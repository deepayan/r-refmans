<!DOCTYPE html><html><head><title>Help for package AzureKeyVault</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {AzureKeyVault}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#az_key_vault'><p>Key vault resource class</p></a></li>
<li><a href='#AzureKeyVault'><p>Azure Key Vault endpoint class</p></a></li>
<li><a href='#cert_key_properties'><p>Helper functions for key vault objects</p></a></li>
<li><a href='#certificate'><p>Certificate object</p></a></li>
<li><a href='#certificates'><p>Certificates in Key Vault</p></a></li>
<li><a href='#create_key_vault'><p>Create Azure key vault</p></a></li>
<li><a href='#delete_key_vault'><p>Delete an Azure Key Vault</p></a></li>
<li><a href='#get_key_vault'><p>Get existing Azure Key Vault</p></a></li>
<li><a href='#key'><p>Encryption key object</p></a></li>
<li><a href='#key_vault'><p>Azure Key Vault client</p></a></li>
<li><a href='#keys'><p>Encryption keys in Key Vault</p></a></li>
<li><a href='#list_deleted_key_vaults'><p>List soft-deleted Key Vaults</p></a></li>
<li><a href='#purge_key_vault'><p>Purge a deleted Azure Key Vault</p></a></li>
<li><a href='#secrets'><p>Stored secrets in Key Vault</p></a></li>
<li><a href='#storage_account'><p>Managed storage account</p></a></li>
<li><a href='#storage_accounts'><p>Storage accounts in Key Vault</p></a></li>
<li><a href='#vault_access_policy'><p>Specify a key vault access policy</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Key and Secret Management in 'Azure'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Manage keys, certificates, secrets, and storage accounts in Microsoft's 'Key Vault' service: <a href="https://azure.microsoft.com/services/key-vault/">https://azure.microsoft.com/services/key-vault/</a>. Provides facilities to store and retrieve secrets, use keys to encrypt, decrypt, sign and verify data, and manage certificates. Integrates with the 'AzureAuth' package to enable authentication with a certificate, and with the 'openssl' package for importing and exporting cryptographic objects. Part of the 'AzureR' family of packages.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Azure/AzureKeyVault">https://github.com/Azure/AzureKeyVault</a>
<a href="https://github.com/Azure/AzureR">https://github.com/Azure/AzureR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Azure/AzureKeyVault/issues">https://github.com/Azure/AzureKeyVault/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3),</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, R6, httr, jsonlite, openssl, jose, AzureRMR,
AzureGraph, AzureAuth (&ge; 1.0.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>AzureStor, knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-09-16 14:44:06 UTC; hongo</td>
</tr>
<tr>
<td>Author:</td>
<td>Hong Ooi [aut, cre],
  Microsoft [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hong Ooi &lt;hongooi73@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-09-16 15:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='az_key_vault'>Key vault resource class</h2><span id='topic+az_key_vault'></span>

<h3>Description</h3>

<p>Class representing a key vault, exposing methods for working with it.
</p>


<h3>Methods</h3>

<p>The following methods are available, in addition to those provided by the <a href="AzureRMR.html#topic+az_resource">AzureRMR::az_resource</a> class:
</p>

<ul>
<li> <p><code>new(...)</code>: Initialize a new key vault object. See 'Initialization'.
</p>
</li>
<li> <p><code>add_principal(principal, ...)</code>: Add an access policy for a user or service principal. See 'Access policies' below.
</p>
</li>
<li> <p><code>get_principal(principal)</code>: Retrieve an access policy for a user or service principal.
</p>
</li>
<li> <p><code>remove_principal(principal)</code>: Remove access for a user or service principal.
</p>
</li>
<li> <p><code>get_endpoint()</code>: Return the vault endpoint. See 'Endpoint' below.
</p>
</li></ul>



<h3>Initialization</h3>

<p>Initializing a new object of this class can either retrieve an existing key vault, or create a new vault on the host. The recommended way to initialize an object is via the <code>get_key_vault</code>, <code>create_key_vault</code> or <code>list_key_vaults</code> methods of the <a href="AzureRMR.html#topic+az_resource_group">az_resource_group</a> class, which handle the details automatically.
</p>


<h3>Access policies</h3>

<p>Client access to a key vault is governed by its access policies, which are set on a per-principal basis. Each principal (user or service) can have different permissions granted, for keys, secrets, certificates, and storage accounts.
</p>
<p>To grant access, use the <code>add_principal</code> method. This has signature</p>
<pre>add_principal(principal, tenant = NULL,
              key_permissions = "all",
              secret_permissions = "all",
              certificate_permissions = "all",
              storage_permissions = "all")
</pre>
<p>The <code>principal</code> can be a GUID, an object of class <code>vault_access_policy</code>, or a user, app or service principal object from the AzureGraph package. Note that the app ID of a registered app is not the same as the ID of its service principal.
</p>
<p>The tenant must be a GUID; if this is NULL, it will be taken from the tenant of the key vault resource.
</p>
<p>Here are the possible permissions for keys, secrets, certificates, and storage accounts. The permission &quot;all&quot; means to grant all permissions.
</p>

<ul>
<li><p> Keys: &quot;get&quot;, &quot;list&quot;, &quot;update&quot;, &quot;create&quot;, &quot;import&quot;, &quot;delete&quot;, &quot;recover&quot;, &quot;backup&quot;, &quot;restore&quot;, &quot;decrypt&quot;, &quot;encrypt&quot;, &quot;unwrapkey&quot;, &quot;wrapkey&quot;, &quot;verify&quot;, &quot;sign&quot;, &quot;purge&quot;
</p>
</li>
<li><p> Secrets: &quot;get&quot;, &quot;list&quot;, &quot;set&quot;, &quot;delete&quot;, &quot;recover&quot;, &quot;backup&quot;, &quot;restore&quot;, &quot;purge&quot;
</p>
</li>
<li><p> Certificates: &quot;get&quot;, &quot;list&quot;, &quot;update&quot;, &quot;create&quot;, &quot;import&quot;, &quot;delete&quot;, &quot;recover&quot;, &quot;backup&quot;, &quot;restore&quot;, &quot;managecontacts&quot;, &quot;manageissuers&quot;, &quot;getissuers&quot;, &quot;listissuers&quot;, &quot;setissuers&quot;, &quot;deleteissuers&quot;, &quot;purge&quot;
</p>
</li>
<li><p> Storage accounts: &quot;get&quot;, &quot;list&quot;, &quot;update&quot;, &quot;set&quot;, &quot;delete&quot;, &quot;recover&quot;, &quot;backup&quot;, &quot;restore&quot;, &quot;regeneratekey&quot;, &quot;getsas&quot;, &quot;listsas&quot;, &quot;setsas&quot;, &quot;deletesas&quot;, &quot;purge&quot;
</p>
</li></ul>

<p>To revoke access, use the <code>remove_principal</code> method. To view the current access policy, use <code>get_principal</code> or <code>list_principals</code>.
</p>


<h3>Endpoint</h3>

<p>The client-side interaction with a key vault is via its <em>endpoint</em>, which is usually at the URL <code style="white-space: pre;">&#8288;https://[vaultname].vault.azure.net&#8288;</code>. The <code>get_endpoint</code> method returns an R6 object of class <code>key_vault</code>, which represents the endpoint. Authenticating with the endpoint is done via an OAuth token; the necessary credentials are taken from the current Resource Manager client in use, or you can supply your own.</p>
<pre>get_endpoint(tenant = self$token$tenant,
             app = self$token$client$client_id,
             password = self$token$client$client_secret, ...)
</pre>
<p>To access the key vault independently of Resource Manager (for example if you are a user without admin or owner access to the vault resource), use the <a href="#topic+key_vault">key_vault</a> function.
</p>


<h3>See Also</h3>

<p><a href="#topic+vault_access_policy">vault_access_policy</a>, <a href="#topic+key_vault">key_vault</a>
<a href="#topic+create_key_vault">create_key_vault</a>, <a href="#topic+get_key_vault">get_key_vault</a>, <a href="#topic+delete_key_vault">delete_key_vault</a>,
<a href="AzureGraph.html#topic+graph_login">AzureGraph::get_graph_login</a>, <a href="AzureGraph.html#topic+az_user">AzureGraph::az_user</a>, <a href="AzureGraph.html#topic+az_app">AzureGraph::az_app</a>, <a href="AzureGraph.html#topic+az_service_principal">AzureGraph::az_service_principal</a>
</p>
<p><a href="https://docs.microsoft.com/en-us/azure/key-vault/">Azure Key Vault documentation</a>,
<a href="https://docs.microsoft.com/en-us/rest/api/keyvault">Azure Key Vault API reference</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# recommended way of retrieving a resource: via a resource group object
kv &lt;- resgroup$get_key_vault("mykeyvault")

# list principals that have access to the vault
kv$list_principals()

# grant a user full access (the default)
usr &lt;- AzureGraph::get_graph_login()$
    get_user("username@aadtenant.com")
kv$add_principal(usr)

# grant a service principal read access to keys and secrets only
svc &lt;- AzureGraph::get_graph_login()$
    get_service_principal(app_id="app_id")
kv$add_principal(svc,
    key_permissions=c("get", "list"),
    secret_permissions=c("get", "list"),
    certificate_permissions=NULL,
    storage_permissions=NULL)
# alternatively, supply a vault_access_policy with the listed permissions
pol &lt;- vault_access_policy(svc,
    key_permissions=c("get", "list"),
    secret_permissions=c("get", "list"),
    certificate_permissions=NULL,
    storage_permissions=NULL)
kv$add_principal(pol)

# revoke access
kv$remove_access(svc)

# get the endpoint object
vault &lt;- kv$get_endpoint()


## End(Not run)
</code></pre>

<hr>
<h2 id='AzureKeyVault'>Azure Key Vault endpoint class</h2><span id='topic+AzureKeyVault'></span>

<h3>Description</h3>

<p>Class representing the client endpoint for a key vault, exposing methods for working with it. Use the <code style="white-space: pre;">&#8288;[key_vault]&#8288;</code> function to instantiate new objects of this class.
</p>


<h3>Fields</h3>


<ul>
<li> <p><code>keys</code>: A sub-object for working with encryption keys stored in the vault. See <a href="#topic+keys">keys</a>.
</p>
</li>
<li> <p><code>secrets</code>: A sub-object for working with secrets stored in the vault. See <a href="#topic+secrets">secrets</a>.
</p>
</li>
<li> <p><code>certificates</code>: A sub-object for working with certificates stored in the vault. See <a href="#topic+certificates">certificates</a>.
</p>
</li>
<li> <p><code>storage</code>: A sub-object for working with storage accounts managed by the vault. See <a href="#topic+storage">storage</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+key_vault">key_vault</a>, <a href="#topic+keys">keys</a>, <a href="#topic+secrets">secrets</a>, <a href="#topic+certificates">certificates</a>, <a href="#topic+storage">storage</a>
</p>
<p><a href="https://docs.microsoft.com/en-us/azure/key-vault/">Azure Key Vault documentation</a>,
<a href="https://docs.microsoft.com/en-us/rest/api/keyvault">Azure Key Vault API reference</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

key_vault("mykeyvault")
key_vault("https://mykeyvault.vault.azure.net")

# authenticating as a service principal
key_vault("mykeyvault", tenant="myaadtenant", app="app_id", password="password")

# authenticating with an existing token
token &lt;- AzureAuth::get_azure_token("https://vault.azure.net", "myaadtenant",
                                    app="app_id", password="password")
key_vault("mykeyvault", token=token)


## End(Not run)
</code></pre>

<hr>
<h2 id='cert_key_properties'>Helper functions for key vault objects</h2><span id='topic+cert_key_properties'></span><span id='topic+cert_x509_properties'></span><span id='topic+cert_issuer_properties'></span><span id='topic+cert_expiry_action'></span><span id='topic+vault_object_attrs'></span>

<h3>Description</h3>

<p>Helper functions for key vault objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cert_key_properties(
  type = c("RSA", "EC"),
  hardware = FALSE,
  ec_curve = NULL,
  rsa_key_size = NULL,
  key_exportable = TRUE,
  reuse_key = FALSE
)

cert_x509_properties(
  dns_names = character(),
  emails = character(),
  upns = character(),
  key_usages = c("digitalSignature", "keyEncipherment"),
  enhanced_key_usages = c("1.3.6.1.5.5.7.3.1", "1.3.6.1.5.5.7.3.2"),
  validity_months = NULL
)

cert_issuer_properties(issuer = "self", cert_type = NULL, transparent = NULL)

cert_expiry_action(remaining = 0.1, action = c("AutoRenew", "EmailContacts"))

vault_object_attrs(
  enabled = TRUE,
  expiry_date = NULL,
  activation_date = NULL,
  recovery_level = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cert_key_properties_+3A_type">type</code></td>
<td>
<p>For <code>cert_key_properties</code>, the type of key to create: RSA or elliptic curve (EC). Note that for keys backing a certificate, only RSA is allowed.</p>
</td></tr>
<tr><td><code id="cert_key_properties_+3A_hardware">hardware</code></td>
<td>
<p>For <code>cert_key_properties</code>, whether to use a hardware key or software key. The former requires a premium key vault.</p>
</td></tr>
<tr><td><code id="cert_key_properties_+3A_ec_curve">ec_curve</code></td>
<td>
<p>For an EC key, the type of elliptic curve.</p>
</td></tr>
<tr><td><code id="cert_key_properties_+3A_rsa_key_size">rsa_key_size</code></td>
<td>
<p>For an RSA key, the key size, either 2048, 3072 or 4096.</p>
</td></tr>
<tr><td><code id="cert_key_properties_+3A_key_exportable">key_exportable</code></td>
<td>
<p>For a key used in a certificate, whether it should be exportable.</p>
</td></tr>
<tr><td><code id="cert_key_properties_+3A_reuse_key">reuse_key</code></td>
<td>
<p>For a key used in a certificate, whether it should be reused when renewing the certificate.</p>
</td></tr>
<tr><td><code id="cert_key_properties_+3A_dns_names">dns_names</code>, <code id="cert_key_properties_+3A_emails">emails</code>, <code id="cert_key_properties_+3A_upns">upns</code></td>
<td>
<p>For <code>cert_x509_properties</code>, the possible subject alternative names (SANs) for a certificate. These should be character vectors.</p>
</td></tr>
<tr><td><code id="cert_key_properties_+3A_key_usages">key_usages</code></td>
<td>
<p>For <code>cert_x509_properties</code>, a character vector of key usages.</p>
</td></tr>
<tr><td><code id="cert_key_properties_+3A_enhanced_key_usages">enhanced_key_usages</code></td>
<td>
<p>For <code>cert_x509_properties</code>, a character vector of enhanced key usages (EKUs).</p>
</td></tr>
<tr><td><code id="cert_key_properties_+3A_validity_months">validity_months</code></td>
<td>
<p>For <code>cert_x509_properties</code>, the number of months the certificate should be valid for.</p>
</td></tr>
<tr><td><code id="cert_key_properties_+3A_issuer">issuer</code></td>
<td>
<p>For <code>cert_issuer_properties</code>, the name of the issuer. Defaults to &quot;self&quot; for a self-signed certificate.</p>
</td></tr>
<tr><td><code id="cert_key_properties_+3A_cert_type">cert_type</code></td>
<td>
<p>For <code>cert_issuer_properties</code>, the type of certificate to issue, eg &quot;OV-SSL&quot;, &quot;DV-SSL&quot; or &quot;EV-SSL&quot;.</p>
</td></tr>
<tr><td><code id="cert_key_properties_+3A_transparent">transparent</code></td>
<td>
<p>For <code>cert_issuer_properties</code>, whether the certificate should be transparent.</p>
</td></tr>
<tr><td><code id="cert_key_properties_+3A_remaining">remaining</code></td>
<td>
<p>For <code>cert_expiry_action</code>, The remaining certificate lifetime at which to take action. If this is a number between 0 and 1, it is interpreted as the percentage of life remaining; otherwise, the number of days remaining. To disable expiry actions, set this to NULL.</p>
</td></tr>
<tr><td><code id="cert_key_properties_+3A_action">action</code></td>
<td>
<p>For <code>cert_expiry_action</code>, what action to take when a certificate is about to expire. Can be either &quot;AutoRenew&quot; or &quot;EmailContacts&quot;. Ignored if <code>remaining == NULL</code>.</p>
</td></tr>
<tr><td><code id="cert_key_properties_+3A_enabled">enabled</code></td>
<td>
<p>For <code>vault_object_attrs</code>, whether this stored object (key, secret, certificate, storage account) is enabled.</p>
</td></tr>
<tr><td><code id="cert_key_properties_+3A_expiry_date">expiry_date</code>, <code id="cert_key_properties_+3A_activation_date">activation_date</code></td>
<td>
<p>For <code>vault_object_attrs</code>, the optional expiry date and activation date of the stored object. Can be any R object that can be coerced to POSIXct format.</p>
</td></tr>
<tr><td><code id="cert_key_properties_+3A_recovery_level">recovery_level</code></td>
<td>
<p>For <code>vault_object_attrs</code>, the recovery level for the stored object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are convenience functions for specifying the properties of objects stored in a key vault. They return lists of fields to pass to the REST API.
</p>

<hr>
<h2 id='certificate'>Certificate object</h2><span id='topic+certificate'></span><span id='topic+cert'></span>

<h3>Description</h3>

<p>This class represents a certificate stored in a vault. It provides methods for carrying out operations, including encryption and decryption, signing and verification, and wrapping and unwrapping.
</p>


<h3>Fields</h3>

<p>This class provides the following fields:
</p>

<ul>
<li> <p><code>cer</code>: The contents of the certificate, in CER format.
</p>
</li>
<li> <p><code>id</code>: The ID of the certificate.
</p>
</li>
<li> <p><code>kid</code>: The ID of the key backing the certificate.
</p>
</li>
<li> <p><code>sid</code>: The ID of the secret backing the certificate.
</p>
</li>
<li> <p><code>contentType</code>: The content type of the secret backing the certificate.
</p>
</li>
<li> <p><code>policy</code>: The certificate management policy, containing the authentication details.
</p>
</li>
<li> <p><code>x5t</code>: The thumbprint of the certificate.
</p>
</li></ul>



<h3>Methods</h3>

<p>This class provides the following methods:</p>
<pre>export(file)
export_cer(file)
sign(digest, ...)
verify(signature, digest, ...)
set_policy(subject=NULL, x509=NULL, issuer=NULL,
           key=NULL, secret_type=NULL, actions=NULL,
           attributes=NULL, wait=TRUE)
get_policy()
sync()

update_attributes(attributes=vault_object_attrs(), ...)
list_versions()
set_version(version=NULL)
delete(confirm=TRUE)
</pre>


<h3>Arguments</h3>


<ul>
<li> <p><code>file</code>: For <code>export</code> and <code>export_cer</code>, a connection object or a character string naming a file to export to.
</p>
</li>
<li> <p><code>digest</code>: For <code>sign</code>, a hash digest string to sign. For <code>verify</code>, a digest to compare to a signature.
</p>
</li>
<li> <p><code>signature</code>: For <code>verify</code>, a signature string.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;subject,x509,issuer,key,secret_type,actions,wait&#8288;</code>: These are the same arguments as used when creating a new certificate. See <a href="#topic+certificates">certificates</a> for more information.
</p>
</li>
<li> <p><code>attributes</code>: For <code>update_attributes</code>, the new attributes for the object, such as the expiry date and activation date. A convenient way to provide this is via the <a href="#topic+vault_object_attrs">vault_object_attrs</a> helper function.
</p>
</li>
<li> <p><code>...</code>: For <code>update_attributes</code>, additional key-specific properties to update. For <code>sign</code> and <code>verify</code>, additional arguments for the corresponding key object methods. See <a href="#topic+keys">keys</a> and <a href="#topic+key">key</a>.
</p>
</li>
<li> <p><code>version</code>: For <code>set_version</code>, the version ID or NULL for the current version.
</p>
</li>
<li> <p><code>confirm</code>: For <code>delete</code>, whether to ask for confirmation before deleting the key.
</p>
</li></ul>



<h3>Details</h3>

<p><code>export</code> exports the full certificate to a file. The format wll be either PEM or PFX (aka PKCS#12), as set by the <code>format</code> argument when the certificate was created. <code>export_cer</code> exports the public key component, aka the CER file. Note that the public key can also be found in the <code>cer</code> field of the object.
</p>
<p><code>sign</code> uses the key associated with the a certificate to sign a digest, and <code>verify</code> checks a signature against a digest for authenticity. See below for an example of using <code>sign</code> to do OAuth authentication with certificate credentials.
</p>
<p><code>set_policy</code> updates the authentication details of a certificate: its issuer, identity, key type, renewal actions, and so on. <code>get_policy</code> returns the current policy of a certificate.
</p>
<p>A certificate can have multiple <em>versions</em>, which are automatically generated when a cert is created with the same name as an existing cert. By default, this object contains the information for the most recent (current) version; use <code>list_versions</code> and <code>set_version</code> to change the version.
</p>


<h3>Value</h3>

<p>For <code>get_policy</code>, a list of certificate policy details.
</p>
<p>For <code>list_versions</code>, a data frame containing details of each version.
</p>
<p>For <code>set_version</code>, the key object with the updated version.
</p>


<h3>See Also</h3>

<p><a href="#topic+certificates">certificates</a>
</p>
<p><a href="https://docs.microsoft.com/en-us/azure/key-vault/">Azure Key Vault documentation</a>,
<a href="https://docs.microsoft.com/en-us/rest/api/keyvault">Azure Key Vault API reference</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

vault &lt;- key_vault("mykeyvault")

cert &lt;- vault$certificates$create("mynewcert")
cert$cer
cert$export("mynewcert.pem")

# new version of an existing certificate
vault$certificates$create("mynewcert", x509=cert_x509_properties(validity_months=24))

cert &lt;- vault$certificates$get("mynewcert")
vers &lt;- cert$list_versions()
cert$set_version(vers[2])

# updating an existing cert version
cert$set_policy(x509=cert_x509_properties(validity_months=12))


## signing a JSON web token (JWT) for authenticating with Azure Active Directory
app &lt;- "app_id"
tenant &lt;- "tenant_id"
claim &lt;- jose::jwt_claim(
    iss=app,
    sub=app,
    aud="https://login.microsoftonline.com/tenant_id/oauth2/token",
    exp=as.numeric(Sys.time() + 60*60),
    nbf=as.numeric(Sys.time())
)
# header includes cert thumbprint
header &lt;- list(alg="RS256", typ="JWT", x5t=cert$x5t)

token_encode &lt;- function(x)
{
    jose::base64url_encode(jsonlite::toJSON(x, auto_unbox=TRUE))
}
token_contents &lt;- paste(token_encode(header), token_encode(claim), sep=".")

# get the signature and concatenate it with header and claim to form JWT
sig &lt;- cert$sign(openssl::sha256(charToRaw(token_contents)))
cert_creds &lt;- paste(token_contents, sig, sep=".")

AzureAuth::get_azure_token("resource_url", tenant, app, certificate=cert_creds)


## End(Not run)
</code></pre>

<hr>
<h2 id='certificates'>Certificates in Key Vault</h2><span id='topic+certificates'></span><span id='topic+certs'></span>

<h3>Description</h3>

<p>This class represents the collection of certificates stored in a vault. It provides methods for managing certificates, including creating, importing and deleting certificates, and doing backups and restores. For operations with a specific certificate, see <a href="#topic+certificate">certificate</a>.
</p>


<h3>Methods</h3>

<p>This class provides the following methods:</p>
<pre>create(name, subject, x509=cert_x509_properties(), issuer=cert_issuer_properties(),
       key=cert_key_properties(), format=c("pem", "pkcs12"),
       expiry_action=cert_expiry_action(),
       attributes=vault_object_attrs(),
       ..., wait=TRUE)
import(name, value, pwd=NULL,
       attributes=vault_object_attrs(),
       ..., wait=TRUE)
get(name)
delete(name, confirm=TRUE)
list()
backup(name)
restore(backup)
get_contacts()
set_contacts(email)
add_issuer(issuer, provider, credentials=NULL, details=NULL)
remove_issuer(issuer)
get_issuer(issuer)
list_issuers()
</pre>


<h3>Arguments</h3>


<ul>
<li> <p><code>name</code>: The name of the certificate.
</p>
</li>
<li> <p><code>subject</code>: For <code>create</code>, The subject or X.500 distinguished name for the certificate.
</p>
</li>
<li> <p><code>x509</code>: Other X.509 properties for the certificate, such as the domain name(s) and validity period. A convenient way to provide this is via the <a href="#topic+cert_x509_properties">cert_x509_properties</a> helper function.
</p>
</li>
<li> <p><code>issuer</code>: Issuer properties for the certificate. A convenient way to provide this is via the <a href="#topic+cert_issuer_properties">cert_issuer_properties</a> helper function. The default is to specify a self-signed certificate.
</p>
</li>
<li> <p><code>key</code>: Key properties for the certificate. A convenient way to provide this is via the <a href="#topic+cert_key_properties">cert_key_properties</a> helper function.
</p>
</li>
<li> <p><code>format</code>: The format to store the certificate in. Can be either PEM or PFX, aka PKCS#12. This also determines the format in which the certificate will be exported (see <a href="#topic+certificate">certificate</a>).
</p>
</li>
<li> <p><code>expiry_action</code>: What Key Vault should do when the certificate is about to expire. A convenient way to provide this is via the <a href="#topic+cert_expiry_action">cert_expiry_action</a> helper function.
</p>
</li>
<li> <p><code>attributes</code>: Optional attributes for the secret. A convenient way to provide this is via the <a href="#topic+vault_object_attrs">vault_object_attrs</a> helper function.
</p>
</li>
<li> <p><code>value</code>: For <code>import</code>, the certificate to import. This can be the name of a PFX file, or a raw vector with the contents of the file.
</p>
</li>
<li> <p><code>pwd</code>: For <code>import</code>, the password if the imported certificate is password-protected.
</p>
</li>
<li> <p><code>...</code>: For <code>create</code> and <code>import</code>, other named arguments which will be treated as tags.
</p>
</li>
<li> <p><code>wait</code>: For <code>create</code> and <code>import</code>, whether to wait until the certificate has been created before returning. If FALSE, you can check on the status of the certificate via the returned object's <code>sync</code> method.
</p>
</li>
<li> <p><code>backup</code>: For <code>restore</code>, a string representing the backup blob for a key.
</p>
</li>
<li> <p><code>email</code>: For <code>set_contacts</code>, the email addresses of the contacts.
</p>
</li>
<li> <p><code>issuer</code>: For the issuer methods, the name by which to refer to an issuer.
</p>
</li>
<li> <p><code>provider</code>: For <code>add_issuer</code>, the provider name as a string.
</p>
</li>
<li> <p><code>credentials</code>: For <code>add_issuer</code>, the credentials for the issuer, if required. Should be a list containing the components <code>account_id</code> and <code>password</code>.
</p>
</li>
<li> <p><code>details</code>: For <code>add_issuer</code>, the organisation details, if required. See the <a href="https://docs.microsoft.com/en-us/rest/api/keyvault/setcertificateissuer/setcertificateissuer#administratordetails">Azure docs</a> for more information.
</p>
</li></ul>



<h3>Value</h3>

<p>For <code>get</code>, <code>create</code> and <code>import</code>, an object of class <code>stored_certificate</code>, representing the certificate itself.
</p>
<p>For <code>list</code>, a vector of key names.
</p>
<p>For <code>add_issuer</code> and <code>get_issuer</code>, an object representing an issuer. For <code>list_issuers</code>, a vector of issuer names.
</p>
<p>For <code>backup</code>, a string representing the backup blob for a certificate. If the certificate has multiple versions, the blob will contain all versions.
</p>


<h3>See Also</h3>

<p><a href="#topic+certificate">certificate</a>, <a href="#topic+cert_key_properties">cert_key_properties</a>, <a href="#topic+cert_x509_properties">cert_x509_properties</a>, <a href="#topic+cert_issuer_properties">cert_issuer_properties</a>, <a href="#topic+vault_object_attrs">vault_object_attrs</a>
</p>
<p><a href="https://docs.microsoft.com/en-us/azure/key-vault/">Azure Key Vault documentation</a>,
<a href="https://docs.microsoft.com/en-us/rest/api/keyvault">Azure Key Vault API reference</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

vault &lt;- key_vault("mykeyvault")

vault$certificates$create("mynewcert", "CN=mydomain.com")
vault$certificates$list()
vault$certificates$get("mynewcert")

# specifying some domain names
vault$certificates$create("mynewcert", "CN=mydomain.com",
    x509=cert_x509_properties(dns_names=c("mydomain.com", "otherdomain.com")))

# specifying a validity period of 2 years (24 months)
vault$certificates$create("mynewcert", "CN=mydomain.com",
    x509=cert_x509_properties(validity_months=24))

# setting management tags
vault$certificates$create("mynewcert", "CN=mydomain.com", tag1="a value", othertag="another value")

# importing a cert from a PFX file
vault$certificates$import("importedcert", "mycert.pfx")

# backup and restore a cert
bak &lt;- vault$certificates$backup("mynewcert")
vault$certificates$delete("mynewcert", confirm=FALSE)
vault$certificates$restore(bak)

# set a contact
vault$certificates$set_contacts("username@mydomain.com")
vault$certificates$get_contacts()

# add an issuer and then obtain a cert
# this can take a long time, so set wait=FALSE to return immediately
vault$certificates$add_issuer("newissuer", provider="OneCert")
vault$certificates$create("issuedcert", "CN=mydomain.com",
    issuer=cert_issuer_properties("newissuer"),
    wait=FALSE)


## End(Not run)
</code></pre>

<hr>
<h2 id='create_key_vault'>Create Azure key vault</h2><span id='topic+create_key_vault'></span>

<h3>Description</h3>

<p>Method for the <a href="AzureRMR.html#topic+az_resource_group">AzureRMR::az_resource_group</a> class.
</p>


<h3>Usage</h3>

<pre>create_key_vault(name, location = self$location, initial_access = default_access(),
                 sku = "Standard", ..., wait = TRUE)
</pre>


<h3>Arguments</h3>


<ul>
<li> <p><code>name</code>: The name of the key vault.
</p>
</li>
<li> <p><code>location</code>: The location/region in which to create the account. Defaults to the resource group location.
</p>
</li>
<li> <p><code>initial_access</code>: The user or service principals that will have access to the vault. This should be a list of objects of type <code style="white-space: pre;">&#8288;[vault_access_policy]&#8288;</code>, created by the function of the same name. The default is to grant access to the logged-in user or service principal of the current Resource Manager client.
</p>
</li>
<li> <p><code>sku</code>: The sku for the vault. Set this to &quot;Premium&quot; to enable the use of hardware security modules (HSMs).
</p>
</li>
<li> <p><code>allow_vm_access</code>: Whether to allow Azure virtual machines to retrieve certificates from the vault.
</p>
</li>
<li> <p><code>allow_arm_access</code>: Whether to allow Azure Resource Manager to retrieve secrets from the vault for template deployment purposes.
</p>
</li>
<li> <p><code>allow_disk_encryption_access</code>: Whether to allow Azure Disk Encryption to retrieve secrets and keys from the vault.
</p>
</li>
<li> <p><code>soft_delete</code>: Whether soft-deletion should be enabled for this vault. Soft-deletion is a feature which protects both the vault itself and its contents from accidental/malicious deletion; see below.
</p>
</li>
<li> <p><code>purge_protection</code>: Whether purge protection is enabled. If this is TRUE and soft-deletion is enabled for the vault, manual purges are not allowed. Has no effect if <code>soft_delete=FALSE</code>.
</p>
</li>
<li> <p><code>...</code>: Other named arguments to pass to the <a href="#topic+az_key_vault">az_key_vault</a> initialization function.
</p>
</li>
<li> <p><code>wait</code>: Whether to wait for the resource creation to complete before returning.
</p>
</li></ul>



<h3>Details</h3>

<p>This method deploys a new key vault resource, with parameters given by the arguments. A key vault is a secure facility for storing and managing encryption keys, certificates, storage account keys, and generic secrets.
</p>
<p>A new key vault will have access granted to the user or service principal used to sign in to the Azure Resource Manager client. To manage access policies after creation, use the <code>add_principal</code>, <code>list_principals</code> and <code>remove_principal</code> methods of the key vault object.
</p>
<p>Key Vault's soft delete feature allows recovery of the deleted vaults and vault objects, known as soft-delete. Specifically, it addresses the following scenarios:
</p>

<ul>
<li><p> Support for recoverable deletion of a key vault
</p>
</li>
<li><p> Support for recoverable deletion of key vault objects (keys, secrets, certificates)
</p>
</li></ul>

<p>With this feature, the delete operation on a key vault or key vault object is a soft-delete, effectively holding the resources for a given retention period (90 days), while giving the appearance that the object is deleted. The service further provides a mechanism for recovering the deleted object, essentially undoing the deletion.
</p>
<p>Soft-deleted vaults can be purged (permanently removed) by calling the <code>purge_key_vault</code> method for the resource group or subscription classes. The purge protection optional feature provides an additional layer of protection by forbidding manual purges; when this is on, a vault or an object in deleted state cannot be purged until the retention period of 90 days has passed.
</p>
<p>To see what soft-deleted key vaults exist, call the <code>list_deleted_key_vaults</code> method. To recover a soft-deleted key vault, call the <code>create_key_vault</code> method from the vault's original resource group, with the vault name. To purge (permanently delete) it, call the <code>purge_key_vault</code> method.
</p>


<h3>Value</h3>

<p>An object of class <code>az_key_vault</code> representing the created key vault.
</p>


<h3>See Also</h3>

<p><a href="#topic+get_key_vault">get_key_vault</a>, <a href="#topic+delete_key_vault">delete_key_vault</a>, <a href="#topic+purge_key_vault">purge_key_vault</a>, <a href="#topic+az_key_vault">az_key_vault</a>, <a href="#topic+vault_access_policy">vault_access_policy</a>
</p>
<p><a href="https://docs.microsoft.com/en-us/azure/key-vault/">Azure Key Vault documentation</a>,
<a href="https://docs.microsoft.com/en-us/rest/api/keyvault">Azure Key Vault API reference</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

rg &lt;- AzureRMR::get_azure_login()$
    get_subscription("subscription_id")$
    get_resource_group("rgname")

# create a new key vault
rg$create_key_vault("mykeyvault")

# create a new key vault, and grant access to a service principal
gr &lt;- AzureGraph::get_graph_login()
svc &lt;- gr$get_service_principal("app_id")
rg$create_key_vault("mykeyvault",
    initial_access=list(vault_access_policy(svc, tenant=NULL)))


## End(Not run)
</code></pre>

<hr>
<h2 id='delete_key_vault'>Delete an Azure Key Vault</h2><span id='topic+delete_key_vault'></span>

<h3>Description</h3>

<p>Method for the <a href="AzureRMR.html#topic+az_resource_group">AzureRMR::az_resource_group</a> class.
</p>


<h3>Details</h3>

<p>Deleting a key vault that has soft-deletion enabled does not permanently remove it. Instead the resource is held for a given retention period (90 days), during which it can be recovered, essentially undoing the deletion.
</p>
<p>To see what soft-deleted key vaults exist, call the <code>list_deleted_key_vaults</code> method. To recover a soft-deleted key vault, call the <code>create_key_vault</code> method from the vault's original resource group, with the vault name. To purge (permanently delete) it, call the <code>purge_key_vault</code> method.
</p>


<h3>Usage</h3>

<pre>delete_key_vault(name, confirm=TRUE, wait=FALSE, purge=FALSE)
</pre>


<h3>Arguments</h3>


<ul>
<li> <p><code>name</code>: The name of the key vault.
</p>
</li>
<li> <p><code>confirm</code>: Whether to ask for confirmation before deleting.
</p>
</li>
<li> <p><code>wait</code>: Whether to wait until the deletion is complete. Note that <code>purge=TRUE</code> will set <code>wait=TRUE</code> as well.
</p>
</li>
<li> <p><code>purge</code>: For a vault with the soft-deletion feature enabled, whether to purge it as well (hard delete). Has no effect if the vault does not have soft-deletion enabled.
</p>
</li></ul>



<h3>Value</h3>

<p>NULL on successful deletion.
</p>


<h3>See Also</h3>

<p><a href="#topic+create_key_vault">create_key_vault</a>, <a href="#topic+get_key_vault">get_key_vault</a>, <a href="#topic+purge_key_vault">purge_key_vault</a>, <a href="#topic+list_deleted_key_vaults">list_deleted_key_vaults</a>, <a href="#topic+az_key_vault">az_key_vault</a>,
</p>
<p><a href="https://docs.microsoft.com/en-us/azure/key-vault/">Azure Key Vault documentation</a>,
<a href="https://docs.microsoft.com/en-us/rest/api/keyvault">Azure Key Vault API reference</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

rg &lt;- AzureRMR::get_azure_login()$
    get_subscription("subscription_id")$
    get_resource_group("rgname")

# assuming the vault has soft-delete enabled
rg$delete_key_vault("mykeyvault", purge=FALSE)

# recovering a soft-deleted key vault
rg$create_key_vault("mykeyvault")

# deleting it for good
rg$delete_key_vault("mykeyvault", purge=FALSE)


## End(Not run)
</code></pre>

<hr>
<h2 id='get_key_vault'>Get existing Azure Key Vault</h2><span id='topic+get_key_vault'></span><span id='topic+list_key_vaults'></span>

<h3>Description</h3>

<p>Methods for the <a href="AzureRMR.html#topic+az_resource_group">AzureRMR::az_resource_group</a> class.
</p>


<h3>Usage</h3>

<pre>get_key_vault(name)
list_key_vaults()
</pre>


<h3>Arguments</h3>


<ul>
<li> <p><code>name</code>: For <code>get_key_vault()</code>, the name of the key vault.
</p>
</li></ul>



<h3>Value</h3>

<p>For <code>get_key_vault()</code>, an object of class <code>az_key_vault</code> representing the vault.
</p>
<p>For <code>list_key_vaults()</code>, a list of such objects.
</p>


<h3>See Also</h3>

<p><a href="#topic+create_key_vault">create_key_vault</a>, <a href="#topic+delete_key_vault">delete_key_vault</a>, <a href="#topic+az_key_vault">az_key_vault</a>
</p>
<p><a href="https://docs.microsoft.com/en-us/azure/key-vault/">Azure Key Vault documentation</a>,
<a href="https://docs.microsoft.com/en-us/rest/api/keyvault">Azure Key Vault API reference</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

rg &lt;- AzureRMR::get_azure_login()$
    get_subscription("subscription_id")$
    get_resource_group("rgname")

rg$list_key_vaults()

rg$get_key_vault("mykeyvault")


## End(Not run)
</code></pre>

<hr>
<h2 id='key'>Encryption key object</h2><span id='topic+key'></span>

<h3>Description</h3>

<p>This class represents an encryption key stored in a vault. It provides methods for carrying out operations, including encryption and decryption, signing and verification, and wrapping and unwrapping.
</p>


<h3>Fields</h3>

<p>This class provides the following fields:
</p>

<ul>
<li> <p><code>key</code>: The key details as a parsed JSON web key (JWK).
</p>
</li>
<li> <p><code>managed</code>: Whether this key's lifetime is managed by Key Vault. TRUE if the key backs a certificate.
</p>
</li></ul>



<h3>Methods</h3>

<p>This class provides the following methods:</p>
<pre>encrypt(plaintext, algorithm=c("RSA-OAEP", "RSA-OAEP-256", "RSA1_5"))
decrypt(ciphertext, algorithm=c("RSA-OAEP", "RSA-OAEP-256", "RSA1_5"), as_raw=TRUE)
sign(digest,
     algorithm=c("RS256", "RS384", "RS512", "PS256", "PS384", "PS512",
                 "ES256", "ES256K", "ES384", "ES512"))
verify(signature, digest,
       algorithm=c("RS256", "RS384", "RS512", "PS256", "PS384", "PS512",
                   "ES256", "ES256K", "ES384", "ES512"))
wrap(value, algorithm=c("RSA-OAEP", "RSA-OAEP-256", "RSA1_5"))
unwrap(value, algorithm=c("RSA-OAEP", "RSA-OAEP-256", "RSA1_5"), as_raw=TRUE)

update_attributes(attributes=vault_object_attrs(), ...)
list_versions()
set_version(version=NULL)
delete(confirm=TRUE)
</pre>


<h3>Arguments</h3>


<ul>
<li> <p><code>plaintext</code>: For <code>encrypt</code>, the plaintext to encrypt.
</p>
</li>
<li> <p><code>ciphertext</code>: For <code>decrypt</code>, the ciphertext to decrypt.
</p>
</li>
<li> <p><code>digest</code>: For <code>sign</code>, a generated hash to sign. For <code>verify</code>, the digest to verify for authenticity.
</p>
</li>
<li> <p><code>signature</code>: For <code>verify</code>, a signature to verify for authenticity.
</p>
</li>
<li> <p><code>value</code>: For <code>wrap</code>, a symmetric key to be wrapped; for <code>unwrap</code>, the value to be unwrapped to obtain the symmetric key.
</p>
</li>
<li> <p><code>as_raw</code>: For <code>decrypt</code> and <code>unwrap</code>, whether to return a character vector or a raw vector (the default).
</p>
</li>
<li> <p><code>algorithm</code>: The algorithm to use for each operation. Note that the algorithm must be compatible with the key type, eg RSA keys cannot use ECDSA for signing or verifying.
</p>
</li>
<li> <p><code>attributes</code>: For <code>update_attributes</code>, the new attributes for the object, such as the expiry date and activation date. A convenient way to provide this is via the <a href="#topic+vault_object_attrs">vault_object_attrs</a> helper function.
</p>
</li>
<li> <p><code>...</code>: For <code>update_attributes</code>, additional key-specific properties to update. See <a href="#topic+keys">keys</a>.
</p>
</li>
<li> <p><code>version</code>: For <code>set_version</code>, the version ID or NULL for the current version.
</p>
</li>
<li> <p><code>confirm</code>: For <code>delete</code>, whether to ask for confirmation before deleting the key.
</p>
</li></ul>



<h3>Details</h3>

<p>The operations supported by a key will be those given by the <code>key_ops</code> argument when the key was created. By default, a newly created RSA key supports all the operations listed above: encrypt/decrypt, sign/verify, and wrap/unwrap. An EC key only supports the sign and verify operations.
</p>
<p>A key can have multiple <em>versions</em>, which are automatically generated when a key is created with the same name as an existing key. By default, the most recent (current) version is used for key operations; use <code>list_versions</code> and <code>set_version</code> to change the version.
</p>


<h3>Value</h3>

<p>For the key operations, a raw vector (for <code>decrypt</code> and <code>unwrap</code>, if <code>as_raw=TRUE</code>) or character vector.
</p>
<p>For <code>list_versions</code>, a data frame containing details of each version.
</p>
<p>For <code>set_version</code>, the key object with the updated version.
</p>


<h3>See Also</h3>

<p><a href="#topic+keys">keys</a>
</p>
<p><a href="https://docs.microsoft.com/en-us/azure/key-vault/">Azure Key Vault documentation</a>,
<a href="https://docs.microsoft.com/en-us/rest/api/keyvault">Azure Key Vault API reference</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

vault &lt;- key_vault("mykeyvault")

vault$keys$create("mynewkey")
# new version of an existing key
vault$keys$create("mynewkey", type="RSA", rsa_key_size=4096)

key &lt;- vault$keys$get("mynewkey")
vers &lt;- key$list_versions()
key$set_version(vers[2])

plaintext &lt;- "some secret text"

ciphertext &lt;- key$encrypt(plaintext)
decrypted &lt;- key$decrypt(ciphertext, as_raw=FALSE)
decrypted == plaintext  # TRUE

dig &lt;- openssl::sha2(charToRaw(plaintext))
sig &lt;- key$sign(dig)
key$verify(sig, dig)  # TRUE

wraptext &lt;- key$wrap(plaintext)
unwrap_text &lt;- key$unwrap(wraptext, as_raw=FALSE)
plaintext == unwrap_text  # TRUE


## End(Not run)
</code></pre>

<hr>
<h2 id='key_vault'>Azure Key Vault client</h2><span id='topic+key_vault'></span>

<h3>Description</h3>

<p>Azure Key Vault client
</p>


<h3>Usage</h3>

<pre><code class='language-R'>key_vault(
  url,
  tenant = "common",
  app = .az_cli_app_id,
  ...,
  domain = "vault.azure.net",
  as_managed_identity = FALSE,
  token = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="key_vault_+3A_url">url</code></td>
<td>
<p>The location of the vault. This can be a full URL, or the vault name alone; in the latter case, the <code>domain</code> argument is appended to obtain the URL.</p>
</td></tr>
<tr><td><code id="key_vault_+3A_tenant">tenant</code>, <code id="key_vault_+3A_app">app</code></td>
<td>
<p>Authentication arguments that will be passed to <code><a href="AzureAuth.html#topic+get_azure_token">AzureAuth::get_azure_token</a></code>. The default is to authenticate interactively.</p>
</td></tr>
<tr><td><code id="key_vault_+3A_...">...</code></td>
<td>
<p>Further arguments that will be passed to either <code>get_azure_token</code> or <code><a href="AzureAuth.html#topic+get_azure_token">AzureAuth::get_managed_token</a></code>, depending on whether <code>as_managed_identity</code> is TRUE.</p>
</td></tr>
<tr><td><code id="key_vault_+3A_domain">domain</code></td>
<td>
<p>The domain of the vault; for the public Azure cloud, this is <code>vault.azure.net</code>. Also the resource for OAuth authentication.</p>
</td></tr>
<tr><td><code id="key_vault_+3A_as_managed_identity">as_managed_identity</code></td>
<td>
<p>Whether to authenticate as a managed identity. Use this if your R session is taking place inside an Azure VM or container that has a system- or user-assigned managed identity assigned to it.</p>
</td></tr>
<tr><td><code id="key_vault_+3A_token">token</code></td>
<td>
<p>An OAuth token obtained via <code>get_azure_token</code> or <code>get_managed_token</code>. If provided, this overrides the other authentication arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a new Key Vault client object. It includes the following component objects for working with data in the vault:
</p>

<ul>
<li> <p><code>keys</code>: A sub-object for working with encryption keys stored in the vault. See <a href="#topic+keys">keys</a>.
</p>
</li>
<li> <p><code>secrets</code>: A sub-object for working with secrets stored in the vault. See <a href="#topic+secrets">secrets</a>.
</p>
</li>
<li> <p><code>certificates</code>: A sub-object for working with certificates stored in the vault. See <a href="#topic+certificates">certificates</a>.
</p>
</li>
<li> <p><code>storage</code>: A sub-object for working with storage accounts managed by the vault. See <a href="#topic+storage">storage</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+keys">keys</a></code>, <code><a href="#topic+secrets">secrets</a></code>, <code><a href="#topic+certificates">certificates</a></code>, <code><a href="#topic+storage">storage</a></code>
</p>
<p><a href="https://docs.microsoft.com/en-us/azure/key-vault/">Azure Key Vault documentation</a>,
<a href="https://docs.microsoft.com/en-us/rest/api/keyvault">Azure Key Vault API reference</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

key_vault("mykeyvault")
key_vault("https://mykeyvault.vault.azure.net")

# authenticating as a service principal
key_vault("mykeyvault", tenant="myaadtenant", app="app_id", password="password")

# authenticating with an existing token
token &lt;- AzureAuth::get_azure_token("https://vault.azure.net", "myaadtenant",
                                    app="app_id", password="password")
key_vault("mykeyvault", token=token)

# authenticating with a system-assigned managed identity
key_vault("mykeyvault", as_managed_identity=TRUE)

# authenticating with a user-assigned managed identity:
# - supply one of the identity's object ID, client ID or resource ID
key_vault("mykeyvault", as_managed_identity=TRUE,
    token_args=list(mi_res_id="/subscriptions/xxxx/resourceGroups/resgrpname/..."))


## End(Not run)
</code></pre>

<hr>
<h2 id='keys'>Encryption keys in Key Vault</h2><span id='topic+keys'></span>

<h3>Description</h3>

<p>This class represents the collection of encryption keys stored in a vault. It provides methods for managing keys, including creating, importing and deleting keys, and doing backups and restores. For operations with a specific key, see <a href="#topic+key">key</a>.
</p>


<h3>Methods</h3>

<p>This class provides the following methods:</p>
<pre>create(name, type=c("RSA", "EC"), hardware=FALSE,
       ec_curve=NULL, rsa_key_size=NULL, key_ops=NULL,
       attributes=vault_object_attrs(), ...)
import(name, key, hardware=FALSE,
       attributes=vault_object_attrs(), ...)
get(name)
delete(name, confirm=TRUE)
list(include_managed=FALSE)
backup(name)
restore(backup)
</pre>


<h3>Arguments</h3>


<ul>
<li> <p><code>name</code>: The name of the key.
</p>
</li>
<li> <p><code>type</code>: For <code>create</code>, the type of key to create: RSA or elliptic curve (EC). Note that for keys backing a certificate, only RSA is allowed.
</p>
</li>
<li> <p><code>hardware</code>: For <code>create</code>, Whether to use a hardware key or software key. The former requires a premium key vault.
</p>
</li>
<li> <p><code>ec_curve</code>: For an EC key, the type of elliptic curve.
</p>
</li>
<li> <p><code>rsa_key_size</code>: For an RSA key, the key size, either 2048, 3072 or 4096.
</p>
</li>
<li> <p><code>key_ops</code>: A character vector of operations that the key supports. The possible operations are &quot;encrypt&quot;, &quot;decrypt&quot;, &quot;sign&quot;, &quot;verify&quot;, &quot;wrapkey&quot; and &quot;unwrapkey&quot;. See <a href="#topic+key">key</a> for more information.
</p>
</li>
<li> <p><code>attributes</code>: Optional attributes for the key, such as the expiry date and activation date. A convenient way to provide this is via the <a href="#topic+vault_object_attrs">vault_object_attrs</a> helper function.
</p>
</li>
<li> <p><code>key</code>: For <code>import</code>, the key to import. This can be the name of a PEM file, a JSON web key (JWK) string, or a key object generated by the openssl package. See the examples below.
</p>
</li>
<li> <p><code>hardware</code>: For <code>import</code>, whether to import this key as a hardware key (HSM). Only supported for a premium key vault.
</p>
</li>
<li> <p><code>...</code>: For <code>create</code> and <code>import</code>, other named arguments which will be treated as tags.
</p>
</li>
<li> <p><code>include_managed</code>: For <code>list</code>, whether to include keys that were created by Key Vault to support a managed certificate.
</p>
</li>
<li> <p><code>backup</code>: For <code>restore</code>, a string representing the backup blob for a key.
</p>
</li></ul>



<h3>Value</h3>

<p>For <code>get</code>, <code>create</code> and <code>import</code>, an object of class <code>stored_key</code>, representing the key itself. This has methods for carrying out the operations given by the <code>key_ops</code> argument.
</p>
<p>For <code>list</code>, a vector of key names.
</p>
<p>For <code>backup</code>, a string representing the backup blob for a key. If the key has multiple versions, the blob will contain all versions.
</p>


<h3>See Also</h3>

<p><a href="#topic+key">key</a>, <a href="#topic+vault_object_attrs">vault_object_attrs</a>
</p>
<p><a href="https://docs.microsoft.com/en-us/azure/key-vault/">Azure Key Vault documentation</a>,
<a href="https://docs.microsoft.com/en-us/rest/api/keyvault">Azure Key Vault API reference</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

vault &lt;- key_vault("mykeyvault")

vault$keys$create("mynewkey")
vault$keys$create("myRSAkey", type="RSA", rsa_key_size=4096)
vault$keys$create("myECkey", type="EC", ec_curve="P-384")

vault$keys$list()
vault$keys$get("mynewkey")

# specifying an expiry date
today &lt;- Sys.date()
vault$keys$create("mynewkey", attributes=vault_object_attrs(expiry_date=today+365))

# setting management tags
vault$keys$create("mynewkey", tag1="a value", othertag="another value")

# importing a key from a PEM file
vault$keys$import("importedkey1", "myprivatekey.pem")

# importing a key generated by OpenSSL
vault$keys$import("importedkey2", openssl::rsa_keygen())

# importing a JWK (which is a JSON string)
key &lt;- openssl::read_key("myprivatekey.pem")
jwk &lt;- jose::write_jwk(key)
vault$keys$import("importedkey3", jwk)

# backup and restore a key
bak &lt;- vault$keys$backup("mynewkey")
vault$keys$delete("mynewkey", confirm=FALSE)
vault$keys$restore(bak)


## End(Not run)
</code></pre>

<hr>
<h2 id='list_deleted_key_vaults'>List soft-deleted Key Vaults</h2><span id='topic+list_deleted_key_vaults'></span>

<h3>Description</h3>

<p>Method for the <a href="AzureRMR.html#topic+az_subscription">AzureRMR::az_subscription</a> class.
</p>


<h3>Usage</h3>

<pre>list_deleted_key_vaults()
</pre>


<h3>Value</h3>

<p>This method returns a data frame with the following columns:
</p>

<ul>
<li> <p><code>name</code>: The name of the deleted key vault.
</p>
</li>
<li> <p><code>location</code>: The location (region) of the vault.
</p>
</li>
<li> <p><code>deletion_date</code>: When the vault was soft-deleted.
</p>
</li>
<li> <p><code>purge_date</code>: When the vault is scheduled to be purged (permanently deleted).
</p>
</li>
<li> <p><code>protected</code>: Whether the vault has purge protection enabled. If TRUE, manual attempts to purge it will fail.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+create_key_vault">create_key_vault</a>, <a href="#topic+get_key_vault">get_key_vault</a>, <a href="#topic+delete_key_vault">delete_key_vault</a>, <a href="#topic+purge_key_vault">purge_key_vault</a>, <a href="#topic+az_key_vault">az_key_vault</a>,
</p>
<p><a href="https://docs.microsoft.com/en-us/azure/key-vault/">Azure Key Vault documentation</a>,
<a href="https://docs.microsoft.com/en-us/rest/api/keyvault">Azure Key Vault API reference</a>
</p>

<hr>
<h2 id='purge_key_vault'>Purge a deleted Azure Key Vault</h2><span id='topic+purge_key_vault'></span>

<h3>Description</h3>

<p>Method for the <a href="AzureRMR.html#topic+az_subscription">AzureRMR::az_subscription</a> and <a href="AzureRMR.html#topic+az_resource_group">AzureRMR::az_resource_group</a> classes.
</p>


<h3>Details</h3>

<p>This method permanently deletes a soft-deleted key vault. Note that it will fail if the vault has purge protection enabled.
</p>


<h3>Usage</h3>

<pre>purge_key_vault(name, location, confirm=TRUE)
</pre>


<h3>Arguments</h3>


<ul>
<li> <p><code>name</code>,<code>location</code>: The name and location of the key vault.
</p>
</li>
<li> <p><code>confirm</code>: Whether to ask for confirmation before permanently deleting the vault.
</p>
</li></ul>



<h3>Value</h3>

<p>NULL on successful purging.
</p>


<h3>See Also</h3>

<p><a href="#topic+create_key_vault">create_key_vault</a>, <a href="#topic+get_key_vault">get_key_vault</a>, <a href="#topic+delete_key_vault">delete_key_vault</a>, <a href="#topic+list_deleted_key_vaults">list_deleted_key_vaults</a>, <a href="#topic+az_key_vault">az_key_vault</a>,
</p>
<p><a href="https://docs.microsoft.com/en-us/azure/key-vault/">Azure Key Vault documentation</a>,
<a href="https://docs.microsoft.com/en-us/rest/api/keyvault">Azure Key Vault API reference</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

rg &lt;- AzureRMR::get_azure_login()$
    get_subscription("subscription_id")$
    get_resource_group("rgname")

# assuming the vault has soft-delete enabled, and is in the same location as its RG
rg$delete_key_vault("mykeyvault")
rg$purge_key_vault("mykeyvault", rg$location)


## End(Not run)
</code></pre>

<hr>
<h2 id='secrets'>Stored secrets in Key Vault</h2><span id='topic+secrets'></span>

<h3>Description</h3>

<p>This class represents the collection of secrets stored in a vault. It provides methods for managing secrets, including creating, importing and deleting secrets, and doing backups and restores.
</p>


<h3>Methods</h3>

<p>This class provides the following methods:</p>
<pre>create(name, value, content_type=NULL, attributes=vault_object_attrs(), ...)
get(name)
delete(name, confirm=TRUE)
list(include_managed=FALSE)
backup(name)
restore(backup)
</pre>


<h3>Arguments</h3>


<ul>
<li> <p><code>name</code>: The name of the secret.
</p>
</li>
<li> <p><code>value</code>: For <code>create</code>, the secret to store. This should be a character string or a raw vector.
</p>
</li>
<li> <p><code>content_type</code>: For <code>create</code>, an optional content type of the secret, such as &quot;application/octet-stream&quot;.
</p>
</li>
<li> <p><code>attributes</code>: Optional attributes for the secret, such as the expiry date and activation date. A convenient way to provide this is via the <a href="#topic+vault_object_attrs">vault_object_attrs</a> helper function.
</p>
</li>
<li> <p><code>...</code>: For <code>create</code>, other named arguments which will be treated as tags.
</p>
</li>
<li> <p><code>include_managed</code>: For <code>list</code>, whether to include secrets that were created by Key Vault to support a managed certificate.
</p>
</li>
<li> <p><code>backup</code>: For <code>restore</code>, a string representing the backup blob for a secret.
</p>
</li></ul>



<h3>Value</h3>

<p>For <code>get</code>, and <code>create</code>, an object of class <code>stored_secret</code>, representing the secret. The actual value of the secret is in the <code>value</code> field.
</p>
<p>For <code>list</code>, a vector of secret names.
</p>
<p>For <code>backup</code>, a string representing the backup blob for a secret. If the secret has multiple versions, the blob will contain all versions.
</p>


<h3>See Also</h3>

<p><a href="#topic+vault_object_attrs">vault_object_attrs</a>
</p>
<p><a href="https://docs.microsoft.com/en-us/azure/key-vault/">Azure Key Vault documentation</a>,
<a href="https://docs.microsoft.com/en-us/rest/api/keyvault">Azure Key Vault API reference</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

vault &lt;- key_vault("mykeyvault")

vault$secrets$create("mysecret", "secret string")

vault$secrets$list()

secret &lt;- vault$secrets$get("mysecret")
secret$value  # 'secret string'

# specifying an expiry date
today &lt;- Sys.date()
vault$secrets$create("mysecret", attributes=vault_object_attrs(expiry_date=today+365))

# setting management tags
vault$secrets$create("mysecret", tag1="a value", othertag="another value")


## End(Not run)
</code></pre>

<hr>
<h2 id='storage_account'>Managed storage account</h2><span id='topic+storage_account'></span>

<h3>Description</h3>

<p>This class represents a storage account that Key Vault will manage access to. It provides methods for regenerating keys, and managing shared access signatures (SAS).
</p>
<p>This class represents a secret stored in a vault.
</p>


<h3>Fields</h3>

<p>This class provides the following fields:
</p>

<ul>
<li> <p><code>id</code>: The internal vault ID of the storage account.
</p>
</li>
<li> <p><code>resourceId</code>: The Azure resource ID of the storage account.
</p>
</li>
<li> <p><code>activeKeyName</code>: The current active storage account key.
</p>
</li>
<li> <p><code>autoRegenerateKey</code>: Whether Key Vault will manage the storage account's key.
</p>
</li>
<li> <p><code>regenerationPeriod</code>: How often the account key is regenerated, in ISO 8601 format.
</p>
</li></ul>

<p>This class provides the following fields:
</p>

<ul>
<li> <p><code>value</code>: The value of the secret.
</p>
</li>
<li> <p><code>id</code>: The ID of the secret.
</p>
</li>
<li> <p><code>kid</code>: If this secret backs a certificate, the ID of the corresponding key.
</p>
</li>
<li> <p><code>managed</code>: Whether this secret's lifetime is managed by Key Vault. TRUE if the secret backs a certificate.
</p>
</li>
<li> <p><code>contentType</code>: The content type of the secret.
</p>
</li></ul>



<h3>Methods</h3>

<p>This class provides the following methods:</p>
<pre>regenerate_key(key_name)
create_sas_definition(sas_name, sas_template, validity_period, sas_type="account",
                      enabled=TRUE, recovery_level=NULL, ...)
delete_sas_definition(sas_name, confirm=TRUE)
get_sas_definition(sas_name)
list_sas_definitions()
show_sas(sas_name)

update_attributes(attributes=vault_object_attrs(), ...)
remove(confirm=TRUE)
</pre>
<p>This class provides the following methods:</p>
<pre>update_attributes(attributes=vault_object_attrs(), ...)
list_versions()
set_version(version=NULL)
delete(confirm=TRUE)
</pre>


<h3>Arguments</h3>


<ul>
<li> <p><code>key_name</code>: For <code>regenerate_key</code>, the name of the access key to regenerate.
</p>
</li>
<li> <p><code>sas_name</code>: The name of a SAS definition.
</p>
</li>
<li> <p><code>sas_template</code>: A string giving the details of the SAS to create. See 'Details' below.
</p>
</li>
<li> <p><code>validity_period</code>: How long the SAS should be valid for.
</p>
</li>
<li> <p><code>sas_type</code>: The type of SAS to generate, either &quot;account&quot; or &quot;service&quot;.
</p>
</li>
<li> <p><code>enabled</code>: Whether the SAS definition. is enabled.
</p>
</li>
<li> <p><code>recovery_level</code>: The recovery level of the SAS definition.
</p>
</li>
<li> <p><code>...</code>: For <code>create_sas_definition</code>, other named arguments to use as tags for a SAS definition. For <code>update_attributes</code>, additional account-specific properties to update. See <a href="#topic+storage_accounts">storage_accounts</a>.
</p>
</li>
<li> <p><code>attributes</code>: For <code>update_attributes</code>, the new attributes for the object, such as the expiry date and activation date. A convenient way to provide this is via the <a href="#topic+vault_object_attrs">vault_object_attrs</a> helper function.
</p>
</li>
<li> <p><code>confirm</code>: For <code>delete</code> and <code>delete_sas_definition</code>, whether to ask for confirmation before deleting.
</p>
</li></ul>


<ul>
<li> <p><code>attributes</code>: For <code>update_attributes</code>, the new attributes for the object, such as the expiry date and activation date. A convenient way to provide this is via the <a href="#topic+vault_object_attrs">vault_object_attrs</a> helper function.
</p>
</li>
<li> <p><code>...</code>: For <code>update_attributes</code>, additional secret-specific properties to update. See <a href="#topic+secrets">secrets</a>.
</p>
</li>
<li> <p><code>version</code>: For <code>set_version</code>, the version ID or NULL for the current version.
</p>
</li>
<li> <p><code>confirm</code>: For <code>delete</code>, whether to ask for confirmation before deleting the secret.
</p>
</li></ul>



<h3>Details</h3>

<p><code>create_sas_definition</code> creates a new SAS definition from a template. This can be created from the Azure Portal, via the Azure CLI, or in R via the AzureStor package (see examples). <code>get_sas_definition</code> returns a list representing the template definition; <code>show_sas</code> returns the actual SAS.
</p>
<p><code>regenerate_key</code> manually regenerates an access key. Note that if the vault is setup to regenerate keys automatically, you won't usually have to use this method.
</p>
<p>Unlike the other objects stored in a key vault, storage accounts are not versioned.
</p>
<p>A secret can have multiple <em>versions</em>, which are automatically generated when a secret is created with the same name as an existing secret. By default, the most recent (current) version is used for secret operations; use <code>list_versions</code> and <code>set_version</code> to change the version.
</p>
<p>The value is stored as an object of S3 class &quot;secret_value&quot;, which has a print method that hides the value to guard against shoulder-surfing. Note that this will not stop a determined attacker; as a general rule, you should minimise assigning secrets or passing them around your R environment. If you want the raw string value itself, eg when passing it to <code>jsonlite::toJSON</code> or other functions which do not accept arbitrary object classes as inputs, use <code>unclass</code> to strip the class attribute first.
</p>


<h3>Value</h3>

<p>For <code>create_sas_definition</code> and <code>get_sas_definition</code>, a list representing the SAS definition. For <code>list_sas_definitions</code>, a list of such lists.
</p>
<p>For <code>show_sas</code>, a string containing the SAS.
</p>
<p>For <code>list_versions</code>, a data frame containing details of each version.
</p>
<p>For <code>set_version</code>, the secret object with the updated version.
</p>


<h3>See Also</h3>

<p><a href="#topic+storage_accounts">storage_accounts</a>
</p>
<p><a href="https://docs.microsoft.com/en-us/azure/key-vault/">Azure Key Vault documentation</a>,
<a href="https://docs.microsoft.com/en-us/rest/api/keyvault">Azure Key Vault API reference</a>
</p>
<p><a href="#topic+secrets">secrets</a>
</p>
<p><a href="https://docs.microsoft.com/en-us/azure/key-vault/">Azure Key Vault documentation</a>,
<a href="https://docs.microsoft.com/en-us/rest/api/keyvault">Azure Key Vault API reference</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

vault &lt;- key_vault("mykeyvault")

# get the storage account details
library(AzureStor)
res &lt;- AzureRMR::get_azure_login()$
    get_subscription("sub_id")$
    get_resource_group("rgname")$
    get_storage_account("mystorageacct")

stor &lt;- vault$storage$create("mystor", res, "key1")

# Creating a new SAS definition
today &lt;- Sys.time()
sasdef &lt;- res$get_account_sas(expiry=today + 7*24*60*60, services="b", permissions="rw")
stor$create_sas_definition("newsas", sasdef, validity_period="P15D")

stor$show_sas("newsas")


## End(Not run)
## Not run: 

vault &lt;- key_vault("mykeyvault")

vault$secrets$create("mynewsecret", "secret text")
# new version of an existing secret
vault$secrets$create("mynewsecret", "extra secret text"))

secret &lt;- vault$secrets$get("mynewsecret")
vers &lt;- secret$list_versions()
secret$set_version(vers[2])

# printing the value will not show the secret
secret$value  # "&lt;hidden&gt;"


## End(Not run)
</code></pre>

<hr>
<h2 id='storage_accounts'>Storage accounts in Key Vault</h2><span id='topic+storage_accounts'></span><span id='topic+storage'></span>

<h3>Description</h3>

<p>This class represents the collection of storage accounts managed by a vault. It provides methods for adding and removing accounts, and doing backups and restores. For operations with a specific account, see <a href="#topic+storage">storage</a>.
</p>


<h3>Methods</h3>

<p>This class provides the following methods:</p>
<pre>add(name, storage_account, key_name, regen_key=TRUE, regen_period=30,
    attributes=vault_object_attrs(), ...)
get(name)
remove(name, confirm=TRUE)
list()
backup(name)
restore(backup)
</pre>


<h3>Arguments</h3>


<ul>
<li> <p><code>name</code>: A name by which to refer to the storage account.
</p>
</li>
<li> <p><code>storage_account</code>: The Azure resource ID of the account. This can also be an object of class <code>az_resource</code> or <code>az_storage</code>, as provided by the AzureRMR or AzureStor packages respectively; in this case, the resource ID is obtained from the object.
</p>
</li>
<li> <p><code>key_name</code>: The name of the storage access key that Key Vault will manage.
</p>
</li>
<li> <p><code>regen_key</code>: Whether to automatically regenerate the access key at periodic intervals.
</p>
</li>
<li> <p><code>regen_period</code>: How often to regenerate the access key. This can be a number, which will be interpreted as days; or as an ISO-8601 string denoting a duration, eg &quot;P30D&quot; (30 days).
</p>
</li>
<li> <p><code>attributes</code>: Optional attributes for the secret. A convenient way to provide this is via the <a href="#topic+vault_object_attrs">vault_object_attrs</a> helper function.
</p>
</li>
<li> <p><code>...</code>: For <code>create</code> and <code>import</code>, other named arguments which will be treated as tags.
</p>
</li>
<li> <p><code>confirm</code>: For <code>remove</code>, whether to ask for confirmation before removing the account.
</p>
</li>
<li> <p><code>backup</code>: For <code>restore</code>, a string representing the backup blob for a key.
</p>
</li>
<li> <p><code>email</code>: For <code>set_contacts</code>, the email addresses of the contacts.
</p>
</li></ul>



<h3>Value</h3>

<p>For <code>get</code> and <code>add</code>, an object of class <code>stored_account</code>, representing the storage account itself.
</p>
<p>For <code>list</code>, a vector of account names.
</p>
<p>For <code>backup</code>, a string representing the backup blob for a storage account. If the account has multiple versions, the blob will contain all versions.
</p>


<h3>See Also</h3>

<p><a href="#topic+storage_account">storage_account</a>, <a href="#topic+vault_object_attrs">vault_object_attrs</a>
</p>
<p><a href="https://docs.microsoft.com/en-us/azure/key-vault/">Azure Key Vault documentation</a>,
<a href="https://docs.microsoft.com/en-us/rest/api/keyvault">Azure Key Vault API reference</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

vault &lt;- key_vault("mykeyvault")

# get the storage account details
library(AzureStor)
stor &lt;- AzureRMR::get_azure_login()$
    get_subscription("sub_id")$
    get_resource_group("rgname")$
    get_storage_account("mystorageacct")
vault$storage$create("mystor", stor, "key1")

vault$storage$list()
vault$storage$get("mystor")

# specifying a regeneration period of 6 months
vault$storage$create("mystor", regen_period="P6M")

# setting management tags
vault$storage$create("mystor", tag1="a value", othertag="another value")

# backup and restore an account
bak &lt;- vault$storage$backup("mystor")
vault$storage$delete("mystor", confirm=FALSE)
vault$storage$restore(bak)


## End(Not run)
</code></pre>

<hr>
<h2 id='vault_access_policy'>Specify a key vault access policy</h2><span id='topic+vault_access_policy'></span>

<h3>Description</h3>

<p>Specify a key vault access policy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vault_access_policy(
  principal,
  tenant = NULL,
  key_permissions = "all",
  secret_permissions = "all",
  certificate_permissions = "all",
  storage_permissions = "all"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vault_access_policy_+3A_principal">principal</code></td>
<td>
<p>The user or service principal for this access policy. Can be a GUID, or a user, app or service principal object from the AzureGraph package.</p>
</td></tr>
<tr><td><code id="vault_access_policy_+3A_tenant">tenant</code></td>
<td>
<p>The tenant of the principal.</p>
</td></tr>
<tr><td><code id="vault_access_policy_+3A_key_permissions">key_permissions</code></td>
<td>
<p>The permissions to grant for working with keys.</p>
</td></tr>
<tr><td><code id="vault_access_policy_+3A_secret_permissions">secret_permissions</code></td>
<td>
<p>The permissions to grant for working with secrets.</p>
</td></tr>
<tr><td><code id="vault_access_policy_+3A_certificate_permissions">certificate_permissions</code></td>
<td>
<p>The permissions to grant for working with certificates.</p>
</td></tr>
<tr><td><code id="vault_access_policy_+3A_storage_permissions">storage_permissions</code></td>
<td>
<p>The permissions to grant for working with storage accounts.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Client access to a key vault is governed by its access policies, which are set on a per-principal basis. Each principal (user or service) can have different permissions granted, for keys, secrets, certificates, and storage accounts.
</p>
<p>Here are the possible permissions. The permission &quot;all&quot; means to grant all permissions.
</p>

<ul>
<li><p> Keys: &quot;get&quot;, &quot;list&quot;, &quot;update&quot;, &quot;create&quot;, &quot;import&quot;, &quot;delete&quot;, &quot;recover&quot;, &quot;backup&quot;, &quot;restore&quot;, &quot;decrypt&quot;, &quot;encrypt&quot;, &quot;unwrapkey&quot;, &quot;wrapkey&quot;, &quot;verify&quot;, &quot;sign&quot;, &quot;purge&quot;
</p>
</li>
<li><p> Secrets: &quot;get&quot;, &quot;list&quot;, &quot;set&quot;, &quot;delete&quot;, &quot;recover&quot;, &quot;backup&quot;, &quot;restore&quot;, &quot;purge&quot;
</p>
</li>
<li><p> Certificates: &quot;get&quot;, &quot;list&quot;, &quot;update&quot;, &quot;create&quot;, &quot;import&quot;, &quot;delete&quot;, &quot;recover&quot;, &quot;backup&quot;, &quot;restore&quot;, &quot;managecontacts&quot;, &quot;manageissuers&quot;, &quot;getissuers&quot;, &quot;listissuers&quot;, &quot;setissuers&quot;, &quot;deleteissuers&quot;, &quot;purge&quot;
</p>
</li>
<li><p> Storage accounts: &quot;get&quot;, &quot;list&quot;, &quot;update&quot;, &quot;set&quot;, &quot;delete&quot;, &quot;recover&quot;, &quot;backup&quot;, &quot;restore&quot;, &quot;regeneratekey&quot;, &quot;getsas&quot;, &quot;listsas&quot;, &quot;setsas&quot;, &quot;deletesas&quot;, &quot;purge&quot;
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>vault_access_policy</code>, suitable for creating a key vault resource.
</p>


<h3>See Also</h3>

<p><a href="#topic+create_key_vault">create_key_vault</a>, <a href="#topic+az_key_vault">az_key_vault</a>
</p>
<p><a href="https://docs.microsoft.com/en-us/azure/key-vault/">Azure Key Vault documentation</a>,
<a href="https://docs.microsoft.com/en-us/rest/api/keyvault">Azure Key Vault API reference</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# default is to grant full access
vault_access_policy("user_id")

# use AzureGraph to specify a user via their email address rather than a GUID
usr &lt;- AzureGraph::get_graph_login()$get_user("username@aadtenant.com")
vault_access_policy(usr)

# grant a service principal read access to keys and secrets only
svc &lt;- AzureGraph::get_graph_login()$
    get_service_principal(app_id="app_id")
vault_access_policy(svc,
    key_permissions=c("get", "list"),
    secret_permissions=c("get", "list"),
    certificate_permissions=NULL,
    storage_permissions=NULL)


## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
