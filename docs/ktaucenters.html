<!DOCTYPE html><html lang="en-US"><head><title>Help for package ktaucenters</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ktaucenters}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.distance'><p>Distance Matrix Computation</p></a></li>
<li><a href='#.flag_outliers'><p>Flag outliers</p></a></li>
<li><a href='#.ktaucenters_run'><p>Robust Clustering algorithm based on centers, a robust and efficient version</p>
of kmeans.</a></li>
<li><a href='#derpsiOpt'><p>Second derivative of the quasi <code class="reqn">\rho</code> function</p></a></li>
<li><a href='#improvedktaucenters'><p>improvedktaucenters</p></a></li>
<li><a href='#ktaucenters'><p>ktaucenters</p></a></li>
<li><a href='#ktaucentersfast'><p>ktaucentersfast</p></a></li>
<li><a href='#mars_screw'><p>Intensity and saturation values of a picture from mars.</p></a></li>
<li><a href='#Mscale'><p>M scale</p></a></li>
<li><a href='#normal_consistency_constants'><p>Normal Consistency Constants</p></a></li>
<li><a href='#psiOpt'><p>Derivative of the quasi optimal <code class="reqn">\rho</code> function</p></a></li>
<li><a href='#rhoOpt'><p>Quasi optimal <code class="reqn">\rho</code> function</p></a></li>
<li><a href='#robinden'><p>Robust Initialization based on Inverse Density estimator (ROBINDEN)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Robust Clustering Procedures</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A clustering algorithm similar to K-Means is implemented, it has two main advantages, 
    namely (a) The estimator is resistant to outliers, that means that results of estimator are still correct when
    there are atypical values in the sample and (b) The estimator is efficient, roughly speaking, 
    if there are no outliers in the sample, results will be similar to those obtained by a classic algorithm (K-Means).
    Clustering procedure is carried out by minimizing the overall robust scale so-called tau scale.
    (see Gonzalez, Yohai and Zamar (2019) &lt;<a href="https://doi.org/10.48550/arXiv.1906.08198">doi:10.48550/arXiv.1906.08198</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), MASS, stats, GSE</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>jpeg, tclust, knitr, rmarkdown, testthat (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.9)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-16 12:58:52 UTC; douglasc</td>
</tr>
<tr>
<td>Author:</td>
<td>Juan Domingo Gonzalez [cre, aut],
  Victor J. Yohai [aut],
  Ruben H. Zamar [aut],
  Douglas Alberto Carmona Guanipa [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Juan Domingo Gonzalez &lt;juanrst@hotmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-16 14:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.distance'>Distance Matrix Computation</h2><span id='topic+.distance'></span>

<h3>Description</h3>

<p>Computes and returns the distance matrix using euclidean distance
measure to compute the distances between the rows of a
data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.distance(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".distance_+3A_x">x</code></td>
<td>
<p>a numeric matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with the distances between the rows of a matrix.
</p>

<hr>
<h2 id='.flag_outliers'>Flag outliers</h2><span id='topic+.flag_outliers'></span>

<h3>Description</h3>

<p>Flag outliers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.flag_outliers(cutoff, b, ktau)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".flag_outliers_+3A_cutoff">cutoff</code></td>
<td>
<p>quantile of chi-square to be used as a threshold for outliers
detection.</p>
</td></tr>
<tr><td><code id=".flag_outliers_+3A_b">b</code></td>
<td>
<p>break down point.</p>
</td></tr>
<tr><td><code id=".flag_outliers_+3A_ktau">ktau</code></td>
<td>
<p>ktaucenters results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with the weight factor for each observation
</p>

<hr>
<h2 id='.ktaucenters_run'>Robust Clustering algorithm based on centers, a robust and efficient version
of kmeans.</h2><span id='topic+.ktaucenters_run'></span>

<h3>Description</h3>

<p>Robust Clustering algorithm based on centers, a robust and efficient version
of kmeans.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.ktaucenters_run(x, centers, tolerance, max_iter)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".ktaucenters_run_+3A_x">x</code></td>
<td>
<p>numeric matrix of size n x p with all observations.</p>
</td></tr>
<tr><td><code id=".ktaucenters_run_+3A_centers">centers</code></td>
<td>
<p>numeric matrix with initial cluster centers.</p>
</td></tr>
<tr><td><code id=".ktaucenters_run_+3A_tolerance">tolerance</code></td>
<td>
<p>maximum difference between current and new computed
clusters. Parameter used for the algorithm stopping rule.</p>
</td></tr>
<tr><td><code id=".ktaucenters_run_+3A_max_iter">max_iter</code></td>
<td>
<p>a maximum number of iterations used for the algorithm
stopping rule.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>tau</code></td>
<td>
<p><code class="reqn">\tau</code> scale value. </p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>number of iterations until convergence is achieved or maximum
number of iteration is reached. </p>
</td></tr>
<tr><td><code>di</code></td>
<td>
<p>distance of each observation to its nearest cluster center. </p>
</td></tr>
<tr><td><code>centers</code></td>
<td>
<p>numeric matrix of size K x p, with the estimated K centers.
</p>
</td></tr>
<tr><td><code>clusters</code></td>
<td>
<p>integer vector of size n with the cluster location for each
observation. </p>
</td></tr>
</table>


<h3>References</h3>

<p>[1] Gonzalez, J. D., Yohai, V. J., &amp; Zamar, R. H. (2019).
Robust Clustering Using Tau-Scales. arXiv preprint arXiv:1906.08198.
</p>
<p>[2] Maronna, R. A. and Yohai, V. J. (2017). Robust and efficient estimation
of multivariate scatter and location.Computational Statistics &amp;Data
Analysis, 109 : 64â€“75.
</p>

<hr>
<h2 id='derpsiOpt'>Second derivative of the quasi <code class="reqn">\rho</code> function</h2><span id='topic+derpsiOpt'></span>

<h3>Description</h3>

<p>Second derivative of the quasi <code class="reqn">\rho</code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derpsiOpt(x, cc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="derpsiOpt_+3A_x">x</code></td>
<td>
<p>numeric vector with positive values.</p>
</td></tr>
<tr><td><code id="derpsiOpt_+3A_cc">cc</code></td>
<td>
<p>tunning constant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with the second derivative of the quasi optimal <code class="reqn">\rho</code>
computation for each element of x.
</p>

<hr>
<h2 id='improvedktaucenters'>improvedktaucenters</h2><span id='topic+improvedktaucenters'></span>

<h3>Description</h3>

<p>Robust Clustering algorithm for non-spherical data. This function estimate
clusters taking into account that clusters may have
different size, volume or orientation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>improvedktaucenters(X, K, cutoff = 0.999, nstart = 5, INITcenters = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="improvedktaucenters_+3A_x">X</code></td>
<td>
<p>numeric matrix of size n x p.</p>
</td></tr>
<tr><td><code id="improvedktaucenters_+3A_k">K</code></td>
<td>
<p>number of clusters.</p>
</td></tr>
<tr><td><code id="improvedktaucenters_+3A_cutoff">cutoff</code></td>
<td>
<p>argument for outliers detection - quantiles of chi-square
to be used as a threshold for outliers detection, defaults to 0.999.</p>
</td></tr>
<tr><td><code id="improvedktaucenters_+3A_nstart">nstart</code></td>
<td>
<p>number of trials that the base ktaucenters is run at the first stage.
If it is greater than 1 and center is not set as NULL, a random set of (distinct) 
rows in x is chosen as the initial centres for each trial.</p>
</td></tr>
<tr><td><code id="improvedktaucenters_+3A_initcenters">INITcenters</code></td>
<td>
<p>numeric matrix of size K x p indicating the initial centers for
that clusters and robust covariance matrices will be computed, if it is set as NULL the
algorithm will compute from ktaucenters routine. Set to NULL by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>centers</code></td>
<td>
<p>: Matrix of size K x p, with the estimated K centers.</p>
</td></tr>
<tr><td><code>cluster</code></td>
<td>
<p>: A vector of integer (from 1:k) indicating the cluster to
which each point is allocated.</p>
</td></tr>
<tr><td><code>sigmas</code></td>
<td>
<p>: A list containing the k covariance matrices found by the 
procedure at its second step.</p>
</td></tr>
<tr><td><code>outliers</code></td>
<td>
<p>: indices observation that can be considered as outliers.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gonzalez, J. D., Yohai, V. J., &amp; Zamar, R. H. (2019).
Robust Clustering Using Tau-Scales. arXiv preprint arXiv:1906.08198.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate synthetic data (three normal cluster in two dimensions)
# Clusters have different shapes and orientation.
# The data is contaminated uniformly (level 20%).

# Generates base clusters
set.seed(1)
Z1 &lt;- c(rnorm(100, 0), rnorm(100, 0), rnorm(100, 0))
Z2 &lt;- rnorm(300)
X &lt;- matrix(0, ncol = 2, nrow = 300)
X[, 1] &lt;- Z1
X[, 2] &lt;- Z2
true.cluster &lt;- c(rep(1, 100), rep(2, 100), rep(3, 100))

# Rotate, expand and translate base clusters
theta &lt;- pi/3
aux1 &lt;- matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow = 2)
aux2 &lt;- sqrt(4) * diag(c(1, 1/4))
B &lt;- aux1 %*% aux2 %*% t(aux1)
X[true.cluster == 3, ] &lt;-
  X[true.cluster == 3, ] %*% aux2 %*% aux1 + matrix(c(5, 2),
                                                  byrow = TRUE,
                                                  nrow = 100,
                                                  ncol = 2)
X[true.cluster == 2, 2] &lt;- X[true.cluster == 2, 2] * 5
X[true.cluster == 1, 2] &lt;- X[true.cluster == 1, 2] * 0.1
X[true.cluster == 1, ] &lt;- X[true.cluster == 1, ] + matrix(c(-5, -1),
                                                          byrow = TRUE,
                                                          nrow = 100,
                                                          ncol = 2)

# Generate 60 synthetic outliers (contamination level 20%)

outliers &lt;- sample(1:300, 60)
X[outliers, ] &lt;- matrix(runif( 40, 2 * min(X), 2 * max(X) ),
                                ncol = 2, nrow = 60)

# Applying the algorithm
robust &lt;- improvedktaucenters(X, K = 3, cutoff = 0.999)

# Plotting results
oldpar &lt;- par(mfrow = c(2, 1))
plot(X, main = "Actual clusters")
for (j in 1:3){
 points(X[true.cluster == j, ], pch = 19, col = j + 1)
}
points(X[outliers, ], pch = 19, col = 1)
plot(X, main = "Clusters estimation")
for (j in 1:3){
 points(X[robust$cluster == j,], pch = 19, col = j + 1)
}
points(X[robust$outliers, ], pch = 19)

par(oldpar)
</code></pre>

<hr>
<h2 id='ktaucenters'>ktaucenters</h2><span id='topic+ktaucenters'></span>

<h3>Description</h3>

<p>Robust and efficient version of Kmeans algorithm for clustering based on centers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ktaucenters(
  X,
  K,
  centers = NULL,
  tolmin = 1e-06,
  NiterMax = 100,
  nstart = 1,
  startWithKmeans = TRUE,
  startWithROBINPD = TRUE,
  cutoff = 0.999
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ktaucenters_+3A_x">X</code></td>
<td>
<p>numeric matrix of size n x p.</p>
</td></tr>
<tr><td><code id="ktaucenters_+3A_k">K</code></td>
<td>
<p>number of clusters.</p>
</td></tr>
<tr><td><code id="ktaucenters_+3A_centers">centers</code></td>
<td>
<p>a matrix of size K x p containing the K initial centers,
one at each matrix-row. If centers is NULL a random set of (distinct) rows in
<code>X</code>
are chosen as the initial centers.</p>
</td></tr>
<tr><td><code id="ktaucenters_+3A_tolmin">tolmin</code></td>
<td>
<p>a tolerance parameter used for the algorithm stopping rule.</p>
</td></tr>
<tr><td><code id="ktaucenters_+3A_nitermax">NiterMax</code></td>
<td>
<p>a maximum number of iterations used for the algorithm stopping rule.</p>
</td></tr>
<tr><td><code id="ktaucenters_+3A_nstart">nstart</code></td>
<td>
<p>the number of trials that the base algorithm is run.
If it is greater than 1 and centers is not set as NULL, a random set of (distinct)
rows
in <code>X</code> will be chosen as the initial centers.</p>
</td></tr>
<tr><td><code id="ktaucenters_+3A_startwithkmeans">startWithKmeans</code></td>
<td>
<p>if positive (or true) kmeans estimated centers are included
as starting point.</p>
</td></tr>
<tr><td><code id="ktaucenters_+3A_startwithrobinpd">startWithROBINPD</code></td>
<td>
<p>if positive (or true) ROBINDEN estimated centers are
included as starting point.</p>
</td></tr>
<tr><td><code id="ktaucenters_+3A_cutoff">cutoff</code></td>
<td>
<p>optional argument for outliers detection - quantiles of chi-square
to be used as a threshold
for outliers detection, defaults to 0.999.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>centers</code></td>
<td>
<p>: Matrix of size K x p with the estimated K centers.</p>
</td></tr>
<tr><td><code>cluster</code></td>
<td>
<p>: A vector of integer (from 1:K) indicating the cluster to
which each point is allocated.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>: Number of iterations until convergence is achieved or
maximum number of iterations reached.</p>
</td></tr>
<tr><td><code>di</code></td>
<td>
<p>: Distance of each observation to its assigned cluster-center.</p>
</td></tr>
<tr><td><code>outliers</code></td>
<td>
<p>: A vector of integers with indices for each observation
considered as outlier.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gonzalez, J. D., Yohai, V. J., &amp; Zamar, R. H. (2019). 
Robust Clustering Using Tau-Scales. arXiv preprint arXiv:1906.08198.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate synthetic data (three clusters well separated)
Z &lt;- rnorm(600)
mues &lt;- rep(c(-3, 0, 3), 200)
X &lt;- matrix(Z + mues, ncol = 2)

# Generate 60 synthetic outliers (contamination level 20%)
X[sample(1:300,60), ] &lt;- matrix(runif( 40, 3 * min(X), 3 * max(X) ),
                                ncol = 2, nrow = 60)

robust &lt;- ktaucenters(
     X, K = 3, centers = X[sample(1:300, 3), ],
     tolmin = 1e-3, NiterMax = 100)

oldpar &lt;- par(mfrow = c(1, 2))

plot(X,type = "n", main = "ktaucenters (Robust) \n outliers: solid black dots")
points(X[robust$cluster == 1, ], col = 2)
points(X[robust$cluster == 2, ], col = 3)
points(X[robust$cluster == 3, ], col = 4)
points(X[robust$outliers, 1], X[robust$outliers, 2], pch = 19)

# Classical (non Robust) algorithm
non_robust &lt;- kmeans(X, centers = 3, nstart = 100)

plot(X, type = "n", main = "kmeans (Classical)")
points(X[non_robust$cluster == 1, ], col = 2)
points(X[non_robust$cluster == 2, ], col = 3)
points(X[non_robust$cluster == 3, ], col = 4)

par(oldpar)
</code></pre>

<hr>
<h2 id='ktaucentersfast'>ktaucentersfast</h2><span id='topic+ktaucentersfast'></span>

<h3>Description</h3>

<p>Robust and efficient version of Kmeans algorithm for clustering based on centers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ktaucentersfast(
  x,
  centers,
  nstart = 1L,
  use_kmeans = TRUE,
  use_robin = TRUE,
  max_iter = 100L,
  max_tol = 1e-06,
  cutoff = 0.999
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ktaucentersfast_+3A_x">x</code></td>
<td>
<p>numeric matrix of size n x p, or an object that can be coerced to a matrix
(such as a numeric vector or a data frame with all numeric columns).</p>
</td></tr>
<tr><td><code id="ktaucentersfast_+3A_centers">centers</code></td>
<td>
<p>either the number of clusters, say <strong>k</strong>, or a matrix of initial
(distinct) cluster centers. If a number, a random set of distinct rows in <code>x</code>
is chosen as the initial centers.</p>
</td></tr>
<tr><td><code id="ktaucentersfast_+3A_nstart">nstart</code></td>
<td>
<p>if centers is a number, how many random sets should be chosen?</p>
</td></tr>
<tr><td><code id="ktaucentersfast_+3A_use_kmeans">use_kmeans</code></td>
<td>
<p>use kmeans centers as starting point?</p>
</td></tr>
<tr><td><code id="ktaucentersfast_+3A_use_robin">use_robin</code></td>
<td>
<p>use robin algorithm centers as starting point?</p>
</td></tr>
<tr><td><code id="ktaucentersfast_+3A_max_iter">max_iter</code></td>
<td>
<p>the maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="ktaucentersfast_+3A_max_tol">max_tol</code></td>
<td>
<p>maximum tolerance parameter used for the algorithm as stopping rule.</p>
</td></tr>
<tr><td><code id="ktaucentersfast_+3A_cutoff">cutoff</code></td>
<td>
<p>quantile of chi-square distribution to be used as a threshold for
outliers detection, defaults to 0.999.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>centers</code></td>
<td>
<p>: A matrix of cluster centers.</p>
</td></tr>
<tr><td><code>cluster</code></td>
<td>
<p>: A vector of integer (from 1:k) indicating the cluster to
which each point is allocated.</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>: <code class="reqn">\tau</code> scale value.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>: Number of iterations until convergence is achieved
or maximum number of iteration reached.</p>
</td></tr>
<tr><td><code>di</code></td>
<td>
<p>: Distance of each observation to its assigned cluster-center</p>
</td></tr>
<tr><td><code>outliers</code></td>
<td>
<p>: A vector of integers with indices for each observation
considered as outlier.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gonzalez, J. D., Yohai, V. J., &amp; Zamar, R. H. (2019). 
Robust Clustering Using Tau-Scales. arXiv preprint arXiv:1906.08198.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate synthetic data (three clusters well separated)
Z &lt;- rnorm(600)
mues &lt;- rep(c(-3, 0, 3), 200)
X &lt;- matrix(Z + mues, ncol = 2)

# Generate 60 synthetic outliers (contamination level 20%)
X[sample(1:300,60), ] &lt;- matrix(runif( 40, 3 * min(X), 3 * max(X) ),
                                ncol = 2, nrow = 60)

robust &lt;- ktaucentersfast(
     X, centers = X[sample(1:300, 3), ],
     max_tol = 1e-3, max_iter = 100)

oldpar &lt;- par(mfrow = c(1, 2))

plot(X,type = "n", main = "ktaucenters (Robust) \n outliers: solid black dots")
points(X[robust$cluster == 1, ], col = 2)
points(X[robust$cluster == 2, ], col = 3)
points(X[robust$cluster == 3, ], col = 4)
points(X[robust$outliers, 1], X[robust$outliers, 2], pch = 19)

# Classical (non Robust) algorithm
non_robust &lt;- kmeans(X, centers = 3, nstart = 100)

plot(X, type = "n", main = "kmeans (Classical)")
points(X[non_robust$cluster == 1, ], col = 2)
points(X[non_robust$cluster == 2, ], col = 3)
points(X[non_robust$cluster == 3, ], col = 4)

par(oldpar)
</code></pre>

<hr>
<h2 id='mars_screw'>Intensity and saturation values of a picture from mars.</h2><span id='topic+mars_screw'></span>

<h3>Description</h3>

<p>A dataset containing the Intensity and Saturation values of a picture from Mars
taken from Rover Curiosity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mars_screw
</code></pre>


<h3>Format</h3>

<p>A list containing information about  pixels of a picture form mars mainly
containing red sand and  metal form Rover itself. List include:
</p>

<ul>
<li><p> SI_matrix: A matrix with 5063 rows and 128 columns.
Elements 1 to 64 of each row indicate the Saturation values of pixels in a square cell 8 x 8
whereas elements 65 to 128 of each row indicate the cell's Intensity  values.
</p>
</li>
<li><p> geographic_matrix: An integer matrix of dimension 5063 x 2, each row indicates
each square cell's locations (x-axis y-axis) at the picture.
</p>
</li>
<li><p> screw_index: the index corresponding to the screw observation (screw_index=4180)
</p>
</li></ul>



<h3>Source</h3>

<p><a href="https://www.nasa.gov/wp-content/uploads/2023/03/694811main_pia16225-43_full.jpg">https://www.nasa.gov/wp-content/uploads/2023/03/694811main_pia16225-43_full.jpg</a>
</p>

<hr>
<h2 id='Mscale'>M scale</h2><span id='topic+Mscale'></span>

<h3>Description</h3>

<p>The M scale of an univariate sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mscale(u, c, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Mscale_+3A_u">u</code></td>
<td>
<p>numeric vector with positive values.</p>
</td></tr>
<tr><td><code id="Mscale_+3A_c">c</code></td>
<td>
<p>a tuning constant. If consistency to standard normal distribution
is desired use <code><a href="#topic+normal_consistency_constants">normal_consistency_constants</a></code>.</p>
</td></tr>
<tr><td><code id="Mscale_+3A_b">b</code></td>
<td>
<p>the desired break down point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>M scale value.
</p>


<h3>References</h3>

<p>Maronna, R. A., Martin, R. D., Yohai, V. J., &amp; Salibian-Barrera,
M. (2018). Robust statistics: theory and methods (with R). Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Mscale(u = rnorm(100), c = 1, b = 0.5)

</code></pre>

<hr>
<h2 id='normal_consistency_constants'>Normal Consistency Constants</h2><span id='topic+normal_consistency_constants'></span>

<h3>Description</h3>

<p>M scale tuning constants so it is consistent with the standard
normal distribution for the quasi optimal <code class="reqn">\rho</code> function used in
<code><a href="#topic+rhoOpt">rhoOpt</a></code>. These constants were computed for 1 <code class="reqn">\leq</code> p
<code class="reqn">\leq</code> 400.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normal_consistency_constants(p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normal_consistency_constants_+3A_p">p</code></td>
<td>
<p>dimension where observation lives.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tuning constant.
</p>


<h3>References</h3>

<p>[1] Maronna, R. A., Martin, R. D., Yohai, V. J., &amp; SalibiÃ¡n-Barrera, M.
(2018). 'Robust statistics: theory and methods (with ' R). Wiley.
</p>
<p>[2] Salibian-Barrera, M., Willems, G., &amp; Zamar, R. (2008). The fast-tau
estimator for regression. 'Journal of Computational and Graphical
Statistics, 17(3), 659-682.
</p>

<hr>
<h2 id='psiOpt'>Derivative of the quasi optimal <code class="reqn">\rho</code> function</h2><span id='topic+psiOpt'></span>

<h3>Description</h3>

<p>Derivative of the quasi optimal <code class="reqn">\rho</code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psiOpt(x, cc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psiOpt_+3A_x">x</code></td>
<td>
<p>numeric vector with positive values.</p>
</td></tr>
<tr><td><code id="psiOpt_+3A_cc">cc</code></td>
<td>
<p>tunning constant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with the derivative of the quasi optimal <code class="reqn">\rho</code>
computation for each element of x.
</p>

<hr>
<h2 id='rhoOpt'>Quasi optimal <code class="reqn">\rho</code> function</h2><span id='topic+rhoOpt'></span>

<h3>Description</h3>

<p>Quasi optimal <code class="reqn">\rho</code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhoOpt(x, cc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rhoOpt_+3A_x">x</code></td>
<td>
<p>numeric vector with positive values.</p>
</td></tr>
<tr><td><code id="rhoOpt_+3A_cc">cc</code></td>
<td>
<p>tunning constant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with quasi optimal <code class="reqn">\rho</code> computation for each element
of x.
</p>


<h3>References</h3>

<p>[1] Salibian-Barrera, M., Willems, G., &amp; Zamar, R. (2008). The fast-tau
estimator for regression. Journal of Computational and GraphicalStatistics,
17(3), 659-682.
</p>

<hr>
<h2 id='robinden'>Robust Initialization based on Inverse Density estimator (ROBINDEN)</h2><span id='topic+robinden'></span>

<h3>Description</h3>

<p>Searches for k initial cluster seeds for k-means based clustering methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robinden(D, n_clusters, mp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robinden_+3A_d">D</code></td>
<td>
<p>a distance matrix, which contains the distances between the rows of
a matrix.</p>
</td></tr>
<tr><td><code id="robinden_+3A_n_clusters">n_clusters</code></td>
<td>
<p>number of cluster centers to find.</p>
</td></tr>
<tr><td><code id="robinden_+3A_mp">mp</code></td>
<td>
<p>number of nearest neighbors to compute point density.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The centers are the observations located in the most dense region
and far away from each other at the same time.
In order to find the observations in the highly dense region, this function
uses point density estimation (instead of Local Outlier Factor, Breunig et
al (2000)), see more details.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>centers</code></td>
<td>
<p>: A numeric vector with the initial cluster centers
indices.</p>
</td></tr>
<tr><td><code>idpoints</code></td>
<td>
<p>: A real vector containing the inverse of point
density estimation.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This is a slightly modified version of ROBIN algorithm
implementation done by Sarka Brodinova &lt;sarka.brodinova@tuwien.ac.at&gt;.
</p>


<h3>Author(s)</h3>

<p>Juan Domingo Gonzalez &lt;juanrst@hotmail.com&gt;
</p>


<h3>References</h3>

<p>Hasan AM, et al. Robust partitional clustering by
outlier and density insensitive seeding. Pattern Recognition Letters,
30(11), 994-1002, 2009.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate synthetic data (7 cluster well separated)
K &lt;- 5
nk &lt;- 100
Z &lt;- rnorm(2 * K * nk)
mues &lt;- rep(5 * -floor(K/2):floor(K/2), 2 * nk * K)
X &lt;-  matrix(Z + mues, ncol = 2)

# Generate synthetic outliers (contamination level 20%)
X[sample(1:(nk * K), (nk * K) * 0.2), ] &lt;-
  matrix(runif((nk * K) * 0.2 * 2, 3 * min(X), 3 * max(X)),
         ncol = 2,
         nrow = (nk * K)* 0.2)
res &lt;- robinden(D = as.matrix(dist(X)), n_clusters = K, mp = 10);
# plot the Initial centers found
plot(X)
points(X[res$centers, ], pch = 19, col = 4, cex = 2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
