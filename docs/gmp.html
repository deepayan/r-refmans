<!DOCTYPE html><html><head><title>Help for package gmp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gmp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#apply'><p>Apply Functions Over Matrix Margins (Rows or Columns)</p></a></li>
<li><a href='#asNumeric'><p>Coerce to 'numeric', not Loosing Dimensions</p></a></li>
<li><a href='#BernoulliQ'><p>Exact Bernoulli Numbers</p></a></li>
<li><a href='#bigq'><p>Large sized rationals</p></a></li>
<li><a href='#Bigq'><p>Relational Operators</p></a></li>
<li><a href='#Bigq_operators'><p>Basic arithmetic operators for large rationals</p></a></li>
<li><a href='#bigz'><p>Large Sized Integer Values</p></a></li>
<li><a href='#bigz_operators'><p>Basic Arithmetic Operators for Large Integers (&quot;bigz&quot;)</p></a></li>
<li><a href='#binomQ'><p>Exact Rational Binomial Probabilities</p></a></li>
<li><a href='#cumsum'><p>(Cumulative) Sums, Products of Large Integers and Rationals</p></a></li>
<li><a href='#extract'><p>Extract or Replace Parts of an Object</p></a></li>
<li><a href='#Extremes'><p>Extrema (Maxima and Minima)</p></a></li>
<li><a href='#factorialZ'><p>Factorial and Binomial Coefficient as Big Integer</p></a></li>
<li><a href='#factorization'><p>Factorize a number</p></a></li>
<li><a href='#formatN'><p>Format Numbers Keeping Classes Distinguishable</p></a></li>
<li><a href='#frexpZ'><p>Split Number into Fractional and Exponent of 2 Parts</p></a></li>
<li><a href='#gcd.bigz'><p>Greatest Common Divisor (GCD) and Least Common Multiple (LCM)</p></a></li>
<li><a href='#gcdex'><p>Compute Bezoult Coefficient</p></a></li>
<li><a href='#gmp-ifiworkarounds'><p>Base Functions in 'gmp'-ified Versions</p></a></li>
<li><a href='#gmp.utils'><p>GMP Number Utilities</p></a></li>
<li><a href='#is.whole'><p>Whole (&quot;Integer&quot;) Numbers</p></a></li>
<li><a href='#isprime'><p>Determine if number is (very probably) prime</p></a></li>
<li><a href='#lucnum'><p>Compute Fibonacci and Lucas numbers</p></a></li>
<li><a href='#matrix'><p>Matrix manipulation with gmp</p></a></li>
<li><a href='#modulus'><p>Modulus of a Big Integer</p></a></li>
<li><a href='#mpfr'><p>Exported function for mpfr use</p></a></li>
<li><a href='#nextprime'><p>Next Prime Number</p></a></li>
<li><a href='#Oakley'><p>RFC 2409 Oakley Groups - Parameters for Diffie-Hellman Key Exchange</p></a></li>
<li><a href='#powm'><p>Exponentiation function</p></a></li>
<li><a href='#Random'><p>Generate a random number</p></a></li>
<li><a href='#Relational_Operator'><p>Relational Operators</p></a></li>
<li><a href='#roundQ'><p>Rounding Big Rationals (&quot;bigq&quot;) to Decimals</p></a></li>
<li><a href='#sizeinbase'><p>Compute size of a bigz in a base</p></a></li>
<li><a href='#solve.bigz'><p>Solve a system of equation</p></a></li>
<li><a href='#Stirling'><p>Eulerian and Stirling Numbers of First and Second Kind</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.7-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-15</td>
</tr>
<tr>
<td>Title:</td>
<td>Multiple Precision Arithmetic</td>
</tr>
<tr>
<td>Author:</td>
<td>Antoine Lucas, Immanuel Scholz, Rainer Boehme &lt;rb-gmp@reflex-studio.de&gt;,
  Sylvain Jasson &lt;Sylvain.Jasson@inrae.fr&gt;,
  Martin Maechler &lt;maechler@stat.math.ethz.ch&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Antoine Lucas &lt;antoinelucas@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Multiple Precision Arithmetic (big integers and rationals,
 prime number tests, matrix computation), "arithmetic without limitations"
 using the C library GMP (GNU Multiple Precision Arithmetic).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Rmpfr, MASS, round</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>gmp (&gt;= 4.2.3)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>BuildResaveData:</td>
<td>no</td>
</tr>
<tr>
<td>LazyDataNote:</td>
<td>not available, as we use data/*.R *and* our classes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://forgemia.inra.fr/sylvain.jasson/gmp">https://forgemia.inra.fr/sylvain.jasson/gmp</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-15 14:34:19 UTC; antoine</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-15 15:50:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='apply'>Apply Functions Over Matrix Margins (Rows or Columns)</h2><span id='topic+apply'></span><span id='topic+apply.bigz'></span><span id='topic+apply.bigq'></span><span id='topic+apply.default'></span>

<h3>Description</h3>

<p>These are S3 <code><a href="utils.html#topic+methods">methods</a></code> for <code><a href="#topic+apply">apply</a>()</code> which we
re-export as S3 generic function.
They &ldquo;overload&rdquo; the <code>apply()</code> function for big rationals (<code>"bigq"</code>)
and big integers (<code>"bigz"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bigz'
apply(X, MARGIN, FUN, ...)
## S3 method for class 'bigq'
apply(X, MARGIN, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_+3A_x">X</code></td>
<td>
<p>a matrix of class bigz or bigq, see e.g.,
<code><a href="#topic+matrix.bigz">matrix.bigz</a></code>.</p>
</td></tr>
<tr><td><code id="apply_+3A_margin">MARGIN</code></td>
<td>
<p>1: apply function to rows; 2: apply function to columns</p>
</td></tr>
<tr><td><code id="apply_+3A_fun">FUN</code></td>
<td>
<p><code><a href="base.html#topic+function">function</a></code> to be applied</p>
</td></tr>
<tr><td><code id="apply_+3A_...">...</code></td>
<td>
<p>(optional) extra arguments for <code>FUN()</code>, as e.g., in
<code><a href="base.html#topic+lapply">lapply</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>bigz</code> and <code>bigq</code> methods return a vector of class
<code>"bigz"</code> or <code>"bigq"</code>, respectively.
</p>


<h3>Author(s)</h3>

<p>Antoine Lucas</p>


<h3>See Also</h3>

<p><code><a href="#topic+apply">apply</a></code>; <code><a href="base.html#topic+lapply">lapply</a></code> is used by our
<code>apply()</code> method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> x &lt;- as.bigz(matrix(1:12,3))
 apply(x,1,min)
 apply(x,2,max)

 x &lt;- as.bigq(x ^ 3, d = (x + 3)^2)
 apply(x,1, min)
 apply(x,2, sum)
 ## now use the "..." to pass  na.rm=TRUE :
 x[2,3] &lt;- NA
 apply(x,1, sum)
 apply(x,1, sum, na.rm = TRUE)
</code></pre>

<hr>
<h2 id='asNumeric'>Coerce to 'numeric', not Loosing Dimensions</h2><span id='topic+asNumeric'></span><span id='topic+asNumeric-methods'></span><span id='topic+asNumeric+2CANY-method'></span><span id='topic+asNumeric+2Cbigq-method'></span><span id='topic+asNumeric+2Cbigz-method'></span>

<h3>Description</h3>

<p>a number-like object is coerced to type (<a href="base.html#topic+typeof">typeof</a>)
<code>"numeric"</code>, keeping <code><a href="base.html#topic+dim">dim</a></code> (and maybe
<code><a href="base.html#topic+dimnames">dimnames</a></code>) when present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asNumeric(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asNumeric_+3A_x">x</code></td>
<td>
<p>a &ldquo;number-like&rdquo; object, e.g., big integer
(<code><a href="#topic+bigz">bigz</a></code>), or <code><a href="Rmpfr.html#topic+mpfr">mpfr</a></code>, notably
including matrices and arrays of such numbers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <span class="rlang"><b>R</b></span> object of type (<code><a href="base.html#topic+typeof">typeof</a></code>) <code>"numeric"</code>, a <code><a href="#topic+matrix">matrix</a></code>
or <code><a href="base.html#topic+array">array</a></code> if <code>x</code> had non-NULL dimension <code><a href="base.html#topic+dim">dim</a>()</code>.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "ANY")</code></dt><dd><p>the default method, which is the
identity for <code><a href="base.html#topic+numeric">numeric</a></code> array.</p>
</dd>
<dt><code>signature(x = "bigq")</code></dt><dd><p>the method for big rationals.</p>
</dd>
<dt><code>signature(x = "bigq")</code></dt><dd><p>the method for big integers.</p>
</dd>
</dl>

<p>Note that package <span class="pkg">Rmpfr</span> provides methods for its own number-like objects.

</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+as.numeric">as.numeric</a></code> coerces to both <code>"numeric"</code> and to a
<code><a href="base.html#topic+vector">vector</a></code>, whereas <code>asNumeric()</code> should keep
<code><a href="base.html#topic+dim">dim</a></code> (and other) attributes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(1:6, 2,3)
stopifnot(identical(m, asNumeric(m)))# remains matrix

(M &lt;- as.bigz(m) / 5) ##-&gt; "bigq" matrix
asNumeric(M) # numeric matrix
stopifnot(all.equal(asNumeric(M), m/5))
</code></pre>

<hr>
<h2 id='BernoulliQ'>Exact Bernoulli Numbers</h2><span id='topic+BernoulliQ'></span>

<h3>Description</h3>


<p>Return the <code class="reqn">n</code>-th Bernoulli number <code class="reqn">B_n</code>, (or <code class="reqn">B_n^+</code>,
see the reference), where <code class="reqn">B_1 = + \frac 1 2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BernoulliQ(n, verbose = getOption("verbose", FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BernoulliQ_+3A_n">n</code></td>
<td>
<p>integer <em>vector</em>, <code class="reqn">n \ge 0</code>.</p>
</td></tr>
<tr><td><code id="BernoulliQ_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if computation should be traced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a big rational (class <code><a href="#topic+bigq-class">&quot;bigq&quot;</a></code>) vector of the
Bernoulli numbers <code class="reqn">B_n</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Bernoulli_number">https://en.wikipedia.org/wiki/Bernoulli_number</a>
</p>


<h3>See Also</h3>

<p><code><a href="Rmpfr.html#topic+Bernoulli">Bernoulli</a></code> in <a href="https://CRAN.R-project.org/package=Rmpfr"><span class="pkg">Rmpfr</span></a> in arbitrary precision
via Riemann's <code class="reqn">\zeta</code> function.

<code>Bern(n)</code> in <a href="https://CRAN.R-project.org/package=DPQ"><span class="pkg">DPQ</span></a> uses standard (double precision)
<span class="rlang"><b>R</b></span> arithmetic for the n-th Bernoulli number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(Bn0.10 &lt;- BernoulliQ(0:10))
</code></pre>

<hr>
<h2 id='bigq'>Large sized rationals</h2><span id='topic+bigq'></span><span id='topic+bigq-class'></span><span id='topic+as.bigq'></span><span id='topic+is.bigq'></span><span id='topic+as.character.bigq'></span><span id='topic+as.double.bigq'></span><span id='topic+print.bigq'></span><span id='topic+is.na.bigq'></span><span id='topic+NA_bigq_'></span><span id='topic+as.bigz.bigq'></span><span id='topic+c_bigq'></span><span id='topic+denominator'></span><span id='topic+denominator+3C-'></span><span id='topic+numerator'></span><span id='topic+numerator+3C-'></span>

<h3>Description</h3>

<p>Class <code>"bigq"</code> encodes rationals encoded as ratios of arbitrary
large integers (via GMP).
A simple S3 class (internally a <code><a href="base.html#topic+raw">raw</a></code> vector), it has been
registered as formal (S4) class (via <code><a href="methods.html#topic+setOldClass">setOldClass</a></code>), too.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.bigq(n, d = 1)
## S3 method for class 'bigq'
as.character(x, b=10,...)
## S3 method for class 'bigq'
as.double(x,...)
as.bigz.bigq(a, mod=NA)
is.bigq(x)
## S3 method for class 'bigq'
is.na(x)
## S3 method for class 'bigq'
print(x, quote=FALSE, initLine = TRUE, ...)
denominator(x)
numerator(x)
NA_bigq_
c_bigq(L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bigq_+3A_n">n</code>, <code id="bigq_+3A_d">d</code></td>
<td>
<p>either integer, numeric or string value
(String value: either starting with <code>0x</code> for hexadecimal, <code>0b</code> for
binary or without prefix for decimal values.
Any format error results in <code>0</code>).
<code>n</code> stands for numerator, <code>d</code> for denominator.</p>
</td></tr>
<tr><td><code id="bigq_+3A_a">a</code></td>
<td>
<p>an element of class <code>"bigq"</code></p>
</td></tr>
<tr><td><code id="bigq_+3A_mod">mod</code></td>
<td>
<p>optional modulus to convert into biginteger</p>
</td></tr>
<tr><td><code id="bigq_+3A_x">x</code></td>
<td>
<p>a &ldquo;rational number&rdquo; (vector), of class <code>"bigq"</code>.</p>
</td></tr>
<tr><td><code id="bigq_+3A_b">b</code></td>
<td>
<p>base: from 2 to 36</p>
</td></tr>
<tr><td><code id="bigq_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods</p>
</td></tr>
<tr><td><code id="bigq_+3A_quote">quote</code></td>
<td>
<p>(for printing:) logical indicating if the numbers
should be quoted (as characters are);  the default used to be
<code>TRUE</code> (implicitly) till 2011.</p>
</td></tr>
<tr><td><code id="bigq_+3A_initline">initLine</code></td>
<td>
<p>(for printing:) logical indicating if an
<b>init</b>ial line (with the class and length or dimension) should
be printed. 


</p>
</td></tr>
<tr><td><code id="bigq_+3A_l">L</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> where each element contains <code>"bigq"</code>
numbers, for <code>c_bigq()</code>, this allows something like an
<code><a href="base.html#topic+sapply">sapply</a>()</code> for <code>"bigq"</code> vectors, see <code>sapplyQ()</code>
in the examples below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as.bigq(x)</code> when <code>x</code> is <code><a href="base.html#topic+numeric">numeric</a></code> (aka
<code><a href="base.html#topic+double">double</a></code> precision) calls the &lsquo;<span class="file">GMP</span>&rsquo; function
<code>mpq_set_d()</code> which is documented to be <em>exact</em> (every finite double
precision number is a rational number).
</p>
<p><code>as.bigz.bigq()</code> returns the smallest integers not less than the
corresponding rationals bigq.
</p>
<p><code>NA_bigq_</code> is computed on package load time as <code>as.bigq(NA)</code>.
</p>


<h3>Value</h3>

<p>An <span class="rlang"><b>R</b></span> object of (S3) class <code>"bigq"</code> representing the parameter value.
</p>


<h3>Author(s)</h3>

<p>Antoine Lucas</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.bigq(21,6)
x
# 7 / 2
# Wow ! result is simplified.

y &lt;- as.bigq(5,3)

# addition works !
x + y

# You can even try multiplication, division...
x * y / 13

# and, since May 2012,
x ^ 20
stopifnot(is.bigq(x), is.bigq(x + y),
	  x ^ 20 == as.bigz(7)^20 / 2^20)

# convert to string, double
as.character(x)
as.double(x)

stopifnot( is.na(NA_bigq_) )

# Depict the "S4-class" bigq, i.e., the formal (S4) methods:
if(require("Rmpfr")) # mostly interesting there
  showMethods(class="bigq")

# an  sapply() version that works for big rationals "bigq":
sapplyQ &lt;- function(X, FUN, ...) c_bigq(lapply(X, FUN, ...))

# dummy example showing it works (here):
qq &lt;- as.bigq(1, 1:999)
q1 &lt;- sapplyQ(qq, function(q) q^2)
stopifnot( identical(q1, qq^2) )
</code></pre>

<hr>
<h2 id='Bigq'>Relational Operators</h2><span id='topic++3D+3D.bigq'></span><span id='topic++21+3D.bigq'></span><span id='topic++3C.bigq'></span><span id='topic++3C+3D.bigq'></span><span id='topic++3E.bigq'></span><span id='topic++3E+3D.bigq'></span><span id='topic+sign.bigq'></span>

<h3>Description</h3>

<p>Binary operators which allow the comparison of values in atomic vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bigq'
sign(x)

## S3 method for class 'bigq'
e1 &lt; e2
## S3 method for class 'bigq'
e1 &lt;= e2
## S3 method for class 'bigq'
e1 == e2
## S3 method for class 'bigq'
e1 &gt;= e2
## S3 method for class 'bigq'
e1 &gt; e2
## S3 method for class 'bigq'
e1 != e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bigq_+3A_x">x</code>, <code id="Bigq_+3A_e1">e1</code>, <code id="Bigq_+3A_e2">e2</code></td>
<td>
<p>Object or vector of class <code><a href="#topic+bigq">bigq</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- as.bigq(8000,21)
  x  &lt; 2 * x
  </code></pre>

<hr>
<h2 id='Bigq_operators'>Basic arithmetic operators for large rationals</h2><span id='topic+add.bigq'></span><span id='topic++2B.bigq'></span><span id='topic+sub.bigq'></span><span id='topic+-.bigq'></span><span id='topic+mul.bigq'></span><span id='topic++2A.bigq'></span><span id='topic+div.bigq'></span><span id='topic++2F.bigq'></span><span id='topic+pow.bigq'></span><span id='topic++5E.bigq'></span><span id='topic+abs.bigq'></span>

<h3>Description</h3>

<p>Addition, subtraction, multiplication, division, and absolute value for
large rationals, i.e. <code>"<a href="#topic+bigq">bigq</a>"</code> class <span class="rlang"><b>R</b></span> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.bigq(e1, e2)
## S3 method for class 'bigq'
e1 + e2

sub.bigq(e1, e2=NULL)
## S3 method for class 'bigq'
e1 - e2

mul.bigq(e1, e2)
## S3 method for class 'bigq'
e1 * e2

div.bigq(e1, e2)
## S3 method for class 'bigq'
e1 / e2

## S3 method for class 'bigq'
e1 ^ e2

## S3 method for class 'bigq'
abs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bigq_operators_+3A_e1">e1</code>, <code id="Bigq_operators_+3A_e2">e2</code>, <code id="Bigq_operators_+3A_x">x</code></td>
<td>
<p>of class <code>"<a href="#topic+bigq">bigq</a>"</code>, or (<code>e1</code> and
<code>e2</code>) integer or string from an integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Operators can be use directly when the objects are of class <code>"<a href="#topic+bigq">bigq</a>"</code>:
a + b, a * b, etc, and <code>a ^ n</code>, where <code>n</code> must be coercable
to a biginteger (<code>"<a href="#topic+bigz">bigz</a>"</code>).
</p>


<h3>Value</h3>

<p>A bigq class representing the result of the arithmetic operation.
</p>


<h3>Author(s)</h3>

<p>Immanuel Scholz and Antoine Lucas</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 1/3 + 1 = 4/3 :
as.bigq(1,3) + 1

r &lt;- as.bigq(12, 47)
stopifnot(r ^ 3 == r*r*r)
</code></pre>

<hr>
<h2 id='bigz'>Large Sized Integer Values</h2><span id='topic+bigz'></span><span id='topic+bigz-class'></span><span id='topic+as.bigz'></span><span id='topic+is.bigz'></span><span id='topic+as.character.bigz'></span><span id='topic+as.double.bigz'></span><span id='topic+print.bigz'></span><span id='topic+is.na.bigz'></span><span id='topic+NA_bigz_'></span><span id='topic+c_bigz'></span><span id='topic+biginteger_as'></span><span id='topic+biginteger_as_character'></span>

<h3>Description</h3>

<p>Class <code>"bigz"</code> encodes arbitrarily large integers (via GMP).
A simple S3 class (internally a <code><a href="base.html#topic+raw">raw</a></code> vector), it has been
registered as formal (S4) class (via <code><a href="methods.html#topic+setOldClass">setOldClass</a></code>), too.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.bigz(a, mod = NA)
NA_bigz_
## S3 method for class 'bigz'
as.character(x, b = 10, ...)

is.bigz(x)
## S3 method for class 'bigz'
is.na(x)
## S3 method for class 'bigz'
print(x, quote=FALSE, initLine = is.null(modulus(x)), ...)
c_bigz(L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bigz_+3A_a">a</code></td>
<td>
<p>either <code><a href="base.html#topic+integer">integer</a></code>, <code><a href="base.html#topic+numeric">numeric</a></code> (i.e.,
<code><a href="base.html#topic+double">double</a></code>) or <code><a href="base.html#topic+character">character</a></code> vector.
</p>
<p>If character: the strings either start with <code>0x</code> for hexadecimal, <code>0b</code> for
binary, <code>0</code> for octal, or without a <code>0*</code> prefix for decimal values.
Formatting errors are signalled as with <code><a href="base.html#topic+stop">stop</a></code>.</p>
</td></tr>
<tr><td><code id="bigz_+3A_b">b</code></td>
<td>
<p>base: from 2 to 36</p>
</td></tr>
<tr><td><code id="bigz_+3A_x">x</code></td>
<td>
<p>a &ldquo;big integer number&rdquo; (vector), of class <code>"bigz"</code>.</p>
</td></tr>
<tr><td><code id="bigz_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods</p>
</td></tr>
<tr><td><code id="bigz_+3A_mod">mod</code></td>
<td>
<p>an integer, numeric, string or bigz of the internal modulus, see below.</p>
</td></tr>
<tr><td><code id="bigz_+3A_quote">quote</code></td>
<td>
<p>(for printing:) logical indicating if the numbers
should be quoted (as characters are);  the default used to be
<code>TRUE</code> (implicitly) till 2011.</p>
</td></tr>
<tr><td><code id="bigz_+3A_initline">initLine</code></td>
<td>
<p>(for printing:) logical indicating if an
<b>init</b>ial line (with the class and length or dimension) should
be printed.  The default prints it for those cases where the class
is not easily discernable from the print output.</p>
</td></tr>
<tr><td><code id="bigz_+3A_l">L</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> where each element contains <code>"bigz"</code>
numbers, for <code>c_bigz()</code>, this allows something like an
<code><a href="base.html#topic+sapply">sapply</a>()</code> for <code>"bigz"</code> vectors, see <code>sapplyZ()</code>
in the examples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bigz's are integers of arbitrary, but given length (means: only
restricted by the host memory).  Basic arithmetic operations can be performed
on bigzs as addition, subtraction, multiplication, division, modulation
(remainder of division), power, multiplicative inverse, calculating of the
greatest common divisor, test whether the integer is prime and other operations
needed when performing standard cryptographic operations.
</p>
<p>For a review of basic arithmetics, see <code><a href="#topic+add.bigz">add.bigz</a></code>.
</p>
<p>Comparison are supported, i.e., <code>"=="</code>, <code>"!="</code>,
<code>"&lt;"</code>, <code>"&lt;="</code>, <code>"&gt;"</code>, and <code>"&gt;="</code>.
</p>
<p><code>NA_bigz_</code> is computed on package load time as <code>as.bigz(NA)</code>.
</p>
<p>Objects of class <code>"bigz"</code> may have a &ldquo;modulus&rdquo;, accessible
via <code><a href="#topic+modulus">modulus</a>()</code>, currently as an attribute <code>mod</code>.
When the object has such a modulus <code class="reqn">m</code>, arithmetic is performed
<em>&ldquo;modulo m&rdquo;</em>, mathematically &ldquo;within the
ring <code class="reqn">Z/mZ</code>&rdquo;.  For many operations, this means
</p>
<pre>   result &lt;- mod.bigz(result, m)  ## == result %% m
</pre>
<p>is called after performing the arithmetic operation and the result
will have the attribute <code>mod</code> set accordingly.
This however does not apply, e.g., for <code>/</code>, where
<code class="reqn">a / b := a b^{-1}</code> and
<code class="reqn">b^{-1}</code> is the <em>multiplicate inverse</em> of <code class="reqn">b</code>
with respect to ring arithmetic, or <code><a href="base.html#topic+NA">NA</a></code> with a warning
when the inverse does not exist.  The warning can be turned off via
<code>options("gmp:warnModMismatch" = FALSE)</code>
</p>
<p>Powers of bigzs can only be performed, if either a modulus is going to
be applied to the result bigz or if the exponent fits into an integer
value.  So, if you want to calculate a power in a finite group
(&ldquo;modulo c&rdquo;), for large <code class="reqn">c</code> do not use
<code>a ^ b %% c</code>, but rather <code>as.bigz(a,c) ^ b</code>.
</p>
<p>The following rules for the result's modulus apply when performing
arithmetic operations on <code>bigz</code>s:
</p>

<ul>
<li><p> If none of the operand has a modulus set, the result will not have a modulus.
</p>
</li>
<li><p> If both operands have a different modulus, the result will not have a
modulus, except in case of <code><a href="#topic+mod.bigz">mod.bigz</a></code>, where the second operand's
value is used.
</p>
</li>
<li><p> If only one of the operands has a modulus or both have a common (the
same), it is set and used for the arithmetic operations, except in
case of <code>mod.bigz</code>, where the second operand's value is used.
</p>
</li></ul>



<h3>Value</h3>

<p>An <span class="rlang"><b>R</b></span> object of (S3) class <code>"bigz"</code>, representing the argument
(<code>x</code> or <code>a</code>).
</p>


<h3>Note</h3>

<pre>
    x &lt;- as.bigz(1234567890123456789012345678901234567890)
  </pre>
<p>will not work as <span class="rlang"><b>R</b></span> converts the number to a double, losing precision
and only then convert to a <code>"bigz"</code> object.
</p>
<p>Instead, use the syntax
</p>
<pre>
    x &lt;- as.bigz("1234567890123456789012345678901234567890")
  </pre>


<h3>Author(s)</h3>

<p>Immanuel Scholz</p>


<h3>References</h3>

<p>The GNU MP Library, see <a href="https://gmplib.org">https://gmplib.org</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## 1+1=2
a &lt;- as.bigz(1)
a + a

## Two non-small Mersenne primes:
two &lt;- as.bigz(2)
p1 &lt;- two^107 -1 ; isprime(p1); p1
p2 &lt;- two^127 -1 ; isprime(p2); p2

stopifnot( is.na(NA_bigz_) )

## Calculate c = x^e mod n
## --------------------------------------------------------------------
x &lt;- as.bigz("0x123456789abcdef") # my secret message
e &lt;- as.bigz(3) # something smelling like a dangerous public RSA exponent
(n &lt;- p1 * p2) #  a product of two primes
as.character(n, b=16)# as both primes were Mersenne's..

## recreate the three numbers above [for demo below]:
n. &lt;- n; x. &lt;- x; e. &lt;- e # save
Rev &lt;- function() { n &lt;&lt;- n.; x &lt;&lt;- x.; e &lt;&lt;- e.}

# first way to do it right
modulus(x) &lt;- n
c &lt;- x ^ e ; c ; Rev()

# similar second way (makes more sense if you reuse e) to do it right
modulus(e) &lt;- n
c2 &lt;- x ^ e
stopifnot(identical(c2, c), is.bigz(c2)) ; Rev()

# third way to do it right
c3 &lt;- x ^ as.bigz(e, n) ; stopifnot(identical(c3, c))

# fourth way to do it right
c4 &lt;- as.bigz(x, n) ^ e ; stopifnot(identical(c4, c))

# WRONG! (although very beautiful. Ok only for very small 'e' as here)
cc &lt;- x ^ e %% n
cc == c

# Return result in hexa
as.character(c, b=16)

# Depict the "S4-class" bigz, i.e., the formal (S4) methods:
if(require("Rmpfr")) # mostly interesting there
  showMethods(class="bigz")

# an  sapply() version that works for big integers "bigz":
sapplyZ &lt;- function(X, FUN, ...) c_bigz(lapply(X, FUN, ...))

# dummy example showing it works (here):
zz &lt;- as.bigz(3)^(1000+ 1:999)
z1 &lt;- sapplyZ(zz, function(z) z^2)
stopifnot( identical(z1, zz^2) )
</code></pre>

<hr>
<h2 id='bigz_operators'>Basic Arithmetic Operators for Large Integers (&quot;bigz&quot;)</h2><span id='topic+add.bigz'></span><span id='topic++2B.bigz'></span><span id='topic+sub.bigz'></span><span id='topic+-.bigz'></span><span id='topic+mul.bigz'></span><span id='topic++2A.bigz'></span><span id='topic+div.bigz'></span><span id='topic++2F.bigz'></span><span id='topic+mod.bigz'></span><span id='topic++25+25.bigz'></span><span id='topic++25+2F+25.bigz'></span><span id='topic+divq.bigz'></span><span id='topic+abs.bigz'></span><span id='topic+inv.bigz'></span><span id='topic+inv'></span><span id='topic+pow.bigz'></span><span id='topic+pow'></span><span id='topic++5E.bigz'></span><span id='topic+log.bigz'></span><span id='topic+log2.bigz'></span><span id='topic+log10.bigz'></span>

<h3>Description</h3>

<p>Addition, substraction, multiplication, (integer) division,
remainder of division, multiplicative inverse,
power and logarithm functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.bigz(e1, e2)
sub.bigz(e1, e2 = NULL)
mul.bigz(e1, e2)
div.bigz(e1, e2)
divq.bigz(e1,e2) ## ==  e1 %/% e2
mod.bigz(e1, e2) ## ==  e1 %%  e2
## S3 method for class 'bigz'
abs(x)

inv.bigz(a, b,...)## == (1 / a) (modulo b)

pow.bigz(e1, e2,...)## == e1 ^ e2

## S3 method for class 'bigz'
log(x, base=exp(1))
## S3 method for class 'bigz'
log2(x)
## S3 method for class 'bigz'
log10(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bigz_operators_+3A_x">x</code></td>
<td>
<p>bigz, integer or string from an integer</p>
</td></tr>
<tr><td><code id="bigz_operators_+3A_e1">e1</code>, <code id="bigz_operators_+3A_e2">e2</code>, <code id="bigz_operators_+3A_a">a</code>, <code id="bigz_operators_+3A_b">b</code></td>
<td>
<p>bigz, integer or string from an integer</p>
</td></tr>
<tr><td><code id="bigz_operators_+3A_base">base</code></td>
<td>
<p>base of the logarithm; base e as default</p>
</td></tr>
<tr><td><code id="bigz_operators_+3A_...">...</code></td>
<td>
<p>Additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Operators can be used directly when objects are of class bigz:
a + b, log(a), etc.
</p>
<p>For details about the internal modulus state, <em>and</em> the rules
applied for arithmetic operations on big integers with a modulus,
see the <code><a href="#topic+bigz">bigz</a></code> help page.
</p>
<p><code>a / b</code>  <code class="reqn">=</code>  <code>div(a,b)</code> returns a rational number
unless the operands have a (matching) modulus where
<code>a * b^-1</code> results.
<br />
<code>a %/% b</code> (or, equivalently, <code>divq(a,b)</code>) returns the
quotient of simple <em>integer</em> division (with truncation towards zero),
possibly re-adding a modulus at the end (but <em>not</em> using a
modulus like in <code>a / b</code>).
</p>
<p><code>r &lt;- inv.bigz(a, m)</code>, the multiplicative inverse of
<code>a</code> modulo <code class="reqn">m</code>, corresponds to <code>1/a</code> or <code>a ^-1</code>
from above <em>when</em> <code>a</code> has modulus <code>m</code>.  Note that
<code class="reqn">a</code> not always has an inverse modulo <code class="reqn">m</code>, in which case
<code>r</code> will be <code><a href="base.html#topic+NA">NA</a></code> with a warning that can be turned
off via </p>
<pre>options("gmp:warnNoInv" = FALSE)</pre><p>.
</p>


<h3>Value</h3>

<p>Apart from <code>/</code> (or <code>div</code>), where rational numbers
(<code><a href="#topic+bigq">bigq</a></code>) may result, these functions return an object of
class <code>"bigz"</code>, representing the result of the arithmetic
operation.
</p>


<h3>Author(s)</h3>

<p>Immanuel Scholz and Antoine Lucas</p>


<h3>References</h3>

<p>The GNU MP Library, see <a href="https://gmplib.org">https://gmplib.org</a></p>


<h3>Examples</h3>

<pre><code class='language-R'># 1+1=2
as.bigz(1) + 1
as.bigz(2)^10
as.bigz(2)^200

# if my.large.num.string is set to a number, this returns the least byte
(my.large.num.string &lt;- paste(sample(0:9, 200, replace=TRUE), collapse=""))
mod.bigz(as.bigz(my.large.num.string), "0xff")

# power exponents can be up to MAX_INT in size, or unlimited if a
# bigz's modulus is set.
pow.bigz(10,10000)

## Modulo 11,   7 and 8 are inverses :
as.bigz(7, mod = 11) * 8 ## ==&gt;  1  (mod 11)
inv.bigz(7, 11)## hence, 8
a &lt;- 1:10
(i.a &lt;- inv.bigz(a, 11))
d &lt;- as.bigz(7)
a %/% d  # = divq(a, d)
a %%  d  # = mod.bigz (a, d)

(ii &lt;- inv.bigz(1:10, 16))
## with 5 warnings (one for each NA)
op &lt;- options("gmp:warnNoInv" = FALSE)
i2 &lt;- inv.bigz(1:10, 16) # no warnings
(i3 &lt;- 1 / as.bigz(1:10, 16))
i4 &lt;- as.bigz(1:10, 16) ^ -1
stopifnot(identical(ii, i2),
	  identical(as.bigz(i2, 16), i3),
	  identical(i3, i4))
options(op)# revert previous options' settings

stopifnot(inv.bigz(7, 11) == 8,
          all(as.bigz(i.a, 11) * a == 1),
          identical(a %/% d, divq.bigz(1:10, 7)),
          identical(a %%  d, mod.bigz (a, d))
 )

</code></pre>

<hr>
<h2 id='binomQ'>Exact Rational Binomial Probabilities</h2><span id='topic+dbinomQ'></span>

<h3>Description</h3>

<p>Compute <em>exact</em> binomial probabilities using (big integer and) big
rational arithmetic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbinomQ(x, size, prob, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binomQ_+3A_x">x</code>, <code id="binomQ_+3A_size">size</code></td>
<td>
<p>integer or big integer (<code>"<a href="#topic+bigz">bigz</a>"</code>), will be
passed to <code><a href="#topic+chooseZ">chooseZ</a>()</code>.</p>
</td></tr>
<tr><td><code id="binomQ_+3A_prob">prob</code></td>
<td>
<p>the probability; should be big rational
(<code>"<a href="#topic+bigq">bigq</a>"</code>); if not it is coerced with a warning.</p>
</td></tr>
<tr><td><code id="binomQ_+3A_log">log</code></td>
<td>
<p>logical; must be <code>FALSE</code> on purpose.  Use
<code>log(Rmpfr::<a href="Rmpfr.html#topic+mpfr">mpfr</a>(dbinomQ(..), precB))</code> for the
logarithm of such big rational numbers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a big rational (<code>"<a href="#topic+bigq">bigq</a>"</code>) of the <code><a href="base.html#topic+length">length</a></code> of
(recycled) <code>x+size+prob</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="#topic+chooseZ">chooseZ</a></code>; <span class="rlang"><b>R</b></span>'s (<span class="pkg">stats</span> package) <code><a href="stats.html#topic+dbinom">dbinom</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dbinomQ(0:8,8, as.bigq(1,2))
##  1/256  1/32   7/64   7/32   35/128 7/32   7/64   1/32   1/256

ph16. &lt;- dbinomQ(0:16, size=16, prob = 1/2)  # innocous warning
ph16  &lt;- dbinomQ(0:16, size=16, prob = as.bigq(1,2))
ph16.75 &lt;- dbinomQ(0:16, size=16, prob = as.bigq(3,4))
ph8.75  &lt;- dbinomQ(0:8, 8, as.bigq(3,4))
stopifnot(exprs = {
   dbinomQ(0:8,8, as.bigq(1,2)) * 2^8 == choose(8, 0:8)
   identical(ph8.75, chooseZ(8,0:8) * 3^(0:8) / 4^8)
   all.equal(ph8.75, choose (8,0:8) * 3^(0:8) / 4^8, tol=1e-15) # see exactly equal
   identical(ph16, ph16.)
   identical(ph16,
            dbinomQ(0:16, size=16, prob = as.bigz(1)/2))
   all.equal(dbinom(0:16, 16, prob=1/2), asNumeric(ph16),    tol=1e-15)
   all.equal(dbinom(0:16, 16, prob=3/4), asNumeric(ph16.75), tol=1e-15)
})
</code></pre>

<hr>
<h2 id='cumsum'>(Cumulative) Sums, Products of Large Integers and Rationals</h2><span id='topic+cumsum.bigz'></span><span id='topic+cumsum.bigq'></span><span id='topic+sum.bigz'></span><span id='topic+sum.bigq'></span><span id='topic+prod.bigz'></span><span id='topic+prod.bigq'></span>

<h3>Description</h3>

<p>Theses are methods to &lsquo;overload&rsquo; the <code><a href="base.html#topic+sum">sum</a>()</code>,
<code><a href="base.html#topic+cumsum">cumsum</a>()</code> and <code><a href="base.html#topic+prod">prod</a>()</code> functions for big
rationals and big integers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bigz'
cumsum(x)
## S3 method for class 'bigq'
cumsum(x)
## S3 method for class 'bigz'
sum(..., na.rm = FALSE)
## S3 method for class 'bigq'
sum(..., na.rm = FALSE)
## S3 method for class 'bigz'
prod(..., na.rm = FALSE)
## S3 method for class 'bigq'
prod(..., na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumsum_+3A_x">x</code>, <code id="cumsum_+3A_...">...</code></td>
<td>
<p><span class="rlang"><b>R</b></span> objects of class <code>bigz</code> or <code>bigq</code> or
&lsquo;simple&rsquo; numbers.</p>
</td></tr>
<tr><td><code id="cumsum_+3A_na.rm">na.rm</code></td>
<td>
<p>logical indicating if missing values (<code><a href="base.html#topic+NA">NA</a></code>)
should be removed before the computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return an element of class bigz or bigq.
</p>


<h3>Author(s)</h3>

<p>Antoine Lucas</p>


<h3>See Also</h3>

<p><code><a href="#topic+apply">apply</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> x &lt;- as.bigz(1:12)
 cumsum(x)
 prod(x)
 sum(x)

 x &lt;- as.bigq(1:12)
 cumsum(x)
 prod(x)
 sum(x)
</code></pre>

<hr>
<h2 id='extract'>Extract or Replace Parts of an Object</h2><span id='topic++5B.bigz'></span><span id='topic++5B+3C-.bigz'></span><span id='topic++5B+5B.bigz'></span><span id='topic++5B+5B+3C-.bigz'></span><span id='topic+c.bigz'></span><span id='topic+rep.bigz'></span><span id='topic+length.bigz'></span><span id='topic+length+3C-.bigz'></span><span id='topic++5B.bigq'></span><span id='topic++5B+3C-.bigq'></span><span id='topic++5B+5B.bigq'></span><span id='topic++5B+5B+3C-.bigq'></span><span id='topic+c.bigq'></span><span id='topic+rep.bigq'></span><span id='topic+length.bigq'></span><span id='topic+length+3C-.bigq'></span>

<h3>Description</h3>

<p>Operators acting on vectors, arrays and lists to extract or replace subsets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bigz'
x[i=NULL, j=NULL, drop = TRUE]
## S3 method for class 'bigq'
x[i=NULL, j=NULL, drop = TRUE]

##_______ In the following, only the bigq method is mentioned: ______



## S3 method for class 'bigq'
c(..., recursive = FALSE)
## S3 method for class 'bigq'
rep(x, times=1, length.out=NA, each=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_+3A_x">x</code></td>
<td>
<p><span class="rlang"><b>R</b></span> object of class <code>"bigz"</code> or <code>"bigq"</code>, respectively.</p>
</td></tr>
<tr><td><code id="extract_+3A_...">...</code></td>
<td>
<p>further arguments, notably for <code>c()</code>.</p>
</td></tr>
<tr><td><code id="extract_+3A_i">i</code>, <code id="extract_+3A_j">j</code></td>
<td>
<p>indices, see standard <span class="rlang"><b>R</b></span> subsetting and subassignment.</p>
</td></tr>
<tr><td><code id="extract_+3A_drop">drop</code></td>
<td>
<p>logical, unused here.</p>
</td></tr>


<tr><td><code id="extract_+3A_times">times</code>, <code id="extract_+3A_length.out">length.out</code>, <code id="extract_+3A_each">each</code></td>
<td>
<p>integer; typically only <em>one</em> is
specified; for more see <code><a href="base.html#topic+rep">rep</a></code> (standard <span class="rlang"><b>R</b></span>, package <span class="pkg">base</span>).
</p>
</td></tr>
<tr><td><code id="extract_+3A_recursive">recursive</code></td>
<td>
<p>unused here</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Unlike standard matrices, <code>x[i]</code> and <code>x[i,]</code> do the same.

</p>


<h3>Examples</h3>

<pre><code class='language-R'>  a &lt;- as.bigz(123)
  ## indexing "outside" --&gt; extends the vectors (filling with NA)
  a[2] &lt;- a[1]
  a[4] &lt;- -4

  ## create a vector of 3 a
  c(a,a,a)

  ## repeate a 5 times
  rep(a,5)

  ## with matrix
  m &lt;- matrix.bigz(1:6,3)

  ## these do the same:
  m[1,]
  m[1]
  m[-c(2,3),]
  m[-c(2,3)]
  m[c(TRUE,FALSE,FALSE)]

  ##_modification on matrix
  m[2,-1] &lt;- 11
</code></pre>

<hr>
<h2 id='Extremes'>Extrema (Maxima and Minima)</h2><span id='topic+max.bigz'></span><span id='topic+max.bigq'></span><span id='topic+min.bigz'></span><span id='topic+min.bigq'></span><span id='topic+which.max+2Cbigq-method'></span><span id='topic+which.max+2Cbigz-method'></span><span id='topic+which.min+2Cbigq-method'></span><span id='topic+which.min+2Cbigz-method'></span>

<h3>Description</h3>

<p>We provide S3 <code><a href="utils.html#topic+methods">methods</a></code> for <code><a href="base.html#topic+min">min</a></code> and
<code><a href="base.html#topic+max">max</a></code> for big rationals (<code>bigq</code>) and big integers
(<code>biqz</code>);  consequently, <code><a href="base.html#topic+range">range</a>()</code> works as well.
</p>
<p>Similarly, S4 methods are provided for <code><a href="base.html#topic+which.min">which.min</a>()</code> and
<code><a href="base.html#topic+which.max">which.max</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bigz'
max(..., na.rm=FALSE)
## S3 method for class 'bigq'
max(..., na.rm=FALSE)
## S3 method for class 'bigz'
min(..., na.rm=FALSE)
## S3 method for class 'bigq'
min(..., na.rm=FALSE)

## S4 method for signature 'bigz'
which.min(x)


## S4 method for signature 'bigq'
which.max(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extremes_+3A_x">x</code></td>
<td>
<p>a &ldquo;big integer&rdquo; (<code>bigz</code>) or &ldquo;big rational&rdquo;
(<code>bigq</code>) vector.</p>
</td></tr>
<tr><td><code id="Extremes_+3A_...">...</code></td>
<td>
<p>numeric arguments</p>
</td></tr>
<tr><td><code id="Extremes_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether missing values should be removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"<a href="#topic+bigz">bigz</a>"</code> or <code>"<a href="#topic+bigq">bigq</a>"</code>.
</p>


<h3>Author(s)</h3>

<p>Antoine Lucas</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+max">max</a></code> etc in <span class="pkg">base</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> x &lt;- as.bigz(1:10)
 max(x)
 min(x)
 range(x) # works correctly via default method
 x &lt;- x[c(7:10,6:3,1:2)]
 which.min(x) ## 9
 which.max(x) ## 4

 Q &lt;- as.bigq(1:10, 3)
 max(Q)
 min(Q)
 (Q &lt;- Q[c(6:3, 7:10,1:2)])
 stopifnot(which.min(Q) == which.min(asNumeric(Q)),
           which.max(Q) == which.max(asNumeric(Q)))

stopifnot(range(x) == c(1,10), 3*range(Q) == c(1,10))
</code></pre>

<hr>
<h2 id='factorialZ'>Factorial and Binomial Coefficient as Big Integer</h2><span id='topic+factorialZ'></span><span id='topic+chooseZ'></span>

<h3>Description</h3>

<p>Efficiently compute the factorial <code class="reqn">n!</code> or a binomial coefficient
<code class="reqn">{n\choose k}</code> as big integer (class <code><a href="#topic+bigz">bigz</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factorialZ(n)
chooseZ(n, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factorialZ_+3A_n">n</code></td>
<td>
<p>non-negative integer (vector), for
<code>factorialZ</code>.  For <code>chooseZ</code>, may be a <code>bigz</code> big
integer, also negative.</p>
</td></tr>
<tr><td><code id="factorialZ_+3A_k">k</code></td>
<td>
<p>non-negative integer vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of big integers, i.e., of class <code><a href="#topic+bigz">bigz</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+factorial">factorial</a></code> and <code><a href="base.html#topic+gamma">gamma</a></code> in base <span class="rlang"><b>R</b></span>;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>factorialZ(0:10)# 1 1 2 6 ... 3628800
factorialZ(0:40)# larger
factorialZ(200)

n &lt;- 1000
f1000 &lt;- factorialZ(n)
stopifnot(1e-15 &gt; abs(as.numeric(1 - lfactorial(n)/log(f1000))))

system.time(replicate(8, f1e4 &lt;&lt;- factorialZ(10000)))
nchar(as.character(f1e4))# 35660 ... (too many to even look at ..)

chooseZ(1000, 100:102)# vectorizes
chooseZ(as.bigz(2)^120, 10)
n &lt;- c(50,80,100)
k &lt;- c(20,30,40)
## currently with an undesirable warning: % from methods/src/eval.c  _FIXME_
stopifnot(chooseZ(n,k) == factorialZ(n) / (factorialZ(k)*factorialZ(n-k)))
</code></pre>

<hr>
<h2 id='factorization'>Factorize a number</h2><span id='topic+factorize'></span>

<h3>Description</h3>

<p>Give all primes numbers to factor the number</p>


<h3>Usage</h3>

<pre><code class='language-R'>factorize(n)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factorization_+3A_n">n</code></td>
<td>
<p>Either integer, numeric or string value
(String value: ither starting with <code>0x</code> for hexadecimal, <code>0b</code> for
binary or without prefix for decimal values.)
Or an element of class bigz.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The factorization function uses the Pollard Rho algorithm.
</p>


<h3>Value</h3>

<p>Vector of class bigz.
</p>


<h3>Author(s)</h3>

<p>Antoine Lucas</p>


<h3>References</h3>

<p>The GNU MP Library, see <a href="https://gmplib.org">https://gmplib.org</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>factorize(34455342)
</code></pre>

<hr>
<h2 id='formatN'>Format Numbers Keeping Classes Distinguishable</h2><span id='topic+formatN'></span><span id='topic+formatN.default'></span><span id='topic+formatN.integer'></span><span id='topic+formatN.double'></span><span id='topic+formatN.bigz'></span><span id='topic+formatN.bigq'></span>

<h3>Description</h3>

<p>Format (generalized) numbers in a way that their <code><a href="base.html#topic+class">class</a></code>es
are distinguishable.  Contrary to <code><a href="base.html#topic+format">format</a>()</code> which uses a
common format for all elements of <code>x</code>, here, each entry is
formatted individually.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatN(x, ...)
## Default S3 method:
formatN(x, ...)
## S3 method for class 'integer'
formatN(x, ...)
## S3 method for class 'double'
formatN(x, ...)
## S3 method for class 'bigz'
formatN(x, ...)
## S3 method for class 'bigq'
formatN(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatN_+3A_x">x</code></td>
<td>
<p>any <span class="rlang"><b>R</b></span> object, typically &ldquo;number-like&rdquo;.</p>
</td></tr>
<tr><td><code id="formatN_+3A_...">...</code></td>
<td>
<p>potentially further arguments passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector of the same <code><a href="base.html#topic+length">length</a></code> as <code>x</code>,
each entry a representation of the corresponding entry in <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+format">format</a></code>, including its (sophisticated) default method;
<code><a href="base.html#topic+as.character">as.character</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Note that each class is uniquely recognizable from its output:
formatN(    -2:5)# integer
formatN(0 + -2:5)# double precision
formatN(as.bigz(-2:5))
formatN(as.bigq(-2:5, 4))
</code></pre>

<hr>
<h2 id='frexpZ'>Split Number into Fractional and Exponent of 2 Parts</h2><span id='topic+frexpZ'></span><span id='topic+frexp'></span>

<h3>Description</h3>

<p>Breaks the number <code>x</code> into its binary significand
(&ldquo;fraction&rdquo;) <code class="reqn">d \in [0.5, 1)</code>
and <code class="reqn">ex</code>, the integral exponent for 2, such that
<code class="reqn">x = d \cdot 2^{ex}.</code>
</p>
<p>If <code>x</code> is zero, both parts (significand and exponent) are zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frexpZ(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frexpZ_+3A_x">x</code></td>
<td>
<p>integer or big integer (<code><a href="#topic+bigz">bigz</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="base.html#topic+list">list</a></code> with the two components
</p>
<table>
<tr><td><code>d</code></td>
<td>
<p>a numeric vector whose absolute values are either zero, or in
<code class="reqn">[\frac{1}{2}, 1)</code>.</p>
</td></tr>
<tr><td><code>exp</code></td>
<td>
<p>an integer vector of the same length;
note that <code>exp == 1 + floor(log2(x))</code>, and hence always
<code>exp &gt; log2(x)</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+log2">log2</a></code>, etc; for <code><a href="#topic+bigz">bigz</a></code> objects built on
(the C++ equivalent of) <code>frexp()</code>, actually GMP's
&lsquo;<span class="samp">&#8288;mpz_get_d_2exp()&#8288;</span>&rsquo;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>frexpZ(1:10)
## and confirm :
with(frexpZ(1:10),  d * 2^exp)
x &lt;- rpois(1000, lambda=100) * (1 + rpois(1000, lambda=16))
X &lt;- as.bigz(x)
stopifnot(all.equal(x, with(frexpZ(x), d* 2^exp)),
          1+floor(log2(x)) == (fx &lt;- frexpZ(x)$exp),
          fx == frexpZ(X)$exp,
          1+floor(log2(X)) == fx
)
</code></pre>

<hr>
<h2 id='gcd.bigz'>Greatest Common Divisor (GCD) and Least Common Multiple (LCM)</h2><span id='topic+gcd.bigz'></span><span id='topic+gcd'></span><span id='topic+gcd.default'></span><span id='topic+lcm.default'></span><span id='topic+lcm.bigz'></span>

<h3>Description</h3>

<p>Compute the greatest common divisor (GCD) and least common multiple
(LCM) of two (big) integers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bigz'
gcd(a, b)
lcm.bigz(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gcd.bigz_+3A_a">a</code>, <code id="gcd.bigz_+3A_b">b</code></td>
<td>
<p>Either integer, numeric, <code><a href="#topic+bigz">bigz</a></code> or a string
value; if a string, either starting with <code>0x</code> for hexadecimal,
<code>0b</code> for binary or without prefix for decimal values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An element of class bigz
</p>


<h3>Author(s)</h3>

<p>Antoine Lucas</p>


<h3>References</h3>

<p>The GNU MP Library, see <a href="https://gmplib.org">https://gmplib.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gcdex">gcdex</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>gcd.bigz(210,342) # or also
lcm.bigz(210,342)
a &lt;- 210 ; b &lt;- 342
stopifnot(gcd.bigz(a,b) * lcm.bigz(a,b) == a * b)

## or
(a &lt;- as.bigz("82696155787249022588"))
(b &lt;- as.bigz("65175989479756205392"))
gcd(a,b) # 4
stopifnot(gcd(a,b) * lcm.bigz(a,b) == a * b)
</code></pre>

<hr>
<h2 id='gcdex'>Compute Bezoult Coefficient</h2><span id='topic+gcdex'></span>

<h3>Description</h3>

<p>Compute g,s,t as
<code class="reqn">as + bt = g = gcd(a,b)</code>.
s and t are also known as Bezoult coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcdex(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gcdex_+3A_a">a</code>, <code id="gcdex_+3A_b">b</code></td>
<td>
<p>either integer, numeric, character string, or of class <code>"bigz"</code>;
If a string, either starting with <code>"0x"</code> for hexadecimal, <code>"0b"</code> for
binary or without prefix for decimal values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a class <code>"bigz"</code> vector of length 3 with (long integer) values
<code class="reqn">g, s, t</code>.
</p>


<h3>Author(s)</h3>

<p>Antoine Lucas</p>


<h3>References</h3>

<p>The GNU MP Library, see <a href="https://gmplib.org">https://gmplib.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gcd.bigz">gcd.bigz</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>gcdex(342,654)
</code></pre>

<hr>
<h2 id='gmp-ifiworkarounds'>Base Functions in 'gmp'-ified Versions</h2><span id='topic+outer'></span>

<h3>Description</h3>

<p>Functions from <span class="pkg">base</span> etc which need a <em>copy</em> in the
<span class="pkg">gmp</span> namespace so they correctly dispatch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outer(X, Y, FUN = "*", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmp-ifiworkarounds_+3A_x">X</code>, <code id="gmp-ifiworkarounds_+3A_y">Y</code>, <code id="gmp-ifiworkarounds_+3A_fun">FUN</code>, <code id="gmp-ifiworkarounds_+3A_...">...</code></td>
<td>
<p>See <span class="pkg">base</span> package help: <code><a href="base.html#topic+outer">outer</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+outer">outer</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>twop &lt;- as.bigz(2)^(99:103)
(mtw &lt;- outer(twop, 0:2))
stopifnot(
   identical(dim(mtw), as.integer(c(5,3)))
 ,
   mtw[,1] == 0
 ,
   identical(as.vector(mtw[,2]), twop)
)
</code></pre>

<hr>
<h2 id='gmp.utils'>GMP Number Utilities</h2><span id='topic+gmpVersion'></span>

<h3>Description</h3>

<p><code>gmpVersion()</code> returns the version of the GMP library which
<span class="pkg">gmp</span> is currently linked to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmpVersion()
</code></pre>


<h3>References</h3>

<p>The GNU MP Library, see <a href="https://gmplib.org">https://gmplib.org</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>gmpVersion()
</code></pre>

<hr>
<h2 id='is.whole'>Whole (&quot;Integer&quot;) Numbers</h2><span id='topic+is.whole'></span><span id='topic+is.whole.default'></span><span id='topic+is.whole.bigz'></span><span id='topic+is.whole.bigq'></span>

<h3>Description</h3>

<p>Check which elements of <code>x[]</code> are integer valued aka
&ldquo;whole&rdquo; numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.whole(x)
## Default S3 method:
is.whole(x)
## S3 method for class 'bigz'
is.whole(x)
## S3 method for class 'bigq'
is.whole(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.whole_+3A_x">x</code></td>
<td>
<p>any <span class="rlang"><b>R</b></span> vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector of the same length as <code>x</code>, indicating where
<code>x[.]</code> is integer valued.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+is.integer">is.integer</a>(x)</code> (<span class="pkg">base</span> package) checks for the
<em>internal</em> mode or class; not if <code>x[i]</code> are integer valued.
</p>
<p>The <code><a href="Rmpfr.html#topic+is.whole">is.whole</a>()</code> method for &quot;mpfr&quot; numbers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> is.integer(3) # FALSE, it's internally a double
 is.whole(3)   # TRUE
 ## integer valued complex numbers  (two FALSE) :
 is.whole(c(7, 1 + 1i, 1.2, 3.4i, 7i))
 is.whole(factorialZ(20)^(10:12)) ## "bigz" are *always* whole numbers
 q &lt;- c(as.bigz(36)^50 / as.bigz(30)^40, 3, factorialZ(30:31), 12.25)
 is.whole(q) # F T T T F
</code></pre>

<hr>
<h2 id='isprime'>Determine if number is (very probably) prime</h2><span id='topic+isprime'></span>

<h3>Description</h3>

<p>Determine whether the number <code class="reqn">n</code> is prime or not, with
<em>three</em> possible answers:
</p>

<dl>
<dt>2:</dt><dd><p><code class="reqn">n</code> is prime,</p>
</dd>
<dt>1:</dt><dd><p><code class="reqn">n</code> is probably prime (without beeing certain),</p>
</dd>
<dt>0:</dt><dd><p><code class="reqn">n</code> is composite.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>isprime(n, reps = 40)  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isprime_+3A_n">n</code></td>
<td>
<p>integer number, to be tested.</p>
</td></tr>
<tr><td><code id="isprime_+3A_reps">reps</code></td>
<td>
<p>integer number of primality testing repeats.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function does some trial divisions, then some Miller-Rabin
probabilistic primary tests.  <code>reps</code> controls how many such tests are
done, 5 to 10 is already a resonable number.  More will reduce the chances
of a composite being returned as &ldquo;probably prime&rdquo;.
</p>


<h3>Value</h3>

<table>
<tr><td><code>0</code></td>
<td>
<p><code class="reqn">n</code> is not prime</p>
</td></tr>
<tr><td><code>1</code></td>
<td>
<p><code class="reqn">n</code> is probably prime</p>
</td></tr>
<tr><td><code>2</code></td>
<td>
<p><code class="reqn">n</code> is prime</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antoine Lucas</p>


<h3>References</h3>

<p>The GNU MP Library, see <a href="https://gmplib.org">https://gmplib.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+nextprime">nextprime</a></code>, <code><a href="#topic+factorize">factorize</a></code>.
</p>
<p>Note that for &ldquo;small&rdquo; <code class="reqn">n</code>, which means something like
<code class="reqn">n &lt; 10'000'000</code>, non-probabilistic methods (such as
<code><a href="#topic+factorize">factorize</a>()</code>) are fast enough. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isprime(210)
isprime(71)

# All primes numbers from 1 to 100
t &lt;- isprime(1:99)
(1:99)[t &gt; 0]

table(isprime(1:10000))# 0 and 2 : surely prime or not prime

primes &lt;- function(n) {
  ## all primes &lt;= n
  stopifnot(length(n) == 1, n &lt;= 1e7) # be reasonable
  p &lt;- c(2L, as.integer(seq(3, n, by=2)))
  p[isprime(p) &gt; 0]
}

## quite quickly, but for these small numbers
## still slower than e.g., sfsmisc::primes()
system.time(p100k &lt;- primes(100000))

## The first couple of Mersenne primes:
p.exp &lt;- primes(1000)
Mers &lt;- as.bigz(2) ^ p.exp - 1
isp.M &lt;- sapply(seq_along(Mers), function(i) isprime(Mers[i], reps=256))
cbind(p.exp, isp.M)[isp.M &gt; 0,]
Mers[isp.M &gt; 0]
</code></pre>

<hr>
<h2 id='lucnum'>Compute Fibonacci and Lucas numbers</h2><span id='topic+fibnum'></span><span id='topic+fibnum2'></span><span id='topic+lucnum'></span><span id='topic+lucnum2'></span>

<h3>Description</h3>

<p>fibnum  compute n-th Fibonacci number.
fibnum2 compute (n-1)-th and n-th Fibonacci number.
lucnum  compute n-th lucas number.
lucnum2 compute (n-1)-th and n-th lucas number.
</p>
<p>Fibonacci numbers are define by: <code class="reqn">F_n=F_{n-1}+F_{n-2}</code>
Lucas numbers are define by: <code class="reqn">L_n=F_n+2F_{n-1}</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fibnum(n)
fibnum2(n)
lucnum(n)
lucnum2(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lucnum_+3A_n">n</code></td>
<td>
<p>Integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Fibonacci numbers and Lucas number.
</p>


<h3>Author(s)</h3>

<p>Antoine Lucas</p>


<h3>References</h3>

<p>The GNU MP Library, see <a href="https://gmplib.org">https://gmplib.org</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>fibnum(10)
fibnum2(10)
lucnum(10)
lucnum2(10)

</code></pre>

<hr>
<h2 id='matrix'>Matrix manipulation with gmp</h2><span id='topic+matrix'></span><span id='topic+matrix.default'></span><span id='topic+matrix.bigz'></span><span id='topic+matrix.bigq'></span><span id='topic+is.matrixZQ'></span><span id='topic+as.matrix.bigz'></span><span id='topic+as.matrix.bigq'></span><span id='topic+as.vector.bigq'></span><span id='topic+as.vector.bigz'></span><span id='topic++25+2A+25'></span><span id='topic++25+2A+25.default'></span><span id='topic++25+2A+25.bigq'></span><span id='topic++25+2A+25.bigz'></span><span id='topic+crossprod'></span><span id='topic+crossprod.default'></span><span id='topic+crossprod.bigq'></span><span id='topic+crossprod.bigz'></span><span id='topic+tcrossprod'></span><span id='topic+tcrossprod.default'></span><span id='topic+tcrossprod.bigq'></span><span id='topic+tcrossprod.bigz'></span><span id='topic+ncol.bigq'></span><span id='topic+ncol.bigz'></span><span id='topic+nrow.bigq'></span><span id='topic+nrow.bigz'></span><span id='topic+cbind.bigz'></span><span id='topic+cbind.bigq'></span><span id='topic+rbind.bigz'></span><span id='topic+rbind.bigq'></span><span id='topic+t.bigq'></span><span id='topic+t.bigz'></span><span id='topic+dim.bigq'></span><span id='topic+dim+3C-.bigq'></span><span id='topic+dim.bigz'></span><span id='topic+dim+3C-.bigz'></span>

<h3>Description</h3>

<p>Overload of &ldquo;all&rdquo; standard tools useful for matrix manipulation adapted
to large numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bigz'
matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL, mod = NA,...)

is.matrixZQ(x)

## S3 method for class 'bigz'
x %*% y
## S3 method for class 'bigq'
x %*% y
## S3 method for class 'bigq'
crossprod(x, y=NULL,...)
## S3 method for class 'bigz'
tcrossprod(x, y=NULL,...)
## ..... etc
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_+3A_data">data</code></td>
<td>
<p>an optional data vector</p>
</td></tr>
<tr><td><code id="matrix_+3A_nrow">nrow</code></td>
<td>
<p>the desired number of rows </p>
</td></tr>
<tr><td><code id="matrix_+3A_ncol">ncol</code></td>
<td>
<p>the desired number of columns</p>
</td></tr>
<tr><td><code id="matrix_+3A_byrow">byrow</code></td>
<td>
<p>logical.  If <code>FALSE</code> (the default), the matrix is filled by
columns, otherwise the matrix is filled by rows.</p>
</td></tr>
<tr><td><code id="matrix_+3A_dimnames">dimnames</code></td>
<td>
<p>not implemented for <code>"bigz"</code> or <code>"bigq"</code> matrices.</p>
</td></tr>
<tr><td><code id="matrix_+3A_mod">mod</code></td>
<td>
<p>optional modulus (when <code>data</code> is <code>"bigz"</code>).</p>
</td></tr>
<tr><td><code id="matrix_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id="matrix_+3A_x">x</code>, <code id="matrix_+3A_y">y</code></td>
<td>
<p>numeric, <code>bigz</code>, or <code>bigq</code> matrices or vectors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The extract function (<code>"["</code>) is the same use for vector or
matrix.  Hence, <code>x[i]</code> returns the same values as <code>x[i,]</code>.
This is not considered a feature and may be changed in the future
(with warnings).
</p>
<p>All matrix multiplications should work as with numeric matrices.
</p>
<p>Special features concerning the <code>"<a href="#topic+bigz">bigz</a>"</code> class: the
modulus can be
</p>

<dl>
<dt>Unset:</dt><dd><p>Just play with large numbers</p>
</dd>
<dt>Set with a vector of size 1:</dt><dd><p>Example:
<code>matrix.bigz(1:6,nrow=2,ncol=3,mod=7)</code>
This means you work
in <code class="reqn">Z/nZ</code>, for the whole matrix.  It is the only case
where the <code>%*%</code> and <code><a href="Matrix.html#topic+solve">solve</a></code> functions will work
in <code class="reqn">Z/nZ</code>.</p>
</dd>
<dt>Set with a vector smaller than data:</dt><dd><p>Example:
<code>matrix.bigz(1:6,nrow=2,ncol=3,mod=1:5)</code>. Then, the modulus
is repeated to the end of data.  This can be used to define a
matrix with a different modulus at each row.
</p>
</dd>
<dt>Set with same size as data:</dt><dd><p>Modulus is defined for each cell</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>matrix()</code>: A matrix of class <code>"bigz"</code> or <code>"bigq"</code>.
</p>
<p><code>is.matrixZQ()</code>: <code><a href="base.html#topic+TRUE">TRUE</a></code> or <code>FALSE</code>.
</p>
<p><code>dim()</code>, <code>ncol()</code>, etc: integer or <code>NULL</code>, as for
simple matrices.
</p>


<h3>Author(s)</h3>

<p>Antoine Lucas</p>


<h3>See Also</h3>

<p>Solving a linear system: <code><a href="#topic+solve.bigz">solve.bigz</a></code>.
<code><a href="base.html#topic+matrix">matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>V &lt;- as.bigz(v &lt;- 3:7)
crossprod(V)# scalar product
(C &lt;- t(V))
stopifnot(dim(C) == dim(t(v)), C == v,
          dim(t(C)) == c(length(v), 1),
          crossprod(V) == sum(V * V),
         tcrossprod(V) == outer(v,v),
          identical(C, t(t(C))),
          is.matrixZQ(C), !is.matrixZQ(V), !is.matrixZQ(5)
	)

## a matrix
x &lt;- diag(1:4)
## invert this matrix
(xI &lt;- solve(x))

## matrix in Z/7Z
y &lt;- as.bigz(x,7)
## invert this matrix (result is *different* from solve(x)):
(yI &lt;- solve(y))
stopifnot(yI %*% y == diag(4),
          y %*% yI == diag(4))

## matrix in Q
z  &lt;- as.bigq(x)
## invert this matrix (result is the same as solve(x))
(zI &lt;- solve(z))

stopifnot(abs(zI - xI) &lt;= 1e-13,
          z %*% zI == diag(4),
          identical(crossprod(zI), zI %*% t(zI))
         )

A &lt;- matrix(2^as.bigz(1:12), 3,4)
for(a in list(A, as.bigq(A, 16), factorialZ(20), as.bigq(2:9, 3:4))) {
  a.a &lt;- crossprod(a)
  aa. &lt;- tcrossprod(a)
  stopifnot(identical(a.a, crossprod(a,a)),
 	    identical(a.a, t(a) %*% a)
            ,
            identical(aa., tcrossprod(a,a)),
	    identical(aa., a %*% t(a))
 	   )
}# {for}
</code></pre>

<hr>
<h2 id='modulus'>Modulus of a Big Integer</h2><span id='topic+modulus'></span><span id='topic+modulus+3C-'></span><span id='topic+modulus.bigz'></span><span id='topic+modulus+3C-.bigz'></span>

<h3>Description</h3>

<p>The modulus of a <code><a href="#topic+bigz">bigz</a></code> number <code class="reqn">a</code> is
&ldquo;unset&rdquo; when <code class="reqn">a</code> is a regular integer, <code class="reqn">a \in Z</code>).
Or the modulus can be set to <code class="reqn">m</code> which means
<code class="reqn">a \in Z/\,m\cdot Z</code>), i.e., all arithmetic with
<code class="reqn">a</code> is performed &lsquo;modulo m&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modulus(a)
modulus(a) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modulus_+3A_a">a</code></td>
<td>
<p><span class="rlang"><b>R</b></span> object of class <code>"<a href="#topic+bigz">bigz</a>"</code></p>
</td></tr>
<tr><td><code id="modulus_+3A_value">value</code></td>
<td>
<p>integer number or object of class <code>"<a href="#topic+bigz">bigz</a>"</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.bigz(24)
modulus(x) # NULL, i.e. none

# x element of Z/31Z :
modulus(x) &lt;- 31
x+x  #  48 |-&gt; (17 %% 31)
10*x # 240 |-&gt; (23 %% 31)
x31 &lt;- x

# reset modulus to "none":
modulus(x) &lt;- NA; x; x. &lt;- x
x &lt;- x31
modulus(x) &lt;- NULL; x

stopifnot(identical(x,            as.bigz(24)), identical(x, x.),
          identical(modulus(x31), as.bigz(31)))
</code></pre>

<hr>
<h2 id='mpfr'>Exported function for mpfr use</h2><span id='topic+.as.bigz'></span><span id='topic+..as.bigz'></span><span id='topic+.as.char.bigz'></span><span id='topic+.sub.bigq'></span>

<h3>Description</h3>

<p>Theses hidden function are provided for mpfr use. Use theses function with care.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.as.bigz(a, mod=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpfr_+3A_a">a</code></td>
<td>
<p>either <code><a href="base.html#topic+integer">integer</a></code>, <code><a href="base.html#topic+numeric">numeric</a></code> (i.e.,
<code><a href="base.html#topic+double">double</a></code>) or <code><a href="base.html#topic+character">character</a></code> vector.
</p>
<p>If character: the strings either start with <code>0x</code> for hexadecimal, <code>0b</code> for
binary, <code>0</code> for octal, or without a <code>0*</code> prefix for decimal values.
Formatting errors are signalled as with <code><a href="base.html#topic+stop">stop</a></code>.</p>
</td></tr>
<tr><td><code id="mpfr_+3A_mod">mod</code></td>
<td>
<p>an integer, numeric, string or bigz of the internal modulus, see below.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <span class="rlang"><b>R</b></span> object of (S3) class <code>"bigz"</code>, representing the argument
(<code>x</code> or <code>a</code>).
</p>


<h3>References</h3>

<p>The GNU MP Library, see <a href="https://gmplib.org">https://gmplib.org</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>.as.bigz(1)
</code></pre>

<hr>
<h2 id='nextprime'>Next Prime Number</h2><span id='topic+nextprime'></span>

<h3>Description</h3>

<p>Return the next prime number, say <code class="reqn">p</code>, with <code class="reqn">p &gt; n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nextprime(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nextprime_+3A_n">n</code></td>
<td>
<p>Integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses probabilistic algorithm to identify
primes.  For practical purposes, it is adequate, the chance
of a composite passing will be extremely small.
</p>


<h3>Value</h3>

<p>A (probably) prime number
</p>


<h3>Author(s)</h3>

<p>Antoine Lucas</p>


<h3>References</h3>

<p>The GNU MP Library, see <a href="https://gmplib.org">https://gmplib.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+isprime">isprime</a></code> and its references and examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nextprime(14)
## still very fast:
(p &lt;- nextprime(1e7))
## to be really sure { isprime()  gives "probably prime" } :
stopifnot(identical(p, factorize(p)))
</code></pre>

<hr>
<h2 id='Oakley'>RFC 2409 Oakley Groups - Parameters for Diffie-Hellman Key Exchange</h2><span id='topic+Oakley'></span><span id='topic+Oakley1'></span><span id='topic+Oakley2'></span>

<h3>Description</h3>

<p>RFC 2409 standardizes global unique prime numbers and generators for
the purpose of secure asymmetric key exchange on the Internet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Oakley1)
data(Oakley2)
</code></pre>


<h3>Value</h3>

<p>Oakley1 returns an object of class <code><a href="#topic+bigz">bigz</a></code> for a 768 bit Diffie-Hellman group.  The generator is stored as value with the respective prime number as modulus attribute.
</p>
<p>Oakley2 returns an object of class <code><a href="#topic+bigz">bigz</a></code> for a 1024 bit Diffie-Hellman group.  The generator is stored as value with the respective prime number as modulus attribute.
</p>


<h3>References</h3>

<p>The Internet Key Exchange (RFC 2409), Nov. 1998</p>


<h3>Examples</h3>

<pre><code class='language-R'>packageDescription("gmp") # {possibly useful for debugging}

data(Oakley1)
(M1 &lt;- modulus(Oakley1))
isprime(M1)# '1' : "probably prime"
sizeinbase(M1)#  232 digits (was 309 in older version)
</code></pre>

<hr>
<h2 id='powm'>Exponentiation function</h2><span id='topic+powm'></span>

<h3>Description</h3>

<p>This function return <code class="reqn">x ^ y mod n</code>.
</p>
<p>This function return <code class="reqn">x ^ y mod n</code>
pow.bigz do the same when modulus is set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powm(x, y, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="powm_+3A_x">x</code></td>
<td>
<p>Integer or big integer - possibly a vector</p>
</td></tr>
<tr><td><code id="powm_+3A_y">y</code></td>
<td>
<p>Integer or big integer - possibly a vector</p>
</td></tr>
<tr><td><code id="powm_+3A_n">n</code></td>
<td>
<p>Integer or big integer - possibly a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A bigz class representing the parameter value.
</p>


<h3>Author(s)</h3>

<p>A. L.</p>


<h3>See Also</h3>

<p><code><a href="#topic+pow.bigz">pow.bigz</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>powm(4,7,9)


x = as.bigz(4,9)
x ^ 7

</code></pre>

<hr>
<h2 id='Random'>Generate a random number</h2><span id='topic+urand.bigz'></span>

<h3>Description</h3>

<p>Generate a uniformly distributed random number in the range 0 to
<code class="reqn">2^{size} -1</code>, inclusive.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>urand.bigz(nb=1,size=200, seed = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Random_+3A_nb">nb</code></td>
<td>
<p>Integer: number of random numbers to be generated (size of
vector returned)</p>
</td></tr>
<tr><td><code id="Random_+3A_size">size</code></td>
<td>
<p>Integer: number will be generated in the range 0 to
<code class="reqn">2^{size} -1</code></p>
</td></tr>
<tr><td><code id="Random_+3A_seed">seed</code></td>
<td>
<p>Bigz: random seed initialisation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A biginteger of class bigz.
</p>


<h3>Author(s)</h3>

<p>Antoine Lucas</p>


<h3>References</h3>

<p>&lsquo;<span class="samp">&#8288;mpz\_urandomb&#8288;</span>&rsquo; from the GMP Library, see <a href="https://gmplib.org">https://gmplib.org</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Integers are differents
urand.bigz()
urand.bigz()
urand.bigz()

# Integers are the same
urand.bigz(seed="234234234324323")
urand.bigz(seed="234234234324323")

# Vector
urand.bigz(nb=50,size=30)
</code></pre>

<hr>
<h2 id='Relational_Operator'>Relational Operators</h2><span id='topic++3D+3D.bigz'></span><span id='topic++21+3D.bigz'></span><span id='topic++3C.bigz'></span><span id='topic++3C+3D.bigz'></span><span id='topic++3E.bigz'></span><span id='topic++3E+3D.bigz'></span><span id='topic+sign.bigz'></span>

<h3>Description</h3>

<p>Binary operators which allow the comparison of values in atomic vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bigz'
sign(x)
## S3 method for class 'bigz'
e1 == e2
## S3 method for class 'bigz'
 e1 &lt; e2
## S3 method for class 'bigz'
e1 &gt;= e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Relational_Operator_+3A_x">x</code>, <code id="Relational_Operator_+3A_e1">e1</code>, <code id="Relational_Operator_+3A_e2">e2</code></td>
<td>
<p><span class="rlang"><b>R</b></span> object (vector or matrix-like) of class <code>"<a href="#topic+bigz">bigz</a>"</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+mod.bigz">mod.bigz</a></code> for arithmetic operators.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- as.bigz(8000)
  x ^ 300 &lt; 2 ^x

  sign(as.bigz(-3:3))
  sign(as.bigq(-2:2, 7))
</code></pre>

<hr>
<h2 id='roundQ'>Rounding Big Rationals (&quot;bigq&quot;) to Decimals</h2><span id='topic+roundQ'></span><span id='topic+round0'></span><span id='topic+round.bigq'></span>

<h3>Description</h3>

<p>Rounding big rationals (of class <code>"bigq"</code>, see <code><a href="#topic+as.bigq">as.bigq</a>()</code>)
to decimal <code>digits</code> is strictly based on a (optionally choosable)
definition of rounding to integer, i.e., <code>digits = 0</code>, the default
method of which we provide as <code>round0()</code>.
</p>
<p>The users typically just call <code>round(x, digits)</code> as elsewhere, and
the <code>round()</code> method will call <code>round(x, digits, round0=round0)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>round0(x)

roundQ(x, digits = 0, r0 = round0)

## S3 method for class 'bigq'
round(x, digits = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roundQ_+3A_x">x</code></td>
<td>
<p>vector of big rationals, i.e., of <code><a href="base.html#topic+class">class</a></code> <code>"bigq"</code>.</p>
</td></tr>
<tr><td><code id="roundQ_+3A_digits">digits</code></td>
<td>
<p>integer number of decimal digits to round to.</p>
</td></tr>
<tr><td><code id="roundQ_+3A_r0">r0</code></td>
<td>
<p>a <code><a href="base.html#topic+function">function</a></code> of one argument which implements a
version of <code><a href="base.html#topic+round">round</a>(x, digits=0)</code>.   The default for
<code>roundQ()</code> is to use our <code>round0()</code> which implements
&ldquo;round to even&rdquo;, as base <span class="rlang"><b>R</b></span>'s <code><a href="base.html#topic+round">round</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>round0()</code> returns a vector of big integers, i.e., <code>"bigz"</code> classed.
</p>
<p><code>roundQ(x, digits, round0)</code> returns a vector of big rationals,
<code>"bigq"</code>, as <code>x</code>.
</p>
<p><code>round.bigq</code> is very simply defined as
<code>function(x, digits)  roundQ(x, digits)</code> .
</p>


<h3>Author(s)</h3>

<p>Martin Maechler, ETH Zurich</p>


<h3>References</h3>

<p>The vignette &ldquo;<em>Exact Decimal Rounding via Rationals</em>&rdquo; from
CRAN package <a href="https://CRAN.R-project.org/package=round"><span class="pkg">round</span></a>,


</p>
<p>Wikipedia, Rounding, notably &quot;Round half to even&quot;:
<a href="https://en.wikipedia.org/wiki/Rounding#Round_half_to_even">https://en.wikipedia.org/wiki/Rounding#Round_half_to_even</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+round">round</a></code> for (double precision) numbers in base <span class="rlang"><b>R</b></span>;
<code><a href="round.html#topic+roundX">roundX</a></code> from CRAN package <a href="https://CRAN.R-project.org/package=round"><span class="pkg">round</span></a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qq &lt;- as.bigq((-21:31), 10)
noquote(cbind(as.character(qq), asNumeric(qq)))
round0(qq) # Big Integer ("bigz")
## corresponds to R's own "round to even" :
stopifnot(round0(qq) == round(asNumeric(qq)))
round(qq) # == round(qq, 0): the same as round0(qq) *but* Big Rational ("bigq")

halfs &lt;- as.bigq(1,2) + -5:12



## round0() is simply
round0 &lt;- function (x) {
    nU &lt;- as.bigz.bigq(xU &lt;- x + as.bigq(1, 2)) # traditional round: .5 rounded up
    if(any(I &lt;- is.whole.bigq(xU))) { # I &lt;==&gt;  x == &lt;n&gt;.5 : "hard case"
        I[I] &lt;- .mod.bigz(nU[I], 2L) == 1L # rounded up is odd  ==&gt; round *down*
        nU[I] &lt;- nU[I] - 1L
    }
    nU
}

## 's' for simple: rounding as you learned in school:
round0s &lt;- function(x) as.bigz.bigq(x + as.bigq(1, 2))

cbind(halfs, round0s(halfs), round0(halfs))


## roundQ() is simply
roundQ &lt;- function(x, digits = 0, r0 = round0) {
    ## round(x * 10^d) / 10^d --  vectorizing in both (x, digits)
    p10 &lt;- as.bigz(10) ^ digits # class: if(all(digits &gt;= 0)) "bigz" else "bigq"
    r0(x * p10) / p10
}
</code></pre>

<hr>
<h2 id='sizeinbase'>Compute size of a bigz in a base</h2><span id='topic+sizeinbase'></span>

<h3>Description</h3>

<p>Return an approximation to the number of
character the integer X would have printed in base b.  The
approximation is never too small. 
</p>
<p>In case of powers of 2, function gives exact result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sizeinbase(a, b=10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sizeinbase_+3A_a">a</code></td>
<td>
<p>big integer, i.e. <code>"<a href="#topic+bigz">bigz</a>"</code></p>
</td></tr>
<tr><td><code id="sizeinbase_+3A_b">b</code></td>
<td>
<p>base</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer of the same length as <code>a</code>: the size, i.e. number of
digits, of each <code>a[i]</code>.
</p>


<h3>Author(s)</h3>

<p>Antoine Lucas</p>


<h3>References</h3>

<p>The GNU MP Library, see <a href="https://gmplib.org">https://gmplib.org</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>sizeinbase(342434, 10)# 6 obviously

Iv &lt;- as.bigz(2:7)^500
sizeinbase(Iv)
stopifnot(sizeinbase(Iv)       == nchar(as.character(Iv)),
          sizeinbase(Iv, b=16) == nchar(as.character(Iv, b=16)))
</code></pre>

<hr>
<h2 id='solve.bigz'>Solve a system of equation</h2><span id='topic+solve.bigz'></span><span id='topic+solve.bigq'></span>

<h3>Description</h3>

<p>This generic function solves the equation <code class="reqn">a \%*\% x = b</code> for
<code class="reqn">x</code>, where <code class="reqn">b</code> can be either a vector or a matrix.
</p>
<p>If a and b are rational, return is a rational matrix.
</p>
<p>If a and b are big integers (of class bigz) solution is in Z/nZ if
there is a common modulus, or a rational matrix if not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bigz'
solve(a, b, ...)
## S3 method for class 'bigq'
solve(a, b, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solve.bigz_+3A_a">a</code>, <code id="solve.bigz_+3A_b">b</code></td>
<td>
<p>A element of class bigz or bigq</p>
</td></tr>
<tr><td><code id="solve.bigz_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It uses the Gauss and trucmuch algo ... (to be detailled).
</p>


<h3>Value</h3>

<p>If a and b are rational, return is a rational matrix.
</p>
<p>If a and b are big integers (of class bigz) solution is in Z/nZ if
there is a common modulus, of a rational matrix if not.
</p>


<h3>Author(s)</h3>

<p>Antoine Lucas</p>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic+solve">solve</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(1:4,2,2)  ## standard solve :
solve(x)

q &lt;- as.bigq(x) ## solve with rational
solve(q)

z &lt;- as.bigz(x)
modulus(z) &lt;- 7  ## solve in Z/7Z :
solve(z)

b &lt;- c(1,3)
solve(q,b)
solve(z,b)

## Inversion of ("non-trivial") rational matrices :

A &lt;- rbind(c(10, 1,  3),
           c( 4, 2, 10),
           c( 1, 8,  2))
(IA.q &lt;- solve(as.bigq(A))) # fractions..
stopifnot(diag(3) == A %*% IA.q)# perfect

set.seed(5); B &lt;- matrix(round(9*runif(5^2, -1,1)), 5)
B
(IB.q &lt;- solve(as.bigq(B)))
stopifnot(diag(5) == B %*% IB.q, diag(5) == IB.q %*% B,
          identical(B, asNumeric(solve(IB.q))))
</code></pre>

<hr>
<h2 id='Stirling'>Eulerian and Stirling Numbers of First and Second Kind</h2><span id='topic+Eulerian'></span><span id='topic+Stirling1'></span><span id='topic+Stirling2'></span><span id='topic+Eulerian.all'></span><span id='topic+Stirling1.all'></span><span id='topic+Stirling2.all'></span>

<h3>Description</h3>

<p>Compute Eulerian numbers and Stirling numbers of the first and second
kind, possibly vectorized for all <code class="reqn">k</code> &ldquo;at once&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Stirling1(n, k)
Stirling2(n, k, method = c("lookup.or.store", "direct"))
Eulerian (n, k, method = c("lookup.or.store", "direct"))

Stirling1.all(n)
Stirling2.all(n)
Eulerian.all (n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Stirling_+3A_n">n</code></td>
<td>
<p>positive integer (<code>0</code> is allowed for <code>Eulerian()</code>).</p>
</td></tr>
<tr><td><code id="Stirling_+3A_k">k</code></td>
<td>
<p>integer in <code>0:n</code>.</p>
</td></tr>
<tr><td><code id="Stirling_+3A_method">method</code></td>
<td>
<p>for <code>Eulerian()</code> and <code>Stirling2()</code>, string
specifying the method to be used.  <code>"direct"</code> uses the explicit
formula (which may suffer from some cancelation for &ldquo;large&rdquo;
<code>n</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Eulerian numbers:<br />
<code class="reqn">A(n,k) =</code> the number of permutations of 1,2,...,n with exactly <code class="reqn">k</code>
ascents (or exactly <code class="reqn">k</code> descents).
</p>
<p>Stirling numbers of the first kind:<br />
<code class="reqn">s(n,k) = (-1)^{n-k}</code> times
the number of permutations of 1,2,...,n with exactly k cycles.
</p>
<p>Stirling numbers of the second kind:<br />
<code class="reqn">S^{(k)}_n</code> is the number of ways of partitioning a set
of <code class="reqn">n</code> elements into <code class="reqn">k</code> non-empty subsets.
</p>


<h3>Value</h3>

<p><code class="reqn">A(n,k)</code>, <code class="reqn">s(n,k)</code> or <code class="reqn">S(n,k) = S^{(k)}_n</code>, respectively.
</p>
<p><code>Eulerian.all(n)</code> is the same as <code>sapply(0:(n-1), Eulerian, n=n)</code>
(for <code class="reqn">n &gt; 0</code>), <br />
<code>Stirling1.all(n)</code> is the same as <code>sapply(1:n, Stirling1, n=n)</code>,
and<br />
<code>Stirling2.all(n)</code> is the same as <code>sapply(1:n, Stirling2, n=n)</code>,
but more efficient.
</p>


<h3>Note</h3>

<p>For typical double precision arithmetic,<br />
<code>Eulerian*(n, *)</code> overflow (to <code>Inf</code>) for <code class="reqn">n \ge 172</code>,<br />
<code>Stirling1*(n, *)</code> overflow (to <code class="reqn">\pm</code><code>Inf</code>) for <code class="reqn">n \ge 171</code>, and<br />
<code>Stirling2*(n, *)</code> overflow (to <code>Inf</code>) for <code class="reqn">n \ge 220</code>.



</p>


<h3>Author(s)</h3>

<p>Martin Maechler (&quot;direct&quot;: May 1992)</p>


<h3>References</h3>

<p><b>Eulerians:</b>
</p>
<p>NIST Digital Library of Mathematical Functions,
26.14: <a href="https://dlmf.nist.gov/26.14">https://dlmf.nist.gov/26.14</a>
</p>
<p><b>Stirling numbers:</b>
</p>
<p>Abramowitz and Stegun
24,1,4 (p. 824-5 ; Table 24.4, p.835);
Closed Form : p.824 &quot;C.&quot;
</p>
<p>NIST Digital Library of Mathematical Functions,
26.8: <a href="https://dlmf.nist.gov/26.8">https://dlmf.nist.gov/26.8</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chooseZ">chooseZ</a></code> for the binomial coefficients.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Stirling1(7,2)
Stirling2(7,3)

stopifnot(
 Stirling1.all(9) == c(40320, -109584, 118124, -67284, 22449, -4536, 546, -36, 1)
 ,
 Stirling2.all(9) == c(1, 255, 3025, 7770, 6951, 2646, 462, 36, 1)
 ,
 Eulerian.all(7) == c(1, 120, 1191, 2416, 1191, 120, 1)
)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
