<!DOCTYPE html><html><head><title>Help for package REPPlab</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {REPPlab}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#REPPlab-package'><p>R Interface to the Java Program 'EPP-lab' v1.0</p></a></li>
<li><a href='#coef.epplab'><p>Extracts the Directions of an Epplab Object</p></a></li>
<li><a href='#EPPlab'><p>Function for Exploratory Projection Pursuit.</p></a></li>
<li><a href='#EPPlabAgg'><p>Function to Aggregate Directions From epplab Objects</p></a></li>
<li><a href='#EPPlabOutlier'><p>Function to Find Outliers for an epplab Object</p></a></li>
<li><a href='#fitted.epplab'><p>Calculates projections of the Data</p></a></li>
<li><a href='#pairs.epplab'><p>Plots a Scatterplot Matrix for an epplab Object</p></a></li>
<li><a href='#plot.epplab'><p>Plot for an epplab Object</p></a></li>
<li><a href='#plot.epplabOutlier'><p>Plot for an epplabOutlier Object</p></a></li>
<li><a href='#predict.epplab'><p>Calculates projections for a new Data Object</p></a></li>
<li><a href='#print.epplab'><p>Print an epplab Object</p></a></li>
<li><a href='#print.epplabOutlier'><p>Print an epplabOutlier Object</p></a></li>
<li><a href='#ReliabilityData'><p>Reliability Data from an Industrial Context</p></a></li>
<li><a href='#screeplot.epplab'><p>Creating a Screeplot for an epplab Object</p></a></li>
<li><a href='#summary.epplab'><p>Summarize an epplab Object</p></a></li>
<li><a href='#summary.epplabOutlier'><p>Summarize an epplabOutlier Object</p></a></li>
<li><a href='#WhitenSVD'><p>Whitening Data Using Singular Value Decomposition</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>R Interface to 'EPP-Lab', a Java Program for Exploratory
Projection Pursuit</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-11</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Fischer, Alain Berro, Klaus Nordhausen, Anne Ruiz-Gazen</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Fischer &lt;daniel.fischer@luke.fi&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15.1), rJava, lattice, LDRTools (&ge; 0.2), utils,
graphics</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tourr, amap</td>
</tr>
<tr>
<td>Description:</td>
<td>An R Interface to 'EPP-lab' v1.0. 'EPP-lab' is a Java program for
    projection pursuit using genetic algorithms written by Alain Berro and S. Larabi
    Marie-Sainte and is included in the package. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-12 10:53:30 UTC; ejo138</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-12 11:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='REPPlab-package'>R Interface to the Java Program 'EPP-lab' v1.0</h2><span id='topic+REPPlab-package'></span>

<h3>Description</h3>

<p>An interface that gives access to the Java program 'EPP-lab' which implements
several biologically inspired optimisation algorithms and several indices
for Exploratory Projection Pursuit (PP). The objective of optimizing PP
indices and projecting the data on the associated one-dimensional directions
is to detect hidden structures such as clusters or outliers in (possibly
high dimensional) data sets.
The 'EPP-lab' sources and jar-files are available under 
<a href="https://github.com/fischuu/EPP-lab">https://github.com/fischuu/EPP-lab</a>. For a detailed description of
'EPP-lab', see Larabi (2011).
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> REPPlab</td>
</tr>
<tr>
 <td style="text-align: left;"> Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;"> Version: </td><td style="text-align: left;">
0.9.6</td>
</tr>
<tr>
 <td style="text-align: left;"> Date: </td><td style="text-align: left;"> 2023-12-11</td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> GPL</td>
</tr>
<tr>
 <td style="text-align: left;"> LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Daniel Fischer, Alain Berro, Klaus Nordhausen, Anne Ruiz-Gazen
</p>
<p>Maintainer: Daniel Fischer &lt;daniel.fischer@luke.fi&gt;
</p>


<h3>References</h3>

<p><cite>Larabi Marie-Sainte, S., (2011), Biologically inspired
algorithms for exploratory projection pursuit, PhD thesis, University of
Toulouse.</cite>
</p>
<p><cite>Ruiz-Gazen, A., Larabi Marie-Sainte, S. and Berro, A. (2010),
Detecting multivariate outliers using projection pursuit with particle swarm
optimization, <em>COMPSTAT2010</em>, pp. 89-98.</cite>
</p>
<p><cite>Berro, A., Larabi Marie-Sainte, S. and Ruiz-Gazen, A. (2010). Genetic
algorithms and particle swarm optimization for exploratory projection
pursuit. Annals of Mathematics and Artifcial Intelligence, 60, 153-178.</cite>
</p>
<p><cite>Larabi Marie-Sainte, S., Berro, A. and Ruiz-Gazen, A. (2010). An
effcient optimization method for revealing local optima of projection
pursuit indices. <em>Swarm Intelligence</em>, pp. 60-71.</cite>
</p>

<hr>
<h2 id='coef.epplab'>Extracts the Directions of an Epplab Object</h2><span id='topic+coef.epplab'></span><span id='topic+coef-method'></span><span id='topic+coef+2Cepplab-method'></span>

<h3>Description</h3>

<p>Extracts the found directions of an <code>epplab</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'epplab'
coef(object, which = 1:ncol(object$PPdir), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.epplab_+3A_object">object</code></td>
<td>
<p>Object of class <code>epplab</code>.</p>
</td></tr>
<tr><td><code id="coef.epplab_+3A_which">which</code></td>
<td>
<p>Specifies which directions are extracted.</p>
</td></tr>
<tr><td><code id="coef.epplab_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The coef function extracts the directions found from the EPPlab call.
</p>


<h3>Author(s)</h3>

<p>Daniel Fischer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tourr)
data(olive)
res &lt;- EPPlab(olive[,3:10],PPalg="PSO",PPindex="KurtosisMin",n.simu=10, maxiter=20)
coef(res)

</code></pre>

<hr>
<h2 id='EPPlab'>Function for Exploratory Projection Pursuit.</h2><span id='topic+EPPlab'></span>

<h3>Description</h3>

<p>REPPlab optimizes a projection pursuit (PP) index using a Genetic Algorithm
(GA) or one of two Particle Swarm Optimisation (PSO) algorithms over several
runs, implemented in the Java program EPP-lab.  One of the PSO algorithms is
a classic one while the other one is a parameter-free extension called
Tribes. The parameters of the algorithms (maxiter and individuals for GA and
maxiter and particles for PSO) can be modified by the user.  The PP indices
are the well-known Friedman and Friedman-Tukey indices together with the
kurtosis and a so-called discriminant index that is devoted to the detection
of groups.  At each run, the function finds a local optimum of the PP index
and gives the associated projection direction and criterion value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EPPlab(
  x,
  PPindex = "KurtosisMax",
  PPalg = "GA",
  n.simu = 20,
  sphere = FALSE,
  maxiter = NULL,
  individuals = NULL,
  particles = NULL,
  step_iter = 10,
  eps = 10^(-6)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EPPlab_+3A_x">x</code></td>
<td>
<p>Matrix where each row is an observation and each column a
dimension.</p>
</td></tr>
<tr><td><code id="EPPlab_+3A_ppindex">PPindex</code></td>
<td>
<p>The used index, see details.</p>
</td></tr>
<tr><td><code id="EPPlab_+3A_ppalg">PPalg</code></td>
<td>
<p>The used algorithm, see details.</p>
</td></tr>
<tr><td><code id="EPPlab_+3A_n.simu">n.simu</code></td>
<td>
<p>Number of simulation runs.</p>
</td></tr>
<tr><td><code id="EPPlab_+3A_sphere">sphere</code></td>
<td>
<p>Logical, sphere the data. Default is <code>FALSE</code>, in which
case the data is only standardized.</p>
</td></tr>
<tr><td><code id="EPPlab_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="EPPlab_+3A_individuals">individuals</code></td>
<td>
<p>Size of the generated population in GA.</p>
</td></tr>
<tr><td><code id="EPPlab_+3A_particles">particles</code></td>
<td>
<p>Number of generated particles in the standard PSO
algorithm.</p>
</td></tr>
<tr><td><code id="EPPlab_+3A_step_iter">step_iter</code></td>
<td>
<p>Convergence criterium parameter, see details. (Default: 10)</p>
</td></tr>
<tr><td><code id="EPPlab_+3A_eps">eps</code></td>
<td>
<p>Convergence criterium parameter, see details. (Default: 10^(-6))</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function always centers the data using <code><a href="Matrix.html#topic+colMeans">colMeans</a></code> and
divides by the standard deviation. Sphering the data is optional. If
sphering is requested the function <code><a href="#topic+WhitenSVD">WhitenSVD</a></code> is used, which
automatically tries to determine the rank of the data.
</p>
<p>Currently the function provides the following projection pursuit indices:
<code>KurtosisMax</code>, <code>Discriminant</code>, <code>Friedman</code>,
<code>FriedmanTukey</code>, <code>KurtosisMin</code>.
</p>
<p>Three algorithms can be used to find the projection directions. These are a
Genetic Algorithm <code>GA</code> and two Particle Swarm Optimisation algorithms
<code>PSO</code> and <code>Tribe</code>.
</p>
<p>Since the algorithms might find local optima they are run several times. The
function sorts the found directions according to the optimization criterion.
</p>
<p>The different algorithms have different default settings. It is for GA:
<code>maxiter=50</code> and <code>individuals=20</code>. For PSO: <code>maxiter=20</code> and
<code>particles=50</code>. For Tribe: <code>maxiter=20</code>.
</p>
<p>For GA, the size of the generated population is fixed by the user
(individuals). The algorithm is based on a tournament section of three
participants.  It uses a 2-point crossover with a probability of 0.65 and
the mutation operator is applied to all the individuals with a probability
of 0.05. The termination criterion corresponds to the number of generations
and is also fixed by the user (maxiter).
</p>
<p>For PSO, the user can give the number of initial generated particles and
also the maximum number of iterations. The other parameters are fixed
following Clerc (2006) and using a &quot;cosine&quot; neighborhood adapted to PP for
the PSO algorithm. For Tribes, only the maximum number of iterations needs
to be fixed. The algorithm proposed by Cooren and Clerc (2009) and adapted
to PP using a &quot;cosine neighborhood&quot; is used.
</p>
<p>The algorithms stop as soon as one of the two following conditions holds:
the maximum number of iterations is reached or the relative difference
between the index value of the present iteration i and the value of
iteration i-<code>step_iter</code> is less than <code>eps</code>. In the last situation,
the algorithm is said to converge and <code>EPPlab</code> will return the number
of iterations needed to attain convergence.  If the convergence is not
reached but the maximum number of iterations is attained, the function will
return some warnings. The default values are 10 for <code>step_iter</code> and
<code>1E-06</code> for <code>eps</code>. Note that if few runs have not converged this
might not be problem and even non-converged projections might reveal some
structure.
</p>


<h3>Value</h3>

<p>A list with class 'epplab' containing the following components:
</p>
<table>
<tr><td><code>PPdir</code></td>
<td>
<p>Matrix containing the PP directions as columns, see details.</p>
</td></tr>
<tr><td><code>PPindexVal</code></td>
<td>
<p>Vector containing the objective criterion value of each
run.</p>
</td></tr> <tr><td><code>PPindex</code></td>
<td>
<p>Name of the used projection index.</p>
</td></tr>
<tr><td><code>PPiter</code></td>
<td>
<p>Vector containing the number of iterations of each run.</p>
</td></tr>
<tr><td><code>PPconv</code></td>
<td>
<p>Boolean vector. Is TRUE if the run converged and FALSE else.</p>
</td></tr>
<tr><td><code>PPalg</code></td>
<td>
<p>Name of the used algorithm.</p>
</td></tr> <tr><td><code>maxiter</code></td>
<td>
<p>Maximum number of
iterations, as given in function call.</p>
</td></tr> <tr><td><code>x</code></td>
<td>
<p>Matrix containing the data
(centered!).</p>
</td></tr> <tr><td><code>sphere</code></td>
<td>
<p>Logical</p>
</td></tr> <tr><td><code>transform</code></td>
<td>
<p>The transformation
matrix from the whitening or standardization step.</p>
</td></tr> <tr><td><code>backtransform</code></td>
<td>
<p>The
back-transformation matrix from the whitening or standardization step.</p>
</td></tr>
<tr><td><code>center</code></td>
<td>
<p>The mean vector of the data</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Fischer, Klaus Nordhausen
</p>


<h3>References</h3>

<p><cite>Larabi Marie-Sainte, S., (2011), Biologically inspired
algorithms for exploratory projection pursuit, PhD thesis, University of
Toulouse.</cite>
</p>
<p><cite>Ruiz-Gazen, A., Larabi Marie-Sainte, S. and Berro, A. (2010),
Detecting multivariate outliers using projection pursuit with particle swarm
optimization, <em>COMPSTAT2010</em>, pp. 89-98.</cite>
</p>
<p><cite>Berro, A., Larabi Marie-Sainte, S. and Ruiz-Gazen, A. (2010). Genetic
algorithms and particle swarm optimization for exploratory projection
pursuit. Annals of Mathematics and Artifcial Intelligence, 60, 153-178.</cite>
</p>
<p><cite>Larabi Marie-Sainte, S., Berro, A. and Ruiz-Gazen, A. (2010). An
effcient optimization method for revealing local optima of projection
pursuit indices. <em>Swarm Intelligence</em>, pp. 60-71.</cite>
</p>
<p><cite>Clerc, M. (2006). Particle Swarm Optimization. ISTE, Wiley.</cite>
</p>
<p><cite>Cooren, Y., Clerc, M. and Siarry, P. (2009). Performance evaluation of
TRIBES, an adaptive particle swarm optimization algorithm. Swarm
Intelligence, 3(2), 149-178.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  library(tourr)
  data(olive)
  olivePP &lt;- EPPlab(olive[,3:10],PPalg="PSO",PPindex="KurtosisMax",n.simu=5, maxiter=20)
  summary(olivePP)

  library(amap)
  data(lubisch)
  X &lt;- lubisch[1:70,2:7]
  rownames(X) &lt;- lubisch[1:70,1]
  res &lt;- EPPlab(X,PPalg="PSO",PPindex="FriedmanTukey",n.simu=15, maxiter=20,sphere=TRUE)
  print(res)
  summary(res)
  fitted(res)
  plot(res)
  pairs(res)
  predict(res,data=lubisch[71:74,2:7])

</code></pre>

<hr>
<h2 id='EPPlabAgg'>Function to Aggregate Directions From epplab Objects</h2><span id='topic+EPPlabAgg'></span>

<h3>Description</h3>

<p>Function that automatically aggregates the projection directions from one or more <code>epplab</code> objects.
Three options are available on how to choose the final projection which can have a rank larger than one.
The parameter <code>x</code> can either be a single object or a list of epplab objects.
Options for <code>method</code> are <code>inverse</code>, <code>sq.inverse</code> and <code>cumulative</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EPPlabAgg(x, method = "cumulative", percentage = 0.85)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EPPlabAgg_+3A_x">x</code></td>
<td>
<p>An object of class <code>epplab</code> or a list of <code>epplab</code> objects.</p>
</td></tr>
<tr><td><code id="EPPlabAgg_+3A_method">method</code></td>
<td>
<p>The type of method, see details. Options are <code>inverse</code>, <code>sq.inverse</code> and <code>cumulative</code>.</p>
</td></tr>
<tr><td><code id="EPPlabAgg_+3A_percentage">percentage</code></td>
<td>
<p>Threshold for the relative eigenvalue sum to retain, see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Denote <code class="reqn">p_i, i=1,...,m</code>, the projection vectors contained in the list of <code>epplab</code> objects 
and <code class="reqn">P_i, i=1,..,m</code>, the corresponding orthogonal projection matrices (each having rank one). 
The method <code>cumulative</code> is based on the eigenvalue decomposition of 
<code class="reqn">P_w=\frac 1m \sum_{i=1}^m P_i</code>
and transforms as <code>O</code> the eigenvectors such that the corresponding
relative eigenvalues sum is at least <code>percentage</code>.
The number of eigenvectors retained corresponds to the rank <code>k</code> and
<code>P</code> is the corresponding orthogonal projection matrix.
The methods <code>inverse</code> and <code>sq.inverse</code> are automatic rules to
choose the number of eigenvectors to retain as implemented by the function
<code><a href="LDRTools.html#topic+AOP">AOP</a></code>.
</p>


<h3>Value</h3>

<p>A list with class 'epplabagg' containing the following components:
</p>
<table>
<tr><td><code>P</code></td>
<td>
<p>The estimated average orthogonal projection matrix.</p>
</td></tr>
<tr><td><code>O</code></td>
<td>
<p>An orthogonal matrix on which P is based upon.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>The rank of the average orthogonal projection matrix.</p>
</td></tr>
<tr><td><code>eigenvalues</code></td>
<td>
<p>The relevant eigenvalues, see details. Only given if <code>method="cumulative"</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Fischer, Klaus Nordhausen, Anne Ruiz-Gazen
</p>


<h3>References</h3>

<p><cite>Liski, E., Nordhausen, K., Oja, H. and Ruiz-Gazen, A. (201?), Combining Linear Dimension Reduction Estimates, to appear in the Proceedings of <em>ICORS 2015</em>, pp. ??-??.</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EPPlab">EPPlab</a></code>, <code><a href="LDRTools.html#topic+AOP">AOP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 library(tourr)
 data(olive)
 # To keep the runtime short, maxiter and n.simu were chosen very 
 # small for demonstration purposes, real life applications would
 # rather choose larger values, e.g. n.simu=100, maxiter=200
 olivePP.kurt.max &lt;-
   EPPlab(olive[,3:10],PPalg="PSO",PPindex="KurtosisMax",n.simu=10, maxiter=20)
 
 olivePP.fried &lt;-
   EPPlab(olive[,3:10],PPalg="PSO",PPindex="Friedman",n.simu=10, maxiter=20)
 
 olivePPs &lt;- list(olivePP.kurt.max, olivePP.fried)
 
 EPPlabAgg(olivePP.kurt.max)$k
 EPPlabAgg(olivePPs, "cum", 0.99)$k
 
 pairs(olivePP.kurt.max$x %*% EPPlabAgg(olivePPs, "cum", 0.99)$O,
       col=olive[,2], pch=olive[,1])
 
 
 olivAOP.sq &lt;- EPPlabAgg(olivePPs, "inv")
 oliveProj &lt;- olivePP.kurt.max$x %*% olivAOP.sq$O
 plot(density(oliveProj))
 rug(oliveProj[olive$region==1],col=1)
 rug(oliveProj[olive$region==2],col=2)
 rug(oliveProj[olive$region==3],col=3)

</code></pre>

<hr>
<h2 id='EPPlabOutlier'>Function to Find Outliers for an epplab Object</h2><span id='topic+EPPlabOutlier'></span>

<h3>Description</h3>

<p>Function to decide wether observations are considered outliers or not in
specific projection directions of an <code>epplab</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EPPlabOutlier(x, which = 1:ncol(x$PPdir), k = 3, location = mean, scale = sd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EPPlabOutlier_+3A_x">x</code></td>
<td>
<p>An object of class <code>epplab</code>.</p>
</td></tr>
<tr><td><code id="EPPlabOutlier_+3A_which">which</code></td>
<td>
<p>The directions in which outliers should be searched. The
default is to look at all.</p>
</td></tr>
<tr><td><code id="EPPlabOutlier_+3A_k">k</code></td>
<td>
<p>Numeric value to decide when an observation is considered an
outlier or not. Default is 3. See details.</p>
</td></tr>
<tr><td><code id="EPPlabOutlier_+3A_location">location</code></td>
<td>
<p>A function which gives the univariate location as an output.
The default is <code><a href="base.html#topic+mean">mean</a></code>.</p>
</td></tr>
<tr><td><code id="EPPlabOutlier_+3A_scale">scale</code></td>
<td>
<p>A function which gives the univariate scale as an output. The
default is <code><a href="stats.html#topic+sd">sd</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Denote <code class="reqn">location_j</code> as the location of the jth projection direction and
analogously <code class="reqn">scale_j</code> as its scale. Then an observation <code class="reqn">x</code> is an
outlier in the jth projection direction, if <code class="reqn">|x-location_j| \geq k \
scale_j</code>.
</p>
<p>Naturally it is best to use for this purpose robust location and scale
measures like <code><a href="stats.html#topic+median">median</a></code> and <code><a href="stats.html#topic+mad">mad</a></code> for example.
</p>


<h3>Value</h3>

<p>A list with class 'epplabOutlier' containing the following
components: </p>
<table>
<tr><td><code>outlier</code></td>
<td>
<p>A matrix with only zeros and ones. A value of 1
classifies the observation as an outlier in this projection direction.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>The factor <code>k</code> used.</p>
</td></tr> <tr><td><code>location</code></td>
<td>
<p>The name of the
<code>location</code> estimator used.</p>
</td></tr> <tr><td><code>scale</code></td>
<td>
<p>The name of the <code>scale</code>
estimator used.</p>
</td></tr> <tr><td><code>PPindex</code></td>
<td>
<p>The name of the <code>PPindex</code> used.</p>
</td></tr>
<tr><td><code>PPalg</code></td>
<td>
<p>The name of the <code>PPalg</code> used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen
</p>


<h3>References</h3>

<p><cite>Ruiz-Gazen, A., Larabi Marie-Sainte, S. and Berro, A.
(2010), Detecting multivariate outliers using projection pursuit with
particle swarm optimization, <em>COMPSTAT2010</em>, pp. 89-98.</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EPPlab">EPPlab</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# creating data with 3 outliers
n &lt;-300 
p &lt;- 10
X &lt;- matrix(rnorm(n*p),ncol=p)
X[1,1] &lt;- 9
X[2,4] &lt;- 7 
X[3,6] &lt;- 8
# giving the data rownames, obs.1, obs.2 and obs.3 are the outliers.
rownames(X) &lt;- paste("obs",1:n,sep=".")

PP&lt;-EPPlab(X,PPalg="PSO",PPindex="KurtosisMax",n.simu=20, maxiter=20)
OUT&lt;-EPPlabOutlier(PP, k = 3, location = median, scale = mad)
OUT

</code></pre>

<hr>
<h2 id='fitted.epplab'>Calculates projections of the Data</h2><span id='topic+fitted.epplab'></span><span id='topic+fitted-method'></span><span id='topic+fitted+2Cepplab-method'></span>

<h3>Description</h3>

<p>Calculates the projections of the data object onto the directions from an
underlying <code>ebblab</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'epplab'
fitted(object, which = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.epplab_+3A_object">object</code></td>
<td>
<p>Object of class <code>epplab</code>.</p>
</td></tr>
<tr><td><code id="fitted.epplab_+3A_which">which</code></td>
<td>
<p>Onto which direction should the new data be projected.</p>
</td></tr>
<tr><td><code id="fitted.epplab_+3A_...">...</code></td>
<td>
<p>Additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default projection direction is the direction with the best objective
criterion.
</p>


<h3>Value</h3>

<p>A matrix, having in each column the projection onto the direction of
a certain run, and in each row the projected value.
</p>


<h3>Author(s)</h3>

<p>Daniel Fischer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tourr)
data(olive)
res &lt;- EPPlab(olive[,3:10],PPalg="PSO",PPindex="KurtosisMin",n.simu=10, maxiter=20)

# Projection to the best direction
fitted(res)

# Projection to the 1,2,5 best directions:
fitted(res,which=c(1,2,5))

</code></pre>

<hr>
<h2 id='pairs.epplab'>Plots a Scatterplot Matrix for an epplab Object</h2><span id='topic+pairs.epplab'></span><span id='topic+pairs-method'></span><span id='topic+pairs+2Cepplab-method'></span>

<h3>Description</h3>

<p>Plots a scatterplot matrix of fitted scores of an <code>epplab</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'epplab'
pairs(x, which = 1:10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairs.epplab_+3A_x">x</code></td>
<td>
<p>Object of class <code>epplab</code>.</p>
</td></tr>
<tr><td><code id="pairs.epplab_+3A_which">which</code></td>
<td>
<p>Which simulation runs should be taken into account.</p>
</td></tr>
<tr><td><code id="pairs.epplab_+3A_...">...</code></td>
<td>
<p>Graphical parameters, see also par().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The option <code>which</code> can restrict the output to certain simulation runs.
In case of many simulations, this might improve the readability.
</p>


<h3>Author(s)</h3>

<p>Daniel Fischer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tourr)
data(olive)
res &lt;- EPPlab(olive[,3:10],PPalg="PSO",PPindex="KurtosisMin",n.simu=10, maxiter=20)
pairs(res)

</code></pre>

<hr>
<h2 id='plot.epplab'>Plot for an epplab Object</h2><span id='topic+plot.epplab'></span><span id='topic+plot-method'></span><span id='topic+plot+2Cepplab-method'></span>

<h3>Description</h3>

<p>The function offers three informative plots for an <code>epplab</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'epplab'
plot(
  x,
  type = "kernel",
  angles = "radiants",
  kernel = "biweight",
  which = 1:10,
  as.table = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.epplab_+3A_x">x</code></td>
<td>
<p>Object of class <code>epplab</code>.</p>
</td></tr>
<tr><td><code id="plot.epplab_+3A_type">type</code></td>
<td>
<p>Type of plot, values are &quot;kernel&quot;, &quot;histogram&quot; and &quot;angles&quot;.</p>
</td></tr>
<tr><td><code id="plot.epplab_+3A_angles">angles</code></td>
<td>
<p>Values are &quot;degree&quot; and &quot;radiants&quot;, if <code>type="angles"</code>.</p>
</td></tr>
<tr><td><code id="plot.epplab_+3A_kernel">kernel</code></td>
<td>
<p>Type of kernel, passed on to <code><a href="stats.html#topic+density">density</a></code>.</p>
</td></tr>
<tr><td><code id="plot.epplab_+3A_which">which</code></td>
<td>
<p>Which simulation runs should be taken into account.</p>
</td></tr>
<tr><td><code id="plot.epplab_+3A_as.table">as.table</code></td>
<td>
<p>A logical flag that controls the order in which panels
should be displayed.</p>
</td></tr>
<tr><td><code id="plot.epplab_+3A_...">...</code></td>
<td>
<p>Graphical parameters, see also <code><a href="lattice.html#topic+xyplot">xyplot</a></code>,
<code><a href="lattice.html#topic+densityplot">densityplot</a></code> and <code><a href="lattice.html#topic+histogram">histogram</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The option <code>which</code> can restrict the output to certain simulation runs.
In case of many simulations, this might improve the readability.
</p>
<p>For <code>type="kernel"</code>, the default, it plots a kernel density estimate
for each of the chosen directions. In the case of <code>type="histogram"</code>
the corresponding histograms.  For <code>type="angles"</code> it plots the angles
of the first chosen direction against all others. Whether the angles are
given in degrees or radiants, depends on the value of <code>angles</code>.
</p>


<h3>Author(s)</h3>

<p>Daniel Fischer, Klaus Nordhausen
</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+xyplot">xyplot</a></code>, <code><a href="lattice.html#topic+densityplot">densityplot</a></code>,
<code><a href="lattice.html#topic+histogram">histogram</a></code>, <code><a href="stats.html#topic+density">density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tourr)
data(olive)
res &lt;- EPPlab(olive[,3:10],PPalg="PSO",PPindex="KurtosisMin",n.simu=10, maxiter=20)

# Plot with kernel estimator
plot(res)

# Just the best 5 and then 8
plot(res,which=c(1:5,8))

# Plot as histogram
plot(res,type="histogram")

# Plot an angles plot
plot(res,type="angles")

</code></pre>

<hr>
<h2 id='plot.epplabOutlier'>Plot for an epplabOutlier Object</h2><span id='topic+plot.epplabOutlier'></span><span id='topic+plot+2CepplabOutlier-method'></span>

<h3>Description</h3>

<p>Visualizes which observations are considered as outliers and how often for
an <code>epplabOutlier</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'epplabOutlier'
plot(x, col = c("white", "black"), outlier = TRUE, xlab = "", ylab = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.epplabOutlier_+3A_x">x</code></td>
<td>
<p>Object of class <code>epplabOutlier</code>.</p>
</td></tr>
<tr><td><code id="plot.epplabOutlier_+3A_col">col</code></td>
<td>
<p>Which colors should be used for non-outliers and outliers.
Default is white and black.</p>
</td></tr>
<tr><td><code id="plot.epplabOutlier_+3A_outlier">outlier</code></td>
<td>
<p>Logical if only observations considered as outliers at least
once should be plotted or all. Default is <code>TRUE</code>.
xlab Possible x axis label. Default is none.
ylab Possible x axis label. Default is none.</p>
</td></tr>
<tr><td><code id="plot.epplabOutlier_+3A_xlab">xlab</code></td>
<td>
<p>Sets the x-axis label.</p>
</td></tr>
<tr><td><code id="plot.epplabOutlier_+3A_ylab">ylab</code></td>
<td>
<p>Sets the y-axis label.</p>
</td></tr>
<tr><td><code id="plot.epplabOutlier_+3A_...">...</code></td>
<td>
<p>Graphical parameters passed on to <code><a href="Matrix.html#topic+image">image</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Fischer and Klaus Nordhausen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EPPlabOutlier">EPPlabOutlier</a></code>, <code><a href="Matrix.html#topic+image">image</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# creating data with 3 outliers
n &lt;-300 
p &lt;- 10
X &lt;- matrix(rnorm(n*p),ncol=p)
X[1,1] &lt;- 9
X[2,4] &lt;- 7 
X[3,6] &lt;- 8
# giving the data rownames, obs.1, obs.2 and obs.3 are the outliers.
rownames(X) &lt;- paste("obs",1:n,sep=".")

PP&lt;-EPPlab(X,PPalg="PSO",PPindex="KurtosisMax",n.simu=20, maxiter=20)
OUT&lt;-EPPlabOutlier(PP, k = 3, location = median, scale = mad)
plot(OUT)

</code></pre>

<hr>
<h2 id='predict.epplab'>Calculates projections for a new Data Object</h2><span id='topic+predict.epplab'></span><span id='topic+predict-method'></span><span id='topic+predict+2Cepplab-method'></span>

<h3>Description</h3>

<p>Calculates the projections of a new data object onto the directions from an
existing <code>ebblab</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'epplab'
predict(object, which = 1, data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.epplab_+3A_object">object</code></td>
<td>
<p>Object of class <code>epplab</code>.</p>
</td></tr>
<tr><td><code id="predict.epplab_+3A_which">which</code></td>
<td>
<p>Onto which direction should the new data be projected.</p>
</td></tr>
<tr><td><code id="predict.epplab_+3A_data">data</code></td>
<td>
<p>The new data object</p>
</td></tr>
<tr><td><code id="predict.epplab_+3A_...">...</code></td>
<td>
<p>Additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default projection direction is the direction with the best objective
criterion. In case that no data is given to the function, the fitted scores
for the original data will be returned.
</p>


<h3>Value</h3>

<p>A matrix having in each column the projection onto the direction of
a certain run and in each row the projected value.
</p>


<h3>Author(s)</h3>

<p>Daniel Fischer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tourr)
data(olive)
res &lt;- EPPlab(olive[,3:10], PPalg="PSO", PPindex="KurtosisMin", n.simu=10, maxiter=20)

newData &lt;- matrix(rnorm(80), ncol=8)

# Projection on the best direction
predict(res, data=newData)

# Projection on the best 3 directions
predict(res, which=1:3, data=newData)

# Similar with function fitted() when no data is given:
predict(res)
fitted(res)

</code></pre>

<hr>
<h2 id='print.epplab'>Print an epplab Object</h2><span id='topic+print.epplab'></span><span id='topic+print-method'></span><span id='topic+print+2Cepplab-method'></span>

<h3>Description</h3>

<p>Prints an <code>epplab</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'epplab'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.epplab_+3A_x">x</code></td>
<td>
<p>Object of class <code>epplab</code>.</p>
</td></tr>
<tr><td><code id="print.epplab_+3A_...">...</code></td>
<td>
<p>Additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The print function displays the result with the best value in the objective
criterion.
</p>


<h3>Author(s)</h3>

<p>Daniel Fischer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tourr)
data(olive)
res &lt;- EPPlab(olive[,3:10],PPalg="PSO",PPindex="KurtosisMin",n.simu=10, maxiter=20)
print(res)

</code></pre>

<hr>
<h2 id='print.epplabOutlier'>Print an epplabOutlier Object</h2><span id='topic+print.epplabOutlier'></span><span id='topic+print+2CepplabOutlier-method'></span>

<h3>Description</h3>

<p>Prints an <code>epplabOutlier</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'epplabOutlier'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.epplabOutlier_+3A_x">x</code></td>
<td>
<p>Object of class <code>epplabOutlier</code>.</p>
</td></tr>
<tr><td><code id="print.epplabOutlier_+3A_...">...</code></td>
<td>
<p>Additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>print</code> function displays only the <code>outlier</code> matrix from the
<code>epplabOutlier</code> object.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# creating data with 3 outliers
n &lt;-300 
p &lt;- 10
X &lt;- matrix(rnorm(n*p),ncol=p)
X[1,1] &lt;- 9
X[2,4] &lt;- 7 
X[3,6] &lt;- 8
# giving the data rownames, obs.1, obs.2 and obs.3 are the outliers.
rownames(X) &lt;- paste("obs",1:n,sep=".")

PP&lt;-EPPlab(X,PPalg="PSO",PPindex="KurtosisMax",n.simu=20, maxiter=20)
OUT&lt;-EPPlabOutlier(PP, k = 3, location = median, scale = mad)
OUT

</code></pre>

<hr>
<h2 id='ReliabilityData'>Reliability Data from an Industrial Context</h2><span id='topic+ReliabilityData'></span>

<h3>Description</h3>

<p>The data set contains 55 variables measured during the production
process of 520 units. The problem for this data is to identify the
produced items with a fault not detected by standard tests.
</p>


<h3>Format</h3>

<p>A data frame with 520 observations on 55 variables.
</p>


<h3>Source</h3>

<p>The data was anonymized to keep confidentiality.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ReliabilityData)
summary(ReliabilityData) 

</code></pre>

<hr>
<h2 id='screeplot.epplab'>Creating a Screeplot for an epplab Object</h2><span id='topic+screeplot.epplab'></span><span id='topic+screeplot-method'></span><span id='topic+screeplot+2Cepplab-method'></span>

<h3>Description</h3>

<p>Plots the objective criteria of an <code>epplab</code> object versus the
simulation runs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'epplab'
screeplot(
  x,
  type = "lines",
  which = 1:10,
  main = "",
  ylab = "Objective criterion",
  xlab = "Simulation run",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="screeplot.epplab_+3A_x">x</code></td>
<td>
<p>Object of class <code>epplab</code>.</p>
</td></tr>
<tr><td><code id="screeplot.epplab_+3A_type">type</code></td>
<td>
<p>Type of screeplot, values are &quot;barplot&quot; and &quot;lines&quot;</p>
</td></tr>
<tr><td><code id="screeplot.epplab_+3A_which">which</code></td>
<td>
<p>Which simulation runs should be taken into account</p>
</td></tr>
<tr><td><code id="screeplot.epplab_+3A_main">main</code></td>
<td>
<p>Main title of the plot</p>
</td></tr>
<tr><td><code id="screeplot.epplab_+3A_ylab">ylab</code></td>
<td>
<p>Y-axis label</p>
</td></tr>
<tr><td><code id="screeplot.epplab_+3A_xlab">xlab</code></td>
<td>
<p>X-axis label</p>
</td></tr>
<tr><td><code id="screeplot.epplab_+3A_...">...</code></td>
<td>
<p>Graphical parameters, see also par()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The option <code>which</code> can restrict the output to certain simulation runs.
In case of many simulations, this might improve the readability.  The
<code>barplot</code> option is often not meaningful, because the objective
criteria are usually large and bars begin by default at zero.
</p>


<h3>Author(s)</h3>

<p>Daniel Fischer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tourr)
data(olive)
res &lt;- EPPlab(olive[,3:10],PPalg="PSO",PPindex="KurtosisMin",n.simu=10, maxiter=20)
screeplot(res)

# Pretty useless:
screeplot(res,type="barplot")

screeplot(res,which=1:5)

</code></pre>

<hr>
<h2 id='summary.epplab'>Summarize an epplab Object</h2><span id='topic+summary.epplab'></span><span id='topic+summary-method'></span><span id='topic+summary+2Cepplab-method'></span>

<h3>Description</h3>

<p>Summarizes and prints an <code>epplab</code> object in an informative way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'epplab'
summary(object, which = 1:10, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.epplab_+3A_object">object</code></td>
<td>
<p>Object of class <code>epplab</code>.</p>
</td></tr>
<tr><td><code id="summary.epplab_+3A_which">which</code></td>
<td>
<p>Summary for <code>which</code> simulation runs</p>
</td></tr>
<tr><td><code id="summary.epplab_+3A_digits">digits</code></td>
<td>
<p>Number of displayed decimal digits</p>
</td></tr>
<tr><td><code id="summary.epplab_+3A_...">...</code></td>
<td>
<p>Additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The option <code>which</code> can restrict the output to certain simulation runs.
In case of many simulations, this might improve the readability.
</p>


<h3>Author(s)</h3>

<p>Daniel Fischer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tourr)
data(olive)
res &lt;- EPPlab(olive[,3:10],PPalg="PSO",PPindex="KurtosisMin",n.simu=10, maxiter=20)
summary(res)

</code></pre>

<hr>
<h2 id='summary.epplabOutlier'>Summarize an epplabOutlier Object</h2><span id='topic+summary.epplabOutlier'></span><span id='topic+summary+2CepplabOutlier-method'></span>

<h3>Description</h3>

<p>Summarizes and prints an <code>epplabOutlier</code> object in an informative way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'epplabOutlier'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.epplabOutlier_+3A_object">object</code></td>
<td>
<p>Object of class <code>epplabOutlier</code>.</p>
</td></tr>
<tr><td><code id="summary.epplabOutlier_+3A_...">...</code></td>
<td>
<p>Additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main information provided here is a table with names of the observations
which are considered outliers and in how many PP directions they are
considered outliers. This function is useful if the data has been given row
names.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# creating data with 3 outliers
n &lt;-300 
p &lt;- 10
X &lt;- matrix(rnorm(n*p),ncol=p)
X[1,1] &lt;- 9
X[2,4] &lt;- 7 
X[3,6] &lt;- 8
# giving the data rownames, obs.1, obs.2 and obs.3 are the outliers.
rownames(X) &lt;- paste("obs",1:n,sep=".")

PP&lt;-EPPlab(X,PPalg="PSO",PPindex="KurtosisMax",n.simu=20, maxiter=20)
OUT&lt;-EPPlabOutlier(PP, k = 3, location = median, scale = mad)
summary(OUT)

</code></pre>

<hr>
<h2 id='WhitenSVD'>Whitening Data Using Singular Value Decomposition</h2><span id='topic+WhitenSVD'></span>

<h3>Description</h3>

<p>The function whitens a data matrix using the singular value decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WhitenSVD(x, tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WhitenSVD_+3A_x">x</code></td>
<td>
<p>A numeric data frame or data matrix with at least two rows.</p>
</td></tr>
<tr><td><code id="WhitenSVD_+3A_tol">tol</code></td>
<td>
<p>Tolerance value to decide the rank of the data. See details for
further information. If set to <code>NULL</code> it will be ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function whitens the data so that the result has mean zero and identity
covariance matrix using the function <code><a href="base.html#topic+svd">svd</a></code>. The data can have
here less observations than variables and svd will determine the rank of the
data automatically as the number of singular values larger than the largest
singular value times <code>tol</code>. If <code>tol=NULL</code> the rank is set to the
number of singular values, which is not advised when one or more singular
values are close to zero.
</p>
<p>The output contains among others as attributes the singular values and the
matrix needed to backtransform the whitened data to its original space.
</p>


<h3>Value</h3>

<p>The whitened data.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+svd">svd</a></code>, <code><a href="stats.html#topic+cov">cov</a></code>, <code><a href="Matrix.html#topic+colMeans">colMeans</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# more observations than variables
X &lt;- matrix(rnorm(200),ncol=4)
A &lt;- WhitenSVD(X)
round(colMeans(A),4)
round(cov(A),4)
# how to backtransform
summary(sweep(A %*% (attr(A,"backtransform")), 2, attr(A,"center"), "+") - X)

# fewer observations than variables
Y &lt;- cbind(rexp(4),runif(4),rnorm(4), runif(4), rnorm(4), rt(4,4))
B &lt;- WhitenSVD(Y)
round(colMeans(B),4)
round(cov(B),4)
# how to backtransform
summary(sweep(B %*% (attr(B,"backtransform")), 2, attr(B,"center"), "+") - Y)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
