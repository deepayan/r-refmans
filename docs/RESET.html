<!DOCTYPE html><html><head><title>Help for package RESET</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RESET}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#RESET-package'>
<p>Reconstruction Set Test</p></a></li>
<li><a href='#convertToPerVarScores'><p>Utility function to that converts RESET scores to/from per-variable scores</p></a></li>
<li><a href='#convertToPerVarScoresForSeurat'><p>Utility function to that converts RESET scores contained in a Seurat object to/from per-variable scores</p></a></li>
<li><a href='#createVarSetCollection'><p>Utility function to help create a variable set collection list object</p></a></li>
<li><a href='#randomColumnSpace'><p>Implementation of a sparse powered randomized algorithm for computing a basis for the column space of a matrix.</p></a></li>
<li><a href='#randomSVD'><p>Implementation of a sparse powered randomized singular value decomposition.</p></a></li>
<li><a href='#reset'><p>Reconstruction Set Test (RESET)</p></a></li>
<li><a href='#resetForSeurat'><p>RESET wrapper for scRNA-seq data processed using the Seurat framework</p></a></li>
<li><a href='#resetViaPCA'><p>Reconstruction Set Test (RESET) via PCA</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Reconstruction Set Test</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains logic for sample-level variable set scoring using randomized reduced rank reconstruction error. 
  Frost, H. Robert (2023) "Reconstruction Set Test (RESET): a computationally efficient method for 
  single sample gene set testing based on randomized reduced rank reconstruction error" &lt;<a href="https://doi.org/10.1101%2F2023.04.03.535366">doi:10.1101/2023.04.03.535366</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), Matrix</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Seurat (&ge; 4.0.0), SeuratObject (&ge; 4.0.0), sctransform (&ge;
0.3.2)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-06 13:32:17 UTC; d37329b</td>
</tr>
<tr>
<td>Author:</td>
<td>H. Robert Frost [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>H. Robert Frost &lt;rob.frost@dartmouth.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-06 23:40:14 UTC</td>
</tr>
</table>
<hr>
<h2 id='RESET-package'>
Reconstruction Set Test
</h2><span id='topic+RESET-package'></span>

<h3>Description</h3>

<p>Implementation of Reconstruction Set Test (RESET), a method for single sample variable set testing based on randomized reduced rank reconstruction error.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> RESET</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.2.2 </td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Note</h3>

<p>This work was supported by the National Institutes of Health grants R35GM146586, R21CA253408, P20GM130454 and P30CA023108.
</p>


<h3>Author(s)</h3>

<p>H. Robert Frost
</p>


<h3>References</h3>


<ul>
<li><p> Frost, H. R. (2023). Reconstruction Set Test (RESET): a computationally efficient method for single sample gene set testing based on randomized reduced rank reconstruction error. biorXiv e-prints. doi: https://doi.org/10.1101/2023.04.03.535366
</p>
</li></ul>


<hr>
<h2 id='convertToPerVarScores'>Utility function to that converts RESET scores to/from per-variable scores</h2><span id='topic+convertToPerVarScores'></span>

<h3>Description</h3>

<p>Utility function that converts the scores generated by <a href="#topic+reset">reset</a> or <a href="#topic+resetViaPCA">resetViaPCA</a> to or from per-variable scores.
This has the same effect as the <code>per.var</code> argument to <a href="#topic+reset">reset</a> or <a href="#topic+resetViaPCA">resetViaPCA</a>. Conversion to per-variable scores will divide each overall score and each sample-level score by the scaled size of the associated variable set. The variable set sizes are scaled by dividing by the mean size among all tested sets (this will result in scores not changing in magnitude for sets of mean size). Conversion from per-variable scores will instead multiply scored by the scaled variable set size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    convertToPerVarScores(reset.out, var.sets, to.per.var=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertToPerVarScores_+3A_reset.out">reset.out</code></td>
<td>
<p>The list returned from a call to <a href="#topic+reset">reset</a> or <a href="#topic+resetViaPCA">resetViaPCA</a>.</p>
</td></tr>
<tr><td><code id="convertToPerVarScores_+3A_var.sets">var.sets</code></td>
<td>
<p>List of variable sets where each element in the list corresponds to a set and the list element is a vector variable names. List names are variable set names. This must the same variable set structure used to create the <code>reset.out</code> input via <a href="#topic+reset">reset</a>.</p>
</td></tr>
<tr><td><code id="convertToPerVarScores_+3A_to.per.var">to.per.var</code></td>
<td>
<p>If true, the scores are converted to a per-variable format by dividing each score by the size of the associated variable set size.
If false, scores are converted from a per-variable format by multiplying by the associated variable set size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Version of the input list where scores have been appropriately converted to or from a per-variable format.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reset">reset</a></code>,<code><a href="#topic+resetViaPCA">resetViaPCA</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> # Create a collection of 3 overlapping variable sets of different sizes
 var.sets = list(set1=1:10, 
                  set2=1:20,
                  set3=1:30)

  # Simulate a 100-by-100 matrix of random Poisson data
  X = matrix(rpois(10000, lambda=1), nrow=100)

  # Inflate first 10 rows for first 10 variables, i.e., the first
  # 10 samples should have elevated scores for the first variable set
  X[1:10,1:10] = rpois(100, lambda=5)

  # Execute RESET using non-randomized basis computation
  reset.out = reset(X, var.sets=var.sets, k=2, random.threshold=20)
  
  # Display the overall scores
  reset.out$v
  
  # Convert to per-variable scores
  reset.out.2 = convertToPerVarScores(reset.out=reset.out, var.sets=var.sets, to.per.var=TRUE)
  
  # Display the overall scores in per-variable format
  reset.out.2$v
  
  # Convert from per-variable scores
  reset.out.3 = convertToPerVarScores(reset.out=reset.out.2, var.sets=var.sets, to.per.var=FALSE)
  
  # Display the overall scores
  reset.out.3$v
</code></pre>

<hr>
<h2 id='convertToPerVarScoresForSeurat'>Utility function to that converts RESET scores contained in a Seurat object to/from per-variable scores</h2><span id='topic+convertToPerVarScoresForSeurat'></span>

<h3>Description</h3>

<p>Utility function that converts the scores generated by <a href="#topic+resetForSeurat">resetForSeurat</a> to or from per-variable scores. 
This has the same effect as the <code>per.var</code> argument to <a href="#topic+resetForSeurat">resetForSeurat</a>.
Conversion to per-variable scores will divide each overall score and each sample-level score by the scaled size of the associated gene set.
The gene set sizes are scaled by dividing by the mean size among all tested sets (this will reset in scores not changing in magnitude for sets of mean size). Conversion from per-variable scores will instead multiply scored by the scaled gene set size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    convertToPerVarScoresForSeurat(seurat.data, gene.set.collection, to.per.var=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertToPerVarScoresForSeurat_+3A_seurat.data">seurat.data</code></td>
<td>
<p>The Seurat object returned from a call to <a href="#topic+resetForSeurat">resetForSeurat</a>.</p>
</td></tr>
<tr><td><code id="convertToPerVarScoresForSeurat_+3A_gene.set.collection">gene.set.collection</code></td>
<td>
<p>List of m gene sets for which scores are computed.
Each element in the list corresponds to a gene set and the list element is a vector
of indices for the genes in the set. The index value is defined relative to the
order of genes in the Seurat active assay. This needs to be the same gene set collection
used in the call to <a href="#topic+resetForSeurat">resetForSeurat</a>.</p>
</td></tr>
<tr><td><code id="convertToPerVarScoresForSeurat_+3A_to.per.var">to.per.var</code></td>
<td>
<p>If true, the scores are converted to a per-variable format by dividing each score by the size of the associated variable set size.
If false, scores are converted from a per-variable format by multiplying by the associated variable set size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Version of the Seurat object where the RESET scores have been appropriately converted to or from a per-variable format.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+resetForSeurat">resetForSeurat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>    # Only run example code if Seurat package is available
    if (requireNamespace("Seurat", quietly=TRUE) &amp; requireNamespace("SeuratObject", quietly=TRUE)) {
        # Define a collection with three overlapping gene sets of different sizes
        collection=list(set1=1:10, set2=1:20, set3=6:10)
        # Execute on the pbmc_small scRNA-seq data set included with SeuratObject
        # See vignettes for more detailed Seurat examples
        reset.out = resetForSeurat(seurat.data=SeuratObject::pbmc_small,
            num.pcs=2, k=2,
            gene.set.collection=collection)
        # Retrieve the overall scores
        reset.out@assays$RESET@meta.features
        # Convert the scores to a per-variable format
        reset.out.2 = convertToPerVarScoresForSeurat(seurat.data=reset.out,
            gene.set.collection=collection)
        # Retrieve the overall scores
        reset.out.2@assays$RESET@meta.features
    }
</code></pre>

<hr>
<h2 id='createVarSetCollection'>Utility function to help create a variable set collection list object</h2><span id='topic+createVarSetCollection'></span>

<h3>Description</h3>

<p>Utility function that creates a variable set list in the format required by <a href="#topic+reset">reset</a> (i.e., list of variable indices) given the variable names and an ordered vector of variable names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    createVarSetCollection(var.names, var.sets, min.size=1, max.size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createVarSetCollection_+3A_var.names">var.names</code></td>
<td>
<p>Vector of variable names. This should correspond to the order of variables as represented by the columns of the target matrix X.</p>
</td></tr>
<tr><td><code id="createVarSetCollection_+3A_var.sets">var.sets</code></td>
<td>
<p>List of m variable sets where each element in the list corresponds to a set and the list element is a vector variable names. List names are variable set names.</p>
</td></tr>
<tr><td><code id="createVarSetCollection_+3A_min.size">min.size</code></td>
<td>
<p>Minimum set size after filtering out variable not in the var.names vector. Sets whose post-filtering size is below this are removed from the final collection list. Default is 1 and cannot be set to less than 1.</p>
</td></tr>
<tr><td><code id="createVarSetCollection_+3A_max.size">max.size</code></td>
<td>
<p>Maximum variable set size after filtering out variables not in the var.names vector. Sets whose post-filtering size is above this are removed from the final collection list. If not specified, no filtering is performed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Version of the input variable set collection list where variable names have been replaced by position indices, variables not present in the var.names vector have been removed and sets failing the min/max size constraints have been removed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reset">reset</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>    # Create a collection with two sets defined over 3 variables
    createVarSetCollection(var.names=c("A", "B", "C"),
        var.sets = list(set1=c("A", "B"), set2=c("B", "C")),
        min.size=2, max.size=3)                    
</code></pre>

<hr>
<h2 id='randomColumnSpace'>Implementation of a sparse powered randomized algorithm for computing a basis for the column space of a matrix.</h2><span id='topic+randomColumnSpace'></span>

<h3>Description</h3>

<p>Computes a rank <code>k</code> approximation of the column space of an n-by-p input matrix <code>X</code> using a sparse randomized embedding with optional subspace power iterations.
Specifically, a p-by-k random text matrix <code>O</code> is created where all elements are generated as independent N(0,1) or U(0,1) random variables except for elements designated as sparse via the specified <code>sparsity.structure</code>, which are set to 0. If a sparse structure is used, the non-zero elements can alternatively be set to the constant value of 1 for a non-random embedding. The test matrix is used to create an n-by-k sketch matrix <code>Y</code> as <code>Y=XO</code>. If <code>q&gt;0</code>, subspace power iterations are performed on <code>Y</code> via algorithm 2 in the paper by Erichson, et al. associated with the <code>rsvd</code> R package (https://doi.org/10.18637/jss.v089.i11). The returned rank <code>k</code> column space approximation of <code>X</code> is then generated via a column-pivoted QR decomposition of <code>Y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    randomColumnSpace(X, k=2, q=0, sparsity.structure=NULL, test.dist="normal")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomColumnSpace_+3A_x">X</code></td>
<td>
<p>An n-by-p target matrix.</p>
</td></tr>
<tr><td><code id="randomColumnSpace_+3A_k">k</code></td>
<td>
<p>Target rank. Defaults to 2.</p>
</td></tr>
<tr><td><code id="randomColumnSpace_+3A_q">q</code></td>
<td>
<p>Number of power iterations. Defaults to 0.</p>
</td></tr>
<tr><td><code id="randomColumnSpace_+3A_sparsity.structure">sparsity.structure</code></td>
<td>
<p>Optional sparsity structure. Should be specified as a vector whose elements are 
the indices (in column-oriented format) of the non-sparse elements in the p x k random test matrix <code>O</code>. If not specified, <code>O</code> will be dense.</p>
</td></tr>
<tr><td><code id="randomColumnSpace_+3A_test.dist">test.dist</code></td>
<td>
<p>Type of random variable used to populate non-sparse elements of random test matrix <code>O</code>. Must be either 'normal' for N(0,1) RVs, 'uniform' for U(0,1) RVs or 'constant' for the value of 1. Note that 'constant' should only be used if <code>sparsity.structure</code> is specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A n-by-k estimate of the column space of <code>X</code>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+randomSVD">randomSVD</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Simulate a 100-by-100 matrix of random Poisson data
  X = matrix(rpois(10000, lambda=2), nrow=100)
  # Create a random sparsity structure for 100-by-5 random test matrix; half elements will be 0
  sparsity.structure = sample(1:500, 250, replace=TRUE)
  # Compute rank 5 estimate of column space of X using a sparse test matrix
  Q = randomColumnSpace(X,k=5,sparsity.structure=sparsity.structure)
  # Compute using a dense test matrix with U(0,1) RVs
  Q = randomColumnSpace(X,k=5,test.dist="uniform")
</code></pre>

<hr>
<h2 id='randomSVD'>Implementation of a sparse powered randomized singular value decomposition.</h2><span id='topic+randomSVD'></span>

<h3>Description</h3>

<p>Computes an approximate rank <code>k</code> singular value decomposition (SVD) of an n-by-p input matrix <code>X</code> using a sparse randomized embedding with optional subspace power iterations. The <code>randomColumnSpace</code> method is used to generate an rank <code>k</code> approximation of the column space of <code>X</code>. This n-by-k approximation <code>Y</code> is then used to create a k-by-p projection <code>B</code> of <code>X</code> onto this rank <code>k</code> subspace via <code>B=Y^TX</code>. A non-random SVD is computed for <code>B</code> and this SVD solution is used to generate an approximate rank <code>k</code> SVD of <code>X</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    randomSVD(X, k=2, q=0, sparsity.structure=NULL, test.dist="normal")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomSVD_+3A_x">X</code></td>
<td>
<p>An n-by-p target matrix.</p>
</td></tr>
<tr><td><code id="randomSVD_+3A_k">k</code></td>
<td>
<p>Target rank. Defaults to 2. See description in <code><a href="#topic+randomColumnSpace">randomColumnSpace</a></code>.</p>
</td></tr>
<tr><td><code id="randomSVD_+3A_q">q</code></td>
<td>
<p>Number of power iterations. Defaults to 0. See description in <code><a href="#topic+randomColumnSpace">randomColumnSpace</a></code>.</p>
</td></tr>
<tr><td><code id="randomSVD_+3A_sparsity.structure">sparsity.structure</code></td>
<td>
<p>Optional sparsity structure. See description in <code><a href="#topic+randomColumnSpace">randomColumnSpace</a></code>.</p>
</td></tr>
<tr><td><code id="randomSVD_+3A_test.dist">test.dist</code></td>
<td>
<p>Type of random variable used to populate non-sparse elements of random test matrix.
See description in <code><a href="#topic+randomColumnSpace">randomColumnSpace</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with the following elements:
</p>

<ul>
<li> <p><code>u</code> a matrix whose columns are the top k approximate left singular vectors of <code>X</code>.
</p>
</li>
<li> <p><code>d</code> a vector containing the top k approximate singular values of <code>X</code>.
</p>
</li>
<li> <p><code>v</code> a matrix whose columns are the top k approximate right singular vectors of <code>X</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+randomColumnSpace">randomColumnSpace</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Simulate a 100-by-100 matrix of random Poisson data
  X = matrix(rpois(10000, lambda=2), nrow=100)
  # Create a random sparsity structure for 100-by-5 random test matrix; half elements will be 0
  sparsity.structure = sample(1:500, 250, replace=TRUE)
  # Compute rank 5 SVD of X using a sparse test matrix
  svd.out = randomSVD(X,k=5,sparsity.structure=sparsity.structure)
  # Compute using a dense test matrix with U(0,1) RVs
  svd.out = randomSVD(X,k=5,test.dist="uniform")
</code></pre>

<hr>
<h2 id='reset'>Reconstruction Set Test (RESET)</h2><span id='topic+reset'></span>

<h3>Description</h3>

<p>Implementation of the Reconstruction Set Test (RESET) method, which transforms an n-by-p input matrix <code>X</code> into an n-by-m matrix of sample-level variable set scores and a length m vector of overall variable set scores. Execution of RESET involves the following sequence of steps:
</p>

<ul>
<li><p> If <code>center.X=TRUE</code>, mean center the columns of <code>X</code>. If <code>X.test</code> is specified, the centering is instead 
performed on just the columns of <code>X</code> corresponding to each variable set. 
See documentation for the <code>X</code> and <code>center.X</code> parameters for more details.
</p>
</li>
<li><p> If <code>scale.X=TRUE</code>, scale the columns of <code>X</code> to have variance 1. If <code>X.test</code> is specified, the scaling is instead 
performed on just the columns of <code>X</code> corresponding to each variable set. 
See documentation for the <code>X</code> and <code>scale.X</code> parameters for more details.            
</p>
</li>
<li><p> If <code>center.X.test=TRUE</code>, mean center the columns of <code>X.test</code>. 
See documentation for the <code>X.test</code> and <code>center.X.test</code> parameters for more details.
</p>
</li>
<li><p> If <code>scale.X.test=TRUE</code>, scale the columns of <code>X.test</code>. 
See documentation for the <code>X.test</code> and <code>scale.X.test</code> parameters for more details.            
</p>
</li>
<li><p> Set the reconstruction target matrix <code>T</code> to <code>X</code> or, if <code>X.test</code> is specified, to <code>X.test</code>.
</p>
</li>
<li><p> Compute the norm of <code>T</code> and norm of each row of <code>T</code>. By default, these are the Frobenius and Euclidean norms respectively. 
</p>
</li>
<li><p> For each set in <code>var.sets</code>, sample-level and matrix level scores are generated as follows:
</p>

<ul>
<li><p> Create a subset of <code>X</code> called <code>X.var.set</code> that only includes the columns of <code>X</code> correponding to the variables
in the set.
</p>
</li>
<li><p> Compute a rank <code>k</code> orthonormal basis <code>Q</code> for the column space of <code>X.var.set</code>. 
If the size of the set is less then or equal to <code>random.threshold</code>, then this is computed as the top <code>k</code> columns
of the <code>Q</code> matrix from a column-pivoted QR decomposition of <code>X.var.set</code>, otherwise, it is approximated using
a randomized algorithm implemented by <code><a href="#topic+randomColumnSpace">randomColumnSpace</a></code>.
</p>
</li>
<li><p> The reduced rank reconstruction of <code>T</code> is then created as <code>Q Q^T T</code>.
</p>
</li>
<li><p> The original <code>T</code> is subtracted from the reconstruction to represent the reconstruction error and the appropriate norm
is computed on each row and the entire error matrix.
</p>
</li>
<li><p> The overall score is the log2 ratio of the norm of the original <code>T</code> to the norm of the reconstruction error matrix.
</p>
</li>
<li><p> The score for each sample is the log2 ratio of the norm of the corresponding row of the original <code>T</code> to the norm of the same row of the reconstruction error matrix.
</p>
</li>
<li><p> If <code>per.var=TRUE</code>, then the overall and sample-level scores are divided by the variable set size.
</p>
</li></ul>

</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>reset(X, X.test, center.X=TRUE, scale.X=FALSE, center.X.test=TRUE, scale.X.test=FALSE, 
      var.sets, k=2, random.threshold, k.buff=0, q=0, test.dist="normal", norm.type="2",
      per.var=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reset_+3A_x">X</code></td>
<td>
<p>The n-by-p target matrix; columns represent variables and rows represent samples.</p>
</td></tr>
<tr><td><code id="reset_+3A_x.test">X.test</code></td>
<td>
<p>Matrix that will be combined with the <code>var.set</code> variables to compute the reduced rank reconstruction.
This is typically a subset or transformation of <code>X</code>, e.g., projection on top PCs. 
Reconstruction error will be measured on the variables in <code>X.test</code>. 
If not specified, the entire <code>X</code> matrix will be used for calculating reconstruction error.</p>
</td></tr>
<tr><td><code id="reset_+3A_center.x">center.X</code></td>
<td>
<p>Flag which controls whether the values in <code>X</code> are mean centered during execution of the algorithm.
If only <code>X</code> is specified and <code>center.X=TRUE</code>, then all columns in <code>X</code> will be centered. If both <code>X</code> and <code>X.test</code> are specified,
then centering is performed on just the columns of <code>X</code> contained in the specified variable sets.
Mean centering is especially important for accurate performance when <code>X.test</code> is specified as a reduced rank representation of the <code>X</code>, e.g, 
as the projection of <code>X</code> onto the top principal components. However, mean centering the entire matrix <code>X</code> can have a dramatic impact on memory 
requirements if <code>X</code> is a large sparse matrix. 
In this case, a non-centered <code>X</code> and appropriate <code>X.test</code> (e.g., project onto top PCs of <code>X</code>) can be provided and mean centering performed
on just the needed variables during execution of RESET. This &quot;just-in-time&quot; centering is enabled by setting <code>center.X=TRUE</code> and 
providing both <code>X</code> and <code>X.test</code>. If <code>X</code> has already been mean-centered (and <code>X.test</code> is a subset of this mean-centered matrix or
computed using this mean-centered matrix), then center should be specified as FALSE.</p>
</td></tr>
<tr><td><code id="reset_+3A_scale.x">scale.X</code></td>
<td>
<p>Flag which controls whether the values in <code>X</code> are are scaled to have variance 1 during execution of the algorithm.
Defaults to false.
If only <code>X</code> is specified and <code>scale.X=TRUE</code>, then all columns in <code>X</code> will be scaled. If both <code>X</code> and <code>X.test</code> are specified,
then scaling is performed on just the columns of <code>X</code> contained in the specified variable sets.</p>
</td></tr>
<tr><td><code id="reset_+3A_center.x.test">center.X.test</code></td>
<td>
<p>Flag which controls whether the values in <code>X.test</code>, if specified, are mean centered during execution of the algorithm.
Centering should be performed consistently for <code>X</code> and <code>X.test</code>, i.e., if <code>center.X</code> is true or <code>X</code> was previously centered, 
then <code>center.X.test</code> should te true unless <code>X.test</code> previously centered or generated from a centered <code>X</code>.</p>
</td></tr>
<tr><td><code id="reset_+3A_scale.x.test">scale.X.test</code></td>
<td>
<p>Flag which controls whether the values in <code>X.test</code>, if specified, are scaled to have variance 1 during execution of the algorithm.
Similar to centering, scaling should be performed consistently for <code>X</code> and <code>X.test</code>, i.e., if <code>scale.X</code> is true or <code>X</code>
was previously scaled then <code>scale.X.test</code> should te true unless <code>X.test</code> previously scaled or generated from a scaled <code>X</code>.</p>
</td></tr>
<tr><td><code id="reset_+3A_var.sets">var.sets</code></td>
<td>
<p>List of m variable sets, each element is a vector of indices of variables in the set that correspond to columns in <code>X</code>. 
If variable set information is instead available in terms of variable names, the appropriate format can be generated 
using <code><a href="#topic+createVarSetCollection">createVarSetCollection</a></code>.</p>
</td></tr>
<tr><td><code id="reset_+3A_k">k</code></td>
<td>
<p>Rank of reconstruction. Default to 2. Cannot be larger than the minimum variable set size.</p>
</td></tr>
<tr><td><code id="reset_+3A_random.threshold">random.threshold</code></td>
<td>
<p>If specified, indicates the variable set size above which a randomized reduced-rank reconstruction is used. 
If the variable set size is less or equal to random.threshold, then a non-random reconstruction is computed. Defaults to k 
and cannot be less than k.</p>
</td></tr>
<tr><td><code id="reset_+3A_k.buff">k.buff</code></td>
<td>
<p>Additional dimensions used in randomized reduced-rank construction algorithm. Defaults to 0. 
Values above 0 can improve the accuracy of the
randomized reconstruction at the expense of additional computational complexity. If <code>k.buff</code>=0, then the reduced rank 
reconstruction can be generated directly from the output of <code><a href="#topic+randomColumnSpace">randomColumnSpace</a></code>, otherwise, a reduced rank SVD must also be computed
with the reconstruction based on the top <code>k</code> components.</p>
</td></tr>
<tr><td><code id="reset_+3A_q">q</code></td>
<td>
<p>Number of power iterations for randomized SVD (see <code><a href="#topic+randomSVD">randomSVD</a></code>). 
Defaults to 0. Although power iterations can improve randomized SVD
performance in general, it can decrease the sensitivity of the RESET method to detect mean or covariance differences.</p>
</td></tr>
<tr><td><code id="reset_+3A_test.dist">test.dist</code></td>
<td>
<p>Distribution for non-zero elements of random test matrix used in randomized SVD algorithm. See description for <code>test.dist</code> parameter
of <code><a href="#topic+randomSVD">randomSVD</a></code> method.</p>
</td></tr>
<tr><td><code id="reset_+3A_norm.type">norm.type</code></td>
<td>
<p>The type of norm to use for computing reconstruction error. Defaults to &quot;2&quot; for Euclidean/Frobenius norm. Other supported option
is &quot;1&quot; for L1 norm.</p>
</td></tr>
<tr><td><code id="reset_+3A_per.var">per.var</code></td>
<td>
<p>If true, the computed scores for each variable set are divided by the scaled variable set size to generate per-variable scores.
Variable set size scaling is performed by dividing all sizes by the mean size (this will generate per-variable scores of approximately the
same magnitude as the non-per-variable scores).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>S</code> an n-by-m matrix of sample-level variable set scores.
</p>
</li>
<li> <p><code>v</code> a length m vector of overall variable set scores.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+createVarSetCollection">createVarSetCollection</a></code>,<code><a href="#topic+randomColumnSpace">randomColumnSpace</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Create a collection of 5 variable sets each of size 10
  var.sets = list(set1=1:10, 
                  set2=11:20,
                  set3=21:30,
                  set4=31:40,
                  set5=41:50)                  

  # Simulate a 100-by-100 matrix of random Poisson data
  X = matrix(rpois(10000, lambda=1), nrow=100)

  # Inflate first 10 rows for first 10 variables, i.e., the first
  # 10 samples should have elevated scores for the first variable set
  X[1:10,1:10] = rpois(100, lambda=5)

  # Execute RESET using non-randomized basis computation
  reset(X, var.sets=var.sets, k=2, random.threshold=10)

  # Execute RESET with randomized basis computation
  # (random.threshold will default to k value which is less
  # than the size of all variable sets)
  reset(X, var.sets=var.sets, k=2, k.buff=2)

  # Execute RESET with non-zero k.buff
  reset(X, var.sets=var.sets, k=2, k.buff=2)
  
  # Execute RESET with non-zero q
  reset(X, var.sets=var.sets, k=2, q=1)

  # Execute RESET with L1 vs L2 norm
  reset(X, var.sets=var.sets, k=2, norm.type="1")

  # Project the X matrix onto the first 5 PCs and use that as X.test
  # Scale X before calling prcomp() so that no centering or scaling
  # is needed within reset()
  X = scale(X)
  X.test = prcomp(X,center=FALSE,scale=FALSE,retx=TRUE)$x[,1:5]
  reset(X, X.test=X.test, center.X=FALSE, scale.X=FALSE, 
    center.X.test=FALSE, scale.X.test=FALSE, var.sets=var.sets, k=2)
</code></pre>

<hr>
<h2 id='resetForSeurat'>RESET wrapper for scRNA-seq data processed using the Seurat framework</h2><span id='topic+resetForSeurat'></span>

<h3>Description</h3>

<p>Executes the Reconstruction Set Test (RESET) method (<code><a href="#topic+reset">reset</a></code>) on 
normalized scRNA-seq data stored in a Seurat object. Will analyze the 
normalized counts in the active assay (i.e., either the log-normalized or SCTransformed counts).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resetForSeurat(seurat.data, num.pcs, gene.set.collection, k=10, random.threshold, 
               k.buff=0, q=0, test.dist="normal", norm.type="2", per.var=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resetForSeurat_+3A_seurat.data">seurat.data</code></td>
<td>
<p>The Seurat object that holds the scRNA-seq data. Assumes PCA has already been performed 
on a centered and scaled version of the normalized counts.</p>
</td></tr>
<tr><td><code id="resetForSeurat_+3A_num.pcs">num.pcs</code></td>
<td>
<p>Number of PCs to use in the RESET method. If not specified, will use all computed PCs. 
The projection of the scRNA-seq data onto these PCs will be used as the <code>X.test</code> matrix for the <code><a href="#topic+reset">reset</a></code> call.</p>
</td></tr>
<tr><td><code id="resetForSeurat_+3A_gene.set.collection">gene.set.collection</code></td>
<td>
<p>List of m gene sets for which scores are computed.
Each element in the list corresponds to a gene set and the list element is a vector
of indices for the genes in the set. The index value is defined relative to the
order of genes in the Seurat active assay. Gene set names should be specified as list names.
See <code><a href="#topic+createVarSetCollection">createVarSetCollection</a></code> for utility function that can be used to help generate this list of indices.</p>
</td></tr>
<tr><td><code id="resetForSeurat_+3A_k">k</code></td>
<td>
<p>See description in <code><a href="#topic+reset">reset</a></code></p>
</td></tr>    
<tr><td><code id="resetForSeurat_+3A_random.threshold">random.threshold</code></td>
<td>
<p>See description in <code><a href="#topic+reset">reset</a></code></p>
</td></tr>
<tr><td><code id="resetForSeurat_+3A_k.buff">k.buff</code></td>
<td>
<p>See description in <code><a href="#topic+reset">reset</a></code></p>
</td></tr>    
<tr><td><code id="resetForSeurat_+3A_q">q</code></td>
<td>
<p>See description in <code><a href="#topic+reset">reset</a></code></p>
</td></tr>    
<tr><td><code id="resetForSeurat_+3A_test.dist">test.dist</code></td>
<td>
<p>See description in <code><a href="#topic+reset">reset</a></code></p>
</td></tr>
<tr><td><code id="resetForSeurat_+3A_norm.type">norm.type</code></td>
<td>
<p>See description in <code><a href="#topic+reset">reset</a></code></p>
</td></tr>
<tr><td><code id="resetForSeurat_+3A_per.var">per.var</code></td>
<td>
<p>See description in <code><a href="#topic+reset">reset</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated Seurat object with the following modifications:
</p>

<ul>
<li><p> RESET sample-level gene set score matrix S stored in the &quot;data&quot; slot of a new &quot;RESET&quot; Assay object.
</p>
</li>
<li><p> RESET overall gene set scores stored in the feature metadata column &quot;RESET&quot;.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+reset">reset</a></code>,<code><a href="#topic+createVarSetCollection">createVarSetCollection</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>    # Only run example code if Seurat package is available
    if (requireNamespace("Seurat", quietly=TRUE) &amp; requireNamespace("SeuratObject", quietly=TRUE)) {
        # Define a collection with three gene sets
        collection=list(set1=1:10, set2=11:20, set3=21:30)
        # Execute on the pbmc_small scRNA-seq data set included with SeuratObject
        # See vignettes for more detailed Seurat examples
        reset.out = resetForSeurat(seurat.data=SeuratObject::pbmc_small,
            num.pcs=5,
            gene.set.collection=collection)
        # Retrieve the scores for the first 10 cells
        reset.out@assays$RESET[,1:10]
        # Retrieve the overall scores
        reset.out@assays$RESET@meta.features
    }
</code></pre>

<hr>
<h2 id='resetViaPCA'>Reconstruction Set Test (RESET) via PCA</h2><span id='topic+resetViaPCA'></span>

<h3>Description</h3>

<p>Wrapper around the <code><a href="#topic+reset">reset</a></code> method that uses the projection of <code>X</code> onto the top <code>num.pcs</code> principal components as <code>X.test</code>.
This PC projection is computed using a randomized reduced rank SVD as implemented by <code><a href="#topic+randomSVD">randomSVD</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resetViaPCA(X, center=TRUE, scale=FALSE, num.pcs=2, pca.buff=2, pca.q=1, var.sets, k=2, 
      random.threshold, k.buff=0, q=0, test.dist="normal", norm.type="2", per.var=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resetViaPCA_+3A_x">X</code></td>
<td>
<p>See description in <code><a href="#topic+reset">reset</a></code></p>
</td></tr>
<tr><td><code id="resetViaPCA_+3A_center">center</code></td>
<td>
<p>Flag which controls whether the values in <code>X</code> are mean centered.
Note that if <code>center</code> is set to true, centering is performed on the entire <code>X</code> matrix prior to 
calling <code><a href="#topic+randomSVD">randomSVD</a></code>, which may have significant performance and memory implications of <code>X</code> is large and/or sparse.
If <code>center</code> is false, then <code>X</code> will be projected onto the uncentered PCs and <code>center.X</code> and <code>center.X.test</code> will be set to
TRUE in the call to <code><a href="#topic+reset">reset</a></code>.</p>
</td></tr> 
<tr><td><code id="resetViaPCA_+3A_scale">scale</code></td>
<td>
<p>Flag which controls whether the values in <code>X</code> are are scaled to have variance 1.
Note that if <code>scale</code> is set to true, scaling is performed on the entire <code>X</code> matrix prior to 
calling <code><a href="#topic+randomSVD">randomSVD</a></code>, which may have significant performance and memory implications of <code>X</code> is large and/or sparse.</p>
</td></tr>
<tr><td><code id="resetViaPCA_+3A_num.pcs">num.pcs</code></td>
<td>
<p>Number of principal components used for computing the projection of <code>X</code>.</p>
</td></tr>
<tr><td><code id="resetViaPCA_+3A_pca.buff">pca.buff</code></td>
<td>
<p>Number of extra dimensions used when calling <code><a href="#topic+randomSVD">randomSVD</a></code> to compute the PCs. See <code>k.buff</code> parameter for
<code><a href="#topic+randomSVD">randomSVD</a></code> function.</p>
</td></tr>
<tr><td><code id="resetViaPCA_+3A_pca.q">pca.q</code></td>
<td>
<p>Number of power iterations used when calling <code><a href="#topic+randomSVD">randomSVD</a></code> to compute the PCs. See <code>q</code> parameter for
<code><a href="#topic+randomSVD">randomSVD</a></code> function.</p>
</td></tr>      
<tr><td><code id="resetViaPCA_+3A_var.sets">var.sets</code></td>
<td>
<p>See description in <code><a href="#topic+reset">reset</a></code></p>
</td></tr>
<tr><td><code id="resetViaPCA_+3A_k">k</code></td>
<td>
<p>See description in <code><a href="#topic+reset">reset</a></code></p>
</td></tr>
<tr><td><code id="resetViaPCA_+3A_random.threshold">random.threshold</code></td>
<td>
<p>See description in <code><a href="#topic+reset">reset</a></code></p>
</td></tr>
<tr><td><code id="resetViaPCA_+3A_k.buff">k.buff</code></td>
<td>
<p>See description in <code><a href="#topic+reset">reset</a></code></p>
</td></tr>
<tr><td><code id="resetViaPCA_+3A_q">q</code></td>
<td>
<p>See description in <code><a href="#topic+reset">reset</a></code></p>
</td></tr>
<tr><td><code id="resetViaPCA_+3A_test.dist">test.dist</code></td>
<td>
<p>See description in <code><a href="#topic+reset">reset</a></code></p>
</td></tr>
<tr><td><code id="resetViaPCA_+3A_norm.type">norm.type</code></td>
<td>
<p>See description in <code><a href="#topic+reset">reset</a></code></p>
</td></tr>
<tr><td><code id="resetViaPCA_+3A_per.var">per.var</code></td>
<td>
<p>See description in <code><a href="#topic+reset">reset</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>S</code> an n-by-m matrix of sample-level variable set scores.
</p>
</li>
<li> <p><code>v</code> a length m vector of overall variable set scores.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+reset">reset</a></code>,<code><a href="#topic+createVarSetCollection">createVarSetCollection</a></code>,<code><a href="#topic+randomColumnSpace">randomColumnSpace</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Create a collection of 5 variable sets each of size 10
  var.sets = list(set1=1:10, 
                  set2=11:20,
                  set3=21:30,
                  set4=31:40,
                  set5=41:50)                  

  # Simulate a 100-by-100 matrix of random Poisson data
  X = matrix(rpois(10000, lambda=1), nrow=100)

  # Inflate first 10 rows for first 10 variables, i.e., the first
  # 10 samples should have elevated scores for the first variable set
  X[1:10,1:10] = rpois(100, lambda=5)

  # Execute RESET when reconstruction measured on top 10 PCs 
  # with mean centering performed before computing PCs
  resetViaPCA(X, num.pcs=10, var.sets=var.sets, k=2, random.threshold=10)
  
  # Execute RESET when reconstruction measured on top 10 
  # uncentered PCs with centering performed as needed inside reset()
  resetViaPCA(X, center=FALSE, num.pcs=10, var.sets=var.sets, k=2, random.threshold=10)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
