<!DOCTYPE html><html lang="en"><head><title>Help for package genoPlotR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {genoPlotR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#genoPlotR-package'>
<p>Plot Publication-Grade Gene and Genome Maps</p></a></li>
<li><a href='#annotation'>
<p>Annotation class and class functions</p></a></li>
<li><a href='#apply_color_scheme'>
<p>Apply a color scheme</p></a></li>
<li><a href='#artemisColors'>
<p>Artemis Colors</p></a></li>
<li><a href='#auto_annotate'>
<p>Auto-annotate dna_segs</p></a></li>
<li><a href='#barto'><p>Comparison of 4 Bartonella genomes</p></a></li>
<li><a href='#c.dna_seg'>
<p>Concatenate dna_seg objects</p></a></li>
<li><a href='#chrY_subseg'><p>Comparisons of subsegments of the Y chromosome in human and chimp</p></a></li>
<li><a href='#comparison'>
<p>Comparison class and class functions</p></a></li>
<li><a href='#dna_seg'>
<p>DNA segment (dna_seg) class and class functions</p></a></li>
<li><a href='#gene_types'>
<p>Gene types</p></a></li>
<li><a href='#human_nt'>
<p>Human-readable nucleotide scale</p></a></li>
<li><a href='#mauve_bbone'><p>Mauve backbone of 4 Bartonella genomes</p></a></li>
<li><a href='#middle'>
<p>Middles of a dna_seg</p></a></li>
<li><a href='#plot_gene_map'>
<p>Plot gene and genome maps</p></a></li>
<li><a href='#range.dna_seg'>
<p>Range calculation</p></a></li>
<li><a href='#read_functions'><p>Reading functions</p></a></li>
<li><a href='#reverse'>
<p>Reverse objects</p></a></li>
<li><a href='#seg_plot'>
<p>seg_plot class and class functions</p></a></li>
<li><a href='#three_genes'><p>Three genes data set</p></a></li>
<li><a href='#trim'>
<p>Trimming data frames or more complex objects with &gt;= 2 numeric columns</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Plot Publication-Grade Gene and Genome Maps</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.11</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-01-05</td>
</tr>
<tr>
<td>Author:</td>
<td>Lionel Guy &lt;lionel.guy@imbim.uu.se&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://genoplotr.r-forge.r-project.org/">http://genoplotr.r-forge.r-project.org/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.0), ade4, grid</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lionel Guy &lt;lionel.guy@imbim.uu.se&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Draws gene or genome maps and comparisons between these, in a 
   publication-grade manner. Starting from simple, common files, it will 
   draw postscript or PDF files that can be sent as such to journals.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-01-07 13:23:56 UTC; lionel</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-01-07 15:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='genoPlotR-package'>
Plot Publication-Grade Gene and Genome Maps
</h2><span id='topic+genoPlotR-package'></span><span id='topic+genoPlotR'></span>

<h3>Description</h3>

<p>Draws gene or genome maps and comparisons between these, in a 
   publication-grade manner. Starting from simple, common files, it will 
   draw postscript or PDF files that can be sent as such to journals.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> genoPlotR</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Plot Publication-Grade Gene and Genome Maps</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.8.11</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2021-01-05</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Lionel Guy &lt;lionel.guy@imbim.uu.se&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> http://genoplotr.r-forge.r-project.org/</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 2.10.0), ade4, grid</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> methods</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Lionel Guy &lt;lionel.guy@imbim.uu.se&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Draws gene or genome maps and comparisons between these, in a 
   publication-grade manner. Starting from simple, common files, it will 
   draw postscript or PDF files that can be sent as such to journals.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
annotation              Annotation class and class functions
apply_color_scheme      Apply a color scheme
artemisColors           Artemis Colors
auto_annotate           Auto-annotate dna_segs
barto                   Comparison of 4 Bartonella genomes
c.dna_seg               Concatenate dna_seg objects
chrY_subseg             Comparisons of subsegments of the Y chromosome
                        in human and chimp
comparison              Comparison class and class functions
dna_seg                 DNA segment (dna_seg) class and class functions
gene_types              Gene types
genoPlotR-package       Plot Publication-Grade Gene and Genome Maps
human_nt                Human-readable nucleotide scale
mauve_bbone             Mauve backbone of 4 Bartonella genomes
middle                  Middles of a dna_seg
plot_gene_map           Plot gene and genome maps
range.dna_seg           Range calculation
read_functions          Reading functions
reverse                 Reverse objects
seg_plot                seg_plot class and class functions
three_genes             Three genes data set
trim                    Trimming data frames or more complex objects
                        with &gt;= 2 numeric columns
</pre>
<p>The only plotting function is <code><a href="#topic+plot_gene_map">plot_gene_map</a></code>, which
produces <code>link[grid]{grid}</code> graphics. Data is composed mainly of
DNA segments (<code><a href="#topic+dna_seg">dna_seg</a></code>) objects, which represent
collections of genes or segments of genomes, and of
<code><a href="#topic+comparison">comparison</a></code> objects, which are the pairwise comparisons
between the <code>dna_seg</code>s. Data can be read from files (see
<code><a href="#topic+read_functions">read_functions</a></code>) or from R objects like
<code>data.frame</code>s or <code>list</code>s, with <code><a href="#topic+dna_seg">dna_seg</a></code> and
<code><a href="#topic+comparison">comparison</a></code> conversion functions. 
</p>


<h3>Author(s)</h3>

<p>Lionel Guy &lt;lionel.guy@imbim.uu.se&gt;
</p>
<p>Maintainer: Lionel Guy &lt;lionel.guy@imbim.uu.se&gt;
</p>


<h3>References</h3>

<p>Guy, L., Roat Kultima, J, and Andersson, S.G.E. (2010). genoPlotR:
comparative gene and genome visualization in R. Bioinformatics 26(18):2334-2335.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_gene_map">plot_gene_map</a></code> for plotting. <code><a href="#topic+dna_seg">dna_seg</a></code> and
<code><a href="#topic+comparison">comparison</a></code> for the base objects and conversion functions.
<code><a href="#topic+read_dna_seg_from_tab">read_dna_seg_from_tab</a></code>, <code><a href="#topic+read_dna_seg_from_ptt">read_dna_seg_from_ptt</a></code>, 
<code><a href="#topic+read_comparison_from_tab">read_comparison_from_tab</a></code> and
<code><a href="#topic+read_comparison_from_blast">read_comparison_from_blast</a></code> to read from files.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simple example
## dna segments
## data.frame with several genes
names1 &lt;- c("feat1", "feat2", "feat3")
starts1 &lt;- c(2, 1000, 1050)
ends1 &lt;- c(600, 800, 1345)
strands1 &lt;- c("-", -1, 1)
cols1 &lt;- c("blue", "grey", "red")
df1 &lt;- data.frame(name=names1, start=starts1, end=ends1,
                  strand=strands1, col=cols1)
dna_seg1 &lt;- dna_seg(df1)
is.dna_seg(dna_seg1)

## with only one gene, or two, and merging
gene2a &lt;- dna_seg(list(name="feat1", start=50, end=900, strand="-", col="blue"))
genes2b &lt;- dna_seg(data.frame(name=c("feat2", "feat3"), start=c(800, 1200),
                              end=c(1100, 1322), strand=c("+", 1),
                              col=c("grey", "red")))
dna_seg2 &lt;- c.dna_seg(gene2a, genes2b)
is.dna_seg(dna_seg2)

## reading from file
dna_seg3_file &lt;- system.file('extdata/dna_seg3.tab', package = 'genoPlotR')
dna_seg3 &lt;- read_dna_seg_from_tab(dna_seg3_file)
is.dna_seg(dna_seg3)

## comparison
## from a data.frame
comparison1 &lt;- as.comparison(data.frame(start1=starts1, end1=ends1,
                                        start2=dna_seg2$start,
                                        end2=dna_seg2$end))
is.comparison(comparison1)

## from a file
comparison2_file &lt;- system.file('extdata/comparison2.tab',
                                package = 'genoPlotR')
comparison2 &lt;- read_comparison_from_tab(comparison2_file,
                                        color_scheme="red_blue")
is.comparison(comparison1)

## plot
plot_gene_map(dna_segs=list(dna_seg1, dna_seg2, dna_seg3),
              comparisons=list(comparison1, comparison2)) 
</code></pre>

<hr>
<h2 id='annotation'>
Annotation class and class functions
</h2><span id='topic+annotation'></span><span id='topic+as.annotation'></span><span id='topic+is.annotation'></span>

<h3>Description</h3>

<p>An annotation describes a DNA segment. It has labels attached to
positions. Each label can be attached to a single position or to a
range. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotation(x1, x2 = NA, text, rot = 0, col = "black")
as.annotation(df, x2 = NA, rot = 0, col = "black")
is.annotation(annotation)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="annotation_+3A_x1">x1</code></td>
<td>

<p>Numeric. A vector giving the first or only position of the
label. Mandatory. 
</p>
</td></tr>
<tr><td><code id="annotation_+3A_x2">x2</code></td>
<td>

<p>Numeric. A vector of the same length as <code>x1</code>. If a row (or the
whole column is  <code>NA</code>, then the annotation(s) will be attached
to <code>x0</code>. Else, the annotation will be attached to the range
between both positions. <code>NA</code> by default.
</p>
</td></tr>
<tr><td><code id="annotation_+3A_text">text</code></td>
<td>

<p>Character of the same length as <code>x0</code>. Gives the text of the
labels. Mandatory.
</p>
</td></tr>
<tr><td><code id="annotation_+3A_rot">rot</code></td>
<td>

<p>Numeric of the same length as <code>x0</code>. Gives the rotation, in
degrees, of the labels. 0 by default.
</p>
</td></tr>
<tr><td><code id="annotation_+3A_col">col</code></td>
<td>

<p>Vector of the same length as <code>x0</code>. The color of the
labels. <code>black</code> by default.
</p>
</td></tr>
<tr><td><code id="annotation_+3A_df">df</code></td>
<td>

<p>A data frame to convert to an annotation object. Should have at
least columns <code>x1</code> and <code>text</code>.
</p>
</td></tr>
<tr><td><code id="annotation_+3A_annotation">annotation</code></td>
<td>

<p>An object to test.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An <code>annotation</code> object is a data frame with columns <code>x0</code>,
<code>x1</code>, <code>text</code>, <code>col</code> and <code>rot</code>. They give,
respectively, the first (or only) position, eventually the second
position, the text, the color and the rotation of the annotation. When
plotted with <code>plot_gene_map</code>, it will add an annotation row on
top of the first <code>dna_seg</code>. Labels for which only one position is
given will be centered on that position. Labels for which two
positions are given are linked by an horizontal square bracket and the
label is plotted in the middle of the positions.
</p>


<h3>Value</h3>

<p><code>annotation</code> and  <code>as.annotation</code> return an annotation object.
<code>is.annotation</code> returns a logical.
</p>


<h3>Author(s)</h3>

<p>Lionel Guy
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_gene_map">plot_gene_map</a></code>, <code><a href="#topic+middle">middle</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## loading data
data(three_genes)

## Calculating middle positions
mid_pos &lt;- middle(dna_segs[[1]])

# Create first annotation
annot1 &lt;- annotation(x1=mid_pos, text=dna_segs[[1]]$name)
plot_gene_map(dna_segs=dna_segs, comparisons=comparisons, annotations=annot1)

## Exploring options
annot2 &lt;- annotation(x1=c(mid_pos[1], dna_segs[[1]]$end[2]),
                     x2=c(NA, dna_segs[[1]]$end[3]),
                     text=c(dna_segs[[1]]$name[1], "region1"),
                     rot=c(30, 0), col=c("grey", "black"))
plot_gene_map(dna_segs=dna_segs, comparisons=comparisons,
              annotations=annot2, annotation_height=1.3)

## Annotations on all the segments
annots &lt;- lapply(dna_segs, function(x){
  mid &lt;- middle(x)
  annot &lt;- annotation(x1=mid, text=x$name, rot=30)
})
plot_gene_map(dna_segs=dna_segs, comparisons=comparisons,
              annotations=annots, annotation_height=1.8, annotation_cex=1)

##
## Using a bigger dataset from a 4-genome comparison
##
data(barto)
## Adding a tree
tree &lt;- newick2phylog("(BB:2.5,(BG:1.8,(BH:1,BQ:0.8):1.9):3);")
## Showing several subsegments
xlims2 &lt;- list(c(1445000, 1415000, 1380000, 1412000),
               c(  10000,   45000,   50000,   83000, 90000, 120000),
               c(  15000,   36000,   90000,  120000, 74000,  98000),
               c(   5000,    82000))
## Adding annotations for all genomes, allow segments to be placed out
## of the longest segment
annots &lt;- lapply(barto$dna_segs, function(x){
  mid &lt;- middle(x)
  annot &lt;- annotation(x1=mid, text=x$name, rot=30)
  # removing gene names starting with "B" and keeping 1 in 4
  idx &lt;- grep("^[^B]", annot$text, perl=TRUE)
  annot[idx[idx %% 4 == 0],] 
})
plot_gene_map(barto$dna_segs, barto$comparisons, tree=tree,
              annotations=annots,
              xlims=xlims2,
              limit_to_longest_dna_seg=FALSE,
              dna_seg_scale=TRUE)


</code></pre>

<hr>
<h2 id='apply_color_scheme'>
Apply a color scheme
</h2><span id='topic+apply_color_scheme'></span>

<h3>Description</h3>

<p>Apply a color scheme to a numeric vector, eventually taking the
direction into account.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_color_scheme(x, direction = NULL, color_scheme = "grey",
decreasing = FALSE, rng = NULL, transparency = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_color_scheme_+3A_x">x</code></td>
<td>

<p>A numeric, that will be used to apply a gradient of colors to a
comparison. 
</p>
</td></tr>
<tr><td><code id="apply_color_scheme_+3A_direction">direction</code></td>
<td>

<p>If a red-blue scheme is choosen, the vector (composed of -1 and 1
values and of same length as <code>x</code>) giving the direction of the
comparison. 
</p>
</td></tr>
<tr><td><code id="apply_color_scheme_+3A_color_scheme">color_scheme</code></td>
<td>

<p>Character. One of <code>red_blue</code>, <code>blue_red</code>, <code>grey</code>,
<code>gray</code>. 
</p>
</td></tr>
<tr><td><code id="apply_color_scheme_+3A_decreasing">decreasing</code></td>
<td>

<p>Logical. Are the values of the comparisons oriented such as the
lower the value, the closer the relationship (e.g. e-values, gaps,
mismatches, etc)? <code>FALSE</code> by default. 
</p>
</td></tr>
<tr><td><code id="apply_color_scheme_+3A_rng">rng</code></td>
<td>

<p>Numeric of length 2. Gives the higher and lower limit to apply a
color scheme.  
</p>
</td></tr>
<tr><td><code id="apply_color_scheme_+3A_transparency">transparency</code></td>
<td>

<p>Numeric of length 1, between 0 and 1, or FALSE. Should the color
scheme use transparency, and if yes how much (ratio). 0.5 by
default.
Not supported on all devices.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A color scale is calculated, with the darker color corresponding to
the highest values of <code>x</code>, or the contrary is <code>decreasing</code>
is <code>TRUE</code>. For the moment, two schemes (red-blue and grey scale)
are used.
</p>
<p>For the red-blue scale (as in ACT), the direct comparisons are
colored in red hues, and the reversed ones in blue hues.
</p>
<p>This is especially useful to replace comparison values (such as BLAST
percent identity values) by color hues.
</p>


<h3>Value</h3>

<p>A character vector of same length as <code>x</code>, representing colors.
</p>


<h3>Author(s)</h3>

<p>Lionel Guy
</p>


<h3>References</h3>

<p>Artemis Comparison Tool, <a href="https://www.sanger.ac.uk/tool/artemis-comparison-tool-act/">https://www.sanger.ac.uk/tool/artemis-comparison-tool-act/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+comparison">comparison</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data
data(three_genes)

## Color schemes
## Greys
comparisons[[1]]$values &lt;- c(70, 80, 90)
comparisons[[1]]$col &lt;- apply_color_scheme(comparisons[[1]]$values,
                                           color_scheme="grey")
plot_gene_map(dna_segs=dna_segs, comparisons=comparisons)
## Red-blue
comparisons[[1]]$col &lt;- apply_color_scheme(comparisons[[1]]$values,
                                           direction=comparisons[[1]]$direction,
                                           color_scheme="red_blue")
plot_gene_map(dna_segs=dna_segs, comparisons=comparisons)
## Decreasing
comparisons[[1]]$col &lt;- apply_color_scheme(comparisons[[1]]$values,
                                           direction=comparisons[[1]]$direction,
                                           color_scheme="red_blue",
                                           decreasing=TRUE)
plot_gene_map(dna_segs=dna_segs, comparisons=comparisons)
## Range
comparisons[[1]]$col &lt;- apply_color_scheme(comparisons[[1]]$values,
                                           direction=comparisons[[1]]$direction,
                                           color_scheme="red_blue",
                                           rng=c(30,100))
plot_gene_map(dna_segs=dna_segs, comparisons=comparisons)
## Transparency
x1 &lt;- seq(100, 600, by=50)
x2 &lt;- seq(1100, 700, by=-50)
comparisons[[2]] &lt;- as.comparison(data.frame(start1=c(x1, x2),
                                             end1=c(x1+250, x2+300),
                                             start2=c(x1+150, x2-300)+2000,
                                             end2=c(x1+250, x2-500)+2000
                                             ))
comparisons[[2]]$col &lt;- apply_color_scheme(1:nrow(comparisons[[2]]),
                                           comparisons[[2]]$direction,
                                           color_scheme="blue_red")
comparisons[[1]]$col &lt;- apply_color_scheme(comparisons[[1]]$values,
                                           color_scheme="grey",
                                           transparency=0.8)
plot_gene_map(dna_segs=dna_segs, comparisons=comparisons)
comparisons[[1]]$col &lt;- apply_color_scheme(comparisons[[1]]$values,
                                           color_scheme="grey",
                                           transparency=1)
comparisons[[2]]$col &lt;- apply_color_scheme(1:nrow(comparisons[[2]]),
                                           comparisons[[2]]$direction,
                                           color_scheme="blue_red",
                                           transparency=0.2)
plot_gene_map(dna_segs=dna_segs, comparisons=comparisons)
</code></pre>

<hr>
<h2 id='artemisColors'>
Artemis Colors
</h2><span id='topic+artemisColors'></span>

<h3>Description</h3>

<p>Returns a data frame with the standard artemis colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>artemisColors()
</code></pre>


<h3>Value</h3>

<p>A <code>data.frame</code> with the following columns: <code>n</code>, <code>names</code>,
<code>colors</code>, <code>r</code>, <code>g</code> and <code>g</code>. The 3 first columns
give the Artemis color number, its name, and its equivalent in R. The
3 last give the r, g and b values. 
</p>


<h3>Author(s)</h3>

<p>Lionel Guy
</p>


<h3>References</h3>

<p>Artemis website: http://www.sanger.ac.uk/resources/software/artemis/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>artCol &lt;- artemisColors()
plot(rep(1, nrow(artCol)), artCol$n, xlim=c(1, 2), type="n")
text(rep(1, nrow(artCol)), artCol$n, labels=artCol$n, col=artCol$colors)
text(rep(1, nrow(artCol)), artCol$n, labels=artCol$names, col=artCol$colors,
     pos=4, offset=1)

</code></pre>

<hr>
<h2 id='auto_annotate'>
Auto-annotate dna_segs
</h2><span id='topic+auto_annotate'></span>

<h3>Description</h3>

<p>Annotate dna_segs in a smart way. This is especially designed for
<code>dna_seg</code>s read from genbank or embl files, but can be extended for
other uses. In short, it produces annotations from <code>dna_seg</code>s, grouping
the tags for operons (atpA, atpB, atC) into one tag (atpA-C), and
similarly for numbered genes (bep1-9).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_annotate(dna_seg, locus_tag_pattern=NULL, names=dna_seg$gene,
              keep_genes_only=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="auto_annotate_+3A_dna_seg">dna_seg</code></td>
<td>

<p>A <code>dna_seg</code> object.
</p>
</td></tr>
<tr><td><code id="auto_annotate_+3A_locus_tag_pattern">locus_tag_pattern</code></td>
<td>

<p><code>NULL</code> by default. A character giving a pattern, that is used
to simplify names. Specially useful to transform long locus tags
into numbers (e.g. Eco003456 becomes 3456).
</p>
</td></tr>
<tr><td><code id="auto_annotate_+3A_names">names</code></td>
<td>

<p>A character vector with as many elements as there are rows in the
<code>dna_seg</code>. By default, the <code>gene</code> column of the
<code>dna_seg</code> is taken. Gives the names to be summarized.
</p>
</td></tr>
<tr><td><code id="auto_annotate_+3A_keep_genes_only">keep_genes_only</code></td>
<td>

<p>A logical, <code>TRUE</code> by default. If set, the genes that have a
name that is &quot;-&quot; or empty are not annotated.
</p>
</td></tr>
<tr><td><code id="auto_annotate_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed to <code>annotation</code> function, like
<code>rot</code> or <code>color</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>annotation</code> object.
</p>


<h3>Author(s)</h3>

<p>Lionel Guy
</p>


<h3>See Also</h3>

<p><code><a href="#topic+annotation">annotation</a></code>, <code><a href="#topic+dna_seg">dna_seg</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Prepare dna_seg
names &lt;- paste("Eco", sprintf("%04d", 1:20), sep="")
gene &lt;- c("-", "atpC", "atpB", "atpA", "atp2", 
          "-", "-", "cda1", "cda2", "cda3",
          "vcx23", "vcx22", "vcx21", "cde20",
          "-", "gfrU", "gfrT", "gfrY", "gfrX", "gfrW")
ds &lt;- dna_seg(data.frame(name=names, start=(1:20)*3, end=(1:20)*3+2,
                         strand=rep(1, 20), gene=gene,
                         stringsAsFactors=FALSE))
## Original annotation
annot1 &lt;- annotation(x1=middle(ds), text=ds$gene, rot=30)
## auto_annotate with various options
annot2 &lt;- auto_annotate(ds)
annot3 &lt;- auto_annotate(ds, keep_genes_only=FALSE, rot=45)
annot4 &lt;- auto_annotate(ds, keep_genes_only=FALSE,
                        locus_tag_pattern="Eco", col="red")
## Plot
plot_gene_map(list(ds, ds, ds, ds),
              annotations=list(annot1, annot2, annot3, annot4))

</code></pre>

<hr>
<h2 id='barto'>Comparison of 4 Bartonella genomes</h2><span id='topic+barto'></span>

<h3>Description</h3>

<p>Comparison of 4 Bartonella genomes by BLAST. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(barto)
</code></pre>


<h3>Format</h3>

<p><code>barto</code>, a list of three dataframes, representing the four genomes
and their pairwise comparisons:
</p>

<ul>
<li><p><code>dna_segs</code>which is a list of 4 <code>dna_seg</code>
objects, containing all the protein genes for each genome. Obtained
by reading ptt files downloaded from NCBI with
<code>read_dna_seg_from_ptt</code>.
</p>
</li>
<li><p><code>comparisons</code>which is a list of 3 <code>comparison</code>
objects, obtained by doing genome-to-genome (fasta files) BLASTS,
and then reading the resulting tab files with
<code>read_comparison_from_blast</code>.
</p>
</li>
<li><p><code>rnt_segs</code>which is a list of 4 <code>dna_seg</code> objects,
containing all the RNA genes of the four genomes. Obtained by
reading rnt files downloaded from NCBI with
<code>read_dna_seg_from_ptt</code>.
</p>
</li></ul>

<p>A bash script to obtain the same file as in the dataset is
available in the <code>extdata</code> folder of the package. Find its
location by running 
<code>system.file('extdata/barto.sh', package = 'genoPlotR')</code>.
</p>


<h3>References</h3>

<p>BLAST: http://www.ncbi.nlm.nih.gov/blast/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(barto)
plot_gene_map(barto$rnt_segs, barto$comparisons, gene_type="blocks")
</code></pre>

<hr>
<h2 id='c.dna_seg'>
Concatenate dna_seg objects
</h2><span id='topic+c.dna_seg'></span>

<h3>Description</h3>

<p>Concatenate dna_seg objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dna_seg'
c(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c.dna_seg_+3A_...">...</code></td>
<td>

<p><code>dna_seg</code>s to be concatenated.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>dna_seg</code> object
</p>


<h3>Author(s)</h3>

<p>Lionel Guy
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dna_seg">dna_seg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load data
data(three_genes)

dna_segs[1:2]
c(dna_segs[[1]], dna_segs[[2]])

</code></pre>

<hr>
<h2 id='chrY_subseg'>Comparisons of subsegments of the Y chromosome in human and chimp</h2><span id='topic+chrY_subseg'></span>

<h3>Description</h3>

<p>A subsegment of the Y chromosome in Homo sapiens and Pan troglodytes,
to illustrate support for exons and introns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chrY_subseg)
</code></pre>


<h3>Format</h3>

<p>A list of two data frames, representing the Y segment in the two
species, and containing:
</p>

<ul>
<li><p><code>dna_segs</code>which is a list of two <code>dna_seg</code>
objects, containing each three rows (or genes).
</p>
</li>
<li><p><code>comparison</code>which is a list of one <code>comparison</code>
objects.
</p>
</li></ul>



<h3>Details</h3>

<p>Header for the Homo sapiens genbank file:
LOCUS       NC_000023             220001 bp    DNA     linear   CON 10-JUN-2009
DEFINITION  Homo sapiens chromosome X, GRCh37 primary reference assembly.
ACCESSION   NC_000023 REGION: 2600000..2820000 GPC_000000047
</p>
<p>Header for the Pan troglodytes file:
LOCUS       NC_006491             220001 bp    DNA     linear   CON 18-SEP-2006
DEFINITION  Pan troglodytes chromosome X, reference assembly (based on
Pan_troglodytes-2.1).
ACCESSION   NC_006491 REGION: 2620000..2840000
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chrY_subseg)
plot_gene_map(chrY_subseg$dna_segs, chrY_subseg$comparison, dna_seg_scale=TRUE,
              scale=FALSE)
</code></pre>

<hr>
<h2 id='comparison'>
Comparison class and class functions
</h2><span id='topic+comparison'></span><span id='topic+as.comparison'></span><span id='topic+is.comparison'></span>

<h3>Description</h3>

<p>A comparison is a collection of similarities, representing the
comparison between two DNA segments. These functions are class
functions to create, convert and test comparison objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comparison(x)
as.comparison(df)
is.comparison(comparison)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comparison_+3A_x">x</code></td>
<td>

<p>Can be a <code>list</code> or <code>data.frame</code> object. See the
details for the columns in the <code>data.frame</code>.
</p>
</td></tr>
<tr><td><code id="comparison_+3A_df">df</code></td>
<td>

<p>A <code>data.frame</code> object. See details for the required columns.
</p>
</td></tr>
<tr><td><code id="comparison_+3A_comparison">comparison</code></td>
<td>

<p>Any object to test.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects (either data frames or lists) should have at least named
elements <code>start1</code>, <code>end1</code>, <code>start2</code> and <code>end2</code>. In
addition, it can take a <code>col</code>or column. Additional numeric columns can
be used for color-coding (via <code>apply_color_scheme</code>.
</p>
<p><code>comparison</code> tries to build a comparison object from either a
data frame or a list, <code>as.comparison</code> accepts only data.frames.
</p>
<p><code>is.comparison</code> returns <code>TRUE</code> if the object tested is a
comparison object.
</p>
<p>Read functions such as <code><a href="#topic+read_comparison_from_tab">read_comparison_from_tab</a></code> and
<code><a href="#topic+read_comparison_from_blast">read_comparison_from_blast</a></code> also return comparison objects.
</p>


<h3>Value</h3>

<p>A comparison object for <code>comparison</code> and
<code>as.comparison</code>. Comparison objects are also of class
<code>data.frame</code>. They contain the columns  <code>start1</code>,
<code>end1</code>, <code>start2</code>, <code>end2</code>, <code>direction</code> and
<code>col</code> (color).
</p>
<p>A logical for <code>is.comparison</code>.
</p>


<h3>Author(s)</h3>

<p>Lionel Guy
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dna_seg">dna_seg</a></code>, <code><a href="#topic+read_comparison_from_tab">read_comparison_from_tab</a></code>,
<code><a href="#topic+read_comparison_from_blast">read_comparison_from_blast</a></code>,
<code><a href="#topic+trim.comparison">trim.comparison</a></code>, <code><a href="#topic+reverse.comparison">reverse.comparison</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Get some values
starts1 &lt;- c(2, 1000, 1050)
ends1 &lt;- c(600, 800, 1345)
starts2 &lt;- c(50, 800, 1200)
ends2 &lt;- c(900, 1100, 1322)

## From a data.frame
comparison1 &lt;- as.comparison(data.frame(start1=starts1, end1=ends1,
                                        start2=starts2, end2=ends2))
comparison1
is.comparison(comparison1)
is.data.frame(comparison1)
comparison(data.frame(start1=starts1, end1=ends1,
                      start2=starts2, end2=ends2))
## From a list
comparison(list(start1=starts1, end1=ends1,
                start2=starts2, end2=ends2))

## From a file
comparison2_file &lt;- system.file('extdata/comparison2.tab',
                                package = 'genoPlotR')
comparison2 &lt;- read_comparison_from_tab(comparison2_file)

</code></pre>

<hr>
<h2 id='dna_seg'>
DNA segment (dna_seg) class and class functions
</h2><span id='topic+dna_seg'></span><span id='topic+as.dna_seg'></span><span id='topic+is.dna_seg'></span>

<h3>Description</h3>

<p>A DNA segment is a collection of genes or elements along a genome, to
be represented on a map. These functions are class functions to
create, convert and test dna_seg objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dna_seg(x, ...)
as.dna_seg(df, col = "blue", fill = "blue", lty = 1, lwd = 1,
           pch = 8, cex = 1, gene_type = "arrows")
is.dna_seg(dna_seg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dna_seg_+3A_x">x</code></td>
<td>

<p>A <code>data.frame</code> or <code>list</code> that can be coerced to a data frame.
</p>
</td></tr>
<tr><td><code id="dna_seg_+3A_...">...</code></td>
<td>

<p>Arguments further passed to <code>as.dna_seg</code> (see below).
</p>
</td></tr>
<tr><td><code id="dna_seg_+3A_df">df</code></td>
<td>

<p>A data frame representing the <code>dna_seg</code> object. See details for
necessary columns.
</p>
</td></tr>
<tr><td><code id="dna_seg_+3A_col">col</code></td>
<td>

<p>Either a color vector of the same length as <code>df</code> or of length
one, to be applied to the whole object. Will be passed to
corresponding <code>grob</code> object. Default to blue.
</p>
</td></tr>
<tr><td><code id="dna_seg_+3A_fill">fill</code></td>
<td>

<p>Either a fill vector of the same length as <code>df</code> or of length
one, to be applied to the whole object. Will be passed to
corresponding <code>grob</code> object. Default to <code>blue</code>.
</p>
</td></tr>
<tr><td><code id="dna_seg_+3A_lty">lty</code></td>
<td>

<p>A vector of the same length as <code>df</code> or of length one, giving
the line type around the objects.
</p>
</td></tr>
<tr><td><code id="dna_seg_+3A_lwd">lwd</code></td>
<td>

<p>Same as <code>lty</code>, giving the line width.
</p>
</td></tr>
<tr><td><code id="dna_seg_+3A_pch">pch</code></td>
<td>

<p>Same as <code>lty</code>, giving the character representing each
object. Goes with <code>gene_type</code> points.
</p>
</td></tr>
<tr><td><code id="dna_seg_+3A_cex">cex</code></td>
<td>

<p>Same as <code>lty</code>, giving the character size representing each
object. Goes with <code>gene_type</code> points.
</p>
</td></tr>
<tr><td><code id="dna_seg_+3A_gene_type">gene_type</code></td>
<td>

<p>Vector of the same length as <code>df</code> or of length one, giving the
type of representation of each object.
</p>
</td></tr>
<tr><td><code id="dna_seg_+3A_dna_seg">dna_seg</code></td>
<td>

<p>Object to test.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects to be converted needs to have their first 4 columns named 
<code>name</code>, <code>start</code>, <code>end</code> and <code>strand</code>. Extra columns
with names <code>col</code>, <code>lty</code>, <code>lwd</code>, <code>pch</code>, <code>cex</code>,
<code>gene_type</code> will be used in the plotting process. Other extra
columns will be kept in the object, but not used.
</p>
<p><code>dna_seg</code> tries to build a dna_seg object from a data frame or a
list. 
</p>
<p><code>as.dna_seg</code> tries to build a dna_seg object from a data frame.
</p>
<p>Read functions such as <code><a href="#topic+read_dna_seg_from_tab">read_dna_seg_from_tab</a></code> and
<code><a href="#topic+read_dna_seg_from_ptt">read_dna_seg_from_ptt</a></code> also return dna_seg objects.  
</p>


<h3>Value</h3>

<p>A comparison object for <code>comparison</code> and
<code>as.comparison</code>. DNA seg objects are also of class
<code>data.frame</code>. They contain the following columns: <code>name</code>,
<code>start</code>, <code>end</code>, <code>strand</code>, <code>col</code>, <code>lty</code>, <code>lwd</code>,
<code>pch</code>, <code>cex</code>, <code>gene_type</code>.
</p>
<p>A logical for <code>is.comparison</code>.
</p>


<h3>Author(s)</h3>

<p>Lionel Guy
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_dna_seg_from_tab">read_dna_seg_from_tab</a></code>,
<code><a href="#topic+read_dna_seg_from_ptt">read_dna_seg_from_ptt</a></code>, <code><a href="#topic+gene_types">gene_types</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate data
names1 &lt;- c("feat1", "feat2", "feat3")
starts1 &lt;- c(2, 1000, 1050)
ends1 &lt;- c(600, 800, 1345)
strands1 &lt;- c("-", -1, 1)
cols1 &lt;- c("blue", "grey", "red")

## create data.frame
df1 &lt;- data.frame(name=names1, start=starts1, end=ends1,
                  strand=strands1, col=cols1)

## with dna_seg
dna_seg1 &lt;- dna_seg(df1)
dna_seg1
as.dna_seg(df1)

## test
is.dna_seg(dna_seg1)

## directly readable with read_dna_seg_from_tab
## Not run: 
write.table(x=dna_seg1, file="dna_seg1.tab", quote=FALSE,
            row.names=FALSE, sep="\t")

## End(Not run)

## with only one gene and with list, or two, and merging with c.dna_seg
gene2a &lt;- dna_seg(list(name="feat1", start=50, end=900, strand="-", col="blue"))
genes2b &lt;- dna_seg(data.frame(name=c("feat2", "feat3"), start=c(800, 1200),
                              end=c(1100, 1322), strand=c("+", 1),
                              col=c("grey", "red"),
                              fill=c("transparent", "grey"),
                              gene_type=c("arrows", "blocks")))
dna_seg2 &lt;- c(gene2a, genes2b)

## test
is.dna_seg(dna_seg2)

## reading from file
dna_seg3_file &lt;- system.file('extdata/dna_seg3.tab', package = 'genoPlotR')
dna_seg3 &lt;- read_dna_seg_from_tab(dna_seg3_file)
is.dna_seg(dna_seg3)

</code></pre>

<hr>
<h2 id='gene_types'>
Gene types
</h2><span id='topic+gene_types'></span>

<h3>Description</h3>

<p>Returns a vector containing the available gene types. In addition to
these gene types, the user can provide graphical functions that return
a list or a single <code>grob</code> object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gene_types(auto = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gene_types_+3A_auto">auto</code></td>
<td>

<p>Logical. Should type &quot;auto&quot; be added?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dna_seg</code>s may contain one character column
<code>gene_type</code>. Elements in this column should either be one of the
predefined gene types, or refer to a graphical function that has
exactly the same name and that returns a <code>grob</code> or a <code>gList</code>
object.
</p>
<p>A gene object (i.e. a single row of a <code>dna_seg</code>) is passed to the
graphical function, as well as the contents of the .... The start
and line width of an element can thus be accessed via
<code>gene$start</code> and <code>gene$lwd</code>. Extra columns that would be
added in the <code>dna_seg</code> can be used similarly. Extra arguments can
also be globally passed via ... when calling <code>plot_gene_map</code>.
</p>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Author(s)</h3>

<p>Lionel Guy
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_gene_map">plot_gene_map</a></code>, <code><a href="#topic+dna_seg">dna_seg</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## To view pre-coded gene types:
gene_types()

## Load data
data(barto)
n &lt;- length(gene_types(auto=FALSE))

## Get a small subset from the barto dataset
dna_seg &lt;- barto$dna_segs[[3]][1:n,]
plot_gene_map(list(dna_seg))

## Change gene_types and plot again
dna_seg$gene_type &lt;- gene_types(auto=FALSE)
dna_seg$fill &lt;- rainbow(n)
dna_seg_r &lt;- dna_seg
dna_seg_r$strand &lt;- -dna_seg$strand

## Add an annotation
annot &lt;- annotation(middle(dna_seg), text=dna_seg$gene_type, rot=45,
                    col=dna_seg$col)

## Plot
plot_gene_map(list(dna_seg, dna_seg_r), annotations=list(annot, annot),
              annotation_height=5, dna_seg_line=grey(0.7))


## Using home-made graphical functions
## Data
data(three_genes)

## Functions returning grobs.
## Creates a triangle
triangleGrob &lt;- function(gene, ...) {
  x &lt;- c(gene$start, (gene$start+gene$end)/2, gene$end)
  y1 &lt;- 0.5 + 0.4*gene$strand
  y &lt;- c(y1, 0.5, y1)
  polygonGrob(x, y, gp=gpar(fill=gene$fill, col=gene$col, lty=gene$lty,
                      lwd=gene$lwd), default.units="native")
}

## Draws a star. Note that the limits of the dna_seg region are
## voluntarily not respected
starGrob &lt;- function(gene, ...){
  ## Coordinates for the star
  x &lt;- sin(((0:5)/2.5)*pi)*(gene$end-gene$start)/2 + (gene$end+gene$start)/2
  y &lt;- cos(((0:5)/2.5)*pi)*gene$strand*2 + 0.5
  idx &lt;- c(1, 3, 5, 2, 4, 1)
  ## Attribute line_col only if present in the gene
  line_col &lt;- if (!is.null(gene$line_col)) gene$line_col else gene$col
  ## Having a conditional transparency, depending on a length cut-off
  ## passed via dots
  length_cutoff &lt;- list(...)$length_cutoff
  if (!is.null(length_cutoff)){
    alpha &lt;- if ((gene$end-gene$start) &lt; length_cutoff)  0.3 else  0.8
  } else alpha &lt;- 1
  
  ## Grobs
  g &lt;- polygonGrob(x[idx], y[idx], gp=gpar(fill=gene$col, col=line_col,
                                     lty=gene$lty, lwd=gene$lwd, alpha=alpha),
                   default.units="native")
  t &lt;- textGrob(label="***", x=(gene$end+gene$start)/2, y=0.5,
                default.units="native")
  gList(g, t)
}

## Replacing the standard types
dna_segs[[1]]$gene_type &lt;- "triangleGrob"
dna_segs[[2]]$gene_type &lt;- "starGrob"
## Adding more variables
dna_segs[[2]]$line_col &lt;- c("black", grey(0.3), "blue")
## Mix of several types on the same line
dna_segs[[3]]$gene_type &lt;- c("starGrob", "triangleGrob", "arrows")

## Plot
plot_gene_map(dna_segs, comparisons, length_cutoff=600)


</code></pre>

<hr>
<h2 id='human_nt'>
Human-readable nucleotide scale
</h2><span id='topic+human_nt'></span>

<h3>Description</h3>

<p>Return a human readable list from a nucleotide position or lenght. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>human_nt(nt, signif = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="human_nt_+3A_nt">nt</code></td>
<td>

<p>A nucleotide position
</p>
</td></tr>
<tr><td><code id="human_nt_+3A_signif">signif</code></td>
<td>

<p>Either a logical or an integer. If <code>FALSE</code> (default), <code>nt</code>
is not rounded. Else, it returns <code>signif</code> significant digits.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Return a nucleotide value in nt, kb, Mb or Gb, according to the value given.
This is particularly useful to display nice scales without too many 
trailing zeros.
</p>


<h3>Value</h3>

<p>Returns a list with 4 elements
</p>
<table role = "presentation">
<tr><td><code>n</code></td>
<td>
<p>A numeric value corresponding to <code>nt</code> divided by
<code>mult</code> (see below).</p>
</td></tr>
<tr><td><code>tag</code></td>
<td>
<p>A character, giving the multiplier used in text.</p>
</td></tr>
<tr><td><code>mult</code></td>
<td>
<p>The muliplier used, in numeric value.</p>
</td></tr>
<tr><td><code>text</code></td>
<td>
<p>A character, giving the value in a human readable format.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lionel Guy
</p>


<h3>Examples</h3>

<pre><code class='language-R'>human_nt(123456)
human_nt(123456, signif=2)
human_nt(123456890, signif=2)
</code></pre>

<hr>
<h2 id='mauve_bbone'>Mauve backbone of 4 Bartonella genomes</h2><span id='topic+mauve_bbone'></span><span id='topic+bbone'></span>

<h3>Description</h3>

<p>The result of a multiple genome alignment with Mauve. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mauve_bbone)
</code></pre>


<h3>Format</h3>

<p><code>bbone</code>, a list of two dataframes, representing the regions which
are conserved in at least two genomes:
</p>

<ul>
<li><p><code>dna_segs</code>which is a list of 4 <code>dna_seg</code>
objects, containing the mauve blocks for each genome.
</p>
</li>
<li><p><code>comparisons</code>which is a list of 3 <code>comparison</code>
objects.
</p>
</li></ul>

<p>A bash script to obtain the same file as in the data is
available in the <code>extdata</code> folder of the package. Find its
location by running 
<code>system.file('extdata/mauve.sh', package = 'genoPlotR')</code>.
</p>
<p>The resulting backone file can then be read with
<code><a href="#topic+read_mauve_backbone">read_mauve_backbone</a></code>.
</p>


<h3>References</h3>

<p>Mauve: http://asap.ahabs.wisc.edu/mauve/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mauve_bbone)
plot_gene_map(bbone$dna_segs, bbone$comparisons)
</code></pre>

<hr>
<h2 id='middle'>
Middles of a dna_seg
</h2><span id='topic+middle'></span>

<h3>Description</h3>

<p>Returns a vector containing the middle of the genes of a
dna_seg. Useful to prepare annotations, for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>middle(dna_seg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="middle_+3A_dna_seg">dna_seg</code></td>
<td>

<p>A <code>dna_seg</code> object.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector.
</p>


<h3>Author(s)</h3>

<p>Lionel Guy
</p>


<h3>See Also</h3>

<p><code><a href="#topic+annotation">annotation</a></code>, <code><a href="#topic+dna_seg">dna_seg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Load data
data(barto)

## Get middles of the first dna_seg
mid &lt;- middle(barto$dna_segs[[1]])

</code></pre>

<hr>
<h2 id='plot_gene_map'>
Plot gene and genome maps
</h2><span id='topic+plot_gene_map'></span>

<h3>Description</h3>

<p>This plotting function represents linearly DNA segments and their
comparisons. It will plot one line per DNA segment, eventually
separated by the comparisons. In addition, a tree can be plotted on
the left of the plot, and annotations on the top row. Since this is a
grid plot, it can be placed into other graphics, or modified subsequently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_gene_map(dna_segs,
              comparisons = NULL,
              tree = NULL,
              tree_width = NULL,
              tree_branch_labels_cex = NULL,
              tree_scale = FALSE,
              legend = NULL, 
              annotations = NULL, 
              annotation_height = 1, 
              annotation_cex = 0.8, 
              seg_plots=NULL,    # user-defined plots
              seg_plot_height=3, # height of plots (in lines)
              seg_plot_height_unit="lines", # unit of preceding
              seg_plot_yaxis=3, # if non-null or non false, ticks
              seg_plot_yaxis_cex=scale_cex,
              xlims = NULL,
              offsets = NULL,
              minimum_gap_size = 0.05,
              fixed_gap_length = FALSE,
              limit_to_longest_dna_seg = TRUE,
              main = NULL, 
              main_pos = "centre", 
              dna_seg_labels = NULL, 
              dna_seg_label_cex=1,
              dna_seg_label_col="black",
              gene_type = NULL,
              arrow_head_len = 200,
              dna_seg_line = TRUE,
              scale = TRUE, 
              dna_seg_scale = !scale,
              n_scale_ticks=7,
              scale_cex=0.6,
              global_color_scheme = c("auto", "auto", "blue_red", 0.5),
              override_color_schemes = FALSE,
              plot_new=TRUE,
              debug = 0,
              ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_gene_map_+3A_dna_segs">dna_segs</code></td>
<td>

<p>A list of <code>dna_seg</code> objects. Mandatory.
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_comparisons">comparisons</code></td>
<td>

<p>A list of <code>comparison</code> objects. Optional. 
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_tree">tree</code></td>
<td>

<p>A tree, under the form of a <code><a href="ade4.html#topic+phylog">phylog</a></code> object. If
specified, takes place at the left of the tags. See details below
for more information.
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_tree_width">tree_width</code></td>
<td>

<p>Numeric. The width of the tree area in the plot, in inches. By
default, takes 20 percent of the total plot.
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_tree_branch_labels_cex">tree_branch_labels_cex</code></td>
<td>

<p>Numeric or <code>NULL</code> (default). If the tree provided contains
node annotations, they will be displayed with this <code>cex</code>. If
equal to 0, node annotations are not displayed.
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_tree_scale">tree_scale</code></td>
<td>

<p>Logical. Plot a scale for the tree? Default is FALSE.
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_legend">legend</code></td>
<td>

<p>Yet unimplemented.
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_annotations">annotations</code></td>
<td>

<p>An <code>annotation</code> object or a list of annotation objects. See
details. Optional.
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_annotation_height">annotation_height</code></td>
<td>

<p>Numeric. The height, in lines, of the annotation line. One by
default, if <code>annotation is defined</code>.
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_annotation_cex">annotation_cex</code></td>
<td>

<p>Numeric. The <code>cex</code> (i.e. the character expansion) of the
annotation line. 
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_seg_plots">seg_plots</code></td>
<td>

<p>A list of <code>seg_plot</code> objects of the length as <code>dna_segs</code>,
a single <code>seg_plot</code> or <code>NULL</code> (default). To draw plots
associated to a <code>dna_seg</code>. See <code><a href="#topic+seg_plot">seg_plot</a></code> for more
information and some examples.
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_seg_plot_height">seg_plot_height</code></td>
<td>

<p>The height of the <code>seg_plot</code> regions. By default, equals to 3
(lines, see next argument).
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_seg_plot_height_unit">seg_plot_height_unit</code></td>
<td>

<p>The unit of the height of the <code>seg_plot</code> regions. Should be a
valid <code>unit</code>. See the <code>grid</code> documentation for more
information. If equals to &quot;null&quot;, then the height will be calculated
as a proportion of the comparison region (i.e. 0.5 means the
<code>seg_plot</code> region will be half the size of the <code>comparison</code>. 
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_seg_plot_yaxis">seg_plot_yaxis</code></td>
<td>

<p>Can be <code>NULL</code>, <code>FALSE</code> or a numercic. In the first two
cases, no y-axis is drawn for the <code>seg_plot</code>s. If numeric, a
axis is drawn with approximately that number of ticks. 
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_seg_plot_yaxis_cex">seg_plot_yaxis_cex</code></td>
<td>

<p>The character expansion of the <code>seg_plot_yaxis</code> labels. Equals
to <code>scale_cex</code> by default.
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_xlims">xlims</code></td>
<td>

<p>A list with as many elements as there are <code>dna_seg</code>s, or
<code>NULL</code>. If <code>NULL</code>, the whole segment will be
represented. If a list, each element of the list is a numeric
vector, representing pairs of  left and right limits for each
subsegment. See details. 
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_offsets">offsets</code></td>
<td>

<p>A list or a vector with as many elements as there are
<code>dna_seg</code>s, or <code>NULL</code>. If is a numeric vector, gives the
offset of the first subsegment. If is a list, each element should
have the same length as there are subsegments (see
<code>xlims</code>). Gives then the length of each gap. If <code>NULL</code>,
the size of the gaps is optimized to minimize the lengths of the
comparisons. See details.
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_minimum_gap_size">minimum_gap_size</code></td>
<td>

<p>A numeric. How much of the plotting region should a gap be, at
least. Default is 0.05 (20% of the plotting region).
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_fixed_gap_length">fixed_gap_length</code></td>
<td>

<p>Should the gaps have a fixed length? Otherwise, the gap length will
be optimized to minimize the size of comparisons. <code>FALSE</code> by
default. 
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_limit_to_longest_dna_seg">limit_to_longest_dna_seg</code></td>
<td>

<p>A logical. Should the plot be restricted to the longest
<code>dna_seg</code>? If no, the other segments can be extended to better
fit comparisons.
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_main">main</code></td>
<td>

<p>A character. Main title of the plot.
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_main_pos">main_pos</code></td>
<td>

<p>Position of the main title. One of <code>centre</code>, <code>left</code> or
<code>right</code>.
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_dna_seg_labels">dna_seg_labels</code></td>
<td>

<p>A character, same length as <code>dna_segs</code>. The names of the
segments. If <code>NULL</code>, the names of <code>dna_segs</code> will be
used, if available. Else, no name are plotted. If a <code>tree</code> is
given, names must exist either in <code>dna_seg_labels</code> or in the
names of <code>dna_segs</code>.
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_dna_seg_label_cex">dna_seg_label_cex</code></td>
<td>

<p>A numeric. The character size for the DNA segments labels, or tree
labels. Default is 1.
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_dna_seg_label_col">dna_seg_label_col</code></td>
<td>

<p>A color, of length 1 or of the same length as <code>dna_segs</code>. Gives
the color of the labels. Default is black.
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_gene_type">gene_type</code></td>
<td>

<p>A character. Describes the type of representation of genes or
<code>dna_seg</code> elements. See details.
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_arrow_head_len">arrow_head_len</code></td>
<td>

<p>A numeric. Gives the length of arrow heads for gene type
&quot;arrows&quot;. The arrow head extends at maximum at half of the gene. Set
to <code>Inf</code> to have all arrow heads covering the half of the
gene. 200 by default.
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_dna_seg_line">dna_seg_line</code></td>
<td>

<p>A vector, either logical or giving colors, of length 1 or of same
length as <code>dna_segs</code>. Should the line in the middle of the
segments be drawn, and if yes, in what color. <code>TRUE</code> by
default, which gives black lines. <code>FALSE</code> (logical, or as a
string) results in no plotting.
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_scale">scale</code></td>
<td>

<p>A logical. Should the scale be displayed on the plot. <code>TRUE</code> by
default. 
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_dna_seg_scale">dna_seg_scale</code></td>
<td>

<p>A logical, of length one or of the same length as
<code>dna_segs</code>. Should a scale be displayed below each or all dna
segments, respectively. <code>!scale</code> by default. 
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_n_scale_ticks">n_scale_ticks</code></td>
<td>

<p>A integer. The (approximate) number of ticks on the longest
segment. Default: 7. 
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_scale_cex">scale_cex</code></td>
<td>

<p>A numeric. The character size for the scale labels. Default is 1.
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_global_color_scheme">global_color_scheme</code></td>
<td>

<p>A character of length 4. If no <code>col</code> column is present on any
comparison or is <code>override_color_schemes</code> is set, apply a
global color scheme over all comparions. See below for more details.
<code>c("auto", "auto", "blue_red")</code> by default. 
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_override_color_schemes">override_color_schemes</code></td>
<td>

<p>A logical. If <code>TRUE</code>, apply a global color scheme even if there
are comparisons that have <code>col</code> columns. <code>FALSE</code> by
default. 
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_plot_new">plot_new</code></td>
<td>

<p>Logical. Produce a new plot? If <code>TRUE</code>, uses
<code>grid.newpage</code> before plotting.
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_debug">debug</code></td>
<td>

<p>A numeric. If &gt; 0, only that number of element will be plotted for
each <code>dna_seg</code> and <code>comparison</code>.
</p>
</td></tr>
<tr><td><code id="plot_gene_map_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed to user-defined graphical functions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One line is plotted per <code><a href="#topic+dna_seg">dna_seg</a></code>. Eventually, the space 
between the lines will be filled with the
<code><a href="#topic+comparison">comparison</a></code>s. <code>dna_seg</code>s can be annotated with
<code><a href="#topic+annotation">annotation</a></code>s, and accompagnying data can be plotted using
<code><a href="#topic+seg_plot">seg_plot</a></code>. 
</p>
<p>A phylogenetic tree (a <code>phylog</code> object from package <code>ade4</code>)
can be drawn at the left of the plot. The tree does not need to be
ordered as the <code>dna_seg_labels</code>, but a permutation of the tree
with that order should exist. If the tree is large, the number of
permutations become too large, and the function will stop (&gt;100000
permutations). The solution is then to provide segments that are
ordered in the same manner as the tree labels (or vice-versa).
</p>
<p>There is an (experimental) support for branch annotations. These are
given in the Newick tree, directly after the parenthesis closing a
node. They can be characters or integers, but so far
<code>newick2phylog</code> doesn't support decimal values. Tags will be
ignored if they start with &quot;I&quot;, and trimmed if they start with &quot;X&quot;.
</p>
<p>The format of the elements of <code>dna_segs</code> is previously determined
in the object or can be globally set by <code>gene_type</code>. See the
function <code><a href="#topic+gene_types">gene_types</a></code> to return the available types. Gene
type can also be user-defined, using a function returning a
<code>grob</code>. See <code><a href="#topic+gene_types">gene_types</a></code> for more details.
</p>
<p><code>xlims</code> allow the user to plot subsegments of a
<code>dna_seg</code>. <code>xlims</code> consists of a list composed of as many
numeric vectors as there are segments. Each of these numeric vectors
give pairs of left and right borders, and gives the
direction. For example, c(1,2,6,4) will plot two subsegments, segment
1 to 2 which is plotted left to right and segment 4 to 6, plotted
right to left. <code>-Inf</code> and <code>Inf</code> values are
accepted. <code>NULL</code> values will result in plotting the whole
segment.
</p>
<p><code>offsets</code> allows to user to define the placement of the
subsegments. If a list is provided, each element of the list should
have as many elements as there are subsegments. It will give the size
of the gaps, including the first one from the border of the plot to
the first subsegment.
</p>
<p>A main title (<code>main</code>) can also be added at the top of the plot,
at the position defined by <code>main_pos</code>. A general scale
can be added at the bottom right of the plot (<code>scale</code>).
</p>
<p><code>dna_seg_scale</code> gives the ability to plot scales on one, some or
every segment. <code>c(TRUE, FALSE, TRUE)</code> will add scales to the
first and third segments.
</p>
<p>The four elements of <code>global_color_scheme</code> are (i) which column
serves as scale to apply the color  scheme, or &quot;auto&quot; (default);
(ii) if the scale is &quot;increasing&quot; or &quot;decreasing&quot; (see
<code>apply_color_scheme</code> for more details), or &quot;auto&quot; (default);
(iii) the color scheme to apply; (iv) the transparency to apply (0.5
by default).
</p>


<h3>Value</h3>


<p>Nothing. A lattice graphic is plotted on the current device.
</p>


<h3>Note</h3>

<p>This plotting function has been tested as far as possible, but given
its complexity and that the package is young, bugs or strange behaviors
are possible. Please report them to the author.
</p>
<p>As of 10/3/2010, support for viewing exons/introns is only available
using genbank and embl formats, not when importing ptt files.
</p>


<h3>Author(s)</h3>

<p>Lionel Guy <a href="mailto:lionel.guy@ebc.uu.se">lionel.guy@ebc.uu.se</a>, Jens Roat Kultima
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dna_seg">dna_seg</a></code> and <code><a href="#topic+comparison">comparison</a></code> for the base objects;
<code><a href="#topic+read_dna_seg_from_tab">read_dna_seg_from_tab</a></code>, <code><a href="#topic+read_dna_seg_from_ptt">read_dna_seg_from_ptt</a></code>,
<code><a href="#topic+read_comparison_from_tab">read_comparison_from_tab</a></code> and
<code><a href="#topic+read_comparison_from_blast">read_comparison_from_blast</a></code> to read from files;
<code><a href="#topic+annotation">annotation</a></code> to annotate <code>dna_seg</code>s;
<code><a href="#topic+seg_plot">seg_plot</a></code> to draw plots next to <code>dna_seg</code>s;
<code><a href="#topic+gene_types">gene_types</a></code> for <code>gene_type</code> argument;
<code><a href="#topic+apply_color_scheme">apply_color_scheme</a></code> for color schemes;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>old.par &lt;- par(no.readonly=TRUE)
data("three_genes")

## Segments only
plot_gene_map(dna_segs=dna_segs) 

## With comparisons
plot_gene_map(dna_segs=dna_segs, comparisons=comparisons) 

## Tree
names &lt;- c("A_aaa", "B_bbb", "C_ccc")
names(dna_segs) &lt;- names
tree &lt;- newick2phylog("(((A_aaa:4.2,B_bbb:3.9):3.1,C_ccc:7.3):1);")
plot_gene_map(dna_segs=dna_segs, comparisons=comparisons,
              tree=tree)
## Increasing tree width
plot_gene_map(dna_segs=dna_segs, comparisons=comparisons,
              tree=tree, tree_width=3)
## Annotations on the tree
tree2 &lt;- newick2phylog("(((A_aaa:4.2,B_bbb:3.9)97:3.1,C_ccc:7.3)78:1);")
plot_gene_map(dna_segs=dna_segs, comparisons=comparisons,
              tree=tree2, tree_width=3)
plot_gene_map(dna_segs=dna_segs, comparisons=comparisons,
              tree=tree2, tree_width=3, tree_branch_labels_cex=0.5)
plot_gene_map(dna_segs=dna_segs, comparisons=comparisons,
              tree=tree2, tree_width=3, tree_branch_labels_cex=0)

## Annotation
## Calculating middle positions
mid_pos &lt;- middle(dna_segs[[1]])

# Create first annotation
annot1 &lt;- annotation(x1=mid_pos, text=dna_segs[[1]]$name)
plot_gene_map(dna_segs=dna_segs, comparisons=comparisons, annotations=annot1)

## Exploring options
annot2 &lt;- annotation(x1=c(mid_pos[1], dna_segs[[1]]$end[2]),
                     x2=c(NA, dna_segs[[1]]$end[3]),
                     text=c(dna_segs[[1]]$name[1], "region1"),
                     rot=c(30, 0), col=c("grey", "black"))
plot_gene_map(dna_segs=dna_segs, comparisons=comparisons,
              annotations=annot2, annotation_height=1.3)

## xlims
## Just returning a segment
plot_gene_map(dna_segs, comparisons,
              xlims=list(NULL, NULL, c(Inf,-Inf)),
              dna_seg_scale=TRUE)
## Removing one gene
plot_gene_map(dna_segs, comparisons,
              xlims=list(NULL, NULL, c(-Inf,2800)),
              dna_seg_scale=TRUE)

## offsets
offsets &lt;- c(0, 0, 0)  
plot_gene_map(dna_segs=dna_segs, comparisons=comparisons, offsets=offsets)
offsets &lt;- c(200, 400, 0)  
plot_gene_map(dna_segs=dna_segs, comparisons=comparisons, offsets=offsets)

## main
plot_gene_map(dna_segs=dna_segs, comparisons=comparisons,
              main="Comparison of A, B and C")
plot_gene_map(dna_segs=dna_segs, comparisons=comparisons,
              main="Comparison of A, B and C", main_pos="left")

## dna_seg_labels
plot_gene_map(dna_segs=dna_segs, comparisons=comparisons,
              dna_seg_labels=c("Huey", "Dewey", "Louie"))

## dna_seg_labels size
plot_gene_map(dna_segs=dna_segs, comparisons=comparisons,
              dna_seg_labels=c("Huey", "Dewey", "Louie"),
              dna_seg_label_cex=2)

## dna_seg_line
plot_gene_map(dna_segs=dna_segs, comparisons=comparisons,
              dna_seg_line=c("FALSE", "red", grey(0.6)))

## gene_type
plot_gene_map(dna_segs=dna_segs, comparisons=comparisons,
              gene_type="side_blocks")

##
## From here on, using a bigger dataset from a 4-genome comparison
##
data("barto")
## Adding a tree
tree &lt;- newick2phylog("(BB:2.5,(BG:1.8,(BH:1,BQ:0.8):1.9):3);")
## Showing only subsegments
xlims1 &lt;- list(c(1380000, 1445000),
               c(10000, 83000),
               c(15000, 98000),
               c(5000, 82000))
## Reducing dataset size for speed purpose
for (i in 1:length(barto$dna_segs)){
    barto$dna_segs[[i]] &lt;- trim(barto$dna_segs[[i]], xlim=xlims1[[i]])
    if (i &lt; length(barto$dna_segs))
        barto$comparisons[[i]] &lt;- trim(barto$comparisons[[i]],
                                      xlim1=xlims1[[i]], xlims1[[i+1]])   
}
plot_gene_map(barto$dna_segs, barto$comparisons, tree=tree,
              xlims=xlims1,
              dna_seg_scale=TRUE)
## Showing several subsegments per genome
xlims2 &lt;- list(c(1445000, 1415000, 1380000, 1412000),
               c(  10000,   45000,   50000,   83000, 90000, 120000),
               c(  15000,   36000,   90000,  120000, 74000,  98000),
               c(   5000,    82000))

## dna_seg_scale, global_color_scheme, size, number, color of dna_seg_scale,
## size of dna_seg_scale labels
plot_gene_map(barto$dna_segs, barto$comparisons, tree=tree, xlims=xlims2,
              dna_seg_scale=c(TRUE, FALSE, FALSE, TRUE), scale=FALSE,
              dna_seg_label_cex=1.7,
              dna_seg_label_col=c("black", "grey", "blue", "red"),
              global_color_scheme=c("e_value", "auto", "grey", "0.7"),
              n_scale_ticks=3, scale_cex=1)

## Hand-made offsets: size of all gaps
offsets2 &lt;- list(c(10000, 10000),
                 c(2000, 2000, 2000),
                 c(10000, 5000, 2000),
                 c(10000))
plot_gene_map(barto$dna_segs, barto$comparisons, tree=tree,
              #annotations=annots,
              xlims=xlims2,
              offsets=offsets2,
              dna_seg_scale=TRUE)
##
## Exploring and modifying a previously plotted gene map plot
##
## View viewports
current.vpTree()
## Go down to one of the viewports, add an xaxis, go back up to root viewport
downViewport("dna_seg_scale.3.2")
grid.rect()
upViewport(0)
## Get all the names of the objects
grobNames &lt;- getNames()
grobNames
## Change the color ot the scale line
grid.edit("scale.lines", gp=gpar(col="grey"))
## Remove first dna_seg_lines
grid.remove("dna_seg_line.1.1")

##
## Plot genoPlotR logo
##
col &lt;- c("#B2182B", "#D6604D", "#F4A582", "#FDDBC7",
         "#D1E5F0", "#92C5DE", "#4393C3", "#2166AC")
cex &lt;- 2.3
## First segment 
start1 &lt;- c(150, 390, 570)
end1   &lt;- c(  1, 490, 690)
genoR &lt;- c(270, 530)
## Second segment
start2 &lt;- c(100, 520, 550)
end2   &lt;- c(240, 420, 650)
Plot &lt;- c(330)
## dna_segs
ds1 &lt;- as.dna_seg(data.frame(name=c("", "", ""),
                             start=start1, end=end1, strand=rep(1, 3),
                             col=col[c(2, 6, 1)], stringsAsFactor=FALSE))
ds_genoR &lt;- as.dna_seg(data.frame(name=c("geno", "R"),
                             start=genoR, end=genoR, strand=rep(1, 2),
                             col=c(col[8], "black"),
                             stringsAsFactor=FALSE), cex=cex, gene_type="text")
ds2 &lt;- as.dna_seg(data.frame(name=c("", "", ""),
                             start=start2, end=end2, strand=rep(1, 3),
                             col=col[c(5, 3, 7)],
                             stringsAsFactor=FALSE))
ds_Plot &lt;- as.dna_seg(data.frame(name="Plot",
                             start=Plot, end=Plot, strand=1,
                             col=col[c(1)],
                             stringsAsFactor=FALSE), cex=cex, gene_type="text")
## comparison
c1 &lt;- as.comparison(data.frame(start1=start1, end1=end1,
                               start2=start2, end2=end2,
                               col=grey(c(0.6, 0.8, 0.5))))
## Generate genoPlotR logo
## Not run: 
pdf("logo.pdf", h=0.7, w=3)

## End(Not run)
par(fin=c(0.7, 3))
plot_gene_map(dna_segs=list(c(ds1, ds_genoR), c(ds2, ds_Plot)),
              comparisons=list(c1), scale=FALSE, dna_seg_scale=FALSE,
              dna_seg_line=grey(0.7), offsets=c(-20,160))
## Not run: 
dev.off()

## End(Not run)
par(old.par)
</code></pre>

<hr>
<h2 id='range.dna_seg'>
Range calculation
</h2><span id='topic+range.dna_seg'></span><span id='topic+range.comparison'></span><span id='topic+range.annotation'></span>

<h3>Description</h3>

<p>Calculate the range of dna_seg and comparisons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dna_seg'
range(x, ...)
## S3 method for class 'comparison'
range(x, overall=TRUE, ...)
## S3 method for class 'annotation'
range(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="range.dna_seg_+3A_x">x</code></td>
<td>

<p>Object to calculate the range from.
</p>
</td></tr>
<tr><td><code id="range.dna_seg_+3A_overall">overall</code></td>
<td>

<p>Logical, <code>TRUE</code> by default. Should the range be calculated over
the whole object? If <code>FALSE</code>, a range is calculated on each
side of the comparison.
</p>
</td></tr>
<tr><td><code id="range.dna_seg_+3A_...">...</code></td>
<td>

<p>Unused.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate the overall range of a <code>dna_seg</code>, <code>comparison</code> or
an <code>annotation</code> object. 
</p>


<h3>Value</h3>

<p>A numeric of length 2. For <code>comparison</code>, if <code>overall</code> is
<code>FALSE</code>, a data frame with two rows and two columns, <code>xlim1</code>
and <code>xlim2</code>.
</p>


<h3>Author(s)</h3>

<p>Lionel Guy
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dna_seg">dna_seg</a></code>, <code><a href="#topic+comparison">comparison</a></code>, <code><a href="#topic+trim">trim</a></code>
for further examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data
data(three_genes)

## On dna_seg
dna_segs[[1]]
range(dna_segs[[1]])

## On comparison
comparisons[[2]]
range(comparisons[[2]])
range(comparisons[[2]], overall=FALSE)
</code></pre>

<hr>
<h2 id='read_functions'>Reading functions</h2><span id='topic+read_functions'></span><span id='topic+read_dna_seg_from_tab'></span><span id='topic+read_dna_seg_from_file'></span><span id='topic+read_dna_seg_from_embl'></span><span id='topic+read_dna_seg_from_genbank'></span><span id='topic+read_dna_seg_from_fasta'></span><span id='topic+read_dna_seg_from_ptt'></span><span id='topic+read_comparison_from_tab'></span><span id='topic+read_comparison_from_blast'></span><span id='topic+read_mauve_backbone'></span>

<h3>Description</h3>

<p>Functions to parse dna_seg objects from tab, embl, genbank, fasta, ptt
files or from mauve backbone files, and comparison objects from tab or blast
files. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_dna_seg_from_tab(file, header = TRUE, ...)
read_dna_seg_from_file(file, tagsToParse=c("CDS"), fileType = "detect",
                       meta_lines = 2, gene_type = "auto", header = TRUE,
                       extra_fields = NULL, ...)
read_dna_seg_from_embl(file, tagsToParse=c("CDS"), ...)
read_dna_seg_from_genbank(file, tagsToParse=c("CDS"), ...)
read_dna_seg_from_fasta(file, ...)
read_dna_seg_from_ptt(file, meta_lines = 2, header = TRUE, ...)
read_comparison_from_tab(file, header = TRUE, ...)
read_comparison_from_blast(file, sort_by = "per_id",
                           filt_high_evalue = NULL,
                           filt_low_per_id = NULL,
                           filt_length = NULL,
                           color_scheme = NULL, ...)
read_mauve_backbone(file, ref = 1, gene_type = "side_blocks",
                    header = TRUE, filter_low = 0,
                    common_blocks_only = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_functions_+3A_file">file</code></td>
<td>

<p>Path to file to load. URL are accepted.
</p>
</td></tr>
<tr><td><code id="read_functions_+3A_header">header</code></td>
<td>

<p>Logical. Does the tab file has headers (column names)?
</p>
</td></tr>
<tr><td><code id="read_functions_+3A_tagstoparse">tagsToParse</code></td>
<td>

<p>Character vector. Tags to parse in embl or genbank files.
Common tags are 'CDS', 'gene', 'misc_feature'.
</p>
</td></tr>
<tr><td><code id="read_functions_+3A_filetype">fileType</code></td>
<td>

<p>Character string. Select file type, could be 'detect' for automatic
detection, 'embl' for embl files, 'genbank' for genbank files or
'ptt' for ptt files.
</p>
</td></tr>
<tr><td><code id="read_functions_+3A_meta_lines">meta_lines</code></td>
<td>

<p>The number of lines in the ptt file that represent &quot;meta&quot; data, not
counting the header lines. Standard for NCBI files is 2 (name and
length, number of proteins. Default is also 2.
</p>
</td></tr>
<tr><td><code id="read_functions_+3A_gene_type">gene_type</code></td>
<td>

<p>Determines how genes are visualized. If 'auto' genes will appear as
arrows in there are no introns and as blocks if there are introns.
Can also be set to for example 'blocks' or 'arrows'. Do note, currently
introns are not supported in the ptt file format.
Default for mauve backbone is <code>side_blocks</code>.
See <code><a href="#topic+gene_types">gene_types</a></code> page for more details, or use function
<code>gene_types</code>. 
</p>
</td></tr>
<tr><td><code id="read_functions_+3A_extra_fields">extra_fields</code></td>
<td>

<p><code>NULL</code> by default. If a character vector, parses extra fields
in the genbank or embl file that have corresponding keys and put
them in the resulting <code>dna_seg</code>.
</p>
</td></tr>
<tr><td><code id="read_functions_+3A_sort_by">sort_by</code></td>
<td>

<p>In BLAST-like tabs, gives the name of the column that will be used
to sort the comparisons. Accepted values are <code>per_id</code>
(percent identity, default), <code>mism</code> (mismatches), <code>gaps</code>
(gaps), <code>e_value</code> (E-value), <code>bit_score</code> (bit score). 
</p>
</td></tr>
<tr><td><code id="read_functions_+3A_filt_high_evalue">filt_high_evalue</code></td>
<td>

<p>A numerical, or <code>NULL</code> (default). Filters out all comparisons
that have a e-value higher than this one.
</p>
</td></tr>
<tr><td><code id="read_functions_+3A_filt_low_per_id">filt_low_per_id</code></td>
<td>

<p>A numerical, or <code>NULL</code> (default). Filters out all comparisons
that have a percent identity lower than this one.
</p>
</td></tr>
<tr><td><code id="read_functions_+3A_filt_length">filt_length</code></td>
<td>

<p>A numerical, or <code>NULL</code> (default). Filters out all comparisons
that have alignments shorter than this value.
</p>
</td></tr>
<tr><td><code id="read_functions_+3A_color_scheme">color_scheme</code></td>
<td>

<p>A color scheme to apply. See <code>apply_color_scheme</code> for more
details. Possible values include <code>grey</code> and <code>red_blue</code>.
<code>NULL</code> by default. Color schemes can be applied while running
<code>plot_gene_map</code>.
</p>
</td></tr>
<tr><td><code id="read_functions_+3A_ref">ref</code></td>
<td>

<p>In mauve backbone, which of the dna segments will be the reference,
i.e. which one will have its blocks in order.
</p>
</td></tr>
<tr><td><code id="read_functions_+3A_...">...</code></td>
<td>

<p>Further arguments passed to generic reading functions and class
conversion functions. See <code><a href="#topic+as.dna_seg">as.dna_seg</a></code> and
<code><a href="#topic+as.comparison">as.comparison</a></code>.
</p>
<p>For <code>read_comparison*</code> functions, see details.
</p>
</td></tr>
<tr><td><code id="read_functions_+3A_filter_low">filter_low</code></td>
<td>

<p>A numeric. If larger than 0, all blocks smaller that this number
will be filtered out. Defaults to 0.
</p>
</td></tr>
<tr><td><code id="read_functions_+3A_common_blocks_only">common_blocks_only</code></td>
<td>

<p>A logical. If <code>TRUE</code> (by default), reads only common blocks
(core blocks).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tab files representing DNA segements should have at least the following
columns: name, start, end, strand (in that order. Additionally, if the
tab file has headers, more columns will be used to define, for
example, the color, line width and type, pch and/or cex. See
<code><a href="#topic+dna_seg">dna_seg</a></code> for more information. An example:
</p>

<table>
<tr>
 <td style="text-align: left;">
    name   </td><td style="text-align: left;"> start </td><td style="text-align: left;"> end   </td><td style="text-align: left;"> strand </td><td style="text-align: left;"> col   </td>
</tr>
<tr>
 <td style="text-align: left;">
    feat1A </td><td style="text-align: left;"> 2     </td><td style="text-align: left;"> 1345  </td><td style="text-align: left;"> 1      </td><td style="text-align: left;"> blue  </td>
</tr>
<tr>
 <td style="text-align: left;">
    feat1B </td><td style="text-align: left;"> 1399  </td><td style="text-align: left;"> 2034  </td><td style="text-align: left;"> 1      </td><td style="text-align: left;"> red   </td>
</tr>
<tr>
 <td style="text-align: left;">
    feat1C </td><td style="text-align: left;"> 2101  </td><td style="text-align: left;"> 2932  </td><td style="text-align: left;"> -1     </td><td style="text-align: left;"> grey  </td>
</tr>
<tr>
 <td style="text-align: left;">
    feat1D </td><td style="text-align: left;"> 2800  </td><td style="text-align: left;"> 3120  </td><td style="text-align: left;"> 1      </td><td style="text-align: left;"> green </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>Embl and Genbank files are two commonly used file types. These file types
often contain a great variety of information. To properly extract data from
these files, the user has to choose which features to extract. Commonly 'CDS'
features are of interest, but other feature tags such as 'gene' or
'misc_feature'  may be of interest. Should a feature contain an inner
&quot;pseudo&quot; tag indicating this CDS or gene is a pseudo gene, this will
be presented as a 'CDS_pseudo' or a 'gene_pseudo' feature type
respectively in the resulting table. Certain constraints apply to
these file types, of which some are: embl files must contain one and
only one ID tag; genbank files may only contain one and only one locus
tag. In these two files, the following tags are parsed (in addition to
the regular name, start, end and strand): protein_id, product, color
(or colour). In addition, extra tags can be parsed with the argument
<code>extra_fields</code>. If there are more than one field with such a tag,
only the first one is parsed.
</p>
<p>Fasta files are read as one gene, as long as there are nucleotides in
the fasta file.
</p>
<p>Ptt (or protein table) files are a tabular format giving a bunch of
information on each protein of a genome (or plasmid, or virus,
etc). They are available for each published genome on the NCBI ftp
site (ftp://ftp.ncbi.nlm.nih.gov/genomes/). As an example, look at
ftp://ftp.ncbi.nlm.nih.gov/genomes/Bacteria/Bartonella_henselae_Houston-1/NC_005956.ptt.
</p>
<p>Tabular comparison files should have at least the following
columns: start1, end1, start2, end2. If no header is specified, the
fifth column is parsed as the color.
</p>

<table>
<tr>
 <td style="text-align: left;">
    start1 </td><td style="text-align: left;"> end1   </td><td style="text-align: left;"> start2 </td><td style="text-align: left;"> end2  </td><td style="text-align: left;">  col  </td>
</tr>
<tr>
 <td style="text-align: left;">
    2      </td><td style="text-align: left;"> 1345   </td><td style="text-align: left;"> 10     </td><td style="text-align: left;"> 1210  </td><td style="text-align: left;">  red  </td>
</tr>
<tr>
 <td style="text-align: left;">
    1399   </td><td style="text-align: left;"> 2034   </td><td style="text-align: left;"> 2700   </td><td style="text-align: left;"> 1100  </td><td style="text-align: left;">  blue </td>
</tr>
<tr>
 <td style="text-align: left;">
    500    </td><td style="text-align: left;"> 800    </td><td style="text-align: left;"> 3000   </td><td style="text-align: left;"> 2500  </td><td style="text-align: left;">  blue </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>BLAST tabular result files are produced either with blastall using -m8
or -m9 parameter, or with any of the newer
blastn/blastp/blastx/tblastx using -outfmt 6 or -outfmt 7.
</p>
<p>In the subsequent <code>plot_gene_map</code>, the comparisons are drawn in
the order of the <code>comparison</code> object, i.e. the last rows of the
comparison object are on the top in the plot. For comparisons read
from BLAST output, the order can be modified by using the argument
<code>sort_by</code>. In any case, the order of plotting can be modified by
modifying the order of rows in the <code>comparison</code> object prior to
plotting. 
</p>
<p>Mauve backbone is another tabular data file that summarizes the blocks
that are similar between all compared genomes. Each genome gets two
columns, one start and one end of the block. There is one row per
block and eventually a header row. If named, columns have sequence
numbers, not actual names, so be careful to input the same order in
both Mauve and genoPlotR. See
http://asap.ahabs.wisc.edu/mauve-aligner/mauve-user-guide/mauve-output-file-formats.html
for more info on the file format. Normally, the function should be
able to read both <code>progressiveMauve</code> and <code>mauveAligner</code>
outputs. The function returns both the blocks as <code>dna_seg</code>s and
the links between the blocks as <code>comparison</code>s.
</p>


<h3>Value</h3>

<p><code>read_dna_seg_from_tab</code>, <code>read_dna_seg_from_file</code>, <code>read_dna_seg_from_embl</code>,
<code>read_dna_seg_from_genbank</code> and <code>read_dna_seg_from_ptt</code> return
<code>dna_seg</code> objects. <code>read_comparison_from_tab</code> and
<code>read_comparison_from_blast</code> return <code>comparison</code>
objects. <code>read_mauve_backbone</code> returns a list containing a list
of <code>dna_seg</code>s and <code>comparison</code>s.
objects. 
</p>


<h3>Note</h3>

<p>Formats are changing and it maybe that some functions are temporarily
malfunctioning. Please report any bug to the author. Mauve examples
were prepared with Mauve 2.3.1.
</p>


<h3>Author(s)</h3>

<p>Lionel Guy, Jens Roat Kultima
</p>


<h3>References</h3>

<p>For BLAST: http://www.ncbi.nlm.nih.gov/blast/
For Mauve: http://asap.ahabs.wisc.edu/mauve/
</p>


<h3>See Also</h3>

<p><code><a href="#topic+comparison">comparison</a></code>, <code><a href="#topic+dna_seg">dna_seg</a></code>,
<code><a href="#topic+apply_color_scheme">apply_color_scheme</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## From tabs
##
## Read DNA segment from tab
dna_seg3_file &lt;- system.file('extdata/dna_seg3.tab', package = 'genoPlotR')
dna_seg3 &lt;- read_dna_seg_from_tab(dna_seg3_file)

## Read comparison from tab
comparison2_file &lt;- system.file('extdata/comparison2.tab',
                                package = 'genoPlotR')
comparison2 &lt;- read_comparison_from_tab(comparison2_file)

##
## Mauve backbone
##
## File: this is only to retrieve the file from the genoPlotR
## installation folder. 
bbone_file &lt;- system.file('extdata/barto.backbone', package = 'genoPlotR')
## Read backbone
## To read your own backbone, run something like
## bbone_file &lt;- "/path/to/my/file.bbone"
bbone &lt;- read_mauve_backbone(bbone_file)
names &lt;- c("B_bacilliformis", "B_grahamii", "B_henselae", "B_quintana")
names(bbone$dna_segs) &lt;- names
## Plot
plot_gene_map(dna_segs=bbone$dna_segs, comparisons=bbone$comparisons)

## Using filter_low &amp; changing reference sequence
bbone &lt;- read_mauve_backbone(bbone_file, ref=2, filter_low=2000) 
names(bbone$dna_segs) &lt;- names
plot_gene_map(dna_segs=bbone$dna_segs, comparisons=bbone$comparisons)

## Read guide tree
tree_file &lt;- system.file('extdata/barto.guide_tree', package = 'genoPlotR')
tree_str &lt;- readLines(tree_file)
for (i in 1:length(names)){
  tree_str &lt;- gsub(paste("seq", i, sep=""), names[i], tree_str)
}
tree &lt;- newick2phylog(tree_str)
## Plot
plot_gene_map(dna_segs=bbone$dna_segs, comparisons=bbone$comparisons,
              tree=tree)

##
## From embl file
##
bq_embl_file &lt;- system.file('extdata/BG_plasmid.embl', package = 'genoPlotR')
bq &lt;- read_dna_seg_from_embl(bq_embl_file)

##
## From genbank file
##
bq_genbank_file &lt;- system.file('extdata/BG_plasmid.gbk', package = 'genoPlotR')
bq &lt;- read_dna_seg_from_file(bq_genbank_file, fileType="detect")

## Parsing extra fields in the genbank file
bq &lt;- read_dna_seg_from_file(bq_genbank_file,
                             extra_fields=c("db_xref", "transl_table"))
names(bq)


##
## From ptt files
##
## From a file
bq_ptt_file &lt;- system.file('extdata/BQ.ptt', package = 'genoPlotR')
bq &lt;- read_dna_seg_from_ptt(bq_ptt_file)
## Read directly from NCBI ftp site:
url &lt;- "ftp://ftp.ncbi.nih.gov/genomes/Bacteria/Bartonella_henselae_Houston-1/NC_005956.ptt"
attempt &lt;- 0
## Not run: 
while (attempt &lt; 5){
  attempt &lt;- attempt + 1
  bh &lt;- try(read_dna_seg_from_ptt(url))
  if (!inherits(bh, "try-error")) {
    attempt &lt;- 99
  } else {
    print(paste("Tried", attempt, "times, retrying in 5s"))
    Sys.sleep(5)
  }
}

## End(Not run)
## If attempt to connect to internet fails
if (!exists("bh")){
  data(barto)
  bh &lt;- barto$dna_segs[[3]]
}

##
## Read from blast
##
bh_vs_bq_file &lt;- system.file('extdata/BH_vs_BQ.blastn.tab',
                             package = 'genoPlotR')
bh_vs_bq &lt;- read_comparison_from_blast(bh_vs_bq_file, color_scheme="grey")

## Plot
plot_gene_map(dna_segs=list(BH=bh, BQ=bq), comparisons=list(bh_vs_bq),
              xlims=list(c(1,50000), c(1, 50000)))


</code></pre>

<hr>
<h2 id='reverse'>
Reverse objects
</h2><span id='topic+reverse'></span><span id='topic+reverse.default'></span><span id='topic+reverse.dna_seg'></span><span id='topic+reverse.comparison'></span>

<h3>Description</h3>

<p>Reverse objects, mainly <code>dna_seg</code> and <code>comparison</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reverse(x, ...)
## Default S3 method:
reverse(x, ...)
## S3 method for class 'dna_seg'
reverse(x, ...)
## S3 method for class 'comparison'
reverse(x, side = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reverse_+3A_x">x</code></td>
<td>

<p>The object to reverse.
</p>
</td></tr>
<tr><td><code id="reverse_+3A_...">...</code></td>
<td>

<p>Unused.
</p>
</td></tr>
<tr><td><code id="reverse_+3A_side">side</code></td>
<td>

<p>In the case of comparisons, the side of the comparison that should
be reversed. If <code>side=1</code>, the first side will be reversed. If
<code>side=2</code>, the second side will be reversed. If <code>side&lt;1</code>,
no side is reversed. If <code>side&gt;2</code>, both sides are reversed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same object as input.
</p>


<h3>Author(s)</h3>

<p>Lionel Guy
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dna_seg">dna_seg</a></code>, <code><a href="#topic+comparison">comparison</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load data
data(three_genes)

## on dna_seg
dna_segs[[1]]
reverse(dna_segs[[1]])
## on comparison
reverse(comparisons[[2]], side=1)
reverse(comparisons[[2]], side=3)

## With mauve backbone
data(mauve_bbone)
## Plot
plot_gene_map(dna_segs=bbone$dna_segs, comparisons=bbone$comparisons)

## Reverse B_bacilliformis, and the corresponding comparison (first "side")
bbone$dna_segs[[1]] &lt;- reverse(bbone$dna_segs[[1]])
bbone$comparisons[[1]] &lt;- reverse(bbone$comparisons[[1]], 1)
plot_gene_map(dna_segs=bbone$dna_segs, comparisons=bbone$comparisons)

</code></pre>

<hr>
<h2 id='seg_plot'>
seg_plot class and class functions
</h2><span id='topic+seg_plot'></span><span id='topic+as.seg_plot'></span><span id='topic+is.seg_plot'></span>

<h3>Description</h3>

<p>An seg_plot is an object to plot data associated to a <code>dna_seg</code>
object. It is a <code>list</code> with mandatory and optional arguments. The
main arguments are <code>func</code>, which is a function returning a
<code><a href="grid.html#topic+grob">grob</a></code> or a <code><a href="grid.html#topic+gList">gList</a></code>, and <code>args</code>, which
are arguments to be passed to this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seg_plot(func,
         args = NULL,
         xargs = c("x", "x0", "x1", "x2", "v"),
         yargs = c("y", "y0", "y1", "y2", "h"),
         ylim = NULL)
as.seg_plot(seg_plot)
is.seg_plot(seg_plot)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seg_plot_+3A_func">func</code></td>
<td>

<p>Mandatory, with no defaults. A function that returns a <code>grob</code>
object. See <code><a href="graphics.html#topic+grid">grid</a></code> documentation to find ready-made
functions. User-defined functions work too.
</p>
</td></tr>
<tr><td><code id="seg_plot_+3A_args">args</code></td>
<td>

<p>A list, <code>NULL</code> by default. The arguments that will be passed to
the function. It is recommended that all arguments are named.
</p>
</td></tr>
<tr><td><code id="seg_plot_+3A_xargs">xargs</code></td>
<td>

<p>A vector giving the names of which of the arguments in <code>args</code>
are defining the x-axis. Used, among others, by the function
<code><a href="#topic+trim.seg_plot">trim.seg_plot</a></code>. By default, gives the most common
x-defining arguments of the <code>grid</code> functions (x, x0, x1, x2, v). 
</p>
</td></tr>
<tr><td><code id="seg_plot_+3A_yargs">yargs</code></td>
<td>

<p>A vector giving the names of which of the arguments in <code>args</code>
are defining the y-axis. Used when plotting the graphs to define
a sensible <code>ylim</code> if not defined. By default, gives the most common
y-defining arguments of the <code>grid</code> functions (y, y0, y1, y2, h). 
</p>
</td></tr>
<tr><td><code id="seg_plot_+3A_ylim">ylim</code></td>
<td>

<p>A numeric vector of length 2, defining the range of the plot when
drawn with <code><a href="#topic+plot_gene_map">plot_gene_map</a></code>. Derived from <code>yargs</code> if
not set.
</p>
</td></tr>
<tr><td><code id="seg_plot_+3A_seg_plot">seg_plot</code></td>
<td>

<p>In <code>as.seg_plot</code>, a <code>list</code> object to convert to
<code>seg_plot</code>. See details below.
</p>
<p>In <code>is.seg_plot</code>, an object to test.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>seg_plot</code> object is an object describing how to plot data
associated to a <code>dna_seg</code>. It is a list composed of a function,
arguments to pass to this function, two arguments to define which of
those define x and y, and an eventual <code>ylim</code> to limit the
plotting to a certain range when plotting.
</p>
<p>The function <code>func</code> should return a <code>grob</code> object, or a
<code>gList</code> list of <code>grob</code>s. The predefined functions of
<code>grid</code>, such as <code>linesGrob</code>, <code>pointsGrob</code>,
<code>segmentsGrob</code>, <code>textGrob</code> or <code>polygonGrob</code> can be
used, or user-defined functions can be defined.
</p>
<p>The arguments in <code>args</code> should correspond to arguments passed to
<code>func</code>. For example, if <code>func = pointsGrob</code>, <code>args</code>
could contain the elements <code>x = 10:1</code>, <code>y = 1:10</code>. It will
often also contain a <code>gp</code> element, the result of a call to the
<code><a href="grid.html#topic+gpar">gpar</a></code> function, to control graphical aspects of the plot
such as color, fill, line width and style, fonts, etc.
</p>


<h3>Value</h3>

<p><code>seg_plot</code> and <code>as.seg_plot</code> return a <code>seg_plot</code> object.
<code>is.seg_plot</code> returns a logical.
</p>


<h3>Author(s)</h3>

<p>Lionel Guy
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_gene_map">plot_gene_map</a></code>, <code><a href="#topic+trim.seg_plot">trim.seg_plot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Using the existing pointsGrob
x &lt;- 1:20
y &lt;- rnorm(20)
sp &lt;- seg_plot(func=pointsGrob, args=list(x=x, y=y,
                                  gp=gpar(col=1:20, cex=1:3)))
is.seg_plot(sp)
## Function seg_plot(...) is identical to as.seg_plot(list(...))
sp2 &lt;- as.seg_plot(list(func=pointsGrob, args=list(x=x, y=y,
                                           gp=gpar(col=1:20, cex=1:3))))
identical(sp, sp2)
## For the show, plot the obtained result
grb &lt;- do.call(sp$func, sp$args)
## Trim the seg_plot
sp_trim &lt;- trim(sp, c(3, 10))
## Changing color and function "on the fly"
sp_trim$args$gp$col &lt;- "blue"
sp_trim$func &lt;- linesGrob
grb_trim &lt;- do.call(sp_trim$func, sp_trim$args)
## Now plot
plot.new()
pushViewport(viewport(xscale=c(0,21), yscale=c(-4,4)))
grid.draw(grb)
grid.draw(grb_trim)

## Using home-made function
triangleGrob &lt;- function(start, end, strand, col, ...) {
  x &lt;- c(start, (start+end)/2, end)
  y1 &lt;- 0.5 + 0.4*strand
  y &lt;- c(y1, rep(0.5, length(y1)), y1)
  polygonGrob(x, y, gp=gpar(col=col), default.units="native",
              id=rep(1:7, 3))
}
start &lt;- seq(1, 19, by=3)+rnorm(7)/3
end &lt;- start + 1 + rnorm(7)
strand &lt;- sign(rnorm(7))
sp_tr &lt;- seg_plot(func=triangleGrob,
                  args=list(start=start, end=end, strand=strand,
                    col=1:length(start)), xargs=c("start", "end"))
grb_tr &lt;- do.call(sp_tr$func, sp_tr$args)
plot.new()
pushViewport(viewport(xscale=c(1,22), yscale=c(-2,2)))
grid.draw(grb_tr)
## Trim
sp_tr_trim &lt;- trim(sp_tr, xlim=c(5, 15))
str(sp_tr_trim)
## If the correct xargs are not indicated, trimming won't work
sp_tr$xargs &lt;- c("x")
sp_tr_trim2 &lt;- trim(sp_tr, xlim=c(5, 15))
identical(sp_tr_trim, sp_tr_trim2)

y1 &lt;- convertY(grobY(grb_tr, "south"), "native")
y2 &lt;- convertY(grobY(grb_tr, "north"), "native")
heightDetails(grb)
grb

## Applying it to plot_gene_maps
data(three_genes)

## Build data to plot
xs &lt;- lapply(dna_segs, range)
colors &lt;- c("red", "blue", "green")

seg_plots &lt;- list()
for (i in 1:length(xs)){
  x &lt;- seq(xs[[i]][1], xs[[i]][2], length=20)
  seg_plots[[i]] &lt;- seg_plot(func=pointsGrob,
                             args=list(x=x, y=rnorm(20)+2*i,
                               default.units="native", pch=3,
                               gp=gpar(col=colors[i], cex=0.5)))
}
plot_gene_map(dna_segs, comparisons,
              seg_plots=seg_plots,
              seg_plot_height=0.5,
              seg_plot_height_unit="inches",
              dna_seg_scale=TRUE)

## A more complicated example
data(barto)
tree &lt;- newick2phylog("(BB:2.5,(BG:1.8,(BH:1,BQ:0.8):1.9):3);")
## Showing several subsegments per genome
xlims2 &lt;- list(c(1445000, 1415000, 1380000, 1412000),
               c(  10000,   45000,   50000,   83000, 90000, 120000),
               c(  15000,   36000,   90000,  120000, 74000,  98000),
               c(   5000,    82000))

## Adding fake data in 1kb windows
seg_plots &lt;- lapply(barto$dna_segs, function(ds){
  x &lt;- seq(1, range(ds)[2], by=1000)
  y &lt;- jitter(seq(100, 300, length=length(x)), amount=50)
  seg_plot(func=linesGrob, args=list(x=x, y=y, gp=gpar(col=grey(0.3), lty=2)))
})
plot_gene_map(barto$dna_segs, barto$comparisons, tree=tree,
              seg_plots=seg_plots,
              seg_plot_height=0.5,
              seg_plot_height_unit="inches",
              xlims=xlims2,
              limit_to_longest_dna_seg=FALSE,
              dna_seg_scale=TRUE,
              main="Random plots for the same segment in 4 Bartonella genomes")

</code></pre>

<hr>
<h2 id='three_genes'>Three genes data set</h2><span id='topic+three_genes'></span><span id='topic+dna_segs'></span><span id='topic+comparisons'></span>

<h3>Description</h3>

<p>A set of three made-up genes, compared in three chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(three_genes)
</code></pre>


<h3>Format</h3>

<p>Two dataframes, representing the three genes in three DNA
segments:
</p>

<ul>
<li><p><code>dna_segs</code>which is a list of three <code>dna_seg</code>
objects, containing each three rows (or genes).
</p>
</li>
<li><p><code>comparisons</code>which is a list of two <code>comparison</code>
objects.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(three_genes)
plot_gene_map(dna_segs, comparisons)
</code></pre>

<hr>
<h2 id='trim'>
Trimming data frames or more complex objects with &gt;= 2 numeric columns 
</h2><span id='topic+trim'></span><span id='topic+trim.default'></span><span id='topic+trim.dna_seg'></span><span id='topic+trim.comparison'></span><span id='topic+trim.annotation'></span><span id='topic+trim.seg_plot'></span>

<h3>Description</h3>

<p>Trims data frames with 2 or more numeric columns using a
xlim. <code>xlim</code>(s) are as used to filter rows whose numeric values are
included in this interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim(x, ...)
## Default S3 method:
trim(x, xlim = NULL, ...)
## S3 method for class 'dna_seg'
trim(x, xlim = NULL, ...)
## S3 method for class 'comparison'
trim(x, xlim1 = c(-Inf, Inf), xlim2 = c(-Inf, Inf), ...)
## S3 method for class 'annotation'
trim(x, xlim = NULL, ...)
## S3 method for class 'seg_plot'
trim(x, xlim = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trim_+3A_x">x</code></td>
<td>

<p>An object to trim,. generally a data frame or a matrix, or a
<code>seg_plot</code> object.
</p>
</td></tr>
<tr><td><code id="trim_+3A_xlim">xlim</code></td>
<td>

<p>A numeric of length 2. In a general case, the rows whose values are
included in this interval are returned.
</p>
</td></tr>
<tr><td><code id="trim_+3A_...">...</code></td>
<td>

<p>Unused.
</p>
</td></tr>
<tr><td><code id="trim_+3A_xlim1">xlim1</code></td>
<td>

<p>A numeric of length 2. In the case of comparison, where the
comparison can be filtered on two sides, the interval to filter the
first side. 
</p>
</td></tr>
<tr><td><code id="trim_+3A_xlim2">xlim2</code></td>
<td>

<p>A numeric of length 2. The interval to filter the second side.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the case where <code>x</code> is a <code>seg_plot</code> object, the function
uses the <code>xargs</code> argument to define what are the vectors defining
the x position (they should be the same length). Then, all the
arguments (including those inside an eventual <code>gp</code> argument) that
are the same length as the x vectors are trimmed, so that only the
rows for which the x values are inside the <code>xlim</code> argument are kept.
</p>


<h3>Value</h3>

<p>Returns the same object as input, with the rows (or subset)
corresponding to the given interval.
</p>


<h3>Author(s)</h3>

<p>Lionel Guy
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dna_seg">dna_seg</a></code>, <code><a href="#topic+comparison">comparison</a></code>, <code><a href="#topic+seg_plot">seg_plot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load
data(barto)
xlim_ref &lt;- c(10000, 45000)
## Seg 2 (ref)
barto$dna_segs[[2]] &lt;- trim(barto$dna_segs[[2]], xlim=xlim_ref)
## Seg 1
barto$comparisons[[1]] &lt;- trim(barto$comparisons[[1]], xlim2=xlim_ref)
xlim1 &lt;- range(barto$comparisons[[1]], overall=FALSE)$xlim1
barto$dna_segs[[1]] &lt;- trim(barto$dna_segs[[1]], xlim=xlim1)
## Seg 3
barto$comparisons[[2]] &lt;- trim(barto$comparisons[[2]], xlim1=xlim_ref)
xlim3 &lt;- range(barto$comparisons[[2]], overall=FALSE)$xlim2
barto$dna_segs[[3]] &lt;- trim(barto$dna_segs[[3]], xlim=xlim3)
## Seg 4
barto$comparisons[[3]] &lt;- trim(barto$comparisons[[3]], xlim1=xlim3)
xlim4 &lt;- range(barto$comparisons[[3]], overall=FALSE)$xlim2
barto$dna_segs[[4]] &lt;- trim(barto$dna_segs[[4]], xlim=xlim4)
## Plot
plot_gene_map(barto$dna_segs, barto$comparisons)

## With seg_plot
x &lt;- 1:20
y &lt;- rnorm(20)
sp &lt;- seg_plot(func=pointsGrob, args=list(x=x, y=y,
                                  gp=gpar(col=1:20, cex=1:3)))
## Trim 
sp_trim &lt;- trim(sp, c(3, 10))
str(sp_trim)
range(sp_trim$arg$x)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
