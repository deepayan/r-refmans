<!DOCTYPE html><html><head><title>Help for package gratia</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gratia}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_confint'><p>Add a confidence interval to an existing object</p></a></li>
<li><a href='#add_constant'><p>Add a constant to estimated values</p></a></li>
<li><a href='#add_fitted'><p>Add fitted values from a model to a data frame</p></a></li>
<li><a href='#add_fitted_samples'><p>Add posterior draws from a model to a data object</p></a></li>
<li><a href='#add_fitted.gam'><p>Add fitted values from a GAM to a data frame</p></a></li>
<li><a href='#add_partial_residuals'><p>Add partial residuals</p></a></li>
<li><a href='#add_residuals'><p>Add residuals from a model to a data frame</p></a></li>
<li><a href='#add_residuals.gam'><p>Add residuals from a GAM to a data frame</p></a></li>
<li><a href='#add_sizer'><p>Add indicators of significant change after SiZeR</p></a></li>
<li><a href='#appraise'><p>Model diagnostic plots</p></a></li>
<li><a href='#basis'><p>Basis expansions for smooths</p></a></li>
<li><a href='#basis_size'><p>Extract basis dimension of a smooth</p></a></li>
<li><a href='#bird_move'><p>Simulated bird migration data</p></a></li>
<li><a href='#boundary'><p>Extract the boundary of a soap film smooth</p></a></li>
<li><a href='#check_user_select_smooths'><p>Select smooths based on user's choices</p></a></li>
<li><a href='#coef.scam'><p>Extract coefficients from a fitted <code>scam</code> model.</p></a></li>
<li><a href='#compare_smooths'><p>Compare smooths across models</p></a></li>
<li><a href='#confint.fderiv'><p>Point-wise and simultaneous confidence intervals for derivatives of smooths</p></a></li>
<li><a href='#confint.gam'><p>Point-wise and simultaneous confidence intervals for smooths</p></a></li>
<li><a href='#data_combos'><p>All combinations of factor levels plus typical values of continuous variables</p></a></li>
<li><a href='#data_sim'><p>Simulate example data for fitting GAMs</p></a></li>
<li><a href='#data_slice'><p>Prepare a data slice through model covariates</p></a></li>
<li><a href='#datagen'><p>Generate data over the range of variables used in smooths</p></a></li>
<li><a href='#derivative_samples'><p>Posterior expectations of derivatives from an estimated model</p></a></li>
<li><a href='#derivatives'><p>Derivatives of estimated smooths via finite differences</p></a></li>
<li><a href='#difference_smooths'><p>Differences of factor smooth interactions</p></a></li>
<li><a href='#draw'><p>Generic plotting via <code>ggplot2</code></p></a></li>
<li><a href='#draw_parametric_effect'><p>Internal function to draw an individual parametric effect</p></a></li>
<li><a href='#draw.basis'><p>Plot basis functions</p></a></li>
<li><a href='#draw.compare_smooths'><p>Plot comparisons of smooths</p></a></li>
<li><a href='#draw.derivatives'><p>Plot derivatives of smooths</p></a></li>
<li><a href='#draw.difference_smooth'><p>Plot differences of smooths</p></a></li>
<li><a href='#draw.evaluated_parametric_term'><p>Plot estimated parametric effects</p></a></li>
<li><a href='#draw.gam'><p>Plot estimated smooths from a fitted GAM</p></a></li>
<li><a href='#draw.gamlss'><p>Plot smooths of a GAMLSS model estimated by <code>GJRM::gamlss</code></p></a></li>
<li><a href='#draw.mgcv_smooth'><p>Plot basis functions</p></a></li>
<li><a href='#draw.pairwise_concurvity'><p>Plot concurvity measures</p></a></li>
<li><a href='#draw.parametric_effects'><p>Plot estimated effects for model parametric terms</p></a></li>
<li><a href='#draw.penalty_df'><p>Display penalty matrices of smooths using <code>ggplot</code></p></a></li>
<li><a href='#draw.rootogram'><p>Draw a rootogram</p></a></li>
<li><a href='#draw.smooth_estimates'><p>Plot the result of a call to <code>smooth_estimates()</code></p></a></li>
<li><a href='#draw.smooth_samples'><p>Plot posterior smooths</p></a></li>
<li><a href='#edf'><p>Effective degrees of freedom for smooths and GAMs</p></a></li>
<li><a href='#eval_smooth'><p>S3 methods to evaluate individual smooths</p></a></li>
<li><a href='#evaluate_parametric_term'><p>Evaluate parametric model terms</p></a></li>
<li><a href='#evaluate_smooth'><p>Evaluate a smooth</p></a></li>
<li><a href='#evenly'><p>Create a sequence of evenly-spaced values</p></a></li>
<li><a href='#factor_combos'><p>All combinations of factor levels</p></a></li>
<li><a href='#family_name'><p>Name of family used to fit model</p></a></li>
<li><a href='#family_type'><p>Extracts the type of family in a consistent way</p></a></li>
<li><a href='#family.gam'><p>Extract family objects from models</p></a></li>
<li><a href='#fderiv'><p>First derivatives of fitted GAM functions</p></a></li>
<li><a href='#fitted_samples'><p>Draw fitted values from the posterior distribution</p></a></li>
<li><a href='#fitted_values'><p>Generate fitted values from a estimated GAM</p></a></li>
<li><a href='#fix_offset'><p>Fix the names of a data frame containing an offset variable.</p></a></li>
<li><a href='#fixef'><p>Extract fixed effects estimates</p></a></li>
<li><a href='#fixef.gam'><p>Extract fixed effects estimates from a fitted GAM</p></a></li>
<li><a href='#gaussian_draws'><p>Posterior samples using a simple Metropolis Hastings sampler</p></a></li>
<li><a href='#get_by_smooth'><p>Extract an factor-by smooth by name</p></a></li>
<li><a href='#get_smooth'><p>Extract an mgcv smooth by name</p></a></li>
<li><a href='#get_smooths_by_id'><p>Extract an mgcv smooth given its position in the model object</p></a></li>
<li><a href='#gratia-package'><p>gratia: Graceful 'ggplot'-Based Graphics and Other Functions for GAMs Fitted Using 'mgcv'</p></a></li>
<li><a href='#gss_vocab'><p>Data from the General Social Survey (GSS) from the National Opinion Research</p>
Center of the University of Chicago</a></li>
<li><a href='#gw_f0'><p>Gu and Wabha test functions</p></a></li>
<li><a href='#has_theta'><p>Are additional parameters available for a GAM?</p></a></li>
<li><a href='#is_by_smooth'><p>Tests for by variable smooths</p></a></li>
<li><a href='#is_factor_term'><p>Is a model term a factor (categorical)?</p></a></li>
<li><a href='#is_mgcv_smooth'><p>Check if objects are smooths or are a particular type of smooth</p></a></li>
<li><a href='#is_offset'><p>Is a model term an offset?</p></a></li>
<li><a href='#link'><p>Extract link and inverse link functions from models</p></a></li>
<li><a href='#load_mgcv'><p>Load mgcv quietly</p></a></li>
<li><a href='#lp_matrix'><p>Return the linear prediction matrix of a fitted GAM</p></a></li>
<li><a href='#lss_parameters'><p>General names of LSS parameters for each GAM family</p></a></li>
<li><a href='#mh_draws'><p>Posterior samples using a Gaussian approximation to the posterior</p>
distribution</a></li>
<li><a href='#model_concurvity'><p>Concurvity of an estimated GAM</p></a></li>
<li><a href='#model_constant'><p>Extract the model constant term</p></a></li>
<li><a href='#model_vars'><p>List the variables involved in a model fitted with a formula</p></a></li>
<li><a href='#n_smooths'><p>How many smooths in a fitted model</p></a></li>
<li><a href='#nb_theta'><p>Negative binomial parameter theta</p></a></li>
<li><a href='#nested_partial_residuals'><p>Partial residuals in nested form</p></a></li>
<li><a href='#nested_rug_values'><p>Values for rug plot in nested form</p></a></li>
<li><a href='#null_deviance'><p>Extract the null deviance of a fitted model</p></a></li>
<li><a href='#observed_fitted_plot'><p>Plot of fitted against observed response values</p></a></li>
<li><a href='#overview'><p>Provides an overview of a model and the terms in that model</p></a></li>
<li><a href='#parametric_effects'><p>Estimated values for parametric model terms</p></a></li>
<li><a href='#parametric_terms'><p>Names of any parametric terms in a GAM</p></a></li>
<li><a href='#partial_derivatives'><p>Partial derivatives of estimated multivariate smooths via finite</p>
differences</a></li>
<li><a href='#partial_residuals'><p>Partial residuals</p></a></li>
<li><a href='#penalty'><p>Extract and tidy penalty matrices</p></a></li>
<li><a href='#post_draws'><p>Low-level Functions to generate draws from the posterior distribution of</p>
model coefficients</a></li>
<li><a href='#post_link_funs'><p>A list of transformation functions named for LSS parameters in a GAMLSS</p></a></li>
<li><a href='#posterior_samples'><p>Draw samples from the posterior distribution of an estimated model</p></a></li>
<li><a href='#predicted_samples'><p>Draw new response values from the conditional distribution of the response</p></a></li>
<li><a href='#qq_plot'><p>Quantile-quantile plot of model residuals</p></a></li>
<li><a href='#ref_level'><p>Return the reference or specific level of a factor</p></a></li>
<li><a href='#ref_sims'><p>Reference simulation data</p></a></li>
<li><a href='#reorder_fs_smooth_terms'><p>Reorder random factor smooth terms to place factor last</p></a></li>
<li><a href='#reorder_tensor_smooth_terms'><p>Reorder tensor product terms for nicer plotting</p></a></li>
<li><a href='#rep_first_factor_value'><p>Repeat the first level of a factor n times</p></a></li>
<li><a href='#residuals_hist_plot'><p>Histogram of model residuals</p></a></li>
<li><a href='#residuals_linpred_plot'><p>Plot of residuals versus linear predictor values</p></a></li>
<li><a href='#response_derivatives'><p>Derivatives on the response scale from an estimated GAM</p></a></li>
<li><a href='#rootogram'><p>Rootograms to assess goodness of model fit</p></a></li>
<li><a href='#seq_min_max_eps'><p>Create a sequence of evenly-spaced values adjusted to accommodate a</p>
small adjustment</a></li>
<li><a href='#shift_values'><p>Shift numeric values in a data frame by an amount <code>eps</code></p></a></li>
<li><a href='#simulate.gam'><p>Simulate from the posterior distribution of a GAM</p></a></li>
<li><a href='#smallAges'><p>Lead-210 age-depth measurements for Small Water</p></a></li>
<li><a href='#smooth_coef_indices'><p>Indices of the parametric terms for a particular smooth</p></a></li>
<li><a href='#smooth_coefs'><p>Coefficients for a particular smooth</p></a></li>
<li><a href='#smooth_data'><p>Generate regular data over the covariates of a smooth</p></a></li>
<li><a href='#smooth_dim'><p>Dimension of a smooth</p></a></li>
<li><a href='#smooth_estimates'><p>Evaluate smooths at covariate values</p></a></li>
<li><a href='#smooth_label'><p>Extract the label for a smooth used by 'mgcv'</p></a></li>
<li><a href='#smooth_samples'><p>Posterior draws for individual smooths</p></a></li>
<li><a href='#smooth_terms'><p>List the variables involved in smooths</p></a></li>
<li><a href='#smooth_type'><p>Determine the type of smooth and return it n a human readable form</p></a></li>
<li><a href='#smooths'><p>Names of smooths in a GAM</p></a></li>
<li><a href='#spline_values'><p>Evaluate a spline at provided covariate values</p></a></li>
<li><a href='#spline_values2'><p>Evaluate a spline at provided covariate values</p></a></li>
<li><a href='#term_names'><p>Extract names of all variables needed to fit a GAM or a smooth</p></a></li>
<li><a href='#term_variables'><p>Names of variables involved in a specified model term</p></a></li>
<li><a href='#theta'><p>General extractor for additional parameters in mgcv models</p></a></li>
<li><a href='#tidy_basis'><p>A tidy basis representation of a smooth object</p></a></li>
<li><a href='#to_na'><p>Sets the elements of vector to <code>NA</code></p></a></li>
<li><a href='#too_far'><p>Exclude values that lie too far from the support of data</p></a></li>
<li><a href='#too_far_to_na'><p>Set rows of data to <code>NA</code> if the lie too far from a reference set of values</p></a></li>
<li><a href='#transform_fun'><p>Transform estimated values and confidence intervals by applying a function</p></a></li>
<li><a href='#typical_values'><p>Typical values of model covariates</p></a></li>
<li><a href='#user_draws'><p>Handle user-supplied posterior draws</p></a></li>
<li><a href='#variance_comp'><p>Variance components of smooths from smoothness estimates</p></a></li>
<li><a href='#vars_from_label'><p>Returns names of variables from a smooth label</p></a></li>
<li><a href='#which_smooths'><p>Identify a smooth term by its label</p></a></li>
<li><a href='#worm_plot'><p>Worm plot of model residuals</p></a></li>
<li><a href='#zooplankton'><p>Madison lakes zooplankton data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.9.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-26</td>
</tr>
<tr>
<td>Title:</td>
<td>Graceful 'ggplot'-Based Graphics and Other Functions for GAMs
Fitted Using 'mgcv'</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gavin L. Simpson &lt;ucfagls@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>mgcv (&ge; 1.9-0), ggplot2 (&ge; 3.5.0), tibble (&ge; 3.0.0), dplyr
(&ge; 1.1.0), tidyr, rlang, patchwork, vctrs, grid, mvnfast,
purrr, stats, tools, grDevices, stringr, tidyselect (&ge; 1.2.0),
lifecycle, pillar, cli, nlme, ggokabeito, withr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gamm4, lme4, testthat, vdiffr, MASS, scam, datasets, knitr,
rmarkdown, forcats, GJRM, readr, glmmTMB, ggdist,
distributional, hexbin, gamair, sf (&ge; 0.7-3)</td>
</tr>
<tr>
<td>Description:</td>
<td>Graceful 'ggplot'-based graphics and utility functions for working with generalized additive models (GAMs) fitted using the 'mgcv' package. Provides a reimplementation of the plot() method for GAMs that 'mgcv' provides, as well as 'tidyverse' compatible representations of estimated smooths.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gavinsimpson.github.io/gratia/">https://gavinsimpson.github.io/gratia/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gavinsimpson/gratia/issues">https://github.com/gavinsimpson/gratia/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-26 14:38:08 UTC; au690221</td>
</tr>
<tr>
<td>Author:</td>
<td>Gavin L. Simpson <a href="https://orcid.org/0000-0002-9084-8413"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Henrik Singmann <a href="https://orcid.org/0000-0002-4842-3657"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-27 17:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_confint'>Add a confidence interval to an existing object</h2><span id='topic+add_confint'></span><span id='topic+add_confint.smooth_estimates'></span><span id='topic+add_confint.parametric_effects'></span><span id='topic+add_confint.default'></span>

<h3>Description</h3>

<p>Add a confidence interval to an existing object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_confint(object, coverage = 0.95, ...)

## S3 method for class 'smooth_estimates'
add_confint(object, coverage = 0.95, ...)

## S3 method for class 'parametric_effects'
add_confint(object, coverage = 0.95, ...)

## Default S3 method:
add_confint(object, coverage = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_confint_+3A_object">object</code></td>
<td>
<p>a R object.</p>
</td></tr>
<tr><td><code id="add_confint_+3A_coverage">coverage</code></td>
<td>
<p>numeric; the coverage for the interval. Must be in the range
0 &lt; <code>coverage</code> &lt; 1.</p>
</td></tr>
<tr><td><code id="add_confint_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='add_constant'>Add a constant to estimated values</h2><span id='topic+add_constant'></span><span id='topic+add_constant.smooth_estimates'></span><span id='topic+add_constant.smooth_samples'></span><span id='topic+add_constant.mgcv_smooth'></span><span id='topic+add_constant.parametric_effects'></span><span id='topic+add_constant.tbl_df'></span><span id='topic+add_constant.evaluated_parametric_term'></span>

<h3>Description</h3>

<p>Add a constant to estimated values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_constant(object, constant = NULL, ...)

## S3 method for class 'smooth_estimates'
add_constant(object, constant = NULL, ...)

## S3 method for class 'smooth_samples'
add_constant(object, constant = NULL, ...)

## S3 method for class 'mgcv_smooth'
add_constant(object, constant = NULL, ...)

## S3 method for class 'parametric_effects'
add_constant(object, constant = NULL, ...)

## S3 method for class 'tbl_df'
add_constant(object, constant = NULL, column = NULL, ...)

## S3 method for class 'evaluated_parametric_term'
add_constant(object, constant = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_constant_+3A_object">object</code></td>
<td>
<p>a object to add a constant to.</p>
</td></tr>
<tr><td><code id="add_constant_+3A_constant">constant</code></td>
<td>
<p>the constant to add.</p>
</td></tr>
<tr><td><code id="add_constant_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods.</p>
</td></tr>
<tr><td><code id="add_constant_+3A_column">column</code></td>
<td>
<p>character; for the <code>"tbl_df"</code> method, which column to add the
constant too.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>object</code> but with the estimate shifted by the addition of
the supplied constant.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>

<hr>
<h2 id='add_fitted'>Add fitted values from a model to a data frame</h2><span id='topic+add_fitted'></span>

<h3>Description</h3>

<p>Add fitted values from a model to a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_fitted(data, model, value = ".value", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_fitted_+3A_data">data</code></td>
<td>
<p>a data frame containing values for the variables used to fit the
model. Passed to <code><a href="stats.html#topic+predict">stats::predict()</a></code> as <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="add_fitted_+3A_model">model</code></td>
<td>
<p>a fitted model for which a <code><a href="stats.html#topic+predict">stats::predict()</a></code> method is
available. S3 method dispatch is performed on the <code>model</code> argument.</p>
</td></tr>
<tr><td><code id="add_fitted_+3A_value">value</code></td>
<td>
<p>character; the name of the variable in which model predictions
will be stored.</p>
</td></tr>
<tr><td><code id="add_fitted_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame (tibble) formed from <code>data</code> and fitted values from
<code>model</code>.
</p>

<hr>
<h2 id='add_fitted_samples'>Add posterior draws from a model to a data object</h2><span id='topic+add_fitted_samples'></span><span id='topic+add_predicted_samples'></span><span id='topic+add_posterior_samples'></span><span id='topic+add_smooth_samples'></span>

<h3>Description</h3>

<p>Adds draws from the posterior distribution of <code>model</code> to the data <code>object</code>
using one of <code><a href="#topic+fitted_samples">fitted_samples()</a></code>, <code><a href="#topic+predicted_samples">predicted_samples()</a></code>, or
<code><a href="#topic+posterior_samples">posterior_samples()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_fitted_samples(object, model, n = 1, seed = NULL, ...)

add_predicted_samples(object, model, n = 1, seed = NULL, ...)

add_posterior_samples(object, model, n = 1, seed = NULL, ...)

add_smooth_samples(object, model, n = 1, seed = NULL, select = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_fitted_samples_+3A_object">object</code></td>
<td>
<p>a data frame or tibble to which the posterior draws will be
added.</p>
</td></tr>
<tr><td><code id="add_fitted_samples_+3A_model">model</code></td>
<td>
<p>a fitted GAM (or GAM-like) object for which a posterior draw
method exists.</p>
</td></tr>
<tr><td><code id="add_fitted_samples_+3A_n">n</code></td>
<td>
<p>integer; the number of posterior draws to add.</p>
</td></tr>
<tr><td><code id="add_fitted_samples_+3A_seed">seed</code></td>
<td>
<p>numeric; a value to seed the random number generator.</p>
</td></tr>
<tr><td><code id="add_fitted_samples_+3A_...">...</code></td>
<td>
<p>arguments are passed to the posterior draw function, currently one
of <code><a href="#topic+fitted_samples">fitted_samples()</a></code>, <code><a href="#topic+predicted_samples">predicted_samples()</a></code>, or <code><a href="#topic+posterior_samples">posterior_samples()</a></code>. <code>n</code>
and <code>seed</code> are already specified here as arguments and are also passed on
to the posterior sampling function.</p>
</td></tr>
<tr><td><code id="add_fitted_samples_+3A_select">select</code></td>
<td>
<p>character; select which smooth's posterior to draw from. The
default, <code>NULL</code>, means the posteriors of all smooths in model wil be
sampled from individually. If supplied, a character vector of requested
smooth terms.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
load_mgcv()

df &lt;- data_sim("eg1", n = 400, seed = 42)

m &lt;- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = "REML")

# add fitted samples (posterior draws of the expected value of the response)
# note that there are 800 rows in the output: 400 data by `n = 2` samples.
df |&gt;
  add_fitted_samples(m, n = 2, seed = 84)

# add posterior draws from smooth s(x2)
df |&gt;
  add_smooth_samples(m, n = 2, seed = 2, select= "s(x2)")

</code></pre>

<hr>
<h2 id='add_fitted.gam'>Add fitted values from a GAM to a data frame</h2><span id='topic+add_fitted.gam'></span>

<h3>Description</h3>

<p>Add fitted values from a GAM to a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gam'
add_fitted(data, model, value = ".fitted", type = "response", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_fitted.gam_+3A_data">data</code></td>
<td>
<p>a data frame containing values for the variables used to fit the
model. Passed to <code><a href="stats.html#topic+predict">stats::predict()</a></code> as <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="add_fitted.gam_+3A_model">model</code></td>
<td>
<p>a fitted model for which a <code><a href="stats.html#topic+predict">stats::predict()</a></code> method is
available. S3 method dispatch is performed on the <code>model</code> argument.</p>
</td></tr>
<tr><td><code id="add_fitted.gam_+3A_value">value</code></td>
<td>
<p>character; the name of the variable in which model predictions
will be stored.</p>
</td></tr>
<tr><td><code id="add_fitted.gam_+3A_type">type</code></td>
<td>
<p>character; the type of predictions to return. See
<code><a href="mgcv.html#topic+predict.gam">mgcv::predict.gam()</a></code> for options.</p>
</td></tr>
<tr><td><code id="add_fitted.gam_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="mgcv.html#topic+predict.gam">mgcv::predict.gam()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame (tibble) formed from <code>data</code> and predictions from
<code>model</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
load_mgcv()
df &lt;- data_sim("eg1", seed = 1)
df &lt;- df[, c("y", "x0", "x1", "x2", "x3")]
m &lt;- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = "REML")

# add fitted values to our data
add_fitted(df, m)

# with type = "terms" or "iterms"
add_fitted(df, m, type = "terms")

</code></pre>

<hr>
<h2 id='add_partial_residuals'>Add partial residuals</h2><span id='topic+add_partial_residuals'></span><span id='topic+add_partial_residuals.gam'></span>

<h3>Description</h3>

<p>Add partial residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_partial_residuals(data, model, ...)

## S3 method for class 'gam'
add_partial_residuals(data, model, select = NULL, partial_match = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_partial_residuals_+3A_data">data</code></td>
<td>
<p>a data frame containing values for the variables used to fit the
model. Passed to <code><a href="stats.html#topic+residuals">stats::residuals()</a></code> as <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="add_partial_residuals_+3A_model">model</code></td>
<td>
<p>a fitted model for which a <code><a href="stats.html#topic+residuals">stats::residuals()</a></code> method is
available. S3 method dispatch is performed on the <code>model</code> argument.</p>
</td></tr>
<tr><td><code id="add_partial_residuals_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="add_partial_residuals_+3A_select">select</code></td>
<td>
<p>character, logical, or numeric; which smooths to plot. If
<code>NULL</code>, the default, then all model smooths are drawn. Numeric <code>select</code>
indexes the smooths in the order they are specified in the formula and
stored in <code>object</code>. Character <code>select</code> matches the labels for smooths
as shown for example in the output from <code>summary(object)</code>. Logical
<code>select</code> operates as per numeric <code>select</code> in the order that smooths are
stored.</p>
</td></tr>
<tr><td><code id="add_partial_residuals_+3A_partial_match">partial_match</code></td>
<td>
<p>logical; should smooths be selected by partial matches
with <code>select</code>? If <code>TRUE</code>, <code>select</code> can only be a single string to match
against.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()

df &lt;- data_sim("eg1", seed = 1)
df &lt;- df[, c("y", "x0", "x1", "x2", "x3")]
m &lt;- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = "REML")

## add partial residuals
add_partial_residuals(df, m)

## add partial residuals for selected smooths
add_partial_residuals(df, m, select = "s(x0)")

</code></pre>

<hr>
<h2 id='add_residuals'>Add residuals from a model to a data frame</h2><span id='topic+add_residuals'></span>

<h3>Description</h3>

<p>Add residuals from a model to a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_residuals(data, model, value = ".residual", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_residuals_+3A_data">data</code></td>
<td>
<p>a data frame containing values for the variables used to fit the
model. Passed to <code><a href="stats.html#topic+residuals">stats::residuals()</a></code> as <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="add_residuals_+3A_model">model</code></td>
<td>
<p>a fitted model for which a <code><a href="stats.html#topic+residuals">stats::residuals()</a></code> method is
available. S3 method dispatch is performed on the <code>model</code> argument.</p>
</td></tr>
<tr><td><code id="add_residuals_+3A_value">value</code></td>
<td>
<p>character; the name of the variable in which model residuals
will be stored.</p>
</td></tr>
<tr><td><code id="add_residuals_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame (tibble) formed from <code>data</code> and residuals from <code>model</code>.
</p>

<hr>
<h2 id='add_residuals.gam'>Add residuals from a GAM to a data frame</h2><span id='topic+add_residuals.gam'></span>

<h3>Description</h3>

<p>Add residuals from a GAM to a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gam'
add_residuals(data, model, value = ".residual", type = "deviance", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_residuals.gam_+3A_data">data</code></td>
<td>
<p>a data frame containing values for the variables used to fit the
model. Passed to <code><a href="stats.html#topic+predict">stats::predict()</a></code> as <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="add_residuals.gam_+3A_model">model</code></td>
<td>
<p>a fitted model for which a <code><a href="stats.html#topic+predict">stats::predict()</a></code> method is
available. S3 method dispatch is performed on the <code>model</code> argument.</p>
</td></tr>
<tr><td><code id="add_residuals.gam_+3A_value">value</code></td>
<td>
<p>character; the name of the variable in which model predictions
will be stored.</p>
</td></tr>
<tr><td><code id="add_residuals.gam_+3A_type">type</code></td>
<td>
<p>character; the type of residuals to return. See
<code><a href="mgcv.html#topic+residuals.gam">mgcv::residuals.gam()</a></code> for options.</p>
</td></tr>
<tr><td><code id="add_residuals.gam_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="mgcv.html#topic+residuals.gam">mgcv::residuals.gam()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame (tibble) formed from <code>data</code> and residuals from <code>model</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()

df &lt;- data_sim("eg1", seed = 1)
df &lt;- df[, c("y", "x0", "x1", "x2", "x3")]
m &lt;- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = "REML")

##
add_residuals(df, m)

</code></pre>

<hr>
<h2 id='add_sizer'>Add indicators of significant change after SiZeR</h2><span id='topic+add_sizer'></span><span id='topic+add_sizer.derivatives'></span><span id='topic+add_sizer.smooth_estimates'></span>

<h3>Description</h3>

<p>Add indicators of significant change after SiZeR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_sizer(object, type = c("change", "sizer"), ...)

## S3 method for class 'derivatives'
add_sizer(object, type = c("change", "sizer"), ...)

## S3 method for class 'smooth_estimates'
add_sizer(object, type = c("change", "sizer"), derivatives = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_sizer_+3A_object">object</code></td>
<td>
<p>an R object. Currently supported methods are for classes
<code>"derivatives"</code>.</p>
</td></tr>
<tr><td><code id="add_sizer_+3A_type">type</code></td>
<td>
<p>character; <code>"change"</code> adds a single variable to <code>object</code>
indicating where the credible interval on the derivative excludes 0.
<code>"sizer"</code> adds two variables indicating whether the derivative is postive
or negative.</p>
</td></tr>
<tr><td><code id="add_sizer_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
<tr><td><code id="add_sizer_+3A_derivatives">derivatives</code></td>
<td>
<p>an object of class <code>"derivatives"</code>, resulting from a call
to <code><a href="#topic+derivatives">derivatives()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()

df &lt;- data_sim("eg1", n = 400, dist = "normal", scale = 2, seed = 42)
m &lt;- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = "REML")

## first derivatives of all smooths using central finite differences
d &lt;- derivatives(m, type = "central") |&gt;
  add_sizer()

# default adds a .change column
names(d)
</code></pre>

<hr>
<h2 id='appraise'>Model diagnostic plots</h2><span id='topic+appraise'></span><span id='topic+appraise.gam'></span><span id='topic+appraise.lm'></span>

<h3>Description</h3>

<p>Model diagnostic plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>appraise(model, ...)

## S3 method for class 'gam'
appraise(
  model,
  method = c("uniform", "simulate", "normal", "direct"),
  use_worm = FALSE,
  n_uniform = 10,
  n_simulate = 50,
  type = c("deviance", "pearson", "response"),
  n_bins = c("sturges", "scott", "fd"),
  ncol = NULL,
  nrow = NULL,
  guides = "keep",
  level = 0.9,
  ci_col = "black",
  ci_alpha = 0.2,
  point_col = "black",
  point_alpha = 1,
  line_col = "red",
  ...
)

## S3 method for class 'lm'
appraise(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="appraise_+3A_model">model</code></td>
<td>
<p>a fitted model. Currently only class <code>"gam"</code>.</p>
</td></tr>
<tr><td><code id="appraise_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="patchwork.html#topic+wrap_plots">patchwork::wrap_plots()</a></code>.</p>
</td></tr>
<tr><td><code id="appraise_+3A_method">method</code></td>
<td>
<p>character; method used to generate theoretical quantiles. Note
that <code>method = "direct"</code> is deprecated in favour of <code>method = "uniform"</code>.</p>
</td></tr>
<tr><td><code id="appraise_+3A_use_worm">use_worm</code></td>
<td>
<p>logical; should a worm plot be drawn in place of the QQ plot?</p>
</td></tr>
<tr><td><code id="appraise_+3A_n_uniform">n_uniform</code></td>
<td>
<p>numeric; number of times to randomize uniform quantiles
in the direct computation method (<code>method = "direct"</code>) for QQ plots.</p>
</td></tr>
<tr><td><code id="appraise_+3A_n_simulate">n_simulate</code></td>
<td>
<p>numeric; number of data sets to simulate from the estimated
model when using the simulation method (<code>method = "simulate"</code>) for QQ
plots.</p>
</td></tr>
<tr><td><code id="appraise_+3A_type">type</code></td>
<td>
<p>character; type of residuals to use. Only <code>"deviance"</code>,
<code>"response"</code>, and <code>"pearson"</code> residuals are allowed.</p>
</td></tr>
<tr><td><code id="appraise_+3A_n_bins">n_bins</code></td>
<td>
<p>character or numeric; either the number of bins or a string
indicating how to calculate the number of bins.</p>
</td></tr>
<tr><td><code id="appraise_+3A_ncol">ncol</code>, <code id="appraise_+3A_nrow">nrow</code></td>
<td>
<p>numeric; the numbers of rows and columns over which to
spread the plots.</p>
</td></tr>
<tr><td><code id="appraise_+3A_guides">guides</code></td>
<td>
<p>character; one of <code>"keep"</code> (the default), <code>"collect"</code>, or
<code>"auto"</code>. Passed to <code><a href="patchwork.html#topic+plot_layout">patchwork::plot_layout()</a></code></p>
</td></tr>
<tr><td><code id="appraise_+3A_level">level</code></td>
<td>
<p>numeric; the coverage level for QQ plot reference intervals.
Must be strictly <code style="white-space: pre;">&#8288;0 &lt; level &lt; 1&#8288;</code>. Only used with <code>method = "simulate"</code>.</p>
</td></tr>
<tr><td><code id="appraise_+3A_ci_alpha">ci_alpha</code>, <code id="appraise_+3A_ci_col">ci_col</code></td>
<td>
<p>numeric; the level of alpha transparency for the
QQ plot reference interval when <code>method = "simulate"</code>, or points drawn in
plots.</p>
</td></tr>
<tr><td><code id="appraise_+3A_point_col">point_col</code>, <code id="appraise_+3A_point_alpha">point_alpha</code></td>
<td>
<p>colour and transparency used to draw points in
the plots. See <code><a href="graphics.html#topic+par">graphics::par()</a></code> section <strong>Color Specification</strong>. This is
passed to the individual plotting functions, and therefore affects the
points of all plots.</p>
</td></tr>
<tr><td><code id="appraise_+3A_line_col">line_col</code></td>
<td>
<p>colour specification for the 1:1 line in the QQ plot and the
reference line in the residuals vs linear predictor plot.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The wording used in <code><a href="mgcv.html#topic+qq.gam">mgcv::qq.gam()</a></code> uses <em>direct</em> in reference to the
simulated residuals method (<code>method = "simulated"</code>). To avoid confusion,
<code>method = "direct"</code> is deprecated in favour of <code>method = "uniform"</code>.
</p>


<h3>See Also</h3>

<p>The plots are produced by functions <code><a href="#topic+qq_plot">qq_plot()</a></code>,
<code><a href="#topic+residuals_linpred_plot">residuals_linpred_plot()</a></code>, <code><a href="#topic+residuals_hist_plot">residuals_hist_plot()</a></code>,
and <code><a href="#topic+observed_fitted_plot">observed_fitted_plot()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()
## simulate some data...
dat &lt;- data_sim("eg1", n = 400, dist = "normal", scale = 2, seed = 2)
mod &lt;- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat)
## run some basic model checks
appraise(mod, point_col = "steelblue", point_alpha = 0.4)

## To change the theme for all panels use the &amp; operator, for example to
## change the ggplot theme for all panels
library("ggplot2")
appraise(mod,
  point_col = "steelblue", point_alpha = 0.4,
  line_col = "black"
) &amp; theme_minimal()
</code></pre>

<hr>
<h2 id='basis'>Basis expansions for smooths</h2><span id='topic+basis'></span><span id='topic+basis.gam'></span><span id='topic+basis.scam'></span><span id='topic+basis.gamm'></span><span id='topic+basis.list'></span><span id='topic+basis.default'></span>

<h3>Description</h3>

<p>Creates a basis expansion from a definition of a smoother using the syntax
of <em>mgcv</em>'s smooths via <code><a href="mgcv.html#topic+s">mgcv::s()</a></code>., <code><a href="mgcv.html#topic+te">mgcv::te()</a></code>, <code><a href="mgcv.html#topic+te">mgcv::ti()</a></code>, and
<code><a href="mgcv.html#topic+t2">mgcv::t2()</a></code>, or from a fitted GAM(M).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basis(object, ...)

## S3 method for class 'gam'
basis(
  object,
  select = NULL,
  term = deprecated(),
  data = NULL,
  n = 100,
  n_2d = 50,
  n_3d = 16,
  n_4d = 4,
  partial_match = FALSE,
  ...
)

## S3 method for class 'scam'
basis(
  object,
  select = NULL,
  term = deprecated(),
  data = NULL,
  n = 100,
  n_2d = 50,
  n_3d = 16,
  n_4d = 4,
  partial_match = FALSE,
  ...
)

## S3 method for class 'gamm'
basis(
  object,
  select = NULL,
  term = deprecated(),
  data = NULL,
  n = 100,
  n_2d = 50,
  n_3d = 16,
  n_4d = 4,
  partial_match = FALSE,
  ...
)

## S3 method for class 'list'
basis(
  object,
  select = NULL,
  term = deprecated(),
  data = NULL,
  n = 100,
  n_2d = 50,
  n_3d = 16,
  n_4d = 4,
  partial_match = FALSE,
  ...
)

## Default S3 method:
basis(object, data, knots = NULL, constraints = FALSE, at = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basis_+3A_object">object</code></td>
<td>
<p>a smooth specification, the result of a call to one of
<code><a href="mgcv.html#topic+s">mgcv::s()</a></code>., <code><a href="mgcv.html#topic+te">mgcv::te()</a></code>, <code><a href="mgcv.html#topic+te">mgcv::ti()</a></code>, or <code><a href="mgcv.html#topic+t2">mgcv::t2()</a></code>, or a fitted
GAM(M) model.</p>
</td></tr>
<tr><td><code id="basis_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="mgcv.html#topic+smoothCon">mgcv::smoothCon()</a></code>.</p>
</td></tr>
<tr><td><code id="basis_+3A_select">select</code></td>
<td>
<p>character; select smooths in a fitted model</p>
</td></tr>
<tr><td><code id="basis_+3A_term">term</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> This argument has been
renamed <code>select</code></p>
</td></tr>
<tr><td><code id="basis_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables used in <code>smooth</code>.</p>
</td></tr>
<tr><td><code id="basis_+3A_n">n</code></td>
<td>
<p>numeric; the number of points over the range of the covariate at
which to evaluate the smooth.</p>
</td></tr>
<tr><td><code id="basis_+3A_n_2d">n_2d</code></td>
<td>
<p>numeric; the number of new observations for each dimension of a
bivariate smooth. Not currently used; <code>n</code> is used for both dimensions.</p>
</td></tr>
<tr><td><code id="basis_+3A_n_3d">n_3d</code></td>
<td>
<p>numeric; the number of new observations to generate for the third
dimension of a 3D smooth.</p>
</td></tr>
<tr><td><code id="basis_+3A_n_4d">n_4d</code></td>
<td>
<p>numeric; the number of new observations to generate for the
dimensions higher than 2 (!) of a <em>k</em>D smooth (<em>k</em> &gt;= 4). For example, if
the smooth is a 4D smooth, each of dimensions 3 and 4 will get <code>n_4d</code>
new observations.</p>
</td></tr>
<tr><td><code id="basis_+3A_partial_match">partial_match</code></td>
<td>
<p>logical; in the case of character <code>select</code>, should
<code>select</code> match partially against <code>smooths</code>? If <code>partial_match = TRUE</code>,
<code>select</code> must only be a single string, a character vector of length 1.</p>
</td></tr>
<tr><td><code id="basis_+3A_knots">knots</code></td>
<td>
<p>a list or data frame with named components containing
knots locations. Names must match the covariates for which the basis
is required. See <code><a href="mgcv.html#topic+smoothCon">mgcv::smoothCon()</a></code>.</p>
</td></tr>
<tr><td><code id="basis_+3A_constraints">constraints</code></td>
<td>
<p>logical; should identifiability constraints be applied to
the smooth basis. See argument <code>absorb.cons</code> in <code><a href="mgcv.html#topic+smoothCon">mgcv::smoothCon()</a></code>.</p>
</td></tr>
<tr><td><code id="basis_+3A_at">at</code></td>
<td>
<p>a data frame containing values of the smooth covariate(s) at which
the basis should be evaluated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()

df &lt;- data_sim("eg4", n = 400, seed = 42)

bf &lt;- basis(s(x0), data = df)
bf &lt;- basis(s(x2, by = fac, bs = "bs"), data = df, constraints = TRUE)

</code></pre>

<hr>
<h2 id='basis_size'>Extract basis dimension of a smooth</h2><span id='topic+basis_size'></span><span id='topic+basis_size.mgcv.smooth'></span><span id='topic+basis_size.gam'></span><span id='topic+basis_size.gamm'></span>

<h3>Description</h3>

<p>Extract basis dimension of a smooth
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basis_size(object, ...)

## S3 method for class 'mgcv.smooth'
basis_size(object, ...)

## S3 method for class 'gam'
basis_size(object, ...)

## S3 method for class 'gamm'
basis_size(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basis_size_+3A_object">object</code></td>
<td>
<p>A fitted GAM(M). Currently <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code> (and anything that
inherits from the <code>"gam"</code> class, e.g. <code><a href="mgcv.html#topic+bam">mgcv::bam()</a></code>) and <code><a href="mgcv.html#topic+gamm">mgcv::gamm()</a></code> are
supported.</p>
</td></tr>
<tr><td><code id="basis_size_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()

df &lt;- data_sim("eg1", n = 200, seed = 1)
m &lt;- bam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df)

basis_size(m)
</code></pre>

<hr>
<h2 id='bird_move'>Simulated bird migration data</h2><span id='topic+bird_move'></span>

<h3>Description</h3>

<p>Data generated from a hypothetical study of bird movement along a migration
corridor, sampled throughout the year. This dataset consists of simulated
sample records of numbers of observed locations of 100 tagged individuals
each from six species of bird, at ten locations along a latitudinal gradient,
with one observation taken every four weeks. Counts were simulated randomly
for each species in each location and week by creating a species-specific
migration curve that gave the probability of finding an individual of a
given species in a given location, then simulated the distribution of
individuals across sites using a multinomial distribution, and subsampling
that using a binomial distribution to simulation observation error (i.e.
not every bird present at a location would be detected). The data set
(<code>bird_move</code>) consists of the variables <code>count</code>, <code>latitude</code>, <code>week</code> and
<code>species</code>.
</p>


<h3>Format</h3>

<p>A data frame
</p>


<h3>Source</h3>

<p>Pedersen EJ, Miller DL, Simpson GL, Ross N. 2018. Hierarchical
generalized additive models: an introduction with mgcv. <em>PeerJ Preprints</em>
<strong>6</strong>:e27320v1 <a href="https://doi.org/10.7287/peerj.preprints.27320v1">doi:10.7287/peerj.preprints.27320v1</a>.
</p>

<hr>
<h2 id='boundary'>Extract the boundary of a soap film smooth</h2><span id='topic+boundary'></span><span id='topic+boundary.soap.film'></span><span id='topic+boundary.gam'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boundary(x, ...)

## S3 method for class 'soap.film'
boundary(x, ...)

## S3 method for class 'gam'
boundary(x, select, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boundary_+3A_x">x</code></td>
<td>
<p>an R object. Currently only objects that inherit from classes
<code>"soap.film"</code> and <code>"gam"</code>.</p>
</td></tr>
<tr><td><code id="boundary_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="boundary_+3A_select">select</code></td>
<td>
<p>character; the label of the soap film smooth from which to
extract the boundary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of lists or data frames specifying the loops that define the
boundary of the soap film smooth.
</p>


<h3>See Also</h3>

<p><a href="mgcv.html#topic+smooth.construct.so.smooth.spec">mgcv::soap</a>
</p>

<hr>
<h2 id='check_user_select_smooths'>Select smooths based on user's choices</h2><span id='topic+check_user_select_smooths'></span>

<h3>Description</h3>

<p>Given a vector indexing the smooths of a GAM, returns a logical
vector selecting the requested smooths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_user_select_smooths(
  smooths,
  select = NULL,
  partial_match = FALSE,
  model_name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_user_select_smooths_+3A_smooths">smooths</code></td>
<td>
<p>character; a vector of smooth labels.</p>
</td></tr>
<tr><td><code id="check_user_select_smooths_+3A_select">select</code></td>
<td>
<p>numeric, logical, or character vector of selected smooths.</p>
</td></tr>
<tr><td><code id="check_user_select_smooths_+3A_partial_match">partial_match</code></td>
<td>
<p>logical; in the case of character <code>select</code>, should
<code>select</code> match partially against <code>smooths</code>? If <code>partial_match = TRUE</code>,
<code>select</code> must only be a single string, a character vector of length 1.</p>
</td></tr>
<tr><td><code id="check_user_select_smooths_+3A_model_name">model_name</code></td>
<td>
<p>character; a model name that will be used in error
messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector the same length as <code>length(smooths)</code> indicating
which smooths have been selected.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>

<hr>
<h2 id='coef.scam'>Extract coefficients from a fitted <code>scam</code> model.</h2><span id='topic+coef.scam'></span>

<h3>Description</h3>

<p>Extract coefficients from a fitted <code>scam</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scam'
coef(object, parametrized = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.scam_+3A_object">object</code></td>
<td>
<p>a model object fitted by <code>scam()</code></p>
</td></tr>
<tr><td><code id="coef.scam_+3A_parametrized">parametrized</code></td>
<td>
<p>logical; extract parametrized coefficients, which
respect the linear inequality constraints of the model.</p>
</td></tr>
<tr><td><code id="coef.scam_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>

<hr>
<h2 id='compare_smooths'>Compare smooths across models</h2><span id='topic+compare_smooths'></span>

<h3>Description</h3>

<p>Compare smooths across models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_smooths(
  model,
  ...,
  select = NULL,
  smooths = deprecated(),
  n = 100,
  data = NULL,
  unconditional = FALSE,
  overall_uncertainty = TRUE,
  partial_match = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_smooths_+3A_model">model</code></td>
<td>
<p>Primary model for comparison.</p>
</td></tr>
<tr><td><code id="compare_smooths_+3A_...">...</code></td>
<td>
<p>Additional models to compare smooths against those of <code>model</code>.</p>
</td></tr>
<tr><td><code id="compare_smooths_+3A_select">select</code></td>
<td>
<p>character; select which smooths to compare. The default
(<code>NULL</code>) means all smooths in <code>model</code> will be compared. Numeric <code>select</code>
indexes the smooths in the order they are specified in the formula and
stored in <code>model</code>. Character <code>select</code> matches the labels for smooths
as shown for example in the output from <code>summary(object)</code>. Logical
<code>select</code> operates as per numeric <code>select</code> in the order that smooths are
stored.</p>
</td></tr>
<tr><td><code id="compare_smooths_+3A_smooths">smooths</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>select</code> instead.</p>
</td></tr>
<tr><td><code id="compare_smooths_+3A_n">n</code></td>
<td>
<p>numeric; the number of points over the range of the covariate at
which to evaluate the smooth.</p>
</td></tr>
<tr><td><code id="compare_smooths_+3A_data">data</code></td>
<td>
<p>a data frame of covariate values at which to evaluate the
smooth.</p>
</td></tr>
<tr><td><code id="compare_smooths_+3A_unconditional">unconditional</code></td>
<td>
<p>logical; should confidence intervals include the
uncertainty due to smoothness selection? If <code>TRUE</code>, the corrected Bayesian
covariance matrix will be used.</p>
</td></tr>
<tr><td><code id="compare_smooths_+3A_overall_uncertainty">overall_uncertainty</code></td>
<td>
<p>logical; should the uncertainty in the model
constant term be included in the standard error of the evaluate values of
the smooth?</p>
</td></tr>
<tr><td><code id="compare_smooths_+3A_partial_match">partial_match</code></td>
<td>
<p>logical; should smooths be selected by partial matches
with <code>select</code>? If <code>TRUE</code>, <code>select</code> can only be a single string to match
against.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
load_mgcv()
dat &lt;- data_sim("eg1", seed = 2)

## models to compare smooths across - artificially create differences
m1 &lt;- gam(y ~ s(x0, k = 5) + s(x1, k = 5) + s(x2, k = 5) + s(x3, k = 5),
  data = dat, method = "REML"
)
m2 &lt;- gam(y ~ s(x0, bs = "ts") + s(x1, bs = "ts") + s(x2, bs = "ts") +
  s(x3, bs = "ts"), data = dat, method = "REML")

## build comparisons
comp &lt;- compare_smooths(m1, m2)
comp
## notice that the result is a nested tibble

draw(comp)

</code></pre>

<hr>
<h2 id='confint.fderiv'>Point-wise and simultaneous confidence intervals for derivatives of smooths</h2><span id='topic+confint.fderiv'></span>

<h3>Description</h3>

<p>Calculates point-wise confidence or simultaneous intervals for the first
derivatives of smooth terms in a fitted GAM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fderiv'
confint(
  object,
  parm,
  level = 0.95,
  type = c("confidence", "simultaneous"),
  nsim = 10000,
  ncores = 1L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.fderiv_+3A_object">object</code></td>
<td>
<p>an object of class <code>"fderiv"</code> containing the estimated
derivatives.</p>
</td></tr>
<tr><td><code id="confint.fderiv_+3A_parm">parm</code></td>
<td>
<p>which parameters (smooth terms) are to be given intervals as a
vector of terms. If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="confint.fderiv_+3A_level">level</code></td>
<td>
<p>numeric, <code style="white-space: pre;">&#8288;0 &lt; level &lt; 1&#8288;</code>; the confidence level of the
point-wise or simultaneous interval. The default is <code>0.95</code> for a 95%
interval.</p>
</td></tr>
<tr><td><code id="confint.fderiv_+3A_type">type</code></td>
<td>
<p>character; the type of interval to compute. One of <code>"confidence"</code>
for point-wise intervals, or <code>"simultaneous"</code> for simultaneous intervals.</p>
</td></tr>
<tr><td><code id="confint.fderiv_+3A_nsim">nsim</code></td>
<td>
<p>integer; the number of simulations used in computing the
simultaneous intervals.</p>
</td></tr>
<tr><td><code id="confint.fderiv_+3A_ncores">ncores</code></td>
<td>
<p>number of cores for generating random variables from a
multivariate normal distribution. Passed to <code><a href="mvnfast.html#topic+rmvn">mvnfast::rmvn()</a></code>.
Parallelization will take place only if OpenMP is supported (but appears
to work on Windows with current <code>R</code>).</p>
</td></tr>
<tr><td><code id="confint.fderiv_+3A_...">...</code></td>
<td>
<p>additional arguments for methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with components:
</p>

<ol>
<li> <p><code>term</code>; factor indicating to which term each row relates,
</p>
</li>
<li> <p><code>lower</code>; lower limit of the confidence or simultaneous interval,
</p>
</li>
<li> <p><code>est</code>; estimated derivative
</p>
</li>
<li> <p><code>upper</code>; upper limit of the confidence or simultaneous interval.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()

dat &lt;- data_sim("eg1", n = 1000, dist = "normal", scale = 2, seed = 2)
mod &lt;- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")

# new data to evaluate the derivatives at, say over the middle 50% of range
# of each covariate
middle &lt;- function(x, n = 25, coverage = 0.5) {
  v &lt;- (1 - coverage) / 2
  q &lt;- quantile(x, prob = c(0 + v, 1 - v), type = 8)
  seq(q[1], q[2], length = n)
}
new_data &lt;- sapply(dat[c("x0", "x1", "x2", "x3")], middle)
new_data &lt;- data.frame(new_data)
## first derivatives of all smooths...
fd &lt;- fderiv(mod, newdata = new_data)

## point-wise interval
ci &lt;- confint(fd, type = "confidence")
ci

## simultaneous interval for smooth term of x2

x2_sint &lt;- confint(fd,
  parm = "x2", type = "simultaneous",
  nsim = 10000, ncores = 2
)

x2_sint


</code></pre>

<hr>
<h2 id='confint.gam'>Point-wise and simultaneous confidence intervals for smooths</h2><span id='topic+confint.gam'></span><span id='topic+confint.gamm'></span><span id='topic+confint.list'></span>

<h3>Description</h3>

<p>Calculates point-wise confidence or simultaneous intervals for the smooth
terms of a fitted GAM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gam'
confint(
  object,
  parm,
  level = 0.95,
  data = newdata,
  n = 100,
  type = c("confidence", "simultaneous"),
  nsim = 10000,
  shift = FALSE,
  transform = FALSE,
  unconditional = FALSE,
  ncores = 1,
  partial_match = FALSE,
  ...,
  newdata = NULL
)

## S3 method for class 'gamm'
confint(object, ...)

## S3 method for class 'list'
confint(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.gam_+3A_object">object</code></td>
<td>
<p>an object of class <code>"gam"</code> or <code>"gamm"</code>.</p>
</td></tr>
<tr><td><code id="confint.gam_+3A_parm">parm</code></td>
<td>
<p>which parameters (smooth terms) are to be given intervals as a
vector of terms. If missing, all parameters are considered, although this
is not currently implemented.</p>
</td></tr>
<tr><td><code id="confint.gam_+3A_level">level</code></td>
<td>
<p>numeric, <code style="white-space: pre;">&#8288;0 &lt; level &lt; 1&#8288;</code>; the confidence level of the point-wise
or simultaneous interval. The default is <code>0.95</code> for a 95% interval.</p>
</td></tr>
<tr><td><code id="confint.gam_+3A_data">data</code></td>
<td>
<p>data frame; new values of the covariates used in the model fit.
The selected smooth(s) wil be evaluated at the supplied values.</p>
</td></tr>
<tr><td><code id="confint.gam_+3A_n">n</code></td>
<td>
<p>numeric; the number of points to evaluate smooths at.</p>
</td></tr>
<tr><td><code id="confint.gam_+3A_type">type</code></td>
<td>
<p>character; the type of interval to compute. One of <code>"confidence"</code>
for point-wise intervals, or <code>"simultaneous"</code> for simultaneous intervals.</p>
</td></tr>
<tr><td><code id="confint.gam_+3A_nsim">nsim</code></td>
<td>
<p>integer; the number of simulations used in computing the
simultaneous intervals.</p>
</td></tr>
<tr><td><code id="confint.gam_+3A_shift">shift</code></td>
<td>
<p>logical; should the constant term be add to the smooth?</p>
</td></tr>
<tr><td><code id="confint.gam_+3A_transform">transform</code></td>
<td>
<p>logical; should the smooth be evaluated on a transformed
scale? For generalised models, this involves applying the inverse of the
link function used to fit the model. Alternatively, the name of, or an
actual, function can be supplied to transform the smooth and it's
confidence interval.</p>
</td></tr>
<tr><td><code id="confint.gam_+3A_unconditional">unconditional</code></td>
<td>
<p>logical; if <code>TRUE</code> (and <code>freq == FALSE</code>) then the
Bayesian smoothing parameter uncertainty corrected covariance matrix is
returned, if available.</p>
</td></tr>
<tr><td><code id="confint.gam_+3A_ncores">ncores</code></td>
<td>
<p>number of cores for generating random variables from a
multivariate normal distribution. Passed to <code><a href="mvnfast.html#topic+rmvn">mvnfast::rmvn()</a></code>.
Parallelization will take place only if OpenMP is supported (but appears
to work on Windows with current <code>R</code>).</p>
</td></tr>
<tr><td><code id="confint.gam_+3A_partial_match">partial_match</code></td>
<td>
<p>logical; should matching <code>parm</code> use a partial match or
an exact match? Can only be used if <code>length(parm)</code> is <code>1</code>.</p>
</td></tr>
<tr><td><code id="confint.gam_+3A_...">...</code></td>
<td>
<p>additional arguments for methods</p>
</td></tr>
<tr><td><code id="confint.gam_+3A_newdata">newdata</code></td>
<td>
<p>DEPRECATED! data frame; containing new values of the
covariates used in the model fit. The selected smooth(s) wil be evaluated
at the supplied values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble with components:
</p>

<ol>
<li> <p><code>.smooth</code>; character indicating to which term each row relates,
</p>
</li>
<li> <p><code>.type</code>; the type of smooth,
</p>
</li>
<li> <p><code>.by</code> the name of the by variable if a by smooth, <code>NA</code> otherwise,
</p>
</li>
<li><p> one or more vectors of values at which the smooth was evaluated, named as
per the variables in the smooth,
</p>
</li>
<li><p> zero or more variables containing values of the by variable,
</p>
</li>
<li> <p><code>.estimate</code>; estimated value of the smooth,
</p>
</li>
<li> <p><code>.se</code>; standard error of the estimated value of the smooth,
</p>
</li>
<li> <p><code>.crit</code>; critical value for the <code>100 * level</code>% confidence interval.
</p>
</li>
<li> <p><code>.lower_ci</code>; lower limit of the confidence or simultaneous interval,
</p>
</li>
<li> <p><code>.upper_ci</code>; upper limit of the confidence or simultaneous interval,
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()

dat &lt;- data_sim("eg1", n = 1000, dist = "normal", scale = 2, seed = 2)
mod &lt;- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")

# new data to evaluate the smooths at, say over the middle 50% of range
# of each covariate
middle &lt;- function(x, n = 50, coverage = 0.5) {
  v &lt;- (1 - coverage) / 2
  q &lt;- quantile(x, prob = c(0 + v, 1 - v), type = 8)
  seq(q[1], q[2], length = n)
}
new_data &lt;- sapply(dat[c("x0", "x1", "x2", "x3")], middle)
new_data &lt;- data.frame(new_data)

## point-wise interval for smooth of x2
ci &lt;- confint(mod, parm = "s(x2)", type = "confidence", data = new_data)
ci

</code></pre>

<hr>
<h2 id='data_combos'>All combinations of factor levels plus typical values of continuous variables</h2><span id='topic+data_combos'></span><span id='topic+data_combos.gam'></span>

<h3>Description</h3>

<p>All combinations of factor levels plus typical values of continuous variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_combos(object, ...)

## S3 method for class 'gam'
data_combos(
  object,
  vars = everything(),
  complete = TRUE,
  envir = environment(formula(object)),
  data = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_combos_+3A_object">object</code></td>
<td>
<p>a fitted model object.</p>
</td></tr>
<tr><td><code id="data_combos_+3A_...">...</code></td>
<td>
<p>arguments passed to methods.</p>
</td></tr>
<tr><td><code id="data_combos_+3A_vars">vars</code></td>
<td>
<p>terms to include or exclude from the returned object. Uses
tidyselect principles.</p>
</td></tr>
<tr><td><code id="data_combos_+3A_complete">complete</code></td>
<td>
<p>logical; should all combinations of factor levels be
returned? If <code>FALSE</code>, only those combinations of levels observed in the
model are retained.</p>
</td></tr>
<tr><td><code id="data_combos_+3A_envir">envir</code></td>
<td>
<p>the environment within which to recreate the data used to fit
<code>object</code>.</p>
</td></tr>
<tr><td><code id="data_combos_+3A_data">data</code></td>
<td>
<p>an optional data frame of data used to fit the mdoel if
reconstruction of the data from the model doesn't work.</p>
</td></tr>
</table>

<hr>
<h2 id='data_sim'>Simulate example data for fitting GAMs</h2><span id='topic+data_sim'></span>

<h3>Description</h3>

<p>A tidy reimplementation of the functions implemented in <code><a href="mgcv.html#topic+gamSim">mgcv::gamSim()</a></code>
that can be used to fit GAMs. An new feature is that the sampling
distribution can be applied to all the example types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_sim(
  model = "eg1",
  n = 400,
  scale = NULL,
  theta = 3,
  power = 1.5,
  dist = c("normal", "poisson", "binary", "negbin", "tweedie", "gamma", "ocat",
    "ordered categorical"),
  n_cat = 4,
  cuts = c(-1, 0, 5),
  seed = NULL,
  gfam_families = c("binary", "tweedie", "normal")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_sim_+3A_model">model</code></td>
<td>
<p>character; either <code>"egX"</code> where <code>X</code> is an integer <code>1:7</code>, or
the name of a model. See Details for possible options.</p>
</td></tr>
<tr><td><code id="data_sim_+3A_n">n</code></td>
<td>
<p>numeric; the number of observations to simulate.</p>
</td></tr>
<tr><td><code id="data_sim_+3A_scale">scale</code></td>
<td>
<p>numeric; the level of noise to use.</p>
</td></tr>
<tr><td><code id="data_sim_+3A_theta">theta</code></td>
<td>
<p>numeric; the dispersion parameter <code class="reqn">\theta</code> to use. The
default is entirely arbitrary, chosen only to provide simulated data that
exhibits extra dispersion beyond that assumed by under a Poisson.</p>
</td></tr>
<tr><td><code id="data_sim_+3A_power">power</code></td>
<td>
<p>numeric; the Tweedie power parameter.</p>
</td></tr>
<tr><td><code id="data_sim_+3A_dist">dist</code></td>
<td>
<p>character; a sampling distribution for the response
variable. <code>"ordered categorical"</code> is a synonym of <code>"ocat"</code>.</p>
</td></tr>
<tr><td><code id="data_sim_+3A_n_cat">n_cat</code></td>
<td>
<p>integer; the number of categories for categorical response.
Currently only used for <code>distr %in% c("ocat", "ordered categorical")</code>.</p>
</td></tr>
<tr><td><code id="data_sim_+3A_cuts">cuts</code></td>
<td>
<p>numeric; vector of cut points on the latent variable, excluding
the end points <code>-Inf</code> and <code>Inf</code>. Must be one fewer than the number of
categories: <code>length(cuts) == n_cat - 1</code>.</p>
</td></tr>
<tr><td><code id="data_sim_+3A_seed">seed</code></td>
<td>
<p>numeric; the seed for the random number generator. Passed to
<code><a href="base.html#topic+Random">base::set.seed()</a></code>.</p>
</td></tr>
<tr><td><code id="data_sim_+3A_gfam_families">gfam_families</code></td>
<td>
<p>character; a vector of distributions to use in
generating data with grouped families for use with <code>family = gfam()</code>. The
allowed distributions as as per <code>dist</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>data_sim()</code> can simulate data from several underlying models of
known true functions. The available options currently are:
</p>

<ul>
<li> <p><code>"eg1"</code>: a four term additive true model. This is the classic Gu &amp; Wahba
four univariate term test model. See <code><a href="#topic+gw_functions">gw_functions</a></code> for more details of
the underlying four functions.
</p>
</li>
<li> <p><code>"eg2"</code>: a bivariate smooth true model.
</p>
</li>
<li> <p><code>"eg3"</code>: an example containing a continuous by smooth (varying
coefficient) true model. The model is <code class="reqn">\hat{y}_i = f_2(x_{1i})x_{2i}</code> where the function <code class="reqn">f_2()</code> is <code class="reqn">f_2(x) = 0.2 * x^{11} *
(10 * (1 - x))^6 + 10 * (10 * x)^3 * (1 - x)^{10}</code>.
</p>
</li>
<li> <p><code>"eg4"</code>: a factor by smooth true model. The true model contains a factor
with 3 levels, where the response for the <em>n</em>th level follows the <em>n</em>th
Gu &amp; Wabha function (for <code class="reqn">n \in {1, 2, 3}</code>).
</p>
</li>
<li> <p><code>"eg5"</code>: an additive plus factor true model. The response is a linear
combination of the Gu &amp; Wabha functions 2, 3, 4 (the latter is a null
function) plus a factor term with four levels.
</p>
</li>
<li> <p><code>"eg6"</code>: an additive plus random effect term true model.
</p>
</li>
<li><p> ´&quot;eg7&quot;<code style="white-space: pre;">&#8288;: a version of the model in &#8288;</code>&quot;eg1&quot;', but where the covariates are
correlated.
</p>
</li>
<li> <p><code>"gwf2"</code>: a model where the response is Gu &amp; Wabha's
<code class="reqn">f_2(x_i)</code> plus noise.
</p>
</li>
<li> <p><code>"lwf6"</code>: a model where the response is Luo &amp; Wabha's &quot;example 6&quot;
function <code class="reqn">sin(2(4x-2)) + 2 exp(-256(x-0.5)^2)</code> plus noise.
</p>
</li>
<li> <p><code>"gfam"</code>: simulates data for use with GAMs with
<code>family = gfam(families)</code>. See example in <code><a href="mgcv.html#topic+gfam">mgcv::gfam()</a></code>. If this model
is specified then <code>dist</code> is ignored and <code>gfam_families</code> is used to
specify which distributions are included in the simulated data. Can be a
vector of any of the families allowed by <code>dist</code>. For
<code>"ocat" %in% gfam_families</code> (or <code>"ordered categorical"</code>), 4 classes are
assumed, which can't be changed. Link functions used are <code>"identity"</code>
for <code>"normal"</code>, <code>"logit"</code> for <code>"binary"</code>, <code>"ocat"</code>, and
<code>"ordered categorical"</code>, and <code>"exp"</code> elsewhere.
</p>
</li></ul>

<p>The random component providing noise or sampling variation can follow one
of the distributions, specified via argument <code>dist</code>
</p>

<ul>
<li> <p><code>"normal"</code>: Gaussian,
</p>
</li>
<li> <p><code>"poisson"</code>: Poisson,
</p>
</li>
<li> <p><code>"binary"</code>: Bernoulli,
</p>
</li>
<li> <p><code>"negbin"</code>: Negative binomial,
</p>
</li>
<li> <p><code>"tweedie"</code>: Tweedie,
</p>
</li>
<li> <p><code>"gamma"</code>: gamma , and
</p>
</li>
<li> <p><code>"ordered categorical"</code>: ordered categorical
</p>
</li></ul>

<p>Other arguments provide the parameters for the distribution.
</p>


<h3>References</h3>

<p>Gu, C., Wahba, G., (1993). Smoothing Spline ANOVA with Component-Wise
Bayesian &quot;Confidence Intervals.&quot; <em>J. Comput. Graph. Stat.</em> <strong>2</strong>, 97–117.
</p>
<p>Luo, Z., Wahba, G., (1997). Hybrid adaptive splines. <em>J. Am. Stat. Assoc.</em>
<strong>92</strong>, 107–116.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data_sim("eg1", n = 100, seed = 1)

# an ordered categorical response
data_sim("eg1", n = 100, dist = "ocat", n_cat = 4, cuts = c(-1, 0, 5))

</code></pre>

<hr>
<h2 id='data_slice'>Prepare a data slice through model covariates</h2><span id='topic+data_slice'></span><span id='topic+data_slice.default'></span><span id='topic+data_slice.data.frame'></span><span id='topic+data_slice.gam'></span><span id='topic+data_slice.gamm'></span><span id='topic+data_slice.list'></span><span id='topic+data_slice.scam'></span>

<h3>Description</h3>

<p>Prepare a data slice through model covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_slice(object, ...)

## Default S3 method:
data_slice(object, ...)

## S3 method for class 'data.frame'
data_slice(object, ...)

## S3 method for class 'gam'
data_slice(object, ..., data = NULL, envir = NULL)

## S3 method for class 'gamm'
data_slice(object, ...)

## S3 method for class 'list'
data_slice(object, ...)

## S3 method for class 'scam'
data_slice(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_slice_+3A_object">object</code></td>
<td>
<p>an R model object.</p>
</td></tr>
<tr><td><code id="data_slice_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>&gt; User supplied variables
defining the data slice. Arguments passed via <code>...</code> need to <em>named</em></p>
</td></tr>
<tr><td><code id="data_slice_+3A_data">data</code></td>
<td>
<p>an alternative data frame of values containing all the variables
needed to fit the model. If <code>NULL</code>, the default, the data used to fit the
model will be recovered using <code>model.frame</code>. User-supplied expressions
passed in <code>...</code> will be evaluated in <code>data</code>.</p>
</td></tr>
<tr><td><code id="data_slice_+3A_envir">envir</code></td>
<td>
<p>the environment within which to recreate the data used to fit
<code>object</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
load_mgcv()

# simulate some Gaussian data
df &lt;- data_sim("eg1", n = 50, seed = 2)

# fit a GAM with 1 smooth and 1 linear term
m &lt;- gam(y ~ s(x2, k = 7) + x1, data = df, method = "REML")

# Want to predict over f(x2) while holding `x1` at some value.
# Default will use the observation closest to the median for unspecified
# variables.
ds &lt;- data_slice(m, x2 = evenly(x2, n = 50))
ds

# for full control, specify the values you want
ds &lt;- data_slice(m, x2 = evenly(x2, n = 50), x1 = 0.3)

# or provide an expression (function call) which will be evaluated in the
# data frame passed to `data` or `model.frame(object)`
ds &lt;- data_slice(m, x2 = evenly(x2, n = 50), x1 = mean(x1))
</code></pre>

<hr>
<h2 id='datagen'>Generate data over the range of variables used in smooths</h2><span id='topic+datagen'></span><span id='topic+datagen.mgcv.smooth'></span><span id='topic+datagen.fs.interaction'></span><span id='topic+datagen.gam'></span><span id='topic+datagen.gamm'></span><span id='topic+datagen.list'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>For each smooth in a GAM, generate new data over the range of the variables
involved in a smooth. This function is deprecated as it is only useful for a
very narrow use-case. Use <code><a href="#topic+data_slice">data_slice()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datagen(x, ...)

## S3 method for class 'mgcv.smooth'
datagen(x, n = 100, data, ...)

## S3 method for class 'fs.interaction'
datagen(x, n = 100, data, ...)

## S3 method for class 'gam'
datagen(x, smooth = NULL, n = 200, ...)

## S3 method for class 'gamm'
datagen(x, ...)

## S3 method for class 'list'
datagen(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datagen_+3A_x">x</code></td>
<td>
<p>an object for which new data is required. Currently objects of
classes <code>"gam"</code>, and <code>"gamm"</code> are supported, as are smooths from <strong>mgcv</strong>
inheriting from class <code>"mgcv.smooth"</code>.</p>
</td></tr>
<tr><td><code id="datagen_+3A_...">...</code></td>
<td>
<p>arguments passed to methods</p>
</td></tr>
<tr><td><code id="datagen_+3A_n">n</code></td>
<td>
<p>numeric; the number of data values to generate per term in each
smooth.</p>
</td></tr>
<tr><td><code id="datagen_+3A_data">data</code></td>
<td>
<p>data frame; for <code>"mgcv.smooth"</code> objects, the data used to fit
the GAM need to be supplied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of new values spread over the range of the
observed values.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>

<hr>
<h2 id='derivative_samples'>Posterior expectations of derivatives from an estimated model</h2><span id='topic+derivative_samples'></span><span id='topic+derivative_samples.default'></span><span id='topic+derivative_samples.gamm'></span><span id='topic+derivative_samples.gam'></span>

<h3>Description</h3>

<p>Posterior expectations of derivatives from an estimated model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derivative_samples(object, ...)

## Default S3 method:
derivative_samples(object, ...)

## S3 method for class 'gamm'
derivative_samples(object, ...)

## S3 method for class 'gam'
derivative_samples(
  object,
  focal = NULL,
  data = NULL,
  order = 1L,
  type = c("forward", "backward", "central"),
  scale = c("response", "linear_predictor"),
  method = c("gaussian", "mh", "inla", "user"),
  n = 100,
  eps = 1e-07,
  n_sim = 10000,
  level = 0.95,
  seed = NULL,
  envir = environment(formula(object)),
  draws = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derivative_samples_+3A_object">object</code></td>
<td>
<p>an R object to compute derivatives for</p>
</td></tr>
<tr><td><code id="derivative_samples_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods and on to <code>fitted_samples()</code></p>
</td></tr>
<tr><td><code id="derivative_samples_+3A_focal">focal</code></td>
<td>
<p>character; name of the focal variable. The response derivative
of the response with respect to this variable will be returned.
All other variables involved in the model will be held at constant values.
This can be missing if supplying <code>data</code>, in which case, the focal variable
will be identified as the one variable that is not constant.</p>
</td></tr>
<tr><td><code id="derivative_samples_+3A_data">data</code></td>
<td>
<p>a data frame containing the values of the model covariates
at which to evaluate the first derivatives of the smooths. If supplied,
all but one variable must be held at a constant value.</p>
</td></tr>
<tr><td><code id="derivative_samples_+3A_order">order</code></td>
<td>
<p>numeric; the order of derivative.</p>
</td></tr>
<tr><td><code id="derivative_samples_+3A_type">type</code></td>
<td>
<p>character; the type of finite difference used. One of
<code>"forward"</code>, <code>"backward"</code>, or <code>"central"</code>.</p>
</td></tr>
<tr><td><code id="derivative_samples_+3A_scale">scale</code></td>
<td>
<p>character; should the derivative be estimated on the response
or the linear predictor (link) scale? One of <code>"response"</code> (the default),
or <code>"linear predictor"</code>.</p>
</td></tr>
<tr><td><code id="derivative_samples_+3A_method">method</code></td>
<td>
<p>character; which method should be used to draw samples from
the posterior distribution. <code>"gaussian"</code> uses a Gaussian (Laplace)
approximation to the posterior. <code>"mh"</code> uses a Metropolis Hastings sample
that alternates t proposals with proposals based on a shrunken version of
the posterior covariance matrix. <code>"inla"</code> uses a variant of Integrated
Nested Laplace Approximation due to Wood (2019), (currently not
implemented). <code>"user"</code> allows for user-supplied posterior draws
(currently not implemented).</p>
</td></tr>
<tr><td><code id="derivative_samples_+3A_n">n</code></td>
<td>
<p>numeric; the number of points to evaluate the derivative at (if
<code>data</code> is not supplied).</p>
</td></tr>
<tr><td><code id="derivative_samples_+3A_eps">eps</code></td>
<td>
<p>numeric; the finite difference.</p>
</td></tr>
<tr><td><code id="derivative_samples_+3A_n_sim">n_sim</code></td>
<td>
<p>integer; the number of simulations used in computing the
simultaneous intervals.</p>
</td></tr>
<tr><td><code id="derivative_samples_+3A_level">level</code></td>
<td>
<p>numeric; <code style="white-space: pre;">&#8288;0 &lt; level &lt; 1&#8288;</code>; the coverage level of the
credible interval. The default is <code>0.95</code> for a 95% interval.</p>
</td></tr>
<tr><td><code id="derivative_samples_+3A_seed">seed</code></td>
<td>
<p>numeric; a random seed for the simulations.</p>
</td></tr>
<tr><td><code id="derivative_samples_+3A_envir">envir</code></td>
<td>
<p>the environment within which to recreate the data used to fit
<code>object</code>.</p>
</td></tr>
<tr><td><code id="derivative_samples_+3A_draws">draws</code></td>
<td>
<p>matrix; user supplied posterior draws to be used when
<code>method = "user"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble, currently with the following variables:
</p>

<ul>
<li> <p><code>.derivative</code>: the estimated partial derivative,
</p>
</li>
<li><p> additional columns containing the covariate values at which the derivative
was evaluated.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
load_mgcv()
df &lt;- data_sim("eg1", dist = "negbin", scale = 0.25, seed = 42)

# fit the GAM (note: for execution time reasons using bam())
m &lt;- bam(y ~ s(x0) + s(x1) + s(x2) + s(x3),
  data = df, family = nb(), method = "fREML")

# data slice through data along x2 - all other covariates will be set to
# typical values (value closest to median)
ds &lt;- data_slice(m, x2 = evenly(x2, n = 200))

# samples from posterior of derivatives
fd_samp &lt;- derivative_samples(m,
  data = ds, type = "central",
  focal = "x2", eps = 0.01, seed = 21, n_sim = 100
)

# plot the first 20 posterior draws
if (requireNamespace("ggplot2") &amp;&amp; requireNamespace("dplyr")) {
  library("ggplot2")
  fd_samp |&gt;
    dplyr::filter(.draw &lt;= 20) |&gt;
    ggplot(aes(x = x2, y = .derivative, group = .draw)) +
    geom_line(alpha = 0.5)
}
</code></pre>

<hr>
<h2 id='derivatives'>Derivatives of estimated smooths via finite differences</h2><span id='topic+derivatives'></span><span id='topic+derivatives.default'></span><span id='topic+derivatives.gamm'></span><span id='topic+derivatives.gam'></span>

<h3>Description</h3>

<p>Derivatives of estimated smooths via finite differences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derivatives(object, ...)

## Default S3 method:
derivatives(object, ...)

## S3 method for class 'gamm'
derivatives(object, ...)

## S3 method for class 'gam'
derivatives(
  object,
  select = NULL,
  term = deprecated(),
  data = newdata,
  order = 1L,
  type = c("forward", "backward", "central"),
  n = 100,
  eps = 1e-07,
  interval = c("confidence", "simultaneous"),
  n_sim = 10000,
  level = 0.95,
  unconditional = FALSE,
  frequentist = FALSE,
  offset = NULL,
  ncores = 1,
  partial_match = FALSE,
  ...,
  newdata = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derivatives_+3A_object">object</code></td>
<td>
<p>an R object to compute derivatives for.</p>
</td></tr>
<tr><td><code id="derivatives_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="derivatives_+3A_select">select</code></td>
<td>
<p>character; select which smooth's posterior to draw from.
The default (<code>NULL</code>) means the posteriors of all smooths in <code>model</code>
wil be sampled from. If supplied, a character vector of requested terms.
Can be a partial match to a smooth term; see argument <code>partial_match</code>
below.</p>
</td></tr>
<tr><td><code id="derivatives_+3A_term">term</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>select</code> instead.</p>
</td></tr>
<tr><td><code id="derivatives_+3A_data">data</code></td>
<td>
<p>a data frame containing the values of the model covariates
at which to evaluate the first derivatives of the smooths.</p>
</td></tr>
<tr><td><code id="derivatives_+3A_order">order</code></td>
<td>
<p>numeric; the order of derivative.</p>
</td></tr>
<tr><td><code id="derivatives_+3A_type">type</code></td>
<td>
<p>character; the type of finite difference used. One of
<code>"forward"</code>, <code>"backward"</code>, or <code>"central"</code>.</p>
</td></tr>
<tr><td><code id="derivatives_+3A_n">n</code></td>
<td>
<p>numeric; the number of points to evaluate the derivative at.</p>
</td></tr>
<tr><td><code id="derivatives_+3A_eps">eps</code></td>
<td>
<p>numeric; the finite difference.</p>
</td></tr>
<tr><td><code id="derivatives_+3A_interval">interval</code></td>
<td>
<p>character; the type of interval to compute. One of
<code>"confidence"</code> for point-wise intervals, or <code>"simultaneous"</code> for
simultaneous intervals.</p>
</td></tr>
<tr><td><code id="derivatives_+3A_n_sim">n_sim</code></td>
<td>
<p>integer; the number of simulations used in computing the
simultaneous intervals.</p>
</td></tr>
<tr><td><code id="derivatives_+3A_level">level</code></td>
<td>
<p>numeric; <code style="white-space: pre;">&#8288;0 &lt; level &lt; 1&#8288;</code>; the confidence level of the
point-wise or simultaneous interval. The default is <code>0.95</code> for a 95%
interval.</p>
</td></tr>
<tr><td><code id="derivatives_+3A_unconditional">unconditional</code></td>
<td>
<p>logical; use smoothness selection-corrected Bayesian
covariance matrix?</p>
</td></tr>
<tr><td><code id="derivatives_+3A_frequentist">frequentist</code></td>
<td>
<p>logical; use the frequentist covariance matrix?</p>
</td></tr>
<tr><td><code id="derivatives_+3A_offset">offset</code></td>
<td>
<p>numeric; a value to use for any offset term</p>
</td></tr>
<tr><td><code id="derivatives_+3A_ncores">ncores</code></td>
<td>
<p>number of cores for generating random variables from a
multivariate normal distribution. Passed to <code><a href="mvnfast.html#topic+rmvn">mvnfast::rmvn()</a></code>.
Parallelization will take place only if OpenMP is supported (but appears
to work on Windows with current <code>R</code>).</p>
</td></tr>
<tr><td><code id="derivatives_+3A_partial_match">partial_match</code></td>
<td>
<p>logical; should smooths be selected by partial matches
with <code>term</code>? If <code>TRUE</code>, <code>term</code> can only be a single string to match
against.</p>
</td></tr>
<tr><td><code id="derivatives_+3A_newdata">newdata</code></td>
<td>
<p>Deprecated: use <code>data</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble, currently with the following variables:
</p>

<ul>
<li> <p><code>smooth</code>: the smooth each row refers to,
</p>
</li>
<li> <p><code>var</code>: the name of the variable involved in the smooth,
</p>
</li>
<li> <p><code>data</code>: values of <code>var</code> at which the derivative was evaluated,
</p>
</li>
<li> <p><code>derivative</code>: the estimated derivative,
</p>
</li>
<li> <p><code>se</code>: the standard error of the estimated derivative,
</p>
</li>
<li> <p><code>crit</code>: the critical value such that <code>derivative</code> ± <code>(crit * se)</code> gives
the upper and lower bounds of the requested confidence or simultaneous
interval (given <code>level</code>),
</p>
</li>
<li> <p><code>lower</code>: the lower bound of the confidence or simultaneous interval,
</p>
</li>
<li> <p><code>upper</code>: the upper bound of the confidence or simultaneous interval.
</p>
</li></ul>



<h3>Note</h3>

<p><code>derivatives()</code> will ignore any random effect smooths it encounters in
<code>object</code>.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
load_mgcv()

dat &lt;- data_sim("eg1", n = 400, dist = "normal", scale = 2, seed = 42)
mod &lt;- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")

## first derivatives of all smooths using central finite differences
derivatives(mod, type = "central")

## derivatives for a selected smooth
derivatives(mod, type = "central", select = "s(x1)")
## or via a partial match
derivatives(mod, type = "central", select = "x1", partial_match = TRUE)

</code></pre>

<hr>
<h2 id='difference_smooths'>Differences of factor smooth interactions</h2><span id='topic+difference_smooths'></span><span id='topic+difference_smooths.gam'></span>

<h3>Description</h3>

<p>Estimates pairwise differences (comparisons) between factor smooth
interactions (smooths with a factor <code>by</code> argument) for pairs of groups
defined by the factor. The group means can be optionally included in the
difference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>difference_smooths(model, ...)

## S3 method for class 'gam'
difference_smooths(
  model,
  select = NULL,
  smooth = deprecated(),
  n = 100,
  ci_level = 0.95,
  data = NULL,
  group_means = FALSE,
  partial_match = TRUE,
  unconditional = FALSE,
  frequentist = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="difference_smooths_+3A_model">model</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="difference_smooths_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods. Not currently used.</p>
</td></tr>
<tr><td><code id="difference_smooths_+3A_select">select</code></td>
<td>
<p>character, logical, or numeric; which smooths to plot. If
<code>NULL</code>, the default, then all model smooths are drawn. Numeric <code>select</code>
indexes the smooths in the order they are specified in the formula and
stored in <code>object</code>. Character <code>select</code> matches the labels for smooths
as shown for example in the output from <code>summary(object)</code>. Logical
<code>select</code> operates as per numeric <code>select</code> in the order that smooths are
stored.</p>
</td></tr>
<tr><td><code id="difference_smooths_+3A_smooth">smooth</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>select</code> instead.</p>
</td></tr>
<tr><td><code id="difference_smooths_+3A_n">n</code></td>
<td>
<p>numeric; the number of points at which to evaluate the difference
between pairs of smooths.</p>
</td></tr>
<tr><td><code id="difference_smooths_+3A_ci_level">ci_level</code></td>
<td>
<p>numeric between 0 and 1; the coverage of credible interval.</p>
</td></tr>
<tr><td><code id="difference_smooths_+3A_data">data</code></td>
<td>
<p>data frame of locations at which to evaluate the difference
between smooths.</p>
</td></tr>
<tr><td><code id="difference_smooths_+3A_group_means">group_means</code></td>
<td>
<p>logical; should the group means be included in the
difference?</p>
</td></tr>
<tr><td><code id="difference_smooths_+3A_partial_match">partial_match</code></td>
<td>
<p>logical; should <code>smooth</code> match partially against
<code>smooths</code>? If <code>partial_match = TRUE</code>, <code>smooth</code> must only be a single
string, a character vector of length 1. Unlike similar functions, the
default here is <code>TRUE</code> because the intention is that users will be matching
against factor-by smooth labels.</p>
</td></tr>
<tr><td><code id="difference_smooths_+3A_unconditional">unconditional</code></td>
<td>
<p>logical; account for smoothness selection in the model?</p>
</td></tr>
<tr><td><code id="difference_smooths_+3A_frequentist">frequentist</code></td>
<td>
<p>logical; use the frequentist covariance matrix?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
load_mgcv()

df &lt;- data_sim("eg4", seed = 42)
m &lt;- gam(y ~ fac + s(x2, by = fac) + s(x0), data = df, method = "REML")

sm_dif &lt;- difference_smooths(m, select = "s(x2)")
sm_dif

draw(sm_dif)

# include the groups means for `fac` in the difference
sm_dif2 &lt;- difference_smooths(m, select = "s(x2)", group_means = TRUE)
draw(sm_dif2)

</code></pre>

<hr>
<h2 id='draw'>Generic plotting via <code>ggplot2</code></h2><span id='topic+draw'></span>

<h3>Description</h3>

<p>Generic plotting via <code>ggplot2</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_+3A_object">object</code></td>
<td>
<p>and R object to plot.</p>
</td></tr>
<tr><td><code id="draw_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic function for plotting of R objects that uses the <code>ggplot2</code> package.
</p>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>

<hr>
<h2 id='draw_parametric_effect'>Internal function to draw an individual parametric effect</h2><span id='topic+draw_parametric_effect'></span>

<h3>Description</h3>

<p>Internal function to draw an individual parametric effect
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_parametric_effect(
  object,
  ci_level = 0.95,
  ci_col = "black",
  ci_alpha = 0.2,
  line_col = "black",
  constant = NULL,
  fun = NULL,
  xlab = NULL,
  ylab = NULL,
  title = NULL,
  subtitle = NULL,
  caption = NULL,
  rug = TRUE,
  position = "identity",
  ylim = NULL,
  angle = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_parametric_effect_+3A_object">object</code></td>
<td>
<p>a fitted GAM, the result of a call to <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code>.</p>
</td></tr>
<tr><td><code id="draw_parametric_effect_+3A_ci_level">ci_level</code></td>
<td>
<p>numeric between 0 and 1; the coverage of credible interval.</p>
</td></tr>
<tr><td><code id="draw_parametric_effect_+3A_ci_col">ci_col</code></td>
<td>
<p>colour specification for the confidence/credible intervals
band. Affects the fill of the interval.</p>
</td></tr>
<tr><td><code id="draw_parametric_effect_+3A_ci_alpha">ci_alpha</code></td>
<td>
<p>numeric; alpha transparency for confidence or simultaneous
interval.</p>
</td></tr>
<tr><td><code id="draw_parametric_effect_+3A_constant">constant</code></td>
<td>
<p>numeric; a constant to add to the estimated values of the
smooth. <code>constant</code>, if supplied, will be added to the estimated value
before the confidence band is computed.</p>
</td></tr>
<tr><td><code id="draw_parametric_effect_+3A_fun">fun</code></td>
<td>
<p>function; a function that will be applied to the estimated values
and confidence interval before plotting. Can be a function or the name of a
function. Function <code>fun</code> will be applied after adding any <code>constant</code>, if
provided.</p>
</td></tr>
<tr><td><code id="draw_parametric_effect_+3A_xlab">xlab</code></td>
<td>
<p>character or expression; the label for the x axis. If not
supplied, a suitable label will be generated from <code>object</code>.</p>
</td></tr>
<tr><td><code id="draw_parametric_effect_+3A_ylab">ylab</code></td>
<td>
<p>character or expression; the label for the y axis. If not
supplied, a suitable label will be generated from <code>object</code>.</p>
</td></tr>
<tr><td><code id="draw_parametric_effect_+3A_title">title</code></td>
<td>
<p>character or expression; the title for the plot. See
<code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>.</p>
</td></tr>
<tr><td><code id="draw_parametric_effect_+3A_subtitle">subtitle</code></td>
<td>
<p>character or expression; the subtitle for the plot. See
<code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>.</p>
</td></tr>
<tr><td><code id="draw_parametric_effect_+3A_caption">caption</code></td>
<td>
<p>character or expression; the plot caption. See
<code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>.</p>
</td></tr>
<tr><td><code id="draw_parametric_effect_+3A_rug">rug</code></td>
<td>
<p>logical; draw a rug plot at the bottom of each plot for 1-D
smooths or plot locations of data for higher dimensions.</p>
</td></tr>
<tr><td><code id="draw_parametric_effect_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a
call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="draw_parametric_effect_+3A_angle">angle</code></td>
<td>
<p>numeric; the angle at which the x axis tick labels are to be
drawn passed to the <code>angle</code> argument of <code><a href="ggplot2.html#topic+guide_axis">ggplot2::guide_axis()</a></code>.</p>
</td></tr>
<tr><td><code id="draw_parametric_effect_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="patchwork.html#topic+wrap_plots">patchwork::wrap_plots()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='draw.basis'>Plot basis functions</h2><span id='topic+draw.basis'></span>

<h3>Description</h3>

<p>Plots basis functions using ggplot2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'basis'
draw(
  object,
  legend = FALSE,
  labeller = NULL,
  ylab = NULL,
  title = NULL,
  subtitle = NULL,
  caption = NULL,
  ncol = NULL,
  nrow = NULL,
  angle = NULL,
  guides = "keep",
  contour = FALSE,
  n_contour = 10,
  contour_col = "black",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw.basis_+3A_object">object</code></td>
<td>
<p>an object, the result of a call to <code><a href="#topic+basis">basis()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.basis_+3A_legend">legend</code></td>
<td>
<p>logical; should a legend by drawn to indicate basis functions?</p>
</td></tr>
<tr><td><code id="draw.basis_+3A_labeller">labeller</code></td>
<td>
<p>a labeller function with which to label facets. The default
is to use <code><a href="ggplot2.html#topic+labellers">ggplot2::label_both()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.basis_+3A_ylab">ylab</code></td>
<td>
<p>character or expression; the label for the y axis. If not
supplied, a suitable label will be generated from <code>object</code>.</p>
</td></tr>
<tr><td><code id="draw.basis_+3A_title">title</code></td>
<td>
<p>character or expression; the title for the plot. See
<code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.basis_+3A_subtitle">subtitle</code></td>
<td>
<p>character or expression; the subtitle for the plot. See
<code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.basis_+3A_caption">caption</code></td>
<td>
<p>character or expression; the plot caption. See
<code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.basis_+3A_ncol">ncol</code>, <code id="draw.basis_+3A_nrow">nrow</code></td>
<td>
<p>numeric; the numbers of rows and columns over which to
spread the plots</p>
</td></tr>
<tr><td><code id="draw.basis_+3A_angle">angle</code></td>
<td>
<p>numeric; the angle at which the x axis tick labels are to be
drawn passed to the <code>angle</code> argument of <code><a href="ggplot2.html#topic+guide_axis">ggplot2::guide_axis()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.basis_+3A_guides">guides</code></td>
<td>
<p>character; one of <code>"keep"</code> (the default), <code>"collect"</code>, or
<code>"auto"</code>. Passed to <code><a href="patchwork.html#topic+plot_layout">patchwork::plot_layout()</a></code></p>
</td></tr>
<tr><td><code id="draw.basis_+3A_contour">contour</code></td>
<td>
<p>logical; should contours be draw on the plot using
<code><a href="ggplot2.html#topic+geom_contour">ggplot2::geom_contour()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.basis_+3A_n_contour">n_contour</code></td>
<td>
<p>numeric; the number of contour bins. Will result in
<code>n_contour - 1</code> contour lines being drawn. See <code><a href="ggplot2.html#topic+geom_contour">ggplot2::geom_contour()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.basis_+3A_contour_col">contour_col</code></td>
<td>
<p>colour specification for contour lines.</p>
</td></tr>
<tr><td><code id="draw.basis_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods. Not used by this method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>patchwork</code> object.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()
df &lt;- data_sim("eg1", n = 400, seed = 42)
m &lt;- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = "REML")

bf &lt;- basis(m)
draw(bf)

bf &lt;- basis(m, "s(x2)")
draw(bf)
</code></pre>

<hr>
<h2 id='draw.compare_smooths'>Plot comparisons of smooths</h2><span id='topic+draw.compare_smooths'></span>

<h3>Description</h3>

<p>Plot comparisons of smooths
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'compare_smooths'
draw(object, ncol = NULL, nrow = NULL, guides = "collect", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw.compare_smooths_+3A_object">object</code></td>
<td>
<p>of class <code>"compare_smooths"</code>, the result of a call to
<code><a href="#topic+compare_smooths">compare_smooths()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.compare_smooths_+3A_ncol">ncol</code>, <code id="draw.compare_smooths_+3A_nrow">nrow</code></td>
<td>
<p>numeric; the numbers of rows and columns over which to
spread the plots</p>
</td></tr>
<tr><td><code id="draw.compare_smooths_+3A_guides">guides</code></td>
<td>
<p>character; one of <code>"keep"</code> (the default), <code>"collect"</code>, or
<code>"auto"</code>. Passed to <code><a href="patchwork.html#topic+plot_layout">patchwork::plot_layout()</a></code></p>
</td></tr>
<tr><td><code id="draw.compare_smooths_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="patchwork.html#topic+wrap_plots">patchwork::wrap_plots()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='draw.derivatives'>Plot derivatives of smooths</h2><span id='topic+draw.derivatives'></span><span id='topic+draw.partial_derivatives'></span>

<h3>Description</h3>

<p>Plot derivatives of smooths
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'derivatives'
draw(
  object,
  select = NULL,
  scales = c("free", "fixed"),
  add_change = FALSE,
  change_type = c("change", "sizer"),
  alpha = 0.2,
  change_col = "black",
  decrease_col = "#56B4E9",
  increase_col = "#E69F00",
  lwd_change = 1.5,
  ncol = NULL,
  nrow = NULL,
  guides = "keep",
  angle = NULL,
  ...
)

## S3 method for class 'partial_derivatives'
draw(
  object,
  select = NULL,
  scales = c("free", "fixed"),
  alpha = 0.2,
  ncol = NULL,
  nrow = NULL,
  guides = "keep",
  angle = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw.derivatives_+3A_object">object</code></td>
<td>
<p>a fitted GAM, the result of a call to <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.derivatives_+3A_select">select</code></td>
<td>
<p>character, logical, or numeric; which smooths to plot. If
<code>NULL</code>, the default, then all model smooths are drawn. Numeric <code>select</code>
indexes the smooths in the order they are specified in the formula and
stored in <code>object</code>. Character <code>select</code> matches the labels for smooths
as shown for example in the output from <code>summary(object)</code>. Logical
<code>select</code> operates as per numeric <code>select</code> in the order that smooths are
stored.</p>
</td></tr>
<tr><td><code id="draw.derivatives_+3A_scales">scales</code></td>
<td>
<p>character; should all univariate smooths be plotted with the
same y-axis scale? If <code>scales = "free"</code>, the default, each univariate
smooth has its own y-axis scale. If <code>scales = "fixed"</code>, a common y axis
scale is used for all univariate smooths.
</p>
<p>Currently does not affect the y-axis scale of plots of the parametric
terms.</p>
</td></tr>
<tr><td><code id="draw.derivatives_+3A_add_change">add_change</code></td>
<td>
<p>logical; should the periods of significant change be
highlighted on the plot?</p>
</td></tr>
<tr><td><code id="draw.derivatives_+3A_change_type">change_type</code></td>
<td>
<p>character; the type of change to indicate. If <code>"change"</code>,
no differentiation is made between periods of significant increase or
decrease. If <code>"sizer"</code>, the periods of increase and decrease are
differentiated in the resulting plot.</p>
</td></tr>
<tr><td><code id="draw.derivatives_+3A_alpha">alpha</code></td>
<td>
<p>numeric; alpha transparency for confidence or simultaneous
interval.</p>
</td></tr>
<tr><td><code id="draw.derivatives_+3A_change_col">change_col</code>, <code id="draw.derivatives_+3A_decrease_col">decrease_col</code>, <code id="draw.derivatives_+3A_increase_col">increase_col</code></td>
<td>
<p>colour specifications to use for
indicating periods of change. <code>col_change</code> is used when
<code>change_type = "change"</code>, while <code>col_decrease</code> and <code>col_increase</code> are used
when 'change_type = &quot;sizer&quot;&ldquo;.</p>
</td></tr>
<tr><td><code id="draw.derivatives_+3A_lwd_change">lwd_change</code></td>
<td>
<p>numeric; the <code>linewidth</code> to use for the change indicators.</p>
</td></tr>
<tr><td><code id="draw.derivatives_+3A_ncol">ncol</code>, <code id="draw.derivatives_+3A_nrow">nrow</code></td>
<td>
<p>numeric; the numbers of rows and columns over which to
spread the plots</p>
</td></tr>
<tr><td><code id="draw.derivatives_+3A_guides">guides</code></td>
<td>
<p>character; one of <code>"keep"</code> (the default), <code>"collect"</code>, or
<code>"auto"</code>. Passed to <code><a href="patchwork.html#topic+plot_layout">patchwork::plot_layout()</a></code></p>
</td></tr>
<tr><td><code id="draw.derivatives_+3A_angle">angle</code></td>
<td>
<p>numeric; the angle at which the x axis tick labels are to be
drawn passed to the <code>angle</code> argument of <code><a href="ggplot2.html#topic+guide_axis">ggplot2::guide_axis()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.derivatives_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="patchwork.html#topic+wrap_plots">patchwork::wrap_plots()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
load_mgcv()
dat &lt;- data_sim("eg1", n = 800, dist = "normal", scale = 2, seed = 42)
mod &lt;- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")

## first derivative of all smooths
df &lt;- derivatives(mod, type = "central")
draw(df)
## fixed axis scales
draw(df, scales = "fixed")
</code></pre>

<hr>
<h2 id='draw.difference_smooth'>Plot differences of smooths</h2><span id='topic+draw.difference_smooth'></span>

<h3>Description</h3>

<p>Plot differences of smooths
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'difference_smooth'
draw(
  object,
  select = NULL,
  rug = FALSE,
  ref_line = FALSE,
  contour = FALSE,
  contour_col = "black",
  n_contour = NULL,
  ci_alpha = 0.2,
  ci_col = "black",
  smooth_col = "black",
  line_col = "red",
  scales = c("free", "fixed"),
  ncol = NULL,
  nrow = NULL,
  guides = "keep",
  xlab = NULL,
  ylab = NULL,
  title = NULL,
  subtitle = NULL,
  caption = NULL,
  angle = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw.difference_smooth_+3A_object">object</code></td>
<td>
<p>a fitted GAM, the result of a call to <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.difference_smooth_+3A_select">select</code></td>
<td>
<p>character, logical, or numeric; which smooths to plot. If
<code>NULL</code>, the default, then all model smooths are drawn. Numeric <code>select</code>
indexes the smooths in the order they are specified in the formula and
stored in <code>object</code>. Character <code>select</code> matches the labels for smooths
as shown for example in the output from <code>summary(object)</code>. Logical
<code>select</code> operates as per numeric <code>select</code> in the order that smooths are
stored.</p>
</td></tr>
<tr><td><code id="draw.difference_smooth_+3A_rug">rug</code></td>
<td>
<p>logical;</p>
</td></tr>
<tr><td><code id="draw.difference_smooth_+3A_ref_line">ref_line</code></td>
<td>
<p>logical;</p>
</td></tr>
<tr><td><code id="draw.difference_smooth_+3A_contour">contour</code></td>
<td>
<p>logical; should contour lines be added to smooth surfaces?</p>
</td></tr>
<tr><td><code id="draw.difference_smooth_+3A_contour_col">contour_col</code></td>
<td>
<p>colour specification for contour lines.</p>
</td></tr>
<tr><td><code id="draw.difference_smooth_+3A_n_contour">n_contour</code></td>
<td>
<p>numeric; the number of contour bins. Will result in
<code>n_contour - 1</code> contour lines being drawn. See <code><a href="ggplot2.html#topic+geom_contour">ggplot2::geom_contour()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.difference_smooth_+3A_ci_alpha">ci_alpha</code></td>
<td>
<p>numeric; alpha transparency for confidence or simultaneous
interval.</p>
</td></tr>
<tr><td><code id="draw.difference_smooth_+3A_ci_col">ci_col</code></td>
<td>
<p>colour specification for the confidence/credible intervals
band. Affects the fill of the interval.</p>
</td></tr>
<tr><td><code id="draw.difference_smooth_+3A_smooth_col">smooth_col</code></td>
<td>
<p>colour specification for the the smooth or difference line.</p>
</td></tr>
<tr><td><code id="draw.difference_smooth_+3A_line_col">line_col</code></td>
<td>
<p>colour specification for drawing reference lines</p>
</td></tr>
<tr><td><code id="draw.difference_smooth_+3A_scales">scales</code></td>
<td>
<p>character; should all univariate smooths be plotted with the
same y-axis scale? If <code>scales = "free"</code>, the default, each univariate
smooth has its own y-axis scale. If <code>scales = "fixed"</code>, a common y axis
scale is used for all univariate smooths.
</p>
<p>Currently does not affect the y-axis scale of plots of the parametric
terms.</p>
</td></tr>
<tr><td><code id="draw.difference_smooth_+3A_ncol">ncol</code>, <code id="draw.difference_smooth_+3A_nrow">nrow</code></td>
<td>
<p>numeric; the numbers of rows and columns over which to
spread the plots</p>
</td></tr>
<tr><td><code id="draw.difference_smooth_+3A_guides">guides</code></td>
<td>
<p>character; one of <code>"keep"</code> (the default), <code>"collect"</code>, or
<code>"auto"</code>. Passed to <code><a href="patchwork.html#topic+plot_layout">patchwork::plot_layout()</a></code></p>
</td></tr>
<tr><td><code id="draw.difference_smooth_+3A_xlab">xlab</code>, <code id="draw.difference_smooth_+3A_ylab">ylab</code>, <code id="draw.difference_smooth_+3A_title">title</code>, <code id="draw.difference_smooth_+3A_subtitle">subtitle</code>, <code id="draw.difference_smooth_+3A_caption">caption</code></td>
<td>
<p>character; labels with which to
annotate plots</p>
</td></tr>
<tr><td><code id="draw.difference_smooth_+3A_angle">angle</code></td>
<td>
<p>numeric; the angle at which the x axis tick labels are to be
drawn passed to the <code>angle</code> argument of <code><a href="ggplot2.html#topic+guide_axis">ggplot2::guide_axis()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.difference_smooth_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="patchwork.html#topic+wrap_plots">patchwork::wrap_plots()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
load_mgcv()
# simulate some data; a factor smooth example
df &lt;- data_sim("eg4", seed = 42)
# fit GAM
m &lt;- gam(y ~ fac + s(x2, by = fac) + s(x0), data = df, method = "REML")

# calculate the differences between pairs of smooths the f_j(x2) term
diffs &lt;- difference_smooths(m, select = "s(x2)")
draw(diffs)
</code></pre>

<hr>
<h2 id='draw.evaluated_parametric_term'>Plot estimated parametric effects</h2><span id='topic+draw.evaluated_parametric_term'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>Plots estimated univariate and bivariate smooths using ggplot2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evaluated_parametric_term'
draw(
  object,
  ci_level = 0.95,
  constant = NULL,
  fun = NULL,
  xlab,
  ylab,
  title = NULL,
  subtitle = NULL,
  caption = NULL,
  rug = TRUE,
  position = "identity",
  response_range = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw.evaluated_parametric_term_+3A_object">object</code></td>
<td>
<p>an object, the result of a call to
<code><a href="#topic+evaluate_parametric_term">evaluate_parametric_term()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.evaluated_parametric_term_+3A_ci_level">ci_level</code></td>
<td>
<p>numeric between 0 and 1; the coverage of credible interval.</p>
</td></tr>
<tr><td><code id="draw.evaluated_parametric_term_+3A_constant">constant</code></td>
<td>
<p>numeric; a constant to add to the estimated values of the
smooth. <code>constant</code>, if supplied, will be added to the estimated value
before the confidence band is computed.</p>
</td></tr>
<tr><td><code id="draw.evaluated_parametric_term_+3A_fun">fun</code></td>
<td>
<p>function; a function that will be applied to the estimated values
and confidence interval before plotting. Can be a function or the name of a
function. Function <code>fun</code> will be applied after adding any <code>constant</code>, if
provided.</p>
</td></tr>
<tr><td><code id="draw.evaluated_parametric_term_+3A_xlab">xlab</code></td>
<td>
<p>character or expression; the label for the x axis. If not
supplied, a suitable label will be generated from <code>object</code>.</p>
</td></tr>
<tr><td><code id="draw.evaluated_parametric_term_+3A_ylab">ylab</code></td>
<td>
<p>character or expression; the label for the y axis. If not
supplied, a suitable label will be generated from <code>object</code>.</p>
</td></tr>
<tr><td><code id="draw.evaluated_parametric_term_+3A_title">title</code></td>
<td>
<p>character or expression; the title for the plot. See
<code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.evaluated_parametric_term_+3A_subtitle">subtitle</code></td>
<td>
<p>character or expression; the subtitle for the plot. See
<code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.evaluated_parametric_term_+3A_caption">caption</code></td>
<td>
<p>character or expression; the plot caption. See
<code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.evaluated_parametric_term_+3A_rug">rug</code></td>
<td>
<p>For <code>evaluate_parametric_terms()</code>, a logical to
indicate if a rug plot should be drawn.</p>
</td></tr>
<tr><td><code id="draw.evaluated_parametric_term_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a
call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="draw.evaluated_parametric_term_+3A_response_range">response_range</code></td>
<td>
<p>numeric; a vector of two values giving the range of
response data for the guide. Used to fix plots to a common scale/range.
Ignored if <code>show</code> is set to <code>"se"</code>.</p>
</td></tr>
<tr><td><code id="draw.evaluated_parametric_term_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>

<hr>
<h2 id='draw.gam'>Plot estimated smooths from a fitted GAM</h2><span id='topic+draw.gam'></span>

<h3>Description</h3>

<p>Plots estimated smooths from a fitted GAM model in a similar way to
<code>mgcv::plot.gam()</code> but instead of using base graphics, <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code>
is used instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gam'
draw(
  object,
  data = NULL,
  select = NULL,
  parametric = FALSE,
  terms = NULL,
  residuals = FALSE,
  scales = c("free", "fixed"),
  ci_level = 0.95,
  n = 100,
  n_3d = 16,
  n_4d = 4,
  unconditional = FALSE,
  overall_uncertainty = TRUE,
  constant = NULL,
  fun = NULL,
  dist = 0.1,
  rug = TRUE,
  contour = TRUE,
  grouped_by = FALSE,
  ci_alpha = 0.2,
  ci_col = "black",
  smooth_col = "black",
  resid_col = "steelblue3",
  contour_col = "black",
  n_contour = NULL,
  partial_match = FALSE,
  discrete_colour = NULL,
  discrete_fill = NULL,
  continuous_colour = NULL,
  continuous_fill = NULL,
  position = "identity",
  angle = NULL,
  ncol = NULL,
  nrow = NULL,
  guides = "keep",
  widths = NULL,
  heights = NULL,
  crs = NULL,
  default_crs = NULL,
  lims_method = "cross",
  wrap = TRUE,
  envir = environment(formula(object)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw.gam_+3A_object">object</code></td>
<td>
<p>a fitted GAM, the result of a call to <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_data">data</code></td>
<td>
<p>a optional data frame that may or may not be used? FIXME!</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_select">select</code></td>
<td>
<p>character, logical, or numeric; which smooths to plot. If
<code>NULL</code>, the default, then all model smooths are drawn. Numeric <code>select</code>
indexes the smooths in the order they are specified in the formula and
stored in <code>object</code>. Character <code>select</code> matches the labels for smooths
as shown for example in the output from <code>summary(object)</code>. Logical
<code>select</code> operates as per numeric <code>select</code> in the order that smooths are
stored.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_parametric">parametric</code></td>
<td>
<p>logical; plot parametric terms also? Note that <code>select</code> is
used for selecting which smooths to plot. The <code>terms</code> argument is used to
select which parametric effects are plotted. The default, as with
<code><a href="mgcv.html#topic+plot.gam">mgcv::plot.gam()</a></code>, is to not draw parametric effects.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_terms">terms</code></td>
<td>
<p>character; which model parametric terms should be drawn? The
Default of <code>NULL</code> will plot all parametric terms that can be drawn.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_residuals">residuals</code></td>
<td>
<p>logical; should partial residuals for a smooth be drawn?
Ignored for anything but a simple univariate smooth.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_scales">scales</code></td>
<td>
<p>character; should all univariate smooths be plotted with the
same y-axis scale? If <code>scales = "free"</code>, the default, each univariate
smooth has its own y-axis scale. If <code>scales = "fixed"</code>, a common y axis
scale is used for all univariate smooths.
</p>
<p>Currently does not affect the y-axis scale of plots of the parametric
terms.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_ci_level">ci_level</code></td>
<td>
<p>numeric between 0 and 1; the coverage of credible interval.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_n">n</code></td>
<td>
<p>numeric; the number of points over the range of the covariate at
which to evaluate the smooth.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_n_3d">n_3d</code></td>
<td>
<p>numeric; the number of new observations to generate for the third
dimension of a 3D smooth.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_n_4d">n_4d</code></td>
<td>
<p>numeric; the number of new observations to generate for the
dimensions higher than 2 (!) of a <em>k</em>D smooth (<em>k</em> &gt;= 4). For example, if
the smooth is a 4D smooth, each of dimensions 3 and 4 will get <code>n_4d</code>
new observations.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_unconditional">unconditional</code></td>
<td>
<p>logical; should confidence intervals include the
uncertainty due to smoothness selection? If <code>TRUE</code>, the corrected Bayesian
covariance matrix will be used.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_overall_uncertainty">overall_uncertainty</code></td>
<td>
<p>logical; should the uncertainty in the model
constant term be included in the standard error of the evaluate values of
the smooth?</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_constant">constant</code></td>
<td>
<p>numeric; a constant to add to the estimated values of the
smooth. <code>constant</code>, if supplied, will be added to the estimated value
before the confidence band is computed.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_fun">fun</code></td>
<td>
<p>function; a function that will be applied to the estimated values
and confidence interval before plotting. Can be a function or the name of a
function. Function <code>fun</code> will be applied after adding any <code>constant</code>, if
provided.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_dist">dist</code></td>
<td>
<p>numeric; if greater than 0, this is used to determine when
a location is too far from data to be plotted when plotting 2-D smooths.
The data are scaled into the unit square before deciding what to exclude,
and <code>dist</code> is a distance within the unit square. See
<code><a href="mgcv.html#topic+exclude.too.far">mgcv::exclude.too.far()</a></code> for further details.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_rug">rug</code></td>
<td>
<p>logical; draw a rug plot at the bottom of each plot for 1-D
smooths or plot locations of data for higher dimensions.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_contour">contour</code></td>
<td>
<p>logical; should contours be draw on the plot using
<code><a href="ggplot2.html#topic+geom_contour">ggplot2::geom_contour()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_grouped_by">grouped_by</code></td>
<td>
<p>logical; should factor by smooths be drawn as one panel
per level of the factor (<code>FALSE</code>, the default), or should the individual
smooths be combined into a single panel containing all levels (<code>TRUE</code>)?</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_ci_alpha">ci_alpha</code></td>
<td>
<p>numeric; alpha transparency for confidence or simultaneous
interval.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_ci_col">ci_col</code></td>
<td>
<p>colour specification for the confidence/credible intervals
band. Affects the fill of the interval.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_smooth_col">smooth_col</code></td>
<td>
<p>colour specification for the smooth line.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_resid_col">resid_col</code></td>
<td>
<p>colour specification for the partial residuals.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_contour_col">contour_col</code></td>
<td>
<p>colour specification for contour lines.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_n_contour">n_contour</code></td>
<td>
<p>numeric; the number of contour bins. Will result in
<code>n_contour - 1</code> contour lines being drawn. See <code><a href="ggplot2.html#topic+geom_contour">ggplot2::geom_contour()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_partial_match">partial_match</code></td>
<td>
<p>logical; should smooths be selected by partial matches
with <code>select</code>? If <code>TRUE</code>, <code>select</code> can only be a single string to match
against.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_discrete_colour">discrete_colour</code></td>
<td>
<p>a suitable colour scale to be used when plotting
discrete variables.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_discrete_fill">discrete_fill</code></td>
<td>
<p>a suitable fill scale to be used when plotting
discrete variables.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_continuous_colour">continuous_colour</code></td>
<td>
<p>a suitable colour scale to be used when plotting
continuous variables.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_continuous_fill">continuous_fill</code></td>
<td>
<p>a suitable fill scale to be used when plotting
continuous variables.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a
call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_angle">angle</code></td>
<td>
<p>numeric; the angle at which the x axis tick labels are to be
drawn passed to the <code>angle</code> argument of <code><a href="ggplot2.html#topic+guide_axis">ggplot2::guide_axis()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_ncol">ncol</code>, <code id="draw.gam_+3A_nrow">nrow</code></td>
<td>
<p>numeric; the numbers of rows and columns over which to
spread the plots</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_guides">guides</code></td>
<td>
<p>character; one of <code>"keep"</code> (the default), <code>"collect"</code>, or
<code>"auto"</code>. Passed to <code><a href="patchwork.html#topic+plot_layout">patchwork::plot_layout()</a></code></p>
</td></tr>
<tr><td><code id="draw.gam_+3A_widths">widths</code>, <code id="draw.gam_+3A_heights">heights</code></td>
<td>
<p>The relative widths and heights of each column and
row in the grid. Will get repeated to match the dimensions of the grid. If
there is more than 1 plot and <code>widths = NULL</code>, the value of <code>widths</code> will
be set internally to <code>widths = 1</code> to accommodate plots of smooths that
use a fixed aspect ratio.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_crs">crs</code></td>
<td>
<p>the coordinate reference system (CRS) to use for the plot. All
data will be projected into this CRS. See <code><a href="ggplot2.html#topic+ggsf">ggplot2::coord_sf()</a></code> for
details.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_default_crs">default_crs</code></td>
<td>
<p>the coordinate reference system (CRS) to use for the
non-sf layers in the plot. If left at the default <code>NULL</code>, the CRS used is
4326 (WGS84), which is appropriate for spline-on-the-sphere smooths, which
are parameterized in terms of latitude and longitude as coordinates. See
<code><a href="ggplot2.html#topic+ggsf">ggplot2::coord_sf()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_lims_method">lims_method</code></td>
<td>
<p>character; affects how the axis limits are determined. See
<code><a href="ggplot2.html#topic+ggsf">ggplot2::coord_sf()</a></code>. Be careful; in testing of some examples, changing
this to <code>"orthogonal"</code> for example with the chlorophyll-a example from
Simon Wood's GAM book quickly used up all the RAM in my test system and the
OS killed R. This could be incorrect usage on my part; right now the grid
of points at which SOS smooths are evaluated (if not supplied by the user)
can produce invalid coordinates for the corners of tiles as the grid is
generated for tile centres without respect to the spacing of those tiles.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_wrap">wrap</code></td>
<td>
<p>logical; wrap plots as a patchwork? If <code>FALSE</code>, a list of
ggplot objects is returned, 1 per term plotted.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_envir">envir</code></td>
<td>
<p>an environment to look up the data within.</p>
</td></tr>
<tr><td><code id="draw.gam_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="patchwork.html#topic+wrap_plots">patchwork::wrap_plots()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object returned is created by <code><a href="patchwork.html#topic+wrap_plots">patchwork::wrap_plots()</a></code>.
</p>


<h3>Note</h3>

<p>Internally, plots of each smooth are created using <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code>
and composed into a single plot using <code><a href="patchwork.html#topic+wrap_plots">patchwork::wrap_plots()</a></code>. As a
result, it is not possible to use <code>+</code> to add to the plots in the way one
might typically work with <code>ggplot()</code> plots. Instead, use the <code>&amp;</code> operator;
see the examples.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()

# simulate some data
df1 &lt;- data_sim("eg1", n = 400, dist = "normal", scale = 2, seed = 2)
# fit GAM
m1 &lt;- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df1, method = "REML")

# plot all smooths
draw(m1)

# can add partial residuals
draw(m1, residuals = TRUE)

df2 &lt;- data_sim("eg2", n = 1000, dist = "normal", scale = 1, seed = 2)
m2 &lt;- gam(y ~ s(x, z, k = 40), data = df2, method = "REML")
draw(m2, contour = FALSE, n = 50)

# See https://gavinsimpson.github.io/gratia/articles/custom-plotting.html
# for more examples and for details on how to modify the theme of all the
# plots produced by draw(). To modify all panels, for example to change the
# theme, use the &amp; operator
</code></pre>

<hr>
<h2 id='draw.gamlss'>Plot smooths of a GAMLSS model estimated by <code>GJRM::gamlss</code></h2><span id='topic+draw.gamlss'></span>

<h3>Description</h3>

<p>Provides a <code><a href="#topic+draw">draw()</a></code> method for GAMLSS (distributional GAMs) fitted
by <code><a href="GJRM.html#topic+gamlss">GJRM::gamlss()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gamlss'
draw(
  object,
  scales = c("free", "fixed"),
  ncol = NULL,
  nrow = NULL,
  guides = "keep",
  widths = NULL,
  heights = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw.gamlss_+3A_object">object</code></td>
<td>
<p>a model, fitted by <code><a href="GJRM.html#topic+gamlss">GJRM::gamlss()</a></code></p>
</td></tr>
<tr><td><code id="draw.gamlss_+3A_scales">scales</code></td>
<td>
<p>character; should all univariate smooths be plotted with the
same y-axis scale? If <code>scales = "free"</code>, the default, each univariate
smooth has its own y-axis scale. If <code>scales = "fixed"</code>, a common y axis
scale is used for all univariate smooths.
</p>
<p>Currently does not affect the y-axis scale of plots of the parametric
terms.</p>
</td></tr>
<tr><td><code id="draw.gamlss_+3A_ncol">ncol</code>, <code id="draw.gamlss_+3A_nrow">nrow</code></td>
<td>
<p>numeric; the numbers of rows and columns over which to
spread the plots</p>
</td></tr>
<tr><td><code id="draw.gamlss_+3A_guides">guides</code></td>
<td>
<p>character; one of <code>"keep"</code> (the default), <code>"collect"</code>, or
<code>"auto"</code>. Passed to <code><a href="patchwork.html#topic+plot_layout">patchwork::plot_layout()</a></code></p>
</td></tr>
<tr><td><code id="draw.gamlss_+3A_widths">widths</code>, <code id="draw.gamlss_+3A_heights">heights</code></td>
<td>
<p>The relative widths and heights of each column and
row in the grid. Will get repeated to match the dimensions of the grid. If
there is more than 1 plot and <code>widths = NULL</code>, the value of <code>widths</code> will
be set internally to <code>widths = 1</code> to accommodate plots of smooths that
use a fixed aspect ratio.</p>
</td></tr>
<tr><td><code id="draw.gamlss_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+draw.gam">draw.gam()</a></code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>Plots of smooths are not labelled with the linear predictor to which
they belong.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("GJRM", quietly = TRUE)) {
  # follow example from ?GJRM::gamlss
  load_mgcv()
  suppressPackageStartupMessages(library("GJRM"))
  set.seed(0)
  n &lt;- 100
  x1 &lt;- round(runif(n))
  x2 &lt;- runif(n)
  x3 &lt;- runif(n)
  f1 &lt;- function(x) cos(pi * 2 * x) + sin(pi * x)
  y1 &lt;- -1.55 + 2 * x1 + f1(x2) + rnorm(n)
  dataSim &lt;- data.frame(y1, x1, x2, x3)

  eq_mu &lt;- y1 ~ x1 + s(x2)
  eq_s &lt;- ~ s(x3, k = 6)
  fl &lt;- list(eq_mu, eq_s)
  m &lt;- gamlss(fl, data = dataSim)

  draw(m)
}
</code></pre>

<hr>
<h2 id='draw.mgcv_smooth'>Plot basis functions</h2><span id='topic+draw.mgcv_smooth'></span>

<h3>Description</h3>

<p>Plots basis functions using ggplot2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mgcv_smooth'
draw(
  object,
  legend = FALSE,
  use_facets = TRUE,
  labeller = NULL,
  xlab,
  ylab,
  title = NULL,
  subtitle = NULL,
  caption = NULL,
  angle = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw.mgcv_smooth_+3A_object">object</code></td>
<td>
<p>an object, the result of a call to <code><a href="#topic+basis">basis()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.mgcv_smooth_+3A_legend">legend</code></td>
<td>
<p>logical; should a legend by drawn to indicate basis functions?</p>
</td></tr>
<tr><td><code id="draw.mgcv_smooth_+3A_use_facets">use_facets</code></td>
<td>
<p>logical; for factor by smooths, use facets to show the
basis functions for each level of the factor? If <code>FALSE</code>, a separate ggplot
object will be created for each level and combined using
<code><a href="patchwork.html#topic+wrap_plots">patchwork::wrap_plots()</a></code>. <strong>Currently ignored</strong>.</p>
</td></tr>
<tr><td><code id="draw.mgcv_smooth_+3A_labeller">labeller</code></td>
<td>
<p>a labeller function with which to label facets. The default
is to use <code><a href="ggplot2.html#topic+labellers">ggplot2::label_both()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.mgcv_smooth_+3A_xlab">xlab</code></td>
<td>
<p>character or expression; the label for the x axis. If not
supplied, a suitable label will be generated from <code>object</code>.</p>
</td></tr>
<tr><td><code id="draw.mgcv_smooth_+3A_ylab">ylab</code></td>
<td>
<p>character or expression; the label for the y axis. If not
supplied, a suitable label will be generated from <code>object</code>.</p>
</td></tr>
<tr><td><code id="draw.mgcv_smooth_+3A_title">title</code></td>
<td>
<p>character or expression; the title for the plot. See
<code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.mgcv_smooth_+3A_subtitle">subtitle</code></td>
<td>
<p>character or expression; the subtitle for the plot. See
<code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.mgcv_smooth_+3A_caption">caption</code></td>
<td>
<p>character or expression; the plot caption. See
<code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.mgcv_smooth_+3A_angle">angle</code></td>
<td>
<p>numeric; the angle at which the x axis tick labels are to be
drawn passed to the <code>angle</code> argument of <code><a href="ggplot2.html#topic+guide_axis">ggplot2::guide_axis()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.mgcv_smooth_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods. Not used by this method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()
df &lt;- data_sim("eg4", n = 400, seed = 42)

bf &lt;- basis(s(x0), data = df)
draw(bf)

bf &lt;- basis(s(x2, by = fac, bs = "bs"), data = df)
draw(bf)
</code></pre>

<hr>
<h2 id='draw.pairwise_concurvity'>Plot concurvity measures</h2><span id='topic+draw.pairwise_concurvity'></span><span id='topic+draw.overall_concurvity'></span>

<h3>Description</h3>

<p>Plot concurvity measures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pairwise_concurvity'
draw(
  object,
  title = "Smooth-wise concurvity",
  subtitle = NULL,
  caption = NULL,
  x_lab = "Term",
  y_lab = "With",
  fill_lab = "Concurvity",
  continuous_colour = NULL,
  ...
)

## S3 method for class 'overall_concurvity'
draw(
  object,
  title = "Overall concurvity",
  subtitle = NULL,
  caption = NULL,
  y_lab = "Concurvity",
  x_lab = NULL,
  bar_col = "steelblue",
  bar_fill = "steelblue",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw.pairwise_concurvity_+3A_object">object</code></td>
<td>
<p>An object inheriting from class <code>"concurvity"</code>, usually the
result of a call to <code><a href="#topic+model_concurvity">model_concurvity()</a></code> or its abbreviated form
<code><a href="#topic+concrvity">concrvity()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.pairwise_concurvity_+3A_title">title</code></td>
<td>
<p>character; the plot title.</p>
</td></tr>
<tr><td><code id="draw.pairwise_concurvity_+3A_subtitle">subtitle</code></td>
<td>
<p>character; the plot subtitle.</p>
</td></tr>
<tr><td><code id="draw.pairwise_concurvity_+3A_caption">caption</code></td>
<td>
<p>character; the plot caption</p>
</td></tr>
<tr><td><code id="draw.pairwise_concurvity_+3A_x_lab">x_lab</code></td>
<td>
<p>character; the label for the x axis.</p>
</td></tr>
<tr><td><code id="draw.pairwise_concurvity_+3A_y_lab">y_lab</code></td>
<td>
<p>character; the label for the y axis.</p>
</td></tr>
<tr><td><code id="draw.pairwise_concurvity_+3A_fill_lab">fill_lab</code></td>
<td>
<p>character; the label to use for the fill guide.</p>
</td></tr>
<tr><td><code id="draw.pairwise_concurvity_+3A_continuous_colour">continuous_colour</code></td>
<td>
<p>function; continuous colour (fill) scale to use.</p>
</td></tr>
<tr><td><code id="draw.pairwise_concurvity_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="draw.pairwise_concurvity_+3A_bar_col">bar_col</code></td>
<td>
<p>colour specification for the bar colour.</p>
</td></tr>
<tr><td><code id="draw.pairwise_concurvity_+3A_bar_fill">bar_fill</code></td>
<td>
<p>colour specification for the bar fill</p>
</td></tr>
</table>

<hr>
<h2 id='draw.parametric_effects'>Plot estimated effects for model parametric terms</h2><span id='topic+draw.parametric_effects'></span>

<h3>Description</h3>

<p>Plot estimated effects for model parametric terms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'parametric_effects'
draw(
  object,
  scales = c("free", "fixed"),
  ci_level = 0.95,
  ci_col = "black",
  ci_alpha = 0.2,
  line_col = "black",
  constant = NULL,
  fun = NULL,
  rug = TRUE,
  position = "identity",
  angle = NULL,
  ...,
  ncol = NULL,
  nrow = NULL,
  guides = "keep"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw.parametric_effects_+3A_object">object</code></td>
<td>
<p>a fitted GAM, the result of a call to <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.parametric_effects_+3A_scales">scales</code></td>
<td>
<p>character; should all univariate smooths be plotted with the
same y-axis scale? If <code>scales = "free"</code>, the default, each univariate
smooth has its own y-axis scale. If <code>scales = "fixed"</code>, a common y axis
scale is used for all univariate smooths.
</p>
<p>Currently does not affect the y-axis scale of plots of the parametric
terms.</p>
</td></tr>
<tr><td><code id="draw.parametric_effects_+3A_ci_level">ci_level</code></td>
<td>
<p>numeric between 0 and 1; the coverage of credible interval.</p>
</td></tr>
<tr><td><code id="draw.parametric_effects_+3A_ci_col">ci_col</code></td>
<td>
<p>colour specification for the confidence/credible intervals
band. Affects the fill of the interval.</p>
</td></tr>
<tr><td><code id="draw.parametric_effects_+3A_ci_alpha">ci_alpha</code></td>
<td>
<p>numeric; alpha transparency for confidence or simultaneous
interval.</p>
</td></tr>
<tr><td><code id="draw.parametric_effects_+3A_line_col">line_col</code></td>
<td>
<p>colour specification used for regression lines of linear
continuous terms.</p>
</td></tr>
<tr><td><code id="draw.parametric_effects_+3A_constant">constant</code></td>
<td>
<p>numeric; a constant to add to the estimated values of the
smooth. <code>constant</code>, if supplied, will be added to the estimated value
before the confidence band is computed.</p>
</td></tr>
<tr><td><code id="draw.parametric_effects_+3A_fun">fun</code></td>
<td>
<p>function; a function that will be applied to the estimated values
and confidence interval before plotting. Can be a function or the name of a
function. Function <code>fun</code> will be applied after adding any <code>constant</code>, if
provided.</p>
</td></tr>
<tr><td><code id="draw.parametric_effects_+3A_rug">rug</code></td>
<td>
<p>logical; draw a rug plot at the bottom of each plot for 1-D
smooths or plot locations of data for higher dimensions.</p>
</td></tr>
<tr><td><code id="draw.parametric_effects_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a
call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="draw.parametric_effects_+3A_angle">angle</code></td>
<td>
<p>numeric; the angle at which the x axis tick labels are to be
drawn passed to the <code>angle</code> argument of <code><a href="ggplot2.html#topic+guide_axis">ggplot2::guide_axis()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.parametric_effects_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="patchwork.html#topic+wrap_plots">patchwork::wrap_plots()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.parametric_effects_+3A_ncol">ncol</code>, <code id="draw.parametric_effects_+3A_nrow">nrow</code></td>
<td>
<p>numeric; the numbers of rows and columns over which to
spread the plots</p>
</td></tr>
<tr><td><code id="draw.parametric_effects_+3A_guides">guides</code></td>
<td>
<p>character; one of <code>"keep"</code> (the default), <code>"collect"</code>, or
<code>"auto"</code>. Passed to <code><a href="patchwork.html#topic+plot_layout">patchwork::plot_layout()</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='draw.penalty_df'>Display penalty matrices of smooths using <code>ggplot</code></h2><span id='topic+draw.penalty_df'></span>

<h3>Description</h3>

<p>Displays the penalty matrices of smooths as a heatmap using <code>ggplot</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'penalty_df'
draw(
  object,
  normalize = FALSE,
  as_matrix = TRUE,
  continuous_fill = NULL,
  xlab = NULL,
  ylab = NULL,
  title = NULL,
  subtitle = NULL,
  caption = NULL,
  ncol = NULL,
  nrow = NULL,
  guides = "keep",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw.penalty_df_+3A_object">object</code></td>
<td>
<p>a fitted GAM, the result of a call to <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.penalty_df_+3A_normalize">normalize</code></td>
<td>
<p>logical; normalize the penalty to the range -1, 1?</p>
</td></tr>
<tr><td><code id="draw.penalty_df_+3A_as_matrix">as_matrix</code></td>
<td>
<p>logical; how should the plotted penalty matrix be oriented?
If <code>TRUE</code> row 1, column 1 of the penalty matrix is draw in the upper left,
whereas, if <code>FALSE</code> it is drawn in the lower left of the plot.</p>
</td></tr>
<tr><td><code id="draw.penalty_df_+3A_continuous_fill">continuous_fill</code></td>
<td>
<p>a suitable fill scale to be used when plotting
continuous variables.</p>
</td></tr>
<tr><td><code id="draw.penalty_df_+3A_xlab">xlab</code></td>
<td>
<p>character or expression; the label for the x axis. If not
supplied, no axis label will be drawn. May be a vector, one per penalty.</p>
</td></tr>
<tr><td><code id="draw.penalty_df_+3A_ylab">ylab</code></td>
<td>
<p>character or expression; the label for the y axis.  If not
supplied, no axis label will be drawn. May be a vector, one per penalty.</p>
</td></tr>
<tr><td><code id="draw.penalty_df_+3A_title">title</code></td>
<td>
<p>character or expression; the title for the plot. See
<code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>. May be a vector, one per penalty.</p>
</td></tr>
<tr><td><code id="draw.penalty_df_+3A_subtitle">subtitle</code></td>
<td>
<p>character or expression; the subtitle for the plot. See
<code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>. May be a vector, one per penalty.</p>
</td></tr>
<tr><td><code id="draw.penalty_df_+3A_caption">caption</code></td>
<td>
<p>character or expression; the plot caption. See
<code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>. May be a vector, one per penalty.</p>
</td></tr>
<tr><td><code id="draw.penalty_df_+3A_ncol">ncol</code>, <code id="draw.penalty_df_+3A_nrow">nrow</code></td>
<td>
<p>numeric; the numbers of rows and columns over which to
spread the plots.</p>
</td></tr>
<tr><td><code id="draw.penalty_df_+3A_guides">guides</code></td>
<td>
<p>character; one of <code>"keep"</code> (the default), <code>"collect"</code>, or
<code>"auto"</code>. Passed to <code><a href="patchwork.html#topic+plot_layout">patchwork::plot_layout()</a></code></p>
</td></tr>
<tr><td><code id="draw.penalty_df_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="patchwork.html#topic+wrap_plots">patchwork::wrap_plots()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()
dat &lt;- data_sim("eg4", n = 400, seed = 42)
m &lt;- gam(y ~ s(x0) + s(x1, bs = "cr") + s(x2, bs = "bs", by = fac),
  data = dat, method = "REML"
)

## produce a multi-panel plot of all penalties
draw(penalty(m))

# for a specific smooth
draw(penalty(m, select = "s(x2):fac1"))
</code></pre>

<hr>
<h2 id='draw.rootogram'>Draw a rootogram</h2><span id='topic+draw.rootogram'></span>

<h3>Description</h3>

<p>A rootogram is a model diagnostic tool that assesses the goodness of fit of
a statistical model. The observed values of the response are compared with
those expected from the fitted model. For discrete, count responses, the
frequency of each count (0, 1, 2, etc) in the observed data and expected
from the conditional distribution of the response implied by the model are
compared. For continuous variables, the observed and expected frequencies
are obtained by grouping the data into bins. The rootogram is drawn using
<code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code> graphics. The design closely follows Kleiber &amp; Zeileis
(2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rootogram'
draw(
  object,
  type = c("hanging", "standing", "suspended"),
  sqrt = TRUE,
  ref_line = TRUE,
  warn_limits = TRUE,
  fitted_colour = "steelblue",
  bar_colour = NA,
  bar_fill = "grey",
  ref_line_colour = "black",
  warn_line_colour = "black",
  ylab = NULL,
  xlab = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw.rootogram_+3A_object">object</code></td>
<td>
<p>and R object to plot.</p>
</td></tr>
<tr><td><code id="draw.rootogram_+3A_type">type</code></td>
<td>
<p>character; the type of rootogram to draw.</p>
</td></tr>
<tr><td><code id="draw.rootogram_+3A_sqrt">sqrt</code></td>
<td>
<p>logical; show the observed and fitted frequencies</p>
</td></tr>
<tr><td><code id="draw.rootogram_+3A_ref_line">ref_line</code></td>
<td>
<p>logical; draw a reference line at zero?</p>
</td></tr>
<tr><td><code id="draw.rootogram_+3A_warn_limits">warn_limits</code></td>
<td>
<p>logical; draw Tukey's warning limit lines at +/- 1?</p>
</td></tr>
<tr><td><code id="draw.rootogram_+3A_fitted_colour">fitted_colour</code>, <code id="draw.rootogram_+3A_bar_colour">bar_colour</code>, <code id="draw.rootogram_+3A_bar_fill">bar_fill</code>, <code id="draw.rootogram_+3A_ref_line_colour">ref_line_colour</code>, <code id="draw.rootogram_+3A_warn_line_colour">warn_line_colour</code></td>
<td>
<p>colours used to draw the respective element of the rootogram.</p>
</td></tr>
<tr><td><code id="draw.rootogram_+3A_xlab">xlab</code>, <code id="draw.rootogram_+3A_ylab">ylab</code></td>
<td>
<p>character; labels for the x and y axis of the rootogram.
May be missing (<code>NULL</code>), in which case suitable labels will be used.
'</p>
</td></tr>
<tr><td><code id="draw.rootogram_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'ggplot' object.
</p>


<h3>References</h3>

<p>Kleiber, C., Zeileis, A., (2016) Visualizing Count Data
Regressions Using Rootograms. <em>Am. Stat.</em> <strong>70</strong>, 296–303.
<a href="https://doi.org/10.1080/00031305.2016.1173590">doi:10.1080/00031305.2016.1173590</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rootogram">rootogram()</a></code> to compute the data for the rootogram.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()
df &lt;- data_sim("eg1", n = 1000, dist = "poisson", scale = 0.1, seed = 6)

# A poisson example
m &lt;- gam(y ~ s(x0, bs = "cr") + s(x1, bs = "cr") + s(x2, bs = "cr") +
  s(x3, bs = "cr"), family = poisson(), data = df, method = "REML")
rg &lt;- rootogram(m)

# plot the rootogram
draw(rg)

# change the type of rootogram
draw(rg, type = "suspended")
</code></pre>

<hr>
<h2 id='draw.smooth_estimates'>Plot the result of a call to <code>smooth_estimates()</code></h2><span id='topic+draw.smooth_estimates'></span>

<h3>Description</h3>

<p>Plot the result of a call to <code>smooth_estimates()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smooth_estimates'
draw(
  object,
  constant = NULL,
  fun = NULL,
  contour = TRUE,
  grouped_by = FALSE,
  contour_col = "black",
  n_contour = NULL,
  ci_alpha = 0.2,
  ci_col = "black",
  smooth_col = "black",
  resid_col = "steelblue3",
  decrease_col = "#56B4E9",
  increase_col = "#E69F00",
  change_lwd = 1.75,
  partial_match = FALSE,
  discrete_colour = NULL,
  discrete_fill = NULL,
  continuous_colour = NULL,
  continuous_fill = NULL,
  angle = NULL,
  ylim = NULL,
  crs = NULL,
  default_crs = NULL,
  lims_method = "cross",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw.smooth_estimates_+3A_object">object</code></td>
<td>
<p>a fitted GAM, the result of a call to <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.smooth_estimates_+3A_constant">constant</code></td>
<td>
<p>numeric; a constant to add to the estimated values of the
smooth. <code>constant</code>, if supplied, will be added to the estimated value
before the confidence band is computed.</p>
</td></tr>
<tr><td><code id="draw.smooth_estimates_+3A_fun">fun</code></td>
<td>
<p>function; a function that will be applied to the estimated values
and confidence interval before plotting. Can be a function or the name of a
function. Function <code>fun</code> will be applied after adding any <code>constant</code>, if
provided.</p>
</td></tr>
<tr><td><code id="draw.smooth_estimates_+3A_contour">contour</code></td>
<td>
<p>logical; should contours be draw on the plot using
<code><a href="ggplot2.html#topic+geom_contour">ggplot2::geom_contour()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.smooth_estimates_+3A_grouped_by">grouped_by</code></td>
<td>
<p>logical; should factor by smooths be drawn as one panel
per level of the factor (<code>FALSE</code>, the default), or should the individual
smooths be combined into a single panel containing all levels (<code>TRUE</code>)?</p>
</td></tr>
<tr><td><code id="draw.smooth_estimates_+3A_contour_col">contour_col</code></td>
<td>
<p>colour specification for contour lines.</p>
</td></tr>
<tr><td><code id="draw.smooth_estimates_+3A_n_contour">n_contour</code></td>
<td>
<p>numeric; the number of contour bins. Will result in
<code>n_contour - 1</code> contour lines being drawn. See <code><a href="ggplot2.html#topic+geom_contour">ggplot2::geom_contour()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.smooth_estimates_+3A_ci_alpha">ci_alpha</code></td>
<td>
<p>numeric; alpha transparency for confidence or simultaneous
interval.</p>
</td></tr>
<tr><td><code id="draw.smooth_estimates_+3A_ci_col">ci_col</code></td>
<td>
<p>colour specification for the confidence/credible intervals
band. Affects the fill of the interval.</p>
</td></tr>
<tr><td><code id="draw.smooth_estimates_+3A_smooth_col">smooth_col</code></td>
<td>
<p>colour specification for the smooth line.</p>
</td></tr>
<tr><td><code id="draw.smooth_estimates_+3A_resid_col">resid_col</code></td>
<td>
<p>colour specification for the partial residuals.</p>
</td></tr>
<tr><td><code id="draw.smooth_estimates_+3A_decrease_col">decrease_col</code>, <code id="draw.smooth_estimates_+3A_increase_col">increase_col</code></td>
<td>
<p>colour specifications to use for
indicating periods of change. <code>col_change</code> is used when
<code>change_type = "change"</code>, while <code>col_decrease</code> and <code>col_increase</code> are used
when 'change_type = &quot;sizer&quot;&ldquo;.</p>
</td></tr>
<tr><td><code id="draw.smooth_estimates_+3A_change_lwd">change_lwd</code></td>
<td>
<p>numeric; the value to set the <code>linewidth</code> to in
<code><a href="ggplot2.html#topic+geom_path">ggplot2::geom_line()</a></code>, used to represent the periods of change.</p>
</td></tr>
<tr><td><code id="draw.smooth_estimates_+3A_partial_match">partial_match</code></td>
<td>
<p>logical; should smooths be selected by partial matches
with <code>select</code>? If <code>TRUE</code>, <code>select</code> can only be a single string to match
against.</p>
</td></tr>
<tr><td><code id="draw.smooth_estimates_+3A_discrete_colour">discrete_colour</code></td>
<td>
<p>a suitable colour scale to be used when plotting
discrete variables.</p>
</td></tr>
<tr><td><code id="draw.smooth_estimates_+3A_discrete_fill">discrete_fill</code></td>
<td>
<p>a suitable fill scale to be used when plotting
discrete variables.</p>
</td></tr>
<tr><td><code id="draw.smooth_estimates_+3A_continuous_colour">continuous_colour</code></td>
<td>
<p>a suitable colour scale to be used when plotting
continuous variables.</p>
</td></tr>
<tr><td><code id="draw.smooth_estimates_+3A_continuous_fill">continuous_fill</code></td>
<td>
<p>a suitable fill scale to be used when plotting
continuous variables.</p>
</td></tr>
<tr><td><code id="draw.smooth_estimates_+3A_angle">angle</code></td>
<td>
<p>numeric; the angle at which the x axis tick labels are to be
drawn passed to the <code>angle</code> argument of <code><a href="ggplot2.html#topic+guide_axis">ggplot2::guide_axis()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.smooth_estimates_+3A_ylim">ylim</code></td>
<td>
<p>numeric; vector of y axis limits to use all <em>all</em> panels drawn.</p>
</td></tr>
<tr><td><code id="draw.smooth_estimates_+3A_crs">crs</code></td>
<td>
<p>the coordinate reference system (CRS) to use for the plot. All
data will be projected into this CRS. See <code><a href="ggplot2.html#topic+ggsf">ggplot2::coord_sf()</a></code> for
details.</p>
</td></tr>
<tr><td><code id="draw.smooth_estimates_+3A_default_crs">default_crs</code></td>
<td>
<p>the coordinate reference system (CRS) to use for the
non-sf layers in the plot. If left at the default <code>NULL</code>, the CRS used is
4326 (WGS84), which is appropriate for spline-on-the-sphere smooths, which
are parameterized in terms of latitude and longitude as coordinates. See
<code><a href="ggplot2.html#topic+ggsf">ggplot2::coord_sf()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="draw.smooth_estimates_+3A_lims_method">lims_method</code></td>
<td>
<p>character; affects how the axis limits are determined. See
<code><a href="ggplot2.html#topic+ggsf">ggplot2::coord_sf()</a></code>. Be careful; in testing of some examples, changing
this to <code>"orthogonal"</code> for example with the chlorophyll-a example from
Simon Wood's GAM book quickly used up all the RAM in my test system and the
OS killed R. This could be incorrect usage on my part; right now the grid
of points at which SOS smooths are evaluated (if not supplied by the user)
can produce invalid coordinates for the corners of tiles as the grid is
generated for tile centres without respect to the spacing of those tiles.</p>
</td></tr>
<tr><td><code id="draw.smooth_estimates_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="patchwork.html#topic+wrap_plots">patchwork::wrap_plots()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()
# example data
df &lt;- data_sim("eg1", seed = 21)
# fit GAM
m &lt;- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = "REML")
# plot all of the estimated smooths
sm &lt;- smooth_estimates(m)
draw(sm)
# evaluate smooth of `x2`
sm &lt;- smooth_estimates(m, select = "s(x2)")
# plot it
draw(sm)

# customising some plot elements
draw(sm, ci_col = "steelblue", smooth_col = "forestgreen", ci_alpha = 0.3)

# Add a constant to the plotted smooth
draw(sm, constant = coef(m)[1])

# Adding change indicators to smooths based on derivatives of the smooth
d &lt;- derivatives(m, n = 100) # n to match smooth_estimates()

smooth_estimates(m) |&gt;
  add_sizer(derivatives = d, type = "sizer") |&gt;
  draw()
</code></pre>

<hr>
<h2 id='draw.smooth_samples'>Plot posterior smooths</h2><span id='topic+draw.smooth_samples'></span>

<h3>Description</h3>

<p>Plot posterior smooths
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smooth_samples'
draw(
  object,
  select = NULL,
  n_samples = NULL,
  seed = NULL,
  xlab = NULL,
  ylab = NULL,
  title = NULL,
  subtitle = NULL,
  caption = NULL,
  alpha = 1,
  colour = "black",
  contour = FALSE,
  contour_col = "black",
  n_contour = NULL,
  scales = c("free", "fixed"),
  rug = TRUE,
  partial_match = FALSE,
  angle = NULL,
  ncol = NULL,
  nrow = NULL,
  guides = "keep",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw.smooth_samples_+3A_object">object</code></td>
<td>
<p>a fitted GAM, the result of a call to <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.smooth_samples_+3A_select">select</code></td>
<td>
<p>character, logical, or numeric; which smooths to plot. If
<code>NULL</code>, the default, then all model smooths are drawn. Numeric <code>select</code>
indexes the smooths in the order they are specified in the formula and
stored in <code>object</code>. Character <code>select</code> matches the labels for smooths
as shown for example in the output from <code>summary(object)</code>. Logical
<code>select</code> operates as per numeric <code>select</code> in the order that smooths are
stored.</p>
</td></tr>
<tr><td><code id="draw.smooth_samples_+3A_n_samples">n_samples</code></td>
<td>
<p>numeric; if not <code>NULL</code>, sample <code>n_samples</code> from the
posterior draws for plotting.</p>
</td></tr>
<tr><td><code id="draw.smooth_samples_+3A_seed">seed</code></td>
<td>
<p>numeric; random seed to be used to if sampling draws.</p>
</td></tr>
<tr><td><code id="draw.smooth_samples_+3A_xlab">xlab</code></td>
<td>
<p>character or expression; the label for the x axis. If not
supplied, a suitable label will be generated from <code>object</code>.</p>
</td></tr>
<tr><td><code id="draw.smooth_samples_+3A_ylab">ylab</code></td>
<td>
<p>character or expression; the label for the y axis. If not
supplied, a suitable label will be generated from <code>object</code>.</p>
</td></tr>
<tr><td><code id="draw.smooth_samples_+3A_title">title</code></td>
<td>
<p>character or expression; the title for the plot. See
<code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.smooth_samples_+3A_subtitle">subtitle</code></td>
<td>
<p>character or expression; the subtitle for the plot. See
<code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.smooth_samples_+3A_caption">caption</code></td>
<td>
<p>character or expression; the plot caption. See
<code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.smooth_samples_+3A_alpha">alpha</code></td>
<td>
<p>numeric; alpha transparency for confidence or simultaneous
interval.</p>
</td></tr>
<tr><td><code id="draw.smooth_samples_+3A_colour">colour</code></td>
<td>
<p>The colour to use to draw the posterior smooths. Passed to
<code><a href="ggplot2.html#topic+geom_path">ggplot2::geom_line()</a></code> as argument <code>colour</code>.</p>
</td></tr>
<tr><td><code id="draw.smooth_samples_+3A_contour">contour</code></td>
<td>
<p>logical; should contour lines be added to smooth surfaces?</p>
</td></tr>
<tr><td><code id="draw.smooth_samples_+3A_contour_col">contour_col</code></td>
<td>
<p>colour specification for contour lines.</p>
</td></tr>
<tr><td><code id="draw.smooth_samples_+3A_n_contour">n_contour</code></td>
<td>
<p>numeric; the number of contour bins. Will result in
<code>n_contour - 1</code> contour lines being drawn. See <code><a href="ggplot2.html#topic+geom_contour">ggplot2::geom_contour()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.smooth_samples_+3A_scales">scales</code></td>
<td>
<p>character; should all univariate smooths be plotted with the
same y-axis scale? If <code>scales = "free"</code>, the default, each univariate
smooth has its own y-axis scale. If <code>scales = "fixed"</code>, a common y axis
scale is used for all univariate smooths.
</p>
<p>Currently does not affect the y-axis scale of plots of the parametric
terms.</p>
</td></tr>
<tr><td><code id="draw.smooth_samples_+3A_rug">rug</code></td>
<td>
<p>logical; draw a rug plot at the bottom of each plot for 1-D
smooths or plot locations of data for higher dimensions.</p>
</td></tr>
<tr><td><code id="draw.smooth_samples_+3A_partial_match">partial_match</code></td>
<td>
<p>logical; should smooths be selected by partial matches
with <code>select</code>? If <code>TRUE</code>, <code>select</code> can only be a single string to match
against.</p>
</td></tr>
<tr><td><code id="draw.smooth_samples_+3A_angle">angle</code></td>
<td>
<p>numeric; the angle at which the x axis tick labels are to be
drawn passed to the <code>angle</code> argument of <code><a href="ggplot2.html#topic+guide_axis">ggplot2::guide_axis()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.smooth_samples_+3A_ncol">ncol</code>, <code id="draw.smooth_samples_+3A_nrow">nrow</code></td>
<td>
<p>numeric; the numbers of rows and columns over which to
spread the plots</p>
</td></tr>
<tr><td><code id="draw.smooth_samples_+3A_guides">guides</code></td>
<td>
<p>character; one of <code>"keep"</code> (the default), <code>"collect"</code>, or
<code>"auto"</code>. Passed to <code><a href="patchwork.html#topic+plot_layout">patchwork::plot_layout()</a></code></p>
</td></tr>
<tr><td><code id="draw.smooth_samples_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code><a href="patchwork.html#topic+wrap_plots">patchwork::wrap_plots()</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()
dat1 &lt;- data_sim("eg1", n = 400, dist = "normal", scale = 1, seed = 1)
## a single smooth GAM
m1 &lt;- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat1, method = "REML")
## posterior smooths from m1
sm1 &lt;- smooth_samples(m1, n = 15, seed = 23478)
## plot
draw(sm1, alpha = 0.7)
## plot only 5 randomly smapled draws
draw(sm1, n_samples = 5, alpha = 0.7)

## A factor-by smooth example
dat2 &lt;- data_sim("eg4", n = 400, dist = "normal", scale = 1, seed = 1)
## a multi-smooth GAM with a factor-by smooth
m2 &lt;- gam(y ~ fac + s(x2, by = fac) + s(x0), data = dat2, method = "REML")
## posterior smooths from m1
sm2 &lt;- smooth_samples(m2, n = 15, seed = 23478)
## plot, this time selecting only the factor-by smooth
draw(sm2, select = "s(x2)", partial_match = TRUE, alpha = 0.7)


## A 2D smooth example
dat3 &lt;- data_sim("eg2", n = 400, dist = "normal", scale = 1, seed = 1)
## fit a 2D smooth
m3 &lt;- gam(y ~ te(x, z), data = dat3, method = "REML")
## get samples
sm3 &lt;- smooth_samples(m3, n = 10)
## plot just 6 of the draws, with contour line overlays
draw(sm3, n_samples = 6, contour = TRUE, seed = 42)

</code></pre>

<hr>
<h2 id='edf'>Effective degrees of freedom for smooths and GAMs</h2><span id='topic+edf'></span><span id='topic+edf.gam'></span><span id='topic+model_edf'></span>

<h3>Description</h3>

<p>Extracts the effective degrees of freedom (EDF) for model smooth terms or
overall EDF for fitted GAMs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edf(object, ...)

## S3 method for class 'gam'
edf(
  object,
  select = NULL,
  smooth = deprecated(),
  type = c("default", "unconditional", "alternative"),
  partial_match = FALSE,
  ...
)

model_edf(object, ..., type = c("default", "unconditional", "alternative"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edf_+3A_object">object</code></td>
<td>
<p>a fitted model from which to extract smooth-specific EDFs.</p>
</td></tr>
<tr><td><code id="edf_+3A_...">...</code></td>
<td>
<p>arguments passed to methods.</p>
</td></tr>
<tr><td><code id="edf_+3A_select">select</code></td>
<td>
<p>character, logical, or numeric; which smooths to plot. If
<code>NULL</code>, the default, then all model smooths are drawn. Numeric <code>select</code>
indexes the smooths in the order they are specified in the formula and
stored in <code>object</code>. Character <code>select</code> matches the labels for smooths
as shown for example in the output from <code>summary(object)</code>. Logical
<code>select</code> operates as per numeric <code>select</code> in the order that smooths are
stored.</p>
</td></tr>
<tr><td><code id="edf_+3A_smooth">smooth</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>select</code> instead.
extracted. If <code>NULL</code>, the default, EDFs for all smooths will be returned.</p>
</td></tr>
<tr><td><code id="edf_+3A_type">type</code></td>
<td>
<p>character: which type of EDF to return. <code>"default"</code> returns the
standard EDF; <code>"unconditional"</code> selects the EDF corrected for smoothness
parameter selection, if available; <code>"alternative"</code> returns the alternative
formulation for EDF from Wood (2017, pp. 252)</p>
</td></tr>
<tr><td><code id="edf_+3A_partial_match">partial_match</code></td>
<td>
<p>logical; should smooths be selected by partial matches
with <code>select</code>? If <code>TRUE</code>, <code>select</code> can only be a single string to match
against.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multiple formulations for the effective degrees of freedom are
available. The additional uncertainty due to selection of smoothness
parameters can be taken into account when computing the EDF of smooths.
This form of the EDF is available with <code>type = "unconditional"</code>.
</p>
<p>Wood (2017; pp. 252) describes an alternative EDF for the  model
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{EDF} = 2\mathrm{tr}(\mathbf{F}) -
  \mathrm{tr}(\mathbf{FF}),</code>
</p>
<p> where
<code class="reqn">\mathrm{tr}</code> is the matrix trace and <code class="reqn">\mathbf{F}</code> is a matrix
mapping un-penalized coefficient estimates to the penalized coefficient
estimates.  The trace of <code class="reqn">\mathbf{F}</code> is effectively the average
shrinkage of the coefficients multipled by the number of coefficients
(Wood, 2017). Smooth-specific EDFs then are obtained by summing up the
relevent elements of <code class="reqn">\mathrm{diag}(2\mathbf{F} - \mathbf{FF})</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()

df &lt;- data_sim("eg1", n = 400, seed = 42)
m &lt;- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = "REML")

# extract the EDFs for all smooths
edf(m)

# or selected smooths
edf(m, select = c("s(x0)", "s(x2)"))

# accounting for smoothness parameter uncertainty
edf(m, type = "unconditional")

# over EDF of the model, including the intercept
model_edf(m)

# can get model EDF for multiple models
m2 &lt;- gam(y ~ s(x0) + s(x1) + s(x3), data = df, method = "REML")
model_edf(m, m2)

</code></pre>

<hr>
<h2 id='eval_smooth'>S3 methods to evaluate individual smooths</h2><span id='topic+eval_smooth'></span><span id='topic+eval_smooth.mgcv.smooth'></span><span id='topic+eval_smooth.soap.film'></span><span id='topic+eval_smooth.scam_smooth'></span><span id='topic+eval_smooth.fs.interaction'></span><span id='topic+eval_smooth.sz.interaction'></span><span id='topic+eval_smooth.random.effect'></span><span id='topic+eval_smooth.mrf.smooth'></span><span id='topic+eval_smooth.t2.smooth'></span><span id='topic+eval_smooth.tensor.smooth'></span>

<h3>Description</h3>

<p>S3 methods to evaluate individual smooths
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_smooth(smooth, ...)

## S3 method for class 'mgcv.smooth'
eval_smooth(
  smooth,
  model,
  n = 100,
  n_3d = NULL,
  n_4d = NULL,
  data = NULL,
  unconditional = FALSE,
  overall_uncertainty = TRUE,
  dist = NULL,
  ...
)

## S3 method for class 'soap.film'
eval_smooth(
  smooth,
  model,
  n = 100,
  n_3d = NULL,
  n_4d = NULL,
  data = NULL,
  unconditional = FALSE,
  overall_uncertainty = TRUE,
  ...
)

## S3 method for class 'scam_smooth'
eval_smooth(
  smooth,
  model,
  n = 100,
  n_3d = NULL,
  n_4d = NULL,
  data = NULL,
  unconditional = FALSE,
  overall_uncertainty = TRUE,
  dist = NULL,
  ...
)

## S3 method for class 'fs.interaction'
eval_smooth(
  smooth,
  model,
  n = 100,
  data = NULL,
  unconditional = FALSE,
  overall_uncertainty = TRUE,
  ...
)

## S3 method for class 'sz.interaction'
eval_smooth(
  smooth,
  model,
  n = 100,
  data = NULL,
  unconditional = FALSE,
  overall_uncertainty = TRUE,
  ...
)

## S3 method for class 'random.effect'
eval_smooth(
  smooth,
  model,
  n = 100,
  data = NULL,
  unconditional = FALSE,
  overall_uncertainty = TRUE,
  ...
)

## S3 method for class 'mrf.smooth'
eval_smooth(
  smooth,
  model,
  n = 100,
  data = NULL,
  unconditional = FALSE,
  overall_uncertainty = TRUE,
  ...
)

## S3 method for class 't2.smooth'
eval_smooth(
  smooth,
  model,
  n = 100,
  n_3d = NULL,
  n_4d = NULL,
  data = NULL,
  unconditional = FALSE,
  overall_uncertainty = TRUE,
  dist = NULL,
  ...
)

## S3 method for class 'tensor.smooth'
eval_smooth(
  smooth,
  model,
  n = 100,
  n_3d = NULL,
  n_4d = NULL,
  data = NULL,
  unconditional = FALSE,
  overall_uncertainty = TRUE,
  dist = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_smooth_+3A_smooth">smooth</code></td>
<td>
<p>currently an object that inherits from class <code>mgcv.smooth</code>.</p>
</td></tr>
<tr><td><code id="eval_smooth_+3A_...">...</code></td>
<td>
<p>arguments assed to other methods</p>
</td></tr>
<tr><td><code id="eval_smooth_+3A_model">model</code></td>
<td>
<p>a fitted model; currently only <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code> and <code><a href="mgcv.html#topic+bam">mgcv::bam()</a></code>
models are suported.</p>
</td></tr>
<tr><td><code id="eval_smooth_+3A_n">n</code></td>
<td>
<p>numeric; the number of points over the range of the covariate at
which to evaluate the smooth.</p>
</td></tr>
<tr><td><code id="eval_smooth_+3A_n_3d">n_3d</code>, <code id="eval_smooth_+3A_n_4d">n_4d</code></td>
<td>
<p>numeric; the number of points over the range of last
covariate in a 3D or 4D smooth. The default is <code>NULL</code> which achieves the
standard behaviour of using <code>n</code> points over the range of all covariate,
resulting in <code>n^d</code> evaluation points, where <code>d</code> is the dimension of the
smooth. For <code>d &gt; 2</code> this can result in very many evaluation points and slow
performance. For smooths of <code>d &gt; 4</code>, the value of <code>n_4d</code> will be used for
all dimensions <code style="white-space: pre;">&#8288;&gt; 4&#8288;</code>, unless this is <code>NULL</code>, in which case the default
behaviour (using <code>n</code> for all dimensions) will be observed.</p>
</td></tr>
<tr><td><code id="eval_smooth_+3A_data">data</code></td>
<td>
<p>an optional data frame of values to evaluate <code>smooth</code> at.</p>
</td></tr>
<tr><td><code id="eval_smooth_+3A_unconditional">unconditional</code></td>
<td>
<p>logical; should confidence intervals include the
uncertainty due to smoothness selection? If <code>TRUE</code>, the corrected Bayesian
covariance matrix will be used.</p>
</td></tr>
<tr><td><code id="eval_smooth_+3A_overall_uncertainty">overall_uncertainty</code></td>
<td>
<p>logical; should the uncertainty in the model
constant term be included in the standard error of the evaluate values of
the smooth?</p>
</td></tr>
<tr><td><code id="eval_smooth_+3A_dist">dist</code></td>
<td>
<p>numeric; if greater than 0, this is used to determine when
a location is too far from data to be plotted when plotting 2-D smooths.
The data are scaled into the unit square before deciding what to exclude,
and <code>dist</code> is a distance within the unit square. See
<code><a href="mgcv.html#topic+exclude.too.far">mgcv::exclude.too.far()</a></code> for further details.</p>
</td></tr>
</table>

<hr>
<h2 id='evaluate_parametric_term'>Evaluate parametric model terms</h2><span id='topic+evaluate_parametric_term'></span><span id='topic+evaluate_parametric_term.gam'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Returns values of parametric model terms
at values of factor terms and over a grid of covariate values for linear
parametric terms. This function is now deprecated in favour of
<code><a href="#topic+parametric_effects">parametric_effects()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_parametric_term(object, ...)

## S3 method for class 'gam'
evaluate_parametric_term(object, term, unconditional = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_parametric_term_+3A_object">object</code></td>
<td>
<p>an object of class <code>"gam"</code> or <code>"gamm"</code>.</p>
</td></tr>
<tr><td><code id="evaluate_parametric_term_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="evaluate_parametric_term_+3A_term">term</code></td>
<td>
<p>character; which parametric term whose effects are evaluated</p>
</td></tr>
<tr><td><code id="evaluate_parametric_term_+3A_unconditional">unconditional</code></td>
<td>
<p>logical; should confidence intervals include the
uncertainty due to smoothness selection? If <code>TRUE</code>, the corrected Bayesian
covariance matrix will be used.</p>
</td></tr>
</table>

<hr>
<h2 id='evaluate_smooth'>Evaluate a smooth</h2><span id='topic+evaluate_smooth'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Evaluate a smooth at a grid of evenly
spaced value over the range of the covariate associated with the smooth.
Alternatively, a set of points at which the smooth should be evaluated can be
supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_smooth(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_smooth_+3A_object">object</code></td>
<td>
<p>an object of class <code>"gam"</code> or <code>"gamm"</code>.</p>
</td></tr>
<tr><td><code id="evaluate_smooth_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> <code>evaluate_smooth()</code> is deprecated in
favour of <code><a href="#topic+smooth_estimates">smooth_estimates()</a></code>, which provides a cleaner way to evaluate a
smooth over a range of covariate values. <code><a href="#topic+smooth_estimates">smooth_estimates()</a></code> can handle a
much wider range of models than <code>evaluate_smooth()</code> is capable of and
<code><a href="#topic+smooth_estimates">smooth_estimates()</a></code> is much easier to extend to handle new smooth types.
</p>
<p>Most code that uses <code>evaluate_smooth()</code> should work simply by changing the
function call to <code><a href="#topic+smooth_estimates">smooth_estimates()</a></code>. However, there are some differences:
</p>

<ul>
<li><p> the <code>newdata</code> argument becomes <code>data</code>
</p>
</li></ul>



<h3>Value</h3>

<p>A data frame, which is of class <code>"evaluated_1d_smooth"</code> or
<code>evaluated_2d_smooth</code>, which inherit from classes <code>"evaluated_smooth"</code>
and <code>"data.frame"</code>.
</p>

<hr>
<h2 id='evenly'>Create a sequence of evenly-spaced values</h2><span id='topic+evenly'></span><span id='topic+seq_min_max'></span>

<h3>Description</h3>

<p>For a continuous vector <code>x</code>, <code>evenly</code> and <code>seq_min_max()</code>
create a sequence of <code>n</code> evenly-spaced values over the range <code>lower</code>
&ndash; <code>upper</code>. By default, <code>lower</code> is defined as <code>min(x)</code> and <code>upper</code> as
<code>max(x)</code>, excluding <code>NA</code>s. For a factor <code>x</code>, the function returns
<code>levels(x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evenly(x, n = 100, by = NULL, lower = NULL, upper = NULL)

seq_min_max(x, n, by = NULL, lower = NULL, upper = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evenly_+3A_x">x</code></td>
<td>
<p>numeric; vector over which evenly-spaced values are returned</p>
</td></tr>
<tr><td><code id="evenly_+3A_n">n</code></td>
<td>
<p>numeric; the number of evenly-spaced values to return. A default of
<code>100</code> is used for convenience as that what is typically used when
evaluating a smooth.</p>
</td></tr>
<tr><td><code id="evenly_+3A_by">by</code></td>
<td>
<p>numeric; the increment of the sequence. If specified, argument <code>n</code>
is ignored and the sequence returned will be from <code>min(x)</code> to <code>max(x)</code> in
increments of <code>by</code>.</p>
</td></tr>
<tr><td><code id="evenly_+3A_lower">lower</code></td>
<td>
<p>numeric; the lower bound of the interval.</p>
</td></tr>
<tr><td><code id="evenly_+3A_upper">upper</code></td>
<td>
<p>numeric; the upper bound of the interval.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length <code>n</code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="base.html#topic+seq">base::seq()</a></code> for details of the behaviour of <code>evenly()</code> when
using <code>by</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rnorm(10)
n &lt;- 10L

# 10 values evenly over the range of `x`
evenly(x, n = n)

# evenly spaced values, incrementing by 0.2
evenly(x, by = 0.2)

# evenly spaced values, incrementing by 0.2, starting at -2
evenly(x, by = 0.2, lower = -2)
</code></pre>

<hr>
<h2 id='factor_combos'>All combinations of factor levels</h2><span id='topic+factor_combos'></span><span id='topic+factor_combos.gam'></span>

<h3>Description</h3>

<p>All combinations of factor levels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factor_combos(object, ...)

## S3 method for class 'gam'
factor_combos(object, vars = everything(), complete = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factor_combos_+3A_object">object</code></td>
<td>
<p>a fitted model object.</p>
</td></tr>
<tr><td><code id="factor_combos_+3A_...">...</code></td>
<td>
<p>arguments passed to methods.</p>
</td></tr>
<tr><td><code id="factor_combos_+3A_vars">vars</code></td>
<td>
<p>terms to include or exclude from the returned object. Uses
tidyselect principles.</p>
</td></tr>
<tr><td><code id="factor_combos_+3A_complete">complete</code></td>
<td>
<p>logical; should all combinations of factor levels be
returned? If <code>FALSE</code>, only those combinations of levels observed in the
model are retained.</p>
</td></tr>
</table>

<hr>
<h2 id='family_name'>Name of family used to fit model</h2><span id='topic+family_name'></span>

<h3>Description</h3>

<p>Extracts the name of the family used to fit the supplied model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>family_name(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="family_name_+3A_object">object</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="family_name_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector containing the family name.
</p>

<hr>
<h2 id='family_type'>Extracts the type of family in a consistent way</h2><span id='topic+family_type'></span><span id='topic+family_type.family'></span><span id='topic+family_type.default'></span>

<h3>Description</h3>

<p>Extracts the type of family in a consistent way
</p>


<h3>Usage</h3>

<pre><code class='language-R'>family_type(object, ...)

## S3 method for class 'family'
family_type(object, ...)

## Default S3 method:
family_type(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="family_type_+3A_object">object</code></td>
<td>
<p>an R object. Currently <code><a href="stats.html#topic+family">family()</a></code> objects and anything with a
<code><a href="stats.html#topic+family">family()</a></code> method.</p>
</td></tr>
<tr><td><code id="family_type_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='family.gam'>Extract family objects from models</h2><span id='topic+family.gam'></span><span id='topic+family.gamm'></span><span id='topic+family.bam'></span><span id='topic+family.list'></span>

<h3>Description</h3>

<p>Provides a <code><a href="stats.html#topic+family">stats::family()</a></code> method for a range of GAM objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gam'
family(object, ...)

## S3 method for class 'gamm'
family(object, ...)

## S3 method for class 'bam'
family(object, ...)

## S3 method for class 'list'
family(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="family.gam_+3A_object">object</code></td>
<td>
<p>a fitted model. Models fitted by <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code>, <code><a href="mgcv.html#topic+bam">mgcv::bam()</a></code>,
<code><a href="mgcv.html#topic+gamm">mgcv::gamm()</a></code>, and <code><a href="gamm4.html#topic+gamm4">gamm4::gamm4()</a></code> are currently supported.</p>
</td></tr>
<tr><td><code id="family.gam_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='fderiv'>First derivatives of fitted GAM functions</h2><span id='topic+fderiv'></span><span id='topic+fderiv.gam'></span><span id='topic+fderiv.gamm'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This function was deprecated because it was limited to first order forward
finite differences for derivatives only, but couldn't be improved to offer
the needed functionality without breaking backwards compatability with papers
and blog posts that already used <code>fderiv()</code>. A replacement, <code><a href="#topic+derivatives">derivatives()</a></code>,
is now available and recommended for new analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fderiv(model, ...)

## S3 method for class 'gam'
fderiv(
  model,
  newdata,
  term,
  n = 200,
  eps = 1e-07,
  unconditional = FALSE,
  offset = NULL,
  ...
)

## S3 method for class 'gamm'
fderiv(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fderiv_+3A_model">model</code></td>
<td>
<p>A fitted GAM. Currently only models fitted by <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code> and
<code><a href="mgcv.html#topic+gamm">mgcv::gamm()</a></code> are supported.</p>
</td></tr>
<tr><td><code id="fderiv_+3A_...">...</code></td>
<td>
<p>Arguments that are passed to other methods.</p>
</td></tr>
<tr><td><code id="fderiv_+3A_newdata">newdata</code></td>
<td>
<p>a data frame containing the values of the model covariates at
which to evaluate the first derivatives of the smooths.</p>
</td></tr>
<tr><td><code id="fderiv_+3A_term">term</code></td>
<td>
<p>character; vector of one or more terms for which derivatives are
required. If missing, derivatives for all smooth terms will be returned.</p>
</td></tr>
<tr><td><code id="fderiv_+3A_n">n</code></td>
<td>
<p>integer; if <code>newdata</code> is missing the original data can be
reconstructed from <code>model</code> and then <code>n</code> controls the number of values over
the range of each covariate with which to populate <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="fderiv_+3A_eps">eps</code></td>
<td>
<p>numeric; the value of the finite difference used to approximate
the first derivative.</p>
</td></tr>
<tr><td><code id="fderiv_+3A_unconditional">unconditional</code></td>
<td>
<p>logical; if <code>TRUE</code>, the smoothing parameter uncertainty
corrected covariance matrix is used, <em>if available</em>, otherwise the
uncorrected Bayesian posterior covariance matrix is used.</p>
</td></tr>
<tr><td><code id="fderiv_+3A_offset">offset</code></td>
<td>
<p>numeric; value of offset to use in generating predictions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"fderiv"</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()

dat &lt;- data_sim("eg1", seed = 2)
mod &lt;- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")

## first derivatives of all smooths...
fd &lt;- fderiv(mod)
## now use --&gt;
fd &lt;- derivatives(mod)

## ...and a selected smooth
fd2 &lt;- fderiv(mod, term = "x1")
## now use --&gt;
fd2 &lt;- derivatives(mod, select = "s(x1)")

## Models with factors
dat &lt;- data_sim("eg4", n = 400, dist = "normal", scale = 2, seed = 2)
mod &lt;- gam(y ~ s(x0) + s(x1) + fac, data = dat, method = "REML")

## first derivatives of all smooths...
fd &lt;- fderiv(mod)
## now use --&gt;
fd &lt;- derivatives(mod)

## ...and a selected smooth
fd2 &lt;- fderiv(mod, term = "x1")
## now use --&gt;
fd2 &lt;- derivatives(mod, select = "s(x1)")
</code></pre>

<hr>
<h2 id='fitted_samples'>Draw fitted values from the posterior distribution</h2><span id='topic+fitted_samples'></span><span id='topic+fitted_samples.gam'></span>

<h3>Description</h3>

<p>Expectations (fitted values) of the response drawn from the posterior
distribution of fitted model using a Gaussian approximation to the
posterior or a simple Metropolis Hastings sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitted_samples(model, ...)

## S3 method for class 'gam'
fitted_samples(
  model,
  n = 1,
  data = newdata,
  seed = NULL,
  scale = c("response", "linear_predictor"),
  method = c("gaussian", "mh", "inla", "user"),
  n_cores = 1,
  burnin = 1000,
  thin = 1,
  t_df = 40,
  rw_scale = 0.25,
  freq = FALSE,
  unconditional = FALSE,
  draws = NULL,
  ...,
  newdata = NULL,
  ncores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted_samples_+3A_model">model</code></td>
<td>
<p>a fitted model of the supported types</p>
</td></tr>
<tr><td><code id="fitted_samples_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods. For <code>fitted_samples()</code>, these
are passed on to <code><a href="mgcv.html#topic+predict.gam">predict.gam()</a></code>. For <code>posterior_samples()</code> these are
passed on to <code>fitted_samples()</code>. For <code>predicted_samples()</code> these are
passed on to the relevant <code>simulate()</code> method.</p>
</td></tr>
<tr><td><code id="fitted_samples_+3A_n">n</code></td>
<td>
<p>numeric; the number of posterior samples to return.</p>
</td></tr>
<tr><td><code id="fitted_samples_+3A_data">data</code></td>
<td>
<p>data frame; new observations at which the posterior draws
from the model should be evaluated. If not supplied, the data used to fit
the model will be used for <code>data</code>, if available in <code>model</code>.</p>
</td></tr>
<tr><td><code id="fitted_samples_+3A_seed">seed</code></td>
<td>
<p>numeric; a random seed for the simulations.</p>
</td></tr>
<tr><td><code id="fitted_samples_+3A_scale">scale</code></td>
<td>
<p>character; what scale should the fitted values be returned on?
<code>"linear predictor"</code> is a synonym for <code>"link"</code> if you prefer that
terminology.</p>
</td></tr>
<tr><td><code id="fitted_samples_+3A_method">method</code></td>
<td>
<p>character; which method should be used to draw samples from
the posterior distribution. <code>"gaussian"</code> uses a Gaussian (Laplace)
approximation to the posterior. <code>"mh"</code> uses a Metropolis Hastings sampler
that alternates t proposals with proposals based on a shrunken version of
the posterior covariance matrix. <code>"inla"</code> uses a variant of Integrated
Nested Laplace Approximation due to Wood (2019), (currently not
implemented). <code>"user"</code> allows for user-supplied posterior draws
(currently not implemented).</p>
</td></tr>
<tr><td><code id="fitted_samples_+3A_n_cores">n_cores</code></td>
<td>
<p>number of cores for generating random variables from a
multivariate normal distribution. Passed to <code><a href="mvnfast.html#topic+rmvn">mvnfast::rmvn()</a></code>.
Parallelization will take place only if OpenMP is supported (but appears
to work on Windows with current <code>R</code>).</p>
</td></tr>
<tr><td><code id="fitted_samples_+3A_burnin">burnin</code></td>
<td>
<p>numeric; number of samples to discard as the burnin draws.
Only used with <code>method = "mh"</code>.</p>
</td></tr>
<tr><td><code id="fitted_samples_+3A_thin">thin</code></td>
<td>
<p>numeric; the number of samples to skip when taking <code>n</code> draws.
Results in <code>thin * n</code> draws from the posterior being taken. Only used with
<code>method = "mh"</code>.</p>
</td></tr>
<tr><td><code id="fitted_samples_+3A_t_df">t_df</code></td>
<td>
<p>numeric; degrees of freedome for t distribution proposals. Only
used with <code>method = "mh"</code>.</p>
</td></tr>
<tr><td><code id="fitted_samples_+3A_rw_scale">rw_scale</code></td>
<td>
<p>numeric; Factor by which to scale posterior covariance
matrix when generating random walk proposals. Negative or non finite to
skip the random walk step. Only used with <code>method = "mh"</code>.</p>
</td></tr>
<tr><td><code id="fitted_samples_+3A_freq">freq</code></td>
<td>
<p>logical; <code>TRUE</code> to use the frequentist covariance matrix of
the parameter estimators, <code>FALSE</code> to use the Bayesian posterior
covariance matrix of the parameters.</p>
</td></tr>
<tr><td><code id="fitted_samples_+3A_unconditional">unconditional</code></td>
<td>
<p>logical; if <code>TRUE</code> (and <code>freq == FALSE</code>) then the
Bayesian smoothing parameter uncertainty corrected covariance matrix is
used, if available.</p>
</td></tr>
<tr><td><code id="fitted_samples_+3A_draws">draws</code></td>
<td>
<p>matrix; user supplied posterior draws to be used when
<code>method = "user"</code>.</p>
</td></tr>
<tr><td><code id="fitted_samples_+3A_newdata">newdata</code></td>
<td>
<p>Deprecated: use <code>data</code> instead.</p>
</td></tr>
<tr><td><code id="fitted_samples_+3A_ncores">ncores</code></td>
<td>
<p>Deprecated; use <code>n_cores</code> instead. The number of cores for
generating random variables from a multivariate normal distribution.
Passed to <code><a href="mvnfast.html#topic+rmvn">mvnfast::rmvn()</a></code>. Parallelization will take place only if
OpenMP is supported (but appears to work on Windows with current <code>R</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble (data frame) with 3 columns containing the posterior
predicted values in long format. The columns are
</p>

<ul>
<li> <p><code>row</code> (integer) the row of <code>data</code> that each posterior draw relates to,
</p>
</li>
<li> <p><code>draw</code> (integer) an index, in range <code>1:n</code>, indicating which draw each row
relates to,
</p>
</li>
<li> <p><code>response</code> (numeric) the predicted response for the indicated row of
<code>data</code>.
</p>
</li></ul>



<h3>Note</h3>

<p>Models with offset terms supplied via the <code>offset</code> argument to
<code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code> etc. are ignored by <code><a href="mgcv.html#topic+predict.gam">mgcv::predict.gam()</a></code>. As such, this
kind of offset term is also ignored by <code>posterior_samples()</code>. Offset terms
that are included in the model formula supplied to <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code> etc are
not ignored and the posterior samples produced will reflect those offset
term values. This has the side effect of requiring any new data values
provided to <code>posterior_samples()</code> via the <code>data</code> argument must include the
offset variable.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>References</h3>

<p>Wood, S.N., (2020). Simplified integrated nested Laplace approximation.
<em>Biometrika</em> <strong>107</strong>, 223&ndash;230. <a href="https://doi.org/10.1093/biomet/asz044">doi:10.1093/biomet/asz044</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()

dat &lt;- data_sim("eg1", n = 1000, dist = "normal", scale = 2, seed = 2)
m1 &lt;- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")

fs &lt;- fitted_samples(m1, n = 5, seed = 42)

fs


# can generate own set of draws and use them
drws &lt;- generate_draws(m1, n = 2, seed = 24)
fs2 &lt;- fitted_samples(m1, method = "user", draws = drws)

fs2


</code></pre>

<hr>
<h2 id='fitted_values'>Generate fitted values from a estimated GAM</h2><span id='topic+fitted_values'></span><span id='topic+fitted_values.gam'></span><span id='topic+fitted_values.gamm'></span><span id='topic+fitted_values.scam'></span>

<h3>Description</h3>

<p>Generate fitted values from a estimated GAM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitted_values(object, ...)

## S3 method for class 'gam'
fitted_values(
  object,
  data = NULL,
  scale = c("response", "link", "linear predictor"),
  ci_level = 0.95,
  ...
)

## S3 method for class 'gamm'
fitted_values(object, ...)

## S3 method for class 'scam'
fitted_values(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted_values_+3A_object">object</code></td>
<td>
<p>a fitted model. Currently only models fitted by <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code>
and <code><a href="mgcv.html#topic+bam">mgcv::bam()</a></code> are supported.</p>
</td></tr>
<tr><td><code id="fitted_values_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="mgcv.html#topic+predict.gam">mgcv::predict.gam()</a></code>. Note that <code>type</code>,
<code>newdata</code>, and <code>se.fit</code> are already used and passed on to
<code><a href="mgcv.html#topic+predict.gam">mgcv::predict.gam()</a></code>.</p>
</td></tr>
<tr><td><code id="fitted_values_+3A_data">data</code></td>
<td>
<p>optional data frame of covariate values for which fitted values
are to be returned.</p>
</td></tr>
<tr><td><code id="fitted_values_+3A_scale">scale</code></td>
<td>
<p>character; what scale should the fitted values be returned on?
<code>"linear predictor"</code> is a synonym for <code>"link"</code> if you prefer that
terminology.</p>
</td></tr>
<tr><td><code id="fitted_values_+3A_ci_level">ci_level</code></td>
<td>
<p>numeric; a value between 0 and 1 indicating the coverage of
the credible interval.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble (data frame) whose first <em>m</em> columns contain either the data
used to fit the model (if <code>data</code> was <code>NULL</code>), or the variables supplied to
<code>data</code>. Four further columns are added:
</p>

<ul>
<li> <p><code>fitted</code>: the fitted values on the specified scale,
</p>
</li>
<li> <p><code>se</code>: the standard error of the fitted values (always on the <em>link</em> scale),
</p>
</li>
<li> <p><code>lower</code>, <code>upper</code>: the limits of the credible interval on the fitted values,
on the specified scale.
</p>
</li></ul>

<p>Models fitted with certain families will include additional variables
</p>

<ul>
<li> <p><code>mgcv::ocat()</code> models: when <code>scale = "repsonse"</code>, the returned object will
contain a <code>row</code> column and a <code>category</code> column, which indicate to which row
of the <code>data</code> each row of the returned object belongs. Additionally, there
will be <code>nrow(data) * n_categories</code> rows in the returned object; each row
is the predicted probability for a single category of the response.
</p>
</li></ul>



<h3>Note</h3>

<p>For most families, regardless of the scale on which the fitted values
are returned, the <code>se</code> component of the returned object is on the <em>link</em>
(<em>linear predictor</em>) scale, not the response scale. An exception is the
<code>mgcv::ocat()</code> family, for which the <code>se</code> is on the response scale if
<code>scale = "response"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()

sim_df &lt;- data_sim("eg1", n = 400, dist = "normal", scale = 2, seed = 2)
m &lt;- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = sim_df, method = "REML")
fv &lt;- fitted_values(m)
fv

</code></pre>

<hr>
<h2 id='fix_offset'>Fix the names of a data frame containing an offset variable.</h2><span id='topic+fix_offset'></span>

<h3>Description</h3>

<p>Identifies which variable, if any, is the model offset, and fixed the name
such that <code>offset(foo(var))</code> is converted to <code>var</code>, and possibly sets the
values of that variable to <code>offset_val</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_offset(model, newdata, offset_val = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fix_offset_+3A_model">model</code></td>
<td>
<p>a fitted GAM.</p>
</td></tr>
<tr><td><code id="fix_offset_+3A_newdata">newdata</code></td>
<td>
<p>data frame; new values at which to predict at.</p>
</td></tr>
<tr><td><code id="fix_offset_+3A_offset_val">offset_val</code></td>
<td>
<p>numeric, optional; if provided, then the offset variable
in <code>newdata</code> is set to this constant value before returning <code>newdata</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original <code>newdata</code> is returned with fixed names and possibly
modified offset variable.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()
df &lt;- data_sim("eg1", n = 400, dist = "normal", seed = 2)
m &lt;- gam(y ~ s(x0) + s(x1) + offset(x2), data = df, method = "REML")
names(model.frame(m))
names(fix_offset(m, model.frame(m), offset_val = 1L))
</code></pre>

<hr>
<h2 id='fixef'>Extract fixed effects estimates</h2><span id='topic+fixef'></span>

<h3>Description</h3>

<p>Extract fixed effects estimates
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixef_+3A_object">object</code></td>
<td>
<p>a fitted GAM</p>
</td></tr>
<tr><td><code id="fixef_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>

<hr>
<h2 id='fixef.gam'>Extract fixed effects estimates from a fitted GAM</h2><span id='topic+fixef.gam'></span><span id='topic+fixef.gamm'></span><span id='topic+fixef.lm'></span><span id='topic+fixef.glm'></span><span id='topic+fixed_effects'></span><span id='topic+fixed_effects.default'></span>

<h3>Description</h3>

<p>Extract fixed effects estimates from a fitted GAM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gam'
fixef(object, ...)

## S3 method for class 'gamm'
fixef(object, ...)

## S3 method for class 'lm'
fixef(object, ...)

## S3 method for class 'glm'
fixef(object, ...)

fixed_effects(object, ...)

## Default S3 method:
fixed_effects(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixef.gam_+3A_object">object</code></td>
<td>
<p>a fitted GAM</p>
</td></tr>
<tr><td><code id="fixef.gam_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()

# run example if lme4 is available
if (require("lme4")) {
  data(sleepstudy, package = "lme4")
  m &lt;- gam(
    Reaction ~ Days + s(Subject, bs = "re") +
      s(Days, Subject, bs = "re"),
    data = sleepstudy, method = "REML"
  )
  fixef(m)
}
</code></pre>

<hr>
<h2 id='gaussian_draws'>Posterior samples using a simple Metropolis Hastings sampler</h2><span id='topic+gaussian_draws'></span><span id='topic+gaussian_draws.gam'></span><span id='topic+gaussian_draws.scam'></span>

<h3>Description</h3>

<p>Posterior samples using a simple Metropolis Hastings sampler
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussian_draws(model, ...)

## S3 method for class 'gam'
gaussian_draws(
  model,
  n,
  n_cores = 1L,
  index = NULL,
  frequentist = FALSE,
  unconditional = FALSE,
  mvn_method = "mvnfast",
  ...
)

## S3 method for class 'scam'
gaussian_draws(
  model,
  n,
  n_cores = 1L,
  index = NULL,
  frequentist = FALSE,
  parametrized = TRUE,
  mvn_method = "mvnfast",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussian_draws_+3A_model">model</code></td>
<td>
<p>a fitted R model. Currently only models fitted by <code>mgcv::gam()</code>
or <code>mgcv::bam()</code>, or return an object that <em>inherits</em> from such objects are
supported. Here, &quot;inherits&quot; is used in a loose fashion; models fitted by
<code>scam::scam()</code> are support even though those models don't strictly inherit
from class <code>"gam"</code> as far as <code>inherits()</code> is concerned.</p>
</td></tr>
<tr><td><code id="gaussian_draws_+3A_...">...</code></td>
<td>
<p>arguments passed to methods.</p>
</td></tr>
<tr><td><code id="gaussian_draws_+3A_n">n</code></td>
<td>
<p>numeric; the number of posterior draws to take.</p>
</td></tr>
<tr><td><code id="gaussian_draws_+3A_n_cores">n_cores</code></td>
<td>
<p>integer; number of CPU cores to use when generating
multivariate normal distributed random values. Only used if
<code>mvn_method = "mvnfast"</code> <strong>and</strong> <code>method = "gaussian"</code>.</p>
</td></tr>
<tr><td><code id="gaussian_draws_+3A_index">index</code></td>
<td>
<p>numeric; vector of indices of coefficients to use. Can be used
to subset the mean vector and covariance matrix extracted from <code>model</code>.</p>
</td></tr>
<tr><td><code id="gaussian_draws_+3A_frequentist">frequentist</code></td>
<td>
<p>logical; if <code>TRUE</code>, the frequentist covariance matrix of
the parameter estimates is used. If <code>FALSE</code>, the Bayesian posterior
covariance matrix of the parameters is used. See <code>mgcv::vcov.gam()</code>.</p>
</td></tr>
<tr><td><code id="gaussian_draws_+3A_unconditional">unconditional</code></td>
<td>
<p>logical; if <code>TRUE</code>  the Bayesian smoothing parameter
uncertainty corrected covariance matrix is used, <em>if available</em> for
<code>model</code>. See <code>mgcv::vcov.gam()</code>.</p>
</td></tr>
<tr><td><code id="gaussian_draws_+3A_mvn_method">mvn_method</code></td>
<td>
<p>character; one of <code>"mvnfast"</code> or <code>"mgcv"</code>. The default is
uses <code>mvnfast::rmvn()</code>, which can be considerably faster at generate large
numbers of MVN random values than <code>mgcv::rmvn()</code>, but which might not work
for some marginal fits, such as those where the covariance matrix is close
to singular.</p>
</td></tr>
<tr><td><code id="gaussian_draws_+3A_parametrized">parametrized</code></td>
<td>
<p>logical; use parametrized coefficients and covariance
matrix, which respect the linear inequality constraints of the model. Only
for <code>scam::scam()</code> model fits.</p>
</td></tr>
</table>

<hr>
<h2 id='get_by_smooth'>Extract an factor-by smooth by name</h2><span id='topic+get_by_smooth'></span>

<h3>Description</h3>

<p>Extract an factor-by smooth by name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_by_smooth(object, term, level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_by_smooth_+3A_object">object</code></td>
<td>
<p>a fitted GAM model object.</p>
</td></tr>
<tr><td><code id="get_by_smooth_+3A_term">term</code></td>
<td>
<p>character; the name of a smooth term to extract.</p>
</td></tr>
<tr><td><code id="get_by_smooth_+3A_level">level</code></td>
<td>
<p>character; which level of the factor to exrtact the smooth
for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single smooth object, or a list of smooths if several match the
named term.
</p>

<hr>
<h2 id='get_smooth'>Extract an mgcv smooth by name</h2><span id='topic+get_smooth'></span>

<h3>Description</h3>

<p>Extract an mgcv smooth by name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_smooth(object, term)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_smooth_+3A_object">object</code></td>
<td>
<p>a fitted GAM model object.</p>
</td></tr>
<tr><td><code id="get_smooth_+3A_term">term</code></td>
<td>
<p>character; the name of a smooth term to extract</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single smooth object, or a list of smooths if several match the
named term.
</p>

<hr>
<h2 id='get_smooths_by_id'>Extract an mgcv smooth given its position in the model object</h2><span id='topic+get_smooths_by_id'></span><span id='topic+get_smooths_by_id.gam'></span><span id='topic+get_smooths_by_id.scam'></span><span id='topic+get_smooths_by_id.gamm'></span><span id='topic+get_smooths_by_id.gamm4'></span><span id='topic+get_smooths_by_id.list'></span>

<h3>Description</h3>

<p>Extract an mgcv smooth given its position in the model object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_smooths_by_id(object, id)

## S3 method for class 'gam'
get_smooths_by_id(object, id)

## S3 method for class 'scam'
get_smooths_by_id(object, id)

## S3 method for class 'gamm'
get_smooths_by_id(object, id)

## S3 method for class 'gamm4'
get_smooths_by_id(object, id)

## S3 method for class 'list'
get_smooths_by_id(object, id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_smooths_by_id_+3A_object">object</code></td>
<td>
<p>a fitted GAM model object.</p>
</td></tr>
<tr><td><code id="get_smooths_by_id_+3A_id">id</code></td>
<td>
<p>numeric; the position of the smooth in the model object.</p>
</td></tr>
</table>

<hr>
<h2 id='gratia-package'>gratia: Graceful 'ggplot'-Based Graphics and Other Functions for GAMs Fitted Using 'mgcv'</h2><span id='topic+gratia'></span><span id='topic+gratia-package'></span>

<h3>Description</h3>

<p>Graceful 'ggplot'-based graphics and utility functions for working with generalized additive models (GAMs) fitted using the 'mgcv' package. Provides a reimplementation of the plot() method for GAMs that 'mgcv' provides, as well as 'tidyverse' compatible representations of estimated smooths.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Gavin L. Simpson <a href="mailto:ucfagls@gmail.com">ucfagls@gmail.com</a> (<a href="https://orcid.org/0000-0002-9084-8413">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Henrik Singmann (<a href="https://orcid.org/0000-0002-4842-3657">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://gavinsimpson.github.io/gratia/">https://gavinsimpson.github.io/gratia/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/gavinsimpson/gratia/issues">https://github.com/gavinsimpson/gratia/issues</a>
</p>
</li></ul>


<hr>
<h2 id='gss_vocab'>Data from the General Social Survey (GSS) from the National Opinion Research
Center of the University of Chicago</h2><span id='topic+gss_vocab'></span>

<h3>Description</h3>

<p>A subset of the data from the <code>carData::GSSvocab</code> dataset from the
<code>carData</code> package, containing observations from 2016 only.
</p>


<h3>Format</h3>

<p>A data frame with 1858 rows and 3 variables:
</p>

<ul>
<li> <p><code>vocab</code>: numeric; the number of words out of 10 correct on a vocabulary
test.
</p>
</li>
<li> <p><code>nativeBorn</code>: factor; Was the respondent born in the US? A factor with
levels <code>no</code> and <code>yes</code>.
</p>
</li>
<li> <p><code>ageGroup</code>: factor; grouped age of the respondent with levels <code>18-29</code>
<code>30-39</code>, <code>40-49</code>, <code>50-59</code>, and <code style="white-space: pre;">&#8288;60+&#8288;</code>.
</p>
</li></ul>


<hr>
<h2 id='gw_f0'>Gu and Wabha test functions</h2><span id='topic+gw_f0'></span><span id='topic+gw_functions'></span><span id='topic+gw_f1'></span><span id='topic+gw_f2'></span><span id='topic+gw_f3'></span>

<h3>Description</h3>

<p>Gu and Wabha test functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gw_f0(x, ...)

gw_f1(x, ...)

gw_f2(x, ...)

gw_f3(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gw_f0_+3A_x">x</code></td>
<td>
<p>numeric; vector of points to evaluate the function at, on interval
(0,1)</p>
</td></tr>
<tr><td><code id="gw_f0_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods, ignored.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- seq(0, 1, length = 6)
gw_f0(x)
gw_f1(x)
gw_f2(x)
gw_f3(x) # should be constant 0

</code></pre>

<hr>
<h2 id='has_theta'>Are additional parameters available for a GAM?</h2><span id='topic+has_theta'></span>

<h3>Description</h3>

<p>Are additional parameters available for a GAM?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_theta(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_theta_+3A_object">object</code></td>
<td>
<p>an R object, either a <code><a href="stats.html#topic+family">family()</a></code> object or an object whose
class has a <code><a href="stats.html#topic+family">family()</a></code> method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical; <code>TRUE</code> if additional parameters available, <code>FALSE</code>
otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()
df &lt;- data_sim("eg1", dist = "poisson", seed = 42, scale = 1 / 5)
m &lt;- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3),
  data = df, method = "REML",
  family = nb()
)
has_theta(m)
p &lt;- theta(m)
</code></pre>

<hr>
<h2 id='is_by_smooth'>Tests for by variable smooths</h2><span id='topic+is_by_smooth'></span><span id='topic+is_factor_by_smooth'></span><span id='topic+is_continuous_by_smooth'></span><span id='topic+by_variable'></span><span id='topic+by_level'></span>

<h3>Description</h3>

<p>Functions to check if a smooth is a by-variable one and to test of the type
of by-variable smooth is a factor-smooth or a continous-smooth interaction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_by_smooth(smooth)

is_factor_by_smooth(smooth)

is_continuous_by_smooth(smooth)

by_variable(smooth)

by_level(smooth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_by_smooth_+3A_smooth">smooth</code></td>
<td>
<p>an object of class <code>"mgcv.smooth"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>

<hr>
<h2 id='is_factor_term'>Is a model term a factor (categorical)?</h2><span id='topic+is_factor_term'></span><span id='topic+is_factor_term.terms'></span><span id='topic+is_factor_term.gam'></span><span id='topic+is_factor_term.bam'></span><span id='topic+is_factor_term.gamm'></span><span id='topic+is_factor_term.list'></span>

<h3>Description</h3>

<p>Given the name (a term label) of a term in a model, identify if the term is a
factor term or numeric. This is useful when considering interactions, where
terms like <code>fac1:fac2</code> or <code>num1:fac1</code> may be requested by the user. Only for
terms of the type <code>fac1:fac2</code> will this function return <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_factor_term(object, term, ...)

## S3 method for class 'terms'
is_factor_term(object, term, ...)

## S3 method for class 'gam'
is_factor_term(object, term, ...)

## S3 method for class 'bam'
is_factor_term(object, term, ...)

## S3 method for class 'gamm'
is_factor_term(object, term, ...)

## S3 method for class 'list'
is_factor_term(object, term, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_factor_term_+3A_object">object</code></td>
<td>
<p>an R object on which method dispatch is performed</p>
</td></tr>
<tr><td><code id="is_factor_term_+3A_term">term</code></td>
<td>
<p>character; the name of a model term, in the sense of
<code>attr(terms(object), "term.labels")</code>. Currently not checked to see if the
term exists in the model.</p>
</td></tr>
<tr><td><code id="is_factor_term_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical: <code>TRUE</code> if and only if all variables involved in the term
are factors, otherwise <code>FALSE</code>.
</p>

<hr>
<h2 id='is_mgcv_smooth'>Check if objects are smooths or are a particular type of smooth</h2><span id='topic+is_mgcv_smooth'></span><span id='topic+stop_if_not_mgcv_smooth'></span><span id='topic+check_is_mgcv_smooth'></span><span id='topic+is_mrf_smooth'></span>

<h3>Description</h3>

<p>Check if objects are smooths or are a particular type of smooth
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_mgcv_smooth(smooth)

stop_if_not_mgcv_smooth(smooth)

check_is_mgcv_smooth(smooth)

is_mrf_smooth(smooth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_mgcv_smooth_+3A_smooth">smooth</code></td>
<td>
<p>an R object, typically a list</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Check if a smooth inherits from class <code>"mgcv.smooth"</code>.
<code>stop_if_not_mgcv_smooth()</code> is a wrapper around <code>is_mgcv_smooth()</code>, useful
when programming for checking if the supplied object is one of mgcv's
smooths, and throwing a consistent error if not.
<code>check_is_mgcv_smooth()</code> is similar to <code>stop_if_not_mgcv_smooth()</code> but
returns the result of <code>is_mgcv_smooth()</code> invisibly.
</p>

<hr>
<h2 id='is_offset'>Is a model term an offset?</h2><span id='topic+is_offset'></span>

<h3>Description</h3>

<p>Given a character vector of model terms, checks to see which, if any, is the
model offset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_offset(terms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_offset_+3A_terms">terms</code></td>
<td>
<p>character vector of model terms.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector of the same length as <code>terms</code>.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()
df &lt;- data_sim("eg1", n = 400, dist = "normal")
m &lt;- gam(y ~ s(x0) + s(x1) + offset(x0), data = df, method = "REML")
nm &lt;- names(model.frame(m))
nm
is_offset(nm)
</code></pre>

<hr>
<h2 id='link'>Extract link and inverse link functions from models</h2><span id='topic+link'></span><span id='topic+link.family'></span><span id='topic+link.gam'></span><span id='topic+link.bam'></span><span id='topic+link.gamm'></span><span id='topic+link.glm'></span><span id='topic+link.list'></span><span id='topic+inv_link'></span><span id='topic+inv_link.family'></span><span id='topic+inv_link.gam'></span><span id='topic+inv_link.bam'></span><span id='topic+inv_link.gamm'></span><span id='topic+inv_link.list'></span><span id='topic+inv_link.glm'></span><span id='topic+extract_link'></span><span id='topic+extract_link.family'></span><span id='topic+extract_link.general.family'></span>

<h3>Description</h3>

<p>Returns the link or its inverse from an estimated model, and provides a
simple way to extract these functions from complex models with multiple
links, such as location scale models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>link(object, ...)

## S3 method for class 'family'
link(object, parameter = NULL, which_eta = NULL, ...)

## S3 method for class 'gam'
link(object, parameter = NULL, which_eta = NULL, ...)

## S3 method for class 'bam'
link(object, parameter = NULL, which_eta = NULL, ...)

## S3 method for class 'gamm'
link(object, ...)

## S3 method for class 'glm'
link(object, ...)

## S3 method for class 'list'
link(object, ...)

inv_link(object, ...)

## S3 method for class 'family'
inv_link(object, parameter = NULL, which_eta = NULL, ...)

## S3 method for class 'gam'
inv_link(object, parameter = NULL, which_eta = NULL, ...)

## S3 method for class 'bam'
inv_link(object, parameter = NULL, which_eta = NULL, ...)

## S3 method for class 'gamm'
inv_link(object, ...)

## S3 method for class 'list'
inv_link(object, ...)

## S3 method for class 'glm'
inv_link(object, ...)

extract_link(family, ...)

## S3 method for class 'family'
extract_link(family, inverse = FALSE, ...)

## S3 method for class 'general.family'
extract_link(family, parameter, inverse = FALSE, which_eta = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="link_+3A_object">object</code></td>
<td>
<p>a family object or a fitted model from which to extract the
family object.  Models fitted by <code><a href="stats.html#topic+glm">stats::glm()</a></code>, <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code>,
<code><a href="mgcv.html#topic+bam">mgcv::bam()</a></code>, <code><a href="mgcv.html#topic+gamm">mgcv::gamm()</a></code>, and <code><a href="gamm4.html#topic+gamm4">gamm4::gamm4()</a></code> are currently
supported.</p>
</td></tr>
<tr><td><code id="link_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="link_+3A_parameter">parameter</code></td>
<td>
<p>character; which parameter of the distribution. Usually
<code>"location"</code> but <code>"scale"</code> and <code>"shape"</code> may be provided for location
scale models. Other options include <code>"mu"</code> as a synonym for <code>"location"</code>,
<code>"sigma"</code> for the scale parameter in <code><a href="mgcv.html#topic+gaulss">mgcv::gaulss()</a></code>, <code>"pi"</code> for the
zero-inflation term in <code><a href="mgcv.html#topic+ziplss">mgcv::ziplss()</a></code>, <code>"power"</code> for the
<code><a href="mgcv.html#topic+twlss">mgcv::twlss()</a></code> power parameter, <code>"xi"</code>, the shape parameter for
<code><a href="mgcv.html#topic+gevlss">mgcv::gevlss()</a></code>, <code>"epsilon"</code> or <code>"skewness"</code> for the skewness and
<code>"delta"</code> or <code>"kurtosis"</code> for the kurtosis parameter for
<code><a href="mgcv.html#topic+shash">mgcv::shash()</a></code>, or <code>"phi"</code> for the scale parameter of <code><a href="mgcv.html#topic+gammals">mgcv::gammals()</a></code> &amp;
<code><a href="mgcv.html#topic+twlss">mgcv::twlss()</a></code>.</p>
</td></tr>
<tr><td><code id="link_+3A_which_eta">which_eta</code></td>
<td>
<p>numeric; the linear predictor to extract for families
<code><a href="mgcv.html#topic+mvn">mgcv::mvn()</a></code> and <code><a href="mgcv.html#topic+multinom">mgcv::multinom()</a></code>.</p>
</td></tr>
<tr><td><code id="link_+3A_family">family</code></td>
<td>
<p>a family object, the result of a call to <code><a href="stats.html#topic+family">family()</a></code>.</p>
</td></tr>
<tr><td><code id="link_+3A_inverse">inverse</code></td>
<td>
<p>logical; return the inverse of the link function?</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()

link(gaussian())
link(nb())

inv_link(nb())

dat &lt;- data_sim("eg1", seed = 4234)
mod &lt;- gam(list(y ~ s(x0) + s(x1) + s(x2) + s(x3), ~1),
  data = dat,
  family = gaulss
)

link(mod, parameter = "scale")
inv_link(mod, parameter = "scale")

## Works with `family` objects too
link(shash(), parameter = "skewness")
</code></pre>

<hr>
<h2 id='load_mgcv'>Load mgcv quietly</h2><span id='topic+load_mgcv'></span>

<h3>Description</h3>

<p>Simple function that loads the <em>mgcv</em> package whilst suppressing the startup
messages that it prints to the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_mgcv()
</code></pre>


<h3>Value</h3>

<p>Returns a logical vectors invisibly, indicating whether the package
was loaded or not.
</p>

<hr>
<h2 id='lp_matrix'>Return the linear prediction matrix of a fitted GAM</h2><span id='topic+lp_matrix'></span><span id='topic+lp_matrix.gam'></span>

<h3>Description</h3>

<p><code>lp_matrix()</code> is a wrapper to <code>predict(..., type = "lpmatrix")</code> for returning
the linear predictor matrix for the model training data (when <code>data = NULL</code>),
or user-specified data values supplied via <code>data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lp_matrix(model, ...)

## S3 method for class 'gam'
lp_matrix(model, data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lp_matrix_+3A_model">model</code></td>
<td>
<p>a fitted model</p>
</td></tr>
<tr><td><code id="lp_matrix_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods and <code>predict</code> methods including
<code><a href="mgcv.html#topic+predict.gam">mgcv::predict.gam()</a></code> and <code><a href="mgcv.html#topic+predict.bam">mgcv::predict.bam()</a></code></p>
</td></tr>
<tr><td><code id="lp_matrix_+3A_data">data</code></td>
<td>
<p>a data frame of values at which to return the linear prediction
matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The linear prediction matrix <code class="reqn">\mathbf{X}_p</code> is a matrix that maps values
of parameters <code class="reqn">\hat{\mathbf{\beta}}_p</code> to values on the linear
predictor of the model <code class="reqn">\hat{\eta}_p = \mathbf{X}_p
\hat{\mathbf{\beta}}_p</code>. <code class="reqn">\mathbf{X}_p</code> is the model matrix where spline
covariates have been replaced by the values of the basis functions evaluated
at the respective covariates. Parametric covariates are also included.
</p>


<h3>Value</h3>

<p>The linear prediction matrix is returned as a matrix. The object
returned is of class <code>"lp_matrix"</code>, which inherits from classes <code>"matrix"</code>
and <code>"array"</code>. The special class allows the printing of the matrix to be
controlled, which we do by printing the matrix as a tibble.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()

df &lt;- data_sim("eg1", seed = 1)
m &lt;- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df)

# linear prediction matrix for observed data
xp &lt;- lp_matrix(m)
## IGNORE_RDIFF_BEGIN
xp
## IGNORE_RDIFF_END

# the object `xp` *is* a matrix
class(xp)
# but we print like a tibble to avoid spamming the R console

# linear predictor matrix for new data set
ds &lt;- data_slice(m, x2 = evenly(x2))
xp &lt;- lp_matrix(m, data = ds)
## IGNORE_RDIFF_BEGIN
xp
## IGNORE_RDIFF_END

</code></pre>

<hr>
<h2 id='lss_parameters'>General names of LSS parameters for each GAM family</h2><span id='topic+lss_parameters'></span>

<h3>Description</h3>

<p>General names of LSS parameters for each GAM family
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lss_parameters(object)
</code></pre>

<hr>
<h2 id='mh_draws'>Posterior samples using a Gaussian approximation to the posterior
distribution</h2><span id='topic+mh_draws'></span><span id='topic+mh_draws.gam'></span>

<h3>Description</h3>

<p>Posterior samples using a Gaussian approximation to the posterior
distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mh_draws(model, ...)

## S3 method for class 'gam'
mh_draws(
  model,
  n,
  burnin = 1000,
  thin = 1,
  t_df = 40,
  rw_scale = 0.25,
  index = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mh_draws_+3A_model">model</code></td>
<td>
<p>a fitted R model. Currently only models fitted by <code>mgcv::gam()</code>
or <code>mgcv::bam()</code>, or return an object that <em>inherits</em> from such objects are
supported. Here, &quot;inherits&quot; is used in a loose fashion; models fitted by
<code>scam::scam()</code> are support even though those models don't strictly inherit
from class <code>"gam"</code> as far as <code>inherits()</code> is concerned.</p>
</td></tr>
<tr><td><code id="mh_draws_+3A_...">...</code></td>
<td>
<p>arguments passed to methods.</p>
</td></tr>
<tr><td><code id="mh_draws_+3A_n">n</code></td>
<td>
<p>numeric; the number of posterior draws to take.</p>
</td></tr>
<tr><td><code id="mh_draws_+3A_burnin">burnin</code></td>
<td>
<p>numeric; the length of any initial burn in period to discard.
See <code>mgcv::gam.mh()</code>.</p>
</td></tr>
<tr><td><code id="mh_draws_+3A_thin">thin</code></td>
<td>
<p>numeric; retain only <code>thin</code> samples. See <code>mgcv::gam.mh()</code>.</p>
</td></tr>
<tr><td><code id="mh_draws_+3A_t_df">t_df</code></td>
<td>
<p>numeric; degrees of freedom for static multivariate <em>t</em> proposal.
See <code>mgcv::gam.mh()</code>.</p>
</td></tr>
<tr><td><code id="mh_draws_+3A_rw_scale">rw_scale</code></td>
<td>
<p>numeric; factor by which to scale posterior covariance
matrix when generating random walk proposals. See <code>mgcv::gam.mh()</code>.</p>
</td></tr>
<tr><td><code id="mh_draws_+3A_index">index</code></td>
<td>
<p>numeric; vector of indices of coefficients to use. Can be used
to subset the mean vector and covariance matrix extracted from <code>model</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='model_concurvity'>Concurvity of an estimated GAM</h2><span id='topic+model_concurvity'></span><span id='topic+model_concurvity.gam'></span><span id='topic+concrvity'></span>

<h3>Description</h3>

<p>Concurvity of an estimated GAM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_concurvity(model, ...)

## S3 method for class 'gam'
model_concurvity(
  model,
  terms = everything(),
  type = c("all", "estimate", "observed", "worst"),
  pairwise = FALSE,
  ...
)

concrvity(
  model,
  terms = everything(),
  type = c("all", "estimate", "observed", "worst"),
  pairwise = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_concurvity_+3A_model">model</code></td>
<td>
<p>a fitted GAM. Currently only objects of class <code>"gam"</code> are
supported</p>
</td></tr>
<tr><td><code id="model_concurvity_+3A_...">...</code></td>
<td>
<p>arguents passed to other methods.</p>
</td></tr>
<tr><td><code id="model_concurvity_+3A_terms">terms</code></td>
<td>
<p>currently ignored</p>
</td></tr>
<tr><td><code id="model_concurvity_+3A_type">type</code></td>
<td>
<p>character;</p>
</td></tr>
<tr><td><code id="model_concurvity_+3A_pairwise">pairwise</code></td>
<td>
<p>logical; extract pairwise concurvity of model terms?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## simulate data with concurvity...
library("tibble")
load_mgcv()
set.seed(8)
n &lt;- 200
df &lt;- tibble(
  t = sort(runif(n)),
  x = gw_f2(t) + rnorm(n) * 3,
  y = sin(4 * pi * t) + exp(x / 20) + rnorm(n) * 0.3
)

## fit model
m &lt;- gam(y ~ s(t, k = 15) + s(x, k = 15), data = df, method = "REML")

## overall concurvity
o_conc &lt;- concrvity(m)
draw(o_conc)

## pairwise concurvity
p_conc &lt;- concrvity(m, pairwise = TRUE)
draw(p_conc)
</code></pre>

<hr>
<h2 id='model_constant'>Extract the model constant term</h2><span id='topic+model_constant'></span>

<h3>Description</h3>

<p>Extracts the model constant term, the model intercept, from a fitted model
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_constant(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_constant_+3A_model">model</code></td>
<td>
<p>a fitted model for which a <code>coef()</code> method exists</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
load_mgcv()

# simulate a small example
df &lt;- data_sim("eg1", seed = 42)

# fit the GAM
m &lt;- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = "REML")

# extract the estimate of the constant term
model_constant(m)
# same as coef(m)[1L]
coef(m)[1L]


</code></pre>

<hr>
<h2 id='model_vars'>List the variables involved in a model fitted with a formula</h2><span id='topic+model_vars'></span><span id='topic+model_vars.gam'></span><span id='topic+model_vars.default'></span><span id='topic+model_vars.bam'></span><span id='topic+model_vars.gamm'></span><span id='topic+model_vars.gamm4'></span><span id='topic+model_vars.list'></span>

<h3>Description</h3>

<p>List the variables involved in a model fitted with a formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_vars(model, ...)

## S3 method for class 'gam'
model_vars(model, ...)

## Default S3 method:
model_vars(model, ...)

## S3 method for class 'bam'
model_vars(model, ...)

## S3 method for class 'gamm'
model_vars(model, ...)

## S3 method for class 'gamm4'
model_vars(model, ...)

## S3 method for class 'list'
model_vars(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_vars_+3A_model">model</code></td>
<td>
<p>a fitted model object with a <code style="white-space: pre;">&#8288;$pred.formula&#8288;</code>, <code style="white-space: pre;">&#8288;$terms&#8288;</code>
component or a <code>"terms"</code> attribute</p>
</td></tr>
<tr><td><code id="model_vars_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods. Currently ignored.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()

# simulate some Gaussian data
df &lt;- data_sim("eg1", n = 50, seed = 2)

# fit a GAM with 1 smooth and 1 linear term
m1 &lt;- gam(y ~ s(x2, k = 7) + x1, data = df, method = "REML")
model_vars(m1)

# fit a lm with two linear terms
m2 &lt;- lm(y ~ x2 + x1, data = df)
model_vars(m2)
</code></pre>

<hr>
<h2 id='n_smooths'>How many smooths in a fitted model</h2><span id='topic+n_smooths'></span><span id='topic+n_smooths.default'></span><span id='topic+n_smooths.gam'></span><span id='topic+n_smooths.gamm'></span><span id='topic+n_smooths.bam'></span>

<h3>Description</h3>

<p>How many smooths in a fitted model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_smooths(object)

## Default S3 method:
n_smooths(object)

## S3 method for class 'gam'
n_smooths(object)

## S3 method for class 'gamm'
n_smooths(object)

## S3 method for class 'bam'
n_smooths(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_smooths_+3A_object">object</code></td>
<td>
<p>a fitted GAM or related model. Typically the result of a call
to <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code>, <code><a href="mgcv.html#topic+bam">mgcv::bam()</a></code>, or <code><a href="mgcv.html#topic+gamm">mgcv::gamm()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='nb_theta'>Negative binomial parameter theta</h2><span id='topic+nb_theta'></span><span id='topic+nb_theta.gam'></span>

<h3>Description</h3>

<p>Negative binomial parameter theta
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nb_theta(model)

## S3 method for class 'gam'
nb_theta(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nb_theta_+3A_model">model</code></td>
<td>
<p>a fitted model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length 1 containing the estimated value of
theta.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>nb_theta(gam)</code>: Method for class <code>"gam"</code>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()
df &lt;- data_sim("eg1", n = 500, dist = "poisson", scale = 0.1, seed = 6)

m &lt;- gam(y ~ s(x0, bs = "cr") + s(x1, bs = "cr") + s(x2, bs = "cr") +
  s(x3, bs = "cr"), family = nb, data = df, method = "REML")
## IGNORE_RDIFF_BEGIN
nb_theta(m)
## IGNORE_RDIFF_END
</code></pre>

<hr>
<h2 id='nested_partial_residuals'>Partial residuals in nested form</h2><span id='topic+nested_partial_residuals'></span>

<h3>Description</h3>

<p>Computes partial residuals for smooth terms, formats them in long/tidy
format, then nests the <code>partial_residual</code> column such that the result
is a nested data frame with one row per smooth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nested_partial_residuals(object, terms = NULL, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nested_partial_residuals_+3A_object">object</code></td>
<td>
<p>a fitted GAM model</p>
</td></tr>
<tr><td><code id="nested_partial_residuals_+3A_terms">terms</code></td>
<td>
<p>a vector of terms to include partial residuals for. Passed to
argument <code>terms</code> of <code><a href="mgcv.html#topic+predict.gam">mgcv::predict.gam()</a></code>].</p>
</td></tr>
<tr><td><code id="nested_partial_residuals_+3A_data">data</code></td>
<td>
<p>optional data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nested tibble (data frame) with one row per smooth term. Contains
two columns:
</p>

<ul>
<li> <p><code>smooth</code> - a label indicating the smooth term
</p>
</li>
<li> <p><code>partial_residual</code> - a list column containing a tibble (data frame) with
1 column <code>partial_residual</code> containing the requested partial residuals
for the indicated smooth.
</p>
</li></ul>


<hr>
<h2 id='nested_rug_values'>Values for rug plot in nested form</h2><span id='topic+nested_rug_values'></span>

<h3>Description</h3>

<p>Extracts original data for smooth terms, formats them in long/tidy
format, then nests the data column(s) such that the result
is a nested data frame with one row per smooth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nested_rug_values(object, terms = NULL, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nested_rug_values_+3A_object">object</code></td>
<td>
<p>a fitted GAM model</p>
</td></tr>
<tr><td><code id="nested_rug_values_+3A_terms">terms</code></td>
<td>
<p>a vector of terms to include original data for. Passed to
argument <code>terms</code> of <code><a href="mgcv.html#topic+predict.gam">mgcv::predict.gam()</a></code>].</p>
</td></tr>
<tr><td><code id="nested_rug_values_+3A_data">data</code></td>
<td>
<p>optional data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nested tibble (data frame) with one row per smooth term.
</p>

<hr>
<h2 id='null_deviance'>Extract the null deviance of a fitted model</h2><span id='topic+null_deviance'></span><span id='topic+null_deviance.default'></span>

<h3>Description</h3>

<p>Extract the null deviance of a fitted model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>null_deviance(model, ...)

## Default S3 method:
null_deviance(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="null_deviance_+3A_model">model</code></td>
<td>
<p>a fitted model</p>
</td></tr>
<tr><td><code id="null_deviance_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>

<hr>
<h2 id='observed_fitted_plot'>Plot of fitted against observed response values</h2><span id='topic+observed_fitted_plot'></span>

<h3>Description</h3>

<p>Plot of fitted against observed response values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>observed_fitted_plot(
  model,
  ylab = NULL,
  xlab = NULL,
  title = NULL,
  subtitle = NULL,
  caption = NULL,
  point_col = "black",
  point_alpha = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="observed_fitted_plot_+3A_model">model</code></td>
<td>
<p>a fitted model. Currently only class <code>"gam"</code>.</p>
</td></tr>
<tr><td><code id="observed_fitted_plot_+3A_ylab">ylab</code></td>
<td>
<p>character or expression; the label for the y axis. If not
supplied, a suitable label will be generated.</p>
</td></tr>
<tr><td><code id="observed_fitted_plot_+3A_xlab">xlab</code></td>
<td>
<p>character or expression; the label for the y axis. If not
supplied, a suitable label will be generated.</p>
</td></tr>
<tr><td><code id="observed_fitted_plot_+3A_title">title</code></td>
<td>
<p>character or expression; the title for the plot. See
<code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>.</p>
</td></tr>
<tr><td><code id="observed_fitted_plot_+3A_subtitle">subtitle</code></td>
<td>
<p>character or expression; the subtitle for the plot. See
<code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>.</p>
</td></tr>
<tr><td><code id="observed_fitted_plot_+3A_caption">caption</code></td>
<td>
<p>character or expression; the plot caption. See
<code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>.</p>
</td></tr>
<tr><td><code id="observed_fitted_plot_+3A_point_col">point_col</code></td>
<td>
<p>colour used to draw points in the plots. See
<code><a href="graphics.html#topic+par">graphics::par()</a></code> section <strong>Color Specification</strong>. This is passed to
the individual plotting functions, and therefore affects the points of
all plots.</p>
</td></tr>
<tr><td><code id="observed_fitted_plot_+3A_point_alpha">point_alpha</code></td>
<td>
<p>numeric; alpha transparency for points in plots.</p>
</td></tr>
</table>

<hr>
<h2 id='overview'>Provides an overview of a model and the terms in that model</h2><span id='topic+overview'></span><span id='topic+overview.gam'></span>

<h3>Description</h3>

<p>Provides an overview of a model and the terms in that model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overview(model, ...)

## S3 method for class 'gam'
overview(
  model,
  parametric = TRUE,
  random_effects = TRUE,
  dispersion = NULL,
  frequentist = FALSE,
  accuracy = 0.001,
  stars = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overview_+3A_model">model</code></td>
<td>
<p>a fitted model object to overview.</p>
</td></tr>
<tr><td><code id="overview_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="overview_+3A_parametric">parametric</code></td>
<td>
<p>logical; include the model parametric terms in the
overview?</p>
</td></tr>
<tr><td><code id="overview_+3A_random_effects">random_effects</code></td>
<td>
<p>tests of fully penalized smooth terms (those with a
zero-dimensional null space, e.g. random effects) are computationally
expensive and for large data sets producing these p values can take a
very long time. If <code>random_effects = FALSE</code>, the tests of the expensive
terms will be skipped.</p>
</td></tr>
<tr><td><code id="overview_+3A_dispersion">dispersion</code></td>
<td>
<p>numeric; a known value for the dispersion parameter. The
default <code>NULL</code> implies that the estimated value or the default value (1
for the Poisson distribution for example) where this is specified is used
instead.</p>
</td></tr>
<tr><td><code id="overview_+3A_frequentist">frequentist</code></td>
<td>
<p>logical; by default the Bayesian estimated covariance
matrix of the parameter estimates is used to calculate p values for
parametric terms. If <code>frequentist = FALSE</code>, the frequentist covariance
matrix of the parameter estimates is used.</p>
</td></tr>
<tr><td><code id="overview_+3A_accuracy">accuracy</code></td>
<td>
<p>numeric; accuracy with which to report p values, with p
values below this value displayed as <code>"&lt; accuracy"</code>.</p>
</td></tr>
<tr><td><code id="overview_+3A_stars">stars</code></td>
<td>
<p>logical; should significance stars be added to the output?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
load_mgcv()

df &lt;- data_sim(n = 400, seed = 2)
m &lt;- gam(y ~ x3 + s(x0) + s(x1, bs = "bs") + s(x2, bs = "ts"),
  data = df, method = "REML"
)
overview(m)

</code></pre>

<hr>
<h2 id='parametric_effects'>Estimated values for parametric model terms</h2><span id='topic+parametric_effects'></span><span id='topic+parametric_effects.gam'></span>

<h3>Description</h3>

<p>Estimated values for parametric model terms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parametric_effects(object, ...)

## S3 method for class 'gam'
parametric_effects(
  object,
  terms = NULL,
  data = NULL,
  unconditional = FALSE,
  unnest = TRUE,
  ci_level = 0.95,
  envir = environment(formula(object)),
  transform = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parametric_effects_+3A_object">object</code></td>
<td>
<p>a fitted model object.</p>
</td></tr>
<tr><td><code id="parametric_effects_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="parametric_effects_+3A_terms">terms</code></td>
<td>
<p>character; which model parametric terms should be drawn? The
Default of <code>NULL</code> will plot all parametric terms that can be drawn.</p>
</td></tr>
<tr><td><code id="parametric_effects_+3A_data">data</code></td>
<td>
<p>a optional data frame that may or may not be used? FIXME!</p>
</td></tr>
<tr><td><code id="parametric_effects_+3A_unconditional">unconditional</code></td>
<td>
<p>logical; should confidence intervals include the
uncertainty due to smoothness selection? If <code>TRUE</code>, the corrected Bayesian
covariance matrix will be used.</p>
</td></tr>
<tr><td><code id="parametric_effects_+3A_unnest">unnest</code></td>
<td>
<p>logical; unnest the parametric effect objects?</p>
</td></tr>
<tr><td><code id="parametric_effects_+3A_ci_level">ci_level</code></td>
<td>
<p>numeric; the coverage required for the confidence interval.
Currently ignored.</p>
</td></tr>
<tr><td><code id="parametric_effects_+3A_envir">envir</code></td>
<td>
<p>an environment to look up the data within.</p>
</td></tr>
<tr><td><code id="parametric_effects_+3A_transform">transform</code></td>
<td>
<p>logical; if <code>TRUE</code>, the parametric effect will be plotted on
its transformed scale which will result in the effect being a straight
line. If FALSE, the effect will be plotted against the raw data (i.e. for
<code>log10(x)</code>, or <code>poly(z)</code>, the x-axis of the plot will be <code>x</code> or <code>z</code>
respectively.)</p>
</td></tr>
</table>

<hr>
<h2 id='parametric_terms'>Names of any parametric terms in a GAM</h2><span id='topic+parametric_terms'></span><span id='topic+parametric_terms.default'></span><span id='topic+parametric_terms.gam'></span>

<h3>Description</h3>

<p>Names of any parametric terms in a GAM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parametric_terms(model, ...)

## Default S3 method:
parametric_terms(model, ...)

## S3 method for class 'gam'
parametric_terms(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parametric_terms_+3A_model">model</code></td>
<td>
<p>a fitted model.</p>
</td></tr>
<tr><td><code id="parametric_terms_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='partial_derivatives'>Partial derivatives of estimated multivariate smooths via finite
differences</h2><span id='topic+partial_derivatives'></span><span id='topic+partial_derivatives.default'></span><span id='topic+partial_derivatives.gamm'></span><span id='topic+partial_derivatives.gam'></span>

<h3>Description</h3>

<p>Partial derivatives of estimated multivariate smooths via finite
differences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partial_derivatives(object, ...)

## Default S3 method:
partial_derivatives(object, ...)

## S3 method for class 'gamm'
partial_derivatives(object, ...)

## S3 method for class 'gam'
partial_derivatives(
  object,
  select = NULL,
  term = deprecated(),
  focal = NULL,
  data = newdata,
  order = 1L,
  type = c("forward", "backward", "central"),
  n = 100,
  eps = 1e-07,
  interval = c("confidence", "simultaneous"),
  n_sim = 10000,
  level = 0.95,
  unconditional = FALSE,
  frequentist = FALSE,
  offset = NULL,
  ncores = 1,
  partial_match = FALSE,
  seed = NULL,
  ...,
  newdata = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partial_derivatives_+3A_object">object</code></td>
<td>
<p>an R object to compute derivatives for.</p>
</td></tr>
<tr><td><code id="partial_derivatives_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="partial_derivatives_+3A_select">select</code></td>
<td>
<p>character; vector of one or more smooth terms for which
derivatives are required. If missing, derivatives for all smooth terms
will be returned. Can be a partial match to a smooth term; see argument
<code>partial_match</code> below.</p>
</td></tr>
<tr><td><code id="partial_derivatives_+3A_term">term</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>select</code> instead.</p>
</td></tr>
<tr><td><code id="partial_derivatives_+3A_focal">focal</code></td>
<td>
<p>character; name of the focal variable. The partial derivative
of the estimated smooth with respect to this variable will be returned.
All other variables involved in the smooth will be held at constant. This
can be missing if supplying <code>data</code>, in which case, the focal variable will
be identified as the one variable that is not constant.</p>
</td></tr>
<tr><td><code id="partial_derivatives_+3A_data">data</code></td>
<td>
<p>a data frame containing the values of the model covariates
at which to evaluate the first derivatives of the smooths. If supplied,
all but one variable must be held at a constant value.</p>
</td></tr>
<tr><td><code id="partial_derivatives_+3A_order">order</code></td>
<td>
<p>numeric; the order of derivative.</p>
</td></tr>
<tr><td><code id="partial_derivatives_+3A_type">type</code></td>
<td>
<p>character; the type of finite difference used. One of
<code>"forward"</code>, <code>"backward"</code>, or <code>"central"</code>.</p>
</td></tr>
<tr><td><code id="partial_derivatives_+3A_n">n</code></td>
<td>
<p>numeric; the number of points to evaluate the derivative at.</p>
</td></tr>
<tr><td><code id="partial_derivatives_+3A_eps">eps</code></td>
<td>
<p>numeric; the finite difference.</p>
</td></tr>
<tr><td><code id="partial_derivatives_+3A_interval">interval</code></td>
<td>
<p>character; the type of interval to compute. One of
<code>"confidence"</code> for point-wise intervals, or <code>"simultaneous"</code> for
simultaneous intervals.</p>
</td></tr>
<tr><td><code id="partial_derivatives_+3A_n_sim">n_sim</code></td>
<td>
<p>integer; the number of simulations used in computing the
simultaneous intervals.</p>
</td></tr>
<tr><td><code id="partial_derivatives_+3A_level">level</code></td>
<td>
<p>numeric; <code style="white-space: pre;">&#8288;0 &lt; level &lt; 1&#8288;</code>; the confidence level of the
point-wise or simultaneous interval. The default is <code>0.95</code> for a 95%
interval.</p>
</td></tr>
<tr><td><code id="partial_derivatives_+3A_unconditional">unconditional</code></td>
<td>
<p>logical; use smoothness selection-corrected Bayesian
covariance matrix?</p>
</td></tr>
<tr><td><code id="partial_derivatives_+3A_frequentist">frequentist</code></td>
<td>
<p>logical; use the frequentist covariance matrix?</p>
</td></tr>
<tr><td><code id="partial_derivatives_+3A_offset">offset</code></td>
<td>
<p>numeric; a value to use for any offset term</p>
</td></tr>
<tr><td><code id="partial_derivatives_+3A_ncores">ncores</code></td>
<td>
<p>number of cores for generating random variables from a
multivariate normal distribution. Passed to <code><a href="mvnfast.html#topic+rmvn">mvnfast::rmvn()</a></code>.
Parallelization will take place only if OpenMP is supported (but appears
to work on Windows with current <code>R</code>).</p>
</td></tr>
<tr><td><code id="partial_derivatives_+3A_partial_match">partial_match</code></td>
<td>
<p>logical; should smooths be selected by partial matches
with <code>term</code>? If <code>TRUE</code>, <code>term</code> can only be a single string to match
against.</p>
</td></tr>
<tr><td><code id="partial_derivatives_+3A_seed">seed</code></td>
<td>
<p>numeric; RNG seed to use.</p>
</td></tr>
<tr><td><code id="partial_derivatives_+3A_newdata">newdata</code></td>
<td>
<p>Deprecated: use <code>data</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble, currently with the following variables:
</p>

<ul>
<li> <p><code>.smooth</code>: the smooth each row refers to,
</p>
</li>
<li> <p><code>.partial_deriv</code>: the estimated partial derivative,
</p>
</li>
<li> <p><code>.se</code>: the standard error of the estimated partial derivative,
</p>
</li>
<li> <p><code>.crit</code>: the critical value such that <code>derivative</code> ± <code>(crit * se)</code> gives
the upper and lower bounds of the requested confidence or simultaneous
interval (given <code>level</code>),
</p>
</li>
<li> <p><code>.lower_ci</code>: the lower bound of the confidence or simultaneous interval,
</p>
</li>
<li> <p><code>.upper_ci</code>: the upper bound of the confidence or simultaneous interval.
</p>
</li></ul>



<h3>Note</h3>

<p><code>partial_derivatives()</code> will ignore any random effect smooths it
encounters in <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library("ggplot2")
library("patchwork")
load_mgcv()

df &lt;- data_sim("eg2", n = 2000, dist = "normal", scale = 0.5, seed = 42)

# fit the GAM (note: for execution time reasons, k is set articifially low)
m &lt;- gam(y ~ te(x, z, k = c(5, 5)), data = df, method = "REML")

# data slice through te(x,z) holding z == 0.4
ds &lt;- data_slice(m, x = evenly(x, n = 100), z = 0.4)

# evaluate te(x,z) at values of x &amp; z
sm &lt;- smooth_estimates(m, select = "te(x,z)", data = ds) |&gt;
  add_confint()

# partial derivatives
pd_x &lt;- partial_derivatives(m, data = ds, type = "central", focal = "x")

# draw te(x,z)
p1 &lt;- draw(m, rug = FALSE) &amp;
  geom_hline(yintercept = 0.4, linewidth = 1)
p1

# draw te(x,z) along slice
cap &lt;- expression(z == 0.4)
p2 &lt;- sm |&gt;
  ggplot(aes(x = x, y = .estimate)) +
  geom_ribbon(aes(ymin = .lower_ci, ymax = .upper_ci), alpha = 0.2) +
  geom_line() +
  labs(
    x = "x", y = "Partial effect", title = "te(x,z)",
    caption = cap
  )
p2

# draw partial derivs
p3 &lt;- pd_x |&gt;
  draw() +
  labs(caption = cap)
p3

# draw all three panels
p1 + p2 + p3 + plot_layout(ncol = 3)

</code></pre>

<hr>
<h2 id='partial_residuals'>Partial residuals</h2><span id='topic+partial_residuals'></span><span id='topic+partial_residuals.gam'></span>

<h3>Description</h3>

<p>Partial residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partial_residuals(object, ...)

## S3 method for class 'gam'
partial_residuals(object, select = NULL, partial_match = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partial_residuals_+3A_object">object</code></td>
<td>
<p>an R object, typically a model. Currently only objects of
class <code>"gam"</code> (or that inherit from that class) are supported.</p>
</td></tr>
<tr><td><code id="partial_residuals_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="partial_residuals_+3A_select">select</code></td>
<td>
<p>character, logical, or numeric; which smooths to plot. If
<code>NULL</code>, the default, then all model smooths are drawn. Numeric <code>select</code>
indexes the smooths in the order they are specified in the formula and
stored in <code>object</code>. Character <code>select</code> matches the labels for smooths
as shown for example in the output from <code>summary(object)</code>. Logical
<code>select</code> operates as per numeric <code>select</code> in the order that smooths are
stored.</p>
</td></tr>
<tr><td><code id="partial_residuals_+3A_partial_match">partial_match</code></td>
<td>
<p>logical; should smooths be selected by partial matches
with <code>select</code>? If <code>TRUE</code>, <code>select</code> can only be a single string to match
against.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## load mgcv
load_mgcv()

## example data - Gu &amp; Wabha four term model
df &lt;- data_sim("eg1", n = 400, seed = 42)
## fit the model
m &lt;- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = "REML")

## extract partial residuals
partial_residuals(m)

## and for a select term
partial_residuals(m, select = "s(x2)")

## or with partial matching
partial_residuals(m, select = "x", partial_match = TRUE) # returns all

</code></pre>

<hr>
<h2 id='penalty'>Extract and tidy penalty matrices</h2><span id='topic+penalty'></span><span id='topic+penalty.default'></span><span id='topic+penalty.gam'></span><span id='topic+penalty.mgcv.smooth'></span><span id='topic+penalty.tensor.smooth'></span><span id='topic+penalty.t2.smooth'></span><span id='topic+penalty.re.smooth.spec'></span>

<h3>Description</h3>

<p>Extract and tidy penalty matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penalty(object, ...)

## Default S3 method:
penalty(object, rescale = FALSE, data, knots = NULL, constraints = FALSE, ...)

## S3 method for class 'gam'
penalty(
  object,
  select = NULL,
  smooth = deprecated(),
  rescale = FALSE,
  partial_match = FALSE,
  ...
)

## S3 method for class 'mgcv.smooth'
penalty(object, rescale = FALSE, ...)

## S3 method for class 'tensor.smooth'
penalty(object, margins = FALSE, ...)

## S3 method for class 't2.smooth'
penalty(object, margins = FALSE, ...)

## S3 method for class 're.smooth.spec'
penalty(object, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penalty_+3A_object">object</code></td>
<td>
<p>a fitted GAM or a smooth.</p>
</td></tr>
<tr><td><code id="penalty_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods.</p>
</td></tr>
<tr><td><code id="penalty_+3A_rescale">rescale</code></td>
<td>
<p>logical; by default, <em>mgcv</em> will scale the penalty matrix for
better performance in <code><a href="mgcv.html#topic+gamm">mgcv::gamm()</a></code>. If <code>rescale</code> is <code>TRUE</code>, this scaling
will be undone to put the penalty matrix back on the original scale.</p>
</td></tr>
<tr><td><code id="penalty_+3A_data">data</code></td>
<td>
<p>data frame; a data frame of values for terms mentioned in the
smooth specification.</p>
</td></tr>
<tr><td><code id="penalty_+3A_knots">knots</code></td>
<td>
<p>a list or data frame with named components containing
knots locations. Names must match the covariates for which the basis
is required. See <code><a href="mgcv.html#topic+smoothCon">mgcv::smoothCon()</a></code>.</p>
</td></tr>
<tr><td><code id="penalty_+3A_constraints">constraints</code></td>
<td>
<p>logical; should identifiability constraints be applied to
the smooth basis. See argument <code>absorb.cons</code> in <code><a href="mgcv.html#topic+smoothCon">mgcv::smoothCon()</a></code>.</p>
</td></tr>
<tr><td><code id="penalty_+3A_select">select</code></td>
<td>
<p>character, logical, or numeric; which smooths to extract
penalties for. If <code>NULL</code>, the default, then penalties for all model
smooths are drawn. Numeric <code>select</code> indexes the smooths in the order they
are specified in the formula and stored in <code>object</code>. Character <code>select</code>
matches the labels for smooths as shown for example in the output from
<code>summary(object)</code>. Logical <code>select</code> operates as per numeric <code>select</code> in
the order that smooths are stored.</p>
</td></tr>
<tr><td><code id="penalty_+3A_smooth">smooth</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>select</code> instead.</p>
</td></tr>
<tr><td><code id="penalty_+3A_partial_match">partial_match</code></td>
<td>
<p>logical; should smooths be selected by partial matches
with <code>select</code>? If <code>TRUE</code>, <code>select</code> can only be a single string to match
against.</p>
</td></tr>
<tr><td><code id="penalty_+3A_margins">margins</code></td>
<td>
<p>logical; extract the penalty matrices for the tensor
product or the marginal smooths of the tensor product?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'tibble' (data frame) of class <code>penalty_df</code> inheriting from
<code>tbl_df</code>, with the following components:
</p>

<ul>
<li> <p><code>.smooth</code> - character; the label <em>mgcv</em> uses to refer to the smooth,
</p>
</li>
<li> <p><code>.type</code> - character; the type of smooth,
</p>
</li>
<li> <p><code>.penalty</code> - character; the label for the specific penalty. Some smooths
have multiple penalty matrices, so the <code>penalty</code> component identifies the
particular penalty matrix and uses the labelling that <em>mgcv</em> uses
internally,
</p>
</li>
<li> <p><code>.row</code> - character; a label of the form <code>fn</code> where <code>n</code> is an integer for
the <code>n</code>th basis function, referencing the columns of the penalty matrix,
</p>
</li>
<li> <p><code>.col</code> - character; a label of the form <code>fn</code> where <code>n</code> is an integer for
the <code>n</code>th basis function, referencing the columns of the penalty matrix,
</p>
</li>
<li> <p><code>.value</code> - double; the value of the penalty matrix for the combination of
<code>row</code> and <code>col</code>,
</p>
</li></ul>



<h3>Note</h3>

<p>The <code>print()</code> method uses <code><a href="base.html#topic+zapsmall">base::zapsmall()</a></code> to turn very small numbers
into 0s for display purposes only; the underlying values of the penalty
matrix or matrices are not changed.
</p>
<p>For smooths that are subject to an eigendecomposition (e.g. the default
thin plate regression splines, <code>bs = "tp"</code>), the signs of the eigenvectors
are not defined and as such you can expect differences across systems in
the penalties for such smooths that are system-, OS-, and CPU architecture-
specific.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
load_mgcv()
dat &lt;- data_sim("eg4", n = 400, seed = 42)
m &lt;- gam(
  y ~ s(x0, bs = "cr") + s(x1, bs = "cr") +
    s(x2, by = fac, bs = "cr"),
  data = dat, method = "REML"
)

# penalties for all smooths
penalty(m)

# for a specific smooth
penalty(m, select = "s(x2):fac1")


</code></pre>

<hr>
<h2 id='post_draws'>Low-level Functions to generate draws from the posterior distribution of
model coefficients</h2><span id='topic+post_draws'></span><span id='topic+post_draws.default'></span><span id='topic+generate_draws'></span><span id='topic+generate_draws.gam'></span>

<h3>Description</h3>

<p>Low-level Functions to generate draws from the posterior distribution of
model coefficients
</p>
<p>Generate posterior draws from a fitted model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_draws(model, ...)

## Default S3 method:
post_draws(
  model,
  n,
  method = c("gaussian", "mh", "inla", "user"),
  mu = NULL,
  sigma = NULL,
  n_cores = 1L,
  burnin = 1000,
  thin = 1,
  t_df = 40,
  rw_scale = 0.25,
  index = NULL,
  frequentist = FALSE,
  unconditional = FALSE,
  parametrized = TRUE,
  mvn_method = c("mvnfast", "mgcv"),
  draws = NULL,
  seed = NULL,
  ...
)

generate_draws(model, ...)

## S3 method for class 'gam'
generate_draws(
  model,
  n,
  method = c("gaussian", "mh", "inla"),
  mu = NULL,
  sigma = NULL,
  n_cores = 1L,
  burnin = 1000,
  thin = 1,
  t_df = 40,
  rw_scale = 0.25,
  index = NULL,
  frequentist = FALSE,
  unconditional = FALSE,
  mvn_method = c("mvnfast", "mgcv"),
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="post_draws_+3A_model">model</code></td>
<td>
<p>a fitted R model. Currently only models fitted by <code>mgcv::gam()</code>
or <code>mgcv::bam()</code>, or return an object that <em>inherits</em> from such objects are
supported. Here, &quot;inherits&quot; is used in a loose fashion; models fitted by
<code>scam::scam()</code> are support even though those models don't strictly inherit
from class <code>"gam"</code> as far as <code>inherits()</code> is concerned.</p>
</td></tr>
<tr><td><code id="post_draws_+3A_...">...</code></td>
<td>
<p>arguments passed to methods.</p>
</td></tr>
<tr><td><code id="post_draws_+3A_n">n</code></td>
<td>
<p>numeric; the number of posterior draws to take.</p>
</td></tr>
<tr><td><code id="post_draws_+3A_method">method</code></td>
<td>
<p>character; which algorithm to use to sample from the posterior.
Currently implemented methods are: <code>"gaussian"</code> and <code>"mh"</code>. <code>"gaussian"</code>
calls <code>gaussian_draws()</code> which uses a Gaussian approximation to the
posterior distribution. <code>"mh"</code> uses a simple Metropolis Hasting sampler
which alternates static proposals based on a Gaussian approximation to the
posterior, with random walk proposals. Note, setting <code>t_df</code> to a low value
will result in heavier-tailed statistic proposals. See <code>mgcv::gam.mh()</code>
for more details.</p>
</td></tr>
<tr><td><code id="post_draws_+3A_mu">mu</code></td>
<td>
<p>numeric; user-supplied mean vector (vector of model coefficients).
Currently ignored.</p>
</td></tr>
<tr><td><code id="post_draws_+3A_sigma">sigma</code></td>
<td>
<p>matrix; user-supplied covariance matrix for <code>mu</code>. Currently
ignored.</p>
</td></tr>
<tr><td><code id="post_draws_+3A_n_cores">n_cores</code></td>
<td>
<p>integer; number of CPU cores to use when generating
multivariate normal distributed random values. Only used if
<code>mvn_method = "mvnfast"</code> <strong>and</strong> <code>method = "gaussian"</code>.</p>
</td></tr>
<tr><td><code id="post_draws_+3A_burnin">burnin</code></td>
<td>
<p>numeric; the length of any initial burn in period to discard.
See <code>mgcv::gam.mh()</code>.</p>
</td></tr>
<tr><td><code id="post_draws_+3A_thin">thin</code></td>
<td>
<p>numeric; retain only <code>thin</code> samples. See <code>mgcv::gam.mh()</code>.</p>
</td></tr>
<tr><td><code id="post_draws_+3A_t_df">t_df</code></td>
<td>
<p>numeric; degrees of freedom for static multivariate <em>t</em> proposal.
See <code>mgcv::gam.mh()</code>.</p>
</td></tr>
<tr><td><code id="post_draws_+3A_rw_scale">rw_scale</code></td>
<td>
<p>numeric; factor by which to scale posterior covariance
matrix when generating random walk proposals. See <code>mgcv::gam.mh()</code>.</p>
</td></tr>
<tr><td><code id="post_draws_+3A_index">index</code></td>
<td>
<p>numeric; vector of indices of coefficients to use. Can be used
to subset the mean vector and covariance matrix extracted from <code>model</code>.</p>
</td></tr>
<tr><td><code id="post_draws_+3A_frequentist">frequentist</code></td>
<td>
<p>logical; if <code>TRUE</code>, the frequentist covariance matrix of
the parameter estimates is used. If <code>FALSE</code>, the Bayesian posterior
covariance matrix of the parameters is used. See <code>mgcv::vcov.gam()</code>.</p>
</td></tr>
<tr><td><code id="post_draws_+3A_unconditional">unconditional</code></td>
<td>
<p>logical; if <code>TRUE</code>  the Bayesian smoothing parameter
uncertainty corrected covariance matrix is used, <em>if available</em> for
<code>model</code>. See <code>mgcv::vcov.gam()</code>.</p>
</td></tr>
<tr><td><code id="post_draws_+3A_parametrized">parametrized</code></td>
<td>
<p>logical; use parametrized coefficients and covariance
matrix, which respect the linear inequality constraints of the model. Only
for <code>scam::scam()</code> model fits.</p>
</td></tr>
<tr><td><code id="post_draws_+3A_mvn_method">mvn_method</code></td>
<td>
<p>character; one of <code>"mvnfast"</code> or <code>"mgcv"</code>. The default is
uses <code>mvnfast::rmvn()</code>, which can be considerably faster at generate large
numbers of MVN random values than <code>mgcv::rmvn()</code>, but which might not work
for some marginal fits, such as those where the covariance matrix is close
to singular.</p>
</td></tr>
<tr><td><code id="post_draws_+3A_draws">draws</code></td>
<td>
<p>matrix; user supplied posterior draws to be used when
<code>method = "user"</code>.</p>
</td></tr>
<tr><td><code id="post_draws_+3A_seed">seed</code></td>
<td>
<p>numeric; the random seed to use. If <code>NULL</code>, a random seed will
be generated without affecting the current state of R's RNG.</p>
</td></tr>
</table>

<hr>
<h2 id='post_link_funs'>A list of transformation functions named for LSS parameters in a GAMLSS</h2><span id='topic+post_link_funs'></span>

<h3>Description</h3>

<p>A list of transformation functions named for LSS parameters in a GAMLSS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_link_funs(
  location = identity_fun,
  scale = identity_fun,
  shape = identity_fun,
  skewness = identity_fun,
  kurtosis = identity_fun,
  power = identity_fun,
  pi = identity_fun
)
</code></pre>

<hr>
<h2 id='posterior_samples'>Draw samples from the posterior distribution of an estimated model</h2><span id='topic+posterior_samples'></span><span id='topic+posterior_samples.gam'></span>

<h3>Description</h3>

<p>Draw samples from the posterior distribution of an estimated model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior_samples(model, ...)

## S3 method for class 'gam'
posterior_samples(
  model,
  n,
  data = newdata,
  seed = NULL,
  method = c("gaussian", "mh", "inla", "user"),
  n_cores = 1,
  burnin = 1000,
  thin = 1,
  t_df = 40,
  rw_scale = 0.25,
  freq = FALSE,
  unconditional = FALSE,
  weights = NULL,
  draws = NULL,
  ...,
  newdata = NULL,
  ncores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_samples_+3A_model">model</code></td>
<td>
<p>a fitted model of the supported types</p>
</td></tr>
<tr><td><code id="posterior_samples_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods. For <code>fitted_samples()</code>, these
are passed on to <code><a href="mgcv.html#topic+predict.gam">predict.gam()</a></code>. For <code>posterior_samples()</code> these are
passed on to <code>fitted_samples()</code>. For <code>predicted_samples()</code> these are
passed on to the relevant <code>simulate()</code> method.</p>
</td></tr>
<tr><td><code id="posterior_samples_+3A_n">n</code></td>
<td>
<p>numeric; the number of posterior samples to return.</p>
</td></tr>
<tr><td><code id="posterior_samples_+3A_data">data</code></td>
<td>
<p>data frame; new observations at which the posterior draws
from the model should be evaluated. If not supplied, the data used to fit
the model will be used for <code>data</code>, if available in <code>model</code>.</p>
</td></tr>
<tr><td><code id="posterior_samples_+3A_seed">seed</code></td>
<td>
<p>numeric; a random seed for the simulations.</p>
</td></tr>
<tr><td><code id="posterior_samples_+3A_method">method</code></td>
<td>
<p>character; which method should be used to draw samples from
the posterior distribution. <code>"gaussian"</code> uses a Gaussian (Laplace)
approximation to the posterior. <code>"mh"</code> uses a Metropolis Hastings sampler
that alternates t proposals with proposals based on a shrunken version of
the posterior covariance matrix. <code>"inla"</code> uses a variant of Integrated
Nested Laplace Approximation due to Wood (2019), (currently not
implemented). <code>"user"</code> allows for user-supplied posterior draws
(currently not implemented).</p>
</td></tr>
<tr><td><code id="posterior_samples_+3A_n_cores">n_cores</code></td>
<td>
<p>number of cores for generating random variables from a
multivariate normal distribution. Passed to <code><a href="mvnfast.html#topic+rmvn">mvnfast::rmvn()</a></code>.
Parallelization will take place only if OpenMP is supported (but appears
to work on Windows with current <code>R</code>).</p>
</td></tr>
<tr><td><code id="posterior_samples_+3A_burnin">burnin</code></td>
<td>
<p>numeric; number of samples to discard as the burnin draws.
Only used with <code>method = "mh"</code>.</p>
</td></tr>
<tr><td><code id="posterior_samples_+3A_thin">thin</code></td>
<td>
<p>numeric; the number of samples to skip when taking <code>n</code> draws.
Results in <code>thin * n</code> draws from the posterior being taken. Only used with
<code>method = "mh"</code>.</p>
</td></tr>
<tr><td><code id="posterior_samples_+3A_t_df">t_df</code></td>
<td>
<p>numeric; degrees of freedome for t distribution proposals. Only
used with <code>method = "mh"</code>.</p>
</td></tr>
<tr><td><code id="posterior_samples_+3A_rw_scale">rw_scale</code></td>
<td>
<p>numeric; Factor by which to scale posterior covariance
matrix when generating random walk proposals. Negative or non finite to
skip the random walk step. Only used with <code>method = "mh"</code>.</p>
</td></tr>
<tr><td><code id="posterior_samples_+3A_freq">freq</code></td>
<td>
<p>logical; <code>TRUE</code> to use the frequentist covariance matrix of
the parameter estimators, <code>FALSE</code> to use the Bayesian posterior
covariance matrix of the parameters.</p>
</td></tr>
<tr><td><code id="posterior_samples_+3A_unconditional">unconditional</code></td>
<td>
<p>logical; if <code>TRUE</code> (and <code>freq == FALSE</code>) then the
Bayesian smoothing parameter uncertainty corrected covariance matrix is
used, if available.</p>
</td></tr>
<tr><td><code id="posterior_samples_+3A_weights">weights</code></td>
<td>
<p>numeric; a vector of prior weights. If <code>data</code> is null
then defaults to <code>object[["prior.weights"]]</code>, otherwise a vector of ones.</p>
</td></tr>
<tr><td><code id="posterior_samples_+3A_draws">draws</code></td>
<td>
<p>matrix; user supplied posterior draws to be used when
<code>method = "user"</code>.</p>
</td></tr>
<tr><td><code id="posterior_samples_+3A_newdata">newdata</code></td>
<td>
<p>Deprecated: use <code>data</code> instead.</p>
</td></tr>
<tr><td><code id="posterior_samples_+3A_ncores">ncores</code></td>
<td>
<p>Deprecated; use <code>n_cores</code> instead. The number of cores for
generating random variables from a multivariate normal distribution.
Passed to <code><a href="mvnfast.html#topic+rmvn">mvnfast::rmvn()</a></code>. Parallelization will take place only if
OpenMP is supported (but appears to work on Windows with current <code>R</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble (data frame) with 3 columns containing the posterior
predicted values in long format. The columns are
</p>

<ul>
<li> <p><code>row</code> (integer) the row of <code>data</code> that each posterior draw relates to,
</p>
</li>
<li> <p><code>draw</code> (integer) an index, in range <code>1:n</code>, indicating which draw each row
relates to,
</p>
</li>
<li> <p><code>response</code> (numeric) the predicted response for the indicated row of
<code>data</code>.
</p>
</li></ul>



<h3>Note</h3>

<p>Models with offset terms supplied via the <code>offset</code> argument to
<code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code> etc. are ignored by <code><a href="mgcv.html#topic+predict.gam">mgcv::predict.gam()</a></code>. As such, this
kind of offset term is also ignored by <code>posterior_samples()</code>. Offset terms
that are included in the model formula supplied to <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code> etc are
not ignored and the posterior samples produced will reflect those offset
term values. This has the side effect of requiring any new data values
provided to <code>posterior_samples()</code> via the <code>data</code> argument must include the
offset variable.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>References</h3>

<p>Wood, S.N., (2020). Simplified integrated nested Laplace approximation.
<em>Biometrika</em> <strong>107</strong>, 223&ndash;230. <a href="https://doi.org/10.1093/biomet/asz044">doi:10.1093/biomet/asz044</a>
</p>

<hr>
<h2 id='predicted_samples'>Draw new response values from the conditional distribution of the response</h2><span id='topic+predicted_samples'></span><span id='topic+predicted_samples.gam'></span>

<h3>Description</h3>

<p>Predicted values of the response (new response data) are drawn from the
fitted model, created via <code>simulate()</code> (e.g. <code><a href="#topic+simulate.gam">simulate.gam()</a></code>) and returned
in a tidy, long, format. These predicted values do not include the
uncertainty in the estimated model; they are simply draws from the
conditional distribution of the response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predicted_samples(model, ...)

## S3 method for class 'gam'
predicted_samples(
  model,
  n = 1,
  data = newdata,
  seed = NULL,
  weights = NULL,
  ...,
  newdata = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predicted_samples_+3A_model">model</code></td>
<td>
<p>a fitted model of the supported types</p>
</td></tr>
<tr><td><code id="predicted_samples_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods. For <code>fitted_samples()</code>, these
are passed on to <code><a href="mgcv.html#topic+predict.gam">predict.gam()</a></code>. For <code>posterior_samples()</code> these are
passed on to <code>fitted_samples()</code>. For <code>predicted_samples()</code> these are
passed on to the relevant <code>simulate()</code> method.</p>
</td></tr>
<tr><td><code id="predicted_samples_+3A_n">n</code></td>
<td>
<p>numeric; the number of posterior samples to return.</p>
</td></tr>
<tr><td><code id="predicted_samples_+3A_data">data</code></td>
<td>
<p>data frame; new observations at which the posterior draws
from the model should be evaluated. If not supplied, the data used to fit
the model will be used for <code>data</code>, if available in <code>model</code>.</p>
</td></tr>
<tr><td><code id="predicted_samples_+3A_seed">seed</code></td>
<td>
<p>numeric; a random seed for the simulations.</p>
</td></tr>
<tr><td><code id="predicted_samples_+3A_weights">weights</code></td>
<td>
<p>numeric; a vector of prior weights. If <code>data</code> is null
then defaults to <code>object[["prior.weights"]]</code>, otherwise a vector of ones.</p>
</td></tr>
<tr><td><code id="predicted_samples_+3A_newdata">newdata</code></td>
<td>
<p>Deprecated: use <code>data</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble (data frame) with 3 columns containing the posterior
predicted values in long format. The columns are
</p>

<ul>
<li> <p><code>row</code> (integer) the row of <code>data</code> that each posterior draw relates to,
</p>
</li>
<li> <p><code>draw</code> (integer) an index, in range <code>1:n</code>, indicating which draw each row
relates to,
</p>
</li>
<li> <p><code>response</code> (numeric) the predicted response for the indicated row of
<code>data</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()

dat &lt;- data_sim("eg1", n = 1000, dist = "normal", scale = 2, seed = 2)
m &lt;- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")

predicted_samples(m, n = 5, seed = 42)

## Can pass arguments to predict.gam()

newd &lt;- data.frame(
  x0 = runif(10), x1 = runif(10), x2 = runif(10),
  x3 = runif(10)
)

## Exclude s(x2)
predicted_samples(m, n = 5, newd, exclude = "s(x2)", seed = 25)

## Exclude s(x1)
predicted_samples(m, n = 5, newd, exclude = "s(x1)", seed = 25)

## Select which terms --- result should be the same as previous
## but note that we have to include any parametric terms, including the
## constant term
predicted_samples(m,
  n = 5, newd, seed = 25,
  terms = c("Intercept", "s(x0)", "s(x2)", "s(x3)")
)

</code></pre>

<hr>
<h2 id='qq_plot'>Quantile-quantile plot of model residuals</h2><span id='topic+qq_plot'></span><span id='topic+qq_plot.default'></span><span id='topic+qq_plot.gam'></span><span id='topic+qq_plot.glm'></span><span id='topic+qq_plot.lm'></span>

<h3>Description</h3>

<p>Quantile-quantile plot of model residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qq_plot(model, ...)

## Default S3 method:
qq_plot(model, ...)

## S3 method for class 'gam'
qq_plot(
  model,
  method = c("uniform", "simulate", "normal", "direct"),
  type = c("deviance", "response", "pearson"),
  n_uniform = 10,
  n_simulate = 50,
  level = 0.9,
  ylab = NULL,
  xlab = NULL,
  title = NULL,
  subtitle = NULL,
  caption = NULL,
  ci_col = "black",
  ci_alpha = 0.2,
  point_col = "black",
  point_alpha = 1,
  line_col = "red",
  ...
)

## S3 method for class 'glm'
qq_plot(model, ...)

## S3 method for class 'lm'
qq_plot(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qq_plot_+3A_model">model</code></td>
<td>
<p>a fitted model. Currently only class <code>"gam"</code>.</p>
</td></tr>
<tr><td><code id="qq_plot_+3A_...">...</code></td>
<td>
<p>arguments passed ot other methods.</p>
</td></tr>
<tr><td><code id="qq_plot_+3A_method">method</code></td>
<td>
<p>character; method used to generate theoretical quantiles. Note
that <code>method = "direct"</code> is deprecated in favour of <code>method = "uniform"</code>.</p>
</td></tr>
<tr><td><code id="qq_plot_+3A_type">type</code></td>
<td>
<p>character; type of residuals to use. Only <code>"deviance"</code>,
<code>"response"</code>, and <code>"pearson"</code> residuals are allowed.</p>
</td></tr>
<tr><td><code id="qq_plot_+3A_n_uniform">n_uniform</code></td>
<td>
<p>numeric; number of times to randomize uniform quantiles
in the direct computation method (<code>method = "uniform"</code>).</p>
</td></tr>
<tr><td><code id="qq_plot_+3A_n_simulate">n_simulate</code></td>
<td>
<p>numeric; number of data sets to simulate from the estimated
model when using the simulation method (<code>method = "simulate"</code>).</p>
</td></tr>
<tr><td><code id="qq_plot_+3A_level">level</code></td>
<td>
<p>numeric; the coverage level for reference intervals. Must be
strictly <code style="white-space: pre;">&#8288;0 &lt; level &lt; 1&#8288;</code>. Only used with <code>method = "simulate"</code>.</p>
</td></tr>
<tr><td><code id="qq_plot_+3A_ylab">ylab</code></td>
<td>
<p>character or expression; the label for the y axis. If not
supplied, a suitable label will be generated.</p>
</td></tr>
<tr><td><code id="qq_plot_+3A_xlab">xlab</code></td>
<td>
<p>character or expression; the label for the y axis. If not
supplied, a suitable label will be generated.</p>
</td></tr>
<tr><td><code id="qq_plot_+3A_title">title</code></td>
<td>
<p>character or expression; the title for the plot. See
<code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>. May be a vector, one per penalty.</p>
</td></tr>
<tr><td><code id="qq_plot_+3A_subtitle">subtitle</code></td>
<td>
<p>character or expression; the subtitle for the plot. See
<code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>. May be a vector, one per penalty.</p>
</td></tr>
<tr><td><code id="qq_plot_+3A_caption">caption</code></td>
<td>
<p>character or expression; the plot caption. See
<code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>. May be a vector, one per penalty.</p>
</td></tr>
<tr><td><code id="qq_plot_+3A_ci_col">ci_col</code></td>
<td>
<p>fill colour for the reference interval when
<code>method = "simulate"</code>.</p>
</td></tr>
<tr><td><code id="qq_plot_+3A_ci_alpha">ci_alpha</code></td>
<td>
<p>alpha transparency for the reference
interval when <code>method = "simulate"</code>.</p>
</td></tr>
<tr><td><code id="qq_plot_+3A_point_col">point_col</code></td>
<td>
<p>colour of points on the QQ plot.</p>
</td></tr>
<tr><td><code id="qq_plot_+3A_point_alpha">point_alpha</code></td>
<td>
<p>alpha transparency of points on the QQ plot.</p>
</td></tr>
<tr><td><code id="qq_plot_+3A_line_col">line_col</code></td>
<td>
<p>colour used to draw the reference line.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The wording used in <code><a href="mgcv.html#topic+qq.gam">mgcv::qq.gam()</a></code> uses <em>direct</em> in reference to the
simulated residuals method (<code>method = "simulated"</code>). To avoid confusion,
<code>method = "direct"</code> is deprecated in favour of <code>method = "uniform"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()
## simulate binomial data...
dat &lt;- data_sim("eg1", n = 200, dist = "binary", scale = .33, seed = 0)
p &lt;- binomial()$linkinv(dat$f) # binomial p
n &lt;- sample(c(1, 3), 200, replace = TRUE) # binomial n
dat &lt;- transform(dat, y = rbinom(n, n, p), n = n)
m &lt;- gam(y / n ~ s(x0) + s(x1) + s(x2) + s(x3),
  family = binomial, data = dat, weights = n,
  method = "REML"
)

## Q-Q plot; default using direct randomization of uniform quantiles
qq_plot(m)

## Alternatively use simulate new data from the model, which
## allows construction of reference intervals for the Q-Q plot
qq_plot(m,
  method = "simulate", point_col = "steelblue",
  point_alpha = 0.4
)

## ... or use the usual normality assumption
qq_plot(m, method = "normal")
</code></pre>

<hr>
<h2 id='ref_level'>Return the reference or specific level of a factor</h2><span id='topic+ref_level'></span><span id='topic+level'></span>

<h3>Description</h3>

<p>Extracts the reference or a specific level the supplied factor,
returning it as a factor with the same levels as the one supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ref_level(fct)

level(fct, level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ref_level_+3A_fct">fct</code></td>
<td>
<p>factor; the factor from which the reference or specific level will
be extracted.</p>
</td></tr>
<tr><td><code id="ref_level_+3A_level">level</code></td>
<td>
<p>character; the specific level to extract in the case of
<code>level()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A length 1 factor with the same levels as the supplied factor <code>fct</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- factor(sample(letters[1:5], 100, replace = TRUE))

# the reference level
ref_level(f)

# a specific level
level(f, level = "b")

# note that the levels will always match the input factor
identical(levels(f), levels(ref_level(f)))
identical(levels(f), levels(level(f, "c")))
</code></pre>

<hr>
<h2 id='ref_sims'>Reference simulation data</h2><span id='topic+ref_sims'></span>

<h3>Description</h3>

<p>A set of reference objects for testing <code><a href="#topic+data_sim">data_sim()</a></code>.
</p>


<h3>Format</h3>

<p>A named list of simulated data sets created by <code><a href="#topic+data_sim">data_sim()</a></code>.
</p>

<hr>
<h2 id='reorder_fs_smooth_terms'>Reorder random factor smooth terms to place factor last</h2><span id='topic+reorder_fs_smooth_terms'></span>

<h3>Description</h3>

<p>Reorder random factor smooth terms to place factor last
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reorder_fs_smooth_terms(smooth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reorder_fs_smooth_terms_+3A_smooth">smooth</code></td>
<td>
<p>an mgcv smooth object</p>
</td></tr>
</table>

<hr>
<h2 id='reorder_tensor_smooth_terms'>Reorder tensor product terms for nicer plotting</h2><span id='topic+reorder_tensor_smooth_terms'></span>

<h3>Description</h3>

<p>If a tensor product smooth of 3 or more terms contains a 2d marginal smooth,
we will get nicer output from <code><a href="#topic+smooth_estimates">smooth_estimates()</a></code> and hence a nicer plot
from the <code><a href="#topic+draw.smooth_estimates">draw.smooth_estimates()</a></code> method if we reorder the terms of the
smooth such that we vary the terms in the 2d marginal first, and any other
terms vary more slowly when we generate data to evaluate the smooth at. This
results in automatically generated data that focuses on the (or the first if
more than one) 2d marginal smooth, with the end result that
<code><a href="#topic+smooth_estimates">smooth_estimates()</a></code> shows how that 2d smooth changes with the other terms
involved in the smooth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reorder_tensor_smooth_terms(smooth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reorder_tensor_smooth_terms_+3A_smooth">smooth</code></td>
<td>
<p>an mgcv smooth object</p>
</td></tr>
</table>

<hr>
<h2 id='rep_first_factor_value'>Repeat the first level of a factor n times</h2><span id='topic+rep_first_factor_value'></span>

<h3>Description</h3>

<p>Function to repeat the first level of a factor n times and
return this vector as a factor with the original levels intact
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rep_first_factor_value(f, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rep_first_factor_value_+3A_f">f</code></td>
<td>
<p>a factor</p>
</td></tr>
<tr><td><code id="rep_first_factor_value_+3A_n">n</code></td>
<td>
<p>numeric; the number of times to repeat the first level of <code>f</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A factor of length <code>n</code> with the levels of <code>f</code>, but whose elements
are all the first level of <code>f</code>.
</p>

<hr>
<h2 id='residuals_hist_plot'>Histogram of model residuals</h2><span id='topic+residuals_hist_plot'></span>

<h3>Description</h3>

<p>Histogram of model residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residuals_hist_plot(
  model,
  type = c("deviance", "pearson", "response"),
  n_bins = c("sturges", "scott", "fd"),
  ylab = NULL,
  xlab = NULL,
  title = NULL,
  subtitle = NULL,
  caption = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals_hist_plot_+3A_model">model</code></td>
<td>
<p>a fitted model. Currently only class <code>"gam"</code>.</p>
</td></tr>
<tr><td><code id="residuals_hist_plot_+3A_type">type</code></td>
<td>
<p>character; type of residuals to use. Only <code>"deviance"</code>,
<code>"response"</code>, and <code>"pearson"</code> residuals are allowed.</p>
</td></tr>
<tr><td><code id="residuals_hist_plot_+3A_n_bins">n_bins</code></td>
<td>
<p>character or numeric; either the number of bins or a string
indicating how to calculate the number of bins.</p>
</td></tr>
<tr><td><code id="residuals_hist_plot_+3A_ylab">ylab</code></td>
<td>
<p>character or expression; the label for the y axis. If not
supplied, a suitable label will be generated.</p>
</td></tr>
<tr><td><code id="residuals_hist_plot_+3A_xlab">xlab</code></td>
<td>
<p>character or expression; the label for the y axis. If not
supplied, a suitable label will be generated.</p>
</td></tr>
<tr><td><code id="residuals_hist_plot_+3A_title">title</code></td>
<td>
<p>character or expression; the title for the plot. See
<code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>.</p>
</td></tr>
<tr><td><code id="residuals_hist_plot_+3A_subtitle">subtitle</code></td>
<td>
<p>character or expression; the subtitle for the plot. See
<code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>.</p>
</td></tr>
<tr><td><code id="residuals_hist_plot_+3A_caption">caption</code></td>
<td>
<p>character or expression; the plot caption. See
<code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='residuals_linpred_plot'>Plot of residuals versus linear predictor values</h2><span id='topic+residuals_linpred_plot'></span>

<h3>Description</h3>

<p>Plot of residuals versus linear predictor values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residuals_linpred_plot(
  model,
  type = c("deviance", "pearson", "response"),
  ylab = NULL,
  xlab = NULL,
  title = NULL,
  subtitle = NULL,
  caption = NULL,
  point_col = "black",
  point_alpha = 1,
  line_col = "red"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals_linpred_plot_+3A_model">model</code></td>
<td>
<p>a fitted model. Currently only class <code>"gam"</code>.</p>
</td></tr>
<tr><td><code id="residuals_linpred_plot_+3A_type">type</code></td>
<td>
<p>character; type of residuals to use. Only <code>"deviance"</code>,
<code>"response"</code>, and <code>"pearson"</code> residuals are allowed.</p>
</td></tr>
<tr><td><code id="residuals_linpred_plot_+3A_ylab">ylab</code></td>
<td>
<p>character or expression; the label for the y axis. If not
supplied, a suitable label will be generated.</p>
</td></tr>
<tr><td><code id="residuals_linpred_plot_+3A_xlab">xlab</code></td>
<td>
<p>character or expression; the label for the y axis. If not
supplied, a suitable label will be generated.</p>
</td></tr>
<tr><td><code id="residuals_linpred_plot_+3A_title">title</code></td>
<td>
<p>character or expression; the title for the plot. See
<code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>.</p>
</td></tr>
<tr><td><code id="residuals_linpred_plot_+3A_subtitle">subtitle</code></td>
<td>
<p>character or expression; the subtitle for the plot. See
<code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>.</p>
</td></tr>
<tr><td><code id="residuals_linpred_plot_+3A_caption">caption</code></td>
<td>
<p>character or expression; the plot caption. See
<code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>.</p>
</td></tr>
<tr><td><code id="residuals_linpred_plot_+3A_point_col">point_col</code></td>
<td>
<p>colour used to draw points in the plots. See
<code><a href="graphics.html#topic+par">graphics::par()</a></code> section <strong>Color Specification</strong>. This is passed to
the individual plotting functions, and therefore affects the points of
all plots.</p>
</td></tr>
<tr><td><code id="residuals_linpred_plot_+3A_point_alpha">point_alpha</code></td>
<td>
<p>numeric; alpha transparency for points in plots.</p>
</td></tr>
<tr><td><code id="residuals_linpred_plot_+3A_line_col">line_col</code></td>
<td>
<p>colour specification for 1:1 line.</p>
</td></tr>
</table>

<hr>
<h2 id='response_derivatives'>Derivatives on the response scale from an estimated GAM</h2><span id='topic+response_derivatives'></span><span id='topic+response_derivatives.default'></span><span id='topic+response_derivatives.gamm'></span><span id='topic+response_derivatives.gam'></span>

<h3>Description</h3>

<p>Derivatives on the response scale from an estimated GAM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>response_derivatives(object, ...)

## Default S3 method:
response_derivatives(object, ...)

## S3 method for class 'gamm'
response_derivatives(object, ...)

## S3 method for class 'gam'
response_derivatives(
  object,
  focal = NULL,
  data = NULL,
  order = 1L,
  type = c("forward", "backward", "central"),
  scale = c("response", "linear_predictor"),
  method = c("gaussian", "mh", "inla", "user"),
  n = 100,
  eps = 1e-07,
  n_sim = 10000,
  level = 0.95,
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="response_derivatives_+3A_object">object</code></td>
<td>
<p>an R object to compute derivatives for.</p>
</td></tr>
<tr><td><code id="response_derivatives_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods and on to <code>fitted_samples()</code></p>
</td></tr>
<tr><td><code id="response_derivatives_+3A_focal">focal</code></td>
<td>
<p>character; name of the focal variable. The response derivative
of the response with respect to this variable will be returned.
All other variables involved in the model will be held at constant values.
This can be missing if supplying <code>data</code>, in which case, the focal variable
will be identified as the one variable that is not constant.</p>
</td></tr>
<tr><td><code id="response_derivatives_+3A_data">data</code></td>
<td>
<p>a data frame containing the values of the model covariates
at which to evaluate the first derivatives of the smooths. If supplied,
all but one variable must be held at a constant value.</p>
</td></tr>
<tr><td><code id="response_derivatives_+3A_order">order</code></td>
<td>
<p>numeric; the order of derivative.</p>
</td></tr>
<tr><td><code id="response_derivatives_+3A_type">type</code></td>
<td>
<p>character; the type of finite difference used. One of
<code>"forward"</code>, <code>"backward"</code>, or <code>"central"</code>.</p>
</td></tr>
<tr><td><code id="response_derivatives_+3A_scale">scale</code></td>
<td>
<p>character; should the derivative be estimated on the response
or the linear predictor (link) scale? One of <code>"response"</code> (the default),
or <code>"linear predictor"</code>.</p>
</td></tr>
<tr><td><code id="response_derivatives_+3A_method">method</code></td>
<td>
<p>character; which method should be used to draw samples from
the posterior distribution. <code>"gaussian"</code> uses a Gaussian (Laplace)
approximation to the posterior. <code>"mh"</code> uses a Metropolis Hastings sample
that alternates t proposals with proposals based on a shrunken version of
the posterior covariance matrix. <code>"inla"</code> uses a variant of Integrated
Nested Laplace Approximation due to Wood (2019), (currently not
implemented). <code>"user"</code> allows for user-supplied posterior draws
(currently not implemented).</p>
</td></tr>
<tr><td><code id="response_derivatives_+3A_n">n</code></td>
<td>
<p>numeric; the number of points to evaluate the derivative at (if
<code>data</code> is not supplied).</p>
</td></tr>
<tr><td><code id="response_derivatives_+3A_eps">eps</code></td>
<td>
<p>numeric; the finite difference.</p>
</td></tr>
<tr><td><code id="response_derivatives_+3A_n_sim">n_sim</code></td>
<td>
<p>integer; the number of simulations used in computing the
simultaneous intervals.</p>
</td></tr>
<tr><td><code id="response_derivatives_+3A_level">level</code></td>
<td>
<p>numeric; <code style="white-space: pre;">&#8288;0 &lt; level &lt; 1&#8288;</code>; the coverage level of the
credible interval. The default is <code>0.95</code> for a 95% interval.</p>
</td></tr>
<tr><td><code id="response_derivatives_+3A_seed">seed</code></td>
<td>
<p>numeric; a random seed for the simulations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble, currently with the following variables:
</p>

<ul>
<li> <p><code>.row</code>: integer, indexing the row of <code>data</code> each row in the output
represents
</p>
</li>
<li> <p><code>.focal</code>: the name of the variable for which the partial derivative was
evaluated,
</p>
</li>
<li> <p><code>.derivative</code>: the estimated partial derivative,
</p>
</li>
<li> <p><code>.lower_ci</code>: the lower bound of the confidence or simultaneous interval,
</p>
</li>
<li> <p><code>.upper_ci</code>: the upper bound of the confidence or simultaneous interval,
</p>
</li>
<li><p> additional columns containing the covariate values at which the derivative
was evaluated.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library("ggplot2")
library("patchwork")
load_mgcv()

df &lt;- data_sim("eg1", dist = "negbin", scale = 0.25, seed = 42)

# fit the GAM (note: for execution time reasons using bam())
m &lt;- bam(y ~ s(x0) + s(x1) + s(x2) + s(x3),
  data = df, family = nb(), method = "fREML"
)

# data slice through data along x2 - all other covariates will be set to
# typical values (value closest to median)
ds &lt;- data_slice(m, x2 = evenly(x2, n = 100))

# fitted values along x2
fv &lt;- fitted_values(m, data = ds)

# response derivatives - ideally n_sim = &gt;10000
y_d &lt;- response_derivatives(m,
  data = ds, type = "central", focal = "x2",
  eps = 0.01, seed = 21, n_sim = 1000
)

# draw fitted values along x2
p1 &lt;- fv |&gt;
  ggplot(aes(x = x2, y = .fitted)) +
  geom_ribbon(aes(ymin = .lower_ci, ymax = .upper_ci, y = NULL),
    alpha = 0.2
  ) +
  geom_line() +
  labs(
    title = "Estimated count as a function of x2",
    y = "Estimated count"
  )

# draw response derivatives
p2 &lt;- y_d |&gt;
  ggplot(aes(x = x2, y = .derivative)) +
  geom_ribbon(aes(ymin = .lower_ci, ymax = .upper_ci), alpha = 0.2) +
  geom_line() +
  labs(
    title = "Estimated 1st derivative of estimated count",
    y = "First derivative"
  )

# draw both panels
p1 + p2 + plot_layout(nrow = 2)

</code></pre>

<hr>
<h2 id='rootogram'>Rootograms to assess goodness of model fit</h2><span id='topic+rootogram'></span><span id='topic+rootogram.gam'></span>

<h3>Description</h3>

<p>A rootogram is a model diagnostic tool that assesses the goodness of fit of
a statistical model. The observed values of the response are compared with
those expected from the fitted model. For discrete, count responses, the
frequency of each count (0, 1, 2, etc) in the observed data and expected
from the conditional distribution of the response implied by the model are
compared. For continuous variables, the observed and expected frequencies
are obtained by grouping the data into bins. The rootogram is drawn using
<code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code> graphics. The design closely follows Kleiber &amp; Zeileis
(2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rootogram(object, ...)

## S3 method for class 'gam'
rootogram(object, max_count = NULL, breaks = "Sturges", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rootogram_+3A_object">object</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="rootogram_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
<tr><td><code id="rootogram_+3A_max_count">max_count</code></td>
<td>
<p>integer; the largest count to consider</p>
</td></tr>
<tr><td><code id="rootogram_+3A_breaks">breaks</code></td>
<td>
<p>for continuous responses, how to group the response. Can be
anything that is acceptable as the <code>breaks</code> argument of
<code><a href="graphics.html#topic+hist">graphics::hist.default()</a></code></p>
</td></tr>
</table>


<h3>References</h3>

<p>Kleiber, C., Zeileis, A., (2016) Visualizing Count Data
Regressions Using Rootograms. <em>Am. Stat.</em> <strong>70</strong>, 296–303.
<a href="https://doi.org/10.1080/00031305.2016.1173590">doi:10.1080/00031305.2016.1173590</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()

df &lt;- data_sim("eg1", n = 1000, dist = "poisson", scale = 0.1, seed = 6)

# A poisson example
m &lt;- gam(y ~ s(x0, bs = "cr") + s(x1, bs = "cr") + s(x2, bs = "cr") +
  s(x3, bs = "cr"), family = poisson(), data = df, method = "REML")
rg &lt;- rootogram(m)
rg
draw(rg) # plot the rootogram

# A Gaussian example
df &lt;- data_sim("eg1", dist = "normal", seed = 2)
m &lt;- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = "REML")
draw(rootogram(m, breaks = "FD"), type = "suspended")

</code></pre>

<hr>
<h2 id='seq_min_max_eps'>Create a sequence of evenly-spaced values adjusted to accommodate a
small adjustment</h2><span id='topic+seq_min_max_eps'></span>

<h3>Description</h3>

<p>Creates a sequence of <code>n</code> evenly-spaced values over the range
<code>min(x)</code> &ndash; <code>max(x)</code>, where the minimum and maximum are adjusted such that
they are always contained within the range of <code>x</code> when <code>x</code> may be shifted
forwards or backwards by an amount related to <code>eps</code>. This is particularly
useful in computing derivatives via finite differences where without this
adjustment we may be predicting for values outside the range of the data
and hence the conmstraints of the penalty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_min_max_eps(x, n, order, type = c("forward", "backward", "central"), eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_min_max_eps_+3A_x">x</code></td>
<td>
<p>numeric; vector over which evenly-spaced values are returned</p>
</td></tr>
<tr><td><code id="seq_min_max_eps_+3A_n">n</code></td>
<td>
<p>numeric; the number of evenly-spaced values to return</p>
</td></tr>
<tr><td><code id="seq_min_max_eps_+3A_order">order</code></td>
<td>
<p>integer; the order of derivative. Either <code>1</code> or <code>2</code> for first or
second order derivatives</p>
</td></tr>
<tr><td><code id="seq_min_max_eps_+3A_type">type</code></td>
<td>
<p>character; the type of finite difference used. One of
<code>"forward"</code>, <code>"backward"</code>, or <code>"central"</code></p>
</td></tr>
<tr><td><code id="seq_min_max_eps_+3A_eps">eps</code></td>
<td>
<p>numeric; the finite difference</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length <code>n</code>.
</p>

<hr>
<h2 id='shift_values'>Shift numeric values in a data frame by an amount <code>eps</code></h2><span id='topic+shift_values'></span>

<h3>Description</h3>

<p>Shift numeric values in a data frame by an amount <code>eps</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shift_values(df, h, i, FUN = `+`, focal = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift_values_+3A_df">df</code></td>
<td>
<p>a data frame or tibble.</p>
</td></tr>
<tr><td><code id="shift_values_+3A_h">h</code></td>
<td>
<p>numeric; the amount to shift values in <code>df</code> by.</p>
</td></tr>
<tr><td><code id="shift_values_+3A_i">i</code></td>
<td>
<p>logical; a vector indexing columns of <code>df</code> that should not be
included in the shift.</p>
</td></tr>
<tr><td><code id="shift_values_+3A_fun">FUN</code></td>
<td>
<p>function; a function to applut the shift. Typically <code>+</code> or <code>-</code>.</p>
</td></tr>
<tr><td><code id="shift_values_+3A_focal">focal</code></td>
<td>
<p>character; the focal variable when computing partial
derivatives. This allows shifting only the focal variable by <code>eps</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='simulate.gam'>Simulate from the posterior distribution of a GAM</h2><span id='topic+simulate.gam'></span><span id='topic+simulate.gamm'></span><span id='topic+simulate.scam'></span>

<h3>Description</h3>

<p>Simulations from the posterior distribution of a fitted GAM model involve
computing predicted values for the observation data for which simulated
data are required, then generating random draws from the probability
distribution used when fitting the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gam'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  data = newdata,
  weights = NULL,
  ...,
  newdata = NULL
)

## S3 method for class 'gamm'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  data = newdata,
  weights = NULL,
  ...,
  newdata = NULL
)

## S3 method for class 'scam'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  data = newdata,
  weights = NULL,
  ...,
  newdata = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.gam_+3A_object">object</code></td>
<td>
<p>a fitted GAM, typically the result of a call to <a href="mgcv.html#topic+gam">mgcv::gam</a>'
or <code><a href="mgcv.html#topic+gamm">mgcv::gamm()</a></code>.</p>
</td></tr>
<tr><td><code id="simulate.gam_+3A_nsim">nsim</code></td>
<td>
<p>numeric; the number of posterior simulations to return.</p>
</td></tr>
<tr><td><code id="simulate.gam_+3A_seed">seed</code></td>
<td>
<p>numeric; a random seed for the simulations.</p>
</td></tr>
<tr><td><code id="simulate.gam_+3A_data">data</code></td>
<td>
<p>data frame; new observations at which the posterior draws
from the model should be evaluated. If not supplied, the data used to fit
the model will be used for <code>newdata</code>, if available in <code>object</code>.</p>
</td></tr>
<tr><td><code id="simulate.gam_+3A_weights">weights</code></td>
<td>
<p>numeric; a vector of prior weights. If <code>newdata</code> is null
then defaults to <code>object[["prior.weights"]]</code>, otherwise a vector of ones.</p>
</td></tr>
<tr><td><code id="simulate.gam_+3A_...">...</code></td>
<td>
<p>arguments passed to methods. <code>simulate.gam()</code> and
<code>simulate.scam()</code> pass <code>...</code> on to <code>predict.gam()</code>. As such you can pass
additional arguments such as <code>terms</code>, <code>exclude</code>, to select which model
terms are included in the predictions. This may be useful, for example,
for excluding the effects of random effect terms.</p>
</td></tr>
<tr><td><code id="simulate.gam_+3A_newdata">newdata</code></td>
<td>
<p>Deprecated. Use <code>data</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>simulate.gam()</code> to function, the <code>family</code> component of the fitted
model must contain, or be updateable to contain, the required random
number generator. See <code><a href="mgcv.html#topic+fix.family.link">mgcv::fix.family.rd()</a></code>.
</p>


<h3>Value</h3>

<p>(Currently) A matrix with <code>nsim</code> columns.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()
dat &lt;- data_sim("eg1", n = 400, dist = "normal", scale = 2, seed = 2)
m1 &lt;- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")

sims &lt;- simulate(m1, nsim = 5, seed = 42)
head(sims)
</code></pre>

<hr>
<h2 id='smallAges'>Lead-210 age-depth measurements for Small Water</h2><span id='topic+smallAges'></span>

<h3>Description</h3>

<p>A dataset containing lead-210 based age depth measurements for the SMALL1
core from Small Water.
</p>


<h3>Format</h3>

<p>A data frame with 12 rows and 7 variables.
</p>


<h3>Details</h3>

<p>The variables are as follows:
</p>

<ul>
<li> <p><code>Depth</code>
</p>
</li>
<li> <p><code>Drymass</code>
</p>
</li>
<li> <p><code>Date</code>
</p>
</li>
<li> <p><code>Age</code>
</p>
</li>
<li> <p><code>Error</code>
</p>
</li>
<li> <p><code>SedAccRate</code>
</p>
</li>
<li> <p><code>SedPerCentChange</code>
</p>
</li></ul>



<h3>Source</h3>

<p>Simpson, G.L. (Unpublished data).
</p>

<hr>
<h2 id='smooth_coef_indices'>Indices of the parametric terms for a particular smooth</h2><span id='topic+smooth_coef_indices'></span>

<h3>Description</h3>

<p>Returns a vector of indices of the parametric terms that represent the
supplied smooth. Useful for extracting model coefficients and columns
of their covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_coef_indices(smooth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_coef_indices_+3A_smooth">smooth</code></td>
<td>
<p>an object that inherits from class <code>mgcv.smooth</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of indices.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth_coefs">smooth_coefs()</a></code> for extracting the coefficients for a particular
smooth.
</p>

<hr>
<h2 id='smooth_coefs'>Coefficients for a particular smooth</h2><span id='topic+smooth_coefs'></span><span id='topic+smooth_coefs.gam'></span><span id='topic+smooth_coefs.bam'></span><span id='topic+smooth_coefs.gamm'></span><span id='topic+smooth_coefs.gamm4'></span><span id='topic+smooth_coefs.list'></span><span id='topic+smooth_coefs.mgcv.smooth'></span><span id='topic+smooth_coefs.scam'></span>

<h3>Description</h3>

<p>Returns a vector of model coefficients of the parametric terms that represent
the supplied smooth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_coefs(object, ...)

## S3 method for class 'gam'
smooth_coefs(object, select, term = deprecated(), ...)

## S3 method for class 'bam'
smooth_coefs(object, select, term = deprecated(), ...)

## S3 method for class 'gamm'
smooth_coefs(object, select, term = deprecated(), ...)

## S3 method for class 'gamm4'
smooth_coefs(object, select, term = deprecated(), ...)

## S3 method for class 'list'
smooth_coefs(object, select, term = deprecated(), ...)

## S3 method for class 'mgcv.smooth'
smooth_coefs(object, model, ...)

## S3 method for class 'scam'
smooth_coefs(object, select, term = deprecated(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_coefs_+3A_object">object</code></td>
<td>
<p>a fitted GAM(M) object, or, for the <code>"mgcv.smooth"</code> method,
an object that inherits from class <code>mgcv.smooth</code>.</p>
</td></tr>
<tr><td><code id="smooth_coefs_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="smooth_coefs_+3A_select">select</code></td>
<td>
<p>character; the label of the smooth whose coefficients will be
returned.</p>
</td></tr>
<tr><td><code id="smooth_coefs_+3A_term">term</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>select</code> instead.</p>
</td></tr>
<tr><td><code id="smooth_coefs_+3A_model">model</code></td>
<td>
<p>a fitted GAM(M) object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of model coefficients.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth_coef_indices">smooth_coef_indices()</a></code> for extracting the indices of the
coefficients for a particular smooth.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
load_mgcv()
df &lt;- data_sim("eg1", seed = 2)
m &lt;- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = "REML")

## IGNORE_RDIFF_BEGIN
smooth_coefs(m, select = "s(x2)")
## IGNORE_RDIFF_END

</code></pre>

<hr>
<h2 id='smooth_data'>Generate regular data over the covariates of a smooth</h2><span id='topic+smooth_data'></span>

<h3>Description</h3>

<p>Generate regular data over the covariates of a smooth
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_data(
  model,
  id,
  n = 100,
  n_2d = NULL,
  n_3d = NULL,
  n_4d = NULL,
  offset = NULL,
  include_all = FALSE,
  var_order = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_data_+3A_model">model</code></td>
<td>
<p>a fitted model</p>
</td></tr>
<tr><td><code id="smooth_data_+3A_id">id</code></td>
<td>
<p>the number ID of the smooth within <code>model</code> to process.</p>
</td></tr>
<tr><td><code id="smooth_data_+3A_n">n</code></td>
<td>
<p>numeric; the number of new observations to generate.</p>
</td></tr>
<tr><td><code id="smooth_data_+3A_n_2d">n_2d</code></td>
<td>
<p>numeric; the number of new observations to generate for the
second dimension of a 2D smooth. <em>Currently ignored</em>.</p>
</td></tr>
<tr><td><code id="smooth_data_+3A_n_3d">n_3d</code></td>
<td>
<p>numeric; the number of new observations to generate for the third
dimension of a 3D smooth.</p>
</td></tr>
<tr><td><code id="smooth_data_+3A_n_4d">n_4d</code></td>
<td>
<p>numeric; the number of new observations to generate for the
dimensions higher than 2 (!) of a <em>k</em>D smooth (<em>k</em> &gt;= 4). For example, if
the smooth is a 4D smooth, each of dimensions 3 and 4 will get <code>n_4d</code>
new observations.</p>
</td></tr>
<tr><td><code id="smooth_data_+3A_offset">offset</code></td>
<td>
<p>numeric; value of the model offset to use.</p>
</td></tr>
<tr><td><code id="smooth_data_+3A_include_all">include_all</code></td>
<td>
<p>logical; include all covariates involved in the smooth?
if <code>FALSE</code>, only the covariates involved in the smooth will be included in
the returned data frame. If <code>TRUE</code>, a representative value will be included
for all other covariates in the model that aren't actually used in the
smooth. This can be useful if you want to pass the returned data frame on
to <code><a href="mgcv.html#topic+smoothCon">mgcv::PredictMat()</a></code>.</p>
</td></tr>
<tr><td><code id="smooth_data_+3A_var_order">var_order</code></td>
<td>
<p>character; the order in which the terms in the smooth
should be processed. Only useful for tensor products with at least one
2d marginal smooth.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
load_mgcv()
df &lt;- data_sim("eg1", seed = 42)
m &lt;- bam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df)

# generate data over range of x1 for smooth s(x1)
smooth_data(m, id = 2)

# generate data over range of x1 for smooth s(x1), with typical value for
# other covariates in the model
smooth_data(m, id = 2, include_all = TRUE)


</code></pre>

<hr>
<h2 id='smooth_dim'>Dimension of a smooth</h2><span id='topic+smooth_dim'></span><span id='topic+smooth_dim.gam'></span><span id='topic+smooth_dim.gamm'></span><span id='topic+smooth_dim.mgcv.smooth'></span>

<h3>Description</h3>

<p>Extracts the dimension of an estimated smooth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_dim(object)

## S3 method for class 'gam'
smooth_dim(object)

## S3 method for class 'gamm'
smooth_dim(object)

## S3 method for class 'mgcv.smooth'
smooth_dim(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_dim_+3A_object">object</code></td>
<td>
<p>an R object. See Details for list of supported objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generic function with methods for objects of class
<code>"gam"</code>, <code>"gamm"</code>, and <code>"mgcv.smooth"</code>.
</p>


<h3>Value</h3>

<p>A numeric vector of dimensions for each smooth.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>

<hr>
<h2 id='smooth_estimates'>Evaluate smooths at covariate values</h2><span id='topic+smooth_estimates'></span><span id='topic+smooth_estimates.gam'></span>

<h3>Description</h3>

<p>Evaluate a smooth at a grid of evenly spaced value over the range of the
covariate associated with the smooth. Alternatively, a set of points at which
the smooth should be evaluated can be supplied. <code>smooth_estimates()</code> is a new
implementation of <code>evaluate_smooth()</code>, and replaces that function, which has
been removed from the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_estimates(object, ...)

## S3 method for class 'gam'
smooth_estimates(
  object,
  select = NULL,
  smooth = deprecated(),
  n = 100,
  n_3d = 16,
  n_4d = 4,
  data = NULL,
  unconditional = FALSE,
  overall_uncertainty = TRUE,
  dist = NULL,
  unnest = TRUE,
  partial_match = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_estimates_+3A_object">object</code></td>
<td>
<p>an object of class <code>"gam"</code> or <code>"gamm"</code>.</p>
</td></tr>
<tr><td><code id="smooth_estimates_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="smooth_estimates_+3A_select">select</code></td>
<td>
<p>character; select which smooth's posterior to draw from.
The default (<code>NULL</code>) means the posteriors of all smooths in <code>model</code>
wil be sampled from. If supplied, a character vector of requested terms.</p>
</td></tr>
<tr><td><code id="smooth_estimates_+3A_smooth">smooth</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>select</code> instead.</p>
</td></tr>
<tr><td><code id="smooth_estimates_+3A_n">n</code></td>
<td>
<p>numeric; the number of points over the range of the covariate at
which to evaluate the smooth.</p>
</td></tr>
<tr><td><code id="smooth_estimates_+3A_n_3d">n_3d</code>, <code id="smooth_estimates_+3A_n_4d">n_4d</code></td>
<td>
<p>numeric; the number of points over the range of last
covariate in a 3D or 4D smooth. The default is <code>NULL</code> which achieves the
standard behaviour of using <code>n</code> points over the range of all covariate,
resulting in <code>n^d</code> evaluation points, where <code>d</code> is the dimension of the
smooth. For <code>d &gt; 2</code> this can result in very many evaluation points and slow
performance. For smooths of <code>d &gt; 4</code>, the value of <code>n_4d</code> will be used for
all dimensions <code style="white-space: pre;">&#8288;&gt; 4&#8288;</code>, unless this is <code>NULL</code>, in which case the default
behaviour (using <code>n</code> for all dimensions) will be observed.</p>
</td></tr>
<tr><td><code id="smooth_estimates_+3A_data">data</code></td>
<td>
<p>a data frame of covariate values at which to evaluate the
smooth.</p>
</td></tr>
<tr><td><code id="smooth_estimates_+3A_unconditional">unconditional</code></td>
<td>
<p>logical; should confidence intervals include the
uncertainty due to smoothness selection? If <code>TRUE</code>, the corrected Bayesian
covariance matrix will be used.</p>
</td></tr>
<tr><td><code id="smooth_estimates_+3A_overall_uncertainty">overall_uncertainty</code></td>
<td>
<p>logical; should the uncertainty in the model
constant term be included in the standard error of the evaluate values of
the smooth?</p>
</td></tr>
<tr><td><code id="smooth_estimates_+3A_dist">dist</code></td>
<td>
<p>numeric; if greater than 0, this is used to determine when
a location is too far from data to be plotted when plotting 2-D smooths.
The data are scaled into the unit square before deciding what to exclude,
and <code>dist</code> is a distance within the unit square. See
<code><a href="mgcv.html#topic+exclude.too.far">mgcv::exclude.too.far()</a></code> for further details.</p>
</td></tr>
<tr><td><code id="smooth_estimates_+3A_unnest">unnest</code></td>
<td>
<p>logical; unnest the smooth objects?</p>
</td></tr>
<tr><td><code id="smooth_estimates_+3A_partial_match">partial_match</code></td>
<td>
<p>logical; in the case of character <code>select</code>, should
<code>select</code> match partially against <code>smooths</code>? If <code>partial_match = TRUE</code>,
<code>select</code> must only be a single string, a character vector of length 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame (tibble), which is of class <code>"smooth_estimates"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()

dat &lt;- data_sim("eg1", n = 400, dist = "normal", scale = 2, seed = 2)
m1 &lt;- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")

## evaluate all smooths
smooth_estimates(m1)

## or selected smooths
smooth_estimates(m1, select = c("s(x0)", "s(x1)"))

</code></pre>

<hr>
<h2 id='smooth_label'>Extract the label for a smooth used by 'mgcv'</h2><span id='topic+smooth_label'></span><span id='topic+smooth_label.gam'></span><span id='topic+smooth_label.mgcv.smooth'></span>

<h3>Description</h3>

<p>The label 'mgcv' uses for smooths is useful in many contexts, including
selecting smooths or labelling plots. <code>smooth_label()</code> extracts this label
from an 'mgcv' smooth object, i.e. an object that inherits from class
<code>"mgcv.smooth"</code>. These would typically be found in the <code style="white-space: pre;">&#8288;$smooth&#8288;</code> component of
a GAM fitted by <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code> or <code><a href="mgcv.html#topic+bam">mgcv::bam()</a></code>, or related functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_label(object, ...)

## S3 method for class 'gam'
smooth_label(object, id, ...)

## S3 method for class 'mgcv.smooth'
smooth_label(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_label_+3A_object">object</code></td>
<td>
<p>an R object. Currently, methods for class <code>"gam"</code> and for mgcv
smooth objects inheriting from class <code>"mgcv.smooth"</code> are supported.</p>
</td></tr>
<tr><td><code id="smooth_label_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="smooth_label_+3A_id">id</code></td>
<td>
<p>numeric; the indices of the smooths whose labels are to be
extracted. If missing, labels for all smooths in the model are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()
df &lt;- data_sim("gwf2", n = 100)
m &lt;- gam(y ~ s(x), data = df, method = "REML")

# extract the smooth
sm &lt;- get_smooths_by_id(m, id = 1)[[1]]

# extract the label
smooth_label(sm)

# or directly on the fitted GAM
smooth_label(m$smooth[[1]])

# or extract labels by idex/position
smooth_label(m, id = 1)
</code></pre>

<hr>
<h2 id='smooth_samples'>Posterior draws for individual smooths</h2><span id='topic+smooth_samples'></span><span id='topic+smooth_samples.gam'></span>

<h3>Description</h3>

<p>Returns draws from the posterior distributions of smooth functions in a GAM.
Useful, for example, for visualising the uncertainty in individual estimated
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_samples(model, ...)

## S3 method for class 'gam'
smooth_samples(
  model,
  select = NULL,
  term = deprecated(),
  n = 1,
  data = newdata,
  method = c("gaussian", "mh", "inla", "user"),
  seed = NULL,
  freq = FALSE,
  unconditional = FALSE,
  n_cores = 1L,
  n_vals = 200,
  burnin = 1000,
  thin = 1,
  t_df = 40,
  rw_scale = 0.25,
  rng_per_smooth = FALSE,
  draws = NULL,
  partial_match = NULL,
  ...,
  newdata = NULL,
  ncores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_samples_+3A_model">model</code></td>
<td>
<p>a fitted model of the supported types</p>
</td></tr>
<tr><td><code id="smooth_samples_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods. For <code>fitted_samples()</code>, these
are passed on to <code><a href="mgcv.html#topic+predict.gam">predict.gam()</a></code>. For <code>posterior_samples()</code> these are
passed on to <code>fitted_samples()</code>. For <code>predicted_samples()</code> these are
passed on to the relevant <code>simulate()</code> method.</p>
</td></tr>
<tr><td><code id="smooth_samples_+3A_select">select</code></td>
<td>
<p>character; select which smooth's posterior to draw from.
The default (<code>NULL</code>) means the posteriors of all smooths in <code>model</code>
wil be sampled from. If supplied, a character vector of requested terms.</p>
</td></tr>
<tr><td><code id="smooth_samples_+3A_term">term</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>select</code> instead.</p>
</td></tr>
<tr><td><code id="smooth_samples_+3A_n">n</code></td>
<td>
<p>numeric; the number of posterior samples to return.</p>
</td></tr>
<tr><td><code id="smooth_samples_+3A_data">data</code></td>
<td>
<p>data frame; new observations at which the posterior draws
from the model should be evaluated. If not supplied, the data used to fit
the model will be used for <code>data</code>, if available in <code>model</code>.</p>
</td></tr>
<tr><td><code id="smooth_samples_+3A_method">method</code></td>
<td>
<p>character; which method should be used to draw samples from
the posterior distribution. <code>"gaussian"</code> uses a Gaussian (Laplace)
approximation to the posterior. <code>"mh"</code> uses a Metropolis Hastings sampler
that alternates t proposals with proposals based on a shrunken version of
the posterior covariance matrix. <code>"inla"</code> uses a variant of Integrated
Nested Laplace Approximation due to Wood (2019), (currently not
implemented). <code>"user"</code> allows for user-supplied posterior draws
(currently not implemented).</p>
</td></tr>
<tr><td><code id="smooth_samples_+3A_seed">seed</code></td>
<td>
<p>numeric; a random seed for the simulations.</p>
</td></tr>
<tr><td><code id="smooth_samples_+3A_freq">freq</code></td>
<td>
<p>logical; <code>TRUE</code> to use the frequentist covariance matrix of
the parameter estimators, <code>FALSE</code> to use the Bayesian posterior
covariance matrix of the parameters.</p>
</td></tr>
<tr><td><code id="smooth_samples_+3A_unconditional">unconditional</code></td>
<td>
<p>logical; if <code>TRUE</code> (and <code>freq == FALSE</code>) then the
Bayesian smoothing parameter uncertainty corrected covariance matrix is
used, if available.</p>
</td></tr>
<tr><td><code id="smooth_samples_+3A_n_cores">n_cores</code></td>
<td>
<p>number of cores for generating random variables from a
multivariate normal distribution. Passed to <code><a href="mvnfast.html#topic+rmvn">mvnfast::rmvn()</a></code>.
Parallelization will take place only if OpenMP is supported (but appears
to work on Windows with current <code>R</code>).</p>
</td></tr>
<tr><td><code id="smooth_samples_+3A_n_vals">n_vals</code></td>
<td>
<p>numeric; how many locations to evaluate the smooth at if
<code>data</code> not supplied</p>
</td></tr>
<tr><td><code id="smooth_samples_+3A_burnin">burnin</code></td>
<td>
<p>numeric; number of samples to discard as the burnin draws.
Only used with <code>method = "mh"</code>.</p>
</td></tr>
<tr><td><code id="smooth_samples_+3A_thin">thin</code></td>
<td>
<p>numeric; the number of samples to skip when taking <code>n</code> draws.
Results in <code>thin * n</code> draws from the posterior being taken. Only used with
<code>method = "mh"</code>.</p>
</td></tr>
<tr><td><code id="smooth_samples_+3A_t_df">t_df</code></td>
<td>
<p>numeric; degrees of freedome for t distribution proposals. Only
used with <code>method = "mh"</code>.</p>
</td></tr>
<tr><td><code id="smooth_samples_+3A_rw_scale">rw_scale</code></td>
<td>
<p>numeric; Factor by which to scale posterior covariance
matrix when generating random walk proposals. Negative or non finite to
skip the random walk step. Only used with <code>method = "mh"</code>.</p>
</td></tr>
<tr><td><code id="smooth_samples_+3A_rng_per_smooth">rng_per_smooth</code></td>
<td>
<p>logical; if TRUE, the behaviour of gratia version
0.8.1 or earlier is used, whereby a separate call the the random number
generator (RNG) is performed for each smooth. If FALSE, a single call to the
RNG is performed for all model parameters</p>
</td></tr>
<tr><td><code id="smooth_samples_+3A_draws">draws</code></td>
<td>
<p>matrix; user supplied posterior draws to be used when
<code>method = "user"</code>.</p>
</td></tr>
<tr><td><code id="smooth_samples_+3A_partial_match">partial_match</code></td>
<td>
<p>logical; should smooths be selected by partial matches
with <code>select</code>? If <code>TRUE</code>, <code>select</code> can only be a single string to match
against.</p>
</td></tr>
<tr><td><code id="smooth_samples_+3A_newdata">newdata</code></td>
<td>
<p>Deprecated: use <code>data</code> instead.</p>
</td></tr>
<tr><td><code id="smooth_samples_+3A_ncores">ncores</code></td>
<td>
<p>Deprecated; use <code>n_cores</code> instead. The number of cores for
generating random variables from a multivariate normal distribution.
Passed to <code><a href="mvnfast.html#topic+rmvn">mvnfast::rmvn()</a></code>. Parallelization will take place only if
OpenMP is supported (but appears to work on Windows with current <code>R</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with additional classes <code>"smooth_samples"</code> and
'&quot;posterior_samples&quot;.
</p>
<p>For the <code>"gam"</code> method, the columns currently returned (not in this order)
are:
</p>

<ul>
<li> <p><code>.smooth</code>; character vector. Indicates the smooth function for that
particular draw,
</p>
</li>
<li> <p><code>.term</code>; character vector. Similar to <code>smooth</code>, but will contain the
full label for the smooth, to differentiate factor-by smooths for
example.
</p>
</li>
<li> <p><code>.by</code>; character vector. If the smooth involves a <code>by</code> term, the
by variable will be named here, <code>NA_character_</code> otherwise.
</p>
</li>
<li> <p><code>.row</code>; integer. A vector of values <code>seq_len(n_vals)</code>, repeated if
<code>n &gt; 1L</code>. Indexes the row in <code>data</code> for that particular draw.
</p>
</li>
<li> <p><code>.draw</code>; integer. A vector of integer values indexing the particular
posterior draw that each row belongs to.
</p>
</li>
<li> <p><code>.value</code>; numeric. The value of smooth function for this posterior draw
and covariate combination.
</p>
</li>
<li> <p><code>xxx</code>; numeric. A series of one or more columns containing data required
for the smooth, named as per the variables involved in the respective
smooth.
</p>
</li>
<li><p> Additional columns will be present in the case of factor by smooths,
which will contain the level for the factor named in <code>by_variable</code> for
that particular posterior draw.
</p>
</li></ul>



<h3>Warning</h3>

<p>The set of variables returned and their order in the tibble is subject to
change in future versions. Don't rely on position.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()

dat &lt;- data_sim("eg1", n = 400, seed = 2)
m1 &lt;- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")

sms &lt;- smooth_samples(m1, select = "s(x0)", n = 5, seed = 42)

sms


## A factor by example (with a spurious covariate x0)
dat &lt;- data_sim("eg4", n = 1000, seed = 2)

## fit model...
m2 &lt;- gam(y ~ fac + s(x2, by = fac) + s(x0), data = dat)
sms &lt;- smooth_samples(m2, n = 5, seed = 42)
draw(sms)

</code></pre>

<hr>
<h2 id='smooth_terms'>List the variables involved in smooths</h2><span id='topic+smooth_terms'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_terms(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_terms_+3A_object">object</code></td>
<td>
<p>an R object the result of a call to <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code>,
<code><a href="mgcv.html#topic+bam">mgcv::bam()</a></code>, or <code><a href="mgcv.html#topic+gamm">mgcv::gamm()</a></code>, or that inherits from classes <code>"gam"</code> or
<code>"mgcv.smooth"</code>, or <code>"fs.interaction"</code>.</p>
</td></tr>
<tr><td><code id="smooth_terms_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods. Currently unused.</p>
</td></tr>
</table>

<hr>
<h2 id='smooth_type'>Determine the type of smooth and return it n a human readable form</h2><span id='topic+smooth_type'></span><span id='topic+smooth_type.default'></span><span id='topic+smooth_type.tprs.smooth'></span><span id='topic+smooth_type.ts.smooth'></span><span id='topic+smooth_type.cr.smooth'></span><span id='topic+smooth_type.cs.smooth'></span><span id='topic+smooth_type.cyclic.smooth'></span><span id='topic+smooth_type.pspline.smooth'></span><span id='topic+smooth_type.cp.smooth'></span><span id='topic+smooth_type.Bspline.smooth'></span><span id='topic+smooth_type.duchon.spline'></span><span id='topic+smooth_type.fs.interaction'></span><span id='topic+smooth_type.sz.interaction'></span><span id='topic+smooth_type.gp.smooth'></span><span id='topic+smooth_type.mrf.smooth'></span><span id='topic+smooth_type.random.effect'></span><span id='topic+smooth_type.sw'></span><span id='topic+smooth_type.sf'></span><span id='topic+smooth_type.soap.film'></span><span id='topic+smooth_type.t2.smooth'></span><span id='topic+smooth_type.sos.smooth'></span><span id='topic+smooth_type.tensor.smooth'></span><span id='topic+smooth_type.mpi.smooth'></span><span id='topic+smooth_type.mpd.smooth'></span><span id='topic+smooth_type.cx.smooth'></span><span id='topic+smooth_type.cv.smooth'></span><span id='topic+smooth_type.micx.smooth'></span><span id='topic+smooth_type.micv.smooth'></span><span id='topic+smooth_type.mdcx.smooth'></span><span id='topic+smooth_type.mdcv.smooth'></span><span id='topic+smooth_type.miso.smooth'></span><span id='topic+smooth_type.mifo.smooth'></span>

<h3>Description</h3>

<p>Determine the type of smooth and return it n a human readable form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_type(smooth)

## Default S3 method:
smooth_type(smooth)

## S3 method for class 'tprs.smooth'
smooth_type(smooth)

## S3 method for class 'ts.smooth'
smooth_type(smooth)

## S3 method for class 'cr.smooth'
smooth_type(smooth)

## S3 method for class 'cs.smooth'
smooth_type(smooth)

## S3 method for class 'cyclic.smooth'
smooth_type(smooth)

## S3 method for class 'pspline.smooth'
smooth_type(smooth)

## S3 method for class 'cp.smooth'
smooth_type(smooth)

## S3 method for class 'Bspline.smooth'
smooth_type(smooth)

## S3 method for class 'duchon.spline'
smooth_type(smooth)

## S3 method for class 'fs.interaction'
smooth_type(smooth)

## S3 method for class 'sz.interaction'
smooth_type(smooth)

## S3 method for class 'gp.smooth'
smooth_type(smooth)

## S3 method for class 'mrf.smooth'
smooth_type(smooth)

## S3 method for class 'random.effect'
smooth_type(smooth)

## S3 method for class 'sw'
smooth_type(smooth)

## S3 method for class 'sf'
smooth_type(smooth)

## S3 method for class 'soap.film'
smooth_type(smooth)

## S3 method for class 't2.smooth'
smooth_type(smooth)

## S3 method for class 'sos.smooth'
smooth_type(smooth)

## S3 method for class 'tensor.smooth'
smooth_type(smooth)

## S3 method for class 'mpi.smooth'
smooth_type(smooth)

## S3 method for class 'mpd.smooth'
smooth_type(smooth)

## S3 method for class 'cx.smooth'
smooth_type(smooth)

## S3 method for class 'cv.smooth'
smooth_type(smooth)

## S3 method for class 'micx.smooth'
smooth_type(smooth)

## S3 method for class 'micv.smooth'
smooth_type(smooth)

## S3 method for class 'mdcx.smooth'
smooth_type(smooth)

## S3 method for class 'mdcv.smooth'
smooth_type(smooth)

## S3 method for class 'miso.smooth'
smooth_type(smooth)

## S3 method for class 'mifo.smooth'
smooth_type(smooth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_type_+3A_smooth">smooth</code></td>
<td>
<p>an object inheriting from class <code>mgcv.smooth</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='smooths'>Names of smooths in a GAM</h2><span id='topic+smooths'></span><span id='topic+smooths.default'></span><span id='topic+smooths.gamm'></span>

<h3>Description</h3>

<p>Names of smooths in a GAM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooths(object)

## Default S3 method:
smooths(object)

## S3 method for class 'gamm'
smooths(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooths_+3A_object">object</code></td>
<td>
<p>a fitted GAM or related model. Typically the result of a call
to <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code>, <code><a href="mgcv.html#topic+bam">mgcv::bam()</a></code>, or <code><a href="mgcv.html#topic+gamm">mgcv::gamm()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='spline_values'>Evaluate a spline at provided covariate values</h2><span id='topic+spline_values'></span>

<h3>Description</h3>

<p>Evaluate a spline at provided covariate values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spline_values(
  smooth,
  data,
  model,
  unconditional,
  overall_uncertainty = TRUE,
  frequentist = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spline_values_+3A_smooth">smooth</code></td>
<td>
<p>currently an object that inherits from class <code>mgcv.smooth</code>.</p>
</td></tr>
<tr><td><code id="spline_values_+3A_data">data</code></td>
<td>
<p>a data frame of values to evaluate <code>smooth</code> at.</p>
</td></tr>
<tr><td><code id="spline_values_+3A_model">model</code></td>
<td>
<p>a fitted model; currently only <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code> and <code><a href="mgcv.html#topic+bam">mgcv::bam()</a></code>
models are suported.</p>
</td></tr>
<tr><td><code id="spline_values_+3A_unconditional">unconditional</code></td>
<td>
<p>logical; should confidence intervals include the
uncertainty due to smoothness selection? If <code>TRUE</code>, the corrected Bayesian
covariance matrix will be used.</p>
</td></tr>
<tr><td><code id="spline_values_+3A_overall_uncertainty">overall_uncertainty</code></td>
<td>
<p>logical; should the uncertainty in the model
constant term be included in the standard error of the evaluate values of
the smooth?</p>
</td></tr>
<tr><td><code id="spline_values_+3A_frequentist">frequentist</code></td>
<td>
<p>logical; use the frequentist covariance matrix?</p>
</td></tr>
</table>

<hr>
<h2 id='spline_values2'>Evaluate a spline at provided covariate values</h2><span id='topic+spline_values2'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>The function <code>spline_values2()</code> has been renamed to <code>spline_values()</code> as of
version 0.9.0. This was allowed following the removal of <code>evaluate_smooth()</code>,
which was the only function using <code>spline_values()</code>. So <code>spline_values2()</code>
has been renamed to <code>spline_values()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spline_values2(
  smooth,
  data,
  model,
  unconditional,
  overall_uncertainty = TRUE,
  frequentist = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spline_values2_+3A_smooth">smooth</code></td>
<td>
<p>currently an object that inherits from class <code>mgcv.smooth</code>.</p>
</td></tr>
<tr><td><code id="spline_values2_+3A_data">data</code></td>
<td>
<p>an optional data frame of values to evaluate <code>smooth</code> at.</p>
</td></tr>
<tr><td><code id="spline_values2_+3A_model">model</code></td>
<td>
<p>a fitted model; currently only <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code> and <code><a href="mgcv.html#topic+bam">mgcv::bam()</a></code>
models are suported.</p>
</td></tr>
<tr><td><code id="spline_values2_+3A_unconditional">unconditional</code></td>
<td>
<p>logical; should confidence intervals include the
uncertainty due to smoothness selection? If <code>TRUE</code>, the corrected Bayesian
covariance matrix will be used.</p>
</td></tr>
<tr><td><code id="spline_values2_+3A_overall_uncertainty">overall_uncertainty</code></td>
<td>
<p>logical; should the uncertainty in the model
constant term be included in the standard error of the evaluate values of
the smooth?</p>
</td></tr>
<tr><td><code id="spline_values2_+3A_frequentist">frequentist</code></td>
<td>
<p>logical; use the frequentist covariance matrix?</p>
</td></tr>
</table>

<hr>
<h2 id='term_names'>Extract names of all variables needed to fit a GAM or a smooth</h2><span id='topic+term_names'></span><span id='topic+term_names.gam'></span><span id='topic+term_names.mgcv.smooth'></span><span id='topic+term_names.gamm'></span>

<h3>Description</h3>

<p>Extract names of all variables needed to fit a GAM or a smooth
</p>


<h3>Usage</h3>

<pre><code class='language-R'>term_names(object, ...)

## S3 method for class 'gam'
term_names(object, ...)

## S3 method for class 'mgcv.smooth'
term_names(object, ...)

## S3 method for class 'gamm'
term_names(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="term_names_+3A_object">object</code></td>
<td>
<p>a fitted GAM object (inheriting from class <code>"gam"</code> or an
<a href="mgcv.html#topic+smooth.construct">mgcv::smooth.construct</a> smooth object, inheriting from class
<code>"mgcv.smooth"</code>.</p>
</td></tr>
<tr><td><code id="term_names_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods. Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of variable names required for terms in the model
</p>

<hr>
<h2 id='term_variables'>Names of variables involved in a specified model term</h2><span id='topic+term_variables'></span><span id='topic+term_variables.terms'></span><span id='topic+term_variables.gam'></span><span id='topic+term_variables.bam'></span>

<h3>Description</h3>

<p>Given the name (a term label) of a term in a model, returns the names
of the variables involved in the term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>term_variables(object, term, ...)

## S3 method for class 'terms'
term_variables(object, term, ...)

## S3 method for class 'gam'
term_variables(object, term, ...)

## S3 method for class 'bam'
term_variables(object, term, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="term_variables_+3A_object">object</code></td>
<td>
<p>an R object on which method dispatch is performed</p>
</td></tr>
<tr><td><code id="term_variables_+3A_term">term</code></td>
<td>
<p>character; the name of a model term, in the sense of
<code>attr(terms(object), "term.labels")</code>. Currently not checked to see if the
term exists in the model.</p>
</td></tr>
<tr><td><code id="term_variables_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of variable names.
</p>

<hr>
<h2 id='theta'>General extractor for additional parameters in mgcv models</h2><span id='topic+theta'></span><span id='topic+theta.gam'></span>

<h3>Description</h3>

<p>General extractor for additional parameters in mgcv models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta(object, ...)

## S3 method for class 'gam'
theta(object, transform = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theta_+3A_object">object</code></td>
<td>
<p>a fitted model</p>
</td></tr>
<tr><td><code id="theta_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="theta_+3A_transform">transform</code></td>
<td>
<p>logical; transform to the natural scale of the parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric vector of additional parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()
df &lt;- data_sim("eg1", dist = "poisson", seed = 42, scale = 1 / 5)
m &lt;- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3),
  data = df, method = "REML",
  family = nb()
)
p &lt;- theta(m)
</code></pre>

<hr>
<h2 id='tidy_basis'>A tidy basis representation of a smooth object</h2><span id='topic+tidy_basis'></span>

<h3>Description</h3>

<p>Takes an object of class <code>mgcv.smooth</code> and returns a tidy representation
of the basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_basis(smooth, data = NULL, at = NULL, coefs = NULL, p_ident = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_basis_+3A_smooth">smooth</code></td>
<td>
<p>a smooth object of or inheriting from class <code>"mgcv.smooth"</code>.
Typically, such objects are returned as part of a fitted GAM or GAMM in
the <code style="white-space: pre;">&#8288;$smooth&#8288;</code> component of the model object or the <code style="white-space: pre;">&#8288;$gam$smooth&#8288;</code> component
if the model was fitted by <code><a href="mgcv.html#topic+gamm">mgcv::gamm()</a></code> or <code><a href="gamm4.html#topic+gamm4">gamm4::gamm4()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy_basis_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables used in <code>smooth</code>.</p>
</td></tr>
<tr><td><code id="tidy_basis_+3A_at">at</code></td>
<td>
<p>a data frame containing values of the smooth covariate(s) at which
the basis should be evaluated.</p>
</td></tr>
<tr><td><code id="tidy_basis_+3A_coefs">coefs</code></td>
<td>
<p>numeric; an optional vector of coefficients for the smooth</p>
</td></tr>
<tr><td><code id="tidy_basis_+3A_p_ident">p_ident</code></td>
<td>
<p>logical vector; only used for handling <code><a href="scam.html#topic+scam">scam::scam()</a></code> smooths.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()

df &lt;- data_sim("eg1", n = 400, seed = 42)

# fit model
m &lt;- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = "REML")

# tidy representaition of a basis for a smooth definition
# extract the smooth
sm &lt;- get_smooth(m, "s(x2)")
# get the tidy basis - need to pass where we want it to be evaluated
bf &lt;- tidy_basis(sm, at = df)

# can weight the basis by the model coefficients for this smooth
bf &lt;- tidy_basis(sm, at = df, coefs = smooth_coefs(sm, model = m))

</code></pre>

<hr>
<h2 id='to_na'>Sets the elements of vector to <code>NA</code></h2><span id='topic+to_na'></span>

<h3>Description</h3>

<p>Given a vector <code>i</code> indexing the elements of <code>x</code>, sets the selected elements
of <code>x</code> to <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_na(x, i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_na_+3A_x">x</code></td>
<td>
<p>vector of values</p>
</td></tr>
<tr><td><code id="to_na_+3A_i">i</code></td>
<td>
<p>vector of values used to subset <code>x</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>x</code> with possibly some elements set to <code>NA</code>
</p>

<hr>
<h2 id='too_far'>Exclude values that lie too far from the support of data</h2><span id='topic+too_far'></span>

<h3>Description</h3>

<p>Identifies pairs of covariate values that lie too far from the original data.
The function is currently a basic wrapper around <code><a href="mgcv.html#topic+exclude.too.far">mgcv::exclude.too.far()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>too_far(x, y, ref_1, ref_2, dist = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="too_far_+3A_x">x</code>, <code id="too_far_+3A_y">y</code></td>
<td>
<p>numeric; vector of values of the covariates to compare with
the observed data</p>
</td></tr>
<tr><td><code id="too_far_+3A_ref_1">ref_1</code>, <code id="too_far_+3A_ref_2">ref_2</code></td>
<td>
<p>numeric; vectors of covariate values that represent the
reference against which <code style="white-space: pre;">&#8288;x1 and &#8288;</code>x2' are compared</p>
</td></tr>
<tr><td><code id="too_far_+3A_dist">dist</code></td>
<td>
<p>if supplied, a numeric vector of length 1 representing the
distance from the data beyond which an observation is excluded. For
example, you want to exclude values that lie further from an observation
than 10% of the range of the observed data, use <code>0.1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a logical vector of the same length as <code>x1</code>.
</p>

<hr>
<h2 id='too_far_to_na'>Set rows of data to <code>NA</code> if the lie too far from a reference set of values</h2><span id='topic+too_far_to_na'></span>

<h3>Description</h3>

<p>Set rows of data to <code>NA</code> if the lie too far from a reference set of values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>too_far_to_na(smooth, input, reference, cols, dist = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="too_far_to_na_+3A_smooth">smooth</code></td>
<td>
<p>an mgcv smooth object</p>
</td></tr>
<tr><td><code id="too_far_to_na_+3A_input">input</code></td>
<td>
<p>data frame containing the input observations and the columns to
be set to <code>NA</code></p>
</td></tr>
<tr><td><code id="too_far_to_na_+3A_reference">reference</code></td>
<td>
<p>data frame containing the reference values</p>
</td></tr>
<tr><td><code id="too_far_to_na_+3A_cols">cols</code></td>
<td>
<p>character vector of columns whose elements will be set to <code>NA</code> if
the data lies too far from the reference set</p>
</td></tr>
<tr><td><code id="too_far_to_na_+3A_dist">dist</code></td>
<td>
<p>numeric, the distance from the reference set beyond which
elements of <code>input</code> will be set to <code>NA</code></p>
</td></tr>
</table>

<hr>
<h2 id='transform_fun'>Transform estimated values and confidence intervals by applying a function</h2><span id='topic+transform_fun'></span><span id='topic+transform_fun.smooth_estimates'></span><span id='topic+transform_fun.smooth_samples'></span><span id='topic+transform_fun.mgcv_smooth'></span><span id='topic+transform_fun.evaluated_parametric_term'></span><span id='topic+transform_fun.parametric_effects'></span><span id='topic+transform_fun.tbl_df'></span>

<h3>Description</h3>

<p>Transform estimated values and confidence intervals by applying a function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_fun(object, fun = NULL, ...)

## S3 method for class 'smooth_estimates'
transform_fun(object, fun = NULL, constant = NULL, ...)

## S3 method for class 'smooth_samples'
transform_fun(object, fun = NULL, constant = NULL, ...)

## S3 method for class 'mgcv_smooth'
transform_fun(object, fun = NULL, constant = NULL, ...)

## S3 method for class 'evaluated_parametric_term'
transform_fun(object, fun = NULL, constant = NULL, ...)

## S3 method for class 'parametric_effects'
transform_fun(object, fun = NULL, constant = NULL, ...)

## S3 method for class 'tbl_df'
transform_fun(object, fun = NULL, column = NULL, constant = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_fun_+3A_object">object</code></td>
<td>
<p>an object to apply the transform function to.</p>
</td></tr>
<tr><td><code id="transform_fun_+3A_fun">fun</code></td>
<td>
<p>the function to apply.</p>
</td></tr>
<tr><td><code id="transform_fun_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods.</p>
</td></tr>
<tr><td><code id="transform_fun_+3A_constant">constant</code></td>
<td>
<p>numeric; a constant to apply before transformation.</p>
</td></tr>
<tr><td><code id="transform_fun_+3A_column">column</code></td>
<td>
<p>character; for the <code>"tbl_df"</code> method, which column to
transform.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>object</code> but with the estimate and upper and lower values
of the confidence interval transformed via the function.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>

<hr>
<h2 id='typical_values'>Typical values of model covariates</h2><span id='topic+typical_values'></span><span id='topic+typical_values.gam'></span><span id='topic+typical_values.data.frame'></span>

<h3>Description</h3>

<p>Typical values of model covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>typical_values(object, ...)

## S3 method for class 'gam'
typical_values(
  object,
  vars = everything(),
  envir = environment(formula(object)),
  data = NULL,
  ...
)

## S3 method for class 'data.frame'
typical_values(object, vars = everything(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="typical_values_+3A_object">object</code></td>
<td>
<p>a fitted GAM(M) model.</p>
</td></tr>
<tr><td><code id="typical_values_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="typical_values_+3A_vars">vars</code></td>
<td>
<p>terms to include or exclude from the returned object. Uses
tidyselect principles.</p>
</td></tr>
<tr><td><code id="typical_values_+3A_envir">envir</code></td>
<td>
<p>the environment within which to recreate the data used to fit
<code>object</code>.</p>
</td></tr>
<tr><td><code id="typical_values_+3A_data">data</code></td>
<td>
<p>an optional data frame of data used to fit the model if
reconstruction of the data from the model doesn't work.</p>
</td></tr>
</table>

<hr>
<h2 id='user_draws'>Handle user-supplied posterior draws</h2><span id='topic+user_draws'></span>

<h3>Description</h3>

<p>Handle user-supplied posterior draws
</p>


<h3>Usage</h3>

<pre><code class='language-R'>user_draws(model, draws, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="user_draws_+3A_model">model</code></td>
<td>
<p>a fitted R model. Currently only models fitted by <code>mgcv::gam()</code>
or <code>mgcv::bam()</code>, or return an object that <em>inherits</em> from such objects are
supported. Here, &quot;inherits&quot; is used in a loose fashion; models fitted by
<code>scam::scam()</code> are support even though those models don't strictly inherit
from class <code>"gam"</code> as far as <code>inherits()</code> is concerned.</p>
</td></tr>
<tr><td><code id="user_draws_+3A_draws">draws</code></td>
<td>
<p>matrix; user supplied posterior draws to be used when
<code>method = "user"</code>.</p>
</td></tr>
<tr><td><code id="user_draws_+3A_...">...</code></td>
<td>
<p>arguments passed to methods.</p>
</td></tr>
</table>

<hr>
<h2 id='variance_comp'>Variance components of smooths from smoothness estimates</h2><span id='topic+variance_comp'></span><span id='topic+variance_comp.gam'></span>

<h3>Description</h3>

<p>A wrapper to <code><a href="mgcv.html#topic+gam.vcomp">mgcv::gam.vcomp()</a></code> which returns the smoothing parameters
expressed as variance components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variance_comp(object, ...)

## S3 method for class 'gam'
variance_comp(object, rescale = TRUE, coverage = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variance_comp_+3A_object">object</code></td>
<td>
<p>an R object. Currently only models fitted by <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code> or
<code><a href="mgcv.html#topic+bam">mgcv::bam()</a></code> are supported.</p>
</td></tr>
<tr><td><code id="variance_comp_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
<tr><td><code id="variance_comp_+3A_rescale">rescale</code></td>
<td>
<p>logical; for numerical stability reasons the penalty matrices
of smooths are rescaled before fitting. If <code>rescale = TRUE</code>, this rescaling
is undone, resulting in variance components that are on their original
scale. This is needed if comparing with other mixed model software, such as
<code>lmer()</code>.</p>
</td></tr>
<tr><td><code id="variance_comp_+3A_coverage">coverage</code></td>
<td>
<p>numeric; a value between 0 and 1 indicating the (approximate)
coverage of the confidence interval that is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper to <code><a href="mgcv.html#topic+gam.vcomp">mgcv::gam.vcomp()</a></code> which performs
three additional services
</p>

<ul>
<li><p> it suppresses the annoying text output that <code><a href="mgcv.html#topic+gam.vcomp">mgcv::gam.vcomp()</a></code> prints to
the terminal,
</p>
</li>
<li><p> returns the variance of each smooth as well as the standard deviation, and
</p>
</li>
<li><p> returns the variance components as a tibble.
</p>
</li></ul>


<hr>
<h2 id='vars_from_label'>Returns names of variables from a smooth label</h2><span id='topic+vars_from_label'></span>

<h3>Description</h3>

<p>Returns names of variables from a smooth label
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vars_from_label(label)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vars_from_label_+3A_label">label</code></td>
<td>
<p>character; a length 1 character vector containing the label of
a smooth.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
vars_from_label("s(x1)")
vars_from_label("t2(x1,x2,x3)")
</code></pre>

<hr>
<h2 id='which_smooths'>Identify a smooth term by its label</h2><span id='topic+which_smooths'></span><span id='topic+which_smooths.default'></span><span id='topic+which_smooths.gam'></span><span id='topic+which_smooths.bam'></span><span id='topic+which_smooths.gamm'></span>

<h3>Description</h3>

<p>Identify a smooth term by its label
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_smooths(object, ...)

## Default S3 method:
which_smooths(object, ...)

## S3 method for class 'gam'
which_smooths(object, terms, ...)

## S3 method for class 'bam'
which_smooths(object, terms, ...)

## S3 method for class 'gamm'
which_smooths(object, terms, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which_smooths_+3A_object">object</code></td>
<td>
<p>a fitted GAM.</p>
</td></tr>
<tr><td><code id="which_smooths_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="which_smooths_+3A_terms">terms</code></td>
<td>
<p>character; one or more (partial) term labels with which to identify
required smooths.</p>
</td></tr>
</table>

<hr>
<h2 id='worm_plot'>Worm plot of model residuals</h2><span id='topic+worm_plot'></span><span id='topic+worm_plot.gam'></span><span id='topic+worm_plot.glm'></span><span id='topic+worm_plot.lm'></span>

<h3>Description</h3>

<p>Worm plot of model residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>worm_plot(model, ...)

## S3 method for class 'gam'
worm_plot(
  model,
  method = c("uniform", "simulate", "normal", "direct"),
  type = c("deviance", "response", "pearson"),
  n_uniform = 10,
  n_simulate = 50,
  level = 0.9,
  ylab = NULL,
  xlab = NULL,
  title = NULL,
  subtitle = NULL,
  caption = NULL,
  ci_col = "black",
  ci_alpha = 0.2,
  point_col = "black",
  point_alpha = 1,
  line_col = "red",
  ...
)

## S3 method for class 'glm'
worm_plot(model, ...)

## S3 method for class 'lm'
worm_plot(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="worm_plot_+3A_model">model</code></td>
<td>
<p>a fitted model. Currently only class <code>"gam"</code>.</p>
</td></tr>
<tr><td><code id="worm_plot_+3A_...">...</code></td>
<td>
<p>arguments passed ot other methods.</p>
</td></tr>
<tr><td><code id="worm_plot_+3A_method">method</code></td>
<td>
<p>character; method used to generate theoretical quantiles. Note
that <code>method = "direct"</code> is deprecated in favour of <code>method = "uniform"</code>.</p>
</td></tr>
<tr><td><code id="worm_plot_+3A_type">type</code></td>
<td>
<p>character; type of residuals to use. Only <code>"deviance"</code>,
<code>"response"</code>, and <code>"pearson"</code> residuals are allowed.</p>
</td></tr>
<tr><td><code id="worm_plot_+3A_n_uniform">n_uniform</code></td>
<td>
<p>numeric; number of times to randomize uniform quantiles
in the direct computation method (<code>method = "uniform"</code>).</p>
</td></tr>
<tr><td><code id="worm_plot_+3A_n_simulate">n_simulate</code></td>
<td>
<p>numeric; number of data sets to simulate from the estimated
model when using the simulation method (<code>method = "simulate"</code>).</p>
</td></tr>
<tr><td><code id="worm_plot_+3A_level">level</code></td>
<td>
<p>numeric; the coverage level for reference intervals. Must be
strictly <code style="white-space: pre;">&#8288;0 &lt; level &lt; 1&#8288;</code>. Only used with <code>method = "simulate"</code>.</p>
</td></tr>
<tr><td><code id="worm_plot_+3A_ylab">ylab</code></td>
<td>
<p>character or expression; the label for the y axis. If not
supplied, a suitable label will be generated.</p>
</td></tr>
<tr><td><code id="worm_plot_+3A_xlab">xlab</code></td>
<td>
<p>character or expression; the label for the y axis. If not
supplied, a suitable label will be generated.</p>
</td></tr>
<tr><td><code id="worm_plot_+3A_title">title</code></td>
<td>
<p>character or expression; the title for the plot. See
<code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>. May be a vector, one per penalty.</p>
</td></tr>
<tr><td><code id="worm_plot_+3A_subtitle">subtitle</code></td>
<td>
<p>character or expression; the subtitle for the plot. See
<code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>. May be a vector, one per penalty.</p>
</td></tr>
<tr><td><code id="worm_plot_+3A_caption">caption</code></td>
<td>
<p>character or expression; the plot caption. See
<code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>. May be a vector, one per penalty.</p>
</td></tr>
<tr><td><code id="worm_plot_+3A_ci_col">ci_col</code></td>
<td>
<p>fill colour for the reference interval when
<code>method = "simulate"</code>.</p>
</td></tr>
<tr><td><code id="worm_plot_+3A_ci_alpha">ci_alpha</code></td>
<td>
<p>alpha transparency for the reference
interval when <code>method = "simulate"</code>.</p>
</td></tr>
<tr><td><code id="worm_plot_+3A_point_col">point_col</code></td>
<td>
<p>colour of points on the QQ plot.</p>
</td></tr>
<tr><td><code id="worm_plot_+3A_point_alpha">point_alpha</code></td>
<td>
<p>alpha transparency of points on the QQ plot.</p>
</td></tr>
<tr><td><code id="worm_plot_+3A_line_col">line_col</code></td>
<td>
<p>colour used to draw the reference line.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The wording used in <code><a href="mgcv.html#topic+qq.gam">mgcv::qq.gam()</a></code> uses <em>direct</em> in reference to the
simulated residuals method (<code>method = "simulated"</code>). To avoid confusion,
<code>method = "direct"</code> is deprecated in favour of <code>method = "uniform"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load_mgcv()
## simulate binomial data...
dat &lt;- data_sim("eg1", n = 200, dist = "binary", scale = .33, seed = 0)
p &lt;- binomial()$linkinv(dat$f) # binomial p
n &lt;- sample(c(1, 3), 200, replace = TRUE) # binomial n
dat &lt;- transform(dat, y = rbinom(n, n, p), n = n)
m &lt;- gam(y / n ~ s(x0) + s(x1) + s(x2) + s(x3),
  family = binomial, data = dat, weights = n,
  method = "REML"
)

## Worm plot; default using direct randomization of uniform quantiles
## Note no reference bands are drawn with this method.
worm_plot(m)

## Alternatively use simulate new data from the model, which
## allows construction of reference intervals for the Q-Q plot
worm_plot(m,
  method = "simulate", point_col = "steelblue",
  point_alpha = 0.4
)

## ... or use the usual normality assumption
worm_plot(m, method = "normal")
</code></pre>

<hr>
<h2 id='zooplankton'>Madison lakes zooplankton data</h2><span id='topic+zooplankton'></span>

<h3>Description</h3>

<p>The Madison lake zooplankton data are from a long-term study in seasonal
dynamics of zooplankton, collected by the Richard Lathrop. The data were
collected from a chain of lakes in Wisconsin (Mendota, Monona, Kegnonsa,
and Waubesa) approximately bi-weekly from 1976 to 1994. They consist of
samples of the zooplankton communities, taken from the deepest point of each
lake via vertical tow. The data are provided by the Wisconsin Department of
Natural Resources and their collection and processing are fully described in
Lathrop (2000).
</p>


<h3>Format</h3>

<p>A data frame
</p>


<h3>Details</h3>

<p>Each record consists of counts of a given zooplankton taxon taken from a
subsample from a single vertical net tow, which was then scaled to account
for the relative volume of subsample versus the whole net sample and the area
of the net tow and rounded to the nearest 1000 to give estimated population
density per m2 for each taxon at each point in time in each sampled lake.
</p>


<h3>Source</h3>

<p>Pedersen EJ, Miller DL, Simpson GL, Ross N. 2018. Hierarchical
generalized additive models: an introduction with mgcv. <em>PeerJ Preprints</em>
<strong>6</strong>:e27320v1 <a href="https://doi.org/10.7287/peerj.preprints.27320v1">doi:10.7287/peerj.preprints.27320v1</a>.
</p>


<h3>References</h3>

<p>Lathrop RC. (2000). Madison Wisonsin Lakes Zooplankton 1976&ndash;1994.
Environmental Data Initiative.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
