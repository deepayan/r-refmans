<!DOCTYPE html><html lang="en"><head><title>Help for package BNSP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BNSP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BNSP-package'><p>Bayesian non- and semi-parametric model fitting</p></a></li>
<li><a href='#ami'><p>Amitriptyline dataset from Johnson and Wichern</p></a></li>
<li><a href='#chol'><p>The Cholesky and modified Cholesky decompositions</p></a></li>
<li><a href='#clustering'><p>Computes the similarity matrix</p></a></li>
<li><a href='#continue'><p>Continues the sampler from where it stopped</p></a></li>
<li><a href='#dpmj'><p>Dirichlet process mixtures of joint models</p></a></li>
<li><a href='#histCorr'><p>Creates plots of correlation matrices</p></a></li>
<li><a href='#lmrm'><p>Bayesian semiparametric modelling of covariance matrices for multivariate longitudinal data</p></a></li>
<li><a href='#mvrm'><p>Bayesian semiparametric analysis of multivariate continuous responses, with variable selection</p></a></li>
<li><a href='#mvrm2mcmc'><p>Convert posterior samples from function <code>mvrm</code> into an object of class &lsquo;mcmc&rsquo;</p></a></li>
<li><a href='#plot.mvrm'><p>Creates plots of terms in the mean and/or variance models</p></a></li>
<li><a href='#plotCorr'><p>Creates plots of the correlation matrices</p></a></li>
<li><a href='#predict.mvrm'><p>Model predictions</p></a></li>
<li><a href='#print.mvrm'><p>Prints an mvrm fit</p></a></li>
<li><a href='#s'><p>mgcv constructor <code>s</code></p></a></li>
<li><a href='#simD'><p>Simulated dataset</p></a></li>
<li><a href='#simD2'><p>Simulated dataset</p></a></li>
<li><a href='#sinusoid'><p>Sinusoid terms in mvrm formulae</p></a></li>
<li><a href='#sm'><p>Smooth terms in mvrm formulae</p></a></li>
<li><a href='#summary.mvrm'><p>Summary of an mvrm fit</p></a></li>
<li><a href='#te'><p>mgcv constructor <code>te</code></p></a></li>
<li><a href='#ti'><p>mgcv constructor <code>ti</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Bayesian Non- And Semi-Parametric Model Fitting</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-05-25</td>
</tr>
<tr>
<td>Author:</td>
<td>Georgios Papageorgiou</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Georgios Papageorgiou &lt;gpapageo@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>MCMC algorithms &amp; processing functions for: 1. single response multiple regression, see Papageorgiou, G. (2018) &lt;<a href="https://doi.org/10.32614%2FRJ-2018-069">doi:10.32614/RJ-2018-069</a>&gt;, 2. multivariate response multiple regression, with nonparametric models for the means, the variances and the correlation matrix, with variable selection, see Papageorgiou, G. and Marshall, B. C. (2020) &lt;<a href="https://doi.org/10.1080%2F10618600.2020.1739534">doi:10.1080/10618600.2020.1739534</a>&gt;, 3. joint mean-covariance models for multivariate responses, see Papageorgiou, G. (2022) &lt;<a href="https://doi.org/10.1002%2Fsim.9376">doi:10.1002/sim.9376</a>&gt;, and 4.Dirichlet process mixtures, see Papageorgiou, G. (2019) &lt;<a href="https://doi.org/10.1111%2Fanzs.12273">doi:10.1111/anzs.12273</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>coda, ggplot2, plot3D, threejs, gridExtra, cubature, Formula,
plyr, mgcv, corrplot, label.switching</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cubature</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mvtnorm, np</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-25 07:19:51 UTC; papgeo</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-25 10:40:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='BNSP-package'>Bayesian non- and semi-parametric model fitting</h2><span id='topic+BNSP-package'></span><span id='topic+BNSP'></span>

<h3>Description</h3>

<p>Markov chain Monte Carlo algorithms for non- and semi-parametric models: 1. spike-slab variable selection in multivariate mean/variance regression models with function <code>mvrm</code>, 2. joint mean-covariance models for multivariate longitudinal responses with function <code>lmrm</code>, and 3. Dirichlet process mixture models with function <code>dpmj</code>.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> BNSP</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.2.3</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-05-25</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2)</td>
</tr>

</table>

<p>This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.
</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
</p>
<p>For details on  the GNU General Public License
see <a href="http://www.gnu.org/copyleft/gpl.html">http://www.gnu.org/copyleft/gpl.html</a> or
write to the Free Software Foundation, Inc., 51 Franklin Street,
Fifth Floor, Boston, MA  02110-1301, USA.</p>


<h3>Author(s)</h3>

<p>Georgios Papageorgiou (2014)
</p>
<p>Maintainer: Georgios Papageorgiou &lt;gpapageo@gmail.com&gt;</p>


<h3>References</h3>

<p>Papageorgiou, G. (2020). Bayesian semiparametric modelling of covariance matrices for multivariate longitudinal data. https://arxiv.org/abs/2012.09833 
</p>
<p>Papageorgiou, G. and Marshall, B.C. (2020). Bayesian semiparametric analysis of multivariate continuous responses, with variable selection. Journal of Computational and Graphical Statistics, 29:4, 896-909, DOI: 10.1080/10618600.2020.1739534
</p>
<p>Papageorgiou, G. (2018). BNSP: an R Package for fitting Bayesian semiparametric regression models and variable selection. The R Journal, 10(2):526-548.
</p>
<p>Papageorgiou, G. (2018). Bayesian density regression for discrete outcomes. Australian and New Zealand Journal of Statistics, arXiv:1603.09706v3 [stat.ME]. 
</p>
<p>Papageorgiou, G., Richardson, S. and Best, N. (2015). Bayesian nonparametric models for spatially indexed data of mixed type.
Journal of the Royal Statistical Society: Series B (Statistical Methodology), 77:973-999.
</p>

<hr>
<h2 id='ami'>Amitriptyline dataset from Johnson and Wichern</h2><span id='topic+ami'></span>

<h3>Description</h3>

<p>Amitriptyline is a prescription antidepressant. The dataset consists of measurements on 17 patients who had over-dosed on amitriptyline.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ami)</code></pre>


<h3>Format</h3>

<p>A data frame containing 17 rows and 7 columns. The columns represent
</p>

<dl>
<dt><code>tot</code></dt><dd><p>total blood plasma level.</p>
</dd>
<dt><code>ami</code></dt><dd><p>amount of amitriptyline found in the plasma.</p>
</dd>
<dt><code>gen</code></dt><dd><p>gender (1 for female).</p>
</dd>
<dt><code>amt</code></dt><dd><p>amount of the drug taken.</p>
</dd>
<dt><code>pr</code></dt><dd><p>PR wave measurement.</p>
</dd>
<dt><code>bp</code></dt><dd><p>diastolic blood pressure.</p>
</dd>
<dt><code>qrs</code></dt><dd><p>QRS wave measurement.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Johnson, R. A., and Wichern, D. W. (2007), Applied Multivariate Statistical Analysis, Essex: Pearson, page 426.</p>


<h3>References</h3>

<p>Johnson, R. A., and Wichern, D. W. (2007). <em>Applied Multivariate Statistical Analysis</em>, Essex: Pearson.</p>

<hr>
<h2 id='chol'>The Cholesky and modified Cholesky decompositions</h2><span id='topic+chol'></span>

<h3>Description</h3>

<p>Computes the Cholesky factorization and modified Cholesky factorizations of a real symmetric positive-definite square matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chol(x, mod = TRUE, p = 1, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chol_+3A_x">x</code></td>
<td>
<p>A symmetric, positive-definite matrix.</p>
</td></tr>
<tr><td><code id="chol_+3A_mod">mod</code></td>
<td>
<p>Defaults to TRUE. With this choice, the function returns the modified Cholesky decomposition. When mod = FALSE, the function returns the usual Cholesky
decomposition.</p>
</td></tr>
<tr><td><code id="chol_+3A_p">p</code></td>
<td>
<p>Relevant only when <code>mod = TRUE</code>. It determines the size of the blocks of the block diagonal matrix.</p>
</td></tr>
<tr><td><code id="chol_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the modified Cholesky decomposition of a real symmetric positive-definite square matrix <code class="reqn">\Sigma</code>. This is given by
</p>
<p style="text-align: center;"><code class="reqn">L \Sigma L^{\top} = D,</code>
</p>

<p>where <code class="reqn">L</code> is a lower tringular matrix with ones on its main diagonal and D is a block diagonal matrix with block size determined by argument <code>p</code>.</p>


<h3>Value</h3>

<p>The function returns matrices <code class="reqn">L</code> and <code class="reqn">D</code>.</p>


<h3>Author(s)</h3>

<p>Georgios Papageorgiou <a href="mailto:gpapageo@gmail.com">gpapageo@gmail.com</a></p>


<h3>See Also</h3>

<p>The default function from <span class="pkg">base</span>, <code><a href="base.html#topic+chol">chol</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>Sigma &lt;- matrix(c(1.21,0.18,0.13,0.41,0.06,0.23,
                  0.18,0.64,0.10,-0.16,0.23,0.07,
                  0.13,0.10,0.36,-0.10,0.03,0.18,
                  0.41,-0.16,-0.10,1.05,-0.29,-0.08,
                  0.06,0.23,0.03,-0.29,1.71,-0.10,
                  0.23,0.07,0.18,-0.08,-0.10,0.36),6,6)
LD &lt;- chol(Sigma)
L &lt;- LD$L
D &lt;- LD$D
round(L,5)
round(D,5)
solve(L) %*% D %*% solve(t(L))
LD &lt;- chol(Sigma, p = 2)
L &lt;- LD$L
D &lt;- LD$D
round(L, 5)
round(D, 5)
solve(L) %*% D %*% solve(t(L))
</code></pre>

<hr>
<h2 id='clustering'>Computes the similarity matrix</h2><span id='topic+clustering'></span>

<h3>Description</h3>

<p>Computes the similarity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustering(object, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clustering_+3A_object">object</code></td>
<td>
<p>an object of class &quot;mvrm&quot;, usually a result of a call to <code>mvrm</code>.</p>
</td></tr>
<tr><td><code id="clustering_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the similarity matrix for clustering based on corrrelations or variables.</p>


<h3>Value</h3>

<p>Similarity matrix.</p>


<h3>Author(s)</h3>

<p>Georgios Papageorgiou <a href="mailto:gpapageo@gmail.com">gpapageo@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+mvrm">mvrm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#see \code{mvrm} example</code></pre>

<hr>
<h2 id='continue'>Continues the sampler from where it stopped</h2><span id='topic+continue'></span>

<h3>Description</h3>

<p>Allows the user to continue the sampler from the state it stopped in the previous call to <code>mvrm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>continue(object, sweeps, burn = 0, thin, discard = FALSE,...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="continue_+3A_object">object</code></td>
<td>
<p>An object of class &quot;mvrm&quot;, usually a result of a call to <code>mvrm</code>.</p>
</td></tr>
<tr><td><code id="continue_+3A_sweeps">sweeps</code></td>
<td>
<p>The number of additional sweeps, maintaining the same thinning interval as specified in the original call to <code>mvrm</code>.</p>
</td></tr>
<tr><td><code id="continue_+3A_burn">burn</code></td>
<td>
<p>length of burn-in period. Defaults to zero.</p>
</td></tr>
<tr><td><code id="continue_+3A_thin">thin</code></td>
<td>
<p>thinning parameter. Defaults to the thinning parameter chosen for <code>object</code>.</p>
</td></tr>
<tr><td><code id="continue_+3A_discard">discard</code></td>
<td>
<p>If set to true, the previous samples are discarded.</p>
</td></tr>
<tr><td><code id="continue_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function allows the sampler to continue from the state it last stopped.</p>


<h3>Value</h3>

<p>The function returns an object of class <code>mvrm</code>.</p>


<h3>Author(s)</h3>

<p>Georgios Papageorgiou <a href="mailto:gpapageo@gmail.com">gpapageo@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+mvrm">mvrm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#see \code{mvrm} example</code></pre>

<hr>
<h2 id='dpmj'>Dirichlet process mixtures of joint models</h2><span id='topic+dpmj'></span>

<h3>Description</h3>

<p>Fits Dirichlet process mixtures of joint response-covariate models, where the covariates are
of mixed type while the discrete responses are represented utilizing continuous latent variables. See &lsquo;Details&rsquo;
section for a full model description and Papageorgiou (2018) for all technical details.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpmj(formula, Fcdf, data, offset, sampler = "truncated", Xpred, offsetPred,
     StorageDir, ncomp, sweeps, burn, thin = 1, seed, H, Hdf, d, D,
     Alpha.xi, Beta.xi, Alpha.alpha, Beta.alpha, Trunc.alpha, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dpmj_+3A_formula">formula</code></td>
<td>
<p>a formula defining the response and the covariates e.g. <code>y ~ x</code>.</p>
</td></tr>
<tr><td><code id="dpmj_+3A_fcdf">Fcdf</code></td>
<td>
<p>a description of the kernel of the response variable. Currently five options are
supported: 1. &quot;poisson&quot;, 2. &quot;negative binomial&quot;, 3. &quot;generalized poisson&quot;, 4. &quot;binomial&quot; and 
5. &quot;beta binomial&quot;. The first three kernels are used for count data analysis, where the third
kernel allows for both over- and under-dispersion relative to the Poisson distribution.   
The last two kernels are used for binomial data analysis. See &lsquo;Details&rsquo; section for some of the 
kernel details.</p>
</td></tr>
<tr><td><code id="dpmj_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by &lsquo;as.data.frame&rsquo; to a data frame)
containing the variables in the model.  If not found in &lsquo;data&rsquo;, the variables are taken from
&lsquo;environment(formula)&rsquo;.</p>
</td></tr>
<tr><td><code id="dpmj_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an a priori known component to be included in the model. 
This should be &lsquo;NULL&rsquo; or a numeric vector of length equal to the sample size.
One &lsquo;offset&rsquo; term can be included in the formula, and if more are
required, their sum should be used.</p>
</td></tr>
<tr><td><code id="dpmj_+3A_sampler">sampler</code></td>
<td>
<p>the MCMC algorithm to be utilized. The two options are <code>sampler = "slice"</code> which
implements a slice sampler (Walker, 2007; Papaspiliopoulos, 2008) and
<code>sampler = "truncated"</code> which proceeds
by truncating the countable mixture at <code>ncomp</code> components (see argument <code>ncomp</code>).</p>
</td></tr>
<tr><td><code id="dpmj_+3A_xpred">Xpred</code></td>
<td>
<p>an optional design matrix the rows of which include the values of the covariates <code class="reqn">x</code> for which the conditional distribution
of <code class="reqn">Y|x,D</code> (where <code class="reqn">D</code> denotes the data) is calculated. These are treated as &lsquo;new&rsquo; covariates i.e.
they do not contribute to the likelihood. The matrix shouldn't include a column of 1's. NA's can be 
included to obtain averaged effects.</p>
</td></tr>
<tr><td><code id="dpmj_+3A_offsetpred">offsetPred</code></td>
<td>
<p>the offset term associated with the new covariates <code>Xpred</code>. It is of dimension one i.e.
the same offset term is used for all rows of <code>Xpred</code>. If <code>Fcdf</code> is one of &quot;poisson&quot; or 
&quot;negative binomial&quot; or &quot;generalized poisson&quot;, then <code>offsetPred</code> is the Poisson offset term. 
If <code>Fcdf</code> is one of &quot;binomial&quot; or &quot;beta binomial&quot;, then <code>offsetPred</code> is the number of Binomial trials. 
If <code>offsetPred</code> is missing, it is taken to be the mean of <code>offset</code>, rounded to the nearest integer.</p>
</td></tr>
<tr><td><code id="dpmj_+3A_storagedir">StorageDir</code></td>
<td>
<p>a directory to store files with the posterior samples of models parameters and other quantities 
of interest. If a directory is not provided, files are created in the current directory and removed 
when the sampler completes.</p>
</td></tr>
<tr><td><code id="dpmj_+3A_ncomp">ncomp</code></td>
<td>
<p>number of mixture components. It defines where the countable mixture of densities [in (1) below] is truncated.
Even if  <code>sampler="slice"</code> is chosen, <code>ncomp</code> needs to be specified as it is used in the initialization process.</p>
</td></tr>
<tr><td><code id="dpmj_+3A_sweeps">sweeps</code></td>
<td>
<p>total number of posterior samples, including those discarded in burn-in period (see argument <code>burn</code>) 
and those discarded by the thinning process (see argument <code>thin</code>).</p>
</td></tr>
<tr><td><code id="dpmj_+3A_burn">burn</code></td>
<td>
<p>length of burn-in period.</p>
</td></tr>
<tr><td><code id="dpmj_+3A_thin">thin</code></td>
<td>
<p>thinning parameter.</p>
</td></tr>
<tr><td><code id="dpmj_+3A_seed">seed</code></td>
<td>
<p>optional seed for the random generator.</p>
</td></tr>
<tr><td><code id="dpmj_+3A_h">H</code></td>
<td>
<p>optional scale matrix of the Wishart-like prior assigned to the restricted covariance matrices <code class="reqn">\Sigma_h^*</code>.
See &lsquo;Details&rsquo; section.</p>
</td></tr>
<tr><td><code id="dpmj_+3A_hdf">Hdf</code></td>
<td>
<p>optional degrees of freedom of the prior Wishart-like prior assigned to the restricted covariance matrices <code class="reqn">\Sigma_h^*</code>.
See &lsquo;Details&rsquo; section.</p>
</td></tr>
<tr><td><code id="dpmj_+3A_d">d</code></td>
<td>
<p>optional prior mean of the mean vector <code class="reqn">\mu_h</code>. See &lsquo;Details&rsquo; section.</p>
</td></tr>
<tr><td><code id="dpmj_+3A_d">D</code></td>
<td>
<p>optional prior covariance matrix of the mean vector <code class="reqn">\mu_h</code>. See &lsquo;Details&rsquo; section.</p>
</td></tr>
<tr><td><code id="dpmj_+3A_alpha.xi">Alpha.xi</code></td>
<td>
<p>an optional parameter that depends on the specified <code>Fcdf</code> argument.
</p>

<ol>
<li><p> If <code>Fcdf = "poisson"</code>, this argument is parameter <code class="reqn">\alpha_{\xi}</code> of the prior of the Poisson rate:
<code class="reqn">\xi \sim</code> Gamma(<code class="reqn">\alpha_{\xi},\beta_{\xi}</code>).
</p>
</li>
<li><p> If <code>Fcdf = "negative binomial"</code>,
this argument is a two-dimensional vector that includes parameters 
<code class="reqn">\alpha_{1\xi}</code> and <code class="reqn">\alpha_{2\xi}</code> of the priors:
<code class="reqn">\xi_1 \sim </code> Gamma(<code class="reqn">\alpha_{1\xi},\beta_{1\xi}</code>) and
<code class="reqn">\xi_2 \sim </code> Gamma(<code class="reqn">\alpha_{2\xi},\beta_{2\xi}</code>), where <code class="reqn">\xi_1</code> and <code class="reqn">\xi_2</code>
are the two parameters of the Negative Binomial pmf.
</p>
</li>
<li><p> If <code>Fcdf = "generalized poisson"</code>, this argument is a two-dimensional vector 
that includes parameters <code class="reqn">\alpha_{1\xi}</code> and <code class="reqn">\alpha_{2\xi}</code> of the priors:
<code class="reqn">\xi_1 \sim </code> Gamma(<code class="reqn">\alpha_{1\xi},\beta_{1\xi}</code>) and
<code class="reqn">\xi_2 \sim </code> N(<code class="reqn">\alpha_{2\xi},\beta_{2\xi})I[\xi_2 \in R_{\xi_2}]</code>, where <code class="reqn">\xi_1</code> and <code class="reqn">\xi_2</code>
are the two parameters of the Generalized Poisson pmf. Parameter <code class="reqn">\xi_2</code> is restricted in the range
<code class="reqn">R_{\xi_2} = (0.05,\infty)</code> as it is a dispersion parameter. 
</p>
</li>
<li><p> If <code>Fcdf = "binomial"</code>, this argument is parameter <code class="reqn">\alpha_{\xi}</code> of the prior of the Binomial probability:
<code class="reqn">\xi \sim</code> Beta(<code class="reqn">\alpha_{\xi},\beta_{\xi}</code>).
</p>
</li>
<li><p> If <code>Fcdf = "beta binomial"</code>, 
this argument is a two-dimensional vector that includes parameters 
<code class="reqn">\alpha_{1\xi}</code> and <code class="reqn">\alpha_{2\xi}</code> of the priors:
<code class="reqn">\xi_1 \sim </code> Gamma(<code class="reqn">\alpha_{1\xi},\beta_{1\xi}</code>) and
<code class="reqn">\xi_2 \sim </code> Gamma(<code class="reqn">\alpha_{2\xi},\beta_{2\xi}</code>), where <code class="reqn">\xi_1</code> and <code class="reqn">\xi_2</code>
are the two parameters of the Beta Binomial pmf.
</p>
</li></ol>

<p>See &lsquo;Details&rsquo; section.</p>
</td></tr>
<tr><td><code id="dpmj_+3A_beta.xi">Beta.xi</code></td>
<td>
<p>an optional parameter that depends on the specified family.
</p>

<ol>
<li><p> If <code>Fcdf = "poisson"</code>, this argument is parameter <code class="reqn">\beta_{\xi}</code> of the prior of the Poisson rate:
<code class="reqn">\xi \sim</code> Gamma(<code class="reqn">\alpha_{\xi},\beta_{\xi}</code>).
</p>
</li>
<li><p> If <code>Fcdf = "negative binomial"</code>,
this argument is a two-dimensional vector that includes parameters 
<code class="reqn">\beta_{1\xi}</code> and <code class="reqn">\beta_{2\xi}</code> of the priors:
<code class="reqn">\xi_1 \sim </code> Gamma(<code class="reqn">\alpha_{1\xi},\beta_{1\xi}</code>) and
<code class="reqn">\xi_2 \sim </code> Gamma(<code class="reqn">\alpha_{2\xi},\beta_{2\xi}</code>), where <code class="reqn">\xi_1</code> and <code class="reqn">\xi_2</code>
are the two parameters of the Negative Binomial pmf.
</p>
</li>
<li><p> If <code>Fcdf = "generalized poisson"</code>, this argument is a two-dimensional vector 
that includes parameters <code class="reqn">\beta_{1\xi}</code> and <code class="reqn">\beta_{2\xi}</code> of the priors:
<code class="reqn">\xi_1 \sim </code> Gamma(<code class="reqn">\alpha_{1\xi},\beta_{1\xi}</code>) and
<code class="reqn">\xi_2 \sim </code> Normal(<code class="reqn">\alpha_{2\xi},\beta_{2\xi})I[\xi_2 \in R_{\xi_2}]</code>, where <code class="reqn">\xi_1</code> and <code class="reqn">\xi_2</code>
are the two parameters of the Generalized Poisson pmf. 
Parameter <code class="reqn">\xi_2</code> is restricted in the range
<code class="reqn">R_{\xi_2} = (0.05,\infty)</code> as it is a dispersion parameter.
Note that <code class="reqn">\beta_{2\xi}</code> is a standard deviation.                          
</p>
</li>
<li><p> If <code>Fcdf = "binomial"</code>, this argument is parameter <code class="reqn">\beta_{\xi}</code> of the prior of the Binomial probability:
<code class="reqn">\xi \sim</code> Beta(<code class="reqn">\alpha_{\xi},\beta_{\xi}</code>).
</p>
</li>
<li><p> If <code>Fcdf = "beta binomial"</code>, 
this argument is a two-dimensional vector that includes parameters 
<code class="reqn">\beta_{1\xi}</code> and <code class="reqn">\beta_{2\xi}</code> of the priors:
<code class="reqn">\xi_1 \sim </code> Gamma(<code class="reqn">\alpha_{1\xi},\beta_{1\xi}</code>) and
<code class="reqn">\xi_2 \sim </code> Gamma(<code class="reqn">\alpha_{2\xi},\beta_{2\xi}</code>), where <code class="reqn">\xi_1</code> and <code class="reqn">\xi_2</code>
are the two parameters of the Beta Binomial pmf.
</p>
</li></ol>

<p>See &lsquo;Details&rsquo; section.</p>
</td></tr>
<tr><td><code id="dpmj_+3A_alpha.alpha">Alpha.alpha</code></td>
<td>
<p>optional shape parameter <code class="reqn">\alpha_{\alpha}</code> of the Gamma prior assigned to the concentration parameter <code class="reqn">\alpha</code>.
See &lsquo;Details&rsquo; section.</p>
</td></tr>
<tr><td><code id="dpmj_+3A_beta.alpha">Beta.alpha</code></td>
<td>
<p>optional rate parameter <code class="reqn">\beta_{\alpha}</code> of the Gamma prior assigned to concentration parameter <code class="reqn">\alpha</code>.
See &lsquo;Details&rsquo; section.</p>
</td></tr>
<tr><td><code id="dpmj_+3A_trunc.alpha">Trunc.alpha</code></td>
<td>
<p>optional truncation point <code class="reqn">c_{\alpha}</code> of the Gamma prior assigned to concentration parameter <code class="reqn">\alpha</code>.
See &lsquo;Details&rsquo; section.</p>
</td></tr>
<tr><td><code id="dpmj_+3A_...">...</code></td>
<td>
<p>Other options that will be ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>dpmj</code> returns samples from the posterior distributions of the parameters of the model:
</p>
<p style="text-align: center;"><code class="reqn">
f(y_i,x_i) = \sum_{h=1}^{\infty} \pi_h f(y_i,x_i|\theta_h), \hspace{200pt} (1) </code>
</p>

<p>where <code class="reqn">y_i</code> is a univariate discrete response,
<code class="reqn">x_i</code> is a <code class="reqn">p</code>-dimensional vector of mixed type covariates, and <code class="reqn">\pi_h, h \geq 1,</code> are obtained according to
Sethuraman's (1994) stick-breaking construction:
<code class="reqn">\pi_1 = v_1</code>, and for <code class="reqn">l \geq 2, \pi_l = v_l \prod_{j=1}^{l-1} (1-v_j)</code>, where <code class="reqn">v_k</code> are iid samples
<code class="reqn">v_k \sim</code>Beta <code class="reqn">(1,\alpha), k \geq 1.</code>
</p>
<p>Let <code class="reqn">Z</code> denote a discrete variable (response or covariate). It is represented as discretized version of a continuous 
latent variable <code class="reqn">Z^*</code>.
Observed discrete <code class="reqn">Z</code> and continuous latent variable <code class="reqn">Z^*</code> are connected by:
</p>
<p style="text-align: center;"><code class="reqn">
z = q \iff c_{q-1} &lt; z^* &lt; c_{q}, q=0,1,2,\dots,</code>
</p>

<p>where the cut-points are obtained as: <code class="reqn">c_{-1} = -\infty</code>,
while for <code class="reqn">q \geq 0</code>, <code class="reqn">c_{q} = c_{q}(\lambda) = \Phi^{-1}\{F(q;\lambda)\}.</code> Here <code class="reqn">\Phi(.)</code>
is the cumulative distribution function (cdf) of a standard normal variable
and <code class="reqn">F()</code> denotes an appropriate cdf. Further, latent variables are assumed to
independently follow a <code class="reqn">N(0,1)</code> distribution, where the mean and variance are restricted to be zero and one as
they are non-identifiable by the data. Choices for <code class="reqn">F()</code> are described next.
</p>
<p>For counts, three options are supported. First, <code class="reqn">F(.;\lambda_i)</code> can be specified as the 
cdf of a Poisson<code class="reqn">(H_i \xi_h)</code> variable. Here <code class="reqn">\lambda_i=(\xi_h,H_i)^T, \xi_h</code> denotes the Poisson rate 
associated with cluster <code class="reqn">h</code>, and <code class="reqn">H_i</code> the offset term associated with sampling unit <code class="reqn">i</code>.
Second, <code class="reqn">F(.;\lambda_i)</code> can be specified as the negative binomial cdf, where <code class="reqn">\lambda_i=
(\xi_{1h},\xi_{2h},H_i)^T</code>. This option allows for overdispersion within each cluster relative to the 
Poisson distribution. Third, <code class="reqn">F(.;\lambda_i)</code> can be specified as the Generalized Poisson cdf, where, again, 
<code class="reqn">\lambda_i=(\xi_{1h},\xi_{2h},H_i)^T</code>. This option allows for both over- and under-dispersion within each
cluster. 
</p>
<p>For Binomial data, two options are supported. First, <code class="reqn">F(.;\lambda_i)</code> may be taken to be the cdf of a
Binomial<code class="reqn">(H_i,\xi_h)</code> variable, where <code class="reqn">\xi_h</code> denotes the success probability of cluster <code class="reqn">h</code> and <code class="reqn">H_i</code> 
the number of trials associated with sampling unit <code class="reqn">i</code>.
Second, <code class="reqn">F(.;\lambda_i)</code> may be specified to be the beta-binomial cdf, where <code class="reqn">\lambda=(\xi_{1h},\xi_{2h},H_i)^T</code>.
</p>
<p>The special case of Binomial data is treated as 
</p>
<p style="text-align: center;"><code class="reqn">
Z = 0 \iff z^* &lt; 0, z^* \sim N(\mu_z^{*},1).</code>
</p>
 
<p>Details on all kernels are provided in the two tables below. The first table provides the probability mass functions
and the mean in the presence of an offset term (which may be taken to be one). The column &lsquo;Sample&rsquo; indicates
for which parameters the routine provides posterior samples. The second table provides information on the assumed priors
along with the default values of the parameters of the prior distributions and it also indicates the 
function arguments that allow the user to alter these.  
</p>

<table>
<tr>
 <td style="text-align: left;">
Kernel  </td><td style="text-align: left;"> PMF </td><td style="text-align: center;"> Offset </td><td style="text-align: left;"> Mean </td><td style="text-align: left;"> Sample </td>
</tr>
<tr>
 <td style="text-align: left;">
Poisson </td><td style="text-align: left;"> <code class="reqn">\exp(-H\xi) (H\xi)^y /y!</code> </td><td style="text-align: center;"> <code class="reqn">H</code>      </td><td style="text-align: left;"> <code class="reqn">H \xi</code>  </td><td style="text-align: left;"> <code class="reqn">\xi</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
Negative Binomial </td><td style="text-align: left;"> <code class="reqn">\frac{\Gamma(y+\xi_1)}{\Gamma(\xi_1)\Gamma(y+1)}(\frac{\xi_2}{H+\xi_2})^{\xi_1}(\frac{H}{H+\xi_2})^{y}</code> 
</td><td style="text-align: center;"> <code class="reqn">H</code> </td><td style="text-align: left;"> <code class="reqn">H \xi_1/\xi_2</code> </td><td style="text-align: left;"> <code class="reqn">\xi_1, \xi_2</code></td>
</tr>
<tr>
 <td style="text-align: left;"> 
Generalized Poisson </td><td style="text-align: left;"> <code class="reqn">\xi_1 \{\xi_1+(\xi_2-1)y\}^{y-1} \xi_2^{-y} \times</code> </td><td style="text-align: center;"> <code class="reqn">H</code> </td><td style="text-align: left;"> <code class="reqn">H\xi_1</code> </td><td style="text-align: left;">  <code class="reqn">\xi_1,\xi_2</code></td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code class="reqn"> ~~ \exp\{-[\xi_1+(\xi_2-1)y]/\xi_2\}/y!</code> </td><td style="text-align: center;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">   
Binomial </td><td style="text-align: left;"> <code class="reqn">{N \choose y} \xi^y (1-\xi)^{N-y}</code> </td><td style="text-align: center;"> <code class="reqn">N</code> </td><td style="text-align: left;"> <code class="reqn">N \xi</code> </td><td style="text-align: left;"> <code class="reqn">\xi</code></td>
</tr>
<tr>
 <td style="text-align: left;"> 
Beta Binomial </td><td style="text-align: left;"> <code class="reqn">{N \choose y} \frac{{Beta}{(y+\xi_1,N-y+\xi_2)}}{{Beta}{(\xi_1,\xi_2)}}</code> 
</td><td style="text-align: center;"> <code class="reqn">N</code> </td><td style="text-align: left;"> <code class="reqn">N \xi_1/(\xi_1+\xi_2)</code> </td><td style="text-align: left;"> <code class="reqn">\xi_1,\xi_2</code></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<table>
<tr>
 <td style="text-align: left;">
Kernel  </td><td style="text-align: left;"> Priors </td><td style="text-align: left;"> Default Values </td>
</tr>
<tr>
 <td style="text-align: left;">
Poisson </td><td style="text-align: left;"> <code class="reqn">\xi \sim</code> Gamma<code class="reqn">(\alpha_{\xi},\beta_{\xi})</code> </td><td style="text-align: left;"> Alpha.xi = 1.0, Beta.xi = 0.1 </td>
</tr>
<tr>
 <td style="text-align: left;">
Negative Binomial </td><td style="text-align: left;"> <code class="reqn">\xi_i \sim</code> Gamma<code class="reqn">(\alpha_{\xi_i},\beta_{\xi_i}), i=1,2</code> </td><td style="text-align: left;"> Alpha.xi = c(1.0,1.0), Beta.xi = c(0.1,0.1) </td>
</tr>
<tr>
 <td style="text-align: left;">
Generalized Poisson </td><td style="text-align: left;"> <code class="reqn">\xi_1 \sim</code> Gamma<code class="reqn">(\alpha_{\xi_1},\beta_{\xi_1})</code> </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
                    </td><td style="text-align: left;"> <code class="reqn">\xi_2 \sim</code> N<code class="reqn">(\alpha_{\xi_2},\beta_{\xi_2})I[\xi_2 &gt; 0.05]</code> </td><td style="text-align: left;"> Alpha.xi = c(1.0,1.0), Beta.xi = c(0.1,1.0) </td>
</tr>
<tr>
 <td style="text-align: left;">
                    </td><td style="text-align: left;"> where <code class="reqn">\beta_{\xi_2}</code> denotes st.dev. </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
Binomial </td><td style="text-align: left;"> <code class="reqn">\xi \sim</code> Beta<code class="reqn">(\alpha_{\xi},\beta_{\xi})</code> </td><td style="text-align: left;"> Alpha.xi = 1.0, Beta.xi = 1.0 </td>
</tr>
<tr>
 <td style="text-align: left;">
Beta Binomial </td><td style="text-align: left;"> <code class="reqn">\xi_i \sim</code> Gamma<code class="reqn">(\alpha_{\xi_i},\beta_{\xi_i}), i=1,2</code> </td><td style="text-align: left;"> Alpha.xi = c(1.0,1.0), Beta.xi = c(0.1,0.1) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Let <code class="reqn">z_i = (y_i,x_{i}^T)^T</code> denote the joint vector of observed continuous and discrete variables and <code class="reqn">z_i^*</code>
the corresponding vector of continuous observed and latent variables. With <code class="reqn">\theta_h</code> denoting model parameters
associated with the <code class="reqn">h</code>th cluster, the joint density <code class="reqn">f(z_{i}|\theta_h)</code> takes the form
</p>
<p style="text-align: center;"><code class="reqn">
f(z_i|\theta_h) = \int_{R(y)} \int_{R(x_{d})} N_{q}(z_i^*;\mu^*_h,\Sigma^*_h) dx_{d}^{*} dy^{*},</code>
</p>

<p>where </p>
<p style="text-align: center;"><code class="reqn">
\begin{array}{ll}
\mu^*_h = \left(
\begin{array}{l}
0 \\
\mu_h \\
\end{array}
\right),
 &amp;
\Sigma^*_h=\left[
\begin{array}{ll}
C_h &amp;  \nu_h^T \\
\nu_h &amp; \Sigma_h \\
\end{array}
\right]
\end{array},
</code>
</p>

<p>where <code class="reqn">C_h</code> is the covariance matrix of the latent continuous variables and it has  
diagonal elements equal to one i.e. it is a correlation matrix.
</p>
<p>In addition to the priors defined in the table above, we specify the following: 
</p>

<ol>
<li> 
<p>The restricted covariance matrix <code class="reqn">\Sigma^*_h</code> is assigned a prior distribution that is based on the Wishart
distribution with degrees of freedom set by default to dimension of matrix plus two and diagonal scale matrix,
with the sub-matrix that corresponds to discrete variables taken to be the identity matrix and with sub-matrix 
that corresponds to continuous variables having entries equal to 1/8 of the square of 
the observed data range. Default values can be changed using arguments <code>H</code> and <code>Hdf</code>.
</p>
</li>
<li>
<p>The prior on <code class="reqn">\mu_h</code>, the non-zero part of <code class="reqn">\mu_h^*</code>, is taken to be multivariate normal <code class="reqn">\mu_h \sim N(d,D)</code>. 
The mean <code class="reqn">d</code> is taken to be equal to the center of the dataset. The covariance matrix <code class="reqn">D</code> is taken to be diagonal. 
Its elements that correspond to continuous variables are set equal to 1/8 of the square of the observed data range while the 
elements that correspond to binary variables are set equal to 5.  
Arguments <code>Mu.mu</code> and <code>Sigma.mu</code> allow the user to change the default values.
</p>
</li>
<li> 
<p>The concentration parameter <code class="reqn">\alpha</code> is assigned a Gamma<code class="reqn">(\alpha_{\alpha},\beta_{\alpha})</code>
prior over the range <code class="reqn">(c_{\alpha},\infty)</code>, that is,
<code class="reqn">f(\alpha) \propto \alpha^{\alpha_{\alpha}-1} \exp\{-\alpha \beta_{\alpha}\} I[\alpha &gt; c_{\alpha}]</code>,
where <code class="reqn">I[.]</code> is the indicator function. The default values are <code class="reqn">\alpha_{\alpha}=2.0, \beta_{\alpha}=5.0</code>,
and <code class="reqn">c_{\alpha}=0.25</code>. Users can alter the default using using arguments <code>Alpha.alpha</code>, <code>Beta.alpha</code> and
<code>Turnc.alpha</code>.
</p>
</li></ol>



<h3>Value</h3>

<p>Function <code>dpmj</code> returns the following:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>seed</code></td>
<td>
<p>the seed that was used (in case replication of the results is needed).</p>
</td></tr>
<tr><td><code>meanReg</code></td>
<td>
<p>if <code>Xpred</code> is specified, the function returns the posterior mean of the conditional expectation of the response <code class="reqn">y</code> 
given each new covariate <code class="reqn">x</code>.</p>
</td></tr>
<tr><td><code>medianReg</code></td>
<td>
<p>if <code>Xpred</code> is specified, the function returns the posterior mean of the conditional 50% quantile of the response <code class="reqn">y</code> 
given each new covariate <code class="reqn">x</code>.</p>
</td></tr>
<tr><td><code>q1Reg</code></td>
<td>
<p>if <code>Xpred</code> is specified, the function returns the posterior mean of the conditional 25% quantile of the response <code class="reqn">y</code> 
given each new covariate <code class="reqn">x</code>.</p>
</td></tr>
<tr><td><code>q3Reg</code></td>
<td>
<p>if <code>Xpred</code> is specified, the function returns the posterior mean of the conditional 75% quantile of the response <code class="reqn">y</code> 
given each new covariate <code class="reqn">x</code>.</p>
</td></tr>
<tr><td><code>modeReg</code></td>
<td>
<p>if <code>Xpred</code> is specified, the function returns the posterior mean of the conditional mode of the response <code class="reqn">y</code> 
given each new covariate <code class="reqn">x</code>.</p>
</td></tr>
<tr><td><code>denReg</code></td>
<td>
<p>if <code>Xpred</code> is specified, the function returns the posterior mean conditional density of the response <code class="reqn">y</code> 
given each new covariate <code class="reqn">x</code>. Results are presented in a matrix the rows of which correspond to the different <code class="reqn">x</code>s.</p>
</td></tr>
<tr><td><code>denVar</code></td>
<td>
<p>if <code>Xpred</code> is specified, the function returns the posterior variance of the conditional density of the response <code class="reqn">y</code> 
given each new covariate <code class="reqn">x</code>. Results are presented in a matrix the rows of which correspond to the different <code class="reqn">x</code>s.</p>
</td></tr>
</table>
<p>Further, function <code>dpmj</code> creates files where the posterior samples are written. These files are (with all file names
preceded by &lsquo;BNSP.&rsquo;):
</p>
<table role = "presentation">
<tr><td><code>alpha.txt</code></td>
<td>
<p>this file contains samples from the posterior of the concentration parameters  <code class="reqn">\alpha</code>. 
The file is arranged in <code>(sweeps-burn)/thin</code> lines and one column, each line including one posterior sample.</p>
</td></tr>
<tr><td><code>compAlloc.txt</code></td>
<td>
<p>this file contains the allocations to clusters obtained during posterior sampling. 
It consists of <code>(sweeps-burn)/thin</code> lines, that represent the posterior samples, and <code class="reqn">n</code> columns, that represent the sampling units. 
Clusters are represented by integers ranging from 0 to <code>ncomp</code>-1.</p>
</td></tr>
<tr><td><code>MeanReg.txt</code></td>
<td>
<p>this file contains the conditional means of the response <code class="reqn">y</code> given covariates <code class="reqn">x</code> obtained during posterior sampling. 
The rows represent the <code>(sweeps-burn)/thin</code> posterior samples. The columns represent the various covariate values <code class="reqn">x</code> for which the 
means are obtained.</p>
</td></tr>
<tr><td><code>MedianReg.txt</code></td>
<td>
<p>this file contains the 50% conditional quantile of the response <code class="reqn">y</code> given covariates <code class="reqn">x</code> obtained 
during posterior sampling. The rows represent the <code>(sweeps-burn)/thin</code> posterior samples. The columns represent the various covariate 
values <code class="reqn">x</code> for which the medians are obtained.</p>
</td></tr>
<tr><td><code>muh.txt</code></td>
<td>
<p>this file contains samples from the posteriors of the <code class="reqn">p</code>-dimensional mean vectors  <code class="reqn">\mu_h, h=1,2,\dots</code>,<code>ncomp</code>. 
The file is arranged in <code>((sweeps-burn)/thin)*ncomp</code> lines and <code class="reqn">p</code> columns. In more detail, sweeps create <code>ncomp</code> 
lines representing samples <code class="reqn">\mu_h^{(sw)}, h=1,\dots,</code><code>ncomp</code>, where superscript <code class="reqn">sw</code> represents a particular sweep. 
The elements of <code class="reqn">\mu_h^{(sw)}</code> are written in the columns of the file.</p>
</td></tr>
<tr><td><code>nmembers.txt</code></td>
<td>
<p>this file contains <code>(sweeps-burn)/thin</code> lines and <code>ncomp</code> columns, where the lines represent posterior 
samples while the columns represent the components or clusters. The entries represent the number of sampling units allocated to each 
component.</p>
</td></tr>
<tr><td><code>Q05Reg.txt</code></td>
<td>
<p>this file contains the 5% conditional quantile of the response <code class="reqn">y</code> given covariates <code class="reqn">x</code> obtained during 
posterior sampling. The rows represent the <code>(sweeps-burn)/thin</code> posterior samples. The columns represent the various covariate values 
<code class="reqn">x</code> for which the quantiles are obtained.</p>
</td></tr>
<tr><td><code>Q10Reg.txt</code></td>
<td>
<p>as above, for the 10% conditional quantile.</p>
</td></tr>
<tr><td><code>Q15Reg.txt</code></td>
<td>
<p>as above, for the 15% conditional quantile.</p>
</td></tr>
<tr><td><code>Q20Reg.txt</code></td>
<td>
<p>as above, for the 20% conditional quantile.</p>
</td></tr>
<tr><td><code>Q25Reg.txt</code></td>
<td>
<p>as above, for the 25% conditional quantile.</p>
</td></tr>
<tr><td><code>Q75Reg.txt</code></td>
<td>
<p>as above, for the 75% conditional quantile.</p>
</td></tr>
<tr><td><code>Q80Reg.txt</code></td>
<td>
<p>as above, for the 80% conditional quantile.</p>
</td></tr>
<tr><td><code>Q85Reg.txt</code></td>
<td>
<p>as above, for the 85% conditional quantile.</p>
</td></tr>
<tr><td><code>Q90Reg.txt</code></td>
<td>
<p>as above, for the 90% conditional quantile.</p>
</td></tr>
<tr><td><code>Q95Reg.txt</code></td>
<td>
<p>as above, for the 95% conditional quantile.</p>
</td></tr>
<tr><td><code>Sigmah.txt</code></td>
<td>
<p>this file contains samples from the posteriors of the <code class="reqn">q \times q</code> restricted covariance  
matrices <code class="reqn">\Sigma_h^*, h=1,2,\dots,</code><code>ncomp</code>. The file is arranged in <code>((sweeps-burn)/thin)*ncomp</code> lines and <code class="reqn">q^2</code> 
columns. In more detail, sweeps create <code>ncomp</code> lines representing samples <code class="reqn">\Sigma_h^{(sw)}, h=1,\dots,</code><code>ncomp</code>, where 
superscript <code class="reqn">sw</code> represents a particular sweep. The elements of <code class="reqn">\Sigma_h^{(sw)}</code> are written in the columns of the file.</p>
</td></tr>
<tr><td><code>xih.txt</code></td>
<td>
<p>this file contains samples from the posteriors of parameters  <code class="reqn">\xi_h</code>, <code class="reqn">h=1,2,\dots,</code><code>ncomp</code>. 
The file is arranged in <code>((sweeps-burn)/thin)*ncomp</code> lines and one or two columns, depending on the number of parameters in the 
selected <code>Fcdf</code>. Sweeps write in the file <code>ncomp</code> lines representing samples <code class="reqn">\xi_h^{(sw)}, h=1,\dots,</code><code>ncomp</code>, 
where superscript <code class="reqn">sw</code> represents a particular sweep.</p>
</td></tr>
<tr><td><code>Updated.txt</code></td>
<td>
<p>this file contains <code>(sweeps-burn)/thin</code> lines with the number of components updated at each iteration of the sampler
(relevant for slice sampling).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Georgios Papageorgiou <a href="mailto:gpapageo@gmail.com">gpapageo@gmail.com</a></p>


<h3>References</h3>

<p>Consul, P. C. &amp; Famoye, G. C. (1992). Generalized Poisson regression model. Communications in 
Statistics - Theory and Methods, 1992, 89-109.
</p>
<p>Papageorgiou, G. (2018). Bayesian density regression for discrete outcomes. arXiv:1603.09706v3 [stat.ME]. 
</p>
<p>Papaspiliopoulos, O. (2008). A note on posterior sampling from Dirichlet mixture models. Technical report,
University of Warwick.
</p>
<p>Sethuraman, J. (1994). A constructive definition of Dirichlet priors. Statistica Sinica, 4, 639-650.
</p>
<p>Walker, S. G. (2007). Sampling the Dirichlet mixture model with slices. Communications in Statistics
Simulation and Computation, 36(1), 45-54.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Bayesian nonparametric joint model with binomial response Y and one predictor X
data(simD)
pred&lt;-seq(with(simD,min(X))+0.1,with(simD,max(X))-0.1,length.out=30)
npred&lt;-length(pred)
# fit1 and fit2 define the same model but with different numbers of
# components and posterior samples
fit1 &lt;- dpmj(cbind(Y,(E-Y))~X, Fcdf="binomial", data=simD, ncomp=10, sweeps=20,
             burn=10, sampler="truncated", Xpred=pred, offsetPred=30)
fit2 &lt;- dpmj(cbind(Y,(E-Y))~X, Fcdf="binomial", data=simD, ncomp=50, sweeps=5000,
               burn=1000, sampler="truncated", Xpred=pred, offsetPred=30)
plot(with(simD,X),with(simD,Y)/with(simD,E))
lines(pred,fit2$medianReg/30,col=3,lwd=2)
# with discrete covariate
simD&lt;-data.frame(simD,Xd=sample(c(0,1),300,replace=TRUE))
pred&lt;-c(0,1)
fit3 &lt;- dpmj(cbind(Y,(E-Y))~Xd, Fcdf="binomial", data=simD, ncomp=10, sweeps=20,
             burn=10, sampler="truncated", Xpred=pred, offsetPred=30)
</code></pre>

<hr>
<h2 id='histCorr'>Creates plots of correlation matrices</h2><span id='topic+histCorr'></span>

<h3>Description</h3>

<p>This function plots the posterior distribution of the elements of correlation matrices. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>histCorr(x, term = "R", plotOptions = list(),...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="histCorr_+3A_x">x</code></td>
<td>
<p>an object of class &lsquo;mvrm&rsquo;, as generated by function <code>mvrm</code>.</p>
</td></tr>
<tr><td><code id="histCorr_+3A_term">term</code></td>
<td>
<p>Admits two possible values: &quot;R&quot; to plot samples from the posterior of the correlation matrix <code class="reqn">R</code>, and &quot;muR&quot; to plot samples from the posterior of the means <code class="reqn">\mu_R</code>.</p>
</td></tr>
<tr><td><code id="histCorr_+3A_plotoptions">plotOptions</code></td>
<td>
<p>ggplot type options.</p>
</td></tr>
<tr><td><code id="histCorr_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use this function to visualize the elements of a correlation matrix.</p>


<h3>Value</h3>

<p>Posterior distributions of elements of correlation matrices.</p>


<h3>Author(s)</h3>

<p>Georgios Papageorgiou <a href="mailto:gpapageo@gmail.com">gpapageo@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+mvrm">mvrm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#see \code{mvrm} example</code></pre>

<hr>
<h2 id='lmrm'>Bayesian semiparametric modelling of covariance matrices for multivariate longitudinal data</h2><span id='topic+lmrm'></span>

<h3>Description</h3>

<p>Implements an MCMC algorithm for posterior sampling based on a semiparametric model for
continuous longitudinal multivariate responses. The overall model consists of 5 regression submodels and it
utilizes spike-slab priors for variable selection and function regularization. See &lsquo;Details&rsquo; section for a full description
of the model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmrm(formula, data = list(), centre=TRUE, id, time,
sweeps, burn = 0, thin = 1, seed, StorageDir,
c.betaPrior = "IG(0.5,0.5*n*p)", pi.muPrior = "Beta(1,1)", 
c.alphaPrior = "IG(1.1,1.1)", pi.phiPrior = "Beta(1,1)", c.psiPrior = "HN(2)",
sigmaPrior = "HN(2)", pi.sigmaPrior = "Beta(1,1)", 
corr.Model = c("common", nClust = 1), DP.concPrior = "Gamma(5,2)",
c.etaPrior = "IG(0.5,0.5*samp)", pi.nuPrior = "Beta(1,1)", 
pi.fiPrior = "Beta(1,1)", c.omegaPrior = "IG(1.1,1.1)", sigmaCorPrior = "HN(2)",
tuneCalpha, tuneSigma2, tuneCbeta, tuneAlpha, tuneSigma2R, tuneR, tuneCpsi, 
tuneCbCor, tuneOmega, tuneComega, tau, FT = 1,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lmrm_+3A_formula">formula</code></td>
<td>
<p>a formula defining the responses and the covariates in the 5 regression models e.g. <code>y1 | y2 ~ x | w | z | t | t</code> or
for smooth effects <code>y1 | y2 ~ sm(x) | sm(w) | sm(z) | sm(t) | sm(t)</code>. The package uses the extended formula notation, where the responses are
defined on the left of <code>~</code> and the models on the right.</p>
</td></tr>
<tr><td><code id="lmrm_+3A_data">data</code></td>
<td>
<p>a data frame.</p>
</td></tr>
<tr><td><code id="lmrm_+3A_centre">centre</code></td>
<td>
<p>Binary indicator. If set equal to TRUE, the design matrices are centred, to have column mean equl to zero, otherwise, if set to FALSE, the columns are not centred.</p>
</td></tr>
<tr><td><code id="lmrm_+3A_id">id</code></td>
<td>
<p>identifiers of the individuals or other sampling units that are observed over time.</p>
</td></tr>
<tr><td><code id="lmrm_+3A_time">time</code></td>
<td>
<p>a vector input that specifies the time of observation</p>
</td></tr>
<tr><td><code id="lmrm_+3A_sweeps">sweeps</code></td>
<td>
<p>total number of posterior samples, including those discarded in burn-in period
(see argument <code>burn</code>) and those discarded by the thinning process
(see argument <code>thin</code>).</p>
</td></tr>
<tr><td><code id="lmrm_+3A_burn">burn</code></td>
<td>
<p>length of burn-in period.</p>
</td></tr>
<tr><td><code id="lmrm_+3A_thin">thin</code></td>
<td>
<p>thinning parameter.</p>
</td></tr>
<tr><td><code id="lmrm_+3A_seed">seed</code></td>
<td>
<p>optional seed for the random generator.</p>
</td></tr>
<tr><td><code id="lmrm_+3A_storagedir">StorageDir</code></td>
<td>
<p>a required directory to store files with the posterior samples of models parameters.</p>
</td></tr>
<tr><td><code id="lmrm_+3A_c.betaprior">c.betaPrior</code></td>
<td>
<p>The inverse Gamma prior of <code class="reqn">c_{\beta}</code>.
The default is &quot;IG(0.5,0.5*n*p)&quot;, that is, an inverse Gamma with parameters <code class="reqn">1/2</code> and
<code class="reqn">np/2</code>, where <code class="reqn">n</code> is the number of sampling units and <code class="reqn">p</code> is the length of the response vector.</p>
</td></tr>
<tr><td><code id="lmrm_+3A_pi.muprior">pi.muPrior</code></td>
<td>
<p>The Beta prior of <code class="reqn">\pi_{\mu}</code>.
The default is &quot;Beta(1,1)&quot;. It can be of dimension <code class="reqn">1</code>, of dimension <code class="reqn">K</code> (the number of effects that enter the mean model),
or of dimension <code class="reqn">p K</code></p>
</td></tr>
<tr><td><code id="lmrm_+3A_c.alphaprior">c.alphaPrior</code></td>
<td>
<p>The inverse Gamma prior of <code class="reqn">c_{\alpha}^2</code>.
The default is &quot;IG(1.1,1.1)&quot;. Half-normal priors for <code class="reqn">c_{\alpha}</code> are also available, declared using &quot;HN(a)&quot;, where &quot;a&quot;
is a positive number. It can be of dimension <code class="reqn">1</code> or <code class="reqn">p</code> (the length of the multivariate response).</p>
</td></tr>
<tr><td><code id="lmrm_+3A_pi.phiprior">pi.phiPrior</code></td>
<td>
<p>The Beta prior of <code class="reqn">\pi_{\phi}</code>.
The default is &quot;Beta(1,1)&quot;. It can be of dimension <code class="reqn">1</code>, of dimension <code class="reqn">B</code> (the number of effects that enter the dependence model), or of dimension <code class="reqn">p^2 B</code></p>
</td></tr>
<tr><td><code id="lmrm_+3A_c.psiprior">c.psiPrior</code></td>
<td>
<p>The prior of <code class="reqn">c_{\psi}^2</code>.
The default is &quot;HN(2)&quot;, a half-normal prior for <code class="reqn">c_{\psi}</code> with variance equal to two,
<code class="reqn">c_{\psi} \sim N(0,2) I[c_{\psi} &gt; 0]</code>. Inverse Gamma priors for <code class="reqn">c_{\psi}^2</code> are also available,
declared using &quot;IG(a,b)&quot;. It can be of dimension <code class="reqn">1</code> or <code class="reqn">p^2</code> (the number of dependence models).</p>
</td></tr>
<tr><td><code id="lmrm_+3A_sigmaprior">sigmaPrior</code></td>
<td>
<p>The prior of <code class="reqn">\sigma_k^2, k=1,\dots,p</code>.
The default is &quot;HN(2)&quot;, a half-normal prior for <code class="reqn">\sigma_k</code> with variance equal to two,
<code class="reqn">\sigma_k \sim N(0,2) I[\sigma&gt;0]</code>. Inverse Gamma priors for <code class="reqn">\sigma_k^2</code> are also available,
declared using &quot;IG(a,b)&quot;. It can be of dimension <code class="reqn">1</code> or <code class="reqn">p</code> (the length of the multivariate response).</p>
</td></tr>
<tr><td><code id="lmrm_+3A_pi.sigmaprior">pi.sigmaPrior</code></td>
<td>
<p>The Beta prior of <code class="reqn">\pi_{\sigma}</code>.
The default is &quot;Beta(1,1)&quot;. It can be of dimension <code class="reqn">1</code>, of dimension <code class="reqn">L</code> (the number of effects that enter the variance model), or of dimension <code class="reqn">pL</code></p>
</td></tr>
<tr><td><code id="lmrm_+3A_corr.model">corr.Model</code></td>
<td>
<p>Specifies the model for the correlation matrices <code class="reqn">R_t</code>.
The three choices supported are &quot;common&quot;, that specifies a common correlations model,
&quot;groupC&quot;, that specifies a grouped correlations model, and &quot;groupV&quot;, that specifies
a grouped variables model. When the model chosen is either &quot;groupC&quot; or &quot;groupV&quot;, the upper
limit on the number of clusters can also be specified, using corr.Model = c(&quot;groupC&quot;, nClust = d)
or corr.Model = c(&quot;groupV&quot;, nClust = p). If the number of clusters is left unspecified,
for the &quot;groupV&quot; model, it is taken to be <code class="reqn">p</code>, the number of responses.
For the &quot;groupC&quot; model, it is taken to be <code class="reqn">d = p(p-1)/2</code>, the number of free elements in the correlation matrices.</p>
</td></tr>
<tr><td><code id="lmrm_+3A_dp.concprior">DP.concPrior</code></td>
<td>
<p>The Gamma prior for the Dirichlet process concentration parameter.</p>
</td></tr>
<tr><td><code id="lmrm_+3A_c.etaprior">c.etaPrior</code></td>
<td>
<p>The inverse Gamma prior of <code class="reqn">c_{\eta}</code>.
The default is &quot;IG(0.5,0.5*samp)&quot;, that is, an inverse Gamma with parameters <code class="reqn">1/2</code> and
<code class="reqn">samp/2</code>, where <code class="reqn">samp</code> is the number of correlations observed over time, that is $samp=M*d$ 
where $M$ is the number of unique observation time points and $d$ is the number of non-redundant elements 
of $R$.</p>
</td></tr>
<tr><td><code id="lmrm_+3A_pi.nuprior">pi.nuPrior</code></td>
<td>
<p>The Beta prior of <code class="reqn">\pi_{\nu}</code>. The default is &quot;Beta(1,1)&quot;. It can be of dimension <code class="reqn">1</code>.</p>
</td></tr>
<tr><td><code id="lmrm_+3A_pi.fiprior">pi.fiPrior</code></td>
<td>
<p>The Beta prior of <code class="reqn">\pi_{\varphi}</code>. The default is &quot;Beta(1,1)&quot;. It can be of dimension <code class="reqn">1</code>.</p>
</td></tr>
<tr><td><code id="lmrm_+3A_c.omegaprior">c.omegaPrior</code></td>
<td>
<p>The prior of <code class="reqn">c_{\omega}^2</code>.
The default is &quot;HN(2)&quot;, a half-normal prior for <code class="reqn">c_{\omega}</code> with variance equal to two,
<code class="reqn">c_{\omega} \sim N(0,2) I[c_{\omega} &gt; 0]</code>. Inverse Gamma priors for <code class="reqn">c_{\omega}^2</code> are also available,
declared using &quot;IG(a,b)&quot;. It can be of dimension <code class="reqn">1</code>.</p>
</td></tr>
<tr><td><code id="lmrm_+3A_sigmacorprior">sigmaCorPrior</code></td>
<td>
<p>The prior of <code class="reqn">\sigma^2</code>.
The default is &quot;HN(2)&quot;, a half-normal prior for <code class="reqn">\sigma^2</code> with variance equal to two,
<code class="reqn">\sigma \sim N(0,2) I[\sigma &gt; 0]</code>. Inverse Gamma priors for <code class="reqn">\sigma^2</code> are also available,
declared using &quot;IG(a,b)&quot;. It can be of dimension <code class="reqn">1</code>.</p>
</td></tr>
<tr><td><code id="lmrm_+3A_tunecalpha">tuneCalpha</code></td>
<td>
<p>Starting value of the tuning parameter for sampling <code class="reqn">c_{\alpha k}, k=1,\dots,p</code>.
Defaults at a vector of $p$ ones. It could be of dimension <code class="reqn">p</code>.</p>
</td></tr>
<tr><td><code id="lmrm_+3A_tunesigma2">tuneSigma2</code></td>
<td>
<p>Starting value of the tuning parameter for sampling <code class="reqn">\sigma^2_k, k=1,\dots,p</code>.
Defaults at a vector of $p$ ones. It could be of dimension <code class="reqn">p</code>.</p>
</td></tr>
<tr><td><code id="lmrm_+3A_tunecbeta">tuneCbeta</code></td>
<td>
<p>Starting value of the tuning parameter for sampling <code class="reqn">c_{\beta}</code>.
Defaults at 100.</p>
</td></tr>
<tr><td><code id="lmrm_+3A_tunealpha">tuneAlpha</code></td>
<td>
<p>Starting value of the tuning parameter for sampling regression coefficients of the variance models
<code class="reqn">\alpha_k, k=1,\dots,p</code>. Defaults at a vector of 5s. It could be of dimension <code class="reqn">L p</code></p>
</td></tr>
<tr><td><code id="lmrm_+3A_tunesigma2r">tuneSigma2R</code></td>
<td>
<p>Starting value of the tuning parameter for sampling <code class="reqn">\sigma^2</code>.
Defaults at 1.</p>
</td></tr>
<tr><td><code id="lmrm_+3A_tuner">tuneR</code></td>
<td>
<p>Starting value of the tuning parameter for sampling correlation matrices.
Defaults at <code class="reqn">40*(p+2)^3</code>. Can be of dimension <code class="reqn">1</code> or <code class="reqn">M</code> is the number of unique observation time points.</p>
</td></tr>
<tr><td><code id="lmrm_+3A_tunecpsi">tuneCpsi</code></td>
<td>
<p>Starting value of the tuning parameter for sampling variances <code class="reqn">c_{\psi}^2</code>.
Defaults at 5. Can be of dimension <code class="reqn">1</code> or <code class="reqn">p^2</code></p>
</td></tr></table>
<p>.
</p>
<table role = "presentation">
<tr><td><code id="lmrm_+3A_tunecbcor">tuneCbCor</code></td>
<td>
<p>Starting value of the tuning parameter for sampling <code class="reqn">c_{\eta}^2</code>.
Defaults at 10.</p>
</td></tr>
<tr><td><code id="lmrm_+3A_tuneomega">tuneOmega</code></td>
<td>
<p>Starting value of the tuning parameter for sampling regression coefficients of the variance models
<code class="reqn">\omega</code>. Defaults at 5.</p>
</td></tr>
<tr><td><code id="lmrm_+3A_tunecomega">tuneComega</code></td>
<td>
<p>Starting value of the tuning parameter for sampling <code class="reqn">c_{\omega}</code>.
Defaults at 1.</p>
</td></tr>
<tr><td><code id="lmrm_+3A_tau">tau</code></td>
<td>
<p>The <code class="reqn">tau</code> of the shadow prior. Defaults at 0.01.</p>
</td></tr>
<tr><td><code id="lmrm_+3A_ft">FT</code></td>
<td>
<p>Binary indicator. If set equal to 1, the Fisher's z transform of the correlations is modelled, otherwise if set equal to 0, the untransformed correlations are modelled.</p>
</td></tr>
<tr><td><code id="lmrm_+3A_...">...</code></td>
<td>
<p>Other options that will be ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>lmrm</code> returns samples from the posterior distributions of the parameters of
a regression model with normally distributed multivariate longitudinal responses. To describe the model, 
let <code class="reqn">Y_{ij} = (Y_{ij1},\dots,Y_{ijp})^{\top}</code> denote the vector of <code class="reqn">p</code> responses
observed on individual <code class="reqn">i, i=1,\dots,n,</code> at time point <code class="reqn">t_{ij}, j=1,\dots,n_i</code>. 
The observational time points <code class="reqn">t_{ij}</code> are allowed to be unequally spaced. 
Further, let <code class="reqn">u_{ij}</code> denote the covariate vector that is observed along with <code class="reqn">Y_{ij}</code> and that may include time, 
other time-dependent covariates and time-independent ones. 
In addition, let <code class="reqn">Y_{i}=(Y_{i1}^{\top},\dots,Y_{in_i}^{\top})^{\top}</code> denote the <code class="reqn">i</code>th response vector. 
With <code class="reqn">\mu_i=E(Y_{i})</code> and <code class="reqn">\Sigma_i = </code> cov<code class="reqn">(Y_i)</code>, the model assumes multivariate normality,
<code class="reqn">Y_{i} \sim N(\mu_i, \Sigma_i), i=1,2,\dots,n</code>.
The means <code class="reqn">\mu_i</code> and covariance matrices <code class="reqn">\Sigma_i</code> are modelled semiparametrically in terms of covariates.    
For the means one can specify semiparametric models, 
</p>
<p style="text-align: center;"><code class="reqn">\mu_{ijk} = \beta_{k0} + \sum_{l=1}^{K_1} u_{ijl} \beta_{kl} + \sum_{l=K_1+1}^{K} f_{\mu,k,l}(u_{ijl}).</code>
</p>

<p>This is the first of the 5 regression submodels. 
</p>
<p>To model the covariance matrix, first consider the modified Cholesky decomposition, 
<code class="reqn">L_i \Sigma_i L_i^{\top} = D_i,</code> where <code class="reqn">L_i</code> is a unit block lower triangular matrix 
and <code class="reqn">D_i</code> is a block diagonal matrix, 
</p>
<p style="text-align: center;"><code class="reqn">
    	\begin{array}{cc}
    		L_i 
    		= \left[ \begin{array}{cccc}
    			I &amp; 0 &amp; \dots &amp; 0 \\ 
    			-\Phi_{i21} &amp; I &amp; \dots &amp; 0 \\ 
    			\vdots &amp; \vdots &amp; \ddots &amp; \vdots  \\
    			-\Phi_{in_i1} &amp; -\Phi_{in_i1} &amp; \dots &amp; I \\ 
    		\end{array}
    		\right],
    		&amp;
    		D_i 
    		= \left[ \begin{array}{cccc}
    			D_{1} &amp; 0 &amp; \dots &amp; 0 \\ 
    			0 &amp; D_{2} &amp; 0 &amp; 0 \\ 
    			\vdots &amp; \vdots &amp; \ddots &amp; \vdots  \\
    			0 &amp; 0 &amp; 0 &amp; D_{n_i} \\ 
    		\end{array}
    		\right],
    	\end{array}
    </code>
</p>

<p>For modelling <code class="reqn">D_{ij}, i=1,\dots,n, j=1,\dots,n_i</code> in terms of covariates,   
first we separate the variances and the correlations <code class="reqn">D_{ij} = S_{ij}^{1/2} R_{ij} S_{ij}^{1/2}</code>.
It is easy to model matrix <code class="reqn">S_{ij}</code> in terms of covariates as the only requirement on its diagonal 
elements is that they are nonnegative, 
</p>
<p style="text-align: center;"><code class="reqn">\log \sigma^2_{ijk} = \alpha_{k0} + \sum_{l=1}^{L_1} w_{ijl} \alpha_{kl} + \sum_{l=L_1+1}^{L} f_{\sigma,k,l}(w_{ijl})</code>
</p>

<p>This is the second of the 5 regression submodels. 
</p>
<p>For <code class="reqn">\phi_{ijklm}</code>, the <code class="reqn">(l,m)</code> element of <code class="reqn">\Phi_{ijk}, l,m=1,\dots,p</code>, one can specify semiparametric models
</p>
<p style="text-align: center;"><code class="reqn">
     \phi_{ijklm} = \psi_{lm0} + \sum_{b=1}^{B_1} v_{ijkb} \psi_{lmb} + \sum_{b=B_1+1}^{B} f_{\phi,l,m,b}(v_{ijkb}) 
    </code>
</p>

<p>This is the third of the 5 regression submodels. 
</p>
<p>The elements of the correlations matrices <code class="reqn">R_{ij}</code> are modelled in terms of covariate time only, hence they are denoted by <code class="reqn">R_t</code>. 
Subject to the positive definiteness constraint, the elements of <code class="reqn">R_t</code> are modelled using a normal distribution
with location and scale parameters, <code class="reqn">\mu_{ct}</code> and <code class="reqn">\sigma^2_{ct}</code>, modelled as     
</p>
<p style="text-align: center;"><code class="reqn">
     \mu_{ct} = \eta_0 + f_{\mu}(t), 
    </code>
</p>

<p style="text-align: center;"><code class="reqn"> 
      \log \sigma^2_{ct} = \omega_0 + f_{\sigma}(t), 
    </code>
</p>

<p>and these are the last 2 of the 5 submodels. 
</p>


<h3>Value</h3>

<p>Function <code>lmrm</code> returns samples from the posteriors of the model parameters.</p>


<h3>Author(s)</h3>

<p>Georgios Papageorgiou <a href="mailto:gpapageo@gmail.com">gpapageo@gmail.com</a></p>


<h3>References</h3>

<p>Papageorgiou, G. (2020). Bayesian semiparametric modelling of covariance matrices for multivariate longitudinal data. arXiv:2012.09833.</p>


<h3>Examples</h3>

<pre><code class='language-R'>	# Fit a joint mean-covariance model on the simulated dataset simD2
	require(ggplot2)
	data(simD2)
	model &lt;- Y1 | Y2 ~ time | sm(time) | sm(lag) | sm(time) | 1 
	# the above defines the responses and the regression models on the left and 
	# right of "~", respectively 
	# the first model, for the mean, is a linear function of time, this is sufficient as 
	# the 2 responses have constant mean.
	# the second model, for the variances, is a smooth function of time
	# the third model, for the dependence structure, is a smooth function of lag, 
	# that lmrm figures out and it does not need to be computed by the user
	# the fourth model, for location of the correlations, is a smooth function of time
	# the fifth model, for scale of the correlations, is just an intercept model
	## Not run: 
	m1 &lt;- lmrm(formula = model, corr.Model = c("common", nClust = 1), data = simD2,
		       id = id, time = time, sweeps = 2500, burn = 500, thin = 2, 
		       StorageDir = getwd(), seed = 1)
	plot(m1)
	
## End(Not run)
</code></pre>

<hr>
<h2 id='mvrm'>Bayesian semiparametric analysis of multivariate continuous responses, with variable selection</h2><span id='topic+mvrm'></span>

<h3>Description</h3>

<p>Implements an MCMC algorithm for posterior sampling based on a semiparametric model for
continuous multivariate responses and additive models for the mean and variance  functions. The model
utilizes spike-slab priors for variable selection and regularization. See &lsquo;Details&rsquo; section for a full description
of the model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvrm(formula, distribution = "normal", data = list(), centre = TRUE, sweeps, 
burn = 0, thin = 1, seed, StorageDir, c.betaPrior = "IG(0.5, 0.5 * n * p)", 
pi.muPrior = "Beta(1, 1)", c.alphaPrior = "IG(1.1, 1.1)", sigmaPrior = "HN(2)", 
pi.sigmaPrior = "Beta(1, 1)", c.psiPrior = "HN(1)", phiPrior = "HN(2)", 
pi.omegaPrior = "Beta(1, 1)", mu.RPrior = "N(0, 1)", sigma.RPrior = "HN(1)", 
corr.Model = c("common", nClust = 1), DP.concPrior = "Gamma(5, 2)", 
breaksPrior = "SBeta(1, 2)", tuneCbeta, tuneCalpha, tuneAlpha, tuneSigma2, 
tuneCpsi, tunePsi, tunePhi, tuneR, tuneSigma2R, tuneHar, tuneBreaks, tunePeriod, tau, 
FT = 1, compDeviance = FALSE, ...) </code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvrm_+3A_formula">formula</code></td>
<td>
<p>a formula defining the responses and the covariates in the mean and variance models e.g. <code>y1 | y2 ~ x | z</code> or
for smooth effects <code>y1 | y2 ~ sm(x) | sm(z)</code>. The package uses the extended formula notation, where the responses are
defined on the left of <code>~</code> and the mean and variance models on the right.</p>
</td></tr>
<tr><td><code id="mvrm_+3A_distribution">distribution</code></td>
<td>
<p>The distribution for the response variables. Currently two options are supported: &quot;normal&quot; and &quot;t&quot;.</p>
</td></tr>
<tr><td><code id="mvrm_+3A_data">data</code></td>
<td>
<p>a data frame.</p>
</td></tr>
<tr><td><code id="mvrm_+3A_centre">centre</code></td>
<td>
<p>Binary indicator. If set equal to TRUE, the design matrices are centred, to have column mean equl to zero, otherwise, if set to FALSE, the columns are not centred.</p>
</td></tr>
<tr><td><code id="mvrm_+3A_sweeps">sweeps</code></td>
<td>
<p>total number of posterior samples, including those discarded in burn-in period
(see argument <code>burn</code>) and those discarded by the thinning process
(see argument <code>thin</code>).</p>
</td></tr>
<tr><td><code id="mvrm_+3A_burn">burn</code></td>
<td>
<p>length of burn-in period.</p>
</td></tr>
<tr><td><code id="mvrm_+3A_thin">thin</code></td>
<td>
<p>thinning parameter.</p>
</td></tr>
<tr><td><code id="mvrm_+3A_seed">seed</code></td>
<td>
<p>optional seed for the random generator.</p>
</td></tr>
<tr><td><code id="mvrm_+3A_storagedir">StorageDir</code></td>
<td>
<p>a required directory to store files with the posterior samples of models parameters.</p>
</td></tr>
<tr><td><code id="mvrm_+3A_c.betaprior">c.betaPrior</code></td>
<td>
<p>The inverse Gamma prior of <code class="reqn">c_{\beta}</code>.
The default is &quot;IG(0.5,0.5*n*p)&quot;, that is, an inverse Gamma with parameters <code class="reqn">1/2</code> and
<code class="reqn">np/2</code>, where <code class="reqn">n</code> is the number of sampling units and <code class="reqn">p</code> is the length of the response vector.</p>
</td></tr>
<tr><td><code id="mvrm_+3A_pi.muprior">pi.muPrior</code></td>
<td>
<p>The Beta prior of <code class="reqn">\pi_{\mu}</code>.
The default is &quot;Beta(1,1)&quot;. It can be of dimension <code class="reqn">1</code>, of dimension <code class="reqn">K</code> (the number of effects that enter the mean model),
or of dimension <code class="reqn">pK</code></p>
</td></tr>
<tr><td><code id="mvrm_+3A_c.alphaprior">c.alphaPrior</code></td>
<td>
<p>The prior of <code class="reqn">c_{\alpha}</code>.
The default is &quot;IG(1.1,1.1)&quot;. Half-normal priors for <code class="reqn">\sqrt{c_{\alpha}}</code> are also available, declared using &quot;HN(a)&quot;, where &quot;a&quot;
is a positive number. It can be of dimension <code class="reqn">1</code> or <code class="reqn">p</code> (the length of the multivariate response).</p>
</td></tr>
<tr><td><code id="mvrm_+3A_sigmaprior">sigmaPrior</code></td>
<td>
<p>The prior of <code class="reqn">\sigma</code>.
The default is &quot;HN(2)&quot;, a half-normal prior for <code class="reqn">\sigma</code> with variance equal to two,
<code class="reqn">\sigma \sim N(0,2) I[\sigma&gt;0]</code>. Inverse Gamma priors for <code class="reqn">\sigma^2</code> are also available,
declared using &quot;IG(a,b)&quot;. It can be of dimension <code class="reqn">1</code> or <code class="reqn">p</code> (the length of the multivariate response).</p>
</td></tr>
<tr><td><code id="mvrm_+3A_pi.sigmaprior">pi.sigmaPrior</code></td>
<td>
<p>The Beta prior of <code class="reqn">\pi_{\sigma}</code>.
The default is &quot;Beta(1,1)&quot;. It can be of dimension <code class="reqn">1</code>, of dimension <code class="reqn">Q</code> (the number of effects that enter the variance model), or of dimension <code class="reqn">pQ</code></p>
</td></tr>
<tr><td><code id="mvrm_+3A_c.psiprior">c.psiPrior</code></td>
<td>
<p>The prior of <code class="reqn">c_{\psi}</code>.
The default is half-normal for <code class="reqn">\sqrt{c_{\psi}}</code>, declared using &quot;HN(a)&quot;, where &quot;a&quot;
is a positive number. The default value for &quot;a&quot; is one. Inverse-gamma priors are also available 
and they can be declared using &quot;IG(a,b)&quot;, where &quot;a&quot; and &quot;b&quot; are positive constants. The prior can 
be of dimension <code class="reqn">1</code> or <code class="reqn">p</code> (the length of the multivariate response).</p>
</td></tr>
<tr><td><code id="mvrm_+3A_phiprior">phiPrior</code></td>
<td>
<p>The prior of <code class="reqn">varphi^2</code>.
The default is half-normal for <code class="reqn">varphi</code>, declared using &quot;HN(a)&quot;, where &quot;a&quot;
is a positive number. The default value for &quot;a&quot; is two. Inverse-gamma priors are also available 
and they can be declared using &quot;IG(a,b)&quot;, where &quot;a&quot; and &quot;b&quot; are positive constants. The prior can 
be of dimension <code class="reqn">1</code> or <code class="reqn">p</code> (the length of the multivariate response).</p>
</td></tr>
<tr><td><code id="mvrm_+3A_pi.omegaprior">pi.omegaPrior</code></td>
<td>
<p>The Beta prior of <code class="reqn">\pi_{\omega}</code>.
The default is &quot;Beta(1,1)&quot;. It can be of dimension <code class="reqn">1</code>, of dimension <code class="reqn">B</code> (the number of effects that enter the shape parameter model), or of dimension <code class="reqn">pB</code></p>
</td></tr>
<tr><td><code id="mvrm_+3A_mu.rprior">mu.RPrior</code></td>
<td>
<p>The normal prior for <code class="reqn">\mu_{R}</code>.
The default is the standard normal distribution.</p>
</td></tr>
<tr><td><code id="mvrm_+3A_sigma.rprior">sigma.RPrior</code></td>
<td>
<p>The half normal prior for <code class="reqn">\sigma_{R}</code>.
The default is the half normal distribution with variance one.</p>
</td></tr>
<tr><td><code id="mvrm_+3A_corr.model">corr.Model</code></td>
<td>
<p>Specifies the model for the correlation matrix <code class="reqn">R</code>.
The three choices supported are &quot;common&quot;, that specifies a common correlations model,
&quot;groupC&quot;, that specifies a grouped correlations model, and &quot;groupV&quot;, that specifies
a grouped variables model. When the model chosen is either &quot;groupC&quot; or &quot;groupV&quot;, the upper
limit on the number of clusters can also be specified, using corr.Model = c(&quot;groupC&quot;, nClust = d)
or corr.Model = c(&quot;groupV&quot;, nClust = p). If the number of clusters is left unspecified,
for the &quot;groupV&quot; model, it is taken to be <code class="reqn">p</code>, the number of responses.
For the &quot;groupC&quot; model, it is taken to be <code class="reqn">d = p(p-1)/2</code>, the number of free elements in the correlation matrix.</p>
</td></tr>
<tr><td><code id="mvrm_+3A_dp.concprior">DP.concPrior</code></td>
<td>
<p>The Gamma prior for the Dirichlet process concentration parameter.</p>
</td></tr>
<tr><td><code id="mvrm_+3A_breaksprior">breaksPrior</code></td>
<td>
<p>The prior for the shifts associated with the growth break points. The shift is taken to have 
a scaled Beta prior with support the (0, p) interval, where p is the period of the sin curve. The default SBeta(1, 2)
is a scaled Beta(1, 2) distribution supported in the (0, p) interval. The shifts are in increasing order.</p>
</td></tr>
<tr><td><code id="mvrm_+3A_tunecbeta">tuneCbeta</code></td>
<td>
<p>Starting value of the tuning parameter for sampling <code class="reqn">c_{\beta}</code>.
Defaults at 20.</p>
</td></tr>
<tr><td><code id="mvrm_+3A_tunecalpha">tuneCalpha</code></td>
<td>
<p>Starting value of the tuning parameter for sampling <code class="reqn">c_{\alpha}</code>.
Defaults at 1.</p>
</td></tr>
<tr><td><code id="mvrm_+3A_tunealpha">tuneAlpha</code></td>
<td>
<p>Starting value of the tuning parameter for sampling regression coefficients of the variance model
<code class="reqn">\alpha</code>. Defaults at 5.</p>
</td></tr>
<tr><td><code id="mvrm_+3A_tunesigma2">tuneSigma2</code></td>
<td>
<p>Starting value of the tuning parameter for sampling variances <code class="reqn">\sigma^2_j</code>.
Defaults at 1.</p>
</td></tr>
<tr><td><code id="mvrm_+3A_tunecpsi">tuneCpsi</code></td>
<td>
<p>Starting value of the tuning parameter for sampling <code class="reqn">c_{\psi}</code>.
Defaults at 1.</p>
</td></tr>
<tr><td><code id="mvrm_+3A_tunepsi">tunePsi</code></td>
<td>
<p>Starting value of the tuning parameter for sampling <code class="reqn">\psi</code>.
Defaults at 5.</p>
</td></tr>
<tr><td><code id="mvrm_+3A_tunephi">tunePhi</code></td>
<td>
<p>Starting value of the tuning parameter for sampling <code class="reqn">\varphi</code>.
Defaults at 0.5.</p>
</td></tr>
<tr><td><code id="mvrm_+3A_tuner">tuneR</code></td>
<td>
<p>Starting value of the tuning parameter for sampling correlation matrices.
Defaults at <code class="reqn">40*(p+2)^3</code>.</p>
</td></tr>
<tr><td><code id="mvrm_+3A_tunesigma2r">tuneSigma2R</code></td>
<td>
<p>Starting value of the tuning parameter for sampling <code class="reqn">\sigma_{R}^2</code>.
Defaults at 1.</p>
</td></tr>
<tr><td><code id="mvrm_+3A_tunehar">tuneHar</code></td>
<td>
<p>Starting value of the tuning parameter for sampling the regression coefficients of
the harmonics. Defaults at 100.</p>
</td></tr>
<tr><td><code id="mvrm_+3A_tunebreaks">tuneBreaks</code></td>
<td>
<p>Starting value of the tuning parameter for sampling the shift parameters associated with 
growth breaks. Defaults at 0.01 times the period of the sin wave.</p>
</td></tr>
<tr><td><code id="mvrm_+3A_tuneperiod">tunePeriod</code></td>
<td>
<p>Starting value of the tuning parameter for sampling the period parameter of the sin curve. 
Defaults to 0.01.</p>
</td></tr>
<tr><td><code id="mvrm_+3A_tau">tau</code></td>
<td>
<p>The <code class="reqn">tau</code> of the shadow prior. Defaults at 0.01.</p>
</td></tr>
<tr><td><code id="mvrm_+3A_ft">FT</code></td>
<td>
<p>Binary indicator. If set equal to 1, the Fisher's z transform of the correlations is modelled, otherwise if set equal to 0, the untransformed correlations are modelled.</p>
</td></tr>
<tr><td><code id="mvrm_+3A_compdeviance">compDeviance</code></td>
<td>
<p>Binary indicator. If set equal to 1, the deviance is computed.</p>
</td></tr>
<tr><td><code id="mvrm_+3A_...">...</code></td>
<td>
<p>Other options that will be ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>mvrm</code> returns samples from the posterior distributions of the parameters of
a regression model with normally distributed multivariate responses and mean and variance functions modeled
in terms of covariates. For instance, in the presence of two responses (<code class="reqn">y_1, y_2</code>) and two covariates
in the mean model (<code class="reqn">u_1, u_2</code>) and two in the variance model (<code class="reqn">w_1, w_2</code>), we may choose to fit
</p>
<p style="text-align: center;"><code class="reqn">
\mu_u = \beta_0 + \beta_1 u_1 + f_{\mu}(u_2),</code>
</p>

<p style="text-align: center;"><code class="reqn">
\log(\sigma^2_W) = \alpha_0 + \alpha_1 w_1 + f_{\sigma}(w_2),</code>
</p>

<p>parametrically modelling the effects of <code class="reqn">u_1</code> and <code class="reqn">w_1</code> and non-parametrically modelling
the effects of <code class="reqn">u_2</code> and <code class="reqn">w_2</code>. Smooth functions, such as <code class="reqn">f_{\mu}</code>
and <code class="reqn">f_{\sigma}</code>, are represented by basis function expansion,
</p>
<p style="text-align: center;"><code class="reqn">
f_{\mu}(u_2) = \sum_{j} \beta_{j} \phi_{j}(u_2),
</code>
</p>

<p style="text-align: center;"><code class="reqn">
f_{\sigma}(w_2) = \sum_{j} \alpha_{j} \phi_{j}(w_2),
</code>
</p>

<p>where <code class="reqn">\phi</code> are the basis functions and <code class="reqn">\beta</code> and <code class="reqn">\alpha</code> are regression coefficients.
</p>
<p>The variance model can equivalently be expressed as
</p>
<p style="text-align: center;"><code class="reqn">
\sigma^2_W = \exp(\alpha_0) \exp(\alpha_1 w_1 + f_{\sigma}(w_2)) = \sigma^2 \exp(\alpha_1 w_1 + f_{\sigma}(w_2)),</code>
</p>

<p>where <code class="reqn">\sigma^2 = \exp(\alpha_0)</code>. This is the parameterization that we adopt in this implementation.
</p>
<p>Positive prior probability that the regression coefficients in the mean model are exactly
zero is achieved by defining binary variables <code class="reqn">\gamma</code> that take value <code class="reqn">\gamma=1</code>
if the associated coefficient <code class="reqn">\beta \neq 0</code> and <code class="reqn">\gamma = 0</code> if <code class="reqn">\beta = 0</code>.
Indicators <code class="reqn">\delta</code> that take value <code class="reqn">\delta=1</code> if the associated coefficient
<code class="reqn">\alpha \neq 0</code> and <code class="reqn">\delta = 0</code> if <code class="reqn">\alpha = 0</code> for the variance function
are defined analogously. We note that all coefficients in the mean and variance functions are
subject to selection except the intercepts, <code class="reqn">\beta_0</code> and <code class="reqn">\alpha_0</code>.
</p>
<p><em>Prior specification:</em>
</p>
<p>For the vector of non-zero regression coefficients <code class="reqn">\beta_{\gamma}</code> we specify a g-prior
</p>
<p style="text-align: center;"><code class="reqn">
\beta_{\gamma} | c_{\beta}, \sigma^2, \gamma, \alpha, \delta \sim N(0,c_{\beta} \sigma^2
(\tilde{X}_{\gamma}^{\top} \tilde{X}_{\gamma} )^{-1}).
</code>
</p>

<p>where <code class="reqn">\tilde{X}</code> is a scaled version of design matrix <code class="reqn">X</code> of the mean model.
</p>
<p>For the vector of non-zero regression coefficients <code class="reqn">\alpha_{\delta}</code> we specify a normal prior
</p>
<p style="text-align: center;"><code class="reqn">
\alpha_{\delta} | c_{\alpha}, \delta \sim N(0,c_{\alpha} I).
</code>
</p>

<p>Independent priors are specified for the indicators variables <code class="reqn">\gamma</code> and <code class="reqn">\delta</code> as
<code class="reqn">P(\gamma = 1 | \pi_{\mu}) = \pi_{\mu}</code> and
<code class="reqn">P(\delta = 1 | \pi_{\sigma}) = \pi_{\sigma}</code>.
Further, Beta priors are specified for <code class="reqn">\pi_{\mu}</code> and <code class="reqn">\pi_{\sigma}</code>
</p>
<p style="text-align: center;"><code class="reqn">
\pi_{\mu} \sim Beta(c_{\mu},d_{\mu}), \pi_{\sigma} \sim Beta(c_{\sigma},d_{\sigma}).
</code>
</p>

<p>We note that blocks of regression coefficients associated with distinct covariate effects
have their own probability of selection (<code class="reqn">\pi_{\mu}</code> or <code class="reqn">\pi_{\sigma}</code>)
and this probability has its own prior distribution.
</p>
<p>Further, we specify inverse Gamma priors for <code class="reqn">c_{\beta}</code> and <code class="reqn">c_{\alpha}</code>
</p>
<p style="text-align: center;"><code class="reqn">
c_{\beta} \sim IG(a_{\beta},b_{\beta}),
c_{\alpha} \sim IG(a_{\alpha},b_{\alpha})</code>
</p>

<p>For <code class="reqn">\sigma^2</code> we consider inverse Gamma and half-normal priors
</p>
<p style="text-align: center;"><code class="reqn">
\sigma^2 \sim IG(a_{\sigma},b_{\sigma}), |\sigma| \sim N(0,\phi^2_{\sigma}).
</code>
</p>

<p>Lastly, for the elements of the correlation matrix, we specify normal distributions with mean <code class="reqn">\mu_R</code> and variance <code class="reqn">\sigma^2_R</code>,
with the priors on these two parameters being normal and half-normal, respectively. This is the common correlations model. Further, 
the grouped correlations model can be specified. It considers a mixture of normal distributions for the means <code class="reqn">\mu_R</code>. The grouped correlations model can also be specified. It clusters the variables instead of the correlations.  
</p>


<h3>Value</h3>

<p>Function <code>mvrm</code> returns the following:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>model formula.</p>
</td></tr>
<tr><td><code>seed</code></td>
<td>
<p>the seed that was used (in case replication of the results is needed).</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>the dataset</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>the mean model design matrix.</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>the variance model design matrix.</p>
</td></tr>
<tr><td><code>LG</code></td>
<td>
<p>the length of the vector of indicators <code class="reqn">\gamma</code>.</p>
</td></tr>
<tr><td><code>LD</code></td>
<td>
<p>the length of the vector of indicators <code class="reqn">\delta</code>.</p>
</td></tr>
<tr><td><code>mcpar</code></td>
<td>
<p>the MCMC parameters: length of burn in period, total number of samples, thinning period.</p>
</td></tr>
<tr><td><code>nSamples</code></td>
<td>
<p>total number of posterior samples</p>
</td></tr>
<tr><td><code>DIR</code></td>
<td>
<p>the storage directory</p>
</td></tr>
</table>
<p>Further, function <code>mvrm</code> creates files where the posterior samples are written.
These files are (with all file names preceded by &lsquo;BNSP.&rsquo;):
</p>
<table role = "presentation">
<tr><td><code>alpha.txt</code></td>
<td>
<p>contains samples from the posterior of vector <code class="reqn">\alpha</code>.
Rows represent posterior samples and columns represent the
regression coefficient, and they are in the same order as the columns of design matrix Z.</p>
</td></tr>
<tr><td><code>beta.txt</code></td>
<td>
<p>contains samples from the posterior of vector <code class="reqn">\beta</code>.
Rows represent posterior samples and columns represent the
regression coefficients, and they are in the same order as the columns of
design matrix X.</p>
</td></tr>
<tr><td><code>gamma.txt</code></td>
<td>
<p>contains samples from the posterior of the vector of the indicators
<code class="reqn">\gamma</code>. Rows represent posterior samples and columns represent the
indicator variables, and they are in the same order as the columns of design matrix X.</p>
</td></tr>
<tr><td><code>delta.txt</code></td>
<td>
<p>contains samples from the posterior of the vector of the indicators
<code class="reqn">\delta</code>. Rows represent posterior samples and columns represent the
indicator variables, and they are in the same order as the columns of design matrix Z.</p>
</td></tr>
<tr><td><code>sigma2.txt</code></td>
<td>
<p>contains samples from the posterior of the error variance <code class="reqn">\sigma^2</code> of each response.</p>
</td></tr>
<tr><td><code>cbeta.txt</code></td>
<td>
<p>contains samples from the posterior of <code class="reqn">c_{\beta}</code>.</p>
</td></tr>
<tr><td><code>calpha.txt</code></td>
<td>
<p>contains samples from the posterior of <code class="reqn">c_{\alpha}</code>.</p>
</td></tr>
<tr><td><code>R.txt</code></td>
<td>
<p>contains samples from the posterior of the correlation matrix <code class="reqn">R</code>.</p>
</td></tr>
<tr><td><code>theta.txt</code></td>
<td>
<p>contains samples from the posterior of <code class="reqn">\theta</code> of the shadow prior (probably not needed).</p>
</td></tr>
<tr><td><code>muR.txt</code></td>
<td>
<p>contains samples from the posterior of <code class="reqn">\mu_R</code>.</p>
</td></tr>
<tr><td><code>sigma2R.txt</code></td>
<td>
<p>contains samples from the posterior of <code class="reqn">\sigma^2_{R}</code>.</p>
</td></tr>
<tr><td><code>deviance.txt</code></td>
<td>
<p>contains the deviance, minus twice the log likelihood evaluated at the sampled values of the parameters.</p>
</td></tr>
</table>
<p>In addition to the above, for models that cluster the correlations we have
</p>
<table role = "presentation">
<tr><td><code>compAlloc.txt</code></td>
<td>
<p>The cluster at which the correlations were allocated, <code class="reqn">\lambda_{kl}</code>. These are integers from zero to the specified number of clusters minus one.</p>
</td></tr>
<tr><td><code>nmembers.txt</code></td>
<td>
<p>The numbers of correlations assigned to each cluster.</p>
</td></tr>
<tr><td><code>DPconc.txt</code></td>
<td>
<p>Contains samples from the posterior of the Dirichlet process concentration parameter.</p>
</td></tr>
</table>
<p>In addition to the above, for models that cluster the variables we have
</p>
<table role = "presentation">
<tr><td><code>compAllocV.txt</code></td>
<td>
<p>The cluster at which the variables were allocated, <code class="reqn">\lambda_{k}</code>. These are integers from zero to the specified number of clusters minus one.</p>
</td></tr>
<tr><td><code>nmembersV.txt</code></td>
<td>
<p>The numbers of variables assigned to each cluster.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Georgios Papageorgiou <a href="mailto:gpapageo@gmail.com">gpapageo@gmail.com</a></p>


<h3>References</h3>

<p>Papageorgiou, G. and Marshall, B.C. (2019). Bayesian semiparametric analysis of multivariate continuous responses, with variable selection. arXiv.
</p>
<p>Papageorgiou, G. (2018). BNSP: an R Package for fitting Bayesian semiparametric regression models and variable selection. The R Journal, 10(2):526-548.
</p>
<p>Chan, D., Kohn, R., Nott, D., &amp; Kirby, C. (2006). Locally adaptive semiparametric estimation of the mean and variance functions in regression models. Journal of Computational and Graphical Statistics, 15(4), 915-936.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Fit a mean/variance regression model on the cps71 dataset from package np. 
#This is a univariate response model
require(np)
require(ggplot2)
data(cps71)
model &lt;- logwage ~ sm(age, k = 30, bs = "rd") | sm(age, k = 30, bs = "rd")
DIR &lt;- getwd()
## Not run: m1 &lt;- mvrm(formula = model, data = cps71, sweeps = 10000, burn = 5000,
                                      thin = 2, seed = 1, StorageDir = DIR)
#Print information and summarize the model
print(m1)
summary(m1)
#Summarize and plot one parameter of interest
alpha &lt;- mvrm2mcmc(m1, "alpha")
summary(alpha)
plot(alpha)
#Obtain a plot of a term in the mean model
wagePlotOptions &lt;- list(geom_point(data = cps71, aes(x = age, y = logwage)))
plot(x = m1, model = "mean", term = "sm(age)", plotOptions = wagePlotOptions)
plot(m1)
#Obtain predictions for new values of the predictor "age"
predict(m1, data.frame(age = c(21, 65)), interval = "credible")

# Fit a bivariate mean/variance model on the marks dataset from package ggm
# two responses: marks mechanics and vectors, and one covariate: marks on algebra 
model2 &lt;- mechanics | vectors ~ sm(algebra, k = 5) | sm(algebra, k = 3)
m2 &lt;- mvrm(formula = model2, data = marks, sweeps = 100000, burn = 50000, 
                       thin = 2, seed = 1, StorageDir = DIR)
plot(m2)

## End(Not run)
</code></pre>

<hr>
<h2 id='mvrm2mcmc'>Convert posterior samples from function <code>mvrm</code> into an object of class &lsquo;mcmc&rsquo;</h2><span id='topic+mvrm2mcmc'></span>

<h3>Description</h3>

<p>Reads in files where the posterior samples were written and creates an object of class 
&lsquo;mcmc&rsquo; so that functions like <code>summary</code> and <code>plot</code> from package <code>coda</code> can be used</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvrm2mcmc(mvrmObj, labels)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvrm2mcmc_+3A_mvrmobj">mvrmObj</code></td>
<td>
<p>An object of class &lsquo;mvrm&rsquo; as created by a call to function <code>mvrm</code>.</p>
</td></tr>
<tr><td><code id="mvrm2mcmc_+3A_labels">labels</code></td>
<td>
<p>The labels of the files to be read in. These can be one or more of: &quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;, &quot;delta&quot;, &quot;sigma2&quot;, &quot;cbeta&quot;, &quot;calpha&quot;, &quot;R&quot;, &quot;muR&quot;, &quot;sigma2R&quot;, &quot;nmembers&quot;, &quot;nmembersV&quot;, &quot;compAlloc&quot;, &quot;compAllocV&quot;, and &quot;DPconc&quot; and they correspond to the parameters of the model that a call to functions <code>mvrm</code> fits. In addition, &quot;deviance&quot; can be read in. If left unspecified, all files are read in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lsquo;mcmc&rsquo; that holds the samples from the posterior of the 
selected parameter.</p>


<h3>Author(s)</h3>

<p>Georgios Papageorgiou <a href="mailto:gpapageo@gmail.com">gpapageo@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+mvrm">mvrm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#see \code{mvrm} example</code></pre>

<hr>
<h2 id='plot.mvrm'>Creates plots of terms in the mean and/or variance models</h2><span id='topic+plot.mvrm'></span>

<h3>Description</h3>

<p>This function plots estimated terms that appear in the mean and variance models. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvrm'
plot(x, model, term, response, response2, intercept = TRUE, grid = 30, 
centre = mean, quantiles = c(0.1, 0.9), contour = TRUE, static = TRUE, 
centreEffects = FALSE, plotOptions = list(), nrow, ask = FALSE, 
plotEmptyCluster = FALSE, combine = FALSE, ...) </code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mvrm_+3A_x">x</code></td>
<td>
<p>an object of class &lsquo;mvrm&rsquo; as generated by function <code>mvrm</code>.</p>
</td></tr>
<tr><td><code id="plot.mvrm_+3A_model">model</code></td>
<td>
<p>one of &quot;mean&quot;, &quot;stdev&quot;, or &quot;both&quot;, specifying which model to be visualized.</p>
</td></tr>
<tr><td><code id="plot.mvrm_+3A_term">term</code></td>
<td>
<p>the term in the selected model to be plotted.</p>
</td></tr>
<tr><td><code id="plot.mvrm_+3A_response">response</code></td>
<td>
<p>integer number denoting the response variable to be plotted (in case there is more than one).</p>
</td></tr>
<tr><td><code id="plot.mvrm_+3A_response2">response2</code></td>
<td>
<p>only relevant for multivariate longitudinal data.</p>
</td></tr>
<tr><td><code id="plot.mvrm_+3A_intercept">intercept</code></td>
<td>
<p>specifies if an intercept should be included in the calculations.</p>
</td></tr>
<tr><td><code id="plot.mvrm_+3A_grid">grid</code></td>
<td>
<p>the length of the grid on which the term will be evaluated.</p>
</td></tr>
<tr><td><code id="plot.mvrm_+3A_centre">centre</code></td>
<td>
<p>a description of how the centre of the posterior should be measured. Usually <code>mean</code> or <code>median</code>.</p>
</td></tr>
<tr><td><code id="plot.mvrm_+3A_quantiles">quantiles</code></td>
<td>
<p>the quantiles to be used when plotting credible regions. 
Plots without credible intervals may be obtained by setting this argument to NULL.</p>
</td></tr>
<tr><td><code id="plot.mvrm_+3A_contour">contour</code></td>
<td>
<p>relevant for 3D plots only. If <code>contour=TRUE</code> then <code>plot.mvrm</code> creates contour plots. 
<code>contour=FALSE</code> is allowed only for creating one plot at a time. The plot can be static or dynamic. See argument &lsquo;static&rsquo;.</p>
</td></tr>
<tr><td><code id="plot.mvrm_+3A_static">static</code></td>
<td>
<p>relevant for 3D plots only. If <code>static=TRUE</code> then <code>plot.mvrm</code> calls 
function <code>ribbon3D</code> from package <code>plot3D</code> to create the plot. 
If <code>static=FALSE</code> then <code>plot.mvrm</code> calls 
function <code>scatterplot3js</code> from package <code>threejs</code> to create the plot.</p>
</td></tr>
<tr><td><code id="plot.mvrm_+3A_centreeffects">centreEffects</code></td>
<td>
<p>if TRUE then the effects in the mean functions are centred around zero over the range of the 
predictor while the effects in the variance function are scaled around one.</p>
</td></tr>
<tr><td><code id="plot.mvrm_+3A_plotoptions">plotOptions</code></td>
<td>
<p>for plots of univariate smooth terms or for plots of bivariate smooth terms where one of the 
two covariates is discrete, this is a list of plot elements to give to <code>ggplot</code>.
For smooths of bivariate continuous covariates, this is a list of plot elements to give to 
<code>ribbon3D</code> (if <code>static=FALSE</code>) or to <code>scatterplot3js</code> (if <code>static=TRUE</code>).</p>
</td></tr>
<tr><td><code id="plot.mvrm_+3A_nrow">nrow</code></td>
<td>
<p>the number of rows in the figure with the plots.</p>
</td></tr>
<tr><td><code id="plot.mvrm_+3A_ask">ask</code></td>
<td>
<p>if set to TRUE, plots will be displayed one at a time.</p>
</td></tr>
<tr><td><code id="plot.mvrm_+3A_plotemptycluster">plotEmptyCluster</code></td>
<td>
<p>if set to TRUE, plots of empty clusters will be displayed. Relevant for multivariate longitudinal datasets.</p>
</td></tr>
<tr><td><code id="plot.mvrm_+3A_combine">combine</code></td>
<td>
<p>Binary indicator. It can be set to TRUE to simultaneously plot two terms. One of the terms must be continuous and the other must be discrete. This makes sense to set to TRUE when wanting to visualize groups that have a common slope.</p>
</td></tr>
<tr><td><code id="plot.mvrm_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use this function to obtain predictions.</p>


<h3>Value</h3>

<p>Predictions along with credible/pediction intervals</p>


<h3>Author(s)</h3>

<p>Georgios Papageorgiou <a href="mailto:gpapageo@gmail.com">gpapageo@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+mvrm">mvrm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#see \code{mvrm} example</code></pre>

<hr>
<h2 id='plotCorr'>Creates plots of the correlation matrices</h2><span id='topic+plotCorr'></span>

<h3>Description</h3>

<p>This function plots the posterior mean and credible intervals of the elements of correlation matrices. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCorr(x, term = "R", centre = mean, quantiles = c(0.1, 0.9), ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotCorr_+3A_x">x</code></td>
<td>
<p>an object of class &lsquo;mvrm&rsquo; as generated by function <code>mvrm</code>.</p>
</td></tr>
<tr><td><code id="plotCorr_+3A_term">term</code></td>
<td>
<p>R or muR,</p>
</td></tr>
<tr><td><code id="plotCorr_+3A_centre">centre</code></td>
<td>
<p>a description of how the centre of the posterior should be measured. Usually <code>mean</code> or <code>median</code>.</p>
</td></tr>
<tr><td><code id="plotCorr_+3A_quantiles">quantiles</code></td>
<td>
<p>the quantiles to be used when plotting credible regions. 
Plots without credible intervals may be obtained by setting this argument to NULL.</p>
</td></tr>
<tr><td><code id="plotCorr_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use this function to visualize the elements of a correlation matrix.</p>


<h3>Value</h3>

<p>Posterior means and credible intervals of elements of correlation matrices.</p>


<h3>Author(s)</h3>

<p>Georgios Papageorgiou <a href="mailto:gpapageo@gmail.com">gpapageo@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+mvrm">mvrm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#see \code{mvrm} example</code></pre>

<hr>
<h2 id='predict.mvrm'>Model predictions</h2><span id='topic+predict.mvrm'></span>

<h3>Description</h3>

<p>Provides predictions and posterior credible/prediction intervals for given feature vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvrm'
predict(object, newdata, interval = c("none", "credible", "prediction"), 
                       level = 0.95, ind.preds=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.mvrm_+3A_object">object</code></td>
<td>
<p>an object of class &quot;mvrm&quot;, usually a result of a call to <code>mvrm</code>.</p>
</td></tr>
<tr><td><code id="predict.mvrm_+3A_newdata">newdata</code></td>
<td>
<p>data frame of feature vectors to obtain predictions for. If newdata is missing, the function will use
the feature vectors in the data frame used to fit the mvrm object.</p>
</td></tr>
<tr><td><code id="predict.mvrm_+3A_interval">interval</code></td>
<td>
<p>type of interval calculation.</p>
</td></tr>
<tr><td><code id="predict.mvrm_+3A_level">level</code></td>
<td>
<p>the level of the credible interval.</p>
</td></tr>
<tr><td><code id="predict.mvrm_+3A_ind.preds">ind.preds</code></td>
<td>
<p>Binary indicator. If set to TRUE the function returns additionally the predictions per individual MCMC sample.</p>
</td></tr>
<tr><td><code id="predict.mvrm_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns predictions of new responses or the means of the responses for given feature vectors.
Predictions for new responses or the means of new responses are the same. However, the two differ in the associated 
level of uncertainty: response predictions are associated with wider (prediction) intervals than mean response
predictions. To obtain prediction intervals (for new responses) the function samples from the normal distributions
with means and variances as sampled during the MCMC run.</p>


<h3>Value</h3>

<p>Predictions for given covariate/feature vectors.</p>


<h3>Author(s)</h3>

<p>Georgios Papageorgiou <a href="mailto:gpapageo@gmail.com">gpapageo@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+mvrm">mvrm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#see \code{mvrm} example</code></pre>

<hr>
<h2 id='print.mvrm'>Prints an mvrm fit</h2><span id='topic+print.mvrm'></span>

<h3>Description</h3>

<p>Provides basic information from an mvrm fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvrm'
print(x, digits = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.mvrm_+3A_x">x</code></td>
<td>
<p>an object of class &quot;mvrm&quot;, usually a result of a call to <code>mvrm</code>.</p>
</td></tr>
<tr><td><code id="print.mvrm_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing.</p>
</td></tr>
<tr><td><code id="print.mvrm_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function prints information about mvrm fits.</p>


<h3>Value</h3>

<p>The function provides a matched call, the number of posterior samples obtained and marginal inclusion probabilities of the terms 
in the mean and variance models.</p>


<h3>Author(s)</h3>

<p>Georgios Papageorgiou <a href="mailto:gpapageo@gmail.com">gpapageo@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+mvrm">mvrm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#see \code{mvrm} example</code></pre>

<hr>
<h2 id='s'>mgcv constructor <code>s</code></h2><span id='topic+s'></span>

<h3>Description</h3>

<p>Provides interface between mgcv::s and BNSP. <code>s(...)</code> calls 
<code>mgcv::smoothCon(mgcv::s(...),...</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>s(..., data, knots = NULL, absorb.cons = FALSE, scale.penalty = TRUE, 
n = nrow(data), dataX = NULL, null.space.penalty = FALSE, sparse.cons = 0, 
diagonal.penalty = FALSE, apply.by = TRUE, modCon = 0, k = -1, fx = FALSE, 
bs = "tp", m = NA, by = NA, xt = NULL, id = NULL, sp = NULL, pc = NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="s_+3A_...">...</code></td>
<td>
<p>a list of variables. See mgcv::s</p>
</td></tr>
<tr><td><code id="s_+3A_data">data</code></td>
<td>
<p>see mgcv::smoothCon</p>
</td></tr>
<tr><td><code id="s_+3A_knots">knots</code></td>
<td>
<p>see mgcv::knots</p>
</td></tr>
<tr><td><code id="s_+3A_absorb.cons">absorb.cons</code></td>
<td>
<p>see mgcv::smoothCon</p>
</td></tr>
<tr><td><code id="s_+3A_scale.penalty">scale.penalty</code></td>
<td>
<p>see mgcv::smoothCon</p>
</td></tr>
<tr><td><code id="s_+3A_n">n</code></td>
<td>
<p>see mgcv::smoothCon</p>
</td></tr>
<tr><td><code id="s_+3A_datax">dataX</code></td>
<td>
<p>see mgcv::smoothCon</p>
</td></tr>
<tr><td><code id="s_+3A_null.space.penalty">null.space.penalty</code></td>
<td>
<p>see mgcv::smoothCon</p>
</td></tr>
<tr><td><code id="s_+3A_sparse.cons">sparse.cons</code></td>
<td>
<p>see mgcv::smoothCon</p>
</td></tr>
<tr><td><code id="s_+3A_diagonal.penalty">diagonal.penalty</code></td>
<td>
<p>see mgcv::smoothCon</p>
</td></tr>
<tr><td><code id="s_+3A_apply.by">apply.by</code></td>
<td>
<p>see mgcv::smoothCon</p>
</td></tr>
<tr><td><code id="s_+3A_modcon">modCon</code></td>
<td>
<p>see mgcv::smoothCon</p>
</td></tr>
<tr><td><code id="s_+3A_k">k</code></td>
<td>
<p>see mgcv::s</p>
</td></tr>
<tr><td><code id="s_+3A_fx">fx</code></td>
<td>
<p>see mgcv::s</p>
</td></tr>
<tr><td><code id="s_+3A_bs">bs</code></td>
<td>
<p>see mgcv::s</p>
</td></tr>
<tr><td><code id="s_+3A_m">m</code></td>
<td>
<p>see mgcv::s</p>
</td></tr>
<tr><td><code id="s_+3A_by">by</code></td>
<td>
<p>see mgcv::s</p>
</td></tr>
<tr><td><code id="s_+3A_xt">xt</code></td>
<td>
<p>see mgcv::s</p>
</td></tr>
<tr><td><code id="s_+3A_id">id</code></td>
<td>
<p>see mgcv::s</p>
</td></tr>
<tr><td><code id="s_+3A_sp">sp</code></td>
<td>
<p>see mgcv::s</p>
</td></tr>
<tr><td><code id="s_+3A_pc">pc</code></td>
<td>
<p>see mgcv::s</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The most relevant arguments for BNSP users are the list of variables <code>...</code>, <code>knots</code>, <code>absorb.cons</code>, <code>bs</code>, and <code>by</code>.</p>


<h3>Value</h3>

<p>A design matrix that specifies a smooth term in a model.</p>


<h3>Author(s)</h3>

<p>Georgios Papageorgiou <a href="mailto:gpapageo@gmail.com">gpapageo@gmail.com</a></p>

<hr>
<h2 id='simD'>Simulated dataset</h2><span id='topic+simD'></span>

<h3>Description</h3>

<p>Just a simulated dataset to illustrate the DO mixture model. The success probability and the covariate have a non-linear relationship.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simD)</code></pre>


<h3>Format</h3>

<p>A data frame with 300 independent observations. Three numerical vectors contain information on
</p>

<dl>
<dt><code>Y</code></dt><dd><p>number of successes.</p>
</dd>
<dt><code>E</code></dt><dd><p>number of trials.</p>
</dd>
<dt><code>X</code></dt><dd><p>explanatory variable.</p>
</dd>
</dl>


<hr>
<h2 id='simD2'>Simulated dataset</h2><span id='topic+simD2'></span>

<h3>Description</h3>

<p>A simulated dataset to illustrate the multivariate longitudinal model. It consists of a bivariate vector of responses observed over 6 time points.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simD2)</code></pre>


<h3>Format</h3>

<p>A data frame that includes observations on 50 sampling units. The data frame has 300 rows for the 50 sampling units observed over 6 time points. It has 4 columns 
</p>

<dl>
<dt><code>Y1</code></dt><dd><p>first response.</p>
</dd>
<dt><code>Y2</code></dt><dd><p>second response.</p>
</dd>
<dt><code>time</code></dt><dd><p>the time of observation.</p>
</dd>
<dt><code>id</code></dt><dd><p>unique sampling unit identifier.</p>
</dd>
</dl>


<hr>
<h2 id='sinusoid'>Sinusoid terms in mvrm formulae</h2><span id='topic+sinusoid'></span>

<h3>Description</h3>

<p>Function used to define sinusoidal curves in the mean formula of function <code>mvrm</code>. 
The function is used internally to construct design matrices.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sinusoid(..., harmonics = 1, amplitude = 1, period = 0, periodRange = NULL, 
breaks = NULL, knots = NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sinusoid_+3A_...">...</code></td>
<td>
<p>a single covariate that the sinusoid term is a function of.</p>
</td></tr> 
<tr><td><code id="sinusoid_+3A_harmonics">harmonics</code></td>
<td>
<p>an integer value that denotes the number of sins and cosines to be utilized in the representation of a sinusoidal curve.</p>
</td></tr>
<tr><td><code id="sinusoid_+3A_amplitude">amplitude</code></td>
<td>
<p>a positive integer. If set equal to one, it denotes a fixed amplitude. Otherwise, if set to an integer that is greater than one, it denotes the number of knots to be utilized in the representation of the time-varying amplitude.</p>
</td></tr>
<tr><td><code id="sinusoid_+3A_period">period</code></td>
<td>
<p>the period of the sinusoidal wave. Values less than or equal to zero signify that the period is unknown. 
Positive values signify that the period is known and fixed.</p>
</td></tr>
<tr><td><code id="sinusoid_+3A_periodrange">periodRange</code></td>
<td>
<p>a vector of length two with the range of possible period values. It is required when the period is unknown.</p>
</td></tr>
<tr><td><code id="sinusoid_+3A_breaks">breaks</code></td>
<td>
<p>the growth break points.</p>
</td></tr>
<tr><td><code id="sinusoid_+3A_knots">knots</code></td>
<td>
<p>the knots to be utilized in the representation of the time-varying amplitude. Relevant only when <code>amplitude</code> is greater than 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use this function within calls to function <code>mvrm</code> to specify sinusoidal waves in the mean function
of a regression model.
</p>
<p>Consider the sinusoidal curve 
</p>
<p style="text-align: center;"><code class="reqn">
y_t = \beta_0 + A(t) \sin(2\pi t/\omega+\varphi) + \epsilon_t,</code>
</p>

<p>where <code class="reqn">y_t</code> is the response at time <code class="reqn">t</code>, <code class="reqn">\beta_0</code> is an intercept term, <code class="reqn">A(t)</code> is a time-varying amplitude, <code class="reqn">\varphi \in [0,2\pi]</code> is the phase shift parameter, <code class="reqn">\omega</code> is the period taken to be known, and
<code class="reqn">\epsilon_t</code> is the error term.
</p>
<p>The period <code class="reqn">\omega</code> is defined by the argument <code>period</code>. 
</p>
<p>The time-varying amplitude is represented using <code class="reqn">A(t) = \sum_{j=1}^{K} \beta_{Aj} \phi_{Aj}(t)</code>, 
where <code class="reqn">K</code>, the number of knots, is defined by argument <code>amplitude</code>. If <code>amplitude = 1</code>, then
the amplitude is taken to be fixed: <code class="reqn">A(t)=A</code>.  
</p>
<p>Further, <code class="reqn">\sin(2\pi t/\omega+\varphi)</code> is represented utilizing
<code class="reqn">\sin(2\pi t/\omega+\varphi) = \sum_{k=1}^{L} a_k \sin(2k\pi t/\omega) + b_k \cos(2k\pi t/\omega)</code>,
where <code class="reqn">L</code>, the number of harmonics, is defined by argument <code>harmonics</code>. 
</p>


<h3>Value</h3>

<p>Specifies the design matrices of an <code>mvrm</code> call</p>


<h3>Author(s)</h3>

<p>Georgios Papageorgiou <a href="mailto:gpapageo@gmail.com">gpapageo@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+mvrm">mvrm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate and fit a sinusoidal curve
# First load releveant packages
require(BNSP)
require(ggplot2)
require(gridExtra)
require(Formula)
# Simulate the data 
mu &lt;- function(u) {cos(0.5 * u) * sin(2 * pi * u + 1)}
set.seed(1)
n &lt;- 100
u &lt;- sort(runif(n, min = 0, max = 2*pi))
y &lt;- rnorm(n, mu(u), 0.1)
data &lt;- data.frame(y, u)
# Define the model and call function \code{mvrm} that perfomes posterior sampling for the given 
# dataset and defined model 
model &lt;- y ~ sinusoid(u, harmonics = 2, amplitude = 20, period = 1)
## Not run: 
m1 &lt;- mvrm(formula = model, data = data, sweeps = 10000, burn = 5000, thin = 2, seed = 1, 
           StorageDir = getwd())
# Plot
x1 &lt;- seq(min(u), max(u), length.out = 100)
plotOptionsM &lt;- list(geom_line(aes_string(x = x1, y = mu(x1)), col = 2, alpha = 0.5, lty = 2),
                     geom_point(data = data, aes(x = u, y = y)))
plot(x = m1, term = 1, plotOptions = plotOptionsM, intercept = TRUE, 
     quantiles = c(0.005, 0.995), grid = 100, combine = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='sm'>Smooth terms in mvrm formulae</h2><span id='topic+sm'></span>

<h3>Description</h3>

<p>Function used to define smooth effects in the mean and variance formulae of function <code>mvrm</code>. 
The function is used internally to construct the design matrices.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sm(..., k = 10, knots = NULL, bs = "rd")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sm_+3A_...">...</code></td>
<td>
<p>one or two covariates that the smooth term is a function of. If two covariates are used, 
they may be both continuous or one continuous and one discrete. Discrete variables should be defined as <code>factor</code>
in the <code>data</code> argument of the calling <code>mvrm</code> function.</p>
</td></tr>
<tr><td><code id="sm_+3A_k">k</code></td>
<td>
<p>the number of knots to be utilized in the basis function expansion.</p>
</td></tr>
<tr><td><code id="sm_+3A_knots">knots</code></td>
<td>
<p>the knots to be utilized in the basis function expansion.</p>
</td></tr>
<tr><td><code id="sm_+3A_bs">bs</code></td>
<td>
<p>a two letter character indicating the basis functions to be used. Currently, the options are
<code>"rd"</code> that specifies radial basis functions and is available for univariate and bivariate smooths,
and <code>"pl"</code> that specifies thin plate splines that are available for univariate smooths.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use this function within calls to function <code>mvrm</code> to specify smooth terms in the mean and/or variance function
of the regression model.
</p>
<p>Univariate radial basis functions with <code class="reqn">q</code> basis functions or <code class="reqn">q-1</code> knots are defined by
</p>
<p style="text-align: center;"><code class="reqn">
\mathcal{B}_1 = \left\{\phi_{1}(u)=u , \phi_{2}(u)=||u-\xi_{1}||^2 \log\left(||u-\xi_{1}||^2\right), \dots, 
\phi_{q}(u)=||u-\xi_{q-1}||^2 \log\left(||u-\xi_{q-1}||^2\right)\right\},
</code>
</p>

<p>where <code class="reqn">||u||</code> denotes the Euclidean norm of <code class="reqn">u</code> and <code class="reqn">\xi_1,\dots,\xi_{q-1}</code> are the knots that  
are chosen as the quantiles of the observed values of explanatory variable <code class="reqn">u</code>, 
with <code class="reqn">\xi_1=\min(u_i), \xi_{q-1}=\max(u_i)</code> and the remaining knots chosen as equally spaced quantiles between
<code class="reqn">\xi_1</code> and <code class="reqn">\xi_{q-1}</code>. 
</p>
<p>Thin plate splines are defined by 
</p>
<p style="text-align: center;"><code class="reqn">
\mathcal{B}_2 = \left\{\phi_{1}(u)=u , \phi_{2}(u)=(u-\xi_{1})_{+}, \dots, \phi_{q}(u)=(u-\xi_{q})_{+}\right\},
</code>
</p>

<p>where <code class="reqn">(a)_+ = \max(a,0)</code>. 
</p>
<p>Radial basis functions for bivariate smooths are defined by
</p>
<p style="text-align: center;"><code class="reqn">
\mathcal{B}_3 = \left\{u_1,u_2,\phi_{3}(u)=||u-\xi_{1}||^2 \log\left(||u-\xi_{1}||^2\right), \dots, 
\phi_{q}(u)=||u-\xi_{q-1}||^2 \log\left(||u-\xi_{q-1}||^2\right)\right\}.
</code>
</p>
 


<h3>Value</h3>

<p>Specifies the design matrices of an <code>mvrm</code> call</p>


<h3>Author(s)</h3>

<p>Georgios Papageorgiou <a href="mailto:gpapageo@gmail.com">gpapageo@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+mvrm">mvrm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#see \code{mvrm} example</code></pre>

<hr>
<h2 id='summary.mvrm'>Summary of an mvrm fit</h2><span id='topic+summary.mvrm'></span>

<h3>Description</h3>

<p>Provides basic information from an mvrm fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvrm'
summary(object, nModels = 5, digits = 5, printTuning = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.mvrm_+3A_object">object</code></td>
<td>
<p>an object of class &quot;mvrm&quot;, usually a result of a call to <code>mvrm</code>.</p>
</td></tr>
<tr><td><code id="summary.mvrm_+3A_nmodels">nModels</code></td>
<td>
<p>integer number of models with the highest posterior probability to be displayed.</p>
</td></tr>
<tr><td><code id="summary.mvrm_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing.</p>
</td></tr>
<tr><td><code id="summary.mvrm_+3A_printtuning">printTuning</code></td>
<td>
<p>if set to TRUE, the starting and finishig values of the tuninf parameters are displayed.</p>
</td></tr>
<tr><td><code id="summary.mvrm_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use this function to summarize mvrm fits.</p>


<h3>Value</h3>

<p>The functions provides a detailed description of the specified model and priors. 
In addition, the function provides information about the Markov chain ran (length, burn-in, thinning) and the
folder where the files with posterior samples are stored. Lastly, the function provides the mean
posterior and null deviance and the mean/variance models visited most often during posterior sampling.</p>


<h3>Author(s)</h3>

<p>Georgios Papageorgiou <a href="mailto:gpapageo@gmail.com">gpapageo@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+mvrm">mvrm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#see \code{mvrm} example</code></pre>

<hr>
<h2 id='te'>mgcv constructor <code>te</code></h2><span id='topic+te'></span>

<h3>Description</h3>

<p>Provides interface between mgcv::te and BNSP. <code>te(...)</code> calls 
<code>mgcv::smoothCon(mgcv::te(...),...</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>te(..., data, knots = NULL, absorb.cons = FALSE, scale.penalty = TRUE, 
n = nrow(data), dataX = NULL, null.space.penalty = FALSE, sparse.cons = 0, 
diagonal.penalty = FALSE, apply.by = TRUE, modCon = 0, k = NA, bs = "cr", 
m = NA, d = NA, by = NA, fx = FALSE, np = TRUE, xt = NULL, id = NULL, 
sp = NULL, pc = NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="te_+3A_...">...</code></td>
<td>
<p>a list of variables. See mgcv::te</p>
</td></tr>
<tr><td><code id="te_+3A_data">data</code></td>
<td>
<p>see mgcv::smoothCon</p>
</td></tr>
<tr><td><code id="te_+3A_knots">knots</code></td>
<td>
<p>see mgcv::knots</p>
</td></tr>
<tr><td><code id="te_+3A_absorb.cons">absorb.cons</code></td>
<td>
<p>see mgcv::smoothCon</p>
</td></tr>
<tr><td><code id="te_+3A_scale.penalty">scale.penalty</code></td>
<td>
<p>see mgcv::smoothCon</p>
</td></tr>
<tr><td><code id="te_+3A_n">n</code></td>
<td>
<p>see mgcv::smoothCon</p>
</td></tr>
<tr><td><code id="te_+3A_datax">dataX</code></td>
<td>
<p>see mgcv::smoothCon</p>
</td></tr>
<tr><td><code id="te_+3A_null.space.penalty">null.space.penalty</code></td>
<td>
<p>see mgcv::smoothCon</p>
</td></tr>
<tr><td><code id="te_+3A_sparse.cons">sparse.cons</code></td>
<td>
<p>see mgcv::smoothCon</p>
</td></tr>
<tr><td><code id="te_+3A_diagonal.penalty">diagonal.penalty</code></td>
<td>
<p>see mgcv::smoothCon</p>
</td></tr>
<tr><td><code id="te_+3A_apply.by">apply.by</code></td>
<td>
<p>see mgcv::smoothCon</p>
</td></tr>
<tr><td><code id="te_+3A_modcon">modCon</code></td>
<td>
<p>see mgcv::smoothCon</p>
</td></tr>
<tr><td><code id="te_+3A_k">k</code></td>
<td>
<p>see mgcv::te</p>
</td></tr>
<tr><td><code id="te_+3A_bs">bs</code></td>
<td>
<p>see mgcv::te</p>
</td></tr>
<tr><td><code id="te_+3A_m">m</code></td>
<td>
<p>see mgcv::te</p>
</td></tr>
<tr><td><code id="te_+3A_d">d</code></td>
<td>
<p>see mgcv::te</p>
</td></tr>
<tr><td><code id="te_+3A_by">by</code></td>
<td>
<p>see mgcv::te</p>
</td></tr>
<tr><td><code id="te_+3A_fx">fx</code></td>
<td>
<p>see mgcv::te</p>
</td></tr>
<tr><td><code id="te_+3A_np">np</code></td>
<td>
<p>see mgcv::te</p>
</td></tr>
<tr><td><code id="te_+3A_xt">xt</code></td>
<td>
<p>see mgcv::te</p>
</td></tr>
<tr><td><code id="te_+3A_id">id</code></td>
<td>
<p>see mgcv::te</p>
</td></tr>
<tr><td><code id="te_+3A_sp">sp</code></td>
<td>
<p>see mgcv::te</p>
</td></tr>
<tr><td><code id="te_+3A_pc">pc</code></td>
<td>
<p>see mgcv::te</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The most relevant arguments for BNSP users are the list of variables <code>...</code>, <code>knots</code>, <code>absorb.cons</code>, <code>bs</code>, and <code>by</code>.</p>


<h3>Value</h3>

<p>A design matrix that specifies a smooth term in a model.</p>


<h3>Author(s)</h3>

<p>Georgios Papageorgiou <a href="mailto:gpapageo@gmail.com">gpapageo@gmail.com</a></p>

<hr>
<h2 id='ti'>mgcv constructor <code>ti</code></h2><span id='topic+ti'></span>

<h3>Description</h3>

<p>Provides interface between mgcv::ti and BNSP. <code>ti(...)</code> calls 
<code>mgcv::smoothCon(mgcv::ti(...),...</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>ti(..., data, knots = NULL, absorb.cons = FALSE, scale.penalty = TRUE, 
n = nrow(data), dataX = NULL, null.space.penalty = FALSE, sparse.cons = 0, 
diagonal.penalty = FALSE, apply.by = TRUE, modCon = 0, k = NA, bs = "cr", 
m = NA, d = NA, by = NA, fx = FALSE, np = TRUE, xt = NULL, id = NULL, 
sp = NULL, mc = NULL, pc = NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ti_+3A_...">...</code></td>
<td>
<p>a list of variables. See mgcv::ti</p>
</td></tr>
<tr><td><code id="ti_+3A_data">data</code></td>
<td>
<p>see mgcv::smoothCon</p>
</td></tr>
<tr><td><code id="ti_+3A_knots">knots</code></td>
<td>
<p>see mgcv::knots</p>
</td></tr>
<tr><td><code id="ti_+3A_absorb.cons">absorb.cons</code></td>
<td>
<p>see mgcv::smoothCon</p>
</td></tr>
<tr><td><code id="ti_+3A_scale.penalty">scale.penalty</code></td>
<td>
<p>see mgcv::smoothCon</p>
</td></tr>
<tr><td><code id="ti_+3A_n">n</code></td>
<td>
<p>see mgcv::smoothCon</p>
</td></tr>
<tr><td><code id="ti_+3A_datax">dataX</code></td>
<td>
<p>see mgcv::smoothCon</p>
</td></tr>
<tr><td><code id="ti_+3A_null.space.penalty">null.space.penalty</code></td>
<td>
<p>see mgcv::smoothCon</p>
</td></tr>
<tr><td><code id="ti_+3A_sparse.cons">sparse.cons</code></td>
<td>
<p>see mgcv::smoothCon</p>
</td></tr>
<tr><td><code id="ti_+3A_diagonal.penalty">diagonal.penalty</code></td>
<td>
<p>see mgcv::smoothCon</p>
</td></tr>
<tr><td><code id="ti_+3A_apply.by">apply.by</code></td>
<td>
<p>see mgcv::smoothCon</p>
</td></tr>
<tr><td><code id="ti_+3A_modcon">modCon</code></td>
<td>
<p>see mgcv::smoothCon</p>
</td></tr>
<tr><td><code id="ti_+3A_k">k</code></td>
<td>
<p>see mgcv::ti</p>
</td></tr>
<tr><td><code id="ti_+3A_bs">bs</code></td>
<td>
<p>see mgcv::ti</p>
</td></tr>
<tr><td><code id="ti_+3A_m">m</code></td>
<td>
<p>see mgcv::ti</p>
</td></tr>
<tr><td><code id="ti_+3A_d">d</code></td>
<td>
<p>see mgcv::ti</p>
</td></tr>
<tr><td><code id="ti_+3A_by">by</code></td>
<td>
<p>see mgcv::ti</p>
</td></tr>
<tr><td><code id="ti_+3A_fx">fx</code></td>
<td>
<p>see mgcv::ti</p>
</td></tr>
<tr><td><code id="ti_+3A_np">np</code></td>
<td>
<p>see mgcv::ti</p>
</td></tr>
<tr><td><code id="ti_+3A_xt">xt</code></td>
<td>
<p>see mgcv::ti</p>
</td></tr>
<tr><td><code id="ti_+3A_id">id</code></td>
<td>
<p>see mgcv::ti</p>
</td></tr>
<tr><td><code id="ti_+3A_sp">sp</code></td>
<td>
<p>see mgcv::ti</p>
</td></tr>
<tr><td><code id="ti_+3A_mc">mc</code></td>
<td>
<p>see mgcv::ti</p>
</td></tr>
<tr><td><code id="ti_+3A_pc">pc</code></td>
<td>
<p>see mgcv::ti</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The most relevant arguments for BNSP users are the list of variables <code>...</code>, <code>knots</code>, <code>absorb.cons</code>, <code>bs</code>, and <code>by</code>.</p>


<h3>Value</h3>

<p>A design matrix that specifies a smooth term in a model.</p>


<h3>Author(s)</h3>

<p>Georgios Papageorgiou <a href="mailto:gpapageo@gmail.com">gpapageo@gmail.com</a></p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
