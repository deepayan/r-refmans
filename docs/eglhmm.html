<!DOCTYPE html><html><head><title>Help for package eglhmm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {eglhmm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anova.eglhmm'>
<p>Test for a difference between two fitted <code>eglhmm</code> models.</p></a></li>
<li><a href='#bcov'><p> Bootstrap covariance.</p></a></li>
<li><a href='#crossval'>
<p>Cross validate an extended generalised linear hidden Markov model.</p></a></li>
<li><a href='#eglhmm'><p> Fit (extended) generalised linear hidden Markov models.</p></a></li>
<li><a href='#eglhmm-internal'><p>Internal eglhmm functions.</p></a></li>
<li><a href='#fitted.eglhmm'><p> Predict method for extended generalised linear hidden Markov models.</p></a></li>
<li><a href='#hydroData'>
<p>Canadian hydrological data sets.</p></a></li>
<li><a href='#ionChannelData'>
<p>Ion channel data</p></a></li>
<li><a href='#miscprints'>
<p>Specialised print methods.</p></a></li>
<li><a href='#monoCyteSim'>
<p>Simulated monocyte counts and psychosis symptoms.</p></a></li>
<li><a href='#plot.eglhmm'>
<p>Plot the results of an eglhmm fit.</p></a></li>
<li><a href='#postHocGradHess'>
<p>Obtain gradient and Hessian, post hoc.</p></a></li>
<li><a href='#reglhmm'><p> Simulate data from a hidden generalised linear Markov</p>
model.</a></li>
<li><a href='#reorder.eglhmm'>
<p>Reorder the states of a fitted eglhmm model</p></a></li>
<li><a href='#SydColDat'><p>Sydney coliform bacteria data</p></a></li>
<li><a href='#weissData'>
<p>Data from &ldquo;An Introduction to Discrete-Valued Time Series&rdquo;</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.1-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-13</td>
</tr>
<tr>
<td>Title:</td>
<td>Extended Generalised Linear Hidden Markov Models</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rolf Turner &lt;rolfturner@posteo.net&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits a variety of hidden Markov models, structured
	in an extended generalized linear model framework.  See
	T. Rolf Turner, Murray A. Cameron, and Peter J. Thomson
	(1998) &lt;<a href="https://doi.org/10.2307%2F3315677">doi:10.2307/3315677</a>&gt;, and
	Rolf Turner (2008) &lt;<a href="https://doi.org/10.1016%2Fj.csda.2008.01.029">doi:10.1016/j.csda.2008.01.029</a>&gt;
	and the references cited therein.</td>
</tr>
<tr>
<td>Imports:</td>
<td>dbd, nnet</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-12 22:54:16 UTC; rolf</td>
</tr>
<tr>
<td>Author:</td>
<td>Rolf Turner [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-12 23:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='anova.eglhmm'>
Test for a difference between two fitted <code>eglhmm</code> models.
</h2><span id='topic+anova.eglhmm'></span>

<h3>Description</h3>

<p>Apply a likelihood ratio test to determine whether the difference,
between the log likelihood statistics of two fitted <code>eglhmm</code> models,
is statistically significant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'eglhmm'
anova(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.eglhmm_+3A_object">object</code></td>
<td>

<p>An object of class <code>"eglhmm"</code> as returned by <code><a href="#topic+eglhmm">eglhmm</a>()</code>.
</p>
</td></tr>
<tr><td><code id="anova.eglhmm_+3A_...">...</code></td>
<td>

<p>Precisely <em>one</em> more object of class <code>"eglhmm"</code>, to be
compared with <code>object</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This anova method handles only comparisons between <em>two</em>
models.)  The order of the arguments (i.e. which object is passed
as &ldquo;<code>object</code>&rdquo; and which is passed as the sole entry
of the ... argument) is immaterial.
</p>


<h3>Value</h3>

<p>A list with components
</p>

<ul>
<li> <p><code>stat</code> the likelihood ratio statistic, i.e. the difference
between the log likelihoods of the two models.  That for the model
with the smaller number of parameters is subtracted from that for
the model with the larger number.
</p>
</li>
<li> <p><code>df</code> the degrees of freedom of the likelihood ratio statistic,
i.e. the difference between the number of parameters of the respective
models.  The smaller number is subtracted from the larger.
</p>
</li>
<li> <p><code>pvalue</code> the <code class="reqn">p</code>-value of the test as given by
<code>pchisq(stat, df, lower.tail = FALSE)</code>.
</p>
</li></ul>

<p>This list has an attribute <code>"details"</code> consisting of a numeric
vector of length four with entries <code>ll1</code> (the smaller of the
log likelihoods), <code>ll2</code> (the larger of the log likelihoods),
<code>np1</code> (the smaller of the parameter counts) and <code>np2</code>
(the larger of the parameter counts).
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit1 &lt;- eglhmm(formula=y~locn+depth,data=SydColCount,
               cells=c("locn","depth"),distr="P",K=2,
               method="em",verb=TRUE)
fit2 &lt;- eglhmm(formula=y~locn+depth+ma.com+nh.com+bo.com,data=SydColCount,
               cells=c("locn","depth"),distr="P",K=2,
               method="em",verb=TRUE)
anova(fit1,fit2)
</code></pre>

<hr>
<h2 id='bcov'> Bootstrap covariance. </h2><span id='topic+bcov'></span>

<h3>Description</h3>

<p>Creates an estimate of the covariance matrix of the parameter
estimates for an extended generalised linear hidden Markov model via
parametric bootstrapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   bcov(object, nsim = 50, itmax = 500, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bcov_+3A_object">object</code></td>
<td>
<p> An object of class <code>eglhmm</code> as produced by
<code><a href="#topic+eglhmm">eglhmm</a>()</code>. </p>
</td></tr>
<tr><td><code id="bcov_+3A_nsim">nsim</code></td>
<td>
<p> The number of data sets to simulate, from which
to estimate parameters.  From each data set a vector of parameters
is estimated; the estimated covariance matrix is the empirical
covariance matrix of these <code>nsim</code> vectors.</p>
</td></tr>
<tr><td><code id="bcov_+3A_itmax">itmax</code></td>
<td>
<p> The maximum number of iterations to be used in attempting
to achieve convergence when fitting models to the simulated data sets.
Note that if convergence is not achieved, the simulated data set being
used is discarded (i.e. it &ldquo;doesn't count&rdquo;) and a replacement data set
is simulated. </p>
</td></tr>
<tr><td><code id="bcov_+3A_verbose">verbose</code></td>
<td>
<p>Logical scalar.  Should a &ldquo;progress report&rdquo;
be printed out at each step of the fitting procedure?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>C_hat</code></td>
<td>
<p>The parametric bootstrap estimate of the covariance
matrix of the parameter estimates.</p>
</td></tr>
<tr><td><code>nc.count</code></td>
<td>
<p>A count of the total number of times that the
algorithm failed to converge during the bootstrapping procedure.</p>
</td></tr>
<tr><td><code>an.count</code></td>
<td>
<p>A count of the &ldquo;anomalies&rdquo; that occurred,
i.e. the number of times that there was a decrease in the log
likelihood.  Present only if the <code>method</code> used in fitting
the models is <code>"em"</code>.
</p>
</td></tr>
</table>


<h3>Remarks</h3>

<p>Although this documentation refers to &ldquo;extended
generalised linear models&rdquo;, the only such models currently
(13/02/2024) available are the Gaussian model with the identity link,
the Poisson model, with the log link, the Binomial model with
the logit link, the Dbd (discretised beta distribution model),
and the Multinom model.  The latter two are generalised linear
models only in the &ldquo;extended&rdquo; sense.  Other models may be
added at a future date.
</p>
<p>When <code>eglhmm()</code> is called by <code>bcov()</code> the argument
<code>checkDecrLL</code> is set equal to <code>FALSE</code>.  This has an
effect only when the <code>method</code> used in fitting the models
is <code>"em"</code>.  In this case a decrease in the log likelihood
is treated as meaning that the algorithm has converged.   Setting
<code>checkDecrLL</code> equal to <code>FALSE</code> is done so as to decrease
the number of discarded data sets and thereby speed up the rate
at which the iterations proceed.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>See the help for <code><a href="#topic+eglhmm">eglhmm</a>()</code> for references.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fitted.eglhmm">fitted.eglhmm</a>()</code> <code><a href="#topic+reglhmm">reglhmm</a>()</code>
<code><a href="#topic+reglhmm.default">reglhmm.default</a>()</code> <code><a href="#topic+reglhmm.eglhmm">reglhmm.eglhmm</a>()</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## Not run:  # Takes too long.
        fitP &lt;- eglhmm(y~locn+depth,data=SydColCount,distr="P",cells=c("locn","depth"),
                     K=2,contr="sum",verb=TRUE,itmax=300)
	cvrP &lt;- bcov(fitP)
        fitD &lt;- eglhmm(y~locn+depth,data=SydColCount,distr="D",cells=c("locn","depth"),
                     K=2,nbot=0,ntop=11,contr="sum",verb=TRUE)
	cvrD &lt;- bcov(fitD)
        fitM &lt;- eglhmm(y~locn+depth,data=SydColDisc,distr="M",cells=c("locn","depth"),
                     K=2,contr="sum",verb=TRUE)
	cvrM &lt;- bcov(fitM)
    
## End(Not run)
</code></pre>

<hr>
<h2 id='crossval'>
Cross validate an extended generalised linear hidden Markov model.
</h2><span id='topic+crossval'></span>

<h3>Description</h3>

<p>Calculates a number of cross validation log likelihood values
for a hidden Markov model (usually one fitted by the <code>eglhmm()</code>
function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    crossval(model,data,nrep,frac=0.8,type,id="id",minNcomp=100,
             seed=NULL,crossVerb=FALSE,lastPar=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossval_+3A_model">model</code></td>
<td>

<p>A list having components with names selected from those
of objects returned by <code>eglhmm()</code> e.g. <code>distr</code>,
<code>theta</code>, <code>formula</code> etc.  Typically <code>model</code> will
be of class <code>"eglhmm"</code> and will have been returned by
the <code><a href="#topic+eglhmm">eglhmm</a>()</code> function.
</p>
</td></tr>
<tr><td><code id="crossval_+3A_data">data</code></td>
<td>

<p>A data frame containing the observations to which the cross
validation are to be fitted.
</p>
<p>It is of course up to the user to ensure that a specified
value of <code>data</code> makes sense, i.e. is consistent with the
other arguments.
</p>
</td></tr>
<tr><td><code id="crossval_+3A_nrep">nrep</code></td>
<td>

<p>Positive nteger scalar; the number of replications, i.e. the
number of cross validation calculations undertaken.  If argument
<code>lastPar</code> (see below) is supplied then <code>nrep</code> is ignored
and is silently set equal to 1.  If <code>lastPar</code> is <code>NULL</code>
then <code>nrep</code> must be supplied, otherwise an error is thrown.
</p>
</td></tr>
<tr><td><code id="crossval_+3A_frac">frac</code></td>
<td>
<p>Postive scaler, less than 1.  The fraction of the
data randomly selected to be used as <code>training data</code> on each
replication.  (The remaining data, i.e. those data <em>not</em>
used as training data, are used as <code>validation</code> data.
</p>
</td></tr>
<tr><td><code id="crossval_+3A_type">type</code></td>
<td>

<p>Integer scalar, equal to either 1 or 2, which determines the nature
of the sampling used to produce the training and validation data.
If <code>type=1</code> then these data sets are obtained by sampling
data points individually.  The training data are obtained by
setting a fraction <code>1 - frac</code> of the observed emission values
(those which are <em>not</em> missing already) equal to <code>NA</code>.
The validation data are the complement of the training data.
</p>
<p>If <code>type=2</code> then the <em>components</em> of <code>data</code> are
randomly sampled (and used in their entirety, either for training
or for validation).  The components are determined from the column
of <code>data</code> the name of which is specified by the argument
<code>id</code>; if there is no such column, then an error is thrown.
Sampling the components means sampling the levels of (the factor)
<code>data[,id]</code>.
</p>
<p>Obviously it is sensible to use <code>type=2</code> <em>only</em>
if <code>data</code> has a <em>large</em> number of components.  By
default this number is required to be at least 100.  (See
<code>minNcomp</code> below.)
</p>
</td></tr>
<tr><td><code id="crossval_+3A_id">id</code></td>
<td>

<p>Character scalar specifying the column to be used to determine the
individual independent time series that make up the data.  Ignored
unless <code>type=2</code>.
</p>
</td></tr>
<tr><td><code id="crossval_+3A_minncomp">minNcomp</code></td>
<td>

<p>Integer scalar specifying the minimum number of components (number
of levels of <code>data["id"]</code>) that <code>data</code> must have in order
for <code>type=2</code> to used.  Ignored if <code>type</code> is equal to 1.
</p>
<p>If the number of components is less than the default value of
<code>minNcomp</code> (i.e. 100) then it is strongly recommended that
<code>type=1</code> be used instead.
</p>
</td></tr>
<tr><td><code id="crossval_+3A_seed">seed</code></td>
<td>

<p>Positive integer scalar to be used as a seed for the random
number generator (so as to enable reproducibility).  If not
supplied, it is randomly chosen from the sequence <code>1:1e6</code>.
Note that if <code>nrep &gt; 1</code> then after this seed is set, a vector
<code>SEEDS</code> of &ldquo;auxiliary&rdquo; seeds, of length <code>nrep</code>,
is chosen from the sequence <code>1:1e6</code> and the seed is set
from the corresponding entry of this vector at the start of each
replication.  If <code>nrep==1</code> then the sampling for the single
replication that occurs is determined by <code>seed</code>.
</p>
</td></tr>
<tr><td><code id="crossval_+3A_crossverb">crossVerb</code></td>
<td>

<p>Logical scalar.  Should brief &ldquo;progress reports&rdquo; (letting
the user know what is happening with respect to replicate <code>repl</code>,
for each <code>repl</code>) be produced?
</p>
</td></tr>
<tr><td><code id="crossval_+3A_lastpar">lastPar</code></td>
<td>

<p>The last values of the (relevant) fitted paramenters, provided as
an attribute of a component of the list returned by the function
currently under consideration (i.e. <code>crossval()</code>, whenever
the process of fitting the model in question to the training data
did not converge.  These values can be used as starting values so
as to carry on with the fitting process from where the previous
attempt left off.
</p>
</td></tr>
<tr><td><code id="crossval_+3A_...">...</code></td>
<td>

<p>Possible additional arguments to be passed to <code>eglhmm()</code> via
<code>update()</code>, e.g. <code>itmax</code>, <code>tolerance</code>, ... .
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>On each replication a random subset comprising <code>frac</code> of
the data is selected to serve as training data.  The complement
of this subset is used as validation data.  The model specified
by <code>model</code> is fitted to the training data.  It is possible
to over-ride some of the details of the specifications producing
<code>model</code>, via the <code>...</code> argument of <code>crossval()</code>.
After the model is fitted to the training data, the log likelihood
of the validation data is calculated on the basis of that
fitted model.
</p>
<p>If the procedure for fitting a model to the training data fails
to converge, then the corresponding entry of the list returned by
this function is <code>NA</code>.  In this case, the entry is assigned an
attribute <code>lastPar</code>, (the estimates of the model parameters
that were current when the fitting algorithm terminated)
which will in turn have attributes <code>trnDat</code>, <code>valDat</code>
(the training data in question and the corresponding validation
data), and <code>seed</code> (the value of the seed that was set before
the sampling that determined <code>trnDat</code> and <code>valDat</code>
took place).  The value of <code>seed</code> is <code>SEEDS[i]</code>
(if <code>nrep&gt;1</code> and the entry in question was the <code>i</code>th
entry of the returned list) or the value of the <code>seed</code>
argument of this function or its random replacement if this
argument was not supplied (if <code>nrep==1</code>).
</p>
<p>The attribute <code>lastPar</code> enables the user to continue the
procedure for fitting a model to the training data, starting
from where the procedure, that failed to converge, left off.
Continuing the procedure is easily effected by calling
<code>crossval()</code> with argument <code>par0</code> set equal to the
<code>lastPar</code> attribute of the relevant entry of the list that
was previously returned by this function.
</p>
<p>If <code>type==1</code> then the training and validation data are
created in a somewhat subtle manner.  The procedure necessitates
referring to the &ldquo;original&rdquo; data.  The data frame that
is passed to <code>eglhmm()</code> is a &ldquo;replicated&rdquo; version
of the original data, with each row of the original data being
repeated once for each level of <code>state</code> (and a <code>"state"</code>
column &mdash; factor &mdash; being added to the resulting data frame).
If <code>type==2</code> the procedure is conceptually simpler.
The procedure in the <code>type==1</code> setting is as follows:
</p>

<ul>
<li><p> Let <code class="reqn">S</code> be the set of indices of all non-missing values
in the column of the original data that contains the emissions.
</p>
</li>
<li><p> Select at random a subset <code class="reqn">V</code> of <code class="reqn">S</code> so that
the size of <code class="reqn">V</code> is the fraction <code>frac</code> of the size
of <code class="reqn">S</code>.
</p>
</li>
<li><p> Let <code class="reqn">T</code> be the complement in <code class="reqn">S</code> of <code class="reqn">V</code>.
</p>
</li>
<li><p> The training data are formed by replacing by <code>NA</code> all
those values of the emissions column in the original data whose
indices are in <code class="reqn">T</code>.
</p>
</li>
<li><p> The validation data are formed
by replacing by <code>NA</code> all those values of the emissions
column in the original data, whose indices are in <code class="reqn">V</code>.
</p>
</li>
<li><p> Then replicate both the training and validation data in
the manner described above.
</p>
<p>If <code>type==2</code> then the training data are formed by selecting
at random a fraction <code>frac</code> of the levels of the column of
<code>data</code> named <code>"id"</code>.  (If there is no such column, an
error is thrown.)  The training data then consist of those rows
of <code>data</code> corresponding to the selected levels of <code>id</code>.
The validation data then consist of those rows of <code>data</code>
which are not in the training data.
</p>
</li></ul>



<h3>Value</h3>

<p>If <code>nrep&gt;1</code> the returned value is list of length <code>nrep</code>.
The <code>i</code>th entry of this list is the log likelihood of the
validation data with respect to the model fitted to the training
data, for the <code>i</code>th random selection of these two subsets.
This entry will be <code>NA</code> if the attempt to fit a model
to the training data was unsuccessful.  The <code>i</code>th entry
has an attribute <code>seed</code> (singular) which is the value of
the seed that was set prior to the random sampling that chose
the training and validation data.  If the <code>i</code>th entry is
<code>NA</code> it will also have an attribute <code>lastPar</code> which
in turn will have attributes <code>trnDat</code> and <code>valDat</code>.
See <b>Details</b>.
</p>
<p>If <code>nrep&gt;1</code> then the returned value also has an attribute
<code>seeds</code> (plural) which is vector of length <code>nrep+1</code>,
consisting of the &ldquo;auxiliary&rdquo; seed vector <code>SEEDS</code>
(see the argument <code>seed</code>) together with the &ldquo;over all&rdquo;
seed (possibly equal to the <code>seed</code> argument) that was set for
the random number generator before any sampling was undertaken.
Note that the <code>i</code>th entry of this <code>seeds</code> attribute
is the same as the <code>seed</code> attribute of the <code>i</code>th entry
of the returned valuel
</p>
<p>If <code>nrep==1</code> then the returned value is a single numeric
scalar which is the log likelihood of the validation data or
<code>NA</code> if the fitting procedure did not converge for the
training data.  It has an attribute <code>seed</code> which is equal
to the <code>seed</code> argument or its random replacement.  If the
value is <code>NA</code> then it has a further attribute <code>lastPar</code>.
(See above.)
</p>


<h3>Note</h3>

<p>If the function fails to fit the model, obtained from the training
data, to the validation data, then the value returned is <code>NA</code>.
This value will have an attribute <code>lastPar</code>.  This attribute
will in turn have attributes, <code>trnDat</code> and <code>valDat</code>,
the training data and validation data which were being used
in the failed fitting procedure.  Supplying an appropriate
value of <code>lastPar</code> enables the continuation of the fitting
procedure, starting from where the procedure previously left off.
See <b>Details</b> for a little more information.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a><br />
</p>


<h3>References</h3>

<p>Celeux, Gilles and Durand, Jean-Baptiste (2008).  Selecting
hidden Markov model state number with cross-validated likelihood.
<em>Computational Statistics</em> <b>23</b> 541&ndash;564, <code>DOI
10.1007/s00180-007-0097-1</code>.
</p>
<p>Smyth, Padhraic (2000).  Model selection for probabilistic clustering
using cross-validated likelihood.  <em>Statistics and Computing</em>
<b>9</b> 63&ndash;72.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eglhmm">eglhmm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ids   &lt;- paste0("s",1001:1101)
cc  &lt;- ccSim[ccSim$id 
cc$id &lt;- factor(cc$id)
cvll1 &lt;- vector("list",9)
set.seed(42)
SEEDS &lt;- sample(1:1e6,9)
for(k in 1:9) {
    cat("k =",k,"started\n")
    fit  &lt;- eglhmm(categMC ~ 1, distr="M", method="em", data=cc, K=k,
                   itmax=1500,cells="id",verb=TRUE)
    cvll1[[k]] &lt;- crossval(fit,nrep=5,type=2,seed=SEEDS[k],tolerance=1e-4,
                           verbose=FALSE,crossVerb=TRUE)
    cat("k =",k,"finished\n")
}

## End(Not run)
fit   &lt;- eglhmm(y ~ 1, data=Downloads,K=4,distr="P",verb=TRUE,cf="singlecell")
# Use artifically low value of itmax so that crossval() fails to
# fit the model to the training data
cvll2 &lt;- crossval(fit,nrep=5,type=1,verbose=TRUE,seed=322596,itmax=5)
cvll3 &lt;- crossval(fit,type=1,verbose=TRUE,lastPar=attr(cvll2[[1]],"lastPar"))
# So cvll3 carried on, in one instance, from where the first
# attempted fit in cvll2 gave up.

</code></pre>

<hr>
<h2 id='eglhmm'> Fit (extended) generalised linear hidden Markov models.</h2><span id='topic+eglhmm'></span>

<h3>Description</h3>

<p>Fits an (extended) generalised linear model to a data set where the
response in each &ldquo;cell&rdquo; of the model consists of a
time series whose serial dependence is modelled by a
hidden Markov model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eglhmm(formula = NULL, response = NULL, data,
      distr = c("Gaussian", "Poisson", "Binomial", "Dbd", "Multinom", "discnp"),
      inclTau=TRUE,preSpecSigma=NULL, indep = NULL, size = NULL, nbot = NULL, ntop = NULL,
      cells = NULL, cf = "singlecell", K = NULL, par0 = NULL, randStart = NULL,
      method = c("lm", "em", "bf"), optimiser = c("optim", "nlm"),
      optimMethod = "BFGS", nlmWarn = FALSE, lmc = 10, tolerance = NULL,
      digits = NULL, verbose = FALSE, itmax = 200,
      contrast = c("treatment", "sum", "helmert"),
      crit = c("CLL", "L2", "Linf", "ABSGRD"), breaks = NULL, hessian = FALSE,
      useAnalGrad = FALSE, ca = FALSE, checkDecrLL=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eglhmm_+3A_formula">formula</code></td>
<td>

<p>A model formula specifying the linear predictor for the model. The
formula should <em>not</em> include <code>state</code> as a predictor
variable.  The variable <code>state</code> gets added to the formula
automatically.  Ignored if the model is bivariate, i.e. if the
length of <code>response</code> is 2.
</p>
</td></tr>
<tr><td><code id="eglhmm_+3A_response">response</code></td>
<td>

<p>A character scalar or a length-2 vector of such scalars,
specifying the name or names of the response(s).
If <code>response</code> is not specified (i.e. if it is left as
<code>NULL</code>) then <code>formula</code> (see below) <em>must</em> be
specfied and <code>response</code> is taken to be the left hand side
of <code>formula</code>.  (In this case, it is of course univariate.)
</p>
</td></tr>
<tr><td><code id="eglhmm_+3A_data">data</code></td>
<td>

<p>A data frame with columns providing the response(s) and the predictor
variables in the model.
</p>
</td></tr>
<tr><td><code id="eglhmm_+3A_distr">distr</code></td>
<td>

<p>Character string specifying the distribution of the response(s)
(&ldquo;emissions&rdquo;) variable(s).  Currently (13/02/2024) the only
distributions accommodated are Gaussian, Poisson, Binomial, Dbd,
and Multinom.  Note that <code>"discnp"</code> is just an alternative
expression for <code>"Multinom"</code>.  Ignored if the response is
bivariate, in which case <code>distr</code> is forcibly set equal
to <code>"Multinom"</code>.  I.e.  bivariate models are, currently,
fitted only to data in which the emissions have the <code>"Multinom"</code>
distribution.
</p>
</td></tr>
<tr><td><code id="eglhmm_+3A_incltau">inclTau</code></td>
<td>

<p>Logical scalar. Should the transition probability matrix parameters
&ldquo;<code>tau</code>&rdquo; be included in those that are estimated via the
Hessian/gradient pardigm? In this case, they are included in the
set of parameters to which the gradient and Hessian are applicable.
If not, they are estimated via the method of moments as is done
when the EM algorithm is used.  In this latter case the dimensions
of the Hessian are reduced (by a substantial amount if <code>K</code>
is &ldquo;large&rdquo;).
</p>
</td></tr>
<tr><td><code id="eglhmm_+3A_prespecsigma">preSpecSigma</code></td>
<td>

<p>Numeric vector of length <code>K</code> (see below) with strictly
positive entries.  Ignored if <code>distr</code> is not equal to
<code>"Gaussian"</code>. This vector provides &ldquo;pre-specified&rdquo;
values of the standard deviations <code>sigma</code> of the Gaussian
distribution associated with each state.  If <code>preSpecSigma</code>
is specified, then it is used as the value of <code>sigma</code>
throughout the fitting process, and <code>sigma</code> is <em>not</em>
estimated from the data. If <code>distr</code> is <code>"Gaussian"</code>
and <code>preSpecSigma</code> is specified, then an error will be thrown
if the length of <code>preSpecSigma</code> is not equal to <code>K</code>, or
if any entries of <code>preSpecSigma</code> fail to be strictly positive.
</p>
</td></tr>
<tr><td><code id="eglhmm_+3A_indep">indep</code></td>
<td>

<p>Logical scalar; should the components of a bivariate
model be considered to be independent?  Ignored unless the
model is bivariate (i.e. unless <code>response</code> is of length 2.
If the model is bivariate and <code>indep</code> is not specified,
an error is thrown.
</p>
</td></tr>
<tr><td><code id="eglhmm_+3A_size">size</code></td>
<td>

<p>Scalar integer specifying the number of trials in the experiment generating
binomial data (see the <code>size</code> argument of <code><a href="stats.html#topic+dbinom">dbinom</a>()</code>).
Ignored unless <code>distr</code> is equal to <code>"Binomial"</code>.
</p>
</td></tr>
<tr><td><code id="eglhmm_+3A_nbot">nbot</code></td>
<td>

<p>Scalar integer specifying the lower end (0 or 1) of the range
of values of the discretised Beta distribution.  Ignored unless
<code>distr</code> is <code>"Dbd"</code>.
</p>
</td></tr>
<tr><td><code id="eglhmm_+3A_ntop">ntop</code></td>
<td>

<p>Scalar integer specifying the upper end of the range of values
of the discretised Beta distribution.  Ignored unless <code>distr</code>
is <code>"Dbd"</code>.
</p>
</td></tr>
<tr><td><code id="eglhmm_+3A_cells">cells</code></td>
<td>
<p>A character vector giving the names of the factors
(columns of the <code>data</code> data frame) which determine what the
&ldquo;cells&rdquo; of the model are considered to be.  The cells
correspond to the combinations of levels of the factors named
by <code>cells</code>.  The sequences of observations from each of
the cells constitute a collection of independent time series,
all following the specified model.
</p>
</td></tr>
<tr><td><code id="eglhmm_+3A_cf">cf</code></td>
<td>
<p>A factor (&ldquo;cell factor&rdquo;) specifying the cells
of the model.  If <code>cells</code> is not specified, then <code>cf</code>
must be.  If <code>cells</code> <em>is</em> specified, then <code>cf</code>
is ignored.  the model.  If <code>cells</code> is not specified, then
in most (if not all?) circumstances, <code>cf</code> should be set
equal <code>factor(rep(1,nrow(data))</code>.  This the effect of making
the entire observation sequence equal to a single time series,
following the specified model.
</p>
</td></tr>
<tr><td><code id="eglhmm_+3A_k">K</code></td>
<td>

<p>Scalar integer specifying the number of states of the hidden Markov
model in question.  If <code>K</code> is not specified and <code>par0</code>
(see below) <em>is</em> specified, and has a component <code>tpm</code>,
then <code>K</code> is set equal to <code>nrow(tpm)</code>.  In this case,
if <code>par0</code> does not have a <code>tpm</code> component, an error
is thrown.  An error is also thrown in this setting if <code>K</code>
is specified to a value different from <code>nrow(tpm)</code>.
</p>
</td></tr>
<tr><td><code id="eglhmm_+3A_par0">par0</code></td>
<td>

<p>A list comprising starting values for the parameter estimates,
to be used by the various methods.  (See <code>method</code> below.)
This list may have components <code>tpm</code> (an estimate of the
transition probability matrix), <code>phi</code> (a vector of estimates
of the coefficients in the linear predictor in the generalised
linear model) and <code>Rho</code> (a matrix, a list of two matrices,
or a three dimensional array) that specifyies the emission
probabilities when <code>distr</code> is <code>"Multinomial"</code>.  Note that
<code>par0</code> may consist of an object of class <code>"eglhmm"</code>
(see below), i.e. a model previously fitted (perhaps without
achieving convergence), by <code>eglhmm()</code>.  This provides a
means whereby a fitting procedure, that failed to converge,
may be continued from where it left off.
</p>
</td></tr>
<tr><td><code id="eglhmm_+3A_randstart">randStart</code></td>
<td>

<p>Either a logical scalar or a list of three logical scalars
named <code>tpm</code>, <code>phi</code>, and <code>Rho</code>.  If the former,
it is converted internally into a list with entries named
<code>tpm</code>, <code>phi</code> and <code>Rho</code>, all having the same
value as the original argument.  If <code>tpm</code> is TRUE then the
(undocumented) function <code>inititialise()</code> chooses entries
for the starting value of <code>tpm</code> at random; likewise for
<code>phi</code> and <code>Rho</code>.  If left <code>NULL</code>, this argument
defaults to <code>list(tpm=FALSE,phi=FALSE,Rho=FALSE)</code>.
</p>
</td></tr>
<tr><td><code id="eglhmm_+3A_method">method</code></td>
<td>

<p>Character string specifying the method used to fit the model. This
may be <code>"lm"</code> (Levenberg-Marquardt algorithm), <code>"em"</code>
(EM algorithm) or <code>"bf"</code> (&ldquo;brute force&rdquo;).  The latter
calls upon <code><a href="stats.html#topic+optim">optim</a>()</code> or <code><a href="stats.html#topic+nlm">nlm</a>()</code> to do the
heavy lifting).  If the response is bivariate, then <code>method</code>
is forcibly (and silently) set equal to <code>"em"</code>.
</p>
</td></tr>
<tr><td><code id="eglhmm_+3A_optimiser">optimiser</code></td>
<td>

<p>Character string specifying which of <code>optim()</code> or <code>nlm()</code>
should be used when <code>method</code> is <code>"bf"</code>.  Ignored unless
<code>method</code> is <code>"bf"</code>.
</p>
</td></tr>
<tr><td><code id="eglhmm_+3A_optimmethod">optimMethod</code></td>
<td>

<p>Character string specifying the optimisation method to be used
by <code>optim()</code>.  See <code><a href="stats.html#topic+optim">optim</a>()</code> for details.
Ignored unless <code>method</code> is <code>"bf"</code> and <code>optimiser</code>
is <code>"optim"</code>.
</p>
</td></tr>
<tr><td><code id="eglhmm_+3A_nlmwarn">nlmWarn</code></td>
<td>

<p>The <code>nlm()</code> function sometimes produces, in the first few
iterations,  warnings to the effect &ldquo;NA/Inf
replaced by maximum positive value&rdquo;.  These warnings are almost
surely irrelevant and are annoying.  If <code>nlmWarn</code> is <code>FALSE</code>
(the default) then these warnings are suppressed.  This argument
is provided to allow for the remote possibilty that the user might
want to see these warnings.
</p>
</td></tr>
<tr><td><code id="eglhmm_+3A_lmc">lmc</code></td>
<td>

<p>Positive numeric scalar.  The initial &ldquo;Levenberg-Marquardt
constant&rdquo;.  Ignored unless <code>method</code> is <code>"lm"</code>.
</p>
</td></tr>
<tr><td><code id="eglhmm_+3A_tolerance">tolerance</code></td>
<td>

<p>Positive numeric scalar.  The convergence tolerance to be used.
What this value actually <em>means</em> depends upon <code>method</code>.
If left as <code>NULL</code> it defaults to <code>1e-6</code> for the bivariate
methods, to <code>sqrt(.Machine$double.eps</code> for the <code>"em"</code>
and <code>"lm"</code> methods, and to the default value of <code>reltol</code>
used by <code>optim()</code> when <code>method</code> is <code>"bf"</code> and
<code>optimiser</code> is <code>"optim"</code>.  It is ignored if <code>method</code>
is <code>"bf"</code> and <code>optimiser</code> is <code>"nlm"</code>.
</p>
</td></tr>
<tr><td><code id="eglhmm_+3A_digits">digits</code></td>
<td>

<p>Integer scalar. The number of digits to which &ldquo;progress
reports&rdquo; are printed when <code>verbose</code> (see below) is
<code>TRUE</code>.  There is a &ldquo;sensible&rdquo; default which is
calculated in terms of <code>tolerance</code>.  This argument is ignored
if <code>method</code> is <code>"bf"</code>.
</p>
</td></tr>
<tr><td><code id="eglhmm_+3A_verbose">verbose</code></td>
<td>

<p>Logical scalar; if <code>TRUE</code>, rudimentary &ldquo;progress
reports&rdquo; are printed out at appropriate points during the
iteration process.  The nature of these &ldquo;reports&rdquo; varies
with <code>method</code>.
</p>
</td></tr>
<tr><td><code id="eglhmm_+3A_itmax">itmax</code></td>
<td>

<p>Integer scalar.  The maximum number of iterative steps to
take.  Has a somewhat different meaning when <code>method</code> is
<code>"bf"</code>, in which case the meaning depends on <code>optimiser</code>.
For methods <code>"em"</code> and <code>"lm"</code>, if convergence is
not achieved by <code>itmax</code> steps, the function gives up,
prints a message to this effect, and returns a value with a
component <code>converged=FALSE</code>.  This returned value may be
used as a starting (the value of the argument <code>par0</code>) so
that the iterations may be continued from where they left off.
Unfortunately this facility is not available when <code>method</code>
is <code>"bf"</code>.
</p>
</td></tr>
<tr><td><code id="eglhmm_+3A_contrast">contrast</code></td>
<td>

<p>Text string specifying the contrast (in respect of
unordered factors) (see <code><a href="stats.html#topic+contrasts">contrasts</a>()</code> and
<code><a href="base.html#topic+options">options</a>()</code>) that will be used when the design matrix
is constructed from the model formula.  May be abbreviated
(e.g. to &quot;t&quot;, &quot;s&quot; or &quot;h&quot;).
</p>
</td></tr>
<tr><td><code id="eglhmm_+3A_crit">crit</code></td>
<td>

<p>Text string specifying the stopping criterion to be used.
Possible values are &ldquo;CLL&rdquo; (scaled change in log likelihood),
&ldquo;L2&rdquo; (scaled square root of the sum of squares of the
changes in the parameter estimates), &ldquo;Linf&rdquo; (scaled maximum
of the absolute value of the changes in the parameter estimates),
and &ldquo;ABSGRD&rdquo; (scaled maximum of the absolute values of
the entries of the gradient vector).  The latter only makes sense
for the Levenberg-Marquardt algorithm.
</p>
<p>This argument is ignored if <code>method</code> is <code>"bf"</code>.
It seems that the <code>"bf"</code> method effectively uses &ldquo;CLL&rdquo;
when <code>optimiser</code> is <code>"optim"</code>.  When <code>optimiser</code>
is <code>"nlm"</code> it seems that a combination of (something like)
&ldquo;ABSGRD&rdquo; and &ldquo;CLL&rdquo; is used.
</p>
</td></tr>
<tr><td><code id="eglhmm_+3A_breaks">breaks</code></td>
<td>

<p>A vector of <code>K+1</code> values used to construct a set of guesses
at the states corresponding to each observation.  These are
in turn used to calculate an initial estimate of the transition
probability matrix.  There is a &ldquo;sensible&rdquo; default (produced
by the undocumented function <code>breaker()</code>.
</p>
</td></tr>
<tr><td><code id="eglhmm_+3A_hessian">hessian</code></td>
<td>

<p>Logical scalar; should a Hessian matrix obtained by numerical
differentiation be returned?  Ignored unless <code>method</code>
is <code>"bf"</code>.
</p>
</td></tr>
<tr><td><code id="eglhmm_+3A_useanalgrad">useAnalGrad</code></td>
<td>

<p>Logical scalar; should &ldquo;analytical&rdquo; calculation of the
gradient be conducted?  This argument is ignored unless the method
is <code>"bf"</code>.
</p>
</td></tr>
<tr><td><code id="eglhmm_+3A_ca">ca</code></td>
<td>

<p>Logical scalar; &ldquo;check analyticals&rdquo;.  Used only when
the method is <code>"bf"</code> and <code>optimiser</code> is <code>"nlm"</code>,
and is passed on to <code><a href="stats.html#topic+nlm">nlm</a>()</code>.
</p>
</td></tr>
<tr><td><code id="eglhmm_+3A_checkdecrll">checkDecrLL</code></td>
<td>

<p>Logical scalar; &ldquo;check for a <em>decrease</em> in the log likelihood&rdquo;.
Ignored unless the <code>method</code> is <code>"em"</code>.  Should the software
check for a decrease in the log likelihood after an EM step?  See
the <b>Remarks</b> for further discussion.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"eglhmm"</code>, consisting of a list with
components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The call by which this object was created.  Present
so that <code>update()</code> can be applied to objects returned by
<code>eglhmm()</code>.</p>
</td></tr>
<tr><td><code>tpm</code></td>
<td>
<p>The estimated transition probability matrix.</p>
</td></tr>
<tr><td><code>ispd</code></td>
<td>
<p>The estimated initial state probability distribution.</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>Except for the <code>"Multinom"</code> distribution this
is the vector of estimated coefficients of the linear predictor
in the generalised linear model.  For the <code>"Multinom"</code>
distribution it consists of the entries of <code>Rho</code> (see below)
with the final all-zero column remove.  In this case <code>phi</code>
is of course redundant.</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>The vector of parameter estimates that the estimation
procedure actually works with. It consists of the catenation of
the non-redundant parameterization of the transition probability
matrix and the vector <code>phi</code>. It is redundant in the case of
the <code>"Multinom"</code> distribution.</p>
</td></tr>
<tr><td><code>Rho</code></td>
<td>
<p>A matrix, or a list of two matrices or a three dimensional
array specifying the emissions probabilities for a multinomial
distribution.  Present only if <code>distr</code> is <code>"Multinom"</code>.</p>
</td></tr>
<tr><td><code>log.like</code></td>
<td>
<p>The value of the log likelihood of the model
evaluated at the parameter estimates, i.e. the (approximately)
maximal value of the log likelihood.</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>
<p>(Not present for the <code>"em"</code> method.) The gradient
vector of the log likelihood at the final parameter estimates;
it <em>should</em> be effectively the zero vector.</p>
</td></tr>
<tr><td><code>numHess</code></td>
<td>
<p>(Present only if <code>method</code> is <code>"bf"</code>
and only if the argument <code>hessian</code> is <code>TRUE</code>.)  A value
of the Hessian matrix (see below), obtained by means of numerical
differentiation.</p>
</td></tr>
<tr><td><code>Hessian</code></td>
<td>
<p>(Present only if <code>method</code> is <code>"lm"</code>.) The
Hessian matrix, i.e. the matrix of second partial derivatives of
the log likelihood, evaluated at the final parameter estimates.
The inverse of the negative of this matrix constitutes an estimate
of the covariance matrix of the parameter estimates.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>A data frame with <code>npred+1</code> columns where <code>npred</code>
is the number of predictors in the model.  The rows contain, in their
first <code>npred</code> entries, all possible combinations of the predictor
values.  The last (<code>npred+1</code>) entry of each row is the fitted mean
of the Gaussian distribution, as determined by that combination
of predictors.  Present only if <code>distr</code> is <code>"Gaussian"</code>.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Numeric vector of length <code>K</code> whose entries
consist of the fitted standard deviations for the underlying
Gaussian distribution, corresponding to each of the states.
Present only if <code>distr</code> is <code>"Gaussian"</code> and
<code>preSpecSigma</code> is <em>not</em> supplied.</p>
</td></tr>
<tr><td><code>preSpecSigma</code></td>
<td>
<p>Numeric vector equal to the <code>preSpecSigma</code>
argument, with names <code>"sigma1"</code>, <code>"sigma2"</code>, ...,
<code>"sigmaK"</code> added.  Present only if <code>distr</code> is
<code>"Gaussian"</code> and <code>preSpecSigma</code> is supplied.</p>
</td></tr>
<tr><td><code>stopCritVal</code></td>
<td>
<p>Numeric scalar equal to the value, assumed by the
stopping criterion specified by the argument <code>crit</code>, at
the termination of the algorithm.  If the algorithm converged
then <code>stopCritVal</code> will be less than <code>tolerance</code>.
Not present if <code>method</code> is <code>"bf"</code>.  If <code>converged</code>
(see below) is <code>NA</code> then <code>stopCritVal</code> is <code>NA</code>
also.</p>
</td></tr>
<tr><td><code>anomaly</code></td>
<td>
<p>Logical scalar.  Did an &ldquo;anomaly&rdquo; occur
in an application of the EM algorithm?  (See <b>Remarks</b>.) '
Present only if <code>method</code> was equal to <code>"em"</code>.  This
entry of the returned value is provided mainly for use by the
<code>bcov()</code> function. Note that <code>anomaly</code> is added to the
returned object, irrespective of the value of <code>checkDecrLL</code>.
When <code>checkDecrLL</code> is <code>TRUE</code>, <code>anomaly</code> is
somewhat redundant, since it will be <code>TRUE</code> if aand only if
<code>converged</code> is <code>NA</code>.  However when <code>checkDecrLL</code>
is <code>FALSE</code>, <code>anomaly</code> is informtive, since it is not
possible to tell from other entries of the returned value when
an anomaly has occurred.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>A logical scalar.  For the <code>"lm"</code>, and
<code>"em"</code> methods it is <code>TRUE</code> if convergence is achieved
within <code>itmax</code> iterations and <code>FALSE</code> otherwise.
For the <code>"em"</code> method, if <code>checkDecrLL</code> is <code>TRUE</code>,
then <code>converged</code> may be <code>NA</code>.  See <b>Remarks</b>
for some discussion.
</p>
<p>For the <code>"bf"</code> method <code>converged</code> is <code>TRUE</code>
if the <code>convergence</code> component of the object returned by
<code><a href="stats.html#topic+optim">optim</a>()</code> is equal to 0 or if the <code>code</code>
component of the object returned by <code><a href="stats.html#topic+nlm">nlm</a>()</code> is
less than or equal to 2, and is <code>FALSE</code> otherwise.  When
<code>nlm()</code> is used, the value of <code>converged</code> has an attribute
<code>"code"</code> equal to the actual value of the <code>code</code>
component.</p>
</td></tr>
<tr><td><code>nstep</code></td>
<td>
<p>The number of steps (iterations) actually used by
the algorithm.  For the <code>"lm"</code> and <code>"em"</code> methods
this is the number of Levenberg-Marquardt steps, or EM steps,
respectively, taken by the algorithm.  For the <code>"bf"</code>
method it is the <code>counts</code> component of the object returned
by <code><a href="stats.html#topic+optim">optim</a>()</code> when <code>optimiser</code> is <code>"optim"</code>
and it is the <code>iterations</code> component of the object returned by
<code><a href="stats.html#topic+nlm">nlm</a>()</code> when <code>optimiser</code> is <code>"nlm"</code>.</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>A vector of the fitted mean values underlying each
combination of observed predictors and state (i.e. corresponding to each
entry of <code>y</code> in the data frame used to fit the model.
See the description of <code>data</code> below.  Present only if
<code>distr</code> is <code>"Gaussian"</code>.</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>A vector of the fitted values of the standard
deviations underlying each combination of observed predictors and state,
i.e. corresponding to each entry of <code>y</code> in the data frame
used to fit the model.  See the description of <code>data</code> below.
Present only if <code>distr</code> is <code>"Gaussian"</code>.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>A vector of estimated values of the Poisson
parameter associated with each combination of observed predictors and state,
i.e. corresponding to each entry of <code>y</code> in the data frame
used to fit the model.  See the description of <code>data</code> below.
Present only if <code>distr</code> is <code>"Poisson"</code>.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>A vector of estimated values of the &ldquo;success&rdquo;
probabilities associated with each combination of observed
predictors and state, i.e. corresponding to each entry of
<code>y</code> in the data frame used to fit the model.  See the
description of <code>data</code> below.  Present only if <code>distr</code>
is <code>"Binomial"</code>.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>A numeric vector of the fitted &ldquo;alpha&rdquo;
parameters, of the discretised Beta distribution, corresponding to
each observation.  Present only if <code>distr</code> is <code>"Dbd"</code>.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>A numeric vector of the fitted &ldquo;beta&rdquo;
parameters, of the discretised Beta distribution, corresponding to
each observation.  Present only if <code>distr</code> is <code>"Dbd"</code>.</p>
</td></tr>
<tr><td><code>fy</code></td>
<td>
<p>The values of the &ldquo;emission probability (density)&rdquo;
function, calculated at each observed value, for each state
(i.e. at each entry of <code>y</code> in <code>data</code>.  See below.)
These values are calculated using the (final) fitted parameters.</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>A (long) text string that is produced if the EM
algorithm encounters the anomaly of a decrease in the log
likelihood after an EM step.  It warns the user that this has
occurred and suggests consulting the help file for an explanation.
Present only if <code>method=="em"</code>, the anomaly referred to
has occurred, and <code>checkDecrLL</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code>par0</code></td>
<td>
<p>The starting values used in the estimation procedure.
Either those provided by the argument <code>par0</code> or those created
by the (undocumented) function <code>initialise</code>.</p>
</td></tr>
<tr><td><code>cells</code></td>
<td>
<p>A character vector indicating the names of the
factors specifying the &ldquo;cells&rdquo; of the model.  (Equal to
the <code>cells</code> argument.)</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The formula for the model that was fitted; equal
to the <code>formula</code> argument, augmented by <code>state</code>.</p>
</td></tr>
<tr><td><code>distr</code></td>
<td>
<p>Text string specifying the distribution of the
response variable.  Equal to the <code>distr</code> argument of this
function.</p>
</td></tr>
<tr><td><code>nbot</code></td>
<td>
<p>Integer scalar. The lower endpoint of the range of
values of the discretised beta distribution.  Equal to the value
of the <code>nbot</code> argument of this function.  Present only if
<code>distr</code> is <code>"Dbd"</code>.</p>
</td></tr>
<tr><td><code>ntop</code></td>
<td>
<p>Integer scalar. The upper endpoint of the range of
values of the discretised beta distribution.  Equal to the value
of the <code>nbot</code> argument of this function.  Present only if
<code>distr</code> is <code>"Dbd"</code>.</p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>Scalar integer equal to the number of trials in the
&ldquo;experiments&rdquo; generating the data.  Equal to the <code>size</code>
argument of this function.  Present only if <code>distr</code> is
<code>"Binomial"</code>.</p>
</td></tr>
<tr><td><code>tolerance</code></td>
<td>
<p>The convergence tolerance used to fit the model.
Equal to the <code>tolerance</code> argument.</p>
</td></tr>
<tr><td><code>crit</code></td>
<td>
<p>Character scalar specifying the stopping criterion
that was used. Equal to the <code>crit</code> argument of this function.
Not present if <code>method</code> is <code>"bf"</code>.</p>
</td></tr>
<tr><td><code>contrast</code></td>
<td>
<p>Text string specifying the contrast for unordered
factors that was used in fitting the model.  Equal to the
<code>contrast</code> argument of this function.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method (<code>"lm"</code>, <code>"em"</code>, or <code>"bf"</code>
used to fit the model.  Equal to the <code>method</code> argument.</p>
</td></tr>
<tr><td><code>stationary</code></td>
<td>
<p>Logical scalar.  Was a stationary Markov
chain fitted?  Currently (13/02/2024) <code>stationary</code> is always
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The data frame to which the model was fitted.
It is a rearrangement of the <code>data</code> argument, with rows of
that argument replicated <code>K</code> times (once for each state).
A <code>state</code> column (factor) has been added, as has a column
<code>cf</code> (&ldquo;cell factor&rdquo;), which indicates, by means of a
single factor, which cell of the model a given row of <code>data</code>
corresponds to.  The aforementioned rearrangement consists of
ordering the cells in the order of the levels of <code>cf</code>.
When <code>distr</code> is <code>"Multinom"</code> the <code>"response"</code>
variables are coerced into factors. </p>
</td></tr>
<tr><td><code>bicm</code></td>
<td>
<p>Numerical scalar.  The number by which <code>npar</code>
is multiplied to form the <code>BIC</code> criterion.  It is
essentially the log of the number of observations.  See the
code of <code>eglhmm()</code> for details.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Numerical scalar.  The Akaike Information criterion,
calculated as <code>-2*ll + 2*npar</code> where <code>ll</code> is the log
likelihood of the fitted model and <code>npar</code> is the number of
fitted parameters.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Numerical scalar.  The Bayesian Information criterion,
calculated as <code>-2*ll + bicm*npar</code> where <code>ll</code> is the log
likelihood of the fitted model, <code>npar</code> is the number of
fitted parameters, and <code>bicm</code> is the log of the number of
observations.</p>
</td></tr>
<tr><td><code>missFrac</code></td>
<td>
<p>The fraction or proportion of missing values in
the observations.</p>
</td></tr>
</table>


<h3>Remarks</h3>


<dl>
<dt><b>Available models:</b></dt><dd><p>Although this documentation refers to
(extended) &ldquo;generalised linear models&rdquo;, the only such
models currently (13/02/2024) available are the Gaussian model
with the identity link, the Poisson model, with the log link,
and the Binomial model with the logit link.  When <code>distr</code>
is <code>"Dbd"</code> or <code>"Multinom"</code> the model fitted is is
a generalised linear model only in a rather extended sense.
Even the Gaussian model is not strictly speaking a generalised
linear model, since the (state dependent) standard deviations
are estimated by a method separate from the generalised linear
model paradigm.  Other models may be added at a future date.</p>
</dd>
<dt><b>Decrease in the log likelihood:</b></dt><dd>
<p>If <code>method</code> is equal to <code>"EM"</code> there may be a
<em>decrease</em> (!!!) in the log likelihood at some EM step.
This is &ldquo;theoretically impossible&rdquo; but can occur in
practice due to an intricacy in the way that the EM algorithm
treats <code>ispd</code> when <code>stationary</code> is <code>TRUE</code>.
It turns out to be effectively impossible to maximise the expected
log likelihood unless the term in that quantity corresponding
to <code>ispd</code> is ignored (whence it <em>is</em> ignored).
Ignoring this term is &ldquo;asymptotically negligible&rdquo; but
can have the unfortunate effect of occasionally leading to a
decrease in the log likelihood.  If <code>method</code> is equal
to <code>"em"</code>, then the object returned by <code>eglhmm()</code>
has a component <code>anomaly</code> which is <code>TRUE</code> if such
a decrease in the log likelihood was detected, and <code>FALSE</code>
otherwise.
</p>
<p>If such a decrease/anomaly is detected, then (provided that
<code>checkDecrLL</code> is <code>TRUE</code>) the algorithm terminates and
the <code>converged</code> component of the returned value is set equal
to <code>NA</code>.  The algorithm issues a message to the effect that
the decrease occurred.  The message suggests that another method
be used and that perhaps the results from the penultimate EM step
(which are returned by this function) be used as starting values.
This of course is not possible if the response is bivariate,
in which case only the EM algorithm is applicable.
</p>
<p>Note that if <code>checkDecrLL</code> is <code>FALSE</code>, then the algorithm
proceeds &ldquo;normally&rdquo;.  That is, it treats the decrease in
the log likelihood to mean that the &ldquo;increase&rdquo; in the
log likeihood is less than <code>tolerance</code> and deems convergence
to be achieved.
</p>
<p>The value of <code>checkDecrLL</code> is set to <code>FALSE</code> in the
function <code><a href="#topic+bcov">bcov</a>()</code> so as to speed up the rate at which
the iterations proceed.  In other circumstances it is probably
judicious to leave it at its default value of <code>TRUE</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>T. Rolf Turner, Murray A. Cameron, and Peter J. Thomson
(1998).  Hidden Markov chains in generalized linear models.
<em>Canadian Journal of Statististics</em> <b>26</b>, pp. 107 &ndash;
125, DOI: https://doi.org/10.2307/3315677.
</p>
<p>Rolf Turner (2008).  Direct maximization of the likelihood of a
hidden Markov model. <em>Computational Statistics
and Data Analysis</em> <b>52</b>, pp. 4147 &ndash; 4160, DOI:
https://doi.org/10.1016/j.csda.2008.01.029
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fitted.eglhmm">fitted.eglhmm</a>()</code> <code><a href="#topic+reglhmm.default">reglhmm.default</a>()</code>
<code><a href="#topic+reglhmm.eglhmm">reglhmm.eglhmm</a>()</code> <code><a href="#topic+bcov">bcov</a>()</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>    loc4 &lt;- c("LngRf","BondiE","BondiOff","MlbrOff")
    SCC4 &lt;- SydColCount[SydColCount$locn %in% loc4,] 
    SCC4$locn &lt;- factor(SCC4$locn) # Get rid of unused levels.
    rownames(SCC4) &lt;- 1:nrow(SCC4)
    fitP.em &lt;- eglhmm(y~locn+depth,data=SCC4,distr="P",cells=c("locn","depth"),
                    K=2,method="em",verb=TRUE)
    ## Not run: 
        fitP.lm &lt;- eglhmm(y~locn+depth,data=SCC4,distr="P",cells=c("locn","depth"),
                        K=2,verb=TRUE)
        fitD.lm &lt;- eglhmm(formula=y~ma.com+nh.com+bo.com,data=SCC4,nbot=0,ntop=11,
                      cells=c("locn","depth"),distr="Dbd",K=2,method="lm",verb=TRUE,
                      tolerance=NULL)
        SCD4 &lt;- SydColDisc[SydColDisc$locn %in% loc4,] 
        SCD4$locn &lt;- factor(SCD4$locn) # Get rid of unused levels.
        fitM.lm  &lt;- eglhmm(formula=y~ma.com+nh.com+bo.com,data=SCD4,
                      cells=c("locn","depth"),distr="Multinom",K=2,
                      verb=TRUE)
        xxx &lt;- split(SCD4,f=SCD4$locn)
        X   &lt;- with(xxx,data.frame(y.LngRf=LngRf$y,y.BondiE=BondiE$y,depth=LngRf$depth))
        fitBiv &lt;- eglhmm(response=c("y.LngRf","y.BondiE"),data=X,K=2,cells="depth",
                         indep=FALSE,verb=TRUE)
    
## End(Not run)
# See the help for ionChannelData for more examples involving the
# ion channel data.
</code></pre>

<hr>
<h2 id='eglhmm-internal'>Internal eglhmm functions.</h2><span id='topic+binForm'></span><span id='topic+bivdepPhi2Rho'></span><span id='topic+bivdepRho2Phi'></span><span id='topic+checkRho'></span><span id='topic+checkTpm'></span><span id='topic+checkYval'></span><span id='topic+cnvrtRho'></span><span id='topic+derivpi'></span><span id='topic+derivp'></span><span id='topic+doKeq1'></span><span id='topic+dotzp'></span><span id='topic+eglhmmBf'></span><span id='topic+eglhmmEm'></span><span id='topic+eglhmmLm'></span><span id='topic+eglhmmBD'></span><span id='topic+eglhmmBI'></span><span id='topic+ell'></span><span id='topic+expForm2p'></span><span id='topic+fakeStates'></span><span id='topic+ffun'></span><span id='topic+fixTau'></span><span id='topic+forGetHgl'></span><span id='topic+getHgl'></span><span id='topic+getIspd'></span><span id='topic+getLL'></span><span id='topic+getModComps'></span><span id='topic+getMu'></span><span id='topic+getTpm'></span><span id='topic+initialise'></span><span id='topic+initRho'></span><span id='topic+llDiff'></span><span id='topic+llKeq1'></span><span id='topic+lmstep'></span><span id='topic+logistic'></span><span id='topic+logit'></span><span id='topic+lse'></span><span id='topic+misstify'></span><span id='topic+msRho'></span><span id='topic+nafracCalc'></span><span id='topic+ordinal'></span><span id='topic+ordinalsuffix'></span><span id='topic+origData'></span><span id='topic+p2expForm'></span><span id='topic+phi2Rho'></span><span id='topic+ragg'></span><span id='topic+recurse'></span><span id='topic+reviseIspd'></span><span id='topic+reviseModel'></span><span id='topic+reviseRho'></span><span id='topic+reviseSigma'></span><span id='topic+reviseTau'></span><span id='topic+reviseTheta'></span><span id='topic+reviseTpm'></span><span id='topic+revSigUnwtd'></span><span id='topic+rho2Phi'></span><span id='topic+saGetHgl'></span><span id='topic+saSubGetHgl'></span><span id='topic+sasubrf1'></span><span id='topic+simMlt'></span><span id='topic+simSngl'></span><span id='topic+steepest'></span>

<h3>Description</h3>

<p>Internal eglhmm functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binForm(fmla)
bivdepPhi2Rho(phi,ijk)
bivdepRho2Phi(Rho)
checkRho(Rho,K,rsplvls,indep)
checkTpm(tpm)
checkYval(yval,Rho,type,warn=TRUE) 
cnvrtRho(Rho)
derivpi(ispd,tpm,npar,dp)
derivp(npar,K,tau=NULL,expo=FALSE)
doKeq1(data,fmla,distr,preSpecSigma,response,indep,size,nbot,ntop,bicm,nafrac)
dotzp(tvec,K,inclTau,preSpecSigma)
ell(phi,G)
expForm2p(x)
fakeStates(data,K,fmla)
ffun(data,fmla,response,Rho,type)
fixTau(tpm)
forGetHgl(nd,theta,data,fmla,inclTau=TRUE,preSpecSigma=NULL)
getHgl(nd,distr,theta,data,fmla,size,nbot,ntop)
getIspd(theta,K)
getLL(rp)
getModComps(distr,fmla,data,theta,size,nbot,ntop)
getMu(gmu,data,fmla)
getTpm(theta,K)
eglhmmBf(formula,data,distr,theta,size,nbot,ntop,
         optimiser,optimMethod,nlmWarn,hessian,useAnalGrad,ca,
         itmax,tolerance,verbose) 
eglhmmEm(formula,data,distr,preSpecSigma,size,tau,zeta,phi,
         mixture=FALSE,itmax=200,crit="CLL",tolerance=NULL,
         digits=NULL,verbose=FALSE,checkDecrLL=TRUE)
eglhmmLm(formula,data,distr,inclTau,preSpecSigma,size,nbot,ntop,
         tau,zeta,phi,lmc=10,mixture=FALSE,itmax=200,crit,
         tolerance=NULL,digits=NULL,verbose=FALSE) 
eglhmmBD(data,par0,K,response,tolerance,digits,verbose,itmax,crit)
eglhmmBI(data,par0,K,response,tolerance,digits,verbose,itmax,crit)
initialise(distr,data,formula,rsplvls,par0,K,preSpecSigma,size,
           nbot,ntop,breaks,randStart,indep)
initRho(data,K,fmla,randStart,indep,rsplvls)
llDiff(new.ll,old.ll,tolerance)
llKeq1(data,object)
lse(z)
lmstep(theta,data,fmla,distr,size,nbot,ntop,lmc)
logistic(eta)
logit(mu)
misstify(y,response,nafrac,fep=NULL)
msRho(Rho0,G)
nafracCalc(data,response)
ordinal(k)
ordinalsuffix(k)
origData(rData)
p2expForm(x)
phi2Rho(phi,K,rhovals,preds)
ragg(theta,data,fmla,distr,size=NULL,nbot=NULL,ntop=NULL,delta=0.01)
recurse(fy,tpm,level=2L)
reviseIspd(tpm)
reviseModel(formula,data,distr,preSpecSigma,size)
reviseRho(data,response,fmla,type)
reviseSigma(r,weights,state)
reviseTau(distr,fmla,data,theta,size,nbot,ntop)
reviseTheta(tvec,theta,distr,fmla,data,size,nbot,ntop)
reviseTpm(xisum,mixture)
revSigUnwtd(phi,X,y,state)
rho2Phi(Rho)
saGetHgl(nd,theta,data,fmla,inclTau=TRUE,preSpecSigma=NULL)
saSubGetHgl(nd,fy,gmu,sd,y,tdm,tpm,xispd,d1pi,d2pi,kstate,
            npar,npt,nxc,d1p,d2p,alpha,alphw,a,b,aw,bw,xlc,
            hess,xl) 
sasubrf1(y,gmu,sd,fy,tdm,kstate,npar,npt,nxc,nd)
simMlt(formula,response,distr,data,ispd,tpm,phi,Rho,
       sigma,size,ntop,zeta,missFrac,fep)
simSngl(distr,tpm,ispd,nt,mlp,Rho,yvals,datxl,fmla,response,
        sig,size,ntop,zeta,mf,fep)
steepest(tvec,theta,data,fmla,distr,size,nbot,ntop)
</code></pre>


<h3>Details</h3>

<p>These functions are auxiliary and are not intended to be called
by the user.  In particular sasubrf1(), saGetHgl(), saSubGetHgl()
and forGetHgl() are for debugging purposes only
</p>


<h3>Value</h3>

<p>All of the functions listed above return values.  These
values vary widely in nature, and are passed on to the
relevant calling functions.  However these values are not
observed directly by users.
</p>

<hr>
<h2 id='fitted.eglhmm'> Predict method for extended generalised linear hidden Markov models. </h2><span id='topic+fitted.eglhmm'></span>

<h3>Description</h3>

<p>Predicted values based on an extended generalised linear hidden Markov model
object. </p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'eglhmm'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.eglhmm_+3A_object">object</code></td>
<td>
<p> An object of class <code>eglhmm</code> as returned
by <code><a href="#topic+eglhmm">eglhmm</a>()</code>. </p>
</td></tr>
<tr><td><code id="fitted.eglhmm_+3A_...">...</code></td>
<td>
<p> Not used. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of fitted values of the same length as that of the
observed values (i.e. length equal to the row dimension of the
data frame to which the model was fitted.  This data frame is
equal to <code>object$data</code> but with repeated rows corresponding to
different states collapsed to a single row.  The row dimension of
this data frame is thus <code>nrow(object$data)/K</code> where <code>K</code>
is the number of states in the model.  This data frame, with
columns <code>cf</code> and <code>state</code> omitted, is returned as an
attribute <code>data</code> of the vector of fitted values.
</p>


<h3>Remark</h3>

<p>Although this documentation refers to &ldquo;generalised linear
models&rdquo;, the only such models currently (13/02/2024) available are
the Gaussian model with the identity link, the Poisson model,
with the log link, and the Binomial model with the logit link.
Other models may be added at a future date.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>See the help for <code><a href="#topic+eglhmm">eglhmm</a>()</code> for references.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+reglhmm">reglhmm</a>()</code> <code><a href="#topic+reglhmm.default">reglhmm.default</a>()</code>
<code><a href="#topic+reglhmm.eglhmm">reglhmm.eglhmm</a>()</code> <code><a href="#topic+bcov">bcov</a>()</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>    loc4 &lt;- c("LngRf","BondiE","BondiOff","MlbrOff")
    SCC4 &lt;- SydColCount[SydColCount$locn %in% loc4,] 
    SCC4$locn &lt;- factor(SCC4$locn) # Get rid of unused levels.
    rownames(SCC4) &lt;- 1:nrow(SCC4)
    fit &lt;- eglhmm(y~locn+depth,data=SCC4,cells=c("locn","depth"),
                 K=2,distr="P",contr="sum",verb=TRUE)
    fv  &lt;- fitted(fit)
    with(attr(fv,"data"),plot(y[locn=="BondiOff" &amp; depth=="40"],
             xlab="time",ylab="count"))
    with(attr(fv,"data"),lines(fv[locn=="BondiOff" &amp; depth=="40"]))
</code></pre>

<hr>
<h2 id='hydroData'>
Canadian hydrological data sets.
</h2><span id='topic+linLandFlows'></span><span id='topic+ftLiardFlows'></span><span id='topic+portMannFlows'></span><span id='topic+portMannSedLoads'></span><span id='topic+portMannSedCon'></span>

<h3>Description</h3>

<p>Five data sets obtained from the &ldquo;HYDAT&rdquo; database,
Environment and Climate Change Canada's database of historical
hydrometric data.  The data were obtained using the <code>tidyhydat</code>
package.  The data have been trimmed so that there are no gaps in
the observation dates and are presented in &ldquo;raw&rdquo; form and in
discretised form as deciles of the residuals (difference between
raw values and the daily mean over years).
</p>


<h3>Format</h3>

<p>Data frames with observations on the following 5 variables.
</p>

<dl>
<dt><code>Date</code></dt><dd><p>Dates on which observations were made.</p>
</dd>
<dt><code>Value</code></dt><dd><p>Numeric vector of observation values.</p>
</dd>
<dt><code>mean</code></dt><dd><p>The mean over years of <code>Value</code>.</p>
</dd>
<dt><code>resid</code></dt><dd><p>The difference <code>Value - mean</code>.</p>
</dd>
<dt><code>deciles</code></dt><dd><p>A factor with levels <code>d1</code>, ..., <code>d10</code>,
which are the deciles of the variable <code>resid</code></p>
</dd>
</dl>



<h3>Details</h3>

<p>The variable <code>mean</code> was calculated as follows:
</p>
<pre>
        yday &lt;- as.POSIXlt(X$Date)$yday
        mn   &lt;- tapply(X$Value,yday,mean,na.rm=TRUE)
        mean &lt;- mn[as.character(yday)]
   </pre>
<p>where <code>X</code> is the data set being processed.
</p>
<p>The data sets are named <code>linLandFlows</code>, <code>ftLiardFlows</code>,
<code>portMannFlows</code>, <code>portMannSedLoads</code> and
<code>portMannSedCon</code>.
</p>
<p>The data set <code>linLandFlows</code> originally consisted of 2008 observations;
there were 1980 observations after &ldquo;trimming&rdquo;.
The data set <code>ftLiardFlows</code> originally consisted of 22364 observations;
there were 11932 observations after &ldquo;trimming&rdquo;.
The data set <code>portMannFlows</code> originally consisted of 6455 observations;
there were 3653 observations after &ldquo;trimming&rdquo;.
The data set <code>portMannSedLoads</code> consists of 2771 observations;
no observations were trimmed.
The data set <code>portMannSedCon</code> consists of 4597 observations;
no observations were trimmed.
</p>
<p>The units of the &ldquo;Flows&rdquo; variables are cubic metres per
second (<code class="reqn">m^3/s</code>); the units of &ldquo;portMannSedLoads&rdquo;
are tonnes; the units of &ldquo;portMannSedCon&rdquo; are milligrams
per litre (mg/l).
</p>
<p>The &ldquo;linLandFlows&rdquo; data were obtained at the Lindberg
Landing hydrometric station on the Liard River in the Northwest
Territories of Canada.  The &ldquo;ftLiardFlows&rdquo; data were
obtained at the Fort Liard hydrometric station on the Liard River
in the Northwest Territories of Canada.  The &ldquo;portMann&rdquo;
data were obtained at the hydrometric station located at the
Port Mann pumping station on the Fraser River in the Province
of British Columbia in Canada.
</p>


<h3>Source</h3>

<p>Environment and Climate Change Canada's database &ldquo;HYDAT&rdquo;,
a database of historical hydrometric data.  The data were obtained
vis the <code>tidyhydat</code> package, which is available from &ldquo;CRAN&rdquo;,
<code>https://cran.r-project.org</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- eglhmm(deciles ~ 1,K=4,distr="M",data=linLandFlows,
              method="em",itmax=10,verb=TRUE)
</code></pre>

<hr>
<h2 id='ionChannelData'>
Ion channel data
</h2><span id='topic+ionChannelData'></span><span id='topic+ic25kHz_12_sgmnt1'></span><span id='topic+ic25kHz_13_sgmnt2'></span><span id='topic+ic25kHz_14_sgmnt2'></span><span id='topic+ic25kHz_15_sgmnt2'></span><span id='topic+ic50kHz_06_sgmnt2'></span><span id='topic+ic50kHz_08_sgmnt2'></span><span id='topic+ic50kHz_09_sgmnt1'></span><span id='topic+ic50kHz_10_sgmnt1'></span>

<h3>Description</h3>

<p>Time series of observations, made by means of patch clamps, of
current in picoamps, across cell membranes.
</p>


<h3>Notes</h3>

<p>The data sets are named <code>ic25kHz_12_sgmnt1</code>,
<code>ic25kHz_13_sgmnt2</code>, <code>ic25kHz_14_sgmnt2</code>,
<code>ic25kHz_15_sgmnt2</code>, <code>ic50kHz_06_sgmnt2</code>,
<code>ic50kHz_08_sgmnt2</code>, <code>ic50kHz_09_sgmnt1</code> and
<code>ic50kHz_10_sgmnt1</code>.
</p>
<p>These data are <b>not</b> immediately available in the <code>eglhmm</code>
package.  Their presence would cause the size of the <code>data</code>
directory to exceed 4.5 Mb., which is unacceptably large.
Consequently these data sets have been placed in a separate
&ldquo;data only&rdquo; package called <code>ionChannelData</code>, which
is available from <code>github</code>.  This package may be obtained by
executing the command:
</p>
<pre>
    install.packages("ionChannelData",repos="https://rolfturner.r-universe.dev")
</pre>
<p>After having installed the <code>ionChannelData</code> package, you may
load it via <code>library(ionChannelData)</code> and then access the data
sets in the usual way, e.g. <code>X &lt;- ic25kHz_12_sgmnt1</code>.
</p>
<p>Alternatively (after having installed the <code>ionChannelData</code>
package) you may use the <code>::</code> syntax to access a single data
set, e.g. <code>X &lt;- ionChannelData::ic25kHz_12_sgmnt1</code>.
</p>
<p>You can access the documentation via,
e.g. <code>?ionChannelData::ionChannelData</code>.
</p>

<hr>
<h2 id='miscprints'>
Specialised print methods.
</h2><span id='topic+print.RhoExpForm'></span><span id='topic+print.RhoProbForm'></span><span id='topic+print.kitty'></span>

<h3>Description</h3>

<p>Print objects of class <code>"RhoExpForm"</code>, <code>"RhoProbForm"</code>
and <code>"kitty"</code>, appropriately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RhoExpForm'
print(x, ...)
## S3 method for class 'RhoProbForm'
print(x, ...)
## S3 method for class 'kitty'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="miscprints_+3A_x">x</code></td>
<td>
<p>An object of class <code>"RhoExpForm"</code>,
<code>"RhoProbForm"</code> or <code>"kitty"</code> respectively.
</p>
</td></tr>
<tr><td><code id="miscprints_+3A_...">...</code></td>
<td>

<p>Not used.  Present for compatibility with the generic
<code>print()</code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The methods <code>print.RhoExpForm()</code> and
<code>print.RhoProbForm()</code> are present essentially for debugging
purposes only.  The method <code>print.kitty()</code> is present to
improve the appearance of printed output from <code>eglhmm</code>
when there is a <code>"message"</code> component of this output.
None of these methods would normally be called by users.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>

<hr>
<h2 id='monoCyteSim'>
Simulated monocyte counts and psychosis symptoms.
</h2><span id='topic+monoCyteSim'></span><span id='topic+bivarSim'></span><span id='topic+ccSim'></span>

<h3>Description</h3>

<p>Discretised values of monocyte counts, and ratings of level of
psychosis simulated from a model fitted to a data set consisting of
observations made on a number of patients from the Northland District
Health Board system.  The real data must be kept confidential due
to ethics constraints.
</p>


<h3>Notes</h3>

<p>The data sets are named <code>bivarSim</code> and <code>cSim</code>.
</p>
<p>These data are <b>not</b> immediately available in the <code>eglhmm</code>
package.  Their presence would cause the size of the <code>data</code>
directory to exceed 4.5 Mb., which is unacceptably large.
Consequently these data sets have been placed in a separate
&ldquo;data only&rdquo; package called <code>monoCyteSim</code>, which is
available from <code>github</code>.  This package may be obtained by
executing the command:
</p>
<pre>
    install.packages("monoCyteSim",repos="https://rolfturner.r-universe.dev")
</pre>
<p>After having installed the <code>monoCyteSim</code> package, you may load
it via <code>library(monoCyteSim)</code> and then access the data sets
in the usual way, e.g. <code>X &lt;- ccSim</code>.
</p>
<p>Alternatively (after having installed the <code>monoCyteSim</code>
package) you may use the <code>::</code> syntax to access a single data
set, e.g. <code>X &lt;- monoCyteSim::ccSim</code>.
</p>
<p>You can access the documentation via, e.g., <code>?monoCyteSim::ccSim</code>.
</p>

<hr>
<h2 id='plot.eglhmm'>
Plot the results of an eglhmm fit.
</h2><span id='topic+plot.eglhmm'></span>

<h3>Description</h3>

<p>For each specified model cell plot an array, with one panel
for each state, of the probability mass or density functions
corresponding to the given cell and state.  The plots are
produced with <code>type="h"</code> for probability mass functions,
and with <code>type="l"</code> for probability density functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'eglhmm'
plot(x, ..., wcells = NULL, col = "red",
             nrnc = NULL, ntop = NULL, xlab = NULL, ylab = NULL,
             xlim = NULL, ylim = NULL, main = NULL, cex.main = 1.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.eglhmm_+3A_x">x</code></td>
<td>

<p>An object of class <code>"eglhmm"</code> as returned by the function
<code><a href="#topic+eglhmm">eglhmm</a>()</code>.
</p>
</td></tr>
<tr><td><code id="plot.eglhmm_+3A_...">...</code></td>
<td>

<p>Not used.
</p>
</td></tr>
<tr><td><code id="plot.eglhmm_+3A_wcells">wcells</code></td>
<td>

<p>Character vector specifying the cells of the model to be plotted.
Defaults to all cells (i.e. the levels of <code>x$data$cf</code>).
</p>
</td></tr>
<tr><td><code id="plot.eglhmm_+3A_col">col</code></td>
<td>

<p>The colour for the (vertical) lines of the plots.
</p>
</td></tr>
<tr><td><code id="plot.eglhmm_+3A_nrnc">nrnc</code></td>
<td>

<p>An integer vector of length two specifying the dimenions of the
array of plots that is produced.  The first entry is the number
of rows, the second the number of columns.  The product of the
entries must be greater than or equal to <code>K</code>, the number of
states in the model.
</p>
</td></tr>
<tr><td><code id="plot.eglhmm_+3A_ntop">ntop</code></td>
<td>

<p>The largest <code>x</code>-value to be used in plots of the Poisson
distribution.  Defaults
to the maximum of the upper <code class="reqn">10^{-7}</code> quantile of
all of the Poisson distributions that are to be plotted.
Ignored unless <code>x$distr</code> is <code>"Poisson"</code>.
</p>
</td></tr>
<tr><td><code id="plot.eglhmm_+3A_xlab">xlab</code></td>
<td>

<p>An optional label for the <code class="reqn">x</code>-axes of the panels in the array
of plots.  Defaults to <code>"x"</code>.
</p>
</td></tr>
<tr><td><code id="plot.eglhmm_+3A_ylab">ylab</code></td>
<td>

<p>An optional label for the <code class="reqn">y</code>-axes of the panels in the array
of plots.  Defaults to <code>"probability"</code> for probability mass
functions and to <code>"probability density"</code> for probability
density functions.
</p>
</td></tr>
<tr><td><code id="plot.eglhmm_+3A_xlim">xlim</code></td>
<td>

<p>An optional vector of length two, specifying the <code>x</code>-limits
for the plots.  Defaults to <code>c(0,ntop)</code> if <code>x$distr</code> is
<code>"Poisson"</code> and to <code>c(0,x$size)</code> if <code>x$distr</code> is
<code>"Binomial"</code>.  There is no default if <code>x$distr</code> is
<code>"Gaussian"</code>.
</p>
</td></tr>
<tr><td><code id="plot.eglhmm_+3A_ylim">ylim</code></td>
<td>

<p>An optional vector of length two, specifying the <code>y</code>-limits
for the plots.  Defaults to <code>c(0,M)</code>  where <code>M</code> is
the maximum of all of the probabilities or probability density
values that are to be plotted.
</p>
</td></tr>
<tr><td><code id="plot.eglhmm_+3A_main">main</code></td>
<td>

<p>Optional character vector specifying overall titles for each
array panel of plots.  Defaults to the names of the model cells.
If the length of <code>main</code> is less than the number (<code>nwc</code>)
of cells to be plotted, then main is replicated to have length
<code>nwc</code>.  If the length of main is greater than <code>nwc</code>
then entries with index greater than <code>nwc</code> are ignored.
If you wish there to be no overall titles for the arrays of plots,
specify <code>main=""</code>.
</p>
</td></tr>
<tr><td><code id="plot.eglhmm_+3A_cex.main">cex.main</code></td>
<td>

<p>Expansion factor for the text in the main title (determining
the size of the text).  Ignored if <code>main</code> is set equal
to the empty string.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If plotting is interactive, then the arrays of plots are displayed
one at a time, and (except for the last of the plots) the user is
prompted with the string <code>"Go?"</code> after each array is plotted.
Press <code>&lt;return&gt;</code> to see the next plot.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eglhmm">eglhmm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    loc4 &lt;- c("LngRf","BondiE","BondiOff","MlbrOff")
    SCC4 &lt;- SydColCount[SydColCount$locn %in% loc4,]
    SCC4$locn &lt;- factor(SCC4$locn) # Get rid of unused levels.
    rownames(SCC4) &lt;- 1:nrow(SCC4)
    fit &lt;- eglhmm(y~locn+depth,data=SCC4,cells=c("locn","depth"),
                 K=2,distr="P",verb=TRUE)
    plot(fit)
    allcells &lt;- levels(fit$data$cf)
    wcells   &lt;- allcells[grep("\\.60",allcells)]
    plot(fit,wcells=wcells,main=c("Longreef","Bondi East","Bondi Offshore",
                                  "Malabar Offshore"),ntop=12)
</code></pre>

<hr>
<h2 id='postHocGradHess'>
Obtain gradient and Hessian, post hoc.
</h2><span id='topic+postHocGradHess'></span>

<h3>Description</h3>

<p>Calculates the gradient and Hessian of the log likelihood of
an extended generalised hidden Markov model, from the components
of a <code>"eglhmm"</code> object, or in certain circumstances, simply
extracts these quantities from that object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postHocGradHess(object,inclTau=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postHocGradHess_+3A_object">object</code></td>
<td>

<p>An object of class <code>"eglhmm"</code> as returned by <code><a href="#topic+eglhmm">eglhmm</a>()</code>.
</p>
</td></tr>
<tr><td><code id="postHocGradHess_+3A_incltau">inclTau</code></td>
<td>

<p>Logical scalar; should the vector of &ldquo;<code>tau</code>&rdquo; parameters
be included in the parameters under consideration?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>object</code> is the result of fitting a bivariate model (i.e.
if it inherits from <code>"eglhmm.bivariate"</code> then an error
is thrown.  (No gradient or Hessian is available in this case.)
</p>
<p>If <code>object$method</code> is <code>"lm"</code> and if <code>inclTau</code>
matches the value used in fitting <code>method</code>, then the
appropriate gradient and Hessian have already been calculated
and are simply extracted from <code>object</code>.  If <code>inclTau</code>
does not match the value used in fitting <code>method</code>, then
the gradient and Hessian are recalculated (by the undocumented
function <code>getHgl()</code>) with the value of <code>inclTau</code> being
that specified by the function argument.
</p>
<p>If <code>object$method</code> is <code>"em"</code> or <code>"bf"</code>, then the
gradient and Hessian are calculated (by the undocumented function
<code>getHgl()</code>) with the value of <code>inclTau</code> being that
specified by the function argument.
</p>
<p>If <code>object$method</code> is <code>"bf"</code> then the gradient has
been calculated numerically and the Hessian <em>may</em> have
been calculated numerically (f the argument <code>hessian</code>
of <code>eglhmm()</code> was set equal to <code>TRUE</code>).  The
corresponding value of the gradient will comprise a component,
named <code>"numGrad"</code>, of the list returned by this function.
The corresponding value of the Hessian, if this was indeed
calculated, will comprise a component, named <code>"numHess"</code>,
of the list returned by this function.
</p>


<h3>Value</h3>

<p>A list with components
</p>

<ul>
<li> <p><code>gradient</code>: The gradient of the log likelihood.
</p>
</li>
<li> <p><code>Hessian</code>: The Hessian of the log likelihood.
</p>
</li>
<li> <p><code>numGrad</code>: The numerically calculated gradient of the log likelihood.
Present only if <code>object$method</code> is <code>"bf"</code>.
</p>
</li>
<li> <p><code>numHess</code>: The numerically calculated Hessian of the log likelihood.
Present only if <code>object$method</code> is <code>"bf"</code> and if argument
<code>hessian</code> was set equal to <code>TRUE</code> in the call to <code>eglhmm()</code>
that produced <code>object</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>R. Nazim Khan, (2002). <em>Statistical modelling and analysis of ion
channel data based on hidden Markov models and the EM algorithm</em>.
Ph.D. thesis, the University of Western Australia, Crawley, WA 6009.
</p>
<p>David Oakes, Direct calculation of the information matrix via the EM
algorithm (1999).  <em>Journal of the Royal Statistical Society</em>,
series B, <b>61</b>, pp. 479 &ndash; 482.
</p>
<p>Theodore C. Lystig and James P. Hughes (2002). Exact computation
of the observed information matrix for hidden Markov models.
<em>Journal of Computational and Graphical Statistics</em>, <b>11</b>
(3), pp. 678 &ndash; 689.
</p>
<p>Olivier Capp and Eric Moulines (July 2005).  Recursive computation
of the score and observed information matrix in hidden Markov
models, <em>IEEE Workshop on Statistical Signal Processing</em>,
Bordeaux.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eglhmm">eglhmm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit.em &lt;- eglhmm(y~locn+depth,data=SydColCount,distr="P",
                 cells=c("locn","depth"),K=2,method="em",verb=TRUE)
gh.em  &lt;- postHocGradHess(fit.em) # Calculates using inclTau=TRUE.
## Not run: 
    gh.em.noTau &lt;- postHocGradHess(fit.em,inclTau=FALSE)
    fit.lm &lt;- eglhmm(y~locn+depth,data=SydColCount,distr="P",
                     cells=c("locn","depth"),K=2,verb=TRUE)
    gh.lm  &lt;- postHocGradHess(fit.lm) # Just extracts the relevant components.
    gh.lm.noTau  &lt;- postHocGradHess(fit.lm,inclTau=FALSE)
    fit.bf &lt;- eglhmm(y~locn+depth,data=SydColCount,distr="P",
                     cells=c("locn","depth"),K=2,method="bf",verb=TRUE,
                     hessian=TRUE)
    gh.bf  &lt;- postHocGradHess(fit.bf) # Calculates using inclTau=TRUE; also
                                      # extracts numerically computed quantities.
    gh.bf.noTau &lt;- postHocGradHess(fit.bf,inclTau=FALSE) # Calculates; also
                                                         # extracts numerically
                                                         # computed quantities.

## End(Not run)
</code></pre>

<hr>
<h2 id='reglhmm'> Simulate data from a hidden generalised linear Markov
model.</h2><span id='topic+reglhmm'></span><span id='topic+reglhmm.default'></span><span id='topic+reglhmm.eglhmm'></span>

<h3>Description</h3>

<p>Takes a specification of the model and simulates the data from
that model.  The model may be specified in terms of the individual
components of that model (the default method).  The components
include a data frame that provides the predictor variables,
and various parameters of the model.  For the <code>"eglhmm"</code>
method the model is specified as a fitted model, an object of
class <code>"eglhmm"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reglhmm(x,...)
## Default S3 method:
reglhmm(x, formula, response, cells=NULL, data=NULL, nobs=NULL,
                         distr=c("Gaussian","Poisson","Binomial","Dbd","Multinom"),
                         phi, Rho, sigma, size, ispd=NULL, ntop=NULL, zeta=NULL,
                         missFrac = 0, fep=NULL,
                         contrast=c("treatment","sum","helmert"),...)
## S3 method for class 'eglhmm'
reglhmm(x, missFrac = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reglhmm_+3A_x">x</code></td>
<td>

<p>For the default method, the transition probability matrix of
the hidden Markov chain.  For the <code>"eglhmm"</code> method,
an object of class <code>"eglhmm"</code> as returned by the function
<code><a href="#topic+eglhmm">eglhmm</a>()</code>.
</p>
</td></tr>
<tr><td><code id="reglhmm_+3A_formula">formula</code></td>
<td>

<p>The formula specifying the generalised linear model from which data
are to be simulated.  Note that the predictor variables in
this formula must include a factor <code>state</code>, which specifies
the state of the hidden Markov chain.  Note also that this formula
must determine a design matrix having a number of columns equal to
the length of the vector <code>phi</code> of model coefficients provided
in <code>object</code> (and to the length of <code>psi</code> in the case of
the Gaussian distribution).  If this condition is not satisfied,
an error is thrown.
</p>
<p>It is advisable to use a formula specified in the manner
<code>y~0+state+...</code> where <code>...</code> represents the predictors
in the model other than <code>state</code>.  Of course <code>phi</code> must
be supplied in a manner that is consistent with this structure.
</p>
</td></tr>
<tr><td><code id="reglhmm_+3A_response">response</code></td>
<td>
<p>A character vector of length 2, specifying
the names of the responses.  Ignored unless <code>distr</code> is
<code>"Multinom"</code>.  If <code>distr</code> is <code>"Multinom"</code> and if
<code>response</code> is provided appropriately, then the simulated
data are bivariate multinomial.
</p>
</td></tr>
<tr><td><code id="reglhmm_+3A_cells">cells</code></td>
<td>

<p>A character vector specifying the names of the factors which
determine the &ldquo;cells&rdquo; of the model.  These factors must be
columns of the data frame <code>data</code>.  (See below.)  Each cell
corresponds to a time series of (simulated) observations.
If <code>cells</code> is not supplied (left equal to <code>NULL</code>)
then the model is taken to have a single cell, i.e. data from a
&ldquo;simple&rdquo; hidden Markov model is generated.   The parameters
of that model may be time-varying, and still depend on the
predictors specified by <code>formula</code>.
</p>
</td></tr>
<tr><td><code id="reglhmm_+3A_data">data</code></td>
<td>

<p>A data frame containing the predictor variables referred to by
<code>formula</code>, i.e. the predictors for the model from which
data are to be simulated.  If <code>data</code> is not specified,
the <code>nobs</code> (see below) must be.  If <code>data</code> is not
specified then <code>formula</code> must have the structure <code>y ~
  state</code> or preferably <code>y ~ 0 + state</code>.  Of course <code>phi</code>
must be specified in a consistent manner.
</p>
</td></tr>
<tr><td><code id="reglhmm_+3A_nobs">nobs</code></td>
<td>

<p>Integer scalar.  The number of observations to be generated in
the setting in which the generalised linear model in question is
vacuous.  Ignored if <code>data</code> is supplied.
</p>
</td></tr>
<tr><td><code id="reglhmm_+3A_distr">distr</code></td>
<td>

<p>Character string specifying the distribution of the
&ldquo;emissions&rdquo; from the model, i.e., of the observations.
This distribution determines &ldquo;emission probabilities&rdquo;.
</p>
</td></tr>
<tr><td><code id="reglhmm_+3A_phi">phi</code></td>
<td>

<p>A numeric vector specifying  the coefficients of the linear
predictor of the generalised linear model.  The length of
<code>phi</code> must be equal to the number of columns of the
design matrix determined by <code>formula</code> and <code>data</code>.
The entries of <code>phi</code> must match up appropriately with
the columns of the design matrix.
</p>
</td></tr>
<tr><td><code id="reglhmm_+3A_rho">Rho</code></td>
<td>
<p>A matrix, or a list of two matrices or a three dimensional
array specifying the emissions probabilities for a multinomial
distribution.  Ignored unless <code>distr</code> is <code>"Multinomial"</code>.
</p>
</td></tr>
<tr><td><code id="reglhmm_+3A_sigma">sigma</code></td>
<td>

<p>A numeric vector of length equal to the number of states.
Its <code class="reqn">i</code>th entry is the standard deviation of the (Gaussian)
distribution corresponding to the <code class="reqn">i</code>th state.  Ignored unless
<code>distr</code> is <code>"Gaussian"</code>.
</p>
</td></tr>
<tr><td><code id="reglhmm_+3A_size">size</code></td>
<td>

<p>Integer scalar.  The number of trials (sample size) from which
the number of &ldquo;successes&rdquo; are counted, in the context of
the binomial distribution.  (I.e. the <code>size</code> parameter of
<code>rbinom()</code>.)  Ignored unless <code>distr</code> is <code>"Binomial"</code>.
</p>
</td></tr>
<tr><td><code id="reglhmm_+3A_ispd">ispd</code></td>
<td>

<p>An optional numeric vector specifying the initial state probability
distribution of the model. If <code>ispd</code> is not provided then it
is taken to be the stationary/steady state distribution determined
by the transition probability matrix <code>x</code>.  If specified,
<code>ispd</code> must be a <em>probability</em> vector of length equal
to the number of rows (equivalently the number of columns)
of <code>x</code>.
</p>
</td></tr>
<tr><td><code id="reglhmm_+3A_ntop">ntop</code></td>
<td>

<p>Integer scalar, strictly greater than 1.  The maximum possible
value of the db distribution.  See <code><a href="dbd.html#topic+db">db</a>()</code>.
Used only if <code>distr</code> is <code>"Dbd"</code>.
</p>
</td></tr>
<tr><td><code id="reglhmm_+3A_zeta">zeta</code></td>
<td>

<p>Logical scalar.  Should zero origin indexing be used?
I.e. should the range of values of the db distribution be taken to
be <code>{0,1,2,...,ntop}</code> rather than <code>{1,2,...,ntop}</code>?
Used only if <code>distr</code> is <code>"Dbd"</code>.
</p>
</td></tr>
<tr><td><code id="reglhmm_+3A_missfrac">missFrac</code></td>
<td>

<p>A non-negative scalar, less than 1.  Data will be randomly set
equal to <code>NA</code> with probability <code>miss.frac</code>.  Note that
for the <code>"eglhmm"</code> method, if <code>"miss.frac"</code> is not
supplied then it is extracted from <code>object</code>
</p>
</td></tr>
<tr><td><code id="reglhmm_+3A_fep">fep</code></td>
<td>
<p>A list of length 1 or 2.  The first entry of this
list is a logical scalar.  If this is <code>TRUE</code>, then the first
entry of the simulated emissions (or at least one entry of the first
pair of simulated emissions) is forced to be &ldquo;present&rdquo;,
i.e. non-missing.  The second entry of <code>fep</code>, if present, is
a numeric scalar, between 0 and 1 (i.e. a probability).  It
is equal to the probability that both entries of the first
pair of emissions are present.  It is ignored if the emissions
are univariate.  If the emissions are bivariate but the second
entry of <code>fep</code> is not provided, then this second entry defaults
to the &ldquo;overall&rdquo; probability that both entries of a pair of
emission are present, given that at least on is present.
This probability is calculated from <code>nafrac</code>.
</p>
</td></tr>
<tr><td><code id="reglhmm_+3A_contrast">contrast</code></td>
<td>

<p>A character string, one of &ldquo;treatment&rdquo;, &ldquo;helmert&rdquo; or &ldquo;sum&rdquo;,
specifying what contrast (for unordered factors) to use in
constructing the design matrix.  (The contrast for ordered factors,
which is has no relevance in this context, is left at it default
value of <code>"contr.poly"</code>.)  Note that the meaning of the
coefficient vector <code>phi</code> depends on the contrast specified,
so make sure that the contrast is the same as what you had in
mind when you specified phi!!!  Note that for the <code>"eglhmm"</code>
method, <code>contrast</code> is extracted from <code>x</code>.
</p>
</td></tr>
<tr><td><code id="reglhmm_+3A_...">...</code></td>
<td>

<p>Not used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the same columns as those of <code>data</code>
and an added column, whose name is determined from <code>formula</code>,
containing the simulated <em>response</em>
</p>


<h3>Remark</h3>

<p>Although this documentation refers to &ldquo;generalised linear
models&rdquo;, the only such models currently (13/02/2024) available are
the Gaussian model with the identity link, the Poisson model,
with the log link, and the Binomial model with the logit link.
The Multinomial model, which is also available, is not exactly
a generalised linear model; it might be thought of as an
&ldquo;extended&rdquo; generalised linear model.  Other models may be
added at a future date.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>T. Rolf Turner, Murray A. Cameron, and Peter J. Thomson
(1998).  Hidden Markov chains in generalized linear models.
<em>Canadian Journal of Statististics</em> <b>26</b>, pp. 107 &ndash;
125, DOI: https://doi.org/10.2307/3315677.
</p>
<p>Rolf Turner (2008).  Direct maximization of the likelihood of a
hidden Markov model. <em>Computational Statistics
and Data Analysis</em> <b>52</b>, pp. 4147 &ndash; 4160, DOI:
https://doi.org/10.1016/j.csda.2008.01.029
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitted.eglhmm">fitted.eglhmm</a>()</code>
<code><a href="#topic+bcov">bcov</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    loc4 &lt;- c("LngRf","BondiE","BondiOff","MlbrOff")
    SCC4 &lt;- SydColCount[SydColCount$locn %in% loc4,] 
    SCC4$locn &lt;- factor(SCC4$locn) # Get rid of unused levels.
    rownames(SCC4) &lt;- 1:nrow(SCC4)
    Tpm   &lt;- matrix(c(0.91,0.09,0.36,0.64),byrow=TRUE,ncol=2)
    Phi   &lt;- c(0,log(5),-0.34,0.03,-0.32,0.14,-0.05,-0.14)
    # The "state effects" are 1 and 5.
    Dat   &lt;- SCC4[,1:3]
    fmla  &lt;- y~0+state+locn+depth
    cells &lt;- c("locn","depth")
# The default method.
    X     &lt;- reglhmm(Tpm,formula=fmla,cells=cells,data=Dat,distr="P",phi=Phi,
                    miss.frac=0.75,contrast="sum")
# The "eglhmm" method.
    fit &lt;- eglhmm(y~locn+depth,data=SCC4,cells=cells,K=2,
                 verb=TRUE,distr="P")
    Y   &lt;- reglhmm(fit)
# Vacuous generalised linear model.
    Z   &lt;- reglhmm(Tpm,formula=y~0+state,nobs=300,distr="P",phi=log(c(2,7)))
    # The "state effects" are 2 and 7.
</code></pre>

<hr>
<h2 id='reorder.eglhmm'>
Reorder the states of a fitted eglhmm model
</h2><span id='topic+reorder.eglhmm'></span>

<h3>Description</h3>

<p>Reorder the states of a fitted eglhmm model so that the
state effects are in decreasing order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'eglhmm'
reorder(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reorder.eglhmm_+3A_x">x</code></td>
<td>

<p>An object of class <code>"eglhmm"</code> as returned by the function
<code><a href="#topic+eglhmm">eglhmm</a>()</code>.
</p>
</td></tr>
<tr><td><code id="reorder.eglhmm_+3A_...">...</code></td>
<td>

<p>Not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The states of a fitted hidden Markov model are usually in a
rather arbitrary order, which can sometimes make it difficult
to compare different fits.  This function reorders the states
so that the state corresponding to the &ldquo;largest state
effect&rdquo; comes first (and so on down the line). What is meant by
&ldquo;largest state effect&rdquo; depends on whether the distribution
used in the model is &ldquo;Dbd&rdquo;.  If the distribution is
<em>not</em> &ldquo;Dbd&rdquo;, then what is meant is simply the largest
of those entries of <code>phi</code> which correspond to <code>state</code>.
(The vector <code>phi</code> is the vector of coefficients of the
linear predictor in the model.  Note that, since the formula
for the model is constructed as <code>y~0+state+...</code>, the
&ldquo;state&rdquo; coefficients are unconstrained and there are as
many of them as there are states.)
</p>
<p>If the distribution in question <em>is</em> &ldquo;Dbd&rdquo; then things
are a bit more complicated.  We calculate the theoretical expected
values for &ldquo;Dbd&rdquo;s with parameters <code class="reqn">\alpha =</code>
<code>alpha[k]</code> and <code class="reqn">\beta =</code> <code>beta[k]</code> where
<code>alpha[k]</code> and <code>beta[k]</code> are the parameter values
corresponding to the <code>k</code>th state.   The states are then
ordered according to the decreasing order of these expected
values.  These expected values are the expected values of the
emissions given that all predictors other than the <em>state</em>
predictors are zero.
</p>


<h3>Value</h3>

<p>An object of class <code>c("eglhmm","reordered")</code> which
is identical to the argument <code>x</code> in most respects.
The components which (may) differ are:
</p>

<ul>
<li> <p><code>tpm</code>
</p>
</li>
<li> <p><code>ispd</code>
</p>
</li>
<li> <p><code>phi</code>
</p>
</li>
<li> <p><code>theta</code>
</p>
</li>
<li> <p><code>Hessian</code>
</p>
</li>
<li> <p><code>gradient</code>
</p>
</li>
<li> <p><code>mean</code> and <code>sd</code>, or <code>lambda</code> or <code>p</code>,
or <code>alpha</code> and <code>beta</code> (depending on which distribution
is being used)
</p>
</li>
<li> <p><code>fy</code>
</p>
</li></ul>

<p>The entries of these components will have the same numerical
values as before but, given that the ordering of the states has
actually changed, will have different orderings, corresponding
to the new ordering of the states.
</p>
<p>Note that the <em>attribute</em> <code>preSpecSigma</code> of the
component <code>theta</code>, may differ from what it was in <code>x</code>.
</p>
<p>The returned value will also have a component <code>neworder</code>
which is an integer vector providing the indices of the
reordering of the states.  It also currently (13/02/2024) has a
component <code>newlog.like</code>.  This should (if there is any
justice in the world &mdash; but there isn't!) have the same value
as the component <code>log.like</code>.  Once I am confident that
everything is working as it should, the <code>newlog.like</code>
component will be removed.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eglhmm">eglhmm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    loc4 &lt;- c("LngRf","BondiE","BondiOff","MlbrOff")
    SCC4 &lt;- SydColCount[SydColCount$locn %in% loc4,]
    SCC4$locn &lt;- factor(SCC4$locn) # Get rid of unused levels.
    rownames(SCC4) &lt;- 1:nrow(SCC4)
    fit  &lt;- eglhmm(y~locn+depth,data=SCC4,cells=c("locn","depth"),
                  K=2,distr="P",verb=TRUE)
    ofit &lt;- reorder(fit)
</code></pre>

<hr>
<h2 id='SydColDat'>Sydney coliform bacteria data</h2><span id='topic+SydColCount'></span><span id='topic+SydColDisc'></span>

<h3>Description</h3>

<p>Transformed counts of faecal coliform bacteria in sea water
at seven locations: Longreef, Bondi East, Port Hacking &ldquo;50&rdquo;,
and Port Hacking &ldquo;100&rdquo; (controls) and Bondi Offshore, Malabar
Offshore and North Head Offshore (outfalls).  At each location
measurements were made at four depths: 0, 20, 40, and 60 meters.
</p>
<p>The data sets are named <code>SydColCount</code> and <code>SydColDisc</code>.
</p>


<h3>Format</h3>

<p>Data frames with 5432 observations on the following 6 variables.
</p>

<dl>
<dt><code>y</code></dt><dd><p>Transformed measures of the number of faecal
coliform count bacteria in a sea-water sample of some specified
volume.  The original measures were obtained by a repeated
dilution process.
</p>
<p>For <code>SydColCount</code> the transformation used was essentially
a square root transformation, resulting values greater than 150
being set to <code>NA</code>.  The results are putatively compatible
with a Poisson model for the emission probabilities.
</p>
<p>For <code>SydColDisc</code> the data were discretised
using the <code>cut()</code> function with breaks given
by <code>c(0,1,5,25,200,Inf)</code> and labels equal to
<code>c("lo","mlo","m","mhi","hi")</code>.</p>
</dd>
</dl>
<p>Note that in the <code>SydColDisc</code> data there are 180 fewer
missing values (<code>NA</code>s) in the <code>y</code> column than in
the <code>SydColCount</code> data.  This is because in forming
the <code>SydColCount</code> data (transforming the original data
to a putative Poisson distribution) values that were greater
than 150 were set equal to <code>NA</code>, and there were 180 such
values.
</p>
<dl>
<dt><code>locn</code></dt><dd><p>a factor with levels &ldquo;LngRf&rdquo;
(Longreef), &ldquo;BondiE&rdquo; (Bondi East), &ldquo;PH50&rdquo;
(Port Hacking 50), &ldquo;PH100&rdquo;  (Port Hacking 100),
&ldquo;BondiOff&rdquo; (Bondi Offshore), &ldquo;MlbrOff&rdquo; (Malabar
Offshore) and &ldquo;NthHdOff&rdquo; (North Head Offshore)</p>
</dd>
<dt><code>depth</code></dt><dd><p>a factor with levels &ldquo;0&rdquo; (0 metres),
&ldquo;20&rdquo; (20 metres), &ldquo;40&rdquo; (40 metres) and &ldquo;60&rdquo;
(60 metres).</p>
</dd>
<dt><code>ma.com</code></dt><dd><p>A factor with levels <code>no</code> and <code>yes</code>,
indicating whether the Malabar sewage outfall had been commissioned.</p>
</dd>
<dt><code>nh.com</code></dt><dd><p>A factor with levels <code>no</code> and <code>yes</code>,
indicating whether the North Head sewage outfall had been commissioned.</p>
</dd>
<dt><code>bo.com</code></dt><dd><p>A factor with levels <code>no</code> and <code>yes</code>,
indicating whether the Bondi Offshore sewage outfall had been commissioned.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The observations corresponding to each location-depth combination
constitute a time series.  The sampling interval is ostensibly
1 week; distinct time series are ostensibly synchronous.
The measurements were made over a 194 week period.  See Turner
et al. (1998) for more detail.
</p>


<h3>Source</h3>

<p>Geoff Coade, of the New South Wales Environment Protection
Authority (Australia) 
</p>


<h3>References</h3>

<p>T. Rolf Turner, Murray A. Cameron, and Peter J. Thomson.  Hidden
Markov chains in generalized linear models.  Canadian J. Statist.,
vol. 26, pp. 107 &ndash; 125, 1998.
</p>
<p>Rolf Turner.  Direct maximization of the likelihood of a hidden
Markov model. <em>Computational Statistics and Data Analysis</em>
<b>52</b>, pp. 4147 &ndash; 4160, 2008, doi:10.1016/j.csda.2008.01.029.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Select out a subset of four locations:
loc4 &lt;- c("LngRf","BondiE","BondiOff","MlbrOff")
SCC4 &lt;- SydColCount[SydColCount$locn %in% loc4,] 
SCC4$locn &lt;- factor(SCC4$locn) # Get rid of unused levels.
rownames(SCC4) &lt;- 1:nrow(SCC4)
</code></pre>

<hr>
<h2 id='weissData'>
Data from &ldquo;An Introduction to Discrete-Valued Time Series&rdquo;
</h2><span id='topic+weissData'></span><span id='topic+Bovine'></span><span id='topic+Cryptosporidiosis'></span><span id='topic+Downloads'></span><span id='topic+EricssonB_Jul2'></span><span id='topic+FattyLiver'></span><span id='topic+FattyLiver2'></span><span id='topic+goldparticle380'></span><span id='topic+Hanta'></span><span id='topic+InfantEEGsleepstates'></span><span id='topic+IPs'></span><span id='topic+LegionnairesDisease'></span><span id='topic+OffshoreRigcountsAlaska'></span><span id='topic+PriceStability'></span><span id='topic+Strikes'></span><span id='topic+WoodPeweeSong'></span>

<h3>Description</h3>

<p>Data sets from the book
&ldquo;An Introduction to Discrete-Valued Time Series&rdquo; by
Christian H. Wei.
</p>
<p>The data sets are named <code>Bovine</code>, <code>Cryptosporidiosis</code>,
<code>Downloads</code>, <code>EricssonB_Jul2</code>, <code>FattyLiver</code>,
<code>FattyLiver2</code>, <code>goldparticle380</code>,
<code>Hanta</code>, <code>InfantEEGsleepstates</code>, <code>IPs</code>,
<code>LegionnairesDisease</code>, <code>OffshoreRigcountsAlaska</code>,
<code>PriceStability</code>, <code>Strikes</code> and <code>WoodPeweeSong</code>.
</p>


<h3>Format</h3>

<p>Each data set is a data frame with a single column named <code>"y"</code>.
</p>

<ul>
<li> <p><code>Bovine</code>
There are 8419 rows.  The column <code>"y"</code> is a factor,
with levels <code>"a","c","g","t"</code>, the DNA &ldquo;bases&rdquo;.
It constitutes the DNA sequence of the bovine leukemia virus.
</p>
</li>
<li> <p><code>Cryptosporidiosis</code>
There are 365 rows.  The column <code>"y"</code> is a numeric (integer)
vector.  It consists of weekly counts of new infections, in Germany
in the years 2002 to 2008.  The counts vary between 2 and 78.
</p>
</li>
<li> <p><code>Downloads</code>
There are 267 rows.  The column <code>"y"</code> is a numeric
(integer) vector.  It consists of the daily number of downloads
of a TEX editor for the period from June 2006 to February 2007.
These counts vary between 0 and 14.
</p>
</li>
<li> <p><code>EricssonB_Jul2</code>
There are 460 rows.  The column <code>"y"</code> is a numeric (integer)
vector.  It consists of the number of transactions per minute,
of the Ericsson B stock, between 9:35 and 17:14 on 2 July, 2002.
The counts vary between 0 and 37.
</p>
</li>
<li> <p><code>FattyLiver</code>
There are 928 rows.  The column <code>"y"</code> is a numeric (binary)
vector.  The value 1 indicates that &ldquo;the considered
diagnosis cannot be excluded for the current patient; that is,
suitable countermeasures are required&rdquo;, and the value 0 indicates
that this is not so.  The values refer to different patients,
examined sequentially over time.
</p>
</li>
<li> <p><code>FattyLiver2</code>
There are 449 rows.  The column <code>"y"</code> is a numeric (binary)
vector as for <code>FattyLiver</code>.  (Different examiner, different
sequence of patients.)
</p>
</li>
<li> <p><code>goldparticle380</code>
There are 380 rows.  The column <code>"y"</code> is a numeric (integer)
vector of counts of gold particles measured in a fixed volume
element of a colloidal solution over time. The count values
vary because of the Brownian motion of the particles.  They vary
between 0 and 7.
</p>
</li>
<li> <p><code>Hanta</code>
There are 52 rows.  The column <code>"y"</code> is a numeric (integer)
vector consisting of the weekly number of territorial units (out of <code class="reqn">n = 38</code>
territorial units with at least one new case of a hantavirus infections,
in the year 2011.  The numbers vary between 0 and 11. 
</p>
</li>
<li> <p><code>InfantEEGsleepstates</code>
There are 107 rows.  The column <code>"y"</code> is a factor with
levels <code>qt, qh, tr, al, ah, aw</code>.  The level <code>"aw"</code>
does not actually appear.
</p>
</li>
<li> <p><code>IPs</code>
There are 241 rows.  The column <code>"y"</code> is a numeric (integer)
vector of the counts of different IP addresses registered at a
web server within periods of length two minutes, &ldquo;assumed&rdquo;
to have been observed between 10:00 a.m. and 6:00 p.m. on 29
November 2005.  The counts vary between 0 and 8.
</p>
</li>
<li> <p><code>LegionnairesDisease</code>
There are 365 rows.  The column <code>"y"</code> is a numeric (integer)
vector of weekly counts of new infections in Germany, in the
years 2002 to 2008.  The counts vary between 0 and 26.
</p>
</li>
<li> <p><code>OffshoreRigcountsAlaska</code>
There are 417 rows.  The column <code>"y"</code> is a numeric (integer)
vector of weekly counts of active rotary drilling rigs in Alaska
for the period 1990 to 1997. The counts vary between 0 and 6.
</p>
</li>
<li> <p><code>PriceStability</code>
There are 152 rows.  The column <code>"y"</code> is a numeric (integer)
vector of monthly counts of countries (out of a group of 17
countries) that showed stable prices (that is, an inflation rate
below 2%), in the period from January 2000 to December 2006.
The counts vary between 0 and 17.
</p>
</li>
<li> <p><code>Strikes</code>
There are 108 rows.  The column <code>"y"</code> is a numeric (integer)
vector of the monthly counts of work stoppages (strikes and
lock-outs) of 1000 or more workers in the period 1994 to 2002.
The counts vary between 0 and 14.
</p>
</li>
<li> <p><code>WoodPeweeSong</code>
There are 1327 rows.  The column <code>"y"</code> is a factor with
levels <code>"1", "2", "3"</code> corresponding to the three different
&ldquo;phrases&rdquo; of wood wewee song.  The time series comprises
a sequence of observations of the &ldquo;morning twilight&rdquo;
song of the wood pewee.
</p>
</li></ul>



<h3>Details</h3>

<p>For detailed information about each of these data sets, see the
book cited in the <b>References</b>.
</p>
<p>Note that the data sets <code>Cryptosporidiosis</code>
and <code>LegionnairesDisease</code> are actually
called <br /> <code>Cryptosporidiosis_02-08</code> and
<code>LegionnairesDisease_02-08</code> in the given reference.
The <br /> &ldquo;suffixes&rdquo; were removed since the minus sign causes
problems in a variable name in <code>R</code>.
</p>


<h3>Source</h3>

<p>These data sets were kindly provided by Prof. Christian
H. Wei.  The package author is also pleased
to acknowledge the kind permission granted by Prof. Kurt
Brnns (Professor Emeritus of Economics at
Ume University) to include the Ericsson time series
data set (<code>EricssonB_Jul2</code>).
</p>


<h3>References</h3>

<p>Christian H. Wei (2018).  <em>An
Introduction to Discrete-Valued Time Series</em>.  Chichester: John
Wiley &amp; Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit1 &lt;- hmm(WoodPeweeSong,K=2,verbose=TRUE)
# EM converges in 6 steps --- suspicious.
set.seed(321)
fit2 &lt;- hmm(WoodPeweeSong,K=2,verbose=TRUE,rand.start=list(tpm=TRUE,Rho=TRUE))
# 52 steps --- note the huge difference between fit1$log.like and fit2$log.like!
set.seed(321)
fit3 &lt;- hmm(WoodPeweeSong,K=2,verbose=TRUE,method="bf",
            rand.start=list(tpm=TRUE,Rho=TRUE))
# log likelihood essentially the same as for fit2

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
