<!DOCTYPE html><html><head><title>Help for package webfakes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {webfakes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#git_app'><p>Web app that acts as a git http server</p></a></li>
<li><a href='#glossary'><p>webfakes glossary</p></a></li>
<li><a href='#http_time_stamp'><p>Format a time stamp for HTTP</p></a></li>
<li><a href='#httpbin_app'><p>Generic web app for testing HTTP clients</p></a></li>
<li><a href='#local_app_process'><p>App process that is cleaned up automatically</p></a></li>
<li><a href='#mw_cgi'><p>Middleware that calls a CGI script</p></a></li>
<li><a href='#mw_cookie_parser'><p>Middleware to parse Cookies</p></a></li>
<li><a href='#mw_etag'><p>Middleware that add an <code>ETag</code> header to the response</p></a></li>
<li><a href='#mw_json'><p>Middleware to parse a JSON body</p></a></li>
<li><a href='#mw_log'><p>Log requests to the standard output or other connection</p></a></li>
<li><a href='#mw_multipart'><p>Parse a multipart HTTP request body</p></a></li>
<li><a href='#mw_range_parser'><p>Middleware to parse a Range header</p></a></li>
<li><a href='#mw_raw'><p>Middleware to read the raw body of a request</p></a></li>
<li><a href='#mw_static'><p>Middleware function to serve static files</p></a></li>
<li><a href='#mw_text'><p>Middleware to parse a plain text body</p></a></li>
<li><a href='#mw_urlencoded'><p>Middleware to parse an url-encoded request body</p></a></li>
<li><a href='#new_app'><p>Create a new web application</p></a></li>
<li><a href='#new_app_process'><p>Run a webfakes app in another process</p></a></li>
<li><a href='#new_regexp'><p>Create a new regular expression to use in webfakes routes</p></a></li>
<li><a href='#oauth2_httr_login'><p>Helper function to use httr's OAuth2.0 functions</p>
non-interactively, e.g. in test cases</a></li>
<li><a href='#oauth2_login'><p>Helper function to log in to a third party OAuth2.0 app without a</p>
browser</a></li>
<li><a href='#oauth2_resource_app'><p>Fake OAuth 2.0 resource and authorization app</p></a></li>
<li><a href='#oauth2_third_party_app'><p>App representing the third-party app</p></a></li>
<li><a href='#server_opts'><p>Webfakes web server options</p></a></li>
<li><a href='#tmpl_glue'><p>glue based template engine</p></a></li>
<li><a href='#webfakes_request'><p>A webfakes request object</p></a></li>
<li><a href='#webfakes_response'><p>A webfakes response object</p></a></li>
<li><a href='#webfakes-package'><p>webfakes: Fake Web Apps for HTTP Testing</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Fake Web Apps for HTTP Testing</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Create a web app that makes it easier to test web clients
    without using the internet. It includes a web app framework with path
    matching, parameters and templates. Can parse various 'HTTP' request
    bodies. Can send 'JSON' data or files from the disk. Includes a web
    app that implements the 'httpbin.org' web service.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://webfakes.r-lib.org/">https://webfakes.r-lib.org/</a>, <a href="https://github.com/r-lib/webfakes">https://github.com/r-lib/webfakes</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-lib/webfakes/issues">https://github.com/r-lib/webfakes/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, tools, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>brotli, callr, covr, curl, digest, glue, httpuv, httr,
jsonlite, processx, testthat (&ge; 3.0.0), withr, xml2, zip (&ge;
2.3.0)</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-11 01:08:07 UTC; gaborcsardi</td>
</tr>
<tr>
<td>Author:</td>
<td>Gábor Csárdi [aut, cre],
  Posit Software, PBC [cph, fnd],
  Civetweb contributors [ctb] (see inst/credits/ciwetweb.md),
  Redoc contributors [ctb] (see inst/credits/redoc.md),
  L. Peter Deutsch [ctb] (src/md5.h),
  Martin Purschke [ctb] (src/md5.h),
  Aladdin Enterprises [cph] (src/md5.h),
  Maëlle Salmon <a href="https://orcid.org/0000-0002-2815-0399"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gábor Csárdi &lt;csardi.gabor@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-11 04:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='git_app'>Web app that acts as a git http server</h2><span id='topic+git_app'></span>

<h3>Description</h3>

<p>It is useful for tests that need an HTTP git server.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>git_app(
  git_root,
  git_cmd = "git",
  git_timeout = as.difftime(1, units = "mins"),
  filter = TRUE,
  cleanup = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="git_app_+3A_git_root">git_root</code></td>
<td>
<p>Path to the root of the directory tree to be served.</p>
</td></tr>
<tr><td><code id="git_app_+3A_git_cmd">git_cmd</code></td>
<td>
<p>Command to call, by default it is <code>"git"</code>. It may also
be a full path to git.</p>
</td></tr>
<tr><td><code id="git_app_+3A_git_timeout">git_timeout</code></td>
<td>
<p>A <code>difftime</code> object, time limit for the git
command.</p>
</td></tr>
<tr><td><code id="git_app_+3A_filter">filter</code></td>
<td>
<p>Whether to support the <code>filter</code> capability in the server.</p>
</td></tr>
<tr><td><code id="git_app_+3A_cleanup">cleanup</code></td>
<td>
<p>Whether to clean up <code>git_root</code> when the app is
garbage collected.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dir.create(tmp &lt;- tempfile())
setwd(tmp)
system("git clone --bare https://github.com/cran/crayon")
system("git clone --bare https://github.com/cran/glue")
app &lt;- git_app(tmp)
git &lt;- new_app_process(app)
system(paste("git ls-remote", git$url("/crayon")))

</code></pre>

<hr>
<h2 id='glossary'>webfakes glossary</h2><span id='topic+glossary'></span>

<h3>Description</h3>

<p>webfakes glossary
</p>


<h3>Webfakes glossary</h3>

<p>The webfakes package uses vocabulary that is standard for web apps, especially those developed with Express.js, but not necessarily well known to all R package developers.
</p>


<h4>app</h4>

<p>(Also: fake web app, webfakes app.) A web application that can be served by webfakes's web server, typically in another process, an <em>app process</em>.
Sometimes we call it a <em>fake</em> web app, to emphasize that we use it for testing real web apps and APIs.
</p>
<p>You can create a webfakes app with the <code>new_app()</code> function.
A webfakes app is an R object that you can save to disk with <code>saveRDS()</code> , and you can also include it in your package.
</p>
<p>You can start an with its <code style="white-space: pre;">&#8288;$listen()&#8288;</code> method.
Since the main R process runs that test suite code, you usually run them in a subprocess, see <code>new_app_process()</code> or <code>local_app_process()</code>.
</p>



<h4>app process</h4>

<p>(Also: web server process, webfakes subprocess.) An app process is an R subprocess, started from the main R process, to serve a webfakes <em>app</em>.
</p>
<p>You can create an app process object with <code>new_app_process()</code> or <code>local_app_process()</code>.
By default the actual process does not start yet, when you create it.
You can start it explicitly with the <code style="white-space: pre;">&#8288;$start&#8288;</code> method of the app process object, or by querying its URL with <code style="white-space: pre;">&#8288;$url()&#8288;</code> or its port with <code style="white-space: pre;">&#8288;$get_port()&#8288;</code>.
</p>
<p>For test cases, you typically start app processes at these places:
</p>

<ul>
<li><p> In a <code>setup*.R</code> file, to start an app that the whole test suite can use.
</p>
</li>
<li><p> Alternatively, in a <code>helper*.R</code> file, to start an app that the whole test suite can use, and it works better for interactive development.
</p>
</li>
<li><p> At the beginning of a test file, to create an app for a single test file.
</p>
</li>
<li><p> Inside <code>test_that()</code>, to create an app for a single test block.
</p>
</li></ul>

<p>See the How-to for details about each.
</p>



<h4>handler</h4>

<p>(Or handler function.) A handler is a <em>route</em> or a <em>middleware</em>.
</p>



<h4>handler stack</h4>

<p>This is a stack of handler functions, which are called by the app one after the other, passing the request and response objects to them.
Handlers typically manipulate the request and/or response objects.
A terminal handler instructs the app to return the response to the HTTP client.
A non-terminal handler tells the app to keep calling handlers, by returning the string <code>"next"</code>.
</p>



<h4>httpbin app</h4>

<p>This is an example app, which implements the excellent <code style="white-space: pre;">&#8288;https://httpbin.org/&#8288;</code> web service.
You can use it to simulate certain HTTP responses.
It is most handy for HTTP clients, but potentially useful for other tools as well.
</p>
<p>Use <code>httpbin_app()</code> to create an instance of this app.
</p>



<h4>middleware</h4>

<p>A middleware is a handler function that is not bound to a path.
It is called by the router, like other handler functions.
It may manipulate the request or the response, or can have a side effect.
Some example built-in middleware functions in webfakes:
</p>

<ul>
<li> <p><code>mw_json()</code> parses a request's JSON body into an R object.
</p>
</li>
<li> <p><code>mw_log()</code> logs requests and responses to the screen or to a file.
</p>
</li>
<li> <p><code>mw_static()</code> serves static files from the directory.
</p>
</li></ul>

<p>You can also write your own middleware functions.
</p>



<h4>path matching</h4>

<p>The router performs path matching when it goes over the handler stack.
If the HTTP method and path of a <em>route</em> match the HTTP method and URL of the request, then the handler is called, otherwise it is not.
Paths can have parameters and be regular expressions.
See <code>?new_regexp()</code> for regular expressions and &quot;Path parameters&quot; in <code>?new_app()</code> for parameters.
</p>



<h4>route</h4>

<p>A route is a handler function that is bound to certain paths of you web app.
If the request URL matches the path of the route, then the handler function is called, to give it a chance to send the appropriate response.
Route paths may have parameters or they can be regular expressions in webfakes.
</p>



<h4>routing</h4>

<p>Routing is the process of going over the handlers stack, and calling handler functions, one after the other, until one handles the request.
If a handler function is a <em>route</em>, then the router only calls it if its path matches the request URL.
</p>


<hr>
<h2 id='http_time_stamp'>Format a time stamp for HTTP</h2><span id='topic+http_time_stamp'></span>

<h3>Description</h3>

<p>Format a time stamp for HTTP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>http_time_stamp(t = Sys.time())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="http_time_stamp_+3A_t">t</code></td>
<td>
<p>Date-time value to format, defaults to the current date and
time. It must be a POSIXct object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector, formatted date-time.
</p>

<hr>
<h2 id='httpbin_app'>Generic web app for testing HTTP clients</h2><span id='topic+httpbin_app'></span>

<h3>Description</h3>

<p>A web app similar to <code style="white-space: pre;">&#8288;https://httpbin.org&#8288;</code>.
See <a href="https://webfakes.r-lib.org/httpbin.html">its specific docs</a>.
You can also see these docs locally, by starting the app:
</p>
<div class="sourceCode r"><pre>httpbin &lt;- new_app_process(httpbin_app())
browseURL(httpbin$url())
</pre></div>


<h3>Usage</h3>

<pre><code class='language-R'>httpbin_app(log = interactive())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="httpbin_app_+3A_log">log</code></td>
<td>
<p>Whether to log requests to the standard output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>webfakes_app</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>app &lt;- httpbin_app()
proc &lt;- new_app_process(app)
url &lt;- proc$url("/get")
resp &lt;- curl::curl_fetch_memory(url)
curl::parse_headers_list(resp$headers)
cat(rawToChar(resp$content))
proc$stop()
</code></pre>

<hr>
<h2 id='local_app_process'>App process that is cleaned up automatically</h2><span id='topic+local_app_process'></span>

<h3>Description</h3>

<p>You can start the process with an explicit <code style="white-space: pre;">&#8288;$start()&#8288;</code> call.
Alternatively it starts up at the first <code style="white-space: pre;">&#8288;$url()&#8288;</code> or <code style="white-space: pre;">&#8288;$get_port()&#8288;</code>
call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_app_process(app, ..., .local_envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_app_process_+3A_app">app</code></td>
<td>
<p><code>webfakes_app</code> object, the web app to run.</p>
</td></tr>
<tr><td><code id="local_app_process_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="#topic+new_app_process">new_app_process()</a></code>.</p>
</td></tr>
<tr><td><code id="local_app_process_+3A_.local_envir">.local_envir</code></td>
<td>
<p>The environment to attach the process cleanup to.
Typically a frame. When this frame finishes, the process is stopped.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+new_app_process">new_app_process()</a></code> for more details.
</p>

<hr>
<h2 id='mw_cgi'>Middleware that calls a CGI script</h2><span id='topic+mw_cgi'></span>

<h3>Description</h3>

<p>You can use it as an unconditional middleware in <code>app$use()</code>,
as a handler on <code>app$get()</code>, <code>app$post()</code>, etc., or you can call it
from a handler. See examples below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mw_cgi(command, args = character(), timeout = as.difftime(Inf, units = "secs"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mw_cgi_+3A_command">command</code></td>
<td>
<p>External command to run.</p>
</td></tr>
<tr><td><code id="mw_cgi_+3A_args">args</code></td>
<td>
<p>Arguments to pass to the external command.</p>
</td></tr>
<tr><td><code id="mw_cgi_+3A_timeout">timeout</code></td>
<td>
<p>Timeout for the external command. If the command does
not terminate in time, the web server kills it and returns an 500
response.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function with signature
</p>
<div class="sourceCode"><pre>function(req, res, env = character())
</pre></div>
<p>See <a href="https://www.ietf.org/rfc/rfc3875">RFC 3875</a> for details on the CGI
protocol.
</p>
<p>The request body (if any) is passed to the external command as standard
intput. <code>mw_cgi()</code> sets <code>CONTENT_LENGTH</code>, <code>CONTENT_TYPE</code>,
<code>GATEWAY_INTERFACE</code>, <code>PATH_INFO</code>, <code>QUERY_STRING</code>, <code>REMOTE_ADDR</code>,
<code>REMOTE_HOST</code>, <code>REMOTE_USER</code>, <code>REQUEST_METHOD</code>, <code>SERVER_NAME</code>,
<code>SERVER_PORT</code>, <code>SERVER_PROTOCOL</code>, <code>SERVER_SOFTEWARE</code>.
</p>
<p>It does not currently set the <code>AUTH_TYPE</code>, <code>PATH_TRANSLATED</code>,
<code>REMOTE_IDENT</code>, <code>SCRIPT_NAME</code> environment variables.
</p>
<p>The standard output of the external command is used to set the
response status code, the response headers and the response body.
Example output from git's CGI:
</p>
<div class="sourceCode"><pre>Status: 200 OK
Expires: Fri, 01 Jan 1980 00:00:00 GMT
Pragma: no-cache
Cache-Control: no-cache, max-age=0, must-revalidate
Content-Type: application/x-git-upload-pack-advertisement

000eversion 2
0015agent=git/2.42.0
0013ls-refs=unborn
0020fetch=shallow wait-for-done
0012server-option
0017object-format=sha1
0010object-info
0000
</pre></div>


<h3>See Also</h3>

<p>Other middleware: 
<code><a href="#topic+mw_cookie_parser">mw_cookie_parser</a>()</code>,
<code><a href="#topic+mw_etag">mw_etag</a>()</code>,
<code><a href="#topic+mw_json">mw_json</a>()</code>,
<code><a href="#topic+mw_log">mw_log</a>()</code>,
<code><a href="#topic+mw_multipart">mw_multipart</a>()</code>,
<code><a href="#topic+mw_range_parser">mw_range_parser</a>()</code>,
<code><a href="#topic+mw_raw">mw_raw</a>()</code>,
<code><a href="#topic+mw_static">mw_static</a>()</code>,
<code><a href="#topic+mw_text">mw_text</a>()</code>,
<code><a href="#topic+mw_urlencoded">mw_urlencoded</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>app &lt;- new_app()
app$use(mw_cgi("echo", "Status: 200\n\nHello"))
app

app2 &lt;- new_app()
app2$get("/greet", mw_cgi("echo", "Status: 200\n\nHello"))
app2

# Using `mw_cgi()` in a handler, you can pass extra environment variables
app3 &lt;- new_app()
cgi &lt;- mw_cgi("echo", "Status: 200\n\nHello")
app2$get("/greet", function(req, res) {
  cgi(req, res, env = c("EXTRA_VAR" = "EXTRA_VALUE"))
})
app3
</code></pre>

<hr>
<h2 id='mw_cookie_parser'>Middleware to parse Cookies</h2><span id='topic+mw_cookie_parser'></span>

<h3>Description</h3>

<p>Adds the cookies as the <code>cookies</code> element of the request object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mw_cookie_parser()
</code></pre>


<h3>Details</h3>

<p>It ignores cookies in an invalid format. It ignores duplicate cookies:
if two cookies have the same name, only the first one is included.
</p>


<h3>Value</h3>

<p>Handler function.
</p>


<h3>See Also</h3>

<p>Other middleware: 
<code><a href="#topic+mw_cgi">mw_cgi</a>()</code>,
<code><a href="#topic+mw_etag">mw_etag</a>()</code>,
<code><a href="#topic+mw_json">mw_json</a>()</code>,
<code><a href="#topic+mw_log">mw_log</a>()</code>,
<code><a href="#topic+mw_multipart">mw_multipart</a>()</code>,
<code><a href="#topic+mw_range_parser">mw_range_parser</a>()</code>,
<code><a href="#topic+mw_raw">mw_raw</a>()</code>,
<code><a href="#topic+mw_static">mw_static</a>()</code>,
<code><a href="#topic+mw_text">mw_text</a>()</code>,
<code><a href="#topic+mw_urlencoded">mw_urlencoded</a>()</code>
</p>

<hr>
<h2 id='mw_etag'>Middleware that add an <code>ETag</code> header to the response</h2><span id='topic+mw_etag'></span>

<h3>Description</h3>

<p>If the response already has an <code>ETag</code> header, then it is kept.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mw_etag(algorithm = "crc32")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mw_etag_+3A_algorithm">algorithm</code></td>
<td>
<p>Checksum algorithm to use. Only <code>"crc32"</code> is
implemented currently.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This middleware handles the <code>If-None-Match</code> headers, and it sets the
status code of the response to 304 if <code>If-None-Match</code> matches the
<code>ETag</code>. It also removes the response body in this case.
</p>


<h3>Value</h3>

<p>Handler function.
</p>


<h3>See Also</h3>

<p>Other middleware: 
<code><a href="#topic+mw_cgi">mw_cgi</a>()</code>,
<code><a href="#topic+mw_cookie_parser">mw_cookie_parser</a>()</code>,
<code><a href="#topic+mw_json">mw_json</a>()</code>,
<code><a href="#topic+mw_log">mw_log</a>()</code>,
<code><a href="#topic+mw_multipart">mw_multipart</a>()</code>,
<code><a href="#topic+mw_range_parser">mw_range_parser</a>()</code>,
<code><a href="#topic+mw_raw">mw_raw</a>()</code>,
<code><a href="#topic+mw_static">mw_static</a>()</code>,
<code><a href="#topic+mw_text">mw_text</a>()</code>,
<code><a href="#topic+mw_urlencoded">mw_urlencoded</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>app &lt;- new_app()
app$use(mw_etag())
app
</code></pre>

<hr>
<h2 id='mw_json'>Middleware to parse a JSON body</h2><span id='topic+mw_json'></span>

<h3>Description</h3>

<p>Adds the parsed object as the <code>json</code> element of the request object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mw_json(type = "application/json", simplifyVector = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mw_json_+3A_type">type</code></td>
<td>
<p>Content type to match before parsing. If it does not
match, then the request object is not modified.</p>
</td></tr>
<tr><td><code id="mw_json_+3A_simplifyvector">simplifyVector</code></td>
<td>
<p>Whether to simplify lists to vectors, passed to
<code><a href="jsonlite.html#topic+fromJSON">jsonlite::fromJSON()</a></code>.</p>
</td></tr>
<tr><td><code id="mw_json_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code><a href="jsonlite.html#topic+fromJSON">jsonlite::fromJSON()</a></code>, that performs
the JSON parsing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Handler function.
</p>


<h3>See Also</h3>

<p>Other middleware: 
<code><a href="#topic+mw_cgi">mw_cgi</a>()</code>,
<code><a href="#topic+mw_cookie_parser">mw_cookie_parser</a>()</code>,
<code><a href="#topic+mw_etag">mw_etag</a>()</code>,
<code><a href="#topic+mw_log">mw_log</a>()</code>,
<code><a href="#topic+mw_multipart">mw_multipart</a>()</code>,
<code><a href="#topic+mw_range_parser">mw_range_parser</a>()</code>,
<code><a href="#topic+mw_raw">mw_raw</a>()</code>,
<code><a href="#topic+mw_static">mw_static</a>()</code>,
<code><a href="#topic+mw_text">mw_text</a>()</code>,
<code><a href="#topic+mw_urlencoded">mw_urlencoded</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>app &lt;- new_app()
app$use(mw_json())
app
</code></pre>

<hr>
<h2 id='mw_log'>Log requests to the standard output or other connection</h2><span id='topic+mw_log'></span>

<h3>Description</h3>

<p>A one line log entry for every request. The output looks like this:
</p>
<div class="sourceCode"><pre>GET http://127.0.0.1:3000/image 200 3 ms - 4742
</pre></div>
<p>and contains
</p>

<ul>
<li><p> the HTTP method,
</p>
</li>
<li><p> the full request URL,
</p>
</li>
<li><p> the HTTP status code of the response,
</p>
</li>
<li><p> how long it took to process the response, in ms,
</p>
</li>
<li><p> and the size of the response body, in bytes.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>mw_log(format = "dev", stream = "stdout")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mw_log_+3A_format">format</code></td>
<td>
<p>Log format. Not implemented currently.</p>
</td></tr>
<tr><td><code id="mw_log_+3A_stream">stream</code></td>
<td>
<p>R connection to log to. <code>"stdout"</code> means the standard
output, <code>"stderr"</code> is the standard error. You can also supply a
connection object, but then you need to be sure that it will be
valid when the app is actually running.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Handler function.
</p>


<h3>See Also</h3>

<p>Other middleware: 
<code><a href="#topic+mw_cgi">mw_cgi</a>()</code>,
<code><a href="#topic+mw_cookie_parser">mw_cookie_parser</a>()</code>,
<code><a href="#topic+mw_etag">mw_etag</a>()</code>,
<code><a href="#topic+mw_json">mw_json</a>()</code>,
<code><a href="#topic+mw_multipart">mw_multipart</a>()</code>,
<code><a href="#topic+mw_range_parser">mw_range_parser</a>()</code>,
<code><a href="#topic+mw_raw">mw_raw</a>()</code>,
<code><a href="#topic+mw_static">mw_static</a>()</code>,
<code><a href="#topic+mw_text">mw_text</a>()</code>,
<code><a href="#topic+mw_urlencoded">mw_urlencoded</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>app &lt;- new_app()
app$use(mw_log())
app
</code></pre>

<hr>
<h2 id='mw_multipart'>Parse a multipart HTTP request body</h2><span id='topic+mw_multipart'></span>

<h3>Description</h3>

<p>Adds the parsed form fields in the <code>form</code> element of the request and
the parsed files to the <code>files</code> element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mw_multipart(type = "multipart/form-data")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mw_multipart_+3A_type">type</code></td>
<td>
<p>Content type to match before parsing. If it does not
match, then the request object is not modified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Handler function.
</p>


<h3>See Also</h3>

<p>Other middleware: 
<code><a href="#topic+mw_cgi">mw_cgi</a>()</code>,
<code><a href="#topic+mw_cookie_parser">mw_cookie_parser</a>()</code>,
<code><a href="#topic+mw_etag">mw_etag</a>()</code>,
<code><a href="#topic+mw_json">mw_json</a>()</code>,
<code><a href="#topic+mw_log">mw_log</a>()</code>,
<code><a href="#topic+mw_range_parser">mw_range_parser</a>()</code>,
<code><a href="#topic+mw_raw">mw_raw</a>()</code>,
<code><a href="#topic+mw_static">mw_static</a>()</code>,
<code><a href="#topic+mw_text">mw_text</a>()</code>,
<code><a href="#topic+mw_urlencoded">mw_urlencoded</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>app &lt;- new_app()
app$use(mw_multipart())
app
</code></pre>

<hr>
<h2 id='mw_range_parser'>Middleware to parse a Range header</h2><span id='topic+mw_range_parser'></span>

<h3>Description</h3>

<p>Adds the requested ranges to the <code>ranges</code> element of the request
object. <code>request$ranges</code> is a data frame with two columns, <code>from</code> and
<code>to</code>. Each row corresponds one requested interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mw_range_parser()
</code></pre>


<h3>Details</h3>

<p>When the last <code>n</code> bytes of the file are requested, the matrix row is set
to <code>c(0, -n)</code>. When all bytes after a <code>p</code> position are requested, the
matrix row is set to <code>c(p, Inf)</code>.
</p>
<p>If the intervals overlap, then <code>ranges</code> is not set, i.e. the <code>Range</code>
header is ignored.
</p>
<p>If its syntax is invalid or the unit is not <code>bytes</code>, then the
<code>Range</code> header is ignored.
</p>


<h3>Value</h3>

<p>Handler function.
</p>


<h3>See Also</h3>

<p>Other middleware: 
<code><a href="#topic+mw_cgi">mw_cgi</a>()</code>,
<code><a href="#topic+mw_cookie_parser">mw_cookie_parser</a>()</code>,
<code><a href="#topic+mw_etag">mw_etag</a>()</code>,
<code><a href="#topic+mw_json">mw_json</a>()</code>,
<code><a href="#topic+mw_log">mw_log</a>()</code>,
<code><a href="#topic+mw_multipart">mw_multipart</a>()</code>,
<code><a href="#topic+mw_raw">mw_raw</a>()</code>,
<code><a href="#topic+mw_static">mw_static</a>()</code>,
<code><a href="#topic+mw_text">mw_text</a>()</code>,
<code><a href="#topic+mw_urlencoded">mw_urlencoded</a>()</code>
</p>

<hr>
<h2 id='mw_raw'>Middleware to read the raw body of a request</h2><span id='topic+mw_raw'></span>

<h3>Description</h3>

<p>Adds the raw body, as a raw object to the <code>raw</code> field of the request.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mw_raw(type = "application/octet-stream")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mw_raw_+3A_type">type</code></td>
<td>
<p>Content type to match. If it does not match, then the
request object is not modified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Handler function.
</p>


<h3>See Also</h3>

<p>Other middleware: 
<code><a href="#topic+mw_cgi">mw_cgi</a>()</code>,
<code><a href="#topic+mw_cookie_parser">mw_cookie_parser</a>()</code>,
<code><a href="#topic+mw_etag">mw_etag</a>()</code>,
<code><a href="#topic+mw_json">mw_json</a>()</code>,
<code><a href="#topic+mw_log">mw_log</a>()</code>,
<code><a href="#topic+mw_multipart">mw_multipart</a>()</code>,
<code><a href="#topic+mw_range_parser">mw_range_parser</a>()</code>,
<code><a href="#topic+mw_static">mw_static</a>()</code>,
<code><a href="#topic+mw_text">mw_text</a>()</code>,
<code><a href="#topic+mw_urlencoded">mw_urlencoded</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>app &lt;- new_app()
app$use(mw_raw())
app
</code></pre>

<hr>
<h2 id='mw_static'>Middleware function to serve static files</h2><span id='topic+mw_static'></span>

<h3>Description</h3>

<p>The content type of the response is set automatically from the
extension of the file. Note that this is a terminal middleware
handler function. If a file is served, then the rest of the handler
functions will not be called. If a file was not found, however,
the rest of the handlers are still called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mw_static(root, set_headers = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mw_static_+3A_root">root</code></td>
<td>
<p>Root path of the served files. Everything under this
directory is served automatically. Directory lists are not currently
supports.</p>
</td></tr>
<tr><td><code id="mw_static_+3A_set_headers">set_headers</code></td>
<td>
<p>Callback function to call before a file is served.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Handler function.
</p>


<h3>See Also</h3>

<p>Other middleware: 
<code><a href="#topic+mw_cgi">mw_cgi</a>()</code>,
<code><a href="#topic+mw_cookie_parser">mw_cookie_parser</a>()</code>,
<code><a href="#topic+mw_etag">mw_etag</a>()</code>,
<code><a href="#topic+mw_json">mw_json</a>()</code>,
<code><a href="#topic+mw_log">mw_log</a>()</code>,
<code><a href="#topic+mw_multipart">mw_multipart</a>()</code>,
<code><a href="#topic+mw_range_parser">mw_range_parser</a>()</code>,
<code><a href="#topic+mw_raw">mw_raw</a>()</code>,
<code><a href="#topic+mw_text">mw_text</a>()</code>,
<code><a href="#topic+mw_urlencoded">mw_urlencoded</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>root &lt;- system.file(package = "webfakes", "examples", "static", "public")
app &lt;- new_app()
app$use(mw_static(root = root))
app
</code></pre>

<hr>
<h2 id='mw_text'>Middleware to parse a plain text body</h2><span id='topic+mw_text'></span>

<h3>Description</h3>

<p>Adds the parsed object as the <code>text</code> element of the request object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mw_text(default_charset = "utf-8", type = "text/plain")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mw_text_+3A_default_charset">default_charset</code></td>
<td>
<p>Encoding to set on the text.</p>
</td></tr>
<tr><td><code id="mw_text_+3A_type">type</code></td>
<td>
<p>Content type to match before parsing. If it does not
match, then the request object is not modified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Handler function.
</p>


<h3>See Also</h3>

<p>Other middleware: 
<code><a href="#topic+mw_cgi">mw_cgi</a>()</code>,
<code><a href="#topic+mw_cookie_parser">mw_cookie_parser</a>()</code>,
<code><a href="#topic+mw_etag">mw_etag</a>()</code>,
<code><a href="#topic+mw_json">mw_json</a>()</code>,
<code><a href="#topic+mw_log">mw_log</a>()</code>,
<code><a href="#topic+mw_multipart">mw_multipart</a>()</code>,
<code><a href="#topic+mw_range_parser">mw_range_parser</a>()</code>,
<code><a href="#topic+mw_raw">mw_raw</a>()</code>,
<code><a href="#topic+mw_static">mw_static</a>()</code>,
<code><a href="#topic+mw_urlencoded">mw_urlencoded</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>app &lt;- new_app()
app$use(mw_text())
app
</code></pre>

<hr>
<h2 id='mw_urlencoded'>Middleware to parse an url-encoded request body</h2><span id='topic+mw_urlencoded'></span>

<h3>Description</h3>

<p>This is typically data from a form. The parsed data is added
as the <code>form</code> element of the request object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mw_urlencoded(type = "application/x-www-form-urlencoded")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mw_urlencoded_+3A_type">type</code></td>
<td>
<p>Content type to match before parsing. If it does not
match, then the request object is not modified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Handler function.
</p>


<h3>See Also</h3>

<p>Other middleware: 
<code><a href="#topic+mw_cgi">mw_cgi</a>()</code>,
<code><a href="#topic+mw_cookie_parser">mw_cookie_parser</a>()</code>,
<code><a href="#topic+mw_etag">mw_etag</a>()</code>,
<code><a href="#topic+mw_json">mw_json</a>()</code>,
<code><a href="#topic+mw_log">mw_log</a>()</code>,
<code><a href="#topic+mw_multipart">mw_multipart</a>()</code>,
<code><a href="#topic+mw_range_parser">mw_range_parser</a>()</code>,
<code><a href="#topic+mw_raw">mw_raw</a>()</code>,
<code><a href="#topic+mw_static">mw_static</a>()</code>,
<code><a href="#topic+mw_text">mw_text</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>app &lt;- new_app()
app$use(mw_urlencoded())
app
</code></pre>

<hr>
<h2 id='new_app'>Create a new web application</h2><span id='topic+new_app'></span><span id='topic+webfakes_app'></span>

<h3>Description</h3>

<p>Create a new web application
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_app()
</code></pre>


<h3>Details</h3>

<p>The typical workflow of creating a web application is:
</p>

<ol>
<li><p> Create a <code>webfakes_app</code> object with <code>new_app()</code>.
</p>
</li>
<li><p> Add middleware and/or routes to it.
</p>
</li>
<li><p> Start is with the <code>webfakes_app$listen()</code> method, or start it in
another process with <code><a href="#topic+new_app_process">new_app_process()</a></code>.
</p>
</li>
<li><p> Make queries to the web app.
</p>
</li>
<li><p> Stop it via <code>CTRL+C</code> / <code>ESC</code>, or, if it is running in another
process, with the <code style="white-space: pre;">&#8288;$stop()&#8288;</code> method of <code><a href="#topic+new_app_process">new_app_process()</a></code>.
</p>
</li></ol>

<p>A web application can be
</p>

<ul>
<li><p> restarted,
</p>
</li>
<li><p> saved to disk,
</p>
</li>
<li><p> copied to another process using the callr package, or a similar way,
</p>
</li>
<li><p> embedded into a package,
</p>
</li>
<li><p> extended by simply adding new routes and/or middleware.
</p>
</li></ul>

<p>The webfakes API is very much influenced by the
<a href="http://expressjs.com/">express.js</a> project.
</p>


<h4>Create web app objects</h4>

<div class="sourceCode r"><pre>new_app()
</pre></div>
<p><code>new_app()</code> returns a <code>webfakes_app</code> object the has the methods listed
on this page.
</p>
<p>An app is an environment with S3 class <code>webfakes_app</code>.
</p>



<h4>The handler stack</h4>

<p>An app has a stack of handlers. Each handler can be a route or
middleware. The differences between the two are:
</p>

<ul>
<li><p> A route is bound to one or more paths on the web server. Middleware
is not (currently) bound to paths, but run for all paths.
</p>
</li>
<li><p> A route is usually (but not always) the end of the handler stack for
a request. I.e. a route takes care of sending out the response to
the request. Middleware typically performs some action on the request
or the response, and then the next handler in the stack is invoked.
</p>
</li></ul>




<h4>Routes</h4>

<p>The following methods define routes. Each method corresponds to the
HTTP verb with the same name, except for <code>app$all()</code>, which creates a
route for all HTTP methods.
</p>
<div class="sourceCode r"><pre>app$all(path, ...)
app$delete(path, ...)
app$get(path, ...)
app$head(path, ...)
app$patch(path, ...)
app$post(path, ...)
app$put(path, ...)
... (see list below)
</pre></div>

<ul>
<li> <p><code>path</code> is a path specification, see 'Path specification' below.
</p>
</li>
<li> <p><code>...</code> is one or more handler functions. These will be placed in the
handler stack, and called if they match an incoming HTTP request.
See 'Handler functions' below.
</p>
</li></ul>

<p>webfakes also has methods for the less frequently used HTTP verbs:
<code>CONNECT</code>, <code>MKCOL</code>, <code>OPTIONS</code>, <code>PROPFIND</code>, <code>REPORT</code>. (The method
names are always in lowercase.)
</p>
<p>If a request is not handled by any routes (or handler functions in
general), then webfakes will send a simple HTTP 404 response.
</p>



<h4>Middleware</h4>

<p><code>app$use()</code> adds a middleware to the handler stack. A middleware is
a handler function, see 'Handler functions' below. webfakes comes with
middleware to perform common tasks:
</p>

<ul>
<li> <p><code><a href="#topic+mw_cookie_parser">mw_cookie_parser()</a></code> parses <code>Cookie</code> headers.
</p>
</li>
<li> <p><code><a href="#topic+mw_etag">mw_etag()</a></code> adds an <code>ETag</code> header to the response.
</p>
</li>
<li> <p><code><a href="#topic+mw_json">mw_json()</a></code> parses JSON request bodies.
</p>
</li>
<li> <p><code><a href="#topic+mw_log">mw_log()</a></code> logs each requests to standard output, or another connection.
</p>
</li>
<li> <p><code><a href="#topic+mw_multipart">mw_multipart()</a></code> parses multipart request bodies.
</p>
</li>
<li> <p><code><a href="#topic+mw_range_parser">mw_range_parser()</a></code> parses <code>Range</code> headers.
</p>
</li>
<li> <p><code><a href="#topic+mw_raw">mw_raw()</a></code> parses raw request bodies.
</p>
</li>
<li> <p><code><a href="#topic+mw_static">mw_static()</a></code> serves static files from a directory.
</p>
</li>
<li> <p><code><a href="#topic+mw_text">mw_text()</a></code> parses plain text request bodies.
</p>
</li>
<li> <p><code><a href="#topic+mw_urlencoded">mw_urlencoded()</a></code> parses URL encoded request bodies.
</p>
</li></ul>

<div class="sourceCode r"><pre>app$use(..., .first = FALSE)
</pre></div>

<ul>
<li> <p><code>...</code> is a set of (middleware) handler functions. They are added to
the handler stack, and called for every HTTP request. (Unless an HTTP
response is created before reaching this point in the handler stack.)
</p>
</li>
<li> <p><code>.first</code> set to <code>TRUE</code> is you want to add the handler function
to the bottom of the stack.
</p>
</li></ul>




<h4>Handler functions</h4>

<p>A handler function is a route or middleware. A handler function is
called by webfakes with the incoming HTTP request and the outgoing
HTTP response objects (being built) as arguments. The handler function
may query and modify the members of the request and/or the response
object. If it returns the string <code>"next"</code>, then it is <em>not</em> a terminal
handler, and once it returns, webfakes will move on to call the next
handler in the stack.
</p>
<p>A typical route:
</p>
<div class="sourceCode r"><pre>app$get("/user/:id", function(req, res) {
  id &lt;- req$params$id
  ...
  res$
    set_status(200L)$
    set_header("X-Custom-Header", "foobar")$
    send_json(response, auto_unbox = TRUE)
})
</pre></div>

<ul>
<li><p> The handler belongs to an API path, which is a wildcard path in
this case. It matches <code style="white-space: pre;">&#8288;/user/alice&#8288;</code>, <code style="white-space: pre;">&#8288;/user/bob&#8288;</code>, etc. The handler
will be only called for GET methods and matching API paths.
</p>
</li>
<li><p> The handler receives the request (<code>req</code>) and the response (<code>res</code>).
</p>
</li>
<li><p> It sets the HTTP status, additional headers, and sends the data.
(In this case the <code>webfakes_response$send_json()</code> method automatically
converts <code>response</code> to JSON and sets the <code>Content-Type</code> and
<code>Content-Length</code> headers.
</p>
</li>
<li><p> This is a terminal handler, because it does <em>not</em> return <code>"next"</code>.
Once this handler function returns, webfakes will send out the HTTP
response.
</p>
</li></ul>

<p>A typical middleware:
</p>
<div class="sourceCode r"><pre>app$use(function(req, res) {
  ...
  "next"
})
</pre></div>

<ul>
<li><p> There is no HTTP method and API path here, webfakes will call the
handler for each HTTP request.
</p>
</li>
<li><p> This is not a terminal handler, it does return <code>"next"</code>, so after it
returns webfakes will look for the next handler in the stack.
</p>
</li></ul>




<h4>Errors</h4>

<p>If a handler function throws an error, then the web server will return
a HTTP 500 <code>text/plain</code> response, with the error message as the
response body.
</p>



<h4>Request and response objects</h4>

<p>See <a href="#topic+webfakes_request">webfakes_request</a> and <a href="#topic+webfakes_response">webfakes_response</a> for the methods of the
request and response objects.
</p>



<h4>Path specification</h4>

<p>Routes are associated with one or more API paths. A path specification
can be
</p>

<ul>
<li><p> A &quot;plain&quot; (i.e. without parameters) string. (E.g. <code>"/list"</code>.)
</p>
</li>
<li><p> A parameterized string. (E.g. <code>"/user/:id"</code>.)
</p>
</li>
<li><p> A regular expression created via <code><a href="#topic+new_regexp">new_regexp()</a></code> function.
</p>
</li>
<li><p> A list or character vector of the previous ones. (Regular expressions
must be in a list.)
</p>
</li></ul>




<h4>Path parameters</h4>

<p>Paths that are specified as parameterized strings or regular expressions
can have parameters.
</p>
<p>For parameterized strings the keys may contain letters, numbers and
underscores. When webfakes matches an API path to a handler with a
parameterized string path, the parameters will be added to the
request, as <code>params</code>. I.e. in the handler function (and subsequent
handler functions, if the current one is not terminal), they are
available in the <code>req$params</code> list.
</p>
<p>For regular expressions, capture groups are also added as parameters.
It is best to use named capture groups, so that the parameters are in
a named list.
</p>
<p>If the path of the handler is a list of parameterized strings or
regular expressions, the parameters are set according to the first
matching one.
</p>



<h4>Templates</h4>

<p>webfakes supports templates, using any template engine. It comes with
a template engine that uses the glue package, see <code><a href="#topic+tmpl_glue">tmpl_glue()</a></code>.
</p>
<p><code>app$engine()</code> registers a template engine, for a certain file
extension. The <code style="white-space: pre;">&#8288;$render()&#8288;</code> method of <a href="#topic+webfakes_response">webfakes_response</a>
can be called from the handler function to evaluate a template from a
file.
</p>
<div class="sourceCode r"><pre>app$engine(ext, engine)
</pre></div>

<ul>
<li> <p><code>ext</code>: the file extension for which the template engine is added.
It should not contain the dot. E.g. <code style="white-space: pre;">&#8288;"html"', &#8288;</code>&quot;brew&quot;'.
</p>
</li>
<li> <p><code>engine</code>: the template engine, a function that takes the file path
(<code>path</code>) of the template, and a list of local variables (<code>locals</code>)
that can be used in the template. It should return the result.
</p>
</li></ul>

<p>An example template engine that uses glue might look like this:
</p>
<div class="sourceCode r"><pre>app$engine("txt", function(path, locals) {
  txt &lt;- readChar(path, nchars = file.size(path))
  glue::glue_data(locals, txt)
})
</pre></div>
<p>(The built-in <code><a href="#topic+tmpl_glue">tmpl_glue()</a></code> engine has more features.)
</p>
<p>This template engine can be used in a handler:
</p>
<div class="sourceCode r"><pre>app$get("/view", function(req, res) {
 txt &lt;- res$render("test")
 res$
   set_type("text/plain")$
   send(txt)
})
</pre></div>
<p>The location of the templates can be set using the <code>views</code> configuration
parameter, see the <code style="white-space: pre;">&#8288;$set_config()&#8288;</code> method below.
</p>
<p>In the template, the variables passed in as <code>locals</code>, and also the
response local variables (see <code>locals</code> in <a href="#topic+webfakes_response">webfakes_response</a>), are
available.
</p>



<h4>Starting and stopping</h4>

<div class="sourceCode r"><pre>app$listen(port = NULL, opts = server_opts(), cleanup = TRUE)
</pre></div>

<ul>
<li> <p><code>port</code>: port to listen on. When <code>NULL</code>, the operating system will
automatically select a free port.
</p>
</li>
<li> <p><code>opts</code>: options to the web server. See <code><a href="#topic+server_opts">server_opts()</a></code> for the
list of options and their default values.
</p>
</li>
<li> <p><code>cleanup</code>: stop the server (with an error) if the standard input
of the process is closed. This is handy when the app runs in a
<code>callr::r_session</code> subprocess, because it stops the app (and the
subprocess) if the main process has terminated.
</p>
</li></ul>

<p>This method does not return, and can be interrupted with <code>CTRL+C</code> / <code>ESC</code>
or a SIGINT signal. See <code><a href="#topic+new_app_process">new_app_process()</a></code> for interrupting an app that
is running in another process.
</p>
<p>When <code>port</code> is <code>NULL</code>, the operating system chooses a port where the
app will listen. To be able to get the port number programmatically,
before the listen method blocks, it advertises the selected port in a
<code>webfakes_port</code> condition, so one can catch it:
</p>
<p>webfakes by default binds only to the loopback interface at 127.0.0.1, so
the webfakes web app is never reachable from the network.
</p>
<div class="sourceCode r"><pre>withCallingHandlers(
  app$listen(),
  "webfakes_port" = function(msg) print(msg$port)
)
</pre></div>



<h4>Logging</h4>

<p>webfakes can write an access log that contains an entry for all incoming
requests, and also an error log for the errors that happen while
the server is running. This is the default behavior for local app
(the ones started by <code>app$listen()</code> and for remote apps (the ones
started via <code>new_app_process()</code>:
</p>

<ul>
<li><p> Local apps do not write an access log by default.
</p>
</li>
<li><p> Remote apps write an access log into the
<code style="white-space: pre;">&#8288;&lt;tmpdir&gt;/webfakes/&lt;pid&gt;/access.log&#8288;</code> file, where <code style="white-space: pre;">&#8288;&lt;tmpdir&gt;&#8288;</code> is the
session temporary directory of the <em>main process</em>, and <code style="white-space: pre;">&#8288;&lt;pid&gt;&#8288;</code> is
the process id of the <em>subprocess</em>.
</p>
</li>
<li><p> Local apps write an error log to <code style="white-space: pre;">&#8288;&lt;tmpdir&gt;/webfakes/error.log&#8288;</code>, where
<code style="white-space: pre;">&#8288;&lt;tmpdir&gt;&#8288;</code> is the session temporary directory of the current process.
</p>
</li>
<li><p> Remote app write an error log to the <code style="white-space: pre;">&#8288;&lt;tmpdir&gt;/webfakes/&lt;pid&gt;/error.log&#8288;</code>,
where <code style="white-space: pre;">&#8288;&lt;tmpdir&gt;&#8288;</code> is the session temporary directory of the
<em>main process</em> and <code style="white-space: pre;">&#8288;&lt;pid&gt;&#8288;</code> is the process id of the <em>subprocess</em>'.
</p>
</li></ul>

<p>See <code><a href="#topic+server_opts">server_opts()</a></code> for changing the default logging behavior.
</p>



<h4>Shared app data</h4>

<div class="sourceCode r"><pre>app$locals
</pre></div>
<p>It is often useful to share data between handlers and requests in an
app. <code>app$locals</code> is an environment that supports this. E.g. a
middleware that counts the number of requests can be implemented as:
</p>
<div class="sourceCode"><pre>app$use(function(req, res) {
  locals &lt;- req$app$locals
  if (is.null(locals$num)) locals$num &lt;- 0L
  locals$num &lt;- locals$num + 1L
  "next"
})
</pre></div>
<p><a href="#topic+webfakes_response">webfakes_response</a> objects also have a <code>locals</code> environment, that is
initially populated as a copy of <code>app$locals</code>.
</p>



<h4>Configuration</h4>

<div class="sourceCode r"><pre>app$get_config(key)
app$set_config(key, value)
</pre></div>

<ul>
<li> <p><code>key</code>: configuration key.
</p>
</li>
<li> <p><code>value</code>: configuration value.
</p>
</li></ul>

<p>Currently used configuration values:
</p>

<ul>
<li> <p><code>views</code>: path where webfakes searches for templates.
</p>
</li></ul>




<h3>Value</h3>

<p>A new <code>webfakes_app</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+webfakes_request">webfakes_request</a> for request objects, <a href="#topic+webfakes_response">webfakes_response</a> for
response objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see example web apps in the `/examples` directory in
system.file(package = "webfakes", "examples")

app &lt;- new_app()
app$use(mw_log())

app$get("/hello", function(req, res) {
  res$send("Hello there!")
})

app$get(new_regexp("^/hi(/.*)?$"), function(req, res) {
  res$send("Hi indeed!")
})

app$post("/hello", function(req, res) {
  res$send("Got it, thanks!")
})

app

# Start the app with: app$listen()
# Or start it in another R session: new_app_process(app)
</code></pre>

<hr>
<h2 id='new_app_process'>Run a webfakes app in another process</h2><span id='topic+new_app_process'></span><span id='topic+webfakes_app_process'></span>

<h3>Description</h3>

<p>Runs an app in a subprocess, using <a href="callr.html#topic+r_session">callr::r_session</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_app_process(
  app,
  port = NULL,
  opts = server_opts(remote = TRUE),
  start = FALSE,
  auto_start = TRUE,
  process_timeout = NULL,
  callr_opts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_app_process_+3A_app">app</code></td>
<td>
<p><code>webfakes_app</code> object, the web app to run.</p>
</td></tr>
<tr><td><code id="new_app_process_+3A_port">port</code></td>
<td>
<p>Port to use. By default the OS assigns a port.</p>
</td></tr>
<tr><td><code id="new_app_process_+3A_opts">opts</code></td>
<td>
<p>Server options. See <code><a href="#topic+server_opts">server_opts()</a></code> for the defaults.</p>
</td></tr>
<tr><td><code id="new_app_process_+3A_start">start</code></td>
<td>
<p>Whether to start the web server immediately. If this is
<code>FALSE</code>, and <code>auto_start</code> is <code>TRUE</code>, then it is started as neeed.</p>
</td></tr>
<tr><td><code id="new_app_process_+3A_auto_start">auto_start</code></td>
<td>
<p>Whether to start the web server process automatically.
If <code>TRUE</code> and the process is not running, then <code style="white-space: pre;">&#8288;$start()&#8288;</code>,
<code style="white-space: pre;">&#8288;$get_port()&#8288;</code> and <code style="white-space: pre;">&#8288;$url()&#8288;</code> start the process.</p>
</td></tr>
<tr><td><code id="new_app_process_+3A_process_timeout">process_timeout</code></td>
<td>
<p>How long to wait for the subprocess to start, in
milliseconds.</p>
</td></tr>
<tr><td><code id="new_app_process_+3A_callr_opts">callr_opts</code></td>
<td>
<p>Options to pass to <code><a href="callr.html#topic+r_session_options">callr::r_session_options()</a></code>
when setting up the subprocess.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>webfakes_app_process</code> object.
</p>


<h4>Methods</h4>

<p>The <code>webfakes_app_process</code> class has the following methods:
</p>
<div class="sourceCode r"><pre>get_app()
get_port()
stop()
get_state()
local_env(envvars)
url(path = "/", query = NULL)
</pre></div>

<ul>
<li> <p><code>envvars</code>: Named list of environment variables. The <code>{url}</code> substring
is replaced by the URL of the app.
</p>
</li>
<li> <p><code>path</code>: Path to return the URL for.
</p>
</li>
<li> <p><code>query</code>: Additional query parameters, a named list, to add to the URL.
</p>
</li></ul>

<p><code>get_app()</code> returns the app object.
</p>
<p><code>get_port()</code> returns the port the web server is running on.
</p>
<p><code>stop()</code> stops the web server, and also the subprocess. If the error
log file is not empty, then it dumps its contents to the screen.
</p>
<p><code>get_state()</code> returns a string, the state of the web server:
</p>

<ul>
<li> <p><code>"not running"</code> the server is not running (because it was stopped
already).
</p>
</li>
<li> <p><code>"live"</code> means that the server is running.
</p>
</li>
<li> <p><code>"dead"</code> means that the subprocess has quit or crashed.
</p>
</li></ul>

<p><code>local_env()</code> sets the given environment variables for the duration of
the app process. It resets them in <code style="white-space: pre;">&#8288;$stop()&#8288;</code>. Webfakes replaces <code>{url}</code>
in the value of the environment variables with the app URL, so you can
set environment variables that point to the app.
</p>
<p><code>url()</code> returns the URL of the web app. You can use the <code>path</code>
parameter to return a specific path.
</p>



<h3>See Also</h3>

<p><code><a href="#topic+local_app_process">local_app_process()</a></code> for automatically cleaning up the
subprocess.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>app &lt;- new_app()
app$get("/foo", function(req, res) {
  res$send("Hello world!")
})

proc &lt;- new_app_process(app)
url &lt;- proc$url("/foo")
resp &lt;- curl::curl_fetch_memory(url)
cat(rawToChar(resp$content))

proc$stop()
</code></pre>

<hr>
<h2 id='new_regexp'>Create a new regular expression to use in webfakes routes</h2><span id='topic+new_regexp'></span><span id='topic+webfakes_regexp'></span>

<h3>Description</h3>

<p>Note that webfakes uses PERL regular expressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_regexp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_regexp_+3A_x">x</code></td>
<td>
<p>String scalar containing a regular expression.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As R does not have data type or class for regular expressions,
you can use <code>new_regexp()</code> to mark a string as a regular expression,
when adding routes.
</p>


<h3>Value</h3>

<p>String with class <code>webfakes_regexp</code>.
</p>


<h3>See Also</h3>

<p>The 'Path specification' and 'Path parameters' chapters
of the manual of <code><a href="#topic+new_app">new_app()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>new_regexp("^/api/match/(?&lt;pattern&gt;.*)$")
</code></pre>

<hr>
<h2 id='oauth2_httr_login'>Helper function to use httr's OAuth2.0 functions
non-interactively, e.g. in test cases</h2><span id='topic+oauth2_httr_login'></span>

<h3>Description</h3>

<p>To perform an automatic acknowledgement and log in for a
local OAuth2.0 app, run by httr, wrap the expression that
obtains the OAuth2.0 token in <code>oauth2_httr_login()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oauth2_httr_login(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oauth2_httr_login_+3A_expr">expr</code></td>
<td>
<p>Expression that calls <code><a href="httr.html#topic+oauth2.0_token">httr::oauth2.0_token()</a></code>,
either directly, or indirectly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In interactive sessions, <code>oauth2_httr_login()</code> overrides the
<code>browser</code> option, and when httr opens a browser page, it
calls <code><a href="#topic+oauth2_login">oauth2_login()</a></code> in a subprocess.
</p>
<p>In non-interactive sessions, httr does not open a browser page,
only messages the user to do it manually. <code>oauth2_httr_login()</code>
listens for these messages, and calls <code><a href="#topic+oauth2_login">oauth2_login()</a></code> in a
subprocess.
</p>


<h3>Value</h3>

<p>The return value of <code>expr</code>.
</p>


<h3>See Also</h3>

<p>See <code>?vignette("oauth", package = "webfakes")</code> for a case
study that uses this function.
</p>
<p>Other OAuth2.0 functions: 
<code><a href="#topic+oauth2_login">oauth2_login</a>()</code>,
<code><a href="#topic+oauth2_resource_app">oauth2_resource_app</a>()</code>,
<code><a href="#topic+oauth2_third_party_app">oauth2_third_party_app</a>()</code>
</p>

<hr>
<h2 id='oauth2_login'>Helper function to log in to a third party OAuth2.0 app without a
browser</h2><span id='topic+oauth2_login'></span>

<h3>Description</h3>

<p>It works with <code><a href="#topic+oauth2_resource_app">oauth2_resource_app()</a></code>, and any third party app,
including the fake <code><a href="#topic+oauth2_third_party_app">oauth2_third_party_app()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oauth2_login(login_url)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oauth2_login_+3A_login_url">login_url</code></td>
<td>
<p>The login URL of the third party app.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>test-oauth.R</code> in webfakes for an example.
</p>


<h3>Value</h3>

<p>A named list with
</p>

<ul>
<li> <p><code>login_response</code> The curl HTTP response object for the login
page.
</p>
</li>
<li> <p><code>token_response</code> The curl HTTP response object for submitting
the login page.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other OAuth2.0 functions: 
<code><a href="#topic+oauth2_httr_login">oauth2_httr_login</a>()</code>,
<code><a href="#topic+oauth2_resource_app">oauth2_resource_app</a>()</code>,
<code><a href="#topic+oauth2_third_party_app">oauth2_third_party_app</a>()</code>
</p>

<hr>
<h2 id='oauth2_resource_app'>Fake OAuth 2.0 resource and authorization app</h2><span id='topic+oauth2_resource_app'></span>

<h3>Description</h3>

<p>The webfakes package comes with two fake apps that allow to imitate the
OAuth2.0 flow in your test cases. (See <a href="https://aaronparecki.com/oauth-2-simplified/">Aaron Parecki’s tutorial</a> for a good
introduction to OAuth2.0.) One app (<code>oauth2_resource_app()</code>) is the API
server that serves both as the resource and provides authorization.
<code>oauth2_third_party_app()</code> plays the role of the third-party app. They
are useful when testing or demonstrating code handling OAuth2.0
authorization, token caching, etc. in a package. The apps can be used in
your tests directly, or you could adapt one or both of them to better
mimic a particular OAuth2.0 flow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oauth2_resource_app(
  access_duration = 3600L,
  refresh_duration = 7200L,
  refresh = TRUE,
  seed = NULL,
  authorize_endpoint = "/authorize",
  token_endpoint = "/token"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oauth2_resource_app_+3A_access_duration">access_duration</code></td>
<td>
<p>After how many seconds should access tokens
expire.</p>
</td></tr>
<tr><td><code id="oauth2_resource_app_+3A_refresh_duration">refresh_duration</code></td>
<td>
<p>After how many seconds should refresh
tokens expire (ignored if <code>refresh</code> is <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="oauth2_resource_app_+3A_refresh">refresh</code></td>
<td>
<p>Should a refresh token be returned (logical).</p>
</td></tr>
<tr><td><code id="oauth2_resource_app_+3A_seed">seed</code></td>
<td>
<p>Random seed used when creating tokens. If <code>NULL</code>,
we rely on R to provide a seed. The app uses its own RNG stream,
so it does not affect reproducibility of the tests.</p>
</td></tr>
<tr><td><code id="oauth2_resource_app_+3A_authorize_endpoint">authorize_endpoint</code></td>
<td>
<p>The authorization endpoint of the resource
server. Change this from the default if the real app that you
are faking does not use <code style="white-space: pre;">&#8288;/authorize&#8288;</code>.</p>
</td></tr>
<tr><td><code id="oauth2_resource_app_+3A_token_endpoint">token_endpoint</code></td>
<td>
<p>The endpoint to request tokens. Change this if the
real app that you are faking does not use <code style="white-space: pre;">&#8288;/token&#8288;</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The app has the following endpoints:
</p>

<ul>
<li> <p><code>GET /register</code> is the endpoint that you can use to register
your third party app. It needs to receive the <code>name</code> of the
third party app, and its <code>redirect_uri</code> as query parameters,
otherwise returns an HTTP 400 error. On success it returns a
JSON dictionary with entries <code>name</code> (the name of the third party
app), <code>client_id</code>, <code>client_secret</code> and <code>redirect_uri</code>.
</p>
</li>
<li> <p><code>GET /authorize</code> is the endpoint where the user of the third
party app is sent. You can change the URL of this endpoint with
the <code>authorize_endpoint</code> argument. It needs to receive the <code>client_id</code>
of the third party app, and its correct <code>redirect_uri</code> as query
parameters. It may receive a <code>state</code> string as well, which can
be used by a client to identify the request. Otherwise it
generates a random <code>state</code> string. On error it fails with a HTTP
400 error. On success it returns a simple HTML login page.
</p>
</li>
<li> <p><code>POST /authorize/decision</code> is the endpoint where the HTML login
page generated at <code style="white-space: pre;">&#8288;/authorize&#8288;</code> connects back to, either with a
positive or negative result. The form on the login page will send
the <code>state</code> string and the user's choice in the <code>action</code> variable.
If the user authorized the third party app, then they are
redirected to the <code>redirect_uri</code> of the app, with a temporary
<code>code</code> and the <code>state</code> string supplied as query parameters.
Otherwise a simple HTML page is returned.
</p>
</li>
<li> <p><code>POST /token</code> is the endpoint where the third party app requests
a temporary access token. It is also uses for refreshing an
access token with a refresh token. You can change the URL of this
endpoint with the <code>token_endpoint</code> argument.
To request a new token or refresh an existing one, the following
data must be included in either a JSON or an URL encoded request body:
</p>

<ul>
<li> <p><code>grant_type</code>, this must be <code>authorization_code</code> for new tokens,
and <code>refresh_token</code> for refreshing.
</p>
</li>
<li> <p><code>code</code>, this must be the temporary code obtained from the
<code style="white-space: pre;">&#8288;/authorize/decision&#8288;</code> redirection, for new tokens. It is not
needed when refreshing.
</p>
</li>
<li> <p><code>client_id</code> must be the client id of the third party app.
</p>
</li>
<li> <p><code>client_secret</code> must be the client secret of the third party
app.
</p>
</li>
<li> <p><code>redirect_uri</code> must be the correct redirection URI of the
third party app. It is not needed when refreshing tokens.
</p>
</li>
<li> <p><code>refresh_token</code> must be the refresh token obtained previously,
when refreshing a token. It is not needed for new tokens.
On success a JSON dictionary is returned with entries:
<code>access_token</code>, <code>expiry</code> and <code>refresh_token</code>. (The latter is
omitted if the <code>refresh</code> argument is <code>FALSE</code>).
</p>
</li></ul>

</li>
<li> <p><code>GET /locals</code> returns a list of current apps, access tokens and
refresh tokens.
</p>
</li>
<li> <p><code>GET /data</code> is an endpoint that returns a simple JSON response,
and needs authorization.
</p>
</li></ul>



<h4>Notes</h4>


<ul>
<li><p> Using this app in your tests requires the glue package, so you
need to put it in <code>Suggests</code>.
</p>
</li>
<li><p> You can add custom endpoints to the app, as needed.
</p>
</li>
<li><p> If you need authorization in your custom endpoint, call
<code>app$is_authorized()</code> in your handler:
</p>
<div class="sourceCode"><pre>if (!app$is_authorized(req, res)) return()
</pre></div>
<p><code>app$is_authorized()</code> returns an HTTP 401 response if the
client is not authorized, so you can simply return from your
handler.
</p>
</li></ul>

<p>For more details see <code>vignette("oauth", package = "webfakes")</code>.
</p>



<h3>Value</h3>

<p>a <code>webfakes</code> app
</p>
<p>webfakes app
</p>


<h3><code>oauth2_resource_app()</code></h3>

<p>App representing the API server (resource/authorization)
</p>


<h3>See Also</h3>

<p>Other OAuth2.0 functions: 
<code><a href="#topic+oauth2_httr_login">oauth2_httr_login</a>()</code>,
<code><a href="#topic+oauth2_login">oauth2_login</a>()</code>,
<code><a href="#topic+oauth2_third_party_app">oauth2_third_party_app</a>()</code>
</p>

<hr>
<h2 id='oauth2_third_party_app'>App representing the third-party app</h2><span id='topic+oauth2_third_party_app'></span>

<h3>Description</h3>

<p>The webfakes package comes with two fake apps that allow to imitate the
OAuth2.0 flow in your test cases. (See <a href="https://aaronparecki.com/oauth-2-simplified/">Aaron Parecki’s tutorial</a> for a good
introduction to OAuth2.0.) One app (<code>oauth2_resource_app()</code>) is the API
server that serves both as the resource and provides authorization.
<code>oauth2_third_party_app()</code> plays the role of the third-party app. They
are useful when testing or demonstrating code handling OAuth2.0
authorization, token caching, etc. in a package. The apps can be used in
your tests directly, or you could adapt one or both of them to better
mimic a particular OAuth2.0 flow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oauth2_third_party_app(name = "Third-Party app")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oauth2_third_party_app_+3A_name">name</code></td>
<td>
<p>Name of the third-party app</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Endpoints:
</p>

<ul>
<li> <p><code>POST /login/config</code> Use this endpoint to configure the client ID
and the client secret of the app, received from
<code><a href="#topic+oauth2_resource_app">oauth2_resource_app()</a></code> (or another resource app). You need to
send in a JSON or URL encoded body:
</p>

<ul>
<li> <p><code>auth_url</code>, the authorization URL of the resource app.
</p>
</li>
<li> <p><code>token_url</code>, the token URL of the resource app.
</p>
</li>
<li> <p><code>client_id</code>, the client ID, received from the resource app.
</p>
</li>
<li> <p><code>client_secret</code> the client secret, received from the resource
app.
</p>
</li></ul>

</li>
<li> <p><code>GET /login</code> Use this endpoint to start the login process. It
will redirect to the resource app for authorization and after the
OAuth2.0 dance to <code style="white-space: pre;">&#8288;/login/redirect&#8288;</code>.
</p>
</li>
<li> <p><code>GET /login/redirect</code>, <code>POST /login/redirect</code> This is the
redirect URI of the third party app. (Some HTTP clients redirect
a <code>POST</code> to a <code>GET</code>, others don't, so it has both.) This endpoint
is used by the resource app, and it received the <code>code</code> that can
be exchanged to an access token and the <code>state</code> which was
generated in <code style="white-space: pre;">&#8288;/login&#8288;</code>. It contacts the resource app to get an
access token, and then stores the token in its <code>app$locals</code>
local variables. It fails with HTTP code 500 if it cannot obtain
an access token. On success it returns a JSON dictionary with
<code>access_token</code>, <code>expiry</code> and <code>refresh_token</code> (optionally) by
default. This behavior can be changed by redefining the
<code>app$redirect_hook()</code> function.
</p>
</li>
<li> <p><code>GET /locals</code> returns the tokens that were obtained from the
resource app.
</p>
</li>
<li> <p><code>GET /data</code> is an endpoint that uses the obtained token(s) to
connect to the <code style="white-space: pre;">&#8288;/data&#8288;</code> endpoint of the resource app. The <code style="white-space: pre;">&#8288;/data&#8288;</code>
endpoint of the resource app needs authorization. It responds
with the response of the resource app. It tries to refresh the
access token of the app if needed.
</p>
</li></ul>

<p>For more details see <code>vignette("oauth", package = "webfakes")</code>.
</p>


<h3>Value</h3>

<p>webfakes app
</p>


<h3>See Also</h3>

<p>Other OAuth2.0 functions: 
<code><a href="#topic+oauth2_httr_login">oauth2_httr_login</a>()</code>,
<code><a href="#topic+oauth2_login">oauth2_login</a>()</code>,
<code><a href="#topic+oauth2_resource_app">oauth2_resource_app</a>()</code>
</p>

<hr>
<h2 id='server_opts'>Webfakes web server options</h2><span id='topic+server_opts'></span>

<h3>Description</h3>

<p>Webfakes web server options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>server_opts(
  remote = FALSE,
  port = NULL,
  num_threads = 1,
  interfaces = "127.0.0.1",
  enable_keep_alive = FALSE,
  access_log_file = remote,
  error_log_file = TRUE,
  tcp_nodelay = FALSE,
  throttle = Inf
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="server_opts_+3A_remote">remote</code></td>
<td>
<p>Meta-option. If set to <code>TRUE</code>, webfakes uses slightly
different defaults, that are more appropriate for a background
server process.</p>
</td></tr>
<tr><td><code id="server_opts_+3A_port">port</code></td>
<td>
<p>Port to start the web server on. Defaults to a randomly
chosen port.</p>
</td></tr>
<tr><td><code id="server_opts_+3A_num_threads">num_threads</code></td>
<td>
<p>Number of request handler threads to use. Typically
you don't need more than one thread, unless you run test cases in
parallel or you make concurrent HTTP requests.</p>
</td></tr>
<tr><td><code id="server_opts_+3A_interfaces">interfaces</code></td>
<td>
<p>The network interfaces to listen on. Being a test
web server, it defaults to the localhost. Only bind to a public
interface if you know what you are doing. webfakes was not designed
to serve public web pages.</p>
</td></tr>
<tr><td><code id="server_opts_+3A_enable_keep_alive">enable_keep_alive</code></td>
<td>
<p>Whether the server keeps connections alive.</p>
</td></tr>
<tr><td><code id="server_opts_+3A_access_log_file">access_log_file</code></td>
<td>
<p><code>TRUE</code>, <code>FALSE</code>, or a path. See 'Logging'
below.</p>
</td></tr>
<tr><td><code id="server_opts_+3A_error_log_file">error_log_file</code></td>
<td>
<p><code>TRUE</code>, <code>FALSE</code>, or a path. See 'Logging'
below.</p>
</td></tr>
<tr><td><code id="server_opts_+3A_tcp_nodelay">tcp_nodelay</code></td>
<td>
<p>if <code>TRUE</code> then packages will be sent as soon as
possible, instead of waiting for a full buffer or timeout to occur.</p>
</td></tr>
<tr><td><code id="server_opts_+3A_throttle">throttle</code></td>
<td>
<p>Limit download speed for clients. If not <code>Inf</code>,
then it is the maximum number of bytes per second, that is sent to
as connection.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of options that can be passed to <code>webfakes_app$listen()</code>
(see <code><a href="#topic+new_app">new_app()</a></code>), and <code><a href="#topic+new_app_process">new_app_process()</a></code>.
</p>


<h3>Logging</h3>


<ul>
<li><p> For <code>access_log_file</code>, <code>TRUE</code> means <code style="white-space: pre;">&#8288;&lt;log-dir&gt;/access.log&#8288;</code>.
</p>
</li>
<li><p> For <code>error_log_file</code>, <code>TRUE</code> means <code style="white-space: pre;">&#8288;&lt;log-dir&gt;/error.log&#8288;</code>.
</p>
</li></ul>

<p><code style="white-space: pre;">&#8288;&lt;log-dir&gt;&#8288;</code> is set to the contents of the <code>WEBFAKES_LOG_DIR</code>
environment variable, if it is set. Otherwise it is set to
<code style="white-space: pre;">&#8288;&lt;tmpdir&gt;/webfakes&#8288;</code> for local apps and <code style="white-space: pre;">&#8288;&lt;tmpdir&gt;/&lt;pid&gt;/webfakes&#8288;</code> for
remote apps (started with <code>new_app_procss()</code>).
</p>
<p><code style="white-space: pre;">&#8288;&lt;tmpdir&gt;&#8288;</code> is the session temporary directory of the <em>main process</em>.
</p>
<p><code style="white-space: pre;">&#8288;&lt;pid&gt;&#8288;</code> is the process id of the subprocess.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See the defaults
server_opts()
</code></pre>

<hr>
<h2 id='tmpl_glue'>glue based template engine</h2><span id='topic+tmpl_glue'></span>

<h3>Description</h3>

<p>Use this template engine to create pages with glue templates.
See <code><a href="glue.html#topic+glue">glue::glue()</a></code> for the syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tmpl_glue(
  sep = "",
  open = "{",
  close = "}",
  na = "NA",
  transformer = NULL,
  trim = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tmpl_glue_+3A_sep">sep</code></td>
<td>
<p>Separator used to separate elements.</p>
</td></tr>
<tr><td><code id="tmpl_glue_+3A_open">open</code></td>
<td>
<p>The opening delimiter. Doubling the full delimiter escapes
it.</p>
</td></tr>
<tr><td><code id="tmpl_glue_+3A_close">close</code></td>
<td>
<p>The closing delimiter. Doubling the full delimiter escapes
it.</p>
</td></tr>
<tr><td><code id="tmpl_glue_+3A_na">na</code></td>
<td>
<p>Value to replace NA values with. If <code>NULL</code> missing values are
propagated, that is an <code>NA</code> result will cause <code>NA</code> output.
Otherwise the value is replaced by the value of <code>na</code>.</p>
</td></tr>
<tr><td><code id="tmpl_glue_+3A_transformer">transformer</code></td>
<td>
<p>A function taking three parameters <code>code</code>, <code>envir</code>
and <code>data</code> used to transform the output of each block before during or
after evaluation.</p>
</td></tr>
<tr><td><code id="tmpl_glue_+3A_trim">trim</code></td>
<td>
<p>Whether to trim the input template with <code><a href="glue.html#topic+trim">glue::trim()</a></code> or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Template function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See th 'hello' app at
hello_root &lt;- system.file(package = "webfakes", "examples", "hello")
hello_root

app &lt;- new_app()
app$engine("txt", tmpl_glue())
app$use(mw_log())


app$get("/view", function(req, res) {
  txt &lt;- res$render("test")
  res$
    set_type("text/plain")$
    send(txt)
})

# Switch to the app's root: setwd(hello_root)
# Now start the app with: app$listen(3000L)
# Or start it in another process: new_process(app)
</code></pre>

<hr>
<h2 id='webfakes_request'>A webfakes request object</h2><span id='topic+webfakes_request'></span>

<h3>Description</h3>

<p>webfakes creates a <code>webfakes_request</code> object for every incoming HTTP
request. This object is passed to every matched route and middleware,
until the response is sent. It has reference semantics, so handlers
can modify it.
</p>


<h3>Details</h3>

<p>Fields and methods:
</p>

<ul>
<li> <p><code>app</code>: The <code>webfakes_app</code> object itself.
</p>
</li>
<li> <p><code>headers</code>: Named list of HTTP request headers.
</p>
</li>
<li> <p><code>hostname</code>: The Host header, the server hostname and maybe port.
</p>
</li>
<li> <p><code>method</code>: HTTP method.
</p>
</li>
<li> <p><code>path</code>: Server path.
</p>
</li>
<li> <p><code>protocol</code>: <code>"http"</code> or <code>"https"</code>.
</p>
</li>
<li> <p><code>query_string</code>: The raw query string, without the starting <code style="white-space: pre;">&#8288;?&#8288;</code>.
</p>
</li>
<li> <p><code>query</code>: Parsed query parameters in a named list.
</p>
</li>
<li> <p><code>remote_addr</code>: String, the domain name or IP address of the client.
webfakes runs on the localhost, so this is <code style="white-space: pre;">&#8288;127.0.0.1&#8288;</code>.
</p>
</li>
<li> <p><code>url</code>: The full URL of the request.
</p>
</li>
<li> <p><code>get_header(field)</code>: Function to query a request header. Returns
<code>NULL</code> if the header is not present.
</p>
</li></ul>

<p>Body parsing middleware adds additional fields to the request object.
See <code><a href="#topic+mw_raw">mw_raw()</a></code>, <code><a href="#topic+mw_text">mw_text()</a></code>, <code><a href="#topic+mw_json">mw_json()</a></code>, <code><a href="#topic+mw_multipart">mw_multipart()</a></code> and
<code><a href="#topic+mw_urlencoded">mw_urlencoded()</a></code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+webfakes_response">webfakes_response</a> for the webfakes response object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is how you can see the request and response objects:
app &lt;- new_app()
app$get("/", function(req, res) {
  browser()
  res$send("done")
})
app

# Now start this app on a port:
# app$listen(3000)
# and connect to it from a web browser: http://127.0.0.1:3000
# You can also use another R session to connect:
# httr::GET("http://127.0.0.1:3000")
# or the command line curl tool:
# curl -v http://127.0.0.1:3000
# The app will stop while processing the request.
</code></pre>

<hr>
<h2 id='webfakes_response'>A webfakes response object</h2><span id='topic+webfakes_response'></span>

<h3>Description</h3>

<p>webfakes creates a <code>webfakes_response</code> object for every incoming HTTP
request. This object is passed to every matched route and middleware,
until the HTTP response is sent. It has reference semantics, so handlers
can modify it.
</p>


<h3>Details</h3>

<p>Fields and methods:
</p>

<ul>
<li> <p><code>app</code>: The <code>webfakes_app</code> object itself.
</p>
</li>
<li> <p><code>req</code>: The request object.
</p>
</li>
<li> <p><code>headers_sent</code>: Whether the response headers were already sent out.
</p>
</li>
<li> <p><code>locals</code>: Local variables, the are shared between the handler
functions. This is for the end user, and not for the middlewares.
</p>
</li>
<li> <p><code>delay(secs)</code>: delay the response for a number of seconds. If a
handler calls <code>delay()</code>, the same handler will be called again,
after the specified number of seconds have passed. Use the <code>locals</code>
environment to distinguish between the calls. If you are using
<code>delay()</code>, and want to serve requests in parallel, then you probably
need a multi-threaded server, see <code><a href="#topic+server_opts">server_opts()</a></code>.
</p>
</li>
<li> <p><code>add_header(field, value)</code>: Add a response header. Note that
<code>add_header()</code> may create duplicate headers. You usually want
<code>set_header()</code>.
</p>
</li>
<li> <p><code>get_header(field)</code>: Query the currently set response headers. If
<code>field</code> is not present it return <code>NULL</code>.
</p>
</li>
<li> <p><code>on_response(fun)</code>: Run the <code>fun</code> handler function just before the
response is sent out. At this point the headers and the body are
already properly set.
</p>
</li>
<li> <p><code>redirect(path, status = 302)</code>: Send a redirect response. It sets
the <code>Location</code> header, and also sends a <code>text/plain</code> body.
</p>
</li>
<li> <p><code>render(view, locals = list())</code>: Render a template page. Searches
for the <code>view</code> template page, using all registered engine extensions,
and calls the first matching template engine. Returns the filled
template.
</p>
</li>
<li> <p><code>send(body)</code>. Send the specified body. <code>body</code> can be a raw vector,
or HTML or other text. For raw vectors it sets the content type to
<code>application/octet-stream</code>.
</p>
</li>
<li> <p><code>send_json(object = NULL, text = NULL, ...)</code>: Send a JSON response.
Either <code>object</code> or <code>text</code> must be given. <code>object</code> will be converted
to JSON using <code><a href="jsonlite.html#topic+fromJSON">jsonlite::toJSON()</a></code>. <code>...</code> are passed to
<code><a href="jsonlite.html#topic+fromJSON">jsonlite::toJSON()</a></code>. It sets the content type appropriately.
</p>
</li>
<li> <p><code>send_file(path, root = ".")</code>: Send a file. Set <code>root = "/"</code> for
absolute file names. It sets the content type automatically, based
on the extension of the file, if it is not set already.
</p>
</li>
<li> <p><code>send_status(status)</code>: Send the specified HTTP status code, without
a response body.
</p>
</li>
<li> <p><code>send_chunk(data)</code>: Send a chunk of a response in chunked encoding.
The first chunk will automatically send the HTTP response headers.
Webfakes will automatically send a final zero-lengh chunk, unless
<code style="white-space: pre;">&#8288;$delay()&#8288;</code> is called.
</p>
</li>
<li> <p><code>set_header(field, value)</code>: Set a response header. If the headers have
been sent out already, then it throws a warning, and does nothing.
</p>
</li>
<li> <p><code>set_status(status)</code>: Set the response status code. If the headers
have been sent out already, then it throws a warning, and does nothing.
</p>
</li>
<li> <p><code>set_type(type)</code>: Set the response content type. If it contains a <code>/</code>
character then it is set as is, otherwise it is assumed to be a file
extension, and the corresponding MIME type is set. If the headers have
been sent out already, then it throws a warning, and does nothing.
</p>
</li>
<li> <p><code>add_cookie(name, value, options)</code>: Adds a cookie to the response.
<code>options</code> is a named list, and may contain:
</p>

<ul>
<li> <p><code>domain</code>: Domain name for the cookie, not set by default.
</p>
</li>
<li> <p><code>expires</code>: Expiry date in GMT. It must be a POSIXct object, and
will be formatted correctly.
</p>
</li>
<li><p> 'http_only': if TRUE, then it sets the 'HttpOnly' attribute, so
Javasctipt cannot access the cookie.
</p>
</li>
<li> <p><code>max_age</code>: Maximum age, in number of seconds.
</p>
</li>
<li> <p><code>path</code>: Path for the cookie, defaults to &quot;/&quot;.
</p>
</li>
<li> <p><code>same_site</code>: The 'SameSite' cookie attribute. Possible values are
&quot;strict&quot;, &quot;lax&quot; and &quot;none&quot;.
</p>
</li>
<li> <p><code>secure</code>: if TRUE, then it sets the 'Secure' attribute.
</p>
</li></ul>

</li>
<li> <p><code>clear_cookie(name, options = list())</code>: clears a cookie. Typically,
web browsers will only clear a cookie if the options also match.
</p>
</li>
<li> <p><code>write(data)</code>: writes (part of) the body of the response. It also
sends out the response headers, if they haven't been sent out before.
</p>
</li></ul>

<p>Usually you need one of the <code>send()</code> methods, to send out the HTTP
response in one go, first the headers, then the body.
</p>
<p>Alternatively, you can use <code style="white-space: pre;">&#8288;$write()&#8288;</code> to send the response in parts.
</p>


<h3>See Also</h3>

<p><a href="#topic+webfakes_request">webfakes_request</a> for the webfakes request object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is how you can see the request and response objects:
app &lt;- new_app()
app$get("/", function(req, res) {
  browser()
  res$send("done")
})
app

# Now start this app on a port:
# app$listen(3000)
# and connect to it from a web browser: http://127.0.0.1:3000
# You can also use another R session to connect:
# httr::GET("http://127.0.0.1:3000")
# or the command line curl tool:
# curl -v http://127.0.0.1:3000
# The app will stop while processing the request.
</code></pre>

<hr>
<h2 id='webfakes-package'>webfakes: Fake Web Apps for HTTP Testing</h2><span id='topic+webfakes'></span><span id='topic+webfakes-package'></span>

<h3>Description</h3>

<p>Create a web app that makes it easier to test web clients without using the internet. It includes a web app framework with path matching, parameters and templates. Can parse various 'HTTP' request bodies. Can send 'JSON' data or files from the disk. Includes a web app that implements the 'httpbin.org' web service.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Gábor Csárdi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li>
<li><p>  Civetweb contributors (see inst/credits/ciwetweb.md) [contributor]
</p>
</li>
<li><p>  Redoc contributors (see inst/credits/redoc.md) [contributor]
</p>
</li>
<li><p> L. Peter Deutsch (src/md5.h) [contributor]
</p>
</li>
<li><p> Martin Purschke (src/md5.h) [contributor]
</p>
</li>
<li><p>  Aladdin Enterprises (src/md5.h) [copyright holder]
</p>
</li>
<li><p> Maëlle Salmon <a href="mailto:maelle.salmon@yahoo.se">maelle.salmon@yahoo.se</a> (<a href="https://orcid.org/0000-0002-2815-0399">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://webfakes.r-lib.org/">https://webfakes.r-lib.org/</a>
</p>
</li>
<li> <p><a href="https://github.com/r-lib/webfakes">https://github.com/r-lib/webfakes</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/r-lib/webfakes/issues">https://github.com/r-lib/webfakes/issues</a>
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
