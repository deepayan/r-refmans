<!DOCTYPE html><html><head><title>Help for package MoNAn</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MoNAn}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MoNAn-package'><p>MoNAn: Mobility Network Analysis</p></a></li>
<li><a href='#alter_covariate'><p>alter_covariate</p></a></li>
<li><a href='#autoCorrelationTest'><p>autoCorrelationTest</p></a></li>
<li><a href='#concentration_basic'><p>concentration_basic</p></a></li>
<li><a href='#concentration_GW'><p>concentration_GW</p></a></li>
<li><a href='#concentration_GW_dyad_covar'><p>concentration_GW_dyad_covar</p></a></li>
<li><a href='#concentration_prop'><p>concentration_prop</p></a></li>
<li><a href='#concentration_prop_orig_cov'><p>concentration_prop_orig_cov</p></a></li>
<li><a href='#concentration_rankGW'><p>concentration_rankGW</p></a></li>
<li><a href='#createAlgorithm'><p>createAlgorithm</p></a></li>
<li><a href='#createEdgelist'><p>createEdgelist</p></a></li>
<li><a href='#createEffectsObject'><p>createEffectsObject</p></a></li>
<li><a href='#createNetwork'><p>createNetwork</p></a></li>
<li><a href='#createNodeSet'><p>createNodeSet</p></a></li>
<li><a href='#createNodeVariable'><p>createNodeVariable</p></a></li>
<li><a href='#createProcessState'><p>createProcessState</p></a></li>
<li><a href='#createWeightedCache'><p>createWeightedCache</p></a></li>
<li><a href='#crowding_out_prop_covar_bin'><p>crowding_out_prop_covar_bin</p></a></li>
<li><a href='#dyadic_covariate'><p>dyadic_covariate</p></a></li>
<li><a href='#dyadic_covariate_resource_attribute'><p>dyadic_covariate_resource_attribute</p></a></li>
<li><a href='#estimateMobilityNetwork'><p>estimateMobilityNetwork</p></a></li>
<li><a href='#extractTraces'><p>extractTraces</p></a></li>
<li><a href='#getIndegree'><p>getIndegree</p></a></li>
<li><a href='#getMultinomialStatistics'><p>getMultinomialStatistics</p></a></li>
<li><a href='#getTieWeights'><p>getTieWeights</p></a></li>
<li><a href='#gofMobilityNetwork'><p>gofMobilityNetwork</p></a></li>
<li><a href='#in_ties_loops'><p>in_ties_loops</p></a></li>
<li><a href='#in_weights_exponent'><p>in_weights_exponent</p></a></li>
<li><a href='#in_weights_GW'><p>in_weights_GW</p></a></li>
<li><a href='#loops'><p>loops</p></a></li>
<li><a href='#loops_additional_origin'><p>loops_additional_origin</p></a></li>
<li><a href='#loops_GW'><p>loops_GW</p></a></li>
<li><a href='#loops_node_covar'><p>loops_node_covar</p></a></li>
<li><a href='#loops_resource_covar'><p>loops_resource_covar</p></a></li>
<li><a href='#loops_resource_covar_node_covar'><p>loops_resource_covar_node_covar</p></a></li>
<li><a href='#loops_x_loops_additional_origin'><p>loops_x_loops_additional_origin</p></a></li>
<li><a href='#mobilityData'><p>Example Data for the MoNAn Package</p></a></li>
<li><a href='#myOutcomeObjects'><p>Exemplary Outcome Objects for the MoNAn Package</p></a></li>
<li><a href='#present_relations'><p>present_relations</p></a></li>
<li><a href='#reciprocity_basic'><p>reciprocity_basic</p></a></li>
<li><a href='#reciprocity_GW'><p>reciprocity_GW</p></a></li>
<li><a href='#reciprocity_GW_dyad_covar'><p>reciprocity_GW_dyad_covar</p></a></li>
<li><a href='#reciprocity_GW_dyad_covar_bin'><p>reciprocity_GW_dyad_covar_bin</p></a></li>
<li><a href='#reciprocity_min'><p>reciprocity_min</p></a></li>
<li><a href='#reciprocity_min_dyad_covar'><p>reciprocity_min_dyad_covar</p></a></li>
<li><a href='#reciprocity_min_resource_covar'><p>reciprocity_min_resource_covar</p></a></li>
<li><a href='#resource_covar_to_node_covar'><p>resource_covar_to_node_covar</p></a></li>
<li><a href='#same_covariate'><p>same_covariate</p></a></li>
<li><a href='#scoreTest'><p>scoreTest</p></a></li>
<li><a href='#sim_covariate'><p>sim_covariate</p></a></li>
<li><a href='#simulateMobilityNetworks'><p>simulateMobilityNetworks</p></a></li>
<li><a href='#staying_by_prop_bin_inflow'><p>staying_by_prop_bin_inflow</p></a></li>
<li><a href='#target_change_match'><p>target_change_match</p></a></li>
<li><a href='#test_effect'><p>test_effect</p>
</p>
<p>Test for each person in the example data and one randomly selected</p>
alternative destination whether change and target statistics match.</a></li>
<li><a href='#transitivity_basic'><p>transitivity_basic</p></a></li>
<li><a href='#transitivity_GW'><p>transitivity_GW</p></a></li>
<li><a href='#transitivity_min'><p>transitivity_min</p></a></li>
<li><a href='#transitivity_netflow'><p>transitivity_netflow</p></a></li>
<li><a href='#triad120C'><p>triad120C</p></a></li>
<li><a href='#triad120D'><p>triad120D</p></a></li>
<li><a href='#triad120U'><p>triad120U</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Mobility Network Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-04</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the method to analyse weighted mobility networks or distribution networks as outlined in: 
    Block, P., Stadtfeld, C., &amp; Robins, G. (2022) &lt;<a href="https://doi.org/10.1016%2Fj.socnet.2021.08.003">doi:10.1016/j.socnet.2021.08.003</a>&gt;. 
    The purpose of the model is to analyse the structure of mobility, 
    incorporating exogenous predictors pertaining to individuals and locations 
    known from classical mobility analyses, as well as modelling emergent mobility 
    patterns akin to structural patterns known from the statistical analysis of social networks.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>snowfall (&ge; 1.84-6.2), methods</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-05 12:19:42 UTC; per</td>
</tr>
<tr>
<td>Author:</td>
<td>Per Block <a href="https://orcid.org/0000-0002-7583-2392"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre,
    aut, cph],
  Christoph Stadtfeld
    <a href="https://orcid.org/0000-0002-2704-2134"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Nico Keiser [aut],
  Marion Hoffman [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Per Block &lt;block@soziologie.uzh.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-05 12:40:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='MoNAn-package'>MoNAn: Mobility Network Analysis</h2><span id='topic+MoNAn'></span><span id='topic+MoNAn-package'></span>

<h3>Description</h3>

<p>Implements the method to analyse weighted mobility networks or distribution networks as outlined in: Block, P., Stadtfeld, C., &amp; Robins, G. (2022) <a href="https://doi.org/10.1016/j.socnet.2021.08.003">doi:10.1016/j.socnet.2021.08.003</a>. The purpose of the model is to analyse the structure of mobility, incorporating exogenous predictors pertaining to individuals and locations known from classical mobility analyses, as well as modelling emergent mobility patterns akin to structural patterns known from the statistical analysis of social networks.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Per Block <a href="mailto:block@soziologie.uzh.ch">block@soziologie.uzh.ch</a> (<a href="https://orcid.org/0000-0002-7583-2392">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Christoph Stadtfeld (<a href="https://orcid.org/0000-0002-2704-2134">ORCID</a>)
</p>
</li>
<li><p> Nico Keiser
</p>
</li>
<li><p> Marion Hoffman
</p>
</li></ul>


<hr>
<h2 id='alter_covariate'>alter_covariate</h2><span id='topic+alter_covariate'></span>

<h3>Description</h3>

<p>Are locations higher on some attribute v more popular targets of mobility?
E.g., do workers have a tendency to move to larger organisations?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alter_covariate(
  dep.var = 1,
  attribute.index,
  state,
  cache,
  i,
  j,
  edge,
  update,
  loop.contribution = TRUE,
  getTargetContribution = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alter_covariate_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="alter_covariate_+3A_attribute.index">attribute.index</code></td>
<td>
</td></tr>
<tr><td><code id="alter_covariate_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="alter_covariate_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="alter_covariate_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="alter_covariate_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="alter_covariate_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="alter_covariate_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="alter_covariate_+3A_loop.contribution">loop.contribution</code></td>
<td>
</td></tr>
<tr><td><code id="alter_covariate_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='autoCorrelationTest'>autoCorrelationTest</h2><span id='topic+autoCorrelationTest'></span>

<h3>Description</h3>

<p>The autoCorrelationTest indicates the degree to which the values of the dependent
variable of consecutive draws from the chain in phase 3 are correlated. Here lower
values are better. Values above 0.5 are very problematic and indicate that a
higher thinning is needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoCorrelationTest(ans)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoCorrelationTest_+3A_ans">ans</code></td>
<td>
<p>An object of class &quot;result.monan&quot; resulting from an estimation with the function <code><a href="#topic+estimateMobilityNetwork">estimateMobilityNetwork()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number indicating the auto-correlation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># regression diagnostics
autoCorrelationTest(myResDN)
</code></pre>

<hr>
<h2 id='concentration_basic'>concentration_basic</h2><span id='topic+concentration_basic'></span>

<h3>Description</h3>

<p>Is there a bandwagon effect in mobility, i.e. do mobile individuals move to
locations that are the destination of many others from their origin?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concentration_basic(
  dep.var = 1,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concentration_basic_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_basic_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_basic_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_basic_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_basic_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_basic_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_basic_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_basic_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='concentration_GW'>concentration_GW</h2><span id='topic+concentration_GW'></span>

<h3>Description</h3>

<p>Is there a bandwagon effect in mobility, i.e. do mobile individuals move to locations
that are the destination of many others from their origin? The functional form of this
statistic assumes that there are decreasing additional returns to more others on the
same mobility path. For example, the probability to choose a mobility path that already
contains 20 other individuals is hardly different from a path with 25 other individuals;
however, there is a substantial difference in the comparison of paths with 2 or 7 other
individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concentration_GW(
  dep.var = 1,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE,
  alpha = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concentration_GW_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_GW_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_GW_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_GW_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_GW_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_GW_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_GW_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_GW_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_GW_+3A_alpha">alpha</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='concentration_GW_dyad_covar'>concentration_GW_dyad_covar</h2><span id='topic+concentration_GW_dyad_covar'></span>

<h3>Description</h3>

<p>Are bandwagon effects (concentration) particularly prevalent between locations
that share characteristics as encoded in a binary dyadic covariate? E.g., do
workers follow the moves of other workers mainly in case they go to organisations
in the same region?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concentration_GW_dyad_covar(
  dep.var = 1,
  attribute.index,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE,
  alpha = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concentration_GW_dyad_covar_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_GW_dyad_covar_+3A_attribute.index">attribute.index</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_GW_dyad_covar_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_GW_dyad_covar_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_GW_dyad_covar_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_GW_dyad_covar_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_GW_dyad_covar_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_GW_dyad_covar_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_GW_dyad_covar_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_GW_dyad_covar_+3A_alpha">alpha</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='concentration_prop'>concentration_prop</h2><span id='topic+concentration_prop'></span>

<h3>Description</h3>

<p>Is there a bandwagon effect in mobility, i.e. do mobile individuals move to locations
that are the destination of many others from their origin? The functional form of this
statistic assumes that individuals consider the proportions of individuals (coming from
the same origin) going to a certain destination, instead of the total number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concentration_prop(
  dep.var = 1,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concentration_prop_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_prop_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_prop_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_prop_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_prop_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_prop_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_prop_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_prop_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='concentration_prop_orig_cov'>concentration_prop_orig_cov</h2><span id='topic+concentration_prop_orig_cov'></span>

<h3>Description</h3>

<p>Is there a bandwagon effect in mobility, i.e. do mobile individuals move to locations
that are the destination of many others from their origin? The functional form of this
statistic assumes that individuals consider the proportions of individuals (coming from
the same origin) going to a certain destination, instead of the total number.
This is weighted by an attribute of the origin, to model differences in
concentration by origin characteristic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concentration_prop_orig_cov(
  dep.var = 1,
  attribute.index,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concentration_prop_orig_cov_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_prop_orig_cov_+3A_attribute.index">attribute.index</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_prop_orig_cov_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_prop_orig_cov_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_prop_orig_cov_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_prop_orig_cov_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_prop_orig_cov_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_prop_orig_cov_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_prop_orig_cov_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='concentration_rankGW'>concentration_rankGW</h2><span id='topic+concentration_rankGW'></span>

<h3>Description</h3>

<p>Is there a bandwagon effect in mobility, i.e. do mobile individuals move to locations
that are the destination of many others from their origin? The functional form of this
statistic assumes that there are increasing returns to choosing more populated paths
but the return of using a path only depends on the ranking of this path in terms of number
of people using it among all paths (and not the actual numbers of people on this path).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concentration_rankGW(
  dep.var = 1,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE,
  lambda = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concentration_rankGW_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_rankGW_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_rankGW_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_rankGW_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_rankGW_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_rankGW_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_rankGW_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_rankGW_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
<tr><td><code id="concentration_rankGW_+3A_lambda">lambda</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='createAlgorithm'>createAlgorithm</h2><span id='topic+createAlgorithm'></span>

<h3>Description</h3>

<p>Specifies the algorithm used in the estimation based on characteristics
of the state and the effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createAlgorithm(
  state,
  effects,
  multinomialProposal = FALSE,
  burnInN1 = NULL,
  thinningN1 = NULL,
  iterationsN1 = NULL,
  gainN1 = 0.1,
  burnInN2 = NULL,
  thinningN2 = NULL,
  initialIterationsN2 = 50,
  nsubN2 = 4,
  initGain = 0.6,
  burnInN3 = NULL,
  thinningN3 = NULL,
  iterationsN3 = 500,
  allowLoops = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createAlgorithm_+3A_state">state</code></td>
<td>
<p>An object of class &quot;processState.monan&quot; that contains all relevant information about
the outcome in the form of an edgelist, the nodesets, and covariates.</p>
</td></tr>
<tr><td><code id="createAlgorithm_+3A_effects">effects</code></td>
<td>
<p>An object of class &quot;effectsList.monan&quot; that specifies the model.</p>
</td></tr>
<tr><td><code id="createAlgorithm_+3A_multinomialproposal">multinomialProposal</code></td>
<td>
<p>How should the next possible outcome in the simulation chains
be sampled? If TRUE, fewer simulation steps are needed, but each simulation
step takes considerably longer. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="createAlgorithm_+3A_burninn1">burnInN1</code></td>
<td>
<p>The number of simulation steps before the first draw in Phase 1.
A recommended value is at least n_Individuals * n_locations if
multinomialProposal = FALSE, and at least n_Individuals if multinomialProposal = TRUE
which is set as default.</p>
</td></tr>
<tr><td><code id="createAlgorithm_+3A_thinningn1">thinningN1</code></td>
<td>
<p>The number of simulation steps between two draws in Phase 1.
A recommended value is at least 0.5 * n_Individuals * n_locations if
multinomialProposal = FALSE, and at least n_Individuals if multinomialProposal = TRUE
which is set as default.</p>
</td></tr>
<tr><td><code id="createAlgorithm_+3A_iterationsn1">iterationsN1</code></td>
<td>
<p>The number of draws taken in Phase 1.
A recommended value is at least 4 * n_effects which is set as default.
If the value is too low, there will be an error in Phase 1.</p>
</td></tr>
<tr><td><code id="createAlgorithm_+3A_gainn1">gainN1</code></td>
<td>
<p>The size of the updating step after Phase 1. A conservative
value is 0, values higher than 0.25 are courageous. Defaults to 0.1.</p>
</td></tr>
<tr><td><code id="createAlgorithm_+3A_burninn2">burnInN2</code></td>
<td>
<p>The number of simulation steps before the first draw in Phase 1.
A recommended value is at least n_Individuals * n_locations if
multinomialProposal = FALSE, and at least n_Individuals if multinomialProposal = TRUE
which is set as default.</p>
</td></tr>
<tr><td><code id="createAlgorithm_+3A_thinningn2">thinningN2</code></td>
<td>
<p>The number of simulation steps between two draws in Phase 2.
A recommended value is at least 0.5 * n_Individuals * n_locations if
multinomialProposal = FALSE, and at least n_Individuals if multinomialProposal = TRUE
which is set as default.</p>
</td></tr>
<tr><td><code id="createAlgorithm_+3A_initialiterationsn2">initialIterationsN2</code></td>
<td>
<p>The number of draws taken in subphase 1 of Phase 2.
For first estimations, a recommended value is around 50 (default to 50).
Note that in later subphases, the number of iterations increases.
If this is a further estimation to improve convergence, higher values (100+)
are recommended.</p>
</td></tr>
<tr><td><code id="createAlgorithm_+3A_nsubn2">nsubN2</code></td>
<td>
<p>Number of subphases in Phase 2. In case this is the first
estimation, 4 subphases are recommended and set as default. If convergence
in a previous estimation was close, then 1-2 subphases should be enough.</p>
</td></tr>
<tr><td><code id="createAlgorithm_+3A_initgain">initGain</code></td>
<td>
<p>The magnitude of parameter updates in the first subphase of
Phase 2. Values of around 0.2 (default) are recommended.</p>
</td></tr>
<tr><td><code id="createAlgorithm_+3A_burninn3">burnInN3</code></td>
<td>
<p>The number of simulation steps before the first draw in Phase 3.
A recommended value is at least 3 * n_Individuals * n_locations if
multinomialProposal = FALSE, and at least 3 * n_Individuals if multinomialProposal = TRUE
which is set as default.</p>
</td></tr>
<tr><td><code id="createAlgorithm_+3A_thinningn3">thinningN3</code></td>
<td>
<p>The number of simulation steps between two draws in Phase 3.
A recommended value is at least n_Individuals * n_locations if
multinomialProposal = FALSE, and at least 2 * n_Individuals if multinomialProposal = TRUE
which is set as default.
In case this value is too low, the outcome might erroneously indicate a lack
of convergence.</p>
</td></tr>
<tr><td><code id="createAlgorithm_+3A_iterationsn3">iterationsN3</code></td>
<td>
<p>Number of draws in Phase 3. Recommended are at the very
least 500 (default).
In case this value is too low, the outcome might erroneously indicate a lack
of convergence.</p>
</td></tr>
<tr><td><code id="createAlgorithm_+3A_allowloops">allowLoops</code></td>
<td>
<p>Logical: can individuals/resources stay in their origin?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;algorithm.monan&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createProcessState">createProcessState()</a></code>, <code><a href="#topic+createEffectsObject">createEffectsObject()</a></code>, <code><a href="#topic+estimateMobilityNetwork">estimateMobilityNetwork()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define algorithm based on state and effects characteristics
myAlg &lt;- createAlgorithm(myState, myEffects, multinomialProposal = FALSE)
</code></pre>

<hr>
<h2 id='createEdgelist'>createEdgelist</h2><span id='topic+createEdgelist'></span>

<h3>Description</h3>

<p>Creates an edgelist object, which is the standard format of the outcome to be modelled
by MoNAn.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createEdgelist(el, nodeSet = c("location", "location", "individuals"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createEdgelist_+3A_el">el</code></td>
<td>
<p>An edgelist in the form of a matrix with two columns and N rows.
The first column indicates the origin of a person/resource, the second row the destination.
Each row represents one observation.</p>
</td></tr>
<tr><td><code id="createEdgelist_+3A_nodeset">nodeSet</code></td>
<td>
<p>The nodesets of the edgelists. This is a vector with three
entries referencing the names of the nodesets of locations and individuals
of the form c(location, location, individuals).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;edgelist.monan&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createProcessState">createProcessState()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create an object of class edgelist.monan
transfers &lt;- createEdgelist(mobilityEdgelist, c("organisations", "organisations", "people"))
</code></pre>

<hr>
<h2 id='createEffectsObject'>createEffectsObject</h2><span id='topic+createEffectsObject'></span>

<h3>Description</h3>

<p>Specifies the model with endogenous and exogenous predictors.
The predictors in the model are called “effects”.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createEffectsObject(effectInit, checkProcessState = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createEffectsObject_+3A_effectinit">effectInit</code></td>
<td>
<p>A list of &quot;effects&quot;, where each effect to be included is specified as a
further list that contains the effect name and the additional parameters it needs.
Effects without further parameters only contain the effect name (e.g., loops).</p>
</td></tr>
<tr><td><code id="createEffectsObject_+3A_checkprocessstate">checkProcessState</code></td>
<td>
<p>For internal use only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;effectsList.monan&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create an effects object
myEffects &lt;- createEffectsObject(
  list(
    list("loops"),
    list("reciprocity_min"),
    list("dyadic_covariate", attribute.index = "sameRegion"),
    list("alter_covariate", attribute.index = "size"),
    list("resource_covar_to_node_covar",
      attribute.index = "region",
      resource.attribute.index = "sex"
    ),
    list("loops_resource_covar", resource.attribute.index = "sex")
  )
)
</code></pre>

<hr>
<h2 id='createNetwork'>createNetwork</h2><span id='topic+createNetwork'></span>

<h3>Description</h3>

<p>Defines a network between locations, generally to be used as a predictor in the model.
NOTE: The outcome variable of the model is not defined as a network, but as an edgelist!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createNetwork(
  m,
  isSymmetric = FALSE,
  isBipartite = FALSE,
  nodeSet = c("actors", "actors")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createNetwork_+3A_m">m</code></td>
<td>
<p>A square matrix containing the network data.</p>
</td></tr>
<tr><td><code id="createNetwork_+3A_issymmetric">isSymmetric</code></td>
<td>
<p>Currently not in use.</p>
</td></tr>
<tr><td><code id="createNetwork_+3A_isbipartite">isBipartite</code></td>
<td>
<p>Currently not in use.</p>
</td></tr>
<tr><td><code id="createNetwork_+3A_nodeset">nodeSet</code></td>
<td>
<p>Which nodeset are the nodes of the network. Usually this will
be the locations in the data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;network.monan&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createProcessState">createProcessState()</a></code>, <code><a href="#topic+createEdgelist">createEdgelist()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create an object of class network.monan
sameRegion &lt;- outer(orgRegion, orgRegion, "==") * 1
sameRegion &lt;- createNetwork(sameRegion, nodeSet = c("organisations", "organisations"))
</code></pre>

<hr>
<h2 id='createNodeSet'>createNodeSet</h2><span id='topic+createNodeSet'></span>

<h3>Description</h3>

<p>Determines and names the nodesets of individuals and locations that make up the mobility network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createNodeSet(x = NULL, isPresent = NULL, considerWhenSampling = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createNodeSet_+3A_x">x</code></td>
<td>
<p>Either a single number indicating how many items are in this nodeset
or a vector from 1:n_items.</p>
</td></tr>
<tr><td><code id="createNodeSet_+3A_ispresent">isPresent</code></td>
<td>
<p>Currently not in use.</p>
</td></tr>
<tr><td><code id="createNodeSet_+3A_considerwhensampling">considerWhenSampling</code></td>
<td>
<p>A boolean/logical vector of the length of the nodeset.
Only in use in special cases.
If the nodeset indicates a location, considerWhenSampling indicates whether the
location is a possible destination, or is only an origin (e.g. a training facility).
Entries in the vector of locations that cannot be a destination are FALSE.
If the nodeset indicates mobile individuals, considerWhenSampling indicates whether
their mobility should be modelled or whether it is structurally determined, that
is, their mobility is exogenously defined and does not follow the same logic as
the mobility of everybody else.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;nodeSet.monan&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createProcessState">createProcessState()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create an object of class nodeSet.monan
people &lt;- createNodeSet(1:nrow(mobilityEdgelist))
organisations &lt;- createNodeSet(length(orgRegion))
</code></pre>

<hr>
<h2 id='createNodeVariable'>createNodeVariable</h2><span id='topic+createNodeVariable'></span>

<h3>Description</h3>

<p>Assigns a covariate to one nodeset, i.e., an exogenous characteristic of mobile
individuals/resources or locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createNodeVariable(
  values,
  range = NULL,
  nodeSet = "actors",
  addSame = FALSE,
  addSim = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createNodeVariable_+3A_values">values</code></td>
<td>
<p>A vector assigning the covariate value to each element of the nodeset.</p>
</td></tr>
<tr><td><code id="createNodeVariable_+3A_range">range</code></td>
<td>
<p>The range of possible values, currently not in use.</p>
</td></tr>
<tr><td><code id="createNodeVariable_+3A_nodeset">nodeSet</code></td>
<td>
<p>The nodeset to which the covariate applies.</p>
</td></tr>
<tr><td><code id="createNodeVariable_+3A_addsame">addSame</code></td>
<td>
<p>Will the variable be used to model categorical homophily (e.g.,
with the same_covariate effect)? In this case, addSame needs to be set to TRUE.</p>
</td></tr>
<tr><td><code id="createNodeVariable_+3A_addsim">addSim</code></td>
<td>
<p>Will the variable be used to model continuous homophily (e.g.,
with the sim_covariate effect)? In this case, addSim needs to be set to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;nodeVar.monan&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createProcessState">createProcessState()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create an object of class nodeVar.monan
region &lt;- createNodeVariable(orgRegion, nodeSet = "organisations")
size &lt;- createNodeVariable(orgSize, nodeSet = "organisations", addSim = TRUE)
sex &lt;- createNodeVariable(indSex, nodeSet = "people")
</code></pre>

<hr>
<h2 id='createProcessState'>createProcessState</h2><span id='topic+createProcessState'></span>

<h3>Description</h3>

<p>Creates the &quot;Process state&quot;, i.e., a MoNAn object that stores all information
about the data that will be used in the estimation. This includes the
outcome variable (edgelist), the nodesets, and all covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createProcessState(elements, dependentVariable)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createProcessState_+3A_elements">elements</code></td>
<td>
<p>A named list of the outcome variable (edgelist), the nodesets,
and all covariates that contain the information about the data that will be
used in the estimation.</p>
</td></tr>
<tr><td><code id="createProcessState_+3A_dependentvariable">dependentVariable</code></td>
<td>
<p>The name of the outcome variable (edgelist) as
specified under &quot;elements&quot;. This indicates what outcome
the researcher is interested in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;processState.monan&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createEdgelist">createEdgelist()</a></code>, <code><a href="#topic+createNodeSet">createNodeSet()</a></code>,
<code><a href="#topic+createNodeVariable">createNodeVariable()</a></code>, <code><a href="#topic+createNetwork">createNetwork()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a process state out of the mobility data objects:
# create objects (which are later combined to the process state)
transfers &lt;- createEdgelist(mobilityEdgelist,
  nodeSet = c("organisations", "organisations", "people")
)
people &lt;- createNodeSet(1:nrow(mobilityEdgelist))
organisations &lt;- createNodeSet(1:length(orgRegion))
sameRegion &lt;- outer(orgRegion, orgRegion, "==") * 1
sameRegion &lt;- createNetwork(sameRegion,
  nodeSet = c("organisations", "organisations")
)
region &lt;- createNodeVariable(orgRegion, nodeSet = "organisations")
size &lt;- createNodeVariable(orgSize, nodeSet = "organisations", addSim = TRUE)
sex &lt;- createNodeVariable(indSex, nodeSet = "people")

# combine created objects to the process state
myState &lt;- createProcessState(list(
    transfers = transfers,
    people = people,
    organisations = organisations,
    sameRegion = sameRegion,
    region = region,
    size = size,
    sex = sex),
  dependentVariable = "transfers")
</code></pre>

<hr>
<h2 id='createWeightedCache'>createWeightedCache</h2><span id='topic+createWeightedCache'></span>

<h3>Description</h3>

<p>Creates a necessary internal object used in simulating the chains in the
simulation and estimation of the model.
In case variables of the individuals in the data are included in the state,
they need to be explicitly mentioned in the creation of the cache under
“resourceCovariates”.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createWeightedCache(processState, resourceCovariates = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createWeightedCache_+3A_processstate">processState</code></td>
<td>
<p>The processs state that provides the data basis for
creating the cache.</p>
</td></tr>
<tr><td><code id="createWeightedCache_+3A_resourcecovariates">resourceCovariates</code></td>
<td>
<p>A vector of resource covariates that will be
used in the model specification.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cache object provided as a list.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createProcessState">createProcessState()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create cache object
myCache &lt;- createWeightedCache(myState, resourceCovariates = c("sex"))
</code></pre>

<hr>
<h2 id='crowding_out_prop_covar_bin'>crowding_out_prop_covar_bin</h2><span id='topic+crowding_out_prop_covar_bin'></span>

<h3>Description</h3>

<p>Is the tendency to stay in vs. move out of a location of individuals of type
non-w dependent on the proportion of individuals of type w moving into the location?
This is especially geared towards modelling how some locations become more or
less attractive dependent on the change in composition for
particular groups. This models segregation dynamics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crowding_out_prop_covar_bin(
  dep.var = 1,
  resource.attribute.index,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crowding_out_prop_covar_bin_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="crowding_out_prop_covar_bin_+3A_resource.attribute.index">resource.attribute.index</code></td>
<td>
</td></tr>
<tr><td><code id="crowding_out_prop_covar_bin_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="crowding_out_prop_covar_bin_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="crowding_out_prop_covar_bin_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="crowding_out_prop_covar_bin_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="crowding_out_prop_covar_bin_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="crowding_out_prop_covar_bin_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="crowding_out_prop_covar_bin_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='dyadic_covariate'>dyadic_covariate</h2><span id='topic+dyadic_covariate'></span>

<h3>Description</h3>

<p>Is mobility between locations predicted by the dyadic covariate u? E.g., is mobility
likely between organisations that are in the same region? Note that in many cases
dyadic covariates can convey the same information as
the ‘same covariate’ or the ‘covariate similarity’ effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dyadic_covariate(
  dep.var = 1,
  attribute.index,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dyadic_covariate_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="dyadic_covariate_+3A_attribute.index">attribute.index</code></td>
<td>
</td></tr>
<tr><td><code id="dyadic_covariate_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="dyadic_covariate_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="dyadic_covariate_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="dyadic_covariate_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="dyadic_covariate_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="dyadic_covariate_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="dyadic_covariate_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='dyadic_covariate_resource_attribute'>dyadic_covariate_resource_attribute</h2><span id='topic+dyadic_covariate_resource_attribute'></span>

<h3>Description</h3>

<p>Is mobility between locations predicted by the dyadic covariate u weighted by
the individual covariate w? E.g., is mobility of women more likely between
organisations that are in the same region? Note that this effect can be used
to also model the interaction between the ‘same covariate’/‘covariate similarity’
effect and individual attributes, since sameness and similarity between locations
can be translated into dyadic covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dyadic_covariate_resource_attribute(
  dep.var = 1,
  attribute.index,
  resource.attribute.index,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dyadic_covariate_resource_attribute_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="dyadic_covariate_resource_attribute_+3A_attribute.index">attribute.index</code></td>
<td>
</td></tr>
<tr><td><code id="dyadic_covariate_resource_attribute_+3A_resource.attribute.index">resource.attribute.index</code></td>
<td>
</td></tr>
<tr><td><code id="dyadic_covariate_resource_attribute_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="dyadic_covariate_resource_attribute_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="dyadic_covariate_resource_attribute_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="dyadic_covariate_resource_attribute_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="dyadic_covariate_resource_attribute_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="dyadic_covariate_resource_attribute_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="dyadic_covariate_resource_attribute_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='estimateMobilityNetwork'>estimateMobilityNetwork</h2><span id='topic+estimateMobilityNetwork'></span><span id='topic+estimateDistributionNetwork'></span><span id='topic+print.result.monan'></span>

<h3>Description</h3>

<p>The core function of the package in which the model for the analysis of
mobility tables is estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateMobilityNetwork(
  state,
  cache,
  effects,
  algorithm,
  initialParameters = NULL,
  prevAns = NULL,
  parallel = FALSE,
  cpus = 1,
  verbose = FALSE,
  returnDeps = FALSE,
  fish = FALSE
)

estimateDistributionNetwork(
  state,
  cache,
  effects,
  algorithm,
  initialParameters = NULL,
  prevAns = NULL,
  parallel = FALSE,
  cpus = 1,
  verbose = FALSE,
  returnDeps = FALSE,
  fish = FALSE
)

## S3 method for class 'result.monan'
print(x, covMat = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateMobilityNetwork_+3A_state">state</code></td>
<td>
<p>An object of class &quot;processState.monan&quot; which contains all relevant information about
the outcome in the form of an edgelist, the nodesets, and covariates.</p>
</td></tr>
<tr><td><code id="estimateMobilityNetwork_+3A_cache">cache</code></td>
<td>
<p>A cache object created from the same state object that is
used in the estimation.</p>
</td></tr>
<tr><td><code id="estimateMobilityNetwork_+3A_effects">effects</code></td>
<td>
<p>An object of class &quot;effectsList.monan&quot; that specifies the model.</p>
</td></tr>
<tr><td><code id="estimateMobilityNetwork_+3A_algorithm">algorithm</code></td>
<td>
<p>An object of class &quot;algorithm.monan&quot; which specifies the algorithm used in the estimation.</p>
</td></tr>
<tr><td><code id="estimateMobilityNetwork_+3A_initialparameters">initialParameters</code></td>
<td>
<p>Starting values for the parameters. Using starting
values, e.g., from a multinomial logit model (see <code><a href="#topic+getMultinomialStatistics">getMultinomialStatistics()</a></code>)
increases the chances of model convergence in the first run of the estimation
considerably.</p>
</td></tr>
<tr><td><code id="estimateMobilityNetwork_+3A_prevans">prevAns</code></td>
<td>
<p>If a previous estimation did not yield satisfactory convergence,
the outcome object of that estimation should be specified here to provide new
starting values for the estimation.</p>
</td></tr>
<tr><td><code id="estimateMobilityNetwork_+3A_parallel">parallel</code></td>
<td>
<p>Logical: computation on multiple cores?</p>
</td></tr>
<tr><td><code id="estimateMobilityNetwork_+3A_cpus">cpus</code></td>
<td>
<p>Number of cores for computation in case parallel = TRUE.</p>
</td></tr>
<tr><td><code id="estimateMobilityNetwork_+3A_verbose">verbose</code></td>
<td>
<p>Logical: display information about estimation progress in the console?</p>
</td></tr>
<tr><td><code id="estimateMobilityNetwork_+3A_returndeps">returnDeps</code></td>
<td>
<p>Logical: should the simulated values of Phase 3 be stored and returned?
This is necessary to run GoF tests.
Note that this might result in very large objects.</p>
</td></tr>
<tr><td><code id="estimateMobilityNetwork_+3A_fish">fish</code></td>
<td>
<p>Logical: display a fish?</p>
</td></tr>
<tr><td><code id="estimateMobilityNetwork_+3A_x">x</code></td>
<td>
<p>An object of class &quot;result.monan&quot;.</p>
</td></tr>
<tr><td><code id="estimateMobilityNetwork_+3A_covmat">covMat</code></td>
<td>
<p>Logical: indicating whether the covariance matrix should be printed.</p>
</td></tr>
<tr><td><code id="estimateMobilityNetwork_+3A_...">...</code></td>
<td>
<p>For internal use only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>estimateMobilityNetwork</code> returns an object of class &quot;result.monan&quot; that contains the estimates, standard errors,
and convergence statistics. Furthermore, the covariance matrix used to calculate
the standard errors is included, which also shows collinearity between effects.
In case returnDeps = TRUE, the simulations of Phase 3 are included, too.
</p>
<p>The function <code>print.result.monan</code> prints the results from a monan
estimation with three columns indicating the estimate, the standard error,
and the convergence statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createProcessState">createProcessState()</a></code>, <code><a href="#topic+createWeightedCache">createWeightedCache()</a></code>,
<code><a href="#topic+createEffectsObject">createEffectsObject()</a></code>, <code><a href="#topic+createAlgorithm">createAlgorithm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# estimate mobility network model

myAlg_short &lt;- createAlgorithm(myState, myEffects, multinomialProposal = FALSE,
                               nsubN2 = 1, iterationsN3 = 100)

myResDN &lt;- estimateMobilityNetwork(myState, myCache, myEffects, myAlg_short,
                                   initialParameters = NULL,
                                   # in case a pseudo-likelihood estimation was run, replace with
                                   # initialParameters = initEst,
                                   parallel = TRUE, cpus = 4,
                                   verbose = TRUE,
                                   returnDeps = TRUE,
                                   fish = FALSE
)

# check convergence
max(abs(myResDN$convergenceStatistics))

# view results
myResDN

myResDN
</code></pre>

<hr>
<h2 id='extractTraces'>extractTraces</h2><span id='topic+extractTraces'></span><span id='topic+plot.traces.monan'></span>

<h3>Description</h3>

<p>This function shows the values of simulated statistics in Phase 3 for subsequent draws from the chain.
Ideally, the plots show points randomly scattered around the red line, which indicates the statistics in the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractTraces(ans, effects)

## S3 method for class 'traces.monan'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractTraces_+3A_ans">ans</code></td>
<td>
<p>An object of class &quot;result.monan&quot; resulting from an estimation with the function <code><a href="#topic+estimateMobilityNetwork">estimateMobilityNetwork()</a></code>.</p>
</td></tr>
<tr><td><code id="extractTraces_+3A_effects">effects</code></td>
<td>
<p>An object of class &quot;effectsList.monan&quot; used in the estimation.</p>
</td></tr>
<tr><td><code id="extractTraces_+3A_x">x</code></td>
<td>
<p>An object of class &quot;traces.monan&quot;.</p>
</td></tr>
<tr><td><code id="extractTraces_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters, use not recommended.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>extractTraces</code> returns a list that includes
(1) the observed statistics for all effects,
(2) the distribution of statistics for all simulations and
(3) effect names.
It is recommended to use the plotting function to inspect the traces.
</p>
<p>The function <code>plot.traces.monan</code> shows a scatter plot of the
statistics of simulated networks from phase three of the esimtation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createEffectsObject">createEffectsObject()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# regression diagnostics
traces &lt;- extractTraces(myResDN, myEffects)


plot(traces)

</code></pre>

<hr>
<h2 id='getIndegree'>getIndegree</h2><span id='topic+getIndegree'></span>

<h3>Description</h3>

<p>Calculates the weighted indegree distribution of all locations in the
network.
The weighted indegree is simply the column sum of the mobility table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getIndegree(cache, dep.var, lvls, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getIndegree_+3A_cache">cache</code></td>
<td>
<p>Current Cache.</p>
</td></tr>
<tr><td><code id="getIndegree_+3A_dep.var">dep.var</code></td>
<td>
<p>Dependent Variable.</p>
</td></tr>
<tr><td><code id="getIndegree_+3A_lvls">lvls</code></td>
<td>
<p>Levels for which the function calculates values.</p>
</td></tr>
<tr><td><code id="getIndegree_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The degree distribution of simulated networks.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gofMobilityNetwork">gofMobilityNetwork()</a></code>
</p>

<hr>
<h2 id='getMultinomialStatistics'>getMultinomialStatistics</h2><span id='topic+getMultinomialStatistics'></span>

<h3>Description</h3>

<p>One updating step in simulating the mobility network model can be expressed
as a multinomial logit model. Extracting the statistics for such a model allows
a straight-forward estimation of a multinomial logit model to get initial
estimates for the full mobility model, which increases the chances of model
convergence in the first run of the estimation considerably.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMultinomialStatistics(state, cache, effects)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMultinomialStatistics_+3A_state">state</code></td>
<td>
<p>An object of class &quot;processState.monan&quot; that stores all information to be used in the model.</p>
</td></tr>
<tr><td><code id="getMultinomialStatistics_+3A_cache">cache</code></td>
<td>
<p>A cache object that contains intermediate information used for estimation.</p>
</td></tr>
<tr><td><code id="getMultinomialStatistics_+3A_effects">effects</code></td>
<td>
<p>An object of class &quot;effectsList.monan&quot; for which the statistics of a multinomial
model should be calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with N * M rows (N = mobile individuals, M = number of locations)
that specifies for each observation the statistics associated with moving to this location.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createProcessState">createProcessState()</a></code>, <code><a href="#topic+createWeightedCache">createWeightedCache()</a></code>, <code><a href="#topic+createEffectsObject">createEffectsObject()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myStatisticsFrame &lt;- getMultinomialStatistics(myState, myCache, myEffects)
</code></pre>

<hr>
<h2 id='getTieWeights'>getTieWeights</h2><span id='topic+getTieWeights'></span>

<h3>Description</h3>

<p>Extracts the distribution of tie weights in the mobility network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTieWeights(cache, dep.var, lvls, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTieWeights_+3A_cache">cache</code></td>
<td>
<p>Current Cache.</p>
</td></tr>
<tr><td><code id="getTieWeights_+3A_dep.var">dep.var</code></td>
<td>
<p>Dependent Variable.</p>
</td></tr>
<tr><td><code id="getTieWeights_+3A_lvls">lvls</code></td>
<td>
<p>Levels for which the function calculates values.</p>
</td></tr>
<tr><td><code id="getTieWeights_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The tie weight distribution of simulated networks.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gofMobilityNetwork">gofMobilityNetwork()</a></code>
</p>

<hr>
<h2 id='gofMobilityNetwork'>gofMobilityNetwork</h2><span id='topic+gofMobilityNetwork'></span><span id='topic+gofDistributionNetwork'></span><span id='topic+plot.gof.stats.monan'></span>

<h3>Description</h3>

<p>Akin to ERGMs, goodness of fit testing is available to see whether auxiliary
statistics are well captured by the model. The logic behind gof testing for network models is outlined in
Hunter et al. (2008) and Lospinoso and Snijders (2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gofMobilityNetwork(ans, simulations, gofFunction, lvls = NULL)

gofDistributionNetwork(ans, simulations, gofFunction, lvls = NULL)

## S3 method for class 'gof.stats.monan'
plot(x, lvls, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gofMobilityNetwork_+3A_ans">ans</code></td>
<td>
<p>An object of class &quot;result.monan&quot; resulting from an estimation with the function <code><a href="#topic+estimateMobilityNetwork">estimateMobilityNetwork()</a></code>.</p>
</td></tr>
<tr><td><code id="gofMobilityNetwork_+3A_simulations">simulations</code></td>
<td>
<p>The simulated outcomes with which the observed statistics are compared.
Usually, they are stored in the ans$deps, in case deps = TRUE was specified in the
estimation.</p>
</td></tr>
<tr><td><code id="gofMobilityNetwork_+3A_goffunction">gofFunction</code></td>
<td>
<p>A gof function that specifies which auxiliary outcome should be used,
e.g., &quot;getIndegree&quot; or &quot;getTieWeights&quot;.</p>
</td></tr>
<tr><td><code id="gofMobilityNetwork_+3A_lvls">lvls</code></td>
<td>
<p>The values for which the gofFunction should be calculated/plotted.</p>
</td></tr>
<tr><td><code id="gofMobilityNetwork_+3A_x">x</code></td>
<td>
<p>An object of class &quot;gof.stats.monan&quot;.</p>
</td></tr>
<tr><td><code id="gofMobilityNetwork_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters, use discouraged.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>gofMobilityNetwork</code> returns a list containing
(1) the observed values of the auxiliary statistics and
(2) a list of the simulated values of the auxiliary statistics.
</p>
<p>The function <code>plot.gof.stats.monan</code> returns violin plots of the
gof tests with observed values superimposed in red.
</p>


<h3>References</h3>

<p>Hunter, D. R., Goodreau, S. M., &amp; Handcock, M. S. (2008). Goodness of fit of social network models.
<em>Journal of the american statistical association</em>, 103(481), 248-258.
</p>
<p>Lospinoso, J., &amp; Snijders, T. A. (2019).
Goodness of fit for stochastic actor-oriented models. <em>Methodological Innovations</em>, 12(3).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getIndegree">getIndegree()</a></code>, <code><a href="#topic+getTieWeights">getTieWeights()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># goodness of fit
myGofIndegree &lt;- gofMobilityNetwork(ans = myResDN, 
                                        simulations = myResDN$deps, 
                                        gofFunction = getIndegree, 
                                        lvls = 1:100)

myGofTieWeight &lt;- gofMobilityNetwork(ans = myResDN, 
                                         simulations = myResDN$deps, 
                                         gofFunction = getTieWeights, 
                                         lvls = 1:30)
plot(myGofIndegree,  lvls = 20:70)
plot(myGofTieWeight, lvls = 1:15)
</code></pre>

<hr>
<h2 id='in_ties_loops'>in_ties_loops</h2><span id='topic+in_ties_loops'></span>

<h3>Description</h3>

<p>Are individuals that are in locations with a large inflow more likely to stay
in their current location?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in_ties_loops(
  dep.var = 1,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="in_ties_loops_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="in_ties_loops_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="in_ties_loops_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="in_ties_loops_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="in_ties_loops_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="in_ties_loops_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="in_ties_loops_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="in_ties_loops_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='in_weights_exponent'>in_weights_exponent</h2><span id='topic+in_weights_exponent'></span>

<h3>Description</h3>

<p>Is there a preferential attachment in the mobility network, i.e., do individuals
move particularly to popular destinations?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in_weights_exponent(
  dep.var = 1,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE,
  exponent = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="in_weights_exponent_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="in_weights_exponent_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="in_weights_exponent_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="in_weights_exponent_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="in_weights_exponent_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="in_weights_exponent_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="in_weights_exponent_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="in_weights_exponent_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
<tr><td><code id="in_weights_exponent_+3A_exponent">exponent</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='in_weights_GW'>in_weights_GW</h2><span id='topic+in_weights_GW'></span>

<h3>Description</h3>

<p>Is there a preferential attachment in the mobility network, i.e., do individuals
move particularly to popular destinations?
The geometrically weighted version avoids degeneracy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in_weights_GW(
  dep.var = 1,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE,
  alpha = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="in_weights_GW_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="in_weights_GW_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="in_weights_GW_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="in_weights_GW_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="in_weights_GW_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="in_weights_GW_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="in_weights_GW_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="in_weights_GW_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
<tr><td><code id="in_weights_GW_+3A_alpha">alpha</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='loops'>loops</h2><span id='topic+loops'></span>

<h3>Description</h3>

<p>Do individuals stay in their location of origin, compared to going to a different location?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loops(
  dep.var = 1,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loops_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="loops_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="loops_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="loops_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="loops_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="loops_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="loops_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="loops_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='loops_additional_origin'>loops_additional_origin</h2><span id='topic+loops_additional_origin'></span>

<h3>Description</h3>

<p>This effect models loops for cases in which individuals have more than one
origin. The additional origin not specified in the mobility data is included
as a resource.attribute.index.
The question modeled is: Do individuals stay in the additional location of
origin, compared to going to a different location?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loops_additional_origin(
  dep.var = 1,
  resource.attribute.index,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loops_additional_origin_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="loops_additional_origin_+3A_resource.attribute.index">resource.attribute.index</code></td>
<td>
</td></tr>
<tr><td><code id="loops_additional_origin_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="loops_additional_origin_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="loops_additional_origin_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="loops_additional_origin_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="loops_additional_origin_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="loops_additional_origin_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="loops_additional_origin_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='loops_GW'>loops_GW</h2><span id='topic+loops_GW'></span>

<h3>Description</h3>

<p>Do individuals stay in their current location, in case many other from their
current location also stay? This effect tests whether the ‘benefit’ of staying
in the origin location depends on the number of others also staying. Note that
this effect should be modelled alongside the loops effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loops_GW(
  dep.var = 1,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE,
  alpha = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loops_GW_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="loops_GW_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="loops_GW_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="loops_GW_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="loops_GW_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="loops_GW_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="loops_GW_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="loops_GW_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
<tr><td><code id="loops_GW_+3A_alpha">alpha</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='loops_node_covar'>loops_node_covar</h2><span id='topic+loops_node_covar'></span>

<h3>Description</h3>

<p>Are locations with specific attributes ‘stickier’ than others, i.e., do individuals
have a higher propensity to stay in some locations? E.g., are individuals working
in organisations in one region less likely to change their employer?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loops_node_covar(
  dep.var = 1,
  attribute.index,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loops_node_covar_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="loops_node_covar_+3A_attribute.index">attribute.index</code></td>
<td>
</td></tr>
<tr><td><code id="loops_node_covar_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="loops_node_covar_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="loops_node_covar_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="loops_node_covar_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="loops_node_covar_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="loops_node_covar_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="loops_node_covar_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='loops_resource_covar'>loops_resource_covar</h2><span id='topic+loops_resource_covar'></span>

<h3>Description</h3>

<p>Are individuals with certain characteristics more likely to remain in their current
location? For example, are men more likely to remain in their current organisation,
while women are more likely to move employer?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loops_resource_covar(
  dep.var = 1,
  resource.attribute.index,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loops_resource_covar_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="loops_resource_covar_+3A_resource.attribute.index">resource.attribute.index</code></td>
<td>
</td></tr>
<tr><td><code id="loops_resource_covar_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="loops_resource_covar_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="loops_resource_covar_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="loops_resource_covar_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="loops_resource_covar_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="loops_resource_covar_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="loops_resource_covar_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='loops_resource_covar_node_covar'>loops_resource_covar_node_covar</h2><span id='topic+loops_resource_covar_node_covar'></span>

<h3>Description</h3>

<p>This is an interaction of the previous two effects: Do individuals with certain
characteristics have a tendency to stay in locations of certain types? Note that
this effect should be included alongside the main effects of ‘loops by individual
covariate’ and ‘loops by location covariate’.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loops_resource_covar_node_covar(
  dep.var = 1,
  resource.attribute.index,
  attribute.index,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loops_resource_covar_node_covar_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="loops_resource_covar_node_covar_+3A_resource.attribute.index">resource.attribute.index</code></td>
<td>
</td></tr>
<tr><td><code id="loops_resource_covar_node_covar_+3A_attribute.index">attribute.index</code></td>
<td>
</td></tr>
<tr><td><code id="loops_resource_covar_node_covar_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="loops_resource_covar_node_covar_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="loops_resource_covar_node_covar_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="loops_resource_covar_node_covar_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="loops_resource_covar_node_covar_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="loops_resource_covar_node_covar_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="loops_resource_covar_node_covar_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='loops_x_loops_additional_origin'>loops_x_loops_additional_origin</h2><span id='topic+loops_x_loops_additional_origin'></span>

<h3>Description</h3>

<p>This effect is specified for cases in which individuals have more than one
origin. The additional origin not specified in the mobility data is included
as a resource.attribute.index.
The question modeled is: Do individuals stay in the additional location of
origin if this is additionally their origin as specified in the mobility data,
compared to going to a different location?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loops_x_loops_additional_origin(
  dep.var = 1,
  resource.attribute.index,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loops_x_loops_additional_origin_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="loops_x_loops_additional_origin_+3A_resource.attribute.index">resource.attribute.index</code></td>
<td>
</td></tr>
<tr><td><code id="loops_x_loops_additional_origin_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="loops_x_loops_additional_origin_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="loops_x_loops_additional_origin_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="loops_x_loops_additional_origin_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="loops_x_loops_additional_origin_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="loops_x_loops_additional_origin_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="loops_x_loops_additional_origin_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='mobilityData'>Example Data for the MoNAn Package</h2><span id='topic+mobilityData'></span><span id='topic+mobilityEdgelist'></span><span id='topic+orgRegion'></span><span id='topic+orgSize'></span><span id='topic+indSex'></span>

<h3>Description</h3>

<p>These are example data for the MoNAn package and can be used to estimate a
mobility network. The raw example data is synthetic (i.e., made up).
This fictitious example contains 17 organisations representing
a labour market that are located in two regions (north and south).
742 workers are employed in these organisations at two time-points.
Some are mobile while others work in the same organisation at both time-points.
The following objects are provided for this purpose:
</p>

<dl>
<dt><code>mobilityEdgelist</code></dt><dd><p>The data frame indicates the origin at time 1
(first column) and the destination at time 2 (second column) for
each of the 742 individuals between the 17 organisations. Note that some
workers stay in their organisation, i.e. their origin equals their
destination.</p>
</dd>
<dt><code>orgRegion</code></dt><dd><p>Categorical characteristic describing whether the
organisation is located on the northern (1) or southern (0) region.</p>
</dd>
<dt><code>orgSize</code></dt><dd><p>Continuous measure representing the size of each
organisation based on assets and revenue.</p>
</dd>
<dt><code>indSex</code></dt><dd><p>Individual-level characteristics representing sex.</p>
</dd>
</dl>



<h3>Format</h3>

<p><code>mobilityEdgelist</code>
A data frame with 742 rows and 2 columns.
</p>
<p><code>orgRegion</code>
An object with 17 values.
</p>
<p><code>orgSize</code>
An object with 17 values.
</p>
<p><code>indSex</code>
An object with 742 values.
</p>

<hr>
<h2 id='myOutcomeObjects'>Exemplary Outcome Objects for the MoNAn Package</h2><span id='topic+myOutcomeObjects'></span><span id='topic+myState'></span><span id='topic+myCache'></span><span id='topic+myEffects'></span><span id='topic+myAlg'></span><span id='topic+myResDN'></span><span id='topic+mySimDN'></span>

<h3>Description</h3>

<p>These are exemplary outcome objects for the MoNAn package and can be used in
order not to run all precedent functions and thus save time. The following
products are provided:
</p>


<h3>Format</h3>

<p><code>myState</code>
An object of class &quot;processState.monan&quot; created by the function <code><a href="#topic+createProcessState">createProcessState()</a></code>.
</p>
<p><code>myCache</code>
A &quot;list&quot; created by the function <code><a href="#topic+createWeightedCache">createWeightedCache()</a></code>.
</p>
<p><code>myEffects</code>
An object of class &quot;effectsList.monan&quot; created by the function <code><a href="#topic+createEffectsObject">createEffectsObject()</a></code>.
</p>
<p><code>myAlg</code>
An object of class &quot;algorithm.monan&quot; created by the function <code><a href="#topic+createAlgorithm">createAlgorithm()</a></code>.
</p>
<p><code>myResDN</code>
An object of class &quot;result.monan&quot; created by the function <code><a href="#topic+estimateMobilityNetwork">estimateMobilityNetwork()</a></code>.
</p>
<p><code>mySimDN</code>
An object of class &quot;sims.monan&quot; created by the function <code><a href="#topic+simulateMobilityNetworks">simulateMobilityNetworks()</a></code>.
</p>

<hr>
<h2 id='present_relations'>present_relations</h2><span id='topic+present_relations'></span>

<h3>Description</h3>

<p>Do individuals move along many or few paths out of their origin? This models
whether individuals have a tendency against being the only one
moving to a particular destination from their origin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>present_relations(
  dep.var = 1,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="present_relations_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="present_relations_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="present_relations_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="present_relations_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="present_relations_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="present_relations_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="present_relations_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="present_relations_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='reciprocity_basic'>reciprocity_basic</h2><span id='topic+reciprocity_basic'></span>

<h3>Description</h3>

<p>Do individuals move to destinations dependent on the number of individuals that
move to ego’s origin from that destination?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reciprocity_basic(
  dep.var = 1,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reciprocity_basic_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_basic_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_basic_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_basic_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_basic_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_basic_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_basic_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_basic_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='reciprocity_GW'>reciprocity_GW</h2><span id='topic+reciprocity_GW'></span>

<h3>Description</h3>

<p>Do individuals move to destinations that send many individuals to ego’s origin?
The number of incoming individuals has decreasing returns, that is, every
additionally incoming individual influences ego’s choice less.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reciprocity_GW(
  dep.var = 1,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE,
  alpha = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reciprocity_GW_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_GW_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_GW_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_GW_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_GW_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_GW_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_GW_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_GW_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_GW_+3A_alpha">alpha</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='reciprocity_GW_dyad_covar'>reciprocity_GW_dyad_covar</h2><span id='topic+reciprocity_GW_dyad_covar'></span>

<h3>Description</h3>

<p>Is reciprocity in mobility particularly prevalent between locations weighted
by a dyadic covariate? E.g., do workers move
to organisations similar in some way to ego’s origin?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reciprocity_GW_dyad_covar(
  dep.var = 1,
  attribute.index,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE,
  alpha = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reciprocity_GW_dyad_covar_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_GW_dyad_covar_+3A_attribute.index">attribute.index</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_GW_dyad_covar_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_GW_dyad_covar_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_GW_dyad_covar_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_GW_dyad_covar_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_GW_dyad_covar_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_GW_dyad_covar_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_GW_dyad_covar_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_GW_dyad_covar_+3A_alpha">alpha</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='reciprocity_GW_dyad_covar_bin'>reciprocity_GW_dyad_covar_bin</h2><span id='topic+reciprocity_GW_dyad_covar_bin'></span>

<h3>Description</h3>

<p>Is reciprocity in mobility particularly prevalent between locations that share
characteristics as encoded in a binary dyadic covariate? E.g., do workers move
to organisations in the same region that send more workers to ego’s origin?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reciprocity_GW_dyad_covar_bin(
  dep.var = 1,
  attribute.index,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE,
  alpha = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reciprocity_GW_dyad_covar_bin_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_GW_dyad_covar_bin_+3A_attribute.index">attribute.index</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_GW_dyad_covar_bin_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_GW_dyad_covar_bin_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_GW_dyad_covar_bin_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_GW_dyad_covar_bin_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_GW_dyad_covar_bin_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_GW_dyad_covar_bin_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_GW_dyad_covar_bin_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_GW_dyad_covar_bin_+3A_alpha">alpha</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='reciprocity_min'>reciprocity_min</h2><span id='topic+reciprocity_min'></span>

<h3>Description</h3>

<p>Do individuals move to destinations that send more individuals to ego’s origin?
This version of the effect is the minimum of the moves in either direction,
thereby guarding against degeneracy and guaranteeing sample size consistency.
It counts the ‘raw’ number of reciprocated transitions in the mobility network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reciprocity_min(
  dep.var = 1,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reciprocity_min_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_min_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_min_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_min_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_min_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_min_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_min_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_min_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='reciprocity_min_dyad_covar'>reciprocity_min_dyad_covar</h2><span id='topic+reciprocity_min_dyad_covar'></span>

<h3>Description</h3>

<p>Do individuals move to destinations that send more individuals to ego’s origin?
This is weighted by a dydic covariate.
This version of the effect is the minimum of the moves in either direction,
thereby guarding against degeneracy and guaranteeing sample size consistency.
It counts the ‘raw’ number of reciprocated transitions in the mobility network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reciprocity_min_dyad_covar(
  dep.var = 1,
  attribute.index,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reciprocity_min_dyad_covar_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_min_dyad_covar_+3A_attribute.index">attribute.index</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_min_dyad_covar_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_min_dyad_covar_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_min_dyad_covar_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_min_dyad_covar_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_min_dyad_covar_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_min_dyad_covar_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_min_dyad_covar_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='reciprocity_min_resource_covar'>reciprocity_min_resource_covar</h2><span id='topic+reciprocity_min_resource_covar'></span>

<h3>Description</h3>

<p>Do people reciprocate moves to other locations specifically if they and others
have a higher value on some covariate? For example, do women move to organisations
that send women to their origin organisation?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reciprocity_min_resource_covar(
  dep.var = 1,
  resource.attribute.index,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reciprocity_min_resource_covar_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_min_resource_covar_+3A_resource.attribute.index">resource.attribute.index</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_min_resource_covar_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_min_resource_covar_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_min_resource_covar_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_min_resource_covar_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_min_resource_covar_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_min_resource_covar_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="reciprocity_min_resource_covar_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='resource_covar_to_node_covar'>resource_covar_to_node_covar</h2><span id='topic+resource_covar_to_node_covar'></span>

<h3>Description</h3>

<p>Do individuals with some individual attribute w tend to move to locations with
some location characteristic v? E.g., do women move to larger organisations than men?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resource_covar_to_node_covar(
  dep.var = 1,
  resource.attribute.index,
  attribute.index,
  state,
  cache,
  i,
  j,
  edge,
  update,
  loop.contribution = FALSE,
  getTargetContribution = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resource_covar_to_node_covar_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="resource_covar_to_node_covar_+3A_resource.attribute.index">resource.attribute.index</code></td>
<td>
</td></tr>
<tr><td><code id="resource_covar_to_node_covar_+3A_attribute.index">attribute.index</code></td>
<td>
</td></tr>
<tr><td><code id="resource_covar_to_node_covar_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="resource_covar_to_node_covar_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="resource_covar_to_node_covar_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="resource_covar_to_node_covar_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="resource_covar_to_node_covar_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="resource_covar_to_node_covar_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="resource_covar_to_node_covar_+3A_loop.contribution">loop.contribution</code></td>
<td>
</td></tr>
<tr><td><code id="resource_covar_to_node_covar_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='same_covariate'>same_covariate</h2><span id='topic+same_covariate'></span>

<h3>Description</h3>

<p>Is mobility more likely between locations that are identical on some attribute v?
E.g., is mobility more likely between organisations that are located in the same region?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>same_covariate(
  dep.var = 1,
  attribute.index,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="same_covariate_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="same_covariate_+3A_attribute.index">attribute.index</code></td>
<td>
</td></tr>
<tr><td><code id="same_covariate_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="same_covariate_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="same_covariate_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="same_covariate_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="same_covariate_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="same_covariate_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="same_covariate_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='scoreTest'>scoreTest</h2><span id='topic+scoreTest'></span><span id='topic+print.scoretest.monan'></span>

<h3>Description</h3>

<p>Based on an estimated model, a score-type test is available that shows whether
statistics representing non-included effects are well represented. If this is
not the case, it is likely that including them will result in significant estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scoreTest(ans, effects)

## S3 method for class 'scoretest.monan'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scoreTest_+3A_ans">ans</code></td>
<td>
<p>An object of class &quot;result.monan&quot; resulting from an estimation with the function <code><a href="#topic+estimateMobilityNetwork">estimateMobilityNetwork()</a></code>.</p>
</td></tr>
<tr><td><code id="scoreTest_+3A_effects">effects</code></td>
<td>
<p>An object of class &quot;effectsList.monan&quot; in which the non included effects that should
be tested are specified.</p>
</td></tr>
<tr><td><code id="scoreTest_+3A_x">x</code></td>
<td>
<p>An object of class &quot;scoretest.monan&quot;.</p>
</td></tr>
<tr><td><code id="scoreTest_+3A_...">...</code></td>
<td>
<p>For internal use only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>scoreTest</code> returns basic values to calculate
parametric and non-parametric p-values
for each tested effect.
</p>
<p>The function <code>print.scoretest.monan</code> shows parametric and non-parametric p-values
for each tested effect.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createEffectsObject">createEffectsObject()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# test whether other effects should be included
myEffects2 &lt;- createEffectsObject(
  list(
    list("loops"),
    list("reciprocity_min"),
    list("dyadic_covariate", attribute.index = "sameRegion"),
    list("alter_covariate", attribute.index = "size"),
    list("resource_covar_to_node_covar", attribute.index = "region", 
          resource.attribute.index = "sex"),
    list("loops_resource_covar", resource.attribute.index = "sex"),
    list("transitivity_min")
  )
)

test_ME.2 &lt;- scoreTest(myResDN, myEffects2)


test_ME.2

</code></pre>

<hr>
<h2 id='sim_covariate'>sim_covariate</h2><span id='topic+sim_covariate'></span>

<h3>Description</h3>

<p>Is mobility more likely between locations that are similar on some attribute v?
E.g., is mobility more likely between organisations that have a similar size?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_covariate(
  dep.var = 1,
  attribute.index,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_covariate_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="sim_covariate_+3A_attribute.index">attribute.index</code></td>
<td>
</td></tr>
<tr><td><code id="sim_covariate_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="sim_covariate_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="sim_covariate_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="sim_covariate_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="sim_covariate_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="sim_covariate_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="sim_covariate_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='simulateMobilityNetworks'>simulateMobilityNetworks</h2><span id='topic+simulateMobilityNetworks'></span><span id='topic+simulateDistributionNetworks'></span>

<h3>Description</h3>

<p>Simulates mobility networks for given data, effects, and parameters. This
function is mainly interesting to explore the behavior of the model or to
do counter-factual simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateMobilityNetworks(
  state,
  cache,
  effects,
  parameters,
  allowLoops,
  burnin,
  thinning,
  nSimulations
)

simulateDistributionNetworks(
  state,
  cache,
  effects,
  parameters,
  allowLoops,
  burnin,
  thinning,
  nSimulations
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulateMobilityNetworks_+3A_state">state</code></td>
<td>
<p>An object of class &quot;processState.monan&quot; that contains all relevant information about
nodesets, and covariates. Further, an edgelist of the dependent variable needs
to be specified with the initial mobility network as starting value for the
simulation. For a large enough burn-in, any initial mobility network is allowed.</p>
</td></tr>
<tr><td><code id="simulateMobilityNetworks_+3A_cache">cache</code></td>
<td>
<p>A cache object created from the same state object that is
used in the simulation.</p>
</td></tr>
<tr><td><code id="simulateMobilityNetworks_+3A_effects">effects</code></td>
<td>
<p>An object of class &quot;effectsList.monan&quot; that specifies the model.</p>
</td></tr>
<tr><td><code id="simulateMobilityNetworks_+3A_parameters">parameters</code></td>
<td>
<p>The parameters associated with the effects that shall be used
in the simulations.</p>
</td></tr>
<tr><td><code id="simulateMobilityNetworks_+3A_allowloops">allowLoops</code></td>
<td>
<p>Logical: can individuals/resources stay in their origin?</p>
</td></tr>
<tr><td><code id="simulateMobilityNetworks_+3A_burnin">burnin</code></td>
<td>
<p>The number of simulation steps that are taken before the first draw of a
network is taken. A number too small will mean the first draw is influenced
by the initially specified network. A recommended value for the lower bound is 3 * n_Individuals *
n_locations.</p>
</td></tr>
<tr><td><code id="simulateMobilityNetworks_+3A_thinning">thinning</code></td>
<td>
<p>The number of simulation steps that are taken between two draws of a
network. A recommended value for the lower bound is n_Individuals * n_locations.</p>
</td></tr>
<tr><td><code id="simulateMobilityNetworks_+3A_nsimulations">nSimulations</code></td>
<td>
<p>The number of mobility networks to be simulated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;sims.monan&quot; with nSimulations entries, where each entry contains a further list with the
state and the cache of the current simulation stored.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simulate a mobility network
# note that thinning and burn-in values are for this example only
# in real cases, choose values aprrox. times 10
mySimDN &lt;- simulateMobilityNetworks(
  myState,
  myCache,
  myEffects,
  parameters = c(2, 1, 1.5, 0.1, -1, -0.5),
  allowLoops = TRUE,
  burnin = 450,
  thinning = 150,
  nSimulations = 10
)

mySimDN[[1]]

</code></pre>

<hr>
<h2 id='staying_by_prop_bin_inflow'>staying_by_prop_bin_inflow</h2><span id='topic+staying_by_prop_bin_inflow'></span>

<h3>Description</h3>

<p>Is the tendency to stay in vs. move out of a location dependent on the proportion
of individuals of type w that enter the location? This is especially geared
towards modelling how some locations become more or less
attractive dependent on the change in composition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>staying_by_prop_bin_inflow(
  dep.var = 1,
  resource.attribute.index,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="staying_by_prop_bin_inflow_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="staying_by_prop_bin_inflow_+3A_resource.attribute.index">resource.attribute.index</code></td>
<td>
</td></tr>
<tr><td><code id="staying_by_prop_bin_inflow_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="staying_by_prop_bin_inflow_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="staying_by_prop_bin_inflow_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="staying_by_prop_bin_inflow_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="staying_by_prop_bin_inflow_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="staying_by_prop_bin_inflow_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="staying_by_prop_bin_inflow_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='target_change_match'>target_change_match</h2><span id='topic+target_change_match'></span>

<h3>Description</h3>

<p>Function to test effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>target_change_match(edge, j_new, effectName, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="target_change_match_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="target_change_match_+3A_j_new">j_new</code></td>
<td>
</td></tr>
<tr><td><code id="target_change_match_+3A_effectname">effectName</code></td>
<td>
</td></tr>
<tr><td><code id="target_change_match_+3A_...">...</code></td>
<td>
</td></tr>
</table>


<h3>Details</h3>

<p>Tests for specific resources and new proposed destination whether
the change statistic and the difference between two target statistics
before and after change match
</p>


<h3>Value</h3>

<p>a vector containing (the change stat),(the target stat before change)
(the target stat after change),(whether this matches exactly),
(whether it matches rounded)
</p>

<hr>
<h2 id='test_effect'>test_effect
Test for each person in the example data and one randomly selected
alternative destination whether change and target statistics match.</h2><span id='topic+test_effect'></span>

<h3>Description</h3>

<p>test_effect
</p>
<p>Test for each person in the example data and one randomly selected
alternative destination whether change and target statistics match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_effect(effectName, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_effect_+3A_effectname">effectName</code></td>
<td>
</td></tr>
<tr><td><code id="test_effect_+3A_...">...</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing for each person in the example data:
Origin; Destination; Suggested destination; Change statistic;
Target before change; Target after change; Whether this is an exact match;
Whether this is a match rounded to 8 digits.
In case the last column contains values that are not all &quot;1&quot;,
the tested function does not work properly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
test_loop &lt;- test_effect("loops")

</code></pre>

<hr>
<h2 id='transitivity_basic'>transitivity_basic</h2><span id='topic+transitivity_basic'></span>

<h3>Description</h3>

<p>Is mobility clustered in groups? This is represented by the count of
transitive triads among three nodes. This effect is prone to degeneracy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transitivity_basic(
  dep.var = 1,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transitivity_basic_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="transitivity_basic_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="transitivity_basic_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="transitivity_basic_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="transitivity_basic_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="transitivity_basic_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="transitivity_basic_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="transitivity_basic_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='transitivity_GW'>transitivity_GW</h2><span id='topic+transitivity_GW'></span>

<h3>Description</h3>

<p>Is mobility clustered in groups? This is represented by the count of
transitive triads among three nodes, where the number of two-paths is
geometrically weighted down to avoid degeneracy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transitivity_GW(
  dep.var = 1,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE,
  alpha = 1.1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transitivity_GW_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="transitivity_GW_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="transitivity_GW_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="transitivity_GW_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="transitivity_GW_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="transitivity_GW_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="transitivity_GW_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="transitivity_GW_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
<tr><td><code id="transitivity_GW_+3A_alpha">alpha</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='transitivity_min'>transitivity_min</h2><span id='topic+transitivity_min'></span>

<h3>Description</h3>

<p>Is mobility clustered in groups? This is represented by the minimum of reciprocated
mobility being present among three nodes. Using the minimum ensures that the effect
is not degenerate and it is sample size consistent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transitivity_min(
  dep.var = 1,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transitivity_min_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="transitivity_min_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="transitivity_min_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="transitivity_min_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="transitivity_min_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="transitivity_min_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="transitivity_min_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="transitivity_min_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='transitivity_netflow'>transitivity_netflow</h2><span id='topic+transitivity_netflow'></span>

<h3>Description</h3>

<p>Do individuals move in one direction in locally ordered triads? E.g., is there
a local hierarchy that individuals follow when moving between locations? The
effect is sample size consistent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transitivity_netflow(
  dep.var = 1,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transitivity_netflow_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="transitivity_netflow_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="transitivity_netflow_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="transitivity_netflow_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="transitivity_netflow_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="transitivity_netflow_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="transitivity_netflow_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="transitivity_netflow_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='triad120C'>triad120C</h2><span id='topic+triad120C'></span>

<h3>Description</h3>

<p>Models the prevalence of the 120C triad
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triad120C(
  dep.var = 1,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triad120C_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="triad120C_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="triad120C_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="triad120C_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="triad120C_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="triad120C_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="triad120C_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="triad120C_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='triad120D'>triad120D</h2><span id='topic+triad120D'></span>

<h3>Description</h3>

<p>Models the prevalence of the 120D triad
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triad120D(
  dep.var = 1,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triad120D_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="triad120D_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="triad120D_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="triad120D_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="triad120D_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="triad120D_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="triad120D_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="triad120D_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

<hr>
<h2 id='triad120U'>triad120U</h2><span id='topic+triad120U'></span>

<h3>Description</h3>

<p>Models the prevalence of the 120U triad
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triad120U(
  dep.var = 1,
  state,
  cache,
  i,
  j,
  edge,
  update,
  getTargetContribution = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triad120U_+3A_dep.var">dep.var</code></td>
<td>
</td></tr>
<tr><td><code id="triad120U_+3A_state">state</code></td>
<td>
</td></tr>
<tr><td><code id="triad120U_+3A_cache">cache</code></td>
<td>
</td></tr>
<tr><td><code id="triad120U_+3A_i">i</code></td>
<td>
</td></tr>
<tr><td><code id="triad120U_+3A_j">j</code></td>
<td>
</td></tr>
<tr><td><code id="triad120U_+3A_edge">edge</code></td>
<td>
</td></tr>
<tr><td><code id="triad120U_+3A_update">update</code></td>
<td>
</td></tr>
<tr><td><code id="triad120U_+3A_gettargetcontribution">getTargetContribution</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the change statistic or target statistic of the effect for
internal use by the estimation algorithm.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
