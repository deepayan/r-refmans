<!DOCTYPE html><html><head><title>Help for package rARPACK</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rARPACK}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#eigs'><p>Find a Specified Number of Eigenvalues/vectors for Square Matrix</p></a></li>
<li><a href='#svds'><p>Find the Largest k Singular Values/Vectors of a Matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Solvers for Large Scale Eigenvalue and SVD Problems</td>
</tr>
<tr>
<td>Version:</td>
<td>0.11-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-03-07</td>
</tr>
<tr>
<td>Author:</td>
<td>Yixuan Qiu, Jiali Mei and authors of the ARPACK library. See file
    AUTHORS for details.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yixuan Qiu &lt;yixuan.qiu@cos.name&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Previously an R wrapper of the 'ARPACK' library
    <a href="http://www.caam.rice.edu/software/ARPACK/">http://www.caam.rice.edu/software/ARPACK/</a>, and now a shell of the
    R package 'RSpectra', an R interface to the 'Spectra' library
    <a href="http://yixuan.cos.name/spectra/">http://yixuan.cos.name/spectra/</a> for solving large scale
    eigenvalue/vector problems. The current version of 'rARPACK'
    simply imports and exports the functions provided by 'RSpectra'.
    New users of 'rARPACK' are advised to switch to the 'RSpectra' package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>Copyright:</td>
<td>see file COPYRIGHTS</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/yixuan/rARPACK">https://github.com/yixuan/rARPACK</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/yixuan/rARPACK/issues">https://github.com/yixuan/rARPACK/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>RSpectra</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Matrix (&ge; 1.1-0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-03-09 14:17:29 UTC; qyx</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-03-10 00:06:16</td>
</tr>
</table>
<hr>
<h2 id='eigs'>Find a Specified Number of Eigenvalues/vectors for Square Matrix</h2><span id='topic+eigs'></span><span id='topic+eigs_sym'></span>

<h3>Description</h3>

<p>This function is a simple wrapper of the <code><a href="RSpectra.html#topic+eigs">eigs</a>()</code>
function in the <span class="pkg">RSpectra</span> package. Also see the documentation there.
</p>
<p>Given an <code class="reqn">n</code> by <code class="reqn">n</code> matrix <code class="reqn">A</code>,
function <code>eigs()</code> can calculate a limited
number of eigenvalues and eigenvectors of <code class="reqn">A</code>.
Users can specify the selection criteria by argument
<code>which</code>, e.g., choosing the <code class="reqn">k</code> largest or smallest
eigenvalues and the corresponding eigenvectors.
</p>
<p>Currently <code>eigs()</code> supports matrices of the following classes:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code>matrix</code>     </td><td style="text-align: left;"> The most commonly used matrix type,
                         defined in <strong>base</strong> package.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>dgeMatrix</code>  </td><td style="text-align: left;"> General matrix, equivalent to <code>matrix</code>,
                         defined in <strong>Matrix</strong> package.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>dgCMatrix</code>  </td><td style="text-align: left;"> Column oriented sparse matrix, defined in
                         <strong>Matrix</strong> package.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>dgRMatrix</code>  </td><td style="text-align: left;"> Row oriented sparse matrix, defined in
                         <strong>Matrix</strong> package.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>dsyMatrix</code>  </td><td style="text-align: left;"> Symmetrix matrix, defined in <strong>Matrix</strong>
                         package.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>function</code>   </td><td style="text-align: left;"> Implicitly specify the matrix through a
                         function that has the effect of calculating
                         <code class="reqn">f(x)=Ax</code>. See section
                         <strong>Function Interface</strong> for details.
</td>
</tr>

</table>

<p><code>eigs_sym()</code> assumes the matrix is symmetric,
and only the lower triangle (or upper triangle, which is
controlled by the argument <code>lower</code>) is used for
computation, which guarantees that the eigenvalues and eigenvectors are
real, and in some cases reduces the workload. One exception is when
<code>A</code> is a function, in which case the user is responsible for the
symmetry of the operator.
</p>
<p><code>eigs_sym()</code> supports &quot;matrix&quot;, &quot;dgeMatrix&quot;, &quot;dgCMatrix&quot;, &quot;dgRMatrix&quot;
and &quot;function&quot; typed matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigs(A, k, which = "LM", sigma = NULL, opts = list(), ...)

eigs_sym(A, k, which = "LM", sigma = NULL, opts = list(),
   lower = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eigs_+3A_a">A</code></td>
<td>
<p>The matrix whose eigenvalues/vectors are to be computed.
It can also be a function which receives a vector <code class="reqn">x</code>
and calculates <code class="reqn">Ax</code>.
See section <strong>Function Interface</strong> for details.</p>
</td></tr>
<tr><td><code id="eigs_+3A_k">k</code></td>
<td>
<p>Number of eigenvalues requested.</p>
</td></tr>
<tr><td><code id="eigs_+3A_which">which</code></td>
<td>
<p>Selection criteria. See <strong>Details</strong> below.</p>
</td></tr>
<tr><td><code id="eigs_+3A_sigma">sigma</code></td>
<td>
<p>Shift parameter. See section <strong>Shift-And-Invert Mode</strong>.</p>
</td></tr>
<tr><td><code id="eigs_+3A_opts">opts</code></td>
<td>
<p>Control parameters related to the computing
algorithm. See <strong>Details</strong> below.</p>
</td></tr>
<tr><td><code id="eigs_+3A_lower">lower</code></td>
<td>
<p>For symmetric matrices, should the lower triangle
or upper triangle be used.</p>
</td></tr>
<tr><td><code id="eigs_+3A_...">...</code></td>
<td>
<p>Additional arguments such as <code>n</code> and <code>args</code> that are
related to the Function Interface. See
<code><a href="RSpectra.html#topic+eigs">eigs</a>()</code> in the <span class="pkg">RSpectra</span> package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>which</code> argument is a character string
that specifies the type of eigenvalues to be computed.
Possible values are:
</p>

<table>
<tr>
 <td style="text-align: left;">
  "LM"  </td><td style="text-align: left;">  The <code class="reqn">k</code> eigenvalues with largest magnitude. Here the
              magnitude means the Euclidean norm of complex numbers.</td>
</tr>
<tr>
 <td style="text-align: left;">
  "SM"  </td><td style="text-align: left;">  The <code class="reqn">k</code> eigenvalues with smallest magnitude.</td>
</tr>
<tr>
 <td style="text-align: left;">
  "LR"  </td><td style="text-align: left;">  The <code class="reqn">k</code> eigenvalues with largest real part.</td>
</tr>
<tr>
 <td style="text-align: left;">
  "SR"  </td><td style="text-align: left;">  The <code class="reqn">k</code> eigenvalues with smallest real part.</td>
</tr>
<tr>
 <td style="text-align: left;">
  "LI"  </td><td style="text-align: left;">  The <code class="reqn">k</code> eigenvalues with largest imaginary part.</td>
</tr>
<tr>
 <td style="text-align: left;">
  "SI"  </td><td style="text-align: left;">  The <code class="reqn">k</code> eigenvalues with smallest imaginary part.</td>
</tr>
<tr>
 <td style="text-align: left;">
  "LA"  </td><td style="text-align: left;">  The <code class="reqn">k</code> largest (algebraic) eigenvalues, considering any
              negative sign.</td>
</tr>
<tr>
 <td style="text-align: left;">
  "SA"  </td><td style="text-align: left;">  The <code class="reqn">k</code> smallest (algebraic) eigenvalues, considering any
              negative sign.</td>
</tr>
<tr>
 <td style="text-align: left;">
  "BE"  </td><td style="text-align: left;">  Compute <code class="reqn">k</code> eigenvalues, half from each end of the
              spectrum. When <code class="reqn">k</code> is odd, compute more from the high
              and then from the low end.
</td>
</tr>

</table>

<p><code>eigs()</code> with matrix type &quot;matrix&quot;, &quot;dgeMatrix&quot;, &quot;dgCMatrix&quot;
and &quot;dgRMatrix&quot; can use &quot;LM&quot;,
&quot;SM&quot;, &quot;LR&quot;, &quot;SR&quot;, &quot;LI&quot; and &quot;SI&quot;.
</p>
<p><code>eigs_sym()</code>, and <code>eigs()</code> with matrix type &quot;dsyMatrix&quot;
can use &quot;LM&quot;, &quot;SM&quot;, &quot;LA&quot;, &quot;SA&quot; and &quot;BE&quot;.
</p>
<p>The <code>opts</code> argument is a list that can supply any of the
following parameters:
</p>

<dl>
<dt><code>ncv</code></dt><dd><p>Number of Lanzcos basis vectors to use. More vectors
will result in faster convergence, but with greater
memory use. For general matrix, <code>ncv</code> must satisfy
<code class="reqn">k+2\le ncv \le n</code>, and
for symmetric matrix, the constraint is
<code class="reqn">k &lt; ncv \le n</code>.
Default is <code>min(n, max(2*k+1, 20))</code>.</p>
</dd>
<dt><code>tol</code></dt><dd><p>Precision parameter. Default is 1e-10.</p>
</dd>
<dt><code>maxitr</code></dt><dd><p>Maximum number of iterations. Default is 1000.</p>
</dd>
<dt><code>retvec</code></dt><dd><p>Whether to compute eigenvectors. If FALSE,
only calculate and return eigenvalues.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list of converged eigenvalues and eigenvectors.
</p>
<table>
<tr><td><code>values</code></td>
<td>
<p>Computed eigenvalues.</p>
</td></tr>
<tr><td><code>vectors</code></td>
<td>
<p>Computed eigenvectors. <code>vectors[, j]</code> corresponds to <code>values[j]</code>.</p>
</td></tr>
<tr><td><code>nconv</code></td>
<td>
<p>Number of converged eigenvalues.</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>Number of iterations used in the computation.</p>
</td></tr>
<tr><td><code>nops</code></td>
<td>
<p>Number of matrix operations used in the computation.</p>
</td></tr>
</table>


<h3>Shift-And-Invert Mode</h3>

<p>The <code>sigma</code> argument is used in the shift-and-invert mode.
</p>
<p>When <code>sigma</code> is not <code>NULL</code>, the selection criteria specified
by argument <code>which</code> will apply to
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{\lambda-\sigma}</code>
</p>

<p>where <code class="reqn">\lambda</code>'s are the eigenvalues of <code class="reqn">A</code>. This mode is useful
when user wants to find eigenvalues closest to a given number.
For example, if <code class="reqn">\sigma=0</code>, then <code>which = "LM"</code> will select the
largest values of <code class="reqn">1/|\lambda|</code>, which turns out to select
eigenvalues of <code class="reqn">A</code> that have the smallest magnitude. The result of
using <code>which = "LM", sigma = 0</code> will be the same as
<code>which = "SM"</code>, but the former one is preferable
in that ARPACK is good at finding large
eigenvalues rather than small ones. More explanation of the
shift-and-invert mode can be found in the SciPy document,
<a href="http://docs.scipy.org/doc/scipy/reference/tutorial/arpack.html">http://docs.scipy.org/doc/scipy/reference/tutorial/arpack.html</a>.
</p>


<h3>Function Interface</h3>

<p>The matrix <code class="reqn">A</code> can be specified through a function with
the definition
</p>
<pre>function(x, args)
{
    ## should return A %*% x
}</pre>
<p>which receives a vector <code>x</code> as an argument and returns a vector
of the same length. The function should have the effect of calculating
<code class="reqn">Ax</code>, and extra arguments can be passed in through the
<code>args</code> parameter. In <code>eigs()</code>, user should also provide
the dimension of the implicit matrix through the argument <code>n</code>.
</p>


<h3>Author(s)</h3>

<p>Yixuan Qiu <a href="http://statr.me">http://statr.me</a>
</p>
<p>Jiali Mei <a href="mailto:vermouthmjl@gmail.com">vermouthmjl@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+eigen">eigen</a>()</code>, <code><a href="base.html#topic+svd">svd</a>()</code>,
<code><a href="#topic+svds">svds</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Matrix)
n = 20
k = 5

## general matrices have complex eigenvalues
set.seed(111)
A1 = matrix(rnorm(n^2), n)  ## class "matrix"
A2 = Matrix(A1)             ## class "dgeMatrix"

eigs(A1, k)
eigs(A2, k, opts = list(retvec = FALSE))  ## eigenvalues only

## sparse matrices
A1[sample(n^2, n^2 / 2)] = 0
A3 = as(A1, "dgCMatrix")
A4 = as(A1, "dgRMatrix")

eigs(A3, k)
eigs(A4, k)

## function interface
f = function(x, args)
{
    as.numeric(args %*% x)
}
eigs(f, k, n = n, args = A3)

## symmetric matrices have real eigenvalues
A5 = crossprod(A1)
eigs_sym(A5, k)

## find the smallest (in absolute value) k eigenvalues of A5
eigs_sym(A5, k, which = "SM")

## another way to do this: use the sigma argument
eigs_sym(A5, k, sigma = 0)

## The results should be the same,
## but the latter method is far more stable on large matrices
</code></pre>

<hr>
<h2 id='svds'>Find the Largest k Singular Values/Vectors of a Matrix</h2><span id='topic+svds'></span>

<h3>Description</h3>

<p>This function is a simple wrapper of the <code><a href="RSpectra.html#topic+svds">svds</a>()</code>
function in the <span class="pkg">RSpectra</span> package. Also see the documentation there.
</p>
<p>Given an <code class="reqn">m</code> by <code class="reqn">n</code> matrix <code class="reqn">A</code>,
function <code>svds()</code> can find its largest <code class="reqn">k</code>
singular values and the corresponding singular vectors.
It is also called the Truncated Singular Value Decomposition
since it only contains a subset of the whole singular triplets.
</p>
<p>Currently <code>svds()</code> supports matrices of the following classes:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code>matrix</code>     </td><td style="text-align: left;"> The most commonly used matrix type,
                         defined in <strong>base</strong> package.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>dgeMatrix</code>  </td><td style="text-align: left;"> General matrix, equivalent to <code>matrix</code>,
                         defined in <strong>Matrix</strong> package.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>dgCMatrix</code>  </td><td style="text-align: left;"> Column oriented sparse matrix, defined in
                         <strong>Matrix</strong> package.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>dgRMatrix</code>  </td><td style="text-align: left;"> Row oriented sparse matrix, defined in
                         <strong>Matrix</strong> package.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>dsyMatrix</code>  </td><td style="text-align: left;"> Symmetrix matrix, defined in <strong>Matrix</strong>
                         package.
</td>
</tr>

</table>

<p>Note that when <code class="reqn">A</code> is symmetric,
SVD reduces to eigen decomposition, so you may consider using
<code><a href="#topic+eigs">eigs</a>()</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svds(A, k, nu = k, nv = k, opts = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svds_+3A_a">A</code></td>
<td>
<p>The matrix whose truncated SVD is to be computed.</p>
</td></tr>
<tr><td><code id="svds_+3A_k">k</code></td>
<td>
<p>Number of singular values requested.</p>
</td></tr>
<tr><td><code id="svds_+3A_nu">nu</code></td>
<td>
<p>Number of left singular vectors to be computed. This must
be between 0 and <code>k</code>.</p>
</td></tr>
<tr><td><code id="svds_+3A_nv">nv</code></td>
<td>
<p>Number of right singular vectors to be computed. This must
be between 0 and <code>k</code>.</p>
</td></tr>
<tr><td><code id="svds_+3A_opts">opts</code></td>
<td>
<p>Control parameters related to the computing
algorithm. See <strong>Details</strong> below.</p>
</td></tr>
<tr><td><code id="svds_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>opts</code> argument is a list that can supply any of the
following parameters:
</p>

<dl>
<dt><code>ncv</code></dt><dd><p>Number of Lanzcos basis vectors to use. More vectors
will result in faster convergence, but with greater
memory use. <code>ncv</code> must be satisfy
<code class="reqn">k &lt; ncv \le p</code> where
<code>p = min(m, n)</code>.
Default is <code>min(p, max(2*k+1, 20))</code>.</p>
</dd>
<dt><code>tol</code></dt><dd><p>Precision parameter. Default is 1e-10.</p>
</dd>
<dt><code>maxitr</code></dt><dd><p>Maximum number of iterations. Default is 1000.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>d</code></td>
<td>
<p>A vector of the computed singular values.</p>
</td></tr>
<tr><td><code>u</code></td>
<td>
<p>An <code>m</code> by <code>nu</code> matrix whose columns contain
the left singular vectors. If <code>nu == 0</code>, <code>NULL</code>
will be returned.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>An <code>n</code> by <code>nv</code> matrix whose columns contain
the right singular vectors. If <code>nv == 0</code>, <code>NULL</code>
will be returned.</p>
</td></tr>
<tr><td><code>nconv</code></td>
<td>
<p>Number of converged singular values.</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>Number of iterations used.</p>
</td></tr>
<tr><td><code>nops</code></td>
<td>
<p>Number of matrix-vector multiplications used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yixuan Qiu &lt;<a href="http://statr.me">http://statr.me</a>&gt;
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+eigen">eigen</a>()</code>, <code><a href="base.html#topic+svd">svd</a>()</code>,
<code><a href="#topic+eigs">eigs</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m = 100
n = 20
k = 5
set.seed(111)
A = matrix(rnorm(m * n), m)

svds(A, k)
svds(t(A), k, nu = 0, nv = 3)

## Sparse matrices
library(Matrix)
A[sample(m * n, m * n / 2)] = 0
Asp1 = as(A, "dgCMatrix")
Asp2 = as(A, "dgRMatrix")

svds(Asp1, k)
svds(Asp2, k, nu = 0, nv = 0)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
