<!DOCTYPE html><html><head><title>Help for package designr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {designr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+,factorContainer,factorContainer-method'><p>Concatenate design factors and designs</p></a></li>
<li><a href='#design.contrasts'><p>Retrieve contrast codes for a design</p></a></li>
<li><a href='#designr'><p>designr</p></a></li>
<li><a href='#factor.design'><p>Factorial Designs</p></a></li>
<li><a href='#factorContainer-class'><p>Design matrix S4 functions</p></a></li>
<li><a href='#factorDesign-class'><p>S4 Methods for designFactor</p></a></li>
<li><a href='#fixed.factor'><p>Fixed factors</p></a></li>
<li><a href='#gibsonwu2013'><p>Gibson &amp; Wu (2013)</p></a></li>
<li><a href='#is.randomFactor'><p>Checking factor design data types</p></a></li>
<li><a href='#nobs,factorDesign-method'><p>Retrieve the number of observations</p></a></li>
<li><a href='#output.design'><p>Summary of Factor Designs</p></a></li>
<li><a href='#random.factor'><p>Random factors</p></a></li>
<li><a href='#random.factors'><p>Extract factors by type</p></a></li>
<li><a href='#show.factorContainer'><p>Output a design factor summary</p></a></li>
<li><a href='#simLMM'><p>Simulate data from a linear mixed-effects model</p></a></li>
<li><a href='#subset,factorDesign-method'><p>Subset factor designs</p></a></li>
<li><a href='#write.design'><p>Write Design Files</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Balanced Factorial Designs</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.13</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://maxrabe.com/designr">https://maxrabe.com/designr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mmrabe/designr/issues">https://github.com/mmrabe/designr/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Generate balanced factorial designs with crossed and nested random and fixed effects <a href="https://github.com/mmrabe/designr">https://github.com/mmrabe/designr</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, tibble, crossdes, methods, dplyr, lme4,</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, jsonlite, writexl, lmerTest, afex, ggplot2,
gridExtra,</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-05 12:40:30 UTC; max</td>
</tr>
<tr>
<td>Author:</td>
<td>Maximilian M. Rabe
    <a href="https://orcid.org/0000-0002-2556-5644"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Reinhold Kliegl <a href="https://orcid.org/0000-0002-0180-8488"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Daniel J. Schad <a href="https://orcid.org/0000-0003-2586-6823"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Maximilian M. Rabe &lt;maximilian.rabe@uni-potsdam.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-05 13:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+2B+2CfactorContainer+2CfactorContainer-method'>Concatenate design factors and designs</h2><span id='topic++2B+2CfactorContainer+2CfactorContainer-method'></span>

<h3>Description</h3>

<p>By adding factors and designs by <code>+</code>, a new design is created that contains all of the components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'factorContainer,factorContainer'
e1 + e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2B+2B2CfactorContainer+2B2CfactorContainer-method_+3A_e1">e1</code>, <code id="+2B2B+2B2CfactorContainer+2B2CfactorContainer-method_+3A_e2">e2</code></td>
<td>
<p>factor containers, such as factors or designs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A factorDesign object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
des &lt;- fixed.factor("Factor1", c("1A","1B")) +
       fixed.factor("Factor2", c("2A","2B")) +
       random.factor("Subject", c("Factor1"))


</code></pre>

<hr>
<h2 id='design.contrasts'>Retrieve contrast codes for a design</h2><span id='topic+design.contrasts'></span><span id='topic+contrast.names'></span>

<h3>Description</h3>

<p>This function can be used to retrieve contrast codes based on experimental codes / planned observations.
</p>
<p>Use this function to retrieve the names for contrasts in an experimental design, such as used by lm, lmer and many other regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>design.contrasts(
  design,
  factors = names(fixed.factors(design)),
  contrasts = NULL,
  expand = TRUE,
  rename_contrasts = "%1$s%2$s",
  intercept = FALSE,
  interactions = FALSE,
  include_random_levels = FALSE
)

contrast.names(design, ranfac = NULL, as_symbols = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="design.contrasts_+3A_design">design</code></td>
<td>
<p>A design object</p>
</td></tr>
<tr><td><code id="design.contrasts_+3A_factors">factors</code></td>
<td>
<p>Which fixed factors to include in the output</p>
</td></tr>
<tr><td><code id="design.contrasts_+3A_contrasts">contrasts</code></td>
<td>
<p>Contrasts to use for each categorical factor. Should be a list named after the fixed effects and containing contrast matrices, such as the ones generated by the standard contrast functions. If NULL or the fixed factor is not found in the list, default contrasts are used (typically, treatment contrasts).</p>
</td></tr>
<tr><td><code id="design.contrasts_+3A_expand">expand</code></td>
<td>
<p>If TRUE, a design matrix is returned. If FALSE, all factors (and interactions) with their respective levels are returned.</p>
</td></tr>
<tr><td><code id="design.contrasts_+3A_rename_contrasts">rename_contrasts</code></td>
<td>
<p>This is the pattern after which columns in the design matrix are named. By default, this is a direct concatenation of factor name and contrast name.</p>
</td></tr>
<tr><td><code id="design.contrasts_+3A_intercept">intercept</code></td>
<td>
<p>If TRUE, an intercept is added to the matrix. Its value is 1 for all observations.</p>
</td></tr>
<tr><td><code id="design.contrasts_+3A_interactions">interactions</code></td>
<td>
<p>If TRUE, interactions of fixed factors are included.</p>
</td></tr>
<tr><td><code id="design.contrasts_+3A_include_random_levels">include_random_levels</code></td>
<td>
<p>If TRUE, levels of random factors are included in the matrix.</p>
</td></tr>
<tr><td><code id="design.contrasts_+3A_ranfac">ranfac</code></td>
<td>
<p>Return random-effects contrast names for a given random factor. If NULL, return fixed-effects contrast names.</p>
</td></tr>
<tr><td><code id="design.contrasts_+3A_as_symbols">as_symbols</code></td>
<td>
<p>Return contrast names as symbols rather than strings (character vectors).</p>
</td></tr>
<tr><td><code id="design.contrasts_+3A_...">...</code></td>
<td>
<p>Arguments to pass on to design.contrasts()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A design matrix (if expand==TRUE, default) or a list of factor levels (if expand==FALSE) for design.contrasts or contrast names for contrast.names.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>contrast.names()</code>: Retrieve contrast names for a design
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>

des &lt;- fixed.factor("Factor1", c("1A","1B")) +
       fixed.factor("Factor2", c("2A","2B")) +
       random.factor("Subject", c("Factor1"))

              
design.contrasts(des)

contrast.names(des)

stopifnot(contrast.names(des) == c("Factor11B", "Factor22B"))

contrast.names(des, as_symbols = TRUE)

design.contrasts(des, contrasts = list(Factor2 = contr.sum))

contrast.names(des, contrasts = list(Factor2 = contr.sum))

</code></pre>

<hr>
<h2 id='designr'>designr</h2><span id='topic+designr'></span>

<h3>Description</h3>

<p>designr is an R package to create and simulate crossed factorial designs.
</p>


<h3>Details</h3>

<p>The package supports factorial designs with an arbitrary number of fixed and random factors. Fixed factors are factors for which levels are known and typically defined by the experimenter, e.g. an experimental condition or a quasi-experimental variable such as a subject’s age group. Conversely, the instances of random factors are usually not known before data collection. Examples for random factors are subjects or items in a typical psychological experiment, with the individual tested subjects and used items being the instances of those random factors.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fixed.factor">fixed.factor</a></code>, <code><a href="#topic+random.factor">random.factor</a></code>, <code><a href="#topic+design.codes">design.codes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A fixed-effects design without repeated measurement is created as easily as this:
  
design1 &lt;- 
  fixed.factor("Age", levels=c("young", "old")) +
  fixed.factor("Material",  levels=c("word", "image"))
design1

# As can be seen, this experimental design requires 4 observations.

# Adding random factors
# Assume we want to test different groups of subjects. Each subject will only be `old` or `young` 
# but be tested with stimuli of both categories `word` and `image`. In a typical behavioral
# experiment, `Age` would now be a between-subject/within-item factor and `Material` a
# within-subject/between-item factor. In other words, `Material` is now nested within the
# instances of `Subject`, whereas `Subject` is grouped by `Age`.

design2 &lt;- 
  fixed.factor("Age", levels=c("young", "old")) +
  fixed.factor("Material",  levels=c("word", "image")) +
  random.factor("Subject", groups = "Age")
design.codes(design2)

# The minimal experimental design will still require 4 observations, assigning one subject to each
# level of the between-subject factor `Age`.

</code></pre>

<hr>
<h2 id='factor.design'>Factorial Designs</h2><span id='topic+factor.design'></span>

<h3>Description</h3>

<p>The main function of this package is to create factorial designs with this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factor.design(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factor.design_+3A_...">...</code></td>
<td>
<p>Factors to add to the design.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of <code>factorDesign</code> with the complete factorial design and all fixed and random factors.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+random.factor">random.factor</a></code> and <code><a href="#topic+fixed.factor">fixed.factor</a></code> for creating factors to add to the design. <code><a href="#topic+output.design">output.design</a></code> and <code><a href="#topic+write.design">write.design</a></code> for creating a useful summary and writing it into output files.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># To create an empty design:
design &lt;- factor.design()

# To create a design for a recognition memory experiment in
# which each participant only sees either picture or words:
design &lt;- factor.design(
    fixed.factor("type",levels=c("pic","word")), 
    fixed.factor("status",levels=c("old","new")), 
    random.factor("subject", groups="type"), 
    random.factor("item", groups="type"), 
    random.factor(c("subject","item"), groups="status")
)

# This is identical to:
design &lt;- fixed.factor("type",levels=c("pic","word")) + 
          fixed.factor("status",levels=c("old","new")) + 
          random.factor("subject", groups="type") + 
          random.factor("item", groups="type") + 
          random.factor(c("subject","item"), groups="status")

# Or:
design &lt;- factor.design(
   ~type(pic,word)+status(old,new)+subject[type]+item[type]+subject:item[status]
)

# You can also create a new design by adding more factors to an existing one:

design1 &lt;- factor.design(~type(pic,word)+status(old,new)+subject[type]+item[type])
design2 &lt;- design1 + random.factor(c("subject","item"), groups="status")

</code></pre>

<hr>
<h2 id='factorContainer-class'>Design matrix S4 functions</h2><span id='topic+factorContainer-class'></span><span id='topic+show+2CfactorContainer-method'></span>

<h3>Description</h3>

<p>Design matrix S4 functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'factorContainer'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factorContainer-class_+3A_object">object</code></td>
<td>
<p>A <code>factorDesign</code> object.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>show(factorContainer)</code>: Display a factor container
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>des &lt;- factor.design()
des &lt;- fixed.factor("Factor1", c("1A","1B")) +
       fixed.factor("Factor2", c("2A","2B")) +
       random.factor("Subject", c("Factor1"))

</code></pre>

<hr>
<h2 id='factorDesign-class'>S4 Methods for designFactor</h2><span id='topic+factorDesign-class'></span>

<h3>Description</h3>

<p>S4 Methods for designFactor
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="factorDesign-class_+3A_x">x</code></td>
<td>
<p>a <code>factorDesign</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- fixed.factor("Factor1", c("1A","1B"))
y &lt;- random.factor("Subject", c("Factor1"))

</code></pre>

<hr>
<h2 id='fixed.factor'>Fixed factors</h2><span id='topic+fixed.factor'></span>

<h3>Description</h3>

<p>This function creates an instance of <code>fixedFactor</code> to be used in a <code>factorDesign</code>. Fixed factors typically relate to (quasi-)experimental factors such as experimental conditions/manipulations, subject/item characteristics ect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixed.factor(
  name,
  levels,
  blocked = FALSE,
  character_as_factor = TRUE,
  is_ordered = FALSE,
  block_name = "%1$s.%2$d",
  groups = character(0),
  replications = 1L,
  assign = "latin.square",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixed.factor_+3A_name">name</code></td>
<td>
<p>Name of the fixed factor.</p>
</td></tr>
<tr><td><code id="fixed.factor_+3A_levels">levels</code></td>
<td>
<p>If not grouped, a vector of factor levels. Any atomic data type (character, logical, numeric, integer) can be used. If grouped, this should be a named list with each entry being a vector (as described before) and its name being a value of the grouping factor(s). If grouped within several factors, i.e. an interaction, the values constituting the names should be concatenated by colons (:), e.g. <code>list(`f1l1:f2l1`=1:2, `f1l2:f2l1`=3:4, ...)</code>. If for any group there are no levels specified, a warning will be issued and <code>NA</code> will be assigned as the value for this factor. If this is intended and the warning should be suppressed, please explicitly assign <code>NA</code> as the value for that group, e.g. <code>list(`f1l1:f2l1`=1:2, `f1l2:f2l1`=NA, ...)</code>.</p>
</td></tr>
<tr><td><code id="fixed.factor_+3A_blocked">blocked</code></td>
<td>
<p>Set this to <code>TRUE</code> if the levels of this factor are blocked. In that case, a factor is created whose factor levels are different sequences of the levels specified in the function call.</p>
</td></tr>
<tr><td><code id="fixed.factor_+3A_character_as_factor">character_as_factor</code></td>
<td>
<p>If this is <code>TRUE</code>, character vectors passed in <code>levels</code> are automatically converted to a factor type.</p>
</td></tr>
<tr><td><code id="fixed.factor_+3A_is_ordered">is_ordered</code></td>
<td>
<p>Is this an ordered factor?</p>
</td></tr>
<tr><td><code id="fixed.factor_+3A_block_name">block_name</code></td>
<td>
<p>If <code>blocked = TRUE</code>, by default, there is not only a design matrix column created that contains the complete sequence of block levels but also a column for each position of the sequence with its assigned level. You may specify a different naming pattern using <code><a href="base.html#topic+sprintf">sprintf</a></code> naming conventions. The first argument passed is the factor name and the second argument is the sequence position (starting at 1). The default column names will be <code>factor.1</code>, <code>factor.2</code>, etc. If <code>NULL</code>, no additional block columns are created.</p>
</td></tr>
<tr><td><code id="fixed.factor_+3A_groups">groups</code></td>
<td>
<p>Names of fixed factors in which to nest this fixed factor (see *Nesting fixed factors*).</p>
</td></tr>
<tr><td><code id="fixed.factor_+3A_replications">replications</code></td>
<td>
<p>Either a single integer or an integer vector of the same length as <code>levels</code> that is used to determine how many times each factor level should be repeated.</p>
</td></tr>
<tr><td><code id="fixed.factor_+3A_assign">assign</code></td>
<td>
<p>If <code>blocked = TRUE</code>, you may specify a different method of rotating levels. The default if <code>'latin.square'</code> but <code>'permutations'</code>, <code>'williams'</code>, and <code>'random.order'</code> are also available.</p>
</td></tr>
<tr><td><code id="fixed.factor_+3A_...">...</code></td>
<td>
<p>more data to save as attributes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of <code>fixedFactor</code>.
</p>


<h3>Nesting Fixed Factors</h3>

<p>If <code>groups</code> is used, the function will attempt to nest levels of the newly created factor within levels/interactions of the specified grouping factors. Note that nesting of fixed effects is only allowed within other fixed effects combinations but not within random effects. For each combination of the grouping factors, e.g. each group, you should specify an individual vector of levels (see above). If you fail to supply levels for any group, <code>NA</code>s will be assigned. This could result in unpredicted behavior when more factors are added. If you know what you are doing and would like to suppress the warning, please explicitly specify <code>NA</code> as the (only) value to assign to that group. At any rate, it is highly recommended to run sanity checks on the balancedness of the design if you are nesting fixed factors!
</p>


<h3>See Also</h3>

<p><code><a href="#topic+random.factor">random.factor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fixed.factor("correct", levels=c(TRUE, FALSE))
fixed.factor("age", levels=c("child", "youth", "adult"))
fixed.factor("order", levels=c("task1", "task2", "task3"), blocked = TRUE, assign="latin.square")

</code></pre>

<hr>
<h2 id='gibsonwu2013'>Gibson &amp; Wu (2013)</h2><span id='topic+gibsonwu2013'></span>

<h3>Description</h3>

<p>The dataset <code>gibsonwu2013</code> contains data from self-paced reading in Chinese, comparing the processing of subject-extracted relative clauses (SRCs) and object-extracted relative clauses (ORCs) in supportive contexts.
</p>


<h3>References</h3>

<p>Gibson, E., &amp; Wu, H.-H. I. (2013). Processing Chinese relative clauses in context. <em>Language and Cognitive Processes, 28</em>, 125–155. <a href="https://doi.org/10.1080/01690965.2010.536656">doi:10.1080/01690965.2010.536656</a>
</p>

<hr>
<h2 id='is.randomFactor'>Checking factor design data types</h2><span id='topic+is.randomFactor'></span><span id='topic+is.fixedFactor'></span><span id='topic+is.factorDesign'></span><span id='topic+is.designFactor'></span>

<h3>Description</h3>

<p>Check if argument is a design factor (either random or fixed factor), specifically a random factor, a fixed factor or a factor design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.randomFactor(fac)

is.fixedFactor(fac)

is.factorDesign(fac)

is.designFactor(fac)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.randomFactor_+3A_fac">fac</code></td>
<td>
<p>Object to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>is.randomFactor()</code>: Check if argument is a random factor.
</p>
</li>
<li> <p><code>is.fixedFactor()</code>: Check if argument is a fixed factor.
</p>
</li>
<li> <p><code>is.factorDesign()</code>: Check if argument is a factor design.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- fixed.factor("factor", c("level1","level2"))
y &lt;- random.factor("factor")

stopifnot(is.fixedFactor(x) &amp;&amp; !is.randomFactor(x))
stopifnot(!is.fixedFactor(y) &amp;&amp; is.randomFactor(y))
stopifnot(is.designFactor(x) &amp;&amp; is.designFactor(y))

</code></pre>

<hr>
<h2 id='nobs+2CfactorDesign-method'>Retrieve the number of observations</h2><span id='topic+nobs+2CfactorDesign-method'></span>

<h3>Description</h3>

<p>Retrieve the number of observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'factorDesign'
nobs(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nobs+2B2CfactorDesign-method_+3A_object">object</code></td>
<td>
<p>A designFactor object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of observations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>des &lt;- fixed.factor("Factor1", c("1A","1B")) +
       fixed.factor("Factor2", c("2A","2B")) +
       random.factor("Subject", c("Factor1"))
       
nobs(des)

stopifnot(nobs(des) == 4)

</code></pre>

<hr>
<h2 id='output.design'>Summary of Factor Designs</h2><span id='topic+output.design'></span><span id='topic+design.formula'></span><span id='topic+design.units'></span><span id='topic+design.codes'></span>

<h3>Description</h3>

<p>These functions return useful summaries of a factor design, including the design matrix itself as well as other parameters and a list of random factors as experimental units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>output.design(
  design,
  group_by = NULL,
  order_by = NULL,
  randomize = FALSE,
  rename_random = TRUE
)

design.formula(
  design,
  contrasts = NULL,
  expand_contrasts = !missing(contrasts),
  interactions = TRUE,
  intercepts = TRUE,
  response = "dv",
  env = parent.frame()
)

design.units(design, rename_random = TRUE, include_interactions = FALSE)

design.codes(
  design,
  group_by = NULL,
  order_by = names(random.factors(design, include_interactions = FALSE)),
  randomize = FALSE,
  rename_random = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="output.design_+3A_design">design</code></td>
<td>
<p>The <code>factorDesign</code> object to summarize.</p>
</td></tr>
<tr><td><code id="output.design_+3A_group_by">group_by</code></td>
<td>
<p>If not <code>NULL</code>, the design matrix is grouped by these factors. Factors must be valid columns of the design matrix. If used, <code>$codes</code> will be a list matched to the entries in <code>$groups</code>.</p>
</td></tr>
<tr><td><code id="output.design_+3A_order_by">order_by</code></td>
<td>
<p>If not <code>NULL</code>, output within each output group is ordered by these columns.</p>
</td></tr>
<tr><td><code id="output.design_+3A_randomize">randomize</code></td>
<td>
<p>After ordering, remaining rows in the same order rank are randomly shuffled.</p>
</td></tr>
<tr><td><code id="output.design_+3A_rename_random">rename_random</code></td>
<td>
<p>Should random factor levels be renamed? If <code>TRUE</code>, levels are renamed as strings composed of the factor name and factor level (e.g., Subj01, Subj02, ...). <code>FALSE</code> disables renaming of random factor levels. Alternatively, you may provide a function which should accept the vectorized ID (integer) as a first argument and the name (single character value) of the random factor as second argument or ignore it. Functions such as <code>as.double</code> or <code>as.integer</code> *are* possible because they ignore the second argument and only convert the ID.</p>
</td></tr>
<tr><td><code id="output.design_+3A_contrasts">contrasts</code></td>
<td>
<p>The contrasts to override (<code>NULL</code> if none to override)</p>
</td></tr>
<tr><td><code id="output.design_+3A_expand_contrasts">expand_contrasts</code></td>
<td>
<p>If <code>TRUE</code>, factors with more than one contrast are replaced by so many contrasts, i.e. the result contains the names of the individual contrasts, not of the factors.</p>
</td></tr>
<tr><td><code id="output.design_+3A_interactions">interactions</code></td>
<td>
<p>Should fixed effects be additive or interactive?</p>
</td></tr>
<tr><td><code id="output.design_+3A_intercepts">intercepts</code></td>
<td>
<p>Should an intercept be included?</p>
</td></tr>
<tr><td><code id="output.design_+3A_response">response</code></td>
<td>
<p>The left-hand side of the equation. Typically, this is just the response/dependent variable.</p>
</td></tr>
<tr><td><code id="output.design_+3A_env">env</code></td>
<td>
<p>The environment in which to embed the formula</p>
</td></tr>
<tr><td><code id="output.design_+3A_include_interactions">include_interactions</code></td>
<td>
<p>Whether to include random factor interactions (i.e., counterbalancing factors) in the output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>design.units</code> returns the experimental units of the design. Those are defined by random factors and their levels. See <code>units</code> return value below.
</p>
<p><code>design.codes</code> returns a dataframe or <code>tibble</code> of all planned observations including each observation's experimental codes, i.e. fixed and random factor levels. If you group the output, a list is returned. See <code>codes</code> return value below.
</p>
<p><code>design.formula</code> returns a list of formulas suitable for regression analysis. Currently, formulas for <code>lm</code> and <code>lme4</code> are returned. See <code>formulas</code> entry,
</p>


<h3>Value</h3>

<p><code>output.design</code> returns a list containing all output summaries, including the following named entities:
</p>

<dl>
<dt><code>codes</code></dt><dd><p>Either a <code>tibble</code> with all experimental codes or a list of <code>tibble</code>s of experimental codes. The list entries are matched to the rows of <code>$groups</code>.</p>
</dd>
<dt><code>groups</code></dt><dd><p>If grouped, contains a tibble in which each row represents an output group, matched to the entries in $codes. If not grouped, this is <code>NULL</code>.</p>
</dd>
<dt><code>ordered</code></dt><dd><p>If ordered, contains a vector of order criteria. If not ordered, this is <code>NULL</code>.</p>
</dd>
<dt><code>randomized</code></dt><dd><p>Value of <code>randomized</code>.</p>
</dd>
<dt><code>units</code></dt><dd><p>A list of random factors and their levels for this design as tibbles. Empty list if no random factors in the design.</p>
</dd>
<dt><code>formulas</code></dt><dd><p>A list of possible model formulas for use with functions such as <code>lm()</code> and <code>lmer()</code>.</p>
</dd>
</dl>

<p>The functions <code>design.codes</code>, <code>design.formula</code> and <code>design.units</code> only return the values of the fields <code>codes</code> (a <code>tibble</code> or list or <code>tibble</code>s of experimental codes), <code>formulas</code> (a list of model formulas), and <code>units</code> (a list of random factors and their levels), respectively.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>design.formula()</code>: Retrieve only the model formulas suitable for the design
</p>
</li>
<li> <p><code>design.units()</code>: Retrieve only the experimental units of a design
</p>
</li>
<li> <p><code>design.codes()</code>: Retrieve only the codes of planned observations of an experimental design
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+design.formula">design.formula</a></code> for more options generating model formulae other than the suggested default ones in the summary.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
des &lt;- fixed.factor("Factor1", c("1A","1B")) +
       fixed.factor("Factor2", c("2A","2B")) +
       random.factor("Subject", c("Factor1"))
       
output.design(des)
design.codes(des)
design.units(des)
design.formula(des)

</code></pre>

<hr>
<h2 id='random.factor'>Random factors</h2><span id='topic+random.factor'></span>

<h3>Description</h3>

<p>This function creates an instance of <code>randomFactor</code> to be used in a <code>factorDesign</code>. A random factor is typically related to an experimental unit such as Subject, Item, Experimenter, ect. and does not have preset levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random.factor(
  name,
  groups = character(0),
  instances = 1L,
  assign = "latin.square",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.factor_+3A_name">name</code></td>
<td>
<p>Name of the random factor as a character vector. Typically, this should be a length-1 vector (i.e., a single string) but you may pass multiple names of random factors whose interaction is to be nested in groups (see *Assignment Constraints*).</p>
</td></tr>
<tr><td><code id="random.factor_+3A_groups">groups</code></td>
<td>
<p>Names of fixed and random factors that are to be used as grouping (nesting/between) levels.</p>
</td></tr>
<tr><td><code id="random.factor_+3A_instances">instances</code></td>
<td>
<p>Number of times (as a single integer value) each level (instantiation) is to be replicated.</p>
</td></tr>
<tr><td><code id="random.factor_+3A_assign">assign</code></td>
<td>
<p>For random factor interactions, use this method for counterbalancing instance assignment (see Assignment Constraints)</p>
</td></tr>
<tr><td><code id="random.factor_+3A_...">...</code></td>
<td>
<p>Additional arguments to be stored as <code>extra</code> values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of the class <code>randomFactor</code>.
</p>


<h3>Nesting Random Factors</h3>

<p>A typical case of nesting in a psychological experiment is to vary a factor between subjects. That means that each subject would only be assigned to one condition of the nesting fixed factor (such as type of instruction). All other fixed factors that are not listed under 'groups' are considered to vary within the random factor. Note that nesting increases the number of replications of the random factor.
</p>
<p>Note that a random factor may be nested within fixed and/or other random factors but fixed factors may only be nested within levels of other fixed factors.
</p>


<h3>Assignment Constraints</h3>

<p>A random interaction (a random factor instantiated with more than one name) governs the assignment of the co-occurence of the listed random factors.
That means that, for example, <code>random.factor(c("Subject","Item"), groups="correct")</code> ensures that the assignment of a Subject and Item to one another occurs in only *one* of the conditions of <code>correct</code>.
You may use <code>assign = '...'</code> to provide the method to counterbalance the assignment. By default, <code>'latin.square'</code> is used but you may also use <code>'random.order'</code> or <code>'permutations'</code>. Note that, depending on the assignment method you use, the constituting random factors (in this case <code>Subject</code> and <code>Item</code>) will be replicated n-times (<code>n</code> being the number of conditions of the nesting factors) for <code>'latin.square'</code> and <code>'random.order'</code> and n!-times for <code>'permutations'</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fixed.factor">fixed.factor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A random factor Subject that nests factors blockOrder and gender,
# i.e. blockOrder and gender are "between-subject"

random.factor("Subject", groups=c("blockOrder", "gender"))

# A random factor Item without any grouping
random.factor("Item")


</code></pre>

<hr>
<h2 id='random.factors'>Extract factors by type</h2><span id='topic+random.factors'></span><span id='topic+fixed.factors'></span>

<h3>Description</h3>

<p>From a given design, extract contained random or fixed factors as a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random.factors(design, include_interactions = TRUE)

fixed.factors(design)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.factors_+3A_design">design</code></td>
<td>
<p>The factor design to check.</p>
</td></tr>
<tr><td><code id="random.factors_+3A_include_interactions">include_interactions</code></td>
<td>
<p>Should random factor interactions be included?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of factors that are either fixed or random.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>random.factors()</code>: Return fixed factors
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
des &lt;- fixed.factor("Factor1", c("1A","1B")) +
       fixed.factor("Factor2", c("2A","2B")) +
       random.factor("Subject", c("Factor1"))
       
random.factors(des)
fixed.factors(des)

stopifnot(setequal(names(random.factors(des)), c("Subject")))
stopifnot(setequal(names(fixed.factors(des)), c("Factor1","Factor2")))


</code></pre>

<hr>
<h2 id='show.factorContainer'>Output a design factor summary</h2><span id='topic+show.factorContainer'></span>

<h3>Description</h3>

<p>Output a design factor summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show.factorContainer(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show.factorContainer_+3A_object">object</code></td>
<td>
<p>the factor container to display</p>
</td></tr>
</table>

<hr>
<h2 id='simLMM'>Simulate data from a linear mixed-effects model</h2><span id='topic+simLMM'></span>

<h3>Description</h3>

<p>This function simulates artificial data from a linear mixed-effects model. Parameters can either be set by hand using the parameters listed below *or* using a fitted <code>lmerMod</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simLMM(
  formula,
  data = NULL,
  Fixef,
  VC_sd,
  CP = 0,
  LMM = NULL,
  empirical = FALSE,
  verbose = TRUE,
  family = "gaussian"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simLMM_+3A_formula">formula</code></td>
<td>
<p>A formula as used in a call to the <code>lmer</code> function: a one-sided linear formula object describing both the fixed-effects and random-effects part of the model, with no response variable to the left of the <code>~</code> operator.</p>
</td></tr>
<tr><td><code id="simLMM_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables named in <code>formula</code>. Optional if <code>LMM</code> is provided.</p>
</td></tr>
<tr><td><code id="simLMM_+3A_fixef">Fixef</code></td>
<td>
<p>a vector of all fixed-effect model parameters.</p>
</td></tr>
<tr><td><code id="simLMM_+3A_vc_sd">VC_sd</code></td>
<td>
<p>standard deviations of the variance components for the random effects. This is a list of vectors, where different list entries reflect different grouping structures, and each vector contains standard deviations of variance components (random intercepts and random slopes) for one grouping factor. The last list entry is the standard deviation of the residual noise term (for <code>gaussian</code> or <code>lognormal</code> families only).</p>
</td></tr>
<tr><td><code id="simLMM_+3A_cp">CP</code></td>
<td>
<p>correlation parameters of the random effects. If <code>CP</code> is a single number, then all CP are set to this same value. If <code>CP</code> is a vector of length equal to the number of grouping factor, then each vector entry specifies one fixed value for all CP associated with this grouping factor. Otherwise, <code>CP</code> can be a list of correlation matrices, which specifies a full correlation matrix for each grouping structure.</p>
</td></tr>
<tr><td><code id="simLMM_+3A_lmm">LMM</code></td>
<td>
<p>if a <code>lmerMod</code> object containing a fitted <code>lmer</code> model is provided, then <code>simLMM</code> uses the estimated model parameters for data simulation. Note: If <code>LMM</code> is provided, <code>formula</code>, <code>Fixef</code>, <code>VC_sd</code>, <code>CP</code>, and <code>family</code> are taken from the provided fitted model, the arguments are ignored in the model call, and a warning is given.</p>
</td></tr>
<tr><td><code id="simLMM_+3A_empirical">empirical</code></td>
<td>
<p>logical. If true, <code>Fixef</code> specify the empirical not population fixed effects parameters. <code>empirical=TRUE</code> does not work for residual Bernoulli noise, and not if continuous covariates are used.</p>
</td></tr>
<tr><td><code id="simLMM_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), then information about the used model parameters is provided. If <code>FALSE</code>, then no output is generated.</p>
</td></tr>
<tr><td><code id="simLMM_+3A_family">family</code></td>
<td>
<p>string specifying the response distribution: <code>"gaussian"</code> (default) assumes a normal distribution, <code>binomial</code> specifies a Bernoulli distribution with a logit link function, <code>"lognormal"</code> specifies a log-normal distribution; with <code>"lp"</code>, only the linear predictor is generated with no residual noise.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
design &lt;-
  fixed.factor("X", levels=c("X1", "X2")) +
  random.factor("Subj", instances=30)
dat &lt;- design.codes(design)
contrasts(dat$X) &lt;- c(-1, +1)

dat$ysim &lt;- simLMM(formula = ~ 1 + X + (1 + X | Subj),
                   data = dat,
                   Fixef = c(200, 10),
                   VC_sd = list(c(30,10), 50),
                   CP = 0.3,
                   empirical = TRUE)

dat$Xn &lt;- ifelse(dat$X=="X1",-1,1)
# lme4::lmer(ysim ~ Xn + (Xn || Subj), data=dat, control=lmerControl(calc.derivs=FALSE))

</code></pre>

<hr>
<h2 id='subset+2CfactorDesign-method'>Subset factor designs</h2><span id='topic+subset+2CfactorDesign-method'></span><span id='topic+subset'></span>

<h3>Description</h3>

<p>Subset factor designs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset+2B2CfactorDesign-method_+3A_x">x</code></td>
<td>
<p>A factorDesign object</p>
</td></tr>
<tr><td><code id="subset+2B2CfactorDesign-method_+3A_...">...</code></td>
<td>
<p>*subset*: Criteria along which to filter in planned observations / design matrix rows., *select*: Names of factors to keep in the design matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>factorDesign</code> object with a subsetted design matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
des &lt;- fixed.factor("Factor1", c("1A","1B")) +
       fixed.factor("Factor2", c("2A","2B")) +
       random.factor("Subject", c("Factor1"))
       
subset(des, select = "Subject")
subset(des, Factor1 == "1A" | Factor2 == "2B", "Subject")

</code></pre>

<hr>
<h2 id='write.design'>Write Design Files</h2><span id='topic+write.design'></span><span id='topic+write.design.csv'></span><span id='topic+write.design.xlsx'></span><span id='topic+write.design.json'></span>

<h3>Description</h3>

<p>This function writes a design into a set of files. For each random factor, a unit list is created that contains a list of all levels (instances) of the random factor and the factor levels to which that level is assigned. Moreover, code_files are created that contain a complete set of experimental codes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.design(
  design,
  group_by = NULL,
  order_by = NULL,
  randomize = FALSE,
  run_files = paste0("run", ifelse(length(group_by) &gt; 0L, paste0("_", group_by, "-%",
    seq_along(group_by), "$s", collapse = ""), "")),
  code_files = "codes_%s",
  output_dir,
  output_handler,
  file_extension = NULL,
  ...
)

write.design.csv(..., quote = FALSE, row.names = FALSE)

write.design.xlsx(..., format_headers = FALSE)

write.design.json(..., dataframe = "columns")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.design_+3A_design">design</code></td>
<td>
<p>The <code>factorDesign</code> to be written into files.</p>
</td></tr>
<tr><td><code id="write.design_+3A_group_by">group_by</code></td>
<td>
<p>Experimental codes are to be grouped by these factors. If <code>NULL</code>, all codes are written into one file. Also see <code><a href="#topic+output.design">output.design</a></code> for grouping design output.</p>
</td></tr>
<tr><td><code id="write.design_+3A_order_by">order_by</code></td>
<td>
<p>The experimental codes are to be ordered by these columns. Also see <code><a href="#topic+output.design">output.design</a></code> for ordering design output.</p>
</td></tr>
<tr><td><code id="write.design_+3A_randomize">randomize</code></td>
<td>
<p>After ordering, lines in the same order rank are to be shuffled randomly if set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="write.design_+3A_run_files">run_files</code></td>
<td>
<p>The pattern to be used for the file names of the run_files (i.e., files containing the experimental codes). By default, file names are <code>"run_Group1_Othergroup4.ext"</code> ect.</p>
</td></tr>
<tr><td><code id="write.design_+3A_code_files">code_files</code></td>
<td>
<p>Code files (files containing conditions for levels of random factors) are named after this pattern.</p>
</td></tr>
<tr><td><code id="write.design_+3A_output_dir">output_dir</code></td>
<td>
<p>All files are written into this directory.</p>
</td></tr>
<tr><td><code id="write.design_+3A_output_handler">output_handler</code></td>
<td>
<p>This is the function that is called to write the data frames. If using <code>write.design.csv</code>, this is <code>utils::write.csv</code> and if using <code>write.design.json</code>, this is <code>jsonlite::write_json</code>.</p>
</td></tr>
<tr><td><code id="write.design_+3A_file_extension">file_extension</code></td>
<td>
<p>This is the file_extension to be added after each file name. Use &rdquo; if no file_extension is to be added. If 'NULL', the file_extension is guessed from the output_handler used.</p>
</td></tr>
<tr><td><code id="write.design_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed on to <code>write.design</code> and the underlying output_handler.</p>
</td></tr>
<tr><td><code id="write.design_+3A_quote">quote</code>, <code id="write.design_+3A_row.names">row.names</code></td>
<td>
<p>see <code><a href="utils.html#topic+write.csv">utils::write.csv()</a></code></p>
</td></tr>
<tr><td><code id="write.design_+3A_format_headers">format_headers</code></td>
<td>
<p>see <code><a href="writexl.html#topic+write_xlsx">writexl::write_xlsx()</a></code>, default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="write.design_+3A_dataframe">dataframe</code></td>
<td>
<p>see <code><a href="jsonlite.html#topic+write_json">jsonlite::write_json()</a></code></p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>write.design.csv()</code>: Using default settings for writing CSV files
</p>
</li>
<li> <p><code>write.design.xlsx()</code>: Using default settings for writing XLSX files (using the <code>writexl</code> package)
</p>
</li>
<li> <p><code>write.design.json()</code>: Using default settings for writing JSON files (using the <code>jsonlite</code> package)
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+output.design">output.design</a></code> for use of <code>order_by</code> and <code>group_by</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
des &lt;- fixed.factor("Factor1", c("1A","1B")) +
       fixed.factor("Factor2", c("2A","2B")) +
       random.factor("Subject", c("Factor1"))
    
# This writes a CSV file for each subject and a CSV list of subjects
write.design(des, group_by = "Subject", output_handler = write.csv, output_dir = tempdir())

# This writes a single CSV file for all subjects and a CSV list of subjects
write.design(des, output_handler = write.csv, output_dir = tempdir())

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
