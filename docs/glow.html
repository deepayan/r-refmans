<!DOCTYPE html><html lang="en"><head><title>Help for package glow</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {glow}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#additive_alpha'><p>additive_alpha</p></a></li>
<li><a href='#circular_palette'><p>circular_palette</p></a></li>
<li><a href='#clifford_attractor'><p>clifford_attractor</p></a></li>
<li><a href='#GlowMapper'><p>GlowMapper</p></a></li>
<li><a href='#GlowMapper4'><p>GlowMapper4</p></a></li>
<li><a href='#light_cool_colors'><p>light_cool_colors</p></a></li>
<li><a href='#light_heat_colors'><p>light_heat_colors</p></a></li>
<li><a href='#LightMapper'><p>LightMapper</p></a></li>
<li><a href='#LightMapper4'><p>LightMapper4</p></a></li>
<li><a href='#map_colors'><p>map_colors</p></a></li>
<li><a href='#mollweide_projection'><p>mollweide_projection</p></a></li>
<li><a href='#relxy'><p>relxy</p></a></li>
<li><a href='#theme_night'><p>theme_night</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Make Plots that Glow</td>
</tr>
<tr>
<td>Version:</td>
<td>0.13.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-09-24</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Travers Ching &lt;traversc@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a framework for creating plots with glowing points.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen, RcppParallel</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, RcppParallel (&ge; 5.1.2), R6</td>
</tr>
<tr>
<td>Depends:</td>
<td>ggplot2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, viridisLite, magick, EBImage, qs2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/traversc/glow">https://github.com/traversc/glow</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/traversc/glow/issues">https://github.com/traversc/glow/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-25 05:11:08 UTC; tching</td>
</tr>
<tr>
<td>Author:</td>
<td>Travers Ching [aut, cre, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-25 12:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='additive_alpha'>additive_alpha</h2><span id='topic+additive_alpha'></span>

<h3>Description</h3>

<p>Simulates additive blending on a dark to light color scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>additive_alpha(colors)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="additive_alpha_+3A_colors">colors</code></td>
<td>
<p>colors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In R plotting (both ggplot and base R) blending is performed by alpha blending, which is an averaging effect. When combining light and glow effects, additive blending is more appropriate. 
</p>
<p>This function simulates additive blending by increasing color on a color scale to compensate for the averaging effect of alpha blending. 
</p>
<p>Note: this function is only appropriate for dark to light color scales.
</p>


<h3>Value</h3>

<p>A simulated additive scale of the input colors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m_solid &lt;- viridisLite::magma(12)
m_additive &lt;- additive_alpha(m_solid)
</code></pre>

<hr>
<h2 id='circular_palette'>circular_palette</h2><span id='topic+circular_palette'></span>

<h3>Description</h3>

<p>A helper function for circularizing color palettes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circular_palette(n, pal_function=rainbow, invert=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circular_palette_+3A_n">n</code></td>
<td>
<p>Number of colors to output (must be divisible by 2)</p>
</td></tr>
<tr><td><code id="circular_palette_+3A_pal_function">pal_function</code></td>
<td>
<p>The base palette to circularize</p>
</td></tr>
<tr><td><code id="circular_palette_+3A_invert">invert</code></td>
<td>
<p>Whether to invert the palette See details.</p>
</td></tr>
<tr><td><code id="circular_palette_+3A_...">...</code></td>
<td>
<p>Arguments passed to 'pal_function'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful when the color represents radial data. E.g. position on a sphere or circle. 
The 'invert' parameter reverses the order of circularization. E.g. if your circular palette would be red to blue to red, 
'invert' changes this blue to red to blue.
</p>


<h3>Value</h3>

<p>A circular color palette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>colors &lt;- circular_palette(n=1000, pal_function=rainbow)
t &lt;- seq(0,2*pi, length.out=1000)
plot(sin(t), cos(t), col = colors, pch = 19)
</code></pre>

<hr>
<h2 id='clifford_attractor'>clifford_attractor</h2><span id='topic+clifford_attractor'></span>

<h3>Description</h3>

<p>A 2D chaotic attractor created by Clifford Pickover.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clifford_attractor(n_iter, A=1.886, B=-2.357, C=-0.328, D=0.918, x0=0.1, y0=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clifford_attractor_+3A_n_iter">n_iter</code></td>
<td>
<p>number of points to generate</p>
</td></tr>
<tr><td><code id="clifford_attractor_+3A_a">A</code></td>
<td>
<p>see details</p>
</td></tr>
<tr><td><code id="clifford_attractor_+3A_b">B</code></td>
<td>
<p>see details</p>
</td></tr>
<tr><td><code id="clifford_attractor_+3A_c">C</code></td>
<td>
<p>see details</p>
</td></tr>
<tr><td><code id="clifford_attractor_+3A_d">D</code></td>
<td>
<p>see details</p>
</td></tr>
<tr><td><code id="clifford_attractor_+3A_x0">x0</code></td>
<td>
<p>The initial x-coordinate</p>
</td></tr>
<tr><td><code id="clifford_attractor_+3A_y0">y0</code></td>
<td>
<p>The initial y-coordinate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A clifford attractor is a 2D chaotic attractor given by the two equations:
X[i+1] = sin(a*Y[i]) - c*cos(a*X[i])
Y[i+1] = sin(b*X[i]) - d*cos(b*Y[i])
https://en.wikipedia.org/wiki/List_of_chaotic_maps
https://stackoverflow.com/q/51122970/2723734
</p>


<h3>Value</h3>

<p>A dataframe containing X and Y coordinates of clifford attractor points, the angle and the distance between successive points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cliff_points &lt;- clifford_attractor(1e4, 1.886,-2.357,-0.328, 0.918, 0.1, 0)
color_pal &lt;- circular_palette(n=144, pal_function=rainbow)
cliff_points$color &lt;- map_colors(color_pal, cliff_points$angle, min_limit=-pi, max_limit=pi)

gm &lt;- GlowMapper4$new(xdim=240, ydim=240, blend_mode = "additive", nthreads=1)
gm$map(x=cliff_points$x, y=cliff_points$y, radius=0.1, color=cliff_points$color)
pd &lt;- gm$output_dataframe(saturation = 1)

ggplot() +
  geom_raster(data = pd, aes(x = x, y = y, fill = rgb(r,g,b,a)), show.legend=FALSE) +
  coord_fixed(gm$aspect(), xlim = gm$xlim(), ylim = gm$ylim()) + 
  scale_fill_identity() + 
  theme_night()
</code></pre>

<hr>
<h2 id='GlowMapper'>GlowMapper</h2><span id='topic+GlowMapper'></span>

<h3>Description</h3>

<p>This class provides a framework for creating scatter plots based on a glow simulation. Points are mapped with a gaussian gradient to a raster with specified dimensions and properties.
</p>


<h3>Usage</h3>

<pre>m &lt;- GlowMapper$new(xdim=1000, ydim=800, blend_mode = "screen", contrast_limit = 1e5, nthreads = 1)

m$map(x, y, radius, intensity = 1, distance_exponent = 2, xlimits = c(NA_real_, NA_real_), ylimits = c(NA_real_, NA_real_), append = FALSE)

m$output_raw(saturation = NA_real_)

m$output_dataframe(saturation = NA_real_)

m$aspect()

m$xlim()

m$ylim()
</pre>


<h3>Arguments</h3>


<dl>
<dt>xdim</dt><dd><p>- The first dimension of the output matrix raster.</p>
</dd>
<dt>ydim</dt><dd><p>- The second dimension of the output matrix raster.</p>
</dd>
<dt>blend_mode</dt><dd><p>- Either screen or additive blending mode. See details.</p>
</dd>
<dt>contrast_limit</dt><dd><p>- Determines the distance to search from a point. You shouldn't need to change this unless you have a lot of points in the plot stacked on top of each other.</p>
</dd>
<dt>nthreads</dt><dd><p>- Number of threads to use.</p>
</dd>
<dt>x</dt><dd><p>- X coordinate of points.</p>
</dd>
<dt>y</dt><dd><p>- Y coordinate of points.</p>
</dd>
<dt>radius</dt><dd><p>- Relative spread of glow intensity. The radius should be proportional to the x and y-ranges of the plot. Values between 1/10 to 1/100 of the range of the plot generally produce good results.</p>
</dd>
<dt>intensity</dt><dd><p>- Maximum intensity at the center of a point.</p>
</dd>
<dt>distance_exponent</dt><dd><p>- Exponent of the distance calculation when calculating intensities. A value of 2 corresponds to euclidean distance; a value of 1 corresponds to manhattan distance.</p>
</dd>
<dt>xlimits</dt><dd><p>- The x-limits of the output plot. If NA, the limits are +/- 5% of the maximum and minimum points.</p>
</dd>
<dt>ylimits</dt><dd><p>- The y-limits of the output plot. If NA, the limits are +/- 5% of the maximum and minimum points.</p>
</dd>
<dt>append</dt><dd><p> - Whether to add to the existing output or overwrite.</p>
</dd>
<dt>saturation</dt><dd><p>- When retrieving the output with <code>$output_raw</code> or <code>$output_dataframe</code>, maximum intensity values are capped at the given value. This is often useful when using additive blend mode to increase contrast.</p>
</dd>
</dl>



<h3>Details</h3>

<p><code>$new()</code> creates a new GlowMapper object, which holds parameters, plotting data, and the output (a matrix of glow intensities). Creates a canvas to plot point data. With additive blending, the intensities of each point are added arithmetically, which is how light intensities are added in the physical world. This is equivalent to an fast/approximate un-normalized 2D kernel density estimate. 
</p>
<p>With &quot;screen&quot; blending,  two intensities are added according to the formula: <code>I_out = 1 - (1-I_a)*(1-I_b)</code>. Both additive blending and screen blending are commutative operations, meaning the order of points in a plot does not affect the output.
</p>
<p>Screen blending can often improve contrast in a plot and is the default. 
</p>
<p><code>$map()</code> maps points to the canvas. 
</p>
<p><code>$output_raw()</code> output raw matrix rasters. Useful for plotting in base R.
</p>
<p><code>$output_dataframe()</code> output the raster as a dataframe with XY coordinates. This is meant to pipe directly into ggplot.
</p>
<p><code>$aspect()</code>, <code>$xlim()</code>, <code>$ylim()</code> return the aspect ratio, x-limits and y-limits of the raster. These functions are intended to be used with plotting functions (e.g. <code>ggplot2::coord_fixed()</code>) so that the output raster is not distorted. See example below.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot Data: x,y,r
x &lt;- numeric(length=50)
y &lt;- numeric(length=50)
r &lt;- numeric(length=50)
for(t in 1:50) {
  xy &lt;- exp(1i * t/2 - t/12)
  x[t] &lt;- Re(xy)
  y[t] &lt;- Im(xy)
  r[t] &lt;- sqrt(x[t]^2 + y[t]^2)
}

# New class object
m &lt;- GlowMapper$new(xdim=500, ydim = 400, blend_mode = "screen")

# Map data on to raster
m$map(x=x, y=y, intensity = 1, radius = r/4 + 0.1, distance_exponent = 2)

# Output raster data as a dataframe
pd &lt;- m$output_dataframe(saturation = 1)

# Plot with ggplot
ggplot(pd, aes(x = x, y = y, fill = value)) + 
  geom_raster(show.legend = FALSE) +
  scale_fill_gradientn(colors=additive_alpha(c("black", "purple", "white"))) +
  coord_fixed(ratio = m$aspect(), xlim = m$xlim(), ylim = m$ylim(), expand = FALSE) + 
  theme_night(bgcolor = "black")
</code></pre>

<hr>
<h2 id='GlowMapper4'>GlowMapper4</h2><span id='topic+GlowMapper4'></span>

<h3>Description</h3>

<p>This class provides a framework for creating scatter plots based on a glow simulation with explicit color intensities. Points are mapped with a gaussian gradient to a raster with specified dimensions and properties.
</p>


<h3>Usage</h3>

<pre>m &lt;- GlowMapper$new(xdim=1000, ydim=800, blend_mode = "additive", background_color = "#00000000", contrast_limit = 1e5, nthreads = 1)

m$map(x, y, radius, color = NULL, r=NULL, g=NULL, b=NULL, distance_exponent = 2, xlimits = c(NA_real_, NA_real_), ylimits = c(NA_real_, NA_real_), append = FALSE)

m$output_raw(saturation = 1, saturation_mode = "overflow")

m$output_dataframe(saturation = 1, saturation_mode = "overflow")

m$aspect()

m$xlim()

m$ylim()
</pre>


<h3>Arguments</h3>


<dl>
<dt>xdim</dt><dd><p>- The first dimension of the output matrix raster.</p>
</dd>
<dt>ydim</dt><dd><p>- The second dimension of the output matrix raster.</p>
</dd>
<dt>blend_mode</dt><dd><p>- Either screen or additive blending mode. See details.</p>
</dd>
<dt>background_color</dt><dd><p>- A color that can be coerced to RGBA with 'col2rgb', or a vector of four values between 0 and 1.</p>
</dd>
<dt>contrast_limit</dt><dd><p>- Determines the distance to search from a point. You shouldn't need to change this unless you have a lot of points in the plot stacked on top of each other.</p>
</dd>
<dt>nthreads</dt><dd><p>- Number of threads to use.</p>
</dd>
<dt>x</dt><dd><p>- X coordinate of points.</p>
</dd>
<dt>y</dt><dd><p>- Y coordinate of points.</p>
</dd>
<dt>radius</dt><dd><p>- Relative spread of glow intensity. The radius should be proportional to the x and y-ranges of the plot. Values between 1/10 to 1/100 of the range of the plot generally produce good results.</p>
</dd>
<dt>color</dt><dd><p>- Color of points. If NULL, r, g, and b parameters must be defined (and vice versa).</p>
</dd>
<dt>r</dt><dd><p>- Red intensity of points. Must be between 0 and 1 if using screen blending.</p>
</dd>
<dt>g</dt><dd><p>- Green intensity of points. Must be between 0 and 1 if using screen blending.</p>
</dd>
<dt>b</dt><dd><p>- Blue intensity of points. Must be between 0 and 1 if using screen blending.</p>
</dd>
<dt>distance_exponent</dt><dd><p>- Exponent of the distance calculation when calculating intensities. A value of 2 corresponds to euclidean distance; a value of 1 corresponds to manhattan distance.</p>
</dd>
<dt>xlimits</dt><dd><p>- The x-limits of the output plot. If NA, the limits are +/- 5% of the maximum and minimum points.</p>
</dd>
<dt>ylimits</dt><dd><p>- The y-limits of the output plot. If NA, the limits are +/- 5% of the maximum and minimum points.</p>
</dd>
<dt>append</dt><dd><p> - Whether to add to the existing output or overwrite.</p>
</dd>
<dt>saturation</dt><dd><p>- When retrieving the output with <code>$output_raw</code> or <code>$output_dataframe</code>, maximum intensity values are capped at the given value. This is often useful when using additive blend mode to increase contrast.</p>
</dd>
<dt>saturation_mode</dt><dd><p>- When intensity values are above the saturation threshold, values can be overflowed into other color channels (&quot;overflow&quot;) or simply clipped at the threshold (&quot;clip&quot;). &quot;Overflow&quot; always produces a gradient to white for intensities above the threshold, which may produce artistically better results.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This 'GlowMapper4' class is similar to the 'GlowMapper' class, but instead of a single intensity matrix output, color is specified explicitly.
</p>
<p><code>$new()</code> creates a new GlowMapper object, which holds parameters, plotting data, and the output (a matrix of glow intensities). Creates a canvas to plot point data. With additive blending, the intensities of each point are added arithmetically, which is how light intensities are added in the physical world. This is equivalent to an fast/approximate un-normalized 2D kernel density estimate. 
</p>
<p>With &quot;screen&quot; blending,  two intensities are added according to the formula: <code>I_out = 1 - (1-I_a)*(1-I_b)</code>. Both additive blending and screen blending are commutative operations, meaning the order of points in a plot does not affect the output.
</p>
<p>Screen blending can often improve contrast in a plot and is the default. 
</p>
<p><code>$map()</code> maps points to the canvas. 
</p>
<p><code>$output_raw()</code> output raw matrix rasters (a list of four matrices, one for each RGBA channel). Useful for plotting in base R.
</p>
<p><code>$output_dataframe()</code> output the raster as a dataframe with XY coordinates. This is meant to pipe directly into ggplot.
</p>
<p><code>$aspect()</code>, <code>$xlim()</code>, <code>$ylim()</code> return the aspect ratio, x-limits and y-limits of the raster. These functions are intended to be used with plotting functions (e.g. <code>ggplot2::coord_fixed()</code>) so that the output raster is not distorted. See example below.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot Data: x,y,r
x &lt;- numeric(length=50)
y &lt;- numeric(length=50)
r &lt;- numeric(length=50)
color &lt;- character(length=50)
for(t in 1:50) {
  xy &lt;- exp(1i * t/2 - t/12)
  x[t] &lt;- Re(xy)
  y[t] &lt;- Im(xy)
  r[t] &lt;- sqrt(x[t]^2 + y[t]^2)
  color[t] &lt;- rgb(t/50,0,1-t/50)
}

# New class object
m &lt;- GlowMapper4$new(xdim=500, ydim = 400, blend_mode = "additive")

# Map data on to raster
m$map(x=x, y=y, color = color, radius = r/4 + 0.1, distance_exponent = 2)

# Output raster data as a dataframe
pd &lt;- m$output_dataframe(saturation = 1, saturation_mode = "overflow")

# Plot with ggplot
ggplot(pd, aes(x = x, y = y, fill = rgb(r,g,b,a))) + 
  geom_raster(show.legend = FALSE) +
  scale_fill_identity() +
  coord_fixed(ratio = m$aspect(), xlim = m$xlim(), ylim = m$ylim(), expand = FALSE) + 
  theme_night(bgcolor = "black")
</code></pre>

<hr>
<h2 id='light_cool_colors'>light_cool_colors</h2><span id='topic+light_cool_colors'></span>

<h3>Description</h3>

<p>A light color palette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>light_cool_colors(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="light_cool_colors_+3A_...">...</code></td>
<td>
<p>Arguments passed to the function returned by 'colorRampPalette'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simple light color palette gradient from dark blue to light blue 
intended for a heatmap with a white or light color background. 
</p>
<p>Equivalent to 'colorRampPalette(c(&quot;#1133AA&quot;, &quot;#CCFFFF&quot;))(...)'.
</p>


<h3>Value</h3>

<p>A light color palette function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>light_colors &lt;- light_cool_colors(144)
plot(1:144, 1:144, col = light_colors, pch = 19)
</code></pre>

<hr>
<h2 id='light_heat_colors'>light_heat_colors</h2><span id='topic+light_heat_colors'></span>

<h3>Description</h3>

<p>A light color palette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>light_heat_colors(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="light_heat_colors_+3A_...">...</code></td>
<td>
<p>Arguments passed to the function returned by 'colorRampPalette'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simple light color palette gradient from red to orange to gold to
yellow intended for a heatmap with a white or light color background. 
</p>
<p>Equivalent to 'colorRampPalette(c(&quot;red&quot;, &quot;darkorange2&quot;, &quot;darkgoldenrod1&quot;, &quot;gold1&quot;, &quot;yellow2&quot;))(...)'.
</p>


<h3>Value</h3>

<p>A light color palette function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>light_colors &lt;- light_heat_colors(144)
plot(1:144, 1:144, col = light_colors, pch = 19)
</code></pre>

<hr>
<h2 id='LightMapper'>LightMapper</h2><span id='topic+LightMapper'></span>

<h3>Description</h3>

<p>This class provides a framework for creating scatter plots based on a point light simulation. Points are mapped with a inverse power gradient to a raster with specified dimensions and properties.
</p>


<h3>Usage</h3>

<pre>m &lt;- LightMapper$new(xdim=1000, ydim=800, blend_mode = "screen", contrast_limit = 1e5, nthreads = 1)

m$map(x, y, radius, intensity = 1, radius, falloff_exponent = 1, distance_exponent = 2, xlimits = c(NA_real_, NA_real_), ylimits = c(NA_real_, NA_real_), append = FALSE)

m$output_raw(saturation = NA_real_)

m$output_dataframe(saturation = NA_real_)

m$aspect()

m$xlim()

m$ylim()
</pre>


<h3>Arguments</h3>


<dl>
<dt>xdim</dt><dd><p>- The first dimension of the output matrix raster.</p>
</dd>
<dt>ydim</dt><dd><p>- The second dimension of the output matrix raster.</p>
</dd>
<dt>blend_mode</dt><dd><p>- Either screen or additive blending mode. See details.</p>
</dd>
<dt>nthreads</dt><dd><p>- Number of threads to use.</p>
</dd>
<dt>x</dt><dd><p>- X coordinate of points.</p>
</dd>
<dt>y</dt><dd><p>- Y coordinate of points.</p>
</dd>
<dt>radius</dt><dd><p>- Relative spread of glow intensity. The radius should be proportional to the x and y-ranges of the plot. Values between 1/10 to 1/100 of the range of the plot generally produce good results.</p>
</dd>
<dt>intensity</dt><dd><p>- Maximum intensity at the center of a point.</p>
</dd>
<dt>falloff_exponent</dt><dd><p>- Exponent to determine how fast light intensity decreases from the point origin. A value of 0.5 corresponds to a linear falloff; a value of 2 corresponds to an inverse square. Generally you want this value to be high, otherwise you'll flood your plot with light.</p>
</dd>
<dt>distance_exponent</dt><dd><p>- Exponent of the distance calculation when calculating intensities. A value of 2 corresponds to euclidean distance; a value of 1 corresponds to manhattan distance.</p>
</dd>
<dt>xlimits</dt><dd><p>- The x-limits of the output plot. If NA, the limits are +/- 5% of the maximum and minimum points.</p>
</dd>
<dt>ylimits</dt><dd><p>- The y-limits of the output plot. If NA, the limits are +/- 5% of the maximum and minimum points.</p>
</dd>
<dt>append</dt><dd><p> - Whether to add to the existing output or overwrite.</p>
</dd>
<dt>saturation</dt><dd><p>- When retrieving the output with <code>$output_raw</code> or <code>$output_dataframe</code>, maximum intensity values are capped at the given value. This is often useful when using additive blend mode to increase contrast.</p>
</dd>
</dl>



<h3>Details</h3>

<p><code>$new()</code> creates a new LightMapper object, which holds parameters, plotting data, and the output (a matrix of glow intensities). Creates a canvas to plot point data. With additive blending, the intensities of each point are added arithmetically, which is how light intensities are added in the physical world. This is equivalent to an fast/approximate un-normalized 2D kernel density estimate. 
</p>
<p>#' With &quot;screen&quot; blending, two intensities are added according to the formula: <code>I_out = 1 - (1-I_a)*(1-I_b)</code>. Both additive blending and screen blending are commutative operations, meaning the order of points in a plot does not affect the output.
</p>
<p>Note: Mapping &quot;lights&quot; (inverse power intensity) is much slower than &quot;glow&quot; effects (gaussian intensities) for various reasons. Plotting more than a few hundred points with <code>LightMapper</code> or <code>LightMapper4</code> may be computationally prohibitive. 
</p>
<p>Screen blending can often improve contrast in a plot and is the default. 
</p>
<p><code>$map()</code> maps points to the canvas. 
</p>
<p><code>$output_raw()</code> output raw matrix rasters. Useful for plotting in base R.
</p>
<p><code>$output_dataframe()</code> output the raster as a dataframe with XY coordinates. This is meant to pipe directly into ggplot.
</p>
<p><code>$aspect()</code>, <code>$xlim()</code>, <code>$ylim()</code> return the aspect ratio, x-limits and y-limits of the raster. These functions are intended to be used with plotting functions (e.g. <code>ggplot2::coord_fixed()</code>) so that the output raster is not distorted. See example below.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot Data: x,y,r
x &lt;- numeric(length=50)
y &lt;- numeric(length=50)
r &lt;- numeric(length=50)
for(t in 1:50) {
  xy &lt;- exp(1i * t/2 - t/12)
  x[t] &lt;- Re(xy)
  y[t] &lt;- Im(xy)
  r[t] &lt;- sqrt(x[t]^2 + y[t]^2)
}

# New class object
m &lt;- LightMapper$new(xdim=500, ydim = 400, blend_mode = "screen")

# Map data on to raster
m$map(x=x, y=y, intensity = 1, radius = r/100, falloff_exponent = 0.5, distance_exponent = 2)

# Output raster data as a dataframe
pd &lt;- m$output_dataframe(saturation = 1)

# Plot with ggplot
ggplot(pd, aes(x = x, y = y, fill = value)) + 
  geom_raster(show.legend = FALSE) +
  scale_fill_gradientn(colors=additive_alpha(c("black", "purple", "white"))) +
  coord_fixed(ratio = m$aspect(), xlim = m$xlim(), ylim = m$ylim(), expand = FALSE) + 
  theme_night(bgcolor = "black")
</code></pre>

<hr>
<h2 id='LightMapper4'>LightMapper4</h2><span id='topic+LightMapper4'></span>

<h3>Description</h3>

<p>This class provides a framework for creating scatter plots based on a point light simulation  with explicit color intensities. Points are mapped with a inverse power gradient to a raster with specified dimensions and properties.
</p>


<h3>Usage</h3>

<pre>m &lt;- GlowMapper$new(xdim=1000, ydim=800, blend_mode = "additive", background_color = "#00000000", nthreads = 1)

m$map(x, y, radius, color = NULL, r=NULL, g=NULL, b=NULL, falloff_exponent = 1, distance_exponent = 2, xlimits = c(NA_real_, NA_real_), ylimits = c(NA_real_, NA_real_), append = FALSE)

m$output_raw(saturation = 1, saturation_mode = "overflow")

m$output_dataframe(saturation = 1, saturation_mode = "overflow")

m$aspect()

m$xlim()

m$ylim()
</pre>


<h3>Arguments</h3>


<dl>
<dt>xdim</dt><dd><p>- The first dimension of the output matrix raster.</p>
</dd>
<dt>ydim</dt><dd><p>- The second dimension of the output matrix raster.</p>
</dd>
<dt>blend_mode</dt><dd><p>- Either screen or additive blending mode. See details.</p>
</dd>
<dt>background_color</dt><dd><p>- A color that can be coerced to RGBA with 'col2rgb', or a vector of four values between 0 and 1.</p>
</dd>
<dt>nthreads</dt><dd><p>- Number of threads to use.</p>
</dd>
<dt>x</dt><dd><p>- X coordinate of points.</p>
</dd>
<dt>y</dt><dd><p>- Y coordinate of points.</p>
</dd>
<dt>radius</dt><dd><p>- Relative spread of glow intensity. The radius should be proportional to the x and y-ranges of the plot. Values between 1/10 to 1/100 of the range of the plot generally produce good results.</p>
</dd>
<dt>color</dt><dd><p>- Color of points. If NULL, r, g, and b parameters must be defined (and vice versa).</p>
</dd>
<dt>r</dt><dd><p>- Red intensity of points. Must be between 0 and 1 if using screen blending.</p>
</dd>
<dt>g</dt><dd><p>- Green intensity of points. Must be between 0 and 1 if using screen blending.</p>
</dd>
<dt>b</dt><dd><p>- Blue intensity of points. Must be between 0 and 1 if using screen blending.</p>
</dd>
<dt>falloff_exponent</dt><dd><p>- Exponent to determine how fast light intensity decreases from the point origin. A value of 0.5 corresponds to a linear falloff; a value of 2 corresponds to an inverse square. Generally you want this value to be high, otherwise you'll flood your plot with light.</p>
</dd>
<dt>distance_exponent</dt><dd><p>- Exponent of the distance calculation when calculating intensities. A value of 2 corresponds to euclidean distance; a value of 1 corresponds to manhattan distance.</p>
</dd>
<dt>xlimits</dt><dd><p>- The x-limits of the output plot. If NA, the limits are +/- 5% of the maximum and minimum points.</p>
</dd>
<dt>ylimits</dt><dd><p>- The y-limits of the output plot. If NA, the limits are +/- 5% of the maximum and minimum points.</p>
</dd>
<dt>append</dt><dd><p> - Whether to add to the existing output or overwrite.</p>
</dd>
<dt>saturation</dt><dd><p>- When retrieving the output with <code>$output_raw</code> or <code>$output_dataframe</code>, maximum intensity values are capped at the given value. This is often useful when using additive blend mode to increase contrast.</p>
</dd>
<dt>saturation_mode</dt><dd><p>- When intensity values are above the saturation threshold, values can be overflowed into other color channels (&quot;overflow&quot;) or simply clipped at the threshold (&quot;clip&quot;). &quot;Overflow&quot; always produces a gradient to white for intensities above the threshold, which may produce artistically better results.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This 'LightMapper4' class is similar to the 'LightMapper' class, but instead of a single intensity matrix output, color is specified explicitly.
</p>
<p><code>$new()</code> creates a new LightMapper4 object, which holds parameters, plotting data, and the output (a matrix of glow intensities). Creates a canvas to plot point data. With additive blending, the intensities of each point are added arithmetically, which is how light intensities are added in the physical world. This is equivalent to an fast/approximate un-normalized 2D kernel density estimate. 
</p>
<p>With &quot;screen&quot; blending,  two intensities are added according to the formula: <code>I_out = 1 - (1-I_a)*(1-I_b)</code>. Both additive blending and screen blending are commutative operations, meaning the order of points in a plot does not affect the output.
</p>
<p>Screen blending can often improve contrast in a plot and is the default. 
</p>
<p><code>$map()</code> maps points to the canvas. 
</p>
<p><code>$output_raw()</code> output raw matrix rasters (a list of four matrices, one for each RGBA channel). Useful for plotting in base R.
</p>
<p><code>$output_dataframe()</code> output the raster as a dataframe with XY coordinates. This is meant to pipe directly into ggplot.
</p>
<p><code>$aspect()</code>, <code>$xlim()</code>, <code>$ylim()</code> return the aspect ratio, x-limits and y-limits of the raster. These functions are intended to be used with plotting functions (e.g. <code>ggplot2::coord_fixed()</code>) so that the output raster is not distorted. See example below.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot Data: x,y,r
x &lt;- numeric(length=50)
y &lt;- numeric(length=50)
r &lt;- numeric(length=50)
color &lt;- character(length=50)
for(t in 1:50) {
  xy &lt;- exp(1i * t/2 - t/12)
  x[t] &lt;- Re(xy)
  y[t] &lt;- Im(xy)
  r[t] &lt;- sqrt(x[t]^2 + y[t]^2)
  color[t] &lt;- rgb(t/50,0,1-t/50)
}

# New class object
m &lt;- LightMapper4$new(xdim=500, ydim = 400, blend_mode = "additive")

# Map data on to raster
m$map(x=x, y=y, color = color, radius = r/30+0.01, falloff_exponent = 1, distance_exponent = 2)

# Output raster data as a dataframe
pd &lt;- m$output_dataframe(saturation = 1)

# Plot with ggplot
ggplot(pd, aes(x = x, y = y, fill = rgb(r,g,b,a))) + 
  geom_raster(show.legend = FALSE) +
  scale_fill_identity() +
  coord_fixed(ratio = m$aspect(), xlim = m$xlim(), ylim = m$ylim(), expand = FALSE) + 
  theme_night(bgcolor = "black")
</code></pre>

<hr>
<h2 id='map_colors'>map_colors</h2><span id='topic+map_colors'></span>

<h3>Description</h3>

<p>A helper function for manually mapping colors to a vector of colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_colors(colors, x, min_limit=NULL, max_limit=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_colors_+3A_colors">colors</code></td>
<td>
<p>A vector of colors</p>
</td></tr>
<tr><td><code id="map_colors_+3A_x">x</code></td>
<td>
<p>A numeric vector of data</p>
</td></tr>
<tr><td><code id="map_colors_+3A_min_limit">min_limit</code></td>
<td>
<p>The minimum value to scale the color to. Must be outside the range of data. If NULL, the minimum is determined by the data.</p>
</td></tr>
<tr><td><code id="map_colors_+3A_max_limit">max_limit</code></td>
<td>
<p>The maximum value to scale the color to. Must be outside the range of data. If NULL, the maximum is determined by the data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A helper function for manually mapping colors to a vector of colors. It is useful when you want to manually specify color data, 
rather than relying on ggplot functions.
</p>


<h3>Value</h3>

<p>A vector of colors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cliff_points &lt;- clifford_attractor(1e4, 1.886,-2.357,-0.328, 0.918, 0.1, 0)
color_pal &lt;- circular_palette(n=144, pal_function=rainbow)
cliff_points$color &lt;- map_colors(color_pal, cliff_points$angle, min_limit=-pi, max_limit=pi)

gm &lt;- GlowMapper4$new(xdim=240, ydim=240, blend_mode = "additive", nthreads=1)
gm$map(x=cliff_points$x, y=cliff_points$y, radius=0.1, color=cliff_points$color)
pd &lt;- gm$output_dataframe(saturation = 1)

ggplot() +
  geom_raster(data = pd, aes(x = x, y = y, fill = rgb(r,g,b,a)), show.legend=FALSE) +
  coord_fixed(gm$aspect(), xlim = gm$xlim(), ylim = gm$ylim()) + 
  scale_fill_identity() + 
  theme_night()
</code></pre>

<hr>
<h2 id='mollweide_projection'>mollweide_projection</h2><span id='topic+mollweide_projection'></span>

<h3>Description</h3>

<p>Performs a cartographic mollweide projection from polar coordinates (latitude/longitude) to X-Y map coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mollweide_projection(latitude, longitude, meridian)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mollweide_projection_+3A_latitude">latitude</code></td>
<td>
<p>Latitude (aka declination) of points</p>
</td></tr>
<tr><td><code id="mollweide_projection_+3A_longitude">longitude</code></td>
<td>
<p>Longitude (aka right ascension) of points</p>
</td></tr>
<tr><td><code id="mollweide_projection_+3A_meridian">meridian</code></td>
<td>
<p>The x=0 center of the plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the &quot;Newton-Raphson with fast convergence everywhere&quot; algorithm. 
</p>
<p>Latitude and longitude should be in units of radians not degrees. Latitude ranges from +/- pi/2 and longitude ranges from +/- pi.
</p>


<h3>Value</h3>

<p>X/Y coordinates
</p>


<h3>See Also</h3>

<p>https://en.wikipedia.org/wiki/Talk:Mollweide_projection
</p>


<h3>Examples</h3>

<pre><code class='language-R'>longitude &lt;- pi / 4
latitude &lt;- pi / 4
mollweide_projection(longitude, latitude, meridian = 0)
</code></pre>

<hr>
<h2 id='relxy'>relxy</h2><span id='topic+relxy'></span><span id='topic+relx'></span><span id='topic+rely'></span>

<h3>Description</h3>

<p>Helper functions for specifying the 'radius' parameter in 'GlowMapper$map' and similar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relx(r, mode = "data")

rely(r, mode = "data")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relxy_+3A_r">r</code></td>
<td>
<p>Radius of point data relative to X or Y range of the plot, a value between 0 and 1.</p>
</td></tr>
<tr><td><code id="relxy_+3A_mode">mode</code></td>
<td>
<p>One of &quot;data&quot; (default) or &quot;plot&quot;. Whether to use a radius relative to the extent 
of the data range or the plot range (which could have been adjusted manually).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Helper functions for specifying the 'radius' parameter relative to the range of the plot as a proportion. 
I.e., a value of 0.02 corresponds to 2
</p>


<h3>Value</h3>

<p>A class structure for input to 'GlowMapper$map'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gm &lt;- GlowMapper$new(xdim=480, ydim=240, blend_mode = "additive", nthreads=4)

gm$map(x=1:10, y=runif(10)*100, radius=relx(0.01), intensity = 1)
pd &lt;- gm$output_dataframe(saturation = 1)

ggplot() +
  geom_raster(data = pd, aes(x = x, y = y, fill = value), show.legend=FALSE) +
  coord_fixed(gm$aspect(), xlim = gm$xlim(), ylim = gm$ylim()) +
  scale_fill_gradientn(colors = additive_alpha(viridisLite::viridis(12))) +
  theme_night()

# Relative radius to y-range
gm$map(x=1:10, y=runif(10)*100, radius=rely(0.01))
pd &lt;- gm$output_dataframe(saturation = 1)
ggplot() +
  geom_raster(data = pd, aes(x = x, y = y, fill = value), show.legend=FALSE) +
  coord_fixed(gm$aspect(), xlim = gm$xlim(), ylim = gm$ylim()) +
  scale_fill_gradientn(colors = additive_alpha(viridisLite::viridis(12))) +
  theme_night()
</code></pre>

<hr>
<h2 id='theme_night'>theme_night</h2><span id='topic+theme_night'></span>

<h3>Description</h3>

<p>A dark ggplot2 theme with a default black background intended to be used with the glow package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_night(bgcolor = "black", base_size = 14, base_family = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="theme_night_+3A_bgcolor">bgcolor</code></td>
<td>
<p>Background color, default black. Generally you want to match the background with the lowest color value on a color scale.</p>
</td></tr>
<tr><td><code id="theme_night_+3A_base_size">base_size</code></td>
<td>
<p>Base default font size.</p>
</td></tr>
<tr><td><code id="theme_night_+3A_base_family">base_family</code></td>
<td>
<p>Base font family.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The theme is heavily modified from the minimal ggplot theme. It is intended to be use with dark background colors and should not be used with white or light backgrounds.
</p>


<h3>Value</h3>

<p>A ggplot2 theme.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(mtcars, aes(x = mpg, y = wt)) + 
  geom_point(color = "white") +
  theme_night(bgcolor = "black")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
