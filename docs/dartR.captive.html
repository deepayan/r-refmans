<!DOCTYPE html><html><head><title>Help for package dartR.captive</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dartR.captive}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#gl.assign.grm'><p>Population assignment using grm</p></a></li>
<li><a href='#gl.assign.mahalanobis'><p>Assign an individual of unknown provenance to population based on</p>
Mahalanobis Distance</a></li>
<li><a href='#gl.assign.pa'><p>Eliminates populations as possible source populations for an</p>
individual of unknown provenance, using private alleles</a></li>
<li><a href='#gl.assign.pca'><p>Assign an individual of unknown provenance to population based on PCA</p></a></li>
<li><a href='#gl.filter.parent.offspring'><p>Filters putative parent offspring within a population</p></a></li>
<li><a href='#gl.grm'><p>Calculates an identity by descent matrix</p></a></li>
<li><a href='#gl.grm.network'><p>Represents a genomic relationship matrix (GRM) as a network</p></a></li>
<li><a href='#gl.plot.network'><p>Represents a distance or dissimilarity matrix as a network</p></a></li>
<li><a href='#gl.report.parent.offspring'><p>Identifies putative parent offspring within a population</p></a></li>
<li><a href='#gl.run.EMIBD9'><p>Run program EMIBD9</p></a></li>
<li><a href='#utils.assignment'><p>Population assignment probabilities</p></a></li>
<li><a href='#utils.assignment_2'><p>Population assignment probabilities</p></a></li>
<li><a href='#utils.assignment_3'><p>Population assignment probabilities</p></a></li>
<li><a href='#utils.assignment_4'><p>Population assignment probabilities</p></a></li>
<li><a href='#zzz'><p>Setting up the package dartR.popgenomics</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysing 'SNP' Data to Support Captive Breeding</td>
</tr>
<tr>
<td>Version:</td>
<td>0.75</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-27</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions are provided that facilitate the analysis of SNP 
    (single nucleotide polymorphism) data to answer questions regarding 
    captive breeding and relatedness between individuals. 'dartR.captive' 
    is part of the 'dartRverse' suit of packages.
    Gruber et al. (2018) &lt;<a href="https://doi.org/10.1111%2F1755-0998.12745">doi:10.1111/1755-0998.12745</a>&gt;.
    Mijangos et al. (2022) &lt;<a href="https://doi.org/10.1111%2F2041-210X.13918">doi:10.1111/2041-210X.13918</a>&gt;.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5), adegenet (&ge; 2.0.0), dartR.base, dartR.data</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, utils, crayon, ggplot2, patchwork, stringr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>SIBER, gplots, fields, igraph, reshape2, rrBLUP, scales,
spelling</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-27 01:11:27 UTC; s425824</td>
</tr>
<tr>
<td>Author:</td>
<td>Bernd Gruber [aut, cre],
  Arthur Georges [aut],
  Jose L. Mijangos [aut],
  Carlo Pacioni [aut],
  Peter J. Unmack [ctb],
  Oliver Berry [ctb],
  Lindsay V. Clark [ctb],
  Floriaan Devloo-Delva [ctb],
  Eric Archer [ctb]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://green-striped-gecko.github.io/dartR/">https://green-striped-gecko.github.io/dartR/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://groups.google.com/g/dartr?pli=1">https://groups.google.com/g/dartr?pli=1</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bernd Gruber &lt;bernd.gruber@canberra.edu.au&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-27 17:10:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='gl.assign.grm'>Population assignment using grm</h2><span id='topic+gl.assign.grm'></span>

<h3>Description</h3>

<p>This function takes one individual and estimates
their probability of coming from individual populations
from multilocus genotype frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gl.assign.grm(x, unknown, verbose = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gl.assign.grm_+3A_x">x</code></td>
<td>
<p>Name of the genlight object containing the SNP data [required].</p>
</td></tr>
<tr><td><code id="gl.assign.grm_+3A_unknown">unknown</code></td>
<td>
<p>Name of the individual to be assigned to a population [required].</p>
</td></tr>
<tr><td><code id="gl.assign.grm_+3A_verbose">verbose</code></td>
<td>
<p>Verbosity: 0, silent or fatal errors; 1, begin and end; 2,
progress log; 3, progress and results summary; 5, full report
[default 2, unless specified using gl.set.verbosity].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a re-implementation of the function multilocus_assignment
from package gstudio.
Description of the method used in this function can be found at:
https://dyerlab.github.io/applied_population_genetics/population-assignment.html
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> consisting of assignment probabilities for each
population.
</p>


<h3>Author(s)</h3>

<p>Custodian: Luis Mijangos &ndash; Post to
<a href="https://groups.google.com/d/forum/dartr">https://groups.google.com/d/forum/dartr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require("dartR.data")
if ((requireNamespace("rrBLUP", quietly = TRUE)) &amp; (requireNamespace("gplots", quietly = TRUE))) {
  res &lt;- gl.assign.grm(platypus.gl, unknown = "T27")
}
</code></pre>

<hr>
<h2 id='gl.assign.mahalanobis'>Assign an individual of unknown provenance to population based on
Mahalanobis Distance</h2><span id='topic+gl.assign.mahalanobis'></span>

<h3>Description</h3>

<p>This script assigns an individual of unknown provenance to one or more target
populations based on the unknown individual's proximity to population
centroids; proximity is estimated using Mahalanobis Distance.
</p>
<p>The following process is followed:
</p>

<ol>
<li><p> An ordination is undertaken on the populations to again yield a
series of orthogonal (independent) axes.
</p>
</li>
<li><p> A workable subset of dimensions is chosen, that specified, or
equal to the number of dimensions with substantive eigenvalues, whichever is
the smaller.
</p>
</li>
<li><p> The Mahalobalis Distance is calculated for the unknown against each
population and probability of membership of each population is calculated.
The assignment probabilities are listed in support of a decision.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>gl.assign.mahalanobis(
  x,
  dim.limit = 2,
  plevel = 0.999,
  plot.out = TRUE,
  unknown,
  verbose = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gl.assign.mahalanobis_+3A_x">x</code></td>
<td>
<p>Name of the input genlight object [required].</p>
</td></tr>
<tr><td><code id="gl.assign.mahalanobis_+3A_dim.limit">dim.limit</code></td>
<td>
<p>Maximum number of dimensions to consider for the
confidence ellipses [default 2]</p>
</td></tr>
<tr><td><code id="gl.assign.mahalanobis_+3A_plevel">plevel</code></td>
<td>
<p>Probability level for bounding ellipses
[default 0.999].</p>
</td></tr>
<tr><td><code id="gl.assign.mahalanobis_+3A_plot.out">plot.out</code></td>
<td>
<p>If TRUE, produces a plot showing the position of the
unknown in relation to putative source populations [default TRUE]</p>
</td></tr>
<tr><td><code id="gl.assign.mahalanobis_+3A_unknown">unknown</code></td>
<td>
<p>Identity label of the focal individual whose provenance is
unknown [required].</p>
</td></tr>
<tr><td><code id="gl.assign.mahalanobis_+3A_verbose">verbose</code></td>
<td>
<p>Verbosity: 0, silent or fatal errors; 1, begin and end; 2,
progress log; 3, progress and results summary; 5, full report
[default 2 or as specified using gl.set.verbosity].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are three considerations to assignment. First, consider only those
populations for which the unknown has no private alleles. Private alleles are
an indication that the unknown does not belong to a target population
(provided that the sample size is adequate, say &gt;=10). This can be evaluated
with gl.assign.pa().
</p>
<p>A next step is to consider the PCoA plot for populations where no private
alleles have been detected. The position of the unknown in relation to the
confidence ellipses is plotted by this script as a basis for narrowing down
the list of putative source populations. This can be evaluated with
gl.assign.pca().
</p>
<p>The third step (delivered by this script) is to consider the assignment
probabilities based on the squared Generalised Linear Distance
(Mahalanobis distance) of the unknown from the centroid for each population,
then to consider the probability associated with its quantile using the
Chisquare approximation. In effect, this index takes into account position
of the unknown in relation to the confidence envelope in all selected
dimensions of the ordination. The larger the assignment probability,
the greater the confidence in the assignment.
</p>
<p>If dim.limit is set to 2, to correspond with the dimensions used in
gl.assign.pa(), then the output provides a ranking of the final set
of putative source populations.
</p>
<p>If dim.limit is set to be &gt; 2, then this script provides a basis for
further narrowing the set of putative populations.If the unknown individual
is an extreme outlier, say at less than 0.001 probability of population
membership (0.999 confidence envelope), then the associated population
can be eliminated from further consideration.
</p>
<p>Warning: gl.assign.mahal() treats each specified dimension equally, without
regard to the percentage variation explained after ordination. If the
unknown is an outlier in a lower dimension with an explanatory variance of,
say, 0.1
dimensions from the ordination.
</p>
<p>Each of these above approaches provides evidence, none are 100
They need to be interpreted cautiously.
</p>
<p>In deciding the assignment, the script considers an individual to be an
outlier with respect to a particular population at alpha = 0.001 as default
</p>


<h3>Value</h3>

<p>A data frame with the results of the assignment analysis.
</p>


<h3>Author(s)</h3>

<p>Custodian: Arthur Georges &ndash;
Post to <a href="https://groups.google.com/d/forum/dartr">https://groups.google.com/d/forum/dartr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Test run with a focal individual from the Macleay River (EmmacMaclGeor)
test &lt;- gl.assign.pa(testset.gl,
  unknown = "UC_01044", nmin = 10, threshold = 1 )
test_2 &lt;- gl.assign.pca(test, unknown = "UC_01044", plevel = 0.95)
df &lt;- gl.assign.mahalanobis(test_2, unknown = "UC_01044")
</code></pre>

<hr>
<h2 id='gl.assign.pa'>Eliminates populations as possible source populations for an
individual of unknown provenance, using private alleles</h2><span id='topic+gl.assign.pa'></span>

<h3>Description</h3>

<p>This script eliminates from consideration as putative source populations,
those populations for which the individual has too many private alleles. The
populations that remain are putative source populations, subject to further
consideration.
</p>
<p>The algorithm identifies those target populations for which the individual
has no private alleles or for which the number of private alleles does not
exceed a user specified threshold.
</p>
<p>An excessive count of private alleles is an indication that the unknown does
not belong to a target population (provided that the sample size is
adequate, say &gt;=10).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gl.assign.pa(
  x,
  unknown,
  nmin = 10,
  threshold = 0,
  n.best = NULL,
  verbose = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gl.assign.pa_+3A_x">x</code></td>
<td>
<p>Name of the input genlight object [required].</p>
</td></tr>
<tr><td><code id="gl.assign.pa_+3A_unknown">unknown</code></td>
<td>
<p>SpecimenID label (indName) of the focal individual whose
provenance is unknown [required].</p>
</td></tr>
<tr><td><code id="gl.assign.pa_+3A_nmin">nmin</code></td>
<td>
<p>Minimum sample size for a target population to be included in the
analysis [default 10].</p>
</td></tr>
<tr><td><code id="gl.assign.pa_+3A_threshold">threshold</code></td>
<td>
<p>Populations to retain for consideration; those for which the
focal individual has less than or equal to threshold loci with private
alleles [default 0].</p>
</td></tr>
<tr><td><code id="gl.assign.pa_+3A_n.best">n.best</code></td>
<td>
<p>If given a value, dictates the best n=n.best populations to
retain for consideration (or more if their are ties) based on private alleles
[default NULL].</p>
</td></tr>
<tr><td><code id="gl.assign.pa_+3A_verbose">verbose</code></td>
<td>
<p>Verbosity: 0, silent or fatal errors; 1, begin and end; 2,
progress log; 3, progress and results summary; 5, full report
[default 2 or as specified using gl.set.verbosity].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A genlight object containing the focal individual (assigned to
population 'unknown') and populations for which the focal individual is not
distinctive (number of loci with private alleles less than or equal to the
threshold). If no such populations, the genlight object contains only data
for the unknown individual.
</p>


<h3>Author(s)</h3>

<p>Custodian: Arthur Georges &ndash; Post to
<a href="https://groups.google.com/d/forum/dartr">https://groups.google.com/d/forum/dartr</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gl.assign.pca">gl.assign.pca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Test run with a focal individual from the Macleay River (EmmacMaclGeor)
test &lt;- gl.assign.pa(testset.gl,
  unknown = "UC_00146", nmin = 10, threshold = 1)

</code></pre>

<hr>
<h2 id='gl.assign.pca'>Assign an individual of unknown provenance to population based on PCA</h2><span id='topic+gl.assign.pca'></span>

<h3>Description</h3>

<p>This script assigns an individual of unknown provenance to one or more target
populations based on its proximity to each population defined by a
confidence ellipse in ordinated space of two dimensions.
</p>
<p>The following process is followed:
</p>

<ol>
<li><p> The space defined by the loci is ordinated to yield a series of
orthogonal axes (independent), and the top two dimensions are considered.
Populations for which the unknown lies outside the specified confidence
limits are no longer removed from the dataset.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>gl.assign.pca(x, unknown, plevel = 0.999, plot.out = TRUE, verbose = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gl.assign.pca_+3A_x">x</code></td>
<td>
<p>Name of the input genlight object [required].</p>
</td></tr>
<tr><td><code id="gl.assign.pca_+3A_unknown">unknown</code></td>
<td>
<p>Identity label of the focal individual whose provenance is
unknown [required].</p>
</td></tr>
<tr><td><code id="gl.assign.pca_+3A_plevel">plevel</code></td>
<td>
<p>Probability level for bounding ellipses in the PCoA plot
[default 0.999].</p>
</td></tr>
<tr><td><code id="gl.assign.pca_+3A_plot.out">plot.out</code></td>
<td>
<p>If TRUE, plot the 2D PCA showing the position
of the unknown [default TRUE]</p>
</td></tr>
<tr><td><code id="gl.assign.pca_+3A_verbose">verbose</code></td>
<td>
<p>Verbosity: 0, silent or fatal errors; 1, begin and end; 2,
progress log; 3, progress and results summary; 5, full report
[default 2 or as specified using gl.set.verbosity].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are three considerations to assignment. First, consider only those
populations for which the unknown has no private alleles. Private alleles are
an indication that the unknown does not belong to a target population
(provided that the sample size is adequate, say &gt;=10). This can be evaluated
with gl.assign.pa().
</p>
<p>A next step is to consider the PCoA plot for populations where no private
alleles have been detected and the position of the unknown in relation to the
confidence ellipses as is plotted by this script. Note, this plot is
considering only the top two dimensions of the ordination, and so an unknown
lying outside the confidence ellipse can be unambiguously interpreted as it
lying outside the confidence envelope. However, if the unknown lies inside
the confidence ellipse in two dimensions, then it may still lie outside the
confidence envelope in deeper dimensions. This second step is good for
eliminating populations from consideration, but does not provide confidence
in assignment.
</p>
<p>The third step is to consider the assignment probabilities, using the script
gl.assign.mahalanobis(). This approach calculates the squared Generalised
Linear Distance (Mahalanobis distance) of the unknown from the centroid
for each population, and calculates the probability associated with its
quantile under the zero truncated normal distribution. This index takes
into account position of the unknown in relation to the confidence envelope
in all selected dimensions of the ordination.
</p>
<p>Each of these approaches provides evidence, none are 100
need to be interpreted cautiously. They are best applied sequentially.
</p>
<p>In deciding the assignment, the script considers an individual to be an
outlier with respect to a particular population at alpha = 0.001 as default.
</p>


<h3>Value</h3>

<p>A genlight object containing only those populations that are
putative source populations for the unknown individual.
</p>


<h3>Author(s)</h3>

<p>Custodian: Arthur Georges &ndash; Post to
<a href="https://groups.google.com/d/forum/dartr">https://groups.google.com/d/forum/dartr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Test run with a focal individual from the Macleay River (EmmacMaclGeor)
test &lt;- gl.assign.pa(testset.gl,
  unknown = "UC_00146", nmin = 10, threshold = 1,
  verbose = 3
)
test_2 &lt;- gl.assign.pca(test, unknown = "UC_00146", plevel = 0.95, verbose = 3)

</code></pre>

<hr>
<h2 id='gl.filter.parent.offspring'>Filters putative parent offspring within a population</h2><span id='topic+gl.filter.parent.offspring'></span>

<h3>Description</h3>

<p>This script removes individuals suspected of being related as
parent-offspring,using the output of the function
<code><a href="#topic+gl.report.parent.offspring">gl.report.parent.offspring</a></code>, which examines the frequency of
pedigree inconsistent loci, that is, those loci that are homozygotes in the
parent for the reference allele, and homozygous in the offspring for the
alternate allele. This condition is not consistent with any pedigree,
regardless of the (unknown) genotype of the other parent.
The pedigree inconsistent loci are counted as an indication of whether or not
it is reasonable to propose the two individuals are in a parent-offspring
relationship.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gl.filter.parent.offspring(
  x,
  min.rdepth = 12,
  min.reproducibility = 1,
  range = 1.5,
  method = "best",
  rm.monomorphs = FALSE,
  plot_theme = theme_dartR(),
  plot_colors = gl.colors(2),
  plot.file = NULL,
  plot.dir = NULL,
  verbose = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gl.filter.parent.offspring_+3A_x">x</code></td>
<td>
<p>Name of the genlight object containing the SNP genotypes [required].</p>
</td></tr>
<tr><td><code id="gl.filter.parent.offspring_+3A_min.rdepth">min.rdepth</code></td>
<td>
<p>Minimum read depth to include in analysis [default 12].</p>
</td></tr>
<tr><td><code id="gl.filter.parent.offspring_+3A_min.reproducibility">min.reproducibility</code></td>
<td>
<p>Minimum reproducibility to include in analysis
[default 1].</p>
</td></tr>
<tr><td><code id="gl.filter.parent.offspring_+3A_range">range</code></td>
<td>
<p>Specifies the range to extend beyond the interquartile range for
delimiting outliers [default 1.5 interquartile ranges].</p>
</td></tr>
<tr><td><code id="gl.filter.parent.offspring_+3A_method">method</code></td>
<td>
<p>Method of selecting the individual to retain from each pair of
parent offspring relationship, 'best' (based on CallRate) or 'random'
[default 'best'].</p>
</td></tr>
<tr><td><code id="gl.filter.parent.offspring_+3A_rm.monomorphs">rm.monomorphs</code></td>
<td>
<p>If TRUE, remove monomorphic loci after filtering
individuals [default FALSE].</p>
</td></tr>
<tr><td><code id="gl.filter.parent.offspring_+3A_plot_theme">plot_theme</code></td>
<td>
<p>Theme for the plot. See Details for options
[default theme_dartR()].</p>
</td></tr>
<tr><td><code id="gl.filter.parent.offspring_+3A_plot_colors">plot_colors</code></td>
<td>
<p>List of two color names for the borders and fill of the
plots [default gl.colors(2)].</p>
</td></tr>
<tr><td><code id="gl.filter.parent.offspring_+3A_plot.file">plot.file</code></td>
<td>
<p>Name for the RDS binary file to save (base name only, exclude extension) [default NULL]</p>
</td></tr>
<tr><td><code id="gl.filter.parent.offspring_+3A_plot.dir">plot.dir</code></td>
<td>
<p>Directory to save the plot RDS files [default as specified
by the global working directory or tempdir()]</p>
</td></tr>
<tr><td><code id="gl.filter.parent.offspring_+3A_verbose">verbose</code></td>
<td>
<p>Verbosity: 0, silent or fatal errors; 1, begin and end; 2,
progress log ; 3, progress and results summary; 5, full report
[default 2, unless specified using gl.set.verbosity].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If two individuals are in a parent offspring relationship, the true number of
pedigree inconsistent loci should be zero, but SNP calling is not infallible.
Some loci will be miss-called. The problem thus becomes one of determining if
the two focal individuals have a count of pedigree inconsistent loci less
than would be expected of typical unrelated individuals. There are some quite
sophisticated software packages available to formally apply likelihoods to
the decision, but we use a simple outlier comparison.
To reduce the frequency of miss-calls, and so emphasize the difference
between true parent-offspring pairs and unrelated pairs, the data can be
filtered on read depth. Typically minimum read depth is set to 5x, but you
can examine the distribution of read depths with the function
<code><a href="dartR.base.html#topic+gl.report.rdepth">gl.report.rdepth</a></code> and push this up with an acceptable loss of
loci. 12x might be a good minimum for this particular analysis. It is
sensible also to push the minimum reproducibility up to 1, if that does not
result in an unacceptable loss of loci. Reproducibility is stored in the slot
<code>@other$loc.metrics$RepAvg</code> and is defined as the proportion of
technical replicate assay pairs for which the marker score is consistent.
You can examine the distribution of reproducibility with the function
<code><a href="dartR.base.html#topic+gl.report.reproducibility">gl.report.reproducibility</a></code>.
Note that the null expectation is not well defined, and the power reduced, if
the population from which the putative parent-offspring pairs are drawn
contains many sibs. Note also that if an individual has been genotyped twice
in the dataset, the replicate pair will be assessed by this script as being
in a parent-offspring relationship.
You should run <code><a href="#topic+gl.report.parent.offspring">gl.report.parent.offspring</a></code> before filtering. Use
this report to decide min.rdepth and min.reproducibility and assess impact on
your dataset.
Note that if your dataset does not contain RepAvg or rdepth among the locus
metrics, the filters for reproducibility and read depth are no used.
Examples of other themes that can be used can be consulted in </p>

<ul>
<li> <p><a href="https://ggplot2.tidyverse.org/reference/ggtheme.html">https://ggplot2.tidyverse.org/reference/ggtheme.html</a> and </p>
</li>
<li>
<p><a href="https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/">https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/</a>
</p>
</li></ul>



<h3>Value</h3>

<p>the filtered genlight object without A set of individuals in
parent-offspring relationship. NULL if no parent-offspring relationships were
found.
</p>


<h3>Author(s)</h3>

<p>Custodian: Arthur Georges &ndash; Post to
<a href="https://groups.google.com/d/forum/dartr">https://groups.google.com/d/forum/dartr</a>
</p>


<h3>See Also</h3>

<p><code><a href="dartR.base.html#topic+gl.report.rdepth">gl.report.rdepth</a></code> , <code><a href="dartR.base.html#topic+gl.report.reproducibility">gl.report.reproducibility</a></code>,
<code><a href="#topic+gl.report.parent.offspring">gl.report.parent.offspring</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- gl.filter.parent.offspring(testset.gl[1:10, 1:50])
</code></pre>

<hr>
<h2 id='gl.grm'>Calculates an identity by descent matrix</h2><span id='topic+gl.grm'></span>

<h3>Description</h3>

<p>This function calculates the mean probability of identity by state (IBS)
across loci that would result from all the possible crosses of the
individuals analyzed. IBD is calculated by an additive relationship matrix
approach developed by Endelman and Jannink (2012) as implemented in the
function <a href="rrBLUP.html#topic+A.mat">A.mat</a> (package rrBLUP).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gl.grm(
  x,
  plotheatmap = TRUE,
  palette_discrete = NULL,
  palette_convergent = NULL,
  legendx = 0,
  legendy = 0.5,
  plot.file = NULL,
  plot.dir = NULL,
  verbose = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gl.grm_+3A_x">x</code></td>
<td>
<p>Name of the genlight object containing the SNP data [required].</p>
</td></tr>
<tr><td><code id="gl.grm_+3A_plotheatmap">plotheatmap</code></td>
<td>
<p>A switch if a heatmap should be shown [default TRUE].</p>
</td></tr>
<tr><td><code id="gl.grm_+3A_palette_discrete">palette_discrete</code></td>
<td>
<p>the color of populations [gl.select.colors].</p>
</td></tr>
<tr><td><code id="gl.grm_+3A_palette_convergent">palette_convergent</code></td>
<td>
<p>A convergent palette for the IBD values
[default convergent_palette].</p>
</td></tr>
<tr><td><code id="gl.grm_+3A_legendx">legendx</code></td>
<td>
<p>x coordinates for the legend[default 0].</p>
</td></tr>
<tr><td><code id="gl.grm_+3A_legendy">legendy</code></td>
<td>
<p>y coordinates for the legend[default 1].</p>
</td></tr>
<tr><td><code id="gl.grm_+3A_plot.file">plot.file</code></td>
<td>
<p>Name for the RDS binary file to save (base name only, exclude extension) [default NULL]</p>
</td></tr>
<tr><td><code id="gl.grm_+3A_plot.dir">plot.dir</code></td>
<td>
<p>Directory in which to save files [default = working directory]</p>
</td></tr>
<tr><td><code id="gl.grm_+3A_verbose">verbose</code></td>
<td>
<p>Verbosity: 0, silent or fatal errors; 1, begin and end; 2,
progress log ; 3, progress and results summary; 5, full report
[default 2 or as specified using gl.set.verbosity].</p>
</td></tr>
<tr><td><code id="gl.grm_+3A_...">...</code></td>
<td>
<p>Parameters passed to function A.mat from package rrBLUP.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two or more alleles are identical by descent (IBD) if they are identical
copies of the same ancestral allele in a base population. The additive
relationship matrix is a theoretical framework for estimating a relationship
matrix that is consistent with an approach to estimate the probability that
the alleles at a random locus are identical in state (IBS).
</p>
<p>This function also plots a heatmap, and a dendrogram, of IBD values where
each diagonal element has a mean that equals 1+f, where f is the inbreeding
coefficient (i.e. the probability that the two alleles at a randomly chosen
locus are IBD from the base population). As this probability lies between 0
and 1, the diagonal elements range from 1 to 2. Because the inbreeding
coefficients are expressed relative to the current population, the mean of
the off-diagonal elements is -(1+f)/n, where n is the number of loci.
Individual names are shown in the margins of the heatmap and colors
represent different populations.
</p>


<h3>Value</h3>

<p>An identity by descent matrix
</p>


<h3>Author(s)</h3>

<p>Custodian: Arthur Georges &ndash; Post to
<a href="https://groups.google.com/d/forum/dartr">https://groups.google.com/d/forum/dartr</a>
</p>


<h3>References</h3>


<ul>
<li><p> Endelman, J. B. (2011). Ridge regression and other kernels for genomic
selection with r package rrblup. The Plant Genome 4, 250.
</p>
</li>
<li><p> Endelman, J. B. , Jannink, J.-L. (2012). Shrinkage estimation of the
realized relationship matrix. G3: Genes, Genomics, Genetics 2, 1405.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+gl.grm.network">gl.grm.network</a></code>
</p>
<p>Other inbreeding functions: 
<code><a href="#topic+gl.grm.network">gl.grm.network</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gl.grm(platypus.gl[1:10, 1:100])

</code></pre>

<hr>
<h2 id='gl.grm.network'>Represents a genomic relationship matrix (GRM) as a network</h2><span id='topic+gl.grm.network'></span>

<h3>Description</h3>

<p>This script takes a G matrix generated by <code><a href="#topic+gl.grm">gl.grm</a></code> and represents
the relationship among the specimens as a network diagram. In order to use
this script, a decision is required on a threshold for relatedness to be
represented as link in the network, and on the layout used to create the
diagram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gl.grm.network(
  G,
  x,
  method = "fr",
  node.size = 8,
  node.label = TRUE,
  node.label.size = 2,
  node.label.color = "black",
  link.color = NULL,
  link.size = 2,
  relatedness_factor = 0.125,
  title = "Network based on a genomic relationship matrix",
  palette_discrete = gl.select.colors(x, library = "brewer", palette = "PuOr", ncolors =
    nPop(x), verbose = 0),
  plot.dir = NULL,
  plot.file = NULL,
  verbose = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gl.grm.network_+3A_g">G</code></td>
<td>
<p>A genomic relationship matrix (GRM) generated by
<code><a href="#topic+gl.grm">gl.grm</a></code> [required].</p>
</td></tr>
<tr><td><code id="gl.grm.network_+3A_x">x</code></td>
<td>
<p>A genlight object from which the G matrix was generated [required].</p>
</td></tr>
<tr><td><code id="gl.grm.network_+3A_method">method</code></td>
<td>
<p>One of 'fr', 'kk', 'gh' or 'mds' [default 'fr'].</p>
</td></tr>
<tr><td><code id="gl.grm.network_+3A_node.size">node.size</code></td>
<td>
<p>Size of the symbols for the network nodes [default 8].</p>
</td></tr>
<tr><td><code id="gl.grm.network_+3A_node.label">node.label</code></td>
<td>
<p>TRUE to display node labels [default TRUE].</p>
</td></tr>
<tr><td><code id="gl.grm.network_+3A_node.label.size">node.label.size</code></td>
<td>
<p>Size of the node labels [default 3].</p>
</td></tr>
<tr><td><code id="gl.grm.network_+3A_node.label.color">node.label.color</code></td>
<td>
<p>Color of the text of the node labels
[default 'black'].</p>
</td></tr>
<tr><td><code id="gl.grm.network_+3A_link.color">link.color</code></td>
<td>
<p>Colors for links [default gl.select.colors].</p>
</td></tr>
<tr><td><code id="gl.grm.network_+3A_link.size">link.size</code></td>
<td>
<p>Size of the links [default 2].</p>
</td></tr>
<tr><td><code id="gl.grm.network_+3A_relatedness_factor">relatedness_factor</code></td>
<td>
<p>Factor of relatedness [default 0.125].</p>
</td></tr>
<tr><td><code id="gl.grm.network_+3A_title">title</code></td>
<td>
<p>Title for the plot
[default 'Network based on genomic relationship matrix'].</p>
</td></tr>
<tr><td><code id="gl.grm.network_+3A_palette_discrete">palette_discrete</code></td>
<td>
<p>A discrete set of colors
with as many colors as there are populations in the dataset
[default NULL].</p>
</td></tr>
<tr><td><code id="gl.grm.network_+3A_plot.dir">plot.dir</code></td>
<td>
<p>Directory to save the plot RDS files [default as specified
by the global working directory or tempdir()]</p>
</td></tr>
<tr><td><code id="gl.grm.network_+3A_plot.file">plot.file</code></td>
<td>
<p>Name for the RDS binary file to save (base name only, exclude extension) [default NULL]</p>
</td></tr>
<tr><td><code id="gl.grm.network_+3A_verbose">verbose</code></td>
<td>
<p>Verbosity: 0, silent or fatal errors; 1, begin and end; 2,
progress log ; 3, progress and results summary; 5, full report
[default 2 or as specified using gl.set.verbosity].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The gl.grm.network function takes a genomic relationship matrix (GRM)
generated by the gl.grm function to represent the relationship among
individuals in the dataset as a network diagram. To generate the GRM, the
function gl.grm uses the function A.mat from package rrBLUP, which implements
the approach developed by Endelman and Jannink (2012).
</p>
<p>The GRM is an estimate of the proportion of alleles that two individuals have
in common. It is generated by estimating the covariance of the genotypes
between two individuals, i.e. how much genotypes in the two individuals
correspond with each other. This covariance depends on the probability that
alleles at a random locus are identical by state (IBS). Two alleles are
IBS if they represent the same allele. Two alleles are identical by
descent (IBD) if one is a physical copy of the other or if they are both
physical copies of the same ancestral allele. Note that IBD is complicated
to determine. IBD implies IBS, but not conversely. However, as the number
of SNPs in a dataset increases, the mean probability of IBS approaches
the mean probability of IBD.
</p>
<p>It follows that the off-diagonal elements of the GRM are two times the
kinship coefficient, i.e. the probability that two alleles at a random locus
drawn from two individuals are IBD. Additionally, the diagonal elements of
the GRM are 1+f, where f is the inbreeding coefficient of each individual,
i.e. the probability that the two alleles at a random locus are IBD.
</p>
<p>Choosing a meaningful threshold to represent the relationship between
individuals is tricky because IBD is not an absolute state but is relative to
a reference population for which there is generally little information so
that we can estimate the kinship of a pair of individuals only relative to
some other quantity. To deal with this, we can use the average inbreeding
coefficient of the diagonal elements as the reference value. For this, the
function subtracts 1 from the mean of the diagonal elements of the GRM. In a
second step, the off-diagonal elements are divided by 2, and finally, the
mean of the diagonal elements is subtracted from each off-diagonal element
after dividing them by 2. This approach is similar to the one used by
Goudet et al. (2018).
</p>
<p>Below is a table modified from Speed &amp; Balding (2015) showing kinship values,
and their confidence intervals (CI), for different relationships that could
be used to guide the choosing of the relatedness threshold in the function.
</p>
<p>|Relationship|Kinship|95
|Identical twins/clones/same individual     | 0.5     |        -         |
</p>
<p>|Sibling/Parent-Offspring                   | 0.25    |    (0.204, 0.296)|
</p>
<p>|Half-sibling                               | 0.125   |    (0.092, 0.158)|
</p>
<p>|First cousin                               | 0.062   |    (0.038, 0.089)|
</p>
<p>|Half-cousin                                | 0.031   |    (0.012, 0.055)|
</p>
<p>|Second cousin                              | 0.016   |    (0.004, 0.031)|
</p>
<p>|Half-second cousin                         | 0.008   |    (0.001, 0.020)|
</p>
<p>|Third cousin                               | 0.004   |    (0.000, 0.012)|
</p>
<p>|Unrelated                                  | 0       |        -         |
</p>
<p>Four layout options are implemented in this function:
</p>

<ul>
<li><p> 'fr' Fruchterman-Reingold layout  <a href="igraph.html#topic+layout_with_fr">layout_with_fr</a>
(package igraph)
</p>
</li>
<li><p> 'kk' Kamada-Kawai layout <a href="igraph.html#topic+layout_with_kk">layout_with_kk</a> (package igraph)
</p>
</li>
<li><p> 'gh' Graphopt layout <a href="igraph.html#topic+layout_with_graphopt">layout_with_graphopt</a>
(package igraph)
</p>
</li>
<li><p> 'mds' Multidimensional scaling layout <a href="igraph.html#topic+layout_with_mds">layout_with_mds</a>
(package igraph)
</p>
</li></ul>



<h3>Value</h3>

<p>A network plot showing relatedness between individuals
</p>


<h3>Author(s)</h3>

<p>Custodian: Arthur Georges &ndash; Post to
<a href="https://groups.google.com/d/forum/dartr">https://groups.google.com/d/forum/dartr</a>
</p>


<h3>References</h3>


<ul>
<li><p> Endelman, J. B. , Jannink, J.-L. (2012). Shrinkage estimation of the
realized relationship matrix. G3: Genes, Genomics, Genetics 2, 1405.
</p>
</li>
<li><p> Goudet, J., Kay, T., &amp; Weir, B. S. (2018). How to estimate kinship.
Molecular Ecology, 27(20), 4121-4135.
</p>
</li>
<li><p> Speed, D., &amp; Balding, D. J. (2015). Relatedness in the post-genomic era:
is it still useful?. Nature Reviews Genetics, 16(1), 33-44.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+gl.grm">gl.grm</a></code>
</p>
<p>Other inbreeding functions: 
<code><a href="#topic+gl.grm">gl.grm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("igraph", quietly = TRUE) &amp; requireNamespace("rrBLUP",
  quietly = TRUE
) &amp; requireNamespace("fields", quietly = TRUE)) {
  t1 &lt;- possums.gl
  # filtering on call rate
  t1 &lt;- gl.filter.callrate(t1)
  t1 &lt;- gl.subsample.loc(t1, n = 100)
  # relatedness matrix
  res &lt;- gl.grm(t1, plotheatmap = FALSE)
  # relatedness network
  res2 &lt;- gl.grm.network(res, t1, relatedness_factor = 0.125)
}
</code></pre>

<hr>
<h2 id='gl.plot.network'>Represents a distance or dissimilarity matrix as a network</h2><span id='topic+gl.plot.network'></span>

<h3>Description</h3>

<p>This script takes a distance matrix generated by dist() and represents the
relationship among the specimens as a network diagram. In order to use this
script, a decision is required on a threshold for relatedness to be
represented as link in the network, and on the layout used to create the
diagram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gl.plot.network(
  D,
  x = NULL,
  method = "fr",
  node.size = 3,
  node.label = FALSE,
  node.label.size = 0.7,
  node.label.color = "black",
  alpha = 0.005,
  title = "Network based on genetic distance",
  verbose = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gl.plot.network_+3A_d">D</code></td>
<td>
<p>A distance or dissimilarity matrix generated by dist() or gl.dist()
[required].</p>
</td></tr>
<tr><td><code id="gl.plot.network_+3A_x">x</code></td>
<td>
<p>A genlight object from which the D matrix was generated
[default NULL].</p>
</td></tr>
<tr><td><code id="gl.plot.network_+3A_method">method</code></td>
<td>
<p>One of &quot;fr&quot;, &quot;kk&quot; or &quot;drl&quot; [default &quot;fr&quot;].</p>
</td></tr>
<tr><td><code id="gl.plot.network_+3A_node.size">node.size</code></td>
<td>
<p>Size of the symbols for the network nodes [default 3].</p>
</td></tr>
<tr><td><code id="gl.plot.network_+3A_node.label">node.label</code></td>
<td>
<p>TRUE to display node labels [default FALSE].</p>
</td></tr>
<tr><td><code id="gl.plot.network_+3A_node.label.size">node.label.size</code></td>
<td>
<p>Size of the node labels [default 0.7].</p>
</td></tr>
<tr><td><code id="gl.plot.network_+3A_node.label.color">node.label.color</code></td>
<td>
<p>Color of the text of the node labels
[default 'black'].</p>
</td></tr>
<tr><td><code id="gl.plot.network_+3A_alpha">alpha</code></td>
<td>
<p>Upper threshold to determine which links between nodes to display
[default 0.005].</p>
</td></tr>
<tr><td><code id="gl.plot.network_+3A_title">title</code></td>
<td>
<p>Title for the plot
[default &quot;Network based on genetic distance&quot;].</p>
</td></tr>
<tr><td><code id="gl.plot.network_+3A_verbose">verbose</code></td>
<td>
<p>Verbosity: 0, silent or fatal errors; 1, begin and end; 2,
progress log; 3, progress and results summary; 5, full report
[default 2, unless specified using gl.set.verbosity].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The threshold for relatedness to be represented as a link in the network is
specified as a quantile. Those relatedness measures above the quantile are
plotted as links, those below the quantile are not. Often you are looking for
relatedness outliers in comparison with the overall relatedness among
individuals, so a very conservative quantile is used (e.g. 0.004), but
ultimately, this decision is made as a matter of trial and error. One way to
approach this trial and error is to try to achieve a sparse set of links
between unrelated 'background' individuals so that the stronger links are
preferentially shown.
</p>
<p>There are several layouts from which to choose. The most popular are given as
options in this script.
</p>

<ul>
<li><p> fr &ndash; Fruchterman, T.M.J. and Reingold, E.M. (1991). Graph Drawing by
Force-directed Placement. Software &ndash; Practice and Experience 21:1129-1164.
</p>
</li>
<li><p> kk &ndash; Kamada, T. and Kawai, S.: An Algorithm for Drawing General
Undirected Graphs. Information Processing Letters 31:7-15, 1989.
</p>
</li>
<li><p> drl &ndash; Martin, S., Brown, W.M., Klavans, R., Boyack, K.W., DrL:
Distributed Recursive (Graph) Layout. SAND Reports 2936:1-10, 2008.
</p>
</li></ul>

<p>Colors of node symbols are those of the rainbow.
</p>


<h3>Value</h3>

<p>returns no value (i.e. NULL)
</p>


<h3>Author(s)</h3>

<p>Custodian: Arthur Georges &ndash; Post to
<a href="https://groups.google.com/d/forum/dartr">https://groups.google.com/d/forum/dartr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if ((requireNamespace("rrBLUP", quietly = TRUE)) &amp; (requireNamespace("gplots", quietly = TRUE))) {
  test &lt;- gl.subsample.loc(platypus.gl, n = 100)
  test &lt;- gl.keep.ind(test, ind.list = indNames(test)[1:10])
  D &lt;- gl.grm(test, legendx = 0.04)
  gl.plot.network(D, test)
}
</code></pre>

<hr>
<h2 id='gl.report.parent.offspring'>Identifies putative parent offspring within a population</h2><span id='topic+gl.report.parent.offspring'></span>

<h3>Description</h3>

<p>This script examines the frequency of pedigree inconsistent loci, that is,
those loci that are homozygotes in the parent for the reference allele, and
homozygous in the offspring for the alternate allele. This condition is not
consistent with any pedigree, regardless of the (unknown) genotype of the
other parent. The pedigree inconsistent loci are counted as an indication of
whether or not it is reasonable to propose the two individuals are in a
parent-offspring relationship.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gl.report.parent.offspring(
  x,
  min.rdepth = 12,
  min.reproducibility = 1,
  range = 1.5,
  plot_theme = theme_dartR(),
  plot_colors = gl.colors(2),
  plot.dir = NULL,
  plot.file = NULL,
  verbose = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gl.report.parent.offspring_+3A_x">x</code></td>
<td>
<p>Name of the genlight object containing the SNP genotypes [required].</p>
</td></tr>
<tr><td><code id="gl.report.parent.offspring_+3A_min.rdepth">min.rdepth</code></td>
<td>
<p>Minimum read depth to include in analysis [default 12].</p>
</td></tr>
<tr><td><code id="gl.report.parent.offspring_+3A_min.reproducibility">min.reproducibility</code></td>
<td>
<p>Minimum reproducibility to include in analysis
[default 1].</p>
</td></tr>
<tr><td><code id="gl.report.parent.offspring_+3A_range">range</code></td>
<td>
<p>Specifies the range to extend beyond the interquartile range for
delimiting outliers [default 1.5 interquartile ranges].</p>
</td></tr>
<tr><td><code id="gl.report.parent.offspring_+3A_plot_theme">plot_theme</code></td>
<td>
<p>Theme for the plot. See Details for options
[default theme_dartR()].</p>
</td></tr>
<tr><td><code id="gl.report.parent.offspring_+3A_plot_colors">plot_colors</code></td>
<td>
<p>List of two color names for the borders and fill of the
plots [default gl.colors(2)].</p>
</td></tr>
<tr><td><code id="gl.report.parent.offspring_+3A_plot.dir">plot.dir</code></td>
<td>
<p>Directory to save the plot RDS files [default as specified
by the global working directory or tempdir()]</p>
</td></tr>
<tr><td><code id="gl.report.parent.offspring_+3A_plot.file">plot.file</code></td>
<td>
<p>Name for the RDS binary file to save (base name only,
exclude extension) [default NULL] Creates a plot that shows the sex linked markers.</p>
</td></tr>
<tr><td><code id="gl.report.parent.offspring_+3A_verbose">verbose</code></td>
<td>
<p>Verbosity: 0, silent or fatal errors; 1, begin and end; 2,
progress log; 3, progress and results summary; 5, full report
[default 2, unless specified using gl.set.verbosity].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If two individuals are in a parent offspring relationship, the true number of
pedigree inconsistent loci should be zero, but SNP calling is not infallible.
Some loci will be miss-called. The problem thus becomes one of determining
if the two focal individuals have a count of pedigree inconsistent loci less
than would be expected of typical unrelated individuals. There are some quite
sophisticated software packages available to formally apply likelihoods to
the decision, but we use a simple outlier comparison.
To reduce the frequency of miss-calls, and so emphasize the difference
between true parent-offspring pairs and unrelated pairs, the data can be
filtered on read depth.
Typically minimum read depth is set to 5x, but you can examine the
distribution of read depths with the function <code><a href="dartR.base.html#topic+gl.report.rdepth">gl.report.rdepth</a></code>
and push this up with an acceptable loss of loci. 12x might be a good minimum
for this particular analysis. It is sensible also to push the minimum
reproducibility up to 1, if that does not result in an unacceptable loss of
loci. Reproducibility is stored in the slot <code>@other$loc.metrics$RepAvg</code>
and is defined as the proportion of technical replicate assay pairs for which
the marker score is consistent. You can examine the distribution of
reproducibility with the function <code><a href="dartR.base.html#topic+gl.report.reproducibility">gl.report.reproducibility</a></code>.
Note that the null expectation is not well defined, and the power reduced, if
the population from which the putative parent-offspring pairs are drawn
contains many sibs. Note also that if an individual has been genotyped twice
in the dataset, the replicate pair will be assessed by this script as being
in a parent-offspring relationship.
The function <code><a href="#topic+gl.filter.parent.offspring">gl.filter.parent.offspring</a></code> will filter out those
individuals in a parent offspring relationship.
Note that if your dataset does not contain RepAvg or rdepth among the locus
metrics, the filters for reproducibility and read depth are no used.
Examples of other themes that can be used can be consulted in </p>

<ul>
<li> <p><a href="https://ggplot2.tidyverse.org/reference/ggtheme.html">https://ggplot2.tidyverse.org/reference/ggtheme.html</a> and </p>
</li>
<li>
<p><a href="https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/">https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/</a>
</p>
</li></ul>



<h3>Value</h3>

<p>A set of individuals in parent-offspring relationship. NULL if no
parent-offspring relationships were found.
</p>


<h3>Author(s)</h3>

<p>Custodian: Arthur Georges (Post to
<a href="https://groups.google.com/d/forum/dartr">https://groups.google.com/d/forum/dartr</a>)
</p>


<h3>See Also</h3>

<p><code><a href="dartR.base.html#topic+gl.report.rdepth">gl.report.rdepth</a></code> ,<code><a href="dartR.base.html#topic+gl.report.reproducibility">gl.report.reproducibility</a></code>,
<code><a href="#topic+gl.filter.parent.offspring">gl.filter.parent.offspring</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- gl.report.parent.offspring(testset.gl[1:10, 1:100])
</code></pre>

<hr>
<h2 id='gl.run.EMIBD9'>Run program EMIBD9</h2><span id='topic+gl.run.EMIBD9'></span>

<h3>Description</h3>

<p>Run program EMIBD9
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gl.run.EMIBD9(
  x,
  outfile = "EMIBD9_Res.ibd9",
  outpath = tempdir(),
  emibd9.path = getwd(),
  Inbreed = TRUE,
  ISeed = 42,
  plot.out = TRUE,
  plot.dir = NULL,
  plot.file = NULL,
  verbose = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gl.run.EMIBD9_+3A_x">x</code></td>
<td>
<p>Name of the genlight object containing the SNP data [required].</p>
</td></tr>
<tr><td><code id="gl.run.EMIBD9_+3A_outfile">outfile</code></td>
<td>
<p>A string, giving the path and name of the output file
[default &quot;EMIBD9_Res.ibd9&quot;].</p>
</td></tr>
<tr><td><code id="gl.run.EMIBD9_+3A_outpath">outpath</code></td>
<td>
<p>Path where to save the output file. Use outpath=getwd() or
outpath='.' when calling this function to direct output files to your working 
or current directory [default tempdir(), mandated by CRAN].</p>
</td></tr>
<tr><td><code id="gl.run.EMIBD9_+3A_emibd9.path">emibd9.path</code></td>
<td>
<p>Path to the folder emidb files.
Please note there are 2 different executables depending on your OS:
EM_IBD_P.exe (=Windows) EM_IBD_P (=Mac, Linux). 
You only need to pointto the folder (the function will recognise which OS you
are running) [default getwd()].</p>
</td></tr>
<tr><td><code id="gl.run.EMIBD9_+3A_inbreed">Inbreed</code></td>
<td>
<p>A Boolean, taking values 0 or 1 to indicate inbreeding is not
and is allowed in estimating IBD coefficients [default 1].</p>
</td></tr>
<tr><td><code id="gl.run.EMIBD9_+3A_iseed">ISeed</code></td>
<td>
<p>An integer used to seed the random number generator [default 42].</p>
</td></tr>
<tr><td><code id="gl.run.EMIBD9_+3A_plot.out">plot.out</code></td>
<td>
<p>A boolean that indicates whether to plot the results [default TRUE].</p>
</td></tr>
<tr><td><code id="gl.run.EMIBD9_+3A_plot.dir">plot.dir</code></td>
<td>
<p>Directory to save the plot RDS files [default as specified 
by the global working directory or tempdir()]</p>
</td></tr>
<tr><td><code id="gl.run.EMIBD9_+3A_plot.file">plot.file</code></td>
<td>
<p>Name for the RDS binary file to save (base name only, exclude extension) [default NULL]</p>
</td></tr>
<tr><td><code id="gl.run.EMIBD9_+3A_verbose">verbose</code></td>
<td>
<p>Verbosity: 0, silent or fatal errors; 1, begin and end; 2,
progress log; 3, progress and results summary; 5, full report
[default NULL, unless specified using gl.set.verbosity]</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Download the program from here:
</p>
<p>https://www.zsl.org/about-zsl/resources/software/emibd9
</p>
<p>For Windows, Mac and Linux install the program then point to the folder where you find:
EM_IBD_P.exe (=Windows) and EM_IBD_P (=Mac, Linux). If running really slow you may 
want to create the files using the function and then run in parallel using the
documentation provided by the authors [you need to have mpiexec installed].
</p>


<h3>Value</h3>

<p>A matrix with pairwise relatedness
</p>


<h3>Author(s)</h3>

<p>Custodian: Luis Mijangos &ndash; Post to
<a href="https://groups.google.com/d/forum/dartr">https://groups.google.com/d/forum/dartr</a>
</p>


<h3>References</h3>


<ul>
<li><p> Wang, J. (2022). A joint likelihood estimator of relatedness and allele
frequencies from a small sample of individuals. Methods in Ecology and
Evolution, 13(11), 2443-2462.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#To run this function needs EMIBD9 installed in your computer
t1 &lt;- gl.filter.allna(platypus.gl)
res_rel &lt;- gl.run.EMIBD9(t1)

## End(Not run)

</code></pre>

<hr>
<h2 id='utils.assignment'>Population assignment probabilities</h2><span id='topic+utils.assignment'></span>

<h3>Description</h3>

<p>This function takes one individual and estimates
their probability of coming from individual populations
from multilocus genotype frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils.assignment(x, unknown, verbose = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utils.assignment_+3A_x">x</code></td>
<td>
<p>Name of the genlight object containing the SNP data [required].</p>
</td></tr>
<tr><td><code id="utils.assignment_+3A_unknown">unknown</code></td>
<td>
<p>Name of the individual to be assigned to a population [required].</p>
</td></tr>
<tr><td><code id="utils.assignment_+3A_verbose">verbose</code></td>
<td>
<p>Verbosity: 0, silent or fatal errors; 1, begin and end; 2,
progress log; 3, progress and results summary; 5, full report
[default 2, unless specified using gl.set.verbosity].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a re-implementation of the function multilocus_assignment
from package gstudio.
Description of the method used in this function can be found at:
https://dyerlab.github.io/applied_population_genetics/population-assignment.html
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> consisting of assignment probabilities for each
population.
</p>


<h3>Author(s)</h3>

<p>Custodian: Luis Mijangos &ndash; Post to
<a href="https://groups.google.com/d/forum/dartr">https://groups.google.com/d/forum/dartr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require("dartR.data")
res &lt;- utils.assignment(platypus.gl, unknown = "T27")
</code></pre>

<hr>
<h2 id='utils.assignment_2'>Population assignment probabilities</h2><span id='topic+utils.assignment_2'></span>

<h3>Description</h3>

<p>This function takes one individual and estimates
their probability of coming from individual populations
from multilocus genotype frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils.assignment_2(x, unknown, verbose = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utils.assignment_2_+3A_x">x</code></td>
<td>
<p>Name of the genlight object containing the SNP data [required].</p>
</td></tr>
<tr><td><code id="utils.assignment_2_+3A_unknown">unknown</code></td>
<td>
<p>Name of the individual to be assigned to a population [required].</p>
</td></tr>
<tr><td><code id="utils.assignment_2_+3A_verbose">verbose</code></td>
<td>
<p>Verbosity: 0, silent or fatal errors; 1, begin and end; 2,
progress log; 3, progress and results summary; 5, full report
[default 2, unless specified using gl.set.verbosity].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a re-implementation of the function multilocus_assignment
from package gstudio.
Description of the method used in this function can be found at:
https://dyerlab.github.io/applied_population_genetics/population-assignment.html
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> consisting of assignment probabilities for each
population.
</p>


<h3>Author(s)</h3>

<p>Custodian: Luis Mijangos &ndash; Post to
<a href="https://groups.google.com/d/forum/dartr">https://groups.google.com/d/forum/dartr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require("dartR.data")
res &lt;- utils.assignment_2(platypus.gl, unknown = "T27")
</code></pre>

<hr>
<h2 id='utils.assignment_3'>Population assignment probabilities</h2><span id='topic+utils.assignment_3'></span>

<h3>Description</h3>

<p>This function takes one individual and estimates
their probability of coming from individual populations
from multilocus genotype frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils.assignment_3(x, unknown, verbose = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utils.assignment_3_+3A_x">x</code></td>
<td>
<p>Name of the genlight object containing the SNP data [required].</p>
</td></tr>
<tr><td><code id="utils.assignment_3_+3A_unknown">unknown</code></td>
<td>
<p>Name of the individual to be assigned to a population [required].</p>
</td></tr>
<tr><td><code id="utils.assignment_3_+3A_verbose">verbose</code></td>
<td>
<p>Verbosity: 0, silent or fatal errors; 1, begin and end; 2,
progress log; 3, progress and results summary; 5, full report
[default 2, unless specified using gl.set.verbosity].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a re-implementation of the function multilocus_assignment
from package gstudio.
Description of the method used in this function can be found at:
https://dyerlab.github.io/applied_population_genetics/population-assignment.html
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> consisting of assignment probabilities for each
population.
</p>


<h3>Author(s)</h3>

<p>Custodian: Luis Mijangos &ndash; Post to
<a href="https://groups.google.com/d/forum/dartr">https://groups.google.com/d/forum/dartr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require("dartR.data")
res &lt;- utils.assignment_2(platypus.gl, unknown = "T27")
</code></pre>

<hr>
<h2 id='utils.assignment_4'>Population assignment probabilities</h2><span id='topic+utils.assignment_4'></span>

<h3>Description</h3>

<p>This function takes one individual and estimates
their probability of coming from individual populations
from multilocus genotype frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utils.assignment_4(x, unknown, verbose = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utils.assignment_4_+3A_x">x</code></td>
<td>
<p>Name of the genlight object containing the SNP data [required].</p>
</td></tr>
<tr><td><code id="utils.assignment_4_+3A_unknown">unknown</code></td>
<td>
<p>Name of the individual to be assigned to a population [required].</p>
</td></tr>
<tr><td><code id="utils.assignment_4_+3A_verbose">verbose</code></td>
<td>
<p>Verbosity: 0, silent or fatal errors; 1, begin and end; 2,
progress log; 3, progress and results summary; 5, full report
[default 2, unless specified using gl.set.verbosity].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a re-implementation of the function multilocus_assignment
from package gstudio.
Description of the method used in this function can be found at:
https://dyerlab.github.io/applied_population_genetics/population-assignment.html
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> consisting of assignment probabilities for each
population.
</p>


<h3>Author(s)</h3>

<p>Custodian: Luis Mijangos &ndash; Post to
<a href="https://groups.google.com/d/forum/dartr">https://groups.google.com/d/forum/dartr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require("dartR.data")
res &lt;- utils.assignment_2(platypus.gl, unknown = "T27")
</code></pre>

<hr>
<h2 id='zzz'>Setting up the package dartR.popgenomics</h2><span id='topic+zzz'></span>

<h3>Description</h3>

<p>Setting up dartR.captive
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zzz
</code></pre>


<h3>Format</h3>

<p>An object of class <code>NULL</code> of length 0.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
