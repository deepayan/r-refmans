<!DOCTYPE html><html><head><title>Help for package deSolve</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {deSolve}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aquaphy'><p>A Physiological Model of Unbalanced Algal Growth</p></a></li>
<li><a href='#ccl4data'><p>Closed Chamber Study of CCl4 Metabolism by Rats.</p></a></li>
<li><a href='#ccl4model'><p>The CCl4 Inhalation Model</p></a></li>
<li><a href='#checkDLL'>
<p>Check shared library (DLL/.so) of a compiled model.</p></a></li>
<li><a href='#cleanEventTimes'>
<p>Find Nearest Event for Each Time Step and Clean Time Steps to Avoid Doubles</p></a></li>
<li><a href='#daspk'><p>Solver for Differential Algebraic Equations (DAE)</p></a></li>
<li><a href='#dede'>
<p>General Solver for Delay Differential Equations.</p></a></li>
<li><a href='#deSolve-internal'><p>Internal deSolve Functions</p></a></li>
<li><a href='#deSolve-package'>
<p>General Solvers for Initial Value Problems of Ordinary Differential Equations</p>
(ODE), Partial Differential Equations (PDE), Differential Algebraic
Equations (DAE) and delay differential equations (DDE).</a></li>
<li><a href='#diagnostics'><p>Print Diagnostic Characteristics of Solvers</p></a></li>
<li><a href='#diagnostics.deSolve'><p>Print Diagnostic Characteristics of ODE and DAE Solvers</p></a></li>
<li><a href='#DLLfunc'><p>Evaluates a Derivative Function Represented in a DLL</p></a></li>
<li><a href='#DLLres'><p>Evaluates a Residual Derivative Function Represented in a DLL</p></a></li>
<li><a href='#events'>
<p>Implementing Events and Roots in Differential Equation Models.</p></a></li>
<li><a href='#forcings'>
<p>Passing Forcing Functions to Models Written in R or Compiled Code.</p></a></li>
<li><a href='#lsoda'>
<p>Solver for Ordinary Differential Equations (ODE),</p>
Switching Automatically Between Stiff and Non-stiff Methods</a></li>
<li><a href='#lsodar'><p>Solver for Ordinary Differential Equations (ODE),</p>
Switching Automatically Between Stiff and Non-stiff Methods and With
Root Finding</a></li>
<li><a href='#lsode'><p>Solver for Ordinary Differential Equations (ODE)</p></a></li>
<li><a href='#lsodes'><p>Solver for Ordinary Differential Equations (ODE) With</p>
Sparse Jacobian</a></li>
<li><a href='#ode'><p>General Solver for Ordinary Differential Equations</p></a></li>
<li><a href='#ode.1D'><p>Solver For Multicomponent 1-D Ordinary Differential Equations</p></a></li>
<li><a href='#ode.2D'><p>Solver for 2-Dimensional Ordinary Differential Equations</p></a></li>
<li><a href='#ode.3D'><p>Solver for 3-Dimensional Ordinary Differential Equations</p></a></li>
<li><a href='#ode.band'><p>Solver for Ordinary Differential Equations; Assumes a Banded</p>
Jacobian</a></li>
<li><a href='#plot.deSolve'>
<p>Plot, Image and Histogram Method for deSolve Objects</p></a></li>
<li><a href='#radau'><p>Implicit Runge-Kutta RADAU IIA</p></a></li>
<li><a href='#rk'><p>Explicit One-Step Solvers for Ordinary Differential Equations</p>
(ODE)</a></li>
<li><a href='#rk4'><p>Solve System of ODE (Ordinary Differential Equation)s by</p>
Euler's Method or Classical Runge-Kutta 4th Order Integration.</a></li>
<li><a href='#rkMethod'><p>Collection of Parameter Sets (Butcher Arrays) for</p>
the Runge-Kutta Family of ODE Solvers</a></li>
<li><a href='#SCOC'><p>A Sediment Model of Oxygen Consumption</p></a></li>
<li><a href='#timelags'>
<p>Time Lagged Values of State Variables and Derivatives.</p></a></li>
<li><a href='#vode'><p>Solver for Ordinary Differential Equations (ODE)</p></a></li>
<li><a href='#zvode'><p>Solver for Ordinary Differential Equations (ODE) for COMPLEX variables</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.40</td>
</tr>
<tr>
<td>Title:</td>
<td>Solvers for Initial Value Problems of Differential Equations
('ODE', 'DAE', 'DDE')</td>
</tr>
<tr>
<td>Author:</td>
<td>Karline Soetaert <a href="https://orcid.org/0000-0003-4603-7100"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Thomas Petzoldt <a href="https://orcid.org/0000-0002-4951-6468"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  R. Woodrow Setzer <a href="https://orcid.org/0000-0002-6709-9186"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Peter N. Brown [ctb] (files ddaspk.f, dvode.f, zvode.f),
  George D. Byrne [ctb] (files dvode.f, zvode.f),
  Ernst Hairer [ctb] (files radau5.f, radau5a),
  Alan C. Hindmarsh [ctb] (files ddaspk.f, dlsode.f, dvode.f, zvode.f,
    opdkmain.f, opdka1.f),
  Cleve Moler [ctb] (file dlinpck.f),
  Linda R. Petzold [ctb] (files ddaspk.f, dlsoda.f),
  Youcef Saad [ctb] (file dsparsk.f),
  Clement W. Ulrich [ctb] (file ddaspk.f)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Petzoldt &lt;thomas.petzoldt@tu-dresden.de&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, graphics, grDevices, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>scatterplot3d, FME</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions that solve initial value problems of a system
        of first-order ordinary differential equations ('ODE'), of
        partial differential equations ('PDE'), of differential
        algebraic equations ('DAE'), and of delay differential
        equations.  The functions provide an interface to the FORTRAN
        functions 'lsoda', 'lsodar', 'lsode', 'lsodes' of the 'ODEPACK'
        collection, to the FORTRAN functions 'dvode', 'zvode' and 'daspk'
        and a C-implementation of solvers of the 'Runge-Kutta' family with
        fixed or variable time steps.  The package contains routines
        designed for solving 'ODEs' resulting from 1-D, 2-D and 3-D
        partial differential equations ('PDE') that have been converted
        to 'ODEs' by numerical differencing.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://desolve.r-forge.r-project.org/">http://desolve.r-forge.r-project.org/</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-27 22:26:41 UTC; thpe</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-27 23:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='aquaphy'>A Physiological Model of Unbalanced Algal Growth</h2><span id='topic+aquaphy'></span>

<h3>Description</h3>

<p>A phytoplankton model with uncoupled carbon and nitrogen
assimilation as a function of light and Dissolved Inorganic Nitrogen
(DIN) concentration.
</p>
<p>Algal biomass is described via 3 different state variables:
</p>

<ul>
<li><p> low molecular weight carbohydrates (LMW), the product of
photosynthesis,
</p>
</li>
<li><p> storage molecules (RESERVE) and 
</p>
</li>
<li><p> the biosynthetic and photosynthetic apparatus (PROTEINS).
</p>
</li></ul>

<p>All algal state variables are expressed in
<code class="reqn">\rm mmol\, C\, m^{-3}</code>.
Only proteins contain nitrogen and
chlorophyll, with a fixed stoichiometric ratio.  As the relative
amount of proteins changes in the algae, so does the N:C and the Chl:C
ratio.
</p>
<p>An additional state variable, dissolved inorganic nitrogen (DIN) has
units of <code class="reqn">\rm mmol\, N\, m^{-3}</code>.
</p>
<p>The algae grow in a dilution culture (chemostat): there is constant
inflow of DIN and outflow of culture water, including DIN and algae,
at the same rate.
</p>
<p>Two versions of the model are included.
</p>

<ul>
<li><p> In the default model, there is a day-night illumination regime, i.e.
the light is switched on and off at fixed times (where the sum of
illuminated + dark period = 24 hours).
</p>
</li>
<li><p> In another version, the light is imposed as a forcing function data
set.
</p>
</li></ul>

<p>This model is written in <code>FORTRAN</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aquaphy(times, y, parms, PAR = NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aquaphy_+3A_times">times</code></td>
<td>
<p>time sequence for which output is wanted; the first value
of times must be the initial time,</p>
</td></tr>
<tr><td><code id="aquaphy_+3A_y">y</code></td>
<td>
<p>the initial (state) values (&quot;DIN&quot;, &quot;PROTEIN&quot;, &quot;RESERVE&quot;,
&quot;LMW&quot;), in that order,</p>
</td></tr>
<tr><td><code id="aquaphy_+3A_parms">parms</code></td>
<td>
<p>vector or list with the aquaphy model parameters; see
the example for the order in which these have to be defined.</p>
</td></tr>
<tr><td><code id="aquaphy_+3A_par">PAR</code></td>
<td>
<p>a data set of the photosynthetically active radiation
(light intensity), if <code>NULL</code>, on-off PAR is used, </p>
</td></tr>
<tr><td><code id="aquaphy_+3A_...">...</code></td>
<td>
<p>any other parameters passed to the integrator <code>ode</code>
(which solves the model).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is implemented primarily to demonstrate the linking of
FORTRAN with <span class="rlang"><b>R</b></span>-code.
</p>
<p>The source can be found in the &lsquo;<span class="file">doc/examples/dynload</span>&rsquo; subdirectory of the package.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>References</h3>

<p>Lancelot, C., Veth, C. and Mathot, S. (1991). Modelling ice-edge
phytoplankton bloom in the Scotia-Weddel sea sector of the Southern
Ocean during spring 1988. Journal of Marine Systems 2, 333&ndash;346.
</p>
<p>Soetaert, K. and Herman, P. (2008). A practical guide to ecological
modelling.  Using R as a simulation platform. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ccl4model">ccl4model</a></code>, the CCl4 inhalation model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ======================================================
##
## Example 1. PAR an on-off function
##
## ======================================================


## -----------------------------
## the model parameters:
## -----------------------------

parameters &lt;- c(maxPhotoSynt   = 0.125,      # mol C/mol C/hr
                rMortPHY       = 0.001,      # /hr
                alpha          = -0.125/150, # uEinst/m2/s/hr
                pExudation     = 0.0,        # -
                maxProteinSynt = 0.136,      # mol C/mol C/hr
                ksDIN          = 1.0,        # mmol N/m3
                minpLMW        = 0.05,       # mol C/mol C
                maxpLMW        = 0.15,       # mol C/mol C
                minQuotum      = 0.075,      # mol C/mol C
                maxStorage     = 0.23,       # /h
                respirationRate= 0.0001,     # /h
                pResp          = 0.4,        # -
                catabolismRate = 0.06,       # /h
                dilutionRate   = 0.01,       # /h
                rNCProtein     = 0.2,        # mol N/mol C
                inputDIN       = 10.0,       # mmol N/m3
                rChlN          = 1,          # g Chl/mol N
                parMean        = 250.,       # umol Phot/m2/s
                dayLength      = 15.         # hours
                )

## -----------------------------
## The initial conditions
## -----------------------------

state &lt;- c(DIN    = 6.,     # mmol N/m3
          PROTEIN = 20.0,   # mmol C/m3
          RESERVE = 5.0,    # mmol C/m3
          LMW     = 1.0)    # mmol C/m3

## -----------------------------
## Running the model
## -----------------------------

times &lt;- seq(0, 24*20, 1)

out &lt;- as.data.frame(aquaphy(times, state, parameters))

## -----------------------------
## Plotting model output
## -----------------------------

par(mfrow = c(2, 2), oma = c(0, 0, 3, 0))
col &lt;- grey(0.9)
ii &lt;- 1:length(out$PAR)              

plot(times[ii], out$Chlorophyll[ii], type = "l",
      main = "Chlorophyll", xlab = "time, hours",ylab = "ug/l")
polygon(times[ii], out$PAR[ii]-10, col = col, border = NA); box()
lines(times[ii], out$Chlorophyll[ii], lwd = 2 )


plot (times[ii], out$DIN[ii], type = "l", main = "DIN",
      xlab = "time, hours",ylab = "mmolN/m3")
polygon(times[ii], out$PAR[ii]-10, col = col, border = NA); box()
lines(times[ii], out$DIN[ii], lwd = 2 )


plot (times[ii], out$NCratio[ii], type = "n", main = "NCratio",
      xlab = "time, hours", ylab = "molN/molC")
polygon(times[ii], out$PAR[ii]-10, col = col, border = NA); box()
lines(times[ii], out$NCratio[ii], lwd = 2 )


plot (times[ii], out$PhotoSynthesis[ii],type = "l",
       main = "PhotoSynthesis", xlab = "time, hours",
       ylab = "mmolC/m3/hr")
polygon(times[ii], out$PAR[ii]-10, col = col, border = NA); box()
lines(times[ii], out$PhotoSynthesis[ii], lwd = 2 )

mtext(outer = TRUE, side = 3, "AQUAPHY, PAR= on-off", cex = 1.5)

## -----------------------------
## Summary model output
## -----------------------------
t(summary(out))

## ======================================================
##
## Example 2. PAR a forcing function data set
##
## ======================================================

times &lt;- seq(0, 24*20, 1)

## -----------------------------
## create the forcing functions
## -----------------------------

ftime  &lt;- seq(0,500,by=0.5)
parval &lt;- pmax(0,250 + 350*sin(ftime*2*pi/24)+
   (runif(length(ftime))-0.5)*250)
Par    &lt;- matrix(nc=2,c(ftime,parval))


state &lt;- c(DIN     = 6.,     # mmol N/m3
           PROTEIN = 20.0,   # mmol C/m3
           RESERVE = 5.0,    # mmol C/m3
           LMW     = 1.0)    # mmol C/m3
              
out &lt;- aquaphy(times, state, parameters, Par)

plot(out, which = c("PAR", "Chlorophyll", "DIN", "NCratio"), 
     xlab = "time, hours", 
     ylab = c("uEinst/m2/s", "ug/l", "mmolN/m3", "molN/molC"))

mtext(outer = TRUE, side = 3, "AQUAPHY, PAR=forcing", cex = 1.5)

# Now all variables plotted in one figure...
plot(out, which = 1:9, type = "l")

par(mfrow = c(1, 1))

</code></pre>

<hr>
<h2 id='ccl4data'>Closed Chamber Study of CCl4 Metabolism by Rats.</h2><span id='topic+ccl4data'></span>

<h3>Description</h3>

<p>The results of a closed chamber experiment to determine
metabolic parameters for CCl4 (carbon tetrachloride) in rats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ccl4data)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>time</dt><dd><p>the time (in hours after starting the experiment).</p>
</dd>
<dt>initconc</dt><dd><p>initial chamber concentration (ppm).</p>
</dd>
<dt>animal</dt><dd><p>this is a repeated measures design; this variable
indicates which animal the observation pertains to.
</p>
</dd>
<dt>ChamberConc</dt><dd><p>chamber concentration at <code>time</code>, in ppm.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Evans, et al. 1994 Applications of sensitivity analysis to a
physiologically based pharmacokinetic model for carbon tetrachloride
in rats. Toxicology and Applied Pharmacology <b>128</b>: 36 &ndash; 44.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(ChamberConc ~ time, data = ccl4data, xlab = "Time (hours)",
  xlim = range(c(0, ccl4data$time)),
  ylab = "Chamber Concentration (ppm)", log = "y")
ccl4data.avg &lt;- aggregate(ccl4data$ChamberConc,
                  by = ccl4data[c("time", "initconc")], mean)
points(x ~ time, data = ccl4data.avg, pch = 16)                        
</code></pre>

<hr>
<h2 id='ccl4model'>The CCl4 Inhalation Model</h2><span id='topic+ccl4model'></span>

<h3>Description</h3>

<p>The CCl4 inhalation model implemented in <code>.Fortran</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>ccl4model(times, y, parms, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ccl4model_+3A_times">times</code></td>
<td>
<p>time sequence for which the model has to be integrated.</p>
</td></tr>
<tr><td><code id="ccl4model_+3A_y">y</code></td>
<td>
<p>the initial values for the state variables (&quot;AI&quot;, &quot;AAM&quot;,
&quot;AT&quot;, &quot;AF&quot;, &quot;AL&quot;, &quot;CLT&quot; and &quot;AM&quot;), in that order.
</p>
</td></tr>
<tr><td><code id="ccl4model_+3A_parms">parms</code></td>
<td>
<p>vector or list holding the ccl4 model parameters; see
the example for the order in which these have to be defined.
</p>
</td></tr>
<tr><td><code id="ccl4model_+3A_...">...</code></td>
<td>
<p>any other parameters passed to the integrator <code>ode</code>
(which solves the model).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is implemented primarily to demonstrate the linking of FORTRAN
with R-code.
</p>
<p>The source can be found in the &lsquo;<span class="file">/doc/examples/dynload</span>&rsquo; subdirectory of the
package.
</p>


<h3>Author(s)</h3>

<p>R. Woodrow Setzer &lt;setzer.woodrow@epa.gov&gt;</p>


<h3>See Also</h3>

<p>Try <code>demo(CCL4model)</code> for how this model has been fitted to the
dataset <code><a href="#topic+ccl4data">ccl4data</a>,</code>
</p>
<p><code><a href="#topic+aquaphy">aquaphy</a></code>, another FORTRAN model, describing growth in
aquatic phytoplankton.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =================
## Parameter values
## =================

Pm &lt;- c(
  ## Physiological parameters
  BW = 0.182,   # Body weight (kg)
  QP = 4.0  ,   # Alveolar ventilation rate (hr^-1)
  QC = 4.0  ,   # Cardiac output (hr^-1)
  VFC = 0.08,   # Fraction fat tissue (kg/(kg/BW))
  VLC = 0.04,   # Fraction liver tissue (kg/(kg/BW))
  VMC = 0.74,   # Fraction of muscle tissue (kg/(kg/BW))
  QFC = 0.05,   # Fractional blood flow to fat ((hr^-1)/QC
  QLC = 0.15,   # Fractional blood flow to liver ((hr^-1)/QC)
  QMC = 0.32,   # Fractional blood flow to muscle ((hr^-1)/QC)

  ## Chemical specific parameters for chemical
  PLA = 16.17,  # Liver/air partition coefficient
  PFA = 281.48, # Fat/air partition coefficient
  PMA = 13.3,   # Muscle/air partition coefficient
  PTA = 16.17,  # Viscera/air partition coefficient
  PB = 5.487,   # Blood/air partition coefficient
  MW = 153.8,   # Molecular weight (g/mol)
  VMAX = 0.04321671, # Max. velocity of metabolism (mg/hr) -calibrated
  KM = 0.4027255,    # Michaelis-Menten constant (mg/l) -calibrated

  ## Parameters for simulated experiment
  CONC = 1000,  # Inhaled concentration
  KL = 0.02,    # Loss rate from empty chamber /hr
  RATS = 1.0,   # Number of rats enclosed in chamber
  VCHC = 3.8    # Volume of closed chamber (l)
)

## ================
## State variables
## ================
y &lt;- c(
  AI  = 21, # total mass , mg
  AAM = 0,
  AT  = 0,
  AF  = 0,
  AL  = 0,
  CLT = 0,  # area under the conc.-time curve in the liver
  AM  = 0   # the amount metabolized (AM)
)

## ==================
## Model application
## ==================

times &lt;- seq(0, 6, by = 0.1)

## initial inhaled concentration-calibrated
conc &lt;- c(26.496, 90.197, 245.15, 951.46) 

plot(ChamberConc ~ time, data = ccl4data, xlab = "Time (hours)",
       xlim = range(c(0, ccl4data$time)),
       ylab = "Chamber Concentration (ppm)",
       log = "y", main = "ccl4model")

for (cc in conc) {
  Pm["CONC"] &lt;- cc

  VCH &lt;- Pm[["VCHC"]] - Pm[["RATS"]] * Pm[["BW"]]
  AI0 &lt;- VCH * Pm[["CONC"]] * Pm[["MW"]]/24450 
  y["AI"] &lt;- AI0
  
  ## run the model:
  out &lt;- as.data.frame(ccl4model(times, y, Pm))
  lines(out$time, out$CP, lwd = 2)
}

legend("topright", lty = c(NA, 1), pch = c(1, NA), lwd = c(NA, 2),
       legend = c("data", "model"))

## ================================== 
## An example with tracer injection
## ==================================
## every day, a conc of 2 is added to AI.
## 1. implemented as a data.frame
eventdat &lt;- data.frame(var = rep("AI", 6), time = 1:6 ,
  value = rep(1, 6), method = rep("add", 6))

eventdat

print(system.time(
  out &lt;-ccl4model(times, y, Pm, events = list(data = eventdat))
))

plot(out, mfrow = c(3, 4), type = "l", lwd = 2)


# 2. implemented as a function in a DLL!
print(system.time(
out2 &lt;-ccl4model(times, y, Pm, events = list(func = "eventfun", time = 1:6))
))

plot(out2, mfrow=c(3, 4), type = "l", lwd = 2)
</code></pre>

<hr>
<h2 id='checkDLL'>
Check shared library (DLL/.so) of a compiled model.
</h2><span id='topic+checkDLL'></span>

<h3>Description</h3>

<p>Check shared library (DLL/.so) of a compiled model and create a list of symbols.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkDLL(func, jacfunc, dllname, initfunc, verbose, nout, outnames, JT = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkDLL_+3A_func">func</code></td>
<td>

<p>character: name of the derivative function.
</p>
</td></tr>
<tr><td><code id="checkDLL_+3A_jacfunc">jacfunc</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> function, that computes the
Jacobian of the system of differential equations
<code class="reqn">\partial\dot{y}_i/\partial y_j</code>, or
a string giving the name of a function or subroutine in
&lsquo;<span class="file">dllname</span>&rsquo; that computes the Jacobian.</p>
</td></tr>
<tr><td><code id="checkDLL_+3A_dllname">dllname</code></td>
<td>
<p>a string giving the name of the shared library
(without extension) that contains all the compiled function or
subroutine definitions refered to in <code>func</code> and
<code>jacfunc</code>.</p>
</td></tr>
<tr><td><code id="checkDLL_+3A_initfunc">initfunc</code></td>
<td>
<p> the name of the initialisation function
(which initialises values of parameters), as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="checkDLL_+3A_verbose">verbose</code></td>
<td>
<p>reserved for future extensions.
</p>
</td></tr>
<tr><td><code id="checkDLL_+3A_nout">nout</code></td>
<td>
<p>only used if <code>dllname</code> is specified and the model is
defined in compiled code: the number of output variables calculated
in the compiled function <code>func</code>, present in the shared
library. Note: it is not automatically checked whether this is
indeed the number of output variables calculated in the dll - you have
to perform this check in the code.
</p>
</td></tr>
<tr><td><code id="checkDLL_+3A_outnames">outnames</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified and
<code>nout</code> &gt; 0: the names of output variables calculated in the
compiled function <code>func</code>, present in the shared library.
These names will be used to label the output matrix.
</p>
</td></tr>
<tr><td><code id="checkDLL_+3A_jt">JT</code></td>
<td>
<p>integer specifying the type of the Jacobian. The default value of 1
must be set to 2 for solver <code>lsodes</code> if 'func' is specified in a  DLL
or inline compiled and if  a 'jacfunc' is provided.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>checkDLL</code> is normally called internally by the solver
functions. It can be used to avoid overhead, when a small compiled
model with a low number of integration steps is repeatedly called.
The feature is currently only available for the <code>lsoda</code> solver.
</p>


<h3>Value</h3>

<p>List of class <code>deSolve.symbols</code> with:
</p>
<table>
<tr><td><code>ModelInit</code></td>
<td>
<p>pointer to the init function of the DLL (class &quot;externalptr&quot;).</p>
</td></tr>
<tr><td><code>Func</code></td>
<td>
<p>pointer to the derivative function in the DLL (class &quot;externalptr&quot;).</p>
</td></tr>
<tr><td><code>JacFunc</code></td>
<td>
<p>pointer to the Jacobi function in the DLL (class &quot;externalptr&quot;).</p>
</td></tr>
<tr><td><code>Nglobal</code></td>
<td>
<p>number of output variables calculated in the compiled function.</p>
</td></tr>
<tr><td><code>Nmtot</code></td>
<td>
<p>list of names of derivatives and output variables.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+lsoda">lsoda</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
symbols &lt;- checkDLL(func = "derivs", jacfunc = NULL, dllname = "lorenzc",
             initfunc = "initmod", verbose = TRUE, nout = 0,
             outnames = NULL, JT = 1)

## End(Not run)

</code></pre>

<hr>
<h2 id='cleanEventTimes'>
Find Nearest Event for Each Time Step and Clean Time Steps to Avoid Doubles
</h2><span id='topic+cleanEventTimes'></span><span id='topic+nearestEvent'></span>

<h3>Description</h3>

<p>These functions can be used for checking time steps and events used by 
ode solver functions. They are normally called internally within the solvers. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearestEvent(times, eventtimes)
cleanEventTimes(times, eventtimes, eps = .Machine$double.eps * 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cleanEventTimes_+3A_times">times</code></td>
<td>
<p>the vector of output times,</p>
</td></tr>
<tr><td><code id="cleanEventTimes_+3A_eventtimes">eventtimes</code></td>
<td>
<p>a vector with the event times,</p>
</td></tr>
<tr><td><code id="cleanEventTimes_+3A_eps">eps</code></td>
<td>
<p>relative tolerance value below which two numbers are assumed 
to be numerically equal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In floating point arithmetics, problems can occur if values have to be
compared for 'equality' but are only close to each other and not exactly
the same.
</p>
<p>The utility functions can be used to add all <code>eventtimes</code> to
the output <code>times</code> vector, but without including times that are
very close to an event.
</p>
<p>This means that all values of <code>eventtimes</code> are contained
but only the subset of <code>times</code> that have no close neighbors in
<code>eventtimes</code>.
</p>
<p>These checks are normally performed internally by the integration solvers.
</p>


<h3>Value</h3>

<p><code>nearestEvent</code> returns a vector with the closest events for
each time step and
</p>
<p><code>cleanEventTimes</code> returns a vector with the output times
without all those that are 'very close' to an event.
</p>


<h3>Author(s)</h3>

<p>Thomas Petzoldt
</p>


<h3>See Also</h3>

<p><code><a href="#topic+events">events</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
events &lt;- sort(c(0, 2, 3, 4 + 1e-10, 5, 7 - 1e-10,
                 7 + 6e-15, 7.5, 9, 24.9999, 25, 80, 1001, 1e300))
times  &lt;- sort(c(0, 1:7, 4.5, 6.75, 7.5, 9.2, 9.0001, 25, 879, 1e3, 1e300+5))

nearest &lt;- nearestEvent(times, events)
data.frame(times=times, nearest = nearest)

## typical usage: include all events in times after removing values that
## are numerically close together, events have priority 
times
unique_times &lt;- cleanEventTimes(times, events)
newtimes &lt;- sort(c(unique_times, events))
newtimes
</code></pre>

<hr>
<h2 id='daspk'>Solver for Differential Algebraic Equations (DAE)</h2><span id='topic+daspk'></span>

<h3>Description</h3>

<p>Solves either:
</p>

<ul>
<li><p> a system of ordinary differential equations (ODE) of the form
</p>
<p style="text-align: center;"><code class="reqn">y' = f(t, y, ...)</code>
</p>
<p> or
</p>
</li>
<li><p> a system of differential algebraic equations (DAE) of the form
</p>
<p style="text-align: center;"><code class="reqn">F(t,y,y') = 0</code>
</p>
<p> or
</p>
</li>
<li><p> a system of linearly implicit DAES in the 
form </p>
<p style="text-align: center;"><code class="reqn">M y' = f(t, y)</code>
</p>
    
</li></ul>

<p>using a combination of backward differentiation formula (BDF) and a
direct linear system solution method (dense or banded).
</p>
<p>The <span class="rlang"><b>R</b></span> function <code>daspk</code> provides an interface to the FORTRAN DAE
solver of the same name, written by Linda R. Petzold, Peter N. Brown,
Alan C. Hindmarsh and Clement W. Ulrich.
</p>
<p>The system of DE's is written as an <span class="rlang"><b>R</b></span> function (which may, of course,
use <code><a href="base.html#topic+.C">.C</a></code>, <code>.Fortran</code>, <code><a href="base.html#topic+.Call">.Call</a></code>, etc., to
call foreign code) or be defined in compiled code that has been
dynamically loaded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>daspk(y, times, func = NULL, parms, nind = c(length(y), 0, 0), 
  dy = NULL, res = NULL, nalg = 0, 
  rtol = 1e-6, atol = 1e-6, jacfunc = NULL,
  jacres = NULL, jactype = "fullint", mass = NULL, estini = NULL,
  verbose = FALSE, tcrit = NULL, hmin = 0, hmax = NULL,
  hini = 0, ynames = TRUE, maxord = 5, bandup = NULL,
  banddown = NULL, maxsteps = 5000, dllname = NULL,
  initfunc = dllname, initpar = parms, rpar = NULL,
  ipar = NULL, nout = 0, outnames = NULL,
  forcings=NULL, initforc = NULL, fcontrol=NULL,
  events = NULL, lags = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="daspk_+3A_y">y</code></td>
<td>
<p>the initial (state) values for the DE system. If <code>y</code>
has a name attribute, the names will be used to label the output
matrix.
</p>
</td></tr>
<tr><td><code id="daspk_+3A_times">times</code></td>
<td>
<p>time sequence for which output is wanted; the first
value of <code>times</code> must be the initial time; if only one step is
to be taken; set <code>times</code> = <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="daspk_+3A_func">func</code></td>
<td>
<p>to be used if the model is an ODE, or a DAE written in linearly
implicit form (M y' = f(t, y)). 
<code>func</code> should be an <span class="rlang"><b>R</b></span>-function that computes the
values of the derivatives in the ODE system (the <em>model
definition</em>) at time t.
</p>
<p><code>func</code> must be defined as:  <code>func &lt;- function(t, y, parms,...)</code>.
<br /> <code>t</code> is the current time point in the
integration, <code>y</code> is the current estimate of the variables in
the ODE system.  If the initial values <code>y</code> has a <code>names</code>
attribute, the names will be available inside <code>func</code>, unless
<code>ynames</code> is FALSE.  <code>parms</code> is a vector or list of
parameters.  <code>...</code> (optional) are any other arguments passed to
the function.
</p>
<p>The return value of <code>func</code> should be a list,
whose first element is a vector containing the derivatives of
<code>y</code> with respect to <code>time</code>, and whose next elements are
global values that are required at each point in <code>times</code>.
The derivatives should be specified in the same order as the specification
of the state variables <code>y</code>.
</p>
<p>Note that it is not possible to define <code>func</code> as a compiled
function in a dynamically loaded shared library. Use <code>res</code>
instead.
</p>
</td></tr>
<tr><td><code id="daspk_+3A_parms">parms</code></td>
<td>
<p>vector or list of parameters used in <code>func</code>,
<code>jacfunc</code>, or <code>res</code>
</p>
</td></tr>
<tr><td><code id="daspk_+3A_nind">nind</code></td>
<td>
<p>if a DAE system: a three-valued vector with the number of
variables of index 1, 2, 3 respectively.
The equations must be defined such that the index 1 variables precede
the index 2 variables which in turn precede the index 3 variables.
The sum of the variables of different index should equal N,
the total number of variables.
Note that this has been added for consistency with <a href="#topic+radau">radau</a>. 
If used, then the variables are weighed differently than in the 
original daspk code, i.e. index 2 variables are scaled with 1/h,
index 3 variables are scaled with 1/h^2. In some cases this allows
daspk to solve index 2 or index 3 problems.
</p>
</td></tr>
<tr><td><code id="daspk_+3A_dy">dy</code></td>
<td>
<p>the initial derivatives of the state variables of the DE
system.  Ignored if an ODE.
</p>
</td></tr>
<tr><td><code id="daspk_+3A_res">res</code></td>
<td>
<p>if a DAE system: either an <span class="rlang"><b>R</b></span>-function that computes the
residual function <code class="reqn">F(t,y,y')</code> of the DAE system (the model
defininition) at time <code>t</code>, or a character string giving the
name of a compiled function in a dynamically loaded shared library.
</p>
<p>If <code>res</code> is a user-supplied <span class="rlang"><b>R</b></span>-function, it must be defined as:
<code>res &lt;- function(t, y, dy, parms, ...)</code>.
</p>
<p>Here <code>t</code> is the current time point in the integration, <code>y</code>
is the current estimate of the variables in the ODE system,
<code>dy</code> are the corresponding derivatives.  If the initial
<code>y</code> or <code>dy</code> have a <code>names</code> attribute, the names will be
available inside <code>res</code>, unless <code>ynames</code> is <code>FALSE</code>.
<code>parms</code> is a vector of parameters.
</p>
<p>The return value of <code>res</code> should be a list, whose first element
is a vector containing the residuals of the DAE system,
i.e. <code class="reqn">\delta = F(t,y,y')</code>, and whose next elements contain output
variables that are required at each point in <code>times</code>.
</p>
<p>If <code>res</code> is a string, then <code>dllname</code> must give the name of
the shared library (without extension) which must be loaded before
<code>daspk()</code> is called (see package vignette <code>"compiledCode"</code>
for more information).
</p>
</td></tr>
<tr><td><code id="daspk_+3A_nalg">nalg</code></td>
<td>
<p>if a DAE system: the number of algebraic equations
(equations not involving derivatives). Algebraic equations should
always be the last, i.e.  preceeded by the differential equations.
</p>
<p>Only used if <code>estini</code> = 1.
</p>
</td></tr>
<tr><td><code id="daspk_+3A_rtol">rtol</code></td>
<td>
<p>relative error tolerance, either a scalar or a vector,
one value for each y,
</p>
</td></tr>
<tr><td><code id="daspk_+3A_atol">atol</code></td>
<td>
<p>absolute error tolerance, either a scalar or a vector,
one value for each y.
</p>
</td></tr>
<tr><td><code id="daspk_+3A_jacfunc">jacfunc</code></td>
<td>
<p>if not <code>NULL</code>, an <span class="rlang"><b>R</b></span> function that computes the
Jacobian of the system of differential equations. Only used in case
the system is an ODE (<code class="reqn">y' = f(t, y)</code>), specified by <code>func</code>. The <span class="rlang"><b>R</b></span>
calling sequence for <code>jacfunc</code> is identical to that of
<code>func</code>.
</p>
<p>If the Jacobian is a full matrix, <code>jacfunc</code> should return a
matrix <code class="reqn">\partial\dot{y}/\partial y</code>, where the ith row contains the derivative of
<code class="reqn">dy_i/dt</code> with respect to <code class="reqn">y_j</code>, or a vector containing the
matrix elements by columns (the way <span class="rlang"><b>R</b></span> and FORTRAN store matrices).
</p>
<p>If the Jacobian is banded, <code>jacfunc</code> should return a matrix
containing only the nonzero bands of the Jacobian, rotated
row-wise. See first example of lsode.
</p>
</td></tr>
<tr><td><code id="daspk_+3A_jacres">jacres</code></td>
<td>
 <p><code>jacres</code> and not <code>jacfunc</code> should be used if
the system is specified by the residual function <code class="reqn">F(t, y, y')</code>,
i.e. <code>jacres</code> is used in conjunction with <code>res</code>.
</p>
<p>If <code>jacres</code> is an <span class="rlang"><b>R</b></span>-function, the calling sequence for
<code>jacres</code> is identical to that of <code>res</code>, but with extra
parameter <code>cj</code>.  Thus it should be called as: <code>jacres = 
    func(t, y, dy, parms, cj, ...)</code>.  Here <code>t</code> is the current time
point in the integration, <code>y</code> is the current estimate of the
variables in the ODE system, <code class="reqn">y'</code> are the corresponding derivatives
and <code>cj</code> is a scalar, which is normally proportional to
the inverse of the stepsize. If the initial <code>y</code> or <code>dy</code>
have a <code>names</code> attribute, the names will be available inside
<code>jacres</code>, unless
<code>ynames</code> is <code>FALSE</code>. <code>parms</code> is a vector of
parameters (which may have a names attribute).
</p>
<p>If the Jacobian is a full matrix, <code>jacres</code> should return the
matrix <code class="reqn">dG/dy + c_j\cdot dG/dy'</code>, where the <code class="reqn">i</code>th row is the sum of the
derivatives of <code class="reqn">G_i</code> with respect to <code class="reqn">y_j</code> and the scaled
derivatives of <code class="reqn">G_i</code> with respect to <code class="reqn">y'_j</code>.
</p>
<p>If the Jacobian is banded, <code>jacres</code> should return only the
nonzero bands of the Jacobian, rotated rowwise. See details for the
calling sequence when <code>jacres</code> is a string.
</p>
</td></tr>
<tr><td><code id="daspk_+3A_jactype">jactype</code></td>
<td>
<p>the structure of the Jacobian, one of
<code>"fullint"</code>, <code>"fullusr"</code>, <code>"bandusr"</code> or
<code>"bandint"</code> - either full or banded and estimated internally or
by the user.
</p>
</td></tr>
<tr><td><code id="daspk_+3A_mass">mass</code></td>
<td>
<p>the mass matrix. 
If not <code>NULL</code>, the problem is a linearly
implicit DAE and defined as <code class="reqn">M\, dy/dt = f(t,y)</code>. The mass-matrix <code class="reqn">M</code>
should be of dimension <code class="reqn">n*n</code> where <code class="reqn">n</code> is the 
number of <code class="reqn">y</code>-values.
</p>
<p>If <code>mass=NULL</code> then the model is either an ODE or a DAE, specified with
<code>res</code>
</p>
</td></tr>
<tr><td><code id="daspk_+3A_estini">estini</code></td>
<td>
<p>only if a DAE system, and if initial values of <code>y</code>
and <code>dy</code> are not consistent (i.e. <code class="reqn">F(t,y,dy) \neq 0</code>), setting
<code>estini</code> = 1 or 2, will solve for them.  If <code>estini</code> = 1: dy
and the algebraic variables are estimated from <code>y</code>; in this
case, the number of algebraic equations must be given (<code>nalg</code>).
If <code>estini</code> = 2: <code>y</code> will be estimated from <code>dy</code>.
</p>
</td></tr>
<tr><td><code id="daspk_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE: full output to the screen, e.g. will
print the <code>diagnostiscs</code> of the integration - see details.
</p>
</td></tr>
<tr><td><code id="daspk_+3A_tcrit">tcrit</code></td>
<td>
<p>the FORTRAN routine <code>daspk</code> overshoots its targets
(times points in the vector <code>times</code>), and interpolates values
for the desired time points.  If there is a time beyond which
integration should not proceed (perhaps because of a singularity),
that should be provided in <code>tcrit</code>.
</p>
</td></tr>
<tr><td><code id="daspk_+3A_hmin">hmin</code></td>
<td>
<p>an optional minimum value of the integration stepsize. In
special situations this parameter may speed up computations with the
cost of precision. Don't use <code>hmin</code> if you don't know why!
</p>
</td></tr>
<tr><td><code id="daspk_+3A_hmax">hmax</code></td>
<td>
<p>an optional maximum value of the integration stepsize. If
not specified, <code>hmax</code> is set to the largest difference in
<code>times</code>, to avoid that the simulation possibly ignores
short-term events. If 0, no maximal size is specified.
</p>
</td></tr>
<tr><td><code id="daspk_+3A_hini">hini</code></td>
<td>
<p>initial step size to be attempted; if 0, the initial step
size is determined by the solver
</p>
</td></tr>
<tr><td><code id="daspk_+3A_ynames">ynames</code></td>
<td>
<p>logical, if <code>FALSE</code>, names of state variables are not
passed to function <code>func</code>; this may speed up the simulation especially
for large models.
</p>
</td></tr>
<tr><td><code id="daspk_+3A_maxord">maxord</code></td>
<td>
<p>the maximum order to be allowed. Reduce <code>maxord</code>
to save storage space ( &lt;= 5)
</p>
</td></tr>
<tr><td><code id="daspk_+3A_bandup">bandup</code></td>
<td>
<p>number of non-zero bands above the diagonal, in case
the Jacobian is banded (and <code>jactype</code> one of
&quot;bandint&quot;, &quot;bandusr&quot;)
</p>
</td></tr>
<tr><td><code id="daspk_+3A_banddown">banddown</code></td>
<td>
<p>number of non-zero bands below the diagonal, in case
the Jacobian is banded (and <code>jactype</code> one of
&quot;bandint&quot;, &quot;bandusr&quot;)
</p>
</td></tr>
<tr><td><code id="daspk_+3A_maxsteps">maxsteps</code></td>
<td>
<p>maximal number of steps per output interval taken by the
solver; will be recalculated to be at least 500 and a multiple of
500; if <code>verbose</code> is <code>TRUE</code> 
the solver will give a warning if more than 500 steps are
taken, but it will continue till <code>maxsteps</code> steps. 
(Note this warning was always given in deSolve versions &lt; 1.10.3).
</p>
</td></tr>
<tr><td><code id="daspk_+3A_dllname">dllname</code></td>
<td>
<p>a string giving the name of the shared library
(without extension) that contains all the compiled function or
subroutine definitions referred to in <code>res</code> and
<code>jacres</code>.  See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="daspk_+3A_initfunc">initfunc</code></td>
<td>
<p>if not <code>NULL</code>, the name of the initialisation function
(which initialises values of parameters), as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="daspk_+3A_initpar">initpar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified and an
initialisation function <code>initfunc</code> is in the dll: the
parameters passed to the initialiser, to initialise the common
blocks (FORTRAN) or global variables (C, C++).
</p>
</td></tr>
<tr><td><code id="daspk_+3A_rpar">rpar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with
double precision values passed to the dll-functions whose names are
specified by <code>res</code> and <code>jacres</code>.
</p>
</td></tr>
<tr><td><code id="daspk_+3A_ipar">ipar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with
integer values passed to the dll-functions whose names are specified
by <code>res</code> and <code>jacres</code>.
</p>
</td></tr>
<tr><td><code id="daspk_+3A_nout">nout</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified and the model is
defined in compiled code: the number of output variables calculated
in the compiled function <code>res</code>, present in the shared
library. Note: it is not automatically checked whether this is
indeed the number of output variables calculated in the dll - you have
to perform this check in the code - See package vignette
<code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="daspk_+3A_outnames">outnames</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified and
<code>nout</code> &gt; 0: the names of output variables calculated in the
compiled function <code>res</code>, present in the shared library.
These names will be used to label the output matrix.
</p>
</td></tr>
<tr><td><code id="daspk_+3A_forcings">forcings</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified: a list with
the forcing function data sets, each present as a two-columned matrix,
with (time,value); interpolation outside the interval
[min(<code>times</code>), max(<code>times</code>)] is done by taking the value at
the closest data extreme.
</p>
<p>See <a href="#topic+forcings">forcings</a> or package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="daspk_+3A_initforc">initforc</code></td>
<td>
<p>if not <code>NULL</code>, the name of the forcing function
initialisation function, as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. It MUST be present if <code>forcings</code> has been given a
value.
See <a href="#topic+forcings">forcings</a> or package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="daspk_+3A_fcontrol">fcontrol</code></td>
<td>
<p>A list of control parameters for the forcing functions.
See <a href="#topic+forcings">forcings</a> or vignette <code>compiledCode</code>.
</p>
</td></tr>
<tr><td><code id="daspk_+3A_events">events</code></td>
<td>
<p>A matrix or data frame that specifies events, i.e. when the value of a
state variable is suddenly changed. See <a href="#topic+events">events</a> for more information.
</p>
</td></tr>
<tr><td><code id="daspk_+3A_lags">lags</code></td>
<td>
<p>A list that specifies timelags, i.e. the number of steps
that has to be kept. To be used for delay differential equations. 
See <a href="#topic+timelags">timelags</a>, <a href="#topic+dede">dede</a> for more information.
</p>
</td></tr>
<tr><td><code id="daspk_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>func</code>,
<code>jacfunc</code>, <code>res</code> and <code>jacres</code>, allowing this to be a
generic function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The daspk solver uses the backward differentiation formulas of orders
one through five (specified with <code>maxord</code>) to solve either:
</p>

<ul>
<li><p> an ODE system of the form </p>
<p style="text-align: center;"><code class="reqn">y' = f(t,y,...)</code>
</p>
  
<p>or
</p>
</li>
<li><p> a DAE system of the form </p>
<p style="text-align: center;"><code class="reqn">y' = M f(t,y,...)</code>
</p>
 
<p>or
</p>
</li>
<li><p> a DAE system of the form </p>
<p style="text-align: center;"><code class="reqn">F(t,y,y') = 0</code>
</p>
<p>. 
The index of the DAE should be preferable &lt;= 1.
</p>
</li></ul>

<p>ODEs are specified using argument <code>func</code>, 
DAEs are specified using argument <code>res</code>.
</p>
<p>If a DAE system, Values for y <em>and</em> y' (argument <code>dy</code>) 
at the initial time must be given as input. Ideally, these values should be consistent,
that is, if t, y, y' are the given initial values, they should
satisfy F(t,y,y') = 0.  <br /> However, if consistent values are not
known, in many cases daspk can solve for them: when <code>estini</code> = 1,
y' and algebraic variables (their number specified with <code>nalg</code>)
will be estimated, when <code>estini</code> = 2, y will be estimated.
</p>
<p>The form of the <b>Jacobian</b> can be specified by
<code>jactype</code>. This is one of:
</p>

<dl>
<dt>jactype = &quot;fullint&quot;:</dt><dd><p>a full Jacobian, calculated internally
by <code>daspk</code>, the default,
</p>
</dd>
<dt>jactype = &quot;fullusr&quot;:</dt><dd><p>a full Jacobian, specified by user
function <code>jacfunc</code> or <code>jacres</code>,
</p>
</dd>
<dt>jactype = &quot;bandusr&quot;:</dt><dd><p>a banded Jacobian, specified by user
function <code>jacfunc</code> or <code>jacres</code>; the size of the bands
specified by <code>bandup</code> and <code>banddown</code>,
</p>
</dd>
<dt>jactype = &quot;bandint&quot;:</dt><dd><p>a banded Jacobian, calculated by
<code>daspk</code>; the size of the bands specified by <code>bandup</code> and
<code>banddown</code>.
</p>
</dd>
</dl>

<p>If <code>jactype</code> = &quot;fullusr&quot; or &quot;bandusr&quot; then the user must supply a
subroutine <code>jacfunc</code>.
</p>
<p>If jactype = &quot;fullusr&quot; or &quot;bandusr&quot; then the user must supply a
subroutine <code>jacfunc</code> or <code>jacres</code>.
</p>
<p>The input parameters <code>rtol</code>, and <code>atol</code> determine the
<b>error control</b> performed by the solver.  If the request for
precision exceeds the capabilities of the machine, <code>daspk</code> will return
an error code. See <code><a href="#topic+lsoda">lsoda</a></code> for details.
</p>
<p>When the index of the variables is specified (argument <code>nind</code>), 
and higher index variables
are present, then the equations are scaled such that equations corresponding
to index 2 variables are multiplied with 1/h, for index 3 they are multiplied
with 1/h^2, where h is the time step. This is not in the standard DASPK code,
but has been added for consistency with solver <a href="#topic+radau">radau</a>. Because of this,
daspk can solve certain index 2 or index 3 problems.
</p>
<p><b>res and jacres</b> may be defined in compiled C or FORTRAN code, as
well as in an R-function. See package vignette <code>"compiledCode"</code>
for details.  Examples
in FORTRAN are in the &lsquo;<span class="file">dynload</span>&rsquo; subdirectory of the
<code>deSolve</code> package directory.
</p>
<p>The diagnostics of the integration can be printed to screen
by calling <code><a href="#topic+diagnostics">diagnostics</a></code>. If <code>verbose</code> = <code>TRUE</code>,
the diagnostics will written to the screen at the end of the integration.
</p>
<p>See vignette(&quot;deSolve&quot;) for an explanation of each element in the vectors
containing the diagnostic properties and how to directly access them.
</p>
<p><b>Models</b> may be defined in compiled C or FORTRAN code, as well as
in an R-function. See package vignette <code>"compiledCode"</code> for details.
</p>
<p>More information about models defined in compiled code is in the package
vignette (&quot;compiledCode&quot;); information about linking forcing functions
to compiled code is in <a href="#topic+forcings">forcings</a>.
</p>
<p>Examples in both C and FORTRAN are in the &lsquo;<span class="file">dynload</span>&rsquo; subdirectory
of the <code>deSolve</code> package directory.
</p>


<h3>Value</h3>

<p>A matrix of class <code>deSolve</code> with up to as many rows as elements in
<code>times</code> and as many
columns as elements in <code>y</code> plus the number of &quot;global&quot; values
returned in the next elements of the return from <code>func</code> or
<code>res</code>, plus an additional column (the first) for the time value.
There will be one row for each element in <code>times</code> unless the
FORTRAN routine &lsquo;daspk&rsquo; returns with an unrecoverable error.  If
<code>y</code> has a names attribute, it will be used to label the columns
of the output value.
</p>


<h3>Note</h3>

<p>In this version, the Krylov method is not (yet) supported.
</p>
<p>From <code>deSolve</code> version 1.10.4 and above, the following changes were made
</p>

<ol>
<li><p> the argument list to <code>daspk</code> 
now also includes <code>nind</code>, the index of each variable. 
This is used to scale the variables, such that <code>daspk</code> in R can also solve
certain index 2 or index 3 problems, which the original Fortran version 
may not be able to solve.
</p>
</li>
<li><p> the default of <code>atol</code> was changed from 1e-8 to 1e-6,
to be consistent with the other solvers.
</p>
</li>
<li><p> the multiple warnings from daspk when the number of steps exceed 500
were toggled off unless <code>verbose</code> is <code>TRUE</code>
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>References</h3>

<p>L. R. Petzold, A Description of DASSL: A Differential/Algebraic
System Solver, in Scientific Computing, R. S. Stepleman et al.
(Eds.), North-Holland, Amsterdam, 1983, pp. 65-68.
</p>
<p>K. E. Brenan, S. L. Campbell, and L. R. Petzold, Numerical
Solution of Initial-Value Problems in Differential-Algebraic
Equations, Elsevier, New York, 1989.
</p>
<p>P. N. Brown and A. C. Hindmarsh, Reduced Storage Matrix Methods
in Stiff ODE Systems, J. Applied Mathematics and Computation,
31 (1989), pp. 40-91.
<a href="https://doi.org/10.1016/0096-3003%2889%2990110-0">doi:10.1016/0096-3003(89)90110-0</a>
</p>
<p>P. N. Brown, A. C. Hindmarsh, and L. R. Petzold, Using Krylov
Methods in the Solution of Large-Scale Differential-Algebraic
Systems, SIAM J. Sci. Comp., 15 (1994), pp. 1467-1488.
<a href="https://doi.org/10.1137/0915088">doi:10.1137/0915088</a>
</p>
<p>P. N. Brown, A. C. Hindmarsh, and L. R. Petzold, Consistent
Initial Condition Calculation for Differential-Algebraic
Systems, LLNL Report UCRL-JC-122175, August 1995; submitted to
SIAM J. Sci. Comp.
</p>
<p>Netlib: <a href="https://netlib.org">https://netlib.org</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+radau">radau</a></code> for integrating DAEs up to index 3,
</p>
</li>
<li> <p><code><a href="#topic+rk">rk</a></code>, </p>
</li>
<li> <p><code><a href="#topic+rk4">rk4</a></code> and <code><a href="#topic+euler">euler</a></code> for
Runge-Kutta integrators.
</p>
</li>
<li> <p><code><a href="#topic+lsoda">lsoda</a></code>, <code><a href="#topic+lsode">lsode</a></code>,
<code><a href="#topic+lsodes">lsodes</a></code>, <code><a href="#topic+lsodar">lsodar</a></code>, <code><a href="#topic+vode">vode</a></code>,
for other solvers of the Livermore family,
</p>
</li>
<li> <p><code><a href="#topic+ode">ode</a></code> for a general interface to most of the ODE solvers,
</p>
</li>
<li> <p><code><a href="#topic+ode.band">ode.band</a></code> for solving models with a banded
Jacobian,
</p>
</li>
<li> <p><code><a href="#topic+ode.1D">ode.1D</a></code> for integrating 1-D models,
</p>
</li>
<li> <p><code><a href="#topic+ode.2D">ode.2D</a></code> for integrating 2-D models,
</p>
</li>
<li> <p><code><a href="#topic+ode.3D">ode.3D</a></code> for integrating 3-D models,
</p>
</li></ul>

<p><code><a href="#topic+diagnostics">diagnostics</a></code> to print diagnostic messages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =======================================================================
## Coupled chemical reactions including an equilibrium
## modeled as (1) an ODE and (2) as a DAE
##
## The model describes three chemical species A,B,D:
## subjected to equilibrium reaction D &lt;- &gt; A + B
## D is produced at a constant rate, prod
## B is consumed at 1s-t order rate, r
## Chemical problem formulation 1: ODE
## =======================================================================

## Dissociation constant
K &lt;- 1 

## parameters
pars &lt;- c(
        ka   = 1e6,     # forward rate
        r    = 1,
        prod = 0.1)


Fun_ODE &lt;- function (t, y, pars)
{
  with (as.list(c(y, pars)), {
    ra  &lt;- ka*D        # forward rate
    rb  &lt;- ka/K *A*B   # backward rate

    ## rates of changes
    dD  &lt;- -ra + rb + prod
    dA  &lt;-  ra - rb
    dB  &lt;-  ra - rb - r*B
    return(list(dy = c(dA, dB, dD),
                CONC = A+B+D))
  })
}

## =======================================================================
## Chemical problem formulation 2: DAE
## 1. get rid of the fast reactions ra and rb by taking
## linear combinations   : dD+dA = prod (res1) and
##                         dB-dA = -r*B (res2)
## 2. In addition, the equilibrium condition (eq) reads:
## as ra = rb : ka*D = ka/K*A*B = &gt;      K*D = A*B
## =======================================================================

Res_DAE &lt;- function (t, y, yprime, pars)
{
  with (as.list(c(y, yprime, pars)), {

    ## residuals of lumped rates of changes
    res1 &lt;- -dD - dA + prod
    res2 &lt;- -dB + dA - r*B
    
    ## and the equilibrium equation
    eq   &lt;- K*D - A*B

    return(list(c(res1, res2, eq),
                CONC = A+B+D))
  })
}

## =======================================================================
## Chemical problem formulation 3: Mass * Func
## Based on the DAE formulation
## =======================================================================

Mass_FUN &lt;- function (t, y, pars) {
  with (as.list(c(y, pars)), {

    ## as above, but without the 
    f1 &lt;- prod
    f2 &lt;- - r*B
    
    ## and the equilibrium equation
    f3   &lt;- K*D - A*B

    return(list(c(f1, f2, f3),
                CONC = A+B+D))
  })
}
Mass &lt;- matrix(nrow = 3, ncol = 3, byrow = TRUE, 
  data=c(1,  0, 1,         # dA + 0 + dB
        -1,  1, 0,         # -dA + dB +0
         0,  0, 0))        # algebraic
         
times &lt;- seq(0, 100, by = 2)

## Initial conc; D is in equilibrium with A,B
y     &lt;- c(A = 2, B = 3, D = 2*3/K)

## ODE model solved with daspk
ODE &lt;- daspk(y = y, times = times, func = Fun_ODE,
                     parms = pars, atol = 1e-10, rtol = 1e-10)

## Initial rate of change
dy  &lt;- c(dA = 0, dB = 0, dD = 0) 

## DAE model solved with daspk
DAE &lt;- daspk(y = y, dy = dy, times = times,
         res = Res_DAE, parms = pars, atol = 1e-10, rtol = 1e-10)

MASS&lt;- daspk(y=y, times=times, func = Mass_FUN, parms = pars, mass = Mass)

## ================
## plotting output
## ================

plot(ODE, DAE, xlab = "time", ylab = "conc", type = c("l", "p"),
     pch = c(NA, 1))

legend("bottomright", lty = c(1, NA), pch = c(NA, 1),
  col = c("black", "red"), legend = c("ODE", "DAE"))

# difference between both implementations:
max(abs(ODE-DAE))

## =======================================================================
## same DAE model, now with the Jacobian
## =======================================================================
jacres_DAE &lt;- function (t, y, yprime, pars, cj)
{
    with (as.list(c(y, yprime, pars)), {
##    res1 = -dD - dA + prod
      PD[1,1] &lt;- -1*cj      # d(res1)/d(A)-cj*d(res1)/d(dA)
      PD[1,2] &lt;- 0          # d(res1)/d(B)-cj*d(res1)/d(dB)
      PD[1,3] &lt;- -1*cj      # d(res1)/d(D)-cj*d(res1)/d(dD)
##     res2 = -dB + dA - r*B
      PD[2,1] &lt;- 1*cj
      PD[2,2] &lt;- -r -1*cj
      PD[2,3] &lt;- 0
##    eq = K*D - A*B
      PD[3,1] &lt;- -B
      PD[3,2] &lt;- -A
      PD[3,3] &lt;- K
      return(PD)
   })
}

PD &lt;- matrix(ncol = 3, nrow = 3, 0)

DAE2 &lt;- daspk(y = y, dy = dy, times = times,
          res = Res_DAE, jacres = jacres_DAE, jactype = "fullusr",
          parms = pars, atol = 1e-10, rtol = 1e-10)
         
max(abs(DAE-DAE2))

## See \dynload subdirectory for a FORTRAN implementation of this model

## =======================================================================
## The chemical model as a DLL, with production a forcing function
## =======================================================================
times &lt;- seq(0, 100, by = 2)

pars &lt;- c(K = 1, ka   = 1e6, r    = 1)

## Initial conc; D is in equilibrium with A,B
y     &lt;- c(A = 2, B = 3, D = as.double(2*3/pars["K"]))

## Initial rate of change
dy  &lt;- c(dA = 0, dB = 0, dD = 0)

# production increases with time
prod &lt;- matrix(ncol = 2, 
               data = c(seq(0, 100, by = 10), 0.1*(1+runif(11)*1)))

ODE_dll &lt;- daspk(y = y, dy = dy, times = times, res = "chemres",
          dllname = "deSolve", initfunc = "initparms",
          initforc = "initforcs", parms = pars, forcings = prod,
          atol = 1e-10, rtol = 1e-10, nout = 2, 
          outnames = c("CONC","Prod"))

plot(ODE_dll, which = c("Prod", "D"), xlab = "time",
     ylab = c("/day", "conc"), main = c("production rate","D"))

</code></pre>

<hr>
<h2 id='dede'>
General Solver for Delay Differential Equations.
</h2><span id='topic+dede'></span>

<h3>Description</h3>

<p>Function <code>dede</code> is a general solver for delay differential equations, i.e.
equations where the derivative depends on past values of the state variables
or their derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dede(y, times, func=NULL, parms,
    method = c( "lsoda", "lsode", "lsodes", "lsodar", "vode",
       "daspk", "bdf", "adams", "impAdams", "radau"), control = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dede_+3A_y">y</code></td>
<td>
<p>the initial (state) values for the DE system, a vector. If
<code>y</code> has a name attribute, the names will be used to label the
output matrix.
</p>
</td></tr>
<tr><td><code id="dede_+3A_times">times</code></td>
<td>
<p>time sequence for which output is wanted; the first
value of <code>times</code> must be the initial time.
</p>
</td></tr>
<tr><td><code id="dede_+3A_func">func</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span>-function that computes the values of the
derivatives in the ODE system (the model definition) at time <code class="reqn">t</code>.
</p>
<p><code>func</code> must be defined as:
<code>func &lt;- function(t, y, parms, ...)</code>.  <code>t</code> is the current time
point in the integration, <code>y</code> is the current estimate of the
variables in the DE system.  If the initial values <code>y</code> has a
<code>names</code> attribute, the names will be available inside <code>func</code>.
<code>parms</code> is a vector or list of parameters; <code>...</code> (optional) are
any other arguments passed to the function.
</p>
<p>The return value of <code>func</code> should be a list, whose first
element is a vector containing the derivatives of <code>y</code> with
respect to <code>time</code>, and whose next elements are global values
that are required at each point in <code>times</code>.The derivatives
must be specified in the <b>same order</b> as the state variables <code>y</code>.
</p>
<p>If method &quot;daspk&quot; is used, then <code>func</code> can be <code>NULL</code>, in which
case <code>res</code> should be used.
</p>
</td></tr>
<tr><td><code id="dede_+3A_parms">parms</code></td>
<td>
<p>parameters passed to <code>func</code>.
</p>
</td></tr>
<tr><td><code id="dede_+3A_method">method</code></td>
<td>
<p>the integrator to use, either a string (<code>"lsoda"</code>,
<code>"lsode"</code>, <code>"lsodes"</code>, <code>"lsodar"</code>, <code>"vode"</code>,
<code>"daspk"</code>, <code>"bdf"</code>, <code>"adams"</code>, <code>"impAdams"</code>, <code>"radau"</code>)
or a function that performs the integration.
The default integrator used is <a href="#topic+lsoda">lsoda</a>.
</p>
</td></tr>
<tr><td><code id="dede_+3A_control">control</code></td>
<td>
<p>a list that can supply (1) the size of the history array, as
<code>control$mxhist</code>; the default is 1e4 and (2) how to interpolate, as
<code>control$interpol</code>, where <code>1</code> is  hermitian interpolation,
<code>2</code> is variable order interpolation, using the Nordsieck history array.
Only for the two Adams methods is the second option recommended.
</p>
</td></tr>
<tr><td><code id="dede_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the integrator.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions <a href="#topic+lagvalue">lagvalue</a> and <a href="#topic+lagderiv">lagderiv</a> are to be used with <code>dede</code>
as they provide access to past (lagged)
values of state variables and derivatives.  The number of past values that
are to be stored in a history matrix, can be specified in <code>control$mxhist</code>.
The default value (if unspecified) is 1e4.
</p>
<p>Cubic Hermite interpolation is used by default to obtain an accurate
interpolant at the requested lagged time. For methods <code>adams, impAdams</code>,
a more accurate interpolation method can be triggered by setting
<code>control$interpol = 2</code>.
</p>
<p><code>dede</code> does not deal explicitly with propagated derivative discontinuities,
but relies on the integrator to control the stepsize in the region of a
discontinuity.
</p>
<p><code>dede</code> does not include methods to deal with delays that are smaller than the
stepsize, although in some cases it may be possible to solve such models.
</p>
<p>For these reasons, it can only solve rather simple delay differential equations.
</p>
<p>When used together with integrator <code>lsodar</code>, or <code>lsode</code>, <code>dde</code>
can simultaneously locate a root, and trigger an event. See last example.
</p>


<h3>Value</h3>

<p>A matrix of class <code>deSolve</code> with up to as many rows as elements in
<code>times</code> and as many
columns as elements in <code>y</code> plus the number of &quot;global&quot; values
returned in the second element of the return from <code>func</code>, plus an
additional column (the first) for the time value.  There will be one
row for each element in <code>times</code> unless the integrator returns
with an unrecoverable error.  If <code>y</code> has a names attribute, it
will be used to label the columns of the output value.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>See Also</h3>

<p><a href="#topic+lagvalue">lagvalue</a>, <a href="#topic+lagderiv">lagderiv</a>,for how to specify lagged variables and
derivatives.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =============================================================================
## A simple delay differential equation
## dy(t) = -y(t-1) ; y(t&lt;0)=1
## =============================================================================

##-----------------------------
## the derivative function
##-----------------------------
derivs &lt;- function(t, y, parms) {
  if (t &lt; 1)
    dy &lt;- -1
  else
    dy &lt;- - lagvalue(t - 1)
  list(c(dy))
}

##-----------------------------
## initial values and times
##-----------------------------
yinit &lt;- 1
times &lt;- seq(0, 30, 0.1)

##-----------------------------
## solve the model
##-----------------------------
yout &lt;- dede(y = yinit, times = times, func = derivs, parms = NULL)

##-----------------------------
## display, plot results
##-----------------------------
plot(yout, type = "l", lwd = 2, main = "dy/dt = -y(t-1)")

## =============================================================================
## The infectuous disease model of Hairer; two lags.
## example 4 from Shampine and Thompson, 2000
## solving delay differential equations with dde23
## =============================================================================

##-----------------------------
## the derivative function
##-----------------------------
derivs &lt;- function(t,y,parms) {
  if (t &lt; 1)
    lag1 &lt;- 0.1
  else
    lag1 &lt;- lagvalue(t - 1,2)
  if (t &lt; 10)
    lag10 &lt;- 0.1
  else
    lag10 &lt;- lagvalue(t - 10,2)

  dy1 &lt;- -y[1] * lag1 + lag10
  dy2 &lt;-  y[1] * lag1 - y[2]
  dy3 &lt;-  y[2] - lag10
  list(c(dy1, dy2, dy3))
}

##-----------------------------
## initial values and times
##-----------------------------
yinit &lt;- c(5, 0.1, 1)
times &lt;- seq(0, 40, by = 0.1)

##-----------------------------
## solve the model
##-----------------------------
system.time(
  yout &lt;- dede(y = yinit, times = times, func = derivs, parms = NULL)
)

##-----------------------------
## display, plot results
##-----------------------------
matplot(yout[,1], yout[,-1], type = "l", lwd = 2, lty = 1,
  main = "Infectuous disease - Hairer")

## =============================================================================
## time lags + EVENTS triggered by a root function
## The two-wheeled suitcase model
## example 8 from Shampine and Thompson, 2000
## solving delay differential equations with dde23
## =============================================================================

##-----------------------------
## the derivative function
##-----------------------------
derivs &lt;- function(t, y, parms) {
  if (t &lt; tau)
    lag &lt;- 0
  else
    lag &lt;- lagvalue(t - tau)

  dy1 &lt;- y[2]
  dy2 &lt;- -sign(y[1]) * gam * cos(y[1]) +
          sin(y[1]) - bet * lag[1] + A * sin(omega * t + mu)
  list(c(dy1, dy2))
}

## root and event function
root &lt;- function(t,y,parms) ifelse(t&gt;0, return(y), return(1))
event &lt;- function(t,y,parms) return(c(y[1], y[2]*0.931))

gam = 0.248; bet = 1; tau = 0.1; A = 0.75
omega = 1.37; mu = asin(gam/A)

##-----------------------------
## initial values and times
##-----------------------------
yinit &lt;- c(y = 0, dy = 0)
times &lt;- seq(0, 12, len = 1000)

##-----------------------------
## solve the model
##-----------------------------
## Note: use a solver that supports both root finding and events,
##       e.g. lsodar, lsode, lsoda, adams, bdf
yout &lt;- dede(y = yinit, times = times, func = derivs, parms = NULL,
  method = "lsodar", rootfun = root, events = list(func = event, root = TRUE))

##-----------------------------
## display, plot results
##-----------------------------

plot(yout, which = 1, type = "l", lwd = 2, main = "suitcase model", mfrow = c(1,2))
plot(yout[,2], yout[,3], xlab = "y", ylab = "dy", type = "l", lwd = 2)

</code></pre>

<hr>
<h2 id='deSolve-internal'>Internal deSolve Functions</h2><span id='topic+timestep'></span>

<h3>Description</h3>

<p>Internal deSolve functions, these are not to be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timestep(prev = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deSolve-internal_+3A_prev">prev</code></td>
<td>
<p>if <code>TRUE</code> will return the timestep previously used;
when <code>FALSE</code> will return the time step to be currently tried by 
the integrator.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>timestep</code> is intended to return the current or next
timestep of the integration.  It works only under specific
circumstances and should not be used by the end user.
</p>
<p>Instead of this, please see the example below for a pure
<span class="rlang"><b>R</b></span> solution.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diagnostics">diagnostics</a></code> for information about the time steps used,<br />
<code><a href="#topic+lagvalue">lagvalue</a></code> and <code><a href="#topic+lagderiv">lagderiv</a></code> that can be used for DDEs. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###################################################
### This example shows how to retrieve information 
### about the used time steps.
###################################################

## a function closure  ('lexical scoping')
modelClosure &lt;- function(t0) {
  t.old &lt;- t.act &lt;- t0
  function(t, y, parms) {
    t.old  &lt;&lt;- t.act
    t.act  &lt;&lt;- t
    cat(t, "\t", t - t.old, "\n")
    with (as.list(c(y, parms)), {
      dP &lt;- a * P      -  b * P * K
      dK &lt;- b * P * K  -  c * K
      list(c(dP, dK))
    })
  }
}

model &lt;- modelClosure(0) # initialization

parms &lt;- c(a = 0.1, b = 0.1, c = 0.1)

y &lt;- c(P = 1, K = 2)

out &lt;- ode(y = y, func = model, times = c(0, 2),
 parms = parms, method = "lsoda")

ls() # prove that t.old and t.new are local within 'model' 
</code></pre>

<hr>
<h2 id='deSolve-package'>
General Solvers for Initial Value Problems of Ordinary Differential Equations
(ODE), Partial Differential Equations (PDE), Differential Algebraic
Equations (DAE) and delay differential equations (DDE).
</h2><span id='topic+deSolve-package'></span><span id='topic+deSolve'></span>

<h3>Description</h3>

<p>Functions that solve initial value problems of a system of
first-order ordinary differential equations (ODE), of partial
differential equations (PDE), of differential algebraic equations (DAE)
and delay differential equations.
</p>
<p>The functions provide an interface to the FORTRAN functions lsoda,
lsodar, lsode, lsodes of the ODEPACK collection,
to the FORTRAN functions dvode, zvode and daspk, and a C-implementation of
solvers of the Runge-Kutta family with fixed or variable time steps.
</p>
<p>The package contains routines designed for solving ODEs
resulting from 1-D, 2-D and 3-D partial differential equations (PDE)
that have been converted to ODEs by numerical differencing.
It includes root-finding (or event location) and provides access to lagged
variables and derivatives.
</p>
<p>The system of differential equations is written as an <span class="rlang"><b>R</b></span> function or
defined in compiled code that has been dynamically loaded, see
package vignette <a href="../doc/compiledCode.pdf">compiledCode</a> for details. The
solvers may be used as part of a modeling package for differential
equations, or for parameter estimation using any appropriate
modeling tool for non-linear models in <span class="rlang"><b>R</b></span> such as
<code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="stats.html#topic+nls">nls</a></code>, <code><a href="stats.html#topic+nlm">nlm</a></code> or
<code><a href="nlme.html#topic+nlme">nlme</a></code>, or <code><a href="FME.html#topic+FME">FME</a></code>.
</p>
<p><b>Package Vignettes, Examples, Online Resources</b>
</p>

<ul>
<li><p> Solving Initial Value Differential Equations in R
(<a href="../doc/deSolve.pdf">pdf</a>, <a href="../doc/deSolve.R">R code</a>)
</p>
</li>
<li><p> Writing Code in Compiled Languages
(<a href="../doc/compiledCode.pdf">pdf</a>, <a href="../doc/compiledCode.R">R code</a>)
</p>
</li>
<li><p> Examples in R (<a href="../doc/examples">code</a>), and in Fortran or C (<a href="../doc/dynload">doc/dynload</a>, <a href="../doc/dynload-dede">doc/dynload-dede</a>)
</p>
</li>
<li><p> deSolve homepage: <a href="https://desolve.r-forge.r-project.org">https://desolve.r-forge.r-project.org</a> (Papers, Books, PDFs)
</p>
</li>
<li><p> Mailing list: <a href="mailto:r-sig-dynamic-models@r-project.org">mailto:r-sig-dynamic-models@r-project.org</a>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Karline Soetaert, Thomas Petzoldt, R. Woodrow Setzer
</p>


<h3>References</h3>

<p>Karline Soetaert, Thomas Petzoldt, R. Woodrow Setzer (2010):  Solving
Differential Equations in R: Package deSolve Journal of Statistical
Software, 33(9), 1&ndash;25.  <a href="https://doi.org/10.18637/jss.v033.i09">doi:10.18637/jss.v033.i09</a>
</p>
<p>Karline Soetaert, Thomas Petzoldt, R. Woodrow Setzer (2010): Solving
differential equations in R. The R Journal 2(2), 5-15.
<a href="https://doi.org/10.32614/RJ-2010-013">doi:10.32614/RJ-2010-013</a>
</p>
<p>Karline Soetaert, Thomas Petzoldt (2011): Solving ODEs, DAEs, DDEs and
PDEs in R. Journal of Numerical Analysis, Industrial and Applied
Mathematics (JNAIAM) 6(1-2),
51-65. 
</p>
<p>Karline Soetaert, Jeff Cash, Francesca Mazzia, (2012):
Solving Differential Equations in R. Springer, 248 pp.
</p>
<p>Alan C. Hindmarsh (1983): ODEPACK, A Systematized Collection of ODE
Solvers, in Scientific Computing, R. S. Stepleman et al. (Eds.),
North-Holland, Amsterdam, pp. 55-64.
</p>
<p>L. R. Petzold, (1983):  A Description of DASSL: A Differential/Algebraic
System Solver, in Scientific Computing, R. S. Stepleman et al. (Eds.),
North-Holland, Amsterdam, pp. 65-68.
</p>
<p>P. N. Brown, G. D. Byrne, A. C. Hindmarsh (1989):  VODE: A Variable
Coefficient ODE Solver, SIAM J. Sci. Stat. Comput., 10, pp. 1038-1051.
<a href="https://doi.org/10.1137/0910062">doi:10.1137/0910062</a>
</p>
<p>See also the references given on the specific help pages of the
different methods.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ode">ode</a></code> for a general interface to most of the ODE solvers,
</p>
<p><code><a href="#topic+ode.band">ode.band</a></code> for solving models with a banded Jacobian,
</p>
<p><code><a href="#topic+ode.1D">ode.1D</a></code>, <code><a href="#topic+ode.2D">ode.2D</a></code>, <code><a href="#topic+ode.3D">ode.3D</a></code>,
for integrating 1-D, 2-D and 3-D models,
</p>
<p><code><a href="#topic+dede">dede</a></code> for a general interface to the delay differential
equation solvers,
</p>
<p><code><a href="#topic+lsoda">lsoda</a></code>, <code><a href="#topic+lsode">lsode</a></code>,
<code><a href="#topic+lsodes">lsodes</a></code>, <code><a href="#topic+lsodar">lsodar</a></code>, <code><a href="#topic+vode">vode</a></code>,
for ODE solvers of the Livermore family,
</p>
<p><code><a href="#topic+daspk">daspk</a></code>, for a DAE solver up to index 1, of the Livermore family,
</p>
<p><code><a href="#topic+radau">radau</a></code> for integrating DAEs up to index 3 using an implicit
Runge-Kutta,
</p>
<p><code><a href="#topic+rk">rk</a></code>, <code><a href="#topic+rkMethod">rkMethod</a></code>, <code><a href="#topic+rk4">rk4</a></code>,
<code><a href="#topic+euler">euler</a></code> for Runge-Kutta solvers,
</p>
<p><code><a href="#topic+DLLfunc">DLLfunc</a></code>, <code><a href="#topic+DLLres">DLLres</a></code>, for testing model implementations
in compiled code,
</p>
<p><code><a href="#topic+forcings">forcings</a></code>,  <code><a href="#topic+events">events</a></code>, for how to implement forcing
functions (external variables) and events (sudden changes in state variables),
</p>
<p><code><a href="#topic+lagvalue">lagvalue</a></code>, <code><a href="#topic+lagderiv">lagderiv</a></code>, for how to get access to
lagged values of state variables and derivatives.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(deSolve)

## Chaos in the atmosphere
Lorenz &lt;- function(t, state, parameters) {
  with(as.list(c(state, parameters)), {
    dX &lt;-  a * X + Y * Z
    dY &lt;-  b * (Y - Z)
    dZ &lt;- -X * Y + c * Y - Z
    list(c(dX, dY, dZ))
  })
}

parameters &lt;- c(a = -8/3, b = -10, c = 28)
state      &lt;- c(X = 1, Y = 1, Z = 1)
times      &lt;- seq(0, 100, by = 0.01)

out &lt;- ode(y = state, times = times, func = Lorenz, parms = parameters)

plot(out)

## add a 3D figure if package scatterplot3D is available
if (require(scatterplot3d))
  scatterplot3d(out[,-1], type = "l")

</code></pre>

<hr>
<h2 id='diagnostics'>Print Diagnostic Characteristics of Solvers</h2><span id='topic+diagnostics'></span><span id='topic+diagnostics.default'></span>

<h3>Description</h3>

<p>Prints several diagnostics of the simulation to the screen, e.g.
number of steps taken, the last step size, ...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnostics(obj, ...)
## Default S3 method:
diagnostics(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnostics_+3A_obj">obj</code></td>
<td>
<p>is an output data structure produced by one of the
solver routines.
</p>
</td></tr>
<tr><td><code id="diagnostics_+3A_...">...</code></td>
<td>
<p>optional arguments allowing to extend <code>diagnostics</code>
as a generic function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Detailed information obout the success of a simulation is printed,
if a <code>diagnostics</code> function exists for a specific solver routine.
A warning is printed, if no class-specific diagnostics exists.
</p>
<p>Please consult the class-specific help page for details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diagnostics.deSolve">diagnostics.deSolve</a></code> for diagnostics of differential
equaton solvers.



</p>

<hr>
<h2 id='diagnostics.deSolve'>Print Diagnostic Characteristics of ODE and DAE Solvers</h2><span id='topic+diagnostics.deSolve'></span>

<h3>Description</h3>

<p>Prints several diagnostics of the simulation to the screen, e.g.
number of steps taken, the last step size, ...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'deSolve'
diagnostics(obj, Full = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnostics.deSolve_+3A_obj">obj</code></td>
<td>
<p>is the output matrix as produced by one of the
integration routines.
</p>
</td></tr>
<tr><td><code id="diagnostics.deSolve_+3A_full">Full</code></td>
<td>
<p>when <code>TRUE</code> then all messages will be printed, including
the ones that are not relevant for the solver. If <code>FALSE</code>, then only
the relevant messages will be printed.
</p>
</td></tr>
<tr><td><code id="diagnostics.deSolve_+3A_...">...</code></td>
<td>
<p>optional arguments allowing to extend <code>diagnostics</code>
as a generic function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the integration output is saved as a <code>data.frame</code>, then the required
attributes are lost and method <code>diagnostics</code> will not work anymore.
</p>


<h3>Value</h3>

<p>The integer and real vector with diagnostic values; for function <code>lsodar</code>
also the root information.
</p>
<p>See tables 2 and 3 in vignette(&quot;deSolve&quot;) for what these vectors contain.
</p>
<p>Note: the number of function evaluations are *without* the extra calls 
performed to generate the ordinary output variables (if present). 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The famous Lorenz equations: chaos in the earth's atmosphere
## Lorenz 1963. J. Atmos. Sci. 20, 130-141.

chaos &lt;- function(t, state, parameters) {
  with(as.list(c(state)), {

    dx     &lt;- -8/3 * x + y * z
    dy     &lt;- -10 * (y - z)
    dz     &lt;- -x * y + 28 * y - z

    list(c(dx, dy, dz))
  })
}

state &lt;- c(x = 1, y = 1, z = 1)
times &lt;- seq(0, 50, 0.01)
out   &lt;- vode(state, times, chaos, 0)
pairs(out, pch = ".")
diagnostics(out)
</code></pre>

<hr>
<h2 id='DLLfunc'>Evaluates a Derivative Function Represented in a DLL</h2><span id='topic+DLLfunc'></span>

<h3>Description</h3>

<p>Calls a function, defined in a compiled language as a DLL</p>


<h3>Usage</h3>

<pre><code class='language-R'>DLLfunc(func, times, y, parms, dllname,
  initfunc = dllname, rpar = NULL, ipar = NULL, nout = 0,
  outnames = NULL, forcings = NULL, initforc = NULL,
  fcontrol = NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DLLfunc_+3A_func">func</code></td>
<td>
<p>the name of the function in the dynamically loaded
shared library,
</p>
</td></tr>
<tr><td><code id="DLLfunc_+3A_times">times</code></td>
<td>
<p>first value = the time at which the function needs to be
evaluated,
</p>
</td></tr>
<tr><td><code id="DLLfunc_+3A_y">y</code></td>
<td>
<p>the values of the dependent variables for which the function
needs to be evaluated,
</p>
</td></tr>
<tr><td><code id="DLLfunc_+3A_parms">parms</code></td>
<td>
<p>the parameters that are passed to the initialiser function,
</p>
</td></tr>
<tr><td><code id="DLLfunc_+3A_dllname">dllname</code></td>
<td>
<p>a string giving the name of the shared library (without
extension) that contains the compiled function or subroutine definitions
referred to in <code>func</code>,
</p>
</td></tr>
<tr><td><code id="DLLfunc_+3A_initfunc">initfunc</code></td>
<td>
<p>if not <code>NULL</code>, the name of the initialisation function
(which initialises values of parameters), as provided in &lsquo;<span class="file">dllname</span>&rsquo;.
See details.
</p>
</td></tr>
<tr><td><code id="DLLfunc_+3A_rpar">rpar</code></td>
<td>
<p>a vector with double precision values passed to the
DLL-function <code>func</code> and <code>jacfunc</code> present in the DLL, via
argument rpar,
</p>
</td></tr>
<tr><td><code id="DLLfunc_+3A_ipar">ipar</code></td>
<td>
<p>a vector with integer values passed to the dll-function
<code>func</code> and <code>jacfunc</code> present in the DLL, via function argument
ipar,
</p>
</td></tr>
<tr><td><code id="DLLfunc_+3A_nout">nout</code></td>
<td>
<p>the number of output variables.
</p>
</td></tr>
<tr><td><code id="DLLfunc_+3A_outnames">outnames</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified and
<code>nout</code> &gt; 0: the names of output variables calculated in the
compiled function <code>func</code>, present in the shared library.
</p>
</td></tr>
<tr><td><code id="DLLfunc_+3A_forcings">forcings</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified: a list with
the forcing function data sets, each present as a two-columned matrix,
with (time, value); interpolation outside the interval
[min(<code>times</code>), max(<code>times</code>)] is done by taking the value at
the closest data extreme.
</p>
<p>See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="DLLfunc_+3A_initforc">initforc</code></td>
<td>
<p>if not <code>NULL</code>, the name of the forcing function
initialisation function, as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. It MUST be present if <code>forcings</code> has been given a
value.
See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="DLLfunc_+3A_fcontrol">fcontrol</code></td>
<td>
<p>A list of control parameters for the forcing functions.
See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is meant to help developing FORTRAN or C models that are
to be used to solve ordinary differential equations (ODE) in packages
<code>deSolve</code> and/or <code>rootSolve</code>.
</p>


<h3>Value</h3>

<p>a list containing:
</p>
<table>
<tr><td><code>dy</code></td>
<td>
<p>the rate of change estimated by the function,
</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>the ordinary output variables of the function.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+ode">ode</a></code> for a general interface to most of the ODE solvers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ==========================================================================
## ex. 1
## ccl4model
## ==========================================================================
## Parameter values and initial conditions
## see example(ccl4model) for a more comprehensive implementation

Parms &lt;- c(0.182, 4.0, 4.0, 0.08, 0.04, 0.74, 0.05, 0.15, 0.32,
        16.17, 281.48, 13.3, 16.17, 5.487, 153.8, 0.04321671,
        0.4027255, 1000, 0.02, 1.0, 3.8)

yini &lt;- c(AI = 21, AAM = 0, AT = 0, AF = 0, AL = 0, CLT = 0,  AM = 0)

## the rate of change
DLLfunc(y = yini, dllname = "deSolve", func = "derivsccl4",
        initfunc = "initccl4", parms = Parms, times = 1,
        nout = 3, outnames = c("DOSE", "MASS", "CP")  )

## ==========================================================================
## ex. 2
## SCOC model
## ==========================================================================

## Forcing function "data"
Flux  &lt;- matrix(ncol = 2, byrow = TRUE, data = c(1, 0.654, 2, 0.167))
parms &lt;- c(k = 0.01)
Yini  &lt;- 60

DLLfunc(y=Yini, times=1, func = "scocder",
    parms = parms, dllname = "deSolve",
    initforc = "scocforc",  forcings = Flux,
    initfunc = "scocpar", nout = 2,
    outnames = c("Mineralisation","Depo"))
## correct value = dy = flux - k * y = 0.654 - 0.01 * 60

DLLfunc(y = Yini, times = 2, func = "scocder",
    parms = parms, dllname = "deSolve",
    initforc = "scocforc",  forcings = Flux,
    initfunc = "scocpar", nout = 2,
    outnames = c("Mineralisation", "Depo"))
</code></pre>

<hr>
<h2 id='DLLres'>Evaluates a Residual Derivative Function Represented in a DLL
</h2><span id='topic+DLLres'></span>

<h3>Description</h3>

<p>Calls a residual function, <code class="reqn">F(t,y,y')</code> of a DAE system
(differential algebraic equations) defined in a compiled language as a
DLL.
</p>
<p>To be used for testing the implementation of DAE problems in compiled code
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DLLres(res, times, y, dy, parms, dllname,
  initfunc = dllname, rpar = NULL, ipar = NULL, nout = 0,
  outnames = NULL, forcings = NULL, initforc = NULL,
  fcontrol = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DLLres_+3A_res">res</code></td>
<td>
<p>the name of the function in the dynamically loaded
shared library,
</p>
</td></tr>
<tr><td><code id="DLLres_+3A_times">times</code></td>
<td>
<p>first value = the time at which the function needs to be
evaluated,
</p>
</td></tr>
<tr><td><code id="DLLres_+3A_y">y</code></td>
<td>
<p>the values of the dependent variables for which the function needs
to be evaluated,
</p>
</td></tr>
<tr><td><code id="DLLres_+3A_dy">dy</code></td>
<td>
<p>the derivative of the values of the dependent variables for
which the function needs to be evaluated,
</p>
</td></tr>
<tr><td><code id="DLLres_+3A_parms">parms</code></td>
<td>
<p>the parameters that are passed to the initialiser function,
</p>
</td></tr>
<tr><td><code id="DLLres_+3A_dllname">dllname</code></td>
<td>
<p>a string giving the name of the shared library (without
extension) that contains the compiled function or subroutine definitions
referred to in <code>func</code>,
</p>
</td></tr>
<tr><td><code id="DLLres_+3A_initfunc">initfunc</code></td>
<td>
<p>if not NULL, the name of the initialisation function
(which initialises values of parameters), as provided in &lsquo;<span class="file">dllname</span>&rsquo;.
See details,
</p>
</td></tr>
<tr><td><code id="DLLres_+3A_rpar">rpar</code></td>
<td>
<p>a vector with double precision values passed to the
DLL-function <code>func</code> and <code>jacfunc</code> present in the DLL, via
argument <code>rpar</code>,
</p>
</td></tr>
<tr><td><code id="DLLres_+3A_ipar">ipar</code></td>
<td>
<p>a vector with integer values passed to the DLL-function
<code>func</code> and <code>jacfunc</code> present in the DLL, via function argument
<code>ipar</code>,
</p>
</td></tr>
<tr><td><code id="DLLres_+3A_nout">nout</code></td>
<td>
<p>the number of output variables.
</p>
</td></tr>
<tr><td><code id="DLLres_+3A_outnames">outnames</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified and
<code>nout</code> &gt; 0: the names of output variables calculated in the
compiled function <code>func</code>, present in the shared library.
</p>
</td></tr>
<tr><td><code id="DLLres_+3A_forcings">forcings</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified: a list with
the forcing function data sets, each present as a two-columned matrix,
with (time,value); interpolation outside the interval
[min(<code>times</code>), max(<code>times</code>)] is done by taking the value at
the closest data extreme.
</p>
<p>See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="DLLres_+3A_initforc">initforc</code></td>
<td>
<p>if not <code>NULL</code>, the name of the forcing function
initialisation function, as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. It MUST be present if <code>forcings</code> has been given a
value.
See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="DLLres_+3A_fcontrol">fcontrol</code></td>
<td>
<p>A list of control parameters for the forcing functions.
See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is meant to help developing FORTRAN or C models that are to be
used to solve differential algebraic equations (DAE) in
package <code>deSolve</code>.
</p>


<h3>Value</h3>

<p>a list containing:
</p>
<table>
<tr><td><code>res</code></td>
<td>
<p>the residual of derivative estimated by the function</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>the ordinary output variables of the function</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>See Also</h3>

<p><a href="#topic+daspk">daspk</a> to solve DAE problems
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =========================================================================
## Residuals from the daspk chemical model, production a forcing function
## =========================================================================
## Parameter values and initial conditions
## see example(daspk) for a more comprehensive implementation

pars &lt;- c(K = 1, ka = 1e6, r = 1)

## Initial conc; D is in equilibrium with A,B
y &lt;- c(A = 2, B = 3, D = 2 * 3/pars["K"])

## Initial rate of change
dy &lt;- c(dA = 0, dB = 0, dD = 0)

## production increases with time
prod &lt;- matrix(ncol = 2,
          data = c(seq(0, 100, by = 10), seq(0.1, 0.5, len = 11)))

DLLres(y = y, dy = dy, times = 5, res = "chemres",
          dllname = "deSolve", initfunc = "initparms",
          initforc = "initforcs", parms = pars, forcings = prod,
          nout = 2, outnames = c("CONC", "Prod"))

</code></pre>

<hr>
<h2 id='events'>
Implementing Events and Roots in Differential Equation Models.
</h2><span id='topic+events'></span><span id='topic+roots'></span>

<h3>Description</h3>

<p>An <code>event</code> occurs when the value of a state variable is suddenly
changed, e.g. because a value is added, subtracted, or multiplied. The
integration routines cannot deal easily with such state variable
changes. Typically these events occur only at specific times.  In
<code>deSolve</code>, events can be imposed by means of an input data.frame,
that specifies at which time and how a certain state variable is altered,
or via an event function.
</p>
<p>Roots occur when a root function becomes zero. By default when a root is
found, the simulation either stops (no event), or triggers an event.
</p>


<h3>Details</h3>

<p>The <code>events</code> are specified by means of argument <code>events</code>
passed to the integration routines.
</p>
<p><code>events</code> should be a list that contains one of the following:
</p>

<dl>
<dt>func: </dt><dd><p>an R-function or the name of a function in compiled
code that specifies the event,
</p>
</dd>
<dt>data: </dt><dd><p>a data.frame that specifies the state variables, times, values and
types of the events. Note that the event times must also
be part of the integration output times, else the event will not take
place. As from version 1.9.1, this is checked by the solver,
and a warning message is produced if event times are missing in times;
see also <code><a href="#topic+cleanEventTimes">cleanEventTimes</a></code> for utility functions
to check and solve such issues.
</p>
</dd>
<dt>time: </dt><dd><p>when events are specified by an event function: the times at
which the events take place. Note that these event times must also
be part of the integration output times exactly, else the event
would not take place. As from version 1.9.1 this is checked by the solver,
and an error message produced if event times are missing in times;
see also <code><a href="#topic+cleanEventTimes">cleanEventTimes</a></code> for utility functions
to check and solve such issues.
</p>
</dd>
<dt>root: </dt><dd><p>when events are specified by a function and triggered
by a root, this logical should be set equal to <code>TRUE</code>
</p>
</dd>
<dt>terminalroot: </dt><dd><p>when events are triggered by a root, the default is
that the simulation continues after the event is executed. In
<code>terminalroot</code>, we can specify which roots should terminate the
simulation.
</p>
</dd>
<dt>maxroot: </dt><dd><p>when <code>root = TRUE</code>, the maximal number of
times at with a root is found and that are kept; defaults to 100.  If
the number of roots &gt; <code>maxroot</code>, then only the first
<code>maxroot</code> will be outputted.
</p>
</dd>
<dt>ties: </dt><dd><p>if events, as specified by a data.frame are &quot;ordered&quot;,
set to &quot;ordered&quot;, the default is &quot;notordered&quot;. This will save
some computational time.
</p>
</dd>
</dl>

<p>In case the events are specified by means of an <span class="rlang"><b>R</b></span> <b>function</b>
(argument <code>events$func</code>),
it must be defined as: <code>function(t, y, parms, ...)</code>.
<code>t</code> is the current time point in the integration,
<code>y</code> is the current estimate of the variables in the ODE system.
If the initial values <code>y</code> has a <code>names</code> attribute, the
names will be available inside <code>events$func</code>.  <code>parms</code> is a
vector or list of parameters; <code>...</code> (optional) are any other
arguments passed to the function via the call to the integration method.
The event function should return the y-values (some of which modified),
as a <em>vector</em>.
</p>
<p>If <code>events$func</code> is a string, this indicates that the events are
specified by a <code>function</code> in compiled code. This function has as
arguments, the number of state variables, the time, and the state
variable vector. See package vignette &quot;compiledCode&quot; for more details.
</p>
<p>In case events are specified by an <span class="rlang"><b>R</b></span>-function,
this requires either: input of the <em>time</em> of the events, a vector as
defined in <code>events$time</code>
OR the specification of a <em>root</em> function.  In the
latter case, the model must be solved with an integration routine
with root-finding capability
</p>
<p>The root function itself should be  specified with argument <code>rootfunc</code>.
In this case, the integrator is informed that the simulation it to be
continued after a root is found by
setting <code>events$root</code> equal to <code>TRUE</code>.
</p>
<p>If the events are specified by a <b>data frame</b>
(argument <code>events$data</code>), this should
contain the following columns (and in that order):
</p>

<dl>
<dt>var: </dt><dd><p>the state variable <em>name</em> or <em>number</em> that is affected
by the event</p>
</dd>
<dt>time: </dt><dd><p>the time at which the event is to take place; the solvers will
check if the time is embraced by the simulation time</p>
</dd>
<dt>value: </dt><dd><p>the value, magnitude of the event</p>
</dd>
<dt>method: </dt><dd><p>which event is to take place; should be one of (&quot;replace&quot;,
&quot;add&quot;, &quot;multiply&quot;); also allowed is to specify the number
(1 = replace, 2 = add, 3 = multiply)
</p>
</dd>
</dl>

<p>For instance, the following line
</p>
<p><code>"v1"  10  2  "add"</code>
</p>
<p>will cause the value 2 to be added to a state variable, called <code>"v1"</code> at
<code>time = 10</code>.
</p>
<p>From deSolve version 1.9.1 the following routines have <b>root-finding</b> capability:
<a href="#topic+lsoda">lsoda</a>, <a href="#topic+lsode">lsode</a>, <a href="#topic+lsodes">lsodes</a>, and <a href="#topic+radau">radau</a>.
For the first 3 integration methods, the
root finding algorithm is based on the algorithm in solver LSODAR, and is
implemented in FORTRAN. For radau, the root solving algorithm is written
in C-code, and it works slightly different. Thus, some problems involving roots
may be more efficiently solved with either lsoda, lsode, or lsodes, while other
problems are more efficiently solved with radau.
</p>
<p>If a root function is defined, but not an event function, then by default the
solver will stop at a root. If this is not desirable, e.g. because we want
to record the position of many roots, then a dummy &quot;event&quot; function can be
defined which returns the values of the state variables - unaltered.
</p>
<p>If roots and events are combined, and roots are found, then the output will have attribute
<code>troot</code> which will contain the <code>times</code> at which a root was found (and
the event trigerred).
There will be at most <code>events$maxroot</code> such values. The default is 100.
</p>
<p>See two last examples; also see example of <code><a href="#topic+ccl4model">ccl4model</a></code>.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert
</p>


<h3>See Also</h3>

<p><a href="#topic+forcings">forcings</a>, for how to implement forcing functions.
</p>
<p><a href="#topic+lsodar">lsodar</a>, for more examples of roots
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =============================================================================
## 1. EVENTS in a data.frame
## =============================================================================

## derivative function: derivatives set to 0
derivs &lt;- function(t, var, parms) {
  list(dvar = rep(0, 2))
}

yini &lt;- c(v1 = 1, v2 = 2)
times &lt;- seq(0, 10, by = 0.1)

eventdat &lt;- data.frame(var = c("v1", "v2", "v2", "v1"),
                       time = c(1, 1, 5, 9) ,
                       value = c(1, 2, 3, 4),
                       method = c("add", "mult", "rep", "add"))
eventdat

out &lt;- vode(func = derivs, y = yini, times = times, parms = NULL,
            events = list(data = eventdat))
plot(out)

##
eventdat &lt;- data.frame(var = c(rep("v1", 10), rep("v2", 10)),
                       time = c(1:10, 1:10),
                       value = runif(20),
                       method = rep("add", 20))
eventdat

out &lt;- ode(func = derivs, y = yini, times = times, parms = NULL,
           events = list(data = eventdat))

plot(out)

## =============================================================================
## 2. EVENTS in a function
## =============================================================================

## derivative function: rate of change v1 = 0, v2 reduced at first-order rate
derivs &lt;- function(t, var, parms) {
   list(c(0, -0.5 * var[2]))
}


# events: add 1 to v1, multiply v2 with random number
eventfun &lt;- function(t, y, parms){
  with (as.list(y),{
    v1 &lt;- v1 + 1
    v2 &lt;- 5 * runif(1)
    return(c(v1, v2))
  })
}

yini &lt;- c(v1 = 1, v2 = 2)
times &lt;- seq(0, 10, by = 0.1)

out &lt;- ode(func = derivs, y = yini, times = times, parms = NULL,
           events = list(func = eventfun, time = c(1:9, 2.2, 2.4)) )
plot(out, type = "l")

## =============================================================================
## 3. EVENTS triggered by a root function
## =============================================================================

## derivative: simple first-order decay
derivs &lt;- function(t, y, pars) {
  return(list(-0.1 * y))
}

## event triggered if state variable = 0.5
rootfun &lt;- function (t, y, pars) {
  return(y - 0.5)
}

## sets state variable = 1
eventfun &lt;- function(t, y, pars) {
  return(y = 1)
}

yini &lt;- 2
times &lt;- seq(0, 100, 0.1)

## uses ode to solve; root = TRUE specifies that the event is
## triggered by a root.
out &lt;- ode(times = times, y = yini, func = derivs, parms = NULL,
           events = list(func = eventfun, root = TRUE),
           rootfun = rootfun)

plot(out, type = "l")

## time of the root:
troot &lt;- attributes(out)$troot
points(troot, rep(0.5, length(troot)))


## =============================================================================
## 4. More ROOT examples: Rotation function
## =============================================================================
Rotate &lt;- function(t, x, p )
  list(c( x[2],
         -x[1]  ))

## Root = when second state variable = 0
rootfun &lt;- function(t, x, p) x[2]

## "event" returns state variables unchanged
eventfun &lt;- function(t, x, p) x
times &lt;- seq(from = 0, to = 15, by = 0.1)

## 1. No event: stops at first root
out1 &lt;- ode(func = Rotate, y = c(5, 5), parms = 0,
           times = times, rootfun = rootfun)
tail(out1)

## 2. Continues till end of times and records the roots
out &lt;- ode(func = Rotate, y = c(5, 5), parms = 0,
           times = times, rootfun = rootfun,
           events = list(func = eventfun, root = TRUE) )

plot(out)
troot &lt;- attributes(out)$troot  # time of roots
points(troot,rep(0, length (troot)))

## Multiple roots:  either one of the state variables = 0
root2 &lt;- function(t, x, p) x

out2 &lt;- ode(func = Rotate, y = c(5, 5), parms = 0,
           times = times, rootfun = root2,
           events = list(func = eventfun, root = TRUE) )

plot(out2, which = 2)
troot &lt;- attributes(out2)$troot
indroot &lt;- attributes(out2)$indroot  # which root was found
points(troot, rep(0, length (troot)), col = indroot, pch = 18, cex = 2)

## Multiple roots and stop at first time root 1.
out3 &lt;- ode(func = Rotate, y = c(5, 5), parms = 0,
      times = times, rootfun = root2,
      events = list(func = eventfun, root = TRUE, terminalroot = 1))


## =============================================================================
## 5. Stop at 5th root - only works with radau.
## =============================================================================
Rotate &lt;- function(t, x, p )
  list(c( x[2],
         -x[1],
         0  ))

## Root = when second state variable = 0
root3  &lt;- function(t, x, p)  c(x[2], x[3] - 5)
event3 &lt;- function (t, x, p) c(x[1:2], x[3]+1)
times &lt;- seq(0, 15, 0.1)
out3 &lt;- ode(func = Rotate, y = c(x1 = 5, x2 = 5, nroot = 0),
      parms = 0, method = "radau",
      times = times, rootfun = root3,
      events = list(func = event3, root = TRUE, terminalroot = 2))
plot(out3)
attributes(out3)[c("troot", "nroot", "indroot")]

## =============================================================================
## 6 Event in R-code, model function in compiled code - based on vode example
## =============================================================================

times &lt;- 1:365
Flux &lt;- cbind(times, sin(pi*times/365)^2) # forcing function

# run without events
out &lt;- ode(y = c(C = 1), times, func = "scocder", parms = c(k=0.01),
   dllname = "deSolve", initforc = "scocforc", forcings = Flux,
   initfunc = "scocpar", nout = 2, outnames = c("Mineralisation", "Depo"))

# Event halves the concentration
EventMin &lt;- function(t, y , p) y/2

out2 &lt;- ode(y = c(C = 1), times, func = "scocder", parms = c(k=0.01),
   dllname = "deSolve", initforc = "scocforc", forcings = Flux,
   initfunc = "scocpar", nout = 2, outnames = c("Mineralisation", "Depo"),
   events = list (func = EventMin, time = c(50.1, 200, 210.5)))

plot(out, out2)


</code></pre>

<hr>
<h2 id='forcings'>
Passing Forcing Functions to Models Written in R or Compiled Code.
</h2><span id='topic+forcings'></span>

<h3>Description</h3>

<p>A <code>forcing function</code> is an external variable that is essential to the 
model, but not explicitly modeled. Rather, it is imposed as a time-series.
Thus, if a model uses forcing variables, their value at each time point 
needs to be estimated by interpolation of a data series.
</p>


<h3>Details</h3>

<p>The <code>forcing functions</code> are imposed as a data series, that contains
the values of the forcings at specified times.
</p>
<p>Models may be defined in compiled C or FORTRAN code, as well as in R.
</p>
<p>If the model is defined in <em>R code</em>, it is most efficient to:
</p>
<p>1. define  a function that performs the linear interpolation,
using <span class="rlang"><b>R</b></span>'s <code><a href="stats.html#topic+approxfun">approxfun</a></code>. It is generally recommended to use 
<code>rule = 2</code>, such as to allow extrapolation outside of the time interval,
especially when using the Livermore solvers, as these may exceed the last
time point.
</p>
<p>2. call this function within the model's derivative function, 
to interpolate at the current timestep.
</p>
<p>See first example.
</p>
<p>If the models are defined in <em>compiled C or FORTRAN code</em>, it is possible to
use <code>deSolve</code>s forcing function update algorithm. This is the
compiled-code equivalent of <code>approxfun</code> or <code>approx</code>.
</p>
<p>In this case:<br />
1. the forcing function data series is provided by means 
of argument <code>forcings</code>, 
</p>
<p>2. <code>initforc</code> is the name of the forcing function initialisation function, 
as provided in &lsquo;<span class="file">dllname</span>&rsquo;, while 
</p>
<p>3. <code>fcontrol</code> is a list used to finetune how the forcing update should 
be performed.
</p>
<p>The <b>fcontrol</b> argument is a list that can supply any of the following
components (conform the definitions in the <a href="stats.html#topic+approxfun">approxfun</a> function):
</p>

<dl>
<dt>method </dt><dd><p>specifies the interpolation method to be used.
Choices are <code>"linear"</code> or <code>"constant"</code>,</p>
</dd>
<dt>rule </dt><dd><p>an integer describing how interpolation is to take place
outside the interval [min(times), max(times)].
If <code>rule</code> is <code>1</code> then an error will be triggered and the
calculation will stop if <code>times</code> extends the interval of the
forcing function data set. If it is <code>2</code>, the <b>default</b>, the
value at the closest data extreme is used, a warning will be printed if
<code>verbose</code> is <code>TRUE</code>,
</p>
<p>Note that the default differs from the <code>approx</code> default.</p>
</dd>
<dt>f </dt><dd><p>For <code>method = "constant"</code> a number between <code>0</code> and
<code>1</code> inclusive, indicating a compromise between left- and
right-continuous step functions. If <code>y0</code> and <code>y1</code> are the
values to the left and right of the point then the value is
<code>y0 * (1 - f) + y1 * f</code> so that <code>f = 0</code> is right-continuous and
<code>f = 1</code> is left-continuous,
</p>
</dd>
<dt>ties </dt><dd><p>Handling of tied <code>times</code> values. Either a function
with a single vector argument returning a single number result or the
string <code>"ordered"</code>.
</p>
<p>Note that the default is <code>"ordered"</code>, hence the existence of ties will
NOT be investigated; in the <code>C</code> code this will mean that -if ties
exist, the first value will be used; if the dataset is not ordered,
then nonsense will be produced.
</p>
<p>Alternative values for <code>ties</code> are <code>mean</code>, <code>min</code> etc
</p>
</dd>
</dl>

<p>The defaults are:
</p>
<p><code>fcontrol = list(method = "linear", rule = 2,  f = 0, ties = "ordered")</code>
</p>
<p>Note that only ONE specification is allowed, even if there is more than
one forcing function data set.
</p>
<p>More information about models defined in compiled code is in the package
vignette (&quot;compiledCode&quot;).
</p>


<h3>Note</h3>

<p>How to write compiled code is described in package vignette
<code>"compiledCode"</code>, which should be referred to for details.
</p>
<p>This vignette also contains examples on how to pass forcing functions.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert,
</p>
<p>Thomas Petzoldt,
</p>
<p>R. Woodrow Setzer
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+approx">approx</a></code> or <code><a href="stats.html#topic+approxfun">approxfun</a></code>, the <span class="rlang"><b>R</b></span> function,
</p>
<p><code><a href="#topic+events">events</a></code> for how to implement events.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =============================================================================
## FORCING FUNCTION: The sediment oxygen consumption example - R-code:
## =============================================================================

## Forcing function data
Flux &lt;- matrix(ncol=2,byrow=TRUE,data=c(
  1, 0.654, 11, 0.167,   21, 0.060, 41, 0.070, 73,0.277, 83,0.186,
  93,0.140,103, 0.255,  113, 0.231,123, 0.309,133,1.127,143,1.923,
  153,1.091,163,1.001,  173, 1.691,183, 1.404,194,1.226,204,0.767,
  214, 0.893,224,0.737, 234,0.772,244, 0.726,254,0.624,264,0.439,
  274,0.168,284 ,0.280, 294,0.202,304, 0.193,315,0.286,325,0.599,
  335, 1.889,345, 0.996,355,0.681,365,1.135))

parms &lt;- c(k=0.01)

times &lt;- 1:365

## the model
sediment &lt;- function( t, O2, k) 
  list (c(Depo(t) - k * O2), depo = Depo(t))

# the forcing functions; rule = 2 avoids NaNs in interpolation
Depo &lt;- approxfun(x = Flux[,1], y = Flux[,2], method = "linear", rule = 2)

Out &lt;- ode(times = times, func = sediment, y = c(O2 = 63), parms = parms)
  
## same forcing functions, now constant interpolation
Depo &lt;- approxfun(x = Flux[,1], y = Flux[,2], method = "constant",
  f = 0.5, rule = 2)

Out2 &lt;- ode(times = times, func = sediment, y = c(O2 = 63), parms = parms)

mf &lt;- par(mfrow = c(2, 1))
plot (Out, which = "depo", type = "l", lwd = 2, mfrow = NULL)
lines(Out2[,"time"], Out2[,"depo"], col = "red", lwd = 2)

plot (Out, which = "O2", type = "l", lwd = 2, mfrow = NULL)
lines(Out2[,"time"], Out2[,"O2"], col = "red", lwd = 2)

## =============================================================================
## SCOC is the same model, as implemented in FORTRAN
## =============================================================================

out&lt;- SCOC(times, parms = parms, Flux = Flux)

plot(out[,"time"], out[,"Depo"], type = "l", col = "red")
lines(out[,"time"], out[,"Mineralisation"], col = "blue")

## Constant interpolation of forcing function - left side of interval
fcontrol &lt;- list(method = "constant")

out2 &lt;- SCOC(times, parms = parms, Flux = Flux, fcontrol = fcontrol)

plot(out2[,"time"], out2[,"Depo"], type = "l", col = "red")
lines(out2[,"time"], out2[,"Mineralisation"], col = "blue")


## Not run: 
## =============================================================================
## show examples (see respective help pages for details)
## =============================================================================

example(aquaphy)

## show package vignette with tutorial about how to use compiled models
## + source code of the vignette
## + directory with C and FORTRAN sources
vignette("compiledCode")
edit(vignette("compiledCode"))
browseURL(paste(system.file(package = "deSolve"), "/doc", sep = ""))

## End(Not run)

</code></pre>

<hr>
<h2 id='lsoda'>
Solver for Ordinary Differential Equations (ODE),
Switching Automatically Between Stiff and Non-stiff Methods
</h2><span id='topic+lsoda'></span>

<h3>Description</h3>

<p>Solving initial value problems for stiff or non-stiff systems of
first-order ordinary differential equations (ODEs).
</p>
<p>The <span class="rlang"><b>R</b></span> function <code>lsoda</code> provides an interface to the FORTRAN ODE
solver of the same name, written by Linda R. Petzold and Alan
C. Hindmarsh.
</p>
<p>The system of ODE's is written as an <span class="rlang"><b>R</b></span> function (which may, of
course, use <code><a href="base.html#topic+.C">.C</a></code>, <code><a href="base.html#topic+.Fortran">.Fortran</a></code>,
<code><a href="base.html#topic+.Call">.Call</a></code>, etc., to call foreign code) or be defined in
compiled code that has been dynamically loaded.  A vector of
parameters is passed to the ODEs, so the solver may be used as part of
a modeling package for ODEs, or for parameter estimation using any
appropriate modeling tool for non-linear models in <span class="rlang"><b>R</b></span> such as
<code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="stats.html#topic+nls">nls</a></code>, <code><a href="stats.html#topic+nlm">nlm</a></code> or
<code><a href="nlme.html#topic+nlme">nlme</a></code>
</p>
<p><code>lsoda</code> differs from the other integrators (except <code>lsodar</code>)
in that it switches automatically between stiff and nonstiff methods.
This means that the user does not have to determine whether the
problem is stiff or not, and the solver will automatically choose the
appropriate method.  It always starts with the nonstiff method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsoda(y, times, func, parms, rtol = 1e-6, atol = 1e-6,
  jacfunc = NULL, jactype = "fullint", rootfunc = NULL,
  verbose = FALSE, nroot = 0, tcrit = NULL,
  hmin = 0, hmax = NULL, hini = 0, ynames = TRUE,
  maxordn = 12, maxords = 5, bandup = NULL, banddown = NULL,
  maxsteps = 5000, dllname = NULL, initfunc = dllname,
  initpar = parms, rpar = NULL, ipar = NULL, nout = 0,
  outnames = NULL, forcings = NULL, initforc = NULL,
  fcontrol = NULL, events = NULL, lags = NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsoda_+3A_y">y</code></td>
<td>
<p>the initial (state) values for the ODE system. If <code>y</code>
has a name attribute, the names will be used to label the output
matrix.
</p>
</td></tr>
<tr><td><code id="lsoda_+3A_times">times</code></td>
<td>
<p>times at which explicit estimates for <code>y</code> are
desired.  The first value in <code>times</code> must be the initial time.
</p>
</td></tr>
<tr><td><code id="lsoda_+3A_func">func</code></td>
<td>
<p>either an <span class="rlang"><b>R</b></span>-function that computes the values of the
derivatives in the ODE system (the <em>model definition</em>) at time
t, or a character string giving the name of a compiled function in a
dynamically loaded shared library, or a list of symbols returned by
<code><a href="#topic+checkDLL">checkDLL</a></code>.
</p>
<p>If <code>func</code> is an <span class="rlang"><b>R</b></span>-function, it must be defined as:
<code>func &lt;- function(t, y, parms,...)</code>.  <code>t</code> is the current
time point in the integration, <code>y</code> is the current estimate of
the variables in the ODE system.  If the initial values <code>y</code> has
a <code>names</code> attribute, the names will be available inside <code>func</code>.
<code>parms</code> is a vector or list of parameters; ... (optional) are
any other arguments passed to the function.
</p>
<p>The return value of <code>func</code> should be a list, whose first
element is a vector containing the derivatives of <code>y</code> with
respect to <code>time</code>, and whose next elements are global values
that are required at each point in <code>times</code>.  The derivatives
must be specified in the <b>same order</b> as the state variables <code>y</code>.
</p>
<p>If <code>func</code> is a string, then <code>dllname</code> must give the name
of the shared library (without extension) which must be loaded
before <code>lsoda()</code> is called. See package vignette
<code>"compiledCode"</code> for more
details.
</p>
<p><code>func</code> can also be a list of symbols returned by <code><a href="#topic+checkDLL">checkDLL</a></code>
to avoid overhead from repeated internal calls to this function. It
is an experimental feature for special situations, when a small compiled
model with a low number of integration steps is repeatedly called. It is
currently only available for the <code>lsoda</code> solver, see
<a href="../doc/dynload-fastlsoda">example</a>.
</p>
</td></tr>
<tr><td><code id="lsoda_+3A_parms">parms</code></td>
<td>
<p>vector or list of parameters used in <code>func</code> or
<code>jacfunc</code>.
</p>
</td></tr>
<tr><td><code id="lsoda_+3A_rtol">rtol</code></td>
<td>
<p>relative error tolerance, either a scalar or an array as
long as <code>y</code>. See details.
</p>
</td></tr>
<tr><td><code id="lsoda_+3A_atol">atol</code></td>
<td>
<p>absolute error tolerance, either a scalar or an array as
long as <code>y</code>. See details.
</p>
</td></tr>
<tr><td><code id="lsoda_+3A_jacfunc">jacfunc</code></td>
<td>
<p>if not <code>NULL</code>, an <span class="rlang"><b>R</b></span> function, that computes the
Jacobian of the system of differential equations
<code class="reqn">\partial\dot{y}_i/\partial y_j</code>, or
a string giving the name of a function or subroutine in
&lsquo;<span class="file">dllname</span>&rsquo; that computes the Jacobian (see vignette
<code>"compiledCode"</code> for more about this option).
</p>
<p>In some circumstances, supplying
<code>jacfunc</code> can speed up the computations, if the system is
stiff.  The <span class="rlang"><b>R</b></span> calling sequence for <code>jacfunc</code> is identical to
that of <code>func</code>.
</p>
<p>If the Jacobian is a full matrix, <code>jacfunc</code> should return a
matrix <code class="reqn">\partial\dot{y}/\partial y</code>, where the ith row contains the derivative of
<code class="reqn">dy_i/dt</code> with respect to <code class="reqn">y_j</code>, or a vector containing the
matrix elements by columns (the way <span class="rlang"><b>R</b></span> and FORTRAN store matrices).
</p>
<p>If the Jacobian is banded, <code>jacfunc</code> should return a matrix
containing only the nonzero bands of the Jacobian, rotated
row-wise. See first example of <a href="#topic+lsode">lsode</a>.
</p>
</td></tr>
<tr><td><code id="lsoda_+3A_jactype">jactype</code></td>
<td>
<p>the structure of the Jacobian, one of <code>"fullint"</code>,
<code>"fullusr"</code>, <code>"bandusr"</code> or <code>"bandint"</code> - either
full or banded and estimated internally or by user.
</p>
</td></tr>
<tr><td><code id="lsoda_+3A_rootfunc">rootfunc</code></td>
<td>
<p>if not <code>NULL</code>, an <span class="rlang"><b>R</b></span> function that computes the
function whose root has to be estimated or a string giving the name
of a function or subroutine in &lsquo;<span class="file">dllname</span>&rsquo; that computes the root
function.  The <span class="rlang"><b>R</b></span> calling sequence for <code>rootfunc</code> is identical
to that of <code>func</code>.  <code>rootfunc</code> should return a vector with
the function values whose root is sought.  When <code>rootfunc</code> is
provided, then <code>lsodar</code> will be called.
</p>
</td></tr>
<tr><td><code id="lsoda_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>: full output to the screen, e.g. will
print the <code>diagnostiscs</code> of the integration - see details.
</p>
</td></tr>
<tr><td><code id="lsoda_+3A_nroot">nroot</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo;  is specified: the number of
constraint functions whose roots are desired during the integration;
if <code>rootfunc</code> is an R-function, the solver estimates the number
of roots.
</p>
</td></tr>
<tr><td><code id="lsoda_+3A_tcrit">tcrit</code></td>
<td>
<p>if not <code>NULL</code>, then <code>lsoda</code> cannot integrate
past <code>tcrit</code>. The FORTRAN routine <code>lsoda</code> overshoots its
targets (times points in the vector <code>times</code>), and interpolates
values for the desired time points.  If there is a time beyond which
integration should not proceed (perhaps because of a singularity),
that should be provided in <code>tcrit</code>.
</p>
</td></tr>
<tr><td><code id="lsoda_+3A_hmin">hmin</code></td>
<td>
<p>an optional minimum value of the integration stepsize. In
special situations this parameter may speed up computations with the
cost of precision. Don't use <code>hmin</code> if you don't know why!
</p>
</td></tr>
<tr><td><code id="lsoda_+3A_hmax">hmax</code></td>
<td>
<p>an optional maximum value of the integration stepsize. If
not specified, <code>hmax</code> is set to the largest difference in
<code>times</code>, to avoid that the simulation possibly ignores
short-term events. If 0, no maximal size is specified.
</p>
</td></tr>
<tr><td><code id="lsoda_+3A_hini">hini</code></td>
<td>
<p>initial step size to be attempted; if 0, the initial step
size is determined by the solver.
</p>
</td></tr>
<tr><td><code id="lsoda_+3A_ynames">ynames</code></td>
<td>
<p>logical, if <code>FALSE</code>: names of state variables are not
passed to function <code>func</code>; this may speed up the simulation especially
for large models.
</p>
</td></tr>
<tr><td><code id="lsoda_+3A_maxordn">maxordn</code></td>
<td>
<p>the maximum order to be allowed in case the method is
non-stiff. Should be &lt;= 12. Reduce <code>maxord</code> to save storage space.
</p>
</td></tr>
<tr><td><code id="lsoda_+3A_maxords">maxords</code></td>
<td>
<p>the maximum order to be allowed in case the method is
stiff. Should be &lt;= 5. Reduce maxord to save storage space.
</p>
</td></tr>
<tr><td><code id="lsoda_+3A_bandup">bandup</code></td>
<td>
<p>number of non-zero bands above the diagonal, in case
the Jacobian is banded.
</p>
</td></tr>
<tr><td><code id="lsoda_+3A_banddown">banddown</code></td>
<td>
<p>number of non-zero bands below the diagonal, in case
the Jacobian is banded.
</p>
</td></tr>
<tr><td><code id="lsoda_+3A_maxsteps">maxsteps</code></td>
<td>
<p>maximal number of steps per output interval taken by the
solver.
</p>
</td></tr>
<tr><td><code id="lsoda_+3A_dllname">dllname</code></td>
<td>
<p>a string giving the name of the shared library
(without extension) that contains all the compiled function or
subroutine definitions refered to in <code>func</code> and
<code>jacfunc</code>. See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="lsoda_+3A_initfunc">initfunc</code></td>
<td>
<p>if not <code>NULL</code>, the name of the initialisation function
(which initialises values of parameters), as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="lsoda_+3A_initpar">initpar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified and an
initialisation function <code>initfunc</code> is in the dll: the
parameters passed to the initialiser, to initialise the common
blocks (FORTRAN) or global variables (C, C++).
</p>
</td></tr>
<tr><td><code id="lsoda_+3A_rpar">rpar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with
double precision values passed to the dll-functions whose names are
specified by <code>func</code> and <code>jacfunc</code>.
</p>
</td></tr>
<tr><td><code id="lsoda_+3A_ipar">ipar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with
integer values passed to the dll-functions whose names are specified
by <code>func</code> and <code>jacfunc</code>.
</p>
</td></tr>
<tr><td><code id="lsoda_+3A_nout">nout</code></td>
<td>
<p>only used if <code>dllname</code> is specified and the model is
defined in compiled code: the number of output variables calculated
in the compiled function <code>func</code>, present in the shared
library. Note: it is not automatically checked whether this is
indeed the number of output variables calculated in the dll - you have
to perform this check in the code. See package vignette
<code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="lsoda_+3A_outnames">outnames</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified and
<code>nout</code> &gt; 0: the names of output variables calculated in the
compiled function <code>func</code>, present in the shared library.
These names will be used to label the output matrix.
</p>
</td></tr>
<tr><td><code id="lsoda_+3A_forcings">forcings</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified: a list with
the forcing function data sets, each present as a two-columned matrix,
with (time,value); interpolation outside the interval
[min(<code>times</code>), max(<code>times</code>)] is done by taking the value at
the closest data extreme.
</p>
<p>See <a href="#topic+forcings">forcings</a> or package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="lsoda_+3A_initforc">initforc</code></td>
<td>
<p>if not <code>NULL</code>, the name of the forcing function
initialisation function, as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. It MUST be present if <code>forcings</code> has been given a
value.
See <a href="#topic+forcings">forcings</a> or package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="lsoda_+3A_fcontrol">fcontrol</code></td>
<td>
<p>A list of control parameters for the forcing functions.
See <a href="#topic+forcings">forcings</a> or vignette <code>compiledCode</code>.
</p>
</td></tr>
<tr><td><code id="lsoda_+3A_events">events</code></td>
<td>
<p>A matrix or data frame that specifies events, i.e. when the value of a
state variable is suddenly changed. See <a href="#topic+events">events</a> for more information.
</p>
</td></tr>
<tr><td><code id="lsoda_+3A_lags">lags</code></td>
<td>
<p>A list that specifies timelags, i.e. the number of steps
that has to be kept. To be used for delay differential equations.
See <a href="#topic+timelags">timelags</a>, <a href="#topic+dede">dede</a> for more information.
</p>
</td></tr>
<tr><td><code id="lsoda_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>func</code> and
<code>jacfunc</code> allowing this to be a generic function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All the hard work is done by the FORTRAN subroutine <code>lsoda</code>,
whose documentation should be consulted for details (it is included as
comments in the source file &lsquo;<span class="file">src/opkdmain.f</span>&rsquo;). The implementation
is based on the 12 November 2003 version of lsoda, from Netlib.
</p>
<p><code>lsoda</code> switches automatically between stiff and nonstiff
methods.  This means that the user does not have to determine whether
the problem is stiff or not, and the solver will automatically choose
the appropriate method.  It always starts with the nonstiff method.
</p>
<p>The form of the <b>Jacobian</b> can be specified by <code>jactype</code> which can
take the following values:
</p>

<dl>
<dt>&quot;fullint&quot;</dt><dd><p>a full Jacobian, calculated internally by lsoda, the default,</p>
</dd>
<dt>&quot;fullusr&quot;</dt><dd><p>a full Jacobian, specified by user function <code>jacfunc</code>,</p>
</dd>
<dt>&quot;bandusr&quot;</dt><dd><p>a banded Jacobian, specified by user function <code>jacfunc</code>
the size of the bands specified by <code>bandup</code> and <code>banddown</code>,</p>
</dd>
<dt>&quot;bandint&quot;</dt><dd><p>banded Jacobian, calculated by lsoda; the size of the bands
specified by <code>bandup</code> and <code>banddown</code>.</p>
</dd>
</dl>

<p>If <code>jactype</code> = &quot;fullusr&quot; or &quot;bandusr&quot; then the user must supply a
subroutine <code>jacfunc</code>.
</p>
<p>The following description of <b>error control</b> is adapted from the
documentation of the lsoda source code
(input arguments <code>rtol</code> and <code>atol</code>, above):
</p>
<p>The input parameters <code>rtol</code>, and <code>atol</code> determine the error
control performed by the solver.  The solver will control the vector
<b>e</b> of estimated local errors in <b>y</b>, according to an
inequality of the form max-norm of ( <b>e</b>/<b>ewt</b> ) <code class="reqn">\leq</code> 1, where <b>ewt</b> is a vector of positive error weights.  The
values of <code>rtol</code> and <code>atol</code> should all be non-negative.  The
form of <b>ewt</b> is:
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{rtol} \times \mathrm{abs}(\mathbf{y}) +
  \mathbf{atol}</code>
</p>

<p>where multiplication of two vectors is element-by-element.
</p>
<p>If the request for precision exceeds the capabilities of the machine,
the FORTRAN subroutine lsoda will return an error code; under some
circumstances, the <span class="rlang"><b>R</b></span> function <code>lsoda</code> will attempt a reasonable
reduction of precision in order to get an answer.  It will write a
warning if it does so.
</p>
<p>The diagnostics of the integration can be printed to screen
by calling <code><a href="#topic+diagnostics">diagnostics</a></code>. If <code>verbose</code> = <code>TRUE</code>,
the diagnostics will written to the screen at the end of the integration.
</p>
<p>See vignette(&quot;deSolve&quot;) for an explanation of each element in the vectors
containing the diagnostic properties and how to directly access them.
</p>
<p><b>Models</b> may be defined in compiled C or FORTRAN code, as well as
in an R-function. See package vignette <code>"compiledCode"</code> for details.
</p>
<p>More information about models defined in compiled code is in the package
vignette (&quot;compiledCode&quot;); information about linking forcing functions
to compiled code is in <a href="#topic+forcings">forcings</a>.
</p>
<p>Examples in both C and FORTRAN are in the &lsquo;<span class="file">dynload</span>&rsquo; subdirectory
of the <code>deSolve</code> package directory.
</p>


<h3>Value</h3>

<p>A matrix of class <code>deSolve</code> with up to as many rows as elements
in <code>times</code> and as many columns as elements in <code>y</code> plus the number of &quot;global&quot;
values returned in the next elements of the return from <code>func</code>,
plus and additional column for the time value.  There will be a row
for each element in <code>times</code> unless the FORTRAN routine &lsquo;lsoda&rsquo;
returns with an unrecoverable error. If <code>y</code> has a names
attribute, it will be used to label the columns of the output value.
</p>


<h3>Note</h3>

<p>The &lsquo;<span class="file">demo</span>&rsquo; directory contains some examples of using
<code><a href="nlme.html#topic+gnls">gnls</a></code> to estimate parameters in a
dynamic model.
</p>


<h3>Author(s)</h3>

<p>R. Woodrow Setzer &lt;setzer.woodrow@epa.gov&gt;</p>


<h3>References</h3>

<p>Hindmarsh, Alan C. (1983) ODEPACK, A Systematized Collection of ODE
Solvers; in p.55&ndash;64 of Stepleman, R.W. et al.[ed.] (1983)
<em>Scientific Computing</em>, North-Holland, Amsterdam.
</p>
<p>Petzold, Linda R. (1983) Automatic Selection of Methods for Solving
Stiff and Nonstiff Systems of Ordinary Differential Equations.
<em>Siam J. Sci. Stat. Comput.</em> <b>4</b>, 136&ndash;148.
<a href="https://doi.org/10.1137/0904010">doi:10.1137/0904010</a>
</p>
<p>Netlib: <a href="https://netlib.org">https://netlib.org</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+rk">rk</a></code>, <code><a href="#topic+rkMethod">rkMethod</a></code>, <code><a href="#topic+rk4">rk4</a></code> and <code><a href="#topic+euler">euler</a></code> for
Runge-Kutta integrators.
</p>
</li>
<li>  <p><code><a href="#topic+lsode">lsode</a></code>, which can also find a root
</p>
</li>
<li>  <p><code><a href="#topic+lsodes">lsodes</a></code>, <code><a href="#topic+lsodar">lsodar</a></code>, <code><a href="#topic+vode">vode</a></code>,
<code><a href="#topic+daspk">daspk</a></code> for other solvers of the Livermore family,
</p>
</li>
<li> <p><code><a href="#topic+ode">ode</a></code> for a general interface to most of the ODE solvers,
</p>
</li>
<li> <p><code><a href="#topic+ode.band">ode.band</a></code> for solving models with a banded
Jacobian,
</p>
</li>
<li> <p><code><a href="#topic+ode.1D">ode.1D</a></code> for integrating 1-D models,
</p>
</li>
<li> <p><code><a href="#topic+ode.2D">ode.2D</a></code> for integrating 2-D models,
</p>
</li>
<li> <p><code><a href="#topic+ode.3D">ode.3D</a></code> for integrating 3-D models,
</p>
</li></ul>

<p><code><a href="#topic+diagnostics">diagnostics</a></code> to print diagnostic messages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =======================================================================
## Example 1:
##   A simple resource limited Lotka-Volterra-Model
##
## Note:
## 1. parameter and state variable names made
##    accessible via "with" function
## 2. function sigimp accessible through lexical scoping
##    (see also ode and rk examples)
## =======================================================================

SPCmod &lt;- function(t, x, parms) {
  with(as.list(c(parms, x)), {
    import &lt;- sigimp(t)
    dS &lt;- import - b*S*P + g*C     #substrate
    dP &lt;- c*S*P  - d*C*P           #producer
    dC &lt;- e*P*C  - f*C             #consumer
    res &lt;- c(dS, dP, dC)
    list(res)
  })
}

## Parameters
parms  &lt;- c(b = 0.0, c = 0.1, d = 0.1, e = 0.1, f = 0.1, g = 0.0)

## vector of timesteps
times  &lt;- seq(0, 100, length = 101)

## external signal with rectangle impulse
signal &lt;- as.data.frame(list(times = times,
                            import = rep(0,length(times))))

signal$import[signal$times &gt;= 10 &amp; signal$times &lt;= 11] &lt;- 0.2

sigimp &lt;- approxfun(signal$times, signal$import, rule = 2)


## Start values for steady state
y &lt;- xstart &lt;- c(S = 1, P = 1, C = 1)

## Solving
out &lt;-  lsoda(xstart, times, SPCmod, parms)

## Plotting
mf &lt;- par("mfrow")
plot(out, main = c("substrate", "producer", "consumer"))
plot(out[,"P"], out[,"C"], type = "l", xlab = "producer", ylab = "consumer")
par(mfrow = mf)

## =======================================================================
## Example 2:
##  from lsoda source code
## =======================================================================

## names makes this easier to read, but may slow down execution.
parms   &lt;- c(k1 = 0.04, k2 = 1e4, k3 = 3e7)
my.atol &lt;- c(1e-6,  1e-10,  1e-6)
times   &lt;- c(0,4 * 10^(-1:10))

lsexamp &lt;- function(t, y, p) {
  yd1 &lt;- -p["k1"] * y[1] + p["k2"] * y[2]*y[3]
  yd3 &lt;- p["k3"] * y[2]^2
  list(c(yd1, -yd1-yd3, yd3), c(massbalance = sum(y)))
}

exampjac &lt;- function(t, y, p) {
  matrix(c(-p["k1"],	   p["k1"],       0,

            p["k2"]*y[3],
          - p["k2"]*y[3] - 2*p["k3"]*y[2],
                           2*p["k3"]*y[2],

          p["k2"]*y[2],  -p["k2"]*y[2],  0
          ), 3, 3)
}


## measure speed (here and below)
system.time(
  out &lt;- lsoda(c(1, 0, 0), times, lsexamp, parms, rtol = 1e-4,
           atol = my.atol, hmax = Inf)
)
out

## This is what the authors of lsoda got for the example:

## the output of this program (on a cdc-7600 in single precision)
## is as follows..
##
## at t =  4.0000e-01   y =  9.851712e-01  3.386380e-05  1.479493e-02
## at t =  4.0000e+00   y =  9.055333e-01  2.240655e-05  9.444430e-02
## at t =  4.0000e+01   y =  7.158403e-01  9.186334e-06  2.841505e-01
## at t =  4.0000e+02   y =  4.505250e-01  3.222964e-06  5.494717e-01
## at t =  4.0000e+03   y =  1.831975e-01  8.941774e-07  8.168016e-01
## at t =  4.0000e+04   y =  3.898730e-02  1.621940e-07  9.610125e-01
## at t =  4.0000e+05   y =  4.936363e-03  1.984221e-08  9.950636e-01
## at t =  4.0000e+06   y =  5.161831e-04  2.065786e-09  9.994838e-01
## at t =  4.0000e+07   y =  5.179817e-05  2.072032e-10  9.999482e-01
## at t =  4.0000e+08   y =  5.283401e-06  2.113371e-11  9.999947e-01
## at t =  4.0000e+09   y =  4.659031e-07  1.863613e-12  9.999995e-01
## at t =  4.0000e+10   y =  1.404280e-08  5.617126e-14  1.000000e+00

## Using the analytic Jacobian speeds up execution a little :

system.time(
  outJ &lt;- lsoda(c(1, 0, 0), times, lsexamp, parms, rtol = 1e-4,
            atol = my.atol, jacfunc = exampjac, jactype = "fullusr", hmax = Inf)
)

all.equal(as.data.frame(out), as.data.frame(outJ)) # TRUE
diagnostics(out)
diagnostics(outJ) # shows what lsoda did internally

</code></pre>

<hr>
<h2 id='lsodar'>Solver for Ordinary Differential Equations (ODE),
Switching Automatically Between Stiff and Non-stiff Methods and With
Root Finding
</h2><span id='topic+lsodar'></span>

<h3>Description</h3>

<p>Solving initial value problems for stiff or non-stiff
systems of first-order ordinary differential equations (ODEs) and
including root-finding.
</p>
<p>The <span class="rlang"><b>R</b></span> function <code>lsodar</code> provides an interface to the FORTRAN ODE
solver of the same name, written by Alan C. Hindmarsh and Linda
R. Petzold.
</p>
<p>The system of ODE's is written as an <span class="rlang"><b>R</b></span> function or be defined in
compiled code that has been dynamically loaded. - see description of
<code><a href="#topic+lsoda">lsoda</a></code> for details.
</p>
<p><code>lsodar</code> differs from <code>lsode</code> in two respects.
</p>

<ul>
<li><p> It switches automatically between stiff and nonstiff methods
(similar as lsoda).
</p>
</li>
<li><p> It finds the root of at least one of a set of constraint
functions g(i) of the independent and dependent variables.
</p>
</li></ul>

<p>Two uses of <code>lsodar</code> are: 
</p>

<ul>
<li><p> To stop the simulation when a certain condition is met
</p>
</li>
<li><p> To trigger <a href="#topic+events">events</a>, i.e. sudden changes in one of the 
state variables when a certain condition is met.
</p>
</li></ul>

<p>when a particular condition is met. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsodar(y, times, func, parms, rtol = 1e-6, atol = 1e-6, 
  jacfunc = NULL, jactype = "fullint", rootfunc = NULL,
  verbose = FALSE, nroot = 0, tcrit = NULL, hmin = 0,
  hmax = NULL, hini = 0, ynames = TRUE, maxordn = 12,
  maxords = 5, bandup = NULL, banddown = NULL, maxsteps = 5000,
  dllname = NULL, initfunc = dllname, initpar = parms,
  rpar = NULL, ipar = NULL, nout = 0, outnames = NULL, forcings=NULL,
  initforc = NULL, fcontrol=NULL, events=NULL, lags = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsodar_+3A_y">y</code></td>
<td>
<p>the initial (state) values for the ODE system. If <code>y</code>
has a name attribute, the names will be used to label the output
matrix.
</p>
</td></tr>
<tr><td><code id="lsodar_+3A_times">times</code></td>
<td>
<p>times at which explicit estimates for <code>y</code> are
desired.  The first value in <code>times</code> must be the initial time.
</p>
</td></tr>
<tr><td><code id="lsodar_+3A_func">func</code></td>
<td>
<p>either an <span class="rlang"><b>R</b></span>-function that computes the values of the
derivatives in the ODE system (the <em>model definition</em>) at time
t, or a character string giving the name of a compiled function in a
dynamically loaded shared library.
</p>
<p>If <code>func</code> is an <span class="rlang"><b>R</b></span>-function, it must be defined as:
<code>func &lt;- function(t, y, parms,...)</code>.  <code>t</code> is the current time
point in the integration, <code>y</code> is the current estimate of the
variables in the ODE system.  If the initial values <code>y</code> has a
<code>names</code> attribute, the names will be available inside <code>func</code>.
<code>parms</code> is a vector or list of parameters; ... (optional) are
any other arguments passed to the function.
</p>
<p>The return value of <code>func</code> should be a list, whose first
element is a vector containing the derivatives of <code>y</code> with
respect to <code>time</code>, and whose next elements are global values
that are required at each point in <code>times</code>.  The derivatives
must be specified in the <b>same order</b> as the state variables <code>y</code>.
</p>
<p>If <code>func</code> is a string, then <code>dllname</code> must give the name
of the shared library (without extension) which must be loaded
before <code>lsodar()</code> is called. See package vignette
<code>"compiledCode"</code> for more
details.
</p>
</td></tr>
<tr><td><code id="lsodar_+3A_parms">parms</code></td>
<td>
<p>vector or list of parameters used in <code>func</code> or
<code>jacfunc</code>.
</p>
</td></tr>
<tr><td><code id="lsodar_+3A_rtol">rtol</code></td>
<td>
<p>relative error tolerance, either a scalar or an array as
long as <code>y</code>. See details.
</p>
</td></tr>
<tr><td><code id="lsodar_+3A_atol">atol</code></td>
<td>
<p>absolute error tolerance, either a scalar or an array as
long as <code>y</code>. See details.
</p>
</td></tr>
<tr><td><code id="lsodar_+3A_jacfunc">jacfunc</code></td>
<td>
<p>if not <code>NULL</code>, an <span class="rlang"><b>R</b></span> function, that computes the
Jacobian of the system of differential equations
<code class="reqn">\partial\dot{y}_i/\partial y_j</code>, or
a string giving the name of a function or subroutine in
&lsquo;<span class="file">dllname</span>&rsquo; that computes the Jacobian (see vignette
<code>"compiledCode"</code> for more about this option).
</p>
<p>In some circumstances, supplying
<code>jacfunc</code> can speed up the computations, if the system is
stiff.  The <span class="rlang"><b>R</b></span> calling sequence for <code>jacfunc</code> is identical to
that of <code>func</code>.
</p>
<p>If the Jacobian is a full matrix, <code>jacfunc</code> should return a
matrix <code class="reqn">\partial\dot{y}/\partial y</code>, where the ith row
contains the derivative of
<code class="reqn">dy_i/dt</code> with respect to <code class="reqn">y_j</code>, or a vector containing the
matrix elements by columns (the way <span class="rlang"><b>R</b></span> and FORTRAN store matrices).
</p>
<p>If the Jacobian is banded, <code>jacfunc</code> should return a matrix
containing only the nonzero bands of the Jacobian, rotated
row-wise. See first example of <a href="#topic+lsode">lsode</a>.
</p>
</td></tr>
<tr><td><code id="lsodar_+3A_jactype">jactype</code></td>
<td>
<p>the structure of the Jacobian, one of
<code>"fullint"</code>, <code>"fullusr"</code>, <code>"bandusr"</code> or
<code>"bandint"</code> - either full or banded and estimated internally or
by user.
</p>
</td></tr>
<tr><td><code id="lsodar_+3A_rootfunc">rootfunc</code></td>
<td>
<p>if not <code>NULL</code>, an <span class="rlang"><b>R</b></span> function that computes the
function whose root has to be estimated or a string giving the name
of a function or subroutine in &lsquo;<span class="file">dllname</span>&rsquo; that computes the root
function.  The <span class="rlang"><b>R</b></span> calling sequence for <code>rootfunc</code> is identical
to that of <code>func</code>.  <code>rootfunc</code> should return a vector with
the function values whose root is sought.
</p>
</td></tr>
<tr><td><code id="lsodar_+3A_verbose">verbose</code></td>
<td>
<p>a logical value that, when <code>TRUE</code>,  will
print the <code>diagnostiscs</code> of the integration - see details.
</p>
</td></tr>
<tr><td><code id="lsodar_+3A_nroot">nroot</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo;  is specified: the number of
constraint functions whose roots are desired during the integration;
if <code>rootfunc</code> is an R-function, the solver estimates the number
of roots.
</p>
</td></tr>
<tr><td><code id="lsodar_+3A_tcrit">tcrit</code></td>
<td>
<p>if not <code>NULL</code>, then <code>lsodar</code> cannot integrate
past <code>tcrit</code>. The FORTRAN routine <code>lsodar</code> overshoots its
targets (times points in the vector <code>times</code>), and interpolates
values for the desired time points.  If there is a time beyond which
integration should not proceed (perhaps because of a singularity),
that should be provided in <code>tcrit</code>.
</p>
</td></tr>
<tr><td><code id="lsodar_+3A_hmin">hmin</code></td>
<td>
<p>an optional minimum value of the integration stepsize. In
special situations this parameter may speed up computations with the
cost of precision. Don't use <code>hmin</code> if you don't know why!
</p>
</td></tr>
<tr><td><code id="lsodar_+3A_hmax">hmax</code></td>
<td>
<p>an optional maximum value of the integration stepsize. If
not specified, <code>hmax</code> is set to the largest difference in
<code>times</code>, to avoid that the simulation possibly ignores
short-term events. If 0, no maximal size is specified.
</p>
</td></tr>
<tr><td><code id="lsodar_+3A_hini">hini</code></td>
<td>
<p>initial step size to be attempted; if 0, the initial step
size is determined by the solver.
</p>
</td></tr>
<tr><td><code id="lsodar_+3A_ynames">ynames</code></td>
<td>
<p>logical, if <code>FALSE</code>: names of state variables are not
passed to function <code>func</code>; this may speed up the simulation
especially for large models.
</p>
</td></tr>
<tr><td><code id="lsodar_+3A_maxordn">maxordn</code></td>
<td>
<p>the maximum order to be allowed in case the method is
non-stiff. Should be &lt;= 12. Reduce <code>maxord</code> to save storage space.
</p>
</td></tr>
<tr><td><code id="lsodar_+3A_maxords">maxords</code></td>
<td>
<p>the maximum order to be allowed in case the method is
stiff. Should be &lt;= 5. Reduce maxord to save storage space.
</p>
</td></tr>
<tr><td><code id="lsodar_+3A_bandup">bandup</code></td>
<td>
<p>number of non-zero bands above the diagonal, in case
the Jacobian is banded.
</p>
</td></tr>
<tr><td><code id="lsodar_+3A_banddown">banddown</code></td>
<td>
<p>number of non-zero bands below the diagonal, in case
the Jacobian is banded.
</p>
</td></tr>
<tr><td><code id="lsodar_+3A_maxsteps">maxsteps</code></td>
<td>
<p>maximal number of steps per output interval taken by the
solver.
</p>
</td></tr>
<tr><td><code id="lsodar_+3A_dllname">dllname</code></td>
<td>
<p>a string giving the name of the shared library
(without extension) that contains all the compiled function or
subroutine definitions refered to in <code>func</code> and
<code>jacfunc</code>. See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="lsodar_+3A_initfunc">initfunc</code></td>
<td>
<p>if not <code>NULL</code>, the name of the initialisation function
(which initialises values of parameters), as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="lsodar_+3A_initpar">initpar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified and an
initialisation function <code>initfunc</code> is in the dll: the
parameters passed to the initialiser, to initialise the common
blocks (FORTRAN) or global variables (C, C++).
</p>
</td></tr>
<tr><td><code id="lsodar_+3A_rpar">rpar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with
double precision values passed to the dll-functions whose names are
specified by <code>func</code> and <code>jacfunc</code>.
</p>
</td></tr>
<tr><td><code id="lsodar_+3A_ipar">ipar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with
integer values passed to the dll-functions whose names are specified
by <code>func</code> and <code>jacfunc</code>.
</p>
</td></tr>
<tr><td><code id="lsodar_+3A_nout">nout</code></td>
<td>
<p>only used if <code>dllname</code> is specified and the model is
defined in compiled code: the number of output variables calculated
in the compiled function <code>func</code>, present in the shared
library. Note: it is not automatically checked whether this is
indeed the number of output variables calculated in the dll - you have
to perform this check in the code - See package vignette
<code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="lsodar_+3A_outnames">outnames</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified and
<code>nout</code> &gt; 0: the names of output variables calculated in the
compiled function <code>func</code>, present in the shared library.
These names will be used to label the output matrix.
</p>
</td></tr>
<tr><td><code id="lsodar_+3A_forcings">forcings</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified: a list with
the forcing function data sets, each present as a two-columned matrix,
with (time,value); interpolation outside the interval
[min(<code>times</code>), max(<code>times</code>)] is done by taking the value at
the closest data extreme.
</p>
<p>See <a href="#topic+forcings">forcings</a> or package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="lsodar_+3A_initforc">initforc</code></td>
<td>
<p>if not <code>NULL</code>, the name of the forcing function
initialisation function, as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. It MUST be present if <code>forcings</code> has been given a
value.
See <a href="#topic+forcings">forcings</a> or package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="lsodar_+3A_fcontrol">fcontrol</code></td>
<td>
<p>A list of control parameters for the forcing functions.
See <a href="#topic+forcings">forcings</a> or vignette <code>compiledCode</code>.
</p>
</td></tr>
<tr><td><code id="lsodar_+3A_events">events</code></td>
<td>
<p>A matrix or data frame that specifies events, i.e. when the value of a 
state variable is suddenly changed. See <a href="#topic+events">events</a> for more information.
</p>
</td></tr>
<tr><td><code id="lsodar_+3A_lags">lags</code></td>
<td>
<p>A list that specifies timelags, i.e. the number of steps 
that has to be kept. To be used for delay differential equations. 
See <a href="#topic+timelags">timelags</a>, <a href="#topic+dede">dede</a> for more information.
</p>
</td></tr>
<tr><td><code id="lsodar_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>func</code> and
<code>jacfunc</code> allowing this to be a generic function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The work is done by the FORTRAN subroutine <code>lsodar</code>, whose
documentation should be consulted for details (it is included as
comments in the source file &lsquo;<span class="file">src/opkdmain.f</span>&rsquo;).  The
implementation is based on the November, 2003 version of lsodar, from
Netlib.
</p>
<p><code>lsodar</code> switches automatically between stiff and nonstiff
methods (similar as <code>lsoda</code>).  This means that the user does not
have to determine whether the problem is stiff or not, and the solver
will automatically choose the appropriate method.  It always starts
with the nonstiff method.
</p>
<p><code>lsodar</code> can find the root of at least one of a set of constraint functions
<code>rootfunc</code> of the independent and dependent variables.  It then returns the
solution at the root if that occurs sooner than the specified stop
condition, and otherwise returns the solution according the specified
stop condition.
</p>
<p>Caution:  Because of numerical errors in the function
<code>rootfun</code> due to roundoff and integration error, <code>lsodar</code> may
return false roots, or return the same root at two or more
nearly equal values of <code>time</code>.
</p>
<p>The form of the <b>Jacobian</b> can be specified by <code>jactype</code>
which can take the following values:
</p>

<dl>
<dt>jactype = &quot;fullint&quot;:</dt><dd><p>a full Jacobian, calculated internally
by lsodar, the default,
</p>
</dd>
<dt>jactype = &quot;fullusr&quot;:</dt><dd><p>a full Jacobian, specified by user
function <code>jacfunc</code>,
</p>
</dd>
<dt>jactype = &quot;bandusr&quot;:</dt><dd><p>a banded Jacobian, specified by user
function <code>jacfunc</code>; the size of the bands specified by
<code>bandup</code> and <code>banddown</code>,
</p>
</dd>
<dt>jactype = &quot;bandint&quot;:</dt><dd><p>banded Jacobian, calculated by lsodar;
the size of the bands specified by <code>bandup</code> and
<code>banddown</code>.
</p>
</dd>
</dl>

<p>If <code>jactype</code> = &quot;fullusr&quot; or &quot;bandusr&quot; then the user must supply a
subroutine <code>jacfunc</code>.
</p>
<p>The input parameters <code>rtol</code>, and <code>atol</code> determine the
<b>error control</b> performed by the solver. See <code><a href="#topic+lsoda">lsoda</a></code>
for details.
</p>
<p>The output will have the attribute <b>iroot</b>, if a root was found
<b>iroot</b> is a vector, its length equal to the number of constraint
functions it will have a value of 1 for the constraint function whose
root that has been found and 0 otherwise.
</p>
<p>The diagnostics of the integration can be printed to screen
by calling <code><a href="#topic+diagnostics">diagnostics</a></code>. If <code>verbose</code> = <code>TRUE</code>,
the diagnostics will written to the screen at the end of the integration.
</p>
<p>See vignette(&quot;deSolve&quot;) for an explanation of each element in the vectors
containing the diagnostic properties and how to directly access them.
</p>
<p><b>Models</b> may be defined in compiled C or FORTRAN code, as well as
in an R-function. See package vignette <code>"compiledCode"</code> for details.
</p>
<p>More information about models defined in compiled code is in the package
vignette (&quot;compiledCode&quot;); information about linking forcing functions
to compiled code is in <a href="#topic+forcings">forcings</a>.
</p>
<p>Examples in both C and FORTRAN are in the &lsquo;<span class="file">dynload</span>&rsquo; subdirectory
of the <code>deSolve</code> package directory.
</p>


<h3>Value</h3>

<p>A matrix of class <code>deSolve</code> with up to as many rows as elements
in <code>times</code> and as many columns as elements in <code>y</code> plus the number of &quot;global&quot;
values returned in the next elements of the return from <code>func</code>,
plus and additional column for the time value.  There will be a row
for each element in <code>times</code> unless the FORTRAN routine &lsquo;lsodar&rsquo;
returns with an unrecoverable error. If <code>y</code> has a names
attribute, it will be used to label the columns of the output value.
</p>
<p>If a root has been found, the output will have the attribute
<code>iroot</code>, an integer indicating which root has been found.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>References</h3>

<p>Alan C. Hindmarsh, ODEPACK, A Systematized Collection of ODE Solvers,
in Scientific Computing, R. S. Stepleman et al. (Eds.), North-Holland,
Amsterdam, 1983, pp. 55-64.
</p>
<p>Linda R. Petzold, Automatic Selection of Methods for Solving Stiff and
Nonstiff Systems of Ordinary Differential Equations, Siam
J. Sci. Stat. Comput. 4 (1983), pp. 136-148.
<a href="https://doi.org/10.1137/0904010">doi:10.1137/0904010</a>
</p>
<p>Kathie L. Hiebert and Lawrence F. Shampine, Implicitly Defined Output
Points for Solutions of ODEs, Sandia Report SAND80-0180, February 1980.
</p>
<p>Netlib: <a href="https://netlib.org">https://netlib.org</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+roots">roots</a></code> for more examples on roots and events 
</p>
</li>
<li> <p><code><a href="#topic+rk">rk</a></code>, <code><a href="#topic+rkMethod">rkMethod</a></code>, <code><a href="#topic+rk4">rk4</a></code> and <code><a href="#topic+euler">euler</a></code> for
Runge-Kutta integrators.
</p>
</li>
<li> <p><code><a href="#topic+lsoda">lsoda</a></code>, <code><a href="#topic+lsode">lsode</a></code>,
<code><a href="#topic+lsodes">lsodes</a></code>, <code><a href="#topic+vode">vode</a></code>,
<code><a href="#topic+daspk">daspk</a></code> for other solvers of the Livermore family,
</p>
</li>
<li> <p><code><a href="#topic+ode">ode</a></code> for a general interface to most of the ODE solvers,
</p>
</li>
<li> <p><code><a href="#topic+ode.band">ode.band</a></code> for solving models with a banded
Jacobian,
</p>
</li>
<li> <p><code><a href="#topic+ode.1D">ode.1D</a></code> for integrating 1-D models,
</p>
</li>
<li> <p><code><a href="#topic+ode.2D">ode.2D</a></code> for integrating 2-D models,
</p>
</li>
<li> <p><code><a href="#topic+ode.3D">ode.3D</a></code> for integrating 3-D models,
</p>
</li></ul>

<p><code><a href="#topic+diagnostics">diagnostics</a></code> to print diagnostic messages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =======================================================================
## Example 1:
##   from lsodar source code
## =======================================================================

Fun &lt;- function (t, y, parms) {
  ydot &lt;- vector(len = 3)
  ydot[1] &lt;- -.04*y[1] + 1.e4*y[2]*y[3]
  ydot[3] &lt;- 3.e7*y[2]*y[2]
  ydot[2] &lt;- -ydot[1] - ydot[3]
  return(list(ydot, ytot = sum(y)))
}

rootFun &lt;- function (t, y, parms) {
  yroot &lt;- vector(len = 2)
  yroot[1] &lt;- y[1] - 1.e-4
  yroot[2] &lt;- y[3] - 1.e-2
  return(yroot)
}

y     &lt;- c(1, 0, 0)
times &lt;- c(0, 0.4*10^(0:8))

out   &lt;- lsodar(y = y, times = times, fun = Fun, rootfun = rootFun,
                rtol = 1e-4, atol = c(1e-6, 1e-10, 1e-6), parms = NULL)
print(paste("root is found for eqn", which(attributes(out)$iroot == 1)))
print(out[nrow(out),])

diagnostics(out)
  
## =======================================================================
## Example 2:
##   using lsodar to estimate steady-state conditions
## =======================================================================

## Bacteria (Bac) are growing on a substrate (Sub)
model &lt;- function(t, state, pars) {
  with (as.list(c(state, pars)), {
    ##        substrate uptake             death     respiration
    dBact &lt;-  gmax*eff*Sub/(Sub+ks)*Bact - dB*Bact - rB*Bact
    dSub  &lt;- -gmax    *Sub/(Sub+ks)*Bact + dB*Bact            + input

    return(list(c(dBact,dSub)))
  })
}

## root is the condition where sum of |rates of change|
## is very small

rootfun &lt;- function (t, state, pars) {
  dstate &lt;- unlist(model(t, state, pars)) # rate of change vector
  return(sum(abs(dstate)) - 1e-10)
}

pars &lt;- list(Bini = 0.1, Sini = 100, gmax = 0.5, eff = 0.5,
             ks = 0.5, rB = 0.01, dB = 0.01, input = 0.1)

tout    &lt;- c(0, 1e10)
state   &lt;- c(Bact = pars$Bini, Sub = pars$Sini)
out     &lt;- lsodar(state, tout, model, pars, rootfun = rootfun)
print(out)


## =======================================================================
## Example 3:
##   using lsodar to trigger an event
## =======================================================================

## a state variable is decaying at a first-order rate. 
## when it reaches the value 0.1, a random amount is added.

derivfun &lt;- function (t,y,parms)
  list (-0.05 * y)

rootfun &lt;- function (t,y,parms)
  return(y - 0.1) 

eventfun &lt;- function(t,y,parms)
  return(y + runif(1))  

yini &lt;- 0.8
times &lt;- 0:200

out &lt;- lsodar(func=derivfun, y = yini, times=times, 
  rootfunc = rootfun, events = list(func=eventfun, root = TRUE))

plot(out, type = "l", lwd = 2, main = "lsodar with event")
  
</code></pre>

<hr>
<h2 id='lsode'>Solver for Ordinary Differential Equations (ODE)</h2><span id='topic+lsode'></span>

<h3>Description</h3>

<p>Solves the initial value problem for stiff or nonstiff systems of
ordinary differential equations (ODE) in the form: </p>
<p style="text-align: center;"><code class="reqn">dy/dt = 
  f(t,y)</code>
</p>
<p>.
</p>
<p>The <span class="rlang"><b>R</b></span> function <code>lsode</code> provides an interface to the FORTRAN ODE
solver of the same name, written by Alan C. Hindmarsh and Andrew
H. Sherman.
</p>
<p>It combines parts of the code <code>lsodar</code> and can thus find the root
of at least one of a set of constraint functions g(i) of the independent
and dependent variables. This can be used to stop the simulation or to 
trigger <a href="#topic+events">events</a>, i.e. a sudden change in one of the state variables.
</p>
<p>The system of ODE's is written as an <span class="rlang"><b>R</b></span> function or be defined in
compiled code that has been dynamically loaded.
</p>
<p>In contrast to <code><a href="#topic+lsoda">lsoda</a></code>, the user has to specify whether or
not the problem is stiff and choose the appropriate solution method.
</p>
<p><code>lsode</code> is very similar to <code><a href="#topic+vode">vode</a></code>, but uses a
fixed-step-interpolate method rather than the variable-coefficient
method in <code><a href="#topic+vode">vode</a></code>. In addition, in <code>vode</code> it is
possible to choose whether or not a copy of the Jacobian is saved for
reuse in the corrector iteration algorithm; In <code>lsode</code>, a copy is
not kept.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsode(y, times, func, parms, rtol = 1e-6, atol = 1e-6,  
  jacfunc = NULL, jactype = "fullint", mf = NULL, rootfunc = NULL,
  verbose = FALSE, nroot = 0, tcrit = NULL, hmin = 0, hmax = NULL, 
  hini = 0, ynames = TRUE, maxord = NULL, bandup = NULL, banddown = NULL,
  maxsteps = 5000, dllname = NULL, initfunc = dllname,
  initpar = parms, rpar = NULL, ipar = NULL, nout = 0,
  outnames = NULL, forcings=NULL, initforc = NULL, 
  fcontrol=NULL, events=NULL, lags = NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsode_+3A_y">y</code></td>
<td>
<p>the initial (state) values for the ODE system. If <code>y</code>
has a name attribute, the names will be used to label the output
matrix.
</p>
</td></tr>
<tr><td><code id="lsode_+3A_times">times</code></td>
<td>
<p>time sequence for which output is wanted; the first
value of <code>times</code> must be the initial time; if only one step is
to be taken; set <code>times</code> = <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="lsode_+3A_func">func</code></td>
<td>
<p>either an <span class="rlang"><b>R</b></span>-function that computes the values of the
derivatives in the ODE system (the <em>model definition</em>) at time
t, or a character string giving the name of a compiled function in a
dynamically loaded shared library.
</p>
<p>If <code>func</code> is an <span class="rlang"><b>R</b></span>-function, it must be defined as:
<code>func &lt;- function(t, y, parms,...)</code>.  <code>t</code> is the current time
point in the integration, <code>y</code> is the current estimate of the
variables in the ODE system.  If the initial values <code>y</code> has a
<code>names</code> attribute, the names will be available inside <code>func</code>.
<code>parms</code> is a vector or list of parameters; ... (optional) are
any other arguments passed to the function.
</p>
<p>The return value of <code>func</code> should be a list, whose first
element is a vector containing the derivatives of <code>y</code> with
respect to <code>time</code>, and whose next elements are global values
that are required at each point in <code>times</code>.  The derivatives
must be specified in the <b>same order</b> as the state variables <code>y</code>.
</p>
<p>If <code>func</code> is
a string, then <code>dllname</code> must give the name of the shared
library (without extension) which must be loaded before
<code>lsode()</code> is called. See package vignette <code>"compiledCode"</code>
for more details.
</p>
</td></tr>
<tr><td><code id="lsode_+3A_parms">parms</code></td>
<td>
<p>vector or list of parameters used in <code>func</code> or
<code>jacfunc</code>.
</p>
</td></tr>
<tr><td><code id="lsode_+3A_rtol">rtol</code></td>
<td>
<p>relative error tolerance, either a
scalar or an array as long as <code>y</code>. See details.
</p>
</td></tr>
<tr><td><code id="lsode_+3A_atol">atol</code></td>
<td>
<p>absolute error tolerance, either a scalar or an array as
long as <code>y</code>. See details.
</p>
</td></tr>
<tr><td><code id="lsode_+3A_jacfunc">jacfunc</code></td>
<td>
<p>if not <code>NULL</code>, an <span class="rlang"><b>R</b></span> function that computes the
Jacobian of the system of differential equations
<code class="reqn">\partial\dot{y}_i/\partial y_j</code>, or
a string giving the name of a function or subroutine in
&lsquo;<span class="file">dllname</span>&rsquo; that computes the Jacobian (see vignette
<code>"compiledCode"</code> for more about this option).
</p>
<p>In some circumstances, supplying
<code>jacfunc</code> can speed up the computations, if the system is
stiff.  The <span class="rlang"><b>R</b></span> calling sequence for <code>jacfunc</code> is identical to
that of <code>func</code>.
</p>
<p>If the Jacobian is a full matrix,
<code>jacfunc</code> should return a matrix <code class="reqn">\partial\dot{y}/\partial y</code>, where the ith row
contains the derivative of <code class="reqn">dy_i/dt</code> with respect to <code class="reqn">y_j</code>,
or a vector containing the matrix elements by columns (the way <span class="rlang"><b>R</b></span>
and FORTRAN store matrices).  <br /> If the Jacobian is banded,
<code>jacfunc</code> should return a matrix containing only the nonzero
bands of the Jacobian, rotated row-wise. See first example of <a href="#topic+lsode">lsode</a>.
</p>
</td></tr>
<tr><td><code id="lsode_+3A_jactype">jactype</code></td>
<td>
<p>the structure of the Jacobian, one of
<code>"fullint"</code>, <code>"fullusr"</code>, <code>"bandusr"</code> or
<code>"bandint"</code> - either full or banded and estimated internally or
by user; overruled if <code>mf</code>is not <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="lsode_+3A_mf">mf</code></td>
<td>
<p>the &quot;method flag&quot; passed to function lsode - overrules
<code>jactype</code> - provides more options than <code>jactype</code> - see
details.
</p>
</td></tr>
<tr><td><code id="lsode_+3A_rootfunc">rootfunc</code></td>
<td>
<p>if not <code>NULL</code>, an <span class="rlang"><b>R</b></span> function that computes the
function whose root has to be estimated or a string giving the name
of a function or subroutine in &lsquo;<span class="file">dllname</span>&rsquo; that computes the root
function.  The <span class="rlang"><b>R</b></span> calling sequence for <code>rootfunc</code> is identical
to that of <code>func</code>.  <code>rootfunc</code> should return a vector with
the function values whose root is sought.
</p>
</td></tr>
<tr><td><code id="lsode_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE: full output to the screen, e.g. will
print the <code>diagnostiscs</code> of the integration - see details.
</p>
</td></tr>
<tr><td><code id="lsode_+3A_nroot">nroot</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo;  is specified: the number of
constraint functions whose roots are desired during the integration;
if <code>rootfunc</code> is an R-function, the solver estimates the number
of roots.
</p>
</td></tr>
<tr><td><code id="lsode_+3A_tcrit">tcrit</code></td>
<td>
<p>if not <code>NULL</code>, then <code>lsode</code> cannot integrate
past <code>tcrit</code>. The FORTRAN routine <code>lsode</code> overshoots its
targets (times points in the vector <code>times</code>), and interpolates
values for the desired time points.  If there is a time beyond which
integration should not proceed (perhaps because of a singularity),
that should be provided in <code>tcrit</code>.
</p>
</td></tr>
<tr><td><code id="lsode_+3A_hmin">hmin</code></td>
<td>
<p>an optional minimum value of the integration stepsize. In
special situations this parameter may speed up computations with the
cost of precision. Don't use <code>hmin</code> if you don't know why!
</p>
</td></tr>
<tr><td><code id="lsode_+3A_hmax">hmax</code></td>
<td>
<p>an optional maximum value of the integration stepsize. If
not specified, <code>hmax</code> is set to the largest difference in
<code>times</code>, to avoid that the simulation possibly ignores
short-term events. If 0, no maximal size is specified.
</p>
</td></tr>
<tr><td><code id="lsode_+3A_hini">hini</code></td>
<td>
<p>initial step size to be attempted; if 0, the initial step
size is determined by the solver.
</p>
</td></tr>
<tr><td><code id="lsode_+3A_ynames">ynames</code></td>
<td>
<p>logical, if <code>FALSE</code> names of state variables are not
passed to function <code>func</code>; this may speed up the simulation especially
for multi-D models.
</p>
</td></tr>
<tr><td><code id="lsode_+3A_maxord">maxord</code></td>
<td>
<p>the maximum order to be allowed. <code>NULL</code> uses the default,
i.e. order 12 if implicit Adams method (meth = 1), order 5 if BDF
method (meth = 2). Reduce maxord to save storage space.
</p>
</td></tr>
<tr><td><code id="lsode_+3A_bandup">bandup</code></td>
<td>
<p>number of non-zero bands above the diagonal, in case
the Jacobian is banded.
</p>
</td></tr>
<tr><td><code id="lsode_+3A_banddown">banddown</code></td>
<td>
<p>number of non-zero bands below the diagonal, in case
the Jacobian is banded.
</p>
</td></tr>
<tr><td><code id="lsode_+3A_maxsteps">maxsteps</code></td>
<td>
<p>maximal number of steps per output interval taken by the
solver.
</p>
</td></tr>
<tr><td><code id="lsode_+3A_dllname">dllname</code></td>
<td>
<p>a string giving the name of the shared library
(without extension) that contains all the compiled function or
subroutine definitions refered to in <code>func</code> and
<code>jacfunc</code>. See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="lsode_+3A_initfunc">initfunc</code></td>
<td>
<p>if not <code>NULL</code>, the name of the initialisation function
(which initialises values of parameters), as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="lsode_+3A_initpar">initpar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified and an
initialisation function <code>initfunc</code> is in the dll: the
parameters passed to the initialiser, to initialise the common
blocks (FORTRAN) or global variables (C, C++).
</p>
</td></tr>
<tr><td><code id="lsode_+3A_rpar">rpar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with
double precision values passed to the dll-functions whose names are
specified by <code>func</code> and <code>jacfunc</code>.
</p>
</td></tr>
<tr><td><code id="lsode_+3A_ipar">ipar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with
integer values passed to the dll-functions whose names are specified
by <code>func</code> and <code>jacfunc</code>.
</p>
</td></tr>
<tr><td><code id="lsode_+3A_nout">nout</code></td>
<td>
<p>only used if <code>dllname</code> is specified and the model is
defined in compiled code: the number of output variables calculated
in the compiled function <code>func</code>, present in the shared
library. Note: it is not automatically checked whether this is
indeed the number of output variables calculated in the dll - you have
to perform this check in the code - See package vignette
<code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="lsode_+3A_outnames">outnames</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified and
<code>nout</code> &gt; 0: the names of output variables calculated in the
compiled function <code>func</code>, present in the shared library.
These names will be used to label the output matrix.
</p>
</td></tr>
<tr><td><code id="lsode_+3A_forcings">forcings</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified: a list with
the forcing function data sets, each present as a two-columned matrix,
with (time,value); interpolation outside the interval
[min(<code>times</code>), max(<code>times</code>)] is done by taking the value at
the closest data extreme.
</p>
<p>See <a href="#topic+forcings">forcings</a> or package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="lsode_+3A_initforc">initforc</code></td>
<td>
<p>if not <code>NULL</code>, the name of the forcing function
initialisation function, as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. It MUST be present if <code>forcings</code> has been given a
value.
See <a href="#topic+forcings">forcings</a> or package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="lsode_+3A_fcontrol">fcontrol</code></td>
<td>
<p>A list of control parameters for the forcing functions.
See <a href="#topic+forcings">forcings</a> or vignette <code>compiledCode</code>.
</p>
</td></tr>
<tr><td><code id="lsode_+3A_events">events</code></td>
<td>
<p>A matrix or data frame that specifies events, i.e. when the value of a 
state variable is suddenly changed. See <a href="#topic+events">events</a> for more information.
</p>
</td></tr>
<tr><td><code id="lsode_+3A_lags">lags</code></td>
<td>
<p>A list that specifies timelags, i.e. the number of steps 
that has to be kept. To be used for delay differential equations. 
See <a href="#topic+timelags">timelags</a>, <a href="#topic+dede">dede</a> for more information.
</p>
</td></tr>
<tr><td><code id="lsode_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>func</code> and
<code>jacfunc</code> allowing this to be a generic function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The work is done by the FORTRAN subroutine <code>lsode</code>, whose
documentation should be consulted for details (it is included as
comments in the source file &lsquo;<span class="file">src/opkdmain.f</span>&rsquo;). The implementation
is based on the November, 2003 version of lsode, from Netlib.
</p>
<p>Before using the integrator <code>lsode</code>, the user has to decide
whether or not the problem is stiff.
</p>
<p>If the problem is nonstiff, use method flag <code>mf</code> = 10, which
selects a nonstiff (Adams) method, no Jacobian used.<br /> If the problem
is stiff, there are four standard choices which can be specified with
<code>jactype</code> or <code>mf</code>.
</p>
<p>The options for <b>jactype</b> are
</p>

<dl>
<dt>jactype = &quot;fullint&quot;</dt><dd><p>a full Jacobian, calculated internally by
lsode, corresponds to <code>mf</code> = 22,
</p>
</dd>
<dt>jactype = &quot;fullusr&quot;</dt><dd><p>a full Jacobian, specified by user
function <code>jacfunc</code>, corresponds to <code>mf</code> = 21,
</p>
</dd>
<dt>jactype = &quot;bandusr&quot;</dt><dd><p>a banded Jacobian, specified by user
function <code>jacfunc</code>; the size of the bands specified by
<code>bandup</code> and <code>banddown</code>, corresponds to <code>mf</code> = 24,
</p>
</dd>
<dt>jactype = &quot;bandint&quot;</dt><dd><p>a banded Jacobian, calculated by lsode;
the size of the bands specified by <code>bandup</code> and
<code>banddown</code>, corresponds to <code>mf</code> = 25.
</p>
</dd>
</dl>

<p>More options are available when specifying <b>mf</b> directly. <br /> The
legal values of <code>mf</code> are 10, 11, 12, 13, 14, 15, 20, 21, 22, 23,
24, 25.<br /> <code>mf</code> is a positive two-digit integer, <code>mf</code> =
(10*METH + MITER), where
</p>

<dl>
<dt>METH</dt><dd><p>indicates the basic linear multistep method: METH = 1
means the implicit Adams method. METH = 2 means the method based
on backward differentiation formulas (BDF-s).
</p>
</dd>
<dt>MITER</dt><dd><p>indicates the corrector iteration method: MITER = 0
means functional iteration (no Jacobian matrix is involved).
MITER = 1 means chord iteration with a user-supplied full (NEQ by
NEQ) Jacobian.  MITER = 2 means chord iteration with an internally
generated (difference quotient) full Jacobian (using NEQ extra
calls to <code>func</code> per df/dy value).  MITER = 3 means chord
iteration with an internally generated diagonal Jacobian
approximation (using 1 extra call to <code>func</code> per df/dy
evaluation).  MITER = 4 means chord iteration with a user-supplied
banded Jacobian.  MITER = 5 means chord iteration with an
internally generated banded Jacobian (using ML+MU+1 extra calls to
<code>func</code> per df/dy evaluation).</p>
</dd>
</dl>

<p>If MITER = 1 or 4, the user must supply a subroutine <code>jacfunc</code>.
</p>
<p>Inspection of the example below shows how to specify both a banded and
full Jacobian.
</p>
<p>The input parameters <code>rtol</code>, and <code>atol</code> determine the
<b>error control</b> performed by the solver.  See <code><a href="#topic+lsoda">lsoda</a></code>
for details.
</p>
<p>The diagnostics of the integration can be printed to screen
by calling <code><a href="#topic+diagnostics">diagnostics</a></code>. If <code>verbose</code> = <code>TRUE</code>,
the diagnostics will written to the screen at the end of the integration.
</p>
<p>See vignette(&quot;deSolve&quot;) for an explanation of each element in the vectors
containing the diagnostic properties and how to directly access them.
</p>
<p><b>Models</b> may be defined in compiled C or FORTRAN code, as well as
in an R-function. See package vignette <code>"compiledCode"</code> for details.
</p>
<p>More information about models defined in compiled code is in the package
vignette (&quot;compiledCode&quot;); information about linking forcing functions
to compiled code is in <a href="#topic+forcings">forcings</a>.
</p>
<p>Examples in both C and FORTRAN are in the &lsquo;<span class="file">dynload</span>&rsquo; subdirectory
of the <code>deSolve</code> package directory.
</p>
<p><code>lsode</code> can find the root of at least one of a set of constraint functions
<code>rootfunc</code> of the independent and dependent variables.  It then returns the
solution at the root if that occurs sooner than the specified stop
condition, and otherwise returns the solution according the specified
stop condition.
</p>
<p>Caution:  Because of numerical errors in the function
<code>rootfun</code> due to roundoff and integration error, <code>lsode</code> may
return false roots, or return the same root at two or more
nearly equal values of <code>time</code>.
</p>


<h3>Value</h3>

<p>A matrix of class <code>deSolve</code> with up to as many rows as elements
in <code>times</code> and as many columns as elements in <code>y</code> plus the number of &quot;global&quot;
values returned in the next elements of the return from <code>func</code>,
plus and additional column for the time value.  There will be a row
for each element in <code>times</code> unless the FORTRAN routine &lsquo;lsode&rsquo;
returns with an unrecoverable error. If <code>y</code> has a names
attribute, it will be used to label the columns of the output value.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>References</h3>

<p>Alan C. Hindmarsh, &quot;ODEPACK, A Systematized Collection of ODE
Solvers,&quot; in Scientific Computing, R. S. Stepleman, et al., Eds.
(North-Holland, Amsterdam, 1983), pp. 55-64.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+rk">rk</a></code>, </p>
</li>
<li> <p><code><a href="#topic+rk4">rk4</a></code> and <code><a href="#topic+euler">euler</a></code> for
Runge-Kutta integrators.
</p>
</li>
<li> <p><code><a href="#topic+lsoda">lsoda</a></code>,
<code><a href="#topic+lsodes">lsodes</a></code>, <code><a href="#topic+lsodar">lsodar</a></code>, <code><a href="#topic+vode">vode</a></code>,
<code><a href="#topic+daspk">daspk</a></code> for other solvers of the Livermore family,
</p>
</li>
<li> <p><code><a href="#topic+ode">ode</a></code> for a general interface to most of the ODE solvers,
</p>
</li>
<li> <p><code><a href="#topic+ode.band">ode.band</a></code> for solving models with a banded
Jacobian,
</p>
</li>
<li> <p><code><a href="#topic+ode.1D">ode.1D</a></code> for integrating 1-D models,
</p>
</li>
<li> <p><code><a href="#topic+ode.2D">ode.2D</a></code> for integrating 2-D models,
</p>
</li>
<li> <p><code><a href="#topic+ode.3D">ode.3D</a></code> for integrating 3-D models,
</p>
</li></ul>

<p><code><a href="#topic+diagnostics">diagnostics</a></code> to print diagnostic messages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =======================================================================
## Example 1:
##   Various ways to solve the same model.
## =======================================================================

## the model, 5 state variables
f1 &lt;- function  (t, y, parms) {
  ydot &lt;- vector(len = 5)

  ydot[1] &lt;-  0.1*y[1] -0.2*y[2]
  ydot[2] &lt;- -0.3*y[1] +0.1*y[2] -0.2*y[3]
  ydot[3] &lt;-           -0.3*y[2] +0.1*y[3] -0.2*y[4]
  ydot[4] &lt;-                     -0.3*y[3] +0.1*y[4] -0.2*y[5]
  ydot[5] &lt;-                               -0.3*y[4] +0.1*y[5]

  return(list(ydot))
}

## the Jacobian, written as a full matrix
fulljac &lt;- function  (t, y, parms) {
  jac &lt;- matrix(nrow = 5, ncol = 5, byrow = TRUE,
                data = c(0.1, -0.2,  0  ,  0  ,  0  ,
                        -0.3,  0.1, -0.2,  0  ,  0  ,
                         0  , -0.3,  0.1, -0.2,  0  ,
                         0  ,  0  , -0.3,  0.1, -0.2,
                         0  ,  0  ,  0  , -0.3,  0.1))
  return(jac)
}

## the Jacobian, written in banded form
bandjac &lt;- function  (t, y, parms) {
  jac &lt;- matrix(nrow = 3, ncol = 5, byrow = TRUE,
                data = c( 0  , -0.2, -0.2, -0.2, -0.2,
                          0.1,  0.1,  0.1,  0.1,  0.1,
                         -0.3, -0.3, -0.3, -0.3,    0))
  return(jac)
}

## initial conditions and output times
yini  &lt;- 1:5
times &lt;- 1:20

## default: stiff method, internally generated, full Jacobian
out   &lt;- lsode(yini, times, f1, parms = 0, jactype = "fullint")

## stiff method, user-generated full Jacobian
out2  &lt;- lsode(yini, times, f1, parms = 0, jactype = "fullusr",
              jacfunc = fulljac)

## stiff method, internally-generated banded Jacobian
## one nonzero band above (up) and below(down) the diagonal
out3  &lt;- lsode(yini, times, f1, parms = 0, jactype = "bandint",
                              bandup = 1, banddown = 1)

## stiff method, user-generated banded Jacobian
out4  &lt;- lsode(yini, times, f1, parms = 0, jactype = "bandusr",
              jacfunc = bandjac, bandup = 1, banddown = 1)

## non-stiff method
out5  &lt;- lsode(yini, times, f1, parms = 0, mf = 10)

## =======================================================================
## Example 2:
##   diffusion on a 2-D grid
##   partially specified Jacobian
## =======================================================================

diffusion2D &lt;- function(t, Y, par) {
   y &lt;- matrix(nrow = n, ncol = n, data = Y)
   dY   &lt;- r*y     # production

   ## diffusion in X-direction; boundaries = 0-concentration
   Flux &lt;- -Dx * rbind(y[1,],(y[2:n,]-y[1:(n-1),]),-y[n,])/dx
   dY   &lt;- dY - (Flux[2:(n+1),]-Flux[1:n,])/dx

   ## diffusion in Y-direction
   Flux &lt;- -Dy * cbind(y[,1],(y[,2:n]-y[,1:(n-1)]),-y[,n])/dy
   dY    &lt;- dY - (Flux[,2:(n+1)]-Flux[,1:n])/dy

   return(list(as.vector(dY)))
}

## parameters
dy    &lt;- dx &lt;- 1   # grid size
Dy    &lt;- Dx &lt;- 1   # diffusion coeff, X- and Y-direction
r     &lt;- 0.025     # production rate
times &lt;- c(0, 1)

n  &lt;- 50
y  &lt;- matrix(nrow = n, ncol = n, 0)

pa &lt;- par(ask = FALSE)

## initial condition
for (i in 1:n) {
  for (j in 1:n) {
    dst &lt;- (i - n/2)^2 + (j - n/2)^2
    y[i, j] &lt;- max(0, 1 - 1/(n*n) * (dst - n)^2)
  }
}
filled.contour(y, color.palette = terrain.colors)

## =======================================================================
##   jacfunc need not be estimated exactly
##   a crude approximation, with a smaller bandwidth will do.
##   Here the half-bandwidth 1 is used, whereas the true
##   half-bandwidths are equal to n.
##   This corresponds to ignoring the y-direction coupling in the ODEs.
## =======================================================================

print(system.time(
  for (i in 1:20) {
    out  &lt;-  lsode(func = diffusion2D, y = as.vector(y), times = times,
              parms = NULL, jactype = "bandint", bandup = 1, banddown = 1)

    filled.contour(matrix(nrow = n, ncol = n, out[2,-1]), zlim = c(0,1),
                  color.palette = terrain.colors, main = i)

    y &lt;- out[2, -1]
  }
))
par(ask = pa)
</code></pre>

<hr>
<h2 id='lsodes'>Solver for Ordinary Differential Equations (ODE) With
Sparse Jacobian
</h2><span id='topic+lsodes'></span>

<h3>Description</h3>

<p>Solves the initial value problem for stiff systems of ordinary
differential equations (ODE) in the form: </p>
<p style="text-align: center;"><code class="reqn">dy/dt = f(t,y)</code>
</p>
<p> and
where the Jacobian matrix df/dy has an arbitrary sparse structure.
</p>
<p>The <span class="rlang"><b>R</b></span> function <code>lsodes</code> provides an interface to the FORTRAN ODE
solver of the same name, written by Alan C. Hindmarsh and Andrew
H. Sherman.
</p>
<p>The system of ODE's is written as an <span class="rlang"><b>R</b></span> function or be defined in
compiled code that has been dynamically loaded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsodes(y, times, func, parms, rtol = 1e-6, atol = 1e-6, 
  jacvec = NULL, sparsetype = "sparseint", nnz = NULL,
  inz = NULL,  rootfunc = NULL,
  verbose = FALSE, nroot = 0, tcrit = NULL, hmin = 0,
  hmax = NULL, hini = 0, ynames = TRUE, maxord = NULL,
  maxsteps = 5000, lrw = NULL, liw = NULL, dllname = NULL,
  initfunc = dllname, initpar = parms, rpar = NULL,
  ipar = NULL, nout = 0, outnames = NULL, forcings=NULL,
  initforc = NULL, fcontrol=NULL, events=NULL, lags = NULL, 
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsodes_+3A_y">y</code></td>
<td>
<p>the initial (state) values for the ODE system. If <code>y</code>
has a name attribute, the names will be used to label the output
matrix.
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_times">times</code></td>
<td>
<p>time sequence for which output is wanted; the first
value of <code>times</code> must be the initial time; if only one step is
to be taken; set <code>times</code> = <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_func">func</code></td>
<td>
<p>either an <span class="rlang"><b>R</b></span>-function that computes the values of the
derivatives in the ODE system (the <em>model definition</em>) at time
<code>t</code>, or a character string giving the name of a compiled
function in a dynamically loaded shared library.
</p>
<p>If <code>func</code> is an <span class="rlang"><b>R</b></span>-function, it must be defined as:
<code>func &lt;- function(t, y, parms,...)</code>.  <code>t</code> is the current
time point in the integration, <code>y</code> is the current estimate of
the variables in the ODE system.  If the initial values <code>y</code> has
a <code>names</code> attribute, the names will be available inside <code>func</code>.
<code>parms</code> is a vector or list of parameters; ... (optional) are
any other arguments passed to the function.
</p>
<p>The return value of <code>func</code> should be a list, whose first
element is a vector containing the derivatives of <code>y</code> with
respect to <code>time</code>, and whose next elements are global values
that are required at each point in <code>times</code>.  The derivatives
must be specified in the <b>same order</b> as the state variables <code>y</code>.
</p>
<p>If <code>func</code> is
a string, then <code>dllname</code> must give the name of the shared
library (without extension) which must be loaded before
<code>lsodes()</code> is called. See package vignette <code>"compiledCode"</code>
for more details.
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_parms">parms</code></td>
<td>
<p>vector or list of parameters used in <code>func</code> or
<code>jacfunc</code>.
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_rtol">rtol</code></td>
<td>
<p>relative error tolerance, either a scalar or an array as
long as <code>y</code>.  See details.
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_atol">atol</code></td>
<td>
<p>absolute error tolerance, either a scalar or an array as
long as <code>y</code>.  See details.
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_jacvec">jacvec</code></td>
<td>
<p>if not <code>NULL</code>, an <span class="rlang"><b>R</b></span> function that computes a
column of the Jacobian of the system of differential equations
<code class="reqn">\partial\dot{y}_i/\partial y_j</code>, 
or a string giving the name of a function or
subroutine in &lsquo;<span class="file">dllname</span>&rsquo; that computes the column of the
Jacobian (see vignette <code>"compiledCode"</code> for more about this option).
</p>
<p>The <span class="rlang"><b>R</b></span>
calling sequence for <code>jacvec</code> is identical to that of
<code>func</code>, but with extra parameter <code>j</code>, denoting the column
number.  Thus, <code>jacvec</code> should be called as: <code>jacvec =
    func(t, y, j, parms)</code> and <code>jacvec</code> should return a vector
containing column <code>j</code> of the Jacobian, i.e.  its i-th value is
<code class="reqn">\partial\dot{y}_i/\partial y_j</code>.
If this function is absent, <code>lsodes</code> will
generate the Jacobian by differences.
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_sparsetype">sparsetype</code></td>
<td>
<p>the sparsity structure of the Jacobian, one of
&quot;sparseint&quot; or &quot;sparseusr&quot;, &quot;sparsejan&quot;, ..., 
The sparsity can be estimated internally by lsodes (first option)
or given by the user (last two). See details.
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_nnz">nnz</code></td>
<td>
<p>the number of nonzero elements in the sparse Jacobian (if
this is unknown, use an estimate).
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_inz">inz</code></td>
<td>
<p>if <code>sparsetype</code> equal to &quot;sparseusr&quot;, a two-columned matrix
with the (row, column) indices to the nonzero elements in the sparse
Jacobian. If <code>sparsetype</code> = &quot;sparsejan&quot;, a vector with the elements 
ian followed by he elements jan as used in the lsodes code. See details.
In all other cases, ignored.
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_rootfunc">rootfunc</code></td>
<td>
<p>if not <code>NULL</code>, an <span class="rlang"><b>R</b></span> function that computes the
function whose root has to be estimated or a string giving the name
of a function or subroutine in &lsquo;<span class="file">dllname</span>&rsquo; that computes the root
function.  The <span class="rlang"><b>R</b></span> calling sequence for <code>rootfunc</code> is identical
to that of <code>func</code>.  <code>rootfunc</code> should return a vector with
the function values whose root is sought.
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>: full output to the screen, e.g. will
print the <code>diagnostiscs</code> of the integration - see details.
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_nroot">nroot</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo;  is specified: the number of
constraint functions whose roots are desired during the integration;
if <code>rootfunc</code> is an R-function, the solver estimates the number
of roots.
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_tcrit">tcrit</code></td>
<td>
<p>if not <code>NULL</code>, then <code>lsodes</code> cannot integrate
past <code>tcrit</code>. The FORTRAN routine <code>lsodes</code> overshoots its
targets (times points in the vector <code>times</code>), and interpolates
values for the desired time points.  If there is a time beyond which
integration should not proceed (perhaps because of a singularity),
that should be provided in <code>tcrit</code>.
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_hmin">hmin</code></td>
<td>
<p>an optional minimum value of the integration stepsize. In
special situations this parameter may speed up computations with the
cost of precision. Don't use <code>hmin</code> if you don't know why!
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_hmax">hmax</code></td>
<td>
<p>an optional maximum value of the integration stepsize. If
not specified, <code>hmax</code> is set to the largest difference in
<code>times</code>, to avoid that the simulation possibly ignores
short-term events. If 0, no maximal size is specified.
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_hini">hini</code></td>
<td>
<p>initial step size to be attempted; if 0, the initial step
size is determined by the solver.
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_ynames">ynames</code></td>
<td>
<p>logical, if <code>FALSE</code> names of state variables are
not passed to function <code>func</code>; this may speed up the simulation
especially for multi-D models.
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_maxord">maxord</code></td>
<td>
<p>the maximum order to be allowed. <code>NULL</code> uses the
default, i.e. order 12 if implicit Adams method (meth = 1), order 5
if BDF method (meth = 2). Reduce maxord to save storage space.
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_maxsteps">maxsteps</code></td>
<td>
<p>maximal number of steps per output interval taken by the
solver.
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_lrw">lrw</code></td>
<td>
<p>the length of the real work array rwork; due to the
sparsicity, this cannot be readily predicted. If <code>NULL</code>, a
guess will be made, and if not sufficient, <code>lsodes</code> will return
with a message indicating the size of rwork actually required.
Therefore, some experimentation may be necessary to estimate the
value of <code>lrw</code>.
</p>
<p>For instance, if you get the error:
</p>
<pre> 
DLSODES- RWORK length is insufficient to proceed.                               
  Length needed is .ge. LENRW (=I1), exceeds LRW (=I2)                    
  In above message,  I1 =     27627   I2 =     25932 
</pre>    
<p>set <code>lrw</code> equal to 27627 or a higher value
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_liw">liw</code></td>
<td>
<p>the length of the integer work array iwork; due to the
sparsicity, this cannot be readily predicted. If <code>NULL</code>, a guess will
be made, and if not sufficient, <code>lsodes</code> will return with a
message indicating the size of iwork actually required.  Therefore,
some experimentation may be necessary to estimate the value of
<code>liw</code>.
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_dllname">dllname</code></td>
<td>
<p>a string giving the name of the shared library
(without extension) that contains all the compiled function or
subroutine definitions refered to in <code>func</code> and
<code>jacfunc</code>. See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_initfunc">initfunc</code></td>
<td>
<p>if not <code>NULL</code>, the name of the initialisation function
(which initialises values of parameters), as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_initpar">initpar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified and an
initialisation function <code>initfunc</code> is in the dll: the
parameters passed to the initialiser, to initialise the common
blocks (FORTRAN) or global variables (C, C++).
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_rpar">rpar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with
double precision values passed to the dll-functions whose names are
specified by <code>func</code> and <code>jacfunc</code>.
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_ipar">ipar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with
integer values passed to the dll-functions whose names are specified
by <code>func</code> and <code>jacfunc</code>.
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_nout">nout</code></td>
<td>
<p>only used if <code>dllname</code> is specified and the model is
defined in compiled code: the number of output variables calculated
in the compiled function <code>func</code>, present in the shared
library. Note: it is not automatically checked whether this is
indeed the number of output variables calculated in the dll - you have
to perform this check in the code. See package vignette
<code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_outnames">outnames</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified and
<code>nout</code> &gt; 0: the names of output variables calculated in the
compiled function <code>func</code>, present in the shared library.
These names will be used to label the output matrix.
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_forcings">forcings</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified: a list with
the forcing function data sets, each present as a two-columned matrix,
with (time,value); interpolation outside the interval
[min(<code>times</code>), max(<code>times</code>)] is done by taking the value at
the closest data extreme.
</p>
<p>See <a href="#topic+forcings">forcings</a> or package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_initforc">initforc</code></td>
<td>
<p>if not <code>NULL</code>, the name of the forcing function
initialisation function, as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. It MUST be present if <code>forcings</code> has been given a
value.
See <a href="#topic+forcings">forcings</a> or package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_fcontrol">fcontrol</code></td>
<td>
<p>A list of control parameters for the forcing functions.
See <a href="#topic+forcings">forcings</a> or vignette <code>compiledCode</code>.
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_events">events</code></td>
<td>
<p>A matrix or data frame that specifies events, i.e. when the value of a 
state variable is suddenly changed. See <a href="#topic+events">events</a> for more information.
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_lags">lags</code></td>
<td>
<p>A list that specifies timelags, i.e. the number of steps 
that has to be kept. To be used for delay differential equations. 
See <a href="#topic+timelags">timelags</a>, <a href="#topic+dede">dede</a> for more information.
</p>
</td></tr>
<tr><td><code id="lsodes_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>func</code> and
<code>jacfunc</code> allowing this to be a generic function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The work is done by the FORTRAN subroutine <code>lsodes</code>, whose
documentation should be consulted for details (it is included as
comments in the source file &lsquo;<span class="file">src/opkdmain.f</span>&rsquo;). The implementation
is based on the November, 2003 version of lsodes, from Netlib.
</p>
<p><code>lsodes</code> is applied for stiff problems, where the Jacobian has a
sparse structure.
</p>
<p>There are several choices depending on whether <code>jacvec</code>
is specified and depending on the setting of <code>sparsetype</code>.
</p>
<p>If function <code>jacvec</code> is present, then it should return the j-th
column of the Jacobian matrix.
</p>
<p>There are also several choices for the sparsity specification, selected by
argument <code>sparsetype</code>.
</p>

<ul>
<li> <p><code>sparsetype</code> = <code>"sparseint"</code>.  The sparsity is estimated
by the solver, based on numerical differences.
In this case, it is advisable to provide an estimate of the number
of non-zero elements in the Jacobian (<code>nnz</code>).
This value can be approximate; upon return the number of nonzero
elements actually required will be known (1st element of attribute
<code>dims</code>).
In this case, <code>inz</code> need not be specified. 
</p>
</li>
<li> <p><code>sparsetype</code> = <code>"sparseusr"</code>. The sparsity is determined by
the user. In this case, <code>inz</code> should be a <code>matrix</code>, containing indices 
(row, column) to the  nonzero elements in the Jacobian matrix.
The number of nonzeros <code>nnz</code> will be set equal to the number of rows
in <code>inz</code>.
</p>
</li>
<li> <p><code>sparsetype</code> = <code>"sparsejan"</code>. The sparsity is also determined by
the user.
In this case, <code>inz</code> should be a <code>vector</code>, containting the <code>ian</code> and 
<code>jan</code> elements of the sparse storage format, as used in the sparse solver.
Elements of <code>ian</code> should be the first <code>n+1</code> elements of this vector, and 
contain the starting locations in <code>jan</code> of columns 1.. n. 
<code>jan</code> contains the row indices of the nonzero locations of           
the Jacobian, reading in columnwise order.
The number of nonzeros <code>nnz</code> will be set equal to the length of <code>inz</code> - (n+1).
</p>
</li>
<li> <p><code>sparsetype</code> = <code>"1D"</code>, <code>"2D"</code>, <code>"3D"</code>. 
The sparsity is estimated by the solver, based on numerical differences.
Assumes finite differences in a 1D, 2D or 3D regular grid - used by 
functions <code>ode.1D</code>, <code>ode.2D</code>, <code>ode.3D</code>.
Similar are <code>"2Dmap"</code>, and <code>"3Dmap"</code>, which also include a 
mapping variable (passed in nnz). 
</p>
</li></ul>

<p>The input parameters <code>rtol</code>, and <code>atol</code> determine the
<b>error control</b> performed by the solver.  See <code><a href="#topic+lsoda">lsoda</a></code>
for details.
</p>
<p>The diagnostics of the integration can be printed to screen
by calling <code><a href="#topic+diagnostics">diagnostics</a></code>. If <code>verbose</code> = <code>TRUE</code>,
the diagnostics will written to the screen at the end of the integration.
</p>
<p>See vignette(&quot;deSolve&quot;) for an explanation of each element in the vectors
containing the diagnostic properties and how to directly access them.
</p>
<p><b>Models</b> may be defined in compiled C or FORTRAN code, as well as
in an R-function. See package vignette <code>"compiledCode"</code> for details.
</p>
<p>More information about models defined in compiled code is in the package
vignette (&quot;compiledCode&quot;); information about linking forcing functions
to compiled code is in <a href="#topic+forcings">forcings</a>.
</p>
<p>Examples in both C and FORTRAN are in the &lsquo;<span class="file">doc/examples/dynload</span>&rsquo; subdirectory
of the <code>deSolve</code> package directory.
</p>
<p><code>lsodes</code> can find the root of at least one of a set of constraint functions
<code>rootfunc</code> of the independent and dependent variables.  It then returns the
solution at the root if that occurs sooner than the specified stop
condition, and otherwise returns the solution according the specified
stop condition.
</p>
<p>Caution:  Because of numerical errors in the function
<code>rootfun</code> due to roundoff and integration error, <code>lsodes</code> may
return false roots, or return the same root at two or more
nearly equal values of <code>time</code>.
</p>


<h3>Value</h3>

<p>A matrix of class <code>deSolve</code> with up to as many rows as elements
in <code>times</code> and as many columns as elements in <code>y</code> plus the number of &quot;global&quot;
values returned in the next elements of the return from <code>func</code>,
plus and additional column for the time value.  There will be a row
for each element in <code>times</code> unless the FORTRAN routine &lsquo;lsodes&rsquo;
returns with an unrecoverable error. If <code>y</code> has a names
attribute, it will be used to label the columns of the output value.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>References</h3>

<p>Alan C. Hindmarsh, ODEPACK, A Systematized Collection of ODE Solvers,
in Scientific Computing, R. S. Stepleman et al. (Eds.), North-Holland,
Amsterdam, 1983, pp. 55-64.
</p>
<p>S. C. Eisenstat, M. C. Gursky, M. H. Schultz, and A. H. Sherman, Yale
Sparse Matrix Package: I. The Symmetric Codes,
Int. J. Num. Meth. Eng., 18 (1982), pp. 1145-1151.
</p>
<p>S. C. Eisenstat, M. C. Gursky, M. H. Schultz, and A. H. Sherman, Yale
Sparse Matrix Package: II. The Nonsymmetric Codes, Research Report
No. 114, Dept. of Computer Sciences, Yale University, 1977.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+rk">rk</a></code>, </p>
</li>
<li> <p><code><a href="#topic+rk4">rk4</a></code> and <code><a href="#topic+euler">euler</a></code> for
Runge-Kutta integrators.
</p>
</li>
<li> <p><code><a href="#topic+lsoda">lsoda</a></code>, <code><a href="#topic+lsode">lsode</a></code>,
<code><a href="#topic+lsodar">lsodar</a></code>, <code><a href="#topic+vode">vode</a></code>,
<code><a href="#topic+daspk">daspk</a></code> for other solvers of the Livermore family,
</p>
</li>
<li> <p><code><a href="#topic+ode">ode</a></code> for a general interface to most of the ODE solvers,
</p>
</li>
<li> <p><code><a href="#topic+ode.band">ode.band</a></code> for solving models with a banded
Jacobian,
</p>
</li>
<li> <p><code><a href="#topic+ode.1D">ode.1D</a></code> for integrating 1-D models,
</p>
</li>
<li> <p><code><a href="#topic+ode.2D">ode.2D</a></code> for integrating 2-D models,
</p>
</li>
<li> <p><code><a href="#topic+ode.3D">ode.3D</a></code> for integrating 3-D models,
</p>
</li></ul>

<p><code><a href="#topic+diagnostics">diagnostics</a></code> to print diagnostic messages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Various ways to solve the same model.

## =======================================================================
## The example from lsodes source code
## A chemical model
## =======================================================================

n  &lt;- 12
y  &lt;- rep(1, n)
dy &lt;- rep(0, n)

times &lt;- c(0, 0.1*(10^(0:4)))

rtol &lt;- 1.0e-4
atol &lt;- 1.0e-6

parms &lt;- c(rk1  = 0.1,   rk2 = 10.0, rk3 = 50.0,  rk4 = 2.5,  rk5 = 0.1,
           rk6  = 10.0,  rk7 = 50.0, rk8 = 2.5,   rk9 = 50.0, rk10 = 5.0,
           rk11 = 50.0, rk12 = 50.0,rk13 = 50.0, rk14 = 30.0,
           rk15 = 100.0,rk16 = 2.5, rk17 = 100.0,rk18 = 2.5,
           rk19 = 50.0, rk20 = 50.0)

#
chemistry &lt;- function (time, Y, pars) {
  with (as.list(pars), {
    dy[1] &lt;- -rk1 *Y[1]
    dy[2] &lt;-  rk1 *Y[1]        + rk11*rk14*Y[4]  + rk19*rk14*Y[5]  -
              rk3 *Y[2]*Y[3]   - rk15*Y[2]*Y[12] - rk2*Y[2]
    dy[3] &lt;-  rk2 *Y[2]        - rk5 *Y[3]       - rk3*Y[2]*Y[3]   -
              rk7*Y[10]*Y[3]   + rk11*rk14*Y[4]   + rk12*rk14*Y[6]
    dy[4] &lt;-  rk3 *Y[2]*Y[3]   - rk11*rk14*Y[4]  - rk4*Y[4]
    dy[5] &lt;-  rk15*Y[2]*Y[12]  - rk19*rk14*Y[5]  - rk16*Y[5]
    dy[6] &lt;-  rk7 *Y[10]*Y[3]  - rk12*rk14*Y[6]  - rk8*Y[6]
    dy[7] &lt;-  rk17*Y[10]*Y[12] - rk20*rk14*Y[7]  - rk18*Y[7]
    dy[8] &lt;-  rk9 *Y[10]       - rk13*rk14*Y[8]  - rk10*Y[8]
    dy[9] &lt;-  rk4 *Y[4]        + rk16*Y[5]       + rk8*Y[6]         +
              rk18*Y[7]
    dy[10] &lt;- rk5 *Y[3]        + rk12*rk14*Y[6]  + rk20*rk14*Y[7]   +
              rk13*rk14*Y[8]   - rk7 *Y[10]*Y[3] - rk17*Y[10]*Y[12] -
              rk6 *Y[10]       - rk9*Y[10]
    dy[11] &lt;- rk10*Y[8]
    dy[12] &lt;- rk6 *Y[10]       + rk19*rk14*Y[5]  + rk20*rk14*Y[7]   -
              rk15*Y[2]*Y[12]  - rk17*Y[10]*Y[12]
    return(list(dy))
  })
}

## =======================================================================
## application 1. lsodes estimates the structure of the Jacobian
##                and calculates the Jacobian by differences
## =======================================================================
out &lt;- lsodes(func = chemistry, y = y, parms = parms, times = times,
              atol = atol, rtol = rtol, verbose = TRUE)

## =======================================================================
## application 2. the structure of the Jacobian is input
##                lsodes calculates the Jacobian by differences
##                this is not so efficient...
## =======================================================================

## elements of Jacobian that are not zero
nonzero &lt;-  matrix(nc = 2, byrow = TRUE, data = c(
  1, 1,   2, 1,    # influence of sp1 on rate of change of others
  2, 2,   3, 2,   4, 2,   5, 2,  12, 2,
  2, 3,   3, 3,   4, 3,   6, 3,  10, 3,
  2, 4,   3, 4,   4, 4,   9, 4,  # d (dyi)/dy4
  2, 5,   5, 5,   9, 5,  12, 5,
  3, 6,   6, 6,   9, 6,  10, 6,
  7, 7,   9, 7,  10, 7,  12, 7,
  8, 8,  10, 8,  11, 8,
  3,10,   6,10,   7,10,   8,10,  10,10,  12,10,
  2,12,   5,12,   7,12,  10,12,  12,12)
)

## when run, the default length of rwork is too small
## lsodes will tell the length actually needed
# out2 &lt;- lsodes(func = chemistry, y = y, parms = parms, times = times,
#              inz = nonzero, atol = atol,rtol = rtol)  #gives warning
out2 &lt;- lsodes(func = chemistry, y = y, parms = parms, times = times, 
            sparsetype = "sparseusr", inz = nonzero,   
             atol = atol, rtol = rtol, verbose = TRUE, lrw = 353)
                            
## =======================================================================
## application 3. lsodes estimates the structure of the Jacobian
##                the Jacobian (vector) function is input
## =======================================================================
chemjac &lt;- function (time, Y, j, pars) {
  with (as.list(pars), {
    PDJ &lt;- rep(0,n)

    if (j == 1){
       PDJ[1] &lt;- -rk1
       PDJ[2] &lt;- rk1
    } else if (j == 2) {
       PDJ[2] &lt;- -rk3*Y[3] - rk15*Y[12] - rk2
       PDJ[3] &lt;- rk2 - rk3*Y[3]
       PDJ[4] &lt;- rk3*Y[3]
       PDJ[5] &lt;- rk15*Y[12]
       PDJ[12] &lt;- -rk15*Y[12]
    } else if (j == 3) {
       PDJ[2] &lt;- -rk3*Y[2]
       PDJ[3] &lt;- -rk5 - rk3*Y[2] - rk7*Y[10]
       PDJ[4] &lt;- rk3*Y[2]
       PDJ[6] &lt;- rk7*Y[10]
       PDJ[10] &lt;- rk5 - rk7*Y[10]
    } else if (j == 4) {
       PDJ[2] &lt;- rk11*rk14
       PDJ[3] &lt;- rk11*rk14
       PDJ[4] &lt;- -rk11*rk14 - rk4
       PDJ[9] &lt;- rk4
    } else if (j == 5) {
       PDJ[2] &lt;- rk19*rk14
       PDJ[5] &lt;- -rk19*rk14 - rk16
       PDJ[9] &lt;- rk16
       PDJ[12] &lt;- rk19*rk14
    } else if (j == 6) {
       PDJ[3] &lt;- rk12*rk14
       PDJ[6] &lt;- -rk12*rk14 - rk8
       PDJ[9] &lt;- rk8
       PDJ[10] &lt;- rk12*rk14
    } else if (j == 7) {
       PDJ[7] &lt;- -rk20*rk14 - rk18
       PDJ[9] &lt;- rk18
       PDJ[10] &lt;- rk20*rk14
       PDJ[12] &lt;- rk20*rk14
    } else if (j == 8) {
       PDJ[8] &lt;- -rk13*rk14 - rk10
       PDJ[10] &lt;- rk13*rk14
       PDJ[11] &lt;- rk10
    } else if (j == 10) {
       PDJ[3] &lt;- -rk7*Y[3]
       PDJ[6] &lt;- rk7*Y[3]
       PDJ[7] &lt;- rk17*Y[12]
       PDJ[8] &lt;- rk9
       PDJ[10] &lt;- -rk7*Y[3] - rk17*Y[12] - rk6 - rk9
       PDJ[12] &lt;- rk6 - rk17*Y[12]
    } else if (j == 12) {
       PDJ[2] &lt;- -rk15*Y[2]
       PDJ[5] &lt;- rk15*Y[2]
       PDJ[7] &lt;- rk17*Y[10]
       PDJ[10] &lt;- -rk17*Y[10]
       PDJ[12] &lt;- -rk15*Y[2] - rk17*Y[10]
    }
    return(PDJ)
  })
} 

out3 &lt;- lsodes(func = chemistry, y = y, parms = parms, times = times,
              jacvec = chemjac, atol = atol, rtol = rtol)

## =======================================================================
## application 4. The structure of the Jacobian (nonzero elements) AND
##                the Jacobian (vector) function is input
## =======================================================================
out4 &lt;- lsodes(func = chemistry, y = y, parms = parms, times = times,
               lrw = 351, sparsetype = "sparseusr", inz = nonzero,
               jacvec = chemjac, atol = atol, rtol = rtol,
               verbose = TRUE)
               
# The sparsejan variant 
# note: errors in inz may cause R to break, so this is not without danger...
# out5 &lt;- lsodes(func = chemistry, y = y, parms = parms, times = times,
#               jacvec = chemjac, atol = atol, rtol = rtol, sparsetype = "sparsejan",
#               inz = c(1,3,8,13,17,21,25,29,32,32,38,38,43,                   # ian
#               1,2, 2,3,4,5,12, 2,3,4,6,10, 2,3,4,9, 2,5,9,12, 3,6,9,10,      # jan 
#               7,9,10,12, 8,10,11, 3,6,7,8,10,12, 2,5,7,10,12), lrw = 343) 

</code></pre>

<hr>
<h2 id='ode'>General Solver for Ordinary Differential Equations</h2><span id='topic+ode'></span><span id='topic+print.deSolve'></span><span id='topic+summary.deSolve'></span>

<h3>Description</h3>

<p>Solves a system of ordinary differential equations; a wrapper
around the implemented ODE solvers</p>


<h3>Usage</h3>

<pre><code class='language-R'>ode(y, times, func, parms, 
method = c("lsoda", "lsode", "lsodes", "lsodar", "vode", "daspk",
           "euler", "rk4", "ode23", "ode45", "radau", 
           "bdf", "bdf_d", "adams", "impAdams", "impAdams_d", "iteration"), ...)

## S3 method for class 'deSolve'
print(x, ...)
## S3 method for class 'deSolve'
summary(object, select = NULL, which = select, 
                 subset = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ode_+3A_y">y</code></td>
<td>
<p>the initial (state) values for the ODE system, a vector. If
<code>y</code> has a name attribute, the names will be used to label the
output matrix.
</p>
</td></tr>
<tr><td><code id="ode_+3A_times">times</code></td>
<td>
<p>time sequence for which output is wanted; the first
value of <code>times</code> must be the initial time.
</p>
</td></tr>
<tr><td><code id="ode_+3A_func">func</code></td>
<td>
<p>either an <span class="rlang"><b>R</b></span>-function that computes the values of the
derivatives in the ODE system (the model definition) at time t, or a
character string giving the name of a compiled function in a
dynamically loaded shared library.
</p>
<p>If <code>func</code> is an <span class="rlang"><b>R</b></span>-function, it must be defined as:
<code>func &lt;- function(t, y, parms,...)</code>.  <code>t</code> is the current time
point in the integration, <code>y</code> is the current estimate of the
variables in the ODE system.  If the initial values <code>y</code> has a
<code>names</code> attribute, the names will be available inside <code>func</code>.
<code>parms</code> is a vector or list of parameters; ... (optional) are
any other arguments passed to the function.
</p>
<p>The return value of <code>func</code> should be a list, whose first
element is a vector containing the derivatives of <code>y</code> with
respect to <code>time</code>, and whose next elements are global values
that are required at each point in <code>times</code>. The derivatives
must be specified in the <b>same order</b> as the state variables <code>y</code>.
</p>
<p>If <code>func</code> is a string, then <code>dllname</code> must give the name
of the shared library (without extension) which must be loaded
before <code>ode</code> is called. See package vignette
<code>"compiledCode"</code> for more details.
</p>
</td></tr>
<tr><td><code id="ode_+3A_parms">parms</code></td>
<td>
<p>parameters passed to <code>func</code>.</p>
</td></tr>
<tr><td><code id="ode_+3A_method">method</code></td>
<td>
<p>the integrator to use, either a <b>function</b> that performs 
integration, or a <b>list</b> of class <code><a href="#topic+rkMethod">rkMethod</a></code>, or a <b>string</b> 
(<code>"lsoda"</code>,
<code>"lsode"</code>, <code>"lsodes"</code>,<code>"lsodar"</code>,<code>"vode"</code>,
<code>"daspk"</code>, <code>"euler"</code>, <code>"rk4"</code>,   <code>"ode23"</code>,
<code>"ode45"</code>, <code>"radau"</code>, <code>"bdf"</code>,   <code>"bdf_d"</code>, <code>"adams"</code>, 
<code>"impAdams"</code> or <code>"impAdams_d"</code>  ,&quot;iteration&quot;).
Options &quot;bdf&quot;, &quot;bdf_d&quot;, &quot;adams&quot;, &quot;impAdams&quot; or &quot;impAdams_d&quot; are the backward
differentiation formula, the BDF with diagonal representation of the Jacobian,
the (explicit) Adams and the implicit Adams method, and the implicit Adams
method with diagonal representation of the Jacobian respectively (see details).
The default integrator used is <a href="#topic+lsoda">lsoda</a>.
</p>
<p>Method <code>"iteration"</code> is special in that here the function <code>func</code> should
return the new value of the state variables rather than the rate of change.
This can be used for individual based models, for difference equations,
or in those cases where the integration is performed within <code>func</code>).
See last example.
</p>
</td></tr>
<tr><td><code id="ode_+3A_x">x</code></td>
<td>
<p>an object of class <code>deSolve</code>, as returned by the
integrators, and to be printed or to be subsetted.
</p>
</td></tr>
<tr><td><code id="ode_+3A_object">object</code></td>
<td>
<p>an object of class <code>deSolve</code>, as returned by the
integrators, and whose summary is to be calculated. In contrast to R's default,
this returns a data.frame. It returns one summary column for a multi-dimensional variable.
</p>
</td></tr>
<tr><td><code id="ode_+3A_which">which</code></td>
<td>
<p>the name(s) or the index to the variables whose summary should be
estimated.  Default = all variables. </p>
</td></tr>
<tr><td><code id="ode_+3A_select">select</code></td>
<td>
<p>which variable/columns to be selected.
</p>
</td></tr>
<tr><td><code id="ode_+3A_subset">subset</code></td>
<td>
<p>logical expression indicating elements or rows to keep when 
calculating a <code>summary</code>: missing values are taken as <code>FALSE</code>
</p>
</td></tr>
<tr><td><code id="ode_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the integrator or to the
methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is simply a wrapper around the various ode solvers.
</p>
<p>See package vignette for information about specifying the model in
compiled code.
</p>
<p>See the selected integrator for the additional options.
</p>
<p>The default integrator used is <code><a href="#topic+lsoda">lsoda</a></code>.
</p>
<p>The option <code>method = "bdf"</code> provdes a handle to the backward 
differentiation formula (it is equal to using <code>method = "lsode"</code>). 
It is best suited to solve stiff (systems of) equations.
</p>
<p>The option <code>method = "bdf_d"</code> selects the backward 
differentiation formula that uses Jacobi-Newton iteration (neglecting the 
off-diagonal elements of the Jacobian (it is equal to using 
<code>method = "lsode", mf = 23</code>). 
It is best suited to solve stiff (systems of) equations.
</p>
<p><code>method = "adams"</code> triggers the Adams method that uses functional
iteration (no Jacobian used); 
(equal to <code>method = "lsode", mf = 10</code>. It is often the best 
choice for solving non-stiff (systems of) equations. Note: when functional
iteration is used, the method is often said to be explicit, although it is  
in fact implicit.
</p>
<p><code>method = "impAdams"</code> selects the implicit Adams method that uses Newton-
Raphson iteration (equal to <code>method = "lsode", mf = 12</code>.
</p>
<p><code>method = "impAdams_d"</code> selects the implicit Adams method that uses Jacobi-
Newton iteration, i.e. neglecting all off-diagonal elements (equal to 
<code>method = "lsode", mf = 13</code>.
</p>
<p>For very stiff systems, <code>method = "daspk"</code> may outperform 
<code>method = "bdf"</code>.
</p>


<h3>Value</h3>

<p>A matrix of class <code>deSolve</code> with up to as many rows as elements in
<code>times</code> and as many
columns as elements in <code>y</code> plus the number of &quot;global&quot; values
returned in the second element of the return from <code>func</code>, plus an
additional column (the first) for the time value.  There will be one
row for each element in <code>times</code> unless the integrator returns
with an unrecoverable error.  If <code>y</code> has a names attribute, it
will be used to label the columns of the output value.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+plot.deSolve">plot.deSolve</a></code> for plotting the outputs,
</p>
</li>
<li> <p><code><a href="#topic+dede">dede</a></code> general solver for delay differential equations
</p>
</li>
<li> <p><code><a href="#topic+ode.band">ode.band</a></code> for solving models with a banded
Jacobian,
</p>
</li>
<li> <p><code><a href="#topic+ode.1D">ode.1D</a></code> for integrating 1-D models,
</p>
</li>
<li> <p><code><a href="#topic+ode.2D">ode.2D</a></code> for integrating 2-D models,
</p>
</li>
<li> <p><code><a href="#topic+ode.3D">ode.3D</a></code> for integrating 3-D models,
</p>
</li>
<li> <p><code><a href="#topic+aquaphy">aquaphy</a></code>, <code><a href="#topic+ccl4model">ccl4model</a></code>, where
<code>ode</code> is used,
</p>
</li>
<li> <p><code><a href="#topic+lsoda">lsoda</a></code>, <code><a href="#topic+lsode">lsode</a></code>,
<code><a href="#topic+lsodes">lsodes</a></code>, <code><a href="#topic+lsodar">lsodar</a></code>, <code><a href="#topic+vode">vode</a></code>,
<code><a href="#topic+daspk">daspk</a></code>, <code><a href="#topic+radau">radau</a></code>,
</p>
</li>
<li>  <p><code><a href="#topic+rk">rk</a></code>, <code><a href="#topic+rkMethod">rkMethod</a></code> for additional
Runge-Kutta methods,
</p>
</li>
<li> <p><code><a href="#topic+forcings">forcings</a></code> and <code><a href="#topic+events">events</a></code>,
</p>
</li>
<li>  <p><code><a href="#topic+diagnostics">diagnostics</a></code> to print diagnostic messages.  
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
## =======================================================================
## Example1: Predator-Prey Lotka-Volterra model (with logistic prey)
## =======================================================================

LVmod &lt;- function(Time, State, Pars) {
  with(as.list(c(State, Pars)), {
    Ingestion    &lt;- rIng  * Prey * Predator
    GrowthPrey   &lt;- rGrow * Prey * (1 - Prey/K)
    MortPredator &lt;- rMort * Predator

    dPrey        &lt;- GrowthPrey - Ingestion
    dPredator    &lt;- Ingestion * assEff - MortPredator

    return(list(c(dPrey, dPredator)))
  })
}

pars  &lt;- c(rIng   = 0.2,    # /day, rate of ingestion
           rGrow  = 1.0,    # /day, growth rate of prey
           rMort  = 0.2 ,   # /day, mortality rate of predator
           assEff = 0.5,    # -, assimilation efficiency
           K      = 10)     # mmol/m3, carrying capacity

yini  &lt;- c(Prey = 1, Predator = 2)
times &lt;- seq(0, 200, by = 1)
out   &lt;- ode(yini, times, LVmod, pars)
summary(out)

## Default plot method
plot(out)

## User specified plotting
matplot(out[ , 1], out[ , 2:3], type = "l", xlab = "time", ylab = "Conc",
        main = "Lotka-Volterra", lwd = 2)
legend("topright", c("prey", "predator"), col = 1:2, lty = 1:2)

## =======================================================================
## Example2: Substrate-Producer-Consumer Lotka-Volterra model
## =======================================================================

## Note:
## Function sigimp passed as an argument (input) to model
##   (see also lsoda and rk examples)

SPCmod &lt;- function(t, x, parms, input)  {
  with(as.list(c(parms, x)), {
    import &lt;- input(t)
    dS &lt;- import - b*S*P + g*C    # substrate
    dP &lt;- c*S*P  - d*C*P          # producer
    dC &lt;- e*P*C  - f*C            # consumer
    res &lt;- c(dS, dP, dC)
    list(res)
  })
}

## The parameters 
parms &lt;- c(b = 0.001, c = 0.1, d = 0.1, e = 0.1, f = 0.1, g = 0.0)

## vector of timesteps
times &lt;- seq(0, 200, length = 101)

## external signal with rectangle impulse
signal &lt;- data.frame(times = times,
                     import = rep(0, length(times)))

signal$import[signal$times &gt;= 10 &amp; signal$times &lt;= 11] &lt;- 0.2

sigimp &lt;- approxfun(signal$times, signal$import, rule = 2)

## Start values for steady state
xstart &lt;- c(S = 1, P = 1, C = 1)

## Solve model
out &lt;- ode(y = xstart, times = times,
           func = SPCmod, parms = parms, input = sigimp)

## Default plot method
plot(out)

## User specified plotting
mf &lt;- par(mfrow = c(1, 2))
matplot(out[,1], out[,2:4], type = "l", xlab = "time", ylab = "state")
legend("topright", col = 1:3, lty = 1:3, legend = c("S", "P", "C"))
plot(out[,"P"], out[,"C"], type = "l", lwd = 2, xlab = "producer",
  ylab = "consumer")
par(mfrow = mf)

## =======================================================================
## Example3: Discrete time model - using method = "iteration"
##           The host-parasitoid model from Soetaert and Herman, 2009, 
##           Springer - p. 284.
## =======================================================================

Parasite &lt;- function(t, y, ks) {
  P &lt;- y[1]
  H &lt;- y[2]
  f    &lt;- A * P / (ks + H)
  Pnew &lt;- H * (1 - exp(-f))
  Hnew &lt;- H * exp(rH * (1 - H) - f)
  
  list (c(Pnew, Hnew))
}
rH &lt;- 2.82 # rate of increase
A  &lt;- 100  # attack rate
ks &lt;- 15   # half-saturation density

out &lt;- ode(func = Parasite, y = c(P = 0.5, H = 0.5), times = 0:50, parms = ks,
           method = "iteration")
            
out2&lt;- ode(func = Parasite, y = c(P = 0.5, H = 0.5), times = 0:50, parms = 25,
           method = "iteration")

out3&lt;- ode(func = Parasite, y = c(P = 0.5, H = 0.5), times = 0:50, parms = 35,
           method = "iteration")

## Plot all 3 scenarios in one figure
plot(out, out2, out3, lty = 1, lwd = 2)

## Same like "out", but *output* every two steps
## hini = 1 ensures that the same *internal* timestep of 1 is used
outb &lt;- ode(func = Parasite, y = c(P = 0.5, H = 0.5),
            times = seq(0, 50, 2), hini = 1, parms = ks,
            method = "iteration")
plot(out, outb, type = c("l", "p"))

## Not run: 
## =======================================================================
## Example4: Playing with the Jacobian options - see e.g. lsoda help page
##
## IMPORTANT: The following example is temporarily broken because of 
##            incompatibility with R 3.0 on some systems.
##            A fix is on the way.
## =======================================================================

## a stiff equation, exponential decay, run 500 times
stiff &lt;- function(t, y, p) {   # y and r are a 500-valued vector
  list(- r * y)
}

N    &lt;- 500
r    &lt;- runif(N, 15, 20)
yini &lt;- runif(N, 1, 40)

times &lt;- 0:10

## Using the default
print(system.time(
  out &lt;- ode(y = yini, parms = NULL, times = times, func = stiff)
))
# diagnostics(out) shows that the method used = bdf (2), so it it stiff

## Specify that the Jacobian is banded, with nonzero values on the 
## diagonal, i.e. the bandwidth up and down = 0 

print(system.time(
  out2 &lt;- ode(y = yini, parms = NULL, times = times, func = stiff,
              jactype = "bandint", bandup = 0, banddown = 0)
))

## Now we also specify the Jacobian function

jacob &lt;- function(t, y, p) -r

print(system.time(
  out3 &lt;- ode(y = yini, parms = NULL, times = times, func = stiff, 
              jacfunc = jacob, jactype = "bandusr", 
              bandup = 0, banddown = 0)
))
## The larger the value of N, the larger the time gain...

## End(Not run)
</code></pre>

<hr>
<h2 id='ode.1D'>Solver For Multicomponent 1-D Ordinary Differential Equations</h2><span id='topic+ode.1D'></span>

<h3>Description</h3>

<p>Solves a system of ordinary differential equations
resulting from 1-Dimensional partial differential equations
that have been converted to ODEs by numerical differencing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ode.1D(y, times, func, parms, nspec = NULL, dimens = NULL, 
   method= c("lsoda", "lsode", "lsodes", "lsodar", "vode", "daspk",
   "euler", "rk4", "ode23", "ode45", "radau", "bdf", "adams", "impAdams",
   "iteration"),
   names = NULL, bandwidth = 1, restructure = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ode.1D_+3A_y">y</code></td>
<td>
<p>the initial (state) values for the ODE system, a vector. If
<code>y</code> has a name attribute, the names will be used to label the
output matrix.
</p>
</td></tr>
<tr><td><code id="ode.1D_+3A_times">times</code></td>
<td>
<p>time sequence for which output is wanted; the first
value of <code>times</code> must be the initial time.
</p>
</td></tr>
<tr><td><code id="ode.1D_+3A_func">func</code></td>
<td>
<p>either an <span class="rlang"><b>R</b></span>-function that computes the values of the
derivatives in the ODE system (the model definition) at time
<code>t</code>, or a character string giving the name of a compiled
function in a dynamically loaded shared library.
</p>
<p>If <code>func</code> is an <span class="rlang"><b>R</b></span>-function, it must be defined as:
<code>func &lt;- function(t, y, parms, ...)</code>.  <code>t</code> is the current time
point in the integration, <code>y</code> is the current estimate of the
variables in the ODE system.  If the initial values <code>y</code> has a
<code>names</code> attribute, the names will be available inside <code>func</code>.
<code>parms</code> is a vector or list of parameters; <code>...</code> (optional) are
any other arguments passed to the function.
</p>
<p>The return value of <code>func</code> should be a list, whose first
element is a vector containing the derivatives of <code>y</code> with
respect to <code>time</code>, and whose next elements are global values
that are required at each point in <code>times</code>. The derivatives
must be specified in the <b>same order</b> as the state variables <code>y</code>.
</p>
<p>If <code>func</code> is a character string then integrator <code>lsodes</code>
will be used. See details.
</p>
</td></tr>
<tr><td><code id="ode.1D_+3A_parms">parms</code></td>
<td>
<p>parameters passed to <code>func</code>.</p>
</td></tr>
<tr><td><code id="ode.1D_+3A_nspec">nspec</code></td>
<td>
<p>the number of <b>species</b> (components) in the model. If
<code>NULL</code>, then <code>dimens</code> should be specified.
</p>
</td></tr>
<tr><td><code id="ode.1D_+3A_dimens">dimens</code></td>
<td>
<p>the number of <b>boxes</b> in the model. If <code>NULL</code>, then
<code>nspec</code> should be specified.
</p>
</td></tr>
<tr><td><code id="ode.1D_+3A_method">method</code></td>
<td>
<p>the integrator. Use <code>"vode", "lsode", "lsoda", 
     "lsodar", "daspk"</code>, or <code>"lsodes"</code> if the model is very stiff;
<code>"impAdams"</code> or <code>"radau"</code> may be best suited for mildly stiff problems; 
<code>"euler", "rk4", "ode23", "ode45", "adams"</code> are most
efficient for non-stiff problems. Also allowed is to pass an integrator
<code>function</code>. Use one of the other Runge-Kutta methods via 
<code>rkMethod</code>. For instance, <code>method = rkMethod("ode45ck")</code> will
trigger the Cash-Karp method of order 4(5).
</p>
<p>Method <code>"iteration"</code> is special in that here the function <code>func</code> should
return the new value of the state variables rather than the rate of change.
This can be used for individual based models, for difference equations,
or in those cases where the integration is performed within <code>func</code>)
</p>
</td></tr>
<tr><td><code id="ode.1D_+3A_names">names</code></td>
<td>
<p>the names of the components; used for plotting.
</p>
</td></tr>
<tr><td><code id="ode.1D_+3A_bandwidth">bandwidth</code></td>
<td>
<p>the number of adjacent boxes over which transport occurs.
Normally equal to 1 (box i only interacts with box i-1, and i+1). 
Values larger than 1 will not work with <code>method = "lsodes"</code>.
Ignored if the method is explicit.
</p>
</td></tr>
<tr><td><code id="ode.1D_+3A_restructure">restructure</code></td>
<td>
<p>whether or not the Jacobian should be restructured.
Only used if the <code>method</code> is an integrator function. Should be
<code>TRUE</code> if the method is implicit, <code>FALSE</code> if explicit.
</p>
</td></tr>
<tr><td><code id="ode.1D_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the integrator.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the method of choice for multi-species 1-dimensional models,
that are only subjected to transport between adjacent layers.
</p>
<p>More specifically, this method is to be used if the state variables
are arranged per species:
</p>
<p>A[1], A[2], A[3],.... B[1], B[2], B[3],.... (for species A, B))
</p>
<p>Two methods are implemented.
</p>

<ul>
<li><p> The default method rearranges the state variables as
A[1], B[1], ... A[2], B[2], ... A[3], B[3], .... This reformulation leads
to a banded Jacobian with (upper and lower) half bandwidth =
number of species.
</p>
<p>Then the selected integrator solves the banded problem.
</p>
</li>
<li><p> The second method uses <code>lsodes</code>. Based on the dimension
of the problem, the method first calculates the sparsity pattern
of the Jacobian, under the assumption that transport is only
occurring between adjacent layers. Then <code>lsodes</code> is called to
solve the problem.
</p>
<p>As <code>lsodes</code> is used to integrate, it may be necessary to
specify the length of the real work array, <code>lrw</code>.
</p>
<p>Although a reasonable guess of <code>lrw</code> is made, it is possible
that this will be too low.  In this case, <code>ode.1D</code> will
return with an error message telling the size of the work array
actually needed. In the second try then, set <code>lrw</code> equal to
this number.
</p>
<p>For instance, if you get the error:
</p>
<pre>   
DLSODES- RWORK length is insufficient to proceed.                               
  Length needed is .ge. LENRW (=I1), exceeds LRW (=I2)                    
  In above message,  I1 =     27627   I2 =     25932 
</pre>      
<p>set <code>lrw</code> equal to 27627 or a higher value
</p>
</li></ul>

<p>If the model is specified in compiled code (in a DLL), then option 2,
based on <code>lsodes</code> is the only solution method.
</p>
<p>For single-species 1-D models, you may also use <code><a href="#topic+ode.band">ode.band</a></code>.
</p>
<p>See the selected integrator for the additional options.
</p>


<h3>Value</h3>

<p>A matrix of class <code>deSolve</code> with up to as many rows as elements in times and as many
columns as elements in <code>y</code> plus the number of &quot;global&quot; values
returned in the second element of the return from <code>func</code>, plus an
additional column (the first) for the time value.  There will be one
row for each element in <code>times</code> unless the integrator returns
with an unrecoverable error.  If <code>y</code> has a names attribute, it
will be used to label the columns of the output value.
</p>
<p>The output will have the attributes <code>istate</code>, and <code>rstate</code>,
two vectors with several useful elements.  The first element of istate
returns the conditions under which the last call to the integrator
returned. Normal is <code>istate = 2</code>.  If <code>verbose = TRUE</code>, the
settings of istate and rstate will be written to the screen. See the
help for the selected integrator for details.
</p>


<h3>Note</h3>

<p>It is advisable though not mandatory to specify <b>both</b>
<code>nspec</code> and <code>dimens</code>. In this case, the solver can check
whether the input makes sense (i.e. if <code>nspec * dimens ==
  length(y)</code>).
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+ode">ode</a></code> for a general interface to most of the ODE solvers,
</p>
</li>
<li> <p><code><a href="#topic+ode.band">ode.band</a></code> for integrating models with a banded Jacobian
</p>
</li>
<li>  <p><code><a href="#topic+ode.2D">ode.2D</a></code> for integrating 2-D models
</p>
</li>
<li>  <p><code><a href="#topic+ode.3D">ode.3D</a></code> for integrating 3-D models
</p>
</li>
<li>  <p><code><a href="#topic+lsodes">lsodes</a></code>,<code><a href="#topic+lsode">lsode</a></code>, <code><a href="#topic+lsoda">lsoda</a></code>,
<code><a href="#topic+lsodar">lsodar</a></code>,<code><a href="#topic+vode">vode</a></code> for the integration options.
</p>
</li></ul>

<p><code><a href="#topic+diagnostics">diagnostics</a></code> to print diagnostic messages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## =======================================================================
## example 1
## a predator and its prey diffusing on a flat surface
## in concentric circles
## 1-D model with using cylindrical coordinates
## Lotka-Volterra type biology
## =======================================================================

## ================
## Model equations
## ================

lvmod &lt;- function (time, state, parms, N, rr, ri, dr, dri) {
  with (as.list(parms), {
    PREY &lt;- state[1:N]
    PRED &lt;- state[(N+1):(2*N)]

    ## Fluxes due to diffusion
    ## at internal and external boundaries: zero gradient
    FluxPrey &lt;- -Da * diff(c(PREY[1], PREY, PREY[N]))/dri
    FluxPred &lt;- -Da * diff(c(PRED[1], PRED, PRED[N]))/dri

    ## Biology: Lotka-Volterra model
    Ingestion     &lt;- rIng  * PREY * PRED
    GrowthPrey    &lt;- rGrow * PREY * (1-PREY/cap)
    MortPredator  &lt;- rMort * PRED

    ## Rate of change = Flux gradient + Biology
    dPREY    &lt;- -diff(ri * FluxPrey)/rr/dr   +
                GrowthPrey - Ingestion
    dPRED    &lt;- -diff(ri * FluxPred)/rr/dr   +
                Ingestion * assEff - MortPredator

    return (list(c(dPREY, dPRED)))
  })
}

## ==================
## Model application
## ==================

## model parameters:

R  &lt;- 20                        # total radius of surface, m
N  &lt;- 100                       # 100 concentric circles
dr &lt;- R/N                       # thickness of each layer
r  &lt;- seq(dr/2,by = dr,len = N) # distance of center to mid-layer
ri &lt;- seq(0,by = dr,len = N+1)  # distance to layer interface
dri &lt;- dr                       # dispersion distances

parms &lt;- c(Da     = 0.05,       # m2/d, dispersion coefficient
           rIng   = 0.2,        # /day, rate of ingestion
           rGrow  = 1.0,        # /day, growth rate of prey
           rMort  = 0.2 ,       # /day, mortality rate of pred
           assEff = 0.5,        # -, assimilation efficiency
           cap    = 10)         # density, carrying capacity

## Initial conditions: both present in central circle (box 1) only
state    &lt;- rep(0, 2 * N)
state[1] &lt;- state[N + 1] &lt;- 10
                
## RUNNING the model:
times  &lt;- seq(0, 200, by = 1)   # output wanted at these time intervals

## the model is solved by the two implemented methods:
## 1. Default: banded reformulation
print(system.time(
  out &lt;- ode.1D(y = state, times = times, func = lvmod, parms = parms,
                nspec = 2, names = c("PREY", "PRED"),
                N = N, rr = r, ri = ri, dr = dr, dri = dri)
))

## 2. Using sparse method
print(system.time(
  out2 &lt;- ode.1D(y = state, times = times, func = lvmod, parms = parms,
                 nspec = 2, names = c("PREY","PRED"), 
                 N = N, rr = r, ri = ri, dr = dr, dri = dri,
                 method = "lsodes")
))

## ================
## Plotting output
## ================
# the data in 'out' consist of: 1st col times, 2-N+1: the prey
# N+2:2*N+1: predators

PREY   &lt;- out[, 2:(N + 1)]

filled.contour(x = times, y = r, PREY, color = topo.colors,
               xlab = "time, days", ylab = "Distance, m",
               main = "Prey density")
# similar:
image(out, which = "PREY", grid = r, xlab = "time, days", 
      legend = TRUE, ylab = "Distance, m", main = "Prey density")

image(out2, grid = r)

# summaries of 1-D variables
summary(out)

# 1-D plots:
matplot.1D(out, type = "l", subset = time == 10)
matplot.1D(out, type = "l", subset = time &gt; 10 &amp; time &lt; 20)

## =======================================================================
## Example 2.
## Biochemical Oxygen Demand (BOD) and oxygen (O2) dynamics
## in a river
## =======================================================================

## ================
## Model equations
## ================
O2BOD &lt;- function(t, state, pars) {
  BOD &lt;- state[1:N]
  O2  &lt;- state[(N+1):(2*N)]

  ## BOD dynamics
  FluxBOD &lt;- v * c(BOD_0, BOD)   # fluxes due to water transport
  FluxO2  &lt;- v * c(O2_0, O2)
  
  BODrate &lt;- r * BOD             # 1-st order consumption

  ## rate of change = flux gradient  - consumption + reaeration (O2)
  dBOD         &lt;- -diff(FluxBOD)/dx - BODrate
  dO2          &lt;- -diff(FluxO2)/dx  - BODrate      +  p * (O2sat-O2)

  return(list(c(dBOD = dBOD, dO2 = dO2)))
}
 
 
## ==================
## Model application
## ==================
## parameters
dx      &lt;- 25        # grid size of 25 meters
v       &lt;- 1e3       # velocity, m/day
x       &lt;- seq(dx/2, 5000, by = dx)  # m, distance from river
N       &lt;- length(x)
r       &lt;- 0.05      # /day, first-order decay of BOD
p       &lt;- 0.5       # /day, air-sea exchange rate 
O2sat   &lt;- 300       # mmol/m3 saturated oxygen conc
O2_0    &lt;- 200       # mmol/m3 riverine oxygen conc
BOD_0   &lt;- 1000      # mmol/m3 riverine BOD concentration

## initial conditions:
state &lt;- c(rep(200, N), rep(200, N))
times &lt;- seq(0, 20, by = 0.1)

## running the model
##  step 1  : model spinup
out &lt;- ode.1D(y = state, times, O2BOD, parms = NULL, 
              nspec = 2, names = c("BOD", "O2"))

## ================
## Plotting output
## ================
## select oxygen (first column of out:time, then BOD, then O2
O2   &lt;- out[, (N + 2):(2 * N + 1)]
color = topo.colors

filled.contour(x = times, y = x, O2, color = color, nlevels = 50,
               xlab = "time, days", ylab = "Distance from river, m",
               main = "Oxygen")
               
## or quicker plotting:
image(out, grid = x,  xlab = "time, days", ylab = "Distance from river, m")               
</code></pre>

<hr>
<h2 id='ode.2D'>Solver for 2-Dimensional Ordinary Differential Equations</h2><span id='topic+ode.2D'></span>

<h3>Description</h3>

<p>Solves a system of ordinary differential equations resulting from
2-Dimensional partial differential equations
that have been converted to ODEs by numerical differencing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ode.2D(y, times, func, parms, nspec = NULL, dimens,
  method= c("lsodes", "euler", "rk4", "ode23", "ode45", "adams", "iteration"),
  names = NULL, cyclicBnd = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ode.2D_+3A_y">y</code></td>
<td>
<p>the initial (state) values for the ODE system, a vector. If
<code>y</code> has a name attribute, the names will be used to label the
output matrix.
</p>
</td></tr>
<tr><td><code id="ode.2D_+3A_times">times</code></td>
<td>
<p>time sequence for which output is wanted; the first
value of <code>times</code> must be the initial time.
</p>
</td></tr>
<tr><td><code id="ode.2D_+3A_func">func</code></td>
<td>
<p>either an <span class="rlang"><b>R</b></span>-function that computes the values of the
derivatives in the ODE system (the model definition) at time
<code>t</code>, or a character string giving the name of a compiled
function in a dynamically loaded shared library.
</p>
<p>If <code>func</code> is an <span class="rlang"><b>R</b></span>-function, it must be defined as:
<code>func &lt;- function(t, y, parms, ...)</code>. <code>t</code> is the current time
point in the integration, <code>y</code> is the current estimate of the
variables in the ODE system.  If the initial values <code>y</code> has a
<code>names</code> attribute, the names will be available inside <code>func</code>.
<code>parms</code> is a vector or list of parameters; <code>...</code> (optional) are
any other arguments passed to the function.
</p>
<p>The return value of <code>func</code> should be a list, whose first
element is a vector containing the derivatives of <code>y</code> with
respect to <code>time</code>, and whose next elements are global values
that are required at each point in <code>times</code>. The derivatives
must be specified in the <b>same order</b> as the state variables <code>y</code>.
</p>
</td></tr>
<tr><td><code id="ode.2D_+3A_parms">parms</code></td>
<td>
<p>parameters passed to <code>func</code>.</p>
</td></tr>
<tr><td><code id="ode.2D_+3A_nspec">nspec</code></td>
<td>
<p>the number of <b>species</b> (components) in the model.</p>
</td></tr>
<tr><td><code id="ode.2D_+3A_dimens">dimens</code></td>
<td>
<p>2-valued vector with the number of <b>boxes</b> in two
dimensions in the model. 
</p>
</td></tr>
<tr><td><code id="ode.2D_+3A_cyclicbnd">cyclicBnd</code></td>
<td>
<p>if not <code>NULL</code> then a number or a 2-valued vector
with the dimensions where a cyclic boundary is used - <code>1</code>: x-dimension,
<code>2</code>: y-dimension; see details.
</p>
</td></tr>
<tr><td><code id="ode.2D_+3A_names">names</code></td>
<td>
<p>the names of the components; used for plotting.
</p>
</td></tr>
<tr><td><code id="ode.2D_+3A_method">method</code></td>
<td>
<p>the integrator. Use <code>"lsodes"</code> if the model is very stiff;
<code>"impAdams"</code> may be best suited for mildly stiff problems; 
<code>"euler", "rk4", "ode23", "ode45", "adams"</code> are most
efficient for non-stiff problems. Also allowed is to pass an integrator
<code>function</code>. Use one of the other Runge-Kutta methods via 
<code>rkMethod</code>. For instance, <code>method = rkMethod("ode45ck")</code> will
trigger the Cash-Karp method of order 4(5).
</p>
<p>If  <code>"lsodes"</code> is used, then also the size of the work array should
be specified (<code>lrw</code>) (see <a href="#topic+lsodes">lsodes</a>).
</p>
<p>Method <code>"iteration"</code> is special in that here the function <code>func</code> should
return the new value of the state variables rather than the rate of change.
This can be used for individual based models, for difference equations,
or in those cases where the integration is performed within <code>func</code>)
</p>
</td></tr>
<tr><td><code id="ode.2D_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>lsodes</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the method of choice for 2-dimensional models, that are only
subjected to transport between adjacent layers.
</p>
<p>Based on the dimension of the problem, and if <code>lsodes</code> is used as 
the integrator, the method first calculates the
sparsity pattern of the Jacobian, under the assumption that transport
is only occurring between adjacent layers. Then <code>lsodes</code> is
called to solve the problem.
</p>
<p>If the model is not stiff, then it is more efficient to use one of the 
explicit integration routines
</p>
<p>In some cases, a cyclic boundary condition exists. This is when the first
boxes in x-or y-direction interact with the last boxes. In this case, there
will be extra non-zero fringes in the Jacobian which need to be taken
into account. The occurrence of cyclic boundaries can be
toggled on by specifying argument <code>cyclicBnd</code>. For innstance,
<code>cyclicBnd = 1</code> indicates that a cyclic boundary is required only for
the x-direction, whereas <code>cyclicBnd = c(1,2)</code> imposes a cyclic boundary
for both x- and y-direction. The default is no cyclic boundaries.
</p>
<p>If <code>lsodes</code> is used to integrate, it will probably be necessary
to specify the length of the real work array, <code>lrw</code>.
</p>
<p>Although a reasonable guess of <code>lrw</code> is made, it is likely that
this will be too low.  In this case, <code>ode.2D</code> will return with an
error message telling the size of the work array actually needed. In
the second try then, set <code>lrw</code> equal to this number.
</p>
<p>For instance, if you get the error:
</p>
<pre>   
DLSODES- RWORK length is insufficient to proceed.                               
  Length needed is .ge. LENRW (=I1), exceeds LRW (=I2)                    
  In above message,  I1 =     27627   I2 =     25932 
</pre>      
<p>set <code>lrw</code> equal to 27627 or a higher value.
</p>
<p>See <a href="#topic+lsodes">lsodes</a> for the additional options.
</p>


<h3>Value</h3>

<p>A matrix of class <code>deSolve</code> with up to as many rows as elements in times and as many
columns as elements in <code>y</code> plus the number of &quot;global&quot; values
returned in the second element of the return from <code>func</code>, plus an
additional column (the first) for the time value.  There will be one
row for each element in <code>times</code> unless the integrator returns
with an unrecoverable error.  If <code>y</code> has a names attribute, it
will be used to label the columns of the output value.
</p>
<p>The output will have the attributes <code>istate</code>, and <code>rstate</code>,
two vectors with several useful elements.  The first element of istate
returns the conditions under which the last call to the integrator
returned. Normal is <code>istate = 2</code>.  If <code>verbose = TRUE</code>, the
settings of istate and rstate will be written to the screen. See the
help for the selected integrator for details.
</p>


<h3>Note</h3>

<p>It is advisable though not mandatory to specify <b>both</b>
<code>nspec</code> and <code>dimens</code>. In this case, the solver can check
whether the input makes sense (as <code>nspec * dimens[1] * dimens[2]
  == length(y)</code>).
</p>
<p>Do <b>not</b> use this method for problems that are not 2D!
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+ode">ode</a></code> for a general interface to most of the ODE solvers,
</p>
</li>
<li> <p><code><a href="#topic+ode.band">ode.band</a></code> for integrating models with a banded Jacobian
</p>
</li>
<li>  <p><code><a href="#topic+ode.1D">ode.1D</a></code> for integrating 1-D models
</p>
</li>
<li>  <p><code><a href="#topic+ode.3D">ode.3D</a></code> for integrating 3-D models
</p>
</li>
<li>  <p><code><a href="#topic+lsodes">lsodes</a></code> for the integration options.
</p>
</li></ul>

<p><code><a href="#topic+diagnostics">diagnostics</a></code> to print diagnostic messages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =======================================================================
## A Lotka-Volterra predator-prey model with predator and prey
## dispersing in 2 dimensions
## =======================================================================

## ==================
## Model definitions
## ==================

lvmod2D &lt;- function (time, state, pars, N, Da, dx) {
  NN &lt;- N*N
  Prey &lt;- matrix(nrow = N, ncol = N,state[1:NN])
  Pred &lt;- matrix(nrow = N, ncol = N,state[(NN+1):(2*NN)])

  with (as.list(pars), {
    ## Biology
    dPrey &lt;- rGrow * Prey * (1- Prey/K) - rIng  * Prey * Pred
    dPred &lt;- rIng  * Prey * Pred*assEff - rMort * Pred

    zero &lt;- rep(0, N)

    ## 1. Fluxes in x-direction; zero fluxes near boundaries
    FluxPrey &lt;- -Da * rbind(zero,(Prey[2:N,] - Prey[1:(N-1),]), zero)/dx
    FluxPred &lt;- -Da * rbind(zero,(Pred[2:N,] - Pred[1:(N-1),]), zero)/dx

    ## Add flux gradient to rate of change
    dPrey    &lt;- dPrey - (FluxPrey[2:(N+1),] - FluxPrey[1:N,])/dx
    dPred    &lt;- dPred - (FluxPred[2:(N+1),] - FluxPred[1:N,])/dx

    ## 2. Fluxes in y-direction; zero fluxes near boundaries
    FluxPrey &lt;- -Da * cbind(zero,(Prey[,2:N] - Prey[,1:(N-1)]), zero)/dx
    FluxPred &lt;- -Da * cbind(zero,(Pred[,2:N] - Pred[,1:(N-1)]), zero)/dx

    ## Add flux gradient to rate of change
    dPrey    &lt;- dPrey - (FluxPrey[,2:(N+1)] - FluxPrey[,1:N])/dx
    dPred    &lt;- dPred - (FluxPred[,2:(N+1)] - FluxPred[,1:N])/dx

    return(list(c(as.vector(dPrey), as.vector(dPred))))
 })
}


## ===================
## Model applications
## ===================

pars    &lt;- c(rIng   = 0.2,    # /day, rate of ingestion
             rGrow  = 1.0,    # /day, growth rate of prey
             rMort  = 0.2 ,   # /day, mortality rate of predator
             assEff = 0.5,    # -, assimilation efficiency
             K      = 5  )    # mmol/m3, carrying capacity

R  &lt;- 20                      # total length of surface, m
N  &lt;- 50                      # number of boxes in one direction
dx &lt;- R/N                     # thickness of each layer
Da &lt;- 0.05                    # m2/d, dispersion coefficient

NN &lt;- N*N                     # total number of boxes

## initial conditions
yini    &lt;- rep(0, 2*N*N)
cc      &lt;- c((NN/2):(NN/2+1)+N/2, (NN/2):(NN/2+1)-N/2)
yini[cc] &lt;- yini[NN+cc] &lt;- 1

## solve model (5000 state variables...  use Cash-Karp Runge-Kutta method
times   &lt;- seq(0, 50, by = 1)
out &lt;- ode.2D(y = yini, times = times, func = lvmod2D, parms = pars,
              dimens = c(N, N), names = c("Prey", "Pred"),
              N = N, dx = dx, Da = Da, method = rkMethod("rk45ck"))

diagnostics(out)
summary(out)

# Mean of prey concentration at each time step
Prey &lt;- subset(out, select = "Prey", arr = TRUE)
dim(Prey)
MeanPrey &lt;- apply(Prey, MARGIN = 3, FUN = mean)
plot(times, MeanPrey)

## Not run: 
## plot results
Col &lt;- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan",
                          "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))

for (i in seq(1, length(times), by = 1))
   image(Prey[ , ,i],
   col = Col(100), xlab = , zlim = range(out[,2:(NN+1)]))

## similar, plotting both and adding a margin text with times:
image(out, xlab = "x", ylab = "y", mtext = paste("time = ", times))

## End(Not run)

select &lt;- c(1, 40)
image(out, xlab = "x", ylab = "y", mtext = "Lotka-Volterra in 2-D",
      subset = select, mfrow = c(2,2), legend =  TRUE)


# plot prey and pred at t = 10; first use subset to select data
prey10 &lt;-  matrix (nrow = N, ncol = N, 
     data = subset(out, select = "Prey", subset = (time == 10)))
pred10 &lt;-  matrix (nrow = N, ncol = N, 
     data = subset(out, select = "Pred", subset = (time == 10)))

mf &lt;- par(mfrow = c(1, 2))
image(prey10)
image(pred10)
par (mfrow = mf)

# same, using deSolve's image:
image(out, subset = (time == 10))

## =======================================================================
## An example with a cyclic boundary condition.
## Diffusion in 2-D; extra flux on 2 boundaries,
## cyclic boundary in y
## =======================================================================


diffusion2D &lt;- function(t, Y, par) {
  y    &lt;- matrix(nrow = nx, ncol = ny, data = Y)  # vector to 2-D matrix
  dY   &lt;- -r * y       # consumption
  BNDx &lt;- rep(1, nx)   # boundary concentration
  BNDy &lt;- rep(1, ny)   # boundary concentration

  ## diffusion in X-direction; boundaries=imposed concentration
  Flux &lt;- -Dx * rbind(y[1,] - BNDy, (y[2:nx,] - y[1:(nx-1),]), BNDy - y[nx,])/dx
  dY   &lt;- dY - (Flux[2:(nx+1),] - Flux[1:nx,])/dx

  ## diffusion in Y-direction
  Flux &lt;- -Dy * cbind(y[,1] - BNDx, (y[,2:ny]-y[,1:(ny-1)]), BNDx - y[,ny])/dy
  dY   &lt;- dY - (Flux[,2:(ny+1)] - Flux[,1:ny])/dy

  ## extra flux on two sides
  dY[,1] &lt;- dY[,1] + 10
  dY[1,] &lt;- dY[1,] + 10

  ## and exchange between sides on y-direction
  dY[,ny] &lt;- dY[,ny] + (y[,1] - y[,ny]) * 10
  return(list(as.vector(dY)))
}

## parameters
dy &lt;- dx &lt;- 1  # grid size
Dy &lt;- Dx &lt;- 1  # diffusion coeff, X- and Y-direction
r  &lt;- 0.05     # consumption rate

nx &lt;- 50
ny &lt;- 100
y  &lt;- matrix(nrow = nx, ncol = ny, 1)

## model most efficiently solved with lsodes - need to specify lrw

print(system.time(
  ST3 &lt;- ode.2D(y, times = 1:100, func = diffusion2D, parms = NULL,
                dimens = c(nx, ny), verbose = TRUE, names = "Y",
                lrw = 400000, atol = 1e-10, rtol = 1e-10, cyclicBnd = 2)
))

# summary of 2-D variable
summary(ST3)

# plot output at t = 10
t10 &lt;-  matrix (nrow = nx, ncol = ny, 
     data = subset(ST3, select = "Y", subset = (time == 10)))

persp(t10, theta = 30, border = NA, phi = 70, 
     col = "lightblue", shade = 0.5, box = FALSE)

# image plot, using deSolve's image function
image(ST3, subset = time == 10, method = "persp",
      theta = 30, border = NA, phi = 70, main = "", 
      col = "lightblue", shade = 0.5, box = FALSE)

## Not run: 
zlim &lt;- range(ST3[, -1])
for (i in 2:nrow(ST3)) {
  y &lt;- matrix(nrow = nx, ncol = ny, data = ST3[i, -1])
  filled.contour(y, zlim = zlim, main = i)
}

# same
image(ST3, method = "filled.contour")

## End(Not run)

</code></pre>

<hr>
<h2 id='ode.3D'>Solver for 3-Dimensional Ordinary Differential Equations</h2><span id='topic+ode.3D'></span>

<h3>Description</h3>

<p>Solves a system of ordinary differential equations resulting from
3-Dimensional partial differential equations
that have been converted to ODEs by numerical differencing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ode.3D(y, times, func, parms, nspec = NULL, dimens, 
  method = c("lsodes", "euler", "rk4", "ode23", "ode45", "adams", "iteration"),
  names = NULL, cyclicBnd = NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ode.3D_+3A_y">y</code></td>
<td>
<p>the initial (state) values for the ODE system, a vector. If
<code>y</code> has a name attribute, the names will be used to label the
output matrix.
</p>
</td></tr>
<tr><td><code id="ode.3D_+3A_times">times</code></td>
<td>
<p>time sequence for which output is wanted; the first
value of <code>times</code> must be the initial time.
</p>
</td></tr>
<tr><td><code id="ode.3D_+3A_func">func</code></td>
<td>
<p>either an <span class="rlang"><b>R</b></span>-function that computes the values of the
derivatives in the ODE system (the model definition) at time
<code>t</code>, or a character string giving the name of a compiled
function in a dynamically loaded shared library.
</p>
<p>If <code>func</code> is an <span class="rlang"><b>R</b></span>-function, it must be defined as:
<code>func &lt;- function(t, y, parms, ...)</code>.  <code>t</code> is the current time
point in the integration, <code>y</code> is the current estimate of the
variables in the ODE system.  If the initial values <code>y</code> has a
<code>names</code> attribute, the names will be available inside <code>func</code>.
<code>parms</code> is a vector or list of parameters; <code>...</code> (optional) are
any other arguments passed to the function.
</p>
<p>The return value of <code>func</code> should be a list, whose first
element is a vector containing the derivatives of <code>y</code> with
respect to <code>time</code>, and whose next elements are global values
that are required at each point in <code>times</code>. The derivatives
must be specified in the <b>same order</b> as the state variables <code>y</code>.
</p>
</td></tr>
<tr><td><code id="ode.3D_+3A_parms">parms</code></td>
<td>
<p>parameters passed to <code>func</code>.</p>
</td></tr>
<tr><td><code id="ode.3D_+3A_nspec">nspec</code></td>
<td>
<p>the number of <b>species</b> (components) in the model.</p>
</td></tr>
<tr><td><code id="ode.3D_+3A_dimens">dimens</code></td>
<td>
<p>3-valued vector with the number of <b>boxes</b> in three
dimensions in the model. 
</p>
</td></tr>
<tr><td><code id="ode.3D_+3A_names">names</code></td>
<td>
<p>the names of the components; used for plotting.
</p>
</td></tr>
<tr><td><code id="ode.3D_+3A_cyclicbnd">cyclicBnd</code></td>
<td>
<p>if not <code>NULL</code> then a number or a 3-valued vector
with the dimensions where a cyclic boundary is used - <code>1</code>: x-dimension,
<code>2</code>: y-dimension; <code>3</code>: z-dimension.
</p>
</td></tr>
<tr><td><code id="ode.3D_+3A_method">method</code></td>
<td>
<p>the integrator. Use <code>"lsodes"</code> if the model is very stiff;
&quot;impAdams&quot; may be best suited for mildly stiff problems; 
<code>"euler", "rk4", "ode23", "ode45", "adams"</code> are most
efficient for non-stiff problems. Also allowed is to pass an integrator
<code>function</code>. Use one of the other Runge-Kutta methods via 
<code>rkMethod</code>. For instance, <code>method = rkMethod("ode45ck")</code> will
trigger the Cash-Karp method of order 4(5).
</p>
<p>Method <code>"iteration"</code> is special in that here the function <code>func</code> should
return the new value of the state variables rather than the rate of change.
This can be used for individual based models, for difference equations,
or in those cases where the integration is performed within <code>func</code>)
</p>
</td></tr>
<tr><td><code id="ode.3D_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>lsodes</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the method of choice for 3-dimensional models, that are only
subjected to transport between adjacent layers.
</p>
<p>Based on the dimension of the problem, the method first calculates the
sparsity pattern of the Jacobian, under the assumption that transport
is only occurring between adjacent layers. Then <code>lsodes</code> is
called to solve the problem.
</p>
<p>As <code>lsodes</code> is used to integrate, it will probably be necessary
to specify the length of the real work array, <code>lrw</code>.
</p>
<p>Although a reasonable guess of <code>lrw</code> is made, it is likely that
this will be too low.  
</p>
<p>In this case, <code>ode.2D</code> will return with an
error message telling the size of the work array actually needed. In
the second try then, set <code>lrw</code> equal to this number.
</p>
<p>For instance, if you get the error:
</p>
<pre>   
DLSODES- RWORK length is insufficient to proceed.                               
  Length needed is .ge. LENRW (=I1), exceeds LRW (=I2)                    
  In above message,  I1 =     27627   I2 =     25932 
</pre>      
<p>set <code>lrw</code> equal to 27627 or a higher value.
</p>
<p>See <a href="#topic+lsodes">lsodes</a> for the additional options.
</p>


<h3>Value</h3>

<p>A matrix of class <code>deSolve</code> with up to as many rows as elements in times and as many
columns as elements in <code>y</code> plus the number of &quot;global&quot; values
returned in the second element of the return from <code>func</code>, plus an
additional column (the first) for the time value.  There will be one
row for each element in <code>times</code> unless the integrator returns
with an unrecoverable error.  If <code>y</code> has a names attribute, it
will be used to label the columns of the output value.
</p>
<p>The output will have the attributes <code>istate</code>, and <code>rstate</code>,
two vectors with several useful elements.  The first element of istate
returns the conditions under which the last call to the integrator
returned. Normal is <code>istate = 2</code>.  If <code>verbose = TRUE</code>, the
settings of istate and rstate will be written to the screen. See the
help for the selected integrator for details.
</p>


<h3>Note</h3>

<p>It is advisable though not mandatory to specify <b>both</b>
<code>nspec</code> and <code>dimens</code>. In this case, the solver can check
whether the input makes sense (as <code>nspec*dimens[1]*dimens[2]*dimens[3]
  == length(y)</code>).
</p>
<p>Do <b>not</b> use this method for problems that are not 3D!
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+ode">ode</a></code> for a general interface to most of the ODE solvers,
</p>
</li>
<li> <p><code><a href="#topic+ode.band">ode.band</a></code> for integrating models with a banded Jacobian
</p>
</li>
<li>  <p><code><a href="#topic+ode.1D">ode.1D</a></code> for integrating 1-D models
</p>
</li>
<li>  <p><code><a href="#topic+ode.2D">ode.2D</a></code> for integrating 2-D models
</p>
</li>
<li>  <p><code><a href="#topic+lsodes">lsodes</a></code> for the integration options.
</p>
</li></ul>

<p><code><a href="#topic+diagnostics">diagnostics</a></code> to print diagnostic messages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =======================================================================
## Diffusion in 3-D; imposed boundary conditions
## =======================================================================
diffusion3D &lt;- function(t, Y, par) {

  ## function to bind two matrices to an array
  mbind &lt;- function (Mat1, Array, Mat2, along = 1) {
    dimens &lt;- dim(Array) + c(0, 0, 2)
    if (along == 3)
      array(dim = dimens, data = c(Mat1, Array, Mat2))
    else if (along == 1)
      aperm(array(dim = dimens,
        data=c(Mat1, aperm(Array, c(3, 2, 1)), Mat2)), c(3, 2, 1))
    else if (along == 2)
      aperm(array(dim = dimens,
        data = c(Mat1, aperm(Array, c(1, 3, 2)), Mat2)), c(1, 3, 2))
  }

  yy  &lt;- array(dim=c(n, n, n), data = Y)      # vector to 3-D array
  dY  &lt;- -r*yy                                # consumption
  BND &lt;- matrix(nrow = n, ncol = n, data = 1) # boundary concentration

  ## diffusion in x-direction
  ## new array including boundary concentrations in X-direction
  BNDx &lt;- mbind(BND, yy, BND, along = 1)
  ## diffusive Flux
  Flux &lt;- -Dx * (BNDx[2:(n+2),,] - BNDx[1:(n+1),,])/dx
  ## rate of change = - flux gradient
  dY[] &lt;- dY[] - (Flux[2:(n+1),,] - Flux[1:n,,])/dx

  ## diffusion in y-direction
  BNDy &lt;- mbind(BND, yy, BND, along = 2)
  Flux &lt;- -Dy * (BNDy[,2:(n+2),] - BNDy[,1:(n+1),])/dy
  dY[] &lt;- dY[] - (Flux[,2:(n+1),] - Flux[,1:n,])/dy

  ## diffusion in z-direction
  BNDz &lt;- mbind(BND, yy, BND, along = 3)
  Flux &lt;- -Dz * (BNDz[,,2:(n+2)] - BNDz[,,1:(n+1)])/dz
  dY[] &lt;- dY[] - (Flux[,,2:(n+1)] - Flux[,,1:n])/dz

  return(list(as.vector(dY)))
}

## parameters
dy &lt;- dx &lt;- dz &lt;-1   # grid size
Dy &lt;- Dx &lt;- Dz &lt;-1   # diffusion coeff, X- and Y-direction
r  &lt;- 0.025          # consumption rate

n  &lt;- 10
y  &lt;- array(dim=c(n,n,n),data=10.)

## use lsodes, the default (for n&gt;20, Runge-Kutta more efficient)
print(system.time(
  RES &lt;- ode.3D(y, func = diffusion3D, parms = NULL, dimens = c(n, n, n),
                times = 1:20, lrw = 120000, atol = 1e-10,
                rtol = 1e-10, verbose = TRUE)
))

y &lt;- array(dim = c(n, n, n), data = RES[nrow(RES), -1])
filled.contour(y[, , n/2], color.palette = terrain.colors)

summary(RES)

## Not run: 
for (i in 2:nrow(RES)) {
  y &lt;- array(dim=c(n,n,n),data=RES[i,-1])
  filled.contour(y[,,n/2],main=i,color.palette=terrain.colors)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='ode.band'>Solver for Ordinary Differential Equations; Assumes a Banded
Jacobian
</h2><span id='topic+ode.band'></span>

<h3>Description</h3>

<p>Solves a system of ordinary differential equations.
</p>
<p>Assumes a banded Jacobian matrix, but does not rearrange the state
variables (in contrast to ode.1D).  Suitable for 1-D models that
include transport only between adjacent layers and that model only one
species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ode.band(y, times, func, parms, nspec = NULL, dimens = NULL, 
  bandup = nspec, banddown = nspec, method = "lsode", names = NULL, 
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ode.band_+3A_y">y</code></td>
<td>
<p>the initial (state) values for the ODE system, a vector. If
<code>y</code> has a name attribute, the names will be used to label the
output matrix.
</p>
</td></tr>
<tr><td><code id="ode.band_+3A_times">times</code></td>
<td>
<p>time sequence for which output is wanted; the first
value of <code>times</code> must be the initial time.
</p>
</td></tr>
<tr><td><code id="ode.band_+3A_func">func</code></td>
<td>
<p>either an <span class="rlang"><b>R</b></span>-function that computes the values of the
derivatives in the ODE system (the model definition) at time
<code>t</code>, or a character string giving the name of a compiled
function in a dynamically loaded shared library.
</p>
<p>If <code>func</code> is an <span class="rlang"><b>R</b></span>-function, it must be defined as:
<code>func &lt;- function(t, y, parms, ...)</code>.  <code>t</code> is the current time
point in the integration, <code>y</code> is the current estimate of the
variables in the ODE system.  If the initial values <code>y</code> has a
<code>names</code> attribute, the names will be available inside <code>func</code>.
<code>parms</code> is a vector or list of parameters; <code>...</code> (optional) are
any other arguments passed to the function.
</p>
<p>The return value of <code>func</code> should be a list, whose first
element is a vector containing the derivatives of <code>y</code> with
respect to <code>time</code>, and whose next elements are global values
that are required at each point in <code>times</code>.The derivatives
must be specified in the <b>same order</b> as the state variables <code>y</code>.
</p>
</td></tr>
<tr><td><code id="ode.band_+3A_parms">parms</code></td>
<td>
<p>parameters passed to <code>func</code>.
</p>
</td></tr>
<tr><td><code id="ode.band_+3A_nspec">nspec</code></td>
<td>
<p>the number of *species* (components) in the model.
</p>
</td></tr>
<tr><td><code id="ode.band_+3A_dimens">dimens</code></td>
<td>
<p>the number of <b>boxes</b> in the model. If <code>NULL</code>, then
<code>nspec</code> should be specified.
</p>
</td></tr>
<tr><td><code id="ode.band_+3A_bandup">bandup</code></td>
<td>
<p>the number of nonzero bands above the Jacobian
diagonal.
</p>
</td></tr>
<tr><td><code id="ode.band_+3A_banddown">banddown</code></td>
<td>
<p>the number of nonzero bands below the Jacobian
diagonal.
</p>
</td></tr>
<tr><td><code id="ode.band_+3A_method">method</code></td>
<td>
<p>the integrator to use, one of <code>"vode"</code>,
<code>"lsode"</code>, <code>"lsoda"</code>, <code>"lsodar"</code>, <code>"radau"</code>.
</p>
</td></tr>
<tr><td><code id="ode.band_+3A_names">names</code></td>
<td>
<p>the names of the components; used for plotting.
</p>
</td></tr>
<tr><td><code id="ode.band_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the integrator.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the method of choice for single-species 1-D reactive transport
models.
</p>
<p>For multi-species 1-D models, this method can only be used if the
state variables are arranged per box, per species (e.g. A[1], B[1],
A[2], B[2], A[3], B[3], ... for species A, B).  By default, the
<b>model</b> function will have the species arranged as A[1], A[2],
A[3], ... B[1], B[2], B[3], ...  in this case, use <code>ode.1D</code>.
</p>
<p>See the selected integrator for the additional options.
</p>


<h3>Value</h3>

<p>A matrix of class <code>deSolve</code> with up to as many rows as elements in <code>times</code> and as
many columns as elements in <code>y</code> plus the number of &quot;global&quot;
values returned in the second element of the return from <code>func</code>,
plus an additional column (the first) for the time value.  There will
be one row for each element in <code>times</code> unless the integrator
returns with an unrecoverable error.  If <code>y</code> has a names
attribute, it will be used to label the columns of the output value.
</p>
<p>The output will have the attributes <code>istate</code> and <code>rstate</code>,
two vectors with several elements. See the help for the selected
integrator for details.  the first element of istate returns the
conditions under which the last call to the integrator returned. Normal is
<code>istate = 2</code>.  If <code>verbose = TRUE</code>, the settings of
<code>istate</code> and <code>rstate</code> will be written to the screen.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+ode">ode</a></code> for a general interface to most of the ODE solvers,
</p>
</li>
<li>  <p><code><a href="#topic+ode.1D">ode.1D</a></code> for integrating 1-D models
</p>
</li>
<li>  <p><code><a href="#topic+ode.2D">ode.2D</a></code> for integrating 2-D models
</p>
</li>
<li>  <p><code><a href="#topic+ode.3D">ode.3D</a></code> for integrating 3-D models
</p>
</li>
<li>  <p><code><a href="#topic+lsode">lsode</a></code>, <code><a href="#topic+lsoda">lsoda</a></code>, <code><a href="#topic+lsodar">lsodar</a></code>,
<code><a href="#topic+vode">vode</a></code> for the integration options.
</p>
</li></ul>

<p><code><a href="#topic+diagnostics">diagnostics</a></code> to print diagnostic messages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## =======================================================================
## The Aphid model from Soetaert and Herman, 2009.
## A practical guide to ecological modelling.
## Using R as a simulation platform. Springer.
## =======================================================================

## 1-D diffusion model

## ================
## Model equations
## ================
Aphid &lt;- function(t, APHIDS, parameters) {
  deltax  &lt;- c (0.5*delx, rep(delx, numboxes-1), 0.5*delx)
  Flux    &lt;- -D*diff(c(0, APHIDS, 0))/deltax
  dAPHIDS &lt;- -diff(Flux)/delx + APHIDS*r

  list(dAPHIDS)   # the output
}
  
## ==================
## Model application
## ==================

## the model parameters:
D         &lt;- 0.3    # m2/day  diffusion rate
r         &lt;- 0.01   # /day    net growth rate
delx      &lt;- 1      # m       thickness of boxes
numboxes  &lt;- 60 

## distance of boxes on plant, m, 1 m intervals
Distance  &lt;- seq(from = 0.5, by = delx, length.out = numboxes)

## Initial conditions, ind/m2
## aphids present only on two central boxes
APHIDS        &lt;- rep(0, times = numboxes)
APHIDS[30:31] &lt;- 1
state         &lt;- c(APHIDS = APHIDS)      # initialise state variables 
                  
## RUNNING the model:
times &lt;- seq(0, 200, by = 1)   # output wanted at these time intervals
out   &lt;- ode.band(state, times, Aphid, parms = 0, 
                  nspec = 1, names = "Aphid")

## ================
## Plotting output
## ================
image(out, grid = Distance, method = "filled.contour", 
      xlab = "time, days", ylab = "Distance on plant, m",
      main = "Aphid density on a row of plants")

matplot.1D(out, grid = Distance, type = "l", 
   subset = time %in% seq(0, 200, by = 10))

# add an observed dataset to 1-D plot (make sure to use correct name):
data &lt;- cbind(dist  = c(0,10, 20,  30,  40, 50, 60), 
              Aphid = c(0,0.1,0.25,0.5,0.25,0.1,0))

matplot.1D(out, grid = Distance, type = "l", 
   subset = time %in% seq(0, 200, by = 10), 
   obs = data, obspar = list(pch = 18, cex = 2, col="red"))
## Not run: 
plot.1D(out, grid = Distance, type = "l")


## End(Not run)
</code></pre>

<hr>
<h2 id='plot.deSolve'>
Plot, Image and Histogram Method for deSolve Objects
</h2><span id='topic+plot.deSolve'></span><span id='topic+plot.1D'></span><span id='topic+matplot.0D'></span><span id='topic+matplot.deSolve'></span><span id='topic+matplot.1D'></span><span id='topic+hist.deSolve'></span><span id='topic+image.deSolve'></span><span id='topic+subset.deSolve'></span>

<h3>Description</h3>

<p>Plot the output of numeric integration routines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'deSolve'
plot(x, ..., select = NULL, which = select, ask = NULL,
              obs = NULL, obspar = list(), subset = NULL)




## S3 method for class 'deSolve'
hist(x, select = 1:(ncol(x)-1), which  = select, ask = NULL,
              subset = NULL, ...)
## S3 method for class 'deSolve'
image(x, select = NULL, which = select, ask = NULL,
              add.contour = FALSE, grid = NULL,
              method = "image", legend = FALSE, subset = NULL, ...)
## S3 method for class 'deSolve'
subset(x, subset = NULL, select = NULL,
             which = select, arr = FALSE, ...)

plot.1D (x, ..., select = NULL, which = select, ask = NULL,
         obs = NULL, obspar = list(), grid = NULL,
         xyswap = FALSE, delay = 0, vertical = FALSE, subset = NULL)

matplot.0D(x, ..., select = NULL, which = select,
           obs = NULL, obspar = list(), subset = NULL,
           legend = list(x = "topright"))

matplot.1D(x, select = NULL, which = select, ask = NULL,
         obs = NULL, obspar = list(), grid = NULL,
         xyswap = FALSE, vertical = FALSE, subset = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.deSolve_+3A_x">x</code></td>
<td>
<p>an object of class <code>deSolve</code>, as returned by the
integrators, and to be plotted.
</p>
<p>For <code>plot.deSolve</code>, it is allowed to pass several objects of class
<code>deSolve</code> after <code>x</code> (unnamed) - see second example.
</p>
</td></tr>
<tr><td><code id="plot.deSolve_+3A_which">which</code></td>
<td>
<p>the name(s) or the index to the variables that should be
plotted or selected.  Default = all variables, except <code>time</code>.
For use with <code>matplot.0D</code> and <code>matplot.1D</code>, <code>which</code> or <code>select</code> can be a list,
with vectors, each referring to a separate y-axis.
</p>
</td></tr>
<tr><td><code id="plot.deSolve_+3A_select">select</code></td>
<td>
<p>which variable/columns to be selected.  This is added for
consistency with the R-function <code>subset</code>.
</p>
</td></tr>
<tr><td><code id="plot.deSolve_+3A_subset">subset</code></td>
<td>
<p>either a logical expression indicating elements or rows to keep in
<code>select</code>, or a vector of integers denoting the indices of the elements
over which to loop. Missing  values are taken as <code>FALSE</code>
</p>
</td></tr>
<tr><td><code id="plot.deSolve_+3A_ask">ask</code></td>
<td>
<p>logical; if <code>TRUE</code>, the user is <em>ask</em>ed before
each plot, if <code>NULL</code> the user is only asked if more than one
page of plots is necessary and the current graphics device is set
interactive, see <code><a href="graphics.html#topic+par">par</a>(ask)</code> and
<code><a href="grDevices.html#topic+dev.interactive">dev.interactive</a></code>.</p>
</td></tr>
<tr><td><code id="plot.deSolve_+3A_add.contour">add.contour</code></td>
<td>
<p>if <code>TRUE</code>, will add contours to the image plot.</p>
</td></tr>
<tr><td><code id="plot.deSolve_+3A_method">method</code></td>
<td>
<p>the name of the plotting method to use, one of &quot;image&quot;,
&quot;filled.contour&quot;, &quot;persp&quot;, &quot;contour&quot;.</p>
</td></tr>
<tr><td><code id="plot.deSolve_+3A_grid">grid</code></td>
<td>
<p>only for <code>image</code> plots and for <code>plot.1D</code>:
the 1-D grid as a vector (for output generated with <code>ode.1D</code>),
or the x- and y-grid, as a <code>list</code> (for output generated with
<code>ode.2D</code>).</p>
</td></tr>
<tr><td><code id="plot.deSolve_+3A_xyswap">xyswap</code></td>
<td>
<p>if <code>TRUE</code>, then x-and y-values are swapped and the
y-axis is from top to bottom. Useful for drawing vertical profiles.</p>
</td></tr>
<tr><td><code id="plot.deSolve_+3A_vertical">vertical</code></td>
<td>
<p>if <code>TRUE</code>, then 1. x-and y-values are swapped, the
y-axis is from top to bottom, the x-axis is on top, margin 3 and the
main title gets the value of the x-axis.
Useful for drawing vertical profiles; see example 2.</p>
</td></tr>
<tr><td><code id="plot.deSolve_+3A_delay">delay</code></td>
<td>
<p>adds a delay (in milliseconds) between consecutive plots
of <code>plot.1D</code> to enable animations.</p>
</td></tr>
<tr><td><code id="plot.deSolve_+3A_obs">obs</code></td>
<td>
<p>a <code>data.frame</code> or <code>matrix</code> with &quot;observed data&quot; that
will be added as <code>points</code> to the plots. <code>obs</code> can also be a
<code>list</code> with multiple data.frames and/or matrices containing
observed data.
</p>
<p>By default the first column of an observed data set should contain
the <code>time</code>-variable.   The other columns contain the observed values
and they should have names that are known in <code>x</code>.
</p>
<p>If the first column of <code>obs</code> consists of factors or characters (strings),
then it is assumed that the data are presented in long (database) format,
where the first three columns contain (name, time, value).
</p>
<p>If <code>obs</code> is not <code>NULL</code> and <code>which</code> is <code>NULL</code>,
then the variables, common to both <code>obs</code> and <code>x</code> will be plotted.
</p>
</td></tr>
<tr><td><code id="plot.deSolve_+3A_obspar">obspar</code></td>
<td>
<p>additional graphics arguments passed to <code>points</code>, for
plotting the observed data. If <code>obs</code> is a <code>list</code> containing multiple
observed data sets, then the graphics arguments can be  a vector
or a list (e.g. for <code>xlim</code>, <code>ylim</code>), specifying each data set
separately.
</p>
</td></tr>
<tr><td><code id="plot.deSolve_+3A_legend">legend</code></td>
<td>
<p>if <code>TRUE</code>, a color legend will be drawn on the right
of each image.
For use with <code>matplot.0D</code> and <code>matplot.1D</code>:
a <code>list</code> with arguments passed to R-function <a href="graphics.html#topic+legend">legend</a>.
</p>
</td></tr>
<tr><td><code id="plot.deSolve_+3A_arr">arr</code></td>
<td>
<p>if <code>TRUE</code>, and the output is from a 2-D or 3-D model,
an array will be returned with dimension =
c(dimension of selected variable, nrow(x)).
When <code>arr=TRUE</code> then only one variable can be selected.
When the output is from a 0-D or 1-D model, then this argument is ignored.
</p>
</td></tr>
<tr><td><code id="plot.deSolve_+3A_...">...</code></td>
<td>
<p>additional arguments.
</p>
<p>The graphical arguments are passed to
<code><a href="graphics.html#topic+plot.default">plot.default</a></code>, <code><a href="Matrix.html#topic+image">image</a></code> or <code><a href="graphics.html#topic+hist">hist</a></code>
</p>
<p>For <code>plot.deSolve</code>, and <code>plot.1D</code>, the dots may contain other objects of class
<code>deSolve</code>, as returned by the integrators, and
to be plotted on the same graphs as <code>x</code>  - see second example.
In this case, <code>x</code> and and these other objects should be compatible,
i.e. the column names should be the same.
</p>
<p>For <code>plot.deSolve</code>, the arguments after ... must be matched exactly.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of panels per page is automatically determined up to 3 x 3
(<code>par(mfrow = c(3, 3))</code>). This default can be overwritten by
specifying user-defined settings for <code>mfrow</code> or <code>mfcol</code>.
Set <code>mfrow</code> equal to <code>NULL</code> to avoid the plotting function to
change user-defined <code>mfrow</code> or <code>mfcol</code> settings.
</p>
<p>Other graphical parameters can be passed as well. Parameters are
vectorized, either according to the number of plots (<code>xlab</code>,
<code>ylab</code>, <code>main</code>, <code>sub</code>, <code>xlim</code>, <code>ylim</code>,
<code>log</code>, <code>asp</code>, <code>ann</code>, <code>axes</code>, <code>frame.plot</code>,
<code>panel.first</code>, <code>panel.last</code>, <code>cex.lab</code>,
<code>cex.axis</code>, <code>cex.main</code>) or according to the number of lines
within one plot (other parameters e.g. <code>col</code>, <code>lty</code>,
<code>lwd</code> etc.) so it is possible to assign specific axis labels to
individual plots, resp. different plotting style. Plotting parameter
<code>ylim</code>, or <code>xlim</code> can also be a list to assign different
axis limits to individual plots.
</p>
<p>Similarly, the graphical parameters for observed data, as passed by
<code>obspar</code> can be vectorized, according to the number of observed
data sets.
</p>
<p>Image plots will only work for 1-D and 2-D variables, as solved with
<code><a href="#topic+ode.1D">ode.1D</a></code> and <code><a href="#topic+ode.2D">ode.2D</a></code>. In the first case, an
image with <code>times</code> as x- and the <code>grid</code> as y-axis will be
created.  In the second case, an x-y plot will be created, for all
times. Unless <code>ask = FALSE</code>, the user will be asked to confirm
page changes.  Via argument <code>mtext</code>, it is possible to label each
page in case of 2D output.
</p>
<p>For images, it is possible to pass an argument
<code>method</code> which can take the values &quot;image&quot; (default),
&quot;filled.contour&quot;, &quot;contour&quot; or &quot;persp&quot;, in order to use the respective
plotting method.
</p>
<p><code>plot</code> and <code>matplot.0D</code> will always have <code>times</code> on the x-axis.
For problems solved with <code>ode.1D</code>, it may be more useful to use
<code>plot.1D</code> or <code>matplot.1D</code>
which will plot how spatial variables change with time. These plots will
have the <code>grid</code> on the x-axis.
</p>


<h3>Value</h3>

<p>Function <code>subset</code> called with <code>arr = FALSE</code> will return a
matrix with up to as many rows as selected by <code>subset</code> and as
many columns as selected variables.
</p>
<p>When <code>arr = TRUE</code> then an array will be outputted with dimensions
equal to the dimension of the selected variable, augmented with the number
of rows selected by <code>subset</code>.  This means that the last dimension points
to <code>times</code>.
</p>
<p>Function <code>subset</code> also has an attribute that contains the <code>times</code>
selected.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deSolve">deSolve</a></code>, <code><a href="#topic+ode">ode</a></code>, <code><a href="#topic+print.deSolve">print.deSolve</a></code>,
</p>
<p><code><a href="graphics.html#topic+hist">hist</a></code>
<code><a href="graphics.html#topic+image">image</a></code>
<code><a href="graphics.html#topic+matplot">matplot</a></code>,
<code><a href="graphics.html#topic+plot">plot</a>.default</code>
for the underlying functions from package <span class="pkg">graphics</span>,
</p>
<p><code><a href="#topic+ode.2D">ode.2D</a></code>, for an example of using <code>subset</code> with
<code>arr = TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =======================================================================
## Example 1. A Predator-Prey model with 4 species in matrix formulation
## =======================================================================

LVmatrix &lt;- function(t, n, parms) {
  with(parms, {
    dn &lt;- r * n + n * (A %*% n)
    return(list(c(dn)))
  })
}
parms &lt;- list(
  r = c(r1 = 0.1, r2 = 0.1, r3 = -0.1, r4 = -0.1),
  A = matrix(c(0.0, 0.0, -0.2, 0.01,      # prey 1
               0.0, 0.0, 0.02, -0.1,      # prey 2
               0.2, 0.02, 0.0, 0.0,       # predator 1; prefers prey 1
               0.01, 0.1, 0.0, 0.0),      # predator 2; prefers prey 2
               nrow = 4, ncol = 4, byrow=TRUE)
)
times &lt;- seq(from = 0, to = 500, by = 0.1)
y     &lt;- c(prey1 = 1, prey2 = 1, pred1 = 2, pred2 = 2)

out &lt;- ode(y, times, LVmatrix, parms)

## Basic line plot
plot(out, type = "l")

## User-specified axis labels
plot(out, type = "l", ylab = c("Prey 1", "Prey 2", "Pred 1", "Pred 2"),
  xlab = "Time (d)", main = "Time Series")

## Set user-defined mfrow
pm &lt;- par (mfrow = c(2, 2))

## "mfrow=NULL" keeps user-defined mfrow
plot(out, which = c("prey1", "pred2"), mfrow = NULL, type = "l", lwd = 2)

plot(out[,"prey1"], out[,"pred1"], xlab="prey1",
  ylab = "pred1", type = "l", lwd = 2)
plot(out[,"prey2"], out[,"pred2"], xlab = "prey2",
  ylab = "pred2", type = "l",lwd = 2)

## restore graphics parameters
par ("mfrow" = pm)

## Plot all in one figure, using matplot
matplot.0D(out, lwd = 2)

## Split y-variables in two groups
matplot.0D(out, which = list(c(1,3), c(2,4)),
           lty = c(1,2,1,2), col=c(4,4,5,5),
           ylab = c("prey1,pred1", "prey2,pred2"))

## =======================================================================
## Example 2. Add second and third output, and observations
## =======================================================================

# New runs with different parameter settings
parms2      &lt;- parms
parms2$r[1] &lt;- 0.2
out2 &lt;- ode(y, times, LVmatrix, parms2)

# New runs with different parameter settings
parms3      &lt;- parms
parms3$r[1] &lt;- 0.05
out3 &lt;- ode(y, times, LVmatrix, parms3)

# plot all three outputs
plot(out, out2, out3, type = "l",
     ylab = c("Prey 1", "Prey 2", "Pred 1", "Pred 2"),
     xlab = "Time (d)", main = c("Prey 1", "Prey 2", "Pred 1", "Pred 2"),
     col = c("red", "blue", "darkred"))


## 'observed' data
obs &lt;- as.data.frame(out[out[,1] %in% seq(10, 500, by = 30), ])

plot(out, which = "prey1", type = "l", obs = obs,
     obspar = list(pch = 18, cex = 2))

plot(out, type = "l", obs = obs, col = "red")

matplot.0D(out, which = c("prey1", "pred1"), type = "l", obs = obs)

## second set of 'observed' data and two outputs
obs2 &lt;- as.data.frame(out2[out2[,1] %in% seq(10, 500, by = 50), ])

## manual xlim, log
plot(out, out2, type = "l", obs = list(obs, obs2), col = c("red", "blue"),
      obspar = list(pch = 18:19, cex = 2, col = c("red", "blue")),
      log = c("y", ""), which = c("prey1", "prey1"),
      xlim = list(c(100, 500), c(0, 400)))

## data in 'long' format
OBS &lt;- data.frame(name = c(rep("prey1", 3), rep("prey2", 2)),
                  time = c(10, 100, 250, 10, 400),
                  value = c(0.05, 0.04, 0.7, 0.5, 1))
OBS
plot(out, obs = OBS, obspar = c(pch = 18, cex = 2))

# a subset only:
plot(out, subset = prey1 &lt; 0.5, type = "p")

# Simple histogram
hist(out, col = "darkblue", breaks = 50)

hist(out, col = "darkblue", breaks = 50, subset = prey1&lt;1 &amp; prey2 &lt; 1)

# different parameters per plot
hist(out, col = c("darkblue", "red", "orange", "black"),
     breaks = c(10,50))

## =======================================================================
## The Aphid model from Soetaert and Herman, 2009.
## A practical guide to ecological modelling.
## Using R as a simulation platform. Springer.
## =======================================================================

## 1-D diffusion model

## ================
## Model equations
## ================
Aphid &lt;- function(t, APHIDS, parameters) {
  deltax  &lt;- c (0.5*delx, rep(delx, numboxes - 1), 0.5*delx)
  Flux    &lt;- -D * diff(c(0, APHIDS, 0))/deltax
  dAPHIDS &lt;- -diff(Flux)/delx + APHIDS * r
  list(dAPHIDS, Flux = Flux)
}

## ==================
## Model application
## ==================

## the model parameters:
D         &lt;- 0.3    # m2/day  diffusion rate
r         &lt;- 0.01   # /day    net growth rate
delx      &lt;- 1      # m       thickness of boxes
numboxes  &lt;- 60

## distance of boxes on plant, m, 1 m intervals
Distance  &lt;- seq(from = 0.5, by = delx, length.out = numboxes)

## Initial conditions, ind/m2
## aphids present only on two central boxes
APHIDS        &lt;- rep(0, times = numboxes)
APHIDS[30:31] &lt;- 1
state         &lt;- c(APHIDS = APHIDS)      # initialise state variables

## RUNNING the model:
times &lt;- seq(0, 200, by = 1)   # output wanted at these time intervals
out   &lt;- ode.1D(state, times, Aphid, parms = 0, nspec = 1, names = "Aphid")

image(out, grid = Distance, main = "Aphid model", ylab = "distance, m",
  legend = TRUE)

## restricting time
image(out, grid = Distance, main = "Aphid model", ylab = "distance, m",
  legend = TRUE, subset = time &lt; 100)

image(out, grid = Distance, main = "Aphid model", ylab = "distance, m",
  method = "persp", border = NA, theta = 30)

FluxAphid &lt;- subset(out, select = "Flux", subset = time &lt; 50)

matplot.1D(out, type = "l", lwd = 2, xyswap = TRUE, lty = 1)

matplot.1D(out, type = "l", lwd = 2, xyswap = TRUE, lty = 1,
           subset = time &lt; 50)

matplot.1D(out, type = "l", lwd = 2, xyswap = TRUE, lty = 1,
           subset = time %in% seq(0, 200, by = 10), col = "grey")

## Not run: 
  plot(out, ask = FALSE, mfrow = c(1, 1))
  plot.1D(out, ask = FALSE, type = "l", lwd = 2, xyswap = TRUE)

## End(Not run)

## see help file for ode.2D for images of 2D variables
</code></pre>

<hr>
<h2 id='radau'>Implicit Runge-Kutta RADAU IIA</h2><span id='topic+radau'></span>

<h3>Description</h3>

<p>Solves the initial value problem for stiff or nonstiff systems of
ordinary differential equations (ODE) in the form: </p>
<p style="text-align: center;"><code class="reqn">dy/dt = 
  f(t,y)</code>
</p>
<p> or linearly implicit differential algebraic equations in the 
form: </p>
<p style="text-align: center;"><code class="reqn">M dy/dt = f(t,y)</code>
</p>
<p>.
</p>
<p>The <span class="rlang"><b>R</b></span> function <code>radau</code> provides an interface to the Fortran solver 
RADAU5, written by Ernst Hairer and G. Wanner, which implements the 3-stage
RADAU IIA method.
It implements the implicit Runge-Kutta method of order 5 with step size 
control and continuous output.
The system of ODEs or DAEs is written as an <span class="rlang"><b>R</b></span> function or can be defined in
compiled code that has been dynamically loaded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radau(y, times, func, parms, nind = c(length(y), 0, 0), 
  rtol = 1e-6, atol = 1e-6, jacfunc = NULL, jactype = "fullint", 
  mass = NULL, massup = NULL, massdown = NULL, rootfunc = NULL,
  verbose = FALSE, nroot = 0, hmax = NULL, hini = 0, ynames = TRUE,
  bandup = NULL, banddown = NULL, maxsteps = 5000, 
  dllname = NULL, initfunc = dllname, initpar = parms, 
  rpar = NULL, ipar = NULL, nout = 0, outnames = NULL, 
  forcings = NULL, initforc = NULL, fcontrol = NULL,
  events=NULL, lags = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="radau_+3A_y">y</code></td>
<td>
<p>the initial (state) values for the ODE system. If <code>y</code>
has a name attribute, the names will be used to label the output
matrix.
</p>
</td></tr>
<tr><td><code id="radau_+3A_times">times</code></td>
<td>
<p>time sequence for which output is wanted; the first
value of <code>times</code> must be the initial time; if only one step is
to be taken; set <code>times</code> = <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="radau_+3A_func">func</code></td>
<td>
<p>either an <span class="rlang"><b>R</b></span>-function that computes the values of the
derivatives in the ODE system (the <em>model definition</em>) at time
t, or the right-hand side of the equation </p>
<p style="text-align: center;"><code class="reqn">M dy/dt = f(t,y)</code>
</p>

<p>if a DAE. (if <code>mass</code> is supplied then the problem is assumed a DAE).
</p>
<p><code>func</code> can also be a character string giving the name of a compiled 
function in a dynamically loaded shared library.
</p>
<p>If <code>func</code> is an <span class="rlang"><b>R</b></span>-function, it must be defined as:
</p>
<p><code>func &lt;- function(t, y, parms,...)</code>.
</p>
<p><code>t</code> is the current time
point in the integration, <code>y</code> is the current estimate of the
variables in the ODE system.  If the initial values <code>y</code> has a
<code>names</code> attribute, the names will be available inside <code>func</code>.
<code>parms</code> is a vector or list of parameters; ... (optional) are
any other arguments passed to the function.
</p>
<p>The return value of <code>func</code> should be a list, whose first
element is a vector containing the derivatives of <code>y</code> with
respect to <code>time</code>, and whose next elements are global values
that are required at each point in <code>times</code>.  The derivatives
must be specified in the <b>same order</b> as the state variables <code>y</code>.
</p>
<p>If <code>func</code> is
a string, then <code>dllname</code> must give the name of the shared
library (without extension) which must be loaded before
<code>radau()</code> is called. See deSolve package vignette <code>"compiledCode"</code>
for more details.
</p>
</td></tr>
<tr><td><code id="radau_+3A_parms">parms</code></td>
<td>
<p>vector or list of parameters used in <code>func</code> or
<code>jacfunc</code>.
</p>
</td></tr>
<tr><td><code id="radau_+3A_nind">nind</code></td>
<td>
<p>if a DAE system: a three-valued vector with the number of
variables of index 1, 2, 3 respectively.
The equations must be defined such that the index 1 variables precede
the index 2 variables which in turn precede the index 3 variables.
The sum of the variables of different index should equal N,
the total number of variables.
This has implications on the scaling of the variables,
i.e. index 2 variables are scaled by 1/h,
index 3 variables are scaled by 1/h^2. 
</p>
</td></tr>
<tr><td><code id="radau_+3A_rtol">rtol</code></td>
<td>
<p>relative error tolerance, either a
scalar or an array as long as <code>y</code>. See details.
</p>
</td></tr>
<tr><td><code id="radau_+3A_atol">atol</code></td>
<td>
<p>absolute error tolerance, either a scalar or an array as
long as <code>y</code>. See details.
</p>
</td></tr>
<tr><td><code id="radau_+3A_jacfunc">jacfunc</code></td>
<td>
<p>if not <code>NULL</code>, an <span class="rlang"><b>R</b></span> function that computes the
Jacobian of the system of differential equations
<code class="reqn">\partial\dot{y}_i/\partial y_j</code>, or
a string giving the name of a function or subroutine in
&lsquo;<span class="file">dllname</span>&rsquo; that computes the Jacobian (see vignette
<code>"compiledCode"</code> from package deSolve, for more about this option).
</p>
<p>In some circumstances, supplying
<code>jacfunc</code> can speed up the computations, if the system is
stiff.  The <span class="rlang"><b>R</b></span> calling sequence for <code>jacfunc</code> is identical to
that of <code>func</code>.
</p>
<p>If the Jacobian is a full matrix,
<code>jacfunc</code> should return a matrix
<code class="reqn">\partial\dot{y}/\partial y</code>, where the ith row
contains the derivative of <code class="reqn">dy_i/dt</code> with respect to <code class="reqn">y_j</code>,
or a vector containing the matrix elements by columns (the way <span class="rlang"><b>R</b></span>
and FORTRAN store matrices).  <br /> If the Jacobian is banded,
<code>jacfunc</code> should return a matrix containing only the nonzero
bands of the Jacobian, rotated row-wise. See example.
</p>
</td></tr>
<tr><td><code id="radau_+3A_jactype">jactype</code></td>
<td>
<p>the structure of the Jacobian, one of
<code>"fullint"</code>, <code>"fullusr"</code>, <code>"bandusr"</code> or
<code>"bandint"</code> - either full or banded and estimated internally or
by user.
</p>
</td></tr>
<tr><td><code id="radau_+3A_mass">mass</code></td>
<td>
<p>the mass matrix. 
If not <code>NULL</code>, the problem is a linearly
implicit DAE and defined as <code class="reqn">M\, dy/dt = f(t,y)</code>.
If the mass-matrix <code class="reqn">M</code> is full, it should be of dimension
<code class="reqn">n^2</code> where <code class="reqn">n</code> is the number of <code class="reqn">y</code>-values;
if banded the number of rows should be less than <code class="reqn">n</code>,
and the mass-matrix is stored diagonal-wise with element <code class="reqn">(i, j)</code>
stored in <code>mass(i - j + mumas + 1, j)</code>.
</p>
<p>If <code>mass = NULL</code> then the model is an ODE (default)  
</p>
</td></tr>
<tr><td><code id="radau_+3A_massup">massup</code></td>
<td>
<p>number of non-zero bands above the diagonal of the <code>mass</code> 
matrix, in case it is banded.
</p>
</td></tr>
<tr><td><code id="radau_+3A_massdown">massdown</code></td>
<td>
<p>number of non-zero bands below the diagonal of the <code>mass</code> 
matrix, in case it is banded.
</p>
</td></tr>
<tr><td><code id="radau_+3A_rootfunc">rootfunc</code></td>
<td>
<p>if not <code>NULL</code>, an <span class="rlang"><b>R</b></span> function that computes the
function whose root has to be estimated or a string giving the name
of a function or subroutine in &lsquo;<span class="file">dllname</span>&rsquo; that computes the root
function.  The <span class="rlang"><b>R</b></span> calling sequence for <code>rootfunc</code> is identical
to that of <code>func</code>.  <code>rootfunc</code> should return a vector with
the function values whose root is sought.
</p>
</td></tr>
<tr><td><code id="radau_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>: full output to the screen, e.g. will
print the <code>diagnostiscs</code> of the integration - see details.
</p>
</td></tr>
<tr><td><code id="radau_+3A_nroot">nroot</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo;  is specified: the number of
constraint functions whose roots are desired during the integration;
if <code>rootfunc</code> is an R-function, the solver estimates the number
of roots.
</p>
</td></tr>
<tr><td><code id="radau_+3A_hmax">hmax</code></td>
<td>
<p>an optional maximum value of the integration stepsize. If
not specified, <code>hmax</code> is set to the largest difference in
<code>times</code>, to avoid that the simulation possibly ignores
short-term events. If 0, no maximal size is specified.
</p>
</td></tr>
<tr><td><code id="radau_+3A_hini">hini</code></td>
<td>
<p>initial step size to be attempted; if 0, the initial step
size is set equal to 1e-6. Usually 1e-3 to 1e-5 is good for stiff equations
</p>
</td></tr>
<tr><td><code id="radau_+3A_ynames">ynames</code></td>
<td>
<p>logical, if <code>FALSE</code> names of state variables are not
passed to function <code>func</code>; this may speed up the simulation especially
for multi-D models.
</p>
</td></tr>
<tr><td><code id="radau_+3A_bandup">bandup</code></td>
<td>
<p>number of non-zero bands above the diagonal, in case
the Jacobian is banded.
</p>
</td></tr>
<tr><td><code id="radau_+3A_banddown">banddown</code></td>
<td>
<p>number of non-zero bands below the diagonal, in case
the Jacobian is banded.
</p>
</td></tr>
<tr><td><code id="radau_+3A_maxsteps">maxsteps</code></td>
<td>
<p>average maximal number of steps per output interval
taken by the solver. This argument is defined such as to ensure
compatibility with the Livermore-solvers. RADAU only accepts the maximal
number of steps for the entire integration, and this is calculated 
as <code>length(times) * maxsteps</code>.
</p>
</td></tr>
<tr><td><code id="radau_+3A_dllname">dllname</code></td>
<td>
<p>a string giving the name of the shared library
(without extension) that contains all the compiled function or
subroutine definitions refered to in <code>func</code> and
<code>jacfunc</code>. See vignette <code>"compiledCode"</code>
from package <code>deSolve</code>.
</p>
</td></tr>
<tr><td><code id="radau_+3A_initfunc">initfunc</code></td>
<td>
<p>if not <code>NULL</code>, the name of the initialisation function
(which initialises values of parameters), as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. See vignette <code>"compiledCode"</code>
from package <code>deSolve</code>.
</p>
</td></tr>
<tr><td><code id="radau_+3A_initpar">initpar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified and an
initialisation function <code>initfunc</code> is in the dll: the
parameters passed to the initialiser, to initialise the common
blocks (FORTRAN) or global variables (C, C++).
</p>
</td></tr>
<tr><td><code id="radau_+3A_rpar">rpar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with
double precision values passed to the dll-functions whose names are
specified by <code>func</code> and <code>jacfunc</code>.
</p>
</td></tr>
<tr><td><code id="radau_+3A_ipar">ipar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with
integer values passed to the dll-functions whose names are specified
by <code>func</code> and <code>jacfunc</code>.
</p>
</td></tr>
<tr><td><code id="radau_+3A_nout">nout</code></td>
<td>
<p>only used if <code>dllname</code> is specified and the model is
defined in compiled code: the number of output variables calculated
in the compiled function <code>func</code>, present in the shared
library. Note: it is not automatically checked whether this is
indeed the number of output variables calculed in the DLL - you have
to perform this check in the code - See vignette <code>"compiledCode"</code>
from package <code>deSolve</code>.
</p>
</td></tr>
<tr><td><code id="radau_+3A_outnames">outnames</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified and
<code>nout</code> &gt; 0: the names of output variables calculated in the
compiled function <code>func</code>, present in the shared library.
These names will be used to label the output matrix.
</p>
</td></tr>
<tr><td><code id="radau_+3A_forcings">forcings</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified: a list with
the forcing function data sets, each present as a two-columned matrix,
with (time, value); interpolation outside the interval
[min(<code>times</code>), max(<code>times</code>)] is done by taking the value at
the closest data extreme.
</p>
<p>See <a href="#topic+forcings">forcings</a> or package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="radau_+3A_initforc">initforc</code></td>
<td>
<p>if not <code>NULL</code>, the name of the forcing function
initialisation function, as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. It MUST be present if <code>forcings</code> has been given a
value.
See <a href="#topic+forcings">forcings</a> or package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="radau_+3A_fcontrol">fcontrol</code></td>
<td>
<p>A list of control parameters for the forcing functions.
See <a href="#topic+forcings">forcings</a> or vignette <code>compiledCode</code>.
</p>
</td></tr>
<tr><td><code id="radau_+3A_events">events</code></td>
<td>
<p>A matrix or data frame that specifies events, i.e. when the value of a
state variable is suddenly changed. See <a href="#topic+events">events</a> for more information.
</p>
</td></tr>
<tr><td><code id="radau_+3A_lags">lags</code></td>
<td>
<p>A list that specifies timelags, i.e. the number of steps
that has to be kept. To be used for delay differential equations.
See <a href="#topic+timelags">timelags</a>, <a href="#topic+dede">dede</a> for more information.
</p>
</td></tr>
<tr><td><code id="radau_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>func</code> and
<code>jacfunc</code> allowing this to be a generic function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The work is done by the FORTRAN subroutine <code>RADAU5</code>, whose
documentation should be consulted for details. The implementation
is based on the Fortran 77 version from January 18, 2002.
</p>
<p>There are four standard choices for the Jacobian which can be specified with
<code>jactype</code>.
</p>
<p>The options for <b>jactype</b> are
</p>

<dl>
<dt>jactype = &quot;fullint&quot;</dt><dd><p>a full Jacobian, calculated internally by
the solver.
</p>
</dd>
<dt>jactype = &quot;fullusr&quot;</dt><dd><p>a full Jacobian, specified by user
function <code>jacfunc</code>.
</p>
</dd>
<dt>jactype = &quot;bandusr&quot;</dt><dd><p>a banded Jacobian, specified by user
function <code>jacfunc</code>; the size of the bands specified by
<code>bandup</code> and <code>banddown</code>.
</p>
</dd>
<dt>jactype = &quot;bandint&quot;</dt><dd><p>a banded Jacobian, calculated by radau;
the size of the bands specified by <code>bandup</code> and
<code>banddown</code>.
</p>
</dd>
</dl>

<p>Inspection of the example below shows how to specify both a banded and
full Jacobian.
</p>
<p>The input parameters <code>rtol</code>, and <code>atol</code> determine the
<b>error control</b> performed by the solver, which roughly keeps the 
local error of <code class="reqn">y(i)</code> below <code class="reqn">rtol(i)*abs(y(i))+atol(i)</code>.  
</p>
<p>The diagnostics of the integration can be printed to screen
by calling <code><a href="#topic+diagnostics">diagnostics</a></code>. If <code>verbose</code> = <code>TRUE</code>,
the diagnostics will be written to the screen at the end of the integration.
</p>
<p>See vignette(&quot;deSolve&quot;) from the <code>deSolve</code> package for an 
explanation of each element in the vectors
containing the diagnostic properties and how to directly access them.
</p>
<p><b>Models</b> may be defined in compiled C or FORTRAN code, as well as
in an R-function. See package vignette <code>"compiledCode"</code> from package 
<code>deSolve</code> for details.
</p>
<p>Information about linking forcing functions to compiled code is in 
<a href="#topic+forcings">forcings</a> (from package <code>deSolve</code>).
</p>
<p><code>radau</code> can find the root of at least one of a set of constraint functions
<code>rootfunc</code> of the independent and dependent variables.  It then returns the
solution at the root if that occurs sooner than the specified stop
condition, and otherwise returns the solution according the specified
stop condition.
</p>
<p>Caution:  Because of numerical errors in the function
<code>rootfun</code> due to roundoff and integration error, <code>radau</code> may
return false roots, or return the same root at two or more
nearly equal values of <code>time</code>.
</p>


<h3>Value</h3>

<p>A matrix of class <code>deSolve</code> with up to as many rows as elements
in <code>times</code> and as many columns as elements in <code>y</code> plus the number of &quot;global&quot;
values returned in the next elements of the return from <code>func</code>,
plus and additional column for the time value.  There will be a row
for each element in <code>times</code> unless the FORTRAN routine 
returns with an unrecoverable error. If <code>y</code> has a names
attribute, it will be used to label the columns of the output value.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert 
</p>


<h3>References</h3>

<p>E. Hairer and G. Wanner, 1996. Solving Ordinary Differential Equations II.
Stiff and Differential-algebraic problems. Springer series in computational
mathematics 14, Springer-Verlag, second edition.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+ode">ode</a></code> for a general interface to most of the ODE solvers ,
</p>
</li>
<li> <p><code><a href="#topic+ode.1D">ode.1D</a></code> for integrating 1-D models,
</p>
</li>
<li> <p><code><a href="#topic+ode.2D">ode.2D</a></code> for integrating 2-D models,
</p>
</li>
<li> <p><code><a href="#topic+ode.3D">ode.3D</a></code> for integrating 3-D models,
</p>
</li>
<li> <p><code><a href="#topic+daspk">daspk</a></code> for integrating DAE models up to index 1
</p>
</li></ul>

<p><code><a href="#topic+diagnostics">diagnostics</a></code> to print diagnostic messages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =======================================================================
## Example 1: ODE
##   Various ways to solve the same model.
## =======================================================================

## the model, 5 state variables
f1 &lt;- function  (t, y, parms) {
  ydot &lt;- vector(len = 5)

  ydot[1] &lt;-  0.1*y[1] -0.2*y[2]
  ydot[2] &lt;- -0.3*y[1] +0.1*y[2] -0.2*y[3]
  ydot[3] &lt;-           -0.3*y[2] +0.1*y[3] -0.2*y[4]
  ydot[4] &lt;-                     -0.3*y[3] +0.1*y[4] -0.2*y[5]
  ydot[5] &lt;-                               -0.3*y[4] +0.1*y[5]

  return(list(ydot))
}

## the Jacobian, written as a full matrix
fulljac &lt;- function  (t, y, parms) {
  jac &lt;- matrix(nrow = 5, ncol = 5, byrow = TRUE,
                data = c(0.1, -0.2,  0  ,  0  ,  0  ,
                        -0.3,  0.1, -0.2,  0  ,  0  ,
                         0  , -0.3,  0.1, -0.2,  0  ,
                         0  ,  0  , -0.3,  0.1, -0.2,
                         0  ,  0  ,  0  , -0.3,  0.1))
  return(jac)
}

## the Jacobian, written in banded form
bandjac &lt;- function  (t, y, parms) {
  jac &lt;- matrix(nrow = 3, ncol = 5, byrow = TRUE,
                data = c( 0  , -0.2, -0.2, -0.2, -0.2,
                          0.1,  0.1,  0.1,  0.1,  0.1,
                         -0.3, -0.3, -0.3, -0.3,    0))
  return(jac)
}

## initial conditions and output times
yini  &lt;- 1:5
times &lt;- 1:20

## default: stiff method, internally generated, full Jacobian
out   &lt;- radau(yini, times, f1, parms = 0)
plot(out)

## stiff method, user-generated full Jacobian
out2  &lt;- radau(yini, times, f1, parms = 0, jactype = "fullusr",
               jacfunc = fulljac)

## stiff method, internally-generated banded Jacobian
## one nonzero band above (up) and below(down) the diagonal
out3  &lt;- radau(yini, times, f1, parms = 0, jactype = "bandint",
               bandup = 1, banddown = 1)

## stiff method, user-generated banded Jacobian
out4  &lt;- radau(yini, times, f1, parms = 0, jactype = "bandusr",
               jacfunc = bandjac, bandup = 1, banddown = 1)


## =======================================================================
## Example 2: ODE
##   stiff problem from chemical kinetics
## =======================================================================
Chemistry &lt;- function (t, y, p) {
  dy1 &lt;- -.04*y[1] + 1.e4*y[2]*y[3]
  dy2 &lt;- .04*y[1] - 1.e4*y[2]*y[3] - 3.e7*y[2]^2
  dy3 &lt;- 3.e7*y[2]^2
  list(c(dy1, dy2, dy3))
}

times &lt;- 10^(seq(0, 10, by = 0.1))
yini &lt;- c(y1 = 1.0, y2 = 0, y3 = 0)

out &lt;- radau(func = Chemistry, times = times, y = yini, parms = NULL)
plot(out, log = "x", type = "l", lwd = 2)

## =============================================================================
## Example 3: DAE
## Car axis problem, index 3 DAE, 8 differential, 2 algebraic equations
## from
## F. Mazzia and C. Magherini. Test Set for Initial Value Problem Solvers,
## release 2.4. Department
## of Mathematics, University of Bari and INdAM, Research Unit of Bari,
## February 2008.
## Available from https://archimede.uniba.it/~testset/
## =============================================================================

## Problem is written as M*y' = f(t,y,p).
## caraxisfun implements the right-hand side:

caraxisfun &lt;- function(t, y, parms) {
  with(as.list(y), {
  
    yb &lt;- r * sin(w * t)
    xb &lt;- sqrt(L * L - yb * yb)
    Ll &lt;- sqrt(xl^2 + yl^2)
    Lr &lt;- sqrt((xr - xb)^2 + (yr - yb)^2)
        
    dxl &lt;- ul; dyl &lt;- vl; dxr &lt;- ur; dyr &lt;- vr
        
    dul  &lt;- (L0-Ll) * xl/Ll      + 2 * lam2 * (xl-xr) + lam1*xb
    dvl  &lt;- (L0-Ll) * yl/Ll      + 2 * lam2 * (yl-yr) + lam1*yb - k * g
               
    dur  &lt;- (L0-Lr) * (xr-xb)/Lr - 2 * lam2 * (xl-xr)
    dvr  &lt;- (L0-Lr) * (yr-yb)/Lr - 2 * lam2 * (yl-yr) - k * g
        
    c1   &lt;- xb * xl + yb * yl
    c2   &lt;- (xl - xr)^2 + (yl - yr)^2 - L * L
        
    list(c(dxl, dyl, dxr, dyr, dul, dvl, dur, dvr, c1, c2))
  })
}

eps &lt;- 0.01; M &lt;- 10; k &lt;- M * eps^2/2; 
L &lt;- 1; L0 &lt;- 0.5; r &lt;- 0.1; w &lt;- 10; g &lt;- 1

yini &lt;- c(xl = 0, yl = L0, xr = L, yr = L0,
          ul = -L0/L, vl = 0,
          ur = -L0/L, vr = 0,
          lam1 = 0, lam2 = 0)

# the mass matrix
Mass      &lt;- diag(nrow = 10, 1)
Mass[5,5] &lt;- Mass[6,6] &lt;- Mass[7,7] &lt;- Mass[8,8] &lt;- M * eps * eps/2
Mass[9,9] &lt;- Mass[10,10] &lt;- 0
Mass

# index of the variables: 4 of index 1, 4 of index 2, 2 of index 3
index &lt;- c(4, 4, 2)

times &lt;- seq(0, 3, by = 0.01)
out &lt;- radau(y = yini, mass = Mass, times = times, func = caraxisfun,
        parms = NULL, nind = index)

plot(out, which = 1:4, type = "l", lwd = 2)
</code></pre>

<hr>
<h2 id='rk'>Explicit One-Step Solvers for Ordinary Differential Equations
(ODE)</h2><span id='topic+rk'></span>

<h3>Description</h3>

<p>Solving initial value problems for non-stiff systems of
first-order ordinary differential equations (ODEs).
</p>
<p>The <span class="rlang"><b>R</b></span> function <code>rk</code> is a top-level function that provides
interfaces to a collection of common explicit one-step solvers of the
Runge-Kutta family with fixed or variable time steps.
</p>
<p>The system of ODE's is written as an <span class="rlang"><b>R</b></span> function (which may, of
course, use <code><a href="base.html#topic+.C">.C</a></code>, <code><a href="base.html#topic+.Fortran">.Fortran</a></code>,
<code><a href="base.html#topic+.Call">.Call</a></code>, etc., to call foreign code) or be defined in
compiled code that has been dynamically loaded.  A vector of
parameters is passed to the ODEs, so the solver may be used as part of
a modeling package for ODEs, or for parameter estimation using any
appropriate modeling tool for non-linear models in <span class="rlang"><b>R</b></span> such as
<code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="stats.html#topic+nls">nls</a></code>, <code><a href="stats.html#topic+nlm">nlm</a></code> or
<code><a href="nlme.html#topic+nlme">nlme</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rk(y, times, func, parms, rtol = 1e-6, atol = 1e-6,
  verbose = FALSE, tcrit = NULL, hmin = 0, hmax = NULL,
  hini = hmax, ynames = TRUE, method = rkMethod("rk45dp7", ... ),
  maxsteps = 5000, dllname = NULL, initfunc = dllname,
  initpar = parms, rpar = NULL, ipar = NULL,
  nout = 0, outnames = NULL, forcings = NULL,
  initforc = NULL, fcontrol = NULL, events = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rk_+3A_y">y</code></td>
<td>
<p>the initial (state) values for the ODE system. If <code>y</code>
has a name attribute, the names will be used to label the output
matrix.
</p>
</td></tr>
<tr><td><code id="rk_+3A_times">times</code></td>
<td>
<p>times at which explicit estimates for <code>y</code> are
desired.  The first value in <code>times</code> must be the initial time.
</p>
</td></tr>
<tr><td><code id="rk_+3A_func">func</code></td>
<td>
<p>either an <span class="rlang"><b>R</b></span>-function that computes the values of the
derivatives in the ODE system (the <em>model definition</em>) at time
t, or a character string giving the name of a compiled function in a
dynamically loaded shared library.
</p>
<p>If <code>func</code> is an <span class="rlang"><b>R</b></span>-function, it must be defined as:
<code>func &lt;- function(t, y, parms,...)</code>.  <code>t</code> is the current
time point in the integration, <code>y</code> is the current estimate of
the variables in the ODE system.  If the initial values <code>y</code> has
a <code>names</code> attribute, the names will be available inside <code>func</code>.
<code>parms</code> is a vector or list of parameters; ... (optional) are
any other arguments passed to the function.
</p>
<p>The return value of <code>func</code> should be a list, whose first
element is a vector containing the derivatives of <code>y</code> with
respect to <code>time</code>, and whose next elements are global values
that are required at each point in <code>times</code>.  The derivatives
must be specified in the <b>same order</b> as the state variables <code>y</code>.
</p>
<p>If <code>func</code> is
a string, then <code>dllname</code> must give the name of the shared
library (without extension) which must be loaded before
<code>rk</code> is called. See package vignette <code>"compiledCode"</code>
for more details.
</p>
</td></tr>
<tr><td><code id="rk_+3A_parms">parms</code></td>
<td>
<p>vector or list of parameters used in <code>func</code>.
</p>
</td></tr>
<tr><td><code id="rk_+3A_rtol">rtol</code></td>
<td>
<p>relative error tolerance, either a scalar or an array as
long as <code>y</code>. Only applicable to methods with variable time
step, see details.
</p>
</td></tr>
<tr><td><code id="rk_+3A_atol">atol</code></td>
<td>
<p>absolute error tolerance, either a scalar or an array as
long as <code>y</code>. Only applicable to methods with variable time
step, see details.
</p>
</td></tr>
<tr><td><code id="rk_+3A_tcrit">tcrit</code></td>
<td>
<p>if not <code>NULL</code>, then <code>rk</code> cannot integrate past
<code>tcrit</code>. This parameter is for compatibility with other solvers.
</p>
</td></tr>
<tr><td><code id="rk_+3A_verbose">verbose</code></td>
<td>
<p>a logical value that, when TRUE, triggers more
verbose output from the ODE solver.
</p>
</td></tr>
<tr><td><code id="rk_+3A_hmin">hmin</code></td>
<td>
<p>an optional minimum value of the integration stepsize. In
special situations this parameter may speed up computations with the
cost of precision. Don't use <code>hmin</code> if you don't know why!
</p>
</td></tr>
<tr><td><code id="rk_+3A_hmax">hmax</code></td>
<td>
<p>an optional maximum value of the integration stepsize. If
not specified, <code>hmax</code> is set to the maximum of <code>hini</code> and
the largest difference in <code>times</code>, to avoid that the simulation
possibly ignores short-term events.  If 0, no maximal size is
specified. Note that <code>hmin</code> and <code>hmax</code> are ignored by
fixed step methods like <code>"rk4"</code> or <code>"euler"</code>.
</p>
</td></tr>
<tr><td><code id="rk_+3A_hini">hini</code></td>
<td>
<p>initial step size to be attempted; if 0, the initial step
size is determined automatically by solvers with flexible time step.
For fixed step methods, setting <code>hini = 0</code> forces 
internal time steps identically to external time steps provided by
<code>times</code>. Similarly, internal time steps of non-interpolating
solvers cannot be bigger than external time steps specified in <code>times</code>.
</p>
</td></tr>
<tr><td><code id="rk_+3A_ynames">ynames</code></td>
<td>
<p>if <code>FALSE</code>: names of state variables are not passed
to function <code>func</code> ; this may speed up the simulation especially
for large models.
</p>
</td></tr>
<tr><td><code id="rk_+3A_method">method</code></td>
<td>
<p>the integrator to use. This can either be a string
constant naming one of the pre-defined methods or a call to function
<code><a href="#topic+rkMethod">rkMethod</a></code> specifying a user-defined method.  The most
common methods are the fixed-step methods <code>"euler"</code>, second and
fourth-order Runge Kutta (<code>"rk2"</code>, <code>"rk4"</code>), or the
variable step methods Bogacki-Shampine <code>"rk23bs"</code>,
Runge-Kutta-Fehlberg <code>"rk34f"</code>, the fifth-order Cash-Karp
method <code>"rk45ck"</code> or the fifth-order Dormand-Prince method with
seven stages <code>"rk45dp7"</code>.
As a suggestion, one may use <code>"rk23bs"</code> (alias <code>"ode23"</code>) for
simple problems and <code>"rk45dp7"</code> (alias <code>"ode45"</code>) for
rough problems.
</p>
</td></tr>
<tr><td><code id="rk_+3A_maxsteps">maxsteps</code></td>
<td>
<p>average maximal number of steps per output interval
taken by the solver. This argument is defined such as to ensure
compatibility with the Livermore-solvers. <code>rk</code> only accepts the maximal
number of steps for the entire integration. It is calculated 
as <code>max(length(times) * maxsteps, max(diff(times)/hini + 1)</code>.
</p>
</td></tr>
<tr><td><code id="rk_+3A_dllname">dllname</code></td>
<td>
<p>a string giving the name of the shared library
(without extension) that contains all the compiled function or
subroutine definitions refered to in <code>func</code> and
<code>jacfunc</code>. See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="rk_+3A_initfunc">initfunc</code></td>
<td>
<p>if not <code>NULL</code>, the name of the initialisation function
(which initialises values of parameters), as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="rk_+3A_initpar">initpar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified and an
initialisation function <code>initfunc</code> is in the dll: the
parameters passed to the initialiser, to initialise the common
blocks (FORTRAN) or global variables (C, C++).
</p>
</td></tr>
<tr><td><code id="rk_+3A_rpar">rpar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with
double precision values passed to the dll-functions whose names are
specified by <code>func</code> and <code>jacfunc</code>.
</p>
</td></tr>
<tr><td><code id="rk_+3A_ipar">ipar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with
integer values passed to the dll-functions whose names are specified
by <code>func</code> and <code>jacfunc</code>.
</p>
</td></tr>
<tr><td><code id="rk_+3A_nout">nout</code></td>
<td>
<p>only used if <code>dllname</code> is specified and the model is
defined in compiled code: the number of output variables calculated
in the compiled function <code>func</code>, present in the shared
library. Note: it is not automatically checked whether this is
indeed the number of output variables calculated in the dll - you have
to perform this check in the code. See package vignette
<code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="rk_+3A_outnames">outnames</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified and
<code>nout</code> &gt; 0: the names of output variables calculated in the
compiled function <code>func</code>, present in the shared library.
</p>
</td></tr>
<tr><td><code id="rk_+3A_forcings">forcings</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified: a list with
the forcing function data sets, each present as a two-columned matrix,
with (time,value); interpolation outside the interval
[min(<code>times</code>), max(<code>times</code>)] is done by taking the value at
the closest data extreme.
</p>
<p>See <a href="#topic+forcings">forcings</a> or package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="rk_+3A_initforc">initforc</code></td>
<td>
<p>if not <code>NULL</code>, the name of the forcing function
initialisation function, as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. It MUST be present if <code>forcings</code> has been given a
value.
See <a href="#topic+forcings">forcings</a> or package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="rk_+3A_fcontrol">fcontrol</code></td>
<td>
<p>A list of control parameters for the forcing functions.
See <a href="#topic+forcings">forcings</a> or vignette <code>compiledCode</code>.
</p>
</td></tr>
<tr><td><code id="rk_+3A_events">events</code></td>
<td>
<p>A matrix or data frame that specifies events, i.e. when the value of a 
state variable is suddenly changed. See <a href="#topic+events">events</a> for more information.
Not also that if events are specified, then polynomial interpolation
is switched off and integration takes place from one external time step 
to the next, with an internal step size less than or equal the difference
of two adjacent points of <code>times</code>.
</p>
</td></tr>
<tr><td><code id="rk_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>func</code> allowing this
to be a generic function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>rk</code> is a generalized implementation that can be used to
evaluate different solvers of the Runge-Kutta family of explicit ODE
solvers. A pre-defined set of common method parameters is in function
<code><a href="#topic+rkMethod">rkMethod</a></code> which also allows to supply user-defined
Butcher tables.
</p>
<p>The input parameters <code>rtol</code>, and <code>atol</code> determine the error
control performed by the solver.  The solver will control the vector
of estimated local errors in <b>y</b>, according to an inequality of
the form max-norm of ( <b>e</b>/<b>ewt</b> ) <code class="reqn">\leq</code> 1, where
<b>ewt</b> is a vector of positive error weights.  The values of
<code>rtol</code> and <code>atol</code> should all be non-negative.  The form of
<b>ewt</b> is:
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{rtol} \times \mathrm{abs}(\mathbf{y}) +
  \mathbf{atol}</code>
</p>

<p>where multiplication of two vectors is element-by-element.
</p>
<p><b>Models</b> can be defined in <span class="rlang"><b>R</b></span> as a user-supplied
<b>R-function</b>, that must be called as: <code>yprime = func(t, y,
  parms)</code>.  <code>t</code> is the current time point in the integration,
<code>y</code> is the current estimate of the variables in the ODE system.
</p>
<p>The return value of <code>func</code> should be a list, whose first element
is a vector containing the derivatives of <code>y</code> with respect to
time, and whose second element contains output variables that are
required at each point in time. Examples are given below.  
</p>


<h3>Value</h3>

<p>A matrix of class <code>deSolve</code> with up to as many rows as elements
in <code>times</code> and as many columns as elements in <code>y</code> plus the
number of &quot;global&quot; values returned in the next elements of the return
from <code>func</code>, plus and additional column for the time value.
There will be a row for each element in <code>times</code> unless the
integration routine returns with an unrecoverable error. If <code>y</code>
has a names attribute, it will be used to label the columns of the
output value.
</p>


<h3>Note</h3>

  
<p>Arguments <code>rpar</code> and <code>ipar</code> are provided for compatibility
with <code>lsoda</code>.
</p>
<p>Starting with version 1.8 implicit Runge-Kutta methods are also
supported by this general <code>rk</code> interface, however their
implementation is still experimental.  Instead of this you may
consider <code><a href="#topic+radau">radau</a></code> for a specific full implementation of an
implicit Runge-Kutta method.
</p>


<h3>Author(s)</h3>

<p>Thomas Petzoldt <a href="mailto:thomas.petzoldt@tu-dresden.de">thomas.petzoldt@tu-dresden.de</a></p>


<h3>References</h3>

<p>Butcher, J. C. (1987) The numerical analysis of ordinary differential
equations, Runge-Kutta and general linear methods, Wiley, Chichester
and New York.
</p>
<p>Engeln-Muellges, G. and Reutter, F. (1996) Numerik Algorithmen:
Entscheidungshilfe zur Auswahl und Nutzung. VDI Verlag, Duesseldorf.
</p>
<p>Hindmarsh, Alan C. (1983) ODEPACK, A Systematized Collection of ODE
Solvers; in p.55&ndash;64 of Stepleman, R.W. et al.[ed.] (1983)
<em>Scientific Computing</em>, North-Holland, Amsterdam.
</p>
<p>Press, W. H., Teukolsky, S. A., Vetterling, W. T. and Flannery,
B. P. (2007) Numerical Recipes in C. Cambridge University Press.
</p>


<h3>See Also</h3>

  
<p>For most practical cases, solvers of the Livermore family (i.e. the
ODEPACK solvers, see below) are superior. Some of them are also
suitable for stiff ODEs, differential algebraic equations (DAEs), or
partial differential equations (PDEs).
</p>

<ul>
<li> <p><code><a href="#topic+rkMethod">rkMethod</a></code> for a list of available Runge-Kutta
parameter sets,
</p>
</li>
<li> <p><code><a href="#topic+rk4">rk4</a></code> and <code><a href="#topic+euler">euler</a></code> for special
versions without interpolation (and less overhead),
</p>
</li>
<li> <p><code><a href="#topic+lsoda">lsoda</a></code>, <code><a href="#topic+lsode">lsode</a></code>,
<code><a href="#topic+lsodes">lsodes</a></code>, <code><a href="#topic+lsodar">lsodar</a></code>, <code><a href="#topic+vode">vode</a></code>,
<code><a href="#topic+daspk">daspk</a></code> for solvers of the Livermore family,
</p>
</li>
<li> <p><code><a href="#topic+ode">ode</a></code> for a general interface to most of the ODE solvers,
</p>
</li>
<li> <p><code><a href="#topic+ode.band">ode.band</a></code> for solving models with a banded
Jacobian,
</p>
</li>
<li> <p><code><a href="#topic+ode.1D">ode.1D</a></code> for integrating 1-D models,
</p>
</li>
<li> <p><code><a href="#topic+ode.2D">ode.2D</a></code> for integrating 2-D models,
</p>
</li>
<li> <p><code><a href="#topic+ode.3D">ode.3D</a></code> for integrating 3-D models,
</p>
</li>
<li> <p><code><a href="#topic+diagnostics">diagnostics</a></code> to print diagnostic messages.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## =======================================================================
## Example: Resource-producer-consumer Lotka-Volterra model
## =======================================================================

## Notes:
## - Parameters are a list, names accessible via "with" function
## - Function sigimp passed as an argument (input) to model
##  (see also ode and lsoda examples)

SPCmod &lt;- function(t, x, parms, input)  {
  with(as.list(c(parms, x)), {
    import &lt;- input(t)
    dS &lt;- import - b*S*P + g*C    # substrate
    dP &lt;- c*S*P  - d*C*P          # producer
    dC &lt;- e*P*C  - f*C            # consumer
    res &lt;- c(dS, dP, dC)
    list(res)
  })
}

## The parameters 
parms &lt;- c(b = 0.001, c = 0.1, d = 0.1, e = 0.1, f = 0.1, g = 0.0)

## vector of timesteps
times &lt;- seq(0, 200, length = 101)

## external signal with rectangle impulse
signal &lt;- data.frame(times = times,
                     import = rep(0, length(times)))

signal$import[signal$times &gt;= 10 &amp; signal$times &lt;= 11] &lt;- 0.2

sigimp &lt;- approxfun(signal$times, signal$import, rule = 2)

## Start values for steady state
xstart &lt;- c(S = 1, P = 1, C = 1)

## Euler method
out1  &lt;- rk(xstart, times, SPCmod, parms, hini = 0.1, 
            input = sigimp, method = "euler")

## classical Runge-Kutta 4th order
out2 &lt;- rk(xstart, times, SPCmod, parms, hini = 1, 
           input = sigimp, method = "rk4")

## Dormand-Prince method of order 5(4)
out3 &lt;- rk(xstart, times, SPCmod, parms, hmax = 1, 
           input = sigimp, method = "rk45dp7")

mf &lt;- par("mfrow")
## deSolve plot method for comparing scenarios
plot(out1, out2, out3, which = c("S", "P", "C"), 
     main = c ("Substrate", "Producer", "Consumer"),
     col =c("black", "red", "green"), 
     lty = c("solid", "dotted", "dotted"), lwd = c(1, 2, 1))

## user-specified plot function
plot (out1[,"P"], out1[,"C"], type = "l", xlab = "Producer", ylab = "Consumer")
lines(out2[,"P"], out2[,"C"], col = "red",   lty = "dotted", lwd = 2)
lines(out3[,"P"], out3[,"C"], col = "green", lty = "dotted")

legend("center", legend = c("euler", "rk4", "rk45dp7"),
  lty = c(1, 3, 3), lwd = c(1, 2, 1),
  col = c("black", "red", "green"))
par(mfrow = mf)
</code></pre>

<hr>
<h2 id='rk4'>Solve System of ODE (Ordinary Differential Equation)s by
Euler's Method or Classical Runge-Kutta 4th Order Integration.
</h2><span id='topic+rk4'></span><span id='topic+euler'></span><span id='topic+euler.1D'></span>

<h3>Description</h3>

<p>Solving initial value problems for systems of first-order
ordinary differential equations (ODEs) using Euler's method or the
classical Runge-Kutta 4th order integration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euler(y, times, func, parms, verbose = FALSE, ynames = TRUE,
  dllname = NULL, initfunc = dllname, initpar = parms,
  rpar = NULL, ipar = NULL, nout = 0, outnames = NULL,
  forcings = NULL, initforc = NULL, fcontrol = NULL, ...)

rk4(y, times, func, parms, verbose = FALSE, ynames = TRUE,
  dllname = NULL, initfunc = dllname, initpar = parms,
  rpar = NULL, ipar = NULL, nout = 0, outnames = NULL,
  forcings = NULL, initforc = NULL, fcontrol = NULL, ...)

euler.1D(y, times, func, parms, nspec = NULL, dimens = NULL,
  names = NULL, verbose = FALSE, ynames = TRUE,
  dllname = NULL, initfunc = dllname, initpar = parms,
  rpar = NULL,  ipar = NULL, nout = 0, outnames = NULL,
  forcings = NULL, initforc = NULL, fcontrol = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rk4_+3A_y">y</code></td>
<td>
<p>the initial (state) values for the ODE system. If <code>y</code>
has a name attribute, the names will be used to label the output
matrix.
</p>
</td></tr>
<tr><td><code id="rk4_+3A_times">times</code></td>
<td>
<p>times at which explicit estimates for <code>y</code> are
desired.  The first value in <code>times</code> must be the initial time.
</p>
</td></tr>
<tr><td><code id="rk4_+3A_func">func</code></td>
<td>
<p>either an <span class="rlang"><b>R</b></span>-function that computes the values of the
derivatives in the ODE system (the <em>model definition</em>) at time
t, or a character string giving the name of a compiled function in a
dynamically loaded shared library.
</p>
<p>If <code>func</code> is an <span class="rlang"><b>R</b></span>-function, it must be defined as:
<code>func &lt;- function(t, y, parms,...)</code>.  <code>t</code> is the current
time point in the integration, <code>y</code> is the current estimate of
the variables in the ODE system.  If the initial values <code>y</code> has
a <code>names</code> attribute, the names will be available inside <code>func</code>.
<code>parms</code> is a vector or list of parameters; ... (optional) are
any other arguments passed to the function.
</p>
<p>The return value of <code>func</code> should be a list, whose first
element is a vector containing the derivatives of <code>y</code> with
respect to <code>time</code>, and whose next elements are global values
that are required at each point in <code>times</code>.  The derivatives
must be specified in the <b>same order</b> as the state variables <code>y</code>.
</p>
<p>If <code>func</code> is a string, then <code>dllname</code> must give the name
of the shared library (without extension) which must be loaded
before <code>rk4</code> is called. See package vignette
<code>"compiledCode"</code> for more details.
</p>
</td></tr>
<tr><td><code id="rk4_+3A_parms">parms</code></td>
<td>
<p>vector or list of parameters used in <code>func</code>.
</p>
</td></tr>
<tr><td><code id="rk4_+3A_nspec">nspec</code></td>
<td>
<p>for 1D models only: the number of <b>species</b> (components)
in the model. If <code>NULL</code>, then <code>dimens</code> should be specified.
</p>
</td></tr>
<tr><td><code id="rk4_+3A_dimens">dimens</code></td>
<td>
<p>for 1D models only: the number of <b>boxes</b> in the
model. If <code>NULL</code>, then <code>nspec</code> should be specified.
</p>
</td></tr>
<tr><td><code id="rk4_+3A_names">names</code></td>
<td>
<p>for 1D models only: the names of the components; used
for plotting.
</p>
</td></tr>
<tr><td><code id="rk4_+3A_verbose">verbose</code></td>
<td>
<p>a logical value that, when <code>TRUE</code>, triggers more
verbose output from the ODE solver.
</p>
</td></tr>
<tr><td><code id="rk4_+3A_ynames">ynames</code></td>
<td>
<p>if <code>FALSE</code>: names of state variables are not passed
to function <code>func</code> ; this may speed up the simulation especially
for large models.
</p>
</td></tr>
<tr><td><code id="rk4_+3A_dllname">dllname</code></td>
<td>
<p>a string giving the name of the shared library
(without extension) that contains all the compiled function or
subroutine definitions refered to in <code>func</code>.
See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="rk4_+3A_initfunc">initfunc</code></td>
<td>
<p>if not <code>NULL</code>, the name of the initialisation function
(which initialises values of parameters), as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. See package vignette <code>"compiledCode"</code>,
</p>
</td></tr>
<tr><td><code id="rk4_+3A_initpar">initpar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified and an
initialisation function <code>initfunc</code> is in the DLL: the
parameters passed to the initialiser, to initialise the common
blocks (FORTRAN) or global variables (C, C++).
</p>
</td></tr>
<tr><td><code id="rk4_+3A_rpar">rpar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with
double precision values passed to the DLL-functions whose names are
specified by <code>func</code> and <code>jacfunc</code>.
</p>
</td></tr>
<tr><td><code id="rk4_+3A_ipar">ipar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with
integer values passed to the dll-functions whose names are specified
by <code>func</code> and <code>jacfunc</code>.
</p>
</td></tr>
<tr><td><code id="rk4_+3A_nout">nout</code></td>
<td>
<p>only used if <code>dllname</code> is specified and the model is
defined in compiled code: the number of output variables calculated
in the compiled function <code>func</code>, present in the shared
library. Note: it is not automatically checked whether this is
indeed the number of output variables calculated in the DLL - you have
to perform this check in the code. See package vignette
<code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="rk4_+3A_outnames">outnames</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified and
<code>nout</code> &gt; 0: the names of output variables calculated in the
compiled function <code>func</code>, present in the shared library.
</p>
</td></tr>
<tr><td><code id="rk4_+3A_forcings">forcings</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified: a list with
the forcing function data sets, each present as a two-columned matrix,
with (time, value); interpolation outside the interval
[min(<code>times</code>), max(<code>times</code>)] is done by taking the value at
the closest data extreme.
</p>
<p>See <a href="#topic+forcings">forcings</a> or package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="rk4_+3A_initforc">initforc</code></td>
<td>
<p>if not <code>NULL</code>, the name of the forcing function
initialisation function, as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. It MUST be present if <code>forcings</code> has been given a
value.
See <a href="#topic+forcings">forcings</a> or package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="rk4_+3A_fcontrol">fcontrol</code></td>
<td>
<p>A list of control parameters for the forcing functions.
See <a href="#topic+forcings">forcings</a> or vignette <code>compiledCode</code>.
</p>
</td></tr>
<tr><td><code id="rk4_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>func</code> allowing this
to be a generic function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rk4</code> and <code>euler</code> are special versions of the two fixed step
solvers with less overhead and less functionality (e.g. no interpolation
and no events) compared to the generic Runge-Kutta codes called by 
<code><a href="#topic+ode">ode</a></code> resp. <code><a href="#topic+rk">rk</a></code>.
</p>
<p>If you need different internal and external time steps or want to use events, 
please use:
<code>rk(y, times, func, parms, method = "rk4")</code> or
<code>rk(y, times, func, parms, method = "euler")</code>.
</p>
<p>See help pages of <code><a href="#topic+rk">rk</a></code> and <code><a href="#topic+rkMethod">rkMethod</a></code>
for details.
</p>
<p>Function <code>euler.1D</code> essentially calls function <code>euler</code> but
contains additional code to support plotting of 1D models, see
<code><a href="#topic+ode.1D">ode.1D</a></code> and <code><a href="#topic+plot.1D">plot.1D</a></code> for details.
</p>


<h3>Value</h3>

<p>A matrix of class <code>deSolve</code> with up to as many rows as elements
in <code>times</code> and as many columns as elements in <code>y</code> plus the
number of &quot;global&quot; values returned in the next elements of the return
from <code>func</code>, plus and additional column for the time value.
There will be a row for each element in <code>times</code> unless the
integration routine returns with an unrecoverable error. If <code>y</code>
has a names attribute, it will be used to label the columns of the
output value.
</p>


<h3>Note</h3>

<p>For most practical cases, solvers with flexible timestep
(e.g. <code>rk(method = "ode45")</code> and especially solvers of the
Livermore family (ODEPACK, e.g. <code><a href="#topic+lsoda">lsoda</a></code>) are superior.
</p>


<h3>Author(s)</h3>

<p>Thomas Petzoldt <a href="mailto:thomas.petzoldt@tu-dresden.de">thomas.petzoldt@tu-dresden.de</a></p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+rkMethod">rkMethod</a></code> for a list of available Runge-Kutta
parameter sets,
</p>
</li>
<li> <p><code><a href="#topic+rk">rk</a></code> for the more general Runge-Code,
</p>
</li>
<li> <p><code><a href="#topic+lsoda">lsoda</a></code>, <code><a href="#topic+lsode">lsode</a></code>,
<code><a href="#topic+lsodes">lsodes</a></code>, <code><a href="#topic+lsodar">lsodar</a></code>, <code><a href="#topic+vode">vode</a></code>,
<code><a href="#topic+daspk">daspk</a></code> for solvers of the Livermore family,
</p>
</li>
<li> <p><code><a href="#topic+ode">ode</a></code> for a general interface to most of the ODE solvers,
</p>
</li>
<li> <p><code><a href="#topic+ode.band">ode.band</a></code> for solving models with a banded
Jacobian,
</p>
</li>
<li> <p><code><a href="#topic+ode.1D">ode.1D</a></code> for integrating 1-D models,
</p>
</li>
<li> <p><code><a href="#topic+ode.2D">ode.2D</a></code> for integrating 2-D models,
</p>
</li>
<li> <p><code><a href="#topic+ode.3D">ode.3D</a></code> for integrating 3-D models,
</p>
</li>
<li> <p><code><a href="#topic+dede">dede</a></code> for integrating models with delay
differential equations,
</p>
</li></ul>

<p><code><a href="#topic+diagnostics">diagnostics</a></code> to print diagnostic messages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =======================================================================
## Example: Analytical and numerical solutions of logistic growth
## =======================================================================

## the derivative of the logistic
logist &lt;- function(t, x, parms) {
  with(as.list(parms), {
    dx &lt;- r * x[1] * (1 - x[1]/K)
    list(dx)
  })
}

time  &lt;- 0:100
N0    &lt;- 0.1; r &lt;- 0.5; K &lt;- 100
parms &lt;- c(r = r, K = K)
x &lt;- c(N = N0)

## analytical solution
plot(time, K/(1 + (K/N0-1) * exp(-r*time)), ylim = c(0, 120),
  type = "l", col = "red", lwd = 2)

## reasonable numerical solution with rk4
time &lt;- seq(0, 100, 2)
out &lt;- as.data.frame(rk4(x, time, logist, parms))
points(out$time, out$N, pch = 16, col = "blue", cex = 0.5)

## same time step with euler, systematic under-estimation
time &lt;- seq(0, 100, 2)
out &lt;- as.data.frame(euler(x, time, logist, parms))
points(out$time, out$N, pch = 1)

## unstable result
time &lt;- seq(0, 100, 4)
out &lt;- as.data.frame(euler(x, time, logist, parms))
points(out$time, out$N, pch = 8, cex = 0.5)

## method with automatic time step
out &lt;- as.data.frame(lsoda(x, time, logist, parms))
points(out$time, out$N, pch = 1, col = "green")

legend("bottomright",
  c("analytical","rk4, h=2", "euler, h=2",
    "euler, h=4", "lsoda"),
  lty = c(1, NA, NA, NA, NA), lwd = c(2, 1, 1, 1, 1),
  pch = c(NA, 16, 1, 8, 1),
  col = c("red", "blue", "black", "black", "green"))
</code></pre>

<hr>
<h2 id='rkMethod'>Collection of Parameter Sets (Butcher Arrays) for
the Runge-Kutta Family of ODE Solvers
</h2><span id='topic+rkMethod'></span>

<h3>Description</h3>

<p>This function returns a list specifying coefficients and properties of
ODE solver methods from the Runge-Kutta family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rkMethod(method = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rkMethod_+3A_method">method</code></td>
<td>
<p>a string constant naming one of the pre-defined methods
of the Runge-Kutta family of solvers.  The most common methods are
the fixed-step methods <code>"euler"</code>, <code>"rk2"</code>, <code>"rk4"</code> or
the variable step methods <code>"rk23bs"</code> (alias <code>"ode23"</code>),
<code>"rk45dp7"</code> (alias <code>"ode45"</code>) or <code>"rk78f"</code>.
</p>
</td></tr>
<tr><td><code id="rkMethod_+3A_...">...</code></td>
<td>
<p>specification of a user-defined solver, see <em>Value</em>
and example below.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function supplies <code>method</code> settings for <code><a href="#topic+rk">rk</a></code> or
<code><a href="#topic+ode">ode</a></code>. If called without arguments, the names of all
currently implemented solvers of the Runge-Kutta family are returned.
</p>
<p>The following comparison gives an idea how the algorithms of <span class="pkg">deSolve</span>
are related to similar algorithms of other simulation languages:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <b>rkMethod</b>    </td><td style="text-align: left;"> | </td><td style="text-align: left;"> <b>Description</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
    "euler"            </td><td style="text-align: left;"> | </td><td style="text-align: left;"> Euler's Method</td>
</tr>
<tr>
 <td style="text-align: left;">
    "rk2"              </td><td style="text-align: left;"> | </td><td style="text-align: left;"> 2nd order Runge-Kutta, fixed time step (Heun's method)</td>
</tr>
<tr>
 <td style="text-align: left;">
    "rk4"              </td><td style="text-align: left;"> | </td><td style="text-align: left;"> classical 4th order Runge-Kutta, fixed time step</td>
</tr>
<tr>
 <td style="text-align: left;">
    "rk23"             </td><td style="text-align: left;"> | </td><td style="text-align: left;"> Runge-Kutta, order 2(3); Octave: ode23</td>
</tr>
<tr>
 <td style="text-align: left;">
    "rk23bs", "ode23"  </td><td style="text-align: left;"> | </td><td style="text-align: left;"> Bogacki-Shampine, order 2(3); Matlab: ode23</td>
</tr>
<tr>
 <td style="text-align: left;">
    "rk34f"            </td><td style="text-align: left;"> | </td><td style="text-align: left;"> Runge-Kutta-Fehlberg, order 3(4)</td>
</tr>
<tr>
 <td style="text-align: left;">
    "rk45ck"           </td><td style="text-align: left;"> | </td><td style="text-align: left;"> Runge-Kutta Cash-Karp, order 4(5)</td>
</tr>
<tr>
 <td style="text-align: left;">
    "rk45f"            </td><td style="text-align: left;"> | </td><td style="text-align: left;"> Runge-Kutta-Fehlberg, order 4(5); Octave: ode45, pair=1 </td>
</tr>
<tr>
 <td style="text-align: left;">
    "rk45e"            </td><td style="text-align: left;"> | </td><td style="text-align: left;"> Runge-Kutta-England, order 4(5)</td>
</tr>
<tr>
 <td style="text-align: left;">
    "rk45dp6"          </td><td style="text-align: left;"> | </td><td style="text-align: left;"> Dormand-Prince, order 4(5), local order 6</td>
</tr>
<tr>
 <td style="text-align: left;">
    "rk45dp7", "ode45" </td><td style="text-align: left;"> | </td><td style="text-align: left;"> Dormand-Prince 4(5), local order 7 </td>
</tr>
<tr>
 <td style="text-align: left;">
                       </td><td style="text-align: left;"> | </td><td style="text-align: left;"> (also known as dopri5; MATLAB: ode45; Octave: ode45, pair=0)</td>
</tr>
<tr>
 <td style="text-align: left;">
    "rk78f"            </td><td style="text-align: left;"> | </td><td style="text-align: left;"> Runge-Kutta-Fehlberg, order 7(8)</td>
</tr>
<tr>
 <td style="text-align: left;">
    "rk78dp"           </td><td style="text-align: left;"> | </td><td style="text-align: left;"> Dormand-Prince, order 7(8)</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>Note that this table is based on the Runge-Kutta coefficients only,
but the algorithms differ also in their implementation, in their
stepsize adaption strategy and interpolation methods.
</p>
<p>The table reflects the state at time of writing and it is of course possible
that implementations change.
</p>
<p>Methods <code>"rk45dp7"</code> (alias <code>"ode45"</code>) and <code>"rk45ck"</code> contain
specific and efficient built-in interpolation schemes (dense output).
</p>
<p>As an alternative, Neville-Aitken polynomials can be used to interpolate between
time steps. This is available for all RK methods and may be useful to speed
up computation if no dense-output formula is available. Note however, that
this can introduce considerable local error; it is disabled by default
(see <code>nknots</code> below).
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>ID</code></td>
<td>
<p>name of the method (character)</p>
</td></tr>
<tr><td><code>varstep</code></td>
<td>
<p>boolean value specifying if the method allows for
variable time step (<code>TRUE</code>) or not (<code>FALSE</code>).
</p>
</td></tr>
<tr><td><code>FSAL</code></td>
<td>
<p>(first same as last) optional boolean value specifying if
the method allows re-use of the last function evaluation
(<code>TRUE</code>) or not (<code>FALSE</code> or <code>NULL</code>).
</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>coefficient matrix of the method. As <code>link{rk}</code> supports
only explicit methods, this matrix must be lower triangular.
<code>A</code> must be a vector for fixed step methods where only the
subdiagonal values are different from zero.
</p>
</td></tr>
<tr><td><code>b1</code></td>
<td>
<p>coefficients of the lower order Runge-Kutta pair.
</p>
</td></tr>
<tr><td><code>b2</code></td>
<td>
<p>coefficients of the higher order Runge-Kutta pair
(optional, for embedded methods that allow variable time step).
</p>
</td></tr>
<tr><td><code>c</code></td>
<td>
<p>coefficients for calculating the intermediate time steps.</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>optional coefficients for built-in polynomial interpolation
of the outputs from internal steps (dense output), currently only
available for method <code>rk45dp7</code> (Dormand-Prince).
</p>
</td></tr>
<tr><td><code>densetype</code></td>
<td>
<p>optional integer value specifying the dense output formula;
currently only <code>densetype = 1</code> for <code>rk45dp7</code> (Dormand-Prince)
and <code>densetype = 2</code> for <code>rk45ck</code> (Cash-Karp) are supported.
Undefined values (e.g., <code>densetype = NULL</code>) disable dense output.
</p>
</td></tr>
<tr><td><code>stage</code></td>
<td>
<p>number of function evaluations needed (corresponds to
number of rows in A).
</p>
</td></tr>
<tr><td><code>Qerr</code></td>
<td>
<p>global error order of the method, important for automatic
time-step adjustment.
</p>
</td></tr>
<tr><td><code>nknots</code></td>
<td>
<p>integer value specifying the order of interpolation
polynomials for methods without dense output.  If <code>nknots</code> &lt; 2
(the default) then internal interpolation is switched off and
integration is performed step by step between external time steps.
</p>
<p>If <code>nknots</code> is between 3 and 8, Neville-Aitken polynomials
are used, which need at least <code>nknots + 1</code> internal time steps.
Interpolation may speed up integration but can lead to local
errors higher than the tolerance, especially if external and
internal time steps are very different.
</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>optional tuning parameter for stepsize
adjustment. If <code>alpha</code> is omitted, it is set to
<code class="reqn">1/Qerr - 0.75 beta</code>. The default value is
<code class="reqn">1/Qerr</code> (for <code>beta</code> = 0).</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>optional tuning parameter for stepsize adjustment. Typical
values are <code class="reqn">0</code> (default) or <code class="reqn">0.4/Qerr</code>.
</p>
</td></tr>
</table>


<h3>Note</h3>


<ul>
<li><p> Adaptive stepsize Runge-Kuttas are preferred if the solution
contains parts when the states change fast, and parts when not much
happens. They will take small steps over bumpy ground and long steps
over uninteresting terrain.
</p>
</li>
<li><p> As a suggestion, one may use <code>"rk23"</code> (alias
<code>"ode23"</code>) for simple problems and <code>"rk45dp7"</code> (alias
<code>"ode45"</code>) for rough problems. The default solver is
<code>"rk45dp7"</code> (alias &quot;ode45&quot;), because of its relatively high
order (4), re-use of the last intermediate steps (FSAL = first
same as last) and built-in polynomial interpolation (dense
output).
</p>
</li>
<li><p> Solver <code>"rk23bs"</code>, that supports also FSAL, may be useful for
slightly stiff systems if demands on precision are relatively low.
</p>
</li>
<li><p> Another good choice, assuring medium accuracy, is the Cash-Karp
Runge-Kutta method, <code>"rk45ck"</code>.
</p>
</li>
<li><p> Classical <code>"rk4"</code> is traditionally used in cases where an
adequate stepsize is known a-priori or if external forcing data
are provided for fixed time steps only and frequent interpolation
of external data needs to be avoided.
</p>
</li>
<li><p> Method <code>"rk45dp7"</code> (alias <code>"ode45"</code>) contains an
efficient built-in interpolation scheme (dense output) based on
intermediate function evaluations.
</p>
</li></ul>

<p>Starting with version 1.8 implicit Runge-Kutta (<code>irk</code>) methods
are also supported by the general <code>rk</code> interface, however their
implementation is still experimental.  Instead of this you may
consider <code><a href="#topic+radau">radau</a></code> for a specific full implementation of an
implicit Runge-Kutta method.
</p>


<h3>Author(s)</h3>

<p>Thomas Petzoldt <a href="mailto:thomas.petzoldt@tu-dresden.de">thomas.petzoldt@tu-dresden.de</a></p>


<h3>References</h3>

<p>Bogacki, P. and Shampine L.F. (1989) A 3(2) pair of Runge-Kutta
formulas, Appl. Math. Lett. <b>2</b>, 1&ndash;9.
</p>
<p>Butcher, J. C. (1987) The numerical analysis of ordinary differential
equations, Runge-Kutta and general linear methods, Wiley, Chichester
and New York.
</p>
<p>Cash, J. R. and Karp A. H., 1990. A variable order Runge-Kutta method
for initial value problems with rapidly varying right-hand sides,
ACM Transactions on Mathematical Software <b>16</b>, 201&ndash;222.
<a href="https://doi.org/10.1145/79505.79507">doi:10.1145/79505.79507</a>
</p>
<p>Dormand, J. R. and Prince, P. J. (1980) A family of embedded
Runge-Kutta formulae, J. Comput. Appl. Math. <b>6</b>(1), 19&ndash;26.
</p>
<p>Engeln-Muellges, G. and Reutter, F. (1996) Numerik Algorithmen:
Entscheidungshilfe zur Auswahl und Nutzung. VDI Verlag, Duesseldorf.
</p>
<p>Fehlberg, E. (1967) Klassische Runge-Kutta-Formeln fuenfter and
siebenter Ordnung mit Schrittweiten-Kontrolle, Computing
(Arch. Elektron. Rechnen) <b>4</b>, 93&ndash;106.
</p>
<p>Kutta, W. (1901) Beitrag zur naeherungsweisen Integration totaler
Differentialgleichungen, Z. Math. Phys. <b>46</b>, 435&ndash;453.
</p>
<p>Octave-Forge - Extra Packages for GNU Octave, Package OdePkg.
<a href="https://octave.sourceforge.io">https://octave.sourceforge.io</a>
</p>
<p>Prince, P. J.  and Dormand, J. R. (1981) High order embedded
Runge-Kutta formulae, J. Comput. Appl. Math. <b>7</b>(1), 67&ndash;75.
<a href="https://doi.org/10.1016/0771-050X%2881%2990010-3">doi:10.1016/0771-050X(81)90010-3</a>
</p>
<p>Runge, C. (1895) Ueber die numerische Aufloesung von
Differentialgleichungen, Math. Ann. <b>46</b>, 167&ndash;178.
</p>
<p>MATLAB (R) is a registed property of The Mathworks
Inc. <a href="https://www.mathworks.com/">https://www.mathworks.com/</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+rk">rk</a></code>, <code><a href="#topic+ode">ode</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>rkMethod()          # returns the names of all available methods
rkMethod("rk45dp7") # parameters of the Dormand-Prince 5(4) method
rkMethod("ode45")   # an alias for the same method

func &lt;- function(t, x, parms) {
  with(as.list(c(parms, x)),{
    dP  &lt;- a * P      - b * C * P
    dC  &lt;- b * P * C  - c * C
    res &lt;- c(dP, dC)
    list(res)
  })
}
times  &lt;- seq(0, 200, length = 101)
parms  &lt;- c(a = 0.1, b = 0.1, c = 0.1)
x &lt;- c(P = 2, C = 1)

## rk using ode45 as the default method
out &lt;- rk(x, times, func, parms)

## all methods can be called also from 'ode' by using rkMethod
out &lt;- ode(x, times, func, parms, method = rkMethod("rk4"))

## 'ode' has aliases for the most common RK methods
out &lt;- ode(x, times, func, parms, method = "ode45")

##===========================================================================
## Comparison of local error from different interpolation methods
##===========================================================================

## lsoda with lower tolerances (1e-10) used as reference
o0 &lt;- ode(x, times, func, parms, method = "lsoda", atol = 1e-10, rtol = 1e-10)

## rk45dp7 with hmax = 10 &gt; delta_t  = 2
o1 &lt;- ode(x, times, func, parms, method = rkMethod("rk45dp7"), hmax = 10)

## disable dense-output interpolation
## and use only Neville-Aitken polynomials instead
o2 &lt;- ode(x, times, func, parms,
  method = rkMethod("rk45dp7", densetype = NULL, nknots = 5), hmax = 10)

## stop and go: disable interpolation completely
## and integrate explicitly between external time steps
o3 &lt;- ode(x, times, func, parms,
  method = rkMethod("rk45dp7", densetype = NULL, nknots = 0, hmax=10))

## compare different interpolation methods with lsoda
mf &lt;- par("mfrow" = c(4, 1))
matplot(o1[,1], o1[,-1], type = "l", xlab = "Time", main = "State Variables",
  ylab = "P, C")
matplot(o0[,1], o0[,-1] - o1[,-1], type = "l", xlab = "Time", ylab = "Diff.",
  main="Difference between lsoda and ode45 with dense output")
abline(h = 0, col = "grey")
matplot(o0[,1], o0[,-1] - o2[,-1], type = "l", xlab = "Time", ylab = "Diff.",
  main="Difference between lsoda and ode45 with Neville-Aitken")
abline(h = 0, col = "grey")
matplot(o0[,1], o0[,-1] - o3[,-1], type = "l", xlab = "Time", ylab = "Diff.",
  main="Difference between lsoda and ode45 in 'stop and go' mode")
abline(h = 0, col = "grey")
par(mf)

##===========================================================================
## rkMethod allows to define user-specified Runge-Kutta methods
##===========================================================================
out &lt;- ode(x, times, func, parms,
          method = rkMethod(ID = "midpoint",
            varstep = FALSE,
            A      = c(0, 1/2),
            b1      = c(0, 1),
            c       = c(0, 1/2),
            stage   = 2,
            Qerr    = 1
          )
        )
plot(out)

## compare method diagnostics
times  &lt;- seq(0, 200, length = 10)
o1 &lt;- ode(x, times, func, parms, method = rkMethod("rk45ck"))
o2 &lt;- ode(x, times, func, parms, method = rkMethod("rk78dp"))
diagnostics(o1)
diagnostics(o2)

</code></pre>

<hr>
<h2 id='SCOC'>A Sediment Model of Oxygen Consumption</h2><span id='topic+SCOC'></span>

<h3>Description</h3>

<p>A model that describes oxygen consumption in a marine sediment.
</p>
<p>One state variable:
</p>

<ul>
<li><p> sedimentary organic carbon,
</p>
</li></ul>

<p>Organic carbon settles on the sediment surface (forcing function Flux)
and decays at a constant rate.
</p>
<p>The equation is simple:
</p>
<p style="text-align: center;"><code class="reqn">\frac{dC}{dt} = Flux - k C</code>
</p>

<p>This model is written in <code>FORTRAN</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SCOC(times, y = NULL, parms, Flux, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SCOC_+3A_times">times</code></td>
<td>
<p>time sequence for which output is wanted; the first value
of times must be the initial time,</p>
</td></tr>
<tr><td><code id="SCOC_+3A_y">y</code></td>
<td>
<p>the initial value of the state variable; if <code>NULL</code> it
will be estimated based on <code>Flux</code> and <code>parms</code>,</p>
</td></tr>
<tr><td><code id="SCOC_+3A_parms">parms</code></td>
<td>
<p>the model parameter, <code>k</code>,</p>
</td></tr>
<tr><td><code id="SCOC_+3A_flux">Flux</code></td>
<td>
<p>a data set with the organic carbon deposition rates, </p>
</td></tr>
<tr><td><code id="SCOC_+3A_...">...</code></td>
<td>
<p>any other parameters passed to the integrator <code>ode</code>
(which solves the model).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is implemented primarily to demonstrate the linking of
FORTRAN with <span class="rlang"><b>R</b></span>-code.
</p>
<p>The source can be found in the &lsquo;<span class="file">doc/examples/dynload</span>&rsquo;
subdirectory of the package.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>References</h3>

<p>Soetaert, K. and P.M.J. Herman, 2009. A Practical Guide to Ecological
Modelling. Using <span class="rlang"><b>R</b></span> as a Simulation Platform.  Springer, 372 pp.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ccl4model">ccl4model</a></code>, the CCl4 inhalation model.
</p>
<p><code><a href="#topic+aquaphy">aquaphy</a></code>, the algal growth model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Forcing function data
Flux &lt;- matrix(ncol = 2, byrow = TRUE, data = c(
  1, 0.654, 11, 0.167,   21, 0.060, 41, 0.070, 73,0.277, 83,0.186,
  93,0.140,103, 0.255,  113, 0.231,123, 0.309,133,1.127,143,1.923,
  153,1.091,163,1.001,  173, 1.691,183, 1.404,194,1.226,204,0.767,
  214, 0.893,224,0.737, 234,0.772,244, 0.726,254,0.624,264,0.439,
  274,0.168,284 ,0.280, 294,0.202,304, 0.193,315,0.286,325,0.599,
  335, 1.889,345, 0.996,355,0.681,365,1.135))

parms &lt;- c(k = 0.01)

times &lt;- 1:365
out &lt;- SCOC(times, parms = parms, Flux = Flux)

plot(out[,"time"], out[,"Depo"], type = "l", col = "red")
lines(out[,"time"], out[,"Mineralisation"], col = "blue")

## Constant interpolation of forcing function - left side of interval
fcontrol &lt;- list(method = "constant")

out2 &lt;- SCOC(times, parms = parms, Flux = Flux, fcontrol = fcontrol)

plot(out2[,"time"], out2[,"Depo"], type = "l",col = "red")
lines(out2[,"time"], out2[,"Mineralisation"], col = "blue")
</code></pre>

<hr>
<h2 id='timelags'>
Time Lagged Values of State Variables and Derivatives.
</h2><span id='topic+timelags'></span><span id='topic+lagvalue'></span><span id='topic+lagderiv'></span>

<h3>Description</h3>

<p>Functions <code>lagvalue</code> and <code>lagderiv</code> provide access to past
(lagged) values of state variables and derivatives.
</p>
<p>They are to be used with function <code>dede</code>, to solve delay differential 
equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lagvalue(t, nr)
lagderiv(t, nr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timelags_+3A_t">t</code></td>
<td>
<p>the time for which the lagged value is wanted; this should
be no larger than the current simulation time and no smaller than the 
initial simulation time.  
</p>
</td></tr>
<tr><td><code id="timelags_+3A_nr">nr</code></td>
<td>
<p>the number of the lagged value; if <code>NULL</code> then all state
variables or derivatives are returned.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>lagvalue</code> and <code>lagderiv</code> can only be called during the
integration, the lagged time should not be smaller than the initial
simulation time, nor should it be larger than the current simulation
time.
</p>
<p>Cubic Hermite interpolation is used to obtain an accurate interpolant
at the requested lagged time. 
</p>


<h3>Value</h3>

<p>a scalar (or vector) with the lagged value(s).
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>See Also</h3>

<p><a href="#topic+dede">dede</a>, for how to implement delay differential equations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =============================================================================
## exercise 6 from Shampine and Thompson, 2000
## solving delay differential equations with dde23
##
## two lag values
## =============================================================================

##-----------------------------
## the derivative function
##-----------------------------
derivs &lt;- function(t, y, parms) { 
  History &lt;- function(t) c(cos(t), sin(t))
  if (t &lt; 1)
    lag1 &lt;- History(t - 1)[1]    
  else 
    lag1 &lt;- lagvalue(t - 1)[1] # returns a vector; select first element

  if (t &lt; 2)
    lag2 &lt;- History(t - 2)[2]
  else 
    lag2 &lt;- lagvalue(t - 2,2) # faster than lagvalue(t - 2)[2]

  dy1 &lt;- lag1 * lag2
  dy2 &lt;- -y[1] * lag2
  
  list(c(dy1, dy2), lag1 = lag1, lag2 = lag2)
}

##-----------------------------
## parameters
##-----------------------------

r &lt;- 3.5; m &lt;- 19

##-----------------------------
## initial values and times
##-----------------------------

yinit &lt;- c(y1 = 0, y2 = 0)
times &lt;- seq(0, 20, by = 0.01)

##-----------------------------
## solve the model  
##-----------------------------

yout &lt;- dede(y = yinit, times = times, func = derivs,
  parms = NULL, atol = 1e-9)

##-----------------------------
## plot results
##-----------------------------

plot(yout, type = "l", lwd = 2)

## =============================================================================
## The predator-prey model with time lags, from Hale
## problem 1 from Shampine and Thompson, 2000
## solving delay differential equations with dde23
##
## a vector with lag valuess
## =============================================================================

##-----------------------------
## the derivative function
##-----------------------------
predprey &lt;- function(t, y, parms) {
  tlag &lt;- t - 1
  if (tlag &lt; 0)
    ylag &lt;- c(80, 30)
  else 
    ylag &lt;- lagvalue(tlag)  # returns a vector
  
  dy1 &lt;- a * y[1] * (1 - y[1]/m) + b * y[1] * y[2]
  dy2 &lt;- c * y[2] + d * ylag[1] * ylag[2]
  list(c(dy1, dy2))
}

##-----------------------------
## parameters
##-----------------------------

a &lt;- 0.25; b &lt;- -0.01; c &lt;- -1 ; d &lt;- 0.01; m &lt;- 200

##-----------------------------
## initial values and times
##-----------------------------

yinit &lt;- c(y1 = 80, y2 = 30)
times &lt;- seq(0, 100, by = 0.01)

#-----------------------------
# solve the model  
#-----------------------------

yout &lt;- dede(y = yinit, times = times, func = predprey, parms = NULL)

##-----------------------------
## display, plot results
##-----------------------------

plot(yout, type = "l", lwd = 2, main = "Predator-prey model", mfrow = c(2, 2))
plot(yout[,2], yout[,3], xlab = "y1", ylab = "y2", type = "l", lwd = 2)

diagnostics(yout)

## =============================================================================
##
## A neutral delay differential equation (lagged derivative)   
##  y't = -y'(t-1), y(t) t &lt; 0 = 1/t
##
## =============================================================================

##-----------------------------
## the derivative function
##-----------------------------
derivs &lt;- function(t, y, parms) {
  tlag &lt;- t - 1
  if (tlag &lt; 0)
    dylag &lt;- -1
  else
    dylag &lt;- lagderiv(tlag)

  list(c(dy = -dylag), dylag = dylag)
}

##-----------------------------
## initial values and times
##-----------------------------

yinit &lt;- 0
times &lt;- seq(0, 4, 0.001)

##-----------------------------
## solve the model  
##-----------------------------

yout &lt;- dede(y = yinit, times = times, func = derivs, parms = NULL)

##-----------------------------
## display, plot results
##-----------------------------

plot(yout, type = "l", lwd = 2)
</code></pre>

<hr>
<h2 id='vode'>Solver for Ordinary Differential Equations (ODE)</h2><span id='topic+vode'></span>

<h3>Description</h3>

<p>Solves the initial value problem for stiff or nonstiff systems of 
ordinary differential equations (ODE) in the form:
</p>
<p style="text-align: center;"><code class="reqn">dy/dt = f(t,y)</code>
</p>

<p>The <span class="rlang"><b>R</b></span> function <code>vode</code> provides an interface to the FORTRAN ODE
solver of the same name, written by Peter N. Brown, Alan C. Hindmarsh
and George D. Byrne.
</p>
<p>The system of ODE's is written as an <span class="rlang"><b>R</b></span> function or be defined in
compiled code that has been dynamically loaded.
</p>
<p>In contrast to <code><a href="#topic+lsoda">lsoda</a></code>, the user has to specify whether or
not the problem is stiff and choose the appropriate solution method.
</p>
<p><code>vode</code> is very similar to <code><a href="#topic+lsode">lsode</a></code>, but uses a
variable-coefficient method rather than the fixed-step-interpolate
methods in <code><a href="#topic+lsode">lsode</a></code>.  In addition, in vode it is possible
to choose whether or not a copy of the Jacobian is saved for reuse in
the corrector iteration algorithm; In <code>lsode</code>, a copy is not
kept.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vode(y, times, func, parms, rtol = 1e-6, atol = 1e-6,  
  jacfunc = NULL, jactype = "fullint", mf = NULL, verbose = FALSE,   
  tcrit = NULL, hmin = 0, hmax = NULL, hini = 0, ynames = TRUE,
  maxord = NULL, bandup = NULL, banddown = NULL, maxsteps = 5000,
  dllname = NULL, initfunc = dllname, initpar = parms, rpar = NULL,
  ipar = NULL, nout = 0, outnames = NULL, forcings=NULL,
  initforc = NULL, fcontrol=NULL, events=NULL, lags = NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vode_+3A_y">y</code></td>
<td>
<p>the initial (state) values for the ODE system. If <code>y</code>
has a name attribute, the names will be used to label the output
matrix.
</p>
</td></tr>
<tr><td><code id="vode_+3A_times">times</code></td>
<td>
<p>time sequence for which output is wanted; the first
value of <code>times</code> must be the initial time; if only one step is
to be taken; set <code>times = NULL</code>.
</p>
</td></tr>
<tr><td><code id="vode_+3A_func">func</code></td>
<td>
<p>either an <span class="rlang"><b>R</b></span>-function that computes the values of the
derivatives in the ODE system (the <em>model definition</em>) at time
<code>t</code>, or a character string giving the name of a compiled function in a
dynamically loaded shared library.
</p>
<p>If <code>func</code> is an <span class="rlang"><b>R</b></span>-function, it must be defined as:
<code>func &lt;- function(t, y, parms,...)</code>.  <code>t</code> is the current time
point in the integration, <code>y</code> is the current estimate of the
variables in the ODE system.  If the initial values <code>y</code> has a
<code>names</code> attribute, the names will be available inside <code>func</code>.
<code>parms</code> is a vector or list of parameters; ... (optional) are
any other arguments passed to the function.
</p>
<p>The return value of <code>func</code> should be a list, whose first
element is a vector containing the derivatives of <code>y</code> with
respect to <code>time</code>, and whose next elements are global values
that are required at each point in <code>times</code>.  The derivatives
must be specified in the <b>same order</b> as the state variables <code>y</code>.
</p>
<p>If <code>func</code> is
a string, then <code>dllname</code> must give the name of the shared
library (without extension) which must be loaded before
<code>vode()</code> is called. See package vignette <code>"compiledCode"</code>
for more details.
</p>
</td></tr>
<tr><td><code id="vode_+3A_parms">parms</code></td>
<td>
<p>vector or list of parameters used in <code>func</code> or
<code>jacfunc</code>.
</p>
</td></tr>
<tr><td><code id="vode_+3A_rtol">rtol</code></td>
<td>
<p>relative error tolerance, either a scalar or an array as
long as <code>y</code>.  See details.
</p>
</td></tr>
<tr><td><code id="vode_+3A_atol">atol</code></td>
<td>
<p>absolute error tolerance, either a scalar or an array as
long as <code>y</code>.  See details.
</p>
</td></tr>
<tr><td><code id="vode_+3A_jacfunc">jacfunc</code></td>
<td>
<p>if not <code>NULL</code>, an <span class="rlang"><b>R</b></span> function that computes the
Jacobian of the system of differential equations 
<code class="reqn">\partial\dot{y}_i/\partial y_j</code>, or
a string giving the name of a function or subroutine in
&lsquo;<span class="file">dllname</span>&rsquo; that computes the Jacobian (see vignette
<code>"compiledCode"</code> for more about this option).
</p>
<p>In some circumstances, supplying
<code>jacfunc</code> can speed up the computations, if the system is
stiff.  The <span class="rlang"><b>R</b></span> calling sequence for <code>jacfunc</code> is identical to
that of <code>func</code>.
</p>
<p>If the Jacobian is a full matrix, <code>jacfunc</code> should return a
matrix <code class="reqn">\partial\dot{y}/\partial y</code>, where the ith row contains the derivative of
<code class="reqn">dy_i/dt</code> with respect to <code class="reqn">y_j</code>, or a vector containing the
matrix elements by columns (the way <span class="rlang"><b>R</b></span> and FORTRAN store matrices).
</p>
<p>If the Jacobian is banded, <code>jacfunc</code> should return a matrix
containing only the nonzero bands of the Jacobian, rotated
row-wise. See first example of <a href="#topic+lsode">lsode</a>.
</p>
</td></tr>
<tr><td><code id="vode_+3A_jactype">jactype</code></td>
<td>
<p>the structure of the Jacobian, one of
<code>"fullint"</code>, <code>"fullusr"</code>, <code>"bandusr"</code> or
<code>"bandint"</code> - either full or banded and estimated internally or
by user; overruled if <code>mf</code> is not <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="vode_+3A_mf">mf</code></td>
<td>
<p>the &quot;method flag&quot; passed to function vode - overrules
<code>jactype</code> - provides more options than <code>jactype</code> - see
details.
</p>
</td></tr>
<tr><td><code id="vode_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE: full output to the screen, e.g. will
print the <code>diagnostiscs</code> of the integration - see details.
</p>
</td></tr>
<tr><td><code id="vode_+3A_tcrit">tcrit</code></td>
<td>
<p>if not <code>NULL</code>, then <code>vode</code> cannot integrate
past <code>tcrit</code>. The FORTRAN routine <code>dvode</code> overshoots its
targets (times points in the vector <code>times</code>), and interpolates
values for the desired time points.  If there is a time beyond which
integration should not proceed (perhaps because of a singularity),
that should be provided in <code>tcrit</code>.
</p>
</td></tr>
<tr><td><code id="vode_+3A_hmin">hmin</code></td>
<td>
<p>an optional minimum value of the integration stepsize. In
special situations this parameter may speed up computations with the
cost of precision. Don't use hmin if you don't know why!
</p>
</td></tr>
<tr><td><code id="vode_+3A_hmax">hmax</code></td>
<td>
<p>an optional maximum value of the integration stepsize. If
not specified, hmax is set to the largest difference in
<code>times</code>, to avoid that the simulation possibly ignores
short-term events. If 0, no maximal size is specified.
</p>
</td></tr>
<tr><td><code id="vode_+3A_hini">hini</code></td>
<td>
<p>initial step size to be attempted; if 0, the initial step
size is determined by the solver.
</p>
</td></tr>
<tr><td><code id="vode_+3A_ynames">ynames</code></td>
<td>
<p>logical; if <code>FALSE</code>: names of state variables are not
passed to function <code>func</code> ; this may speed up the simulation
especially for multi-D models.
</p>
</td></tr>
<tr><td><code id="vode_+3A_maxord">maxord</code></td>
<td>
<p>the maximum order to be allowed. <code>NULL</code> uses the default,
i.e. order 12 if implicit Adams method (meth = 1), order 5 if BDF
method (meth = 2). Reduce maxord to save storage space.
</p>
</td></tr>
<tr><td><code id="vode_+3A_bandup">bandup</code></td>
<td>
<p>number of non-zero bands above the diagonal, in case
the Jacobian is banded.
</p>
</td></tr>
<tr><td><code id="vode_+3A_banddown">banddown</code></td>
<td>
<p>number of non-zero bands below the diagonal, in case
the Jacobian is banded.
</p>
</td></tr>
<tr><td><code id="vode_+3A_maxsteps">maxsteps</code></td>
<td>
<p>maximal number of steps per output interval taken by the
solver.
</p>
</td></tr>
<tr><td><code id="vode_+3A_dllname">dllname</code></td>
<td>
<p>a string giving the name of the shared library
(without extension) that contains all the compiled function or
subroutine definitions refered to in <code>func</code> and <code>jacfunc</code>.
See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="vode_+3A_initfunc">initfunc</code></td>
<td>
<p>if not <code>NULL</code>, the name of the initialisation function
(which initialises values of parameters), as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="vode_+3A_initpar">initpar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified and an
initialisation function <code>initfunc</code> is in the dll: the
parameters passed to the initialiser, to initialise the common
blocks (FORTRAN) or global variables (C, C++).
</p>
</td></tr>
<tr><td><code id="vode_+3A_rpar">rpar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with
double precision values passed to the dll-functions whose names are
specified by <code>func</code> and <code>jacfunc</code>.
</p>
</td></tr>
<tr><td><code id="vode_+3A_ipar">ipar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with
integer values passed to the dll-functions whose names are specified
by <code>func</code> and <code>jacfunc</code>.
</p>
</td></tr>
<tr><td><code id="vode_+3A_nout">nout</code></td>
<td>
<p>only used if <code>dllname</code> is specified and the model is
defined in compiled code: the number of output variables calculated
in the compiled function <code>func</code>, present in the shared
library. Note: it is not automatically checked whether this is
indeed the number of output variables calculated in the dll - you have
to perform this check in the code - See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="vode_+3A_outnames">outnames</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified and
<code>nout</code> &gt; 0: the names of output variables calculated in the
compiled function <code>func</code>, present in the shared library.
These names will be used to label the output matrix.
</p>
</td></tr>
<tr><td><code id="vode_+3A_forcings">forcings</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified: a list with
the forcing function data sets, each present as a two-columned matrix,
with (time,value); interpolation outside the interval
[min(<code>times</code>), max(<code>times</code>)] is done by taking the value at
the closest data extreme.
</p>
<p>See <a href="#topic+forcings">forcings</a> or package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="vode_+3A_initforc">initforc</code></td>
<td>
<p>if not <code>NULL</code>, the name of the forcing function
initialisation function, as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. It MUST be present if <code>forcings</code> has been given a
value.
See <a href="#topic+forcings">forcings</a> or package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="vode_+3A_fcontrol">fcontrol</code></td>
<td>
<p>A list of control parameters for the forcing functions.
<a href="#topic+forcings">forcings</a> or package vignette <code>"compiledCode"</code>
</p>
</td></tr>
<tr><td><code id="vode_+3A_events">events</code></td>
<td>
<p>A matrix or data frame that specifies events, i.e. when the value of a 
state variable is suddenly changed. See <a href="#topic+events">events</a> for more information.
</p>
</td></tr>
<tr><td><code id="vode_+3A_lags">lags</code></td>
<td>
<p>A list that specifies timelags, i.e. the number of steps 
that has to be kept. To be used for delay differential equations. 
See <a href="#topic+timelags">timelags</a>, <a href="#topic+dede">dede</a> for more information.
</p>
</td></tr>
<tr><td><code id="vode_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>func</code> and
<code>jacfunc</code> allowing this to be a generic function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Before using the integrator <code>vode</code>, the user has to decide
whether or not the problem is stiff.
</p>
<p>If the problem is nonstiff, use method flag <code>mf</code> = 10, which
selects a nonstiff (Adams) method, no Jacobian used.
</p>
<p>If the problem is stiff, there are four standard choices which can be
specified with <code>jactype</code> or <code>mf</code>.
</p>
<p>The options for <b>jactype</b> are
</p>

<dl>
<dt>jac = &quot;fullint&quot;:</dt><dd><p>a full Jacobian, calculated internally by
vode, corresponds to <code>mf</code> = 22,
</p>
</dd>
<dt>jac = &quot;fullusr&quot;:</dt><dd><p>a full Jacobian, specified by user function
<code>jacfunc</code>, corresponds to <code>mf</code> = 21,
</p>
</dd>
<dt>jac = &quot;bandusr&quot;:</dt><dd><p>a banded Jacobian, specified by user
function <code>jacfunc</code>; the size of the bands specified by
<code>bandup</code> and <code>banddown</code>, corresponds to <code>mf</code> = 24,
</p>
</dd>
<dt>jac = &quot;bandint&quot;:</dt><dd><p>a banded Jacobian, calculated by vode; the
size of the bands specified by <code>bandup</code> and <code>banddown</code>,
corresponds to <code>mf</code> = 25.
</p>
</dd>
</dl>

<p>More options are available when specifying <b>mf</b> directly.
</p>
<p>The legal values of <code>mf</code> are 10, 11, 12, 13, 14, 15, 20, 21, 22,
23, 24, 25, -11, -12, -14, -15, -21, -22, -24, -25.
</p>
<p><code>mf</code> is a signed two-digit integer, <code>mf = JSV*(10*METH +
  MITER)</code>, where
</p>

<dl>
<dt>JSV = SIGN(mf)</dt><dd><p>indicates the Jacobian-saving strategy: JSV =
1 means a copy of the Jacobian is saved for reuse in the corrector
iteration algorithm. JSV = -1 means a copy of the Jacobian is not
saved.
</p>
</dd>
<dt>METH</dt><dd><p>indicates the basic linear multistep method: METH = 1
means the implicit Adams method. METH = 2 means the method based
on backward differentiation formulas (BDF-s).
</p>
</dd>
<dt>MITER</dt><dd><p>indicates the corrector iteration method: MITER = 0
means functional iteration (no Jacobian matrix is involved).
</p>
<p>MITER = 1 means chord iteration with a user-supplied full (NEQ by
NEQ) Jacobian.
</p>
<p>MITER = 2 means chord iteration with an internally generated
(difference quotient) full Jacobian (using NEQ extra calls to
<code>func</code> per df/dy value).
</p>
<p>MITER = 3 means chord iteration with an internally generated
diagonal Jacobian approximation (using 1 extra call to <code>func</code>
per df/dy evaluation).
</p>
<p>MITER = 4 means chord iteration with a user-supplied banded
Jacobian.
</p>
<p>MITER = 5 means chord iteration with an internally generated
banded Jacobian (using ML+MU+1 extra calls to <code>func</code> per
df/dy evaluation).
</p>
</dd>
</dl>

<p>If MITER = 1 or 4, the user must supply a subroutine <code>jacfunc</code>.
</p>
<p>The example for integrator <code><a href="#topic+lsode">lsode</a></code> demonstrates how to
specify both a banded and full Jacobian.
</p>
<p>The input parameters <code>rtol</code>, and <code>atol</code> determine the
<b>error control</b> performed by the solver.  If the request for
precision exceeds the capabilities of the machine, vode will return an
error code. See <code><a href="#topic+lsoda">lsoda</a></code> for details.
</p>
<p>The diagnostics of the integration can be printed to screen
by calling <code><a href="#topic+diagnostics">diagnostics</a></code>. If <code>verbose</code> = <code>TRUE</code>,
the diagnostics will written to the screen at the end of the integration.
</p>
<p>See vignette(&quot;deSolve&quot;) for an explanation of each element in the vectors
containing the diagnostic properties and how to directly access them.
</p>
<p><b>Models</b> may be defined in compiled C or FORTRAN code, as well as
in an R-function. See package vignette <code>"compiledCode"</code> for details.
</p>
<p>More information about models defined in compiled code is in the package
vignette (&quot;compiledCode&quot;); information about linking forcing functions
to compiled code is in <a href="#topic+forcings">forcings</a>.
</p>
<p>Examples in both C and FORTRAN are in the &lsquo;<span class="file">dynload</span>&rsquo; subdirectory
of the <code>deSolve</code> package directory.
</p>


<h3>Value</h3>

<p>A matrix of class <code>deSolve</code> with up to as many rows as elements
in <code>times</code> and as many columns as elements in <code>y</code> plus the number of &quot;global&quot;
values returned in the next elements of the return from <code>func</code>,
plus and additional column for the time value.  There will be a row
for each element in <code>times</code> unless the FORTRAN routine &lsquo;vode&rsquo;
returns with an unrecoverable error. If <code>y</code> has a names
attribute, it will be used to label the columns of the output value.
</p>


<h3>Note</h3>

<p>From version 1.10.4, the default of <code>atol</code> was changed from 1e-8 to 1e-6,
to be consistent with the other solvers.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>References</h3>

<p>P. N. Brown, G. D. Byrne, and A. C. Hindmarsh, 1989.  VODE: A Variable
Coefficient ODE Solver, SIAM J. Sci. Stat. Comput., 10, pp. 1038-1051.
<br /> Also, LLNL Report UCRL-98412, June 1988.
<a href="https://doi.org/10.1137/0910062">doi:10.1137/0910062</a>
</p>
<p>G. D. Byrne and A. C. Hindmarsh, 1975. A Polyalgorithm for the
Numerical Solution of Ordinary Differential Equations.  ACM
Trans. Math. Software, 1, pp. 71-96.
<a href="https://doi.org/10.1145/355626.355636">doi:10.1145/355626.355636</a> 
</p>
<p>A. C. Hindmarsh and G. D. Byrne, 1977. EPISODE: An Effective Package
for the Integration of Systems of Ordinary Differential
Equations. LLNL Report UCID-30112, Rev. 1.
</p>
<p>G. D. Byrne and A. C. Hindmarsh, 1976. EPISODEB: An Experimental
Package for the Integration of Systems of Ordinary Differential
Equations with Banded Jacobians. LLNL Report UCID-30132, April 1976.
</p>
<p>A. C. Hindmarsh, 1983. ODEPACK, a Systematized Collection of ODE
Solvers. in Scientific Computing, R. S. Stepleman et al., eds.,
North-Holland, Amsterdam, pp. 55-64.
</p>
<p>K. R. Jackson and R. Sacks-Davis, 1980. An Alternative Implementation
of Variable Step-Size Multistep Formulas for Stiff ODEs.  ACM
Trans. Math. Software, 6, pp. 295-318.
<a href="https://doi.org/10.1145/355900.355903">doi:10.1145/355900.355903</a> 
</p>
<p>Netlib: <a href="https://netlib.org">https://netlib.org</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+rk">rk</a></code>, </p>
</li>
<li> <p><code><a href="#topic+rk4">rk4</a></code> and <code><a href="#topic+euler">euler</a></code> for
Runge-Kutta integrators.
</p>
</li>
<li> <p><code><a href="#topic+lsoda">lsoda</a></code>, <code><a href="#topic+lsode">lsode</a></code>,
<code><a href="#topic+lsodes">lsodes</a></code>, <code><a href="#topic+lsodar">lsodar</a></code>,
<code><a href="#topic+daspk">daspk</a></code> for other solvers of the Livermore family,
</p>
</li>
<li> <p><code><a href="#topic+ode">ode</a></code> for a general interface to most of the ODE solvers,
</p>
</li>
<li> <p><code><a href="#topic+ode.band">ode.band</a></code> for solving models with a banded
Jacobian,
</p>
</li>
<li> <p><code><a href="#topic+ode.1D">ode.1D</a></code> for integrating 1-D models,
</p>
</li>
<li> <p><code><a href="#topic+ode.2D">ode.2D</a></code> for integrating 2-D models,
</p>
</li>
<li> <p><code><a href="#topic+ode.3D">ode.3D</a></code> for integrating 3-D models,
</p>
</li></ul>

<p><code><a href="#topic+diagnostics">diagnostics</a></code> to print diagnostic messages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =======================================================================
## ex. 1
## The famous Lorenz equations: chaos in the earth's atmosphere
## Lorenz 1963. J. Atmos. Sci. 20, 130-141.
## =======================================================================

chaos &lt;- function(t, state, parameters) {
  with(as.list(c(state)), {

    dx     &lt;- -8/3 * x + y * z
    dy     &lt;- -10 * (y - z)
    dz     &lt;- -x * y + 28 * y - z

    list(c(dx, dy, dz))
  })
}

state &lt;- c(x = 1, y = 1, z = 1)
times &lt;- seq(0, 100, 0.01)

out   &lt;- vode(state, times, chaos, 0)

plot(out, type = "l")   # all versus time
plot(out[,"x"], out[,"y"], type = "l", main = "Lorenz butterfly",
  xlab = "x", ylab = "y")


## =======================================================================
## ex. 2
## SCOC model, in FORTRAN  - to see the FORTRAN code:
## browseURL(paste(system.file(package="deSolve"),
##                             "/doc/examples/dynload/scoc.f",sep=""))
## example from Soetaert and Herman, 2009, chapter 3. (simplified)
## =======================================================================

## Forcing function data
Flux &lt;- matrix(ncol = 2, byrow = TRUE, data = c(
  1,  0.654, 11, 0.167,  21, 0.060, 41, 0.070, 73, 0.277, 83, 0.186,
  93, 0.140,103, 0.255, 113, 0.231,123, 0.309,133, 1.127,143, 1.923,
  153,1.091,163, 1.001, 173, 1.691,183, 1.404,194, 1.226,204, 0.767,
  214,0.893,224, 0.737, 234, 0.772,244, 0.726,254, 0.624,264, 0.439,
  274,0.168,284, 0.280, 294, 0.202,304, 0.193,315, 0.286,325, 0.599,
  335,1.889,345, 0.996, 355, 0.681,365, 1.135))

parms &lt;- c(k = 0.01)

meanDepo &lt;- mean(approx(Flux[,1], Flux[,2], xout = seq(1, 365, by = 1))$y)

Yini &lt;- c(y = as.double(meanDepo/parms))

times &lt;- 1:365
out &lt;- vode(Yini, times, func = "scocder",
    parms = parms, dllname = "deSolve",
    initforc = "scocforc", forcings = Flux,
    initfunc = "scocpar", nout = 2,
    outnames = c("Mineralisation", "Depo"))

matplot(out[,1], out[,c("Depo", "Mineralisation")], 
        type = "l", col = c("red", "blue"), xlab = "time", ylab = "Depo")

## Constant interpolation of forcing function - left side of interval
fcontrol &lt;- list(method = "constant")

out2 &lt;- vode(Yini, times, func = "scocder",
    parms = parms, dllname = "deSolve",
    initforc = "scocforc",  forcings = Flux, fcontrol = fcontrol,
    initfunc = "scocpar", nout = 2,
    outnames = c("Mineralisation", "Depo"))
matplot(out2[,1], out2[,c("Depo", "Mineralisation")], 
        type = "l", col = c("red", "blue"), xlab = "time", ylab = "Depo")

## Constant interpolation of forcing function - middle of interval
fcontrol &lt;- list(method = "constant", f = 0.5)

out3 &lt;- vode(Yini, times, func = "scocder",
    parms = parms, dllname = "deSolve",
    initforc = "scocforc",  forcings = Flux, fcontrol = fcontrol,
    initfunc = "scocpar", nout = 2,
    outnames = c("Mineralisation", "Depo"))

matplot(out3[,1], out3[,c("Depo", "Mineralisation")], 
        type = "l", col = c("red", "blue"), xlab = "time", ylab = "Depo")

plot(out, out2, out3)
</code></pre>

<hr>
<h2 id='zvode'>Solver for Ordinary Differential Equations (ODE) for COMPLEX variables</h2><span id='topic+zvode'></span>

<h3>Description</h3>

<p>Solves the initial value problem for stiff or nonstiff systems of 
ordinary differential equations (ODE) in the form:
</p>
<p style="text-align: center;"><code class="reqn">dy/dt = f(t,y)</code>
</p>

<p>where <code class="reqn">dy</code> and <code class="reqn">y</code> are complex variables. 
</p>
<p>The <span class="rlang"><b>R</b></span> function <code>zvode</code> provides an interface to the FORTRAN ODE
solver of the same name, written by Peter N. Brown, Alan C. Hindmarsh
and George D. Byrne.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zvode(y, times, func, parms, rtol = 1e-6, atol = 1e-6,  
  jacfunc = NULL, jactype = "fullint", mf = NULL, verbose = FALSE,   
  tcrit = NULL, hmin = 0, hmax = NULL, hini = 0, ynames = TRUE,
  maxord = NULL, bandup = NULL, banddown = NULL, maxsteps = 5000,
  dllname = NULL, initfunc = dllname, initpar = parms, rpar = NULL,
  ipar = NULL, nout = 0, outnames = NULL, forcings = NULL,
  initforc = NULL, fcontrol = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zvode_+3A_y">y</code></td>
<td>
<p>the initial (state) values for the ODE system. If <code>y</code>
has a name attribute, the names will be used to label the output
matrix. <em>y has to be complex</em>
</p>
</td></tr>
<tr><td><code id="zvode_+3A_times">times</code></td>
<td>
<p>time sequence for which output is wanted; the first
value of <code>times</code> must be the initial time; if only one step is
to be taken; set <code>times = NULL</code>.
</p>
</td></tr>
<tr><td><code id="zvode_+3A_func">func</code></td>
<td>
<p>either an <span class="rlang"><b>R</b></span>-function that computes the values of the
derivatives in the ODE system (the <em>model definition</em>) at time
<code>t</code>, or a character string giving the name of a compiled function in a
dynamically loaded shared library.
</p>
<p>If <code>func</code> is an <span class="rlang"><b>R</b></span>-function, it must be defined as:
<code>func &lt;- function(t, y, parms, ...)</code>.  <code>t</code> is the current time
point in the integration, <code>y</code> is the current estimate of the
variables in the ODE system.  If the initial values <code>y</code> has a
<code>names</code> attribute, the names will be available inside <code>func</code>.
<code>parms</code> is a vector or list of parameters; ... (optional) are
any other arguments passed to the function.
</p>
<p>The return value of <code>func</code> should be a list, whose first
element is a vector containing the derivatives of <code>y</code> with
respect to <code>time</code>, and whose next elements are global values
that are required at each point in <code>times</code>.  The derivatives
must be specified in the <b>same order</b> as the state variables <code>y</code>.
They should be <em>complex numbers</em>.
</p>
<p>If <code>func</code> is
a string, then <code>dllname</code> must give the name of the shared
library (without extension) which must be loaded before
<code>zvode()</code> is called. See package vignette <code>"compiledCode"</code>
for more details.
</p>
</td></tr>
<tr><td><code id="zvode_+3A_parms">parms</code></td>
<td>
<p>vector or list of parameters used in <code>func</code> or
<code>jacfunc</code>.
</p>
</td></tr>
<tr><td><code id="zvode_+3A_rtol">rtol</code></td>
<td>
<p>relative error tolerance, either a scalar or an array as
long as <code>y</code>.  See details.
</p>
</td></tr>
<tr><td><code id="zvode_+3A_atol">atol</code></td>
<td>
<p>absolute error tolerance, either a scalar or an array as
long as <code>y</code>.  See details.
</p>
</td></tr>
<tr><td><code id="zvode_+3A_jacfunc">jacfunc</code></td>
<td>
<p>if not <code>NULL</code>, an <span class="rlang"><b>R</b></span> function that computes the
Jacobian of the system of differential equations
<code class="reqn">\partial\dot{y}_i/\partial y_j</code>, or
a string giving the name of a function or subroutine in
&lsquo;<span class="file">dllname</span>&rsquo; that computes the Jacobian (see vignette
<code>"compiledCode"</code> for more about this option).
</p>
<p>In some circumstances, supplying
<code>jacfunc</code> can speed up the computations, if the system is
stiff.  The <span class="rlang"><b>R</b></span> calling sequence for <code>jacfunc</code> is identical to
that of <code>func</code>.
</p>
<p>If the Jacobian is a full matrix, <code>jacfunc</code> should return a
matrix <code class="reqn">\dot{dy}/dy</code>, where the ith row contains the derivative of
<code class="reqn">dy_i/dt</code> with respect to <code class="reqn">y_j</code>, or a vector containing the
matrix elements by columns (the way <span class="rlang"><b>R</b></span> and FORTRAN store matrices).
Its elements should be <em>complex numbers</em>.
</p>
<p>If the Jacobian is banded, <code>jacfunc</code> should return a matrix
containing only the nonzero bands of the Jacobian, rotated
row-wise. See first example of <code>lsode</code>.
</p>
</td></tr>
<tr><td><code id="zvode_+3A_jactype">jactype</code></td>
<td>
<p>the structure of the Jacobian, one of
<code>"fullint"</code>, <code>"fullusr"</code>, <code>"bandusr"</code> or
<code>"bandint"</code> - either full or banded and estimated internally or
by user; overruled if <code>mf</code> is not <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="zvode_+3A_mf">mf</code></td>
<td>
<p>the &quot;method flag&quot; passed to function <code>zvode</code> - overrules
<code>jactype</code> - provides more options than <code>jactype</code> - see
details.
</p>
</td></tr>
<tr><td><code id="zvode_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE: full output to the screen, e.g. will
print the <code>diagnostiscs</code> of the integration - see details.
</p>
</td></tr>
<tr><td><code id="zvode_+3A_tcrit">tcrit</code></td>
<td>
<p>if not <code>NULL</code>, then <code>zvode</code> cannot integrate
past <code>tcrit</code>. The FORTRAN routine <code>dvode</code> overshoots its
targets (times points in the vector <code>times</code>), and interpolates
values for the desired time points.  If there is a time beyond which
integration should not proceed (perhaps because of a singularity),
that should be provided in <code>tcrit</code>.
</p>
</td></tr>
<tr><td><code id="zvode_+3A_hmin">hmin</code></td>
<td>
<p>an optional minimum value of the integration stepsize. In
special situations this parameter may speed up computations with the
cost of precision. Don't use hmin if you don't know why!
</p>
</td></tr>
<tr><td><code id="zvode_+3A_hmax">hmax</code></td>
<td>
<p>an optional maximum value of the integration stepsize. If
not specified, hmax is set to the largest difference in
<code>times</code>, to avoid that the simulation possibly ignores
short-term events. If 0, no maximal size is specified.
</p>
</td></tr>
<tr><td><code id="zvode_+3A_hini">hini</code></td>
<td>
<p>initial step size to be attempted; if 0, the initial step
size is determined by the solver.
</p>
</td></tr>
<tr><td><code id="zvode_+3A_ynames">ynames</code></td>
<td>
<p>logical; if <code>FALSE</code>: names of state variables are not
passed to function <code>func</code> ; this may speed up the simulation
especially for multi-D models.
</p>
</td></tr>
<tr><td><code id="zvode_+3A_maxord">maxord</code></td>
<td>
<p>the maximum order to be allowed. <code>NULL</code> uses the default,
i.e. order 12 if implicit Adams method (<code>meth = 1</code>), order 5 if BDF
method (<code>meth = 2</code>). Reduce maxord to save storage space.
</p>
</td></tr>
<tr><td><code id="zvode_+3A_bandup">bandup</code></td>
<td>
<p>number of non-zero bands above the diagonal, in case
the Jacobian is banded.
</p>
</td></tr>
<tr><td><code id="zvode_+3A_banddown">banddown</code></td>
<td>
<p>number of non-zero bands below the diagonal, in case
the Jacobian is banded.
</p>
</td></tr>
<tr><td><code id="zvode_+3A_maxsteps">maxsteps</code></td>
<td>
<p>maximal number of steps per output interval taken by the
solver.
</p>
</td></tr>
<tr><td><code id="zvode_+3A_dllname">dllname</code></td>
<td>
<p>a string giving the name of the shared library
(without extension) that contains all the compiled function or
subroutine definitions refered to in <code>func</code> and <code>jacfunc</code>.
See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="zvode_+3A_initfunc">initfunc</code></td>
<td>
<p>if not <code>NULL</code>, the name of the initialisation function
(which initialises values of parameters), as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="zvode_+3A_initpar">initpar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified and an
initialisation function <code>initfunc</code> is in the dll: the
parameters passed to the initialiser, to initialise the common
blocks (FORTRAN) or global variables (C, C++).
</p>
</td></tr>
<tr><td><code id="zvode_+3A_rpar">rpar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with
double precision values passed to the DLL-functions whose names are
specified by <code>func</code> and <code>jacfunc</code>.
</p>
</td></tr>
<tr><td><code id="zvode_+3A_ipar">ipar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with
integer values passed to the dll-functions whose names are specified
by <code>func</code> and <code>jacfunc</code>.
</p>
</td></tr>
<tr><td><code id="zvode_+3A_nout">nout</code></td>
<td>
<p>only used if <code>dllname</code> is specified and the model is
defined in compiled code: the number of output variables calculated
in the compiled function <code>func</code>, present in the shared
library. Note: it is not automatically checked whether this is
indeed the number of output variables calculated in the DLL - you have
to perform this check in the code - See package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="zvode_+3A_outnames">outnames</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified and
<code>nout</code> &gt; 0: the names of output variables calculated in the
compiled function <code>func</code>, present in the shared library.
These names will be used to label the output matrix.
</p>
</td></tr>
<tr><td><code id="zvode_+3A_forcings">forcings</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified: a list with
the forcing function data sets, each present as a two-columned matrix,
with (time,value); interpolation outside the interval
[min(<code>times</code>), max(<code>times</code>)] is done by taking the value at
the closest data extreme.
</p>
<p>See <a href="#topic+forcings">forcings</a> or package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="zvode_+3A_initforc">initforc</code></td>
<td>
<p>if not <code>NULL</code>, the name of the forcing function
initialisation function, as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. It MUST be present if <code>forcings</code> has been given a
value.
See <a href="#topic+forcings">forcings</a> or package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="zvode_+3A_fcontrol">fcontrol</code></td>
<td>
<p>A list of control parameters for the forcing functions.
<a href="#topic+forcings">forcings</a> or package vignette <code>"compiledCode"</code>
</p>
</td></tr>
<tr><td><code id="zvode_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>func</code> and
<code>jacfunc</code> allowing this to be a generic function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see <code><a href="#topic+vode">vode</a></code>, the double precision version, for details.
</p>


<h3>Value</h3>

<p>A matrix of class <code>deSolve</code> with up to as many rows as elements
in <code>times</code> and as many columns as elements in <code>y</code> plus the 
number of &quot;global&quot; values returned in the next elements of the return 
from <code>func</code>,
plus and additional column for the time value.  There will be a row
for each element in <code>times</code> unless the FORTRAN routine &lsquo;zvode&rsquo;
returns with an unrecoverable error. If <code>y</code> has a names
attribute, it will be used to label the columns of the output value.
</p>


<h3>Note</h3>

<p>From version 1.10.4, the default of atol was changed from 1e-8 to 1e-6,
to be consistent with the other solvers.
</p>
<p>The following text is adapted from the zvode.f source code:
</p>
<p>When using <code>zvode</code> for a stiff system, it should only be used for
the case in which the function f is analytic, that is, when each f(i)
is an analytic function of each y(j).  Analyticity means that the
partial derivative df(i)/dy(j) is a unique complex number, and this
fact is critical in the way <code>zvode</code> solves the dense or banded linear
systems that arise in the stiff case.  For a complex stiff ODE system
in which f is not analytic, <code>zvode</code> is likely to have convergence
failures, and for this problem one should instead use <code>ode</code> on the
equivalent real system (in the real and imaginary parts of y).
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>References</h3>

<p>P. N. Brown, G. D. Byrne, and A. C. Hindmarsh, 1989.  VODE: A Variable
Coefficient ODE Solver, SIAM J. Sci. Stat. Comput., 10, pp. 1038-1051.
<br /> Also, LLNL Report UCRL-98412, June 1988.
<a href="https://doi.org/10.1137/0910062">doi:10.1137/0910062</a>
</p>
<p>G. D. Byrne and A. C. Hindmarsh, 1975. A Polyalgorithm for the
Numerical Solution of Ordinary Differential Equations.  ACM
Trans. Math. Software, 1, pp. 71-96.
<a href="https://doi.org/10.1145/355626.355636">doi:10.1145/355626.355636</a>
</p>
<p>A. C. Hindmarsh and G. D. Byrne, 1977. EPISODE: An Effective Package
for the Integration of Systems of Ordinary Differential
Equations. LLNL Report UCID-30112, Rev. 1.
</p>
<p>G. D. Byrne and A. C. Hindmarsh, 1976. EPISODEB: An Experimental
Package for the Integration of Systems of Ordinary Differential
Equations with Banded Jacobians. LLNL Report UCID-30132, April 1976.
</p>
<p>A. C. Hindmarsh, 1983. ODEPACK, a Systematized Collection of ODE
Solvers. in Scientific Computing, R. S. Stepleman et al., eds.,
North-Holland, Amsterdam, pp. 55-64.
</p>
<p>K. R. Jackson and R. Sacks-Davis, 1980. An Alternative Implementation
of Variable Step-Size Multistep Formulas for Stiff ODEs.  ACM
Trans. Math. Software, 6, pp. 295-318.
<a href="https://doi.org/10.1145/355900.355903">doi:10.1145/355900.355903</a>
</p>
<p>Netlib: <a href="https://netlib.org">https://netlib.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vode">vode</a></code> for the double precision version
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## =======================================================================
## Example 1 - very simple example 
## df/dt = 1i*f, where 1i is the imaginary unit
## The initial value is f(0) = 1 = 1+0i
## =======================================================================

ZODE &lt;- function(Time, f, Pars) {
  df &lt;-  1i*f
  return(list(df))
}

pars    &lt;- NULL
yini    &lt;- c(f = 1+0i)
times   &lt;- seq(0, 2*pi, length = 100)
out     &lt;- zvode(func = ZODE, y = yini, parms = pars, times = times,
  atol = 1e-10, rtol = 1e-10)

# The analytical solution to this ODE is the exp-function:
# f(t) = exp(1i*t)
#      = cos(t)+1i*sin(t)  (due to Euler's equation)

analytical.solution  &lt;- exp(1i * times) 

## compare numerical and analytical solution
tail(cbind(out[,2], analytical.solution))


## =======================================================================
## Example 2 - example in "zvode.f",  
## df/dt = 1i*f        (same as above ODE)
## dg/dt = -1i*g*g*f   (an additional ODE depending on f)
##
## Initial values are
## g(0) = 1/2.1 and
## z(0) = 1  
## =======================================================================

ZODE2&lt;-function(Time,State,Pars) {
  with(as.list(State), {
    df &lt;- 1i * f
    dg &lt;- -1i * g*g * f
    return(list(c(df, dg)))
  })
}

yini    &lt;- c(f = 1 + 0i, g = 1/2.1 + 0i)
times   &lt;- seq(0, 2*pi, length = 100)
out     &lt;- zvode(func = ZODE2, y = yini, parms = NULL, times = times,
  atol = 1e-10, rtol = 1e-10)


## The analytical solution is
## f(t) = exp(1i*t)   (same as above)
## g(t) = 1/(f(t) + 1.1)

analytical &lt;- cbind(f = exp(1i * times), g = 1/(exp(1i * times) + 1.1))

## compare numerical solution and the two analytical ones:
tail(cbind(out[,2], analytical[,1]))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
