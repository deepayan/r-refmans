<!DOCTYPE html><html lang="en"><head><title>Help for package aphylo</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {aphylo}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aphylo-package'><p>Statistical Inference in Annotated Phylogenetic Trees</p></a></li>
<li><a href='#accuracy_sifter'><p>Accuracy calculation as defined in Engelhardt et al. (2011)</p></a></li>
<li><a href='#ape-methods'><p>Available methods from the APE package</p></a></li>
<li><a href='#aphylo_cv'><p>Leave-one-out Cross Validation</p></a></li>
<li><a href='#APHYLO_DEFAULT_MCMC_CONTROL'><p>Model estimation using Markov Chain Monte Carlo</p></a></li>
<li><a href='#aphylo_estimates'><p>Objects of class <code>aphylo_estimates</code></p></a></li>
<li><a href='#aphylo_from_data_frame'><p>Create an <code>aphylo</code> object with partial annotations</p></a></li>
<li><a href='#aphylo_mle'><p>Model estimation using Maximum Likelihood Estimation</p></a></li>
<li><a href='#aphylo-class'><p>Annotated Phylogenetic Tree</p></a></li>
<li><a href='#aphylo-index'><p>Indexing aphylo objects</p></a></li>
<li><a href='#aphylo-info'><p>Information about <code>aphylo</code> and <code>multiAphylo</code> objects</p></a></li>
<li><a href='#aphylo-methods'><p>Plot and print methods for <code>aphylo</code> objects</p></a></li>
<li><a href='#aphylo-model'><p>Formulas in <code>aphylo</code></p></a></li>
<li><a href='#as.phylo'><p>Extensions to the <code>as.phylo</code> function</p></a></li>
<li><a href='#auc'><p>Area Under the Curve and Receiving Operating Curve</p></a></li>
<li><a href='#balance_ann'><p>Functional balance of a tree</p></a></li>
<li><a href='#bprior'><p>Default priors for aphylo_mcmc</p></a></li>
<li><a href='#dist2root'><p>Pointer to <code>pruner</code></p></a></li>
<li><a href='#fakeexperiment'><p>Fake Experimental Data</p></a></li>
<li><a href='#faketree'><p>Fake Phylogenetic Tree</p></a></li>
<li><a href='#imputate_duplications'><p>Impute duplication events based on a vector of species</p></a></li>
<li><a href='#list_offspring'><p>List each nodes' offspring or parent</p></a></li>
<li><a href='#LogLike'><p>Likelihood of an observed annotated phylogenetic tree</p></a></li>
<li><a href='#mislabel'><p>Switch labels acoording to mislabeling probabilities</p></a></li>
<li><a href='#multiAphylo'><p>Building Lists of Annotated Trees</p></a></li>
<li><a href='#panther-tree'><p>Reads PANTHER db trees</p></a></li>
<li><a href='#plot_logLik'><p>Plot Log-Likelihood function of the model</p></a></li>
<li><a href='#plot_multivariate'><p>Multiavariate plot (surface)</p></a></li>
<li><a href='#plot.aphylo_prediction_score'><p>Visualize predictions</p></a></li>
<li><a href='#posterior-probabilities'><p>Posterior probabilities based on parameter estimates</p></a></li>
<li><a href='#prediction_score'><p>Calculate prediction score (quality of prediction)</p></a></li>
<li><a href='#raphylo'><p>Simulation of Annotated Phylogenetic Trees</p></a></li>
<li><a href='#rdrop_annotations'><p>Randomly drop leaf annotations</p></a></li>
<li><a href='#read_nhx'><p>Read New Hampshire eXtended format for trees</p></a></li>
<li><a href='#read_pli'><p>Read PLI files from SIFTER</p></a></li>
<li><a href='#sim_fun_on_tree'><p>Simulate functions on a ginven tree</p></a></li>
<li><a href='#sim_tree'><p>Random tree generation</p></a></li>
<li><a href='#states'><p>Matrix of states</p></a></li>
<li><a href='#write_pli'><p>Write pli files used by SIFTER</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Statistical Inference and Prediction of Annotations in
Phylogenetic Trees</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3-4</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements a parsimonious evolutionary model to analyze and
  predict gene-functional annotations in phylogenetic trees as described in Vega
  Yon et al. (2021) &lt;<a href="https://doi.org/10.1371%2Fjournal.pcbi.1007948">doi:10.1371/journal.pcbi.1007948</a>&gt;. Focusing on
  computational efficiency, 'aphylo' makes it possible to estimate pooled
  phylogenetic models, including thousands (hundreds) of annotations (trees) in
  the same run. The package also provides the tools for visualization of
  annotated phylogenies, calculation of posterior probabilities (prediction)
  and goodness-of-fit assessment featured in Vega Yon et al. (2021).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), ape (&ge; 5.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.1), Matrix, methods, coda, fmcmc, utils, MASS,
xml2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, tinytest, AUC, rmarkdown,</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/USCbiostats/aphylo">https://github.com/USCbiostats/aphylo</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/USCbiostats/aphylo/issues">https://github.com/USCbiostats/aphylo/issues</a></td>
</tr>
<tr>
<td>Classification/MSC:</td>
<td>90C35, 90B18, 91D30</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-03 16:29:02 UTC; u6039184</td>
</tr>
<tr>
<td>Author:</td>
<td>George Vega Yon <a href="https://orcid.org/0000-0002-3171-0844"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  National Cancer Institute (NCI) [fnd] (Grant Number 5P01CA196569-02),
  USC Biostatistics [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>George Vega Yon &lt;g.vegayon@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-03 23:00:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='aphylo-package'>Statistical Inference in Annotated Phylogenetic Trees</h2><span id='topic+aphylo-package'></span>

<h3>Description</h3>

<p>Statistical Inference in Annotated Phylogenetic Trees
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: George Vega Yon <a href="mailto:g.vegayon@gmail.com">g.vegayon@gmail.com</a> (<a href="https://orcid.org/0000-0002-3171-0844">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> National Cancer Institute (NCI) (Grant Number 5P01CA196569-02) [funder]
</p>
</li>
<li><p> USC Biostatistics [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/USCbiostats/aphylo">https://github.com/USCbiostats/aphylo</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/USCbiostats/aphylo/issues">https://github.com/USCbiostats/aphylo/issues</a>
</p>
</li></ul>


<hr>
<h2 id='accuracy_sifter'>Accuracy calculation as defined in Engelhardt et al. (2011)</h2><span id='topic+accuracy_sifter'></span><span id='topic+accuracy_sifter.aphylo_estimates'></span><span id='topic+accuracy_sifter.default'></span>

<h3>Description</h3>

<p>Uses SIFTER's 2011 definition of accuracy, where a protein is tagged as
accurately predicted if the highest ranked prediction matches it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>accuracy_sifter(pred, lab, tol = 1e-10, highlight = "", ...)

## S3 method for class 'aphylo_estimates'
accuracy_sifter(pred, lab, tol = 1e-10, highlight = "", ...)

## Default S3 method:
accuracy_sifter(pred, lab, tol = 1e-10, highlight = "", nine_na = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="accuracy_sifter_+3A_pred">pred</code></td>
<td>
<p>A matrix of predictions, or an <a href="#topic+aphylo_estimates">aphylo_estimates</a> object.</p>
</td></tr>
<tr><td><code id="accuracy_sifter_+3A_lab">lab</code></td>
<td>
<p>A matrix of labels (0,1,NA, or 9 if <code>nine_na = TRUE</code>).</p>
</td></tr>
<tr><td><code id="accuracy_sifter_+3A_tol">tol</code></td>
<td>
<p>Numeric scalar. Predictions within <code>tol</code> of the max score
will be tagged as the prediction made by the model (see deails).</p>
</td></tr>
<tr><td><code id="accuracy_sifter_+3A_highlight">highlight</code></td>
<td>
<p>Pattern passed to <a href="base.html#topic+sprintf">sprintf</a> used to highlight
predicted functions that match the observed.</p>
</td></tr>
<tr><td><code id="accuracy_sifter_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the method. In the case of <code>aphylo_estimates</code>,
the arguments are passed to <code><a href="#topic+predict.aphylo_estimates">predict.aphylo_estimates()</a></code>.</p>
</td></tr>
<tr><td><code id="accuracy_sifter_+3A_nine_na">nine_na</code></td>
<td>
<p>Treat 9 as NA.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The analysis is done at the protein level. For each protein, the function
compares the YES annotations of that proteins with the predicted by the model.
The algorithm selects the predicted annotations as those that are within
<code>tol</code> of the maximum score.
</p>
<p>This algorithm doesn't take into account NOT annotations (0s), which are
excluded from the analysis.
</p>
<p>When <code>highlight = ""</code>, no highlight is done.
</p>


<h3>Value</h3>

<p>A data frame with <code>Ntip()</code> rows and four variables. The variables are:
</p>

<ul>
<li><p> Gene: Label of the gene
</p>
</li>
<li><p> Predicted: The assigned gene function.
</p>
</li>
<li><p> Observed: The true set of gene functions.
</p>
</li>
<li><p> Accuracy: The measurement of accuracy according to Engelhardt et al. (2011).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(81231)
atree &lt;- raphylo(50, psi = c(0,0), P = 3)
ans &lt;- aphylo_mcmc(atree ~ mu_d + mu_s + Pi)

accuracy_sifter(ans)

</code></pre>

<hr>
<h2 id='ape-methods'>Available methods from the APE package</h2><span id='topic+ape-methods'></span>

<h3>Description</h3>

<p>The generics <code><a href="ape.html#topic+summary.phylo">ape::Nedge()</a></code>, <code><a href="ape.html#topic+summary.phylo">ape::Nnode()</a></code>, and <code><a href="ape.html#topic+summary.phylo">ape::Ntip()</a></code> can be used
directly on objects of class <a href="#topic+aphylo">aphylo</a>, <a href="#topic+aphylo_estimates">aphylo_estimates</a>, <a href="#topic+multiAphylo">multiAphylo</a>
</p>


<h3>Value</h3>

<p>Integer with the number of edges, nodes, or tips accordignly.
</p>


<h3>See Also</h3>

<p>Other information: 
<code><a href="#topic+aphylo-info">aphylo-info</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12312)
atree &lt;- raphylo(50, P = 2)
Nnode(atree)
Ntip(atree)
Nedge(atree)

multitree &lt;- rmultiAphylo(10, 50, P = 2)
Nnode(multitree)
Ntip(multitree)
Nedge(multitree)
</code></pre>

<hr>
<h2 id='aphylo_cv'>Leave-one-out Cross Validation</h2><span id='topic+aphylo_cv'></span><span id='topic+aphylo_cv.formula'></span>

<h3>Description</h3>

<p>This implements Leave-one-out cross-validation (LOO-CV) for trees of class
<a href="#topic+aphylo">aphylo</a> and <a href="#topic+multiAphylo">multiAphylo</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aphylo_cv(...)

## S3 method for class 'formula'
aphylo_cv(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aphylo_cv_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the method.</p>
</td></tr>
<tr><td><code id="aphylo_cv_+3A_model">model</code></td>
<td>
<p>As passed to <a href="#topic+aphylo_mcmc">aphylo_mcmc</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each observation in the dataset (either a single gene if of
class <a href="#topic+aphylo">aphylo</a>, or an entire tree if of class <a href="#topic+multiAphylo">multiAphylo</a>), we restimate
the model removing the observation and use the parameter estimates to make
a prediction on it. The prediction is done using the function <a href="#topic+predict.aphylo_estimates">predict.aphylo_estimates</a>
with argument <code>loo = TRUE</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>aphylo_cv</code> with the following components:
</p>

<ul>
<li> <p><code>pred_out</code> Out of sample prediction.
</p>
</li>
<li> <p><code>expected</code> Expected annotations
</p>
</li>
<li> <p><code>call</code> The call
</p>
</li>
<li> <p><code>ids</code> Integer vector with the ids of the leafs used in the loo process.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># It takes about two minutes to run this example


  set.seed(123)
  atrees &lt;- rmultiAphylo(10, 10, P = 1)

  cv_multi  &lt;- aphylo_cv(atrees ~ mu_d + mu_s + Pi)
  cv_single &lt;- aphylo_cv(atrees[[1]] ~ mu_d + mu_s + Pi)
  

</code></pre>

<hr>
<h2 id='APHYLO_DEFAULT_MCMC_CONTROL'>Model estimation using Markov Chain Monte Carlo</h2><span id='topic+APHYLO_DEFAULT_MCMC_CONTROL'></span><span id='topic+aphylo_mcmc'></span><span id='topic+MCMC'></span><span id='topic+APHYLO_PARAM_DEFAULT'></span>

<h3>Description</h3>

<p>The function is a wrapper of <code><a href="fmcmc.html#topic+MCMC">fmcmc::MCMC()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>APHYLO_DEFAULT_MCMC_CONTROL

aphylo_mcmc(
  model,
  params,
  priors = uprior(),
  control = list(),
  check_informative = getOption("aphylo_informative", FALSE),
  reduced_pseq = getOption("aphylo_reduce_pseq", TRUE)
)

APHYLO_PARAM_DEFAULT
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="APHYLO_DEFAULT_MCMC_CONTROL_+3A_model">model</code></td>
<td>
<p>A model as specified in <a href="#topic+aphylo-model">aphylo-model</a>.</p>
</td></tr>
<tr><td><code id="APHYLO_DEFAULT_MCMC_CONTROL_+3A_params">params</code></td>
<td>
<p>A vector of length 7 with initial parameters. In particular
<code>psi[1]</code>, <code>psi[2]</code>, <code>mu[1]</code>, <code>mu[2]</code>, <code>eta[1]</code>, <code>eta[2]</code> and <code>Pi</code>.</p>
</td></tr>
<tr><td><code id="APHYLO_DEFAULT_MCMC_CONTROL_+3A_priors">priors</code></td>
<td>
<p>A function to be used as prior for the model (see <a href="#topic+bprior">bprior</a>).</p>
</td></tr>
<tr><td><code id="APHYLO_DEFAULT_MCMC_CONTROL_+3A_control">control</code></td>
<td>
<p>A list with parameters for the optimization method (see
details).</p>
</td></tr>
<tr><td><code id="APHYLO_DEFAULT_MCMC_CONTROL_+3A_check_informative">check_informative</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> the algorithm
stops with an error when the annotations are uninformative (either 0s or 1s).</p>
</td></tr>
<tr><td><code id="APHYLO_DEFAULT_MCMC_CONTROL_+3A_reduced_pseq">reduced_pseq</code></td>
<td>
<p>Logical. When <code>TRUE</code> it will use a reduced peeling sequence
in which it drops unannotated leafs. If the model includes <code>eta</code> this is set
to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 6.
</p>
<p>An object of class <code>numeric</code> of length 9.
</p>


<h3>Details</h3>

<p><code>APHYLO_DEFAULT_MCMC_CONTROL</code> lists the default values for the MCMC
estimation:
</p>

<ul>
<li> <p><code>nsteps</code>: <code>1e4L</code>
</p>
</li>
<li> <p><code>burnin</code>: <code>5e3L</code>
</p>
</li>
<li> <p><code>thin</code> : <code>10L</code>
</p>
</li>
<li> <p><code>nchains</code> : <code>2L</code>
</p>
</li>
<li> <p><code>multicore</code> : <code>FALSE</code>
</p>
</li>
<li> <p><code>conv_checker</code> : <code>fmcmc::convergence_auto(5e3)</code>
</p>
</li></ul>

<p>For more information about the MCMC estimation process, see <code><a href="fmcmc.html#topic+MCMC">fmcmc::MCMC()</a></code>.
</p>
<p>Methods <code><a href="base.html#topic+print">base::print()</a></code>, <code><a href="base.html#topic+summary">base::summary()</a></code>, <a href="stats.html#topic+coef">stats::coef</a>, <code><a href="stats.html#topic+window">stats::window()</a></code>,
<code><a href="stats.html#topic+vcov">stats::vcov()</a></code>, <code><a href="stats.html#topic+logLik">stats::logLik()</a></code>, <a href="#topic+predict.aphylo_estimates">predict()</a>,
and the various ways to query features of the trees via <a href="ape.html#topic+summary.phylo">Ntip()</a>
are available post estimation.
</p>
<p>The vector <code>APHYLO_PARAM_DEFAULT</code> lists the starting values for the parameters
in the model. The current defaults are:
</p>

<ul>
<li> <p><code>psi0</code>: 0.10
</p>
</li>
<li> <p><code>psi1</code>: 0.05
</p>
</li>
<li> <p><code>mu_d0</code>: 0.90
</p>
</li>
<li> <p><code>mu_d1</code>: 0.50
</p>
</li>
<li> <p><code>mu_s0</code>: 0.10
</p>
</li>
<li> <p><code>mu_s1</code>: 0.05
</p>
</li>
<li> <p><code>eta0</code>: 1.00
</p>
</li>
<li> <p><code>eta1</code>: 1.00
</p>
</li>
<li> <p><code>Pi</code>: 0.50
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <a href="#topic+aphylo_estimates">aphylo_estimates</a>.
</p>


<h3>See Also</h3>

<p>Other parameter estimation: 
<code><a href="#topic+aphylo_mle">aphylo_mle</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using the MCMC ------------------------------------------------------------



set.seed(1233)
# Simulating a tree
tree &lt;- sim_tree(200)

# Simulating functions
atree &lt;- raphylo(
  tree = tree,
  psi  = c(.01, .03),
  mu_d = c(.05, .02),
  Pi   = .5
)

# Running the MCMC
set.seed(1231)

ans_mcmc &lt;- aphylo_mcmc(
  atree ~ mu_d + psi + eta + Pi,
  control = list(nsteps = 2e5, burnin=1000, thin=200)
)

</code></pre>

<hr>
<h2 id='aphylo_estimates'>Objects of class <code>aphylo_estimates</code></h2><span id='topic+aphylo_estimates'></span><span id='topic+print.aphylo_estimates'></span><span id='topic+coef.aphylo_estimates'></span><span id='topic+vcov.aphylo_estimates'></span><span id='topic+plot.aphylo_estimates'></span>

<h3>Description</h3>

<p>The model fitting of annotated phylogenetic trees can be done using either
MLE via <code><a href="#topic+aphylo_mle">aphylo_mle()</a></code> or MCMC via <code><a href="#topic+aphylo_mcmc">aphylo_mcmc()</a></code>. This section describes
the object of class <code>aphylo_estimates</code> that these functions generate and
the post estimation methods/functions that can be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aphylo_estimates'
print(x, ...)

## S3 method for class 'aphylo_estimates'
coef(object, ...)

## S3 method for class 'aphylo_estimates'
vcov(object, ...)

## S3 method for class 'aphylo_estimates'
plot(
  x,
  y = NULL,
  which.tree = 1L,
  ids = list(1:Ntip(x)[which.tree]),
  loo = TRUE,
  nsamples = 1L,
  ncores = 1L,
  centiles = c(0.025, 0.5, 0.975),
  cl = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aphylo_estimates_+3A_x">x</code>, <code id="aphylo_estimates_+3A_object">object</code></td>
<td>
<p>Depending of the method, an object of class <code>aphylo_estimates</code>.</p>
</td></tr>
<tr><td><code id="aphylo_estimates_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the corresponding method.</p>
</td></tr>
<tr><td><code id="aphylo_estimates_+3A_y">y</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="aphylo_estimates_+3A_which.tree">which.tree</code></td>
<td>
<p>Integer scalar. Which tree to plot.</p>
</td></tr>
<tr><td><code id="aphylo_estimates_+3A_ids">ids</code>, <code id="aphylo_estimates_+3A_nsamples">nsamples</code>, <code id="aphylo_estimates_+3A_ncores">ncores</code>, <code id="aphylo_estimates_+3A_centiles">centiles</code>, <code id="aphylo_estimates_+3A_cl">cl</code></td>
<td>
<p>passed to <code><a href="#topic+predict.aphylo_estimates">predict.aphylo_estimates()</a></code></p>
</td></tr>
<tr><td><code id="aphylo_estimates_+3A_loo">loo</code></td>
<td>
<p>Logical scalar. When <code>loo = TRUE</code>, predictions are preformed
similar to what a leave-one-out cross-validation scheme would be done
(see <a href="#topic+predict.aphylo_estimates">predict.aphylo_estimates</a>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot method for the object of class <code>aphylo_estimates</code> plots
the original tree with the predicted annotations.
</p>


<h3>Value</h3>

<p>Objects of class <code>aphylo_estimates</code> are a list withh the following elements:
</p>
<table role = "presentation">
<tr><td><code>par</code></td>
<td>
<p>A numeric vector of length 5 with the solution.</p>
</td></tr>
<tr><td><code>hist</code></td>
<td>
<p>A numeric matrix of size <code>counts*5</code> with the solution path
(length 2 if used <code>optim</code> as the intermediate steps are not available to the
user). In the case of <code>aphylo_mcmc</code>, <code>hist</code> is an object of class
<code><a href="coda.html#topic+mcmc.list">coda::mcmc.list()</a></code>.</p>
</td></tr>
<tr><td><code>ll</code></td>
<td>
<p>A numeric scalar with the value of <code>fun(par, dat)</code>. The value of the log likelihood.</p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p>Integer scalar number of steps/batch performed.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>Integer scalar. Equal to 0 if <code>optim</code> converged. See <code>optim</code>.</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>Character scalar. See <code>optim</code>.</p>
</td></tr>
<tr><td><code>fun</code></td>
<td>
<p>A function (the objective function).</p>
</td></tr>
<tr><td><code>priors</code></td>
<td>
<p>If specified, the function <code>priors</code> passed to the method.</p>
</td></tr>
<tr><td><code>dat</code></td>
<td>
<p>The data <code>dat</code> provided to the function.</p>
</td></tr>
<tr><td><code>par0</code></td>
<td>
<p>A numeric vector of length 5 with the initial parameters.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Character scalar with the name of the method used.</p>
</td></tr>
<tr><td><code>varcovar</code></td>
<td>
<p>A matrix of size 5*5. The estimated covariance matrix.</p>
</td></tr>
</table>
<p>The plot method for <code>aphylo_estimates</code> returns the selected tree
(<code>which.tree</code>) with predicted annotations, also of class <a href="#topic+aphylo">aphylo</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(7881)
atree &lt;- raphylo(40, P = 2)
res   &lt;- aphylo_mcmc(atree ~ mu_d + mu_s + Pi)

print(res)
coef(res)
vcov(res)
plot(res)
</code></pre>

<hr>
<h2 id='aphylo_from_data_frame'>Create an <code>aphylo</code> object with partial annotations</h2><span id='topic+aphylo_from_data_frame'></span>

<h3>Description</h3>

<p>Create an <code>aphylo</code> object with partial annotations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aphylo_from_data_frame(tree, annotations, types = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aphylo_from_data_frame_+3A_tree">tree</code></td>
<td>
<p>An object of class <code>phylo</code>.</p>
</td></tr>
<tr><td><code id="aphylo_from_data_frame_+3A_annotations">annotations</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">data.frame</a> with annotations. The first column should
be the gene id (see details).</p>
</td></tr>
<tr><td><code id="aphylo_from_data_frame_+3A_types">types</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">data.frame</a> with types. Just like the annotations, the first
column should be the gene id.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each row in the the <code>annotations</code> data frame passed to this function
must have a unique row per gene, and one column per function (GO term). The id
of each gene must match the labels in the <code>tree</code> object. Missing genes are
annotated with <code>NA</code> (9).
</p>
<p>In the case of <code>types</code>, while tips can also be annotated with a type, which
should be either 0, duplication, or 1, speciation, only internal nodes
are required. Tip types are ignored.
</p>


<h3>Value</h3>

<p>An object of class <a href="#topic+aphylo">aphylo</a>.
</p>


<h3>See Also</h3>

<p>Other Data management functions: 
<code><a href="#topic+aphylo-class">aphylo-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generating a test dataset
set.seed(1371)
x &lt;- raphylo(20)

# Extracting the tree and annotations
tree &lt;- x$tree

anno &lt;- with(x, rbind(tip.annotation, node.annotation))
anno &lt;- data.frame(id = with(tree, c(tip.label, node.label)), anno)

types &lt;- data.frame(id = tree$node.label, x$node.type)

# Creating a aphylo tree without node types
aphylo_from_data_frame(tree, anno)

# Now including types
aphylo_from_data_frame(tree, anno, types)

# Dropping some data
aphylo_from_data_frame(tree, anno[sample.int(nrow(anno), 10),])

</code></pre>

<hr>
<h2 id='aphylo_mle'>Model estimation using Maximum Likelihood Estimation</h2><span id='topic+aphylo_mle'></span><span id='topic+MLE'></span>

<h3>Description</h3>

<p>The function is a wrapper of <code><a href="stats.html#topic+optim">stats::optim()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aphylo_mle(
  model,
  params,
  method = "L-BFGS-B",
  priors = function(p) 1,
  control = list(),
  lower = 1e-05,
  upper = 1 - 1e-05,
  check_informative = getOption("aphylo_informative", FALSE),
  reduced_pseq = getOption("aphylo_reduce_pseq", TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aphylo_mle_+3A_model">model</code></td>
<td>
<p>A model as specified in <a href="#topic+aphylo-model">aphylo-model</a>.</p>
</td></tr>
<tr><td><code id="aphylo_mle_+3A_params">params</code></td>
<td>
<p>A vector of length 7 with initial parameters. In particular
<code>psi[1]</code>, <code>psi[2]</code>, <code>mu[1]</code>, <code>mu[2]</code>, <code>eta[1]</code>, <code>eta[2]</code> and <code>Pi</code>.</p>
</td></tr>
<tr><td><code id="aphylo_mle_+3A_method">method</code>, <code id="aphylo_mle_+3A_control">control</code>, <code id="aphylo_mle_+3A_lower">lower</code>, <code id="aphylo_mle_+3A_upper">upper</code></td>
<td>
<p>Arguments passed to <code><a href="stats.html#topic+optim">stats::optim()</a></code>.</p>
</td></tr>
<tr><td><code id="aphylo_mle_+3A_priors">priors</code></td>
<td>
<p>A function to be used as prior for the model (see <a href="#topic+bprior">bprior</a>).</p>
</td></tr>
<tr><td><code id="aphylo_mle_+3A_check_informative">check_informative</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> the algorithm
stops with an error when the annotations are uninformative (either 0s or 1s).</p>
</td></tr>
<tr><td><code id="aphylo_mle_+3A_reduced_pseq">reduced_pseq</code></td>
<td>
<p>Logical. When <code>TRUE</code> it will use a reduced peeling sequence
in which it drops unannotated leafs. If the model includes <code>eta</code> this is set
to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default starting parameters are described in <a href="#topic+APHYLO_PARAM_DEFAULT">APHYLO_PARAM_DEFAULT</a>.
</p>


<h3>Value</h3>

<p>An object of class <a href="#topic+aphylo_estimates">aphylo_estimates</a>.
</p>


<h3>See Also</h3>

<p>Other parameter estimation: 
<code><a href="#topic+APHYLO_DEFAULT_MCMC_CONTROL">APHYLO_DEFAULT_MCMC_CONTROL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Using simulated data ------------------------------------------------------
set.seed(19)
dat &lt;- raphylo(100)
dat &lt;- rdrop_annotations(dat, .4)

# Computing Estimating the parameters 
ans  &lt;- aphylo_mle(dat ~ psi + mu_d + eta + Pi)
ans

# Plotting the path
plot(ans)

# Computing Estimating the parameters Using Priors for all the parameters
mypriors &lt;- function(params) {
    dbeta(params, c(2, 2, 2, 2, 1, 10, 2), rep(10, 7))
}

ans_dbeta &lt;- aphylo_mle(dat ~ psi + mu_d + eta + Pi, priors = mypriors)
ans_dbeta
</code></pre>

<hr>
<h2 id='aphylo-class'>Annotated Phylogenetic Tree</h2><span id='topic+aphylo-class'></span><span id='topic+aphylo'></span><span id='topic+new_aphylo'></span><span id='topic+new_aphylo.phylo'></span>

<h3>Description</h3>

<p>The <code>aphylo</code> class tree holds both the tree structure represented as a
partially ordered phylogenetic tree, and node annotations. While annotations
are included for both leafs and inner nodes, the algorithms included in this
package only uses the leaf annotations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_aphylo(tree, tip.annotation, ...)

## S3 method for class 'phylo'
new_aphylo(
  tree,
  tip.annotation,
  node.annotation = NULL,
  tip.type = NULL,
  node.type = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aphylo-class_+3A_tree">tree</code></td>
<td>
<p>An object of class <a href="ape.html#topic+read.tree">phylo</a></p>
</td></tr>
<tr><td><code id="aphylo-class_+3A_tip.annotation">tip.annotation</code>, <code id="aphylo-class_+3A_node.annotation">node.annotation</code></td>
<td>
<p>Annotation data. See <a href="#topic+aphylo-class">aphylo</a>.</p>
</td></tr>
<tr><td><code id="aphylo-class_+3A_...">...</code></td>
<td>
<p>Further argmuents passed to the method.</p>
</td></tr>
<tr><td><code id="aphylo-class_+3A_tip.type">tip.type</code>, <code id="aphylo-class_+3A_node.type">node.type</code></td>
<td>
<p>Integer vectors with values 0 or 1. 0 denotes duplication node and 1 speciation node. This is used in <a href="#topic+LogLike">LogLike</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>aphylo</code> with the following elements:
</p>
<table role = "presentation">
<tr><td><code>tree</code></td>
<td>
<p>An object of class <a href="ape.html#topic+read.tree">phylo</a>.</p>
</td></tr>
<tr><td><code>tip.annotation</code></td>
<td>
<p>An integer matrix. Tip (leaf) nodes annotations.</p>
</td></tr>
<tr><td><code>node.annotation</code></td>
<td>
<p>An integer matrix (optional). Internal nodes
annotations.</p>
</td></tr>
<tr><td><code>offspring</code></td>
<td>
<p>A list. List of offspring of each node.</p>
</td></tr>
<tr><td><code>pseq</code></td>
<td>
<p>Integer vector. The pruning sequence (postorder).</p>
</td></tr>
<tr><td><code>reduced_pseq</code></td>
<td>
<p>Integer vector. The reduced version of <code>pseq</code>.</p>
</td></tr>
<tr><td><code>Ntips.annotated</code></td>
<td>
<p>Integer. Number of tips with annotations.</p>
</td></tr>
<tr><td><code>tip.type</code></td>
<td>
<p>Binary of length <code><a href="ape.html#topic+summary.phylo">ape::Ntip()</a></code>. 0 means duplication and 1 speciation.</p>
</td></tr>
<tr><td><code>tip.type</code></td>
<td>
<p>Binary of length <code><a href="ape.html#topic+summary.phylo">ape::Nnode()</a></code>. 0 means duplication and 1 speciation.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other Data management functions: 
<code><a href="#topic+aphylo_from_data_frame">aphylo_from_data_frame</a>()</code>
</p>
<p>Other aphylo methods: 
<code><a href="#topic+aphylo-methods">aphylo-methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A simple example ----------------------------------------------------------

data(fakeexperiment)
data(faketree)
ans &lt;- new_aphylo(fakeexperiment[,2:3], tree = as.phylo(faketree))
 
# We can visualize it
plot(ans)
</code></pre>

<hr>
<h2 id='aphylo-index'>Indexing aphylo objects</h2><span id='topic+aphylo-index'></span><span id='topic++5B.aphylo'></span><span id='topic++5B+3C-.aphylo'></span>

<h3>Description</h3>

<p>Indexing aphylo objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aphylo'
x[i, j, drop = FALSE]

## S3 replacement method for class 'aphylo'
x[i, j] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aphylo-index_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+aphylo">aphylo</a>.</p>
</td></tr>
<tr><td><code id="aphylo-index_+3A_i">i</code>, <code id="aphylo-index_+3A_j">j</code></td>
<td>
<p>Integer vector. Indices of genes or functions.</p>
</td></tr>
<tr><td><code id="aphylo-index_+3A_drop">drop</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code>, the function returns a matrix of
annotations. Otherwise an object of class <code>aphylo</code>.</p>
</td></tr>
<tr><td><code id="aphylo-index_+3A_value">value</code></td>
<td>
<p>Integer vector. Replacing values, can be either <code>c(0, 1, 9, NA)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The subsetting method allows selecting one or more annotations from
the <a href="#topic+aphylo">aphylo</a> object. Whenever <code>i</code> is specified, then aphylo returns the corresponding
annotations.
</p>


<h3>Value</h3>


<ul>
<li><p> When indexing with <code>i</code>: A data frame with the annotations of the
selected genes.
</p>
</li>
<li><p> When only indexing with <code>j</code> (<code>drop = FALSE</code>): An <code>aphylo</code> object with the selected sets of
annotations.
</p>
</li>
<li><p> When only indexing with <code>j</code> (<code>drop = TRUE</code>): A data.frame with the selected
annotations.
</p>
</li>
<li><p> When indexing on both <code>i</code> and <code>j</code>: A data.frame with the selected genes and annotations.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12312)
atree &lt;- raphylo(50, P = 4)
atree[1:10,]
atree[,2:3]
atree[, 2:3, drop = TRUE]
atree[1:10, 2:3]


</code></pre>

<hr>
<h2 id='aphylo-info'>Information about <code>aphylo</code> and <code>multiAphylo</code> objects</h2><span id='topic+aphylo-info'></span><span id='topic+Nann'></span><span id='topic+Nannotated'></span><span id='topic+Ntrees'></span>

<h3>Description</h3>

<p>Information about annotations, in particular, number of annotations (<code>Nann</code>),
number of annotated leaves (<code>Nannotated</code>), number of unnanotated leaves
(<code>Nunannotated</code>), and number of trees (<code>Ntrees</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Nann(phy)

Nannotated(phy)

Ntrees(phy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aphylo-info_+3A_phy">phy</code></td>
<td>
<p>Either an object of class <a href="#topic+aphylo">aphylo</a>, <a href="#topic+multiAphylo">multiAphylo</a>, or
<a href="#topic+aphylo_estimates">aphylo_estimates</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>phy</code> is of class <code>aphylo</code>, then a single scalar.
otherwise, if <code>phy</code> is of class <code>multiAphylo</code>
</p>


<h3>See Also</h3>

<p>Other information: 
<code><a href="#topic+ape-methods">ape-methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generating data for the example
set.seed(223)
dat &lt;- rmultiAphylo(10, n = 5, P = 2)
Nann(dat)
Nannotated(dat)
Ntrees(dat)
</code></pre>

<hr>
<h2 id='aphylo-methods'>Plot and print methods for <code>aphylo</code> objects</h2><span id='topic+aphylo-methods'></span><span id='topic+plot.aphylo'></span>

<h3>Description</h3>

<p>Plot and print methods for <code>aphylo</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aphylo'
plot(
  x,
  y = NULL,
  prop = 0.15,
  node.type.col = c(dupl = "black", other = "gray"),
  node.type.size = c(dupl = 0, other = 0),
  rect.args = list(),
  as_ci = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aphylo-methods_+3A_x">x</code></td>
<td>
<p>An object of class <code>aphylo</code>.</p>
</td></tr>
<tr><td><code id="aphylo-methods_+3A_y">y</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="aphylo-methods_+3A_prop">prop</code></td>
<td>
<p>Numeric scalar between 0 and 1. Proportion of the device that the
annotations use in <code>plot.aphylo</code>.</p>
</td></tr>
<tr><td><code id="aphylo-methods_+3A_node.type.col">node.type.col</code>, <code id="aphylo-methods_+3A_node.type.size">node.type.size</code></td>
<td>
<p>Vectors of length 2. In the case of
<code>node.type.col</code> the color of the duplication and other nodes. <code>node.type.size</code>
sets the size of circles.</p>
</td></tr>
<tr><td><code id="aphylo-methods_+3A_rect.args">rect.args</code></td>
<td>
<p>List of arguments passed to <a href="graphics.html#topic+rect">graphics::rect</a>.</p>
</td></tr>
<tr><td><code id="aphylo-methods_+3A_as_ci">as_ci</code></td>
<td>
<p>Integer vector. Internal use only.</p>
</td></tr>
<tr><td><code id="aphylo-methods_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <a href="ape.html#topic+plot.phylo">ape::plot.phylo</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plot.aphylo</code> function is a wrapper of <a href="ape.html#topic+plot.phylo">ape::plot.phylo</a>.
</p>


<h3>Value</h3>

<p>In the case of <code>plot.aphylo</code>, <code>NULL</code>.
</p>


<h3>See Also</h3>

<p>Other aphylo methods: 
<code><a href="#topic+aphylo-class">aphylo-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(7172)
atree &lt;- raphylo(20)
plot(atree)
</code></pre>

<hr>
<h2 id='aphylo-model'>Formulas in <code>aphylo</code></h2><span id='topic+aphylo-model'></span><span id='topic+aphylo-formula'></span><span id='topic+eta'></span><span id='topic+psi'></span><span id='topic+Pi'></span><span id='topic+mu_d'></span><span id='topic+mu_s'></span><span id='topic+aphylo_formula'></span>

<h3>Description</h3>

<p>This function the the workhorse behind the likelihood function. It creates
arbitrary models by modifying the call to <code><a href="#topic+LogLike">LogLike()</a></code> function according to
what the user specifies as model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eta(..., env)

psi(..., env)

Pi(..., env)

mu_d(..., env)

mu_s(..., env)

aphylo_formula(fm, params, priors, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aphylo-model_+3A_...">...</code></td>
<td>
<p>Either 0, 1 or both. Depending on the parameter, the index of the
model parameter that will be set as fixed.</p>
</td></tr>
<tr><td><code id="aphylo-model_+3A_env">env</code></td>
<td>
<p>Environment (not to be called by the user).</p>
</td></tr>
<tr><td><code id="aphylo-model_+3A_fm">fm</code></td>
<td>
<p>A formula. Model of the type <code style="white-space: pre;">&#8288;&lt;aphylo-object&gt; ~ &lt;parameters&gt;&#8288;</code> (see
examples).</p>
</td></tr>
<tr><td><code id="aphylo-model_+3A_params">params</code></td>
<td>
<p>Numeric vector with model parameters.</p>
</td></tr>
<tr><td><code id="aphylo-model_+3A_priors">priors</code></td>
<td>
<p>(optional) A function. Prior for the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>fun</code> A function. The log-likelihood function.
</p>
</li>
<li> <p><code>fixed</code> Logical vector.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12)
x &lt;- raphylo(10)

# Baseline model
aphylo_formula(x ~ mu_d)

# Mislabeling probabilities
aphylo_formula(x ~ mu_d + psi)

# Different probabilities for speciation and duplication node
# (only works if you have both types)
aphylo_formula(x ~ mu_d + mu_s + psi)

# Mislabeling probabilities and etas(fixed)
aphylo_formula(x ~ mu_d + psi + eta(0, 1))

# Mislabeling probabilities and Pi 
aphylo_formula(x ~ mu_d + psi + Pi)

</code></pre>

<hr>
<h2 id='as.phylo'>Extensions to the <code>as.phylo</code> function</h2><span id='topic+as.phylo'></span><span id='topic+as.phylo.matrix'></span><span id='topic+as.phylo.aphylo'></span>

<h3>Description</h3>

<p>This function takes an edgelist and recodes (relabels) the nodes following
<a href="https://CRAN.R-project.org/package=ape"><span class="pkg">ape</span></a>'s coding convention.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
as.phylo(x, edge.length = NULL, root.edge = NULL, ...)

## S3 method for class 'aphylo'
as.phylo(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.phylo_+3A_x">x</code></td>
<td>
<p>Either an edgelist or an object of class <a href="#topic+aphylo">aphylo</a>.</p>
</td></tr>
<tr><td><code id="as.phylo_+3A_edge.length">edge.length</code></td>
<td>
<p>A vector with branch lengths  (optional).</p>
</td></tr>
<tr><td><code id="as.phylo_+3A_root.edge">root.edge</code></td>
<td>
<p>A numeric scalar with the length for the root node (optional).</p>
</td></tr>
<tr><td><code id="as.phylo_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer matrix of the same dimmension as <code>edges</code> with the following
aditional attribute:
</p>
<table role = "presentation">
<tr><td><code>labels</code></td>
<td>
<p>Named integer vector of size <code>n</code>. Original labels of the edgelist
where the first <code>n</code> are leaf nodes, <code>n+1</code> is the root node, and the reminder
are the internal nodes.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# A simple example ----------------------------------------------------------
# This tree has a coding different from ape's

mytree &lt;- matrix(c(1, 2, 1, 3, 2, 4, 2, 5), byrow = TRUE, ncol=2)
mytree

ans &lt;- as.phylo(mytree)
ans
plot(ans)


</code></pre>

<hr>
<h2 id='auc'>Area Under the Curve and Receiving Operating Curve</h2><span id='topic+auc'></span><span id='topic+print.aphylo_auc'></span><span id='topic+plot.aphylo_auc'></span>

<h3>Description</h3>

<p>The AUC values are computed by approximation using the area of the polygons formed
under the ROC curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auc(pred, labels, nc = 200L, nine_na = TRUE)

## S3 method for class 'aphylo_auc'
print(x, ...)

## S3 method for class 'aphylo_auc'
plot(x, y = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="auc_+3A_pred">pred</code></td>
<td>
<p>A numeric vector with the predictions of the model. Values must
range between 0 and 1.</p>
</td></tr>
<tr><td><code id="auc_+3A_labels">labels</code></td>
<td>
<p>An integer vector with the labels (truth). Values should be either
0 or 1.</p>
</td></tr>
<tr><td><code id="auc_+3A_nc">nc</code></td>
<td>
<p>Integer. Number of cutoffs to use for computing the rates and AUC.</p>
</td></tr>
<tr><td><code id="auc_+3A_nine_na">nine_na</code></td>
<td>
<p>Logical. When <code>TRUE</code>, 9 is treated as <code>NA</code>.</p>
</td></tr>
<tr><td><code id="auc_+3A_x">x</code></td>
<td>
<p>An object of class <code>aphylo_auc</code>.</p>
</td></tr>
<tr><td><code id="auc_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the method.</p>
</td></tr>
<tr><td><code id="auc_+3A_y">y</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list:
</p>

<ul>
<li> <p><code>tpr</code> A vector of length <code>nc</code> with the True Positive Rates.
</p>
</li>
<li> <p><code>tnr</code> A vector of length <code>nc</code> with the True Negative Rates.
</p>
</li>
<li> <p><code>fpr</code> A vector of length <code>nc</code> with the False Positive Rates.
</p>
</li>
<li> <p><code>fnr</code> A vector of length <code>nc</code> with the False Negative Rates.
</p>
</li>
<li> <p><code>auc</code> A numeric value. Area Under the Curve.
</p>
</li>
<li> <p><code>cutoffs</code> A vector of length <code>nc</code> with the cutoffs used.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(8381)
x   &lt;- rdrop_annotations(raphylo(50), .3)
ans &lt;- aphylo_mcmc(x ~ mu_d + mu_s + Pi)
ans_auc &lt;- auc(predict(ans, loo = TRUE), x[,1,drop=TRUE])
print(ans_auc)
plot(ans_auc)
</code></pre>

<hr>
<h2 id='balance_ann'>Functional balance of a tree</h2><span id='topic+balance_ann'></span>

<h3>Description</h3>

<p>This function computes the distance between .5 and the observed proportion
of ones for each function in a tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balance_ann(phy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="balance_ann_+3A_phy">phy</code></td>
<td>
<p>An object of class <a href="#topic+aphylo">aphylo</a> or <a href="#topic+multiAphylo">multiAphylo</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functional balance is defined as follows
</p>
<p style="text-align: center;"><code class="reqn">%
P^{-1}\sum_{p}\left(1 - \left|0.5 - N^{-1}\sum_n a_{np}\right|\right)
</code>
</p>

<p>Where <code>A</code> is the matrix of annotations.
</p>
<p>With values ranging between 0 and 1, one been perfect balance, this is, equal
number of zeros and ones in the annotations. In the case of multiple functions,
as noted in the formula, the balance is the average across functions.
</p>


<h3>Value</h3>

<p>If <code>phy</code> is an object of class <code>phylo</code>, a single scalar, otherwise,
it returns a vector of length <code><a href="#topic+Ntrees">Ntrees</a></code><code>(phy)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- raphylo(20, P = 2)
balance_ann(x)

balance_ann(c(x, x))

</code></pre>

<hr>
<h2 id='bprior'>Default priors for <a href="#topic+aphylo_mcmc">aphylo_mcmc</a></h2><span id='topic+bprior'></span><span id='topic+uprior'></span>

<h3>Description</h3>

<p>Convenient wrappers to be used with the <code>aphylo</code> estimation methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bprior(shape1 = 1, shape2 = 9, ...)

uprior()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bprior_+3A_shape1">shape1</code>, <code id="bprior_+3A_shape2">shape2</code>, <code id="bprior_+3A_...">...</code></td>
<td>
<p>Arguments passed to <a href="stats.html#topic+Beta">stats::dbeta</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>In the case of <code>bprior</code>, a wrapper of the function <a href="stats.html#topic+Beta">stats::dbeta</a>.
<code>uprior</code> returns a function <code>function(p) 1</code> (the uniform prior)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bprior(1, 9)
uprior()
</code></pre>

<hr>
<h2 id='dist2root'>Pointer to <code>pruner</code></h2><span id='topic+dist2root'></span><span id='topic+get_postorder'></span><span id='topic+new_aphylo_pruner'></span><span id='topic+aphylo_pruner'></span>

<h3>Description</h3>

<p>Creates an external pointer to an object of class <code>aphylo_pruner</code>. This is mostly
used to compute the model's likelihood function faster by reusing underlying
C++ class objects to store probability matrices and data. This is intended
for internal use only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist2root(ptr)

get_postorder(ptr)

new_aphylo_pruner(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist2root_+3A_ptr">ptr</code></td>
<td>
<p>An object of class <code>aphylo_pruner</code>.</p>
</td></tr>
<tr><td><code id="dist2root_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+aphylo">aphylo</a> or <a href="#topic+multiAphylo">multiAphylo</a>.</p>
</td></tr>
<tr><td><code id="dist2root_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The underlying implementation of the pruning function is based on the
pruner C++ library that implements Felsenstein's tree pruning algorithm.
See <a href="https://github.com/USCbiostats/pruner">https://github.com/USCbiostats/pruner</a>.
</p>


<h3>Value</h3>

<p><code>dist2root</code>: An integer vector with the number of steps from each
node (internal or not) to the root node.
</p>
<p><code>get_postorder</code>: An integer vector with the postorder sequence
for pruning the tree (indexed from 0).
</p>
<p>The function <code>new_aphylo_pruner</code> returns an object of class
<code>aphylo_pruner</code> or <code>multiAphylo_pruner</code>, depending on the class of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x  &lt;- raphylo(20) 
pruner &lt;- new_aphylo_pruner(x)

# Computing loglike
LogLike(
  pruner,
  psi  = c(.10, .20),
  mu_d = c(.90, .80),
  mu_s = c(.10, .05),
  Pi   = .05,
  eta  = c(.90, .80)
  )
  
dist2root(pruner)
get_postorder(pruner)
</code></pre>

<hr>
<h2 id='fakeexperiment'>Fake Experimental Data</h2><span id='topic+fakeexperiment'></span>

<h3>Description</h3>

<p>A fake dataset containing 2 functional state of the leaf nodes. Each
function can have either 0 (unactive), 1 (active) or 9 (n/a).
This dataset is inteded for testing only.
</p>


<h3>Format</h3>

<p>A data frame with 4 rows and 3 variables:
</p>

<dl>
<dt>f1</dt><dd><p>State of function 1.</p>
</dd>
<dt>f2</dt><dd><p>State of function 1.</p>
</dd>
<dt>LeafId</dt><dd><p>Integer, ID of the leaf.</p>
</dd>
</dl>



<h3>Source</h3>

<p>BiostatsUSC
</p>

<hr>
<h2 id='faketree'>Fake Phylogenetic Tree</h2><span id='topic+faketree'></span>

<h3>Description</h3>

<p>A fake dataset containing the parent-offspring relations between genes.
This dataset is inteded for testing only.
</p>


<h3>Format</h3>

<p>A data frame with 6 rows and 2 variables:
</p>

<dl>
<dt>NodeId</dt><dd><p>Integer, ID of the offspring.</p>
</dd>
<dt>ParentId</dt><dd><p>Integer, ID of the parent.</p>
</dd>
</dl>



<h3>Source</h3>

<p>BiostatsUSC
</p>

<hr>
<h2 id='imputate_duplications'>Impute duplication events based on a vector of species</h2><span id='topic+imputate_duplications'></span>

<h3>Description</h3>

<p>Uses a simple algorithm to impute duplication events based on the
terminal genes of the tree. An interior node is a duplication event
if a specie has two or more leafs within its clade.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputate_duplications(tree, species)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imputate_duplications_+3A_tree">tree</code></td>
<td>
<p>An object of class <a href="ape.html#topic+read.tree">ape::phylo</a>.</p>
</td></tr>
<tr><td><code id="imputate_duplications_+3A_species">species</code></td>
<td>
<p>A character vector of length <code>ape::Ntip(tree)</code> (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will take a vector of species and, based on that, assign
duplication events throughout the interior nodes. An interior node is labeled
as a duplication event if two or more of the leaves within it are from the
same species.
</p>


<h3>Value</h3>

<p>A logical vector of length <code>ape::Nnode(tree, internal.only = FALSE)</code>
with <code>TRUE</code> to indicate that the corresponding node is a duplication event.
The order matches that in the input tree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data from PANTHER
path &lt;- system.file("tree.tree", package="aphylo")
ptree &lt;- read_panther(path)

# Extracting the species
sp &lt;- gsub(".+[:]|[|].+", "" , ptree$tree$tip.label)

# Imputing duplications
imputate_duplications(ptree$tree, species = sp)
</code></pre>

<hr>
<h2 id='list_offspring'>List each nodes' offspring or parent</h2><span id='topic+list_offspring'></span><span id='topic+list_parents'></span>

<h3>Description</h3>

<p>For each node in a tree, the functions <code>list_offspring</code> and <code>list_parents</code>
lists all its offspring and parents, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_offspring(x)

list_parents(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="list_offspring_+3A_x">x</code></td>
<td>
<p>An object of class <code>phylo</code> or <code>aphylo</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of length <code>n</code> (total number of nodes).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A simple example with phylo tree ------------------------------------------

set.seed(4)
x &lt;- ape::rtree(10)
list_offspring(x)

</code></pre>

<hr>
<h2 id='LogLike'>Likelihood of an observed annotated phylogenetic tree</h2><span id='topic+LogLike'></span>

<h3>Description</h3>

<p>This function computes the log-likelihood of the chosen parameters given
a particular dataset. The arguments <code>annotations</code>, and <code>offspring</code>
should be as those returned by <code><a href="#topic+new_aphylo">new_aphylo()</a></code>.
For complete parameter estimation see <a href="#topic+aphylo_estimates">aphylo_estimates</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LogLike(tree, psi, mu_d, mu_s, eta, Pi, verb_ans = TRUE, check_dims = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LogLike_+3A_tree">tree</code></td>
<td>
<p>A phylogenetic tree of class <a href="#topic+aphylo">aphylo</a>.</p>
</td></tr>
<tr><td><code id="LogLike_+3A_psi">psi</code></td>
<td>
<p>Numeric vector of length 2. Misclasification probabilities. (see <code><a href="#topic+LogLike">LogLike</a></code>).</p>
</td></tr>
<tr><td><code id="LogLike_+3A_mu_d">mu_d</code>, <code id="LogLike_+3A_mu_s">mu_s</code></td>
<td>
<p>Numeric vector of length 2. Gain/loss probabilities (see <code><a href="#topic+LogLike">LogLike</a></code>).</p>
</td></tr>
<tr><td><code id="LogLike_+3A_eta">eta</code></td>
<td>
<p>Numeric vector of length 2. Annotation bias probabilities (see <code><a href="#topic+LogLike">LogLike</a></code>).</p>
</td></tr>
<tr><td><code id="LogLike_+3A_pi">Pi</code></td>
<td>
<p>Numeric scalar. Root node probability of having the function (see <code><a href="#topic+LogLike">LogLike</a></code>).</p>
</td></tr>
<tr><td><code id="LogLike_+3A_verb_ans">verb_ans</code></td>
<td>
<p>Logical scalar. When <code>FALSE</code> (default) the function
returns a list with a single scalar (the log-likelihood).</p>
</td></tr>
<tr><td><code id="LogLike_+3A_check_dims">check_dims</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> (default) the function
checks the dimmension of the passed parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameters to estimate are described as follows:
</p>

<ol>
<li><p><code>psi</code>: A vector of length 2 with <code class="reqn">\psi_0</code> and
<code class="reqn">\psi_1</code>, which are the misclassification probabilities fo
<code class="reqn">s_p=0</code> and <code class="reqn">s_p=1</code>
respectively.
</p>
</li>
<li><p><code>mu_d</code>, <code>mu_s</code>: A vector of length 2 with <code class="reqn">\mu_0</code> and
<code class="reqn">\mu_1</code> which are the gain and loss probabilities respectively.
The subscript d denotes duplication nodes and s speciation node.
</p>
</li>
<li><p><code>eta</code>: A vector of length 2 with <code class="reqn">\eta_0</code> and
<code class="reqn">\eta_1</code> which are the annotation bias probabilities.
</p>
</li>
<li><p><code>Pi</code>: A numeric scalar which for which equals the probability
of the root node having the function.
</p>
</li></ol>



<h3>Value</h3>

<p>A list of class <code>phylo_LogLik</code> with the following elements:
</p>
<table role = "presentation">
<tr><td><code>S</code></td>
<td>
<p>An integer matrix of size <code class="reqn">2^p\times p</code> as returned
by <code><a href="#topic+states">states</a></code>.</p>
</td></tr>
<tr><td><code>Pr</code></td>
<td>
<p>A numeric matrix of size <code class="reqn">G\times 2^p</code> with node/state
probabilities.</p>
</td></tr>
<tr><td><code>ll</code></td>
<td>
<p>A numeric scalar with the log-likelihood value given the chosen
parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='mislabel'>Switch labels acoording to mislabeling probabilities</h2><span id='topic+mislabel'></span>

<h3>Description</h3>

<p>Switch labels acoording to mislabeling probabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mislabel(atree, psi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mislabel_+3A_atree">atree</code></td>
<td>
<p>An object of class <a href="#topic+aphylo">aphylo</a>.</p>
</td></tr>
<tr><td><code id="mislabel_+3A_psi">psi</code></td>
<td>
<p>Numeric vector of length 2. Misclasification probabilities. (see <code><a href="#topic+LogLike">LogLike</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+aphylo">aphylo</a> with modified labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(131)
x &lt;- raphylo(5, P=2, psi=c(0,0))
x$tip.annotation

# Flipping 0s to 1s and vice versa
mislabel(x, psi = c(1,1))$tip.annotation

</code></pre>

<hr>
<h2 id='multiAphylo'>Building Lists of Annotated Trees</h2><span id='topic+multiAphylo'></span><span id='topic+c.aphylo'></span><span id='topic+print.multiAphylo'></span>

<h3>Description</h3>

<p>This is equivalent to what <a href="ape.html#topic+c.phylo">ape::c.phylo</a> does.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aphylo'
c(...)

## S3 method for class 'multiAphylo'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multiAphylo_+3A_...">...</code></td>
<td>
<p>One or several object of class <code>aphylo</code> or <code>multiAPhylo</code>. Ignored
in the case of <code>print.multiAphylo</code>.</p>
</td></tr>
<tr><td><code id="multiAphylo_+3A_x">x</code></td>
<td>
<p>An object of class <code>multiAphylo</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>multiAphylo</code>. Each element corresponds to a single <code>aphylo</code>
object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fakeexperiment)
data(faketree)
ans &lt;- new_aphylo(fakeexperiment[,2:3], tree = as.phylo(faketree))
c(ans, ans)
</code></pre>

<hr>
<h2 id='panther-tree'>Reads PANTHER db trees</h2><span id='topic+panther-tree'></span><span id='topic+PANTHER'></span><span id='topic+PANTHERDB'></span><span id='topic+read_panther'></span><span id='topic+read.panther'></span>

<h3>Description</h3>

<p>The PANTHER Project handles a modified version of newick tree files which,
besides of the tree structure, includes the type of node and ancestor
labels. This function is a wrapper of <code><a href="ape.html#topic+read.tree">ape::read.tree()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_panther(x, tree.reader = ape::read.tree, ...)

read.panther(x, tree.reader = ape::read.tree, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="panther-tree_+3A_x">x</code></td>
<td>
<p>Character scalar. Full path to the panther file.</p>
</td></tr>
<tr><td><code id="panther-tree_+3A_tree.reader">tree.reader</code></td>
<td>
<p>Function that will be used to read the tree file.
It can be either <code>ape::read.tree</code> or <code>rncl::read_newick_phylo</code>.</p>
</td></tr>
<tr><td><code id="panther-tree_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="ape.html#topic+read.tree">ape::read.tree()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of a data.frame and a <code>phylo</code> object. The
data.frame has the following columns:
</p>
<table role = "presentation">
<tr><td><code>branch_length</code></td>
<td>
<p>Numeric vector. Length of the branch to its parent node.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Character vector. Can be either <code>"S"</code> (speciation), <code>"D"</code>
(duplication), or <code>"T"</code> (horizontal transfer).</p>
</td></tr>
<tr><td><code>ancestor</code></td>
<td>
<p>Character vector. Name of the ancestor.</p>
</td></tr>
</table>
<p>The nodeids can be identified using the rownames.
</p>


<h3>See Also</h3>

<p>Other reading: 
<code><a href="#topic+read_nhx">read_nhx</a>()</code>,
<code><a href="#topic+read_pli">read_pli</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("tree.tree", package="aphylo")
read_panther(path)

</code></pre>

<hr>
<h2 id='plot_logLik'>Plot Log-Likelihood function of the model</h2><span id='topic+plot_logLik'></span><span id='topic+plot_logLik.aphylo'></span><span id='topic+plot_logLik.formula'></span><span id='topic+plot_logLik.aphylo_estimates'></span>

<h3>Description</h3>

<p>Plot Log-Likelihood function of the model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_logLik(x, sets, ...)

## S3 method for class 'aphylo'
plot_logLik(x, sets, ...)

## S3 method for class 'formula'
plot_logLik(x, sets, ...)

## S3 method for class 'aphylo_estimates'
plot_logLik(x, sets, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_logLik_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+aphylo">aphylo()</a></code></p>
</td></tr>
<tr><td><code id="plot_logLik_+3A_sets">sets</code></td>
<td>
<p>(optional) Character matrix of size <code style="white-space: pre;">&#8288;2 x # of combinations&#8288;</code>.
contains the names of the pairs to plot. If nothing passed, the function will
generate all possible combinations as <code>combn(names(params), 2)</code>.</p>
</td></tr>
<tr><td><code id="plot_logLik_+3A_...">...</code></td>
<td>
<p>Aditional parameters to be passed to <code>plotfun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL (invisible). Generates a plot of the loglikelihood of the model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading data
data(fakeexperiment)
data(faketree)
O &lt;- new_aphylo(fakeexperiment[,2:3], tree = as.phylo(faketree))

# Baseline plot (all parameters but Pi)
plot_logLik(O)

# No psi parameter
plot_logLik(O ~ mu_d + Pi + eta)

</code></pre>

<hr>
<h2 id='plot_multivariate'>Multiavariate plot (surface)</h2><span id='topic+plot_multivariate'></span>

<h3>Description</h3>

<p>Multiavariate plot (surface)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_multivariate(
  fun,
  params,
  domain,
  sets,
  nlevels = 20,
  args = list(),
  plotfun = graphics::image,
  plot = TRUE,
  postplot = function(params, res) {
     points(params, cex = 2, pch = 3, col = "red")

    },
  mfrow = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_multivariate_+3A_fun">fun</code></td>
<td>
<p>A function that receives 2 or more parameters and returns a single
number.</p>
</td></tr>
<tr><td><code id="plot_multivariate_+3A_params">params</code></td>
<td>
<p>Numeric vector with the default parameters.</p>
</td></tr>
<tr><td><code id="plot_multivariate_+3A_domain">domain</code></td>
<td>
<p>(optional) Named list with as many elements as parameters. Specifies the
domain of the function.</p>
</td></tr>
<tr><td><code id="plot_multivariate_+3A_sets">sets</code></td>
<td>
<p>(optional) Character matrix of size <code style="white-space: pre;">&#8288;2 x # of combinations&#8288;</code>.
contains the names of the pairs to plot. If nothing passed, the function will
generate all possible combinations as <code>combn(names(params), 2)</code>.</p>
</td></tr>
<tr><td><code id="plot_multivariate_+3A_nlevels">nlevels</code></td>
<td>
<p>Integer. Number of levels.</p>
</td></tr>
<tr><td><code id="plot_multivariate_+3A_args">args</code></td>
<td>
<p>List of named arguments to be passed to <code>fun</code>.</p>
</td></tr>
<tr><td><code id="plot_multivariate_+3A_plotfun">plotfun</code></td>
<td>
<p>Function that will be used to plot <code style="white-space: pre;">&#8288;x,y,z&#8288;</code>.</p>
</td></tr>
<tr><td><code id="plot_multivariate_+3A_plot">plot</code></td>
<td>
<p>Logical. When <code>FALSE</code> skips plotting.</p>
</td></tr>
<tr><td><code id="plot_multivariate_+3A_postplot">postplot</code></td>
<td>
<p>Function to be called after <code>plotfun</code>. Should recieve a vector
with the current parameters.</p>
</td></tr>
<tr><td><code id="plot_multivariate_+3A_mfrow">mfrow</code></td>
<td>
<p>Passed to <a href="graphics.html#topic+par">graphics::par</a>.</p>
</td></tr>
<tr><td><code id="plot_multivariate_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>plotfun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length <code>length(sets)</code>, each with the following:
</p>

<ul>
<li><p> x,y,z vectors of coordinates.
</p>
</li>
<li><p> xlab,ylab vectors with the corresponding labels.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example: A model with less parameters
set.seed(1231)
x &lt;- raphylo(20)
ans &lt;- aphylo_mcmc(
  x ~ psi + mu_d + mu_s,
  control = list(nsteps = 1e3, burnin = 0)
  )

# Creating the multivariate plot (using by default image)
plot_multivariate(
  function(...) {
    ans$fun(unlist(list(...)), priors = ans$priors, dat = ans$dat, verb_ans = FALSE)
  },
  sets = matrix(c("mu_d0", "mu_d1", "psi0", "psi1"), ncol=2),
  params = ans$par
)
</code></pre>

<hr>
<h2 id='plot.aphylo_prediction_score'>Visualize predictions</h2><span id='topic+plot.aphylo_prediction_score'></span><span id='topic+plot-prediction'></span>

<h3>Description</h3>

<p>Visualize predictions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aphylo_prediction_score'
plot(
  x,
  y = NULL,
  main = "Prediction Accuracy: Observed versus predicted values",
  main.colorkey = "Probability of Functional Annotation",
  which.fun = seq_len(ncol(x$expected)),
  include.labels = NULL,
  labels.col = "black",
  leafs_only = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.aphylo_prediction_score_+3A_x">x</code></td>
<td>
<p>An object of class <code>aphylo_prediction_score</code>.</p>
</td></tr>
<tr><td><code id="plot.aphylo_prediction_score_+3A_y">y</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="plot.aphylo_prediction_score_+3A_main">main</code></td>
<td>
<p>Passed to <code>title</code>.</p>
</td></tr>
<tr><td><code id="plot.aphylo_prediction_score_+3A_main.colorkey">main.colorkey</code></td>
<td>
<p>Character scalar. Title of the colorkey (optional).</p>
</td></tr>
<tr><td><code id="plot.aphylo_prediction_score_+3A_which.fun">which.fun</code></td>
<td>
<p>Integer vector. Which function to plot.</p>
</td></tr>
<tr><td><code id="plot.aphylo_prediction_score_+3A_include.labels">include.labels</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code>, draws nice labels
at each slice which by default are specified as the rownames of <code>x$expected</code>.
This is mostly useful when the number of predictions is small.</p>
</td></tr>
<tr><td><code id="plot.aphylo_prediction_score_+3A_labels.col">labels.col</code></td>
<td>
<p>Character scalar. Color of the labels.</p>
</td></tr>
<tr><td><code id="plot.aphylo_prediction_score_+3A_leafs_only">leafs_only</code></td>
<td>
<p>Logical. When <code>TRUE</code> (default) only plots the leaf nodes.</p>
</td></tr>
<tr><td><code id="plot.aphylo_prediction_score_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>include.labels = NULL</code> and <code>ncol(x$expected) &gt; 40</code>,
then <code>include.labels=FALSE</code> by default.
</p>


<h3>Value</h3>

<p>NULL (invisible) Generates a plot of the predictions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(8783)
atree  &lt;- raphylo(29)
ans    &lt;- aphylo_mle(atree ~ mu_d + mu_s + Pi)
pred_s &lt;- prediction_score(ans)

pred_s
plot(pred_s)
</code></pre>

<hr>
<h2 id='posterior-probabilities'>Posterior probabilities based on parameter estimates</h2><span id='topic+posterior-probabilities'></span><span id='topic+predict.aphylo_estimates'></span><span id='topic+predict_pre_order'></span><span id='topic+predict_pre_order.aphylo_estimates'></span><span id='topic+predict_pre_order.aphylo'></span><span id='topic+predict_brute_force'></span>

<h3>Description</h3>

<p>The function <code>predict_pre_order</code> uses a pre-order algorithm to compute the
posterior probabilities, whereas the <code>predict_brute_force</code> computes posterior
probabilities generating all possible cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aphylo_estimates'
predict(
  object,
  which.tree = NULL,
  ids = NULL,
  newdata = NULL,
  params = stats::coef(object),
  loo = TRUE,
  nsamples = 1L,
  centiles = c(0.025, 0.5, 0.975),
  cl = NULL,
  ...
)

predict_pre_order(x, ...)

## S3 method for class 'aphylo_estimates'
predict_pre_order(
  x,
  params = stats::coef(x),
  which.tree = 1:Ntrees(x),
  ids = lapply(Ntip(x)[which.tree], seq_len),
  loo = TRUE,
  nsamples = 1L,
  centiles = c(0.025, 0.5, 0.975),
  ncores = 1L,
  cl = NULL,
  ...
)

## S3 method for class 'aphylo'
predict_pre_order(x, psi, mu_d, mu_s, eta, Pi, ...)

predict_brute_force(atree, psi, mu_d, mu_s, Pi, force = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="posterior-probabilities_+3A_which.tree">which.tree</code></td>
<td>
<p>Integer scalar. Which tree to include in the prediction.</p>
</td></tr>
<tr><td><code id="posterior-probabilities_+3A_ids">ids</code></td>
<td>
<p>Integer vector. Ids (positions) of the nodes that need to be
predicted (see details.)</p>
</td></tr>
<tr><td><code id="posterior-probabilities_+3A_newdata">newdata</code></td>
<td>
<p>(optional) An aphylo object.</p>
</td></tr>
<tr><td><code id="posterior-probabilities_+3A_params">params</code></td>
<td>
<p>A numeric vector with the corresponding parameters.</p>
</td></tr>
<tr><td><code id="posterior-probabilities_+3A_loo">loo</code></td>
<td>
<p>Logical scalar. When <code>loo = TRUE</code>, predictions are preformed
similar to what a leave-one-out cross-validation scheme would be done
(see <a href="#topic+predict.aphylo_estimates">predict.aphylo_estimates</a>).</p>
</td></tr>
<tr><td><code id="posterior-probabilities_+3A_nsamples">nsamples</code></td>
<td>
<p>Integer scalar. When greater than one, the prediction is done
using a random sample from the MCMC chain. This only works if the model was
fitted using MCMC, of course.</p>
</td></tr>
<tr><td><code id="posterior-probabilities_+3A_centiles">centiles</code></td>
<td>
<p>Used together with <code>nsamples</code>, this indicates the centiles
to be computed from the distribution of outcomes.</p>
</td></tr>
<tr><td><code id="posterior-probabilities_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="posterior-probabilities_+3A_ncores">ncores</code>, <code id="posterior-probabilities_+3A_cl">cl</code></td>
<td>
<p>Passed to <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
<tr><td><code id="posterior-probabilities_+3A_psi">psi</code></td>
<td>
<p>Numeric vector of length 2. Misclasification probabilities. (see <code><a href="#topic+LogLike">LogLike</a></code>).</p>
</td></tr>
<tr><td><code id="posterior-probabilities_+3A_mu_d">mu_d</code>, <code id="posterior-probabilities_+3A_mu_s">mu_s</code></td>
<td>
<p>Numeric vector of length 2. Gain/loss probabilities (see <code><a href="#topic+LogLike">LogLike</a></code>).</p>
</td></tr>
<tr><td><code id="posterior-probabilities_+3A_eta">eta</code></td>
<td>
<p>Numeric vector of length 2. Annotation bias probabilities (see <code><a href="#topic+LogLike">LogLike</a></code>).</p>
</td></tr>
<tr><td><code id="posterior-probabilities_+3A_pi">Pi</code></td>
<td>
<p>Numeric scalar. Root node probability of having the function (see <code><a href="#topic+LogLike">LogLike</a></code>).</p>
</td></tr>
<tr><td><code id="posterior-probabilities_+3A_atree">atree</code>, <code id="posterior-probabilities_+3A_x">x</code>, <code id="posterior-probabilities_+3A_object">object</code></td>
<td>
<p>Either a tree of class <a href="#topic+aphylo">aphylo</a> or an object of class <a href="#topic+aphylo_estimates">aphylo_estimates</a></p>
</td></tr>
<tr><td><code id="posterior-probabilities_+3A_force">force</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> it will try to compute the brute-force
probabilities for trees with more than 7 nodes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>predict_brute_force</code> is only intended for testing. For predictions
after estimating the model, see <a href="#topic+predict.aphylo_estimates">predict.aphylo_estimates</a>.
</p>
<p>In the case of the parameter <code>loo</code> (leave-one-out), while making tip-level
predictions, at each leaf the algorithm will drop annotations regarding that
leaf, making its prediction using all the available information except the
one include in such leaf.
</p>
<p>The <code>predict_brute_force</code> function makes the (obviously) brute force
calculation of the probabilities. It will perform
It returns a list with the following:
</p>

<ul>
<li> <p><code>Pr</code> The conditional probabilities of observing a tree given a particular state
of the leave nodes. The size is given by (2^nnodes x 2^nleaves), each entry is
read as &quot;The probability of observing scenario i (row) given that the leaves have
state j (colum).&quot; The scenarios are specified in the <code>row</code> matrix returned by the
function.
</p>
</li>
<li> <p><code>row</code> Indicates the state of each node (columns) per scenario (row).
</p>
</li>
<li> <p><code>col</code> Indicates the state of each leaf node (columns) per potential leaf
scenario.
</p>
</li></ul>



<h3>Value</h3>

<p>In the case of the <code>predict</code> method, a <code>P</code> column numeric matrix
with values between <code class="reqn">[0,1]</code> (probabilities).
</p>


<h3>Prediction on specific nodes</h3>

<p>The <code>ids</code> parameter indicates for which nodes, both internal and tips, the
predictions should be made. By default, the function will only make predictions
on the leaf nodes.
</p>
<p>The ids follow <code>ape</code>'s convention, this is, <code>1:Ntips(x)</code>
are the leaf nodes, <code>Ntips(x) + 1L</code> is the root node, and everything else
are the interior nodes.
</p>
<p>Although the prediction algorithm is fast, indicating only
a subset of the nodes could make a difference when <code>loo = TRUE</code> and/or
<code>nsamples &gt; 1</code> (calculating a Credible/Confidence Interval.)
</p>
<p>In the case of <code>multiAphylo</code>, <code>ids</code> should be passed as a list of length
<code>Ntrees(x)</code>, with each element indicating the nodes. Otherwise, ids
are passed as an integer vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Single tree ---------------------------------------------------------------
set.seed(123)
atree &lt;- raphylo(10)

# Fitting the model with MLE
ans &lt;- aphylo_mle(atree ~ psi + mu_d + mu_s + Pi)

# Prediction on leaves
predict(ans)

# Prediction on all nodes (including root and interior)
predict(ans, ids = 1:Nnode(ans, internal.only = FALSE))

# Multiple trees (multiAphylo) ----------------------------------------------
atree &lt;- c(raphylo(10), raphylo(5))

# Fitting the model with MLE
ans &lt;- aphylo_mle(atree ~ psi + mu_d + mu_s + Pi)

# Prediction on leaves
predict(ans)

# Predicting only interior nodes
predict(ans, ids = list(11:19, 6:9))

</code></pre>

<hr>
<h2 id='prediction_score'>Calculate prediction score (quality of prediction)</h2><span id='topic+prediction_score'></span><span id='topic+prediction_score.aphylo_estimates'></span><span id='topic+print.aphylo_prediction_score'></span>

<h3>Description</h3>

<p>Calculate prediction score (quality of prediction)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prediction_score(x, expected, alpha0 = NULL, alpha1 = NULL, W = NULL, ...)

## S3 method for class 'aphylo_estimates'
prediction_score(
  x,
  expected = NULL,
  alpha0 = NULL,
  alpha1 = NULL,
  W = NULL,
  loo = TRUE,
  ...
)

## S3 method for class 'aphylo_prediction_score'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prediction_score_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+aphylo_estimates">aphylo_estimates</a> or other numeric vector-like
object (see details).</p>
</td></tr>
<tr><td><code id="prediction_score_+3A_expected">expected</code></td>
<td>
<p>Numeric vector-like object length <code class="reqn">n</code> (see details).
Expected values (either 0 or 1).</p>
</td></tr>
<tr><td><code id="prediction_score_+3A_alpha0">alpha0</code>, <code id="prediction_score_+3A_alpha1">alpha1</code></td>
<td>
<p>Probability of observing a zero an a one, respectively.</p>
</td></tr>
<tr><td><code id="prediction_score_+3A_w">W</code></td>
<td>
<p>A square matrix. Must have as many rows as genes in <code>expected</code>.</p>
</td></tr>
<tr><td><code id="prediction_score_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <a href="#topic+predict.aphylo_estimates">predict.aphylo_estimates</a></p>
</td></tr>
<tr><td><code id="prediction_score_+3A_loo">loo</code></td>
<td>
<p>Logical scalar. When <code>loo = TRUE</code>, predictions are preformed
similar to what a leave-one-out cross-validation scheme would be done
(see <a href="#topic+predict.aphylo_estimates">predict.aphylo_estimates</a>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the case of <code>prediction_score</code>, <code>...</code> are passed to
<code>predict.aphylo_estimates</code>.
The function will accept <code>x</code> as a numeric vector, list of vectors, or matrix.
Otherwise, it will try to coerce it to a matrix. If it fails, it will throw
an error.
</p>
<p>In the case of the method for aphylo estimates, the function takes as
a reference using alpha equal to the proportion of observed tip annotations that
are equal to 1, this is:
</p>
<div class="sourceCode"><pre>mean(x$dat$tip.annotation[x$dat$tip.annotation != 9L], na.rm = TRUE)
</pre></div>


<h3>Value</h3>

<p>A list of class <code>aphylo_prediction_score</code>:
</p>

<ul>
<li><p> obs       : Observed 1 - MAE.
</p>
</li>
<li><p> obs_raw   : Unnormalized (raw) scores.
</p>
</li>
<li><p> random_raw: Unnormalized (raw) scores.
</p>
</li>
<li><p> worse_raw : Unnormalized (raw) scores.
</p>
</li>
<li><p> pval      : Computed p-value.
</p>
</li>
<li><p> worse     : Reference of worse case.
</p>
</li>
<li><p> predicted : Numeric matrix with observed predictions.
</p>
</li>
<li><p> expected  : Integer matrix with expected annotations.
</p>
</li>
<li><p> random    : Random score (null).
</p>
</li>
<li><p> alpha0    : The passed alpha parameters.
</p>
</li>
<li><p> alpha1    : The passed alpha parameters.
</p>
</li>
<li><p> auc       : An object of class <code>aphylo_auc</code>.
</p>
</li>
<li><p> obs.ids   : Indices of the ids.
</p>
</li>
<li><p> leaf.ids  : IDs of the leafs (if present).
</p>
</li>
<li><p> tree      : Of class <code>phylo</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example with prediction_score ---------------------------------------------
set.seed(11552)
ap  &lt;- raphylo(
  50, P = 1,
  Pi   = 0,
  mu_d = c(.8,.2),
  mu_s = c(0.1,0.1),
  psi  = c(0,0)
  )
ans &lt;- aphylo_mcmc(
  ap ~ mu_d + mu_s + Pi,
  control = list(nsteps=2e3, thin=20, burnin = 500),
  priors = bprior(c(9, 1, 1, 1, 5), c(1, 9, 9, 9, 5))
  )
                   
(pr &lt;- prediction_score(ans, loo = TRUE))
plot(pr)
</code></pre>

<hr>
<h2 id='raphylo'>Simulation of Annotated Phylogenetic Trees</h2><span id='topic+raphylo'></span><span id='topic+rmultiAphylo'></span>

<h3>Description</h3>

<p>Simulation of Annotated Phylogenetic Trees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raphylo(
  n = NULL,
  tree = NULL,
  edge.length = NULL,
  tip.type = NULL,
  node.type = function(n) sample.int(2, size = n, replace = TRUE, prob = c(0.2, 0.8)) - 1,
  P = 1L,
  psi = c(0.05, 0.05),
  mu_d = c(0.9, 0.5),
  mu_s = c(0.05, 0.02),
  eta = c(1, 1),
  Pi = 0.2,
  informative = getOption("aphylo_informative", FALSE),
  maxtries = 20L
)

rmultiAphylo(R, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raphylo_+3A_n">n</code></td>
<td>
<p>Integer scalar. Number of leafs. If not specified, then</p>
</td></tr>
<tr><td><code id="raphylo_+3A_tree">tree</code></td>
<td>
<p>An object of class <a href="ape.html#topic+read.tree">phylo</a>.</p>
</td></tr>
<tr><td><code id="raphylo_+3A_edge.length">edge.length</code></td>
<td>
<p>Passed to <a href="#topic+sim_tree">sim_tree</a>.</p>
</td></tr>
<tr><td><code id="raphylo_+3A_tip.type">tip.type</code>, <code id="raphylo_+3A_node.type">node.type</code></td>
<td>
<p>Integer vectors with values 0 or 1. 0 denotes duplication node and 1 speciation node. This is used in <a href="#topic+LogLike">LogLike</a>.</p>
</td></tr>
<tr><td><code id="raphylo_+3A_p">P</code></td>
<td>
<p>Integer scalar. Number of functions to generate.</p>
</td></tr>
<tr><td><code id="raphylo_+3A_psi">psi</code></td>
<td>
<p>Numeric vector of length 2. Misclasification probabilities. (see <code><a href="#topic+LogLike">LogLike</a></code>).</p>
</td></tr>
<tr><td><code id="raphylo_+3A_mu_d">mu_d</code>, <code id="raphylo_+3A_mu_s">mu_s</code></td>
<td>
<p>Numeric vector of length 2. Gain/loss probabilities (see <code><a href="#topic+LogLike">LogLike</a></code>).</p>
</td></tr>
<tr><td><code id="raphylo_+3A_eta">eta</code></td>
<td>
<p>Numeric vector of length 2. Annotation bias probabilities (see <code><a href="#topic+LogLike">LogLike</a></code>).</p>
</td></tr>
<tr><td><code id="raphylo_+3A_pi">Pi</code></td>
<td>
<p>Numeric scalar. Root node probability of having the function (see <code><a href="#topic+LogLike">LogLike</a></code>).</p>
</td></tr>
<tr><td><code id="raphylo_+3A_informative">informative</code>, <code id="raphylo_+3A_maxtries">maxtries</code></td>
<td>
<p>Passed to <a href="#topic+sim_fun_on_tree">sim_fun_on_tree</a>.</p>
</td></tr>
<tr><td><code id="raphylo_+3A_r">R</code></td>
<td>
<p>Integer, number of replicates</p>
</td></tr>
<tr><td><code id="raphylo_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>raphylo</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>rmultiAphylo</code> function is a wrapper around <code>raphylo</code>.
</p>


<h3>Value</h3>

<p>An object of class <a href="#topic+aphylo">aphylo</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A simple example ----------------------------------------------------------

set.seed(1231)
ans &lt;- raphylo(n=500)

</code></pre>

<hr>
<h2 id='rdrop_annotations'>Randomly drop leaf annotations</h2><span id='topic+rdrop_annotations'></span>

<h3>Description</h3>

<p>The function takes an annotated tree and randomly selects leaf nodes to set
annotations as 9 (missing). The function allows specifying a proportion of
annotations to drop, and also the relative probability that has dropping
a 0 with respecto to a 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdrop_annotations(
  x,
  pcent,
  prob.drop.0 = 0.5,
  informative = getOption("aphylo_informative", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rdrop_annotations_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+aphylo">aphylo</a>.</p>
</td></tr>
<tr><td><code id="rdrop_annotations_+3A_pcent">pcent</code></td>
<td>
<p>Numeric scalar. Proportion of the annotations to remove.</p>
</td></tr>
<tr><td><code id="rdrop_annotations_+3A_prob.drop.0">prob.drop.0</code></td>
<td>
<p>Numeric scalar. Probability of removing a 0, conversely,
<code>1 - prob.drop.0</code> is the probability of removing a 1.</p>
</td></tr>
<tr><td><code id="rdrop_annotations_+3A_informative">informative</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code> (the default) the algorithm drops
annotations only if the number of annotations to drop of either 0s or 1s are
less than the currently available in the data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> with fewer annotations (more 9s).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following tree has roughtly the same proportion of 0s and 1s
# and 0 mislabeling.
set.seed(1)
x &lt;- raphylo(200, Pi=.5, mu_d=c(.5,.5), psi=c(0,0))
summary(x)

# Dropping half of the annotations
summary(rdrop_annotations(x, .5))

# Dropping half of the annotations, but 0 are more likely to drop
summary(rdrop_annotations(x, .5, prob.drop.0 = 2/3))

</code></pre>

<hr>
<h2 id='read_nhx'>Read New Hampshire eXtended format for trees</h2><span id='topic+read_nhx'></span>

<h3>Description</h3>

<p>Read New Hampshire eXtended format for trees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_nhx(fn, txt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_nhx_+3A_fn">fn</code></td>
<td>
<p>Full path to the tree file.</p>
</td></tr>
<tr><td><code id="read_nhx_+3A_txt">txt</code></td>
<td>
<p>If no file is specified, trees can also be passed as
a character scalar (see examples).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li><p> tree An object of class <code>ape</code>
</p>
</li>
<li><p> edge Edge annotations (length and other annotations)
</p>
</li>
<li><p> nhx A list of annotations NHX
</p>
</li></ul>



<h3>References</h3>

<p>&quot;NHX - New Hampshire eXtended [version 2.0]&quot;,
<a href="https://en.wikipedia.org/wiki/Newick_format#New_Hampshire_X_format">https://en.wikipedia.org/wiki/Newick_format#New_Hampshire_X_format</a>
</p>


<h3>See Also</h3>

<p>Other reading: 
<code><a href="#topic+panther-tree">panther-tree</a></code>,
<code><a href="#topic+read_pli">read_pli</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example directly extracted from
# https://sites.google.com/site/cmzmasek/home/software/forester/nhx
read_nhx(
  txt = "(((ADH2:0.1[&amp;&amp;NHX:S=human], ADH1:0.11[&amp;&amp;NHX:S=human]):0.05[&amp;&amp;NHX:S=primates:D=Y:B=100],
    ADHY:0.1[&amp;&amp;NHX:S=nematode],ADHX:0.12[&amp;&amp;NHX:S=insect]):0.1[&amp;&amp;NHX:S=metazoa:D=N],
    (ADH4:0.09[&amp;&amp;NHX:S=yeast],ADH3:0.13[&amp;&amp;NHX:S=yeast], ADH2:0.12[&amp;&amp;NHX:S=yeast],
    ADH1:0.11[&amp;&amp;NHX:S=yeast]):0.1 [&amp;&amp;NHX:S=Fungi])[&amp;&amp;NHX:D=N];"
    )
</code></pre>

<hr>
<h2 id='read_pli'>Read PLI files from SIFTER</h2><span id='topic+read_pli'></span>

<h3>Description</h3>

<p>Read PLI files from SIFTER
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_pli(fn, dropNAs = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_pli_+3A_fn">fn</code></td>
<td>
<p>Full path to the file</p>
</td></tr>
<tr><td><code id="read_pli_+3A_dropnas">dropNAs</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code>, the function will discard any
protein that has no annotations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data table object including the following columns:
</p>

<ul>
<li><p> name: Used to match UniProtKB data and GOA,
</p>
</li>
<li><p> number,
</p>
</li>
<li><p> go: A list of the GO annotations
</p>
</li>
<li><p> moc: Evidence code
</p>
</li>
<li><p> fam: Name of the family
</p>
</li></ul>



<h3>See Also</h3>

<p>Other reading: 
<code><a href="#topic+panther-tree">panther-tree</a></code>,
<code><a href="#topic+read_nhx">read_nhx</a>()</code>
</p>

<hr>
<h2 id='sim_fun_on_tree'>Simulate functions on a ginven tree</h2><span id='topic+sim_fun_on_tree'></span>

<h3>Description</h3>

<p>Simulate functions on a ginven tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_fun_on_tree(
  tree,
  tip.type,
  node.type,
  psi,
  mu_d,
  mu_s,
  eta,
  Pi,
  P = 1L,
  informative = getOption("aphylo_informative", FALSE),
  maxtries = 20L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_fun_on_tree_+3A_tree">tree</code></td>
<td>
<p>An object of class <a href="ape.html#topic+read.tree">phylo</a></p>
</td></tr>
<tr><td><code id="sim_fun_on_tree_+3A_tip.type">tip.type</code>, <code id="sim_fun_on_tree_+3A_node.type">node.type</code></td>
<td>
<p>Integer vectors with values 0 or 1. 0 denotes duplication node and 1 speciation node. This is used in <a href="#topic+LogLike">LogLike</a>.</p>
</td></tr>
<tr><td><code id="sim_fun_on_tree_+3A_psi">psi</code></td>
<td>
<p>Numeric vector of length 2. Misclasification probabilities. (see <code><a href="#topic+LogLike">LogLike</a></code>).</p>
</td></tr>
<tr><td><code id="sim_fun_on_tree_+3A_mu_d">mu_d</code>, <code id="sim_fun_on_tree_+3A_mu_s">mu_s</code></td>
<td>
<p>Numeric vector of length 2. Gain/loss probabilities (see <code><a href="#topic+LogLike">LogLike</a></code>).</p>
</td></tr>
<tr><td><code id="sim_fun_on_tree_+3A_eta">eta</code></td>
<td>
<p>Numeric vector of length 2. Annotation bias probabilities (see <code><a href="#topic+LogLike">LogLike</a></code>).</p>
</td></tr>
<tr><td><code id="sim_fun_on_tree_+3A_pi">Pi</code></td>
<td>
<p>Numeric scalar. Root node probability of having the function (see <code><a href="#topic+LogLike">LogLike</a></code>).</p>
</td></tr>
<tr><td><code id="sim_fun_on_tree_+3A_p">P</code></td>
<td>
<p>Integer scalar. Number of functions to simulate.</p>
</td></tr>
<tr><td><code id="sim_fun_on_tree_+3A_informative">informative</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> (default) the function
re-runs the simulation algorithm until both 0s and 1s show in the leaf
nodes of the tree.</p>
</td></tr>
<tr><td><code id="sim_fun_on_tree_+3A_maxtries">maxtries</code></td>
<td>
<p>Integer scalar. If <code>informative = TRUE</code>, then the function
will try at most <code>maxtries</code> times.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using the model described in the vignette
<a href="../doc/peeling_phylo.html">peeling_phylo.html</a>
</p>
<p>The optiona <code>informative</code> was created such that when needed the
function can be forced to simualte annotations while making sure (or at
least trying <code>maxtries</code> times) that the leafs have both 0s and 9s. From what
we've learned while conducting simulation studies, using this option may
indirectly bias the data generating process.
</p>


<h3>Value</h3>

<p>An matrix of size <code>length(offspring)*P</code> with values 9, 0 and 1
indicating <code>"no information"</code>, <code>"no function"</code> and <code>"function"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1 ----------------------------------------------------------------
# We need to simulate a tree
set.seed(1231)
newtree &lt;- sim_tree(1e3)

# Preprocessing the data

# Simulating
ans &lt;- sim_fun_on_tree(
  newtree,
  psi  = c(.01, .05),
  mu_d = c(.90, .80),
  mu_s = c(.1, .05),
  Pi   = .5,
  eta  = c(1, 1)
)

# Tabulating results
table(ans)
</code></pre>

<hr>
<h2 id='sim_tree'>Random tree generation</h2><span id='topic+sim_tree'></span>

<h3>Description</h3>

<p>Random tree generation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_tree(n, edge.length = stats::runif)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_tree_+3A_n">n</code></td>
<td>
<p>Integer scalar. Number of leaf nodes.</p>
</td></tr>
<tr><td><code id="sim_tree_+3A_edge.length">edge.length</code></td>
<td>
<p>A Function. Used to set the length of the edges.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An alternative to <a href="ape.html#topic+rtree">ape::rtree</a>. This function was written in C++ and is
significantly faster than <code>rtree</code>.
</p>
<p>The algorithm was implemented as follows
</p>

<ol>
<li><p> Initialize <code style="white-space: pre;">&#8288;N = {1, ..., n}&#8288;</code>, <code>E</code> to be empty,
<code>k = 2*n - 1</code>
</p>
</li>
<li><p> While <code>length(N) != 1</code> do:
</p>

<ol>
<li><p> Randomly choose a pair <code style="white-space: pre;">&#8288;(i, j)&#8288;</code> from <code>N</code>
</p>
</li>
<li><p> Add the edges <code style="white-space: pre;">&#8288;E = E U {(k, i), (k, j)}&#8288;</code>,
</p>
</li>
<li><p> Redefine <code style="white-space: pre;">&#8288;N = (N \ {i, j}) U {k}&#8288;</code>
</p>
</li>
<li><p> Set <code>k = k - 1</code>
</p>
</li>
<li><p> next
</p>
</li></ol>

</li>
<li><p> Use <code>edge.length(2*n - 1)</code> (simulating branch lengths).
</p>
</li></ol>



<h3>Value</h3>

<p>An object of class <a href="ape.html#topic+read.tree">ape::phylo</a> with the edgelist as a postorderd,
<code>node.label</code> and <code>edge.length</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A very simple example ----------------------------------------------------
set.seed(1223)
newtree &lt;- sim_tree(50)

plot(newtree)


# A performance benchmark with ape::rtree ----------------------------------
## Not run: 
library(ape)
microbenchmark::microbenchmark(
  ape = rtree(1e3),
  phy = sim_tree(1e3),
 unit = "relative"
)
# This is what you would get.
# Unit: relative
#   expr     min       lq     mean  median       uq      max neval
#    ape 14.7598 14.30809 14.30013 16.7217 14.32843 4.754106   100
#    phy  1.0000  1.00000  1.00000  1.0000  1.00000 1.000000   100

## End(Not run)
</code></pre>

<hr>
<h2 id='states'>Matrix of states</h2><span id='topic+states'></span>

<h3>Description</h3>

<p>Matrix of states
</p>


<h3>Usage</h3>

<pre><code class='language-R'>states(P)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="states_+3A_p">P</code></td>
<td>
<p>Integer scalar. Number of functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size 2^P by P with all the possible
(0,1) combinations of functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>states(3)
</code></pre>

<hr>
<h2 id='write_pli'>Write pli files used by SIFTER</h2><span id='topic+write_pli'></span>

<h3>Description</h3>

<p>Write pli files used by SIFTER
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_pli(
  family_id,
  protein_name,
  protein_number,
  go_number,
  moc = "EXP",
  file = ""
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_pli_+3A_family_id">family_id</code></td>
<td>
<p>Character scalar. Name of the family</p>
</td></tr>
<tr><td><code id="write_pli_+3A_protein_name">protein_name</code>, <code id="write_pli_+3A_protein_number">protein_number</code>, <code id="write_pli_+3A_go_number">go_number</code>, <code id="write_pli_+3A_moc">moc</code></td>
<td>
<p>Vectors of the same length</p>
</td></tr>
<tr><td><code id="write_pli_+3A_file">file</code></td>
<td>
<p>Character scalar passed to <a href="base.html#topic+cat">cat</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string with the XML file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(882)
atree &lt;- raphylo(5)
write_pli(
  family_id      = "a family",
  protein_name   = atree$tree$tip.label,
  protein_number = 1:Ntip(atree),
  go_number      = "GO:123123123123"
)
# Possible outcome:
#&lt;?xml version="1.0"?&gt;
#&lt;Family&gt;
#  &lt;FamilyID&gt;a family&lt;/FamilyID&gt;
#  &lt;Protein&gt;
#    &lt;ProteinName&gt;1&lt;/ProteinName&gt;
#    &lt;ProteinNumber&gt;1&lt;/ProteinNumber&gt;
#    &lt;GONumber&gt;[GO:123123123123]&lt;/GONumber&gt;
#    &lt;MOC&gt;[EXP]&lt;/MOC&gt;
#  &lt;/Protein&gt;
#  &lt;Protein&gt;
#    &lt;ProteinName&gt;2&lt;/ProteinName&gt;
#    &lt;ProteinNumber&gt;2&lt;/ProteinNumber&gt;
#    &lt;GONumber&gt;[GO:123123123123]&lt;/GONumber&gt;
#    &lt;MOC&gt;[EXP]&lt;/MOC&gt;
#  &lt;/Protein&gt;
#  &lt;Protein&gt;
#    &lt;ProteinName&gt;3&lt;/ProteinName&gt;
#    &lt;ProteinNumber&gt;3&lt;/ProteinNumber&gt;
#    &lt;GONumber&gt;[GO:123123123123]&lt;/GONumber&gt;
#    &lt;MOC&gt;[EXP]&lt;/MOC&gt;
#  &lt;/Protein&gt;
#  &lt;Protein&gt;
#    &lt;ProteinName&gt;4&lt;/ProteinName&gt;
#    &lt;ProteinNumber&gt;4&lt;/ProteinNumber&gt;
#    &lt;GONumber&gt;[GO:123123123123]&lt;/GONumber&gt;
#    &lt;MOC&gt;[EXP]&lt;/MOC&gt;
#  &lt;/Protein&gt;
#  &lt;Protein&gt;
#    &lt;ProteinName&gt;5&lt;/ProteinName&gt;
#    &lt;ProteinNumber&gt;5&lt;/ProteinNumber&gt;
#    &lt;GONumber&gt;[GO:123123123123]&lt;/GONumber&gt;
#    &lt;MOC&gt;[EXP]&lt;/MOC&gt;
#  &lt;/Protein&gt;
#&lt;/Family&gt;
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
