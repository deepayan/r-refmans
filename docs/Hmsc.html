<!DOCTYPE html><html lang="en"><head><title>Help for package Hmsc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Hmsc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Hmsc-package'><p>Hmsc: Hierarchical Model of Species Communities</p></a></li>
<li><a href='#alignPosterior'><p>alignPosterior</p></a></li>
<li><a href='#biPlot'><p>biPlot</p></a></li>
<li><a href='#c.Hmsc'><p>Combine Posterior Samples of Several Hmsc Models</p></a></li>
<li><a href='#computeAssociations'><p>computeAssociations</p></a></li>
<li><a href='#computeDataParameters'><p>computeDataParameters</p></a></li>
<li><a href='#computeInitialParameters'><p>computeInitialParameters</p></a></li>
<li><a href='#computePredictedValues'><p>computePredictedValues</p></a></li>
<li><a href='#computeVariancePartitioning'><p>computeVariancePartitioning</p></a></li>
<li><a href='#computeWAIC'><p>computeWAIC</p></a></li>
<li><a href='#constructGradient'><p>constructGradient</p></a></li>
<li><a href='#constructKnots'><p>constructKnots</p></a></li>
<li><a href='#convertToCodaObject'><p>convertToCodaObject</p></a></li>
<li><a href='#createPartition'><p>createPartition</p></a></li>
<li><a href='#evaluateModelFit'><p>evaluateModelFit</p></a></li>
<li><a href='#getPostEstimate'><p>getPostEstimate</p></a></li>
<li><a href='#Hmsc'><p>Hmsc</p></a></li>
<li><a href='#HmscRandomLevel'><p>Create an <code>Hmsc</code> random level</p></a></li>
<li><a href='#plotBeta'><p>plotBeta</p></a></li>
<li><a href='#plotGamma'><p>plotGamma</p></a></li>
<li><a href='#plotGradient'><p>plotGradient</p></a></li>
<li><a href='#plotVariancePartitioning'><p>plotVariancePartitioning</p></a></li>
<li><a href='#poolMcmcChains'><p>poolMcmcChains</p></a></li>
<li><a href='#predict.Hmsc'><p>predict</p></a></li>
<li><a href='#predictLatentFactor'><p>predictLatentFactor</p></a></li>
<li><a href='#prepareGradient'><p>prepareGradient</p></a></li>
<li><a href='#sampleMcmc'><p>sampleMCMC</p></a></li>
<li><a href='#samplePrior'><p>samplePrior</p></a></li>
<li><a href='#setPriors'><p>setPriors</p></a></li>
<li><a href='#setPriors.Hmsc'><p>setPriors.Hmsc</p></a></li>
<li><a href='#setPriors.HmscRandomLevel'><p>setPriors.HmscRandomLevel</p></a></li>
<li><a href='#TD'><p>Simulated data and a fitted Hmsc model for a small species community.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Hierarchical Model of Species Communities</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0-13</td>
</tr>
<tr>
<td>Description:</td>
<td>Hierarchical Modelling of Species Communities (HMSC) is
   a model-based approach for analyzing community ecological data. 
   This package implements it in the Bayesian framework with Gibbs
   Markov chain Monte Carlo (MCMC) sampling (Tikhonov et al. (2020)
   &lt;<a href="https://doi.org/10.1111%2F2041-210X.13345">doi:10.1111/2041-210X.13345</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.helsinki.fi/en/researchgroups/statistical-ecology/software/hmsc">https://www.helsinki.fi/en/researchgroups/statistical-ecology/software/hmsc</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/hmsc-r/HMSC/issues/">https://github.com/hmsc-r/HMSC/issues/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp, testthat, corrplot</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2), coda</td>
</tr>
<tr>
<td>Imports:</td>
<td>abind, ape, BayesLogit, fields, FNN, ggplot2, MASS, Matrix,
matrixStats, MCMCpack, methods, nnet, rlang, parallel, pracma,
pROC, sp, statmod, truncnorm</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-11 13:37:09 UTC; jarioksa</td>
</tr>
<tr>
<td>Author:</td>
<td>Gleb Tikhonov [aut],
  Otso Ovaskainen <a href="https://orcid.org/0000-0001-9750-4421"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jari Oksanen [aut],
  Melinda de Jonge [aut],
  Oystein Opedal [aut],
  Tad Dallas [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Otso Ovaskainen &lt;otso.ovaskainen@helsinki.fi&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-11 14:10:14 UTC</td>
</tr>
</table>
<hr>
<h2 id='Hmsc-package'>Hmsc: Hierarchical Model of Species Communities</h2><span id='topic+Hmsc-package'></span>

<h3>Description</h3>

<p>Hierarchical Modelling of Species Communities (Hmsc) is a
flexible framework for Joint Species Distribution Modelling (JSDMs). The
framework can be used to relate species occurrences or abundances to
environmental covariates, species traits and phylogenetic relationships.
JSDMs are a special case of species distribution models (SDMs) that take
into account the multivariate nature of communities which allows us to
estimate community level responses as well capture biotic interactions and
the influence of missing covariates in residual species associations. The
Hmsc package contains functions to fit JSDMs, analyze the output and to
generate predictions with these JSDMs.
</p>


<h3>Workflow</h3>

<p>A typical workflow for a Hmsc analysis constists of 5 steps:
</p>
<p><b>Step 1: Setting the model structure and fitting the model</b>
</p>
<p>The obligatory data for a Hmsc analysis includes a matrix of species occurrences
or abundances (Y) and a data frame of environmental covariates (XData). The
species matrix Y consists of ns columns representing the species and np rows
representing the sampling units. Species data for different species does not
have to be on the same scale, i.e. species 1 may be recorded as
presence/absence while species 2 is recorded as abundance. XData consists of
nc columns representing the environmental variables and np rows representing
the sampling units. Y and XData need to have the same amount of rows
(sampling units).
</p>
<p>Optionally, the user can include information species traits, phylogenetic
relationships and information on the spatiotemporal or hierarchical context of the sampling
design to account for dependencies among the sampling units.
</p>
<p>The model structure is created using the <code><a href="#topic+Hmsc">Hmsc</a></code> function. As
input, this function needs at least the matrix with species data (Y) and the
dataframe with environmental variables. This is also the place where the data model is specified, as a default Hmsc assumes normally distributed species data. Other options are 'probit' for binary data, 'Poisson' and 'overdispersedPoisson' for count data. Additionally, you can specify the study design, the random effects structure, the species traits to be used,
species phylogeny, how the covariate should be scales and how viable selection should be applied.
</p>
<p>The random levels supplied to <code><a href="#topic+Hmsc">Hmsc</a></code> are generated using <code><a href="#topic+HmscRandomLevel">HmscRandomLevel</a></code>. Here, the user can specify the spatial or temporal information for the units as well as the covariates for covariate-depedent associations. If there is no spatial, temporal or coviate information for this level, the user should provide here the names of the units for this level.
</p>
<p>After setting the model structure, the model is fitted by running <code><a href="#topic+sampleMcmc">sampleMcmc</a></code> to sample from the posterior distributions of the model parameters.
</p>
<p><b>Step 2: Examining MCMC convergence</b>
</p>
<p>After fitting the model, the MCMC convergence needs to be evaluated. The
easiest way to do this is generate a coda object from the fitted model using
<code><a href="#topic+convertToCodaObject">convertToCodaObject</a></code>. Convergence of the chains should be
assessed qualitatively using trace plots of the model parameters and
quantitatively using gelman diagnostics <code><a href="coda.html#topic+gelman.diag">gelman.diag</a></code> and
by calculating the effective sample size with
<code><a href="coda.html#topic+effectiveSize">effectiveSize</a></code>.
</p>
<p><b>Step 3: Evaluating model fit</b>
</p>
<p>If MCMC convergence is satisfacotry, the model fit can be evaluated. Using
the <code><a href="#topic+computePredictedValues">computePredictedValues</a></code> function. It is also recommended to
also compute predictive power using cross validation. Cross validation is
done by supplying the partitioning created using using
<code><a href="#topic+createPartition">createPartition</a></code> to <code><a href="#topic+computePredictedValues">computePredictedValues</a></code>.
</p>
<p><b>Step 4: Exploring parameter estimates</b>
</p>
<p>When the fitted model has satisfactory convergence and fit, the next step is
generally to investigate the parameter estimates of the model. The posterior
distribution of the parameter of choice is extracted from the model object
using <code><a href="#topic+getPostEstimate">getPostEstimate</a></code>. <code><a href="#topic+plotBeta">plotBeta</a></code> and
<code><a href="#topic+plotGamma">plotGamma</a></code> can be used to visuzalize the beta and gamma
parameter estimates. Additionally, the function <code><a href="#topic+biPlot">biPlot</a></code> can be
used to construct an ordination plot from the eta and lamda parameters
</p>
<p>Additionally, at this stage of the analysis, the user may want to look at
how the variance explained by the model is partitioned using the
<code><a href="#topic+computeVariancePartitioning">computeVariancePartitioning</a></code> and the
<code><a href="#topic+plotVariancePartitioning">plotVariancePartitioning</a></code> function.
</p>
<p><b>Step 5: Making predictions</b>
</p>
<p>Hmsc comes with a generic <code><a href="stats.html#topic+predict">predict</a></code> function that can be used to predict species occurences or counts in new units. These predictions can be unconditional or conditional on the occurence of other species. For conditional predictions, the user needs to supply species data for at least some species in the new units.
Additionally, the package specific tools to make predictions along environmental gradients. These predictions can be vizualized at both the species and the community level (<code><a href="#topic+constructGradient">constructGradient</a></code>, <code><a href="#topic+plotGradient">plotGradient</a></code>).
</p>


<h3>Citing the Package</h3>

<p>Tikhonov, G., Opedal, O.H., Abrego, N., Lehikoinen, A., de Jonge,
M.M.J, Oksanen, J. and Ovaskainen, O. (2020) Joint species
distribution modelling with the R-package Hmsc. <em>Methods in
Ecology and Evolution</em> <b>11,</b> 442&ndash;447. <a href="https://doi.org/10.1111/2041-210X.13345">doi:10.1111/2041-210X.13345</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://www.helsinki.fi/en/researchgroups/statistical-ecology/software/hmsc">https://www.helsinki.fi/en/researchgroups/statistical-ecology/software/hmsc</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/hmsc-r/HMSC/issues/">https://github.com/hmsc-r/HMSC/issues/</a>
</p>
</li></ul>


<hr>
<h2 id='alignPosterior'>alignPosterior</h2><span id='topic+alignPosterior'></span>

<h3>Description</h3>

<p>Aligns posterior in terms of variables susceptible to label switching
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alignPosterior(hM)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alignPosterior_+3A_hm">hM</code></td>
<td>
<p>a fitted <code>Hmsc</code> model object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>Hmsc</code> model object that is identical to the input except the posterior being aligned
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Align the posterior for a previously fitted HMSC model
m = alignPosterior(TD$m)

</code></pre>

<hr>
<h2 id='biPlot'>biPlot</h2><span id='topic+biPlot'></span>

<h3>Description</h3>

<p>Constructs an ordination biplot based on the fitted model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>biPlot(
  hM,
  etaPost,
  lambdaPost,
  factors = c(1, 2),
  colVar = NULL,
  colors = NULL,
  spNames = hM$spNames,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="biPlot_+3A_hm">hM</code></td>
<td>
<p>a fitted <code>Hmsc</code> model object</p>
</td></tr>
<tr><td><code id="biPlot_+3A_etapost">etaPost</code></td>
<td>
<p>posterior distribution of site loadings (Eta)</p>
</td></tr>
<tr><td><code id="biPlot_+3A_lambdapost">lambdaPost</code></td>
<td>
<p>posterior distribution of species loadings
(Lambda)</p>
</td></tr>
<tr><td><code id="biPlot_+3A_factors">factors</code></td>
<td>
<p>indices of the two factors to be plotted</p>
</td></tr>
<tr><td><code id="biPlot_+3A_colvar">colVar</code></td>
<td>
<p>the environmental covariate from XData according to
which the sites are to be coloured</p>
</td></tr>
<tr><td><code id="biPlot_+3A_colors">colors</code></td>
<td>
<p>controls the colors of the heatmap. For continuous
covariates, colors should be given as a name of palette, with
default value <code>colorRampPalette(c("blue","white","red"))</code>,
or as a vector of colours. For factors, colors should be given
as a vector of colours, e.g. <code>c("blue","red")</code>.</p>
</td></tr>
<tr><td><code id="biPlot_+3A_spnames">spNames</code></td>
<td>
<p>a vector of species names to be added to the
ordination diagram</p>
</td></tr>
<tr><td><code id="biPlot_+3A_...">...</code></td>
<td>
<p>other parameters passed to the function.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Construct an ordination biplot using two chosen latent factors from a previously fitted HMSC model
etaPost = getPostEstimate(TD$m, "Eta")
lambdaPost=getPostEstimate(TD$m, "Lambda")
biPlot(TD$m, etaPost = etaPost, lambdaPost=lambdaPost, factors=c(1,2))


</code></pre>

<hr>
<h2 id='c.Hmsc'>Combine Posterior Samples of Several Hmsc Models</h2><span id='topic+c.Hmsc'></span>

<h3>Description</h3>

<p>Function combines posterior samples of several sampled
<code><a href="#topic+Hmsc">Hmsc</a></code> models (see <code><a href="#topic+sampleMcmc">sampleMcmc</a></code>) as new
chains in the first fitted model. The combined models must be
comparable, and there are some tests for detecting non-equal
models. These tests will only give warning, and it is at user
deliberation to decide which models and which posterior samples can
be combined.  You should be careful not start two models from the
same random number seed, because these will only duplicate your
data instead of providing new independent samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Hmsc'
c(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c.Hmsc_+3A_...">...</code></td>
<td>
<p>Sampled <code>Hmsc</code> models with posterior samples that
will be added as new chaings in the first listed model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+Hmsc">Hmsc</a></code> model with chains of posterior
samples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Fit a toy model with two chains
m1 &lt;- sampleMcmc(TD$m, samples=10, transient=5, nChains=2, verbose=0)
## Need more data? Add chains: check carefully that these are
## sampled exactly like the previous model
m2 &lt;- sampleMcmc(TD$m, nChains=2, samples=10, transient=5, verbose=0)
## Now four chains
m4 &lt;- c(m1, m2)
m4

</code></pre>

<hr>
<h2 id='computeAssociations'>computeAssociations</h2><span id='topic+computeAssociations'></span>

<h3>Description</h3>

<p>Computes the species association matrices associated with each random level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeAssociations(hM, start = 1, thin = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeAssociations_+3A_hm">hM</code></td>
<td>
<p>a fitted <code>Hmsc</code> model object</p>
</td></tr>
<tr><td><code id="computeAssociations_+3A_start">start</code></td>
<td>
<p>index of first MCMC sample included</p>
</td></tr>
<tr><td><code id="computeAssociations_+3A_thin">thin</code></td>
<td>
<p>thinning interval of posterior distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of association matrices (<code class="reqn">\omega</code>) corresponding to each random level in the model
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the associations (residual correlations) between species from a HMSC model
assoc = computeAssociations(TD$m)

</code></pre>

<hr>
<h2 id='computeDataParameters'>computeDataParameters</h2><span id='topic+computeDataParameters'></span>

<h3>Description</h3>

<p>Computes initial values before the sampling starts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeDataParameters(hM)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeDataParameters_+3A_hm">hM</code></td>
<td>
<p>a fitted <code>Hmsc</code> model object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list including pre-computed matrix inverses and determinants (for phylogenetic and spatial random effects) needed in MCMC sampling
</p>

<hr>
<h2 id='computeInitialParameters'>computeInitialParameters</h2><span id='topic+computeInitialParameters'></span>

<h3>Description</h3>

<p>Computes initial parameter values before the sampling starts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeInitialParameters(hM, initPar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeInitialParameters_+3A_hm">hM</code></td>
<td>
<p>a fitted <code>Hmsc</code> model object</p>
</td></tr>
<tr><td><code id="computeInitialParameters_+3A_initpar">initPar</code></td>
<td>
<p>a list of initial parameter values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of Hmsc model parameters
</p>

<hr>
<h2 id='computePredictedValues'>computePredictedValues</h2><span id='topic+computePredictedValues'></span><span id='topic+pcomputePredictedValues'></span>

<h3>Description</h3>

<p>Computes predicted values from the fitted <code>Hmsc</code> model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computePredictedValues(
  hM,
  partition = NULL,
  partition.sp = NULL,
  start = 1,
  thin = 1,
  Yc = NULL,
  mcmcStep = 1,
  expected = TRUE,
  initPar = NULL,
  nParallel = 1,
  nChains = length(hM$postList),
  updater = list(),
  verbose = hM$verbose,
  alignPost = TRUE
)

pcomputePredictedValues(
  hM,
  partition = NULL,
  partition.sp = NULL,
  start = 1,
  thin = 1,
  Yc = NULL,
  mcmcStep = 1,
  expected = TRUE,
  initPar = NULL,
  nParallel = 1,
  useSocket = .Platform$OS.type == "windows",
  nChains = length(hM$postList),
  updater = list(),
  verbose = nParallel == 1,
  alignPost = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computePredictedValues_+3A_hm">hM</code></td>
<td>
<p>a fitted <code>Hmsc</code> model object</p>
</td></tr>
<tr><td><code id="computePredictedValues_+3A_partition">partition</code></td>
<td>
<p>partition vector for cross-validation created by <code><a href="#topic+createPartition">createPartition</a></code></p>
</td></tr>
<tr><td><code id="computePredictedValues_+3A_partition.sp">partition.sp</code></td>
<td>
<p>species partitioning vector for conditional cross-validation</p>
</td></tr>
<tr><td><code id="computePredictedValues_+3A_start">start</code></td>
<td>
<p>index of first MCMC sample included</p>
</td></tr>
<tr><td><code id="computePredictedValues_+3A_thin">thin</code></td>
<td>
<p>thinning interval of posterior distribution</p>
</td></tr>
<tr><td><code id="computePredictedValues_+3A_yc">Yc</code></td>
<td>
<p>response matrix on which the predictions are to be conditioned</p>
</td></tr>
<tr><td><code id="computePredictedValues_+3A_mcmcstep">mcmcStep</code></td>
<td>
<p>number of MCMC steps used to make conditional predictions</p>
</td></tr>
<tr><td><code id="computePredictedValues_+3A_expected">expected</code></td>
<td>
<p>whether expected values (TRUE) or realizations (FALSE) are to be predicted</p>
</td></tr>
<tr><td><code id="computePredictedValues_+3A_initpar">initPar</code></td>
<td>
<p>a named list of parameter values used for initialization of MCMC states</p>
</td></tr>
<tr><td><code id="computePredictedValues_+3A_nparallel">nParallel</code></td>
<td>
<p>number of parallel processes by which the chains are executed</p>
</td></tr>
<tr><td><code id="computePredictedValues_+3A_nchains">nChains</code></td>
<td>
<p>number of independent MCMC chains to be run</p>
</td></tr>
<tr><td><code id="computePredictedValues_+3A_updater">updater</code></td>
<td>
<p>a named list, specifying which conditional updaters should be omitted</p>
</td></tr>
<tr><td><code id="computePredictedValues_+3A_verbose">verbose</code></td>
<td>
<p>the interval between MCMC steps printed to the console</p>
</td></tr>
<tr><td><code id="computePredictedValues_+3A_alignpost">alignPost</code></td>
<td>
<p>boolean flag indicating whether the posterior of each chains should be aligned</p>
</td></tr>
<tr><td><code id="computePredictedValues_+3A_usesocket">useSocket</code></td>
<td>
<p>(logical) use socket clusters in parallel processing;
these can be used in all operating systems, but they are
usually slower than forking which can only be used
in non-Windows operating systems (macOS, Linux, unix-like
systems).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two alternative functions <code>computePredictedValues</code>
and <code>pcomputePredictedValues</code>. Function
<code>pcomputePredictedValues</code> uses more aggressive parallelization
and can be much faster when <code>partition</code> is used. Function
<code>computePredictedValues</code> can run chains of each
<code>sampleMcmc</code> partition in parallel, but
<code>pcomputePredictedValues</code> can run each partition fold times
chain in parallel (if hardware and operating systems
permit). Function <code>pcomputePredictedValues</code> is still
experimental, and therefore we provide both the old and new
functions, but the old functions is scheduled to be removed in the
future. Species partitions are not yet parallelized, and they can
be very slow, especially with many <code>mcmcSteps</code>.
</p>
<p>If the option <code>partition</code> is not used, the posterior predictive distribution is based on the model
fitted to the full data. If the option <code>partition</code> is used but <code>partition.sp</code> is not used, the posterior predictive distribution
is based on cross-validation over the sampling units. If <code>partition.sp</code> is additionally used, then, when predictions are made for
each fold of the sampling units, the predictions are done separately for each fold of species. When making the predictions
for one fold of species, the predictions are conditional on known occurrences (those observed in the data) of the species
belonging to the other folds. If <code>partition.sp</code> is used, the parameter <code>mcmcStep</code> should be set high enough to obtain
appropriate conditional predictions. The option <code>Yc</code> can be used alternatively to <code>partition.sp</code> if the conditioning is to be done
based on a fixed set of data (independently of which sampling unit and species the predictions are made for).
</p>


<h3>Value</h3>

<p>an array of model predictions, made for each posterior sample
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.Hmsc">predict.Hmsc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute predicted values using a previously fitted HMSC model
preds = computePredictedValues(TD$m)

## Not run: 
# Compute predicted values for a previously fitted HMSC model using 2 folds
partition = createPartition(TD$m, nfolds = 2)
predsCV1 = computePredictedValues(TD$m,partition=partition)

# Compute conditional predictions for a previously fitted HMSC model using 2 folds
partition = createPartition(TD$m, nfolds = 2)
predsCV2 = computePredictedValues(TD$m, partition = partition,
partition.sp = 1:TD$m$ns, mcmcStep = 100)

## End(Not run)

</code></pre>

<hr>
<h2 id='computeVariancePartitioning'>computeVariancePartitioning</h2><span id='topic+computeVariancePartitioning'></span>

<h3>Description</h3>

<p>Computes variance components with respect to given grouping of fixed effects and levels
of random effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeVariancePartitioning(
  hM,
  group = NULL,
  groupnames = NULL,
  start = 1,
  na.ignore = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeVariancePartitioning_+3A_hm">hM</code></td>
<td>
<p>a fitted <code>Hmsc</code> model object</p>
</td></tr>
<tr><td><code id="computeVariancePartitioning_+3A_group">group</code></td>
<td>
<p>vector of numeric values corresponding to group
identifiers in groupnames. If the model was defined with
<code>XData</code> and <code>XFormula</code>, the default is to use model
terms.</p>
</td></tr>
<tr><td><code id="computeVariancePartitioning_+3A_groupnames">groupnames</code></td>
<td>
<p>vector of names for each group of fixed
effect. Should match <code>group</code>. If the model was defined
with <code>XData</code> and <code>XFormula</code>, the default is to use
the labels of model terms.</p>
</td></tr>
<tr><td><code id="computeVariancePartitioning_+3A_start">start</code></td>
<td>
<p>index of first MCMC sample included</p>
</td></tr>
<tr><td><code id="computeVariancePartitioning_+3A_na.ignore">na.ignore</code></td>
<td>
<p>logical. If TRUE, covariates are ignored for sites
where the focal species is NA when computing
variance-covariance matrices for each species</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The vector <code>group</code> has one value for each column of the matrix <code>hM$X</code>, describing the index of the
group in which this column is to be included. The names of the group are given by <code>groupnames</code>. The output object
<code>VP$vals</code> gives the variance proportion for each group and species. The output object <code>VP$R2T</code> gives the
variance among species explained by traits, measured for species' responses to covariates (<code>VP$R2T$Beta</code>) and species occurrences
(<code>VP$R2T$Y</code>)
</p>


<h3>Value</h3>

<p>returns an object VP with components VP$vals, VP$R2T, VP$group and VP$groupnames.
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+plotVariancePartitioning">plotVariancePartitioning</a></code> to display the result object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Partition the explained variance for a previously fitted model
# without grouping environmental covariates
VP = computeVariancePartitioning(TD$m)

# Partition the explained variance for a previously fitted model
# while grouping the two environmental variables together
VP = computeVariancePartitioning(TD$m, group=c(1,1), groupnames = c("Habitat"))

</code></pre>

<hr>
<h2 id='computeWAIC'>computeWAIC</h2><span id='topic+computeWAIC'></span>

<h3>Description</h3>

<p>Computes the value of WAIC (Widely Applicable Information Criterion) for the <code>Hmsc</code> model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeWAIC(hM, ghN = 11, byColumn = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeWAIC_+3A_hm">hM</code></td>
<td>
<p>a fitted <code>Hmsc</code> model object</p>
</td></tr>
<tr><td><code id="computeWAIC_+3A_ghn">ghN</code></td>
<td>
<p>order of Gauss-Hermite quadrature for approximate numerical integration</p>
</td></tr>
<tr><td><code id="computeWAIC_+3A_bycolumn">byColumn</code></td>
<td>
<p>describes whether WAIC is computed for the entire model <code>byColumn=FALSE</code> or for each column (i.e. species) <code>byColumn=TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The result is exact for normal and probit observational models. For Poisson-type
observational model the result is obtained through numerical integration using Gauss-Hermite quadrature.
</p>


<h3>Value</h3>

<p>the scalar WAIC
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute WAIC of previously sampled Hmsc object
WAIC = computeWAIC(TD$m)


</code></pre>

<hr>
<h2 id='constructGradient'>constructGradient</h2><span id='topic+constructGradient'></span>

<h3>Description</h3>

<p>Constructs an environmental gradient over one of the variables included in <code>XData</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constructGradient(
  hM,
  focalVariable,
  non.focalVariables = list(),
  ngrid = 20,
  coordinates = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="constructGradient_+3A_hm">hM</code></td>
<td>
<p>a fitted <code>Hmsc</code> model object</p>
</td></tr>
<tr><td><code id="constructGradient_+3A_focalvariable">focalVariable</code></td>
<td>
<p>focal variable over which the gradient is constructed</p>
</td></tr>
<tr><td><code id="constructGradient_+3A_non.focalvariables">non.focalVariables</code></td>
<td>
<p>list giving assumptions on how non-focal variables co-vary with the focal variable or a single number given the default type for all non-focal variables</p>
</td></tr>
<tr><td><code id="constructGradient_+3A_ngrid">ngrid</code></td>
<td>
<p>number of points along the gradient (for continuous focal variables)</p>
</td></tr>
<tr><td><code id="constructGradient_+3A_coordinates">coordinates</code></td>
<td>
<p>A named list of coordinates were model is
evaluated in spatial or temporal models. The name should be one
of the random levels, and value can be <code>"c"</code> for mean of
coordinates (default), <code>"i"</code> for infinite coordinates
without effect of spatial dependence, or a numeric vector of
coordinates where the model is evaluated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In basic form, <code>non.focalVariables</code> is a list, where each element is on the form variable=list(type,value),
where <code>variable</code> is one of the non-focal variables, and the <code>value</code> is needed only if <code>type = 3</code>. Alternatives
<code>type = 1</code> sets the values of the non-focal variable
to the most likely value (defined as expected value for covariates, mode for factors),
<code>type = 2</code> sets the values of the non-focal variable to most likely value, given the value of focal variable,
based on a linear relationship, and
<code>type = 3</code> fixes to the value given.
As a shortcut, a single number <code>1</code> or <code>2</code> can be given as a type
used for all non-focal variables.
If a <code>non.focalVariable</code> is not listed, <code>type=2</code> is used as default.
Note that if the focal variable is continuous, selecting type 2 for a non-focal categorical variable can cause abrupt changes in response.
</p>
<p>The function needs access to the original <code>XData</code> data frame,
and cannot be used if you defined your model with <code>X</code> model
matrix. In that case you must construct your gradient manually.
</p>


<h3>Value</h3>

<p>a named list with slots <code>XDataNew</code>, <code>studyDesignNew</code> and <code>rLNew</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotGradient">plotGradient</a></code>, <code><a href="stats.html#topic+predict">predict</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construct gradient for environmental covariate called 'x1'.
Gradient = constructGradient(TD$m, focalVariable="x1")

# Construct gradient for environmental covariate called 'x1'
# while setting the other covariate to its most likely values
Gradient = constructGradient(TD$m, focalVariable="x1",non.focalVariables=list(x2=list(1)))

</code></pre>

<hr>
<h2 id='constructKnots'>constructKnots</h2><span id='topic+constructKnots'></span>

<h3>Description</h3>

<p>Construct a Regular Grid of Knot Locations for Spatial GPP Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constructKnots(sData, nKnots = NULL, knotDist = NULL, minKnotDist = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="constructKnots_+3A_sdata">sData</code></td>
<td>
<p>a dataframe containing spatial or temporal coordinates of units of the random level</p>
</td></tr>
<tr><td><code id="constructKnots_+3A_nknots">nKnots</code></td>
<td>
<p>the number of knots wanted on the spatial dimension with the shortest range</p>
</td></tr>
<tr><td><code id="constructKnots_+3A_knotdist">knotDist</code></td>
<td>
<p>the distance between the wanted knots</p>
</td></tr>
<tr><td><code id="constructKnots_+3A_minknotdist">minKnotDist</code></td>
<td>
<p>the minimum distance of a knot to the nearest data point</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a helper function for spatial Hmsc models with the
spatial method set to GPP where user must provide knot
locations. Knot locations with a distance greater than
<code>minKnotDist</code> to the nearest data point are dropped from
the grid. If the input locations are
<code><a href="sp.html#topic+SpatialPoints">SpatialPoints</a></code> data, these are treated like
Euclidean coordinates, and if the points are not projected, a
warning is issued.
</p>
<p>Only one of <code>nKnots</code> and <code>minKnotDist</code> arguments can be provided.
</p>


<h3>Value</h3>

<p>a data frame with knot locations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Creating knots for some 2 dimensional spatial data
n = 100
xycoords = matrix(runif(2*n),ncol=2)
xyKnots = constructKnots(xycoords,knotDist = 0.2, minKnotDist = 0.5)

</code></pre>

<hr>
<h2 id='convertToCodaObject'>convertToCodaObject</h2><span id='topic+convertToCodaObject'></span>

<h3>Description</h3>

<p>Converts the Hmsc posterior into a named list of mcmc.list objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertToCodaObject(
  hM,
  start = 1,
  spNamesNumbers = c(TRUE, TRUE),
  covNamesNumbers = c(TRUE, TRUE),
  trNamesNumbers = c(TRUE, TRUE),
  Beta = TRUE,
  Gamma = TRUE,
  V = TRUE,
  Sigma = TRUE,
  Rho = TRUE,
  Eta = TRUE,
  Lambda = TRUE,
  Alpha = TRUE,
  Omega = TRUE,
  Psi = TRUE,
  Delta = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convertToCodaObject_+3A_hm">hM</code></td>
<td>
<p>a fitted <code>Hmsc</code> model object</p>
</td></tr>
<tr><td><code id="convertToCodaObject_+3A_start">start</code></td>
<td>
<p>index of first MCMC sample included</p>
</td></tr>
<tr><td><code id="convertToCodaObject_+3A_spnamesnumbers">spNamesNumbers</code></td>
<td>
<p>logical of length 2, where first entry controls whether species names are printed,
and second entry controls whether species numbers are printed</p>
</td></tr>
<tr><td><code id="convertToCodaObject_+3A_covnamesnumbers">covNamesNumbers</code></td>
<td>
<p>Logical of length 2, where first entry controls whether covariate names are printed,
and second entry controls whether covariate numbers are printed</p>
</td></tr>
<tr><td><code id="convertToCodaObject_+3A_trnamesnumbers">trNamesNumbers</code></td>
<td>
<p>Logical of length 2, where first entry controls whether trait names are printed,
and second entry controls whether traits numbers are printed</p>
</td></tr>
<tr><td><code id="convertToCodaObject_+3A_beta">Beta</code></td>
<td>
<p>logical indicating whether posterior of Beta is included</p>
</td></tr>
<tr><td><code id="convertToCodaObject_+3A_gamma">Gamma</code></td>
<td>
<p>logical indicating whether posterior of Gamma is included</p>
</td></tr>
<tr><td><code id="convertToCodaObject_+3A_v">V</code></td>
<td>
<p>logical indicating whether posterior of V is included</p>
</td></tr>
<tr><td><code id="convertToCodaObject_+3A_sigma">Sigma</code></td>
<td>
<p>logical indicating whether posterior of Sigma is included</p>
</td></tr>
<tr><td><code id="convertToCodaObject_+3A_rho">Rho</code></td>
<td>
<p>logical indicating whether posterior of Rho is included</p>
</td></tr>
<tr><td><code id="convertToCodaObject_+3A_eta">Eta</code></td>
<td>
<p>logical indicating whether posterior of Eta is included</p>
</td></tr>
<tr><td><code id="convertToCodaObject_+3A_lambda">Lambda</code></td>
<td>
<p>logical indicating whether posterior of Lambda is included</p>
</td></tr>
<tr><td><code id="convertToCodaObject_+3A_alpha">Alpha</code></td>
<td>
<p>logical indicating whether posterior of Alpha is included</p>
</td></tr>
<tr><td><code id="convertToCodaObject_+3A_omega">Omega</code></td>
<td>
<p>logical indicating whether posterior of Omega is included</p>
</td></tr>
<tr><td><code id="convertToCodaObject_+3A_psi">Psi</code></td>
<td>
<p>logical indicating whether posterior of Psi is included</p>
</td></tr>
<tr><td><code id="convertToCodaObject_+3A_delta">Delta</code></td>
<td>
<p>logical indicating whether posterior of Delta is included</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list that can be analysed with <a href="https://CRAN.R-project.org/package=coda"><span class="pkg">coda</span></a> functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert recorded posterior samples in \code{Hmsc} object to coda object
codaObject = convertToCodaObject(TD$m)

# Convert recorded posterior samples, starting from sample 100, in m object to coda object
codaObject = convertToCodaObject(TD$m, start=100)

</code></pre>

<hr>
<h2 id='createPartition'>createPartition</h2><span id='topic+createPartition'></span>

<h3>Description</h3>

<p>Constructs a partition vector given the number of folds and column of study design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createPartition(hM, nfolds = 10, column = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createPartition_+3A_hm">hM</code></td>
<td>
<p>a fitted <code>Hmsc</code> model object</p>
</td></tr>
<tr><td><code id="createPartition_+3A_nfolds">nfolds</code></td>
<td>
<p>number of cross-validation folds</p>
</td></tr>
<tr><td><code id="createPartition_+3A_column">column</code></td>
<td>
<p>name or index of the column in the <code>studyDesign</code> matrix, corresponding to the level for which units are splitted into folds</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector describing the fold of each sampling unit
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create 3 folds for a HMSC object
partition = createPartition(TD$m, nfolds = 3)
</code></pre>

<hr>
<h2 id='evaluateModelFit'>evaluateModelFit</h2><span id='topic+evaluateModelFit'></span>

<h3>Description</h3>

<p>Computes measures of model fit for a <code>Hmsc</code> model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluateModelFit(hM, predY)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evaluateModelFit_+3A_hm">hM</code></td>
<td>
<p>a fitted <code>Hmsc</code> model object</p>
</td></tr>
<tr><td><code id="evaluateModelFit_+3A_predy">predY</code></td>
<td>
<p>array of predictions, typically posterior sample</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All measures of model fit are based on comparing the posterior predictive distribution (<code>predY)</code>)
to the observed values (<code>hM$Y</code>). The predicted distribution is first summarized to
a single matrix of predicted values by taking the posterior mean (for normal and probit models)
or posterior median (for Poisson models). All measures of model fit are given as vectors with
one value for each species.
</p>
<p>The kinds of measures of model fit depend on the type of response variable.
For all types of response variables, root-mean-square error (RMSE) between predicted
and observed values is computed.
For normal models, R2 is computed as squared pearson
correlation between observed and predicted values, times the sign of the correlation.
For probit models, Tjur R2 and AUC are
computed. For Poisson models, a pseudo-R2 is computed as
squared spearman correlation between observed and predicted values, times the sign of the correlation (SR2).
For Poisson models, the observed and predicted data are also truncated to occurrences (presence-absences),
for which the same measures are given as for the probit models (O.RMSE, O.AUC and O.TjurR2).
For Poisson models, the observed and predicted data are also subsetted to conditional on presence,
for which the root-mean-square error and pseudo-R2 based on squared spearman correlation
are computed (C.RMSE, C.SR2).
</p>
<p>The measures O.RMSE, O.AUC, O.TjurR2, C.RMSE and C.SR2 can be computed only if the option
<code>expected=FALSE</code> has been used when making the predictions
</p>
<p>If the model includes a mixture of response variable types, the resulting measures of model fit
contain NA's for those response variables for which they cannot be computed.
</p>


<h3>Value</h3>

<p>a list of measures of model fit
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Evaluate model fit
preds = computePredictedValues(TD$m)
MF = evaluateModelFit(hM=TD$m, predY=preds)

# Evaluate model performance based on cross validation: this will be slow
## Not run: 
partition = createPartition(TD$m, nfolds = 2)
predsCV1 = computePredictedValues(TD$m, partition=partition)
MF = evaluateModelFit(hM=TD$m, predY=predsCV1)

## End(Not run)
</code></pre>

<hr>
<h2 id='getPostEstimate'>getPostEstimate</h2><span id='topic+getPostEstimate'></span>

<h3>Description</h3>

<p>Calculates mean, support and other posterior quantities for a specified model parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPostEstimate(
  hM,
  parName,
  r = 1,
  x = NULL,
  q = c(),
  chainIndex = 1:length(hM$postList),
  start = 1,
  thin = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPostEstimate_+3A_hm">hM</code></td>
<td>
<p>a fitted <code>Hmsc</code> model object</p>
</td></tr>
<tr><td><code id="getPostEstimate_+3A_parname">parName</code></td>
<td>
<p>name of the parameter to be summarized. Can take value of
model's baseline parameters, &quot;Omega&quot; or &quot;OmegaCor&quot;.</p>
</td></tr>
<tr><td><code id="getPostEstimate_+3A_r">r</code></td>
<td>
<p>the random level for which to calculate the parameter. Has effect only for Eta, Lambda, Omega and OmegaCor.</p>
</td></tr>
<tr><td><code id="getPostEstimate_+3A_x">x</code></td>
<td>
<p>values of covariates for covariate dependent omega</p>
</td></tr>
<tr><td><code id="getPostEstimate_+3A_q">q</code></td>
<td>
<p>vector of quantiles to calculate.</p>
</td></tr>
<tr><td><code id="getPostEstimate_+3A_chainindex">chainIndex</code></td>
<td>
<p>which posterior chains to use for summarization (defaults to all)</p>
</td></tr>
<tr><td><code id="getPostEstimate_+3A_start">start</code></td>
<td>
<p>index of first MCMC sample included</p>
</td></tr>
<tr><td><code id="getPostEstimate_+3A_thin">thin</code></td>
<td>
<p>thinning interval of posterior distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of posterior quantities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get posterior mean and support for species' responses to environmental covariates
postBeta = getPostEstimate(TD$m, parName='Beta')

# Get posterior mean and support for species' responses to latent factors for the first random level
postLambda = getPostEstimate(TD$m, parName='Lambda', r=1)

</code></pre>

<hr>
<h2 id='Hmsc'>Hmsc</h2><span id='topic+Hmsc'></span>

<h3>Description</h3>

<p>Creates an <code>Hmsc</code>-class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hmsc(
  Y,
  XFormula = ~.,
  XData = NULL,
  X = NULL,
  XScale = TRUE,
  XSelect = NULL,
  XRRRData = NULL,
  XRRRFormula = ~. - 1,
  XRRR = NULL,
  ncRRR = 2,
  XRRRScale = TRUE,
  YScale = FALSE,
  studyDesign = NULL,
  ranLevels = NULL,
  ranLevelsUsed = names(ranLevels),
  TrFormula = NULL,
  TrData = NULL,
  Tr = NULL,
  TrScale = TRUE,
  phyloTree = NULL,
  C = NULL,
  distr = "normal",
  truncateNumberOfFactors = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Hmsc_+3A_y">Y</code></td>
<td>
<p>a matrix of species occurences or abundances</p>
</td></tr>
<tr><td><code id="Hmsc_+3A_xformula">XFormula</code></td>
<td>
<p>a <code><a href="stats.html#topic+formula">formula</a></code>-class object for fixed effects
(linear regression)</p>
</td></tr>
<tr><td><code id="Hmsc_+3A_xdata">XData</code></td>
<td>
<p>a data frame of measured covariates for fixed effects with
<code><a href="stats.html#topic+formula">formula</a></code>-based specification</p>
</td></tr>
<tr><td><code id="Hmsc_+3A_x">X</code></td>
<td>
<p>a matrix of measured covariates for fixed effects with direct specification</p>
</td></tr>
<tr><td><code id="Hmsc_+3A_xscale">XScale</code></td>
<td>
<p>a boolean flag indicating whether to scale covariates for the fixed effects</p>
</td></tr>
<tr><td><code id="Hmsc_+3A_xselect">XSelect</code></td>
<td>
<p>a list describing how variable selection is to be applied</p>
</td></tr>
<tr><td><code id="Hmsc_+3A_xrrrdata">XRRRData</code></td>
<td>
<p>a data frame of covariates for reduced-rank regression</p>
</td></tr>
<tr><td><code id="Hmsc_+3A_xrrrformula">XRRRFormula</code></td>
<td>
<p><code><a href="stats.html#topic+formula">formula</a></code> for reduced-rank regression</p>
</td></tr>
<tr><td><code id="Hmsc_+3A_xrrr">XRRR</code></td>
<td>
<p>a matrix of covariates for reduced-rank regression</p>
</td></tr>
<tr><td><code id="Hmsc_+3A_ncrrr">ncRRR</code></td>
<td>
<p>number of covariates (linear combinations) for reduced-rank regression</p>
</td></tr>
<tr><td><code id="Hmsc_+3A_xrrrscale">XRRRScale</code></td>
<td>
<p>a boolean flag indicating whether to scale covariates for reduced-rank regression</p>
</td></tr>
<tr><td><code id="Hmsc_+3A_yscale">YScale</code></td>
<td>
<p>a boolean flag whether to scale responses for which normal distribution is assumed</p>
</td></tr>
<tr><td><code id="Hmsc_+3A_studydesign">studyDesign</code></td>
<td>
<p>a data frame of correspondence between sampling units and units on different levels of latent
factors</p>
</td></tr>
<tr><td><code id="Hmsc_+3A_ranlevels">ranLevels</code></td>
<td>
<p>a named list of <code>HmscRandomLevel</code>-class objects, specifying the structure and data for random
levels</p>
</td></tr>
<tr><td><code id="Hmsc_+3A_ranlevelsused">ranLevelsUsed</code></td>
<td>
<p>a vector with names of levels of latent factors that are used in the analysis</p>
</td></tr>
<tr><td><code id="Hmsc_+3A_trformula">TrFormula</code></td>
<td>
<p>a <code><a href="stats.html#topic+formula">formula</a></code>-class object for regression
dependence of <code class="reqn">\beta_{kj}</code> coefficients on species traits</p>
</td></tr>
<tr><td><code id="Hmsc_+3A_trdata">TrData</code></td>
<td>
<p>a data frame of measured species traits for
<code><a href="stats.html#topic+formula">formula</a></code>-based specification</p>
</td></tr>
<tr><td><code id="Hmsc_+3A_tr">Tr</code></td>
<td>
<p>a matrix of measured traits for direct specification</p>
</td></tr>
<tr><td><code id="Hmsc_+3A_trscale">TrScale</code></td>
<td>
<p>a boolean flag whether to scale values of species traits</p>
</td></tr>
<tr><td><code id="Hmsc_+3A_phylotree">phyloTree</code></td>
<td>
<p>a phylogenetic tree (object of class <code>phylo</code> or <code>corPhyl</code>) for species in <code>Y</code></p>
</td></tr>
<tr><td><code id="Hmsc_+3A_c">C</code></td>
<td>
<p>a phylogenic correlation matrix for species in <code>Y</code></p>
</td></tr>
<tr><td><code id="Hmsc_+3A_distr">distr</code></td>
<td>
<p>a string shortcut or <code class="reqn">n_s \times 2</code> matrix specifying the observation models</p>
</td></tr>
<tr><td><code id="Hmsc_+3A_truncatenumberoffactors">truncateNumberOfFactors</code></td>
<td>
<p>logical, reduces the maximal number of latent factor to be at most the number of species</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Matrix <code class="reqn">Y</code> may contain missing values, but it is not recommended to add a
species/sampling unit with fully missing data, since those do not bring any new additional information.
</p>
<p>Only one of <code>XFormula</code>-<code>XData</code> and <code>X</code> arguments can be specified. Similar requirement applies to
<code>TrFormula</code>-<code>TrData</code> and <code>Tr</code>. It is recommended to use the specification with <code><a href="stats.html#topic+formula">formula</a></code>,
since that information enables additional features for postprocessing of the fitted model.
</p>
<p>As default, scaling is applied for <code>X</code> and <code>Tr</code> matrices, but not for <code>Y</code> matrix. If the <code>X</code> and/or <code>Tr</code> matrices are
scaled, the estimated parameters are back-transformed so that the estimated parameters correspond to the original
<code>X</code> and <code>Tr</code> matrices, not the scaled ones. In contrast, if <code>Y</code> is scaled, the estimated parameters are not
back-transformed because doing so is not possible for all model parameters. Thus, the estimated parameters
correspond to the scaled <code>Y</code> matrix, not the original one. If the <code>Y</code> matrix is scaled, the predictions
generated by <code>predict</code> are back-transformed, so that the predicted <code>Y</code> matrices are directly comparable
to the original <code>Y</code> matrix. If default priors are assumed, it is recommended that all matrices (<code>X</code>, <code>Tr</code> and <code>Y</code>) are scaled.
</p>
<p>The object <code>XSelect</code> is a list. Each object of the list <code>Xsel = XSelect[[i]]</code> is a named list with objects
<code>Xsel$covGroup</code>, <code>Xsel$spGroup</code> and <code>Xsel$q</code>. The parameter <code>covGroup</code> is a vector containing
the columns of the matrix <code>X</code> for which variable selection is applied. The parameter <code>spGroup</code>
is a vector of length equal to the number of species <code>ns</code>, with values <code>1,...,ng</code>,
where <code>ng</code> is the number of
groups of species for which variable selection is applied simultanously. The parameter
<code>q</code> is a vector of length <code>ng</code>, containing the prior probabilities by which the variables
are to be included.
For example, choosing <code>covGroup = c(2,3)</code>, <code>spGroup = rep(1,ns)</code> and <code>q=0.1</code> either includes
or excludes both of the covariates 2 and 3 simultaneously for all species. For another example, choosing <code>covGroup = c(2,3)</code>,
<code>spGroup = 1:ns</code> and <code>q=rep(0.1,ns)</code> either includes
or excludes both of the covariates 2 and 3 separately for each species.
</p>
<p>The included random levels are specified by the <code>ranLevels</code> and <code>ranLevelsUsed</code> arguments. The
correspondence between units of each random level and rows of <code>Y</code> must be specified by a column of
<code>studyDesign</code>, which corresponds to the name of a list item in <code>ranLevels</code>. It is
possible to provide an arbitrary number of columns in <code>studyDesign</code> that are not listed in <code>ranLevels</code>.
These do not affect the model formulation or fitting scheme, but can be utilized during certain functions
postprocessing the results of statistical model fit.
</p>
<p>The <code>distr</code> argument may be either a matrix, a string literal, or a vector of string literals. In the case of
a matrix, the dimension must be <code class="reqn">n_s \times 2</code>, where the first column defines the family of the observation
model and the second argument defines the dispersion property. The elements of the first column must take values
1-normal, 2-probit and 3-Poisson with log link function. The second argument stands for the dispersion parameter
being fixed (0) or estimated (1). The default fixed values of the dispersion parameters are 1 for normal and probit,
and 0.01 for Poisson (implemented as a limiting case of lognormally-overdispersed Poisson). Alternatively, a string
literal shortcut can be given as a value to the <code>distr</code> argument, simultaniously specifying similar class of
observation models for all species. The available shortcuts are <code>"normal"</code>, <code>"probit"</code>, <code>"poisson"</code>,
<code>"lognormal poisson"</code>. If <code>distr</code> is a vector of string literals, each element corresponds to one species,
should be either <code>"normal"</code>, <code>"probit"</code>, <code>"poisson"</code>, <code>"lognormal poisson"</code>,
and these can be abbreviated as long as they are unique strings.
The matrix argument and the vector of string literals allows specifying different observation
models for different species.
</p>
<p>By default this constructor assigns default priors to the latent factors. Those priors are designed to be
reasonably flat assuming that the covariates, species traits and normally distributed responses are scaled.
In case when other priors needed to be specified, a call of <code>setPriors.Hmsc</code> methods should be made,
where the particular priors may be specified.
</p>


<h3>Value</h3>

<p>An object of <code>Hmsc</code> class without any posterior samples.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HmscRandomLevel">HmscRandomLevel</a></code>, <code><a href="#topic+sampleMcmc">sampleMcmc</a></code>, <code><a href="#topic+setPriors.Hmsc">setPriors.Hmsc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating a Hmsc object without phylogeny, trait data or random levels
m = Hmsc(Y=TD$Y, XData=TD$X, XFormula=~x1+x2)

# Creating a Hmsc object with phylogeny and traits
m = Hmsc(Y=TD$Y, XData=TD$X, XFormula=~x1+x2,
TrData=TD$Tr, TrFormula=~T1+T2, phyloTree=TD$phylo)

# Creating a Hmsc object with 2 nested random levels (50 sampling units in 20 plots)
studyDesign = data.frame(sample = as.factor(1:50), plot = as.factor(sample(1:20,50,replace=TRUE)))
rL1 = HmscRandomLevel(units=levels(TD$studyDesign$plot))
rL2 = HmscRandomLevel(units=levels(TD$studyDesign$sample))
m = Hmsc(Y=TD$Y, XData=TD$X, XFormula=~x1+x2,
studyDesign=studyDesign,ranLevels=list("sample"=rL1,"plot"=rL2))

</code></pre>

<hr>
<h2 id='HmscRandomLevel'>Create an <code>Hmsc</code> random level</h2><span id='topic+HmscRandomLevel'></span>

<h3>Description</h3>

<p>Specifies the structure of a random factor, including
whether the random factor is assumed to be spatially explicit
or not, the spatial coordinates and the potential structure of
covariate-dependent random factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HmscRandomLevel(
  sData = NULL,
  sMethod = "Full",
  distMat = NULL,
  xData = NULL,
  units = NULL,
  N = NULL,
  nNeighbours = 10,
  sKnot = NULL,
  longlat = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HmscRandomLevel_+3A_sdata">sData</code></td>
<td>
<p>a matrix or a dataframe containing spatial or temporal
coordinates of units of the random level, or a similar
<code>SpatialPoints</code> structure of the <a href="https://CRAN.R-project.org/package=sp"><span class="pkg">sp</span></a> package. If
spatial coordinates are unprojected longitude and latitude,
great circle distances will be calculated internally. All
spatial locations should be unique. If you have several
observations in the same point, they should be identified by
the random levels.</p>
</td></tr>
<tr><td><code id="HmscRandomLevel_+3A_smethod">sMethod</code></td>
<td>
<p>a string specifying which spatial method to be
used. Possible values are <code>"Full"</code>, <code>"GPP"</code> and
<code>"NNGP"</code></p>
</td></tr>
<tr><td><code id="HmscRandomLevel_+3A_distmat">distMat</code></td>
<td>
<p>a distance matrix containing the distances between
units of the random level, with unit names as rownames, or a
<code><a href="stats.html#topic+dist">dist</a></code> structure with location
Labels. <code>distMat</code> cannot be used with <code>"GPP"</code> spatial
model.</p>
</td></tr>
<tr><td><code id="HmscRandomLevel_+3A_xdata">xData</code></td>
<td>
<p>a dataframe containing the covariates measured at the
units of the random level for covariate-dependent associations</p>
</td></tr>
<tr><td><code id="HmscRandomLevel_+3A_units">units</code></td>
<td>
<p>a vector, specifying the names of the units of a
non-structured level</p>
</td></tr>
<tr><td><code id="HmscRandomLevel_+3A_n">N</code></td>
<td>
<p>number of unique units on this level</p>
</td></tr>
<tr><td><code id="HmscRandomLevel_+3A_nneighbours">nNeighbours</code></td>
<td>
<p>a scalar specifying the number of neighbours to
be used in case the spatial method is set to <code>NNGP</code>. Only
positive values smaller than the total number of plots are
allowed.</p>
</td></tr>
<tr><td><code id="HmscRandomLevel_+3A_sknot">sKnot</code></td>
<td>
<p>a dataframe containing the knot locations to be used
for the Gaussian predictive process if <code>sMethod</code> is set to
<code>"GPP"</code>. Suitable data can be produced with
<code><a href="#topic+constructKnots">constructKnots</a></code>. The knot locations shall not
duplicate <code>sData</code>.</p>
</td></tr>
<tr><td><code id="HmscRandomLevel_+3A_longlat">longlat</code></td>
<td>
<p>Interpret coordinate data <code>sData</code> as longitude
and latitude in decimal degrees. If this is <code>TRUE</code>, great
circle distances will be used instead of Euclidean distances.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only one of <code>sData</code>, <code>distMat</code>, <code>xData</code>, <code>units</code> and <code>N</code> arguments can be
provided.
</p>
<p>As a good practice, we recommend to specify all available units for a random level, even if some of those are not
used for training the model.
</p>


<h3>Value</h3>

<p>a <code>HmscRandomLevel</code>-class object that can be used for <code>Hmsc</code>-class object construction
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setPriors.Hmsc">setPriors.Hmsc</a></code> to change the default priors
of an existing <code>HmscRandomLevel</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setting a random level with 50 units
rL = HmscRandomLevel(units=TD$studyDesign$sample)

# Setting a spatial random level
rL = HmscRandomLevel(sData=TD$xycoords)

# Setting a covariate-dependent random level.
rL = HmscRandomLevel(xData=data.frame(x1=rep(1,length(TD$X$x1)),x2=TD$X$x2))

</code></pre>

<hr>
<h2 id='plotBeta'>plotBeta</h2><span id='topic+plotBeta'></span>

<h3>Description</h3>

<p>Plots heatmaps of parameter estimates or posterior support values of species' environmental responses, i.e. how species in <code>Y</code> responds to covariates in <code>X</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotBeta(
  hM,
  post,
  param = "Support",
  plotTree = FALSE,
  SpeciesOrder = "Original",
  SpVector = NULL,
  covOrder = "Original",
  covVector = NULL,
  spNamesNumbers = c(TRUE, TRUE),
  covNamesNumbers = c(TRUE, TRUE),
  supportLevel = 0.9,
  split = 0.3,
  cex = c(0.7, 0.7, 0.8),
  colors = colorRampPalette(c("blue", "white", "red")),
  colorLevels = NULL,
  mar = NULL,
  marTree = c(6, 0, 2, 0),
  mgp = c(3, 2, 0),
  main = NULL,
  smallplot = NULL,
  bigplot = NULL,
  newplot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotBeta_+3A_hm">hM</code></td>
<td>
<p>a fitted <code>Hmsc</code> model object</p>
</td></tr>
<tr><td><code id="plotBeta_+3A_post">post</code></td>
<td>
<p>posterior summary of Beta parameters obtained from <code><a href="#topic+getPostEstimate">getPostEstimate</a></code></p>
</td></tr>
<tr><td><code id="plotBeta_+3A_param">param</code></td>
<td>
<p>controls which parameter is plotted, current options include &quot;Mean&quot; for posterior mean estimate,
&quot;Support&quot; for the level of statistical support measured by posterior probability for a positive or negative
response, and &quot;Sign&quot; to indicate whether the response is positive, negative, or neither of these given the
chosen <code>supportLevel</code></p>
</td></tr>
<tr><td><code id="plotBeta_+3A_plottree">plotTree</code></td>
<td>
<p>logical. Whether species' environmental responses is to be mapped onto the phylogeny used in
model fitting</p>
</td></tr>
<tr><td><code id="plotBeta_+3A_speciesorder">SpeciesOrder</code></td>
<td>
<p>controls the ordering of species, current options are &quot;Original&quot;, &quot;Tree&quot;, and &quot;Vector&quot;.
If SpeciesOrder = &quot;Vector&quot;, an ordering vector must be provided (see SpVector). If plotTree = TRUE, SpeciesOrder
is ignored</p>
</td></tr>
<tr><td><code id="plotBeta_+3A_spvector">SpVector</code></td>
<td>
<p>controls the ordering of species if SpeciesOrder = &quot;Vector&quot;. If a subset of species are listed,
only those will be plotted. For alphabetic ordering, try
<code>match(1:hM$ns, as.numeric(as.factor(colnames(hM$Y))))</code></p>
</td></tr>
<tr><td><code id="plotBeta_+3A_covorder">covOrder</code></td>
<td>
<p>controls the ordering of covariates, current options are &quot;Original&quot; and &quot;Vector&quot;.
If covOrder = &quot;Vector&quot;, an ordering vector must be provided (see covVector)</p>
</td></tr>
<tr><td><code id="plotBeta_+3A_covvector">covVector</code></td>
<td>
<p>controls the ordering of covariates if covOrder = &quot;Vector&quot;. If a subset of covariates are listed,
only those will be plotted</p>
</td></tr>
<tr><td><code id="plotBeta_+3A_spnamesnumbers">spNamesNumbers</code></td>
<td>
<p>logical of length 2, where first entry controls whether species names are added to axes,
and second entry controls whether species numbers are added</p>
</td></tr>
<tr><td><code id="plotBeta_+3A_covnamesnumbers">covNamesNumbers</code></td>
<td>
<p>logical of length 2, where first entry controls whether covariate names are added to axes,
and second entry controls whether covariate numbers are added</p>
</td></tr>
<tr><td><code id="plotBeta_+3A_supportlevel">supportLevel</code></td>
<td>
<p>controls threshold posterior support for plotting</p>
</td></tr>
<tr><td><code id="plotBeta_+3A_split">split</code></td>
<td>
<p>if plotTree = TRUE, controls the division of the plotting window between the tree and the heatmap.</p>
</td></tr>
<tr><td><code id="plotBeta_+3A_cex">cex</code></td>
<td>
<p>controls character expansion (font size). Three values, controlling covariate names, species names,
and color legend axis labels</p>
</td></tr>
<tr><td><code id="plotBeta_+3A_colors">colors</code></td>
<td>
<p>controls the colors of the heatmap, default value <code>colorRampPalette(c("blue","white","red"))</code></p>
</td></tr>
<tr><td><code id="plotBeta_+3A_colorlevels">colorLevels</code></td>
<td>
<p>number of color levels used in the heatmap</p>
</td></tr>
<tr><td><code id="plotBeta_+3A_mar">mar</code></td>
<td>
<p>plotting margins</p>
</td></tr>
<tr><td><code id="plotBeta_+3A_martree">marTree</code></td>
<td>
<p>plotting margins for phylogenetic tree</p>
</td></tr>
<tr><td><code id="plotBeta_+3A_mgp">mgp</code></td>
<td>
<p>can be used to set the location of the scale bar</p>
</td></tr>
<tr><td><code id="plotBeta_+3A_main">main</code></td>
<td>
<p>main title for the plot.</p>
</td></tr>
<tr><td><code id="plotBeta_+3A_smallplot">smallplot</code></td>
<td>
<p>passed to <code><a href="fields.html#topic+image.plot">image.plot</a></code></p>
</td></tr>
<tr><td><code id="plotBeta_+3A_bigplot">bigplot</code></td>
<td>
<p>passed to <code><a href="fields.html#topic+image.plot">image.plot</a></code></p>
</td></tr>
<tr><td><code id="plotBeta_+3A_newplot">newplot</code></td>
<td>
<p>set to  false if the plot will be part of multi-panel plot initialized with par(mfrow)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Plot posterior support values of species' environmental responses
betaPost=getPostEstimate(TD$m, "Beta")
plotBeta(TD$m, post=betaPost, param="Support")

# Plot parameter estimates of species' environmental responses together with the phylogenetic tree
betaPost=getPostEstimate(TD$m, "Beta")
plotBeta(TD$m, post=betaPost, param="Mean", plotTree=TRUE)

</code></pre>

<hr>
<h2 id='plotGamma'>plotGamma</h2><span id='topic+plotGamma'></span>

<h3>Description</h3>

<p>Plots heatmaps of parameter estimates or posterior support values of trait effects
on species' environmental responses, i.e. how environmental responses in <code>Beta</code> responds to
covariates in <code>X</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGamma(
  hM,
  post,
  param = "Support",
  trOrder = "Original",
  trVector = NULL,
  covOrder = "Original",
  covVector = NULL,
  trNamesNumbers = c(TRUE, TRUE),
  covNamesNumbers = c(TRUE, TRUE),
  supportLevel = 0.9,
  main = NULL,
  cex = c(0.8, 0.8, 0.8),
  colors = colorRampPalette(c("blue", "white", "red")),
  colorLevels = NULL,
  mar = c(6, 9, 2, 0),
  smallplot = NULL,
  bigplot = NULL,
  newplot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotGamma_+3A_hm">hM</code></td>
<td>
<p>a fitted <code>Hmsc</code> model object</p>
</td></tr>
<tr><td><code id="plotGamma_+3A_post">post</code></td>
<td>
<p>posterior summary of Gamma parameters obtained from <code><a href="#topic+getPostEstimate">getPostEstimate</a></code></p>
</td></tr>
<tr><td><code id="plotGamma_+3A_param">param</code></td>
<td>
<p>controls which parameter is plotted, current options include &quot;Mean&quot; for posterior mean
estimate, &quot;Support&quot; for the level of statistical support measured by posterior probability for a
positive or negative response, and &quot;Sign&quot; to indicate whether the response is positive,
negative, or neither of these given the chosen <code>supportLevel</code></p>
</td></tr>
<tr><td><code id="plotGamma_+3A_trorder">trOrder</code></td>
<td>
<p>controls the ordering of traits, current options are &quot;Original&quot;, and &quot;Vector&quot;.
If trOrder = &quot;Vector&quot;, an ordering vector must be provided (see trVector)</p>
</td></tr>
<tr><td><code id="plotGamma_+3A_trvector">trVector</code></td>
<td>
<p>controls the ordering of traits if trOrder = &quot;Vector&quot;. If a subset of traits
are listed, only those will be plotted</p>
</td></tr>
<tr><td><code id="plotGamma_+3A_covorder">covOrder</code></td>
<td>
<p>controls the ordering of covariates, current options are &quot;Original&quot; and
&quot;Vector&quot;. If covOrder = &quot;Vector&quot;, an ordering vector must be provided (see covVector)</p>
</td></tr>
<tr><td><code id="plotGamma_+3A_covvector">covVector</code></td>
<td>
<p>controls the ordering of covariates if covOrder = &quot;Vector&quot;. If a subset of
covariates are listed, only those will be plotted</p>
</td></tr>
<tr><td><code id="plotGamma_+3A_trnamesnumbers">trNamesNumbers</code></td>
<td>
<p>logical of length 2, where first entry controls whether trait names
are added to axes, and second entry controls whether traits numbers are added</p>
</td></tr>
<tr><td><code id="plotGamma_+3A_covnamesnumbers">covNamesNumbers</code></td>
<td>
<p>logical of length 2, where first entry controls whether covariate names
are added to axes, and second entry controls whether covariate numbers are added</p>
</td></tr>
<tr><td><code id="plotGamma_+3A_supportlevel">supportLevel</code></td>
<td>
<p>controls threshold posterior support for plotting</p>
</td></tr>
<tr><td><code id="plotGamma_+3A_main">main</code></td>
<td>
<p>main title for the plot</p>
</td></tr>
<tr><td><code id="plotGamma_+3A_cex">cex</code></td>
<td>
<p>controls character expansion (font size). Three values, controlling covariate names,
trait names, and color legend axis labels</p>
</td></tr>
<tr><td><code id="plotGamma_+3A_colors">colors</code></td>
<td>
<p>controls the colors of the heatmap, default value <code>colorRampPalette(c("blue","white","red"))</code></p>
</td></tr>
<tr><td><code id="plotGamma_+3A_colorlevels">colorLevels</code></td>
<td>
<p>number of color levels used in the heatmap</p>
</td></tr>
<tr><td><code id="plotGamma_+3A_mar">mar</code></td>
<td>
<p>plotting margins</p>
</td></tr>
<tr><td><code id="plotGamma_+3A_smallplot">smallplot</code></td>
<td>
<p>passed to <code><a href="fields.html#topic+image.plot">image.plot</a></code></p>
</td></tr>
<tr><td><code id="plotGamma_+3A_bigplot">bigplot</code></td>
<td>
<p>passed to <code><a href="fields.html#topic+image.plot">image.plot</a></code></p>
</td></tr>
<tr><td><code id="plotGamma_+3A_newplot">newplot</code></td>
<td>
<p>set to  false if the plot will be part of multi-panel plot</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Plot posterior support values of trait effects on environmental responses
gammaPost=getPostEstimate(TD$m, "Gamma")
plotGamma(TD$m, post=gammaPost, param="Support")

# Plot parameter estimates of trait effects on environmental responses
gammaPost=getPostEstimate(TD$m, "Gamma")
plotGamma(TD$m, post=gammaPost, param="Mean")

</code></pre>

<hr>
<h2 id='plotGradient'>plotGradient</h2><span id='topic+plotGradient'></span>

<h3>Description</h3>

<p>Plots an environmental gradient over one of the variables included in <code>XData</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGradient(
  hM,
  Gradient,
  predY,
  measure,
  xlabel = NULL,
  ylabel = NULL,
  index = 1,
  q = c(0.025, 0.5, 0.975),
  cicol = rgb(0, 0, 1, alpha = 0.5),
  pointcol = "lightgrey",
  pointsize = 1,
  showData = FALSE,
  jigger = 0,
  yshow = NA,
  showPosteriorSupport = TRUE,
  main,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotGradient_+3A_hm">hM</code></td>
<td>
<p>a fitted <code>Hmsc</code> model object</p>
</td></tr>
<tr><td><code id="plotGradient_+3A_gradient">Gradient</code></td>
<td>
<p>an object returned by <code><a href="#topic+constructGradient">constructGradient</a></code></p>
</td></tr>
<tr><td><code id="plotGradient_+3A_predy">predY</code></td>
<td>
<p>an object returned by applying the function <code><a href="stats.html#topic+predict">predict</a></code> to <code>Gradient</code></p>
</td></tr>
<tr><td><code id="plotGradient_+3A_measure">measure</code></td>
<td>
<p>whether to plot species richness (&quot;S&quot;), an individual species (&quot;Y&quot;) or community-weighted
mean trait values (&quot;T&quot;)</p>
</td></tr>
<tr><td><code id="plotGradient_+3A_xlabel">xlabel</code></td>
<td>
<p>label for x-axis</p>
</td></tr>
<tr><td><code id="plotGradient_+3A_ylabel">ylabel</code></td>
<td>
<p>label for y-axis</p>
</td></tr>
<tr><td><code id="plotGradient_+3A_index">index</code></td>
<td>
<p>which species or trait to plot</p>
</td></tr>
<tr><td><code id="plotGradient_+3A_q">q</code></td>
<td>
<p>quantiles of the credibility interval plotted</p>
</td></tr>
<tr><td><code id="plotGradient_+3A_cicol">cicol</code></td>
<td>
<p>colour with which the credibility interval is plotted</p>
</td></tr>
<tr><td><code id="plotGradient_+3A_pointcol">pointcol</code></td>
<td>
<p>colour with which the data points are plotted</p>
</td></tr>
<tr><td><code id="plotGradient_+3A_pointsize">pointsize</code></td>
<td>
<p>size in which the data points are plotted</p>
</td></tr>
<tr><td><code id="plotGradient_+3A_showdata">showData</code></td>
<td>
<p>whether raw data are plotted as well</p>
</td></tr>
<tr><td><code id="plotGradient_+3A_jigger">jigger</code></td>
<td>
<p>the amount by which the raw data are to be jiggered in x-direction (for factors) or
y-direction (for continuous covariates)</p>
</td></tr>
<tr><td><code id="plotGradient_+3A_yshow">yshow</code></td>
<td>
<p>scale y-axis so that these values are also
visible. This can used to scale y-axis so that it includes 0
and the expected maximum values.</p>
</td></tr>
<tr><td><code id="plotGradient_+3A_showposteriorsupport">showPosteriorSupport</code></td>
<td>
<p>add margin text on the posterior
support of predicted change from gradient minimum to maximum
for continuous gradients.</p>
</td></tr>
<tr><td><code id="plotGradient_+3A_main">main</code></td>
<td>
<p>main title for the plot.</p>
</td></tr>
<tr><td><code id="plotGradient_+3A_...">...</code></td>
<td>
<p>additional arguments for plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>measure</code>=&quot;Y&quot;, <code>index</code> selects which species to plot from <code>hM$spNames</code>.
For <code>measure</code>=&quot;T&quot;, <code>index</code> selects which trait to plot from <code>hM$trNames</code>.
With <code>measure</code>=&quot;S&quot; the row sum of <code>pred</code> is plotted,
and thus the interpretation of &quot;species richness&quot; holds only for probit models.
For Poisson models &quot;S&quot; shows the total count,
whereas for normal models it shows the summed response.
For <code>measure</code>=&quot;T&quot;,
in probit model the weighting is over species occurrences,
whereas in count models it is over individuals.
In normal models, the weights are exp-transformed predictions to avoid negative weights
</p>


<h3>Value</h3>

<p>For the case of a continuous covariate, returns the posterior probability that the plotted
variable is greater for the last sampling unit of the gradient than for the first sampling unit of
the gradient. For the case of a factor, returns the plot object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+constructGradient">constructGradient</a></code>, <code><a href="stats.html#topic+predict">predict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot response of species 2 over the gradient of environmental variable x1
Gradient = constructGradient(TD$m, focalVariable="x1")
predY = predict(TD$m, Gradient=Gradient)
plotGradient(TD$m, Gradient, pred=predY, measure="Y", index = 2, showData = TRUE, jigger = 0.05)
# Plot modelled species richness over the gradient of environmental variable x1
Gradient = constructGradient(TD$m, focalVariable="x1")
predY = predict(TD$m, Gradient=Gradient)
plotGradient(TD$m, Gradient, pred=predY, measure="S")

</code></pre>

<hr>
<h2 id='plotVariancePartitioning'>plotVariancePartitioning</h2><span id='topic+plotVariancePartitioning'></span>

<h3>Description</h3>

<p>Plots the results of variance partitioning of a <code>Hmsc</code> model produced by
<code><a href="#topic+computeVariancePartitioning">computeVariancePartitioning</a></code> as a barplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotVariancePartitioning(
  hM,
  VP,
  cols = NULL,
  main = "Variance Partitioning",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotVariancePartitioning_+3A_hm">hM</code></td>
<td>
<p>a fitted <code>Hmsc</code> model object</p>
</td></tr>
<tr><td><code id="plotVariancePartitioning_+3A_vp">VP</code></td>
<td>
<p>a Hmsc variance partitioning object produced by <code><a href="#topic+computeVariancePartitioning">computeVariancePartitioning</a></code></p>
</td></tr>
<tr><td><code id="plotVariancePartitioning_+3A_cols">cols</code></td>
<td>
<p>colors of the barplot</p>
</td></tr>
<tr><td><code id="plotVariancePartitioning_+3A_main">main</code></td>
<td>
<p>main title for the plot</p>
</td></tr>
<tr><td><code id="plotVariancePartitioning_+3A_...">...</code></td>
<td>
<p>additional parameters passed to the barplot function</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Plot how the explained variance of a previously fitted model is partitioned
VP = computeVariancePartitioning(TD$m)
plotVariancePartitioning(TD$m, VP)

</code></pre>

<hr>
<h2 id='poolMcmcChains'>poolMcmcChains</h2><span id='topic+poolMcmcChains'></span>

<h3>Description</h3>

<p>Combines a list of single or several MCMC chains into a single chain
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poolMcmcChains(postList, chainIndex = 1:length(postList), start = 1, thin = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="poolMcmcChains_+3A_postlist">postList</code></td>
<td>
<p>list of posterior chains</p>
</td></tr>
<tr><td><code id="poolMcmcChains_+3A_chainindex">chainIndex</code></td>
<td>
<p>index of chains to be included</p>
</td></tr>
<tr><td><code id="poolMcmcChains_+3A_start">start</code></td>
<td>
<p>index of first MCMC sample included</p>
</td></tr>
<tr><td><code id="poolMcmcChains_+3A_thin">thin</code></td>
<td>
<p>thinning between included MCMC samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with combined MCMC samples
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Combine the posteriors from all chains in a Hmsc object
postList = TD$m$postList
pooledPost = poolMcmcChains(postList)

</code></pre>

<hr>
<h2 id='predict.Hmsc'>predict</h2><span id='topic+predict.Hmsc'></span>

<h3>Description</h3>

<p>Calculates predicted values from a fitted <code>Hmsc</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Hmsc'
predict(
  object,
  post = poolMcmcChains(object$postList),
  XData = NULL,
  X = NULL,
  XRRRData = NULL,
  XRRR = NULL,
  studyDesign = object$studyDesign,
  ranLevels = object$ranLevels,
  Gradient = NULL,
  Yc = NULL,
  mcmcStep = 1,
  expected = FALSE,
  predictEtaMean = FALSE,
  predictEtaMeanField = FALSE,
  nParallel = 1,
  useSocket = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.Hmsc_+3A_object">object</code></td>
<td>
<p>a fitted <code>Hmsc</code> model object</p>
</td></tr>
<tr><td><code id="predict.Hmsc_+3A_post">post</code></td>
<td>
<p>a list of posterior samples of the HMSC model. By default uses all samples from the pooled
posterior of the hM object.</p>
</td></tr>
<tr><td><code id="predict.Hmsc_+3A_xdata">XData</code></td>
<td>
<p>a dataframe specifying the unpreprocessed covariates for the predictions to be made.
Works only if the <code>XFormula</code> argument was specified in the <code>Hmsc()</code> model constructor call.
Requirements are similar to those in the <code>Hmsc</code> model constructor.</p>
</td></tr>
<tr><td><code id="predict.Hmsc_+3A_x">X</code></td>
<td>
<p>a matrix specifying the covariates for the predictions to be made.
Only one of XData and X arguments may be provided.</p>
</td></tr>
<tr><td><code id="predict.Hmsc_+3A_xrrrdata">XRRRData</code></td>
<td>
<p>a dataframe of covariates for reduced-rank regression</p>
</td></tr>
<tr><td><code id="predict.Hmsc_+3A_xrrr">XRRR</code></td>
<td>
<p>a matrix of covariates for reduced-rank regression</p>
</td></tr>
<tr><td><code id="predict.Hmsc_+3A_studydesign">studyDesign</code></td>
<td>
<p>a matrix, specifying the structure of the study design for the prediction.
Requirements are similar to those of the <code>Hmsc</code> constructor. By default this argument is
assigned the study design of the training data in the fitted Hmsc model.</p>
</td></tr>
<tr><td><code id="predict.Hmsc_+3A_ranlevels">ranLevels</code></td>
<td>
<p>a list of <code>HmscRandomLevel</code> objects, futher specifying the structure of
random levels. Requirements are similar to those of the <code>Hmsc</code> constructor.
Each level must cover all units, specified in the correspondingly named column of <code>studyDesign</code>
argument. By default this argument is assigned the list of <code>HmscRandomLevel</code> objects
specified for fitting Hmsc model.</p>
</td></tr>
<tr><td><code id="predict.Hmsc_+3A_gradient">Gradient</code></td>
<td>
<p>an object returned by
<code><a href="#topic+constructGradient">constructGradient</a></code>. Providing <code>Gradient</code> is
an alternative for providing <code>XData</code>, <code>studyDesign</code>
and <code>ranLevels</code>. Cannot be used together with <code>Yc</code>.</p>
</td></tr>
<tr><td><code id="predict.Hmsc_+3A_yc">Yc</code></td>
<td>
<p>a matrix of the outcomes that are assumed to be known for
conditional predictions. Cannot be used together with
<code>Gradient</code>.</p>
</td></tr>
<tr><td><code id="predict.Hmsc_+3A_mcmcstep">mcmcStep</code></td>
<td>
<p>the number of extra mcmc steps used for updating the random effects</p>
</td></tr>
<tr><td><code id="predict.Hmsc_+3A_expected">expected</code></td>
<td>
<p>boolean flag indicating whether to return the location parameter of the observation
models or sample the values from those.</p>
</td></tr>
<tr><td><code id="predict.Hmsc_+3A_predictetamean">predictEtaMean</code></td>
<td>
<p>boolean flag indicating whether to use the estimated mean values of posterior
predictive distribution for random effets corresponding for the new units.</p>
</td></tr>
<tr><td><code id="predict.Hmsc_+3A_predictetameanfield">predictEtaMeanField</code></td>
<td>
<p>boolean flag indicating whether to use draws from the mean-field of the
posterior predictive distribution for random effets corresponding for the new units.</p>
</td></tr>
<tr><td><code id="predict.Hmsc_+3A_nparallel">nParallel</code></td>
<td>
<p>Number of parallel processes. Parallel processing
is only useful with new <code>Yc</code> data and extra
<code>mcmcStep</code>.</p>
</td></tr>
<tr><td><code id="predict.Hmsc_+3A_usesocket">useSocket</code></td>
<td>
<p>(logical) Use socket clusters in parallel
proecessing; these are the only alternative in Windows, but in
other systems this should be usually set <code>FALSE</code> for
forking.</p>
</td></tr>
<tr><td><code id="predict.Hmsc_+3A_...">...</code></td>
<td>
<p>other arguments passed to functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code>mcmcStep,the number of extra mcmc steps used for updating the random effects
for the Eta parameters, starting from the samples of the fitted Hmsc model in order to
account for the conditional infromation provided in the Yc argument. The higher this number is,
the more the obtained updated samples are unaffected by the posterior estimates of latent factors
in the model fitted to the training data and more resembles the true conditional posterior. However,
the elapsed time for conditional prediction grows approximately linearly as this parameter increases.
The exact number for sufficient is problem-dependent and should be assessed by e.g. gradually
increasing this parameter till the stationarity of the produced predictions.</code>
</p>


<h3>Value</h3>

<p>A list of length <code>length(post)</code>, each element of which contains a sample from the posterior
predictive distribution (given the sample of the Hmsc model parameters in the corresponding element of
the <code>post</code> argument)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predictLatentFactor">predictLatentFactor</a></code>
</p>

<hr>
<h2 id='predictLatentFactor'>predictLatentFactor</h2><span id='topic+predictLatentFactor'></span>

<h3>Description</h3>

<p>Draws samples from the conditional predictive
distribution of latent factors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictLatentFactor(
  unitsPred,
  units,
  postEta,
  postAlpha,
  rL,
  predictMean = FALSE,
  predictMeanField = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predictLatentFactor_+3A_unitspred">unitsPred</code></td>
<td>
<p>a factor vector with random level units for which
predictions are to be made</p>
</td></tr>
<tr><td><code id="predictLatentFactor_+3A_units">units</code></td>
<td>
<p>a factor vector with random level units that are
conditioned on</p>
</td></tr>
<tr><td><code id="predictLatentFactor_+3A_posteta">postEta</code></td>
<td>
<p>a list containing samples of random factors at
conditioned units</p>
</td></tr>
<tr><td><code id="predictLatentFactor_+3A_postalpha">postAlpha</code></td>
<td>
<p>a list containing samples of range (lengthscale)
parameters for latent factors</p>
</td></tr>
<tr><td><code id="predictLatentFactor_+3A_rl">rL</code></td>
<td>
<p>a <code>HmscRandomLevel</code>-class object that describes the
random level structure</p>
</td></tr>
<tr><td><code id="predictLatentFactor_+3A_predictmean">predictMean</code></td>
<td>
<p>a boolean flag indicating whether to return the
mean of the predictive Gaussian process distribution</p>
</td></tr>
<tr><td><code id="predictLatentFactor_+3A_predictmeanfield">predictMeanField</code></td>
<td>
<p>a boolean flag indicating whether to return
the samples from the mean-field distribution of the predictive
Gaussian process distribution</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Length of <code>units</code> vector and number of rows in
<code>postEta</code> matrix shall be equal. The method assumes that
the i-th row of <code>postEta</code> correspond to i-th element of
<code>units</code>.
</p>
<p>This method uses only the coordinates <code>rL$s</code> field of the
<code>rL$s</code> argument. This field shall be a matrix with rownames
covering the union of <code>unitsPred</code> and <code>units</code>
factors. Alternatively, it can use distance matrix
<code>rL$distMat</code> which is a symmetric square matrix with similar
row names as the coordinate data (except for the GPP models that
only can use coordinates).
</p>
<p>In case of spatial random level, the computational complexity of
the generic method scales cubically as the number of unobserved
units to be predicted. Both <code>predictMean=TRUE</code> and
<code>predictMeanField=TRUE</code> options decrease the asymptotic
complexity to linear. The <code>predictMeanField=TRUE</code> option
also preserves the uncertainty in marginal distribution of
predicted latent factors, but neglects the inter-dependece
between them.
</p>


<h3>Value</h3>

<p>a list of length <code>length(postEta)</code> containing samples
of random factors at <code>unitsPred</code> from their predictive
distribution conditional on the values at <code>units</code>
</p>

<hr>
<h2 id='prepareGradient'>prepareGradient</h2><span id='topic+prepareGradient'></span>

<h3>Description</h3>

<p>prepares a user-made environmental and/or spatial gradient to be used for prediction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepareGradient(hM, XDataNew, sDataNew)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prepareGradient_+3A_hm">hM</code></td>
<td>
<p>a fitted <code>Hmsc</code> model object.</p>
</td></tr>
<tr><td><code id="prepareGradient_+3A_xdatanew">XDataNew</code></td>
<td>
<p>a dataframe of the new <code>XData</code>.</p>
</td></tr>
<tr><td><code id="prepareGradient_+3A_sdatanew">sDataNew</code></td>
<td>
<p>a named list of the new <code>sData</code>, where the name gives
the spatial random level.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dataframe <code>XDataNew</code> is the for output as for input. The main purpose of this function is to prepare
the study design and random levels so that predictions can be made with the <code><a href="stats.html#topic+predict">predict</a></code> function.
Note that the difference between <code>constructGradient</code> and <code>prepareGradient</code> is that while
<code>prepareGradient</code> takes as input the new environmental and spatial data, <code>constructGradient</code>
generates those data to represent a new environmental gradient.
</p>


<h3>Value</h3>

<p>a named list with members <code>XDataNew</code>, <code>studyDesignNew</code> and <code>rLNew</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+constructGradient">constructGradient</a></code>, <code><a href="stats.html#topic+predict">predict</a></code>
</p>

<hr>
<h2 id='sampleMcmc'>sampleMCMC</h2><span id='topic+sampleMcmc'></span>

<h3>Description</h3>

<p>Samples the posterior with block-conditional Gibbs MCMC sampler
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleMcmc(
  hM,
  samples,
  transient = 0,
  thin = 1,
  initPar = NULL,
  verbose,
  adaptNf = rep(transient, hM$nr),
  nChains = 1,
  nParallel = 1,
  useSocket = TRUE,
  dataParList = NULL,
  updater = list(),
  fromPrior = FALSE,
  alignPost = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampleMcmc_+3A_hm">hM</code></td>
<td>
<p>a fitted <code>Hmsc</code> model object</p>
</td></tr>
<tr><td><code id="sampleMcmc_+3A_samples">samples</code></td>
<td>
<p>the number of MCMC samples to be obtained in each chain</p>
</td></tr>
<tr><td><code id="sampleMcmc_+3A_transient">transient</code></td>
<td>
<p>the number of MCMC steps that are executed before starting recording posterior samples</p>
</td></tr>
<tr><td><code id="sampleMcmc_+3A_thin">thin</code></td>
<td>
<p>the number of MCMC steps between each recording of samples from the posterior</p>
</td></tr>
<tr><td><code id="sampleMcmc_+3A_initpar">initPar</code></td>
<td>
<p>a named list of parameter values used for
initialization of MCMC states, or alternatively text
<code>"fixed effects"</code> to use linear Maximum Likelihood model
instead of randomizing from prior; the <code>"fixed effects"</code>
can shorten the transient phase of sampling, but will
initialize all chains to the same starting values</p>
</td></tr>
<tr><td><code id="sampleMcmc_+3A_verbose">verbose</code></td>
<td>
<p>the interval between MCMC steps printed to the console (default is an interval that prints ca. 50 reports)</p>
</td></tr>
<tr><td><code id="sampleMcmc_+3A_adaptnf">adaptNf</code></td>
<td>
<p>a vector of length <code class="reqn">n_r</code> with number of MCMC steps at which the adaptation of the
number of latent factors is conducted</p>
</td></tr>
<tr><td><code id="sampleMcmc_+3A_nchains">nChains</code></td>
<td>
<p>number of independent MCMC chains to be run</p>
</td></tr>
<tr><td><code id="sampleMcmc_+3A_nparallel">nParallel</code></td>
<td>
<p>number of parallel processes by which the chains
are executed.</p>
</td></tr>
<tr><td><code id="sampleMcmc_+3A_usesocket">useSocket</code></td>
<td>
<p>(logical) use socket clusters in parallel
processing; in Windows this is the only option, but in other
operating systems fork clusters are a better alternative, and
this should be set <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sampleMcmc_+3A_dataparlist">dataParList</code></td>
<td>
<p>a named list with pre-computed <code>Qg</code>, <code>iQg</code>, <code>RQg</code>, <code>detQg</code>, <code>rLPar</code>
parameters</p>
</td></tr>
<tr><td><code id="sampleMcmc_+3A_updater">updater</code></td>
<td>
<p>a named list, specifying which conditional updaters should be ommitted</p>
</td></tr>
<tr><td><code id="sampleMcmc_+3A_fromprior">fromPrior</code></td>
<td>
<p>whether prior (TRUE) or posterior (FALSE) is to be sampled</p>
</td></tr>
<tr><td><code id="sampleMcmc_+3A_alignpost">alignPost</code></td>
<td>
<p>boolean flag indicating whether the posterior of each chains should be aligned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The exact number of samples to be recorded in order to get a proper estimate of the full posterior with
Gibbs MCMC algorithms, as well as the required thinning and cut-off of transient is very problem-specific and
depends both on the model structure and the data itself. Therefore, in general it is very challenging to a priori
provide an informed recommendation on what values should be used for a particular problem. A common recommended
strategy involves executing the posterior sampling with MCMC with some guess of the values for these arguments,
checking the properties of the obtained samples (primarily potential scale reduction factor and effective sample
size), and adjusting the guess accordingly.
</p>
<p>The value of 1 for <code>thin</code> argument means that at each MCMC step after the transient a sample is recorded.
</p>
<p>Typically, the value of <code>nParallel</code> equal to <code>nChains</code> leads to most efficient usage of available
parallelization capacities. However, this may be not the case if R is configured with multi-tread linear
algebra libraries. For debug and test purposes, the <code>nParallel</code> should be set to 1, since only in this case a
details of the potentially encountered errors would be available.
</p>
<p>The <code>dataParList</code> argument may be handy for large problems that needs to be refitted multiple times, e.g.
with different prior values. In that case, the data parameters that are precomputed for the Hmsc sampling
scheme may require an undesirably lot of storage space if they are saved for each of the model.
Instead, they could be computed only once and then directly reused, therefore reducing the storing redundancy.
</p>
<p>Some of the available conditional updaters partially duplicate each other. In certain cases, the usage of all
of them may lead to suboptimal performance, compared to some subset of those. Then, it is possible to manually
disable some of them, by adding a <code>$UPDATER_NAME=FALSE</code> pair to the updater argument. Another usage of
this argument involves cases when some of the model parameters are known and have to be fixed. However, such
tweaks of the sampling scheme should be done with caution, as if compromized they would lead to erroneuos
results.
</p>


<h3>Value</h3>

<p>An <code>Hmsc</code>-class object with chains of posterior samples added to the <code>postList</code> field
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hmsc">Hmsc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## you need 1000 or more samples, but that will take too long
## in an example
m = sampleMcmc(TD$m, samples=10)

## Not run: 
## Record 1000 posterior samples while skipping 1 MCMC step between samples
## from 2 chains after discarding the first 500 MCMC steps
m = sampleMcmc(TD$m, samples=1000, transient=500, thin=2, nChains=2, nParallel=1)

## End(Not run)

</code></pre>

<hr>
<h2 id='samplePrior'>samplePrior</h2><span id='topic+samplePrior'></span>

<h3>Description</h3>

<p>Samples the parameter vector from prior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samplePrior(hM, dataParList = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="samplePrior_+3A_hm">hM</code></td>
<td>
<p>a fitted <code>Hmsc</code> model object</p>
</td></tr>
<tr><td><code id="samplePrior_+3A_dataparlist">dataParList</code></td>
<td>
<p>list of data parameters (see <code><a href="#topic+computeDataParameters">computeDataParameters</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list containing the Hmsc model parameters
</p>

<hr>
<h2 id='setPriors'>setPriors</h2><span id='topic+setPriors'></span>

<h3>Description</h3>

<p>Sets or resets priors to objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setPriors(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setPriors_+3A_...">...</code></td>
<td>
<p>Hmsc or HmscRandolLevel object and other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of same type as first input
</p>


<h3>See Also</h3>

<p>setPriors.Hmsc, setPriors.HmscRandomLevel
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set priors for random level so that there is minimum of 2 latent factors and maximum of 3
rL1 = HmscRandomLevel(units=TD$studyDesign$plot)
rL1 = setPriors(rL1, nfMax=3, nfMin=2)

# Set shrinkage parameters for priors of random level
rL1 = HmscRandomLevel(units=TD$studyDesign$plot)
rL1 = setPriors(rL1, a1=10, a2=10, b1=1, b2=1)

</code></pre>

<hr>
<h2 id='setPriors.Hmsc'>setPriors.Hmsc</h2><span id='topic+setPriors.Hmsc'></span>

<h3>Description</h3>

<p>Sets or resets priors to the <code>Hmsc</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Hmsc'
setPriors(
  hM,
  V0 = NULL,
  f0 = NULL,
  mGamma = NULL,
  UGamma = NULL,
  aSigma = NULL,
  bSigma = NULL,
  nuRRR = NULL,
  a1RRR = NULL,
  b1RRR = NULL,
  a2RRR = NULL,
  b2RRR = NULL,
  rhopw = NULL,
  setDefault = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setPriors.Hmsc_+3A_hm">hM</code></td>
<td>
<p>a fitted <code>Hmsc</code> model object</p>
</td></tr>
<tr><td><code id="setPriors.Hmsc_+3A_v0">V0</code></td>
<td>
<p>scale matrix in the Wishart prior distribution for the V matrix</p>
</td></tr>
<tr><td><code id="setPriors.Hmsc_+3A_f0">f0</code></td>
<td>
<p>number of degrees of freedom in the Wishart prior distribution for the V matrix</p>
</td></tr>
<tr><td><code id="setPriors.Hmsc_+3A_mgamma">mGamma</code></td>
<td>
<p>mean for the prior multivariate Gaussian distribution for Gamma parameters</p>
</td></tr>
<tr><td><code id="setPriors.Hmsc_+3A_ugamma">UGamma</code></td>
<td>
<p>covariance matrix for the prior multivariate Gaussian distribution for Gamma parameters</p>
</td></tr>
<tr><td><code id="setPriors.Hmsc_+3A_asigma">aSigma</code></td>
<td>
<p>shape parameter for the prior gamma distribution for the variance parameter, only for normal &amp; lognormal Poisson models</p>
</td></tr>
<tr><td><code id="setPriors.Hmsc_+3A_bsigma">bSigma</code></td>
<td>
<p>rate parameter for the prior gamma distribution for the variance parameter, only for normal &amp; lognormal Poisson models</p>
</td></tr>
<tr><td><code id="setPriors.Hmsc_+3A_nurrr">nuRRR</code>, <code id="setPriors.Hmsc_+3A_a1rrr">a1RRR</code>, <code id="setPriors.Hmsc_+3A_b1rrr">b1RRR</code>, <code id="setPriors.Hmsc_+3A_a2rrr">a2RRR</code>, <code id="setPriors.Hmsc_+3A_b2rrr">b2RRR</code></td>
<td>
<p>parameters of the multiplicative gamma process shrinking prior for reduced rank regression</p>
</td></tr>
<tr><td><code id="setPriors.Hmsc_+3A_rhopw">rhopw</code></td>
<td>
<p>discrete grid prior for phylogenetic signal, should be a matrix of 2 columns</p>
</td></tr>
<tr><td><code id="setPriors.Hmsc_+3A_setdefault">setDefault</code></td>
<td>
<p>logical indicating whether default priors should be used</p>
</td></tr>
<tr><td><code id="setPriors.Hmsc_+3A_...">...</code></td>
<td>
<p>other parameters passed to the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Modified <code>Hmsc</code> object
</p>

<hr>
<h2 id='setPriors.HmscRandomLevel'>setPriors.HmscRandomLevel</h2><span id='topic+setPriors.HmscRandomLevel'></span>

<h3>Description</h3>

<p>Sets or resets priors to the Hmsc object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HmscRandomLevel'
setPriors(
  rL,
  nu = NULL,
  a1 = NULL,
  a2 = NULL,
  b1 = NULL,
  b2 = NULL,
  alphapw = NULL,
  nfMax = NULL,
  nfMin = NULL,
  setDefault = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setPriors.HmscRandomLevel_+3A_rl">rL</code></td>
<td>
<p>a fitted <code>HmscRandomLevel</code> model object</p>
</td></tr>
<tr><td><code id="setPriors.HmscRandomLevel_+3A_nu">nu</code>, <code id="setPriors.HmscRandomLevel_+3A_a1">a1</code>, <code id="setPriors.HmscRandomLevel_+3A_b1">b1</code>, <code id="setPriors.HmscRandomLevel_+3A_a2">a2</code>, <code id="setPriors.HmscRandomLevel_+3A_b2">b2</code></td>
<td>
<p>parameters of the multiplicative gamma process shrinking prior</p>
</td></tr>
<tr><td><code id="setPriors.HmscRandomLevel_+3A_alphapw">alphapw</code></td>
<td>
<p>discrete grid prior for spatial scale parameter</p>
</td></tr>
<tr><td><code id="setPriors.HmscRandomLevel_+3A_nfmax">nfMax</code></td>
<td>
<p>maximum number of latent factors to be sampled</p>
</td></tr>
<tr><td><code id="setPriors.HmscRandomLevel_+3A_nfmin">nfMin</code></td>
<td>
<p>minimum number of latent factors to be sampled</p>
</td></tr>
<tr><td><code id="setPriors.HmscRandomLevel_+3A_setdefault">setDefault</code></td>
<td>
<p>logical indicating whether default priors should be used</p>
</td></tr>
<tr><td><code id="setPriors.HmscRandomLevel_+3A_...">...</code></td>
<td>
<p>other arguments (ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Modified HmscRandomLevel object
</p>

<hr>
<h2 id='TD'>Simulated data and a fitted Hmsc model for a small species community.</h2><span id='topic+TD'></span>

<h3>Description</h3>

<p>This dataset contains simulated occurence data for 4 species in 50 sampling units.
The data is based on a hierarchical study design consisting of 50 sampling units in 10 georeferenced plots.
Occurences of 4 species were simulated using one continuous environmental variable (x1) and spatial autocorrelation between the plots.
Response of species to the environment are related to one species trait which is fully phylogenetically structured.
This dataset is used for the examples and package testing.
The variables are as follows:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TD
</code></pre>


<h3>Format</h3>

<p>A list of 12 objects
</p>

<dl>
<dt>ns</dt><dd><p>Number of species in the dataset</p>
</dd>
<dt>units</dt><dd><p>Number of sampling units</p>
</dd>
<dt>plots</dt><dd><p>Number of plots</p>
</dd>
<dt>X</dt><dd><p>A 3 by 50 environmental matrix consisting of one continuous and one categorical variable. Also includes intercept column</p>
</dd>
<dt>phy</dt><dd><p>A list containing the simulated phylogenetic tree for 4 species</p>
</dd>
<dt>C</dt><dd><p>A 4 by 4 phylogenetic variance covariance matrix</p>
</dd>
<dt>Tr</dt><dd><p>A 4 by 3 trait matrix with one phylogenetically phylogenetically structured continuous trait, one categroical trait and an intercept</p>
</dd>
<dt>xycoords</dt><dd><p>simulated 2 dimensional coordinates</p>
</dd>
<dt>studyDesign</dt><dd><p>Sampling unit and plot IDs</p>
</dd>
<dt>Y</dt><dd><p>Simulated species occurences</p>
</dd>
<dt>m</dt><dd><p>A fitted Hmsc object with 100 posterior samples</p>
</dd>
</dl>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
