<!DOCTYPE html><html><head><title>Help for package sandbox</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sandbox}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_Population'><p>Add a Population to a Rule Book</p></a></li>
<li><a href='#add_Rule'><p>Add a Rule to a Rule Book</p></a></li>
<li><a href='#convert_units'><p>Convert between phi units and micrometers</p></a></li>
<li><a href='#get_RuleBook'><p>Get One of a Series of Predefined Rule Books for a Model Run.</p></a></li>
<li><a href='#make_Sample'><p>Create a Virtual Sample.</p></a></li>
<li><a href='#measure_SAR_OSL'><p>Measure an aliquot with the CW SAR OSL protocol</p></a></li>
<li><a href='#prepare_Aliquot'><p>Prepare Aliquots from Sample Dataset</p></a></li>
<li><a href='#prepare_Sieving'><p>Sieve a Sample</p></a></li>
<li><a href='#prepare_Subsample'><p>Prepare Subsamples from a Sample Dataset</p></a></li>
<li><a href='#sample'><p>Example Grain Size Data</p></a></li>
<li><a href='#sample_osl_aliquots'><p>Aliquots Prepared to Measured Virtually</p></a></li>
<li><a href='#sandbox-package'><p>Probabilistic Numerical Modelling of Sediment Properties</p>
<br />
</p>

<p><img src="../help/figures/logo_sandbox.png" width="50" alt="sandbox logo" /></p></a></li>
<li><a href='#set_Parameter'><p>Set Profile- and Grain-Specific Model Parameters.</p></a></li>
<li><a href='#set_Rule'><p>Set depth-dependent rule for model parameter.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Probabilistic Numerical Modelling of Sediment Properties</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-02-25</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Dietze <a href="https://orcid.org/0000-0001-6063-1726"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Sebastian Kreutzer
    <a href="https://orcid.org/0000-0002-0734-2199"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Dietze &lt;mdietze@gfz-potsdam.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A flexible framework for definition and application of time/depth-
    based rules for sets of parameters for single grains that can be used to 
    create artificial sediment profiles. Such profiles can be used for virtual 
    sample preparation and synthetic, for instance, luminescence measurements.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/coffeemuggler/sandbox/issues">https://github.com/coffeemuggler/sandbox/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, RLumModel (&ge; 0.2.9), parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>EMMAgeo (&ge; 0.9.7), Luminescence (&ge; 0.9.15), testthat (&ge;
3.0.2),</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-25 07:46:36 UTC; micha</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-25 08:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_Population'>Add a Population to a Rule Book</h2><span id='topic+add_Population'></span>

<h3>Description</h3>

<p>The function adds a further population element to all rules or a rule book.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_Population(book, populations = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_Population_+3A_book">book</code></td>
<td>
<p><a href="base.html#topic+character">character</a> value, name of the rule book to be modified.</p>
</td></tr>
<tr><td><code id="add_Population_+3A_populations">populations</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> value, number of additional populations
to create.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="base.html#topic+list">list</a> object with all rules for a model run.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze, GFZ Potsdam (Germany)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## create simple true age-depth-relationship
book_1 &lt;- get_RuleBook()

book_2 &lt;- add_Population(
 book = book_1,
 populations = 1)
 
</code></pre>

<hr>
<h2 id='add_Rule'>Add a Rule to a Rule Book</h2><span id='topic+add_Rule'></span>

<h3>Description</h3>

<p>The function adds a new rule to an existing rule book. The specified rule
will be appended to the rule book.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_Rule(book, name, group, type, populations = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_Rule_+3A_book">book</code></td>
<td>
<p><a href="base.html#topic+character">character</a> value, name of the rule book to be modified.</p>
</td></tr>
<tr><td><code id="add_Rule_+3A_name">name</code></td>
<td>
<p><a href="base.html#topic+character">character</a> value, name of the rule to be added.</p>
</td></tr>
<tr><td><code id="add_Rule_+3A_group">group</code></td>
<td>
<p><a href="base.html#topic+character">character</a> value, group to which the rule belongs. One
out of <code>"general"</code> (covering the sediment section properties) and
<code>"specific"</code> (relevant for a single grain).</p>
</td></tr>
<tr><td><code id="add_Rule_+3A_type">type</code></td>
<td>
<p><a href="base.html#topic+character">character</a> value, generic type of the rule. One out of
<code>"exact"</code> (defined by exact value, changing with depth),
<code>"normal"</code> (normal distribution, defined by mean and standard
deviation, changing with depth), <code>"uniform"</code> (defined by minimum and
maximum values, changing with depth) and <code>"gamma"</code> (gamma distribution,
defined by shape and scale parameter and constant offset, all changing
with depth)</p>
</td></tr>
<tr><td><code id="add_Rule_+3A_populations">populations</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> value, number of populations to create.
The number of populations to add should match the existing number of
populations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="base.html#topic+list">list</a> object with all rules for a model run.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze, GFZ Potsdam (Germany), Sebastian Kreutzer, Geography
&amp; Earth Sciences, Aberystwyth University (United Kingdom)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## create simple true age-depth-relationship
book_1 &lt;- get_RuleBook()

book_2 &lt;- add_Rule(
 book = book_1, 
 name = "extrarule", 
 group = "general", 
 type = "normal", 
 populations = 1)
                
</code></pre>

<hr>
<h2 id='convert_units'>Convert between phi units and micrometers</h2><span id='topic+convert_units'></span>

<h3>Description</h3>

<p>The function converts values from the phi-scale (Krumbein 1934, 1938) to
the micrometer-scale and vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_units(phi, mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_units_+3A_phi">phi</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> vector, grain-size class values
in phi to be converted</p>
</td></tr>
<tr><td><code id="convert_units_+3A_mu">mu</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> vector, grain-size class values
in micrometres to be converted</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">
\phi = -log2(D/D_{0})</code>
</p>

<p>with <code class="reqn">D</code> the diameter in µm and <code class="reqn">D_{0}</code> the reference diameter.
Herer 1000 µm.
</p>


<h3>Value</h3>

<p><a href="base.html#topic+numeric">numeric</a> vector, converted grain-size class values
</p>


<h3>Author(s)</h3>

<p>Michael Dietze, GFZ Potsdam (Germany)
</p>


<h3>References</h3>

<p>Krumbein, W.C., 1938. Size frequency distributions of sediments and the normal phi curve.
Journal of Sedimentary Research 8, 84–90. doi: <a href="https://doi.org/10.1306/D4269008-2B26-11D7-8648000102C1865D">10.1306/D4269008-2B26-11D7-8648000102C1865D</a>
</p>
<p>Krumbein, W.C., 1934. Size frequency distributions of sediments.
Journal of Sedimentary Research 4, 65–77. doi: <a href="https://doi.org/10.1306/D4268EB9-2B26-11D7-8648000102C1865D">10.1306/D4268EB9-2B26-11D7-8648000102C1865D</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load example data set
## generate phi-values
phi &lt;- -2:5

## convert and show phi to mu
mu  &lt;- convert_units(phi = phi)
mu

## convert and show mu to phi
convert_units(mu = mu)

</code></pre>

<hr>
<h2 id='get_RuleBook'>Get One of a Series of Predefined Rule Books for a Model Run.</h2><span id='topic+get_RuleBook'></span>

<h3>Description</h3>

<p>The function returns a pre-built model rule book, i.e., a combination of
model parameters and rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_RuleBook(book = "empty", osl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_RuleBook_+3A_book">book</code></td>
<td>
<p><a href="base.html#topic+character">character</a> value, name of the rule book to be generated.
One out of <code>"empty"</code>, default is <code>"empty"</code>.</p>
</td></tr>
<tr><td><code id="get_RuleBook_+3A_osl">osl</code></td>
<td>
<p><a href="base.html#topic+character">character</a> value, optional keyword for an OSL (optical
stimulated luminescence) model of choice. Must be one of the available
models from the R package RLumModel-package. See details for full list of
available models.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is possible to generate OSL-tailored rule books. For this, the
argument <code>osl</code> must be provided with a keyword defining one of the
OSL models from the R package <code>'RLumModel'</code>: <code>"Bailey2001"</code>,
<code>"Bailey2004"</code>, <code>"Pagonis2008"</code>, <code>"Pagonis2007"</code>,
<code>"Bailey2002"</code> and <code>"Friedrich2017"</code>. The model parameters will
be appended to the rule book entries and defined by mean and standard
deviation.
</p>


<h3>Value</h3>

<p>A <a href="base.html#topic+list">list</a> object with all rules for a model run.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze, GFZ Potsdam (Germany), Sebastian Kreutzer, Geography &amp; Earth
Sciences, Aberystwyth University (United Kingdom)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## create simple true age-depth-relationship
book_flat &lt;- get_RuleBook(book = "empty")

</code></pre>

<hr>
<h2 id='make_Sample'>Create a Virtual Sample.</h2><span id='topic+make_Sample'></span>

<h3>Description</h3>

<p>The function generates many virtual sediment grains based on the specified
sample geometry and depth, using the information from a rule book.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_Sample(
  book,
  depth,
  geometry = "cuboid",
  radius,
  height,
  width,
  length,
  slice = TRUE,
  force = FALSE,
  n_cores = max(1, parallel::detectCores() - 2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_Sample_+3A_book">book</code></td>
<td>
<p><a href="base.html#topic+list">list</a> object, initially produced by <a href="#topic+get_RuleBook">get_RuleBook</a></p>
</td></tr>
<tr><td><code id="make_Sample_+3A_depth">depth</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> scalar, depth of the sample centre (m).</p>
</td></tr>
<tr><td><code id="make_Sample_+3A_geometry">geometry</code></td>
<td>
<p><a href="base.html#topic+character">character</a> scalar, keyword defining the geometry of
the sample. One out of <code>"cuboid"</code> and <code>"cylinder"</code>,
default is <code>"cuboid"</code>.</p>
</td></tr>
<tr><td><code id="make_Sample_+3A_radius">radius</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> scalar, radius of the cylinder (m).</p>
</td></tr>
<tr><td><code id="make_Sample_+3A_height">height</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> scalar, height of the cuboid (m).</p>
</td></tr>
<tr><td><code id="make_Sample_+3A_width">width</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> scalar, width of the cuboid (m).</p>
</td></tr>
<tr><td><code id="make_Sample_+3A_length">length</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> scalar, length of the cuboid or cylinder (m).</p>
</td></tr>
<tr><td><code id="make_Sample_+3A_slice">slice</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> scalar, option to sample in repeated slices of
10^6 grains until the required sample size is reached. Useful to avoid
memory issues for large numbers of grains per sample volume.</p>
</td></tr>
<tr><td><code id="make_Sample_+3A_force">force</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> scalar, option to override the default
maximum number of 10^7 grains per sample, set to avoid memory problems
of the computer.</p>
</td></tr>
<tr><td><code id="make_Sample_+3A_n_cores">n_cores</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> (<em>optional</em>) set the number of cores used for the parallel
processing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="base.html#topic+list">list</a> object.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze, GFZ Potsdam (Germany)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(12234)
sample_01 &lt;- make_Sample(
  book = get_RuleBook(), 
  depth = 1, 
  geometry = "cuboid",
  n_cores = 1,
  height = 0.001,
  width = 0.001, 
  length = 0.001)

</code></pre>

<hr>
<h2 id='measure_SAR_OSL'>Measure an aliquot with the CW SAR OSL protocol</h2><span id='topic+measure_SAR_OSL'></span>

<h3>Description</h3>

<p>The function models the time-dependent photon counts of an aliquot
according to the specified CW SAR OSL (continuous wave, single aliquot
regenerative dose protocol for optically stimulated luminescence) sequence
and parameters. The modelling is done for each component and photon count
curves are summed to return an <a href="Luminescence.html#topic+RLum.Analysis-class">Luminescence::RLum.Analysis</a> object as equivalent of
importing a real measurement data set to the R-package <code>Luminescence-package</code>.
</p>
<p>The function uses the package RLumModel-package to perform the simulation of the
photon count curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measure_SAR_OSL(aliquot, sequence, dose_rate = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="measure_SAR_OSL_+3A_aliquot">aliquot</code></td>
<td>
<p><a href="base.html#topic+data.frame">data.frame</a> or a <a href="base.html#topic+list">list</a> of it, a set of grains that are assigned to an
aliquot (sample subset used for measurement), i.e., the result of
<a href="#topic+prepare_Aliquot">prepare_Aliquot</a>.</p>
</td></tr>
<tr><td><code id="measure_SAR_OSL_+3A_sequence">sequence</code></td>
<td>
<p><a href="base.html#topic+list">list</a>, definition of the SAR protocol.</p>
</td></tr>
<tr><td><code id="measure_SAR_OSL_+3A_dose_rate">dose_rate</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> value, Dose rate of the luminescence
reader, in Gy/s.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="Luminescence.html#topic+RLum.Analysis-class">Luminescence::RLum.Analysis</a> object. Equivalent of the import result for
a real world measurement file. This object can be evaluated by functions
of the package <code>Luminescence-package</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze, GFZ Potsdam (Germany),
Sebastian Kreutzer, Geography &amp; Earth Sciences, Aberystwyth University (United Kingdom)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## load example data set
data(sample_osl_aliquots, envir = environment())

sequence &lt;- list(
  RegDose = c(0, 1, 2, 5, 10, 0, 1),
  TestDose = 2,
  PH = 220,
  CH = 200,
  OSL_temp = 125,
  OSL_duration = 70)

## reduce number of 
## grains to two
sample_osl_aliquots$aliquot_1 &lt;- 
sample_osl_aliquots$aliquot_1[1:2,]

## or measure all aliquots in a row
sar_all &lt;- measure_SAR_OSL(
 aliquot = sample_osl_aliquots,
 sequence = sequence,
 dose_rate = 0.1)
 
 
## End(Not run)

</code></pre>

<hr>
<h2 id='prepare_Aliquot'>Prepare Aliquots from Sample Dataset</h2><span id='topic+prepare_Aliquot'></span>

<h3>Description</h3>

<p>The function consecutively fills aliquots (i.e., subsamples distributed on
round carrier discs) with grains from an input sample. Remaining grains that
are not enough to fill a further aliquot are discarded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_Aliquot(sample, diameter, density = 0.65)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_Aliquot_+3A_sample">sample</code></td>
<td>
<p><a href="base.html#topic+data.frame">data.frame</a>, sample object to be distributed to
aliquots.</p>
</td></tr>
<tr><td><code id="prepare_Aliquot_+3A_diameter">diameter</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> value, diameter of the aliquot sample
carriers in mm.</p>
</td></tr>
<tr><td><code id="prepare_Aliquot_+3A_density">density</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> value, packing density of the grains on
the sample carrier. Default is <code>0.65</code>. The packing density is unitless.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+list">list</a> of <a href="base.html#topic+data.frame">data.frame</a> objects with grains organised as aliquots, i.e. list
elements.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze, GFZ Potsdam (Germany),
Sebastian Kreutzer, Geography &amp; Earth Sciences, Aberystwyth University (United Kingdom)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load example data set
data(sample, envir = environment())

A &lt;- prepare_Aliquot(
 sample = sample, 
 diameter = 0.1)

B &lt;- prepare_Aliquot(
 sample = sample, 
 diameter = 1, 
 density = 0.6)
 
</code></pre>

<hr>
<h2 id='prepare_Sieving'>Sieve a Sample</h2><span id='topic+prepare_Sieving'></span>

<h3>Description</h3>

<p>The function removes grains that are not within the provided sieve
interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_Sieving(sample, interval)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_Sieving_+3A_sample">sample</code></td>
<td>
<p><a href="base.html#topic+data.frame">data.frame</a> sample object to be sieved.</p>
</td></tr>
<tr><td><code id="prepare_Sieving_+3A_interval">interval</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> vector, sieve interval, in phi units.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+data.frame">data.frame</a> with grains that are within the sieve interval.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze, GFZ Potsdam (Germany)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load example data set
data(sample, envir = environment())

## sieve sample (in phi units)
sample_sieved &lt;- prepare_Sieving(
  sample = sample,
  interval = c(5, 6))
                                 
## plot results
plot(density(
  x = sample$grainsize, 
  from = -1, 
  to = 11))
lines(density(
  x = sample_sieved$grainsize, 
  from = -1, 
  to = 11), 
  col = 2)

</code></pre>

<hr>
<h2 id='prepare_Subsample'>Prepare Subsamples from a Sample Dataset</h2><span id='topic+prepare_Subsample'></span>

<h3>Description</h3>

<p>The function splits the master sample in a set of subsamples. The
step can be done by creating equally large subsamples in terms of
contained grains (parameter <code>number</code>), by volume (parameter
<code>volume</code>) or by weight (parameter <code>weight</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_Subsample(sample, number, volume, weight)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_Subsample_+3A_sample">sample</code></td>
<td>
<p><a href="base.html#topic+data.frame">data.frame</a>, sample object to be distributed to
aliquots.</p>
</td></tr>
<tr><td><code id="prepare_Subsample_+3A_number">number</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> value, number of evenly large subsamples to
be created</p>
</td></tr>
<tr><td><code id="prepare_Subsample_+3A_volume">volume</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> value, volume of subsamples. Remainder
of the master sample that is too small for the last subsample is
removed. Volume must be given in m^3 and takes packing density of
the sample into account.</p>
</td></tr>
<tr><td><code id="prepare_Subsample_+3A_weight">weight</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> value, weight of the subsamples. Remainder
of the master sample that is too small for the last subsample is
removed. Weight is calculated based on density of each grain. Weight
must be given in kg.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+list">list</a> object with grains organised as aliquots, i.e. list
elements.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze, GFZ Postdam (Germany)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load example data set
data(sample, envir = environment())

## create 10 subsamples
prepare_Subsample(sample, 10) 

</code></pre>

<hr>
<h2 id='sample'>Example Grain Size Data</h2><span id='topic+sample'></span>

<h3>Description</h3>

<p>Example data set of a virtual loess-like sample.
</p>


<h3>Format</h3>

<p>The format is: 'data.frame':	1000 obs. of  12 variables:
$ ID               : int  33107 33108 33109 33110 33111 33112 ...
$ depth            : num  5 5 5 5 5 ...
$ population       : num  3 1 3 2 1 3 1 3 3 3 ...
$ age              : num  25711 25710 25712 25709 25710 ...
$ dose_rate        : num  7.163 -1.083 -0.929 3.541 5.732 ...
$ water_content    : num  13.29 10.99 3.65 8.98 3.29 ...
$ population       : num  0.3 0.586 0.3 0.114 0.586 ...
$ grainsize        : num  4.01 6.22 5.16 5.47 5.57 ...
$ density          : num  1.92 1.91 1.9 1.88 1.9 ...
$ packing          : num  0.708 0.702 0.698 0.702 0.688 ...
$ photon_equivalent: num  1.017 0.993 1.005 1 0.995 ...
$ predose          : num  2020 3106 1983 191 2387 ...
</p>


<h3>Details</h3>

<p>The sample was created using the rule book book_1, a depth of 5 m and
a cuboid sample geometry with 2 mm edge length.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(sample, envir = environment())

## plot grain-size distribution
plot(density(sample$grainsize))

</code></pre>

<hr>
<h2 id='sample_osl_aliquots'>Aliquots Prepared to Measured Virtually</h2><span id='topic+sample_osl_aliquots'></span>

<h3>Description</h3>

<p>Example data of virtually prepared aliquots 
ready to be measured
</p>


<h3>Format</h3>

<p>The format is: 'data.frame':	2 obs. of  65 variables:
..$ grains      : num [1:2] 1 2
..$ d_sample    : num [1:2] 2 2
..$ population  : num [1:2] 1 1
..$ age         : num [1:2] 1574 1578
..$ population  : num [1:2] 2 2
..$ grainsize   : num [1:2] 2.52 2.48
..$ packing     : num [1:2] 1.32 4.82
..$ density     : num [1:2] 3.24 2.13
..$ osl_doserate: num [1:2] 0.00875 0.0046
..$ osl_N1      : num [1:2] 1.5e+07 1.5e+07
..$ osl_N2      : num [1:2] 1e+07 1e+07
..$ osl_N3      : num [1:2] 1e+09 1e+09
..$ osl_N4      : num [1:2] 2.5e+08 2.5e+08
..$ osl_N5      : num [1:2] 5e+10 5e+10
..$ osl_N6      : num [1:2] 3e+08 3e+08
..$ osl_N7      : num [1:2] 1e+10 1e+10
..$ osl_N8      : num [1:2] 5e+09 5e+09
..$ osl_N9      : num [1:2] 1e+11 1e+11
..$ osl_E1      : num [1:2] 0.97 0.97
..$ osl_E2      : num [1:2] 1.55 1.55
..$ osl_E3      : num [1:2] 1.7 1.7
..$ osl_E4      : num [1:2] 1.72 1.72
..$ osl_E5      : num [1:2] 2 2
..$ osl_E6      : num [1:2] 1.43 1.43
..$ osl_E7      : num [1:2] 1.75 1.75
..$ osl_E8      : num [1:2] 5 5
..$ osl_E9      : num [1:2] 5 5
..$ osl_s1      : num [1:2] 5e+12 5e+12
..$ osl_s2      : num [1:2] 5e+14 5e+14
..$ osl_s3      : num [1:2] 5e+13 5e+13
..$ osl_s4      : num [1:2] 5e+14 5e+14
..$ osl_s5      : num [1:2] 1e+10 1e+10
..$ osl_s6      : num [1:2] 5e+13 5e+13
..$ osl_s7      : num [1:2] 5e+14 5e+14
..$ osl_s8      : num [1:2] 1e+13 1e+13
..$ osl_s9      : num [1:2] 1e+13 1e+13
..$ osl_A1      : num [1:2] 1e-08 1e-08
..$ osl_A2      : num [1:2] 1e-08 1e-08
..$ osl_A3      : num [1:2] 1e-09 1e-09
..$ osl_A4      : num [1:2] 5e-10 5e-10
..$ osl_A5      : num [1:2] 1e-10 1e-10
..$ osl_A6      : num [1:2] 5e-07 5e-07
..$ osl_A7      : num [1:2] 1e-09 1e-09
..$ osl_A8      : num [1:2] 1e-10 1e-10
..$ osl_A9      : num [1:2] 1e-09 1e-09
..$ osl_B1      : num [1:2] 0 0
..$ osl_B2      : num [1:2] 0 0
..$ osl_B3      : num [1:2] 0 0
..$ osl_B4      : num [1:2] 0 0
..$ osl_B5      : num [1:2] 0 0
..$ osl_B6      : num [1:2] 5e-09 5e-09
..$ osl_B7      : num [1:2] 5e-10 5e-10
..$ osl_B8      : num [1:2] 1e-10 1e-10
..$ osl_B9      : num [1:2] 1e-10 1e-10
..$ osl_Th1     : num [1:2] 0.75 0.75
..$ osl_Th2     : num [1:2] 0 0
..$ osl_Th3     : num [1:2] 6 6
..$ osl_Th4     : num [1:2] 4.5 4.5
..$ osl_Th5     : num [1:2] 0 0
..$ osl_E_th1   : num [1:2] 0.1 0.1
..$ osl_E_th2   : num [1:2] 0 0
..$ osl_E_th3   : num [1:2] 0.1 0.1
..$ osl_E_th4   : num [1:2] 0.13 0.13
..$ osl_E_th5   : num [1:2] 0 0
..$ osl_R       : num [1:2] 5e+07 5e+07
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(sample_osl_aliquots, envir = environment())

## plot grain-size distribution
plot(density(sample_osl_aliquots[[1]]$age))

</code></pre>

<hr>
<h2 id='sandbox-package'>Probabilistic Numerical Modelling of Sediment Properties
<br />

<img src="../help/figures/logo_sandbox.png" width="50" alt="sandbox logo" />
</h2><span id='topic+sandbox-package'></span><span id='topic+sandbox'></span>

<h3>Description</h3>

<p>Flexible framework for definition and application of time/depth-based
rules for sets of parameters for single grains that can be used to
create synthetic samples, used for synthetic preparation and synthetic
measurements.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze (GFZ Potsdam, Germany),
Sebastian Kreutzer (Geography &amp; Earth Sciences, Aberystwyth University, United Kingdom)
</p>

<hr>
<h2 id='set_Parameter'>Set Profile- and Grain-Specific Model Parameters.</h2><span id='topic+set_Parameter'></span>

<h3>Description</h3>

<p>The function defines one model parameter used to generate a set of
virtual grains. A parameter is defined in a probabilistic way, as parametric
distribution function. Each parameter of the distribution function can be
changed through time using <a href="#topic+set_Rule">set_Rule</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_Parameter(book, parameter, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_Parameter_+3A_book">book</code></td>
<td>
<p><a href="base.html#topic+list">list</a> object, rule book to be edited.</p>
</td></tr>
<tr><td><code id="set_Parameter_+3A_parameter">parameter</code></td>
<td>
<p><a href="base.html#topic+character">character</a> scalar, keyword defining the parameter to
be defined. Some
parameters can be described by more than one function, see details.</p>
</td></tr>
<tr><td><code id="set_Parameter_+3A_type">type</code></td>
<td>
<p><a href="base.html#topic+character">character</a> scalar, keyword defining the distribution
function used to describe the parameter. See details for available
keywords, default is <code>"exact"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following parameter types are available:
</p>

<ul>
<li> <p><code>exact</code>: parameter does not vary at all. No additional
parameters needed except for vector <code>value</code>, defining the
constant values for corresponding depths.
</p>
</li>
<li> <p><code>uniform</code>: parameter varies following a uniform distribution.
The following additional parameter vectors are required: <code>min</code>
(minimum) and <code>max</code> (maximum)
</p>
</li>
<li> <p><code>normal</code>: parameter varies following a normal distribution,
which is defined by mean and standard deviation
</p>
</li>
<li> <p><code>gamma</code>: parameter varies following a gamma distribution,
defined by shape parameter, scale parameter)
and offset (defining constant offset of values)
</p>
</li></ul>



<h3>Value</h3>

<p>A <a href="base.html#topic+list">list</a> object.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze, GFZ Potsdam (Germany)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## get empty rule book
book_1 &lt;- get_RuleBook(book = "empty")

## set density from default "normal" to "exact"
book_2 &lt;- set_Parameter(book = book_1,
                        parameter = "density",
                        type = "exact")

book_1$density$density_1$type
book_2$density$density_1$type

</code></pre>

<hr>
<h2 id='set_Rule'>Set depth-dependent rule for model parameter.</h2><span id='topic+set_Rule'></span>

<h3>Description</h3>

<p>The function defines how the specified model parameter varies with depth.
The transfer function uses different interpolation functions to create a
continuous representation of a parameter value with depth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_Rule(book, parameter, value, depth, type = "spline")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_Rule_+3A_book">book</code></td>
<td>
<p><a href="base.html#topic+list">list</a> object, rule book to be edited.</p>
</td></tr>
<tr><td><code id="set_Rule_+3A_parameter">parameter</code></td>
<td>
<p><a href="base.html#topic+character">character</a> scalar, parameter name to be edited.
Can also be the keyword for an OSL model. See details.</p>
</td></tr>
<tr><td><code id="set_Rule_+3A_value">value</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+list">list</a>, specifying the
parameter values at the corresponding depth points. If a parameter
is defined by more than one argument (e.g., mean and standard
deviation), all the relevant arguments must be defined for each
corresponding depth as separate list element.</p>
</td></tr>
<tr><td><code id="set_Rule_+3A_depth">depth</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+list">list</a>, specifying the depths used for the
interpolation. All elements must be of the same lengths as the
corresponding data in <code>value</code>.</p>
</td></tr>
<tr><td><code id="set_Rule_+3A_type">type</code></td>
<td>
<p><a href="base.html#topic+character">character</a> scalar, interpolation method. One out of
<code>spline</code>, default is <code>spline</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To assign standard OSL model parameters, one of the available keywords of
the R package RLumModel-package can be used. The function will then set
all rules of the rule book with the standard values associated with these
models, and setting the standard deviation to zero. The keyword can be
one out of <code>"Bailey2001"</code>, <code>"Bailey2004"</code>, <code>"Pagonis2008"</code>,
<code>"Pagonis2007"</code>, <code>"Bailey2002"</code> and <code>"Friedrich2017"</code>.
This will fill the rule book with the standard parameters independent of
depth. Note that a dose rate (parameter name <code>osl_doserate</code>) needs to
be set separately!
</p>


<h3>Value</h3>

<p>A <a href="base.html#topic+list">list</a> object with all created formula objects.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze, GFZ Potsdam (Germany), Sebastian Kreutzer, Geography
&amp; Earth Sciences, Aberystwyth University (United Kingdom)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## create empty rule book
book_01 &lt;- get_RuleBook()

## assign rule definitions to lists
depth &lt;- list(c(0, 10))
age &lt;- list(c(0, 1000))

## add age definition
book_01 &lt;- set_Rule(
 book = book_01, 
 parameter = "age", 
 value = age, 
 depth = depth)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
