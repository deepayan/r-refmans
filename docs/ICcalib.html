<!DOCTYPE html><html lang="en"><head><title>Help for package ICcalib</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ICcalib}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CalcCoxCalibP'><p>Calculating the probabilities of positive binary exposure status at a given time point using a proportional hazards calibration model</p></a></li>
<li><a href='#CalcCoxCalibRSIntsP'><p>Calculating the probabilities of positive binary exposure status at a given time point using proportional hazards grouped risk-set</p>
calibration models</a></li>
<li><a href='#CalcNpmleCalibP'><p>Calculating the probabilities of positive binary exposure status at a given time point using a nonparametric calibration model</p></a></li>
<li><a href='#CalcNpmleRSP'><p>Calculating the probabilities of positive binary exposure status at a given time point using a nonparametric risk-set calibration models</p></a></li>
<li><a href='#CalcVarParam'><p>Variance estimation for the main proportional hazards model</p></a></li>
<li><a href='#CalcWeibullCalibP'><p>Calculating the probabilities of positive binary exposure status at a given time point using a Weibull calibration model</p></a></li>
<li><a href='#CalcWeibullRSP'><p>Calculating the probabilities of positive binary exposure status at a given time point using risk-set Weibull calibration models</p></a></li>
<li><a href='#FitCalibCox'><p>Fitting Proportional Hazards Calibration Models with Covariates</p></a></li>
<li><a href='#FitCalibCoxRS'><p>Fitting Proportional Hazards Risk-Set Calibration Models with Covariates</p></a></li>
<li><a href='#FitCalibNpmle'><p>Fitting Nonparametric Calibration Models</p></a></li>
<li><a href='#FitCalibWeibull'><p>Fitting Weibull Calibration Models</p></a></li>
<li><a href='#FitCalibWeibullRS'><p>Fitting Weibull Risk-Set Calibration Models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Cox Model with Interval-Censored Starting Time of a Covariate</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-07-23</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Nevo</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Nevo &lt;danielnevo@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Calibration and risk-set calibration methods for fitting Cox proportional hazard model when a binary covariate is measured intermittently. Methods include functions to fit calibration models from interval-censored data and modified partial likelihood for the proportional hazard model, Nevo et al. (2018+) &lt;<a href="https://doi.org/10.48550/arXiv.1801.01529">doi:10.48550/arXiv.1801.01529</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.5), survival, fitdistrplus, icenReg, numDeriv,
ICsurv, msm, MASS</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-07-31 19:07:26 UTC; User</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-08-01 04:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='CalcCoxCalibP'>Calculating the probabilities of positive binary exposure status at a given time point using a proportional hazards calibration model</h2><span id='topic+CalcCoxCalibP'></span>

<h3>Description</h3>

<p>For a given time point, calculate the probability of positive exposure value  for multiple observations (participants). 
The function uses the results of a proportional hazards calibration model fit, and given covariates and collected data on the history 
of the binary exposure for each participant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcCoxCalibP(w, w.res, point, fit.cox, hz.times, Q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalcCoxCalibP_+3A_w">w</code></td>
<td>
<p>A matrix of time points when measurements on the binary covariate were obtained.</p>
</td></tr>
<tr><td><code id="CalcCoxCalibP_+3A_w.res">w.res</code></td>
<td>
<p>A matrix of measurement results of the binary covariate. Each measurement corresponds to the time points in <code>w</code></p>
</td></tr>
<tr><td><code id="CalcCoxCalibP_+3A_point">point</code></td>
<td>
<p>The time point at which the probabilities are estimated</p>
</td></tr>
<tr><td><code id="CalcCoxCalibP_+3A_fit.cox">fit.cox</code></td>
<td>
<p>The result of <code>icenReg::ic_sp</code> on the interval-censored data</p>
</td></tr>
<tr><td><code id="CalcCoxCalibP_+3A_hz.times">hz.times</code></td>
<td>
<p>Times used for calculating the baseline hazard function from PH calibration model</p>
</td></tr>
<tr><td><code id="CalcCoxCalibP_+3A_q">Q</code></td>
<td>
<p>Matrix of covariates for the PH calibration model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of estimated probabilities of positive exposure status at time <code>point</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.data &lt;- ICcalib:::SimCoxIntervalCensCox(n.sample = 200, lambda = 0.1, 
                                            alpha = 0.25, beta0 = 0, 
                                            gamma.q = c(log(0.75), log(2.5)), 
                                            gamma.z = log(1.5), mu = 0.2, 
                                            n.points = 2)
# The baseline hazard for the calibration model is calculated in observation times
cox.hz.times &lt;- sort(unique(sim.data$obs.tm)) 
# Fit proprtional hazards calibration model
fit.cox &lt;- FitCalibCox(w = sim.data$w, w.res = sim.data$w.res, Q = sim.data$Q, 
                       hz.times = cox.hz.times, n.int = 5, order = 2)
# Calculate the conditional probabilities of binary covariate=1 at time one
probs &lt;- CalcCoxCalibP(w = sim.data$w, w.res = sim.data$w.res, point = 1,
                       Q = sim.data$Q, fit.cox = fit.cox, hz.times = cox.hz.times)
summary(probs)
</code></pre>

<hr>
<h2 id='CalcCoxCalibRSIntsP'>Calculating the probabilities of positive binary exposure status at a given time point using proportional hazards grouped risk-set
calibration models</h2><span id='topic+CalcCoxCalibRSIntsP'></span>

<h3>Description</h3>

<p>For a given time point, calculate the probability of positive exposure value  for multiple observations (participants). 
The function uses the results of proportional hazards grouped risk-set calibration model fit, and given covariates and collected data on the history 
of the binary exposure for each participant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcCoxCalibRSIntsP(w, w.res, point, fit.cox.rs.ints, hz.times, Q, pts.for.ints)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalcCoxCalibRSIntsP_+3A_w">w</code></td>
<td>
<p>A matrix of time points when measurements on the binary covariate were obtained.</p>
</td></tr>
<tr><td><code id="CalcCoxCalibRSIntsP_+3A_w.res">w.res</code></td>
<td>
<p>A matrix of measurement results of the binary covariate. Each measurement corresponds to the time points in <code>w</code></p>
</td></tr>
<tr><td><code id="CalcCoxCalibRSIntsP_+3A_point">point</code></td>
<td>
<p>The time point at which the probabilities are estimated</p>
</td></tr>
<tr><td><code id="CalcCoxCalibRSIntsP_+3A_fit.cox.rs.ints">fit.cox.rs.ints</code></td>
<td>
<p>The result of <code>FitCalibCoxRSInts</code> on the interval-censored data</p>
</td></tr>
<tr><td><code id="CalcCoxCalibRSIntsP_+3A_hz.times">hz.times</code></td>
<td>
<p>Times used for calculating the baseline hazard function from PH calibration model</p>
</td></tr>
<tr><td><code id="CalcCoxCalibRSIntsP_+3A_q">Q</code></td>
<td>
<p>Matrix of covariates for the PH calibration model</p>
</td></tr>
<tr><td><code id="CalcCoxCalibRSIntsP_+3A_pts.for.ints">pts.for.ints</code></td>
<td>
<p>Points defining the intervals for grouping risk-sets (first one has to be zero). Should be sorted from zero up</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of estimated probabilities of positive exposure status at time <code>point</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(17)
sim.data &lt;- ICcalib:::SimCoxIntervalCensCox(n.sample = 100, lambda = 0.1, 
                                            alpha = 0.25, beta0 = 0, 
                                            gamma.q = c(log(0.75), log(2.5)), 
                                            gamma.z = log(1.5), mu = 0.2, 
                                            n.points = 2)
# The baseline hazard for the calibration model is calculated in observation times
cox.hz.times &lt;- sort(unique(sim.data$obs.tm)) 
# Fit proprtional hazards calibration model
fit.cox.rs.ints &lt;- FitCalibCoxRSInts(w = sim.data$w, w.res = sim.data$w.res, 
                                     Q = sim.data$Q, hz.times = cox.hz.times, 
                                     n.int = 5, order = 2, pts.for.ints = seq(0,4,1), 
                                     tm = sim.data$obs.tm, event = sim.data$delta)
# Calculate the conditional probabilities of binary covariate=1 at time one
probs &lt;- CalcCoxCalibRSIntsP(w = sim.data$w, w.res = sim.data$w.res, point = 1,
                             fit.cox.rs.ints = fit.cox.rs.ints,
                             pts.for.ints = seq(0,4,1), Q = sim.data$Q, 
                             hz.times = cox.hz.times)
summary(probs)
</code></pre>

<hr>
<h2 id='CalcNpmleCalibP'>Calculating the probabilities of positive binary exposure status at a given time point using a nonparametric calibration model</h2><span id='topic+CalcNpmleCalibP'></span>

<h3>Description</h3>

<p>For a given time point, calculate the probability of positive exposure value  for multiple observations (participants). 
The function uses the results of a nonparametric calibration model fit, and given collected data on the history 
of the binary exposure for each participant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcNpmleCalibP(w, w.res, point, fit.npmle)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalcNpmleCalibP_+3A_w">w</code></td>
<td>
<p>A matrix of time points when measurements on the binary covariate were obtained.</p>
</td></tr>
<tr><td><code id="CalcNpmleCalibP_+3A_w.res">w.res</code></td>
<td>
<p>A matrix of measurement results of the binary covariate. Each measurement corresponds to the time points in <code>w</code></p>
</td></tr>
<tr><td><code id="CalcNpmleCalibP_+3A_point">point</code></td>
<td>
<p>The time point at which the probabilities are estimated.</p>
</td></tr>
<tr><td><code id="CalcNpmleCalibP_+3A_fit.npmle">fit.npmle</code></td>
<td>
<p>The result of <code>icenReg::ic_np</code> on the interval-censored data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of estimated probabilities of positive exposure status at time <code>point</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.data &lt;- ICcalib:::SimCoxIntervalCensSingle(n.sample = 200, lambda = 0.1, 
                                               alpha = 0.25, beta0 = log(0.5), 
                                               mu = 0.2, n.points = 2, 
                                               weib.shape = 1, weib.scale = 2)
# Fit nonparametric calibration model
fit.npmle &lt;- FitCalibNpmle(w = sim.data$w, w.res = sim.data$w.res)
# Calculate the conditional probabilities of binary covariate=1 at time one
probs &lt;- CalcNpmleCalibP(w = sim.data$w, w.res = sim.data$w.res, 
                         point = 1, fit.npmle = fit.npmle)
summary(probs)
</code></pre>

<hr>
<h2 id='CalcNpmleRSP'>Calculating the probabilities of positive binary exposure status at a given time point using a nonparametric risk-set calibration models</h2><span id='topic+CalcNpmleRSP'></span>

<h3>Description</h3>

<p>For a given time point, calculate the probability of positive exposure value  for multiple observations (participants). 
The function first fits the nonparametric risk-set calibration models at each main event time point and then calculates the probabilities
of positive binary exposure status.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcNpmleRSP(w, w.res, point, obs.tm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalcNpmleRSP_+3A_w">w</code></td>
<td>
<p>A matrix of time points when measurements on the binary covariate were obtained.</p>
</td></tr>
<tr><td><code id="CalcNpmleRSP_+3A_w.res">w.res</code></td>
<td>
<p>A matrix of measurement results of the binary covariate. Each measurement corresponds to the time points in <code>w</code></p>
</td></tr>
<tr><td><code id="CalcNpmleRSP_+3A_point">point</code></td>
<td>
<p>The time point at which the probabilities are estimated</p>
</td></tr>
<tr><td><code id="CalcNpmleRSP_+3A_obs.tm">obs.tm</code></td>
<td>
<p>Vector of observed main event time or censoring time</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the NPMLE at each main event time point and then provides the estimated probabilities for positive 
exposure status at time <code>point</code>.
</p>


<h3>Value</h3>

<p>A vector of estimated probabilities of positive exposure status at time <code>point</code>.
</p>


<h3>See Also</h3>

<p><code><a href="icenReg.html#topic+ic_np">ic_np</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data set
sim.data &lt;- ICcalib:::SimCoxIntervalCensSingle(n.sample = 200, lambda = 0.1, 
                                               alpha = 0.25, beta0 = log(0.5), 
                                               mu = 0.2, n.points = 2, 
                                               weib.shape = 1, weib.scale = 2)
# Calculate the conditional probabilities of binary covariate=1 at time one
# Unlike CalcNpmle, CalcNpmleRSP includes the calibration model fitting
probs &lt;- CalcNpmleRSP(w = sim.data$w, w.res = sim.data$w.res, point = 1, 
                      obs.tm = sim.data$obs.tm)
summary(probs)
</code></pre>

<hr>
<h2 id='CalcVarParam'>Variance estimation for the main proportional hazards model</h2><span id='topic+CalcVarParam'></span><span id='topic+CalcVarParamRSInts'></span><span id='topic+CalcVarThetaWeib'></span><span id='topic+CalcVarThetaWeibRS'></span><span id='topic+CalcVarNpmle'></span><span id='topic+CalcVarNpmleRS'></span>

<h3>Description</h3>

<p>Estimation of the covariance matrix for the parameters of the main proportional hazards model. 
This includes the variance of the binary exposure estimate and the other covariates, if included in the model. 
Each function correspond to a different calibration (or risk-set calibration model).
</p>
<p>For nonparametric calibration, bootstrap calculations of the variance and confidence interval for the for the log hazard-ratio of the binary exposure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcVarParam(theta, tm, event, Z, Q, ps, ps.deriv, w, w.res, fit.cox)

CalcVarParamRSInts(theta, tm, event, Z, Q, ps, ps.deriv, w, w.res,
  fit.cox.rs.ints, pts.for.ints, n.etas.per.fit)

CalcVarThetaWeib(beta, etas, tm, event, ps, ps.deriv.shape, ps.deriv.scale, w,
  w.res)

CalcVarThetaWeibRS(beta, etas.matrix, tm, event, ps.rs, ps.deriv.shape.rs,
  ps.deriv.scale.rs, w, w.res)

CalcVarNpmle(tm, event, w, w.res, BS = 100, CI = T)

CalcVarNpmleRS(tm, event, w, w.res, BS = 100, CI = T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalcVarParam_+3A_theta">theta</code></td>
<td>
<p>Coefficient vector from main PH model. First coefficient corresponds to X, the rest to Z</p>
</td></tr>
<tr><td><code id="CalcVarParam_+3A_tm">tm</code></td>
<td>
<p>Vector of observed main event time or censoring time</p>
</td></tr>
<tr><td><code id="CalcVarParam_+3A_event">event</code></td>
<td>
<p>Vector of censoring indicators. <code>1</code> for event <code>0</code> for censored</p>
</td></tr>
<tr><td><code id="CalcVarParam_+3A_z">Z</code></td>
<td>
<p>Additional variables for the main model other than the binary covariate</p>
</td></tr>
<tr><td><code id="CalcVarParam_+3A_q">Q</code></td>
<td>
<p>For PH calibration models: additional covariates</p>
</td></tr>
<tr><td><code id="CalcVarParam_+3A_ps">ps</code></td>
<td>
<p>A matrix. Rows are observations, columns are time pointas of the events. The entry at the i-th row and j-column is
the conditional probability of positive exposure status for observation i at the j-th event time.</p>
</td></tr>
<tr><td><code id="CalcVarParam_+3A_ps.deriv">ps.deriv</code></td>
<td>
<p>A matrix. Rows are observations, columns are time points of the events.  The derivative of <code>ps</code> with 
respect to the calibration model parameters</p>
</td></tr>
<tr><td><code id="CalcVarParam_+3A_w">w</code></td>
<td>
<p>A matrix of time points when measurements on the binary covariate were obtained.</p>
</td></tr>
<tr><td><code id="CalcVarParam_+3A_w.res">w.res</code></td>
<td>
<p>A matrix of measurement results of the binary covariate. The measurement corresponding to the time points in <code>w</code>.</p>
</td></tr>
<tr><td><code id="CalcVarParam_+3A_fit.cox">fit.cox</code></td>
<td>
<p>For PH calibration models:  The result of <code>icenReg::ic_sp</code> on the interval-censored data</p>
</td></tr>
<tr><td><code id="CalcVarParam_+3A_fit.cox.rs.ints">fit.cox.rs.ints</code></td>
<td>
<p>For grouped risk-set PH calibraion: The result of <code>FitCalibCoxRSInts</code> on the interval-censored data</p>
</td></tr>
<tr><td><code id="CalcVarParam_+3A_pts.for.ints">pts.for.ints</code></td>
<td>
<p>For grouped-risk set PH calibraion: Points defining the intervals for grouping risk-sets (first one has to be zero). Should be sorted from zero up</p>
</td></tr>
<tr><td><code id="CalcVarParam_+3A_n.etas.per.fit">n.etas.per.fit</code></td>
<td>
<p>For grouped-risk set PH calibraion: A vector. Total number of parameters for each PH calibration fit.</p>
</td></tr>
<tr><td><code id="CalcVarParam_+3A_beta">beta</code></td>
<td>
<p>Coefficient of the binary covariate. The analogue of theta for non-PH calibration models</p>
</td></tr>
<tr><td><code id="CalcVarParam_+3A_etas">etas</code></td>
<td>
<p>For Weibull calibration: Shape and scale parameters of the Weibull calibration model.</p>
</td></tr>
<tr><td><code id="CalcVarParam_+3A_ps.deriv.shape">ps.deriv.shape</code></td>
<td>
<p>The derivative of <code>ps</code> with respect to the shape parameter of the Weibull calibration model.</p>
</td></tr>
<tr><td><code id="CalcVarParam_+3A_ps.deriv.scale">ps.deriv.scale</code></td>
<td>
<p>The derivative of <code>ps</code> with respect to the scale parameter of the Weibull calibration model.</p>
</td></tr>
<tr><td><code id="CalcVarParam_+3A_etas.matrix">etas.matrix</code></td>
<td>
<p>For Weibull risk-set calibration: Two-columns matrix. Each row contains shape and scale parameters from a Weibull risk-set calibration model</p>
</td></tr>
<tr><td><code id="CalcVarParam_+3A_ps.rs">ps.rs</code></td>
<td>
<p>A matrix. Rows are observations, columns are time points of the events. The entry at the i-th row and j-column is
the conditional probability of positive exposure status for observation i at the j-th event time.</p>
</td></tr>
<tr><td><code id="CalcVarParam_+3A_ps.deriv.shape.rs">ps.deriv.shape.rs</code></td>
<td>
<p>For Weibull risk-set calibration:The derivative of <code>ps</code> with respect to the shape parameters of the Weibull risk-set calibration models.</p>
</td></tr>
<tr><td><code id="CalcVarParam_+3A_ps.deriv.scale.rs">ps.deriv.scale.rs</code></td>
<td>
<p>For Weibull risk-set calibration:The derivative of <code>ps</code> with respect to the scale parameters of the Weibull risk-set calibration models.</p>
</td></tr>
<tr><td><code id="CalcVarParam_+3A_bs">BS</code></td>
<td>
<p>For nonparametric calibration: Number of bootstrap iterations, Default: 100</p>
</td></tr>
<tr><td><code id="CalcVarParam_+3A_ci">CI</code></td>
<td>
<p>For nonparametric calibration: Should the function return confidence intervals?, Default: T</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The covariance matrix. The first row and column are for the binary exposure.
</p>
<p>For nonparametric calibration: Variance estimate and possibly confidence interval for the log hazard-ratio of the binary exposure under 
a nonparametric calibration model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data set
sim.data &lt;- ICcalib:::SimCoxIntervalCensSingle(n.sample = 200, lambda = 0.1, alpha = 0.25, 
                                               beta0 = log(0.5), mu = 0.2, n.points = 2, 
                                               weib.shape = 1, weib.scale = 2)
case.times &lt;- sim.data$obs.tm[sim.data$delta==1]
# Fit a Weibull calibration model for the covariate starting time distribution
calib.weib.params &lt;- FitCalibWeibull(w = sim.data$w, w.res = sim.data$w.res)
px &lt;- t(sapply(case.times, CalcWeibullCalibP, w = sim.data$w, 
               w.res =  sim.data$w.res, weib.params = calib.weib.params))
# Calculate derivative matrices
px.deriv.shape &lt;- t(sapply(case.times, ICcalib:::CalcWeibullCalibPderivShape, 
w = sim.data$w, w.res =  sim.data$w.res, weib.params = calib.weib.params))
px.deriv.scale &lt;- t(sapply(case.times, ICcalib:::CalcWeibullCalibPderivScale, 
w = sim.data$w, w.res = sim.data$ w.res, weib.params = calib.weib.params))
# Point estimate 
est.weib.calib &lt;- optimize(f = ICcalib:::CoxLogLikX,  tm = sim.data$obs.tm, 
                           event = sim.data$delta, ps = px, interval = c(-50,50), 
                           maximum = TRUE)$maximum
# Variance estimate (no addtional covariates)
var.beta.wb &lt;- CalcVarThetaWeib(beta = est.weib.calib, etas = calib.weib.params, 
                                tm = sim.data$obs.tm, event = sim.data$delta, 
                                ps = px, ps.deriv.shape = px.deriv.shape, 
                                ps.deriv.scale =  px.deriv.scale, w = sim.data$w, 
                                w.res = sim.data$w.res)
 print(est.weib.calib)
 print(var.beta.wb)                               
</code></pre>

<hr>
<h2 id='CalcWeibullCalibP'>Calculating the probabilities of positive binary exposure status at a given time point using a Weibull calibration model</h2><span id='topic+CalcWeibullCalibP'></span>

<h3>Description</h3>

<p>For a given time point, calculate the probability of positive exposure value  for multiple observations (participants). 
The function uses the results of a Weibull calibration model fit, and given collected data on the history 
of the binary exposure for each participant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcWeibullCalibP(w, w.res, point, weib.params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalcWeibullCalibP_+3A_w">w</code></td>
<td>
<p>A matrix of time points when measurements on the binary covariate were obtained.</p>
</td></tr>
<tr><td><code id="CalcWeibullCalibP_+3A_w.res">w.res</code></td>
<td>
<p>A matrix of measurement results of the binary covariate. Each measurement corresponds to the time points in <code>w</code></p>
</td></tr>
<tr><td><code id="CalcWeibullCalibP_+3A_point">point</code></td>
<td>
<p>The time point at which the probabilities are estimated.</p>
</td></tr>
<tr><td><code id="CalcWeibullCalibP_+3A_weib.params">weib.params</code></td>
<td>
<p>A bivariate vector. Shape and scale parameters of the Weibull calibration model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of estimated probabilities of positive exposure status at time <code>point</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Weibull">Weibull</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data set
sim.data &lt;- ICcalib:::SimCoxIntervalCensSingle(n.sample = 200, lambda = 0.1, 
                                               alpha = 0.25, beta0 = log(0.5), 
                                               mu = 0.2, n.points = 2, 
                                               weib.shape = 1, weib.scale = 2)
# Fit a Weibull calibration model for the covariate starting time distribution
calib.weib.params &lt;- FitCalibWeibull(w = sim.data$w, w.res = sim.data$w.res)
# Calculate the conditional probabilities of binary covariate=1 at time one
probs &lt;- CalcWeibullCalibP(w = sim.data$w, w.res = sim.data$w.res, point = 1,
                           weib.params = calib.weib.params)
summary(probs)
</code></pre>

<hr>
<h2 id='CalcWeibullRSP'>Calculating the probabilities of positive binary exposure status at a given time point using risk-set Weibull calibration models</h2><span id='topic+CalcWeibullRSP'></span>

<h3>Description</h3>

<p>For a given time point, calculate the probability of positive exposure value  for multiple observations (participants). 
The function uses the results of a Weibull calibration model fit, and given collected data on the history 
of the binary exposure for each participant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcWeibullRSP(w, w.res, point, weib.params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalcWeibullRSP_+3A_w">w</code></td>
<td>
<p>A matrix of time points when measurements on the binary covariate were obtained.</p>
</td></tr>
<tr><td><code id="CalcWeibullRSP_+3A_w.res">w.res</code></td>
<td>
<p>A matrix of measurement results of the binary covariate. Each measurement corresponds to the time points in <code>w</code></p>
</td></tr>
<tr><td><code id="CalcWeibullRSP_+3A_point">point</code></td>
<td>
<p>The time point at which the probabilities are estimated.</p>
</td></tr>
<tr><td><code id="CalcWeibullRSP_+3A_weib.params">weib.params</code></td>
<td>
<p>A bivariate vector. Shape and scale parameters of the Weibull calibration model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At its present form this function is identical to <code>CalcWeibullCalibP</code>. This is because the current version of the <code>ICcalib</code> package
(Version 1.0.005), the user loop over the main event times. Then, at each event time point, the user should include the appropriate Weibull
parameters as estimated by <code>FitCalibWeibullRS</code>.
</p>


<h3>Value</h3>

<p>A vector of estimated probabilities of positive exposure status at time <code>point</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Weibull">Weibull</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data set
sim.data &lt;- ICcalib:::SimCoxIntervalCensSingle(n.sample = 200, lambda = 0.1, 
                                               alpha = 0.25, beta0 = log(0.5), 
                                               mu = 0.2, n.points = 2, 
                                               weib.shape = 1, weib.scale = 2)
case.times &lt;- sim.data$obs.tm[sim.data$delta==1]
# Fit Weibull risk-set calibration models
calib.weib.params &lt;- FitCalibWeibullRS(w = sim.data$w, w.res = sim.data$w.res, 
                                       tm = sim.data$obs.tm, 
                                       event = sim.data$delta)
# Calculate the conditional probabilities of binary covariate=1 at time one
probs &lt;- CalcWeibullRSP(w = sim.data$w, w.res = sim.data$w.res, point = 1,
                        weib.params = calib.weib.params)
summary(probs)
## Not run: 
if(interactive()){
 #EXAMPLE1
 }

## End(Not run)
</code></pre>

<hr>
<h2 id='FitCalibCox'>Fitting Proportional Hazards Calibration Models with Covariates</h2><span id='topic+FitCalibCox'></span>

<h3>Description</h3>

<p>Fits a proportional hazards calibration model for time-to-exposure from interval-censored data with covariates. The exposure is a binary covariate measured
in intermittent times. The covariates (<code>Q</code>) are associated with the time-to-exposure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FitCalibCox(w, w.res, Q, hz.times, n.int = 5, order = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FitCalibCox_+3A_w">w</code></td>
<td>
<p>A matrix of time points when measurements on the binary covariate were obtained.</p>
</td></tr>
<tr><td><code id="FitCalibCox_+3A_w.res">w.res</code></td>
<td>
<p>A matrix of measurement results of the binary covariate. It corresponds to the time points in <code>w</code></p>
</td></tr>
<tr><td><code id="FitCalibCox_+3A_q">Q</code></td>
<td>
<p>Matrix of covariates for PH calibration model</p>
</td></tr>
<tr><td><code id="FitCalibCox_+3A_hz.times">hz.times</code></td>
<td>
<p>Times used for calculating the baseline hazard function from PH calibration model</p>
</td></tr>
<tr><td><code id="FitCalibCox_+3A_n.int">n.int</code></td>
<td>
<p>The number of interior knots to be used, see <code>ICsurv::fast.PH.ICsurv.EM</code>, Default: 5</p>
</td></tr>
<tr><td><code id="FitCalibCox_+3A_order">order</code></td>
<td>
<p>the order of the basis functions. See <code>ICsurv::fast.PH.ICsurv.EM</code>, Default: 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object created by ICsurv::fast.PH.ICsurv.EM, with additional variables <code>knots</code> and <code>order</code>.
</p>


<h3>See Also</h3>

<p><code><a href="ICsurv.html#topic+fast.PH.ICsurv.EM">fast.PH.ICsurv.EM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.data &lt;- ICcalib:::SimCoxIntervalCensCox(n.sample = 200, lambda = 0.1, 
                                            alpha = 0.25, beta0 = 0, 
                                            gamma.q = c(log(0.75), log(2.5)), 
                                            gamma.z = log(1.5), mu = 0.2, 
                                            n.points = 2)
# The baseline hazard for the calibration model is calculated in observation times
cox.hz.times &lt;- sort(unique(sim.data$obs.tm)) 
# Fit proprtional hazards calibration model
FitCalibCox(w = sim.data$w, w.res = sim.data$w.res, Q = sim.data$Q, 
            hz.times = cox.hz.times, n.int = 5, order = 2)
</code></pre>

<hr>
<h2 id='FitCalibCoxRS'>Fitting Proportional Hazards Risk-Set Calibration Models with Covariates</h2><span id='topic+FitCalibCoxRS'></span><span id='topic+FitCalibCoxRSInts'></span>

<h3>Description</h3>

<p><code>FitCalibCoxRS</code> fits proportional hazards risk-set calibration models for time-to-exposure from interval-censored data with covariates. The exposure is a binary covariate measured
in intermittent times. The covariates (<code>Q</code>) are associated with the time-to-exposure. This function fits a calibration model at each main event time point,
using only members of the risk set at that time point.
model is fitted (for all the data) and used for that time point.
</p>
<p><code>FitCalibCoxRSInts</code> fits proportional hazards grouped risk-set calibration models for time-to-exposure from interval-censored data with covariates. The exposure is a binary covariate measured
in intermittent times. The covariates (<code>Q</code>) are associated with the time-to-exposure. Unlike <code>FitCalibCoxRS</code>, this function fits a calibration model
at each of the given points for <code>pts.for.ints</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FitCalibCoxRS(w, w.res, Q, hz.times, tm, n.int = 5, order = 2, event)

FitCalibCoxRSInts(w, w.res, Q, hz.times, n.int = 5, order = 2, tm, event,
  pts.for.ints)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FitCalibCoxRS_+3A_w">w</code></td>
<td>
<p>A matrix of time points when measurements on the binary covariate were obtained.</p>
</td></tr>
<tr><td><code id="FitCalibCoxRS_+3A_w.res">w.res</code></td>
<td>
<p>A matrix of measurement results of the binary covariate. It corresponds to the time points in <code>w</code></p>
</td></tr>
<tr><td><code id="FitCalibCoxRS_+3A_q">Q</code></td>
<td>
<p>Matrix of covariates for PH calibration model</p>
</td></tr>
<tr><td><code id="FitCalibCoxRS_+3A_hz.times">hz.times</code></td>
<td>
<p>Times used for calculating the baseline hazard function of a PH calibration model</p>
</td></tr>
<tr><td><code id="FitCalibCoxRS_+3A_tm">tm</code></td>
<td>
<p>Vector of observed main event time or censoring time</p>
</td></tr>
<tr><td><code id="FitCalibCoxRS_+3A_n.int">n.int</code></td>
<td>
<p>The number of interior knots to be used, see <code>ICsurv::fast.PH.ICsurv.EM</code>, Default: 5</p>
</td></tr>
<tr><td><code id="FitCalibCoxRS_+3A_order">order</code></td>
<td>
<p>the order of the basis functions. See <code>ICsurv::fast.PH.ICsurv.EM</code>, Default: 2</p>
</td></tr>
<tr><td><code id="FitCalibCoxRS_+3A_event">event</code></td>
<td>
<p>Vector of censoring indicators. <code>1</code> for event <code>0</code> for censored</p>
</td></tr>
<tr><td><code id="FitCalibCoxRS_+3A_pts.for.ints">pts.for.ints</code></td>
<td>
<p>Points defining the intervals for grouping risk-sets (first one has to be zero). Should be sorted from zero up.
<code>pts.for.ints</code> is used only for <code>FitCalibCoxRSInts</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case of an error in the model-fitting at a certain time point, a proportional hazards calibration 
model (for all the data) is fitted and used for that time point.
</p>


<h3>Value</h3>

<p>A list of Cox PH model fits, each supplemented with the knots and order used for the I-splines.
</p>


<h3>See Also</h3>

<p><code><a href="ICsurv.html#topic+fast.PH.ICsurv.EM">fast.PH.ICsurv.EM</a></code>,  <code><a href="#topic+FitCalibCox">FitCalibCox</a></code>
</p>
<p><code><a href="ICsurv.html#topic+fast.PH.ICsurv.EM">fast.PH.ICsurv.EM</a></code>,  <code><a href="#topic+FitCalibCox">FitCalibCox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2) 
sim.data &lt;- ICcalib:::SimCoxIntervalCensCox(n.sample = 50, lambda = 0.1, 
                                            alpha = 0.25, beta0 = log(0.2),
                                            gamma.q = c(log(0.75), log(2.5)), 
                                            gamma.z = log(1.5), mu = 0.2, 
                                            n.points = 2)
# The baseline hazard for the calibration model is calculated in observation times
cox.hz.times &lt;- sort(unique(sim.data$obs.tm)) 
# Fit proprtional hazards grouped risk-sets calibration models
calib.ph.rs.fit &lt;- FitCalibCoxRSInts(w = sim.data$w, w.res = sim.data$w.res, Q = sim.data$Q, 
                                     hz.times = cox.hz.times, tm = sim.data$obs.tm, 
                                     event = sim.data$delta, pts.for.ints = seq(0, 3, 1.5),
                                     n.int = 5, order = 2)
# Below is a more time consuming option (no grouping of risk-sets)
# FitCalibCoxRS(w = sim.data$w, w.res = sim.data$w.res, Q = sim.data$Q, 
#                hz.times = cox.hz.times, obs.tm = sim.data$obs.tm, 
#               event = sim.data$delta, n.int = 5, order = 1)
</code></pre>

<hr>
<h2 id='FitCalibNpmle'>Fitting Nonparametric Calibration Models</h2><span id='topic+FitCalibNpmle'></span>

<h3>Description</h3>

<p>Fits a Weibull calibration model for time-to-exposure from interval-censored data. The exposure is a binary covariate measured
in intermittent times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FitCalibNpmle(w, w.res)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FitCalibNpmle_+3A_w">w</code></td>
<td>
<p>A matrix of time points when measurements on the binary covariate were obtained.</p>
</td></tr>
<tr><td><code id="FitCalibNpmle_+3A_w.res">w.res</code></td>
<td>
<p>A matrix of measurement results of the binary covariate. It corresponds to the time points in <code>w</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of NPMLE model fitting for interval-censored data, as obtained by <code>icenReg::ic_np</code>
</p>


<h3>See Also</h3>

<p><code><a href="icenReg.html#topic+ic_np">ic_np</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data set
sim.data &lt;- ICcalib:::SimCoxIntervalCensSingle(n.sample = 200, lambda = 0.1, 
                                               alpha = 0.25, beta0 = log(0.5), 
                                               mu = 0.2, n.points = 2, 
                                               weib.shape = 1, weib.scale = 2)
# Calcualte the NPMLE for a nonparametric calibration model for the covariate 
# starting-time distribution
npmle.fit &lt;- ICcalib::FitCalibNpmle(w = sim.data$w, w.res = sim.data$w.res)
# Plot the estimated survival function
plot(npmle.fit)
</code></pre>

<hr>
<h2 id='FitCalibWeibull'>Fitting Weibull Calibration Models</h2><span id='topic+FitCalibWeibull'></span>

<h3>Description</h3>

<p>Fits a Weibull calibration model for time-to-exposure from interval-censored data. The exposure is a binary covariate measured
in intermittent times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FitCalibWeibull(w, w.res)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FitCalibWeibull_+3A_w">w</code></td>
<td>
<p>A matrix of time points when measurements on the binary covariate were obtained.</p>
</td></tr>
<tr><td><code id="FitCalibWeibull_+3A_w.res">w.res</code></td>
<td>
<p>A matrix of measurement results of the binary covariate. It corresponds to the time points in <code>w</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A bivariate vector: the estimated Weibull shape and scale parameters
</p>


<h3>See Also</h3>

<p><code><a href="fitdistrplus.html#topic+fitdistcens">fitdistcens</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data set
sim.data &lt;- ICcalib:::SimCoxIntervalCensSingle(n.sample = 200, lambda = 0.1, 
                                               alpha = 0.25, beta0 = log(0.5), 
                                               mu = 0.2, n.points = 2, 
                                               weib.shape = 1, weib.scale = 2)
# Fit a Weibull calibration model for the covariate starting time distribution
ICcalib::FitCalibWeibull(w = sim.data$w, w.res = sim.data$w.res) 
</code></pre>

<hr>
<h2 id='FitCalibWeibullRS'>Fitting Weibull Risk-Set Calibration Models</h2><span id='topic+FitCalibWeibullRS'></span>

<h3>Description</h3>

<p>Fits Weibull risk-set calibration models for time-to-exposure from interval-censored data. The exposure is a binary covariate measured
in intermittent times. This function fits a calibration model at each main event time point, using only members of the risk set at that time point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FitCalibWeibullRS(w, w.res, tm, event, lower = 1e-04, upper = 200)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FitCalibWeibullRS_+3A_w">w</code></td>
<td>
<p>A matrix of time points when measurements on the binary covariate were obtained.</p>
</td></tr>
<tr><td><code id="FitCalibWeibullRS_+3A_w.res">w.res</code></td>
<td>
<p>A matrix of measurement results of the binary covariate. Each measurement corresponds to the time points in <code>w</code></p>
</td></tr>
<tr><td><code id="FitCalibWeibullRS_+3A_tm">tm</code></td>
<td>
<p>Vector of observed main event time or censoring time.</p>
</td></tr>
<tr><td><code id="FitCalibWeibullRS_+3A_event">event</code></td>
<td>
<p>Vector of censoring indicators. <code>1</code> for event <code>0</code> for censored</p>
</td></tr>
<tr><td><code id="FitCalibWeibullRS_+3A_lower">lower</code></td>
<td>
<p>A value to replace zero in the left point of the interval, Default: 1e-04</p>
</td></tr>
<tr><td><code id="FitCalibWeibullRS_+3A_upper">upper</code></td>
<td>
<p>A value to replace infinity in the right point of the interval, Default: 200</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case of an error in the model-fitting at a certain time point, a Weibull calibration 
model is fitted and used for that time point.
</p>


<h3>Value</h3>

<p>A 2-column matrix with the shape and scale parameter for each time-point at which a calibration model was fitted.
</p>


<h3>See Also</h3>

<p><code><a href="fitdistrplus.html#topic+fitdistcens">fitdistcens</a></code>, <code><a href="#topic+FitCalibWeibull">FitCalibWeibull</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data set
sim.data &lt;- ICcalib:::SimCoxIntervalCensSingle(n.sample = 200, lambda = 0.1, 
                                               alpha = 0.25, beta0 = log(0.5), 
                                               mu = 0.2, n.points = 2, 
                                               weib.shape = 1, weib.scale = 2)
# Fit Weibull risk-set calibration models for the conditional covariate 
# starting-time distributions
ICcalib::FitCalibWeibullRS(w = sim.data$w, w.res = sim.data$w.res, 
                           tm = sim.data$obs.tm, event = sim.data$delta)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
