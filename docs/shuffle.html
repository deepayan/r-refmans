<!DOCTYPE html><html lang="en"><head><title>Help for package shuffle</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {shuffle}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#shuffle-package'>
<p>The Shuffle Estimator for Explainable Variance</p></a></li>
<li><a href='#design_vec'>
<p>The design for an fMRI experiment</p></a></li>
<li><a href='#designVec2Mat'>
<p>Convert between a vector and matrix representation of the design</p></a></li>
<li><a href='#estimateShuffle'>
<p>Calculate the shuffle estimators</p></a></li>
<li><a href='#fMRI_responses'>
<p>Responses for 30 voxels (of V1) to 1560 stimuli.</p></a></li>
<li><a href='#getAveraging'>
<p>Convert design into averaging matrices.</p></a></li>
<li><a href='#getNormalizer'>
<p>getNormalizer</p></a></li>
<li><a href='#MSbetAvg'>
<p>Calculate Mean-square-between</p></a></li>
<li><a href='#prediction_res'>
<p>Prediction results for V1 voxels as generated by the Gallant lab in UC Berkeley and published in Kay et al. (2008).</p></a></li>
<li><a href='#prepareShuffle'>
<p>Prerprocess for the shuffle estimator</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>The Shuffle Estimator for Explainable Variance</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-4-24</td>
</tr>
<tr>
<td>Author:</td>
<td>Yuval Benjamini</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yuval Benjamini &lt;yuvalbenj@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of the shuffle estimator, a non-parametric estimator for signal and noise variance under mild noise correlations.  </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2.0)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-04-29 19:03:34 UTC; yuvalb</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-05-02 06:41:26</td>
</tr>
</table>
<hr>
<h2 id='shuffle-package'>
The Shuffle Estimator for Explainable Variance </h2><span id='topic+shuffle-package'></span><span id='topic+shuffle'></span>

<h3>Description</h3>

<p>This package implements the algorithms underlying the shuffle estimators, variance 
estimators for one-way analysis of variance designs. The estimators can overcome correlated noise 
by recomputing the mean-square-between statistics on a permuted version of the data. 
The permutations should preserve the noise covariance matrix, but a parametric model for the noise covariance is not necessary. For more details see Benjamini and Yu, and here 
<a href="http://statweb.stanford.edu/~yuvalben">http://statweb.stanford.edu/~yuvalben</a>.
</p>
<p>Two functions implement the important stages of estimation:<br />
prepareShuffle(design_vec, premutation), which preprocess the design and computes the normalization constant for a given permutation.<br />
estimateShuffle(response_vec, prepare), which estimates variances and effect sizes for a specific data vector.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> shuffle</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2013-4-24 </td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Yuval Benjamini &lt;yuvalbenj@gmail.com&gt;
</p>


<h3>References</h3>

<p>Benjamini and Yu (2013), &quot;The shuffle estimator for explainable variance in fMRI experiments&quot;, Annals of Applied Statistics 7 (4) <a href="http://projecteuclid.org/euclid.aoas/1387823308">http://projecteuclid.org/euclid.aoas/1387823308</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(design_vec,fMRI_responses,prediction_res)

# Make example shorter - for paper example use T = ncol(fMRI_responses)
T = 156*4
fMRI_responses_sm = fMRI_responses[,1:T]
design_sm = design_vec[1:T]
permutation = rev(1:T)

prep_shuffle = prepareShuffle(design_sm,permutation)

var_explained = numeric(nrow(fMRI_responses_sm))
for (i in 1:nrow(fMRI_responses_sm)) {
    var_explained[i] = estimateShuffle(fMRI_responses_sm[i,],prep_shuffle)$effect
}

plot(var_explained, pmax(prediction_res,0)^2,
		    xlim = c(0,0.7), ylim = c(0,0.7), 
		    xlab = "Explainable variance", ylab = "Corr^2") 
abline(0,1,col=4)
</code></pre>

<hr>
<h2 id='design_vec'>
The design for an fMRI experiment
</h2><span id='topic+design_vec'></span>

<h3>Description</h3>

<p>The design vector for the validation data in an fMRI experiment.
At time t the image design_vec[t] was shown. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(design_vec)</code></pre>


<h3>Format</h3>

<p>The format is:
num [1:1560] 2 3 6 1 11 2 2 7 2 10 ...
</p>


<h3>Details</h3>

<p>The design vector for the validation data in an fMRI experiment.
The experiment consisted of 1560 timeframes, 120 images each repeated 13 times. 
The imshrd were organized into 10 separate blocks, each repeating 12 images.
</p>


<h3>Source</h3>

<p>Kay, Naselaris, Prenger and Gallant (2008), &quot;Identifying natural images from human brain activity&quot;
</p>


<h3>References</h3>

<p>Benjamini and Yu (2013), &quot;The shuffle estimator for explainable variance&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(design_vec)
plot(design_vec,xlab = "event", ylab = "treatment", main="Design of the full experiment" )

plot(design_vec[1:120],xlab = "event",ylab= "treatment",main="Design of a single block")
</code></pre>

<hr>
<h2 id='designVec2Mat'>
Convert between a vector and matrix representation of the design
</h2><span id='topic+designVec2Mat'></span><span id='topic+designMat2Vec'></span><span id='topic+perm2Mat'></span>

<h3>Description</h3>

<p>Convert between representations of a one-way anova with $m$ treatments and $T$ measurements.
The vector representation is a T-length integer vector with m distinct integers. The matrix representation is a T by m matrix with a 1 at i,j indicating the 
i'th measurement belongs to the j'th treatment. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>designVec2Mat(desvec)
designMat2Vec(desmat)
perm2Mat(perm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="designVec2Mat_+3A_desvec">desvec</code>, <code id="designVec2Mat_+3A_perm">perm</code></td>
<td>
<p>An integer vector of length T with m distinct non-zero integers. 0 indicates measurements should be discarded.</p>
</td></tr>
<tr><td><code id="designVec2Mat_+3A_desmat">desmat</code></td>
<td>
<p>A 0-1 matrix with T rows, m columns.</p>
</td></tr> 
</table>


<h3>Note</h3>

<p>designVec2Mat() is called within getAveraging .
</p>


<h3>Author(s)</h3>

<p>Yuval Benjamini
</p>

<hr>
<h2 id='estimateShuffle'>
Calculate the shuffle estimators
</h2><span id='topic+estimateShuffle'></span>

<h3>Description</h3>

<p>estimateShuffle estimates the following quantities for a response vector:
the signal variance (signalVar), the noise variance (noiseVar), the total variance (YVar), 
and the explainable variance (effect). Inputs to the function are the response vector, and 
a preprocessing structure (the output of prepareShuffle) which holds the design, the shuffle permutation, and 
the calculated normalizer. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateShuffle(dat, prep, neg = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimateShuffle_+3A_dat">dat</code></td>
<td>

<p>A vector of reponses - should be of the same size as the design vector and the shuffle permutation.
</p>
</td></tr>
<tr><td><code id="estimateShuffle_+3A_prep">prep</code></td>
<td>

<p>The output of prepareShuffle; includes the design, the shuffling permuation, and a normalizer. 
</p>
</td></tr>
<tr><td><code id="estimateShuffle_+3A_neg">neg</code></td>
<td>

<p>If neg=FALSE does not allow the signal variance to get arbitrary negative values,
but instead sets signal variance to -1e-05.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>estimateShuffle compares the mean-square-between of the data
to the mean-square-between of the permuted data, the difference being the scaled noise variance. 
Effect size is the ratio between the estimated signal data and the estimated total variance. 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>signalVar</code></td>
<td>
<p>The estimated variance of the signal</p>
</td></tr>
<tr><td><code>noiseVar</code></td>
<td>
<p>The estimated variance of the noise</p>
</td></tr>	    
<tr><td><code>YVar</code></td>
<td>
<p>The estimated total variance</p>
</td></tr>
<tr><td><code>effect</code></td>
<td>
<p>The proportion of explainable variance (signalVar/Yvar)</p>
</td></tr>  
</table>


<h3>Author(s)</h3>

<p>Yuval Benjamini</p>


<h3>References</h3>

<p>Benjamini and Yu (2013), &quot;The shuffle estimator for explainable variance in fMRI experiments&quot;. 
</p>

<hr>
<h2 id='fMRI_responses'>
Responses for 30 voxels (of V1) to 1560 stimuli.
</h2><span id='topic+fMRI_responses'></span>

<h3>Description</h3>

<p>A 30x1560 data matrix consisting of a sample of 30 fMRI responses from the visual cortex V1 of a human subject, 
to a sequence of natural images. The treatment index is found in design_vec. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fMRI_responses)</code></pre>


<h3>Format</h3>

<p>A 30x1560 matrix of real values. Each row corresponds to a different voxel. 
</p>


<h3>Details</h3>

<p>Measurement were recorded as a person was watching a sequence of natural images.
Each column corresponds to a displayed image; 
each row corresponds to the response of a single voxel in the fMRI scan.
This data consists of a small subset of the voxels in V1 from the original scans. 
The data was recorded in the Gallant lab at UC Berkeley.</p>


<h3>Source</h3>

<p>Kay, Naselaris, Prenger and Gallant (2008), &quot;Identifying natural images from human brain activity&quot; 
</p>


<h3>References</h3>

<p>Benjamini and Yu (2013), &quot;The shuffle estimator for explainable variance in fMRI experiments&quot;</p>

<hr>
<h2 id='getAveraging'>
Convert design into averaging matrices.
</h2><span id='topic+getAveraging'></span>

<h3>Description</h3>

<p>getAveraging(des) converts a design (either a vector or a matrix) 
into averaging matrix notation (from the paper).  
For a response vector Y, (B Y)[t] is the mean of all responses corresponding to the treatment at time t, 
and (B-G)Y [t] is the averaged-removed treatment mean. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAveraging(des)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getAveraging_+3A_des">des</code></td>
<td>

<p>Either a vector or a matrix representation of design (see designVec2Mat and designMat2Vec). 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components
</p>
<table role = "presentation">
<tr><td><code>m</code></td>
<td>
<p>The number of treatments</p>
</td></tr>
<tr><td><code>ns</code></td>
<td>
<p>An m-length vector with the number of repeats for each treatment. For balanced designs with n repeats, ns=rep(n,m)</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>The averaging matrix according to the design</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>1/T for T the number of measurements</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yuval Benjamini
</p>


<h3>References</h3>

<p>Benjamini and Yu (2013).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(design_vec)

design_avg = getAveraging(design_vec)
rand_resp = rnorm(length(design_vec))

global_mean = mean(rand_resp[design_vec != 0 ])
first_treatment_mean=  mean(rand_resp[design_vec == design_vec[1]])
cat((design_avg$B %*% rand_resp)[1], first_treatment_mean )

cat(((design_avg$B-design_avg$G) %*% rand_resp)[1], first_treatment_mean- global_mean)
</code></pre>

<hr>
<h2 id='getNormalizer'>
getNormalizer
</h2><span id='topic+getNormalizer'></span>

<h3>Description</h3>

<p>Computes the normalizer 1/(1-alpha) for a given design and permutation. 
The shuffle estimator is [MSbet(Y) - MSbet(PY)]*normalizer. \
We prefer the normalizer to be close to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNormalizer(avgmat, perm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getNormalizer_+3A_avgmat">avgmat</code></td>
<td>

<p>The output of getAveraging.
</p>
</td></tr>
<tr><td><code id="getNormalizer_+3A_perm">perm</code></td>
<td>

<p>The shuffling permutation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under balanced designs, the normalizer = 1/[1-alpha]. More generally, 
we call facA = 1 and facB = alpha(design, permutation).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>norm</code></td>
<td>
<p>The value by which to correct the difference of variances [1/(facA-facB)]</p>
</td></tr>
<tr><td><code>facA</code></td>
<td>
<p>The signal coefficient of the original design, should be 1</p>
</td></tr>
<tr><td><code>facB</code></td>
<td>
<p>The signal variance coefficient of the permuted design</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yuval Benjamini 
</p>


<h3>References</h3>

<p>Benjamini and Yu (2013). 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(design_vec)

# Make example shorter - for paper example use T = ncol(fMRI_responses) = 156*10
T = 156*4
design_sm = design_vec[1:T]

identity_perm = 1:T
reverse_perm = rev(identity_perm)
shift_perm = c(2:T, 1)

design_avg = getAveraging(design_sm)
identity_norm = getNormalizer(design_avg, identity_perm)
print('For the identity, we cannot get an estimator')
print(sprintf('facA(1) %.3f, facB(alpha) %.3f, normalizer %.3f ', 
		    identity_norm$facA, identity_norm$facB, identity_norm$norm))

reverse_norm = getNormalizer(design_avg, reverse_perm)
print('For the reverse, we get a normalizer close to 1 ')
print(sprintf('facA(1) %.3f, facB(alpha) %.3f, normalizer %.3f ', 
		    reverse_norm$facA, reverse_norm$facB, reverse_norm$norm))

shift_norm = getNormalizer(design_avg, shift_perm)
print('The shift mixes across blocks. The normalizer is smaller, but assumptions may not hold')
print(sprintf('facA(1) %.3f, facB(alpha) %.3f, normalizer %.3f ', 
		    shift_norm$facA, shift_norm$facB, shift_norm$norm))

</code></pre>

<hr>
<h2 id='MSbetAvg'>
Calculate Mean-square-between
</h2><span id='topic+MSbetAvg'></span>

<h3>Description</h3>

<p>MSbetAvg calculates the mean-square-between contrast according to the design vector.
Responses for each condition are averaged, and the sample variance is calculated for these averages. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MSbetAvg(dat, avgmat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MSbetAvg_+3A_dat">dat</code></td>
<td>

<p>The vector of measurements on which the constrast is computed. 
</p>
</td></tr>
<tr><td><code id="MSbetAvg_+3A_avgmat">avgmat</code></td>
<td>

<p>The design parameters, as extracted by getAveraging(). 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the quadratic contrast computed on the data vector.
</p>


<h3>Author(s)</h3>

<p>Yuval Benjamini
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fMRI_responses,design_vec)

msbet = MSbetAvg(fMRI_responses[1,], getAveraging(design_vec))

# Compute same value using "aov" when design is balanced ... 
ns =tapply(design_vec,design_vec, length)
# (check that design is balanced)
stopifnot(length(unique(ns))==1)

m = length(unique(design_vec))

aov_sum = summary(aov(fMRI_responses[1,] ~ factor(design_vec)))
ss_bet = aov_sum[[1]][1,2]
# In unbalanced designs, each example should require more care...
msbet_aov = (ss_bet / ns[1] )/(m-1) 

cat(msbet, msbet_aov)

</code></pre>

<hr>
<h2 id='prediction_res'>
Prediction results for V1 voxels as generated by the Gallant lab in UC Berkeley and published in Kay et al. (2008). 
</h2><span id='topic+prediction_res'></span>

<h3>Description</h3>

<p>The correlation between measured response and predicted response on validation data for 1250 V1 voxels. 
The prediction algorithms are described in detail in Kay et al, 2008. We compare these prediction results 
to the explainable variance estimated with the shuffle estimator. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(prediction_res)</code></pre>


<h3>Format</h3>

<p>A numerical vector of correlation coefficients.
</p>


<h3>Source</h3>

<p>Kay, Naselaris, Prenger and Gallant (2008), &quot;Identifying natural images from human brain activity&quot;
</p>


<h3>References</h3>

<p>Benjamini and Yu (2013)
</p>

<hr>
<h2 id='prepareShuffle'>
Prerprocess for the shuffle estimator
</h2><span id='topic+prepareShuffle'></span>

<h3>Description</h3>

<p>prepareShuffle computes the averaging matrices and normalizing constants for the shuffle estimator. 
It can be run once for all data vectors sharing the design. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepareShuffle(des, perm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prepareShuffle_+3A_des">des</code></td>
<td>
<p>A design vector or matrix
</p>
</td></tr>
<tr><td><code id="prepareShuffle_+3A_perm">perm</code></td>
<td>

<p>The shuffling permutation
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>m</code></td>
<td>
<p>The number of treatments</p>
</td></tr>
<tr><td><code>ns</code></td>
<td>
<p>An m-length vector with the number of repeats for each treatment. For balanced designs with n repeats, ns=rep(n,m)</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>The averaging matrix according to the design</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>1/T for T the number of measurements</p>
</td></tr>
<tr><td><code>norm</code></td>
<td>
<p>The value by which to correct the difference of variances [1/(facA-facB)]</p>
</td></tr>
<tr><td><code>facA</code></td>
<td>
<p>The signal coefficient of the original design</p>
</td></tr>
<tr><td><code>facB</code></td>
<td>
<p>The signal variance coefficient of the permuted design</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yuval Benjamini
</p>


<h3>References</h3>

<p>Benjamini and Yu (2013)
</p>


<h3>See Also</h3>

<p>getAverage
getNormalizer
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
