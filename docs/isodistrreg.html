<!DOCTYPE html><html><head><title>Help for package isodistrreg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {isodistrreg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#isodistrreg-package'><p>Isotonic distributional regression (IDR)</p></a></li>
<li><a href='#.onUnload'><p>Unload dll when package is unloaded</p></a></li>
<li><a href='#bscore'><p>Brier score for forecast probability of threshold exceedance</p></a></li>
<li><a href='#cdf'><p>Cumulative distribution function (CDF) of IDR or raw forecasts</p></a></li>
<li><a href='#compOrd'><p>Componentwise partial order relation</p></a></li>
<li><a href='#crps'><p>Continuous ranked probability score (CRPS)</p></a></li>
<li><a href='#dindexm'><p>Distributional index model (DIM)</p></a></li>
<li><a href='#idr'><p>Fit IDR to training data</p></a></li>
<li><a href='#idrbag'><p>Compute IDR predictions with (su)bagging</p></a></li>
<li><a href='#multivHazardLoop'><p>Loop for multivariate estimation under hazard ratio ordering (experimental,</p>
will possibly me modified)</a></li>
<li><a href='#neighborPoints'><p>Neighbor points with respect to componentwise order</p></a></li>
<li><a href='#pit'><p>Probability integral transform (PIT)</p></a></li>
<li><a href='#plot.idr'><p>Plot IDR predictions</p></a></li>
<li><a href='#predict.dindexfit'><p>Predict method for distributional index model (DIM)</p></a></li>
<li><a href='#predict.idrfit'><p>Predict method for IDR fits</p></a></li>
<li><a href='#prepareData'><p>Prepare data for IDR modeling with given orders</p></a></li>
<li><a href='#qpred'><p>Quantile function of IDR or raw forecasts</p></a></li>
<li><a href='#qscore'><p>Quantile scores for IDR or raw forecasts</p></a></li>
<li><a href='#rain'><p>Frankfurt airport precipitation data</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#trReduc'><p>Transitive Reduction of path matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Isotonic Distributional Regression (IDR)</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-03-16</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Henzi &lt;henzi.alexander@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Distributional regression under stochastic order restrictions for
    numeric and binary response variables and partially ordered covariates. See
    Henzi, Ziegel, Gneiting (2020) &lt;<a href="https://doi.org/10.48550/arXiv.1909.03725">doi:10.48550/arXiv.1909.03725</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.1), osqp, Matrix, utils</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/AlexanderHenzi/isodistrreg">https://github.com/AlexanderHenzi/isodistrreg</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/AlexanderHenzi/isodistrreg/issues">https://github.com/AlexanderHenzi/isodistrreg/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-03-19 06:26:20 UTC; alexh</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexander Henzi [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-03-22 09:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='isodistrreg-package'>Isotonic distributional regression (IDR)</h2><span id='topic+isodistrreg-package'></span>

<h3>Description</h3>

<p>Isotonic distributional Regression (IDR) is a nonparametric method to 
estimate conditional distributions under monotonicity constraints.
</p>


<h3>How does it work?</h3>

<p>Read the arXiv preprint &lsquo;Isotonic Distributional Regression&rsquo; on 
<a href="https://arxiv.org/abs/1909.03725">https://arxiv.org/abs/1909.03725</a> or by calling 
<code>browseVignettes(package = "isodistrreg")</code>.
</p>


<h3>The <span class="pkg">isodistrreg</span> package</h3>

<p>To make probabilistic forecasts with IDR,
</p>

<ul>
<li><p> call <code><a href="#topic+idr">idr</a>(y = y, X = X, ...)</code>, where <code>y</code> is the
response variable (e.g. weather variable observations) and <code>X</code> is a
<code>data.frame</code> of covariates (e.g. ensemble forecasts).
</p>
</li>
<li><p> use <code><a href="#topic+predict.idrfit">predict</a>(fit, data)</code>, where <code>fit</code>
is the model fit computed with <code>idr</code> and <code>data</code> is the data based
on which you want to make predictions.
</p>
</li>
<li><p> Try <code><a href="#topic+idrbag">idrbag</a></code> for IDR with (su)bagging.
</p>
</li></ul>

<p>The following pre-defined functions are available to evaluate IDR
predictions:
</p>

<ul>
<li> <p><code><a href="#topic+cdf">cdf</a></code> and <code><a href="#topic+qpred">qpred</a></code> to compute the cumulative
distribution function (CDF) and quantile function of IDR predictions.
</p>
</li>
<li> <p><code><a href="#topic+bscore">bscore</a></code> and <code><a href="#topic+qscore">qscore</a></code> to calculate Brier scores
for probability forecasts for threshold exceedance (e.g. probability of
precipitation) and quantile scores (e.g. mean absolute error of median
forecast.)
</p>
</li>
<li> <p><code><a href="#topic+crps">crps</a></code> to compute the continuous ranked probability score
(CRPS).
</p>
</li>
<li> <p><code><a href="#topic+pit">pit</a></code> to compute the probability integral transform (PIT).
</p>
</li>
<li> <p><code><a href="#topic+plot.idr">plot</a></code> to plot IDR predictive CDFs.
</p>
</li></ul>

<p>Use the dataset <code><a href="#topic+rain">rain</a></code> to test IDR.
</p>


<h3>References</h3>

<p>Alexander Henzi, Johanna F. Ziegel, and Tilmann Gneiting. Isotonic
Distributional Regression. arXiv e-prints, art. arXiv:1909.03725, Sep 2019.
URL <a href="https://arxiv.org/abs/1909.03725">https://arxiv.org/abs/1909.03725</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## A usage example:

# Prepare dataset: Half of the data as training dataset, other half for validation.
# Consult the R documentation (?rain) for details about the dataset.
data(rain)
trainingData &lt;- subset(rain, date &lt;= "2012-01-09")
validationData &lt;- subset(rain, date &gt; "2012-01-09")

# Variable selection: use HRES and the perturbed forecasts P1, ..., P50
varNames &lt;- c("HRES", paste0("P", 1:50))

# Partial orders on variable groups: Usual order of numbers on HRES (group '1') and
# increasing convex order on the remaining variables (group '2').
groups &lt;- setNames(c(1, rep(2, 50)), varNames)
orders &lt;- c("comp" = 1, "icx" = 2)

# Fit IDR to training dataset.
fit &lt;- idr(
  y = trainingData[["obs"]],
  X = trainingData[, varNames],
  groups = groups,
  orders = orders
)

# Make prediction for the first day in the validation data:
firstPrediction &lt;- predict(fit, data = validationData[1, varNames])
plot(firstPrediction)

# Use cdf() and qpred() to make probability and quantile forecasts:

## What is the probability of precipitation?
1 - cdf(firstPrediction, thresholds = 0)

## What are the predicted 10%, 50% and 90% quantiles for precipitation?
qpred(firstPrediction, quantiles = c(0.1, 0.5, 0.9))

# Make predictions for the complete verification dataset and compare IDR calibrated
# forecasts to the raw ensemble (ENS):
predictions &lt;- predict(fit, data = validationData[, varNames])
y &lt;- validationData[["obs"]]

## Continuous ranked probability score (CRPS):
CRPS &lt;- cbind(
  "ens" = crps(validationData[, varNames], y),
  "IDR" = crps(predictions, y)
)
apply(CRPS, 2, mean)

## Brier score for probability of precipitation:
BS &lt;- cbind(
  "ens" = bscore(validationData[, varNames], thresholds = 0, y),
  "IDR" = bscore(predictions, thresholds = 0, y)
)
apply(BS, 2, mean)

## Quantile score of forecast for 90% quantile:
QS90 &lt;- cbind(
  "ens" = qscore(validationData[, varNames], quantiles = 0.9, y),
  "IDR" = qscore(predictions, quantiles = 0.9, y)
)
apply(QS90, 2, mean)

## Check calibration using (randomized) PIT histograms:
pitEns &lt;- pit(validationData[, varNames], y)
pitIdr &lt;- pit(predictions, y)

hist(pitEns, main = "PIT of raw ensemble forecasts", freq = FALSE)
hist(pitIdr, main = "PIT of IDR calibrated forecasts", freq = FALSE)

</code></pre>

<hr>
<h2 id='.onUnload'>Unload dll when package is unloaded</h2><span id='topic+.onUnload'></span>

<h3>Description</h3>

<p>Unload dll when package is unloaded
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.onUnload(libpath)
</code></pre>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>

<hr>
<h2 id='bscore'>Brier score for forecast probability of threshold exceedance</h2><span id='topic+bscore'></span>

<h3>Description</h3>

<p>Computes the Brier score of forecast probabilities for exceeding
given thresholds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bscore(predictions, thresholds, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bscore_+3A_predictions">predictions</code></td>
<td>
<p>either an object of class <code>idr</code> (output of
<code><a href="#topic+predict.idrfit">predict.idrfit</a></code>), or a <code>data.frame</code> of numeric variables.
In the latter case, the CDF is computed using the empirical distribution of
the variables in <code>predictions</code>.</p>
</td></tr>
<tr><td><code id="bscore_+3A_thresholds">thresholds</code></td>
<td>
<p>numeric vector of thresholds at which the CDF will be
evaluated.</p>
</td></tr>
<tr><td><code id="bscore_+3A_y">y</code></td>
<td>
<p>a numeric vector of obervations of the same length as the number of
predictions, or of length 1. In the latter case, <code>y</code> will be used for
all predictions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Brier score for the event of exceeding a given threshold
<em>z</em> is defined as </p>
<p style="text-align: center;"><code class="reqn"> (1\{y &gt; z\} - P(y &gt; z))^2 </code>
</p>
<p> where <em>y</em> is the
observation and <em>P(y &gt; z)</em> the forecast probability for exceeding the
threshold <code>z</code>.
</p>


<h3>Value</h3>

<p>A matrix of the Brier scores for the desired thresholds, one column
per threshold.
</p>


<h3>References</h3>

<p>Gneiting, T. and Raftery, A. E. (2007), 'Strictly proper scoring rules,
prediction, and estimation', Journal of the American Statistical Association
102(477), 359-378
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.idrfit">predict.idrfit</a></code>, <code><a href="#topic+cdf">cdf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("rain")

## Postprocess HRES forecast using data of 3 years

X &lt;- rain[1:(3 * 365), "HRES", drop = FALSE]
y &lt;- rain[1:(3 * 365), "obs"]

fit &lt;- idr(y = y, X = X)

## Compute Brier score for postprocessed probability of precipitation
## forecast using data of the next 2 years (out-of-sample predictions)

data &lt;- rain[(3 * 365 + 1):(5 * 365), "HRES", drop = FALSE]
obs &lt;- rain[(3 * 365 + 1):(5 * 365), "obs"]
predictions &lt;- predict(fit, data = data)
score &lt;- bscore(predictions, thresholds = 0, y = obs)

mean(score)
</code></pre>

<hr>
<h2 id='cdf'>Cumulative distribution function (CDF) of IDR or raw forecasts</h2><span id='topic+cdf'></span><span id='topic+cdf.idr'></span><span id='topic+cdf.data.frame'></span>

<h3>Description</h3>

<p>Evaluate the the cumulative distribution function (CDF) of IDR predictions or
of unprocessed forecasts in a <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdf(predictions, thresholds)

## S3 method for class 'idr'
cdf(predictions, thresholds)

## S3 method for class 'data.frame'
cdf(predictions, thresholds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf_+3A_predictions">predictions</code></td>
<td>
<p>either an object of class <code>idr</code> (output of
<code><a href="#topic+predict.idrfit">predict.idrfit</a></code>), or a <code>data.frame</code> of numeric variables.
In the latter case, the CDF is computed using the empirical distribution of
the variables in <code>predictions</code>.</p>
</td></tr>
<tr><td><code id="cdf_+3A_thresholds">thresholds</code></td>
<td>
<p>numeric vector of thresholds at which the CDF will be
evaluated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The CDFs are considered as piecewise constant stepfunctions: If <code>x</code> are
the points where the IDR fitted CDF (or the empirical distribution of the
forecasts) has jumps and <code>p</code> the corresponding CDF values, then for
<code>x[i] &lt;= x &lt; x[i + 1]</code>, the CDF at <code>x</code> is <code>p[i]</code>.
</p>


<h3>Value</h3>

<p>A matrix of probabilities giving the evaluated CDFs at the given thresholds,
one column for each threshold.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.idrfit">predict.idrfit</a></code> <code><a href="#topic+qpred">qpred</a></code>, <code><a href="#topic+bscore">bscore</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("rain")

## Postprocess HRES forecast using data of 3 years

X &lt;- rain[1:(3 * 365), "HRES", drop = FALSE]
y &lt;- rain[1:(3 * 365), "obs"]

fit &lt;- idr(y = y, X = X)

## Compute probability of precipitation given that the HRES forecast is
## 0 mm, 0.5 mm or 1 mm

predictions &lt;- predict(fit, data = data.frame(HRES = c(0, 0.5, 1)))
1 - cdf(predictions, thresholds = 0)
</code></pre>

<hr>
<h2 id='compOrd'>Componentwise partial order relation</h2><span id='topic+compOrd'></span>

<h3>Description</h3>

<p>Compares all rows of a numeric matrix or data frame <code>X</code>
with respect to the componentwise order. A row <code>X[i, ]</code> is smaller or
equal to a row <code>X[j, ]</code> in the componentwise order, if <code>X[i, k] &lt;=
X[j, k]</code> for <code>k = 1, ..., ncol(X)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compOrd(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compOrd_+3A_x">X</code></td>
<td>
<p>a numeric matrix or a data frame containing numeric or ordered
factor variables with at least two columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The columns of <code>X</code> are sorted sequentially: First all constraints
based on only the first column <code>X[, 1]</code> are activated (set <code>TRUE</code>),
then constraints are dropped based on the orders of the remaining columns.
This avoids <code>nrow(X)^2 / 2</code> pairwise comparisons.
</p>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>paths</code></td>
<td>
<p>a two-column matrix giving all pairs of indices
<code>(i,j)</code> which satisfy <code>all(X[i, ] &lt;= X[j, ])</code>.</p>
</td></tr>
<tr><td><code>colOrder</code></td>
<td>
<p>a matrix of the columnwise orders of <code>X</code>. Used to
compute paths and required for other function calls.</p>
</td></tr>
</table>

<hr>
<h2 id='crps'>Continuous ranked probability score (CRPS)</h2><span id='topic+crps'></span><span id='topic+crps.idr'></span><span id='topic+crps.data.frame'></span>

<h3>Description</h3>

<p>Computes the CRPS of IDR or raw forecasts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crps(predictions, y)

## S3 method for class 'idr'
crps(predictions, y)

## S3 method for class 'data.frame'
crps(predictions, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crps_+3A_predictions">predictions</code></td>
<td>
<p>either an object of class <code>idr</code> (output of
<code><a href="#topic+predict.idrfit">predict.idrfit</a></code>), or a <code>data.frame</code> of numeric variables. In
the latter case, the CRPS is computed using the empirical distribution of
the variables in <code>predictions</code>.</p>
</td></tr>
<tr><td><code id="crps_+3A_y">y</code></td>
<td>
<p>a numeric vector of obervations of the same length as the number of
predictions, or of length 1. In the latter case, <code>y</code> will be used for
all predictions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses adapted code taken from the function <code>crps_edf</code> of
the <span class="pkg">scoringRules</span> package.
</p>


<h3>Value</h3>

<p>A vector of CRPS values.
</p>


<h3>References</h3>

<p>Jordan A., Krueger F., Lerch S. (2018). &quot;Evaluating Probabilistic
Forecasts with scoringRules.&quot; Journal of Statistical Software. Forthcoming.
</p>
<p>Gneiting, T. and Raftery, A. E. (2007), 'Strictly proper scoring rules,
prediction, and estimation', Journal of the American Statistical Association
102(477), 359-378
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.idrfit">predict.idrfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("rain")

## Postprocess HRES forecast using data of 3 years

X &lt;- rain[1:(3 * 365), "HRES", drop = FALSE]
y &lt;- rain[1:(3 * 365), "obs"]

fit &lt;- idr(y = y, X = X)

## Compute CRPS of postprocessed HRES forecast using data of the next 2 years
## (out-of-sample predictions)

data &lt;- rain[(3 * 365 + 1):(5 * 365), "HRES", drop = FALSE]
obs &lt;- rain[(3 * 365 + 1):(5 * 365), "obs"]
predictions &lt;- predict(fit, data = data)
idrCrps &lt;- crps(predictions, y = obs)

## Compare this to CRPS of the raw ensemble of all forecasts (high resolution,
## control and 50 perturbed ensemble forecasts)

rawData &lt;- rain[(3 * 365 + 1):(5 * 365), c("HRES", "CTR", paste0("P", 1:50))]
rawCrps &lt;- crps(rawData, y = obs)

c("idr_HRES" = mean(idrCrps), "raw_all" = mean(rawCrps))
</code></pre>

<hr>
<h2 id='dindexm'>Distributional index model (DIM)</h2><span id='topic+dindexm'></span>

<h3>Description</h3>

<p>Fits distributional index model with user-specified index
function to training dataset. See the examples at the bottom to learn
how to specify a distributional single index model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dindexm(
  formula,
  indexfit,
  data,
  response,
  pars = osqpSettings(verbose = FALSE, eps_abs = 1e-05, eps_rel = 1e-05, max_iter =
    10000L),
  progress = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dindexm_+3A_formula">formula</code></td>
<td>
<p>object of class <code>formula</code> that describes the index 
model</p>
</td></tr>
<tr><td><code id="dindexm_+3A_indexfit">indexfit</code></td>
<td>
<p>function that fits the index model to training data. Should
accept arguments <code>formula</code> and <code>data</code> and admit a <code>predict</code>
method. Further arguments in <code>...</code> are passed to indexfit.
See examples.</p>
</td></tr>
<tr><td><code id="dindexm_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing the covariates of the index model
and the response variable.</p>
</td></tr>
<tr><td><code id="dindexm_+3A_response">response</code></td>
<td>
<p>name of the response variable in <code>data</code>.</p>
</td></tr>
<tr><td><code id="dindexm_+3A_pars">pars</code></td>
<td>
<p>parameters for quadratic programming optimization (only relevant
for multivariate index functions), set using
<code><a href="osqp.html#topic+osqpSettings">osqpSettings</a></code>.</p>
</td></tr>
<tr><td><code id="dindexm_+3A_progress">progress</code></td>
<td>
<p>display progressbar for fitting idr?</p>
</td></tr>
<tr><td><code id="dindexm_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>indexfit</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a distributional index model (DIM) to training data. The
DIM assumes that the response is more likely to attain higher values when the
values of the index function increases. The index function can be
estimated by parametric methods like <code><a href="stats.html#topic+lm">lm</a></code> or 
<code><a href="stats.html#topic+glm">glm</a></code> or also nonparametrically.
</p>
<p>The formal mathematical assumption of the DIM is that the conditional CDFs
<code class="reqn">F_{y | g(X) = g(x)}(z)</code> at each fixed threshold <em>z</em> decreases, as
<em>g(x)</em> increases. Here <code>y</code> denotes the response, <code>x</code>, <code>X</code>
are the covariates in <code>data</code> and <code>g</code> is the index function
estimated by <code>indexfit</code>.
</p>
<p>Estimation is performed in two steps: <code>indexfit</code> is applied to 
<code>data</code> to estimate the function <code>g</code>. With this estimate,
<code><a href="#topic+idr">idr</a></code> is applied with the pseudo-covariates <code>g(x)</code> and
response <code>y</code>.
</p>


<h3>Value</h3>

<p>Object of class <code>dindexm</code>: A list containing the index model (first
component) and the IDR fit on the pseudo-data with the index as covariate
(second component).
</p>


<h3>References</h3>

<p>Henzi, A., Kleger, G. R., &amp; Ziegel, J. F. (2020). Distributional (Single)
Index Models. arXiv preprint arXiv:2006.09219.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+idr">idr</a></code> for more information on IDR,
<code><a href="#topic+predict.dindexfit">predict.dindexfit</a></code> for (out-of-sample) predictions based on a
model with with <code>dindexm</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 1000
X &lt;- data.frame(x1 = rnorm(n), x2 = rnorm(n), x3 = rnorm(n))
y &lt;- rnorm(n, 1 - X[, 1] + X[, 2]^2 / 3 - (1 - X[, 3]) * (1 + X[, 3]) / 2)
data &lt;- cbind(y = y, as.data.frame(X))

## data for out-of-sample prediction
newX &lt;- data.frame(x1 = rnorm(10), x2 = rnorm(10), x3 = rnorm(10))

## linear regression model for index
model &lt;- dindexm(
  formula = y ~ poly(x1, degree = 2) + poly(x2, degree = 2) + 
    poly(x3, degree = 2),
  indexfit = lm,
  response = "y",
  data = data
)
pred &lt;- predict(model, data = newX)

## plot
plot(pred, 1, main = "LM based DIM")
grd &lt;- pred[[1]]$points
trueCdf &lt;- pnorm(
  grd,
  1 - newX[1, 1] + newX[1, 2]^2 / 3 - (1 - newX[1, 3]) * (1 + newX[1, 3]) / 2
)
points(grd, trueCdf, type = "l", col = 2)
</code></pre>

<hr>
<h2 id='idr'>Fit IDR to training data</h2><span id='topic+idr'></span>

<h3>Description</h3>

<p>Fits isotonic distributional regression (IDR) to a training
dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idr(y, X, groups = setNames(rep(1, ncol(X)), colnames(X)), orders =
  c("comp" = 1), stoch = "sd", pars = osqpSettings(verbose = FALSE, eps_abs =
  1e-5, eps_rel = 1e-5, max_iter = 10000L), progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idr_+3A_y">y</code></td>
<td>
<p>numeric vector (the response variable).</p>
</td></tr>
<tr><td><code id="idr_+3A_x">X</code></td>
<td>
<p>data frame of numeric or ordered factor variables (the regression
covariates).</p>
</td></tr>
<tr><td><code id="idr_+3A_groups">groups</code></td>
<td>
<p>named vector of length <code>ncol(X)</code> denoting groups of
variables that are to be ordered with the same order (see 'Details'). Only
relevant if <code>X</code> contains more than one variable. The same names as in
<code>X</code> should be used.</p>
</td></tr>
<tr><td><code id="idr_+3A_orders">orders</code></td>
<td>
<p>named vector giving for each group in <code>groups</code> the order
that will be applied to this group. Only relevant if <code>X</code> contains more
than one variable. The names of <code>orders</code> give the order, the entries
give the group labels. Available options: <code>"comp"</code> for componentwise
order, <code>"sd"</code> for stochastic dominance, <code>"icx"</code> for increasing
convex order (see 'Details). Default is <code>"comp"</code> for all variables.
The <code>"sd"</code> and <code>"icx"</code> orders can only be used with numeric
variables, but not with ordered factors.</p>
</td></tr>
<tr><td><code id="idr_+3A_stoch">stoch</code></td>
<td>
<p>stochastic order constraint used for estimation. Default is
<code>"sd"</code> for first order stochastic dominance. Use <code>"hazard"</code> for
hazard rate order (experimental).</p>
</td></tr>
<tr><td><code id="idr_+3A_pars">pars</code></td>
<td>
<p>parameters for quadratic programming optimization (only relevant
if <code>X</code> has more than one column), set using
<code><a href="osqp.html#topic+osqpSettings">osqpSettings</a></code>.</p>
</td></tr>
<tr><td><code id="idr_+3A_progress">progress</code></td>
<td>
<p>display progressbar (<code>TRUE</code>, <code>FALSE</code> or <code>1</code>,
<code>0</code>)?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the isotonic distributional regression (IDR)
of a response <em>y</em> on on one or more covariates <em>X</em>. IDR estimates
the cumulative distribution function (CDF) of <em>y</em> conditional on
<em>X</em> by monotone regression, assuming that <em>y</em> is more likely to
take higher values, as <em>X</em> increases. Formally, IDR assumes that the
conditional CDF <code class="reqn">F_{y | X = x}(z)</code> at each fixed threshold <em>z</em>
decreases, as <em>x</em> increases, or equivalently, that the exceedance
probabilities for any threshold <code>z</code> <code class="reqn">P(y &gt; z | X = x)</code> increase
with <em>x</em>.
</p>
<p>The conditional CDFs are estimated at each threshold in <code>unique(y)</code>.
This is the set where the CDFs may have jumps. If <code>X</code> contains more
than one variable, the CDFs are estimated by calling
<code><a href="osqp.html#topic+solve_osqp">solve_osqp</a></code> from the package <span class="pkg">osqp</span>
<code>length(unique(y))</code> times. This might take a while if the training
dataset is large.
</p>
<p>Use the argument <code>groups</code> to group <em>exchangeable</em> covariates.
Exchangeable covariates are indistinguishable except from the order in
which they are labelled (e.g. ensemble weather forecasts, repeated
measurements under the same measurement conditions).
</p>
<p>The following orders are available to perform the monotone regression in
IDR: </p>
 <ul>
<li><p> Componentwise order (<code>"comp"</code>): A covariate
vector <code>x1</code> is greater than <code>x2</code> if <code>x1[i] &gt;= x2[i]</code> holds
for all components <code>i</code>. This is the <em>standard order used in
multivariate monotone regression</em> and <em>should not be used for
exchangeable variables (e.g. perturbed ensemble forecasts)</em>. </p>
</li>
<li>
<p>Stochastic dominance (<code>"sd"</code>): <code>x1</code> is greater than <code>x2</code> in
the stochastic order, if the (empirical) distribution of the elements of
<code>x1</code> is greater than the distribution of the elements of <code>x2</code> (in
first order) stochastic dominance. The <code>"sd"</code> order is invariant under
permutations of the grouped variables and therefore <em>suitable for
exchangeable covariables</em>. </p>
</li>
<li><p> Increasing convex order (<code>"icx"</code>):
The <code>"icx"</code> order can be used for groups of exchangeable variables. It
should be used if the variables have increasing variability, when their
mean increases (e.g. precipitation forecasts or other variables with
right-skewed distributions). More precisely, <code>"icx"</code> uses the
increasing convex stochastic order on the empirical distributions of the
grouped variables. </p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>"idrfit"</code> containing the following
components:
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>data frame of all distinct covariate combinations used for
the fit.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>list of all observed responses in the training data for
given covariate combinations in <code>X</code>.</p>
</td></tr>
<tr><td><code>cdf</code></td>
<td>
<p>matrix containing the estimated CDFs, one CDF per row,
evaluated at <code>thresholds</code> (see next point). The CDF in the <code>i</code>th
row corredponds to the estimated conditional distribution of the response
given the covariates values in <code>X[i,]</code>.</p>
</td></tr>
<tr><td><code>thresholds</code></td>
<td>
<p>the thresholds at which the CDFs in <code>cdf</code> are
evaluated. The entries in <code>cdf[,j]</code> are the conditional CDFs evaluated
at <code>thresholds[j]</code>.</p>
</td></tr>
<tr><td><code>groups</code>, <code>orders</code></td>
<td>
<p> the groups and orders used for
estimation.</p>
</td></tr>
<tr><td><code>diagnostic</code></td>
<td>
<p>list giving a bound on the precision of the CDF
estimation (the maximal downwards-step in the CDF that has been detected)
and the fraction of CDF estimations that were stopped at the iteration
limit <code>max_iter</code>. Decrease the parameters <code>eps_abs</code> and/or
<code>eps_rel</code> or increase <code>max_iter</code> in <code>pars</code> to improve the
precision. See <code><a href="osqp.html#topic+osqpSettings">osqpSettings</a></code> for more optimization
parameters.</p>
</td></tr>
<tr><td><code>indices</code></td>
<td>
<p> the row indices of the covariates in <code>X</code> in the
original training dataset (used for in-sample predictions with
<code><a href="#topic+predict.idrfit">predict.idrfit</a></code>).</p>
</td></tr>
<tr><td><code>constraints</code></td>
<td>
<p> (in multivariate IDR, <code>NULL</code> otherwise)
matrices giving the order constraints for optimization. Used in
<code><a href="#topic+predict.idrfit">predict.idrfit</a></code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function <code>idr</code> is only intended for fitting IDR model for a
training dataset and storing the results for further processing, but not
for prediction or evaluation, which is done using the output of
<code><a href="#topic+predict.idrfit">predict.idrfit</a></code>.
</p>


<h3>Author(s)</h3>

<p>Code for the Pool-Adjacent Violators Algorithm (PAVA) is adapted from 
R code by Lutz Duembgen (available on
<a href="https://www.imsv.unibe.ch/about_us/files/lutz_duembgen/software/index_eng.html">https://www.imsv.unibe.ch/about_us/files/lutz_duembgen/software/index_eng.html</a>).
</p>


<h3>References</h3>

<p>Henzi, A., Moesching, A., &amp; Duembgen, L. (2020). Accelerating the
pool-adjacent-violators algorithm for isotonic distributional regression.
arXiv preprint arXiv:2006.05527.
</p>
<p>Stellato, B., Banjac, G., Goulart, P., Bemporad, A., &amp; Boyd, S. (2020).
OSQP: An operator splitting solver for quadratic programs. Mathematical
Programming Computation, 1-36.
</p>
<p>Bartolomeo Stellato, Goran Banjac, Paul Goulart and Stephen Boyd (2019).
osqp: Quadratic Programming Solver using the 'OSQP' Library. R package
version 0.6.0.3. https://CRAN.R-project.org/package=osqp
</p>


<h3>See Also</h3>

<p>The S3 method <code><a href="#topic+predict.idrfit">predict.idrfit</a></code> for predictions based on
an IDR fit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("rain")

## Fit IDR to data of 185 days using componentwise order on HRES and CTR and
## increasing convex order on perturbed ensemble forecasts (P1, P2, ..., P50)

varNames &lt;- c("HRES", "CTR", paste0("P", 1:50))
X &lt;- rain[1:185, varNames]
y &lt;- rain[1:185, "obs"]

## HRES and CTR are group '1', with componentwise order "comp", perturbed
## forecasts P1, ..., P50 are group '2', with "icx" order

groups &lt;- setNames(c(1, 1, rep(2, 50)), varNames)
orders &lt;- c("comp" = 1, "icx" = 2)

fit &lt;- idr(y = y, X = X, orders = orders, groups = groups)
fit
</code></pre>

<hr>
<h2 id='idrbag'>Compute IDR predictions with (su)bagging</h2><span id='topic+idrbag'></span>

<h3>Description</h3>

<p>Computes IDR predictions with bootstrap aggregating (bagging)
or subsample aggregation (subagging).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idrbag(y, X, groups = setNames(rep(1, ncol(X)), colnames(X)), orders =
  c("comp" = 1), stoch = "sd", pars = osqpSettings(verbose = FALSE, eps_abs =
  1e-5, eps_rel = 1e-5, max_iter = 10000L), progress = TRUE, newdata, 
  digits = 3, interpolation = "linear", b, p, replace = FALSE, grid = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idrbag_+3A_y">y</code></td>
<td>
<p>numeric vector (the response variable).</p>
</td></tr>
<tr><td><code id="idrbag_+3A_x">X</code></td>
<td>
<p>data frame of numeric or ordered factor variables (the regression
covariates).</p>
</td></tr>
<tr><td><code id="idrbag_+3A_groups">groups</code></td>
<td>
<p>named vector of length <code>ncol(X)</code> denoting groups of
variables that are to be ordered with the same order (see 'Details'). Only
relevant if <code>X</code> contains more than one variable. The same names as in
<code>X</code> should be used.</p>
</td></tr>
<tr><td><code id="idrbag_+3A_orders">orders</code></td>
<td>
<p>named vector giving for each group in <code>groups</code> the order
that will be applied to this group. Only relevant if <code>X</code> contains more
than one variable. The names of <code>orders</code> give the order, the entries
give the group labels. Available options: <code>"comp"</code> for componentwise
order, <code>"sd"</code> for stochastic dominance, <code>"icx"</code> for increasing
convex order (see 'Details). Default is <code>"comp"</code> for all variables.
The <code>"sd"</code> and <code>"icx"</code> orders can only be used with numeric
variables, but not with ordered factors.</p>
</td></tr>
<tr><td><code id="idrbag_+3A_stoch">stoch</code></td>
<td>
<p>stochastic order constraint used for estimation. Default is
<code>"sd"</code> for first order stochastic dominance. Use <code>"hazard"</code> for
hazard rate order (experimental).</p>
</td></tr>
<tr><td><code id="idrbag_+3A_pars">pars</code></td>
<td>
<p>parameters for quadratic programming optimization (only relevant
if <code>X</code> has more than one column), set using
<code><a href="osqp.html#topic+osqpSettings">osqpSettings</a></code>.</p>
</td></tr>
<tr><td><code id="idrbag_+3A_progress">progress</code></td>
<td>
<p>display progressbar (<code>TRUE</code>, <code>FALSE</code> or <code>1</code>,
<code>0</code>)?</p>
</td></tr>
<tr><td><code id="idrbag_+3A_newdata">newdata</code></td>
<td>
<p><code>data.frame</code> containing variables with which to
predict. Ordered factor variables are converted to numeric for computation,
so ensure that the factor levels are identical in <code>newdata</code> and in
<code>X</code>.</p>
</td></tr>
<tr><td><code id="idrbag_+3A_digits">digits</code></td>
<td>
<p>number of decimal places for the predictive CDF.</p>
</td></tr>
<tr><td><code id="idrbag_+3A_interpolation">interpolation</code></td>
<td>
<p>interpolation method for univariate data. Default is 
<code>"linear"</code>. Any other argument will select midpoint interpolation (see 
'Details' in <code><a href="#topic+predict.idrfit">predict.idrfit</a></code>). Has no effect for multivariate
IDR.</p>
</td></tr>
<tr><td><code id="idrbag_+3A_b">b</code></td>
<td>
<p>number of (su)bagging samples.</p>
</td></tr>
<tr><td><code id="idrbag_+3A_p">p</code></td>
<td>
<p>size of (su)bagging samples relative to training data.</p>
</td></tr>
<tr><td><code id="idrbag_+3A_replace">replace</code></td>
<td>
<p>draw samples with (<code>TRUE</code>, <code>1</code>) or without
(<code>FALSE</code>, <code>0</code>) replacement?</p>
</td></tr>
<tr><td><code id="idrbag_+3A_grid">grid</code></td>
<td>
<p>grid on which the predictive CDFs are evaluated. Default are
the unique values of <code>y</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function draws <code>b</code> times a random subsample of size
<code>ceiling(nrow(X)*p)</code>) from the training data, fits IDR to each
subsample, computes predictions for the new data supplied in <code>newdata</code>,
and averages the predictions derived from the <code>b</code> subsamples. There are
no default values for <code>b</code> and <code>p</code>.
</p>


<h3>Value</h3>

<p>A list of predictions, see <code><a href="#topic+predict.idrfit">predict.idrfit</a></code>.
</p>

<hr>
<h2 id='multivHazardLoop'>Loop for multivariate estimation under hazard ratio ordering (experimental,
will possibly me modified)</h2><span id='topic+multivHazardLoop'></span>

<h3>Description</h3>

<p>Loop for multivariate estimation under hazard ratio ordering (experimental,
will possibly me modified)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multivHazardLoop(X, thresholds, nThr, weights, cpY, pars)
</code></pre>


<h3>Value</h3>

<p>A list containing the estimated conditional CDFs, estimation diagnostics,
and the constraint matrices for estimation.
</p>

<hr>
<h2 id='neighborPoints'>Neighbor points with respect to componentwise order</h2><span id='topic+neighborPoints'></span>

<h3>Description</h3>

<p>Find the neighbor points of the rows of a matrix <code>x</code> within
the rows of <code>X</code> in the componentwise partial order. That is, for each
row <code>x[i, ]</code>, find all indices <code>k</code> such that either <code>x[i, ] &gt;=
X[k, ]</code> in all components and <code>x[i, ] &gt;= X[j, ] &gt;= X[k, ]</code> holds for no
<code>j</code> different from <code>k</code>, or <code>x[i, ] &lt;= X[k, ]</code> in all
components and <code>x[i ,] &lt;= X[j, ] &lt;= X[k, ]</code> holds for no <code>j</code>
different from <code>k</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighborPoints(x, X, orderX)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neighborPoints_+3A_x">x</code></td>
<td>
<p>numeric matrix with at least two columns.</p>
</td></tr>
<tr><td><code id="neighborPoints_+3A_x">X</code></td>
<td>
<p>numeric matrix with same number of columns as <code>x</code>.</p>
</td></tr>
<tr><td><code id="neighborPoints_+3A_orderx">orderX</code></td>
<td>
<p>output of <code>compOrd(X)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Lists of length <code>nrow(x)</code> giving for each <code>x[i, ]</code> the indices
of the smaller and the greater neighbor points within the rows of <code>X</code>.
</p>

<hr>
<h2 id='pit'>Probability integral transform (PIT)</h2><span id='topic+pit'></span><span id='topic+pit.idr'></span><span id='topic+pit.data.frame'></span>

<h3>Description</h3>

<p>Computes the probability integral transform (PIT) of IDR or raw
forecasts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pit(predictions, y, randomize = TRUE, seed = NULL)

## S3 method for class 'idr'
pit(predictions, y, randomize = TRUE, seed = NULL)

## S3 method for class 'data.frame'
pit(predictions, y, randomize = TRUE, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pit_+3A_predictions">predictions</code></td>
<td>
<p>either an object of class <code>idr</code> (output of
<code><a href="#topic+predict.idrfit">predict.idrfit</a></code>), or a <code>data.frame</code> of numeric variables. In
the latter case, the PIT is computed using the empirical distribution of
the variables in <code>predictions</code>.</p>
</td></tr>
<tr><td><code id="pit_+3A_y">y</code></td>
<td>
<p>a numeric vector of obervations of the same length as the number of
predictions.</p>
</td></tr>
<tr><td><code id="pit_+3A_randomize">randomize</code></td>
<td>
<p>PIT values should be randomized at discontinuity points of the
predictive CDF (e.g. at zero for precipitation forecasts). Set <code>
randomize = TRUE</code> to randomize.</p>
</td></tr>
<tr><td><code id="pit_+3A_seed">seed</code></td>
<td>
<p>argument to <code>set.seed</code> for random number generation (if
<code>randomize</code> is <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of PIT values.
</p>


<h3>References</h3>

<p>Gneiting, T., Balabdaoui, F. and Raftery, A. E. (2007), 'Probabilistic
forecasts, calibration and sharpness', Journal of the Royal Statistical
Society: Series B (Statistical Methodology) 69(2), 243-268.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.idrfit">predict.idrfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("rain")
require("graphics")

## Postprocess HRES forecast using data of 4 years

X &lt;- rain[1:(4 * 365), "HRES", drop = FALSE]
y &lt;- rain[1:(4 * 365), "obs"]

fit &lt;- idr(y = y, X = X)

## Assess calibration of the postprocessed HRES forecast using data of next 4
## years and compare to calibration of the raw ensemble

data &lt;- rain[(4 * 365 + 1):(8 * 365), "HRES", drop = FALSE]
obs &lt;- rain[(4 * 365 + 1):(8 * 365), "obs"]
predictions &lt;- predict(fit, data = data)
idrPit &lt;- pit(predictions, obs, seed = 123)

rawData &lt;- rain[(4 * 365 + 1):(8 * 365), c("HRES", "CTR", paste0("P", 1:50))]
rawPit &lt;- pit(rawData, obs, seed = 123)

hist(idrPit, xlab = "Probability Integral Transform",
  ylab = "Density", freq = FALSE, main = "Postprocessed HRES")
hist(rawPit, xlab = "Probability Integral Transform",
  ylab = "Density", freq = FALSE, main = "Raw ensemble")
</code></pre>

<hr>
<h2 id='plot.idr'>Plot IDR predictions</h2><span id='topic+plot.idr'></span>

<h3>Description</h3>

<p>Plot an IDR predictive CDF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'idr'
plot(
  x,
  index = 1,
  bounds = TRUE,
  col.cdf = "black",
  col.bounds = "blue",
  lty.cdf = 1,
  lty.bounds = 3,
  xlab = "Threshold",
  ylab = "CDF",
  main = "IDR predictive CDF",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.idr_+3A_x">x</code></td>
<td>
<p>object of class <code>idr</code> (output of
<code><a href="#topic+predict.idrfit">predict.idrfit</a></code>).</p>
</td></tr>
<tr><td><code id="plot.idr_+3A_index">index</code></td>
<td>
<p>index of the prediction in <code>x</code> for which a plot is desired.</p>
</td></tr>
<tr><td><code id="plot.idr_+3A_bounds">bounds</code></td>
<td>
<p>whether the bounds should be plotted or not (see
<code><a href="#topic+predict.idrfit">predict.idrfit</a></code> for details about the meaning of the bounds).</p>
</td></tr>
<tr><td><code id="plot.idr_+3A_col.cdf">col.cdf</code></td>
<td>
<p>color of the predictive CDF.</p>
</td></tr>
<tr><td><code id="plot.idr_+3A_col.bounds">col.bounds</code></td>
<td>
<p>color of the bounds.</p>
</td></tr>
<tr><td><code id="plot.idr_+3A_lty.cdf">lty.cdf</code></td>
<td>
<p>linetype of the predictive CDF.</p>
</td></tr>
<tr><td><code id="plot.idr_+3A_lty.bounds">lty.bounds</code></td>
<td>
<p>linetype of the CDF bounds.</p>
</td></tr>
<tr><td><code id="plot.idr_+3A_xlab">xlab</code></td>
<td>
<p>label for x axis.</p>
</td></tr>
<tr><td><code id="plot.idr_+3A_ylab">ylab</code></td>
<td>
<p>label for y axis.</p>
</td></tr>
<tr><td><code id="plot.idr_+3A_main">main</code></td>
<td>
<p>main title.</p>
</td></tr>
<tr><td><code id="plot.idr_+3A_...">...</code></td>
<td>
<p>further arguments to <code><a href="stats.html#topic+plot.stepfun">plot.stepfun</a></code> or
<code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data based on which the plot is drawn (returned invisible).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.idrfit">predict.idrfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("rain")
require("graphics")

## Postprocess HRES and CTR forecast using data of 2 years

X &lt;- rain[1:(2 * 365), c("HRES", "CTR"), drop = FALSE]
y &lt;- rain[1:(2 * 365), "obs"]

## Fit IDR and plot the predictive CDF when the HRES forecast is 1 mm and
## CTR is 0 mm

fit &lt;- idr(y = y, X = X)
pred &lt;- predict(fit, data = data.frame(HRES = 1, CTR = 0))
plot(pred)
</code></pre>

<hr>
<h2 id='predict.dindexfit'>Predict method for distributional index model (DIM)</h2><span id='topic+predict.dindexfit'></span>

<h3>Description</h3>

<p>Prediction based on distributional index model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dindexfit'
predict(
  object,
  data = NULL,
  digits = 3,
  interpolation = "linear",
  asplitAvail = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.dindexfit_+3A_object">object</code></td>
<td>
<p>DIM fit (object of class <code>"dindexfit"</code>).</p>
</td></tr>
<tr><td><code id="predict.dindexfit_+3A_data">data</code></td>
<td>
<p>optional <code>data.frame</code> containing variables with which to
predict. In-sample predictions are returned if this is omitted.</p>
</td></tr>
<tr><td><code id="predict.dindexfit_+3A_digits">digits</code></td>
<td>
<p>number of decimal places for the predictive CDF.</p>
</td></tr>
<tr><td><code id="predict.dindexfit_+3A_interpolation">interpolation</code></td>
<td>
<p>interpolation method for univariate index Default is 
<code>"linear"</code>. Any other argument will select midpoint interpolation (see 
'Details' in <code><a href="#topic+predict.idrfit">predict.idrfit</a></code>). Has no effect for multivariate
index function.</p>
</td></tr>
<tr><td><code id="predict.dindexfit_+3A_asplitavail">asplitAvail</code></td>
<td>
<p>use <code><a href="base.html#topic+asplit">asplit</a></code> for splitting arrays
(default is <code>TRUE</code>). Set to <code>FALSE</code> for R Versions &lt; 3.6, where
<code>asplit</code> is not available.</p>
</td></tr>
<tr><td><code id="predict.dindexfit_+3A_...">...</code></td>
<td>
<p>further arguments passed to the index prediction function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of predictions, as for <code><a href="#topic+predict.idrfit">predict.idrfit</a></code>.
</p>


<h3>See Also</h3>

<p>Examples in <code><a href="#topic+dindexm">dindexm</a></code>.
</p>

<hr>
<h2 id='predict.idrfit'>Predict method for IDR fits</h2><span id='topic+predict.idrfit'></span>

<h3>Description</h3>

<p>Prediction based on IDR model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'idrfit'
predict(object, data = NULL, digits = 3, interpolation = "linear", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.idrfit_+3A_object">object</code></td>
<td>
<p>IDR fit (object of class <code>"idrfit"</code>).</p>
</td></tr>
<tr><td><code id="predict.idrfit_+3A_data">data</code></td>
<td>
<p>optional <code>data.frame</code> containing variables with which to
predict. In-sample predictions are returned if this is omitted. Ordered 
factor variables are converted to numeric for computation, so ensure that 
the factor levels are identical in <code>data</code> and the training data for
<code>fit</code>.</p>
</td></tr>
<tr><td><code id="predict.idrfit_+3A_digits">digits</code></td>
<td>
<p>number of decimal places for the predictive CDF.</p>
</td></tr>
<tr><td><code id="predict.idrfit_+3A_interpolation">interpolation</code></td>
<td>
<p>interpolation method for univariate data. Default is 
<code>"linear"</code>. Any other argument will select midpoint interpolation (see 
'Details'). Has no effect for multivariate IDR.</p>
</td></tr>
<tr><td><code id="predict.idrfit_+3A_...">...</code></td>
<td>
<p>included for generic function consistency.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the variables <code>x = data[j,]</code> for which predictions are
desired are already contained in the training dataset <code>X</code> for the fit,
<code>predict.idrfit</code> returns the corresponding in-sample prediction.
Otherwise monotonicity is used to derive upper and lower bounds for the
predictive CDF, and the predictive CDF is a pointwise average of these
bounds. For univariate IDR with a numeric covariate, the predictive CDF is
computed by linear interpolation. Otherwise, or if 
<code>interpolation != "linear"</code>, midpoint interpolation is used, i.e.
default weights of <code>0.5</code> for both the lower and the upper bound.
</p>
<p>If the lower and the upper bound on the predictive cdf are far apart (or
trivial, i.e. constant 0 or constant 1), this indicates that the prediction
based on <code>x</code> is uncertain because either the training dataset is too
small or only few similar variable combinations as in <code>x</code> have been
observed in the training data. However, <em>the bounds on the predictive
CDF are not prediction intervals and should not be interpreted as such. They
only indicate the uncertainty of out-of-sample predictions for which the
variables are not contained in the training data.</em>
</p>
<p>If the new variables <code>x</code> are greater than all <code>X[i, ]</code> in the
selected order(s), the lower bound on the cdf is trivial (constant 0) and the
upper bound is taken as predictive cdf. The upper bound on the cdf is trivial
(constant 1) if <code>x</code> is smaller than all <code>X[i, ]</code>. If <code>x</code> is
not comparable to any row of <code>X</code> in the given order, a prediction based
on the training data is not possible. In that case, the default forecast is
the empirical distribution of <code>y</code> in the training data.
</p>


<h3>Value</h3>

<p>A list of predictions. Each prediction is a <code>data.frame</code>
containing the following variables:
</p>
<table>
<tr><td><code>points</code></td>
<td>
<p>the points where the predictive CDF has jumps.</p>
</td></tr>
<tr><td><code>cdf</code></td>
<td>
<p>the estimated CDF evaluated at the <code>points</code>.</p>
</td></tr>
<tr><td><code>lower</code>, <code>upper</code></td>
<td>
<p> (only for out-of-sample predictions)
bounds for the estimated CDF, see 'Details' above.</p>
</td></tr>
</table>
<p>The output has the attribute <code>incomparables</code>, which gives the indices
of all predictions for which the climatological forecast is returned because
the forecast variables are not comparable to the training data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+idr">idr</a></code> to fit IDR to training data.
</p>
<p><code><a href="#topic+cdf">cdf</a></code>, <code><a href="#topic+qpred">qpred</a></code> to evaluate the CDF or quantile
function of IDR predictions.
</p>
<p><code><a href="#topic+bscore">bscore</a></code>, <code><a href="#topic+qscore">qscore</a></code>, <code><a href="#topic+crps">crps</a></code>,
<code><a href="#topic+pit">pit</a></code> to compute Brier scores, quantile scores, the CRPS and the
PIT of IDR predictions.
</p>
<p><code><a href="#topic+plot.idr">plot</a></code> to plot IDR predictive CDFs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("rain")

## Fit IDR to data of 185 days using componentwise order on HRES and CTR and
## increasing convex order on perturbed ensemble forecasts (P1, P2, ..., P50)

varNames &lt;- c("HRES", "CTR", paste0("P", 1:50))
X &lt;- rain[1:185, varNames]
y &lt;- rain[1:185, "obs"]

## HRES and CTR are group '1', with componentwise order "comp", perturbed
## forecasts P1, ..., P50 are group '2', with "icx" order

groups &lt;- setNames(c(1, 1, rep(2, 50)), varNames)
orders &lt;- c("comp" = 1, "icx" = 2)

fit &lt;- idr(y = y, X = X, orders = orders, groups = groups)

## Predict for day 186
predict(fit, data = rain[186, varNames])
</code></pre>

<hr>
<h2 id='prepareData'>Prepare data for IDR modeling with given orders</h2><span id='topic+prepareData'></span>

<h3>Description</h3>

<p>Prepare data for IDR modeling with given orders
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepareData(X, groups, orders)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepareData_+3A_x">X</code></td>
<td>
<p><code>data.frame</code> of covariates.</p>
</td></tr>
<tr><td><code id="prepareData_+3A_groups">groups</code></td>
<td>
<p>vector of groups.</p>
</td></tr>
<tr><td><code id="prepareData_+3A_orders">orders</code></td>
<td>
<p>named vector of orders for groups.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Transformed data <code>X</code> with covariates modified according to the given
order.
</p>

<hr>
<h2 id='qpred'>Quantile function of IDR or raw forecasts</h2><span id='topic+qpred'></span><span id='topic+qpred.idr'></span><span id='topic+qpred.data.frame'></span>

<h3>Description</h3>

<p>Evaluate the the quantile function of IDR predictions or of unprocessed
forecasts in a <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qpred(predictions, quantiles)

## S3 method for class 'idr'
qpred(predictions, quantiles)

## S3 method for class 'data.frame'
qpred(predictions, quantiles)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qpred_+3A_predictions">predictions</code></td>
<td>
<p>either an object of class <code>idr</code> (output of
<code><a href="#topic+predict.idrfit">predict.idrfit</a></code>), or a <code>data.frame</code> of numeric variables. In
the latter case, quantiles are computed using the empirical distribution of
the variables in <code>predictions</code>.</p>
</td></tr>
<tr><td><code id="qpred_+3A_quantiles">quantiles</code></td>
<td>
<p>numeric vector of desired quantiles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The quantiles are defined as lower quantiles, that is,
</p>
<p style="text-align: center;"><code class="reqn">
  q(u) = inf(x: cdf(x) &gt;= u).
</code>
</p>



<h3>Value</h3>

<p>A matrix of forecasts for the desired quantiles, one column per quantile.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.idrfit">predict.idrfit</a></code>, <code><a href="#topic+cdf">cdf</a></code>, <code><a href="#topic+qscore">qscore</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("rain")

## Postprocess HRES forecast using data of 3 years

X &lt;- rain[1:(3 * 365), "HRES", drop = FALSE]
y &lt;- rain[1:(3 * 365), "obs"]

fit &lt;- idr(y = y, X = X)

## Compute 95%-quantile forecast given that the HRES forecast is
## 2.5 mm, 5 mm or 10 mm

predictions &lt;- predict(fit, data = data.frame(HRES = c(2.5, 5, 10)))
qpred(predictions, quantiles = 0.95)
</code></pre>

<hr>
<h2 id='qscore'>Quantile scores for IDR or raw forecasts</h2><span id='topic+qscore'></span>

<h3>Description</h3>

<p>Computes quantile scores of IDR quantile predictions or of quantile
predictions from raw forecasts in a <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qscore(predictions, quantiles, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qscore_+3A_predictions">predictions</code></td>
<td>
<p>either an object of class <code>idr</code> (output of
<code><a href="#topic+predict.idrfit">predict.idrfit</a></code>), or a <code>data.frame</code> of numeric variables. In
the latter case, quantiles are computed using the empirical distribution of
the variables in <code>predictions</code>.</p>
</td></tr>
<tr><td><code id="qscore_+3A_quantiles">quantiles</code></td>
<td>
<p>numeric vector of desired quantiles.</p>
</td></tr>
<tr><td><code id="qscore_+3A_y">y</code></td>
<td>
<p>a numeric vector of obervations of the same length as the number of
predictions, or of length 1. In the latter case, <code>y</code> will be used
for all predictions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The quantile score of a forecast <em>x</em> for the <em>u</em>-quantile is
defined as
</p>
<p style="text-align: center;"><code class="reqn">
2(1{x &gt; y} - u)(x - y),
</code>
</p>

<p>where <em>y</em> is the observation. For <em>u = 1/2</em>, this equals the mean
absolute error of the median forecast.
</p>


<h3>Value</h3>

<p>A matrix of the quantile scores for the desired quantiles, one column per
quantile.
</p>


<h3>References</h3>

<p>Gneiting, T. and Raftery, A. E. (2007), 'Strictly proper scoring rules,
prediction, and estimation', Journal of the American Statistical Association
102(477), 359-378
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.idrfit">predict.idrfit</a></code>, <code><a href="#topic+qpred">qpred</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("rain")

## Postprocess HRES forecast using data of 3 years

X &lt;- rain[1:(3 * 365), "HRES", drop = FALSE]
y &lt;- rain[1:(3 * 365), "obs"]

fit &lt;- idr(y = y, X = X)

## Compute mean absolute error of the median postprocessed forecast using
## data of the next 2 years (out-of-sample predictions) and compare to raw
## HRES forecast

data &lt;- rain[(3 * 365 + 1):(5 * 365), "HRES", drop = FALSE]
obs &lt;- rain[(3 * 365 + 1):(5 * 365), "obs"]

predictions &lt;- predict(fit, data = data)
idrMAE &lt;- mean(qscore(predictions, 0.5, obs))
rawMAE &lt;- mean(qscore(data, 0.5, obs))

c("idr" = idrMAE, "raw" = rawMAE)
</code></pre>

<hr>
<h2 id='rain'>Frankfurt airport precipitation data</h2><span id='topic+rain'></span>

<h3>Description</h3>

<p>Accumulated 06-30 hour precipitation observations and operational ECMWF
ensemble forecasts for Frankfurt airport, Germany. The observations are
airport station observations (WMO station index 10637), the forecasts are
gridded forecasts for the 0.25 degrees latitude/longitude box containing the
station. Dates range from 2007-01-01 to 2017-01-01, days with missing values
have been removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("rain")
</code></pre>


<h3>Format</h3>

<p>A data frame with 3617 rows. The first column gives the dates, the second 
column are the observations. The remaining columns are the ensemble forecasts
(high resolution HRES, 50 perturbed forecasts P1 to P50 and the control 
forecast CTR for the perturbed forecasts). The units of the forecasts and
observations are mm/m^2.
</p>


<h3>Source</h3>

<p>Observations: <a href="http://www.ogimet.com/synops.phtml.en">http://www.ogimet.com/synops.phtml.en</a>
</p>
<p>Forecasts: available on TIGGE
<a href="https://confluence.ecmwf.int/display/TIGGE/TIGGE+archive">https://confluence.ecmwf.int/display/TIGGE/TIGGE+archive</a>
</p>


<h3>References</h3>

<p>Bougeault et al. (2010) The THORPEX Interactive Grand Global Ensemble. Bull.
Amer. Meteor. Soc., 91, 1059-1072.
</p>
<p>Swinbank et al. (2016) The TIGGE project and its achievements. Bull. Amer.
Meteor. Soc., 97, 49-67.
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+osqpSettings'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>osqp</dt><dd><p><code><a href="osqp.html#topic+osqpSettings">osqpSettings</a></code></p>
</dd>
</dl>

<hr>
<h2 id='trReduc'>Transitive Reduction of path matrix</h2><span id='topic+trReduc'></span>

<h3>Description</h3>

<p>Computes the transitive reduction of the path matrix of a directed acyclic
graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trReduc(paths, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trReduc_+3A_paths">paths</code></td>
<td>
<p>a two column integer matrix containing all pairs of nodes
which are linked by a path of edges.</p>
</td></tr>
<tr><td><code id="trReduc_+3A_n">n</code></td>
<td>
<p>the number of nodes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each <code>k</code>, all indirect paths going through node <code>k</code> are
removed (if there are any).
</p>


<h3>Value</h3>

<p>A two column matrix giving all pairs of edges <code>(i,j)</code> such that there
exists a directed edge from node <code>i</code> to node <code>j</code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
