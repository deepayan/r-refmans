<!DOCTYPE html><html><head><title>Help for package Bessel</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Bessel}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Airy'><p>Airy Functions (and Their First Derivative)</p></a></li>
<li><a href='#Bessel'><p>Bessel Functions of Complex Arguments I(), J(), K(), and Y()</p></a></li>
<li><a href='#BesselH'><p>Hankel (H-Bessel) Function (of Complex Argument)</p></a></li>
<li><a href='#besselI.nuAsym'><p>Asymptotic Expansion of Bessel I(x,nu) and K(x,nu) for Large nu (and x)</p></a></li>
<li><a href='#besselIasym'><p>Asymptotic Expansion of Bessel I(x,nu) and K(x,nu) For Large x</p></a></li>
<li><a href='#besselJs'><p>Bessel J() function Simple Series Representation</p></a></li>
<li><a href='#bI'><p>Bessel I() function Simple Series Representation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Computations and Approximations for Bessel Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6-0</td>
</tr>
<tr>
<td>VersionNote:</td>
<td>Last CRAN: 0.5-5, on 2013-12-10</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-04-24</td>
</tr>
<tr>
<td>Description:</td>
<td>Computations for Bessel function for complex, real and partly
  'mpfr' (arbitrary precision) numbers; notably interfacing TOMS 644;
  approximations for large arguments, experiments, etc.</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin Maechler</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Maechler &lt;maechler@stat.math.ethz.ch&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, Rmpfr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gsl, sfsmisc</td>
</tr>
<tr>
<td>SuggestsNote:</td>
<td>only 'gsl' may be used in code; the others are for
vignettes only</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://specfun.r-forge.r-project.org/">http://specfun.r-forge.r-project.org/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-04-25 07:30:47 UTC; maechler</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-05-02 09:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='Airy'>Airy Functions (and Their First Derivative)</h2><span id='topic+Airy'></span><span id='topic+AiryA'></span><span id='topic+AiryB'></span>

<h3>Description</h3>

<p>Compute the Airy functions <code class="reqn">Ai</code> or <code class="reqn">Bi</code> or their first
derivatives,
<code class="reqn">\frac{d}{dz} Ai(z)</code> and
<code class="reqn">\frac{d}{dz} Bi(z)</code>.
</p>
<p>The Airy functions are solutions of the differential equation
</p>
<p style="text-align: center;"><code class="reqn">w'' = z w</code>
</p>

<p>for <code class="reqn">w(z)</code>, and are related to each other and to the
(modified) Bessel functions via (many identities, see
<a href="https://dlmf.nist.gov/9.6">https://dlmf.nist.gov/9.6</a>), e.g., if
<code class="reqn">\zeta := \frac{2}{3} z \sqrt{z} = \frac{2}{3} z^{\frac{3}{2}}</code>,
</p>
<p style="text-align: center;"><code class="reqn">Ai(z) = \pi^{-1}\sqrt{z/3}K_{1/3}(\zeta) =
            \frac{1}{3}\sqrt{z}\left(I_{-1/3}(\zeta) - I_{1/3}(\zeta)\right),</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">Bi(z) = \sqrt{z/3} \left(I_{-1/3}(\zeta) + I_{1/3}(\zeta)\right).</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>AiryA(z, deriv = 0, expon.scaled = FALSE, verbose = 0)
AiryB(z, deriv = 0, expon.scaled = FALSE, verbose = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Airy_+3A_z">z</code></td>
<td>
<p>complex or numeric vector.</p>
</td></tr>
<tr><td><code id="Airy_+3A_deriv">deriv</code></td>
<td>
<p>order of derivative; must be 0 or 1.</p>
</td></tr>
<tr><td><code id="Airy_+3A_expon.scaled">expon.scaled</code></td>
<td>
<p>logical indicating if the result should be scaled
by an exponential factor (typically to avoid under- or over-flow).</p>
</td></tr>
<tr><td><code id="Airy_+3A_verbose">verbose</code></td>
<td>
<p>integer defaulting to 0, indicating the level of verbosity
notably from C code.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, when <code>expon.scaled</code> is false, <code>AiryA()</code>
computes the complex Airy function <code class="reqn">Ai(z)</code> or its derivative
<code class="reqn">\frac{d}{dz} Ai(z)</code> on <code>deriv=0</code> or <code>deriv=1</code>
respectively. <br />
When <code>expon.scaled</code> is true, it returns
<code class="reqn">\exp(\zeta) Ai(z)</code> or
<code class="reqn">\exp(\zeta) \frac{d}{dz} Ai(z)</code>,
effectively removing the exponential decay in
<code class="reqn">-\pi/3 &lt; \arg(z) &lt; \pi/3</code> and
the exponential growth in
<code class="reqn">\pi/3 &lt; \left|\arg(z)\right| &lt; \pi</code>,
where <code class="reqn">\zeta= \frac{2}{3} z \sqrt{z}</code>, and
<code class="reqn">\arg(z) = </code><code><a href="base.html#topic+Arg">Arg</a>(z)</code>.
</p>
<p>While the Airy functions <code class="reqn">Ai(z)</code> and <code class="reqn">d/dz Ai(z)</code> are
analytic in the whole <code class="reqn">z</code> plane, the corresponding scaled
functions (for <code>expon.scaled=TRUE</code>) have a cut along the
negative real axis.
</p>
<p>By default, when <code>expon.scaled</code> is false, <code>AiryB()</code>
computes the complex Airy function <code class="reqn">Bi(z)</code> or its derivative
<code class="reqn">\frac{d}{dz} Bi(z)</code> on <code>deriv=0</code> or <code>deriv=1</code>
respectively. <br />
When <code>expon.scaled</code> is true, it returns
<code class="reqn">exp(-\left|\Re(\zeta)\right|) Bi(z)</code> or
<code class="reqn">exp(-\left|\Re(\zeta)\right|)\frac{d}{dz}Bi(z)</code>,
to remove the exponential behavior in both the left and right half
planes where, as above,
<code class="reqn">\zeta= \frac{2}{3}\cdot z \sqrt{z}</code>.
</p>


<h3>Value</h3>

<p>a complex or numeric vector of the same length (and class) as <code>z</code>.
</p>


<h3>Author(s)</h3>

<p>Donald E. Amos, Sandia National Laboratories, wrote the original
fortran code.
Martin Maechler did the <span class="rlang"><b>R</b></span> interface.
</p>


<h3>References</h3>

<p>see <code><a href="#topic+BesselJ">BesselJ</a></code>; notably for many results the
</p>
<p>Digital Library of Mathematical Functions (DLMF), Chapter 9
<em>Airy and Related Functions</em> at <a href="https://dlmf.nist.gov/9">https://dlmf.nist.gov/9</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BesselI">BesselI</a></code> etc; the Hankel functions <code><a href="#topic+Hankel">Hankel</a></code>.
</p>
<p>The CRAN package <a href="https://CRAN.R-project.org/package=Rmpfr"><span class="pkg">Rmpfr</span></a> has <code><a href="Rmpfr.html#topic+Ai">Ai</a>(x)</code> for
arbitrary precise &quot;mpfr&quot;-numbers <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The AiryA() := Ai() function -------------

curve(AiryA, -20, 100, n=1001)
curve(AiryA,  -1, 100, n=1011, log="y") -&gt; Aix
curve(AiryA(x, expon.scaled=TRUE), -1, 50, n=1001)
## Numerically "proving" the 1st identity above :
z &lt;- Aix$x; i &lt;- z &gt; 0; head(z &lt;- z[i &lt;- z &gt; 0])
Aix &lt;- Aix$y[i]; zeta &lt;- 2/3*z*sqrt(z)
stopifnot(all.equal(Aix, 1/pi * sqrt(z/3)* BesselK(zeta, nu = 1/3),
                    tol = 4e-15)) # 64b Lnx: 7.9e-16;  32b Win: 1.8e-15

## This gives many warnings (248 on nb-mm4, F24) about lost accuracy, but on Windows takes ~ 4 sec:
curve(AiryA(x, expon.scaled=TRUE),  1, 10000, n=1001, log="xy")

## The AiryB() := Bi() function -------------

curve(AiryB, -20, 2, n=1001); abline(h=0,v=0, col="gray",lty=2)
curve(AiryB, -1, 20, n=1001, log = "y") # exponential growth (x &gt; 0)

curve(AiryB(x,expon.scaled=TRUE), -1, 20,    n=1001)
curve(AiryB(x,expon.scaled=TRUE),  1, 10000, n=1001, log="x")
</code></pre>

<hr>
<h2 id='Bessel'>Bessel Functions of Complex Arguments I(), J(), K(), and Y()</h2><span id='topic+BesselI'></span><span id='topic+BesselJ'></span><span id='topic+BesselK'></span><span id='topic+BesselY'></span>

<h3>Description</h3>

<p>Compute the Bessel functions I(), J(), K(), and Y(), of complex
arguments <code>z</code> and real <code>nu</code>,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BesselI(z, nu, expon.scaled = FALSE, nSeq = 1, verbose = 0)
BesselJ(z, nu, expon.scaled = FALSE, nSeq = 1, verbose = 0)
BesselK(z, nu, expon.scaled = FALSE, nSeq = 1, verbose = 0)
BesselY(z, nu, expon.scaled = FALSE, nSeq = 1, verbose = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bessel_+3A_z">z</code></td>
<td>
<p>complex or numeric vector.</p>
</td></tr>
<tr><td><code id="Bessel_+3A_nu">nu</code></td>
<td>
<p>numeric (scalar).</p>
</td></tr>
<tr><td><code id="Bessel_+3A_expon.scaled">expon.scaled</code></td>
<td>
<p>logical indicating if the result should be scaled
by an exponential factor, typically to avoid under- or over-flow.
See the &lsquo;Details&rsquo; about the specific scaling.</p>
</td></tr>
<tr><td><code id="Bessel_+3A_nseq">nSeq</code></td>
<td>
<p>positive integer; if <code class="reqn">&gt; 1</code>, computes the result for
a whole <em>sequence</em> of <code>nu</code> values;<br />
if <code>nu &gt;= 0</code>,<code>nu, nu+1, ..., nu+nSeq-1</code>,<br />
if <code>nu &lt; 0</code>, <code>nu, nu-1, ..., nu-nSeq+1</code>.</p>
</td></tr>
<tr><td><code id="Bessel_+3A_verbose">verbose</code></td>
<td>
<p>integer defaulting to 0, indicating the level of verbosity
notably from C code.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The case <code>nu &lt; 0</code> is handled by using simple formula from
Abramowitz and Stegun,  see details in <code><a href="base.html#topic+besselI">besselI</a>()</code>.
</p>
<p>The scaling activated by <code>expon.scaled = TRUE</code> depends on the
function and the scaled versions are  </p>

<dl>
<dt>J():</dt><dd><p><code>BesselJ(z, nu, expo=TRUE)</code><code class="reqn">:= \exp(-\left|\Im(z)\right|) J_{\nu}(z)</code></p>
</dd>
<dt>Y():</dt><dd><p><code>BesselY(z, nu, expo=TRUE)</code><code class="reqn"> := \exp(-\left|\Im(z)\right|) Y_{\nu}(z)</code></p>
</dd>
<dt>I():</dt><dd><p><code>BesselI(z, nu, expo=TRUE)</code><code class="reqn"> := \exp(-\left|\Re(z)\right|) I_{\nu}(z)</code></p>
</dd>
<dt>K():</dt><dd><p><code>BesselK(z, nu, expo=TRUE)</code><code class="reqn"> := \exp(z) K_{\nu}(z)</code></p>
</dd>
</dl>



<h3>Value</h3>

<p>a complex or numeric vector (or <code><a href="base.html#topic+matrix">matrix</a></code> with <code>nSeq</code>
columns if <code>nSeq &gt; 1</code>)
of the same length (or <code><a href="base.html#topic+nrow">nrow</a></code> when <code>nSeq &gt; 1</code>) and
<code><a href="base.html#topic+mode">mode</a></code> as <code>z</code>.
</p>


<h3>Author(s)</h3>

<p>Donald E. Amos, Sandia National Laboratories, wrote the original
fortran code.
Martin Maechler did the translation to C, and partial cleanup
(replacing <code>goto</code>'s), in addition to the <span class="rlang"><b>R</b></span> interface.
</p>


<h3>References</h3>

<p>Abramowitz, M., and Stegun, I. A. (1955, etc).
<em>Handbook of mathematical functions</em>
(NBS AMS series 55, U.S. Dept. of Commerce),
<a href="http://people.math.sfu.ca/~cbm/aands/">http://people.math.sfu.ca/~cbm/aands/</a>
</p>
<p>Wikipedia (20nn). <em>Bessel Function</em>,
<a href="https://en.wikipedia.org/wiki/Bessel_function">https://en.wikipedia.org/wiki/Bessel_function</a>
</p>

<p>D. E. Amos (1986)
Algorithm 644: A portable package for Bessel functions of a complex
argument and nonnegative order;
<em>ACM Trans. Math. Software</em> <b>12</b>, 3, 265&ndash;273.
</p>
<p>D. E. Amos (1983)
<em>Computation of Bessel Functions of Complex Argument</em>;  Sand83-0083.
</p>
<p>D. E. Amos (1983)
<em>Computation of Bessel Functions of Complex Argument and Large Order</em>; Sand83-0643.
</p>
<p>D. E. Amos (1985)
<em>A subroutine package for Bessel functions of a complex
argument and nonnegative order</em>; Sand85-1018.
</p>
<p>Olver, F.W.J. (1974).
<em>Asymptotics and Special Functions</em>;
Academic Press, N.Y., p.420
</p>


<h3>See Also</h3>

<p>The base <span class="rlang"><b>R</b></span> functions <code><a href="base.html#topic+besselI">besselI</a>()</code>, <code><a href="base.html#topic+besselK">besselK</a>()</code>, etc.
</p>
<p>The Hankel functions (of first and second kind),
<code class="reqn">H_{\nu}^{(1)}(z)</code> and <code class="reqn">H_{\nu}^{(2)}(z)</code>: <code><a href="#topic+Hankel">Hankel</a></code>.
</p>
<p>The Airy functions <code class="reqn">Ai()</code> and <code class="reqn">Bi()</code> and their first
derivatives, <code><a href="#topic+Airy">Airy</a></code>.
</p>
<p>For large <code>x</code> and/or <code>nu</code> arguments, algorithm AS~644 is not
good enough, and the results may overflow to <code>Inf</code> or underflow
to zero, such that direct computation of <code class="reqn">\log(I_\nu(x))</code> and
<code class="reqn">\log(K_\nu(x))</code> are desirable.  For this, we provide
<code><a href="#topic+besselI.nuAsym">besselI.nuAsym</a>()</code>, <code><a href="#topic+besselIasym">besselIasym</a>()</code> and
<code><a href="#topic+besselK.nuAsym">besselK.nuAsym</a>(*, log= *)</code>, based on asymptotic expansions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## For real small arguments, BesselI() gives the same as base::besselI() :
set.seed(47); x &lt;- sort(round(rlnorm(20), 2))
M &lt;- cbind(x, b = besselI(x, 3), B = BesselI(x, 3))
stopifnot(all.equal(M[,"b"], M[,"B"], tol = 2e-15)) # ~4e-16 even
M

## and this is true also for the 'exponentially scaled' version:
Mx &lt;- cbind(x, b = besselI(x, 3, expon.scaled=TRUE),
               B = BesselI(x, 3, expon.scaled=TRUE))
stopifnot(all.equal(Mx[,"b"], Mx[,"B"], tol = 2e-15)) # ~4e-16 even
</code></pre>

<hr>
<h2 id='BesselH'>Hankel (H-Bessel) Function (of Complex Argument)</h2><span id='topic+Hankel'></span><span id='topic+BesselH'></span>

<h3>Description</h3>

<p>Compute the Hankel functions <code class="reqn">H(1,*)</code> and <code class="reqn">H(2,*)</code>,
also called &lsquo;H-Bessel&rsquo; function (of the third kind),
of complex arguments.  They are defined as
</p>
<p style="text-align: center;"><code class="reqn">
    H(1,\nu, z) := H_{\nu}^{(1)}(z) =  J_{\nu}(z) + i Y_{\nu}(z),</code>
</p>

<p style="text-align: center;"><code class="reqn">
    H(2,\nu, z) := H_{\nu}^{(2)}(z) =  J_{\nu}(z) - i Y_{\nu}(z),</code>
</p>

<p>where <code class="reqn">J_{\nu}(z)</code> and <code class="reqn">Y_{\nu}(z)</code> are the
Bessel functions of the first and second kind, see
<code><a href="#topic+BesselJ">BesselJ</a></code>, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BesselH(m, z, nu, expon.scaled = FALSE, nSeq = 1, verbose = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BesselH_+3A_m">m</code></td>
<td>
<p>integer, either 1 or 2, indicating the kind of Hankel function.</p>
</td></tr>
<tr><td><code id="BesselH_+3A_z">z</code></td>
<td>
<p>complex or numeric vector of values <b>different from 0</b>.</p>
</td></tr>
<tr><td><code id="BesselH_+3A_nu">nu</code></td>
<td>
<p>numeric, must currently be non-negative.</p>
</td></tr>
<tr><td><code id="BesselH_+3A_expon.scaled">expon.scaled</code></td>
<td>
<p>logical indicating if the result should be scaled
by an exponential factor (typically to avoid under- or over-flow).</p>
</td></tr>
<tr><td><code id="BesselH_+3A_nseq">nSeq</code></td>
<td>
<p>positive integer; if <code class="reqn">&gt; 1</code>, computes the result for
a whole <em>sequence</em> of <code>nu</code> values of length <code>nSeq</code>,
see &lsquo;Details&rsquo; below.</p>
</td></tr>
<tr><td><code id="BesselH_+3A_verbose">verbose</code></td>
<td>
<p>integer defaulting to 0, indicating the level of verbosity
notably from C code.</p>
</td></tr>
</table>


<h3>Details</h3>


<p>By default (when <code>expon.scaled</code> is false), the resulting sequence
(of length <code>nSeq</code>) is for <code class="reqn">m = 1,2</code>,
</p>
<p style="text-align: center;"><code class="reqn">y_j = H(m, \nu+j-1, z),</code>
</p>

<p>computed for <code class="reqn">j=1,\dots,nSeq</code>.
</p>
<p>If <code>expon.scaled</code> is true, the sequence is for <code class="reqn">m = 1,2</code>
</p>
<p style="text-align: center;"><code class="reqn">y_j = \exp(-\tilde{m} z i) \cdot H(m, \nu+j-1, z),</code>
</p>

<p>where <code class="reqn">\tilde{m} = 3-2m</code>
(and <code class="reqn">i^2 = -1</code>), for <code class="reqn">j=1,\dots,nSeq</code>.
</p>


<h3>Value</h3>

<p>a complex or numeric vector (or <code><a href="base.html#topic+matrix">matrix</a></code> if <code>nSeq &gt; 1</code>)
of the same length and <code><a href="base.html#topic+mode">mode</a></code> as <code>z</code>.
</p>


<h3>Author(s)</h3>

<p>Donald E. Amos, Sandia National Laboratories, wrote the original
fortran code.
Martin Maechler did the <span class="rlang"><b>R</b></span> interface.
</p>


<h3>References</h3>

<p>see <code><a href="#topic+BesselI">BesselI</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BesselI">BesselI</a></code> etc; the Airy function <code><a href="#topic+Airy">Airy</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##------------------ H(1, *) ----------------
nus &lt;- c(1,2,5,10)
for(i in seq_along(nus))
   curve(BesselH(1, x, nu=nus[i]), -10, 10, add= i &gt; 1, col=i, n=1000)
legend("topleft", paste("nu = ", format(nus)), col = seq_along(nus), lty=1)

## nu = 10 looks a bit  "special" ...   hmm...
curve(BesselH(1, x, nu=10), -.3, .3, col=4,
      ylim = c(-10,10), n=1000)

##------------------ H(2, *) ----------------
for(i in seq_along(nus))
   curve(BesselH(2, x, nu=nus[i]), -10, 10, add= i &gt; 1, col=i, n=1000)
legend("bottomright", paste("nu = ", format(nus)), col = seq_along(nus), lty=1)
## the same nu = 10 behavior ..
</code></pre>

<hr>
<h2 id='besselI.nuAsym'>Asymptotic Expansion of Bessel I(x,nu) and K(x,nu) for Large nu (and x)</h2><span id='topic+besselI.nuAsym'></span><span id='topic+besselK.nuAsym'></span>

<h3>Description</h3>

<p>Compute Bessel functions <code class="reqn">I_{\nu}(x)</code> and
<code class="reqn">K_{\nu}(x)</code> for large <code class="reqn">\nu</code> and possibly large
<code class="reqn">x</code>,
using asymptotic expansions in Debye polynomials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>besselI.nuAsym(x, nu, k.max, expon.scaled = FALSE, log = FALSE)
besselK.nuAsym(x, nu, k.max, expon.scaled = FALSE, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="besselI.nuAsym_+3A_x">x</code></td>
<td>
<p>numeric or <code><a href="base.html#topic+complex">complex</a></code>, with real part <code class="reqn">\ge 0</code>.</p>
</td></tr>
<tr><td><code id="besselI.nuAsym_+3A_nu">nu</code></td>
<td>
<p>numeric; The <em>order</em> (maybe fractional!) of the
corresponding Bessel function.</p>
</td></tr>
<tr><td><code id="besselI.nuAsym_+3A_k.max">k.max</code></td>
<td>
<p>integer number of terms in the expansion.  Must be in
<code>0:5</code>, currently.</p>
</td></tr>
<tr><td><code id="besselI.nuAsym_+3A_expon.scaled">expon.scaled</code></td>
<td>
<p>logical; if <code>TRUE</code>, the results are
exponentially scaled, the same as in the corresponding
<code><a href="#topic+BesselI">BesselI</a>()</code> and <code>BesselK()</code> functions in order to avoid overflow
(<code class="reqn">I_{\nu}</code>) or underflow (<code class="reqn">K_{\nu}</code>), respectively.</p>
</td></tr>
<tr><td><code id="besselI.nuAsym_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, <code class="reqn">\log(f(.))</code> is returned instead of <code class="reqn">f</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Abramowitz &amp; Stegun , page 378, has formula 9.7.7 and 9.7.8 for the asymptotic
expansions of <code class="reqn">I_{\nu}(x)</code> and <code class="reqn">K_{\nu}(x)</code>, respectively,
also saying <em>
When <code class="reqn">\nu \to +\infty</code>, these expansions
(of <code class="reqn">I_{\nu}(\nu z)</code> and
<code class="reqn">K_{\nu}(\nu z)</code>)
hold uniformly with respect to <code class="reqn">z</code> in the sector
<code class="reqn">|arg z| \le \frac{1}{2} \pi - \epsilon</code>,
where <code class="reqn">\epsilon</code> iw qn arbitrary positive number.</em>
and for this reason, we require <code class="reqn">\Re(x) \ge 0</code>.
</p>
<p>The Debye polynomials <code class="reqn">u_k(x)</code> are defined in 9.3.9 and 9.3.10 (page 366).
</p>


<h3>Value</h3>

<p>a numeric vector of the same length as the long of <code>x</code> and
<code>nu</code>. (usual argument recycling is applied implicitly.)
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>References</h3>

<p>Abramowitz, M., and Stegun, I. A. (1955, etc).
<em>Handbook of mathematical functions</em>
(NBS AMS series 55, U.S. Dept. of Commerce), pp. 366, 378.
</p>


<h3>See Also</h3>

<p>From this package <span class="pkg">Bessel</span>: <code><a href="#topic+BesselI">BesselI</a>()</code>; further,
<code><a href="#topic+besselIasym">besselIasym</a>()</code> for the case when <code class="reqn">x</code> is large and
<code class="reqn">\nu</code> is small or moderate.
</p>
<p>Further, from <span class="pkg">base</span>: <code><a href="base.html#topic+besselI">besselI</a></code>, etc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1:10, 20, 50, 100, 100000)
nu &lt;- c(1, 10, 20, 50, 10^(2:10))

sapply(0:4, function(k.)
            sapply(nu, function(n.)
                   besselI.nuAsym(x, nu=n., k.max = k., log = TRUE)))

sapply(0:4, function(k.)
            sapply(nu, function(n.)
                   besselK.nuAsym(x, nu=n., k.max = k., log = TRUE)))
</code></pre>

<hr>
<h2 id='besselIasym'>Asymptotic Expansion of Bessel I(x,nu) and K(x,nu) For Large x</h2><span id='topic+besselIasym'></span><span id='topic+besselKasym'></span><span id='topic+besselI.ftrms'></span>

<h3>Description</h3>

<p>Compute Bessel function <code class="reqn">I_{\nu}(x)</code>
and <code class="reqn">K_{\nu}(x)</code>
for large <code class="reqn">x</code> and small or moderate
<code class="reqn">\nu</code>, using the asymptotic expansions (9.7.1) and (9.7.2), p.377-8 of
Abramowitz &amp; Stegun, for <code class="reqn">x \to\infty</code>, even valid for
<em><code><a href="base.html#topic+complex">complex</a></code></em> <code class="reqn">x</code>,

</p>
<p style="text-align: center;"><code class="reqn">I_a(x) = exp(x) / \sqrt{2\pi x} \cdot f(x, a),
  </code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">f(x,a) = 1 - \frac{\mu-1}{8x} + \frac{(\mu-1)(\mu-9)}{2! (8x)^2}
    - \ldots,</code>
</p>


<p>and  <code class="reqn">\mu = 4 a^2</code> and <code class="reqn">|arg(x)| &lt; \pi/2</code>.
</p>
<p>Whereas <code>besselIasym(x,a)</code> computes a possibly exponentially scaled
and/or <code><a href="base.html#topic+log">log</a></code>ged version of <code class="reqn">I_a(x)</code>,
<code>besselI.ftrms</code> returns the corresponding <em>terms</em> in the
series expansion of <code class="reqn">f(x,a)</code> above.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>besselIasym  (x, nu, k.max = 10, expon.scaled = FALSE, log = FALSE)
besselKasym  (x, nu, k.max = 10, expon.scaled = FALSE, log = FALSE)
besselI.ftrms(x, nu, K = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="besselIasym_+3A_x">x</code></td>
<td>
<p>numeric or complex (with real part) <code class="reqn">\ge 0</code>.</p>
</td></tr>
<tr><td><code id="besselIasym_+3A_nu">nu</code></td>
<td>
<p>numeric; the <em>order</em> (maybe fractional!) of the
corresponding Bessel function.</p>
</td></tr>
<tr><td><code id="besselIasym_+3A_k.max">k.max</code>, <code id="besselIasym_+3A_k">K</code></td>
<td>
<p>integer number of terms in the expansion.</p>
</td></tr>
<tr><td><code id="besselIasym_+3A_expon.scaled">expon.scaled</code></td>
<td>
<p>logical; if <code>TRUE</code>, the results are
exponentially scaled in order to avoid overflow.</p>
</td></tr>


<tr><td><code id="besselIasym_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, <code class="reqn">\log(f(.))</code> is returned instead of <code class="reqn">f</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<p>Even though the reference (A. &amp; S.) requires
<code class="reqn">|\arg z| &lt; \pi/2</code> for <code class="reqn">I()</code> and
<code class="reqn">|\arg z| &lt; 3\pi/2</code> for <code class="reqn">K()</code>,
where <code class="reqn">\arg(z) := </code><code><a href="base.html#topic+Arg">Arg</a>(z)</code>,
the zero-th order term seems correct also for negative (real) numbers.
</p>


<h3>Value</h3>

<p>a numeric (or complex) vector of the same length as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>References</h3>

<p>Abramowitz, M., and Stegun, I. A. (1955, etc).
<em>Handbook of mathematical functions</em>
(NBS AMS series 55, U.S. Dept. of Commerce).
</p>


<h3>See Also</h3>

<p>From this package <span class="pkg">Bessel()</span> <code><a href="#topic+BesselI">BesselI</a>()</code>; further,
<code><a href="#topic+besselI.nuAsym">besselI.nuAsym</a>()</code> which is useful when <code class="reqn">\nu</code> is large
(as well); further <span class="pkg">base</span> <code><a href="base.html#topic+besselI">besselI</a></code>, etc
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1:10, 20, 50, 100^(2:10))
nu &lt;- c(1, 10, 20, 50, 100)
r &lt;- lapply(c(0:4,10,20), function(k.)
            sapply(nu, function(n.)
                  besselIasym(x, nu=n., k.max = k., log = TRUE)))
warnings() 

try( # needs improvement in R  [or a local workaround]
 besselIasym(10000*(1+1i), nu=200, k.max=20, log=TRUE)
) # Error in log1p(-d) : unimplemented complex function

</code></pre>

<hr>
<h2 id='besselJs'>Bessel J() function Simple Series Representation</h2><span id='topic+besselJs'></span>

<h3>Description</h3>

<p>Computes the modified Bessel <code class="reqn">J</code> function, using one of its basic
definitions as an infinite series, e.g. A. &amp; S., p.360, (9.1.10).  The
implementation is pure <span class="rlang"><b>R</b></span>, working for <code><a href="base.html#topic+numeric">numeric</a></code>,
<code><a href="base.html#topic+complex">complex</a></code>, but also e.g., for objects of class
<code>"<a href="Rmpfr.html#topic+mpfr-class">mpfr</a>"</code> from package <span class="pkg">Rmpfr</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>besselJs(x, nu, nterm = 800, log = FALSE,
         Ceps = if (isNum) 8e-16 else 2^(-x@.Data[[1]]@prec))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="besselJs_+3A_x">x</code></td>
<td>
<p>numeric or complex vector, or of another <code><a href="base.html#topic+class">class</a></code>
for which arithmetic methods are defined, notably
objects of class <code><a href="Rmpfr.html#topic+mpfr-class">mpfr</a></code>.</p>
</td></tr>
<tr><td><code id="besselJs_+3A_nu">nu</code></td>
<td>
<p>non-negative numeric (scalar).</p>
</td></tr>
<tr><td><code id="besselJs_+3A_nterm">nterm</code></td>
<td>
<p>integer indicating the number of terms to be used.
Should be in the order of <code>abs(x)</code>, but can be smaller for
large x.  A warning is given, when <code>nterm</code> was <em>possibly</em> too
small. (Currently, many of these warnings are wrong, as</p>
</td></tr>
<tr><td><code id="besselJs_+3A_log">log</code></td>
<td>
<p>logical indicating if the logarithm <code class="reqn">log J.()</code> is
required.</p>
</td></tr>
<tr><td><code id="besselJs_+3A_ceps">Ceps</code></td>
<td>
<p>a relative error tolerance for checking if <code>nterm</code>
has been sufficient.  The default is &ldquo;correct&rdquo; for double
precision and also for
multiprecision objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a &ldquo;numeric&rdquo; (or complex or <code>"<a href="Rmpfr.html#topic+mpfr-class">mpfr</a>"</code>)
vector of the same class and length as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>References</h3>

<p>Abramowitz, M., and Stegun, I. A. (1955, etc).
<em>Handbook of mathematical functions</em>
(NBS AMS series 55, U.S. Dept. of Commerce).
<a href="http://people.math.sfu.ca/~cbm/aands/page_360.htm">http://people.math.sfu.ca/~cbm/aands/page_360.htm</a>
</p>


<h3>See Also</h3>

<p>This package <code><a href="#topic+BesselJ">BesselJ</a></code>, <span class="pkg">base</span> <code><a href="base.html#topic+besselJ">besselJ</a></code>, etc
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stopifnot(all.equal(besselJs(1:10, 1), # our R code
                    besselJ (1:10, 1)))# internal C code w/ different algorithm

## Large 'nu' ...
x &lt;- (0:20)/4
(bx &lt;- besselJ(x, nu=200))# base R's -- gives (mostly wrong) warnings
if(require("Rmpfr")) { ## Use high precision, notably large exponent range, numbers:
  Bx &lt;- besselJs(mpfr(x, 64), nu=200)
  all.equal(Bx, bx, tol = 1e-15)# TRUE -- warnings were mostly wrong; specifically:
  cbind(bx, Bx)
  signif(asNumeric(1 - (bx/Bx)[19:21]), 4) # only [19] had lost accuracy

  ## With*out* mpfr numbers -- using log -- is accurate (here)
  lbx &lt;- besselJs(     x,      nu=200, log=TRUE)
  lBx &lt;- besselJs(mpfr(x, 64), nu=200, log=TRUE)
  cbind(x, lbx, lBx)
  stopifnot(all.equal(asNumeric(log(Bx)), lbx, tol=1e-15),
	    all.equal(lBx, lbx, tol=4e-16))
} # Rmpfr
</code></pre>

<hr>
<h2 id='bI'>Bessel I() function Simple Series Representation</h2><span id='topic+bI'></span><span id='topic+besselIs'></span>

<h3>Description</h3>

<p>Computes the modified Bessel <code class="reqn">I</code> function, using one of its basic
definitions as an infinite series.  The implementation is pure <span class="rlang"><b>R</b></span>,
working for <code><a href="base.html#topic+numeric">numeric</a></code>, <code><a href="base.html#topic+complex">complex</a></code>, but also
e.g., for objects of class <code>"<a href="Rmpfr.html#topic+mpfr-class">mpfr</a>"</code>
from package <span class="pkg">Rmpfr</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>besselIs(x, nu, nterm = 800, expon.scaled = FALSE, log = FALSE,
         Ceps = if (isNum) 8e-16 else 2^(-x@.Data[[1]]@prec))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bI_+3A_x">x</code></td>
<td>
<p>numeric or complex vector, or of another <code><a href="base.html#topic+class">class</a></code>
for which arithmetic methods are defined, notably
objects of class <code><a href="Rmpfr.html#topic+mpfr-class">mpfr</a></code> (package <a href="https://CRAN.R-project.org/package=Rmpfr"><span class="pkg">Rmpfr</span></a>).</p>
</td></tr>
<tr><td><code id="bI_+3A_nu">nu</code></td>
<td>
<p>non-negative numeric (scalar).</p>
</td></tr>
<tr><td><code id="bI_+3A_nterm">nterm</code></td>
<td>
<p>integer indicating the number of terms to be used.
Should be in the order of <code>abs(x)</code>, but can be smaller for
large x.  A warning is given, when <code>nterm</code> was chosen too
small.</p>
</td></tr>
<tr><td><code id="bI_+3A_expon.scaled">expon.scaled</code></td>
<td>
<p>logical indicating if the result should be scaled
by <code class="reqn">exp(-abs(x))</code>.</p>
</td></tr>
<tr><td><code id="bI_+3A_log">log</code></td>
<td>
<p>logical indicating if the logarithm <code class="reqn">log I.()</code> is
required.  This allows even more precision than
<code>expon.scaled=TRUE</code> in some cases.</p>
</td></tr>
<tr><td><code id="bI_+3A_ceps">Ceps</code></td>
<td>
<p>a relative error tolerance for checking if <code>nterm</code>
has been sufficient.  The default is &ldquo;correct&rdquo; for double
precision and also for
multiprecision objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a &ldquo;numeric&rdquo; (or complex or <code>"<a href="Rmpfr.html#topic+mpfr-class">mpfr</a>"</code>)
vector of the same class and length as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>References</h3>

<p>Abramowitz, M., and Stegun, I. A. (1955, etc).
<em>Handbook of mathematical functions</em>
(NBS AMS series 55, U.S. Dept. of Commerce).
</p>


<h3>See Also</h3>

<p>This package <code><a href="#topic+BesselI">BesselI</a></code>, <span class="pkg">base</span> <code><a href="base.html#topic+besselI">besselI</a></code>, etc
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(nus &lt;- c(outer((0:3)/4, 1:5, `+`)))
stopifnot(
  all.equal(besselIs(1:10, 1), # our R code
            besselI (1:10, 1)) # internal C code w/ different algorithm
  ,
  sapply(nus, function(nu)
   all.equal(besselIs(1:10, nu, expon.scale=TRUE), # our R code
             BesselI (1:10, nu, expon.scale=TRUE)) # TOMS644 code
   )
  ,
  ## complex argument [gives warnings  'nterm=800' may be too small]
  sapply(nus, function(nu)
   all.equal(besselIs((1:10)*(1+1i), nu, expon.scale=TRUE), # our R code
             BesselI ((1:10)*(1+1i), nu, expon.scale=TRUE)) # TOMS644 code
   )
)

## Large 'nu' ...
x &lt;- (0:20)/4
(bx &lt;- besselI(x, nu=200))# base R's -- gives (mostly wrong) warnings
if(require("Rmpfr")) { ## Use high precision (notably large exponent range) numbers:
  Bx &lt;- besselIs(mpfr(x, 64), nu=200)
  all.equal(Bx, bx, tol = 1e-15)# TRUE -- warning were mostly wrong; specifically:
  cbind(bx, Bx)
  signif(asNumeric(1 - (bx/Bx)[19:21]), 4) # only [19] had lost accuracy

  ## With*out* mpfr numbers -- using log -- is accurate (here)
  (lbx &lt;- besselIs(     x,      nu=200, log=TRUE))
  lBx &lt;-  besselIs(mpfr(x, 64), nu=200, log=TRUE)
  stopifnot(all.equal(asNumeric(log(Bx)), lbx, tol=1e-15),
	    all.equal(lBx, lbx, tol=4e-16))
} # Rmpfr
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
