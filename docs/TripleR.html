<!DOCTYPE html><html><head><title>Help for package TripleR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TripleR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#getEffects'>
<p>Calculates round robin effects for multiple variables</p></a></li>
<li><a href='#long2matrix'><p>Convert long format to a quadratic matrix</p></a></li>
<li><a href='#matrix2long'><p>Convert a quadratic matrix to long format</p></a></li>
<li><a href='#parCor'><p>partial correlation</p></a></li>
<li><a href='#plot_missings'><p>Plot missing values</p></a></li>
<li><a href='#plot.RRuni'><p>Plot variance components from SRAs</p></a></li>
<li><a href='#RR'><p>Triple R: Round-Robin Analyses Using R</p></a></li>
<li><a href='#RR.style'><p>Set labeling styles for RR analyses</p></a></li>
<li><a href='#RR.summary'><p>Print group descriptives</p></a></li>
<li><a href='#selfCor'><p>partial correlation</p></a></li>
<li><a href='#TripleR-package'><p>Triple R: A Package for Round-Robin Analyses Using R</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Social Relation Model (SRM) Analyses for Single or Multiple
Groups</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-25</td>
</tr>
<tr>
<td>Author:</td>
<td>F. D. Schönbrodt, M. D. Back, S. C. Schmukle</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Felix Schönbrodt &lt;felix.schoenbrodt@psy.lmu.de&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>ggplot2 (&ge; 0.9.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>reshape2, plyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lme4, R.rsp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Description:</td>
<td>Social Relation Model (SRM) analyses for single or multiple
    round-robin groups are performed. These analyses are either based on one
    manifest variable, one latent construct measured by two manifest variables,
    two manifest variables and their bivariate relations, or two latent
    constructs each measured by two manifest variables. Within-group t-tests
    for variance components and covariances are provided for single groups.
    For multiple groups two types of significance tests are provided:
    between-groups t-tests (as in SOREMO) and enhanced standard errors based on
    Lashley and Bond (1997) &lt;<a href="https://doi.org/10.1037%2F1082-989X.2.3.278">doi:10.1037/1082-989X.2.3.278</a>&gt;. Handling for missing values is provided.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-26 07:37:31 UTC; felix</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-26 11:40:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='getEffects'>
Calculates round robin effects for multiple variables
</h2><span id='topic+getEffects'></span>

<h3>Description</h3>

<p>This is a helper function which facilitates the calculation of round robin effects if many variables are assessed. Only univariate analyses are possible at the moment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEffects(formule, data, varlist, by=NA, na.rm=TRUE, 
			minVar=localOptions$minVar, gm=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getEffects_+3A_formule">formule</code></td>
<td>
<p>The right hand side of the formula, specifying the actor, partner and group variable.
</p>
</td></tr>
<tr><td><code id="getEffects_+3A_data">data</code></td>
<td>

<p>The data frame.
</p>
</td></tr>
<tr><td><code id="getEffects_+3A_varlist">varlist</code></td>
<td>

<p>A vector with the column names (the column numbers are not possible!) of the variables which should be inserted at the left hand side of the formula.
</p>
</td></tr>
<tr><td><code id="getEffects_+3A_by">by</code></td>
<td>

<p>By which variables should the results be merged? If by is NA (the default), a intelligent default handling is performed. It is strongly recommended to keep the defaults.
</p>
</td></tr>
<tr><td><code id="getEffects_+3A_na.rm">na.rm</code></td>
<td>

<p>This argument is passed to function <code>RR</code>.
</p>
</td></tr>
<tr><td><code id="getEffects_+3A_minvar">minVar</code></td>
<td>
<p>Set the minVar parameter for all analyses. See <code><a href="#topic+RR">RR</a></code> for details on this parameter.
</p>
</td></tr>
<tr><td><code id="getEffects_+3A_gm">gm</code></td>
<td>
<p>Should effects returned as group centered (<code>gm=FALSE</code>, or with group means included (<code>gm=TRUE</code>)?)
</p>
</td></tr>
<tr><td><code id="getEffects_+3A_...">...</code></td>
<td>

<p>Additional parameters passed to RR (e.g., selfenhance)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with all effects is returned
</p>


<h3>Author(s)</h3>

<p>Felix Schönbrodt
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RR">RR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(likingLong)
res &lt;- getEffects(~perceiver.id*target.id, 
				  data=likingLong, 
				  varlist=c("liking_a", "liking_b", "metaliking_a", "metaliking_b"))
str(res)

# effects including group means:
res.gm &lt;- getEffects(~perceiver.id*target.id, 
				  data=likingLong, gm=TRUE,
				  varlist=c("liking_a", "liking_b", "metaliking_a", "metaliking_b"))
str(res.gm)


# Multipe groups
#-----------------------
data("multiLikingLong")

res.g &lt;- getEffects(~perceiver.id*target.id|group.id, 
				  data=multiLikingLong, 
				  varlist=c("liking_a", "liking_b", "metaliking_a", "metaliking_b"))
str(res.g)

# effects including group means:
res.g.gm &lt;- getEffects(~perceiver.id*target.id|group.id, 
				  data=multiLikingLong, gm=TRUE,
				  varlist=c("liking_a", "liking_b", "metaliking_a", "metaliking_b"))
str(res.g.gm)

</code></pre>

<hr>
<h2 id='long2matrix'>Convert long format to a quadratic matrix</h2><span id='topic+long2matrix'></span>

<h3>Description</h3>

<p>This function converts data from the long format to a quadratic round robin matrix. It is ensured that the matrix in fact is quadratic (i.e. rows or columns are added if necessary).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>long2matrix(formule, data, minData=1, verbose=TRUE, reduce=TRUE, 
				skip3=TRUE, g.id=NULL, exclude.ids=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="long2matrix_+3A_formule">formule</code></td>
<td>
<p>A formula specifying the variable names. Example usage: <code>DV ~ perceiver.id*target.id | group.id</code> (group.id only necessary in multi group data sets)</p>
</td></tr>
<tr><td><code id="long2matrix_+3A_data">data</code></td>
<td>
<p>A data frame in long format)</p>
</td></tr>
<tr><td><code id="long2matrix_+3A_verbose">verbose</code></td>
<td>
<p>Should additional information be printed?</p>
</td></tr>
<tr><td><code id="long2matrix_+3A_mindata">minData</code></td>
<td>
<p>Sets the minimum of data points which have to be present in each row and column</p>
</td></tr>
<tr><td><code id="long2matrix_+3A_reduce">reduce</code></td>
<td>
<p>Should persons that only are actors or only partners be removed? Actor/partner effects and variance components can only be calculated, if every person is both an actor and a partner. For displaying reasons (e.g. for data inspection), however, it can be necessary to check, which persons are missing.</p>
</td></tr>
<tr><td><code id="long2matrix_+3A_skip3">skip3</code></td>
<td>
<p>Should groups with 3 or fewer participants be skipped? SRAs need groups with a minimum of 4 participants</p>
</td></tr>
<tr><td><code id="long2matrix_+3A_g.id">g.id</code></td>
<td>
<p>For internal use only</p>
</td></tr>
<tr><td><code id="long2matrix_+3A_exclude.ids">exclude.ids</code></td>
<td>
<p>A list of participant ids, which should be excluded</p>
</td></tr>
<tr><td><code id="long2matrix_+3A_...">...</code></td>
<td>
<p>Further undocumented or internal arguments passed to the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of quadratic matrix. Each list entry is one group, as specified by <code>group.id</code>. If only one group is present, this is stored in the first list entry.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matrix2long">matrix2long</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#load a data set in long style
data("multiGroup")

str(multiGroup)
qm &lt;- long2matrix(ex~perceiver.id*target.id|group.id, multiGroup)
qm[[2]]

# we see some warnings that some persons are only actors or only partners. 
# Let's check the data without removing them:
qm2 &lt;- long2matrix(ex~perceiver.id*target.id|group.id, multiGroup, reduce=FALSE)
qm2[[2]]
 
</code></pre>

<hr>
<h2 id='matrix2long'>Convert a quadratic matrix to long format</h2><span id='topic+matrix2long'></span>

<h3>Description</h3>

<p>This function converts data from a quadratic round robin matrix into long format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix2long(M, new.ids=TRUE, var.id="value")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix2long_+3A_m">M</code></td>
<td>
<p>A matrix with actors in rows and partners in columns)</p>
</td></tr>
<tr><td><code id="matrix2long_+3A_new.ids">new.ids</code></td>
<td>
<p>Should new ids for actors and partners be defined? (If new.ids=FALSE the row and column names are taken. In that case, you have to make sure, that rows and columns have the same set of names.)</p>
</td></tr>
<tr><td><code id="matrix2long_+3A_var.id">var.id</code></td>
<td>
<p>The name of the column with the measured variable in the returned data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame in long format
</p>


<h3>See Also</h3>

<p><code><a href="#topic+long2matrix">long2matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#The example data are taken from the "Mainz Freshman Study" and consist 
# of ratings of liking as well as ratings of the metaperception of 
# liking at zero-acquaintance using a Round-Robin group of 54 participants 
# (Back, Schmukle, &amp; Egloff, in pres)

# load a data set in matrix style
data("liking_a")

str(liking_a)
long &lt;- matrix2long(liking_a)

str(long)
 
</code></pre>

<hr>
<h2 id='parCor'>partial correlation</h2><span id='topic+parCor'></span>

<h3>Description</h3>

<p>Performs partial correlations between x and y, controlled for z.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parCor(x,y,z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parCor_+3A_x">x</code></td>
<td>
<p>First variable</p>
</td></tr> 
<tr><td><code id="parCor_+3A_y">y</code></td>
<td>
<p>Second variable</p>
</td></tr>
<tr><td><code id="parCor_+3A_z">z</code></td>
<td>
<p>Control variable. This variable is coerced into a factor; in the TripleR context z usually is the group id.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs partial correlations between x and y, controlled for z. The control variable is coerced into a factor; in the TripleR context z usually is the group id. Do <em>not</em> use this function with a continuous control variable - results will be wrong! Degrees of freedom for the <em>t</em> test are reduced by <em>g</em> - 1 (<em>g</em> is the number of groups).
</p>


<h3>Value</h3>

<table>
<tr><td><code>par.cor</code></td>
<td>
<p>partial correlation</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>degrees of freedom for the t test</p>
</td></tr>
<tr><td><code>t.value</code></td>
<td>
<p>t value</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>p value</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+RR">RR</a></code>, <code><a href="#topic+getEffects">getEffects</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(multiGroup)
data(multiNarc)

# the function 'head' shows the first few lines of a data structure:
head(multiNarc)

# calculate SRA effects for extraversion ratings
RR.style("p")
RR1 &lt;- RR(ex ~ perceiver.id * target.id | group.id, multiGroup, na.rm=TRUE)

# merge variables to one data set
dat &lt;- merge(RR1$effects, multiNarc, by="id")

# We now have a combined data set with SRA effects and external self ratings:
head(dat)

# function parCor(x, y, z) computes partial correlation between x and y, 
# controlled for group membership z
d1 &lt;- parCor(dat$ex.t, dat$narc, dat$group.id)
d1


# disattenuate for target effect reliability
parCor2 &lt;- d1$par.cor * (1/sqrt(attr(RR1$effects$ex.t, "reliability")))
parCor2
</code></pre>

<hr>
<h2 id='plot_missings'>Plot missing values</h2><span id='topic+plot_missings'></span>

<h3>Description</h3>

<p>This function plots missing values in the round robin matrix for visual inspection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_missings(formule, data, show.ids=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_missings_+3A_formule">formule</code></td>
<td>
<p>A formula specifying the variable names. Example usage: <code>DV ~ perceiver.id*target.id | group.id</code> (group.id only necessary in multi group data sets)</p>
</td></tr>
<tr><td><code id="plot_missings_+3A_data">data</code></td>
<td>
<p>The data frame</p>
</td></tr>   
<tr><td><code id="plot_missings_+3A_show.ids">show.ids</code></td>
<td>
<p>Should the id's of the persons be printed on the axes?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(multiGroup)
m2 &lt;- multiGroup
m2$ex[m2$perceiver.id==90201] &lt;- NA
m2$ex[m2$perceiver.id&gt;92001] &lt;- NA
m2$ex[sample(nrow(m2),  1000)] &lt;- NA
plot_missings(ex~perceiver.id*target.id|group.id, data=m2)
(RR1m &lt;- RR(ex~perceiver.id*target.id|group.id, data=m2, na.rm=TRUE))
</code></pre>

<hr>
<h2 id='plot.RRuni'>Plot variance components from SRAs</h2><span id='topic+plot.RRuni'></span><span id='topic+plot.RRbi'></span><span id='topic+plot.RRmulti'></span>

<h3>Description</h3>

<p>This function plots variance components for all RR objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RRuni'
plot(x, ..., measure=NA, geom="bar")
## S3 method for class 'RRmulti'
plot(x, ..., measure=NA, geom="scatter", conf.level=0.95, connect=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.RRuni_+3A_x">x</code></td>
<td>
<p>A RR results object</p>
</td></tr>
<tr><td><code id="plot.RRuni_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the plot function</p>
</td></tr>
<tr><td><code id="plot.RRuni_+3A_measure">measure</code></td>
<td>
<p>Sets the labels to &lsquo;behavior&rsquo; or &lsquo;perception&rsquo;; if no parameter is provided the function uses the defaults from RR.style</p>
</td></tr>   
<tr><td><code id="plot.RRuni_+3A_geom">geom</code></td>
<td>
<p>Style of plot: set &lsquo;bar&rsquo; or &lsquo;pie&rsquo; for single groups; &lsquo;scatter&rsquo; or &lsquo;bar&rsquo; for multiple groups</p>
</td></tr>
<tr><td><code id="plot.RRuni_+3A_conf.level">conf.level</code></td>
<td>
<p>Confidence level for error bars in the scatter style</p>
</td></tr>
<tr><td><code id="plot.RRuni_+3A_connect">connect</code></td>
<td>
<p>Should dots for variance components of each group be connected? (Looks usually very cluttered ...)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object is returned - that means, you can subsequently adjust the scale labels, etc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	data(likingLong)
	RR1 &lt;- RR(liking_a ~ perceiver.id*target.id, data=likingLong)
	plot(RR1)
	plot(RR1, geom="pie")
	
	RR2 &lt;- RR(liking_a + metaliking_a ~ perceiver.id*target.id, data=likingLong)
	plot(RR2)
	
	
	data("multiLikingLong")
	RR1m &lt;- RR(liking_a ~ perceiver.id*target.id|group.id, data=multiLikingLong)
	plot(RR1m)
	plot(RR1m, measure="perception")
	plot(RR1m, measure="perception", geom="bar")
	plot(RR1m, measure="perception", connect=TRUE)

	RR2m &lt;- RR(liking_a + metaliking_a ~ perceiver.id*target.id|group.id, data=multiLikingLong)
	plot(RR2m)

## End(Not run)
</code></pre>

<hr>
<h2 id='RR'>Triple R: Round-Robin Analyses Using R</h2><span id='topic+RR'></span><span id='topic+liking_a'></span><span id='topic+likingLong'></span><span id='topic+multiLikingLong'></span><span id='topic+liking_b'></span><span id='topic+metaliking_a'></span><span id='topic+metaliking_b'></span><span id='topic+multiGroup'></span><span id='topic+multiNarc'></span>

<h3>Description</h3>

<p>The function RR performs Social Relation Model (SRM) analyses for single or multiple round-robin groups. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RR(formula, data, na.rm=FALSE, minData=1, verbose=TRUE, g.id=NULL, index="", 
	exclude.ids="", varname=NA, se="LashleyBond", minVar=localOptions$minVar, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RR_+3A_formula">formula</code></td>
<td>
<p>a formula (see details) consisting of a measure (e.g. a rating) obtained with a round-robin group</p>
</td></tr> 
<tr><td><code id="RR_+3A_data">data</code></td>
<td>
<p>A data frame in long format</p>
</td></tr>
<tr><td><code id="RR_+3A_na.rm">na.rm</code></td>
<td>
<p>If missing values are present, you have to set this parameter to TRUE</p>
</td></tr>
<tr><td><code id="RR_+3A_mindata">minData</code></td>
<td>
<p>Sets the minimum of data points which have to be present in each row and column</p>
</td></tr>
<tr><td><code id="RR_+3A_verbose">verbose</code></td>
<td>
<p>Defines if warnings and additional information should be printed on execution</p>
</td></tr>
<tr><td><code id="RR_+3A_g.id">g.id</code></td>
<td>
<p>For internal use only; do not set this parameter</p>
</td></tr>
<tr><td><code id="RR_+3A_index">index</code></td>
<td>
<p>set <code>index = 'enhance'</code> for additionally requesting an index for self enhancement (self rating - perceiver effect - target effect - group mean of self ratings; Kwan, John, Kenny, Bond, &amp; Robins, 2004) along with the actor and partner effects.</p>
</td></tr>
<tr><td><code id="RR_+3A_exclude.ids">exclude.ids</code></td>
<td>
<p>For internal use only; do not set this parameter</p>
</td></tr>
<tr><td><code id="RR_+3A_varname">varname</code></td>
<td>
<p>The name stem of the effects variables. By default, this is the first variable passed in the formula. In case of latent constructs, however, it might be preferable to set a new name for the latent construct.</p>
</td></tr>
<tr><td><code id="RR_+3A_se">se</code></td>
<td>
<p>This defines how significance tests are computed in the multi-group case. Either &quot;LashleyBond&quot; (= recommended significancetest by Lashley &amp; Bond, 1997; default) or &quot;SOREMO&quot; (= between group significance test as implemented in SOREMO). In single groups, always the Lashley-Bond standard errors and significance tests are provided.</p>
</td></tr>
<tr><td><code id="RR_+3A_minvar">minVar</code></td>
<td>
<p>Actor and partners effects are only calculated if the respective relative variance component is greater than minVar. Set minVar to NA if this cleaning should not be performed. For small groups, Kenny (1994) suggests a minimum relative variance of 10% for the interpretation of SRM effects. In any case, actor/ partner effects and correlations with these variables should not be interpreted if these components have negative variance estimates. minVar defaults to zero; with RR.style this default can be changed for all subsequent analyses.</p>
</td></tr>
<tr><td><code id="RR_+3A_...">...</code></td>
<td>
<p>Further undocumented or internal arguments passed to the function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please note: detailed instructions on how to use the TripleR package are provided in the built in pdf document &lsquo;How to use TripleR&rsquo;. You can open this document either by on this link: <a href="../doc/TripleR.pdf">../doc/TripleR.pdf</a>, or you can browse all included vignettes by opening the index of the package documentation (scroll down to the very end of this page and click on &lsquo;Index&rsquo;; than click on &lsquo;Overview of user guides and package vignettes&rsquo;). These help files are only for quick references.
</p>
<p>The estimation of the parameters of the Social Relation Model (SRM) is based on formulae provided by Kenny (1994; p. 236-244). If multiple groups are provided, SRMs are computed within each single group. Variance components then are calculated as the weighted average across groups (weighted with N – 1). Please note that in case of largely varying group sizes a precision weighting based on  inverse-variance weights might be preferable but is not currently implemented in TripleR.
For tests of significance of a single group, Triple R computes standard errors by using formulae published by Bond and Lashley (1996) for the case of a univariate SRM analysis. The formulae for the standard errors of the bivariate SRM parameters were kindly provided to us by C.F. Bond in personal communication. If multiple groups are provided, by default the standard error is computed as the square root of the weighted mean of the squared group-specific standard errors, as recommended by Lashley and Bond (1997). For <code>se = “SOREMO”</code> a between-group t-test is employed to calculate the significance which was suggested by Kenny and La Voie (1984) and is used in the software SOREMO.
</p>
<p>The Bond-Lashley standard errors operate under the assumption that the only source of variance in the SRM parameter is sampling error, i.e. that variance estimates do not differ systematically between groups. Lashley and Kenny (1998) found that this assumption was basically true in 13 different round robin studies. Thus, we generally recommend using the Bond-Lashley standard errors (<code>se="LashleyBond"</code>), which are more powerful than the Kenny-La Voie standard errors (<code>se="SOREMO"</code>), see Lashley and Bond (1997) and Lashley and Kenny (1998). However, in case that you have reasons to assume that variances systematically vary across groups, the Kenny-La Voie standard errors (<code>se="SOREMO"</code>) might be preferable as they are likely more robust in the presence of group effects (Lashley &amp; Kenny, 1998).
</p>
<p>The formula to specify the round robin design has following notation:
<code>DV ~ perceiver.id * target.id | group.id</code> (group.id is only provided if multiple groups are present). If two variables are used to describe one latent construct, both are connected with a slash on the left hand side: <code>DV1a/DV1b ~ perceiver.id * target.id</code>. If two variables are used to describe two manifest constructs, both are connected with a <code>+</code> on the left hand side: <code>DV1+DV2 ~ perceiver.id * target.id</code>. A latent analysis of two constructs would be notated as following: <code>DV1a/DV1b + DV2a/DV2b ~ perceiver.id * target.id</code>.
</p>
<p>Data sets from the Mainz Freshman Study (see Back, Schmukle, &amp; Egloff, in press) are included (liking_a, liking_b, metaliking_a, metaliking_b, likingLong), as well as an additional data set containing missing values (multiGroup)
</p>
<p>The handling for missing data (<code>na.rm=TRUE</code>) is performed in three steps:
</p>

<ul>
<li><p> Rows and columns which have less then <code>minData</code> data points are removed from the matrix (i.e. both the &lsquo;missing&rsquo; row or column and the corresponding column or row, even if they have data in them)
</p>
</li>
<li><p> For the calculation of actor and partner variances, actor-partner-covariances and the respective effects, missing values are imputed as the average of the respective row and col means. The calculation of relationship variances and covariances as well as relationship effects is also based on the imputed data set; however, single relationship effects which were missing in the original data set are set to missing again.
</p>
</li>
<li><p> In the case of multiple variables (i.e., latent or bivariate analyses), participants are excluded listwise to ensure that all analyses are based on the same data set.
</p>
</li></ul>



<h3>Value</h3>

<p>Printed are both unstandardized and standardized SRM estimates with the corresponding standard errors and t-values for actor variance, partner variance, relationship variance, error variance, actor-partner covariance, and relationship covariance. In case of a bivariate analysis values are additionally provided for actor-actor covariance, partner-partner covariance, actor-partner covariance, partner-actor covariance, intrapersonal relationship covariance, and interpersonal relationship covariance.
</p>
<p>Reliabilities of actor, partner, and relationship effects (the latter only in the case of latent analyses) are printed according to Bonito &amp; Kenny (2010).
</p>
<p>The returned values depend on the kind of analyses that is performed:
</p>
<p>Univariate, single group:
</p>
<table>
<tr><td><code>effects</code></td>
<td>
<p>actor and partner effects for all participants; if self ratings are provided they also are returned as group mean centered values</p>
</td></tr>
<tr><td><code>effects.gm</code></td>
<td>
<p>actor and partner effects for all participants, group mean added</p>
</td></tr>
<tr><td><code>effectsRel</code></td>
<td>
<p>relationship effects for all participants</p>
</td></tr>
<tr><td><code>varComp</code></td>
<td>
<p>variance components</p>
</td></tr>
</table>
<p>Bivariate, single group:
</p>
<table>
<tr><td><code>univariate</code></td>
<td>
<p>List of results of univariate of SRM analyses of both variables- specify variable in index: univariate[[1]] or univariate[[2]]. That means, each of the both <code>univariate</code> objects is a complete RR object for the univariate analyses, nested in the results objects. If you want to retrieve the effects for the first variable, you have to type <code>RR2$univariate[[1]]$effects</code>. If you want to retrieve the variance components, you have to type <code>RR2$univariate[[1]]$varComp</code></p>
</td></tr>
<tr><td><code>bivariate</code></td>
<td>
<p>Results of bivariate SRM analyses</p>
</td></tr>
</table>
<p>In the multiple group case, following values are returned:
</p>
<table>
<tr><td><code>univariate</code></td>
<td>
<p>The weighted average of univariate SRM results</p>
</td></tr>
<tr><td><code>bivariate</code></td>
<td>
<p>The weighted average of bivariate SRM results</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>SRM results for each group</p>
</td></tr>
<tr><td><code>effects</code></td>
<td>
<p>actor and partner effects for all participants</p>
</td></tr>
<tr><td><code>effectsRel</code></td>
<td>
<p>relationship effects for all participants</p>
</td></tr>
<tr><td><code>varComp.group</code></td>
<td>
<p>a list of variance components in all single groups</p>
</td></tr>
<tr><td><code>group.var</code></td>
<td>
<p>group variance estimate</p>
</td></tr>
</table>
<p>If self ratings are present in the data set, the function also prints the correlation between self ratings and actor/partner effects. In case of multiple groups, these are corrected for group membership (partial correlations). These correlations with self-ratings can also directly be computed with the function <code><a href="#topic+selfCor">selfCor</a></code>. Partial correlations to external (non-SRM) variables can be computed with the function <code><a href="#topic+parCor">parCor</a></code>
</p>


<h3>Note</h3>

<p>In case that a behavior was measured, the variances of an SRM analysis are labeled as actor variance, partner variance and relationship variance (default output labels). In case that a perception was measured, perceiver is printed instead of actor and target is printed instead of partner. You can set appropriate output labels by using the function <code><a href="#topic+RR.style">RR.style</a></code>.
These settings from RR.style, however, can be overwritten for each <code>print</code> call: :
</p>

<ul>
<li> <p><code>print(RRobject, measure1="behavior")</code>: prints output for a univariate analysis of behavior data.
</p>
</li>
<li> <p><code>print(RRobject, measure1="perception")</code>: prints output for a univariate analysis of perception data.
</p>
</li>
<li> <p><code>print(RRobject, measure1="behavior", measure2="behavior")</code>: prints output for a bivariate analysis of behavior data.
</p>
</li>
<li> <p><code>print(RRobject, measure1="perception", measure2="perception")</code>: prints output for a bivariate analysis of perception data.
</p>
</li>
<li> <p><code>print(RRobject, measure1="behavior", measure2="perception")</code> or <br />
<code>print(RRobject, measure1="perception", measure2="behavior")</code>: prints output for a bivariate analysis of behavior and perception data.
</p>
</li>
<li> <p><code>print(RRobject, measure1="perception", measure2="metaperception")</code>: is for the special case that a perception and a corresponding metaperception was measured. In this case, additionally the appropriate output labels for bivariate SRM analyses of other- and metaperceptions (reciprocities, assumed reciprocities, meta-accuracies; see Kenny, 1994) are presented.
</p>
</li>
<li> <p><code>print(RRobject, digits=6)</code>: Provide the number of displayed digits.
</p>
</li></ul>

<p>You can plot any RR object using <code>plot(RR)</code>. See <code><a href="#topic+plot.RRuni">plot.RRuni</a></code> for possible parameters.
</p>


<h3>Author(s)</h3>

<p>Felix D. Schönbrodt, Mitja D. Back, Stefan C. Schmukle</p>


<h3>References</h3>

<p>The main reference for the TripleR package is:
</p>

<ul>
<li><p>Schönbrodt, F. D., Back, M. D., &amp; Schmukle, S. C. (2012). TripleR: An R package for social relations analyses based on round-robin designs. <em>Behavior Research Methods, 44</em>, 455-470. doi:10.3758/s13428-011-0150-4
</p>
</li></ul>

<p>Please cite this paper if you use TripleR in your research.
</p>
<p>Further information on SRM and its application:
</p>
  
<ul>
<li><p>Back, M. D., Schmukle, S. C. &amp; Egloff, B. (2011). A closer look at first sight: Social relations lens model analyses of personality and interpersonal attraction at zero acquaintance. <em>European Journal of Personality, 25</em>, 225-238. doi:10.1002/per.790
</p>
</li>
<li><p>Bond, C. F., Jr., &amp; Lashley, B. R. (1996). Round-robin analysis of social interaction: Exact and estimated standard errors. <em>Psychometrika, 61</em>, 303-311. doi:10.1007/BF02294341
</p>
</li>
<li><p>Bonito, J. A., &amp; Kenny, D. A. (2010). The measurement of reliability of social relations components from round-robin designs. <em>Personal Relationships, 17</em>, 235 - 251. doi:10.1111/j.1475-6811.2010.01274.x
</p>
</li>
<li><p>Kenny, D. A. (1994). <em>Interpersonal perception: A social relations analysis</em>. New York: Guilford Press.
</p>
</li>
<li><p>Kenny, D. A., &amp; La Voie, L. J. (1984). The social relations model. In L. Berkowitz (Ed.),<em> Advances in experimental social psychology</em> (Vol. 18, pp. 142-182). San Diego, CA: Academic Press.
</p>
</li>
<li><p>Kwan, V. S. Y., John, O. P., Kenny, D. A., Bond, M. H., &amp; Robins, R. W. (2004). Reconceptualizing individual differences in self-enhancement bias: An interpersonal approach. <em>Psychological Review, 111</em>, 94–110. doi:10.1037/0033-295X.111.1.94
</p>
</li>
<li><p>Lashley, B. R., &amp; Bond, C. F., Jr. (1997). Significance testing for round robin data. <em>Psychological Methods</em>, <em>2</em>, 278-291. doi:10.1037/1082-989X.2.3.278
</p>
</li>
<li><p>Lashley, B. R. &amp; Kenny, D. A. (1998). Power estimation in social relations analyses. <em>Psychological Methods, 3</em>, 328-338. doi:10.1037/1082-989X.3.3.328
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+RR.style">RR.style</a></code>, <code><a href="#topic+getEffects">getEffects</a></code>, <code><a href="#topic+plot_missings">plot_missings</a></code>, <code><a href="#topic+long2matrix">long2matrix</a></code>, <code><a href="#topic+matrix2long">matrix2long</a></code>, <code><a href="#topic+plot.RRuni">plot.RRuni</a></code>, <code><a href="#topic+RR.summary">RR.summary</a></code>, <code><a href="#topic+selfCor">selfCor</a></code>, <code><a href="#topic+parCor">parCor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The example data are taken from the "Mainz Freshman Study" and consist 
# of ratings of liking as well as ratings of the metaperception of 
# liking at zero-acquaintance using a Round-Robin group of 54 participants 

#------------------------------------------------------------
# ----  Single group   --------------------------------------
#------------------------------------------------------------

# Load data frame in long format - it contains 4 variables:
#liking ratings indicator a (liking_a, "How likeable do you find this person?")  
#liking ratings indicator b (liking_b, "Would you like to get to know this person?")
#metaliking ratings indicator a (metaliking_a, "How likeable does this person find you?")
#metaliking ratings indicator b (metaliking_b, "Would this person like to get to know you?")
data("likingLong")

#manifest univariate SRM analysis
RR1 &lt;- RR(liking_a ~ perceiver.id*target.id, data=likingLong)

## Not run: 
#manifest bivariate SRM analysis
RR2 &lt;- RR(liking_a + metaliking_a ~ perceiver.id*target.id, data=likingLong)

#latent (construct-level) univariate SRM analysis
RR3 &lt;- RR(liking_a / liking_b ~ perceiver.id*target.id, data=likingLong)

#latent (construct-level) univariate SRM analysis, define new variable name for the latent construct
RR3b &lt;- RR(liking_a / liking_b ~ perceiver.id*target.id, data=likingLong, varname="liking")
# compare:
head(RR3$effects)
head(RR3b$effects)

#latent (construct-level) bivariate SRM analysis
RR4 &lt;- RR(liking_a/liking_b + metaliking_a/metaliking_b ~ perceiver.id*target.id, data=likingLong)


# prints output of the manifest univariate analysis
# in terms of actor and partner variance (default output labels)
print(RR1, measure1="behavior") 

# prints output of the manifest univariate analysis 
# in terms of perceiver and target variance (appropriate for perception data)
print(RR1, measure1="perception")

# prints output of the manifest bivariate SRM analysis appropriate 
# for perception-metaperception data  
print(RR2, measure1="perception", measure2="metaperception")

#prints output of the latent univariate SRM analysis
# appropriate for perception data  
print(RR3, measure1="perception") 

#prints output of the latent bivariate SRM analysis
# appropriate for perception-perception data  
# Note: you can use abbreviations of the strings "behavior", "perception", and "metaperception"
print(RR4, measure1="p", measure2="p") 

## End(Not run)


#------------------------------------------------------------
# ----  Multiple groups --------------------------------------
#------------------------------------------------------------

# data("multiLikingLong") is a variant of the liking data set (see above) with multiple groups
data("multiLikingLong")

# set RR.style to "perception" (affects subsequent printing of objects)
RR.style("perception")

#manifest univariate SRM analysis
RR1m &lt;- RR(liking_a ~ perceiver.id*target.id|group.id, data=multiLikingLong)

## Not run: 
#manifest bivariate SRM analysis
RR2m &lt;- RR(liking_a + metaliking_a ~ perceiver.id*target.id|group.id, data=multiLikingLong)

#latent (construct-level) univariate SRM analysis
RR3m &lt;- RR(liking_a / liking_b ~ perceiver.id*target.id|group.id, data=multiLikingLong)

#latent (construct-level) bivariate SRM analysis
RR4m &lt;- RR(liking_a/liking_b + metaliking_a/metaliking_b ~ perceiver.id*target.id|group.id,
		 		data=multiLikingLong)

# prints output of the manifest univariate analysis
# in terms of actor and partner variance (default output labels)
print(RR1m, measure1="behavior") 

# prints output of the manifest univariate analysis 
# in terms of perceiver and target variance (appropriate for perception data)
print(RR1m, measure1="perception")


#------------------------------------------------------------
# ----  Multiple groups with missing values --------------------------------------
#------------------------------------------------------------

# a multi group data set with two variables:
# ex = extraversion ratings, and ne = neurotizism ratings
data("multiGroup")

#manifest univariate SRM analysis, data set with missings
RR1miss &lt;- RR(ex~perceiver.id*target.id|group.id, data=multiGroup, na.rm=TRUE)

#manifest univariate SRM analysis, data set with missings, 
# minimum 10 data points are requested for each participant
RR1miss &lt;- RR(ex~perceiver.id*target.id|group.id, data=multiGroup, na.rm=TRUE, minData=10)

## End(Not run)

</code></pre>

<hr>
<h2 id='RR.style'>Set labeling styles for RR analyses</h2><span id='topic+RR.style'></span>

<h3>Description</h3>

<p>This function sets labels for the printing of RR-objects and for plots. All subsequent calls of RR will be produced in this style (until another style is set). That means, usually you only have to define this style once at the start of your project.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RR.style(style="behavior", suffixes=NA, minVar=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RR.style_+3A_style">style</code></td>
<td>
<p>a string defining the labeling style - either &lsquo;behavior&rsquo; or &lsquo;perception&rsquo;.</p>
</td></tr> 
<tr><td><code id="RR.style_+3A_suffixes">suffixes</code></td>
<td>
<p>Which suffixes should be append to the actor and partner effects, and to the self ratings? Default is <code>.a</code>, <code>.p</code>, and <code>.s</code>, for actor/ partner/ self in the case of behavior, or <code>.p</code>, <code>.t</code>, and <code>.s</code>, for perceiver/ target/ self in the case of perceptions. If no suffixes are provided in the parameters, these defaults are taken depending on the <code>style</code> parameter</p>
</td></tr> 
<tr><td><code id="RR.style_+3A_minvar">minVar</code></td>
<td>
<p>Set the minVar parameter for all subsequent analyses. See <code><a href="#topic+RR">RR</a></code> for details on this parameter.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>Printing options and naming conventions are set for all subsequent analyses. If you specify other styles in a print.RR call, this setting temporarily overwrites the settings from RR.style (without changing them).
</p>


<h3>Author(s)</h3>

<p>Felix D. Schönbrodt</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("likingLong")

RR.style("behavior")
RR(liking_a ~ perceiver.id*target.id, data=likingLong)

RR.style("p")	# a "p" is enough for "perception"
RR(liking_a ~ perceiver.id*target.id, data=likingLong)

</code></pre>

<hr>
<h2 id='RR.summary'>Print group descriptives</h2><span id='topic+RR.summary'></span>

<h3>Description</h3>

<p>Shows descriptives for multiple groups (how many groups, which groups are excluded, group sizes)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RR.summary(formule, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RR.summary_+3A_formule">formule</code></td>
<td>
<p>A formula specifying the variable names. Example usage: <code>DV ~ perceiver.id*target.id | group.id</code> (group.id only necessary in multi group data sets)</p>
</td></tr>
<tr><td><code id="RR.summary_+3A_data">data</code></td>
<td>
<p>A data frame in long format)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Printed output
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("multiGroup")
RR.summary(ex~perceiver.id*target.id|group.id, data=multiGroup) 
</code></pre>

<hr>
<h2 id='selfCor'>partial correlation</h2><span id='topic+selfCor'></span>

<h3>Description</h3>

<p>Performs partial correlations between x and y, controlled for z.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selfCor(x, digits=3, measure=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selfCor_+3A_x">x</code></td>
<td>
<p>An RR object</p>
</td></tr> 
<tr><td><code id="selfCor_+3A_digits">digits</code></td>
<td>
<p>Digits to which values are rounded in the output</p>
</td></tr>
<tr><td><code id="selfCor_+3A_measure">measure</code></td>
<td>
<p>Either &quot;behavior&quot; or &quot;percetion&quot;. Only affects labeling of output; if NA, the current setting of RR.style is taken as default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints correlations between self ratings (if present in the round robin matrices) and SRA effects. In case of multiple groups, partial correlations are printed (controlled for group membership).
The output of selfCor is also printed in the standard RR-ouput.
</p>


<h3>Value</h3>

<p>A data frame with correlation coefficients and p values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RR">RR</a></code>, <code><a href="#topic+getEffects">getEffects</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(multiGroup)

RR.style("p")
# a single group
RR1 &lt;- RR(ex~perceiver.id*target.id, data=multiGroup[multiGroup$group.id=="2", ], na.rm=TRUE)
selfCor(RR1)

# multiple groups
RR2 &lt;- RR(ex~perceiver.id*target.id|group.id, data=multiGroup, na.rm=TRUE)
selfCor(RR2)

</code></pre>

<hr>
<h2 id='TripleR-package'>Triple R: A Package for Round-Robin Analyses Using R</h2><span id='topic+TripleR-package'></span><span id='topic+TripleR'></span>

<h3>Description</h3>

<p>Social Relation Model (SRM) analyses for single or multiple round-robin groups are performed. These analyses are either based on one manifest variable, one latent construct measured by two manifest variables, two manifest variables and their bivariate relations, or bivariate relations between two latent constructs each measured by two manifest variables.
</p>


<h3>Details</h3>

<p>For further information of usage see <code><a href="#topic+RR">RR</a></code> or the built in pdf document &lsquo;How to use TripleR&rsquo;. You can browse all included vignettes by opening the index of the package documentation (scroll down to the very end of this page and click on &lsquo;Index&rsquo;; than click on &lsquo;Overview of user guides and package vignettes&rsquo;).
</p>
<p>If you use this package in your research, please cite it as:
Schönbrodt, F. D., Back, M. D., &amp; Schmukle, S. C. (2012). TripleR: An R package for social relations analyses based on round-robin designs. <em>Behavior Research Methods, 44</em>, 455–470. doi:10.3758/s13428-011-0150-4
</p>


<h3>Author(s)</h3>

<p>Felix D. Schönbrodt, Mitja D. Back, &amp; Stefan C. Schmukle
</p>


<h3>References</h3>

<p>Further information on SRM and its application:
</p>
  
<ul>
<li><p>Back, M. D., Schmukle, S. C. &amp; Egloff, B. (2011). A closer look at first sight: Social relations lens model analyses of personality and interpersonal attraction at zero acquaintance. <em>European Journal of Personality, 25</em>, 225-238. doi:10.1002/per.790
</p>
</li>
<li><p>Bond, C. F., Jr., &amp; Lashley, B. R. (1996). Round-robin analysis of social interaction: Exact and estimated standard errors. <em>Psychometrika, 61</em>, 303-311. doi:10.1007/BF02294341
</p>
</li>
<li><p>Bonito, J. A., &amp; Kenny, D. A. (2010). The measurement of reliability of social relations components from round-robin designs. <em>Personal Relationships, 17</em>, 235 - 251. doi:10.1111/j.1475-6811.2010.01274.x
</p>
</li>
<li><p>Kenny, D. A. (1994). <em>Interpersonal perception: A social relations analysis</em>. New York: Guilford Press.
</p>
</li>
<li><p>Kenny, D. A., &amp; La Voie, L. J. (1984). The social relations model. In L. Berkowitz (Ed.),<em> Advances in experimental social psychology</em> (Vol. 18, pp. 142-182). San Diego, CA: Academic Press.
</p>
</li>
<li><p>Kwan, V. S. Y., John, O. P., Kenny, D. A., Bond, M. H., &amp; Robins, R. W. (2004). Reconceptualizing individual differences in self-enhancement bias: An interpersonal approach. <em>Psychological Review, 111</em>, 94–110. doi:10.1037/0033-295X.111.1.94
</p>
</li>
<li><p>Lashley, B. R., &amp; Bond, C. F., Jr. (1997). Significance testing for round robin data. <em>Psychological Methods</em>, <em>2</em>, 278-291. doi:10.1037/1082-989X.2.3.278 
</p>
</li>
<li><p>Lashley, B. R. &amp; Kenny, D. A. (1998). Power estimation in social relations analyses. <em>Psychological Methods, 3</em>, 328-338. doi:10.1037/1082-989X.3.3.328
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
