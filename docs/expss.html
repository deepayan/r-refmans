<!DOCTYPE html><html><head><title>Help for package expss</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {expss}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_columns'><p>Add columns to data.frame.</p></a></li>
<li><a href='#add_rows'><p>Add rows to data.frame/matrix/table</p></a></li>
<li><a href='#apply_labels'><p>Set variable labels/value labels on variables in the data.frame</p></a></li>
<li><a href='#as_huxtable.etable'><p>Convert table to huxtable</p></a></li>
<li><a href='#as.category'><p>Convert dichotomy data.frame/matrix to data.frame with category encoding</p></a></li>
<li><a href='#as.datatable_widget'><p>Create an HTML table widget for usage with Shiny</p></a></li>
<li><a href='#as.dichotomy'><p>Convert variable (possibly multiple choice question) to data.frame/matrix of dummy variables.</p></a></li>
<li><a href='#as.etable'><p>Convert data.frame/matrix to object of class 'etable'</p></a></li>
<li><a href='#as.labelled'><p>Recode vector into numeric vector with value labels</p></a></li>
<li><a href='#compare_proportions'><p>Calculate significance (p-values) of differences between proportions/means</p></a></li>
<li><a href='#compute'><p>Modify data.frame/modify subset of the data.frame</p></a></li>
<li><a href='#count_if'><p>Count/sum/average/other functions on values that meet a criterion</p></a></li>
<li><a href='#criteria'><p>Criteria functions</p></a></li>
<li><a href='#cross_cases'><p>Cross tabulation with support of labels, weights and multiple response variables.</p></a></li>
<li><a href='#cross_fun'><p>Cross-tabulation with custom summary function.</p></a></li>
<li><a href='#do_repeat'><p>Repeats the same transformations on a specified set of variables/values</p></a></li>
<li><a href='#drop_empty_rows'><p>Drop empty (with all NA's) rows/columns from data.frame/table</p></a></li>
<li><a href='#expss'><p>expss: Tables with Labels and Some Useful Functions from Spreadsheets and SPSS Statistics</p></a></li>
<li><a href='#expss.options'><p>Options for controlling behavior of the package</p></a></li>
<li><a href='#fctr'><p>Convert labelled variable to factor</p></a></li>
<li><a href='#fre'><p>Simple frequencies with support of labels, weights and multiple response variables.</p></a></li>
<li><a href='#htmlTable.etable'><p>Outputting HTML tables in RStudio viewer/R Notebooks</p></a></li>
<li><a href='#if_na'><p>Replace values with NA and vice-versa</p></a></li>
<li><a href='#info'><p>Provides variables description for dataset</p></a></li>
<li><a href='#keep'><p>Keep or drop elements by name/criteria in data.frame/matrix</p></a></li>
<li><a href='#match_row'><p>Match finds value in rows or columns/index returns value by index from rows or columns</p></a></li>
<li><a href='#merge.etable'><p>Merge two tables/data.frames</p></a></li>
<li><a href='#mrset'><p>Create multiple response set/multiple dichotomy set from variables</p></a></li>
<li><a href='#name_dots'><p>Bug workaround</p></a></li>
<li><a href='#names2labels'><p>Replace data.frame/list names with corresponding variables labels.</p></a></li>
<li><a href='#nest'><p>Compute nested variable(-s) from several variables</p></a></li>
<li><a href='#net'><p>Add subtotal to a set of categories</p></a></li>
<li><a href='#prepend_values'><p>Prepend values/variable names to value/variable labels</p></a></li>
<li><a href='#product_test'><p>Data from product test of chocolate confectionary</p></a></li>
<li><a href='#prop'><p>Compute proportions from numeric vector/matrix/data.frame</p></a></li>
<li><a href='#qc'><p>Create vector of characters from unquoted strings (variable names)</p></a></li>
<li><a href='#read_spss'><p>Read an SPSS Data File</p></a></li>
<li><a href='#recode'><p>Change, rearrange or consolidate the values of an existing or new variable. Inspired by the RECODE command from SPSS.</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#set_caption'><p>Add caption to the table</p></a></li>
<li><a href='#sheet'><p>Make data.frame without conversion to factors and without fixing names</p></a></li>
<li><a href='#sort_asc'><p>Sort data.frames/matrices/vectors</p></a></li>
<li><a href='#split_by'><p>Splits data.frame into list of data.frames that can be analyzed separately</p></a></li>
<li><a href='#split_labels'><p>Split character vector to matrix/split columns in data.frame</p></a></li>
<li><a href='#sum_row'><p>Compute sum/mean/sd/median/max/min/custom function on rows/columns</p></a></li>
<li><a href='#tab_significance_options'><p>Mark significant differences between columns in the table</p></a></li>
<li><a href='#tab_sort_asc'><p>Partially (inside blocks) sort tables/data.frames</p></a></li>
<li><a href='#tables'><p>Functions for custom tables construction</p></a></li>
<li><a href='#text_to_columns'><p>Make data.frame from text</p></a></li>
<li><a href='#unlab'><p>Drop variable label and value labels</p></a></li>
<li><a href='#val_lab'><p>Set or get value labels</p></a></li>
<li><a href='#values2labels'><p>Replace vector/matrix/data.frame/list values with corresponding value labels.</p></a></li>
<li><a href='#var_lab'><p>Set or get variable label</p></a></li>
<li><a href='#vars'><p>Get variables/range of variables by name/by pattern.</p></a></li>
<li><a href='#vectors'><p>Infix operations on vectors - append, diff, intersection, union, replication</p></a></li>
<li><a href='#w_mean'><p>Compute various weighted statistics</p></a></li>
<li><a href='#weight_by'><p>Create dataset according to its frequency weights</p></a></li>
<li><a href='#where'><p>Subset (filter) data.frames/matrices/vectors/lists</p></a></li>
<li><a href='#window_fun'><p>Function over grouping variables (window function)</p></a></li>
<li><a href='#write_labelled_csv'><p>Write labelled data to file or export file to SPSS syntax.</p></a></li>
<li><a href='#xl_write'><p>Write tables and other objects to an xlsx file with formatting</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tables, Labels and Some Useful Functions from Spreadsheets and
'SPSS' Statistics</td>
</tr>
<tr>
<td>Version:</td>
<td>0.11.6</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gregory Demin &lt;gdemin@gmail.com&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gdemin.github.io/expss/">https://gdemin.github.io/expss/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gdemin/expss/issues">https://github.com/gdemin/expss/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), maditr (&ge; 0.8.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, stats, data.table (&ge; 1.12.6), htmlTable (&ge; 1.11.0),
matrixStats (&ge; 0.51.0),</td>
</tr>
<tr>
<td>Suggests:</td>
<td>foreign, DT, htmltools, knitr, rmarkdown, repr, ggplot2,
testthat, openxlsx, fst, huxtable</td>
</tr>
<tr>
<td>Description:</td>
<td>Package computes and displays tables with support for 'SPSS'-style 
        labels, multiple and nested banners, weights, multiple-response variables 
        and significance testing. There are facilities for nice output of tables 
        in 'knitr', 'Shiny', '*.xlsx' files, R and 'Jupyter' notebooks. Methods 
        for labelled variables add value labels support to base R functions and to 
        some functions from other packages. Additionally, the package brings 
        popular data transformation functions from 'SPSS' Statistics and 'Excel': 
        'RECODE', 'COUNT', 'COUNTIF', 'VLOOKUP' and etc. 
        These functions are very useful for data processing in marketing research 
        surveys. Package intended to help people to move data 
        processing from 'Excel' and 'SPSS' to R.</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-12 21:54:02 UTC; gregory</td>
</tr>
<tr>
<td>Author:</td>
<td>Gregory Demin [aut, cre],
  Sebastian Jeworutzki
    <a href="https://orcid.org/0000-0002-2671-5253"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Dan Chaltiel [ctb],
  John Williams [ctb],
  Tom Elliott [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-15 21:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_columns'>Add columns to data.frame.</h2><span id='topic+add_columns'></span>

<h3>Description</h3>

<p><code>add_columns</code> inspired by MATCH FILES (Add
variables...) from SPSS Statistics. It works similar to SQL left join but
number of cases in the left part always remain the same. If there are
duplicated keys in the <code>y</code> then error will be raised by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_columns(x, y, by = NULL, ignore_duplicates = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_columns_+3A_x">x</code></td>
<td>
<p>data.frame to be joined with <code>y</code>.</p>
</td></tr>
<tr><td><code id="add_columns_+3A_y">y</code></td>
<td>
<p>data.frame.</p>
</td></tr>
<tr><td><code id="add_columns_+3A_by">by</code></td>
<td>
<p>character vector or NULL(default) or 1. Names of common variables
in the <code>x</code> and <code>y</code> by which we will attach <code>y</code> to
<code>x</code>. If it is NULL then common names will be used. If it is equals
to 1 then we will use the first column from both dataframes. To add columns
by different variables on <code>x</code> and <code>y</code> use a named vector.
For example, <code>by = c("a" = "b")</code> will match x.a to y.b.</p>
</td></tr>
<tr><td><code id="add_columns_+3A_ignore_duplicates">ignore_duplicates</code></td>
<td>
<p>logical Should we ignore duplicates in the <code>by</code>
variables in the <code>y</code>? If it is TRUE than first occurrence of duplicated
key will be used.</p>
</td></tr>
<tr><td><code id="add_columns_+3A_...">...</code></td>
<td>
<p>arguments for further methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# example for 'add_columns' from base 'merge'
authors = data.frame(
    surname = c("Tukey", "Venables", "Tierney", "Ripley", "McNeil"),
    nationality = c("US", "Australia", "US", "UK", "Australia"),
    deceased = c("yes", rep("no", 4))
)

books = data.frame(
    surname = c("Tukey", "Venables", "Tierney",
                "Ripley", "Ripley", "McNeil", "R Core"),
    title = c("Exploratory Data Analysis",
              "Modern Applied Statistics ...",
              "LISP-STAT",
              "Spatial Statistics", "Stochastic Simulation",
              "Interactive Data Analysis",
              "An Introduction to R")
)

add_columns(books, authors)

</code></pre>

<hr>
<h2 id='add_rows'>Add rows to data.frame/matrix/table</h2><span id='topic+add_rows'></span><span id='topic+add_rows.data.frame'></span>

<h3>Description</h3>

<p>Take a sequence of vector, matrix or data-frame arguments and combine by
rows. Contrary to <a href="base.html#topic+cbind">rbind</a> it handles non-matching column
names. 
There is also special method for the results of
<a href="#topic+cro">cro</a>/<a href="#topic+cro_fun">cro_fun</a>/<a href="#topic+tables">tables</a>/<a href="#topic+fre">fre</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_rows(...)

## S3 method for class 'data.frame'
add_rows(..., nomatch_columns = c("add", "drop", "stop"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_rows_+3A_...">...</code></td>
<td>
<p>data.frame/matrix/table for binding</p>
</td></tr>
<tr><td><code id="add_rows_+3A_nomatch_columns">nomatch_columns</code></td>
<td>
<p>action if there are non-matching columns between
data.frames. Possible values are <code>"add"</code>, <code>"drop"</code>, <code>"stop"</code>.
<code>"add"</code> will combine all columns, <code>"drop"</code> will leave only common
columns, <code>"stop"</code> will raise an error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See <a href="base.html#topic+cbind">rbind</a>, <a href="#topic+cro">cro</a>, <a href="#topic+cro_fun">cro_fun</a>, <a href="#topic+fre">fre</a>, <a href="#topic+tables">tables</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a = data.frame(x = 1:5, y = 6:10)
b = data.frame(y = 6:10, z = 11:15)

add_rows(a, b) # x, y, z

add_rows(a, b, nomatch_columns = "drop")  # y

</code></pre>

<hr>
<h2 id='apply_labels'>Set variable labels/value labels on variables in the data.frame</h2><span id='topic+apply_labels'></span>

<h3>Description</h3>

<p><code>apply_labels</code> tries automatically detect what is variable label and
what are value labels. See also <a href="#topic+var_lab">var_lab</a> and <a href="#topic+val_lab">val_lab</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_labels(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_labels_+3A_data">data</code></td>
<td>
<p>data.frame/list</p>
</td></tr>
<tr><td><code id="apply_labels_+3A_...">...</code></td>
<td>
<p>named arguments or lists. Name of argument is a variable name in
the <code>data</code>. Argument values are variable or value labels. Unnamed
characters of length 1 are considered as variable labels and named vectors
are considered as value labels. List arguments should be named lists and contain
value and variable labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data</code> with applied labels
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
mtcars = apply_labels(mtcars,
                      vs = "Engine",
                      vs = num_lab("
                             0 V-engine 
                             1 Straight engine
                             "),
                      am = "Transmission",
                      am = num_lab("
                             0 Automatic 
                             1 Manual
                             ")
)

# 'table' from base R
table(mtcars$vs, mtcars$am)

# more sophisticated crosstable
cross_cases(mtcars, vs, am)

# the same but with list argument
list_arg = list( vs = "Engine",
                 vs = num_lab("
                             0 V-engine 
                             1 Straight engine
                             "),
                 am = "Transmission",
                 am = num_lab("
                             0 Automatic 
                             1 Manual
                             ")
                 )

mtcars = apply_labels(mtcars, list_arg)

</code></pre>

<hr>
<h2 id='as_huxtable.etable'>Convert table to huxtable</h2><span id='topic+as_huxtable.etable'></span><span id='topic+as_hux.etable'></span>

<h3>Description</h3>

<p>This function converts a <code>etable</code> object to a <code>huxtable</code>.
The <code><a href="huxtable.html#topic+huxtable-package">huxtable-package</a></code> needs to be installed to use this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_huxtable.etable(x, ...)

as_hux.etable(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_huxtable.etable_+3A_x">x</code></td>
<td>
<p>etable. Table to convert to a huxtable.</p>
</td></tr>
<tr><td><code id="as_huxtable.etable_+3A_...">...</code></td>
<td>
<p>arguments passed on to <a href="huxtable.html#topic+huxtable">huxtable</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>huxtable</code> allows to export formated tables to LaTeX, HTML, Microsoft Word, 
Microsoft Excel, Microsoft Powerpoint, RTF and Markdown.
</p>
<p>Tables in knitr or rmarkdown documents of type LaTeX or Word 
are converted by default.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  
library(huxtable)
data(mtcars)
mtcars = apply_labels(mtcars,
                      mpg = "Miles/(US) gallon",
                      cyl = "Number of cylinders",
                      disp = "Displacement (cu.in.)",
                      hp = "Gross horsepower",
                      drat = "Rear axle ratio",
                      wt = "Weight (1000 lbs)",
                      qsec = "1/4 mile time",
                      vs = "Engine",
                      vs = c("V-engine" = 0,
                             "Straight engine" = 1),
                      am = "Transmission",
                      am = c("Automatic" = 0,
                             "Manual"=1),
                      gear = "Number of forward gears",
                      carb = "Number of carburetors"
)

tab = mtcars %&gt;% 
    tab_cols(total(), am %nest% vs) %&gt;% 
    tab_cells(mpg, hp) %&gt;% 
    tab_stat_mean() %&gt;% 
    tab_cells(cyl) %&gt;% 
    tab_stat_cpct() %&gt;% 
    tab_pivot() %&gt;% 
    set_caption("Table 1. Some variables from mtcars dataset.")

ht = as_huxtable(tab)
ht

## End(Not run)
</code></pre>

<hr>
<h2 id='as.category'>Convert dichotomy data.frame/matrix to data.frame with category encoding</h2><span id='topic+as.category'></span><span id='topic+is.category'></span>

<h3>Description</h3>

<p>Convert dichotomy data.frame/matrix to data.frame with category encoding
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.category(x, prefix = NULL, counted_value = 1, compress = FALSE)

is.category(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.category_+3A_x">x</code></td>
<td>
<p>Dichotomy data.frame/matrix (usually with 0,1 coding).</p>
</td></tr>
<tr><td><code id="as.category_+3A_prefix">prefix</code></td>
<td>
<p>If is not NULL then column names will be added in the form
prefix+column number.</p>
</td></tr>
<tr><td><code id="as.category_+3A_counted_value">counted_value</code></td>
<td>
<p>Vector. Values that will be considered as indicator 
of category presence. By default it equals to 1.</p>
</td></tr>
<tr><td><code id="as.category_+3A_compress">compress</code></td>
<td>
<p>Logical. Should we drop columns with all NA? FALSE by 
default. TRUE significantly decreases performance of the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame of class <code>category</code> with numeric values
that correspond to column numbers of counted values. Column names of x or
variable labels are added as value labels.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.dichotomy">as.dichotomy</a></code> for reverse conversion, <a href="#topic+mrset">mrset</a>,
<a href="#topic+mdset">mdset</a> for usage multiple-response variables with tables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)

# Let's imagine it's matrix of consumed products
dichotomy_matrix = matrix(sample(0:1,40,replace = TRUE,prob=c(.6,.4)),nrow=10)
colnames(dichotomy_matrix) = c("Milk","Sugar","Tea","Coffee")

as.category(dichotomy_matrix, compress = TRUE) # compressed version
category_encoding = as.category(dichotomy_matrix)

 # should be TRUE
identical(val_lab(category_encoding), c(Milk = 1L, Sugar = 2L, Tea = 3L, Coffee = 4L))
all(as.dichotomy(category_encoding, use_na = FALSE) == dichotomy_matrix)

# with prefix
as.category(dichotomy_matrix, prefix = "products_")

# data.frame with variable labels
dichotomy_dataframe = as.data.frame(dichotomy_matrix)
colnames(dichotomy_dataframe) = paste0("product_", 1:4)
var_lab(dichotomy_dataframe[[1]]) = "Milk"
var_lab(dichotomy_dataframe[[2]]) = "Sugar"
var_lab(dichotomy_dataframe[[3]]) = "Tea"
var_lab(dichotomy_dataframe[[4]]) = "Coffee"

as.category(dichotomy_dataframe, prefix = "products_")

</code></pre>

<hr>
<h2 id='as.datatable_widget'>Create an HTML table widget for usage with Shiny</h2><span id='topic+as.datatable_widget'></span><span id='topic+as.datatable_widget.etable'></span><span id='topic+as.datatable_widget.with_caption'></span>

<h3>Description</h3>

<p>This is method for rendering results of <a href="#topic+tables">tables</a>/<a href="#topic+fre">fre</a>/<a href="#topic+cro">cro</a>
in Shiny. <code>DT</code> package should be installed for this
feature (<code>install.packages('DT')</code>). For detailed description of function
and its arguments see <a href="DT.html#topic+datatable">datatable</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.datatable_widget(data, ...)

## S3 method for class 'etable'
as.datatable_widget(
  data,
  ...,
  repeat_row_labels = FALSE,
  show_row_numbers = FALSE,
  digits = get_expss_digits()
)

## S3 method for class 'with_caption'
as.datatable_widget(
  data,
  ...,
  repeat_row_labels = FALSE,
  show_row_numbers = FALSE,
  digits = get_expss_digits()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.datatable_widget_+3A_data">data</code></td>
<td>
<p>a data object (result of <a href="#topic+tables">tables</a>/<a href="#topic+fre">fre</a>/<a href="#topic+cro">cro</a>).</p>
</td></tr>
<tr><td><code id="as.datatable_widget_+3A_...">...</code></td>
<td>
<p>further parameters for <a href="DT.html#topic+datatable">datatable</a></p>
</td></tr>
<tr><td><code id="as.datatable_widget_+3A_repeat_row_labels">repeat_row_labels</code></td>
<td>
<p>logical Should we repeat duplicated row labels in
the every row? Default is FALSE.</p>
</td></tr>
<tr><td><code id="as.datatable_widget_+3A_show_row_numbers">show_row_numbers</code></td>
<td>
<p>logical Default is FALSE.</p>
</td></tr>
<tr><td><code id="as.datatable_widget_+3A_digits">digits</code></td>
<td>
<p>integer By default, all numeric columns are rounded to one digit after
decimal separator. Also you can set this argument by option 'expss.digits'
- for example, <code>expss_digits(2)</code>. If it is NA than all
numeric columns remain unrounded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <a href="DT.html#topic+datatable">datatable</a>
</p>


<h3>See Also</h3>

<p><a href="htmlTable.html#topic+htmlTable">htmlTable</a> for knitting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  

data(mtcars)
mtcars = apply_labels(mtcars,
                      mpg = "Miles/(US) gallon",
                      cyl = "Number of cylinders",
                      disp = "Displacement (cu.in.)",
                      hp = "Gross horsepower",
                      drat = "Rear axle ratio",
                      wt = "Weight (1000 lbs)",
                      qsec = "1/4 mile time",
                      vs = "Engine",
                      vs = c("V-engine" = 0,
                             "Straight engine" = 1),
                      am = "Transmission",
                      am = c("Automatic" = 0,
                             "Manual"=1),
                      gear = "Number of forward gears",
                      carb = "Number of carburetors"
)

mtcars_table = mtcars %&gt;% 
                 tab_cols(total(), am %nest% vs) %&gt;% 
                 tab_cells(mpg, hp) %&gt;% 
                 tab_stat_mean() %&gt;% 
                 tab_cells(cyl) %&gt;% 
                 tab_stat_cpct() %&gt;% 
                 tab_pivot() %&gt;% 
                 set_caption("Table 1. Some variables from mtcars dataset.")

library(shiny)
shinyApp(
    ui = fluidPage(fluidRow(column(12, DT::dataTableOutput('tbl')))),
    server = function(input, output) {
        output$tbl = DT::renderDataTable(
            as.datatable_widget(mtcars_table)
        )
    }
)

## End(Not run)
</code></pre>

<hr>
<h2 id='as.dichotomy'>Convert variable (possibly multiple choice question) to data.frame/matrix of dummy variables.</h2><span id='topic+as.dichotomy'></span><span id='topic+dummy'></span><span id='topic+dummy1'></span><span id='topic+is.dichotomy'></span>

<h3>Description</h3>

<p>This function converts variable/multiple response
variable (vector/matrix/data.frame) with category encoding into
data.frame/matrix with dichotomy encoding (0/1) suited for most statistical
analysis, e. g. clustering, factor analysis, linear regression and so on.
</p>
 
<ul>
<li><p><code>as.dichotomy</code> returns data.frame of class 'dichotomy' with 0, 1
and possibly NA.
</p>
</li>
<li><p><code>dummy</code> returns matrix of class 'dichotomy' with 0, 1 and possibly NA.
</p>
</li>
<li><p><code>dummy1</code> drops last column in dichotomy matrix. It is useful in many cases
because any column of such matrix usually is linear combinations of other columns.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>as.dichotomy(
  x,
  prefix = "v",
  keep_unused = FALSE,
  use_na = TRUE,
  keep_values = NULL,
  keep_labels = NULL,
  drop_values = NULL,
  drop_labels = NULL,
  presence = 1,
  absence = 0
)

dummy(
  x,
  keep_unused = FALSE,
  use_na = TRUE,
  keep_values = NULL,
  keep_labels = NULL,
  drop_values = NULL,
  drop_labels = NULL,
  presence = 1,
  absence = 0
)

dummy1(
  x,
  keep_unused = FALSE,
  use_na = TRUE,
  keep_values = NULL,
  keep_labels = NULL,
  drop_values = NULL,
  drop_labels = NULL,
  presence = 1,
  absence = 0
)

is.dichotomy(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.dichotomy_+3A_x">x</code></td>
<td>
<p>vector/factor/matrix/data.frame.</p>
</td></tr>
<tr><td><code id="as.dichotomy_+3A_prefix">prefix</code></td>
<td>
<p>character. By default &quot;v&quot;.</p>
</td></tr>
<tr><td><code id="as.dichotomy_+3A_keep_unused">keep_unused</code></td>
<td>
<p>Logical. Should we create columns for unused value
labels/factor levels? FALSE by default.</p>
</td></tr>
<tr><td><code id="as.dichotomy_+3A_use_na">use_na</code></td>
<td>
<p>Logical. Should we use NA for rows with all NA or use 0's
instead. TRUE by default.</p>
</td></tr>
<tr><td><code id="as.dichotomy_+3A_keep_values">keep_values</code></td>
<td>
<p>Numeric/character. Values that should be kept. By default
all values will be kept.</p>
</td></tr>
<tr><td><code id="as.dichotomy_+3A_keep_labels">keep_labels</code></td>
<td>
<p>Numeric/character. Labels/levels that should be kept. By
default all labels/levels will be kept.</p>
</td></tr>
<tr><td><code id="as.dichotomy_+3A_drop_values">drop_values</code></td>
<td>
<p>Numeric/character. Values that should be dropped. By default
all values will be kept. Ignored if keep_values/keep_labels are provided.</p>
</td></tr>
<tr><td><code id="as.dichotomy_+3A_drop_labels">drop_labels</code></td>
<td>
<p>Numeric/character. Labels/levels that should be dropped. By
default all labels/levels will be kept. Ignored if keep_values/keep_labels are provided.</p>
</td></tr>
<tr><td><code id="as.dichotomy_+3A_presence">presence</code></td>
<td>
<p>numeric value which will code presence of the level. By
default it is 1. Note that all tables functions need that <code>presence</code>
and <code>absence</code> will be 1 and 0.</p>
</td></tr>
<tr><td><code id="as.dichotomy_+3A_absence">absence</code></td>
<td>
<p>numeric value which will code absence of the level. By default
it is 0. Note that all tables functions need that <code>presence</code> and
<code>absence</code> will be 1 and 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as.dichotomy</code> returns data.frame of class <code>dichotomy</code> 
with 0,1. Columns of this data.frame have variable labels according to
value labels of original data. If label doesn't exist for particular value
then this value will be used as variable label. <code>dummy</code> returns matrix
of class <code>dichotomy</code>. Column names of this matrix are value labels of
original data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.category">as.category</a></code> for reverse conversion, <a href="#topic+mrset">mrset</a>,
<a href="#topic+mdset">mdset</a> for usage multiple-response variables with tables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(2)
# toy example
# brands - multiple response question
# Which brands do you use during last three months? 
set.seed(123)
brands = as.sheet(t(replicate(20,sample(c(1:5,NA),4,replace = FALSE))))
# score - evaluation of tested product
score = sample(-1:1,20,replace = TRUE)
var_lab(brands) = "Used brands"
val_lab(brands) = autonum("
                              Brand A
                              Brand B
                              Brand C
                              Brand D
                              Brand E
                              ")

var_lab(score) = "Evaluation of tested brand"
val_lab(score) = make_labels("
                             -1 Dislike it
                              0 So-so
                              1 Like it    
                             ")

cro_cpct(as.dichotomy(brands), score)
# the same as
cro_cpct(mrset(brands), score)

# customer segmentation by used brands
kmeans(dummy(brands), 3)

# model of influence of used brands on evaluation of tested product 
summary(lm(score ~ dummy(brands)))

# prefixed data.frame 
as.dichotomy(brands, prefix = "brand_")

</code></pre>

<hr>
<h2 id='as.etable'>Convert data.frame/matrix to object of class 'etable'</h2><span id='topic+as.etable'></span><span id='topic+is.etable'></span>

<h3>Description</h3>

<p>If <code>x</code> is <code>data.frame</code> then <code>as.etable</code> just adds
<code>etable</code> to <code>class</code> attribute of <code>x</code>. If <code>x</code> is matrix
then it will be converted to data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.etable(x, rownames_as_row_labels = NULL)

is.etable(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.etable_+3A_x">x</code></td>
<td>
<p>data.frame/matrix</p>
</td></tr>
<tr><td><code id="as.etable_+3A_rownames_as_row_labels">rownames_as_row_labels</code></td>
<td>
<p>logical. If it is TRUE than rownames of 
<code>x</code> will be added to result as first column with name 
<code>row_labels</code>. By default row names will be added if they are not NULL
and are not sequential numerics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>etable</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
etable_mtcars = as.etable(mtcars)
is.etable(etable_mtcars) #TRUE

etable_mtcars #another 'print' method is used

cor(mtcars) %&gt;% as.etable()
</code></pre>

<hr>
<h2 id='as.labelled'>Recode vector into numeric vector with value labels</h2><span id='topic+as.labelled'></span><span id='topic+is.labelled'></span>

<h3>Description</h3>

<p>Recode vector into numeric vector with value labels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.labelled(x, label = NULL)

is.labelled(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.labelled_+3A_x">x</code></td>
<td>
<p>numeric vector/character vector/factor</p>
</td></tr>
<tr><td><code id="as.labelled_+3A_label">label</code></td>
<td>
<p>optional variable label</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector with value labels
</p>


<h3>Examples</h3>

<pre><code class='language-R'>character_vector = c("one", "two",  "two", "three")
as.labelled(character_vector, label = "Numbers")


</code></pre>

<hr>
<h2 id='compare_proportions'>Calculate significance (p-values) of differences between proportions/means</h2><span id='topic+compare_proportions'></span><span id='topic+compare_means'></span>

<h3>Description</h3>

<p><code>compare_proportions</code> calculates p-values (via z-test) for comparison
between each proportion in the <code>prop1</code> and <code>prop2</code>. Results are calculated
with the same formula as in <a href="stats.html#topic+prop.test">prop.test</a> without continuity
correction.
<code>compare_means</code> calculates p-values (via t-test) for comparison between 
each mean in the <code>mean1</code> and <code>mean2</code>. Results are calculated on the
aggregated statistics (means, std. devs, N) with the same formula as in
<a href="stats.html#topic+t.test">t.test</a>.
These functions mainly intended for usage inside <a href="#topic+significance_cpct">significance_cpct</a> and
<a href="#topic+significance_means">significance_means</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_proportions(prop1, prop2, base1, base2, common_base = 0)

compare_means(
  mean1,
  mean2,
  sd1,
  sd2,
  base1,
  base2,
  common_base = 0,
  var_equal = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_proportions_+3A_prop1">prop1</code></td>
<td>
<p>a numeric vector of proportions in the group 1. Values should be
between 0 and 1</p>
</td></tr>
<tr><td><code id="compare_proportions_+3A_prop2">prop2</code></td>
<td>
<p>a numeric vector of proportions in the group 2. Values should be
between 0 and 1</p>
</td></tr>
<tr><td><code id="compare_proportions_+3A_base1">base1</code></td>
<td>
<p>a numeric vector for <code>compare_means</code> and single number for 
<code>compare_proportions</code>. Number of valid cases for each mean in the first group for 
<code>compare_means</code> and number of cases for <code>compare_proportions</code>.</p>
</td></tr>
<tr><td><code id="compare_proportions_+3A_base2">base2</code></td>
<td>
<p>a numeric vector for <code>compare_means</code> and single number for 
<code>compare_proportions</code>. Number of valid cases for each mean in the
second group for <code>compare_means</code> and number of cases for
<code>compare_proportions</code>.</p>
</td></tr>
<tr><td><code id="compare_proportions_+3A_common_base">common_base</code></td>
<td>
<p>numeric. Number of cases that belong to both values in the
first and the second argument. It can occur in the case of overlapping
samples. Calculations are made according to algorithm in IBM SPSS Statistics
Algorithms v20, p. 263. Note that with these adjustments t-tests between
means are made with equal variance assumed (as with <code>var_equal =
TRUE</code>).</p>
</td></tr>
<tr><td><code id="compare_proportions_+3A_mean1">mean1</code></td>
<td>
<p>a numeric vector of the means in the first group.</p>
</td></tr>
<tr><td><code id="compare_proportions_+3A_mean2">mean2</code></td>
<td>
<p>a numeric vector of the means in the second group.</p>
</td></tr>
<tr><td><code id="compare_proportions_+3A_sd1">sd1</code></td>
<td>
<p>a numeric vector of the standard deviations in the first group.
Values should be non-negative.</p>
</td></tr>
<tr><td><code id="compare_proportions_+3A_sd2">sd2</code></td>
<td>
<p>a numeric vector of the standard deviations in the second group.
Values should be non-negative.</p>
</td></tr>
<tr><td><code id="compare_proportions_+3A_var_equal">var_equal</code></td>
<td>
<p>a logical variable indicating whether to treat the variances
in the groups as being equal. For details see <a href="stats.html#topic+t.test">t.test</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector with p-values
</p>


<h3>See Also</h3>

<p><a href="#topic+significance_cpct">significance_cpct</a>, <a href="#topic+significance_means">significance_means</a>, 
<a href="stats.html#topic+prop.test">prop.test</a>, <a href="stats.html#topic+t.test">t.test</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># proportions
data(mtcars)
counts = table(mtcars$am, mtcars$vs)
props = prop.table(counts)
compare_proportions(props[,1], props[,2], 
                    colSums(counts)[1], colSums(counts)[1])
                    
# means
t.test(mpg ~ am, data = mtcars)$p.value 
# the same result
with(mtcars, 
          compare_means(
              mean(mpg[am==0]), mean(mpg[am==1]), 
              sd(mpg[am==0]),  sd(mpg[am==1]),
              length(mpg[am==0]), length(mpg[am==1])
          ))
</code></pre>

<hr>
<h2 id='compute'>Modify data.frame/modify subset of the data.frame</h2><span id='topic+compute'></span><span id='topic+modify'></span><span id='topic+do_if'></span><span id='topic+modify_if'></span><span id='topic+calculate'></span><span id='topic+use_labels'></span><span id='topic+calc'></span>

<h3>Description</h3>


<ul>
<li><p><code>compute</code> evaluates expression <code>expr</code> in the context of data.frame 
<code>data</code> and return original data possibly modified.
</p>
</li>
<li><p><code>calculate</code> evaluates expression <code>expr</code> in the context of 
data.frame <code>data</code> and return value of the evaluated expression. Function <code>use_labels</code> is shortcut for <code>calculate</code> with
argument <code>use_labels</code> set to <code>TRUE</code>. When <code>use_labels</code> is TRUE
there is a special shortcut for entire data.frame - <code>..data</code>.
</p>
</li>
<li><p><code>do_if</code> modifies only rows for which <code>cond</code> equals to
TRUE. Other rows remain unchanged. Newly created variables also will have
values only in rows for which <code>cond</code> have TRUE. There will be NA's in
other rows. This function tries to mimic SPSS &quot;DO IF(). ... END IF.&quot;
statement.
</p>
</li></ul>

<p>Full-featured <code>%to%</code> is available in the expressions for addressing
range of variables.
There is a special constant <code>.N</code> which equals to number of cases in 
<code>data</code> for usage in expression inside <code>compute</code>/<code>calculate</code>. 
Inside <code>do_if</code> <code>.N</code> gives number of rows which will be affected by 
expressions. For parametrization (variable substitution) see <a href="#topic+..">..</a> or 
examples. Sometimes it is useful to create new empty variable inside compute.
You can use <code>.new_var</code> function for this task. This function creates
variable of length <code>.N</code> filled with NA. See examples.
<code>modify</code> is an alias for <code>compute</code>, <code>modify_if</code> is
an alias for <code>do_if</code> and <code>calc</code> is an alias for <code>calculate</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute(data, ...)

modify(data, ...)

do_if(data, cond, ...)

modify_if(data, cond, ...)

calculate(data, expr, use_labels = FALSE)

use_labels(data, expr)

calc(data, expr, use_labels = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_+3A_data">data</code></td>
<td>
<p>data.frame/list of data.frames. If <code>data</code> is list of
data.frames then expression <code>expr</code> will be evaluated inside each
data.frame separately.</p>
</td></tr>
<tr><td><code id="compute_+3A_...">...</code></td>
<td>
<p>expressions that should be evaluated in the context of data.frame
<code>data</code>. It can be arbitrary code in curly brackets or assignments. See
examples.</p>
</td></tr>
<tr><td><code id="compute_+3A_cond">cond</code></td>
<td>
<p>logical vector or expression. Expression will be evaluated in the context of the data.</p>
</td></tr>
<tr><td><code id="compute_+3A_expr">expr</code></td>
<td>
<p>expression that should be evaluated in the context of data.frame <code>data</code></p>
</td></tr>
<tr><td><code id="compute_+3A_use_labels">use_labels</code></td>
<td>
<p>logical. Experimental feature. If it equals to <code>TRUE</code> 
then we will try to replace variable names with labels. So many base R
functions which show variable names will show labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>compute</code> and <code>do_if</code> functions return modified 
data.frame/list of modified data.frames, <code>calculate</code> returns value of
the evaluated expression/list of values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dfs = data.frame(
    test = 1:5,
    a = rep(10, 5),
    b_1 = rep(11, 5),
    b_2 = rep(12, 5),
    b_3 = rep(13, 5),
    b_4 = rep(14, 5),
    b_5 = rep(15, 5) 
)


# compute sum of b* variables and attach it to 'dfs'
let(dfs, 
    b_total = sum_row(b_1 %to% b_5),
    b_total = set_var_lab(b_total, "Sum of b"),
    random_numbers = runif(.N) # .N usage
) %&gt;% print()

# calculate sum of b* variables and return it
query(dfs, sum_row(b_1 %to% b_5))


# set values to existing/new variables
let(dfs, 
    columns('new_b{1:5}') := b_1 %to% b_5
) %&gt;% print()


# conditional modification
let_if(dfs, test %in% 2:4, 
    a = a + 1,    
    b_total = sum_row(b_1 %to% b_5),
    random_numbers = runif(.N) # .N usage
) %&gt;% print()


# variable substitution
name1 = "a"
name2 = "new_var"

let(dfs, 
     (name2) := get(name1)*2    
) %&gt;% print()


# 'use_labels' examples. Utilization of labels in base R.
data(mtcars)
mtcars = apply_labels(mtcars,
                      mpg = "Miles/(US) gallon",
                      cyl = "Number of cylinders",
                      disp = "Displacement (cu.in.)",
                      hp = "Gross horsepower",
                      drat = "Rear axle ratio",
                      wt = "Weight (lb/1000)",
                      qsec = "1/4 mile time",
                      vs = "Engine",
                      vs = c("V-engine" = 0,
                             "Straight engine" = 1),
                      am = "Transmission",
                      am = c("Automatic" = 0,
                             "Manual"=1),
                      gear = "Number of forward gears",
                      carb = "Number of carburetors"
)

use_labels(mtcars, table(am, vs))

## Not run: 
use_labels(mtcars, plot(mpg, hp))

## End(Not run)

mtcars %&gt;% 
       use_labels(lm(mpg ~ disp + hp + wt)) %&gt;% 
       summary()

</code></pre>

<hr>
<h2 id='count_if'>Count/sum/average/other functions on values that meet a criterion</h2><span id='topic+count_if'></span><span id='topic+count_row_if'></span><span id='topic+count_col_if'></span><span id='topic+has'></span><span id='topic++25row_in+25'></span><span id='topic++25has+25'></span><span id='topic++25col_in+25'></span><span id='topic+sum_if'></span><span id='topic+sum_row_if'></span><span id='topic+sum_col_if'></span><span id='topic+mean_if'></span><span id='topic+mean_row_if'></span><span id='topic+mean_col_if'></span><span id='topic+sd_if'></span><span id='topic+sd_row_if'></span><span id='topic+sd_col_if'></span><span id='topic+median_if'></span><span id='topic+median_row_if'></span><span id='topic+median_col_if'></span><span id='topic+max_if'></span><span id='topic+max_row_if'></span><span id='topic+max_col_if'></span><span id='topic+min_if'></span><span id='topic+min_row_if'></span><span id='topic+min_col_if'></span><span id='topic+apply_row_if'></span><span id='topic+apply_col_if'></span>

<h3>Description</h3>

<p>These functions calculate count/sum/average/etc. on values that meet a 
criterion that you specify. <code>apply_if_*</code> apply custom functions. There
are different flavors of these functions: <code>*_if</code> work on entire
dataset/matrix/vector, <code>*_row_if</code> works on each row and <code>*_col_if</code>
works on each column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_if(criterion, ...)

count_row_if(criterion, ...)

count_col_if(criterion, ...)

has(x, criterion)

x %row_in% criterion

x %has% criterion

x %col_in% criterion

sum_if(criterion, ..., data = NULL)

sum_row_if(criterion, ..., data = NULL)

sum_col_if(criterion, ..., data = NULL)

mean_if(criterion, ..., data = NULL)

mean_row_if(criterion, ..., data = NULL)

mean_col_if(criterion, ..., data = NULL)

sd_if(criterion, ..., data = NULL)

sd_row_if(criterion, ..., data = NULL)

sd_col_if(criterion, ..., data = NULL)

median_if(criterion, ..., data = NULL)

median_row_if(criterion, ..., data = NULL)

median_col_if(criterion, ..., data = NULL)

max_if(criterion, ..., data = NULL)

max_row_if(criterion, ..., data = NULL)

max_col_if(criterion, ..., data = NULL)

min_if(criterion, ..., data = NULL)

min_row_if(criterion, ..., data = NULL)

min_col_if(criterion, ..., data = NULL)

apply_row_if(fun, criterion, ..., data = NULL)

apply_col_if(fun, criterion, ..., data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_if_+3A_criterion">criterion</code></td>
<td>
<p>Vector with counted values or
function. See details and examples.</p>
</td></tr>
<tr><td><code id="count_if_+3A_...">...</code></td>
<td>
<p>Data on which criterion will be applied. Vector, matrix,
data.frame, list.</p>
</td></tr>
<tr><td><code id="count_if_+3A_x">x</code></td>
<td>
<p>Data on which criterion will be applied. Vector, matrix,
data.frame, list.</p>
</td></tr>
<tr><td><code id="count_if_+3A_data">data</code></td>
<td>
<p>Data on which function will be applied. Doesn't applicable to 
<code>count_*_if</code> functions. If omitted then function will be applied on
the ... argument.</p>
</td></tr>
<tr><td><code id="count_if_+3A_fun">fun</code></td>
<td>
<p>Custom function that will be applied based on criterion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Possible type for criterion argument:
</p>

<ul>
<li><p>vector/single value All values in <code>...</code> which equal to the
elements of vector in the criteria will be used as function <code>fun</code>
argument.
</p>
</li>
<li><p>function Values for which function gives TRUE will be used as
function <code>fun</code> argument. There are some special functions for
convenience (e. g. <code>gt(5)</code> is equivalent &quot;&gt;5&quot; in spreadsheet) - see
<a href="#topic+criteria">criteria</a>.</p>
</li></ul>

<p><code>count*</code> and <code>%in*%</code> never returns NA's. Other functions remove
NA's before calculations (as <code>na.rm = TRUE</code> in base R functions).
</p>
<p>Function criterion should return logical vector of same size and shape as its
argument. This function will be applied to each column of supplied data and
TRUE results will be used. There is asymmetrical behavior in <code>*_row_if</code>
and <code>*_col_if</code> for function criterion: in both cases function criterion
will be applied columnwise.
</p>


<h3>Value</h3>

<p><code>*_if</code> return single value (vector of length 1). 
<code>*_row_if</code> returns vector for each row of supplied arguments.
<code>*_col_if</code> returns vector for each column of supplied arguments.
<code>%row_in%</code>/<code>%col_in%</code> return logical vector - indicator of
presence of criterion in each row/column. <code>%has%</code> is an alias for
<code>%row_in%</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
sheet1 = as.sheet(
       matrix(sample(c(1:10,NA), 30, replace = TRUE), 10)
)

result  = let(sheet1, 
             # count 8
             exact = count_row_if(8, V1, V2, V3),
             # count values greater than 8
             greater = count_row_if(gt(8), V1, V2, V3),
             # count integer values between 5 and 8, e. g. 5, 6, 7, 8
             integer_range = count_row_if(5:8, V1, V2, V3),
             # count values between 5 and 8 
             range = count_row_if(5 %thru% 8, V1, V2, V3),
             # count NA 
             na = count_row_if(is.na, V1, V2, V3),
             # count not-NA 
             not_na = count_row_if(not_na, V1, V2, V3), 
             # are there any 5 in each row?
             has_five = cbind(V1, V2, V3) %row_in% 5   
         )  
print(result)
 
mean_row_if(6, sheet1$V1, data = sheet1)
median_row_if(gt(2), sheet1$V1, sheet1$V2, sheet1$V3) 
sd_row_if(5 %thru% 8, sheet1$V1, sheet1$V2, sheet1$V3)
 
if_na(sheet1) = 5 # replace NA 

# custom apply
apply_col_if(prod, gt(2), sheet1$V1, data = sheet1) # product of all elements by columns
apply_row_if(prod, gt(2), sheet1$V1, data = sheet1) # product of all elements by rows
 
# Examples borrowed from Microsoft Excel help for COUNTIF
sheet1 = text_to_columns(
    "
       a       b
    apples    32
    oranges   54
    peaches   75
    apples    86
    "
)

count_if("apples", sheet1$a) # 2

count_if("apples", sheet1) # 2

with(sheet1, count_if("apples", a, b)) # 2

count_if(gt(55), sheet1$b) # greater than 55 = 2

count_if(ne(75), sheet1$b) # not equal 75 = 3

count_if(ge(32), sheet1$b) # greater than or equal 32 = 4

count_if(gt(32) &amp; lt(86), sheet1$b) # 2

# count only integer values between 33 and 85
count_if(33:85, sheet1$b) # 2

# values with letters
count_if(regex("^[A-z]+$"), sheet1) # 4

# values that started on 'a'
count_if(regex("^a"), sheet1) # 2

# count_row_if
count_row_if(regex("^a"), sheet1) # c(1,0,0,1)

sheet1 %row_in% 'apples'  # c(TRUE,FALSE,FALSE,TRUE)

# Some of Microsoft Excel examples for SUMIF/AVERAGEIF/etc 
sheet1 = text_to_columns(
    "
    property_value commission data
    100000              7000  250000
    200000             14000	
    300000             21000	
    400000             28000
    "
)

# Sum of commision for property value greater than 160000
with(sheet1, sum_if(gt(160000), property_value, data = commission)) # 63000
    
# Sum of property value greater than 160000
with(sheet1, sum_if(gt(160000), property_value)) # 900000

# Sum of commision for property value equals to 300000
with(sheet1, sum_if(300000, property_value, data = commission)) # 21000
    
# Sum of commision for property value greater than first value of data
with(sheet1, sum_if(gt(data[1]), property_value, data = commission)) # 49000
    
sheet1 = text_to_columns(
       "
         category     food sales
       Vegetables Tomatoes  2300
       Vegetables   Celery  5500
           Fruits  Oranges   800
             NA     Butter   400
       Vegetables  Carrots  4200
           Fruits   Apples  1200
       "
       )

# Sum of sales for Fruits
with(sheet1, sum_if("Fruits", category, data = sales)) # 2000

# Sum of sales for Vegetables    
with(sheet1, sum_if("Vegetables", category, data = sales)) # 12000

# Sum of sales for food which is ending on 'es' 
with(sheet1, sum_if(perl("es$"), food, data = sales)) # 4300

# Sum of sales for empty category
with(sheet1, sum_if(NA, category, data = sales))  # 400


sheet1 = text_to_columns(
    "
    property_value commission data
    100000              7000  250000
    200000             14000	
    300000             21000	
    400000             28000
    "
)

# Commision average for comission less than 23000
with(sheet1, mean_if(lt(23000), commission)) # 14000


# Property value average for property value less than 95000
with(sheet1, mean_if(lt(95000), property_value)) #  NaN

# Commision average for property value greater than 250000
with(sheet1, mean_if(gt(250000), property_value, data = commission)) # 24500


sheet1 = text_to_columns(
    '
                region  profits
                  East   45678
                  West   23789
                 North   -4789
    "South (New Office)"     0
               MidWest    9678
    ',
    quote = '"'
)


# Mean profits for 'west' regions
with(sheet1, mean_if(contains("West"), region, data = profits)) # 16733.5


# Mean profits for regions wich doesn't contain New Office
with(sheet1, mean_if(not(contains("New Office")), region, data = profits))  # 18589


sheet1 = text_to_columns(
    "
    grade weight 
    89      1
    93      2
    96      2
    85      3
    91      1
    88      1
    "
)

# Minimum grade for weight equals to 1
with(sheet1, min_if(1, weight, data = grade)) # 88


# Maximum grade for weight equals to 1
with(sheet1, max_if(1, weight, data = grade)) #91


# Example with offset
sheet1 = text_to_columns(
    "
    weight grade 
       10    b
       11    a
      100    a
      111    b
        1    a
        1    a
    "
)

with(sheet1, min_if("a", grade[2:5], data = weight[1:4])) # 10


</code></pre>

<hr>
<h2 id='criteria'>Criteria functions</h2><span id='topic+criteria'></span><span id='topic+as.criterion'></span><span id='topic+is.criterion'></span><span id='topic+equals'></span><span id='topic+eq'></span><span id='topic+not_equals'></span><span id='topic+ne'></span><span id='topic+neq'></span><span id='topic+less'></span><span id='topic+lt'></span><span id='topic+less_or_equal'></span><span id='topic+le'></span><span id='topic+lte'></span><span id='topic+greater'></span><span id='topic+gt'></span><span id='topic+greater_or_equal'></span><span id='topic+ge'></span><span id='topic+gte'></span><span id='topic+thru'></span><span id='topic++25thru+25'></span><span id='topic+when'></span><span id='topic+is_max'></span><span id='topic+is_min'></span><span id='topic+contains'></span><span id='topic+like'></span><span id='topic+fixed'></span><span id='topic+perl'></span><span id='topic+regex'></span><span id='topic+has_label'></span><span id='topic+from'></span><span id='topic+to'></span><span id='topic+items'></span><span id='topic+not_na'></span><span id='topic+is_na'></span><span id='topic+other'></span><span id='topic+and'></span><span id='topic+or'></span><span id='topic+not'></span>

<h3>Description</h3>

<p>Produce criteria which could be used in the different situations - see
'<a href="#topic+recode">recode</a>', '<a href="#topic+na_if">na_if</a>', '<a href="#topic+count_if">count_if</a>', '<a href="#topic+match_row">match_row</a>',
'<a href="#topic++25i+25">%i%</a>' and etc. For example, <code>'greater(5)'</code> returns function
which tests whether its argument greater than five. <code>'fixed("apple")'</code>
returns function which tests whether its argument contains &quot;apple&quot;. For
criteria logical operations (|, &amp;, !, xor) are defined, e. g. you can write
something like: <code>'greater(5) | equals(1)'</code>.
List of functions:
</p>

<ul>
<li><p>comparison criteria - <code>'equals'</code>, <code>'greater'</code> and etc. return
functions which compare its argument against value.
</p>
</li>
<li><p><code>'thru'</code> checks whether a value is inside interval.
<code>'thru(0,1)'</code> is equivalent to <code>'x&gt;=0 &amp; x&lt;=1'</code>
</p>
</li>
<li><p><code>'%thru%'</code> is infix version of <code>'thru'</code>, e. g. <code>'0
%thru% 1'</code>
</p>
</li>
<li><p><code>'is_max'</code> and <code>'is_min'</code> return TRUE where vector value is
equals to maximum or minimum.
</p>
</li>
<li><p><code>'contains'</code> searches for the pattern in the strings. By default,
it works with fixed patterns rather than regular expressions. For details
about its arguments see <a href="base.html#topic+grep">grepl</a>
</p>
</li>
<li><p><code>'like'</code> searches for the Excel-style pattern in the strings. You
can use wildcards: '*' means any number of symbols, '?' means single symbol.
Case insensitive.
</p>
</li>
<li><p><code>'fixed'</code> alias for contains.
</p>
</li>
<li><p><code>'perl'</code> such as <code>'contains'</code> but the pattern is perl-compatible
regular expression (<code>'perl = TRUE'</code>). For details see <a href="base.html#topic+grep">grepl</a>
</p>
</li>
<li><p><code>'regex'</code> use POSIX 1003.2 extended regular expressions
(<code>'fixed = FALSE'</code>). For details see <a href="base.html#topic+grep">grepl</a>
</p>
</li>
<li><p><code>'has_label'</code> searches values which have supplied label(-s).  We
can used criteria as an argument for 'has_label'.
</p>
</li>
<li><p><code>'to'</code> returns function which gives TRUE for all elements of
vector before the first occurrence of <code>'x'</code> and for  <code>'x'</code>.
</p>
</li>
<li><p><code>'from'</code> returns function which gives TRUE for all elements of 
vector after the first occurrence of <code>'x'</code> and for <code>'x'</code>.
</p>
</li>
<li><p><code>'not_na'</code> returns TRUE for all non-NA vector elements. 
</p>
</li>
<li><p><code>'other'</code> returns TRUE for all vector elements. It is intended
for usage with <code>'recode'</code>.
</p>
</li>
<li><p><code>'items'</code> returns TRUE for the vector elements with the given
sequential numbers.
</p>
</li>
<li><p><code>'and'</code>, <code>'or'</code>, <code>'not'</code> are spreadsheet-style boolean functions.
</p>
</li></ul>
 
<p>Shortcuts for comparison criteria:
</p>

<ul>
<li><p>'equals' - <code>'eq'</code>
</p>
</li>
<li><p>'not_equals' - <code>'neq'</code>, <code>'ne'</code>
</p>
</li>
<li><p>'greater' - <code>'gt'</code>
</p>
</li>
<li><p>'greater_or_equal' - <code>'gte'</code>, <code>'ge'</code>
</p>
</li>
<li><p>'less' - <code>'lt'</code>
</p>
</li>
<li><p>'less_or_equal' - <code>'lte'</code>, <code>'le'</code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>as.criterion(crit)

is.criterion(x)

equals(x)

not_equals(x)

less(x)

less_or_equal(x)

greater(x)

greater_or_equal(x)

thru(lower, upper)

lower %thru% upper

when(x)

is_max(x)

is_min(x)

contains(
  pattern,
  ignore.case = FALSE,
  perl = FALSE,
  fixed = TRUE,
  useBytes = FALSE
)

like(pattern)

fixed(
  pattern,
  ignore.case = FALSE,
  perl = FALSE,
  fixed = TRUE,
  useBytes = FALSE
)

perl(
  pattern,
  ignore.case = FALSE,
  perl = TRUE,
  fixed = FALSE,
  useBytes = FALSE
)

regex(
  pattern,
  ignore.case = FALSE,
  perl = FALSE,
  fixed = FALSE,
  useBytes = FALSE
)

has_label(x)

from(x)

to(x)

items(...)

not_na(x)

is_na(x)

other(x)

and(...)

or(...)

not(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="criteria_+3A_crit">crit</code></td>
<td>
<p>vector of values/function which returns logical or logical vector. It will be
converted to function of class criterion.</p>
</td></tr>
<tr><td><code id="criteria_+3A_x">x</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="criteria_+3A_lower">lower</code></td>
<td>
<p>vector/single value - lower bound of interval</p>
</td></tr>
<tr><td><code id="criteria_+3A_upper">upper</code></td>
<td>
<p>vector/single value - upper bound of interval</p>
</td></tr>
<tr><td><code id="criteria_+3A_pattern">pattern</code></td>
<td>
<p>character string containing a regular expression (or character
string for <code>'fixed'</code>) to be matched in the given character vector.
Coerced by as.character to a character string if possible.</p>
</td></tr>
<tr><td><code id="criteria_+3A_ignore.case">ignore.case</code></td>
<td>
<p>logical see <a href="base.html#topic+grep">grepl</a></p>
</td></tr>
<tr><td><code id="criteria_+3A_perl">perl</code></td>
<td>
<p>logical see <a href="base.html#topic+grep">grepl</a></p>
</td></tr>
<tr><td><code id="criteria_+3A_fixed">fixed</code></td>
<td>
<p>logical see <a href="base.html#topic+grep">grepl</a></p>
</td></tr>
<tr><td><code id="criteria_+3A_usebytes">useBytes</code></td>
<td>
<p>logical see <a href="base.html#topic+grep">grepl</a></p>
</td></tr>
<tr><td><code id="criteria_+3A_...">...</code></td>
<td>
<p>numeric indexes of desired items for items, logical vectors or criteria for boolean functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>function of class 'criterion' which tests its argument against
condition and return logical value
</p>


<h3>See Also</h3>

<p><a href="#topic+recode">recode</a>, <a href="#topic+count_if">count_if</a>,
<a href="#topic+match_row">match_row</a>, <a href="#topic+na_if">na_if</a>, <a href="#topic++25i+25">%i%</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># operations on vector, '%d%' means 'diff'
1:6 %d% greater(4) # 1:4
1:6 %d% (1 | greater(4)) # 2:4
# '%i%' means 'intersect
1:6 %i% (is_min() | is_max()) # 1, 6
# with Excel-style boolean operators
1:6 %i% or(is_min(), is_max()) # 1, 6

letters %i% (contains("a") | contains("z")) # a, z

letters %i% perl("a|z") # a, z

letters %i% from("w")  # w, x, y, z

letters %i% to("c")  # a, b, c

letters %i% (from("b") &amp; to("e"))  # b, d, e

c(1, 2, NA, 3) %i% not_na() # c(1, 2, 3)

# examples with count_if
df1 = data.frame(
    a=c("apples", "oranges", "peaches", "apples"),
    b = c(32, 54, 75, 86)
)

count_if(greater(55), df1$b) # greater than 55 = 2

count_if(not_equals(75), df1$b) # not equals 75 = 3

count_if(greater(32) &amp; less(86), df1$b) # greater than 32 and less than 86 = 2
count_if(and(greater(32), less(86)), df1$b) # the same result

# infix version
count_if(35 %thru% 80, df1$b) # greater than or equals to 35 and less than or equals to 80 = 2

# values that started on 'a'
count_if(like("a*"), df1) # 2

# the same with Perl-style regular expression
count_if(perl("^a"), df1) # 2

# count_row_if
count_row_if(perl("^a"), df1) # c(1,0,0,1)

# examples with 'n_intersect' and 'n_diff'
data(iris)
iris %&gt;% n_intersect(to("Petal.Width")) # all columns up to 'Species' 
 
# 'Sepal.Length', 'Sepal.Width' will be left 
iris %&gt;% n_diff(from("Petal.Length"))

# except first column
iris %n_d% items(1)

# 'recode' examples
qvar = c(1:20, 97, NA, NA)
recode(qvar, 1 %thru% 5 ~ 1, 6 %thru% 10 ~ 2, 11 %thru% hi ~ 3, other ~ 0)
# the same result
recode(qvar, 1 %thru% 5 ~ 1, 6 %thru% 10 ~ 2, greater_or_equal(11) ~ 3, other ~ 0)


</code></pre>

<hr>
<h2 id='cross_cases'>Cross tabulation with support of labels, weights and multiple response variables.</h2><span id='topic+cross_cases'></span><span id='topic+cross_cpct'></span><span id='topic+cross_rpct'></span><span id='topic+cross_tpct'></span><span id='topic+cross_cpct_responses'></span><span id='topic+cro'></span><span id='topic+cro_cases'></span><span id='topic+cro_cpct'></span><span id='topic+cro_rpct'></span><span id='topic+cro_tpct'></span><span id='topic+cro_cpct_responses'></span><span id='topic+total'></span><span id='topic+calc_cro'></span><span id='topic+calc_cro_cases'></span><span id='topic+calc_cro_cpct'></span><span id='topic+calc_cro_rpct'></span><span id='topic+calc_cro_tpct'></span><span id='topic+calc_cro_cpct_responses'></span>

<h3>Description</h3>


<ul>
<li><p><code>cross_cases</code> build a contingency table of the counts.
</p>
</li>
<li><p><code>cross_cpct</code>, <code>cross_cpct_responses</code> build a contingency table 
of the column percent. These functions give different results only for 
multiple response variables. For <code>cross_cpct</code> base of percent is number 
of valid cases. Case is considered as valid if it has at least one non-NA 
value. So for multiple response variables sum of percent may be greater than
100. For <code>cross_cpct_responses</code> base of percent is number of valid 
responses. Multiple response variables can have several responses for single 
case. Sum of percent of <code>cross_cpct_responses</code> always equals to 100%.
</p>
</li>
<li><p><code>cross_rpct</code> build a contingency table of the row percent. Base
for percent is number of valid cases.
</p>
</li>
<li><p><code>cross_tpct</code> build a contingency table of the table percent. Base
for percent is number of valid cases.
</p>
</li>
<li><p><code>cross_*</code> functions evaluate their arguments
in the context of the first argument <code>data</code>.
</p>
</li>
<li><p><code>cro_*</code> functions use standard evaluation, e. g 'cro(mtcars$am, mtcars$vs)'.
</p>
</li>
<li><p><code>total</code> auxiliary function - creates variables with 1 for valid
case of its argument <code>x</code> and NA in opposite case.
</p>
</li></ul>

<p>You can combine tables with <a href="#topic+add_rows">add_rows</a> and <a href="#topic+merge.etable">merge.etable</a>. For
sorting table see <a href="#topic+tab_sort_asc">tab_sort_asc</a>. 
To provide multiple-response variables as arguments use <a href="#topic+mrset">mrset</a> for 
multiples with category encoding and <a href="#topic+mdset">mdset</a> for multiples with 
dichotomy (dummy) encoding. To compute statistics with nested 
variables/banners use <a href="#topic+nest">nest</a>. For more sophisticated interface with
modern piping via <code>magrittr</code> see <a href="#topic+tables">tables</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_cases(
  data,
  cell_vars,
  col_vars = total(),
  row_vars = NULL,
  weight = NULL,
  subgroup = NULL,
  total_label = NULL,
  total_statistic = "u_cases",
  total_row_position = c("below", "above", "none")
)

cross_cpct(
  data,
  cell_vars,
  col_vars = total(),
  row_vars = NULL,
  weight = NULL,
  subgroup = NULL,
  total_label = NULL,
  total_statistic = "u_cases",
  total_row_position = c("below", "above", "none")
)

cross_rpct(
  data,
  cell_vars,
  col_vars = total(),
  row_vars = NULL,
  weight = NULL,
  subgroup = NULL,
  total_label = NULL,
  total_statistic = "u_cases",
  total_row_position = c("below", "above", "none")
)

cross_tpct(
  data,
  cell_vars,
  col_vars = total(),
  row_vars = NULL,
  weight = NULL,
  subgroup = NULL,
  total_label = NULL,
  total_statistic = "u_cases",
  total_row_position = c("below", "above", "none")
)

cross_cpct_responses(
  data,
  cell_vars,
  col_vars = total(),
  row_vars = NULL,
  weight = NULL,
  subgroup = NULL,
  total_label = NULL,
  total_statistic = "u_responses",
  total_row_position = c("below", "above", "none")
)

cro(
  cell_vars,
  col_vars = total(),
  row_vars = NULL,
  weight = NULL,
  subgroup = NULL,
  total_label = NULL,
  total_statistic = "u_cases",
  total_row_position = c("below", "above", "none")
)

cro_cases(
  cell_vars,
  col_vars = total(),
  row_vars = NULL,
  weight = NULL,
  subgroup = NULL,
  total_label = NULL,
  total_statistic = "u_cases",
  total_row_position = c("below", "above", "none")
)

cro_cpct(
  cell_vars,
  col_vars = total(),
  row_vars = NULL,
  weight = NULL,
  subgroup = NULL,
  total_label = NULL,
  total_statistic = "u_cases",
  total_row_position = c("below", "above", "none")
)

cro_rpct(
  cell_vars,
  col_vars = total(),
  row_vars = NULL,
  weight = NULL,
  subgroup = NULL,
  total_label = NULL,
  total_statistic = "u_cases",
  total_row_position = c("below", "above", "none")
)

cro_tpct(
  cell_vars,
  col_vars = total(),
  row_vars = NULL,
  weight = NULL,
  subgroup = NULL,
  total_label = NULL,
  total_statistic = "u_cases",
  total_row_position = c("below", "above", "none")
)

cro_cpct_responses(
  cell_vars,
  col_vars = total(),
  row_vars = NULL,
  weight = NULL,
  subgroup = NULL,
  total_label = NULL,
  total_statistic = "u_responses",
  total_row_position = c("below", "above", "none")
)

total(x = 1, label = "#Total")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_cases_+3A_data">data</code></td>
<td>
<p>data.frame in which context all other arguments will be evaluated
(for <code>cross_*</code>).</p>
</td></tr>
<tr><td><code id="cross_cases_+3A_cell_vars">cell_vars</code></td>
<td>
<p>vector/data.frame/list. Variables on which percentage/cases
will be computed. Use <a href="#topic+mrset">mrset</a>/<a href="#topic+mdset">mdset</a> for multiple-response
variables.</p>
</td></tr>
<tr><td><code id="cross_cases_+3A_col_vars">col_vars</code></td>
<td>
<p>vector/data.frame/list. Variables which breaks table by
columns. Use <a href="#topic+mrset">mrset</a>/<a href="#topic+mdset">mdset</a> for multiple-response variables.</p>
</td></tr>
<tr><td><code id="cross_cases_+3A_row_vars">row_vars</code></td>
<td>
<p>vector/data.frame/list. Variables which breaks table by rows.
Use <a href="#topic+mrset">mrset</a>/<a href="#topic+mdset">mdset</a> for multiple-response variables.</p>
</td></tr>
<tr><td><code id="cross_cases_+3A_weight">weight</code></td>
<td>
<p>numeric vector. Optional cases weights. Cases with NA's,
negative and zero weights are removed before calculations.</p>
</td></tr>
<tr><td><code id="cross_cases_+3A_subgroup">subgroup</code></td>
<td>
<p>logical vector. You can specify subgroup on which table will be computed.</p>
</td></tr>
<tr><td><code id="cross_cases_+3A_total_label">total_label</code></td>
<td>
<p>By default &quot;#Total&quot;. You can provide several names - each name for
each total statistics.</p>
</td></tr>
<tr><td><code id="cross_cases_+3A_total_statistic">total_statistic</code></td>
<td>
<p>By default it is &quot;u_cases&quot; (unweighted cases). 
Possible values are &quot;u_cases&quot;, &quot;u_responses&quot;, &quot;u_cpct&quot;, &quot;u_rpct&quot;, &quot;u_tpct&quot;,
&quot;w_cases&quot;, &quot;w_responses&quot;, &quot;w_cpct&quot;, &quot;w_rpct&quot;, &quot;w_tpct&quot;. &quot;u_&quot; means
unweighted statistics and &quot;w_&quot; means weighted statistics.</p>
</td></tr>
<tr><td><code id="cross_cases_+3A_total_row_position">total_row_position</code></td>
<td>
<p>Position of total row in the resulting table. Can
be one of &quot;below&quot;, &quot;above&quot;, &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="cross_cases_+3A_x">x</code></td>
<td>
<p>vector/data.frame of class 'category'/'dichotomy'.</p>
</td></tr>
<tr><td><code id="cross_cases_+3A_label">label</code></td>
<td>
<p>character. Label for total variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class 'etable'. Basically it's a data.frame but class
is needed for custom methods.
</p>


<h3>See Also</h3>

<p><a href="#topic+tables">tables</a>, <a href="#topic+fre">fre</a>, <a href="#topic+cro_fun">cro_fun</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(mtcars)
mtcars = apply_labels(mtcars,
                      mpg = "Miles/(US) gallon",
                      cyl = "Number of cylinders",
                      disp = "Displacement (cu.in.)",
                      hp = "Gross horsepower",
                      drat = "Rear axle ratio",
                      wt = "Weight (1000 lbs)",
                      qsec = "1/4 mile time",
                      vs = "Engine",
                      vs = c("V-engine" = 0,
                             "Straight engine" = 1),
                      am = "Transmission",
                      am = c("Automatic" = 0,
                             "Manual"=1),
                      gear = "Number of forward gears",
                      carb = "Number of carburetors"
)

cross_cases(mtcars, am, vs) 
cro(mtcars$am, mtcars$vs) # the same result

# column percent with multiple banners
cross_cpct(mtcars, cyl, list(total(), vs, am)) 

# nested banner
cross_cpct(mtcars, cyl, list(total(), vs %nest% am))

# stacked variables
cross_cases(mtcars, list(cyl, carb), list(total(), vs %nest% am))

# nested variables
cross_cpct(mtcars, am %nest% cyl, list(total(), vs))

# row variables
cross_cpct(mtcars, cyl, list(total(), vs), row_vars = am)

# several totals above table
cross_cpct(mtcars, cyl, 
              list(total(), vs), 
              row_vars = am,
              total_row_position = "above",
              total_label = c("number of cases", "row %"),
              total_statistic = c("u_cases", "u_rpct")
              )

# multiple-choice variable
# brands - multiple response question
# Which brands do you use during last three months? 
set.seed(123)
brands = data.table(t(replicate(20,sample(c(1:5,NA),4,replace = FALSE)))) %&gt;% 
    setNames(paste0("brand_", 1:4))
# score - evaluation of tested product
brands = brands %&gt;% 
    let(
        score = sample(-1:1,.N,replace = TRUE)
    ) %&gt;% 
    apply_labels(
        brand_1 = "Used brands",
        brand_1 = num_lab("
                              1 Brand A
                              2 Brand B
                              3 Brand C
                              4 Brand D
                              5 Brand E
                              "),

        score = "Evaluation of tested brand",
        score = num_lab("
                             -1 Dislike it
                             0 So-so
                             1 Like it    
                             ")
)
cross_cpct(brands, mrset(brand_1 %to% brand_4), list(total(), score))
# responses
cross_cpct_responses(brands, mrset(brand_1 %to% brand_4), list(total(), score))

## End(Not run)
</code></pre>

<hr>
<h2 id='cross_fun'>Cross-tabulation with custom summary function.</h2><span id='topic+cross_fun'></span><span id='topic+cross_fun_df'></span><span id='topic+cross_mean'></span><span id='topic+cross_mean_sd_n'></span><span id='topic+cross_sum'></span><span id='topic+cross_median'></span><span id='topic+cross_pearson'></span><span id='topic+cross_spearman'></span><span id='topic+cro_fun'></span><span id='topic+cro_fun_df'></span><span id='topic+cro_mean'></span><span id='topic+cro_mean_sd_n'></span><span id='topic+cro_sum'></span><span id='topic+cro_median'></span><span id='topic+cro_pearson'></span><span id='topic+cro_spearman'></span><span id='topic+combine_functions'></span><span id='topic+calc_cro_fun'></span><span id='topic+calc_cro_fun_df'></span><span id='topic+calc_cro_mean'></span><span id='topic+calc_cro_mean_sd_n'></span><span id='topic+calc_cro_sum'></span><span id='topic+calc_cro_median'></span><span id='topic+calc_cro_pearson'></span><span id='topic+calc_cro_spearman'></span>

<h3>Description</h3>


<ul>
<li><p><code>cross_mean</code>, <code>cross_sum</code>, <code>cross_median</code> calculate 
mean/sum/median by groups. NA's are always omitted.
</p>
</li>
<li><p><code>cross_mean_sd_n</code> calculates mean, standard deviation and N
simultaneously. Mainly intended for usage with <a href="#topic+significance_means">significance_means</a>.
</p>
</li>
<li><p><code>cross_pearson</code>, <code>cross_spearman</code> calculate correlation of 
first variable in each data.frame in <code>cell_vars</code> with other variables. 
NA's are removed pairwise.
</p>
</li>
<li><p><code>cross_fun</code>, <code>cross_fun_df</code> return table with custom summary 
statistics defined by <code>fun</code> argument. NA's treatment depends on your 
<code>fun</code> behavior. To use weight you should have formal <code>weight</code> 
argument in <code>fun</code> and some logic for its processing inside. Several 
functions with weight support are provided - see <a href="#topic+w_mean">w_mean</a>. 
<code>cross_fun</code> applies <code>fun</code> on each variable in <code>cell_vars</code> 
separately, <code>cross_fun_df</code> gives to <code>fun</code> each data.frame in 
<code>cell_vars</code> as a whole. So <code>cross_fun(iris[, -5], iris$Species, fun =
mean)</code> gives the same result as <code>cross_fun_df(iris[, -5], iris$Species, 
fun = colMeans)</code>. For <code>cross_fun_df</code> names of <code>cell_vars</code> will 
converted to labels if they are available before the <code>fun</code> will be applied. 
Generally it is recommended that <code>fun</code> will always return object of the 
same form. Row names/vector names of <code>fun</code> result will appear in the row
labels of the table and column names/names of list will appear in the column 
labels. If your <code>fun</code> returns data.frame/matrix/list with element named
'row_labels' then this element will be used as row labels. And it will have
precedence over rownames.
</p>
</li>
<li><p><code>cross_*</code> are evaluate their arguments
in the context of the first argument <code>data</code>.
</p>
</li>
<li><p><code>cro_*</code> functions use standard evaluation, e. g 'cro(mtcars$am, mtcars$vs)'.
</p>
</li>
<li><p><code>combine_functions</code> is auxiliary function for combining several 
functions into one function for usage with <code>cro_fun</code>/<code>cro_fun_df</code>.
Names of arguments will be used as statistic labels. By default, results of
each function are combined with <a href="base.html#topic+c">c</a>. But you can provide your own method
function with <code>method</code> argument. It will be applied as in the expression
<code>do.call(method, list_of_functions_results)</code>. Particular useful method
is <code>list</code>. When it used then statistic labels will appear in the column
labels. See examples. Also you may be interested in <code>data.frame</code>, 
<code>rbind</code>, <code>cbind</code> methods.</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>cross_fun(
  data,
  cell_vars,
  col_vars = total(),
  row_vars = total(label = ""),
  weight = NULL,
  subgroup = NULL,
  fun,
  ...,
  unsafe = FALSE
)

cross_fun_df(
  data,
  cell_vars,
  col_vars = total(),
  row_vars = total(label = ""),
  weight = NULL,
  subgroup = NULL,
  fun,
  ...,
  unsafe = FALSE
)

cross_mean(
  data,
  cell_vars,
  col_vars = total(),
  row_vars = total(label = ""),
  weight = NULL,
  subgroup = NULL
)

cross_mean_sd_n(
  data,
  cell_vars,
  col_vars = total(),
  row_vars = total(label = ""),
  weight = NULL,
  subgroup = NULL,
  weighted_valid_n = FALSE,
  labels = NULL
)

cross_sum(
  data,
  cell_vars,
  col_vars = total(),
  row_vars = total(label = ""),
  weight = NULL,
  subgroup = NULL
)

cross_median(
  data,
  cell_vars,
  col_vars = total(),
  row_vars = total(label = ""),
  weight = NULL,
  subgroup = NULL
)

cross_pearson(
  data,
  cell_vars,
  col_vars = total(),
  row_vars = total(label = ""),
  weight = NULL,
  subgroup = NULL
)

cross_spearman(
  data,
  cell_vars,
  col_vars = total(),
  row_vars = total(label = ""),
  weight = NULL,
  subgroup = NULL
)

cro_fun(
  cell_vars,
  col_vars = total(),
  row_vars = total(label = ""),
  weight = NULL,
  subgroup = NULL,
  fun,
  ...,
  unsafe = FALSE
)

cro_fun_df(
  cell_vars,
  col_vars = total(),
  row_vars = total(label = ""),
  weight = NULL,
  subgroup = NULL,
  fun,
  ...,
  unsafe = FALSE
)

cro_mean(
  cell_vars,
  col_vars = total(),
  row_vars = total(label = ""),
  weight = NULL,
  subgroup = NULL
)

cro_mean_sd_n(
  cell_vars,
  col_vars = total(),
  row_vars = total(label = ""),
  weight = NULL,
  subgroup = NULL,
  weighted_valid_n = FALSE,
  labels = NULL
)

cro_sum(
  cell_vars,
  col_vars = total(),
  row_vars = total(label = ""),
  weight = NULL,
  subgroup = NULL
)

cro_median(
  cell_vars,
  col_vars = total(),
  row_vars = total(label = ""),
  weight = NULL,
  subgroup = NULL
)

cro_pearson(
  cell_vars,
  col_vars = total(),
  row_vars = total(label = ""),
  weight = NULL,
  subgroup = NULL
)

cro_spearman(
  cell_vars,
  col_vars = total(),
  row_vars = total(label = ""),
  weight = NULL,
  subgroup = NULL
)

combine_functions(..., method = c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_fun_+3A_data">data</code></td>
<td>
<p>data.frame in which context all other arguments will be evaluated
(for <code>cross_*</code>).</p>
</td></tr>
<tr><td><code id="cross_fun_+3A_cell_vars">cell_vars</code></td>
<td>
<p>vector/data.frame/list. Variables on which summary function
will be computed.</p>
</td></tr>
<tr><td><code id="cross_fun_+3A_col_vars">col_vars</code></td>
<td>
<p>vector/data.frame/list. Variables which breaks table by
columns. Use <a href="#topic+mrset">mrset</a>/<a href="#topic+mdset">mdset</a> for multiple-response variables.</p>
</td></tr>
<tr><td><code id="cross_fun_+3A_row_vars">row_vars</code></td>
<td>
<p>vector/data.frame/list. Variables which breaks table by rows.
Use <a href="#topic+mrset">mrset</a>/<a href="#topic+mdset">mdset</a> for multiple-response variables.</p>
</td></tr>
<tr><td><code id="cross_fun_+3A_weight">weight</code></td>
<td>
<p>numeric vector. Optional cases weights. Cases with NA's,
negative and zero weights are removed before calculations.</p>
</td></tr>
<tr><td><code id="cross_fun_+3A_subgroup">subgroup</code></td>
<td>
<p>logical vector. You can specify subgroup on which table will be computed.</p>
</td></tr>
<tr><td><code id="cross_fun_+3A_fun">fun</code></td>
<td>
<p>custom summary function. Generally it is recommended that 
<code>fun</code> will always return object of the same form. Rownames/vector 
names of <code>fun</code> result will appear in the row labels of the table and 
column names/names of list will appear in the column labels. To use weight 
you should have formal <code>weight</code> argument in <code>fun</code> and some logic 
for its processing inside. For <code>cro_fun_df</code> <code>fun</code> will receive 
<a href="data.table.html#topic+data.table">data.table</a> with all names converted to variable labels
(if labels exists). So it is not recommended to rely on original variables
names in your <code>fun</code>.</p>
</td></tr>
<tr><td><code id="cross_fun_+3A_...">...</code></td>
<td>
<p>further arguments for <code>fun</code>  in 
<code>cross_fun</code>/<code>cross_fun_df</code> or functions for <code>combine_functions</code>.
Ignored in <code>cross_fun</code>/<code>cross_fun_df</code> if <code>unsafe</code> is TRUE.</p>
</td></tr>
<tr><td><code id="cross_fun_+3A_unsafe">unsafe</code></td>
<td>
<p>logical/character If not FALSE than <code>fun</code> will be 
evaluated as is. It can lead to significant increase in the performance. 
But there are some limitations. For <code>cross_fun</code> it means that your 
function <code>fun</code> should return vector. If length of this vector is
greater than one than you should provide with <code>unsafe</code> argument vector
of unique labels for each element of this vector. There will be no attempts
to automatically make labels for the results of <code>fun</code>. For 
<code>cross_fun_df</code> your function should return vector or list/data.frame
(optionally with 'row_labels' element - statistic labels). If <code>unsafe</code>
is TRUE or not logical then further arguments (<code>...</code>) for <code>fun</code>
will be ignored.</p>
</td></tr>
<tr><td><code id="cross_fun_+3A_weighted_valid_n">weighted_valid_n</code></td>
<td>
<p>logical. Should we show weighted valid N in
<code>cro_mean_sd_n</code>? By default it is FALSE.</p>
</td></tr>
<tr><td><code id="cross_fun_+3A_labels">labels</code></td>
<td>
<p>character vector of length 3. Labels for mean, standard
deviation and valid N in <code>cro_mean_sd_n</code>.</p>
</td></tr>
<tr><td><code id="cross_fun_+3A_method">method</code></td>
<td>
<p>function which will combine results of multiple functions in
<code>combine_functions</code>. It will be applied as in the expression 
<code>do.call(method, list_of_functions_results)</code>. By default it is
<code>c</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class 'etable'. Basically it's a data.frame but class
is needed for custom methods.
</p>


<h3>See Also</h3>

<p><a href="#topic+tables">tables</a>, <a href="#topic+fre">fre</a>, <a href="#topic+cross_cases">cross_cases</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
mtcars = apply_labels(mtcars,
                      mpg = "Miles/(US) gallon",
                      cyl = "Number of cylinders",
                      disp = "Displacement (cu.in.)",
                      hp = "Gross horsepower",
                      drat = "Rear axle ratio",
                      wt = "Weight (1000 lbs)",
                      qsec = "1/4 mile time",
                      vs = "Engine",
                      vs = c("V-engine" = 0,
                             "Straight engine" = 1),
                      am = "Transmission",
                      am = c("Automatic" = 0,
                             "Manual"=1),
                      gear = "Number of forward gears",
                      carb = "Number of carburetors"
)


# Simple example - there is special shortcut for it - 'cross_mean'
cross_fun(mtcars, 
          list(mpg, disp, hp, wt, qsec), 
          col_vars = list(total(), am), 
          row_vars = vs, 
          fun = mean)



# The same example with 'subgroup'
cross_fun(mtcars, 
       list(mpg, disp, hp, wt, qsec), 
       col_vars = list(total(), am), 
       row_vars = vs, 
       subgroup = vs == 0, 
       fun = mean)
                                
# 'combine_functions' usage  
cross_fun(mtcars, 
          list(mpg, disp, hp, wt, qsec), 
          col_vars = list(total(), am), 
          row_vars = vs, 
          fun = combine_functions(Mean = mean, 
                                  'Std. dev.' = sd,
                                  'Valid N' = valid_n)
)

# 'combine_functions' usage - statistic labels in columns
cross_fun(mtcars, 
          list(mpg, disp, hp, wt, qsec), 
          col_vars = list(total(), am), 
          row_vars = vs, 
          fun = combine_functions(Mean = mean, 
                                  'Std. dev.' = sd,
                                  'Valid N' = valid_n,
                                  method = list
                                  )
)

# 'summary' function
cross_fun(mtcars, 
          list(mpg, disp, hp, wt, qsec), 
          col_vars = list(total(), am), 
          row_vars = list(total(), vs), 
          fun = summary
) 
                          
# comparison 'cross_fun' and 'cross_fun_df'
cross_fun(mtcars,
          data.frame(mpg, disp, hp, wt, qsec), 
          col_vars = am,
          fun = mean
)


# same result
cross_fun_df(mtcars,
             data.frame(mpg, disp, hp, wt, qsec), 
             col_vars = am, 
             fun = colMeans
             )

# usage for 'cross_fun_df' which is not possible for 'cross_fun'
# linear regression by groups
cross_fun_df(mtcars,
             data.frame(mpg, disp, hp, wt, qsec), 
             col_vars = am,
             fun = function(x){
                 frm = reformulate(".", response = as.name(names(x)[1]))
                 model = lm(frm, data = x)
                 cbind('Coef.' = coef(model), 
                       confint(model)
                 )
             } 
)
</code></pre>

<hr>
<h2 id='do_repeat'>Repeats the same transformations on a specified set of variables/values</h2><span id='topic+do_repeat'></span><span id='topic+as_is'></span>

<h3>Description</h3>

<p>Repeats the same transformations on a specified set of variables/values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_repeat(data, ...)

as_is(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do_repeat_+3A_data">data</code></td>
<td>
<p>data.frame/list. If <code>data</code> is list then <code>do_repeat</code>
will be applied to each element of the list.</p>
</td></tr>
<tr><td><code id="do_repeat_+3A_...">...</code></td>
<td>
<p>stand-in name(s) followed by equals sign and a vector/list of 
replacement variables or values. They can be numeric/characters or 
variables names. Names at the top-level can be unquoted (non-standard 
evaluation). Quoted characters also considered as variables names. To avoid
this behavior use <code>as_is</code> function. For standard evaluation of 
parameters you can surround them by round brackets. Also you can use 
<a href="#topic++25to+25">%to%</a> operator and other <a href="#topic+criteria">criteria</a> functions. Last argument
should be expression in curly brackets which will be evaluated in the scope
of data.frame <code>data</code>. See examples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is a special constant <code>.N</code> which equals to number of 
cases in <code>data</code> for usage in expression inside <code>do_repeat</code>. Also 
there are a variables <code>.item_num</code> which is equal to the current 
iteration number and <code>.item_value</code> which is named list with current
stand-in variables values.
</p>


<h3>Value</h3>

<p>transformed data.frame <code>data</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
scaled_iris = do_repeat(iris, 
                        i = Sepal.Length %to% Petal.Width, 
                        {
                            i = scale(i)
                        })
head(scaled_iris)

# several stand-in names and standard evaluattion
old_names = qc(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width)
new_names = paste0("scaled_", old_names)
scaled_iris = do_repeat(iris, 
                        orig = ((old_names)), 
                        scaled = ((new_names)), 
                        {
                            scaled = scale(orig)
                        })
head(scaled_iris)

# numerics
new_df = data.frame(id = 1:20)
# note the automatic creation of the sequence of variables
new_df = do_repeat(new_df, 
                   item = i1 %to% i3, 
                   value = c(1, 2, 3), 
                   {
                       item = value
                   })
head(new_df)

# the same result with internal variable '.item_num'
new_df = data.frame(id = 1:20)
new_df = do_repeat(new_df, 
                   item = i1 %to% i3,
                   {
                       item = .item_num
                   })
head(new_df)

# functions
set.seed(123)
new_df = data.frame(id = 1:20)
new_df = do_repeat(new_df, 
                   item = c(i1, i2, i3), 
                   fun = c("rnorm", "runif", "rexp"), 
                   {
                       item = fun(.N)
                   })
head(new_df)


</code></pre>

<hr>
<h2 id='drop_empty_rows'>Drop empty (with all NA's) rows/columns from data.frame/table</h2><span id='topic+drop_empty_rows'></span><span id='topic+drop_empty_columns'></span><span id='topic+drop_r'></span><span id='topic+drop_c'></span><span id='topic+drop_rc'></span>

<h3>Description</h3>

<p>By default tables produced by functions <a href="#topic+tables">tables</a>, <a href="#topic+cross_cpct">cross_cpct</a>, 
<a href="#topic+cross_fun">cross_fun</a> and <a href="#topic+cross_fun_df">cross_fun_df</a> are created with all 
possible value labels. If values for this labels are absent in variable there 
are NA's in rows and columns. 
<code>drop_empty_rows</code>/<code>drop_empty_columns</code> are intended to remove 
these empty rows/columns. <code>drop_r</code> and <code>drop_c</code> are the same
functions with shorter names. <code>drop_rc</code> drops rows and columns
simultaneously.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_empty_rows(x, excluded_rows = NULL, excluded_columns = NULL)

drop_empty_columns(x, excluded_rows = NULL, excluded_columns = NULL)

drop_r(x, excluded_rows = NULL, excluded_columns = NULL)

drop_c(x, excluded_rows = NULL, excluded_columns = NULL)

drop_rc(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_empty_rows_+3A_x">x</code></td>
<td>
<p>data.frame/etable(result of <a href="#topic+cro">cro</a> and etc.)</p>
</td></tr>
<tr><td><code id="drop_empty_rows_+3A_excluded_rows">excluded_rows</code></td>
<td>
<p>character/logical/numeric rows which won't be dropped
and in which NAs won't be counted. If it is characters then they will be
considered as pattern/vector of patterns. Patterns will be matched with
Perl-style regular expression with values in the first column of <code>x</code>
(see <a href="base.html#topic+grep">grep</a>, <code>perl = TRUE</code> argument). Rows which have such
patterns will be excluded. By default for class 'etable' pattern is &quot;#&quot;
because &quot;#&quot; marks totals in the result of <a href="#topic+cro">cro</a>.</p>
</td></tr>
<tr><td><code id="drop_empty_rows_+3A_excluded_columns">excluded_columns</code></td>
<td>
<p>logical/numeric/characters columns which won't be
dropped and in which NAs won't be counted. By default for class 'etable' it
is first column - column with labels in table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with removed rows/columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
mtcars = apply_labels(mtcars,
            vs = "Engine",
            vs = num_lab("
                      0 V-engine 
                      1 Straight engine
                      9 Other
                      "),
            am = "Transmission",
            am = num_lab("
                     0 Automatic 
                     1 Manual
                     9 Other
                     ")
         )
with_empty = cross_cases(mtcars, am, vs)

drop_empty_rows(with_empty)
drop_empty_columns(with_empty)
drop_rc(with_empty)
                        
</code></pre>

<hr>
<h2 id='expss'>expss: Tables with Labels and Some Useful Functions from Spreadsheets and SPSS Statistics</h2><span id='topic+expss'></span>

<h3>Description</h3>

<p>'expss' package implements some popular functions from spreadsheets and SPSS 
Statistics software. Implementations are not complete copies of their 
originals. I try to make them consistent with other R functions. See examples
in the vignette and in the help.
</p>


<h3>Excel</h3>


<ul>
<li><p>IF <a href="base.html#topic+ifelse">ifelse</a>
</p>
</li>
<li><p>AVERAGE <a href="#topic+mean_row">mean_row</a>
</p>
</li>
<li><p>SUM <a href="#topic+sum_row">sum_row</a>
</p>
</li>
<li><p>MIN <a href="#topic+min_row">min_row</a>
</p>
</li>
<li><p>MAX <a href="#topic+max_row">max_row</a>
</p>
</li>
<li><p>VLOOKUP <a href="maditr.html#topic+vlookup">vlookup</a>
</p>
</li>
<li><p>COUNTIF <a href="#topic+count_if">count_if</a>
</p>
</li>
<li><p>AVERAGEIF <a href="#topic+mean_row_if">mean_row_if</a>
</p>
</li>
<li><p>SUMIF <a href="#topic+sum_row_if">sum_row_if</a>
</p>
</li>
<li><p>MINIF <a href="#topic+min_row_if">min_row_if</a>
</p>
</li>
<li><p>MAXIF <a href="#topic+max_row_if">max_row_if</a>
</p>
</li>
<li><p>IFS <a href="#topic+ifs">ifs</a>
</p>
</li>
<li><p>IFNA <a href="#topic+if_na">if_na</a>
</p>
</li>
<li><p>MATCH <a href="#topic+match_row">match_row</a>
</p>
</li>
<li><p>INDEX <a href="#topic+index_row">index_row</a>
</p>
</li>
<li><p>PIVOT TABLES <a href="#topic+tables">tables</a>, <a href="#topic+cross_fun">cross_fun</a>, <a href="#topic+cross_cpct">cross_cpct</a>
</p>
</li></ul>



<h3>SPSS</h3>


<ul>
<li><p>RECODE <a href="#topic+recode">recode</a>
</p>
</li>
<li><p>COUNT <a href="#topic+count_row_if">count_row_if</a>
</p>
</li>
<li><p>VARIABLE LABELS <a href="#topic+var_lab">var_lab</a>
</p>
</li>
<li><p>VALUE LABELS <a href="#topic+val_lab">val_lab</a>
</p>
</li>
<li><p>ANY <a href="#topic+any_in_row">any_in_row</a>
</p>
</li>
<li><p>FREQUENCIES <a href="#topic+fre">fre</a>
</p>
</li>
<li><p>CROSSTABS <a href="#topic+cro">cro</a>
</p>
</li>
<li><p>CUSTOM TABLES <a href="#topic+tables">tables</a>
</p>
</li></ul>


<hr>
<h2 id='expss.options'>Options for controlling behavior of the package</h2><span id='topic+expss.options'></span><span id='topic+expss_digits'></span><span id='topic+get_expss_digits'></span><span id='topic+expss_round_half_to_even'></span><span id='topic+get_expss_rounding'></span><span id='topic+expss_enable_value_labels_support'></span><span id='topic+expss_enable_value_labels_support_extreme'></span><span id='topic+expss_disable_value_labels_support'></span><span id='topic+expss_output_default'></span><span id='topic+expss_output_commented'></span><span id='topic+expss_output_raw'></span><span id='topic+expss_output_viewer'></span><span id='topic+expss_output_rnotebook'></span><span id='topic+expss_output_huxtable'></span><span id='topic+expss_fix_encoding_on'></span><span id='topic+expss_fix_encoding_off'></span><span id='topic+expss_fre_stat_lab'></span>

<h3>Description</h3>

<p>All options can be set with <code>options(option.name = option.value)</code> or
with special functions (see below). You can get value of option with
<code>getOption("option.name").</code>
</p>

<ul>
<li><p><code>expss.digits</code>  Number of digits after decimal separator which
will be shown for tables. This parameter is supported in the
<a href="#topic+as.datatable_widget">as.datatable_widget</a>, <a href="#topic+htmlTable.etable">htmlTable.etable</a> and <code>print</code>
methods. <code>NULL</code> is default and means one digit. <code>NA</code> means no
rounding. There is a convenience function for this option:
<code>expss_digits</code>.
</p>
</li>
<li><p><code>expss.round_half_to_even</code>  Determines which rounding we will use.
Default rounding is as with R <code>round</code>: &quot;half to even&quot;. For rounding &quot;half to largest&quot; 
set this option to FALSE. This parameter is supported in the <a href="#topic+as.datatable_widget">as.datatable_widget</a>,
<a href="#topic+htmlTable.etable">htmlTable.etable</a>, <code>print</code> and in significance testing
methods. <code>NULL</code> is default and means R default rounding. <code>NA</code> means no
rounding. Parameter does not affect calculations, only table representation. 
There is a convenience function for this option:
<code>expss_round_half_to_even</code>.
</p>
</li>
<li><p><code>expss.enable_value_labels_support</code> By default, all labelled
variables will use labels as labels for factor levels when <a href="base.html#topic+factor">factor</a> is
called. So, any function which calls <a href="base.html#topic+factor">factor</a>/<a href="base.html#topic+as.factor">as.factor</a> will use
value labels. In details this option changes behavior of two methods for
class <code>labelled</code> - <code>as.character</code> and <code>unique</code> - on which
<code>factor</code> depends entirely. If you have compatibility problems set this
option to zero: <code>options(expss.enable_value_labels_support = 0)</code>.
Additionally there is an option for extreme value labels support:
<code>options(expss.enable_value_labels_support = 2)</code>. With this value
<code>factor</code>/<code>as.factor</code> will take into account empty levels. See
example. It is recommended to turn off this option immediately after usage
because <code>unique.labelled</code> will give weird result. Labels without values
will be added to unique values.  There are shortcuts for these options:
<code>expss_enable_value_labels_support()</code>,
<code>expss_enable_value_labels_support_extreme()</code> and
<code>expss_disable_value_labels_support()</code>.
</p>
</li>
<li><p><code>expss.output</code>  By default tables are printed in the console.
You can change this behavior by setting this option. There are five possible
values: <code>'rnotebook'</code>, <code>'viewer'</code>, <code>'commented'</code>,
<code>'raw'</code> or <code>'huxtable'</code>. First option is useful when you run your code in the R Notebook
- output will be rendered to nice HTML. The second option will render tables
to RStudio viewer. <code>knitr</code> is supported automatically via
<code>knit_print</code> method. <code>'commented'</code> prints default output to the
console with comment symbol (<code>#</code>) at the beginning of the each line.
With comment symbol you can easily copy and paste your output into the
script. Option <code>raw</code> disables any formatting and all tables are printed
as data.frames. Option <code>huxtable</code> print output via the huxtable library.
Shortcuts for options: <code>expss_output_default()</code>,
<code>expss_output_raw()</code>, <code>expss_output_viewer()</code>,
<code>expss_output_commented()</code>, <code>expss_output_rnotebook()</code> and
<code>expss_output_huxtable()</code>.
</p>
</li>
<li><p><code>expss_fix_encoding_on</code>/<code>expss_fix_encoding_off</code>  If you
expreience problems with character encoding in RStudio Viewer/RNotebooks under Windows
try <code>expss_fix_encoding_on()</code>. In some cases, it can help.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>expss_digits(digits = NULL)

get_expss_digits()

expss_round_half_to_even(round_half_to_even = TRUE)

get_expss_rounding()

expss_enable_value_labels_support()

expss_enable_value_labels_support_extreme()

expss_disable_value_labels_support()

expss_output_default()

expss_output_commented()

expss_output_raw()

expss_output_viewer()

expss_output_rnotebook()

expss_output_huxtable(...)

expss_fix_encoding_on()

expss_fix_encoding_off()

expss_fre_stat_lab(
  label = c("Count", "Valid percent", "Percent", "Responses, %",
    "Cumulative responses, %")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expss.options_+3A_digits">digits</code></td>
<td>
<p>integer. Number of digits after decimal point. <code>NULL</code> is
default and means 1 digit. <code>NA</code> means no rounding.</p>
</td></tr>
<tr><td><code id="expss.options_+3A_round_half_to_even">round_half_to_even</code></td>
<td>
<p>logical. Default is TRUE which means
default R rounding: &quot;half to even&quot;. For rounding &quot;half to largest&quot; 
set this option to FALSE.</p>
</td></tr>
<tr><td><code id="expss.options_+3A_...">...</code></td>
<td>
<p>list of parameters for <code>huxtable::set_default_properties</code>.
See <a href="huxtable.html#topic+set_default_properties">set_default_properties</a>.</p>
</td></tr>
<tr><td><code id="expss.options_+3A_label">label</code></td>
<td>
<p>character vector of length 5. Default labels for <a href="#topic+fre">fre</a>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# example of different levels of value labels support
my_scale = c(1, 2, 2, 2)
# note that we have label 'Hard to say' for which there are no values in 'my_scale'
val_lab(my_scale) = num_lab("
                            1 Yes
                            2 No
                            3 Hard to say
                            ")
# disable labels support
expss_disable_value_labels_support()
table(my_scale) # there is no labels in the result
unique(my_scale)
# default value labels support
expss_enable_value_labels_support()
# table with labels but there are no label "Hard to say"
table(my_scale)
unique(my_scale)
# extreme value labels support
expss_enable_value_labels_support_extreme()
# now we see "Hard to say" with zero counts
table(my_scale)
# weird 'unique'! There is a value 3 which is absent in 'my_scale'
unique(my_scale)
# return immediately to defaults to avoid issues
expss_enable_value_labels_support()
</code></pre>

<hr>
<h2 id='fctr'>Convert labelled variable to factor</h2><span id='topic+fctr'></span>

<h3>Description</h3>

<p><code>fctr</code> converts variable to factor. It force labels usage as factor 
labels for labelled variables even if 'expss.enable_value_labels_support' set
to 0. For other types of variables base <a href="base.html#topic+factor">factor</a> is called. Factor
levels are constructed as values labels. If label doesn't exist for
particular value then this value remain as is - so there is no information
lost. This levels look like as &quot;Variable_label|Value label&quot; if argument
<code>prepend</code> set to TRUE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fctr(x, ..., drop_unused_labels = FALSE, prepend_var_lab = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fctr_+3A_x">x</code></td>
<td>
<p>a vector of data with labels.</p>
</td></tr>
<tr><td><code id="fctr_+3A_...">...</code></td>
<td>
<p>optional arguments for <code><a href="base.html#topic+factor">factor</a></code></p>
</td></tr>
<tr><td><code id="fctr_+3A_drop_unused_labels">drop_unused_labels</code></td>
<td>
<p>logical. Should we drop unused value labels?
Default is FALSE.</p>
</td></tr>
<tr><td><code id="fctr_+3A_prepend_var_lab">prepend_var_lab</code></td>
<td>
<p>logical. Should we prepend variable label before value
labels? Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class factor. For details see base <a href="base.html#topic+factor">factor</a> documentation.
</p>


<h3>See Also</h3>

<p><a href="#topic+values2labels">values2labels</a>, <a href="#topic+names2labels">names2labels</a>, <a href="#topic+val_lab">val_lab</a>, 
<a href="#topic+var_lab">var_lab</a>. Materials for base functions: <code><a href="base.html#topic+factor">factor</a></code>,
<code><a href="base.html#topic+factor">as.factor</a></code>, <code><a href="base.html#topic+factor">ordered</a></code>,
<code><a href="base.html#topic+factor">as.ordered</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)

var_lab(mtcars$am) = "Transmission"
val_lab(mtcars$am) = c(automatic = 0, manual=1)

summary(lm(mpg ~ am, data = mtcars)) # no labels  
summary(lm(mpg ~ fctr(am), data = mtcars)) # with labels 
summary(lm(mpg ~ fctr(unvr(am)), data = mtcars)) # without variable label 
</code></pre>

<hr>
<h2 id='fre'>Simple frequencies with support of labels, weights and multiple response variables.</h2><span id='topic+fre'></span>

<h3>Description</h3>

<p><code>fre</code> returns data.frame with six columns: labels or values, counts, 
valid percent (excluding NA), percent (with NA), percent of responses(for 
single-column <code>x</code> it equals to valid percent) and cumulative percent of 
responses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fre(
  x,
  weight = NULL,
  drop_unused_labels = TRUE,
  prepend_var_lab = FALSE,
  stat_lab = getOption("expss.fre_stat_lab", c("Count", "Valid percent", "Percent",
    "Responses, %", "Cumulative responses, %"))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fre_+3A_x">x</code></td>
<td>
<p>vector/data.frame/list. data.frames are considered as multiple
response variables. If <code>x</code> is list then vertically stacked frequencies
for each element of list will be generated,</p>
</td></tr>
<tr><td><code id="fre_+3A_weight">weight</code></td>
<td>
<p>numeric vector. Optional case weights. NA's and negative weights
treated as zero weights.</p>
</td></tr>
<tr><td><code id="fre_+3A_drop_unused_labels">drop_unused_labels</code></td>
<td>
<p>logical. Should we drop unused value labels?
Default is TRUE.</p>
</td></tr>
<tr><td><code id="fre_+3A_prepend_var_lab">prepend_var_lab</code></td>
<td>
<p>logical. Should we prepend variable label before value
labels? By default we will add variable labels to value labels only if
<code>x</code> or predictor is list (several variables).</p>
</td></tr>
<tr><td><code id="fre_+3A_stat_lab">stat_lab</code></td>
<td>
<p>character. Labels for the frequency columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class 'etable'. Basically it's a data.frame but class
is needed for custom methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
mtcars = mtcars %&gt;% 
    apply_labels(
        mpg = "Miles/(US) gallon",
        cyl = "Number of cylinders",
        disp = "Displacement (cu.in.)",
        hp = "Gross horsepower",
        drat = "Rear axle ratio",
        wt = "Weight (lb/1000)",
        qsec = "1/4 mile time",
        vs = "Engine",
        vs = c("V-engine" = 0, 
                "Straight engine" = 1),
        am = "Transmission",
        am = c(automatic = 0, 
                manual=1),
        gear = "Number of forward gears",
        carb = "Number of carburetors"
    )

fre(mtcars$vs)

# stacked frequencies
fre(list(mtcars$vs, mtcars$am))

# multiple-choice variable
# brands - multiple response question
# Which brands do you use during last three months? 
set.seed(123)
brands = data.frame(t(replicate(20,sample(c(1:5,NA),4,replace = FALSE))))
# score - evaluation of tested product
score = sample(-1:1,20,replace = TRUE)
var_lab(brands) = "Used brands"
val_lab(brands) = make_labels("
                              1 Brand A
                              2 Brand B
                              3 Brand C
                              4 Brand D
                              5 Brand E
                              ")

var_lab(score) = "Evaluation of tested brand"
val_lab(score) = make_labels("
                             -1 Dislike it
                             0 So-so
                             1 Like it    
                             ")

fre(brands)

# stacked frequencies
fre(list(score, brands))

</code></pre>

<hr>
<h2 id='htmlTable.etable'>Outputting HTML tables in RStudio viewer/R Notebooks</h2><span id='topic+htmlTable.etable'></span><span id='topic+htmlTable.with_caption'></span><span id='topic+htmlTable.list'></span><span id='topic+knit_print.etable'></span><span id='topic+knit_print.with_caption'></span><span id='topic+repr_html.etable'></span><span id='topic+repr_html.with_caption'></span><span id='topic+repr_text.etable'></span><span id='topic+repr_text.with_caption'></span>

<h3>Description</h3>

<p>This is method for rendering results of <a href="#topic+fre">fre</a>/<a href="#topic+cro">cro</a>/<a href="#topic+tables">tables</a>
in Shiny/RMarkdown/Jupyter notebooks and etc. For detailed description of
function and its arguments see <a href="htmlTable.html#topic+htmlTable">htmlTable</a>. You can pack your
tables in the list and render them all simultaneously. See examples. You may
be interested in <code>expss_output_viewer()</code> for automatical rendering
tables in the RStudio viewer or  <code>expss_output_rnotebook()</code> for
rendering in the R notebooks. See <a href="#topic+expss.options">expss.options</a>. <code>repr_html</code> is
method for rendering table in the Jupyter notebooks and <code>knit_print</code> is
method for rendering table in the <code>knitr</code> HTML-documents. Jupyter
notebooks and <code>knitr</code> documents are supported automatically but in the R
notebooks it is needed to set output to notebook via
<code>expss_output_rnotebook()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'etable'
htmlTable(
  x,
  header = NULL,
  rnames = NULL,
  rowlabel = NULL,
  caption = NULL,
  tfoot = NULL,
  label = NULL,
  rgroup = NULL,
  n.rgroup = NULL,
  cgroup = NULL,
  n.cgroup = NULL,
  tspanner = NULL,
  n.tspanner = NULL,
  total = NULL,
  ctable = TRUE,
  compatibility = getOption("htmlTableCompat", "LibreOffice"),
  cspan.rgroup = "all",
  escape.html = FALSE,
  ...,
  digits = get_expss_digits(),
  row_groups = TRUE
)

## S3 method for class 'with_caption'
htmlTable(
  x,
  header = NULL,
  rnames = NULL,
  rowlabel = NULL,
  caption = NULL,
  tfoot = NULL,
  label = NULL,
  rgroup = NULL,
  n.rgroup = NULL,
  cgroup = NULL,
  n.cgroup = NULL,
  tspanner = NULL,
  n.tspanner = NULL,
  total = NULL,
  ctable = TRUE,
  compatibility = getOption("htmlTableCompat", "LibreOffice"),
  cspan.rgroup = "all",
  escape.html = FALSE,
  ...,
  digits = get_expss_digits(),
  row_groups = TRUE
)

## S3 method for class 'list'
htmlTable(
  x,
  header = NULL,
  rnames = NULL,
  rowlabel = NULL,
  caption = NULL,
  tfoot = NULL,
  label = NULL,
  rgroup = NULL,
  n.rgroup = NULL,
  cgroup = NULL,
  n.cgroup = NULL,
  tspanner = NULL,
  n.tspanner = NULL,
  total = NULL,
  ctable = TRUE,
  compatibility = getOption("htmlTableCompat", "LibreOffice"),
  cspan.rgroup = "all",
  escape.html = FALSE,
  ...,
  digits = get_expss_digits(),
  row_groups = TRUE,
  gap = "&lt;br&gt;"
)

knit_print.etable(x, ..., digits = get_expss_digits(), escape.html = FALSE)

knit_print.with_caption(
  x,
  ...,
  digits = get_expss_digits(),
  escape.html = FALSE
)

repr_html.etable(obj, ..., digits = get_expss_digits(), escape.html = FALSE)

repr_html.with_caption(
  obj,
  ...,
  digits = get_expss_digits(),
  escape.html = FALSE
)

repr_text.etable(obj, ..., digits = get_expss_digits())

repr_text.with_caption(obj, ..., digits = get_expss_digits())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="htmlTable.etable_+3A_x">x</code></td>
<td>
<p>a data object of class 'etable' - result of <a href="#topic+fre">fre</a>/<a href="#topic+cro">cro</a> and etc.</p>
</td></tr>
<tr><td><code id="htmlTable.etable_+3A_header">header</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="htmlTable.etable_+3A_rnames">rnames</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="htmlTable.etable_+3A_rowlabel">rowlabel</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="htmlTable.etable_+3A_caption">caption</code></td>
<td>
<p>See manual for <a href="htmlTable.html#topic+htmlTable">htmlTable</a>.</p>
</td></tr>
<tr><td><code id="htmlTable.etable_+3A_tfoot">tfoot</code></td>
<td>
<p>See manual for <a href="htmlTable.html#topic+htmlTable">htmlTable</a>.</p>
</td></tr>
<tr><td><code id="htmlTable.etable_+3A_label">label</code></td>
<td>
<p>See manual for <a href="htmlTable.html#topic+htmlTable">htmlTable</a>.</p>
</td></tr>
<tr><td><code id="htmlTable.etable_+3A_rgroup">rgroup</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="htmlTable.etable_+3A_n.rgroup">n.rgroup</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="htmlTable.etable_+3A_cgroup">cgroup</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="htmlTable.etable_+3A_n.cgroup">n.cgroup</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="htmlTable.etable_+3A_tspanner">tspanner</code></td>
<td>
<p>See manual for <a href="htmlTable.html#topic+htmlTable">htmlTable</a>.</p>
</td></tr>
<tr><td><code id="htmlTable.etable_+3A_n.tspanner">n.tspanner</code></td>
<td>
<p>See manual for <a href="htmlTable.html#topic+htmlTable">htmlTable</a>.</p>
</td></tr>
<tr><td><code id="htmlTable.etable_+3A_total">total</code></td>
<td>
<p>See manual for <a href="htmlTable.html#topic+htmlTable">htmlTable</a>.</p>
</td></tr>
<tr><td><code id="htmlTable.etable_+3A_ctable">ctable</code></td>
<td>
<p>See manual for <a href="htmlTable.html#topic+htmlTable">htmlTable</a>.</p>
</td></tr>
<tr><td><code id="htmlTable.etable_+3A_compatibility">compatibility</code></td>
<td>
<p>See manual for <a href="htmlTable.html#topic+htmlTable">htmlTable</a>.</p>
</td></tr>
<tr><td><code id="htmlTable.etable_+3A_cspan.rgroup">cspan.rgroup</code></td>
<td>
<p>See manual for <a href="htmlTable.html#topic+htmlTable">htmlTable</a>.</p>
</td></tr>
<tr><td><code id="htmlTable.etable_+3A_escape.html">escape.html</code></td>
<td>
<p>logical: should HTML characters be escaped? Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="htmlTable.etable_+3A_...">...</code></td>
<td>
<p>further parameters for <a href="htmlTable.html#topic+htmlTable">htmlTable</a>.</p>
</td></tr>
<tr><td><code id="htmlTable.etable_+3A_digits">digits</code></td>
<td>
<p>integer By default, all numeric columns are rounded to one digit after
decimal separator. Also you can set this argument by setting option 'expss.digits'
- for example, <code>expss_digits(2)</code>. If it is NA than all
numeric columns remain unrounded.</p>
</td></tr>
<tr><td><code id="htmlTable.etable_+3A_row_groups">row_groups</code></td>
<td>
<p>logical Should we create row groups? TRUE by default.</p>
</td></tr>
<tr><td><code id="htmlTable.etable_+3A_gap">gap</code></td>
<td>
<p>character Separator between tables if we output list of
tables. By default it is line break '&lt;br&gt;'.</p>
</td></tr>
<tr><td><code id="htmlTable.etable_+3A_obj">obj</code></td>
<td>
<p>a data object of class 'etable' - result of <a href="#topic+fre">fre</a>/<a href="#topic+cro">cro</a> and etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a string of class htmlTable
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  
data(mtcars)
mtcars = apply_labels(mtcars,
                      mpg = "Miles/(US) gallon",
                      cyl = "Number of cylinders",
                      disp = "Displacement (cu.in.)",
                      hp = "Gross horsepower",
                      drat = "Rear axle ratio",
                      wt = "Weight (1000 lbs)",
                      qsec = "1/4 mile time",
                      vs = "Engine",
                      vs = c("V-engine" = 0,
                             "Straight engine" = 1),
                      am = "Transmission",
                      am = c("Automatic" = 0,
                             "Manual"=1),
                      gear = "Number of forward gears",
                      carb = "Number of carburetors"
)

expss_output_viewer()
mtcars %&gt;% 
     tab_cols(total(), am %nest% vs) %&gt;% 
     tab_cells(mpg, hp) %&gt;% 
     tab_stat_mean() %&gt;% 
     tab_cells(cyl) %&gt;% 
     tab_stat_cpct() %&gt;% 
     tab_pivot() %&gt;% 
     set_caption("Table 1. Some variables from mtcars dataset.")
     
# several tables in a list
list(
    cross_cpct(mtcars, list(am, vs, cyl), list(total(), am))
        %&gt;% set_caption("Table 1. Percent."),   
    cross_mean_sd_n(mtcars, list(mpg, hp, qsec), list(total(), am)) 
        %&gt;% set_caption("Table 2. Means.")
    ) %&gt;% 
    htmlTable()
     
expss_output_default()   
 

## End(Not run)
</code></pre>

<hr>
<h2 id='if_na'>Replace values with NA and vice-versa</h2><span id='topic+if_na'></span><span id='topic+if_na+3C-'></span><span id='topic++25if_na+25'></span><span id='topic+na_if'></span><span id='topic+na_if+3C-'></span><span id='topic++25na_if+25'></span><span id='topic+mis_val'></span><span id='topic+mis_val+3C-'></span><span id='topic++25mis_val+25'></span><span id='topic+valid'></span>

<h3>Description</h3>


<ul>
<li><p><code>if_na</code> replaces NA values in vector/data.frame/matrix/list with
supplied value. For single value argument label can be provided with
<code>label</code> argument. If replacement value is vector then <code>if_na</code> uses
for replacement values from appropriate positions.  An opposite operation is <code>na_if</code>.
</p>
</li>
<li><p><code>na_if</code> replaces values with NA in
vector/data.frame/matrix/list. Another alias for this is <code>mis_val</code>.
</p>
</li>
<li><p><code>valid</code> returns logical vector which indicate the presence of at
least one not-NA value in row.  For vector or single column data.frame result
is the same as with <a href="stats.html#topic+complete.cases">complete.cases</a>. There is a special case
for data.frame of class <code>dichotomy</code>. In this case result indicate the
presence of at least one 1 in a row. </p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>if_na(x, value, label = NULL)

if_na(x, label = NULL) &lt;- value

x %if_na% value

na_if(x, value, with_labels = FALSE)

na_if(x, with_labels = FALSE) &lt;- value

x %na_if% value

mis_val(x, value, with_labels = FALSE)

mis_val(x, with_labels = FALSE) &lt;- value


valid(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="if_na_+3A_x">x</code></td>
<td>
<p>vector/matrix/data.frame/list</p>
</td></tr>
<tr><td><code id="if_na_+3A_value">value</code></td>
<td>
<p>single value, vector of the same length as number of rows in
<code>x</code>, or function (<a href="#topic+criteria">criteria</a>) for <code>na_if</code>. See <a href="#topic+recode">recode</a>
for details.</p>
</td></tr>
<tr><td><code id="if_na_+3A_label">label</code></td>
<td>
<p>a character of length 1. Label for <code>value</code> which replace NA.</p>
</td></tr>
<tr><td><code id="if_na_+3A_with_labels">with_labels</code></td>
<td>
<p>logical. FALSE by default. Should we also remove labels of
values which we recode to NA?</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>


<h3>Value</h3>

<p>object of the same form and class as <code>x</code>. <code>valid</code> returns logical vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple case
a = c(NA, 2, 3, 4, NA)
if_na(a, 99)

# the same result
a %if_na% 99

# with label
a = c(NA, 2, 3, 4, NA)
if_na(a, 99, label = "Hard to say")

# in-place replacement. The same result:
if_na(a, label = "Hard to say") = 99 
a # c(99, 2, 3, 4, 99)

# replacement with values from other variable
a = c(NA, 2, 3, 4, NA)
b = 1:5
if_na(a, b)

# replacement with group means
# make data.frame 
set.seed(123)
group = sample(1:3, 30, replace = TRUE)
param = runif(30)
param[sample(30, 10)] = NA # place 10 NA's
df = data.frame(group, param)

# replace NA's with group means
if_na(df$param) = window_fun(df$param, df$group, mean_col)
df

######################
### na_if examples ###
######################

a = c(1:5, 99)
# 99 to NA
na_if(a, 99)    # c(1:5, NA)

a %na_if% 99    # same result

# values which greater than 4 to NA
na_if(a, gt(4)) # c(1:4, NA, NA)

# alias 'mis_val', with_labels = TRUE
a = c(1, 1, 2, 2, 99)
val_lab(a) = c(Yes = 1, No = 2, "Hard to say" = 99)
mis_val(a, 99, with_labels = TRUE)

set.seed(123)
dfs = data.frame(
      a = c("bad value", "bad value", "good value", "good value", "good value"),
      b = runif(5)
)

# rows with 'bad value' will be filled with NA
# logical argument and recycling by columns
na_if(dfs, dfs$a=="bad value")

a = rnorm(50)
# values greater than 1 or less than -1 will be set to NA
# special functions usage
na_if(a, lt(-1) | gt(1))

# values inside [-1, 1] to NA
na_if(a, -1 %thru% 1)
</code></pre>

<hr>
<h2 id='info'>Provides variables description for dataset</h2><span id='topic+info'></span>

<h3>Description</h3>

<p><code>info</code> returns data.frame with variables description and some summary
statistics. Resulting data.frame mainly intended to keep in front of eyes in 
RStudio viewer or to be saved as csv to view in the spreadsheet software as 
reference about working dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>info(x, stats = TRUE, frequencies = TRUE, max_levels = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="info_+3A_x">x</code></td>
<td>
<p>vector/factor/list/data.frame.</p>
</td></tr>
<tr><td><code id="info_+3A_stats">stats</code></td>
<td>
<p>Logical. Should we calculate summary for each variable?</p>
</td></tr>
<tr><td><code id="info_+3A_frequencies">frequencies</code></td>
<td>
<p>Logical. Should we calculate frequencies for each 
variable? This calculation can take significant amount of time for large 
datasets.</p>
</td></tr>
<tr><td><code id="info_+3A_max_levels">max_levels</code></td>
<td>
<p>Numeric. Maximum levels for using in frequency 
calculations. Levels above this value will convert to 'Other values'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with following columns: Name, Class, Length, NotNA, NA, 
Distincts, Label, ValueLabels, Min., 1st Qu., Median, Mean, 3rd Qu., Max., 
Frequency.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
var_lab(mtcars$am) = "Transmission"
val_lab(mtcars$am) = c("Automatic"=0, "Manual"=1)
info(mtcars, max_levels = 5)                             
</code></pre>

<hr>
<h2 id='keep'>Keep or drop elements by name/criteria in data.frame/matrix</h2><span id='topic+keep'></span><span id='topic+except'></span>

<h3>Description</h3>

<p><code>keep</code> selects variables/elements from data.frame by their names or by 
criteria (see <a href="#topic+criteria">criteria</a>). <code>except</code> drops variables/elements from 
data.frame by their names or by criteria. Names at the top-level can be
unquoted (non-standard evaluation). For standard evaluation of parameters you
can surround them by round brackets. See examples. Methods for list will apply
<code>keep</code>/<code>except</code> to each element of the list separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keep(data, ...)

except(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keep_+3A_data">data</code></td>
<td>
<p>data.frame/matrix/list</p>
</td></tr>
<tr><td><code id="keep_+3A_...">...</code></td>
<td>
<p>column names of type character/numeric or criteria/logical functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of the same type as <code>data</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
columns(iris, Sepal.Length, Sepal.Width)  
columns(iris, -Species)

columns(iris, Species, "^.") # move 'Species' to the first position

columns(iris, -"^Petal") # remove columns which names start with 'Petal'

columns(iris, -5) # remove fifth column

data(mtcars)
columns(mtcars, mpg:qsec) # keep columns from 'mpg' to 'qsec'
columns(mtcars, mpg %to% qsec) # the same result

 # standard and non-standard evaluation
 many_vars = c("am", "vs", "cyl")
 columns(mtcars, many_vars)
 
# character expansion
dfs = data.frame(
     a =   rep(10, 5),
     b_1 = rep(11, 5),
     b_2 = rep(12, 5),
     b_3 = rep(12, 5),
     b_4 = rep(14, 5),
     b_5 = rep(15, 5) 
 )
 i = 1:5
 columns(dfs, b_1 %to% b_5) 
 columns(dfs, "b_{i}") # the same result  
</code></pre>

<hr>
<h2 id='match_row'>Match finds value in rows or columns/index returns value by index from rows or columns</h2><span id='topic+match_row'></span><span id='topic+match_col'></span><span id='topic+index_row'></span><span id='topic+index_col'></span><span id='topic+value_row_if'></span><span id='topic+value_col_if'></span>

<h3>Description</h3>

<p><code>match</code> finds value in rows or columns. <code>index</code> returns value by index
from row or column. One can use functions as criteria for <code>match</code>. In 
this case position of first value on which function equals to TRUE will be 
returned. For convenience there are special predefined functions - see
<a href="#topic+criteria">criteria</a>. If value is not found then NA will be returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_row(criterion, ...)

match_col(criterion, ...)

index_row(index, ...)

index_col(index, ...)

value_row_if(criterion, ...)

value_col_if(criterion, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_row_+3A_criterion">criterion</code></td>
<td>
<p>Vector of values to be matched, or
function.</p>
</td></tr>
<tr><td><code id="match_row_+3A_...">...</code></td>
<td>
<p>data. Vectors, matrixes, data.frames, lists. Shorter arguments
will be recycled.</p>
</td></tr>
<tr><td><code id="match_row_+3A_index">index</code></td>
<td>
<p>vector of positions in rows/columns from which values should be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with length equals to number of rows for *_row and equals to
number of columns for *_col.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># toy data
v1 = 1:3
v2 = 2:4
v3 = 7:5

# postions of 1,3,5 in rows
match_row(c(1, 3, 5), v1, v2, v3) # 1:3
# postions of 1,3,5 in columns
match_col(1, v1, v2, v3) # c(v1 = 1, v2 = NA, v3 = NA)

# postion of first value greater than 2
ix = match_row(gt(2), v1, v2, v3) 
ix # c(3,2,1)
# return values by result of previous 'match_row' 
index_row(ix, v1, v2, v3) # c(7,3,3)

# the same actions with data.frame
dfs = data.frame(v1, v2, v3)

# postions of 1,3,5 in rows
match_row(c(1, 3, 5), dfs) # 1:3
# postions of 1,3,5 in columns
match_col(1, dfs) # c(v1 = 1, v2 = NA, v3 = NA)

# postion of first value greater than 2
ix = match_row(gt(2), dfs) 
ix # c(3,2,1)
# return values by result of previous 'match_row' 
index_row(ix, dfs) # c(7,3,3)
</code></pre>

<hr>
<h2 id='merge.etable'>Merge two tables/data.frames</h2><span id='topic+merge.etable'></span>

<h3>Description</h3>

<p><code>%merge%</code> is infix shortcut for base <a href="base.html#topic+merge">merge</a> with 
<code>all.x = TRUE</code> and  <code>all.y = FALSE</code> (left join). There is also 
special method for combining results of <code>cross_*</code> and <code>fre</code>. For them
<code>all = TRUE</code> (full join). It allows make complex tables from simple
ones. See examples. Strange result is possible if one or two arguments have
duplicates in first column (column with labels).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'etable'
merge(
  x,
  y,
  by = 1,
  by.x = by,
  by.y = by,
  all = TRUE,
  all.x = all,
  all.y = all,
  sort = FALSE,
  suffixes = c("", ""),
  incomparables = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge.etable_+3A_x">x</code></td>
<td>
<p>data.frame or results of <code>fre</code>/<code>cross_*</code>/<code>table_*</code></p>
</td></tr>
<tr><td><code id="merge.etable_+3A_y">y</code></td>
<td>
<p>data.frame or results of <code>fre</code>/<code>cross_*</code>/<code>table_*</code></p>
</td></tr>
<tr><td><code id="merge.etable_+3A_by">by</code></td>
<td>
<p>for 'etable' object default is 1 (first column). For details see <a href="base.html#topic+merge">merge</a></p>
</td></tr>
<tr><td><code id="merge.etable_+3A_by.x">by.x</code></td>
<td>
<p>For details see <a href="base.html#topic+merge">merge</a></p>
</td></tr>
<tr><td><code id="merge.etable_+3A_by.y">by.y</code></td>
<td>
<p>For details see <a href="base.html#topic+merge">merge</a></p>
</td></tr>
<tr><td><code id="merge.etable_+3A_all">all</code></td>
<td>
<p>For details see <a href="base.html#topic+merge">merge</a></p>
</td></tr>
<tr><td><code id="merge.etable_+3A_all.x">all.x</code></td>
<td>
<p>For details see <a href="base.html#topic+merge">merge</a></p>
</td></tr>
<tr><td><code id="merge.etable_+3A_all.y">all.y</code></td>
<td>
<p>For details see <a href="base.html#topic+merge">merge</a></p>
</td></tr>
<tr><td><code id="merge.etable_+3A_sort">sort</code></td>
<td>
<p>For details see <a href="base.html#topic+merge">merge</a></p>
</td></tr>
<tr><td><code id="merge.etable_+3A_suffixes">suffixes</code></td>
<td>
<p>For details see <a href="base.html#topic+merge">merge</a></p>
</td></tr>
<tr><td><code id="merge.etable_+3A_incomparables">incomparables</code></td>
<td>
<p>For details see <a href="base.html#topic+merge">merge</a></p>
</td></tr>
<tr><td><code id="merge.etable_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>See Also</h3>

<p><a href="#topic+fre">fre</a>, <a href="#topic+cross_cpct">cross_cpct</a>, <a href="#topic+cross_fun">cross_fun</a>, <a href="base.html#topic+merge">merge</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(2)
data(mtcars)
# apply labels
mtcars = apply_labels(mtcars,
                mpg = "Miles/(US) gallon",
                cyl = "Number of cylinders",
                disp = "Displacement (cu.in.)",
                hp = "Gross horsepower",
                drat = "Rear axle ratio",
                wt = "Weight (lb/1000)",
                qsec = "1/4 mile time",
                vs = "V/S",
                vs = c("V-engine" = 0, "Straight engine" = 1),
                am = "Transmission (0 = automatic, 1 = manual)",
                am = c(automatic = 0, manual = 1),
                gear = "Number of forward gears",
                carb = "Number of carburetors"
)

# table by 'am'
tab1 = cross_cpct(mtcars, gear, am)
# table with percents
tab2 = cross_cpct(mtcars, gear, vs)

# combine tables
tab1 %&gt;% merge(tab2)

# complex tables
# table with counts
counts = cross_cases(mtcars, list(vs, am, gear, carb), list("Count"))
# table with percents
percents = cross_cpct(mtcars, list(vs, am, gear, carb), list("Column, %"))

# combine tables
counts %&gt;% merge(percents)
</code></pre>

<hr>
<h2 id='mrset'>Create multiple response set/multiple dichotomy set from variables</h2><span id='topic+mrset'></span><span id='topic+mdset'></span><span id='topic+mrset_f'></span><span id='topic+mdset_f'></span><span id='topic+mrset_p'></span><span id='topic+mdset_p'></span><span id='topic+mrset_t'></span><span id='topic+mdset_t'></span>

<h3>Description</h3>

<p>These functions are intended for usage with tables - <a href="#topic+tables">tables</a>,
<a href="#topic+cross_cpct">cross_cpct</a>, <a href="#topic+cross_fun">cross_fun</a>. Result of <code>mrset</code> is considered as 
muliple-response set with category encoding and result of <code>mdset</code> is 
considered as multiple response set with dichotomy (dummy) encoding e. g. 
with 0 or 1 in the each column. Each column in the <code>dichotomy</code> is 
indicator of absence or presence of particular feature. Both functions don't 
convert its arguments to anything - it is supposed that arguments already 
have appropriate encoding. For conversation see <a href="#topic+as.dichotomy">as.dichotomy</a> or 
<a href="#topic+as.category">as.category</a>. 
</p>

<ul>
<li><p><code>mrset_f</code> and <code>mdset_f</code> select variables by fixed pattern. Fixed
pattern can be unquoted. For details see <a href="#topic+..f">..f</a>.
</p>
</li>
<li><p><code>mrset_p</code> and <code>mdset_p</code> select variables for
multiple-responses by perl-style regular expresssion. For details see <a href="#topic+..p">..p</a>.
</p>
</li>
<li><p><code>mrset_t</code> and <code>mdset_t</code> select variables by expanding text
arguments. For details see <a href="#topic+..t">..t</a> and <a href="maditr.html#topic+text_expand">text_expand</a>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>mrset(..., label = NULL)

mdset(..., label = NULL)

mrset_f(..., label = NULL)

mdset_f(..., label = NULL)

mrset_p(..., label = NULL)

mdset_p(..., label = NULL)

mrset_t(..., label = NULL)

mdset_t(..., label = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mrset_+3A_...">...</code></td>
<td>
<p>variables</p>
</td></tr>
<tr><td><code id="mrset_+3A_label">label</code></td>
<td>
<p>character optional label for multiple response set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame of class <code>category</code>/<code>dichotomy</code>
</p>


<h3>See Also</h3>

<p><a href="#topic+as.dichotomy">as.dichotomy</a>, <a href="#topic+as.category">as.category</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(2)
data(product_test)

cross_cpct(product_test, mrset(a1_1 %to% a1_6))

# same result
cross_cpct(product_test, mrset_f(a1_))

# same result
cross_cpct(product_test, mrset_p("a1_"))

# same result
cross_cpct(product_test, mrset_t("a1_{1:6}"))
</code></pre>

<hr>
<h2 id='name_dots'>Bug workaround</h2><span id='topic+name_dots'></span>

<h3>Description</h3>

<p>Function is added to workaround strange bug with data.table (issue #10).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>name_dots(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="name_dots_+3A_...">...</code></td>
<td>
<p>arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>

<hr>
<h2 id='names2labels'>Replace data.frame/list names with corresponding variables labels.</h2><span id='topic+names2labels'></span><span id='topic+n2l'></span>

<h3>Description</h3>

<p><code>names2labels</code> replaces data.frame/list names with corresponding 
variables labels. If there are no labels for some variables their names
remain unchanged. <code>n2l</code> is just shortcut for <code>names2labels</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>names2labels(x, exclude = NULL, keep_names = FALSE)

n2l(x, exclude = NULL, keep_names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="names2labels_+3A_x">x</code></td>
<td>
<p>data.frame/list.</p>
</td></tr>
<tr><td><code id="names2labels_+3A_exclude">exclude</code></td>
<td>
<p>logical/integer/character columns which names should be left
unchanged. Only applicable to list/data.frame.</p>
</td></tr>
<tr><td><code id="names2labels_+3A_keep_names">keep_names</code></td>
<td>
<p>logical. If TRUE original column names will be kept with
labels. Only applicable to list/data.frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of the same type as x but with variable labels instead of
names.
</p>


<h3>See Also</h3>

<p><a href="#topic+values2labels">values2labels</a>, <a href="#topic+val_lab">val_lab</a>,  <a href="#topic+var_lab">var_lab</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
mtcars = mtcars %&gt;% 
    apply_labels(
        mpg = "Miles/(US) gallon",
        cyl = "Number of cylinders",
        disp = "Displacement (cu.in.)",
        hp = "Gross horsepower",
        drat = "Rear axle ratio",
        wt = "Weight (lb/1000)",
        qsec = "1/4 mile time",
        vs = "Engine",
        vs = c("V-engine" = 0, 
                "Straight engine" = 1),
        am = "Transmission",
        am = c(automatic = 0, 
                manual=1),
        gear = "Number of forward gears",
        carb = "Number of carburetors"
    )

# without original names
# note: we exclude dependent variable 'mpg' from conversion to use its short name in formula
summary(lm(mpg ~ ., data = names2labels(mtcars, exclude = "mpg")))
# with names
summary(lm(mpg ~ ., data = names2labels(mtcars, exclude = "mpg", keep_names = TRUE)))
</code></pre>

<hr>
<h2 id='nest'>Compute nested variable(-s) from several variables</h2><span id='topic+nest'></span><span id='topic++25nest+25'></span>

<h3>Description</h3>

<p><code>nest</code> mainly intended for usage with table functions such as 
<a href="#topic+cro">cro</a>. See examples. <code>%nest%</code> is infix version of this function. 
You can apply <code>nest</code> on multiple-response variables/list of variables
and data.frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest(...)

x %nest% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_+3A_...">...</code></td>
<td>
<p>vectors/data.frames/lists</p>
</td></tr>
<tr><td><code id="nest_+3A_x">x</code></td>
<td>
<p>vector/data.frame/list</p>
</td></tr>
<tr><td><code id="nest_+3A_y">y</code></td>
<td>
<p>vector/data.frame/list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector/data.frame/list
</p>


<h3>See Also</h3>

<p>See also <a href="base.html#topic+interaction">interaction</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)

mtcars = apply_labels(mtcars,
                      cyl = "Number of cylinders",
                      vs = "Engine",
                      vs = num_lab("
                             0 V-engine 
                             1 Straight engine
                             "),
                      am = "Transmission",
                      am = num_lab("
                             0 Automatic 
                             1 Manual
                             "),
                      carb = "Number of carburetors"
)

data.table::setDTthreads(2) # for running on CRAN
cross_cases(mtcars, cyl, am %nest% vs)

# list of variables
cross_cases(mtcars, cyl, am %nest% list(vs, cyl))

# list of variables - multiple banners/multiple nesting
cross_cases(mtcars, cyl, list(total(), list(am, vs) %nest% cyl))

# three variables 
cross_cases(mtcars, am %nest% vs %nest% carb, cyl)

# the same with usual version
cross_cases(mtcars, cyl, nest(am, vs))

# three variables 
cross_cases(mtcars, nest(am, vs, carb), cyl)
</code></pre>

<hr>
<h2 id='net'>Add subtotal to a set of categories</h2><span id='topic+net'></span><span id='topic+subtotal'></span><span id='topic+tab_net_cells'></span><span id='topic+tab_net_cols'></span><span id='topic+tab_net_rows'></span><span id='topic+tab_subtotal_cells'></span><span id='topic+tab_subtotal_cols'></span><span id='topic+tab_subtotal_rows'></span><span id='topic+hide'></span><span id='topic+unhide'></span>

<h3>Description</h3>

<p>'subtotal' adds subtotal to set of categories, 'net' replaces categories with
their net value. If you provide named arguments then name will be used as
label for subtotal. In other case labels will be automatically generated
taking into account arguments 'new_label' and 'prefix'. Note that if you
provide overlapping categories then net and subtotals will also be
overlapping. 'subtotal' and 'net' are intended for usage with <a href="#topic+cro">cro</a> and
friends. 'tab_subtotal_*' and 'tab_net_*' are intended for usage with custom
tables - see <a href="#topic+tables">tables</a>.
There are auxiliary functions 'hide' and 'unhide'. 'hide' is used with
'subtotal' when you need to leave only subtotal for some specific items.
And 'unhide' is used with 'net' when you want to show items for some nets.
See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net(
  x,
  ...,
  position = c("below", "above", "top", "bottom"),
  prefix = "TOTAL ",
  new_label = c("all", "range", "first", "last"),
  add = FALSE
)

subtotal(
  x,
  ...,
  position = c("below", "above", "top", "bottom"),
  prefix = "TOTAL ",
  new_label = c("all", "range", "first", "last"),
  add = TRUE
)

tab_net_cells(
  data,
  ...,
  position = c("below", "above", "top", "bottom"),
  prefix = "TOTAL ",
  new_label = c("all", "range", "first", "last")
)

tab_net_cols(
  data,
  ...,
  position = c("below", "above", "top", "bottom"),
  prefix = "TOTAL ",
  new_label = c("all", "range", "first", "last")
)

tab_net_rows(
  data,
  ...,
  position = c("below", "above", "top", "bottom"),
  prefix = "TOTAL ",
  new_label = c("all", "range", "first", "last")
)

tab_subtotal_cells(
  data,
  ...,
  position = c("below", "above", "top", "bottom"),
  prefix = "TOTAL ",
  new_label = c("all", "range", "first", "last")
)

tab_subtotal_cols(
  data,
  ...,
  position = c("below", "above", "top", "bottom"),
  prefix = "TOTAL ",
  new_label = c("all", "range", "first", "last")
)

tab_subtotal_rows(
  data,
  ...,
  position = c("below", "above", "top", "bottom"),
  prefix = "TOTAL ",
  new_label = c("all", "range", "first", "last")
)

hide(category)

unhide(category)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="net_+3A_x">x</code></td>
<td>
<p>variable, list, data.frame or multiple response set</p>
</td></tr>
<tr><td><code id="net_+3A_...">...</code></td>
<td>
<p>list of categories for grouping. It can be numeric vectors (for
example, 1:2), ranges (for example, 4 
greater(5)). If an argument is named then this name will be used as label for
subtotal.</p>
</td></tr>
<tr><td><code id="net_+3A_position">position</code></td>
<td>
<p>position of the subtotal or net relative to original
categories. &quot;below&quot; by default. One of the &quot;below&quot;, &quot;above&quot;, &quot;top&quot;,
&quot;bottom&quot;. &quot;top&quot; and &quot;bottom&quot; place nets and subtotals above or below all
other categories. For nets &quot;below&quot; and &quot;above&quot; have no difference because
original categories are removed.</p>
</td></tr>
<tr><td><code id="net_+3A_prefix">prefix</code></td>
<td>
<p>character, &quot;TOTAL &quot; by default. It is a prefix to automatically
created labels for nets and subtotals.</p>
</td></tr>
<tr><td><code id="net_+3A_new_label">new_label</code></td>
<td>
<p>how we will combine original values for automatically
generated subtotal labels. Possible values are &quot;all&quot;, &quot;range&quot;, &quot;first&quot;,
&quot;last&quot;. &quot;all&quot; collapse all labels, &quot;range&quot; take only first and last label,</p>
</td></tr>
<tr><td><code id="net_+3A_add">add</code></td>
<td>
<p>logical. Should we add subtotal to categories or replace categories with a net?</p>
</td></tr>
<tr><td><code id="net_+3A_data">data</code></td>
<td>
<p>intermediate table. See <a href="#topic+tables">tables</a>.</p>
</td></tr>
<tr><td><code id="net_+3A_category">category</code></td>
<td>
<p>category (numeric vectors, ranges, criteria) which you want
to 'hide' or 'unhide'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>multiple response set or list of the multiple response sets
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(2)
ol = c(1:7, 99)
var_lab(ol) = "Liking"
val_lab(ol)  = num_lab("
                     1 Disgusting
                     2 Very Poor
                     3 Poor
                     4 So-so
                     5 Good
                     6 Very good
                     7 Excellent
                     99 Hard to say
                     ")
                     
cro(subtotal(ol, BOTTOM = 1:3, TOP = 6:7, position = "top"))
# example with hide
cro(subtotal(ol, TOP1 = hide(7), TOP2 = hide(6:7), TOP3 = 5:7, BOTTOM = 1:3, position = "top"))
# autolabelling
cro(subtotal(ol, 1:3, 6:7))
# replace original codes and another way of autolabelling
cro(net(ol, 1:3, 6:7, new_label = "range", prefix = "NET "))
# unhide
cro(net(ol, 1:3, unhide(6:7), new_label = "range", prefix = "NET "))
# character variable and criteria usage
items = c("apple", "banana", "potato", "orange", "onion", "tomato", "pineapple")
cro(
    subtotal(items, 
             "TOTAL FRUITS"     = like("*ap*") | like("*an*"), 
             "TOTAL VEGETABLES" = like("*to*") | like("*on*"), 
             position = "bottom")
)

# 'tab_net_*' usage
data(mtcars)
mtcars = apply_labels(mtcars,
                      mpg = "Miles/(US) gallon",
                      am = "Transmission",
                      am = c("Automatic" = 0,
                             "Manual"=1),
                      gear = "Number of forward gears",
                      gear = c(
                          One = 1,
                          Two = 2,
                          Three = 3,
                          Four = 4,
                          Five = 5
                      )
)
mtcars %&gt;% 
    tab_cells(mpg) %&gt;% 
    tab_net_cells("Low mpg" = less(mean(mpg)), "High mpg" = greater_or_equal(mean(mpg))) %&gt;% 
    tab_cols(total(), am) %&gt;% 
    tab_stat_cases() %&gt;% 
    tab_pivot()

mtcars %&gt;% 
    tab_cells(mpg) %&gt;% 
    tab_rows(gear) %&gt;%
    tab_subtotal_rows(1:2, 3:4, "5 and more" = greater(4)) %&gt;% 
    tab_stat_mean() %&gt;% 
    tab_pivot()
</code></pre>

<hr>
<h2 id='prepend_values'>Prepend values/variable names to value/variable labels</h2><span id='topic+prepend_values'></span><span id='topic+prepend_names'></span><span id='topic+prepend_all'></span><span id='topic+tab_prepend_values'></span><span id='topic+tab_prepend_names'></span><span id='topic+tab_prepend_all'></span>

<h3>Description</h3>

<p>These functions add values/variable names as prefixes to value/variable 
labels. Functions which start with <code>tab_</code> intended for usage inside 
table creation sequences. See examples and <a href="#topic+tables">tables</a>. It is recommended
to use <code>tab_prepend_*</code> at the start of sequence of tables creation. If
you use it in the middle of the sequence then previous statements will not be
affected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepend_values(x)

prepend_names(x)

prepend_all(x)

tab_prepend_values(data)

tab_prepend_names(data)

tab_prepend_all(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepend_values_+3A_x">x</code></td>
<td>
<p>vector/data.frame. <code>prepend_names</code> can be applied only to data.frames.</p>
</td></tr>
<tr><td><code id="prepend_values_+3A_data">data</code></td>
<td>
<p>data.frame/intermediate result of tables construction. See <a href="#topic+tables">tables</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>original object with prepended names/values to labels
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(mtcars)
mtcars = apply_labels(mtcars,
                      mpg = "Miles/(US) gallon",
                      cyl = "Number of cylinders",
                      disp = "Displacement (cu.in.)",
                      hp = "Gross horsepower",
                      drat = "Rear axle ratio",
                      wt = "Weight (lb/1000)",
                      qsec = "1/4 mile time",
                      vs = "Engine",
                      vs = c("V-engine" = 0,
                             "Straight engine" = 1),
                      am = "Transmission",
                      am = c("Automatic" = 0,
                             "Manual"=1),
                      gear = "Number of forward gears",
                      carb = "Number of carburetors"
)

# prepend names and 'cross_cpct'
mtcars %&gt;% 
       prepend_names %&gt;% 
       cross_cpct(list(cyl, gear), list(total(), vs, am))
     
# prepend values to value labels                 
mtcars %&gt;% 
   tab_prepend_values %&gt;% 
   tab_cols(total(), vs, am) %&gt;% 
   tab_cells(cyl, gear) %&gt;% 
   tab_stat_cpct() %&gt;% 
   tab_pivot()

# prepend names and labels
mtcars %&gt;% 
   tab_prepend_all %&gt;% 
   tab_cols(total(), vs, am) %&gt;% 
   tab_cells(cyl, gear) %&gt;% 
   tab_stat_cpct() %&gt;% 
   tab_pivot() 
   
# variable in rows without prefixes
mtcars %&gt;% 
   tab_cells(cyl, gear) %&gt;% 
   tab_prepend_all %&gt;% 
   tab_cols(total(), vs, am) %&gt;% 
   tab_stat_cpct() %&gt;% 
   tab_pivot()  
   
## End(Not run) 
</code></pre>

<hr>
<h2 id='product_test'>Data from product test of chocolate confectionary</h2><span id='topic+product_test'></span>

<h3>Description</h3>

<p>It is truncated dataset with data from product test of two samples of
chocolate sweets. 150 respondents tested two kinds of sweets (codenames:
VSX123 and SDF546). Sample was divided into two groups (cells) of 75
respondents in each group. In cell 1 product VSX123 was presented first and
then SDF546. In cell 2 sweets were presented in reversed order. Questions
about respondent impressions about first product are in the block A (and
about second tested product in the block B). At the end of the questionnaire 
there is a question about preferences between sweets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>product_test
</code></pre>


<h3>Format</h3>

<p>A data frame with 150 rows and 18 variables:
</p>

<dl>
<dt>id</dt><dd><p>Respondent Id.</p>
</dd>
<dt>cell</dt><dd><p>First tested product (cell number).</p>
</dd>
<dt>s2a</dt><dd><p>Age.</p>
</dd>
<dt>a1_1</dt><dd><p>What did you like in these sweets? Multiple response. First tested product.</p>
</dd>
<dt>a1_2</dt><dd><p>(continue) What did you like in these sweets? Multiple response. First tested product.</p>
</dd>
<dt>a1_3</dt><dd><p>(continue) What did you like in these sweets? Multiple response. First tested product.</p>
</dd>
<dt>a1_4</dt><dd><p>(continue) What did you like in these sweets? Multiple response. First tested product.</p>
</dd>
<dt>a1_5</dt><dd><p>(continue) What did you like in these sweets? Multiple response. First tested product.</p>
</dd>
<dt>a1_6</dt><dd><p>(continue) What did you like in these sweets? Multiple response. First tested product.</p>
</dd>
<dt>a22</dt><dd><p>Overall liking. First tested product.</p>
</dd>
<dt>b1_1</dt><dd><p>What did you like in these sweets? Multiple response. Second tested product.</p>
</dd>
<dt>b1_2</dt><dd><p>(continue) What did you like in these sweets? Multiple response. Second tested product.</p>
</dd>
<dt>b1_3</dt><dd><p>(continue) What did you like in these sweets? Multiple response. Second tested product.</p>
</dd>
<dt>b1_4</dt><dd><p>(continue) What did you like in these sweets? Multiple response. Second tested product.</p>
</dd>
<dt>b1_5</dt><dd><p>(continue) What did you like in these sweets? Multiple response. Second tested product.</p>
</dd>
<dt>b1_6</dt><dd><p>(continue) What did you like in these sweets? Multiple response. Second tested product.</p>
</dd>
<dt>b22</dt><dd><p>Overall liking. Second tested product.</p>
</dd>
<dt>c1</dt><dd><p>Preferences.</p>
</dd>
</dl>


<hr>
<h2 id='prop'>Compute proportions from numeric vector/matrix/data.frame</h2><span id='topic+prop'></span><span id='topic+prop_col'></span><span id='topic+prop_row'></span>

<h3>Description</h3>

<p><code>prop</code> returns proportion to sum of entire <code>x</code>. <code>prop_col</code> 
returns proportion to sum of each column of <code>x</code>. <code>prop_row</code> returns
proportion to sum of each row of <code>x</code>. Non-numeric columns in the
data.frame are ignored. NA's are also ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop(x)

prop_col(x)

prop_row(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prop_+3A_x">x</code></td>
<td>
<p>numeric vector/matrix/data.frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the same structure as <code>x</code> but with proportions of original
values from sum of original values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a = c(25, 25, NA)
prop(a)

# data.frame with non-numeric columns
fac = factor(c("a", "b", "c"))
char = c("a", "b", "c")
dat = as.POSIXct("2016-09-27") 
a = sheet(fac, a = c(25, 25, NA), b = c(100, NA, 50), char, dat)

prop(a)
prop_row(a)
prop_col(a)

# the same as result as with 'prop.table'
tbl = table(state.division, state.region)

prop(tbl)
prop_row(tbl)
prop_col(tbl)
</code></pre>

<hr>
<h2 id='qc'>Create vector of characters from unquoted strings (variable names)</h2><span id='topic+qc'></span><span id='topic+qe'></span>

<h3>Description</h3>


<ul>
<li><p><code>qc</code> It is often needed to address variables in the data.frame in the such 
manner: <code>dfs[ , c("var1", "var2", "var3")]</code>. <code>qc</code> (&quot;quoted c&quot;) is a
shortcut for the such cases to reduce keystrokes. With <code>qc</code> you can write:
<code>dfs[ , qc(var1, var2, var3)]</code>.
</p>
</li>
<li><p><code>qe</code> returns list of expression.</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>qc(...)

qe(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qc_+3A_...">...</code></td>
<td>
<p>unquoted names of variables in
<code>qc</code> or unquoted expressions in <code>qe</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of characters or expressions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## qc
qc(a, b, c)
identical(qc(a, b, c), c("a", "b", "c"))

mtcars[, qc(am, mpg, gear)]

## qe
qe(mrset(a1 %to% a6), mrset(b1 %to% b6), mrset(c1 %to% c6))
</code></pre>

<hr>
<h2 id='read_spss'>Read an SPSS Data File</h2><span id='topic+read_spss'></span><span id='topic+read_spss_to_list'></span>

<h3>Description</h3>

<p><code>read_spss</code> reads data from a file stored in SPSS *.sav format. It
returns data.frame and never converts string variables to factors. Also it
prepares SPSS values/variables labels for working with
<code>val_lab</code>/<code>var_lab</code> functions. User-missings values are ignored.
<code>read_spss</code> is simple wrapper around <code>read.spss</code> function from
package <code>foreign</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_spss(file, reencode = TRUE, use_missings = FALSE, ...)

read_spss_to_list(file, reencode = TRUE, use_missings = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_spss_+3A_file">file</code></td>
<td>
<p>Character string: the name of the file or URL to read.</p>
</td></tr>
<tr><td><code id="read_spss_+3A_reencode">reencode</code></td>
<td>
<p>logical: should character strings be re-encoded to the current locale.
The default is TRUE. NA means to do so in a UTF-8 locale, only. Alternatively, a
character string specifying an encoding to assume for the file.</p>
</td></tr>
<tr><td><code id="read_spss_+3A_use_missings">use_missings</code></td>
<td>
<p>logical: should information on user-defined missing
values be used to set the corresponding values to NA?</p>
</td></tr>
<tr><td><code id="read_spss_+3A_...">...</code></td>
<td>
<p>further parameters for <a href="foreign.html#topic+read.spss">read.spss</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>read_spss</code> returns data.frame.
</p>


<h3>See Also</h3>

<p><a href="foreign.html#topic+read.spss">read.spss</a> in package <code>foreign</code>, <a href="#topic+val_lab">val_lab</a>,
<a href="#topic+var_lab">var_lab</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

w = read_spss("project_123.sav") # to data.frame


## End(Not run)
</code></pre>

<hr>
<h2 id='recode'>Change, rearrange or consolidate the values of an existing or new variable. Inspired by the RECODE command from SPSS.</h2><span id='topic+recode'></span><span id='topic+rec'></span><span id='topic+if_val'></span><span id='topic+recode+3C-'></span><span id='topic+if_val+3C-'></span><span id='topic+rec+3C-'></span><span id='topic+ifs'></span><span id='topic+lo'></span><span id='topic+hi'></span><span id='topic+copy'></span><span id='topic+from_to'></span><span id='topic++25into+25'></span>

<h3>Description</h3>

<p><code>recode</code> change, rearrange or consolidate the values of an existing 
variable based on conditions. Design of this function inspired by RECODE from
SPSS. Sequence of recodings provided in the form of formulas. For example, 
1:2 ~ 1 means that all 1's and 2's will be replaced with 1. Each value will be
recoded only once. In the assignment form <code>recode(...) = ...</code> of this 
function values which doesn't meet any condition remain unchanged. In case of
the usual form <code>... = recode(...)</code> values which doesn't meet any 
condition will be replaced with NA. One can use values or more sophisticated
logical conditions and functions as a condition. There are several special 
functions for usage as criteria - for details see <a href="#topic+criteria">criteria</a>. Simple 
common usage looks like: <code>recode(x, 1:2 ~ -1, 3 ~ 0, 1:2 ~ 1, 99 ~ NA)</code>.
For more information, see details and examples.
The <code>ifs</code> function checks whether one or more conditions are met and
returns a value that corresponds to the first TRUE condition. <code>ifs</code> can
take the place of multiple nested <code>ifelse</code> statements and is much
easier to read with multiple conditions. <code>ifs</code> works in the same manner
as <code>recode</code> - e. g. with formulas. But conditions
should be only logical and it doesn't operate on multicolumn objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recode(
  x,
  ...,
  with_labels = FALSE,
  new_label = c("all", "range", "first", "last")
)

rec(x, ..., with_labels = TRUE, new_label = c("all", "range", "first", "last"))

recode(x, with_labels = FALSE, new_label = c("all", "range", "first", "last")) &lt;- value

rec(x, with_labels = TRUE, new_label = c("all", "range", "first", "last")) &lt;- value

ifs(...)

lo

hi

copy(x)

from_to(from, to)

values %into% names
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recode_+3A_x">x</code></td>
<td>
<p>vector/matrix/data.frame/list</p>
</td></tr>
<tr><td><code id="recode_+3A_...">...</code></td>
<td>
<p>sequence of formulas which describe recodings. They are used when
<code>from</code>/<code>to</code> arguments are not provided.</p>
</td></tr>
<tr><td><code id="recode_+3A_with_labels">with_labels</code></td>
<td>
<p>logical. FALSE by default for 'recode' and TRUE for 'rec'.
Should we also recode value labels with the same recodings as variable?</p>
</td></tr>
<tr><td><code id="recode_+3A_new_label">new_label</code></td>
<td>
<p>one of &quot;all&quot;, &quot;range&quot;, &quot;first&quot;, or &quot;last&quot;. If we recode
value labels ('with_labels = TRUE') how we will combine labels for
duplicated values? &quot;all&quot; will use all labels, &quot;range&quot; will use first and
last labels. See examples.</p>
</td></tr>
<tr><td><code id="recode_+3A_value">value</code></td>
<td>
<p>list with formulas which describe recodings in assignment form
of function/<code>to</code> list if <code>from</code>/<code>to</code> notation is used.</p>
</td></tr>
<tr><td><code id="recode_+3A_from">from</code></td>
<td>
<p>list of conditions for values which should be recoded (in the
same format as LHS of formulas).</p>
</td></tr>
<tr><td><code id="recode_+3A_to">to</code></td>
<td>
<p>list of values into which old values should be recoded (in the same
format as RHS of formulas).</p>
</td></tr>
<tr><td><code id="recode_+3A_values">values</code></td>
<td>
<p>object(-s) which will be assigned to <code>names</code> for 
<code>%into%</code> operation. <code>%into%</code> supports multivalue assignments.
See examples.</p>
</td></tr>
<tr><td><code id="recode_+3A_names">names</code></td>
<td>
<p>name(-s) which will be given to <code>values</code> expression. For 
<code>%into%</code>.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>numeric</code> of length 1.
</p>
<p>An object of class <code>numeric</code> of length 1.
</p>


<h3>Details</h3>

<p>Input conditions - possible values for left-hand side (LHS) of formula or
element of <code>from</code> list:
</p>

<ul>
<li><p>vector/single value All values in <code>x</code> which equal to elements of the
vector in LHS will be replaced with RHS.
</p>
</li>
<li><p>function Values for which function gives TRUE will be replaced with 
RHS. There are some special functions for the convenience - see <a href="#topic+criteria">criteria</a>.
</p>
</li>
<li><p>single logical value <code>TRUE</code> It means all other unrecoded values
(ELSE in SPSS RECODE). All other unrecoded values will be changed to RHS of the
formula or appropriate element of <code>to</code>. 
</p>
</li></ul>

<p>Output values - possible values for right-hand side (RHS) of formula or
element of <code>to</code> list:
</p>

<ul>
<li><p>value replace elements of <code>x</code>. This value will be
recycled across rows and columns of <code>x</code>.
</p>
</li>
<li><p>vector values of this vector will replace values in the corresponding
position in rows of <code>x</code>. Vector will be recycled across columns of
<code>x</code>.
</p>
</li>
<li><p>function This function will be applied to values of <code>x</code> which 
satisfy recoding condition. There is a special auxiliary function <code>copy</code> 
which just returns its argument. So, in the <code>recode</code> it just copies old 
value (COPY in SPSS RECODE).  See examples.</p>
</li></ul>

<p><code>%into%</code> tries to mimic SPSS 'INTO'. Values from left-hand side will 
be assigned to right-hand side. You can use <code>%to%</code> expression in the 
RHS of <code>%into%</code>. See examples. 
<code>lo</code> and <code>hi</code> are shortcuts for <code>-Inf</code> and <code>Inf</code>. They
can be useful in expressions with <code>%thru%</code>, e. g. <code>1 %thru%
hi</code>.
</p>


<h3>Value</h3>

<p>object of the same form as <code>x</code> with recoded values
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples from SPSS manual
# RECODE V1 TO V3 (0=1) (1=0) (2, 3=-1) (9=9) (ELSE=SYSMIS)
v1  = c(0, 1, 2, 3, 9, 10)
recode(v1) = c(0 ~ 1, 1 ~ 0, 2:3 ~ -1, 9 ~ 9, TRUE ~ NA)
v1

# RECODE QVAR(1 THRU 5=1)(6 THRU 10=2)(11 THRU HI=3)(ELSE=0).
qvar = c(1:20, 97, NA, NA)
recode(qvar, 1 %thru% 5 ~ 1, 6 %thru% 10 ~ 2, 11 %thru% hi ~ 3, TRUE ~ 0)
# the same result
recode(qvar, 1 %thru% 5 ~ 1, 6 %thru% 10 ~ 2, ge(11) ~ 3, TRUE ~ 0)

# RECODE STRNGVAR ('A', 'B', 'C'='A')('D', 'E', 'F'='B')(ELSE=' '). 
strngvar = LETTERS
recode(strngvar, c('A', 'B', 'C') ~ 'A', c('D', 'E', 'F') ~ 'B', TRUE ~ ' ')

# recode in place. Note that we recode only first six letters
recode(strngvar) = c(c('A', 'B', 'C') ~ 'A', c('D', 'E', 'F') ~ 'B')
strngvar

# RECODE AGE (MISSING=9) (18 THRU HI=1) (0 THRU 18=0) INTO VOTER. 
age = c(NA, 2:40, NA)
voter = recode(age, NA ~ 9, 18 %thru% hi ~ 1, 0 %thru% 18 ~ 0)
voter
# the same result with '%into%'
recode(age, NA ~ 9, 18 %thru% hi ~ 1, 0 %thru% 18 ~ 0) %into% voter2
voter2
# recode with adding labels
voter = recode(age, "Refuse to answer" = NA ~ 9, 
                    "Vote" = 18 %thru% hi ~ 1, 
                    "Don't vote" = 0 %thru% 18 ~ 0)
voter

# recoding with labels
ol = c(1:7, 99)
var_lab(ol) = "Liking"
val_lab(ol)  = num_lab("
                     1 Disgusting
                     2 Very Poor
                     3 Poor
                     4 So-so
                     5 Good
                     6 Very good
                     7 Excellent
                     99 Hard to say
                     ")

recode(ol, 1:3 ~ 1, 5:7 ~ 7, TRUE ~ copy, with_labels = TRUE)
# 'rec' is a shortcut for recoding with labels. Same result: 
rec(ol, 1:3 ~ 1, 5:7 ~ 7, TRUE ~ copy)
# another method of combining labels
recode(ol, 1:3 ~ 1, 5:7 ~ 7, TRUE ~ copy, with_labels = TRUE, new_label = "range")
# example with from/to notation
# RECODE QVAR(1 THRU 5=1)(6 THRU 10=2)(11 THRU HI=3)(ELSE=0).
list_from = list(1 %thru% 5, 6 %thru% 10, ge(11), TRUE)
list_to = list(1, 2, 3, 0)
recode(qvar, from_to(list_from, list_to))


list_from = list(NA, 18 %thru% hi, 0 %thru% 18)
list_to = list("Refuse to answer" = 9, "Vote" = 1, "Don't vote" = 0)
voter = recode(age, from_to(list_from, list_to))
voter

# 'ifs' examples
a = 1:5
b = 5:1
ifs(b&gt;3 ~ 1)                       # c(1, 1, NA, NA, NA)
ifs(b&gt;3 ~ 1, TRUE ~ 3)             # c(1, 1, 3, 3, 3)
ifs(b&gt;3 ~ 1, a&gt;4 ~ 7, TRUE ~ 3)    # c(1, 1, 3, 3, 7)
ifs(b&gt;3 ~ a, TRUE ~ 42)            # c(1, 2, 42, 42, 42)

# advanced usage
#' # multiple assignment with '%into%'
set.seed(123)
x1 = runif(30)
x2 = runif(30)
x3 = runif(30)
# note nessesary brackets around RHS of '%into%'
recode(x1 %to% x3, gt(0.5) ~ 1, other ~ 0) %into% (x_rec_1 %to% x_rec_3)
fre(x_rec_1)
# the same operation with characters expansion
i = 1:3
recode(x1 %to% x3, gt(0.5) ~ 1, other ~ 0) %into% text_expand('x_rec2_{i}')
fre(x_rec2_1)

# factor recoding
a = factor(letters[1:4])
recode(a, "a" ~ "z", TRUE ~ copy) # we get factor

# example with function in RHS
data(iris)
new_iris = recode(iris, is.numeric ~ scale, other ~ copy)
str(new_iris)

set.seed(123)
a = rnorm(20)
# if a&lt;(-0.5) we change it to absolute value of a (abs function)
recode(a, lt(-0.5) ~ abs, other ~ copy) 

# the same example with logical criteria
recode(a, when(a&lt;(-.5)) ~ abs, other ~ copy) 
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+htmlTable'></span><span id='topic+htmlTableWidget'></span><span id='topic+htmlTableWidgetOutput'></span><span id='topic+interactiveTable'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>htmlTable</dt><dd><p><code><a href="htmlTable.html#topic+htmlTable">htmlTable</a></code>, <code><a href="htmlTable.html#topic+htmlTableWidget">htmlTableWidget</a></code>, <code><a href="htmlTable.html#topic+htmlTableWidget-shiny">htmlTableWidgetOutput</a></code>, <code><a href="htmlTable.html#topic+interactiveTable">interactiveTable</a></code></p>
</dd>
</dl>

<hr>
<h2 id='set_caption'>Add caption to the table</h2><span id='topic+set_caption'></span><span id='topic+get_caption'></span><span id='topic+is.with_caption'></span>

<h3>Description</h3>

<p>To drop caption use <code>set_caption</code> with <code>caption = NULL</code>. Captions
are supported by <a href="#topic+htmlTable.etable">htmlTable.etable</a>, <a href="#topic+xl_write">xl_write</a> and
<a href="#topic+as.datatable_widget">as.datatable_widget</a> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_caption(obj, caption)

get_caption(obj)

is.with_caption(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_caption_+3A_obj">obj</code></td>
<td>
<p>object of class <code>etable</code> - result of <code>cross_cpct</code> and etc.</p>
</td></tr>
<tr><td><code id="set_caption_+3A_caption">caption</code></td>
<td>
<p>character caption for the table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>with_caption</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mtcars)
mtcars = apply_labels(mtcars,
                      vs = "Engine",
                      vs = num_lab("
                             0 V-engine 
                             1 Straight engine
                             "),
                      am = "Transmission",
                      am = num_lab("
                             0 Automatic 
                             1 Manual
                             ")
)
tbl_with_caption = cross_cases(mtcars, am, vs) %&gt;% 
    set_caption("Table 1. Type of transimission.")
    
tbl_with_caption

</code></pre>

<hr>
<h2 id='sheet'>Make data.frame without conversion to factors and without fixing names</h2><span id='topic+sheet'></span><span id='topic+as.sheet'></span>

<h3>Description</h3>

<p><code>sheet</code> and <code>as.sheet</code> are shortcuts to <code>data.frame</code> and 
<code>as.data.frame</code> with stringsAsFactors = FALSE, check.names = FALSE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sheet(...)

as.sheet(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sheet_+3A_...">...</code></td>
<td>
<p>objects, possibly named</p>
</td></tr>
<tr><td><code id="sheet_+3A_x">x</code></td>
<td>
<p>object to be coerced to data.frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame/list
</p>


<h3>See Also</h3>

<p><a href="base.html#topic+data.frame">data.frame</a>, <a href="base.html#topic+as.data.frame">as.data.frame</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# see the difference
df1 = data.frame(a = letters[1:3], "This is my long name" = 1:3)
df2 = sheet(a = letters[1:3], "This is my long name" = 1:3)

str(df1)
str(df2)


</code></pre>

<hr>
<h2 id='sort_asc'>Sort data.frames/matrices/vectors</h2><span id='topic+sort_asc'></span><span id='topic+sort_desc'></span>

<h3>Description</h3>

<p><code>sort_asc</code> sorts in ascending order and <code>sort_desc</code> sorts in 
descending order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_asc(data, ..., na.last = FALSE)

sort_desc(data, ..., na.last = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_asc_+3A_data">data</code></td>
<td>
<p>data.frame/matrix/vector</p>
</td></tr>
<tr><td><code id="sort_asc_+3A_...">...</code></td>
<td>
<p>character/numeric or criteria/logical functions (see
<a href="#topic+criteria">criteria</a>). Column names/numbers for data.frame/matrix by which
object will be sorted. Names at the top-level can be unquoted (non-standard
evaluation). For standard evaluation of parameters you can surround them by
round brackets. See examples. Ignored for vectors.</p>
</td></tr>
<tr><td><code id="sort_asc_+3A_na.last">na.last</code></td>
<td>
<p>for controlling the treatment of NAs. If TRUE, missing values
in the data are put last; if FALSE, they are put first; if NA, they are
removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sorted <code>data</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
sort_asc(mtcars, mpg)
sort_asc(mtcars, cyl, mpg) # by two column

# same results with column nums
sort_asc(mtcars, 1)
sort_asc(mtcars, 2:1) # by two column
sort_asc(mtcars, 2, 1) # by two column

# call with parameter
sorting_columns = c("cyl", "mpg")
sort_asc(mtcars, (sorting_columns)) 

</code></pre>

<hr>
<h2 id='split_by'>Splits data.frame into list of data.frames that can be analyzed separately</h2><span id='topic+split_by'></span><span id='topic+split_off'></span>

<h3>Description</h3>

<p>Splits data.frame into list of data.frames that can be analyzed separately.
These data.frames are sets of cases that have the same values for the
specified split variables. Any missing values in split variables are dropped
together with the corresponding values of <code>data</code>. <code>split_off</code> works
with lists of data.frames or objects that can be coerced to data.frame and
assumed to have compatible structure. Resulting rows will be sorted in order
of the split variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_by(data, ..., drop = TRUE)

split_off(data, groups = NULL, rownames = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_by_+3A_data">data</code></td>
<td>
<p>data.frame for <code>split_by</code>/list for <code>split_off</code></p>
</td></tr>
<tr><td><code id="split_by_+3A_...">...</code></td>
<td>
<p>unquoted variables names (see <a href="#topic+keep">keep</a>) by which <code>data</code>
will be split into list.</p>
</td></tr>
<tr><td><code id="split_by_+3A_drop">drop</code></td>
<td>
<p>should we drop combination of levels with zero observation? TRUE
by default.</p>
</td></tr>
<tr><td><code id="split_by_+3A_groups">groups</code></td>
<td>
<p>character If it is not <code>NULL</code> then we add list
names as variable to result of <code>split_off</code> with the name specified by
<code>groups</code>. If it is <code>TRUE</code> then name will be <code>.groups</code>.</p>
</td></tr>
<tr><td><code id="split_by_+3A_rownames">rownames</code></td>
<td>
<p>character If it is not <code>NULL</code> then we add data.frames
rownames as variable to result of <code>split_off</code> with the name specified
by <code>rownames</code>. If it is <code>TRUE</code> then name will be 
<code>.rownames</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>split_by</code> returns list of data.frames/<code>split_off</code>
returns data.frame
</p>


<h3>See Also</h3>

<p><a href="base.html#topic+split">split</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# usage of 'groups', 'rownames'
data(mtcars)
# add labels to dataset
mtcars %&gt;% 
    apply_labels(mpg = "Miles/(US) gallon",
                 disp = "Displacement (cu.in.)",
                 wt = "Weight",
                 hp = "Gross horsepower",
                 vs = "Engine",
                 vs = num_lab(" 
                                   0 V-engine
                                   1 Straight engine
                                   "),
                 
                 am = "Transmission",
                 am = num_lab(" 
                                   0 Automatic
                                   1 Manual
                                   ")
    ) %&gt;% 
    split_by(am, vs) %&gt;% 
    to_list({
        res = lm(mpg ~ hp + disp + wt, data = .x)
        cbind(Coef. = coef(res), confint(res))
    }) %&gt;% 
    split_off(groups = TRUE, rownames = "variable")
</code></pre>

<hr>
<h2 id='split_labels'>Split character vector to matrix/split columns in data.frame</h2><span id='topic+split_labels'></span><span id='topic+split_columns'></span><span id='topic+split_table_to_df'></span><span id='topic+make_subheadings'></span>

<h3>Description</h3>

<p><code>split_labels</code>/<code>split_columns</code> are auxiliary functions for 
post-processing tables resulted from <a href="#topic+cro">cro</a>/<a href="#topic+cro_fun">cro_fun</a> and etc. In
these tables all labels collapsed in the first column with &quot;|&quot; separator.
<code>split_columns</code> split first column into multiple columns with separator
(<code>split</code> argument). <code>split_table_to_df</code> split first column of table
and column names. Result of this operation is data.frame with character
columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_labels(
  x,
  remove_repeated = TRUE,
  split = "\\|",
  fixed = FALSE,
  perl = FALSE
)

split_columns(
  data,
  columns = 1,
  remove_repeated = TRUE,
  split = "\\|",
  fixed = FALSE,
  perl = FALSE
)

split_table_to_df(
  data,
  digits = get_expss_digits(),
  remove_repeated = TRUE,
  split = "\\|",
  fixed = FALSE,
  perl = FALSE
)

make_subheadings(data, number_of_columns = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_labels_+3A_x">x</code></td>
<td>
<p>character vector which will be split</p>
</td></tr>
<tr><td><code id="split_labels_+3A_remove_repeated">remove_repeated</code></td>
<td>
<p>logical. Default is <code>TRUE</code>. Should we remove repeated labels?</p>
</td></tr>
<tr><td><code id="split_labels_+3A_split">split</code></td>
<td>
<p>character vector (or object which can be coerced to such)
containing regular expression(s) (unless <code>fixed = TRUE</code>) to use for
splitting.</p>
</td></tr>
<tr><td><code id="split_labels_+3A_fixed">fixed</code></td>
<td>
<p>logical. If TRUE match split exactly, otherwise use regular
expressions. Has priority over <code>perl</code>.</p>
</td></tr>
<tr><td><code id="split_labels_+3A_perl">perl</code></td>
<td>
<p>logical. Should Perl-compatible regexps be used?</p>
</td></tr>
<tr><td><code id="split_labels_+3A_data">data</code></td>
<td>
<p>data.frame vector which will be split</p>
</td></tr>
<tr><td><code id="split_labels_+3A_columns">columns</code></td>
<td>
<p>character/numeric/logical  columns in the data.frame
<code>data</code> which should be split</p>
</td></tr>
<tr><td><code id="split_labels_+3A_digits">digits</code></td>
<td>
<p>numeric. How many digits after decimal point should be left in
<code>split_table_to_df</code>?</p>
</td></tr>
<tr><td><code id="split_labels_+3A_number_of_columns">number_of_columns</code></td>
<td>
<p>integer. Number of columns from row labels which
will be used as subheadings in table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>split_labels</code> returns character matrix, <code>split_columns</code> returns
data.frame with columns replaced by possibly multiple columns with split
labels. <code>split_table_to_df</code> returns data.frame with character columns.
</p>


<h3>See Also</h3>

<p><a href="base.html#topic+strsplit">strsplit</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(2)
data(mtcars)

# apply labels
mtcars = apply_labels(mtcars,
    cyl = "Number of cylinders",
    vs = "Engine",
    vs = c("V-engine" = 0,
                    "Straight engine" = 1),
    am = "Transmission",
    am = c(automatic = 0,
                    manual=1),
    gear = "Number of forward gears",
    carb = "Number of carburetors"
)

# all row labels in the first column
tabl = mtcars %&gt;% 
       cross_cpct(list(cyl, gear, carb), list(total(), vs, am))

tabl # without subheadings

make_subheadings(tabl) # with subheadings
              
split_labels(tabl[[1]])
split_labels(colnames(tabl))

# replace first column with new columns 
split_columns(tabl) # remove repeated

split_columns(tabl, remove_repeated = FALSE)

split_columns(tabl)

split_table_to_df(tabl)

split_table_to_df(tabl)


</code></pre>

<hr>
<h2 id='sum_row'>Compute sum/mean/sd/median/max/min/custom function on rows/columns</h2><span id='topic+sum_row'></span><span id='topic+sum_col'></span><span id='topic+mean_row'></span><span id='topic+mean_col'></span><span id='topic+sd_row'></span><span id='topic+sd_col'></span><span id='topic+median_row'></span><span id='topic+median_col'></span><span id='topic+max_row'></span><span id='topic+max_col'></span><span id='topic+min_row'></span><span id='topic+min_col'></span><span id='topic+apply_row'></span><span id='topic+apply_col'></span><span id='topic+any_in_row'></span><span id='topic+any_in_col'></span><span id='topic+all_in_row'></span><span id='topic+all_in_col'></span>

<h3>Description</h3>

<p>These functions are intended for usage inside <a href="maditr.html#topic+let">let</a>, and
<a href="maditr.html#topic+let_if">let_if</a>. sum/mean/sd/median/max/min by default omits NA. <code>any_in_*</code>
checks existence of any TRUE in each row/column. It is equivalent of
<a href="base.html#topic+any">any</a> applied to each row/column. <code>all_in_*</code> is equivalent of
<a href="base.html#topic+all">all</a> applied to each row/column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_row(..., na.rm = TRUE)

sum_col(..., na.rm = TRUE)

mean_row(..., na.rm = TRUE)

mean_col(..., na.rm = TRUE)

sd_row(..., na.rm = TRUE)

sd_col(..., na.rm = TRUE)

median_row(..., na.rm = TRUE)

median_col(..., na.rm = TRUE)

max_row(..., na.rm = TRUE)

max_col(..., na.rm = TRUE)

min_row(..., na.rm = TRUE)

min_col(..., na.rm = TRUE)

apply_row(fun, ...)

apply_col(fun, ...)

any_in_row(..., na.rm = TRUE)

any_in_col(..., na.rm = TRUE)

all_in_row(..., na.rm = TRUE)

all_in_col(..., na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_row_+3A_...">...</code></td>
<td>
<p>data. Vectors, matrixes, data.frames, list. Shorter arguments
will be recycled.</p>
</td></tr>
<tr><td><code id="sum_row_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Contrary to the base 'sum' it is TRUE by default. Should missing values (including NaN)
be removed?</p>
</td></tr>
<tr><td><code id="sum_row_+3A_fun">fun</code></td>
<td>
<p>custom function that will be applied to ...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All functions except <code>apply_*</code> return numeric vector of length 
equals the number of argument columns/rows. Value of <code>apply_*</code> depends
on supplied <code>fun</code> function.
</p>


<h3>See Also</h3>

<p><a href="#topic++25to+25">%to%</a>, <a href="#topic+count_if">count_if</a>,
<a href="#topic+sum_if">sum_if</a>, <a href="#topic+mean_if">mean_if</a>, <a href="#topic+median_if">median_if</a>, <a href="#topic+sd_if">sd_if</a>,
<a href="#topic+min_if">min_if</a>, <a href="#topic+max_if">max_if</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris = iris %&gt;% 
    let( 
        new_median = median_row(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width),
        new_mean = mean_row(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width)
    )
  
dfs = data.frame(
    test = 1:5,
    aa = rep(10, 5),
    b_ = rep(20, 5),
    b_1 = rep(11, 5),
    b_2 = rep(12, 5),
    b_4 = rep(14, 5),
    b_5 = rep(15, 5) 
)

# calculate sum of b* variables
dfs %&gt;% 
    let( 
        b_total = sum_row(b_, b_1 %to% b_5)
    ) %&gt;% 
    print()

# conditional modification
dfs %&gt;% 
    let_if(test %in% 2:4, 
        b_total = sum_row(b_, b_1 %to% b_5)
    ) %&gt;% 
    print()


</code></pre>

<hr>
<h2 id='tab_significance_options'>Mark significant differences between columns in the table</h2><span id='topic+tab_significance_options'></span><span id='topic+tab_last_sig_cpct'></span><span id='topic+tab_last_sig_means'></span><span id='topic+tab_last_sig_cases'></span><span id='topic+tab_last_sig_cell_chisq'></span><span id='topic+tab_last_round'></span><span id='topic+tab_last_add_sig_labels'></span><span id='topic+significance_cases'></span><span id='topic+significance_cell_chisq'></span><span id='topic+cell_chisq'></span><span id='topic+significance'></span><span id='topic+significance_cpct'></span><span id='topic+add_sig_labels'></span><span id='topic+significance_means'></span>

<h3>Description</h3>


<ul>
<li><p><code>significance_cpct</code> conducts z-tests between column percent in
the result of <a href="#topic+cross_cpct">cross_cpct</a>. Results are calculated with the same formula 
as in <a href="stats.html#topic+prop.test">prop.test</a> without continuity correction.
</p>
</li>
<li><p><code>significance_means</code> conducts t-tests between column means in
the result of <a href="#topic+cross_mean_sd_n">cross_mean_sd_n</a>. Results are calculated with the same formula 
as in <a href="stats.html#topic+t.test">t.test</a>.
</p>
</li>
<li><p><code>significance_cases</code> conducts chi-squared tests on the subtable of
table with counts in the result of <a href="#topic+cross_cases">cross_cases</a>. Results are calculated
with the same formula as in <a href="stats.html#topic+chisq.test">chisq.test</a>.
</p>
</li>
<li><p><code>significance_cell_chisq</code> compute cell chi-square test on table
with column percent. The cell chi-square test looks at each table cell and
tests whether it is significantly different from its expected value in the
overall table. For example, if it is thought that variations in political
opinions might depend on the respondent's age, this test can be used to
detect which cells contribute significantly to that dependence. Unlike the
chi-square test (<code>significance_cases</code>), which is carried out on a whole
set of rows and columns, the cell chi-square test is carried out
independently on each table cell. Although the significance level of the cell
chi-square test is accurate for any given cell, the cell tests cannot be used
instead of the chi-square test carried out on the overall table. Their
purpose is simply to point to the parts of the table where dependencies
between row and column categories may exist.</p>
</li></ul>

<p>For <code>significance_cpct</code> and <code>significance_means</code> there are three
type of comparisons which can be conducted simultaneously (argument
<code>compare_type</code>):
</p>

<ul>
<li><p><code>subtable</code> provide comparisons between all columns inside each
subtable.
</p>
</li>
<li><p><code>previous_column</code> is a comparison of each column of the subtable
with the previous column. It is useful if columns are periods or survey
waves.
</p>
</li>
<li><p><code>first_column</code> provides comparison the table first column with
all other columns in the table. <code>adjusted_first_column</code> is also
comparison with the first column but with adjustment for common base. It is
useful if the first column is total column and other columns are subgroups of
this total. Adjustments are made according to algorithm in IBM SPSS
Statistics Algorithms v20, p. 263. Note that with these adjustments t-tests
between means are made with equal variance assumed (as with <code>var_equal =
TRUE</code>).</p>
</li></ul>

<p>By now there are no adjustments for multiple-response variables (results of 
<a href="#topic+mrset">mrset</a>) in the table columns so significance tests are rather 
approximate for such cases.
Also, there are functions for the significance testing in the sequence of
custom tables calculations (see <a href="#topic+tables">tables</a>):
</p>

<ul>
<li><p><code>tab_last_sig_cpct</code>, <code>tab_last_sig_means</code> and 
<code>tab_last_sig_cpct</code> make the same tests as their analogs mentioned 
above. It is recommended to use them after appropriate statistic function: 
<a href="#topic+tab_stat_cpct">tab_stat_cpct</a>, <a href="#topic+tab_stat_mean_sd_n">tab_stat_mean_sd_n</a> and <a href="#topic+tab_stat_cases">tab_stat_cases</a>.

</p>
</li>
<li><p><code>tab_significance_options</code> With this function we can set
significance options for the entire custom table creation sequence.
</p>
</li>
<li><p><code>tab_last_add_sig_labels</code> This function applies 
<code>add_sig_labels</code>  to the last calculated table - it adds labels (letters
by default) for significance to columns header. It may be useful if you want
to combine a table with significance with table without it.
</p>
</li>
<li><p><code>tab_last_round</code> This function rounds numeric columns in the
last calculated table to specified number of digits. It is sometimes
needed if you want to combine table with significance with table without it.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>tab_significance_options(
  data,
  sig_level = 0.05,
  min_base = 2,
  delta_cpct = 0,
  delta_means = 0,
  correct = TRUE,
  compare_type = "subtable",
  bonferroni = FALSE,
  subtable_marks = "greater",
  inequality_sign = "both" %in% subtable_marks,
  sig_labels = LETTERS,
  sig_labels_previous_column = c("v", "^"),
  sig_labels_first_column = c("-", "+"),
  sig_labels_chisq = c("&lt;", "&gt;"),
  keep = c("percent", "cases", "means", "sd", "bases"),
  row_margin = c("auto", "sum_row", "first_column"),
  total_marker = "#",
  total_row = 1,
  digits = get_expss_digits(),
  na_as_zero = FALSE,
  var_equal = FALSE,
  mode = c("replace", "append"),
  as_spss = FALSE
)

tab_last_sig_cpct(
  data,
  sig_level = 0.05,
  delta_cpct = 0,
  min_base = 2,
  compare_type = "subtable",
  bonferroni = FALSE,
  subtable_marks = c("greater", "both", "less"),
  inequality_sign = "both" %in% subtable_marks,
  sig_labels = LETTERS,
  sig_labels_previous_column = c("v", "^"),
  sig_labels_first_column = c("-", "+"),
  keep = c("percent", "bases"),
  na_as_zero = FALSE,
  total_marker = "#",
  total_row = 1,
  digits = get_expss_digits(),
  as_spss = FALSE,
  mode = c("replace", "append"),
  label = NULL
)

tab_last_sig_means(
  data,
  sig_level = 0.05,
  delta_means = 0,
  min_base = 2,
  compare_type = "subtable",
  bonferroni = FALSE,
  subtable_marks = c("greater", "both", "less"),
  inequality_sign = "both" %in% subtable_marks,
  sig_labels = LETTERS,
  sig_labels_previous_column = c("v", "^"),
  sig_labels_first_column = c("-", "+"),
  keep = c("means", "sd", "bases"),
  var_equal = FALSE,
  digits = get_expss_digits(),
  mode = c("replace", "append"),
  label = NULL
)

tab_last_sig_cases(
  data,
  sig_level = 0.05,
  min_base = 2,
  correct = TRUE,
  keep = c("cases", "bases"),
  total_marker = "#",
  total_row = 1,
  digits = get_expss_digits(),
  mode = c("replace", "append"),
  label = NULL
)

tab_last_sig_cell_chisq(
  data,
  sig_level = 0.05,
  min_base = 2,
  subtable_marks = c("both", "greater", "less"),
  sig_labels_chisq = c("&lt;", "&gt;"),
  correct = TRUE,
  keep = c("percent", "bases", "none"),
  row_margin = c("auto", "sum_row", "first_column"),
  total_marker = "#",
  total_row = 1,
  total_column_marker = "#",
  digits = get_expss_digits(),
  mode = c("replace", "append"),
  label = NULL
)

tab_last_round(data, digits = get_expss_digits())

tab_last_add_sig_labels(data, sig_labels = LETTERS)

significance_cases(
  x,
  sig_level = 0.05,
  min_base = 2,
  correct = TRUE,
  keep = c("cases", "bases"),
  total_marker = "#",
  total_row = 1,
  digits = get_expss_digits()
)

significance_cell_chisq(
  x,
  sig_level = 0.05,
  min_base = 2,
  subtable_marks = c("both", "greater", "less"),
  sig_labels_chisq = c("&lt;", "&gt;"),
  correct = TRUE,
  keep = c("percent", "bases", "none"),
  row_margin = c("auto", "sum_row", "first_column"),
  total_marker = "#",
  total_row = 1,
  total_column_marker = "#",
  digits = get_expss_digits()
)

cell_chisq(cases_matrix, row_base, col_base, total_base, correct)

significance_cpct(
  x,
  sig_level = 0.05,
  delta_cpct = 0,
  min_base = 2,
  compare_type = "subtable",
  bonferroni = FALSE,
  subtable_marks = c("greater", "both", "less"),
  inequality_sign = "both" %in% subtable_marks,
  sig_labels = LETTERS,
  sig_labels_previous_column = c("v", "^"),
  sig_labels_first_column = c("-", "+"),
  keep = c("percent", "bases"),
  na_as_zero = FALSE,
  total_marker = "#",
  total_row = 1,
  digits = get_expss_digits(),
  as_spss = FALSE
)

add_sig_labels(x, sig_labels = LETTERS)

significance_means(
  x,
  sig_level = 0.05,
  delta_means = 0,
  min_base = 2,
  compare_type = "subtable",
  bonferroni = FALSE,
  subtable_marks = c("greater", "both", "less"),
  inequality_sign = "both" %in% subtable_marks,
  sig_labels = LETTERS,
  sig_labels_previous_column = c("v", "^"),
  sig_labels_first_column = c("-", "+"),
  keep = c("means", "sd", "bases"),
  var_equal = FALSE,
  digits = get_expss_digits()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tab_significance_options_+3A_data">data</code></td>
<td>
<p>data.frame/intermediate_table for <code>tab_*</code> functions.</p>
</td></tr>
<tr><td><code id="tab_significance_options_+3A_sig_level">sig_level</code></td>
<td>
<p>numeric. Significance level - by default it equals to <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="tab_significance_options_+3A_min_base">min_base</code></td>
<td>
<p>numeric. Significance test will be conducted if both
columns have bases greater or equal to <code>min_base</code>. By default, it equals to <code>2</code>.</p>
</td></tr>
<tr><td><code id="tab_significance_options_+3A_delta_cpct">delta_cpct</code></td>
<td>
<p>numeric. Minimal delta between percent for which we mark 
significant differences (in percent points) - by default it equals to zero.
Note that, for example, for minimal 5 percent point difference
<code>delta_cpct</code> should be equals 5, not 0.05.</p>
</td></tr>
<tr><td><code id="tab_significance_options_+3A_delta_means">delta_means</code></td>
<td>
<p>numeric. Minimal delta between means for which we mark 
significant differences  - by default it equals to zero.</p>
</td></tr>
<tr><td><code id="tab_significance_options_+3A_correct">correct</code></td>
<td>
<p>logical indicating whether to apply continuity correction when
computing the test statistic for 2 by 2 tables. Only for
<code>significance_cases</code> and <code>significance_cell_chisq</code>. For details
see <a href="stats.html#topic+chisq.test">chisq.test</a>. <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="tab_significance_options_+3A_compare_type">compare_type</code></td>
<td>
<p>Type of compare between columns. By default, it is 
<code>subtable</code> - comparisons will be conducted between columns of each 
subtable. Other possible values are: <code>first_column</code>, 
<code>adjusted_first_column</code> and <code>previous_column</code>. We can conduct
several tests simultaneously.</p>
</td></tr>
<tr><td><code id="tab_significance_options_+3A_bonferroni">bonferroni</code></td>
<td>
<p>logical. <code>FALSE</code> by default. Should we use Bonferroni
adjustment by the number of comparisons in each row?</p>
</td></tr>
<tr><td><code id="tab_significance_options_+3A_subtable_marks">subtable_marks</code></td>
<td>
<p>character. One of &quot;greater&quot;, &quot;both&quot; or &quot;less&quot;. By
deafult we mark only values which are significantly greater than some other
columns. For <code>significance_cell_chisq</code> default is &quot;both&quot;.We can change
this behavior by setting an argument to <code>less</code> or <code>both</code>.</p>
</td></tr>
<tr><td><code id="tab_significance_options_+3A_inequality_sign">inequality_sign</code></td>
<td>
<p>logical. FALSE if <code>subtable_marks</code> is &quot;less&quot; or 
&quot;greater&quot;. Should we show <code>&gt;</code> or <code>&lt;</code> before significance marks of
subtable comparisons.</p>
</td></tr>
<tr><td><code id="tab_significance_options_+3A_sig_labels">sig_labels</code></td>
<td>
<p>character vector. Labels for marking differences between
columns of subtable.</p>
</td></tr>
<tr><td><code id="tab_significance_options_+3A_sig_labels_previous_column">sig_labels_previous_column</code></td>
<td>
<p>a character vector with two elements. Labels
for marking a difference with the previous column. First mark means 'lower' (by
default it is <code>v</code>) and the second means greater (<code>^</code>).</p>
</td></tr>
<tr><td><code id="tab_significance_options_+3A_sig_labels_first_column">sig_labels_first_column</code></td>
<td>
<p>a character vector with two elements. Labels 
for marking a difference with the first column of the table. First mark means
'lower' (by default it is <code>-</code>) and the second means 'greater'
(<code>+</code>).</p>
</td></tr>
<tr><td><code id="tab_significance_options_+3A_sig_labels_chisq">sig_labels_chisq</code></td>
<td>
<p>a character vector with two labels 
for marking a difference with row margin of the table. First mark means
'lower' (by default it is <code>&lt;</code>) and the second means 'greater'
(<code>&gt;</code>). Only for <code>significance_cell_chisq</code>.</p>
</td></tr>
<tr><td><code id="tab_significance_options_+3A_keep">keep</code></td>
<td>
<p>character. One or more from &quot;percent&quot;, &quot;cases&quot;, &quot;means&quot;, &quot;bases&quot;, 
&quot;sd&quot; or &quot;none&quot;. This argument determines which statistics will remain in
the table after significance marking.</p>
</td></tr>
<tr><td><code id="tab_significance_options_+3A_row_margin">row_margin</code></td>
<td>
<p>character. One of values &quot;auto&quot; (default), &quot;sum_row&quot;, or
&quot;first_column&quot;. If it is &quot;auto&quot; we try to find total column in the subtable
by <code>total_column_marker</code>. If the search is failed, we use the sum of
each rows as row total. With &quot;sum_row&quot; option we always sum each row to get
margin. Note that in this case result for multiple response variables in
banners may be incorrect. With &quot;first_column&quot; option we use table first
column as row margin for all subtables. In this case result for the
subtables with incomplete bases may be incorrect. Only for
<code>significance_cell_chisq</code>.</p>
</td></tr>
<tr><td><code id="tab_significance_options_+3A_total_marker">total_marker</code></td>
<td>
<p>character. Total rows mark in the table. &quot;#&quot; by default.</p>
</td></tr>
<tr><td><code id="tab_significance_options_+3A_total_row">total_row</code></td>
<td>
<p>integer/character. In the case of the several totals per
subtable it is a number or name of total row for the significance
calculation.</p>
</td></tr>
<tr><td><code id="tab_significance_options_+3A_digits">digits</code></td>
<td>
<p>an integer indicating how much digits after decimal separator</p>
</td></tr>
<tr><td><code id="tab_significance_options_+3A_na_as_zero">na_as_zero</code></td>
<td>
<p>logical. <code>FALSE</code> by default. Should we treat
<code>NA</code>'s as zero cases?</p>
</td></tr>
<tr><td><code id="tab_significance_options_+3A_var_equal">var_equal</code></td>
<td>
<p>a logical variable indicating whether to treat the two
variances as being equal. For details see <a href="stats.html#topic+t.test">t.test</a>.</p>
</td></tr>
<tr><td><code id="tab_significance_options_+3A_mode">mode</code></td>
<td>
<p>character. One of <code>replace</code>(default) or <code>append</code>. In
the first case the previous result in the sequence of table calculation
will be replaced with result of significance testing. In the second case
result of the significance testing will be appended to sequence of table
calculation.</p>
</td></tr>
<tr><td><code id="tab_significance_options_+3A_as_spss">as_spss</code></td>
<td>
<p>a logical. FALSE by default. If TRUE, proportions which
are equal to zero or one will be ignored. Also will be ignored categories
with bases less than 2.</p>
</td></tr>
<tr><td><code id="tab_significance_options_+3A_label">label</code></td>
<td>
<p>character. Label for the statistic in the <code>tab_*</code>. Ignored
if the <code>mode</code> is equals to <code>replace</code>.</p>
</td></tr>
<tr><td><code id="tab_significance_options_+3A_total_column_marker">total_column_marker</code></td>
<td>
<p>character. Mark for total columns in the
subtables. &quot;#&quot; by default.</p>
</td></tr>
<tr><td><code id="tab_significance_options_+3A_x">x</code></td>
<td>
<p>table (class <code>etable</code>): result of <a href="#topic+cross_cpct">cross_cpct</a> with 
proportions and bases for <code>significance_cpct</code>, result of 
<a href="#topic+cross_mean_sd_n">cross_mean_sd_n</a> with means, standard deviations and valid N for 
<code>significance_means</code>, and result of <a href="#topic+cross_cases">cross_cases</a> with counts and
bases for <code>significance_cases</code>.</p>
</td></tr>
<tr><td><code id="tab_significance_options_+3A_cases_matrix">cases_matrix</code></td>
<td>
<p>numeric matrix with counts size R*C</p>
</td></tr>
<tr><td><code id="tab_significance_options_+3A_row_base">row_base</code></td>
<td>
<p>numeric vector with row bases, length R</p>
</td></tr>
<tr><td><code id="tab_significance_options_+3A_col_base">col_base</code></td>
<td>
<p>numeric vector with col bases, length C</p>
</td></tr>
<tr><td><code id="tab_significance_options_+3A_total_base">total_base</code></td>
<td>
<p>numeric single value, total base</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>tab_last_*</code> functions return objects of class
<code>intermediate_table</code>. Use <a href="#topic+tab_pivot">tab_pivot</a> to get the final result -
<code>etable</code> object. Other functions return <code>etable</code> object with
significant differences.
</p>


<h3>See Also</h3>

<p><a href="#topic+cross_cpct">cross_cpct</a>, <a href="#topic+cross_cases">cross_cases</a>, <a href="#topic+cross_mean_sd_n">cross_mean_sd_n</a>, <a href="#topic+tables">tables</a>,
<a href="#topic+compare_proportions">compare_proportions</a>, <a href="#topic+compare_means">compare_means</a>, <a href="stats.html#topic+prop.test">prop.test</a>,
<a href="stats.html#topic+t.test">t.test</a>, <a href="stats.html#topic+chisq.test">chisq.test</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
mtcars = apply_labels(mtcars,
                      mpg = "Miles/(US) gallon",
                      cyl = "Number of cylinders",
                      disp = "Displacement (cu.in.)",
                      hp = "Gross horsepower",
                      drat = "Rear axle ratio",
                      wt = "Weight (lb/1000)",
                      qsec = "1/4 mile time",
                      vs = "Engine",
                      vs = c("V-engine" = 0,
                             "Straight engine" = 1),
                      am = "Transmission",
                      am = c("Automatic" = 0,
                             "Manual"=1),
                      gear = "Number of forward gears",
                      carb = "Number of carburetors"
)

## Not run: 
mtcars_table = cross_cpct(mtcars, 
                          list(cyl, gear),
                          list(total(), vs, am)
                          )

significance_cpct(mtcars_table)
# comparison with first column
significance_cpct(mtcars_table, compare_type = "first_column")

# comparison with first column and inside subtable
significance_cpct(mtcars_table, 
            compare_type = c("first_column", "subtable"))

# only significance marks
significance_cpct(mtcars_table, keep = "none")

# means
mtcars_means = cross_mean_sd_n(mtcars, 
                               list(mpg, wt, hp),
                               list(total(), vs, cyl))
                               )
                        
significance_means(mtcars_means) 

# mark values which are less and greater
significance_means(mtcars_means, subtable_marks = "both")

# chi-squared test
mtcars_cases = cross_cases(mtcars, 
                           list(cyl, gear),
                           list(total(), vs, am)
                           )
                         
significance_cases(mtcars_cases)  

# cell chi-squared test
# increase number of cases to avoid warning about chi-square approximation
mtcars2 = add_rows(mtcars, mtcars, mtcars)

tbl = cross_cpct(mtcars2, gear, am)
significance_cell_chisq(tbl)

# table with multiple variables
tbl = cross_cpct(mtcars2, list(gear, cyl), list(total(), am, vs))
significance_cell_chisq(tbl, sig_level = .0001)  

# custom tables with significance
mtcars %&gt;% 
    tab_significance_options(subtable_marks = "both") %&gt;% 
    tab_cells(mpg, hp) %&gt;% 
    tab_cols(total(), vs, am) %&gt;% 
    tab_stat_mean_sd_n() %&gt;% 
    tab_last_sig_means(keep = "means") %&gt;% 
    tab_cells(cyl, gear) %&gt;% 
    tab_stat_cpct() %&gt;% 
    tab_last_sig_cpct() %&gt;% 
    tab_pivot()   
    
# Overcomplicated examples - we move significance marks to
# separate columns. Columns with statistics remain numeric    
mtcars %&gt;% 
    tab_significance_options(keep = "none", 
                         sig_labels = NULL, 
                         subtable_marks = "both",  
                         mode = "append") %&gt;% 
    tab_cols(total(), vs, am) %&gt;% 
    tab_cells(mpg, hp) %&gt;% 
    tab_stat_mean_sd_n() %&gt;% 
    tab_last_sig_means() %&gt;% 
    tab_last_hstack("inside_columns") %&gt;% 
    tab_cells(cyl, gear) %&gt;% 
    tab_stat_cpct() %&gt;% 
    tab_last_sig_cpct() %&gt;% 
    tab_last_hstack("inside_columns") %&gt;% 
    tab_pivot(stat_position = "inside_rows") %&gt;% 
    drop_empty_columns()    

## End(Not run)   
</code></pre>

<hr>
<h2 id='tab_sort_asc'>Partially (inside blocks) sort tables/data.frames</h2><span id='topic+tab_sort_asc'></span><span id='topic+tab_sort_desc'></span>

<h3>Description</h3>

<p><code>tab_sort_asc</code>/<code>tab_sort_desc</code> sort tables (usually result of 
<a href="#topic+cro">cro</a>/<a href="#topic+tables">tables</a>) in ascending/descending order between specified
rows (by default, it is rows which contain '#' in the first column).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tab_sort_asc(x, ..., excluded_rows = "#", na.last = FALSE)

tab_sort_desc(x, ..., excluded_rows = "#", na.last = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tab_sort_asc_+3A_x">x</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="tab_sort_asc_+3A_...">...</code></td>
<td>
<p>character/numeric or criteria/logical functions (see 
<a href="#topic+criteria">criteria</a>). Column names/numbers for data.frame/matrix by which 
object will be sorted. Names at the top-level can be unquoted (non-standard
evaluation). For standard evaluation of parameters you can surround them by
round brackets. See examples. If this argument is missing then table will 
be sorted by second column. Usually second column is the first column with
numbers in the table (there are row labels in the first column).</p>
</td></tr>
<tr><td><code id="tab_sort_asc_+3A_excluded_rows">excluded_rows</code></td>
<td>
<p>character/logical/numeric rows which won't be sorted. 
Rows of the table will be sorted between excluded rows. If it is characters
then they will be considered as pattern/vector of patterns. Patterns will
be matched with Perl-style regular expression with values in the first
column of <code>x</code> (see <a href="base.html#topic+grep">grep</a>, <code>perl = TRUE</code> argument).
Rows which have such patterns will be excluded. By default, pattern is &quot;#&quot;
because &quot;#&quot; marks totals in the result of <a href="#topic+cro">cro</a>.</p>
</td></tr>
<tr><td><code id="tab_sort_asc_+3A_na.last">na.last</code></td>
<td>
<p>for controlling the treatment of NAs. If TRUE, missing values
in the data are put last; if FALSE, they are put first; if NA, they are
removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sorted table('etable')/data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(mtcars)

# apply labels
mtcars = apply_labels(mtcars,
    cyl = "Number of cylinders",
    vs = "Engine",
    vs = c("V-engine" = 0,
                    "Straight engine" = 1),
    am = "Transmission",
    am = c(automatic = 0,
                    manual=1),
    gear = "Number of forward gears",
    carb = "Number of carburetors"
)

# without sorting
mtcars %&gt;% cross_cpct(list(cyl, gear, carb), list("#total", vs, am))

# with sorting
mtcars %&gt;% 
    cross_cpct(list(cyl, gear, carb), list("#total", vs, am)) %&gt;% 
    tab_sort_desc
    
# sort by parameter
sorting_column = "Engine|V-engine"

mtcars %&gt;% 
    cross_cpct(list(cyl, gear, carb), list("#total", vs, am)) %&gt;% 
    tab_sort_desc((sorting_column))

## End(Not run)    
</code></pre>

<hr>
<h2 id='tables'>Functions for custom tables construction</h2><span id='topic+tables'></span><span id='topic+tab_cols'></span><span id='topic+tab_cells'></span><span id='topic+tab_rows'></span><span id='topic+tab_weight'></span><span id='topic+tab_mis_val'></span><span id='topic+tab_total_label'></span><span id='topic+tab_total_statistic'></span><span id='topic+tab_total_row_position'></span><span id='topic+tab_subgroup'></span><span id='topic+tab_row_label'></span><span id='topic+tab_stat_fun'></span><span id='topic+tab_stat_mean_sd_n'></span><span id='topic+tab_stat_mean'></span><span id='topic+tab_stat_median'></span><span id='topic+tab_stat_se'></span><span id='topic+tab_stat_sum'></span><span id='topic+tab_stat_min'></span><span id='topic+tab_stat_max'></span><span id='topic+tab_stat_sd'></span><span id='topic+tab_stat_valid_n'></span><span id='topic+tab_stat_unweighted_valid_n'></span><span id='topic+tab_stat_fun_df'></span><span id='topic+tab_stat_cases'></span><span id='topic+tab_stat_cpct'></span><span id='topic+tab_stat_cpct_responses'></span><span id='topic+tab_stat_tpct'></span><span id='topic+tab_stat_rpct'></span><span id='topic+tab_last_vstack'></span><span id='topic+tab_last_hstack'></span><span id='topic+tab_pivot'></span><span id='topic+tab_transpose'></span><span id='topic+tab_caption'></span>

<h3>Description</h3>

<p>Table construction consists of at least of three functions chained with 
<code>magrittr</code> pipe operator. At first we need to 
specify variables for which statistics will be computed with 
<code>tab_cells</code>. Secondary, we calculate statistics with one of 
<code>tab_stat_*</code> functions. And last, we finalize table creation with 
<code>tab_pivot</code>: <code>dataset %&gt;% tab_cells(variable) %&gt;%
tab_stat_cases() %&gt;% tab_pivot()</code>. After that we can optionally sort table
with <a href="#topic+tab_sort_asc">tab_sort_asc</a>, drop empty rows/columns with <a href="#topic+drop_rc">drop_rc</a> and 
transpose with <code>tab_transpose</code>. Generally, table is just a data.frame so
we can use arbitrary operations on it. Statistic is always calculated with 
the last cell, column/row variables, weight, missing values and subgroup. To 
define new cell/column/row variables we can call appropriate function one more time. 
<code>tab_pivot</code> defines how we combine different statistics and where 
statistic labels will appear - inside/outside rows/columns. See examples.
For significance testing see <a href="#topic+significance">significance</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tab_cols(data, ...)

tab_cells(data, ...)

tab_rows(data, ...)

tab_weight(data, weight = NULL)

tab_mis_val(data, ...)

tab_total_label(data, ...)

tab_total_statistic(data, ...)

tab_total_row_position(data, total_row_position = c("below", "above", "none"))

tab_subgroup(data, subgroup = NULL)

tab_row_label(data, ..., label = NULL)

tab_stat_fun(data, ..., label = NULL, unsafe = FALSE)

tab_stat_mean_sd_n(
  data,
  weighted_valid_n = FALSE,
  labels = c("Mean", "Std. dev.", ifelse(weighted_valid_n, "Valid N", "Unw. valid N")),
  label = NULL
)

tab_stat_mean(data, label = "Mean")

tab_stat_median(data, label = "Median")

tab_stat_se(data, label = "S. E.")

tab_stat_sum(data, label = "Sum")

tab_stat_min(data, label = "Min.")

tab_stat_max(data, label = "Max.")

tab_stat_sd(data, label = "Std. dev.")

tab_stat_valid_n(data, label = "Valid N")

tab_stat_unweighted_valid_n(data, label = "Unw. valid N")

tab_stat_fun_df(data, ..., label = NULL, unsafe = FALSE)

tab_stat_cases(
  data,
  total_label = NULL,
  total_statistic = "u_cases",
  total_row_position = c("below", "above", "none"),
  label = NULL
)

tab_stat_cpct(
  data,
  total_label = NULL,
  total_statistic = "u_cases",
  total_row_position = c("below", "above", "none"),
  label = NULL
)

tab_stat_cpct_responses(
  data,
  total_label = NULL,
  total_statistic = "u_responses",
  total_row_position = c("below", "above", "none"),
  label = NULL
)

tab_stat_tpct(
  data,
  total_label = NULL,
  total_statistic = "u_cases",
  total_row_position = c("below", "above", "none"),
  label = NULL
)

tab_stat_rpct(
  data,
  total_label = NULL,
  total_statistic = "u_cases",
  total_row_position = c("below", "above", "none"),
  label = NULL
)

tab_last_vstack(
  data,
  stat_position = c("outside_rows", "inside_rows"),
  stat_label = c("inside", "outside"),
  label = NULL
)

tab_last_hstack(
  data,
  stat_position = c("outside_columns", "inside_columns"),
  stat_label = c("inside", "outside"),
  label = NULL
)

tab_pivot(
  data,
  stat_position = c("outside_rows", "inside_rows", "outside_columns", "inside_columns"),
  stat_label = c("inside", "outside")
)

tab_transpose(data)

tab_caption(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tables_+3A_data">data</code></td>
<td>
<p>data.frame/intermediate_table</p>
</td></tr>
<tr><td><code id="tables_+3A_...">...</code></td>
<td>
<p>vector/data.frame/list. Variables for tables. Use
<a href="#topic+mrset">mrset</a>/<a href="#topic+mdset">mdset</a> for multiple-response variables.</p>
</td></tr>
<tr><td><code id="tables_+3A_weight">weight</code></td>
<td>
<p>numeric vector in <code>tab_weight</code>. Cases with NA's, negative
and zero weights are removed before calculations.</p>
</td></tr>
<tr><td><code id="tables_+3A_total_row_position">total_row_position</code></td>
<td>
<p>Position of total row in the resulting table. Can
be one of &quot;below&quot;, &quot;above&quot;, &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="tables_+3A_subgroup">subgroup</code></td>
<td>
<p>logical vector in <code>tab_subgroup</code>. You can specify
subgroup on which table will be computed.</p>
</td></tr>
<tr><td><code id="tables_+3A_label">label</code></td>
<td>
<p>character. Label for the statistic in the <code>tab_stat_*</code>.</p>
</td></tr>
<tr><td><code id="tables_+3A_unsafe">unsafe</code></td>
<td>
<p>logical If TRUE than <code>fun</code> will be evaluated as is. It can
lead to significant increase in the performance. But there are some 
limitations. For <code>tab_stat_fun</code> it means that your function <code>fun</code> 
should return vector of length one. Also there will be no attempts to make
labels for statistic.  For <code>tab_stat_fun_df</code> your function should return
vector of length one or list/data.frame (optionally with 'row_labels'
element - statistic labels). If <code>unsafe</code> is TRUE then further
arguments (<code>...</code>) for <code>fun</code> will be ignored.</p>
</td></tr>
<tr><td><code id="tables_+3A_weighted_valid_n">weighted_valid_n</code></td>
<td>
<p>logical. Sould we show weighted valid N in
<code>tab_stat_mean_sd_n</code>? By default it is FALSE.</p>
</td></tr>
<tr><td><code id="tables_+3A_labels">labels</code></td>
<td>
<p>character vector of length 3. Labels for mean, standard
deviation and valid N in <code>tab_stat_mean_sd_n</code>.</p>
</td></tr>
<tr><td><code id="tables_+3A_total_label">total_label</code></td>
<td>
<p>By default &quot;#Total&quot;. You can provide several names - each
name for each total statistics.</p>
</td></tr>
<tr><td><code id="tables_+3A_total_statistic">total_statistic</code></td>
<td>
<p>By default it is &quot;u_cases&quot; (unweighted cases). 
Possible values are &quot;u_cases&quot;, &quot;u_responses&quot;, &quot;u_cpct&quot;, &quot;u_rpct&quot;, &quot;u_tpct&quot;,
&quot;w_cases&quot;, &quot;w_responses&quot;, &quot;w_cpct&quot;, &quot;w_rpct&quot;, &quot;w_tpct&quot;. &quot;u_&quot; means
unweighted statistics and &quot;w_&quot; means weighted statistics.</p>
</td></tr>
<tr><td><code id="tables_+3A_stat_position">stat_position</code></td>
<td>
<p>character one of the values <code>"outside_rows"</code>, 
<code>"inside_rows"</code>, <code>"outside_columns"</code> or <code>"inside_columns"</code>.
It defines how we will combine statistics in the table.</p>
</td></tr>
<tr><td><code id="tables_+3A_stat_label">stat_label</code></td>
<td>
<p>character one of the values <code>"inside"</code> or 
<code>"outside"</code>. Where will be placed labels for the statistics relative
to column names/row labels? See examples.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p><code>tab_cells</code> variables on which percentage/cases/summary
functions will be computed. Use <a href="#topic+mrset">mrset</a>/<a href="#topic+mdset">mdset</a> for
multiple-response variables.
</p>
</li>
<li><p><code>tab_cols</code> optional variables which breaks table by
columns. Use <a href="#topic+mrset">mrset</a>/<a href="#topic+mdset">mdset</a> for
multiple-response variables.
</p>
</li>
<li><p><code>tab_rows</code> optional variables which breaks table by rows. Use
<a href="#topic+mrset">mrset</a>/<a href="#topic+mdset">mdset</a> for multiple-response variables.
</p>
</li>
<li><p><code>tab_weight</code> optional weight for the statistic.
</p>
</li>
<li><p><code>tab_mis_val</code> optional missing values for the statistic. It will
be applied on variables specified by <code>tab_cells</code>. It works in the same
manner as <a href="#topic+na_if">na_if</a>.
</p>
</li>
<li><p><code>tab_subgroup</code> optional logical vector/expression which specify
subset of data for table.
</p>
</li>
<li><p><code>tab_row_label</code> Add to table empty row with specified row
labels. It is usefull for making section headings and etc.
</p>
</li>
<li><p><code>tab_total_row_position</code> Default value for
<code>total_row_position</code> argument in <code>tab_stat_cases</code> and etc. Can be
one of &quot;below&quot;, &quot;above&quot;, &quot;none&quot;.
</p>
</li>
<li><p><code>tab_total_label</code> Default value for <code>total_label</code> argument
in <code>tab_stat_cases</code> and etc. You can provide several names - each name
for each total statistics.
</p>
</li>
<li><p><code>tab_total_statistic</code> Default value for <code>total_statistic</code>
argument in <code>tab_stat_cases</code> and etc. You can provide several values.
Possible values are &quot;u_cases&quot;, &quot;u_responses&quot;, &quot;u_cpct&quot;, &quot;u_rpct&quot;, &quot;u_tpct&quot;, 
&quot;w_cases&quot;, &quot;w_responses&quot;, &quot;w_cpct&quot;, &quot;w_rpct&quot;, &quot;w_tpct&quot;. &quot;u_&quot; means unweighted
statistics and &quot;w_&quot; means weighted statistics.
</p>
</li>
<li><p><code>tab_stat_fun</code>, <code>tab_stat_fun_df</code> <code>tab_stat_fun</code> 
applies function on each variable in cells separately, <code>tab_stat_fun_df</code>
gives to function each data.frame in cells as a whole 
<a href="data.table.html#topic+data.table">data.table</a> with all names converted to variable labels (if
labels exists). So it is not recommended to rely on original variables names 
in your <code>fun</code>. For details see <a href="#topic+cross_fun">cross_fun</a>. You can provide several
functions as arguments. They will be combined as with
<a href="#topic+combine_functions">combine_functions</a>. So you can use <code>method</code> argument. For details
see documentation for <a href="#topic+combine_functions">combine_functions</a>. 
</p>
</li>
<li><p><code>tab_stat_cases</code> calculate counts.
</p>
</li>
<li><p><code>tab_stat_cpct</code>, <code>tab_stat_cpct_responses</code> calculate column
percent. These functions give different results only for multiple response
variables. For <code>tab_stat_cpct</code> base of percent is number of valid cases.
Case is considered as valid if it has at least one non-NA value. So for
multiple response variables sum of percent may be greater than 100. For 
<code>tab_stat_cpct_responses</code> base of percent is number of valid responses. 
Multiple response variables can have several responses for single case. Sum 
of percent of <code>tab_stat_cpct_responses</code> always equals to 100%.
</p>
</li>
<li><p><code>tab_stat_rpct</code> calculate row percent. Base
for percent is number of valid cases.
</p>
</li>
<li><p><code>tab_stat_tpct</code> calculate table percent. Base
for percent is number of valid cases.
</p>
</li>
<li><p><code>tab_stat_mean</code>, <code>tab_stat_median</code>, <code>tab_stat_se</code>,
<code>tab_stat_sum</code>, <code>tab_stat_min</code>, <code>tab_stat_max</code>,
<code>tab_stat_sd</code>, <code>tab_stat_valid_n</code>, 
<code>tab_stat_unweighted_valid_n</code> different summary statistics. NA's are
always omitted.
</p>
</li>
<li><p><code>tab_pivot</code> finalize table creation and define how different
<code>tab_stat_*</code> will be combined
</p>
</li>
<li><p><code>tab_caption</code> set caption on the table. Should be used after the <code>tab_pivot</code>.
</p>
</li>
<li><p><code>tab_transpose</code> transpose final table after <code>tab_pivot</code> or last
statistic.</p>
</li></ul>



<h3>Value</h3>

<p>All of these functions return object of class 
<code>intermediate_table</code> except <code>tab_pivot</code> which returns final
result - object of class <code>etable</code>. Basically it's a data.frame but
class is needed for custom methods.
</p>


<h3>See Also</h3>

<p><a href="#topic+fre">fre</a>, <a href="#topic+cross_cases">cross_cases</a>, <a href="#topic+cross_fun">cross_fun</a>, <a href="#topic+tab_sort_asc">tab_sort_asc</a>,
<a href="#topic+drop_empty_rows">drop_empty_rows</a>, <a href="#topic+significance">significance</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(mtcars)
mtcars = apply_labels(mtcars,
                      mpg = "Miles/(US) gallon",
                      cyl = "Number of cylinders",
                      disp = "Displacement (cu.in.)",
                      hp = "Gross horsepower",
                      drat = "Rear axle ratio",
                      wt = "Weight (1000 lbs)",
                      qsec = "1/4 mile time",
                      vs = "Engine",
                      vs = c("V-engine" = 0,
                             "Straight engine" = 1),
                      am = "Transmission",
                      am = c("Automatic" = 0,
                             "Manual"=1),
                      gear = "Number of forward gears",
                      carb = "Number of carburetors"
)
# some examples from 'cro'
# simple example - generally with 'cro' it can be made with less typing
mtcars %&gt;% 
    tab_cells(cyl) %&gt;% 
    tab_cols(vs) %&gt;% 
    tab_stat_cpct() %&gt;% 
    tab_pivot()

# split rows
mtcars %&gt;% 
    tab_cells(cyl) %&gt;% 
    tab_cols(vs) %&gt;% 
    tab_rows(am) %&gt;% 
    tab_stat_cpct() %&gt;% 
    tab_pivot()

# multiple banners
mtcars %&gt;% 
    tab_cells(cyl) %&gt;% 
    tab_cols(total(), vs, am) %&gt;% 
    tab_stat_cpct() %&gt;% 
    tab_pivot()

# nested banners
mtcars %&gt;% 
    tab_cells(cyl) %&gt;% 
    tab_cols(total(), vs %nest% am) %&gt;% 
    tab_stat_cpct() %&gt;% 
    tab_pivot()

# summary statistics
mtcars %&gt;% 
    tab_cells(mpg, disp, hp, wt, qsec) %&gt;%
    tab_cols(am) %&gt;% 
    tab_stat_fun(Mean = w_mean, "Std. dev." = w_sd, "Valid N" = w_n) %&gt;%
    tab_pivot()

# summary statistics - labels in columns
mtcars %&gt;% 
    tab_cells(mpg, disp, hp, wt, qsec) %&gt;%
    tab_cols(am) %&gt;% 
    tab_stat_fun(Mean = w_mean, "Std. dev." = w_sd, "Valid N" = w_n, method = list) %&gt;%
    tab_pivot()

# subgroup with droping empty columns
mtcars %&gt;% 
    tab_subgroup(am == 0) %&gt;% 
    tab_cells(cyl) %&gt;% 
    tab_cols(total(), vs %nest% am) %&gt;% 
    tab_stat_cpct() %&gt;% 
    tab_pivot() %&gt;% 
    drop_empty_columns()

# total position at the top of the table
mtcars %&gt;% 
    tab_cells(cyl) %&gt;% 
    tab_cols(total(), vs) %&gt;% 
    tab_rows(am) %&gt;% 
    tab_stat_cpct(total_row_position = "above",
                  total_label = c("number of cases", "row %"),
                  total_statistic = c("u_cases", "u_rpct")) %&gt;% 
    tab_pivot()

# this example cannot be made easily with 'cro'             
mtcars %&gt;%
    tab_cells(am) %&gt;%
    tab_cols(total(), vs) %&gt;%
    tab_total_row_position("none") %&gt;% 
    tab_stat_cpct(label = "col %") %&gt;%
    tab_stat_rpct(label = "row %") %&gt;%
    tab_stat_tpct(label = "table %") %&gt;%
    tab_pivot(stat_position = "inside_rows")

# statistic labels inside columns             
mtcars %&gt;%
    tab_cells(am) %&gt;%
    tab_cols(total(), vs) %&gt;%
    tab_total_row_position("none") %&gt;% 
    tab_stat_cpct(label = "col %") %&gt;%
    tab_stat_rpct(label = "row %") %&gt;%
    tab_stat_tpct(label = "table %") %&gt;%
    tab_pivot(stat_position = "inside_columns")

# stacked statistics
mtcars %&gt;% 
    tab_cells(cyl) %&gt;% 
    tab_cols(total(), am) %&gt;% 
    tab_stat_mean() %&gt;%
    tab_stat_se() %&gt;% 
    tab_stat_valid_n() %&gt;% 
    tab_stat_cpct() %&gt;% 
    tab_pivot()
    
# stacked statistics with section headings
mtcars %&gt;% 
    tab_cells(cyl) %&gt;% 
    tab_cols(total(), am) %&gt;% 
    tab_row_label("#Summary statistics") %&gt;% 
    tab_stat_mean() %&gt;%
    tab_stat_se() %&gt;% 
    tab_stat_valid_n() %&gt;% 
    tab_row_label("#Column percent") %&gt;% 
    tab_stat_cpct() %&gt;% 
    tab_pivot()

# stacked statistics with different variables
mtcars %&gt;% 
    tab_cols(total(), am) %&gt;% 
    tab_cells(mpg, hp, qsec) %&gt;% 
    tab_stat_mean() %&gt;%
    tab_cells(cyl, carb) %&gt;% 
    tab_stat_cpct() %&gt;% 
    tab_pivot()

# stacked statistics - label position outside row labels
mtcars %&gt;% 
    tab_cells(cyl) %&gt;% 
    tab_cols(total(), am) %&gt;% 
    tab_stat_mean() %&gt;%
    tab_stat_se %&gt;% 
    tab_stat_valid_n() %&gt;% 
    tab_stat_cpct(label = "Col %") %&gt;% 
    tab_pivot(stat_label = "outside")
    
# example from 'cross_fun_df' - linear regression by groups with sorting 
mtcars %&gt;% 
    tab_cells(sheet(mpg, disp, hp, wt, qsec)) %&gt;% 
    tab_cols(total(), am) %&gt;% 
    tab_stat_fun_df(
        function(x){
            frm = reformulate(".", response = as.name(names(x)[1]))
            model = lm(frm, data = x)
            sheet('Coef.' = coef(model), 
                  confint(model)
            )
        }    
    ) %&gt;% 
    tab_pivot() %&gt;% 
    tab_sort_desc()

# multiple-response variables and weight
data(product_test)
codeframe_likes = num_lab("
                          1 Liked everything
                          2 Disliked everything
                          3 Chocolate
                          4 Appearance
                          5 Taste
                          6 Stuffing
                          7 Nuts
                          8 Consistency
                          98 Other
                          99 Hard to answer
                          ")

set.seed(1)
product_test = product_test %&gt;% 
    let(
        # recode age by groups
        age_cat = recode(s2a, lo %thru% 25 ~ 1, lo %thru% hi ~ 2),
        wgt = runif(.N, 0.25, 4),
        wgt = wgt/sum(wgt)*.N
    ) %&gt;% 
    apply_labels(
        age_cat = "Age",
        age_cat = c("18 - 25" = 1, "26 - 35" = 2),
        
        a1_1 = "Likes. VSX123",
        b1_1 = "Likes. SDF456",
        a1_1 = codeframe_likes,
        b1_1 = codeframe_likes
    )

product_test %&gt;% 
    tab_cells(mrset(a1_1 %to% a1_6), mrset(b1_1 %to% b1_6)) %&gt;% 
    tab_cols(total(), age_cat) %&gt;% 
    tab_weight(wgt) %&gt;% 
    tab_stat_cpct() %&gt;% 
    tab_sort_desc() %&gt;% 
    tab_pivot()
    
# trick to place cell variables labels inside columns
# useful to compare two variables
# '|' is needed to prevent automatic labels creation from argument
# alternatively we can use list(...) to avoid this
product_test %&gt;% 
    tab_cols(total(), age_cat) %&gt;% 
    tab_weight(wgt) %&gt;% 
    tab_cells("|" = unvr(mrset(a1_1 %to% a1_6))) %&gt;% 
    tab_stat_cpct(label = var_lab(a1_1)) %&gt;% 
    tab_cells("|" = unvr(mrset(b1_1 %to% b1_6))) %&gt;% 
    tab_stat_cpct(label = var_lab(b1_1)) %&gt;% 
    tab_pivot(stat_position = "inside_columns")

# if you need standard evaluation, use 'vars'
tables = mtcars %&gt;%
      tab_cols(total(), am %nest% vs)

for(each in c("mpg", "disp", "hp", "qsec")){
    tables = tables %&gt;% tab_cells(vars(each)) %&gt;%
        tab_stat_fun(Mean = w_mean, "Std. dev." = w_sd, "Valid N" = w_n) 
}
tables %&gt;% tab_pivot()

## End(Not run) 
</code></pre>

<hr>
<h2 id='text_to_columns'>Make data.frame from text</h2><span id='topic+text_to_columns'></span><span id='topic+text_to_columns_csv'></span><span id='topic+text_to_columns_csv2'></span><span id='topic+text_to_columns_tab'></span><span id='topic+text_to_columns_tab2'></span>

<h3>Description</h3>

<p>Convert delimited text lines to data.frame. Blank lines are always skipped,
trailing whitespaces are trimmed. You can use comments with '#' inside your text.
For details see <a href="utils.html#topic+read.table">read.table</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_to_columns(
  text,
  header = TRUE,
  sep = "",
  quote = "",
  dec = ".",
  encoding = "unknown",
  ...
)

text_to_columns_csv(
  text,
  header = TRUE,
  sep = ",",
  quote = "",
  dec = ".",
  encoding = "unknown",
  ...
)

text_to_columns_csv2(
  text,
  header = TRUE,
  sep = ";",
  quote = "",
  dec = ",",
  encoding = "unknown",
  ...
)

text_to_columns_tab(
  text,
  header = TRUE,
  sep = "\t",
  quote = "",
  dec = ".",
  encoding = "unknown",
  ...
)

text_to_columns_tab2(
  text,
  header = TRUE,
  sep = "\t",
  quote = "",
  dec = ",",
  encoding = "unknown",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_to_columns_+3A_text">text</code></td>
<td>
<p>character/vector of characters</p>
</td></tr>
<tr><td><code id="text_to_columns_+3A_header">header</code></td>
<td>
<p>a logical value indicating whether the <code>text</code> contains the
names of the variables as its first line.</p>
</td></tr>
<tr><td><code id="text_to_columns_+3A_sep">sep</code></td>
<td>
<p>the field separator character. Values on each line of the file are
separated by this character. If sep = &quot;&quot; (the default for <code>text_to_columns</code>) the
separator is 'white space', that is one or more spaces, tabs, newlines or
carriage returns.</p>
</td></tr>
<tr><td><code id="text_to_columns_+3A_quote">quote</code></td>
<td>
<p>the set of quoting characters. To disable quoting altogether, use quote = &quot;&quot;.</p>
</td></tr>
<tr><td><code id="text_to_columns_+3A_dec">dec</code></td>
<td>
<p>the character used in the file for decimal points.</p>
</td></tr>
<tr><td><code id="text_to_columns_+3A_encoding">encoding</code></td>
<td>
<p>encoding to be assumed for input strings. It is used to mark
character strings as known to be in Latin-1 or UTF-8 (see <a href="utils.html#topic+read.table">read.table</a>).</p>
</td></tr>
<tr><td><code id="text_to_columns_+3A_...">...</code></td>
<td>
<p>further parameters which will be passed to <a href="utils.html#topic+read.table">read.table</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>text_to_columns("
# simple data.frame 
     a b   c
     1 2.5 a
     4 5.5 b
     7 8.5 c
")

</code></pre>

<hr>
<h2 id='unlab'>Drop variable label and value labels</h2><span id='topic+unlab'></span><span id='topic+drop_all_labels'></span>

<h3>Description</h3>

<p><code>unlab</code> returns variable x without variable labels and value labels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unlab(x)

drop_all_labels(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unlab_+3A_x">x</code></td>
<td>
<p>Variable(s). Vector/data.frame/list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>unlab</code> returns original variable x without variable label, value labels and class.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unvr">unvr</a></code> <code><a href="#topic+unvl">unvl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>raw_var = rep(1:2,5)
var_with_lab = set_var_lab(raw_var,"Income")
val_lab(var_with_lab) = c("Low"=1,"High"=2)
identical(raw_var,unlab(var_with_lab)) # should be TRUE
</code></pre>

<hr>
<h2 id='val_lab'>Set or get value labels</h2><span id='topic+val_lab'></span><span id='topic+val_lab+3C-'></span><span id='topic+set_val_lab'></span><span id='topic+add_val_lab'></span><span id='topic+add_val_lab+3C-'></span><span id='topic+unvl'></span><span id='topic+drop_val_labs'></span><span id='topic+make_labels'></span><span id='topic+drop_unused_labels'></span><span id='topic+num_lab'></span><span id='topic+lab_num'></span><span id='topic+autonum'></span>

<h3>Description</h3>

<p>These functions set/get/drop value labels. Duplicated values are not allowed.
If argument <code>x</code> is data.frame or list then labels applied to all 
elements of data.frame/list. To drop value labels, use <code>val_lab(var) &lt;- 
NULL</code> or <code>unvl(var)</code>. <code>make_labels</code> converts text from the form 
that usually used in questionnaires to named vector. For variable labels see
<a href="#topic+var_lab">var_lab</a>. For working with entire data.frame see <a href="#topic+apply_labels">apply_labels</a>.
</p>

<ul>
<li><p><code>val_lab</code> returns value labels or NULL if labels doesn't 
exist. 
</p>
</li>
<li><p><code>val_lab&lt;-</code> set value labels.
</p>
</li>
<li><p><code>set_val_lab</code> returns variable with value labels. 
</p>
</li>
<li><p><code>add_val_lab&lt;-</code> add value labels to already existing value labels. 
</p>
</li>
<li><p><code>unvl</code> drops value labels.
</p>
</li>
<li><p><code>make_labels</code> makes named vector from text for usage as value labels.
</p>
</li>
<li><p><code>num_lab</code>, <code>lab_num</code> and  <code>autonum</code> are shortcuts for <code>make_labels</code>
with <code>code_postion</code> 'left', 'right' and 'autonum' accordingly.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>val_lab(x)

val_lab(x) &lt;- value

set_val_lab(x, value, add = FALSE)

add_val_lab(x, value)

add_val_lab(x) &lt;- value

unvl(x)

drop_val_labs(x)

make_labels(text, code_position = c("left", "right", "autonum"))

drop_unused_labels(x)

num_lab(text)

lab_num(text)

autonum(text)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="val_lab_+3A_x">x</code></td>
<td>
<p>Variable(s). Vector/data.frame/list.</p>
</td></tr>
<tr><td><code id="val_lab_+3A_value">value</code></td>
<td>
<p>Named vector. Names of vector are labels for the
appropriate values of variable x.</p>
</td></tr>
<tr><td><code id="val_lab_+3A_add">add</code></td>
<td>
<p>Logical. Should we add value labels to old labels or replace it?
Deafult is FALSE - we completely replace old values. If TRUE new value
labels will be combined with old value labels.</p>
</td></tr>
<tr><td><code id="val_lab_+3A_text">text</code></td>
<td>
<p>text that should be converted to named vector</p>
</td></tr>
<tr><td><code id="val_lab_+3A_code_position">code_position</code></td>
<td>
<p>Possible values &quot;left&quot;, &quot;right&quot; - position of numeric code in
<code>text</code>. &quot;autonum&quot; - makes codes by autonumbering lines of <code>text</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Value labels are stored in attribute &quot;labels&quot; 
(<code>attr(x,"labels")</code>). We set variable class to &quot;labelled&quot; for preserving
labels from dropping during some operations (such as <code>c</code> and <code>`[`</code>).
</p>


<h3>Value</h3>

<p><code>val_lab</code> return value labels (named vector). If labels doesn't 
exist it return NULL . <code>val_lab&lt;-</code> and <code>set_val_lab</code> return 
variable (vector x) of class &quot;labelled&quot; with attribute &quot;labels&quot; which
contains value labels. <code>make_labels</code> return named vector for usage as
value labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># toy example
data.table::setDTthreads(2)
set.seed(123)
# score - evaluation of tested product

score = sample(-1:1,20,replace = TRUE)
var_lab(score) = "Evaluation of tested brand"
val_lab(score) = c("Dislike it" = -1,
                   "So-so" = 0,
                   "Like it" = 1    
                   )

# frequency of product scores                                      
fre(score)

# brands - multiple response question
# Which brands do you use during last three months? 

brands = as.sheet(t(replicate(20,sample(c(1:5,NA),4,replace = FALSE))))

var_lab(brands) = "Used brands"
val_lab(brands) = make_labels("
                              1 Brand A
                              2 Brand B
                              3 Brand C
                              4 Brand D
                              5 Brand E
                              ")


# percentage of used brands
fre(brands)

# percentage of brands within each score
cro_cpct(brands, score)

## make labels from text copied from questionnaire

age = c(1, 2, 1, 2)

val_lab(age) = num_lab("
 1. 18 - 26
 2. 27 - 35
")

# note support of value lables in base R
table(age)

# or, if in original codes is on the right side

products = 1:8

val_lab(products) = lab_num("
 Chocolate bars    1
 Chocolate sweets (bulk)	2
 Slab chocolate(packed)	3
 Slab chocolate (bulk)	4
 Boxed chocolate sweets	5
 Marshmallow/pastilles in chocolate coating	6
 Marmalade in chocolate coating	7
 Other	8
")

table(products)
</code></pre>

<hr>
<h2 id='values2labels'>Replace vector/matrix/data.frame/list values with corresponding value labels.</h2><span id='topic+values2labels'></span><span id='topic+v2l'></span>

<h3>Description</h3>

<p><code>values2labels</code> replaces vector/matrix/data.frame/list values with
corresponding value labels. If there are no labels for some values they are
converted to characters in most cases. If there are no labels at all for
variable it remains unchanged. <code>v2l</code> is just shortcut to <code>values2labels</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>values2labels(x)

v2l(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="values2labels_+3A_x">x</code></td>
<td>
<p>vector/matrix/data.frame/list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of the same form as x but with value labels instead of values.
</p>


<h3>See Also</h3>

<p><a href="#topic+names2labels">names2labels</a>, <a href="#topic+val_lab">val_lab</a>,  <a href="#topic+var_lab">var_lab</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
var_lab(mtcars$mpg) = NULL
val_lab(mtcars$am) = c(" automatic" = 0, " manual" =  1)

summary(lm(mpg ~ ., data = values2labels(mtcars[,c("mpg","am")])))
</code></pre>

<hr>
<h2 id='var_lab'>Set or get variable label</h2><span id='topic+var_lab'></span><span id='topic+var_lab+3C-'></span><span id='topic+set_var_lab'></span><span id='topic+unvr'></span><span id='topic+drop_var_labs'></span><span id='topic+add_labelled_class'></span>

<h3>Description</h3>

<p>These functions set/get/drop variable labels. For 
value labels see <a href="#topic+val_lab">val_lab</a>. For working with entire data.frame see
<a href="#topic+apply_labels">apply_labels</a>.
</p>

<ul>
<li><p><code>var_lab</code> returns variable label or NULL if label doesn't 
exist. 
</p>
</li>
<li><p><code>var_lab&lt;-</code> set variable label. 
</p>
</li>
<li><p><code>set_var_lab</code> returns variable with label.
</p>
</li>
<li><p><code>unvr</code> drops variable label. 
</p>
</li>
<li><p><code>add_labelled_class</code> Add missing 'labelled' class. This function
is needed when you load SPSS data with packages which in some cases don't set
'labelled' class for variables with labels. For example, <code>haven</code> package
doesn't set 'labelled' class for variables which have variable label but
don't have value labels. Note that to use 'expss' with 'haven' you need to
load 'expss' strictly after 'haven' to avoid conflicts. </p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>var_lab(x, default = NULL)

var_lab(x) &lt;- value

set_var_lab(x, value)

unvr(x)

drop_var_labs(x)

add_labelled_class(
  x,
  remove_classes = c("haven_labelled", "spss_labelled", "haven_labelled_spss",
    "vctrs_vctr")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_lab_+3A_x">x</code></td>
<td>
<p>Variable. In the most cases it is numeric vector.</p>
</td></tr>
<tr><td><code id="var_lab_+3A_default">default</code></td>
<td>
<p>A character scalar. What we want to get from 'var_lab' if
there is no variable label. NULL by default.</p>
</td></tr>
<tr><td><code id="var_lab_+3A_value">value</code></td>
<td>
<p>A character scalar - label for the variable x.</p>
</td></tr>
<tr><td><code id="var_lab_+3A_remove_classes">remove_classes</code></td>
<td>
<p>A character vector of classes which should be removed
from the class attribute of the <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Variable label is stored in attribute &quot;label&quot; (<code>attr(x,"label")</code>). For
preserving from dropping this attribute during some operations (such as <code>c</code>)
variable class is set to &quot;labelled&quot;. There are special methods of
subsetting and concatenation for this class. To drop variable label use 
<code>var_lab(var) &lt;- NULL</code> or <code>unvr(var)</code>.
</p>


<h3>Value</h3>

<p><code>var_lab</code> return variable label. If label doesn't exist it return
NULL . <code>var_lab&lt;-</code> and <code>set_var_lab</code> return variable (vector x)
of class &quot;labelled&quot; with attribute &quot;label&quot; which equals submitted value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
var_lab(mtcars$mpg) = "Miles/(US) gallon"
var_lab(mtcars$cyl) = "Number of cylinders"
var_lab(mtcars$disp) = "Displacement (cu.in.)"
var_lab(mtcars$hp) = "Gross horsepower"
var_lab(mtcars$drat) = "Rear axle ratio"
var_lab(mtcars$wt) = "Weight (lb/1000)"
var_lab(mtcars$qsec) = "1/4 mile time"
var_lab(mtcars$vs) = "V/S"
var_lab(mtcars$am) = "Transmission (0 = automatic, 1 = manual)"
val_lab(mtcars$am) = c(automatic = 0, manual=1)
var_lab(mtcars$gear) = "Number of forward gears"
var_lab(mtcars$carb) = "Number of carburetors"

fre(mtcars$am)

cross_mean(mtcars, list(mpg, disp, hp, qsec), list(total(), am))
 
## Not run: 
if(FALSE){ # to prevent execution
# you need to load packages strictly in this order to avoid conflicts
library(haven)
library(expss)
spss_data = haven::read_spss("spss_file.sav")
# add missing 'labelled' class
spss_data = add_labelled_class(spss_data) 
}

## End(Not run)
</code></pre>

<hr>
<h2 id='vars'>Get variables/range of variables by name/by pattern.</h2><span id='topic+vars'></span><span id='topic+vars_list'></span><span id='topic+indirect'></span><span id='topic+indirect_list'></span><span id='topic++25to+25'></span><span id='topic++25to_list+25'></span><span id='topic+..'></span><span id='topic+..f'></span><span id='topic+..p'></span><span id='topic+..t'></span>

<h3>Description</h3>


<ul>
<li><p><code>vars</code> returns data.frame with all variables by their names or
by criteria (see <a href="#topic+criteria">criteria</a>). There is no non-standard evaluation in
this function by design so use quotes for names of your variables. This
function is intended to get variables by parameter/criteria. The only
exception with non-standard evaluation is <code>%to%</code>. You can use
<code>%to%</code> inside <code>vars</code> or independently.
</p>
</li>
<li><p><code>..p</code> returns data.frame with all variables which names satisfy
supplied perl-style regular expression. Arguments for this function is quoted
characters. It is a shortcut for <code>vars(perl(pattern))</code>.
</p>
</li>
<li><p><code>..f</code> returns data.frame with all variables which names contain
supplied pattern. Arguments for this function can be unquoted. It is a
shortcut for <code>vars(fixed(pattern))</code>.
</p>
</li>
<li><p><code>..t</code> returns data.frame with variables which names are stored
in the supplied arguments. Expressions in characters in curly brackets are
expanded. See <a href="maditr.html#topic+text_expand">text_expand</a>.
</p>
</li>
<li><p><code>..[]</code> returns data.frame with all variables by their names or 
by criteria (see <a href="#topic+criteria">criteria</a>).  Names at the top-level can be unquoted 
(non-standard evaluation). For standard evaluation of parameters you can 
surround them by round brackets. You can assign to this expression. If there 
are several names inside square brackets then each element of list/data.frame
from right side will be assigned to appropriate name from left side. You can 
use <code>item1 %to% item2</code> notation to get/create sequence of variables. 
If there are no arguments inside square brackets than from each item of RHS 
will be created separate variable in the parent frame. In this case RHS
should be named list or data.frame. 
</p>
</li>
<li><p><code>..$name</code> sets/returns object which name is stored in the
variable <code>name</code>. It is convenient wrapper around 
<a href="base.html#topic+get">get</a>/<a href="base.html#topic+assign">assign</a> functions.
</p>
</li>
<li><p><code>%to%</code> returns range of variables between <code>e1</code> and 
<code>e2</code> (similar to SPSS 'to').
</p>
</li>
<li><p><code>indirect</code>/<code>indirect_list</code> are aliases for
<code>vars</code>/<code>vars_list</code>.
</p>
</li></ul>

<p>Functions with word 'list' in name return lists of variables instead of 
dataframes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vars(...)

vars_list(...)

indirect(...)

indirect_list(...)

e1 %to% e2

e1 %to_list% e2

..

..f(...)

..p(...)

..t(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vars_+3A_...">...</code></td>
<td>
<p>characters names of variables or criteria/logical functions</p>
</td></tr>
<tr><td><code id="vars_+3A_e1">e1</code></td>
<td>
<p>unquoted name of start variable (e. g. a_1)</p>
</td></tr>
<tr><td><code id="vars_+3A_e2">e2</code></td>
<td>
<p>unquoted name of start variable (e. g. a_5)</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>parameter</code> of length 1.
</p>


<h3>Value</h3>

<p>data.frame/list with variables
</p>

<hr>
<h2 id='vectors'>Infix operations on vectors - append, diff, intersection, union, replication</h2><span id='topic+vectors'></span><span id='topic++25a+25'></span><span id='topic+v_union'></span><span id='topic++25u+25'></span><span id='topic+v_diff'></span><span id='topic++25d+25'></span><span id='topic+v_intersect'></span><span id='topic++25i+25'></span><span id='topic+v_xor'></span><span id='topic++25e+25'></span><span id='topic++25r+25'></span><span id='topic+n_intersect'></span><span id='topic++25n_i+25'></span><span id='topic+n_diff'></span><span id='topic++25n_d+25'></span>

<h3>Description</h3>

<p>All these functions except <code>%n_d%</code>, <code>%n_i%</code> preserve names of
vectors and don't remove duplicates.
</p>

<ul>
<li><p><code>%a%</code> a(ppends) second argument to the first argument. See also
<a href="base.html#topic+append">append</a>.
</p>
</li>
<li><p><code>%u%</code> and <code>v_union</code> u(nite) first and second arguments.
Remove elements from the second argument which exist in the first argument. 
</p>
</li>
<li><p><code>%d%</code> and <code>v_diff</code> d(iff) second argument from the first
argument. Second argument could be a function which returns logical value. In
this case elements of the first argument which give TRUE will be removed. 
</p>
</li>
<li><p><code>%i%</code> and <code>v_intersect</code> i(ntersect) first argument and
second argument. Second argument could be a function which returns logical
value. In this case elements of the first argument which give FALSE will be
removed. 
</p>
</li>
<li><p><code>%e%</code> and <code>v_xor</code> e(xclusive OR). Returns elements that
contained only in one of arguments.
</p>
</li>
<li><p><code>%r%</code>  r(epeats) first argument second argument times. See
also <a href="base.html#topic+rep">rep</a>.
</p>
</li>
<li><p><code>%n_d%</code> and <code>n_diff</code> n(ames) d(iff) - diff second argument
from names of first argument. Second argument could be a function which
returns logical value. In this case elements of the first argument which names
give TRUE will be removed. 
</p>
</li>
<li><p><code>%n_i%</code> and <code>n_intersect</code> n(ames) i(ntersect) - intersect
names of the first argument with the second argument. Second argument could be a
function which returns logical value. In this case elements of the first argument
which names give FALSE will be removed. 
</p>
</li></ul>
 
<p>For <code>%d%</code>, <code>%i%</code>, <code>%n_d%</code>, <code>%n_i%</code> one can use
criteria functions. See <a href="#topic+criteria">criteria</a> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e1 %a% e2

v_union(e1, e2)

e1 %u% e2

v_diff(e1, e2)

e1 %d% e2

v_intersect(e1, e2)

e1 %i% e2

v_xor(e1, e2)

e1 %e% e2

e1 %r% e2

n_intersect(e1, e2)

e1 %n_i% e2

n_diff(e1, e2)

e1 %n_d% e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vectors_+3A_e1">e1</code></td>
<td>
<p>vector or data.frame, matrix, list for <code>%n_d%</code>, <code>%n_i%</code>)</p>
</td></tr>
<tr><td><code id="vectors_+3A_e2">e2</code></td>
<td>
<p>vector or function for <code>%d%</code>, <code>%i%</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector or data.frame, matrix, list for <code>%n_d%</code>, <code>%n_i%</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
1:4 %a% 5:6   # 1:6

1:4 %a% 4:5   # 1,2,3,4,4,5

1:4 %u% 4:5   # 1,2,3,4,5

1:6 %d% 5:6   # 1:4

# function as criterion
1:6 %d% greater(4) # 1:4

1:4 %i% 4:5   # 4

# with criteria functions 
letters %i% (contains("a") | contains("z")) # a, z

letters %i% perl("[a-d]") # a,b,c,d

1:4 %e% 4:5   # 1, 2, 3, 5

1:2 %r% 2     # 1, 2, 1, 2

# %n_i%, %n_d%

# remove column Species
iris %n_d% "Species" 

# leave only columns which names start with "Sepal"
iris %n_i% like("Sepal*") 

# leave column "Species" and columns which names start with "Sepal" 
iris %n_i% ("Species" | like("Sepal*")) 
iris %n_i% or("Species", like("Sepal*")) # same result

</code></pre>

<hr>
<h2 id='w_mean'>Compute various weighted statistics</h2><span id='topic+w_mean'></span><span id='topic+w_median'></span><span id='topic+w_var'></span><span id='topic+w_sd'></span><span id='topic+w_se'></span><span id='topic+w_mad'></span><span id='topic+w_sum'></span><span id='topic+w_n'></span><span id='topic+unweighted_valid_n'></span><span id='topic+valid_n'></span><span id='topic+w_max'></span><span id='topic+w_min'></span><span id='topic+w_cov'></span><span id='topic+w_cor'></span><span id='topic+w_pearson'></span><span id='topic+w_spearman'></span>

<h3>Description</h3>


<ul>
<li><p><code>w_mean</code> weighted mean of a numeric vector
</p>
</li>
<li><p><code>w_sd</code> weighted sample standard deviation of a numeric vector
</p>
</li>
<li><p><code>w_var</code> weighted sample variance of a numeric vector
</p>
</li>
<li><p><code>w_se</code> weighted standard error of a numeric vector
</p>
</li>
<li><p><code>w_median</code> weighted median of a numeric vector
</p>
</li>
<li><p><code>w_mad</code> weighted mean absolute deviation from median of a numeric vector
</p>
</li>
<li><p><code>w_sum</code> weighted sum of a numeric vector
</p>
</li>
<li><p><code>w_n</code> weighted number of values of a numeric vector
</p>
</li>
<li><p><code>w_cov</code> weighted covariance matrix of a numeric matrix/data.frame
</p>
</li>
<li><p><code>w_cor</code> weighted Pearson correlation matrix of a numeric matrix/data.frame
</p>
</li>
<li><p><code>w_pearson</code> shortcut for <code>w_cor</code>. Weighted Pearson
correlation matrix of a numeric matrix/data.frame
</p>
</li>
<li><p><code>w_spearman</code> weighted Spearman correlation matrix of a numeric matrix/data.frame
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>w_mean(x, weight = NULL, na.rm = TRUE)

w_median(x, weight = NULL, na.rm = TRUE)

w_var(x, weight = NULL, na.rm = TRUE)

w_sd(x, weight = NULL, na.rm = TRUE)

w_se(x, weight = NULL, na.rm = TRUE)

w_mad(x, weight = NULL, na.rm = TRUE)

w_sum(x, weight = NULL, na.rm = TRUE)

w_n(x, weight = NULL, na.rm = TRUE)

unweighted_valid_n(x, weight = NULL)

valid_n(x, weight = NULL)

w_max(x, weight = NULL, na.rm = TRUE)

w_min(x, weight = NULL, na.rm = TRUE)

w_cov(x, weight = NULL, use = c("pairwise.complete.obs", "complete.obs"))

w_cor(x, weight = NULL, use = c("pairwise.complete.obs", "complete.obs"))

w_pearson(x, weight = NULL, use = c("pairwise.complete.obs", "complete.obs"))

w_spearman(x, weight = NULL, use = c("pairwise.complete.obs", "complete.obs"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="w_mean_+3A_x">x</code></td>
<td>
<p>a numeric vector (matrix/data.frame for correlations) containing the
values whose weighted statistics is to be computed.</p>
</td></tr>
<tr><td><code id="w_mean_+3A_weight">weight</code></td>
<td>
<p>a vector of weights to use for each element of x. Cases with
missing, zero or negative weights will be removed before calculations. If
<code>weight</code> is missing then unweighted statistics will be computed.</p>
</td></tr>
<tr><td><code id="w_mean_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped
before the computation proceeds. Note that contrary to base R statistic
functions the default value is TRUE (remove missing values).</p>
</td></tr>
<tr><td><code id="w_mean_+3A_use">use</code></td>
<td>
<p><code>"pairwise.complete.obs"</code> (default) or <code>"complete.obs"</code>.
In the first case  the correlation or covariance between each pair of
variables is computed using all complete pairs of observations on those
variables. If <code>use</code> is <code>"complete.obs"</code> then missing values are
handled by casewise deletion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If argument of correlation functions is data.frame with variable labels then
variables names will be replaced with labels. If this is undesirable behavior
use <a href="#topic+drop_var_labs">drop_var_labs</a> function: <code>w_cor(drop_var_labs(x))</code>. Weighted
Spearman correlation coefficients are calculated with weights rounded to nearest
integer. It gives the same result as in SPSS Statistics software. By
now this algorithm is not memory efficient.
</p>


<h3>Value</h3>

<p>a numeric value of length one/correlation matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
dfs = mtcars %&gt;% columns(mpg, disp, hp, wt)

with(dfs, w_mean(hp, weight = 1/wt))

# apply labels
mtcars = mtcars %&gt;% 
    apply_labels(
        mpg = "Miles/(US) gallon",
        cyl = "Number of cylinders",
        disp = "Displacement (cu.in.)",
        hp = "Gross horsepower",
        drat = "Rear axle ratio",
        wt = "Weight (lb/1000)",
        qsec = "1/4 mile time",
        vs = "Engine",
        vs = c("V-engine" = 0, 
                "Straight engine" = 1),
        am = "Transmission",
        am = c(automatic = 0, 
                manual=1),
        gear = "Number of forward gears",
        carb = "Number of carburetors"
    )

# weighted correlations with labels
w_cor(dfs, weight = 1/dfs$wt)

# without labels
w_cor(drop_var_labs(dfs), weight = 1/dfs$wt)
</code></pre>

<hr>
<h2 id='weight_by'>Create dataset according to its frequency weights</h2><span id='topic+weight_by'></span>

<h3>Description</h3>

<p>This is a &quot;brute force&quot; weighting procedure. Each row of the dataset is
replicated &quot;case weight&quot; times. If 'weight' is not integer it will
be rounded to the nearest integer. So cases with weight less than 0.5 will be
removed from the dataset. Such weighting is used in the several statistical
procedures in the SPSS Statistic, e. g. for the Spearman correlation
coefficient or GLM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weight_by(data, weight = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weight_by_+3A_data">data</code></td>
<td>
<p>data.frame, data.table or matrix. Dataset which will be weighted.</p>
</td></tr>
<tr><td><code id="weight_by_+3A_weight">weight</code></td>
<td>
<p>unquoted column name of weights in 'data' or vector of weights.
If it is NULL 'data' will be returned unchanged.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'data' with each row replicated according to case weight.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(state) # US states
# convert matrix to data.table
states = data.table(state.x77, keep.rownames = "State")

# create weighted dataset
states_weighted = states %&gt;% 
    let(
        # calculate 'weight' variable. 
        weight = Population/100
    ) %&gt;% 
    weight_by(weight)

# Each row in the weighted dataset is represented proportionally to the population of the state
nrow(states) # unweigthed number of cases
nrow(states_weighted) # number of cases in the weighted dataset
str(states_weighted)
</code></pre>

<hr>
<h2 id='where'>Subset (filter) data.frames/matrices/vectors/lists</h2><span id='topic+where'></span>

<h3>Description</h3>

<p>For the data frame <code>cond</code> will be evaluated in the data.frame's context.
So columns can be referred as variables in the expression (see the examples).
If <code>data</code> is list then <code>where</code> will be applied to each element of 
the list. For other types (vector/matrix) there is no non-standard
evaluation. There is a special constant <code>.N</code> which equals to number of
rows in <code>data</code> for usage in <code>cond</code> expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>where(data, cond)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="where_+3A_data">data</code></td>
<td>
<p>data.frame/matrix/vector/list to be subsetted</p>
</td></tr>
<tr><td><code id="where_+3A_cond">cond</code></td>
<td>
<p>logical or numeric expression indicating elements or rows to 
keep: missing values (NA) are taken as FALSE. If <code>data</code> is data.frame
then <code>cond</code> will be evaluated in the scope of the <code>data</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame/matrix/vector/list which contains just selected rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># leave only 'setosa'
rows(iris, Species == "setosa")
# leave only first five rows
rows(iris, 1:5)


# example of .N usage. 
set.seed(42)
train = rows(iris, sample(.N, 100))
str(train)

set.seed(42)
test = rows(iris, -sample(.N, 100))
str(test)

</code></pre>

<hr>
<h2 id='window_fun'>Function over grouping variables (window function)</h2><span id='topic+window_fun'></span>

<h3>Description</h3>

<p>This is faster version of <a href="stats.html#topic+ave">ave</a>. <code>window_fun</code> applies function
to every subset of <code>x</code> and return vector of the same length as <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>window_fun(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="window_fun_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="window_fun_+3A_...">...</code></td>
<td>
<p>Grouping variables all of the same length as x or length 1 and
function as last argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of the same length as <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>window_fun(1:3, mean)  # no grouping -&gt; grand mean

attach(warpbreaks)

window_fun(breaks, wool, mean)
window_fun(breaks, tension, function(x) mean(x, trim = 0.1))

detach(warpbreaks)
</code></pre>

<hr>
<h2 id='write_labelled_csv'>Write labelled data to file or export file to SPSS syntax.</h2><span id='topic+write_labelled_csv'></span><span id='topic+write_labelled_csv2'></span><span id='topic+write_labelled_tab'></span><span id='topic+write_labelled_tab2'></span><span id='topic+write_labelled_xlsx'></span><span id='topic+write_labelled_fst'></span><span id='topic+read_labelled_csv'></span><span id='topic+read_labelled_csv2'></span><span id='topic+read_labelled_tab'></span><span id='topic+read_labelled_tab2'></span><span id='topic+read_labelled_xlsx'></span><span id='topic+read_labelled_fst'></span><span id='topic+write_labelled_spss'></span><span id='topic+write_labels_spss'></span><span id='topic+write_labels'></span><span id='topic+create_dictionary'></span><span id='topic+apply_dictionary'></span><span id='topic+old_write_labelled_csv'></span><span id='topic+old_read_labelled_csv'></span>

<h3>Description</h3>


<ul>
<li><p><code>write_labelled_csv</code> and <code>read_labelled_csv</code> writes csv
file with labels. By default labels are stored in the commented lines at the
beginning of the file before the data part. <code>*_csv2</code> write and read data
with a semicolon separator and comma as decimal delimiter. <code>*_tab/*_tab2</code>
write and read data with 'tab' separator and &quot;.&quot;/&quot;,&quot; as decimal delimiter. 
</p>
</li>
<li><p><code>write_labelled_xlsx</code> and <code>read_labelled_xlsx</code> write and
read labelled 'xlsx' format. It is a simple Excel file with data and labels on
separate sheets. It can help you with labelled data exchange in the
corporate environment.
</p>
</li>
<li><p><code>write_labelled_fst</code> and <code>read_labelled_fst</code> write and read
labelled data in the 'fst' format. See <a href="https://www.fstpackage.org/">Fst Package</a>.
Data and labels are stored in the separate files. With 'fst' format you can
read and write a huge amount of data very quickly.
</p>
</li>
<li><p>write_labelled_spss write 'csv' file with SPSS syntax for reading it.
You can use it for the data exchange with SPSS.
</p>
</li>
<li><p><code>create_dictionary</code> and <code>apply_dictionary</code> make data.frame
with dictionary, e. g. variable and value labels for each variable. See
format description in the 'Details' section.
</p>
</li>
<li><p><code>write_labels</code> and <code>write_labels_spss</code> Write R code and
SPSS syntax for labelling data. It allows to extract labels from *.sav files
that come without accompanying syntax. 
</p>
</li>
<li><p><code>old_write_labelled_csv</code> and <code>old_read_labelled_csv</code> Read
and write labelled 'csv' in format of the 'expss' version before 0.9.0.

</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>write_labelled_csv(
  x,
  filename,
  remove_new_lines = TRUE,
  single_file = TRUE,
  ...
)

write_labelled_csv2(
  x,
  filename,
  remove_new_lines = TRUE,
  single_file = TRUE,
  ...
)

write_labelled_tab(
  x,
  filename,
  remove_new_lines = TRUE,
  single_file = TRUE,
  ...
)

write_labelled_tab2(
  x,
  filename,
  remove_new_lines = TRUE,
  single_file = TRUE,
  ...
)

write_labelled_xlsx(
  x,
  filename,
  data_sheet = "data",
  dict_sheet = "dictionary",
  remove_repeated = FALSE,
  use_references = TRUE
)

write_labelled_fst(x, filename, ...)

read_labelled_csv(filename, undouble_quotes = TRUE, ...)

read_labelled_csv2(filename, undouble_quotes = TRUE, ...)

read_labelled_tab(filename, undouble_quotes = TRUE, ...)

read_labelled_tab2(filename, undouble_quotes = TRUE, ...)

read_labelled_xlsx(filename, data_sheet = 1, dict_sheet = "dictionary")

read_labelled_fst(filename, ...)

write_labelled_spss(
  x,
  filename,
  fileEncoding = "",
  remove_new_lines = TRUE,
  ...
)

write_labels_spss(x, filename)

write_labels(x, filename, fileEncoding = "")

create_dictionary(x, remove_repeated = FALSE, use_references = TRUE)

apply_dictionary(x, dict)

old_write_labelled_csv(
  x,
  filename,
  fileEncoding = "",
  remove_new_lines = TRUE,
  ...
)

old_read_labelled_csv(filename, fileEncoding = "", undouble_quotes = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_labelled_csv_+3A_x">x</code></td>
<td>
<p>data.frame to be written/data.frame whose labels to be written</p>
</td></tr>
<tr><td><code id="write_labelled_csv_+3A_filename">filename</code></td>
<td>
<p>the name of the file which the data are to be read from/write to.</p>
</td></tr>
<tr><td><code id="write_labelled_csv_+3A_remove_new_lines">remove_new_lines</code></td>
<td>
<p>A logical indicating should we replace new lines with spaces in
the character variables. TRUE by default.</p>
</td></tr>
<tr><td><code id="write_labelled_csv_+3A_single_file">single_file</code></td>
<td>
<p>logical. TRUE by default. Should we write labels into the
same file as data? If it is FALSE dictionary will be written in the
separate file.</p>
</td></tr>
<tr><td><code id="write_labelled_csv_+3A_...">...</code></td>
<td>
<p>additional arguments for
<a href="data.table.html#topic+fwrite">fwrite</a>/<a href="data.table.html#topic+fread">fread</a>, e. g. column separator,
decimal separator, encoding and etc.</p>
</td></tr>
<tr><td><code id="write_labelled_csv_+3A_data_sheet">data_sheet</code></td>
<td>
<p>character &quot;data&quot; by default. Where data will be placed in the '*.xlsx' file.</p>
</td></tr>
<tr><td><code id="write_labelled_csv_+3A_dict_sheet">dict_sheet</code></td>
<td>
<p>character &quot;dictionary&quot; by default. Where dictionary will be placed in the '*.xlsx' file.</p>
</td></tr>
<tr><td><code id="write_labelled_csv_+3A_remove_repeated">remove_repeated</code></td>
<td>
<p>logical. FALSE by default. If TRUE then we remove
repeated variable names. It makes a dictionary to look nicer for humans but
less convenient for usage.</p>
</td></tr>
<tr><td><code id="write_labelled_csv_+3A_use_references">use_references</code></td>
<td>
<p>logical. When TRUE (default) then if the variable has
the same value labels as the previous variable, we use reference to this
variable. It makes dictionary significantly more compact for datasets
with many variables with the same value labels.</p>
</td></tr>
<tr><td><code id="write_labelled_csv_+3A_undouble_quotes">undouble_quotes</code></td>
<td>
<p>A logical indicating should we undouble quotes which
were escaped by doubling. TRUE by default. Argument
will be removed when data.table issue #1109 will be fixed.</p>
</td></tr>
<tr><td><code id="write_labelled_csv_+3A_fileencoding">fileEncoding</code></td>
<td>
<p>character string: if non-empty declares the encoding to 
be used on a file (not a connection) so the character data can be 
re-encoded as they are written. Used for writing dictionary. See
<a href="base.html#topic+connections">file</a>.</p>
</td></tr>
<tr><td><code id="write_labelled_csv_+3A_dict">dict</code></td>
<td>
<p>data.frame with labels - a result of <code>create_dictionary</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Dictionary is a data.frame with the following columns:
</p>

<ul>
<li><p>variable variable name in the data set. It can be omitted
(<code>NA</code>). In this case name from the previous row will be taken.
</p>
</li>
<li><p>value code for label in the column <code>'label'</code>.
</p>
</li>
<li><p>label in most cases it is value label but its meaning can be changed
by the column <code>'meta'</code>.
</p>
</li>
<li><p>meta if it is NA then we have value label in the <code>'label'</code>
column. If it is <code>'varlab'</code>, then there is a variable label in the
<code>'label'</code> column and column <code>'value'</code> is ignored. If it is
<code>'reference'</code>, then there is a variable name in the <code>'label'</code>
column and we use value labels from this variable, column <code>'value'</code> is
ignored.
</p>
</li></ul>



<h3>Value</h3>

<p>Functions for writing invisibly return NULL. Functions for reading
return labelled data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(mtcars)
mtcars = mtcars %&gt;% 
    apply_labels(
        mpg = "Miles/(US) gallon",
        cyl = "Number of cylinders",
        disp = "Displacement (cu.in.)",
        hp = "Gross horsepower",
        drat = "Rear axle ratio",
        wt = "Weight (lb/1000)",
        qsec = "1/4 mile time",
        vs = "Engine",
        vs = c("V-engine" = 0, 
                "Straight engine" = 1),
        am = "Transmission",
        am = c(automatic = 0, 
                manual=1),
        gear = "Number of forward gears",
        carb = "Number of carburetors"
    )

write_labelled_csv(mtcars, "mtcars.csv")
new_mtcars = read_labelled_csv("mtcars.csv")
str(new_mtcars)

# identically, for xlsx
write_labelled_xlsx(mtcars, "mtcars.xlsx")
new_mtcars = read_labelled_xlsx("mtcars.xlsx")
str(new_mtcars)

# to SPSS syntax
write_labelled_spss(mtcars, "mtcars.csv")


## End(Not run)
</code></pre>

<hr>
<h2 id='xl_write'>Write tables and other objects to an xlsx file with formatting</h2><span id='topic+xl_write'></span><span id='topic+xl_write_file'></span><span id='topic+xl_write.default'></span><span id='topic+xl_write.list'></span><span id='topic+xl_write.etable'></span><span id='topic+xl_write.with_caption'></span>

<h3>Description</h3>

<p>Note that <code>openxlsx</code> package is required for these functions. It can be
install by printing <code>install.packages('openxlsx')</code> in the console. On
Windows system you also may need to
install <a href="https://cran.r-project.org/bin/windows/Rtools/">rtools</a>. You
can export several tables at once by combining them in a list. See examples.
If you need to write all tables to the single sheet you can use
<code>xl_write_file</code>. It automatically creates workbook, worksheet and save
*.xlsx file for you.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xl_write(obj, wb, sheet, row = 1, col = 1, ...)

xl_write_file(obj, filename, sheetname = "Tables", ...)

## Default S3 method:
xl_write(
  obj,
  wb,
  sheet,
  row = 1,
  col = 1,
  rownames = FALSE,
  colnames = !is.atomic(obj),
  ...
)

## S3 method for class 'list'
xl_write(obj, wb, sheet, row = 1, col = 1, gap = 1, ...)

## S3 method for class 'etable'
xl_write(
  obj,
  wb,
  sheet,
  row = 1,
  col = 1,
  remove_repeated = c("all", "rows", "columns", "none"),
  format_table = TRUE,
  borders = list(borderColour = "black", borderStyle = "thin"),
  header_format = openxlsx::createStyle(fgFill = "#EBEBEB", halign = "left", wrapText =
    FALSE),
  main_format = openxlsx::createStyle(halign = "right", numFmt = format(0, nsmall =
    get_expss_digits())),
  row_labels_format = openxlsx::createStyle(halign = "left"),
  total_format = openxlsx::createStyle(fgFill = "#EBEBEB", border = "TopBottom",
    borderStyle = "thin", halign = "right", numFmt = "0"),
  total_row_labels_format = openxlsx::createStyle(fgFill = "#EBEBEB", border =
    "TopBottom", borderStyle = "thin", halign = "left"),
  top_left_corner_format = header_format,
  row_symbols_to_remove = NULL,
  col_symbols_to_remove = NULL,
  other_rows_formats = NULL,
  other_row_labels_formats = NULL,
  other_cols_formats = NULL,
  other_col_labels_formats = NULL,
  additional_cells_formats = NULL,
  ...
)

## S3 method for class 'with_caption'
xl_write(
  obj,
  wb,
  sheet,
  row = 1,
  col = 1,
  remove_repeated = c("all", "rows", "columns", "none"),
  format_table = TRUE,
  borders = list(borderColour = "black", borderStyle = "thin"),
  header_format = openxlsx::createStyle(fgFill = "#EBEBEB", halign = "left", wrapText =
    FALSE),
  main_format = openxlsx::createStyle(halign = "right", numFmt = format(0, nsmall =
    get_expss_digits())),
  row_labels_format = openxlsx::createStyle(halign = "left"),
  total_format = openxlsx::createStyle(fgFill = "#EBEBEB", border = "TopBottom",
    borderStyle = "thin", halign = "right", numFmt = "0"),
  total_row_labels_format = openxlsx::createStyle(fgFill = "#EBEBEB", border =
    "TopBottom", borderStyle = "thin", halign = "left"),
  top_left_corner_format = header_format,
  row_symbols_to_remove = NULL,
  col_symbols_to_remove = NULL,
  other_rows_formats = NULL,
  other_row_labels_formats = NULL,
  other_cols_formats = NULL,
  other_col_labels_formats = NULL,
  additional_cells_formats = NULL,
  caption_format = openxlsx::createStyle(textDecoration = "bold", halign = "left"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xl_write_+3A_obj">obj</code></td>
<td>
<p><code>table</code> - result of <a href="#topic+cro">cro</a>, <a href="#topic+fre">fre</a> and etc.
<code>obj</code> also can be data.frame, list or other objects.</p>
</td></tr>
<tr><td><code id="xl_write_+3A_wb">wb</code></td>
<td>
<p>xlsx workbook object, result of <a href="openxlsx.html#topic+createWorkbook">createWorkbook</a> function.</p>
</td></tr>
<tr><td><code id="xl_write_+3A_sheet">sheet</code></td>
<td>
<p>character or numeric - worksheet name/number in the workbook <code>wb</code></p>
</td></tr>
<tr><td><code id="xl_write_+3A_row">row</code></td>
<td>
<p>numeric - starting row for writing data</p>
</td></tr>
<tr><td><code id="xl_write_+3A_col">col</code></td>
<td>
<p>numeric - starting column for writing data</p>
</td></tr>
<tr><td><code id="xl_write_+3A_...">...</code></td>
<td>
<p>further arguments for <code>xl_write</code></p>
</td></tr>
<tr><td><code id="xl_write_+3A_filename">filename</code></td>
<td>
<p>A character string naming an xlsx file. For <code>xl_write_file</code>.</p>
</td></tr>
<tr><td><code id="xl_write_+3A_sheetname">sheetname</code></td>
<td>
<p>A character name for the worksheet. For <code>xl_write_file</code>.</p>
</td></tr>
<tr><td><code id="xl_write_+3A_rownames">rownames</code></td>
<td>
<p>logical should we write data.frame row names?</p>
</td></tr>
<tr><td><code id="xl_write_+3A_colnames">colnames</code></td>
<td>
<p>logical should we write data.frame column names?</p>
</td></tr>
<tr><td><code id="xl_write_+3A_gap">gap</code></td>
<td>
<p>integer. Number of rows between list elements.</p>
</td></tr>
<tr><td><code id="xl_write_+3A_remove_repeated">remove_repeated</code></td>
<td>
<p>Should we remove duplicated row or column labels in
the rows/columns of the etable? Possible values: &quot;all&quot;, &quot;rows&quot;, &quot;columns&quot;, &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="xl_write_+3A_format_table">format_table</code></td>
<td>
<p>logical should we format table? If FALSE all format arguments will be ignored.</p>
</td></tr>
<tr><td><code id="xl_write_+3A_borders">borders</code></td>
<td>
<p>list Style of the table borders. List with two named elements:
<code>borderColour</code> and <code>borderStyle</code>. For details see
<a href="openxlsx.html#topic+createStyle">createStyle</a> function. If it is NULL then no table borders will
be produced.</p>
</td></tr>
<tr><td><code id="xl_write_+3A_header_format">header_format</code></td>
<td>
<p>table header format - result of the <a href="openxlsx.html#topic+createStyle">createStyle</a> function.</p>
</td></tr>
<tr><td><code id="xl_write_+3A_main_format">main_format</code></td>
<td>
<p>result of the <a href="openxlsx.html#topic+createStyle">createStyle</a> function.
Format of the table main area except total rows. Total rows is rows which
row labels contain '#'.</p>
</td></tr>
<tr><td><code id="xl_write_+3A_row_labels_format">row_labels_format</code></td>
<td>
<p>result of the <a href="openxlsx.html#topic+createStyle">createStyle</a> function.
Format of the row labels area except total rows. Total rows is rows which
row labels contain '#'.</p>
</td></tr>
<tr><td><code id="xl_write_+3A_total_format">total_format</code></td>
<td>
<p>result of the <a href="openxlsx.html#topic+createStyle">createStyle</a> function.
Format of the total rows in the table main area. Total rows is rows which
row labels contain '#'.</p>
</td></tr>
<tr><td><code id="xl_write_+3A_total_row_labels_format">total_row_labels_format</code></td>
<td>
<p>result of the <a href="openxlsx.html#topic+createStyle">createStyle</a> function.
Format of the total rows in the row labels area. Total rows is rows which
row labels contain '#'.</p>
</td></tr>
<tr><td><code id="xl_write_+3A_top_left_corner_format">top_left_corner_format</code></td>
<td>
<p>result of the <a href="openxlsx.html#topic+createStyle">createStyle</a> function.</p>
</td></tr>
<tr><td><code id="xl_write_+3A_row_symbols_to_remove">row_symbols_to_remove</code></td>
<td>
<p>character vector. Perl-style regular expressions
for substrings which will be removed from row labels.</p>
</td></tr>
<tr><td><code id="xl_write_+3A_col_symbols_to_remove">col_symbols_to_remove</code></td>
<td>
<p>character vector. Perl-style regular expressions
for substrings  which will be removed from column names.</p>
</td></tr>
<tr><td><code id="xl_write_+3A_other_rows_formats">other_rows_formats</code></td>
<td>
<p>named list. Names of the list are perl-style
regular expression patterns, items of the list are results of the
<a href="openxlsx.html#topic+createStyle">createStyle</a> function. Rows in the main area which row
labels contain pattern will be formatted according to the appropriate style.</p>
</td></tr>
<tr><td><code id="xl_write_+3A_other_row_labels_formats">other_row_labels_formats</code></td>
<td>
<p>named list. Names of the list are perl-style
regular expression patterns, items of the list are results of the
<a href="openxlsx.html#topic+createStyle">createStyle</a> function. Rows in the row labels area which row
labels contain pattern will be formatted according to the appropriate style.</p>
</td></tr>
<tr><td><code id="xl_write_+3A_other_cols_formats">other_cols_formats</code></td>
<td>
<p>named list. Names of the list are perl-style
regular expression patterns, items of the list are results of the
<a href="openxlsx.html#topic+createStyle">createStyle</a> function. Columns in the main area which column
labels contain pattern will be formatted according to the appropriate style.</p>
</td></tr>
<tr><td><code id="xl_write_+3A_other_col_labels_formats">other_col_labels_formats</code></td>
<td>
<p>named list. Names of the list are perl-style
regular expression patterns, items of the list are results of the
<a href="openxlsx.html#topic+createStyle">createStyle</a> function. Columns in the header area which column
labels contain pattern will be formatted according to the appropriate style.</p>
</td></tr>
<tr><td><code id="xl_write_+3A_additional_cells_formats">additional_cells_formats</code></td>
<td>
<p>list Each item of the list is list which
consists of two elements. First element is two columns matrix or data.frame
with row number and column numbers in the main area of the table. Such
matrix can be produced with code <code>which(logical_condition, arr.ind =
TRUE)</code>. Instead of matrix one can use function which accepts original table
(<code>obj</code>) and return such matrix. Second element is result of the
<a href="openxlsx.html#topic+createStyle">createStyle</a> function. Cells in the main area will be
formatted according to this style.</p>
</td></tr>
<tr><td><code id="xl_write_+3A_caption_format">caption_format</code></td>
<td>
<p>result of the <a href="openxlsx.html#topic+createStyle">createStyle</a> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisibly return vector with rows and columns (<code>c(rows,
  columns)</code>) occupied by outputted object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(openxlsx)
data(mtcars)
# add labels to dataset
mtcars = apply_labels(mtcars,
                      mpg = "Miles/(US) gallon",
                      cyl = "Number of cylinders",
                      disp = "Displacement (cu.in.)",
                      hp = "Gross horsepower",
                      drat = "Rear axle ratio",
                      wt = "Weight (lb/1000)",
                      qsec = "1/4 mile time",
                      vs = "Engine",
                      vs = c("V-engine" = 0,
                             "Straight engine" = 1),
                      am = "Transmission",
                      am = c("Automatic" = 0,
                             "Manual"=1),
                      gear = "Number of forward gears",
                      carb = "Number of carburetors"
)

# create table with caption
mtcars_table = cross_cpct(mtcars,
                             cell_vars = list(cyl, gear),
                             col_vars = list(total(), am, vs)
) %&gt;% 
    set_caption("Table 1")


wb = createWorkbook()
sh = addWorksheet(wb, "Tables")
# export table
xl_write(mtcars_table, wb, sh)
saveWorkbook(wb, "table1.xlsx", overwrite = TRUE)

## quick export
xl_write_file(mtcars_table, "table1.xlsx")

## custom cells formatting
wb = createWorkbook()
sh = addWorksheet(wb, "Tables")

# we want to mark cells which are greater than total column
my_formatter = function(tbl){
    greater_than_total = tbl[,-1]&gt;tbl[[2]]
    which(greater_than_total, arr.ind = TRUE)
}
# export table
xl_write(mtcars_table, wb, sh, 
    additional_cells_formats = list(
        list(my_formatter, createStyle(textDecoration =  "bold", fontColour = "blue"))
    )
)
saveWorkbook(wb, "table_with_additional_format.xlsx", overwrite = TRUE)

## automated report generation on multiple variables with the same banner
 
banner = with(mtcars, list(total(), am, vs))

# create list of tables
list_of_tables = lapply(mtcars, function(variable) {
    if(length(unique(variable))&lt;7){
        cro_cpct(variable, banner) %&gt;% significance_cpct()
    } else {
        # if number of unique values greater than seven we calculate mean
        cro_mean_sd_n(variable, banner) %&gt;% significance_means()
        
    }
    
})


wb = createWorkbook()
sh = addWorksheet(wb, "Tables")
# export list of tables with additional formatting
xl_write(list_of_tables, wb, sh, 
         # remove '#' sign from totals 
         col_symbols_to_remove = "#",
         row_symbols_to_remove = "#",
         # format total column as bold
         other_col_labels_formats = list("#" = createStyle(textDecoration = "bold")),
         other_cols_formats = list("#" = createStyle(textDecoration = "bold")),
)
saveWorkbook(wb, "report.xlsx", overwrite = TRUE)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
