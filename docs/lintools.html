<!DOCTYPE html><html lang="en"><head><title>Help for package lintools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lintools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#allTotallyUnimodular'><p>Test if a list of matrices are all unimodular</p></a></li>
<li><a href='#block_index'><p>Find independent blocks of equations.</p></a></li>
<li><a href='#compact'><p>Remove spurious variables and restrictions</p></a></li>
<li><a href='#echelon'><p>Reduced row echelon form</p></a></li>
<li><a href='#eliminate'><p>Eliminate a variable from a set of edit rules</p></a></li>
<li><a href='#hellerTompkins'><p>Determine if a matrix is totally unimodular using Heller and Tompkins criterium.</p></a></li>
<li><a href='#is_feasible'><p>Check feasibility of a system of linear (in)equations</p></a></li>
<li><a href='#is_totally_unimodular'><p>Test for total unimodularity of a matrix.</p></a></li>
<li><a href='#lintools'><p>Tools for manipulating linear systems of (in)equations</p></a></li>
<li><a href='#normalize'><p>Bring a system of (in)equalities in a standard form</p></a></li>
<li><a href='#pinv'><p>Moore-Penrose pseudoinverse</p></a></li>
<li><a href='#project'><p>Project a vector on the border of the region defined by a set of linear (in)equality restrictions.</p></a></li>
<li><a href='#raghavachari'><p>Determine if a matrix is unimodular using recursive Raghavachari criterium</p></a></li>
<li><a href='#ranges'><p>Derive variable ranges from linear restrictions</p></a></li>
<li><a href='#reduceMatrix'><p>Apply reduction method from Scholtus (2008)</p></a></li>
<li><a href='#sparse_constraints'><p>Generate sparse set of constraints.</p></a></li>
<li><a href='#sparse_project'><p>Successive projections with sparsely defined restrictions</p></a></li>
<li><a href='#subst_value'><p>Substitute a value in a system of linear (in)equations</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Maintainer:</td>
<td>Mark van der Loo &lt;mark.vanderloo@gmail.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Title:</td>
<td>Manipulation of Linear Systems of (in)Equalities</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Description:</td>
<td>Variable elimination (Gaussian elimination, Fourier-Motzkin elimination), 
    Moore-Penrose pseudoinverse, reduction to reduced row echelon form, value substitution,  
    projecting a vector on the convex polytope described by a system of (in)equations, 
    simplify systems by removing spurious columns and rows and collapse implied equalities, 
    test if a matrix is totally unimodular, compute variable ranges implied by linear
    (in)equalities.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.7</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/data-cleaning/lintools">https://github.com/data-cleaning/lintools</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/data-cleaning/lintools/issues">https://github.com/data-cleaning/lintools/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tinytest, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-16 20:23:31 UTC; mark</td>
</tr>
<tr>
<td>Author:</td>
<td>Mark van der Loo [aut, cre],
  Edwin de Jonge [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-16 20:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='allTotallyUnimodular'>Test if a list of matrices are all unimodular</h2><span id='topic+allTotallyUnimodular'></span>

<h3>Description</h3>

<p>Helper function for <code><a href="#topic+raghavachari">raghavachari</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allTotallyUnimodular(L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allTotallyUnimodular_+3A_l">L</code></td>
<td>
<p>A list of objects of class matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector of length <code>length(L)</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is_totally_unimodular">is_totally_unimodular</a></code>
</p>

<hr>
<h2 id='block_index'>Find independent blocks of equations.</h2><span id='topic+block_index'></span>

<h3>Description</h3>

<p>Find independent blocks of equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block_index(A, eps = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="block_index_+3A_a">A</code></td>
<td>
<p><code>[numeric]</code> Matrix</p>
</td></tr>
<tr><td><code id="block_index_+3A_eps">eps</code></td>
<td>
<p><code>[numeric]</code> Coefficients with absolute value <code>&lt; eps</code> are treated as zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing <code>numeric</code> vectors, each vector indexing an independent
block of rows in the system <code>Ax &lt;= b</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 A &lt;- matrix(c(
   1,0,2,0,0,
   3,0,4,0,0,
   0,5,0,6,7,
   0,8,0,0,9
 ),byrow=TRUE,nrow=4)
 b &lt;- rep(0,4)
 bi &lt;- block_index(A)
 lapply(bi,function(ii) compact(A[ii,,drop=FALSE],b=b[ii])$A)


</code></pre>

<hr>
<h2 id='compact'>Remove spurious variables and restrictions</h2><span id='topic+compact'></span>

<h3>Description</h3>

<p>A system of linear (in)equations can be compactified by removing
zero-rows and zero-columns (=variables). Such rows and columns may
arise after substitution (see <code><a href="#topic+subst_value">subst_value</a></code>) or eliminaton
of a variable (see <code><a href="#topic+eliminate">eliminate</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compact(
  A,
  b,
  x = NULL,
  neq = nrow(A),
  nleq = 0,
  eps = 1e-08,
  remove_columns = TRUE,
  remove_rows = TRUE,
  deduplicate = TRUE,
  implied_equations = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compact_+3A_a">A</code></td>
<td>
<p>[<code>numeric</code>] matrix</p>
</td></tr>
<tr><td><code id="compact_+3A_b">b</code></td>
<td>
<p>[<code>numeric</code>] vector</p>
</td></tr>
<tr><td><code id="compact_+3A_x">x</code></td>
<td>
<p>[<code>numeric</code>] vector</p>
</td></tr>
<tr><td><code id="compact_+3A_neq">neq</code></td>
<td>
<p>[<code>numeric</code>] The first <code>neq</code> rows in <code>A</code> and
<code>b</code> are treated as linear equalities.</p>
</td></tr>
<tr><td><code id="compact_+3A_nleq">nleq</code></td>
<td>
<p>[<code>numeric</code>] The <code>nleq</code> rows after <code>neq</code> are treated as
inequations of the form <code>a.x&lt;=b</code>. All remaining rows are treated as strict inequations
of the form <code>a.x&lt;b</code>.</p>
</td></tr>
<tr><td><code id="compact_+3A_eps">eps</code></td>
<td>
<p>[<code>numeric</code>] Anything with absolute value <code>&lt; eps</code> is considered zero.</p>
</td></tr>
<tr><td><code id="compact_+3A_remove_columns">remove_columns</code></td>
<td>
<p>[<code>logical</code>] Toggle remove spurious columns from <code>A</code> and variables from <code>x</code></p>
</td></tr>
<tr><td><code id="compact_+3A_remove_rows">remove_rows</code></td>
<td>
<p>[<code>logical</code>] Toggle remove spurious rows</p>
</td></tr>
<tr><td><code id="compact_+3A_deduplicate">deduplicate</code></td>
<td>
<p>[<code>logical</code>] Toggle remove duplicate rows</p>
</td></tr>
<tr><td><code id="compact_+3A_implied_equations">implied_equations</code></td>
<td>
<p>[<code>logical</code>] replace cases of <code>a.x&lt;=b</code> and <code>a.x&gt;=b</code> with
<code>a.x==b</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the following elements.
</p>

<ul>
<li><p><code>A</code>: The compactified version of input <code>A</code>
</p>
</li>
<li><p><code>b</code>: The compactified version of input <code>b</code>
</p>
</li>
<li><p><code>x</code>: The compactified version of input <code>x</code>
</p>
</li>
<li><p><code>neq</code>: number of equations in new system
</p>
</li>
<li><p><code>nleq</code>: number of inequations of the form <code>a.x&lt;=b</code> in the new system
</p>
</li>
<li><p><code>cols_removed</code>: [<code>logical</code>] indicates what elements of <code>x</code> (columns of <code>A</code>) have been removed
</p>
</li></ul>



<h3>Details</h3>

<p>It is assumend that the system of equations is in normalized form (see <code>link{normalize}</code>).
</p>

<hr>
<h2 id='echelon'>Reduced row echelon form</h2><span id='topic+echelon'></span>

<h3>Description</h3>

<p>Transform the equalities in a system of linear (in)equations or Reduced Row Echelon form (RRE)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>echelon(A, b, neq = nrow(A), nleq = 0, eps = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="echelon_+3A_a">A</code></td>
<td>
<p><code>[numeric]</code> matrix</p>
</td></tr>
<tr><td><code id="echelon_+3A_b">b</code></td>
<td>
<p><code>[numeric]</code> vector</p>
</td></tr>
<tr><td><code id="echelon_+3A_neq">neq</code></td>
<td>
<p><code>[numeric]</code> The first <code>neq</code> rows of <code>A</code>, <code>b</code> are treated as equations.</p>
</td></tr>
<tr><td><code id="echelon_+3A_nleq">nleq</code></td>
<td>
<p>[<code>numeric</code>] The <code>nleq</code> rows after <code>neq</code> are treated as
inequations of the form <code>a.x&lt;=b</code>. All remaining rows are treated as strict inequations
of the form <code>a.x&lt;b</code>.</p>
</td></tr>
<tr><td><code id="echelon_+3A_eps">eps</code></td>
<td>
<p><code>[numeric]</code> Values of magnitude less than <code>eps</code> are considered zero (for the purpose of handling
machine rounding errors).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>

<ul>
<li><p><code>A</code>: the <code>A</code> matrix with equalities transformed to RRE form.
</p>
</li>
<li><p><code>b</code>: the constant vector corresponding to <code>A</code>
</p>
</li>
<li><p><code>neq</code>: the number of equalities in the resulting system.
</p>
</li>
<li><p><code>nleq</code>: the number of inequalities of the form <code>a.x &lt;= b</code>. This will only
be passed to the output.
</p>
</li></ul>



<h3>Details</h3>

<p>The parameters <code>A</code>, <code>b</code> and <code>neq</code> describe a system of the form <code>Ax&lt;=b</code>, where
the first <code>neq</code> rows are equalities. The equalities are transformed to RRE form.
</p>
<p>A system of equations is in <a href="https://en.wikipedia.org/wiki/Row_echelon_form">reduced row echelon</a> form when
</p>

<ul>
<li><p>All zero rows are below the nonzero rows
</p>
</li>
<li><p>For every row, the leading coefficient (first nonzero from the left) is always right of the leading coefficient of the row above it.
</p>
</li>
<li><p>The leading coefficient equals 1, and is the only nonzero coefficient in its column.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>echelon(
 A = matrix(c(
    1,3,1,
    2,7,3,
    1,5,3,
    1,2,0), byrow=TRUE, nrow=4)
 , b = c(4,-9,1,8)
 , neq=4
)


</code></pre>

<hr>
<h2 id='eliminate'>Eliminate a variable from a set of edit rules</h2><span id='topic+eliminate'></span>

<h3>Description</h3>

<p>Eliminating a variable amounts to deriving all (non-redundant) linear
(in)equations not containing that variable. Geometrically, it can be interpreted as
a projection of the solution space (vectors satisfying all equations) along the
eliminated variable's axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eliminate(
  A,
  b,
  neq = nrow(A),
  nleq = 0,
  variable,
  H = NULL,
  h = 0,
  eps = 1e-08
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eliminate_+3A_a">A</code></td>
<td>
<p><code>[numeric]</code> Matrix</p>
</td></tr>
<tr><td><code id="eliminate_+3A_b">b</code></td>
<td>
<p><code>[numeric]</code> vector</p>
</td></tr>
<tr><td><code id="eliminate_+3A_neq">neq</code></td>
<td>
<p>[<code>numeric</code>] The first <code>neq</code> rows in <code>A</code> and
<code>b</code> are treated as linear equalities.</p>
</td></tr>
<tr><td><code id="eliminate_+3A_nleq">nleq</code></td>
<td>
<p>[<code>numeric</code>] The <code>nleq</code> rows after <code>neq</code> are treated as
inequations of the form <code>a.x&lt;=b</code>. All remaining rows are treated as strict inequations
of the form <code>a.x&lt;b</code>.</p>
</td></tr>
<tr><td><code id="eliminate_+3A_variable">variable</code></td>
<td>
<p><code>[numeric|logical|character]</code> Index in columns of <code>A</code>, representing the variable to eliminate.</p>
</td></tr>
<tr><td><code id="eliminate_+3A_h">H</code></td>
<td>
<p><code>[numeric]</code> (optional) Matrix indicating how linear inequalities have been derived.</p>
</td></tr>
<tr><td><code id="eliminate_+3A_h">h</code></td>
<td>
<p><code>[numeric]</code> (optional) number indicating how many variables have been eliminated from the original system
using Fourier-Motzkin elimination.</p>
</td></tr>
<tr><td><code id="eliminate_+3A_eps">eps</code></td>
<td>
<p><code>[numeric]</code> Coefficients with absolute value  <code>&lt;= eps</code> are treated as zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the folowing components
</p>

<ul>
<li><p><code>A</code>: the <code>A</code> corresponding to the system with variables eliminated.
</p>
</li>
<li><p><code>b</code>: the constant vector corresponding to the resulting system
</p>
</li>
<li><p><code>neq</code>: the number of equations
</p>
</li>
<li><p><code>H</code>: The memory matrix storing how each row was derived
</p>
</li>
<li><p><code>h</code>: The number of variables eliminated from the original system.
</p>
</li></ul>



<h3>Details</h3>

<p>For equalities Gaussian elimination is applied. If inequalities are involved,
Fourier-Motzkin elimination is used. In principle, FM-elimination can
generate a large number of redundant inequations, especially when applied
recursively. Redundancies can be recognized by recording how new inequations
have been derived from the original set. This is stored in the <code>H</code> matrix
when multiple variables are to be eliminated (Kohler, 1967).
</p>


<h3>References</h3>

<p>D.A. Kohler (1967) Projections of convex polyhedral sets, Operational Research
Center Report , ORC 67-29, University of California, Berkely.
</p>
<p>H.P. Williams (1986) Fourier's method of linear programming and its dual. American
Mathematical Monthly 93, pp 681-695.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example from Williams (1986)
A &lt;- matrix(c(
   4, -5, -3,  1,
  -1,  1, -1,  0,
   1,  1,  2,  0,
  -1,  0,  0,  0,
   0, -1,  0,  0,
   0,  0, -1,  0),byrow=TRUE,nrow=6) 
b &lt;- c(0,2,3,0,0,0)
L &lt;- eliminate(A=A, b=b, neq=0, nleq=6, variable=1)


</code></pre>

<hr>
<h2 id='hellerTompkins'>Determine if a matrix is totally unimodular using Heller and Tompkins criterium.</h2><span id='topic+hellerTompkins'></span>

<h3>Description</h3>

<p>This function is <code>deducorrect</code> internal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hellerTompkins(A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hellerTompkins_+3A_a">A</code></td>
<td>
<p>An object of class matrix in <code class="reqn">\{-1,0,1\}^{m\times n}</code>. 
Each column  must have exactly 2 nonzero elements. (This is tested by 
<code><a href="#topic+is_totally_unimodular">is_totally_unimodular</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if matrix is unimodular, otherwise <code>FALSE</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is_totally_unimodular">is_totally_unimodular</a></code>
</p>

<hr>
<h2 id='is_feasible'>Check feasibility of a system of linear (in)equations</h2><span id='topic+is_feasible'></span>

<h3>Description</h3>

<p>Check feasibility of a system of linear (in)equations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_feasible(A, b, neq = nrow(A), nleq = 0, eps = 1e-08, method = "elimination")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_feasible_+3A_a">A</code></td>
<td>
<p>[<code>numeric</code>] matrix</p>
</td></tr>
<tr><td><code id="is_feasible_+3A_b">b</code></td>
<td>
<p>[<code>numeric</code>] vector</p>
</td></tr>
<tr><td><code id="is_feasible_+3A_neq">neq</code></td>
<td>
<p>[<code>numeric</code>] The first <code>neq</code> rows in <code>A</code> and
<code>b</code> are treated as linear equalities.</p>
</td></tr>
<tr><td><code id="is_feasible_+3A_nleq">nleq</code></td>
<td>
<p>[<code>numeric</code>] The <code>nleq</code> rows after <code>neq</code> are treated as
inequations of the form <code>a.x&lt;=b</code>. All remaining rows are treated as strict inequations
of the form <code>a.x&lt;b</code>.</p>
</td></tr>
<tr><td><code id="is_feasible_+3A_eps">eps</code></td>
<td>
<p>[<code>numeric</code>] Absolute values <code>&lt; eps</code> are treated as zero.</p>
</td></tr>
<tr><td><code id="is_feasible_+3A_method">method</code></td>
<td>
<p>[<code>character</code>] At the moment, only the 'elimination' method is implemented.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># An infeasible system:
# x + y == 0
# x &gt; 0
# y &gt; 0
A &lt;- matrix(c(1,1,1,0,0,1),byrow=TRUE,nrow=3)
b &lt;- rep(0,3)
is_feasible(A=A,b=b,neq=1,nleq=0)

# A feasible system:
# x + y == 0
# x &gt;= 0
# y &gt;= 0
A &lt;- matrix(c(1,1,1,0,0,1),byrow=TRUE,nrow=3)
b &lt;- rep(0,3)
is_feasible(A=A,b=b,neq=1,nleq=2)

</code></pre>

<hr>
<h2 id='is_totally_unimodular'>Test for total unimodularity of a matrix.</h2><span id='topic+is_totally_unimodular'></span>

<h3>Description</h3>

<p>Check wether a matrix is totally unimodular.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_totally_unimodular(A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_totally_unimodular_+3A_a">A</code></td>
<td>
<p>An object of class <code><a href="base.html#topic+matrix">matrix</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A matrix for which the determinant of every square submatrix equals <code class="reqn">-1</code>,
<code class="reqn">0</code> or <code class="reqn">1</code> is called
<a href="https://en.wikipedia.org/wiki/Unimodular_matrix">totally unimodular</a>. 
This function tests wether a matrix with coefficients in <code class="reqn">\{-1,0,1\}</code> is
totally unimodular. It tries to reduce the matrix using the reduction method
described in Scholtus (2008). Next, a test based on Heller and Tompkins
(1956) or Raghavachari is performed.
</p>


<h3>Value</h3>

<p>logical
</p>


<h3>References</h3>

<p>Heller I and Tompkins CB (1956). An extension of a theorem of Danttzig's In kuhn HW and Tucker AW (eds.),
pp. 247-254. Princeton University Press.
</p>
<p>Raghavachari M (1976). A constructive method to recognize the total
unimodularity of a matrix. _Zeitschrift fur operations research_,
*20*, pp. 59-61.
</p>
<p>Scholtus S (2008). Algorithms for correcting some obvious
inconsistencies and rounding errors in business survey data. Technical
Report 08015, Netherlands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Totally unimodular matrix, reduces to nothing
A &lt;- matrix(c(
 1,1,0,0,0,
 -1,0,0,1,0,
 0,0,01,1,0,
 0,0,0,-1,1),nrow=5)
is_totally_unimodular(A)

# Totally unimodular matrix, by Heller-Tompson criterium
A &lt;- matrix(c(
 1,1,0,0,
 0,0,1,1,
 1,0,1,0,
 0,1,0,1),nrow=4)
is_totally_unimodular(A)

# Totally unimodular matrix, by Raghavachani recursive criterium
A &lt;- matrix(c(
    1,1,1,
    1,1,0,
    1,0,1))
is_totally_unimodular(A)




</code></pre>

<hr>
<h2 id='lintools'>Tools for manipulating linear systems of (in)equations</h2><span id='topic+lintools'></span>

<h3>Description</h3>

<p>This package offers a basic and consistent interface to a number of
operations on linear systems of (in)equations not available in base R.
Except for the projection on the convex polytope, operations are currently
supported for dense matrices only.
</p>


<h3>Details</h3>

<p>The following operations are implemented.
</p>

<ul>
<li><p>Split matrices in independent blocks
</p>
</li>
<li><p>Remove spurious rows and columns from a system of (in)equations
</p>
</li>
<li><p>Rewrite equalities in reduced row echelon form
</p>
</li>
<li><p>Eliminate variables through Gaussian or Fourier-Motzkin elimination
</p>
</li>
<li><p>Determine the feasibility of a system of linear (in)equations
</p>
</li>
<li><p>Compute Moore-Penrose Pseudoinverse
</p>
</li>
<li><p>Project a vector onto the convec polytope described by a set of linear (in)equations
</p>
</li>
<li><p>Simplify a system by substituting values
</p>
</li></ul>

<p>Most functions assume a system of (in)equations to be stored in a standard form. The <code><a href="#topic+normalize">normalize</a></code>
function can bring any system of equations to this form.
</p>

<hr>
<h2 id='normalize'>Bring a system of (in)equalities in a standard form</h2><span id='topic+normalize'></span>

<h3>Description</h3>

<p>Bring a system of (in)equalities in a standard form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize(A, b, operators, unit = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalize_+3A_a">A</code></td>
<td>
<p><code>[numeric]</code> Matrix</p>
</td></tr>
<tr><td><code id="normalize_+3A_b">b</code></td>
<td>
<p><code>[numeric]</code> vector</p>
</td></tr>
<tr><td><code id="normalize_+3A_operators">operators</code></td>
<td>
<p><code>[character]</code> operators in <code>{&lt;,&lt;=,==,&gt;=,&gt;}</code>.</p>
</td></tr>
<tr><td><code id="normalize_+3A_unit">unit</code></td>
<td>
<p><code>[numeric]</code> (nonnegative) Your unit of measurement. This is used to
replace strict inequations of the form <code>a.x &lt; b</code> with <code>a.x &lt;= b-unit</code>.
Typically, <code>unit</code> is related to the units in which your data 
is measured.  If unit is 0, inequations are not replaced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the folowing components
</p>

<ul>
<li><p><code>A</code>: the <code>A</code> corresponding to the normalized sytem.
</p>
</li>
<li><p><code>b</code>: the constant vector corresponding to the normalized system
</p>
</li>
<li><p><code>neq</code>: the number of equations
</p>
</li>
<li><p><code>nleq</code>: the number of non-strict inequations (&lt;=)
</p>
</li>
<li><p><code>order</code>: the index vector used to permute the original rows of <code>A</code>.
</p>
</li></ul>



<h3>Details</h3>

<p>For this package, a set of equations is in normal form when 
</p>

<ul>
<li><p> The first <code>neq</code> rows represent linear equalities.
</p>
</li>
<li><p> The next <code>nleq</code> rows represent inequalities of the form <code>a.x &lt;= b</code>
</p>
</li>
<li><p> All other rows are strict inequalities of the form <code>a.x &lt; b</code>
</p>
</li></ul>

<p>If <code>unit&gt;0</code>, the strict inequalities <code>a.x &lt; b</code> are replaced with 
inequations of the form <code>a.x &lt;= b-unit</code>, where <code>unit</code> represents
the precision of measurement.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A &lt;- matrix(1:12,nrow=4)
b &lt;- 1:4
ops &lt;- c("&lt;=","==","==","&lt;")
normalize(A,b,ops)
normalize(A,b,ops,unit=0.1)

</code></pre>

<hr>
<h2 id='pinv'>Moore-Penrose pseudoinverse</h2><span id='topic+pinv'></span>

<h3>Description</h3>

<p>Compute the pseudoinverse of a matrix using the
SVD-construction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pinv(A, eps = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pinv_+3A_a">A</code></td>
<td>
<p>[numeric] matrix</p>
</td></tr>
<tr><td><code id="pinv_+3A_eps">eps</code></td>
<td>
<p>[numeric] tolerance for determining zero singular values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Moore-Penrose pseudoinverse (sometimes called the generalized inverse) <code class="reqn">\boldsymbol{A}^+</code> of a matrix <code class="reqn">\boldsymbol{A}</code>
has the property that <code class="reqn">\boldsymbol{A}^+\boldsymbol{AA}^+ = \boldsymbol{A}</code>. It can be constructed as follows.
</p>

<ul>
<li><p>Compute the singular value decomposition <code class="reqn">\boldsymbol{A} = \boldsymbol{UDV}^T</code>
</p>
</li>
<li><p>Replace diagonal elements in <code class="reqn">\boldsymbol{D}</code> of which the absolute values are larger than some limit <code>eps</code> with their reciprocal values
</p>
</li>
<li><p>Compute <code class="reqn">\boldsymbol{A}^+ = \boldsymbol{UDV}^T</code>
</p>
</li></ul>



<h3>References</h3>

<p>S Lipshutz and M Lipson (2009) Linear Algebra. In: Schuam's outlines. McGraw-Hill
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(c(
 1,  1, -1,  2,
 2,  2, -1,  3,
 -1, -1,  2, -3
),byrow=TRUE,nrow=3)
# multiply by 55 to retrieve whole numbers
pinv(A) * 55

</code></pre>

<hr>
<h2 id='project'>Project a vector on the border of the region defined by a set of linear (in)equality restrictions.</h2><span id='topic+project'></span>

<h3>Description</h3>

<p>Compute a vector, closest to <code>x</code> in the Euclidean sense, satisfying a set of linear (in)equality restrictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project(
  x,
  A,
  b,
  neq = length(b),
  w = rep(1, length(x)),
  eps = 0.01,
  maxiter = 1000L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="project_+3A_x">x</code></td>
<td>
<p>[<code>numeric</code>] Vector that needs to satisfy the linear restrictions.</p>
</td></tr>
<tr><td><code id="project_+3A_a">A</code></td>
<td>
<p>[<code>matrix</code>] Coefficient matrix for linear restrictions.</p>
</td></tr>
<tr><td><code id="project_+3A_b">b</code></td>
<td>
<p>[<code>numeric</code>] Right hand side of linear restrictions.</p>
</td></tr>
<tr><td><code id="project_+3A_neq">neq</code></td>
<td>
<p>[<code>numeric</code>] The first <code>neq</code> rows in <code>A</code> and <code>b</code> are treated as linear equalities. 
The others as Linear inequalities of the form <code class="reqn">Ax&lt;=b</code>.</p>
</td></tr>
<tr><td><code id="project_+3A_w">w</code></td>
<td>
<p>[<code>numeric</code>] Optional weight vector of the same length as <code>x</code>. Must be positive.</p>
</td></tr>
<tr><td><code id="project_+3A_eps">eps</code></td>
<td>
<p>The maximum allowed deviation from the constraints (see details).</p>
</td></tr>
<tr><td><code id="project_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the following entries:
</p>

<ul>
<li><p><code>x</code>: the adjusted vector
</p>
</li>
<li><p><code>status</code>: Exit status:
</p>

<ul>
<li><p>0: success
</p>
</li>
<li><p>1: could not allocate enough memory (space for approximately <code class="reqn">2(m+n)</code> <code>double</code>s is necessary).
</p>
</li>
<li><p>2: divergence detected (set of restrictions may be contradictory)
</p>
</li>
<li><p>3: maximum number of iterations reached
</p>
</li></ul>


</li>
<li><p><code>eps</code>: The tolerance achieved after optimizing (see Details).
</p>
</li>
<li><p><code>iterations</code>: The number of iterations performed.
</p>
</li>
<li><p><code>duration</code>: the time it took to compute the adjusted vector
</p>
</li>
<li><p><code>objective</code>: The (weighted) Euclidean distance between the initial and the adjusted vector
</p>
</li></ul>



<h3>Details</h3>

<p>The tolerance <code>eps</code> is defined as the maximum absolute value of the difference vector 
<code class="reqn">\boldsymbol{Ax}-\boldsymbol{b}</code> for equalities. For inequalities, the difference vector
is set to zero when it's value is lesser than zero (i.e. when the restriction is satisfied). The
algorithm iterates until either the tolerance is met, the number of allowed iterations is
exceeded or divergence is detected.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sparse_project">sparse_project</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# the system 
# x + y = 10
# -x &lt;= 0   # ==&gt; x &gt; 0
# -y &lt;= 0   # ==&gt; y &gt; 0
#
A &lt;- matrix(c(
   1,1,
  -1,0,
   0,-1), byrow=TRUE, nrow=3
)
b &lt;- c(10,0,0)

# x and y will be adjusted by the same amount
project(x=c(4,5), A=A, b=b, neq=1)

# One of the inequalies violated
project(x=c(-1,5), A=A, b=b, neq=1)

# Weighted distances: 'heavy' variables change less
project(x=c(4,5), A=A, b=b, neq=1, w=c(100,1))

# if w=1/x0, the ratio between coefficients of x0 stay the same (to first order)
x0 &lt;- c(x=4,y=5)
x1 &lt;- project(x=x0,A=A,b=b,neq=1,w=1/x0)

x0[1]/x0[2]
x1$x[1] / x1$x[2]



</code></pre>

<hr>
<h2 id='raghavachari'>Determine if a matrix is unimodular using recursive Raghavachari criterium</h2><span id='topic+raghavachari'></span>

<h3>Description</h3>

<p>This function is <code>lintools</code> internal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raghavachari(A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raghavachari_+3A_a">A</code></td>
<td>
<p>An object of class Matrix in <code class="reqn">\{-1,0,1\}^{m\times n}</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is_totally_unimodular">is_totally_unimodular</a></code>
</p>

<hr>
<h2 id='ranges'>Derive variable ranges from linear restrictions</h2><span id='topic+ranges'></span>

<h3>Description</h3>

<p>Gaussian and/or Fourier-Motzkin elimination is used 
to derive upper and lower limits implied by a system of (in)equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ranges(A, b, neq = nrow(A), nleq = 0, eps = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ranges_+3A_a">A</code></td>
<td>
<p><code>[numeric]</code> Matrix</p>
</td></tr>
<tr><td><code id="ranges_+3A_b">b</code></td>
<td>
<p><code>[numeric]</code> vector</p>
</td></tr>
<tr><td><code id="ranges_+3A_neq">neq</code></td>
<td>
<p>[<code>numeric</code>] The first <code>neq</code> rows in <code>A</code> and
<code>b</code> are treated as linear equalities.</p>
</td></tr>
<tr><td><code id="ranges_+3A_nleq">nleq</code></td>
<td>
<p>[<code>numeric</code>] The <code>nleq</code> rows after <code>neq</code> are treated as
inequations of the form <code>a.x&lt;=b</code>. All remaining rows are treated as strict inequations
of the form <code>a.x&lt;b</code>.</p>
</td></tr>
<tr><td><code id="ranges_+3A_eps">eps</code></td>
<td>
<p><code>[numeric]</code> Coefficients with absolute value  <code>&lt;= eps</code> are treated as zero.
using Fourier-Motzkin elimination.</p>
</td></tr>
</table>

<hr>
<h2 id='reduceMatrix'>Apply reduction method from Scholtus (2008)</h2><span id='topic+reduceMatrix'></span>

<h3>Description</h3>

<p>Apply the reduction method in the appendix of Scholtus (2008) to a matrix.
Let <code class="reqn">A</code> with coefficients in <code class="reqn">\{-1,0,1\}</code>. If, after a possible 
permutation of columns it can be written 
in the form <code class="reqn">A=[B,C]</code> where each column in <code class="reqn">B</code> has at most 1 nonzero
element, then <code class="reqn">A</code> is totally unimodular if and only if <code class="reqn">C</code> is totally
unimodular. By transposition, a similar theorem holds for the rows of A. This
function iteratively removes rows and columns with only 1 nonzero element
from <code class="reqn">A</code> and returns the reduced result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduceMatrix(A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reduceMatrix_+3A_a">A</code></td>
<td>
<p>An object of class matrix in <code class="reqn">\{-1,0,1\}^{m\times n}</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The reduction of A.
</p>


<h3>References</h3>

<p>Scholtus S (2008). Algorithms for correcting some obvious
inconsistencies and rounding errors in business survey data. Technical
Report 08015, Netherlands.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is_totally_unimodular">is_totally_unimodular</a></code>
</p>

<hr>
<h2 id='sparse_constraints'>Generate sparse set of constraints.</h2><span id='topic+sparse_constraints'></span><span id='topic+sparseConstraints'></span><span id='topic+sparse_constraints.data.frame'></span><span id='topic+print.sparse_constraints'></span>

<h3>Description</h3>

<p>Generate a constraint set to be used by <code><a href="#topic+sparse_project">sparse_project</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse_constraints(object, ...)

sparseConstraints(object, ...)

## S3 method for class 'data.frame'
sparse_constraints(object, b, neq = length(b), base = 1L, sorted = FALSE, ...)

## S3 method for class 'sparse_constraints'
print(x, range = 1L:10L, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparse_constraints_+3A_object">object</code></td>
<td>
<p>R object to be translated to sparse_constraints format.</p>
</td></tr>
<tr><td><code id="sparse_constraints_+3A_...">...</code></td>
<td>
<p>options to be passed to other methods</p>
</td></tr>
<tr><td><code id="sparse_constraints_+3A_b">b</code></td>
<td>
<p>Constant vector</p>
</td></tr>
<tr><td><code id="sparse_constraints_+3A_neq">neq</code></td>
<td>
<p>The first <code>new</code> equations are interpreted as equality constraints, the rest as '&lt;='</p>
</td></tr>
<tr><td><code id="sparse_constraints_+3A_base">base</code></td>
<td>
<p>are the indices in <code>object[,1:2]</code> base 0 or base 1?</p>
</td></tr>
<tr><td><code id="sparse_constraints_+3A_sorted">sorted</code></td>
<td>
<p>is <code>object</code> sorted by the  first column?</p>
</td></tr>
<tr><td><code id="sparse_constraints_+3A_x">x</code></td>
<td>
<p>an object of class <code>sparse_constraints</code></p>
</td></tr>
<tr><td><code id="sparse_constraints_+3A_range">range</code></td>
<td>
<p>integer vector stating which constraints to print</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>sparse_constraints</code> (see details).
</p>


<h3>Note</h3>

<p>As of version 0.1.1.0, <code>sparseConstraints</code> is deprecated. Use <code>sparse_constraints</code> instead.
</p>


<h3>Details</h3>

<p>The <code>sparse_constraints</code> objects holds coefficients of
<code class="reqn">\boldsymbol{A}</code> and <code class="reqn">\boldsymbol{b}</code> of the system
<code class="reqn">\boldsymbol{Ax}\leq \boldsymbol{b}</code> in sparse format, outside of
<code>R</code>'s memory. It can be reused to find solutions for vectors to adjust.
</p>
<p>In <code>R</code>, it is a <em>reference object</em>. In particular, it is meaningless to
</p>

<ul>
<li><p>Copy the object. You only will only generate a pointer to physically the same object.
</p>
</li>
<li><p>Save the object. The physical object is destroyed when <code>R</code> closes, or when <code>R</code>'s
garbage collector cleans up a removed <code>sparse_constraints</code> object.
</p>
</li></ul>



<h3>The <code>$project</code> method</h3>

<p>Once a <code>sparse_constraints</code> object <code>sc</code> is created, you can reuse it to optimize
several vectors by calling <code>sc$project()</code> with the following parameters:
</p>

<ul>
<li><p><code>x</code>: <code>[numeric]</code> the vector to be optimized
</p>
</li>
<li><p><code>w</code>: <code>[numeric]</code> the weight vector (of <code>length(x)</code>). By default all weights equal 1.
</p>
</li>
<li><p><code>eps</code>: <code>[numeric]</code> desired tolerance. By default <code class="reqn">10^{-2}</code> 
</p>
</li>
<li><p><code>maxiter</code>: <code>[integer]</code> maximum number of iterations. By default 1000.
</p>
</li></ul>

<p>The return value of <code>$spa</code> is the same as that of <code><a href="#topic+sparse_project">sparse_project</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sparse_project">sparse_project</a></code>, <code><a href="#topic+project">project</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The following system of constraints, stored in
# row-column-coefficient format
#
# x1 + x8 ==  950,
# x3 + x4 ==  950 ,
# x6 + x7 == x8,
# x4 &gt; 0
# 
A &lt;- data.frame( 
   row = c( 1, 1, 2, 2, 3, 3, 3, 4)
   , col = c( 1, 2, 3, 4, 2, 5, 6, 4)
   , coef = c(-1,-1,-1,-1, 1,-1,-1,-1)
)
b &lt;- c(-950, -950, 0,0) 

sc &lt;- sparse_constraints(A, b, neq=3)

# Adjust the 0-vector minimally so all constraints are met:
sc$project(x=rep(0,8))

# Use the same object to adjust the 100*1-vector
sc$project(x=rep(100,8))

# use the same object to adjust the 0-vector, but with different weights
sc$project(x=rep(0,8),w=1:8)


</code></pre>

<hr>
<h2 id='sparse_project'>Successive projections with sparsely defined restrictions</h2><span id='topic+sparse_project'></span>

<h3>Description</h3>

<p>Compute a vector, closest to <code class="reqn">x</code> satisfying a set of linear (in)equality restrictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse_project(
  x,
  A,
  b,
  neq = length(b),
  w = rep(1, length(x)),
  eps = 0.01,
  maxiter = 1000L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparse_project_+3A_x">x</code></td>
<td>
<p><code>[numeric]</code> Vector to optimize, starting point.</p>
</td></tr>
<tr><td><code id="sparse_project_+3A_a">A</code></td>
<td>
<p><code>[data.frame]</code> Coeffiencient matrix in <code>[row,column,coefficient]</code> format.</p>
</td></tr>
<tr><td><code id="sparse_project_+3A_b">b</code></td>
<td>
<p><code>[numeric]</code> Constant vector of the system <code class="reqn">Ax\leq b</code></p>
</td></tr>
<tr><td><code id="sparse_project_+3A_neq">neq</code></td>
<td>
<p><code>[integer]</code> Number of equalities</p>
</td></tr>
<tr><td><code id="sparse_project_+3A_w">w</code></td>
<td>
<p><code>[numeric]</code> weight vector of same length of <code>x</code></p>
</td></tr>
<tr><td><code id="sparse_project_+3A_eps">eps</code></td>
<td>
<p>maximally allowed tolerance</p>
</td></tr>
<tr><td><code id="sparse_project_+3A_maxiter">maxiter</code></td>
<td>
<p>maximally allowed number of iterations.</p>
</td></tr>
<tr><td><code id="sparse_project_+3A_...">...</code></td>
<td>
<p>extra parameters passed to <code><a href="#topic+sparse_constraints">sparse_constraints</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the following entries:
</p>

<ul>
<li><p><code>x</code>: the adjusted vector
</p>
</li>
<li><p><code>status</code>: Exit status:
</p>

<ul>
<li><p>0: success
</p>
</li>
<li><p>1: could not allocate enough memory (space for approximately <code class="reqn">2(m+n)</code> <code>double</code>s is necessary).
</p>
</li>
<li><p>2: divergence detected (set of restrictions may be contradictory)
</p>
</li>
<li><p>3: maximum number of iterations reached
</p>
</li></ul>


</li>
<li><p><code>eps</code>: The tolerance achieved after optimizing (see Details).
</p>
</li>
<li><p><code>iterations</code>: The number of iterations performed.
</p>
</li>
<li><p><code>duration</code>: the time it took to compute the adjusted vector
</p>
</li>
<li><p><code>objective</code>: The (weighted) Euclidean distance between the initial and the adjusted vector
</p>
</li></ul>



<h3>Details</h3>

<p>The tolerance <code>eps</code> is defined as the maximum absolute value of the difference vector 
<code class="reqn">\boldsymbol{Ax}-\boldsymbol{b}</code> for equalities. For inequalities, the difference vector
is set to zero when it's value is lesser than zero (i.e. when the restriction is satisfied). The
algorithm iterates until either the tolerance is met, the number of allowed iterations is
exceeded or divergence is detected.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+project">project</a></code>, <code><a href="#topic+sparse_constraints">sparse_constraints</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# the system 
# x + y = 10
# -x &lt;= 0   # ==&gt; x &gt; 0
# -y &lt;= 0   # ==&gt; y &gt; 0
# Defined in the row-column-coefficient form:

A &lt;- data.frame(
    row = c(1,1,2,3)
  , col = c(1,2,1,2)
  , coef= c(1,1,-1,-1)
)
b &lt;- c(10,0,0)

sparse_project(x=c(4,5),A=A,b=b)

</code></pre>

<hr>
<h2 id='subst_value'>Substitute a value in a system of linear (in)equations</h2><span id='topic+subst_value'></span>

<h3>Description</h3>

<p>Substitute a value in a system of linear (in)equations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subst_value(A, b, variables, values, remove_columns = FALSE, eps = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subst_value_+3A_a">A</code></td>
<td>
<p><code>[numeric]</code> matrix</p>
</td></tr>
<tr><td><code id="subst_value_+3A_b">b</code></td>
<td>
<p><code>[numeric]</code> vector</p>
</td></tr>
<tr><td><code id="subst_value_+3A_variables">variables</code></td>
<td>
<p><code>[numeric|logical|character]</code> vector of column indices in <code>A</code></p>
</td></tr>
<tr><td><code id="subst_value_+3A_values">values</code></td>
<td>
<p><code>[numeric]</code> vecor of values to substitute.</p>
</td></tr>
<tr><td><code id="subst_value_+3A_remove_columns">remove_columns</code></td>
<td>
<p><code>[logical]</code> Remove spurious columns when substituting?</p>
</td></tr>
<tr><td><code id="subst_value_+3A_eps">eps</code></td>
<td>
<p><code>[numeric]</code> scalar. Any value with absolute value below <code>eps</code> will be 
interpreted as zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the following components:
</p>

<ul>
<li><p><code>A</code>: the <code>A</code> corresponding to the simplified sytem.
</p>
</li>
<li><p><code>b</code>: the constant vector corresponding to the new system
</p>
</li></ul>



<h3>Details</h3>

<p>A system of the form <code>Ax &lt;= b</code> can be simplified if one or more of the
<code>x[i]</code> values is fixed.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
