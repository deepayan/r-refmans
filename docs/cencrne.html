<!DOCTYPE html><html lang="en"><head><title>Help for package cencrne</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cencrne}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#evaluation'><p>Consistent Estimation of the Number of Communities via Regularized Network Embedding.</p></a></li>
<li><a href='#example.data'><p>Some example data</p></a></li>
<li><a href='#gen.int'><p>Consistent Estimation of the Number of Communities via Regularized Network Embedding.</p></a></li>
<li><a href='#genelambda.obo'><p>Generate tuning parameters</p></a></li>
<li><a href='#network.comm.num'><p>Consistent Estimation of the Number of Communities via Regularized Network Embedding.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Consistent Estimation of the Number of Communities via
Regularized Network Embedding</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>The network analysis plays an important role in numerous application domains including biomedicine. 
             Estimation of the number of communities is a fundamental and critical issue in network analysis. Most existing studies assume that the number of communities is known a priori, or lack of rigorous theoretical guarantee on the estimation consistency. This method proposes a regularized network embedding model to simultaneously estimate the community structure and the number of communities in a unified formulation. 
	           The proposed model equips network embedding with a novel composite regularization term, which pushes the embedding vector towards its center and collapses similar community centers with each other. A rigorous theoretical analysis is conducted, establishing asymptotic consistency in terms of community detection and estimation of the number of communities. 
	           Reference: 
             Ren, M., Zhang S. and Wang J. (2022). "Consistent Estimation of the Number of Communities via Regularized Network Embedding". Biometrics, &lt;<a href="https://doi.org/10.1111%2Fbiom.13815">doi:10.1111/biom.13815</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, Matrix</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-27 15:56:52 UTC; 10259</td>
</tr>
<tr>
<td>Author:</td>
<td>Mingyang Ren <a href="https://orcid.org/0000-0002-8061-9940"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Sanguo Zhang [aut],
  Junhui Wang [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mingyang Ren &lt;renmingyang17@mails.ucas.ac.cn&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-09 10:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='evaluation'>Consistent Estimation of the Number of Communities via Regularized Network Embedding.</h2><span id='topic+evaluation'></span>

<h3>Description</h3>

<p>The evaluation function for Consistent Estimation of the Number of Communities via Regularized Network Embedding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluation(Z.hat, Z.true, cluster.matrix.hat, cluster.matrix.true,
                  P.true, Theta.true, K.hat=4, K.true=4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evaluation_+3A_z.hat">Z.hat</code></td>
<td>
<p>A n * r matrix, the estimated embedding vectors corresponding to n nodes.</p>
</td></tr>
<tr><td><code id="evaluation_+3A_z.true">Z.true</code></td>
<td>
<p>A n * r matrix, the true embedding vectors corresponding to n nodes.</p>
</td></tr>
<tr><td><code id="evaluation_+3A_cluster.matrix.hat">cluster.matrix.hat</code></td>
<td>
<p>A n * n estimated membership matrix, whose (i,j)-element is 1, if nodes i and j are estimated to belong to the same community, and 0, otherwise.</p>
</td></tr>
<tr><td><code id="evaluation_+3A_cluster.matrix.true">cluster.matrix.true</code></td>
<td>
<p>A n * n true membership matrix, whose (i,j)-element is 1, if nodes i and j belong to the same community, and 0, otherwise.</p>
</td></tr>
<tr><td><code id="evaluation_+3A_p.true">P.true</code></td>
<td>
<p>A n * n true probability matrix.</p>
</td></tr>
<tr><td><code id="evaluation_+3A_theta.true">Theta.true</code></td>
<td>
<p>A n * n true matrix: Z.true %*% t(Z.true).</p>
</td></tr>
<tr><td><code id="evaluation_+3A_k.hat">K.hat</code></td>
<td>
<p>The true number of communities.</p>
</td></tr>
<tr><td><code id="evaluation_+3A_k.true">K.true</code></td>
<td>
<p>The estimated number of communities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector including five evaluation index.
prop. 1: the estimated and actual number of communities are equal; 0: not equal.
</p>


<h3>Author(s)</h3>

<p>Mingyang Ren.
</p>

<hr>
<h2 id='example.data'>Some example data</h2><span id='topic+example.data'></span>

<h3>Description</h3>

<p>Some example data
</p>


<h3>Format</h3>

<p>A list including:
A: An observed n * n adjacency matrix of undirected graph, n=360.
K.true: The estimated number of communities.
Z.true: A n * r matrix, the true embedding vectors corresponding to n nodes, n=360, r=5.
B.true: A n * r matrix, the true community centers corresponding to n nodes.
P.true: A n * n true probability matrix.
Theta.true: A n * n true matrix: Z.true %*% t(Z.true).
cluster.matrix.true: A n * n true membership matrix, whose (i,j)-element is 1, if nodes i and j belong to the same community, and 0, otherwise.
</p>


<h3>Source</h3>

<p>Simulated data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example.data)
</code></pre>

<hr>
<h2 id='gen.int'>Consistent Estimation of the Number of Communities via Regularized Network Embedding.</h2><span id='topic+gen.int'></span>

<h3>Description</h3>

<p>The function generating the initial values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.int(A, R=8, K.max0=8,rand.seed=123,
               lambda3=0, a=3, kappa=1, alpha=1,
               eps = 1e-2, niter = 20, niter.Z=5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen.int_+3A_a">A</code></td>
<td>
<p>An observed n * n adjacency matrix of undirected graph.</p>
</td></tr>
<tr><td><code id="gen.int_+3A_r">R</code></td>
<td>
<p>Int, the relatively large dimension of embedding vectors given in advance.</p>
</td></tr>
<tr><td><code id="gen.int_+3A_k.max0">K.max0</code></td>
<td>
<p>The relatively large upper bound of the number of communities given in advance to generate initial values of B.</p>
</td></tr>
<tr><td><code id="gen.int_+3A_rand.seed">rand.seed</code></td>
<td>
<p>The random seed of generating initial value.</p>
</td></tr>
<tr><td><code id="gen.int_+3A_lambda3">lambda3</code></td>
<td>
<p>A float value, the tuning parameter for sparsity of Z.</p>
</td></tr>
<tr><td><code id="gen.int_+3A_a">a</code></td>
<td>
<p>A float value, regularization parameter in MCP, the default setting is 3.</p>
</td></tr>
<tr><td><code id="gen.int_+3A_kappa">kappa</code></td>
<td>
<p>A float value, the penalty parameter in ADMM algorithm, the default setting is 1.</p>
</td></tr>
<tr><td><code id="gen.int_+3A_alpha">alpha</code></td>
<td>
<p>A float value, the step size of coordinate descent algorithm updating Z, the default setting is 1.</p>
</td></tr>
<tr><td><code id="gen.int_+3A_eps">eps</code></td>
<td>
<p>A float value, algorithm termination threshold.</p>
</td></tr>
<tr><td><code id="gen.int_+3A_niter">niter</code></td>
<td>
<p>Int, maximum number of cycles of the overall ADMM algorithm.</p>
</td></tr>
<tr><td><code id="gen.int_+3A_niter.z">niter.Z</code></td>
<td>
<p>Int, maximum number of cycles of coordinate descent algorithm updating Z.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including all estimated parameters and the BIC values with all choices of given tuning parameters, and the selected optional parameters.
Opt_Z: A n * r matrix, the estimated embedding vectors corresponding to n nodes;
Opt_B: A n * r matrix, the estimated community centers corresponding to n nodes;
Opt_K: Int, the estimated number of communities;
Opt_member: A n-dimensional vector, describing the membership of n nodes;
Opt_cluster.matrix: A n * n membership matrix, whose (i,j)-element is 1, if nodes i and j belong to the same community, and 0, otherwise.
</p>


<h3>Author(s)</h3>

<p>Mingyang Ren.
</p>


<h3>References</h3>

<p>Ren, M., Zhang S., Zhang Q. and Ma S. (2022). Consistent Estimation of the Number of Communities via Regularized Network Embedding.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cencrne)
data(example.data)
A                   = example.data$A
K.true              = example.data$K.true
Z.true              = example.data$Z.true
B.true              = example.data$B.true
P.true              = example.data$P.true
Theta.true          = example.data$Theta.true
cluster.matrix.true = example.data$cluster.matrix.true

n              = dim(A)[1]
sample.index.n = rbind(combn(n,2),1:(n*(n-1)/2))
int.list       = gen.int(A)
Z.int          = int.list$Z.int
B.int          = int.list$B.int



</code></pre>

<hr>
<h2 id='genelambda.obo'>Generate tuning parameters</h2><span id='topic+genelambda.obo'></span>

<h3>Description</h3>

<p>Generating a sequence of the tuning parameters (lambda1, lambda2, and lambda3).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genelambda.obo(nlambda1=10,lambda1_max=1,lambda1_min=0.05,
                      nlambda2=10,lambda2_max=1,lambda2_min=0.01,
                      nlambda3=10,lambda3_max=5,lambda3_min=0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genelambda.obo_+3A_nlambda1">nlambda1</code></td>
<td>
<p>The numbers of lambda 1.</p>
</td></tr>
<tr><td><code id="genelambda.obo_+3A_lambda1_max">lambda1_max</code></td>
<td>
<p>The maximum values of lambda 1.</p>
</td></tr>
<tr><td><code id="genelambda.obo_+3A_lambda1_min">lambda1_min</code></td>
<td>
<p>The minimum values of lambda 1.</p>
</td></tr>
<tr><td><code id="genelambda.obo_+3A_nlambda2">nlambda2</code></td>
<td>
<p>The numbers of lambda 2.</p>
</td></tr>
<tr><td><code id="genelambda.obo_+3A_lambda2_max">lambda2_max</code></td>
<td>
<p>The maximum values of lambda 2.</p>
</td></tr>
<tr><td><code id="genelambda.obo_+3A_lambda2_min">lambda2_min</code></td>
<td>
<p>The minimum values of lambda 2.</p>
</td></tr>
<tr><td><code id="genelambda.obo_+3A_nlambda3">nlambda3</code></td>
<td>
<p>The numbers of lambda 3.</p>
</td></tr>
<tr><td><code id="genelambda.obo_+3A_lambda3_max">lambda3_max</code></td>
<td>
<p>The maximum values of lambda 3.</p>
</td></tr>
<tr><td><code id="genelambda.obo_+3A_lambda3_min">lambda3_min</code></td>
<td>
<p>The minimum values of lambda 3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sequence of the tuning parameters (lambda1, lambda2, and lambda3).
</p>


<h3>Author(s)</h3>

<p>Mingyang Ren
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lambda &lt;- genelambda.obo(nlambda1=5,lambda1_max=0.5,lambda1_min=0.1, nlambda2=15,lambda2_max=1.5,
                         lambda2_min=0.1, nlambda3=10,lambda3_max=3.5,lambda3_min=0.5)
lambda
</code></pre>

<hr>
<h2 id='network.comm.num'>Consistent Estimation of the Number of Communities via Regularized Network Embedding.</h2><span id='topic+network.comm.num'></span>

<h3>Description</h3>

<p>The main function for Consistent Estimation of the Number of Communities via Regularized Network Embedding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network.comm.num(A, sample.index.n, lambda, Z.int, B.int,
                        a=3, kappa=1, alpha=1, eps=5e-2, niter=20,
               niter.Z=5, update.B="ADMM",local.oppro=FALSE, merge.all=TRUE,
               ad.BIC=FALSE, Fully.Connected=TRUE, trace=FALSE,
               line.search=TRUE, ad.BIC.B=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="network.comm.num_+3A_a">A</code></td>
<td>
<p>An observed n * n adjacency matrix of undirected graph.</p>
</td></tr>
<tr><td><code id="network.comm.num_+3A_sample.index.n">sample.index.n</code></td>
<td>
<p>A 3 * (n*(n-1)/2) matrix, all pairs of integers from 1 to n.</p>
</td></tr>
<tr><td><code id="network.comm.num_+3A_lambda">lambda</code></td>
<td>
<p>A list, the sequences of the tuning parameters (<code class="reqn">\lambda_1</code>, <code class="reqn">\lambda_2</code>, and <code class="reqn">\lambda_3</code>).</p>
</td></tr>
<tr><td><code id="network.comm.num_+3A_z.int">Z.int</code></td>
<td>
<p>A n * r matrix, the initial values of embedding vectors corresponding to n nodes.</p>
</td></tr>
<tr><td><code id="network.comm.num_+3A_b.int">B.int</code></td>
<td>
<p>A n * r matrix, the initial values of community centers corresponding to n nodes.</p>
</td></tr>
<tr><td><code id="network.comm.num_+3A_a">a</code></td>
<td>
<p>A float value, regularization parameter in MCP, the default setting is 3.</p>
</td></tr>
<tr><td><code id="network.comm.num_+3A_kappa">kappa</code></td>
<td>
<p>A float value, the penalty parameter in ADMM algorithm, the default setting is 1.</p>
</td></tr>
<tr><td><code id="network.comm.num_+3A_alpha">alpha</code></td>
<td>
<p>A float value, the step size of coordinate descent algorithm updating Z, the default setting is 1.</p>
</td></tr>
<tr><td><code id="network.comm.num_+3A_eps">eps</code></td>
<td>
<p>A float value, algorithm termination threshold.</p>
</td></tr>
<tr><td><code id="network.comm.num_+3A_niter">niter</code></td>
<td>
<p>Int, maximum number of cycles of the overall ADMM algorithm.</p>
</td></tr>
<tr><td><code id="network.comm.num_+3A_niter.z">niter.Z</code></td>
<td>
<p>Int, maximum number of cycles of coordinate descent algorithm updating Z.</p>
</td></tr>
<tr><td><code id="network.comm.num_+3A_update.b">update.B</code></td>
<td>
<p>The optimization algorithm updating B, which can be selected &quot;ADMM&quot; (default) and &quot;AMA&quot;.</p>
</td></tr>
<tr><td><code id="network.comm.num_+3A_local.oppro">local.oppro</code></td>
<td>
<p>The logical variable, whether to use local approximations when updating Z, the default setting is F.</p>
</td></tr>
<tr><td><code id="network.comm.num_+3A_merge.all">merge.all</code></td>
<td>
<p>Whether to merge pairs of nodes indirectly connected (but without the direct edge) in the estimated community membership matrix.</p>
</td></tr>
<tr><td><code id="network.comm.num_+3A_ad.bic">ad.BIC</code></td>
<td>
<p>Whether to use the adjusted BIC, the default setting is F.</p>
</td></tr>
<tr><td><code id="network.comm.num_+3A_fully.connected">Fully.Connected</code></td>
<td>
<p>Whether to use the all pairs (i,j) in fusion penalty, the default setting is T. If F, the pairs (i,j) in fusion penalty will be determined by the observed n * n adjacency matrix A.</p>
</td></tr>
<tr><td><code id="network.comm.num_+3A_trace">trace</code></td>
<td>
<p>Whether to output the intermediate process of the algorithm.</p>
</td></tr>
<tr><td><code id="network.comm.num_+3A_line.search">line.search</code></td>
<td>
<p>Linear search or not, the default setting is T.</p>
</td></tr>
<tr><td><code id="network.comm.num_+3A_ad.bic.b">ad.BIC.B</code></td>
<td>
<p>Whether the BIC criterion contains terms involving the B matrix, the default setting is F.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including all estimated parameters and the BIC values with all choices of given tuning parameters, and the selected optional parameters.
Opt_Z: A n * r matrix, the estimated embedding vectors corresponding to n nodes;
Opt_B: A n * r matrix, the estimated community centers corresponding to n nodes;
Opt_K: Int, the estimated number of communities;
Opt_member: A n-dimensional vector, describing the membership of n nodes;
Opt_cluster.matrix: A n * n membership matrix, whose (i,j)-element is 1, if nodes i and j belong to the same community, and 0, otherwise.
</p>


<h3>Author(s)</h3>

<p>Mingyang Ren, Sanguo Zhang, Junhui Wang. Maintainer: Mingyang Ren <a href="mailto:renmingyang17@mails.ucas.ac.cn">renmingyang17@mails.ucas.ac.cn</a>.
</p>


<h3>References</h3>

<p>Ren, M., Zhang S. and Wang J. (2022). Consistent Estimation of the Number of Communities via Regularized Network Embedding.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(cencrne)
data(example.data)
A                   = example.data$A
K.true              = example.data$K.true
Z.true              = example.data$Z.true
B.true              = example.data$B.true
P.true              = example.data$P.true
Theta.true          = example.data$Theta.true
cluster.matrix.true = example.data$cluster.matrix.true

n       = dim(A)[1]
lam.max = 3
lam.min = 0.5
lam1.s  = 2/log(n)
lam2.s  = sqrt(8*log(n)/n)
lam3.s  = 1/8/log(n)/sqrt(n)
lambda  = genelambda.obo(nlambda1=3,lambda1_max=lam.max*lam1.s,lambda1_min=lam.min*lam1.s,
                         nlambda2=10,lambda2_max=lam.max*lam2.s,lambda2_min=lam.min*lam2.s,
                         nlambda3=1,lambda3_max=lam.max*lam3.s,lambda3_min=lam.min*lam3.s)

sample.index.n = rbind(combn(n,2),1:(n*(n-1)/2))
int.list       = gen.int(A)
Z.int          = int.list$Z.int
B.int          = int.list$B.int
res            = network.comm.num(A, sample.index.n, lambda, Z.int, B.int)

K.hat = res$Opt_K # the estimated number of communities
Z.hat = res$Opt_Z # the estimated embedding vectors corresponding to n nodes
cluster.matrix.hat = res$Opt_cluster.matrix # the n * n estimated membership matrix
evaluation(Z.hat, Z.true, cluster.matrix.hat, cluster.matrix.true,
           P.true, Theta.true, K.hat, K.true)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
