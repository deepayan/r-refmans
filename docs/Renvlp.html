<!DOCTYPE html><html><head><title>Help for package Renvlp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Renvlp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#amitriptyline'><p>Amitriptyline Data</p></a></li>
<li><a href='#Berkeley'><p>Berkeley Guidance Study Data</p></a></li>
<li><a href='#boot.env'><p>Bootstrap for env</p></a></li>
<li><a href='#boot.env.apweights'><p>Bootstrap for env.apweights</p></a></li>
<li><a href='#boot.env.tcond'><p>Bootstrap for env.tcond</p></a></li>
<li><a href='#boot.eppls'><p>Bootstrap for eppls</p></a></li>
<li><a href='#boot.genv'><p>Bootstrap for genv</p></a></li>
<li><a href='#boot.henv'><p>Bootstrap for henv</p></a></li>
<li><a href='#boot.logit.env'><p>Bootstrap for logit.env</p></a></li>
<li><a href='#boot.penv'><p>Bootstrap for penv</p></a></li>
<li><a href='#boot.pois.env'><p>Bootstrap for pois.env</p></a></li>
<li><a href='#boot.rrenv'><p>Bootstrap for rrenv</p></a></li>
<li><a href='#boot.rrenv.apweights'><p>Bootstrap for rrenv.apweights</p></a></li>
<li><a href='#boot.senv'><p>Bootstrap for senv</p></a></li>
<li><a href='#boot.stenv'><p>Bootstrap for stenv</p></a></li>
<li><a href='#boot.sxenv'><p>Bootstrap for sxenv</p></a></li>
<li><a href='#boot.xenv'><p>Bootstrap for xenv</p></a></li>
<li><a href='#concrete'><p>Concrete Slump Test Dataset</p></a></li>
<li><a href='#cv.env'><p>Cross validation for env</p></a></li>
<li><a href='#cv.env.apweights'><p>Cross validation for env.apweights</p></a></li>
<li><a href='#cv.env.tcond'><p>Cross validation for env.tcond</p></a></li>
<li><a href='#cv.eppls'><p>Cross validation for peplos</p></a></li>
<li><a href='#cv.genv'><p>Cross validation for genv</p></a></li>
<li><a href='#cv.henv'><p>Cross validation for henv</p></a></li>
<li><a href='#cv.logit.env'><p>Cross validation for logit.env</p></a></li>
<li><a href='#cv.penv'><p>Cross validation for penv</p></a></li>
<li><a href='#cv.pois.env'><p>Cross validation for pois.env</p></a></li>
<li><a href='#cv.rrenv'><p>Cross validation for rrenv</p></a></li>
<li><a href='#cv.rrenv.apweights'><p>Cross validation for rrenv.apweights</p></a></li>
<li><a href='#cv.senv'><p>Cross validation for senv</p></a></li>
<li><a href='#cv.stenv'><p>Cross validation for stenv</p></a></li>
<li><a href='#cv.sxenv'><p>Cross validation for sxenv</p></a></li>
<li><a href='#cv.xenv'><p>Cross validation for xenv</p></a></li>
<li><a href='#d.select'><p>Select the rank of beta</p></a></li>
<li><a href='#env'><p>Fit the response envelope model</p></a></li>
<li><a href='#env.apweights'><p>Fit the envelope model with nonconstant variance</p></a></li>
<li><a href='#env.tcond'><p>Fit the envelope model with t-distributed errors</p></a></li>
<li><a href='#eppls'>
<p>Fit the Envelope-based Partial Partial Least Squares model</p></a></li>
<li><a href='#felmdir'><p>Fit the functional envelope linear model</p></a></li>
<li><a href='#felmKL'><p>Fit the functional envelope linear model</p></a></li>
<li><a href='#fiberpaper'><p>Pulp and Paper Data</p></a></li>
<li><a href='#genv'><p>Fit the groupwise envelope model</p></a></li>
<li><a href='#henv'><p>Fit the heteroscedastic envelope model</p></a></li>
<li><a href='#horseshoecrab'><p>Horseshoe Crab Data</p></a></li>
<li><a href='#logit.env'><p>Fit the envelope model in logistic regression</p></a></li>
<li><a href='#NJdata'><p>New Jersey Open Covid-19 Dataset</p></a></li>
<li><a href='#penv'><p>Fit the partial envelope model</p></a></li>
<li><a href='#pois.env'><p>Fit the envelope model in poisson regression</p></a></li>
<li><a href='#pred.env'><p>Estimation or prediction for env</p></a></li>
<li><a href='#pred.env.apweights'><p>Estimation or prediction for env.apweights</p></a></li>
<li><a href='#pred.env.tcond'><p>Estimation or prediction for env.tcond</p></a></li>
<li><a href='#pred.eppls'><p>Estimation or prediction for eppls</p></a></li>
<li><a href='#pred.felmdir'><p>Estimation or prediction for felmdir</p></a></li>
<li><a href='#pred.felmKL'><p>Estimation or prediction for felmKL</p></a></li>
<li><a href='#pred.genv'><p>Estimation or prediction for genv</p></a></li>
<li><a href='#pred.henv'><p>Estimation or prediction for henv</p></a></li>
<li><a href='#pred.logit.env'><p>Estimation or prediction for logit.env</p></a></li>
<li><a href='#pred.penv'><p>Estimation or prediction for penv</p></a></li>
<li><a href='#pred.pois.env'><p>Estimation or prediction for pois.env</p></a></li>
<li><a href='#pred.rrenv'><p>Estimation or prediction for rrenv</p></a></li>
<li><a href='#pred.rrenv.apweights'><p>Estimation or prediction for rrenv.apweights</p></a></li>
<li><a href='#pred.senv'><p>Estimation or prediction for senv</p></a></li>
<li><a href='#pred.stenv'><p>Estimation or prediction for stenv</p></a></li>
<li><a href='#pred.sxenv'><p>Estimation or prediction for sxenv</p></a></li>
<li><a href='#pred.xenv'><p>Estimation or prediction for xenv</p></a></li>
<li><a href='#pred2.env'><p>Estimation or prediction for env</p></a></li>
<li><a href='#Renvlp-package'>
<p>Computing Envelope Estimators</p></a></li>
<li><a href='#rrenv'><p>Fit the reduced-rank envelope model</p></a></li>
<li><a href='#rrenv.apweights'><p>Fit the reduced-rank envelope model with nonconstant variance</p></a></li>
<li><a href='#sales'><p>Sales staff Data</p></a></li>
<li><a href='#senv'><p>Fit the scaled response envelope model</p></a></li>
<li><a href='#stenv'><p>Fit the simultaneous envelope model</p></a></li>
<li><a href='#sxenv'><p>Fit the scaled predictor envelope model</p></a></li>
<li><a href='#testcoef.env'><p>Hypothesis test of the coefficients of the response envelope model</p></a></li>
<li><a href='#testcoef.env.apweights'><p>Hypothesis test of the coefficients of the response envelope model with nonconstant variance</p></a></li>
<li><a href='#testcoef.env.tcond'><p>Hypothesis test of the coefficients of the response envelope model with t-distributed errors</p></a></li>
<li><a href='#testcoef.genv'><p>Hypothesis test of the coefficients of the groupwise envelope model</p></a></li>
<li><a href='#testcoef.henv'><p>Hypothesis test of the coefficients of the heteroscedastic envelope model</p></a></li>
<li><a href='#testcoef.logit.env'><p>Hypothesis test of the coefficients of the envelope model</p></a></li>
<li><a href='#testcoef.penv'><p>Hypothesis test of the coefficients of the partial envelope model</p></a></li>
<li><a href='#testcoef.pois.env'><p>Hypothesis test of the coefficients of the envelope model</p></a></li>
<li><a href='#testcoef.rrenv'><p>Hypothesis test of the coefficients of the reduced rank envelope model</p></a></li>
<li><a href='#testcoef.rrenv.apweights'><p>Hypothesis test of the coefficients of the reduced rank envelope model with nonconstant error variance</p></a></li>
<li><a href='#testcoef.senv'><p>Hypothesis test of the coefficients of the scaled response envelope model</p></a></li>
<li><a href='#testcoef.stenv'><p>Hypothesis test of the coefficients of the simultaneous envelope model</p></a></li>
<li><a href='#testcoef.sxenv'><p>Hypothesis test of the coefficients of the scaled predictor envelope model</p></a></li>
<li><a href='#testcoef.xenv'><p>Hypothesis test of the coefficients of the predictor envelope model</p></a></li>
<li><a href='#u.env'><p>Select the dimension of env</p></a></li>
<li><a href='#u.env.apweights'><p>Select the dimension of env.apweights</p></a></li>
<li><a href='#u.env.tcond'><p>Select the dimension of env.tcond</p></a></li>
<li><a href='#u.eppls'><p>Select the dimension of eppls</p></a></li>
<li><a href='#u.felmdir'><p>Find the envelope dimensions in the functional envelope linear model</p></a></li>
<li><a href='#u.felmKL'><p>Find the envelope dimensions in the functional envelope linear model</p></a></li>
<li><a href='#u.genv'><p>Select the dimension of genv</p></a></li>
<li><a href='#u.henv'><p>Select the dimension of henv</p></a></li>
<li><a href='#u.logit.env'><p>Select the dimension of logit.env</p></a></li>
<li><a href='#u.penv'><p>Select the dimension of penv</p></a></li>
<li><a href='#u.pois.env'><p>Select the dimension of pois.env</p></a></li>
<li><a href='#u.pred2.env'><p>Select the dimension of the constructed partial envelope for prediction based on envelope model</p></a></li>
<li><a href='#u.rrenv'><p>Select the dimension of rrenv</p></a></li>
<li><a href='#u.rrenv.apweights'><p>Select the dimension of rrenv.apweights</p></a></li>
<li><a href='#u.senv'><p>Select the dimension of senv</p></a></li>
<li><a href='#u.stenv'><p>Select the dimension of stenv</p></a></li>
<li><a href='#u.sxenv'><p>Select the dimension of sxenv</p></a></li>
<li><a href='#u.xenv'><p>Select the dimension of xenv</p></a></li>
<li><a href='#vehicles'><p>Automobile Dataset</p></a></li>
<li><a href='#waterstrider'><p>Water strider data</p></a></li>
<li><a href='#weighted.env'><p>Weighted response envelope estimator</p></a></li>
<li><a href='#weighted.penv'><p>Weighted partial envelope estimator</p></a></li>
<li><a href='#weighted.pred.env'><p>Estimation or prediction using weighted partial envelope</p></a></li>
<li><a href='#weighted.xenv'><p>Weighted predictor envelope estimator</p></a></li>
<li><a href='#wheatprotein'><p>Wheat Protein Data</p></a></li>
<li><a href='#xenv'><p>Fit the predictor envelope model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Computing Envelope Estimators</td>
</tr>
<tr>
<td>Version:</td>
<td>3.4.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-11</td>
</tr>
<tr>
<td>Author:</td>
<td>Minji Lee, Zhihua Su</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Minji Lee &lt;minjilee101@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a general routine, envMU, which allows  estimation of the M envelope of span(U) given root n consistent estimators of M and U. The routine envMU does not presume a model.  This package implements response envelopes,  partial response envelopes,  envelopes in the predictor space,  heteroscedastic envelopes,  simultaneous envelopes,  scaled response envelopes,  scaled envelopes in the predictor space,  groupwise envelopes, weighted envelopes,  envelopes in logistic regression, envelopes in Poisson regression envelopes in function-on-function linear regression, envelope-based Partial Partial Least Squares,  envelopes with non-constant error covariance, envelopes with t-distributed errors, reduced rank envelopes and reduced rank envelopes with non-constant error covariance. For each of these model-based routines the package provides inference tools including bootstrap, cross validation, estimation and prediction, hypothesis testing on coefficients are included except for weighted envelopes. Tools for selection of dimension include AIC, BIC and likelihood ratio testing.   Background is available at Cook, R. D., Forzani, L. and Su, Z. (2016) &lt;<a href="https://doi.org/10.1016%2Fj.jmva.2016.05.006">doi:10.1016/j.jmva.2016.05.006</a>&gt;. Optimization is based on a clockwise coordinate descent algorithm.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rsolnp, stats, orthogonalsplinebasis, pls, matrixcalc, Matrix</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-11 18:44:45 UTC; minjilee</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-10 21:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='amitriptyline'>Amitriptyline Data
</h2><span id='topic+amitriptyline'></span>

<h3>Description</h3>

<p>Patients who were admitted to the hospital after an amitriptyline overdose.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("amitriptyline")</code></pre>


<h3>Format</h3>

<p>A data frame with 17 observations on the following 7 variables.
</p>

<dl>
<dt><code>tot</code></dt><dd><p>Total TCAD plasma level.</p>
</dd>
<dt><code>ami</code></dt><dd><p>Amount of amitriptyline present in TCAD plasma level.</p>
</dd>
<dt><code>gen</code></dt><dd><p>Gender:1 if female, 0 if male.</p>
</dd>
<dt><code>amt</code></dt><dd><p>Amount of antidepressants taken at time of overdose.</p>
</dd>
<dt><code>pr</code></dt><dd><p>PR wave measurement.</p>
</dd>
<dt><code>diap</code></dt><dd><p>Diastolic blood pressure.</p>
</dd>
<dt><code>qrs</code></dt><dd><p>QRS wave measurement.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This data set contains measures of side effects of amitriptyline and gender information.
</p>


<h3>References</h3>

<p>Johnson, R.A., Wichern, D.W. (2007). Applied Multivariage Statistical Analysis, 6th edition.
</p>

<hr>
<h2 id='Berkeley'>Berkeley Guidance Study Data
</h2><span id='topic+Berkeley'></span>

<h3>Description</h3>

<p>Heights of children born in Berkeley</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Berkeley")</code></pre>


<h3>Format</h3>

<p>A data frame with 93 observations on the following 32 variables.
</p>

<dl>
<dt><code>V1</code></dt><dd><p>Sex.</p>
</dd>
<dt><code>V2</code></dt><dd><p>Age 1.</p>
</dd>
<dt><code>V3</code></dt><dd><p>Age 1.25.</p>
</dd>
<dt><code>V4</code></dt><dd><p>Age 1.5.</p>
</dd>
<dt><code>V5</code></dt><dd><p>Age 1.75.</p>
</dd>
<dt><code>V6</code></dt><dd><p>Age 2.</p>
</dd>
<dt><code>V7</code></dt><dd><p>Age 3.</p>
</dd>
<dt><code>V8</code></dt><dd><p>Age 4.</p>
</dd>
<dt><code>V9</code></dt><dd><p>Age 5.</p>
</dd>
<dt><code>V10</code></dt><dd><p>Age 6.</p>
</dd>
<dt><code>V11</code></dt><dd><p>Age 7.</p>
</dd>
<dt><code>V12</code></dt><dd><p>Age 8.</p>
</dd>
<dt><code>V13</code></dt><dd><p>Age 8.5.</p>
</dd>
<dt><code>V14</code></dt><dd><p>Age 9.</p>
</dd>
<dt><code>V15</code></dt><dd><p>Age 9.5.</p>
</dd>
<dt><code>V16</code></dt><dd><p>Age 10.</p>
</dd>
<dt><code>V17</code></dt><dd><p>Age 10.5.</p>
</dd>
<dt><code>V18</code></dt><dd><p>Age 11.</p>
</dd>
<dt><code>V19</code></dt><dd><p>Age 11.5.</p>
</dd>
<dt><code>V20</code></dt><dd><p>Age 12.</p>
</dd>
<dt><code>V21</code></dt><dd><p>Age 12.5.</p>
</dd>
<dt><code>V22</code></dt><dd><p>Age 13.</p>
</dd>
<dt><code>V23</code></dt><dd><p>Age 13.5.</p>
</dd>
<dt><code>V24</code></dt><dd><p>Age 14.</p>
</dd>
<dt><code>V25</code></dt><dd><p>Age 14.5.</p>
</dd>
<dt><code>V26</code></dt><dd><p>Age 15.</p>
</dd>
<dt><code>V27</code></dt><dd><p>Age 15.5.</p>
</dd>
<dt><code>V28</code></dt><dd><p>Age 16.</p>
</dd>
<dt><code>V29</code></dt><dd><p>Age 16.5.</p>
</dd>
<dt><code>V30</code></dt><dd><p>Age 17.</p>
</dd>
<dt><code>V31</code></dt><dd><p>Age 17.5.</p>
</dd>
<dt><code>V32</code></dt><dd><p>Age 18.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This data set contains measurements of heights of children born in 1928-29 in Berkeley, CA. 
</p>


<h3>References</h3>

<p>Tuddenham, R. D. and Snyder, M. M. (1954). Physical growth of California boys and girls from birth to eighteen years. Publications in child developments. University of California, Berkeley, 1(2), 183-364.
</p>

<hr>
<h2 id='boot.env'>Bootstrap for env</h2><span id='topic+boot.env'></span>

<h3>Description</h3>

<p>Compute bootstrap standard error for the response envelope estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.env(X, Y, u, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.env_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="boot.env_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="boot.env_+3A_u">u</code></td>
<td>
<p>Dimension of the envelope. An integer between 0 and r.</p>
</td></tr>
<tr><td><code id="boot.env_+3A_b">B</code></td>
<td>
<p>Number of bootstrap samples. A positive integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the bootstrap standard errors for the regression coefficients in the envelope model by bootstrapping the residuals.
</p>


<h3>Value</h3>

<p>The output is an r by p matrix.
</p>
<table>
<tr><td><code>bootse</code></td>
<td>
<p>The standard error for elements in beta computed by bootstrap.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(wheatprotein)
X &lt;- wheatprotein[, 8]
Y &lt;- wheatprotein[, 1:6]

u &lt;- u.env(X, Y)
u

B &lt;- 100
bootse &lt;- boot.env(X, Y, 1, B)
bootse
</code></pre>

<hr>
<h2 id='boot.env.apweights'>Bootstrap for env.apweights</h2><span id='topic+boot.env.apweights'></span>

<h3>Description</h3>

<p>Compute bootstrap standard error for the response envelope estimator that accommodates nonconstant variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.env.apweights(X, Y, u, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.env.apweights_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="boot.env.apweights_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="boot.env.apweights_+3A_u">u</code></td>
<td>
<p>Dimension of the envelope. An integer between 0 and r.</p>
</td></tr>
<tr><td><code id="boot.env.apweights_+3A_b">B</code></td>
<td>
<p>Number of bootstrap samples. A positive integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the bootstrap standard errors for the regression coefficients in the envelope model with nonconstant variance by bootstrapping the residuals.
</p>


<h3>Value</h3>

<p>The output is an r by p matrix.
</p>
<table>
<tr><td><code>bootse</code></td>
<td>
<p>The standard error for elements in beta computed by bootstrap.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(concrete)
X &lt;- concrete[, 1:7]
Y &lt;- concrete[, 8:10]

## Not run: u &lt;- u.env.apweights(X, Y)
## Not run: u

B &lt;- 100
## Not run: bootse &lt;- boot.env.apweights(X, Y, 1, B)
## Not run: bootse
</code></pre>

<hr>
<h2 id='boot.env.tcond'>Bootstrap for env.tcond</h2><span id='topic+boot.env.tcond'></span>

<h3>Description</h3>

<p>Compute bootstrap standard error for the response envelope estimator with t-distributed errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.env.tcond(X, Y, u, df, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.env.tcond_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="boot.env.tcond_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="boot.env.tcond_+3A_u">u</code></td>
<td>
<p>Dimension of the envelope. An integer between 0 and r.</p>
</td></tr>
<tr><td><code id="boot.env.tcond_+3A_df">df</code></td>
<td>
<p>Degrees of freedom of the t-distribution. A positive number that is greater than 2.</p>
</td></tr>
<tr><td><code id="boot.env.tcond_+3A_b">B</code></td>
<td>
<p>Number of bootstrap samples. A positive integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the bootstrap standard errors for the regression coefficients in the envelope model with t-distributed errors by bootstrapping the residuals.
</p>


<h3>Value</h3>

<p>The output is an r by p matrix.
</p>
<table>
<tr><td><code>bootse</code></td>
<td>
<p>The standard error for elements in beta computed by bootstrap.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(concrete)
X &lt;- concrete[1:78, 1:7]  # The first 78 observations are training data
Y &lt;- concrete[1:78, 8:10]

## Not run: u &lt;- u.env.tcond(X, Y, 6)
## Not run: u

B &lt;- 100
## Not run: bootse &lt;- boot.env.tcond(X, Y, 2, 6, B)
## Not run: bootse
</code></pre>

<hr>
<h2 id='boot.eppls'>Bootstrap for eppls</h2><span id='topic+boot.eppls'></span>

<h3>Description</h3>

<p>Compute bootstrap standard error for the Envelope-based Partial Partial Least Squares estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.eppls(X1, X2, Y, u, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.eppls_+3A_x1">X1</code></td>
<td>

<p>An <code class="reqn">n</code> by <code class="reqn">p1</code> matrix of continuous predictors, where <code class="reqn">p1</code> is the  number of continuous predictors with <code class="reqn">p1 &lt; n</code>.
</p>
</td></tr>
<tr><td><code id="boot.eppls_+3A_x2">X2</code></td>
<td>

<p>An <code class="reqn">n</code> by <code class="reqn">p2</code> matrix of categorical predictors, where <code class="reqn">p2</code> is the  number of categorical predictors with <code class="reqn">p2 &lt; n</code>.
</p>
</td></tr>
<tr><td><code id="boot.eppls_+3A_y">Y</code></td>
<td>

<p>An <code class="reqn">n</code> by <code class="reqn">r</code> matrix of multivariate responses, where <code class="reqn">r</code> is the number of responses.
</p>
</td></tr>
<tr><td><code id="boot.eppls_+3A_u">u</code></td>
<td>

<p>A given dimension of the Envelope-based Partial Partial Least Squares.  It should be an interger between <code class="reqn">0</code> and <code class="reqn">p1</code>.
</p>
</td></tr>
<tr><td><code id="boot.eppls_+3A_b">B</code></td>
<td>

<p>Number of bootstrap samples. A positive integer.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the bootstrap standard errors for the regression coefficients beta1 and beta2 in the Envelope-based Partial Partial Least Squares by bootstrapping the residuals.
</p>


<h3>Value</h3>

<p>The output is a list that contains the following components:
</p>
<table>
<tr><td><code>bootse1</code></td>
<td>

<p>The standard error for elements in beta1 computed by bootstrap. The output is an p1 by r matrix.
</p>
</td></tr> 
<tr><td><code>bootse1</code></td>
<td>

<p>The standard error for elements in beta2 computed by bootstrap. The output is an p2 by r matrix.
</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(amitriptyline)
  
Y &lt;- amitriptyline[ , 1:2]
X1 &lt;- amitriptyline[ , 4:7]
X2 &lt;- amitriptyline[ , 3]

B &lt;- 100
## Not run: bootse &lt;- boot.eppls(X1, X2, Y, 2, B)
## Not run: bootse
</code></pre>

<hr>
<h2 id='boot.genv'>Bootstrap for genv</h2><span id='topic+boot.genv'></span>

<h3>Description</h3>

<p>Compute bootstrap standard error for the groupwise envelope.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.genv(X, Y, Z, u, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.genv_+3A_x">X</code></td>
<td>

<p>Predictors. An n by p matrix, p is the number of predictors. The 
predictors can be univariate or multivariate, discrete or 
continuous.  
</p>
</td></tr>
<tr><td><code id="boot.genv_+3A_y">Y</code></td>
<td>

<p>Multivariate responses. An n by r matrix, r is the number of 
responses and n is number of observations. The responses must be 
continuous variables.
</p>
</td></tr>
<tr><td><code id="boot.genv_+3A_z">Z</code></td>
<td>

<p>A group indicator vector of length <code class="reqn">n</code>, where <code class="reqn">n</code> 
denotes the number of observations.	
</p>
</td></tr>
<tr><td><code id="boot.genv_+3A_u">u</code></td>
<td>

<p>Dimension of the groupwise envelope. An integer between 0 and r.
</p>
</td></tr>
<tr><td><code id="boot.genv_+3A_b">B</code></td>
<td>

<p>Number of bootstrap samples. A positive integer.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the bootstrap standard errors for the regression coefficients in the groupwise envelope model by bootstrapping the residuals.
</p>


<h3>Value</h3>

<p>The output is an p by r matrix.
</p>
<table>
<tr><td><code>bootse</code></td>
<td>
<p>The standard error for elements in beta computed by bootstrap.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(fiberpaper)
X &lt;- fiberpaper[ , c(5, 7)]
Y &lt;- fiberpaper[ , 1:3]
Z &lt;- as.numeric(fiberpaper[ , 6] &gt; mean(fiberpaper[ , 6]))

## Not run: B &lt;- 100
## Not run: res &lt;- boot.genv(X, Y, Z, 2, B)
## Not run: res$bootse[[1]]
## Not run: res$bootse[[2]]

</code></pre>

<hr>
<h2 id='boot.henv'>Bootstrap for henv</h2><span id='topic+boot.henv'></span>

<h3>Description</h3>

<p>Compute bootstrap standard error for the heteroscedastic envelope.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.henv(X, Y, u, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.henv_+3A_x">X</code></td>
<td>

<p>A group indicator vector of length <code class="reqn">n</code>, where <code class="reqn">n</code> denotes the number of observations.
</p>
</td></tr>
<tr><td><code id="boot.henv_+3A_y">Y</code></td>
<td>

<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.
</p>
</td></tr>
<tr><td><code id="boot.henv_+3A_u">u</code></td>
<td>

<p>Dimension of the heteroscedastic envelope. An integer between 0 and 
r.
</p>
</td></tr>
<tr><td><code id="boot.henv_+3A_b">B</code></td>
<td>

<p>Number of bootstrap samples. A positive integer.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the bootstrap standard errors for the regression coefficients in the heteroscedastic envelope model by bootstrapping the residuals.
</p>


<h3>Value</h3>

<p>The output is an r by p matrix.
</p>
<table>
<tr><td><code>bootse</code></td>
<td>
<p>The standard error for elements in beta computed by bootstrap.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(waterstrider)
X &lt;- waterstrider[ , 1]
Y &lt;- waterstrider[ , 2:5]

B &lt;- 100
## Not run: res &lt;- boot.henv(X, Y, 2, B)
## Not run: res

</code></pre>

<hr>
<h2 id='boot.logit.env'>Bootstrap for logit.env</h2><span id='topic+boot.logit.env'></span>

<h3>Description</h3>

<p>Compute bootstrap standard error for the envelope estimator in logistic regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.logit.env(X, Y, u, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.logit.env_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors and n is number of observations.  The predictors must be continuous variables.</p>
</td></tr>
<tr><td><code id="boot.logit.env_+3A_y">Y</code></td>
<td>
<p>Response. An n by 1 matrix. The univariate response must be binary.</p>
</td></tr>
<tr><td><code id="boot.logit.env_+3A_u">u</code></td>
<td>
<p>Dimension of the envelope. An integer between 0 and p.</p>
</td></tr>
<tr><td><code id="boot.logit.env_+3A_b">B</code></td>
<td>
<p>Number of bootstrap samples. A positive integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the bootstrap standard errors for the coefficients in the logistic regression envelope by the paired bootstrap.
</p>


<h3>Value</h3>

<p>The output is a p by 1 matrix.
</p>
<table>
<tr><td><code>bootse</code></td>
<td>
<p>The standard error for elements in beta computed by bootstrap.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(horseshoecrab)	
X1 &lt;- as.numeric(horseshoecrab[ , 1] == 2)
X2 &lt;- as.numeric(horseshoecrab[ , 1] == 3)
X3 &lt;- as.numeric(horseshoecrab[ , 1] == 4)
X4 &lt;- as.numeric(horseshoecrab[ , 2] == 2)
X5 &lt;- as.numeric(horseshoecrab[ , 2] == 3)
X6 &lt;- horseshoecrab[ , 3]
X7 &lt;- horseshoecrab[ , 5]
X &lt;- cbind(X1, X2, X3, X4, X5, X6, X7)
Y &lt;- as.numeric(ifelse(horseshoecrab[ , 4] &gt; 0, 1, 0))

B &lt;- 100
## Not run: bootse &lt;- boot.logit.env(X, Y, 1, B)
## Not run: bootse
</code></pre>

<hr>
<h2 id='boot.penv'>Bootstrap for penv</h2><span id='topic+boot.penv'></span>

<h3>Description</h3>

<p>Compute bootstrap standard error for the partial envelope estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.penv(X1, X2, Y, u, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.penv_+3A_x1">X1</code></td>
<td>
<p>Predictors of main interest. An n by p1 matrix, n is the number of observations, and p1 is the number of main predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="boot.penv_+3A_x2">X2</code></td>
<td>
<p>Covariates, or predictors not of main interest.  An n by p2 matrix, p2 is the number of covariates.</p>
</td></tr>
<tr><td><code id="boot.penv_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="boot.penv_+3A_u">u</code></td>
<td>
<p>Dimension of the partial envelope. An integer between 0 and r.</p>
</td></tr>
<tr><td><code id="boot.penv_+3A_b">B</code></td>
<td>
<p>Number of bootstrap samples. A positive integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the bootstrap standard errors for the regression coefficients beta1 in the partial envelope model by bootstrapping the residuals.
</p>


<h3>Value</h3>

<p>The output is an r by p1 matrix.
</p>
<table>
<tr><td><code>bootse</code></td>
<td>
<p>The standard error for elements in beta1 computed by bootstrap.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(fiberpaper)
X1 &lt;- fiberpaper[, 7]
X2 &lt;- fiberpaper[, 5:6]
Y &lt;- fiberpaper[, 1:4]

B &lt;- 100
## Not run: bootse &lt;- boot.penv(X1, X2, Y, 1, B)
## Not run: bootse
</code></pre>

<hr>
<h2 id='boot.pois.env'>Bootstrap for pois.env</h2><span id='topic+boot.pois.env'></span>

<h3>Description</h3>

<p>Compute bootstrap standard error for the envelope estimator in poisson regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.pois.env(X, Y, u, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.pois.env_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors and n is number of observations.  The predictors must be continuous variables.</p>
</td></tr>
<tr><td><code id="boot.pois.env_+3A_y">Y</code></td>
<td>
<p>Response. An n by 1 matrix. The univariate response must be counts.</p>
</td></tr>
<tr><td><code id="boot.pois.env_+3A_u">u</code></td>
<td>
<p>Dimension of the envelope. An integer between 0 and p.</p>
</td></tr>
<tr><td><code id="boot.pois.env_+3A_b">B</code></td>
<td>
<p>Number of bootstrap samples. A positive integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the bootstrap standard errors for the coefficients in the poisson regression envelope by the paired bootstrap.
</p>


<h3>Value</h3>

<p>The output is a p by 1 matrix.
</p>
<table>
<tr><td><code>bootse</code></td>
<td>
<p>The standard error for elements in beta computed by bootstrap.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(horseshoecrab)
X1 &lt;- as.numeric(horseshoecrab[ , 1] == 2)
X2 &lt;- as.numeric(horseshoecrab[ , 1] == 3)
X3 &lt;- as.numeric(horseshoecrab[ , 1] == 4)
X4 &lt;- as.numeric(horseshoecrab[ , 2] == 2)
X5 &lt;- as.numeric(horseshoecrab[ , 2] == 3)
X6 &lt;- horseshoecrab[ , 3]
X7 &lt;- horseshoecrab[ , 5]
X &lt;- cbind(X1, X2, X3, X4, X5, X6, X7)
Y &lt;- horseshoecrab[ , 4]

B &lt;- 100
## Not run: bootse &lt;- boot.pois.env(X, Y, 1, B)
## Not run: bootse
</code></pre>

<hr>
<h2 id='boot.rrenv'>Bootstrap for rrenv</h2><span id='topic+boot.rrenv'></span>

<h3>Description</h3>

<p>Compute bootstrap standard error for the reduced rank envelope estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.rrenv(X, Y, u, d, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.rrenv_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="boot.rrenv_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="boot.rrenv_+3A_u">u</code></td>
<td>
<p>Dimension of the envelope. An integer between 0 and r.</p>
</td></tr>
<tr><td><code id="boot.rrenv_+3A_d">d</code></td>
<td>
<p>The rank of the coefficient matrix.  An integer between 0 and u.</p>
</td></tr>
<tr><td><code id="boot.rrenv_+3A_b">B</code></td>
<td>
<p>Number of bootstrap samples. A positive integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the bootstrap standard errors for the regression coefficients in the reduced rank envelope model.
</p>


<h3>Value</h3>

<p>The output is an r by p matrix.
</p>
<table>
<tr><td><code>bootse</code></td>
<td>
<p>The standard error for elements in beta computed by bootstrap.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(vehicles)
X &lt;- vehicles[, 1:11]  
Y &lt;- vehicles[, 12:15]
X &lt;- scale(X)
Y &lt;- scale(Y)  # The scales of Y are vastly different, so scaling is reasonable here

B &lt;- 100
## Not run: bootse &lt;- boot.rrenv(X, Y, 4, 2, B)
## Not run: bootse
</code></pre>

<hr>
<h2 id='boot.rrenv.apweights'>Bootstrap for rrenv.apweights</h2><span id='topic+boot.rrenv.apweights'></span>

<h3>Description</h3>

<p>Compute bootstrap standard error for the reduced rank envelope estimator with nonconstant error covariance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.rrenv.apweights(X, Y, u, d, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.rrenv.apweights_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="boot.rrenv.apweights_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="boot.rrenv.apweights_+3A_u">u</code></td>
<td>
<p>Dimension of the envelope. An integer between 0 and r.</p>
</td></tr>
<tr><td><code id="boot.rrenv.apweights_+3A_d">d</code></td>
<td>
<p>The rank of the coefficient matrix.  An integer between 0 and u.</p>
</td></tr>
<tr><td><code id="boot.rrenv.apweights_+3A_b">B</code></td>
<td>
<p>Number of bootstrap samples. A positive integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the bootstrap standard errors for the regression coefficients in the reduced rank envelope model that accommodates nonconstant error covariance.
</p>


<h3>Value</h3>

<p>The output is an r by p matrix.
</p>
<table>
<tr><td><code>bootse</code></td>
<td>
<p>The standard error for elements in beta computed by bootstrap.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(vehicles)
X &lt;- vehicles[, 1:11]  
Y &lt;- vehicles[, 12:15]
X &lt;- scale(X)
Y &lt;- scale(Y)  # The scales of Y are vastly different, so scaling is reasonable here

B &lt;- 10
## Not run: bootse &lt;- boot.rrenv.apweights(X, Y, 3, 2, B)
## Not run: bootse
</code></pre>

<hr>
<h2 id='boot.senv'>Bootstrap for senv</h2><span id='topic+boot.senv'></span>

<h3>Description</h3>

<p>Compute bootstrap standard error for the scaled response envelope estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.senv(X, Y, u, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.senv_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="boot.senv_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="boot.senv_+3A_u">u</code></td>
<td>
<p>Dimension of the scaled envelope. An integer between 0 and r.</p>
</td></tr>
<tr><td><code id="boot.senv_+3A_b">B</code></td>
<td>
<p>Number of bootstrap samples. A positive integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the bootstrap standard errors for the regression coefficients in the scaled envelope model by bootstrapping the residuals.
</p>


<h3>Value</h3>

<p>The output is an r by p matrix.
</p>
<table>
<tr><td><code>bootse</code></td>
<td>
<p>The standard error for elements in beta computed by bootstrap.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(sales)
X &lt;- sales[, 1:3]
Y &lt;- sales[, 4:7]

u &lt;- u.senv(X, Y)
u

## Not run: B &lt;- 100
## Not run: bootse &lt;- boot.senv(X, Y, 2, B)
## Not run: bootse
</code></pre>

<hr>
<h2 id='boot.stenv'>Bootstrap for stenv</h2><span id='topic+boot.stenv'></span>

<h3>Description</h3>

<p>Compute bootstrap standard error for the simultaneous envelope estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.stenv(X, Y, q, u, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.stenv_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="boot.stenv_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="boot.stenv_+3A_q">q</code></td>
<td>
<p>Dimension of the X-envelope. An integer between 0 and p.</p>
</td></tr>
<tr><td><code id="boot.stenv_+3A_u">u</code></td>
<td>
<p>Dimension of the Y-envelope. An integer between 0 and r.</p>
</td></tr>
<tr><td><code id="boot.stenv_+3A_b">B</code></td>
<td>
<p>Number of bootstrap samples. A positive integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the bootstrap standard errors for the regression coefficients in the envelope model by bootstrapping the residuals.
</p>


<h3>Value</h3>

<p>The output is an p by r matrix.
</p>
<table>
<tr><td><code>bootse</code></td>
<td>
<p>The standard error for elements in beta computed by bootstrap.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(fiberpaper)
X &lt;- fiberpaper[, 5:7]
Y &lt;- fiberpaper[, 1:4]
u &lt;- u.stenv(X, Y)
u

## Not run: B &lt;- 100
## Not run: bootse &lt;- boot.stenv(X, Y, 2, 3, B)
## Not run: bootse
</code></pre>

<hr>
<h2 id='boot.sxenv'>Bootstrap for sxenv</h2><span id='topic+boot.sxenv'></span>

<h3>Description</h3>

<p>Compute bootstrap standard error for the scaled predictor envelope estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.sxenv(X, Y, u, R, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.sxenv_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="boot.sxenv_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="boot.sxenv_+3A_u">u</code></td>
<td>
<p>Dimension of the scaled envelope in the predictor space. An integer between 0 and p.</p>
</td></tr>
<tr><td><code id="boot.sxenv_+3A_r">R</code></td>
<td>
<p>The number of replications of the scales. A vector, the sum of all elements of R must be p.</p>
</td></tr>
<tr><td><code id="boot.sxenv_+3A_b">B</code></td>
<td>
<p>Number of bootstrap samples. A positive integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the bootstrap standard errors for the regression coefficients in the scaled envelope model in the predictor space by bootstrapping the residuals.
</p>


<h3>Value</h3>

<p>The output is an p by r matrix.
</p>
<table>
<tr><td><code>bootse</code></td>
<td>
<p>The standard error for elements in beta computed by bootstrap.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(sales)
Y &lt;- sales[, 1:3]
X &lt;- sales[, 4:7]
R &lt;- rep(1, 4)

u &lt;- u.sxenv(X, Y, R)
u

B &lt;- 100
## Not run: bootse &lt;- boot.sxenv(X, Y, 2, R, B)
## Not run: bootse
</code></pre>

<hr>
<h2 id='boot.xenv'>Bootstrap for xenv</h2><span id='topic+boot.xenv'></span>

<h3>Description</h3>

<p>Compute bootstrap standard error for the predictor envelope estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.xenv(X, Y, u, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.xenv_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors and n is number of observations.  The predictors must be continuous variables.</p>
</td></tr>
<tr><td><code id="boot.xenv_+3A_y">Y</code></td>
<td>
<p>Responses. An n by r matrix, r is the number of responses. The response can be univariate or multivariate and must be continuous variable.</p>
</td></tr>
<tr><td><code id="boot.xenv_+3A_u">u</code></td>
<td>
<p>Dimension of the envelope. An integer between 0 and p.</p>
</td></tr>
<tr><td><code id="boot.xenv_+3A_b">B</code></td>
<td>
<p>Number of bootstrap samples. A positive integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the bootstrap standard errors for the regression coefficients in the envelope model in predictor space by bootstrapping the residuals.
</p>


<h3>Value</h3>

<p>The output is a p by r matrix.
</p>
<table>
<tr><td><code>bootse</code></td>
<td>
<p>The standard error for elements in beta computed by bootstrap.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(wheatprotein)
X &lt;- wheatprotein[, 1:6]
Y &lt;- wheatprotein[, 7]

## Not run: B &lt;- 100
## Not run: bootse &lt;- boot.xenv(X, Y, 2, B)
## Not run: bootse
</code></pre>

<hr>
<h2 id='concrete'>Concrete Slump Test Dataset</h2><span id='topic+concrete'></span>

<h3>Description</h3>

<p>Concrete is a highly complex material. This dataset investigates the relationship between the slump, flow and 28-day Compressive Strength of concrete and concrete ingredients.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("concrete")</code></pre>


<h3>Format</h3>

<p>A data frame with 103 entries on the following 10 variables.
</p>

<dl>
<dt><code>Cement</code></dt><dd><p>Cement, input gradients, kg in one M^3 concrete.</p>
</dd>
<dt><code>Slag</code></dt><dd><p>Slag, input gradients, kg in one M^3 concrete.</p>
</dd>
<dt><code>Fly_ash</code></dt><dd><p>Fly ash, input gradients, kg in one M^3 concrete.</p>
</dd>
<dt><code>Water</code></dt><dd><p>Water, input gradients, kg in one M^3 concrete.</p>
</dd>
<dt><code>SP</code></dt><dd><p>Superplasticizer, input gradients, kg in one M^3 concrete.</p>
</dd>
<dt><code>Coarse_Aggr</code></dt><dd><p>Coarse aggregate, input gradients, kg in one M^3 concrete.</p>
</dd>
<dt><code>Fine_Aggr</code></dt><dd><p>Fine aggregate, input gradients, kg in one M^3 concrete.</p>
</dd>
<dt><code>Slump</code></dt><dd><p>Slump, output variable, in centimeter.</p>
</dd>
<dt><code>Flow</code></dt><dd><p>Flow, output variable, in centimeter.</p>
</dd>
<dt><code>Strength</code></dt><dd><p>28-day Compressive Strength, in Mpa.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Concrete is the most important material in civil engineering.  This dataset include 103 data points that measure three characteristics of the concrete and the amount of seven input ingradents. 
</p>


<h3>Source</h3>

<p>UCI Machine Learning Repository: http://archive.ics.uci.edu/ml/datasets/concrete+slump+test
</p>


<h3>References</h3>

<p>Yeh, I-Cheng (2007). Modeling slump flow of concrete using second-order regressions and artificial neural networks. Cement and Concrete Composites, 29(6), 474-480.
</p>

<hr>
<h2 id='cv.env'>Cross validation for env</h2><span id='topic+cv.env'></span>

<h3>Description</h3>

<p>Compute the prediction error for the response envelope estimator using m-fold cross validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.env(X, Y, u, m, nperm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.env_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="cv.env_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="cv.env_+3A_u">u</code></td>
<td>
<p>Dimension of the envelope. An integer between 0 and r.</p>
</td></tr>
<tr><td><code id="cv.env_+3A_m">m</code></td>
<td>
<p>A positive integer that is used to indicate m-fold cross validation.</p>
</td></tr>
<tr><td><code id="cv.env_+3A_nperm">nperm</code></td>
<td>
<p>A positive integer indicating number of permutations of the observations, m-fold cross validation is run on each permutation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes prediction errors using m-fold cross validation.  For a fixed dimension u, the data is randomly partitioned into m parts, each part is in turn used for testing for the prediction performance while the rest m-1 parts are used for training.  This process is repeated for <code>nperm</code> times, and average prediction error is reported. As Y is multivariate, the identity inner product is used for computing the prediction errors.
</p>


<h3>Value</h3>

<p>The output is a real nonnegative number.
</p>
<table>
<tr><td><code>cvPE</code></td>
<td>
<p>The prediction error estimated by m-fold cross validation.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(wheatprotein)
X &lt;- wheatprotein[, 8]
Y &lt;- wheatprotein[, 1:6]
u &lt;- u.env(X, Y)
u

m &lt;- 5
nperm &lt;- 50
cvPE &lt;- cv.env(X, Y, 1, m, nperm)
cvPE
</code></pre>

<hr>
<h2 id='cv.env.apweights'>Cross validation for env.apweights</h2><span id='topic+cv.env.apweights'></span>

<h3>Description</h3>

<p>Compute the prediction error using m-fold cross validation for the response envelope estimator that accommodates nonconstant variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.env.apweights(X, Y, u, m, nperm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.env.apweights_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="cv.env.apweights_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="cv.env.apweights_+3A_u">u</code></td>
<td>
<p>Dimension of the envelope. An integer between 0 and r.</p>
</td></tr>
<tr><td><code id="cv.env.apweights_+3A_m">m</code></td>
<td>
<p>A positive integer that is used to indicate m-fold cross validation.</p>
</td></tr>
<tr><td><code id="cv.env.apweights_+3A_nperm">nperm</code></td>
<td>
<p>A positive integer indicating number of permutations of the observations, m-fold cross validation is run on each permutation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes prediction errors using m-fold cross validation.  For a fixed dimension u, the data is randomly partitioned into m parts, each part is in turn used for testing for the prediction performance while the rest m-1 parts are used for training.  This process is repeated for <code>nperm</code> times, and average prediction error is reported. As Y is multivariate, the identity inner product is used for computing the prediction errors.
</p>


<h3>Value</h3>

<p>The output is a real nonnegative number.
</p>
<table>
<tr><td><code>cvPE</code></td>
<td>
<p>The prediction error estimated by m-fold cross validation.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(concrete)
X &lt;- concrete[, 1:7]
Y &lt;- concrete[, 8:10]
## Not run: u &lt;- u.env.apweights(X, Y)
## Not run: u

m &lt;- 5
nperm &lt;- 50
## Not run: cvPE &lt;- cv.env.apweights(X, Y, 2, m, nperm)
## Not run: cvPE
</code></pre>

<hr>
<h2 id='cv.env.tcond'>Cross validation for env.tcond</h2><span id='topic+cv.env.tcond'></span>

<h3>Description</h3>

<p>Compute the prediction error using m-fold cross validation for the response envelope estimator where the errors follow a t-distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.env.tcond(X, Y, u, df, m, nperm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.env.tcond_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="cv.env.tcond_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="cv.env.tcond_+3A_u">u</code></td>
<td>
<p>Dimension of the envelope. An integer between 0 and r.</p>
</td></tr>
<tr><td><code id="cv.env.tcond_+3A_df">df</code></td>
<td>
<p>Degrees of freedom of the t-distribution. A positive number that is greater than 2.</p>
</td></tr>
<tr><td><code id="cv.env.tcond_+3A_m">m</code></td>
<td>
<p>A positive integer that is used to indicate m-fold cross validation.</p>
</td></tr>
<tr><td><code id="cv.env.tcond_+3A_nperm">nperm</code></td>
<td>
<p>A positive integer indicating number of permutations of the observations, m-fold cross validation is run on each permutation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes prediction errors using m-fold cross validation.  For a fixed dimension u, the data is randomly partitioned into m parts, each part is in turn used for testing for the prediction performance while the rest m-1 parts are used for training.  This process is repeated for <code>nperm</code> times, and average prediction error is reported. As Y is multivariate, the identity inner product is used for computing the prediction errors.
</p>


<h3>Value</h3>

<p>The output is a real nonnegative number.
</p>
<table>
<tr><td><code>cvPE</code></td>
<td>
<p>The prediction error estimated by m-fold cross validation.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(concrete)
X &lt;- concrete[1:78, 1:7]  # The first 78 observations are training data
Y &lt;- concrete[1:78, 8:10]
## Not run: u &lt;- u.env.tcond(X, Y, 6)
## Not run: u

m &lt;- 5
nperm &lt;- 50
## Not run: cvPE &lt;- cv.env.tcond(X, Y, 2, 6, m, nperm)
## Not run: cvPE
</code></pre>

<hr>
<h2 id='cv.eppls'>Cross validation for peplos</h2><span id='topic+cv.eppls'></span>

<h3>Description</h3>

<p>Compute the prediction error for the Envelope-based Partial Partial Least Squares estimator using m-fold cross validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.eppls(X1, X2, Y, u, m, nperm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.eppls_+3A_x1">X1</code></td>
<td>
<p>Predictors of main interest. An n by p1 matrix, n is the number of observations, and p1 is the number of main predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="cv.eppls_+3A_x2">X2</code></td>
<td>
<p>Covariates, or predictors not of main interest.  An n by p2 matrix, p2 is the number of covariates.</p>
</td></tr>
<tr><td><code id="cv.eppls_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="cv.eppls_+3A_u">u</code></td>
<td>
<p>Dimension of the envelope. An integer between 0 and r.</p>
</td></tr>
<tr><td><code id="cv.eppls_+3A_m">m</code></td>
<td>
<p>A positive integer that is used to indicate m-fold cross validation.</p>
</td></tr>
<tr><td><code id="cv.eppls_+3A_nperm">nperm</code></td>
<td>
<p>A positive integer indicating number of permutations of the observations, m-fold cross validation is run on each permutation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes prediction errors using m-fold cross validation.  For a fixed dimension u, the data is randomly partitioned into m parts, each part is in turn used for testing for the prediction performance while the rest m-1 parts are used for training.  This process is repeated for <code>nperm</code> times, and average prediction error is reported. As Y is multivariate, the identity inner product is used for computing the prediction errors.
</p>


<h3>Value</h3>

<p>The output is a real nonnegative number.
</p>
<table>
<tr><td><code>cvPE</code></td>
<td>
<p>The prediction error estimated by m-fold cross validation.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(amitriptyline)
  
Y &lt;- amitriptyline[ , 1:2]
X1 &lt;- amitriptyline[ , 4:7]
X2 &lt;- amitriptyline[ , 3]

m &lt;- 5
nperm &lt;- 50
## Not run: cvPE &lt;- cv.eppls(X1, X2, Y, 2, m, nperm)
## Not run: cvPE
</code></pre>

<hr>
<h2 id='cv.genv'>Cross validation for genv</h2><span id='topic+cv.genv'></span>

<h3>Description</h3>

<p>Compute the prediction error for the groupwise envelope estimator using m-fold cross validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.genv(X, Y, Z, u, m, nperm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.genv_+3A_x">X</code></td>
<td>

<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.
</p>
</td></tr>
<tr><td><code id="cv.genv_+3A_y">Y</code></td>
<td>

<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.
</p>
</td></tr>
<tr><td><code id="cv.genv_+3A_z">Z</code></td>
<td>

<p>A group indicator vector of length <code class="reqn">n</code>, where <code class="reqn">n</code>  
denotes the number of observations.
</p>
</td></tr>
<tr><td><code id="cv.genv_+3A_u">u</code></td>
<td>

<p>Dimension of the groupwise envelope. An integer between 0 and r.
</p>
</td></tr>
<tr><td><code id="cv.genv_+3A_m">m</code></td>
<td>

<p>A positive integer that is used to indicate <code>m</code>-fold cross 
validation.
</p>
</td></tr>
<tr><td><code id="cv.genv_+3A_nperm">nperm</code></td>
<td>

<p>A positive integer indicating number of permutations of the observations, m-fold cross validation is run on each permutation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes prediction errors using m-fold cross validation.  For a fixed dimension u, the data is randomly partitioned into m parts, each part is in turn used for testing for the prediction performance while the rest m-1 parts are used for training.  This process is repeated for <code>nperm</code> times, and average prediction error is reported. As Y is multivariate, the identity inner product is used for computing the prediction errors.
</p>


<h3>Value</h3>

<p>The output is a real nonnegative number.
</p>
<table>
<tr><td><code>cvPE</code></td>
<td>
<p>The prediction error estimated by m-fold cross validation.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(fiberpaper)
X &lt;- fiberpaper[ , c(5, 7)]
Y &lt;- fiberpaper[ , 1:3]
Z &lt;- as.numeric(fiberpaper[ , 6] &gt; mean(fiberpaper[ , 6]))

## Not run: m &lt;- 5
## Not run: nperm &lt;- 50
## Not run: cvPE &lt;- cv.genv(X, Y, Z, 2, m, nperm)
## Not run: cvPE

</code></pre>

<hr>
<h2 id='cv.henv'>Cross validation for henv</h2><span id='topic+cv.henv'></span>

<h3>Description</h3>

<p>Compute the prediction error for the heteroscedastic envelope estimator using m-fold cross validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.henv(X, Y, u, m, nperm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.henv_+3A_x">X</code></td>
<td>

<p>A group indicator vector of length <code class="reqn">n</code>, where <code class="reqn">n</code>  
denotes the number of observations.
</p>
</td></tr>
<tr><td><code id="cv.henv_+3A_y">Y</code></td>
<td>

<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.
</p>
</td></tr>
<tr><td><code id="cv.henv_+3A_u">u</code></td>
<td>

<p>Dimension of the heteroscedastic envelope. An integer between 0 and 
r.
</p>
</td></tr>
<tr><td><code id="cv.henv_+3A_m">m</code></td>
<td>

<p>A positive integer that is used to indicate <code>m</code>-fold cross 
validation.
</p>
</td></tr>
<tr><td><code id="cv.henv_+3A_nperm">nperm</code></td>
<td>

<p>A positive integer indicating number of permutations of the observations, m-fold cross validation is run on each permutation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes prediction errors using m-fold cross validation.  For a fixed dimension u, the data is randomly partitioned into m parts, each part is in turn used for testing for the prediction performance while the rest m-1 parts are used for training.  This process is repeated for <code>nperm</code> times, and average prediction error is reported. As Y is multivariate, the identity inner product is used for computing the prediction errors.
</p>


<h3>Value</h3>

<p>The output is a real nonnegative number.
</p>
<table>
<tr><td><code>cvPE</code></td>
<td>
<p>The prediction error estimated by m-fold cross validation.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(waterstrider)
X &lt;- waterstrider[ , 1]
Y &lt;- waterstrider[ , 2:5]

m &lt;- 5
nperm &lt;- 50

## Not run: cvPE &lt;- cv.henv(X, Y, 2, m, nperm)
## Not run: cvPE
</code></pre>

<hr>
<h2 id='cv.logit.env'>Cross validation for logit.env</h2><span id='topic+cv.logit.env'></span>

<h3>Description</h3>

<p>Compute the prediction error for the envelope estimator in logistic regression using m-fold cross validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.logit.env(X, Y, u, m, nperm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.logit.env_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors and n is number of observations.  The predictors must be continuous variables.</p>
</td></tr>
<tr><td><code id="cv.logit.env_+3A_y">Y</code></td>
<td>
<p>Response. An n by 1 matrix. The univariate response must be binary.</p>
</td></tr>
<tr><td><code id="cv.logit.env_+3A_u">u</code></td>
<td>
<p>Dimension of the envelope. An integer between 0 and p.</p>
</td></tr>
<tr><td><code id="cv.logit.env_+3A_m">m</code></td>
<td>
<p>A positive integer that is used to indicate m-fold cross validation.</p>
</td></tr>
<tr><td><code id="cv.logit.env_+3A_nperm">nperm</code></td>
<td>
<p>A positive integer indicating number of permutations of the observations, m-fold cross validation is run on each permutation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes prediction errors using m-fold cross validation.  For a fixed dimension u, the data is randomly partitioned into m parts, each part is in turn used for testing for the prediction performance while the rest m-1 parts are used for training.  This process is repeated for <code>nperm</code> times, and average prediction error is reported. 
</p>


<h3>Value</h3>

<p>The output is a real nonnegative number.
</p>
<table>
<tr><td><code>cvPE</code></td>
<td>
<p>The prediction error estimated by m-fold cross validation.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(horseshoecrab)
X1 &lt;- as.numeric(horseshoecrab[ , 1] == 2)
X2 &lt;- as.numeric(horseshoecrab[ , 1] == 3)
X3 &lt;- as.numeric(horseshoecrab[ , 1] == 4)
X4 &lt;- as.numeric(horseshoecrab[ , 2] == 2)
X5 &lt;- as.numeric(horseshoecrab[ , 2] == 3)
X6 &lt;- horseshoecrab[ , 3]
X7 &lt;- horseshoecrab[ , 5]
X &lt;- cbind(X1, X2, X3, X4, X5, X6, X7)
Y &lt;- as.numeric(ifelse(horseshoecrab[ , 4] &gt; 0, 1, 0))

m &lt;- 5
nperm &lt;- 50
## Not run: cvPE &lt;- cv.logit.env(X, Y, 1, m, nperm)
## Not run: cvPE

</code></pre>

<hr>
<h2 id='cv.penv'>Cross validation for penv</h2><span id='topic+cv.penv'></span>

<h3>Description</h3>

<p>Compute the prediction error for the partial envelope estimator using m-fold cross validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.penv(X1, X2, Y, u, m, nperm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.penv_+3A_x1">X1</code></td>
<td>
<p>Predictors of main interest. An n by p1 matrix, n is the number of observations, and p1 is the number of main predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="cv.penv_+3A_x2">X2</code></td>
<td>
<p>Covariates, or predictors not of main interest.  An n by p2 matrix, p2 is the number of covariates.</p>
</td></tr>
<tr><td><code id="cv.penv_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="cv.penv_+3A_u">u</code></td>
<td>
<p>Dimension of the envelope. An integer between 0 and r.</p>
</td></tr>
<tr><td><code id="cv.penv_+3A_m">m</code></td>
<td>
<p>A positive integer that is used to indicate m-fold cross validation.</p>
</td></tr>
<tr><td><code id="cv.penv_+3A_nperm">nperm</code></td>
<td>
<p>A positive integer indicating number of permutations of the observations, m-fold cross validation is run on each permutation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes prediction errors using m-fold cross validation.  For a fixed dimension u, the data is randomly partitioned into m parts, each part is in turn used for testing for the prediction performance while the rest m-1 parts are used for training.  This process is repeated for <code>nperm</code> times, and average prediction error is reported. As Y is multivariate, the identity inner product is used for computing the prediction errors.
</p>


<h3>Value</h3>

<p>The output is a real nonnegative number.
</p>
<table>
<tr><td><code>cvPE</code></td>
<td>
<p>The prediction error estimated by m-fold cross validation.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(fiberpaper)
X1 &lt;- fiberpaper[, 7]
X2 &lt;- fiberpaper[, 5:6]
Y &lt;- fiberpaper[, 1:4]

m &lt;- 5
nperm &lt;- 50
## Not run: cvPE &lt;- cv.penv(X1, X2, Y, 1, m, nperm)
## Not run: cvPE
</code></pre>

<hr>
<h2 id='cv.pois.env'>Cross validation for pois.env</h2><span id='topic+cv.pois.env'></span>

<h3>Description</h3>

<p>Compute the prediction error for the envelope estimator in poisson regression using m-fold cross validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.pois.env(X, Y, u, m, nperm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.pois.env_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors and n is number of observations.  The predictors must be continuous variables.</p>
</td></tr>
<tr><td><code id="cv.pois.env_+3A_y">Y</code></td>
<td>
<p>Response. An n by 1 matrix. The univariate response must be counts.</p>
</td></tr>
<tr><td><code id="cv.pois.env_+3A_u">u</code></td>
<td>
<p>Dimension of the envelope. An integer between 0 and p.</p>
</td></tr>
<tr><td><code id="cv.pois.env_+3A_m">m</code></td>
<td>
<p>A positive integer that is used to indicate m-fold cross validation.</p>
</td></tr>
<tr><td><code id="cv.pois.env_+3A_nperm">nperm</code></td>
<td>
<p>A positive integer indicating number of permutations of the observations, m-fold cross validation is run on each permutation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes prediction errors using m-fold cross validation.  For a fixed dimension u, the data is randomly partitioned into m parts, each part is in turn used for testing for the prediction performance while the rest m-1 parts are used for training.  This process is repeated for <code>nperm</code> times, and average prediction error is reported. 
</p>


<h3>Value</h3>

<p>The output is a real nonnegative number.
</p>
<table>
<tr><td><code>cvPE</code></td>
<td>
<p>The prediction error estimated by m-fold cross validation.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(horseshoecrab)
X1 &lt;- as.numeric(horseshoecrab[ , 1] == 2)
X2 &lt;- as.numeric(horseshoecrab[ , 1] == 3)
X3 &lt;- as.numeric(horseshoecrab[ , 1] == 4)
X4 &lt;- as.numeric(horseshoecrab[ , 2] == 2)
X5 &lt;- as.numeric(horseshoecrab[ , 2] == 3)
X6 &lt;- horseshoecrab[ , 3]
X7 &lt;- horseshoecrab[ , 5]
X &lt;- cbind(X1, X2, X3, X4, X5, X6, X7)
Y &lt;- horseshoecrab[ , 4]

m &lt;- 5
nperm &lt;- 50
## Not run: cvPE &lt;- cv.pois.env(X, Y, 1, m, nperm)
## Not run: cvPE

</code></pre>

<hr>
<h2 id='cv.rrenv'>Cross validation for rrenv</h2><span id='topic+cv.rrenv'></span>

<h3>Description</h3>

<p>Compute the prediction error using m-fold cross validation for the reduced rank envelope estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.rrenv(X, Y, u, d, m, nperm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.rrenv_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="cv.rrenv_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="cv.rrenv_+3A_u">u</code></td>
<td>
<p>Dimension of the envelope. An integer between 0 and r.</p>
</td></tr>
<tr><td><code id="cv.rrenv_+3A_d">d</code></td>
<td>
<p>The rank of the coefficient matrix.  An integer between 0 and u.</p>
</td></tr>
<tr><td><code id="cv.rrenv_+3A_m">m</code></td>
<td>
<p>A positive integer that is used to indicate m-fold cross validation.</p>
</td></tr>
<tr><td><code id="cv.rrenv_+3A_nperm">nperm</code></td>
<td>
<p>A positive integer indicating number of permutations of the observations, m-fold cross validation is run on each permutation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes prediction errors using m-fold cross validation.  For a fixed dimension u, the data is randomly partitioned into m parts, each part is in turn used for testing for the prediction performance while the rest m-1 parts are used for training.  This process is repeated for <code>nperm</code> times, and average prediction error is reported. As Y is multivariate, the identity inner product is used for computing the prediction errors.
</p>


<h3>Value</h3>

<p>The output is a real nonnegative number.
</p>
<table>
<tr><td><code>cvPE</code></td>
<td>
<p>The prediction error estimated by m-fold cross validation.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(vehicles)
X &lt;- vehicles[, 1:11]  
Y &lt;- vehicles[, 12:15]
X &lt;- scale(X)
Y &lt;- scale(Y)  # The scales of Y are vastly different, so scaling is reasonable here

m &lt;- 5
nperm &lt;- 50
## Not run: cvPE &lt;- cv.rrenv(X, Y, 4, 2, m, nperm)
## Not run: cvPE
</code></pre>

<hr>
<h2 id='cv.rrenv.apweights'>Cross validation for rrenv.apweights</h2><span id='topic+cv.rrenv.apweights'></span>

<h3>Description</h3>

<p>Compute the prediction error using m-fold cross validation for the reduced rank envelope estimator that accommodates nonconstant error covariance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.rrenv.apweights(X, Y, u, d, m, nperm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.rrenv.apweights_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="cv.rrenv.apweights_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="cv.rrenv.apweights_+3A_u">u</code></td>
<td>
<p>Dimension of the envelope. An integer between 0 and r.</p>
</td></tr>
<tr><td><code id="cv.rrenv.apweights_+3A_d">d</code></td>
<td>
<p>The rank of the coefficient matrix.  An integer between 0 and u.</p>
</td></tr>
<tr><td><code id="cv.rrenv.apweights_+3A_m">m</code></td>
<td>
<p>A positive integer that is used to indicate m-fold cross validation.</p>
</td></tr>
<tr><td><code id="cv.rrenv.apweights_+3A_nperm">nperm</code></td>
<td>
<p>A positive integer indicating number of permutations of the observations, m-fold cross validation is run on each permutation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes prediction errors using m-fold cross validation.  For a fixed dimension u, the data is randomly partitioned into m parts, each part is in turn used for testing for the prediction performance while the rest m-1 parts are used for training.  This process is repeated for <code>nperm</code> times, and average prediction error is reported. As Y is multivariate, the identity inner product is used for computing the prediction errors.
</p>


<h3>Value</h3>

<p>The output is a real nonnegative number.
</p>
<table>
<tr><td><code>cvPE</code></td>
<td>
<p>The prediction error estimated by m-fold cross validation.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(vehicles)
X &lt;- vehicles[, 1:11]  
Y &lt;- vehicles[, 12:15]
X &lt;- scale(X)
Y &lt;- scale(Y)  # The scales of Y are vastly different, so scaling is reasonable here

m &lt;- 5
nperm &lt;- 50
## Not run: cvPE &lt;- cv.rrenv.apweights(X, Y, 3, 2, m, nperm)
## Not run: cvPE
</code></pre>

<hr>
<h2 id='cv.senv'>Cross validation for senv</h2><span id='topic+cv.senv'></span>

<h3>Description</h3>

<p>Compute the prediction error for the scaled response envelope estimator using m-fold cross validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.senv(X, Y, u, m, nperm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.senv_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="cv.senv_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="cv.senv_+3A_u">u</code></td>
<td>
<p>Dimension of the scaled envelope. An integer between 0 and r.</p>
</td></tr>
<tr><td><code id="cv.senv_+3A_m">m</code></td>
<td>
<p>A positive integer that is used to indicate m-fold cross validation.</p>
</td></tr>
<tr><td><code id="cv.senv_+3A_nperm">nperm</code></td>
<td>
<p>A positive integer indicating number of permutations of the observations, m-fold cross validation is run on each permutation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes prediction errors using m-fold cross validation.  For a fixed dimension u, the data is randomly partitioned into m parts, each part is in turn used for testing for the prediction performance while the rest m-1 parts are used for training.  This process is repeated for <code>nperm</code> times, and average prediction error is reported. As Y is multivariate, the identity inner product is used for computing the prediction errors.
</p>


<h3>Value</h3>

<p>The output is a real nonnegative number.
</p>
<table>
<tr><td><code>cvPE</code></td>
<td>
<p>The prediction error estimated by m-fold cross validation.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(sales)
X &lt;- sales[, 1:3]
Y &lt;- sales[, 4:7]

m &lt;- 5
nperm &lt;- 50
## Not run: cvPE &lt;- cv.senv(X, Y, 2, m, nperm)
## Not run: cvPE
</code></pre>

<hr>
<h2 id='cv.stenv'>Cross validation for stenv</h2><span id='topic+cv.stenv'></span>

<h3>Description</h3>

<p>Compute the prediction error for the simultaneous envelope estimator using m-fold cross validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.stenv(X, Y, q, u, m, nperm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.stenv_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors and n is number of observations.  The predictors must be continuous variables.</p>
</td></tr>
<tr><td><code id="cv.stenv_+3A_y">Y</code></td>
<td>
<p>Responses. An n by r matrix, r is the number of responses. The response can be univariate or multivariate and must be continuous variable.</p>
</td></tr>
<tr><td><code id="cv.stenv_+3A_q">q</code></td>
<td>
<p>Dimension of the X-envelope. An integer between 0 and p.</p>
</td></tr>
<tr><td><code id="cv.stenv_+3A_u">u</code></td>
<td>
<p>Dimension of the Y-envelope. An integer between 0 and r.</p>
</td></tr>
<tr><td><code id="cv.stenv_+3A_m">m</code></td>
<td>
<p>A positive integer that is used to indicate m-fold cross validation.</p>
</td></tr>
<tr><td><code id="cv.stenv_+3A_nperm">nperm</code></td>
<td>
<p>A positive integer indicating number of permutations of the observations, m-fold cross validation is run on each permutation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes prediction errors using m-fold cross validation.  For a fixed dimension (q, u), the data is randomly partitioned into m parts, each part is in turn used for testing for the prediction performance while the rest m-1 parts are used for training.  This process is repeated for <code>nperm</code> times, and average prediction error is reported. If Y is multivariate, the identity inner product is used for computing the prediction errors.
</p>


<h3>Value</h3>

<p>The output is a real nonnegative number.
</p>
<table>
<tr><td><code>cvPE</code></td>
<td>
<p>The prediction error estimated by m-fold cross validation.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(fiberpaper)
X &lt;- fiberpaper[, 5:7]
Y &lt;- fiberpaper[, 1:4]

m &lt;- 5
nperm &lt;- 50
## Not run: cvPE &lt;- cv.stenv(X, Y, 2, 3, m, nperm)
## Not run: cvPE
</code></pre>

<hr>
<h2 id='cv.sxenv'>Cross validation for sxenv</h2><span id='topic+cv.sxenv'></span>

<h3>Description</h3>

<p>Compute the prediction error for the scaled predictor envelope estimator using m-fold cross validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.sxenv(X, Y, u, R, m, nperm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.sxenv_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors and n is number of observations.  The predictors must be continuous variables.</p>
</td></tr>
<tr><td><code id="cv.sxenv_+3A_y">Y</code></td>
<td>
<p>Responses. An n by r matrix, r is the number of responses. The response can be univariate or multivariate and must be continuous variable.</p>
</td></tr>
<tr><td><code id="cv.sxenv_+3A_u">u</code></td>
<td>
<p>Dimension of the scaled envelope. An integer between 0 and r.</p>
</td></tr>
<tr><td><code id="cv.sxenv_+3A_r">R</code></td>
<td>
<p>The number of replications of the scales. A vector, the sum of all elements of R must be p.</p>
</td></tr>
<tr><td><code id="cv.sxenv_+3A_m">m</code></td>
<td>
<p>A positive integer that is used to indicate m-fold cross validation.</p>
</td></tr>
<tr><td><code id="cv.sxenv_+3A_nperm">nperm</code></td>
<td>
<p>A positive integer indicating number of permutations of the observations, m-fold cross validation is run on each permutation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes prediction errors using m-fold cross validation.  For a fixed dimension u, the data is randomly partitioned into m parts, each part is in turn used for testing for the prediction performance while the rest m-1 parts are used for training.  This process is repeated for <code>nperm</code> times, and average prediction error is reported. As Y is multivariate, the identity inner product is used for computing the prediction errors.
</p>


<h3>Value</h3>

<p>The output is a real nonnegative number.
</p>
<table>
<tr><td><code>cvPE</code></td>
<td>
<p>The prediction error estimated by m-fold cross validation.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(sales)
Y &lt;- sales[, 1:3]
X &lt;- sales[, 4:7]
R &lt;- rep(1, 4)

m &lt;- 5
nperm &lt;- 50
## Not run: cvPE &lt;- cv.sxenv(X, Y, 2, R, m, nperm)
## Not run: cvPE
</code></pre>

<hr>
<h2 id='cv.xenv'>Cross validation for xenv</h2><span id='topic+cv.xenv'></span>

<h3>Description</h3>

<p>Compute the prediction error for the predictor envelope estimator using m-fold cross validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.xenv(X, Y, u, m, nperm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.xenv_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors and n is number of observations.  The predictors must be continuous variables.</p>
</td></tr>
<tr><td><code id="cv.xenv_+3A_y">Y</code></td>
<td>
<p>Responses. An n by r matrix, r is the number of responses. The response can be univariate or multivariate and must be continuous variable.</p>
</td></tr>
<tr><td><code id="cv.xenv_+3A_u">u</code></td>
<td>
<p>Dimension of the envelope. An integer between 0 and p.</p>
</td></tr>
<tr><td><code id="cv.xenv_+3A_m">m</code></td>
<td>
<p>A positive integer that is used to indicate m-fold cross validation.</p>
</td></tr>
<tr><td><code id="cv.xenv_+3A_nperm">nperm</code></td>
<td>
<p>A positive integer indicating number of permutations of the observations, m-fold cross validation is run on each permutation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes prediction errors using m-fold cross validation.  For a fixed dimension u, the data is randomly partitioned into m parts, each part is in turn used for testing for the prediction performance while the rest m-1 parts are used for training.  This process is repeated for <code>nperm</code> times, and average prediction error is reported. If Y is multivariate, the identity inner product is used for computing the prediction errors.
</p>


<h3>Value</h3>

<p>The output is a real nonnegative number.
</p>
<table>
<tr><td><code>cvPE</code></td>
<td>
<p>The prediction error estimated by m-fold cross validation.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(wheatprotein)
X &lt;- wheatprotein[, 1:6]
Y &lt;- wheatprotein[, 7]

m &lt;- 5
nperm &lt;- 50
## Not run: cvPE &lt;- cv.xenv(X, Y, 2, m, nperm)
## Not run: cvPE
</code></pre>

<hr>
<h2 id='d.select'>Select the rank of beta</h2><span id='topic+d.select'></span>

<h3>Description</h3>

<p>This function outputs the rank selected by a chi-squared test developed by Bura and Cook (2003) with specified significance level for the beta. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d.select(X, Y, alpha = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d.select_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="d.select_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="d.select_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for testing. The default is 0.01.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimate the rank of beta using a chi-squared test.  The test statistic and degrees of freedom are described in Bura and Cook (2003).
</p>


<h3>Value</h3>

<table>
<tr><td><code>rank.beta</code></td>
<td>
<p>Rank of beta guided by the Bura-Cook estimator.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bura, E. and Cook, R. D. (2003). Rank estimation in reduced-rank regression. Journal of Multivariate Analysis, 87, 159 - 176.
</p>

<hr>
<h2 id='env'>Fit the response envelope model</h2><span id='topic+env'></span>

<h3>Description</h3>

<p>Fit the response envelope model in multivariate linear regression with dimension u. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env(X, Y, u, asy = TRUE, init = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="env_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="env_+3A_u">u</code></td>
<td>
<p>Dimension of the envelope. An integer between 0 and r.</p>
</td></tr>
<tr><td><code id="env_+3A_asy">asy</code></td>
<td>
<p>Flag for computing the asymptotic variance of the envelope estimator.  The default is <code>TRUE</code>. When p and r are large, computing the asymptotic variance can take much time and memory.  If only the envelope estimators are needed, the flag can be set to <code>asy = FALSE</code>.</p>
</td></tr>
<tr><td><code id="env_+3A_init">init</code></td>
<td>
<p>The user-specified value of Gamma for the envelope subspace. An r by u matrix. The default is the one generated by function envMU.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits the envelope model to the responses and predictors, </p>
<p style="text-align: center;"><code class="reqn">
 Y = \mu + \Gamma\eta X+\varepsilon, \Sigma=\Gamma\Omega\Gamma'+\Gamma_{0}\Omega_{0}\Gamma'_{0}
 </code>
</p>

<p>using the maximum likelihood estimation.  When the dimension of the envelope is between 1 and r-1, the starting value and blockwise coordinate descent algorithm in Cook et al. (2016) is implemented.  When the dimension is r, then the envelope model degenerates to the standard multivariate linear regression.  When the dimension is 0, it means that X and Y are uncorrelated, and the fitting is different.
</p>


<h3>Value</h3>

<p>The output is a list that contains the following components:
</p>
<table>
<tr><td><code>beta</code></td>
<td>
<p>The envelope estimator of the regression coefficients.</p>
</td></tr> 
<tr><td><code>Sigma</code></td>
<td>
<p>The envelope estimator of the error covariance matrix.</p>
</td></tr>
<tr><td><code>Gamma</code></td>
<td>
<p>An orthonormal basis of the envelope subspace.</p>
</td></tr>
<tr><td><code>Gamma0</code></td>
<td>
<p>An orthonormal basis of the complement of the envelope subspace.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>The coordinates of beta with respect to Gamma.</p>
</td></tr>
<tr><td><code>Omega</code></td>
<td>
<p>The coordinates of Sigma with respect to Gamma.</p>
</td></tr>
<tr><td><code>Omega0</code></td>
<td>
<p>The coordinates of Sigma with respect to Gamma0.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>The estimated intercept.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The maximized log likelihood function.</p>
</td></tr>
<tr><td><code>covMatrix</code></td>
<td>
<p>The asymptotic covariance of vec(beta). The covariance matrix returned are asymptotic.  For the actual standard errors, multiply by 1 / n.</p>
</td></tr>
<tr><td><code>asySE</code></td>
<td>
<p>The asymptotic standard error for elements in beta under the envelope model.  The standard errors returned are asymptotic, for actual standard errors, multiply by 1 / sqrt(n).</p>
</td></tr>
<tr><td><code>ratio</code></td>
<td>
<p>The asymptotic standard error ratio of the standard multivariate linear regression estimator over the envelope estimator, for each element in beta.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of observations in the data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cook, R. D., Li, B. and Chiaromente, F. (2010). Envelope Models for Parsimonious and Efficient Multivariate Linear Regression (with discussion). Statist. Sinica 20, 927- 1010.
</p>
<p>Cook, R. D., Forzani, L. and Su, Z. (2016) A Note on Fast Envelope Estimation. Journal of Multivariate Analysis. 150, 42-54.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wheatprotein)
X &lt;- wheatprotein[, 8]
Y &lt;- wheatprotein[, 1:6]
u &lt;- u.env(X, Y)
u

m &lt;- env(X, Y, 1)
m
m$beta
</code></pre>

<hr>
<h2 id='env.apweights'>Fit the envelope model with nonconstant variance</h2><span id='topic+env.apweights'></span>

<h3>Description</h3>

<p>For fixed envelope dimension u, fit the envelope model in multivariate linear regression with nonconstant error variance. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env.apweights(X, Y, u, asy = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env.apweights_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="env.apweights_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="env.apweights_+3A_u">u</code></td>
<td>
<p>Dimension of the envelope. An integer between 0 and r.</p>
</td></tr>
<tr><td><code id="env.apweights_+3A_asy">asy</code></td>
<td>
<p>Flag for computing the asymptotic variance of the envelope estimator.  The default is <code>TRUE</code>. When p and r are large, computing the asymptotic variance can take much time and memory.  If only the envelope estimators are needed, the flag can be set to <code>asy = FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits the envelope model to the responses and predictors, </p>
<p style="text-align: center;"><code class="reqn">
 Y_{i} = \mu + \Gamma\eta X_{i}+\varepsilon_{i}, \Sigma=c_{i}(\Gamma\Omega\Gamma'+\Gamma_{0}\Omega_{0}\Gamma'_{0}), i=1, ..., n,
 </code>
</p>

<p>using the maximum likelihood estimation.  It allows that the error covariance matrix to be nonconstant.  When the dimension of the envelope is between 1 and r-1, the alternating algorithm in Forzani and Su (2021) is implemented.  When the dimension is r, then the envelope model degenerates to the standard multivariate linear regression.  When the dimension is 0, it means that X and Y are uncorrelated, and the fitting is different.
</p>


<h3>Value</h3>

<p>The output is a list that contains the following components:
</p>
<table>
<tr><td><code>beta</code></td>
<td>
<p>The envelope estimator of the regression coefficients.</p>
</td></tr> 
<tr><td><code>Sigma</code></td>
<td>
<p>The envelope estimator of the error covariance matrix.</p>
</td></tr>
<tr><td><code>Gamma</code></td>
<td>
<p>An orthogonal basis of the envelope subspace.</p>
</td></tr>
<tr><td><code>Gamma0</code></td>
<td>
<p>An orthogonal basis of the complement of the envelope subspace.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>The coordinates of beta with respect to Gamma.</p>
</td></tr>
<tr><td><code>Omega</code></td>
<td>
<p>The coordinates of Sigma with respect to Gamma.</p>
</td></tr>
<tr><td><code>Omega0</code></td>
<td>
<p>The coordinates of Sigma with respect to Gamma0.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>The estimated intercept.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The maximized log likelihood function.</p>
</td></tr>
<tr><td><code>covMatrix</code></td>
<td>
<p>The asymptotic covariance of vec(beta). The covariance matrix returned are asymptotic.  For the actual standard errors, multiply by 1 / n.</p>
</td></tr>
<tr><td><code>asySE</code></td>
<td>
<p>The asymptotic standard error for elements in beta under the envelope model.  The standard errors returned are asymptotic, for actual standard errors, multiply by 1 / sqrt(n).</p>
</td></tr>
<tr><td><code>ratio</code></td>
<td>
<p>The asymptotic standard error ratio of the standard multivariate linear regression estimator (with consideration of nonconstant variance) over the envelope estimator, for each element in beta.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of observations in the data.</p>
</td></tr>
<tr><td><code>C1</code></td>
<td>
<p>The estimated weights <code class="reqn">c_i</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Forzani, L. and Su, Z. (2021). Envelopes for elliptical multivariate linear regression. Statist. Sinica 31, 301-332.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(concrete)
X &lt;- concrete[, 1:7]
Y &lt;- concrete[, 8:10]
## Not run: u &lt;- u.env.apweights(X, Y)
## Not run: u

m &lt;- env.apweights(X, Y, 2)
m
m$beta
</code></pre>

<hr>
<h2 id='env.tcond'>Fit the envelope model with t-distributed errors</h2><span id='topic+env.tcond'></span>

<h3>Description</h3>

<p>For fixed envelope dimension u, fit the envelope model in multivariate linear regression, where the errors follow a multivariate t-distribution. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env.tcond(X, Y, u, df, asy = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env.tcond_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="env.tcond_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="env.tcond_+3A_u">u</code></td>
<td>
<p>Dimension of the envelope. An integer between 0 and r.</p>
</td></tr>
<tr><td><code id="env.tcond_+3A_df">df</code></td>
<td>
<p>Degrees of freedom of the t-distribution. A positive number that is greater than 2.</p>
</td></tr>
<tr><td><code id="env.tcond_+3A_asy">asy</code></td>
<td>
<p>Flag for computing the asymptotic variance of the envelope estimator.  The default is <code>TRUE</code>. When p and r are large, computing the asymptotic variance can take much time and memory.  If only the envelope estimators are needed, the flag can be set to <code>asy = FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits the envelope model to the responses and predictors, </p>
<p style="text-align: center;"><code class="reqn">
 Y_{i} = \alpha + \Gamma\eta X_{i}+\varepsilon_{i}, \Sigma=\Gamma\Omega\Gamma'+\Gamma_{0}\Omega_{0}\Gamma'_{0}, i=1, ..., n,
 </code>
</p>

<p>using the maximum likelihood estimation.  The errors <code class="reqn">\varepsilon_{i}</code> follow a multivariate t-distribution with scale matrix <code class="reqn">\Sigma</code> and degrees of freedom <code>df</code>.   When the dimension of the envelope is between 1 and r-1, the alternating algorithm in Forzani and Su (2021) is implemented.  When the dimension is r, then the envelope model degenerates to the standard multivariate linear regression.  When the dimension is 0, it means that X and Y are uncorrelated, and the fitting is different.
</p>


<h3>Value</h3>

<p>The output is a list that contains the following components:
</p>
<table>
<tr><td><code>beta</code></td>
<td>
<p>The envelope estimator of the regression coefficients.</p>
</td></tr> 
<tr><td><code>Sigma</code></td>
<td>
<p>The envelope estimator of the error covariance matrix.</p>
</td></tr>
<tr><td><code>Gamma</code></td>
<td>
<p>An orthogonal basis of the envelope subspace.</p>
</td></tr>
<tr><td><code>Gamma0</code></td>
<td>
<p>An orthogonal basis of the complement of the envelope subspace.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>The coordinates of beta with respect to Gamma.</p>
</td></tr>
<tr><td><code>Omega</code></td>
<td>
<p>The coordinates of Sigma with respect to Gamma.</p>
</td></tr>
<tr><td><code>Omega0</code></td>
<td>
<p>The coordinates of Sigma with respect to Gamma0.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>The estimated intercept.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The maximized log likelihood function.</p>
</td></tr>
<tr><td><code>covMatrix</code></td>
<td>
<p>The asymptotic covariance of vec(beta). The covariance matrix returned are asymptotic.  For the actual standard errors, multiply by 1 / n.</p>
</td></tr>
<tr><td><code>asySE</code></td>
<td>
<p>The asymptotic standard error for elements in beta under the envelope model.  The standard errors returned are asymptotic, for actual standard errors, multiply by 1 / sqrt(n).</p>
</td></tr>
<tr><td><code>ratio</code></td>
<td>
<p>The asymptotic standard error ratio of the standard multivariate linear regression estimator (with consideration of nonconstant variance) over the envelope estimator, for each element in beta.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of observations in the data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Forzani, L. and Su, Z. (2021). Envelopes for elliptical multivariate linear regression. Statist. Sinica 31, 301-332.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(concrete)
X &lt;- concrete[1:78, 1:7]  # The first 78 observations are training data
Y &lt;- concrete[1:78, 8:10]
## Not run: u &lt;- u.env.tcond(X, Y, 6)
## Not run: u

m &lt;- env.tcond(X, Y, 2, 6)
m
m$beta
</code></pre>

<hr>
<h2 id='eppls'>
Fit the Envelope-based Partial Partial Least Squares model 
</h2><span id='topic+eppls'></span>

<h3>Description</h3>

<p>Fit the Envelope-based Partial Partial Least Squares model for multivariate linear regression with dimension u.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eppls(X1, X2, Y, u, asy = TRUE, init = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eppls_+3A_x1">X1</code></td>
<td>

<p>An <code class="reqn">n</code> by <code class="reqn">p1</code> matrix of continuous predictors, where <code class="reqn">p1</code> is the  number of continuous predictors with <code class="reqn">p1 &lt; n</code>.
</p>
</td></tr>
<tr><td><code id="eppls_+3A_x2">X2</code></td>
<td>

<p>An <code class="reqn">n</code> by <code class="reqn">p2</code> matrix of categorical predictors, where <code class="reqn">p2</code> is the  number of categorical predictors with <code class="reqn">p2 &lt; n</code>.
</p>
</td></tr>
<tr><td><code id="eppls_+3A_y">Y</code></td>
<td>

<p>An <code class="reqn">n</code> by <code class="reqn">r</code> matrix of multivariate responses, where <code class="reqn">r</code> is the number of responses.
</p>
</td></tr>
<tr><td><code id="eppls_+3A_u">u</code></td>
<td>

<p>A given dimension of the Envelope-based Partial Partial Least Squares.  It should be an interger between <code class="reqn">0</code> and <code class="reqn">p1</code>.
</p>
</td></tr>
<tr><td><code id="eppls_+3A_asy">asy</code></td>
<td>

<p>Flag for computing the asymptotic variance of the envelope estimator.  The default is <code>TRUE</code>. When p and r are large, computing the asymptotic variance can take much time and memory.  If only the envelope estimators are needed, the flag can be set to <code>asy = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="eppls_+3A_init">init</code></td>
<td>

<p>The user-specified value of Gamma for the envelope subspace. An <code class="reqn">r</code> by <code class="reqn">u</code> matrix. The default is the one generated by function envMU.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function the Envelope-based Partial Partial Least Squares model for multivariate linear regression with dimension <code class="reqn">u</code>, </p>
<p style="text-align: center;"><code class="reqn">
 Y = \mu + \Gamma\eta X + \varepsilon, \Sigma=\Gamma\Omega\Gamma' + \Gamma_{0}\Omega_{0}\Gamma'_{0}
 </code>
</p>

<p>using the maximum likelihood estimation.  When the dimension of the envelope is between 1 and <code class="reqn">p1</code>-1, the starting value and blockwise coordinate descent algorithm in Cook et al. (2016) is implemented.  When the dimension is <code class="reqn">p1</code>, then the envelope model degenerates to the standard multivariate linear regression.  When the dimension is 0, it means that X and Y are uncorrelated, and the fitting is different.
</p>


<h3>Value</h3>

<p>The output is a list that contains the following components:
</p>
<table>
<tr><td><code>muY</code></td>
<td>

<p>The estimator of mean of <code>Y</code>. 
</p>
</td></tr>
<tr><td><code>mu1</code></td>
<td>

<p>The estimator of mean of <code>X1</code>. 
</p>
</td></tr>
<tr><td><code>mu2</code></td>
<td>

<p>The estimator of mean of <code>X2</code>. 
</p>
</td></tr>
<tr><td><code>beta1</code></td>
<td>

<p>A <code class="reqn">p1</code> by <code class="reqn">r</code> matrix for the estimator of regression coefficients for continuous predictors.
</p>
</td></tr>
<tr><td><code>beta2</code></td>
<td>

<p>A <code class="reqn">p2</code> by <code class="reqn">r</code> matrix for the estimator of regression coefficients for categorical predictors.
</p>
</td></tr>
<tr><td><code>Gamma</code></td>
<td>

<p>An <code class="reqn">p1</code> by <code class="reqn">d</code> matrix for the orthogonal basis of the Envelope-based Partial Partial Least Squares.
</p>
</td></tr>
<tr><td><code>Gamma0</code></td>
<td>

<p>An <code class="reqn">p1</code> by <code class="reqn">(p1-d)</code> matrix for the orthogonal basis of the complement of the Envelope-based Partial Partial Least Squares.
</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>

<p>A <code class="reqn">p2</code> by <code class="reqn">p1</code> matrix for the estimator of regression coefficients based on the regression of <code>X1</code> on <code>X2</code>.
</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>

<p>A <code class="reqn">d</code> by <code class="reqn">p1</code> matrix for the coordinates of <code>beta1</code> with respect to <code>Gamma</code>.
</p>
</td></tr>
<tr><td><code>Omega</code></td>
<td>

<p>A <code class="reqn">d</code> by <code class="reqn">d</code> matrix for the coordinates of <code>SigmaX1</code> with respect to <code>Gamma</code>.
</p>
</td></tr>
<tr><td><code>Omega0</code></td>
<td>

<p>A <code class="reqn">(p1-d)</code> by <code class="reqn">(p1-d)</code> matrix for the coordinates of <code>SigmaX1</code> with respect to <code>Gamma0</code>.
</p>
</td></tr>
<tr><td><code>SigmaX1</code></td>
<td>

<p>The estimator of error covariance matrix <code>Sigma</code>[1|2]. 
</p>
</td></tr>
<tr><td><code>SigmaYcX</code></td>
<td>

<p>The estimator of error covariance matrix <code>Sigma</code>[<code>Y</code>|<code>X</code>]. 
</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>

<p>The maximized log likelihood function.
</p>
</td></tr>
<tr><td><code>n</code></td>
<td>

<p>The number of observations in the data.
</p>
</td></tr>
<tr><td><code>covMatrix1</code></td>
<td>

<p>The asymptotic covariance of vec(beta1). The covariance matrix returned are asymptotic.  For the actual standard errors, multiply by 1 / n.
</p>
</td></tr>
<tr><td><code>covMatrix2</code></td>
<td>

<p>The asymptotic covariance of vec(beta2). The covariance matrix returned are asymptotic.  For the actual standard errors, multiply by 1 / n.
</p>
</td></tr>
<tr><td><code>asySE1</code></td>
<td>

<p>The asymptotic standard error matrix for elements in <code>beta1</code>. The multiplication by the reciprocal of square root of <code class="reqn">n</code> returns actual standard errors.
</p>
</td></tr>
<tr><td><code>asySE2</code></td>
<td>

<p>The asymptotic standard error matrix for elements in <code>beta2</code>. The multiplication by the reciprocal of square root of <code class="reqn">n</code> returns actual standard errors.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Park, Y., Su, Z. and Chung, D. (2022+)  Envelope-based Partial Partial Least Squares with Application to Cytokine-based Biomarker Analysis for COVID-19.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(amitriptyline)
  
  Y &lt;- amitriptyline[ , 1:2]
  X1 &lt;- amitriptyline[ , 4:7]
  X2 &lt;- amitriptyline[ , 3]
  u &lt;- u.eppls(X1, X2, Y)
  
  u
  
  m &lt;- eppls(X1, X2, Y, 2)
  m
</code></pre>

<hr>
<h2 id='felmdir'>Fit the functional envelope linear model</h2><span id='topic+felmdir'></span>

<h3>Description</h3>

<p>Fit the response and predictor envelope model in function-on-function linear regression with dimensions ux and uy, using the direct estimation. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>felmdir(X, Y, ux, uy, t1, t2, knots = c(0, 0.25, 0.5, 0.75, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="felmdir_+3A_x">X</code></td>
<td>
<p>Predictor function. An n by T1 matrix, T1 is number of observed time points, which is the length of t1.  Here we assume that each function is observed at the same time points.</p>
</td></tr>
<tr><td><code id="felmdir_+3A_y">Y</code></td>
<td>
<p>Response function. An n by T2 matrix, T2 is number of observed time points, which is the length of t2.  Here we assume that each function is observed at the same time points.</p>
</td></tr>
<tr><td><code id="felmdir_+3A_ux">ux</code></td>
<td>
<p>Dimension of the predictor envelope. An integer between 0 and number of knots +2.</p>
</td></tr>
<tr><td><code id="felmdir_+3A_uy">uy</code></td>
<td>
<p>Dimension of the response envelope. An integer between 0 and number of knots +2.</p>
</td></tr>
<tr><td><code id="felmdir_+3A_t1">t1</code></td>
<td>
<p>The observed time points for the predictor functions.</p>
</td></tr>
<tr><td><code id="felmdir_+3A_t2">t2</code></td>
<td>
<p>The observed time points for the response functions.</p>
</td></tr>
<tr><td><code id="felmdir_+3A_knots">knots</code></td>
<td>
<p>The location of knots of the cubic splines used for estimation.  Locations should be positive. The default location of the knots are 0, 0.25, 0.5, 0.75, 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits the envelope model to the function-on-function linear regression, </p>
<p style="text-align: center;"><code class="reqn">
 Y = \alpha + B X + \epsilon</code>
</p>
<p>, 
where X and Y are random functions in Hilbert spaces <code class="reqn">H_X</code> and <code class="reqn">H_Y</code>, <code class="reqn">\alpha</code> is a fixed member in <code class="reqn">H_Y</code>, <code class="reqn">\epsilon</code> is a random member of <code class="reqn">H_Y</code>, and B: <code class="reqn">H_X -&gt; H_Y</code> is a linear operator.  We use cubic splines as the basis for both <code class="reqn">H_X</code> and <code class="reqn">H_Y</code>. The coefficients <code class="reqn">[X]</code> and <code class="reqn">[Y]</code> with respect to the basis are computed.  The predictor and response envelope model is fitted on the linear regression model of <code class="reqn">[Y]</code> on <code class="reqn">[X]</code>. In this method, we do not need to estimate the eigenfunctions of <code class="reqn">Sigma_X</code> and <code class="reqn">Sigma_\epsilon</code>.  Based on the estimation result, the fitted value of <code class="reqn">Y</code> is calculated.  The standard function-on-function regression model also works through the linear regression model of <code class="reqn">[Y]</code> on <code class="reqn">[X]</code>. But instead of fitting an envelope model, it fits a standard linear regression model, based on which the fitted value of <code class="reqn">[Y]</code> is calculated.  The details are elaborated in Section 5, direct estimation, in the reference of Su et al. (2022). 
</p>


<h3>Value</h3>

<p>The output is a list that contains the following components:
</p>
<table>
<tr><td><code>beta</code></td>
<td>
<p>The envelope estimator of the regression coefficients in the regression of <code class="reqn">[Y]</code> on <code class="reqn">[X]</code>.</p>
</td></tr> 
<tr><td><code>betafull</code></td>
<td>
<p>The standard estimator, i.e., the OLS estimator of the regression coefficients in the regression of <code class="reqn">[Y]</code> on <code class="reqn">[X]</code>.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>The envelope estimator of the intercept in the regression of <code class="reqn">[Y]</code> on <code class="reqn">[X]</code>.</p>
</td></tr>
<tr><td><code>alphafull</code></td>
<td>
<p>The standard estimator of the intercept in the regression of <code class="reqn">[Y]</code> on <code class="reqn">[X]</code>.</p>
</td></tr>
<tr><td><code>fitted.env</code></td>
<td>
<p>The fitted value of Y computed from the functional envelope linear model.</p>
</td></tr>
<tr><td><code>fitted.full</code></td>
<td>
<p>The fitted value of Y computed from the standard function-to-function linear model.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Su, Z., Li, B. and Cook, R. D. (2022+) Envelope model for function-on-function linear regression.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(NJdata)
dataX &lt;- matrix(NJdata[,6], nrow = 21)
X &lt;- as.matrix(dataX[, 32:61])
dataY &lt;- matrix(NJdata[,3], nrow = 21)
Y &lt;- as.matrix(dataY[, 32:61])
t1 &lt;- 0:29
t2 &lt;- t1

m &lt;- felmdir(X, Y, 3, 1, t1, t2)
head(m$fitted.env)
head(m$fitted.full)
</code></pre>

<hr>
<h2 id='felmKL'>Fit the functional envelope linear model</h2><span id='topic+felmKL'></span>

<h3>Description</h3>

<p>Fit the response and predictor envelope model in function-on-function linear regression with dimensions ux and uy, using Karhunen-Loeve expansion based estimation. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>felmKL(X, Y, ux, uy, t1, t2, knots = c(0, 0.25, 0.5, 0.75, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="felmKL_+3A_x">X</code></td>
<td>
<p>Predictor function. An n by T1 matrix, T1 is number of observed time points, which is the length of t1.  Here we assume that each function is observed at the same time points.</p>
</td></tr>
<tr><td><code id="felmKL_+3A_y">Y</code></td>
<td>
<p>Response function. An n by T2 matrix, T2 is number of observed time points, which is the length of t2.  Here we assume that each function is observed at the same time points.</p>
</td></tr>
<tr><td><code id="felmKL_+3A_ux">ux</code></td>
<td>
<p>Dimension of the predictor envelope. An integer between 0 and number of knots +2.</p>
</td></tr>
<tr><td><code id="felmKL_+3A_uy">uy</code></td>
<td>
<p>Dimension of the response envelope. An integer between 0 and number of knots +2.</p>
</td></tr>
<tr><td><code id="felmKL_+3A_t1">t1</code></td>
<td>
<p>The observed time points for the predictor functions.</p>
</td></tr>
<tr><td><code id="felmKL_+3A_t2">t2</code></td>
<td>
<p>The observed time points for the response functions.</p>
</td></tr>
<tr><td><code id="felmKL_+3A_knots">knots</code></td>
<td>
<p>The location of knots of the cubic splines used for estimation.  Locations should be positive. The default location of the knots are 0, 0.25, 0.5, 0.75, 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits the envelope model to the function-on-function linear regression, </p>
<p style="text-align: center;"><code class="reqn">
 Y = \alpha + B X + \epsilon, 
 </code>
</p>

<p>where X and Y are random functions in Hilbert spaces <code class="reqn">H_X</code> and <code class="reqn">H_Y</code>, <code class="reqn">\alpha</code> is a fixed member in <code class="reqn">H_Y</code>, <code class="reqn">\epsilon</code> is a random member of <code class="reqn">H_Y</code>, and B: <code class="reqn">H_X -&gt; H_Y</code> is a linear operator.  We use cubic splines as the basis for both <code class="reqn">H_X</code> and <code class="reqn">H_Y</code> in the estimation of the eigenfunctions of <code class="reqn">Sigma_X</code> and <code class="reqn">Sigma_\epsilon</code>. The coefficients <code class="reqn">[X]</code> and <code class="reqn">[Y]</code> with respect to the estimated eigenfunctions are computed.  The predictor and response envelope model is fitted on the linear regression model of <code class="reqn">[Y]</code> on <code class="reqn">[X]</code>.  Based on its result, the fitted value of <code class="reqn">Y</code> is calculated.  The standard function-on-function regression model also works through the linear regression model of <code class="reqn">[Y]</code> on <code class="reqn">[X]</code>. But instead of fitting an envelope model, it fits a standard linear regression model, based on which the fitted value of <code class="reqn">Y</code> is calculated.  The details are elaborated in Section 6, Karhunen-Lo'eve expansion based estimation, in the reference of Su et al. (2022).  
</p>


<h3>Value</h3>

<p>The output is a list that contains the following components:
</p>
<table>
<tr><td><code>beta</code></td>
<td>
<p>The envelope estimator of the regression coefficients in the regression of <code class="reqn">[Y]</code> on <code class="reqn">[X]</code>.</p>
</td></tr> 
<tr><td><code>betafull</code></td>
<td>
<p>The standard estimator, i.e., the OLS estimator of the regression coefficients in the regression of <code class="reqn">[Y]</code> on <code class="reqn">[X]</code>.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>The envelope estimator of the intercept in the regression of <code class="reqn">[Y]</code> on <code class="reqn">[X]</code>.</p>
</td></tr>
<tr><td><code>alphafull</code></td>
<td>
<p>The standard estimator of the intercept in the regression of <code class="reqn">[Y]</code> on <code class="reqn">[X]</code>.</p>
</td></tr>
<tr><td><code>phihat.cord</code></td>
<td>
<p>The estimated coordinates of eigenfunctions of <code class="reqn">Sigma_\epsilon</code> with respect to the cubic splines.</p>
</td></tr>
<tr><td><code>psihat.cord</code></td>
<td>
<p>The estimated coordinates of eigenfunctions of <code class="reqn">Sigma_X</code> with respect to the cubic splines.</p>
</td></tr>
<tr><td><code>fitted.env</code></td>
<td>
<p>The fitted value of Y computed from the functional envelope linear model.</p>
</td></tr>
<tr><td><code>fitted.full</code></td>
<td>
<p>The fitted value of Y computed from the standard function-to-function linear model.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Su, Z., Li, B. and Cook, R. D. (2022+) Envelope model for function-on-function linear regression.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(NJdata)
dataX &lt;- matrix(NJdata[,6], nrow = 21)
X &lt;- as.matrix(dataX[, 32:61])
dataY &lt;- matrix(NJdata[,3], nrow = 21)
Y &lt;- as.matrix(dataY[, 32:61])
t1 &lt;- 0:29
t2 &lt;- t1

m &lt;- felmKL(X, Y, 4, 3, t1, t2)
head(m$fitted.env)
head(m$fitted.full)
</code></pre>

<hr>
<h2 id='fiberpaper'>Pulp and Paper Data
</h2><span id='topic+fiberpaper'></span>

<h3>Description</h3>

<p>Pulp and paper property</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("fiberpaper")</code></pre>


<h3>Format</h3>

<p>A data frame with 62 observations on the following 8 variables.
</p>

<dl>
<dt><code>V1</code></dt><dd><p>Breaking length.</p>
</dd>
<dt><code>V2</code></dt><dd><p>Elastic modulus.</p>
</dd>
<dt><code>V3</code></dt><dd><p>Stress at failure.</p>
</dd>
<dt><code>V4</code></dt><dd><p>Burst strength.</p>
</dd>
<dt><code>V5</code></dt><dd><p>Arithmetic fiber length.</p>
</dd>
<dt><code>V6</code></dt><dd><p>Long fiber fraction.</p>
</dd>
<dt><code>V7</code></dt><dd><p>Fine fiber fraction.</p>
</dd>
<dt><code>V8</code></dt><dd><p>Zero span tensile.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This data set contains measurements of properties of pulp fibers
and the paper made from them.
</p>


<h3>References</h3>

<p>Johnson, R.A. and Wichern, D.W. (2007). Applied Multivariate
Statistical Analysis, 6th edition.
</p>

<hr>
<h2 id='genv'>Fit the groupwise envelope model</h2><span id='topic+genv'></span>

<h3>Description</h3>

<p>Fit the groupwise envelope model in multivariate linear regression with dimension u. The groupwise envelope model is designed to accommodate both distinct regression coefficients and distinct error structures for different groups. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genv(X, Y, Z, u, asy = TRUE, fit = TRUE, init = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genv_+3A_x">X</code></td>
<td>

<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.
</p>
</td></tr>
<tr><td><code id="genv_+3A_y">Y</code></td>
<td>

<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.
</p>
</td></tr>
<tr><td><code id="genv_+3A_z">Z</code></td>
<td>

<p>A group indicator vector of length <code class="reqn">n</code>, where <code class="reqn">n</code> 
denotes the number of observations.
</p>
</td></tr>
<tr><td><code id="genv_+3A_u">u</code></td>
<td>

<p>Dimension of the groupwise envelope. An integer between 0 and r.
</p>
</td></tr>
<tr><td><code id="genv_+3A_asy">asy</code></td>
<td>
<p>Flag for computing the asymptotic variance of the envelope estimator.  The default is <code>TRUE</code>. When p and r are large, computing the asymptotic variance can take much time and memory.  If only the envelope estimators are needed, the flag can be set to <code>asy = FALSE</code>.</p>
</td></tr>
<tr><td><code id="genv_+3A_fit">fit</code></td>
<td>
<p>Flag for computing the fitted response.  The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="genv_+3A_init">init</code></td>
<td>
<p>The user-specified value of Gamma for the groupwise envelope subspace. An r by u matrix. The default is the one generated by function genvMU.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits the groupwise envelope model to the responses and predictors, </p>
<p style="text-align: center;"><code class="reqn">
 Y_{(l)j} = \mu_{(l)} + \Gamma\eta_{(l)j} X_{(l)j}+\varepsilon_{(l)j}, \Sigma_{(l)}=\Gamma\Omega_{(l)}\Gamma'+\Gamma_{0}\Omega_{0}\Gamma'_{0}
 </code>
</p>

<p>for l = 1, ..., L, using the maximum likelihood estimation.  When the dimension of the groupwise envelope is between 1 and r-1, the starting value and blockwise coordinate descent algorithm in Cook et al. (2016) is implemented.  When the dimension is r, then the envelope model degenerates to the standard multivariate linear regression.  When the dimension is 0, it means that X and Y are uncorrelated, and the fitting is different. When L is 1, the groupwise envelope model degenerates to the envelope model in Cook et al. (2010).
</p>


<h3>Value</h3>

<p>The output is a list that contains the following components:
</p>
<table>
<tr><td><code>beta</code></td>
<td>

<p>A list of <code class="reqn">r</code> by <code class="reqn">p</code> matrices for the estimator of
regression coefficients.  <code>beta</code>[[i]] indicates the 
estimator of regression coefficient for the ith group.
</p>
</td></tr>	
<tr><td><code>Sigma</code></td>
<td>

<p>A list of the estimator of error covariance matrix. <code>Sigma</code>[[i]] contains the estimated covariance matrix for the ith group.
</p>
</td></tr>	
<tr><td><code>Gamma</code></td>
<td>

<p>An orthonormal basis of the groupwise envelope subspace.
</p>
</td></tr>
<tr><td><code>Gamma0</code></td>
<td>

<p>An orthonormal basis of the complement of the groupwise envelope subspace.
</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>

<p>The coordinates of beta with respect to Gamma.
</p>
</td></tr>
<tr><td><code>Omega</code></td>
<td>

<p>The coordinates of Sigma with respect to Gamma.
</p>
</td></tr>
<tr><td><code>Omega0</code></td>
<td>

<p>The coordinates of Sigma with respect to Gamma0.
</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>

<p>The estimator of group mean.  A <code class="reqn">r</code> by <code class="reqn">L</code> matrix  
whose ith column contains the mean for the group.
</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>

<p>The maximized log likelihood function.
</p>
</td></tr>
<tr><td><code>covMatrix</code></td>
<td>

<p>A list of the asymptotic covariance of vec(beta). The covariance 
matrix returned are asymptotic.  For the actual standard errors, 
multiply by 1 / n. <code>covMatrix</code>[[i]] contains the asymptotic 
covariance matrix for the ith group.
</p>
</td></tr>
<tr><td><code>asySE</code></td>
<td>

<p>A list of the asymptotic standard error for elements in beta under 
the groupwise envelope model.  The standard errors returned are 
asymptotic, for actual standard errors, multiply by 1 / sqrt(n). 
<code>asySE</code>[[i]] contains the asymptotic standard error for 
elements in beta[[i]].
</p>
</td></tr>
<tr><td><code>ratio</code></td>
<td>

<p>A list of the asymptotic standard error ratio of the standard 
multivariate linear regression estimator over the groupwise envelope 
estimator, for each element in beta. <code>ratio</code>[[i]] contains the 
asymptotic standard error ratio for the ith group.
</p>
</td></tr>
<tr><td><code>groupInd</code></td>
<td>

<p>A matrix containing the unique values of group indicators. The 
matrix has p rows.	
</p>
</td></tr>
<tr><td><code>n</code></td>
<td>

<p>The number of observations in the data.
</p>
</td></tr>
<tr><td><code>ng</code></td>
<td>

<p>The number of observations in each group.
</p>
</td></tr>
<tr><td><code>Yfit</code></td>
<td>

<p>Fitted responses.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Park, Y., Su, Z. and Zhu, H. (2017)  Groupwise envelope models for Imaging Genetic Analysis. Biometrics, to appear.
</p>
<p>Cook, R. D., Li, B. and Chiaromente, F. (2010). Envelope Models for Parsimonious and Efficient Multivariate Linear Regression (with discussion). Statist. Sinica 20, 927- 1010.
</p>
<p>Cook, R. D., Forzani, L. and Su, Z. (2016) A Note on Fast Envelope Estimation. Journal of Multivariate Analysis. 150, 42-54.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fiberpaper)
X &lt;- fiberpaper[ , c(5, 7)]
Y &lt;- fiberpaper[ , 1:3]
Z &lt;- as.numeric(fiberpaper[ , 6] &gt; mean(fiberpaper[ , 6]))
## Not run: u &lt;- u.genv(X, Y, Z)
## Not run: u
## Not run: m &lt;- genv(X, Y, Z, 2)

</code></pre>

<hr>
<h2 id='henv'>Fit the heteroscedastic envelope model</h2><span id='topic+henv'></span>

<h3>Description</h3>

<p>Fit the heteroscedastic envelope model derived to incorporate heteroscedastic error structure in the context of estimating multivariate means for different groups with dimension u. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>henv(X, Y, u, asy = TRUE, fit = TRUE, init = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="henv_+3A_x">X</code></td>
<td>

<p>A group indicator vector of length <code class="reqn">n</code>, where <code class="reqn">n</code> 
denotes the number of observations.
</p>
</td></tr>
<tr><td><code id="henv_+3A_y">Y</code></td>
<td>

<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.
</p>
</td></tr>
<tr><td><code id="henv_+3A_u">u</code></td>
<td>

<p>Dimension of the heteroscedastic envelope. An integer between 0 and r.
</p>
</td></tr>
<tr><td><code id="henv_+3A_asy">asy</code></td>
<td>
<p>Flag for computing the asymptotic variance of the envelope estimator.  The default is <code>TRUE</code>. When p and r are large, computing the asymptotic variance can take much time and memory.  If only the envelope estimators are needed, the flag can be set to <code>asy = FALSE</code>.</p>
</td></tr>
<tr><td><code id="henv_+3A_fit">fit</code></td>
<td>
<p>Flag for computing the fitted response.  The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="henv_+3A_init">init</code></td>
<td>
<p>The user-specified value of Gamma for the heteroscedastic envelope subspace. An r by u matrix. The default is the one generated by function henvMU.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits the heteroscedastic envelope model to the responses, </p>
<p style="text-align: center;"><code class="reqn">
 Y_{(i)j} = \mu + \Gamma\eta_{(i)} +\varepsilon_{(i)j}, \Sigma_{(i)}=\Gamma\Omega_{(i)}\Gamma'+\Gamma_{0}\Omega_{0}\Gamma'_{0}
 </code>
</p>

<p>for i = 1, ..., p, using the maximum likelihood estimation.  When the dimension of the heteroscedastic envelope is between 1 and r-1, the starting value and blockwise coordinate descent algorithm in Cook et al. (2016) is implemented.  When the dimension is r, then the envelope model degenerates to the standard multivariate linear regression for comparing group means.  When the dimension is 0, it means there is no any group effect, and the fitting is different. 
</p>


<h3>Value</h3>

<p>The output is a list that contains the following components:
</p>
<table>
<tr><td><code>beta</code></td>
<td>

<p>The heteroscedastic envelope estimator of the group main effect. An 
r by p matix, the ith column of the matrix contains the main effect 
for the ith group.
</p>
</td></tr>
<tr><td><code>Sigma</code></td>
<td>

<p>A list of the heteroscedastic envelope estimator of the error 
covariance matrix. <code>Sigma</code>[[i]] contains the estimated 
covariance matrix for the ith group.
</p>
</td></tr>	
<tr><td><code>Gamma</code></td>
<td>

<p>An orthonormal basis of the heteroscedastic envelope subspace.
</p>
</td></tr>
<tr><td><code>Gamma0</code></td>
<td>

<p>An orthonormal basis of the complement of the heteroscedastic envelope subspace.
</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>

<p>A list of the coordinates of beta with respect to Gamma. <code>eta</code>
[[i]] indicates the coordinates of the main effect of the ith group 
with respect to Gamma.
</p>
</td></tr>
<tr><td><code>Omega</code></td>
<td>

<p>A list of the coordinates of Sigma with respect to Gamma. 
<code>Omega</code>[[i]] indicates the coordinates of the covariance matrix 
of the ith group with respect to Gamma.
</p>
</td></tr>
<tr><td><code>Omega0</code></td>
<td>

<p>The coordinates of Sigma with respect to Gamma0.
</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>

<p>The heteroscedastic envelope estimator of the grand mean. A r by 1 
matrix.
</p>
</td></tr>
<tr><td><code>mug</code></td>
<td>

<p>A list of the heteroscedastic envelope estimator of the group mean. 
An r by p matix, the ith column of the matrix contains the mean for 
the ith group.
</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>

<p>The maximized log likelihood function.
</p>
</td></tr>
<tr><td><code>covMatrix</code></td>
<td>

<p>The asymptotic covariance of (mu, vec(beta)')'. An r(p + 1) by r(p + 
1) matrix. The covariance matrix returned are asymptotic.  For the 
actual standard errors, multiply by 1 / n. 
</p>
</td></tr>
<tr><td><code>asySE</code></td>
<td>

<p>The asymptotic standard error for elements in beta under the 
heteroscedastic envelope model. An r by p matrix. The standard 
errors returned are asymptotic, for actual standard errors, multiply 
by 1 / sqrt(n). 
</p>
</td></tr>
<tr><td><code>ratio</code></td>
<td>

<p>The asymptotic standard error ratio of the standard multivariate 
linear regression for comparing group means over the heteroscedastic 
envelope estimator, for each element in beta. An r by p matrix.
</p>
</td></tr>
<tr><td><code>groupInd</code></td>
<td>

<p>A matrix containing the unique values of group indicators. The 
matrix has p rows.	
</p>
</td></tr>
<tr><td><code>n</code></td>
<td>

<p>The number of observations in the data.
</p>
</td></tr>
<tr><td><code>ng</code></td>
<td>

<p>The number of observations in each group.
</p>
</td></tr>
<tr><td><code>Yfit</code></td>
<td>

<p>Fitted responses.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Su, Z. and Cook, R. D. (2013)  Estimation of Multivariate Means with Heteroscedastic Error Using Envelope Models. Statistica Sinica, 23, 213-230.
</p>
<p>Cook, R. D., Li, B. and Chiaromente, F. (2010). Envelope Models for Parsimonious and Efficient Multivariate Linear Regression (with discussion). Statist. Sinica 20, 927- 1010.
</p>
<p>Cook, R. D., Forzani, L. and Su, Z. (2016) A Note on Fast Envelope Estimation. Journal of Multivariate Analysis. 150, 42-54.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(waterstrider)
X &lt;- waterstrider[ , 1]
Y &lt;- waterstrider[ , 2:5]

## Not run: u &lt;- u.henv(X, Y)
## Not run: u

## Not run: m &lt;- henv(X, Y, 2)

</code></pre>

<hr>
<h2 id='horseshoecrab'>Horseshoe Crab Data
</h2><span id='topic+horseshoecrab'></span>

<h3>Description</h3>

<p>The number of satellite male crabs near a female crab upon characteristic of the female horseshoe crabs. </p>


<h3>Usage</h3>

<pre><code class='language-R'>data("horseshoecrab")</code></pre>


<h3>Format</h3>

<p>A data frame with 173 observations on the following 5 variables.
</p>

<dl>
<dt><code>V1</code></dt><dd><p>Color.</p>
</dd>
<dt><code>V2</code></dt><dd><p>Condition of spine.</p>
</dd>
<dt><code>V3</code></dt><dd><p>Width of shell.</p>
</dd>
<dt><code>V4</code></dt><dd><p>Satellite.</p>
</dd>
<dt><code>V5</code></dt><dd><p>Weight.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This data set contains the number of satellite male crabs and characteristics of the female horseshoe crabs.
</p>


<h3>References</h3>

<p>Agresti, A. (2007). An Introduction to Categorical Data Analysis, 2nd edition.
</p>

<hr>
<h2 id='logit.env'>Fit the envelope model in logistic regression</h2><span id='topic+logit.env'></span>

<h3>Description</h3>

<p>Fit the envelope model in logistic regression with dimension u.</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit.env(X, Y, u, asy = TRUE, init = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logit.env_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors and n is number of observations.  The predictors must be continuous variables.</p>
</td></tr>
<tr><td><code id="logit.env_+3A_y">Y</code></td>
<td>
<p>Response. An n by 1 matrix. The univariate response must be binary.</p>
</td></tr>
<tr><td><code id="logit.env_+3A_u">u</code></td>
<td>
<p>Dimension of the envelope. An integer between 0 and p.</p>
</td></tr>
<tr><td><code id="logit.env_+3A_asy">asy</code></td>
<td>
<p>Flag for computing the asymptotic variance of the envelope estimator.  The default is <code>TRUE</code>. When p and r are large, computing the asymptotic variance can take much time and memory.  If only the envelope estimators are needed, the flag can be set to <code>asy = FALSE</code>.</p>
</td></tr>
<tr><td><code id="logit.env_+3A_init">init</code></td>
<td>
<p>The user-specified value of Gamma for the envelope subspace in logistic regression. An p by u matrix. The default is the one generated by function logit.envMU.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits the envelope model in logistic regression, </p>
<p style="text-align: center;"><code class="reqn">
 Y = exp(\mu + \beta' X) / (1 + exp(\mu + \beta' X)), \Sigma_{X}=\Gamma\Omega\Gamma'+\Gamma_{0}\Omega_{0}\Gamma'_{0}
</code>
</p>

<p>using the maximum likelihood estimation.  When the dimension of the envelope is between 1 and p-1, the starting value and blockwise coordinate descent algorithm in Cook et al. (2016) is implemented.  This model works the best when X is multivariate normal.
</p>


<h3>Value</h3>

<p>The output is a list that contains the following components:
</p>
<table>
<tr><td><code>beta</code></td>
<td>
<p>The envelope estimator of the canonical parameter.</p>
</td></tr> 
<tr><td><code>SigmaX</code></td>
<td>
<p>The envelope estimator of the covariance matrix of X.</p>
</td></tr>
<tr><td><code>Gamma</code></td>
<td>
<p>An orthonormal basis of the envelope subspace.</p>
</td></tr>
<tr><td><code>Gamma0</code></td>
<td>
<p>An orthonormal basis of the complement of the envelope subspace.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>The estimated beta of the canonical parameter with respect to Gamma.</p>
</td></tr>
<tr><td><code>Omega</code></td>
<td>
<p>The coordinates of SigmaX with respect to Gamma.</p>
</td></tr>
<tr><td><code>Omega0</code></td>
<td>
<p>The coordinates of SigmaX with respect to Gamma0.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>The estimated intercept of the canonical parameter.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The maximized log likelihood function.</p>
</td></tr>
<tr><td><code>covMatrix</code></td>
<td>
<p>The asymptotic covariance of vec(beta). The covariance matrix returned are asymptotic.  For the actual standard errors, multiply by 1 / n.</p>
</td></tr>
<tr><td><code>asySE</code></td>
<td>
<p>The asymptotic standard error for elements in beta under the envelope model.  The standard errors returned are asymptotic, for actual standard errors, multiply by 1 / sqrt(n).</p>
</td></tr>
<tr><td><code>ratio</code></td>
<td>
<p>The asymptotic standard error ratio of the standard multivariate linear regression estimator over the envelope estimator, for each element in beta.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of observations in the data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cook, R. D., Zhang, X. (2015). Foundations for Envelope Models and Methods. Journal of the American Statistical Association 110, 599 - 611.
</p>
<p>Cook, R. D., Forzani, L. and Su, Z. (2016) A Note on Fast Envelope Estimation. Journal of Multivariate Analysis. 150, 42-54.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(horseshoecrab)
X1 &lt;- as.numeric(horseshoecrab[ , 1] == 2)
X2 &lt;- as.numeric(horseshoecrab[ , 1] == 3)
X3 &lt;- as.numeric(horseshoecrab[ , 1] == 4)
X4 &lt;- as.numeric(horseshoecrab[ , 2] == 2)
X5 &lt;- as.numeric(horseshoecrab[ , 2] == 3)
X6 &lt;- horseshoecrab[ , 3]
X7 &lt;- horseshoecrab[ , 5]
X &lt;- cbind(X1, X2, X3, X4, X5, X6, X7)
Y &lt;- as.numeric(ifelse(horseshoecrab[ , 4] &gt; 0, 1, 0))

## Not run: u &lt;- u.logit.env(X, Y)
## Not run: u

## Not run: m &lt;- logit.env(X, Y, 1)
## Not run: m$beta
</code></pre>

<hr>
<h2 id='NJdata'>New Jersey Open Covid-19 Dataset</h2><span id='topic+NJdata'></span>

<h3>Description</h3>

<p>Daily COVID-19 infections, weather information as well as mobility of people for all 21 counties in May and June, 2020.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(NJdata)</code></pre>


<h3>Format</h3>

<p>A data frame with 1281 entries on the following 9 variables.
</p>

<dl>
<dt><code>key</code></dt><dd><p>The FIPS (Federal Information Processing System) county codes.</p>
</dd>
<dt><code>date</code></dt><dd><p>Date of measurements.</p>
</dd>
<dt><code>mobility_retail_and_recreation</code></dt><dd><p>Percentage change in visits to restaurants, cafes, shopping centers, theme parks, museums, libraries, and movie theaters compared to baseline.  The baseline is the median value, for the corresponding day of the week, during the 5-week period Jan 3-Feb 6, 2020.</p>
</dd>
<dt><code>mobility_grocery_and_pharmacy</code></dt><dd><p>Percentage change in visits to places like grocery markets, food warehouses, farmers markets, specialty food shops, drug stores, and pharmacies compared to baseline.  The baseline is the median value, for the corresponding day of the week, during the 5-week period Jan 3-Feb 6, 2020.</p>
</dd>
<dt><code>mobility_workplaces</code></dt><dd><p>Percentage change in visits to places of work compared to baseline.  The baseline is the median value, for the corresponding day of the week, during the 5-week period Jan 3-Feb 6, 2020.</p>
</dd>
<dt><code>new_confirmed</code></dt><dd><p>Count of new cases confirmed after positive test on this date.  Values can be negative, typically indicating a correction or an adjustment in the way they were measured. For example, a case might have been incorrectly flagged as recovered one date so it will be subtracted from the following date.</p>
</dd>
<dt><code>new_deceased</code></dt><dd><p>Count of new deaths from a positive COVID-19 case on this date.  Values can be negative, typically indicating a correction or an adjustment in the way they were measured. For example, a case might have been incorrectly flagged as recovered one date so it will be subtracted from the following date.</p>
</dd>
<dt><code>average_temperature</code></dt><dd><p>Recorded hourly average temperature, in celsius.</p>
</dd>
<dt><code>rainfall</code></dt><dd><p>Rainfall during the entire day, in millimeters.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This dataset contains COVID-19 new confirmed cases and deceased cases, average temperature and total rainfall, as well as the movement of people to different categories of places for each date-region pair.
</p>


<h3>Source</h3>

<p><a href="https://github.com/open-covid-19/data#open-covid-19-dataset">https://github.com/open-covid-19/data#open-covid-19-dataset</a>
</p>

<hr>
<h2 id='penv'>Fit the partial envelope model</h2><span id='topic+penv'></span>

<h3>Description</h3>

<p>Fit the partial envelope model in multivariate linear regression with dimension u. The partial envelope model focuses on the coefficients of main interest. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penv(X1, X2, Y, u, asy = TRUE, init = NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penv_+3A_x1">X1</code></td>
<td>
<p>Predictors of main interest. An n by p1 matrix, n is the number of observations, and p1 is the number of main predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="penv_+3A_x2">X2</code></td>
<td>
<p>Covariates, or predictors not of main interest.  An n by p2 matrix, p2 is the number of covariates.</p>
</td></tr>
<tr><td><code id="penv_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="penv_+3A_u">u</code></td>
<td>
<p>Dimension of the partial envelope. An integer between 0 and r.</p>
</td></tr>
<tr><td><code id="penv_+3A_asy">asy</code></td>
<td>
<p>Flag for computing the asymptotic variance of the partial envelope estimator.  The default is <code>TRUE</code>. When p and r are large, computing the asymptotic variance can take much time and memory.  If only the partial envelope estimators are needed, the flag can be set to <code>asy = FALSE</code>.</p>
</td></tr>
<tr><td><code id="penv_+3A_init">init</code></td>
<td>
<p>The user-specified value of Gamma for the partial envelope subspace. An r by u matrix. The default is the one generated by function envMU.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits the partial envelope model to the responses Y and predictors X1 and X2, </p>
<p style="text-align: center;"><code class="reqn">
 Y = \mu + \Gamma\eta X_{1} + \beta_{2}X_{2} +\varepsilon, \Sigma=\Gamma\Omega\Gamma'+\Gamma_{0}\Omega_{0}\Gamma'_{0}
</code>
</p>

<p>using the maximum likelihood estimation.  When the dimension of the envelope is between 1 and r - 1, we implemented the algorithm in Su and Cook (2011), but the partial envelope subspace is estimated using the blockwise coordinate descent algorithm in Cook et al. (2016).  When the dimension is r, then the partial envelope model degenerates to the standard multivariate linear regression with Y as the responses and both X1 and X2 as predictors.  When the dimension is 0, X1 and Y are uncorrelated, and the fitting is the standard multivariate linear regression with Y as the responses and X2 as the predictors.
</p>


<h3>Value</h3>

<p>The output is a list that contains the following components:
</p>
<table>
<tr><td><code>beta1</code></td>
<td>
<p>The partial envelope estimator of beta1, which is the regression coefficients for X1.</p>
</td></tr> 
<tr><td><code>beta2</code></td>
<td>
<p>The partial envelope estimator of beta2, which is the regression coefficients for X2.</p>
</td></tr> 
<tr><td><code>Sigma</code></td>
<td>
<p>The partial envelope estimator of the error covariance matrix.</p>
</td></tr>
<tr><td><code>Gamma</code></td>
<td>
<p>An orthonormal basis of the partial envelope subspace.</p>
</td></tr>
<tr><td><code>Gamma0</code></td>
<td>
<p>An orthonormal basis of the complement of the partial envelope subspace.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>The coordinates of beta1 with respect to Gamma.</p>
</td></tr>
<tr><td><code>Omega</code></td>
<td>
<p>The coordinates of Sigma with respect to Gamma.</p>
</td></tr>
<tr><td><code>Omega0</code></td>
<td>
<p>The coordinates of Sigma with respect to Gamma0.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>The estimated intercept in the partial envelope model.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The maximized log likelihood function.</p>
</td></tr>
<tr><td><code>covMatrix</code></td>
<td>
<p>The asymptotic covariance of vec(beta), while beta = (beta1, beta2). The covariance matrix returned are asymptotic.  For the actual standard errors, multiply by 1 / n.</p>
</td></tr>
<tr><td><code>asySE1</code></td>
<td>
<p>The asymptotic standard error for elements in beta1 under the partial envelope model.  The standard errors returned are asymptotic, for actual standard errors, multiply by 1 / sqrt(n).</p>
</td></tr>
<tr><td><code>asySE2</code></td>
<td>
<p>The asymptotic standard error for elements in beta2 under the partial envelope model.  The standard errors returned are asymptotic, for actual standard errors, multiply by 1 / sqrt(n).</p>
</td></tr>
<tr><td><code>ratio</code></td>
<td>
<p>The asymptotic standard error ratio of the stanard multivariate linear regression estimator over the partial envelope estimator, for each element in beta1.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of observations in the data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Su, Z. and Cook, R.D. (2011). Partial envelopes for efficient estimation in multivariate linear regression. Biometrika 98, 133 - 146.
</p>
<p>Cook, R. D., Forzani, L. and Su, Z. (2016) A Note on Fast Envelope Estimation. Journal of Multivariate Analysis. 150, 42-54.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fiberpaper)
X1 &lt;- fiberpaper[, 7]
X2 &lt;- fiberpaper[, 5:6]
Y &lt;- fiberpaper[, 1:4]
u &lt;- u.penv(X1, X2, Y)
u

m &lt;- penv(X1, X2, Y, 1)
m
m$beta1
</code></pre>

<hr>
<h2 id='pois.env'>Fit the envelope model in poisson regression</h2><span id='topic+pois.env'></span>

<h3>Description</h3>

<p>Fit the envelope model in poisson regression with dimension u.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pois.env(X, Y, u, asy = TRUE, init = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pois.env_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors and n is number of observations.  The predictors must be continuous variables.</p>
</td></tr>
<tr><td><code id="pois.env_+3A_y">Y</code></td>
<td>
<p>Response. An n by 1 matrix. The univariate response must be counts.</p>
</td></tr>
<tr><td><code id="pois.env_+3A_u">u</code></td>
<td>
<p>Dimension of the envelope. An integer between 0 and p.</p>
</td></tr>
<tr><td><code id="pois.env_+3A_asy">asy</code></td>
<td>
<p>Flag for computing the asymptotic variance of the envelope estimator.  The default is <code>TRUE</code>. When p and r are large, computing the asymptotic variance can take much time and memory.  If only the envelope estimators are needed, the flag can be set to <code>asy = FALSE</code>.</p>
</td></tr>
<tr><td><code id="pois.env_+3A_init">init</code></td>
<td>
<p>The user-specified value of Gamma for the envelope subspace in poisson regression. An p by u matrix. The default is the one generated by function pois.envMU.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits the envelope model in poisson regression, </p>
<p style="text-align: center;"><code class="reqn">
 Y = exp(\mu + \beta' X), \Sigma_{X}=\Gamma\Omega\Gamma'+\Gamma_{0}\Omega_{0}\Gamma'_{0}
</code>
</p>

<p>using the maximum likelihood estimation.  When the dimension of the envelope is between 1 and p-1, the starting value and blockwise coordinate descent algorithm in Cook et al. (2016) is implemented.  This model works the best when X is multivariate normal.
</p>


<h3>Value</h3>

<p>The output is a list that contains the following components:
</p>
<table>
<tr><td><code>beta</code></td>
<td>
<p>The envelope estimator of the canonical parameter.</p>
</td></tr> 
<tr><td><code>SigmaX</code></td>
<td>
<p>The envelope estimator of the covariance matrix of X.</p>
</td></tr>
<tr><td><code>Gamma</code></td>
<td>
<p>An orthonormal basis of the envelope subspace.</p>
</td></tr>
<tr><td><code>Gamma0</code></td>
<td>
<p>An orthonormal basis of the complement of the envelope subspace.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>The estimated beta of the canonical parameter with respect to Gamma.</p>
</td></tr>
<tr><td><code>Omega</code></td>
<td>
<p>The coordinates of SigmaX with respect to Gamma.</p>
</td></tr>
<tr><td><code>Omega0</code></td>
<td>
<p>The coordinates of SigmaX with respect to Gamma0.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>The estimated intercept of the canonical parameter.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The maximized log likelihood function.</p>
</td></tr>
<tr><td><code>covMatrix</code></td>
<td>
<p>The asymptotic covariance of vec(beta). The covariance matrix returned are asymptotic.  For the actual standard errors, multiply by 1 / n.</p>
</td></tr>
<tr><td><code>asySE</code></td>
<td>
<p>The asymptotic standard error for elements in beta under the envelope model.  The standard errors returned are asymptotic, for actual standard errors, multiply by 1 / sqrt(n).</p>
</td></tr>
<tr><td><code>ratio</code></td>
<td>
<p>The asymptotic standard error ratio of the standard multivariate linear regression estimator over the envelope estimator, for each element in beta.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of observations in the data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cook, R. D., Zhang, X. (2015). Foundations for Envelope Models and Methods. Journal of the American Statistical Association 110, 599 - 611.
</p>
<p>Cook, R. D., Forzani, L. and Su, Z. (2016) A Note on Fast Envelope Estimation. Journal of Multivariate Analysis. 150, 42-54.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(horseshoecrab)
X1 &lt;- as.numeric(horseshoecrab[ , 1] == 2)
X2 &lt;- as.numeric(horseshoecrab[ , 1] == 3)
X3 &lt;- as.numeric(horseshoecrab[ , 1] == 4)
X4 &lt;- as.numeric(horseshoecrab[ , 2] == 2)
X5 &lt;- as.numeric(horseshoecrab[ , 2] == 3)
X6 &lt;- horseshoecrab[ , 3]
X7 &lt;- horseshoecrab[ , 5]
X &lt;- cbind(X1, X2, X3, X4, X5, X6, X7)
Y &lt;- horseshoecrab[ , 4]

## Not run: u &lt;- u.pois.env(X, Y)
## Not run: u

m &lt;- pois.env(X, Y, 1)
m$beta
</code></pre>

<hr>
<h2 id='pred.env'>Estimation or prediction for env</h2><span id='topic+pred.env'></span>

<h3>Description</h3>

<p>Perform estimation or prediction under the response envelope model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred.env(m, Xnew)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred.env_+3A_m">m</code></td>
<td>
<p>A list containing estimators and other statistics inherited from env.</p>
</td></tr>
<tr><td><code id="pred.env_+3A_xnew">Xnew</code></td>
<td>
<p>The value of X with which to estimate or predict Y.  A p dimensional vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates the envelope model at new value Xnew.  It can perform estimation: find the fitted value when X = Xnew, or prediction: predict Y when X = Xnew.  The covariance matrix and the standard errors are also provided.
</p>


<h3>Value</h3>

<p>The output is a list that contains following components.
</p>
<table>
<tr><td><code>value</code></td>
<td>
<p>The fitted value or the predicted value evaluated at Xnew.</p>
</td></tr> 
<tr><td><code>covMatrix.estm</code></td>
<td>
<p>The covariance matrix of the fitted value at Xnew.</p>
</td></tr> 
<tr><td><code>SE.estm</code></td>
<td>
<p>The standard error of the fitted value at Xnew.</p>
</td></tr> 
<tr><td><code>covMatrix.pred</code></td>
<td>
<p>The covariance matrix of the predicted value at Xnew.</p>
</td></tr> 
<tr><td><code>SE.pred</code></td>
<td>
<p>The standard error of the predicted value at Xnew.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(wheatprotein)
X &lt;- wheatprotein[, 8]
Y &lt;- wheatprotein[, 1:6]
u &lt;- u.env(X, Y)
u

m &lt;- env(X, Y, 1)
m

X &lt;- as.matrix(X)
pred.res &lt;- pred.env(m, X[2, ])
pred.res

</code></pre>

<hr>
<h2 id='pred.env.apweights'>Estimation or prediction for env.apweights</h2><span id='topic+pred.env.apweights'></span>

<h3>Description</h3>

<p>Perform estimation or prediction under the response envelope model with accommodation to nonconstant variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred.env.apweights(m, Xnew)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred.env.apweights_+3A_m">m</code></td>
<td>
<p>A list containing estimators and other statistics inherited from env.apweights.</p>
</td></tr>
<tr><td><code id="pred.env.apweights_+3A_xnew">Xnew</code></td>
<td>
<p>The value of X with which to estimate or predict Y.  A p dimensional vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates the envelope model with nonconstant variance at new value Xnew.  It can perform estimation: find the fitted value when X = Xnew, or prediction: predict Y when X = Xnew.  The covariance matrix and the standard errors are also provided.
</p>


<h3>Value</h3>

<p>The output is a list that contains following components.
</p>
<table>
<tr><td><code>value</code></td>
<td>
<p>The fitted value or the predicted value evaluated at Xnew.</p>
</td></tr> 
<tr><td><code>covMatrix.estm</code></td>
<td>
<p>The covariance matrix of the fitted value at Xnew.</p>
</td></tr> 
<tr><td><code>SE.estm</code></td>
<td>
<p>The standard error of the fitted value at Xnew.</p>
</td></tr> 
<tr><td><code>covMatrix.pred</code></td>
<td>
<p>The covariance matrix of the predicted value at Xnew.</p>
</td></tr> 
<tr><td><code>SE.pred</code></td>
<td>
<p>The standard error of the predicted value at Xnew.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(concrete)
X &lt;- concrete[, 1:7]
Y &lt;- concrete[, 8:10]
## Not run: u &lt;- u.envapweights(X, Y)
## Not run: u

m &lt;- env.apweights(X, Y, 2)
m

X &lt;- as.matrix(X)
pred.res &lt;- pred.env.apweights(m, X[2, ])
pred.res

</code></pre>

<hr>
<h2 id='pred.env.tcond'>Estimation or prediction for env.tcond</h2><span id='topic+pred.env.tcond'></span>

<h3>Description</h3>

<p>Perform estimation or prediction under the response envelope model, where the errors follow a multivariate t-distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred.env.tcond(m, Xnew)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred.env.tcond_+3A_m">m</code></td>
<td>
<p>A list containing estimators and other statistics inherited from env.tcond.</p>
</td></tr>
<tr><td><code id="pred.env.tcond_+3A_xnew">Xnew</code></td>
<td>
<p>The value of X with which to estimate or predict Y.  A p dimensional vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates the envelope model with t distributed errors at new value Xnew.  It can perform estimation: find the fitted value when X = Xnew, or prediction: predict Y when X = Xnew.  The covariance matrix and the standard errors are also provided.
</p>


<h3>Value</h3>

<p>The output is a list that contains following components.
</p>
<table>
<tr><td><code>value</code></td>
<td>
<p>The fitted value or the predicted value evaluated at Xnew.</p>
</td></tr> 
<tr><td><code>covMatrix.estm</code></td>
<td>
<p>The covariance matrix of the fitted value at Xnew.</p>
</td></tr> 
<tr><td><code>SE.estm</code></td>
<td>
<p>The standard error of the fitted value at Xnew.</p>
</td></tr> 
<tr><td><code>covMatrix.pred</code></td>
<td>
<p>The covariance matrix of the predicted value at Xnew.</p>
</td></tr> 
<tr><td><code>SE.pred</code></td>
<td>
<p>The standard error of the predicted value at Xnew.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(concrete)
X &lt;- concrete[1:78, 1:7]  # The first 78 observations are training data
Y &lt;- concrete[1:78, 8:10]
## Not run: u &lt;- u.env.tcond(X, Y, 6)
## Not run: u

m &lt;- env.tcond(X, Y, 2, 6)
m

X &lt;- as.matrix(X)
pred.res &lt;- pred.env.tcond(m, X[2, ])
pred.res

</code></pre>

<hr>
<h2 id='pred.eppls'>Estimation or prediction for eppls</h2><span id='topic+pred.eppls'></span>

<h3>Description</h3>

<p>Perform estimation or prediction under the Envelope-based Partial Partial Least Squares.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred.eppls(m, X1new, X2new)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred.eppls_+3A_m">m</code></td>
<td>
<p>A list containing estimators and other statistics inherited from eppls.</p>
</td></tr>
<tr><td><code id="pred.eppls_+3A_x1new">X1new</code></td>
<td>
<p>The value of X1 with which to estimate or predict Y.  A p1 dimensional vector.</p>
</td></tr>
<tr><td><code id="pred.eppls_+3A_x2new">X2new</code></td>
<td>
<p>The value of X2 with which to estimate or predict Y.  A p2 dimensional vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates the partial envelope model at new value Xnew.  It can perform estimation: find the fitted value when X = Xnew, or prediction: predict Y when X = Xnew.  The covariance matrix and the standard errors are also provided.
</p>


<h3>Value</h3>

<p>The output is a list that contains following components.
</p>
<table>
<tr><td><code>value</code></td>
<td>

<p>The fitted value or the predicted value evaluated at X1new and X2new.
</p>
</td></tr> 
<tr><td><code>covMatrix.estm</code></td>
<td>

<p>The covariance matrix of the fitted value at X1new and X2new.
</p>
</td></tr> 
<tr><td><code>SE.estm</code></td>
<td>

<p>The standard error of the fitted value at X1new and X2new.
</p>
</td></tr> 
<tr><td><code>covMatrix.pred</code></td>
<td>

<p>The covariance matrix of the predicted value at X1new and X2new.
</p>
</td></tr> 
<tr><td><code>SE.pred</code></td>
<td>

<p>The standard error of the predicted value at X1new and X2new.
</p>
</td></tr>  
</table>


<h3>References</h3>

<p>Park, Y., Su, Z. and Chung, D. (2022+)  Envelope-based Partial Partial Least Squares with Application to Cytokine-based Biomarker Analysis for COVID-19.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(amitriptyline)
  
  Y &lt;- amitriptyline[ , 1:2]
  X1 &lt;- amitriptyline[ , 4:7]
  X2 &lt;- amitriptyline[ , 3]
  u &lt;- u.eppls(X1, X2, Y)
  
  u
  
  m &lt;- eppls(X1, X2, Y, 2)
  
  pred.res &lt;- pred.eppls(m, X1[1, ], X2[1])
  pred.res
</code></pre>

<hr>
<h2 id='pred.felmdir'>Estimation or prediction for felmdir</h2><span id='topic+pred.felmdir'></span>

<h3>Description</h3>

<p>Perform estimation or prediction under the functional envelope linear model, using the direct estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred.felmdir(X, Y, ux, uy, t1, t2, Xnew, knots = c(0, 0.25, 0.5, 0.75, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred.felmdir_+3A_x">X</code></td>
<td>
<p>Predictor function. An n by T1 matrix, T1 is number of observed time points, which is the length of t1.  Here we assume that each function is observed at the same time points.</p>
</td></tr>
<tr><td><code id="pred.felmdir_+3A_y">Y</code></td>
<td>
<p>Response function. An n by T2 matrix, T2 is number of observed time points, which is the length of t2.  Here we assume that each function is observed at the same time points.</p>
</td></tr>
<tr><td><code id="pred.felmdir_+3A_ux">ux</code></td>
<td>
<p>Dimension of the predictor envelope. An integer between 0 and number of knots +2.</p>
</td></tr>
<tr><td><code id="pred.felmdir_+3A_uy">uy</code></td>
<td>
<p>Dimension of the response envelope. An integer between 0 and number of knots +2.</p>
</td></tr>
<tr><td><code id="pred.felmdir_+3A_t1">t1</code></td>
<td>
<p>The observed time points for the predictor functions.</p>
</td></tr>
<tr><td><code id="pred.felmdir_+3A_t2">t2</code></td>
<td>
<p>The observed time points for the response functions.</p>
</td></tr>
<tr><td><code id="pred.felmdir_+3A_xnew">Xnew</code></td>
<td>
<p>The value of X with which to estimate or predict Y.  A T1 dimensional vector. The observed time points should be the same as those of X.</p>
</td></tr>
<tr><td><code id="pred.felmdir_+3A_knots">knots</code></td>
<td>
<p>The location of knots of the cubic splines used for estimation.  Locations should be positive. The default location of the knots are 0, 0.25, 0.5, 0.75, 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates the functional envelope linear model at new value Xnew.  It can perform estimation: find the fitted value when X = Xnew, or prediction: predict Y when X = Xnew.  The covariance matrix and the standard errors are also provided.  The estimation method uses the direct estimation in Su et al. (2022) with cubic splines.
</p>


<h3>Value</h3>

<p>The output is a list that contains following components.
</p>
<table>
<tr><td><code>value</code></td>
<td>
<p>The fitted value or the predicted value evaluated at Xnew.  The fitted or predicted values are at the same observation points as Y.</p>
</td></tr> 
<tr><td><code>covMatrix.estm</code></td>
<td>
<p>The covariance matrix of the fitted value at Xnew.</p>
</td></tr> 
<tr><td><code>SE.estm</code></td>
<td>
<p>The standard error of the fitted value at Xnew.</p>
</td></tr> 
<tr><td><code>covMatrix.pred</code></td>
<td>
<p>The covariance matrix of the predicted value at Xnew.</p>
</td></tr> 
<tr><td><code>SE.pred</code></td>
<td>
<p>The standard error of the predicted value at Xnew.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Su, Z., Li, B. and Cook, R. D. (2022+) Envelope model for function-on-function linear regression.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(NJdata)
dataX &lt;- matrix(NJdata[,6], nrow = 21)
X &lt;- as.matrix(dataX[, 32:61])
dataY &lt;- matrix(NJdata[,3], nrow = 21)
Y &lt;- as.matrix(dataY[, 32:61])
t1 &lt;- 0:29
t2 &lt;- t1

m &lt;- pred.felmdir(X, Y, 3, 1, t1, t2, X[1,])
m$value
m$SE.estm
m$SE.pred
</code></pre>

<hr>
<h2 id='pred.felmKL'>Estimation or prediction for felmKL</h2><span id='topic+pred.felmKL'></span>

<h3>Description</h3>

<p>Perform estimation or prediction under the functional envelope linear model, using Karhunen-Loeve expansion based estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred.felmKL(X, Y, ux, uy, t1, t2, Xnew, knots = c(0, 0.25, 0.5, 0.75, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred.felmKL_+3A_x">X</code></td>
<td>
<p>Predictor function. An n by T1 matrix, T1 is number of observed time points, which is the length of t1.  Here we assume that each function is observed at the same time points.</p>
</td></tr>
<tr><td><code id="pred.felmKL_+3A_y">Y</code></td>
<td>
<p>Response function. An n by T2 matrix, T2 is number of observed time points, which is the length of t2.  Here we assume that each function is observed at the same time points.</p>
</td></tr>
<tr><td><code id="pred.felmKL_+3A_ux">ux</code></td>
<td>
<p>Dimension of the predictor envelope. An integer between 0 and number of knots +2.</p>
</td></tr>
<tr><td><code id="pred.felmKL_+3A_uy">uy</code></td>
<td>
<p>Dimension of the response envelope. An integer between 0 and number of knots +2.</p>
</td></tr>
<tr><td><code id="pred.felmKL_+3A_t1">t1</code></td>
<td>
<p>The observed time points for the predictor functions.</p>
</td></tr>
<tr><td><code id="pred.felmKL_+3A_t2">t2</code></td>
<td>
<p>The observed time points for the response functions.</p>
</td></tr>
<tr><td><code id="pred.felmKL_+3A_xnew">Xnew</code></td>
<td>
<p>The value of X with which to estimate or predict Y.  A T1 dimensional vector. The observed time points should be the same as those of X.</p>
</td></tr>
<tr><td><code id="pred.felmKL_+3A_knots">knots</code></td>
<td>
<p>The location of knots of the cubic splines used for estimation.  Locations should be positive. The default location of the knots are 0, 0.25, 0.5, 0.75, 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates the functional envelope linear model at new value Xnew.  It can perform estimation: find the fitted value when X = Xnew, or prediction: predict Y when X = Xnew.  The covariance matrix and the standard errors are also provided.  The estimation method uses the Karhunen-Loeve expansion based estimation in Su et al. (2022) with cubic splines.
</p>


<h3>Value</h3>

<p>The output is a list that contains following components.
</p>
<table>
<tr><td><code>value</code></td>
<td>
<p>The fitted value or the predicted value evaluated at Xnew.  The fitted or predicted values are at the same observation points as Y.</p>
</td></tr> 
<tr><td><code>covMatrix.estm</code></td>
<td>
<p>The covariance matrix of the fitted value at Xnew.</p>
</td></tr> 
<tr><td><code>SE.estm</code></td>
<td>
<p>The standard error of the fitted value at Xnew.</p>
</td></tr> 
<tr><td><code>covMatrix.pred</code></td>
<td>
<p>The covariance matrix of the predicted value at Xnew.</p>
</td></tr> 
<tr><td><code>SE.pred</code></td>
<td>
<p>The standard error of the predicted value at Xnew.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Su, Z., Li, B. and Cook, R. D. (2022+) Envelope model for function-on-function linear regression.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(NJdata)
dataX &lt;- matrix(NJdata[,6], nrow = 21)
X &lt;- as.matrix(dataX[, 32:61])
dataY &lt;- matrix(NJdata[,3], nrow = 21)
Y &lt;- as.matrix(dataY[, 32:61])
t1 &lt;- 0:29
t2 &lt;- t1

m &lt;- pred.felmKL(X, Y, 4, 3, t1, t2, X[1,])
m$value
m$SE.estm
m$SE.pred
</code></pre>

<hr>
<h2 id='pred.genv'>Estimation or prediction for genv</h2><span id='topic+pred.genv'></span>

<h3>Description</h3>

<p>Perform estimation or prediction under the groupwise envelope model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred.genv(m, Xnew, Znew)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred.genv_+3A_m">m</code></td>
<td>
<p>A list containing estimators and other statistics inherited from env.</p>
</td></tr>
<tr><td><code id="pred.genv_+3A_xnew">Xnew</code></td>
<td>
<p>The value of X with which to estimate or predict Y.  A p dimensional vector.</p>
</td></tr>
<tr><td><code id="pred.genv_+3A_znew">Znew</code></td>
<td>
<p>A group indicator of X.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates the envelope model at new value Xnew.  It can perform estimation: find the fitted value when X = Xnew with a group indicator Z = Znew, or prediction: predict Y when X = Xnew with a group indicator Z = Znew.  The covariance matrix and the standard errors are also provided.
</p>


<h3>Value</h3>

<p>The output is a list that contains following components.
</p>
<table>
<tr><td><code>value</code></td>
<td>
<p>The fitted value or the predicted value evaluated at Znew.</p>
</td></tr> 
<tr><td><code>covMatrix.estm</code></td>
<td>
<p>The covariance matrix of the fitted value at Znew.</p>
</td></tr> 
<tr><td><code>SE.estm</code></td>
<td>
<p>The standard error of the fitted value at Znew.</p>
</td></tr> 
<tr><td><code>covMatrix.pred</code></td>
<td>
<p>The covariance matrix of the predicted value at Znew.</p>
</td></tr> 
<tr><td><code>SE.pred</code></td>
<td>
<p>The standard error of the predicted value at Znew.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(fiberpaper)
X &lt;- fiberpaper[ , c(5, 7)]
Y &lt;- fiberpaper[ , 1:3]
Z &lt;- as.numeric(fiberpaper[ , 6] &gt; mean(fiberpaper[ , 6]))
u &lt;- u.genv(X, Y, Z)
u

m &lt;- genv(X, Y, Z, 2)
m

X &lt;- as.matrix(X)
pred.res &lt;- pred.genv(m, X[2, ], Z[2])
pred.res

</code></pre>

<hr>
<h2 id='pred.henv'>Estimation or prediction for henv</h2><span id='topic+pred.henv'></span>

<h3>Description</h3>

<p>Perform estimation or prediction under the heteroscedastic envelope model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred.henv(m, Xnew)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred.henv_+3A_m">m</code></td>
<td>
<p>A list containing estimators and other statistics inherited from henv.</p>
</td></tr>
<tr><td><code id="pred.henv_+3A_xnew">Xnew</code></td>
<td>
<p>The value of X with which to estimate or predict Y. An r by 1 vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates the heteroscedastic envelope model at new value Xnew.  It can perform estimation: find the fitted value when X = Xnew, or prediction: predict Y when X = Xnew.  The covariance matrix and the standard errors are also provided.
</p>


<h3>Value</h3>

<p>The output is a list that contains following components.
</p>
<table>
<tr><td><code>value</code></td>
<td>
<p>The fitted value or the predicted value evaluated at Xnew.</p>
</td></tr> 
<tr><td><code>covMatrix.estm</code></td>
<td>
<p>The covariance matrix of the fitted value at Xnew.</p>
</td></tr> 
<tr><td><code>SE.estm</code></td>
<td>
<p>The standard error of the fitted value at Xnew.</p>
</td></tr> 
<tr><td><code>covMatrix.pred</code></td>
<td>
<p>The covariance matrix of the predicted value at Xnew.</p>
</td></tr> 
<tr><td><code>SE.pred</code></td>
<td>
<p>The standard error of the predicted value at Xnew.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(waterstrider)
X &lt;- waterstrider[ , 1]
Y &lt;- waterstrider[ , 2:5]


## Not run: m &lt;- henv(X, Y, 2)

## Not run: pred.res &lt;- pred.henv(m, X[2])

</code></pre>

<hr>
<h2 id='pred.logit.env'>Estimation or prediction for logit.env</h2><span id='topic+pred.logit.env'></span>

<h3>Description</h3>

<p>Perform estimation or prediction under the envelope model in logistic regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred.logit.env(m, Xnew)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred.logit.env_+3A_m">m</code></td>
<td>
<p>A list containing estimators and other statistics inherited from xenv.</p>
</td></tr>
<tr><td><code id="pred.logit.env_+3A_xnew">Xnew</code></td>
<td>
<p>The value of X with which to estimate or predict Y.  A p dimensional vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates the envelope model at new value Xnew.  It can perform estimation: find the fitted value when X = Xnew.  The covariance matrix of estimation and the standard errors of estimation are also provided.
</p>


<h3>Value</h3>

<p>The output is a list that contains following components.
</p>
<table>
<tr><td><code>value</code></td>
<td>
<p>The fitted value or predicted value evaluated at Xnew.</p>
</td></tr> 
<tr><td><code>covMatrix.estm</code></td>
<td>
<p>The covariance matrix of the fitted value at Xnew.</p>
</td></tr> 
<tr><td><code>SE.estm</code></td>
<td>
<p>The standard error of the fitted value at Xnew.</p>
</td></tr>  
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(horseshoecrab)	
X1 &lt;- as.numeric(horseshoecrab[ , 1] == 2)
X2 &lt;- as.numeric(horseshoecrab[ , 1] == 3)
X3 &lt;- as.numeric(horseshoecrab[ , 1] == 4)
X4 &lt;- as.numeric(horseshoecrab[ , 2] == 2)
X5 &lt;- as.numeric(horseshoecrab[ , 2] == 3)
X6 &lt;- horseshoecrab[ , 3]
X7 &lt;- horseshoecrab[ , 5]
X &lt;- cbind(X1, X2, X3, X4, X5, X6, X7)
Y &lt;- as.numeric(ifelse(horseshoecrab[ , 4] &gt; 0, 1, 0))

m &lt;- logit.env(X, Y, 1)

pred.res &lt;- pred.logit.env(m, X[1, ])
pred.res

</code></pre>

<hr>
<h2 id='pred.penv'>Estimation or prediction for penv</h2><span id='topic+pred.penv'></span>

<h3>Description</h3>

<p>Perform estimation or prediction under the partial envelope model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred.penv(m, X1new, X2new)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred.penv_+3A_m">m</code></td>
<td>
<p>A list containing estimators and other statistics inherited from penv.</p>
</td></tr>
<tr><td><code id="pred.penv_+3A_x1new">X1new</code></td>
<td>
<p>The value of X1 with which to estimate or predict Y.  A p1 dimensional vector.</p>
</td></tr>
<tr><td><code id="pred.penv_+3A_x2new">X2new</code></td>
<td>
<p>The value of X2 with which to estimate or predict Y.  A p2 dimensional vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates the partial envelope model at new value Xnew.  It can perform estimation: find the fitted value when X = Xnew, or prediction: predict Y when X = Xnew.  The covariance matrix and the standard errors are also provided.
</p>


<h3>Value</h3>

<p>The output is a list that contains following components.
</p>
<table>
<tr><td><code>value</code></td>
<td>
<p>The fitted value or the predicted value evaluated at X1new and X2new.</p>
</td></tr> 
<tr><td><code>covMatrix.estm</code></td>
<td>
<p>The covariance matrix of the fitted value at X1new and X2new.</p>
</td></tr> 
<tr><td><code>SE.estm</code></td>
<td>
<p>The standard error of the fitted value at X1new and X2new.</p>
</td></tr> 
<tr><td><code>covMatrix.pred</code></td>
<td>
<p>The covariance matrix of the predicted value at X1new and X2new.</p>
</td></tr> 
<tr><td><code>SE.pred</code></td>
<td>
<p>The standard error of the predicted value at X1new and X2new.</p>
</td></tr>  
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(fiberpaper)
X1 &lt;- fiberpaper[, 7]
X2 &lt;- fiberpaper[, 5:6]
Y &lt;- fiberpaper[, 1:4]
m &lt;- penv(X1, X2, Y, 1)

pred.res &lt;- pred.penv(m, X1[1], X2[1, ])
pred.res
</code></pre>

<hr>
<h2 id='pred.pois.env'>Estimation or prediction for pois.env</h2><span id='topic+pred.pois.env'></span>

<h3>Description</h3>

<p>Perform estimation or prediction under the envelope model in poisson regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred.pois.env(m, Xnew)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred.pois.env_+3A_m">m</code></td>
<td>
<p>A list containing estimators and other statistics inherited from xenv.</p>
</td></tr>
<tr><td><code id="pred.pois.env_+3A_xnew">Xnew</code></td>
<td>
<p>The value of X with which to estimate or predict Y.  A p dimensional vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates the envelope in poisson regression at new value Xnew.  It can perform estimation: find the fitted value when X = Xnew, or prediction: predict Y when X = Xnew.  The covariance matrix of estimation and the standard errors of estimation are also provided.
</p>


<h3>Value</h3>

<p>The output is a list that contains following components.
</p>
<table>
<tr><td><code>value</code></td>
<td>
<p>The fitted value or the predicted value evaluated at Xnew.</p>
</td></tr> 
<tr><td><code>covMatrix.estm</code></td>
<td>
<p>The covariance matrix of the fitted value at Xnew.</p>
</td></tr> 
<tr><td><code>SE.estm</code></td>
<td>
<p>The standard error of the fitted value at Xnew.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(horseshoecrab)
X1 &lt;- as.numeric(horseshoecrab[ , 1] == 2)
X2 &lt;- as.numeric(horseshoecrab[ , 1] == 3)
X3 &lt;- as.numeric(horseshoecrab[ , 1] == 4)
X4 &lt;- as.numeric(horseshoecrab[ , 2] == 2)
X5 &lt;- as.numeric(horseshoecrab[ , 2] == 3)
X6 &lt;- horseshoecrab[ , 3]
X7 &lt;- horseshoecrab[ , 5]
X &lt;- cbind(X1, X2, X3, X4, X5, X6, X7)
Y &lt;- horseshoecrab[ , 4]

m &lt;- pois.env(X, Y, 1)

pred.res &lt;- pred.pois.env(m, X[1, ])
pred.res

</code></pre>

<hr>
<h2 id='pred.rrenv'>Estimation or prediction for rrenv</h2><span id='topic+pred.rrenv'></span>

<h3>Description</h3>

<p>Perform estimation or prediction under the reduced rank envelope model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred.rrenv(m, Xnew)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred.rrenv_+3A_m">m</code></td>
<td>
<p>A list containing estimators and other statistics inherited from rrenv.</p>
</td></tr>
<tr><td><code id="pred.rrenv_+3A_xnew">Xnew</code></td>
<td>
<p>The value of X with which to estimate or predict Y.  A p dimensional vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates the reduced rank envelope model at new value Xnew.  It can perform estimation: find the fitted value when X = Xnew, or prediction: predict Y when X = Xnew.  The covariance matrix and the standard errors are also provided.
</p>


<h3>Value</h3>

<p>The output is a list that contains following components.
</p>
<table>
<tr><td><code>value</code></td>
<td>
<p>The fitted value or the predicted value evaluated at Xnew.</p>
</td></tr> 
<tr><td><code>covMatrix.estm</code></td>
<td>
<p>The covariance matrix of the fitted value at Xnew.</p>
</td></tr> 
<tr><td><code>SE.estm</code></td>
<td>
<p>The standard error of the fitted value at Xnew.</p>
</td></tr> 
<tr><td><code>covMatrix.pred</code></td>
<td>
<p>The covariance matrix of the predicted value at Xnew.</p>
</td></tr> 
<tr><td><code>SE.pred</code></td>
<td>
<p>The standard error of the predicted value at Xnew.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(vehicles)
X &lt;- vehicles[, 1:11]  
Y &lt;- vehicles[, 12:15]
X &lt;- scale(X)
Y &lt;- scale(Y)  # The scales of Y are vastly different, so scaling is reasonable here

m &lt;- rrenv(X, Y, 4, 2)
m

X &lt;- as.matrix(X)
pred.res &lt;- pred.rrenv(m, X[2, ])
pred.res

</code></pre>

<hr>
<h2 id='pred.rrenv.apweights'>Estimation or prediction for rrenv.apweights</h2><span id='topic+pred.rrenv.apweights'></span>

<h3>Description</h3>

<p>Perform estimation or prediction under the reduced rank envelope model with nonconstant error covariance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred.rrenv.apweights(m, Xnew)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred.rrenv.apweights_+3A_m">m</code></td>
<td>
<p>A list containing estimators and other statistics inherited from rrenv.apweights.</p>
</td></tr>
<tr><td><code id="pred.rrenv.apweights_+3A_xnew">Xnew</code></td>
<td>
<p>The value of X with which to estimate or predict Y.  A p dimensional vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates the reduced rank envelope model that accommodates nonconstant error covariance at new value Xnew.  It can perform estimation: find the fitted value when X = Xnew, or prediction: predict Y when X = Xnew.  The covariance matrix and the standard errors are also provided.
</p>


<h3>Value</h3>

<p>The output is a list that contains following components.
</p>
<table>
<tr><td><code>value</code></td>
<td>
<p>The fitted value or the predicted value evaluated at Xnew.</p>
</td></tr> 
<tr><td><code>covMatrix.estm</code></td>
<td>
<p>The covariance matrix of the fitted value at Xnew.</p>
</td></tr> 
<tr><td><code>SE.estm</code></td>
<td>
<p>The standard error of the fitted value at Xnew.</p>
</td></tr> 
<tr><td><code>covMatrix.pred</code></td>
<td>
<p>The covariance matrix of the predicted value at Xnew.</p>
</td></tr> 
<tr><td><code>SE.pred</code></td>
<td>
<p>The standard error of the predicted value at Xnew.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(vehicles)
X &lt;- vehicles[, 1:11]  
Y &lt;- vehicles[, 12:15]
X &lt;- scale(X)
Y &lt;- scale(Y)  # The scales of Y are vastly different, so scaling is reasonable here

## Not run: m &lt;- rrenv.apweights(X, Y, 3, 2)
## Not run: m

## Not run: X &lt;- as.matrix(X)
## Not run: pred.res &lt;- pred.rrenv.apweights(m, X[2, ])
## Not run: pred.res

</code></pre>

<hr>
<h2 id='pred.senv'>Estimation or prediction for senv</h2><span id='topic+pred.senv'></span>

<h3>Description</h3>

<p>Perform estimation or prediction under the scaled response envelope model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred.senv(m, Xnew)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred.senv_+3A_m">m</code></td>
<td>
<p>A list containing estimators and other statistics inherited from scale.env.</p>
</td></tr>
<tr><td><code id="pred.senv_+3A_xnew">Xnew</code></td>
<td>
<p>The value of X with which to estimate or predict Y.  A p dimensional vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates the scaled envelope model at new value Xnew.  It can perform estimation: find the fitted value when X = Xnew, or prediction: predict Y when X = Xnew.  The covariance matrix and the standard errors are also provided.
</p>


<h3>Value</h3>

<p>The output is a list that contains following components.
</p>
<table>
<tr><td><code>value</code></td>
<td>
<p>The fitted value or the predicted value evaluated at Xnew.</p>
</td></tr> 
<tr><td><code>covMatrix.estm</code></td>
<td>
<p>The covariance matrix of the fitted value at Xnew.</p>
</td></tr> 
<tr><td><code>SE.estm</code></td>
<td>
<p>The standard error of the fitted value at Xnew.</p>
</td></tr> 
<tr><td><code>covMatrix.pred</code></td>
<td>
<p>The covariance matrix of the predicted value at Xnew.</p>
</td></tr> 
<tr><td><code>SE.pred</code></td>
<td>
<p>The standard error of the predicted value at Xnew.</p>
</td></tr>  
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(sales)
X &lt;- sales[, 1:3]
Y &lt;- sales[, 4:7]

m &lt;- senv(X, Y, 2)

pred.res &lt;- pred.senv(m, X[2, ])
pred.res

</code></pre>

<hr>
<h2 id='pred.stenv'>Estimation or prediction for stenv</h2><span id='topic+pred.stenv'></span>

<h3>Description</h3>

<p>Perform estimation or prediction under the simultaneous envelope model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred.stenv(m, Xnew)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred.stenv_+3A_m">m</code></td>
<td>
<p>A list containing estimators and other statistics inherited from stenv.</p>
</td></tr>
<tr><td><code id="pred.stenv_+3A_xnew">Xnew</code></td>
<td>
<p>The value of X with which to estimate or predict Y.  A p dimensional vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates the simultaneous envelope model at new value Xnew.  It can perform estimation: find the fitted value when X = Xnew, or prediction: predict Y when X = Xnew.  The covariance matrix and the standard errors are also provided.
</p>


<h3>Value</h3>

<p>The output is a list that contains following components.
</p>
<table>
<tr><td><code>value</code></td>
<td>
<p>The fitted value or the predicted value evaluated at Xnew.</p>
</td></tr> 
<tr><td><code>covMatrix.estm</code></td>
<td>
<p>The covariance matrix of the fitted value at Xnew.</p>
</td></tr> 
<tr><td><code>SE.estm</code></td>
<td>
<p>The standard error of the fitted value at Xnew.</p>
</td></tr> 
<tr><td><code>covMatrix.pred</code></td>
<td>
<p>The covariance matrix of the predicted value at Xnew.</p>
</td></tr> 
<tr><td><code>SE.pred</code></td>
<td>
<p>The standard error of the predicted value at Xnew.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(fiberpaper)
X &lt;- fiberpaper[ , 5:7]
Y &lt;- fiberpaper[ , 1:4]

m &lt;- stenv(X, Y, 2, 3)
m

pred.res &lt;- pred.stenv(m, X[1, ])
pred.res

</code></pre>

<hr>
<h2 id='pred.sxenv'>Estimation or prediction for sxenv</h2><span id='topic+pred.sxenv'></span>

<h3>Description</h3>

<p>Perform estimation or prediction under the scaled predictor envelope model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred.sxenv(m, Xnew)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred.sxenv_+3A_m">m</code></td>
<td>
<p>A list containing estimators and other statistics inherited from stenv.</p>
</td></tr>
<tr><td><code id="pred.sxenv_+3A_xnew">Xnew</code></td>
<td>
<p>The value of X with which to estimate or predict Y.  A p dimensional vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates the scaled envelope model in the predictor space at new value Xnew.  It can perform estimation: find the fitted value when X = Xnew, or prediction: predict Y when X = Xnew.  The covariance matrix and the standard errors are also provided.
</p>


<h3>Value</h3>

<p>The output is a list that contains following components.
</p>
<table>
<tr><td><code>value</code></td>
<td>
<p>The fitted value or the predicted value evaluated at Xnew.</p>
</td></tr> 
<tr><td><code>covMatrix.estm</code></td>
<td>
<p>The covariance matrix of the fitted value at Xnew.</p>
</td></tr> 
<tr><td><code>SE.estm</code></td>
<td>
<p>The standard error of the fitted value at Xnew.</p>
</td></tr> 
<tr><td><code>covMatrix.pred</code></td>
<td>
<p>The covariance matrix of the predicted value at Xnew.</p>
</td></tr> 
<tr><td><code>SE.pred</code></td>
<td>
<p>The standard error of the predicted value at Xnew.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(sales)
Y &lt;- sales[, 1:3]
X &lt;- sales[, 4:7]
R &lt;- rep(1, 4)

m &lt;- sxenv(X, Y, 2, R)

pred.res &lt;- pred.sxenv(m, X[1, ])
pred.res

</code></pre>

<hr>
<h2 id='pred.xenv'>Estimation or prediction for xenv</h2><span id='topic+pred.xenv'></span>

<h3>Description</h3>

<p>Perform estimation or prediction under the predictor envelope model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred.xenv(m, Xnew)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred.xenv_+3A_m">m</code></td>
<td>
<p>A list containing estimators and other statistics inherited from xenv.</p>
</td></tr>
<tr><td><code id="pred.xenv_+3A_xnew">Xnew</code></td>
<td>
<p>The value of X with which to estimate or predict Y.  A p dimensional vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates the envelope model at new value Xnew.  It can perform estimation: find the fitted value when X = Xnew, or prediction: predict Y when X = Xnew.  The covariance matrix and the standard errors are also provided.
</p>


<h3>Value</h3>

<p>The output is a list that contains following components.
</p>
<table>
<tr><td><code>value</code></td>
<td>
<p>The fitted value or the predicted value evaluated at Xnew.</p>
</td></tr> 
<tr><td><code>covMatrix.estm</code></td>
<td>
<p>The covariance matrix of the fitted value at Xnew.</p>
</td></tr> 
<tr><td><code>SE.estm</code></td>
<td>
<p>The standard error of the fitted value at Xnew.</p>
</td></tr> 
<tr><td><code>covMatrix.pred</code></td>
<td>
<p>The covariance matrix of the predicted value at Xnew.</p>
</td></tr> 
<tr><td><code>SE.pred</code></td>
<td>
<p>The standard error of the predicted value at Xnew.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(wheatprotein)
X &lt;- wheatprotein[, 1:6]
Y &lt;- wheatprotein[, 7]

m &lt;- xenv(X, Y, 2)
m

pred.res &lt;- pred.xenv(m, X[1, ])
pred.res

</code></pre>

<hr>
<h2 id='pred2.env'>Estimation or prediction for env</h2><span id='topic+pred2.env'></span>

<h3>Description</h3>

<p>Perform estimation or prediction under the envelope model through partial envelope model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred2.env(X, Y, u, Xnew)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred2.env_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="pred2.env_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="pred2.env_+3A_u">u</code></td>
<td>
<p>The dimension of the constructed partial envelope model.</p>
</td></tr>
<tr><td><code id="pred2.env_+3A_xnew">Xnew</code></td>
<td>
<p>The value of X with which to estimate or predict Y.  A p dimensional vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates the envelope model at new value Xnew.  It can perform estimation: find the fitted value when X = Xnew, or prediction: predict Y when X = Xnew.  The covariance matrix and the standard errors are also provided.  Compared to predict.env, this function performs prediction through partial envelope model, which can be more accurate if the partial envelope is of smaller dimension and contains less variant material information.  The constructed partial envelope model is obtained by the following: Let A0 by a p by p-1 matrix, such that A = (Xnew, A0) has full rank.  Let phi1 = beta * Xnew, phi2 = beta * A0, phi = (phi1, phi2) and X = inverse of A * X = (Z1, Z2')'.  Then the model Y = alpha + beta * X + epsilon can be reparameterized as Y = alpha + phi1 * Z1 + phi2 * Z2 + epsilon.  We then fit a partial envelope model with Z1 as the predictor of interest, and predict at (Z1, Z2')' =  inverse of A * Xnew.
</p>


<h3>Value</h3>

<p>The output is a list that contains following components.
</p>
<table>
<tr><td><code>value</code></td>
<td>
<p>The fitted value or the predicted value evaluated at Xnew.</p>
</td></tr> 
<tr><td><code>covMatrix.estm</code></td>
<td>
<p>The covariance matrix of the fitted value at Xnew.</p>
</td></tr> 
<tr><td><code>SE.estm</code></td>
<td>
<p>The standard error of the fitted value at Xnew.</p>
</td></tr> 
<tr><td><code>covMatrix.pred</code></td>
<td>
<p>The covariance matrix of the predicted value at Xnew.</p>
</td></tr> 
<tr><td><code>SE.pred</code></td>
<td>
<p>The standard error of the predicted value at Xnew.</p>
</td></tr>  
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(fiberpaper)
X &lt;- fiberpaper[, 5:7]
Y &lt;- fiberpaper[, 1:4]

u &lt;- u.pred2.env(X, Y, X[10, ])
pred.res &lt;- pred2.env(X, Y, u$u.bic, X[10, ])
pred.res$SE.estm
pred.res$SE.pred
</code></pre>

<hr>
<h2 id='Renvlp-package'>
Computing Envelope Estimators
</h2><span id='topic+Renvlp-package'></span>

<h3>Description</h3>

<p>This package contains functions for estimating envelope models including response envelopes, partial response envelopes, envelopes in the predictor space, heteroscedastic envelopes, simultaneous envelopes, scaled response envelopes, scaled envelopes in the predictor space, groupwise envelopes, weighted envelopes, envelopes in logistic regression, envelopes in poisson regression, envelopes in function-on-function linear regression, envelope-based Partial Partial Least Squares,  envelopes with non-constant error covariance, envelopes with t-distributed errors, reduced rank envelopes and reduced rank envelopes with non-constant error covariance.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> Renvlp</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 3.4.5</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-09-11</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> Rsolnp, orthogonalsplinebasis, pls, matrixcalc, Matrix</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> Mass, stats</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Minji Lee and Zhihua Su.
</p>
<p>Maintainer: Minji Lee &lt;minjilee101@gmail.com&gt;
</p>


<h3>References</h3>

<p>Cook, R. D., Forzani, L. and Su, Z. (2016) A Note on Fast Envelope Estimation. Journal of Multivariate Analysis. 150, 42-54.	
</p>
<p>Cook, R. D., Li, B. and Chiaromente, F. (2010). Envelope Models for Parsimonious and Efficient Multivariate Linear Regression (with discussion). Statist. Sinica 20, 927- 1010.
</p>
<p>Su, Z. and Cook, R.D. (2011). Partial envelopes for efficient estimation in multivariate linear regression. Biometrika 98, 133 - 146.
</p>
<p>Cook, R. D., Helland, I. S. and Su, Z. (2013). Envelopes and Partial Least Squares Re-
gression. Journal of the Royal Statistical Society: Series B 75, 851 - 877.
</p>
<p>Su, Z. and Cook, R.D. (2013). Estimation of Multivariate Means with Heteroscedastic Error Using Envelope Models. Statistica Sinica, 23, 213-230.
</p>
<p>Cook, R. D., Zhang, X. (2015). Simultaneous Envelopes for Multivariate Linear Regression. Technometrics 57, 11 - 25.
</p>
<p>Cook, R. D., Su, Z. (2013). Scaled Envelopes: scale Invariant and Efficient Estimation in Multivariate Linear Regression. Biometrika 100, 939 - 954.
</p>
<p>Cook, R. D., Su, Z. (2016). Scaled Predictor Envelopes and Partial Least Squares Regression. Technometrics 58, 155 - 165.
</p>
<p>Park, Y., Su, Z. and Zhu, H. (2017)  Groupwise envelope models for Imaging Genetic Analysis. Biometrics.
</p>
<p>Eck, D. J. and Cook, R. D. (2017). Weighted Envelope Estimation to Handle Variability in Model
Selection. Biometrika.
</p>
<p>Cook, R. D., Zhang, X. (2015). Foundations for Envelope Models and Methods. Journal of the American Statistical Association 110, 599 - 611.
</p>
<p>Su, Z., Li, B. and Cook, R. D. (2022+) Envelope model for function-on-function linear regression.
</p>
<p>Park, Y., Su, Z. and Chung, D. (2022+)  Envelope-based Partial Partial Least Squares with Application to Cytokine-based Biomarker Analysis for COVID-19. Statistics in Medicine. 
</p>
<p>Cook, R. D., Forzani, L. and Zhang, X. (2015). Envelopes and reduced-rank regression.  Biometrika 102, 439-456.
</p>
<p>Forzani, L. and Su, Z. (2021). Envelopes for elliptical multivariate linear regression. Statist. Sinica 31, 301-332.
</p>

<hr>
<h2 id='rrenv'>Fit the reduced-rank envelope model</h2><span id='topic+rrenv'></span>

<h3>Description</h3>

<p>Fit the reduced-rank envelope model with rank d and fixed envelope dimension u. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rrenv(X, Y, u, d, asy = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rrenv_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="rrenv_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="rrenv_+3A_u">u</code></td>
<td>
<p>Dimension of the envelope. An integer between 0 and r.</p>
</td></tr>
<tr><td><code id="rrenv_+3A_d">d</code></td>
<td>
<p>The rank of the coefficient matrix.  An integer between 0 and u.</p>
</td></tr>
<tr><td><code id="rrenv_+3A_asy">asy</code></td>
<td>
<p>Flag for computing the asymptotic variance of the reduced rank envelope estimator.  The default is <code>TRUE</code>. When p and r are large, computing the asymptotic variance can take much time and memory.  If only the envelope estimators are needed, the flag can be set to <code>asy = FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits the reduced rank envelope model to the responses and predictors, </p>
<p style="text-align: center;"><code class="reqn">
 Y_{i} = \alpha + \Gamma\eta BX_{i}+\varepsilon_{i}, \Sigma=\Gamma\Omega\Gamma'+\Gamma_{0}\Omega_{0}\Gamma'_{0}, i=1, ..., n,
 </code>
</p>

<p>using the maximum likelihood estimation.  The errors <code class="reqn">\varepsilon_{i}</code> follow a normal distribution.  When 0 &lt; d &lt; u &lt; r, the estimation procedure in Cook et al. (2015) is implemented.  When d &lt; u = r, then the model is equivalent to a reduced rank regression model.  When d = u, or d = p &lt; r, then B can be taken as the identity matrix and the model reduces to a response envelope model.  When the dimension is d = u = r, then the envelope model degenerates to the standard multivariate linear regression.  When the u = 0, it means that X and Y are uncorrelated, and the fitting is different.  If the error covariance matrix is nonconstant, see the function <code>rrenv.apweights</code>.
</p>


<h3>Value</h3>

<p>The output is a list that contains the following components:
</p>
<table>
<tr><td><code>Gamma</code></td>
<td>
<p>An orthogonal basis of the envelope subspace.</p>
</td></tr>
<tr><td><code>Gamma0</code></td>
<td>
<p>An orthogonal basis of the complement of the envelope subspace.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>The estimated intercept.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>The envelope estimator of the regression coefficients.</p>
</td></tr> 
<tr><td><code>Sigma</code></td>
<td>
<p>The envelope estimator of the error covariance matrix.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>The eta matrix in the coefficient matrix.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>The B matrix in the coefficient matrix.</p>
</td></tr>
<tr><td><code>Omega</code></td>
<td>
<p>The coordinates of Sigma with respect to Gamma.</p>
</td></tr>
<tr><td><code>Omega0</code></td>
<td>
<p>The coordinates of Sigma with respect to Gamma0.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The maximized log likelihood function.</p>
</td></tr>
<tr><td><code>covMatrix</code></td>
<td>
<p>The asymptotic covariance of vec(beta). The covariance matrix returned are asymptotic.  For the actual standard errors, multiply by 1 / n.</p>
</td></tr>
<tr><td><code>asySE</code></td>
<td>
<p>The asymptotic standard error for elements in beta under the reduced rank envelope model.  The standard errors returned are asymptotic, for actual standard errors, multiply by 1 / sqrt(n).</p>
</td></tr>
<tr><td><code>ratio</code></td>
<td>
<p>The asymptotic standard error ratio of the standard multivariate linear regression estimator (with consideration of nonconstant variance) over the envelope estimator, for each element in beta.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of observations in the data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cook, R. D., Forzani, L. and Zhang, X. (2015). Envelopes and reduced-rank regression.  Biometrika 102, 439-456.
</p>
<p>Forzani, L. and Su, Z. (2021). Envelopes for elliptical multivariate linear regression. Statist. Sinica 31, 301-332.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vehicles)
X &lt;- vehicles[, 1:11]  
Y &lt;- vehicles[, 12:15]
X &lt;- scale(X)
Y &lt;- scale(Y)  # The scales of Y are vastly different, so scaling is reasonable here
d &lt;- d.select(X, Y, 0.01)
d

## Not run: u &lt;- u.rrenv(X, Y, 2)
## Not run: u

m &lt;- rrenv(X, Y, 4, 2)
m
m$beta
</code></pre>

<hr>
<h2 id='rrenv.apweights'>Fit the reduced-rank envelope model with nonconstant variance</h2><span id='topic+rrenv.apweights'></span>

<h3>Description</h3>

<p>For rank d and fixed envelope dimension u, fit the reduced-rank envelope model with nonconstant error variance.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rrenv.apweights(X, Y, u, d, asy = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rrenv.apweights_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="rrenv.apweights_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="rrenv.apweights_+3A_u">u</code></td>
<td>
<p>Dimension of the envelope. An integer between 0 and r.</p>
</td></tr>
<tr><td><code id="rrenv.apweights_+3A_d">d</code></td>
<td>
<p>The rank of the coefficient matrix.  An integer between 0 and u.</p>
</td></tr>
<tr><td><code id="rrenv.apweights_+3A_asy">asy</code></td>
<td>
<p>Flag for computing the asymptotic variance of the reduced rank envelope estimator.  The default is <code>TRUE</code>. When p and r are large, computing the asymptotic variance can take much time and memory.  If only the envelope estimators are needed, the flag can be set to <code>asy = FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits the reduced rank envelope model to the responses and predictors, </p>
<p style="text-align: center;"><code class="reqn">
 Y_{i} = \alpha + \Gamma\eta BX_{i}+\varepsilon_{i}, \Sigma=c_{i}(\Gamma\Omega\Gamma'+\Gamma_{0}\Omega_{0}\Gamma'_{0}), i=1, ..., n,
 </code>
</p>

<p>using the maximum likelihood estimation.  The errors <code class="reqn">\varepsilon_{i}</code> follow a normal distribution.  It allows that the error covariance matrix to be nonconstant.  When 0 &lt; d &lt; u &lt; r, the estimation procedure in Cook et al. (2015) is implemented.  When d &lt; u = r, then the model is equivalent to a reduced rank regression model.  When d = u, or d = p &lt; r, then B can be taken as the identity matrix and the model reduces to a response envelope model.  When the dimension is d = u = r, then the envelope model degenerates to the standard multivariate linear regression.  When the u = 0, it means that X and Y are uncorrelated, and the fitting is different.
</p>


<h3>Value</h3>

<p>The output is a list that contains the following components:
</p>
<table>
<tr><td><code>Gamma</code></td>
<td>
<p>An orthogonal basis of the envelope subspace.</p>
</td></tr>
<tr><td><code>Gamma0</code></td>
<td>
<p>An orthogonal basis of the complement of the envelope subspace.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>The estimated intercept.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>The envelope estimator of the regression coefficients.</p>
</td></tr> 
<tr><td><code>Sigma</code></td>
<td>
<p>The envelope estimator of the error covariance matrix.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>The eta matrix in the coefficient matrix.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>The B matrix in the coefficient matrix.</p>
</td></tr>
<tr><td><code>Omega</code></td>
<td>
<p>The coordinates of Sigma with respect to Gamma.</p>
</td></tr>
<tr><td><code>Omega0</code></td>
<td>
<p>The coordinates of Sigma with respect to Gamma0.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The maximized log likelihood function.</p>
</td></tr>
<tr><td><code>covMatrix</code></td>
<td>
<p>The asymptotic covariance of vec(beta). The covariance matrix returned are asymptotic.  For the actual standard errors, multiply by 1 / n.</p>
</td></tr>
<tr><td><code>asySE</code></td>
<td>
<p>The asymptotic standard error for elements in beta under the reduced rank envelope model.  The standard errors returned are asymptotic, for actual standard errors, multiply by 1 / sqrt(n).</p>
</td></tr>
<tr><td><code>ratio</code></td>
<td>
<p>The asymptotic standard error ratio of the standard multivariate linear regression estimator (with consideration of nonconstant variance) over the envelope estimator, for each element in beta.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of observations in the data.</p>
</td></tr>
<tr><td><code>C1</code></td>
<td>
<p>The estimated weights <code class="reqn">c_i</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cook, R. D., Forzani, L. and Zhang, X. (2015). Envelopes and reduced-rank regression.  Biometrika 102, 439-456.
</p>
<p>Forzani, L. and Su, Z. (2021). Envelopes for elliptical multivariate linear regression. Statist. Sinica 31, 301-332.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vehicles)
X &lt;- vehicles[, 1:11]  
Y &lt;- vehicles[, 12:15]
X &lt;- scale(X)
Y &lt;- scale(Y)  # The scales of Y are vastly different, so scaling is reasonable here
d &lt;- d.select(X, Y, 0.01)
d

## Not run: u &lt;- u.rrenv.apweights(X, Y, 2)
## Not run: u

## Not run: m &lt;- rrenv.apweights(X, Y, 3, 2)
## Not run: m
## Not run: m$beta
</code></pre>

<hr>
<h2 id='sales'>Sales staff Data
</h2><span id='topic+sales'></span>

<h3>Description</h3>

<p>On the performance of a firm's sales staff </p>


<h3>Usage</h3>

<pre><code class='language-R'>data("sales")</code></pre>


<h3>Format</h3>

<p>A data frame with 50 observations on the following 7 variables.
</p>

<dl>
<dt><code>V1</code></dt><dd><p>Index of sales growth.</p>
</dd>
<dt><code>V2</code></dt><dd><p>Index of sales profitability.</p>
</dd>
<dt><code>V3</code></dt><dd><p>Index of new account sales.</p>
</dd>
<dt><code>V4</code></dt><dd><p>Score on creativity.</p>
</dd>
<dt><code>V5</code></dt><dd><p>Score on mechanical reasoning test.</p>
</dd>
<dt><code>V6</code></dt><dd><p>Score on abstract reasoning test.</p>
</dd>
<dt><code>V7</code></dt><dd><p>Score on Mathematics test.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This data set contains 3 measures of performance and 4 tests scores.
</p>


<h3>References</h3>

<p>Johnson, R.A., Wichern, D.W. (2007). Applied Multivariage Statistical Analysis, 6th edition.
</p>

<hr>
<h2 id='senv'>Fit the scaled response envelope model</h2><span id='topic+senv'></span>

<h3>Description</h3>

<p>Fit the scaled response envelope model in multivariate linear regression with dimension u. The scaled response envelope model is a scale-invariant version of the response envelope model.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>senv(X, Y, u, asy = TRUE, init = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="senv_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="senv_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="senv_+3A_u">u</code></td>
<td>
<p>Dimension of the scaled envelope. An integer between 0 and r.</p>
</td></tr>
<tr><td><code id="senv_+3A_asy">asy</code></td>
<td>
<p>Flag for computing the asymptotic variance of the envelope estimator.  The default is <code>TRUE</code>. When p and r are large, computing the asymptotic variance can take much time and memory.  If only the scaled envelope estimators are needed, the flag can be set to <code>asy = FALSE</code>.</p>
</td></tr>
<tr><td><code id="senv_+3A_init">init</code></td>
<td>
<p>The user-specified value of Gamma for the scaled envelope subspace. An r by u matrix. The default is the one generated by function senvMU.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits the scaled envelope model to the responses and predictors, </p>
<p style="text-align: center;"><code class="reqn">
 Y = \mu + \Lambda\Gamma\eta X + \varepsilon, \Sigma=\Lambda\Gamma\Omega\Gamma'\Lambda + \Lambda\Gamma_{0}\Omega_{0}\Gamma'_{0}\Lambda
 </code>
</p>

<p>using the maximum likelihood estimation.  When the dimension of the scaled  envelope is between 1 and r-1, the starting value and blockwise coordinate descent algorithm in Cook et al. (2016) is implemented.  When the dimension is r, then the scaled envelope model degenerates to the standard multivariate linear regression.  When the dimension is 0, it means that X and Y are uncorrelated, and the fitting is different.
</p>


<h3>Value</h3>

<p>The output is a list that contains the following components:
</p>
<table>
<tr><td><code>beta</code></td>
<td>
<p>The scaled envelope estimator of the regression coefficients.</p>
</td></tr> 
<tr><td><code>Sigma</code></td>
<td>
<p>The scaled envelope estimator of the error covariance matrix.</p>
</td></tr>
<tr><td><code>Lambda</code></td>
<td>
<p>The matrix of estimated scale.</p>
</td></tr>
<tr><td><code>Gamma</code></td>
<td>
<p>An orthonormal basis of the scaled envelope subspace.</p>
</td></tr>
<tr><td><code>Gamma0</code></td>
<td>
<p>An orthonormal basis of the complement of the scaled envelope subspace.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>The coordinates of beta with respect to Gamma.</p>
</td></tr>
<tr><td><code>Omega</code></td>
<td>
<p>The coordinates of Sigma with respect to Gamma.</p>
</td></tr>
<tr><td><code>Omega0</code></td>
<td>
<p>The coordinates of Sigma with respect to Gamma0.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>The estimated intercept.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The maximized log likelihood function.</p>
</td></tr>
<tr><td><code>covMatrix</code></td>
<td>
<p>The asymptotic covariance of vec(beta). The covariance matrix returned are asymptotic.  For the actual standard errors, multiply by 1 / n.</p>
</td></tr>
<tr><td><code>asySE</code></td>
<td>
<p>The asymptotic standard error for elements in beta under the envelope model.  The standard errors returned are asymptotic, for actual standard errors, multiply by 1 / sqrt(n).</p>
</td></tr>
<tr><td><code>ratio</code></td>
<td>
<p>The asymptotic standard error ratio of the standard multivariate linear regression estimator over the envelope estimator, for each element in beta.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of observations in the data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cook, R. D., Su, Z. (2013). Scaled Envelopes: scale Invariant and Efficient Estimation in Multivariate Linear Regression. Biometrika 100, 939 - 954.
</p>
<p>Cook, R. D., Forzani, L. and Su, Z. (2016) A Note on Fast Envelope Estimation. Journal of Multivariate Analysis. 150, 42-54.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sales)
X &lt;- sales[, 1:3]
Y &lt;- sales[, 4:7]

u &lt;- u.senv(X, Y)
u

m &lt;- senv(X, Y, 2)
m$beta
</code></pre>

<hr>
<h2 id='stenv'>Fit the simultaneous envelope model</h2><span id='topic+stenv'></span>

<h3>Description</h3>

<p>Fit the simultaneous envelope model in multivariate linear regression with dimension (q, u). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stenv(X, Y, q, u, asy = TRUE, Pinit = NULL, Ginit = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stenv_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="stenv_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="stenv_+3A_q">q</code></td>
<td>
<p>Dimension of the X-envelope. An integer between 0 and p.</p>
</td></tr>
<tr><td><code id="stenv_+3A_u">u</code></td>
<td>
<p>Dimension of the Y-envelope. An integer between 0 and r.</p>
</td></tr>
<tr><td><code id="stenv_+3A_asy">asy</code></td>
<td>
<p>Flag for computing the asymptotic variance of the envelope estimator.  The default is <code>TRUE</code>. When p and r are large, computing the asymptotic variance can take much time and memory.  If only the envelope estimators are needed, the flag can be set to <code>asy = FALSE</code>.</p>
</td></tr>
<tr><td><code id="stenv_+3A_pinit">Pinit</code></td>
<td>
<p>The user-specified value of Phi for the X-envelope subspace. An p by q matrix. The default is the one generated by function stenvMU.</p>
</td></tr>
<tr><td><code id="stenv_+3A_ginit">Ginit</code></td>
<td>
<p>The user-specified value of Gamma for the Y-envelope subspace. An r by u matrix. The default is the one generated by function stenvMU.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits the envelope model to the responses and predictors simultaneously, </p>
<p style="text-align: center;"><code class="reqn">
 Y = \mu + \beta'X+\varepsilon, \beta = \Phi\eta\Gamma', \Sigma_{Y|X}=\Gamma\Omega\Gamma'+\Gamma_{0}\Omega_{0}\Gamma'_{0}, \Sigma_{X}=\Phi\Delta\Phi'+\Phi_{0}\Delta_{0}\Phi'_{0}
 </code>
</p>

<p>using the maximum likelihood estimation.  When the dimension of the Y-envelope is between 1 and r-1 and the dimension of the X-envelope is between 1 and p-1, the starting value and blockwise coordinate descent algorithm in Cook et al. (2016) is implemented.  When the dimension is (p, r), then the envelope model degenerates to the standard multivariate linear regression.  When the dimension of the Y-envelope is r, then the envelope model degenerates to the standard envelope model.  When the dimension of X-envelope is p, then the envelope model degenerates to the envelope model in the predictor space.  When the dimension is 0, it means that X and Y are uncorrelated, and the fitting is different.
</p>


<h3>Value</h3>

<p>The output is a list that contains the following components:
</p>
<table>
<tr><td><code>beta</code></td>
<td>
<p>The envelope estimator of the regression coefficients.</p>
</td></tr> 
<tr><td><code>SigmaYcX</code></td>
<td>
<p>The envelope estimator of the error covariance matrix.</p>
</td></tr>
<tr><td><code>SigmaX</code></td>
<td>
<p>The envelope estimator of the covariance matrix of X.</p>
</td></tr>
<tr><td><code>Gamma</code></td>
<td>
<p>An orthonormal basis of the Y-envelope subspace.</p>
</td></tr>
<tr><td><code>Gamma0</code></td>
<td>
<p>An orthonormal basis of the complement of the Y-envelope subspace.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>The coordinates of beta with respect to Gamma and Phi.</p>
</td></tr>
<tr><td><code>Omega</code></td>
<td>
<p>The coordinates of SigmaYcX with respect to Gamma.</p>
</td></tr>
<tr><td><code>Omega0</code></td>
<td>
<p>The coordinates of SigmaYcX with respect to Gamma0.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>The estimated intercept.</p>
</td></tr>
<tr><td><code>Phi</code></td>
<td>
<p>An orthonormal basis of the X-envelope subspace.</p>
</td></tr>
<tr><td><code>Phi0</code></td>
<td>
<p>An orthonormal basis of the complement of the X-envelope subspace.</p>
</td></tr>
<tr><td><code>Delta</code></td>
<td>
<p>The coordinates of SigmaX with respect to Phi.</p>
</td></tr>
<tr><td><code>Delta0</code></td>
<td>
<p>The coordinates of SigmaX with respect to Phi0.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The maximized log likelihood function.</p>
</td></tr>
<tr><td><code>covMatrix</code></td>
<td>
<p>The asymptotic covariance of vec(beta). The covariance matrix returned are asymptotic.  For the actual standard errors, multiply by 1 / n.</p>
</td></tr>
<tr><td><code>asySE</code></td>
<td>
<p>The asymptotic standard error for elements in beta under the envelope model.  The standard errors returned are asymptotic, for actual standard errors, multiply by 1 / sqrt(n).</p>
</td></tr>
<tr><td><code>ratio</code></td>
<td>
<p>The asymptotic standard error ratio of the standard multivariate linear regression estimator over the envelope estimator, for each element in beta.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of observations in the data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cook, R. D., Zhang, X. (2015). Simultaneous Envelopes for Multivariate Linear Regression. Technometrics 57, 11 - 25.
</p>
<p>Cook, R. D., Forzani, L. and Su, Z. (2016) A Note on Fast Envelope Estimation. Journal of Multivariate Analysis. 150, 42-54.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fiberpaper)
X &lt;- fiberpaper[, 5:7]
Y &lt;- fiberpaper[, 1:4]
u &lt;- u.stenv(X, Y)
u

m &lt;- stenv(X, Y, 2, 3)
m
m$beta
</code></pre>

<hr>
<h2 id='sxenv'>Fit the scaled predictor envelope model</h2><span id='topic+sxenv'></span>

<h3>Description</h3>

<p>Fit the scaled predictor envelope model in multivariate linear regression with dimension u. The scaled predictor envelope model is a scale-invariant version of the predictor envelope model.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sxenv(X, Y, u, R, asy = TRUE, init = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sxenv_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="sxenv_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="sxenv_+3A_u">u</code></td>
<td>
<p>Dimension of the scaled envelope in the predictor space. An integer between 0 and p.</p>
</td></tr>
<tr><td><code id="sxenv_+3A_r">R</code></td>
<td>
<p>The number of replications of the scales. A vector, the sum of all elements of R must be p.</p>
</td></tr>
<tr><td><code id="sxenv_+3A_asy">asy</code></td>
<td>
<p>Flag for computing the asymptotic variance of the envelope estimator.  The default is <code>TRUE</code>. When p and r are large, computing the asymptotic variance can take much time and memory.  If only the envelope estimators are needed, the flag can be set to <code>asy = FALSE</code>.</p>
</td></tr>
<tr><td><code id="sxenv_+3A_init">init</code></td>
<td>
<p>The user-specified value of Gamma for the scaled envelope subspace in the predictor space. An p by u matrix. The default is the one generated by function sxenvMU.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits the scaled envelope model in the predictor space to the responses and predictors, </p>
<p style="text-align: center;"><code class="reqn">
 Y = \mu_{Y} + \eta'\Gamma'\Lambda^{-1} (X - \mu_{X}) + \varepsilon, \Sigma _{X} = \Lambda\Gamma\Omega\Gamma'\Lambda + \Lambda\Gamma_{0}\Omega_{0}\Gamma'_{0}\Lambda
 </code>
</p>

<p>using the maximum likelihood estimation.  When the dimension of the scaled  envelope in the predictor space is between 1 and p-1, the starting value and blockwise coordinate descent algorithm in Cook et al. (2016) is implemented.  When the dimension is p, then the scaled envelope model in the predictor space degenerates to the standard multivariate linear regression.  When the dimension is 0, it means that X and Y are uncorrelated, and the fitting is different.
</p>


<h3>Value</h3>

<p>The output is a list that contains the following components:
</p>
<table>
<tr><td><code>beta</code></td>
<td>
<p>The scaled envelope estimator of the regression coefficients.</p>
</td></tr> 
<tr><td><code>Sigma</code></td>
<td>
<p>The scaled envelope estimator of the error covariance matrix.</p>
</td></tr>
<tr><td><code>Lambda</code></td>
<td>
<p>The matrix of estimated scale.</p>
</td></tr>
<tr><td><code>Gamma</code></td>
<td>
<p>An orthonormal basis of the scaled envelope subspace.</p>
</td></tr>
<tr><td><code>Gamma0</code></td>
<td>
<p>An orthonormal basis of the complement of the scaled envelope subspace.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>The coordinates of beta with respect to Gamma.</p>
</td></tr>
<tr><td><code>Omega</code></td>
<td>
<p>The coordinates of Sigma with respect to Gamma.</p>
</td></tr>
<tr><td><code>Omega0</code></td>
<td>
<p>The coordinates of Sigma with respect to Gamma0.</p>
</td></tr>
<tr><td><code>muY</code></td>
<td>
<p>The mean of Y.</p>
</td></tr>
<tr><td><code>muX</code></td>
<td>
<p>The mean of X.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The maximized log likelihood function.</p>
</td></tr>
<tr><td><code>covMatrix</code></td>
<td>
<p>The asymptotic covariance of vec(beta). The covariance matrix returned are asymptotic.  For the actual standard errors, multiply by 1 / n.</p>
</td></tr>
<tr><td><code>asySE</code></td>
<td>
<p>The asymptotic standard error for elements in beta under the envelope model.  The standard errors returned are asymptotic, for actual standard errors, multiply by 1 / sqrt(n).</p>
</td></tr>
<tr><td><code>ratio</code></td>
<td>
<p>The asymptotic standard error ratio of the standard multivariate linear regression estimator over the envelope estimator, for each element in beta.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of observations in the data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cook, R. D., Su, Z. (2016). Scaled Predictor Envelopes and Partial Least Squares Regression. Technometrics 58, 155 - 165.
</p>
<p>Cook, R. D., Forzani, L. and Su, Z. (2016) A Note on Fast Envelope Estimation. Journal of Multivariate Analysis. 150, 42-54.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sales)
Y &lt;- sales[, 1:3]
X &lt;- sales[, 4:7]
R &lt;- rep(1, 4)

u &lt;- u.sxenv(X, Y, R)
u

m &lt;- sxenv(X, Y, 2, R)
m$beta
</code></pre>

<hr>
<h2 id='testcoef.env'>Hypothesis test of the coefficients of the response envelope model</h2><span id='topic+testcoef.env'></span>

<h3>Description</h3>

<p>This function tests the null hypothesis L * beta * R = A versus the alternative hypothesis L * beta * R ~= A, where beta is estimated under the response envelope model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testcoef.env(m, L, R, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testcoef.env_+3A_m">m</code></td>
<td>
<p>A list containing estimators and other statistics inherited from env.</p>
</td></tr>
<tr><td><code id="testcoef.env_+3A_l">L</code></td>
<td>
<p>The matrix multiplied to beta on the left.  It is a d1 by r matrix, while d1 is less than or equal to r.</p>
</td></tr>
<tr><td><code id="testcoef.env_+3A_r">R</code></td>
<td>
<p>The matrix multiplied to beta on the right.  It is a p by d2 matrix, while d2 is less than or equal to p.</p>
</td></tr>
<tr><td><code id="testcoef.env_+3A_a">A</code></td>
<td>
<p>The matrix on the right hand side of the equation.  It is a d1 by d2 matrix.</p>
</td></tr>
</table>
<p>Note that inputs <code>L</code>, <code>R</code> and <code>A</code> must be matrices, if not, use <code>as.matrix</code> to convert them.  
</p>


<h3>Details</h3>

<p>This function tests for hypothesis H0: L beta R = A, versus Ha: L beta R != A.  The beta is estimated by the envelope model.  If L = Ir, R = Ip and A = 0, then the test is equivalent to the standard F test on if beta = 0.  The test statistic used is vec(L beta R - A) hatSigma^-1 vec(L beta R - A)^T, where beta is the envelope estimator and hatSigma is the estimated asymptotic covariance of vec(L beta R - A). The reference distribution is chi-squared distribution with degrees of freedom d1 * d2. 
</p>


<h3>Value</h3>

<p>The output is a list that contains following components.
</p>
<table>
<tr><td><code>chisqStatistic</code></td>
<td>
<p>The test statistic.</p>
</td></tr> 
<tr><td><code>dof</code></td>
<td>
<p>The degrees of freedom of the reference chi-squared distribution.</p>
</td></tr> 
<tr><td><code>pValue</code></td>
<td>
<p>p-value of the test.</p>
</td></tr> 
<tr><td><code>covMatrix</code></td>
<td>
<p>The covariance matrix of vec(L beta R).</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(wheatprotein)
X &lt;- wheatprotein[, 8]
Y &lt;- wheatprotein[, 1:6]
m &lt;- env(X, Y, 1)
m

L &lt;- diag(6)
R &lt;- as.matrix(1)
A &lt;- matrix(0, 6, 1)

test.res &lt;- testcoef.env(m, L, R, A)
test.res
</code></pre>

<hr>
<h2 id='testcoef.env.apweights'>Hypothesis test of the coefficients of the response envelope model with nonconstant variance</h2><span id='topic+testcoef.env.apweights'></span>

<h3>Description</h3>

<p>This function tests the null hypothesis L * beta * R = A versus the alternative hypothesis L * beta * R ~= A, where beta is estimated under the response envelope model with nonconstant error variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testcoef.env.apweights(m, L, R, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testcoef.env.apweights_+3A_m">m</code></td>
<td>
<p>A list containing estimators and other statistics inherited from env.apweights.</p>
</td></tr>
<tr><td><code id="testcoef.env.apweights_+3A_l">L</code></td>
<td>
<p>The matrix multiplied to beta on the left.  It is a d1 by r matrix, while d1 is less than or equal to r.</p>
</td></tr>
<tr><td><code id="testcoef.env.apweights_+3A_r">R</code></td>
<td>
<p>The matrix multiplied to beta on the right.  It is a p by d2 matrix, while d2 is less than or equal to p.</p>
</td></tr>
<tr><td><code id="testcoef.env.apweights_+3A_a">A</code></td>
<td>
<p>The matrix on the right hand side of the equation.  It is a d1 by d2 matrix.</p>
</td></tr>
</table>
<p>Note that inputs <code>L</code>, <code>R</code> and <code>A</code> must be matrices, if not, use <code>as.matrix</code> to convert them.  
</p>


<h3>Details</h3>

<p>This function tests for hypothesis H0: L beta R = A, versus Ha: L beta R != A.  The beta is estimated by the envelope model with nonconstant errors.  If L = Ir, R = Ip and A = 0, then the test is equivalent to the standard F test on if beta = 0.  The test statistic used is vec(L beta R - A) hatSigma^-1 vec(L beta R - A)^T, where beta is the envelope estimator and hatSigma is the estimated asymptotic covariance of vec(L beta R - A). The reference distribution is chi-squared distribution with degrees of freedom d1 * d2. 
</p>


<h3>Value</h3>

<p>The output is a list that contains following components.
</p>
<table>
<tr><td><code>chisqStatistic</code></td>
<td>
<p>The test statistic.</p>
</td></tr> 
<tr><td><code>dof</code></td>
<td>
<p>The degrees of freedom of the reference chi-squared distribution.</p>
</td></tr> 
<tr><td><code>pValue</code></td>
<td>
<p>p-value of the test.</p>
</td></tr> 
<tr><td><code>covMatrix</code></td>
<td>
<p>The covariance matrix of vec(L beta R).</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(concrete)
X &lt;- concrete[, 1:7]
Y &lt;- concrete[, 8:10]
m &lt;- env.apweights(X, Y, 2)
m

L &lt;- diag(3)
R &lt;- matrix(1, 7, 1)
A &lt;- matrix(0, 3, 1)

test.res &lt;- testcoef.env.apweights(m, L, R, A)
test.res
</code></pre>

<hr>
<h2 id='testcoef.env.tcond'>Hypothesis test of the coefficients of the response envelope model with t-distributed errors</h2><span id='topic+testcoef.env.tcond'></span>

<h3>Description</h3>

<p>This function tests the null hypothesis L * beta * R = A versus the alternative hypothesis L * beta * R ~= A, where beta is estimated under the response envelope model with t-distributed errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testcoef.env.tcond(m, L, R, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testcoef.env.tcond_+3A_m">m</code></td>
<td>
<p>A list containing estimators and other statistics inherited from env.tcond.</p>
</td></tr>
<tr><td><code id="testcoef.env.tcond_+3A_l">L</code></td>
<td>
<p>The matrix multiplied to beta on the left.  It is a d1 by r matrix, while d1 is less than or equal to r.</p>
</td></tr>
<tr><td><code id="testcoef.env.tcond_+3A_r">R</code></td>
<td>
<p>The matrix multiplied to beta on the right.  It is a p by d2 matrix, while d2 is less than or equal to p.</p>
</td></tr>
<tr><td><code id="testcoef.env.tcond_+3A_a">A</code></td>
<td>
<p>The matrix on the right hand side of the equation.  It is a d1 by d2 matrix.</p>
</td></tr>
</table>
<p>Note that inputs <code>L</code>, <code>R</code> and <code>A</code> must be matrices, if not, use <code>as.matrix</code> to convert them.  
</p>


<h3>Details</h3>

<p>This function tests for hypothesis H0: L beta R = A, versus Ha: L beta R != A.  The beta is estimated by the envelope model with t-distributed errors.  If L = Ir, R = Ip and A = 0, then the test is equivalent to the standard F test on if beta = 0.  The test statistic used is vec(L beta R - A) hatSigma^-1 vec(L beta R - A)^T, where beta is the envelope estimator and hatSigma is the estimated asymptotic covariance of vec(L beta R - A). The reference distribution is chi-squared distribution with degrees of freedom d1 * d2. 
</p>


<h3>Value</h3>

<p>The output is a list that contains following components.
</p>
<table>
<tr><td><code>chisqStatistic</code></td>
<td>
<p>The test statistic.</p>
</td></tr> 
<tr><td><code>dof</code></td>
<td>
<p>The degrees of freedom of the reference chi-squared distribution.</p>
</td></tr> 
<tr><td><code>pValue</code></td>
<td>
<p>p-value of the test.</p>
</td></tr> 
<tr><td><code>covMatrix</code></td>
<td>
<p>The covariance matrix of vec(L beta R).</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(concrete)
X &lt;- concrete[1:78, 1:7]  # The first 78 observations are training data
Y &lt;- concrete[1:78, 8:10]
m &lt;- env.tcond(X, Y, 2, 6)
m

L &lt;- diag(3)
R &lt;- matrix(1, 7, 1)
A &lt;- matrix(0, 3, 1)

test.res &lt;- testcoef.env.tcond(m, L, R, A)
test.res
</code></pre>

<hr>
<h2 id='testcoef.genv'>Hypothesis test of the coefficients of the groupwise envelope model</h2><span id='topic+testcoef.genv'></span>

<h3>Description</h3>

<p>This function tests the null hypothesis L * beta * R = A versus the alternative hypothesis L * beta * R ~= A, where beta is estimated under the groupwise envelope model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testcoef.genv(m, L, R, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testcoef.genv_+3A_m">m</code></td>
<td>
<p>A list containing estimators and other statistics inherited from genv.</p>
</td></tr>
<tr><td><code id="testcoef.genv_+3A_l">L</code></td>
<td>
<p>The matrix multiplied to beta on the left.  It is a d1 by r matrix, while d1 is less than or equal to r.</p>
</td></tr>
<tr><td><code id="testcoef.genv_+3A_r">R</code></td>
<td>
<p>The matrix multiplied to beta on the right.  It is a p by d2 matrix, while d2 is less than or equal to p.</p>
</td></tr>
<tr><td><code id="testcoef.genv_+3A_a">A</code></td>
<td>
<p>The matrix on the right hand side of the equation.  It is a d1 by d2 matrix.</p>
</td></tr>
</table>
<p>Note that inputs <code>L</code>, <code>R</code> and <code>A</code> must be matrices, if not, use <code>as.matrix</code> to convert them.  
</p>


<h3>Details</h3>

<p>This function tests for hypothesis H0: L beta[[i]] R = A, versus Ha: L beta[[i]] R != A.  The beta is estimated by the groupwise envelope model.  If L = Ir, R = Ip and A = 0, then the test is equivalent to the standard F test on if beta[[i]] = 0.  The test statistic used is vec(L beta R - A) hatSigma^-1 vec(L beta R - A)^T, where beta is the envelope estimator and hatSigma is the estimated asymptotic covariance of vec(L beta R - A). The reference distribution is chi-squared distribution with degrees of freedom d1 * d2. 
</p>


<h3>Value</h3>

<p>The output is a list that contains following components.
</p>
<table>
<tr><td><code>chisqStatistic</code></td>
<td>
<p>The test statistic.</p>
</td></tr> 
<tr><td><code>dof</code></td>
<td>
<p>The degrees of freedom of the reference chi-squared distribution.</p>
</td></tr> 
<tr><td><code>pValue</code></td>
<td>
<p>p-value of the test.</p>
</td></tr> 
<tr><td><code>covMatrix</code></td>
<td>
<p>The covariance matrix of vec(L beta R).</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(fiberpaper)
X &lt;- fiberpaper[ , c(5, 7)]
Y &lt;- fiberpaper[ , 1:3]
Z &lt;- as.numeric(fiberpaper[ , 6] &gt; mean(fiberpaper[ , 6]))
u &lt;- u.genv(X, Y, Z)
u

m &lt;- genv(X, Y, Z, 2)
m

L &lt;- diag(3)
R &lt;- diag(2)
A &lt;- matrix(0, 3, 2)

test.res &lt;- testcoef.genv(m, L, R, A)
test.res
</code></pre>

<hr>
<h2 id='testcoef.henv'>Hypothesis test of the coefficients of the heteroscedastic envelope model</h2><span id='topic+testcoef.henv'></span>

<h3>Description</h3>

<p>This function tests the null hypothesis L * beta * R = A versus the alternative hypothesis L * beta * R ~= A, where beta is estimated under the heteroscedastic envelope model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testcoef.henv(m, L, R, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testcoef.henv_+3A_m">m</code></td>
<td>
<p>A list containing estimators and other statistics inherited from genv.</p>
</td></tr>
<tr><td><code id="testcoef.henv_+3A_l">L</code></td>
<td>
<p>The matrix multiplied to beta on the left.  It is a d1 by r matrix, while d1 is less than or equal to r.</p>
</td></tr>
<tr><td><code id="testcoef.henv_+3A_r">R</code></td>
<td>
<p>The matrix multiplied to beta on the right.  It is a p by d2 matrix, while d2 is less than or equal to p.</p>
</td></tr>
<tr><td><code id="testcoef.henv_+3A_a">A</code></td>
<td>
<p>The matrix on the right hand side of the equation.  It is a d1 by d2 matrix.</p>
</td></tr>
</table>
<p>Note that inputs <code>L</code>, <code>R</code> and <code>A</code> must be matrices, if not, use <code>as.matrix</code> to convert them.  
</p>


<h3>Details</h3>

<p>This function tests for hypothesis H0: L beta R = A, versus Ha: L beta R != A.  The beta is estimated by the heteroscedastic envelope model.  If L = Ir, R = Ip and A = 0, then the test is equivalent to the standard F test on if beta = 0.  The test statistic used is vec(L beta R - A) hatSigma^-1 vec(L beta R - A)^T, where beta is the envelope estimator and hatSigma is the estimated asymptotic covariance of vec(L beta R - A). The reference distribution is chi-squared distribution with degrees of freedom d1 * d2. 
</p>


<h3>Value</h3>

<p>The output is a list that contains following components.
</p>
<table>
<tr><td><code>chisqStatistic</code></td>
<td>
<p>The test statistic.</p>
</td></tr> 
<tr><td><code>dof</code></td>
<td>
<p>The degrees of freedom of the reference chi-squared distribution.</p>
</td></tr> 
<tr><td><code>pValue</code></td>
<td>
<p>p-value of the test.</p>
</td></tr> 
<tr><td><code>covMatrix</code></td>
<td>
<p>The covariance matrix of vec(L beta R).</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(waterstrider)
X &lt;- waterstrider[ , 1]
Y &lt;- waterstrider[ , 2:5]

## Not run: m &lt;- henv(X, Y, 2)
## Not run: m

L &lt;- diag(4)
R &lt;- matrix(c(1, -1, 0), 3, 1)
A &lt;- matrix(0, 4, 1)

## Not run: test.res &lt;- testcoef.henv(m, L, R, A)
## Not run: test.res
</code></pre>

<hr>
<h2 id='testcoef.logit.env'>Hypothesis test of the coefficients of the envelope model</h2><span id='topic+testcoef.logit.env'></span>

<h3>Description</h3>

<p>This function tests the null hypothesis L * beta = A versus the alternative hypothesis L * beta ~= A, where beta is estimated under the envelope model in logistic regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testcoef.logit.env(m, L, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testcoef.logit.env_+3A_m">m</code></td>
<td>
<p>A list containing estimators and other statistics inherited from logit.env.</p>
</td></tr>
<tr><td><code id="testcoef.logit.env_+3A_l">L</code></td>
<td>
<p>The matrix multiplied to beta on the left.  It is a d1 by p matrix, while d1 is less than or equal to p.</p>
</td></tr>
<tr><td><code id="testcoef.logit.env_+3A_a">A</code></td>
<td>
<p>The matrix on the right hand side of the equation.  It is a d1 by 1 matrix.</p>
</td></tr>
</table>
<p>Note that inputs <code>L</code> and <code>A</code> must be matrices, if not, use <code>as.matrix</code> to convert them.  
</p>


<h3>Details</h3>

<p>This function tests for hypothesis H0: L beta = A, versus Ha: L beta != A.  The beta is estimated by the envelope model in predictor space.  If L = Ip and A = 0, then the test is equivalent to the standard F test on if beta = 0.  The test statistic used is vec(L beta - A) hatSigma^-1 vec(L beta - A)^T, where beta is the envelope estimator and hatSigma is the estimated asymptotic covariance of vec(L beta - A). The reference distribution is chi-squared distribution with degrees of freedom d1. 
</p>


<h3>Value</h3>

<p>The output is a list that contains following components.
</p>
<table>
<tr><td><code>chisqStatistic</code></td>
<td>
<p>The test statistic.</p>
</td></tr> 
<tr><td><code>dof</code></td>
<td>
<p>The degrees of freedom of the reference chi-squared distribution.</p>
</td></tr> 
<tr><td><code>pValue</code></td>
<td>
<p>p-value of the test.</p>
</td></tr> 
<tr><td><code>covMatrix</code></td>
<td>
<p>The covariance matrix of vec(L beta).</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(horseshoecrab)
X1 &lt;- as.numeric(horseshoecrab[ , 1] == 2)
X2 &lt;- as.numeric(horseshoecrab[ , 1] == 3)
X3 &lt;- as.numeric(horseshoecrab[ , 1] == 4)
X4 &lt;- as.numeric(horseshoecrab[ , 2] == 2)
X5 &lt;- as.numeric(horseshoecrab[ , 2] == 3)
X6 &lt;- horseshoecrab[ , 3]
X7 &lt;- horseshoecrab[ , 5]
X &lt;- cbind(X1, X2, X3, X4, X5, X6, X7)
Y &lt;- as.numeric(ifelse(horseshoecrab[ , 4] &gt; 0, 1, 0))

m &lt;- logit.env(X, Y, 1)

L &lt;- diag(7)
A &lt;- matrix(0, 7, 1)

test.res &lt;- testcoef.logit.env(m, L, A)
test.res
</code></pre>

<hr>
<h2 id='testcoef.penv'>Hypothesis test of the coefficients of the partial envelope model</h2><span id='topic+testcoef.penv'></span>

<h3>Description</h3>

<p>This function tests the null hypothesis L * beta1 * R = A versus the alternative hypothesis L * beta1 * R ~= A, where beta is estimated under the partial envelope model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testcoef.penv(m, L, R, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testcoef.penv_+3A_m">m</code></td>
<td>
<p>A list containing estimators and other statistics inherited from penv.</p>
</td></tr>
<tr><td><code id="testcoef.penv_+3A_l">L</code></td>
<td>
<p>The matrix multiplied to beta on the left.  It is a d1 by r matrix, while d1 is less than or equal to r.</p>
</td></tr>
<tr><td><code id="testcoef.penv_+3A_r">R</code></td>
<td>
<p>The matrix multiplied to beta on the right.  It is a p1 by d2 matrix, while d2 is less than or equal to p1.</p>
</td></tr>
<tr><td><code id="testcoef.penv_+3A_a">A</code></td>
<td>
<p>The matrix on the right hand side of the equation.  It is a d1 by d2 matrix.</p>
</td></tr>
</table>
<p>Note that inputs <code>L</code>, <code>R</code> and <code>A</code> must be matrices, if not, use <code>as.matrix</code> to convert them.  
</p>


<h3>Details</h3>

<p>This function tests for hypothesis H0: L beta1 R = A, versus Ha: L beta1 R != A.  The beta is estimated by the partial envelope model.  If L = Ir, R = Ip1 and A = 0, then the test is equivalent to the standard F test on if beta1 = 0.  The test statistics used is vec(L beta1 R - A) hatSigma^-1 vec(L beta1 R - A)^T, where beta is the envelope estimator and hatSigma is the estimated asymptotic covariance of vec(L beta1 R - A). The reference distribution is chi-squared distribution with degrees of freedom d1 * d2. 
</p>


<h3>Value</h3>

<p>The output is a list that contains following components.
</p>
<table>
<tr><td><code>chisqStatistic</code></td>
<td>
<p>The test statistic.</p>
</td></tr> 
<tr><td><code>dof</code></td>
<td>
<p>The degrees of freedom of the reference chi-squared distribution.</p>
</td></tr> 
<tr><td><code>pValue</code></td>
<td>
<p>p-value of the test.</p>
</td></tr> 
<tr><td><code>covMatrix</code></td>
<td>
<p>The covariance matrix of vec(L beta1 R).</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(fiberpaper)
X1 &lt;- fiberpaper[, 7]
X2 &lt;- fiberpaper[, 5:6]
Y &lt;- fiberpaper[, 1:4]
m &lt;- penv(X1, X2, Y, 1)
m

L &lt;- diag(4)
R &lt;- as.matrix(1)
A &lt;- matrix(0, 4, 1)

test.res &lt;- testcoef.penv(m, L, R, A)
test.res
</code></pre>

<hr>
<h2 id='testcoef.pois.env'>Hypothesis test of the coefficients of the envelope model</h2><span id='topic+testcoef.pois.env'></span>

<h3>Description</h3>

<p>This function tests the null hypothesis L * beta = A versus the alternative hypothesis L * beta ~= A, where beta is estimated under the envelope model in poisson regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testcoef.pois.env(m, L, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testcoef.pois.env_+3A_m">m</code></td>
<td>
<p>A list containing estimators and other statistics inherited from pois.env.</p>
</td></tr>
<tr><td><code id="testcoef.pois.env_+3A_l">L</code></td>
<td>
<p>The matrix multiplied to beta on the left.  It is a d1 by p matrix, while d1 is less than or equal to p.</p>
</td></tr>
<tr><td><code id="testcoef.pois.env_+3A_a">A</code></td>
<td>
<p>The matrix on the right hand side of the equation.  It is a d1 by 1 matrix.</p>
</td></tr>
</table>
<p>Note that inputs <code>L</code> and <code>A</code> must be matrices, if not, use <code>as.matrix</code> to convert them.   
</p>


<h3>Details</h3>

<p>This function tests for hypothesis H0: L beta = A, versus Ha: L beta != A.  The beta is estimated by the envelope model in predictor space.  If L = Ip and A = 0, then the test is equivalent to the standard F test on if beta = 0.  The test statistic used is vec(L beta - A) hatSigma^-1 vec(L beta - A)^T, where beta is the envelope estimator and hatSigma is the estimated asymptotic covariance of vec(L beta - A). The reference distribution is chi-squared distribution with degrees of freedom d1. 
</p>


<h3>Value</h3>

<p>The output is a list that contains following components.
</p>
<table>
<tr><td><code>chisqStatistic</code></td>
<td>
<p>The test statistic.</p>
</td></tr> 
<tr><td><code>dof</code></td>
<td>
<p>The degrees of freedom of the reference chi-squared distribution.</p>
</td></tr> 
<tr><td><code>pValue</code></td>
<td>
<p>p-value of the test.</p>
</td></tr> 
<tr><td><code>covMatrix</code></td>
<td>
<p>The covariance matrix of vec(L beta).</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(horseshoecrab)
X1 &lt;- as.numeric(horseshoecrab[ , 1] == 2)
X2 &lt;- as.numeric(horseshoecrab[ , 1] == 3)
X3 &lt;- as.numeric(horseshoecrab[ , 1] == 4)
X4 &lt;- as.numeric(horseshoecrab[ , 2] == 2)
X5 &lt;- as.numeric(horseshoecrab[ , 2] == 3)
X6 &lt;- horseshoecrab[ , 3]
X7 &lt;- horseshoecrab[ , 5]
X &lt;- cbind(X1, X2, X3, X4, X5, X6, X7)
Y &lt;- horseshoecrab[ , 4]

m &lt;- pois.env(X, Y, 1)

L &lt;- diag(7)
A &lt;- matrix(0, 7, 1)

test.res &lt;- testcoef.pois.env(m, L, A)
test.res
</code></pre>

<hr>
<h2 id='testcoef.rrenv'>Hypothesis test of the coefficients of the reduced rank envelope model</h2><span id='topic+testcoef.rrenv'></span>

<h3>Description</h3>

<p>This function tests the null hypothesis L * beta * R = A versus the alternative hypothesis L * beta * R ~= A, where beta is estimated under the reduced rank envelope model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testcoef.rrenv(m, L, R, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testcoef.rrenv_+3A_m">m</code></td>
<td>
<p>A list containing estimators and other statistics inherited from rrenv.</p>
</td></tr>
<tr><td><code id="testcoef.rrenv_+3A_l">L</code></td>
<td>
<p>The matrix multiplied to beta on the left.  It is a d1 by r matrix, while d1 is less than or equal to r.</p>
</td></tr>
<tr><td><code id="testcoef.rrenv_+3A_r">R</code></td>
<td>
<p>The matrix multiplied to beta on the right.  It is a p by d2 matrix, while d2 is less than or equal to p.</p>
</td></tr>
<tr><td><code id="testcoef.rrenv_+3A_a">A</code></td>
<td>
<p>The matrix on the right hand side of the equation.  It is a d1 by d2 matrix.</p>
</td></tr>
</table>
<p>Note that inputs <code>L</code>, <code>R</code> and <code>A</code> must be matrices, if not, use <code>as.matrix</code> to convert them.  
</p>


<h3>Details</h3>

<p>This function tests for hypothesis H0: L beta R = A, versus Ha: L beta R != A.  The beta is estimated by the reduced rank envelope model.  If L = Ir, R = Ip and A = 0, then the test is equivalent to the standard F test on if beta = 0.  The test statistic used is vec(L beta R - A) hatSigma^-1 vec(L beta R - A)^T, where beta is the envelope estimator and hatSigma is the estimated asymptotic covariance of vec(L beta R - A). The reference distribution is chi-squared distribution with degrees of freedom d1 * d2. 
</p>


<h3>Value</h3>

<p>The output is a list that contains following components.
</p>
<table>
<tr><td><code>chisqStatistic</code></td>
<td>
<p>The test statistic.</p>
</td></tr> 
<tr><td><code>dof</code></td>
<td>
<p>The degrees of freedom of the reference chi-squared distribution.</p>
</td></tr> 
<tr><td><code>pValue</code></td>
<td>
<p>p-value of the test.</p>
</td></tr> 
<tr><td><code>covMatrix</code></td>
<td>
<p>The covariance matrix of vec(L beta R).</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(vehicles)
X &lt;- vehicles[, 1:11]  
Y &lt;- vehicles[, 12:15]
X &lt;- scale(X)
Y &lt;- scale(Y)  # The scales of Y are vastly different, so scaling is reasonable here
m &lt;- rrenv(X, Y, 4, 2)
m

L &lt;- diag(4)
R &lt;- matrix(1, 11, 1)
A &lt;- matrix(0, 4, 1)

test.res &lt;- testcoef.rrenv(m, L, R, A)
test.res
</code></pre>

<hr>
<h2 id='testcoef.rrenv.apweights'>Hypothesis test of the coefficients of the reduced rank envelope model with nonconstant error variance</h2><span id='topic+testcoef.rrenv.apweights'></span>

<h3>Description</h3>

<p>This function tests the null hypothesis L * beta * R = A versus the alternative hypothesis L * beta * R ~= A, where beta is estimated under the reduced rank envelope model with nonconstant error variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testcoef.rrenv.apweights(m, L, R, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testcoef.rrenv.apweights_+3A_m">m</code></td>
<td>
<p>A list containing estimators and other statistics inherited from rrenv.apweights.</p>
</td></tr>
<tr><td><code id="testcoef.rrenv.apweights_+3A_l">L</code></td>
<td>
<p>The matrix multiplied to beta on the left.  It is a d1 by r matrix, while d1 is less than or equal to r.</p>
</td></tr>
<tr><td><code id="testcoef.rrenv.apweights_+3A_r">R</code></td>
<td>
<p>The matrix multiplied to beta on the right.  It is a p by d2 matrix, while d2 is less than or equal to p.</p>
</td></tr>
<tr><td><code id="testcoef.rrenv.apweights_+3A_a">A</code></td>
<td>
<p>The matrix on the right hand side of the equation.  It is a d1 by d2 matrix.</p>
</td></tr>
</table>
<p>Note that inputs <code>L</code>, <code>R</code> and <code>A</code> must be matrices, if not, use <code>as.matrix</code> to convert them.  
</p>


<h3>Details</h3>

<p>This function tests for hypothesis H0: L beta R = A, versus Ha: L beta R != A.  The beta is estimated by the reduced rank envelope model that accommodates nonconstant error variance.  If L = Ir, R = Ip and A = 0, then the test is equivalent to the standard F test on if beta = 0.  The test statistic used is vec(L beta R - A) hatSigma^-1 vec(L beta R - A)^T, where beta is the envelope estimator and hatSigma is the estimated asymptotic covariance of vec(L beta R - A). The reference distribution is chi-squared distribution with degrees of freedom d1 * d2. 
</p>


<h3>Value</h3>

<p>The output is a list that contains following components.
</p>
<table>
<tr><td><code>chisqStatistic</code></td>
<td>
<p>The test statistic.</p>
</td></tr> 
<tr><td><code>dof</code></td>
<td>
<p>The degrees of freedom of the reference chi-squared distribution.</p>
</td></tr> 
<tr><td><code>pValue</code></td>
<td>
<p>p-value of the test.</p>
</td></tr> 
<tr><td><code>covMatrix</code></td>
<td>
<p>The covariance matrix of vec(L beta R).</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(vehicles)
X &lt;- vehicles[, 1:11]  
Y &lt;- vehicles[, 12:15]
X &lt;- scale(X)
Y &lt;- scale(Y)  # The scales of Y are vastly different, so scaling is reasonable here
## Not run: m &lt;- rrenv.apweights(X, Y, 3, 2)
## Not run: m

L &lt;- diag(4)
R &lt;- matrix(1, 11, 1)
A &lt;- matrix(0, 4, 1)

## Not run: test.res &lt;- testcoef.rrenv.apweights(m, L, R, A)
## Not run: test.res
</code></pre>

<hr>
<h2 id='testcoef.senv'>Hypothesis test of the coefficients of the scaled response envelope model</h2><span id='topic+testcoef.senv'></span>

<h3>Description</h3>

<p>This function tests the null hypothesis L * beta * R = A versus the alternative hypothesis L * beta * R ~= A, where beta is estimated under the scaled response envelope model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testcoef.senv(m, L, R, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testcoef.senv_+3A_m">m</code></td>
<td>
<p>A list containing estimators and other statistics inherited from scale.env.</p>
</td></tr>
<tr><td><code id="testcoef.senv_+3A_l">L</code></td>
<td>
<p>The matrix multiplied to beta on the left.  It is a d1 by r matrix, while d1 is less than or equal to r.</p>
</td></tr>
<tr><td><code id="testcoef.senv_+3A_r">R</code></td>
<td>
<p>The matrix multiplied to beta on the right.  It is a p by d2 matrix, while d2 is less than or equal to p.</p>
</td></tr>
<tr><td><code id="testcoef.senv_+3A_a">A</code></td>
<td>
<p>The matrix on the right hand side of the equation.  It is a d1 by d2 matrix.</p>
</td></tr>
</table>
<p>Note that inputs <code>L</code>, <code>R</code> and <code>A</code> must be matrices, if not, use <code>as.matrix</code> to convert them.  
</p>


<h3>Details</h3>

<p>This function tests for hypothesis H0: L beta R = A, versus Ha: L beta R != A.  The beta is estimated by the scaled envelope model.  If L = Ir, R = Ip and A = 0, then the test is equivalent to the standard F test on if beta = 0.  The test statistic used is vec(L beta R - A) hatSigma^-1 vec(L beta R - A)^T, where beta is the envelope estimator and hatSigma is the estimated asymptotic covariance of vec(L beta R - A). The reference distribution is chi-squared distribution with degrees of freedom d1 * d2. 
</p>


<h3>Value</h3>

<p>The output is a list that contains following components.
</p>
<table>
<tr><td><code>chisqStatistic</code></td>
<td>
<p>The test statistic.</p>
</td></tr> 
<tr><td><code>dof</code></td>
<td>
<p>The degrees of freedom of the reference chi-squared distribution.</p>
</td></tr> 
<tr><td><code>pValue</code></td>
<td>
<p>p-value of the test.</p>
</td></tr> 
<tr><td><code>covMatrix</code></td>
<td>
<p>The covariance matrix of vec(L beta R).</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(sales)
X &lt;- sales[, 1:3]
Y &lt;- sales[, 4:7]

m &lt;- senv(X, Y, 2)

L &lt;- diag(4)
R &lt;- as.matrix(c(1, 0, 0))
A &lt;- matrix(0, 4, 1)

test.res &lt;- testcoef.senv(m, L, R, A)
test.res
</code></pre>

<hr>
<h2 id='testcoef.stenv'>Hypothesis test of the coefficients of the simultaneous envelope model</h2><span id='topic+testcoef.stenv'></span>

<h3>Description</h3>

<p>This function tests the null hypothesis L * beta * R = A versus the alternative hypothesis L * beta * R ~= A, where beta is estimated under the simultaneous envelope model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testcoef.stenv(m, L, R, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testcoef.stenv_+3A_m">m</code></td>
<td>
<p>A list containing estimators and other statistics inherited from stenv.</p>
</td></tr>
<tr><td><code id="testcoef.stenv_+3A_l">L</code></td>
<td>
<p>The matrix multiplied to beta on the left.  It is a d1 by p matrix, while d1 is less than or equal to p.</p>
</td></tr>
<tr><td><code id="testcoef.stenv_+3A_r">R</code></td>
<td>
<p>The matrix multiplied to beta on the right.  It is an r by d2 matrix, while d2 is less than or equal to r.</p>
</td></tr>
<tr><td><code id="testcoef.stenv_+3A_a">A</code></td>
<td>
<p>The matrix on the right hand side of the equation.  It is a d1 by d2 matrix.</p>
</td></tr>
</table>
<p>Note that inputs <code>L</code>, <code>R</code> and <code>A</code> must be matrices, if not, use <code>as.matrix</code> to convert them.  
</p>


<h3>Details</h3>

<p>This function tests for hypothesis H0: L beta R = A, versus Ha: L beta R != A.  The beta is estimated by the simultaneous envelope model.  If L = Ip, R = Ir and A = 0, then the test is equivalent to the standard F test on if beta = 0.  The test statistic used is vec(L beta R - A) hatSigma^-1 vec(L beta R - A)^T, where beta is the envelope estimator and hatSigma is the estimated asymptotic covariance of vec(L beta R - A). The reference distribution is chi-squared distribution with degrees of freedom d1 * d2. 
</p>


<h3>Value</h3>

<p>The output is a list that contains following components.
</p>
<table>
<tr><td><code>chisqStatistic</code></td>
<td>
<p>The test statistic.</p>
</td></tr> 
<tr><td><code>dof</code></td>
<td>
<p>The degrees of freedom of the reference chi-squared distribution.</p>
</td></tr> 
<tr><td><code>pValue</code></td>
<td>
<p>p-value of the test.</p>
</td></tr> 
<tr><td><code>covMatrix</code></td>
<td>
<p>The covariance matrix of vec(L beta R).</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(fiberpaper)
X &lt;- fiberpaper[ , 5:7]
Y &lt;- fiberpaper[ , 1:4]
m &lt;- stenv(X, Y, 2, 3)

L &lt;- diag(3)
R &lt;- as.matrix(c(1, 0, 0, 0), nrow = 4)
A &lt;- matrix(0, 3, 1)

test.res &lt;- testcoef.stenv(m, L, R, A)
test.res
</code></pre>

<hr>
<h2 id='testcoef.sxenv'>Hypothesis test of the coefficients of the scaled predictor envelope model</h2><span id='topic+testcoef.sxenv'></span>

<h3>Description</h3>

<p>This function tests the null hypothesis L * beta * R = A versus the alternative hypothesis L * beta * R ~= A, where beta is estimated under the scaled predictor envelope model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testcoef.sxenv(m, L, R, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testcoef.sxenv_+3A_m">m</code></td>
<td>
<p>A list containing estimators and other statistics inherited from scale.xenv.</p>
</td></tr>
<tr><td><code id="testcoef.sxenv_+3A_l">L</code></td>
<td>
<p>The matrix multiplied to beta on the left.  It is a d1 by p matrix, while d1 is less than or equal to p.</p>
</td></tr>
<tr><td><code id="testcoef.sxenv_+3A_r">R</code></td>
<td>
<p>The matrix multiplied to beta on the right.  It is an r by d2 matrix, while d2 is less than or equal to r.</p>
</td></tr>
<tr><td><code id="testcoef.sxenv_+3A_a">A</code></td>
<td>
<p>The matrix on the right hand side of the equation.  It is a d1 by d2 matrix.</p>
</td></tr>
</table>
<p>Note that inputs <code>L</code>, <code>R</code> and <code>A</code> must be matrices, if not, use <code>as.matrix</code> to convert them.  
</p>


<h3>Details</h3>

<p>This function tests for hypothesis H0: L beta R = A, versus Ha: L beta R != A.  The beta is estimated by the scaled envelope model in the predictor space.  If L = Ip, R = Ir and A = 0, then the test is equivalent to the standard F test on if beta = 0.  The test statistic used is vec(L beta R - A) hatSigma^-1 vec(L beta R - A)^T, where beta is the envelope estimator and hatSigma is the estimated asymptotic covariance of vec(L beta R - A). The reference distribution is chi-squared distribution with degrees of freedom d1 * d2. 
</p>


<h3>Value</h3>

<p>The output is a list that contains following components.
</p>
<table>
<tr><td><code>chisqStatistic</code></td>
<td>
<p>The test statistic.</p>
</td></tr> 
<tr><td><code>dof</code></td>
<td>
<p>The degrees of freedom of the reference chi-squared distribution.</p>
</td></tr> 
<tr><td><code>pValue</code></td>
<td>
<p>p-value of the test.</p>
</td></tr> 
<tr><td><code>covMatrix</code></td>
<td>
<p>The covariance matrix of vec(L beta R).</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(sales)
Y &lt;- sales[, 1:3]
X &lt;- sales[, 4:7]
R &lt;- rep(1, 4)

u &lt;- u.sxenv(X, Y, R)
u

m &lt;- sxenv(X, Y, 2, R)

L &lt;- diag(4)
R &lt;- as.matrix(c(1, 0, 0))
A &lt;- matrix(0, 4, 1)

test.res &lt;- testcoef.sxenv(m, L, R, A)
test.res
</code></pre>

<hr>
<h2 id='testcoef.xenv'>Hypothesis test of the coefficients of the predictor envelope model</h2><span id='topic+testcoef.xenv'></span>

<h3>Description</h3>

<p>This function tests the null hypothesis L * beta * R = A versus the alternative hypothesis L * beta * R ~= A, where beta is estimated under the predictor envelope model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testcoef.xenv(m, L, R, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testcoef.xenv_+3A_m">m</code></td>
<td>
<p>A list containing estimators and other statistics inherited from xenv.</p>
</td></tr>
<tr><td><code id="testcoef.xenv_+3A_l">L</code></td>
<td>
<p>The matrix multiplied to beta on the left.  It is a d1 by p matrix, while d1 is less than or equal to p.</p>
</td></tr>
<tr><td><code id="testcoef.xenv_+3A_r">R</code></td>
<td>
<p>The matrix multiplied to beta on the right.  It is an r by d2 matrix, while d2 is less than or equal to r.</p>
</td></tr>
<tr><td><code id="testcoef.xenv_+3A_a">A</code></td>
<td>
<p>The matrix on the right hand side of the equation.  It is a d1 by d2 matrix.</p>
</td></tr>
</table>
<p>Note that inputs <code>L</code>, <code>R</code> and <code>A</code> must be matrices, if not, use <code>as.matrix</code> to convert them.  
</p>


<h3>Details</h3>

<p>This function tests for hypothesis H0: L beta R = A, versus Ha: L beta R != A.  The beta is estimated by the envelope model in predictor space.  If L = Ip, R = Ir and A = 0, then the test is equivalent to the standard F test on if beta = 0.  The test statistic used is vec(L beta R - A) hatSigma^-1 vec(L beta R - A)^T, where beta is the envelope estimator and hatSigma is the estimated asymptotic covariance of vec(L beta R - A). The reference distribution is chi-squared distribution with degrees of freedom d1 * d2. 
</p>


<h3>Value</h3>

<p>The output is a list that contains following components.
</p>
<table>
<tr><td><code>chisqStatistic</code></td>
<td>
<p>The test statistic.</p>
</td></tr> 
<tr><td><code>dof</code></td>
<td>
<p>The degrees of freedom of the reference chi-squared distribution.</p>
</td></tr> 
<tr><td><code>pValue</code></td>
<td>
<p>p-value of the test.</p>
</td></tr> 
<tr><td><code>covMatrix</code></td>
<td>
<p>The covariance matrix of vec(L beta R).</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(wheatprotein)
X &lt;- wheatprotein[, 1:6]
Y &lt;- wheatprotein[, 7]
m &lt;- xenv(X, Y, 2)
m

L &lt;- diag(6)
R &lt;- as.matrix(1)
A &lt;- matrix(0, 6, 1)

test.res &lt;- testcoef.xenv(m, L, R, A)
test.res
</code></pre>

<hr>
<h2 id='u.env'>Select the dimension of env</h2><span id='topic+u.env'></span>

<h3>Description</h3>

<p>This function outputs dimensions selected by Akaike information criterion (AIC), Bayesian information criterion (BIC) and likelihood ratio testing with specified significance level for the response envelope model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>u.env(X, Y, alpha = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="u.env_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="u.env_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="u.env_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for testing.  The default is 0.01.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>u.aic</code></td>
<td>
<p>Dimension of the envelope subspace selected by AIC.</p>
</td></tr>
<tr><td><code>u.bic</code></td>
<td>
<p>Dimension of the envelope subspace selected by BIC.</p>
</td></tr>
<tr><td><code>u.lrt</code></td>
<td>
<p>Dimension of the envelope subspace selected by the likelihood ratio testing procedure.</p>
</td></tr>
<tr><td><code>loglik.seq</code></td>
<td>
<p>Log likelihood for dimension from 0 to r.</p>
</td></tr>
<tr><td><code>aic.seq</code></td>
<td>
<p>AIC value for dimension from 0 to r.</p>
</td></tr>
<tr><td><code>bic.seq</code></td>
<td>
<p>BIC value for dimension from 0 to r.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(wheatprotein)
X &lt;- wheatprotein[, 8]
Y &lt;- wheatprotein[, 1:6]
u &lt;- u.env(X, Y)
u
</code></pre>

<hr>
<h2 id='u.env.apweights'>Select the dimension of env.apweights</h2><span id='topic+u.env.apweights'></span>

<h3>Description</h3>

<p>This function outputs dimensions selected by Akaike information criterion (AIC), Bayesian information criterion (BIC) and likelihood ratio testing with specified significance level for the response envelope model that accommodates nonconstant variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>u.env.apweights(X, Y, alpha = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="u.env.apweights_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="u.env.apweights_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="u.env.apweights_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for testing.  The default is 0.01.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>u.aic</code></td>
<td>
<p>Dimension of the envelope subspace selected by AIC.</p>
</td></tr>
<tr><td><code>u.bic</code></td>
<td>
<p>Dimension of the envelope subspace selected by BIC.</p>
</td></tr>
<tr><td><code>u.lrt</code></td>
<td>
<p>Dimension of the envelope subspace selected by the likelihood ratio testing procedure.</p>
</td></tr>
<tr><td><code>loglik.seq</code></td>
<td>
<p>Log likelihood for dimension from 0 to r.</p>
</td></tr>
<tr><td><code>aic.seq</code></td>
<td>
<p>AIC value for dimension from 0 to r.</p>
</td></tr>
<tr><td><code>bic.seq</code></td>
<td>
<p>BIC value for dimension from 0 to r.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(concrete)
X &lt;- concrete[, 1:7]
Y &lt;- concrete[, 8:10]
## Not run: u &lt;- u.env.apweights(X, Y)
## Not run: u
</code></pre>

<hr>
<h2 id='u.env.tcond'>Select the dimension of env.tcond</h2><span id='topic+u.env.tcond'></span>

<h3>Description</h3>

<p>This function outputs dimensions selected by Akaike information criterion (AIC), Bayesian information criterion (BIC) and likelihood ratio testing with specified significance level for the response envelope model with t-distributed errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>u.env.tcond(X, Y, df, alpha = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="u.env.tcond_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="u.env.tcond_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="u.env.tcond_+3A_df">df</code></td>
<td>
<p>Degrees of freedom of the t-distribution. A positive number that is greater than 2.</p>
</td></tr>
<tr><td><code id="u.env.tcond_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for testing.  The default is 0.01.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>u.aic</code></td>
<td>
<p>Dimension of the envelope subspace selected by AIC.</p>
</td></tr>
<tr><td><code>u.bic</code></td>
<td>
<p>Dimension of the envelope subspace selected by BIC.</p>
</td></tr>
<tr><td><code>u.lrt</code></td>
<td>
<p>Dimension of the envelope subspace selected by the likelihood ratio testing procedure.</p>
</td></tr>
<tr><td><code>loglik.seq</code></td>
<td>
<p>Log likelihood for dimension from 0 to r.</p>
</td></tr>
<tr><td><code>aic.seq</code></td>
<td>
<p>AIC value for dimension from 0 to r.</p>
</td></tr>
<tr><td><code>bic.seq</code></td>
<td>
<p>BIC value for dimension from 0 to r.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(concrete)
X &lt;- concrete[1:78, 1:7]  # The first 78 observations are training data
Y &lt;- concrete[1:78, 8:10]
## Not run: u &lt;- u.env.tcond(X, Y, 6)
## Not run: u

</code></pre>

<hr>
<h2 id='u.eppls'>Select the dimension of eppls</h2><span id='topic+u.eppls'></span>

<h3>Description</h3>

<p>This function outputs dimensions selected by Bayesian information criterion (BIC) for the Envelope-based Partial Partial Least Squares.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>u.eppls(X1, X2, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="u.eppls_+3A_x1">X1</code></td>
<td>

<p>An <code class="reqn">n</code> by <code class="reqn">p1</code> matrix of continuous predictors, where <code class="reqn">p1</code> is the  number of continuous predictors with <code class="reqn">p1 &lt; n</code>.
</p>
</td></tr>
<tr><td><code id="u.eppls_+3A_x2">X2</code></td>
<td>

<p>An <code class="reqn">n</code> by <code class="reqn">p2</code> matrix of categorical predictors, where <code class="reqn">p2</code> is the  number of categorical predictors with <code class="reqn">p2 &lt; n</code>.
</p>
</td></tr>
<tr><td><code id="u.eppls_+3A_y">Y</code></td>
<td>

<p>An <code class="reqn">n</code> by <code class="reqn">r</code> matrix of multivariate responses, where <code class="reqn">r</code> is the number of responses.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>u.bic</code></td>
<td>

<p>Dimension of the Envelope-based Partial Partial Least Squares.
</p>
</td></tr>
<tr><td><code>bic.seq</code></td>
<td>

<p>BIC value for dimension from <code class="reqn">0</code> to <code class="reqn">p1</code>.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Park, Y., Su, Z. and Chung, D. (2022+)  Envelope-based Partial Partial Least Squares with Application to Cytokine-based Biomarker Analysis for COVID-19.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(amitriptyline)
  
  Y &lt;- amitriptyline[ , 1:2]
  X1 &lt;- amitriptyline[ , 4:7]
  X2 &lt;- amitriptyline[ , 3]
  u &lt;- u.eppls(X1, X2, Y)
  
  u
</code></pre>

<hr>
<h2 id='u.felmdir'>Find the envelope dimensions in the functional envelope linear model</h2><span id='topic+u.felmdir'></span>

<h3>Description</h3>

<p>Fit the dimensions of the response and predictor envelopes in function-on-function linear regression, under direct estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  u.felmdir(X, Y, t1, t2, knots = c(0, 0.25, 0.5, 0.75, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="u.felmdir_+3A_x">X</code></td>
<td>
<p>Predictor function. An n by T1 matrix, T1 is number of observed time points, which is the length of t1.  Here we assume that each function is observed at the same time points.</p>
</td></tr>
<tr><td><code id="u.felmdir_+3A_y">Y</code></td>
<td>
<p>Response function. An n by T2 matrix, T2 is number of observed time points, which is the length of t2.  Here we assume that each function is observed at the same time points.</p>
</td></tr>
<tr><td><code id="u.felmdir_+3A_t1">t1</code></td>
<td>
<p>The observed time points for the predictor functions.</p>
</td></tr>
<tr><td><code id="u.felmdir_+3A_t2">t2</code></td>
<td>
<p>The observed time points for the response functions.</p>
</td></tr>
<tr><td><code id="u.felmdir_+3A_knots">knots</code></td>
<td>
<p>The location of knots of the cubic splines used for estimation.  Locations should be positive. The default location of the knots are 0, 0.25, 0.5, 0.75, 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds the dimension of the predictor and response envelope model by Bayesian information criterion (BIC) performed on the direct estimation.  To be more specific, consider the envelope model to the function-on-function linear regression, </p>
<p style="text-align: center;"><code class="reqn">
 Y = \alpha + B X + \epsilon, 
 </code>
</p>

<p>where X and Y are random functions in Hilbert spaces <code class="reqn">H_X</code> and <code class="reqn">H_Y</code>, <code class="reqn">\alpha</code> is a fixed member in <code class="reqn">H_Y</code>, <code class="reqn">\epsilon</code> is a random member of <code class="reqn">H_Y</code>, and B: <code class="reqn">H_X -&gt; H_Y</code> is a linear operator.  We use cubic splines as the basis for both <code class="reqn">H_X</code> and <code class="reqn">H_Y</code>. The coefficients <code class="reqn">[X]</code> and <code class="reqn">[Y]</code> with respect to the basis are computed.  The predictor and response envelope model is fitted on the linear regression model of <code class="reqn">[Y]</code> on <code class="reqn">[X]</code>, and the dimensions of the predictor and response envelopes are calculated using BIC. The details are included in Section 7 of Su et al. (2022).  
</p>


<h3>Value</h3>

<p>The output is a list that contains the following components:
</p>
<table>
<tr><td><code>ux</code></td>
<td>
<p>The estimated dimension of the predictor envelope.</p>
</td></tr>
<tr><td><code>uy</code></td>
<td>
<p>The estimated dimension of the response envelope.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>The envelope estimator of the regression coefficients in the regression of <code class="reqn">[Y]</code> on <code class="reqn">[X]</code>, when the dimensions of envelopes are taken at their estimated values.</p>
</td></tr> 
<tr><td><code>betafull</code></td>
<td>
<p>The standard estimator, i.e., the OLS estimator of the regression coefficients in the regression of <code class="reqn">[Y]</code> on <code class="reqn">[X]</code>.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>The envelope estimator of the intercept in the regression of <code class="reqn">[Y]</code> on <code class="reqn">[X]</code>, when the dimensions of envelopes are taken at their estimated values.</p>
</td></tr>
<tr><td><code>alphafull</code></td>
<td>
<p>The standard estimator of the intercept in the regression of <code class="reqn">[Y]</code> on <code class="reqn">[X]</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Su, Z., Li, B. and Cook, R. D. (2022+) Envelope model for function-on-function linear regression.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(NJdata)
  dataX &lt;- matrix(NJdata[,6], nrow = 21)
  X &lt;- as.matrix(dataX[, 32:61])
  dataY &lt;- matrix(NJdata[,3], nrow = 21)
  Y &lt;- as.matrix(dataY[, 32:61])
  t1 &lt;- 0:29
  t2 &lt;- t1
  
  ## Not run: m &lt;- u.felmdir(X, Y, t1, t2)
  ## Not run: m$ux
  ## Not run: m$uy
</code></pre>

<hr>
<h2 id='u.felmKL'>Find the envelope dimensions in the functional envelope linear model</h2><span id='topic+u.felmKL'></span>

<h3>Description</h3>

<p>Fit the dimensions of the response and predictor envelopes in function-on-function linear regression, under Karhunen-Loeve expansion based estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  u.felmKL(X, Y, t1, t2, knots = c(0, 0.25, 0.5, 0.75, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="u.felmKL_+3A_x">X</code></td>
<td>
<p>Predictor function. An n by T1 matrix, T1 is number of observed time points, which is the length of t1.  Here we assume that each function is observed at the same time points.</p>
</td></tr>
<tr><td><code id="u.felmKL_+3A_y">Y</code></td>
<td>
<p>Response function. An n by T2 matrix, T2 is number of observed time points, which is the length of t2.  Here we assume that each function is observed at the same time points.</p>
</td></tr>
<tr><td><code id="u.felmKL_+3A_t1">t1</code></td>
<td>
<p>The observed time points for the predictor functions.</p>
</td></tr>
<tr><td><code id="u.felmKL_+3A_t2">t2</code></td>
<td>
<p>The observed time points for the response functions.</p>
</td></tr>
<tr><td><code id="u.felmKL_+3A_knots">knots</code></td>
<td>
<p>The location of knots of the cubic splines used for estimation.  Locations should be positive. The default location of the knots are 0, 0.25, 0.5, 0.75, 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds the dimension of the predictor and response envelope model by Bayesian information criterion (BIC) performed on the Karhunen-Lo'eve expansion based estimation.  To be more specific, consider the envelope model to the function-on-function linear regression, </p>
<p style="text-align: center;"><code class="reqn">
 Y = \alpha + B X + \epsilon, 
 </code>
</p>

<p>where X and Y are random functions in Hilbert spaces <code class="reqn">H_X</code> and <code class="reqn">H_Y</code>, <code class="reqn">\alpha</code> is a fixed member in <code class="reqn">H_Y</code>, <code class="reqn">\epsilon</code> is a random member of <code class="reqn">H_Y</code>, and B: <code class="reqn">H_X -&gt; H_Y</code> is a linear operator.  We use cubic splines as the basis for both <code class="reqn">H_X</code> and <code class="reqn">H_Y</code> in the estimation of the eigenfunctions of <code class="reqn">Sigma_X</code> and <code class="reqn">Sigma_\epsilon</code>. The coefficients <code class="reqn">[X]</code> and <code class="reqn">[Y]</code> with respect to the estimated eigenfunctions are computed.  The predictor and response envelope model is fitted on the linear regression model of <code class="reqn">[Y]</code> on <code class="reqn">[X]</code>, and the dimensions of the predictor and response envelopes are calculated using BIC. The details are included in Section 7 of Su et al. (2022).  
</p>


<h3>Value</h3>

<p>The output is a list that contains the following components:
</p>
<table>
<tr><td><code>ux</code></td>
<td>
<p>The estimated dimension of the predictor envelope.</p>
</td></tr>
<tr><td><code>uy</code></td>
<td>
<p>The estimated dimension of the response envelope.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>The envelope estimator of the regression coefficients in the regression of <code class="reqn">[Y]</code> on <code class="reqn">[X]</code>, when the dimensions of envelopes are taken at their estimated values.</p>
</td></tr> 
<tr><td><code>betafull</code></td>
<td>
<p>The standard estimator, i.e., the OLS estimator of the regression coefficients in the regression of <code class="reqn">[Y]</code> on <code class="reqn">[X]</code>.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>The envelope estimator of the intercept in the regression of <code class="reqn">[Y]</code> on <code class="reqn">[X]</code>, when the dimensions of envelopes are taken at their estimated values.</p>
</td></tr>
<tr><td><code>alphafull</code></td>
<td>
<p>The standard estimator of the intercept in the regression of <code class="reqn">[Y]</code> on <code class="reqn">[X]</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Su, Z., Li, B. and Cook, R. D. (2022+) Envelope model for function-on-function linear regression.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(NJdata)
  dataX &lt;- matrix(NJdata[,6], nrow = 21)
  X &lt;- as.matrix(dataX[, 32:61])
  dataY &lt;- matrix(NJdata[,3], nrow = 21)
  Y &lt;- as.matrix(dataY[, 32:61])
  t1 &lt;- 0:29
  t2 &lt;- t1
  
  ## Not run: m &lt;- u.felmKL(X, Y, t1, t2)
  ## Not run: m$ux
  ## Not run: m$uy
</code></pre>

<hr>
<h2 id='u.genv'>Select the dimension of genv</h2><span id='topic+u.genv'></span>

<h3>Description</h3>

<p>This function outputs dimensions selected by Akaike information criterion (AIC), Bayesian information criterion (BIC) and likelihood ratio testing with specified significance level for the groupwise envelope model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>u.genv(X, Y, Z, alpha = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="u.genv_+3A_x">X</code></td>
<td>

<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.
</p>
</td></tr>
<tr><td><code id="u.genv_+3A_y">Y</code></td>
<td>

<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.
</p>
</td></tr>
<tr><td><code id="u.genv_+3A_z">Z</code></td>
<td>

<p>A group indicator vector of length <code class="reqn">n</code>, where <code class="reqn">n</code> 
denotes the number of observations.
</p>
</td></tr>
<tr><td><code id="u.genv_+3A_alpha">alpha</code></td>
<td>

<p>Significance level for testing.  The default is 0.01.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>u.aic</code></td>
<td>
<p>Dimension of the groupwise envelope subspace selected by AIC.</p>
</td></tr>
<tr><td><code>u.bic</code></td>
<td>
<p>Dimension of the groupwise envelope subspace selected by BIC.</p>
</td></tr>
<tr><td><code>u.lrt</code></td>
<td>
<p>Dimension of the groupwise envelope subspace selected by the likelihood ratio testing procedure.</p>
</td></tr>
<tr><td><code>loglik.seq</code></td>
<td>
<p>Log likelihood for dimension from 0 to r.</p>
</td></tr>
<tr><td><code>aic.seq</code></td>
<td>
<p>AIC value for dimension from 0 to r.</p>
</td></tr>
<tr><td><code>bic.seq</code></td>
<td>
<p>BIC value for dimension from 0 to r.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(fiberpaper)
X &lt;- fiberpaper[ , c(5, 7)]
Y &lt;- fiberpaper[ , 1:3]
Z &lt;- as.numeric(fiberpaper[ , 6] &gt; mean(fiberpaper[ , 6]))

u &lt;- u.genv(X, Y, Z)
u
</code></pre>

<hr>
<h2 id='u.henv'>Select the dimension of henv</h2><span id='topic+u.henv'></span>

<h3>Description</h3>

<p>This function outputs dimensions selected by Akaike information criterion (AIC), Bayesian information criterion (BIC) and likelihood ratio testing with specified significance level for the heteroscedastic envelope model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>u.henv(X, Y, alpha = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="u.henv_+3A_x">X</code></td>
<td>

<p>A group indicator vector of length <code class="reqn">n</code>, where <code class="reqn">n</code> 
denotes the number of observations.
</p>
</td></tr>
<tr><td><code id="u.henv_+3A_y">Y</code></td>
<td>

<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.
</p>
</td></tr>
<tr><td><code id="u.henv_+3A_alpha">alpha</code></td>
<td>

<p>Significance level for testing.  The default is 0.01.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>u.aic</code></td>
<td>
<p>Dimension of the heteroscedastic envelope subspace selected by AIC.</p>
</td></tr>
<tr><td><code>u.bic</code></td>
<td>
<p>Dimension of the heteroscedastic envelope subspace selected by BIC.</p>
</td></tr>
<tr><td><code>u.lrt</code></td>
<td>
<p>Dimension of the heteroscedastic envelope subspace selected by the likelihood ratio testing procedure.</p>
</td></tr>
<tr><td><code>loglik.seq</code></td>
<td>
<p>Log likelihood for dimension from 0 to r.</p>
</td></tr>
<tr><td><code>aic.seq</code></td>
<td>
<p>AIC value for dimension from 0 to r.</p>
</td></tr>
<tr><td><code>bic.seq</code></td>
<td>
<p>BIC value for dimension from 0 to r.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(waterstrider)
X &lt;- waterstrider[ , 1]
Y &lt;- waterstrider[ , 2:5]

## Not run: u &lt;- u.henv(X, Y)
## Not run: u
</code></pre>

<hr>
<h2 id='u.logit.env'>Select the dimension of logit.env</h2><span id='topic+u.logit.env'></span>

<h3>Description</h3>

<p>This function outputs dimensions selected by Akaike information criterion (AIC), Bayesian information criterion (BIC) and likelihood ratio testing with specified significance level for the envelope model in logistic regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>u.logit.env(X, Y, alpha = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="u.logit.env_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors and n is number of observations.  The predictors must be continuous variables.</p>
</td></tr>
<tr><td><code id="u.logit.env_+3A_y">Y</code></td>
<td>
<p>Response. An n by 1 matrix. The univariate response must be binary.</p>
</td></tr>
<tr><td><code id="u.logit.env_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for testing.  The default is 0.01.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>u.aic</code></td>
<td>
<p>Dimension of the envelope subspace selected by AIC.</p>
</td></tr>
<tr><td><code>u.bic</code></td>
<td>
<p>Dimension of the envelope subspace selected by BIC.</p>
</td></tr>
<tr><td><code>u.lrt</code></td>
<td>
<p>Dimension of the envelope subspace selected by the likelihood ratio testing procedure.</p>
</td></tr>
<tr><td><code>loglik.seq</code></td>
<td>
<p>Log likelihood for dimension from 0 to p.</p>
</td></tr>
<tr><td><code>aic.seq</code></td>
<td>
<p>AIC value for dimension from 0 to p.</p>
</td></tr>
<tr><td><code>bic.seq</code></td>
<td>
<p>BIC value for dimension from 0 to p.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(horseshoecrab)
X1 &lt;- as.numeric(horseshoecrab[ , 1] == 2)
X2 &lt;- as.numeric(horseshoecrab[ , 1] == 3)
X3 &lt;- as.numeric(horseshoecrab[ , 1] == 4)
X4 &lt;- as.numeric(horseshoecrab[ , 2] == 2)
X5 &lt;- as.numeric(horseshoecrab[ , 2] == 3)
X6 &lt;- horseshoecrab[ , 3]
X7 &lt;- horseshoecrab[ , 5]
X &lt;- cbind(X1, X2, X3, X4, X5, X6, X7)
Y &lt;- as.numeric(ifelse(horseshoecrab[ , 4] &gt; 0, 1, 0))

## Not run: u &lt;- u.logit.env(X, Y)
## Not run: u
</code></pre>

<hr>
<h2 id='u.penv'>Select the dimension of penv</h2><span id='topic+u.penv'></span>

<h3>Description</h3>

<p>This function outputs dimensions selected by Akaike information criterion (AIC), Bayesian information criterion (BIC) and likelihood ratio testing with specified significance level for the partial envelope model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>u.penv(X1, X2, Y, alpha = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="u.penv_+3A_x1">X1</code></td>
<td>
<p>Predictors of main interest. An n by p1 matrix, n is the number of observations, and p1 is the number of main predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="u.penv_+3A_x2">X2</code></td>
<td>
<p>Covariates, or predictors not of main interest.  An n by p2 matrix, p2 is the number of covariates.</p>
</td></tr>
<tr><td><code id="u.penv_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="u.penv_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for testing.  The default is 0.01.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>u.aic</code></td>
<td>
<p>Dimension of the partial envelope subspace selected by AIC.</p>
</td></tr>
<tr><td><code>u.bic</code></td>
<td>
<p>Dimension of the partial envelope subspace selected by BIC.</p>
</td></tr>
<tr><td><code>u.lrt</code></td>
<td>
<p>Dimension of the partial envelope subspace selected by the likelihood ratio testing procedure.</p>
</td></tr>
<tr><td><code>loglik.seq</code></td>
<td>
<p>Log likelihood for dimension from 0 to r.</p>
</td></tr>
<tr><td><code>aic.seq</code></td>
<td>
<p>AIC value for dimension from 0 to r.</p>
</td></tr>
<tr><td><code>bic.seq</code></td>
<td>
<p>BIC value for dimension from 0 to r.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(fiberpaper)
X1 &lt;- fiberpaper[, 7]
X2 &lt;- fiberpaper[, 5:6]
Y &lt;- fiberpaper[, 1:4]

u &lt;- u.penv(X1, X2, Y)
u
</code></pre>

<hr>
<h2 id='u.pois.env'>Select the dimension of pois.env</h2><span id='topic+u.pois.env'></span>

<h3>Description</h3>

<p>This function outputs dimensions selected by Akaike information criterion (AIC), Bayesian information criterion (BIC) and likelihood ratio testing with specified significance level for the envelope model in poisson regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>u.pois.env(X, Y, alpha = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="u.pois.env_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors and n is number of observations.  The predictors must be continuous variables.</p>
</td></tr>
<tr><td><code id="u.pois.env_+3A_y">Y</code></td>
<td>
<p>Response. An n by 1 matrix. The univariate response must be counts.</p>
</td></tr>
<tr><td><code id="u.pois.env_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for testing.  The default is 0.01.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>u.aic</code></td>
<td>
<p>Dimension of the envelope subspace selected by AIC.</p>
</td></tr>
<tr><td><code>u.bic</code></td>
<td>
<p>Dimension of the envelope subspace selected by BIC.</p>
</td></tr>
<tr><td><code>u.lrt</code></td>
<td>
<p>Dimension of the envelope subspace selected by the likelihood ratio testing procedure.</p>
</td></tr>
<tr><td><code>loglik.seq</code></td>
<td>
<p>Log likelihood for dimension from 0 to p.</p>
</td></tr>
<tr><td><code>aic.seq</code></td>
<td>
<p>AIC value for dimension from 0 to p.</p>
</td></tr>
<tr><td><code>bic.seq</code></td>
<td>
<p>BIC value for dimension from 0 to p.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(horseshoecrab)
X1 &lt;- as.numeric(horseshoecrab[ , 1] == 2)
X2 &lt;- as.numeric(horseshoecrab[ , 1] == 3)
X3 &lt;- as.numeric(horseshoecrab[ , 1] == 4)
X4 &lt;- as.numeric(horseshoecrab[ , 2] == 2)
X5 &lt;- as.numeric(horseshoecrab[ , 2] == 3)
X6 &lt;- horseshoecrab[ , 3]
X7 &lt;- horseshoecrab[ , 5]
X &lt;- cbind(X1, X2, X3, X4, X5, X6, X7)
Y &lt;- horseshoecrab[ , 4]

## Not run: u &lt;- u.pois.env(X, Y)
## Not run: u
</code></pre>

<hr>
<h2 id='u.pred2.env'>Select the dimension of the constructed partial envelope for prediction based on envelope model</h2><span id='topic+u.pred2.env'></span>

<h3>Description</h3>

<p>This function outputs dimensions selected by Akaike information criterion (AIC), Bayesian information criterion (BIC) and likelihood ratio testing with specified significance level for the constructed partial envelope model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>u.pred2.env(X, Y, Xnew, alpha = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="u.pred2.env_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="u.pred2.env_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="u.pred2.env_+3A_xnew">Xnew</code></td>
<td>
<p>The value of X with which to estimate or predict Y.  A p dimensional vector.</p>
</td></tr>
<tr><td><code id="u.pred2.env_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for testing.  The default is 0.01.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>u.aic</code></td>
<td>
<p>Dimension of the constructed partial envelope subspace selected by AIC.</p>
</td></tr>
<tr><td><code>u.bic</code></td>
<td>
<p>Dimension of the constructed partial envelope subspace selected by BIC.</p>
</td></tr>
<tr><td><code>u.lrt</code></td>
<td>
<p>Dimension of the constructed partial envelope subspace selected by the likelihood ratio testing procedure.</p>
</td></tr>
<tr><td><code>loglik.seq</code></td>
<td>
<p>Log likelihood for dimension from 0 to r.</p>
</td></tr>
<tr><td><code>aic.seq</code></td>
<td>
<p>AIC value for dimension from 0 to r.</p>
</td></tr>
<tr><td><code>bic.seq</code></td>
<td>
<p>BIC value for dimension from 0 to r.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(fiberpaper)
X &lt;- fiberpaper[, 5:7]
Y &lt;- fiberpaper[, 1:4]

u &lt;- u.pred2.env(X, Y, X[10, ])
u
</code></pre>

<hr>
<h2 id='u.rrenv'>Select the dimension of rrenv</h2><span id='topic+u.rrenv'></span>

<h3>Description</h3>

<p>This function outputs the envelope dimension selected by Akaike information criterion (AIC), Bayesian information criterion (BIC) and likelihood ratio testing with specified significance level for the reduced rank envelope model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>u.rrenv(X, Y, d, alpha = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="u.rrenv_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="u.rrenv_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="u.rrenv_+3A_d">d</code></td>
<td>
<p>The rank of the coefficient matrix.  An integer between 0 and r.</p>
</td></tr>
<tr><td><code id="u.rrenv_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for testing.  The default is 0.01.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>u.aic</code></td>
<td>
<p>Dimension of the envelope subspace selected by AIC.</p>
</td></tr>
<tr><td><code>u.bic</code></td>
<td>
<p>Dimension of the envelope subspace selected by BIC.</p>
</td></tr>
<tr><td><code>u.lrt</code></td>
<td>
<p>Dimension of the envelope subspace selected by the likelihood ratio testing procedure.</p>
</td></tr>
<tr><td><code>loglik.seq</code></td>
<td>
<p>Log likelihood for dimension from d to r.</p>
</td></tr>
<tr><td><code>aic.seq</code></td>
<td>
<p>AIC value for dimension from d to r.</p>
</td></tr>
<tr><td><code>bic.seq</code></td>
<td>
<p>BIC value for dimension from d to r.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(vehicles)
X &lt;- vehicles[, 1:11]  
Y &lt;- vehicles[, 12:15]
X &lt;- scale(X)
Y &lt;- scale(Y)  # The scales of Y are vastly different, so scaling is reasonable here
d &lt;- d.select(X, Y, 0.01)
d

## Not run: u &lt;- u.rrenv(X, Y, 2)
## Not run: u

</code></pre>

<hr>
<h2 id='u.rrenv.apweights'>Select the dimension of rrenv.apweights</h2><span id='topic+u.rrenv.apweights'></span>

<h3>Description</h3>

<p>This function outputs the envelope dimension selected by Akaike information criterion (AIC), Bayesian information criterion (BIC) and likelihood ratio testing with specified significance level for the reduced rank envelope model with nonconstant error variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>u.rrenv.apweights(X, Y, d, alpha = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="u.rrenv.apweights_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="u.rrenv.apweights_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="u.rrenv.apweights_+3A_d">d</code></td>
<td>
<p>The rank of the coefficient matrix.  An integer between 0 and r.</p>
</td></tr>
<tr><td><code id="u.rrenv.apweights_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for testing.  The default is 0.01.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>u.aic</code></td>
<td>
<p>Dimension of the envelope subspace selected by AIC.</p>
</td></tr>
<tr><td><code>u.bic</code></td>
<td>
<p>Dimension of the envelope subspace selected by BIC.</p>
</td></tr>
<tr><td><code>u.lrt</code></td>
<td>
<p>Dimension of the envelope subspace selected by the likelihood ratio testing procedure.</p>
</td></tr>
<tr><td><code>loglik.seq</code></td>
<td>
<p>Log likelihood for dimension from d to r.</p>
</td></tr>
<tr><td><code>aic.seq</code></td>
<td>
<p>AIC value for dimension from d to r.</p>
</td></tr>
<tr><td><code>bic.seq</code></td>
<td>
<p>BIC value for dimension from d to r.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(vehicles)
X &lt;- vehicles[, 1:11]  
Y &lt;- vehicles[, 12:15]
X &lt;- scale(X)
Y &lt;- scale(Y)  # The scales of Y are vastly different, so scaling is reasonable here
d &lt;- d.select(X, Y, 0.01)
d

## Not run: u &lt;- u.rrenv.apweights(X, Y, 2)
## Not run: u

</code></pre>

<hr>
<h2 id='u.senv'>Select the dimension of senv</h2><span id='topic+u.senv'></span>

<h3>Description</h3>

<p>This function outputs dimensions selected by Akaike information criterion (AIC), Bayesian information criterion (BIC) for the scaled response envelope model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>u.senv(X, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="u.senv_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="u.senv_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>u.aic</code></td>
<td>
<p>Dimension of the scaled envelope subspace selected by AIC.</p>
</td></tr>
<tr><td><code>u.bic</code></td>
<td>
<p>Dimension of the scaled envelope subspace selected by BIC.</p>
</td></tr>
<tr><td><code>aic.seq</code></td>
<td>
<p>AIC value for dimension from 0 to r.</p>
</td></tr>
<tr><td><code>bic.seq</code></td>
<td>
<p>BIC value for dimension from 0 to r.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(sales)
X &lt;- sales[, 1:3]
Y &lt;- sales[, 4:7]

u &lt;- u.senv(X, Y)
u
</code></pre>

<hr>
<h2 id='u.stenv'>Select the dimension of stenv</h2><span id='topic+u.stenv'></span>

<h3>Description</h3>

<p>This function outputs dimensions selected by Akaike information criterion (AIC), Bayesian information criterion (BIC) and likelihood ratio testing with specified significance level for the simultaneous envelope model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>u.stenv(X, Y, alpha = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="u.stenv_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="u.stenv_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="u.stenv_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for testing. The default is 0.01.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>d</code></td>
<td>
<p>Rank of beta selected by the Bura-Cook estimator.</p>
</td></tr>	
<tr><td><code>u.aic</code></td>
<td>
<p>Dimension of the simultaneous envelope subspace selected by AIC.</p>
</td></tr>
<tr><td><code>u.bic</code></td>
<td>
<p>Dimension of the simultaneous envelope subspace selected by BIC.</p>
</td></tr>
<tr><td><code>u.lrt</code></td>
<td>
<p>Dimension of the simultaneous envelope subspace selected by the likelihood ratio testing procedure.</p>
</td></tr>
<tr><td><code>loglik.mat</code></td>
<td>
<p>Log likelihood for dimension from (1, 1) to (p, r).</p>
</td></tr>
<tr><td><code>aic.mat</code></td>
<td>
<p>AIC value for dimension from (1, 1) to (p, r).</p>
</td></tr>
<tr><td><code>bic.mat</code></td>
<td>
<p>BIC value for dimension from (1, 1) to (p, r).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(fiberpaper)
X &lt;- fiberpaper[, 5:7]
Y &lt;- fiberpaper[, 1:4]

u &lt;- u.stenv(X, Y)
u
</code></pre>

<hr>
<h2 id='u.sxenv'>Select the dimension of sxenv</h2><span id='topic+u.sxenv'></span>

<h3>Description</h3>

<p>This function outputs dimensions selected by Akaike information criterion (AIC), Bayesian information criterion (BIC) for the scaled predictor envelope model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>u.sxenv(X, Y, R)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="u.sxenv_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="u.sxenv_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="u.sxenv_+3A_r">R</code></td>
<td>
<p>The number of replications of the scales. A vector, the sum of all elements of R must be p.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>u.aic</code></td>
<td>
<p>Dimension of the scaled envelope subspace in the predictor space selected by AIC.</p>
</td></tr>
<tr><td><code>u.bic</code></td>
<td>
<p>Dimension of the scaled envelope subspace in the predictor space selected by BIC.</p>
</td></tr>
<tr><td><code>aic.seq</code></td>
<td>
<p>AIC value for dimension from 0 to p.</p>
</td></tr>
<tr><td><code>bic.seq</code></td>
<td>
<p>BIC value for dimension from 0 to p.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(sales)
Y &lt;- sales[, 1:3]
X &lt;- sales[, 4:7]
R &lt;- rep(1, 4)

u &lt;- u.sxenv(X, Y, R)
u
</code></pre>

<hr>
<h2 id='u.xenv'>Select the dimension of xenv</h2><span id='topic+u.xenv'></span>

<h3>Description</h3>

<p>This function outputs dimensions selected by Akaike information criterion (AIC), Bayesian information criterion (BIC) and likelihood ratio testing with specified significance level for the predictor envelope model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>u.xenv(X, Y, alpha = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="u.xenv_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors and n is number of observations.  The predictors must be continuous variables.</p>
</td></tr>
<tr><td><code id="u.xenv_+3A_y">Y</code></td>
<td>
<p>Responses. An n by r matrix, r is the number of responses. The response can be univariate or multivariate and must be continuous variable.</p>
</td></tr>
<tr><td><code id="u.xenv_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for testing.  The default is 0.01.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>u.aic</code></td>
<td>
<p>Dimension of the envelope subspace selected by AIC.</p>
</td></tr>
<tr><td><code>u.bic</code></td>
<td>
<p>Dimension of the envelope subspace selected by BIC.</p>
</td></tr>
<tr><td><code>u.lrt</code></td>
<td>
<p>Dimension of the envelope subspace selected by the likelihood ratio testing procedure.</p>
</td></tr>
<tr><td><code>loglik.seq</code></td>
<td>
<p>Log likelihood for dimension from 0 to p.</p>
</td></tr>
<tr><td><code>aic.seq</code></td>
<td>
<p>AIC value for dimension from 0 to p.</p>
</td></tr>
<tr><td><code>bic.seq</code></td>
<td>
<p>BIC value for dimension from 0 to p.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(wheatprotein)
X &lt;- wheatprotein[, 1:6]
Y &lt;- wheatprotein[, 7]

u &lt;- u.xenv(X, Y)
u
</code></pre>

<hr>
<h2 id='vehicles'>Automobile Dataset</h2><span id='topic+vehicles'></span>

<h3>Description</h3>

<p>This dataset consists of 15 characteristics for 30 vehicles.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data("vehicles")
</code></pre>


<h3>Format</h3>

<p>A data frame with 30 entries on the following 15 variables.
</p>

<dl>
<dt><code>turbo</code></dt><dd><p>Indicator for vehicles with turbo aspiration.</p>
</dd>
<dt><code>two.doors</code></dt><dd><p>Indicator for vehicles with two doors.</p>
</dd>
<dt><code>hatchback</code></dt><dd><p>Indicator for hatchback vehicles.</p>
</dd>
<dt><code>wheel.base</code></dt><dd><p>Wheelbase of the vehicle.</p>
</dd>
<dt><code>length</code></dt><dd><p>Length of the vehicle.</p>
</dd>
<dt><code>width</code></dt><dd><p>Width of the vehicle.</p>
</dd>
<dt><code>height</code></dt><dd><p>Height of the vehicle.</p>
</dd>
<dt><code>curb.weight</code></dt><dd><p>Curb weight of the vehicle.</p>
</dd>
<dt><code>eng.size</code></dt><dd><p>Engine size of the vehicle.</p>
</dd>
<dt><code>horsepower</code></dt><dd><p>Horsepower of the vehicle.</p>
</dd>
<dt><code>peak.rpm</code></dt><dd><p>Peak revolutions per minute.</p>
</dd>
<dt><code>price</code></dt><dd><p>Price in dollars.</p>
</dd>
<dt><code>symbol</code></dt><dd><p>Insurance risk rating.  A value of +3 indicates that the auto is risky, -3 that it is probably pretty safe.</p>
</dd>
<dt><code>city.mpg</code></dt><dd><p>Fuel efficiency in city.</p>
</dd>
<dt><code>highway.mpg</code></dt><dd><p>Fuel efficiency in highway.</p>
</dd>
</dl>



<h3>Source</h3>

<p>This dataset is a subset of the vehicles dataset in the R package plsdepot.
</p>


<h3>References</h3>

<p>1) 1985 Model Import Car and Truck Specifications, 1985 Ward's Automotive Yearbook.
2) Personal Auto Manuals, Insurance Services Office, 160 Water Street, New York, NY 10038. 
3) Insurance Collision Report, Insurance Institute for Highway Safety, Watergate 600, Washington, DC 20037. 
</p>
<p>Machine Learning Repository. http://archive.ics.uci.edu/ml/datasets/Automobile</p>

<hr>
<h2 id='waterstrider'>Water strider data
</h2><span id='topic+waterstrider'></span>

<h3>Description</h3>

<p>Measures of characteristics of the water striders </p>


<h3>Usage</h3>

<pre><code class='language-R'>data("waterstrider")</code></pre>


<h3>Format</h3>

<p>A data frame with 90 observations on the following 9 variables.
</p>

<dl>
<dt><code>V1</code></dt><dd><p>Index of water strider species.</p>
</dd>
<dt><code>V2</code></dt><dd><p>Logarithm of length of the first antennal segment.</p>
</dd>
<dt><code>V3</code></dt><dd><p>Logarithm of length of the second antennal segment.</p>
</dd>
<dt><code>V4</code></dt><dd><p>Logarithm of length of the third antennal segment.</p>
</dd>
<dt><code>V5</code></dt><dd><p>Logarithm of length of the fourth antennal segment.</p>
</dd>
<dt><code>V6</code></dt><dd><p>Logarithm of length of fomora of middle leg.</p>
</dd>
<dt><code>V7</code></dt><dd><p>Logarithm of length of tibiae of middle leg.</p>
</dd>
<dt><code>V8</code></dt><dd><p>Logarithm of length of fomora of hind leg.</p>
</dd>
<dt><code>V9</code></dt><dd><p>Logarithm of length of tibiae of hind leg.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This data set contains 8 measures of water striders and an indicator of the species of water striders.
</p>


<h3>References</h3>

<p>Klingenberg, C. R. and Spence, J. R. (1993). Heterochrony and Allometry Lessons from the Water Strider Genus Limnoporus. Evolution 47, 1834-1853
</p>

<hr>
<h2 id='weighted.env'>Weighted response envelope estimator</h2><span id='topic+weighted.env'></span>

<h3>Description</h3>

<p>Compute the weighted response envelope estimator with weights computed from BIC. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted.env(X, Y, bstrpNum = 0, min.u = 1, 
max.u = ncol(as.matrix(Y)), boot.resi = "full")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted.env_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="weighted.env_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="weighted.env_+3A_bstrpnum">bstrpNum</code></td>
<td>
<p>Number of bootstrap samples. A positive integer.</p>
</td></tr>
<tr><td><code id="weighted.env_+3A_min.u">min.u</code></td>
<td>
<p>Lower bound of the range of u to compute bootstrap error. A postive integer between 1 and p. This argument is relevant only when <code>bstrpNum</code>&gt;0.</p>
</td></tr>
<tr><td><code id="weighted.env_+3A_max.u">max.u</code></td>
<td>
<p>Upper bound of the range of u to compute bootstrap error. A postive integer between 1 and p. This argument is relevant only when <code>bstrpNum</code>&gt;0.</p>
</td></tr>
<tr><td><code id="weighted.env_+3A_boot.resi">boot.resi</code></td>
<td>
<p>A string that can be &quot;full&quot; or &quot;weighted&quot; indicating the model from which the residuals are calculated.  If the input is &quot;full&quot;, then the residuals are obtained using the standard estimators; and if the input is &quot;weighted&quot;, then the residuals are obtained using the weighted envelope estimators.  This argument is for computing residuals in residual bootstrap, and it is relevant only when <code>bstrpNum</code>&gt;0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the weighted envelope estimator in a standard multivariate linear regression.  And the weighted envelope estimator takes the form </p>
<p style="text-align: center;"><code class="reqn">
 \hat{\beta}_{w}=\sum_{j=1}^{r}w_{j}\hat{\beta}_{j},
 </code>
</p>

<p>where <code class="reqn">\hat{\beta}_{j}</code> is the envelope estimator of <code class="reqn">\beta</code> with <code class="reqn">u=j</code> and <code class="reqn">w_{j}</code>'s are the weights computed from BIC values
</p>
<p style="text-align: center;"><code class="reqn">
w_{j}=\frac{\exp(-b_{j})}{\sum_{k=1}^{r}\exp(-b_{k})},
</code>
</p>

<p>where <code class="reqn">b_{j}</code> is the BIC criterion evaluated at the envelope estimator <code class="reqn">\hat{\beta}_{j}</code>.  For details, see Eck and Cook (2017).
</p>
<p>The variation of the weighted envelope estimator is estimated by residual bootstrap.  The user can specify the range for bootstrap <code class="reqn">u=</code>(<code>min.u</code>, <code>max.u</code>), if the weights outside of the range are small.
</p>


<h3>Value</h3>

<p>The output is a list that contains the following components:
</p>
<table>
<tr><td><code>beta</code></td>
<td>
<p>The weighted envelope estimator of the regression coefficients.</p>
</td></tr> 
<tr><td><code>mu</code></td>
<td>
<p>The weighted estimated intercept.</p>
</td></tr>
<tr><td><code>Sigma</code></td>
<td>
<p>The weighted envelope estimator of the error covariance matrix.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>Weights computed based on BIC.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The log likelihood function computed with weighted envelope estimator.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of observations in the data.</p>
</td></tr>
<tr><td><code>bootse</code></td>
<td>
<p>The standard error for elements in beta computed by residual bootstrap.  This output is available only when <code>bstrpNum</code>&gt;0.</p>
</td></tr>
<tr><td><code>ratios</code></td>
<td>
<p>The boostrap standard error ratio of the standard multivariate linear regression estimator over the weighted envelope estimator for each element in beta.  This output is available only when <code>bstrpNum</code>&gt;0.</p>
</td></tr>
<tr><td><code>bic_select</code></td>
<td>
<p>A table that lists how many times BIC selected each candidate dimension.  If BIC never selects a dimension, this dimension does not appear on the table.  This output is available only when <code>bstrpNum</code>&gt;0.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Eck, D. J. and Cook, R. D. (2017). Weighted Envelope Estimation to Handle Variability in Model
Selection. Biometrika. To appear.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wheatprotein)
X &lt;- wheatprotein[, 8]
Y &lt;- wheatprotein[, 1:6]
m &lt;- weighted.env(X, Y)
m$w
m$beta

## Not run: m2 &lt;- weighted.env(X, Y, bstrpNum = 100, min.u = 1, max.u = 6, boot.resi = "full")
## Not run: m2$bic_select
## Not run: m2$bootse
</code></pre>

<hr>
<h2 id='weighted.penv'>Weighted partial envelope estimator</h2><span id='topic+weighted.penv'></span>

<h3>Description</h3>

<p>Compute the weighted partial envelope estimator with weights computed from BIC. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted.penv(X1, X2, Y, bstrpNum = 0, min.u = 1, 
max.u = ncol(as.matrix(Y)), boot.resi = "full")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted.penv_+3A_x1">X1</code></td>
<td>
<p>Predictors of main interest. An n by p1 matrix, n is the number of observations, and p1 is the number of main predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="weighted.penv_+3A_x2">X2</code></td>
<td>
<p>Covariates, or predictors not of main interest.  An n by p2 matrix, p2 is the number of covariates.</p>
</td></tr>
<tr><td><code id="weighted.penv_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="weighted.penv_+3A_bstrpnum">bstrpNum</code></td>
<td>
<p>Number of bootstrap samples. A positive integer.</p>
</td></tr>
<tr><td><code id="weighted.penv_+3A_min.u">min.u</code></td>
<td>
<p>Lower bound of the range of u to compute bootstrap error. A postive integer between 1 and p. This argument is relevant only when <code>bstrpNum</code>&gt;0.</p>
</td></tr>
<tr><td><code id="weighted.penv_+3A_max.u">max.u</code></td>
<td>
<p>Upper bound of the range of u to compute bootstrap error. A postive integer between 1 and p. This argument is relevant only when <code>bstrpNum</code>&gt;0.</p>
</td></tr>
<tr><td><code id="weighted.penv_+3A_boot.resi">boot.resi</code></td>
<td>
<p>A string that can be &quot;full&quot; or &quot;weighted&quot; indicating the model from which the residuals are calculated.  If the input is &quot;full&quot;, then the residuals are obtained using the standard estimators; and if the input is &quot;weighted&quot;, then the residuals are obtained using the weighted envelope estimators.  This argument is for computing residuals in residual bootstrap, and it is relevant only when <code>bstrpNum</code>&gt;0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the weighted partial envelope estimator in a standard multivariate linear regression.  And the weighted partial envelope estimator takes the form </p>
<p style="text-align: center;"><code class="reqn">
 \hat{\beta}_{w}=\sum_{j=1}^{r}w_{j}\hat{\beta}_{j},
 </code>
</p>

<p>where <code class="reqn">\hat{\beta}_{j}</code> is the partial envelope estimator of <code class="reqn">\beta</code> with <code class="reqn">u=j</code> and <code class="reqn">w_{j}</code>'s are the weights computed from BIC values
</p>
<p style="text-align: center;"><code class="reqn">
w_{j}=\frac{\exp(-b_{j})}{\sum_{k=1}^{r}\exp(-b_{k})},
</code>
</p>

<p>where <code class="reqn">b_{j}</code> is the BIC criterion evaluated at the partial envelope estimator <code class="reqn">\hat{\beta}_{j}</code>.  For details, see Eck and Cook (2017).
</p>
<p>The variation of the weighted partial envelope estimator is estimated by residual bootstrap.  The user can specify the range for bootstrap <code class="reqn">u=</code>(<code>min.u</code>, <code>max.u</code>), if the weights outside of the range are small.
</p>


<h3>Value</h3>

<p>The output is a list that contains the following components:
</p>
<table>
<tr><td><code>beta</code></td>
<td>
<p>The weighted partial envelope estimator of the regression coefficients.</p>
</td></tr> 
<tr><td><code>mu</code></td>
<td>
<p>The weighted estimated intercept.</p>
</td></tr>
<tr><td><code>Sigma</code></td>
<td>
<p>The weighted partial envelope estimator of the error covariance matrix.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>Weights computed based on BIC.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The log likelihood function computed with weighted partial envelope estimator.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of observations in the data.</p>
</td></tr>
<tr><td><code>bootse</code></td>
<td>
<p>The standard error for elements in beta1 computed by residual bootstrap.  This output is available only when <code>bstrpNum</code>&gt;0.</p>
</td></tr>
<tr><td><code>ratios</code></td>
<td>
<p>The boostrap standard error ratio of the standard multivariate linear regression estimator over the weighted partial envelope estimator for each element in beta1.  This output is available only when <code>bstrpNum</code>&gt;0.</p>
</td></tr>
<tr><td><code>bic_select</code></td>
<td>
<p>A table that lists how many times BIC selected each candidate dimension.  If BIC never selects a dimension, this dimension does not appear on the table.  This output is available only when <code>bstrpNum</code>&gt;0.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Eck, D. J. and Cook, R. D. (2017). Weighted Envelope Estimation to Handle Variability in Model
Selection. Biometrika. To appear.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fiberpaper)
X1 &lt;- fiberpaper[, 7]
X2 &lt;- fiberpaper[, 5:6]
Y &lt;- fiberpaper[, 1:4]
m &lt;- weighted.penv(X1, X2, Y)
m$w
m$beta1

m2 &lt;- penv(X1, X2, Y, 2)
m2$beta1


## Not run: m3 &lt;- weighted.penv(X1, X2, Y, bstrpNum = 100, boot.resi = "full")
## Not run: m3$w
## Not run: m3$bic_select
## Not run: m3$bootse

## Not run: boot.penv(X1, X2, Y, 2, 100)

</code></pre>

<hr>
<h2 id='weighted.pred.env'>Estimation or prediction using weighted partial envelope</h2><span id='topic+weighted.pred.env'></span>

<h3>Description</h3>

<p>Perform estimation or prediction through weighted partial envelope model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted.pred.env(X, Y, Xnew)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted.pred.env_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.</p>
</td></tr>
<tr><td><code id="weighted.pred.env_+3A_y">Y</code></td>
<td>
<p>Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must be continuous variables.</p>
</td></tr>
<tr><td><code id="weighted.pred.env_+3A_xnew">Xnew</code></td>
<td>
<p>The value of X with which to estimate or predict Y.  A p dimensional vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates the envelope model at new value Xnew.  It can perform estimation: find the fitted value when X = Xnew, or prediction: predict Y when X = Xnew.  But it does not provide the estimation or prediction error.  This function performs prediction using the same procedure as in pred2.env, except that the partial envelope estimator with dimension u is replaced by a weighted partial envelope estimator.  The weights are decided based on BIC values.  
</p>


<h3>Value</h3>

<table>
<tr><td><code>value</code></td>
<td>
<p>The fitted value or the predicted value evaluated at Xnew.</p>
</td></tr> 
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(fiberpaper)
X &lt;- fiberpaper[, 5:7]
Y &lt;- fiberpaper[, 1:4]

## Not run: pred.res &lt;- weighted.pred.env(X, Y, X[10, ])

</code></pre>

<hr>
<h2 id='weighted.xenv'>Weighted predictor envelope estimator</h2><span id='topic+weighted.xenv'></span>

<h3>Description</h3>

<p>Compute the weighted predictor envelope estimator with weights computed from BIC. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted.xenv(X, Y, bstrpNum = 0, min.u = 1, 
max.u = ncol(as.matrix(X)), boot.resi = "full")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted.xenv_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors and n is number of observations.  The predictors must be continuous variables.</p>
</td></tr>
<tr><td><code id="weighted.xenv_+3A_y">Y</code></td>
<td>
<p>Responses. An n by r matrix, r is the number of responses. The response can be univariate or multivariate and must be continuous variable.</p>
</td></tr>
<tr><td><code id="weighted.xenv_+3A_bstrpnum">bstrpNum</code></td>
<td>
<p>Number of bootstrap samples. A positive integer.</p>
</td></tr>
<tr><td><code id="weighted.xenv_+3A_min.u">min.u</code></td>
<td>
<p>Lower bound of the range of u to compute bootstrap error. A postive integer between 1 and p. This argument is relevant only when <code>bstrpNum</code>&gt;0.</p>
</td></tr>
<tr><td><code id="weighted.xenv_+3A_max.u">max.u</code></td>
<td>
<p>Upper bound of the range of u to compute bootstrap error. A postive integer between 1 and p. This argument is relevant only when <code>bstrpNum</code>&gt;0.</p>
</td></tr>
<tr><td><code id="weighted.xenv_+3A_boot.resi">boot.resi</code></td>
<td>
<p>A string that can be &quot;full&quot; or &quot;weighted&quot; indicating the model from which the residuals are calculated.  If the input is &quot;full&quot;, then the residuals are obtained using the standard estimators; and if the input is &quot;weighted&quot;, then the residuals are obtained using the weighted predictor envelope estimators.  This argument is for computing residuals in residual bootstrap, and it is relevant only when <code>bstrpNum</code>&gt;0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the weighted predictor envelope estimator in a standard multivariate linear regression.  And the weighted predictor envelope estimator takes the form </p>
<p style="text-align: center;"><code class="reqn">
 \hat{\beta}_{w}=\sum_{j=1}^{p}w_{j}\hat{\beta}_{j},
 </code>
</p>

<p>where <code class="reqn">\hat{\beta}_{j}</code> is the predictor envelope estimator of <code class="reqn">\beta</code> with <code class="reqn">u=j</code> and <code class="reqn">w_{j}</code>'s are the weights computed from BIC values
</p>
<p style="text-align: center;"><code class="reqn">
w_{j}=\frac{\exp(-b_{j})}{\sum_{k=1}^{p}\exp(-b_{k})},
</code>
</p>

<p>where <code class="reqn">b_{j}</code> is the BIC criterion evaluated at the predictor envelope estimator <code class="reqn">\hat{\beta}_{j}</code>.  For details, see Eck and Cook (2017).
</p>
<p>The variation of the weighted predictor envelope estimator is estimated by residual bootstrap.  The user can specify the range for bootstrap <code class="reqn">u=</code>(<code>min.u</code>, <code>max.u</code>), if the weights outside of the range are small.
</p>


<h3>Value</h3>

<p>The output is a list that contains the following components:
</p>
<table>
<tr><td><code>beta</code></td>
<td>
<p>The weighted predictor envelope estimator of the regression coefficients.</p>
</td></tr> 
<tr><td><code>mu</code></td>
<td>
<p>The weighted estimated intercept.</p>
</td></tr>
<tr><td><code>SigmaX</code></td>
<td>
<p>The weighted predictor envelope estimator of the covariance matrix of X.</p>
</td></tr>
<tr><td><code>SigmaYcX</code></td>
<td>
<p>The weighted predictor envelope estimator of the error covariance matrix.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>Weights computed based on BIC.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The log likelihood function computed with weighted predictor envelope estimator.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of observations in the data.</p>
</td></tr>
<tr><td><code>bootse</code></td>
<td>
<p>The standard error for elements in beta computed by residual bootstrap.  This output is available only when <code>bstrpNum</code>&gt;0.</p>
</td></tr>
<tr><td><code>ratios</code></td>
<td>
<p>The boostrap standard error ratio of the standard multivariate linear regression estimator over the weighted predictor envelope estimator for each element in beta.  This output is available only when <code>bstrpNum</code>&gt;0.</p>
</td></tr>
<tr><td><code>bic_select</code></td>
<td>
<p>A table that lists how many times BIC selected each candidate dimension.  If BIC never selects a dimension, this dimension does not appear on the table.  This output is available only when <code>bstrpNum</code>&gt;0.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Eck, D. J. and Cook, R. D. (2017). Weighted Envelope Estimation to Handle Variability in Model
Selection. Biometrika. To appear.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wheatprotein)
X &lt;- wheatprotein[, 1:6]
Y &lt;- wheatprotein[, 7]
m &lt;- weighted.xenv(X, Y)
m$w
m$beta

## Not run: m2 &lt;- weighted.xenv(X, Y, bstrpNum = 100, min.u = 2, max.u = 4, boot.resi = "full")
## Not run: m2$w
## Not run: m2$bootse
</code></pre>

<hr>
<h2 id='wheatprotein'>Wheat Protein Data</h2><span id='topic+wheatprotein'></span>

<h3>Description</h3>

<p>The protein content of ground wheat samples.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wheatprotein)</code></pre>


<h3>Format</h3>

<p>A data frame with 50 observations on the following 8 variables.
</p>

<dl>
<dt><code>V1</code></dt><dd><p>Measurements of the reflectance of NIR radiation by the wheat samples at 1680nm.  The measurements were made on the log(1/reflectance) scale.</p>
</dd>
<dt><code>V2</code></dt><dd><p>Measurements of the reflectance of NIR radiation by the wheat samples at 1806nm.</p>
</dd>
<dt><code>V3</code></dt><dd><p>Measurements of the reflectance of NIR radiation by the wheat samples at 1932nm.</p>
</dd>
<dt><code>V4</code></dt><dd><p>Measurements of the reflectance of NIR radiation by the wheat samples at 2058nm.</p>
</dd>
<dt><code>V5</code></dt><dd><p>Measurements of the reflectance of NIR radiation by the wheat samples at 2184nm.</p>
</dd>
<dt><code>V6</code></dt><dd><p>Measurements of the reflectance of NIR radiation by the wheat samples at 2310nm.</p>
</dd>
<dt><code>V7</code></dt><dd><p>The protein content of each sample (in percent).</p>
</dd>
<dt><code>V8</code></dt><dd><p>Binary indicator, 0 for high protein content and 1 for low protein content. The cut off point is if the protein content is smaller than 9.75.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data are the result of an experiment to calibrate a near
infrared reflectance (NIR) instrument for measuring the protein
content of ground wheat samples. The protein content of each
sample (in percent) was measured by the standard Kjeldahl method.
In Fearn (1983), the problem is to find a linear combination of
the measurements that predicts protein content. The estimated
coefficients can then be entered into the instrument allowing the
protein content of future samples to be read directly. The first
24 cases were used for calibration and the last 26 samples were
used for prediction.
</p>


<h3>References</h3>

<p>Fearn, T. (1983). A misuse of ridge regression in the calibration
of a near infrared reflectance instrument.
</p>

<hr>
<h2 id='xenv'>Fit the predictor envelope model</h2><span id='topic+xenv'></span>

<h3>Description</h3>

<p>Fit the predictor envelope model in linear regression with dimension u. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xenv(X, Y, u, asy = TRUE, init = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xenv_+3A_x">X</code></td>
<td>
<p>Predictors. An n by p matrix, p is the number of predictors and n is number of observations.  The predictors must be continuous variables.</p>
</td></tr>
<tr><td><code id="xenv_+3A_y">Y</code></td>
<td>
<p>Responses. An n by r matrix, r is the number of responses. The response can be univariate or multivariate and must be continuous variable.</p>
</td></tr>
<tr><td><code id="xenv_+3A_u">u</code></td>
<td>
<p>Dimension of the envelope. An integer between 0 and p.</p>
</td></tr>
<tr><td><code id="xenv_+3A_asy">asy</code></td>
<td>
<p>Flag for computing the asymptotic variance of the envelope estimator.  The default is <code>TRUE</code>. When p and r are large, computing the asymptotic variance can take much time and memory.  If only the envelope estimators are needed, the flag can be set to <code>asy = FALSE</code>.</p>
</td></tr>
<tr><td><code id="xenv_+3A_init">init</code></td>
<td>
<p>The user-specified value of Gamma for the envelope subspace in the predictor space. An p by u matrix. The default is the one generated by function envMU.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits the envelope model in the predictor space, </p>
<p style="text-align: center;"><code class="reqn">
 Y = \mu + \eta'\Omega^{-1}\Gamma' X +\varepsilon, \Sigma_{X}=\Gamma\Omega\Gamma'+\Gamma_{0}\Omega_{0}\Gamma'_{0}
</code>
</p>

<p>using the maximum likelihood estimation.  When the dimension of the envelope is between 1 and p-1, the starting value and blockwise coordinate descent algorithm in Cook et al. (2016) is implemented.  When the dimension is p, then the envelope model degenerates to the standard multivariate linear regression.  When the dimension is 0, it means that X and Y are uncorrelated, and the fitting is different.
</p>


<h3>Value</h3>

<p>The output is a list that contains the following components:
</p>
<table>
<tr><td><code>beta</code></td>
<td>
<p>The envelope estimator of the regression coefficients.</p>
</td></tr> 
<tr><td><code>SigmaX</code></td>
<td>
<p>The envelope estimator of the covariance matrix of X.</p>
</td></tr>
<tr><td><code>Gamma</code></td>
<td>
<p>An orthonormal basis of the envelope subspace.</p>
</td></tr>
<tr><td><code>Gamma0</code></td>
<td>
<p>An orthonormal basis of the complement of the envelope subspace.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>The estimated eta.  According to the envelope parameterization, beta = Gamma * Omega^-1 * eta.</p>
</td></tr>
<tr><td><code>Omega</code></td>
<td>
<p>The coordinates of SigmaX with respect to Gamma.</p>
</td></tr>
<tr><td><code>Omega0</code></td>
<td>
<p>The coordinates of SigmaX with respect to Gamma0.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>The estimated intercept.</p>
</td></tr>
<tr><td><code>SigmaYcX</code></td>
<td>
<p>The estimated conditional covariance matrix of Y given X.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The maximized log likelihood function.</p>
</td></tr>
<tr><td><code>covMatrix</code></td>
<td>
<p>The asymptotic covariance of vec(beta). The covariance matrix returned are asymptotic.  For the actual standard errors, multiply by 1 / n.</p>
</td></tr>
<tr><td><code>asySE</code></td>
<td>
<p>The asymptotic standard error for elements in beta under the envelope model.  The standard errors returned are asymptotic, for actual standard errors, multiply by 1 / sqrt(n).</p>
</td></tr>
<tr><td><code>ratio</code></td>
<td>
<p>The asymptotic standard error ratio of the standard multivariate linear regression estimator over the envelope estimator, for each element in beta.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of observations in the data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cook, R. D., Helland, I. S. and Su, Z. (2013). Envelopes and Partial Least Squares Re-
gression. Journal of the Royal Statistical Society: Series B 75, 851 - 877.
</p>
<p>Cook, R. D., Forzani, L. and Su, Z. (2016) A Note on Fast Envelope Estimation. Journal of Multivariate Analysis. 150, 42-54.
</p>


<h3>See Also</h3>

<p><code><a href="pls.html#topic+simpls.fit">simpls.fit</a></code> for partial least squares (PLS).	
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Fit the envelope in the predictor space	
data(wheatprotein)
X &lt;- wheatprotein[, 1:6]
Y &lt;- wheatprotein[, 7]
u &lt;- u.xenv(X, Y)
u

m &lt;- xenv(X, Y, 4)
m
m$beta

## Fit the partial least squares
## Not run: m1 &lt;- pls::simpls.fit(X, Y, 4)
## Not run: m1$coefficients
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
