<!DOCTYPE html><html><head><title>Help for package recmap</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {recmap}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.draw_recmap_us_state_ev'><p>this function reproduces the original election cartogram from 2004 using</p>
the cartogram output from the 2003 implementation.</a></li>
<li><a href='#.get_7triangles'><p>construct polygon mesh displayed in Figure 4a in</p></a></li>
<li><a href='#as.recmap.SpatialPolygonsDataFrame'><p>Convert a SpatialPolygonsDataFrame Object to recmap Object</p></a></li>
<li><a href='#as.SpatialPolygonsDataFrame.recmap'><p>Convert a recmap Object to SpatialPolygonsDataFrame Object.</p></a></li>
<li><a href='#checkerboard'>
<p>Create a Checkboard</p></a></li>
<li><a href='#is.recmap'><p>Is an Object from a Class recmap?</p></a></li>
<li><a href='#jss2711'>
<p>jss2711 data</p></a></li>
<li><a href='#plot.recmap'><p>Plot a recmap object.</p></a></li>
<li><a href='#recmap'><p>Compute a Rectangular Statistical Cartogram</p></a></li>
<li><a href='#recmapGA'><p>Genetic Algorithm Wrapper Function for recmap</p></a></li>
<li><a href='#recmapGRASP'>
<p>Greedy Randomized Adaptive Search Procedure Wrapper Function for recmap</p></a></li>
<li><a href='#summary.recmap'><p>Summary for recmap object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Compute the Rectangular Statistical Cartogram</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.17</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christian Panse &lt;Christian.Panse@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the RecMap MP2 construction heuristic
  &lt;<a href="https://doi.org/10.1109%2FINFVIS.2004.57">doi:10.1109/INFVIS.2004.57</a>&gt;.
  This algorithm draws maps according to a given statistical
  value, e.g., election results, population, or epidemiological data.
  The basic idea of the RecMap algorithm is that each map region,
  e.g., different countries, is represented by a rectangle.
  The area of each rectangle represents the statistical value given
  as input (maintain zero cartographic error).
  C++ is used to implement the computationally intensive tasks.
  The vignette included in this package provides documentation
  about the usage of the recmap algorithm.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.3), GA (&ge; 3.1), Rcpp (&ge; 1.0), sp(&ge; 1.3)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>doParallel, knitr, rmarkdown, shiny, testthat, tufte</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 1.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/cpanse/recmap/issues">https://github.com/cpanse/recmap/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-23 11:32:49 UTC; cpanse</td>
</tr>
<tr>
<td>Author:</td>
<td>Christian Panse <a href="https://orcid.org/0000-0003-1975-3064"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-23 22:40:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='.draw_recmap_us_state_ev'>this function reproduces the original election cartogram from 2004 using 
the cartogram output from the 2003 implementation.</h2><span id='topic+.draw_recmap_us_state_ev'></span>

<h3>Description</h3>

<p>this function reproduces the original election cartogram from 2004 using 
the cartogram output from the 2003 implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.draw_recmap_us_state_ev(plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".draw_recmap_us_state_ev_+3A_plot">plot</code></td>
<td>
<p>default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the plot
</p>

<hr>
<h2 id='.get_7triangles'>construct polygon mesh displayed in Figure 4a in</h2><span id='topic+.get_7triangles'></span>

<h3>Description</h3>

<p>construct polygon mesh displayed in Figure 4a in
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.get_7triangles(A = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".get_7triangles_+3A_a">A</code></td>
<td>
<p>defines the area of a region in the center</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a> object
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.1109/TVCG.2004.1260761">doi:10.1109/TVCG.2004.1260761</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>triangle.map &lt;- recmap:::.get_7triangles()
z &lt;- c(rep(4, 4), rep(1, 3))
cols &lt;- c(rep('white', 4), rep('grey',3))

op &lt;- par(mfrow=c(1,2), mar=c(0, 0, 0, 0))
plot(triangle.map, col=cols)

## Not run: 
 # requires libfft.so installed in linux 
if (require(getcartr) &amp; require(Rcartogram)){
  cartogram &lt;- quick.carto(triangle.map, z, res=64)
  plot(cartogram, col=cols)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='as.recmap.SpatialPolygonsDataFrame'>Convert a SpatialPolygonsDataFrame Object to recmap Object</h2><span id='topic+as.recmap.SpatialPolygonsDataFrame'></span><span id='topic+as.recmap'></span>

<h3>Description</h3>

<p>The method generates a recmap class out of a <code><a href="sp.html#topic+SpatialPolygonsDataFrame">SpatialPolygonsDataFrame</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatialPolygonsDataFrame'
as.recmap(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.recmap.SpatialPolygonsDataFrame_+3A_x">X</code></td>
<td>
<p><code><a href="sp.html#topic+SpatialPolygonsDataFrame">SpatialPolygonsDataFrame</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a <code><a href="#topic+recmap">recmap</a></code> object.
</p>


<h3>References</h3>

<p>Roger S. Bivand, Edzer Pebesma, Virgilio Gomez-Rubio, 2013.
Applied spatial data analysis with R, Second edition. Springer, NY.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SpDf &lt;- as.SpatialPolygonsDataFrame(recmap(checkerboard(8)))
summary(SpDf)
spplot(SpDf)
summary(as.recmap(SpDf))

</code></pre>

<hr>
<h2 id='as.SpatialPolygonsDataFrame.recmap'>Convert a recmap Object to SpatialPolygonsDataFrame Object.</h2><span id='topic+as.SpatialPolygonsDataFrame.recmap'></span><span id='topic+as.SpatialPolygonsDataFrame'></span>

<h3>Description</h3>

<p>The method generates a SpatialPolygons object of a as input given
<code><a href="#topic+recmap">recmap</a></code> object. Both <code>data.frame</code>s are merged by the index order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'recmap'
as.SpatialPolygonsDataFrame(x, df = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.SpatialPolygonsDataFrame.recmap_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+recmap">recmap</a></code> object.</p>
</td></tr>
<tr><td><code id="as.SpatialPolygonsDataFrame.recmap_+3A_df">df</code></td>
<td>
<p>a <code>data.frame</code> object. default is NULL.</p>
</td></tr>
<tr><td><code id="as.SpatialPolygonsDataFrame.recmap_+3A_...">...</code></td>
<td>
<p>...</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>SpDf &lt;- as.SpatialPolygonsDataFrame(recmap(checkerboard(8)))
summary(SpDf)
spplot(SpDf)

</code></pre>

<hr>
<h2 id='checkerboard'>
Create a Checkboard
</h2><span id='topic+checkerboard'></span>

<h3>Description</h3>

<p>This function generates a <code><a href="#topic+recmap">recmap</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkerboard(n = 8, ratio = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkerboard_+3A_n">n</code></td>
<td>
<p>defines the size of the map. default is 8 which will generate a map 
having 64 regions.</p>
</td></tr>
<tr><td><code id="checkerboard_+3A_ratio">ratio</code></td>
<td>
<p>defines the ratio of the statistical value. As default, the 
black regions have a value which is four times higher.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a checkerboard as <code><a href="#topic+recmap">recmap</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Christian Panse
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+recmap">recmap</a></code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
checkerboard8x8 &lt;- checkerboard(8)

plot(checkerboard8x8, 
  col=c('white','white','white','black')[checkerboard8x8$z])

</code></pre>

<hr>
<h2 id='is.recmap'>Is an Object from a Class recmap?</h2><span id='topic+is.recmap'></span>

<h3>Description</h3>

<p>Is an Object from a Class recmap?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.recmap(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.recmap_+3A_object">object</code></td>
<td>
<p>any <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
</table>

<hr>
<h2 id='jss2711'>
jss2711 data
</h2><span id='topic+jss2711'></span><span id='topic+SBB'></span><span id='topic+Switzerland'></span><span id='topic+UK'></span><span id='topic+cmp_GA_GRASP'></span><span id='topic+mbb_check'></span>

<h3>Description</h3>

<p>jss2711 contains the replication materials (input and output) for the 
<a href="https://doi.org/10.18637/jss.v086.c01">doi:10.18637/jss.v086.c01</a> manuscript's
Figures 4, 5, 6, 7, 11, 12, and 13.
</p>


<h3>Format</h3>

<p>A set of nested <code>list</code> of <code>data.frames</code>.
</p>


<h3>Author(s)</h3>

<p>Christian Panse, 2018
</p>


<h3>Source</h3>


<ul>
<li><p>Figure 4 &ndash; <code>mbb_check</code> contains a <code>data.frame</code> with some
<code>recmap</code> implemention benchmarks. Generated on
</p>

<ul>
<li> <p>MacBook Pro (15-inch, 2017).
</p>
</li>
<li> <p>Processor: 2.9 GHz Intel Core i7
</p>
</li>
<li> <p>Memory: 16 GB 2133 MHz LPDDR3
</p>
</li></ul>


</li>
<li><p>Figure 5 &ndash; <code>cmp_GA_GRASP</code> contains a <code>list</code> of results using 
a <code><a href="#topic+recmapGA">GRASP</a></code> and <code><a href="GA.html#topic+ga">GA</a></code> metaheuristic.
Generated on a MacBook Pro (Retina, 13-inch, Mid 2014).
</p>
</li>
<li><p>Figure 11 &ndash; <code>Switzerland</code>:
</p>

<ul>
<li> <p>input map rectangles derived from:
Swiss Federal Office of Topography <a href="https://www.swisstopo.admin.ch">https://www.swisstopo.admin.ch</a> using Landscape Models / Boundaries GG25,
downloaded 2016-05-01; Perfomed on a Intel(R) Xeon(R) CPU E5-2698 v3 @ 2.30GHz/ Debian8
</p>
</li>
<li><p>statistical data: Bundesamt fur Statistik (BFS) <a href="https://www.bfs.admin.ch">https://www.bfs.admin.ch</a>,
Website Statistik Schweiz, downloaded file <code>je-d-21.03.01.xls</code> on 2016-05-26., 
</p>
</li>
<li><p>Perfomed on a Intel(R) Xeon(R) CPU E5-2698 v3 @ 2.30GHz/ Debian8.
</p>
</li></ul>

</li>
<li><p>Figure 12 &ndash; <code>SBB</code>: 
</p>

<ul>
<li> <p>Source: <a href="https://data.sbb.ch/explore/?sort=explore.download_count&amp;refine.modified=2016">https://data.sbb.ch/explore</a> 2016-05-12.
</p>
</li>
<li><p>Perfomed on a Intel(R) Xeon(R) CPU E5-2698 v3 @ 2.30GHz/ Debian 8.
</p>
</li></ul>

</li>
<li><p>Figure 13 &ndash; <code>UK</code>:
</p>

<ul>
<li> <p>input map rectangles derived from: <code>https://census.edina.ac.uk/ukborders</code>;
Contains OS data Crown copyright [and database right] (2016);
</p>
</li>
<li> <p>Source of election data: <a href="https://www.nisra.gov.uk">NISRA</a>
</p>
</li>
<li> <p>copyright - Contains National Statistics data Crown copyright and database right 2016
Contains NRS data Crown copyright and database right 2016
</p>
</li>
<li> <p>Perfomed on a Intel(R) Xeon(R) CPU E5-2698 v3 @ 2.30GHz/ Debian8
</p>
</li></ul>
</li></ul>



<h3>References</h3>

<p>Panse C (2018). &quot;Rectangular Statistical Cartograms in R: The recmap
Package.&quot; Journal of Statistical Software, Code Snippets, 86(1),
pp. 1-27. <a href="https://doi.org/10.18637/jss.v086.c01">doi:10.18637/jss.v086.c01</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>options(warn = -1)

## Figure 4 
jss2711_figure4 &lt;- function(nrep = 1, size = 2:10){
  recmap_debug_code &lt;- '
  // [[Rcpp::plugins(cpp11)]]
  
  #include &lt;Rcpp.h&gt;
  #include &lt;string&gt;
  #include &lt;recmap.h&gt;
  
  using namespace Rcpp;

  // [[Rcpp::depends(recmap)]]
  // [[Rcpp::export]]
  int recmap_debug(DataFrame df,
    bool map_region_intersect_multiset = true) {
    // access the columns
    NumericVector x = df["x"];
    NumericVector y = df["y"];
    NumericVector dx = df["dx"];
    NumericVector dy = df["dy"];
    
    
    NumericVector z = df["z"];
    CharacterVector name = df["name"];
    
    NumericVector cartogram_x(x.size());
    NumericVector cartogram_y(x.size());
    NumericVector cartogram_dx(x.size());
    NumericVector cartogram_dy(x.size());
    
    NumericVector dfs_num(x.size());
    NumericVector topology_error(x.size());
    NumericVector relpos_error(x.size());
    NumericVector relpos_nh_error(x.size());
   
    crecmap::RecMap X;
    X.set_map_region_intersect_multiset(map_region_intersect_multiset);
    
    for (int i = 0; i &lt; x.size(); i++) {
      std::string sname = Rcpp::as&lt;std::string&gt;(name[i]);
      X.push_region(x[i], y[i], dx[i], dy[i], z[i],  sname);
    }
    
    X.run(true);
    
    return(X.get_intersect_count());
  }
  '
  
  sourceCpp(code = recmap_debug_code, rebuild = TRUE, verbose = TRUE)
  
  do.call('rbind', lapply(size, function(size){
    set.seed(1);
    CB &lt;- checkerboard(size); 

    do.call('rbind',lapply(rep(size, nrep), function(n){

      CB.smp &lt;- CB[sample(nrow(CB), nrow(CB)), ]
      start_time &lt;- Sys.time()
      ncall.multiset &lt;- recmap_debug(CB.smp,
         map_region_intersect_multiset = TRUE)

      end_time &lt;- Sys.time()

      diff_time.multiset &lt;- as.numeric(difftime(end_time,
        start_time, units = "secs"))


      start_time &lt;- Sys.time()
      ncall.list &lt;- recmap_debug(CB.smp,
        map_region_intersect_multiset = FALSE)
      end_time &lt;- Sys.time()
      diff_time.list &lt;- as.numeric(difftime(end_time,
        start_time, units = "secs"))

      rv &lt;- rbind(data.frame(number = ncall.multiset,
        algorithm="multiset", size = nrow(CB),
	  time_in_secs = diff_time.multiset),
        data.frame(number = ncall.list,
	  algorithm="list", size = nrow(CB),
	    time_in_secs =  diff_time.list))

      rv$machine &lt;- Sys.info()['machine']
      rv$sysname &lt;- Sys.info()['sysname']
      rv
      }))
    }))
}

## Not run: 
	mbb_check &lt;- jss2711_figure4()

## End(Not run)

data(jss2711)
boxplot(number  ~ sqrt(size),
  axes=FALSE,
  data = mbb_check,
  log='y', 
  cex = 0.75,
  subset = algorithm == "list", 
  col = "red", boxwex = 0.25); 
abline(v = sqrt(50), col = 'lightgray', lwd = 3)

boxplot(number  ~ sqrt(size), 
  data = mbb_check,log='y',
  subset = algorithm == "multiset",
  cex = 0.75,
  ylab = 'number of MBB intersection calls',
  xlab = 'number of map regions',
  boxwex = 0.25, add = TRUE, axes=FALSE); 
axis(2)
axis(1, c(5, sqrt(50), 10, 15, 20), c("5x5", "US", "10x10", "15x15", "20x20"))
box()

legend("bottomright", c("C++ STL list", "C++ STL multiset"),
      col=c('red', 'black'), pch = 16, cex = 1.0)



## Figure 5

op &lt;- par(mar=c(0, 0, 0, 0), mfrow=c(1, 3), bg = 'azure')

plot(cmp_GA_GRASP$GRASP$Map,
     border='black',
     col=c('white', 'white', 'white', 'black')[cmp_GA_GRASP$GRASP$Map$z])

plot(cmp_GA_GRASP$GRASP$Cartogram,
     border='black',
     col = c('white', 'white', 'white', 'black')[cmp_GA_GRASP$GRASP$Cartogram$z])

plot(cmp_GA_GRASP$GA$Cartogram,
     border='black',
     col = c('white', 'white', 'white', 'black')[cmp_GA_GRASP$GA$Cartogram$z])
par(op)

## Figure 6 - right

op &lt;- par(mar = c(0, 0, 0, 0), mfrow=c(1, 1), bg = 'azure')
# found by the GA
smp &lt;- cmp_GA_GRASP$GA$GA@solution[1,]

Cartogram.Checkerboard &lt;- recmap(cmp_GA_GRASP$GA$Map[smp, ])
idx &lt;- order(Cartogram.Checkerboard$dfs.num)

plot(Cartogram.Checkerboard,
     border='black',
     col=c('white', 'white', 'white', 'black')[Cartogram.Checkerboard$z])

# draw placement order
lines(Cartogram.Checkerboard$x[idx],
  Cartogram.Checkerboard$y[idx],
  col = rgb(1,0,0, alpha=0.3), lwd = 4, cex=0.5)

text(Cartogram.Checkerboard$x[idx],
  Cartogram.Checkerboard$y[idx],
  1:length(idx), pos=1, col=rgb(1,0,0, alpha=0.7))

points(Cartogram.Checkerboard$x[idx[1]],
  Cartogram.Checkerboard$y[idx[1]], lwd = 5, col = 'red')
text(Cartogram.Checkerboard$x[idx[1]],
  Cartogram.Checkerboard$y[idx[1]], "start", col = 'red', pos=3)
points(Cartogram.Checkerboard$x[idx[length(idx)]],
  Cartogram.Checkerboard$y[idx[length(idx)]],
       cex = 1.25, lwd = 2, col = 'red', pch = 5)
par(op)
op &lt;- par(mar = c(4, 4, 1.5, 0.5), mfrow = c(1, 1), bg = 'white')
plot(best ~ elapsedtime, data = cmp_GA_GRASP$cmp,
     type = 'n',
     ylab = 'best fitness value',
     xlab = 'elapsed time [in seconds]')
abline(v=60, col='lightgrey',lwd=2)
lines(cmp_GA_GRASP$cmp[cmp_GA_GRASP$cmp$algorithm == "GRASP",
  c('elapsedtime', 'best')], type = 'b', col='red', pch=16)
lines(cmp_GA_GRASP$cmp[cmp_GA_GRASP$cmp$algorithm == "GA",
  c('elapsedtime', 'best')], type = 'b', pch=16)
legend("bottomright", 
  c("Evolutionary based Genetic Algorithm (GA)",
    "Greedy Randomized Adaptive Search Procedures (GRASP)"),
    col = c('black', 'red'),
       pch=16, cex=1.0)

par(op)

## Figure 7
## Not run: 

res &lt;- lapply(c(1, 1, 2, 2, 3, 3), function(seed){
  set.seed(seed); 
  res &lt;- recmapGA(V = checkerboard(4), pmutation = 0.25)
  res$seed &lt;- seed
  res})
 
op &lt;- par(mfcol=c(2,4), bg='azure', mar=c(5, 5, 0.5, 0.5))

x &lt;- recmap(checkerboard(4))
p &lt;- paste(' = (', paste(1:length(x$z), collapse=", "), ')', sep='')
plot(x, 
      sub=substitute(paste(Pi['forward'], p), list(p=p)), 
      col = c('white', 'white', 'white', 'black')[x$z])

x &lt;- recmap(checkerboard(4)[rev(1:16),])
p &lt;- paste(' = (', paste(rev(1:length(x$z)), collapse=", "), ')', sep='')
plot(x, 
      sub=substitute(paste(Pi[reverse], p), list(p=p)), 
      col = c('white', 'white', 'white', 'black')[x$z])


rv &lt;- lapply(res, function(x){
  p &lt;- paste(' = (', paste(x$GA@solution[1,], collapse=", "), ')', sep='')
  plot(x$Cartogram, 
       col = c('white', 'white', 'white', 'black')[x$Cartogram$z],
       sub=substitute(paste(Pi[seed], perm), list(perm=p, seed=x$seed)))
  }) 

## End(Not run)

# sanity check - reproducibility 

identical.recmap &lt;- function(x, y, plot.diff = FALSE){
  target &lt;- x
  current &lt;- y 
  
  stopifnot(is.recmap(target))
  stopifnot(is.recmap(current))
  rv &lt;- identical(x$x, y$x) &amp;&amp; identical(x$y, y$y)  &amp;&amp; 
    identical(x$dx, y$dx) &amp;&amp; identical(x$dy, y$dy)
  if (plot.diff){
   rvtemp &lt;- lapply(c('x', 'y', 'dx', 'dy'), function(cn){
        plot(sort(abs(target[, cn] - current[, cn])),
          ylab = 'absolute error',
          main = cn)
        abline(h = 0, col = 'grey')
      })
  }
  
  rv 
}

## Not run: 
op &lt;- par(mfcol = c(4, 4), mar = c(4, 4, 4, 1)); 
identical.recmap(res[[1]]$Cartogram, res[[2]]$Cartogram, TRUE) 
identical.recmap(res[[3]]$Cartogram, res[[4]]$Cartogram, TRUE) 
identical.recmap(res[[5]]$Cartogram, res[[6]]$Cartogram, TRUE) 
identical.recmap(res[[1]]$Cartogram, res[[6]]$Cartogram, TRUE) 

## End(Not run)

## Figure 11
## Not run: plot(recmap(Switzerland$map[Switzerland$solution,]))

op &lt;- par(mfrow=c(1, 1), mar=c(0,0,0,0)); 

C &lt;- Switzerland$Cartogram

plot(C)

idx &lt;- rev(order(C$z))[1:50];

text(C$x[idx], C$y[idx], C$name[idx], col = 'red', 
  cex = C$dx[idx] / strwidth(as.character(C$name[idx])))

## Figure 12

fitness.SBB &lt;- function(idxOrder, Map, ...){
  Cartogram &lt;- recmap(Map[idxOrder, ])
  if (sum(Cartogram$topology.error == 100) &gt; 1){return (0)}
  1 / sum(Cartogram$z / (sqrt(sum(Cartogram$z^2))) * Cartogram$relpos.error)
}

## Not run: 
SBB &lt;- recmapGA(V=SBB$Map, 
  parallel=TRUE, 
  maxiter=1000, 
  run=1000, 
  seed = 1, 
  keepBest = TRUE,
  fitness=fitness.SBB)

## End(Not run)

SBB.Map &lt;- SBB$Map

# make input map overlapping
S &lt;- SBB$Map
S &lt;- S[!is.na(S$x),]
S$dx &lt;- 0.1; S$dy &lt;- 0.1; S$z &lt;- S$DTV
S$name &lt;- S$Bahnhof_Haltestelle

op &lt;- par(mfrow = c(2, 1), mar = c(0, 0, 0, 0))
plot.recmap(S)
idx &lt;- rev(order(S$z))[1:10]
text(S$x[idx], S$y[idx], S$name[idx], col='red', cex=0.7)
idx &lt;- rev(order(S$z))[11:30]
text(S$x[idx], S$y[idx], S$name[idx], col = 'red', cex = 0.5)

Cartogram.recomp &lt;- recmap(S)
plot(Cartogram.recomp)

idx &lt;- rev(order(Cartogram.recomp$z))[1:40]
text(Cartogram.recomp$x[idx],Cartogram.recomp$y[idx],
	Cartogram.recomp$name[idx],
	col = 'red',
	cex = 1.25 * Cartogram.recomp$dx[idx] / strwidth(Cartogram.recomp$name[idx]))

# sanity check - reproducibility cross plattform
op &lt;- par(mfrow = c(2, 2), mar = c(5, 5, 5, 5))
identical.recmap(Cartogram.recomp, SBB$Cartogram, TRUE)


## Figure 13

## Not run: 
DF &lt;- data.frame(Pct_Leave = UK$Map$Pct_Leave, row.names = UK$Map$name)
spplot(as.SpatialPolygonsDataFrame(UK$Map, DF), 
  main="Input England/Wales/Scottland")

UK.recmap &lt;- recmap(UK$Map)
spplot(as.SpatialPolygonsDataFrame(UK.recmap , DF))

# sanity check - reproducibility cross plattform
op &lt;- par(mfrow=c(2,2), mar=c(5,5,5,5))
identical.recmap(UK.recmap, UK$Cartogram, TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.recmap'>Plot a recmap object.</h2><span id='topic+plot.recmap'></span><span id='topic+plot.recmapGA'></span><span id='topic+plot.recmapGRASP'></span>

<h3>Description</h3>

<p>plots input and output of the <code><a href="#topic+recmap">recmap</a></code> function.
The function requires column names (x, y, dx, dy).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'recmap'
plot(x, col = "#00000011", col.text = "grey", border = "darkgreen", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.recmap_+3A_x">x</code></td>
<td>
<p><code>recmap</code> object - can be input or output of <code>recmap</code>.</p>
</td></tr>
<tr><td><code id="plot.recmap_+3A_col">col</code></td>
<td>
<p>a vector of colors.</p>
</td></tr>
<tr><td><code id="plot.recmap_+3A_col.text">col.text</code></td>
<td>
<p>a vector of colors.</p>
</td></tr>
<tr><td><code id="plot.recmap_+3A_border">border</code></td>
<td>
<p>This parameter is passed to the <code><a href="graphics.html#topic+rect">rect</a></code> function.
color for rectangle border(s). The default means par(&quot;fg&quot;). 
Use border = NA to omit borders. If there are shading lines, border = TRUE 
means use the same colour for the border as for the shading lines.
The default value is set to <code>'darkgreen'</code>.</p>
</td></tr>
<tr><td><code id="plot.recmap_+3A_...">...</code></td>
<td>
<p>whatsoever</p>
</td></tr>
</table>


<h3>Value</h3>

<p>graphical output
</p>


<h3>Examples</h3>

<pre><code class='language-R'>checkerboard(2) |&gt; recmap() |&gt; plot()
</code></pre>

<hr>
<h2 id='recmap'>Compute a Rectangular Statistical Cartogram</h2><span id='topic+recmap'></span><span id='topic+RecMap'></span><span id='topic+cartogram'></span><span id='topic+all.equal.recmap'></span>

<h3>Description</h3>

<p>The input consists of a map represented by overlapping rectangles.
The algorithm requires as input for each map region:
</p>

<ul>
<li><p>a tuple of (x, y) values corresponding to the 
(longitude, latitude) position,
</p>
</li>
<li><p>a tuple of (dx, dy) of expansion along (longitude, latitude),
</p>
</li>
<li><p>and a statistical value z.
</p>
</li></ul>

<p>The (x, y) coordinates represent the center of the minimal bounding boxes 
(MBB), The coordinates of the MBB are derived by adding or subtracting the 
(dx, dy) / 2 tuple accordingly. The tuple (dx, dy) also defines the ratio of the 
map region. The statistical values define the desired area of each map region.
</p>
<p>The output is a rectangular cartogram where the map regions are:
</p>

<ul>
<li><p>Non-overlapping,
</p>
</li>
<li><p>connected,
</p>
</li>
<li><p>ratio and area of each rectangle correspond to the desired areas,
</p>
</li>
<li><p>rectangles are placed parallel to the axes.
</p>
</li></ul>

<p>The construction heuristic places each rectangle in a way that important spatial 
constraints, in particular
</p>

<ul>
<li><p>the topology of the pseudo dual graph,
</p>
</li>
<li><p>the relative position of MBB centers.
</p>
</li></ul>

<p>are tried to be preserved.
</p>
<p>The ratios are preserved and the area of each region corresponds to the as 
input given statistical value z.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recmap(V, E = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recmap_+3A_v">V</code></td>
<td>
<p>defines the input map regions formatted as <code><a href="base.html#topic+data.frame">data.frame</a></code>
having the column names <code>c('x', 'y', 'dx', 'dy', 'z', 'name')</code> 
as described above. V could also be considered as the nodes of the pseudo dual.</p>
</td></tr>
<tr><td><code id="recmap_+3A_e">E</code></td>
<td>
<p>defines the edges of the map region's pseudo dual graph. 
If <code>E</code> is not provided, this is the default; the pseudo dual graph is
composed of overlapping rectangles. If used, E must be a
<code><a href="base.html#topic+data.frame">data.frame</a></code> containing two columns named <code>c('u', 'v')</code>
of type integer referencing the row number of <code>V</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basic idea of the current recmap <em>implementation</em>:
</p>

<ol>
<li><p>Compute the pseudo dual out of the overlapping map regions.
</p>
</li>
<li><p>Determine the <em>core region</em> by <code>index &lt;- int(n / 2)</code>.
</p>
</li>
<li><p>Place region by region along DFS skeleton of pseudo dual starting 
with the <em>core region</em>.</p>
</li></ol>

<p>Note: if a rectangle can not be placed, accept a non-<em>feasible solution</em>
(avoid solutions having a topology error higher than 100)
Solving this constellation can be intensive in the computation, and due to the
assumably low fitness value the candidate cartogram
will be likely rejected by the metaheuristic.
</p>
<p><em>Time Complexity:</em>
The time complexity is <code class="reqn">O(n^2)</code>, where n is the number of regions.
DFS is visiting each map region only once and therefore has 
time complexity <code class="reqn">O(n)</code>. For each placement, a constant number of
MBB intersection are called (max 360). MBB check is implemented using
<code>std::set</code>, <code>insert</code>, <code>upper_bound</code>, <code>upper_bound</code> 
costs are <code class="reqn">O(\log(n))</code>.
However, the worst case for a range query is <code class="reqn">O(n)</code>, if and only if dx or dy
cover the whole x or y range. Q.E.D.
</p>
<p><em>Performance:</em>
In praxis, computing on a 2.4 GHz Intel Core i7 machine (using only one core), using the 
50 state U.S. map example, recmap can compute approximately 100 cartograms in one second.
The number of MBB calls were
(Min., Median, Mean, Max)  = (1448, 2534, 3174, 17740), using in each run
a different index order using the (<code><a href="base.html#topic+sample">sample</a></code>) method.
</p>
<p><em>Geodetic datum:</em> the <code>recmap</code> algorithm is not transforming the 
geodetic datum, e.g., WGS84 or Swissgrid.
</p>


<h3>Value</h3>

<p>Returns a <code>recmap</code> S3 object of the transformed map with new coordinates 
(x, y, dx, dy) plus additional columns containing information for topology 
error, relative position error, and the DFS number.
The error values are thought to be used for fitness function of the
metaheuristic.
</p>


<h3>Author(s)</h3>

<p>Christian Panse, 2016
</p>


<h3>Examples</h3>

<pre><code class='language-R'>map &lt;- checkerboard(2)
cartogram &lt;- recmap(map)

map
cartogram

op &lt;- par(mfrow = c(1, 2))
plot(map)
plot(cartogram)

## US example
usa &lt;- data.frame(x = state.center$x,
  y = state.center$y,
  # make the rectangles overlapping by correcting
  # lines of longitude distance.
  dx = sqrt(state.area) / 2
    / (0.8 * 60 * cos(state.center$y * pi / 180)),
  dy = sqrt(state.area) / 2 / (0.8 * 60),
  z = sqrt(state.area),
  name = state.name)

usa$z &lt;- state.x77[, 'Population']
US.Map &lt;- usa[match(usa$name,
  c('Hawaii', 'Alaska'), nomatch = 0)  == 0, ]

plot.recmap(US.Map)
US.Map |&gt; recmap() |&gt; plot()
par(op)

# define a fitness function
recmap.fitness &lt;- function(idxOrder, Map, ...){
  Cartogram &lt;- recmap(Map[idxOrder, ])
  # a map region could not be placed;
  # accept only feasible solutions!
  if (sum(Cartogram$topology.error == 100) &gt; 0){return (0)}
  1 / sum(Cartogram$z / (sqrt(sum(Cartogram$z^2)))
    * Cartogram$relpos.error)
}

</code></pre>

<hr>
<h2 id='recmapGA'>Genetic Algorithm Wrapper Function for recmap</h2><span id='topic+recmapGA'></span>

<h3>Description</h3>

<p>higher-level function for <code><a href="#topic+recmap">recmap</a></code> using a Genetic Algorithm as
metaheuristic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recmapGA(
  V,
  fitness = .recmap.fitness,
  pmutation = 0.25,
  popSize = 10 * nrow(Map),
  maxiter = 10,
  run = maxiter,
  monitor = if (interactive()) {
     gaMonitor
 } else FALSE,
  parallel = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recmapGA_+3A_v">V</code></td>
<td>
<p>defines the input map regions formatted as <code><a href="base.html#topic+data.frame">data.frame</a></code>
having the column names <code>c('x', 'y', 'dx', 'dy', 'z', 'name')</code> 
as described above. V could also be considered as the nodes of the pseudo dual.</p>
</td></tr>
<tr><td><code id="recmapGA_+3A_fitness">fitness</code></td>
<td>
<p>the fitness function, any allowable R function which takes as input an individual <code>string</code> representing a potential solution, and returns a numerical value describing its &ldquo;fitness&rdquo;.</p>
</td></tr>
<tr><td><code id="recmapGA_+3A_pmutation">pmutation</code></td>
<td>
<p>the probability of mutation in a parent chromosome. Usually mutation occurs with a small probability, and by default is set to 0.1.</p>
</td></tr>
<tr><td><code id="recmapGA_+3A_popsize">popSize</code></td>
<td>
<p>the population size.</p>
</td></tr>
<tr><td><code id="recmapGA_+3A_maxiter">maxiter</code></td>
<td>
<p>the maximum number of iterations to run before the GA search is halted.</p>
</td></tr>
<tr><td><code id="recmapGA_+3A_run">run</code></td>
<td>
<p>the number of consecutive generations without any improvement in the best fitness value before the GA is stopped.</p>
</td></tr>
<tr><td><code id="recmapGA_+3A_monitor">monitor</code></td>
<td>
<p>a logical or an R function which takes as input the current state of the <code>ga-class</code> object and show the evolution of the search. By default, for interactive sessions the function <code><a href="GA.html#topic+gaMonitor">gaMonitor</a></code> prints the average and best fitness values at each iteration. If set to <code>plot</code> these information are plotted on a graphical device. Other functions can be written by the user and supplied as argument. In non interactive sessions, by default <code>monitor = FALSE</code> so any output is suppressed.</p>
</td></tr>
<tr><td><code id="recmapGA_+3A_parallel">parallel</code></td>
<td>

<p>An optional argument which allows to specify if the Genetic Algorithm should be run sequentially or in parallel. 
</p>
<p>For a single machine with multiple cores, possible values are: 
</p>

<ul>
<li><p> a logical value specifying if parallel computing should be used (<code>TRUE</code>) or not (<code>FALSE</code>, default) for evaluating the fitness function;
</p>
</li>
<li><p> a numerical value which gives the number of cores to employ. By default, this is obtained from the function <code><a href="parallel.html#topic+detectCores">detectCores</a></code>; 
</p>
</li>
<li><p> a character string specifying the type of parallelisation to use. This depends on system OS: on Windows OS only <code>"snow"</code> type functionality is available, while on Unix/Linux/Mac OSX both <code>"snow"</code> and <code>"multicore"</code> (default) functionalities are available.
</p>
</li></ul>

<p>In all the cases described above, at the end of the search the cluster is automatically stopped by shutting down the workers.
</p>
<p>If a cluster of multiple machines is available, evaluation of the fitness function can be executed in parallel using all, or a subset of, the cores available to the machines belonging to the cluster. However, this option requires more work from the user, who needs to set up and register a parallel back end. 
In this case the cluster must be explicitly stopped with <code><a href="parallel.html#topic+stopCluster">stopCluster</a></code>.
</p>
</td></tr>
<tr><td><code id="recmapGA_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitness function. This allows to write fitness functions that keep some variables fixed during the search.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of the input <code>Map</code>, the solution of the <code><a href="GA.html#topic+ga">ga</a></code> 
function, and a <code><a href="#topic+recmap">recmap</a></code> object containing the cartogram.
</p>


<h3>References</h3>

<p>Luca Scrucca (2013). GA: A Package for Genetic Algorithms in R.
Journal of Statistical Software, 53(4), 1-37.
<a href="https://doi.org/10.18637/jss.v053.i04">doi:10.18637/jss.v053.i04</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The default fitnes function is currently defined as
function(idxOrder, Map, ...){

  Cartogram &lt;- recmap(Map[idxOrder, ])
  # a map region could not be placed; 
  # accept only feasible solutions!
  
  if (sum(Cartogram$topology.error == 100) &gt; 0){return (0)}
  
  1 / sum(Cartogram$relpos.error)
}


## use Genetic Algorithms (GA &gt;=3.0.0) as metaheuristic
set.seed(1)

## https://github.com/luca-scr/GA/issues/52
if (Sys.info()['machine'] == "arm64") GA::gaControl(useRcpp = FALSE)
res &lt;- recmapGA(V = checkerboard(4), pmutation = 0.25)

op &lt;- par(mfrow = c(1, 3))
plot(res$Map, main = "Input Map") 
plot(res$GA, main="Genetic Algorithm")
plot(res$Cartogram, main = "Output Cartogram")


## US example
getUS_map &lt;- function(){
  usa &lt;- data.frame(x = state.center$x, 
  y = state.center$y, 
  # make the rectangles overlapping by correcting 
  # lines of longitude distance.
  dx = sqrt(state.area) / 2 
    / (0.8 * 60 * cos(state.center$y * pi / 180)), 
  dy = sqrt(state.area) / 2 / (0.8 * 60), 
  z = sqrt(state.area),
  name = state.name)
      
  usa$z &lt;- state.x77[, 'Population']
  US.Map &lt;- usa[match(usa$name, 
    c('Hawaii', 'Alaska'), nomatch = 0)  == 0, ]

  class(US.Map) &lt;- c('recmap', 'data.frame')
  US.Map
}

## Not run: 
# takes 34.268 seconds on CRAN
res &lt;- recmapGA(V = getUS_map(), maxiter = 5)
op &lt;- par(ask = TRUE)
plot(res)
par(op)
summary(res)

## End(Not run)
</code></pre>

<hr>
<h2 id='recmapGRASP'>
Greedy Randomized Adaptive Search Procedure Wrapper Function for recmap
</h2><span id='topic+recmapGRASP'></span>

<h3>Description</h3>

<p>Implements a metaheuristic for <code><a href="#topic+recmap">recmap</a></code> based on GRASP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recmapGRASP(Map, fitness = .recmap.fitness, n.samples = nrow(Map) * 2, 
  fitness.cutoff = 1.7, iteration.max = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recmapGRASP_+3A_map">Map</code></td>
<td>

<p>defines the input map regions formatted as <code><a href="base.html#topic+data.frame">data.frame</a></code>
having the column names <code>c('x', 'y', 'dx', 'dy', 'z', 'name')</code> 
as described above.
</p>
</td></tr>
<tr><td><code id="recmapGRASP_+3A_fitness">fitness</code></td>
<td>

<p>a fitness function <code>function(idxOrder, Map, ...)</code> returning a number 
which as to be maximized.
</p>
</td></tr>
<tr><td><code id="recmapGRASP_+3A_n.samples">n.samples</code></td>
<td>

<p>number of samples.
</p>
</td></tr>
<tr><td><code id="recmapGRASP_+3A_fitness.cutoff">fitness.cutoff</code></td>
<td>

<p>cut-off value.
</p>
</td></tr>
<tr><td><code id="recmapGRASP_+3A_iteration.max">iteration.max</code></td>
<td>

<p>maximal number of iteration.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of the input <code>Map</code>, the best solution of GRASP,
and a <code><a href="#topic+recmap">recmap</a></code> object containing the cartogram. 
</p>


<h3>Author(s)</h3>

<p>Christian Panse
</p>


<h3>References</h3>

<p>Feo TA, Resende MGC (1995). 
&quot;Greedy Randomized Adaptive Search Procedures.&quot;
Journal of Global Optimization, 6(2), 109-133. ISSN 1573-2916. 
<a href="https://doi.org/10.1007/BF01096763">doi:10.1007/BF01096763</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+recmapGA">recmapGA</a></code> and <code><a href="#topic+recmap">recmap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## US example
getUS_map &lt;- function(){
  usa &lt;- data.frame(x = state.center$x, 
  y = state.center$y, 
  # make the rectangles overlapping by correcting 
  # lines of longitude distance.
  dx = sqrt(state.area) / 2 
    / (0.8 * 60 * cos(state.center$y * pi / 180)), 
  dy = sqrt(state.area) / 2 / (0.8 * 60), 
  z = sqrt(state.area),
  name = state.name)
      
  usa$z &lt;- state.x77[, 'Population']
  US.Map &lt;- usa[match(usa$name, 
    c('Hawaii', 'Alaska'), nomatch = 0)  == 0, ]

  class(US.Map) &lt;- c('recmap', 'data.frame')
  US.Map
}

## Not run: 
res &lt;- recmapGRASP(getUS_map())
plot(res$Map, main = "Input Map") 
plot(res$Cartogram, main = "Output Cartogram")

## End(Not run)

</code></pre>

<hr>
<h2 id='summary.recmap'>Summary for recmap object</h2><span id='topic+summary.recmap'></span><span id='topic+summary.recmapGA'></span>

<h3>Description</h3>

<p>Summary method for S3 class <code><a href="#topic+recmap">recmap</a></code>.
The area error is computed as described in the CartoDraw paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'recmap'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.recmap_+3A_object">object</code></td>
<td>
<p>an object for which a summary is desired.</p>
</td></tr>
<tr><td><code id="summary.recmap_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a <code>data.frame</code> containing summary information, e.g.,
objective functions or number of map regions.
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.1109/TVCG.2004.1260761">doi:10.1109/TVCG.2004.1260761</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(checkerboard(4));
summary(recmap(checkerboard(4)))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
