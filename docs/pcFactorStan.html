<!DOCTYPE html><html><head><title>Help for package pcFactorStan</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pcFactorStan}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pcFactorStan-package'><p>Stan Models for the Pairwise Comparison Factor Model</p></a></li>
<li><a href='#calibrateItems'><p>Determine the optimal scale constant for a set of items</p></a></li>
<li><a href='#cmp_probs'><p>Item response function for pairwise comparisons</p></a></li>
<li><a href='#filterGraph'><p>Filter graph to remove vertices that are not well connected</p></a></li>
<li><a href='#findModel'><p>Given a model name, return stanmodel object</p></a></li>
<li><a href='#generateCovItems'><p>Generate paired comparison data with random correlations between items</p></a></li>
<li><a href='#generateFactorItems'><p>Generate paired comparison data for a factor model</p></a></li>
<li><a href='#generateItem'><p>Generate paired comparison data for one or more items given</p>
absolute latent scores</a></li>
<li><a href='#generateSingleFactorItems'><p>Generate paired comparison data with a common factor that</p>
accounts for some proportion of the variance</a></li>
<li><a href='#itemModelExplorer'><p>A Shiny app to experiment with the item response model</p></a></li>
<li><a href='#normalizeData'><p>Normalize data according to a canonical order</p></a></li>
<li><a href='#outlierTable'><p>List observations with Pareto values larger than a given threshold</p></a></li>
<li><a href='#parDistributionCustom'><p>Produce data suitable for plotting parameter distributions</p></a></li>
<li><a href='#parInterval'><p>Produce data suitable for plotting parameter estimates</p></a></li>
<li><a href='#pcStan'><p>Fit a paired comparison Stan model</p></a></li>
<li><a href='#phyActFlowPropensity'><p>Physical activity flow propensity</p></a></li>
<li><a href='#prepCleanData'><p>Transforms data into a form tailored for efficient evaluation by Stan</p></a></li>
<li><a href='#prepData'><p>Transforms data into a form tailored for efficient evaluation by Stan</p></a></li>
<li><a href='#prepFactorModel'><p>Specify a factor model</p></a></li>
<li><a href='#prepSingleFactorModel'><p>Specify a single factor model</p></a></li>
<li><a href='#responseCurve'><p>Produce data suitable for plotting item response curves</p></a></li>
<li><a href='#roundRobinGraph'><p>Create an edge list with round-robin connectivity</p></a></li>
<li><a href='#toLoo'><p>Compute approximate leave-one-out (LOO) cross-validation for Bayesian</p>
models using Pareto smoothed importance sampling (PSIS)</a></li>
<li><a href='#twoLevelGraph'><p>Create an edge list with a random two level connectivity</p></a></li>
<li><a href='#unfactor'><p>Turn a factor back into a vector of integers</p></a></li>
<li><a href='#withoutIndex'><p>Remove the array indexing from a parameter name</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Stan Models for the Paired Comparison Factor Model</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides convenience functions and pre-programmed
    Stan models related to the paired comparison factor model. Its purpose
    is to make fitting paired comparison data using Stan easy. This
    package is described in Pritikin (2020) &lt;<a href="https://doi.org/10.1016%2Fj.heliyon.2020.e04821">doi:10.1016/j.heliyon.2020.e04821</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jpritikin/pcFactorStan">https://github.com/jpritikin/pcFactorStan</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jpritikin/pcFactorStan/issues">https://github.com/jpritikin/pcFactorStan/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4), methods, Rcpp (&ge; 0.12.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>rstan (&ge; 2.26.0), rstantools (&ge; 2.1.1), reshape2, mvtnorm,
igraph, loo, lifecycle</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, shiny, ggplot2, covr, qgraph,
Matrix</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.12.0), RcppEigen (&ge; 0.3.3.3.0), RcppParallel (&ge;
5.0.2), StanHeaders (&ge; 2.26.0), BH (&ge; 1.66.0), rstan (&ge;
2.26.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>lifecycle</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-12 17:48:58 UTC; joshua</td>
</tr>
<tr>
<td>Author:</td>
<td>Joshua N. Pritikin
    <a href="https://orcid.org/0000-0002-9862-5484"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Daniel C. Furr [ctb],
  Trustees of Columbia University [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joshua N. Pritikin &lt;jpritikin@pobox.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-13 17:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='pcFactorStan-package'>Stan Models for the Pairwise Comparison Factor Model</h2><span id='topic+pcFactorStan-package'></span><span id='topic+pcFactorStan'></span>

<h3>Description</h3>

<p><span class="pkg">pcFactorStan</span> makes it easy to fit the paired comparison
factor model using <span class="pkg">rstan</span>.
</p>
<p>A user will generally want to use <code><a href="#topic+prepData">prepData</a></code> and
<code><a href="#topic+pcStan">pcStan</a></code> to fit a model.
</p>
<p>The package includes a number of Stan models (see
<code><a href="#topic+findModel">findModel</a></code> for a list) and an example dataset
<code><a href="#topic+phyActFlowPropensity">phyActFlowPropensity</a></code>.
</p>
<p>After gaining some experience with the pre-defined models, we
anticipate that users may write their own Stan models and fit them
with <code><a href="rstan.html#topic+stan">stan</a></code>, for which <code><a href="#topic+pcStan">pcStan</a></code> is a
wrapper.
</p>

<hr>
<h2 id='calibrateItems'>Determine the optimal scale constant for a set of items</h2><span id='topic+calibrateItems'></span>

<h3>Description</h3>

<p>Data are passed through <code><a href="#topic+filterGraph">filterGraph</a></code> and <code><a href="#topic+normalizeData">normalizeData</a></code>.
Then the &lsquo;unidim_adapt&rsquo; model is fit to each item individually.
A larger <code>varCorrection</code> will obtain a more accurate
<code>scale</code>, but is also more likely to produce an intractable
model. A good compromise is between 5.0 and 9.0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrateItems(
  df,
  iter = 2000L,
  chains = 4L,
  varCorrection = 5,
  maxAttempts = 5L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibrateItems_+3A_df">df</code></td>
<td>
<p>a data frame with pairs of vertices given in columns <code>pa1</code> and <code>pa2</code>, and item response data in other columns</p>
</td></tr>
<tr><td><code id="calibrateItems_+3A_iter">iter</code></td>
<td>
<p>A positive integer specifying the number of iterations for each chain (including warmup).</p>
</td></tr>
<tr><td><code id="calibrateItems_+3A_chains">chains</code></td>
<td>
<p>A positive integer specifying the number of Markov chains.</p>
</td></tr>
<tr><td><code id="calibrateItems_+3A_varcorrection">varCorrection</code></td>
<td>
<p>A correction factor greater than or equal to 1.0</p>
</td></tr>
<tr><td><code id="calibrateItems_+3A_maxattempts">maxAttempts</code></td>
<td>
<p>How many times to try re-running a model with more iterations.</p>
</td></tr>
<tr><td><code id="calibrateItems_+3A_...">...</code></td>
<td>
<p>Additional options passed to <code><a href="rstan.html#topic+stan">stan</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame (one row per item) with the following columns:
</p>

<dl>
<dt>item</dt><dd><p>Name of the item</p>
</dd>
<dt>iter</dt><dd><p>Number of iterations per chain</p>
</dd>
<dt>divergent</dt><dd><p>Number of divergent transitions observed after warmup</p>
</dd>
<dt>treedepth</dt><dd><p>Number of times the treedepth was exceeded</p>
</dd>
<dt>low_bfmi</dt><dd><p>Number of chains with low E-BFMI</p>
</dd>
<dt>n_eff</dt><dd><p>Minimum effective number of samples across all parameters</p>
</dd>
<dt>Rhat</dt><dd><p>Maximum Rhat across all parameters</p>
</dd>
<dt>scale</dt><dd><p>Median marginal posterior of <code>scale</code></p>
</dd>
<dt>thetaVar</dt><dd><p>Median variance of theta (latent scores)</p>
</dd>
</dl>



<h3>References</h3>

<p>Vehtari, A., Gelman, A., Simpson, D., Carpenter, B., &amp; Bürkner, P. C. (2019). Rank-normalization, folding, and localization: An improved <code class="reqn">\widehat R</code> for assessing convergence of MCMC. arXiv preprint arXiv:1903.08008.
</p>


<h3>See Also</h3>

<p><code><a href="rstan.html#topic+check_hmc_diagnostics">check_hmc_diagnostics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
result &lt;- calibrateItems(phyActFlowPropensity)  # takes more than 5 seconds
print(result)

</code></pre>

<hr>
<h2 id='cmp_probs'>Item response function for pairwise comparisons</h2><span id='topic+cmp_probs'></span>

<h3>Description</h3>

<p>Use <code><a href="#topic+itemModelExplorer">itemModelExplorer</a></code> to explore the item model. In
this <span class="pkg">shiny</span> app, the <em>discrimination</em> parameter does what
is customary in item response models. However, it is not difficult
to show that discrimination is a function of thresholds and
scale. That is, discrimination is not an independent parameter.  In
paired comparison models, discrimination and measurement error are
confounded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmp_probs(alpha, scale, pa1, pa2, thRaw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmp_probs_+3A_alpha">alpha</code></td>
<td>
<p>discrimination parameter</p>
</td></tr>
<tr><td><code id="cmp_probs_+3A_scale">scale</code></td>
<td>
<p>scale correction factor</p>
</td></tr>
<tr><td><code id="cmp_probs_+3A_pa1">pa1</code></td>
<td>
<p>first latent worth</p>
</td></tr>
<tr><td><code id="cmp_probs_+3A_pa2">pa2</code></td>
<td>
<p>second latent worth</p>
</td></tr>
<tr><td><code id="cmp_probs_+3A_thraw">thRaw</code></td>
<td>
<p>vector of positive thresholds</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The thresholds are parameterized as the difference
from the previous threshold. For example, thresholds c(0.5, 0.6)
are not at the same location but are at locations c(0.5,
1.1). Thresholds are symmetric. If there is one threshold then the
model admits three possible response outcomes (e.g. <em>win</em>, <em>tie</em>, and
<em>lose</em>). Responses are always stored centered with zero representing
a tie. Therefore, it is necessary to add one plus the number of
thresholds to response data to index into the vector returned by
<code>cmp_probs</code>. For example, if our response data is (-1, 0, 1)
and has one threshold then we would add 2 (1 + 1 threshold) to
obtain the indices (1, 2, 3).
</p>


<h3>Value</h3>

<p>A vector of probabilities of observing each outcome
</p>


<h3>Math</h3>

<p>Up until version 1.4, the item response model was based on the
partial credit model (Masters, 1982). In version 1.5,
the graded response model is used instead (Samejima, 1969).
The advantage of the graded response model is greater
independence among threshold parameters and the ability to
compute only the parts of the model that are actually needed
given particular observations. The curves predicted by both
models are similar and should obtain similar results in data
analyses.
</p>


<h3>References</h3>

<p>Samejima, F. (1969). Estimation of latent ability using a response pattern of graded
scores. <em>Psychometrika Monograph Supplement, 34</em>(4, Pt. 2), 100.
</p>
<p>Masters, G. N. (1982). A Rasch model for partial credit scoring.
<em>Psychometrika, 47</em>, 149–174. doi: 10.1007/BF02296272
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Returns probabilities of
# c(pa1 &gt; pa2, pa1 = pa2, pa1 &lt; pa2)
cmp_probs(1,1,0,1,.8)

# Add another threshold for a symmtric 3 point Likert scale
cmp_probs(1,1,0,.5,c(.8, 1.6))
</code></pre>

<hr>
<h2 id='filterGraph'>Filter graph to remove vertices that are not well connected</h2><span id='topic+filterGraph'></span>

<h3>Description</h3>

<p>Vertices not part of the largest connected component are excluded (Hopcroft &amp; Tarjan, 1973).
Vertices that have fewer than <code>minAny</code> edges and are not
connected to <code>minDifferent</code> or more different vertices are
excluded. For example, vertex &lsquo;a&rsquo; connected to vertices
&lsquo;b&rsquo; and &lsquo;c&rsquo; will be include so long as these vertices
are part of the largest connected component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterGraph(df, minAny = 11L, minDifferent = 2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filterGraph_+3A_df">df</code></td>
<td>
<p>a data frame with pairs of vertices given in columns <code>pa1</code> and <code>pa2</code>, and item response data in other columns</p>
</td></tr>
<tr><td><code id="filterGraph_+3A_minany">minAny</code></td>
<td>
<p>the minimum number of edges</p>
</td></tr>
<tr><td><code id="filterGraph_+3A_mindifferent">minDifferent</code></td>
<td>
<p>the minimum number of vertices</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given that <code>minDifferent</code> defaults to 2,
if activity <code class="reqn">A</code> was compared to at least
two other activities, <code class="reqn">B</code> and <code class="reqn">C</code>, then <code class="reqn">A</code> is retained.
The rationale is that,
although little may be learned about <code class="reqn">A</code>,
there may be a transitive relationship,
such as <code class="reqn">B &lt; A &lt; C</code>, by which the model can infer that <code class="reqn">B &lt; C</code>.
Therefore, per-activity sample size is less of a concern
when the graph is densely connected.
</p>
<p>A young novice asked the wise master, &quot;Why is 11 the default <code>minAny</code> instead of 10?&quot;
The master answered, &quot;Because 11 is a prime number.&quot;
</p>


<h3>Value</h3>

<p>The same graph excluding some
vertices.
</p>


<h3>References</h3>

<p>Hopcroft, J., &amp; Tarjan, R. (1973). Algorithm 447: Efficient algorithms for graph
manipulation. <em>Communications of the ACM, 16</em>(6), 372–378.
doi:10.1145/362248.362272
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- filterGraph(phyActFlowPropensity[,c(paste0('pa',1:2),'predict')])
head(df)

</code></pre>

<hr>
<h2 id='findModel'>Given a model name, return stanmodel object</h2><span id='topic+findModel'></span>

<h3>Description</h3>

<p>This is a convenience function to help you look up the path to an
appropriate model for your data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findModel(model = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findModel_+3A_model">model</code></td>
<td>
<p>the name of a model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are essentially three models: &lsquo;unidim&rsquo;, &lsquo;covariance&rsquo;, and &lsquo;factor&rsquo;.
&lsquo;unidim&rsquo; analyzes a single item. &lsquo;covariance&rsquo; is suitable for two or more items.
Once you have vetted your items with the &lsquo;unidim&rsquo; and &lsquo;covariance&rsquo; models,
then you can try the &lsquo;factor&rsquo; model.
For each model, there is a &lsquo;_ll&rsquo; variation. This model
includes row-wise log likelihoods suitable for feeding to <span class="pkg">loo</span>
for efficient approximate leave-one-out cross-validation (Vehtari, Gelman, &amp; Gabry, 2017).
</p>
<p>There is also a special model &lsquo;unidim_adapt&rsquo;.  Except for
this model, the other models require a scaling constant.  To find
an appropriate scaling constant, we recommend fitting
&lsquo;unidim_adapt&rsquo; to each item separately and then take the
median of median point estimates to set the scale. &lsquo;unidim_adapt&rsquo; requires a
varCorrection constant. In general, a varCorrection of 2.0 or 3.0
should provide optimal results.
</p>
<p>Since version 1.1.0, the factor model permits an arbitrary number
of factors and arbitrary factor-to-item paths. If you were using
the old factor model, you'll need to update your code to call
<a href="#topic+prepSingleFactorModel">prepSingleFactorModel</a>. Arbitrary factor model structure
should be specified using <a href="#topic+prepFactorModel">prepFactorModel</a>. The single factor model
is called &lsquo;factor1&rsquo; and the general factor model is called &lsquo;factor&rsquo;.
</p>


<h3>Value</h3>

<p>An instance of S4 class <code><a href="rstan.html#topic+stanmodel-class">stanmodel</a></code> that can be passed to <code><a href="#topic+pcStan">pcStan</a></code>.
</p>


<h3>References</h3>

<p>Vehtari A, Gelman A, Gabry J (2017). &quot;Practical Bayesian model evaluation
using leave-one-out cross-validation and WAIC.&quot; <em>Statistics and Computing,
27</em>, 1413-1432. doi: 10.1007/s11222-016-9696-4
</p>


<h3>See Also</h3>

<p><code><a href="#topic+toLoo">toLoo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>findModel()  # shows available models
findModel('unidim')
</code></pre>

<hr>
<h2 id='generateCovItems'>Generate paired comparison data with random correlations between items</h2><span id='topic+generateCovItems'></span>

<h3>Description</h3>

<p>If you need access to the correlation matrix used to generate the
absolute latent scores then you will need to generate them yourself.
This is not difficult. See how in the example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateCovItems(df, numItems, th = 0.5, name, ..., scale = 1, alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateCovItems_+3A_df">df</code></td>
<td>
<p>a data frame with pairs of vertices given in columns <code>pa1</code> and <code>pa2</code>, and item response data in other columns</p>
</td></tr>
<tr><td><code id="generateCovItems_+3A_numitems">numItems</code></td>
<td>
<p>how many items to create</p>
</td></tr>
<tr><td><code id="generateCovItems_+3A_th">th</code></td>
<td>
<p>a vector of thresholds</p>
</td></tr>
<tr><td><code id="generateCovItems_+3A_name">name</code></td>
<td>
<p>a vector of item names</p>
</td></tr>
<tr><td><code id="generateCovItems_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="generateCovItems_+3A_scale">scale</code></td>
<td>
<p>a vector of scaling constants</p>
</td></tr>
<tr><td><code id="generateCovItems_+3A_alpha">alpha</code></td>
<td>
<p>a vector of item discriminations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The given data.frame <code>df</code> with additional columns for each item.
In addition, you can obtain the correlation matrix used
to generate the latent worths from <code>attr(df, "cor")</code> and
and latent worths from <code>attr(df, "worth")</code>.
</p>


<h3>Response model</h3>

<p>See <a href="#topic+cmp_probs">cmp_probs</a> for details.
</p>


<h3>See Also</h3>

<p>Other item generators: 
<code><a href="#topic+generateFactorItems">generateFactorItems</a>()</code>,
<code><a href="#topic+generateItem">generateItem</a>()</code>,
<code><a href="#topic+generateSingleFactorItems">generateSingleFactorItems</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mvtnorm)
df &lt;- twoLevelGraph(letters[1:10], 100)
df &lt;- generateCovItems(df, 3)

# generateCovItems essentially does the same thing as:
numItems &lt;- 3
palist &lt;- letters[1:10]
trueCor &lt;- cov2cor(rWishart(1, numItems, diag(numItems))[,,1])
theta &lt;- rmvnorm(length(palist), sigma=trueCor)
dimnames(theta) &lt;- list(palist, paste0('i', 3 + 1:numItems))
df &lt;- generateItem(df, theta)
attr(df, "cor")

</code></pre>

<hr>
<h2 id='generateFactorItems'>Generate paired comparison data for a factor model</h2><span id='topic+generateFactorItems'></span>

<h3>Description</h3>

<p>Generate paired comparison data given a mapping from factors to items.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateFactorItems(
  df,
  path,
  factorScalePrior = deprecated(),
  th = 0.5,
  name,
  ...,
  scale = 1,
  alpha = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateFactorItems_+3A_df">df</code></td>
<td>
<p>a data frame with pairs of vertices given in columns <code>pa1</code> and <code>pa2</code>, and item response data in other columns</p>
</td></tr>
<tr><td><code id="generateFactorItems_+3A_path">path</code></td>
<td>
<p>a named list of item names</p>
</td></tr>
<tr><td><code id="generateFactorItems_+3A_factorscaleprior">factorScalePrior</code></td>
<td>
<p>a named numeric vector (deprecated)</p>
</td></tr>
<tr><td><code id="generateFactorItems_+3A_th">th</code></td>
<td>
<p>a vector of thresholds</p>
</td></tr>
<tr><td><code id="generateFactorItems_+3A_name">name</code></td>
<td>
<p>a vector of item names</p>
</td></tr>
<tr><td><code id="generateFactorItems_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="generateFactorItems_+3A_scale">scale</code></td>
<td>
<p>a vector of scaling constants</p>
</td></tr>
<tr><td><code id="generateFactorItems_+3A_alpha">alpha</code></td>
<td>
<p>a vector of item discriminations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each factor, you need to specify its name and which items it predicts.
The connections from factors to items is specified by the 'path' argument.
Both factors and items are specified by name (not index).
</p>
<p>Path proportions (factor-to-item loadings) are sampled
from a logistic transformed normal distribution with scale
0.6. A few attempts are made to resample path
proportions if any of the item proportions sum to more than
1.0. An exception will be raised if repeated attempts fail to
produce viable proportion assignments.
</p>


<h3>Value</h3>

<p>The given data.frame <code>df</code> with additional columns for each item.
In addition, you can obtain path proportions (factor-to-item loadings) from <code>attr(df, "pathProp")</code>,
the factor scores from <code>attr(df, "score")</code>,
and latent worths from <code>attr(df, "worth")</code>.
</p>


<h3>Response model</h3>

<p>See <a href="#topic+cmp_probs">cmp_probs</a> for details.
</p>


<h3>Backward incompatibility</h3>

<p>The function <a href="#topic+generateFactorItems">generateFactorItems</a> was renamed to
<code>generateSingleFactorItems</code> (version 1.1.0) to make space for a more
flexible factor model with an arbitrary number of factors and
arbitrary factor-to-item loading pattern. If you don't need this
flexibility, you can call the old function <a href="#topic+generateSingleFactorItems">generateSingleFactorItems</a>.
</p>


<h3>References</h3>

<p>Silver, D., Hubert, T., Schrittwieser, J., Antonoglou, I., Lai, M.,
Guez, A., ... &amp; Lillicrap, T. (2018). A general reinforcement
learning algorithm that masters chess, shogi, and Go through
self-play. <em>Science, 362</em>(6419), 1140-1144.
</p>


<h3>See Also</h3>

<p>To fit a factor model: <a href="#topic+prepFactorModel">prepFactorModel</a>
</p>
<p>Other item generators: 
<code><a href="#topic+generateCovItems">generateCovItems</a>()</code>,
<code><a href="#topic+generateItem">generateItem</a>()</code>,
<code><a href="#topic+generateSingleFactorItems">generateSingleFactorItems</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- twoLevelGraph(letters[1:10], 100)
df &lt;- generateFactorItems(df, list(f1=paste0('i',1:4),
                           f2=paste0('i',2:4)),
                      c(f1=0.9, f2=0.5))
head(df)
attr(df, "pathProp")
attr(df, "score")
attr(df, "worth")
</code></pre>

<hr>
<h2 id='generateItem'>Generate paired comparison data for one or more items given
absolute latent scores</h2><span id='topic+generateItem'></span>

<h3>Description</h3>

<p>To add a single item, <code>theta</code> should be a vector of latent
scores. To add multiple items at a time, <code>theta</code> should be a
matrix with one item in each column. Item names can be given as
the colnames of <code>theta</code>.
</p>
<p>The interpretation of <code>theta</code> depends on the context where the
data were generated. For example, in chess, <code>theta</code> represents
unobserved chess skill that is partially revealed by match
outcomes.
</p>
<p>The graph can be regarded as undirected, but data are generated
relative to the order of vertices within each row. Vertices do not
commute. For example, a <code>-1</code> for vertices &lsquo;a&rsquo; and
&lsquo;b&rsquo; is the same as <code>1</code> for vertices &lsquo;b&rsquo; and
&lsquo;a&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateItem(df, theta, th = 0.5, name, ..., scale = 1, alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateItem_+3A_df">df</code></td>
<td>
<p>a data frame with pairs of vertices given in columns <code>pa1</code> and <code>pa2</code>, and item response data in other columns</p>
</td></tr>
<tr><td><code id="generateItem_+3A_theta">theta</code></td>
<td>
<p>a vector or matrix of absolute latent scores. See details below.</p>
</td></tr>
<tr><td><code id="generateItem_+3A_th">th</code></td>
<td>
<p>a vector of thresholds</p>
</td></tr>
<tr><td><code id="generateItem_+3A_name">name</code></td>
<td>
<p>a vector of item names</p>
</td></tr>
<tr><td><code id="generateItem_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="generateItem_+3A_scale">scale</code></td>
<td>
<p>a vector of scaling constants</p>
</td></tr>
<tr><td><code id="generateItem_+3A_alpha">alpha</code></td>
<td>
<p>a vector of item discriminations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The given data.frame <code>df</code> with additional columns for each item.
</p>


<h3>Response model</h3>

<p>See <a href="#topic+cmp_probs">cmp_probs</a> for details.
</p>


<h3>See Also</h3>

<p>Other item generators: 
<code><a href="#topic+generateCovItems">generateCovItems</a>()</code>,
<code><a href="#topic+generateFactorItems">generateFactorItems</a>()</code>,
<code><a href="#topic+generateSingleFactorItems">generateSingleFactorItems</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- roundRobinGraph(letters[1:5], 40)
df &lt;- generateItem(df)
</code></pre>

<hr>
<h2 id='generateSingleFactorItems'>Generate paired comparison data with a common factor that
accounts for some proportion of the variance</h2><span id='topic+generateSingleFactorItems'></span>

<h3>Description</h3>

<p>Imagine that there are people that play in tournaments of more than
one board game. For example, the computer player AlphaZero (Silver
et al. 2018) has trained to play chess, shogi, and Go. We can take
the tournament match outcome data and find rankings among the
players for each of these games. We may also suspect that there is
a latent board game skill that accounts for some proportion of the
variance in the per-board game rankings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateSingleFactorItems(df, prop, th = 0.5, name, ..., scale = 1, alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateSingleFactorItems_+3A_df">df</code></td>
<td>
<p>a data frame with pairs of vertices given in columns <code>pa1</code> and <code>pa2</code>, and item response data in other columns</p>
</td></tr>
<tr><td><code id="generateSingleFactorItems_+3A_prop">prop</code></td>
<td>
<p>the number of items or a vector of signed proportions of variance</p>
</td></tr>
<tr><td><code id="generateSingleFactorItems_+3A_th">th</code></td>
<td>
<p>a vector of thresholds</p>
</td></tr>
<tr><td><code id="generateSingleFactorItems_+3A_name">name</code></td>
<td>
<p>a vector of item names</p>
</td></tr>
<tr><td><code id="generateSingleFactorItems_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="generateSingleFactorItems_+3A_scale">scale</code></td>
<td>
<p>a vector of scaling constants</p>
</td></tr>
<tr><td><code id="generateSingleFactorItems_+3A_alpha">alpha</code></td>
<td>
<p>a vector of item discriminations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The given data.frame <code>df</code> with additional columns for each item.
</p>


<h3>Response model</h3>

<p>See <a href="#topic+cmp_probs">cmp_probs</a> for details.
</p>


<h3>Backward incompatibility</h3>

<p>The function <a href="#topic+generateFactorItems">generateFactorItems</a> was renamed to
<code>generateSingleFactorItems</code> (version 1.1.0) to make space for a more
flexible factor model with an arbitrary number of factors and
arbitrary factor-to-item loading pattern. If you don't need this
flexibility, you can call the old function <a href="#topic+generateSingleFactorItems">generateSingleFactorItems</a>.
</p>


<h3>References</h3>

<p>Silver, D., Hubert, T., Schrittwieser, J., Antonoglou, I., Lai, M.,
Guez, A., ... &amp; Lillicrap, T. (2018). A general reinforcement
learning algorithm that masters chess, shogi, and Go through
self-play. <em>Science, 362</em>(6419), 1140-1144.
</p>


<h3>See Also</h3>

<p>Other item generators: 
<code><a href="#topic+generateCovItems">generateCovItems</a>()</code>,
<code><a href="#topic+generateFactorItems">generateFactorItems</a>()</code>,
<code><a href="#topic+generateItem">generateItem</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- twoLevelGraph(letters[1:10], 100)
df &lt;- generateSingleFactorItems(df, 3)
</code></pre>

<hr>
<h2 id='itemModelExplorer'>A Shiny app to experiment with the item response model</h2><span id='topic+itemModelExplorer'></span>

<h3>Description</h3>

<p>When data <code>dl</code> and fitted model <code>fit</code> are provided, the
item parameters associated with <code>item</code> are loaded for
inspection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itemModelExplorer(dl = NULL, fit = NULL, item = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="itemModelExplorer_+3A_dl">dl</code></td>
<td>
<p>a data list prepared by <code><a href="#topic+prepData">prepData</a></code></p>
</td></tr>
<tr><td><code id="itemModelExplorer_+3A_fit">fit</code></td>
<td>
<p>a <code><a href="rstan.html#topic+stanfit-class">stanfit</a></code> object</p>
</td></tr>
<tr><td><code id="itemModelExplorer_+3A_item">item</code></td>
<td>
<p>name of the item to visualize</p>
</td></tr>
</table>


<h3>Response model</h3>

<p>See <a href="#topic+cmp_probs">cmp_probs</a> for details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
itemModelExplorer()  # will launch a browser in RStudio

</code></pre>

<hr>
<h2 id='normalizeData'>Normalize data according to a canonical order</h2><span id='topic+normalizeData'></span>

<h3>Description</h3>

<p>Pairwise comparison data are not commutative.
Alice beating Bob in chess is equivalent to Bob losing to
Alice. <code>normalizeData</code> assigns an arbitrary order to all
vertices and reorders vertices column-wise to match,
flipping signs as needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalizeData(df, ..., .palist = NULL, .sortRows = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalizeData_+3A_df">df</code></td>
<td>
<p>a data frame with pairs of vertices given in columns <code>pa1</code> and <code>pa2</code>, and item response data in other columns</p>
</td></tr>
<tr><td><code id="normalizeData_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="normalizeData_+3A_.palist">.palist</code></td>
<td>
<p>a character vector giving an order to use instead of the default</p>
</td></tr>
<tr><td><code id="normalizeData_+3A_.sortrows">.sortRows</code></td>
<td>
<p>logical. Using the same order, sort rows in addition to vertex pairs.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(pa1=NA, pa2=NA, i1=c(1, -1))
df[1,paste0('pa',1:2)] &lt;- c('a','b')
df[2,paste0('pa',1:2)] &lt;- c('b','a')
normalizeData(df)
</code></pre>

<hr>
<h2 id='outlierTable'>List observations with Pareto values larger than a given threshold</h2><span id='topic+outlierTable'></span>

<h3>Description</h3>

<p>The function <code><a href="#topic+prepCleanData">prepCleanData</a></code> compresses observations
into the most efficient format for evaluation by Stan. This function
maps indices of observations back to the actual observations,
filtering by the largest Pareto k values. It is assumed that
<code>data</code> was processed by <code><a href="#topic+normalizeData">normalizeData</a></code> or is in
the same order as seen by <code><a href="#topic+prepCleanData">prepCleanData</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outlierTable(data, x, threshold = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outlierTable_+3A_data">data</code></td>
<td>
<p>a data list prepared for processing by Stan</p>
</td></tr>
<tr><td><code id="outlierTable_+3A_x">x</code></td>
<td>
<p>An object created by <code><a href="loo.html#topic+loo">loo</a></code></p>
</td></tr>
<tr><td><code id="outlierTable_+3A_threshold">threshold</code></td>
<td>
<p>threshold is the minimum k value to include</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame (one row per observation) with the following columns:
</p>

<dl>
<dt>pa1</dt><dd><p>Name of object 1</p>
</dd>
<dt>pa2</dt><dd><p>Name of object 2</p>
</dd>
<dt>item</dt><dd><p>Name of item</p>
</dd>
<dt>pick</dt><dd><p>Observed response</p>
</dd>
<dt>k</dt><dd><p>Associated Pareto k value</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+toLoo">toLoo</a></code>, <code><a href="loo.html#topic+pareto-k-diagnostic">pareto_k_ids</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>palist &lt;- letters[1:10]
df &lt;- twoLevelGraph(palist, 300)
theta &lt;- rnorm(length(palist))
names(theta) &lt;- palist
df &lt;- generateItem(df, theta, th=rep(0.5, 4))

df &lt;- filterGraph(df)
df &lt;- normalizeData(df)
dl &lt;- prepCleanData(df)
dl$scale &lt;- 1.5


m1 &lt;- pcStan("unidim_ll", dl)

loo1 &lt;- toLoo(m1, cores=1)
ot &lt;- outlierTable(dl, loo1, threshold=.2)
df[df$pa1==ot[1,'pa1'] &amp; df$pa2==ot[1,'pa2'], 'i1']

</code></pre>

<hr>
<h2 id='parDistributionCustom'>Produce data suitable for plotting parameter distributions</h2><span id='topic+parDistributionCustom'></span><span id='topic+parDistributionFor'></span>

<h3>Description</h3>

<p>Produce data suitable for plotting parameter distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parDistributionCustom(
  fit,
  pars,
  nameVec,
  label = withoutIndex(pars[1]),
  samples = 500
)

parDistributionFor(fit, pi, samples = 500)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parDistributionCustom_+3A_fit">fit</code></td>
<td>
<p>a <code><a href="rstan.html#topic+stanfit-class">stanfit</a></code> object</p>
</td></tr>
<tr><td><code id="parDistributionCustom_+3A_pars">pars</code></td>
<td>
<p>a vector of parameter names</p>
</td></tr>
<tr><td><code id="parDistributionCustom_+3A_namevec">nameVec</code></td>
<td>
<p>a vector of explanatory parameters names</p>
</td></tr>
<tr><td><code id="parDistributionCustom_+3A_label">label</code></td>
<td>
<p>column name for <code>nameVec</code></p>
</td></tr>
<tr><td><code id="parDistributionCustom_+3A_samples">samples</code></td>
<td>
<p>number of posterior samples</p>
</td></tr>
<tr><td><code id="parDistributionCustom_+3A_pi">pi</code></td>
<td>
<p>a data.frame returned by <code><a href="#topic+parInterval">parInterval</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the following columns:
</p>

<dl>
<dt>sample</dt><dd><p>Sample index</p>
</dd>
<dt><em>label</em></dt><dd><p>A name from <em>nameVec</em></p>
</dd>
<dt>value</dt><dd><p>A single sample of the associated parameter</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other data extractor: 
<code><a href="#topic+parInterval">parInterval</a>()</code>,
<code><a href="#topic+responseCurve">responseCurve</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> vignette('manual', 'pcFactorStan') 
</code></pre>

<hr>
<h2 id='parInterval'>Produce data suitable for plotting parameter estimates</h2><span id='topic+parInterval'></span>

<h3>Description</h3>

<p>Produce data suitable for plotting parameter estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parInterval(fit, pars, nameVec, label = withoutIndex(pars[1]), width = 0.8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parInterval_+3A_fit">fit</code></td>
<td>
<p>a <code><a href="rstan.html#topic+stanfit-class">stanfit</a></code> object</p>
</td></tr>
<tr><td><code id="parInterval_+3A_pars">pars</code></td>
<td>
<p>a vector of parameter names</p>
</td></tr>
<tr><td><code id="parInterval_+3A_namevec">nameVec</code></td>
<td>
<p>a vector of explanatory parameters names</p>
</td></tr>
<tr><td><code id="parInterval_+3A_label">label</code></td>
<td>
<p>column name for <code>nameVec</code></p>
</td></tr>
<tr><td><code id="parInterval_+3A_width">width</code></td>
<td>
<p>a width in probability units for the uncertainty interval</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the following columns:
</p>

<dl>
<dt>L</dt><dd><p>Lower quantile</p>
</dd>
<dt>M</dt><dd><p>Median</p>
</dd>
<dt>U</dt><dd><p>Upper quantile</p>
</dd>
<dt><em>label</em></dt><dd><p><em>nameVec</em></p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other data extractor: 
<code><a href="#topic+parDistributionCustom">parDistributionCustom</a>()</code>,
<code><a href="#topic+responseCurve">responseCurve</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> vignette('manual', 'pcFactorStan') 
</code></pre>

<hr>
<h2 id='pcStan'>Fit a paired comparison Stan model</h2><span id='topic+pcStan'></span>

<h3>Description</h3>

<p>Uses <code><a href="#topic+findModel">findModel</a></code> to find the appropriate
model and then invokes <a href="rstan.html#topic+sampling">sampling</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcStan(model, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcStan_+3A_model">model</code></td>
<td>
<p>the name of a model</p>
</td></tr>
<tr><td><code id="pcStan_+3A_data">data</code></td>
<td>
<p>a data list prepared for processing by Stan</p>
</td></tr>
<tr><td><code id="pcStan_+3A_...">...</code></td>
<td>
<p>Additional options passed to <code><a href="rstan.html#topic+stan">stan</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="rstan.html#topic+stanfit-class">stanfit</a></code> object.
</p>
<p>An object of S4 class <code><a href="rstan.html#topic+stanfit-class">stanfit</a></code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="rstan.html#topic+sampling">sampling</a></code>, for which this function is
a wrapper, for additional options. See <code><a href="#topic+prepData">prepData</a></code> to
create a suitable data list.  See
<code><a href="rstan.html#topic+print.stanfit">print.stanfit</a></code> for ways of getting tables
summarizing parameter posteriors.
</p>
<p><code><a href="#topic+calibrateItems">calibrateItems</a></code>, <code><a href="#topic+outlierTable">outlierTable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dl &lt;- prepData(phyActFlowPropensity[,c(1,2,3)])
dl$varCorrection &lt;- 5.0
pcStan('unidim_adapt', data=dl)  # takes more than 5 seconds
</code></pre>

<hr>
<h2 id='phyActFlowPropensity'>Physical activity flow propensity</h2><span id='topic+phyActFlowPropensity'></span>

<h3>Description</h3>

<p>A dataset containing paired comparisons of 87 physical activities on 16
flow-related facets. Participants submitted two activities using free-form
input. These activities were substitute into item templates.
For example, the &lsquo;predict&rsquo; item asked,
&ldquo;How predictable is the action?&rdquo; with response options:
</p>

<ul>
<li><p> A1 is much more predictable than A2.
</p>
</li>
<li><p> A1 is somewhat more predictable than A2.
</p>
</li>
<li><p> Both offer roughly equal predictability.
</p>
</li>
<li><p> A2 is somewhat more predictable than A1.
</p>
</li>
<li><p> A2 is much more predictable than A1.
</p>
</li></ul>

<p>Most items were adapted from Jackson &amp; Eklund (2002).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phyActFlowPropensity
</code></pre>


<h3>Format</h3>

<p>A data.frame with one row per activity comparison and items in
the columns. All item responses are between -2 and 2. Zero indicates
that both activities were judged equal on the trait.
</p>


<h3>Source</h3>

<p>A manuscript fully describing the study is in preparation.
Data are made available under the <a href="https://cdla.dev/sharing-1-0/">Community Data License Agreement - Sharing - Version 1.0</a>
</p>


<h3>References</h3>

<p>Jackson, S. A., &amp; Eklund, R. C. (2002). Assessing flow in physical activity: The flow state
scale-2 and dispositional flow scale-2. <em>Journal of Sport and Exercise Psychology, 24</em>(2),
133-150. doi:10.1123/jsep.24.2.133
</p>

<hr>
<h2 id='prepCleanData'>Transforms data into a form tailored for efficient evaluation by Stan</h2><span id='topic+prepCleanData'></span>

<h3>Description</h3>

<p>Vertex names, if not already factors, are converted to
factors.  The number of thresholds per item is determined by the
largest absolute response value.  Missing responses are filtered
out.  Responses on the same pair of vertices on the same item are
grouped together.  Within a vertex pair and item, responses
are ordered from negative to positive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepCleanData(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepCleanData_+3A_df">df</code></td>
<td>
<p>a data frame with pairs of vertices given in columns <code>pa1</code> and <code>pa2</code>, and item response data in other columns</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: Reordering of responses is likely unless something like
<code><a href="#topic+normalizeData">normalizeData</a></code> has been used with <code>.sortRows=TRUE</code>.
</p>


<h3>Value</h3>

<p>a data list suitable for passing as the <code>data</code>
argument to <code><a href="#topic+pcStan">pcStan</a></code> or <code><a href="rstan.html#topic+stan">stan</a></code>
</p>


<h3>See Also</h3>

<p>Other data preppers: 
<code><a href="#topic+prepData">prepData</a>()</code>,
<code><a href="#topic+prepFactorModel">prepFactorModel</a>()</code>,
<code><a href="#topic+prepSingleFactorModel">prepSingleFactorModel</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- prepCleanData(phyActFlowPropensity)
str(df)
</code></pre>

<hr>
<h2 id='prepData'>Transforms data into a form tailored for efficient evaluation by Stan</h2><span id='topic+prepData'></span>

<h3>Description</h3>

<p>Invokes <code><a href="#topic+filterGraph">filterGraph</a></code> and <code><a href="#topic+normalizeData">normalizeData</a></code>.
Vertex names, if not already factors, are converted to
factors.  The number of thresholds per item is determined by the
largest absolute response value.  Missing responses are filtered
out.  Responses on the same pair of vertices on the same item are
grouped together.  Within a vertex pair and item, responses
are ordered from negative to positive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepData(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepData_+3A_df">df</code></td>
<td>
<p>a data frame with pairs of vertices given in columns <code>pa1</code> and <code>pa2</code>, and item response data in other columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data list suitable for passing as the <code>data</code>
argument to <code><a href="#topic+pcStan">pcStan</a></code> or <code><a href="rstan.html#topic+stan">stan</a></code>
</p>


<h3>See Also</h3>

<p>Other data preppers: 
<code><a href="#topic+prepCleanData">prepCleanData</a>()</code>,
<code><a href="#topic+prepFactorModel">prepFactorModel</a>()</code>,
<code><a href="#topic+prepSingleFactorModel">prepSingleFactorModel</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- prepData(phyActFlowPropensity)
str(df)

</code></pre>

<hr>
<h2 id='prepFactorModel'>Specify a factor model</h2><span id='topic+prepFactorModel'></span>

<h3>Description</h3>

<p>Specify a factor model with an arbitrary number of factors and
arbitrary factor-to-item structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepFactorModel(
  data,
  path,
  factorScalePrior = deprecated(),
  psiScalePrior = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepFactorModel_+3A_data">data</code></td>
<td>
<p>a data list prepared for processing by Stan</p>
</td></tr>
<tr><td><code id="prepFactorModel_+3A_path">path</code></td>
<td>
<p>a named list of item names</p>
</td></tr>
<tr><td><code id="prepFactorModel_+3A_factorscaleprior">factorScalePrior</code></td>
<td>
<p>a named numeric vector (deprecated)</p>
</td></tr>
<tr><td><code id="prepFactorModel_+3A_psiscaleprior">psiScalePrior</code></td>
<td>
<p>matrix of priors for factor correlations (deprecated)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each factor, you need to specify its name and which items it predicts.
The connections from factors to items is specified by the 'path' argument.
Both factors and items are specified by name (not index).
</p>


<h3>Value</h3>

<p>a data list suitable for passing as the <code>data</code>
argument to <code><a href="#topic+pcStan">pcStan</a></code> or <code><a href="rstan.html#topic+stan">stan</a></code>
</p>


<h3>See Also</h3>

<p>To simulate data from a factor model: <a href="#topic+generateFactorItems">generateFactorItems</a>
</p>
<p>Other factor model: 
<code><a href="#topic+prepSingleFactorModel">prepSingleFactorModel</a>()</code>
</p>
<p>Other data preppers: 
<code><a href="#topic+prepCleanData">prepCleanData</a>()</code>,
<code><a href="#topic+prepData">prepData</a>()</code>,
<code><a href="#topic+prepSingleFactorModel">prepSingleFactorModel</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pa &lt;- phyActFlowPropensity[,setdiff(colnames(phyActFlowPropensity),
                                    c('goal1','feedback1'))]
dl &lt;- prepData(pa)
dl &lt;- prepFactorModel(dl,
                      list(flow=c('complex','skill','predict',
                                  'creative', 'novelty', 'stakes',
                                  'present', 'reward', 'chatter',
                                  'body'),
                           f2=c('waiting','control','evaluated','spont'),
                           rc=c('novelty', 'waiting')))
str(dl)
</code></pre>

<hr>
<h2 id='prepSingleFactorModel'>Specify a single factor model</h2><span id='topic+prepSingleFactorModel'></span>

<h3>Description</h3>

<p>Specify a single latent factor with a path to each item.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepSingleFactorModel(data, factorScalePrior = deprecated())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepSingleFactorModel_+3A_data">data</code></td>
<td>
<p>a data list prepared for processing by Stan</p>
</td></tr>
<tr><td><code id="prepSingleFactorModel_+3A_factorscaleprior">factorScalePrior</code></td>
<td>
<p>a named numeric vector (deprecated)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data list suitable for passing as the <code>data</code>
argument to <code><a href="#topic+pcStan">pcStan</a></code> or <code><a href="rstan.html#topic+stan">stan</a></code>
</p>


<h3>See Also</h3>

<p>Other factor model: 
<code><a href="#topic+prepFactorModel">prepFactorModel</a>()</code>
</p>
<p>Other data preppers: 
<code><a href="#topic+prepCleanData">prepCleanData</a>()</code>,
<code><a href="#topic+prepData">prepData</a>()</code>,
<code><a href="#topic+prepFactorModel">prepFactorModel</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dl &lt;- prepData(phyActFlowPropensity)
dl &lt;- prepSingleFactorModel(dl)
str(dl)
</code></pre>

<hr>
<h2 id='responseCurve'>Produce data suitable for plotting item response curves</h2><span id='topic+responseCurve'></span>

<h3>Description</h3>

<p>Selects <code>samples</code> random draws from the posterior and evaluates the item
response curve on the grid given by <code>seq(from,to,by)</code>.
All items use the same <code>responseNames</code>. If you have some items
with a different number of thresholds or different response names
then you can call <code>responseCurve</code> for each item separately
and <code>rbind</code> the results together.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>responseCurve(
  dl,
  fit,
  responseNames,
  item = dl$nameInfo$item,
  samples = 100,
  from = qnorm(0.1),
  to = -from,
  by = 0.02
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="responseCurve_+3A_dl">dl</code></td>
<td>
<p>a data list prepared by <code><a href="#topic+prepData">prepData</a></code></p>
</td></tr>
<tr><td><code id="responseCurve_+3A_fit">fit</code></td>
<td>
<p>a <code><a href="rstan.html#topic+stanfit-class">stanfit</a></code> object</p>
</td></tr>
<tr><td><code id="responseCurve_+3A_responsenames">responseNames</code></td>
<td>
<p>a vector of labels for the possible responses</p>
</td></tr>
<tr><td><code id="responseCurve_+3A_item">item</code></td>
<td>
<p>a vector of item names</p>
</td></tr>
<tr><td><code id="responseCurve_+3A_samples">samples</code></td>
<td>
<p>number of posterior samples</p>
</td></tr>
<tr><td><code id="responseCurve_+3A_from">from</code></td>
<td>
<p>the starting latent difference value</p>
</td></tr>
<tr><td><code id="responseCurve_+3A_to">to</code></td>
<td>
<p>the ending latent difference value</p>
</td></tr>
<tr><td><code id="responseCurve_+3A_by">by</code></td>
<td>
<p>the grid increment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the following columns:
</p>

<dl>
<dt>response</dt><dd><p>Which response</p>
</dd>
<dt>worthDiff</dt><dd><p>Difference in worth</p>
</dd>
<dt>item</dt><dd><p>Which item</p>
</dd>
<dt>sample</dt><dd><p>Which sample</p>
</dd>
<dt>prob</dt><dd><p>Associated probability</p>
</dd>
<dt>responseSample</dt><dd><p>A grouping index for independent item response samples</p>
</dd>
</dl>



<h3>Response model</h3>

<p>See <a href="#topic+cmp_probs">cmp_probs</a> for details.
</p>


<h3>See Also</h3>

<p>Other data extractor: 
<code><a href="#topic+parDistributionCustom">parDistributionCustom</a>()</code>,
<code><a href="#topic+parInterval">parInterval</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> vignette('manual', 'pcFactorStan') 
</code></pre>

<hr>
<h2 id='roundRobinGraph'>Create an edge list with round-robin connectivity</h2><span id='topic+roundRobinGraph'></span>

<h3>Description</h3>

<p>Create an edge list with round-robin connectivity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roundRobinGraph(name, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roundRobinGraph_+3A_name">name</code></td>
<td>
<p>vector of vertex names</p>
</td></tr>
<tr><td><code id="roundRobinGraph_+3A_n">N</code></td>
<td>
<p>number of comparisons</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An undirected graph represented as a data frame with each row describing an edge.
</p>


<h3>See Also</h3>

<p>Other graph generators: 
<code><a href="#topic+twoLevelGraph">twoLevelGraph</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>roundRobinGraph(letters[1:5], 10)
</code></pre>

<hr>
<h2 id='toLoo'>Compute approximate leave-one-out (LOO) cross-validation for Bayesian
models using Pareto smoothed importance sampling (PSIS)</h2><span id='topic+toLoo'></span>

<h3>Description</h3>

<p>You must use an &lsquo;_ll&rsquo; model variation (see <code><a href="#topic+findModel">findModel</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toLoo(fit, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toLoo_+3A_fit">fit</code></td>
<td>
<p>a <code><a href="rstan.html#topic+stanfit-class">stanfit</a></code> object</p>
</td></tr>
<tr><td><code id="toLoo_+3A_...">...</code></td>
<td>
<p>Additional options passed to <code><a href="loo.html#topic+loo">loo</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a loo object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+outlierTable">outlierTable</a></code>, <code><a href="loo.html#topic+loo">loo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>palist &lt;- letters[1:10]
df &lt;- twoLevelGraph(palist, 300)
theta &lt;- rnorm(length(palist))
names(theta) &lt;- palist
df &lt;- generateItem(df, theta, th=rep(0.5, 4))

df &lt;- filterGraph(df)
df &lt;- normalizeData(df)
dl &lt;- prepCleanData(df)
dl$scale &lt;- 1.5


m1 &lt;- pcStan("unidim_ll", dl)

loo1 &lt;- toLoo(m1, cores=1)
print(loo1)

</code></pre>

<hr>
<h2 id='twoLevelGraph'>Create an edge list with a random two level connectivity</h2><span id='topic+twoLevelGraph'></span>

<h3>Description</h3>

<p>Initially, edges are added from the first vertex to all the other
vertices. Thereafter, the first vertex is drawn from a Beta(shape1,
1.0) distribution and the second vertex is drawn from a
Beta(shape2, 1.0) distribution. The idea is that the edges will
tend to connect a small subset of vertices from the top of the tree
to leaf vertices. These vertex connections are similar to the pairs
that you might observe in an elimination tournament. The selected
vertices are sorted so it doesn't matter whether <code>shape1 &gt;
shape2</code> or <code>shape1 &lt; shape2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twoLevelGraph(name, N, shape1 = 0.8, shape2 = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="twoLevelGraph_+3A_name">name</code></td>
<td>
<p>vector of vertex names</p>
</td></tr>
<tr><td><code id="twoLevelGraph_+3A_n">N</code></td>
<td>
<p>number of comparisons</p>
</td></tr>
<tr><td><code id="twoLevelGraph_+3A_shape1">shape1</code></td>
<td>
<p>beta distribution parameter for first edge</p>
</td></tr>
<tr><td><code id="twoLevelGraph_+3A_shape2">shape2</code></td>
<td>
<p>beta distribution parameter for second edge</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An undirected graph represented as a data frame with each row describing an edge.
</p>


<h3>See Also</h3>

<p>Other graph generators: 
<code><a href="#topic+roundRobinGraph">roundRobinGraph</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>twoLevelGraph(letters[1:5], 20)
</code></pre>

<hr>
<h2 id='unfactor'>Turn a factor back into a vector of integers</h2><span id='topic+unfactor'></span>

<h3>Description</h3>

<p>Factors store values as integers and use a 'levels' attribute to
map the integers to labels. This function removes the 'factor'
class and levels attribute, leaving the vector of integers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unfactor(f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unfactor_+3A_f">f</code></td>
<td>
<p>a factor</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- factor(letters[1:3])
print(f)
print(unfactor(f))
</code></pre>

<hr>
<h2 id='withoutIndex'>Remove the array indexing from a parameter name</h2><span id='topic+withoutIndex'></span>

<h3>Description</h3>

<p>Remove the array indexing from a parameter name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>withoutIndex(name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="withoutIndex_+3A_name">name</code></td>
<td>
<p>a parameter name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the name without the square bracket parameter indexing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>withoutIndex("foo[1,2]")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
