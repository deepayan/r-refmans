<!DOCTYPE html><html><head><title>Help for package calmate</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {calmate}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calmate-package'><p>Package calmate</p></a></li>
<li><a href='#calmateByThetaAB.array'><p>Normalize allele-specific copy numbers (CA,CB)</p></a></li>
<li><a href='#calmateByTotalAndFracB.array'><p>Normalize allele-specific copy numbers (total,fracB)</p></a></li>
<li><a href='#CalMaTeCalibration'><p>The CalMaTeCalibration class</p></a></li>
<li><a href='#fitCalMaTe.matrix'><p>Calibrates SNP loci according to the CalMaTe method</p></a></li>
<li><a href='#fitCalMaTeCNprobes.matrix'><p>Normalizes non-polymorphic copy number loci according to the CalMaTe method</p></a></li>
<li><a href='#fitCalMaTeInternal'><p>Algorithms to fit the CalMaTe model for a single SNP</p></a></li>
<li><a href='#Non-documented objects'><p>Non-documented objects</p></a></li>
<li><a href='#thetaAB2TotalAndFracB.array'><p>Converts an Jx2xI array between (thetaA,thetaB) and (total,fracB) formats</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.13.0</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.1), R.utils (&ge; 2.11.0), aroma.core (&ge; 3.2.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, MASS, R.methodsS3 (&ge; 1.8.1), R.oo (&ge; 1.24.0),
matrixStats (&ge; 0.61.0), R.filesets (&ge; 2.14.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>DNAcopy</td>
</tr>
<tr>
<td>Title:</td>
<td>Improved Allele-Specific Copy Number of SNP Microarrays for
Downstream Segmentation</td>
</tr>
<tr>
<td>Description:</td>
<td>The CalMaTe method calibrates preprocessed allele-specific copy number estimates (ASCNs) from DNA microarrays by controlling for single-nucleotide polymorphism-specific allelic crosstalk. The resulting ASCNs are on average more accurate, which increases the power of segmentation methods for detecting changes between copy number states in tumor studies including copy neutral loss of heterozygosity. CalMaTe applies to any ASCNs regardless of preprocessing method and microarray technology, e.g. Affymetrix and Illumina.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> | <a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> [expanded from: LGPL (&ge; 2.1)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/HenrikBengtsson/calmate/">https://github.com/HenrikBengtsson/calmate/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/HenrikBengtsson/calmate/issues">https://github.com/HenrikBengtsson/calmate/issues</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>TRUE</td>
</tr>
<tr>
<td>biocViews:</td>
<td>aCGH, CopyNumberVariants, SNP, Microarray, OneChannel,
TwoChannel, Genetics</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-08 19:16:14 UTC; hb</td>
</tr>
<tr>
<td>Author:</td>
<td>Maria Ortiz [aut, ctb],
  Ander Aramburu [ctb],
  Henrik Bengtsson [aut, cre, cph],
  Pierre Neuvial [aut, ctb],
  Angel Rubio [aut, ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Henrik Bengtsson &lt;henrikb@braju.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-08 23:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='calmate-package'>Package calmate</h2><span id='topic+calmate-package'></span><span id='topic+calmate'></span>

<h3>Description</h3>

<p>The CalMaTe method calibrates preprocessed allele-specific copy number estimates (ASCNs) from DNA microarrays by controlling for single-nucleotide polymorphism-specific allelic crosstalk. The resulting ASCNs are on average more accurate, which increases the power of segmentation methods for detecting changes between copy number states in tumor studies including copy neutral loss of heterozygosity. CalMaTe applies to any ASCNs regardless of preprocessing method and microarray technology, e.g. Affymetrix and Illumina.
</p>


<h3>Requirements</h3>

<p>This package depends on a set of packages that are all available
via CRAN.  It has been tested and verified to run on all common
operating systems on which R runs, including Linux, Windows and OSX.
</p>


<h3>Installation and updates</h3>

<p>To install this package, do <code>install.packages("calmate")</code>.
</p>


<h3>To get started</h3>


<ol>
<li><p> To process SNP and non-polymorphic signals, see <code><a href="#topic+calmateByTotalAndFracB">calmateByTotalAndFracB</a></code>().  If you are working solely with SNP signals, <code><a href="#topic+calmateByThetaAB">calmateByThetaAB</a></code>() is also available, but we recommend the former.
</p>
</li>
<li><p> For processing data in the aroma framework, see <code><a href="#topic+CalMaTeCalibration">CalMaTeCalibration</a></code>.
</p>
</li></ol>



<h3>How to cite</h3>

<p>Please cite [1] when using CalMaTe.
</p>


<h3>License</h3>

<p>LGPL (&gt;= 2.1).
</p>


<h3>Author(s)</h3>

<p>Maria Ortiz [aut, ctb],
Ander Aramburu [ctb],
Henrik Bengtsson [aut, cre, cph],
Pierre Neuvial [aut, ctb],
Angel Rubio [aut, ctb].
</p>


<h3>References</h3>

<p>[1] M. Ortiz-Estevez, A. Aramburu, H. Bengtsson, P. Neuvial and A. Rubio, <em>CalMaTe: A method and software to improve allele-specific copy number of SNP arrays for downstream segmentation</em>, Bioinformatics, 2012 [PMC3381965].
<br />
</p>

<hr>
<h2 id='calmateByThetaAB.array'>Normalize allele-specific copy numbers (CA,CB)</h2><span id='topic+calmateByThetaAB.array'></span><span id='topic+calmateByThetaAB'></span>

<h3>Description</h3>

<p>Normalize allele-specific copy numbers (CA,CB).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'array'
calmateByThetaAB(data, references=NULL, ..., truncate=FALSE, refAvgFcn=NULL,
  flavor=c("v2", "v1"), verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calmateByThetaAB.array_+3A_data">data</code></td>
<td>
<p>An Jx2xI <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+array">array</a></code>, where J is the number of SNPs,
2 is the number of alleles, and I is the number of samples.</p>
</td></tr>
<tr><td><code id="calmateByThetaAB.array_+3A_references">references</code></td>
<td>
<p>An index <code><a href="base.html#topic+vector">vector</a></code> in [1,I] or a <code><a href="base.html#topic+logical">logical</a></code> <code><a href="base.html#topic+vector">vector</a></code>
of length I specifying which samples are used when calculating the
reference signals.  If <code><a href="base.html#topic+NULL">NULL</a></code>, all samples are used. At least 3 samples.</p>
</td></tr>
<tr><td><code id="calmateByThetaAB.array_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the internal fit function
<code><a href="#topic+fitCalMaTeInternal">fitCalMaTeInternal</a></code>.</p>
</td></tr>
<tr><td><code id="calmateByThetaAB.array_+3A_truncate">truncate</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, final ASCNs are forced to be non-negative
while preserving the total CNs.</p>
</td></tr>
<tr><td><code id="calmateByThetaAB.array_+3A_refavgfcn">refAvgFcn</code></td>
<td>
<p>(optional) A <code><a href="base.html#topic+function">function</a></code> that takes a JxI <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+matrix">matrix</a></code>
an argument <code>na.rm</code> and returns a <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of length J.
It should calculate some type of average for each of the J rows, e.g.
<code><a href="matrixStats.html#topic+rowMedians">rowMedians</a></code>.
If specified, then the total copy numbers of the calibrated ASCNs
are standardized toward (twice) the average of the total copy numbers
of the calibrated reference ASCNs.</p>
</td></tr>
<tr><td><code id="calmateByThetaAB.array_+3A_flavor">flavor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying which flavor of the
CalMaTe algorithm to use for fitting the model.</p>
</td></tr>
<tr><td><code id="calmateByThetaAB.array_+3A_verbose">verbose</code></td>
<td>
<p>See <code><a href="R.utils.html#topic+Verbose">Verbose</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an Jx2xI <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+array">array</a></code>
with the same dimension names as argument <code>data</code>.
</p>


<h3>Flavors</h3>

<p>For backward compatibility, we try to keep all major versions of
the CalMaTe algorithm available.  Older versions can be used by
specifying argument <code>flavor</code>.
The default flavor is <code>v2</code>.
For more information about the different flavors,
see <code><a href="#topic+fitCalMaTeInternal">fitCalMaTeInternal</a></code>.
</p>


<h3>References</h3>

<p>[1] M. Ortiz-Estevez, A. Aramburu, H. Bengtsson, P. Neuvial and A. Rubio, <em>CalMaTe: A method and software to improve allele-specific copy number of SNP arrays for downstream segmentation</em>, Bioinformatics, 2012 [PMC3381965].
<br />
</p>


<h3>See Also</h3>

<p>To calibrate (total,fracB) data,
see <code><a href="#topic+calmateByTotalAndFracB.array">*calmateByTotalAndFracB</a>()</code>.
We strongly recommend to always work with (total,fracB) data
instead of (CA,CB) data, because it is much more general.
</p>
<p>For further information on the internal fit functions, see
<code><a href="#topic+fitCalMaTeInternal">fitCalMaTeInternal</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load example (thetaA,thetaB) signals
path &lt;- system.file("exData", package="calmate");
theta &lt;- loadObject("thetaAB,100x2x40.Rbin", path=path);

# Calculate (CA,CB)
thetaR &lt;- matrixStats::rowMedians(theta[,"A",] + theta[,"B",], na.rm=TRUE);
C &lt;- 2*theta/thetaR;

# Calibrate (CA,CB) by CalMaTe
CC &lt;- calmateByThetaAB(theta);

# Plot two "random" arrays
Clim &lt;- c(0,4);
subplots(4, ncol=2, byrow=FALSE);
for (ii in c(1,5)) {
  sampleName &lt;- dimnames(C)[[3]][ii];
  sampleLabel &lt;- sprintf("Sample #%d ('%s')", ii, sampleName);
  plot(C[,,ii], xlim=Clim, ylim=Clim);
  title(main=sampleLabel);
  plot(CC[,,ii], xlim=Clim, ylim=Clim);
  title(main=sprintf("%s\ncalibrated", sampleLabel));
}
</code></pre>

<hr>
<h2 id='calmateByTotalAndFracB.array'>Normalize allele-specific copy numbers (total,fracB)</h2><span id='topic+calmateByTotalAndFracB.array'></span><span id='topic+calmateByTotalAndFracB'></span>

<h3>Description</h3>

<p>Normalize allele-specific copy numbers (total,fracB), where total is the total (non-polymorphic) signal and
fracB is the allele B fraction.
It is only loci with a non-missing (<code><a href="base.html#topic+NA">NA</a></code>) fracB value that are
considered to be SNPs and normalized by CalMaTe.  The other loci
are left untouched.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'array'
calmateByTotalAndFracB(data, references=NULL, ..., refAvgFcn=NULL, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calmateByTotalAndFracB.array_+3A_data">data</code></td>
<td>
<p>An Jx2xI <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+array">array</a></code>, where J is the number of loci,
2 is total and fracB (in that order, if unnamed), and
I is the number of samples.</p>
</td></tr>
<tr><td><code id="calmateByTotalAndFracB.array_+3A_references">references</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> or <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> specifying which
samples should be used as the reference set.
By default, all samples are considered. If not NULL at least 3 samples.</p>
</td></tr>
<tr><td><code id="calmateByTotalAndFracB.array_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+calmateByThetaAB.array">*calmateByThetaAB</a>()</code>.</p>
</td></tr>
<tr><td><code id="calmateByTotalAndFracB.array_+3A_refavgfcn">refAvgFcn</code></td>
<td>
<p>(optional) A <code><a href="base.html#topic+function">function</a></code> that takes a JxI <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+matrix">matrix</a></code>
an argument <code>na.rm</code> and returns a <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of length J.
It should calculate some type of average for each of the J rows, e.g.
<code><a href="matrixStats.html#topic+rowMedians">rowMedians</a></code>.
If specified, then the total copy numbers of the calibrated ASCNs
are standardized toward (twice) the average of the total copy numbers
of the calibrated reference ASCNs.</p>
</td></tr>
<tr><td><code id="calmateByTotalAndFracB.array_+3A_verbose">verbose</code></td>
<td>
<p>See <code><a href="R.utils.html#topic+Verbose">Verbose</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an Jx2xI <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+array">array</a></code>
with the same dimension names as argument <code>data</code>.
</p>


<h3>References</h3>

<p>[1] M. Ortiz-Estevez, A. Aramburu, H. Bengtsson, P. Neuvial and A. Rubio, <em>CalMaTe: A method and software to improve allele-specific copy number of SNP arrays for downstream segmentation</em>, Bioinformatics, 2012 [PMC3381965].
<br />
</p>


<h3>See Also</h3>

<p>To calibrate (thetaA,thetaB) or (CA,CB) signals,
see <code><a href="#topic+calmateByThetaAB.array">*calmateByThetaAB</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load example (thetaA,thetaB) signals
path &lt;- system.file("exData", package="calmate");
theta &lt;- loadObject("thetaAB,100x2x40.Rbin", path=path);

# Transform to (total,fracB) signals
data &lt;- thetaAB2TotalAndFracB(theta);

# Calibrate (total,fracB) by CalMaTe
dataC &lt;- calmateByTotalAndFracB(data);

# Calculate copy-number ratios
theta &lt;- data[,"total",];
thetaR &lt;- matrixStats::rowMedians(theta, na.rm=TRUE);
data[,"total",] &lt;- 2*theta/thetaR;

# Plot two "random" arrays
Clim &lt;- c(0,4);
Blim &lt;- c(0,1);
subplots(4, ncol=2, byrow=FALSE);
for (ii in c(1,5)) {
  sampleName &lt;- dimnames(data)[[3]][ii];
  sampleLabel &lt;- sprintf("Sample #%d ('%s')", ii, sampleName);
  plot(data[,,ii], xlim=Clim, ylim=Blim);
  title(main=sampleLabel);
  plot(dataC[,,ii], xlim=Clim, ylim=Blim);
  title(main=sprintf("%s\ncalibrated", sampleLabel));
}


# Assert that it also works with a single unit
dummy &lt;- calmateByTotalAndFracB(data[1,,,drop=FALSE]);
stopifnot(length(dim(dummy)) == 3);
</code></pre>

<hr>
<h2 id='CalMaTeCalibration'>The CalMaTeCalibration class</h2><span id='topic+CalMaTeCalibration'></span>

<h3>Description</h3>

<p>Package:  calmate <br />
<b>Class CalMaTeCalibration</b><br />
</p>
<p><code><a href="R.oo.html#topic+Object">Object</a></code><br />
<code>~~|</code><br />
<code>~~+--</code><code><a href="aroma.core.html#topic+ParametersInterface">ParametersInterface</a></code><br />
<code>~~~~~~~|</code><br />
<code>~~~~~~~+--</code><code>CalMaTeCalibration</code><br />
</p>
<p><b>Directly known subclasses:</b><br />
<br />
</p>
<p>public static class <b>CalMaTeCalibration</b><br />
extends <a href="aroma.core.html#topic+ParametersInterface">ParametersInterface</a><br />
</p>
<p>This class represents the CalMaTe method [1], which
corrects for SNP effects in allele-specific copy-number estimates
(ASCNs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalMaTeCalibration(data=NULL, tags="*", references=NULL, flavor=c("v2", "v1"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalMaTeCalibration_+3A_data">data</code></td>
<td>
<p>A named <code><a href="base.html#topic+list">list</a></code> with data set named <code>"total"</code> and
<code>"fracB"</code> where the former should be of class
<code><a href="aroma.core.html#topic+AromaUnitTotalCnBinarySet">AromaUnitTotalCnBinarySet</a></code> and the latter of
class <code><a href="aroma.core.html#topic+AromaUnitFracBCnBinarySet">AromaUnitFracBCnBinarySet</a></code>.  The
two data sets must be for the same chip type, have the same
number of samples and the same sample names.</p>
</td></tr>
<tr><td><code id="CalMaTeCalibration_+3A_tags">tags</code></td>
<td>
<p>Tags added to the output data sets.</p>
</td></tr>
<tr><td><code id="CalMaTeCalibration_+3A_references">references</code></td>
<td>
<p>An optional <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> specifying which samples
should be as reference samples for estimating the model parameters.
If <code><a href="base.html#topic+NULL">NULL</a></code>, all samples are used.</p>
</td></tr>
<tr><td><code id="CalMaTeCalibration_+3A_flavor">flavor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying which flavor of the
CalMaTe algorithm to use for fitting the model.
See <code><a href="#topic+fitCalMaTeInternal">fitCalMaTeInternal</a></code> for details.</p>
</td></tr>
<tr><td><code id="CalMaTeCalibration_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+calmateByTotalAndFracB">calmateByTotalAndFracB</a></code>().</p>
</td></tr>
</table>


<h3>Fields and Methods</h3>

<p><b>Methods:</b><br />
</p>

<table>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>findUnitsTodo</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>getDataSets</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>getFullName</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>getName</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>getOutputDataSets</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>getPath</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>getReferences</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>getRootPath</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>getTags</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>nbrOfFiles</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>process</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>setTags</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p><b>Methods inherited from ParametersInterface</b>:<br />
getParameterSets, getParameters, getParametersAsString
</p>
<p><b>Methods inherited from Object</b>:<br />
$, $&lt;-, [[, [[&lt;-, as.character, attach, attachLocally, clearCache, clearLookupCache, clone, detach, equals, extend, finalize, getEnvironment, getFieldModifier, getFieldModifiers, getFields, getInstantiationTime, getStaticInstance, hasField, hashCode, ll, load, names, objectSize, print, save, asThis
</p>


<h3>Reference samples</h3>

<p>In order to estimate the calibration parameters, the model assumes
that, for any given SNP, there are a majority of samples that are
diploid at that SNP.  Note that it does not have to be the same set
of samples for all SNPs.
</p>
<p>By using argument <code>references</code>, it is possible so specify which
samples should be used when estimating the calibration parameters.
This is useful when for instance there are several tumor samples with
unknown properties as well as a set of normal samples that can be
assumed to be diploid.
</p>
<p>Theoretical, a minimum of three reference samples are needed in order
for the model to be identifiable.  If less, an error is thrown.
However, in practice more reference samples should be used, that is,
in the order of at least 6-10 reference samples with a diverse set
of genotypes.
</p>


<h3>Flavors</h3>

<p>For backward compatibility, we try to keep all major versions of
the CalMaTe algorithm available.  Older versions can be used by
specifying argument <code>flavor</code>.
For more information about the different flavors,
see <code><a href="#topic+fitCalMaTeInternal">fitCalMaTeInternal</a></code>.
</p>


<h3>References</h3>

<p>[1] M. Ortiz-Estevez, A. Aramburu, H. Bengtsson, P. Neuvial and A. Rubio, <em>CalMaTe: A method and software to improve allele-specific copy number of SNP arrays for downstream segmentation</em>, Bioinformatics, 2012 [PMC3381965].
<br />
</p>


<h3>See Also</h3>

<p>Low-level versions of the CalMaTe method is available
via the <code><a href="#topic+calmateByThetaAB">calmateByThetaAB</a></code>() and
<code><a href="#topic+calmateByTotalAndFracB">calmateByTotalAndFracB</a></code>() methods.
</p>
<p>For further information on the internal fit functions, see
<code><a href="#topic+fitCalMaTeInternal">fitCalMaTeInternal</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# CRMAv2 - Preprocess raw Affymetrix data
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
library("aroma.affymetrix");  # Needed for CRMAv2
dataSet &lt;- "Affymetrix_2006-TumorNormal";
chipType &lt;- "Mapping250K_Nsp";
dsList &lt;- doCRMAv2(dataSet, chipType=chipType, combineAlleles=FALSE,
                                             plm="RmaCnPlm", verbose=-10);
print(dsList);


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# CalMaTe - Post-calibration of ASCNs estimates
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
asn &lt;- CalMaTeCalibration(dsList);
print(asn);

# For speed issues, we will here only process loci on Chromosome 17.
chr &lt;- 17;
ugp &lt;- getAromaUgpFile(dsList$total);
units &lt;- getUnitsOnChromosome(ugp, chr);

dsNList &lt;- process(asn, units=units, verbose=verbose);
print(dsNList);


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Plot allele B fractions (before and after)
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Sample #1 and Chromosome 17
ii &lt;- 1;

# Extract raw (TCN,BAF)
df &lt;- getFile(dsList$total, ii);
dfR &lt;- getAverageFile(dsList$total, verbose=verbose);
gamma &lt;- extractRawCopyNumbers(df, logBase=NULL, chromosome=chr);
gammaR &lt;- extractRawCopyNumbers(dfR, logBase=NULL, chromosome=chr);
gamma &lt;- 2*divideBy(gamma, gammaR);
df &lt;- getFile(dsList$fracB, ii);
beta &lt;- extractRawAlleleBFractions(df, chromosome=chr);

# Extract calibrated (TCN,BAF)
dfN &lt;- getFile(dsNList$fracB, ii);
betaN &lt;- extractRawAlleleBFractions(dfN, chromosome=chr);
dfN &lt;- getFile(dsNList$total, ii);
gammaN &lt;- extractRawCopyNumbers(dfN, logBase=NULL, chromosome=chr);

# Plot
subplots(4, ncol=2, byrow=FALSE);
plot(beta);
title(sprintf("%s", getName(beta)));
plot(gamma);
plot(betaN);
title(sprintf("%s (CalMaTe)", getName(betaN)));
plot(gammaN);


## End(Not run)</code></pre>

<hr>
<h2 id='fitCalMaTe.matrix'>Calibrates SNP loci according to the CalMaTe method</h2><span id='topic+fitCalMaTe.matrix'></span><span id='topic+fitCalMaTe'></span>

<h3>Description</h3>

<p>Calibrates SNP loci according to the CalMaTe method.
<em>Note: This is an internal function of the package, which is kept
only kept to provide easy access to the internal fit functions.
It it actually not elsewhere in the package, and should nor by others.</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
fitCalMaTe(dataT, references, flavor=c("v2", "v1"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitCalMaTe.matrix_+3A_datat">dataT</code></td>
<td>
<p>A 2xI <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+matrix">matrix</a></code> of allele specific copy numbers (ASCNs),
where 2 is the number alleles and I is the number of samples.</p>
</td></tr>
<tr><td><code id="fitCalMaTe.matrix_+3A_references">references</code></td>
<td>
<p>A <code><a href="base.html#topic+integer">integer</a></code> <code><a href="base.html#topic+vector">vector</a></code> with elements in [1,I] specifying
which samples should be used as the reference set.</p>
</td></tr>
<tr><td><code id="fitCalMaTe.matrix_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the internal fit functions.</p>
</td></tr>
<tr><td><code id="fitCalMaTe.matrix_+3A_flavor">flavor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying which internal fit function
(flavor of the CalMaTe algorithm) to use for fitting the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a 2xI <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+matrix">matrix</a></code> of calibrated ASCNs.
</p>


<h3>Flavors</h3>

<p>For backward compatibility, we try to keep all major versions of
the CalMaTe algorithm available.  Older versions can be used by
specifying argument <code>flavor</code>.
For more information about the different flavors,
see <code><a href="#topic+fitCalMaTeInternal">fitCalMaTeInternal</a></code>.
</p>


<h3>References</h3>

<p>[1] M. Ortiz-Estevez, A. Aramburu, H. Bengtsson, P. Neuvial and A. Rubio, <em>CalMaTe: A method and software to improve allele-specific copy number of SNP arrays for downstream segmentation</em>, Bioinformatics, 2012 [PMC3381965].
<br />
</p>


<h3>See Also</h3>

<p>For further information on the internal fit functions,
see <code><a href="#topic+fitCalMaTeInternal">fitCalMaTeInternal</a></code>.
</p>

<hr>
<h2 id='fitCalMaTeCNprobes.matrix'>Normalizes non-polymorphic copy number loci according to the CalMaTe method</h2><span id='topic+fitCalMaTeCNprobes.matrix'></span><span id='topic+fitCalMaTeCNprobes'></span>

<h3>Description</h3>

<p>Normalizes non-polymorphic copy number loci according to the CalMaTe method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
fitCalMaTeCNprobes(dataT, references, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitCalMaTeCNprobes.matrix_+3A_datat">dataT</code></td>
<td>
<p>A JxI <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+matrix">matrix</a></code>, where J is the number of loci
and I is the number of samples.</p>
</td></tr>
<tr><td><code id="fitCalMaTeCNprobes.matrix_+3A_references">references</code></td>
<td>
<p>A <code><a href="base.html#topic+integer">integer</a></code> <code><a href="base.html#topic+vector">vector</a></code> with elements in [1,I] specifying
which samples should be used as the reference set.</p>
</td></tr>
<tr><td><code id="fitCalMaTeCNprobes.matrix_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of length J.
</p>

<hr>
<h2 id='fitCalMaTeInternal'>Algorithms to fit the CalMaTe model for a single SNP</h2><span id='topic+fitCalMaTeInternal'></span><span id='topic+fitCalMaTeV1'></span><span id='topic+fitCalMaTeV2'></span><span id='topic+fitCalMaTeMedians'></span>

<h3>Description</h3>

<p>Algorithms to fit the CalMaTe model for a single SNP.
<em>Note: These are internal functions of the package.
They should not be used elsewhere.</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fitCalMaTeV1(dataT, references, fB1=1/3, fB2=2/3, maxIter=50, ...)
  fitCalMaTeV2(dataT, references, fB1=1/3, fB2=2/3, maxIter=50, ...)
  fitCalMaTeMedians(dataT, references, fB1=1/3, fB2=2/3,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitCalMaTeInternal_+3A_datat">dataT</code></td>
<td>
<p>A 2xI <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+matrix">matrix</a></code> of allele specific copy numbers (ASCNs),
where 2 is the number alleles and I is the number of samples.</p>
</td></tr>
<tr><td><code id="fitCalMaTeInternal_+3A_references">references</code></td>
<td>
<p>A <code><a href="base.html#topic+integer">integer</a></code> <code><a href="base.html#topic+vector">vector</a></code> with elements in [1,I] specifying
which samples should be used as the reference set.</p>
</td></tr>
<tr><td><code id="fitCalMaTeInternal_+3A_fb1">fB1</code>, <code id="fitCalMaTeInternal_+3A_fb2">fB2</code></td>
<td>
<p>Thresholds for calling genotypes AA, AB, BB from the
allele B fractions.</p>
</td></tr>
<tr><td><code id="fitCalMaTeInternal_+3A_maxiter">maxIter</code></td>
<td>
<p>The maximum number of iterations without converging
before the algorithm quits.</p>
</td></tr>
<tr><td><code id="fitCalMaTeInternal_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a 2xI <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+matrix">matrix</a></code> of calibrated ASCNs.
</p>


<h3>Flavor v1</h3>

<p>This is an early version (June 2010-January 2012) of the algorithm
described in [1].
</p>


<h3>Flavor v2</h3>

<p>This is the model and algorithm described in [1].
</p>
<p>This version was introduced to decrease the number of
&quot;artificial outliers&quot; introduced by CalMaTe for some SNPs
due to non-converging or wreak-havoc estimates of the SNP effects.
Flavor v2 differ from Flavor v1 as follows:
</p>

<ul>
<li><p> The estimation of the model parameters are now done solely
based on reference samples.  In previous versions, some of the
initial estimation steps were using also non-reference samples.
</p>
</li>
<li><p> For a small number of SNPs, the main CalMaTe scheme for estimating
parameters would not converge or converge poorly.  For such SNPs
CalMaTe now falls back to using a plain median estimator,
i.e. <code>fitCalMaTeMedians()</code>.
</p>
</li>
<li><p> The above fallback estimator is also used in cases where
all samples are identified to be homozygous.
</p>
</li></ul>

<p>The <code>fitCalMaTeMedians()</code> method is used as a fallback method
by <code>fitCalMaTeV2()</code>.  It fits CalMaTe without using the
<code><a href="MASS.html#topic+rlm">rlm</a></code> function.
</p>


<h3>References</h3>

<p>[1] M. Ortiz-Estevez, A. Aramburu, H. Bengtsson, P. Neuvial and A. Rubio, <em>CalMaTe: A method and software to improve allele-specific copy number of SNP arrays for downstream segmentation</em>, Bioinformatics, 2012 [PMC3381965].
<br />
</p>


<h3>See Also</h3>

<p>These functions are called by <code><a href="#topic+calmateByThetaAB">calmateByThetaAB</a></code>().
</p>

<hr>
<h2 id='Non-documented+20objects'>Non-documented objects</h2><span id='topic+Non-documented+20objects'></span><span id='topic+truncateThetaAB'></span><span id='topic+truncateThetaAB.array'></span><span id='topic+allocateOutputDataSets'></span><span id='topic+allocateOutputDataSets.CalMaTeCalibration'></span><span id='topic+as.character.CalMaTeCalibration'></span><span id='topic+getAsteriskTags'></span><span id='topic+getAsteriskTags.CalMaTeCalibration'></span><span id='topic+getDataSets'></span><span id='topic+getDataSets.CalMaTeCalibration'></span><span id='topic+getFullName'></span><span id='topic+getFullName.CalMaTeCalibration'></span><span id='topic+getInputDataSet'></span><span id='topic+getInputDataSet.CalMaTeCalibration'></span><span id='topic+getName.CalMaTeCalibration'></span><span id='topic+getOutputDataSet'></span><span id='topic+getOutputDataSet.CalMaTeCalibration'></span><span id='topic+getPath.CalMaTeCalibration'></span><span id='topic+getRootPath'></span><span id='topic+getRootPath.CalMaTeCalibration'></span><span id='topic+getTags'></span><span id='topic+getTags.CalMaTeCalibration'></span><span id='topic+nbrOfFiles'></span><span id='topic+nbrOfFiles.CalMaTeCalibration'></span><span id='topic+process'></span><span id='topic+process.CalMaTeCalibration'></span><span id='topic+setTags'></span><span id='topic+setTags.CalMaTeCalibration'></span><span id='topic+findUnitsTodo'></span><span id='topic+findUnitsTodo.CalMaTeCalibration'></span><span id='topic+getOutputDataSets'></span><span id='topic+getOutputDataSets.CalMaTeCalibration'></span><span id='topic+truncateFracB'></span><span id='topic+truncateFracB.array'></span><span id='topic+truncateFracB.matrix'></span><span id='topic+truncateThetaAB.matrix'></span><span id='topic+getReferences'></span><span id='topic+getReferences.CalMaTeCalibration'></span><span id='topic+cat'></span><span id='topic+getParameters.CalMaTeCalibration'></span>

<h3>Description</h3>

<p>This page contains aliases for all &quot;non-documented&quot; objects that
<code>R CMD check</code> detects in this package.
</p>
<p>Almost all of them are <em>generic</em> functions that have specific
document for the corresponding method coupled to a specific class.
Other functions are re-defined by <code>setMethodS3()</code> to
<em>default</em> methods. Neither of these two classes are non-documented
in reality.
The rest are deprecated methods.
</p>

<hr>
<h2 id='thetaAB2TotalAndFracB.array'>Converts an Jx2xI array between (thetaA,thetaB) and (total,fracB) formats</h2><span id='topic+thetaAB2TotalAndFracB.array'></span><span id='topic+thetaAB2TotalAndFracB'></span><span id='topic+totalAndFracB2ThetaAB'></span><span id='topic+totalAndFracB2ThetaAB.array'></span>

<h3>Description</h3>

<p>Converts an Jx2xI array between (thetaA,thetaB) and (total,fracB) formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'array'
thetaAB2TotalAndFracB(data, ..., verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thetaAB2TotalAndFracB.array_+3A_data">data</code></td>
<td>
<p>An Jx2xI <code><a href="base.html#topic+numeric">numeric</a></code> array, where J is the number of SNPs,
2 is the number of alleles, and I is the number of samples.</p>
</td></tr>
<tr><td><code id="thetaAB2TotalAndFracB.array_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="thetaAB2TotalAndFracB.array_+3A_verbose">verbose</code></td>
<td>
<p>See <code><a href="R.utils.html#topic+Verbose">Verbose</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an Jx2xI <code><a href="base.html#topic+numeric">numeric</a></code> array.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load example (thetaA,thetaB) signals
path &lt;- system.file("exData", package="calmate");
theta &lt;- loadObject("thetaAB,100x2x40.Rbin", path=path);

data &lt;- thetaAB2TotalAndFracB(theta);
str(data);

theta2 &lt;- totalAndFracB2ThetaAB(data);
str(theta2);

stopifnot(all.equal(theta2, theta));
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
