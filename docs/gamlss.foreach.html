<!DOCTYPE html><html lang="en"><head><title>Help for package gamlss.foreach</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gamlss.foreach}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#gamlss.foreach-package'><p>Computational Intensive Functions within GAMLSS</p></a></li>
<li><a href='#BayesianBoot'>
<p>Non parametric and Bayesian Bootstrapping for  GAMLSS models</p></a></li>
<li><a href='#centiles.boot'><p>Bootstrapping centiles curves estimated using GAMLSS</p></a></li>
<li><a href='#fitPCR'>
<p>Function to fit simple Principal Component Regression.</p></a></li>
<li><a href='#fitRolling'><p>Function to Fit Rolling Regression in gamlss</p></a></li>
<li><a href='#fitted.PCR'><p>Methods for PCR objects</p></a></li>
<li><a href='#pc'><p>Functions to Fit Principal Component Regression in GAMLSS</p></a></li>
<li><a href='#which.Data.Corr'><p>Detecting Hight Pair-Wise Correlations in Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Parallel Computations for Distributional Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1-6</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-08-28</td>
</tr>
<tr>
<td>Author:</td>
<td>Mikis Stasinopoulos [aut, cre, cph], Bob Rigby [aut], Fernanda De Bastiani [aut]</td>
</tr>
<tr>
<td>Description:</td>
<td>Computational intensive calculations for Generalized Additive Models for Location Scale and Shape, &lt;<a href="https://doi.org/10.1111%2Fj.1467-9876.2005.00510.x">doi:10.1111/j.1467-9876.2005.00510.x</a>&gt;. </td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mikis Stasinopoulos &lt;d.stasinopoulos@londonmet.ac.uk&gt;</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.2.1), gamlss, foreach, doParallel, methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>gamlss.data, gamlss.dist, glmnet</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.gamlss.com/">https://www.gamlss.com/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-28 09:02:52 UTC; dimitriosstasinopoulos</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-28 10:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='gamlss.foreach-package'>Computational Intensive Functions within GAMLSS</h2><span id='topic+gamlss.foreach-package'></span><span id='topic+gamlss.foreach'></span>

<h3>Description</h3>

<p>This package is intended for functions needed parallel computations  provided by the package <span class="pkg">foreach</span>. 
</p>
<p>At the moment the following functions exist:
</p>
<p><code>centiles.boot()</code>, which is designed get bootstrap confidence intervals for centile curves
</p>
<p><code>fitRolling()</code>, rolling regression  which is common in time series analysis when one step ahead forecasts is required.
</p>
<p><code>fitPCR()</code>, for univariate  principal component regression. I
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> gamlss.foreach</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Parallel Computations for Distributional Regression</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.1-6</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-08-28</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Mikis Stasinopoulos [aut, cre, cph], Bob Rigby [aut], Fernanda De Bastiani [aut]</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Computational intensive calculations for Generalized Additive Models for Location Scale and Shape, &lt;doi:10.1111/j.1467-9876.2005.00510.x&gt;. </td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Mikis Stasinopoulos &lt;d.stasinopoulos@londonmet.ac.uk&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 2.2.1), gamlss, foreach, doParallel, methods</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> gamlss.data, gamlss.dist, glmnet</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2 | GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://www.gamlss.com/</td>
</tr>
<tr>
 <td style="text-align: left;">
NeedsCompilation: </td><td style="text-align: left;"> no</td>
</tr>
<tr>
 <td style="text-align: left;">
Packaged: </td><td style="text-align: left;"> 2021-03-04 15:27:15 UTC; dimitriosstasinopoulos</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
BayesianBoot            Non parametric and Bayesian Bootstrapping for
                        GAMLSS models
centiles.boot           Bootstrapping centiles curves estimated using
                        GAMLSS
fitPCR                  Function to fit simple Principal Component
                        Regression.
fitRolling              Function to Fit Rolling Regression in gamlss
fitted.PCR              Methods for PCR objects
gamlss.foreach-package
                        Computational Intensive Functions within GAMLSS
pc                      Functions to Fit Principal Component Regression
                        in GAMLSS
which.Data.Corr         Detecting Hight Pair-Wise Correlations in Data
</pre>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos, <a href="mailto:d.stasinopoulos@londonmet.ac.uk">d.stasinopoulos@londonmet.ac.uk</a>,and Bob Rigby 
<a href="mailto:r.rigby@londonmet.ac.uk">r.rigby@londonmet.ac.uk</a>  
</p>
<p>Maintainer: Mikis Stasinopoulos, <a href="mailto:d.stasinopoulos@londonmet.ac.uk">d.stasinopoulos@londonmet.ac.uk</a> 
</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape, (with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC, <a href="https://doi.org/10.1201/9780429298547">doi:10.1201/9780429298547</a>. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://doi.org/10.18637/jss.v023.i07">doi:10.18637/jss.v023.i07</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  <a href="https://doi.org/10.1201/b21973">doi:10.1201/b21973</a>
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="gamlss.html#topic+gamlss">gamlss</a></code>,<code><a href="gamlss.html#topic+centiles">centiles</a></code>,<code><a href="gamlss.html#topic+centiles.pred">centiles.pred</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(gamlss.foreach)
# fixed degrees of freedom
cl &lt;- makePSOCKcluster(2)
registerDoParallel(2)
data(db)
nage &lt;- with(db, age^0.33)
ndb &lt;- data.frame(db, nage)
m1 &lt;- gamlss(head~cs(nage, 12), sigma.fo=~cs(nage,4), nu.fo=~nage, 
             tau.fo=~nage, family=BCT, data=ndb)
test1 &lt;- centiles.boot(m1, xname="nage", xvalues=seq(0.01,20,0.2),B=10, power=0.33)
test1
plot(test1)
# degrees of freedom varying
m2 &lt;- gamlss(head~pb(nage), sigma.fo=~pb(nage), nu.fo=~pb(nage), 
             tau.fo=~pb(nage), family=BCT, data=ndb)
test2 &lt;- centiles.boot(m2, xname="nage", xvalues=seq(0.01,20,0.2),B=10, power=0.33)
stopImplicitCluster()
test2
plot(test2)

</code></pre>

<hr>
<h2 id='BayesianBoot'>
Non parametric and Bayesian Bootstrapping for  GAMLSS models
</h2><span id='topic+BayesianBoot'></span><span id='topic+NonParametricBoot'></span>

<h3>Description</h3>

<p>The function takes a GAMLSS fitted model and bootstrap it to create <code>B</code> bootstrap samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NonParametricBoot(obj, data = NULL, B = 100, newdata = NULL)

BayesianBoot(obj, data = NULL, B = 100, newdata = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BayesianBoot_+3A_obj">obj</code></td>
<td>
<p>a <code>gamlss</code> fitted model</p>
</td></tr>
<tr><td><code id="BayesianBoot_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="BayesianBoot_+3A_b">B</code></td>
<td>
<p>the number of boostrap samples</p>
</td></tr>
<tr><td><code id="BayesianBoot_+3A_newdata">newdata</code></td>
<td>
<p>new data for <code>predictAll()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function  <code>NonParametric()</code> perform non-parametric bootstraping, Efron and Tibshirani (1993) while the function  <code>BayesianBoot()</code> perform Bayesian bootstrap
Rubin (1981)</p>


<h3>Value</h3>

<p>An <code>Bayesian.boot</code> object with elements
</p>
<table role = "presentation">
<tr><td><code>boot</code></td>
<td>
<p>the bootstrap samples</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>the required number of boostraps</p>
</td></tr>
<tr><td><code>trueB</code></td>
<td>
<p>the actual number of boostraps</p>
</td></tr>
<tr><td><code>par</code></td>
<td>
<p>the distribution parameters</p>
</td></tr>
<tr><td><code>orig.coef</code></td>
<td>
<p>the fitted coeficients from the GAMLSS model</p>
</td></tr>
<tr><td><code>orig.call</code></td>
<td>
<p>the call from the GAMLSS model</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos, <a href="mailto:d.stasinopoulos@londonmet.ac.uk">d.stasinopoulos@londonmet.ac.uk</a>
</p>


<h3>References</h3>

<p>Efron, B. and Tibshirani, R, (1993), <em>An introduction to the bootstrap</em>,
Chapman and Hall New York, Monographs on statistics and applied probability,
vulume 57.
</p>
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape, (with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC, <a href="https://doi.org/10.1201/9780429298547">doi:10.1201/9780429298547</a>. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Rubin, D. B. (1981) the bayesian bootstrap. <em>The annals of statistics</em>,
pp. 130-134.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://doi.org/10.18637/jss.v023.i07">doi:10.18637/jss.v023.i07</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  <a href="https://doi.org/10.1201/b21973">doi:10.1201/b21973</a>
</p>
<p>Stasinopoulos, M. D., Rigby, R. A., and De Bastiani F., (2018) GAMLSS: a distributional regression approach, <em>Statistical Modelling</em>, Vol. <b>18</b>, 
pp, 248-273, SAGE Publications Sage India: New Delhi, India. <a href="https://doi.org/10.1177/1471082X18759144">doi:10.1177/1471082X18759144</a>
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

 <p><code><a href="gamlss.html#topic+gamlss">gamlss</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;-gamlss(y~x+qrt, data=aids, family=NBI())
registerDoParallel(cores = 2)
B1 &lt;- BayesianBoot(m1)
summary(B1)
plot(B1)
B2 &lt;- NonParametricBoot(m1)
stopImplicitCluster()
summary(B2)
plot(B2)
</code></pre>

<hr>
<h2 id='centiles.boot'>Bootstrapping centiles curves estimated using GAMLSS</h2><span id='topic+centiles.boot'></span><span id='topic+print.centiles.boot'></span><span id='topic+summary.centiles.boot'></span><span id='topic+plot.centiles.boot'></span>

<h3>Description</h3>

<p>This is a function designed for non-parametric bootstrapping centile curves (growth curves) when the fitted model is fitted using GAMLSS with a single explanatory variable (usually age). 
Non parametric  bootstrapping resample the data with replacement.  
The model is refitted for each bootstraps sample.  
Notes that if smoothing is used in the model, it is advisable (but not necessary) that the smoothing degree of freedom are fixed throughout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centiles.boot(obj, data = NULL, xname = NULL, xvalues = NULL, 
  power = NULL, cent = c(2.5, 50, 97.5), B = 100, calibration = FALSE,
  ...)
             
## S3 method for class 'centiles.boot'
print(x, ...) 
## S3 method for class 'centiles.boot'
summary(object, fun = "mean", ...)              
## S3 method for class 'centiles.boot'
plot(x, quantiles = c(0.025, 0.975), 
       ylab = NULL, xlab = NULL, location = "median", original = FALSE, 
       scheme = c("shaded", "lines"), col.cent = "darkred", 
       col.se = "orange", col.shaded = "gray", lwd.center = 1.5, ...)  
             
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="centiles.boot_+3A_obj">obj</code></td>
<td>
<p>a fitted gamlss object for the function <code>centiles.boot()</code></p>
</td></tr>
<tr><td><code id="centiles.boot_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables occurring in the formula. 
If it is missing, then it will try to get the data frame from the GAMLSS object</p>
</td></tr>
<tr><td><code id="centiles.boot_+3A_xname">xname</code></td>
<td>
<p>the name (as character) of the unique explanatory variable (it has to be the same as in the original fitted model)</p>
</td></tr>
<tr><td><code id="centiles.boot_+3A_xvalues">xvalues</code></td>
<td>
<p>a vector containing the new x-variable  values for which bootstrap simulation predictions will be made</p>
</td></tr>
<tr><td><code id="centiles.boot_+3A_power">power</code></td>
<td>
<p>if power transformation is needed (but see example below)</p>
</td></tr>
<tr><td><code id="centiles.boot_+3A_cent">cent</code></td>
<td>
<p>a vector of centile values for which the predicted centiles 
have to be evaluated, by default is: 2.5, 50 and 97.5</p>
</td></tr>
<tr><td><code id="centiles.boot_+3A_b">B</code></td>
<td>
<p>the number of bootstraps </p>
</td></tr>
<tr><td><code id="centiles.boot_+3A_calibration">calibration</code></td>
<td>
<p>whether to calibrate the centiles, default is FALSE</p>
</td></tr>
<tr><td><code id="centiles.boot_+3A_...">...</code></td>
<td>
<p>for extra arguments, for the <code>centiles.pred()</code> function</p>
</td></tr>
<tr><td><code id="centiles.boot_+3A_x">x</code></td>
<td>
<p>an <code>a centiles.boot</code> object</p>
</td></tr>
<tr><td><code id="centiles.boot_+3A_object">object</code></td>
<td>
<p>an <code>a centiles.boot</code> object</p>
</td></tr>
<tr><td><code id="centiles.boot_+3A_fun">fun</code></td>
<td>
<p>for the <code>summary()</code> function this is a summary statistics function. The &quot;mean&quot; is the  default</p>
</td></tr>
<tr><td><code id="centiles.boot_+3A_quantiles">quantiles</code></td>
<td>
<p>specify  which quantiles (in the <code>plot()</code> function)  of the bootstrap distribution to plot</p>
</td></tr> 
<tr><td><code id="centiles.boot_+3A_location">location</code></td>
<td>
<p>which location parameter to plot, with default the mean</p>
</td></tr> 
<tr><td><code id="centiles.boot_+3A_original">original</code></td>
<td>
<p>logical if TRUE the original predicted centile values at the given <code>xvalues</code> are plotted (the default is FALSE)</p>
</td></tr>
<tr><td><code id="centiles.boot_+3A_ylab">ylab</code></td>
<td>
<p>y label for the plot </p>
</td></tr>
<tr><td><code id="centiles.boot_+3A_xlab">xlab</code></td>
<td>
<p>x label for the plot</p>
</td></tr>
<tr><td><code id="centiles.boot_+3A_scheme">scheme</code></td>
<td>
<p>which scheme of plotting to use  <code>"shaded"</code> or <code>"lines"</code></p>
</td></tr>
<tr><td><code id="centiles.boot_+3A_col.cent">col.cent</code></td>
<td>
<p>the colour of the centile in the <code>"shaded"</code> scheme, with <code>"darkred"</code> as default</p>
</td></tr>
<tr><td><code id="centiles.boot_+3A_col.se">col.se</code></td>
<td>
<p>the colour of the standard errors for the <code>"lines"</code> scheme with default <code>"orange"</code></p>
</td></tr>
<tr><td><code id="centiles.boot_+3A_col.shaded">col.shaded</code></td>
<td>
<p>the colour of the standard errors for the <code>"shaded"</code> scheme with default &quot;gray&quot;</p>
</td></tr>
<tr><td><code id="centiles.boot_+3A_lwd.center">lwd.center</code></td>
<td>
<p>the width of the central line</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is designed for bootstrapping centiles curves. 
It can be used to provide bootstrap means, standard deviations and quantiles, 
so the variability of the centile curves 
can be accessed (eg. by deriving confidence bands for centile curves).   
</p>


<h3>Value</h3>

<p>The function returns an object <code>centile.boot</code> which has its own 
<code>print()</code>, <code>summary()</code>, and <code>plot()</code> functions.  
The object  <code>centile.boot</code> is a list with elements:
</p>
<table role = "presentation">
<tr><td><code>boot0</code></td>
<td>
<p>Containing centile predictions from the fitted model to the original data using the <code>centile.pred()</code> function  on the new <code>xvalues</code>. This can be compared with the <code>mean</code> 
of the object to assess the bias</p>
</td></tr>
<tr><td><code>boot</code></td>
<td>
<p>A list of length <code>trueB</code>, each containing a matrix of dimension 
<code>length(xvalues)</code> by <code>(length(cent)+1)</code></p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>The number of bootstrap samples requested</p>
</td></tr>
<tr><td><code>trueB</code></td>
<td>
<p>The number of actual bootstrapping simulations performed. It is equal to 
<code>B-number of failed simulations</code></p>
</td></tr>
<tr><td><code>xvalues</code></td>
<td>
<p>The new x-variable  values for which the bootstrap simulation has taken place  </p>
</td></tr>
<tr><td><code>cent</code></td>
<td>
<p>The centile values requested</p>
</td></tr>
<tr><td><code>original.call</code></td>
<td>
<p>The call of the original gamlss fitted model</p>
</td></tr>
<tr><td><code>yname</code></td>
<td>
<p>The name of the response variable, used in the <code>plot()</code> function</p>
</td></tr>
<tr><td><code>xname</code></td>
<td>
<p>The name of the x-variable, used in the <code>plot()</code> function</p>
</td></tr>
<tr><td><code>failed</code></td>
<td>
<p>A vector containing values identifying which of the bootstrap simulations had 
failed to converge and therefore have not included in the list <code>boot</code>
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>See example below of how to use the function when a power transformation is used for the x-variable
</p>
<p>Do not forget to use <code>registerDoParallel(cores = NUMBER)</code> or
<code>cl &lt;- makeCluster(NUMBER)</code> and 
<code>registerDoParallel(cl)</code>
before calling the function <code>centiles.boot()</code>. Use   <code>closeAllConnections()</code> after the fits to close the connections. Where <code>NUMBER</code> depends on the machine used. 
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos, <a href="mailto:d.stasinopoulos@londonmet.ac.uk">d.stasinopoulos@londonmet.ac.uk</a>, Bob Rigby 
<a href="mailto:r.rigby@londonmet.ac.uk">r.rigby@londonmet.ac.uk</a> and Calliope Akantziliotou</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape, (with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC, <a href="https://doi.org/10.1201/9780429298547">doi:10.1201/9780429298547</a>. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://doi.org/10.18637/jss.v023.i07">doi:10.18637/jss.v023.i07</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  <a href="https://doi.org/10.1201/b21973">doi:10.1201/b21973</a>
</p>
<p>Stasinopoulos, M. D., Rigby, R. A., and De Bastiani F., (2018) GAMLSS: a distributional regression approach, <em>Statistical Modelling</em>, Vol. <b>18</b>, 
pp, 248-273, SAGE Publications Sage India: New Delhi, India. <a href="https://doi.org/10.1177/1471082X18759144">doi:10.1177/1471082X18759144</a>
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

 <p><code><a href="gamlss.html#topic+gamlss">gamlss</a></code>,<code><a href="gamlss.html#topic+centiles">centiles</a></code>,<code><a href="gamlss.html#topic+centiles.pred">centiles.pred</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># bring the data and fit the model
data(abdom) 
m1&lt;-gamlss(y~poly(x,2), sigma.fo=~x, data=abdom, family=BCT)
# perform the bootstrap simulation 
# (only 10 bootstrap samples here)
registerDoParallel(cores = 2)
boC&lt;-centiles.boot(m1,xname="x", xvalues=c(15,20,25,30,35,40,45), B=10)
stopImplicitCluster()
boC
# get summaries
summary(boC, fun="mean")
#summary(boC, "median")
#summary(boC, "quantile", 0.025)
plot(boC)

# with transformation in x within the formula
# unsuitable for large data set since it is slow
m2&lt;-gamlss(y~cs(x^0.5),sigma.fo=~cs(x^0.5), data=abdom, family=BCT) 
boC&lt;-centiles.boot(m2,xname="x", xvalues=c(15,20,25,30,35,40,45), B=10)
summary(boC)
plot(boC)
#
# now with x-variable previously transformed
# better for large data set as it is faster 
nx&lt;-abdom$x^0.5
newd&lt;-data.frame(abdom, nx=abdom$x^0.5)
m3&lt;-gamlss(y~cs(nx),sigma.fo=~cs(nx), data=newd, family=BCT)
boC &lt;- centiles.boot(m3, xname="nx", xvalues=c(15,20,25,30,35,40,45), data=newd, power=0.5, B=10)
summary(boC)
#plot(boC)
# the original variables can be added in
#points(y~x,data=abdom)
</code></pre>

<hr>
<h2 id='fitPCR'>
Function to fit simple Principal Component Regression.
</h2><span id='topic+fitPCR'></span>

<h3>Description</h3>

<p>This function is a univariate (i.e. one response) version of a principal component regression. It is based on the function <code>svdpc.fit()</code>
of package <span class="pkg">pls</span> but it has been generalised to take prior weights. It gets a (single) response variable <code>y</code> (n x 1) and a matrix of  explanatory variables of dimensions n x p  and fits different  principal component regressions up to principal component M. Note that M can be less or equal to p (if <code class="reqn">n &gt; p</code>) or less or equal to n if <code class="reqn">n &lt;p</code>, that is, when there they are less observations than variables.
</p>
<p>The function is used by the GAMLSS additive term function <code>pcr()</code> to fit a principal component regression model within <code>gamlss()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
fitPCR(x = NULL, y = NULL, weights = rep(1, n), 
       M = NULL, df = NULL, supervised = FALSE, 
       k = 2, r = 0.2, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitPCR_+3A_x">x</code></td>
<td>
<p>a matrix of explanatory variables</p>
</td></tr>
<tr><td><code id="fitPCR_+3A_y">y</code></td>
<td>
<p>the response variable</p>
</td></tr>
<tr><td><code id="fitPCR_+3A_weights">weights</code></td>
<td>
<p>prior weights</p>
</td></tr>
<tr><td><code id="fitPCR_+3A_m">M</code></td>
<td>
<p>if set  specifies the maximum number of components to be considered</p>
</td></tr>
<tr><td><code id="fitPCR_+3A_df">df</code></td>
<td>
<p>if set specifies the number of components</p>
</td></tr>
<tr><td><code id="fitPCR_+3A_supervised">supervised</code></td>
<td>
<p>whether supervised PCR should be used or not, <code>default=FALSE</code></p>
</td></tr>
<tr><td><code id="fitPCR_+3A_k">k</code></td>
<td>
<p>the penalty of GAIC</p>
</td></tr>
<tr><td><code id="fitPCR_+3A_r">r</code></td>
<td>
<p>a correlation value (between zero and one) used smoothing parameter when <code>supervised=TRUE</code></p>
</td></tr>
<tr><td><code id="fitPCR_+3A_plot">plot</code></td>
<td>
<p>Whether to plot the coefficient path</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>More details here
</p>


<h3>Value</h3>

<p>It returns a object <code>PCR</code> which can be used with methods <code>print()</code>, 
<code>summary()</code>, <code>plot()</code>, <code>fitted()</code> and <code>coef()</code>. The object has elements:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>The beta coefficients for 1 to M principal components</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>the n x M dimensional matrix T o=f scores</p>
</td></tr> 
<tr><td><code>loadings</code></td>
<td>
<p>the p x M dimensional matrix P of loadings</p>
</td></tr>  
<tr><td><code>gamma</code></td>
<td>
<p>the first M principal component coefficients</p>
</td></tr>                 <tr><td><code>se.gamma</code></td>
<td>
<p>the standard errors of the  M principal component coefficients</p>
</td></tr>
<tr><td><code>center</code></td>
<td>
<p>the location parameters used to scale the x's</p>
</td></tr> 
<tr><td><code>scale</code></td>
<td>
<p>the scale parameters used to scale the x's</p>
</td></tr> 
<tr><td><code>fitted.values</code></td>
<td>
<p>matrix of n x M dimensions</p>
</td></tr>  
<tr><td><code>Xvar</code></td>
<td>
<p>sum of squares  of the scores i.e. diag(T'T)</p>
</td></tr> 
<tr><td><code>gaic</code></td>
<td>
<p>The GAIC values</p>
</td></tr> 
<tr><td><code>pc</code></td>
<td>
<p>number  of PC i.e. which value of  GAIC has the minimum</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>which penalty for GAIC</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>the maximum of PC tried</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>The estimated sigma from the M fitted components</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>The n x M matrix of the residuals</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos, Robert Rigby and Fernanda De Bastiani.</p>


<h3>References</h3>

<p>Bjorn-Helge Mevik, Ron Wehrens and Kristian Hovde Liland
(2019). pls: Partial Least Squares and Principal Component
Regression. R package version 2.7-2.
https://CRAN.R-project.org/package=pls
</p>
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape, (with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC, <a href="https://doi.org/10.1201/9780429298547">doi:10.1201/9780429298547</a>. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://doi.org/10.18637/jss.v023.i07">doi:10.18637/jss.v023.i07</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  <a href="https://doi.org/10.1201/b21973">doi:10.1201/b21973</a>
</p>
<p>Stasinopoulos, M. D., Rigby, R. A., and De Bastiani F., (2018) GAMLSS: a distributional regression approach, <em>Statistical Modelling</em>, Vol. <b>18</b>, 
pp, 248-273, SAGE Publications Sage India: New Delhi, India. <a href="https://doi.org/10.1177/1471082X18759144">doi:10.1177/1471082X18759144</a>
</p>
<p>Stasinopoulos, M. D., Rigby, R. A., Georgikopoulos N., and De Bastiani F., (2021) Principal  component regression in GAMLSS  applied to Greek-German government bond yield spreads, <em>Statistical Modelling</em> 
<a href="https://doi.org/10.1177/1471082X211022980">doi:10.1177/1471082X211022980</a>.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pc">pc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(glmnet)
data(QuickStartExample)
attach(QuickStartExample)
hist(y, main="(a)")
if (is.null(rownames(x))) colnames(x) &lt;- paste0("X", 
    seq(1:dim(x)[2]))
############################################################
# fitPCR
############################################################
# fitting
registerDoParallel(cores = 2)
MM&lt;- fitPCR(x,y, k=log(100))
stopImplicitCluster()
points(MM$coef[,16]~rep(16,20))
names(MM)
MM
#----------------------------------------------------------
# plotting
plot(MM)
plot(MM, "gaic")
#----------------------------------------------------------
print(MM)
#----------------------------------------------------------
coef(MM)                        # the gammas
coef(MM, param="beta")          # the betas
coef(MM, param="beta", pc=1)  # at position 1
#----------------------------------------------------------
# plotting y and and fitted balues at different points
plot(y)
points(fitted(MM, pc=3), col=2)
points(fitted(MM, pc=20), col=3)
#----------------------------------------------------------
# variance covariance 
vcov(MM, type="se", pc=1) 
vcov(MM, type="se", pc=2)
vcov(MM, type="se", pc=20)
# library(corrplot)
# corrplot(vcov(MM, type="cor", pc=10))
# corrplot(vcov(MM, type="cor", pc=20))
#----------------------------------------------------------
summary(MM)
summary(MM, param="beta", pc=15)
summary(MM, param ="beta", pc=3) 
summary(MM, param ="beta") # at default
#----------------------------------------------------------
predict(MM, newdata= x[1:5,])
fitted(MM)[1:5]
</code></pre>

<hr>
<h2 id='fitRolling'>Function to Fit Rolling Regression in gamlss</h2><span id='topic+fitRolling'></span>

<h3>Description</h3>

<p>Rolling regression is common in time series analysis when one step ahead forecasts is required. The function <code>fitRolling()</code> works as follows: A model is fitted first to the whole data set using <code>gamlss()</code>. Then the function <code>fitRolling()</code> can be used. The function uses a fixed size rolling widow  i.e.  365 days. The model is refitted repeatedly for the different windows over time (like a local regression in smoothing).  Each time one step ahead forecast of distribution parameters are saved together with the prediction global deviance. The result is presented as a matrix  with time as rows and parameters and the prediction deviance as columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitRolling(obj, data, window = 365, as.time = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitRolling_+3A_obj">obj</code></td>
<td>
<p>a gamlss fitted model</p>
</td></tr>
<tr><td><code id="fitRolling_+3A_data">data</code></td>
<td>
<p>the original data of the fitted model</p>
</td></tr>
<tr><td><code id="fitRolling_+3A_window">window</code></td>
<td>
<p>the number of observation to include in the window (typically this will be a year)</p>
</td></tr>
<tr><td><code id="fitRolling_+3A_as.time">as.time</code></td>
<td>
<p>if a column indicating time exist in the data set this can be specified here</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the total observations are <code>N</code> and the window size <code>n</code> then we will need <code>N-n</code> different fits. The parallelization of the fits is achieved using the function <code>foreach()</code> from the package <span class="pkg">foreach</span>.  
</p>


<h3>Value</h3>

<p>Returns a matrix containing as columns the one ahead prediction parameters of the distribution as well as the  prediction global deviance.</p>


<h3>Note</h3>

<p>Do not forget to use <code>registerDoParallel(cores = NUMBER)</code> or
<code>cl &lt;- makeCluster(NUMBER)</code> and 
<code>registerDoParallel(cl)</code>
before calling the function <code>fitRolling()</code> and <code>closeAllConnections()</code> after the fits. Where <code>NUMBER</code> depends on the machine used. 
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos, <a href="mailto:d.stasinopoulos@londonmet.ac.uk">d.stasinopoulos@londonmet.ac.uk</a>
</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape, (with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC, <a href="https://doi.org/10.1201/9780429298547">doi:10.1201/9780429298547</a>. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://doi.org/10.18637/jss.v023.i07">doi:10.18637/jss.v023.i07</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  <a href="https://doi.org/10.1201/b21973">doi:10.1201/b21973</a>
</p>
<p>Stasinopoulos, M. D., Rigby, R. A., and De Bastiani F., (2018) GAMLSS: a distributional regression approach, <em>Statistical Modelling</em>, Vol. <b>18</b>, 
pp, 248-273, SAGE Publications Sage India: New Delhi, India. <a href="https://doi.org/10.1177/1471082X18759144">doi:10.1177/1471082X18759144</a>
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

 <p><code><a href="gamlss.html#topic+gamlss">gamlss</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# fitting the aids data 45 observations
m1 &lt;- gamlss(formula = y ~ pb(x) + qrt, family = NBI, data = aids) 
# get rolling regression with a window of 30
# there are 45-40=15 fits to do
# declaring cores (not needed for small data like this)
registerDoParallel(cores = 2)
FF &lt;- fitRolling(m1, data=aids, window=30)
FF
stopImplicitCluster()
# check the first prediction
m30_1 &lt;-update(m1, data=aids[1:30,])
predictAll(m30_1, newdata=aids[31,],output="matrix")
FF[1,]
# plot all the data 
plot(y~x, data=aids, xlim=c(0,45), ylim=c(0, 700), col=gray(.8))
# the first 30 observations
points(y~x, data=aids[1:30,], xlim=c(0,45))
# One step ahead forecasts
lines(FF[,"mu"]~as.numeric(rownames(FF)), col="red")
lines(fitted(m1)~aids$x, col="blue")

</code></pre>

<hr>
<h2 id='fitted.PCR'>Methods for PCR objects</h2><span id='topic+fitted.PCR'></span><span id='topic+coef.PCR'></span><span id='topic+plot.PCR'></span><span id='topic+summary.PCR'></span><span id='topic+predict.PCR'></span><span id='topic+vcov.PCR'></span>

<h3>Description</h3>

<p>The functions below are methods for PCR objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PCR'
fitted(object, pc = object$pc, ...)
## S3 method for class 'PCR'
plot(x, type = c("path", "gaic"),
                   labels = TRUE, cex = 0.8, ...)
## S3 method for class 'PCR'
coef(object, param = c("gamma", "beta"), 
              pc = object$pc, ...)
## S3 method for class 'PCR'
predict(object, newdata = NULL, 
                pc = object$pc, ...)
## S3 method for class 'PCR'
vcov(object, pc = object$pc, 
        type = c("vcov", "cor", "se", "all"),
                      ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.PCR_+3A_object">object</code>, <code id="fitted.PCR_+3A_x">x</code></td>
<td>
<p>an PCR object</p>
</td></tr>
<tr><td><code id="fitted.PCR_+3A_pc">pc</code></td>
<td>
<p>the number of PC  (by default the one minimising the local GAIC)</p>
</td></tr>
<tr><td><code id="fitted.PCR_+3A_type">type</code></td>
<td>
<p>for <code>plot()</code> whether to plot the path of coefficients or the path of GAIC and for <code>vcov()</code> whether variance covariance, correlation or se's</p>
</td></tr>
<tr><td><code id="fitted.PCR_+3A_param">param</code></td>
<td>
<p>getting the gamma or the beta coefficients</p>
</td></tr>
<tr><td><code id="fitted.PCR_+3A_newdata">newdata</code></td>
<td>
<p>new data for prediction</p>
</td></tr>
<tr><td><code id="fitted.PCR_+3A_labels">labels</code></td>
<td>
<p>whether to plot the labels of the variables</p>
</td></tr>
<tr><td><code id="fitted.PCR_+3A_cex">cex</code></td>
<td>
<p>the size of the text when plotting the labels of the variables</p>
</td></tr>
<tr><td><code id="fitted.PCR_+3A_...">...</code></td>
<td>
<p>for extra arguments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos <a href="mailto:d.stasinopoulos@londonmet.ac.uk">d.stasinopoulos@londonmet.ac.uk</a>, Bob Rigby and Fernada De Bastiani  </p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape, (with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+fitPCR">fitPCR</a></code> </p>

<hr>
<h2 id='pc'>Functions to Fit Principal Component Regression in GAMLSS</h2><span id='topic+pc'></span><span id='topic+pcr'></span><span id='topic+gamlss.pc'></span><span id='topic+gamlss.pcr'></span><span id='topic+getSVD'></span>

<h3>Description</h3>

<p>The functions <code>pcr()</code> and <code>pc()</code> can be use to fit  principal component regression (PCR) within a GAMLSS model. They  can be used as an extra additive term (together with other additive terms for example <code>pb()</code>) but the idea is mainly to be used on their own as a way of reducing the dimensionality of the the (scaled) x-variables. The functions can be used even when the number of the explanatory variables say <code>p</code> is greater than the number of observations <code>n</code>. 
</p>
<p>The two functions differ on the way PCR is implemented within the GAMLSS algorithm see for example Stasinopoulos et.al (2021).
In the function <code>pc()</code> the singular value decomposition of the scaled x's is done in the beginning and different re-weighted linear models are fitted on the PC scores see  algorithm  1 in Stasinopoulos et al. (2021). In the function <code>pcr()</code> at each iteration a new weighted PCR is performed using the function <code>fitPCR()</code> see algorithm  2 in Stasinopoulos et al. (2021). 
</p>
<p>The functions <code>gamlss.pcr()</code> and <code>gamlss.pc()</code> are supporting functions. The  are not intended to be called directly by users. The function <code>gamlss.pc()</code> is using the linear model function <code>lm()</code> to fit the first principal components while the function codegamlss.pcr() uses <code>fitPCR()</code>.
</p>
<p>The function <code>getSVD()</code> creates a singular value decomposition of a design matrix <code>X</code> using the <span class="rlang"><b>R</b></span> function <code>La.svd()</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pc(x.vars = NULL, x = NULL, x.svd = NULL, df = NULL, 
   center = TRUE, scale = TRUE, tol = NULL, 
   max.number = min(p, n), k = log(n), 
   method = c( "t-values","GAIC","k-fold"))

pcr(x.vars = NULL, x = NULL, df = NULL, 
    M = min(p, n), k = log(n), 
    r = 0.2, method = c("GAIC", "t-values", "SPCR"))

gamlss.pc(x, y, w, xeval = NULL, ...)

gamlss.pcr(x, y, w, xeval = NULL, ...)

getSVD(x = NULL, nu = min(n, p), nv = min(n, p))

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pc_+3A_x.vars">x.vars</code></td>
<td>
<p>A character vector showing the names of the x-variables. The variables should exist in the original <code>data</code> argument declared in the <code>gamlss()</code> function</p>
</td></tr>
<tr><td><code id="pc_+3A_x">x</code></td>
<td>
<p>For the function <code>pc()</code> and <code>getSVD()</code> <code>x</code> is a design matrix of dimensions <code>n x p</code> contain all the explanatory variables terms. 
</p>
<p>For the function <code>gamlss.pc()</code>, <code>x</code> is a vector of zeros which curries all in information needed for the principal components fits in its attributes
</p>
</td></tr>
<tr><td><code id="pc_+3A_x.svd">x.svd</code></td>
<td>
<p>A list created by the function <code>getSVD()</code>. This will speed up the time of fitting, (especial for large data sets), since all  the principal components calculation are done in advance. Also if all the parameters of the distribution are modelled by principal components the calculation needed to be done only once.</p>
</td></tr>
<tr><td><code id="pc_+3A_df">df</code></td>
<td>
<p>(if is not <code>NULL</code>) the number of principal components to be fitted. If it is <code>NULL</code> the number of principal components is automatically calculated  using a GAIC criterion.</p>
</td></tr>
<tr><td><code id="pc_+3A_center">center</code></td>
<td>
<p>whether to center the explanatory variables with default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="pc_+3A_scale">scale</code></td>
<td>
<p>whether to scale the explanatory variables with default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="pc_+3A_r">r</code></td>
<td>
<p>the cut point for correlation coefficient to be use <code>SPCR</code></p>
</td></tr> 
<tr><td><code id="pc_+3A_tol">tol</code></td>
<td>
<p>CHECK THIS?????</p>
</td></tr>
<tr><td><code id="pc_+3A_max.number">max.number</code>, <code id="pc_+3A_m">M</code></td>
<td>
<p>The maximum number of principal component to be used in the fit.</p>
</td></tr>
<tr><td><code id="pc_+3A_method">method</code></td>
<td>
<p>method used for choosing the number of components</p>
</td></tr>
<tr><td><code id="pc_+3A_k">k</code></td>
<td>
<p>the penalty for GAIC</p>
</td></tr>
<tr><td><code id="pc_+3A_y">y</code></td>
<td>
<p>the iterative response variable</p>
</td></tr>
<tr><td><code id="pc_+3A_w">w</code></td>
<td>
<p>the iterative weights </p>
</td></tr>
<tr><td><code id="pc_+3A_xeval">xeval</code></td>
<td>
<p>used in prediction</p>
</td></tr>
<tr><td><code id="pc_+3A_...">...</code></td>
<td>
<p>for extra arguments</p>
</td></tr>  
<tr><td><code id="pc_+3A_nu">nu</code></td>
<td>
<p>the number of left singular vectors to be computed. This must between 0 and n = nrow(x).</p>
</td></tr>
<tr><td><code id="pc_+3A_nv">nv</code></td>
<td>
	
<p>the number of right singular vectors to be computed. This must be between 0 and p = ncol(x).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are three different ways of declaring the list of x-variables (two for the function <code>pcr()</code>):
</p>
<p><em>x.vars</em>: this should be a character vector having the names of the explanatory variables. The names  should be  contained in the names  of variables of the <code>data</code> argument of the function <code>gamlss()</code>, see example below.
</p>
<p><em>x</em>: This should be a design matrix (preferable unscaled since this could create problems when try to predict), see examples.
</p>
<p><em>x.svd</em>: This should be a list created by the function <code>getSVD()</code> which is used as an argument a design matrix, see examples.
</p>


<h3>Value</h3>

<p>For the function <code>pc()</code> returns an object <code>pc</code> with elements <code>"coef"</code>, <code>"beta"</code>, <code>"pc"</code>,   <code>"edf"</code>,  <code>"AIC"</code>. The object <code>pc</code> has methods <code>plot()</code>,  <code>coef()</code> and <code>print()</code>. 
</p>
<p>For the function <code>pcr()</code> returns an object <code>PCR</code> see for the help for function <code>fitPCR</code>.  
</p>


<h3>Note</h3>

<p> Do not forget to use <code>registerDoParallel(cores = NUMBER)</code> or
<code>cl &lt;- makeCluster(NUMBER)</code> and 
<code>registerDoParallel(cl)</code>
before calling the function <code>pc()</code> without specifying the degrees of freedom.  Use <code>closeAllConnections()</code> after the fits to close the connections. The <code>NUMBER</code> depends on the machine used. 
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos <a href="mailto:d.stasinopoulos@londonmet.ac.uk">d.stasinopoulos@londonmet.ac.uk</a>, Bob Rigby 
</p>


<h3>References</h3>

<p>Bjorn-Helge Mevik, Ron Wehrens and Kristian Hovde Liland
(2019). pls: Partial Least Squares and Principal Component
Regression. R package version 2.7-2.
https://CRAN.R-project.org/package=pls
</p>
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape, (with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC, <a href="https://doi.org/10.1201/9780429298547">doi:10.1201/9780429298547</a>. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://doi.org/10.18637/jss.v023.i07">doi:10.18637/jss.v023.i07</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  <a href="https://doi.org/10.1201/b21973">doi:10.1201/b21973</a>
</p>
<p>Stasinopoulos, M. D., Rigby, R. A., and De Bastiani F., (2018) GAMLSS: a distributional regression approach, <em>Statistical Modelling</em>, Vol. <b>18</b>, 
pp, 248-273, SAGE Publications Sage India: New Delhi, India. <a href="https://doi.org/10.1177/1471082X18759144">doi:10.1177/1471082X18759144</a>
</p>
<p>Stasinopoulos, M. D., Rigby, R. A., Georgikopoulos N., and De Bastiani F., (2021) Principal  component regression in GAMLSS  applied to Greek-German government bond yield spreads, <em>Statistical Modelling</em> 
<a href="https://doi.org/10.1177/1471082X211022980">doi:10.1177/1471082X211022980</a>.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+centiles.boot">centiles.boot</a></code>, <code><a href="#topic+fitRolling">fitRolling</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># the pc() function
# fitting the same model using different arguments
# using x.vars
p1 &lt;- gamlss(y~pc(x.vars=c("x1","x2","x3","x4","x5","x6")), data=usair)
registerDoParallel(cores = 2)
t1 &lt;- gamlss(y~pcr(x.vars=c("x1","x2","x3","x4","x5","x6")), data=usair)
# using x
X &lt;- model.matrix(~x1+x2+x3+x4+x5+x6, data=usair)[,-1]
p2 &lt;- gamlss(y~pc(x=X), data=usair)
t2 &lt;- gamlss(y~pcr(x=X), data=usair)
# using x.svd
svdX &lt;- getSVD(X)
p3 &lt;- gamlss(y~pc(x.svd=svdX), data=usair)
# selecting the componets 
p3 &lt;- gamlss(y~pc(x.svd=svdX, df=3), data=usair)
stopImplicitCluster()
plot(getSmo(t2))
plot(getSmo(t2), "gaic")
</code></pre>

<hr>
<h2 id='which.Data.Corr'>Detecting Hight Pair-Wise Correlations in Data</h2><span id='topic+which.Data.Corr'></span><span id='topic+which.yX.Corr'></span>

<h3>Description</h3>

<p>There are two function here. 
</p>
<p>The function <code>which.Data.Corr()</code> is taking as an argument a <code>data.frame</code> or a data matrix and it reports the pairs of variables which have higher correlation  than <code>r</code>.
</p>
<p>The function <code>which.yX.Corr()</code> it takes as arguments a continuous response variable, <code>y</code>, and a set of continuous explanatory variables, <code>x</code>, (which may include first order interactions), 
and it creates a <code>data.frame</code> containing all variables with a pair-wise correlation above <code>r</code>. If the set of the continuous explanatory variables contains first order interactions, then by default, (<code>hierarchical = TRUE</code>), the main effects of the first order interactions will be also included so hierarchy will be preserved.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which.Data.Corr(data, r = 0.9, digits=3)
which.yX.Corr(y, x, r = 0.5, plot = TRUE, 
              hierarchical = TRUE, print = TRUE, digits=3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="which.Data.Corr_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or a matrix</p>
</td></tr>
<tr><td><code id="which.Data.Corr_+3A_r">r</code></td>
<td>
<p>a correlation values (acting as a lower limit)</p>
</td></tr>
<tr><td><code id="which.Data.Corr_+3A_y">y</code></td>
<td>
<p>the response variable (continuous)</p>
</td></tr>
<tr><td><code id="which.Data.Corr_+3A_x">x</code></td>
<td>
<p>the (continuous) explanatory variables</p>
</td></tr>
<tr><td><code id="which.Data.Corr_+3A_plot">plot</code></td>
<td>
<p>whether to plot the results or not</p>
</td></tr>
<tr><td><code id="which.Data.Corr_+3A_print">print</code></td>
<td>
<p>whether to print the dim of the new matrix or not</p>
</td></tr>
<tr><td><code id="which.Data.Corr_+3A_hierarchical">hierarchical</code></td>
<td>
<p>This is designed for make sure that if first order interactions are included in the list the main effects will be also included</p>
</td></tr>
<tr><td><code id="which.Data.Corr_+3A_digits">digits</code></td>
<td>
<p>the number of digits to print.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>which.Data.Corr()</code> creates a matrix with three columns. The first two columns contain the names of the variables having pair-wise correlation higher than <code>r</code> and the third column show their correlation.
</p>
<p>The function <code>which.yX.Corr()</code> creats a design matrix which containts variables which have 
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos <a href="mailto:d.stasinopoulos@londonmet.ac.uk">d.stasinopoulos@londonmet.ac.uk</a>, Bob Rigby and Fernada De Bastiani.
</p>


<h3>References</h3>

<p>Bjorn-Helge Mevik, Ron Wehrens and Kristian Hovde Liland
(2019). pls: Partial Least Squares and Principal Component
Regression. R package version 2.7-2.
https://CRAN.R-project.org/package=pls
</p>
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape, (with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC, <a href="https://doi.org/10.1201/9780429298547">doi:10.1201/9780429298547</a>. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://doi.org/10.18637/jss.v023.i07">doi:10.18637/jss.v023.i07</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  <a href="https://doi.org/10.1201/b21973">doi:10.1201/b21973</a>
</p>
<p>Stasinopoulos, M. D., Rigby, R. A., and De Bastiani F., (2018) GAMLSS: a distributional regression approach, <em>Statistical Modelling</em>, Vol. <b>18</b>, 
pp, 248-273, SAGE Publications Sage India: New Delhi, India. <a href="https://doi.org/10.1177/1471082X18759144">doi:10.1177/1471082X18759144</a>
</p>
<p>Stasinopoulos, M. D., Rigby, R. A., Georgikopoulos N., and De Bastiani F., (2021) Principal  component regression in GAMLSS  applied to Greek-German government bond yield spreads, <em>Statistical Modelling</em> 
<a href="https://doi.org/10.1177/1471082X211022980">doi:10.1177/1471082X211022980</a>.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).  
. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pc">pc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(oil, package="gamlss.data")
dim(oil)
# which variables are highly correlated?
CC&lt;- which.Data.Corr(oil, r=0.999)
head(CC)
# 6 of them
# get the explanatory variables
form1 &lt;- as.formula(paste("OILPRICE ~ ",
          paste(names(oil)[-1],collapse='+'))) 
# no interactions
X &lt;- model.matrix(form1, data=oil)[,-1]
dim(X)
sX &lt;- which.yX.Corr(oil$OILPRICE,x=X, r=0.4)
dim(sX)
# first order interactions
form2 &lt;- as.formula(paste("OILPRICE ~ ",
        paste0(paste0("(",paste(names(oil)[-1], 
        collapse='+')), ")^2"))) 
form2
XX &lt;- model.matrix(form2, data=oil)[,-1]
dim(XX)
which.yX.Corr(oil$OILPRICE,x=XX, r=0.4)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
