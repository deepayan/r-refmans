<!DOCTYPE html><html><head><title>Help for package SpatialBSS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SpatialBSS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coef.sbss'>
<p>Coef Method for an Object of Class 'sbss'</p></a></li>
<li><a href='#gen_glob_outl'>
<p>Contamination with Global Outliers</p></a></li>
<li><a href='#gen_loc_outl'>
<p>Contamination with Local Outliers</p></a></li>
<li><a href='#local_covariance_matrix'>
<p>Computation of Local Covariance Matrices</p></a></li>
<li><a href='#local_gss_covariance_matrix'>
<p>Computation of Robust Local Covariance Matrices</p></a></li>
<li><a href='#plot.sbss'>
<p>Plot Method for an Object of Class 'sbss'</p></a></li>
<li><a href='#predict.sbss'>
<p>Predict Method for an Object of Class 'sbss'</p></a></li>
<li><a href='#print.sbss'>
<p>Print Method for an Object of Class 'sbss'</p></a></li>
<li><a href='#robsbss'>
<p>Robust Spatial Blind Source Separation</p></a></li>
<li><a href='#sbss'>
<p>Spatial Blind Source Separation</p></a></li>
<li><a href='#sbss_asymp'>
<p>Asymptotic Test for the White Noise Dimension in a Spatial Blind Source Separation Model</p></a></li>
<li><a href='#sbss_boot'>
<p>Different Bootstrap Tests for the White Noise Dimension in a Spatial Blind Source Separation Model</p></a></li>
<li><a href='#snss_jd'>
<p>Spatial Non-Stationary Source Separation Joint Diagonalization</p></a></li>
<li><a href='#snss_sd'>
<p>Spatial Non-Stationary Source Separation Simultaneous Diagonalization</p></a></li>
<li><a href='#snss_sjd'>
<p>Spatial Non-Stationary Source Separation Spatial Joint Diagonalization</p></a></li>
<li><a href='#spatial_kernel_matrix'>
<p>Computation of Spatial Kernel Matrices</p></a></li>
<li><a href='#SpatialBSS-package'>
<p>Blind Source Separation for Multivariate Spatial Data</p></a></li>
<li><a href='#white_data'>
<p>Different Approaches of Data Whitening</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Blind Source Separation for Multivariate Spatial Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.14-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-07-20</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Klaus Nordhausen &lt;klausnordhausenR@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Blind source separation for multivariate spatial data based on simultaneous/joint diagonalization of (robust) local covariance matrices. This package is an implementation of the methods described in Bachoc, Genton, Nordhausen, Ruiz-Gazen and Virta (2020) &lt;<a href="https://doi.org/10.1093%2Fbiomet%2Fasz079">doi:10.1093/biomet/asz079</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.2), JADE, sp, stats, SpatialNP, distances,
robustbase</td>
</tr>
<tr>
<td>Suggests:</td>
<td>sf, knitr, rmarkdown, markdown, gstat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-20 10:25:22 UTC; admin</td>
</tr>
<tr>
<td>Author:</td>
<td>Christoph Muehlmann
    <a href="https://orcid.org/0000-0001-7330-8434"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Mika Sipil&lt;e4&gt; <a href="https://orcid.org/0000-0002-5912-840X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Klaus Nordhausen <a href="https://orcid.org/0000-0002-3758-8501"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Sara Taskinen <a href="https://orcid.org/0000-0001-9470-7258"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Joni Virta <a href="https://orcid.org/0000-0002-2150-2769"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-20 17:00:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='coef.sbss'>
Coef Method for an Object of Class 'sbss'
</h2><span id='topic+coef.sbss'></span>

<h3>Description</h3>

<p>Extracts the estimated unmixing matrix of an object of class <code>'sbss'</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sbss'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.sbss_+3A_object">object</code></td>
<td>

<p>object of class <code>'sbss'</code>. Usually result of <code><a href="#topic+sbss">sbss</a></code>.
</p>
</td></tr>
<tr><td><code id="coef.sbss_+3A_...">...</code></td>
<td>

<p>further arguments to be passed to or from methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the estimated unmixing matrix of an object of class <code>'sbss'</code> as a numeric matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbss">sbss</a></code>
</p>

<hr>
<h2 id='gen_glob_outl'>
Contamination with Global Outliers
</h2><span id='topic+gen_glob_outl'></span>

<h3>Description</h3>

<p>Generates synthetic global outliers and contaminates a given p-variate random field
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_glob_outl(x, alpha = 0.05, h = 10, random_sign = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_glob_outl_+3A_x">x</code></td>
<td>

<p>a numeric matrix of dimension <code>c(n, p)</code> where the <code>p</code> columns correspond to the entries of the random field and the <code>n</code> rows are the observations.
</p>
</td></tr>
<tr><td><code id="gen_glob_outl_+3A_alpha">alpha</code></td>
<td>

<p>a numerical value between 0 and 1 giving the proportion of observations to contaminate.
</p>
</td></tr>
<tr><td><code id="gen_glob_outl_+3A_h">h</code></td>
<td>

<p>a numerical constant to determine how large the contaminated outliers are, see details.
</p>
</td></tr>
<tr><td><code id="gen_glob_outl_+3A_random_sign">random_sign</code></td>
<td>

<p>logical. If <code>TRUE</code>, the sign of each component of the outlier is randomly selected. Default is <code>FALSE</code>. See more in details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>gen_glob_outl</code> generates outliers for a given field by selecting randomly <code>round(alpha * n)</code> observations <code class="reqn">x_i</code> to be the outliers and contaminating them by setting <code class="reqn">x^{out}_i = (c^i)'x_i</code>, where the elements <code class="reqn">c^i_j</code> of vector <code class="reqn">c^i</code> are determined by the parameter <code>random_sign</code>. If <code>random_sign = TRUE</code>, <code class="reqn">c^i_j</code> is either <code class="reqn">h</code> or <code class="reqn">-h</code> with <code class="reqn">P(c^i_j = h) = P(c^i_j = -h) = 0.5</code>. If <code>random_sign = FALSE</code>, <code class="reqn">c^i_j=h</code> for all <code class="reqn">j=1,...p</code>, <code class="reqn">i=1,...,n</code>. The parameter <code>alpha</code> determines the contamination rate <code class="reqn">\alpha</code> and the parameter <code>h</code> determines the size of the outliers.
</p>


<h3>Value</h3>

<p><code>gen_glob_outl</code> returns a <code>data.frame</code> containing the contaminated fields as <code class="reqn">p</code> first columns. The column <code class="reqn">p + 1</code> contains a logical indicator whether the observation is outlier or not.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen_loc_outl">gen_loc_outl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate coordinates
coords &lt;- runif(1000 * 2) * 20
dim(coords) &lt;- c(1000, 2)
coords_df &lt;- as.data.frame(coords)
names(coords_df) &lt;- c("x", "y")
# simulate random field
if (!requireNamespace('gstat', quietly = TRUE)) {
  message('Please install the package gstat to run the example code.')
} else {
  library(gstat)
  model_1 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, model = 'Exp'), nmax = 20)
  model_2 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, kappa = 2, model = 'Mat'), 
                   nmax = 20)
  model_3 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, model = 'Gau'), nmax = 20)
  field_1 &lt;- predict(model_1, newdata = coords_df, nsim = 1)$sim1
  field_2 &lt;- predict(model_2, newdata = coords_df, nsim = 1)$sim1
  field_3 &lt;- predict(model_3, newdata = coords_df, nsim = 1)$sim1
  field &lt;- cbind(field_1, field_2, field_3)
  # Generate 10 % global outliers to data, with size h=15.
  field_cont &lt;- gen_glob_outl(field, alpha = 0.1, h = 15)
  
  # Generate 5 % global outliers to data, with size h = 10 and random sign.
  field_cont2 &lt;- gen_glob_outl(field, alpha = 0.05, h = 10, random_sign = TRUE)
}
</code></pre>

<hr>
<h2 id='gen_loc_outl'>
Contamination with Local Outliers
</h2><span id='topic+gen_loc_outl'></span>

<h3>Description</h3>

<p>Generates synthetic local outliers and contaminates a given p-variate random field by swapping observations based on the first principal component score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_loc_outl(x, coords, alpha = 0.05, 
             neighborhood_type = c("radius", "fixed_n"), 
             radius = NULL, 
             neighborhood_size = NULL, 
             swap_order = c("regular", "reverse", "random"))

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_loc_outl_+3A_x">x</code></td>
<td>

<p>a numeric matrix of dimension <code>c(n, p)</code> where the <code>p</code> columns correspond to the entries of the random field and the <code>n</code> rows are the observations.
</p>
</td></tr>
<tr><td><code id="gen_loc_outl_+3A_coords">coords</code></td>
<td>

<p>a numeric matrix or data frame with dimension <code>c(n,2)</code> containing the coordinates of the observations.
</p>
</td></tr>
<tr><td><code id="gen_loc_outl_+3A_alpha">alpha</code></td>
<td>

<p>a numeric value between 0 and 1 determining the proportion of the contaminated observations.
</p>
</td></tr>
<tr><td><code id="gen_loc_outl_+3A_neighborhood_type">neighborhood_type</code></td>
<td>

<p>a string determining the type of neighborhood. If <code>'radius'</code>, each neighborhood contains all points within the radius determined by the parameter <code>radius</code>. If <code>'fixed_n'</code>, each neighborhood contains a constant number of closest points, where the constant is determined by the parameter <code>neighborhood_size</code>. Default is <code>'radius'</code>.
</p>
</td></tr>
<tr><td><code id="gen_loc_outl_+3A_radius">radius</code></td>
<td>

<p>a positive numeric value defining the size of the radius when the <br />
<code>neighborhood_type</code> is <code>'radius'</code>. If <code>NULL</code> the radius defaults as <code>0.01*n</code>.
</p>
</td></tr>
<tr><td><code id="gen_loc_outl_+3A_neighborhood_size">neighborhood_size</code></td>
<td>

<p>a positive integer defining the number of points in each neighborhood when the <code>neighborhood_type</code> is <code>'fixed_n'</code>. If <code>NULL</code> the number of points defaults as <code>ceiling(0.01*n)</code>.
</p>
</td></tr>
<tr><td><code id="gen_loc_outl_+3A_swap_order">swap_order</code></td>
<td>

<p>a string to determine which swap order is used. Either <code>'regular'</code> (default), <code>'reverse'</code> or <code>'random'</code>. See details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>gen_loc_outl</code> generates local outliers by swapping the most extreme and the least extreme observations based on the first principal component score under the condition that at most one outliers lies in each neighborhood. For each location <code class="reqn">s_i</code>, the neighborhood <code class="reqn">N_i</code> is defined based on the parameter 
<code>neighborhood_type</code>. When <code>neighborhood_type</code> is <code>'radius'</code>, the neighborhood <code class="reqn">N_i</code> contains all locations <code class="reqn">s_j</code> for which the Euclidean norm <code class="reqn">||s_i - s_j|| &lt; r</code>, where <code class="reqn">r</code> is determined by the parameter <code>radius</code>. When <code>neighborhood_type</code> is <code>'fixed_n'</code>, the neighborhood <code class="reqn">N_i</code> contains <code class="reqn">m - 1</code> nearest locations of <code class="reqn">s_i</code>, where <code class="reqn">m</code> is determined by the parameter <code>neighborhood_size</code>. For more details see Ernst &amp; Haesbroeck, (2017).
</p>
<p>After calculating the neighborhoods, the local outliers are generated following Ernst &amp; Haesbroeck, (2017) and Harris
et al. (2014) using the steps:
</p>

<ol>
<li>
<p>Sort the observations from highest to lowest by their principle component analysis (PCA) scores of the first component (PC-1).

</p>
</li>
<li>
<p>Set <code class="reqn">k</code> to be <code class="reqn">\alpha N/2</code> rounded to nearest integer and select the set of local outlier points <code class="reqn">S^{out}</code> by finding <code class="reqn">k</code> observations with the highest PC-1 values and <code class="reqn">k</code> observations with the lowest PC-1 values under the condition that for all <code class="reqn">s_i, s_j \in S_{out}</code> it holds that <code class="reqn">N_i \neq N_j</code>.

</p>
</li>
<li>
<p>Form sets <code class="reqn">X_{large}</code>, which contains <code class="reqn">k</code> observations with the largest PC-1 values of outlier points <code class="reqn">S_{out}</code> and <code class="reqn">X^{small}</code>, which contains <code class="reqn">k</code> observations with the smallest PC-1 values of outlier points <code class="reqn">S^{out}</code>. Generate the local outliers by swapping <code class="reqn">X^{small,i}</code> with <code class="reqn">X^{large, k + 1 - i}</code>, <code class="reqn">i=1,...,k</code>. The parameter <code>swap_order</code> defines how the sets <code class="reqn">X^{large}</code> and <code class="reqn">X^{small}</code> are ordered.

</p>
</li></ol>

<p>If the parameter <code>swap_order</code> is <code>'regular'</code>, <code class="reqn">X^{small}</code> and <code class="reqn">X^{large}</code> are sorted by PC-1 score from smallest to largest.
If the parameter <code>swap_order</code> is <code>'reverse'</code>, <code class="reqn">X^{small}</code> is sorted from largest to smallest and <code class="reqn">X^{large}</code> from smallest to largest.
If the parameter <code>swap_order</code> is <code>'random'</code>, <code class="reqn">X^{small}</code> and <code class="reqn">X^{large}</code> are in random order.
</p>


<h3>Value</h3>

<p><code>gen_loc_outl</code> returns a <code>data.frame</code> containing the contaminated fields as <code class="reqn">p</code> first columns. The column <code class="reqn">p + 1</code> contains a logical indicator whether the observation is an outlier or not.
</p>


<h3>Note</h3>

<p>This function is a modified version of code originally
provided by M. Ernst and G. Haesbroeck.
</p>


<h3>References</h3>

<p>Ernst, M., &amp; Haesbroeck, G. (2017). <em>Comparison of local outlier detection techniques in spatial multivariate data</em>. Data Mining and Knowledge Discovery, 31 , 371-399. <a href="https://doi.org/10.1007/s10618-016-0471-0">doi:10.1007/s10618-016-0471-0</a>
</p>
<p>Harris, P., Brunsdon, C., Charlton, M., Juggins, S., &amp; Clarke, A. (2014). <em>Multivariate spatial outlier detection using robust geographically weighted methods</em>. Mathematical Geosciences, 46 , 1-31. <a href="https://doi.org/10.1007/s11004-013-9491-0">doi:10.1007/s11004-013-9491-0</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen_glob_outl">gen_glob_outl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate coordinates
coords &lt;- runif(1000 * 2) * 20
dim(coords) &lt;- c(1000, 2)
coords_df &lt;- as.data.frame(coords)
names(coords_df) &lt;- c("x", "y")
# simulate random field
if (!requireNamespace('gstat', quietly = TRUE)) {
  message('Please install the package gstat to run the example code.')
} else {
  library(gstat)
  model_1 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, model = 'Exp'), nmax = 20)
  model_2 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, kappa = 2, model = 'Mat'), 
                   nmax = 20)
  model_3 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, model = 'Gau'), nmax = 20)
                   
  field_1 &lt;- predict(model_1, newdata = coords_df, nsim = 1)$sim1
  field_2 &lt;- predict(model_2, newdata = coords_df, nsim = 1)$sim1
  field_3 &lt;- predict(model_3, newdata = coords_df, nsim = 1)$sim1
  field &lt;- cbind(field_1, field_2, field_3)
  
  # Generate 5 % local outliers to data using radius neighborhoods 
  # and regular swap_order.
  field_cont &lt;- gen_loc_outl(field, coords, alpha = 0.05,
                             neighborhood_type = "radius", 
                             radius = 0.5, swap_order = "regular")

  # Generate 10 % local outliers to data using fixed_n neighborhoods 
  # and reverse swap_order.
  field_cont2 &lt;- gen_loc_outl(field, coords, alpha = 0.1, 
                              neighborhood_type = "fixed_n", 
                              neighborhood_size = 10, swap_order = "reverse")
}
</code></pre>

<hr>
<h2 id='local_covariance_matrix'>
Computation of Local Covariance Matrices
</h2><span id='topic+local_covariance_matrix'></span>

<h3>Description</h3>

<p><code>local_covariance_matrix</code> computes local covariance matrices for a random field based on a given set of spatial kernel matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_covariance_matrix(x, kernel_list, lcov = c('lcov', 'ldiff', 'lcov_norm'), 
                        center = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_covariance_matrix_+3A_x">x</code></td>
<td>

<p>a numeric matrix of dimension <code>c(n, p)</code> where the <code>p</code> columns correspond to the entries of the random field and the <code>n</code> rows are the observations.
</p>
</td></tr>
<tr><td><code id="local_covariance_matrix_+3A_kernel_list">kernel_list</code></td>
<td>

<p>a list with spatial kernel matrices of dimension <code>c(n, n)</code>. This list is usually computed with the function <code><a href="#topic+spatial_kernel_matrix">spatial_kernel_matrix</a></code>.
</p>
</td></tr>
<tr><td><code id="local_covariance_matrix_+3A_lcov">lcov</code></td>
<td>

<p>a string indicating which type of local covariance matrix to use. Either <code>'lcov'</code> (default) or <code>'ldiff'</code>.
</p>
</td></tr>
<tr><td><code id="local_covariance_matrix_+3A_center">center</code></td>
<td>

<p>logical. If <code>TRUE</code> the data <code>x</code> is centered prior computing the local covariance matrices. Default is <code>TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two versions of local covariance matrices are implemented, the argument <code>lcov</code> determines which version is used:
</p>

<ul>
<li> <p><code>'lcov'</code>: </p>
<p style="text-align: center;"><code class="reqn"> LCov(f) = 1/n \sum_{i,j} f(d_{i,j}) (x(s_i)-\bar{x}) (x(s_j)-\bar{x})' ,</code>
</p>

</li>
<li> <p><code>'ldiff'</code>: </p>
<p style="text-align: center;"><code class="reqn"> LDiff(f) = 1/n \sum_{i,j} f(d_{i,j}) (x(s_i)-x(s_j)) (x(s_i)-x(s_j))',</code>
</p>

</li>
<li> <p><code>'lcov_norm'</code>: </p>
<p style="text-align: center;"><code class="reqn"> LCov^*(f) = 1/(n F^{1/2}_{f,n}) \sum_{i,j} f(d_{i,j}) (x(s_i)-\bar{x}) (x(s_j)-\bar{x})',</code>
</p>
<p> with </p>
<p style="text-align: center;"><code class="reqn"> F_{f,n} = 1 / n \sum_{i,j} f^2(d_{i,j}).</code>
</p>

</li></ul>

<p>Where <code class="reqn">d_{i,j} \ge 0</code> correspond to the pairwise distances between coordinates, <code class="reqn">x(s_i)</code> are the <code>p</code> random field values at location <code class="reqn">s_i</code>, <code class="reqn">\bar{x}</code> is the sample mean vector, and the kernel function <code class="reqn">f(d)</code> determines the locality. The choice <code>'lcov_norm'</code> is useful when testing for the actual signal dimension of the latent field, see <code><a href="#topic+sbss_asymp">sbss_asymp</a></code> and <code><a href="#topic+sbss_boot">sbss_boot</a></code>. The function <code>local_covariance_matrix</code> computes local covariance matrices for a given random field and given spatial kernel matrices, the type of computed local covariance matrices is determined by the argument <code>'lcov'</code>. If the argument <code>center</code> equals <code>FALSE</code> then the centering in the above formula for <code class="reqn">LCov(f)</code> is not carried out. See also <code><a href="#topic+spatial_kernel_matrix">spatial_kernel_matrix</a></code> for details. 
</p>


<h3>Value</h3>

<p><code>local_covariance_matrix</code> returns a list of equal length as the argument <code>kernel_list</code>. Each list entry is a numeric matrix of dimension <code>c(p, p)</code> corresponding to a local covariance matrix. The list has the attribute <code>'lcov'</code> which equals the function argument <code>lcov</code>.
</p>


<h3>References</h3>

<p>Muehlmann, C., Filzmoser, P. and Nordhausen, K. (2021), <em>Spatial Blind Source Separation in the Presence of a Drift</em>, Submitted for publication. Preprint available at <a href="https://arxiv.org/abs/2108.13813">https://arxiv.org/abs/2108.13813</a>.
</p>
<p>Bachoc, F., Genton, M. G, Nordhausen, K., Ruiz-Gazen, A. and Virta, J. (2020), <em>Spatial Blind Source Separation</em>, Biometrika, 107, 627-646, <a href="https://doi.org/10.1093/biomet/asz079">doi:10.1093/biomet/asz079</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spatial_kernel_matrix">spatial_kernel_matrix</a></code>, <code><a href="#topic+sbss">sbss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate coordinates
coords &lt;- runif(1000 * 2) * 20
dim(coords) &lt;- c(1000, 2)
coords_df &lt;- as.data.frame(coords)
names(coords_df) &lt;- c("x", "y")
# simulate random field
if (!requireNamespace('gstat', quietly = TRUE)) {
  message('Please install the package gstat to run the example code.')
} else {
  library(gstat)
  model_1 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, model = 'Exp'), nmax = 20)
  model_2 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, kappa = 2, model = 'Mat'), 
                   nmax = 20)
  model_3 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, model = 'Gau'), nmax = 20)
  field_1 &lt;- predict(model_1, newdata = coords_df, nsim = 1)$sim1
  field_2 &lt;- predict(model_2, newdata = coords_df, nsim = 1)$sim1
  field_3 &lt;- predict(model_3, newdata = coords_df, nsim = 1)$sim1
  field &lt;- as.matrix(cbind(field_1, field_2, field_3))

  # computing two ring kernel matrices and corresponding local covariance matrices
  kernel_params_ring &lt;- c(0, 0.5, 0.5, 2)
  ring_kernel_list &lt;- 
    spatial_kernel_matrix(coords, 'ring', kernel_params_ring)
  loc_cov_ring &lt;- 
    local_covariance_matrix(x = field, kernel_list = ring_kernel_list)
    
  # computing two ring kernel matrices and corresponding local difference matrices
  kernel_params_ring &lt;- c(0, 0.5, 0.5, 2)
  ring_kernel_list &lt;- 
    spatial_kernel_matrix(coords, 'ring', kernel_params_ring)
  loc_cov_ring &lt;- 
    local_covariance_matrix(x = field, kernel_list = ring_kernel_list, lcov = 'ldiff')
  
  # computing three ball kernel matrices and corresponding local covariance matrices
  kernel_params_ball &lt;- c(0.5, 1, 2)
  ball_kernel_list &lt;- 
    spatial_kernel_matrix(coords, 'ball', kernel_params_ball)
  loc_cov_ball &lt;- 
    local_covariance_matrix(x = field, kernel_list = ball_kernel_list)
  
  # computing three gauss kernel matrices and corresponding local covariance matrices
  kernel_params_gauss &lt;- c(0.5, 1, 2)
  gauss_kernel_list &lt;- 
    spatial_kernel_matrix(coords, 'gauss', kernel_params_gauss)
  loc_cov_gauss &lt;- 
    local_covariance_matrix(x = field, kernel_list = gauss_kernel_list)
}
</code></pre>

<hr>
<h2 id='local_gss_covariance_matrix'>
Computation of Robust Local Covariance Matrices
</h2><span id='topic+local_gss_covariance_matrix'></span>

<h3>Description</h3>

<p><code>local_gss_covariance_matrix</code> computes generalized local sign covariance matrices for a random field based on a given set of spatial kernel matrices. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_gss_covariance_matrix(x, kernel_list, lcov = c('norm', 'winsor', 'qwinsor'), 
                        center = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_gss_covariance_matrix_+3A_x">x</code></td>
<td>

<p>a numeric matrix of dimension <code>c(n, p)</code> where the <code>p</code> columns correspond to the entries of the random field and the <code>n</code> rows are the observations.
</p>
</td></tr>
<tr><td><code id="local_gss_covariance_matrix_+3A_kernel_list">kernel_list</code></td>
<td>

<p>a list with spatial kernel matrices of dimension <code>c(n, n)</code>. This list is usually computed with the function <code><a href="#topic+spatial_kernel_matrix">spatial_kernel_matrix</a></code>.
</p>
</td></tr>
<tr><td><code id="local_gss_covariance_matrix_+3A_lcov">lcov</code></td>
<td>

<p>a string indicating which type of robust local covariance matrix to use. Either <code>'norm'</code> (default), <code>'winsor'</code> or <code>'qwinsor'</code>.
</p>
</td></tr>
<tr><td><code id="local_gss_covariance_matrix_+3A_center">center</code></td>
<td>

<p>logical. If <code>TRUE</code> the data <code>x</code> is robustly centered prior computing the local covariance matrices. Default is <code>TRUE</code>. See also <code><a href="#topic+white_data">white_data</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generalized local sign matrices are determined by radial functions <code class="reqn">w(l_i)</code>, where <code class="reqn">l_i = ||x(s_i)-T(x)||</code> and <code class="reqn">T(x)</code> is Hettmansperger Randles location estimator (Hettmansperger &amp; Randles, 2002), and kernel functions <code class="reqn">f(d_{i,j})</code>, where <code class="reqn">d_{i,j}=||s_i - s_j||</code>. Generalized local sign covariance (gLSCM) matrix is then calculated as
</p>
<p style="text-align: center;"><code class="reqn">gLSCM(f,w) = 1/(n F^{1/2}_{f,n}) \sum_{i,j} f(d_{i,j})  w(l_i)w(l_j)(x(s_i)-T(x)) (x(s_j)-T(x))'</code>
</p>
<p> with </p>
<p style="text-align: center;"><code class="reqn"> F_{f,n} = 1 / n \sum_{i,j} f^2(d_{i,j}).</code>
</p>

<p>Three radial functions <code class="reqn">w(l_i)</code> (Raymaekers &amp; Rousseeuw, 2019) are implemented, the parameter <code>lcov</code> defines which is used:
</p>

<ul>
<li> <p><code>'norm'</code>: </p>
<p style="text-align: center;"><code class="reqn"> w(l_i) = 1/l_i </code>
</p>

</li>
<li> <p><code>'winsor'</code>: </p>
<p style="text-align: center;"><code class="reqn"> w(l_i) = Q/l_i </code>
</p>

</li>
<li> <p><code>'qwinsor'</code>: </p>
<p style="text-align: center;"><code class="reqn"> w(l_i) = Q^2/l_i^2.</code>
</p>

</li></ul>

<p>The cutoff <code class="reqn">Q</code> is defined as <code class="reqn">Q = l_{(h)}</code>, where <code class="reqn">l_{(h)}</code> is <code class="reqn">h</code>th order statistic of <code class="reqn">\{l_1, ..., l_n\}</code> and <code class="reqn">h = (n + p + 1)/2</code>. If the argument <code>center</code> equals <code>FALSE</code> then the centering in the above formula for <code class="reqn">gLSCM(f,w)</code> is not carried out. See also <code><a href="#topic+spatial_kernel_matrix">spatial_kernel_matrix</a></code> for details. 
</p>


<h3>Value</h3>

<p><code>local_gss_covariance_matrix</code> returns a list with two entries:
</p>
<table>
<tr><td><code>cov_sp_list</code></td>
<td>

<p>List of equal length as the argument <code>kernel_list</code>. Each list entry is a numeric matrix of dimension <code>c(p, p)</code> corresponding to a robust local covariance matrix. The list has the attribute <code>'lcov'</code> which equals the function argument <code>lcov</code>.
</p>
</td></tr>  
<tr><td><code>weights</code></td>
<td>

<p>numeric vector of <code>length(n)</code> giving the weights for each observation for the robust local covariance estimation.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Hettmansperger, T. P., &amp; Randles, R. H. (2002). <em>A practical affine equivariant multivariate median</em>. Biometrika, 89 , 851-860. <a href="https://doi.org/10.1093/biomet/89.4.851">doi:10.1093/biomet/89.4.851</a>.
</p>
<p>Raymaekers, J., &amp; Rousseeuw, P. (2019). <em>A generalized spatial sign covariance matrix. Journal of Multivariate Analysis</em>, 171 , 94-111. <a href="https://doi.org/10.1016/j.jmva.2018.11.010">doi:10.1016/j.jmva.2018.11.010</a>.
</p>
<p>Sipila, M., Muehlmann, C. Nordhausen, K. &amp; Taskinen, S. (2022). <em>Robust second order stationary spatial blind source separation using generalized sign matrices</em>. Manuscript.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spatial_kernel_matrix">spatial_kernel_matrix</a></code>, <code><a href="#topic+robsbss">robsbss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate coordinates
coords &lt;- runif(1000 * 2) * 20
dim(coords) &lt;- c(1000, 2)
coords_df &lt;- as.data.frame(coords)
names(coords_df) &lt;- c("x", "y")
# simulate random field
if (!requireNamespace('gstat', quietly = TRUE)) {
  message('Please install the package gstat to run the example code.')
} else {
  library(gstat)
  model_1 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, model = 'Exp'), nmax = 20)
  model_2 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, kappa = 2, model = 'Mat'), 
                   nmax = 20)
  model_3 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, model = 'Gau'), nmax = 20)
  field_1 &lt;- predict(model_1, newdata = coords_df, nsim = 1)$sim1
  field_2 &lt;- predict(model_2, newdata = coords_df, nsim = 1)$sim1
  field_3 &lt;- predict(model_3, newdata = coords_df, nsim = 1)$sim1
  field &lt;- cbind(field_1, field_2, field_3)
  
  # computing two ring kernel matrices and corresponding 
  # robust local covariance matrices using 'norm' radial function:
  kernel_params_ring &lt;- c(0, 0.5, 0.5, 2)
  ring_kernel_list &lt;- 
    spatial_kernel_matrix(coords, 'ring', kernel_params_ring)
  loc_cov_ring &lt;- 
    local_gss_covariance_matrix(x = field, kernel_list = ring_kernel_list, 
                               lcov = 'norm')
    
  # computing three ball kernel matrices and corresponding 
  # robust local covariance matrices using 'winsor' radial function:
  kernel_params_ball &lt;- c(0.5, 1, 2)
  ball_kernel_list &lt;- 
    spatial_kernel_matrix(coords, 'ball', kernel_params_ball)
  loc_cov_ball &lt;- 
    local_gss_covariance_matrix(x = field, kernel_list = ball_kernel_list, 
                               lcov = 'winsor')
    
  # computing three gauss kernel matrices and corresponding 
  # robust local covariance matrices using 'qwinsor' radial function:
  kernel_params_gauss &lt;- c(0.5, 1, 2)
  gauss_kernel_list &lt;- 
    spatial_kernel_matrix(coords, 'gauss', kernel_params_gauss)
  loc_cov_gauss &lt;- 
    local_gss_covariance_matrix(x = field, kernel_list = gauss_kernel_list, 
                               lcov = 'qwinsor')
}
</code></pre>

<hr>
<h2 id='plot.sbss'>
Plot Method for an Object of Class 'sbss'
</h2><span id='topic+plot.sbss'></span>

<h3>Description</h3>

<p><code>plot.sbss</code> is an interface to the standard plot method for the class of the estimated source random field. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sbss'
plot(x, which = 1:ncol(x$s), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sbss_+3A_x">x</code></td>
<td>

<p>object of class <code>'sbss'</code>. Usually result of <code><a href="#topic+sbss">sbss</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.sbss_+3A_which">which</code></td>
<td>

<p>a numeric vector indicating which components of the latent field should be plotted.
</p>
</td></tr>
<tr><td><code id="plot.sbss_+3A_...">...</code></td>
<td>

<p>further arguments to the plot method of <code>class(x$s)</code>, which is either <code><a href="sp.html#topic+spplot">spplot</a></code> or <code><a href="sf.html#topic+plot">plot</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method calls the corresponding plot method of <code>class(x$s)</code>. Either <code><a href="sp.html#topic+spplot">spplot</a></code> for <code>class(x$s)</code> is <code><a href="sp.html#topic+SpatialPointsDataFrame">SpatialPointsDataFrame</a></code> or <code><a href="sf.html#topic+plot.sf">plot.sf</a></code> for <code>class(x$s)</code> is <code><a href="sf.html#topic+sf">sf</a></code>. If <code>x$s</code> is a matrix then it is internally cast to <code><a href="sp.html#topic+SpatialPointsDataFrame">SpatialPointsDataFrame</a></code> and <code><a href="sp.html#topic+spplot">spplot</a></code> is used for plotting. Arguments to the corresponding plot functions can be given through <code>...</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbss">sbss</a></code>, <code><a href="sp.html#topic+spplot">spplot</a></code>, <code><a href="sf.html#topic+plot.sf">plot.sf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate coordinates
coords &lt;- runif(1000 * 2) * 20
dim(coords) &lt;- c(1000, 2)
coords_df &lt;- as.data.frame(coords)
names(coords_df) &lt;- c("x", "y")
# simulate random field
if (!requireNamespace('gstat', quietly = TRUE)) {
  message('Please install the package gstat to run the example code.')
} else {
  library(gstat)
  model_1 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, model = 'Exp'), nmax = 20)
  model_2 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, kappa = 2, model = 'Mat'), 
                   nmax = 20)
  model_3 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, model = 'Gau'), nmax = 20)
  field_1 &lt;- predict(model_1, newdata = coords_df, nsim = 1)$sim1
  field_2 &lt;- predict(model_2, newdata = coords_df, nsim = 1)$sim1
  field_3 &lt;- predict(model_3, newdata = coords_df, nsim = 1)$sim1
  field &lt;- as.matrix(cbind(field_1, field_2, field_3))

  # compute ring kernel matrices
  kernel_parameters &lt;- c(0, 1, 1, 2, 2, 3)
  ring_kernel_list &lt;- spatial_kernel_matrix(coords, 'ring', kernel_parameters)
  
  # apply sbss SpatialPointsDataFrame object
  field_sp &lt;- sp::SpatialPointsDataFrame(coords = coords, data = data.frame(field))
  res_sp &lt;- sbss(field_sp, kernel_list = ring_kernel_list)
  
  # plot with SpatialPointsDataFrame object
  plot(res_sp)
  
  # plot with SpatialPointsDataFrame object 
  # and additional arguments for spplot function
  plot(res_sp, colorkey = TRUE, as.table = TRUE, cex = 1)

  # apply sbss with sf object
  if (!requireNamespace('sf', quietly = TRUE)) {
    message('Please install the package sf to run the example code.')
  } else {
    field_sf &lt;- sf::st_as_sf(data.frame(coords = coords, field), 
                             coords = c(1,2))
    res_sf &lt;- sbss(x = field_sf, kernel_list = ring_kernel_list)
    
    # plot with sf object
    plot(res_sf)
    
    # plot with sf object 
    # and additional arguments for plot.sf function
    plot(res_sf, axes = TRUE, key.pos = 4)
  }
}

</code></pre>

<hr>
<h2 id='predict.sbss'>
Predict Method for an Object of Class 'sbss'
</h2><span id='topic+predict.sbss'></span>

<h3>Description</h3>

<p><code>predict.sbss</code> predicts the estimated source random field on a grid with Inverse Distance Weighting (IDW) and plots these predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sbss'
predict(object, p = 2, n_grid = 50, which = 1:ncol(object$s), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.sbss_+3A_object">object</code></td>
<td>

<p>object of class <code>'sbss'</code>. Usually result of <code><a href="#topic+sbss">sbss</a></code>.
</p>
</td></tr>
<tr><td><code id="predict.sbss_+3A_p">p</code></td>
<td>

<p>numeric. The positive power parameter for IDW. Default is 2.
</p>
</td></tr>
<tr><td><code id="predict.sbss_+3A_n_grid">n_grid</code></td>
<td>

<p>numeric. Each dimension of the spatial domain is divided by this integer to derive a grid for IDW predictions. Default is 50.
</p>
</td></tr>
<tr><td><code id="predict.sbss_+3A_which">which</code></td>
<td>

<p>a numeric vector indicating which components of the latent field should be predicted.
</p>
</td></tr>
<tr><td><code id="predict.sbss_+3A_...">...</code></td>
<td>

<p>further arguments to the plot method of <code>class(x$s)</code>, which is either <code><a href="sp.html#topic+spplot">spplot</a></code> or <code><a href="sf.html#topic+plot">plot</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="https://en.wikipedia.org/wiki/Inverse_distance_weighting">IDW</a> predictions are made on a grid. The side lengths of the rectangular shaped grid cells are derived by the differences of the rounded maximum and minimum values divided by the <code>n_grid</code> argument for each column of <code>object$coords</code>. Hence, the grid contains a total of <code>n_grid ^ 2</code> points. The power parameter of the IDW predictions is given by <code>p</code> (default: 2).
</p>
<p>The predictions are plotted with the corresponding plot method of <code>class(x$s)</code>. Either <code><a href="sp.html#topic+spplot">spplot</a></code> for <code>class(x$s)</code> is <code><a href="sp.html#topic+SpatialPointsDataFrame">SpatialPointsDataFrame</a></code> or <code><a href="sf.html#topic+plot.sf">plot.sf</a></code> for <code>class(x$s)</code> is <code><a href="sf.html#topic+sf">sf</a></code>. If <code>x$s</code> is a matrix then it is internally cast to <code><a href="sp.html#topic+SpatialPointsDataFrame">SpatialPointsDataFrame</a></code> and <code><a href="sp.html#topic+spplot">spplot</a></code> is used for plotting. Arguments to the corresponding plot functions can be given through <code>...</code> as it is done by the method <code><a href="#topic+plot.sbss">plot.sbss</a></code>.
</p>


<h3>Value</h3>

<p>The return is dependent on the class of the latent field in the <code>'sbss'</code> object.
If <code>class(object$s)</code> is a matrix then a list with the following entries is returned:
</p>
<table>
<tr><td><code>vals_pred_idw</code></td>
<td>
<p>a matrix of dimension <code>c(n,p)</code> (when <code>which</code> is default or less than <code>p</code> columns according to the selected components with the <code>which</code> argument) with the IDW predictions of the estimated source random field.</p>
</td></tr>
<tr><td><code>coords_pred_idw</code></td>
<td>
<p>a matrix of dimension <code>c(n,2)</code> with the grid coordinates for the IDW predictions.</p>
</td></tr>
</table>
<p>If <code>class(object$s)</code> is <code><a href="sp.html#topic+SpatialPointsDataFrame">SpatialPointsDataFrame</a></code> or <code><a href="sf.html#topic+sf">sf</a></code> then the predicted values and their coordinates are returned as an object of the corresponding class.
</p>
<p>The return is invisible.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbss">sbss</a></code>, <code><a href="#topic+plot.sbss">plot.sbss</a></code>, <code><a href="sp.html#topic+spplot">spplot</a></code>, <code><a href="sf.html#topic+plot.sf">plot.sf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate coordinates
coords &lt;- runif(1000 * 2) * 20
dim(coords) &lt;- c(1000, 2)
coords_df &lt;- as.data.frame(coords)
names(coords_df) &lt;- c("x", "y")
# simulate random field
if (!requireNamespace('gstat', quietly = TRUE)) {
  message('Please install the package gstat to run the example code.')
} else {
  library(gstat)
  model_1 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, model = 'Exp'), nmax = 20)
  model_2 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, kappa = 2, model = 'Mat'), 
                   nmax = 20)
  model_3 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, model = 'Gau'), nmax = 20)
  field_1 &lt;- predict(model_1, newdata = coords_df, nsim = 1)$sim1
  field_2 &lt;- predict(model_2, newdata = coords_df, nsim = 1)$sim1
  field_3 &lt;- predict(model_3, newdata = coords_df, nsim = 1)$sim1
  field &lt;- as.matrix(cbind(field_1, field_2, field_3))

  # apply sbss with three ring kernels
  kernel_borders &lt;- c(0, 1, 1, 2, 2, 4)
  res_sbss &lt;-  sbss(field, coords, 'ring', kernel_borders)
  
  # predict latent fields on grid with default settings
  predict(res_sbss)
  
  # predict latent fields on grid with custom plotting settings
  predict(res_sbss, colorkey = TRUE, as.table = TRUE, cex = 1)
  
  # predict latent fields on a 60x60 grid
  predict(res_sbss, n_grid = 60, colorkey = TRUE, as.table = TRUE, cex = 1)
  
  # predict latent fields with a higher IDW power parameter
  predict(res_sbss, p = 10, colorkey = TRUE, as.table = TRUE, cex = 1)
  
  # predict latent fields and save the predictions
  predict_list &lt;- predict(res_sbss, p = 5, colorkey = TRUE, as.table = TRUE, cex = 1)
}
</code></pre>

<hr>
<h2 id='print.sbss'>
Print Method for an Object of Class 'sbss'
</h2><span id='topic+print.sbss'></span>

<h3>Description</h3>

<p>Prints the estimated unmixing matrix and the diagonalized local covariance matrices for an object of class <code>'sbss'</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sbss'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.sbss_+3A_x">x</code></td>
<td>

<p>object of class <code>'sbss'</code>. Usually result of <code><a href="#topic+sbss">sbss</a></code>.
</p>
</td></tr>
<tr><td><code id="print.sbss_+3A_...">...</code></td>
<td>

<p>additional arguments for the method <code>print.listof</code>.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+sbss">sbss</a></code>
</p>

<hr>
<h2 id='robsbss'>
Robust Spatial Blind Source Separation
</h2><span id='topic+robsbss'></span><span id='topic+robsbss.default'></span><span id='topic+robsbss.SpatialPointsDataFrame'></span><span id='topic+robsbss.sf'></span>

<h3>Description</h3>

<p><code>robsbss</code> is a robust variant of <code>sbss</code>. It estimates the unmixing matrix assuming a spatial blind source separation model by jointly diagonalizing the Hettmansperger-Randles scatter matrix and one/many generalized local sign covariance matrices. These local generalized sign covariance matrices are determined by spatial kernel functions and radial functions. Three types of such kernel functions and three types of radial functions are supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robsbss(x, ...)

## Default S3 method:
robsbss(x, coords, kernel_type = c('ring', 'ball', 'gauss'), 
     kernel_parameters, lcov = c('norm', 'winsor', 'qwinsor'), 
     ordered = TRUE, kernel_list = NULL, ...)
## S3 method for class 'SpatialPointsDataFrame'
robsbss(x, ...)
## S3 method for class 'sf'
robsbss(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="robsbss_+3A_x">x</code></td>
<td>

<p>either a numeric matrix of dimension <code>c(n, p)</code> where the <code>p</code> columns correspond to the entries of the random field and the <code>n</code> rows are the observations, an object of class <code><a href="sp.html#topic+SpatialPointsDataFrame">SpatialPointsDataFrame</a></code> or an object of class <code><a href="sf.html#topic+sf">sf</a></code>. 
</p>
</td></tr>
<tr><td><code id="robsbss_+3A_coords">coords</code></td>
<td>

<p>a numeric matrix of dimension <code>c(n,2)</code> where each row represents the coordinates of a point in the spatial domain. Only needed if <code>x</code> is a matrix and the argument <code>kernel_list</code> is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="robsbss_+3A_kernel_type">kernel_type</code></td>
<td>

<p>a string indicating which kernel function to use. Either <code>'ring'</code> (default), <code>'ball'</code> or <code>'gauss'</code>.
</p>
</td></tr>
<tr><td><code id="robsbss_+3A_kernel_parameters">kernel_parameters</code></td>
<td>

<p>a numeric vector that gives the parameters for the kernel function. At least length of one for <code>'ball'</code> and <code>'gauss'</code> or two for <code>'ring'</code> kernel, see details.
</p>
</td></tr>
<tr><td><code id="robsbss_+3A_lcov">lcov</code></td>
<td>

<p>a string indicating which radial function or type of robust local covariance matrix to use. Either <code>'norm'</code> (default), <code>'winsor'</code> or <code>'qwinsor'</code>. See also <br /> 
<code><a href="#topic+local_gss_covariance_matrix">local_gss_covariance_matrix</a></code> for details.
</p>
</td></tr>
<tr><td><code id="robsbss_+3A_ordered">ordered</code></td>
<td>

<p>logical. If <code>TRUE</code> the entries of the latent field are ordered by the sum of squared (pseudo-)eigenvalues of the diagonalized local covariance matrix/matrices. Default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="robsbss_+3A_kernel_list">kernel_list</code></td>
<td>

<p>a list of spatial kernel matrices with dimension <code>c(n,n)</code>, see details. Usually computed by the function <code><a href="#topic+spatial_kernel_matrix">spatial_kernel_matrix</a></code>.
</p>
</td></tr>
<tr><td><code id="robsbss_+3A_...">...</code></td>
<td>

<p>further arguments for the fast real joint diagonalization algorithm that jointly diagonalizes the local covariance matrices. See details and <code><a href="JADE.html#topic+frjd">frjd</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>robsbss</code> is a robust variant of <code>sbss</code> which uses Hettmansperger-Randles (HR) location and scatter estimates (Hettmansperger &amp; Randles, 2002) for whitening (see <code><a href="#topic+white_data">white_data</a></code> for details) and jointly diagonalizes HR scatter matrix and generalized local sign matrices to estimate the unmixing matrix. The generalized local sign matrices are determined by radial functions <code class="reqn">w(l_i)</code>, where <code class="reqn">l_i = ||x(s_i)-T(x)||</code> and <code class="reqn">T(x)</code> is HR location estimator, and kernel functions <code class="reqn">f(d_{i,j})</code>, where <code class="reqn">d_{i,j}=||s_i - s_j||</code>. Generalized local sign covariance (gLSCM) matrix is then calculated as
</p>
<p style="text-align: center;"><code class="reqn">gLSCM(f,w) = 1/(n F^{1/2}_{f,n}) \sum_{i,j} f(d_{i,j})  w(l_i)w(l_j)(x(s_i)-T(x)) (x(s_j)-T(x))'</code>
</p>
<p> with </p>
<p style="text-align: center;"><code class="reqn"> F_{f,n} = 1 / n \sum_{i,j} f^2(d_{i,j}).</code>
</p>

<p>Three radial functions (Raymaekers &amp; Rousseeuw, 2019) <code class="reqn">w(l_i)</code> are implemented, the parameter <code>lcov</code> defines which is used:
</p>

<ul>
<li> <p><code>'norm'</code>: </p>
<p style="text-align: center;"><code class="reqn"> w(l_i) = 1/l_i </code>
</p>

</li>
<li> <p><code>'winsor'</code>: </p>
<p style="text-align: center;"><code class="reqn"> w(l_i) = Q/l_i </code>
</p>

</li>
<li> <p><code>'qwinsor'</code>: </p>
<p style="text-align: center;"><code class="reqn"> w(l_i) = Q^2/l_i^2.</code>
</p>

</li></ul>

<p>The cutoff <code class="reqn">Q</code> is defined as <code class="reqn">Q = l_{(h)}</code>, where <code class="reqn">l_{(h)}</code> is <code class="reqn">h</code>th order statistic of <code class="reqn">\{l_1, ..., l_n\}</code> and <code class="reqn">h = (n + p + 1)/2</code>.
In addition, three kernel functions <code class="reqn">f(d)</code> are implemented, the parameter <code>kernel_type</code> defines which is used:
</p>

<ul>
<li> <p><code>'ring'</code>: parameters are inner radius <code class="reqn">r_{in}</code> and outer radius <code class="reqn">r_{out}</code>, with <code class="reqn">r_{in} &lt; r_{out}</code>, and <code class="reqn">r_{in}, r_{out} \ge 0</code>: </p>
<p style="text-align: center;"><code class="reqn">f(d;r_{in}, r_{out}) = I(r_{in} &lt; d \le r_{out})</code>
</p>

</li>
<li> <p><code>'ball'</code>: parameter is the radius <code class="reqn">r</code>, with <code class="reqn">r \ge 0</code>: </p>
<p style="text-align: center;"><code class="reqn">f(d;r) = I(d \le r)</code>
</p>

</li>
<li> <p><code>'gauss'</code>: Gaussian function where 95% of the mass is inside the parameter <code class="reqn">r</code>, with <code class="reqn">r \ge 0</code>: </p>
<p style="text-align: center;"><code class="reqn">f(d;r) = exp(-0.5 (\Phi^{-1}(0.95) d/r)^2).</code>
</p>

</li></ul>

<p>The argument <code>kernel_type</code> determines the used kernel function as presented above, the argument <code>kernel_parameters</code> gives the corresponding parameters for the kernel function. Specifically, if <code>kernel_type</code> equals <code>'ball'</code> or <code>'gauss'</code> then <code>kernel_parameters</code> is a numeric vector where each entry corresponds to one parameter. Hence, <code>length(kernel_parameters)</code> local covariance matrices are used. Whereas, if <code>kernel_type</code> equals <code>'ring'</code>, then <code>kernel_parameters</code> must be a numeric vector of even length where subsequently the inner and outer radii must be given (informally: <code>c(r_in1, r_out1, r_in2, r_out2, ...)</code>). In that case <code>length(kernel_parameters) / 2</code> local covariance matrices are used.
</p>
<p><code>robsbss</code> calls <code><a href="#topic+spatial_kernel_matrix">spatial_kernel_matrix</a></code> internally to compute a list of <code>c(n,n)</code> kernel matrices based on the parameters given, where each entry of those matrices corresponds to <code class="reqn">f(d_{i,j})</code>. Alternatively, such a list of kernel matrices can be given directly to the function <code>robsbss</code> via the <code>kernel_list</code> argument. This is useful when <code>robsbss</code> is called numerous times with the same coordinates/kernel functions as the computation of the kernel matrices is then done only once prior the actual <code>robsbss</code> calls. For details see also <code><a href="#topic+spatial_kernel_matrix">spatial_kernel_matrix</a></code>.
</p>
<p>If more than one generalized local sign covariance matrix is used <code>robsbss</code> jointly diagonalizes these matrices with the function <code><a href="JADE.html#topic+frjd">frjd</a></code>. <code>...</code> provides arguments for <code>frjd</code>, useful arguments might be:
</p>

<ul>
<li> <p><code>eps</code>: tolerance for convergence.
</p>
</li>
<li> <p><code>maxiter</code>: maximum number of iterations.
</p>
</li></ul>



<h3>Value</h3>

<p><code>robsbss</code> returns a list of class <code>'sbss'</code> with the following entries: 
</p>
<table>
<tr><td><code>s</code></td>
<td>

<p>object of <code>class(x)</code> containing the estimated source random field.
</p>
</td></tr>  
<tr><td><code>coords</code></td>
<td>

<p>coordinates of the observations. Is <code>NULL</code> if <code>x</code> was a matrix and the argument <code>kernel_list</code> was not <code>NULL</code> at the <code>robsbss</code> call.
</p>
</td></tr>
<tr><td><code>w</code></td>
<td>

<p>estimated unmixing matrix.
</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>

<p>numeric vector of <code>length(n)</code> giving the weights for each observation for the robust local covariance estimation.
</p>
</td></tr>
<tr><td><code>w_inv</code></td>
<td>

<p>inverse of the estimated unmixing matrix.
</p>
</td></tr>
<tr><td><code>pevals</code></td>
<td>

<p>(pseudo-)eigenvalues for each latent field entry.
</p>
</td></tr>  
<tr><td><code>d</code></td>
<td>

<p>matrix of stacked (jointly) diagonalized local covariance matrices with dimension <code>c(length(kernel_parameters)*p,p)</code> for <code>'ball'</code> and <code>'gauss'</code> kernel or <code>c(</code>
<code>(length(kernel_parameters) / 2)*p,p)</code> for <code>'ring'</code> kernel.
</p>
</td></tr>
<tr><td><code>diags</code></td>
<td>

<p>matrix of dimension <code>c(length(kernel_parameters),p)</code> where the rows contain the diagonal of the diagonalized local autocovariance matrices.
</p>
</td></tr>
<tr><td><code>x_mu</code></td>
<td>

<p>robustly estimated columnmeans of <code>x</code>.
</p>
</td></tr>
<tr><td><code>cov_inv_sqrt</code></td>
<td>

<p>square root of the inverse sample covariance matrix of <code>x</code>.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Hettmansperger, T. P., &amp; Randles, R. H. (2002). <em>A practical affine equivariant multivariate median</em>. Biometrika, 89 , 851-860. <a href="https://doi.org/10.1093/biomet/89.4.851">doi:10.1093/biomet/89.4.851</a>.
</p>
<p>Raymaekers, J., &amp; Rousseeuw, P. (2019). <em>A generalized spatial sign covariance matrix. Journal of Multivariate Analysis</em>, 171 , 94-111. <a href="https://doi.org/10.1016/j.jmva.2018.11.010">doi:10.1016/j.jmva.2018.11.010</a>.
</p>
<p>Sipila, M., Muehlmann, C. Nordhausen, K. &amp; Taskinen, S. (2022). <em>Robust second order stationary spatial blind source separation using generalized sign matrices</em>. Manuscript.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spatial_kernel_matrix">spatial_kernel_matrix</a></code>, <code><a href="#topic+local_gss_covariance_matrix">local_gss_covariance_matrix</a></code>, <code><a href="sp.html#topic+sp">sp</a></code>, <code><a href="sf.html#topic+sf">sf</a></code>, <code><a href="JADE.html#topic+frjd">frjd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate coordinates
coords &lt;- runif(1000 * 2) * 20
dim(coords) &lt;- c(1000, 2)
coords_df &lt;- as.data.frame(coords)
names(coords_df) &lt;- c("x", "y")
# simulate random field
if (!requireNamespace('gstat', quietly = TRUE)) {
  message('Please install the package gstat to run the example code.')
} else {
  library(gstat)
  model_1 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, model = 'Exp'), nmax = 20)
  model_2 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, kappa = 2, model = 'Mat'), 
                   nmax = 20)
  model_3 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, model = 'Gau'), nmax = 20)
  field_1 &lt;- predict(model_1, newdata = coords_df, nsim = 1)$sim1
  field_2 &lt;- predict(model_2, newdata = coords_df, nsim = 1)$sim1
  field_3 &lt;- predict(model_3, newdata = coords_df, nsim = 1)$sim1
  field &lt;- cbind(field_1, field_2, field_3)
  # Generate 5 % local outliers to data
  field_cont &lt;- gen_loc_outl(field, coords, radius = 2, 
                             swap_order = "regular")[,1:3]
  X &lt;- as.matrix(field_cont)
  
  # apply sbss with three ring kernels
  kernel_parameters &lt;- c(0, 1, 1, 2, 2, 3)
  robsbss_result &lt;- 
    robsbss(X, coords, kernel_type = 'ring', kernel_parameters = kernel_parameters)
  
  # print object
  print(robsbss_result)
  
  # plot latent field
  plot(robsbss_result, colorkey = TRUE, as.table = TRUE, cex = 1)
  
  # predict latent fields on grid
  predict(robsbss_result, colorkey = TRUE, as.table = TRUE, cex = 1)
  
  # unmixing matrix
  w_unmix &lt;- coef(robsbss_result)
}
</code></pre>

<hr>
<h2 id='sbss'>
Spatial Blind Source Separation
</h2><span id='topic+sbss'></span><span id='topic+sbss.default'></span><span id='topic+sbss.SpatialPointsDataFrame'></span><span id='topic+sbss.sf'></span>

<h3>Description</h3>

<p><code>sbss</code> estimates the unmixing matrix assuming a spatial blind source separation model by simultaneous/jointly diagonalizing the covariance matrix and one/many local covariance matrices. These local covariance matrices are determined by spatial kernel functions. Three types of such kernel functions are supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sbss(x, ...)

## Default S3 method:
sbss(x, coords, kernel_type = c('ring', 'ball', 'gauss'), 
     kernel_parameters, lcov = c('lcov', 'ldiff', 'lcov_norm'), ordered = TRUE, 
     kernel_list = NULL, rob_whitening = FALSE, ...)
## S3 method for class 'SpatialPointsDataFrame'
sbss(x, ...)
## S3 method for class 'sf'
sbss(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sbss_+3A_x">x</code></td>
<td>

<p>either a numeric matrix of dimension <code>c(n, p)</code> where the <code>p</code> columns correspond to the entries of the random field and the <code>n</code> rows are the observations, an object of class <code><a href="sp.html#topic+SpatialPointsDataFrame">SpatialPointsDataFrame</a></code> or an object of class <code><a href="sf.html#topic+sf">sf</a></code>. 
</p>
</td></tr>
<tr><td><code id="sbss_+3A_coords">coords</code></td>
<td>

<p>a numeric matrix of dimension <code>c(n,2)</code> where each row represents the coordinates of a point in the spatial domain. Only needed if <code>x</code> is a matrix and the argument <code>kernel_list</code> is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="sbss_+3A_kernel_type">kernel_type</code></td>
<td>

<p>a string indicating which kernel function to use. Either <code>'ring'</code> (default), <code>'ball'</code> or <code>'gauss'</code>.
</p>
</td></tr>
<tr><td><code id="sbss_+3A_kernel_parameters">kernel_parameters</code></td>
<td>

<p>a numeric vector that gives the parameters for the kernel function. At least length of one for <code>'ball'</code> and <code>'gauss'</code> or two for <code>'ring'</code> kernel, see details.
</p>
</td></tr>
<tr><td><code id="sbss_+3A_lcov">lcov</code></td>
<td>

<p>a string indicating which type of local covariance matrix to use. Either <code>'lcov'</code> (default), <code>'ldiff'</code> or <code>'lcov_norm'</code>. See <code><a href="#topic+sbss_asymp">sbss_asymp</a></code> for details on the latter option.
</p>
</td></tr>
<tr><td><code id="sbss_+3A_ordered">ordered</code></td>
<td>

<p>logical. If <code>TRUE</code> the entries of the latent field are ordered by the sum of squared (pseudo-)eigenvalues of the diagonalized local covariance matrix/matrices. Default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="sbss_+3A_kernel_list">kernel_list</code></td>
<td>

<p>a list of spatial kernel matrices with dimension <code>c(n,n)</code>, see details. Usually computed by the function <code><a href="#topic+spatial_kernel_matrix">spatial_kernel_matrix</a></code>.
</p>
</td></tr>
<tr><td><code id="sbss_+3A_rob_whitening">rob_whitening</code></td>
<td>

<p>logical. If <code>TRUE</code> whitening is carried out with respect to the first spatial scatter matrix and not the sample covariance matrix, see details. Default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="sbss_+3A_...">...</code></td>
<td>

<p>further arguments for the fast real joint diagonalization algorithm that jointly diagonalizes the local covariance matrices. See details and <code><a href="JADE.html#topic+frjd">frjd</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Three versions of local covariance matrices are implemented, the argument <code>lcov</code> determines which version is used:
</p>

<ul>
<li> <p><code>'lcov'</code>: </p>
<p style="text-align: center;"><code class="reqn"> LCov(f) = 1/n \sum_{i,j} f(d_{i,j}) (x(s_i)-\bar{x}) (x(s_j)-\bar{x})' ,</code>
</p>

</li>
<li> <p><code>'ldiff'</code>: </p>
<p style="text-align: center;"><code class="reqn"> LDiff(f) = 1/n \sum_{i,j} f(d_{i,j}) (x(s_i)-x(s_j)) (x(s_i)-x(s_j))',</code>
</p>

</li>
<li> <p><code>'lcov_norm'</code>: </p>
<p style="text-align: center;"><code class="reqn"> LCov^*(f) = 1/(n F^{1/2}_{f,n}) \sum_{i,j} f(d_{i,j}) (x(s_i)-\bar{x}) (x(s_j)-\bar{x})',</code>
</p>
<p> with </p>
<p style="text-align: center;"><code class="reqn"> F_{f,n} = 1 / n \sum_{i,j} f^2(d_{i,j}).</code>
</p>

</li></ul>

<p>Where <code class="reqn">d_{i,j} \ge 0</code> correspond to the pairwise distances between coordinates, <code class="reqn">x(s_i)</code> are the <code>p</code> random field values at location <code class="reqn">s_i</code>, <code class="reqn">\bar{x}</code> is the sample mean vector, and the kernel function <code class="reqn">f(d)</code> determines the locality. The choice <code>'lcov_norm'</code> is useful when testing for the actual signal dimension of the latent field, see <code><a href="#topic+sbss_asymp">sbss_asymp</a></code> and <code><a href="#topic+sbss_boot">sbss_boot</a></code>. LDiff matrices are supposed to be more robust when the random field shows a smooth trend. The following kernel functions are implemented and chosen with the argument <code>kernel_type</code>:
</p>

<ul>
<li> <p><code>'ring'</code>: parameters are inner radius <code class="reqn">r_{in}</code> and outer radius <code class="reqn">r_{out}</code>, with <code class="reqn">r_{in} &lt; r_{out}</code>, and <code class="reqn">r_{in}, r_{out} \ge 0</code>: </p>
<p style="text-align: center;"><code class="reqn">f(d;r_{in}, r_{out}) = I(r_{in} &lt; d \le r_{out})</code>
</p>

</li>
<li> <p><code>'ball'</code>: parameter is the radius <code class="reqn">r</code>, with <code class="reqn">r \ge 0</code>: </p>
<p style="text-align: center;"><code class="reqn">f(d;r) = I(d \le r)</code>
</p>

</li>
<li> <p><code>'gauss'</code>: Gaussian function where 95% of the mass is inside the parameter <code class="reqn">r</code>, with <code class="reqn">r \ge 0</code>: </p>
<p style="text-align: center;"><code class="reqn">f(d;r) = exp(-0.5 (\Phi^{-1}(0.95) d/r)^2)</code>
</p>

</li></ul>

<p>The argument <code>kernel_type</code> determines the used kernel function as presented above, the argument <code>kernel_parameters</code> gives the corresponding parameters for the kernel function. Specifically, if <code>kernel_type</code> equals <code>'ball'</code> or <code>'gauss'</code> then <code>kernel_parameters</code> is a numeric vector where each entry corresponds to one parameter. Hence, <code>length(kernel_parameters)</code> local covariance matrices are used. Whereas, if <code>kernel_type</code> equals <code>'ring'</code>, then <code>kernel_parameters</code> must be a numeric vector of even length where subsequently the inner and outer radii must be given (informally: <code>c(r_in1, r_out1, r_in2, r_out2, ...)</code>). In that case <code>length(kernel_parameters) / 2</code> local covariance matrices are used.
</p>
<p>Internally, <code>sbss</code> calls <code><a href="#topic+spatial_kernel_matrix">spatial_kernel_matrix</a></code> to compute a list of <code>c(n,n)</code> kernel matrices based on the parameters given, where each entry of those matrices corresponds to <code class="reqn">f(d_{i,j})</code>. Alternatively, such a list of kernel matrices can be given directly to the function <code>sbss</code> via the <code>kernel_list</code> argument. This is useful when <code>sbss</code> is called numerous times with the same coordinates/kernel functions as the computation of the kernel matrices is then done only once prior the actual <code>sbss</code> calls. For details see also <code><a href="#topic+spatial_kernel_matrix">spatial_kernel_matrix</a></code>.
</p>
<p><code>rob_whitening</code> determines which scatter is used for the whitening step. If <code>TRUE</code>, whitening is carried out with respect to the scatter matrix defined by the <code>lcov</code> argument, where the kernel function is given by the argument <code>kernel_type</code> and the parameters correspond to the first occuring in the argument <code>kernel_parameters</code>. Therefore, at least two different kernel parameters need to be given. Note that only <code class="reqn">LDiff(f)</code> matrices are positive definite, hence whitening with <code>'lcov'</code> is likely to produce an error. If the argument is <code>FALSE</code>, whitening is carried out with respect to the usual sample covariance matrix. <code>sbss</code> internally calls <code><a href="#topic+white_data">white_data</a></code>.
</p>
<p>If more than one local covariance matrix is used <code>sbss</code> jointly diagonalizes these matrices with the function <code><a href="JADE.html#topic+frjd">frjd</a></code>. <code>...</code> provides arguments for <code>frjd</code>, useful arguments might be:
</p>

<ul>
<li> <p><code>eps</code>: tolerance for convergence.
</p>
</li>
<li> <p><code>maxiter</code>: maximum number of iterations.
</p>
</li></ul>



<h3>Value</h3>

<p><code>sbss</code> returns a list of class <code>'sbss'</code> with the following entries: 
</p>
<table>
<tr><td><code>s</code></td>
<td>

<p>object of <code>class(x)</code> containing the estimated source random field.
</p>
</td></tr>  
<tr><td><code>coords</code></td>
<td>

<p>coordinates of the observations. Is <code>NULL</code> if <code>x</code> was a matrix and the argument <code>kernel_list</code> was not <code>NULL</code> at the <code>sbss</code> call.
</p>
</td></tr>
<tr><td><code>w</code></td>
<td>

<p>estimated unmixing matrix.
</p>
</td></tr>
<tr><td><code>w_inv</code></td>
<td>

<p>inverse of the estimated unmixing matrix.
</p>
</td></tr>
<tr><td><code>pevals</code></td>
<td>

<p>(pseudo-)eigenvalues for each latent field entry.
</p>
</td></tr>  
<tr><td><code>d</code></td>
<td>

<p>matrix of stacked (jointly) diagonalized local covariance matrices with dimension <code>c(length(kernel_parameters)*p,p)</code> for <code>'ball'</code> and <code>'gauss'</code> kernel or <code>c(</code>
<code>(length(kernel_parameters) / 2)*p,p)</code> for <code>'ring'</code> kernel.
</p>
</td></tr>
<tr><td><code>diags</code></td>
<td>

<p>matrix of dimension <code>c(length(kernel_parameters),p)</code> where the rows contain the diagonal of the diagonalized local autocovariance matrices.
</p>
</td></tr>
<tr><td><code>x_mu</code></td>
<td>

<p>columnmeans of <code>x</code>.
</p>
</td></tr>
<tr><td><code>cov_inv_sqrt</code></td>
<td>

<p>square root of the inverse sample covariance matrix of <code>x</code>.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Muehlmann, C., Filzmoser, P. and Nordhausen, K. (2021), <em>Spatial Blind Source Separation in the Presence of a Drift</em>, Submitted for publication. Preprint available at <a href="https://arxiv.org/abs/2108.13813">https://arxiv.org/abs/2108.13813</a>.
</p>
<p>Bachoc, F., Genton, M. G, Nordhausen, K., Ruiz-Gazen, A. and Virta, J. (2020), <em>Spatial Blind Source Separation</em>, Biometrika, 107, 627-646, <a href="https://doi.org/10.1093/biomet/asz079">doi:10.1093/biomet/asz079</a>.
</p>
<p>Nordhausen, K., Oja, H., Filzmoser, P., Reimann, C. (2015), <em>Blind Source Separation for Spatial Compositional Data</em>, Mathematical Geosciences 47, 753-770, <a href="https://doi.org/10.1007/s11004-014-9559-5">doi:10.1007/s11004-014-9559-5</a>.
</p>
<p>Muehlmann, C., Bachoc, F., Nordhausen, K. and Yi, M. (2022), <em>Test of the Latent Dimension of a Spatial Blind Source Separation Model</em>, to appear in Statistica Sinica, <a href="https://doi.org/10.5705/ss.202021.0326">doi:10.5705/ss.202021.0326</a>.v
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spatial_kernel_matrix">spatial_kernel_matrix</a></code>, <code><a href="#topic+local_covariance_matrix">local_covariance_matrix</a></code>, <code><a href="sp.html#topic+sp">sp</a></code>, <code><a href="sf.html#topic+sf">sf</a></code>, <code><a href="JADE.html#topic+frjd">frjd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate coordinates
coords &lt;- runif(1000 * 2) * 20
dim(coords) &lt;- c(1000, 2)
coords_df &lt;- as.data.frame(coords)
names(coords_df) &lt;- c("x", "y")

# simulate random field
if (!requireNamespace('gstat', quietly = TRUE)) {
  message('Please install the package gstat to run the example code.')
} else {
  library(gstat)
  model_1 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, model = 'Exp'), nmax = 20)
  model_2 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, kappa = 2, model = 'Mat'), 
                   nmax = 20)
  model_3 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, model = 'Gau'), nmax = 20)
  field_1 &lt;- predict(model_1, newdata = coords_df, nsim = 1)$sim1
  field_2 &lt;- predict(model_2, newdata = coords_df, nsim = 1)$sim1
  field_3 &lt;- predict(model_3, newdata = coords_df, nsim = 1)$sim1
  field &lt;- as.matrix(cbind(field_1, field_2, field_3))

  # apply sbss with three ring kernels
  kernel_parameters &lt;- c(0, 1, 1, 2, 2, 3)
  sbss_result &lt;- 
    sbss(field, coords, kernel_type = 'ring', kernel_parameters = kernel_parameters)
  
  # print object
  print(sbss_result)
  
  # plot latent field
  plot(sbss_result, colorkey = TRUE, as.table = TRUE, cex = 1)
  
  # predict latent fields on grid
  predict(sbss_result, colorkey = TRUE, as.table = TRUE, cex = 1)
  
  # unmixing matrix
  w_unmix &lt;- coef(sbss_result)
  
  # apply the same sbss with a kernel list
  kernel_list &lt;- spatial_kernel_matrix(coords, kernel_type = 'ring', kernel_parameters)
  sbss_result_k &lt;- sbss(field, kernel_list = kernel_list)
  
  # apply sbss with three ring kernels and local difference matrices
  sbss_result_ldiff &lt;- 
    sbss(field, coords, kernel_type = 'ring', 
         kernel_parameters = kernel_parameters, lcov = 'ldiff')
}

</code></pre>

<hr>
<h2 id='sbss_asymp'>
Asymptotic Test for the White Noise Dimension in a Spatial Blind Source Separation Model
</h2><span id='topic+sbss_asymp'></span><span id='topic+sbss_asymp.default'></span><span id='topic+sbss_asymp.SpatialPointsDataFrame'></span><span id='topic+sbss_asymp.sf'></span>

<h3>Description</h3>

<p><code>sbss_asymp</code> uses asymptotic theory for the spatial blind source separation (SBSS) methodology to test if the last <code class="reqn">p - q</code> entries of the latent random field are white noise assuming that the <code class="reqn">p</code>-variate observed random field follows a SBSS model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sbss_asymp(x, ...)

## Default S3 method:
sbss_asymp(x, coords, q, kernel_parameters, 
           kernel_list = NULL, ...)
## S3 method for class 'SpatialPointsDataFrame'
sbss_asymp(x, ...)
## S3 method for class 'sf'
sbss_asymp(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sbss_asymp_+3A_x">x</code></td>
<td>

<p>either a numeric matrix of dimension <code>c(n, p)</code> where the <code>p</code> columns correspond to the entries of the random field and the <code>n</code> rows are the observations, an object of class <code><a href="sp.html#topic+SpatialPointsDataFrame">SpatialPointsDataFrame</a></code> or an object of class <code><a href="sf.html#topic+sf">sf</a></code>. 
</p>
</td></tr>
<tr><td><code id="sbss_asymp_+3A_coords">coords</code></td>
<td>

<p>a numeric matrix of dimension <code>c(n,2)</code> where each row represents the coordinates of a point in the spatial domain. Only needed if <code>x</code> is a matrix and the argument <code>kernel_list</code> is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="sbss_asymp_+3A_q">q</code></td>
<td>

<p>an integer between <code>0</code> and <code>p - 1</code> specifying the number of hypothetical signal components (null hypothesis) in the latent random field.
</p>
</td></tr>
<tr><td><code id="sbss_asymp_+3A_kernel_parameters">kernel_parameters</code></td>
<td>

<p>a numeric vector that gives the parameters for the ring kernel function. At least length of two, see details.
</p>
</td></tr>
<tr><td><code id="sbss_asymp_+3A_kernel_list">kernel_list</code></td>
<td>

<p>a list of spatial kernel matrices with dimension <code>c(n,n)</code>, see details. Usually computed by the function <code><a href="#topic+spatial_kernel_matrix">spatial_kernel_matrix</a></code>.
</p>
</td></tr>
<tr><td><code id="sbss_asymp_+3A_...">...</code></td>
<td>

<p>further arguments for the fast real joint diagonalization algorithm that jointly diagonalizes the local covariance matrices. See details and <code><a href="JADE.html#topic+frjd">frjd</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the SBSS methodology in conjunction with local covariance matrices based on ring kernel functions to estimate the <code class="reqn">p</code>-variate latent random field <code class="reqn">s = x^{wh} w</code>, where <code class="reqn">x^{wh}</code> is the whitened version of the data and <code class="reqn">w</code> is the estimated unmixing matrix. The considered (adapted) local covariance matrices write as
</p>
<p style="text-align: center;"><code class="reqn"> LCov^* = 1/(n F^{1/2}_n) \sum_{i,j} I(r_i &lt; d_{i,j} \le r_o) (x(s_i)-\bar{x}) (x(s_j)-\bar{x})'</code>
</p>

<p>with
</p>
<p style="text-align: center;"><code class="reqn"> F_n = 1 / n \sum_{i,j} I(r_i &lt; d_{i,j} \le r_o).</code>
</p>

<p>Where <code class="reqn">d_{i,j} \ge 0</code> correspond to the pairwise distances between coordinates, <code class="reqn">x(s_i)</code> are the <code>p</code> random field values at location <code class="reqn">s_i</code> (which is the i-th row of the argument <code>x</code> and the location corresponds to the i-th row of the argument <code>coords</code>) and <code class="reqn">\bar{x}</code> is the sample mean vector. The function argument <code>kernel_parameters</code> determines the parameters of the used ring kernel functions or alternatively a list of kernel matrices can be given with the argument <code>kernel_list</code>, see <code><a href="#topic+sbss">sbss</a></code> for details. 
</p>
<p>The null hypothesis specified with the argument <code>q</code> states that the last <code class="reqn">p - q</code> components of the estimated latent field are white noise. The method orders the components of the latent field by the order of the decreasing sums of squares of the corresponding (pseudo-)eigenvalues of the local covariance matrices produced by the joint diagonalization algorithm (or the eigendecomposition if only one local covariance matrix is used). Under the null the lower right <code class="reqn">(p - q) * (p - q)</code> block matrices of the jointly diagonalized local covariance matrices equal zero matrices. Therefore, the sum of their squared norms <code class="reqn">m</code> is used as test statistic.  
</p>
<p>This function conducts the hypothesis test using the asymptotic null distribution of <code class="reqn">m</code>, a chi-squared distribution with <code class="reqn">k(p - q)(p - q + 1)/2</code> degrees of freedom (<code class="reqn">k</code> is the number jointly diagonalized local covariance matrices).
</p>
<p>If more than one local covariance matrix is used <code>sbss_asymp</code> jointly diagonalizes these matrices with the function <code><a href="JADE.html#topic+frjd">frjd</a></code>. <code>...</code> provides arguments for <code>frjd</code>, useful arguments might be:
</p>

<ul>
<li> <p><code>eps</code>: tolerance for convergence.
</p>
</li>
<li> <p><code>maxiter</code>: maximum number of iterations.
</p>
</li></ul>



<h3>Value</h3>

<p><code>sbss_asymp</code> returns a list of class <code>'sbss_test'</code> inheriting from the classes <code>'htest'</code> and <code>'sbss'</code> with the following entries: 
</p>
<table>
<tr><td><code>alternative</code></td>
<td>

<p>a string containing the alternative hypothesis.
</p>
</td></tr> 
<tr><td><code>method</code></td>
<td>

<p>a string which indicates which test methods was used.
</p>
</td></tr> 
<tr><td><code>data.name</code></td>
<td>

<p>a string specifying the name of the used data.
</p>
</td></tr> 
<tr><td><code>statistic</code></td>
<td>

<p>the value of the test statistic.
</p>
</td></tr> 
<tr><td><code>parameters</code></td>
<td>

<p>degrees of freedom for the asymptotic chi-squared distribution of the test statistic under the null hypothesis.
</p>
</td></tr> 
<tr><td><code>p.value</code></td>
<td>

<p>the p-value of the test.
</p>
</td></tr> 
<tr><td><code>s</code></td>
<td>

<p>object of <code>class(x)</code> containing the estimated source random field.
</p>
</td></tr>  
<tr><td><code>coords</code></td>
<td>

<p>coordinates of the observations. Is <code>NULL</code> if <code>x</code> was a matrix and the argument <code>kernel_list</code> was not <code>NULL</code> at the <code>sbss_asymp</code> call.
</p>
</td></tr>
<tr><td><code>w</code></td>
<td>

<p>estimated unmixing matrix.
</p>
</td></tr>
<tr><td><code>w_inv</code></td>
<td>

<p>inverse of the estimated unmixing matrix.
</p>
</td></tr>
<tr><td><code>d</code></td>
<td>

<p>matrix of stacked (jointly) diagonalized local covariance matrices with dimension <code>c((length(kernel_parameters) / 2)*p,p)</code>.
</p>
</td></tr>
<tr><td><code>x_mu</code></td>
<td>

<p>columnmeans of <code>x</code>.
</p>
</td></tr>
<tr><td><code>cov_inv_sqrt</code></td>
<td>

<p>square root of the inverse sample covariance matrix of <code>x</code>.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Muehlmann, C., Bachoc, F., Nordhausen, K. and Yi, M. (2022), <em>Test of the Latent Dimension of a Spatial Blind Source Separation Model</em>, to appear in Statistica Sinica, <a href="https://doi.org/10.5705/ss.202021.0326">doi:10.5705/ss.202021.0326</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbss">sbss</a></code>, <code><a href="#topic+spatial_kernel_matrix">spatial_kernel_matrix</a></code>, <code><a href="#topic+local_covariance_matrix">local_covariance_matrix</a></code>, <code><a href="sp.html#topic+sp">sp</a></code>, 
<code><a href="sf.html#topic+sf">sf</a></code>, <code><a href="JADE.html#topic+frjd">frjd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate coordinates
n &lt;- 1000
coords &lt;- runif(n * 2) * 20
dim(coords) &lt;- c(n, 2)
coords_df &lt;- as.data.frame(coords)
names(coords_df) &lt;- c("x", "y")
# simulate random field
if (!requireNamespace('gstat', quietly = TRUE)) {
  message('Please install the package gstat to run the example code.')
} else {
  library(gstat)
  model_1 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, model = 'Exp'), nmax = 20)
  model_2 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, kappa = 2, model = 'Mat'), 
                   nmax = 20)
  field_1 &lt;- predict(model_1, newdata = coords_df, nsim = 1)$sim1
  field_2 &lt;- predict(model_2, newdata = coords_df, nsim = 1)$sim1
  field_3 &lt;- rnorm(n)
  field_4 &lt;- rnorm(n)
  
  latent_field &lt;- cbind(as.matrix(cbind(field_1, field_2)), field_3, field_4)
  mixing_matrix &lt;- matrix(rnorm(16), 4, 4)
  observed_field &lt;- latent_field %*% t(mixing_matrix)
  
  # apply the asymptotic test for a hypothetical latent white noise dimension of q
  # q can lie between 0 and 3 in this case
  # using one ring kernel function and the null hypothesis q = 1
  asymp_res_1 &lt;- 
    sbss_asymp(observed_field, coords, q = 1, kernel_parameters = c(0, 1))
  
  # using two ring kernel functions and the null hypothesis q = 3
  asymp_res_2 &lt;- 
    sbss_asymp(observed_field, coords, q = 3, kernel_parameters = c(0, 1, 1, 2))
    
  # the result is of class sbss_test which is inherited from htest and sbss
  # print object (print method for an object of class htest)
  print(asymp_res_1)
  print(asymp_res_2)
  
  # plot latent field (plot method for an object of class sbss)
  plot(asymp_res_1, colorkey = TRUE, as.table = TRUE, cex = 1)
  
  # predict latent fields on grid (predict method for an object of class sbss)
  predict(asymp_res_1, colorkey = TRUE, as.table = TRUE, cex = 1)
  
  # unmixing matrix (coef method for an object of class sbss)
  w_unmix &lt;- coef(asymp_res_1)
}

</code></pre>

<hr>
<h2 id='sbss_boot'>
Different Bootstrap Tests for the White Noise Dimension in a Spatial Blind Source Separation Model
</h2><span id='topic+sbss_boot'></span><span id='topic+sbss_boot.default'></span><span id='topic+sbss_boot.SpatialPointsDataFrame'></span><span id='topic+sbss_boot.sf'></span>

<h3>Description</h3>

<p><code>sbss_boot</code> uses bootstrap tests for the spatial blind source separation (SBSS) methodology to test if the last <code class="reqn">p - q</code> entries of the latent random field are white noise assuming that the <code class="reqn">p</code>-variate observed random field follows a SBSS model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sbss_boot(x, ...)

## Default S3 method:
sbss_boot(x, coords, q, kernel_parameters, 
          boot_method = c('permute', 'parametric'), 
          n_boot = 200, kernel_list = NULL, ...) 
## S3 method for class 'SpatialPointsDataFrame'
sbss_boot(x, ...)
## S3 method for class 'sf'
sbss_boot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sbss_boot_+3A_x">x</code></td>
<td>

<p>either a numeric matrix of dimension <code>c(n, p)</code> where the <code>p</code> columns correspond to the entries of the random field and the <code>n</code> rows are the observations, an object of class <code><a href="sp.html#topic+SpatialPointsDataFrame">SpatialPointsDataFrame</a></code> or an object of class <code><a href="sf.html#topic+sf">sf</a></code>. 
</p>
</td></tr>
<tr><td><code id="sbss_boot_+3A_coords">coords</code></td>
<td>

<p>a numeric matrix of dimension <code>c(n,2)</code> where each row represents the coordinates of a point in the spatial domain. Only needed if <code>x</code> is a matrix and the argument <code>kernel_list</code> is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="sbss_boot_+3A_q">q</code></td>
<td>

<p>an integer between <code>0</code> and <code>p - 1</code> specifying the number of hypothetical signal components (null hypothesis) in the latent random field.
</p>
</td></tr>
<tr><td><code id="sbss_boot_+3A_kernel_parameters">kernel_parameters</code></td>
<td>

<p>a numeric vector that gives the parameters for the ring kernel function. At least length of two, see details.
</p>
</td></tr>
<tr><td><code id="sbss_boot_+3A_boot_method">boot_method</code></td>
<td>

<p>a string indicating which bootstrap strategy is used, see details. Either <code>'permute'</code> (default) or <code>'parametric'</code>.
</p>
</td></tr>
<tr><td><code id="sbss_boot_+3A_n_boot">n_boot</code></td>
<td>

<p>positive integer specifying the number of bootstrap samples. Default is <code class="reqn">200</code>.
</p>
</td></tr>
<tr><td><code id="sbss_boot_+3A_kernel_list">kernel_list</code></td>
<td>

<p>a list of spatial kernel matrices with dimension <code>c(n,n)</code>, see details. Usually computed by the function <code><a href="#topic+spatial_kernel_matrix">spatial_kernel_matrix</a></code>.
</p>
</td></tr>
<tr><td><code id="sbss_boot_+3A_...">...</code></td>
<td>

<p>further arguments for the fast real joint diagonalization algorithm that jointly diagonalizes the local covariance matrices. See details and <code><a href="JADE.html#topic+frjd">frjd</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the SBSS methodology in conjunction with local covariance matrices based on ring kernel functions to estimate the <code class="reqn">p</code>-variate latent random field <code class="reqn">s = x^{wh} w</code>, where <code class="reqn">x^{wh}</code> is the whitened version of the data and <code class="reqn">w</code> is the estimated unmixing matrix. The considered (adapted) local covariance matrices write as
</p>
<p style="text-align: center;"><code class="reqn"> LCov^* = 1/(n F^{1/2}_n) \sum_{i,j} I(r_i &lt; d_{i,j} \le r_o) (x(s_i)-\bar{x}) (x(s_j)-\bar{x})'</code>
</p>

<p>with
</p>
<p style="text-align: center;"><code class="reqn"> F_n = 1 / n \sum_{i,j} I(r_i &lt; d_{i,j} \le r_o).</code>
</p>

<p>Where <code class="reqn">d_{i,j} \ge 0</code> correspond to the pairwise distances between coordinates, <code class="reqn">x(s_i)</code> are the <code>p</code> random field values at location <code class="reqn">s_i</code> (which is the i-th row of the argument <code>x</code> and the location corresponds to the i-th row of the argument <code>coords</code>) and <code class="reqn">\bar{x}</code> is the sample mean vector. The function argument <code>kernel_parameters</code> determines the parameters of the used ring kernel functions or alternatively a list of kernel matrices can be given with the argument <code>kernel_list</code>, see <code><a href="#topic+sbss">sbss</a></code> for details. 
</p>
<p>The null hypothesis specified with the argument <code>q</code> states that the last <code class="reqn">p - q</code> components of the estimated latent field are white noise. The method orders the components of the latent field by the order of the decreasing sums of squares of the corresponding (pseudo-)eigenvalues of the local covariance matrices produced by the joint diagonalization algorithm (or the eigendecomposition if only one local covariance matrix is used). Under the null the lower right <code class="reqn">(p - q) * (p - q)</code> block matrices of the jointly diagonalized local covariance matrices equal zero matrices. Therefore, the sum of their squared norms <code class="reqn">m</code> is used as test statistic for the bootstrap based inference methods described below. 
</p>

<ol>
<li><p> Compute the test statistic <code class="reqn">m</code> based on the original data <code class="reqn">x</code>.
</p>
</li>
<li><p> The estimated latent field <code class="reqn">s</code> (its dimension is <code>c(n,p)</code>) is split into the signal part (first <code>q</code> columns) and the white noise part (last <code>p - q</code> columns).
</p>
</li>
<li><p> Replace the noise part by a bootstrap sample drawn based on one of the two strategies described below.
</p>
</li>
<li><p> Recombine the signal part and resampled noise part by concatenating the columns leading to <code class="reqn">s^{bs}</code> and back-transform it by <code class="reqn">x^{bs} = s^{bs}  w^{-1}</code>.
</p>
</li>
<li><p> Compute the test statistic <code class="reqn">m^{bs}</code> based on <code class="reqn">x^{bs}</code>.
</p>
</li>
<li><p> Repeat Step 2 - 5 for a total amount of <code>n_boot</code> times (default is <code>200</code>) and the p-value of the bootstrap test is computed by
</p>
<p style="text-align: center;"><code class="reqn"> (sum(m &gt; m^{bs}) + 1) / (n_{boot} + 1). </code>
</p>

</li></ol>

<p>The argument <code>boot_method</code> (default is <code>"permute"</code>) specifies the used resample strategy. The two following strategies are implemented:
</p>

<ul>
<li> <p><code>boot_method = "permute"</code>: 
This strategy is non-parametric. It draws each bootstrap sample from the vector of all <code class="reqn">n(p - q)</code> observed hypothetical white noise observations.
</p>
</li>
<li> <p><code>boot_method = "parametric"</code>: 
This is parametric. Each bootstrap sample is drawn independently and identically from the standard normal distribution.
</p>
</li></ul>

<p>If more than one local covariance matrix is used <code>sbss_boot</code> jointly diagonalizes these matrices with the function <code><a href="JADE.html#topic+frjd">frjd</a></code>. <code>...</code> provides arguments for <code>frjd</code>, useful arguments might be:
</p>

<ul>
<li> <p><code>eps</code>: tolerance for convergence.
</p>
</li>
<li> <p><code>maxiter</code>: maximum number of iterations.
</p>
</li></ul>



<h3>Value</h3>

<p><code>sbss_boot</code> returns a list of class <code>'sbss_test'</code> inheriting from the classes <code>'htest'</code> and <code>'sbss'</code> with the following entries: 
</p>
<table>
<tr><td><code>alternative</code></td>
<td>

<p>a string containing the alternative hypothesis.
</p>
</td></tr> 
<tr><td><code>method</code></td>
<td>

<p>a string which indicates which test methods was used.
</p>
</td></tr> 
<tr><td><code>data.name</code></td>
<td>

<p>a string specifying the name of the used data.
</p>
</td></tr> 
<tr><td><code>statistic</code></td>
<td>

<p>the value of the test statistic.
</p>
</td></tr> 
<tr><td><code>parameters</code></td>
<td>

<p>a integer specifying the number of generated bootstrap samples (the value of the argument <code>n_boot</code>).
</p>
</td></tr> 
<tr><td><code>p.value</code></td>
<td>

<p>the p-value of the test.
</p>
</td></tr> 
<tr><td><code>s</code></td>
<td>

<p>object of <code>class(x)</code> containing the estimated source random field.
</p>
</td></tr>  
<tr><td><code>coords</code></td>
<td>

<p>coordinates of the observations. Is <code>NULL</code> if <code>x</code> was a matrix and the argument <code>kernel_list</code> was not <code>NULL</code> at the <code>sbss_boot</code> call.
</p>
</td></tr>
<tr><td><code>w</code></td>
<td>

<p>estimated unmixing matrix.
</p>
</td></tr>
<tr><td><code>w_inv</code></td>
<td>

<p>inverse of the estimated unmixing matrix.
</p>
</td></tr>
<tr><td><code>d</code></td>
<td>

<p>matrix of stacked (jointly) diagonalized local covariance matrices with dimension <code>c((length(kernel_parameters) / 2)*p,p)</code>.
</p>
</td></tr>
<tr><td><code>x_mu</code></td>
<td>

<p>columnmeans of <code>x</code>.
</p>
</td></tr>
<tr><td><code>cov_inv_sqrt</code></td>
<td>

<p>square root of the inverse sample covariance matrix of <code>x</code>.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Muehlmann, C., Bachoc, F., Nordhausen, K. and Yi, M. (2022), <em>Test of the Latent Dimension of a Spatial Blind Source Separation Model</em>, to appear in Statistica Sinica, <a href="https://doi.org/10.5705/ss.202021.0326">doi:10.5705/ss.202021.0326</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbss">sbss</a></code>, <code><a href="#topic+spatial_kernel_matrix">spatial_kernel_matrix</a></code>, <code><a href="#topic+local_covariance_matrix">local_covariance_matrix</a></code>, <code><a href="sp.html#topic+sp">sp</a></code>, 
<code><a href="sf.html#topic+sf">sf</a></code>, <code><a href="JADE.html#topic+frjd">frjd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate coordinates
n &lt;- 1000
coords &lt;- runif(n * 2) * 20
dim(coords) &lt;- c(n, 2)
coords_df &lt;- as.data.frame(coords)
names(coords_df) &lt;- c("x", "y")
# simulate random field
if (!requireNamespace('gstat', quietly = TRUE)) {
  message('Please install the package gstat to run the example code.')
} else {
  library(gstat)
  model_1 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, model = 'Exp'), nmax = 20)
  model_2 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, kappa = 2, model = 'Mat'), 
                   nmax = 20)
  field_1 &lt;- predict(model_1, newdata = coords_df, nsim = 1)$sim1
  field_2 &lt;- predict(model_2, newdata = coords_df, nsim = 1)$sim1
  field_3 &lt;- rnorm(n)
  field_4 &lt;- rnorm(n)
  
  latent_field &lt;- cbind(as.matrix(cbind(field_1, field_2)), field_3, field_4)
  mixing_matrix &lt;- matrix(rnorm(16), 4, 4)
  observed_field &lt;- latent_field %*% t(mixing_matrix)
  
  # apply the bootstrap tests for a hypothetical latent white noise dimension of q
  # q can lie between 0 and 3 in this case
  # using one ring kernel function with the permute strategy
  # and the null hypothesis q = 1
  boot_res_1 &lt;- 
    sbss_boot(observed_field, coords, q = 1, kernel_parameters = c(0, 1), 
              boot_method = 'permute', n_boot = 100)
  
  # using two one ring kernel function with the parametric strategy
  # and the null hypothesis q = 3
  boot_res_2 &lt;- 
    sbss_boot(observed_field, coords, q = 3, kernel_parameters = c(0, 1, 1, 2), 
              boot_method = 'parametric', n_boot = 100)
    
  # the result is of class sbss_test which is inherited from htest and sbss
  # print object (print method for an object of class htest)
  print(boot_res_1)
  print(boot_res_2)
  
  # plot latent field (plot method for an object of class sbss)
  plot(boot_res_1, colorkey = TRUE, as.table = TRUE, cex = 1)
  
  # predict latent fields on grid (predict method for an object of class sbss)
  predict(boot_res_1, colorkey = TRUE, as.table = TRUE, cex = 1)
  
  # unmixing matrix (coef method for an object of class sbss)
  w_unmix &lt;- coef(boot_res_1)
}

</code></pre>

<hr>
<h2 id='snss_jd'>
Spatial Non-Stationary Source Separation Joint Diagonalization
</h2><span id='topic+snss_jd'></span><span id='topic+snss_jd.default'></span><span id='topic+snss_jd.list'></span><span id='topic+snss_jd.SpatialPointsDataFrame'></span><span id='topic+snss_jd.sf'></span>

<h3>Description</h3>

<p><code>snss_jd</code> estimates the unmixing matrix assuming a spatial non-stationary source separation model implying non-constant covariance by jointly diagonalizing at least two covariance matrices computed for corresponding different sub-domains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snss_jd(x, ...)

## Default S3 method:
snss_jd(x, coords, n_block, ordered = TRUE, ...)
## S3 method for class 'list'
snss_jd(x, coords, ordered = TRUE, ...)
## S3 method for class 'SpatialPointsDataFrame'
snss_jd(x, ...)
## S3 method for class 'sf'
snss_jd(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snss_jd_+3A_x">x</code></td>
<td>

<p>either a numeric matrix of dimension <code>c(n, p)</code> where the <code>p</code> columns correspond to the entries of the random field and the <code>n</code> rows are the observations, a list of length <code>K</code> defining the subdivision of the domain, an object of class <code><a href="sf.html#topic+sf">sf</a></code> or an object of class <code><a href="sp.html#topic+SpatialPointsDataFrame">SpatialPointsDataFrame</a></code>. 
</p>
</td></tr>
<tr><td><code id="snss_jd_+3A_coords">coords</code></td>
<td>

<p>a numeric matrix of dimension <code>c(n,2)</code> when <code>x</code> is a matrix where each row represents the sample location of a point in the spatial domain or a list of length <code>K</code> if <code>x</code> is a list which defines the subdivision of the domain. Not needed otherwise.
</p>
</td></tr>
<tr><td><code id="snss_jd_+3A_n_block">n_block</code></td>
<td>

<p>an integer defining the subdivision of the domain. See details.
</p>
</td></tr>
<tr><td><code id="snss_jd_+3A_ordered">ordered</code></td>
<td>

<p>logical. If <code>TRUE</code> the entries of the latent field are ordered by the sum of squared pseudo-eigenvalues of the diagonalized sub-domain covariance matrices. Default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="snss_jd_+3A_...">...</code></td>
<td>

<p>further arguments for the fast real joint diagonalization algorithm that jointly diagonalizes the sub-domain covariance matrices. See details and <code><a href="JADE.html#topic+frjd">frjd</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes that the random field <code class="reqn">x</code> is formed by </p>
<p style="text-align: center;"><code class="reqn"> x(t) = A s(t) + b, </code>
</p>
<p> where <code class="reqn">A</code> is the deterministic <code class="reqn">p \times p</code> mixing matrix, <code class="reqn">b</code> is the <code class="reqn">p</code>-dimensional location vector, <code class="reqn">x</code> is the observable <code class="reqn">p</code>-variate random field given by the argument <code>x</code>, <code class="reqn">t</code> are the spatial locations given by the argument <code>coords</code> and <code class="reqn">s</code> is the latent <code class="reqn">p</code>-variate random field assumed to consist of uncorrelated entries that have zero mean but non-constant variances. This function aims to recover <code class="reqn">s</code> by </p>
<p style="text-align: center;"><code class="reqn"> W(x(t) - \bar{x}), </code>
</p>
<p> where <code class="reqn">W</code> is the <code class="reqn">p \times p</code> unmixing matrix and <code class="reqn">\bar{x}</code> is the sample mean. The function does this by splitting the given spatial domain into <code>n_block^2</code> equally sized rectangular sub-domains and jointly diagonalizing the corresponding covariance matrices for all sub-domains.
</p>
<p>Alternatively the domain subdivision can be defined by providing lists of length <code>K</code> for the arguments <code>x</code> and <code>coords</code> where the first list entries correspond to the values and coordinates of the first sub-domain and the second entries to the values and coordinates of the second sub-domain, etc..
</p>
<p><code>snss_jd</code> jointly diagonalizes the covariance matrices for each sub-domain with the function <code><a href="JADE.html#topic+frjd">frjd</a></code>. <code>...</code> provides arguments for <code>frjd</code>, useful arguments might be:
</p>

<ul>
<li> <p><code>eps</code>: tolerance for convergence.
</p>
</li>
<li> <p><code>maxiter</code>: maximum number of iterations.
</p>
</li></ul>



<h3>Value</h3>

<p>Similarly as <code><a href="#topic+sbss">sbss</a></code> the function <code>snss_jd</code> returns a list of class <code>'snss'</code> and <code>'sbss'</code> with the following entries: 
</p>
<table>
<tr><td><code>s</code></td>
<td>

<p>object of <code>class(x)</code> containing the estimated source random field.
</p>
</td></tr>  
<tr><td><code>coords</code></td>
<td>

<p>coordinates of the observations. Only given if <code>x</code> is a matrix or list.
</p>
</td></tr>
<tr><td><code>w</code></td>
<td>

<p>estimated unmixing matrix.
</p>
</td></tr>
<tr><td><code>w_inv</code></td>
<td>

<p>inverse of the estimated unmixing matrix.
</p>
</td></tr>
<tr><td><code>d</code></td>
<td>

<p>matrix of stacked (jointly) diagonalized sub-domain covariance matrices with dimension <code>c(n_block^2*p,p)</code> or <code>c(K*p,p)</code> if <code>x</code> and <code>coords</code> are lists of length <code>K</code>.
</p>
</td></tr>
<tr><td><code>x_mu</code></td>
<td>

<p>columnmeans of <code>x</code>.
</p>
</td></tr>
<tr><td><code>cov_inv_sqrt</code></td>
<td>

<p>square root of the inverse sample covariance matrix of <code>x</code>.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Muehlmann, C., Bachoc, F. and Nordhausen, K. (2022), <em>Blind Source Separation for Non-Stationary Random Fields</em>, Spatial Statistics, 47, 100574, <a href="https://doi.org/10.1016/j.spasta.2021.100574">doi:10.1016/j.spasta.2021.100574</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbss">sbss</a></code>, <code><a href="sp.html#topic+sp">sp</a></code>, <code><a href="sf.html#topic+sf">sf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate coordinates
n &lt;- 1000
coords &lt;- runif(n * 2) * 20
dim(coords) &lt;- c(n, 2)

# simulate random field
field_1 &lt;- rnorm(n)
field_2 &lt;- 2 * sin(pi / 20 * coords[, 1]) * rnorm(n)
field_3 &lt;- rnorm(n) * (coords[, 1] &lt; 10) + rnorm(n, 0, 3) * (coords[, 1] &gt;= 10)

latent_field &lt;- cbind(field_1, field_2, field_3)
mixing_matrix &lt;- matrix(rnorm(9), 3, 3)
observed_field &lt;- latent_field 

observed_field_sp &lt;- sp::SpatialPointsDataFrame(coords = coords, 
                                                data = data.frame(observed_field))
sp::spplot(observed_field_sp, colorkey = TRUE, as.table = TRUE, cex = 1)

# apply snss_jd with 4 sub-domains 
res_4 &lt;- snss_jd(observed_field, coords, n_block = 2)
JADE::MD(W.hat = coef(res_4), A = mixing_matrix)

# apply snss_jd with 9 sub-domains
res_9 &lt;- snss_jd(observed_field, coords, n_block = 3)
JADE::MD(W.hat = coef(res_9), A = mixing_matrix)
cor(res_9$s, latent_field)

# print object
print(res_4)

# plot latent field
plot(res_4, colorkey = TRUE, as.table = TRUE, cex = 1)

# predict latent fields on grid
predict(res_4, colorkey = TRUE, as.table = TRUE, cex = 1)

# unmixing matrix
w_unmix &lt;- coef(res_4)

# apply snss_jd with SpatialPointsDataFrame object 
res_4_sp &lt;- snss_jd(observed_field_sp, n_block = 2)

# apply with list arguments
# first axis split by 5
# second axis split by 10
# results in 4 sub-domains
flag_x &lt;- coords[, 1] &lt; 5
flag_y &lt;- coords[, 2] &lt; 10
coords_list &lt;- list(coords[flag_x &amp; flag_y, ],
                    coords[!flag_x &amp; flag_y, ],
                    coords[flag_x &amp; !flag_y, ],
                    coords[!flag_x &amp; !flag_y, ])
field_list &lt;- list(observed_field[flag_x &amp; flag_y, ],
                   observed_field[!flag_x &amp; flag_y, ],
                   observed_field[flag_x &amp; !flag_y, ],
                   observed_field[!flag_x &amp; !flag_y, ])
plot(coords, col = 1)
points(coords_list[[2]], col = 2)
points(coords_list[[3]], col = 3)
points(coords_list[[4]], col = 4)

res_list &lt;- snss_jd(x = field_list,
                    coords = coords_list)
plot(res_list, colorkey = TRUE, as.table = TRUE, cex = 1)
JADE::MD(W.hat = coef(res_list), A = mixing_matrix)

</code></pre>

<hr>
<h2 id='snss_sd'>
Spatial Non-Stationary Source Separation Simultaneous Diagonalization
</h2><span id='topic+snss_sd'></span><span id='topic+snss_sd.default'></span><span id='topic+snss_sd.list'></span><span id='topic+snss_sd.SpatialPointsDataFrame'></span><span id='topic+snss_sd.sf'></span>

<h3>Description</h3>

<p><code>snss_sd</code> estimates the unmixing matrix assuming a spatial non-stationary source separation model implying non-constant covariance by simultaneously diagonalizing two covariance matrices computed for two corresponding different sub-domains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snss_sd(x, ...)

## Default S3 method:
snss_sd(x, coords, direction = c('x', 'y'), 
     ordered = TRUE, ...)
## S3 method for class 'list'
snss_sd(x, coords, ordered = TRUE, ...)
## S3 method for class 'SpatialPointsDataFrame'
snss_sd(x, ...)
## S3 method for class 'sf'
snss_sd(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snss_sd_+3A_x">x</code></td>
<td>

<p>either a numeric matrix of dimension <code>c(n, p)</code> where the <code>p</code> columns correspond to the entries of the random field and the <code>n</code> rows are the observations, a list of length two defining the subdivision of the domain, an object of class <code><a href="sf.html#topic+sf">sf</a></code> or an object of class <code><a href="sp.html#topic+SpatialPointsDataFrame">SpatialPointsDataFrame</a></code>. 
</p>
</td></tr>
<tr><td><code id="snss_sd_+3A_coords">coords</code></td>
<td>

<p>a numeric matrix of dimension <code>c(n,2)</code> when <code>x</code> is a matrix where each row represents the sample location of a point in the spatial domain or a list of length two if <code>x</code> is a list which defines the subdivision of the domain. Not needed otherwise.
</p>
</td></tr>
<tr><td><code id="snss_sd_+3A_direction">direction</code></td>
<td>

<p>a string indicating on which coordinate axis the domain is halved. Either <code>'x'</code> (default) or <code>'y'</code>.
</p>
</td></tr>
<tr><td><code id="snss_sd_+3A_ordered">ordered</code></td>
<td>

<p>logical. If <code>TRUE</code> the entries of the latent field are ordered according to the decreasingly ordered eigenvalues. Default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="snss_sd_+3A_...">...</code></td>
<td>

<p>further arguments to be passed to or from methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes that the random field <code class="reqn">x</code> is formed by </p>
<p style="text-align: center;"><code class="reqn"> x(t) = A s(t) + b, </code>
</p>
<p> where <code class="reqn">A</code> is the deterministic <code class="reqn">p \times p</code> mixing matrix, <code class="reqn">b</code> is the <code class="reqn">p</code>-dimensional location vector, <code class="reqn">x</code> is the observable <code class="reqn">p</code>-variate random field given by the argument <code>x</code>, <code class="reqn">t</code> are the spatial locations given by the argument <code>coords</code> and <code class="reqn">s</code> is the latent <code class="reqn">p</code>-variate random field assumed to consist of uncorrelated entries that have zero mean but non-constant variances. This function aims to recover <code class="reqn">s</code> by </p>
<p style="text-align: center;"><code class="reqn"> W(x(t) - \bar{x}), </code>
</p>
<p> where <code class="reqn">W</code> is the <code class="reqn">p \times p</code> unmixing matrix and <code class="reqn">\bar{x}</code> is the sample mean. The function does this by splitting the given spatial domain in half according to the first coordinate (argument <code>direction</code> equals <code>'x'</code>) or the second coodinate (argument <code>direction</code> equals <code>'y'</code>) and simultaneously diagonalizing the sample covariance matrices for each of the two sub-domains.
</p>
<p>Alternatively the domain subdivison can be defined by providing lists of length two for the arguments <code>x</code> and <code>coords</code> where the first list entries correspond to the values and coordinates of the first sub-domain and the second entries to the values and coordinates of the second sub-domain.
</p>


<h3>Value</h3>

<p>Similarly as <code><a href="#topic+sbss">sbss</a></code> the function <code>snss_sd</code> returns a list of class <code>'snss'</code> and <code>'sbss'</code> with the following entries: 
</p>
<table>
<tr><td><code>s</code></td>
<td>

<p>object of <code>class(x)</code> containing the estimated source random field.
</p>
</td></tr>  
<tr><td><code>coords</code></td>
<td>

<p>coordinates of the observations. Only given if <code>x</code> is a matrix or list.
</p>
</td></tr>
<tr><td><code>w</code></td>
<td>

<p>estimated unmixing matrix.
</p>
</td></tr>
<tr><td><code>w_inv</code></td>
<td>

<p>inverse of the estimated unmixing matrix.
</p>
</td></tr>
<tr><td><code>d</code></td>
<td>

<p>diagonal matrix containing the eigenvalues of the eigendecomposition.
</p>
</td></tr>
<tr><td><code>x_mu</code></td>
<td>

<p>columnmeans of <code>x</code>.
</p>
</td></tr>
<tr><td><code>cov_inv_sqrt</code></td>
<td>

<p>square root of the inverse sample covariance matrix for the first sub-domain.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Muehlmann, C., Bachoc, F. and Nordhausen, K. (2022), <em>Blind Source Separation for Non-Stationary Random Fields</em>, Spatial Statistics, 47, 100574, <a href="https://doi.org/10.1016/j.spasta.2021.100574">doi:10.1016/j.spasta.2021.100574</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbss">sbss</a></code>, <code><a href="sp.html#topic+sp">sp</a></code>, <code><a href="sf.html#topic+sf">sf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate coordinates
n &lt;- 1000
coords &lt;- runif(n * 2) * 20
dim(coords) &lt;- c(n, 2)

# simulate random field
field_1 &lt;- rnorm(n)
field_2 &lt;- 2 * sin(pi / 20 * coords[, 1]) * rnorm(n)
field_3 &lt;- rnorm(n) * (coords[, 1] &lt; 10) + rnorm(n, 0, 3) * (coords[, 1] &gt;= 10)

latent_field &lt;- cbind(field_1, field_2, field_3)
mixing_matrix &lt;- matrix(rnorm(9), 3, 3)
observed_field &lt;- latent_field %*% t(mixing_matrix)

observed_field_sp &lt;- sp::SpatialPointsDataFrame(coords = coords, 
                                              data = data.frame(observed_field))
sp::spplot(observed_field_sp, colorkey = TRUE, as.table = TRUE, cex = 1)

# apply snss_sd with split in x 
res_x &lt;- snss_sd(observed_field, coords, direction = 'x')
JADE::MD(W.hat = coef(res_x), A = mixing_matrix)

# apply snss_sd with split in y
# should be much worse as field shows only variation in x
res_y &lt;- snss_sd(observed_field, coords, direction = 'y')
JADE::MD(W.hat = coef(res_y), A = mixing_matrix)

# print object
print(res_x)

# plot latent field
plot(res_x, colorkey = TRUE, as.table = TRUE, cex = 1)

# predict latent fields on grid
predict(res_x, colorkey = TRUE, as.table = TRUE, cex = 1)

# unmixing matrix
w_unmix &lt;- coef(res_x)

# apply snss_sd with SpatialPointsDataFrame object 
res_x_sp &lt;- snss_sd(observed_field_sp, direction = 'x')

# apply with list arguments
# first axis split by 5
flag_coords &lt;- coords[, 1] &lt; 5
coords_list &lt;- list(coords[flag_coords, ],
                    coords[!flag_coords, ])
field_list &lt;- list(observed_field[flag_coords, ],
                   observed_field[!flag_coords, ])
plot(coords, col = flag_coords + 1)

res_list &lt;- snss_sd(x = field_list,
                    coords = coords_list)
plot(res_list, colorkey = TRUE, as.table = TRUE, cex = 1)
JADE::MD(W.hat = coef(res_list), A = mixing_matrix)

</code></pre>

<hr>
<h2 id='snss_sjd'>
Spatial Non-Stationary Source Separation Spatial Joint Diagonalization
</h2><span id='topic+snss_sjd'></span><span id='topic+snss_sjd.default'></span><span id='topic+snss_sjd.list'></span><span id='topic+snss_sjd.SpatialPointsDataFrame'></span><span id='topic+snss_sjd.sf'></span>

<h3>Description</h3>

<p><code>snss_sjd</code> estimates the unmixing matrix assuming a spatial non-stationary source separation model implying non-constant (spatial) covariance by jointly diagonalizing several covariance and/or spatial covariance matrices computed for a subdivision of the spatial domain into at least two sub-domains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snss_sjd(x, ...)

## Default S3 method:
snss_sjd(x, coords, n_block, kernel_type = c('ring', 'ball', 'gauss'), 
     kernel_parameters, with_cov = TRUE, lcov = c('lcov', 'ldiff', 'lcov_norm'), 
     ordered = TRUE, ...)
## S3 method for class 'list'
snss_sjd(x, coords, kernel_type = c('ring', 'ball', 'gauss'), 
     kernel_parameters, with_cov = TRUE, lcov = c('lcov', 'ldiff', 'lcov_norm'), 
     ordered = TRUE, ...)
## S3 method for class 'SpatialPointsDataFrame'
snss_sjd(x, ...)
## S3 method for class 'sf'
snss_sjd(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snss_sjd_+3A_x">x</code></td>
<td>

<p>either a numeric matrix of dimension <code>c(n, p)</code> where the <code>p</code> columns correspond to the entries of the random field and the <code>n</code> rows are the observations, a list of length <code>K</code> defining the subdivision of the domain, an object of class <code><a href="sf.html#topic+sf">sf</a></code> or an object of class <code><a href="sp.html#topic+SpatialPointsDataFrame">SpatialPointsDataFrame</a></code>. 
</p>
</td></tr>
<tr><td><code id="snss_sjd_+3A_coords">coords</code></td>
<td>

<p>a numeric matrix of dimension <code>c(n,2)</code> when <code>x</code> is a matrix where each row represents the sample location of a point in the spatial domain or a list of length <code>K</code> if <code>x</code> is a list which defines the subdivision of the domain. Not needed otherwise.
</p>
</td></tr>
<tr><td><code id="snss_sjd_+3A_n_block">n_block</code></td>
<td>

<p>either be an integer defining the subdivision of the domain, <code>'x'</code> or <code>'y'</code>. See details.
</p>
</td></tr>
<tr><td><code id="snss_sjd_+3A_kernel_type">kernel_type</code></td>
<td>

<p>a string indicating which kernel function to use. Either <code>'ring'</code> (default), <code>'ball'</code> or <code>'gauss'</code>.
</p>
</td></tr>
<tr><td><code id="snss_sjd_+3A_kernel_parameters">kernel_parameters</code></td>
<td>

<p>a numeric vector that gives the parameters for the kernel function. At least length of one for <code>'ball'</code> and <code>'gauss'</code> or two for <code>'ring'</code> kernel, see details.
</p>
</td></tr>
<tr><td><code id="snss_sjd_+3A_with_cov">with_cov</code></td>
<td>

<p>logical. If <code>TRUE</code> not only spatial covariance matrices but also the sample covariances matrices for each sub-domain are considered in the joint diagonalization procedure. Default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="snss_sjd_+3A_lcov">lcov</code></td>
<td>

<p>a string indicating which type of local covariance matrix to use. Either <code>'lcov'</code> (default), <code>'ldiff'</code> or <code>'lcov_norm'</code>. See <code><a href="#topic+sbss_asymp">sbss_asymp</a></code> for details on the latter option.
</p>
</td></tr>
<tr><td><code id="snss_sjd_+3A_ordered">ordered</code></td>
<td>

<p>logical. If <code>TRUE</code> the entries of the latent field are ordered by the sum of squared pseudo-eigenvalues of the diagonalized sub-domain (local) covariance matrices. Default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="snss_sjd_+3A_...">...</code></td>
<td>

<p>further arguments for the fast real joint diagonalization algorithm that jointly diagonalizes the sub-domain covariance matrices. See details and <code><a href="JADE.html#topic+frjd">frjd</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes that the random field <code class="reqn">x</code> is formed by </p>
<p style="text-align: center;"><code class="reqn"> x(t) = A s(t) + b, </code>
</p>
<p> where <code class="reqn">A</code> is the deterministic <code class="reqn">p \times p</code> mixing matrix, <code class="reqn">b</code> is the <code class="reqn">p</code>-dimensional location vector, <code class="reqn">x</code> is the observable <code class="reqn">p</code>-variate random field given by the argument <code>x</code>, <code class="reqn">t</code> are the spatial locations given by the argument <code>coords</code> and <code class="reqn">s</code> is the latent <code class="reqn">p</code>-variate random field assumed to consist of uncorrelated entries that have zero mean but non-constant (spatial) second order dependence. This function aims to recover <code class="reqn">s</code> by </p>
<p style="text-align: center;"><code class="reqn"> W(x(t) - \bar{x}), </code>
</p>
<p> where <code class="reqn">W</code> is the <code class="reqn">p \times p</code> unmixing matrix and <code class="reqn">\bar{x}</code> is the sample mean. The function does this by splitting the given spatial domain into <code>n_block^2</code> equally sized rectangular sub-domains and jointly diagonalizing the corresponding spatial covariance matrices for all sub-domains. If the argument <code>with_cov</code> equals <code>TRUE</code> (default) then additionally also the sample covariance matrices for each sub-domain are included in the joint diagonalization procedure.
</p>
<p>The arguments <code>kernel_type</code>, <code>kernel_parameters</code> and <code>lcov</code> determine which spatial kernel functions and which type of local covariance matrices are used for each sub-domain. The usage is equal to the function <code><a href="#topic+sbss">sbss</a></code>.
</p>
<p>Alternatively the domain subdivision can be defined by providing lists of length <code>K</code> for the arguments <code>x</code> and <code>coords</code> where the first list entries correspond to the values and coordinates of the first sub-domain and the second entries to the values and coordinates of the second sub-domain, etc.. The argument <code>n_block</code> might be <code>'x'</code> or <code>'y'</code> indicating a split across the x or y coordinates similar as done by the function <code><a href="#topic+snss_sd">snss_sd</a></code>.
</p>
<p><code>snss_sjd</code> jointly diagonalizes the covariance matrices for each sub-domain with the function <code><a href="JADE.html#topic+frjd">frjd</a></code>. <code>...</code> provides arguments for <code>frjd</code>, useful arguments might be:
</p>

<ul>
<li> <p><code>eps</code>: tolerance for convergence.
</p>
</li>
<li> <p><code>maxiter</code>: maximum number of iterations.
</p>
</li></ul>



<h3>Value</h3>

<p>Similarly as <code><a href="#topic+sbss">sbss</a></code> the function <code>snss_jd</code> returns a list of class <code>'snss'</code> and <code>'sbss'</code> with the following entries: 
</p>
<table>
<tr><td><code>s</code></td>
<td>

<p>object of <code>class(x)</code> containing the estimated source random field.
</p>
</td></tr>  
<tr><td><code>coords</code></td>
<td>

<p>coordinates of the observations. Only given if <code>x</code> is a matrix or list.
</p>
</td></tr>
<tr><td><code>w</code></td>
<td>

<p>estimated unmixing matrix.
</p>
</td></tr>
<tr><td><code>w_inv</code></td>
<td>

<p>inverse of the estimated unmixing matrix.
</p>
</td></tr>
<tr><td><code>d</code></td>
<td>

<p>matrix of stacked (jointly) diagonalized sub-domain covariance and/or local covariance matrices.
</p>
</td></tr>
<tr><td><code>x_mu</code></td>
<td>

<p>columnmeans of <code>x</code>.
</p>
</td></tr>
<tr><td><code>cov_inv_sqrt</code></td>
<td>

<p>square root of the inverse sample covariance matrix of <code>x</code>.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Muehlmann, C., Bachoc, F. and Nordhausen, K. (2022), <em>Blind Source Separation for Non-Stationary Random Fields</em>, Spatial Statistics, 47, 100574, <a href="https://doi.org/10.1016/j.spasta.2021.100574">doi:10.1016/j.spasta.2021.100574</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbss">sbss</a></code>, <code><a href="sp.html#topic+sp">sp</a></code>, <code><a href="sf.html#topic+sf">sf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate coordinates
n &lt;- 1000
coords &lt;- runif(n * 2) * 20
dim(coords) &lt;- c(n, 2)

# simulate random field
field_1 &lt;- rnorm(n)
field_2 &lt;- 2 * sin(pi / 20 * coords[, 1]) * rnorm(n)
field_3 &lt;- rnorm(n) * (coords[, 1] &lt; 10) + rnorm(n, 0, 3) * (coords[, 1] &gt;= 10)

latent_field &lt;- cbind(field_1, field_2, field_3)
mixing_matrix &lt;- matrix(rnorm(9), 3, 3)
observed_field &lt;- latent_field 

observed_field_sp &lt;- sp::SpatialPointsDataFrame(coords = coords, 
                                                data = data.frame(observed_field))
sp::spplot(observed_field_sp, colorkey = TRUE, as.table = TRUE, cex = 1)

# apply snss_sjd with 4 sub-domains
# one ring kernel per sub-domain
# without covariances
res_4_ball &lt;- snss_sjd(observed_field, coords, n_block = 2,
                  kernel_type = 'ball', kernel_parameters = c(0, 2), 
                  with_cov = TRUE)
JADE::MD(W.hat = coef(res_4_ball), A = mixing_matrix)

# apply snss_sjd with split across y
# one ring kernel per sub-domain
# without covariances
# should not work as field does not show spatial dependence
res_4_ring &lt;- snss_sjd(observed_field, coords, n_block = 'y',
                       kernel_type = 'ring', kernel_parameters = c(0, 2), 
                       with_cov = FALSE)
JADE::MD(W.hat = coef(res_4_ring), A = mixing_matrix)

# print object
print(res_4_ball)

# plot latent field
plot(res_4_ball, colorkey = TRUE, as.table = TRUE, cex = 1)

# predict latent fields on grid
predict(res_4_ball, colorkey = TRUE, as.table = TRUE, cex = 1)

# unmixing matrix
w_unmix &lt;- coef(res_4_ball)

# apply snss_jd with SpatialPointsDataFrame object 
res_4_ball_sp &lt;- snss_sjd(observed_field_sp, n_block = 2,
                          kernel_type = 'ball', kernel_parameters = c(0, 2), 
                          with_cov = TRUE)

# apply with list arguments
# first axis split by 5
# second axis split by 10
# results in 4 sub-domains
flag_x &lt;- coords[, 1] &lt; 5
flag_y &lt;- coords[, 2] &lt; 10
coords_list &lt;- list(coords[flag_x &amp; flag_y, ],
                    coords[!flag_x &amp; flag_y, ],
                    coords[flag_x &amp; !flag_y, ],
                    coords[!flag_x &amp; !flag_y, ])
field_list &lt;- list(observed_field[flag_x &amp; flag_y, ],
                   observed_field[!flag_x &amp; flag_y, ],
                   observed_field[flag_x &amp; !flag_y, ],
                   observed_field[!flag_x &amp; !flag_y, ])
plot(coords, col = 1)
points(coords_list[[2]], col = 2)
points(coords_list[[3]], col = 3)
points(coords_list[[4]], col = 4)

res_list &lt;- snss_sjd(x = field_list,
                    coords = coords_list,
                    kernel_type = 'ring', kernel_parameters = c(0, 2))
plot(res_list, colorkey = TRUE, as.table = TRUE, cex = 1)
JADE::MD(W.hat = coef(res_list), A = mixing_matrix)

</code></pre>

<hr>
<h2 id='spatial_kernel_matrix'>
Computation of Spatial Kernel Matrices
</h2><span id='topic+spatial_kernel_matrix'></span>

<h3>Description</h3>

<p><code>spatial_kernel_matrix</code> computes spatial kernel matrices for a given kernel function with its parameters and a set of coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial_kernel_matrix(coords, kernel_type = c('ring', 'ball', 'gauss'), 
                      kernel_parameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatial_kernel_matrix_+3A_coords">coords</code></td>
<td>

<p>a numeric matrix of dimension <code>c(n,2)</code> where each row represents the coordinates of a point in the spatial domain.
</p>
</td></tr>
<tr><td><code id="spatial_kernel_matrix_+3A_kernel_type">kernel_type</code></td>
<td>

<p>a character string indicating which kernel function to use. Either <code>'ring'</code> (default), <code>'ball'</code> or <code>'gauss'</code>.
</p>
</td></tr>
<tr><td><code id="spatial_kernel_matrix_+3A_kernel_parameters">kernel_parameters</code></td>
<td>

<p>a numeric vector that gives the parameters for the kernel function. At least length of one for <code>'ball'</code> and <code>'gauss'</code> or two for <code>'ring'</code> kernel, see details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two versions of local covariance matrices can be defined:
</p>

<ul>
<li> <p><code>'lcov'</code>: </p>
<p style="text-align: center;"><code class="reqn"> LCov(f) = 1/n \sum_{i,j} f(d_{i,j}) (x(s_i)-\bar{x}) (x(s_j)-\bar{x})',</code>
</p>

</li>
<li> <p><code>'ldiff'</code>: </p>
<p style="text-align: center;"><code class="reqn"> LDiff(f) = 1/n \sum_{i,j} f(d_{i,j}) (x(s_i)-x(s_j)) (x(s_i)-x(s_j))',</code>
</p>

</li>
<li> <p><code>'lcov_norm'</code>: </p>
<p style="text-align: center;"><code class="reqn"> LCov^*(f) = 1/(n F^{1/2}_{f,n}) \sum_{i,j} f(d_{i,j}) (x(s_i)-\bar{x}) (x(s_j)-\bar{x})',</code>
</p>
<p> with </p>
<p style="text-align: center;"><code class="reqn"> F_{f,n} = 1 / n \sum_{i,j} f^2(d_{i,j}).</code>
</p>

</li></ul>

<p>Where <code class="reqn">d_{i,j} \ge 0</code> correspond to the pairwise distances between coordinates, <code class="reqn">x(s_i)</code> are the <code>p</code> random field values at location <code class="reqn">s_i</code>, <code class="reqn">\bar{x}</code> is the sample mean vector, and the kernel function <code class="reqn">f(d)</code> determines the locality. The function <code>spatial_kernel_matrix</code> computes a list of <code>c(n,n)</code> matrices where each entry of these matrices correspond to the spatial kernel function evaluated at the distance between two points, mathematically the entry ij of each kernel matrix is <code class="reqn">f(d_{i,j})</code>. The following kernel functions are implemented and chosen with the argument <code>kernel_type</code>:
</p>

<ul>
<li> <p><code>'ring'</code>: parameters are inner radius <code class="reqn">r_i</code> and outer radius <code class="reqn">r_o</code>, with <code class="reqn">r_i &lt; r_o</code>, and <code class="reqn">r_i, r_o \ge 0</code>: </p>
<p style="text-align: center;"><code class="reqn">f(d;r_i, r_o) = I(r_i &lt; d \le r_o)</code>
</p>

</li>
<li> <p><code>'ball'</code>: parameter is the radius <code class="reqn">r</code>, with <code class="reqn">r \ge 0</code>: </p>
<p style="text-align: center;"><code class="reqn">f(d;r) = I(d \le r)</code>
</p>

</li>
<li> <p><code>'gauss'</code>: Gaussian function where 95% of the mass is inside the parameter <code class="reqn">r</code>, with <code class="reqn">r \ge 0</code>: </p>
<p style="text-align: center;"><code class="reqn">f(d;r) = exp(-0.5 (\Phi^{-1}(0.95) d/r)^2)</code>
</p>

</li></ul>

<p>The argument <code>kernel_type</code> determines the used kernel function as presented above, the argument <code>kernel_parameters</code> gives the corresponding parameters for the kernel function. Specifically, if <code>kernel_type</code> equals <code>'ball'</code> or <code>'gauss'</code> then <code>kernel_parameters</code> is a numeric vector where each entry corresponds to one parameter. Hence, <code>length(kernel_parameters)</code> spatial kernel matrices of type <code>kernel_type</code> are computed. Whereas, if <code>kernel_type</code> equals <code>'ring'</code>, then <code>kernel_parameters</code> must be a numeric vector of even length where subsequently the inner and outer radii must be given (informally: <code>c(r_i1, r_o1, r_i2, r_o2, ...)</code>). In that case <code>length(kernel_parameters) / 2</code> spatial kernel matrices of type <code>'ring'</code> are computed.
</p>
<p>The output of this function can be used with the function <code><a href="#topic+sbss">sbss</a></code> to avoid unnecessary computation of kernel matrices when <code><a href="#topic+sbss">sbss</a></code> is called multiple times with the same coordinate/kernel function setting. Additionally, the output can be used with the function <code><a href="#topic+local_covariance_matrix">local_covariance_matrix</a></code> to actually compute local covariance matrices as defined above based on a given set of spatial kernel matrices.
</p>


<h3>Value</h3>

<p><code>spatial_kernel_matrix</code> returns a list with length of <code>length(kernel_parameters)</code> (for <code>'ball'</code> and <code>'gauss'</code> kernel functions) or <code>length(kernel_parameters) / 2</code> (for <code>'ring'</code> kernel function) containing numeric matrices of dimension <code>c(n,n)</code> corresponding to the spatial kernel matrices.
</p>


<h3>References</h3>

<p>Muehlmann, C., Filzmoser, P. and Nordhausen, K. (2021), <em>Spatial Blind Source Separation in the Presence of a Drift</em>, Submitted for publication. Preprint available at <a href="https://arxiv.org/abs/2108.13813">https://arxiv.org/abs/2108.13813</a>.
</p>
<p>Bachoc, F., Genton, M. G, Nordhausen, K., Ruiz-Gazen, A. and Virta, J. (2020), <em>Spatial Blind Source Separation</em>, Biometrika, 107, 627-646, <a href="https://doi.org/10.1093/biomet/asz079">doi:10.1093/biomet/asz079</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbss">sbss</a></code>, <code><a href="#topic+local_covariance_matrix">local_covariance_matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate a set of coordinates
coords &lt;- rnorm(100 * 2)
dim(coords) &lt;- c(100, 2)

# computing two ring kernel matrices
kernel_params_ring &lt;- c(0, 0.5, 0.5, 2)
ring_kernel_list &lt;- 
  spatial_kernel_matrix(coords, 'ring', kernel_params_ring)

# computing three ball kernel matrices
kernel_params_ball &lt;- c(0.5, 1, 2)
ball_kernel_list &lt;- 
  spatial_kernel_matrix(coords, 'ball', kernel_params_ball)

# computing three gauss kernel matrices
kernel_params_gauss &lt;- c(0.5, 1, 2)
gauss_kernel_list &lt;- 
  spatial_kernel_matrix(coords, 'gauss', kernel_params_gauss)

</code></pre>

<hr>
<h2 id='SpatialBSS-package'>
Blind Source Separation for Multivariate Spatial Data
</h2><span id='topic+SpatialBSS-package'></span>

<h3>Description</h3>

<p>Blind source separation for multivariate spatial data based on simultaneous/joint diagonalization of local covariance matrices. This package is an implementation of the methods described in Nordhausen, Oja, Filzmoser and Reimann (2015) &lt;doi:10.1007/s11004-014-9559-5&gt;, Bachoc, Genton, Nordhausen, Ruiz-Gazen and Virta (2020) &lt;doi:10.1093/biomet/asz079&gt; and
Muehlmann, Bachoc and Nordhausen (2022) &lt;doi:10.1016/j.spasta.2021.100574&gt; as well as some related methods.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> SpatialBSS</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.14-0 </td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-07-20</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>This package provides functions to solve the Blind Source Separation problem for multivariate spatial data. These methods are designed to work with random fields that are observed on irregular locations. Moreover, the random field is assumed to show weak second order stationarity. The main functions of this package are:
</p>

<ul>
<li><p><code><a href="#topic+sbss">sbss</a></code> This function derives a set of local scatter matrices that are based on spatial kernel functions, where the spatial kernel functions can be chosen. Then this set of local covariance matrices as well as the sample covariance matrix are simultaneously/jointly diagonalized. Local covariance matrices as well as local difference matrices are implemented.
</p>
</li>
<li><p><code><a href="#topic+sbss_asymp">sbss_asymp</a></code>, <code><a href="#topic+sbss_boot">sbss_boot</a></code> These functions test for white noise components in the estimated latent field estimated by the <code><a href="#topic+sbss">sbss</a></code> function based on asymptotic results or bootstrap inference principles. 
</p>
</li>
<li><p><code><a href="#topic+snss_sd">snss_sd</a></code>, <code><a href="#topic+snss_jd">snss_jd</a></code> and <code><a href="#topic+snss_sjd">snss_sjd</a></code> These functions estimate the latent random field assuming a spatial non-stationary source separation model. This is done by splitting the domain into a number of sub-domains and diagonalizing the corresponding covariance and/or local covariance matrices for each sub-domain. 
</p>
</li>
<li><p><code><a href="#topic+robsbss">robsbss</a></code> Uses robust estimates of local covariance matrices to solve the SBSS problem.
</p>
</li></ul>

<p>Joint diagonalization is computed with the <code><a href="JADE.html#topic+frjd">frjd</a></code> (fast real joint diagonalization) algorithm from the package <code><a href="JADE.html#topic+JADE-package">JADE</a></code>.
</p>
<p>The random field can be either a pair of numeric matrices giving the coordinates and field values or an object of class <code><a href="sp.html#topic+SpatialPointsDataFrame">SpatialPointsDataFrame</a></code> or <code><a href="sf.html#topic+sf">sf</a></code>.
</p>


<h3>Author(s)</h3>

<p>Christoph Muehlmann, Mika Sipila, Klaus Nordhausen, Sara Taskinen, Joni Virta
</p>
<p>Maintainer: 
Klaus Nordhausen <a href="mailto:klausnordhausenR@gmail.com">klausnordhausenR@gmail.com</a>
</p>


<h3>References</h3>

<p>Muehlmann, C., Filzmoser, P. and Nordhausen, K. (2021), <em>Spatial Blind Source Separation in the Presence of a Drift</em>, Submitted for publication. Preprint available at <a href="https://arxiv.org/abs/2108.13813">https://arxiv.org/abs/2108.13813</a>.
</p>
<p>Bachoc, F., Genton, M. G, Nordhausen, K., Ruiz-Gazen, A. and Virta, J. (2020), <em>Spatial Blind Source Separation</em>, Biometrika, 107, 627-646, <a href="https://doi.org/10.1093/biomet/asz079">doi:10.1093/biomet/asz079</a>.
</p>
<p>Nordhausen, K., Oja, H., Filzmoser, P., Reimann, C. (2015), <em>Blind Source Separation for Spatial Compositional Data</em>, Mathematical Geosciences 47, 753-770, <a href="https://doi.org/10.1007/s11004-014-9559-5">doi:10.1007/s11004-014-9559-5</a>.
</p>
<p>Muehlmann, C., Bachoc, F. and Nordhausen, K. (2022), <em>Blind Source Separation for Non-Stationary Random Fields</em>, Spatial Statistics, 47, 100574, <a href="https://doi.org/10.1016/j.spasta.2021.100574">doi:10.1016/j.spasta.2021.100574</a>.
</p>
<p>Muehlmann, C., Bachoc, F., Nordhausen, K. and Yi, M. (2022), <em>Test of the Latent Dimension of a Spatial Blind Source Separation Model</em>, to appear in Statistica Sinica, <a href="https://doi.org/10.5705/ss.202021.0326">doi:10.5705/ss.202021.0326</a>.
</p>

<hr>
<h2 id='white_data'>
Different Approaches of Data Whitening
</h2><span id='topic+white_data'></span>

<h3>Description</h3>

<p><code>white_data</code> whites the data with respect to the sample covariance matrix, or different spatial scatter matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>white_data(x, whitening = c("standard", "rob", "hr"), 
           lcov = c('lcov', 'ldiff', 'lcov_norm'), 
           kernel_mat = numeric(0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="white_data_+3A_x">x</code></td>
<td>

<p>a numeric matrix of dimension <code>c(n, p)</code> where the <code>p</code> columns correspond to the entries of the random field and the <code>n</code> rows are the observations.
</p>
</td></tr>
<tr><td><code id="white_data_+3A_whitening">whitening</code></td>
<td>

<p>a string indicating the whitening method. If <code>'standard'</code> then the whitening is carried out with respect to sample covariance matrix, if <code>'rob'</code> then the first spatial scatter matrix is used instead of sample the covariance matrix and if <code>'hr'</code> then the Hettmansperger-Randles location and scatter estimates are used for whitening. See details for more. Default is <code>'standard'</code>.
</p>
</td></tr>
<tr><td><code id="white_data_+3A_lcov">lcov</code></td>
<td>

<p>a string indicating which type of local covariance matrix is used for whitening, when the whitening method <code>'rob'</code> is used. Either <code>'lcov'</code> (default) or <code>'ldiff'</code>.
</p>
</td></tr>
<tr><td><code id="white_data_+3A_kernel_mat">kernel_mat</code></td>
<td>

<p>a spatial kernel matrix with dimension <code>c(n,n)</code>, see details. Usually computed by the function <code><a href="#topic+spatial_kernel_matrix">spatial_kernel_matrix</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inverse square root of a positive definite matrix <code class="reqn">M(x)</code> with eigenvalue decomposition <code class="reqn">UDU'</code> is defined as <code class="reqn">M(x)^{-1/2} = UD^{-1/2}U'</code>. <code>white_data</code> whitens the data by <code class="reqn">M(x)^{-1/2}(x - T(x))</code> where <code class="reqn">T(x)</code> is a location functional of <code class="reqn">x</code> and the matrix <code class="reqn">M(x)</code> is a scatter functional. If the argument <code>whitening</code> is <code>'standard'</code>, <code class="reqn">M(x)</code> is the sample covariance matrix and <code class="reqn">T(x)</code> is a vector of column means of <code class="reqn">x</code>. If the argument <code>whitening</code> is <code>'hr'</code>, the Hettmansperger-Randles location and scatter estimates (Hettmansperger &amp; Randles, 2002) are used as location functional <code class="reqn">T(x)</code> and scatter functional <code class="reqn">M(x)</code>. The Hettmansperger-Randles location and scatter estimates are robust variants of sample mean and covariance matrices, that are used for whitening in <code><a href="#topic+robsbss">robsbss</a></code>. If the argument <code>whitening</code> is <code>'rob'</code>, the argument <code>lcov</code> determines the scatter functional <code class="reqn">M(x)</code> to be one of the following local scatter matrices:
</p>

<ul>
<li> <p><code>'lcov'</code>: </p>
<p style="text-align: center;"><code class="reqn"> LCov(f) = 1/n \sum_{i,j} f(d_{i,j}) (x(s_i)-\bar{x}) (x(s_j)-\bar{x})' ,</code>
</p>

</li>
<li> <p><code>'ldiff'</code>: </p>
<p style="text-align: center;"><code class="reqn"> LDiff(f) = 1/n \sum_{i,j} f(d_{i,j}) (x(s_i)-x(s_j)) (x(s_i)-x(s_j))',</code>
</p>

</li>
<li> <p><code>'lcov_norm'</code>: </p>
<p style="text-align: center;"><code class="reqn"> LCov^*(f) = 1/(n F^{1/2}_{f,n}) \sum_{i,j} f(d_{i,j}) (x(s_i)-\bar{x}) (x(s_j)-\bar{x})',</code>
</p>
<p> with </p>
<p style="text-align: center;"><code class="reqn"> F_{f,n} = 1 / n \sum_{i,j} f^2(d_{i,j}),</code>
</p>

</li></ul>

<p>where <code class="reqn">d_{i,j} \ge 0</code> correspond to the pairwise distances between coordinates, <code class="reqn">x(s_i)</code> are the <code>p</code> random field values at location <code class="reqn">s_i</code>, <code class="reqn">\bar{x}</code> is the sample mean vector, and the kernel function <code class="reqn">f(d)</code> determines the locality. The choice <code>'lcov_norm'</code> is useful when testing for the actual signal dimension of the latent field, see <code><a href="#topic+sbss_asymp">sbss_asymp</a></code> and <code><a href="#topic+sbss_boot">sbss_boot</a></code>. See also <code><a href="#topic+sbss">sbss</a></code> for details.
</p>
<p>Note that <code class="reqn">LCov(f)</code> are usually not positive definite, therefore in that case the matrix cannot be inverted and an error is produced. Whitening with <code class="reqn">LCov(f)</code> matrices might be favorable in the presence of spatially uncorrelated noise, and whitening with <code class="reqn">LDiff(f)</code> might be favorable when a non-constant smooth drift is present in the data.
</p>
<p>The argument <code>kernel_mat</code> is a matrix of dimension <code>c(n,n)</code> where each entry corresponds to the spatial kernel function evaluated at the distance between two sample locations, mathematically the entry ij of each kernel matrix is <code class="reqn">f(d_{i,j})</code>. This matrix is usually computed with the function <code><a href="#topic+spatial_kernel_matrix">spatial_kernel_matrix</a></code>.
</p>


<h3>Value</h3>

<p><code>white_data</code> returns a list with the following entries: 
</p>
<table>
<tr><td><code>mu</code></td>
<td>

<p>a numeric vector of length <code>ncol(x)</code> containing the column means of the data matrix <code>x</code>.
</p>
</td></tr>  
<tr><td><code>x_0</code></td>
<td>

<p>a numeric matrix of dimension <code>c(n, p)</code> containing the columns centered data of <code>x</code>.
</p>
</td></tr>
<tr><td><code>x_w</code></td>
<td>

<p>a numeric matrix of dimension <code>c(n, p)</code> containing the whitened data of <code>x</code>.
</p>
</td></tr>
<tr><td><code>s</code></td>
<td>

<p>a numeric matrix of dimension <code>c(p, p)</code> which is the scatter matrix <code class="reqn">M</code>.
</p>
</td></tr>
<tr><td><code>s_inv_sqrt</code></td>
<td>

<p>a numeric matrix of dimension <code>c(p, p)</code> which equals the inverse square root of the scatter matrix <code class="reqn">M</code> used for whitening.
</p>
</td></tr>
<tr><td><code>s_sqrt</code></td>
<td>

<p>a numeric matrix of dimension <code>c(p, p)</code> which equals the square root of the scatter matrix <code class="reqn">M</code>.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Muehlmann, C., Filzmoser, P. and Nordhausen, K. (2021), <em>Spatial Blind Source Separation in the Presence of a Drift</em>, Submitted for publication. Preprint available at <a href="https://arxiv.org/abs/2108.13813">https://arxiv.org/abs/2108.13813</a>.
</p>
<p>Bachoc, F., Genton, M. G, Nordhausen, K., Ruiz-Gazen, A. and Virta, J. (2020), <em>Spatial Blind Source Separation</em>, Biometrika, 107, 627-646, <a href="https://doi.org/10.1093/biomet/asz079">doi:10.1093/biomet/asz079</a>.
</p>
<p>Hettmansperger, T. P., &amp; Randles, R. H. (2002). <em>A practical affine equivariant multivariate median</em>. Biometrika, 89 , 851-860. <a href="https://doi.org/10.1093/biomet/89.4.851">doi:10.1093/biomet/89.4.851</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbss">sbss</a></code>, <code><a href="#topic+spatial_kernel_matrix">spatial_kernel_matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate coordinates
coords &lt;- runif(1000 * 2) * 20
dim(coords) &lt;- c(1000, 2)
coords_df &lt;- as.data.frame(coords)
names(coords_df) &lt;- c("x", "y")
# simulate random field
if (!requireNamespace('gstat', quietly = TRUE)) {
  message('Please install the package gstat to run the example code.')
} else {
  library(gstat)
  model_1 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, model = 'Exp'), nmax = 20)
  model_2 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, kappa = 2, model = 'Mat'), 
                   nmax = 20)
  model_3 &lt;- gstat(formula = z ~ 1, locations = ~ x + y, dummy = TRUE, beta = 0, 
                   model = vgm(psill = 0.025, range = 1, model = 'Gau'), nmax = 20)
  field_1 &lt;- predict(model_1, newdata = coords_df, nsim = 1)$sim1
  field_2 &lt;- predict(model_2, newdata = coords_df, nsim = 1)$sim1
  field_3 &lt;- predict(model_3, newdata = coords_df, nsim = 1)$sim1
  field &lt;- cbind(field_1, field_2, field_3)
  X &lt;- as.matrix(field)

  # white the data with the usual sample covariance 
  x_w_1 &lt;- white_data(X)
  
  # white the data with a ldiff matrix and ring kernel
  kernel_params_ring &lt;- c(0, 1)
  ring_kernel_list &lt;- 
    spatial_kernel_matrix(coords, 'ring', kernel_params_ring)
  x_w_2 &lt;- white_data(field, whitening = 'rob',
    lcov = 'ldiff', kernel_mat = ring_kernel_list[[1]])
  
  # Generate 5 % of global outliers to data
  field_cont &lt;- gen_glob_outl(field)[,1:3]
  X &lt;- as.matrix(field_cont)
  # white the data using Hettmansperger-Randles location and scatter estimates
  x_w_3 &lt;- white_data(X, whitening = 'hr')
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
