<!DOCTYPE html><html><head><title>Help for package MIRES</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MIRES}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.combine_RHS'><p>Combine all unique RHS entries into one RHS formula.</p></a></li>
<li><a href='#.formula_lhs'><p>Get the one-length LHS of formula as string.</p></a></li>
<li><a href='#.formula_names'><p>Get terms from formula list</p></a></li>
<li><a href='#.formula_rhs'><p>Get RHS of formula as character vector.</p></a></li>
<li><a href='#.hdi'><p>Compute Highest Posterior Density intervals.</p></a></li>
<li><a href='#.indicator_spec'><p>Generates indicator spec list.</p></a></li>
<li><a href='#.pairwise_diff_single'><p>Outer subtraction for given params across MCMC samples.</p></a></li>
<li><a href='#.parse_formula'><p>Parse formula (list).</p></a></li>
<li><a href='#.sample_diff'><p>Compute all differences of vector.</p></a></li>
<li><a href='#.sample_diff_labels'><p>Generate labels for all differences of vector.</p></a></li>
<li><a href='#bflt'><p>Compute BF(Less than)</p></a></li>
<li><a href='#datagen_uni'><p>Unidimensional data generation.</p></a></li>
<li><a href='#ddirichletprocess'><p>Create dirichletprocess (exponential) based density function.</p></a></li>
<li><a href='#ddirichletprocess_spike'><p>Create Stan-based spike-mixture DP based density estimation function.</p></a></li>
<li><a href='#ddirichletprocess_stan'><p>Create Stan-based density function.</p></a></li>
<li><a href='#dhmre'><p>Density for hmre prior on RE SDs.</p></a></li>
<li><a href='#dhmre_pairwise'><p>Implied density for pairwise differences given HMRE prior.</p></a></li>
<li><a href='#dlogspline'><p>Create logspline-based density function.</p></a></li>
<li><a href='#generateData'><p>Paper simulation function (For historical purposes)</p></a></li>
<li><a href='#genStickBreakPi'><p>Stick-breaking function.</p></a></li>
<li><a href='#mires'><p>Fit mixed effects measurement model for invariance assessment.</p></a></li>
<li><a href='#MIRES-package'><p>The 'MIRES' package.</p></a></li>
<li><a href='#pairwise'><p>Pairwise comparisons of random parameters.</p></a></li>
<li><a href='#posterior_density_funs_sigmas'><p>Create marginal posterior density function approximations for random effect SDs</p></a></li>
<li><a href='#predict_DP'><p>Prediction for DP density estimation models.</p></a></li>
<li><a href='#print.mires'><p>Print function for mires objects.</p></a></li>
<li><a href='#print.summary.mires'><p>Print method for MIRES summary objects.</p></a></li>
<li><a href='#ranef.mires'><p>Extract random effects of each group from MIRES model.</p></a></li>
<li><a href='#rhmre'><p>Random sampling from hmre prior on RE SDs.</p></a></li>
<li><a href='#sim_all'><p>Simulated data: All parameters vary (Full non-invariance)</p></a></li>
<li><a href='#sim_intercepts'><p>Simulated data: Intercepts vary</p></a></li>
<li><a href='#sim_items'><p>Simulated data: Half the items are non-invariant.</p></a></li>
<li><a href='#sim_loadings'><p>Simulated data: Loadings vary</p></a></li>
<li><a href='#sim_none'><p>Simulated data: No variance (Full invariance)</p></a></li>
<li><a href='#sim_resid'><p>Simulated data: Residual variances vary</p></a></li>
<li><a href='#simulate_DP'><p>Generate Truncated Dirichlet Process Mixture.</p></a></li>
<li><a href='#split_stannames'><p>Split stan names into a list of parameter names (char vec) and (col-named) matrix of numeric indices.</p></a></li>
<li><a href='#summary.mires'><p>Summary method for mires object.</p></a></li>
<li><a href='#tidy_stanpars'><p>Tidy up a vector of stan names into a data frame.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Measurement Invariance Assessment Using Random Effects Models
and Shrinkage</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimates random effect latent measurement models, wherein the loadings, residual variances, intercepts, latent means, and latent variances all vary across groups. The random effect variances of the measurement parameters are then modeled using a hierarchical inclusion model, wherein the inclusion of the variances (i.e., whether it is effectively zero or non-zero) is informed by similar parameters (of the same type, or of the same item). This additional hierarchical structure allows the evidence in favor of partial invariance to accumulate more quickly, and yields more certain decisions about measurement invariance. Martin, Williams, and Rast (2020) &lt;<a href="https://doi.org/10.31234%2Fosf.io%2Fqbdjt">doi:10.31234/osf.io/qbdjt</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, Rcpp (&ge; 0.12.0), rstan (&ge; 2.18.1), rstantools (&ge;
2.0.0), Formula (&ge; 1.2-1), stats (&ge; 3.4.0), parallel (&ge;
3.4.0), mvtnorm (&ge; 1.0), dirichletprocess (&ge; 0.4.0),
truncnorm (&ge; 1.0), pracma (&ge; 2.2.9), cubature (&ge; 2.0.0),
logspline (&ge; 2.1.0), nlme (&ge; 3.1), HDInterval (&ge; 0.2.2)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0), Rcpp (&ge; 0.12.0), RcppEigen (&ge; 0.3.3.3.0),
rstan (&ge; 2.18.1), StanHeaders (&ge; 2.18.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stephenSRMMartin/MIRES/issues">https://github.com/stephenSRMMartin/MIRES/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-02-19 02:12:41 UTC; hwkiller</td>
</tr>
<tr>
<td>Author:</td>
<td>Stephen Martin <a href="https://orcid.org/0000-0001-8085-2390"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Philippe Rast <a href="https://orcid.org/0000-0003-3630-6629"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stephen Martin &lt;stephenSRMMartin@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-22 10:40:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='.combine_RHS'>Combine all unique RHS entries into one RHS formula.</h2><span id='topic+.combine_RHS'></span>

<h3>Description</h3>

<p>Combine all unique RHS entries into one RHS formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.combine_RHS(formList)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".combine_RHS_+3A_formlist">formList</code></td>
<td>
<p>List of formulas.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Formula. RHS only.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='.formula_lhs'>Get the one-length LHS of formula as string.</h2><span id='topic+.formula_lhs'></span>

<h3>Description</h3>

<p>Get the one-length LHS of formula as string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.formula_lhs(formula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".formula_lhs_+3A_formula">formula</code></td>
<td>
<p>Formula.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>String. LHS variable of formula. Formula must have only one name on LHS.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='.formula_names'>Get terms from formula list</h2><span id='topic+.formula_names'></span>

<h3>Description</h3>

<p>Get terms from formula list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.formula_names(formList, terms = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".formula_names_+3A_formlist">formList</code></td>
<td>
</td></tr>
<tr><td><code id=".formula_names_+3A_terms">terms</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing factor (factor names) and indicator (indicator names) as lists.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='.formula_rhs'>Get RHS of formula as character vector.</h2><span id='topic+.formula_rhs'></span>

<h3>Description</h3>

<p>Get RHS of formula as character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.formula_rhs(formula, terms = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".formula_rhs_+3A_formula">formula</code></td>
<td>
<p>Formula.</p>
</td></tr>
<tr><td><code id=".formula_rhs_+3A_terms">terms</code></td>
<td>
<p>Logical. Whether to return the formula expressions, or variables (FALSE). I.e., &quot;I(x^2)&quot; instead of &quot;x&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='.hdi'>Compute Highest Posterior Density intervals.</h2><span id='topic+.hdi'></span>

<h3>Description</h3>

<p>Compute Highest Posterior Density intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.hdi(samps, prob, add_zero = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".hdi_+3A_samps">samps</code></td>
<td>
<p>MCMC sample matrix.</p>
</td></tr>
<tr><td><code id=".hdi_+3A_prob">prob</code></td>
<td>
<p>Numeric in (0,1).</p>
</td></tr>
<tr><td><code id=".hdi_+3A_add_zero">add_zero</code></td>
<td>
<p>Logical (Default: FALSE) - Whether to add zero to samples. Useful for unidirectional effects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of HDIs.
</p>


<h3>Author(s)</h3>

<p>Stephen Martin
</p>

<hr>
<h2 id='.indicator_spec'>Generates indicator spec list.</h2><span id='topic+.indicator_spec'></span>

<h3>Description</h3>

<p>Generates the &quot;indicator spec&quot; used by Stan
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.indicator_spec(formList, mm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".indicator_spec_+3A_formlist">formList</code></td>
<td>
</td></tr>
<tr><td><code id=".indicator_spec_+3A_mm">mm</code></td>
<td>
</td></tr>
</table>


<h3>Details</h3>

<p>The indicator spec consists of two parts.
The first part is J_f, or the number of indicators under each factor.
The second part is an [F, J] array, wherein each row defines the 1:J_f[f] columns of the indicator matrix belonging to the factor.
Example:
[1, 3, 5, 0, 0, 0]: J_f[1] = 3
[2, 4, 6, 0, 0, 0]: J_f[2] = 3
[1, 2, 3, 4, 0, 0]: J_f[3] = 4; J = 6; F = 3
</p>


<h3>Value</h3>

<p>List containing J_f (Indicators per factor; numeric vector) and F_ind (FxJ Numeric Matrix, where F_ind[f,1:J_f] gives the column indices of the model matrix corresponding to factor f.)
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='.pairwise_diff_single'>Outer subtraction for given params across MCMC samples.</h2><span id='topic+.pairwise_diff_single'></span>

<h3>Description</h3>

<p>Computes p_j - p_i not j, for each j.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.pairwise_diff_single(mcmc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".pairwise_diff_single_+3A_mcmc">mcmc</code></td>
<td>
<p>Numeric matrix. MCMC samples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assumes that mcmc contains params from ONE parameter across the indices whose differences are of interest (e.g, resid_random[1:K, 1]).
</p>


<h3>Value</h3>

<p>MCMC Matrix of all differences. Posterior samples of all possible differences, minus duplicates.
</p>


<h3>Author(s)</h3>

<p>Stephen R Martin
</p>

<hr>
<h2 id='.parse_formula'>Parse formula (list).</h2><span id='topic+.parse_formula'></span>

<h3>Description</h3>

<p>Parse formula (list).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.parse_formula(formula, group, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".parse_formula_+3A_formula">formula</code></td>
<td>
<p>Formula or list of formulas.</p>
</td></tr>
<tr><td><code id=".parse_formula_+3A_group">group</code></td>
<td>
<p>Raw name for group.</p>
</td></tr>
<tr><td><code id=".parse_formula_+3A_data">data</code></td>
<td>
<p>data.frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing meta-data and stan data.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='.sample_diff'>Compute all differences of vector.</h2><span id='topic+.sample_diff'></span>

<h3>Description</h3>

<p>Compute all differences of vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.sample_diff(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".sample_diff_+3A_x">x</code></td>
<td>
<p>Numeric vector (e.g., one row of mcmc samples)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric Vector of lower-triangular outer difference matrix.
</p>


<h3>Author(s)</h3>

<p>Stephen R Martin
</p>

<hr>
<h2 id='.sample_diff_labels'>Generate labels for all differences of vector.</h2><span id='topic+.sample_diff_labels'></span>

<h3>Description</h3>

<p>Generate labels for all differences of vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.sample_diff_labels(mcmcNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".sample_diff_labels_+3A_mcmcnames">mcmcNames</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>Character Vector of lower-triangular outer difference matrix. I.e., labels for .sample_diff.
</p>


<h3>Author(s)</h3>

<p>Stephen R Martin
</p>

<hr>
<h2 id='bflt'>Compute BF(Less than)</h2><span id='topic+bflt'></span>

<h3>Description</h3>

<p>Computes the BF12, where 1 is less than and 2 is greater than.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bflt(mcmc, less_than, prior_cumul_fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bflt_+3A_mcmc">mcmc</code></td>
<td>
<p>MCMC vector.</p>
</td></tr>
<tr><td><code id="bflt_+3A_less_than">less_than</code></td>
<td>
<p>Value to test.</p>
</td></tr>
<tr><td><code id="bflt_+3A_prior_cumul_fun">prior_cumul_fun</code></td>
<td>
<p>CDF function.</p>
</td></tr>
<tr><td><code id="bflt_+3A_...">...</code></td>
<td>
</td></tr>
</table>


<h3>Details</h3>

<p>The BF12 here is BF for a parameter being less than a threshold, t, vs the parameter being greater than t.
This borrows from the encompassing approach, where u is the unconstrained prior:
BF1u = p(D|H = 1) / p(D|H = u)
BF2u = p(D|H = 2) / p(D|H = u)
BF12 = BF1u / BF2u.
</p>
<p>BF1u = int p(D|H = 1, theta_1)p(theta_1 | H = 1) / p(D|H = u, theta_u)p(theta_u | H=u)
</p>


<h3>Value</h3>

<p>BF12 value.
</p>


<h3>Author(s)</h3>

<p>Stephen Martin
</p>

<hr>
<h2 id='datagen_uni'>Unidimensional data generation.</h2><span id='topic+datagen_uni'></span>

<h3>Description</h3>

<p>Generates unidimensional data for testing the HMRE/MIRES approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datagen_uni(J, K, n, fixed, mipattern, etadist = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datagen_uni_+3A_j">J</code></td>
<td>
<p>Integer. Number of indicators.</p>
</td></tr>
<tr><td><code id="datagen_uni_+3A_k">K</code></td>
<td>
<p>Integer. Number of groups.</p>
</td></tr>
<tr><td><code id="datagen_uni_+3A_n">n</code></td>
<td>
<p>Integer. Number of observations within group.</p>
</td></tr>
<tr><td><code id="datagen_uni_+3A_fixed">fixed</code></td>
<td>
<p>Named List. lambda, resid_log, nu, in that order.</p>
</td></tr>
<tr><td><code id="datagen_uni_+3A_mipattern">mipattern</code></td>
<td>
<p>List. See details.</p>
</td></tr>
<tr><td><code id="datagen_uni_+3A_etadist">etadist</code></td>
<td>
<p>(Default: NULL). NULL, &quot;std&quot;, or a list of two. If NULL (Default), all groups have latent scores distributed standard normal. If &quot;std&quot;, means are standard normal, and (log) latent SDs are also standard normal (i.e., standard log normal; product to 1). If a list, slot one provides the K means, slot two provides the K log SDs. These should have a mean of zero (sum to zero) and a mean of 1 (product to 1), respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mipattern</code> is a list specifying a pattern of MI.
The first entry should be a string specifying one of: constant, random, none, items, params, or custom.
The other entries depend on the specification desired, as described below.
</p>

<dl>
<dt>constant</dt><dd><p> (2) Numeric: All RE SDs are set to this value.</p>
</dd>
<dt>random</dt><dd><p> (2) Numeric: All RE SDs are generated between 0 and this value.</p>
</dd>
<dt>none</dt><dd><p> All RE SDs set to zero (full invariance).</p>
</dd>
<dt>items</dt><dd><p> (2) Numeric: Value of RE SDs for (3) items. E.g., &quot;items&quot;, .4, 4 would set all parameters for items 1 to 4 to have an RE SD of .4.</p>
</dd>
<dt>params</dt><dd><p> (2) Numeric: Value of RE SD for parameter type (3), where (3) is an integer (0: Loadings, 1: Residual SDs, 2: Intercepts). E.g., &quot;params&quot;, .4, 2 would set all RE-SDs of intercepts to be .4.</p>
</dd>
<dt>custom</dt><dd><p> (2) Numeric: Specify all 3J RE-SDs manually in order of loadings, residual log SDs, and intercepts.</p>
</dd>
</dl>

<p>Note that this is <em>not</em> the generative model specified by MIRES, but a convenience function for meeting the bare assumptions while generating MI or non-MI data.
</p>


<h3>Value</h3>

<p>List of meta(data), params, data, and a data frame.
</p>


<h3>Author(s)</h3>

<p>Stephen Martin
</p>

<hr>
<h2 id='ddirichletprocess'>Create dirichletprocess (exponential) based density function.</h2><span id='topic+ddirichletprocess'></span>

<h3>Description</h3>

<p>Create dirichletprocess (exponential) based density function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddirichletprocess(mcmc, iter = 500, mode = c("posterior", "est"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddirichletprocess_+3A_mcmc">mcmc</code></td>
<td>
<p>MCMC samples.</p>
</td></tr>
<tr><td><code id="ddirichletprocess_+3A_iter">iter</code></td>
<td>
<p>MH Iterations to run.</p>
</td></tr>
<tr><td><code id="ddirichletprocess_+3A_mode">mode</code></td>
<td>
<p>posterior or est.</p>
</td></tr>
<tr><td><code id="ddirichletprocess_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function returning a matrix (if posterior) or vector (if est).
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='ddirichletprocess_spike'>Create Stan-based spike-mixture DP based density estimation function.</h2><span id='topic+ddirichletprocess_spike'></span>

<h3>Description</h3>

<p>Create Stan-based spike-mixture DP based density estimation function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddirichletprocess_spike(mcmc, mode = "est", K = 200, spike_scale = 1e-05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddirichletprocess_spike_+3A_mcmc">mcmc</code></td>
<td>
<p>MCMC samples.</p>
</td></tr>
<tr><td><code id="ddirichletprocess_spike_+3A_mode">mode</code></td>
<td>
<p>posterior or est.</p>
</td></tr>
<tr><td><code id="ddirichletprocess_spike_+3A_k">K</code></td>
<td>
<p>Number of DP components (Default: 200)</p>
</td></tr>
<tr><td><code id="ddirichletprocess_spike_+3A_spike_scale">spike_scale</code></td>
<td>
<p>Numeric (Default: .00001). The scale of the half-normal spike.</p>
</td></tr>
<tr><td><code id="ddirichletprocess_spike_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function.
</p>


<h3>Author(s)</h3>

<p>Stephen R Martin
</p>

<hr>
<h2 id='ddirichletprocess_stan'>Create Stan-based density function.</h2><span id='topic+ddirichletprocess_stan'></span>

<h3>Description</h3>

<p>Create Stan-based density function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddirichletprocess_stan(mcmc, mode = "est", K = 200, model = "dpHNormal", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddirichletprocess_stan_+3A_mcmc">mcmc</code></td>
<td>
<p>MCMC samples.</p>
</td></tr>
<tr><td><code id="ddirichletprocess_stan_+3A_mode">mode</code></td>
<td>
<p>posterior or est.</p>
</td></tr>
<tr><td><code id="ddirichletprocess_stan_+3A_k">K</code></td>
<td>
<p>Number of DP components (Default: 200)</p>
</td></tr>
<tr><td><code id="ddirichletprocess_stan_+3A_model">model</code></td>
<td>
<p>dpHNormal, dpExp, dpGauss, or dpWeibull (Default: dpHNormal).</p>
</td></tr>
<tr><td><code id="ddirichletprocess_stan_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function returning vector (if est) or matrix (if posterior)
</p>


<h3>Author(s)</h3>

<p>Stephen Martin
</p>

<hr>
<h2 id='dhmre'>Density for hmre prior on RE SDs.</h2><span id='topic+dhmre'></span>

<h3>Description</h3>

<p>Density for hmre prior on RE SDs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dhmre(x, mu = 0, sigma = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dhmre_+3A_x">x</code></td>
<td>
<p>Numeric.</p>
</td></tr>
<tr><td><code id="dhmre_+3A_mu">mu</code></td>
<td>
<p>Numeric. HMRE Prior location.</p>
</td></tr>
<tr><td><code id="dhmre_+3A_sigma">sigma</code></td>
<td>
<p>Numeric. (Default: 1; must be &gt; 0). HMRE prior scale.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Density.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='dhmre_pairwise'>Implied density for pairwise differences given HMRE prior.</h2><span id='topic+dhmre_pairwise'></span>

<h3>Description</h3>

<p>Computes the implied densities of random effect differences given HMRE prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dhmre_pairwise(x, mu = 0, sigma = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dhmre_pairwise_+3A_x">x</code></td>
<td>
<p>Numeric. Difference in random effects.</p>
</td></tr>
<tr><td><code id="dhmre_pairwise_+3A_mu">mu</code></td>
<td>
<p>Numeric. HMRE Prior location.</p>
</td></tr>
<tr><td><code id="dhmre_pairwise_+3A_sigma">sigma</code></td>
<td>
<p>Numeric. (Default: 1; must be &gt; 0). HMRE prior scale.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The HMRE prior for the RE-SD is <code class="reqn">\int N^+(\sigma_p | exp(h_p))LN(h_p | 4\mu, \sqrt{4}\sigma)dh_p</code>.
The random effects are distributed as <code class="reqn">u_{k,p} \sim N(0, \sigma_p)</code>.
The implied prior is therefore <code class="reqn">u_{k,p} - u_{\lnot k, p} \sim N(0, \sqrt{2}\sigma)</code>.
Note that there is a singularity at 0, because the integrand at sigma = 0 is an infinite spike.
We currently integrate (using a change of variables) starting at machine precision-zero. Consider this the approximation of the limit as we approach 0 positively.
This is therefore divergent when assessed at a difference of zero, due to the RESD taking on a zero value (and an infinite function value).
This is expected, as the limit of a Gaussian as sigma -&gt; 0 is the Dirac delta function.
</p>


<h3>Value</h3>

<p>Numeric vector.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='dlogspline'>Create logspline-based density function.</h2><span id='topic+dlogspline'></span>

<h3>Description</h3>

<p>Create logspline-based density function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlogspline(mcmc, lbound = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dlogspline_+3A_mcmc">mcmc</code></td>
<td>
<p>MCMC samples.</p>
</td></tr>
<tr><td><code id="dlogspline_+3A_lbound">lbound</code></td>
<td>
<p>Integer (Default: 0).</p>
</td></tr>
<tr><td><code id="dlogspline_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Density Function.
</p>


<h3>Author(s)</h3>

<p>Stephen Martin
</p>

<hr>
<h2 id='generateData'>Paper simulation function (For historical purposes)</h2><span id='topic+generateData'></span>

<h3>Description</h3>

<p>Paper simulation function (For historical purposes)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateData(J, K, n, paramSDPattern)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateData_+3A_j">J</code></td>
<td>
<p>Integer. Number of indicators.</p>
</td></tr>
<tr><td><code id="generateData_+3A_k">K</code></td>
<td>
<p>Integer. Number of groups.</p>
</td></tr>
<tr><td><code id="generateData_+3A_n">n</code></td>
<td>
<p>Integer. Observations per group.</p>
</td></tr>
<tr><td><code id="generateData_+3A_paramsdpattern">paramSDPattern</code></td>
<td>
<p>List.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List.
</p>


<h3>Author(s)</h3>

<p>Stephen Martin
</p>

<hr>
<h2 id='genStickBreakPi'>Stick-breaking function.</h2><span id='topic+genStickBreakPi'></span>

<h3>Description</h3>

<p>Stick-breaking function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genStickBreakPi(K, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genStickBreakPi_+3A_k">K</code></td>
<td>
<p>Max cluster.</p>
</td></tr>
<tr><td><code id="genStickBreakPi_+3A_alpha">alpha</code></td>
<td>
<p>Numeric. The alpha parameter to the DP.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of DP weights.
</p>


<h3>Author(s)</h3>

<p>Stephen Martin
</p>

<hr>
<h2 id='mires'>Fit mixed effects measurement model for invariance assessment.</h2><span id='topic+mires'></span>

<h3>Description</h3>

<p>Fits mixed effects measurement models for measurement invariance assessment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mires(
  formula,
  group,
  data,
  inclusion_model = c("dependent", "independent"),
  identification = c("sum_to_zero", "hierarchical"),
  save_scores = FALSE,
  prior_only = FALSE,
  prior = c(0, 0.25),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mires_+3A_formula">formula</code></td>
<td>
<p>Formula. LHS is the factor name, and RHS contains indicators.</p>
</td></tr>
<tr><td><code id="mires_+3A_group">group</code></td>
<td>
<p>Grouping variable (symbol). Grouping variable over which to assess invariance.</p>
</td></tr>
<tr><td><code id="mires_+3A_data">data</code></td>
<td>
<p>data.frame. Must contain the indicators specified in formula, and the grouping variable.</p>
</td></tr>
<tr><td><code id="mires_+3A_inclusion_model">inclusion_model</code></td>
<td>
<p>String (Default: dependent). If dependent, then the regularization of RE-SDs are dependent (See Details). If independent, then regularization is per-parameter. This is useful for comparing a dependent inclusion model to a non-dependent inclusion model. Note that adaptive regularization occurs regardless (until a non-regularized version is implemented).</p>
</td></tr>
<tr><td><code id="mires_+3A_identification">identification</code></td>
<td>
<p>String (Default: sum_to_zero). If <code>hierarchical</code>, then latent means and (log) SDs are identified as zero-centered random effects. If <code>sum_to_zero</code>, then latent means are identified by a sum-to-zero constraint, and (log) latent SDs are identified by a sum-to-zero constraint.</p>
</td></tr>
<tr><td><code id="mires_+3A_save_scores">save_scores</code></td>
<td>
<p>Logical (Default: FALSE). If TRUE, latent scores for each observation are estimated. If FALSE (Default), latent scores are marginalized out; this can result in more efficient sampling and faster fits, due to the drastic reduction in estimated parameters. Note that the random effects for each group are always estimated, and are not marginalized out.</p>
</td></tr>
<tr><td><code id="mires_+3A_prior_only">prior_only</code></td>
<td>
<p>Logical (Default: FALSE). If TRUE, samples are drawn from the prior.</p>
</td></tr>
<tr><td><code id="mires_+3A_prior">prior</code></td>
<td>
<p>Numeric vector (Default: c(0, .25)). The location and scale parameters for the hierarchical inclusion model.</p>
</td></tr>
<tr><td><code id="mires_+3A_...">...</code></td>
<td>
<p>Further arguments to <code><a href="rstan.html#topic+sampling">sampling</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MIRES stands for Measurement Invariance assessment with Random Effects and Shrinkage.
Unlike other measurement invariance approaches, the MIRES model assumes all measurement model parameters (loadings, residual SDs, and intercepts) can randomly vary across groups &mdash; It is a mixed effects model on all parameters.
Unlike most mixed effects models, the random effect variances are themselves also hierarchically modeled from a half-normal distribution with location zero, and a scaling parameter.
This scaling parameter allows for rapid shrinkage of variance toward zero (invariance), while allowing variance if deemed necessary (non-invariance).
</p>
<p>The scaling parameter (an estimated quantity) controls whether the RE variance is effectively zero (invariant) or not (non-invariant).
Therefore, the random effect variances are regularized.
When <code>inclusion_model</code> is <code>dependent</code> (Default), the scaling parameters are hierarchically modeled.
By doing so, the invariance or non-invariance of a parameter is informed by other parameters with shared characteristics.
Currently, we assume that each parameter informs the invariance of other similar parameters (presence of variance in some loadings increases the probability of variance in other loadings), and of similar items (non-invariance of item j parameters informs other parameters for item j).
This approach increases the information available about presence or absence of invariance, allowing for more certain decisions.
</p>
<p>The &quot;Hierarchical inclusion model&quot; on the random effect variance manifests as a hierarchical prior.
When a dependent inclusion model is specified, then the hierarchical prior on random effect SDs is:
</p>
<p style="text-align: center;"><code class="reqn">p(\sigma_p | \exp(\tau)) = \mathcal{N}^+(\sigma_p | 0, \exp(\tau))</code>
</p>

<p style="text-align: center;"><code class="reqn">\tau = \tau_c + \tau_{param} + \tau_{item} + \tau_p</code>
</p>

<p style="text-align: center;"><code class="reqn">\tau_* \sim \mathcal{N}(\mu_h, \sigma_h)</code>
</p>

<p>Therefore, the regularization of each RE-SD is shared between all RE-SDs (tau_c), all RE-SDs of the same parameter type (tau_param), and all RE-SDs of the same item (tau_item).
</p>
<p>When an independent inclusion model is specified (<code>inclusion_model</code> is &quot;independent&quot;), only the independent regularization term <code class="reqn">\tau_p</code> is included.
The prior is then scaled so that the marginal prior on each <code class="reqn">p(\sigma_p)</code> remains the same.
In this case, RE-SDs cannot share regularization intensities between one another.
</p>
<p>The inclusion model hyper parameters (mu_h, sigma_h) can be specified, but we recommend the default as a relatively sane, but weakly informative prior.
</p>


<h3>Value</h3>

<p>mires object.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>


<h3>References</h3>

<p>Stan Development Team (2020). RStan: the R interface to Stan. R package version 2.21.1. https://mc-stan.org
</p>
<p>Martin, S. R., Williams, D. R., &amp; Rast, P. (2019, June 18). Measurement Invariance Assessment with Bayesian Hierarchical Inclusion Modeling. &lt;doi:10.31234/osf.io/qbdjt&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sim_loadings) # Load simulated data set
head(sim_loadings) # 8 indicators, grouping variable is called "group"

# Fit MIRES to simulated data example.
# Assume factor name is, e.g., agreeableness.
fit &lt;- mires(agreeableness ~ x_1 + x_2 + x_3 + x_4 + x_5 + x_6 + x_7 + x_8,
             group = group,
             data = sim_loadings, chains = 2, cores = 2)

# Summarize fit
summary(fit)

# Compare all groups' loadings:
pairwise(fit, param = "lambda")
# Compare groups "2" and "3" only:
pairwise(fit, param = "lambda", groups = c("2", "3"))

# Get random effects:
fit_ranefs &lt;- ranef(fit)
# Look at random effects of loadings:
fit_ranefs$lambda

</code></pre>

<hr>
<h2 id='MIRES-package'>The 'MIRES' package.</h2><span id='topic+MIRES-package'></span><span id='topic+MIRES'></span>

<h3>Description</h3>

<p>Estimates random effect latent measurement models, wherein the loadings, residual variances, intercepts, latent means, and latent variances all vary across groups. The random effect variances of the measurement parameters are then modeled using a hierarchical inclusion model, wherein the inclusion of the variances (i.e., whether it is effectively zero or non-zero) is informed by similar parameters (of the same type, or of the same item). This additional hierarchical structure allows the evidence in favor of partial invariance to accumulate more quickly, and yields more certain decisions about measurement invariance.
</p>


<h3>References</h3>

<p>Stan Development Team (2020). RStan: the R interface to Stan. R package version 2.21.1. https://mc-stan.org
</p>
<p>Martin, S. R., Williams, D. R., &amp; Rast, P. (2019, June 18). Measurement Invariance Assessment with Bayesian Hierarchical Inclusion Modeling. &lt;doi:10.31234/osf.io/qbdjt&gt;
</p>

<hr>
<h2 id='pairwise'>Pairwise comparisons of random parameters.</h2><span id='topic+pairwise'></span>

<h3>Description</h3>

<p>Compute pairwise differences in group-specific measurement parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise(
  mires,
  param = c("lambda", "resid", "nu"),
  prob = 0.95,
  less_than = 0.1,
  groups = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwise_+3A_mires">mires</code></td>
<td>
<p>mires object.</p>
</td></tr>
<tr><td><code id="pairwise_+3A_param">param</code></td>
<td>
<p>Character. One of <code>lambda</code> (loadings), <code>resid</code> (residual standard deviation on the log scale), or <code>nu</code> (intercepts).</p>
</td></tr>
<tr><td><code id="pairwise_+3A_prob">prob</code></td>
<td>
<p>Numeric (0-1). Probability mass contained within the highest density interval.</p>
</td></tr>
<tr><td><code id="pairwise_+3A_less_than">less_than</code></td>
<td>
<p>Numeric (Default: .1; positive). Value at which to assess Pr(|difference| &lt; less_than|D).</p>
</td></tr>
<tr><td><code id="pairwise_+3A_groups">groups</code></td>
<td>
<p>Character vector (Optional). If specified, will only compute pairwise differences of the specified groups.</p>
</td></tr>
<tr><td><code id="pairwise_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a specified set of parameters, this computes all pairwise differences in the random effects across the posterior. Specifically, this computes the posterior differences of groups' parameters, for all parameters. This is useful for comparing groups' estimates under non-invariance.
</p>


<h3>Value</h3>

<p>Data frame.
</p>


<h3>Author(s)</h3>

<p>Stephen Martin
</p>

<hr>
<h2 id='posterior_density_funs_sigmas'>Create marginal posterior density function approximations for random effect SDs</h2><span id='topic+posterior_density_funs_sigmas'></span>

<h3>Description</h3>

<p>For each RE-SD, approximates the marginal posterior density from MCMC samples for use in BF calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior_density_funs_sigmas(mires, add_zero = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_density_funs_sigmas_+3A_mires">mires</code></td>
<td>
<p>mires object.</p>
</td></tr>
<tr><td><code id="posterior_density_funs_sigmas_+3A_add_zero">add_zero</code></td>
<td>
<p>Logical (Default: TRUE). Whether to add a zero to samples.</p>
</td></tr>
<tr><td><code id="posterior_density_funs_sigmas_+3A_...">...</code></td>
<td>
<p>Args passed onto .density.stan.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Starts by computing (lower-bounded) logspline approximations.
If these fail, it uses the Dirichlet process with positive-normal kernels as an approximation.
</p>


<h3>Value</h3>

<p>List of approximate density functions.
</p>


<h3>Author(s)</h3>

<p>Stephen Martin
</p>

<hr>
<h2 id='predict_DP'>Prediction for DP density estimation models.</h2><span id='topic+predict_DP'></span>

<h3>Description</h3>

<p>Prediction for DP density estimation models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_DP(x, fit, K, pi = "pi", dens, params, R_params, samps = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_DP_+3A_x">x</code></td>
<td>
<p>Values for prediction.</p>
</td></tr>
<tr><td><code id="predict_DP_+3A_fit">fit</code></td>
<td>
<p>Stan DP fit.</p>
</td></tr>
<tr><td><code id="predict_DP_+3A_k">K</code></td>
<td>
<p>Max cluster.</p>
</td></tr>
<tr><td><code id="predict_DP_+3A_pi">pi</code></td>
<td>
<p>Character. Name of stan variable corresponding to DP weights.</p>
</td></tr>
<tr><td><code id="predict_DP_+3A_dens">dens</code></td>
<td>
<p>Function. The density base function used.</p>
</td></tr>
<tr><td><code id="predict_DP_+3A_params">params</code></td>
<td>
<p>Character vector. Names of base/kernel function parameters in Stan (e.g., mu, sigma for normal base functions).</p>
</td></tr>
<tr><td><code id="predict_DP_+3A_r_params">R_params</code></td>
<td>
<p>Character vector. Names of corresponding parameters for the R equivalent (e.g., mean, sd in dnorm).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of posterior mean, sd, .025, and .975 intervals.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='print.mires'>Print function for mires objects.</h2><span id='topic+print.mires'></span>

<h3>Description</h3>

<p>Print function for mires objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mires'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mires_+3A_x">x</code></td>
<td>
<p>mires object.</p>
</td></tr>
<tr><td><code id="print.mires_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x (Invisibly)
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='print.summary.mires'>Print method for MIRES summary objects.</h2><span id='topic+print.summary.mires'></span>

<h3>Description</h3>

<p>Print method for MIRES summary objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.mires'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.mires_+3A_x">x</code></td>
<td>
<p>summary.mires object.</p>
</td></tr>
<tr><td><code id="print.summary.mires_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x (Invisibly)
</p>


<h3>Author(s)</h3>

<p>Stephen Martin
</p>

<hr>
<h2 id='ranef.mires'>Extract random effects of each group from MIRES model.</h2><span id='topic+ranef.mires'></span><span id='topic+ranef'></span>

<h3>Description</h3>

<p>Extract random effects of each group from MIRES model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mires'
ranef(object, prob = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ranef.mires_+3A_object">object</code></td>
<td>
<p>mires object.</p>
</td></tr>
<tr><td><code id="ranef.mires_+3A_prob">prob</code></td>
<td>
<p>Numeric (Default: .95). Amount of probability mass to contain within the credible interval.</p>
</td></tr>
<tr><td><code id="ranef.mires_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing summaries of lambda, (log) residual SDs, nu, latent mean, and (log) latent SD random effects.
</p>


<h3>Author(s)</h3>

<p>Stephen R Martin
</p>

<hr>
<h2 id='rhmre'>Random sampling from hmre prior on RE SDs.</h2><span id='topic+rhmre'></span>

<h3>Description</h3>

<p>Random sampling from hmre prior on RE SDs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhmre(n, mu = 0, sigma = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rhmre_+3A_n">n</code></td>
<td>
<p>Integer.</p>
</td></tr>
<tr><td><code id="rhmre_+3A_mu">mu</code></td>
<td>
<p>Numeric. HMRE Prior location.</p>
</td></tr>
<tr><td><code id="rhmre_+3A_sigma">sigma</code></td>
<td>
<p>Numeric. (Default: 1; must be &gt; 0). HMRE prior scale.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='sim_all'>Simulated data: All parameters vary (Full non-invariance)</h2><span id='topic+sim_all'></span>

<h3>Description</h3>

<p>Simulated data: All parameters vary (Full non-invariance)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_all
</code></pre>


<h3>Format</h3>

<p>A simulated dataset containing eight indicators for one factor, and one grouping variable.
</p>

<hr>
<h2 id='sim_intercepts'>Simulated data: Intercepts vary</h2><span id='topic+sim_intercepts'></span>

<h3>Description</h3>

<p>Simulated data: Intercepts vary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_intercepts
</code></pre>


<h3>Format</h3>

<p>A simulated dataset containing eight indicators for one factor, and one grouping variable.
</p>

<hr>
<h2 id='sim_items'>Simulated data: Half the items are non-invariant.</h2><span id='topic+sim_items'></span>

<h3>Description</h3>

<p>Simulated data: Half the items are non-invariant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_items
</code></pre>


<h3>Format</h3>

<p>A simulated dataset containing eight indicators for one factor, and one grouping variable.
</p>

<hr>
<h2 id='sim_loadings'>Simulated data: Loadings vary</h2><span id='topic+sim_loadings'></span>

<h3>Description</h3>

<p>Simulated data: Loadings vary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_loadings
</code></pre>


<h3>Format</h3>

<p>A simulated dataset containing eight indicators for one factor, and one grouping variable.
</p>

<hr>
<h2 id='sim_none'>Simulated data: No variance (Full invariance)</h2><span id='topic+sim_none'></span>

<h3>Description</h3>

<p>Simulated data: No variance (Full invariance)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_none
</code></pre>


<h3>Format</h3>

<p>A simulated dataset containing eight indicators for one factor, and one grouping variable.
</p>

<hr>
<h2 id='sim_resid'>Simulated data: Residual variances vary</h2><span id='topic+sim_resid'></span>

<h3>Description</h3>

<p>Simulated data: Residual variances vary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_resid
</code></pre>


<h3>Format</h3>

<p>A simulated dataset containing eight indicators for one factor, and one grouping variable.
</p>

<hr>
<h2 id='simulate_DP'>Generate Truncated Dirichlet Process Mixture.</h2><span id='topic+simulate_DP'></span>

<h3>Description</h3>

<p>Generate Truncated Dirichlet Process Mixture.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_DP(N, K, param, alpha, f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_DP_+3A_n">N</code></td>
<td>
<p>Number of data points.</p>
</td></tr>
<tr><td><code id="simulate_DP_+3A_k">K</code></td>
<td>
<p>Max cluster.</p>
</td></tr>
<tr><td><code id="simulate_DP_+3A_param">param</code></td>
<td>
<p>Data.frame of parameters corresponding to d and r distribution  functions. (E.g., data.frame(mean = rnorm(50), sd = abs(rnorm(50, 0, .5))))</p>
</td></tr>
<tr><td><code id="simulate_DP_+3A_alpha">alpha</code></td>
<td>
<p>Numeric. The alpha parameter to the DP.</p>
</td></tr>
<tr><td><code id="simulate_DP_+3A_f">f</code></td>
<td>
<p>Character. Root name of base or kernel function (e.g., &quot;norm&quot;, &quot;exp&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of data (y), weights (pi), params (param), and the true density function (d).
</p>


<h3>Author(s)</h3>

<p>Stephen Martin
</p>

<hr>
<h2 id='split_stannames'>Split stan names into a list of parameter names (char vec) and (col-named) matrix of numeric indices.</h2><span id='topic+split_stannames'></span>

<h3>Description</h3>

<p>Split stan names into a list of parameter names (char vec) and (col-named) matrix of numeric indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_stannames(stannames, labs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_stannames_+3A_stannames">stannames</code></td>
<td>
<p>Char vector.</p>
</td></tr>
<tr><td><code id="split_stannames_+3A_labs">labs</code></td>
<td>
<p>Optional. Names of columns to which the indices meaningfully pertain to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of param names and a matrix of indices.
</p>


<h3>Author(s)</h3>

<p>Stephen R Martin
</p>

<hr>
<h2 id='summary.mires'>Summary method for mires object.</h2><span id='topic+summary.mires'></span>

<h3>Description</h3>

<p>Computes summaries for MIRES objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mires'
summary(object, prob = 0.95, less_than = 0.1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mires_+3A_object">object</code></td>
<td>
<p>mires object.</p>
</td></tr>
<tr><td><code id="summary.mires_+3A_prob">prob</code></td>
<td>
<p>Numeric (Default = .95). Probability mass to be contained in the highest posterior density interval.</p>
</td></tr>
<tr><td><code id="summary.mires_+3A_less_than">less_than</code></td>
<td>
<p>Numeric (Default: .1; positive). Value at which to assess Pr(SD &lt; less_than|D).</p>
</td></tr>
<tr><td><code id="summary.mires_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes summary tables for fixed measurement parameters (loadings, residual SDs, and intercepts) and random effect standard deviations (resd).
The printed output includes the posterior mean, median, SD, and .95 (Default) highest density intervals.
HDIs were chosen instead of quantile intervals because the random effect SDs can be on the boundary of zero if invariance is plausible.
Additionally, other columns exist to help aid decisions about invariance:
</p>

<dl>
<dt>BF01</dt><dd><p>Bayes factor of invariance (Variance = 0) to non-invariance (Variance &gt; 0)</p>
</dd>
<dt>BF10</dt><dd><p>Bayes factor of non-invariance (Variance &gt; 0) to invariance (Variance = 0). The inverse of BF01 for convenience</p>
</dd>
<dt>Pr(SD &lt;= <code>less_than</code>)</dt><dd><p>The posterior probability that the random effect SD is less than <code>less_than</code> (Default: .1). Set <code>less_than</code> to a value below which you would consider the variance to be effectively ignorable.</p>
</dd>
<dt>BF(SD &lt;= <code>less_than</code>)</dt><dd><p>The Bayes Factor comparing effectively-invariant (SD &lt; <code>less_than</code>) to non-invariant (SD &gt; <code>less_than</code>). Set <code>less_than</code> to a value below which you would consider variance to be effectively ignorable. This uses the encompassing prior approach.</p>
</dd>
</dl>



<h3>Value</h3>

<p>summary.mires object. List of meta data and summary. Summary is list of summary tables for all fixed effects parameters.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='tidy_stanpars'>Tidy up a vector of stan names into a data frame.</h2><span id='topic+tidy_stanpars'></span>

<h3>Description</h3>

<p>Tidy up a vector of stan names into a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_stanpars(stannames, labs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_stanpars_+3A_stannames">stannames</code></td>
<td>
<p>Character vector of stan names.</p>
</td></tr>
<tr><td><code id="tidy_stanpars_+3A_labs">labs</code></td>
<td>
<p>Optional. Character vector for what indices meaningfully pertain to. E.g., c(&quot;Factor&quot;, &quot;Item&quot;) for an FxJ matrix.</p>
</td></tr>
<tr><td><code id="tidy_stanpars_+3A_...">...</code></td>
<td>
<p>Optional. Named vectors of labels corresponding to indices. E.g., if labs = &quot;Item&quot;, and you include <code>Item = colnames(model_matrix)</code>, then the indices (numeric) are replaced by the name in the supplied vector. E.g., the numeric i will be replaced by the i-th name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame containing parameters and the (optionally named) indices.
</p>


<h3>Author(s)</h3>

<p>Stephen R Martin
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
