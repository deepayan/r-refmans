<!DOCTYPE html><html><head><title>Help for package rmsb</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rmsb}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#[.Ocens'><p>Ocens</p></a></li>
<li><a href='#as.data.frame.Ocens'><p>Convert <code>Ocens</code> Object to Data Frame to Facilitate Subset</p></a></li>
<li><a href='#blrm'><p>Bayesian Binary and Ordinal Logistic Regression</p></a></li>
<li><a href='#blrmStats'><p>Compute Indexes of Predictive Accuracy and Their Uncertainties</p></a></li>
<li><a href='#cluster'><p>cluster</p></a></li>
<li><a href='#coef.rmsb'><p>Extract Bayesian Summary of Coefficients</p></a></li>
<li><a href='#compareBmods'><p>Compare Bayesian Model Fits</p></a></li>
<li><a href='#distSym'><p>Distribution Symmetry Measure</p></a></li>
<li><a href='#ExProb.blrm'><p>Function Generator for Exceedance Probabilities for <code>blrm()</code></p></a></li>
<li><a href='#getParamCoef'><p>Get a Bayesian Parameter Vector Summary</p></a></li>
<li><a href='#HPDint'><p>Highest Posterior Density Interval</p></a></li>
<li><a href='#Mean.blrm'><p>Function Generator for Mean Y for <code>blrm()</code></p></a></li>
<li><a href='#Ocens'><p>Censored Ordinal Variable</p></a></li>
<li><a href='#pdensityContour'><p>Bivariate Posterior Contour</p></a></li>
<li><a href='#plot.PostF'><p>Plot Posterior Density of <code>PostF</code></p></a></li>
<li><a href='#plot.rmsb'><p>Plot Posterior Densities and Summaries</p></a></li>
<li><a href='#PostF'><p>Function Generator for Posterior Probabilities of Assertions</p></a></li>
<li><a href='#predict.blrm'><p>Make predictions from a <code>blrm()</code> fit</p></a></li>
<li><a href='#print.blrm'><p>Print <code>blrm()</code> Results</p></a></li>
<li><a href='#print.blrmStats'><p>Print Details for <code>blrmStats</code> Predictive Accuracy Measures</p></a></li>
<li><a href='#print.predict.blrm'><p>Print Predictions for <code>blrm()</code></p></a></li>
<li><a href='#print.rmsb'><p>Basic Print for Bayesian Parameter Summary</p></a></li>
<li><a href='#Quantile.blrm'><p>Function Generator for Quantiles of Y for <code>blrm()</code></p></a></li>
<li><a href='#rmsb-package'><p>The 'rmsb' package.</p></a></li>
<li><a href='#selectedQr'><p>QR Decomposition Preserving Selected Columns</p></a></li>
<li><a href='#stackMI'><p>Bayesian Model Fitting and Stacking for Multiple Imputation</p></a></li>
<li><a href='#stanDx'><p>Print Stan Diagnostics</p></a></li>
<li><a href='#stanDxplot'><p>Diagnostic Trace Plots</p></a></li>
<li><a href='#stanGet'><p>Get Stan Output</p></a></li>
<li><a href='#tauFetch'><p>Fetch Partial Proportional Odds Parameters</p></a></li>
<li><a href='#vcov.rmsb'><p>Variance-Covariance Matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Bayesian Regression Modeling Strategies</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-11</td>
</tr>
<tr>
<td>Description:</td>
<td>A Bayesian companion to the 'rms' package, 'rmsb' provides Bayesian model fitting, post-fit estimation, and graphics.  It implements Bayesian regression models whose fit objects can be processed by 'rms' functions such as 'contrast()', 'summary()', 'Predict()', 'nomogram()', and 'latex()'.  The fitting function currently implemented in the package is 'blrm()' for Bayesian logistic binary and ordinal regression with optional clustering, censoring, and departures from the proportional odds assumption using the partial proportional odds model of Peterson and Harrell (1990) <a href="https://www.jstor.org/stable/2347760">https://www.jstor.org/stable/2347760</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://hbiostat.org/R/rmsb/">https://hbiostat.org/R/rmsb/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), rms (&ge; 6.8-0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, Rcpp (&ge; 0.12.0), rstan (&ge; 2.26.23), Hmisc (&ge;
4.3-0), survival (&ge; 3.1-12), ggplot2, MASS, cluster, digest,
knitr, loo</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0), Rcpp (&ge; 0.12.0), RcppEigen (&ge; 0.3.3.3.0),
RcppParallel (&ge; 5.0.1), rstan (&ge; 2.18.1), StanHeaders (&ge;
2.18.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>cmdstanr, bayesplot, mice</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://mc-stan.org/r-packages/">https://mc-stan.org/r-packages/</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-11 22:29:58 UTC; harrelfe</td>
</tr>
<tr>
<td>Author:</td>
<td>Frank Harrell <a href="https://orcid.org/0000-0002-8271-5493"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Ben Goodrich [ctb] (contributed Stan code),
  Ben Bolker [ctb] (wrote original code that is folded into the
    pdensityContour function),
  Doug Bates [ctb] (write original code for highest posterior density
    interval that is folded into the HPDint function)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Frank Harrell &lt;fh@fharrell.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-12 15:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B.Ocens'>Ocens</h2><span id='topic++5B.Ocens'></span>

<h3>Description</h3>

<p>Subset Method for <code>Ocens</code> Objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Ocens'
x[rows = 1:d[1], cols = 1:d[2], ...]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.Ocens_+3A_x">x</code></td>
<td>
<p>an <code>Ocens</code> object</p>
</td></tr>
<tr><td><code id="+2B5B.Ocens_+3A_rows">rows</code></td>
<td>
<p>logical or integer vector</p>
</td></tr>
<tr><td><code id="+2B5B.Ocens_+3A_cols">cols</code></td>
<td>
<p>logical or integer vector</p>
</td></tr>
<tr><td><code id="+2B5B.Ocens_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Subsets an <code>Ocens</code> object, preserving its special attributes.  Attributes are not updated.  In the future such updating should be implemented.
</p>


<h3>Value</h3>

<p>new <code>Ocens</code> object
</p>


<h3>Author(s)</h3>

<p>Frank Harrell
</p>

<hr>
<h2 id='as.data.frame.Ocens'>Convert <code>Ocens</code> Object to Data Frame to Facilitate Subset</h2><span id='topic+as.data.frame.Ocens'></span>

<h3>Description</h3>

<p>Converts an <code>Ocens</code> object to a data frame so that subsetting will preserve all needed attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Ocens'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.Ocens_+3A_x">x</code></td>
<td>
<p>an <code>Ocens</code> object</p>
</td></tr>
<tr><td><code id="as.data.frame.Ocens_+3A_row.names">row.names</code></td>
<td>
<p>optional vector of row names</p>
</td></tr>
<tr><td><code id="as.data.frame.Ocens_+3A_optional">optional</code></td>
<td>
<p>set to <code>TRUE</code> if needed</p>
</td></tr>
<tr><td><code id="as.data.frame.Ocens_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame containing a 2-column integer matrix with attributes
</p>


<h3>Author(s)</h3>

<p>Frank Harrell
</p>

<hr>
<h2 id='blrm'>Bayesian Binary and Ordinal Logistic Regression</h2><span id='topic+blrm'></span>

<h3>Description</h3>

<p>Uses <code>rstan</code> with pre-compiled Stan code, or <code>cmdstan</code> to get posterior draws of parameters from a binary logistic or proportional odds semiparametric ordinal logistic model.  The Stan code internally using the qr decompositon on the design matrix so that highly collinear columns of the matrix do not hinder the posterior sampling.  The parameters are transformed back to the original scale before returning results to R.   Design matrix columns are centered before running Stan, so Stan diagnostic output will have the intercept terms shifted but the results of <code><a href="#topic+blrm">blrm()</a></code> for intercepts are for the original uncentered data.  The only prior distributions for regression betas are normal with mean zero.  Priors are specified on contrasts so that they can be specified on a meaningful scale and so that more complex patterns can be imposed.  Parameters that are not involved in any contrasts in <code>pcontrast</code> or <code>npcontrast</code> have non-informative priors.  Contrasts are automatically converted to the QR space used in Stan code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blrm(
  formula,
  ppo = NULL,
  cppo = NULL,
  data = environment(formula),
  subset,
  na.action = na.delete,
  priorsdppo = rep(100, pppo),
  iprior = 0,
  conc = 1/(0.8 + 0.35 * max(k, 3)),
  ascale = 1,
  psigma = 1,
  rsdmean = if (psigma == 1) 0 else 1,
  rsdsd = 1,
  normcppo = FALSE,
  pcontrast = NULL,
  npcontrast = NULL,
  backend = c("rstan", "cmdstan"),
  iter = 2000,
  warmup = iter/2,
  chains = 4,
  refresh = 0,
  progress = if (refresh &gt; 0) "stan-progress.txt" else "",
  x = TRUE,
  y = TRUE,
  loo = n &lt;= 1000,
  ppairs = NULL,
  method = c("both", "sampling", "optimizing"),
  inito = if (length(ppo)) 0 else "random",
  inits = inito,
  standata = FALSE,
  file = NULL,
  debug = FALSE,
  sampling.args = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blrm_+3A_formula">formula</code></td>
<td>
<p>a R formula object that can use <code>rms</code> package enhancements such as the restricted interaction operator</p>
</td></tr>
<tr><td><code id="blrm_+3A_ppo">ppo</code></td>
<td>
<p>formula specifying the model predictors for which proportional odds is not assumed</p>
</td></tr>
<tr><td><code id="blrm_+3A_cppo">cppo</code></td>
<td>
<p>a function that if present causes a constrained partial PO model to be fit.  The function specifies the values in the Gamma vector in Peterson and Harrell (1990) equation (6).  Sometimes to make posterior sampling better behaved, the function should be scaled and centered.  This is done by wrapping <code>cppo</code> in a function that scales the <code>cppo</code> result before returning the vector value, when <code>normcppo</code> is <code>TRUE</code>. The default normalization is based on the mean and standard deviation of the function values over the distribution of observed Y.  For getting predicted values and estimates post-<code><a href="#topic+blrm">blrm()</a></code>, <code>cppo</code> must not reference any functions that are not available at such later times.</p>
</td></tr>
<tr><td><code id="blrm_+3A_data">data</code></td>
<td>
<p>a data frame; defaults to using objects from the calling environment</p>
</td></tr>
<tr><td><code id="blrm_+3A_subset">subset</code></td>
<td>
<p>a logical vector or integer subscript vector specifying which subset of data whould be used</p>
</td></tr>
<tr><td><code id="blrm_+3A_na.action">na.action</code></td>
<td>
<p>default is <code>na.delete</code> to remove missings and report on them</p>
</td></tr>
<tr><td><code id="blrm_+3A_priorsdppo">priorsdppo</code></td>
<td>
<p>vector of prior standard deviations for non-proportional odds parameters.  The last element is the only one for which the SD corresponds to the original data scale.  This only applies to the unconstrained PPO model.</p>
</td></tr>
<tr><td><code id="blrm_+3A_iprior">iprior</code></td>
<td>
<p>specifies whether to use a Dirichlet distribution for the cell probabilities, which induce a more complex prior distribution for the intercepts (<code>iprior=0</code>, the default), non-informative priors (<code>iprior=1</code>) directly on the intercept parameters,  or to directly use a t-distribution with 3 d.f. and scale parameter <code>ascale</code> (<code>iprior=2</code>).</p>
</td></tr>
<tr><td><code id="blrm_+3A_conc">conc</code></td>
<td>
<p>the Dirichlet distribution concentration parameter for the prior distribution of cell probabilities at covariate means.  The default is the reciprocal of 0.8 + 0.35 max(k, 3) where k is the number of Y categories.  The default is chosen to make the posterior mean of the intercepts more closely match the MLE.  For optimizing, the concentration parameter is always 1.0 to obtain results very close to the MLE for providing the posterior mode.</p>
</td></tr>
<tr><td><code id="blrm_+3A_ascale">ascale</code></td>
<td>
<p>scale parameter for the t-distribution for priors for the intercepts if <code>iprior=2</code>, defaulting to 1.0</p>
</td></tr>
<tr><td><code id="blrm_+3A_psigma">psigma</code></td>
<td>
<p>defaults to 1 for a half-t distribution with 4 d.f., location parameter <code>rsdmean</code> and scale parameter <code>rsdsd</code>.  Set <code>psigma=2</code> to use the exponential distribution.</p>
</td></tr>
<tr><td><code id="blrm_+3A_rsdmean">rsdmean</code></td>
<td>
<p>the assumed mean of the prior distribution of the standard deviation of random effects.  When <code>psigma=2</code> this is the mean of an exponential distribution and defaults to 1.  When <code>psigma=1</code> this is the mean of the half-t distribution and defaults to zero.</p>
</td></tr>
<tr><td><code id="blrm_+3A_rsdsd">rsdsd</code></td>
<td>
<p>applies only to <code>psigma=1</code> and is the scale parameter for the half t distribution for the SD of random effects, defaulting to 1.</p>
</td></tr>
<tr><td><code id="blrm_+3A_normcppo">normcppo</code></td>
<td>
<p>set to <code>TRUE</code> to modify the <code>cppo</code> function automatically centering and scaling the result</p>
</td></tr>
<tr><td><code id="blrm_+3A_pcontrast">pcontrast</code></td>
<td>
<p>a list specifying contrasts that are to be given Gaussian prior distributions.  The predictor combinations specified in <code>pcontrast</code> are run through <code><a href="rms.html#topic+gendata">rms::gendata()</a></code> so that contrasts are specified in units of original variables, and unspecified variables are set to medians or modes as saved by <code><a href="rms.html#topic+datadist">rms::datadist()</a></code>.  Thanks to <code>Stan</code>, putting priors on combinations and transformations of model parameters has the same effect of putting different priors on the original parameters without figuring out how to do that.  The syntax used here allows specification of differences, double differences (e.g., interactions or nonlinearity), triple differences (e.g., to put contraints on nonlinear interactions), etc.  The requested predictor combinations must be named so they may be referred to inside <code>contrast</code>.  The syntax is <code>pcontrast=list(..., contrast=expression(...), mu=, sd=, weights=, ycut=, expand=)</code>.  <code>...</code> denotes one or more <code>list()</code>s with predictor combinations, and each <code>list()</code> must be named, e.g., <code>pcontrast=list(c1=list(sex='female'), c2=list(sex='male'))</code> to set up for a <code>female - male</code> contrast specified as <code>contrast=expression(c1 - c2)</code>.  The <code>c1 - c2</code> subtraction will operate on the design matrices generated by the covariate settings in the <code>list()</code>s.  For <code style="white-space: pre;">&#8288;weights, ycut, expand&#8288;</code> see <code><a href="rms.html#topic+Xcontrast">rms::Xcontrast()</a></code> and <code><a href="rms.html#topic+contrast">rms::contrast.rms()</a></code>.  <code>mu</code> is a vector of prior means associated with the rows of the stacked contrasts, and <code>sd</code> is a corresponding vector of Gaussian prior SDs.  When <code>mu</code> is not given it defaults to 0.0, and <code>sd</code> defaults to 100.0.  Values of <code>mu</code> and/or <code>sd</code> are repeated to the number of contrasts if they are of length 1.  Full examples are given <a href="https://hbiostat.org/rmsc/genreg#bayes">here</a>.</p>
</td></tr>
<tr><td><code id="blrm_+3A_npcontrast">npcontrast</code></td>
<td>
<p>like <code>pcontrast</code> but applies to the non-proportional odds submodel in <code>ppo</code>.  Priors for the amount of departure from proportional odds are isolated from the priors of the &quot;main effects&quot; in <code>formula</code>.  The contrasts specified in <code>npcontrast</code> must include <code>ycut</code>, and <code>ycut</code> must vary over the elements of the contrasts to make sense.</p>
</td></tr>
<tr><td><code id="blrm_+3A_backend">backend</code></td>
<td>
<p>set to <code>cmdstan</code> to use <code>cmdstan</code> through the R <code>cmdstanr</code> package instead of the default <code>rstan</code>.  You can also specify this with a global option <code>rmsb.backend</code>.</p>
</td></tr>
<tr><td><code id="blrm_+3A_iter">iter</code></td>
<td>
<p>number of posterior samples per chain for <code><a href="rstan.html#topic+stanmodel-method-sampling">rstan::sampling()</a></code> to run, counting warmups</p>
</td></tr>
<tr><td><code id="blrm_+3A_warmup">warmup</code></td>
<td>
<p>number of warmup iterations to discard.  Default is <code>iter</code>/2.</p>
</td></tr>
<tr><td><code id="blrm_+3A_chains">chains</code></td>
<td>
<p>number of separate chains to run</p>
</td></tr>
<tr><td><code id="blrm_+3A_refresh">refresh</code></td>
<td>
<p>see <code><a href="rstan.html#topic+stanmodel-method-sampling">rstan::sampling()</a></code> and <code><a href="cmdstanr.html#topic+model-method-sample">cmdstanr::sample()</a></code>.  The default is 0, indicating that no progress notes are output.  If <code>refresh &gt; 0</code> and <code>progress</code> is not <code>''</code>, progress output will be appended to file <code>progress</code>.  The default file name is <code>'stan-progress.txt'</code>.</p>
</td></tr>
<tr><td><code id="blrm_+3A_progress">progress</code></td>
<td>
<p>see <code>refresh</code>.  Defaults to <code>''</code> if <code>refresh = 0</code>.  Note: If running interactively but not under RStudio, <code>rstan</code> will open a browser window for monitoring progress.</p>
</td></tr>
<tr><td><code id="blrm_+3A_x">x</code></td>
<td>
<p>set to <code>FALSE</code> to not store the design matrix in the fit.  <code>x=TRUE</code> is needed if running <code>blrmStats</code> for example.</p>
</td></tr>
<tr><td><code id="blrm_+3A_y">y</code></td>
<td>
<p>set to <code>FALSE</code> to not store the response variable in the fit</p>
</td></tr>
<tr><td><code id="blrm_+3A_loo">loo</code></td>
<td>
<p>set to <code>FALSE</code> to not run <code>loo</code> and store its result as object <code>loo</code> in the returned object.  <code>loo</code> defaults to <code>FALSE</code> if the sample size is greater than 1000, as <code>loo</code> requires the per-observation likelihood components, which creates a matrix N times the number of posterior draws.</p>
</td></tr>
<tr><td><code id="blrm_+3A_ppairs">ppairs</code></td>
<td>
<p>set to a file name to run <code>rstan</code> <code>pairs</code> or, if <code>backend='cmdstan'</code> <code>bayesplot::mcmc_pairs</code> and store the resulting png plot there.  Set to <code>TRUE</code> instead to directly plot these diagnostics.  The default is not to run pair plots.</p>
</td></tr>
<tr><td><code id="blrm_+3A_method">method</code></td>
<td>
<p>set to <code>'optimizing'</code> to run the Stan optimizer and not do posterior sampling, <code>'both'</code> (the default) to run both the optimizer and posterior sampling, or <code>'sampling'</code> to run only the posterior sampling and not compute posterior modes. Running <code>optimizing</code> is a way to obtain maximum likelihood estimates and allows one to quickly study the effect of changing the prior distributions.  When <code>method='optimizing'</code> is used the result returned is not a standard <code><a href="#topic+blrm">blrm()</a></code> object but is instead the parameter estimates, -2 log likelihood, and optionally the Hession matrix (if you specify <code>hessian=TRUE</code> in ...).  When <code>method='both'</code> is used, <code><a href="rstan.html#topic+stanmodel-method-sampling">rstan::sampling()</a></code> and <code><a href="rstan.html#topic+stanmodel-method-optimizing">rstan::optimizing()</a></code> are both run, and parameter estimates (posterior modes) from <code>optimizing</code> are stored in a matrix <code>param</code> in the fit object, which also contains the posterior means and medians, and other results from <code>optimizing</code> are stored in object <code>opt</code> in the <code><a href="#topic+blrm">blrm()</a></code> fit object.  When random effects are present, <code>method</code> is automatically set to <code>'sampling'</code> as maximum likelihood estimates without marginalizing over the random effects do not make sense.</p>
</td></tr>
<tr><td><code id="blrm_+3A_inito">inito</code></td>
<td>
<p>intial value for optimization.  The default is the <code>rstan</code> default <code>'random'</code>.  Frequently specifying <code>init=0</code> will benefit when the number of distinct Y categories grows or when using <code>ppo</code> hence 0 is the default for that.</p>
</td></tr>
<tr><td><code id="blrm_+3A_inits">inits</code></td>
<td>
<p>initial value for sampling, defaults to <code>inito</code></p>
</td></tr>
<tr><td><code id="blrm_+3A_standata">standata</code></td>
<td>
<p>set to <code>TRUE</code> to return the Stan data list and not run the model</p>
</td></tr>
<tr><td><code id="blrm_+3A_file">file</code></td>
<td>
<p>a file name for a <code>saveRDS</code>-created file containing or to contain the saved fit object.  If <code>file</code> is specified and the file does not exist, it will be created right before the fit object is returned, less the large <code>rstan</code> object.  If the file already exists, its stored <code>md5</code> hash string <code>datahash</code> fit object component is retrieved and compared to that of the current <code>rstan</code> inputs.  If the data to be sent to <code>rstan</code>, the priors, and all sampling and optimization options and stan code are identical, the previously stored fit object is immediately returned and no new calculatons are done.</p>
</td></tr>
<tr><td><code id="blrm_+3A_debug">debug</code></td>
<td>
<p>set to <code>TRUE</code> to output timing and progress information to /tmp/debug.txt</p>
</td></tr>
<tr><td><code id="blrm_+3A_sampling.args">sampling.args</code></td>
<td>
<p>a list containing parameters to pass to <code><a href="rstan.html#topic+stanmodel-method-sampling">rstan::sampling()</a></code> or to the <code>rcmdstan</code> <code>sample</code> function, other than these arguments: <code style="white-space: pre;">&#8288;iter, warmup, chains, refresh, init&#8288;</code> which are already arguments to <code>blrm</code></p>
</td></tr>
<tr><td><code id="blrm_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="rstan.html#topic+stanmodel-method-optimizing">rstan::optimizing()</a></code> or the <code>rcmdstan</code> optimizing function.  The <code>seed</code> parameter is a popular example.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The partial proportional odds model of Peterson and Harrell (1990) is implemented, and is invoked when the user specifies a second model formula as the <code>ppo</code> argument.  This formula has no left-hand-side variable, and has right-side variables that are a subset of those in <code>formula</code> specifying for which predictors the proportional odds assumption is relaxed.
</p>
<p>The Peterson and Harrell (1990) constrained partial proportional odds is also implemented, and is usually preferred to the above unconstrained PPO model as it adds a vector of coefficients instead of a matrix of coefficients.  In the constrained PPO model the user provides a function <code>cppo</code> that computes a score for all observed values of the dependent variable.  For example with a discrete ordinal outcome <code>cppo</code> may return a value of 1.0 for a specific value of Y and zero otherwise.  That will result in a departure from the proportional odds assumption for just that one level of Y.  The value returned by <code>cppo</code> at the lowest Y value is never used in any case.
</p>
<p><code><a href="#topic+blrm">blrm()</a></code> also handles single-level hierarchical random effects models for the case when there are repeated measurements per subject which are reflected as random intercepts, and a different experimental model that allows for AR(1) serial correlation within subject.  For both setups, a <code>cluster</code> term in the model signals the existence of subject-specific random effects.
</p>
<p>When using the <code>cmdstan</code> backend, <code>cmdstanr</code> will need to compile the Stan code once per computer, only recompiling the code when the Stan source code changes.  By default the compiled code is stored in directory <code>.rmsb</code> under your home directory.  Specify <code>options(rmsbdir=)</code> to specify a different location.  You should specify <code>rmsbdir</code> to be in a project-specific location if you want to archive code for old projects.
</p>
<p>If you want to run MCMC sampling even when no inputs or Stan code have changed, i.e., to use a different random number seed for the sampling process, remove the <code>file</code> before running <code>blrm</code>.
</p>
<p>See <a href="https://hbiostat.org/R/examples/blrm/blrm.html">here</a> and <a href="https://hbiostat.org/R/examples/blrm/blrmc.html">here</a> for multiple examples with results.
</p>


<h3>Value</h3>

<p>an <code>rms</code> fit object of class <code>blrm</code>, <code>rmsb</code>, <code>rms</code> that also contains <code>rstan</code> or <code>cmdstanr</code> results under the name <code>rstan</code>.  In the <code>rstan</code> results, which are also used to produce diagnostics, the intercepts are shifted because of the centering of columns of the design matrix done by <code><a href="#topic+blrm">blrm()</a></code>.  With <code>method='optimizing'</code> a class-less list is return with these elements: <code>coefficients</code> (MLEs), <code>beta</code> (non-intercept parameters on the QR decomposition scale), <code>deviance</code> (-2 log likelihood), <code>return_code</code> (see <code><a href="rstan.html#topic+stanmodel-method-optimizing">rstan::optimizing()</a></code>), and, if you specified <code>hessian=TRUE</code> to <code><a href="#topic+blrm">blrm()</a></code>, the Hessian matrix.  To learn about the scaling of orthogonalized QR design matrix columns, look at the <code>xqrsd</code> object in the returned object.  This is the vector of SDs for all the columns of the transformed matrix.  The returned element <code>sampling_time</code> is the elapsed time for running posterior samplers, in seconds.  This will be just a little more than the time for running one CPU core for one chain.
</p>


<h3>Author(s)</h3>

<p>Frank Harrell and Ben Goodrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.blrm">print.blrm()</a></code>, <code><a href="#topic+blrmStats">blrmStats()</a></code>, <code><a href="#topic+stanDx">stanDx()</a></code>, <code><a href="#topic+stanGet">stanGet()</a></code>, <code><a href="#topic+coef.rmsb">coef.rmsb()</a></code>, <code><a href="#topic+vcov.rmsb">vcov.rmsb()</a></code>, <code><a href="#topic+print.rmsb">print.rmsb()</a></code>, <code><a href="#topic+coef.rmsb">coef.rmsb()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  getHdata(titanic3)
  dd &lt;- datadist(titanic3); options(datadist='dd')
  f &lt;- blrm(survived ~ (rcs(age, 5) + sex + pclass)^2, data=titanic3)
  f                   # model summary using print.blrm
  coef(f)             # compute posterior mean parameter values
  coef(f, 'median')   # compute posterior median values
  stanDx(f)           # print basic Stan diagnostics
  s &lt;- stanGet(f)     # extract rstan object from fit
  plot(s, pars=f$betas)       # Stan posteriors for beta parameters
  stanDxplot(s)       # Stan diagnostic plots by chain
  blrmStats(f)        # more details about predictive accuracy measures
  ggplot(Predict(...))   # standard rms output
  summary(f, ...)     # invokes summary.rms
  contrast(f, ...)    # contrast.rms computes HPD intervals
  plot(nomogram(f, ...)) # plot nomogram using posterior mean parameters

  # Fit a random effects model to handle multiple observations per
  # subject ID using cmdstan
  # options(rmsb.backend='cmdstan')
  f &lt;- blrm(outcome ~ rcs(age, 5) + sex + cluster(id), data=mydata)

## End(Not run)
</code></pre>

<hr>
<h2 id='blrmStats'>Compute Indexes of Predictive Accuracy and Their Uncertainties</h2><span id='topic+blrmStats'></span>

<h3>Description</h3>

<p>For a binary or ordinal logistic regression fit from <code><a href="#topic+blrm">blrm()</a></code>, computes several indexes of predictive accuracy along with highest posterior density intervals for them.  Optionally plots their posterior densities.
When there are more than two levels of the outcome variable, computes Somers' Dxy and c-index on a random sample of 10,000 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blrmStats(fit, ns = 400, prob = 0.95, pl = FALSE, dist = c("density", "hist"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blrmStats_+3A_fit">fit</code></td>
<td>
<p>an object produced by <code><a href="#topic+blrm">blrm()</a></code></p>
</td></tr>
<tr><td><code id="blrmStats_+3A_ns">ns</code></td>
<td>
<p>number of posterior draws to use in the calculations (default is 400)</p>
</td></tr>
<tr><td><code id="blrmStats_+3A_prob">prob</code></td>
<td>
<p>HPD interval probability (default is 0.95)</p>
</td></tr>
<tr><td><code id="blrmStats_+3A_pl">pl</code></td>
<td>
<p>set to <code>TRUE</code> to plot the posterior densities using base graphics</p>
</td></tr>
<tr><td><code id="blrmStats_+3A_dist">dist</code></td>
<td>
<p>if <code>pl</code> is <code>TRUE</code> specifies whether to plot the density estimate (the default) or a histogram</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of class <code>blrmStats</code> whose most important element is <code>Stats</code>.  The indexes computed are defined below, with gp, B, EV, and vp computed using the intercept corresponding to the median value of Y.  See <a href="https://fharrell.com/post/addvalue">https://fharrell.com/post/addvalue</a> for more information.
</p>

<dl>
<dt>&quot;Dxy&quot;</dt><dd><p>Somers' Dxy rank correlation between predicted and observed.  The concordance probability (c-index; AUROC in the binary Y case) may be obtained from the relationship Dxy=2(c-0.5).</p>
</dd>
<dt>&quot;g&quot;</dt><dd><p>Gini's mean difference: the average absolute difference over all pairs of linear predictor values</p>
</dd>
<dt>&quot;gp&quot;</dt><dd><p>Gini's mean difference on the predicted probability scale</p>
</dd>
<dt>&quot;B&quot;</dt><dd><p>Brier score</p>
</dd>
<dt>&quot;EV&quot;</dt><dd><p>explained variation</p>
</dd>
<dt>&quot;v&quot;</dt><dd><p>variance of linear predictor</p>
</dd>
<dt>&quot;vp&quot;</dt><dd><p>variable of estimated probabilities</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Frank Harrell
</p>


<h3>See Also</h3>

<p><code><a href="Hmisc.html#topic+rcorr.cens">Hmisc::rcorr.cens()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  f &lt;- blrm(...)
  blrmStats(f, pl=TRUE)   # print and plot

## End(Not run)
</code></pre>

<hr>
<h2 id='cluster'>cluster</h2><span id='topic+cluster'></span>

<h3>Description</h3>

<p>Cluster Function for Random Effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_+3A_x">x</code></td>
<td>
<p>a vector representing a categorical vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used by <code>blrm</code> to signal a categorical variable to generate random effects.
</p>


<h3>Value</h3>

<p>x unchanged
</p>


<h3>Author(s)</h3>

<p>Frank Harrell
</p>

<hr>
<h2 id='coef.rmsb'>Extract Bayesian Summary of Coefficients</h2><span id='topic+coef.rmsb'></span>

<h3>Description</h3>

<p>Computes either the posterior mean (default), posterior median, or posterior mode of the parameters in an <code>rms</code> Bayesian regression model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rmsb'
coef(object, stat = c("mean", "median", "mode"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.rmsb_+3A_object">object</code></td>
<td>
<p>an object created by an <code>rms</code> package Bayesian fitting function</p>
</td></tr>
<tr><td><code id="coef.rmsb_+3A_stat">stat</code></td>
<td>
<p>name of measure of posterior distribution central tendency to compute</p>
</td></tr>
<tr><td><code id="coef.rmsb_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of intercepts and regression coefficients
</p>


<h3>Author(s)</h3>

<p>Frank Harrell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  f &lt;- blrm(...)
  coef(f, stat='mode')

## End(Not run)
</code></pre>

<hr>
<h2 id='compareBmods'>Compare Bayesian Model Fits</h2><span id='topic+compareBmods'></span>

<h3>Description</h3>

<p>Uses <code><a href="loo.html#topic+loo_model_weights">loo::loo_model_weights()</a></code> to compare a series of models such as those created with <code><a href="#topic+blrm">blrm()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareBmods(..., method = "stacking", r_eff_list = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compareBmods_+3A_...">...</code></td>
<td>
<p>a series of model fits</p>
</td></tr>
<tr><td><code id="compareBmods_+3A_method">method</code></td>
<td>
<p>see <code><a href="loo.html#topic+loo_model_weights">loo::loo_model_weights()</a></code></p>
</td></tr>
<tr><td><code id="compareBmods_+3A_r_eff_list">r_eff_list</code></td>
<td>
<p>see <code><a href="loo.html#topic+loo_model_weights">loo::loo_model_weights()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="loo.html#topic+loo_model_weights">loo::loo_model_weights()</a></code> object
</p>


<h3>Author(s)</h3>

<p>Frank Harrell
</p>

<hr>
<h2 id='distSym'>Distribution Symmetry Measure</h2><span id='topic+distSym'></span>

<h3>Description</h3>

<p>From a sample from a distribution computes a symmetry measure.  By default it is the gap between the mean and the 0.95 quantile divided by the gap between the 0.05 quantile and the mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distSym(x, prob = 0.9, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distSym_+3A_x">x</code></td>
<td>
<p>a numeric vector representing a sample from a continuous distribution</p>
</td></tr>
<tr><td><code id="distSym_+3A_prob">prob</code></td>
<td>
<p>quantile interval coverage</p>
</td></tr>
<tr><td><code id="distSym_+3A_na.rm">na.rm</code></td>
<td>
<p>set to <code>TRUE</code> to remove <code>NA</code>s before proceeding.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar with a value of 1.0 indicating symmetry
</p>


<h3>Author(s)</h3>

<p>Frank Harrell
</p>

<hr>
<h2 id='ExProb.blrm'>Function Generator for Exceedance Probabilities for <code><a href="#topic+blrm">blrm()</a></code></h2><span id='topic+ExProb.blrm'></span>

<h3>Description</h3>

<p>For a <code><a href="#topic+blrm">blrm()</a></code> object generates a function for computing the	estimates of the function Prob(Y&gt;=y) given one or more values of the linear predictor using the reference (median) intercept.  This function can optionally be evaluated at only a set of user-specified	<code>y</code> values, otherwise a right-step function is returned.  There is a plot method for plotting the step functions, and if more than one linear predictor was evaluated multiple step functions are drawn. <code>ExProb</code> is especially useful for <code>nomogram()</code>.  The linear predictor argument is a posterior summarized linear predictor lp (e.g. using posterior mean of intercepts and slopes) computed at the reference intercept.  <code>lptau</code> must be provided when call the created function if the model is a partial proportional odds model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'blrm'
ExProb(object, posterior.summary = c("mean", "median"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExProb.blrm_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+blrm">blrm()</a></code> fit</p>
</td></tr>
<tr><td><code id="ExProb.blrm_+3A_posterior.summary">posterior.summary</code></td>
<td>
<p>defaults to posterior mean; may also specify <code>"median"</code>.  Must be consistent with the summary used when creating <code>lp</code>.</p>
</td></tr>
<tr><td><code id="ExProb.blrm_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an R function
</p>


<h3>Author(s)</h3>

<p>Frank Harrell
</p>

<hr>
<h2 id='getParamCoef'>Get a Bayesian Parameter Vector Summary</h2><span id='topic+getParamCoef'></span>

<h3>Description</h3>

<p>Retrieves posterior mean, median, or mode (if available)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getParamCoef(
  fit,
  posterior.summary = c("mean", "median", "mode"),
  what = c("both", "betas", "taus")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getParamCoef_+3A_fit">fit</code></td>
<td>
<p>a Bayesian model fit from <code>rmsb</code></p>
</td></tr>
<tr><td><code id="getParamCoef_+3A_posterior.summary">posterior.summary</code></td>
<td>
<p>which summary statistic (Bayesian point estimate) to fetch</p>
</td></tr>
<tr><td><code id="getParamCoef_+3A_what">what</code></td>
<td>
<p>specifies which coefficients to include.  Default is all.  Specify <code>what="betas"</code> to include only intercepts and betas if the model is a partial proportional odds model (i.e.,, exclude the tau parameters).  Specify <code>what="taus"</code> to include only the tau parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of regression coefficients
</p>


<h3>Author(s)</h3>

<p>Frank Harrell
</p>

<hr>
<h2 id='HPDint'>Highest Posterior Density Interval</h2><span id='topic+HPDint'></span>

<h3>Description</h3>

<p>Adapts code from <code><a href="coda.html#topic+HPDinterval">coda::HPDinterval()</a></code> to compute a highest posterior density interval from posterior samples for a single parameter.  Quoting from the <code>coda</code> help file, for each parameter the interval is constructed from the empirical cdf of the sample as the shortest interval  for  which  the  difference  in  the  ecdf  values  of  the  endpoints  is  the  nominal  probability.  Assuming that the distribution is not severely multimodal, this is the HPD interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HPDint(x, prob = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HPDint_+3A_x">x</code></td>
<td>
<p>a vector of posterior draws</p>
</td></tr>
<tr><td><code id="HPDint_+3A_prob">prob</code></td>
<td>
<p>desired probability coverage</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 2-vector with elements <code>Lower</code> and <code>Upper</code>
</p>


<h3>Author(s)</h3>

<p>Douglas Bates and Frank Harrell
</p>

<hr>
<h2 id='Mean.blrm'>Function Generator for Mean Y for <code><a href="#topic+blrm">blrm()</a></code></h2><span id='topic+Mean.blrm'></span>

<h3>Description</h3>

<p>Creates a function to turn a posterior summarized linear predictor lp (e.g. using posterior mean of intercepts and slopes) computed at the reference intercept into e.g. an estimate of mean Y using the posterior mean of all the intercept.  <code>lptau</code> must be provided when call the created function if the model is a partial proportional odds model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'blrm'
Mean(object, codes = FALSE, posterior.summary = c("mean", "median"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mean.blrm_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+blrm">blrm()</a></code> fit</p>
</td></tr>
<tr><td><code id="Mean.blrm_+3A_codes">codes</code></td>
<td>
<p>if <code>TRUE</code>, use the integer codes <code class="reqn">1,2,\ldots,k</code> for the <code class="reqn">k</code>-level response in computing the predicted mean response.</p>
</td></tr>
<tr><td><code id="Mean.blrm_+3A_posterior.summary">posterior.summary</code></td>
<td>
<p>defaults to posterior mean; may also specify <code>"median"</code>.  Must be consistent with the summary used when creating <code>lp</code>.</p>
</td></tr>
<tr><td><code id="Mean.blrm_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an R function
</p>


<h3>Author(s)</h3>

<p>Frank Harrell
</p>

<hr>
<h2 id='Ocens'>Censored Ordinal Variable</h2><span id='topic+Ocens'></span>

<h3>Description</h3>

<p>Creates a 2-column integer matrix that handles left- right- and interval-censored ordinal or continuous values for use in <code><a href="#topic+blrm">blrm()</a></code>.  A pair of values <code style="white-space: pre;">&#8288;[a, b]&#8288;</code> represents an interval-censored value known to be in the interval <code style="white-space: pre;">&#8288;[a, b]&#8288;</code> inclusive of <code>a</code> and <code>b</code>.  It is assumed that all distinct values are observed as uncensored for at least one observation.  When both input variables are <code>factor</code>s it is assume that the one with the higher number of levels is the one that correctly specifies the order of levels, and that the other variable does not contain any additional levels.  If the variables are not <code>factor</code>s it is assumed their original values provide the orderings.  Since all values that form the left or right endpoints of an interval censored value must be represented in the data, a left-censored point is is coded as <code>a=1</code> and a right-censored point is coded as <code>b</code> equal to the maximum observed value.  If the maximum observed value is not really the maximum possible value, everything still works except that predictions involving values above the highest observed value cannot be made.  As with most censored-data methods, <code><a href="#topic+blrm">blrm()</a></code> assumes that censoring is independent of the response variable values that would have been measured had censoring not occurred.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ocens(a, b = a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ocens_+3A_a">a</code></td>
<td>
<p>vector representing a <code>factor</code>, numeric, or alphabetically ordered character strings</p>
</td></tr>
<tr><td><code id="Ocens_+3A_b">b</code></td>
<td>
<p>like <code>a</code>.  If omitted, it copies <code>a</code>, representing nothing but uncensored values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 2-column integer matrix of class <code>"Ocens"</code> with an attribute <code>levels</code> (ordered).  When the original variables were <code>factor</code>s, these are factor levels, otherwise are numerically or alphabetically sorted distinct (over <code>a</code> and <code>b</code> combined) values.  When the variables are not factors and are numeric, another attribute <code>median</code> is also returned.  This is the median of the uncensored values.  When the variables are factor or character, the median of the integer versions of variables for uncensored observations is returned as attribute <code>mid</code>.  A final attribute <code>freq</code> is the vector of frequencies of occurrences of all uncensored values.  <code>freq</code> aligns with <code>levels</code>.
</p>


<h3>Author(s)</h3>

<p>Frank Harrell
</p>

<hr>
<h2 id='pdensityContour'>Bivariate Posterior Contour</h2><span id='topic+pdensityContour'></span>

<h3>Description</h3>

<p>Computes coordinates of a highest density contour containing a given probability volume given a sample from a continuous bivariate distribution, and optionally plots.  The default method assumes an elliptical shape, but one can optionally use a kernel density estimator.
Code adapted from <code>embbook::HPDregionplot</code>.  See <a href="https://www.sumsar.net/blog/2014/11/how-to-summarize-a-2d-posterior-using-a-highest-density-ellipse/">https://www.sumsar.net/blog/2014/11/how-to-summarize-a-2d-posterior-using-a-highest-density-ellipse/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdensityContour(
  x,
  y,
  method = c("ellipse", "kernel"),
  prob = 0.95,
  otherprob = c(0.01, 0.1, 0.25, 0.5, 0.75, 0.9),
  h = c(1.3 * MASS::bandwidth.nrd(x), 1.3 * MASS::bandwidth.nrd(y)),
  n = 70,
  pl = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdensityContour_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="pdensityContour_+3A_y">y</code></td>
<td>
<p>a numeric vector the same length of x</p>
</td></tr>
<tr><td><code id="pdensityContour_+3A_method">method</code></td>
<td>
<p>defaults to <code>'ellipse'</code>, can be set to <code>'kernel'</code></p>
</td></tr>
<tr><td><code id="pdensityContour_+3A_prob">prob</code></td>
<td>
<p>main probability coverage (the only one for <code>method='ellipse'</code>)</p>
</td></tr>
<tr><td><code id="pdensityContour_+3A_otherprob">otherprob</code></td>
<td>
<p>vector of other probability coverages for <code>method='kernel'</code></p>
</td></tr>
<tr><td><code id="pdensityContour_+3A_h">h</code></td>
<td>
<p>vector of bandwidths for x and y.  See <code><a href="MASS.html#topic+kde2d">MASS::kde2d()</a></code>.</p>
</td></tr>
<tr><td><code id="pdensityContour_+3A_n">n</code></td>
<td>
<p>number of grid points in each direction, defaulting to normal reference bandwidth (see <code>bandwidth.nrd</code>).</p>
</td></tr>
<tr><td><code id="pdensityContour_+3A_pl">pl</code></td>
<td>
<p>set to <code>TRUE</code> to plot contours</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 2-column matrix with x and y coordinates unless <code>pl=TRUE</code> in which case a <code>ggplot2</code> graphic is returned
</p>


<h3>Author(s)</h3>

<p>Ben Bolker and Frank Harrell
</p>

<hr>
<h2 id='plot.PostF'>Plot Posterior Density of <code>PostF</code></h2><span id='topic+plot.PostF'></span>

<h3>Description</h3>

<p>Computes highest posterior density and posterior mean and median as vertical lines, and plots these on the density function.  You can transform the posterior draws while plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PostF'
plot(
  x,
  ...,
  cint = 0.95,
  label = NULL,
  type = c("linetype", "facet"),
  ltitle = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PostF_+3A_x">x</code></td>
<td>
<p>result of running a function created by <code>PostF</code></p>
</td></tr>
<tr><td><code id="plot.PostF_+3A_...">...</code></td>
<td>
<p>other results created by such functions</p>
</td></tr>
<tr><td><code id="plot.PostF_+3A_cint">cint</code></td>
<td>
<p>interval probability</p>
</td></tr>
<tr><td><code id="plot.PostF_+3A_label">label</code></td>
<td>
<p>x-axis label if not the expression originally evaluated.  When more than one result is plotted, <code>label</code> is a vector of character strings, one for each result.</p>
</td></tr>
<tr><td><code id="plot.PostF_+3A_type">type</code></td>
<td>
<p>when plotting more than one result specifies whether to make one plot distinguishing results by line type, or whether to make separate panels</p>
</td></tr>
<tr><td><code id="plot.PostF_+3A_ltitle">ltitle</code></td>
<td>
<p>used of <code>type='linetype'</code> to specify name of legend for the line types</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ggplot2</code> object
</p>


<h3>Author(s)</h3>

<p>Frank Harrell
</p>

<hr>
<h2 id='plot.rmsb'>Plot Posterior Densities and Summaries</h2><span id='topic+plot.rmsb'></span>

<h3>Description</h3>

<p>For an <code>rms</code> Bayesian fit object, plots posterior densities for selected parameters along with posterior mode, mean, median, and highest posterior density interval.  If the fit was produced by <code>stackMI</code> the density represents the distribution after stacking the posterior draws over imputations, and the per-imputation density is also drawn as pale curves.  If exactly two parameters are being plotted and <code>bivar=TRUE</code>, hightest bivariate posterior density contrours are plotted instead, for a variety of <code>prob</code> values including the one specified, using
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rmsb'
plot(
  x,
  which = NULL,
  nrow = NULL,
  ncol = NULL,
  prob = 0.95,
  bivar = FALSE,
  bivarmethod = c("ellipse", "kernel"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.rmsb_+3A_x">x</code></td>
<td>
<p>an <code>rms</code> Bayesian fit object</p>
</td></tr>
<tr><td><code id="plot.rmsb_+3A_which">which</code></td>
<td>
<p>names of parameters to plot, defaulting to all non-intercepts. Can instead be a vector of integers.</p>
</td></tr>
<tr><td><code id="plot.rmsb_+3A_nrow">nrow</code></td>
<td>
<p>number of rows of plots</p>
</td></tr>
<tr><td><code id="plot.rmsb_+3A_ncol">ncol</code></td>
<td>
<p>number of columns of plots</p>
</td></tr>
<tr><td><code id="plot.rmsb_+3A_prob">prob</code></td>
<td>
<p>probability for HPD interval</p>
</td></tr>
<tr><td><code id="plot.rmsb_+3A_bivar">bivar</code></td>
<td>
<p>set to <code>TRUE</code> to plot bivariate density contours instead of univariate results (ignored if the number of parameters plotted is not exactly two)</p>
</td></tr>
<tr><td><code id="plot.rmsb_+3A_bivarmethod">bivarmethod</code></td>
<td>
<p>passed as <code>method</code> argument to <code>pdensityContour</code></p>
</td></tr>
<tr><td><code id="plot.rmsb_+3A_...">...</code></td>
<td>
<p>passed to <code>pdensityContour</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ggplot2</code> object
</p>


<h3>Author(s)</h3>

<p>Frank Harrell
</p>

<hr>
<h2 id='PostF'>Function Generator for Posterior Probabilities of Assertions</h2><span id='topic+PostF'></span>

<h3>Description</h3>

<p>From a Bayesian fit object such as that from <code><a href="#topic+blrm">blrm()</a></code> generates an R function for evaluating the probability that an assertion is true.  The probability, within simulation error, is the proportion of times the assertion is true over the posterior draws.  If the assertion does not evaluate to a logical or 0/1 quantity, it is taken as a continuous derived parameter and the vector of draws for that parameter is returned and can be passed to the <code>PostF</code> plot method.  <code>PostF</code> can also be used on objects created by <code>contrast.rms</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PostF(fit, name = c("short", "orig"), pr = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PostF_+3A_fit">fit</code></td>
<td>
<p>a Bayesian fit or <code>contrast.rms</code> object</p>
</td></tr>
<tr><td><code id="PostF_+3A_name">name</code></td>
<td>
<p>specifies whether assertions will refer to shortened parameter names (the default) or original names.  Shorted names are of the form <code style="white-space: pre;">&#8288;a1, ..., ak&#8288;</code> where <code>k</code> is the number of intercepts in the model, and <code style="white-space: pre;">&#8288;b1, ..., bp&#8288;</code> where <code>p</code> is the number of non-intercepts.  When using original names that are not legal R variable names, you must enclose them in backticks.  For <code>contrast</code> objects, <code>name</code> is ignored and you must use contrast names.  The <code>cnames</code> argument to <code>contrast.rms</code> is handy for assigning your own names.</p>
</td></tr>
<tr><td><code id="PostF_+3A_pr">pr</code></td>
<td>
<p>set to <code>TRUE</code> to have a table of short names and original names printed when <code>name='short'</code>.  For <code>contrasts</code> the contrast names are printed if <code>pr=TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an R function
</p>


<h3>Author(s)</h3>

<p>Frank Harrell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  f &lt;- blrm(y ~ age + sex)
  P &lt;- PostF(f)
  P(b2 &gt; 0)     # Model is a1 + b1*age + b2*(sex == 'male')
  P(b1 &lt; 0 &amp; b2 &gt; 0)   # Post prob of a compound assertion
  # To compute probabilities using original parameter names:
  P &lt;- PostF(f, name='orig')
  P(age &lt; 0)    # Post prob of negative age effect
  P(`sex=male` &gt; 0)
  f &lt;- blrm(y ~ sex + pol(age, 2))
  P &lt;- PostF(f)
  # Compute and plot posterior density of the vertex of the
  # quadratic age effect
  plot(P(-b2 / (2 * b3)))

  # The following would be useful in age and sex interacted
  k &lt;- contrast(f, list(age=c(30, 50), sex='male'),
                   list(age=c(30, 50), sex='female'),
                cnames=c('age 30 M-F', 'age 50 M-F'))
  P &lt;- PostF(k)
  P(`age 30 M-F` &gt; 0 &amp; `age 50 M-F` &gt; 0)
##' 
## End(Not run)
</code></pre>

<hr>
<h2 id='predict.blrm'>Make predictions from a <code><a href="#topic+blrm">blrm()</a></code> fit</h2><span id='topic+predict.blrm'></span>

<h3>Description</h3>

<p>Predict method for <code><a href="#topic+blrm">blrm()</a></code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'blrm'
predict(
  object,
  ...,
  kint = NULL,
  ycut = NULL,
  zcppo = TRUE,
  Zmatrix = TRUE,
  fun = NULL,
  funint = TRUE,
  type = c("lp", "fitted", "fitted.ind", "mean", "x", "data.frame", "terms", "cterms",
    "ccterms", "adjto", "adjto.data.frame", "model.frame"),
  se.fit = FALSE,
  codes = FALSE,
  posterior.summary = c("mean", "median", "all"),
  cint = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.blrm_+3A_object">object</code>, <code id="predict.blrm_+3A_...">...</code>, <code id="predict.blrm_+3A_type">type</code>, <code id="predict.blrm_+3A_se.fit">se.fit</code>, <code id="predict.blrm_+3A_codes">codes</code></td>
<td>
<p>see <code>predict.lrm()</code></p>
</td></tr>
<tr><td><code id="predict.blrm_+3A_kint">kint</code></td>
<td>
<p>This is only useful in a multiple intercept model such as the ordinal    logistic model. There to use to second of three intercepts, for example,    specify <code>kint=2</code>. The default is the middle    intercept corresponding to the median <code>y</code>.  You can specify <code>ycut</code> instead, and the intercept    corresponding to Y &gt;= <code>ycut</code> will be used for <code>kint</code>.</p>
</td></tr>
<tr><td><code id="predict.blrm_+3A_ycut">ycut</code></td>
<td>
<p>for an ordinal model specifies the Y cutoff to use in evaluating departures from proportional odds, when the constrained partial proportional odds model is used.  When omitted, <code>ycut</code>    is implied by <code>kint</code>.  The only time it is absolutely mandatory    to specify <code>ycut</code> is when computing an effect (e.g., odds ratio) at a level of the response variable that did not occur in the data.    This would only occur when the <code>cppo</code> function given to    <code>blrm</code> is a continuous function.  If <code>type='x'</code> and neither <code>kint</code> nor <code>ycut</code> are given, the partial PO part of the design matrix is not multiplied by the <code>cppo</code> function.  If <code>type='x'</code>, the number of predicted observations is 1, <code>ycut</code> is longer than 1, and <code>zcppo</code> is <code>TRUE</code>, predictions are duplicated to the length of <code>ycut</code> as it is assumed that the user wants to see the effect of varying <code>ycut</code>, e.g., to see cutoff-specific odds ratios.</p>
</td></tr>
<tr><td><code id="predict.blrm_+3A_zcppo">zcppo</code></td>
<td>
<p>applies only to <code>type='x'</code> for a constrained partial PO model.  Set to <code>FALSE</code> to prevent multiplication of Z matrix by <code>cppo(ycut)</code>.</p>
</td></tr>
<tr><td><code id="predict.blrm_+3A_zmatrix">Zmatrix</code></td>
<td>
<p>set to <code>FALSE</code> to exclude the partial PO Z matrix from the returned design matrix if <code>type='x'</code></p>
</td></tr>
<tr><td><code id="predict.blrm_+3A_fun">fun</code></td>
<td>
<p>a function to evaluate on the linear predictor, e.g. a function created by <code><a href="Hmisc.html#topic+Mean">Mean()</a></code> or <code><a href="Hmisc.html#topic+Quantile">Quantile()</a></code></p>
</td></tr>
<tr><td><code id="predict.blrm_+3A_funint">funint</code></td>
<td>
<p>set to <code>FALSE</code> if <code>fun</code> is not a function such as the result of <code><a href="Hmisc.html#topic+Mean">Mean()</a></code>, <code><a href="Hmisc.html#topic+Quantile">Quantile()</a></code>, or <code>ExProb()</code> that    contains an <code>intercepts</code> argument</p>
</td></tr>
<tr><td><code id="predict.blrm_+3A_posterior.summary">posterior.summary</code></td>
<td>
<p>set to <code>'median'</code> or <code>'mode'</code> to use posterior median/mode instead of mean. For some <code>type</code>s set to <code>'all'</code> to compute the needed quantity for all posterior draws, and return one more dimension in the array.</p>
</td></tr>
<tr><td><code id="predict.blrm_+3A_cint">cint</code></td>
<td>
<p>probability for highest posterior density interval.  Set to <code>FALSE</code> to suppress calculation of the interval.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame,  matrix, or vector with posterior summaries for the requested quantity, plus an attribute <code>'draws'</code> that has all the posterior draws for that quantity.  For <code>type='fitted'</code> and <code>type='fitted.ind'</code> this attribute is a 3-dimensional array representing draws x observations generating predictions x levels of Y.
</p>


<h3>Author(s)</h3>

<p>Frank Harrell
</p>


<h3>See Also</h3>

<p><code>predict.lrm()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  f &lt;- blrm(...)
  predict(f, newdata, type='...', posterior.summary='median')

## End(Not run)
</code></pre>

<hr>
<h2 id='print.blrm'>Print <code><a href="#topic+blrm">blrm()</a></code> Results</h2><span id='topic+print.blrm'></span>

<h3>Description</h3>

<p>Prints main results from <code><a href="#topic+blrm">blrm()</a></code> along with indexes and predictive accuracy and their highest posterior density intervals computed from <code>blrmStats</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'blrm'
print(
  x,
  dec = 4,
  coefs = TRUE,
  intercepts = x$non.slopes &lt; 10,
  prob = 0.95,
  ns = 400,
  title = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.blrm_+3A_x">x</code></td>
<td>
<p>object created by <code><a href="#topic+blrm">blrm()</a></code></p>
</td></tr>
<tr><td><code id="print.blrm_+3A_dec">dec</code></td>
<td>
<p>number of digits to print to the right of the decimal</p>
</td></tr>
<tr><td><code id="print.blrm_+3A_coefs">coefs</code></td>
<td>
<p>specify <code>FALSE</code> to suppress printing parameter estimates, and in integer k to print only the first k</p>
</td></tr>
<tr><td><code id="print.blrm_+3A_intercepts">intercepts</code></td>
<td>
<p>set to <code>FALSE</code> to suppress printing intercepts.   Default is to print them unless there are more than 9.</p>
</td></tr>
<tr><td><code id="print.blrm_+3A_prob">prob</code></td>
<td>
<p>HPD interval probability for summary indexes</p>
</td></tr>
<tr><td><code id="print.blrm_+3A_ns">ns</code></td>
<td>
<p>number of random samples of the posterior draws for use in computing HPD intervals for accuracy indexes</p>
</td></tr>
<tr><td><code id="print.blrm_+3A_title">title</code></td>
<td>
<p>title of output, constructed by default</p>
</td></tr>
<tr><td><code id="print.blrm_+3A_...">...</code></td>
<td>
<p>passed to <code>prModFit</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frank Harrell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  f &lt;- blrm(...)
  options(lang='html')   # default is lang='plain'; also can be latex
  f               # print using defaults
  print(f, posterior.summary='median')   # instead of post. means

## End(Not run)
</code></pre>

<hr>
<h2 id='print.blrmStats'>Print Details for <code>blrmStats</code> Predictive Accuracy Measures</h2><span id='topic+print.blrmStats'></span>

<h3>Description</h3>

<p>Prints results of <code>blrmStats</code> with brief explanations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'blrmStats'
print(x, dec = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.blrmStats_+3A_x">x</code></td>
<td>
<p>an object produced by <code>blrmStats</code></p>
</td></tr>
<tr><td><code id="print.blrmStats_+3A_dec">dec</code></td>
<td>
<p>number of digits to round indexes</p>
</td></tr>
<tr><td><code id="print.blrmStats_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frank Harrell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  f &lt;- blrm(...)
  s &lt;- blrmStats(...)
  s    # print with defaults
  print(s, dec=4)

## End(Not run)
</code></pre>

<hr>
<h2 id='print.predict.blrm'>Print Predictions for <code><a href="#topic+blrm">blrm()</a></code></h2><span id='topic+print.predict.blrm'></span>

<h3>Description</h3>

<p>Prints the summary portion of the results of <code>predict.blrm</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predict.blrm'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.predict.blrm_+3A_x">x</code></td>
<td>
<p>result from <code>predict.blrm</code></p>
</td></tr>
<tr><td><code id="print.predict.blrm_+3A_digits">digits</code></td>
<td>
<p>number of digits to round numeric results</p>
</td></tr>
<tr><td><code id="print.predict.blrm_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frank Harrell
</p>

<hr>
<h2 id='print.rmsb'>Basic Print for Bayesian Parameter Summary</h2><span id='topic+print.rmsb'></span>

<h3>Description</h3>

<p>For a Bayesian regression fit prints the posterior mean, median, SE, highest posterior density interval, and symmetry coefficient from the posterior draws.  For a given parameter, the symmetry measure is computed using the <code>distSym</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rmsb'
print(x, prob = 0.95, dec = 4, intercepts = TRUE, pr = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.rmsb_+3A_x">x</code></td>
<td>
<p>an object created by an <code>rms</code> Bayesian fitting function</p>
</td></tr>
<tr><td><code id="print.rmsb_+3A_prob">prob</code></td>
<td>
<p>HPD interval coverage probability (default is 0.95)</p>
</td></tr>
<tr><td><code id="print.rmsb_+3A_dec">dec</code></td>
<td>
<p>amount of rounding (digits to the right of the decimal)</p>
</td></tr>
<tr><td><code id="print.rmsb_+3A_intercepts">intercepts</code></td>
<td>
<p>set to <code>FALSE</code> to not print intercepts</p>
</td></tr>
<tr><td><code id="print.rmsb_+3A_pr">pr</code></td>
<td>
<p>set to <code>FALSE</code> to return an unrounded matrix and not print</p>
</td></tr>
<tr><td><code id="print.rmsb_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix (rounded if <code>pr=TRUE</code>)
</p>


<h3>Author(s)</h3>

<p>Frank Harrell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  f &lt;- blrm(...)
  print.rmsb(f)

## End(Not run)
</code></pre>

<hr>
<h2 id='Quantile.blrm'>Function Generator for Quantiles of Y for <code><a href="#topic+blrm">blrm()</a></code></h2><span id='topic+Quantile.blrm'></span>

<h3>Description</h3>

<p>Creates a function to turn a posterior summarized linear predictor lp (e.g. using posterior mean of intercepts and slopes) computed at the reference intercept into e.g. an estimate of a quantile of Y using the posterior mean of all the intercepts.  <code>lptau</code> must be provided when call the created function if the model is a partial proportional odds model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'blrm'
Quantile(object, codes = FALSE, posterior.summary = c("mean", "median"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Quantile.blrm_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+blrm">blrm()</a></code> fit</p>
</td></tr>
<tr><td><code id="Quantile.blrm_+3A_codes">codes</code></td>
<td>
<p>if <code>TRUE</code>, use the integer codes <code class="reqn">1,2,\ldots,k</code> for the <code class="reqn">k</code>-level response in computing the quantile</p>
</td></tr>
<tr><td><code id="Quantile.blrm_+3A_posterior.summary">posterior.summary</code></td>
<td>
<p>defaults to posterior mean; may also specify <code>"median"</code>.  Must be consistent with the summary used when creating <code>lp</code>.</p>
</td></tr>
<tr><td><code id="Quantile.blrm_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an R function
</p>


<h3>Author(s)</h3>

<p>Frank Harrell
</p>

<hr>
<h2 id='rmsb-package'>The 'rmsb' package.</h2><span id='topic+rmsb-package'></span><span id='topic+rmsb'></span>

<h3>Description</h3>

<p>Regression Modeling Strategies Bayesian
</p>
<p>The <span class="pkg">rmsb</span> package is an appendage to the <span class="pkg">rms</span> package that
implements Bayesian regression models whose fit objects can be processed
by <span class="pkg">rms</span> functions such as <code>contrast, summary, Predict, nomogram</code>,
and <code>latex</code>.  The fitting function
currently implemented in the package is <code>blrm</code> for Bayesian logistic
binary and ordinal regression with optional clustering, censoring, and
departures from the proportional odds assumption using the partial
proportional odds model of Peterson and Harrell (1990).
</p>


<h3>References</h3>

<p>Stan Development Team (2020). RStan: the R interface to Stan. R package version 2.19.3. https://mc-stan.org
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="https://hbiostat.org/R/rmsb/">https://hbiostat.org/R/rmsb/</a> for the package's main web page
</p>
</li>
<li> <p><a href="https://hbiostat.org/R/examples/blrm/blrm.html">https://hbiostat.org/R/examples/blrm/blrm.html</a> for a vignette with
many examples of using the <code>blrm</code> function
</p>
</li></ul>


<hr>
<h2 id='selectedQr'>QR Decomposition Preserving Selected Columns</h2><span id='topic+selectedQr'></span>

<h3>Description</h3>

<p>Runs a matrix through the QR decomposition and returns the transformed matrix and the forward and inverse transforming matrices <code style="white-space: pre;">&#8288;R, Rinv&#8288;</code>.  If columns of the input matrix <code>X</code> are centered the QR transformed matrix will be orthogonal.  This is helpful in understanding the transformation and in scaling prior distributions on the transformed scale.  <code>not</code> can be specified to keep selected columns as-is.  <code>cornerQr</code> leaves the last column of <code>X</code> alone (possibly after centering).  When <code>not</code> is specified, the square transforming matrices have appropriate identity submatrices inserted so that recreation of original <code>X</code> is automatic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectedQr(X, not = NULL, corner = FALSE, center = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectedQr_+3A_x">X</code></td>
<td>
<p>a numeric matrix</p>
</td></tr>
<tr><td><code id="selectedQr_+3A_not">not</code></td>
<td>
<p>an integer vector specifying which columns of <code>X</code> are to be kept with their original values</p>
</td></tr>
<tr><td><code id="selectedQr_+3A_corner">corner</code></td>
<td>
<p>set to <code>FALSE</code> to not treat the last column specially.  You may not specify both <code>not</code> and <code>corner</code>.</p>
</td></tr>
<tr><td><code id="selectedQr_+3A_center">center</code></td>
<td>
<p>set to <code>FALSE</code> to not center columns of <code>X</code> first</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with elements <code style="white-space: pre;">&#8288;X, R, Rinv, xbar&#8288;</code> where <code>xbar</code> is the vector of means (vector of zeros if <code>center=FALSE</code>)
</p>


<h3>Author(s)</h3>

<p>Ben Goodrich and Frank Harrell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- 1 : 10
  X &lt;- cbind(x, x^2)
  w &lt;- selectedQr(X)
  w
  with(w, X %*% R)  # = scale(X, center=TRUE, scale=FALSE)
  Xqr &lt;- w$X
  plot(X[, 1], Xqr[, 1])
  plot(X[, 1], Xqr[, 2])
  cov(X)
  cov(Xqr)
  X &lt;- cbind(x, x^3, x^4, x^2)
  w &lt;- selectedQr(X, not=2:3)
  with(w, X %*% R)
</code></pre>

<hr>
<h2 id='stackMI'>Bayesian Model Fitting and Stacking for Multiple Imputation</h2><span id='topic+stackMI'></span>

<h3>Description</h3>

<p>Runs an <code>rmsb</code> package Bayesian fitting function such as <code>blrm</code> separately for each completed dataset given a multiple imputation result such as one produced by <code>Hmisc::aregImpute</code>.  Stacks the posterior draws and diagnostics across all imputations, and computes parameter summaries on the stacked posterior draws.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stackMI(
  formula,
  fitter,
  xtrans,
  data = NULL,
  n.impute = xtrans$n.impute,
  dtrans = NULL,
  derived = NULL,
  subset = NULL,
  refresh = 0,
  progress = if (refresh &gt; 0) "stan-progress.txt" else "",
  file = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stackMI_+3A_formula">formula</code></td>
<td>
<p>a model formula</p>
</td></tr>
<tr><td><code id="stackMI_+3A_fitter">fitter</code></td>
<td>
<p>a Bayesian fitter</p>
</td></tr>
<tr><td><code id="stackMI_+3A_xtrans">xtrans</code></td>
<td>
<p>an object created by <code>transcan</code>, <code><a href="Hmisc.html#topic+aregImpute">aregImpute</a></code>, or <code><a href="mice.html#topic+mice">mice</a></code></p>
</td></tr>
<tr><td><code id="stackMI_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="stackMI_+3A_n.impute">n.impute</code></td>
<td>
<p>number of imputations to run, default is the number saved in <code>xtrans</code></p>
</td></tr>
<tr><td><code id="stackMI_+3A_dtrans">dtrans</code></td>
<td>
<p>see <code>Hmisc::fit.mult.impute</code></p>
</td></tr>
<tr><td><code id="stackMI_+3A_derived">derived</code></td>
<td>
<p>see <code>Hmisc::fit.mult.impute</code></p>
</td></tr>
<tr><td><code id="stackMI_+3A_subset">subset</code></td>
<td>
<p>an integer or logical vector specifying the subset of observations to fit</p>
</td></tr>
<tr><td><code id="stackMI_+3A_refresh">refresh</code></td>
<td>
<p>see <a href="rstan.html#topic+stanmodel-method-sampling">rstan::sampling</a>.  The default is 0, indicating that no progress notes are output.  If <code>refresh &gt; 0</code> and <code>progress</code> is not <code>''</code>, progress output will be appended to file <code>progress</code>.  The default file name is <code>'stan-progress.txt'</code>.</p>
</td></tr>
<tr><td><code id="stackMI_+3A_progress">progress</code></td>
<td>
<p>see <code>refresh</code>.  Defaults to <code>''</code> if <code>refresh = 0</code>.  Note: If running interactively but not under RStudio, <code>rstan</code> will open a browser window for monitoring progress.</p>
</td></tr>
<tr><td><code id="stackMI_+3A_file">file</code></td>
<td>
<p>optional file name in which to store results in RDS format.  If <code>file</code> is given and it already exists, and none of the arguments to <code>stackMI</code> have changed since that fit, the fit object from <code>file</code> is immediately returned.  So if the model, data, and imputations have not changed nothing needs to be computed.</p>
</td></tr>
<tr><td><code id="stackMI_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>fitter</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>rmsb</code> fit object with expanded posterior draws and diagnostics
</p>


<h3>Author(s)</h3>

<p>Frank Harrell
</p>

<hr>
<h2 id='stanDx'>Print Stan Diagnostics</h2><span id='topic+stanDx'></span>

<h3>Description</h3>

<p>Retrieves the effect samples sizes and Rhats computed after a fitting function ran <code>rstan</code>, and prepares it for printing.  If the fit was created by <code>stackImpute</code>, the diagnostics for all imputations are printed (separately).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stanDx(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stanDx_+3A_object">object</code></td>
<td>
<p>an object created by an <code>rms</code> package Bayesian fitting function such as <code><a href="#topic+blrm">blrm()</a></code> or <code><a href="#topic+stackMI">stackMI()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix suitable for printing
</p>


<h3>Author(s)</h3>

<p>Frank Harrell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  f &lt;- blrm(...)
  stanDx(f)

## End(Not run)
</code></pre>

<hr>
<h2 id='stanDxplot'>Diagnostic Trace Plots</h2><span id='topic+stanDxplot'></span>

<h3>Description</h3>

<p>For an <code>rms</code> Bayesian fit object, uses by default the stored posterior draws to check convergence properties of posterior sampling.  If instead <code>rstan=TRUE</code>, calls the <code>rstan</code> <code>traceplot</code> function on the <code>rstan</code> object inside the <code>rmsb</code> object, to check properties of posterior sampling.  If <code>rstan=TRUE</code> and the <code>rstan</code> object has been removed and <code>previous=TRUE</code>, attempts to find an already existing plot created by a previous run of the <code>knitr</code> chunk, assuming it was the <code>plotno</code> numbered plot of the chunk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stanDxplot(
  x,
  which = NULL,
  rstan = FALSE,
  previous = TRUE,
  plotno = 1,
  rev = FALSE,
  stripsize = 8,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stanDxplot_+3A_x">x</code></td>
<td>
<p>an <code>rms</code> Bayesian fit object</p>
</td></tr>
<tr><td><code id="stanDxplot_+3A_which">which</code></td>
<td>
<p>names of parameters to plot, defaulting to all non-intercepts.  When <code>rstan=FALSE</code> these are the friendly <code>rms</code> names, otherwise they are the <code>rstan</code> parameter names.  If the model fit was run through <code>stackMI</code> for multiple imputation, the number of traces is multiplied by the number of imputations.  Set to <code>'ALL'</code> to plot all parameters.</p>
</td></tr>
<tr><td><code id="stanDxplot_+3A_rstan">rstan</code></td>
<td>
<p>set to <code>TRUE</code> to use <code><a href="rstan.html#topic+stanfit-method-traceplot">rstan::traceplot()</a></code> on a (presumed) stored <code>rstan</code> object in <code>x</code>, otherwise only real iterations are plotted and parameter values are shown as points instead of lines, with chains separated</p>
</td></tr>
<tr><td><code id="stanDxplot_+3A_previous">previous</code></td>
<td>
<p>see details</p>
</td></tr>
<tr><td><code id="stanDxplot_+3A_plotno">plotno</code></td>
<td>
<p>see details</p>
</td></tr>
<tr><td><code id="stanDxplot_+3A_rev">rev</code></td>
<td>
<p>set to <code>TRUE</code> to reverse direction for faceting chains</p>
</td></tr>
<tr><td><code id="stanDxplot_+3A_stripsize">stripsize</code></td>
<td>
<p>specifies size of chain facet label text, default is 8</p>
</td></tr>
<tr><td><code id="stanDxplot_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="rstan.html#topic+stanfit-method-traceplot">rstan::traceplot()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ggplot2</code> object if <code>rstan</code> object was in <code>x</code>
</p>


<h3>Author(s)</h3>

<p>Frank Harrell
</p>

<hr>
<h2 id='stanGet'>Get Stan Output</h2><span id='topic+stanGet'></span>

<h3>Description</h3>

<p>Extracts the object created by <code><a href="rstan.html#topic+stanmodel-method-sampling">rstan::sampling()</a></code> so that standard Stan diagnostics can be run from it
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stanGet(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stanGet_+3A_object">object</code></td>
<td>
<p>an objected created by an <code>rms</code> package Bayesian fitting function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the object created by <code><a href="rstan.html#topic+stanmodel-method-sampling">rstan::sampling()</a></code>
</p>


<h3>Author(s)</h3>

<p>Frank Harrell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  f &lt;- blrm(...)
  s &lt;- stanGet(f)

## End(Not run)
</code></pre>

<hr>
<h2 id='tauFetch'>Fetch Partial Proportional Odds Parameters</h2><span id='topic+tauFetch'></span>

<h3>Description</h3>

<p>Fetches matrix of posterior draws for partial proportional odds parameters (taus) for a given intercept.  Can also form a matrix containing both regular parameters and taus, or for just non-taus.  For the constrained partial proportional odds model the function returns the appropriate <code>cppo</code> function value multiplied by tau (tau being a vector in this case and not a matrix).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tauFetch(fit, intercept, what = c("tau", "nontau", "both"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tauFetch_+3A_fit">fit</code></td>
<td>
<p>an object created by <code><a href="#topic+blrm">blrm()</a></code></p>
</td></tr>
<tr><td><code id="tauFetch_+3A_intercept">intercept</code></td>
<td>
<p>integer specifying which intercept to fetch</p>
</td></tr>
<tr><td><code id="tauFetch_+3A_what">what</code></td>
<td>
<p>specifies the result to return</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with number of raws equal to the numnber of original draws
</p>


<h3>Author(s)</h3>

<p>Frank Harrell
</p>

<hr>
<h2 id='vcov.rmsb'>Variance-Covariance Matrix</h2><span id='topic+vcov.rmsb'></span>

<h3>Description</h3>

<p>Computes the variance-covariance matrix from the posterior draws by compute the sample covariance matrix of the draws
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rmsb'
vcov(object, regcoef.only = TRUE, intercepts = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.rmsb_+3A_object">object</code></td>
<td>
<p>an object produced by an <code>rms</code> package Bayesian fitting function</p>
</td></tr>
<tr><td><code id="vcov.rmsb_+3A_regcoef.only">regcoef.only</code></td>
<td>
<p>set to <code>FALSE</code> to also include non-regression coefficients such as shape/scale parameters</p>
</td></tr>
<tr><td><code id="vcov.rmsb_+3A_intercepts">intercepts</code></td>
<td>
<p>set to <code>'all'</code> to include all intercepts (the default), <code>'none'</code> to exclude them all, or a vector of integers to get selected intercepts</p>
</td></tr>
<tr><td><code id="vcov.rmsb_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>


<h3>Author(s)</h3>

<p>Frank Harrell
</p>


<h3>See Also</h3>

<p>vcov.rms
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  f &lt;- blrm(...)
  v &lt;- vcov(f)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
