<!DOCTYPE html><html lang="en"><head><title>Help for package haplo.stats</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {haplo.stats}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anova.haplo.glm'>
<p>Analysis of variance for haplo.glm model fit</p></a></li>
<li><a href='#chisq.power'>
<p>Power and sample size for the chi-square distribution</p></a></li>
<li><a href='#dglm.fit'>
<p>Internal functions for the HaploStats package.  See the help file for</p>
the main functions (haplo.em, haplo.score, haplo.glm) for details on
some of these functions.</a></li>
<li><a href='#f.power'>
<p>Power and sample size for the F distribution</p></a></li>
<li><a href='#find.haplo.beta.qt'>
<p>Find beta coefficients for risk haplotypes, for specified r2</p></a></li>
<li><a href='#fitted.haplo.glm'>
<p>Fitted values from haplo.glm fit</p></a></li>
<li><a href='#geno.count.pairs'>
<p>Counts of Total Haplotype Pairs Produced by Genotypes</p></a></li>
<li><a href='#geno1to2'>
<p>convert genotype matrix from 1-column 2-column</p></a></li>
<li><a href='#get.hapPair'>
<p>Get a list of objects for haplotype pairs</p></a></li>
<li><a href='#Ginv'>
<p>Compute Generalized Inverse of Input Matrix</p></a></li>
<li><a href='#haplo.cc'>
<p>Haplotype Association Analysis in a Case-Control design</p></a></li>
<li><a href='#haplo.design'>
<p>Build a design matrix for haplotypes</p></a></li>
<li><a href='#haplo.em'>
<p>EM Computation of Haplotype Probabilities, with Progressive Insertion</p>
of Loci</a></li>
<li><a href='#haplo.em.control'>
<p>Create the Control Parameters for the EM Computation of Haplotype</p>
Probabilities, with Progressive Insertion of Loci</a></li>
<li><a href='#haplo.em.fitter'>
<p>Compute engine for haplotype EM algorithm</p></a></li>
<li><a href='#haplo.glm'>
<p>GLM Regression of Trait on Ambiguous Haplotypes</p></a></li>
<li><a href='#haplo.glm.control'>
<p>Create list of control parameters for haplo.glm</p></a></li>
<li><a href='#haplo.group'>
<p>Frequencies for Haplotypes by Grouping Variable</p></a></li>
<li><a href='#haplo.hash'>
<p>Integer Rank Codes for Haplotypes</p></a></li>
<li><a href='#haplo.model.frame'>
<p>Sets up a model frame for haplo.glm</p></a></li>
<li><a href='#haplo.power.cc'>
<p>Compute either power or sample size for haplotype associations in a</p>
case-control study.</a></li>
<li><a href='#haplo.power.qt'>
<p>Compute either power or sample size for haplotype associations with a</p>
quantitative trait.</a></li>
<li><a href='#haplo.scan'>
<p>Search for a trait-locus by sliding a fixed-width window over each marker locus</p>
and scanning all possible haplotype lengths within the window</a></li>
<li><a href='#haplo.score'>
<p>Score Statistics for Association of Traits with Haplotypes</p></a></li>
<li><a href='#haplo.score.merge'>
<p>Merge haplo.score And haplo.group Objects</p></a></li>
<li><a href='#haplo.score.slide'>
<p>Score Statistics for Association of Traits with Haplotypes</p></a></li>
<li><a href='#hapPower.demo'><p>  Set of haplotypes and frequencies for power and sample size</p>
calculations</a></li>
<li><a href='#hla.demo'><p> HLA Loci and Serologic Response to Measles Vaccination</p></a></li>
<li><a href='#locator.haplo'>
<p>Find Location from Mouse Clicks and Print Haplotypes on Plot</p></a></li>
<li><a href='#locus'>
<p>Creates an object of class &quot;locus&quot;</p></a></li>
<li><a href='#louis.info'>
<p>Louis Information for haplo.glm</p></a></li>
<li><a href='#na.geno.keep'>
<p>Remove rows with NA in covariates, but keep genotypes with NAs</p></a></li>
<li><a href='#plot.haplo.score'>
<p>Plot Haplotype Frequencies versus Haplotype Score Statistics</p></a></li>
<li><a href='#plot.haplo.score.slide'>
<p>Plot a haplo.score.slide Object</p></a></li>
<li><a href='#plot.seqhap'>
<p>Plot a seqhap object</p></a></li>
<li><a href='#print.haplo.cc'>
<p>Print a haplo.cc object</p></a></li>
<li><a href='#print.haplo.em'>
<p>Print contents of a haplo.em object</p></a></li>
<li><a href='#print.haplo.group'>
<p>Print a haplo.group object</p></a></li>
<li><a href='#print.haplo.scan'>
<p>Print a haplo.scan object</p></a></li>
<li><a href='#print.haplo.score'>
<p>Print a haplo.score object</p></a></li>
<li><a href='#print.haplo.score.merge'>
<p>Print a haplo.score.merge object</p></a></li>
<li><a href='#print.haplo.score.slide'>
<p>Print the contents of a haplo.score.slide object</p></a></li>
<li><a href='#printBanner'>
<p>Print a nice banner</p></a></li>
<li><a href='#residuals.haplo.glm'>
<p>Accessing residuals for haplo.glm fit</p></a></li>
<li><a href='#score.sim.control'>
<p>Create the list of control parameters for simulations in haplo.score</p></a></li>
<li><a href='#seqhap'>
<p>Sequential Haplotype Scan Association Analysis for Case-Control Data</p></a></li>
<li><a href='#seqhap.dat'>
<p>Simulated data for seqhap examples</p></a></li>
<li><a href='#setupGeno'>
<p>Create a group of locus objects from a genotype matrix, assign to</p>
'model.matrix' class.</a></li>
<li><a href='#summary.haplo.em'>
<p>Summarize contents of a haplo.em object</p></a></li>
<li><a href='#summary.haplo.glm'>
<p>Print and summary of a haplo.glm object</p></a></li>
<li><a href='#summaryGeno'>
<p>Summarize Full Haplotype Enumeration on Genotype Matrix</p></a></li>
<li><a href='#vcov.haplo.glm'><p>variance-covariance matrix of a fitted haplo.glm object</p></a></li>
<li><a href='#x.sexcheck'>
<p>consistency checks for x.linked locus</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.9.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-09-19</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Analysis of Haplotypes with Traits and Covariates
when Linkage Phase is Ambiguous</td>
</tr>
<tr>
<td>Description:</td>
<td>Routines for the analysis of indirectly measured haplotypes. The statistical methods assume that all subjects are unrelated and that haplotypes are ambiguous (due to unknown linkage phase of the genetic markers). The main functions are: haplo.em(), haplo.glm(), haplo.score(), and haplo.power(); all of which have detailed examples in the vignette.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0), methods, stats, graphics, arsenal</td>
</tr>
<tr>
<td>Imports:</td>
<td>rms</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://analytictools.mayo.edu/research/haplo-stats/">https://analytictools.mayo.edu/research/haplo-stats/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-19 13:46:47 UTC; sinnwell</td>
</tr>
<tr>
<td>Author:</td>
<td>Schaid Daniel [aut],
  Jason P. Sinnwell [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jason P. Sinnwell &lt;sinnwell.jason@mayo.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-19 22:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='anova.haplo.glm'>
Analysis of variance for haplo.glm model fit
</h2><span id='topic+anova.haplo.glm'></span><span id='topic+anova.haplo.glmlist'></span>

<h3>Description</h3>

<p>Perform an analysis of variance between two haplo.glm model fits
using the deviances from the fitted objects 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'haplo.glm'
anova(object, ..., dispersion=NULL, test="Chisq")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anova.haplo.glm_+3A_object">object</code></td>
<td>

<p>A haplo.glm or glm object
</p>
</td></tr>
<tr><td><code id="anova.haplo.glm_+3A_...">...</code></td>
<td>

<p>More model fits to compare against the fit in the first argument
</p>
</td></tr>
<tr><td><code id="anova.haplo.glm_+3A_dispersion">dispersion</code></td>
<td>

<p>the dispersion parameter for the fitting family. By default it is
obtained from the object(s)
</p>
</td></tr>
<tr><td><code id="anova.haplo.glm_+3A_test">test</code></td>
<td>

<p>character string for the test of model comparison. Only &quot;Chisq&quot;
supported for haplo.glm objects
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses print.anova for the displayed result
</p>


<h3>Value</h3>

<p>A data.frame of the anova class, with these columns: Df, Deviance, Resid.Df,
Resid.Dev, p-value
</p>


<h3>See Also</h3>

<p><code><a href="#topic+haplo.glm">haplo.glm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(hla.demo)
 geno &lt;- as.matrix(hla.demo[,c(17,18,21:24)])
 keep &lt;- !apply(is.na(geno) | geno==0, 1, any) # SKIP THESE THREE LINES
 hla.demo &lt;- hla.demo[keep,]                   # IN AN ANALYSIS
 geno &lt;- geno[keep,]                           # 
 attach(hla.demo)
 label &lt;-c("DQB","DRB","B")
 y &lt;- hla.demo$resp
 y.bin &lt;- 1*(hla.demo$resp.cat=="low")

# set up a genotype array as a model.matrix for inserting into data frame
# Note that hla.demo is a data.frame, and we need to subset to columns
# of interest. Also also need to convert to a matrix object, so that
# setupGeno can code alleles and convert geno to 'model.matrix' class.

 geno &lt;- setupGeno(geno, miss.val=c(0,NA))

  # geno now has an attribute 'unique.alleles' which must be passed to
  # haplo.glm as allele.lev=attributes(geno)$unique.alleles, see below

 my.data &lt;- data.frame(geno=geno, age=hla.demo$age, male=hla.demo$male,
                        y=y, y.bin=y.bin)


 fit.gaus &lt;- haplo.glm(y ~ male + geno, family = gaussian,  na.action=
               "na.geno.keep", data=my.data, locus.label=label,
               control = haplo.glm.control(haplo.freq.min=0.02))
 glmfit.gaus &lt;- glm(y~male, family=gaussian, data=my.data)

 anova.haplo.glm(glmfit.gaus, fit.gaus)

</code></pre>

<hr>
<h2 id='chisq.power'>
Power and sample size for the chi-square distribution
</h2><span id='topic+chisq.power'></span><span id='topic+chisq.power.dif'></span><span id='topic+chisq.sample.size'></span>

<h3>Description</h3>

<p>Power and sample size for the chi-square distribution given
non-centrality, degrees of freedom, alpha, N (for chisq.power), and
power (for chisq.sample.size) 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chisq.power(n, nc, df, alpha)
chisq.power.dif(n, nc, df, alpha, power)
chisq.sample.size(nc, df=df, alpha, power, lower=20, upper=100000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chisq.power_+3A_n">n</code></td>
<td>

<p>sample size (for power)
</p>
</td></tr>
<tr><td><code id="chisq.power_+3A_nc">nc</code></td>
<td>

<p>non-centrality parameter
</p>
</td></tr>
<tr><td><code id="chisq.power_+3A_df">df</code></td>
<td>

<p>degrees of freedom
</p>
</td></tr>
<tr><td><code id="chisq.power_+3A_alpha">alpha</code></td>
<td>

<p>type-I error rate
</p>
</td></tr>
<tr><td><code id="chisq.power_+3A_power">power</code></td>
<td>

<p>desired power (for sample size)
</p>
</td></tr>
<tr><td><code id="chisq.power_+3A_lower">lower</code></td>
<td>

<p>lower bound for search space for sample size
</p>
</td></tr>
<tr><td><code id="chisq.power_+3A_upper">upper</code></td>
<td>

<p>upper bound for search space for sample size
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>power, the difference in power from target power, and sample size,
respectively for the three different functions
</p>

<hr>
<h2 id='dglm.fit'>
Internal functions for the HaploStats package.  See the help file for
the main functions (haplo.em, haplo.score, haplo.glm) for details on
some of these functions. 
</h2><span id='topic+dglm.fit'></span><span id='topic+haplo.chistat'></span><span id='topic+haplo.enum'></span><span id='topic+haplo.score.glm'></span><span id='topic+haplo.score.podds'></span><span id='topic+mf.gindx'></span><span id='topic+haplo.binomial'></span><span id='topic+residScaledGlmFit'></span><span id='topic+sr.class'></span><span id='topic+sr.class+3C-'></span><span id='topic+varfunc.glm.fit'></span>

<h3>Description</h3>

<p>Internal function for the HaploStats package
</p>

<hr>
<h2 id='f.power'>
Power and sample size for the F distribution
</h2><span id='topic+f.power'></span><span id='topic+f.power.dif'></span><span id='topic+f.sample.size'></span>

<h3>Description</h3>

<p>Power and sample size for the F distribution given
non-centrality, degrees of freedom, alpha, N (for f.power), and
power (for f.sample.size) 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f.power(n, nc, df1, alpha)
f.power.dif(n, nc, df1, alpha, power)
f.sample.size(nc, df1, alpha, power, lower=20, upper=10000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f.power_+3A_n">n</code></td>
<td>

<p>sample size
</p>
</td></tr>
<tr><td><code id="f.power_+3A_nc">nc</code></td>
<td>

<p>non-centrality parameter
</p>
</td></tr>
<tr><td><code id="f.power_+3A_df1">df1</code></td>
<td>

<p>degrees of freedom for numerator of f distribution
</p>
</td></tr>
<tr><td><code id="f.power_+3A_alpha">alpha</code></td>
<td>

<p>type-I error
</p>
</td></tr>
<tr><td><code id="f.power_+3A_power">power</code></td>
<td>

<p>desired power (for sample size)
</p>
</td></tr>
<tr><td><code id="f.power_+3A_lower">lower</code></td>
<td>

<p>lower limit for search space for sample size solution
</p>
</td></tr>
<tr><td><code id="f.power_+3A_upper">upper</code></td>
<td>

<p>upper limit for search space for sample size solution
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>power, the difference in power from target power, and sample size,
respectively for the three functions, assuming an F distribution for
the test statistic
</p>

<hr>
<h2 id='find.haplo.beta.qt'>
Find beta coefficients for risk haplotypes, for specified r2
</h2><span id='topic+find.haplo.beta.qt'></span><span id='topic+find.beta.qt.phase.known'></span><span id='topic+find.intercept.qt.phase.known'></span>

<h3>Description</h3>

<p>Find betas for risk haplotypes and intercept (beta for base.index
haplotype) with a given r2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.haplo.beta.qt(haplo, haplo.freq, base.index, haplo.risk, r2, y.mu=0, y.var=1)
find.beta.qt.phase.known(beta.size, haplo.risk, base.index, haplo,
haplo.freq, r2, y.mu, y.var)
find.intercept.qt.phase.known(beta.no.intercept, base.index, haplo, haplo.freq, y.mu)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find.haplo.beta.qt_+3A_haplo">haplo</code></td>
<td>

<p>matrix of haplotypes, with rows the different haplotypes and
columns the alleles of the haplotypes. For H haplotypes of L loci,
haplo has dimension H x L.
</p>
</td></tr>
<tr><td><code id="find.haplo.beta.qt_+3A_haplo.freq">haplo.freq</code></td>
<td>

<p>vector of length H for the population haplotype frequencies
(corresponding to the rows of haplo)
</p>
</td></tr>
<tr><td><code id="find.haplo.beta.qt_+3A_base.index">base.index</code></td>
<td>

<p>integer index of the haplotype considered to be the base-line for
logistic regression (index between 1 and H); often, the most common
haplotype is chosen for the base-line.
</p>
</td></tr>
<tr><td><code id="find.haplo.beta.qt_+3A_haplo.risk">haplo.risk</code></td>
<td>

<p>vector of relative risks for haplotypes
</p>
</td></tr>
<tr><td><code id="find.haplo.beta.qt_+3A_r2">r2</code></td>
<td>

<p>correlation coefficient
</p>
</td></tr>
<tr><td><code id="find.haplo.beta.qt_+3A_y.mu">y.mu</code></td>
<td>

<p>mean of y, a quantitative trait
</p>
</td></tr>
<tr><td><code id="find.haplo.beta.qt_+3A_y.var">y.var</code></td>
<td>

<p>variance of y, a quantitative trait
</p>
</td></tr>
<tr><td><code id="find.haplo.beta.qt_+3A_beta.size">beta.size</code></td>
<td>

<p>beta values for risk haplotypes in find.beta.qt.phase.known
</p>
</td></tr>
<tr><td><code id="find.haplo.beta.qt_+3A_beta.no.intercept">beta.no.intercept</code></td>
<td>

<p>beta vector for haplotypes for quantitative trait,
excluding the beta for intercept 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>beta estimates for haplotypes or intercept
</p>

<hr>
<h2 id='fitted.haplo.glm'>
Fitted values from haplo.glm fit
</h2><span id='topic+fitted.haplo.glm'></span>

<h3>Description</h3>

<p>The fitted values for each person, collapsed over their expanded
fitted values due to their multiple possible haplotype pairs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'haplo.glm'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.haplo.glm_+3A_object">object</code></td>
<td>

<p>A haplo.glm object
</p>
</td></tr>
<tr><td><code id="fitted.haplo.glm_+3A_...">...</code></td>
<td>

<p>Optional arguments for the method
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Many of the subjects in a haplo.glm fit are expanded in the model
matrix with weights used to reflect the posterior probability of the
subject's haplotype pairs given their genotype.  The working fitted
values within the fitted object are from this expanded model matrix,
and the fitted values from this method are calculated from the
weighted fitted value for the subject across all their haplotype pairs.
</p>


<h3>Value</h3>

<p>vector of fitted values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+haplo.glm">haplo.glm</a></code>
</p>

<hr>
<h2 id='geno.count.pairs'>
Counts of Total Haplotype Pairs Produced by Genotypes 
</h2><span id='topic+geno.count.pairs'></span>

<h3>Description</h3>

<p>Provide a count of all possible haplotype pairs for each subject,
according to the phenotypes in the rows of the geno matrix.  
The count for each row includes the count for complete phenotypes, as 
well as possible haplotype pairs for phenotypes where there are
missing alleles at any of the loci.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geno.count.pairs(geno)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geno.count.pairs_+3A_geno">geno</code></td>
<td>

<p>Matrix of alleles, such that each locus has a  pair  of adjacent 
columns of alleles,  and the order of columns corresponds to the 
order of loci  on a chromosome.   If there are K loci, then geno 
has  2*K  columns.  Rows represent all observed alleles for each 
subject, their phenotype.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When a subject has no missing alleles, and has h heterozygous sites, 
there are 2**(h-1) haplotype pairs that are possible ('**'=power).
For loci with missing alleles, we consider all possible pairs of alleles 
at those loci.  Suppose that there are M loci with missing alleles, and 
let the vector V have values 1 or 0 acccording to whether these loci 
are imputed to be heterozygous or homozygous, respectively. The length
of V is M.  The total number of  possible states of V is 
2**M. Suppose that  the vector W, also of length M, provides a count
of the number of possible heterozygous/homozygous states at the loci
with missing data. For example, if one allele  is missing, and there
are K possible alleles at that locus, then there can be one homozygous
and (K-1) heterozygous genotypes. If two alleles are missing, there
can be K homozygous and K(K-1)/2 heterozygous genotypes. Suppose the
function H(h+V) counts the total number of heterozygous sites among
the loci without missing data (of which h are heterozygous) and the
imputed loci (represented by the  vector V). Then, the total number of
possible pairs of haplotypes can be respresented as SUM(W*H(h+V)),
where the sum is over all possible values for the vector V.
</p>


<h3>Value</h3>

<p>Vector where each element gives a count of the number haplotype pairs 
that are consistent with a  subject's phenotype, where a phenotype may
include 0, 1, or 2 missing alleles at any locus.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+haplo.em">haplo.em</a></code>,
<code><a href="#topic+summaryGeno">summaryGeno</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hla.demo)
genohla &lt;- hla.demo[,c(17,18,21:24)]
geno &lt;- setupGeno(genohla)
count.geno &lt;- geno.count.pairs(geno)
print(count.geno)
</code></pre>

<hr>
<h2 id='geno1to2'>
convert genotype matrix from 1-column 2-column 
</h2><span id='topic+geno1to2'></span>

<h3>Description</h3>

<p>convert 1-column genotype matrix to 2-column genotype matrix,
converting from a minor allele count (0,1,2) to (1/1, 1/2, 2/2) where 2 is the
minor allele. (not supported for x-linked markers)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geno1to2(geno, locus.label=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geno1to2_+3A_geno">geno</code></td>
<td>

<p>1-column representation of genotype matrix for 2-allele loci.  Values
are 0, 1, or 2, usually the count of minor alleles
</p>
</td></tr>
<tr><td><code id="geno1to2_+3A_locus.label">locus.label</code></td>
<td>

<p>Vector of labels for loci, If a locus name is &quot;A&quot;, its columns
will be &quot;A.1&quot; and &quot;A.2&quot;
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 2-column genotype matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geno1 &lt;- matrix(c(0,0,1,
                  1,0,2,
                  2,1,0), ncol=3, byrow=TRUE)
geno1to2(geno1, locus.label=c("A", "B", "C"))

## demonstrate how NA and 3 will be coded
geno1[1,3] &lt;- NA
geno1[1,1] &lt;- 3
geno1to2(geno1)
</code></pre>

<hr>
<h2 id='get.hapPair'>
Get a list of objects for haplotype pairs
</h2><span id='topic+get.hapPair'></span>

<h3>Description</h3>

<p>Get a list of objects for modeling haplotype pairs from a set of unique
haplotypes and their frequencies, given the baseline haplotype
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.hapPair(haplo, haplo.freq, base.index)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.hapPair_+3A_haplo">haplo</code></td>
<td>

<p>matrix of haplotypes, with rows the different haplotypes and
columns the alleles of the haplotypes. For H haplotypes of L loci,
haplo has dimension H x L.
</p>
</td></tr>
<tr><td><code id="get.hapPair_+3A_haplo.freq">haplo.freq</code></td>
<td>

<p>vector of length H for the population haplotype frequencies
(corresponding to the rows of haplo)
</p>
</td></tr>
<tr><td><code id="get.hapPair_+3A_base.index">base.index</code></td>
<td>

<p>integer index of the haplotype considered to be the base-line for
logistic regression (index between 1 and H); often, the most common
haplotype is chosen for the base-line.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with components:
</p>
<table role = "presentation">
<tr><td><code>p.g</code></td>
<td>

<p>Genotype probability under Hardy-Weinberg Equilibrium, where the
genotype is the haplotype pair
</p>
</td></tr>
<tr><td><code>x.haplo</code></td>
<td>

<p>Design matrix for all pairs of haplotypes, excluding the baseline
haplotype.  Effects are coded to an additive effect for the haplotypes.
</p>
</td></tr>
<tr><td><code>haplo.indx</code></td>
<td>

<p>two-column matrix containing the indices for the haplotypes in x.haplo.
The indices are the row of the haplotype in haplo.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>haplo &lt;- rbind(
               c(     1,    2,    2,    1,    2),
               c(     1,    2,    2,    1,    1),
               c(     1,    1,    2,    1,    1),
               c(     1,    2,    1,    1,    2),
               c(     1,    2,    2,    2,    1),
               c(     1,    2,    1,    1,    1),
               c(     1,    1,    2,    2,    1),
               c(     1,    1,    1,    1,    2),
               c(     1,    2,    1,    2,    1),
               c(     1,    1,    1,    2,    1),
               c(     2,    2,    1,    1,    2),
               c(     1,    1,    2,    1,    2),
               c(     1,    1,    2,    2,    2),
               c(     1,    2,    2,    2,    2),
               c(     2,    2,    2,    1,    2),
               c(     1,    1,    1,    1,    1),
               c(     2,    1,    1,    1,    1),
               c(     2,    1,    2,    1,    1),
               c(     2,    2,    1,    1,    1),
               c(     2,    2,    1,    2,    1),
               c(     2,    2,    2,    1,    1))
dimnames(haplo)[[2]] &lt;- paste("loc", 1:ncol(haplo), sep=".")
haplo &lt;- data.frame(haplo)

haplo.freq &lt;- c(0.170020121, 0.162977867, 0.123742455, 0.117706237, 0.097585513, 0.084507042,
                0.045271630, 0.039235412, 0.032193159, 0.019114688, 0.019114688, 0.013078471,
                0.013078471, 0.013078471, 0.013078471, 0.006036217, 0.006036217, 0.006036217,
                0.006036217, 0.006036217, 0.006036217)

hPair &lt;- get.hapPair(haplo, haplo.freq, base.index=1)
names(hPair)
dim(hPair$x.haplo)
</code></pre>

<hr>
<h2 id='Ginv'>
Compute Generalized Inverse of Input Matrix
</h2><span id='topic+Ginv'></span>

<h3>Description</h3>

<p>Singular value decomposition (svd) is used to compute a
generalized inverse of input matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ginv(x, eps=1e-6)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Ginv_+3A_x">x</code></td>
<td>

<p>A matrix.
</p>
</td></tr>
<tr><td><code id="Ginv_+3A_eps">eps</code></td>
<td>

<p>minimum cutoff for singular values in svd of x
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The svd function uses the LAPACK standard library to compute the 
singular values of the input matrix, and the rank of the matrix is 
determined by the number of singular values  that  are  at  least  as
large   as  max(svd)*eps,  where  eps  is  a  small  value.  
For S-PLUS, the Matrix library is required (Ginv loads Matrix if not already
done so).
</p>


<h3>Value</h3>

<p>List with components:
</p>
<table role = "presentation">
<tr><td><code>Ginv</code></td>
<td>

<p>Generalized inverse of x.
</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>

<p>Rank of matrix x.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Press  WH,  Teukolsky  SA,  Vetterling  WT,  Flannery  BP.
Numerical  recipes  in C. The art of scientific computing.
2nd ed. Cambridge University Press,  Cambridge.1992.  page
61.
</p>
<p>Anderson, E., et al. (1994). LAPACK User's Guide, 
2nd edition, SIAM, Philadelphia.
</p>


<h3>See Also</h3>

<p>svd
</p>


<h3>Examples</h3>

<pre><code class='language-R'># for matrix x, extract the generalized inverse and 
# rank of x as follows
    x &lt;- matrix(c(1,2,1,2,3,2),ncol=3)
    save &lt;- Ginv(x)
    ginv.x &lt;- save$Ginv
    rank.x &lt;- save$rank
</code></pre>

<hr>
<h2 id='haplo.cc'>
Haplotype Association Analysis in a Case-Control design
</h2><span id='topic+haplo.cc'></span>

<h3>Description</h3>

<p>Combine results from haplo.score, haplo.group, and haplo.glm for
case-control study designs.  Analyze the association between the 
binary (case-control) trait and the haplotypes relevant to the
unrelated individuals' genotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haplo.cc(y, geno, x.adj=NA, locus.label=NA, ci.prob=0.95,
         miss.val=c(0,NA), weights=NULL, eps.svd=1e-5, simulate=FALSE,
         sim.control=score.sim.control(), control=haplo.glm.control())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="haplo.cc_+3A_y">y</code></td>
<td>

<p>Vector of trait values, must be 1 for cases and 0 for controls.
</p>
</td></tr>
<tr><td><code id="haplo.cc_+3A_geno">geno</code></td>
<td>

<p>Matrix of alleles, such that each locus has a pair of
adjacent columns of alleles, and the order of columns
corresponds to the order of loci on a chromosome.  If
there are K loci, then ncol(geno) = 2*K. Rows represent
alleles for each subject.
</p>
</td></tr>
<tr><td><code id="haplo.cc_+3A_x.adj">x.adj</code></td>
<td>

<p>Matrix of non-genetic covariates used to adjust the score 
statistics.  Note that intercept should not be included, 
as it will be added in this function.
</p>
</td></tr>
<tr><td><code id="haplo.cc_+3A_ci.prob">ci.prob</code></td>
<td>

<p>Probability level for confidence interval on the Odds Ratios of
each haplotype to span the true value. 
</p>
</td></tr>
<tr><td><code id="haplo.cc_+3A_locus.label">locus.label</code></td>
<td>

<p>Vector of labels for loci, of length K (see definition of geno matrix)
</p>
</td></tr>
<tr><td><code id="haplo.cc_+3A_miss.val">miss.val</code></td>
<td>

<p>Vector of codes for missing values of alleles
</p>
</td></tr>
<tr><td><code id="haplo.cc_+3A_weights">weights</code></td>
<td>

<p>the weights for observations (rows of the data frame). By default, all
observations are weighted equally.  One use is to correct for
over-sampling of cases in a case-control sample.
</p>
</td></tr>
<tr><td><code id="haplo.cc_+3A_eps.svd">eps.svd</code></td>
<td>

<p>epsilon value for singular value cutoff; to be used in the generalized
inverse calculation on the variance matrix of the score vector.  The
degrees of freedom for the global score test is 1 less than the number of
haplotypes that are scored (k-1).  The degrees of freedom is
calculated from the rank of the variance matrix for the score vector.
In some instances of numeric instability, the singular value
decomposition indicates full rank (k).  One remedy has been to give a
larger epsilon value.
</p>
</td></tr>
<tr><td><code id="haplo.cc_+3A_simulate">simulate</code></td>
<td>

<p>Logical:  if [F]alse, no empirical p-values are computed; if [T]rue,
simulations are performed within haplo.score. Specific simulation parameters
can be controlled in the sim.control parameter list.  
</p>
</td></tr>
<tr><td><code id="haplo.cc_+3A_sim.control">sim.control</code></td>
<td>

<p>A list of control parameters to determine how simulations are
performed for simulated p-values.  The list is created by the function
score.sim.control and the default values of this function can be
changed as desired.  See score.sim.control for details.
</p>
</td></tr>
<tr><td><code id="haplo.cc_+3A_control">control</code></td>
<td>

<p>A list of control parameters for managing the execution of
haplo.cc. The list is created by the function haplo.glm.control, which
also manages control parameters for the execution of haplo.em.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All function calls within haplo.cc are for the analysis of association
between haplotypes and the case-control status (binomial trait).  No 
additional covariates may be modeled with this function.  Odd Ratios
are in reference to the baseline haplotype.  Odds Ratios will change
if a different baseline is chosen using haplo.glm.control.
</p>


<h3>Value</h3>

<p>A list including the haplo.score object (score.lst), vector of subject
counts by case and control group (group.count), haplo.glm object (fit.lst), 
confidence interval probability (ci.prob), and a data frame (cc.df) with the 
following components:
</p>
<table role = "presentation">
<tr><td><code>haplotypes</code></td>
<td>

<p>The first K columns contain the haplotypes used in the analysis.
</p>
</td></tr>
<tr><td><code>Hap-Score</code></td>
<td>

<p>Score statistic for association of haplotype with the binary trait.
</p>
</td></tr>
<tr><td><code>p-val</code></td>
<td>

<p>P-value for the haplotype score statistic, based on a chi-square
distribution with 1 degree of freedom.
</p>
</td></tr>
<tr><td><code>sim.p.val</code></td>
<td>

<p>Vector of p-values for score.haplo, based on simulations in
haplo.score (omitted when simulations not performed).
P-value of score.global based on simulations
(set equal to NA when simulate=F).
</p>
</td></tr>
<tr><td><code>pool.hf</code></td>
<td>

<p>Estimated haplotype frequency for cases and controls pooled together.
</p>
</td></tr>
<tr><td><code>control.hf</code></td>
<td>

<p>Estimated haplotype frequency for control group subjects.
</p>
</td></tr>
<tr><td><code>case.hf</code></td>
<td>

<p>Estimated haplotype frequency for case group subjects.
</p>
</td></tr>
<tr><td><code>glm.eff</code></td>
<td>

<p>The haplo.glm function modeled the haplotype effects as: baseline (Base),
additive haplotype effect (Eff), or rare haplotypes pooled into a
single group (R).
</p>
</td></tr>
<tr><td><code>OR.lower</code></td>
<td>

<p>Lower limit of the Odds Ratio Confidence Interval.
</p>
</td></tr>
<tr><td><code>OR</code></td>
<td>

<p>Odds Ratio based on haplo.glm model estimated coefficient for the haplotype.
</p>
</td></tr>
<tr><td><code>OR.upper</code></td>
<td>

<p>Upper limit of the Odds Ratio Confidence Interval.
</p>
</td></tr>
</table>


<h3>References</h3>


<dl>
<dt>Schaid et al</dt><dd><p>Schaid DJ, Rowland CM, Tines DE, Jacobson RM,
Poland  GA. Score tests for association of traits with haplotypes
when linkage phase is ambiguous. Amer J Hum Genet. 70 (2002): 425-434.</p>
</dd>
<dt>Lake et al</dt><dd><p>Lake S, LH, Silverman E, Weiss S, Laird N, Schaid DJ.  Estimation and
tests of haplotype-environment interaction when linkage phase is
ambiguous. Human Heredity. 55 (2003):  56-65</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+haplo.em">haplo.em</a></code>,
<code><a href="#topic+haplo.score">haplo.score</a></code>,
<code><a href="#topic+haplo.group">haplo.group</a></code>,
<code><a href="#topic+haplo.score.merge">haplo.score.merge</a></code>,
<code><a href="#topic+haplo.glm">haplo.glm</a></code>
<code><a href="#topic+print.haplo.cc">print.haplo.cc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  For a genotype matrix geno.test, case/control vector y.test
#  The function call will be like this
#  cc.test &lt;- haplo.cc(y.test, geno.test, locus.label=locus.label, haplo.min.count=3, ci.prob=0.95)
#
</code></pre>

<hr>
<h2 id='haplo.design'>
Build a design matrix for haplotypes
</h2><span id='topic+haplo.design'></span>

<h3>Description</h3>

<p>Build a design matrix for haplotypes estimated from a haplo.em object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haplo.design(obj, haplo.effect="additive", hapcodes=NA, min.count=5, haplo.base=NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="haplo.design_+3A_obj">obj</code></td>
<td>

<p>an object created from haplo.em
</p>
</td></tr>
<tr><td><code id="haplo.design_+3A_haplo.effect">haplo.effect</code></td>
<td>

<p>The &quot;effect&quot; pattern of haplotypes on the response. This
parameter determines the coding for scoring the haplotypes. 
Valid coding options for heterozygous and homozygous carriers
of a haplotype are &quot;additive&quot; (1, 2, respectively),
&quot;dominant&quot; (1,1, respectively), and &quot;recessive&quot; (0, 1,
respectively). 
</p>
</td></tr>
<tr><td><code id="haplo.design_+3A_hapcodes">hapcodes</code></td>
<td>

<p>codes assigned in haplo.em, corresponding to the row numbers in the
haplotypes matrix item in <code>obj</code>
</p>
</td></tr>
<tr><td><code id="haplo.design_+3A_min.count">min.count</code></td>
<td>

<p>The minimum number of estimated counts of the haplotype in the sample
in order for a haplotype to be included in the design matrix.  
</p>
</td></tr>
<tr><td><code id="haplo.design_+3A_haplo.base">haplo.base</code></td>
<td>

<p>code for which haplotype will be the reference group, or to be
considered the baseline of a model.  The code is the row number of the
<code>haplotypes</code> matrix in <code>obj</code>. This haplotype is removed from
the design matrix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First a matrix is made for the possible haplotypes for each
person, coded for the haplo.effect, weighted by the posterior
probability of those possible haplotypes per person, and then 
collapsed back to a single row per person.
</p>


<h3>Value</h3>

<p>Matrix of columns for haplotype effects. Column names are &quot;hap.k&quot;
where k is the row number of the unique haplotypes within the haplo.em
object's &quot;haplotypes&quot; item. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+haplo.em">haplo.em</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ###------------------------------------------------
 ### See the user manual for more complete examples
 ###------------------------------------------------

 data(hla.demo)
 attach(hla.demo)

 geno &lt;- hla.demo[,c(17,18,21:24)]
 label &lt;-c("DQB","DRB","B")

 keep &lt;- !apply(is.na(geno) | geno==0, 1, any)

 save.em.keep &lt;- haplo.em(geno=geno[keep,], locus.label=label)

 save.df &lt;- haplo.design(save.em.keep, min.count=10)
 dim(save.df)

 names(save.df)
 save.df[1:10,]


</code></pre>

<hr>
<h2 id='haplo.em'>
EM Computation of Haplotype Probabilities, with Progressive Insertion
of Loci
</h2><span id='topic+haplo.em'></span>

<h3>Description</h3>

<p>For genetic marker phenotypes measured on unrelated subjects, with 
linkage phase unknown, compute maximum likelihood estimates of
haplotype probabilities.  Because linkage phase is unknown, there 
may be  more than one pair of haplotypes that are consistent with 
the oberved marker phenotypes, so posterior probabilities of pairs 
of haplotypes for each subject are also computed. Unlike the usual EM
which attempts to enumerate all possible pairs of haplotypes before
iterating over the EM steps,  this &quot;progressive insertion&quot; algorithm 
progressively inserts batches of loci into haplotypes of growing
lengths, runs the EM steps, trims off
pairs of haplotypes per subject when the posterior probability of the
pair is below a specified threshold, and then continues these
insertion, EM, and trimming steps until all loci are inserted into the
haplotype. The user can choose the batch size. If the batch size
is chosen to be all loci, and the threshold for trimming is set to
0, then this algorithm reduces to the usual EM algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haplo.em(geno, locus.label=NA, miss.val=c(0, NA), weight, control= 
           haplo.em.control())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="haplo.em_+3A_geno">geno</code></td>
<td>

<p>matrix of alleles, such that each locus has a pair of adjacent 
columns of alleles, and the order of columns corresponds to 
the order of loci on a chromosome.  If there are K loci, then 
ncol(geno) = 2*K. Rows represent the alleles for each subject.
</p>
</td></tr>
<tr><td><code id="haplo.em_+3A_locus.label">locus.label</code></td>
<td>

<p>vector of labels for loci.
</p>
</td></tr>
<tr><td><code id="haplo.em_+3A_miss.val">miss.val</code></td>
<td>

<p>vector of values that represent missing alleles in geno.
</p>
</td></tr>
<tr><td><code id="haplo.em_+3A_weight">weight</code></td>
<td>

<p>weights for observations (rows of geno matrix).  
</p>
</td></tr>
<tr><td><code id="haplo.em_+3A_control">control</code></td>
<td>

<p>list of control parameters. The default is constructed by the function
haplo.em.control. The default behavior of this function results in the
following parameter settings:  loci.insert.order=1:n.loci, 
insert.batch.size=min(4,n.loci), min.posterior= 0.0001, tol=0.00001,
max.iter=500, random.start=0 (no random start), iseed=NULL (no saved
seed to start random start), verbose=0 (no printout during EM
iterations). See haplo.em.control for more details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basis of this progressive insertion algorithm is from the sofware
snphap by David Clayton. Although some of the features and control
parameters of this S-PLUS version are modeled after snphap, there are
substantial differences, such as extension to allow for more than two
alleles per locus, and some other nuances on how the alogrithm is implemented.
</p>


<h3>Value</h3>

<p>list with components:
</p>
<table role = "presentation">
<tr><td><code>converge</code></td>
<td>

<p>indicator of convergence of the EM algorithm
(1 = converge, 0 = failed).
</p>
</td></tr>
<tr><td><code>lnlike</code></td>
<td>

<p>value of lnlike at last EM iteration (maximum lnlike if converged).
</p>
</td></tr>
<tr><td><code>lnlike.noLD</code></td>
<td>

<p>value of lnlike under the null of linkage equilibrium at all loci.  
</p>
</td></tr>
<tr><td><code>lr</code></td>
<td>

<p>likelihood ratio statistic to test the final lnlike against the
lnlike that assumes complete linkage equilibrium among all loci
(i.e., haplotype frequencies are products of allele frequencies).
</p>
</td></tr>
<tr><td><code>df.lr</code></td>
<td>

<p>degrees of freedom for likelihood ratio statistic. The df for the
unconstrained final model is the  number of non-zero haplotype frequencies
minus 1, and the df for the null model of complete linkage 
equilibrium is the sum, over all loci, of (number of alleles - 1). The
df for the lr statistic is df[unconstrained] - df[null]. This can
result in negative df, if many haplotypes are estimated to have zero 
frequency, or if a large amount of trimming occurs, when using large
values of min.posterior in the list of control parameters.
</p>
</td></tr>
<tr><td><code>hap.prob</code></td>
<td>

<p>vector of mle's of haplotype probabilities.  The ith
element of hap.prob corresponds to the ith row of 
haplotype.
</p>
</td></tr>
<tr><td><code>locus.label</code></td>
<td>

<p>vector of labels for loci, of length K 
(see definition of input values).
</p>
</td></tr>
<tr><td><code>subj.id</code></td>
<td>

<p>vector of id's for subjects used in the analysis, based on row number
of input geno matrix. If subjects are removed, then their id will be
missing from subj.id.
</p>
</td></tr>
<tr><td><code>rows.rem</code></td>
<td>

<p>now defunct, but set equal to a vector of length 0, to be compatible 
with other functions that check for rows.rem.
</p>
</td></tr>
<tr><td><code>indx.subj</code></td>
<td>

<p>vector for row index of subjects after expanding to all 
possible pairs of haplotypes for each person.  If indx.subj=i, 
then i is the ith row of  geno.  If the ith 
subject has n possible pairs of haplotypes that correspond 
to their marker genotype, then i is repeated n times.
</p>
</td></tr>
<tr><td><code>nreps</code></td>
<td>

<p>vector for the count of haplotype pairs that map to
each subject's marker genotypes.
</p>
</td></tr>
<tr><td><code>max.pairs</code></td>
<td>

<p>vector of maximum number of pairs of haplotypes per subject that are
consistent with their marker data in the matrix geno. The
length of max.pairs  = nrow(geno). This vector is computed by  
geno.count.pairs.
</p>
</td></tr>
<tr><td><code>hap1code</code></td>
<td>

<p>vector of codes for each subject's first haplotype.
The values in hap1code are the row numbers of the unique
haplotypes in the returned matrix haplotype.
</p>
</td></tr>
<tr><td><code>hap2code</code></td>
<td>

<p>similar to hap1code, but for each subject's second haplotype.
</p>
</td></tr>
<tr><td><code>post</code></td>
<td>

<p>vector of posterior probabilities of pairs of haplotypes for 
a person, given their marker phenotypes.
</p>
</td></tr>
<tr><td><code>haplotype</code></td>
<td>

<p>matrix of unique haplotypes. Each row represents a unique 
haplotype, and the number of columns is the number of loci.
</p>
</td></tr>
<tr><td><code>control</code></td>
<td>

<p>list of control parameters for algorithm. See haplo.em.control
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Sorted order of haplotypes with character alleles is system-dependent,
and can be controlled via the LC_COLLATE locale environment
variable. Different locale settings can cause results to be
non-reproducible even when controlling the random seed. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setupGeno">setupGeno</a></code>,
<code><a href="#topic+haplo.em.control">haplo.em.control</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hla.demo)
attach(hla.demo)
geno &lt;- hla.demo[,c(17,18,21:24)]
label &lt;-c("DQB","DRB","B")
keep &lt;- !apply(is.na(geno) | geno==0, 1, any)

save.em.keep &lt;- haplo.em(geno=geno[keep,], locus.label=label)

# warning: output will not exactly match

print.haplo.em(save.em.keep)
</code></pre>

<hr>
<h2 id='haplo.em.control'>
Create the Control Parameters for the EM Computation of Haplotype 
Probabilities, with Progressive Insertion of Loci
</h2><span id='topic+haplo.em.control'></span>

<h3>Description</h3>

<p>Create a list of parameters that control the EM algorithm for 
estimating haplotype frequencies, based on progressive insertion 
of loci. Non-default parameters for the EM algorithm can be
set as parameters passed to haplo.em.control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haplo.em.control(loci.insert.order=NULL, insert.batch.size = 6,
                             min.posterior = 1e-09, tol = 1e-05,
                             max.iter=5000, random.start=0, n.try = 10,
                             iseed=NULL, max.haps.limit=2e6, verbose=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="haplo.em.control_+3A_loci.insert.order">loci.insert.order</code></td>
<td>

<p>Numeric vector with specific order to insert the loci. If this value
is NULL, the insert order will be in sequential order (1, 2, ..., No. Loci).
</p>
</td></tr>
<tr><td><code id="haplo.em.control_+3A_insert.batch.size">insert.batch.size</code></td>
<td>

<p>Number of loci to be inserted in a single batch.
</p>
</td></tr>
<tr><td><code id="haplo.em.control_+3A_min.posterior">min.posterior</code></td>
<td>

<p>Minimum posterior probability of a haplotype pair, conditional on
observed marker genotypes. Posteriors below this minimum value will
have their pair of haplotypes &quot;trimmed&quot; off the list of possible
pairs.  If all markers in low LD, we recommend using the default.
If markers have at least moderate LD, can increase this value to use
less memory.
</p>
</td></tr>
<tr><td><code id="haplo.em.control_+3A_tol">tol</code></td>
<td>

<p>If the change in log-likelihood value between EM steps is less 
than the tolerance (tol), it has converged.
</p>
</td></tr>
<tr><td><code id="haplo.em.control_+3A_max.iter">max.iter</code></td>
<td>

<p>Maximum number of iterations allowed for the EM algorithm before it
stops and prints an error.  If the error is printed, double max.iter.
</p>
</td></tr>
<tr><td><code id="haplo.em.control_+3A_random.start">random.start</code></td>
<td>

<p>If random.start = 0, then the inititial starting values of the
posteriors for the first  EM attempt will be based on assuming equal
posterior probabilities (conditional on genotypes). If random.start = 1,
then the initial starting values of the first EM attempt will be based on assuming a uniform distribution for
the initial posterior probabilities.
</p>
</td></tr>
<tr><td><code id="haplo.em.control_+3A_n.try">n.try</code></td>
<td>

<p>Number of times to try to maximize the lnlike by the EM algorithm. The
first try uses, as initial starting values for the posteriors,
either equal values or uniform random variables, as determined by
random.start. All subsequent tries will use random uniform values as
initial starting values for the posterior probabilities.
</p>
</td></tr>
<tr><td><code id="haplo.em.control_+3A_iseed">iseed</code></td>
<td>

<p>An integer or a saved copy of .Random.seed. This allows simulations to
be reproduced by using the same initial seed.
</p>
</td></tr>
<tr><td><code id="haplo.em.control_+3A_max.haps.limit">max.haps.limit</code></td>
<td>

<p>Maximum number of haplotypes for the input genotypes.  It is used as
the amount of memory to allocate in C for the progressive-insertion
E-M steps.  Within haplo.em, the first step is to try to allocate the
sum of the result of geno.count.pairs(), if that exceeds
max.haps.limit, start by allocating max.haps.limit.  If that is
exceeded in the progressive-insertions steps, the C function doubles
the memory until it can no longer request more. 
</p>
</td></tr>
<tr><td><code id="haplo.em.control_+3A_verbose">verbose</code></td>
<td>

<p>Logical, if TRUE, print procedural messages to the screen.  If FALSE, 
do not print any messages. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default is to use n.try = 10. If this takes too much time, it may
be worthwhile to decrease n.try. Other tips for computing haplotype
frequencies for a large number of loci, particularly if some have many
alleles, is to decrease the batch size (insert.batch.size), increase
the memory (max.haps.limit), and increase the probability of trimming
off rare haplotypes at each insertion step (min.posterior).
</p>


<h3>Value</h3>

<p>A list of the parameters passed to the function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+haplo.em">haplo.em</a></code>,
<code><a href="#topic+haplo.score">haplo.score</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is how it is used within haplo.score
#    &gt; score.gauss &lt;- haplo.score(resp, geno, trait.type="gaussian", 
#    &gt;           em.control=haplo.em.control(insert.batch.size = 2, n.try=1))
</code></pre>

<hr>
<h2 id='haplo.em.fitter'>
Compute engine for haplotype EM algorithm 
</h2><span id='topic+haplo.em.fitter'></span>

<h3>Description</h3>

<p>For internal use within the haplo.stats library
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haplo.em.fitter(n.loci, n.subject, weight, geno.vec, n.alleles,
                max.haps, max.iter, loci.insert.order, min.posterior, 
                tol, insert.batch.size, random.start, iseed1, iseed2, 
                iseed3, verbose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="haplo.em.fitter_+3A_n.loci">n.loci</code></td>
<td>

<p>number of loci in genotype matrix
</p>
</td></tr>
<tr><td><code id="haplo.em.fitter_+3A_n.subject">n.subject</code></td>
<td>

<p>number of subjects in the sample
</p>
</td></tr>
<tr><td><code id="haplo.em.fitter_+3A_weight">weight</code></td>
<td>

<p>numeric weights
</p>
</td></tr>
<tr><td><code id="haplo.em.fitter_+3A_geno.vec">geno.vec</code></td>
<td>

<p>vectorized genotype matrix
</p>
</td></tr>
<tr><td><code id="haplo.em.fitter_+3A_n.alleles">n.alleles</code></td>
<td>

<p>numeric vector giving number of alleles at each marker
</p>
</td></tr>
<tr><td><code id="haplo.em.fitter_+3A_max.haps">max.haps</code></td>
<td>

<p>maximum unique haplotypes in the sample
</p>
</td></tr>
<tr><td><code id="haplo.em.fitter_+3A_max.iter">max.iter</code></td>
<td>

<p>maximum iterations to perform in the fitter
</p>
</td></tr>
<tr><td><code id="haplo.em.fitter_+3A_loci.insert.order">loci.insert.order</code></td>
<td>

<p>order to insert loci for progressive insertion
</p>
</td></tr>
<tr><td><code id="haplo.em.fitter_+3A_min.posterior">min.posterior</code></td>
<td>

<p>after insertion and maximization, discard haplotype pairs per person
that do not meet minimum posterior prob
</p>
</td></tr>
<tr><td><code id="haplo.em.fitter_+3A_tol">tol</code></td>
<td>

<p>convergence tolerance for E-M steps
</p>
</td></tr>
<tr><td><code id="haplo.em.fitter_+3A_insert.batch.size">insert.batch.size</code></td>
<td>

<p>number of markers to insert per batch
</p>
</td></tr>
<tr><td><code id="haplo.em.fitter_+3A_random.start">random.start</code></td>
<td>

<p>logical; if TRUE, allow for random starting values of haplotype frequencies 
</p>
</td></tr>
<tr><td><code id="haplo.em.fitter_+3A_iseed1">iseed1</code></td>
<td>

<p>random seed for algorithm
</p>
</td></tr>
<tr><td><code id="haplo.em.fitter_+3A_iseed2">iseed2</code></td>
<td>

<p>random seed for algorithm
</p>
</td></tr>
<tr><td><code id="haplo.em.fitter_+3A_iseed3">iseed3</code></td>
<td>

<p>random seed for algorithm
</p>
</td></tr>
<tr><td><code id="haplo.em.fitter_+3A_verbose">verbose</code></td>
<td>

<p>logical, print long, verbose output from E-M steps?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For internal use within the haplo.stats library
</p>

<hr>
<h2 id='haplo.glm'>
GLM Regression of Trait on Ambiguous Haplotypes
</h2><span id='topic+haplo.glm'></span><span id='topic+print.haplo.glm'></span>

<h3>Description</h3>

<p>Perform glm regression of a trait on haplotype effects, allowing for
ambiguous haplotypes. This method performs an iterative  two-step EM, 
with the posterior probabilities of pairs of haplotypes per subject used as
weights to update the regression coefficients, and the regression
coefficients used to update the posterior probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haplo.glm(formula=formula(data), family=gaussian, data=parent.frame(),
           weights, na.action="na.geno.keep", start=NULL, 
           locus.label=NA, control=haplo.glm.control(), 
           method="glm.fit", model=TRUE, x=FALSE, y=TRUE, 
           contrasts=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="haplo.glm_+3A_formula">formula</code></td>
<td>

<p>a formula expression as for other regression models, of the
form response ~ predictors. For details, see the documentation
for lm and formula. 
</p>
</td></tr>
<tr><td><code id="haplo.glm_+3A_family">family</code></td>
<td>

<p>a family object. This is a list of expressions for defining the
link, variance function, initialization values, and iterative
weights for the generalized linear model. Supported families
are: gaussian, binomial, poisson. Currently, only the logit
link is implemented for binimial.	  
</p>
</td></tr>
<tr><td><code id="haplo.glm_+3A_data">data</code></td>
<td>

<p>a data frame in which to interpret the variables occurring in
the formula. A CRITICAL element of the data frame is the
matrix of genotypes, denoted here as &quot;geno&quot;, although an 
informative name should be used in practice. This geno matrix is actually a 
matrix of alleles, such that each locus has a pair of adjacent 
columns of alleles, and the order of columns corresponds to 
the order of loci on a chromosome.  If there are K loci, then 
ncol(geno) = 2*K. Rows represent the alleles for each subject. It is
also CRITICAL that this matrix is defined as a model.matrix, so
the columns of the matrix are packaged together into a single
matrix object. If geno is a matrix of alleles, then before adding it to
the data frame, use the setupGeno() function, which will assign this
correct class.  The function will also recode alleles to numeric
starting from 1, while saving the original alleles in the unique.alleles
attribute.  This attribute is required in haplo.glm.
</p>
</td></tr>
<tr><td><code id="haplo.glm_+3A_weights">weights</code></td>
<td>

<p>the weights for observations (rows of the data frame). By default, all
observations are weighted equally.
</p>
</td></tr>
<tr><td><code id="haplo.glm_+3A_na.action">na.action</code></td>
<td>

<p>a function to filter missing data. This is applied to the
model.frame. The default value of na.action=na.geno.keep will keep
observations with some (but not all) missing alleles, but exclude
observations missing any other data (e.g., response variable, other
covariates, weight). The EM algorithm for ambiguous haplotypes accounts
for missing alleles. Similar to the usual glm, na.fail creates an
error if any missing values are found, and a third possible
alternative is na.exclude, which deletes observations that contain
one or more missing values for any data, including alleles.
</p>
</td></tr>
<tr><td><code id="haplo.glm_+3A_start">start</code></td>
<td>

<p>a vector of initial values on the scale of the linear
predictor. 
</p>
</td></tr>
<tr><td><code id="haplo.glm_+3A_locus.label">locus.label</code></td>
<td>

<p>vector of labels for loci.
</p>
</td></tr>
<tr><td><code id="haplo.glm_+3A_control">control</code></td>
<td>

<p>list of control parameters. The default is constructed by the function
haplo.glm.control. The items in this list control the regression
modeling of the haplotypes (e.g., additive, dominant, recessive
effects of haplotypes; which haplotype is chosen as the baseline for
regression; how to handle rare haplotypes; control of the glm function
- maximum number of iterations), and the EM algorithm for estimating initial
haplotype frequencies. See haplo.glm.control for details.
</p>
</td></tr>
<tr><td><code id="haplo.glm_+3A_method">method</code></td>
<td>

<p>currently, glm.fit is the only method allowed.
</p>
</td></tr>
<tr><td><code id="haplo.glm_+3A_model">model</code></td>
<td>

<p>logical, if model=TRUE, the model.frame is returned.
</p>
</td></tr>
<tr><td><code id="haplo.glm_+3A_x">x</code></td>
<td>

<p>logical, if x=TRUE, the model.matrix is returned.
</p>
</td></tr>
<tr><td><code id="haplo.glm_+3A_y">y</code></td>
<td>

<p>logical, if y=TRUE, the response variable is returned.
</p>
</td></tr>
<tr><td><code id="haplo.glm_+3A_contrasts">contrasts</code></td>
<td>

<p>currently ignored
</p>
</td></tr>
<tr><td><code id="haplo.glm_+3A_...">...</code></td>
<td>

<p>other arguments that may be passed - currently ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To properly prepare the data frame, the genotype matrix must be
processed by setupGeno, and then included in the data frame with the
response and other variables.
</p>
<p>For binomial family, the initialization of values gives warnings if
non-integer number of successes, which is a concern in these models
because of the weights of posterior probability of each haplotype pair
per subject.  We supress the warnings by defining a haplo.binomial
family, which we use if family=binomial is used.
</p>


<h3>Value</h3>

<p>An object of class &quot;haplo.glm&quot; is returned.          
The output object from haplo.glm has all the components of a
glm object, with a few more. It is important to note that some of
the returned components correpond to the &quot;expanded&quot; version
of the data. This means that each observation is expanded into
the number of terms in the
observation's posterior distribution of haplotype pairs, given the
marker data. For example, when fitting the response y on haplotype
effects, the value of y[i], for the ith observation, is replicated
m[i] times, where m[i] is the number of pairs of haplotypes consistent
with the observed marker data. The returned components that are
expanded are indicated below by [expanded] in the definition of the
component.
</p>
<p>These expanded components may need to be collapsed, depending on the
objective of the user. For example, when considering the influence of 
an observation, it may make sense to examine the expanded residuals
for a single observation, perhaps plotted against the haplotypes
for that observation. In contrast, it would not be sensible to plot
all residuals against non-genetic covariates, without first
collapsing the expanded residuals for each observation. To collapse,
one can use the average residual per observation, weighted according
to the posterior probabilities. The appropriate weight can be
computed as wt = weight.expanded * haplo.post.info[[post]].
Then, the weighted average can be calculated as
with(fit, tapply(residuals * wt, haplo.post.info[[&quot;indx&quot;]], sum).
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>

<p>the coefficients of the linear.predictors, which multiply the
columns of the model matrix. The names of the coefficients are
the names of the column of the model matrix. For haplotype coefficients, the names
are the concatentation of name of the geno matrix with a haplotype
number. The haplotype number corresponds to the index of the
haplotype. The default print will show the coefficients with haplotype
number, along with the alleles that define the haplotype, and the
estimated haplotype frequency. If the model is over-determined there
will be missing values in the coefficients corresponding to
inestimable coefficients.
</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>

<p>[expanded]  residuals from the final weighted least squares fit; also
known as working residuals, these are typically not
interpretable without rescaling by the weights
(see glm.object and residuals.haplo.glm).
</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>

<p>[expanded] fitted mean values, obtained by transforming
linear.predictors using the inverse link function (see glm.object).
</p>
</td></tr>
<tr><td><code>effects</code></td>
<td>

<p>[expaded] orthogonal, single-degree-of-freedom effects (see lm.object).          
</p>
</td></tr>
<tr><td><code>R</code></td>
<td>

<p>the triangular factor of the decomposition (see lm.object).                
</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>

<p>the computed rank (number of linearly independent columns in
the model matrix), which is the model degrees of freedom
- see lm.object.
</p>
</td></tr>
<tr><td><code>assign</code></td>
<td>

<p>the list of assignments of coefficients (and effects) to the
terms in the model (see lm.object).      
</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>

<p>[expanded] number of degrees of freedom for residuals, corresponding
to the expanded data.
</p>
</td></tr>
<tr><td><code>prior.weights</code></td>
<td>

<p>[expanded] input weights after expanding according to the number
of pairs of haplotypes consistent with an observation's 
marker genotype data. 
</p>
</td></tr>
<tr><td><code>family</code></td>
<td>

<p>a 3 element character vector giving the name of the family, the
link and the variance function; mainly for printing purposes.           
</p>
</td></tr>
<tr><td><code>linear.predictors</code></td>
<td>

<p>[expanded] linear fit, given by the product of the model matrix and
the coefficients. In a glm, eta.
</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>

<p>up to a constant, minus twice the maximized log-likelihood.
Similar to the residual sum of squares.         
</p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>

<p>the deviance corresponding to the model with no predictors.    
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>an image of the call that produced the object, but with the
arguments all named and with the actual formula included as the
formula argument.             
</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>

<p>the number of IRLS iterations used to compute the estimates, for the
last step of the EM fit of coefficients.
</p>
</td></tr>
<tr><td><code>y</code></td>
<td>

<p>expanded response.                
</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>

<p>a list containing sufficient information to construct the
contrasts used to fit any factors occurring in the model (see lm.object).
</p>
</td></tr>
<tr><td><code>lnlike</code></td>
<td>

<p>log-likelihood of the fitted model.     
</p>
</td></tr>
<tr><td><code>lnlike.null</code></td>
<td>

<p>log-likelihood of the null model (intercept-only).      
</p>
</td></tr>
<tr><td><code>lrt</code></td>
<td>

<p>likelihood ratio test statistic to test whether all coefficients
(excepet intercept) are zero: 2*(lnlike - lnlike.null)
</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>

<p>an object of mode expression and class term summarizing the
formula, but not complete for the final model. Because this does
not represent expansion of the design matrix for the haplotypes, it
is typically not of direct relevance to users.           
</p>
</td></tr>
<tr><td><code>control</code></td>
<td>

<p>list of all control parameters        
</p>
</td></tr>
<tr><td><code>haplo.unique</code></td>
<td>

<p>the data.frame of unique haplotypes   
</p>
</td></tr>
<tr><td><code>haplo.base</code></td>
<td>

<p>the index of the haplotype used as the base-line for the regression
model. To see the actual haplotype definition, use the following: 
with(fit, haplo.unique[haplo.base,]), where fit is the saved haplo.glm
object (e.g., fit &lt;- haplo.glm(y ~ geno, ...) ).
</p>
</td></tr>
<tr><td><code>haplo.freq</code></td>
<td>

<p>the final estimates of haplotype frequencies, after completing EM
steps of updating haplotype frequencies and regression coefficients.
The length of haplo.freq is the number of rows of haplo.unique, and
the order of haplo.freq is the same as that for the rows of
haplo.unique. So, the frequencies of the unique haplotypes can be 
viewed as with(fit, cbind(haplo.unique, haplo.freq)).
</p>
</td></tr>
<tr><td><code>haplo.freq.init</code></td>
<td>

<p>the initial estimates of haplotype frequencies, based on the EM
algorithm for estimating haplotype frequencies, ingnoring the
trait. These can be compared with haplo.freq, to see the impact of 
using the regression model to update the haplotype frequencies.
</p>
</td></tr>
<tr><td><code>converge.em</code></td>
<td>

<p>T/F whether the EM-glm steps converged
</p>
</td></tr>
<tr><td><code>haplo.common</code></td>
<td>

<p>the indices of the haplotypes determined to be &quot;common&quot; enough to
estimate their corresponding regression coefficients.
</p>
</td></tr>
<tr><td><code>haplo.rare</code></td>
<td>

<p>the indices of all the haplotypes determined to be too rare to
estimate their specific regression coefficients.     
</p>
</td></tr>
<tr><td><code>haplo.rare.term</code></td>
<td>

<p>T/F whether the &quot;rare&quot; term is included in the haplotype regression model.
</p>
</td></tr>
<tr><td><code>haplo.names</code></td>
<td>

<p>the names of the coefficients that represent haplotype effects.    
</p>
</td></tr>
<tr><td><code>haplo.post.info</code></td>
<td>

<p>a data.frame of information regarding the posterior
probabilites. The columns of this data.frame are: indx (the index of
the input obsevation; if the ith observation is repeated m times, then
indx will show m replicates of i; hence, indx will correspond to the
&quot;expanded&quot; observations); hap1 and hap2 (the indices of the
haplotypes; if hap1=j and hap2=k, then the two haplotypes in terms
of alleles are haplo.unique[j,] and haplo.unique[k,] from the fitted object);
post.init (the initial posterior probability, based on
haplo.freq.init); post (the final posterior probability, based on
haplo.freq).
</p>
</td></tr>
<tr><td><code>x</code></td>
<td>

<p>the model matrix, with [expanded] rows, if x=T.              
</p>
</td></tr>
<tr><td><code>info</code></td>
<td>

<p>the observed information matrix, based on Louis' formula. The upper
left submatrix is for the regression coefficient, the lower right
submatrix for the haplotype frequencies, and the remaining is the
information between regression coefficients and haplotype frequencies. 
</p>
</td></tr>
<tr><td><code>var.mat</code></td>
<td>

<p>the variance-covariance matrix of regression coefficients and
haplotype frequencies, based on the inverse of info. Upper left
submatrix is for regression coefficients, lower right submatrix for
haplotype frequencies.
</p>
</td></tr>
<tr><td><code>haplo.elim</code></td>
<td>

<p>the indices of the haplotypes eliminated from the info and var.mat
matrices because their frequencies are less than haplo.min.info (the
minimum haplotype frequency required for computation of the
information matrix - see haplo.glm.control)
</p>
</td></tr>
<tr><td><code>missing</code></td>
<td>

<p>a matrix of logical values, indicating whether rows of data were
removed for missing values in either genotype matrix (genomiss) or
any other variables (yxmiss), such as y, other covariates, or weights.  
</p>
</td></tr>
<tr><td><code>rank.info</code></td>
<td>

<p>rank of information (info) matrix.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Lake S, Lyon H, Silverman E, Weiss S, Laird N, Schaid D (2002)
Estimation and tests of haplotype-environment interaction 
when linkage phase is ambiguous. Human Heredity 55:56-65.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+haplo.glm.control">haplo.glm.control</a></code>,
<code><a href="#topic+haplo.em">haplo.em</a></code>,
<code><a href="#topic+haplo.model.frame">haplo.model.frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cat(" FOR REGULAR USAGE, DO NOT DISCARD GENOTYPES WITH MISSING VALUES\n")
cat(" WE ONLY SUBSET BY keep HERE SO THE EXAMPLES RUN FASTER\n")

 data(hla.demo)
 geno &lt;- as.matrix(hla.demo[,c(17,18,21:24)])
 keep &lt;- !apply(is.na(geno) | geno==0, 1, any) # SKIP THESE THREE LINES
 hla.demo &lt;- hla.demo[keep,]                   # IN AN ANALYSIS
 geno &lt;- geno[keep,]                           # 
 attach(hla.demo)
 label &lt;-c("DQB","DRB","B")
 y &lt;- hla.demo$resp
 y.bin &lt;- 1*(hla.demo$resp.cat=="low")

# set up a genotype array as a model.matrix for inserting into data frame
# Note that hla.demo is a data.frame, and we need to subset to columns
# of interest. Also also need to convert to a matrix object, so that
# setupGeno can code alleles and convert geno to 'model.matrix' class.

 geno &lt;- setupGeno(geno, miss.val=c(0,NA))

  # geno now has an attribute 'unique.alleles' which must be passed to
  # haplo.glm as allele.lev=attributes(geno)$unique.alleles, see below

 my.data &lt;- data.frame(geno=geno, age=hla.demo$age, male=hla.demo$male,
                      y=y, y.bin=y.bin)

 fit.gaus &lt;- haplo.glm(y ~ male + geno, family = gaussian,  na.action=
               "na.geno.keep",allele.lev=attributes(geno)$unique.alleles, 
               data=my.data, locus.label=label,
               control = haplo.glm.control(haplo.freq.min=0.02))
 fit.gaus
 
</code></pre>

<hr>
<h2 id='haplo.glm.control'>
Create list of control parameters for haplo.glm
</h2><span id='topic+haplo.glm.control'></span>

<h3>Description</h3>

<p>Create a list of control pararameters for haplo.glm. If no parameters
are passed to this function, then all default values are used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haplo.glm.control(haplo.effect="add", haplo.base=NULL,
                  haplo.min.count=NA, haplo.freq.min=.01,
                  sum.rare.min=0.001, haplo.min.info=0.001, 
                  keep.rare.haplo=TRUE,
                  eps.svd=sqrt(.Machine$double.eps),
                  glm.c=glm.control(maxit=500), 
                  em.c=haplo.em.control())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="haplo.glm.control_+3A_haplo.effect">haplo.effect</code></td>
<td>

<p>the &quot;effect&quot; of a haplotypes, which determines the covariate (x)
coding of haplotypes. Valid options are &quot;additive&quot; (causing x = 0,
1, or 2, the count of a  particular haplotype), &quot;dominant&quot; (causing
x = 1 if heterozygous or homozygous carrier of a particular
haplotype; x = 0 otherwise), and &quot;recessive&quot; (causing x = 1 if
homozygous for a particular haplotype; x = 0 otherwise).
</p>
</td></tr>
<tr><td><code id="haplo.glm.control_+3A_haplo.base">haplo.base</code></td>
<td>

<p>the index for the haplotype to be used as the base-line for
regression. By default, haplo.base=NULL, so that the most frequent
haplotype is chosen as the base-line.
</p>
</td></tr>
<tr><td><code id="haplo.glm.control_+3A_haplo.min.count">haplo.min.count</code></td>
<td>

<p>The minimum number of expected counts for a haplotype from the
sample to be included in the model.  The count is based on 
estimated haplotype frequencies.  Suggested minimum is 5.
</p>
</td></tr>
<tr><td><code id="haplo.glm.control_+3A_haplo.freq.min">haplo.freq.min</code></td>
<td>

<p>the minimum haplotype frequency for a haplotype to be included in
the regression model as its own effect. The haplotype frequency is
based on the EM algorithm that estimates haplotype frequencies
independent of trait.
</p>
</td></tr>
<tr><td><code id="haplo.glm.control_+3A_sum.rare.min">sum.rare.min</code></td>
<td>

<p>the sum of the &quot;rare&quot; haplotype frequencies must be larger than
sum.rare.min in order for the pool of rare haplotypes to be included
in the regression model as a separate term. If this condition
is not met, then the rare haplotypes are pooled with the base-line
haplotype (see keep.rare.haplo below).
</p>
</td></tr>
<tr><td><code id="haplo.glm.control_+3A_haplo.min.info">haplo.min.info</code></td>
<td>

<p>the minimum haplotype frequency for determining the contribution of 
a haplotype to the observed
information matrix. Haplotypes with less frequency are
dropped from the observed information matrix. The haplotype
frequency is that from the final EM that iteratively updates 
haplotype frequencies and regression coefficients. 
</p>
</td></tr>
<tr><td><code id="haplo.glm.control_+3A_keep.rare.haplo">keep.rare.haplo</code></td>
<td>

<p>TRUE/FALSE to determine if the pool of rare haplotype should be kept as a
separate term in the regression model (when keep.rare.haplo=TRUE), or
pooled with the base-line haplotype (when keep.rare.haplo=FALSE).
</p>
</td></tr>
<tr><td><code id="haplo.glm.control_+3A_eps.svd">eps.svd</code></td>
<td>

<p>argument to be passed to Ginv for the generalized inverse of the
information matrix, helps to determine the number of singular values
</p>
</td></tr>
<tr><td><code id="haplo.glm.control_+3A_glm.c">glm.c</code></td>
<td>

<p>list of control parameters for the usual glm.control (see
glm.control).
</p>
</td></tr>
<tr><td><code id="haplo.glm.control_+3A_em.c">em.c</code></td>
<td>

<p>list of control parameters for the EM algorithm to estimate
haplotype frequencies, independent of trait (see haplo.em.control). 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the list of above components
</p>


<h3>See Also</h3>

<p><code><a href="#topic+haplo.glm">haplo.glm</a></code>,
<code><a href="#topic+haplo.em.control">haplo.em.control</a></code>,
<code><a href="stats.html#topic+glm.control">glm.control</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># NOT RUN
# using the data set up in the example for haplo.glm,
# the control function is used in haplo.glm as follows
#  &gt; fit &lt;- haplo.glm(y ~ male + geno, family = gaussian,  
#  &gt;          na.action="na.geno.keep",
#  &gt;          data=my.data, locus.label=locus.label,
#  &gt;          control = haplo.glm.control(haplo.min.count=5,
#  &gt;          em.c=haplo.em.control(n.try=1)))
</code></pre>

<hr>
<h2 id='haplo.group'>
Frequencies for Haplotypes by Grouping Variable
</h2><span id='topic+haplo.group'></span>

<h3>Description</h3>

<p>Calculate maximum likelihood estimates of haplotype probabilities for 
the entire dataset and separately for each subset defined by the
levels of a group variable.  Only autosomal loci are considered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haplo.group(group, geno, locus.label=NA, 
            miss.val=0, weight=NULL, 
            control=haplo.em.control())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="haplo.group_+3A_group">group</code></td>
<td>

<p>Group can be of logical, numeric, character, or factor class type.
</p>
</td></tr>
<tr><td><code id="haplo.group_+3A_geno">geno</code></td>
<td>

<p>Matrix of alleles, such that each locus has a pair of
adjacent columns of alleles, and the order of columns
corresponds to the order of loci on a chromosome.  If
there are K loci, then geno has 2*K columns. Rows represent all
observed alleles for each subject.  
</p>
</td></tr>
<tr><td><code id="haplo.group_+3A_locus.label">locus.label</code></td>
<td>

<p>Vector of labels for loci, of length K (see definition of geno matrix).
</p>
</td></tr>
<tr><td><code id="haplo.group_+3A_miss.val">miss.val</code></td>
<td>

<p>Vector of codes for allele missing values.
</p>
</td></tr>
<tr><td><code id="haplo.group_+3A_weight">weight</code></td>
<td>

<p>weights for observations (rows of geno matrix). One reason to use is
to adjust for disproportionate sample of sub-groups.  Weights only
used in the frequency calculation for the pooled subject.
</p>
</td></tr>
<tr><td><code id="haplo.group_+3A_control">control</code></td>
<td>

<p>list of control parameters for haplo.em (see haplo.em.control).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Haplo.em is used to compute the maximum likelihood estimates of 
the haplotype frequencies for the total sample, then for each of 
the groups separately.  
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>list</code></td>
<td>

<p>A list as an object of the haplo.group class.  The three
elements of the list are described below.
</p>
</td></tr>
<tr><td><code>group.df</code></td>
<td>

<p>A data frame with the columns described as follows.
-haplotype:
Names for the K columns for the K alleles in the haplotypes.
-total:
Estimated frequencies for haplotypes from the total sample.
-group.name.i:
Estimated haplotype frequencies for the haplotype
if it occurs in the group referenced by 'i'.  Frequency is NA 
if it doesn't occur for the group.  The column name is the actual 
variable name joined with the ith level of that variable.
</p>
</td></tr>
<tr><td><code>group.count</code></td>
<td>

<p>Vector containing the number of subjects for each level of the 
grouping variable.
</p>
</td></tr>
<tr><td><code>n.loci</code></td>
<td>

<p>Number of loci occuring in the geno matrix.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Schaid DJ, Rowland CM, Tines DE, Jacobson RM,  Poland  GA.
&quot;Score tests for association of traits with haplotypes when
linkage phase is ambiguous.&quot; Amer J Hum Genet. 70 (2002):  425-434.
</p>


<h3>See Also</h3>

<p>print.haplo.group, haplo.em
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(hla.demo)
  geno &lt;- as.matrix(hla.demo[,c(17,18,21:24)])

# remove any subjects with missing alleles for faster examples, 
# but you may keep them in practice
  keep &lt;- !apply(is.na(geno) | geno==0, 1, any)
  hla.demo &lt;- hla.demo[keep,]
  geno &lt;- geno[keep,]
  attach(hla.demo)
  
  y.ord &lt;- as.numeric(resp.cat)
  y.bin &lt;-ifelse(y.ord==1,1,0)
  group.bin &lt;- haplo.group(y.bin, geno, miss.val=0)
  print.haplo.group(group.bin)
</code></pre>

<hr>
<h2 id='haplo.hash'>
Integer Rank Codes for Haplotypes
</h2><span id='topic+haplo.hash'></span>

<h3>Description</h3>

<p>Create a vector of integer codes for the input  matrix  of
haplotypes.   The haplotypes in the input matrix are
converted to character strings, and if there are C unique
strings, the integer codes for the haplotypes will be 1,
2, ..., C.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haplo.hash(hap)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="haplo.hash_+3A_hap">hap</code></td>
<td>

<p>A matrix of haplotypes. If there are N haplotypes for K
loci, hap have dimensions N x K.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The alleles that make  up  each  row  in  hap  are  pasted
together  as character strings, and the unique strings are
sorted so that the rank order of  the  sorted  strings  is
used as the integer code for the unique haplotypes.
</p>


<h3>Value</h3>

<p>List with elements:
</p>
<table role = "presentation">
<tr><td><code>hash</code></td>
<td>

<p>Vector of integer codes for the input data  (hap).  The
value of hash is the row number of the unique haplotypes
given in the returned matrix hap.mtx.
</p>
</td></tr>
<tr><td><code>hap.mtx</code></td>
<td>

<p>Matrix of unique haplotypes.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>haplo.em
</p>

<hr>
<h2 id='haplo.model.frame'>
Sets up a model frame for haplo.glm
</h2><span id='topic+haplo.model.frame'></span>

<h3>Description</h3>

<p>For internal use within the haplo.stats library
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haplo.model.frame(m, locus.label=NA, control=haplo.glm.control())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="haplo.model.frame_+3A_m">m</code></td>
<td>

<p>model.frame from evaluated formula
</p>
</td></tr>
<tr><td><code id="haplo.model.frame_+3A_locus.label">locus.label</code></td>
<td>

<p>labels for loci in genotype matrix
</p>
</td></tr>
<tr><td><code id="haplo.model.frame_+3A_control">control</code></td>
<td>

<p>control parameters for haplo.glm
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See haplo.glm description in help file and user manual
</p>


<h3>Value</h3>

<p>A model frame with haplotypes modeled as effects
</p>

<hr>
<h2 id='haplo.power.cc'>
Compute either power or sample size for haplotype associations in a
case-control study.
</h2><span id='topic+haplo.power.cc'></span><span id='topic+haplo.power.cc.ncp'></span><span id='topic+find.intercept.logistic'></span>

<h3>Description</h3>

<p>For a given set of haplotypes, their population frequencies, and assumed
logistic regression coefficients (log-odds-ratios per haplotype,
assuming a log-additive model of haplotype effects), determine either
the sample size (total number of subjects) to achieve a stated
power or the power for a stated sample size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haplo.power.cc(haplo, haplo.freq, base.index, haplo.beta, case.frac,
prevalence, alpha, sample.size=NULL, power=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="haplo.power.cc_+3A_haplo">haplo</code></td>
<td>

<p>matrix of haplotypes, with rows the different haplotypes and
columns the alleles of the haplotypes. For H haplotypes of L loci,
haplo has dimension H x L.
</p>
</td></tr>
<tr><td><code id="haplo.power.cc_+3A_haplo.freq">haplo.freq</code></td>
<td>

<p>vector of length H for the population haplotype frequencies
(corresponding to the rows of haplo)
</p>
</td></tr>
<tr><td><code id="haplo.power.cc_+3A_base.index">base.index</code></td>
<td>

<p>integer index of the haplotype considered to be the base-line for
logistic regression (index between 1 and H); often, the most common
haplotype is chosen for the base-line.
</p>
</td></tr>
<tr><td><code id="haplo.power.cc_+3A_haplo.beta">haplo.beta</code></td>
<td>

<p>vector of length H for the haplotype effects: each beta is the 
log-odds-ratio for the corresponding haplotype effect. 
The base-line hapoltype should have a beta=0, as this base-line
beta coefficient will be automatically calculated according to the 
haplotype frequencies, the other haplo.beta's, and the disease prevalence.
</p>
</td></tr>
<tr><td><code id="haplo.power.cc_+3A_case.frac">case.frac</code></td>
<td>

<p>fraction of cases in the total sample size (e.g., case.frac = .5
for typical case-control studies with equal numbers of cases and controls)
</p>
</td></tr>
<tr><td><code id="haplo.power.cc_+3A_prevalence">prevalence</code></td>
<td>

<p>popultaion disease prevalence (used to calculate the base-line
intercept beta)
</p>
</td></tr>
<tr><td><code id="haplo.power.cc_+3A_alpha">alpha</code></td>
<td>

<p>type-I error rate
</p>
</td></tr>
<tr><td><code id="haplo.power.cc_+3A_sample.size">sample.size</code></td>
<td>

<p>total sample size (if power is to be calcualted). Either sample.size or
power must be specified, but not both.
</p>
</td></tr>
<tr><td><code id="haplo.power.cc_+3A_power">power</code></td>
<td>

<p>desired power (if sample.size is to be calculated). Either sample.size
or power must be specified, but not both.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Asympotic power calcuations are based on the non-centrality parameter
of a non-central chi-square distribution. This non-centrality
parameter is determined by the specified regression coefficients
( values in haplo.beta), as well as the distribution of haplotypes
(determined by haplo.freq). To account for haplotypes with unknown
phase, all possible haplotype pairs are enumerated, and the EM
algorithm is used to determine the posterior probabilities of pairs of
haplotypes, conditional on unphased genotype data. Because this
function uses the function haplo.em, the  number of possible
haplotypes can be large when there is a large number of loci (i.e.,
large number of columns in the haplo matrix). If too large, the
function haplo.em will run out of memory, making this function
(haplo.power.cc) fail. If this occurs, then consider reducing the
&quot;size&quot; of the haplotypes, by reducing the number of columns of haplo,
and adjusting the corresponding vectors (e.g., haplo.freq, haplo.beta).
</p>


<h3>Value</h3>

<p>list with components:
</p>
<table role = "presentation">
<tr><td><code>ss.phased.haplo</code></td>
<td>

<p>sample size for phased haplotypes
</p>
</td></tr>
<tr><td><code>ss.unphased.haplo</code></td>
<td>

<p>sample size for unphased haplotypes
</p>
</td></tr>
<tr><td><code>power.phased.haplo</code></td>
<td>

<p>power for phased haplotypes
</p>
</td></tr>
<tr><td><code>power.unphased.haplo</code></td>
<td>

<p>power for unphased haplotypes
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Schaid, DJ. Power and sample size for testing associations of
haplotypes with complex traits. Ann Hum Genet (2005) 70:116-130.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+haplo.em">haplo.em</a></code>
<code><a href="#topic+haplo.power.qt">haplo.power.qt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>haplo &lt;- rbind(
               c(     1,    2,    2,    1,    2),
               c(     1,    2,    2,    1,    1),
               c(     1,    1,    2,    1,    1),
               c(     1,    2,    1,    1,    2),
               c(     1,    2,    2,    2,    1),
               c(     1,    2,    1,    1,    1),
               c(     1,    1,    2,    2,    1),
               c(     1,    1,    1,    1,    2),
               c(     1,    2,    1,    2,    1),
               c(     1,    1,    1,    2,    1),
               c(     2,    2,    1,    1,    2),
               c(     1,    1,    2,    1,    2),
               c(     1,    1,    2,    2,    2),
               c(     1,    2,    2,    2,    2),
               c(     2,    2,    2,    1,    2),
               c(     1,    1,    1,    1,    1),
               c(     2,    1,    1,    1,    1),
               c(     2,    1,    2,    1,    1),
               c(     2,    2,    1,    1,    1),
               c(     2,    2,    1,    2,    1),
               c(     2,    2,    2,    1,    1))
dimnames(haplo)[[2]] &lt;- paste("loc", 1:ncol(haplo), sep=".")
haplo &lt;- data.frame(haplo)

haplo.freq &lt;- c(0.170020121, 0.162977867, 0.123742455, 0.117706237, 0.097585513, 0.084507042,
                0.045271630, 0.039235412, 0.032193159, 0.019114688, 0.019114688, 0.013078471,
                0.013078471, 0.013078471, 0.013078471, 0.006036217, 0.006036217, 0.006036217,
                0.006036217, 0.006036217, 0.006036217)

# define index for risk haplotypes (having alleles 1-1 at loci 2 and 3)
haplo.risk &lt;- (1:nrow(haplo))[haplo$loc.2==1 &amp; haplo$loc.3==1]

# define index for baseline haplotype
base.index &lt;-  1

# specify OR for risk haplotypes
or &lt;- 1.25

# determine beta regression coefficients for risk haplotypes

haplo.beta &lt;- numeric(length(haplo.freq))
haplo.beta[haplo.risk] &lt;-  log(or)

# Note that non-risk haplotypes have beta=0, as does the intercept
# (haplotype with base.index value). 

# Compute total sample size for given power

haplo.power.cc(haplo, haplo.freq, base.index, haplo.beta, case.frac=.5,
prevalence=.1, alpha=.05, power=.8)

# Compute power for given sample size

haplo.power.cc(haplo, haplo.freq, base.index, haplo.beta, case.frac=.5,
prevalence=.1, alpha=.05, sample.size=11978)
</code></pre>

<hr>
<h2 id='haplo.power.qt'>
Compute either power or sample size for haplotype associations with a
quantitative trait.
</h2><span id='topic+haplo.power.qt'></span><span id='topic+haplo.power.qt.ncp'></span>

<h3>Description</h3>

<p>For a given set of haplotypes, their population frequencies, and assumed
linear regression coefficients (additive model of haplotype effects on
a quantitative trait), determine either
the sample size  to achieve a stated
power or the power for a stated sample size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haplo.power.qt(haplo, haplo.freq, base.index, haplo.beta, y.mu, y.var,
alpha, sample.size = NULL, power = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="haplo.power.qt_+3A_haplo">haplo</code></td>
<td>

<p>matrix of haplotypes, with rows the different haplotypes and
columns the alleles of the haplotypes. For H haplotypes of L loci,
haplo has dimension H x L.
</p>
</td></tr>
<tr><td><code id="haplo.power.qt_+3A_haplo.freq">haplo.freq</code></td>
<td>

<p>vector of length H for the population haplotype frequencies
(corresponding to the rows of haplo)
</p>
</td></tr>
<tr><td><code id="haplo.power.qt_+3A_base.index">base.index</code></td>
<td>

<p>integer index of the haplotype considered to be the base-line for
logistic regression (index between 1 and H); often, the most common
haplotype is chosen for the base-line.
</p>
</td></tr>
<tr><td><code id="haplo.power.qt_+3A_haplo.beta">haplo.beta</code></td>
<td>

<p>vector of length H for the haplotype effects: each beta is the 
amount of expected change per haplotype from the base-line average,
and the beta for the base-line (indexed by base.index) is the 
beta for the intercept.
</p>
</td></tr>
<tr><td><code id="haplo.power.qt_+3A_y.mu">y.mu</code></td>
<td>

<p>population mean of quantitative trait, y.
</p>
</td></tr>
<tr><td><code id="haplo.power.qt_+3A_y.var">y.var</code></td>
<td>

<p>popultaion variance of quantitative trait, y.
</p>
</td></tr>
<tr><td><code id="haplo.power.qt_+3A_alpha">alpha</code></td>
<td>

<p>type-I error rate
</p>
</td></tr>
<tr><td><code id="haplo.power.qt_+3A_sample.size">sample.size</code></td>
<td>

<p>sample size (if power is to be calcualted). Either sample.size or power must be specified, but not both.
</p>
</td></tr>
<tr><td><code id="haplo.power.qt_+3A_power">power</code></td>
<td>

<p>desired power (if sample.size is to be calculated). Either sample.size or power must be specified, but not both.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Asympotic power calcuations are based on the non-centrality parameter
of a non-central F distribution. This non-centrality
parameter is determined by the specified regression coefficients
( values in haplo.beta), as well as the distribution of haplotypes
(determined by haplo.freq). To account for haplotypes with unknown
phase, all possible haplotype pairs are enumerated, and the EM
algorithm is used to determine the posterior probabilities of pairs of
haplotypes, conditional on unphased genotype data. Because this
function uses the function haplo.em, the  number of possible
haplotypes can be large when there is a large number of loci (i.e.,
large number of columns in the haplo matrix). If too large, the
function haplo.em will run out of memory, making this function
(haplo.power.qt) fail. If this occurs, then consider reducing the
&quot;size&quot; of the haplotypes, by reducing the number of columns of haplo,
and adjusting the corresponding vectors (e.g., haplo.freq, haplo.beta).
</p>


<h3>Value</h3>

<p>list with components:
</p>
<table role = "presentation">
<tr><td><code>ss.phased.haplo</code></td>
<td>

<p>sample size for phased haplotypes
</p>
</td></tr>
<tr><td><code>ss.unphased.haplo</code></td>
<td>

<p>sample size for unphased haplotypes
</p>
</td></tr>
<tr><td><code>power.phased.haplo</code></td>
<td>

<p>power for phased haplotypes
</p>
</td></tr>
<tr><td><code>power.unphased.haplo</code></td>
<td>

<p>power for unphased haplotypes
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Schaid, DJ. Power and sample size for testing associations of
haplotypes with complex traits. Ann Hum Genet (2005) 70:116-130.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find.haplo.beta.qt">find.haplo.beta.qt</a></code>,
<code><a href="#topic+haplo.em">haplo.em</a></code>,
<code><a href="#topic+haplo.power.cc">haplo.power.cc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>haplo &lt;- rbind(
               c(     1,    2,    2,    1,    2),
               c(     1,    2,    2,    1,    1),
               c(     1,    1,    2,    1,    1),
               c(     1,    2,    1,    1,    2),
               c(     1,    2,    2,    2,    1),
               c(     1,    2,    1,    1,    1),
               c(     1,    1,    2,    2,    1),
               c(     1,    1,    1,    1,    2),
               c(     1,    2,    1,    2,    1),
               c(     1,    1,    1,    2,    1),
               c(     2,    2,    1,    1,    2),
               c(     1,    1,    2,    1,    2),
               c(     1,    1,    2,    2,    2),
               c(     1,    2,    2,    2,    2),
               c(     2,    2,    2,    1,    2),
               c(     1,    1,    1,    1,    1),
               c(     2,    1,    1,    1,    1),
               c(     2,    1,    2,    1,    1),
               c(     2,    2,    1,    1,    1),
               c(     2,    2,    1,    2,    1),
               c(     2,    2,    2,    1,    1))
dimnames(haplo)[[2]] &lt;- paste("loc", 1:ncol(haplo), sep=".")
haplo &lt;- data.frame(haplo)

haplo.freq &lt;- c(0.170020121, 0.162977867, 0.123742455, 0.117706237,
0.097585513, 0.084507042, 0.045271630, 0.039235412, 0.032193159,
0.019114688, 0.019114688, 0.013078471, 0.013078471, 0.013078471,
0.013078471, 0.006036217, 0.006036217, 0.006036217,
0.006036217, 0.006036217, 0.006036217)

# define index for risk haplotypes (having alleles 1-1 at loci 2 and 3)
haplo.risk &lt;- (1:nrow(haplo))[haplo$loc.2==1 &amp; haplo$loc.3==1]

# define index for baseline haplotype
base.index &lt;-  1

# Because it can be easier to speficy genetic effect size in terms of
# a regression model R-squared value (r2), we use an
# auxiliary function to set up haplo.beta based on a specifed r2 value:

tmp &lt;- find.haplo.beta.qt(haplo,haplo.freq,base.index,haplo.risk,
r2=0.01, y.mu=0, y.var=1)

haplo.beta &lt;- tmp$beta  

# Compute sample size for given power

haplo.power.qt(haplo, haplo.freq, base.index, haplo.beta, y.mu=0,
y.var=1, alpha=.05, power=.80) 

# Compute power for given sample size

haplo.power.qt(haplo, haplo.freq, base.index, haplo.beta, y.mu=0,
y.var=1, alpha=.05, sample.size = 2091)  
</code></pre>

<hr>
<h2 id='haplo.scan'>
Search for a trait-locus by sliding a fixed-width window over each marker locus
and scanning all possible haplotype lengths within the window
</h2><span id='topic+haplo.scan'></span><span id='topic+haplo.scan.obs'></span><span id='topic+haplo.scan.sim'></span>

<h3>Description</h3>

<p>Search for haplotypes that have the strongest association with a
binary trait (typically case/control status) by sliding a fixed-width
window over each marker locus and scanning all possible haplotype
lengths within the window. For each haplotype length, a score
statistic is computed to compare the set of haplotypes with a given
length between cases versus controls. The locus-specific score statistic 
is the maximum score statistic calculated on loci containing
that locus.  The maximum score statistic over all haplotype lengths
within all possible windows is used for a global test for association.
Permutations of the trait are used to compute p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haplo.scan(y, geno, width=4, miss.val=c(0, NA),
          em.control=haplo.em.control(),
          sim.control=score.sim.control())

haplo.scan.obs(y, em.obj, width)

haplo.scan.sim(y.reord, save.lst, nloci)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="haplo.scan_+3A_y">y</code></td>
<td>

<p>Vector of binary trait values, must be 1 for cases and 0 for controls.
</p>
</td></tr>
<tr><td><code id="haplo.scan_+3A_y.reord">y.reord</code></td>
<td>

<p>Same as y, except the order is permuted
</p>
</td></tr>
<tr><td><code id="haplo.scan_+3A_geno">geno</code></td>
<td>

<p>Matrix of alleles, such that each locus has a pair of adjacent
columns of alleles, and the order of columns corresponds to the
order of loci on a chromosome. If there are K loci, then 
ncol(geno) = 2*K. Rows represent alleles for each subject.
</p>
</td></tr>
<tr><td><code id="haplo.scan_+3A_width">width</code></td>
<td>

<p>Width of sliding the window
</p>
</td></tr>
<tr><td><code id="haplo.scan_+3A_miss.val">miss.val</code></td>
<td>

<p>Vector of codes for missing values of alleles
</p>
</td></tr>
<tr><td><code id="haplo.scan_+3A_em.control">em.control</code></td>
<td>

<p>A list of control parameters to determine how to perform the EM
algorithm for estimating haplotype frequencies when phase is  
unknown. The list is created by the function haplo.em.control -
see this function for more details.
</p>
</td></tr>
<tr><td><code id="haplo.scan_+3A_sim.control">sim.control</code></td>
<td>

<p>A list of control parameters to determine how simulations are
performed for simulated p-values. The list is created by the
function score.sim.control and the default values of this
function can be changed as desired. See score.sim.control for
details.
</p>
</td></tr>
<tr><td><code id="haplo.scan_+3A_em.obj">em.obj</code></td>
<td>

<p>Object returned from haplo.em, performed on geno
</p>
</td></tr>
<tr><td><code id="haplo.scan_+3A_save.lst">save.lst</code></td>
<td>

<p>Information on haplotypes needed for haplo.scan.sim, already
calculated in haplo.scan
</p>
</td></tr>
<tr><td><code id="haplo.scan_+3A_nloci">nloci</code></td>
<td>

<p>number of markers
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Search for a region for which the haplotypes have the strongest
association with a binary trait by sliding a window of fixed width
over each marker locus, and considering all haplotype lengths within
each window. To acount for unknown linkage phase, the function haplo.em is
called prior to scanning, to create a list of haplotype pairs and 
posterior probabilities. To illustrate the scanning, consider a 10-locus
dataset. When placing a window of width 3 over locus 5, the possible 
haplotype lengths that contain locus 5 are three (loci 3-4-5,
4-5-6, and 5-6-7), two (loci 4-5, and 5-6) and one (locus 5).  
For each of these loci subsets a score statistic is computed, which is
based on the difference between the mean vector of haplotype counts
for cases and that for controls. The maximum of these score
statistics, over all possible haplotype lengths within a window, is 
the locus-specific test statistic. The global test statistic is the 
maximum over all computed score statistics. To compute p-values, 
the case/control status is randomly permuted.  Simulations are
performed until precision criteria are met for all p-values; the
criteria are controlled by score.sim.control. See the note for long run
times.
</p>


<h3>Value</h3>

<p>A list that has class haplo.scan, which contains the following items:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>

<p>The call to haplo.scan
</p>
</td></tr>
<tr><td><code>scan.df</code></td>
<td>

<p>A data frame containing the maximum test statistic for each window
around each locus, and its simulated p-value.
</p>
</td></tr>
<tr><td><code>max.loc</code></td>
<td>

<p>The loci (locus) which contain(s) the maximum observed test statistic
over all haplotype lengths and all windows.
</p>
</td></tr>
<tr><td><code>globalp</code></td>
<td>

<p>A p-value for the significance of the global maximum statistic.
</p>
</td></tr>
<tr><td><code>nsim</code></td>
<td>

<p>Number of simulations performed
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For datasets with many estimated haplotypes, the run-time can be very long.
</p>


<h3>References</h3>


<dl>
<dt>Cheng et al-1</dt><dd><p>Cheng R, Ma JZ, Wright FA, Lin S, Gau X, Wang
D, Elston RC, Li MD. &quot;Nonparametric disequilibrium mapping of
functional sites using haplotypes of multiple tightly linked
single-nucleotide polymorphism markers&quot;. Genetics 164
(2003):1175-1187.</p>
</dd> 
<dt>Cheng et al-2</dt><dd><p>Cheng R, Ma JZ, Elston RC, Li MD.  &quot;Fine Mapping Functional Sites or
Regions from Case-Control Data Using Haplotypes of Multiple
Linked SNPs.&quot;  Annals of Human Genetics 69 (2005): 102-112. 
</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+haplo.em">haplo.em</a></code>,
<code><a href="#topic+haplo.em.control">haplo.em.control</a></code>,
<code><a href="#topic+score.sim.control">score.sim.control</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # create a random genotype matrix with 10 loci, 50 cases, 50 controls
  set.seed(1)
  tmp &lt;- ifelse(runif(2000)&gt;.3, 1, 2)
  geno &lt;- matrix(tmp, ncol=20)
  y &lt;- rep(c(0,1),c(50,50))

  # search 10-locus region, typically don't limit the number of
  # simulations, but run time can get long with many simulations

  scan.obj &lt;- haplo.scan(y, geno, width=3,
                sim.control = score.sim.control(min.sim=10, max.sim=20))

  print(scan.obj)
</code></pre>

<hr>
<h2 id='haplo.score'>
Score Statistics for Association of Traits with Haplotypes
</h2><span id='topic+haplo.score'></span>

<h3>Description</h3>

<p>Compute score statistics to evaluate the association of a trait
with haplotypes, when linkage phase is unknown and diploid marker 
phenotypes are observed among unrelated subjects. For now, only 
autosomal loci are considered.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haplo.score(y, geno, trait.type="gaussian", offset = NA, x.adj = NA,
            min.count=5, skip.haplo=min.count/(2*nrow(geno)),
            locus.label=NA, miss.val=c(0,NA), haplo.effect="additive",
            eps.svd=1e-5, simulate=FALSE, sim.control=score.sim.control(),
            em.control=haplo.em.control())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="haplo.score_+3A_y">y</code></td>
<td>

<p>Vector of trait values. For trait.type = &quot;binomial&quot;, y must 
have values of 1 for event, 0 for no event.
</p>
</td></tr>
<tr><td><code id="haplo.score_+3A_geno">geno</code></td>
<td>

<p>Matrix of alleles, such that each locus has a pair of
adjacent columns of alleles, and the order of columns
corresponds to the order of loci on a chromosome.  If
there are K loci, then ncol(geno) = 2*K. Rows represent
alleles for each subject.
</p>
</td></tr>
<tr><td><code id="haplo.score_+3A_trait.type">trait.type</code></td>
<td>

<p>Character string defining type of trait, with values of 
&quot;gaussian&quot;, &quot;binomial&quot;, &quot;poisson&quot;, &quot;ordinal&quot;.
</p>
</td></tr>
<tr><td><code id="haplo.score_+3A_offset">offset</code></td>
<td>

<p>Vector of offset when trait.type = &quot;poisson&quot;
</p>
</td></tr>
<tr><td><code id="haplo.score_+3A_x.adj">x.adj</code></td>
<td>

<p>Matrix of non-genetic covariates used to adjust the score 
statistics.  Note that intercept should not be included, 
as it will be added in this function.
</p>
</td></tr>
<tr><td><code id="haplo.score_+3A_min.count">min.count</code></td>
<td>

<p>The minimum number of counts for a haplotype to be included in the
model.  First, the haplotypes selected to score are chosen by minimum
frequency greater than skip.haplo (based on min.count, by default).
It is also used when haplo.effect is either dominant or
recessive. This is explained best in the recessive instance, where
only subjects who are homozygous for a haplotype will contribute
information to the score for that haplotype.  If fewer than min.count
subjects are estimated to be affected by that haplotype, it is not
scored.  A warning is issued if no haplotypes can be scored.
</p>
</td></tr>
<tr><td><code id="haplo.score_+3A_skip.haplo">skip.haplo</code></td>
<td>

<p>Minimum haplotype frequency for which haplotypes are scored in the model.
By default, the frequency is based on &quot;min.count&quot; divided by the 2*N total haplotype 
occurrences in the sample.
</p>
</td></tr>
<tr><td><code id="haplo.score_+3A_locus.label">locus.label</code></td>
<td>

<p>Vector of labels for loci, of length K (see definition of geno matrix)
</p>
</td></tr>
<tr><td><code id="haplo.score_+3A_miss.val">miss.val</code></td>
<td>

<p>Vector of codes for missing values of alleles
</p>
</td></tr>
<tr><td><code id="haplo.score_+3A_haplo.effect">haplo.effect</code></td>
<td>

<p>the &quot;effect&quot; of a haplotypes, which determines the covariate (x)
coding of haplotypes. Valid options are &quot;additive&quot; (causing x = 0,
1, or 2, the count of a  particular haplotype), &quot;dominant&quot; (causing
x = 1 if heterozygous or homozygous carrier of a particular
haplotype; x = 0 otherwise), and &quot;recessive&quot; (causing x = 1 if
homozygous for a particular haplotype; x = 0 otherwise).
</p>
</td></tr>
<tr><td><code id="haplo.score_+3A_eps.svd">eps.svd</code></td>
<td>

<p>epsilon value for singular value cutoff; to be used in the generalized
inverse calculation on the variance matrix of the score vector (see
help(Ginv) for details).  
</p>
</td></tr>
<tr><td><code id="haplo.score_+3A_simulate">simulate</code></td>
<td>

<p>Logical:  if FALSE, no empirical p-values are computed; if TRUE,
simulations are performed. Specific simulation parameters
can be controlled in the sim.control parameter list.  
</p>
</td></tr>
<tr><td><code id="haplo.score_+3A_sim.control">sim.control</code></td>
<td>

<p>A list of control parameters to determine how simulations are
performed for simulated p-values.  The list is created by the function
score.sim.control and the default values of this function can be
changed as desired.  See score.sim.control for details.
</p>
</td></tr>
<tr><td><code id="haplo.score_+3A_em.control">em.control</code></td>
<td>

<p>A list of control parameters to determine how to perform the EM
algorithm for estimating haplotype frequencies when phase is unknown.
The list is created by the function haplo.em.control - see this function
for more details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute the maximum likelihood estimates of the haplotype frequencies
and the posterior probabilities of the pairs of haplotypes for each
subject using an EM algorithm. The algorithm begins with haplotypes
from a subset of the loci and progressively discards those with low
frequency before inserting more loci.  The process is repeated until
haplotypes for all loci are established.  The posterior probabilities
are used to compute the score statistics for the association of
(ambiguous) haplotypes with traits. The glm function is used to
compute residuals of the regression of the trait on the non-genetic
covariates.  
</p>


<h3>Value</h3>

<p>List with the following components:
</p>
<table role = "presentation">
<tr><td><code>score.global</code></td>
<td>

<p>Global statistic to test association of trait with 
haplotypes that have frequencies &gt;= skip.haplo.
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>Degrees of freedom for score.global.
</p>
</td></tr>
<tr><td><code>score.global.p</code></td>
<td>

<p>P-value of score.global based on chi-square distribution, 
with degrees of freedom equal to df.
</p>
</td></tr>
<tr><td><code>score.global.p.sim</code></td>
<td>

<p>P-value of score.global based on simulations
(set equal to NA when simulate=F).
</p>
</td></tr>
<tr><td><code>score.haplo</code></td>
<td>

<p>Vector of score statistics for individual
haplotypes that have frequencies &gt;= skip.haplo.
</p>
</td></tr>
<tr><td><code>score.haplo.p</code></td>
<td>

<p>Vector of p-values for score.haplo, based on a
chi-square distribution with 1 df.
</p>
</td></tr>
<tr><td><code>score.haplo.p.sim</code></td>
<td>

<p>Vector of p-values for score.haplo, based on
simulations (set equal to NA when simulate=F).
</p>
</td></tr>
<tr><td><code>score.max.p.sim</code></td>
<td>

<p>Simulated p-value indicating for simulations the number of times a 
maximum score.haplo value exceeds the maximum score.haplo from the
original data (equal to NA when simulate=F).
</p>
</td></tr>
<tr><td><code>haplotype</code></td>
<td>

<p>Matrix of hapoltypes  analyzed.  The ith row of
haplotype corresponds to the ith item of score.haplo,
score.haplo.p, and score.haplo.p.sim.
</p>
</td></tr>
<tr><td><code>hap.prob</code></td>
<td>

<p>Vector of haplotype probabilies, corresponding to the
haplotypes in the matrix haplotype.
</p>
</td></tr>
<tr><td><code>locus.label</code></td>
<td>

<p>Vector of labels for loci, of length  K  (same  as
input argument).
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>The call to the haplo.score function; useful for recalling what
parameters were used.
</p>
</td></tr>
<tr><td><code>haplo.effect</code></td>
<td>

<p>The haplotype effect model parameter that was selected for haplo.score.
</p>
</td></tr>
<tr><td><code>simulate</code></td>
<td>

<p>Same as function input parameter.  If [T]rue, simulation results are
included in the haplo.score object.
</p>
</td></tr>
<tr><td><code>n.val.global</code></td>
<td>

<p>Vector containing the number of valid simulations used in the
global score statistic simulation. The number of valid simulations can
be less than the number of simulations requested (by sim.control)
if simulated data sets produce unstable variances of the score
statistics.  
</p>
</td></tr>
<tr><td><code>n.val.haplo</code></td>
<td>

<p>Vector containing the number of valid simulations used in the p-value
simulations for maximum-score statistic and scores for the individual
haplotypes.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Schaid DJ, Rowland CM, Tines DE, Jacobson RM,  Poland  GA.
&quot;Score tests for association of traits with haplotypes when
linkage phase is ambiguous.&quot; Amer J Hum Genet. 70 (2002):  425-434.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+haplo.em">haplo.em</a></code>,
<code><a href="#topic+plot.haplo.score">plot.haplo.score</a></code>,
<code><a href="#topic+print.haplo.score">print.haplo.score</a></code>,
<code><a href="#topic+haplo.em.control">haplo.em.control</a></code>,
<code><a href="#topic+score.sim.control">score.sim.control</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # establish all hla.demo data, 
  # remove genotypes with missing alleles just so haplo.score runs faster 
  # with missing values included, this example takes 2-4 minutes
  # FOR REGULAR USAGE, DO NOT DISCARD GENOTYPES WITH MISSING VALUES

  data(hla.demo)
  geno &lt;- as.matrix(hla.demo[,c(17,18,21:24)])
  keep &lt;- !apply(is.na(geno) | geno==0, 1, any)
  hla.demo &lt;- hla.demo[keep,]
  geno &lt;- geno[keep,]
  attach(hla.demo)
  label &lt;- c("DQB","DRB","B")
 
# For quantitative, normally distributed trait:

  score.gaus &lt;- haplo.score(resp, geno, locus.label=label, 
                            trait.type = "gaussian")
  print(score.gaus)

# For ordinal trait:
  y.ord &lt;- as.numeric(resp.cat)
  score.ord &lt;- haplo.score(y.ord, geno, locus.label=label,
                           trait.type="ordinal")
  print(score.ord)

# For a  binary trait and simulations,
# limit simulations to 500 in score.sim.control, default is 20000
  y.bin &lt;-ifelse(y.ord==1,1,0)
  score.bin.sim &lt;- haplo.score(y.bin, geno, trait.type = "binomial",
                     locus.label=label, simulate=TRUE,
                     sim.control=score.sim.control(min.sim=200,max.sim=500))

  print(score.bin.sim)

# For a binary trait, adjusted for sex and age:

  x &lt;- cbind(male, age)
  score.bin.adj &lt;- haplo.score(y.bin, geno, trait.type = "binomial", 
                               locus.label=label, x.adj=x)
  print(score.bin.adj)
</code></pre>

<hr>
<h2 id='haplo.score.merge'>
Merge haplo.score And haplo.group Objects
</h2><span id='topic+haplo.score.merge'></span>

<h3>Description</h3>

<p>Combine information from returned objects of haplo.score and 
haplo.group, 'score' and 'group' respectively.  'score' and
'group' are sorted differently and 'score' keeps a subset of 
all the haplotypes while 'group' has all of them.  To combine
results from the two objects, merge them by haplotype and sort 
by score of the haplotype. The merged object includes all haplotypes; 
i.e. those appearing in 'group', but the print default only shows 
haplotypes which have a score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haplo.score.merge(score, group)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="haplo.score.merge_+3A_score">score</code></td>
<td>

<p>Object returned from haplo.score of class &quot;haplo.score&quot;. 
</p>
</td></tr>
<tr><td><code id="haplo.score.merge_+3A_group">group</code></td>
<td>

<p>Object returned from haplo.group of class &quot;haplo.group&quot;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Haplo.score returns score statistic and p-value for haplotypes with
an overall frequency above the user-specified threshold, skip.haplo.  
For haplotypes with frequencies below the threshold, the score and 
p-value will be NA.  Overall haplotype frequencies and for sub-groups
are estimated by haplo.group.    
</p>


<h3>Value</h3>

<p>Data frame including haplotypes, score-statistics, score p-value, 
estimated haplotype frequency for all subjects, and haplotype 
frequency from group subsets.
</p>


<h3>Side Effects</h3>

<p>Warning:  The merge will not detect if the group and score objects
resulted from different subject phenotypes selected by memory-usage
parameters, rm.geno.na and enum.limit.  Users must use the same values
for these parameters in haplo.score and haplo.group so the merged
objects are consistent.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+haplo.score">haplo.score</a></code>,
<code><a href="#topic+haplo.group">haplo.group</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(hla.demo)
  geno &lt;- as.matrix(hla.demo[,c(17,18,21:24)])
  keep &lt;- !apply(is.na(geno) | geno==0, 1, any)
  hla.demo &lt;- hla.demo[keep,]
  geno &lt;- geno[keep,]
  attach(hla.demo)
  y.ord &lt;- as.numeric(resp.cat)
  y.bin &lt;-ifelse(y.ord==1,1,0)
  
  group.bin &lt;- haplo.group(y.bin, geno, miss.val=0)
  score.bin &lt;- haplo.score(y.bin, geno, trait.type="binomial")
  score.merged &lt;- haplo.score.merge(score.bin, group.bin)

  print(score.merged)
</code></pre>

<hr>
<h2 id='haplo.score.slide'>
Score Statistics for Association of Traits with Haplotypes
</h2><span id='topic+haplo.score.slide'></span>

<h3>Description</h3>

<p>Used to identify sub-haplotypes from a group of loci.  Run haplo.score
on all contiguous subsets of size n.slide from the loci in a genotype
matrix (geno).  From each call to haplo.score, report the global score
statistic p-value. Can also report global and maximum score statistics
simulated p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haplo.score.slide(y, geno, trait.type="gaussian", n.slide=2,
                  offset = NA, x.adj = NA, min.count=5,
                  skip.haplo=min.count/(2*nrow(geno)),
                  locus.label=NA, miss.val=c(0,NA),
                  haplo.effect="additive", eps.svd=1e-5,
                  simulate=FALSE, sim.control=score.sim.control(),
                  em.control=haplo.em.control())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="haplo.score.slide_+3A_y">y</code></td>
<td>

<p>Vector of trait values. For trait.type = &quot;binomial&quot;, y must 
have values of 1 for event, 0 for no event.
</p>
</td></tr>
<tr><td><code id="haplo.score.slide_+3A_geno">geno</code></td>
<td>

<p>Matrix of alleles, such that each locus has a pair of
adjacent columns of alleles, and the order of columns
corresponds to the order of loci on a chromosome.  If
there are K loci, then ncol(geno) = 2*K. Rows represent
alleles for each subject.
</p>
</td></tr>
<tr><td><code id="haplo.score.slide_+3A_trait.type">trait.type</code></td>
<td>

<p>Character string defining type of trait, with values of 
&quot;gaussian&quot;, &quot;binomial&quot;, &quot;poisson&quot;, &quot;ordinal&quot;.
</p>
</td></tr>
<tr><td><code id="haplo.score.slide_+3A_n.slide">n.slide</code></td>
<td>

<p>Number of loci in each contiguous subset.  The first subset is the ordered
loci numbered 1 to n.slide, the second subset is 2 through n.slide+1
and so on.  If the total number of loci in geno is n.loci, then there
are n.loci - n.slide + 1 total subsets.
</p>
</td></tr>
<tr><td><code id="haplo.score.slide_+3A_offset">offset</code></td>
<td>

<p>Vector of offset when trait.type = &quot;poisson&quot;
</p>
</td></tr>
<tr><td><code id="haplo.score.slide_+3A_x.adj">x.adj</code></td>
<td>

<p>Matrix of non-genetic covariates used to adjust the score 
statistics.  Note that intercept should not be included, 
as it will be added in this function. 
</p>
</td></tr>
<tr><td><code id="haplo.score.slide_+3A_min.count">min.count</code></td>
<td>

<p>The minimum number of counts for a haplotype to be included in the
model.  First, the haplotypes selected to score are chosen by minimum
frequency greater than skip.haplo (based on min.count, by default).
It is also used when haplo.effect is either dominant or
recessive. This is explained best in the recessive instance, where
only subjects who are homozygous for a haplotype will contribute
information to the score for that haplotype.  If fewer than min.count
subjects are estimated to be affected by that haplotype, it is not
scored.  A warning is issued if no haplotypes can be scored.
</p>
</td></tr>
<tr><td><code id="haplo.score.slide_+3A_skip.haplo">skip.haplo</code></td>
<td>

<p>For haplotypes with frequencies &lt; skip.haplo, categorize them into a common
group of rare haplotypes.
</p>
</td></tr>
<tr><td><code id="haplo.score.slide_+3A_locus.label">locus.label</code></td>
<td>

<p>Vector of labels for loci, of length K (see definition of geno matrix).
</p>
</td></tr>
<tr><td><code id="haplo.score.slide_+3A_miss.val">miss.val</code></td>
<td>

<p>Vector of codes for missing values of alleles.
</p>
</td></tr>
<tr><td><code id="haplo.score.slide_+3A_haplo.effect">haplo.effect</code></td>
<td>

<p>The &quot;effect&quot; pattern of haplotypes on the response. This parameter
determines the coding for scoring the haplotypes. 
Valid coding options for heterozygous and homozygous carriers of a
haplotype are &quot;additive&quot; (1, 2, respectively), &quot;dominant&quot; (1,1,
respectively), and &quot;recessive&quot; (0, 1, respectively).
</p>
</td></tr>
<tr><td><code id="haplo.score.slide_+3A_eps.svd">eps.svd</code></td>
<td>

<p>epsilon value for singular value cutoff; to be used in the generalized
inverse calculation on the variance matrix of the score vector. 
</p>
</td></tr>
<tr><td><code id="haplo.score.slide_+3A_simulate">simulate</code></td>
<td>

<p>Logical, if [F]alse (default) no empirical p-values are computed.
If [T]rue simulations are performed.  Specific simulation parameters
can be controlled in the sim.control parameter list.
</p>
</td></tr>
<tr><td><code id="haplo.score.slide_+3A_sim.control">sim.control</code></td>
<td>

<p>A list of control parameters used to perform simulations for simulated
p-values in haplo.score.  The list is created by the function
score.sim.control and the default values of this function can be
changed as desired.
</p>
</td></tr>
<tr><td><code id="haplo.score.slide_+3A_em.control">em.control</code></td>
<td>

<p>A list of control parameters used to perform the em algorithm for
estimating haplotype frequencies when phase is unknown.  The list is
created by the function haplo.em.control and the default values of
this function can be changed as desired.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Haplo.score.slide is useful for a series of loci where little is
known of the association between a trait and haplotypes.  Using a
range of n.slide values, the region with the strongest association
will consistently have low p-values for locus subsets containing the
associated haplotypes.  The global p-value measures significance 
of the entire set of haplotypes for the locus subset.  Simulated
maximum score statistic p-values indicate when one or a few haplotypes
are associated with the trait.
</p>


<h3>Value</h3>

<p>List with the following components:
</p>
<table role = "presentation">
<tr><td><code>df</code></td>
<td>

<p>Data frame with start locus, global p-value, simulated global p-value,
and simulated maximum-score p-value.
</p>
</td></tr>
<tr><td><code>n.loci</code></td>
<td>

<p>Number of loci given in the genotype matrix.
</p>
</td></tr>
<tr><td><code>simulate</code></td>
<td>

<p>Same as parameter description above.
</p>
</td></tr>
<tr><td><code>haplo.effect</code></td>
<td>

<p>The haplotype effect model parameter that was selected for haplo.score.
</p>
</td></tr>
<tr><td><code>n.slide</code></td>
<td>

<p>Same as parameter description above.
</p>
</td></tr>
<tr><td><code>locus.label</code></td>
<td>

<p>Same as parameter description above.
</p>
</td></tr>
<tr><td><code>n.val.haplo</code></td>
<td>

<p>Vector containing the number of valid simulations used in the
maximum-score statistic p-value simulation.  The number of valid simulations
can be less than the number of simulations requested (by sim.control)
if simulated data sets produce unstable variables of the score
statistics. 
</p>
</td></tr>
<tr><td><code>n.val.global</code></td>
<td>

<p>Vector containing the number of valid simulations used in the
global score statistic p-value simulation.  
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Schaid DJ, Rowland CM, Tines DE, Jacobson RM,  Poland  GA.
&quot;Score tests for association of traits with haplotypes when
linkage phase is ambiguous.&quot; Amer J Hum Genet. 70 (2002):  425-434.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+haplo.score">haplo.score</a></code>,
<code><a href="#topic+plot.haplo.score.slide">plot.haplo.score.slide</a></code>,
<code><a href="#topic+score.sim.control">score.sim.control</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(hla.demo)

# Continuous trait slide by 2 loci on all 11 loci, uncomment to run it.
# Takes &gt; 20 minutes to run
#  geno.11 &lt;- hla.demo[,-c(1:4)]
#  label.11 &lt;- c("DPB","DPA","DMA","DMB","TAP1","TAP2","DQB","DQA","DRB","B","A")
#  slide.gaus &lt;- haplo.score.slide(hla.demo$resp, geno.11, trait.type = "gaussian",
#                                  locus.label=label.11, n.slide=2)

#  print(slide.gaus)
#  plot(slide.gaus)

# Run shortened example on 9 loci 
# For an ordinal trait, slide by 3 loci, and simulate p-values:
#  geno.9 &lt;- hla.demo[,-c(1:6,15,16)]
#  label.9 &lt;- c("DPA","DMA","DMB","TAP1","DQB","DQA","DRB","B","A")

#  y.ord &lt;- as.numeric(hla.demo$resp.cat)

# data is set up, to run, run these lines of code on the data that was
# set up in this example. It takes &gt; 15 minutes to run
#  slide.ord.sim &lt;-  haplo.score.slide(y.ord, geno.9, trait.type = "ordinal",
#                      n.slide=3, locus.label=label.9, simulate=TRUE,
#                      sim.control=score.sim.control(min.sim=200, max.sim=500))

  # note, results will vary due to simulations
#  print(slide.ord.sim)
#  plot(slide.ord.sim)
#  plot(slide.ord.sim, pval="global.sim")
#  plot(slide.ord.sim, pval="max.sim")
</code></pre>

<hr>
<h2 id='hapPower.demo'>  Set of haplotypes and frequencies for power and sample size
calculations </h2><span id='topic+hapPower.demo'></span>

<h3>Description</h3>

<p>An example set of haplotypes and frequencies for power and sample size
calculations in haplo.power.cc and haplo.power.qt
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hapPower.demo)</code></pre>


<h3>Format</h3>

<p>A data frame with 21 observations on the following 6 variables.
</p>

<dl>
<dt><code>loc.1</code></dt><dd><p>allele 1 in the haplotype </p>
</dd>
<dt><code>loc.2</code></dt><dd><p>allele 2 in the haplotype </p>
</dd>
<dt><code>loc.3</code></dt><dd><p>allele 3 in the haplotype </p>
</dd>
<dt><code>loc.4</code></dt><dd><p>allele 4 in the haplotype </p>
</dd>
<dt><code>loc.5</code></dt><dd><p>allele 5 in the haplotype </p>
</dd>
<dt><code>haplo.freq</code></dt><dd><p>numeric, frequency of haplotype</p>
</dd>
</dl>



<h3>References</h3>

<p>Schaid, DJ. Power and sample size for testing associations of
haplotypes with complex traits. <em>Ann Hum Genet</em> (2005) 70:116-130.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hapPower.demo)
</code></pre>

<hr>
<h2 id='hla.demo'> HLA Loci and Serologic Response to Measles Vaccination  </h2><span id='topic+hla.demo'></span>

<h3>Description</h3>

<p>A data frame with genotypes at eleven HLA-region loci genotyped for
220 subjects, phase not known. Contains measles vaccination response
with covariate data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hla.demo)</code></pre>


<h3>Format</h3>

<p>A data frame with 220 observations on the following 26 variables.
</p>

<dl>
<dt><code>resp</code></dt><dd><p>numeric, Quantitative response to Measles Vaccination</p>
</dd>
<dt><code>resp.cat</code></dt><dd><p>Category of vaccination response, a factor with levels <code>high</code> <code>low</code> <code>normal</code></p>
</dd>
<dt><code>male</code></dt><dd><p>numeric, indicator of gener, 1=male, 0=female</p>
</dd>
<dt><code>age</code></dt><dd><p>numeric, subject's age</p>
</dd>
<dt><code>DPB.a1</code></dt><dd><p>first allele of genotype </p>
</dd>
<dt><code>DPB.a2</code></dt><dd><p>second allele of genotype </p>
</dd>
<dt><code>DPA.a1</code></dt><dd><p>first allele of genotype </p>
</dd>
<dt><code>DPA.a2</code></dt><dd><p>second allele of genotype</p>
</dd>
<dt><code>DMA.a1</code></dt><dd><p>first allele of genotype</p>
</dd>
<dt><code>DMA.a2</code></dt><dd><p>second allele of genotype</p>
</dd>
<dt><code>DMB.a1</code></dt><dd><p>first allele of genotype</p>
</dd>
<dt><code>DMB.a2</code></dt><dd><p>second allele of genotype</p>
</dd>
<dt><code>TAP1.a1</code></dt><dd><p>first allele of genotype </p>
</dd>
<dt><code>TAP1.a2</code></dt><dd><p> second allele of genotype</p>
</dd>
<dt><code>TAP2.a1</code></dt><dd><p>first allele of genotype </p>
</dd>
<dt><code>TAP2.a2</code></dt><dd><p>second allele of genotype </p>
</dd>
<dt><code>DQB.a1</code></dt><dd><p>first allele of genotype</p>
</dd>
<dt><code>DQB.a2</code></dt><dd><p>second allele of genotype</p>
</dd>
<dt><code>DQA.a1</code></dt><dd><p>first allele of genotype</p>
</dd>
<dt><code>DQA.a2</code></dt><dd><p>second allele of genotype</p>
</dd>
<dt><code>DRB.a1</code></dt><dd><p>first allele of genotype</p>
</dd>
<dt><code>DRB.a2</code></dt><dd><p>second allele of genotype</p>
</dd>
<dt><code>B.a1</code></dt><dd><p>first allele of genotype</p>
</dd>
<dt><code>B.a2</code></dt><dd><p>second allele of genotype</p>
</dd>
<dt><code>A.a1</code></dt><dd><p>first allele of genotype</p>
</dd>
<dt><code>A.a2</code></dt><dd><p>second allele of genotype</p>
</dd>
</dl>



<h3>Source</h3>

<p>Data set kindly provided by Gregory A. Poland, M.D. and the Mayo
Clinic Vaccine Research Group for illustration only, and my not be
used for publication.
</p>


<h3>References</h3>

<p>Schaid DJ, Rowland CM, Tines DE, Jacobson RM,  Poland  GA.
&quot;Score tests for association of traits with haplotypes when
linkage phase is ambiguous.&quot; Amer J Hum Genet. 70 (2002):  425-434.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hla.demo)
</code></pre>

<hr>
<h2 id='locator.haplo'>
Find Location from Mouse Clicks and Print Haplotypes on Plot
</h2><span id='topic+locator.haplo'></span>

<h3>Description</h3>

<p>Much like the R/Splus locator function is used to find x-y coordinates
on a plot.  Find all x-y coordinates that are chosen by the user's
mouse clicks.  Then print haplotype labels at the chosen positions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locator.haplo(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="locator.haplo_+3A_obj">obj</code></td>
<td>

<p>An object (of class haplo.score) that is returned from haplo.score.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After plotting the results in obj, as from plot(obj), the function
locator.haplo is used to place on the plot the text strings for
haplotypes of interest. After the function call (e.g.,
locator.haplo(obj)), the user can click, with the left mouse button,
on as many points in the plot as desired. Then, clicking with the
middle mouse button will cause the haplotypes to be printed on the
plot. The format of a haplotype is &quot;a:b:c&quot;, where a, b, and c are
alleles, and the separator &quot;:&quot; is used to separate alleles on a
haplotype. The algorithm chooses the closest point that the user
clicks on, and prints the haplotype either above the point (for points
on the lower-half of the plot) or below the point (for points in the
upper-half of the plot).
</p>


<h3>Value</h3>

<p>List with the following components:
</p>
<table role = "presentation">
<tr><td><code>x.coord</code></td>
<td>

<p>Vector of x-coordinates.
</p>
</td></tr>
<tr><td><code>y.coord</code></td>
<td>

<p>Vector of y-coordinates.
</p>
</td></tr>
<tr><td><code>hap.txt</code></td>
<td>

<p>Vector of character strings for haplotypes.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+haplo.score">haplo.score</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># follow the pseudo-code
#  score.out &lt;-  haplo.score(y, geno, trait.type = "gaussian")

#  plot(score.out)

#  locator.haplo(score.out)
</code></pre>

<hr>
<h2 id='locus'>
Creates an object of class &quot;locus&quot;
</h2><span id='topic+locus'></span>

<h3>Description</h3>

<p>Creates an object containing genotypes for multiple individuals. The object can then use method functions developed for
objects of class &quot;locus&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locus(allele1, allele2, chrom.label=NULL,locus.alias=NULL,
     x.linked=FALSE, sex=NULL, male.code="M", female.code="F", miss.val=NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="locus_+3A_allele1">allele1</code></td>
<td>

<p>A vector containing the labels for 1 allele for a set of individuals, or optionally a matrix with 2 columns each containing an allele for each person.
</p>
</td></tr>
<tr><td><code id="locus_+3A_allele2">allele2</code></td>
<td>

<p>A vector containing the labels for the second allele for a set of individuals.  If allele 1 is a matrix, allele 2 need not be specified.
</p>
</td></tr>
<tr><td><code id="locus_+3A_chrom.label">chrom.label</code></td>
<td>

<p>A label describing the chromosome the alleles belong to
</p>
</td></tr>
<tr><td><code id="locus_+3A_locus.alias">locus.alias</code></td>
<td>

<p>A vector containing one or more aliases describing the locus. The
first alias in the vector will be used as a label for printing in
some functions such as multilocus.print().  
</p>
</td></tr>
<tr><td><code id="locus_+3A_x.linked">x.linked</code></td>
<td>

<p>A logical value denoting whether the chromosome is x linked
</p>
</td></tr>
<tr><td><code id="locus_+3A_sex">sex</code></td>
<td>

<p>A vector containing the gender of each individual (required if x.linked=T)
</p>
</td></tr>
<tr><td><code id="locus_+3A_male.code">male.code</code></td>
<td>

<p>The code denoting a male in the sex vector
</p>
</td></tr>
<tr><td><code id="locus_+3A_female.code">female.code</code></td>
<td>

<p>The code denoting a female in the sex vector
</p>
</td></tr>
<tr><td><code id="locus_+3A_miss.val">miss.val</code></td>
<td>

<p>a vector of codes denoting missing values for allele1 and
allele2. Note that NA will always be treated as a missing value, even
if not specified in miss.val.  Also note that if multiple missing
value codes are specified, the original missing value code for a
specific individual can not be retrieved from the locus object. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class locus which inherits from class model.matrix containing the following elements:
</p>
<table role = "presentation">
<tr><td><code>geno</code></td>
<td>

<p>a matrix with 2 columns where each row contains numeric codes for the 2 alleles for an individual.
</p>
</td></tr>
<tr><td><code>chrom.label</code></td>
<td>

<p>a chromosome label
</p>
</td></tr>
<tr><td><code>locus.alias</code></td>
<td>

<p>a vector of aliases for the locus
</p>
</td></tr>
<tr><td><code>x.linked</code></td>
<td>

<p>a logical value specifying if the locus is x-linked or not
</p>
</td></tr>
<tr><td><code>allele.labels</code></td>
<td>

<p>a vector of labels corresponding to the numeric codes in matrix geno (similar to levels in a factor)
</p>
</td></tr>
<tr><td><code>male.code</code></td>
<td>

<p>a code to be used to identify males for an x.linked locus.
</p>
</td></tr>
<tr><td><code>female.code</code></td>
<td>

<p>a code to be used to identify females for an x.linked locus.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>b1 &lt;- c("A","A","B","C","E","D")
b2 &lt;- c("A","A","C","E","F","G")
loc1 &lt;- locus(b1,b2,chrom=4,locus.alias="D4S1111")

loc1

# a second example which uses more parameters, some may not be supported.
c1 &lt;- c(101,10, 112,112,21,112)
c2 &lt;- c(101,101,112,  100,21, 10)

gender &lt;- rep(c("M","F"),3)
loc2 &lt;- locus(c1,c2,chrom="X",locus.alias="DXS1234", x.linked=TRUE, sex=gender)

loc2
</code></pre>

<hr>
<h2 id='louis.info'>
Louis Information for haplo.glm
</h2><span id='topic+louis.info'></span>

<h3>Description</h3>

<p>For internal use within the haplo.stats library's haplo.glm function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>louis.info(fit, epsilon=1e-8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="louis.info_+3A_fit">fit</code></td>
<td>

<p>glm fitted object
</p>
</td></tr>
<tr><td><code id="louis.info_+3A_epsilon">epsilon</code></td>
<td>

<p>cut-off for singular values in the generalized inverse of the
information matrix  
</p>
</td></tr>
</table>

<hr>
<h2 id='na.geno.keep'>
Remove rows with NA in covariates, but keep genotypes with NAs
</h2><span id='topic+na.geno.keep'></span>

<h3>Description</h3>

<p>Removes rows with NA in response or covariates, but keeps subjects
with NAs in their genotypes if not missing all alleles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na.geno.keep(m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="na.geno.keep_+3A_m">m</code></td>
<td>

<p>model matrix
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a model matrix with rows removed if exclusion criteria requires it
</p>

<hr>
<h2 id='plot.haplo.score'>
Plot Haplotype Frequencies versus Haplotype Score Statistics
</h2><span id='topic+plot.haplo.score'></span>

<h3>Description</h3>

<p>Method function to plot a class of type haplo.score
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'haplo.score'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.haplo.score_+3A_x">x</code></td>
<td>

<p>The object returned from haplo.score (which has class haplo.score).
</p>
</td></tr>
<tr><td><code id="plot.haplo.score_+3A_...">...</code></td>
<td>

<p>Dynamic parameter for the values of additional parameters for 
the plot method.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a plot method function used to plot haplotype frequencies on
the x-axis and haplotype-specific scores on the y-axis. Because
haplo.score is a class, the generic plot function 
can be used, which in turn calls this plot.haplo.score function.
</p>


<h3>Value</h3>

<p>Nothing is returned.
</p>


<h3>References</h3>

<p>Schaid DJ, Rowland CM, Tines DE, Jacobson RM,  Poland  GA.
&quot;Score tests for association of traits with haplotypes when
linkage phase is ambiguous.&quot; Amer J Hum Genet. 70 (2002):  425-434.
</p>


<h3>See Also</h3>

<p>haplo.score
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(hla.demo)
  geno &lt;- as.matrix(hla.demo[,c(17,18,21:24)])
  keep &lt;- !apply(is.na(geno) | geno==0, 1, any)
  hla.demo &lt;- hla.demo[keep,]
  geno &lt;- geno[keep,]
  attach(hla.demo)
  label &lt;- c("DQB","DRB","B")
 
# For quantitative, normally distributed trait:

  score.gaus &lt;- haplo.score(resp, geno, locus.label=label, 
                            trait.type = "gaussian")

  plot.haplo.score(score.gaus)
  ## try: locator.haplo(1)
</code></pre>

<hr>
<h2 id='plot.haplo.score.slide'>
Plot a haplo.score.slide Object 
</h2><span id='topic+plot.haplo.score.slide'></span>

<h3>Description</h3>

<p>Method function to plot an object of class haplo.score.slide.  The
p-values from haplo.score.slide are for sub-haplotypes of a larger
chromosomal region, and these are plotted to visualize the change in
p-values as the sub-haplotype &quot;slides&quot; over a chromosome. Plot
-log10(p-value) on the y-axis vs. the loci over which it was computed
on the x-axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'haplo.score.slide'
plot(x, pval="global", dist.vec=1:x$n.loci, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.haplo.score.slide_+3A_x">x</code></td>
<td>

<p>The object returned from haplo.score.slide
</p>
</td></tr>
<tr><td><code id="plot.haplo.score.slide_+3A_pval">pval</code></td>
<td>

<p>Character string for the choice of p-value to plot. Options are:
&quot;global&quot; (the global score statistic p-value based on an asymptotic
chi-square distribution), &quot;global.sim&quot; (the global score statistic
simulated p-value), and &quot;max.sim&quot; (the simulated p-value for the
maximum score statistic).
</p>
</td></tr>
<tr><td><code id="plot.haplo.score.slide_+3A_dist.vec">dist.vec</code></td>
<td>

<p>Numeric vector for position (i.e., in cM) of the loci along a
chromosome. Distances on x-axis will correspond to these positions. 
</p>
</td></tr>
<tr><td><code id="plot.haplo.score.slide_+3A_...">...</code></td>
<td>

<p>Dynamic parameter for the values of additional parameters for 
the plot method. Some useful options for manageing the x-axis labels
are cex.axis, las, and srt.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The x-axis has tick marks for all loci.  The y-axis is the -log10() of
the selected p-value.  For each haplo.score result, plot a horizontal
line at the height of -log10(p-value) drawn across the loci over which
it was calculated.  Therefore a p-value of 0.001 for the first 3 loci
will plot as a horizontal line plotted at y=3 covering the first three
tick marks.  
If the p-value for a set of loci is zero or very near zero, it is set
to a minimum.  Global asymptotic p-values of zero are set to the
minimum of an epsilon or the lowest non-zero p-value in the region.
Simulated p-values equal to zero are set to 0.5 divided by the total number of
simulations performed.
</p>


<h3>Value</h3>

<p>Nothing is returned.
</p>


<h3>References</h3>

<p>Schaid DJ, Rowland CM, Tines DE, Jacobson RM,  Poland  GA.
&quot;Score tests for association of traits with haplotypes when
linkage phase is ambiguous.&quot; Amer J Hum Genet. 70 (2002):  425-434.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+haplo.score.slide">haplo.score.slide</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This example has a long run-time, therefore it is commented

#   data(hla.demo)
#   attach(hla.demo)
#   geno.11 &lt;- hla.demo[,-c(1:4)]
#   label.11 &lt;- c("DPB","DPA","DMA","DMB","TAP1","TAP2","DQB","DQA","DRB","B","A")

#For an ordinal trait, slide by 3 loci, and simulate p-values:
#   y.ord &lt;- as.numeric(resp.cat)
#   slide.ord.sim &lt;-  haplo.score.slide(y.ord, geno.11, trait.type = "ordinal",
#                              n.slide=3, locus.label=label.11, simulate=TRUE,
#                              sim.control=score.sim.control(min.sim=500))

#   print(slide.ord.sim)
#   plot(slide.ord.sim)
#   plot(slide.ord.sim, pval="global.sim", las=2, cex.axis=.8)
#   plot(slide.ord.sim, pval="max.sim", srt=90, cex.axis=.8)
</code></pre>

<hr>
<h2 id='plot.seqhap'>
Plot a seqhap object
</h2><span id='topic+plot.seqhap'></span>

<h3>Description</h3>

<p>Method to plot an object of class seqhap. The p-values at each
locus are based on sequentially combined loci, and they
are plotted to visualize the p-values when scanning each locus using
seqhap methods. Plots -log10(p-value) on the y-axis vs. the
loci over which it was computed on the x-axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'seqhap'
plot(x, pval="hap", single=TRUE,
minp=.Machine$double.eps, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.seqhap_+3A_x">x</code></td>
<td>

<p>The object returned from seqhap
</p>
</td></tr>
<tr><td><code id="plot.seqhap_+3A_pval">pval</code></td>
<td>

<p>Character string for the choice of p-value to plot. Options are:
&quot;hap&quot; (sequential haplotype asymptotic p-value), &quot;hap.sim&quot; (sequential
haplotype simulated p-value), &quot;sum&quot; (sequential summary asymptotic
p-value), and &quot;sum.sim&quot; (sequential summary simulated p-value).  
</p>
</td></tr>
<tr><td><code id="plot.seqhap_+3A_single">single</code></td>
<td>

<p>Logical, indicating whether to plot p-values for single-locus
association tests. If TRUE, the pointwise p-values from the
single-locus will be plotted using a dotted line.
</p>
</td></tr>
<tr><td><code id="plot.seqhap_+3A_minp">minp</code></td>
<td>

<p>Smallest &quot;allowable&quot; p-value; any p-value smaller will be set to
log10(minp).  The default is the value closest to zero that can be
represented in Splus/R.
</p>
</td></tr>
<tr><td><code id="plot.seqhap_+3A_...">...</code></td>
<td>

<p>Dynamic parameter for the values of additional parameters for 
the plot method.  Accept the ylim parameter for plot() and other
parameters for lines(), points(), and axis().
Recommended values to make locus labels vertical on the x-axis:
for R:  las=2,  cex.axis=1.2
for S+: srt=90, cex.axis=1.2, adj=1
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The x-axis has tick marks for all loci.  The y-axis is the -log10() of
the selected p-value.  For the sequential result for each locus, a
horizontal line at the height of -log10(p-value) is drawn across the
loci combined. The start locus is indicated by a filled triangle and
other loci combined with the start locus are indicated by an asterisk
or circle.
</p>
<p>If the permutation p-value is zero, for plotting purposes it is set to
1/(n.sim+1).
</p>


<h3>Value</h3>

<p>Nothing is returned.
</p>


<h3>References</h3>

<p>Yu Z, Schaid DJ. (2007) Sequential haplotype scan methods for
association analysis. Genet Epidemiol, in print.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqhap">seqhap</a></code>,
<code><a href="#topic+print.seqhap">print.seqhap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    data(seqhap.dat)
    mydata.y &lt;- seqhap.dat[,1]
    mydata.x &lt;- seqhap.dat[,-1]
    data(seqhap.pos)
    myobj &lt;- seqhap(y=mydata.y, geno=mydata.x, pos=seqhap.pos$pos)
    plot(myobj)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='print.haplo.cc'>
Print a haplo.cc object
</h2><span id='topic+print.haplo.cc'></span>

<h3>Description</h3>

<p>Display results for a haplotype analysis on a case-control study.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'haplo.cc'
print(x, order.by=c("score","haplotype","freq"), digits=max(options()$digits-2, 5),
    nlines=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.haplo.cc_+3A_x">x</code></td>
<td>

<p>A haplo.cc object, made by the haplo.cc function.
</p>
</td></tr>
<tr><td><code id="print.haplo.cc_+3A_order.by">order.by</code></td>
<td>

<p>Order the printed data frame by the column: haplotype score (score), haplotype alleles
(haplotype), or haplotype frequency (freq).
</p>
</td></tr>
<tr><td><code id="print.haplo.cc_+3A_digits">digits</code></td>
<td>

<p>Number of digits to display for the numeric columns of the data frame.
</p>
</td></tr>
<tr><td><code id="print.haplo.cc_+3A_nlines">nlines</code></td>
<td>

<p>Print the first nlines of the cc.df data frame of the haplo.cc object,
keeps output short if desired.
</p>
</td></tr>
<tr><td><code id="print.haplo.cc_+3A_...">...</code></td>
<td>

<p>Dynamic parameter for the values of additional parameters for 
the print method.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+haplo.cc">haplo.cc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## for a haplo.cc object named cc.test, 
##    order results by haplotype 
# print.haplo.cc(cc.test, order.by="haplotype")
</code></pre>

<hr>
<h2 id='print.haplo.em'>
Print contents of a haplo.em object
</h2><span id='topic+print.haplo.em'></span>

<h3>Description</h3>

<p>Print a data frame with haplotypes and their frequencies.  Likelihood
information is also printed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'haplo.em'
print(x, digits=max(options()$digits-2, 5), nlines=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.haplo.em_+3A_x">x</code></td>
<td>

<p>A haplo.em object
</p>
</td></tr>
<tr><td><code id="print.haplo.em_+3A_digits">digits</code></td>
<td>

<p>number of significant digits to print for numeric values
</p>
</td></tr>
<tr><td><code id="print.haplo.em_+3A_nlines">nlines</code></td>
<td>

<p>To shorten output, print the first 1:nlines rows of the large data frame.  
</p>
</td></tr>
<tr><td><code id="print.haplo.em_+3A_...">...</code></td>
<td>

<p>optional arguments for print
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned
</p>


<h3>See Also</h3>

<p><code><a href="#topic+haplo.em">haplo.em</a></code>
</p>

<hr>
<h2 id='print.haplo.group'>
Print a haplo.group object
</h2><span id='topic+print.haplo.group'></span>

<h3>Description</h3>

<p>Method function to print a class of type haplo.group
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'haplo.group'
print(x, digits=max(options()$digits-2, 5), nlines=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.haplo.group_+3A_x">x</code></td>
<td>

<p>The object returned from haplo.group (which has old class haplo.group).
</p>
</td></tr>
<tr><td><code id="print.haplo.group_+3A_digits">digits</code></td>
<td>

<p>Set the number of significant digits to print for haplotype probabilities.
</p>
</td></tr>
<tr><td><code id="print.haplo.group_+3A_nlines">nlines</code></td>
<td>

<p>For shorter output, print first 1:nlines rows of the large data frame
</p>
</td></tr>
<tr><td><code id="print.haplo.group_+3A_...">...</code></td>
<td>

<p>Optional arguments for the print method
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a print method function used to print information from the
haplo.group class, with haplotype-specific information given in a
table. Because haplo.group is a class, the generic print function 
can be used, which in turn calls this print.haplo.group function.
</p>


<h3>Value</h3>

<p>Nothing is returned.
</p>


<h3>References</h3>

<p>Schaid DJ, Rowland CM, Tines DE, Jacobson RM, Poland  GA.
Expected haplotype frequencies for association of traits with 
haplotypes when linkage phase is ambiguous. 
Submitted to Amer J Hum Genet.
</p>


<h3>See Also</h3>

<p>haplo.score, haplo.group, haplo.em
</p>

<hr>
<h2 id='print.haplo.scan'>
Print a haplo.scan object
</h2><span id='topic+print.haplo.scan'></span>

<h3>Description</h3>

<p>Print a haplo.scan object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'haplo.scan'
print(x, digits=max(options()$digits - 2, 5), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.haplo.scan_+3A_x">x</code></td>
<td>

<p>An object created by haplo.scan
</p>
</td></tr>
<tr><td><code id="print.haplo.scan_+3A_digits">digits</code></td>
<td>

<p>Significant digits shown for numeric data
</p>
</td></tr>
<tr><td><code id="print.haplo.scan_+3A_...">...</code></td>
<td>

<p>Options parameters for the print function
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL
</p>


<h3>See Also</h3>

<p><code><a href="#topic+haplo.scan">haplo.scan</a></code>
</p>

<hr>
<h2 id='print.haplo.score'>
Print a haplo.score object
</h2><span id='topic+print.haplo.score'></span>

<h3>Description</h3>

<p>Method function to print a class of type haplo.score
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'haplo.score'
print(x, digits, nlines=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.haplo.score_+3A_x">x</code></td>
<td>

<p>The object returned from haplo.score (which has class haplo.score).
</p>
</td></tr>
<tr><td><code id="print.haplo.score_+3A_digits">digits</code></td>
<td>

<p>Number of digits to round the numeric output.
</p>
</td></tr>
<tr><td><code id="print.haplo.score_+3A_nlines">nlines</code></td>
<td>

<p>Print the first 'nlines' rows of the large data frame for fast, short
view of the results.  
</p>
</td></tr>
<tr><td><code id="print.haplo.score_+3A_...">...</code></td>
<td>

<p>Dynamic parameter for the values of additional parameters for 
the print method.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a print method function used to print information from
haplo.score class, with haplotype-specific information given in a
table. Because haplo.score is a class, the generic print function 
can be used, which in turn calls this print.haplo.score function.
</p>


<h3>Value</h3>

<p>If print is assigned, the object contains the table of haplotype scores
that was printed by the method
</p>


<h3>See Also</h3>

<p>haplo.score
</p>

<hr>
<h2 id='print.haplo.score.merge'>
Print a haplo.score.merge object
</h2><span id='topic+print.haplo.score.merge'></span>

<h3>Description</h3>

<p>Method function to print a class of type haplo.score.merge
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'haplo.score.merge'
print(x, order.by="score", all.haps=FALSE, 
                digits=max(options()$digits-2, 5), nlines=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.haplo.score.merge_+3A_x">x</code></td>
<td>

<p>The object returned from haplo.score.merge (which has old class {S} 
haplo.score.merge).
</p>
</td></tr>
<tr><td><code id="print.haplo.score.merge_+3A_order.by">order.by</code></td>
<td>

<p>Column of the haplo.score.merge object by which to order the results
</p>
</td></tr>
<tr><td><code id="print.haplo.score.merge_+3A_all.haps">all.haps</code></td>
<td>

<p>Logical, if (T)rue prints a row for all haplotypes.  If (F)alse, the
default, only prints the haplotypes kept in haplo.score for modelling.
</p>
</td></tr>
<tr><td><code id="print.haplo.score.merge_+3A_digits">digits</code></td>
<td>

<p>Set the number of significant digits to print for the numeric output.
</p>
</td></tr>
<tr><td><code id="print.haplo.score.merge_+3A_nlines">nlines</code></td>
<td>

<p>Print the first 'nlines' rows of the large data frame for a short
view of the results.
</p>
</td></tr>
<tr><td><code id="print.haplo.score.merge_+3A_...">...</code></td>
<td>

<p>Dynamic parameter for the values of additional parameters for 
the print method.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a print method function used to print information from the
haplo.score.merge class. Because haplo.score.merge is a class, 
the generic print function can be used, which in turn calls this 
print.haplo.score.merge function.
</p>


<h3>Value</h3>

<p>Nothing is returned.
</p>


<h3>References</h3>

<p>Schaid DJ, Rowland CM, Tines DE, Jacobson RM, Poland  GA.
Expected haplotype frequencies for association of traits with 
haplotypes when linkage phase is ambiguous. 
Submitted to Amer J Hum Genet.
</p>


<h3>See Also</h3>

<p>haplo.score.merge, haplo.score, haplo.group
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#see example for haplo.score.merge
</code></pre>

<hr>
<h2 id='print.haplo.score.slide'>
Print the contents of a haplo.score.slide object
</h2><span id='topic+print.haplo.score.slide'></span>

<h3>Description</h3>

<p>Print the data frame returned from haplo.score.slide
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'haplo.score.slide'
print(x, digits=max(options()$digits - 2, 5), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.haplo.score.slide_+3A_x">x</code></td>
<td>

<p>A haplo.score.slide object
</p>
</td></tr>
<tr><td><code id="print.haplo.score.slide_+3A_digits">digits</code></td>
<td>

<p>Number of digits to print for numeric output
</p>
</td></tr>
<tr><td><code id="print.haplo.score.slide_+3A_...">...</code></td>
<td>

<p>Optional arguments for the print method
</p>
</td></tr>
</table>

<hr>
<h2 id='printBanner'>
Print a nice banner
</h2><span id='topic+printBanner'></span>

<h3>Description</h3>

<p>Print a centered banner that carries to multiple lines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printBanner(str, banner.width=options()$width, char.perline=.75*banner.width, border="=")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="printBanner_+3A_str">str</code></td>
<td>

<p>character string - a title within the banner
</p>
</td></tr>
<tr><td><code id="printBanner_+3A_banner.width">banner.width</code></td>
<td>

<p>width of banner, the default is set to fit current options
</p>
</td></tr>
<tr><td><code id="printBanner_+3A_char.perline">char.perline</code></td>
<td>

<p>number of characters per line for the title, the default is 75% of 
the banner.width parameter 
</p>
</td></tr>
<tr><td><code id="printBanner_+3A_border">border</code></td>
<td>

<p>type of character for the border
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function prints a nice banner in both R and S-PLUS
</p>


<h3>Value</h3>

<p>nothing is returned
</p>


<h3>See Also</h3>

<p>options
</p>


<h3>Examples</h3>

<pre><code class='language-R'>printBanner("This is a pretty banner", banner.width=40, char.perline=30)

# the output looks like this:
# ========================================
#         This is a pretty banner
# ========================================
</code></pre>

<hr>
<h2 id='residuals.haplo.glm'>
Accessing residuals for haplo.glm fit
</h2><span id='topic+residuals.haplo.glm'></span>

<h3>Description</h3>

<p>Access the residuals from a haplo.glm model fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'haplo.glm'
residuals(object, type=c("deviance", "pearson",
                                "working", "response"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.haplo.glm_+3A_object">object</code></td>
<td>

<p>A haplo.glm object
</p>
</td></tr>
<tr><td><code id="residuals.haplo.glm_+3A_type">type</code></td>
<td>

<p>Type of residuals to return. Options are &quot;deviance&quot; (default),
&quot;pearson&quot;, &quot;working&quot;, and &quot;response&quot;. Partial residuals not supported
in this method.
</p>
</td></tr>
<tr><td><code id="residuals.haplo.glm_+3A_...">...</code></td>
<td>

<p>Optional arguments
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Many of the subjects in a haplo.glm fit are expanded in the model
matrix with weights used to reflect the posterior probability of the
subject's haplotype pairs given their genotype.  The working residuals
within the fitted object are from this expanded model matrix, and the
residuals in this method are calculated from the weighted fitted value
for the subject across all their haplotype pairs.
</p>


<h3>Value</h3>

<p>Residuals for each person in the model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+haplo.glm">haplo.glm</a></code>,
<code><a href="stats.html#topic+residuals.glm">residuals.glm</a></code>,
<code><a href="#topic+fitted.haplo.glm">fitted.haplo.glm</a></code>
</p>

<hr>
<h2 id='score.sim.control'>
Create the list of control parameters for simulations in haplo.score
</h2><span id='topic+score.sim.control'></span>

<h3>Description</h3>

<p>In the call to haplo.score, the sim.control
parameter is a list of parameters that control the simulations. This
list is created by this function, score.sim.control, making it easy to
change the default values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score.sim.control(p.threshold=0.25, min.sim=1000, max.sim=20000.,verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="score.sim.control_+3A_p.threshold">p.threshold</code></td>
<td>

<p>A paremeter used to determine p-value precision from Besag and
Clifford (1991).  For a p-value calculated after min.sim simulations,
continue doing simulations until the p-value's sample standard error is
less than p.threshold * p-value.  The dafault value for p.threshold = 1/4
corresponds approximately to having a two-sided 95% confidence
interval for the p-value with a width as wide as the p-value itself.
Therefore, simulations are more precise for smaller p-values.
Additionally, since simulations are stopped as soon as this criteria
is met, p-values may be biased high.  
</p>
</td></tr>
<tr><td><code id="score.sim.control_+3A_min.sim">min.sim</code></td>
<td>

<p>The minimum number of simulations to run.  To run exactly min.sim
simulations, set max.sim = min.sim.  Also, if run-time is an issue, a
lower minimum (e.g. 500) may be useful, especially when doing
simulations in haplo.score.slide.
</p>
</td></tr>
<tr><td><code id="score.sim.control_+3A_max.sim">max.sim</code></td>
<td>

<p>The upper limit of simulations allowed.  When the number of
simulations reaches max.sim, p-values are approximated based on
simulation results at that time.
</p>
</td></tr>
<tr><td><code id="score.sim.control_+3A_verbose">verbose</code></td>
<td>

<p>Logical, if (T)rue, print updates from every simulation to the
screen.  If (F)alse, do not print these details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In simulations for haplo.score, employ the simulation p-value
precision criteria of Besag and Clifford (1991).  The criteria
ensures both the global and the maximum score statistic simulated
p-values be precise for small p-values.  First, perform min.sim
simulations to guarantee sufficient precision for the score
statistics on individual haplotypes.  Then continue simulations as
needed until simulated p-values for both the global and max score
statistics meet precision requirements set by p.threshold.
</p>


<h3>Value</h3>

<p>A list of the control parameters:
</p>
<table role = "presentation">
<tr><td><code>p.threshold</code></td>
<td>

<p>As described above
</p>
</td></tr>
<tr><td><code>min.sim</code></td>
<td>

<p>As described above.
</p>
</td></tr>
<tr><td><code>max.sim</code></td>
<td>

<p>As described above
</p>
</td></tr>
<tr><td><code>verbose</code></td>
<td>

<p>As described above
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Besag, J and Clifford, P.  &quot;Sequential Monte Carlo p-values.&quot;
Biometrika.  78, no. 2 (1991): 301-304.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+haplo.score">haplo.score</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># it would be used in haplo.score as appears below
#
# score.sim.500 &lt;- haplo.score(y, geno, trait.type="gaussian", simulate=T, 
#                sim.control=score.sim.control(min.sim=500, max.sim=2000)
</code></pre>

<hr>
<h2 id='seqhap'>
Sequential Haplotype Scan Association Analysis for Case-Control Data
</h2><span id='topic+seqhap'></span><span id='topic+print.seqhap'></span>

<h3>Description</h3>

<p>Seqhap implements sequential haplotype scan methods to perform
association analyses for case-control data.  When evaluating each
locus, loci that contribute additional information to haplotype 
associations with disease status will be added sequentially. 
This conditional evaluation is based on the 
Mantel-Haenszel (MH) test.  Two sequential methods are provided, a
sequential haplotype method and a sequential summary method, as well as
results based on the traditional single-locus method.  Currently, seqhap
only works with bialleleic loci (single nucleotide polymorphisms, 
or SNPs) and binary traits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqhap(y, geno, pos, locus.label=NA, weight=NULL, 
       mh.threshold=3.84, r2.threshold=0.95, haplo.freq.min=0.005, 
       miss.val=c(0, NA), sim.control=score.sim.control(),
       control=haplo.em.control())
## S3 method for class 'seqhap'
print(x, digits=max(options()$digits-2, 5), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seqhap_+3A_y">y</code></td>
<td>

<p>vector of binary response (1=case, 0=control). The length is equal 
to the number of rows in geno. 
</p>
</td></tr>
<tr><td><code id="seqhap_+3A_geno">geno</code></td>
<td>

<p>matrix of alleles, such that each locus has a pair of adjacent columns
of alleles, and the order of columns corresponds to the order of loci
on a chromosome. If there are K loci, then ncol(geno)=2*K. Rows
represent the alleles for each subject. Currently, only bi-allelic loci
(SNPs) are allowed. 
</p>
</td></tr>
<tr><td><code id="seqhap_+3A_pos">pos</code></td>
<td>

<p>vector of physical positions (or relative physical positions) for
loci. If there are K loci, length(pos)=K. The scale (in kb, bp, or
etc.) doesn't affect the results.
</p>
</td></tr>
<tr><td><code id="seqhap_+3A_locus.label">locus.label</code></td>
<td>

<p>vector of labels for the set of loci 
</p>
</td></tr>
<tr><td><code id="seqhap_+3A_weight">weight</code></td>
<td>

<p>weights for observations (rows of geno matrix).
</p>
</td></tr>
<tr><td><code id="seqhap_+3A_mh.threshold">mh.threshold</code></td>
<td>

<p>threshold for the Mantel-Haenszel statistic that evaluates whether a
locus contributes additional information of haplotype association to
disease, conditional on current haplotypes. The default is 3.84, which
is the 95th percentile of the chi-square distribution with 1 degree 
of freedom. 
</p>
</td></tr>
<tr><td><code id="seqhap_+3A_r2.threshold">r2.threshold</code></td>
<td>

<p>threshold for a locus to be skipped. When scanning locus k, loci
with correlations r-squared (the square of the Pearson's correlation)
greater than r2.threshold with locus k will be ignored, so that the haplotype
growing process continues for markers that are further away from locus k.
</p>
</td></tr>
<tr><td><code id="seqhap_+3A_haplo.freq.min">haplo.freq.min</code></td>
<td>

<p>the minimum haplotype frequency for a haplotype to be included in the
association tests. The haplotype frequency is based on the EM
algorithm that estimates haplotype frequencies independent of trait. 
</p>
</td></tr>
<tr><td><code id="seqhap_+3A_miss.val">miss.val</code></td>
<td>

<p>vector of values that represent missing alleles.
</p>
</td></tr>
<tr><td><code id="seqhap_+3A_sim.control">sim.control</code></td>
<td>

<p>A list of control parameters to determine how simulations are
performed for permutation p-values, similar to the strategy in
haplo.score.  The list is created by the function
score.sim.control and the default values of this function can be 
changed as desired.  Permutations are performed until a p.threshold
accuracy rate is met for the three region-based p-values calculated in
seqhap. See score.sim.control for details.
</p>
</td></tr>
<tr><td><code id="seqhap_+3A_control">control</code></td>
<td>

<p>A list of parameters that control the EM algorithm for estimating 
haplotype frequencies when phase is unknown.  The list is created by 
the function haplo.em.control - see this function for more details.
</p>
</td></tr>
<tr><td><code id="seqhap_+3A_x">x</code></td>
<td>

<p>a seqhap object to print
</p>
</td></tr>
<tr><td><code id="seqhap_+3A_digits">digits</code></td>
<td>

<p>Number of significant digits to print for numeric values
</p>
</td></tr>
<tr><td><code id="seqhap_+3A_...">...</code></td>
<td>

<p>Additional parameters for the print method
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No further details
</p>


<h3>Value</h3>

<p>list with components:
</p>
<table role = "presentation">
<tr><td><code>converge</code></td>
<td>

<p>indicator of convergence of the EM algorithm (see haplo.em); 
1 = converge, 0=failed
</p>
</td></tr>
<tr><td><code>locus.label</code></td>
<td>

<p>vector of labels for loci
</p>
</td></tr>
<tr><td><code>pos</code></td>
<td>

<p>chromosome positions for loci, same as input.
</p>
</td></tr>
<tr><td><code>n.sim</code></td>
<td>

<p>number of permutations performed for emperical p-values
</p>
</td></tr>
<tr><td><code>inlist</code></td>
<td>

<p>matrix that shows which loci are combined for association analysis in
the sequential scan. The non-zero values of the kth row of inlist are
the indices of the loci combined when scanning locus k. 
</p>
</td></tr>
<tr><td><code>chi.stat</code></td>
<td>

<p>chi-square statistics of single-locus analysis.
</p>
</td></tr>
<tr><td><code>chi.p.point</code></td>
<td>

<p>permuted pointwise p-values of single-locus analysis.
</p>
</td></tr>
<tr><td><code>chi.p.region</code></td>
<td>

<p>permuted regional p-value of single-locus analysis.
</p>
</td></tr>
<tr><td><code>hap.stat</code></td>
<td>

<p>chi-square statistics of sequential haplotype analysis.
</p>
</td></tr>
<tr><td><code>hap.df</code></td>
<td>

<p>degrees of freedom of sequential haplotype analysis.
</p>
</td></tr>
<tr><td><code>hap.p.point</code></td>
<td>

<p>permuted pointwise p-values of sequential haplotype analysis.
</p>
</td></tr>
<tr><td><code>hap.p.region</code></td>
<td>

<p>permuted region p-value of sequential haplotype analysis.
</p>
</td></tr>
<tr><td><code>sum.stat</code></td>
<td>

<p>chi-square statistics of sequential summary analysis.
</p>
</td></tr>
<tr><td><code>sum.df</code></td>
<td>

<p>degrees of freedom of sequential summary analysis.
</p>
</td></tr>
<tr><td><code>sum.p.point</code></td>
<td>

<p>permuted pointwise p-values of sequential summary analysis.
</p>
</td></tr>
<tr><td><code>sum.p.region</code></td>
<td>

<p>permuted regional p-value of sequential summary analysis.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Yu Z, Schaid DJ. (2007) Sequential haplotype scan methods for
association analysis. Genet Epidemiol, in print.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+haplo.em">haplo.em</a></code>,
<code><a href="#topic+print.seqhap">print.seqhap</a></code>,
<code><a href="#topic+plot.seqhap">plot.seqhap</a></code>,
<code><a href="#topic+score.sim.control">score.sim.control</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load example data with response and genotypes. 
data(seqhap.dat)
mydata.y &lt;- seqhap.dat[,1]
mydata.x &lt;- seqhap.dat[,-1]
# load positions
data(seqhap.pos)
pos &lt;- seqhap.pos$pos
# run seqhap with default settings
## Not run: 
  # this example takes 5-10 seconds to run
  myobj &lt;- seqhap(y=mydata.y, geno=mydata.x, pos=pos)
  print.seqhap(myobj)

## End(Not run)
</code></pre>

<hr>
<h2 id='seqhap.dat'>
Simulated data for seqhap examples
</h2><span id='topic+seqhap.dat'></span><span id='topic+seqhap.pos'></span>

<h3>Description</h3>

<p>Simulated data set for the demonstration of seqhap functionality.
Contains one column for disease status and columns representing 10 SNP
loci with a known association.  seqhap.pos contains a column for
chromosome position, as required by seqhap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(seqhap.dat)
data(seqhap.pos)
</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 observations on the following 21 variables.
</p>

<dl>
<dt><code>disease</code></dt><dd><p>numeric, indicator of disease status 0=no, 1=yes</p>
</dd>
<dt><code>m1.1</code></dt><dd><p>first allele of genotype</p>
</dd>
<dt><code>m1.2</code></dt><dd><p>second allele of genotype</p>
</dd>
<dt><code>m2.1</code></dt><dd><p>first allele of genotype</p>
</dd>
<dt><code>m2.2</code></dt><dd><p>second allele of genotype</p>
</dd>
<dt><code>m3.1</code></dt><dd><p>first allele of genotype</p>
</dd>
<dt><code>m3.2</code></dt><dd><p>second allele of genotype</p>
</dd>
<dt><code>m4.1</code></dt><dd><p>first allele of genotype</p>
</dd>
<dt><code>m4.2</code></dt><dd><p>second allele of genotype</p>
</dd>
<dt><code>m5.1</code></dt><dd><p>first allele of genotype</p>
</dd>
<dt><code>m5.2</code></dt><dd><p>second allele of genotype</p>
</dd>
<dt><code>m6.1</code></dt><dd><p>first allele of genotype</p>
</dd>
<dt><code>m6.2</code></dt><dd><p>second allele of genotype</p>
</dd>
<dt><code>m7.1</code></dt><dd><p>first allele of genotype</p>
</dd>
<dt><code>m7.2</code></dt><dd><p>second allele of genotype</p>
</dd>
<dt><code>m8.1</code></dt><dd><p>first allele of genotype</p>
</dd>
<dt><code>m8.2</code></dt><dd><p>second allele of genotype</p>
</dd>
<dt><code>m9.1</code></dt><dd><p>first allele of genotype</p>
</dd>
<dt><code>m9.2</code></dt><dd><p>second allele of genotype</p>
</dd>
<dt><code>m10.1</code></dt><dd><p>first allele of genotype</p>
</dd>
<dt><code>m10.2</code></dt><dd><p>second allele of genotype</p>
</dd>
</dl>



<h3>References</h3>

<p>Yu Z, Schaid DJ (2007) Sequantial haplotype scan methods for
association analysis.  <em>Gen Epi</em>, in print.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(seqhap.dat)
</code></pre>

<hr>
<h2 id='setupGeno'>
Create a group of locus objects from a genotype matrix, assign to
'model.matrix' class.  
</h2><span id='topic+setupGeno'></span>

<h3>Description</h3>

<p>The function makes each pair of columns a locus object, which
recodes alleles to numeric and saves the original alleles as an
attribute of the model.matrix. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setupGeno(geno, miss.val=c(0,NA), locus.label=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setupGeno_+3A_geno">geno</code></td>
<td>

<p>Matrix of alleles, such that each locus has a pair of adjacent
columns of alleles, and the order of columns corresponds to the
order of loci on a chromosome. If there are K loci, then
ncol(geno) = 2*K. Rows represent alleles for each subject.
</p>
</td></tr>
<tr><td><code id="setupGeno_+3A_miss.val">miss.val</code></td>
<td>

<p>A vector of codes denoting missing values for allele1 and
allele2. Note that NA will always be treated as a missing value, even
if not specified in miss.val.  Also note that if multiple missing
value codes are specified, the original missing value code for a
specific individual can not be retrieved from the loci object.
</p>
</td></tr>
<tr><td><code id="setupGeno_+3A_locus.label">locus.label</code></td>
<td>

<p>vector of labels for the loci
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function contains the essential parts of the loci function,
which is no longer within haplo.stats
</p>


<h3>Value</h3>

<p>A 'model.matrix' object with the alleles recoded to numeric values,
and the original values are stored in the 'unique.alleles' attribute.
The ith item of the unique.alleles list is a vector of unique alleles
for the ith locus.
</p>


<h3>Note</h3>

<p>A matrix that contains all elements of mode character will be sorted
in alphabetic order. This order may differ across platforms according
to your setting of LC_COLLATE.  See the note in <code>haplo.em</code> about
how this sort order affects results.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locus">locus</a></code>,
<code><a href="#topic+haplo.glm">haplo.glm</a></code>,
<code><a href="#topic+haplo.em">haplo.em</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create some loci to work with
a1 &lt;- 1:6
a2 &lt;- 7:12

b1 &lt;- c("A","A","B","C","E","D")
b2 &lt;-c("A","A","C","E","F","G")

c1 &lt;- c("101","10","115","132","21","112")
c2 &lt;- c("100","101","0","100","21","110")

myGeno &lt;- data.frame(a1,a2,b1,b2,c1,c2)
myGeno &lt;- setupGeno(myGeno)
myGeno

attributes(myGeno)$unique.alleles
</code></pre>

<hr>
<h2 id='summary.haplo.em'>
Summarize contents of a haplo.em object
</h2><span id='topic+summary.haplo.em'></span>

<h3>Description</h3>

<p>Display haplotype pairs and their posterior probabilities by subject.
Also display a table with number of max haplotype pairs for a
subject versus how many were kept (max vs. used).  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'haplo.em'
summary(object, show.haplo=FALSE, digits=max(options()$digits-2, 5), nlines=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.haplo.em_+3A_object">object</code></td>
<td>

<p>A haplo.em object
</p>
</td></tr>
<tr><td><code id="summary.haplo.em_+3A_show.haplo">show.haplo</code></td>
<td>

<p>Logical. If TRUE, show the alleles of the haplotype pairs, otherwise show
only the recoded values.
</p>
</td></tr>
<tr><td><code id="summary.haplo.em_+3A_digits">digits</code></td>
<td>

<p>number of significant digits to be printed for numeric values
</p>
</td></tr>
<tr><td><code id="summary.haplo.em_+3A_nlines">nlines</code></td>
<td>

<p>To shorten output, print the first 1:nlines rows of the large data frame.  
</p>
</td></tr>
<tr><td><code id="summary.haplo.em_+3A_...">...</code></td>
<td>

<p>Optional arguments for the summary method
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with a row for every subject's possible haplotype pairs
and the posterior probabilities of that pair given their genotypes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+haplo.em">haplo.em</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hla.demo)
geno &lt;- hla.demo[,c(17,18,21:24)]
label &lt;-c("DQB","DRB","B")
keep &lt;- !apply(is.na(geno) | geno==0, 1, any)

save.em.keep &lt;- haplo.em(geno=geno[keep,], locus.label=label)
save.df &lt;- summary(save.em.keep)
save.df[1:10,]
</code></pre>

<hr>
<h2 id='summary.haplo.glm'>
Print and summary of a haplo.glm object
</h2><span id='topic+summary.haplo.glm'></span><span id='topic+print.summary.haplo.glm'></span>

<h3>Description</h3>

<p>Do print and summary as in regular glm, then display extra information
on haplotypes used in the model fit 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'haplo.glm'
summary(object, show.all.haplo=FALSE,
                            show.missing=FALSE, ...)
## S3 method for class 'summary.haplo.glm'
print(x, digits = max(getOption("digits")-3,3), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.haplo.glm_+3A_x">x</code></td>
<td>

<p>A haplo.glm object
</p>
</td></tr>
<tr><td><code id="summary.haplo.glm_+3A_object">object</code></td>
<td>

<p>A haplo.glm object
</p>
</td></tr>
<tr><td><code id="summary.haplo.glm_+3A_show.all.haplo">show.all.haplo</code></td>
<td>

<p>Logical.  If TRUE, print all haplotypes considered in the model.
</p>
</td></tr>
<tr><td><code id="summary.haplo.glm_+3A_show.missing">show.missing</code></td>
<td>

<p>Logical. If TRUE, print number of rows removed because of missing
values (NA) in y or x-covariates, or all alleles missing in geno
</p>
</td></tr>
<tr><td><code id="summary.haplo.glm_+3A_digits">digits</code></td>
<td>

<p>Number of numeric digits to print.
</p>
</td></tr>
<tr><td><code id="summary.haplo.glm_+3A_...">...</code></td>
<td>

<p>Optional arguments for summary method
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses print.glm for the first section, then prints information on the
haplotypes.
</p>


<h3>Value</h3>

<p>If print is assigned, the object contains a list with the coefficient
and haplotype data.frames which are printed by the method.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+haplo.glm">haplo.glm</a></code>
</p>

<hr>
<h2 id='summaryGeno'>
Summarize Full Haplotype Enumeration on Genotype Matrix 
</h2><span id='topic+summaryGeno'></span>

<h3>Description</h3>

<p>Provide a summary of missing allele information for each individual 
in the genotype matrix.  The number of loci missing zero, one, or two 
alleles is computed, as well as the total number of haplotype pairs 
that could result from the observed phenotype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryGeno(geno, miss.val=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summaryGeno_+3A_geno">geno</code></td>
<td>

<p>Matrix of alleles, such that each locus has a pair of adjacent columns
of alleles, and the order of columns corresponds to the order of loci 
on a chromosome. If there are K loci, then geno has 2*K columns. Rows 
represent all observed alleles for each subject.
</p>
</td></tr>
<tr><td><code id="summaryGeno_+3A_miss.val">miss.val</code></td>
<td>

<p>Vector of codes for allele missing values.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After getting information on the individual loci, this function makes 
a call to geno.count.pairs().  The E-M steps to estimate haplotype 
frequencies considers haplotypes that could result from a phenotype
with a missing allele.  It will not remove a subject's phenotype, only
the unlikely haplotypes that result from it.  
</p>


<h3>Value</h3>

<p>Data frame with columns representing the number of loci with zero,
one, and two missing alleles, then the total haplotype pairs resulting
from full enumeration of the phenotype.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geno.count.pairs">geno.count.pairs</a></code>,
<code><a href="#topic+haplo.em">haplo.em</a></code>
</p>

<hr>
<h2 id='vcov.haplo.glm'>variance-covariance matrix of a fitted haplo.glm object
</h2><span id='topic+vcov.haplo.glm'></span>

<h3>Description</h3>

<p>Returns the variance-covariance matrix of the main parameters of a
fitted haplo.glm object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'haplo.glm'
vcov(object, freq=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcov.haplo.glm_+3A_object">object</code></td>
<td>

<p>A haplo.glm object
</p>
</td></tr>
<tr><td><code id="vcov.haplo.glm_+3A_freq">freq</code></td>
<td>

<p>Logical.  If TRUE, return the full covariance matrix including the
entries for the frequency parameters
</p>
</td></tr>
<tr><td><code id="vcov.haplo.glm_+3A_...">...</code></td>
<td>

<p>Optional arguments for print method
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>var.mat is pre-computed in haplo.glm, the generalized inverse of the
Louis information matrix
</p>


<h3>Value</h3>

<p>Variance-covariance matrix of model parameters
</p>


<h3>See Also</h3>

<p><code><a href="#topic+haplo.glm">haplo.glm</a></code>
</p>

<hr>
<h2 id='x.sexcheck'>
consistency checks for x.linked locus  
</h2><span id='topic+x.sexcheck'></span>

<h3>Description</h3>

<p>Given an x.linked locus object and a vector of gender codes, the
function will check to make sure the gender codes match the codes used
to originally define the locus, and that no individuals defined as
males are heterozygous.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x.sexcheck(x, sex, stop=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="x.sexcheck_+3A_x">x</code></td>
<td>

<p>an object of class locus
</p>
</td></tr>
<tr><td><code id="x.sexcheck_+3A_sex">sex</code></td>
<td>

<p>a vector of codes identifying the gender of each individual contained
in the locus object
</p>
</td></tr>
<tr><td><code id="x.sexcheck_+3A_stop">stop</code></td>
<td>

<p>if T , any warnings are converted to errors and execution is
halted immediately
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>T if one or more errors were found
F if no errors were found
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locus">locus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c1 &lt;- c(101,10, 112,112,21,112)
c2 &lt;- c(101,101,112,100,21, 10)

gender &lt;- rep(c("M","F"),3)
loc2 &lt;- locus(c1,c2,chrom="X",locus.alias="DXS1234", x.linked=TRUE, sex=gender)

loc2
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
