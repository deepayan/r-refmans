<!DOCTYPE html><html><head><title>Help for package areal</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {areal}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ar_stl_asthma'><p>Asthma in St. Louis by Census Tract, 2017</p></a></li>
<li><a href='#ar_stl_race'><p>Race in St. Louis by Census Tract, 2017</p></a></li>
<li><a href='#ar_stl_wards'><p>Ward Boundaries in St. Louis, 2010</p></a></li>
<li><a href='#ar_stl_wardsClipped'><p>Clipped Ward Boundaries in St. Louis, 2010</p></a></li>
<li><a href='#ar_tessellate'><p>Create Tessellations From SF Object</p></a></li>
<li><a href='#ar_validate'><p>Validating Data for Interpolation</p></a></li>
<li><a href='#aw_aggregate'><p>Aggregate Estimates Based on Target ID</p></a></li>
<li><a href='#aw_calculate'><p>Calculate Estimated Population</p></a></li>
<li><a href='#aw_interpolate'><p>Interpolate Values</p></a></li>
<li><a href='#aw_intersect'><p>Intersect Source and Target Data</p></a></li>
<li><a href='#aw_preview_weights'><p>Preview Areal Weights</p></a></li>
<li><a href='#aw_total'><p>Calculate Total Area</p></a></li>
<li><a href='#aw_verify'><p>Verify Correct Extensive-Sum Interpolation</p></a></li>
<li><a href='#aw_weight'><p>Calculate Areal Weight</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Areal Weighted Interpolation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.8</td>
</tr>
<tr>
<td>Description:</td>
<td>A pipeable, transparent implementation of areal weighted interpolation
    with support for interpolating multiple variables in a single function call.
    These tools provide a full-featured workflow for validation and estimation
    that fits into both modern data management (e.g. tidyverse) and spatial 
    data (e.g. sf) frameworks.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://chris-prener.github.io/areal/">https://chris-prener.github.io/areal/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/chris-prener/areal/issues">https://github.com/chris-prener/areal/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, glue, purrr, rlang, sf</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-31 00:46:59 UTC; chris</td>
</tr>
<tr>
<td>Author:</td>
<td>Christopher Prener
    <a href="https://orcid.org/0000-0002-4310-9888"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Charlie Revord [aut],
  Branson Fox <a href="https://orcid.org/0000-0002-4361-2811"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christopher Prener &lt;chris.prener@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-31 07:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='ar_stl_asthma'>Asthma in St. Louis by Census Tract, 2017</h2><span id='topic+ar_stl_asthma'></span>

<h3>Description</h3>

<p>A simple features data set containing the geometry and asthma estimates
from the Centers for Disease Control for St. Louis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ar_stl_asthma)
</code></pre>


<h3>Format</h3>

<p>A data frame with 106 rows and 24 variables:
</p>

<dl>
<dt>GEOID</dt><dd><p>full GEOID string</p>
</dd>
<dt>STATEFP</dt><dd><p>state FIPS code</p>
</dd>
<dt>COUNTYFP</dt><dd><p>county FIPS code</p>
</dd>
<dt>TRACTCE</dt><dd><p>tract FIPS code</p>
</dd>
<dt>NAMELSAD</dt><dd><p>tract name</p>
</dd>
<dt>ALAND</dt><dd><p>area of tract land, square meters</p>
</dd>
<dt>AWATER</dt><dd><p>area of tract water, square meters</p>
</dd>
<dt>ASTHMA</dt><dd><p>percent of residents with current asthma diagnosis, estimated</p>
</dd>
<dt>geometry</dt><dd><p>simple features geometry</p>
</dd>
</dl>



<h3>Source</h3>

<p>Centers for Disease Control's 500 Cities Data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(ar_stl_asthma)
head(ar_stl_asthma)
summary(ar_stl_asthma$ASTHMA)

</code></pre>

<hr>
<h2 id='ar_stl_race'>Race in St. Louis by Census Tract, 2017</h2><span id='topic+ar_stl_race'></span>

<h3>Description</h3>

<p>A simple features data set containing the geometry and associated attributes
for the 2013-2017 American Community Survey estimates for race in St. Louis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ar_stl_race)
</code></pre>


<h3>Format</h3>

<p>A data frame with 106 rows and 24 variables:
</p>

<dl>
<dt>GEOID</dt><dd><p>full GEOID string</p>
</dd>
<dt>STATEFP</dt><dd><p>state FIPS code</p>
</dd>
<dt>COUNTYFP</dt><dd><p>county FIPS code</p>
</dd>
<dt>TRACTCE</dt><dd><p>tract FIPS code</p>
</dd>
<dt>NAMELSAD</dt><dd><p>tract name</p>
</dd>
<dt>ALAND</dt><dd><p>area of tract land, square meters</p>
</dd>
<dt>AWATER</dt><dd><p>area of tract water, square meters</p>
</dd>
<dt>TOTAL_E</dt><dd><p>total populaton count, estimated</p>
</dd>
<dt>TOTAL_M</dt><dd><p>total populaton count, margin of error</p>
</dd>
<dt>WHITE_E</dt><dd><p>white populaton count, estimated</p>
</dd>
<dt>WHITE_M</dt><dd><p>white populaton count, margin of error</p>
</dd>
<dt>BLACK_E</dt><dd><p>black populaton count, estimated</p>
</dd>
<dt>BLACK_M</dt><dd><p>black populaton count, margin of error</p>
</dd>
<dt>AIAN_E</dt><dd><p>american indian and alskan native populaton count, estimated</p>
</dd>
<dt>AIAN_M</dt><dd><p>american indian and alskan native populaton count, margin of error</p>
</dd>
<dt>ASIAN_E</dt><dd><p>asian populaton count, estimated</p>
</dd>
<dt>ASIAN_M</dt><dd><p>asian populaton count, margin of error</p>
</dd>
<dt>NHPI_E</dt><dd><p>native hawaiian and pacific islander populaton count, estimated</p>
</dd>
<dt>NHPI_M</dt><dd><p>native hawaiian and pacific islander populaton count, margin of error</p>
</dd>
<dt>OTHER_E</dt><dd><p>other race populaton count, estimated</p>
</dd>
<dt>OTHER_M</dt><dd><p>other race populaton count, margin of error</p>
</dd>
<dt>TWOPLUS_E</dt><dd><p>two or more races populaton count, estimated</p>
</dd>
<dt>TWOPLUS_M</dt><dd><p>two or more races populaton count, margin of error</p>
</dd>
<dt>geometry</dt><dd><p>simple features geometry</p>
</dd>
</dl>



<h3>Source</h3>

<p><code>tidycensus</code> package
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(ar_stl_race)
head(ar_stl_race)
summary(ar_stl_race$ALAND)

</code></pre>

<hr>
<h2 id='ar_stl_wards'>Ward Boundaries in St. Louis, 2010</h2><span id='topic+ar_stl_wards'></span>

<h3>Description</h3>

<p>A simple features data set containing the 2010 Ward boundaries, which
are used as districts for Alderpersons who serve as elected representatives.
The <code>OBJECTID</code> and <code>AREA</code> columns are included to simulate &quot;real&quot;
data that may have superfluous or unclear columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ar_stl_wards)
</code></pre>


<h3>Format</h3>

<p>A data frame with 28 rows and 4 variables:
</p>

<dl>
<dt>OBJECTID</dt><dd><p>Artifact from ESRI data creation</p>
</dd>
<dt>WARD</dt><dd><p>Ward number</p>
</dd>
<dt>AREA</dt><dd><p>area of each ward</p>
</dd>
<dt>geometry</dt><dd><p>simple features geometry</p>
</dd>
</dl>



<h3>Source</h3>

<p>City of St. Louis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(ar_stl_wards)
head(ar_stl_wards)
summary(ar_stl_wards$AREA)

</code></pre>

<hr>
<h2 id='ar_stl_wardsClipped'>Clipped Ward Boundaries in St. Louis, 2010</h2><span id='topic+ar_stl_wardsClipped'></span>

<h3>Description</h3>

<p>A simple features data set containing the 2010 Ward boundaries, which
are used as districts for Alderpersons who serve as elected representatives.
This version of the ward boundary has been modified so that the wards only
extend to the Mississippi River shoreline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ar_stl_wardsClipped)
</code></pre>


<h3>Format</h3>

<p>A data frame with 28 rows and 2 variables:
</p>

<dl>
<dt>WARD</dt><dd><p>Ward number</p>
</dd>
<dt>geometry</dt><dd><p>simple features geometry</p>
</dd>
</dl>



<h3>Source</h3>

<p>City of St. Louis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(ar_stl_wardsClipped)
head(ar_stl_wardsClipped)

</code></pre>

<hr>
<h2 id='ar_tessellate'>Create Tessellations From SF Object</h2><span id='topic+ar_tessellate'></span>

<h3>Description</h3>

<p>Create Tessellations From SF Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ar_tessellate(.data, shape = "square", size = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ar_tessellate_+3A_.data">.data</code></td>
<td>
<p>An object of class <code>sf</code> to tessellate from</p>
</td></tr>
<tr><td><code id="ar_tessellate_+3A_shape">shape</code></td>
<td>
<p>One of 'square' or 'hexagon', the shape to make tessellations from</p>
</td></tr>
<tr><td><code id="ar_tessellate_+3A_size">size</code></td>
<td>
<p>Numeric multiplier for size of tessellations, default is one kilometer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>sf</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ar_tessellate(ar_stl_wards)

ar_tessellate(ar_stl_wards, shape = "hexagon", size = .75)

</code></pre>

<hr>
<h2 id='ar_validate'>Validating Data for Interpolation</h2><span id='topic+ar_validate'></span>

<h3>Description</h3>

<p><code>ar_validate</code> executes a series of logic tests for <code>sf</code> object status,
shared coordinates between source and target data, appropriate project, and absence of
variable name conflicts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ar_validate(source, target, varList, method = "aw", verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ar_validate_+3A_source">source</code></td>
<td>
<p>A <code>sf</code> object with data to be interpolated</p>
</td></tr>
<tr><td><code id="ar_validate_+3A_target">target</code></td>
<td>
<p>A <code>sf</code> object that data should be interpolated to</p>
</td></tr>
<tr><td><code id="ar_validate_+3A_varlist">varList</code></td>
<td>
<p>A vector of variable names to be added to the <code>target</code> object</p>
</td></tr>
<tr><td><code id="ar_validate_+3A_method">method</code></td>
<td>
<p>The areal interpolation method validation is being performed for. This
should be set to <code>"aw"</code>. Additional functionality will be added as the package
adds new interpolation techniques.</p>
</td></tr>
<tr><td><code id="ar_validate_+3A_verbose">verbose</code></td>
<td>
<p>A logical scalar; if <code>TRUE</code>, a tibble with test results is returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>verbose</code> is <code>FALSE</code>, a logical scalar is returned that is <code>TRUE</code>
is all tests are passed and <code>FALSE</code> if one or more tests is failed. If <code>verbose</code>
is <code>TRUE</code>, a tibble with detailed test results is returned.
</p>


<h3>See Also</h3>

<p><a href="base.html#topic+c">c</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ar_validate(source = ar_stl_asthma, target = ar_stl_wards, varList = "ASTHMA")

ar_validate(source = ar_stl_asthma, target = ar_stl_wards, varList = "ASTHMA", verbose = TRUE)

</code></pre>

<hr>
<h2 id='aw_aggregate'>Aggregate Estimates Based on Target ID</h2><span id='topic+aw_aggregate'></span>

<h3>Description</h3>

<p><code>aw_aggregate</code> sums the new estimates produced by <a href="#topic+aw_calculate">aw_calculate</a>
based on the target id. These are then joined with the target data. This is
the fourth step in the interpolation process after <a href="#topic+aw_weight">aw_weight</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aw_aggregate(.data, target, tid, interVar, newVar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aw_aggregate_+3A_.data">.data</code></td>
<td>
<p>A given intersected dataset</p>
</td></tr>
<tr><td><code id="aw_aggregate_+3A_target">target</code></td>
<td>
<p>A <code>sf</code> object that data should be interpolated to</p>
</td></tr>
<tr><td><code id="aw_aggregate_+3A_tid">tid</code></td>
<td>
<p>A unique identification number within <code>target</code></p>
</td></tr>
<tr><td><code id="aw_aggregate_+3A_intervar">interVar</code></td>
<td>
<p>A variable containing an interpolated value created by <code>aw_calculate</code></p>
</td></tr>
<tr><td><code id="aw_aggregate_+3A_newvar">newVar</code></td>
<td>
<p>Optional; a new field name to store the interpolated value in. If not specified,
the <code>interVar</code> argument will be used as the new field name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>sf</code> object with the interpolated value added to it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

race &lt;- select(ar_stl_race, GEOID, TOTAL_E)
wards &lt;- select(ar_stl_wards, WARD)

wards %&gt;%
    aw_intersect(source = race, areaVar = "area") %&gt;%
    aw_total(source = race, id = GEOID, areaVar = "area", totalVar = "totalArea",
             weight = "sum", type = "extensive") %&gt;%
    aw_weight(areaVar = "area", totalVar = "totalArea", areaWeight = "areaWeight") %&gt;%
    aw_calculate(value = "TOTAL_E", areaWeight = "areaWeight") -&gt; intersect

aw_aggregate(intersect, target = wards, tid = WARD, interVar = TOTAL_E)

</code></pre>

<hr>
<h2 id='aw_calculate'>Calculate Estimated Population</h2><span id='topic+aw_calculate'></span>

<h3>Description</h3>

<p><code>aw_calculate</code> multiplies the given <code>value</code> by the area weight. This
is the fourth step in the interpolation process after <a href="#topic+aw_weight">aw_weight</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aw_calculate(.data, value, areaWeight, newVar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aw_calculate_+3A_.data">.data</code></td>
<td>
<p>A given intersected dataset</p>
</td></tr>
<tr><td><code id="aw_calculate_+3A_value">value</code></td>
<td>
<p>A column within <code>source</code> to be interpolated</p>
</td></tr>
<tr><td><code id="aw_calculate_+3A_areaweight">areaWeight</code></td>
<td>
<p>The name of the variable containing area weight per feature</p>
</td></tr>
<tr><td><code id="aw_calculate_+3A_newvar">newVar</code></td>
<td>
<p>Optional; a new field name to store the interpolated value in. If not specified,
the <code>value</code> argument will be used as the new field name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An intersected file of class sf with a new field of interest recalculated with area weight
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

race &lt;- select(ar_stl_race, GEOID, TOTAL_E)
wards &lt;- select(ar_stl_wards, WARD)

wards %&gt;%
    aw_intersect(source = race, areaVar = "area") %&gt;%
    aw_total(source = race, id = GEOID, areaVar = "area", totalVar = "totalArea",
             weight = "sum", type = "extensive") %&gt;%
    aw_weight(areaVar = "area", totalVar = "totalArea", areaWeight = "areaWeight") -&gt; intersect

aw_calculate(intersect, value = "TOTAL_E", areaWeight = "areaWeight")

</code></pre>

<hr>
<h2 id='aw_interpolate'>Interpolate Values</h2><span id='topic+aw_interpolate'></span>

<h3>Description</h3>

<p>This is the core function within the package for areal weighted
interpolation. It validates both data sources before interpolating one or more
listed values from the source data into the target data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aw_interpolate(.data, tid, source, sid, weight = "sum", output = "sf", extensive,
    intensive)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aw_interpolate_+3A_.data">.data</code></td>
<td>
<p>A <code>sf</code> object that data should be interpolated to (this is referred
to as the <code>target</code> elsewhere in the package).</p>
</td></tr>
<tr><td><code id="aw_interpolate_+3A_tid">tid</code></td>
<td>
<p>A unique identification number within <code>target</code></p>
</td></tr>
<tr><td><code id="aw_interpolate_+3A_source">source</code></td>
<td>
<p>A <code>sf</code> object with data to be interpolated</p>
</td></tr>
<tr><td><code id="aw_interpolate_+3A_sid">sid</code></td>
<td>
<p>A unique identification number within <code>source</code></p>
</td></tr>
<tr><td><code id="aw_interpolate_+3A_weight">weight</code></td>
<td>
<p>For <code>"extensive"</code> interpolations, should be either <code>"total"</code> or
<code>"sum"</code>. For <code>"intensive"</code> interpolations, should be <code>"sum"</code>. For mixed
interpolations, this will only impact the calculation of the extensive variables.</p>
</td></tr>
<tr><td><code id="aw_interpolate_+3A_output">output</code></td>
<td>
<p>One of either <code>"sf"</code> or <code>"tibble"</code></p>
</td></tr>
<tr><td><code id="aw_interpolate_+3A_extensive">extensive</code></td>
<td>
<p>A vector of quoted variable names to be treated as spatially extensive
(e.g. population counts); optional if <code>intensive</code> is specified</p>
</td></tr>
<tr><td><code id="aw_interpolate_+3A_intensive">intensive</code></td>
<td>
<p>A vector of quoted variable names to be treated as spatially intensive
(e.g. population density); optional if <code>extensive</code> is specified</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Areal weighted interpolation can be used for generating demographic
estimates for overlapping but incongruent polygon features. It assumes that
individual members of a population are evenly dispersed within the source features
(an assumption not likely to hold in the real world). It also functions best
when data are in a projected coordinate system, like the UTM coordinate system.
</p>


<h3>Value</h3>

<p>A <code>sf</code> object or a <code>tibble</code> with the value or values interpolated into
the <code>target</code> data.
</p>


<h3>See Also</h3>

<p><a href="base.html#topic+c">c</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aw_interpolate(ar_stl_wards, tid = WARD, source = ar_stl_race, sid = GEOID, weight = "sum",
    output = "sf", extensive = "TOTAL_E")

aw_interpolate(ar_stl_wards, tid = WARD, source = ar_stl_asthma, sid = GEOID, weight = "sum",
    output = "tibble", intensive = "ASTHMA")

</code></pre>

<hr>
<h2 id='aw_intersect'>Intersect Source and Target Data</h2><span id='topic+aw_intersect'></span>

<h3>Description</h3>

<p><code>aw_intersect</code> intersects the source and target datasets and
computes a new area field for the intersected data using the units associated
with whatever project the data are currently in. This is the first step in the
interpolation process after data validation and subsetting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aw_intersect(.data, source, areaVar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aw_intersect_+3A_.data">.data</code></td>
<td>
<p>A <code>sf</code> object that data should be interpolated to</p>
</td></tr>
<tr><td><code id="aw_intersect_+3A_source">source</code></td>
<td>
<p>A <code>sf</code> object with data to be interpolated</p>
</td></tr>
<tr><td><code id="aw_intersect_+3A_areavar">areaVar</code></td>
<td>
<p>The name of the new area variable to be calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>sf</code> object with the intersected data and new area field.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

race &lt;- select(ar_stl_race, GEOID, TOTAL_E)
wards &lt;- select(ar_stl_wards, WARD)

aw_intersect(wards, source = race, areaVar = "area")

</code></pre>

<hr>
<h2 id='aw_preview_weights'>Preview Areal Weights</h2><span id='topic+aw_preview_weights'></span>

<h3>Description</h3>

<p>Provides a preview of the weight options for areal weighted interpolation.
This can be useful for selecting the final specification for <code>aw_interpolate</code>
without having to construct a pipeline of all of the subfunctions manually.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aw_preview_weights(.data, tid, source, sid, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aw_preview_weights_+3A_.data">.data</code></td>
<td>
<p>A <code>sf</code> object that data should be interpolated to (this is referred
to as the <code>target</code> elsewhere in the package).</p>
</td></tr>
<tr><td><code id="aw_preview_weights_+3A_tid">tid</code></td>
<td>
<p>A unique identification number within <code>target</code></p>
</td></tr>
<tr><td><code id="aw_preview_weights_+3A_source">source</code></td>
<td>
<p>A <code>sf</code> object with data to be interpolated</p>
</td></tr>
<tr><td><code id="aw_preview_weights_+3A_sid">sid</code></td>
<td>
<p>A unique identification number within <code>source</code></p>
</td></tr>
<tr><td><code id="aw_preview_weights_+3A_type">type</code></td>
<td>
<p>One of either <code>"extensive"</code> (if the data are spatitally extensive e.g.
population counts), <code>"intensive"</code> (if the data are spatially intensive e.g.
population density), or <code>"mixed"</code> (if the data include both extensive and
intensive values). If <code>"extensive"</code>, the sum is returned for the interpolated
value. If <code>"intensive"</code>, the mean is returned for the interpolated value.
If <code>"mixed"</code>, vectors named <code>"extensive"</code> and <code>"intensive"</code> containing
the relevant variable names should be specified in the dots.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with the areal weights that would be used for interpolation if <code>type</code>
is either <code>"extensive"</code> or <code>"intensive"</code>. If it is mixed, two tibbles (one for
<code>"extensive"</code> and one for <code>"intensive"</code>) are returned as a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aw_preview_weights(ar_stl_wards, tid = WARD, source = ar_stl_race, sid = GEOID,
                   type = "extensive")

aw_preview_weights(ar_stl_wards, tid = WARD, source = ar_stl_asthma, sid = GEOID,
                   type = "intensive")

</code></pre>

<hr>
<h2 id='aw_total'>Calculate Total Area</h2><span id='topic+aw_total'></span>

<h3>Description</h3>

<p><code>aw_total</code> produces a new total area field that contains
the total area by <code>source</code> id. This is the second step in the
interpolation process after <a href="#topic+aw_intersect">aw_intersect</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aw_total(.data, source, id, areaVar, totalVar, type, weight)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aw_total_+3A_.data">.data</code></td>
<td>
<p>A <code>sf</code> object that has been intersected using <a href="#topic+aw_intersect">aw_intersect</a></p>
</td></tr>
<tr><td><code id="aw_total_+3A_source">source</code></td>
<td>
<p>A <code>sf</code> object with data to be interpolated</p>
</td></tr>
<tr><td><code id="aw_total_+3A_id">id</code></td>
<td>
<p>A unique identification number</p>
</td></tr>
<tr><td><code id="aw_total_+3A_areavar">areaVar</code></td>
<td>
<p>The name of the variable measuring a feature's area, which is
created as part of <a href="#topic+aw_intersect">aw_intersect</a></p>
</td></tr>
<tr><td><code id="aw_total_+3A_totalvar">totalVar</code></td>
<td>
<p>The name of a new total area field to be calculated</p>
</td></tr>
<tr><td><code id="aw_total_+3A_type">type</code></td>
<td>
<p>One of <code>"intensive"</code> or <code>"extensive"</code></p>
</td></tr>
<tr><td><code id="aw_total_+3A_weight">weight</code></td>
<td>
<p>One of <code>"sum"</code> or <code>"total"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>sf</code> object with the intersected data and new total area field.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

race &lt;- select(ar_stl_race, GEOID, TOTAL_E)
wards &lt;- select(ar_stl_wards, WARD)

wards %&gt;%
    aw_intersect(source = race, areaVar = "area") -&gt; intersect

aw_total(intersect, source = race, id = GEOID, areaVar = "area",
         totalVar = "totalArea", weight = "sum", type = "extensive")

</code></pre>

<hr>
<h2 id='aw_verify'>Verify Correct Extensive-Sum Interpolation</h2><span id='topic+aw_verify'></span>

<h3>Description</h3>

<p>Verify Correct Extensive-Sum Interpolation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aw_verify(source, sourceValue, result, resultValue)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aw_verify_+3A_source">source</code></td>
<td>
<p>A <code>sf</code> object with data to be interpolated</p>
</td></tr>
<tr><td><code id="aw_verify_+3A_sourcevalue">sourceValue</code></td>
<td>
<p>A column within <code>source</code> to be interpolated</p>
</td></tr>
<tr><td><code id="aw_verify_+3A_result">result</code></td>
<td>
<p>A <code>sf</code> object with interpolated data</p>
</td></tr>
<tr><td><code id="aw_verify_+3A_resultvalue">resultValue</code></td>
<td>
<p>A column within <code>result</code> with the interpolated values</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>aw_verify</code> ensures that the sum of the resulting interpolated
value is equal to the sum of the original source value. This functionality
only works for interpolations that are extensive and use the <code>sum</code>
approach to calculating areal weights.
</p>


<h3>Value</h3>

<p>A logical scalar; if <code>TRUE</code>, these two values are equal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- aw_interpolate(ar_stl_wards, tid = WARD, source = ar_stl_race, sid = GEOID,
                         weight = "sum", output = "tibble", extensive = "TOTAL_E")

aw_verify(source = ar_stl_race, sourceValue = TOTAL_E, result = result, resultValue = TOTAL_E)

</code></pre>

<hr>
<h2 id='aw_weight'>Calculate Areal Weight</h2><span id='topic+aw_weight'></span>

<h3>Description</h3>

<p><code>aw_weight</code> creates an area weight field by dividing the area
field by the total area field. This is the third step in the interpolation
process after <a href="#topic+aw_weight">aw_weight</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aw_weight(.data, areaVar, totalVar, areaWeight)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aw_weight_+3A_.data">.data</code></td>
<td>
<p>A <code>sf</code> object that has been intersected using <a href="#topic+aw_intersect">aw_intersect</a></p>
</td></tr>
<tr><td><code id="aw_weight_+3A_areavar">areaVar</code></td>
<td>
<p>The name of the variable measuring a feature's area</p>
</td></tr>
<tr><td><code id="aw_weight_+3A_totalvar">totalVar</code></td>
<td>
<p>The name of the variable containing total area field by <code>source</code> id</p>
</td></tr>
<tr><td><code id="aw_weight_+3A_areaweight">areaWeight</code></td>
<td>
<p>The name of a new area weight field to be calculated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>sf</code> object with the intersected data and new area weight field.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

race &lt;- select(ar_stl_race, GEOID, TOTAL_E)
wards &lt;- select(ar_stl_wards, WARD)

wards %&gt;%
    aw_intersect(source = race, areaVar = "area") %&gt;%
    aw_total(source = race, id = GEOID, areaVar = "area", totalVar = "totalArea",
             weight = "sum", type = "extensive") -&gt; intersect

aw_weight(intersect, areaVar = "area", totalVar = "totalArea", areaWeight = "areaWeight")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
