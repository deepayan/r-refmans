<!DOCTYPE html><html><head><title>Help for package rpostgis</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rpostgis}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bs'><p>Return indexes for an exact number of blocks for a raster</p></a></li>
<li><a href='#dbAddKey'><p>Add key.</p></a></li>
<li><a href='#dbAsDate'><p>Converts to timestamp.</p></a></li>
<li><a href='#dbBuildTableQuery'><p>Builds CREATE TABLE query for a data frame object.</p></a></li>
<li><a href='#dbColumn'><p>Add or remove a column.</p></a></li>
<li><a href='#dbComment'><p>Comment table/view/schema.</p></a></li>
<li><a href='#dbConnCheck'><p>Check if a supported PostgreSQL connection</p></a></li>
<li><a href='#dbDrop'><p>Drop table/view/schema.</p></a></li>
<li><a href='#dbExistsTable'><p>Check if a PostgreSQL table/view exists</p></a></li>
<li><a href='#dbGetDefs'><p>Get definitions for data frame mode reading</p></a></li>
<li><a href='#dbIndex'><p>Create an index.</p></a></li>
<li><a href='#dbSchema'><p>Check and create schema.</p></a></li>
<li><a href='#dbTableInfo'><p>Get information about table columns.</p></a></li>
<li><a href='#dbTableNameFix'><p>Format input for database schema/table names.</p></a></li>
<li><a href='#dbVacuum'><p>Vacuum.</p></a></li>
<li><a href='#dbVersion'><p>Returns major.minor version of PostgreSQL (for version checking)</p></a></li>
<li><a href='#dbWriteDataFrame'><p>Write/read in data frame mode to/from database table.</p></a></li>
<li><a href='#pgCheckGeom'><p>Check if geometry or geography column exists in a table,</p>
and return the column name for use in a query.</a></li>
<li><a href='#pgGetBoundary'><p>Retrieve bounding envelope of geometries or rasters.</p></a></li>
<li><a href='#pgGetGeom'><p>Load a PostGIS geometry from a PostgreSQL table/view/query into R.</p></a></li>
<li><a href='#pgGetGeomQ'><p>Load geometries from a full query and return a Spatial* object</p></a></li>
<li><a href='#pgGetRast'><p>Load raster from PostGIS database into R.</p></a></li>
<li><a href='#pgGetSRID'><p>Get SRID(s) from a geometry/geography column in a full table</p></a></li>
<li><a href='#pgInsert'><p>Inserts data into a PostgreSQL table.</p></a></li>
<li><a href='#pgInsertizeGeom'><p>Format R data objects for insert into a PostgreSQL table.</p></a></li>
<li><a href='#pgListGeom'><p>List geometries/rasters</p></a></li>
<li><a href='#pgMakePts'><p>Add a POINT or LINESTRING geometry field.</p></a></li>
<li><a href='#pgPostGIS'><p>Check and create PostGIS extension.</p></a></li>
<li><a href='#pgSRID'><p>Find (or create) PostGIS SRID based on CRS object.</p></a></li>
<li><a href='#pgWriteGeom'><p>Inserts data into a PostgreSQL table.</p></a></li>
<li><a href='#pgWriteRast'><p>Write raster to PostGIS database table.</p></a></li>
<li><a href='#rpostgis'><p>R interface to a PostGIS database.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.5.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-20</td>
</tr>
<tr>
<td>Title:</td>
<td>R Interface to a 'PostGIS' Database</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides an interface between R and 'PostGIS'-enabled
    'PostgreSQL' databases to transparently transfer spatial
    data. Both vector (points, lines, polygons) and raster data are
    supported in read and write modes. Also provides convenience
    functions to execute common procedures in 'PostgreSQL/PostGIS'.</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>'PostgreSQL' with 'PostGIS' extension</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0), RPostgreSQL, DBI (&ge; 0.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, sp, stats, terra (&ge; 1.6.7), purrr, sf, raster</td>
</tr>
<tr>
<td>Suggests:</td>
<td>RPostgres, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://cidree.github.io/rpostgis/">https://cidree.github.io/rpostgis/</a>,
<a href="https://github.com/Cidree/rpostgis">https://github.com/Cidree/rpostgis</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Cidree/rpostgis/issues">https://github.com/Cidree/rpostgis/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-20 13:50:45 UTC; cidre</td>
</tr>
<tr>
<td>Author:</td>
<td>Mathieu Basille <a href="https://orcid.org/0000-0001-9366-7127"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  David Bucklin [aut],
  Adrián Cidre González
    <a href="https://orcid.org/0000-0002-3310-3052"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adrián Cidre González &lt;adrian.cidre@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-20 14:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='bs'>Return indexes for an exact number of blocks for a raster</h2><span id='topic+bs'></span>

<h3>Description</h3>

<p>Return indexes for an exact number of blocks for a raster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bs(r, blocks)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bs_+3A_r">r</code></td>
<td>
<p>a RasterLayer or SpatRaster object</p>
</td></tr>
<tr><td><code id="bs_+3A_blocks">blocks</code></td>
<td>
<p>Number of desired blocks (columns, rows)</p>
</td></tr>
</table>

<hr>
<h2 id='dbAddKey'>Add key.</h2><span id='topic+dbAddKey'></span>

<h3>Description</h3>

<p>Add a primary or foreign key to a table column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbAddKey(
  conn,
  name,
  colname,
  type = c("primary", "foreign"),
  reference,
  colref,
  display = TRUE,
  exec = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbAddKey_+3A_conn">conn</code></td>
<td>
<p>A connection object.</p>
</td></tr>
<tr><td><code id="dbAddKey_+3A_name">name</code></td>
<td>
<p>A character string, or a character vector, specifying
a PostgreSQL table name.</p>
</td></tr>
<tr><td><code id="dbAddKey_+3A_colname">colname</code></td>
<td>
<p>A character string specifying the name of the
column to which the key will be assign; alternatively, a
character vector specifying the name of the columns for keys
spanning more than one column.</p>
</td></tr>
<tr><td><code id="dbAddKey_+3A_type">type</code></td>
<td>
<p>The type of the key, either <code>"primary"</code> or
<code>"foreign"</code></p>
</td></tr>
<tr><td><code id="dbAddKey_+3A_reference">reference</code></td>
<td>
<p>A character string specifying a foreign table
name to which the foreign key will be associated (ignored if
<code>type == "primary"</code>).</p>
</td></tr>
<tr><td><code id="dbAddKey_+3A_colref">colref</code></td>
<td>
<p>A character string specifying the name of the
primary key in the foreign table to which the foreign key will
be associated; alternatively, a character vector specifying
the name of the columns for keys spanning more than one column
(ignored if <code>type == "primary"</code>).</p>
</td></tr>
<tr><td><code id="dbAddKey_+3A_display">display</code></td>
<td>
<p>Logical. Whether to display the query (defaults to
<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="dbAddKey_+3A_exec">exec</code></td>
<td>
<p>Logical. Whether to execute the query (defaults to
<code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>exec = TRUE</code>, returns <code>TRUE</code> if the key was successfully added.
</p>


<h3>Author(s)</h3>

<p>Mathieu Basille <a href="mailto:mathieu@basille.org">mathieu@basille.org</a>
</p>


<h3>See Also</h3>

<p>The PostgreSQL documentation:
<a href="http://www.postgresql.org/docs/current/static/sql-altertable.html">http://www.postgresql.org/docs/current/static/sql-altertable.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Examples use a dummy connection from DBI package
conn &lt;- DBI::ANSI()

## Primary key
dbAddKey(conn, name = c("sch1", "tbl1"), colname = "id1", exec = FALSE)

## Primary key using multiple columns
dbAddKey(conn, name = c("sch1", "tbl1"), colname = c("id1", "id2",
    "id3"), exec = FALSE)

## Foreign key
dbAddKey(conn, name = c("sch1", "tbl1"), colname = "id", type = "foreign",
    reference = c("sch2", "tbl2"), colref = "id", exec = FALSE)

## Foreign key using multiple columns
dbAddKey(conn, name = c("sch1", "tbl1"), colname = c("id1", "id2"),
    type = "foreign", reference = c("sch2", "tbl2"), colref = c("id3",
        "id4"), exec = FALSE)
</code></pre>

<hr>
<h2 id='dbAsDate'>Converts to timestamp.</h2><span id='topic+dbAsDate'></span>

<h3>Description</h3>

<p>Convert a date field to a timestamp with or without time zone.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbAsDate(conn, name, date = "date", tz = NULL, display = TRUE, exec = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbAsDate_+3A_conn">conn</code></td>
<td>
<p>A connection object.</p>
</td></tr>
<tr><td><code id="dbAsDate_+3A_name">name</code></td>
<td>
<p>A character string specifying a PostgreSQL table name.</p>
</td></tr>
<tr><td><code id="dbAsDate_+3A_date">date</code></td>
<td>
<p>A character string specifying the date field.</p>
</td></tr>
<tr><td><code id="dbAsDate_+3A_tz">tz</code></td>
<td>
<p>A character string specifying the time zone, in
<code>"EST"</code>, <code>"America/New_York"</code>, <code>"EST5EDT"</code>,
<code>"-5"</code>.</p>
</td></tr>
<tr><td><code id="dbAsDate_+3A_display">display</code></td>
<td>
<p>Logical. Whether to display the query (defaults to
<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="dbAsDate_+3A_exec">exec</code></td>
<td>
<p>Logical. Whether to execute the query (defaults to
<code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>exec = TRUE</code>, returns <code>TRUE</code> if the
conversion was successful.
</p>


<h3>Author(s)</h3>

<p>Mathieu Basille <a href="mailto:mathieu@basille.org">mathieu@basille.org</a>
</p>


<h3>See Also</h3>

<p>The PostgreSQL documentation:
<a href="http://www.postgresql.org/docs/current/static/datatype-datetime.html">http://www.postgresql.org/docs/current/static/datatype-datetime.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example uses a dummy connection from DBI package
conn &lt;- DBI::ANSI()
dbAsDate(conn, name = c("schema", "table"), date = "date", tz = "GMT",
    exec = FALSE)
</code></pre>

<hr>
<h2 id='dbBuildTableQuery'>Builds CREATE TABLE query for a data frame object.</h2><span id='topic+dbBuildTableQuery'></span>

<h3>Description</h3>

<p>Builds CREATE TABLE query for a data frame object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbBuildTableQuery(
  conn = NULL,
  name,
  obj,
  field.types = NULL,
  row.names = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbBuildTableQuery_+3A_conn">conn</code></td>
<td>
<p>A PostgreSQL connection</p>
</td></tr>
<tr><td><code id="dbBuildTableQuery_+3A_name">name</code></td>
<td>
<p>Table name string, length 1-2.</p>
</td></tr>
<tr><td><code id="dbBuildTableQuery_+3A_obj">obj</code></td>
<td>
<p>A data frame object.</p>
</td></tr>
<tr><td><code id="dbBuildTableQuery_+3A_field.types">field.types</code></td>
<td>
<p>optional named list of the types for each field in <code>obj</code></p>
</td></tr>
<tr><td><code id="dbBuildTableQuery_+3A_row.names">row.names</code></td>
<td>
<p>logical, should row.name of <code>obj</code> be exported as a row_names field? Default is FALSE</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Adapted from RPostgreSQL::postgresqlBuildTableDefinition
</p>

<hr>
<h2 id='dbColumn'>Add or remove a column.</h2><span id='topic+dbColumn'></span>

<h3>Description</h3>

<p>Add or remove a column to/from a table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbColumn(
  conn,
  name,
  colname,
  action = c("add", "drop"),
  coltype = "integer",
  cascade = FALSE,
  display = TRUE,
  exec = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbColumn_+3A_conn">conn</code></td>
<td>
<p>A connection object.</p>
</td></tr>
<tr><td><code id="dbColumn_+3A_name">name</code></td>
<td>
<p>A character string specifying a PostgreSQL table name.</p>
</td></tr>
<tr><td><code id="dbColumn_+3A_colname">colname</code></td>
<td>
<p>A character string specifying the name of the
column</p>
</td></tr>
<tr><td><code id="dbColumn_+3A_action">action</code></td>
<td>
<p>A character string specifying if the column is to be
added (<code>"add"</code>, default) or removed (<code>"drop"</code>).</p>
</td></tr>
<tr><td><code id="dbColumn_+3A_coltype">coltype</code></td>
<td>
<p>A character string indicating the type of the
column, if <code>action = "add"</code>.</p>
</td></tr>
<tr><td><code id="dbColumn_+3A_cascade">cascade</code></td>
<td>
<p>Logical. Whether to drop foreign key constraints of
other tables, if <code>action = "drop"</code>.</p>
</td></tr>
<tr><td><code id="dbColumn_+3A_display">display</code></td>
<td>
<p>Logical. Whether to display the query (defaults to
<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="dbColumn_+3A_exec">exec</code></td>
<td>
<p>Logical. Whether to execute the query (defaults to
<code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>exec = TRUE</code>, returns <code>TRUE</code> if the column was
successfully added or removed.
</p>


<h3>Author(s)</h3>

<p>Mathieu Basille <a href="mailto:mathieu@basille.org">mathieu@basille.org</a>
</p>


<h3>See Also</h3>

<p>The PostgreSQL documentation:
<a href="http://www.postgresql.org/docs/current/static/sql-altertable.html">http://www.postgresql.org/docs/current/static/sql-altertable.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## examples use a dummy connection from DBI package
conn&lt;-DBI::ANSI()
## Add an integer column
dbColumn(conn, name = c("schema", "table"), colname = "field", exec = FALSE)
## Drop a column (with CASCADE)
dbColumn(conn, name = c("schema", "table"), colname = "field", action = "drop",
    cascade = TRUE, exec = FALSE)
</code></pre>

<hr>
<h2 id='dbComment'>Comment table/view/schema.</h2><span id='topic+dbComment'></span>

<h3>Description</h3>

<p>Comment on a table, a view or a schema.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbComment(
  conn,
  name,
  comment,
  type = c("table", "view", "schema"),
  display = TRUE,
  exec = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbComment_+3A_conn">conn</code></td>
<td>
<p>A connection object.</p>
</td></tr>
<tr><td><code id="dbComment_+3A_name">name</code></td>
<td>
<p>A character string specifying a PostgreSQL table, view
or schema name.</p>
</td></tr>
<tr><td><code id="dbComment_+3A_comment">comment</code></td>
<td>
<p>A character string specifying the comment.</p>
</td></tr>
<tr><td><code id="dbComment_+3A_type">type</code></td>
<td>
<p>The type of the object to comment, either <code>"table"</code>, <code>"view"</code>,
or <code>"schema"</code></p>
</td></tr>
<tr><td><code id="dbComment_+3A_display">display</code></td>
<td>
<p>Logical. Whether to display the query (defaults to
<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="dbComment_+3A_exec">exec</code></td>
<td>
<p>Logical. Whether to execute the query (defaults to
<code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>exec = TRUE</code>, returns <code>TRUE</code> if the comment was
successfully applied.
</p>


<h3>Author(s)</h3>

<p>Mathieu Basille <a href="mailto:mathieu@basille.org">mathieu@basille.org</a>
</p>


<h3>See Also</h3>

<p>The PostgreSQL documentation:
<a href="http://www.postgresql.org/docs/current/static/sql-comment.html">http://www.postgresql.org/docs/current/static/sql-comment.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## examples use a dummy connection from DBI package
conn &lt;- DBI::ANSI()
dbComment(conn, name = c("schema", "table"), comment = "Comment on a view.",
    type = "view", exec = FALSE)
dbComment(conn, name = "test_schema", comment = "Comment on a schema.", type = "schema",
    exec = FALSE)
</code></pre>

<hr>
<h2 id='dbConnCheck'>Check if a supported PostgreSQL connection</h2><span id='topic+dbConnCheck'></span>

<h3>Description</h3>

<p>Check if a supported PostgreSQL connection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbConnCheck(conn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbConnCheck_+3A_conn">conn</code></td>
<td>
<p>A PostgreSQL connection</p>
</td></tr>
</table>

<hr>
<h2 id='dbDrop'>Drop table/view/schema.</h2><span id='topic+dbDrop'></span>

<h3>Description</h3>

<p>Drop a table, a view or a schema.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbDrop(
  conn,
  name,
  type = c("table", "schema", "view", "materialized view"),
  ifexists = FALSE,
  cascade = FALSE,
  display = TRUE,
  exec = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbDrop_+3A_conn">conn</code></td>
<td>
<p>A connection object.</p>
</td></tr>
<tr><td><code id="dbDrop_+3A_name">name</code></td>
<td>
<p>A character string specifying a PostgreSQL table, schema, or view name.</p>
</td></tr>
<tr><td><code id="dbDrop_+3A_type">type</code></td>
<td>
<p>The type of the object to drop, either <code>"table"</code>, <code>"schema"</code>,
<code>"view"</code>, or <code>"materialized view"</code>.</p>
</td></tr>
<tr><td><code id="dbDrop_+3A_ifexists">ifexists</code></td>
<td>
<p>Do not throw an error if the object does not
exist. A notice is issued in this case.</p>
</td></tr>
<tr><td><code id="dbDrop_+3A_cascade">cascade</code></td>
<td>
<p>Automatically drop objects that depend on the object
(such as views).</p>
</td></tr>
<tr><td><code id="dbDrop_+3A_display">display</code></td>
<td>
<p>Logical. Whether to display the query (defaults to
<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="dbDrop_+3A_exec">exec</code></td>
<td>
<p>Logical. Whether to execute the query (defaults to
<code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>exec = TRUE</code>, returns <code>TRUE</code> if the table/schema/view
was successfully dropped.
</p>


<h3>Author(s)</h3>

<p>Mathieu Basille <a href="mailto:mathieu@basille.org">mathieu@basille.org</a>
</p>


<h3>See Also</h3>

<p>The PostgreSQL documentation:
<a href="http://www.postgresql.org/docs/current/static/sql-droptable.html">http://www.postgresql.org/docs/current/static/sql-droptable.html</a>,
<a href="http://www.postgresql.org/docs/current/static/sql-dropview.html">http://www.postgresql.org/docs/current/static/sql-dropview.html</a>,
<a href="http://www.postgresql.org/docs/current/static/sql-dropschema.html">http://www.postgresql.org/docs/current/static/sql-dropschema.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## examples use a dummy connection from DBI package
conn &lt;- DBI::ANSI()
dbDrop(conn, name = c("schema", "view_name"), type = "view", exec = FALSE)
dbDrop(conn, name = "test_schema", type = "schema", cascade = "TRUE", exec = FALSE)
</code></pre>

<hr>
<h2 id='dbExistsTable'>Check if a PostgreSQL table/view exists</h2><span id='topic+dbExistsTable'></span>

<h3>Description</h3>

<p>Check if a PostgreSQL table/view exists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbExistsTable(conn, name, table.only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbExistsTable_+3A_conn">conn</code></td>
<td>
<p>A PostgreSQL connection</p>
</td></tr>
<tr><td><code id="dbExistsTable_+3A_name">name</code></td>
<td>
<p>Table/view name string, length 1-2.</p>
</td></tr>
</table>

<hr>
<h2 id='dbGetDefs'>Get definitions for data frame mode reading</h2><span id='topic+dbGetDefs'></span>

<h3>Description</h3>

<p>Get definitions for data frame mode reading
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbGetDefs(conn, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbGetDefs_+3A_conn">conn</code></td>
<td>
<p>A PostgreSQL connection</p>
</td></tr>
<tr><td><code id="dbGetDefs_+3A_name">name</code></td>
<td>
<p>Table/view name string, length 1-2.</p>
</td></tr>
</table>

<hr>
<h2 id='dbIndex'>Create an index.</h2><span id='topic+dbIndex'></span>

<h3>Description</h3>

<p>Defines a new index on a PostgreSQL table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbIndex(
  conn,
  name,
  colname,
  idxname,
  unique = FALSE,
  method = c("btree", "hash", "rtree", "gist"),
  display = TRUE,
  exec = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbIndex_+3A_conn">conn</code></td>
<td>
<p>A connection object.</p>
</td></tr>
<tr><td><code id="dbIndex_+3A_name">name</code></td>
<td>
<p>A character string specifying a PostgreSQL table name.</p>
</td></tr>
<tr><td><code id="dbIndex_+3A_colname">colname</code></td>
<td>
<p>A character string, or a character vector
specifying the name of the column to which the key will be
associated; alternatively, a character vector specifying the
name of the columns to build the index.</p>
</td></tr>
<tr><td><code id="dbIndex_+3A_idxname">idxname</code></td>
<td>
<p>A character string specifying the name of the index
to be created. By default, this uses the name of the table
(without the schema) and the name of the columns as follows:
<code>&lt;table_name&gt;_&lt;column_names&gt;_idx</code>.</p>
</td></tr>
<tr><td><code id="dbIndex_+3A_unique">unique</code></td>
<td>
<p>Logical. Causes the system to check for duplicate
values in the table when the index is created (if data already
exist) and each time data is added. Attempts to insert or
update data which would result in duplicate entries will
generate an error.</p>
</td></tr>
<tr><td><code id="dbIndex_+3A_method">method</code></td>
<td>
<p>The name of the method to be used for the
index. Choices are <code>"btree"</code>, <code>"hash"</code>,
<code>"rtree"</code>, and <code>"gist"</code>. The default method is
<code>"btree"</code>, although <code>"gist"</code> should be the index of
choice for PostGIS spatial types (geometry, geography,
raster).</p>
</td></tr>
<tr><td><code id="dbIndex_+3A_display">display</code></td>
<td>
<p>Logical. Whether to display the query (defaults to
<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="dbIndex_+3A_exec">exec</code></td>
<td>
<p>Logical. Whether to execute the query (defaults to
<code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>exec = TRUE</code>, returns <code>TRUE</code> if the index was
successfully created.
</p>


<h3>Author(s)</h3>

<p>Mathieu Basille <a href="mailto:mathieu@basille.org">mathieu@basille.org</a>
</p>


<h3>See Also</h3>

<p>The PostgreSQL documentation:
<a href="http://www.postgresql.org/docs/current/static/sql-createindex.html">http://www.postgresql.org/docs/current/static/sql-createindex.html</a>;
the PostGIS documentation for GiST indexes:
<a href="http://postgis.net/docs/using_postgis_dbmanagement.html#id541286">http://postgis.net/docs/using_postgis_dbmanagement.html#id541286</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Examples use a dummy connection from DBI package
conn &lt;- DBI::ANSI()

## GIST index
dbIndex(conn, name = c("sch", "tbl"), colname = "geom", method = "gist",
    exec = FALSE)

## Regular BTREE index on multiple columns
dbIndex(conn, name = c("sch", "tbl"), colname = c("col1", "col2",
    "col3"), exec = FALSE)
</code></pre>

<hr>
<h2 id='dbSchema'>Check and create schema.</h2><span id='topic+dbSchema'></span>

<h3>Description</h3>

<p>Checks the existence, and if necessary, creates a schema.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbSchema(conn, name, display = TRUE, exec = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbSchema_+3A_conn">conn</code></td>
<td>
<p>A connection object (required, even if <code>exec =
FALSE</code>).</p>
</td></tr>
<tr><td><code id="dbSchema_+3A_name">name</code></td>
<td>
<p>A character string specifying a PostgreSQL schema
name.</p>
</td></tr>
<tr><td><code id="dbSchema_+3A_display">display</code></td>
<td>
<p>Logical. Whether to display the query (defaults to
<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="dbSchema_+3A_exec">exec</code></td>
<td>
<p>Logical. Whether to execute the query (defaults to
<code>TRUE</code>). Note: if <code>exec = FALSE</code>, the function still
checks the existence of the schema, but does not create it if
it does not exists.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>exec = TRUE</code>, returns <code>TRUE</code> if the schema exists
(whether it was already available or was just created).
</p>


<h3>Author(s)</h3>

<p>Mathieu Basille <a href="mailto:mathieu@basille.org">mathieu@basille.org</a>
</p>


<h3>See Also</h3>

<p>The PostgreSQL documentation:
<a href="http://www.postgresql.org/docs/current/static/sql-createschema.html">http://www.postgresql.org/docs/current/static/sql-createschema.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    dbSchema(conn, name = "schema", exec = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='dbTableInfo'>Get information about table columns.</h2><span id='topic+dbTableInfo'></span>

<h3>Description</h3>

<p>Get information about columns in a PostgreSQL table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbTableInfo(conn, name, allinfo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbTableInfo_+3A_conn">conn</code></td>
<td>
<p>A connection object to a PostgreSQL database.</p>
</td></tr>
<tr><td><code id="dbTableInfo_+3A_name">name</code></td>
<td>
<p>A character string specifying a PostgreSQL schema (if
necessary), and table or view name (e.g., <code>name
= c("schema", "table")</code>).</p>
</td></tr>
<tr><td><code id="dbTableInfo_+3A_allinfo">allinfo</code></td>
<td>
<p>Logical, Get all information on table? Default is
column names, types, nullable, and maximum length of character
columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Author(s)</h3>

<p>David Bucklin <a href="mailto:david.bucklin@gmail.com">david.bucklin@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dbTableInfo(conn, c("schema", "table"))

## End(Not run)
</code></pre>

<hr>
<h2 id='dbTableNameFix'>Format input for database schema/table names.</h2><span id='topic+dbTableNameFix'></span>

<h3>Description</h3>

<p>Internal rpostgis function to return common (length = 2) schema
and table name vector from various table and schema + table name
inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbTableNameFix(conn = NULL, t.nm, as.identifier = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbTableNameFix_+3A_conn">conn</code></td>
<td>
<p>A connection object. Must be provided but can be set NULL,
where a dummy connection will be used.</p>
</td></tr>
<tr><td><code id="dbTableNameFix_+3A_t.nm">t.nm</code></td>
<td>
<p>Table name string, length 1-2.</p>
</td></tr>
<tr><td><code id="dbTableNameFix_+3A_as.identifier">as.identifier</code></td>
<td>
<p>Boolean whether to return (schema,table) name as database
sanitized identifiers (TRUE) or as regular character (FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of length 2. Each character element is in
(escaped) double-quotes when as.identifier = TRUE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
name &lt;- c("schema", "table")
dbTableNameFix(conn,name)

## Current search path schema is added to single-length character
## object (if only table is given)
name &lt;- "table"
dbTableNameFix(conn, name)

## Schema or table names with double quotes should be given exactly as
## they are (make sure to wrap in single quotes in R):
name &lt;- c('sch"ema', '"table"')
dbTableNameFix(conn, name)

## End(Not run)
</code></pre>

<hr>
<h2 id='dbVacuum'>Vacuum.</h2><span id='topic+dbVacuum'></span>

<h3>Description</h3>

<p>Performs a VACUUM (garbage-collect and optionally analyze) on a
table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbVacuum(
  conn,
  name,
  full = FALSE,
  verbose = FALSE,
  analyze = TRUE,
  display = TRUE,
  exec = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbVacuum_+3A_conn">conn</code></td>
<td>
<p>A connection object.</p>
</td></tr>
<tr><td><code id="dbVacuum_+3A_name">name</code></td>
<td>
<p>A character string specifying a PostgreSQL table name.</p>
</td></tr>
<tr><td><code id="dbVacuum_+3A_full">full</code></td>
<td>
<p>Logical. Whether to perform a &quot;full&quot; vacuum, which can
reclaim more space, but takes much longer and exclusively
locks the table.</p>
</td></tr>
<tr><td><code id="dbVacuum_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to print a detailed vacuum
activity report for each table.</p>
</td></tr>
<tr><td><code id="dbVacuum_+3A_analyze">analyze</code></td>
<td>
<p>Logical. Whether to update statistics used by the
planner to determine the most efficient way to execute a query
(default to <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="dbVacuum_+3A_display">display</code></td>
<td>
<p>Logical. Whether to display the query (defaults to
<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="dbVacuum_+3A_exec">exec</code></td>
<td>
<p>Logical. Whether to execute the query (defaults to
<code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>exec = TRUE</code>, returns TRUE if query is successfully executed.
</p>


<h3>Author(s)</h3>

<p>Mathieu Basille <a href="mailto:mathieu@basille.org">mathieu@basille.org</a>
</p>


<h3>See Also</h3>

<p>The PostgreSQL documentation:
<a href="http://www.postgresql.org/docs/current/static/sql-vacuum.html">http://www.postgresql.org/docs/current/static/sql-vacuum.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## examples use a dummy connection from DBI package
conn &lt;- DBI::ANSI()
dbVacuum(conn, name = c("schema", "table"), full = TRUE, exec = FALSE)
</code></pre>

<hr>
<h2 id='dbVersion'>Returns major.minor version of PostgreSQL (for version checking)</h2><span id='topic+dbVersion'></span>

<h3>Description</h3>

<p>Returns major.minor version of PostgreSQL (for version checking)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbVersion(conn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbVersion_+3A_conn">conn</code></td>
<td>
<p>A PostgreSQL connection</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector of length 3 of major,minor,bug version.
</p>

<hr>
<h2 id='dbWriteDataFrame'>Write/read in data frame mode to/from database table.</h2><span id='topic+dbWriteDataFrame'></span><span id='topic+dbWriteDF'></span><span id='topic+dbReadDataFrame'></span><span id='topic+dbReadDF'></span>

<h3>Description</h3>

<p>Write <code>data.frame</code> or similar (e.g. <code>tibble</code>) to database table, 
with column definitions, row names, and a new integer primary key column. 
Read back into R with <code>dbReadDataFrame</code>, which recreates original 
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbWriteDataFrame(conn, name, df, overwrite = FALSE, only.defs = FALSE)

dbReadDataFrame(conn, name, df = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbWriteDataFrame_+3A_conn">conn</code></td>
<td>
<p>A connection object to a PostgreSQL database</p>
</td></tr>
<tr><td><code id="dbWriteDataFrame_+3A_name">name</code></td>
<td>
<p>Character, schema and table of the PostgreSQL table</p>
</td></tr>
<tr><td><code id="dbWriteDataFrame_+3A_df">df</code></td>
<td>
<p>The data frame to write (for <code>dbReadDataFrame</code>, this
allows to update an existing <code>data.frame</code> with definitions
stored in the database)</p>
</td></tr>
<tr><td><code id="dbWriteDataFrame_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical; if TRUE, a new table (<code>name</code>) will
overwrite the existing table (<code>name</code>) in the database. Note:
overwriting a view must be done manually (e.g., with <code><a href="#topic+dbDrop">dbDrop</a></code>).</p>
</td></tr>
<tr><td><code id="dbWriteDataFrame_+3A_only.defs">only.defs</code></td>
<td>
<p>Logical; if <code>TRUE</code>, only the table
definitions will be written.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Writing in data frame mode is only for new database tables (or for
overwriting an existing one). It will save all column names as they
appear in R, along with column data types and attributes. This is
done by adding metadata to a lookup table in the table's schema
named &quot;.R_df_defs&quot; (will be created if not present). It also adds
two fields with fixed names to the database table: &quot;.R_rownames&quot;
(storing the row.names of the data frame), and &quot;.db_pkid&quot;, which is
a new integer primary key. Existing columns in the data.frame
matching these names will be automatically changed.
</p>
<p>The <code>rpostgis</code> database table read functions
<code>dbReadDataFrame</code> and <code>pgGetGeom</code> will use the metadata
created in data frame mode to recreate a data.frame in R, if it is
available. Otherwise, it will be imported using default
<code>RPostgreSQL::dbGetQuery</code> methods.
</p>
<p>All spatial objects must be written with <code><a href="#topic+pgWriteGeom">pgWriteGeom</a></code>.
For more flexible writing of <code>data.frame</code>s to the database
(including all writing into existing database tables), use
<code><a href="#topic+pgWriteGeom">pgWriteGeom</a></code> with <code>df.mode = FALSE</code>.
</p>


<h3>Value</h3>

<p><code>TRUE</code> for successful write with
<code>dbWriteDataFrame</code>, <code>data.frame</code> for
<code>dbReadDataFrame</code>
</p>


<h3>Author(s)</h3>

<p>David Bucklin <a href="mailto:david.bucklin@gmail.com">david.bucklin@gmail.com</a>
</p>
<p>Adrián Cidre González <a href="mailto:adrian.cidre@gmail.com">adrian.cidre@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(datasets)

## Write the mtcars data.frame to the database:
dbWriteDataFrame(conn, name = "mtcars_data", df = mtcars)

## Reads it back into a different object:
mtcars2 &lt;- dbReadDataFrame(conn, name = "mtcars_data")

## Check equality:
all.equal(mtcars, mtcars2)
## Should return TRUE.

## End(Not run)
</code></pre>

<hr>
<h2 id='pgCheckGeom'>Check if geometry or geography column exists in a table,
and return the column name for use in a query.</h2><span id='topic+pgCheckGeom'></span>

<h3>Description</h3>

<p>Check if geometry or geography column exists in a table,
and return the column name for use in a query.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgCheckGeom(conn, name, geom)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgCheckGeom_+3A_conn">conn</code></td>
<td>
<p>A PostgreSQL connection</p>
</td></tr>
<tr><td><code id="pgCheckGeom_+3A_name">name</code></td>
<td>
<p>A table name formatted for use in a query</p>
</td></tr>
<tr><td><code id="pgCheckGeom_+3A_geom">geom</code></td>
<td>
<p>a geometry or geography column name</p>
</td></tr>
</table>

<hr>
<h2 id='pgGetBoundary'>Retrieve bounding envelope of geometries or rasters.</h2><span id='topic+pgGetBoundary'></span>

<h3>Description</h3>

<p>Retrieve bounding envelope (rectangle) of all geometries or
rasters in a PostGIS table as a <code>sfc</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgGetBoundary(conn, name, geom = "geom", clauses = NULL, returnclass = "sf")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgGetBoundary_+3A_conn">conn</code></td>
<td>
<p>A connection object to a PostgreSQL database</p>
</td></tr>
<tr><td><code id="pgGetBoundary_+3A_name">name</code></td>
<td>
<p>A character string specifying a PostgreSQL schema and
table/view name holding the geometry (e.g., <code>name =
c("schema","table")</code>)</p>
</td></tr>
<tr><td><code id="pgGetBoundary_+3A_geom">geom</code></td>
<td>
<p>A character string specifying the name of the geometry column
in the table <code>name</code> (Default = <code>"geom"</code>). Note that for raster objects
you will need to change the default value</p>
</td></tr>
<tr><td><code id="pgGetBoundary_+3A_clauses">clauses</code></td>
<td>
<p>character, additional SQL to append to modify select
query from table. Must begin with an SQL clause (e.g., &quot;WHERE ...&quot;,
&quot;ORDER BY ...&quot;, &quot;LIMIT ...&quot;); same usage as in <code>pgGetGeom</code>.</p>
</td></tr>
<tr><td><code id="pgGetBoundary_+3A_returnclass">returnclass</code></td>
<td>
<p>'sf' by default; 'terra' for <code>SpatVector</code>; 
or 'sp' for <code>sp</code> objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class sfc (list-column with geometries); 
SpatVector or sp object
</p>


<h3>Author(s)</h3>

<p>David Bucklin <a href="mailto:david.bucklin@gmail.com">david.bucklin@gmail.com</a> and Adrian Cidre 
González <a href="mailto:adrian.cidre@gmail.com">adrian.cidre@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pgGetBoundary(conn, c("schema", "polys"), geom = "geom")
pgGetBoundary(conn, c("schema", "rasters"), geom = "rast")

## End(Not run)
</code></pre>

<hr>
<h2 id='pgGetGeom'>Load a PostGIS geometry from a PostgreSQL table/view/query into R.</h2><span id='topic+pgGetGeom'></span>

<h3>Description</h3>

<p>Retrieve geometries from a PostGIS table/view/query, and convert
it to an R <code>sf</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgGetGeom(
  conn,
  name,
  geom = "geom",
  gid = NULL,
  other.cols = TRUE,
  clauses = NULL,
  boundary = NULL,
  query = NULL,
  returnclass = "sf"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgGetGeom_+3A_conn">conn</code></td>
<td>
<p>A connection object to a PostgreSQL database</p>
</td></tr>
<tr><td><code id="pgGetGeom_+3A_name">name</code></td>
<td>
<p>A character string specifying a PostgreSQL schema and
table/view name holding the geometry (e.g., <code>name =
c("schema","table")</code>)</p>
</td></tr>
<tr><td><code id="pgGetGeom_+3A_geom">geom</code></td>
<td>
<p>The name of the geometry/(geography) column. (Default = <code>"geom"</code>)</p>
</td></tr>
<tr><td><code id="pgGetGeom_+3A_gid">gid</code></td>
<td>
<p>Name of the column in <code>name</code> holding the IDs. Should be
unique for each record to return. <code>gid=NULL</code> (default) automatically
creates a new unique ID for each row in the <code>sf</code> object.</p>
</td></tr>
<tr><td><code id="pgGetGeom_+3A_other.cols">other.cols</code></td>
<td>
<p>Names of specific columns in the table to
retrieve, in a character vector (e.g. <code>other.cols.=c("col1","col2")</code>.)
The default (<code>other.cols = TRUE</code>) is to attach
all columns. Setting <code>other.cols=FALSE</code> will return a Spatial-only
object without attributes (no data frame).</p>
</td></tr>
<tr><td><code id="pgGetGeom_+3A_clauses">clauses</code></td>
<td>
<p>character, additional SQL to append to modify select
query from table. Must begin with an SQL clause (e.g., &quot;WHERE ...&quot;,
&quot;ORDER BY ...&quot;, &quot;LIMIT ...&quot;); see below for examples.</p>
</td></tr>
<tr><td><code id="pgGetGeom_+3A_boundary">boundary</code></td>
<td>
<p><code>sf</code>, <code>SpatVector</code> or <code>sp</code> object; or numeric.
If a spatial object is provided, its bounding box will be used to select
geometries to import. Alternatively, a numeric vector (<code>c([top],
[bottom], [right], [left])</code>) indicating the projection-specific limits with
which to subset the spatial data. If not value is provided, the default
<code>boundary = NULL</code> will not apply any boundary subset.</p>
</td></tr>
<tr><td><code id="pgGetGeom_+3A_query">query</code></td>
<td>
<p>character, a full SQL query including a geometry column.
For use with query mode only (see details).</p>
</td></tr>
<tr><td><code id="pgGetGeom_+3A_returnclass">returnclass</code></td>
<td>
<p>'sf' by default; 'terra' for <code>SpatVector</code>;
or 'sp' for <code>sp</code> objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The features of the table to retrieve must have the same geometry type.
The query mode version of <code>pgGetGeom</code> allows the user to enter a
complete SQL query (<code>query</code>) that returns a Geometry column, and save
the query as a new view (<code>name</code>) if desired. If (<code>name</code>) is not
specified, a temporary view with name &quot;.rpostgis_TEMPview&quot; is used only
within the function execution. In this mode, the other arguments can be used
normally to modify the Spatial* object returned from the query.
</p>


<h3>Value</h3>

<p>sf, SpatVector or sp object
</p>


<h3>Author(s)</h3>

<p>David Bucklin <a href="mailto:david.bucklin@gmail.com">david.bucklin@gmail.com</a>
</p>
<p>Mathieu Basille <a href="mailto:mathieu@basille.org">mathieu@basille.org</a>
</p>
<p>Adrián Cidre González <a href="mailto:adrian.cidre@gmail.com">adrian.cidre@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Retrieve a sf with all data from table
## 'schema.tablename', with geometry in the column 'geom'
pgGetGeom(conn, c("schema", "tablename"))
## Return a sf with columns c1 &amp; c2 as data
pgGetGeom(conn, c("schema", "tablename"), other.cols = c("c1","c2"))
## Return a spatial-only (no data frame),
## retaining id from table as rownames
pgGetGeom(conn, c("schema", "tablename"), gid = "table_id",
  other.cols = FALSE)
## Return a spatial-only (no data frame),
## retaining id from table as rownames and with a subset of the data
pgGetGeom(conn, c("schema", "roads"), geom = "roadgeom", gid = "road_ID",
    other.cols = FALSE, clauses  = "WHERE road_type = 'highway'")
## Query mode
pgGetGeom(conn, query = "SELECT r.gid as id, ST_Buffer(r.geom, 100) as geom
                           FROM
                             schema.roads r,
                             schema.adm_boundaries b
                           WHERE
                             ST_Intersects(r.geom, b.geom);")

## End(Not run)
</code></pre>

<hr>
<h2 id='pgGetGeomQ'>Load geometries from a full query and return a Spatial* object</h2><span id='topic+pgGetGeomQ'></span>

<h3>Description</h3>

<p>Load geometries from a full query and return a Spatial* object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgGetGeomQ(conn, query, name = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgGetGeomQ_+3A_query">query</code></td>
<td>
<p>character, a full SQL query including a geometry column.</p>
</td></tr>
<tr><td><code id="pgGetGeomQ_+3A_name">name</code></td>
<td>
<p>optional character string specifying
a PostgreSQL schema and view name (e.g., <code>name = c("schema","view")</code>)
to save the query as. If NULL, a temporary view &quot;.rpostgis_TEMPview&quot; is used
temporarily (only within the function scope).</p>
</td></tr>
<tr><td><code id="pgGetGeomQ_+3A_...">...</code></td>
<td>
<p>For <code>pgGetGeomQ</code>, other arguments as in <code>pgGetGeom</code></p>
</td></tr>
</table>

<hr>
<h2 id='pgGetRast'>Load raster from PostGIS database into R.</h2><span id='topic+pgGetRast'></span>

<h3>Description</h3>

<p>Retrieve rasters from a PostGIS table into a <code>terra SpatRaster</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgGetRast(
  conn,
  name,
  rast = "rast",
  bands = 1,
  boundary = NULL,
  clauses = NULL,
  returnclass = "terra",
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgGetRast_+3A_conn">conn</code></td>
<td>
<p>A connection object to a PostgreSQL database</p>
</td></tr>
<tr><td><code id="pgGetRast_+3A_name">name</code></td>
<td>
<p>A character string specifying a PostgreSQL schema and
table/view name holding the geometry (e.g., <code>name =
c("schema","table")</code>)</p>
</td></tr>
<tr><td><code id="pgGetRast_+3A_rast">rast</code></td>
<td>
<p>Name of the column in <code>name</code> holding the raster object. 
Defaults to &quot;rast&quot;.</p>
</td></tr>
<tr><td><code id="pgGetRast_+3A_bands">bands</code></td>
<td>
<p>Index number(s) for the band(s) to retrieve (defaults to 1).
The special case (<code>bands = TRUE</code>) returns all bands in the raster. See
also 'Details'</p>
</td></tr>
<tr><td><code id="pgGetRast_+3A_boundary">boundary</code></td>
<td>
<p><code>sf</code> object, <code>SpatVector</code> object, or numeric. If a
spatial object is provided, its bounding box will be used to select
the part of the raster to import. Alternatively, a numeric vector
(<code>c([top], [bottom], [right], [left])</code>) indicating the 
projection-specific limits with which to clip the raster. If not value 
is provided, the default <code>boundary = NULL</code> will return the 
full raster.</p>
</td></tr>
<tr><td><code id="pgGetRast_+3A_clauses">clauses</code></td>
<td>
<p>character, optional SQL to append to modify select
query from table. Must begin with 'WHERE'.</p>
</td></tr>
<tr><td><code id="pgGetRast_+3A_returnclass">returnclass</code></td>
<td>
<p>'terra' by default; or 'raster' for <code>raster</code> objects.</p>
</td></tr>
<tr><td><code id="pgGetRast_+3A_progress">progress</code></td>
<td>
<p>whether to show a progress bar (TRUE by default). The progress
bar mark the progress of reading bands from the database.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since version 1.5.0, this function retrieve SpatRaster objects from 
<code>terra</code> package by default. The argument <code>returnclass</code> can be 
used to return <code>raster</code> objects instead.
</p>
<p>The argument <code>bands</code> can take as argument:
</p>
<p>* The index of the desirable band (e.g. bands = 2 will fetch the second band
of the raster).
</p>
<p>* More than one index for several bands (e.g. bands = c(2,4) will return a
<code>SpatRaster</code> with two bands).
</p>
<p>* All bands in the raster (bands = TRUE).
</p>


<h3>Value</h3>

<p><code>SpatRaster</code>; <code>raster</code>; or <code>RasterStack</code> object
</p>


<h3>Author(s)</h3>

<p>David Bucklin <a href="mailto:david.bucklin@gmail.com">david.bucklin@gmail.com</a> and Adrián Cidre
González <a href="mailto:adrian.cidre@gmail.com">adrian.cidre@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pgGetRast(conn, c("schema", "tablename"))
pgGetRast(conn, c("schema", "DEM"), boundary = c(55,
    50, 17, 12))

## End(Not run)
</code></pre>

<hr>
<h2 id='pgGetSRID'>Get SRID(s) from a geometry/geography column in a full table</h2><span id='topic+pgGetSRID'></span>

<h3>Description</h3>

<p>Get SRID(s) from a geometry/geography column in a full table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgGetSRID(conn, name, geom)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgGetSRID_+3A_conn">conn</code></td>
<td>
<p>A PostgreSQL connection</p>
</td></tr>
<tr><td><code id="pgGetSRID_+3A_name">name</code></td>
<td>
<p>A schema/table name</p>
</td></tr>
<tr><td><code id="pgGetSRID_+3A_geom">geom</code></td>
<td>
<p>a geometry or geography column name</p>
</td></tr>
</table>

<hr>
<h2 id='pgInsert'>Inserts data into a PostgreSQL table.</h2><span id='topic+pgInsert'></span>

<h3>Description</h3>

<p>'r lifecycle::badge(&quot;deprecated&quot;)'
</p>
<p>This function has been deprecated in favour of [pgWriteGeom()] and will be
removed in a future release.
</p>
<p>This function takes a take an R <code>sp</code> object (<code>Spatial*</code> or
<code>Spatial*DataFrame</code>), or a regular <code>data.frame</code>, and performs the
database insert (and table creation, when the table does not exist)
on the database.
</p>
<p>If <code>new.id</code> is specified, a new sequential integer field is
added to the data frame for insert. For <code>Spatial*</code>-only
objects (no data frame), a new ID column is created by default with name
<code>"gid"</code>.
</p>
<p>This function will use <code><a href="sf.html#topic+st_as_text">st_as_text</a></code> for geography types, and
<code><a href="sf.html#topic+st_as_binary">st_as_binary</a></code> for geometry types.
</p>
<p>In the event of function or database error, the database uses
ROLLBACK to revert to the previous state. 
</p>
<p>If the user specifies <code>return.pgi = TRUE</code>, and data preparation is
successful, the function will return 
a <code>pgi</code> object (see next paragraph), regardless of whether the
insert was successful or not. This object can be useful for debugging, 
or re-used as the <code>data.obj</code> in <code>pgInsert</code>; 
(e.g., when data preparation is slow, and the exact same data 
needs to be inserted into tables in two separate
tables or databases). If <code>return.pgi = FALSE</code>
(default), the function will return <code>TRUE</code> for successful insert and
<code>FALSE</code> for failed inserts.
</p>
<p>Use this function with <code>df.mode = TRUE</code> to save data frames from
<code>Spatial*</code>-class objects to the database in &quot;data frame mode&quot;. Along with normal 
<code>dbwriteDataFrame</code> operation, the proj4string of the spatial 
data will also be saved, and re-attached to the data when using 
<code>pgGetGeom</code> to import the data. Note that other attributes
of <code>Spatial*</code> objects are <strong>not</strong> saved (e.g., <code>coords.nrs</code>,
which is used to specify the column index of x/y columns in <code>SpatialPoints*</code>).
</p>
<p>pgi objects are a list containing four character strings: (1)
in.table, the table name which will be created or inserted
into (2) db.new.table, the SQL statement to create the new
table, (3) db.cols.insert, a character string of the database column
names to insert into, and (4) insert.data, a character string
of the data to insert.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgInsert(
  conn,
  name,
  data.obj,
  geom = "geom",
  df.mode = FALSE,
  partial.match = FALSE,
  overwrite = FALSE,
  new.id = NULL,
  row.names = FALSE,
  upsert.using = NULL,
  alter.names = FALSE,
  encoding = NULL,
  return.pgi = FALSE,
  df.geom = NULL,
  geog = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgInsert_+3A_conn">conn</code></td>
<td>
<p>A connection object to a PostgreSQL database</p>
</td></tr>
<tr><td><code id="pgInsert_+3A_name">name</code></td>
<td>
<p>A character string specifying a PostgreSQL schema and
table name (e.g., <code>name = c("schema","table")</code>). 
If not already existing, the table will be
created. If the table already exists, the function will check
if all R data frame columns match database columns, and if so,
do the insert. If not, the insert will be aborted. The
argument <code>partial.match</code> allows for inserts with only
partial matches of data frame and database column names, and
<code>overwrite</code> allows for overwriting the existing database
table.</p>
</td></tr>
<tr><td><code id="pgInsert_+3A_data.obj">data.obj</code></td>
<td>
<p>A <code>Spatial*</code> or <code>Spatial*DataFrame</code>, or <code>data.frame</code></p>
</td></tr>
<tr><td><code id="pgInsert_+3A_geom">geom</code></td>
<td>
<p>character string. For <code>Spatial*</code> datasets, the name of
geometry/(geography) column in the database table.  (existing or to be
created; defaults to <code>"geom"</code>). The special name &quot;geog&quot; will
automatically set <code>geog</code> to TRUE.</p>
</td></tr>
<tr><td><code id="pgInsert_+3A_df.mode">df.mode</code></td>
<td>
<p>Logical; Whether to write the (Spatial) data frame in data frame mode 
(preserving data frame column attributes and row.names).
A new table must be created with this mode (or overwrite set to TRUE),
and the <code>row.names</code>, <code>alter.names</code>, and <code>new.id</code> arguments will
be ignored (see <code><a href="#topic+dbWriteDataFrame">dbWriteDataFrame</a></code> for more information).</p>
</td></tr>
<tr><td><code id="pgInsert_+3A_partial.match">partial.match</code></td>
<td>
<p>Logical; allow insert on partial column
matches between data frame and database table. If <code>TRUE</code>,
columns in R data frame will be compared with the existing
database table <code>name</code>.  Columns in the data frame that
exactly match the database table will be inserted into the
database table.</p>
</td></tr>
<tr><td><code id="pgInsert_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical; if true, a new table (<code>name</code>) will
overwrite the existing table (<code>name</code>) in the database. Note:
overwriting a view must be done manually (e.g., with <code><a href="#topic+dbDrop">dbDrop</a></code>).</p>
</td></tr>
<tr><td><code id="pgInsert_+3A_new.id">new.id</code></td>
<td>
<p>Character, name of a new sequential integer ID
column to be added to the table for insert (for spatial objects without
data frames, this column is created even if left <code>NULL</code>
and defaults to the name <code>"gid"</code>). If <code>partial.match
= TRUE</code> and the column does not exist in the database table,
it will be discarded.</p>
</td></tr>
<tr><td><code id="pgInsert_+3A_row.names">row.names</code></td>
<td>
<p>Whether to add the data frame row names to the 
database table. Column name will be '.R_rownames'.</p>
</td></tr>
<tr><td><code id="pgInsert_+3A_upsert.using">upsert.using</code></td>
<td>
<p>Character, name of the column(s) in the database table 
or constraint name used to identify already-existing rows in the table, which will
be updated rather than inserted. The column(s) must have a unique constraint
already created in the database table (e.g., a primary key). 
Requires PostgreSQL 9.5+.</p>
</td></tr>
<tr><td><code id="pgInsert_+3A_alter.names">alter.names</code></td>
<td>
<p>Logical, whether to make database column names
DB-compliant (remove special characters/capitalization). Default is
<code>FALSE</code>.  (This must be set to <code>FALSE</code> to match
with non-standard names in an existing database table.)</p>
</td></tr>
<tr><td><code id="pgInsert_+3A_encoding">encoding</code></td>
<td>
<p>Character vector of length 2, containing the
from/to encodings for the data (as in the function
<code><a href="base.html#topic+iconv">iconv</a></code>). For example, if the dataset contain certain
latin characters (e.g., accent marks), and the database is in
UTF-8, use <code>encoding = c("latin1", "UTF-8")</code>. Left
<code>NULL</code>, no conversion will be done.</p>
</td></tr>
<tr><td><code id="pgInsert_+3A_return.pgi">return.pgi</code></td>
<td>
<p>Whether to return a formatted list of insert parameters
(i.e., a <code>pgi</code> object; see function details.)</p>
</td></tr>
<tr><td><code id="pgInsert_+3A_df.geom">df.geom</code></td>
<td>
<p>Character vector, name of a character column in an R data.frame
storing PostGIS geometries, this argument can be used to insert a geometry
stored as character type in a data.frame (do not use with Spatial* data types).
If only the column name is used (e.g., <code>df.geom = "geom"</code>), 
the column type will be a generic (GEOMETRY); use a two-length character vector 
(e.g., <code>df.geom = c("geom", "(POINT,4326)")</code> to also specify a 
specific PostGIS geometry type and SRID for the column. Only recommended for
for new tables/overwrites, since this method will change the 
existing column type.</p>
</td></tr>
<tr><td><code id="pgInsert_+3A_geog">geog</code></td>
<td>
<p>Logical; Whether to write the spatial data as a PostGIS 
'GEOGRAPHY' type. By default, FALSE, unless <code>geom = "geog"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if the insertion was successful,
<code>FALSE</code> if failed, or a <code>pgi</code> object if specified.
</p>


<h3>Author(s)</h3>

<p>David Bucklin <a href="mailto:david.bucklin@gmail.com">david.bucklin@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sp)
data(meuse)
coords &lt;- SpatialPoints(meuse[, c("x", "y")])
spdf &lt;- SpatialPointsDataFrame(coords, meuse)

## Insert data in new database table
pgInsert(conn, name = c("public", "meuse_data"), data.obj = spdf)

## The same command will insert into already created table (if all R
## columns match)
pgInsert(conn, name = c("public", "meuse_data"), data.obj = spdf)

## If not all database columns match, need to use partial.match = TRUE,
## where non-matching columns are not inserted
colnames(spdf@data)[4] &lt;- "cu"
pgInsert(conn, name = c("public", "meuse_data"), data.obj = spdf,
    partial.match = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='pgInsertizeGeom'>Format R data objects for insert into a PostgreSQL table.</h2><span id='topic+pgInsertizeGeom'></span><span id='topic+pgInsertize'></span>

<h3>Description</h3>

<p>These are internal rpostgis functions that take an R <code>sp</code> or <code>sf</code> object (Spatial*,
Spatial*DataFrame or sf; for <code>pgInsertizeGeom</code>), or data frame (for
<code>pgInsertize</code>) and return a <code>pgi</code> list object, which can
be used in the function <code>pgInsert</code> to insert rows of the
object into the database table. (Note that these functions do not
do any modification of the database, it only prepares the data for
insert.) The function <code>pgInsert</code> is a wrapper around these
functions, so <code>pgInsertize*</code> should only be used in
situations where data preparation and insert need to be separated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgInsertizeGeom(
  data.obj,
  geom = "geometry",
  create.table = NULL,
  force.match = NULL,
  conn = NULL,
  new.id = NULL,
  row.names = FALSE,
  alter.names = FALSE,
  partial.match = FALSE,
  df.mode = FALSE,
  geog = FALSE
)

pgInsertize(
  data.obj,
  create.table = NULL,
  force.match = NULL,
  conn = NULL,
  new.id = NULL,
  row.names = FALSE,
  alter.names = FALSE,
  partial.match = FALSE,
  df.mode = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgInsertizeGeom_+3A_data.obj">data.obj</code></td>
<td>
<p>A Spatial* or Spatial*DataFrame, or data frame for
<code>pgInsertize</code>.</p>
</td></tr>
<tr><td><code id="pgInsertizeGeom_+3A_geom">geom</code></td>
<td>
<p>character string, the name of geometry column in the
database table. (existing or to be created; defaults to
'geom').</p>
</td></tr>
<tr><td><code id="pgInsertizeGeom_+3A_create.table">create.table</code></td>
<td>
<p>character, schema and table of the PostgreSQL
table to create (actual table creation will be done in later
in pgWriteGeom().) Column names will be converted to
PostgreSQL-compliant names. Default is <code>NULL</code> (no new
table created).</p>
</td></tr>
<tr><td><code id="pgInsertizeGeom_+3A_force.match">force.match</code></td>
<td>
<p>character, schema and table of the PostgreSQL
table to compare columns of data frame with.  If specified with
<code>partial.match = TRUE</code>
only columns in the data frame that exactly match the database
table will be kept, and reordered to match the database
table. If <code>NULL</code>, all columns will be kept in the same
order given in the data frame.</p>
</td></tr>
<tr><td><code id="pgInsertizeGeom_+3A_conn">conn</code></td>
<td>
<p>A database connection (if a table is given in for
&quot;force.match&quot; parameter)</p>
</td></tr>
<tr><td><code id="pgInsertizeGeom_+3A_new.id">new.id</code></td>
<td>
<p>character, name of a new sequential integer ID
column to be added to the table.  (for spatial objects without
data frames, this column is created even if left <code>NULL</code>
and defaults to the name <code>"gid"</code>).</p>
</td></tr>
<tr><td><code id="pgInsertizeGeom_+3A_row.names">row.names</code></td>
<td>
<p>Whether to add the data frame row names to the 
database table. Column name will be '.R_rownames'.</p>
</td></tr>
<tr><td><code id="pgInsertizeGeom_+3A_alter.names">alter.names</code></td>
<td>
<p>Logical, whether to make database column names
DB-compliant (remove special characters). Default is
<code>TRUE</code>.  (This should to be set to <code>FALSE</code> to match
to non-standard names in an existing database table using the
<code>force.match</code> setting.)</p>
</td></tr>
<tr><td><code id="pgInsertizeGeom_+3A_partial.match">partial.match</code></td>
<td>
<p>Logical; if force.match is set and  true, 
columns in R data frame will be compared with an the 
existing database table <code>name</code>. Only columns in the 
data frame that exactly match the database
table will be inserted into the database table.</p>
</td></tr>
<tr><td><code id="pgInsertizeGeom_+3A_df.mode">df.mode</code></td>
<td>
<p>Logical; Whether to write data in data frame mode 
(preserving data frame column attributes and row.names).
A new table must be created with this mode (or overwrite set to TRUE),
and the row.names, alter.names, and new.id arguments will
be ignored (see <code>dbWriteDataFrame</code> for more information.</p>
</td></tr>
<tr><td><code id="pgInsertizeGeom_+3A_geog">geog</code></td>
<td>
<p>Logical; Whether to write the spatial data as a PostGIS 
'GEOGRAPHY' type.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The entire data frame is prepared by default, unless
<code>force.match</code> specifies a database table (along with a
database connection <code>conn</code>), in which case the R column names
are compared to the <code>force.match</code> column names, and only
exact matches are formatted to be inserted.
</p>
<p>A new database table can also be prepared to be created using the
<code>create.table</code> argument.  If <code>new.id</code> is specified, a
new sequential integer field is added to the data frame.  For
<code>Spatial*</code>-only objects (no data frame), a new.id is created
by default with name <code>gid</code>.  For <code>pgInsertizeGeom</code>, if
the R package <code>wkb</code> is installed, this function uses
<code>writeWKB</code> to translate the geometries for some spatial types
(faster with large datasets), otherwise the <code>rgeos</code> function
<code>writeWKT</code> is used.
</p>


<h3>Value</h3>

<p>pgi A list containing four character strings: (1)
in.table, the table name which will be created or inserted
into, if specified by either create.table or force.match (else
NULL) (2) db.new.table, the SQL statement to create the new
table, if specified in create.table (else NULL), (3)
db.cols.insert, a character string of the database column
names to insert into, and (4) insert.data, a character string
of the data to insert. See examples for usage within the
<code>pgInsert</code> function.
</p>


<h3>Author(s)</h3>

<p>David Bucklin <a href="mailto:david.bucklin@gmail.com">david.bucklin@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sp)
data(meuse)
coords &lt;- SpatialPoints(meuse[, c("x", "y")])
spdf &lt;- SpatialPointsDataFrame(coords, meuse)

## Format data for insert
pgi.new &lt;- pgInsertizeGeom(spdf, geom = "point_geom", create.table = c("schema",
    "table"), new.id = "pt_gid")
print(pgi.new)

## Insert data in database table (note that an error will be given if
## all insert columns do not have exactly matching database table
## columns)
pgWriteGeom(conn = conn, data.obj = pgi.new)

## Inserting into existing table
pgi.existing &lt;- pgInsertizeGeom(spdf, geom = "point_geom", force.match = c("schema",
    "table"), conn = conn)
## A warning message is given, since the "dist.m" column is not found
## in the database table (it was changed to "dist_m" in pgi.new to
## make name DB-compliant). All other columns are prepared for insert.
print(pgi.existing)

pgWriteGeom(conn = conn, data.obj = pgi.existing)

## End(Not run)
## Not run: 
## Format regular (non-spatial) data frame for insert using
## pgInsertize connect to database
data &lt;- data.frame(a = c(1, 2, 3), b = c(4, NA, 6), c = c(7,
    "text", 9))

## Format non-spatial data frame for insert
values &lt;- pgInsertize(data.obj = data)

## Insert data in database table (note that an error will be given if
## all insert columns do not match exactly to database table columns)
pgWriteGeom(conn, data.obj = values, name = c("schema", "table"))

## Run with forced matching of database table column names
values &lt;- pgInsertize(data.obj = data, force.match = c("schema",
    "table"), conn = conn)

pgWriteGeom(conn, data.obj = values)

## End(Not run)
</code></pre>

<hr>
<h2 id='pgListGeom'>List geometries/rasters</h2><span id='topic+pgListGeom'></span><span id='topic+pgListRast'></span>

<h3>Description</h3>

<p>List all geometry/(geography) or raster columns available in a PostGIS database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgListGeom(conn, geog = TRUE)

pgListRast(conn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgListGeom_+3A_conn">conn</code></td>
<td>
<p>A PostgreSQL database connection.</p>
</td></tr>
<tr><td><code id="pgListGeom_+3A_geog">geog</code></td>
<td>
<p>Logical. For pgListGeom, whether to include PostGIS geography-type 
columns stored in the database</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>exec = TRUE</code>, a data frame with schema, table,
geometry/(geography) or raster (for pgListRast) column, and geometry/(geography) type.
</p>


<h3>Author(s)</h3>

<p>David Bucklin <a href="mailto:david.bucklin@gmail.com">david.bucklin@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pgListGeom(conn)

pgListRast(conn)

## End(Not run)
</code></pre>

<hr>
<h2 id='pgMakePts'>Add a POINT or LINESTRING geometry field.</h2><span id='topic+pgMakePts'></span><span id='topic+pgMakeStp'></span>

<h3>Description</h3>

<p>Add a new POINT or LINESTRING geometry field.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgMakePts(
  conn,
  name,
  colname = "geom",
  x = "x",
  y = "y",
  srid,
  index = TRUE,
  display = TRUE,
  exec = TRUE
)

pgMakeStp(
  conn,
  name,
  colname = "geom",
  x = "x",
  y = "y",
  dx = "dx",
  dy = "dy",
  srid,
  index = TRUE,
  display = TRUE,
  exec = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgMakePts_+3A_conn">conn</code></td>
<td>
<p>A connection object.</p>
</td></tr>
<tr><td><code id="pgMakePts_+3A_name">name</code></td>
<td>
<p>A character string specifying a PostgreSQL schema and
table name (e.g., <code>name = c("schema","table")</code>)</p>
</td></tr>
<tr><td><code id="pgMakePts_+3A_colname">colname</code></td>
<td>
<p>A character string specifying the name of the new
geometry column.</p>
</td></tr>
<tr><td><code id="pgMakePts_+3A_x">x</code></td>
<td>
<p>The name of the x/longitude field.</p>
</td></tr>
<tr><td><code id="pgMakePts_+3A_y">y</code></td>
<td>
<p>The name of the y/latitude field.</p>
</td></tr>
<tr><td><code id="pgMakePts_+3A_srid">srid</code></td>
<td>
<p>A valid SRID for the new geometry.</p>
</td></tr>
<tr><td><code id="pgMakePts_+3A_index">index</code></td>
<td>
<p>Logical. Whether to create an index on the new
geometry.</p>
</td></tr>
<tr><td><code id="pgMakePts_+3A_display">display</code></td>
<td>
<p>Logical. Whether to display the query (defaults to
<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="pgMakePts_+3A_exec">exec</code></td>
<td>
<p>Logical. Whether to execute the query (defaults to
<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="pgMakePts_+3A_dx">dx</code></td>
<td>
<p>The name of the dx field (i.e. increment in x
direction).</p>
</td></tr>
<tr><td><code id="pgMakePts_+3A_dy">dy</code></td>
<td>
<p>The name of the dy field (i.e. increment in y
direction).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>exec = TRUE</code>, returns <code>TRUE</code> if the geometry
field was successfully created.
</p>


<h3>Author(s)</h3>

<p>Mathieu Basille <a href="mailto:mathieu@basille.org">mathieu@basille.org</a>
</p>


<h3>See Also</h3>

<p>The PostGIS documentation for <code>ST_MakePoint</code>:
<a href="http://postgis.net/docs/ST_MakePoint.html">http://postgis.net/docs/ST_MakePoint.html</a>, and for
<code>ST_MakeLine</code>:
<a href="http://postgis.net/docs/ST_MakeLine.html">http://postgis.net/docs/ST_MakeLine.html</a>, which are the
main functions of the call.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Examples use a dummy connection from DBI package
conn &lt;- DBI::ANSI()

## Create a new POINT field called 'pts_geom'
pgMakePts(conn, name = c("schema", "table"), colname = "pts_geom",
    x = "longitude", y = "latitude", srid = 4326, exec = FALSE)

## Create a new LINESTRING field called 'stp_geom'
pgMakeStp(conn, name = c("schema", "table"), colname = "stp_geom",
    x = "longitude", y = "latitude", dx = "xdiff", dy = "ydiff",
    srid = 4326, exec = FALSE)
</code></pre>

<hr>
<h2 id='pgPostGIS'>Check and create PostGIS extension.</h2><span id='topic+pgPostGIS'></span>

<h3>Description</h3>

<p>The function checks for the availability of the PostGIS extension,
and if it is available, but not installed, install
it. Additionally, can also install Topology, Tiger Geocoder,
SFCGAL and Raster extensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgPostGIS(
  conn,
  topology = FALSE,
  tiger = FALSE,
  sfcgal = FALSE,
  raster = FALSE,
  display = TRUE,
  exec = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgPostGIS_+3A_conn">conn</code></td>
<td>
<p>A connection object (required, even if <code>exec =
FALSE</code>).</p>
</td></tr>
<tr><td><code id="pgPostGIS_+3A_topology">topology</code></td>
<td>
<p>Logical. Whether to check/install the Topology
extension.</p>
</td></tr>
<tr><td><code id="pgPostGIS_+3A_tiger">tiger</code></td>
<td>
<p>Logical. Whether to check/install the Tiger Geocoder
extension. Will also install extensions &quot;fuzzystrmatch&quot;,
&quot;address_standardizer&quot;, and &quot;address_standardizer_data_us&quot; if
all are available.</p>
</td></tr>
<tr><td><code id="pgPostGIS_+3A_sfcgal">sfcgal</code></td>
<td>
<p>Logical. Whether to check/install the SFCGAL
extension.</p>
</td></tr>
<tr><td><code id="pgPostGIS_+3A_raster">raster</code></td>
<td>
<p>Logical. Whether to check/install the Raster extension</p>
</td></tr>
<tr><td><code id="pgPostGIS_+3A_display">display</code></td>
<td>
<p>Logical. Whether to display the query (defaults to
<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="pgPostGIS_+3A_exec">exec</code></td>
<td>
<p>Logical. Whether to execute the query (defaults to
<code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>exec = TRUE</code>, returns <code>TRUE</code> if PostGIS is installed.
</p>


<h3>Author(s)</h3>

<p>Mathieu Basille <a href="mailto:mathieu@basille.org">mathieu@basille.org</a> and
Adrián Cidre González <a href="mailto:adrian.cidre@gmail.com">adrian.cidre@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 'exec = FALSE' does not install any extension, but nevertheless
## check for available and installed extensions:
## Not run: 
    pgPostGIS(con, topology = TRUE, tiger = TRUE, sfcgal = TRUE,
        exec = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='pgSRID'>Find (or create) PostGIS SRID based on CRS object.</h2><span id='topic+pgSRID'></span>

<h3>Description</h3>

<p>This function takes <code><a href="sf.html#topic+st_crs">st_crs</a></code>-class object and a
PostgreSQL database connection (with PostGIS extension), and
returns the matching SRID(s) for that CRS. If a match is not
found, a new entry can be created in the PostgreSQL
<code>spatial_ref_sys</code> table using the parameters specified by the
CRS. New entries will be created with <code>auth_name =
'rpostgis_custom'</code>, with the default value being the next open value
between 880001-889999 (a different SRID value can be entered if desired.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgSRID(conn, crs, create.srid = FALSE, new.srid = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgSRID_+3A_conn">conn</code></td>
<td>
<p>A connection object to a PostgreSQL database.</p>
</td></tr>
<tr><td><code id="pgSRID_+3A_crs">crs</code></td>
<td>
<p>crs object, created through a call to
<code><a href="sf.html#topic+st_crs">st_crs</a></code>.</p>
</td></tr>
<tr><td><code id="pgSRID_+3A_create.srid">create.srid</code></td>
<td>
<p>Logical. If no matching SRID is found, should a new
SRID be created? User must have write access on
<code>spatial_ref_sys</code> table.</p>
</td></tr>
<tr><td><code id="pgSRID_+3A_new.srid">new.srid</code></td>
<td>
<p>Integer. Optional SRID to give to a newly created
SRID. If left NULL (default), the next open value of
<code>srid</code> in <code>spatial_ref_sys</code> between 880001 and
889999 will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SRID code (integer).
</p>


<h3>Author(s)</h3>

<p>David Bucklin <a href="mailto:david.bucklin@gmail.com">david.bucklin@gmail.com</a> and Adrián Cidre 
González <a href="mailto:adrian.cidre@gmail.com">adrian.cidre@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
drv &lt;- dbDriver("PostgreSQL")
conn &lt;- dbConnect(drv, dbname = "dbname", host = "host", port = "5432",
    user = "user", password = "password")
(crs &lt;- sf::st_crs("+proj=longlat"))
pgSRID(conn, crs)
(crs2 &lt;- sf::st_crs(paste("+proj=stere", "+lat_0=52.15616055555555 +lon_0=5.38763888888889",
    "+k=0.999908 +x_0=155000 +y_0=463000", "+ellps=bessel",
    "+towgs84=565.237,50.0087,465.658,-0.406857,0.350733,-1.87035,4.0812",
    "+units=m")))
pgSRID(conn, crs2, create.srid = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='pgWriteGeom'>Inserts data into a PostgreSQL table.</h2><span id='topic+pgWriteGeom'></span><span id='topic+print.pgi'></span>

<h3>Description</h3>

<p>This function takes a take an R <code>sf</code>, a <code>SpatVector</code> or <code>sp</code> object (<code>Spatial*</code> or
<code>Spatial*DataFrame</code>); or a regular <code>data.frame</code>, and performs the
database insert (and table creation, when the table does not exist)
on the database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgWriteGeom(
  conn,
  name,
  data.obj,
  geom = "geom",
  df.mode = FALSE,
  partial.match = FALSE,
  overwrite = FALSE,
  new.id = NULL,
  row.names = FALSE,
  upsert.using = NULL,
  alter.names = FALSE,
  encoding = NULL,
  return.pgi = FALSE,
  df.geom = NULL,
  geog = FALSE
)

## S3 method for class 'pgi'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgWriteGeom_+3A_conn">conn</code></td>
<td>
<p>A connection object to a PostgreSQL database</p>
</td></tr>
<tr><td><code id="pgWriteGeom_+3A_name">name</code></td>
<td>
<p>A character string specifying a PostgreSQL schema and
table name (e.g., <code>name = c("schema","table")</code>). 
If not already existing, the table will be
created. If the table already exists, the function will check
if all R data frame columns match database columns, and if so,
do the insert. If not, the insert will be aborted. The
argument <code>partial.match</code> allows for inserts with only
partial matches of data frame and database column names, and
<code>overwrite</code> allows for overwriting the existing database
table.</p>
</td></tr>
<tr><td><code id="pgWriteGeom_+3A_data.obj">data.obj</code></td>
<td>
<p>A <code>sf</code>,<code>SpatVector</code>, <code>sp</code>-class, or <code>data.frame</code></p>
</td></tr>
<tr><td><code id="pgWriteGeom_+3A_geom">geom</code></td>
<td>
<p>character string. For <code>Spatial*</code> datasets, the name of
geometry/(geography) column in the database table.  (existing or to be
created; defaults to <code>"geom"</code>). The special name &quot;geog&quot; will
automatically set <code>geog</code> to TRUE.</p>
</td></tr>
<tr><td><code id="pgWriteGeom_+3A_df.mode">df.mode</code></td>
<td>
<p>Logical; Whether to write the (Spatial) data frame in data frame mode 
(preserving data frame column attributes and row.names).
A new table must be created with this mode (or overwrite set to TRUE),
and the <code>row.names</code>, <code>alter.names</code>, and <code>new.id</code> arguments will
be ignored (see <code><a href="#topic+dbWriteDataFrame">dbWriteDataFrame</a></code> for more information).</p>
</td></tr>
<tr><td><code id="pgWriteGeom_+3A_partial.match">partial.match</code></td>
<td>
<p>Logical; allow insert on partial column
matches between data frame and database table. If <code>TRUE</code>,
columns in R data frame will be compared with the existing
database table <code>name</code>.  Columns in the data frame that
exactly match the database table will be inserted into the
database table.</p>
</td></tr>
<tr><td><code id="pgWriteGeom_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical; if true, a new table (<code>name</code>) will
overwrite the existing table (<code>name</code>) in the database. Note:
overwriting a view must be done manually (e.g., with <code><a href="#topic+dbDrop">dbDrop</a></code>).</p>
</td></tr>
<tr><td><code id="pgWriteGeom_+3A_new.id">new.id</code></td>
<td>
<p>Character, name of a new sequential integer ID
column to be added to the table for insert (for spatial objects without
data frames, this column is created even if left <code>NULL</code>
and defaults to the name <code>"gid"</code>). If <code>partial.match
= TRUE</code> and the column does not exist in the database table,
it will be discarded.</p>
</td></tr>
<tr><td><code id="pgWriteGeom_+3A_row.names">row.names</code></td>
<td>
<p>Whether to add the data frame row names to the 
database table. Column name will be '.R_rownames'.</p>
</td></tr>
<tr><td><code id="pgWriteGeom_+3A_upsert.using">upsert.using</code></td>
<td>
<p>Character, name of the column(s) in the database table 
or constraint name used to identify already-existing rows in the table, which will
be updated rather than inserted. The column(s) must have a unique constraint
already created in the database table (e.g., a primary key). 
Requires PostgreSQL 9.5+.</p>
</td></tr>
<tr><td><code id="pgWriteGeom_+3A_alter.names">alter.names</code></td>
<td>
<p>Logical, whether to make database column names
DB-compliant (remove special characters/capitalization). Default is
<code>FALSE</code>.  (This must be set to <code>FALSE</code> to match
with non-standard names in an existing database table.)</p>
</td></tr>
<tr><td><code id="pgWriteGeom_+3A_encoding">encoding</code></td>
<td>
<p>Character vector of length 2, containing the
from/to encodings for the data (as in the function
<code><a href="base.html#topic+iconv">iconv</a></code>). For example, if the dataset contain certain
latin characters (e.g., accent marks), and the database is in
UTF-8, use <code>encoding = c("latin1", "UTF-8")</code>. Left
<code>NULL</code>, no conversion will be done.</p>
</td></tr>
<tr><td><code id="pgWriteGeom_+3A_return.pgi">return.pgi</code></td>
<td>
<p>Whether to return a formatted list of insert parameters
(i.e., a <code>pgi</code> object; see function details.)</p>
</td></tr>
<tr><td><code id="pgWriteGeom_+3A_df.geom">df.geom</code></td>
<td>
<p>Character vector, name of a character column in an R data.frame
storing PostGIS geometries, this argument can be used to insert a geometry
stored as character type in a data.frame (do not use with Spatial* data types).
If only the column name is used (e.g., <code>df.geom = "geom"</code>), 
the column type will be a generic (GEOMETRY); use a two-length character vector 
(e.g., <code>df.geom = c("geom", "(POINT,4326)")</code> to also specify a 
specific PostGIS geometry type and SRID for the column. Only recommended for
for new tables/overwrites, since this method will change the 
existing column type.</p>
</td></tr>
<tr><td><code id="pgWriteGeom_+3A_geog">geog</code></td>
<td>
<p>Logical; Whether to write the spatial data as a PostGIS 
'GEOGRAPHY' type. By default, FALSE, unless <code>geom = "geog"</code>.</p>
</td></tr>
<tr><td><code id="pgWriteGeom_+3A_x">x</code></td>
<td>
<p>A list of class <code>pgi</code></p>
</td></tr>
<tr><td><code id="pgWriteGeom_+3A_...">...</code></td>
<td>
<p>Further arguments not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>new.id</code> is specified, a new sequential integer field is
added to the data frame for insert. For <code>spatial</code>-only
objects (no data frame), a new ID column is created by default with name
<code>"gid"</code>.
</p>
<p>This function will use <code><a href="sf.html#topic+st_as_text">st_as_text</a></code> for geography types, and
<code><a href="sf.html#topic+st_as_binary">st_as_binary</a></code> for geometry types.
</p>
<p>In the event of function or database error, the database uses
ROLLBACK to revert to the previous state. 
</p>
<p>If the user specifies <code>return.pgi = TRUE</code>, and data preparation is
successful, the function will return 
a <code>pgi</code> object (see next paragraph), regardless of whether the
insert was successful or not. This object can be useful for debugging, 
or re-used as the <code>data.obj</code> in <code>pgWriteGeom</code>; 
(e.g., when data preparation is slow, and the exact same data 
needs to be inserted into tables in two separate
tables or databases). If <code>return.pgi = FALSE</code>
(default), the function will return <code>TRUE</code> for successful insert and
<code>FALSE</code> for failed inserts.
</p>
<p>Use this function with <code>df.mode = TRUE</code> to save data frames from
<code>spatial</code>-class objects to the database in &quot;data frame mode&quot;. Along with normal 
<code>dbwriteDataFrame</code> operation, the proj4string of the spatial 
data will also be saved, and re-attached to the data when using 
<code>pgGetGeom</code> to import the data. Note that other attributes
of <code>spatial</code> objects are <strong>not</strong> saved (e.g., <code>coords.nrs</code>,
which is used to specify the column index of x/y columns in <code>*POINT</code> and
<code>SpatialPoints*</code>).
</p>
<p>pgi objects are a list containing four character strings: (1)
in.table, the table name which will be created or inserted
into (2) db.new.table, the SQL statement to create the new
table, (3) db.cols.insert, a character string of the database column
names to insert into, and (4) insert.data, a character string
of the data to insert.
</p>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if the insertion was successful,
<code>FALSE</code> if failed, or a <code>pgi</code> object if specified.
</p>


<h3>Author(s)</h3>

<p>David Bucklin <a href="mailto:david.bucklin@gmail.com">david.bucklin@gmail.com</a> and Adrián Cidre
González <a href="mailto:adrian.cidre@gmail.com">adrian.cidre@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
pts &lt;- st_sf(a = 1:2, geom = st_sfc(st_point(0:1), st_point(1:2)), crs = 4326)

## Insert data in new database table
pgWriteGeom(conn, name = c("public", "my_pts"), data.obj = pts)

## The same command will insert into already created table (if all R
## columns match)
pgWriteGeom(conn, name = c("public", "my_pts"), data.obj = pts)

## If not all database columns match, need to use partial.match = TRUE,
## where non-matching columns are not inserted
names(pts)[1] &lt;- "b"
pgWriteGeom(conn, name = c("public", "my_pts"), data.obj = pts,
    partial.match = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='pgWriteRast'>Write raster to PostGIS database table.</h2><span id='topic+pgWriteRast'></span>

<h3>Description</h3>

<p>Sends R raster to a PostGIS database table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgWriteRast(
  conn,
  name,
  raster,
  bit.depth = NULL,
  blocks = NULL,
  constraints = TRUE,
  overwrite = FALSE,
  append = FALSE,
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgWriteRast_+3A_conn">conn</code></td>
<td>
<p>A connection object to a PostgreSQL database.</p>
</td></tr>
<tr><td><code id="pgWriteRast_+3A_name">name</code></td>
<td>
<p>A character string specifying a PostgreSQL schema in the
database (if necessary) and table name to hold the raster (e.g., 
<code>name = c("schema","table")</code>).</p>
</td></tr>
<tr><td><code id="pgWriteRast_+3A_raster">raster</code></td>
<td>
<p>An terra <code>SpatRaster</code>; objects from the raster
package (<code>RasterLayer</code>, <code>RasterBrick</code>, or <code>RasterStack</code>); 
a <code>SpatialGrid*</code> or <code>SpatialPixels*</code> from sp package.</p>
</td></tr>
<tr><td><code id="pgWriteRast_+3A_bit.depth">bit.depth</code></td>
<td>
<p>The bit depth of the raster. Will be set to 32-bit
(unsigned int, signed int, or float, depending on the data)
if left null, but can be specified (as character) as one of the
PostGIS pixel types (see <a href="http://postgis.net/docs/RT_ST_BandPixelType.html">http://postgis.net/docs/RT_ST_BandPixelType.html</a>).</p>
</td></tr>
<tr><td><code id="pgWriteRast_+3A_blocks">blocks</code></td>
<td>
<p>Optional desired number of blocks (tiles) to split the raster
into in the resulting PostGIS table. This should be specified as a
one or two-length (columns, rows) integer vector. See also 'Details'.</p>
</td></tr>
<tr><td><code id="pgWriteRast_+3A_constraints">constraints</code></td>
<td>
<p>Whether to create constraints from raster data. Recommended
to leave <code>TRUE</code> unless applying constraints manually (see
<a href="http://postgis.net/docs/RT_AddRasterConstraints.html">http://postgis.net/docs/RT_AddRasterConstraints.html</a>).
Note that constraint notices may print to the console,
depending on the PostgreSQL server settings.</p>
</td></tr>
<tr><td><code id="pgWriteRast_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to overwrite the existing table (<code>name</code>).</p>
</td></tr>
<tr><td><code id="pgWriteRast_+3A_append">append</code></td>
<td>
<p>Whether to append to the existing table (<code>name</code>).</p>
</td></tr>
<tr><td><code id="pgWriteRast_+3A_progress">progress</code></td>
<td>
<p>whether to show a progress bar (TRUE by default). The progress
bar mark the progress of writing blocks into the database.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>SpatRaster band names will be stored in an array in the column
&quot;band_names&quot;, which will be restored in R when imported with the function
<code><a href="#topic+pgGetRast">pgGetRast</a></code>.
</p>
<p>Rasters from the <code>sp</code> and <code>raster</code> packages are converted to 
<code>terra</code> objects prior to insert.
</p>
<p>If <code>blocks = NULL</code>, the number of block will vary by raster size, with
a default value of 100 copies of the data in the memory at any point in time.
If a specified number of blocks is desired, set blocks to a one or two-length 
integer vector. Note that fewer, larger blocks generally results in faster
write times.
</p>


<h3>Value</h3>

<p>TRUE for successful import.
</p>


<h3>Author(s)</h3>

<p>David Bucklin <a href="mailto:david.bucklin@gmail.com">david.bucklin@gmail.com</a> and Adrián Cidre 
González <a href="mailto:adrian.cidre@gmail.com">adrian.cidre@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Function follows process from 
<a href="http://postgis.net/docs/using_raster_dataman.html#RT_Creating_Rasters">http://postgis.net/docs/using_raster_dataman.html#RT_Creating_Rasters</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pgWriteRast(conn, c("schema", "tablename"), raster_name)

# basic test
r &lt;- terra::rast(nrows=180, ncols=360, xmin=-180, xmax=180,
    ymin=-90, ymax=90, vals=1)
pgWriteRast(conn, c("schema", "test"), raster = r,
    bit.depth = "2BUI", overwrite = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='rpostgis'>R interface to a PostGIS database.</h2><span id='topic+rpostgis'></span>

<h3>Description</h3>

<p>'rpostgis' provides an interface between R and
'PostGIS'-enabled 'PostgreSQL' databases to transparently transfer
spatial data. Both vector (points, lines, polygons) and raster
data are supported in read and write modes. Also provides
convenience functions to execute common procedures in
'PostgreSQL/PostGIS'. For a list of documented functions, use
<code>library(help = "rpostgis")</code>.
</p>


<h3>Details</h3>

<p>A typical session starts by establishing the connection to a
working PostgreSQL database:
</p>
<p>library(rpostgis)
con &lt;- dbConnect(&quot;PostgreSQL&quot;, dbname = &lt;dbname&gt;, host = &lt;host&gt;,
user = &lt;user&gt;, password = &lt;password&gt;)
</p>
<p>For example, this could be:
</p>
<p>con &lt;- dbConnect(&quot;PostgreSQL&quot;, dbname = &quot;rpostgis&quot;, host = &quot;localhost&quot;,
user = &quot;postgres&quot;, password = &quot;postgres&quot;)
</p>
<p>The next step typically involves checking if PostGIS was installed
on the working database, and if not try to install it:
</p>
<p>pgPostGIS(con)
</p>
<p>The function should return <code>TRUE</code> for all <code>pg-</code>
functions to work.
</p>
<p>Finally, at the end of an interactive session, the connection to
the database should be closed:
</p>
<p>dbDisconnect(con)
</p>


<h3>Author(s)</h3>

<p>Mathieu Basille (<a href="mailto:mathieu@basille.org">mathieu@basille.org</a>) and David
Bucklin (<a href="mailto:david.bucklin@gmail.com">david.bucklin@gmail.com</a>)
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
