<!DOCTYPE html><html lang="en"><head><title>Help for package PepMapViz</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PepMapViz}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calculate_all_Area'><p>Calculate Area/Intensity for the whole input sequence dataframe</p></a></li>
<li><a href='#calculate_all_PSM'><p>Calculate Spectra Count (PSM) for the whole input sequence dataframe</p></a></li>
<li><a href='#calculate_Area'><p>Calculate Area/Intensity for one row of the input sequence dataframe</p></a></li>
<li><a href='#calculate_PSM'><p>Calculate Spectra Count (PSM) for one row of the input sequence dataframe</p></a></li>
<li><a href='#combine_files_from_folder'><p>Combine CSV and TXT Files from a Folder</p></a></li>
<li><a href='#convert_to_regex_pattern'><p>Convert Peptide Sequence to Regex Pattern</p></a></li>
<li><a href='#create_peptide_plot'><p>Create a peptide Plot</p></a></li>
<li><a href='#match_and_calculate_positions'><p>Match peptide sequence with provided sequence and calculate positions</p></a></li>
<li><a href='#obtain_mod'><p>Obtain post translational modification(PTM) information from Peptide data</p>
based on the specified data type</a></li>
<li><a href='#obtain_mod_Comet'><p>Obtain modification information from Peptide data generated by Comet</p></a></li>
<li><a href='#obtain_mod_DIANN'><p>Obtain modification information from Peptide data generated by DIA-NN</p></a></li>
<li><a href='#obtain_mod_Maxquant'><p>Obtain modification information from Peptide data generated by Maxquant</p></a></li>
<li><a href='#obtain_mod_MSFragger'><p>Obtain modification information from Peptide data generated by MSFragger</p></a></li>
<li><a href='#obtain_mod_PEAKS'><p>Obtain modification information from Peptide data generated by PEAKS</p></a></li>
<li><a href='#obtain_mod_Skyline'><p>Obtain modification information from Peptide data generated by Skyline</p></a></li>
<li><a href='#obtain_mod_Spectronaut'><p>Obtain modification information from Peptide data generated by Spectronaut</p></a></li>
<li><a href='#peptide_quantification'><p>Peptide Quantification</p></a></li>
<li><a href='#strip_sequence'><p>Strip peptide sequences based on the specified data type</p></a></li>
<li><a href='#strip_sequence_Comet'><p>Strip sequence from Comet outputs</p></a></li>
<li><a href='#strip_sequence_DIANN'><p>Strip sequence from DIANN outputs</p></a></li>
<li><a href='#strip_sequence_Maxquant'><p>Strip sequence from Maxquant outputs</p></a></li>
<li><a href='#strip_sequence_MSFragger'><p>Strip sequence from MSFragger outputs</p></a></li>
<li><a href='#strip_sequence_PEAKS'><p>Strip sequence from PEAKS outputs</p></a></li>
<li><a href='#strip_sequence_Skyline'><p>Strip sequence from Skyline outputs</p></a></li>
<li><a href='#strip_sequence_Spectronaut'><p>Strip sequence from Spectronaut outputs</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>A Versatile Toolkit for Peptide Mapping, Visualization, and
Comparative Exploration</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A versatile R visualization package that empowers 
    researchers with comprehensive visualization tools for seamlessly mapping peptides 
    to protein sequences, identifying distinct domains and regions of interest, 
    accentuating mutations, and highlighting post-translational modifications, 
    all while enabling comparisons across diverse experimental conditions. 
    Potential applications of 'PepMapViz' include the visualization of cross-software 
    mass spectrometry results at the peptide level for specific protein and domain 
    details in a linearized format and post-translational modification coverage 
    across different experimental conditions; unraveling insights into disease 
    mechanisms. It also enables visualization of major histocompatibility complex-presented peptides in 
    different antibody regions predicting immunogenicity in antibody drug development.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, stringr, ggforce, ggh4x, ggnewscale, data.table,
rlang</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>biocViews:</td>
<td>Immunogenicity, MassSpectrometry, Proteomics, Peptidomics,
Software, Visualization</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-11 21:36:29 UTC; zhouz45</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zhenru Zhou &lt;zhou.zhenru@gene.com&gt;</td>
</tr>
<tr>
<td>Note:</td>
<td>The following words are correctly spelled domain-specific terms:
MHC, 'PepMapViz', immunogenicity, linearized, spectrometry,
translational. The package includes large datasets in the
'extdata' directory, which are essential for demonstrating the
functionality and performance of the tools provided. These
datasets are necessary for reproducibility and comprehensive
testing.</td>
</tr>
<tr>
<td>Author:</td>
<td>Zhenru Zhou [aut, cre],
  Qui Phung [ctb],
  Corey Bakalarski [aut],
  Genentech, Inc. [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-13 14:00:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='calculate_all_Area'>Calculate Area/Intensity for the whole input sequence dataframe</h2><span id='topic+calculate_all_Area'></span>

<h3>Description</h3>

<p>Calculate Area/Intensity for the whole input sequence dataframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_all_Area(
  whole_seq,
  matching_result,
  matching_columns,
  distinct_columns,
  area_column,
  with_PTM = FALSE,
  reps = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_all_Area_+3A_whole_seq">whole_seq</code></td>
<td>
<p>A dataframe holding whole sequence information. 'Region_Sequence' column is required for the sequence information. Change the column name if it is different than 'Region_Sequence'.</p>
</td></tr>
<tr><td><code id="calculate_all_Area_+3A_matching_result">matching_result</code></td>
<td>
<p>The dataframe that contains the matched results and PTM information.</p>
</td></tr>
<tr><td><code id="calculate_all_Area_+3A_matching_columns">matching_columns</code></td>
<td>
<p>Vector of column names that should match between each row of 'whole_seq' and the 'matching_result' dataframe.</p>
</td></tr>
<tr><td><code id="calculate_all_Area_+3A_distinct_columns">distinct_columns</code></td>
<td>
<p>Vector of column names that should be used to calculate Area separately for each unique combination of these columns.</p>
</td></tr>
<tr><td><code id="calculate_all_Area_+3A_area_column">area_column</code></td>
<td>
<p>The name of the column in 'matching_result' that contains the area/intensity information.</p>
</td></tr>
<tr><td><code id="calculate_all_Area_+3A_with_ptm">with_PTM</code></td>
<td>
<p>A boolean parameter indicating whether PTM should be considered during calculation of Area. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="calculate_all_Area_+3A_reps">reps</code></td>
<td>
<p>A boolean parameter indicating whether the area/intensity should be divided by the number of replicates. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>data_with_area</code>, a dataframe contains calculated Area for each record in 'whole_seq'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>whole_seq &lt;- data.frame(
  Region_Sequence = c(
    "XYZAAA",
    "XYZCCC",
    "XYZBBB",
    "XYZDDD",
    "XYZAAB",
    "XYZCCD",
    "XYZBBB",
    "XYZDDD",
    "XYZAAA",
    "XYZCCC",
    "XYZBBB",
    "XYZDDD",
    "XYZAAB",
    "XYZCCD",
    "XYZBBB",
    "XYZDDD"
  ),
  Condition_1 = c(
    "Drug1",
    "Drug1",
    "Drug2",
    "Drug2",
    "Drug1",
    "Drug1",
    "Drug2",
    "Drug2",
    "Drug1",
    "Drug1",
    "Drug2",
    "Drug2",
    "Drug1",
    "Drug1",
    "Drug2",
    "Drug2"
  ),
  Condition_2 = c(
    "Donor1",
    "Donor1",
    "Donor1",
    "Donor1",
    "Donor1",
    "Donor1",
    "Donor1",
    "Donor1",
    "Donor2",
    "Donor2",
    "Donor2",
    "Donor2",
    "Donor2",
    "Donor2",
    "Donor2",
    "Donor2"
  ),
  Region_1 = c(
    "VH",
    "VL",
    "VH",
    "VL",
    "VH",
    "VL",
    "VH",
    "VL",
    "VH",
    "VL",
    "VH",
    "VL",
    "VH",
    "VL",
    "VH",
    "VL"
  ),
  Region_2 = c(
    "Arm_1",
    "Arm_1",
    "Arm_1",
    "Arm_1",
    "Arm_2",
    "Arm_2",
    "Arm_2",
    "Arm_2",
    "Arm_1",
    "Arm_1",
    "Arm_1",
    "Arm_1",
    "Arm_2",
    "Arm_2",
    "Arm_2",
    "Arm_2"
  )
)
matching_result &lt;- data.frame(
  Sequence = c("AAA", "DDD", "DDD"),
  Condition_1 = c("Drug1", "Drug2", "Drug2"),
  Condition_2 = c("Donor1", "Donor2", "Donor2"),
  Region_1 = c("VH", "VL", "VL"),
  Region_2 = c("Arm_1", "Arm_2", "Arm_2"),
  Start_Position = c(4, 4, 4),
  End_Position = c(6, 6, 6),
  PTM_position = c(NA, 2, 0),
  PTM_type = c(NA, "O", "C"),
  Area = c(100, 200, 200),
  reps = c(1, 2, 2)
)
matching_columns &lt;- c("Condition_1", "Region_2")
area_column &lt;- "Area"
data_with_area &lt;- calculate_all_Area(
  whole_seq,
  matching_result,
  matching_columns,
  distinct_columns = c("Condition_2", "Region_1"),
  area_column,
  with_PTM = TRUE,
  reps = TRUE
)

</code></pre>

<hr>
<h2 id='calculate_all_PSM'>Calculate Spectra Count (PSM) for the whole input sequence dataframe</h2><span id='topic+calculate_all_PSM'></span>

<h3>Description</h3>

<p>Calculate Spectra Count (PSM) for the whole input sequence dataframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_all_PSM(
  whole_seq,
  matching_result,
  matching_columns,
  distinct_columns,
  with_PTM = FALSE,
  reps = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_all_PSM_+3A_whole_seq">whole_seq</code></td>
<td>
<p>A dataframe holding whole sequence information. 'Region_Sequence' column is required for the sequence information. Change the column name if it is different than 'Region_Sequence'.</p>
</td></tr>
<tr><td><code id="calculate_all_PSM_+3A_matching_result">matching_result</code></td>
<td>
<p>The dataframe that contains the matched results and PTM information.</p>
</td></tr>
<tr><td><code id="calculate_all_PSM_+3A_matching_columns">matching_columns</code></td>
<td>
<p>Vector of column names that should match between each row of 'whole_seq' and the 'matching_result' dataframe.</p>
</td></tr>
<tr><td><code id="calculate_all_PSM_+3A_distinct_columns">distinct_columns</code></td>
<td>
<p>Vector of column names that should be used to calculate PSM separately for each unique combination of these columns.</p>
</td></tr>
<tr><td><code id="calculate_all_PSM_+3A_with_ptm">with_PTM</code></td>
<td>
<p>A boolean parameter indicating whether PTM should be considered during calculation of PSM. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="calculate_all_PSM_+3A_reps">reps</code></td>
<td>
<p>A boolean parameter indicating whether the area/intensity should be divided by the number of replicates. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>data_with_psm</code>, a dataframe contains calculated PSM for each record in 'whole_seq'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>whole_seq &lt;- data.frame(
  Region_Sequence = c(
    "XYZAAA",
    "XYZCCC",
    "XYZBBB",
    "XYZDDD",
    "XYZAAB",
    "XYZCCD",
    "XYZBBB",
    "XYZDDD",
    "XYZAAA",
    "XYZCCC",
    "XYZBBB",
    "XYZDDD",
    "XYZAAB",
    "XYZCCD",
    "XYZBBB",
    "XYZDDD"
  ),
  Condition_1 = c(
    "Drug1",
    "Drug1",
    "Drug2",
    "Drug2",
    "Drug1",
    "Drug1",
    "Drug2",
    "Drug2",
    "Drug1",
    "Drug1",
    "Drug2",
    "Drug2",
    "Drug1",
    "Drug1",
    "Drug2",
    "Drug2"
  ),
  Condition_2 = c(
    "Donor1",
    "Donor1",
    "Donor1",
    "Donor1",
    "Donor1",
    "Donor1",
    "Donor1",
    "Donor1",
    "Donor2",
    "Donor2",
    "Donor2",
    "Donor2",
    "Donor2",
    "Donor2",
    "Donor2",
    "Donor2"
  ),
  Region_1 = c(
    "VH",
    "VL",
    "VH",
    "VL",
    "VH",
    "VL",
    "VH",
    "VL",
    "VH",
    "VL",
    "VH",
    "VL",
    "VH",
    "VL",
    "VH",
    "VL"
  ),
  Region_2 = c(
    "Arm_1",
    "Arm_1",
    "Arm_1",
    "Arm_1",
    "Arm_2",
    "Arm_2",
    "Arm_2",
    "Arm_2",
    "Arm_1",
    "Arm_1",
    "Arm_1",
    "Arm_1",
    "Arm_2",
    "Arm_2",
    "Arm_2",
    "Arm_2"
  )
)
matching_result &lt;- data.frame(
  Sequence = c("AAA", "DDD", "DDD"),
  Condition_1 = c("Drug1", "Drug2", "Drug2"),
  Condition_2 = c("Donor1", "Donor2", "Donor2"),
  Region_1 = c("VH", "VL", "VL"),
  Region_2 = c("Arm_1", "Arm_2", "Arm_2"),
  Start_Position = c(4, 4, 4),
  End_Position = c(6, 6, 6),
  PTM_position = c(NA, 2, 0),
  PTM_type = c(NA, "O", "C"),
  Area = c(100, 200, 200),
  reps = c(1, 2, 2)
)
matching_columns &lt;- c("Condition_1", "Region_2")
data_with_psm &lt;- calculate_all_PSM(
  whole_seq,
  matching_result,
  matching_columns,
  distinct_columns = c("Condition_2", "Region_1"),
  with_PTM = TRUE,
  reps = TRUE
)
</code></pre>

<hr>
<h2 id='calculate_Area'>Calculate Area/Intensity for one row of the input sequence dataframe</h2><span id='topic+calculate_Area'></span>

<h3>Description</h3>

<p>Calculate Area/Intensity for one row of the input sequence dataframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_Area(
  row,
  matching_result,
  matching_columns,
  distinct_columns = NULL,
  area_column,
  with_PTM = FALSE,
  reps = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_Area_+3A_row">row</code></td>
<td>
<p>A row of dataframe containing the sequence for the 'Character' column in region_data.</p>
</td></tr>
<tr><td><code id="calculate_Area_+3A_matching_result">matching_result</code></td>
<td>
<p>The dataframe that contains the matched results and PTM information.</p>
</td></tr>
<tr><td><code id="calculate_Area_+3A_matching_columns">matching_columns</code></td>
<td>
<p>Vector of column names that should match between the 'row' and 'matching_result' dataframes.</p>
</td></tr>
<tr><td><code id="calculate_Area_+3A_distinct_columns">distinct_columns</code></td>
<td>
<p>Vector of column names that should be used to calculate Area separately for each unique combination of these columns.</p>
</td></tr>
<tr><td><code id="calculate_Area_+3A_area_column">area_column</code></td>
<td>
<p>The name of the column in 'matching_result' that contains the area/intensity information.</p>
</td></tr>
<tr><td><code id="calculate_Area_+3A_with_ptm">with_PTM</code></td>
<td>
<p>A boolean parameter indicating whether PTM should be considered. If <code>with_PTM = TRUE</code>,
the function will also add 'PTM' and 'PTM_type' to the result 'region_data' dataframe. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="calculate_Area_+3A_reps">reps</code></td>
<td>
<p>A boolean parameter indicating whether the area/intensity should be divided by the number of replicates. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the modified <code>region_data</code> dataframe that includes the &quot;Area&quot; column, and optionally &quot;PTM&quot; and &quot;PTM_type&quot; columns.
If the 'filter_conditions' do not match, an empty dataframe will be returned early.
An AttributeError is raised if 'PTM_position' and 'PTM_type' columns do not exist in the 'result' dataframe when 'with_PTM' is <code>TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>row &lt;- data.frame(
 Region_Sequence = c("XYZAAA"),
 Condition_1 = c("Drug1"),
 Condition_2 = c("Donor1"),
 Region_1 = c("VH"),
 Region_2 = c("Arm_1")
)
matching_result &lt;- data.frame(
  Sequence = c("AAA", "DDD", "DDD"),
  Condition_1 = c("Drug1", "Drug2", "Drug2"),
  Condition_2 = c("Donor1", "Donor2", "Donor2"),
  Region_1 = c("VH", "VL", "VL"),
  Region_2 = c("Arm_1", "Arm_2", "Arm_2"),
  Start_Position = c(4, 4, 4),
  End_Position = c(6, 6, 6),
  PTM_position = c(NA, 2, 0),
  PTM_type = c(NA,"O","C"),
  Area = c(100, 200, 200),
  reps = c(1, 2, 2)
)
matching_columns &lt;- c("Condition_1", "Region_2")
area_column &lt;- "Area"
data_with_area &lt;- calculate_Area(
  row,
  matching_result,
  matching_columns,
  distinct_columns = c("Condition_2", "Region_1"),
  area_column,
  with_PTM = TRUE,
  reps = TRUE
)

</code></pre>

<hr>
<h2 id='calculate_PSM'>Calculate Spectra Count (PSM) for one row of the input sequence dataframe</h2><span id='topic+calculate_PSM'></span>

<h3>Description</h3>

<p>Calculate Spectra Count (PSM) for one row of the input sequence dataframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_PSM(
  row,
  matching_result,
  matching_columns,
  distinct_columns,
  with_PTM = FALSE,
  reps = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_PSM_+3A_row">row</code></td>
<td>
<p>A row of dataframe containing the sequence for the 'Character' column in region_data.</p>
</td></tr>
<tr><td><code id="calculate_PSM_+3A_matching_result">matching_result</code></td>
<td>
<p>The dataframe that contains the matched results and PTM information.</p>
</td></tr>
<tr><td><code id="calculate_PSM_+3A_matching_columns">matching_columns</code></td>
<td>
<p>Vector of column names that should match between the 'row' and 'matching_result' dataframes.</p>
</td></tr>
<tr><td><code id="calculate_PSM_+3A_distinct_columns">distinct_columns</code></td>
<td>
<p>Vector of column names that should be used to calculate PSM separately for each unique combination of these columns.</p>
</td></tr>
<tr><td><code id="calculate_PSM_+3A_with_ptm">with_PTM</code></td>
<td>
<p>A boolean parameter indicating whether PTM should be considered. If <code>with_PTM = TRUE</code>,
the function will also add 'PTM' and 'PTM_type' to the result 'region_data' dataframe. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="calculate_PSM_+3A_reps">reps</code></td>
<td>
<p>A boolean parameter indicating whether the area/intensity should be divided by the number of replicates. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the modified <code>region_data</code> dataframe that includes the &quot;PSM&quot; column, and optionally &quot;PTM&quot; and &quot;PTM_type&quot; columns.
If the 'filter_conditions' do not match, an empty dataframe will be returned early.
An AttributeError is raised if 'PTM_position' and 'PTM_type' columns do not exist in the 'result' dataframe when 'with_PTM' is <code>TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>row &lt;- data.frame(
 Region_Sequence = c("XYZDDD"),
 Condition_1 = c("Drug2"),
 Region_1 = c("VL"),
 Region_2 = c("Arm_2")
)
matching_result &lt;- data.frame(
  Sequence = c("AAA", "DDD", "DDD"),
  Condition_1 = c("Drug1", "Drug2", "Drug2"),
  Condition_2 = c("Donor1", "Donor2", "Donor2"),
  Region_1 = c("VH", "VL", "VL"),
  Region_2 = c("Arm_1", "Arm_2", "Arm_2"),
  Start_Position = c(4, 4, 4),
  End_Position = c(6, 6, 6),
  PTM_position = c(NA, 2, 0),
  PTM_type = c(NA,"O","C"),
  Area = c(100, 200, 200),
  reps = c(1, 2, 2)
)
matching_columns &lt;- c("Condition_1", "Region_2")
result &lt;- calculate_PSM(
  row,
  matching_result,
  matching_columns,
  distinct_columns = c("Condition_2", "Region_1"),
  with_PTM = TRUE,
  reps = TRUE
)

</code></pre>

<hr>
<h2 id='combine_files_from_folder'>Combine CSV and TXT Files from a Folder</h2><span id='topic+combine_files_from_folder'></span>

<h3>Description</h3>

<p>This function reads all CSV and TXT files from a specified folder and combines them
into a single data.table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_files_from_folder(folder_path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine_files_from_folder_+3A_folder_path">folder_path</code></td>
<td>
<p>The path to the folder containing the CSV or TSV files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table containing the combined data from all files.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>folder_path &lt;- ""
combined_df &lt;- combine_files_from_folder(folder_path)
print(combined_df)

</code></pre>

<hr>
<h2 id='convert_to_regex_pattern'>Convert Peptide Sequence to Regex Pattern</h2><span id='topic+convert_to_regex_pattern'></span>

<h3>Description</h3>

<p>This function converts a peptide sequence into a regular expression pattern
that accounts for ambiguous amino acids. Each amino acid is replaced by a
character class that includes itself, 'X', and any specific ambiguities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_to_regex_pattern(peptide)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_to_regex_pattern_+3A_peptide">peptide</code></td>
<td>
<p>A character string representing the peptide sequence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string containing the regex pattern for matching.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert a peptide sequence to a regex pattern
peptide &lt;- "NDEQIL"
regex_pattern &lt;- convert_to_regex_pattern(peptide)
print(regex_pattern) # Output: "[NBX][DBX][EZX][QZX][ILX][ILX]"
</code></pre>

<hr>
<h2 id='create_peptide_plot'>Create a peptide Plot</h2><span id='topic+create_peptide_plot'></span>

<h3>Description</h3>

<p>This function generates a peptide plot using the provided data and allows for customization of the plot layout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_peptide_plot(
  data,
  y_axis_vars,
  x_axis_vars,
  y_expand = c(0.1, 0.15),
  x_expand = c(0.6, 0.6),
  theme_options = NULL,
  labs_options = NULL,
  color_fill_column,
  fill_gradient_options = list(),
  label_size = 3,
  add_domain = TRUE,
  domain = NULL,
  domain_start_column = "domain_start",
  domain_end_column = "domain_end",
  domain_type_column = "domain_type",
  domain_color = NULL,
  PTM = FALSE,
  PTM_type_column = "PTM_type",
  PTM_color = NULL,
  add_label = TRUE,
  label_column = "Character",
  label_value = NULL,
  column_order = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_peptide_plot_+3A_data">data</code></td>
<td>
<p>A dataframe containing the PSM data or Area data got from peptide_cluster_quantification.</p>
</td></tr>
<tr><td><code id="create_peptide_plot_+3A_y_axis_vars">y_axis_vars</code></td>
<td>
<p>A list of variables for the donor and type facets.</p>
</td></tr>
<tr><td><code id="create_peptide_plot_+3A_x_axis_vars">x_axis_vars</code></td>
<td>
<p>A list of variables for the region facets.</p>
</td></tr>
<tr><td><code id="create_peptide_plot_+3A_y_expand">y_expand</code></td>
<td>
<p>A numeric vector of length 2 specifying the expansion for the y-axis. Default is <code>c(0.1, 0.15)</code>.</p>
</td></tr>
<tr><td><code id="create_peptide_plot_+3A_x_expand">x_expand</code></td>
<td>
<p>A numeric vector of length 2 specifying the expansion for the x-axis. Default is <code>c(0.6, 0.6)</code>.</p>
</td></tr>
<tr><td><code id="create_peptide_plot_+3A_theme_options">theme_options</code></td>
<td>
<p>A list of additional theme options to customize the plot. Default is an empty list.</p>
</td></tr>
<tr><td><code id="create_peptide_plot_+3A_labs_options">labs_options</code></td>
<td>
<p>A list of additional labs options to customize the plot labels. Default is an empty list.</p>
</td></tr>
<tr><td><code id="create_peptide_plot_+3A_color_fill_column">color_fill_column</code></td>
<td>
<p>The name of the column in <code>data_with_psm</code> to be used for the fill aesthetic. Default is 'PSM'.</p>
</td></tr>
<tr><td><code id="create_peptide_plot_+3A_fill_gradient_options">fill_gradient_options</code></td>
<td>
<p>A list of options for <code>scale_fill_gradient</code>. Default is an empty list.</p>
</td></tr>
<tr><td><code id="create_peptide_plot_+3A_label_size">label_size</code></td>
<td>
<p>The size of the labels in the plot. Default is 3.</p>
</td></tr>
<tr><td><code id="create_peptide_plot_+3A_add_domain">add_domain</code></td>
<td>
<p>A logical value indicating whether to add domain like CDR (Complementarity-Determining Region) to the plot. Default is TRUE.</p>
</td></tr>
<tr><td><code id="create_peptide_plot_+3A_domain">domain</code></td>
<td>
<p>A dataframe containing the domain data with columns including 'domain_start', 'domain_end', and 'domain_type'.</p>
</td></tr>
<tr><td><code id="create_peptide_plot_+3A_domain_start_column">domain_start_column</code></td>
<td>
<p>The name of the column in <code>domain</code> containing the start position of the domain Default is 'domain_start'.</p>
</td></tr>
<tr><td><code id="create_peptide_plot_+3A_domain_end_column">domain_end_column</code></td>
<td>
<p>The name of the column in <code>domain</code> containing the end position of the domain Default is 'domain_end'.</p>
</td></tr>
<tr><td><code id="create_peptide_plot_+3A_domain_type_column">domain_type_column</code></td>
<td>
<p>The name of the column in <code>domain</code> containing the type of the domain Default is 'domain_type'.</p>
</td></tr>
<tr><td><code id="create_peptide_plot_+3A_domain_color">domain_color</code></td>
<td>
<p>A list of colors for the domain types. Default is NULL.</p>
</td></tr>
<tr><td><code id="create_peptide_plot_+3A_ptm">PTM</code></td>
<td>
<p>A logical value indicating whether to include PTM (Post-Translational Modification) data in the plot. Default is FALSE.</p>
</td></tr>
<tr><td><code id="create_peptide_plot_+3A_ptm_type_column">PTM_type_column</code></td>
<td>
<p>The name of the column in <code>data_with_psm</code> containing the type of the PTM. Default is 'PTM_type'.</p>
</td></tr>
<tr><td><code id="create_peptide_plot_+3A_ptm_color">PTM_color</code></td>
<td>
<p>A list of colors for the PTM types. Default is NULL.</p>
</td></tr>
<tr><td><code id="create_peptide_plot_+3A_add_label">add_label</code></td>
<td>
<p>A logical value indicating whether to add labels to the plot. Default is TRUE.</p>
</td></tr>
<tr><td><code id="create_peptide_plot_+3A_label_column">label_column</code></td>
<td>
<p>The name of the column in <code>data_with_psm</code> containing the labels to be added to the plot. Default is 'Character'.</p>
</td></tr>
<tr><td><code id="create_peptide_plot_+3A_label_value">label_value</code></td>
<td>
<p>A list of column names and their values to filter the data for the labels. Default is NULL.</p>
</td></tr>
<tr><td><code id="create_peptide_plot_+3A_column_order">column_order</code></td>
<td>
<p>A list of column names and their order for the plot. Default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a ggplot object representing the PSM plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(
  Character = c("X", "Y", "Z", "A", "A", "A"),
  Position = 1:6,
  Condition_1 = rep("Drug1", 6),
  Region_2 = rep("Arm_1", 6),
  Area = c(0.000000, 0.000000, 0.000000, 6.643856, 6.643856, 6.643856),
  Condition_2 = rep("Donor1", 6),
  Region_1 = rep("VH", 6),
  PTM = c(FALSE, TRUE, FALSE, FALSE, FALSE, FALSE),
  PTM_type = c(NA, "O", NA, NA, NA, NA)
)
domain &lt;- data.frame(
  domain_type = c("CDR H1", "CDR H2", "CDR H3"),
  Region_1 = c("VH", "VH", "VH"),
  Region_2 = c("Arm_1", "Arm_1", "Arm_1"),
  Condition_1 = c("Drug1", "Drug1", "Drug1"),
  domain_start = c(1, 3, 5),
  domain_end = c(2, 4, 6)
)
x_axis_vars &lt;- c("Region_2", "Region_1")
y_axis_vars &lt;- c("Condition_2")
domain_color &lt;- c(
"CDR H1" = "#F8766D",
"CDR H2" = "#B79F00",
"CDR H3" = "#00BA38",
"CDR L1" = "#00BFC4",
"CDR L2" = "#619CFF",
"CDR L3" = "#F564E3"
)
PTM_color &lt;- c(
  "Ox" = "red",
  "Deamid" = "cyan",
  "Cam" = "blue",
  "Acetyl" = "magenta"
)
p &lt;- create_peptide_plot(
  data,
  y_axis_vars,
  x_axis_vars,
  y_expand = c(0.2, 0.2),
  x_expand = c(0.5, 0.5),
  theme_options = list(),
  labs_options = list(title = "PSM Plot", x = "Position", fill = "PSM"),
  color_fill_column = 'Area',
  fill_gradient_options = list(),
  label_size = 5,
  add_domain = TRUE,
  domain = domain,
  domain_start_column = "domain_start",
  domain_end_column = "domain_end",
  domain_type_column = "domain_type",
  domain_color = domain_color,
  PTM = FALSE,
  PTM_type_column = "PTM_type",
  PTM_color = PTM_color,
  add_label = TRUE,
  label_column = "Character",
  label_value = NULL,
  column_order = list(Region_1 = 'VH,VL')
)
print(p)

</code></pre>

<hr>
<h2 id='match_and_calculate_positions'>Match peptide sequence with provided sequence and calculate positions</h2><span id='topic+match_and_calculate_positions'></span>

<h3>Description</h3>

<p>This function matches peptide sequences from the 'peptide_data' data frame to
corresponding provided sequences in the 'whole_seq' data frame. It calculates
the start and end positions of the matched sequences and returns a data frame
with information about the matching positions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_and_calculate_positions(
  peptide_data,
  column,
  whole_seq,
  match_columns,
  sequence_length = NULL,
  column_keep = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="match_and_calculate_positions_+3A_peptide_data">peptide_data</code></td>
<td>
<p>A data frame containing peptide sequence information to match.</p>
</td></tr>
<tr><td><code id="match_and_calculate_positions_+3A_column">column</code></td>
<td>
<p>The name of the column in peptide_data containing the peptide
sequences to be matched.</p>
</td></tr>
<tr><td><code id="match_and_calculate_positions_+3A_whole_seq">whole_seq</code></td>
<td>
<p>A data frame containing details about antibody sequence
information including the domain and region information.
'Region_Sequence' column is required for the sequence information.
Change the column name if it is different than 'Region_Sequence'.</p>
</td></tr>
<tr><td><code id="match_and_calculate_positions_+3A_match_columns">match_columns</code></td>
<td>
<p>A character vector of column names to match on while
matching peptide sequence.</p>
</td></tr>
<tr><td><code id="match_and_calculate_positions_+3A_sequence_length">sequence_length</code></td>
<td>
<p>(Optional) The sequence length range of peptide that
we want to keep in the result. (e.g. c(1, 5) will include
peptide sequence length from 1 to 5.)</p>
</td></tr>
<tr><td><code id="match_and_calculate_positions_+3A_column_keep">column_keep</code></td>
<td>
<p>(Optional) The name of the columns in peptide_data to
keep in result data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns from 'peptide_data' and 'whole_seq'
indicating the matched positions and related information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>peptide_data &lt;- data.frame(
  Sequence = c("AILNK", "BXLMR", "JJNXX", "DDEEF"),
  Condition_1 = c("Drug1", "Drug1", "Drug2", "Drug2"),
  Condition_2 = c("Donor1", "Donor2", "Donor1", "Donor2"),
  Region_1 = c("VH", "VL", "VH", "VL"),
  Region_2 = c("Arm_1", "Arm_2", "Arm_1", "Arm_2"),
  Area = c(100, 2, 4, NA)
)
whole_seq &lt;- data.frame(
  Region_Sequence = c(
    "XYZAILNKPQR",
    "ABCBXLMRDEF",
    "GHIJJNXXKLM",
    "NOPDDEEFQRS",
    "AILXKPQR",
    "BNJLMRDEF",
    "ILNXXKLM",
    "DDEEXQRS",
    "XYZAAA",
    "XYZCCC",
    "XYZBBB",
    "XYZDDD",
    "XYZAAB",
    "XYZCCD",
    "XYZBBB",
    "XYZDDD"
  ),
  Condition_1 = c(
    "Drug1",
    "Drug1",
    "Drug2",
    "Drug2",
    "Drug1",
    "Drug1",
    "Drug2",
    "Drug2",
    "Drug1",
    "Drug1",
    "Drug2",
    "Drug2",
    "Drug1",
    "Drug1",
    "Drug2",
    "Drug2"
  ),
  Condition_2 = c(
    "Donor1",
    "Donor1",
    "Donor1",
    "Donor1",
    "Donor1",
    "Donor1",
    "Donor1",
    "Donor1",
    "Donor2",
    "Donor2",
    "Donor2",
    "Donor2",
    "Donor2",
    "Donor2",
    "Donor2",
    "Donor2"
  ),
  Region_1 = c(
    "VH",
    "VL",
    "VH",
    "VL",
    "VH",
    "VL",
    "VH",
    "VL",
    "VH",
    "VL",
    "VH",
    "VL",
    "VH",
    "VL",
    "VH",
    "VL"
  ),
  Region_2 = c(
    "Arm_1",
    "Arm_1",
    "Arm_1",
    "Arm_1",
    "Arm_2",
    "Arm_2",
    "Arm_2",
    "Arm_2",
    "Arm_1",
    "Arm_1",
    "Arm_1",
    "Arm_1",
    "Arm_2",
    "Arm_2",
    "Arm_2",
    "Arm_2"
  )
)
match_columns &lt;- c("Condition_1", "Condition_2", "Region_1")
column_keep &lt;- c("Region_2")
sequence_length &lt;- c(1, 5)
column &lt;- "Sequence"
matching_result &lt;- match_and_calculate_positions(peptide_data,
                                                 column,
                                                 whole_seq,
                                                 match_columns,
                                                 sequence_length,
                                                 column_keep)

</code></pre>

<hr>
<h2 id='obtain_mod'>Obtain post translational modification(PTM) information from Peptide data
based on the specified data type</h2><span id='topic+obtain_mod'></span>

<h3>Description</h3>

<p>This function takes outputs from multiple platform, a data frame with column
containing modified peptide sequence with the detailed post translational
modification(PTM) information and converts it into a new dataframe with the desired format of peptide
sequences and associated PTM information. Due to the flexibility of outputs from
multiple platform, the PTM mass to type table needs to be provided if convertion to PTM_type is needed.
The result includes 'Peptide', 'PTM_position', 'PTM_type' and 'PTM_mass' columns.The function chooses
the appropriate converting method based on the specified data type ('PEAKS',
'Spectronaut', 'MSFragger', 'Comet', 'DIANN', 'Skyline' or 'Maxquant'),
allowing you to convert the data into a consistent format for further analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obtain_mod(
  data,
  column,
  type,
  strip_seq_col = NULL,
  PTM_table = NULL,
  PTM_annotation = FALSE,
  PTM_mass_column
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="obtain_mod_+3A_data">data</code></td>
<td>
<p>A data frame with the peptide sequences.</p>
</td></tr>
<tr><td><code id="obtain_mod_+3A_column">column</code></td>
<td>
<p>The name of the column containing the modified peptide sequences.</p>
</td></tr>
<tr><td><code id="obtain_mod_+3A_type">type</code></td>
<td>
<p>A character string specifying the data type (e.g. 'Skyline' or 'Maxquant').</p>
</td></tr>
<tr><td><code id="obtain_mod_+3A_strip_seq_col">strip_seq_col</code></td>
<td>
<p>(Optional) The name of the column containing the stripped peptide sequences.</p>
</td></tr>
<tr><td><code id="obtain_mod_+3A_ptm_table">PTM_table</code></td>
<td>
<p>A data frame with columns 'PTM_mass' and 'PTM_type' containing PTM annotation information.</p>
</td></tr>
<tr><td><code id="obtain_mod_+3A_ptm_annotation">PTM_annotation</code></td>
<td>
<p>A logical value indicating whether to include PTM annotation information in the result.</p>
</td></tr>
<tr><td><code id="obtain_mod_+3A_ptm_mass_column">PTM_mass_column</code></td>
<td>
<p>The name of the column containing the PTM mass information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with 'PTM_position', 'PTM_type', 'PTM_mass', 'reps', and other columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
data_skyline &lt;- data.table(
  'Peptide Modified Sequence' = c(
    "AGLC[+57]QTFVYGGC[+57]R",
    "AAAASAAEAGIATTGTEDSDDALLK",
    "IVGGWEC[+57]EK"
  ),
  Condition = c("A", "B", "B")
)
PTM_table &lt;- data.table(
  PTM_mass = c(57.02, -0.98, 15.9949),
  PTM_type = c("Cam", "Amid", "Ox")
)
converted_data_skyline &lt;- obtain_mod(
  data_skyline,
  'Peptide Modified Sequence',
  'Skyline',
  strip_seq_col = NULL,
  PTM_table,
  PTM_annotation = TRUE,
  PTM_mass_column = "PTM_mass"
)

data_maxquant &lt;- data.table(
  'Modified sequence' = c(
    "_(ac)AAAAELRLLEK_",
    "_EAAENSLVAYK_",
    "_AADTIGYPVM(ox)IRSAYALGGLGSGICPNK_"
  ),
  Condition = c("A", "B", "B")
)
PTM_table &lt;- data.table(
  PTM_mass = c('Phospho (STY)', 'Oxidation (M)'),
  PTM_type = c("Phos", "Ox")
)
converted_data_maxquant &lt;- obtain_mod(
  data_maxquant,
  'Modified sequence',
  'Maxquant',
  strip_seq_col = NULL,
  PTM_table,
  PTM_annotation = TRUE,
  PTM_mass_column = "PTM_mass"
)


</code></pre>

<hr>
<h2 id='obtain_mod_Comet'>Obtain modification information from Peptide data generated by Comet</h2><span id='topic+obtain_mod_Comet'></span>

<h3>Description</h3>

<p>This function takes Comet output containing a column with modified peptide
sequences including PTM information and converts it into a new dataframe with the
desired format of peptide sequences and associated PTM information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obtain_mod_Comet(
  data,
  column,
  PTM_table = NULL,
  PTM_annotation = FALSE,
  PTM_mass_column
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="obtain_mod_Comet_+3A_data">data</code></td>
<td>
<p>A data.table with a column containing PTM information.</p>
</td></tr>
<tr><td><code id="obtain_mod_Comet_+3A_column">column</code></td>
<td>
<p>The name of the column containing the modified peptide sequences.</p>
</td></tr>
<tr><td><code id="obtain_mod_Comet_+3A_ptm_table">PTM_table</code></td>
<td>
<p>A data.table with columns 'PTM_mass' and 'PTM_type' containing PTM annotation information.</p>
</td></tr>
<tr><td><code id="obtain_mod_Comet_+3A_ptm_annotation">PTM_annotation</code></td>
<td>
<p>A logical value indicating whether to include PTM annotation information in the result.</p>
</td></tr>
<tr><td><code id="obtain_mod_Comet_+3A_ptm_mass_column">PTM_mass_column</code></td>
<td>
<p>The name of the column containing the PTM mass information</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with 'PTM_position', 'PTM_type', 'reps', and other columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
data &lt;- data.table(
  modified_peptide = c(
    "AAM[15.9949]Q[-0.98]RGSLYQCDYSTGSC[57.02]EPIR",
    "K.AAQQTGKLVHANFGT.K",
    "K.[-0.98]AATVTGKLVHANFGT.K"
  ),
  plain_peptide = c(
    "AAMQRGSLYQCDYSTGSCEPIR",
    "AAQQTGKLVHANFGT",
    "AATVTGKLVHANFGT"
  ),
  Condition = c("A", "B", "B")
)
PTM_table &lt;- data.table(
  PTM_mass = c(57.02, -0.98, 15.9949),
  PTM_type = c("Cam", "Amid", "Ox")
)
column &lt;- 'modified_peptide'
PTM_mass_column &lt;- "PTM_mass"
converted_data &lt;- obtain_mod_Comet(data, column, PTM_table, PTM_annotation = TRUE, PTM_mass_column)

</code></pre>

<hr>
<h2 id='obtain_mod_DIANN'>Obtain modification information from Peptide data generated by DIA-NN</h2><span id='topic+obtain_mod_DIANN'></span>

<h3>Description</h3>

<p>This function takes DIA-NN output containing a column with modified peptide
sequences including PTM information and converts it into a new dataframe with the
desired format of peptide sequences and associated PTM information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obtain_mod_DIANN(
  data,
  column,
  PTM_table = NULL,
  PTM_annotation = FALSE,
  PTM_mass_column
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="obtain_mod_DIANN_+3A_data">data</code></td>
<td>
<p>A dataframe with 'Stripped.Sequence' column and 'Modified.Sequence' column containing modified peptide sequences.</p>
</td></tr>
<tr><td><code id="obtain_mod_DIANN_+3A_column">column</code></td>
<td>
<p>The name of the column containing the modified peptide sequences.</p>
</td></tr>
<tr><td><code id="obtain_mod_DIANN_+3A_ptm_table">PTM_table</code></td>
<td>
<p>A dataframe with columns 'PTM_mass' and 'PTM_type' containing PTM annotation information.</p>
</td></tr>
<tr><td><code id="obtain_mod_DIANN_+3A_ptm_annotation">PTM_annotation</code></td>
<td>
<p>A logical value indicating whether to include PTM annotation information in the result.</p>
</td></tr>
<tr><td><code id="obtain_mod_DIANN_+3A_ptm_mass_column">PTM_mass_column</code></td>
<td>
<p>The name of the column containing the PTM mass information</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with 'Peptide', 'PTM_position', and 'PTM_type' columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
data &lt;- data.table(
  Modified.Sequence = c(
    "AAAAGPGAALS(UniMod:21)PRPC(UniMod:4)DSDPATPGAQSPK",
    "AAAASAAEAGIATTGTEDSDDALLK",
    "AAAAALSGSPPQTEKPT(UniMod:21)HYR"
  ),
  Stripped.Sequence = c(
    "AAAAGPGAALSPRPCDSDPATPGAQSPK",
    "AAAASAAEAGIATTGTEDSDDALLK",
    "AAAAALSGSPPQTEKPTHYR"
  ),
  Condition = c("A", "B", "B")
)
PTM_table &lt;- data.table(PTM_mass = c('UniMod:21', 'UniMod:4'),
                        PTM_type = c("Phos", "Cam"))
converted_data &lt;- obtain_mod_DIANN(
  data,
  'Modified.Sequence',
  PTM_table,
  PTM_annotation = TRUE,
  PTM_mass_column = "PTM_mass"
)

</code></pre>

<hr>
<h2 id='obtain_mod_Maxquant'>Obtain modification information from Peptide data generated by Maxquant</h2><span id='topic+obtain_mod_Maxquant'></span>

<h3>Description</h3>

<p>This function takes Maxquant output containing a column with modified peptide sequences
including PTM information and converts it into a new dataframe with the desired format of peptide
sequences and associated PTM information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obtain_mod_Maxquant(
  data,
  column,
  PTM_table = NULL,
  PTM_annotation = FALSE,
  PTM_mass_column
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="obtain_mod_Maxquant_+3A_data">data</code></td>
<td>
<p>A data.table with a column containing modified peptide sequences.</p>
</td></tr>
<tr><td><code id="obtain_mod_Maxquant_+3A_column">column</code></td>
<td>
<p>The name of the column containing the modified peptide sequences.</p>
</td></tr>
<tr><td><code id="obtain_mod_Maxquant_+3A_ptm_table">PTM_table</code></td>
<td>
<p>A data.table with columns 'PTM_mass' and 'PTM_type' containing PTM annotation information.</p>
</td></tr>
<tr><td><code id="obtain_mod_Maxquant_+3A_ptm_annotation">PTM_annotation</code></td>
<td>
<p>A logical value indicating whether to include PTM annotation information in the result.</p>
</td></tr>
<tr><td><code id="obtain_mod_Maxquant_+3A_ptm_mass_column">PTM_mass_column</code></td>
<td>
<p>The name of the column containing the PTM mass information</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with 'PTM_position', 'PTM_type', 'reps', and other columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
data &lt;- data.table(
  'Modified sequence' = c(
    "_GLGPSPAGDGPS(Phospho (STY))GSGK_",
    "_HSSYPAGTEDDEGM(Oxidation (M))GEEPSPFR_",
    "_HSSYPAGTEDDEGM(Oxidation (M))GEEPS(Phospho (STY))PFR_"
  ),
  Condition = c("A", "B", "B")
)
PTM_table &lt;- data.table(
  PTM_mass = c('Phospho (STY)', 'Oxidation (M)'),
  PTM_type = c("Phos", "Ox")
)
converted_data &lt;- obtain_mod_Maxquant(
  data,
  'Modified sequence',
  PTM_table,
  PTM_annotation = TRUE,
  PTM_mass_column = "PTM_mass"
)

</code></pre>

<hr>
<h2 id='obtain_mod_MSFragger'>Obtain modification information from Peptide data generated by MSFragger</h2><span id='topic+obtain_mod_MSFragger'></span>

<h3>Description</h3>

<p>This function takes MSFragger output containing a 'Assigned Modifications' column with
PTM information and converts it into a new dataframe with the desired format of peptide
sequences and associated PTM information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obtain_mod_MSFragger(
  data,
  column,
  strip_seq_col,
  PTM_table = NULL,
  PTM_annotation = FALSE,
  PTM_mass_column
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="obtain_mod_MSFragger_+3A_data">data</code></td>
<td>
<p>A data.table with a column containing stripped sequence and a column containing PTM information.</p>
</td></tr>
<tr><td><code id="obtain_mod_MSFragger_+3A_column">column</code></td>
<td>
<p>The name of the column containing the modified peptide sequences.</p>
</td></tr>
<tr><td><code id="obtain_mod_MSFragger_+3A_strip_seq_col">strip_seq_col</code></td>
<td>
<p>The name of the column containing the stripped peptide sequences.</p>
</td></tr>
<tr><td><code id="obtain_mod_MSFragger_+3A_ptm_table">PTM_table</code></td>
<td>
<p>A data.table with columns 'PTM_mass' and 'PTM_type' containing PTM annotation information.</p>
</td></tr>
<tr><td><code id="obtain_mod_MSFragger_+3A_ptm_annotation">PTM_annotation</code></td>
<td>
<p>A logical value indicating whether to include PTM annotation information in the result.</p>
</td></tr>
<tr><td><code id="obtain_mod_MSFragger_+3A_ptm_mass_column">PTM_mass_column</code></td>
<td>
<p>The name of the column containing the PTM mass information</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with 'PTM_position', 'PTM_type', 'reps', and other columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
data &lt;- data.table(
  Peptide = c("DDREDMLVYQAK", "EAAENSLVAYK", "IEAELQDICNDVLELLDK"),
  `Assigned Modifications` = c("C-term(15.9949), 6M(-0.98)", "", "N-term(42.0106)"),
  Condition1 = c("A", "B", "B"),
  Condition2 = c("C", "C", "D")
)
PTM_table &lt;- data.table(
  PTM_mass = c(42.0106, -0.98, 15.9949),
  PTM_type = c("Acet", "Amid", "Ox")
)
column &lt;- "Assigned Modifications"
strip_seq_col &lt;- "Peptide"
converted_data &lt;- obtain_mod_MSFragger(
  data,
  column,
  strip_seq_col,
  PTM_table,
  PTM_annotation = TRUE,
  PTM_mass_column = "PTM_mass"
)

</code></pre>

<hr>
<h2 id='obtain_mod_PEAKS'>Obtain modification information from Peptide data generated by PEAKS</h2><span id='topic+obtain_mod_PEAKS'></span>

<h3>Description</h3>

<p>This function takes PEAKS output containing a column with modified peptide
sequences including PTM information and converts it into a new dataframe with the
desired format of peptide sequences and associated PTM information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obtain_mod_PEAKS(
  data,
  column,
  PTM_table = NULL,
  PTM_annotation = FALSE,
  PTM_mass_column
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="obtain_mod_PEAKS_+3A_data">data</code></td>
<td>
<p>A dataframe with a column containing modified peptide sequences.</p>
</td></tr>
<tr><td><code id="obtain_mod_PEAKS_+3A_column">column</code></td>
<td>
<p>The name of the column containing the modified peptide sequences.</p>
</td></tr>
<tr><td><code id="obtain_mod_PEAKS_+3A_ptm_table">PTM_table</code></td>
<td>
<p>A dataframe with columns 'PTM_mass' and 'PTM_type' containing PTM annotation information.</p>
</td></tr>
<tr><td><code id="obtain_mod_PEAKS_+3A_ptm_annotation">PTM_annotation</code></td>
<td>
<p>A logical value indicating whether to include PTM annotation information in the result.</p>
</td></tr>
<tr><td><code id="obtain_mod_PEAKS_+3A_ptm_mass_column">PTM_mass_column</code></td>
<td>
<p>The name of the column containing the PTM mass information</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with 'PTM_position', 'PTM_type', 'PTM_mass', 'reps', and other columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
data &lt;- data.table(
  Peptide = c(
    "AAN(+42)Q(-0.98)RGSLYQCDYSTGSC(+57.02)EPIR",
    "K.AAQQTGKLVHANFGT.K",
    "K.(-0.98)AATVTGKLVHANFGT.K"
  ),
  Sequence = c(
    "AANQRGSLYQCDYSTGSCEPIR",
    "AAQQTGKLVHANFGT",
    "AATVTGKLVHANFGT"
  ),
  Condition = c("A", "B", "B")
)
PTM_table &lt;- data.table(PTM_mass = c(42, -0.98, 57.02),
                        PTM_type = c("Acet", "Amid", "Cam"))
column &lt;- "Peptide"
PTM_mass_column &lt;- "PTM_mass"
converted_data &lt;- obtain_mod_PEAKS(data, column, PTM_table, PTM_annotation = TRUE, PTM_mass_column)

</code></pre>

<hr>
<h2 id='obtain_mod_Skyline'>Obtain modification information from Peptide data generated by Skyline</h2><span id='topic+obtain_mod_Skyline'></span>

<h3>Description</h3>

<p>This function takes Skyline output containing a column with modified peptide
sequences including PTM information and converts it into a new dataframe with the
desired format of peptide sequences and associated PTM information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obtain_mod_Skyline(
  data,
  column,
  PTM_table,
  PTM_annotation = FALSE,
  PTM_mass_column
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="obtain_mod_Skyline_+3A_data">data</code></td>
<td>
<p>A data.table with a column containing PTM information.</p>
</td></tr>
<tr><td><code id="obtain_mod_Skyline_+3A_column">column</code></td>
<td>
<p>The name of the column containing the modified peptide sequences.</p>
</td></tr>
<tr><td><code id="obtain_mod_Skyline_+3A_ptm_table">PTM_table</code></td>
<td>
<p>A data.table with columns 'PTM_mass' and 'PTM_type' containing PTM annotation information.</p>
</td></tr>
<tr><td><code id="obtain_mod_Skyline_+3A_ptm_annotation">PTM_annotation</code></td>
<td>
<p>A logical value indicating whether to include PTM annotation information in the result.</p>
</td></tr>
<tr><td><code id="obtain_mod_Skyline_+3A_ptm_mass_column">PTM_mass_column</code></td>
<td>
<p>The name of the column containing the PTM mass information</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with 'PTM_position', 'PTM_type', 'reps', and other columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
data &lt;- data.table(
  'Peptide Modified Sequence' = c(
    "AAM[15.9949]Q[-0.98]RGSLYQCDYSTGSC[57.02]EPIR",
    "AAQQTGKLVHANFGT",
    "[-0.98]AATVTGKLVHANFGT"
  ),
  Condition = c("A", "B", "B")
)
PTM_table &lt;- data.table(
  PTM_mass = c(57.02, -0.98, 15.9949),
  PTM_type = c("Cam", "Amid", "Ox")
)
converted_data &lt;- obtain_mod_Skyline(
  data,
  'Peptide Modified Sequence',
  PTM_table,
  PTM_annotation = TRUE,
  PTM_mass_column = "PTM_mass"
)

</code></pre>

<hr>
<h2 id='obtain_mod_Spectronaut'>Obtain modification information from Peptide data generated by Spectronaut</h2><span id='topic+obtain_mod_Spectronaut'></span>

<h3>Description</h3>

<p>This function takes Spectronaut output containing a column with modified peptide sequences
including PTM information and converts it into a new dataframe with the desired format of peptide
sequences and associated PTM information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obtain_mod_Spectronaut(
  data,
  column,
  PTM_table = NULL,
  PTM_annotation = FALSE,
  PTM_mass_column
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="obtain_mod_Spectronaut_+3A_data">data</code></td>
<td>
<p>A data.table with a column containing modified peptide sequences.</p>
</td></tr>
<tr><td><code id="obtain_mod_Spectronaut_+3A_column">column</code></td>
<td>
<p>The name of the column containing the modified peptide sequences.</p>
</td></tr>
<tr><td><code id="obtain_mod_Spectronaut_+3A_ptm_table">PTM_table</code></td>
<td>
<p>A data.table with columns 'PTM_mass' and 'PTM_type' containing PTM annotation information.</p>
</td></tr>
<tr><td><code id="obtain_mod_Spectronaut_+3A_ptm_annotation">PTM_annotation</code></td>
<td>
<p>A logical value indicating whether to include PTM annotation information in the result.</p>
</td></tr>
<tr><td><code id="obtain_mod_Spectronaut_+3A_ptm_mass_column">PTM_mass_column</code></td>
<td>
<p>The name of the column containing the PTM mass information</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with 'PTM_position', 'PTM_type', 'reps', and other columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
data &lt;- data.table(
  EG.ModifiedPeptide = c(
    "_[Acetyl (Protein N-term)]M[Oxidation (M)]DDREDLVYQAK_",
    "_EAAENSLVAYK_",
    "_IEAELQDIC[Carbamidomethyl (C)]NDVLELLDK_"
  ),
  Condition = c("A", "B", "B")
)
PTM_table &lt;- data.table(
  PTM_mass = c(
    'Acetyl (Protein N-term)',
    'Oxidation (M)',
    'Carbamidomethyl (C)'
  ),
  PTM_type = c("Acet", "Ox", "Cam")
)
converted_data &lt;- obtain_mod_Spectronaut(data, 'EG.ModifiedPeptide',
                                         PTM_table, PTM_annotation = TRUE,
                                         PTM_mass_column = "PTM_mass")
data &lt;- data.table(
  EG.IntPIMID = c(
    "_[+42]M[-0.98]DDREDLVYQAK_",
    "_EAAENSLVAYK_",
    "_IEAELQDIC[+57]NDVLELLDK_"
  ),
  Condition = c("A", "B", "B")
)
PTM_table &lt;- data.table(PTM_mass = c(42, -0.98, 57),
                        PTM_type = c("Acet", "Amid", "Cam"))
PTM_mass_column &lt;- "PTM_mass"
converted_data &lt;- obtain_mod_Spectronaut(data,
                                         'EG.IntPIMID',
                                         PTM_table,
                                         PTM_annotation = TRUE,
                                         PTM_mass_column)

</code></pre>

<hr>
<h2 id='peptide_quantification'>Peptide Quantification</h2><span id='topic+peptide_quantification'></span>

<h3>Description</h3>

<p>Peptide Quantification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peptide_quantification(
  whole_seq,
  matching_result,
  matching_columns,
  distinct_columns,
  quantify_method,
  area_column = NULL,
  with_PTM = FALSE,
  reps = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="peptide_quantification_+3A_whole_seq">whole_seq</code></td>
<td>
<p>A dataframe holding whole sequence information. 'Region_Sequence' column is required for the sequence information. Change the column name if it is different than 'Region_Sequence'.</p>
</td></tr>
<tr><td><code id="peptide_quantification_+3A_matching_result">matching_result</code></td>
<td>
<p>The dataframe that contains the matched results and PTM information.</p>
</td></tr>
<tr><td><code id="peptide_quantification_+3A_matching_columns">matching_columns</code></td>
<td>
<p>Vector of column names that should match between each row of 'whole_seq' and the 'matching_result' dataframe.</p>
</td></tr>
<tr><td><code id="peptide_quantification_+3A_distinct_columns">distinct_columns</code></td>
<td>
<p>Vector of column names that should be used to calculate PSM or Area separately for each unique combination of these columns.</p>
</td></tr>
<tr><td><code id="peptide_quantification_+3A_quantify_method">quantify_method</code></td>
<td>
<p>A string indicating the quantification method. It can be either &quot;PSM&quot; or &quot;Area&quot;.</p>
</td></tr>
<tr><td><code id="peptide_quantification_+3A_area_column">area_column</code></td>
<td>
<p>The name of the column in 'matching_result' that contains the area/intensity information. Required if quantify_method is &quot;Area&quot;.</p>
</td></tr>
<tr><td><code id="peptide_quantification_+3A_with_ptm">with_PTM</code></td>
<td>
<p>A boolean parameter indicating whether PTM should be considered during calculation. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="peptide_quantification_+3A_reps">reps</code></td>
<td>
<p>A boolean parameter indicating whether the area/intensity should be divided by the number of replicates. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe containing the calculated PSM or Area for each record in 'whole_seq'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>whole_seq &lt;- data.frame(
  Region_Sequence = c(
    "XYZAAA",
    "XYZCCC",
    "XYZBBB",
    "XYZDDD",
    "XYZAAB",
    "XYZCCD",
    "XYZBBB",
    "XYZDDD",
    "XYZAAA",
    "XYZCCC",
    "XYZBBB",
    "XYZDDD",
    "XYZAAB",
    "XYZCCD",
    "XYZBBB",
    "XYZDDD"
  ),
  Condition_1 = c(
    "Drug1",
    "Drug1",
    "Drug2",
    "Drug2",
    "Drug1",
    "Drug1",
    "Drug2",
    "Drug2",
    "Drug1",
    "Drug1",
    "Drug2",
    "Drug2",
    "Drug1",
    "Drug1",
    "Drug2",
    "Drug2"
  ),
  Condition_2 = c(
    "Donor1",
    "Donor1",
    "Donor1",
    "Donor1",
    "Donor1",
    "Donor1",
    "Donor1",
    "Donor1",
    "Donor2",
    "Donor2",
    "Donor2",
    "Donor2",
    "Donor2",
    "Donor2",
    "Donor2",
    "Donor2"
  ),
  Region_1 = c(
    "VH",
    "VL",
    "VH",
    "VL",
    "VH",
    "VL",
    "VH",
    "VL",
    "VH",
    "VL",
    "VH",
    "VL",
    "VH",
    "VL",
    "VH",
    "VL"
  ),
  Region_2 = c(
    "Arm_1",
    "Arm_1",
    "Arm_1",
    "Arm_1",
    "Arm_2",
    "Arm_2",
    "Arm_2",
    "Arm_2",
    "Arm_1",
    "Arm_1",
    "Arm_1",
    "Arm_1",
    "Arm_2",
    "Arm_2",
    "Arm_2",
    "Arm_2"
  )
)
matching_result &lt;- data.frame(
  Sequence = c("AAA", "DDD", "DDD"),
  Condition_1 = c("Drug1", "Drug2", "Drug2"),
  Condition_2 = c("Donor1", "Donor2", "Donor2"),
  Region_1 = c("VH", "VL", "VL"),
  Region_2 = c("Arm_1", "Arm_2", "Arm_2"),
  Start_Position = c(4, 4, 4),
  End_Position = c(6, 6, 6),
  PTM_position = c(NA, 2, 0),
  PTM_type = c(NA, "O", "C"),
  Area = c(100, 200, 200),
  reps = c(1, 2, 2)
)
matching_columns &lt;- c("Condition_1", "Region_2")
area_column &lt;- "Area"
data_with_quantification &lt;- peptide_quantification(
  whole_seq,
  matching_result,
  matching_columns,
  distinct_columns = c("Condition_2", "Region_1"),
  quantify_method = "Area",
  area_column = area_column,
  with_PTM = TRUE,
  reps = TRUE
)
</code></pre>

<hr>
<h2 id='strip_sequence'>Strip peptide sequences based on the specified data type</h2><span id='topic+strip_sequence'></span>

<h3>Description</h3>

<p>This function takes outputs from multiple platform, a data frame with a
column containing peptide sequences to be stripped,
and a column where the stripped sequences will be stored. The function chooses
the appropriate stripping method based on the specified data type ('PEAKS',
'Spectronaut', 'MSFragger', 'Comet', 'DIANN', 'Skyline' or 'Maxquant').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strip_sequence(data, column, convert_column, type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strip_sequence_+3A_data">data</code></td>
<td>
<p>A data frame with the peptide sequences.</p>
</td></tr>
<tr><td><code id="strip_sequence_+3A_column">column</code></td>
<td>
<p>The name of the column containing the peptide sequences to be stripped.</p>
</td></tr>
<tr><td><code id="strip_sequence_+3A_convert_column">convert_column</code></td>
<td>
<p>The name of the column where the stripped sequences will be stored.</p>
</td></tr>
<tr><td><code id="strip_sequence_+3A_type">type</code></td>
<td>
<p>A character string specifying the data type (e.g. 'Skyline' or 'Maxquant').</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the specified column containing stripped sequences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
data_skyline &lt;- data.table(
  'Peptide Modified Sequence' = c(
    "AGLC[+57]QTFVYGGC[+57]R",
    "AAAASAAEAGIATTGTEDSDDALLK",
    "IVGGWEC[+57]EK"
  ),
  Condition = c("A", "B", "B")
)
data_maxquant &lt;- data.table(
  'Modified sequence' = c(
    "_(ac)AAAAELRLLEK_",
    "_EAAENSLVAYK_",
    "_AADTIGYPVM(ox)IRSAYALGGLGSGICPNK_"
  ),
  Condition = c("A", "B", "B")
)

converted_data_skyline &lt;- strip_sequence(data_skyline,
                                         'Peptide Modified Sequence',
                                         'Sequence',
                                         "Skyline")
converted_data_maxquant &lt;- strip_sequence(data_maxquant, 'Modified sequence',
                                          'Sequence', "Maxquant")

</code></pre>

<hr>
<h2 id='strip_sequence_Comet'>Strip sequence from Comet outputs</h2><span id='topic+strip_sequence_Comet'></span>

<h3>Description</h3>

<p>This function takes Comet output containing a column with peptide sequences to be stripped
and converts it into a new dataframe with the stripped sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strip_sequence_Comet(data, column, convert_column)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strip_sequence_Comet_+3A_data">data</code></td>
<td>
<p>A dataframe with a column containing peptide sequences to be stripped</p>
</td></tr>
<tr><td><code id="strip_sequence_Comet_+3A_column">column</code></td>
<td>
<p>The name of the column containing the peptide sequences to be stripped.</p>
</td></tr>
<tr><td><code id="strip_sequence_Comet_+3A_convert_column">convert_column</code></td>
<td>
<p>The name of the column where the stripped sequences will be stored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with a column containing stripped sequence
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
data &lt;- data.table(
  modified_peptide = c(
    "AAM[15.9949]Q[-0.98]RGSLYQCDYSTGSC[57.02]EPIR",
    "K.AAQQTGKLVHANFGT.K",
    "K.[0.98]AATVTGKLVHANFGT.K"
  ),
  Condition = c("A", "B", "B")
)
column &lt;- 'modified_peptide'
convert_column &lt;- 'Sequence'
converted_data &lt;- strip_sequence_Comet(data, column, convert_column)

</code></pre>

<hr>
<h2 id='strip_sequence_DIANN'>Strip sequence from DIANN outputs</h2><span id='topic+strip_sequence_DIANN'></span>

<h3>Description</h3>

<p>This function takes DIANN output containing a column with peptide sequences to be stripped
and converts it into a new dataframe with the stripped sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strip_sequence_DIANN(data, column, convert_column)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strip_sequence_DIANN_+3A_data">data</code></td>
<td>
<p>A dataframe with a column containing peptide sequences to be stripped</p>
</td></tr>
<tr><td><code id="strip_sequence_DIANN_+3A_column">column</code></td>
<td>
<p>The name of the column containing the peptide sequences to be stripped.</p>
</td></tr>
<tr><td><code id="strip_sequence_DIANN_+3A_convert_column">convert_column</code></td>
<td>
<p>The name of the column where the stripped sequences will be stored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with a column containing stripped sequence
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
data &lt;- data.table(
  Modified.Sequence = c(
    "AAAAGPGAALS(UniMod:21)PRPC(UniMod:4)DSDPATPGAQSPK",
    "AAAASAAEAGIATTGTEDSDDALLK",
    "AAAAALSGSPPQTEKPT(UniMod:21)HYR"
  ),
  Condition = c("A", "B", "B")
)
column &lt;- 'Modified.Sequence'
convert_column &lt;- 'Sequence'
converted_data &lt;- strip_sequence_DIANN(data, column, convert_column)

</code></pre>

<hr>
<h2 id='strip_sequence_Maxquant'>Strip sequence from Maxquant outputs</h2><span id='topic+strip_sequence_Maxquant'></span>

<h3>Description</h3>

<p>This function takes Maxquant output containing a column with peptide sequences to be stripped
and converts it into a new dataframe with the stripped sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strip_sequence_Maxquant(data, column, convert_column)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strip_sequence_Maxquant_+3A_data">data</code></td>
<td>
<p>A dataframe with a column containing peptide sequences to be stripped</p>
</td></tr>
<tr><td><code id="strip_sequence_Maxquant_+3A_column">column</code></td>
<td>
<p>The name of the column containing the peptide sequences to be stripped.</p>
</td></tr>
<tr><td><code id="strip_sequence_Maxquant_+3A_convert_column">convert_column</code></td>
<td>
<p>The name of the column where the stripped sequences will be stored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with a column containing stripped sequence
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
data &lt;- data.table(
  'Modified sequence' = c(
    "_(ac)AA(ox)AAELRLLEK_",
    "_EAAENSLVAYK_",
    "_AADTIGYPVM(ox)IRSAYALGGLGSGICPNK_"
  ),
  Condition = c("A", "B", "B")
)
column &lt;- 'Modified sequence'
convert_column &lt;- 'Sequence'
converted_data &lt;- strip_sequence_Maxquant(data, column, convert_column)

</code></pre>

<hr>
<h2 id='strip_sequence_MSFragger'>Strip sequence from MSFragger outputs</h2><span id='topic+strip_sequence_MSFragger'></span>

<h3>Description</h3>

<p>This function takes MSFragger output containing a column with peptide sequences to be stripped
and converts it into a new dataframe with the stripped sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strip_sequence_MSFragger(data, column, convert_column)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strip_sequence_MSFragger_+3A_data">data</code></td>
<td>
<p>A dataframe with a column containing peptide sequences to be stripped</p>
</td></tr>
<tr><td><code id="strip_sequence_MSFragger_+3A_column">column</code></td>
<td>
<p>The name of the column containing the peptide sequences to be stripped.</p>
</td></tr>
<tr><td><code id="strip_sequence_MSFragger_+3A_convert_column">convert_column</code></td>
<td>
<p>The name of the column where the stripped sequences will be stored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with a column containing stripped sequence
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
data &lt;- data.table(
  'Modified Peptide' = c(
    "AAM[15.9949]Q[-0.98]RGSLYQCDYSTGSC[57.02]EPIR",
    "K.AAQQTGKLVHANFGT.K",
    "K.[0.98]AATVTGKLVHANFGT.K"
  ),
  Condition = c("A", "B", "B")
)
column &lt;- 'Modified Peptide'
convert_column &lt;- 'Sequence'
converted_data &lt;- strip_sequence_MSFragger(data, 'Modified Peptide', 'Sequence')

</code></pre>

<hr>
<h2 id='strip_sequence_PEAKS'>Strip sequence from PEAKS outputs</h2><span id='topic+strip_sequence_PEAKS'></span>

<h3>Description</h3>

<p>This function takes PEAKS output containing a column with peptide sequences to be stripped
and converts it into a new dataframe with the stripped sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strip_sequence_PEAKS(data, column, convert_column)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strip_sequence_PEAKS_+3A_data">data</code></td>
<td>
<p>A dataframe with a column containing peptide sequences to be stripped</p>
</td></tr>
<tr><td><code id="strip_sequence_PEAKS_+3A_column">column</code></td>
<td>
<p>The name of the column containing the peptide sequences to be stripped.</p>
</td></tr>
<tr><td><code id="strip_sequence_PEAKS_+3A_convert_column">convert_column</code></td>
<td>
<p>The name of the column where the stripped sequences will be stored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with a column containing stripped sequence
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
data &lt;- data.table(
  Peptide = c(
    "AAN(+0.98)Q(-0.98)RGSLYQCDYSTGSC(+57.02)EPIR",
    "K.AAQQTGKLVHANFGT.K",
    "K.(+0.98)AATVTGKLVHANFGT.K"
  ),
  Condition = c("A", "B", "B")
)
column &lt;- "Peptide"
convert_column &lt;- "Sequence"
converted_data &lt;- strip_sequence_PEAKS(data, column, convert_column)

</code></pre>

<hr>
<h2 id='strip_sequence_Skyline'>Strip sequence from Skyline outputs</h2><span id='topic+strip_sequence_Skyline'></span>

<h3>Description</h3>

<p>This function takes Skyline output containing a column with peptide sequences to be stripped
and converts it into a new dataframe with the stripped sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strip_sequence_Skyline(data, column, convert_column)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strip_sequence_Skyline_+3A_data">data</code></td>
<td>
<p>A dataframe with a column containing peptide sequences to be stripped</p>
</td></tr>
<tr><td><code id="strip_sequence_Skyline_+3A_column">column</code></td>
<td>
<p>The name of the column containing the peptide sequences to be stripped.</p>
</td></tr>
<tr><td><code id="strip_sequence_Skyline_+3A_convert_column">convert_column</code></td>
<td>
<p>The name of the column where the stripped sequences will be stored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with a column containing stripped sequence
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
data &lt;- data.table(
  'Peptide Modified Sequence' = c(
    "AGLC[+57]QTFVYGGC[+57]R",
    "AAAASAAEAGIATTGTEDSDDALLK",
    "IVGGWEC[+57]EK"
  ),
  Condition = c("A", "B", "B")
)
column &lt;- 'Peptide Modified Sequence'
convert_column &lt;- 'Sequence'
converted_data &lt;- strip_sequence_Skyline(data, column, convert_column)

</code></pre>

<hr>
<h2 id='strip_sequence_Spectronaut'>Strip sequence from Spectronaut outputs</h2><span id='topic+strip_sequence_Spectronaut'></span>

<h3>Description</h3>

<p>This function takes Spectronaut output containing a column with peptide sequences to be stripped
and converts it into a new dataframe with the stripped sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strip_sequence_Spectronaut(data, column, convert_column)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strip_sequence_Spectronaut_+3A_data">data</code></td>
<td>
<p>A dataframe with a column containing peptide sequences to be stripped</p>
</td></tr>
<tr><td><code id="strip_sequence_Spectronaut_+3A_column">column</code></td>
<td>
<p>The name of the column containing the peptide sequences to be stripped.</p>
</td></tr>
<tr><td><code id="strip_sequence_Spectronaut_+3A_convert_column">convert_column</code></td>
<td>
<p>The name of the column where the stripped sequences will be stored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with a column containing stripped sequence
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
data &lt;- data.table(
  EG.IntPIMID = c(
    "_[+42]M[-16]DDREDLVYQAK_",
    "_EAAENSLVAYK_",
    "_IEAELQDIC[+57]NDVLELLDK_"
  ),
  Condition = c("A", "B", "B")
)
converted_data &lt;- strip_sequence_Spectronaut(data, 'EG.IntPIMID', 'Sequence')

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
