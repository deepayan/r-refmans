<!DOCTYPE html><html><head><title>Help for package sftime</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sftime}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bind'><p>Bind rows (features) of <code>sftime</code> objects</p></a></li>
<li><a href='#geos_binary_ops'><p>Geometric operations on pairs of simple feature geometry sets (including <code>sftime</code> objects)</p></a></li>
<li><a href='#geos_combine'><p>Combine or union feature geometries (including <code>sftime</code> objects)</p></a></li>
<li><a href='#is_sortable'><p>Checks whether a vector or list is sortable</p></a></li>
<li><a href='#plot.sftime'><p>Plots an  <code>sftime</code> object</p></a></li>
<li><a href='#print.sftime'><p>Prints an <code>sftime</code> object</p></a></li>
<li><a href='#st_as_sftime'><p>Convert a foreign object to an <code>sftime</code> object</p></a></li>
<li><a href='#st_cast'><p>Cast geometry to another type: either simplify, or cast explicitly</p></a></li>
<li><a href='#st_crop.sftime'><p>Crop an <code>sftime</code> object to a specific rectangle</p></a></li>
<li><a href='#st_geometry'><p>Drops the geometry column of <code>sftime</code> objects</p></a></li>
<li><a href='#st_join'><p>Spatial join, spatial filter for <code>sftime</code> objects</p></a></li>
<li><a href='#st_sftime'><p>Construct an <code>sftime</code> object from all its components</p></a></li>
<li><a href='#st_time'><p>Get, set, or replace time information</p></a></li>
<li><a href='#tidyverse'><p>'tidyverse' methods for <code>sftime</code> objects</p></a></li>
<li><a href='#transform.sftime'><p>Transform method for <code>sftime</code> objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Classes and Methods for Simple Feature Objects that Have a Time
Column</td>
</tr>
<tr>
<td>Description:</td>
<td>Classes and methods for spatial objects that have a registered time 
    column, in particular for irregular spatiotemporal data. The time column can 
    be of any type, but needs to be ordinal. Regularly laid out spatiotemporal 
    data (vector or raster data cubes) are handled by package 'stars'. </td>
</tr>
<tr>
<td>Version:</td>
<td>0.2-0</td>
</tr>
<tr>
<td>Depends:</td>
<td>sf (&ge; 1.0.7)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, spacetime, rmarkdown, dplyr (&ge; 0.8-3), trajectories
(&ge; 0.2.2), stars, ncmeta, tidyr, ggplot2, magrittr, sp, rlang</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/LICENSE-1.1">Apache License version 1.1</a> | <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License version 2.0</a> [expanded from: Apache License]</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Collate:</td>
<td>sftime.R init.R join.R plot.R st_cast.R st_geometry.R
st_time.R tidyverse.R bind.R crop.R geom-transformers.R</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-16 18:31:04 UTC; henni</td>
</tr>
<tr>
<td>Author:</td>
<td>Henning Teickner <a href="https://orcid.org/0000-0002-3993-1182"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Edzer Pebesma <a href="https://orcid.org/0000-0001-8049-7069"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  Benedikt Graeler <a href="https://orcid.org/0000-0001-5443-4304"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Henning Teickner &lt;henning.teickner@uni-muenster.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-17 08:50:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='bind'>Bind rows (features) of <code>sftime</code> objects</h2><span id='topic+bind'></span><span id='topic+rbind.sftime'></span><span id='topic+cbind.sftime'></span>

<h3>Description</h3>

<p>Bind rows (features) of <code>sftime</code> objects
</p>
<p>Bind columns (variables) of <code>sftime</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sftime'
rbind(..., deparse.level = 1)

## S3 method for class 'sftime'
cbind(..., deparse.level = 1, sf_column_name = NULL, tc_column_name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind_+3A_...">...</code></td>
<td>
<p>Objects to bind; note that for the <code>rbind</code> and <code>cbind</code> 
methods, all objects have to be of class <code>sftime</code>; see 
<code><a href="methods.html#topic+dotsMethods">dotsMethods</a></code>.</p>
</td></tr>
<tr><td><code id="bind_+3A_deparse.level">deparse.level</code></td>
<td>
<p>An integer value; see <code><a href="base.html#topic+rbind">rbind</a></code>.</p>
</td></tr>
<tr><td><code id="bind_+3A_sf_column_name">sf_column_name</code></td>
<td>
<p>Character value; specifies the active geometry column; 
passed on to <code><a href="#topic+st_sftime">st_sftime</a></code>.</p>
</td></tr>
<tr><td><code id="bind_+3A_tc_column_name">tc_column_name</code></td>
<td>
<p>Character value; specifies active time column; passed 
on to <code><a href="#topic+st_sftime">st_sftime</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both <code>rbind</code> and <code>cbind</code> have non-standard method dispatch 
(see <a href="base.html#topic+cbind">cbind</a>): the <code>rbind</code> or <code>cbind</code> method for 
<code>sftime</code> objects is only called when all arguments to be combined are of 
class <code>sftime</code>.
</p>
<p>If you need to <code>cbind</code> e.g. a <code>data.frame</code> to an <code>sf</code>, 
use <code><a href="base.html#topic+data.frame">data.frame</a></code> directly and use <code><a href="#topic+st_sftime">st_sftime</a></code> on its 
result, or use <code><a href="dplyr.html#topic+bind">bind_cols</a></code>; see examples.
</p>


<h3>Value</h3>

<p><code>rbind</code> combines all <code>sftime</code> objects in <code>...</code> 
row-wise and returns the combined <code>sftime</code> object.
</p>
<p><code>cbind</code> combines all <code>sftime</code> objects in <code>...</code> 
column-wise and returns the combined <code>sftime</code> object. When called with 
multiple <code>sftime</code> objects warns about multiple time and geometry columns 
present when the time and geometry columns to use are not specified by using 
arguments <code>tc_column_name</code> and <code>sf_column_name</code>; see also 
<a href="#topic+st_sftime">st_sftime</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g1 &lt;- st_sfc(st_point(1:2))
x1 &lt;- st_sftime(a = 3, geometry = g1, time = Sys.time())

g2 &lt;- st_sfc(st_point(c(4, 6)))
x2 &lt;- st_sftime(a = 4, geometry = g2, time = Sys.time())

rbind(x1, x2) # works because both tc1 and tc2 have the same class

## Not run: 
st_time(x2) &lt;- 1
rbind(x1, x2) # error because both tc1 and tc2 do not have the same class

## End(Not run)

cbind(x1, x2) 

if (require(dplyr))
  dplyr::bind_cols(x1, x2)
  
df &lt;- data.frame(x = 3)   
st_sftime(data.frame(x1, df))   
  
</code></pre>

<hr>
<h2 id='geos_binary_ops'>Geometric operations on pairs of simple feature geometry sets (including <code>sftime</code> objects)</h2><span id='topic+geos_binary_ops'></span><span id='topic+st_intersection.sftime'></span><span id='topic+st_difference.sftime'></span><span id='topic+st_sym_difference.sftime'></span>

<h3>Description</h3>

<p>Geometric operations on pairs of simple feature geometry sets (including <code>sftime</code> objects)
</p>
<p>Intersection
</p>
<p>Difference
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sftime'
st_intersection(x, y, ...)

## S3 method for class 'sftime'
st_difference(x, y, ...)

## S3 method for class 'sftime'
st_sym_difference(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geos_binary_ops_+3A_x">x</code></td>
<td>
<p>object of class <code>sftime</code>, <code>sf</code>, <code>sfc</code> or <code>sfg</code>.</p>
</td></tr>
<tr><td><code id="geos_binary_ops_+3A_y">y</code></td>
<td>
<p>object of class <code>sftime</code>, <code>sf</code>, <code>sfc</code> or <code>sfg</code>.</p>
</td></tr>
<tr><td><code id="geos_binary_ops_+3A_...">...</code></td>
<td>
<p>See <code><a href="sf.html#topic+geos_binary_ops">geos_binary_ops</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>st_intersection</code>: When called with a missing <code>y</code>, the 
<code>sftime</code> method for <code>st_intersection</code> returns an <code>sftime</code> 
object with attributes taken from the contributing feature with lowest index; 
two fields are added: 
</p>

<dl>
<dt><code>n.overlaps</code></dt><dd><p>The number of overlapping features in <code>x</code>.</p>
</dd>
<dt><code>origins</code></dt><dd><p>A list-column with indexes of all overlapping 
features.</p>
</dd>
</dl>

<p><code>st_difference</code>: When <code>st_difference</code> is called with a 
single argument, overlapping areas are erased from geometries that are 
indexed at greater numbers in the argument to <code>x</code>; geometries that are 
empty or contained fully inside geometries with higher priority are removed 
entirely.
</p>


<h3>Value</h3>

<p>The intersection, difference or symmetric difference between two sets 
of geometries.
The returned object has the same class as that of the first argument 
(<code>x</code>) with the non-empty geometries resulting from applying the 
operation to all geometry pairs in <code>x</code> and <code>y</code>. In case <code>x</code> 
is of class <code>sf</code> or <code>sftime</code>, the matching attributes of the 
original object(s) are added. The <code>sfc</code> geometry list-column returned 
carries an attribute <code>idx</code>, which is an <code>n</code>-by-2 matrix with every 
row the index of the corresponding entries of <code>x</code> and <code>y</code>, 
respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- st_sfc(st_point(c(1, 2)), st_point(c(1, 3)), st_point(c(2, 3)), 
     st_point(c(2, 1)), st_point(c(3, 1)))
tc &lt;- Sys.time() + 1:5
x1 &lt;- st_sftime(a = 1:5, g, time = tc)
x2 &lt;- st_buffer(x1, dist = 1)

## intersection

# only x provided (no y)
plot(st_intersection(x2))

# with arguments x and y provided
plot(st_intersection(x2, x1))

## difference

# only x provided (no y)
plot(st_difference(x2))

# with arguments x and y provided
plot(st_difference(x2, x1))

## symmetric difference
plot(st_sym_difference(x1, x2))

</code></pre>

<hr>
<h2 id='geos_combine'>Combine or union feature geometries (including <code>sftime</code> objects)</h2><span id='topic+geos_combine'></span><span id='topic+st_union.sftime'></span>

<h3>Description</h3>

<p>Combine or union feature geometries (including <code>sftime</code> objects)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sftime'
st_union(x, y, ..., by_feature = FALSE, is_coverage = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geos_combine_+3A_x">x</code></td>
<td>
<p>An object of class <code>sftime</code>, <code>sf</code>, <code>sfc</code> or 
<code>sfg</code>.</p>
</td></tr>
<tr><td><code id="geos_combine_+3A_y">y</code></td>
<td>
<p>An object of class <code>sftime</code>, <code>sf</code>, <code>sfc</code> or 
<code>sfg</code> (optional).</p>
</td></tr>
<tr><td><code id="geos_combine_+3A_...">...</code></td>
<td>
<p>See <code><a href="sf.html#topic+geos_combine">geos_combine</a></code>.</p>
</td></tr>
<tr><td><code id="geos_combine_+3A_by_feature">by_feature</code></td>
<td>
<p>See <code><a href="sf.html#topic+geos_combine">geos_combine</a></code>.</p>
</td></tr>
<tr><td><code id="geos_combine_+3A_is_coverage">is_coverage</code></td>
<td>
<p>See <code><a href="sf.html#topic+geos_combine">geos_combine</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="sf.html#topic+geos_combine">geos_combine</a></code>.
</p>


<h3>Value</h3>

<p>If <code>y</code> is missing, <code>st_union(x)</code> returns a single geometry 
with resolved boundaries, else the geometries for all unioned pairs of 
<code>x[i]</code> and <code>y[j]</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># union simple features in an sftime object
g &lt;- st_sfc(st_point(c(1, 2)), st_point(c(1, 3)), st_point(c(2, 3)), 
     st_point(c(2, 1)), st_point(c(3, 1)))
tc &lt;- Sys.time() + 1:5
x &lt;- st_sftime(a = 1:5, g, time = tc)

# only x provided (no y)
plot(st_union(st_buffer(x, dist = 1)))

# with arguments x and y provided
plot(st_union(st_buffer(x, dist = 1), st_buffer(x, dist = 0.5)), "a")

</code></pre>

<hr>
<h2 id='is_sortable'>Checks whether a vector or list is sortable</h2><span id='topic+is_sortable'></span>

<h3>Description</h3>

<p>Checks whether a vector or list is sortable. This is the condition for a 
vector to be usable as time column in a <code>sftime</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_sortable(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_sortable_+3A_x">x</code></td>
<td>
<p>The object to check.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Checks whether the provided object can be handled by 
<code><a href="base.html#topic+order">order</a></code>. A couple of basic types are whitelisted. However, custom 
types can be defined when they provide a dedicated generic to <a href="base.html#topic+xtfrm">xtfrm</a>. 
Note that a <code>list</code> can only be sorted with <a href="base.html#topic+atomic">atomic</a> values. See the 
examples below for a template.
</p>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> passes the check, else <code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Sys.time() + 5:1 * 3600 * 24
sort(x)
is_sortable(x)

</code></pre>

<hr>
<h2 id='plot.sftime'>Plots an  <code>sftime</code> object</h2><span id='topic+plot.sftime'></span><span id='topic+plot'></span>

<h3>Description</h3>

<p><code>plot.sftime</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sftime'
plot(x, y, ..., number = 6, tcuts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sftime_+3A_x">x</code></td>
<td>
<p>The <code><a href="#topic+st_sftime">sftime</a></code> object to be plotted.</p>
</td></tr>
<tr><td><code id="plot.sftime_+3A_y">y</code></td>
<td>
<p>A character value; The variable name to be plotted; if missing, the 
first variable is plotted.</p>
</td></tr>
<tr><td><code id="plot.sftime_+3A_...">...</code></td>
<td>
<p>Additional arguments; Passed on to <code><a href="sf.html#topic+plot">plot.sf</a></code>.</p>
</td></tr>
<tr><td><code id="plot.sftime_+3A_number">number</code></td>
<td>
<p>A numeric value; The number of panels to be plotted, cannot be 
larger than the number of timestamps; ignored when <code>tcuts</code> is provided.</p>
</td></tr>
<tr><td><code id="plot.sftime_+3A_tcuts">tcuts</code></td>
<td>
<p>predefined temporal ranges assigned to each map; if missing, 
will be determined as equal spans according to <code>number</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>NULL</code> and creates as side effect a plot for <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
coords &lt;- matrix(runif(100), ncol = 2)
g &lt;- st_sfc(lapply(1:50, function(i) st_point(coords[i, ]) ))
sft &lt;- st_sftime(a = 1:50, g, time = as.POSIXct("2020-09-01 00:00:00") + 0:49 * 3600 * 6)

plot(sft)

</code></pre>

<hr>
<h2 id='print.sftime'>Prints an <code>sftime</code> object</h2><span id='topic+print.sftime'></span>

<h3>Description</h3>

<p>Prints an <code>sftime</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sftime'
print(x, ..., n = getOption("sf_max_print", default = 10))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.sftime_+3A_x">x</code></td>
<td>
<p>An object of class <code>sftime</code>.</p>
</td></tr>
<tr><td><code id="print.sftime_+3A_...">...</code></td>
<td>
<p>Currently unused arguments, for compatibility.</p>
</td></tr>
<tr><td><code id="print.sftime_+3A_n">n</code></td>
<td>
<p>Numeric value; maximum number of printed elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> (invisible).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- st_sfc(st_point(c(1, 2)), st_point(c(1, 3)), st_point(c(2, 3)), 
     st_point(c(2, 1)), st_point(c(3, 1)))
tc &lt;- Sys.time() + 1:5
x &lt;- st_sftime(a = 1:5, g, time = tc)
print(x)
print(x[0, ])

</code></pre>

<hr>
<h2 id='st_as_sftime'>Convert a foreign object to an <code>sftime</code> object</h2><span id='topic+st_as_sftime'></span><span id='topic+st_as_sftime.ST'></span><span id='topic+st_as_sftime.Track'></span><span id='topic+st_as_sftime.Tracks'></span><span id='topic+st_as_sftime.TracksCollection'></span><span id='topic+st_as_sftime.sftime'></span><span id='topic+st_as_sftime.sf'></span><span id='topic+st_as_sftime.stars'></span><span id='topic+st_as_sftime.data.frame'></span>

<h3>Description</h3>

<p>Convert a foreign object to an <code>sftime</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_as_sftime(x, ...)

## S3 method for class 'ST'
st_as_sftime(x, ...)

## S3 method for class 'Track'
st_as_sftime(x, ...)

## S3 method for class 'Tracks'
st_as_sftime(x, ...)

## S3 method for class 'TracksCollection'
st_as_sftime(x, ...)

## S3 method for class 'sftime'
st_as_sftime(x, ...)

## S3 method for class 'sf'
st_as_sftime(x, ..., time_column_name = NULL)

## S3 method for class 'stars'
st_as_sftime(x, ..., long = TRUE, time_column_name = NULL)

## S3 method for class 'data.frame'
st_as_sftime(
  x,
  ...,
  agr = NA_agr_,
  coords,
  wkt,
  dim = "XYZ",
  remove = TRUE,
  na.fail = TRUE,
  sf_column_name = NULL,
  time_column_name = NULL,
  time_column_last = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_as_sftime_+3A_x">x</code></td>
<td>
<p>An object to be converted into an object of class 
<code><a href="#topic+st_sftime">sftime</a></code>.</p>
</td></tr>
<tr><td><code id="st_as_sftime_+3A_...">...</code></td>
<td>
<p>Further arguments passed to methods.</p>
</td></tr>
<tr><td><code id="st_as_sftime_+3A_time_column_name">time_column_name</code></td>
<td>
<p>A character value; name of the active time column. In 
case there is more than one and <code>time_column_name</code> is <code>NULL</code>, the 
first one is taken.</p>
</td></tr>
<tr><td><code id="st_as_sftime_+3A_long">long</code></td>
<td>
<p>A logical value; See <code><a href="stars.html#topic+st_as_sf">st_as_sf</a></code>. 
Typically, <code>long</code> should be set to <code>TRUE</code> since time information
typically is a dimension of a stars object.</p>
</td></tr>
<tr><td><code id="st_as_sftime_+3A_agr">agr</code></td>
<td>
<p>A character vector; see details section of <code><a href="sf.html#topic+st_sf">st_sf</a></code>.</p>
</td></tr>
<tr><td><code id="st_as_sftime_+3A_coords">coords</code></td>
<td>
<p>In case of point data: names or numbers of the numeric columns 
holding coordinates.</p>
</td></tr>
<tr><td><code id="st_as_sftime_+3A_wkt">wkt</code></td>
<td>
<p>The name or number of the character column that holds WKT encoded 
geometries.</p>
</td></tr>
<tr><td><code id="st_as_sftime_+3A_dim">dim</code></td>
<td>
<p>Passed on to <code><a href="sf.html#topic+st_point">st_point</a></code> (only when argument 
<code>coords</code> is given).</p>
</td></tr>
<tr><td><code id="st_as_sftime_+3A_remove">remove</code></td>
<td>
<p>A logical value; when <code>coords</code> or <code>wkt</code> is given, 
remove these columns from codedata.frame?</p>
</td></tr>
<tr><td><code id="st_as_sftime_+3A_na.fail">na.fail</code></td>
<td>
<p>A logical value; if <code>TRUE</code>, raise an error if coordinates 
contain missing values.</p>
</td></tr>
<tr><td><code id="st_as_sftime_+3A_sf_column_name">sf_column_name</code></td>
<td>
<p>A character value; name of the active list-column with 
simple feature geometries; in case there is more than one and 
<code>sf_column_name</code> is <code>NULL</code>, the first one is taken.</p>
</td></tr>
<tr><td><code id="st_as_sftime_+3A_time_column_last">time_column_last</code></td>
<td>
<p>A logical value; if <code>TRUE</code>, the active time column is 
always put last, otherwise column order is left unmodified. If both <code>sfc_last</code>
and <code>time_column_last</code> are <code>TRUE</code>, the active time column is put last.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> converted to an <code>sftime</code> object.
</p>
<p><code>st_as_sftime.Tracks</code> furthermore adds a column 
<code>track_name</code> with the names of the <code>tracks</code> slot of the input
<code>Tracks</code> object.
</p>
<p><code>st_as_sftime.TracksCollection</code> furthermore adds the columns 
<code>tracks_name</code> with the names of the <code>tracksCollection</code> slot and 
<code>track_name</code> with the names of the <code>tracks</code> slot of the input
<code>Tracks</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># modified from spacetime:
library(sp)
library(spacetime)

sp &lt;- cbind(x = c(0,0,1), y = c(0,1,1))
row.names(sp) &lt;- paste("point", 1:nrow(sp), sep="")
sp &lt;- SpatialPoints(sp)
time &lt;- as.POSIXct("2010-08-05") + 3600 * (10:12)
x &lt;- STI(sp, time)

st_as_sftime(x)

# convert a Track object from package trajectories to an sftime object
library(trajectories)
x1_Track &lt;- trajectories::rTrack(n = 100)
x1_Track@data$speed &lt;- sort(rnorm(length(x1_Track)))
x1_sftime &lt;- st_as_sftime(x1_Track)

# convert a Tracks object from package trajectories to an sftime object
x2_Tracks &lt;- trajectories::rTracks(m = 6)
x2_sftime &lt;- st_as_sftime(x2_Tracks)

# convert a TracksCollection object from package trajectories to an sftime object
x3_TracksCollection &lt;- trajectories::rTracksCollection(p = 2, m = 3, n = 50)
x3_sftime &lt;- st_as_sftime(x3_TracksCollection)

# convert an sftime object to an sftime object
st_as_sftime(x3_sftime)
  
# convert an sf object to an sftime object
g &lt;- st_sfc(st_point(c(1, 2)), st_point(c(1, 3)), st_point(c(2, 3)), 
     st_point(c(2, 1)), st_point(c(3, 1)))
x4_sf &lt;- st_sf(a = 1:5, g, time = Sys.time() + 1:5)
x4_sftime &lt;- st_as_sftime(x4_sf) 

# convert a Tracks object from package trajectories to an sftime object
x5_stars &lt;- stars::read_stars(system.file("nc/bcsd_obs_1999.nc", package = "stars"))
x5_sftime &lt;- st_as_sftime(x5_stars, time_column_name = "time")

# this requires some thought to not accidentally drop time dimensions. For
# example, setting `merge = TRUE` will drop the time dimension and thus throw
# an error:
## Not run: 
x5_sftime &lt;- st_as_sftime(x5_stars, merge = TRUE, time_column_name = "time")

## End(Not run)

# convert a data frame to an sftime object
x5_df &lt;- 
   data.frame(a = 1:5, g, time = Sys.time() + 1:5, stringsAsFactors = FALSE)
x5_sftime &lt;- st_as_sftime(x5_df)

</code></pre>

<hr>
<h2 id='st_cast'>Cast geometry to another type: either simplify, or cast explicitly</h2><span id='topic+st_cast'></span><span id='topic+st_cast.sftime'></span>

<h3>Description</h3>

<p>Cast geometry to another type: either simplify, or cast explicitly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sftime'
st_cast(x, to, ..., warn = TRUE, do_split = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_cast_+3A_x">x</code></td>
<td>
<p>An object of class <code>sftime</code>.</p>
</td></tr>
<tr><td><code id="st_cast_+3A_to">to</code></td>
<td>
<p>character; target type, if missing, simplification is tried; when <code>x</code> is of type <code>sfg</code> (i.e., a single geometry) then <code>to</code> needs to be specified.</p>
</td></tr>
<tr><td><code id="st_cast_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="st_cast_+3A_warn">warn</code></td>
<td>
<p>logical; if <code>TRUE</code>, warn if attributes are assigned to sub-geometries</p>
</td></tr>
<tr><td><code id="st_cast_+3A_do_split">do_split</code></td>
<td>
<p>logical; if <code>TRUE</code>, allow splitting of geometries in sub-geometries</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> with changed geometry type.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># cast from POINT to LINESTRING
g &lt;- st_sfc(st_point(1:2), st_point(c(2, 4)))
time &lt;- Sys.time()
x &lt;- 
  st_sftime(a = 3:4, g, time = time) %&gt;%
  dplyr::group_by(time) %&gt;%
  dplyr::summarize(do_union = TRUE) %&gt;%
  st_cast(to = "LINESTRING")
</code></pre>

<hr>
<h2 id='st_crop.sftime'>Crop an <code>sftime</code> object to a specific rectangle</h2><span id='topic+st_crop.sftime'></span>

<h3>Description</h3>

<p>Crop an <code>sftime</code> object to a specific rectangle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sftime'
st_crop(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_crop.sftime_+3A_x">x</code></td>
<td>
<p>An object of class <code>sftime</code>.</p>
</td></tr>
<tr><td><code id="st_crop.sftime_+3A_y">y</code></td>
<td>
<p>A numeric vector with named elements <code>xmin</code>, <code>ymin</code>, 
<code>xmax</code> and <code>ymax</code>, or an object of class <code>bbox</code>, or an object 
for which there is an <code><a href="sf.html#topic+st_bbox">st_bbox</a></code> method to convert it 
to a <code>bbox</code> object.</p>
</td></tr>
<tr><td><code id="st_crop.sftime_+3A_...">...</code></td>
<td>
<p>Additional arguments; Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="sf.html#topic+st_crop">st_crop</a></code>.
</p>


<h3>Value</h3>

<p><code>x</code> cropped using <code>y</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># modified from sf:
box &lt;- c(xmin = 0, ymin = 0, xmax = 1, ymax = 1)
pol &lt;- sf::st_sfc(sf::st_buffer(sf::st_point(c(0.5, 0.5)), 0.6))
pol_sftime &lt;- st_sftime(a = 1, geom = pol, time = Sys.time() + 1:2 * 1000)

pol_sftime_cropped &lt;- sf::st_crop(pol_sftime, sf::st_bbox(box))

class(pol_sftime_cropped)
plot(pol_sftime_cropped)
</code></pre>

<hr>
<h2 id='st_geometry'>Drops the geometry column of <code>sftime</code> objects</h2><span id='topic+st_geometry'></span><span id='topic+st_drop_geometry.sftime'></span>

<h3>Description</h3>

<p>Drops the geometry column of an <code>sftime</code> object. This will also drop 
the <code>sftime</code> class attribute and <code>time_column</code> attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sftime'
st_drop_geometry(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_geometry_+3A_x">x</code></td>
<td>
<p>An <code>sftime</code> object.</p>
</td></tr>
<tr><td><code id="st_geometry_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> without geometry column and without <code>sftime</code> and 
<code>sf</code> class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># dropping the geometry column will also drop the `sftime` class:
g &lt;- st_sfc(st_point(1:2))
time &lt;- Sys.time()
x &lt;- st_sftime(a = 3, g, time = time)
st_drop_geometry(x)

</code></pre>

<hr>
<h2 id='st_join'>Spatial join, spatial filter for <code>sftime</code> objects</h2><span id='topic+st_join'></span><span id='topic+st_join.sftime'></span><span id='topic+st_filter.sftime'></span>

<h3>Description</h3>

<p>Spatial join, spatial filter for <code>sftime</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sftime'
st_join(
  x,
  y,
  join = st_intersects,
  ...,
  suffix = c(".x", ".y"),
  left = TRUE,
  largest = FALSE
)

## S3 method for class 'sftime'
st_filter(x, y, ..., .predicate = st_intersects)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_join_+3A_x">x</code></td>
<td>
<p>An object of class <code>sftime</code> or <code>sf</code>.</p>
</td></tr>
<tr><td><code id="st_join_+3A_y">y</code></td>
<td>
<p>An object of class <code>sftime</code> or <code>sf</code>.</p>
</td></tr>
<tr><td><code id="st_join_+3A_join">join</code></td>
<td>
<p>A geometry predicate function with the same profile as 
<code><a href="sf.html#topic+geos_binary_pred">st_intersects</a></code>; see details.</p>
</td></tr>
<tr><td><code id="st_join_+3A_...">...</code></td>
<td>
<p>for <code>st_join</code>: arguments passed on to the <code>join</code> function or to <code>st_intersection</code> when <code>largest</code> is <code>TRUE</code>; for <code>st_filter</code> arguments passed on to the <code>.predicate</code> function, e.g. <code>prepared</code>, or a pattern for <a href="sf.html#topic+st_relate">st_relate</a></p>
</td></tr>
<tr><td><code id="st_join_+3A_suffix">suffix</code></td>
<td>
<p>length 2 character vector; see <a href="base.html#topic+merge">merge</a></p>
</td></tr>
<tr><td><code id="st_join_+3A_left">left</code></td>
<td>
<p>logical; if <code>TRUE</code> return the left join, otherwise an inner join; see details.
see also <a href="dplyr.html#topic+mutate-joins">left_join</a></p>
</td></tr>
<tr><td><code id="st_join_+3A_largest">largest</code></td>
<td>
<p>logical; if <code>TRUE</code>, return <code>x</code> features augmented with the fields of <code>y</code> that have the largest overlap with each of the features of <code>x</code>; see https://github.com/r-spatial/sf/issues/578</p>
</td></tr>
<tr><td><code id="st_join_+3A_.predicate">.predicate</code></td>
<td>
<p>A geometry predicate function with the same profile as 
<code><a href="sf.html#topic+geos_binary_pred">st_intersects</a></code>; see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Alternative values for argument <code>join</code> are:
</p>

<ul>
<li> <p><a href="sf.html#topic+geos_binary_pred">st_contains_properly</a>
</p>
</li>
<li> <p><a href="sf.html#topic+geos_binary_pred">st_contains</a>
</p>
</li>
<li> <p><a href="sf.html#topic+geos_binary_pred">st_covered_by</a>
</p>
</li>
<li> <p><a href="sf.html#topic+geos_binary_pred">st_covers</a>
</p>
</li>
<li> <p><a href="sf.html#topic+geos_binary_pred">st_crosses</a>
</p>
</li>
<li> <p><a href="sf.html#topic+geos_binary_pred">st_disjoint</a>
</p>
</li>
<li> <p><a href="sf.html#topic+geos_binary_pred">st_equals_exact</a>
</p>
</li>
<li> <p><a href="sf.html#topic+geos_binary_pred">st_equals</a>
</p>
</li>
<li> <p><a href="sf.html#topic+geos_binary_pred">st_is_within_distance</a>
</p>
</li>
<li> <p><a href="sf.html#topic+geos_binary_pred">st_nearest_feature</a>
</p>
</li>
<li> <p><a href="sf.html#topic+geos_binary_pred">st_overlaps</a>
</p>
</li>
<li> <p><a href="sf.html#topic+geos_binary_pred">st_touches</a>
</p>
</li>
<li> <p><a href="sf.html#topic+geos_binary_pred">st_within</a>
</p>
</li>
<li><p> any user-defined function of the same profile as the above
</p>
</li></ul>

<p>A left join returns all records of the <code>x</code> object with <code>y</code> fields 
for non-matched records filled with <code>NA</code> values; an inner join returns 
only records that spatially match.
</p>


<h3>Value</h3>

<p>An object of class <code>sftime</code>, joined based on geometry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g1 &lt;- st_sfc(st_point(c(1,1)), st_point(c(2,2)), st_point(c(3,3)))
x1 &lt;- st_sftime(a = 1:3, geometry = g1, time = Sys.time())

g2 &lt;- st_sfc(st_point(c(10,10)), st_point(c(2,2)), st_point(c(2,2)), st_point(c(3,3)))
x2 &lt;- st_sftime(a = 11:14, geometry = g2, time = Sys.time())

## st_join

# left spatial join with st_intersects
st_join(x1, x2)

# inner spatial join with st_intersects
st_join(x1, x2, left = FALSE)

## st_filter

st_filter(x1, x2)
st_filter(x2, x1)

</code></pre>

<hr>
<h2 id='st_sftime'>Construct an <code>sftime</code> object from all its components</h2><span id='topic+st_sftime'></span><span id='topic++5B.sftime'></span><span id='topic++5B+5B+3C-.sftime'></span><span id='topic++24+3C-.sftime'></span>

<h3>Description</h3>

<p>Construct an <code>sftime</code> object from all its components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_sftime(
  ...,
  agr = sf::NA_agr_,
  row.names,
  stringsAsFactors = TRUE,
  crs,
  precision,
  sf_column_name = NULL,
  time_column_name = NULL,
  check_ring_dir = FALSE,
  sfc_last = TRUE,
  time_column_last = TRUE
)

## S3 method for class 'sftime'
x[i, j, ..., drop = FALSE, op = sf::st_intersects]

## S3 replacement method for class 'sftime'
x[[i]] &lt;- value

## S3 replacement method for class 'sftime'
x$i &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_sftime_+3A_...">...</code></td>
<td>
<p>Column elements to be binded into an <code>sftime</code> object or a 
single <code>list</code> or <code>data.frame</code> with such columns. At least one of 
these columns shall be a geometry list-column of class <code>sfc</code> and one 
shall be a time column (to be specified with <code>time_column_name</code>).</p>
</td></tr>
<tr><td><code id="st_sftime_+3A_agr">agr</code></td>
<td>
<p>A character vector; see details below.</p>
</td></tr>
<tr><td><code id="st_sftime_+3A_row.names">row.names</code></td>
<td>
<p>row.names for the created <code>sf</code> object.</p>
</td></tr>
<tr><td><code id="st_sftime_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>A logical value; see 
<code><a href="sf.html#topic+st_read">st_read</a></code>.</p>
</td></tr>
<tr><td><code id="st_sftime_+3A_crs">crs</code></td>
<td>
<p>Coordinate reference system, something suitable as input to 
<code><a href="sf.html#topic+st_crs">st_crs</a></code>.</p>
</td></tr>
<tr><td><code id="st_sftime_+3A_precision">precision</code></td>
<td>
<p>A numeric value; see 
<code><a href="sf.html#topic+st_as_binary">st_as_binary</a></code>.</p>
</td></tr>
<tr><td><code id="st_sftime_+3A_sf_column_name">sf_column_name</code></td>
<td>
<p>A character value; name of the active list-column with 
simple feature geometries; in case there is more than one and 
<code>sf_column_name</code> is <code>NULL</code>, the first one is taken.</p>
</td></tr>
<tr><td><code id="st_sftime_+3A_time_column_name">time_column_name</code></td>
<td>
<p>A character value; name of the active 
time column. In case <code>time_column_name</code> is <code>NULL</code>, the first 
<code><a href="base.html#topic+POSIXct">POSIXct</a></code> column is taken. If there is no <code>POSIXct</code> column,
the first <code><a href="base.html#topic+Date">Date</a></code> column is taken.</p>
</td></tr>
<tr><td><code id="st_sftime_+3A_check_ring_dir">check_ring_dir</code></td>
<td>
<p>A logical value; see <code><a href="sf.html#topic+st_read">st_read</a></code>.</p>
</td></tr>
<tr><td><code id="st_sftime_+3A_sfc_last">sfc_last</code></td>
<td>
<p>A logical value; if <code>TRUE</code>, <code>sfc</code> columns are 
always put last, otherwise column order is left unmodified.</p>
</td></tr>
<tr><td><code id="st_sftime_+3A_time_column_last">time_column_last</code></td>
<td>
<p>A logical value; if <code>TRUE</code>, the active time column is 
always put last, otherwise column order is left unmodified. If both <code>sfc_last</code>
and <code>time_column_last</code> are <code>TRUE</code>, the active time column is put last.</p>
</td></tr>
<tr><td><code id="st_sftime_+3A_x">x</code></td>
<td>
<p>An object of class <code>sf</code>.</p>
</td></tr>
<tr><td><code id="st_sftime_+3A_i">i</code></td>
<td>
<p>Record selection, see <a href="base.html#topic++5B.data.frame">[.data.frame</a></p>
</td></tr>
<tr><td><code id="st_sftime_+3A_j">j</code></td>
<td>
<p>Variable selection, see <a href="base.html#topic++5B.data.frame">[.data.frame</a></p>
</td></tr>
<tr><td><code id="st_sftime_+3A_drop">drop</code></td>
<td>
<p>A logical value, default <code>FALSE</code>; if <code>TRUE</code> drop the 
geometry column and return a <code>data.frame</code>, else make the geometry sticky 
and return an <code>sf</code> object.</p>
</td></tr>
<tr><td><code id="st_sftime_+3A_op">op</code></td>
<td>
<p>A function; geometrical binary predicate function to apply when 
<code>i</code> is a simple feature object.</p>
</td></tr>
<tr><td><code id="st_sftime_+3A_value">value</code></td>
<td>
<p>An object to insert into <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See also <a href="base.html#topic++5B.data.frame">[.data.frame</a>; for <code>[.sftime</code> <code>...</code> 
arguments are passed to <code>op</code>.
</p>


<h3>Value</h3>

<p><code>st_sftime</code>: An object of class <code>sftime</code>.
</p>
<p>Returned objects for subsetting functions: <code>[.sf</code> will return a 
<code>data.frame</code> or vector if the geometry column (of class <code>sfc</code>) is 
dropped (<code>drop=TRUE</code>), an <code>sfc</code> object if only the geometry column 
is selected, and otherwise return an <code>sftime</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## construction with an sfc object
library(sf)
g &lt;- st_sfc(st_point(1:2))
tc &lt;- Sys.time()
st_sftime(a = 3, g, time = tc)

## construction with an sf object
## Not run: 
st_sftime(st_sf(a = 3, g), time = tc) 
# error, because if ... contains a data.frame-like object, no other objects 
# may be passed through ... . Instead, add the time column before.

## End(Not run)

st_sftime(st_sf(a = 3, g, time = tc))

## Subsetting
g &lt;- st_sfc(st_point(c(1, 2)), st_point(c(1, 3)), st_point(c(2, 3)), 
     st_point(c(2, 1)), st_point(c(3, 1)))
tc &lt;- Sys.time() + 1:5
x &lt;- st_sftime(a = 1:5, g, time = tc)

# rows
x[1, ]
class(x[1, ])

x[x$a &lt; 3, ]
class(x[x$a &lt; 3, ])

# columns
x[, 1]
class(x[, 1]) # drops time column as for ordinary data.frame subsetting, 
# keeps geometry column of sf object

x[, 3]
class(x[, 3]) # keeps time column because it is explicitly selected,
# keeps geometry column of sf object, returns an sftime object

x[, 3, drop = TRUE] 
class(x[, 3, drop = TRUE]) # if the geometry column is dropped, not only the
# sf class is dropped, but also the sftime class

x["a"]
class(x["a"]) # Time columns are not sticky: If a column is selected by a 
# character vector and this does not contain the active time column, the time 
# column is dropped. 

x[c("a", "time")]
class(x[c("a", "time")]) # keeps the time column

# with sf or sftime object 
pol = st_sfc(st_polygon(list(cbind(c(0,2,2,0,0),c(0,0,2,2,0)))))
h = st_sf(r = 5, pol)

x[h, ] 
class(x[h, ]) # returns sftime object

h[x, ] 
class(h[x, ]) # returns sf object

## Assigning values to columns

# assigning new values to a non-time column
x[["a"]] &lt;- 5:1
class(x)

# assigning allowed new values to the time column
x[["time"]] &lt;- Sys.time() + 1:5
class(x)

# assigning new values to the time column which invalidate the time column
x[["time"]] &lt;- list(letters[1:2])
class(x)

# assigning new values with `$`
x$time &lt;- Sys.time() + 1:5
class(x)

</code></pre>

<hr>
<h2 id='st_time'>Get, set, or replace time information</h2><span id='topic+st_time'></span><span id='topic+st_time+3C-'></span><span id='topic+st_time.sftime'></span><span id='topic+st_time+3C-.sf'></span><span id='topic+st_time+3C-.sftime'></span><span id='topic+st_set_time'></span><span id='topic+st_drop_time'></span>

<h3>Description</h3>

<p>Get, set, or replace time information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_time(obj, ...)

st_time(x, ...) &lt;- value

## S3 method for class 'sftime'
st_time(obj, ...)

## S3 replacement method for class 'sf'
st_time(x, ..., time_column_name = "time") &lt;- value

## S3 replacement method for class 'sftime'
st_time(x, ...) &lt;- value

st_set_time(x, value, ...)

st_drop_time(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_time_+3A_obj">obj</code></td>
<td>
<p>An object of class <code>sftime</code>.</p>
</td></tr>
<tr><td><code id="st_time_+3A_...">...</code></td>
<td>
<p>Additional arguments; Ignored.</p>
</td></tr>
<tr><td><code id="st_time_+3A_x">x</code></td>
<td>
<p>An object of class <code>sftime</code> or <code>sf</code>.</p>
</td></tr>
<tr><td><code id="st_time_+3A_value">value</code></td>
<td>
<p>An object for which <code><a href="#topic+is_sortable">is_sortable</a></code> returns 
<code>TRUE</code> or an object of class <code>character</code>, or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="st_time_+3A_time_column_name">time_column_name</code></td>
<td>
<p>Character value; The name of the column to set as 
active time column in <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case <code>value</code> is character and <code>x</code> is of class 
<code>sftime</code>, the active time column (as indicated by attribute 
<code>time_column</code>) is set to <code>x[[value]]</code>.
</p>
<p>The replacement function applied to <code>sftime</code> objects will overwrite the 
active time column, if <code>value</code> is <code>NULL</code>, it will remove it and 
coerce <code>x</code> to an <code>sftime</code> object.
</p>
<p><code>st_drop_time</code> drops the time column of its argument, and 
reclasses it accordingly.
</p>


<h3>Value</h3>

<p><code>st_time</code> returns the content of the active time column of an
<code>sftime</code> object. 
Assigning an object for which <code><a href="#topic+is_sortable">is_sortable</a></code> returns <code>TRUE</code> 
to an <code>sf</code> object creates an <code><a href="#topic+st_sftime">sftime</a></code> object. 
Assigning an object for which <code><a href="#topic+is_sortable">is_sortable</a></code> returns <code>TRUE</code> 
to an <code>sftime</code> object replaces the active time column by this object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># from sftime object
g &lt;- st_sfc(st_point(1:2))
time &lt;- Sys.time()
x &lt;- st_sftime(a = 3, g, time = time)
st_time(x) 

## assign a vector with time information

# to sf object
x &lt;- st_sf(a = 3, g)
st_time(x) &lt;- time
x

# to sftime object
x &lt;- st_sftime(a = 3, g, time = time)
st_time(x) &lt;- Sys.time()

## remove time column from sftime object
st_time(x) &lt;- NULL

## pipe-friendly

# assign time column to sf object
x &lt;- st_sf(a = 3, g)
x &lt;- st_set_time(x, time)

# remove time column from sftime object
st_set_time(x, NULL)

## drop time column and class

# same as x &lt;- st_set_time(x, NULL)
st_drop_time(x)

</code></pre>

<hr>
<h2 id='tidyverse'>'tidyverse' methods for <code>sftime</code> objects</h2><span id='topic+tidyverse'></span><span id='topic+inner_join.sftime'></span><span id='topic+left_join.sftime'></span><span id='topic+right_join.sftime'></span><span id='topic+full_join.sftime'></span><span id='topic+semi_join.sftime'></span><span id='topic+anti_join.sftime'></span><span id='topic+filter.sftime'></span><span id='topic+arrange.sftime'></span><span id='topic+group_by.sftime'></span><span id='topic+ungroup.sftime'></span><span id='topic+rowwise.sftime'></span><span id='topic+mutate.sftime'></span><span id='topic+transmute.sftime'></span><span id='topic+select.sftime'></span><span id='topic+rename.sftime'></span><span id='topic+slice.sftime'></span><span id='topic+summarise.sftime'></span><span id='topic+summarize.sftime'></span><span id='topic+distinct.sftime'></span><span id='topic+gather.sftime'></span><span id='topic+pivot_longer.sftime'></span><span id='topic+spread.sftime'></span><span id='topic+sample_n.sftime'></span><span id='topic+sample_frac.sftime'></span><span id='topic+nest.sftime'></span><span id='topic+unnest.sftime'></span><span id='topic+separate.sftime'></span><span id='topic+unite.sftime'></span><span id='topic+separate_rows.sftime'></span>

<h3>Description</h3>

<p>'tidyverse' methods for <code>sftime</code> objects. Geometries are sticky, use 
<code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to let <code>dplyr</code>'s own methods drop them. Use 
these methods without the <code>.sftime</code> suffix and after loading the 
'tidyverse' package with the generic (or after loading package 'tidyverse').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inner_join.sftime(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

left_join.sftime(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

right_join.sftime(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

full_join.sftime(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

semi_join.sftime(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

anti_join.sftime(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

filter.sftime(.data, ..., .dots)

arrange.sftime(.data, ..., .dots)

group_by.sftime(.data, ..., add = FALSE)

ungroup.sftime(.data, ...)

rowwise.sftime(.data, ...)

mutate.sftime(.data, ..., .dots)

transmute.sftime(.data, ..., .dots)

select.sftime(.data, ...)

rename.sftime(.data, ...)

slice.sftime(.data, ..., .dots)

summarise.sftime(.data, ..., .dots, do_union = TRUE, is_coverage = FALSE)

summarize.sftime(.data, ..., .dots, do_union = TRUE, is_coverage = FALSE)

distinct.sftime(.data, ..., .keep_all = FALSE)

## S3 method for class 'sftime'
gather(
  data,
  key,
  value,
  ...,
  na.rm = FALSE,
  convert = FALSE,
  factor_key = FALSE
)

## S3 method for class 'sftime'
pivot_longer(
  data,
  cols,
  names_to = "name",
  names_prefix = NULL,
  names_sep = NULL,
  names_pattern = NULL,
  names_ptypes = NULL,
  names_transform = NULL,
  names_repair = "check_unique",
  values_to = "value",
  values_drop_na = FALSE,
  values_ptypes = NULL,
  values_transform = NULL,
  ...
)

## S3 method for class 'sftime'
spread(data, key, value, fill = NA, convert = FALSE, drop = TRUE, sep = NULL)

sample_n.sftime(
  tbl,
  size,
  replace = FALSE,
  weight = NULL,
  .env = parent.frame()
)

sample_frac.sftime(
  tbl,
  size = 1,
  replace = FALSE,
  weight = NULL,
  .env = parent.frame()
)

## S3 method for class 'sftime'
nest(.data, ...)

## S3 method for class 'sftime'
unnest(data, ..., .preserve = NULL)

## S3 method for class 'sftime'
separate(
  data,
  col,
  into,
  sep = "[^[:alnum:]]+",
  remove = TRUE,
  convert = FALSE,
  extra = "warn",
  fill = "warn",
  ...
)

## S3 method for class 'sftime'
unite(data, col, ..., sep = "_", remove = TRUE)

## S3 method for class 'sftime'
separate_rows(data, ..., sep = "[^[:alnum:]]+", convert = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidyverse_+3A_x">x</code></td>
<td>
<p>An object of class <code>sftime</code>.</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_y">y</code></td>
<td>
<p>A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_by">by</code></td>
<td>
<p>A character vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so that you
can check they're correct; suppress the message by supplying <code>by</code> explicitly.
</p>
<p>To join by different variables on <code>x</code> and <code>y</code>, use a named vector.
For example, <code>by = c("a" = "b")</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a vector with length &gt; 1.
For example, <code>by = c("a", "b")</code> will match <code>x$a</code> to <code>y$a</code> and <code>x$b</code> to
<code>y$b</code>. Use a named vector to match different variables in <code>x</code> and <code>y</code>.
For example, <code>by = c("a" = "b", "c" = "d")</code> will match <code>x$a</code> to <code>y$b</code> and
<code>x$c</code> to <code>y$d</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>,
use <code>by = character()</code>.</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_suffix">suffix</code></td>
<td>
<p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_.data">.data</code></td>
<td>
<p>An object of class <code>stime</code>.</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_.dots">.dots</code></td>
<td>
<p>see corresponding function in package <code>dplyr</code></p>
</td></tr>
<tr><td><code id="tidyverse_+3A_add">add</code></td>
<td>
<p>see corresponding function in dplyr</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_do_union">do_union</code></td>
<td>
<p>logical; in case <code>summary</code> does not create a geometry column, should geometries be created by unioning using <a href="sf.html#topic+st_union">st_union</a>, or simply by combining using <a href="sf.html#topic+st_combine">st_combine</a>? Using <a href="sf.html#topic+st_union">st_union</a> resolves internal boundaries, but in case of unioning points, this will likely change the order of the points; see Details.</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_is_coverage">is_coverage</code></td>
<td>
<p>logical; if <code>do_union</code> is <code>TRUE</code>, use an optimized algorithm for features that form a polygonal coverage (have no overlaps)</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_.keep_all">.keep_all</code></td>
<td>
<p>see corresponding function in dplyr</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_data">data</code></td>
<td>
<p>see original function docs</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_key">key</code></td>
<td>
<p>see original function docs</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_value">value</code></td>
<td>
<p>see original function docs</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_na.rm">na.rm</code></td>
<td>
<p>see original function docs</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_convert">convert</code></td>
<td>
<p>see <a href="tidyr.html#topic+separate_rows">separate_rows</a></p>
</td></tr>
<tr><td><code id="tidyverse_+3A_factor_key">factor_key</code></td>
<td>
<p>see original function docs</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_cols">cols</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to pivot into
longer format.</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_names_to">names_to</code></td>
<td>
<p>A string specifying the name of the column to create
from the data stored in the column names of <code>data</code>.
</p>
<p>Can be a character vector, creating multiple columns, if <code>names_sep</code>
or <code>names_pattern</code> is provided. In this case, there are two special
values you can take advantage of:
</p>

<ul>
<li> <p><code>NA</code> will discard that component of the name.
</p>
</li>
<li> <p><code>.value</code> indicates that component of the name defines the name of the
column containing the cell values, overriding <code>values_to</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tidyverse_+3A_names_prefix">names_prefix</code></td>
<td>
<p>A regular expression used to remove matching text
from the start of each variable name.</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_names_sep">names_sep</code></td>
<td>
<p>If <code>names_to</code> contains multiple values,
these arguments control how the column name is broken up.
</p>
<p><code>names_sep</code> takes the same specification as <code><a href="tidyr.html#topic+separate">separate()</a></code>, and can either
be a numeric vector (specifying positions to break on), or a single string
(specifying a regular expression to split on).
</p>
<p><code>names_pattern</code> takes the same specification as <code><a href="tidyr.html#topic+extract">extract()</a></code>, a regular
expression containing matching groups (<code style="white-space: pre;">&#8288;()&#8288;</code>).
</p>
<p>If these arguments do not give you enough control, use
<code>pivot_longer_spec()</code> to create a spec object and process manually as
needed.</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_names_pattern">names_pattern</code></td>
<td>
<p>If <code>names_to</code> contains multiple values,
these arguments control how the column name is broken up.
</p>
<p><code>names_sep</code> takes the same specification as <code><a href="tidyr.html#topic+separate">separate()</a></code>, and can either
be a numeric vector (specifying positions to break on), or a single string
(specifying a regular expression to split on).
</p>
<p><code>names_pattern</code> takes the same specification as <code><a href="tidyr.html#topic+extract">extract()</a></code>, a regular
expression containing matching groups (<code style="white-space: pre;">&#8288;()&#8288;</code>).
</p>
<p>If these arguments do not give you enough control, use
<code>pivot_longer_spec()</code> to create a spec object and process manually as
needed.</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_names_ptypes">names_ptypes</code></td>
<td>
<p>A list of column name-prototype pairs.
A prototype (or ptype for short) is a zero-length vector (like <code>integer()</code>
or <code>numeric()</code>) that defines the type, class, and attributes of a vector.
Use these arguments to confirm that the created columns are the types that
you expect.
</p>
<p>If not specified, the type of the columns generated from <code>names_to</code> will
be character, and the type of the variables generated from <code>values_to</code>
will be the common type of the input columns used to generate them.</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_names_transform">names_transform</code></td>
<td>
<p>A list of column name-function pairs.
Use these arguments if you need to change the type of specific columns.
For example, <code>names_transform = list(week = as.integer)</code> would convert
a character week variable to an integer.</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_names_repair">names_repair</code></td>
<td>
<p>What happens if the output has invalid column names?
The default, <code>"check_unique"</code> is to error if the columns are duplicated.
Use <code>"minimal"</code> to allow duplicates in the output, or <code>"unique"</code> to
de-duplicated by adding numeric suffixes. See <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code>
for more options.</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_values_to">values_to</code></td>
<td>
<p>A string specifying the name of the column to create
from the data stored in cell values. If <code>names_to</code> is a character
containing the special <code>.value</code> sentinel, this value will be ignored,
and the name of the value column will be derived from part of the
existing column names.</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_values_drop_na">values_drop_na</code></td>
<td>
<p>If <code>TRUE</code>, will drop rows that contain only <code>NA</code>s
in the <code>value_to</code> column. This effectively converts explicit missing values
to implicit missing values, and should generally be used only when missing
values in <code>data</code> were created by its structure.</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_values_ptypes">values_ptypes</code></td>
<td>
<p>A list of column name-prototype pairs.
A prototype (or ptype for short) is a zero-length vector (like <code>integer()</code>
or <code>numeric()</code>) that defines the type, class, and attributes of a vector.
Use these arguments to confirm that the created columns are the types that
you expect.
</p>
<p>If not specified, the type of the columns generated from <code>names_to</code> will
be character, and the type of the variables generated from <code>values_to</code>
will be the common type of the input columns used to generate them.</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_values_transform">values_transform</code></td>
<td>
<p>A list of column name-function pairs.
Use these arguments if you need to change the type of specific columns.
For example, <code>names_transform = list(week = as.integer)</code> would convert
a character week variable to an integer.</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_fill">fill</code></td>
<td>
<p>see original function docs</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_drop">drop</code></td>
<td>
<p>see original function docs</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_sep">sep</code></td>
<td>
<p>see <a href="tidyr.html#topic+separate_rows">separate_rows</a></p>
</td></tr>
<tr><td><code id="tidyverse_+3A_tbl">tbl</code></td>
<td>
<p>see original function docs</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_size">size</code></td>
<td>
<p>see original function docs</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_replace">replace</code></td>
<td>
<p>see original function docs</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_weight">weight</code></td>
<td>
<p>see original function docs</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_.env">.env</code></td>
<td>
<p>see original function docs</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_.preserve">.preserve</code></td>
<td>
<p>see <a href="tidyr.html#topic+nest">unnest</a></p>
</td></tr>
<tr><td><code id="tidyverse_+3A_col">col</code></td>
<td>
<p>see <a href="tidyr.html#topic+separate">separate</a></p>
</td></tr>
<tr><td><code id="tidyverse_+3A_into">into</code></td>
<td>
<p>see <a href="tidyr.html#topic+separate">separate</a></p>
</td></tr>
<tr><td><code id="tidyverse_+3A_remove">remove</code></td>
<td>
<p>see <a href="tidyr.html#topic+separate">separate</a></p>
</td></tr>
<tr><td><code id="tidyverse_+3A_extra">extra</code></td>
<td>
<p>see <a href="tidyr.html#topic+separate">separate</a></p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> For <code>_join</code> methods: An object of class <code>sftime</code> 
representing the joining result of <code>x</code> and <code>y</code>. See 
<code><a href="dplyr.html#topic+mutate-joins">mutate-joins</a></code>.
</p>
</li>
<li><p> For <code>filter</code>: See <code><a href="dplyr.html#topic+filter">filter</a></code>.
</p>
</li>
<li><p> For <code>arrange</code>: See <code><a href="dplyr.html#topic+arrange">arrange</a></code>. 
</p>
</li>
<li><p> For <code>group_by</code> and <code>ungroup</code>: A grouped <code>sftime</code> 
object. See <code><a href="dplyr.html#topic+arrange">arrange</a></code>. 
</p>
</li>
<li><p> For <code>rowwise</code>: An <code>sftime</code> object. See 
<code><a href="dplyr.html#topic+rowwise">rowwise</a></code>. 
</p>
</li>
<li><p> For <code>mutate</code> and <code>transmute</code>: See 
<code><a href="dplyr.html#topic+mutate">mutate</a></code>.
</p>
</li>
<li><p> For <code>select</code>: See <code><a href="dplyr.html#topic+select">select</a></code>. If the active 
time column is not explicitly selected, a <code>sf</code> object is returned. 
</p>
</li>
<li><p> For <code>rename</code>: See <code><a href="dplyr.html#topic+rename">rename</a></code>.    
</p>
</li>
<li><p> For <code>slice</code>: See <code><a href="dplyr.html#topic+slice">slice</a></code>.
</p>
</li>
<li><p> For <code>summarize</code> and <code>summarise</code>: See 
<code><a href="dplyr.html#topic+summarise">summarise</a></code>.  
</p>
</li>
<li><p> For <code>distinct</code>: See <code><a href="dplyr.html#topic+distinct">distinct</a></code>.
</p>
</li>
<li><p> For <code>gather</code>: See <code><a href="tidyr.html#topic+gather">gather</a></code>. 
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>g1 &lt;- st_sfc(st_point(1:2), st_point(c(5, 8)), st_point(c(2, 9)))
x1 &lt;- st_sftime(a = 1:3, geometry = g1, time = Sys.time())

g2 &lt;- st_sfc(st_point(c(4, 6)), st_point(c(4, 6)), st_point(c(4, 6)))
x2 &lt;- st_sftime(a = 2:4, geometry = g2, time = Sys.time())

library(dplyr)

## inner_join
inner_join(x1, as.data.frame(x2), by = "a") # note: the active time column is
# time.x and the active geometry column geometry.x

inner_join(x2, as.data.frame(x1), by = "a")

## left_join
left_join(x1, as.data.frame(x2), by = "a")

left_join(x2, as.data.frame(x1), by = "a")

## right_join
right_join(x1, as.data.frame(x2), by = "a")

right_join(x2, as.data.frame(x1), by = "a")

## full_join
full_join(x1, as.data.frame(x2), by = "a")

full_join(x2, as.data.frame(x1), by = "a")

## semi_join
semi_join(x1, as.data.frame(x2), by = "a")

semi_join(x2, as.data.frame(x1), by = "a")

## anti_join
anti_join(x1, as.data.frame(x2), by = "a")

anti_join(x2, as.data.frame(x1), by = "a")

## filter
filter(x1, a &lt;= 2)

## arrange
arrange(x1, dplyr::desc(a))

## group_by
group_by(x1, time)

## ungroup
ungroup(group_by(x1, time))

## rowwise
x1 %&gt;%
  mutate(a1 = 5:7) %&gt;%
  rowwise() %&gt;%
  mutate(a2 = mean(a, a1))

## mutate
x1 %&gt;%
  mutate(a1 = 5:7)

## transmute
x1 %&gt;%
  transmute(a1 = 5:7)

## select
x1 %&gt;%
  select(-time) %&gt;%
  select(geometry)

## rename
x1 %&gt;%
  rename(a1 = a)

## slice
x1 %&gt;%
  slice(1:2)

## summarise
x1 %&gt;%
  summarise(time = mean(time))
  
x1 %&gt;%
  summarize(time = mean(time))

## distinct
x1 %&gt;%
  distinct(geometry)

## gather
library(tidyr)
x1 %&gt;%
  mutate(a1 = 5:7) %&gt;%
  gather(key = "variable", value = "value", a, a1)

## pivot_longer
x1 %&gt;%
  mutate(a1 = 5:7) %&gt;%
  pivot_longer(cols = c("a", "a1"), names_to = "variable", values_to = "value")

## spread
x1 %&gt;%
  mutate(a1 = 5:7) %&gt;%
  gather(key = "variable", value = "value", a, a1) %&gt;%
  spread(key = "variable", value = "value")

## sample_n
set.seed(234)
x1 %&gt;%
  sample_n(size = 10, replace = TRUE)

## sample_frac
x1 %&gt;%
  sample_frac(size = 10, replace = TRUE) %&gt;%
  sample_frac(size = 0.1, replace = FALSE)

## nest
x1 %&gt;%
  nest(a1 = -time)

## unnest
x1 %&gt;%
  mutate(a1 = list(1, c(1, 2), 5)) %&gt;%
  unnest(a1)

## separate
x1 %&gt;%
  mutate(x = c(NA, "a.b", "a.d")) %&gt;%
  separate(x, c("A", "B"))

## unite
x1 %&gt;%
  mutate(x = c(NA, "a.b", "a.d")) %&gt;%
  separate(x, c("A", "B")) %&gt;%
  unite(x, c("A", "B"))
  
## separate_rows
x1 %&gt;%
  mutate(z = c("1", "2,3,4", "5,6")) %&gt;%
  separate_rows(z, convert = TRUE)

</code></pre>

<hr>
<h2 id='transform.sftime'>Transform method for <code>sftime</code> objects</h2><span id='topic+transform.sftime'></span>

<h3>Description</h3>

<p>Can be used to create or modify attribute variables; for transforming 
geometries see <code><a href="sf.html#topic+st_transform">st_transform</a></code>, and all other functions starting with 
<code>st_</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sftime'
transform(`_data`, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform.sftime_+3A__data">_data</code></td>
<td>
<p>An object of class <code><a href="#topic+st_sftime">sftime</a></code>.</p>
</td></tr>
<tr><td><code id="transform.sftime_+3A_...">...</code></td>
<td>
<p>Further arguments of the form new_variable=expression</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>_data</code> (an <code>sftime object</code>) with modified attribute values 
(columns).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create an sftime object
g &lt;- st_sfc(st_point(c(1, 2)), st_point(c(1, 3)), st_point(c(2, 3)), 
     st_point(c(2, 1)), st_point(c(3, 1)))
x &lt;- 
   data.frame(a = 1:5, g, time = Sys.time() + 1:5, stringsAsFactors = FALSE)
x_sftime &lt;- st_as_sftime(x)
x_sftime

# modify values in column a
transform(x_sftime, a = rev(a))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
