<!DOCTYPE html><html><head><title>Help for package landscapeR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {landscapeR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#expandClass'><p>Expand an existing class of patches.</p></a></li>
<li><a href='#landscapeR-package'><p>landscapeR: A landscape simulator for R.</p></a></li>
<li><a href='#makeClass'><p>Create a class of patches.</p></a></li>
<li><a href='#makeLine'><p>Create a linear patch (beta version).</p></a></li>
<li><a href='#makePatch'><p>Create a single patch</p></a></li>
<li><a href='#rmSingle'><p>Remove single tones from patches</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Categorical Landscape Simulation Facility</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-07-05</td>
</tr>
<tr>
<td>Copyright:</td>
<td>Natural Environment Research Council (NERC) and Centre for
Ecology and Hydrology (CEH)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dariomasante/landscapeR">https://github.com/dariomasante/landscapeR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dariomasante/landscapeR/issues">https://github.com/dariomasante/landscapeR/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>raster, Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulates categorical maps on actual geographical realms, starting from either empty landscapes or landscapes provided by the user (e.g. land use maps). Allows to tweak or create landscapes while retaining a high degree of control on its features, without the hassle of specifying each location attribute. In this it differs from other tools which generate null or neutral landscapes in a theoretical space. The basic algorithm currently implemented uses a simple agent style/cellular automata growth model, with no rules (apart from areas of exclusion) and von Neumann neighbourhood (four cells, aka Rook case). Outputs are raster dataset exportable to any common GIS format.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-07-05 12:46:53 UTC; masanda</td>
</tr>
<tr>
<td>Author:</td>
<td>Dario Masante [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dario Masante &lt;dario.masante@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-07-05 14:54:40 UTC</td>
</tr>
</table>
<hr>
<h2 id='expandClass'>Expand an existing class of patches.</h2><span id='topic+expandClass'></span>

<h3>Description</h3>

<p>Expand an existing class of patches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expandClass(context, class, size, bgr = 0, pts = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expandClass_+3A_context">context</code></td>
<td>
<p>Raster object or matrix, an empty landscape raster or a mask indicating where the patch cannot be generated (see bgr below).</p>
</td></tr>
<tr><td><code id="expandClass_+3A_class">class</code></td>
<td>
<p>The raster value of class (or patch) to expand.</p>
</td></tr>
<tr><td><code id="expandClass_+3A_size">size</code></td>
<td>
<p>integer. Size of expansion, as number of raster cells.</p>
</td></tr>
<tr><td><code id="expandClass_+3A_bgr">bgr</code></td>
<td>
<p>integer. The background available where expansion is allowed (i.e. shrinking classes).</p>
</td></tr>
<tr><td><code id="expandClass_+3A_pts">pts</code></td>
<td>
<p>integer or matrix. The seed point location around which the patches are built (random points are given by default). It can be an integer, as indexes of the cells in the raster, or a two columns matrix indicating x and y coordinates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A RasterLayer object. If <code>rast=FALSE</code> returns a list of vectors, each containing the <code>context</code> cells assigned to each patch.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(raster)

m = matrix(0, 33, 33)
r = raster(m, xmn=0, xmx=10, ymn=0, ymx=10)
r = makeClass(r, 5, 10)
plot(r)

rr = expandClass(r, 1, 100)
plot(rr)

## This function can be used to mimic shapes, by providing a skeleton:
m[,17] = 1
r = raster(m, xmn=0, xmx=10, ymn=0, ymx=10)
plot(r)

rr = expandClass(r, 1, 100)
plot(rr)
</code></pre>

<hr>
<h2 id='landscapeR-package'>landscapeR: A landscape simulator for R.</h2><span id='topic+landscapeR-package'></span><span id='topic+landscapeR'></span>

<h3>Description</h3>

<p>This package is aimed at simulating categorical landscapes on actual geographical realms,
starting from either empty landscapes, or landscapes provided by the user (e.g. land use maps).
landscapeR allows to tweak or create landscapes while retaining a high degree of control on its features,
without the hassle of specifying each location attribute. In this it differs from other tools
which generate null or neutral landscape in a theoretical space. The basic algorithm currently
implemented uses a simple agent style/cellular automata growth model, with no rules
(apart from areas of exclusion). Outputs are raster dataset exportable to any common GIS format.
</p>


<h3>Details</h3>

<p>Check out the vignette illustrating the use of landscapeR.<br />
Also: <a href="https://github.com/dariomasante/landscapeR">https://github.com/dariomasante/landscapeR</a>
</p>


<h3>landscapeR functions</h3>


<ul>
<li><p><code><a href="#topic+makePatch">makePatch</a></code> creates a single patch in the landscape.
</p>
</li>
<li><p><code><a href="#topic+makeClass">makeClass</a></code> creates a group of patches belonging to the same class.
</p>
</li>
<li><p><code><a href="#topic+expandClass">expandClass</a></code> expands an existing class of patches.
</p>
</li>
<li><p><code><a href="#topic+makeLine">makeLine</a></code> creates a linear patch.
</p>
</li>
<li><p><code><a href="#topic+rmSingle">rmSingle</a></code> removes single tones from patches and background.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Dario Masante
</p>

<hr>
<h2 id='makeClass'>Create a class of patches.</h2><span id='topic+makeClass'></span>

<h3>Description</h3>

<p>Create a class of patches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeClass(context, npatch, size, pts = NULL, bgr = 0, edge = FALSE,
  rast = TRUE, val = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeClass_+3A_context">context</code></td>
<td>
<p>Raster object, a raster of an empty landscape or a mask, indicating where the patch cannot be generated (see <code>bgr</code> argument).</p>
</td></tr>
<tr><td><code id="makeClass_+3A_npatch">npatch</code></td>
<td>
<p>number of patches per class</p>
</td></tr>
<tr><td><code id="makeClass_+3A_size">size</code></td>
<td>
<p>integer. The size of patches, as number of raster cells. A single integer can be provided, in which case all patches will have that size.</p>
</td></tr>
<tr><td><code id="makeClass_+3A_pts">pts</code></td>
<td>
<p>integer or matrix. The seed point location around which the patches are built (random points are given by default). It can be an integer, as indexes of the cells in the raster, or a two columns matrix indicating x and y coordinates.</p>
</td></tr>
<tr><td><code id="makeClass_+3A_bgr">bgr</code></td>
<td>
<p>integer. A single value of background cells, where a patch can be generated (default is zero). Cells/classes which cannot be changed must have a different value.</p>
</td></tr>
<tr><td><code id="makeClass_+3A_edge">edge</code></td>
<td>
<p>logical. Should the vector of edge cells of the patch be returned?</p>
</td></tr>
<tr><td><code id="makeClass_+3A_rast">rast</code></td>
<td>
<p>logical. If TRUE returns a Raster object, otherwise a vector of cell numbers where the patch occurs</p>
</td></tr>
<tr><td><code id="makeClass_+3A_val">val</code></td>
<td>
<p>integer. The value to be assigned to patch cells, when <code>rast=TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The patches created can be contiguous, therefore resembling a single patch with size
equal to the sum of contiguous cells. The patches are created starting from the seed points (if provided) and iteratively sampling randomly neighbouring cells at the edge of the patch, according to von Neumann neighbourhood (four cells, aka Rook case).
There is a tolerance of +/- 3 cells from the patch size declared in <code>size</code> argument.
</p>


<h3>Value</h3>

<p>A RasterLayer object, or a vector of cell numbers  if <code>rast=FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(raster)

m = matrix(0, 33, 33)
r = raster(m, xmn=0, xmx=10, ymn=0, ymx=10)
num = 5
size = 15
rr = makeClass(r, num, size)
plot(rr)

## Create a class of three patches of given size at three corners of the spatial context
size = c(10, 50, 200)
pts = c(1, 33, 1089)
rr = makeClass(r, 3, size, pts)
plot(rr)
</code></pre>

<hr>
<h2 id='makeLine'>Create a linear patch (beta version).</h2><span id='topic+makeLine'></span>

<h3>Description</h3>

<p>Create a linear patch, setting direction and convolution. The higher the convolution degree, the weaker the
linear shape (and direction).



</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeLine(context, size, direction = NULL, convol = 0.5, spt = NULL,
  bgr = 0, edge = FALSE, rast = FALSE, val = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeLine_+3A_context">context</code></td>
<td>
<p>Raster object or matrix, an empty landscape raster or a mask indicating where the patch cannot be generated (see bgr below).</p>
</td></tr>
<tr><td><code id="makeLine_+3A_size">size</code></td>
<td>
<p>integer. Size of the patch to be generated, as number of raster cells.</p>
</td></tr>
<tr><td><code id="makeLine_+3A_direction">direction</code></td>
<td>
<p>numeric. The direction towards which the patch will point and grow, expressed in degrees between 0 and 360.</p>
</td></tr>
<tr><td><code id="makeLine_+3A_convol">convol</code></td>
<td>
<p>numeric. Level of convolution to be assigned to the patch (default is <code>convol=0.5</code>). A value
between 0 and 1, where 0 is no convolution at all (basically a straight line) and 1 is maximum convolution (i.e. tends to form a circular patch).</p>
</td></tr>
<tr><td><code id="makeLine_+3A_spt">spt</code></td>
<td>
<p>integer or matrix. The seed point location around which the patch is generated (a random point is given by default). It can be an integer, as index of the cell in the raster, or a two columns matrix indicating x and y coordinates (an integer vector of length 2 is accepted too).</p>
</td></tr>
<tr><td><code id="makeLine_+3A_bgr">bgr</code></td>
<td>
<p>integer. A single value of background cells, where a patch can be generated (default is zero). Cells/classes which cannot be changed must have a different value.</p>
</td></tr>
<tr><td><code id="makeLine_+3A_edge">edge</code></td>
<td>
<p>logical. Should the vector of edge cells of the patch be returned?</p>
</td></tr>
<tr><td><code id="makeLine_+3A_rast">rast</code></td>
<td>
<p>logical. If TRUE returns a Raster object, otherwise a vector of cell numbers where the patch occurs</p>
</td></tr>
<tr><td><code id="makeLine_+3A_val">val</code></td>
<td>
<p>integer. The value to be assigned to patch cells, when <code>rast=TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For any values of <code>convol</code> &gt; 0.8, no big differences are observed noted. Also direction is progressively lost
as convolution increases.
</p>


<h3>Value</h3>

<p>A vector of raster cell numbers, or a RasterLayer object if <code>rast=TRUE</code>. If <code>edge=TRUE</code> a
list of two vectors is returned: one for the inner raster cells and the second for cells at the edge of the patch.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(raster)
r &lt;- matrix(0,33,33)
r &lt;- raster(r, xmn=0, xmx=10, ymn=0, ymx=10)
plot(makeLine(r, size=50, spt = 545, direction=45, convol=0.05, rast=TRUE))

</code></pre>

<hr>
<h2 id='makePatch'>Create a single patch</h2><span id='topic+makePatch'></span>

<h3>Description</h3>

<p>Function will create a single patch. <strong>NOTE</strong>: <code>makeClass</code> should be used preferably when creating a single patch, as better error and exception handling is provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makePatch(context, size, spt = NULL, bgr = 0, edge = FALSE,
  rast = FALSE, val = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makePatch_+3A_context">context</code></td>
<td>
<p>Raster object or matrix, an empty landscape raster or a mask indicating where the patch cannot be generated (see bgr below).</p>
</td></tr>
<tr><td><code id="makePatch_+3A_size">size</code></td>
<td>
<p>integer. Size of the patch to be generated, as number of raster cells.</p>
</td></tr>
<tr><td><code id="makePatch_+3A_spt">spt</code></td>
<td>
<p>integer or matrix. The seed point location around which the patch is generated (a random point is given by default). It can be an integer, as index of the cell in the raster, or a two columns matrix indicating x and y coordinates (an integer vector of length 2 is accepted too).</p>
</td></tr>
<tr><td><code id="makePatch_+3A_bgr">bgr</code></td>
<td>
<p>integer. A single value of background cells, where a patch can be generated (default is zero). Cells/classes which cannot be changed must have a different value.</p>
</td></tr>
<tr><td><code id="makePatch_+3A_edge">edge</code></td>
<td>
<p>logical. Should the vector of edge cells of the patch be returned?</p>
</td></tr>
<tr><td><code id="makePatch_+3A_rast">rast</code></td>
<td>
<p>logical. If TRUE returns a Raster object, otherwise a vector of cell numbers where the patch occurs</p>
</td></tr>
<tr><td><code id="makePatch_+3A_val">val</code></td>
<td>
<p>integer. The value to be assigned to patch cells, when <code>rast=TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The patch is created starting from the seed point and iteratively sampling randomly neighbouring cells at the edge of the patch, according to von Neumann neighbourhood (four cells, aka Rook case).
There is a tolerance of +/- 3 cells from the patch size declared in <code>size</code> argument.
Argument <code>bgr</code> accepts a single value only, unlike <code>makeClass</code> that accepts multiple and should therefore preferred.
</p>


<h3>Value</h3>

<p>A vector of raster cell numbers, or a RasterLayer object if <code>rast=TRUE</code>. If <code>edge=TRUE</code> a
list of two vectors is returned: one for the inner raster cells and the second for cells at the edge of the patch.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(raster)
mtx = matrix(0, 33, 33)
r = raster(mtx, xmn=0, xmx=10, ymn=0, ymx=10)
patchSize = 500
rr = makePatch(r, patchSize, rast=TRUE)
plot(rr)

## Create a patch with value 3, starting from the centre cell
mtx = matrix(0, 33, 33)
r = raster(mtx, xmn=0, xmx=10, ymn=0, ymx=10)
newVal = 3
centre = 545
cells = makePatch(r, patchSize, centre)
r[cells] = newVal
plot(r)

## Now create a new patch with value 10 and size 100 inside the existing patch
rr = makePatch(r, 100, bgr=newVal, rast=TRUE, val=10)
plot(rr)
</code></pre>

<hr>
<h2 id='rmSingle'>Remove single tones from patches</h2><span id='topic+rmSingle'></span>

<h3>Description</h3>

<p>Patch creation algorithm can occasionally leave single cells scattered within patches.
This function reduces the &quot;salt-pepper&quot; effect, identifying or correcting those cells.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmSingle(rst, rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmSingle_+3A_rst">rst</code></td>
<td>
<p>input raster landscape.</p>
</td></tr>
<tr><td><code id="rmSingle_+3A_rm">rm</code></td>
<td>
<p>logical, if TRUE returns the raster without single tones cells, if FALSE a vector of numbers identifying the index of single tones cells.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A raster without single tones cells. If <code>rm=FALSE</code>, it returns a vector of numbers identifying the index of single tones cells.
The value assigned to single tone cells is picked from one of the four neighbouring cells, selected at random.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(raster)
m = matrix(0, 33, 33)
r = raster(m, xmn=0, xmx=10, ymn=0, ymx=10)
patchSize = 500

## Make a patch and introduce a single tone cell
r = makePatch(r, patchSize, spt=578, rast=TRUE)
r[578] = 0
plot(r)

## Now remove it
plot( rmSingle(r) )

## Single tones can be identified but not removed:
rmSingle(r, rm = FALSE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
