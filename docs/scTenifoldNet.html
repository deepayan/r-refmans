<!DOCTYPE html><html lang="en"><head><title>Help for package scTenifoldNet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {scTenifoldNet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cpDecomposition'><p>Canonical Polyadic Decomposition</p></a></li>
<li><a href='#cpmNormalization'><p>Performs counts per million (CPM) data normalization</p></a></li>
<li><a href='#dRegulation'><p>Evaluates gene differential regulation based on manifold alignment distances.</p></a></li>
<li><a href='#makeNetworks'><p>Computes gene regulatory networks for subsamples of cells based on principal component regression.</p></a></li>
<li><a href='#manifoldAlignment'><p>Performs non-linear manifold alignment of two gene regulatory networks.</p></a></li>
<li><a href='#pcNet'><p>Computes a gene regulatory network based on principal component regression</p></a></li>
<li><a href='#scQC'><p>Performs single-cell data quality control</p></a></li>
<li><a href='#scTenifoldNet'><p>scTenifoldNet</p></a></li>
<li><a href='#tensorDecomposition'><p>Performs CANDECOMP/PARAFAC (CP) Tensor Decomposition.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Construct and Compare scGRN from Single-Cell Transcriptomic Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3</td>
</tr>
<tr>
<td>Description:</td>
<td>A workflow based on machine learning methods to construct and compare single-cell gene regulatory networks (scGRN) using single-cell RNA-seq (scRNA-seq) data collected from different conditions. Uses principal component regression, tensor decomposition, and manifold alignment, to accurately identify even subtly shifted gene expression programs. See &lt;<a href="https://doi.org/10.1016%2Fj.patter.2020.100139">doi:10.1016/j.patter.2020.100139</a>&gt; for more details.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/cailab-tamu/scTenifoldNet">https://github.com/cailab-tamu/scTenifoldNet</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/cailab-tamu/scTenifoldNet/issues">https://github.com/cailab-tamu/scTenifoldNet/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>pbapply, RSpectra, Matrix, methods, stats, utils, MASS,
RhpcBLASctl</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-10-28 13:47:19 UTC; danie</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Osorio <a href="https://orcid.org/0000-0003-4424-8422"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Yan Zhong [aut, ctb],
  Guanxun Li [aut, ctb],
  Jianhua Huang [aut, ctb],
  James Cai <a href="https://orcid.org/0000-0002-8081-6725"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    ctb, ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Osorio &lt;dcosorioh@utexas.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-10-29 06:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cpDecomposition'>Canonical Polyadic Decomposition</h2><span id='topic+cpDecomposition'></span>

<h3>Description</h3>

<p>Canonical Polyadic (CP) decomposition of a tensor, aka CANDECOMP/PARAFRAC. Approximate a K-Tensor using a sum of <code>num_components</code> rank-1 K-Tensors. A rank-1 K-Tensor can be written as an outer product of K vectors. There are a total of <code>num_compoents *tnsr@num_modes</code> vectors in the output, stored in <code>tnsr@num_modes</code> matrices, each with <code>num_components</code> columns. This is an iterative algorithm, with two possible stopping conditions: either relative error in Frobenius norm has gotten below <code>tol</code>, or the <code>max_iter</code> number of iterations has been reached. For more details on CP decomposition, consult Kolda and Bader (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpDecomposition(tnsr, num_components = NULL, max_iter = 25, tol = 1e-05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpDecomposition_+3A_tnsr">tnsr</code></td>
<td>
<p>Tensor with K modes</p>
</td></tr>
<tr><td><code id="cpDecomposition_+3A_num_components">num_components</code></td>
<td>
<p>the number of rank-1 K-Tensors to use in approximation</p>
</td></tr>
<tr><td><code id="cpDecomposition_+3A_max_iter">max_iter</code></td>
<td>
<p>maximum number of iterations if error stays above <code>tol</code></p>
</td></tr>
<tr><td><code id="cpDecomposition_+3A_tol">tol</code></td>
<td>
<p>relative Frobenius norm error tolerance</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the Alternating Least Squares (ALS) estimation procedure. A progress bar is included to help monitor operations on large tensors.
</p>


<h3>Value</h3>

<p>a list containing the following </p>

<dl>
<dt><code>lambdas</code></dt><dd><p>a vector of normalizing constants, one for each component</p>
</dd>
<dt><code>U</code></dt><dd><p>a list of matrices - one for each mode - each matrix with <code>num_components</code> columns</p>
</dd>
<dt><code>conv</code></dt><dd><p>whether or not <code>resid</code> &lt; <code>tol</code> by the last iteration</p>
</dd>
<dt><code>norm_percent</code></dt><dd><p>the percent of Frobenius norm explained by the approximation</p>
</dd>
<dt><code>est</code></dt><dd><p>estimate of <code>tnsr</code> after compression</p>
</dd>
<dt><code>fnorm_resid</code></dt><dd><p>the Frobenius norm of the error <code>fnorm(est-tnsr)</code></p>
</dd>
<dt><code>all_resids</code></dt><dd><p>vector containing the Frobenius norm of error for all the iterations</p>
</dd>
</dl>



<h3>References</h3>

<p>T. Kolda, B. Bader, &quot;Tensor decomposition and applications&quot;. SIAM Applied Mathematics and Applications 2009.
</p>

<hr>
<h2 id='cpmNormalization'>Performs counts per million (CPM) data normalization</h2><span id='topic+cpmNormalization'></span>

<h3>Description</h3>

<p>This function normalizes the count data present in a given matrix using counts per million normalization (CPM). Each gene count for each cell is divided by the total counts for that cell and multiplied by 1e6. No log-transformation is applied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpmNormalization(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpmNormalization_+3A_x">X</code></td>
<td>
<p>Raw counts matrix with cells as columns and genes (symbols) as rows</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dgCMatrix object with the count per million (CPM) normalized values.
</p>


<h3>References</h3>

<p>Vallejos, Catalina A., et al. &quot;Normalizing single-cell RNA sequencing data: challenges and opportunities.&quot; Nature methods 14.6 (2017): 565.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(scTenifoldNet)

# Simulating of a dataset following a negative binomial distribution with high sparcity (~67%)
nCells = 2000
nGenes = 100
set.seed(1)
X &lt;- rnbinom(n = nGenes * nCells, size = 20, prob = 0.98)
X &lt;- round(X)
X &lt;- matrix(X, ncol = nCells)
rownames(X) &lt;- c(paste0('ng', 1:90), paste0('mt-', 1:10))

# Performing Single cell quality control
qcOutput &lt;- scQC(
  X = X,
  minLibSize = 30,
  removeOutlierCells = TRUE,
  minPCT = 0.05,
  maxMTratio = 0.1
)
# Performing Counts per million Normalization (CPM)
normalizationOutput &lt;- cpmNormalization(qcOutput)

# Visualizing the differences
oldPar &lt;- par(no.readonly = TRUE)

par(
  mfrow = c(1, 2),
  mar = c(3, 3, 1, 1),
  mgp = c(1.5, 0.5, 0)
)
plot(
  Matrix::colSums(qcOutput),
  ylab = 'Library Size',
  xlab = 'Cell',
  main = 'Before CPM Normalization'
)
plot(
  Matrix::colSums(normalizationOutput),
  ylab = 'Library Size',
  xlab = 'Cell',
  main = 'After CPM Normalization'
)

par(oldPar)
</code></pre>

<hr>
<h2 id='dRegulation'>Evaluates gene differential regulation based on manifold alignment distances.</h2><span id='topic+dRegulation'></span>

<h3>Description</h3>

<p>Using the output of the non-linear manifold alignment, this function computes the Euclidean distance between the coordinates for the same gene in both conditions. Calculated distances are then transformed using Box-Cox power transformation, and standardized to ensure normality. P-values are assigned following the chi-square distribution over the fold-change of the squared distance computed with respect to the expectation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dRegulation(manifoldOutput)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dRegulation_+3A_manifoldoutput">manifoldOutput</code></td>
<td>
<p>A matrix. The output of the non-linear manifold alignment,  a labeled matrix with two times the number of shared genes as rows (X_ genes followed by Y_ genes in the same order) and <code>d</code> number of columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with 6 columns as follows: </p>

<ul>
<li> <p><code>gene</code> A character vector with the gene id identified from the <code>manifoldAlignment</code> output.
</p>
</li>
<li> <p><code>distance</code> A numeric vector of the Euclidean distance computed between the coordinates of the same gene in both conditions.
</p>
</li>
<li> <p><code>Z</code> A numeric vector of the Z-scores computed after Box-Cox power transformation.
</p>
</li>
<li> <p><code>FC</code> A numeric vector of the FC computed with respect to the expectation.
</p>
</li>
<li> <p><code>p.value</code> A numeric vector of the p-values associated to the fold-changes, probabilities are asigned as <code class="reqn">P[X &gt; x]</code> using the Chi-square distribution with one degree of freedom.
</p>
</li>
<li> <p><code>p.adj</code> A numeric vector of adjusted p-values using Benjamini &amp; Hochberg (1995) FDR correction.
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> Benjamini, Y., and Yekutieli, D. (2001). The control of the false discovery rate in multiple testing under dependency. Annals of Statistics, 29, 1165-1188. doi: 10.1214/aos/1013699998.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(scTenifoldNet)

# Simulating of a dataset following a negative binomial distribution with high sparcity (~67%)
nCells = 2000
nGenes = 100
set.seed(1)
X &lt;- rnbinom(n = nGenes * nCells, size = 20, prob = 0.98)
X &lt;- round(X)
X &lt;- matrix(X, ncol = nCells)
rownames(X) &lt;- c(paste0('ng', 1:90), paste0('mt-', 1:10))

# Performing Single cell quality control
qcOutput &lt;- scQC(
  X = X,
  minLibSize = 30,
  removeOutlierCells = TRUE,
  minPCT = 0.05,
  maxMTratio = 0.1
)

# Computing 3 single-cell gene regulatory networks each one from a subsample of 500 cells
xNetworks &lt;- makeNetworks(X = qcOutput,
                         nNet = 3, 
                         nCells = 500, 
                         nComp = 3, 
                         scaleScores = TRUE, 
                         symmetric = FALSE, 
                         q = 0.95
                         )

# Computing a K = 3 CANDECOMP/PARAFAC (CP) Tensor Decomposition 
tdOutput &lt;- tensorDecomposition(xNetworks, K = 3, maxError = 1e5, maxIter = 1e3)

## Not run: 
# Computing the alignment
# For this example, we are using the same input, the match should be perfect. 
maOutput &lt;- manifoldAlignment(tdOutput$X, tdOutput$X)

# Evaluating the difference in regulation
dcOutput &lt;- dRegulation(maOutput, minFC = 0)
head(dcOutput)

# Plotting
# If FDR &lt; 0.05, the gene will be colored in red.
geneColor &lt;- ifelse(dcOutput$p.adj &lt; 0.05, 'red', 'black')
qqnorm(dcOutput$Z, main = 'Standardized Distance', pch = 16, col = geneColor)
qqline(dcOutput$Z)

## End(Not run)
</code></pre>

<hr>
<h2 id='makeNetworks'>Computes gene regulatory networks for subsamples of cells based on principal component regression.</h2><span id='topic+makeNetworks'></span>

<h3>Description</h3>

<p>This function computes <code>nNet</code> gene regulatory networks for a randomly selected subsample of <code>nCells</code> cells based on principal component regression (PCR), a technique based on principal component analysis. In PCR, the outcome variable is regressed over a <code>nComp</code> number of for principal components computed from a set of covariates to estimate the unknown regression coefficients in the model. <code>pcNet</code> function computes the PCR coefficients for each gene one at a time using all the others as covariates, to construct an all by all gene regulatory network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeNetworks(
  X,
  nNet = 10,
  nCells = 500,
  nComp = 3,
  scaleScores = TRUE,
  symmetric = FALSE,
  q = 0.95,
  nCores = parallel::detectCores()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeNetworks_+3A_x">X</code></td>
<td>
<p>A filtered and normlized gene expression matrix with cells as columns and genes as rows.</p>
</td></tr>
<tr><td><code id="makeNetworks_+3A_nnet">nNet</code></td>
<td>
<p>An integer value. The number of networks based on principal components regression to generate.</p>
</td></tr>
<tr><td><code id="makeNetworks_+3A_ncells">nCells</code></td>
<td>
<p>An integer value. The number of cells to subsample each time to generate a network.</p>
</td></tr>
<tr><td><code id="makeNetworks_+3A_ncomp">nComp</code></td>
<td>
<p>An integer value. The number of principal components in PCA to generate the networks. Should be greater than 2 and lower than the total number of genes.</p>
</td></tr>
<tr><td><code id="makeNetworks_+3A_scalescores">scaleScores</code></td>
<td>
<p>A boolean value (<code>TRUE/FALSE</code>), if <code>TRUE</code>, the weights will be normalized such that the maximum absolute value is 1.</p>
</td></tr>
<tr><td><code id="makeNetworks_+3A_symmetric">symmetric</code></td>
<td>
<p>A boolean value (<code>TRUE/FALSE</code>), if <code>TRUE</code>, the weights matrix returned will be symmetric.</p>
</td></tr>
<tr><td><code id="makeNetworks_+3A_q">q</code></td>
<td>
<p>A decimal value between 0 and 1. Represent the cut-off threshold of top q% relationships to be returned.</p>
</td></tr>
<tr><td><code id="makeNetworks_+3A_ncores">nCores</code></td>
<td>
<p>An integer value. Defines the number of cores to be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Principal component regression may be broadly divided into three major steps: </p>

<ol>
<li><p> Perform PCA on the observed covariates data matrix to obtain <code>nComp</code> number of the principal components.
</p>
</li>
<li><p> Regress the observed vector of outcomes on the selected principal components as covariates, using ordinary least squares regression to get a vector of estimated regression coefficients
</p>
</li>
<li><p> Transform this vector back to the scale of the actual covariates, using the eigenvectors corresponding to the selected principal components to get the final PCR estimator for estimating the regression coefficients characterizing the original model.
</p>
</li></ol>



<h3>Value</h3>

<p>A list with <code>nNet</code> gene regulatory networks in dgCMatrix format. Each one computed from a randomly selected subsample of <code>nCells</code> cells.
</p>


<h3>References</h3>


<ul>
<li><p> Gill, Ryan, Somnath Datta, and Susmita Datta. &quot;dna: An R package for differential network analysis.&quot; Bioinformation 10.4 (2014): 233.
</p>
</li>
<li><p> Jolliffe, Ian T. &quot;A note on the use of principal components in regression.&quot; Journal of the Royal Statistical Society: Series C (Applied Statistics) 31.3 (1982): 300-303.
</p>
</li>
<li><p> Massy, William F. &quot;Principal components regression in exploratory statistical research.&quot; Journal of the American Statistical Association 60.309 (1965): 234-256.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(scTenifoldNet)

# Simulating of a dataset following a negative binomial distribution with high sparcity (~67%)
nCells = 2000
nGenes = 100
set.seed(1)
X &lt;- rnbinom(n = nGenes * nCells, size = 20, prob = 0.98)
X &lt;- round(X)
X &lt;- matrix(X, ncol = nCells)
rownames(X) &lt;- c(paste0('ng', 1:90), paste0('mt-', 1:10))

# Performing Single cell quality control
qcOutput &lt;- scQC(
  X = X,
  minLibSize = 30,
  removeOutlierCells = TRUE,
  minPCT = 0.05,
  maxMTratio = 0.1
)

# Computing 3 single-cell gene regulatory networks each one from a subsample of 500 cells
mnOutput &lt;- makeNetworks(X = X,
                         nNet = 3, 
                         nCells = 500, 
                         nComp = 3, 
                         scaleScores = TRUE, 
                         symmetric = FALSE, 
                         q = 0.95
                         )

# Verifying the class
class(mnOutput)

# Verifying the number of networks
length(mnOutput)

# Veryfying the dimention of the networks
lapply(mnOutput,dim)

# Single-cell gene regulatory networks
mnOutput[[1]][1:10,1:10]
mnOutput[[2]][1:10,1:10]
mnOutput[[3]][1:10,1:10]
</code></pre>

<hr>
<h2 id='manifoldAlignment'>Performs non-linear manifold alignment of two gene regulatory networks.</h2><span id='topic+manifoldAlignment'></span>

<h3>Description</h3>

<p>Build comparable low-dimensional features for two weight-averaged denoised single-cell gene regulatory networks. Using a non-linear network embedding method <code>manifoldAlignment </code> aligns two gene regulatory networks and finds the structural similarities between them. This function is a wrapper of the <code>Python</code> code provided by Vu et al., (2012) at https://github.com/all-umass/ManifoldWarping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manifoldAlignment(X, Y, d = 30, nCores = parallel::detectCores())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="manifoldAlignment_+3A_x">X</code></td>
<td>
<p>A gene regulatory network.</p>
</td></tr>
<tr><td><code id="manifoldAlignment_+3A_y">Y</code></td>
<td>
<p>A gene regulatory network.</p>
</td></tr>
<tr><td><code id="manifoldAlignment_+3A_d">d</code></td>
<td>
<p>The dimension of the low-dimensional feature space.</p>
</td></tr>
<tr><td><code id="manifoldAlignment_+3A_ncores">nCores</code></td>
<td>
<p>An integer value. Defines the number of cores to be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Manifold alignment builds connections between two or more disparate data sets by aligning their underlying manifolds and provides knowledge transfer across the data sets. For further information please see: Wang et al., (2009)
</p>


<h3>Value</h3>

<p>A low-dimensional projection for two the two gene regulatory networks used as input. The output is a labeled matrix with two times the number of shared genes as rows ( X_ genes followed by Y_ genes in the same order) and <code>d</code> number of columns.
</p>


<h3>References</h3>


<ul>
<li><p> Vu, Hoa Trong, Clifton Carey, and Sridhar Mahadevan. &quot;Manifold warping: Manifold alignment over time.&quot; Twenty-Sixth AAAI Conference on Artificial Intelligence. 2012.
</p>
</li>
<li><p> Wang, Chang, and Sridhar Mahadevan. &quot;A general framework for manifold alignment.&quot; 2009 AAAI Fall Symposium Series. 2009.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(scTenifoldNet)

# Simulating of a dataset following a negative binomial distribution with high sparcity (~67%)
nCells = 2000
nGenes = 100
set.seed(1)
X &lt;- rnbinom(n = nGenes * nCells, size = 20, prob = 0.98)
X &lt;- round(X)
X &lt;- matrix(X, ncol = nCells)
rownames(X) &lt;- c(paste0('ng', 1:90), paste0('mt-', 1:10))

# Performing Single cell quality control
qcOutput &lt;- scQC(
  X = X,
  minLibSize = 30,
  removeOutlierCells = TRUE,
  minPCT = 0.05,
  maxMTratio = 0.1
)

# Computing 3 single-cell gene regulatory networks each one from a subsample of 500 cells
xNetworks &lt;- makeNetworks(X = X,
                         nNet = 3, 
                         nCells = 500, 
                         nComp = 3, 
                         scaleScores = TRUE, 
                         symmetric = FALSE, 
                         q = 0.95
                         )

# Computing a K = 3 CANDECOMP/PARAFAC (CP) Tensor Decomposition 
tdOutput &lt;- tensorDecomposition(xNetworks, K = 3, maxError = 1e5, maxIter = 1e3)

## Not run: 
# Computing the alignment
# For this example, we are using the same input, the match should be perfect. 
maOutput &lt;- manifoldAlignment(tdOutput$X, tdOutput$X)

# Separating the coordinates for each gene
X &lt;- maOutput[grepl('X_', rownames(maOutput)),]
Y &lt;- maOutput[grepl('Y_', rownames(maOutput)),]

# Plotting
# X Points
plot(X, pch = 16)

# Y Points
points(Y, col = 'red')

# Legend
legend('topright', legend = c('X', 'Y'), 
       col = c('black', 'red'), bty = 'n', 
       pch = c(16,1), cex = 0.7)

## End(Not run)
</code></pre>

<hr>
<h2 id='pcNet'>Computes a gene regulatory network based on principal component regression</h2><span id='topic+pcNet'></span>

<h3>Description</h3>

<p>This function computes a gene regulatory network based on principal component regression (PCR), a technique based on principal component analysis. In PCR, the outcome variable is regressed over a <code>nComp</code> number of for principal components computed from a set of covariates to estimate the unknown regression coefficients in the model. <code>pcNet</code> function computes the PCR coefficients for each gene one at a time using all the others as covariates, to construct an all by all gene regulatory network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcNet(
  X,
  nComp = 3,
  scaleScores = TRUE,
  symmetric = FALSE,
  q = 0,
  verbose = TRUE,
  nCores = parallel::detectCores()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcNet_+3A_x">X</code></td>
<td>
<p>A filtered and normalized gene expression matrix with cells as columns and genes as rows.</p>
</td></tr>
<tr><td><code id="pcNet_+3A_ncomp">nComp</code></td>
<td>
<p>An integer value. The number of principal components in PCA to generate the networks. Should be greater than 2 and lower than the total number of genes.</p>
</td></tr>
<tr><td><code id="pcNet_+3A_scalescores">scaleScores</code></td>
<td>
<p>A boolean value (<code>TRUE/FALSE</code>), if <code>TRUE</code>, the weights will be normalized such that the maximum absolute value is 1.</p>
</td></tr>
<tr><td><code id="pcNet_+3A_symmetric">symmetric</code></td>
<td>
<p>A boolean value (<code>TRUE/FALSE</code>), if <code>TRUE</code>, the weights matrix returned will be symmetric.</p>
</td></tr>
<tr><td><code id="pcNet_+3A_q">q</code></td>
<td>
<p>A decimal value between 0 and 1. Defines the cut-off threshold of top q% relationships to be returned.</p>
</td></tr>
<tr><td><code id="pcNet_+3A_verbose">verbose</code></td>
<td>
<p>A boolean value (<code>TRUE/FALSE</code>), if <code>TRUE</code>, a progress bar is shown.</p>
</td></tr>
<tr><td><code id="pcNet_+3A_ncores">nCores</code></td>
<td>
<p>An integer value. Defines the number of cores to be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Principal component regression may be broadly divided into three major steps: </p>

<ol>
<li><p> Perform PCA on the observed covariates data matrix to obtain <code>nComp</code> number of the principal components.
</p>
</li>
<li><p> Regress the observed vector of outcomes on the selected principal components as covariates, using ordinary least squares regression to get a vector of estimated regression coefficients
</p>
</li>
<li><p> Transform this vector back to the scale of the actual covariates, using the eigenvectors corresponding to the selected principal components to get the final PCR estimator for estimating the regression coefficients characterizing the original model.
</p>
</li></ol>



<h3>Value</h3>

<p>A gene regulatory network in dgCMatrix format.
</p>


<h3>References</h3>


<ul>
<li><p> Gill, Ryan, Somnath Datta, and Susmita Datta. &quot;dna: An R package for differential network analysis.&quot; Bioinformation 10.4 (2014): 233.
</p>
</li>
<li><p> Jolliffe, Ian T. &quot;A note on the use of principal components in regression.&quot; Journal of the Royal Statistical Society: Series C (Applied Statistics) 31.3 (1982): 300-303.
</p>
</li>
<li><p> Massy, William F. &quot;Principal components regression in exploratory statistical research.&quot; Journal of the American Statistical Association 60.309 (1965): 234-256.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(scTenifoldNet)

# Simulating of a dataset following a negative binomial distribution with high sparcity (~67%)
nCells = 2000
nGenes = 100
set.seed(1)
X &lt;- rnbinom(n = nGenes * nCells, size = 20, prob = 0.98)
X &lt;- round(X)
X &lt;- matrix(X, ncol = nCells)
rownames(X) &lt;- c(paste0('ng', 1:90), paste0('mt-', 1:10))

# Performing Single cell quality control
qcOutput &lt;- scQC(
  X = X,
  minLibSize = 30,
  removeOutlierCells = TRUE,
  minPCT = 0.05,
  maxMTratio = 0.1
)

# Computing a single-cell gene regulatory network using principal component regression
# Non-symmetric
pcnetOutput &lt;- pcNet(X = qcOutput, nComp = 3, scaleScores = TRUE, symmetric = FALSE, q = 0)
pcnetOutput[1:10,1:10]

# Symmetric
pcnetOutput &lt;- pcNet(X = qcOutput, nComp = 3, scaleScores = TRUE, symmetric = TRUE, q = 0)
pcnetOutput[1:5,1:5]
</code></pre>

<hr>
<h2 id='scQC'>Performs single-cell data quality control</h2><span id='topic+scQC'></span>

<h3>Description</h3>

<p>This function performs quality control filters over the provided input matrix, the function checks for minimum cell library size, mitochondrial ratio, outlier cells, and the fraction of cells where a gene is expressed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scQC(
  X,
  minLibSize = 1000,
  removeOutlierCells = TRUE,
  minPCT = 0.05,
  maxMTratio = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scQC_+3A_x">X</code></td>
<td>
<p>Raw counts matrix with cells as columns and genes (symbols) as rows.</p>
</td></tr>
<tr><td><code id="scQC_+3A_minlibsize">minLibSize</code></td>
<td>
<p>An integer value. Defines the minimum library size required for a cell to be included in the analysis.</p>
</td></tr>
<tr><td><code id="scQC_+3A_removeoutliercells">removeOutlierCells</code></td>
<td>
<p>A boolean value (<code>TRUE/FALSE</code>), if <code>TRUE</code>, the identified cells with library size greater than 1.58 IQR/sqrt(n) computed from the sample, are removed. For further details see: <code>?boxplot.stats</code></p>
</td></tr>
<tr><td><code id="scQC_+3A_minpct">minPCT</code></td>
<td>
<p>A decimal value between 0 and 1. Defines the minimum fraction of cells where the gene needs to be expressed to be included in the analysis.</p>
</td></tr>
<tr><td><code id="scQC_+3A_maxmtratio">maxMTratio</code></td>
<td>
<p>A decimal value between 0 and 1. Defines the maximum ratio of mitochondrial reads (mithocondrial reads / library size) present in a cell to be included in the analysis. It's computed using the symbol genes starting with 'MT-' non-case sensitive.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dgCMatrix object with the cells and the genes that pass the quality control filters.
</p>


<h3>References</h3>

<p>Ilicic, Tomislav, et al. &quot;Classification of low quality cells from single-cell RNA-seq data.&quot; Genome biology 17.1 (2016): 29.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(scTenifoldNet)

# Simulating of a dataset following a negative binomial distribution with high sparcity (~67%)
nCells = 2000
nGenes = 100
set.seed(1)
X &lt;- rnbinom(n = nGenes * nCells, size = 20, prob = 0.98)
X &lt;- round(X)
X &lt;- matrix(X, ncol = nCells)
rownames(X) &lt;- c(paste0('ng', 1:90), paste0('mt-', 1:10))

# Performing Single cell quality control
qcOutput &lt;- scQC(
  X = X,
  minLibSize = 30,
  removeOutlierCells = TRUE,
  minPCT = 0.05,
  maxMTratio = 0.1
)

# Visualizing the Differences
oldPar &lt;- par(no.readonly = TRUE)

par(
  mfrow = c(2, 2),
  mar = c(3, 3, 1, 1),
  mgp = c(1.5, 0.5, 0)
)
# Library Size
plot(
  Matrix::colSums(X),
  ylim = c(20, 70),
  ylab = 'Library Size',
 xlab = 'Cell',
  main = 'Library Size - Before QC'
)
abline(h = c(30, 58),
       lty = 2,
       col = 'red')
plot(
  Matrix::colSums(qcOutput),
  ylim = c(20, 70),
  ylab = 'Library Size',
  xlab = 'Cell',
  main = 'Library Size - After QC'
)
abline(h = c(30, 58),
       lty = 2,
       col = 'red')
# Mitochondrial ratio
mtGenes &lt;- grepl('^mt-', rownames(X), ignore.case = TRUE)
plot(
  Matrix::colSums(X[mtGenes,]) / Matrix::colSums(X),
  ylim = c(0, 0.3),
  ylab = 'Mitochondrial Ratio',
  xlab = 'Cell',
  main = 'Mitochondrial Ratio - Before QC'
)
abline(h = c(0.1), lty = 2, col = 'red')
plot(
  Matrix::colSums(qcOutput[mtGenes,]) / Matrix::colSums(qcOutput),
  ylim = c(0, 0.3),
  ylab = 'Mitochondrial Ratio',
  xlab = 'Cell',
  main = 'Mitochondrial Ratio - Before QC'
)
abline(h = c(0.1), lty = 2, col = 'red')

par(oldPar)
</code></pre>

<hr>
<h2 id='scTenifoldNet'>scTenifoldNet</h2><span id='topic+scTenifoldNet'></span>

<h3>Description</h3>

<p>Construct and compare single-cell gene regulatory networks (scGRNs) using single-cell RNA-seq (scRNA-seq) data sets collected from different conditions based on principal component regression, tensor decomposition, and manifold alignment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scTenifoldNet(
  X,
  Y,
  qc = TRUE,
  qc_minLibSize = 1000,
  qc_removeOutlierCells = TRUE,
  qc_minPCT = 0.05,
  qc_maxMTratio = 0.1,
  nc_nNet = 10,
  nc_nCells = 500,
  nc_nComp = 3,
  nc_symmetric = FALSE,
  nc_scaleScores = TRUE,
  nc_q = 0.05,
  td_K = 3,
  td_nDecimal = 1,
  td_maxIter = 1000,
  td_maxError = 1e-05,
  ma_nDim = 30,
  nCores = parallel::detectCores()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scTenifoldNet_+3A_x">X</code></td>
<td>
<p>Raw counts matrix with cells as columns and genes (symbols) as rows.</p>
</td></tr>
<tr><td><code id="scTenifoldNet_+3A_y">Y</code></td>
<td>
<p>Raw counts matrix with cells as columns and genes (symbols) as rows.</p>
</td></tr>
<tr><td><code id="scTenifoldNet_+3A_qc">qc</code></td>
<td>
<p>A boolean value (TRUE/FALSE), if TRUE, a quality control is applied over the data.</p>
</td></tr>
<tr><td><code id="scTenifoldNet_+3A_qc_minlibsize">qc_minLibSize</code></td>
<td>
<p>An integer value. Defines the minimum library size required for a cell to be included in the analysis.</p>
</td></tr>
<tr><td><code id="scTenifoldNet_+3A_qc_removeoutliercells">qc_removeOutlierCells</code></td>
<td>
<p>A boolean value (TRUE/FALSE), if TRUE, the identified cells with library size greater than 1.58 IQR/sqrt(n) computed from the sample, are removed. For further details see: <code>?boxplot.stats</code></p>
</td></tr>
<tr><td><code id="scTenifoldNet_+3A_qc_minpct">qc_minPCT</code></td>
<td>
<p>A decimal value between 0 and 1. Defines the minimum fraction of cells where the gene needs to be expressed to be included in the analysis.</p>
</td></tr>
<tr><td><code id="scTenifoldNet_+3A_qc_maxmtratio">qc_maxMTratio</code></td>
<td>
<p>A decimal value between 0 and 1. Defines the maximum ratio of mitochondrial reads (mithocondrial reads / library size) present in a cell to be included in the analysis. It's computed using the symbol genes starting with 'MT-' non-case sensitive.</p>
</td></tr>
<tr><td><code id="scTenifoldNet_+3A_nc_nnet">nc_nNet</code></td>
<td>
<p>An integer value. The number of networks based on principal components regression to generate.</p>
</td></tr>
<tr><td><code id="scTenifoldNet_+3A_nc_ncells">nc_nCells</code></td>
<td>
<p>An integer value. The number of cells to subsample each time to generate a network.</p>
</td></tr>
<tr><td><code id="scTenifoldNet_+3A_nc_ncomp">nc_nComp</code></td>
<td>
<p>An integer value. The number of principal components in PCA to generate the networks. Should be greater than 2 and lower than the total number of genes.</p>
</td></tr>
<tr><td><code id="scTenifoldNet_+3A_nc_symmetric">nc_symmetric</code></td>
<td>
<p>A boolean value (TRUE/FALSE), if TRUE, the weights matrix returned will be symmetric.</p>
</td></tr>
<tr><td><code id="scTenifoldNet_+3A_nc_scalescores">nc_scaleScores</code></td>
<td>
<p>A boolean value (TRUE/FALSE), if TRUE, the weights will be normalized such that the maximum absolute value is 1.</p>
</td></tr>
<tr><td><code id="scTenifoldNet_+3A_nc_q">nc_q</code></td>
<td>
<p>A decimal value between 0 and 1. Defines the cut-off threshold of top q% relationships to be returned.</p>
</td></tr>
<tr><td><code id="scTenifoldNet_+3A_td_k">td_K</code></td>
<td>
<p>An integer value. Defines the number of rank-one tensors used to approximate the data using CANDECOMP/PARAFAC (CP) Tensor Decomposition.</p>
</td></tr>
<tr><td><code id="scTenifoldNet_+3A_td_ndecimal">td_nDecimal</code></td>
<td>
<p>An integer value indicating the number of decimal places to be used.</p>
</td></tr>
<tr><td><code id="scTenifoldNet_+3A_td_maxiter">td_maxIter</code></td>
<td>
<p>An integer value. Defines the maximum number of iterations if error stay above <code>td_maxError</code>.</p>
</td></tr>
<tr><td><code id="scTenifoldNet_+3A_td_maxerror">td_maxError</code></td>
<td>
<p>A decimal value between 0 and 1. Defines the relative Frobenius norm error tolerance.</p>
</td></tr>
<tr><td><code id="scTenifoldNet_+3A_ma_ndim">ma_nDim</code></td>
<td>
<p>An integer value. Defines the number of dimensions of the low-dimensional feature space to be returned from the non-linear manifold alignment.</p>
</td></tr>
<tr><td><code id="scTenifoldNet_+3A_ncores">nCores</code></td>
<td>
<p>An integer value. Defines the number of cores to be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 3 slots as follows: 
</p>

<ul>
<li><p>tensorNetworks: The generated weight-averaged denoised gene regulatory networks using CANDECOMP/PARAFAC (CP) Tensor Decomposition.
</p>
</li>
<li><p>manifoldAlignment: The generated low-dimensional features result of the non-linear manifold alignment.
</p>
</li>
<li><p>diffRegulation The results of the differential regulation analysis.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(scTenifoldNet)

# Simulating of a dataset following a negative binomial distribution with high sparcity (~67%)
nCells = 2000
nGenes = 100
set.seed(1)
X &lt;- rnbinom(n = nGenes * nCells, size = 20, prob = 0.98)
X &lt;- round(X)
X &lt;- matrix(X, ncol = nCells)
rownames(X) &lt;- c(paste0('ng', 1:90), paste0('mt-', 1:10))

# Generating a perturbed network modifying the expression of genes 10, 2 and 3
Y &lt;- X
Y[10,] &lt;- Y[50,]
Y[2,] &lt;- Y[11,]
Y[3,] &lt;- Y[5,]

## Not run: 
# scTenifoldNet
Output &lt;- scTenifoldNet(X = X, Y = Y,
                       nc_nNet = 10, nc_nCells = 500,
                       td_K = 3, qc_minLibSize = 30)

# Structure of the output
str(Output)

# Accessing the computed weight-averaged denoised gene regulatory networks

# Network for sample X
igraph::graph_from_adjacency_matrix(adjmatrix = Output$tensorNetworks$X, weighted = TRUE)
# IGRAPH 15cbeea DNW- 100 2836 -- 
# + attr: name (v/c), weight (e/n)
# + edges from 15cbeea (vertex names):
#   [1] ng6 -&gt;ng1 ng12-&gt;ng1 ng14-&gt;ng1 ng24-&gt;ng1 ng28-&gt;ng1
# [6] ng31-&gt;ng1 ng42-&gt;ng1 ng44-&gt;ng1 ng49-&gt;ng1 ng55-&gt;ng1
# [11] ng56-&gt;ng1 ng59-&gt;ng1 ng62-&gt;ng1 ng63-&gt;ng1 ng72-&gt;ng1
# [16] ng73-&gt;ng1 ng74-&gt;ng1 ng77-&gt;ng1 ng80-&gt;ng1 ng82-&gt;ng1
# [21] ng83-&gt;ng1 ng87-&gt;ng1 ng89-&gt;ng1 mt-1-&gt;ng1 mt-5-&gt;ng1
# [26] mt-7-&gt;ng1 ng27-&gt;ng3 ng28-&gt;ng3 ng31-&gt;ng3 ng32-&gt;ng3
# [31] ng44-&gt;ng3 ng59-&gt;ng3 ng62-&gt;ng3 ng72-&gt;ng3 ng73-&gt;ng3
# [36] ng74-&gt;ng3 ng77-&gt;ng3 ng82-&gt;ng3 ng87-&gt;ng3 ng89-&gt;ng3
# + ... omitted several edges

# Network for sample Y
igraph::graph_from_adjacency_matrix(adjmatrix = Output$tensorNetworks$Y, weighted = TRUE)
#IGRAPH 3ad1533 DNW- 100 725 -- 
# + attr: name (v/c), weight (e/n)
# + edges from 3ad1533 (vertex names):
#   [1] ng2 -&gt;ng2 ng3 -&gt;ng2 ng5 -&gt;ng2 ng6 -&gt;ng2
# [5] ng7 -&gt;ng2 ng8 -&gt;ng2 ng9 -&gt;ng2 ng10-&gt;ng2
# [9] ng11-&gt;ng2 ng12-&gt;ng2 ng13-&gt;ng2 ng15-&gt;ng2
# [13] ng16-&gt;ng2 ng17-&gt;ng2 ng18-&gt;ng2 ng20-&gt;ng2
# [17] ng21-&gt;ng2 ng22-&gt;ng2 ng23-&gt;ng2 ng24-&gt;ng2
# [21] ng25-&gt;ng2 ng26-&gt;ng2 ng28-&gt;ng2 ng29-&gt;ng2
# [25] ng30-&gt;ng2 ng31-&gt;ng2 ng33-&gt;ng2 ng34-&gt;ng2
# [29] ng35-&gt;ng2 ng36-&gt;ng2 ng38-&gt;ng2 ng39-&gt;ng2
# + ... omitted several edges

# Accessing the manifold alignment result

head(Output$manifoldAlignment)
#            NLMA 1      NLMA 2      NLMA 3       NLMA 4        NLMA 5
# X_ng1  0.0068499391  0.01096706  0.03077900  0.002655469 -0.0136455614
# X_ng2  0.3356288575 -0.03551752 -0.18463680 -0.193353751  0.3398606363
# X_ng3 -0.1285177133 -0.20064344  0.20926567  0.059542294 -0.0099528441
# X_ng4  0.0029881645 -0.01267593  0.01195683  0.007331123  0.0003031888
# X_ng5 -0.1192632208 -0.18475439  0.27616148  0.112944009 -0.0281827702
# X_ng6  0.0005911568  0.02557475  0.07527792 -0.191180647 -0.1165095115
#            NLMA 6      NLMA 7       NLMA 8       NLMA 9     NLMA 10
# X_ng1 -0.029852128 0.007539925  0.009299591 -0.009813157 -0.01360414
# X_ng2 -0.313361443 0.146429589  0.006286777  0.162023788 -0.04307899
# X_ng3 -0.008733285 0.172084611  0.508056218  0.199322512 -0.07935797
# X_ng4 -0.004680652 0.005344541  0.002634755 -0.003376544 -0.01100757
# X_ng5 -0.126328797 0.190769152 -0.468107666  0.170278281 -0.06744795
# X_ng6 -0.051266264 0.063822269  0.011060924 -0.134880459 -0.02579998
#           NLMA 11      NLMA 12      NLMA 13      NLMA 14      NLMA 15
# X_ng1 -0.0199528840  0.008035130  0.004631187  0.000807797  0.011960838
# X_ng2 -0.0138200390 -0.002847701 -0.004404942  0.008024704  0.006040799
# X_ng3  0.0232384468 -0.031398116 -0.007026934  0.028956700 -0.002112626
# X_ng4  0.0012864539 -0.018915289  0.003835404  0.004054159 -0.002546324
# X_ng5  0.0232899093 -0.040974531 -0.006759459  0.025415953 -0.007518957
# X_ng6 -0.0001650355  0.023277338  0.006646904 -0.002683418 -0.112688129
#          NLMA 16      NLMA 17     NLMA 18      NLMA 19       NLMA 20
# X_ng1 -0.016962988 -0.016649748  0.01140020 -0.006632691 -0.0005015655
# X_ng2  0.007543775 -0.016188689  0.02517684  0.014814415  0.0162617154
# X_ng3 -0.005598267 -0.006975026  0.05218029  0.006731063  0.0183436415
# X_ng4  0.003207934 -0.001784120  0.01093237 -0.001192860  0.0028746990
# X_ng5 -0.009555879 -0.007429166  0.05206441  0.006534604  0.0170071357
# X_ng6 -0.065437425  0.110728870 -0.12746932  0.335610531  0.1341842827
#          NLMA 21      NLMA 22      NLMA 23      NLMA 24      NLMA 25
# X_ng1  0.003113385 -0.023311350 -0.026415944 7.085995e-04  0.053898102
# X_ng2  0.001390569  0.001191301 -0.015621435 2.359703e-03 -0.013418093
# X_ng3 -0.007483171  0.011496519  0.004164546 2.764407e-02 -0.004527981
# X_ng4  0.020316634 -0.002796092  0.032119363 4.203867e-05 -0.002251366
# X_ng5 -0.004963436  0.016525449  0.009683698 2.564700e-02  0.002286340
# X_ng6  0.229199525  0.340639745 -0.041216345 3.599596e-03  0.008572652
#          NLMA 26       NLMA 27      NLMA 28     NLMA 29      NLMA 30
# X_ng1  0.065832029 -0.0080248854  0.107300843 -0.02902323 -0.005337500
# X_ng2 -0.007982259 -0.0026295392 -0.001765851  0.01491257 -0.003546343
# X_ng3  0.009770602  0.0008819272  0.014564070 -0.01568192 -0.017450667
# X_ng4  0.015802609  0.0012975576 -0.003406675 -0.01774975 -0.003300053
# X_ng5  0.003401007  0.0001761177  0.013622016 -0.01224127 -0.013909178
# X_ng6 -0.089450710 -0.0763838722 -0.107751916 -0.05841353 -0.059217012

# Differential Regulation
head(Output$diffRegulation,n = 10)
# gene    distance        Z        FC      p.value      p.adj
# 2   ng2 0.023526702 2.762449 12.193413 0.0004795855 0.02414332
# 50 ng50 0.023514429 2.761550 12.180695 0.0004828665 0.02414332
# 11 ng11 0.022443941 2.681598 11.096894 0.0008647241 0.02882414
# 3   ng3 0.020263415 2.508478  9.045415 0.0026335445 0.06583861
# 10 ng10 0.019194561 2.417929  8.116328 0.0043868326 0.07711821
# 5   ng5 0.019079975 2.407977  8.019712 0.0046270923 0.07711821
# 31 ng31 0.013632541 1.865506  4.094085 0.0430335257 0.61476465
# 96 mt-6 0.011401177 1.589757  2.863536 0.0906081350 0.90977795
# 59 ng59 0.009835354 1.368238  2.130999 0.1443466682 0.90977795
# 62 ng62 0.007995812 1.067193  1.408408 0.2353209153 0.90977795

# Plotting
# Genes with FDR &lt; 0.1 are labeled as red
set.seed(1)
qChisq &lt;- rchisq(100,1)
geneColor &lt;- rev(ifelse(Output$diffRegulation$p.adj &lt; 0.1, 10,1))
qqplot(qChisq, Output$diffRegulation$FC, pch = 16, main = 'H0', col = geneColor, 
       xlab = expression(X^2~Quantiles), ylab = 'FC', xlim=c(0,8), ylim=c(0,13))
qqline(qChisq)
legend('bottomright', legend = c('FDR &lt; 0.1'), pch = 16, col = 'red', bty='n', cex = 0.7)

## End(Not run)
</code></pre>

<hr>
<h2 id='tensorDecomposition'>Performs CANDECOMP/PARAFAC (CP) Tensor Decomposition.</h2><span id='topic+tensorDecomposition'></span>

<h3>Description</h3>

<p>Generate weight-averaged denoised gene regulatory networks using CANDECOMP/PARAFAC (CP) Tensor Decomposition. The <code>tensorDecomposition</code> function takes one or two lists of gene regulatory matrices, if two list are provided, the shared genes are selected and the CP tensor decomposition is performed independently for each list (3d-tensor). The tensor decomposed matrices are then averaged to generate weight-averaged denoised networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tensorDecomposition(
  xList,
  yList = NULL,
  nDecimal = 1,
  K = 5,
  maxError = 1e-05,
  maxIter = 1000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tensorDecomposition_+3A_xlist">xList</code></td>
<td>
<p>A list of gene regulatory networks.</p>
</td></tr>
<tr><td><code id="tensorDecomposition_+3A_ylist">yList</code></td>
<td>
<p>Optional. A list of gene regulatory networks.</p>
</td></tr>
<tr><td><code id="tensorDecomposition_+3A_ndecimal">nDecimal</code></td>
<td>
<p>An integer value indicating the number of decimal places to be used.</p>
</td></tr>
<tr><td><code id="tensorDecomposition_+3A_k">K</code></td>
<td>
<p>The number of rank-one tensors used to approximate the data using CANDECOMP/PARAFAC (CP) Tensor Decomposition,</p>
</td></tr>
<tr><td><code id="tensorDecomposition_+3A_maxerror">maxError</code></td>
<td>
<p>A decimal value between 0 and 1. Defines the relative Frobenius norm error tolerance</p>
</td></tr>
<tr><td><code id="tensorDecomposition_+3A_maxiter">maxIter</code></td>
<td>
<p>An integer value. Defines the maximum number of iterations if error stay above <code>maxError</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>CANDECOMP/PARAFRAC (CP) tensor decomposition approximate a K-Tensor using a sum of <code>K</code> rank-1 K-Tensors. A rank-1 K-Tensor can be written as an outer product of K vectors. This is an iterative algorithm, with two possible stopping conditions: either relative error in Frobenius norm has gotten below <code>maxError</code>, or the <code>maxIter</code> number of iterations has been reached. For more details on CP decomposition, consult Kolda and Bader (2009) and Morup (2011).
</p>


<h3>Value</h3>

<p>A list of weight-averaged denoised gene regulatory networks.
</p>


<h3>Author(s)</h3>

<p>This is an adaptation of the code provided by Li, J., Bien, J., &amp; Wells, M. T. (2018)
</p>


<h3>References</h3>


<ul>
<li><p> Li, J., Bien, J., &amp; Wells, M. T. (2018). rTensor: An R Package for Multidimensional Array (Tensor) Unfolding, Multiplication, and Decomposition. Journal of Statistical Software, 87(10), 1-31.
</p>
</li>
<li><p> Kolda, Tamara G., and Brett W. Bader. &quot;Tensor decompositions and applications.&quot; SIAM review 51.3 (2009): 455-500.
</p>
</li>
<li><p> Morup, Morten. &quot;Applications of tensor (multiway array) factorizations and decompositions in data mining.&quot; Wiley Interdisciplinary Reviews: Data Mining and Knowledge Discovery 1.1 (2011): 24-40.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(scTenifoldNet)

# Simulating of a dataset following a negative binomial distribution with high sparcity (~67%)
nCells = 2000
nGenes = 100
set.seed(1)
X &lt;- rnbinom(n = nGenes * nCells, size = 20, prob = 0.98)
X &lt;- round(X)
X &lt;- matrix(X, ncol = nCells)
rownames(X) &lt;- c(paste0('ng', 1:90), paste0('mt-', 1:10))

# Performing Single cell quality control
qcOutput &lt;- scQC(
  X = X,
  minLibSize = 30,
  removeOutlierCells = TRUE,
  minPCT = 0.05,
  maxMTratio = 0.1
)

# Computing 3 single-cell gene regulatory networks each one from a subsample of 500 cells
mnOutput &lt;- makeNetworks(X = X,
                         nNet = 3, 
                         nCells = 500, 
                         nComp = 3, 
                         scaleScores = TRUE, 
                         symmetric = FALSE, 
                         q = 0.95
                         )

# Computing a K = 3 CANDECOMP/PARAFAC (CP) Tensor Decomposition
tdOutput &lt;- tensorDecomposition(mnOutput, K = 3, maxError = 1e5, maxIter = 1e3)

# Verifying the number of networks
length(tdOutput)

# Veryfying the dimention of the networks
lapply(tdOutput,dim)

# Weight-averaged denoised single-cell gene regulatory networks
tdOutput[[1]][1:10,1:10]
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
