<!DOCTYPE html><html lang="en-GB"><head><title>Help for package sonicscrewdriver</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sonicscrewdriver}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#-+2CPseudoWave+2Cnumeric-method'><p>PseudoWave scalar subtraction</p></a></li>
<li><a href='#+5B+2CWave+2CTimeRegion-method'><p>Allow subsetting a Wave object with a TimeRegion</p></a></li>
<li><a href='#+2A+2Cnumeric+2CPseudoWave-method'><p>Numeric multiplication by PseudoWave</p></a></li>
<li><a href='#+2A+2CPseudoWave+2Cnumeric-method'><p>PseudoWave scalar manipulation</p></a></li>
<li><a href='#+2F+2CPseudoWave+2Cnumeric-method'><p>PseudoWave scalar division</p></a></li>
<li><a href='#+2B+2Cnumeric+2CPseudoWave-method'><p>Numeric addition by PseudoWave</p></a></li>
<li><a href='#+2B+2CPseudoWave+2Cnumeric-method'><p>PseudoWave scalar addition</p></a></li>
<li><a href='#ab_diel_traits'><p>Convert text times of day in audioblast traits to numeric values</p></a></li>
<li><a href='#ab_seqss_nearestStart'><p>Nearest start time</p></a></li>
<li><a href='#addProcess'><p>Add a process to a Tagged Wave or WaveMC object</p></a></li>
<li><a href='#addSpectra'><p>Add two spectra from seewave</p></a></li>
<li><a href='#allChannels'><p>Apply a function to all channels of a Wave or WaveMC object</p></a></li>
<li><a href='#annotation'><p>Create a new Annotation object</p></a></li>
<li><a href='#Annotation-class'><p>A S4 class for annotations</p></a></li>
<li><a href='#audio_filesize'><p>Calculated size of raw audio files</p></a></li>
<li><a href='#audioblast'><p>Get data or analyses from audioBlast</p></a></li>
<li><a href='#audioblastDownload'><p>Download audio files from audioBlast</p></a></li>
<li><a href='#audiomothConfig'><p>Read AudioMoth configuration file</p></a></li>
<li><a href='#audiomothWave'><p>Read AudioMoth metadata from a wave file</p></a></li>
<li><a href='#autoBandPass'><p>Automatic Band Pass Filter</p></a></li>
<li><a href='#bandpass'><p>Simple bandpass filter</p></a></li>
<li><a href='#beatComplexity'><p>Beat spectrum complexity</p></a></li>
<li><a href='#beatSpectrum'><p>Computes a beat spectrum</p></a></li>
<li><a href='#birdNetAnalyse'><p>Analyse sound files using BirdNET-Analyzer</p></a></li>
<li><a href='#birdNetInstall'><p>Install the BirdNET environment</p></a></li>
<li><a href='#channels_se'><p>Channels for sound ecology</p></a></li>
<li><a href='#circularise'><p>Circularise a dataset</p></a></li>
<li><a href='#concat'><p>Concatenate two or more Wave-like objects.</p></a></li>
<li><a href='#convert2bytes'><p>Convert bits to bytes</p></a></li>
<li><a href='#convert2Celsius'><p>Convert temperature to Celsius</p></a></li>
<li><a href='#convert2degrees'><p>Convert angle to degrees</p></a></li>
<li><a href='#convert2dyne_cm2'><p>Convert pressure to dyne per square centimetre</p></a></li>
<li><a href='#convert2Fahrenheit'><p>Convert temperature to Fahrenheit</p></a></li>
<li><a href='#convert2Kelvin'><p>Convert temperature to Kelvin</p></a></li>
<li><a href='#convert2Pascals'><p>Convert pressure to Pascals</p></a></li>
<li><a href='#convert2radians'><p>Convert angle to radians</p></a></li>
<li><a href='#convert2seconds'><p>Convert time to seconds</p></a></li>
<li><a href='#corWaveMC'><p>Correlate channels in a WaveMC object</p></a></li>
<li><a href='#cutws'><p>Cut wave by samples</p></a></li>
<li><a href='#data2Wave'><p>Convert data into a Wave object</p></a></li>
<li><a href='#dayPhase'><p>Phase of day</p></a></li>
<li><a href='#dayPhases'><p>Phases of day</p></a></li>
<li><a href='#daysPhases'><p>Phases of days</p></a></li>
<li><a href='#defaultCluster'><p>Create Default Cluster for Windowing</p></a></li>
<li><a href='#dielFraction'><p>Calculate the fraction of a day given by a value</p></a></li>
<li><a href='#dielHistogram'><p>Diel Histogram</p></a></li>
<li><a href='#dielLabels'><p>Generate labels for a diel plot</p></a></li>
<li><a href='#dielPlot'><p>Create a diel plot</p></a></li>
<li><a href='#dielPositions'><p>Generate positions of labels for a diel plot</p></a></li>
<li><a href='#dielRings'><p>Plot rings on a diel plot</p></a></li>
<li><a href='#dolbear'><p>Dolbear's law</p></a></li>
<li><a href='#dutyCycle'><p>Calculate the duty cycle of a wave</p></a></li>
<li><a href='#emptyDiel'><p>Create an empty diel plot</p></a></li>
<li><a href='#emptyYearly'><p>Create an empty yearly plot</p></a></li>
<li><a href='#entropyStats'><p>Various measurements of frequency values for a Wave object</p></a></li>
<li><a href='#filterWave'><p>Apply a WaveFilter object to a Wave object</p></a></li>
<li><a href='#frequencySound'><p>Get the frequency from wavelength and speed of sound</p></a></li>
<li><a href='#frequencyStats'><p>Various measurements of frequency values for a Wave object</p></a></li>
<li><a href='#generateNoise'><p>Add noise to a Wave like object</p></a></li>
<li><a href='#generateTimeMask'><p>Generate time masked Wave-like objects</p></a></li>
<li><a href='#generateTimeShift'><p>Generated time-shifted versions of a Wave-like object</p></a></li>
<li><a href='#gs_transcribe'><p>Google Speech API Transcribe</p></a></li>
<li><a href='#humanBytes'><p>Converts bytes in human readable form</p></a></li>
<li><a href='#humanTime'><p>Converts time to human readable form</p></a></li>
<li><a href='#jitter'><p>Calculate the jitter in a Wave object</p></a></li>
<li><a href='#labelPadding'><p>Pad labels with interval</p></a></li>
<li><a href='#labelReduction'><p>Combines labels which overlap into single continuous regions</p></a></li>
<li><a href='#map2RGB'><p>Map three vectors to RGB</p></a></li>
<li><a href='#naturalFrequency'><p>Calculate the natural frequency</p></a></li>
<li><a href='#normalise'><p>Normalise a Wave object</p></a></li>
<li><a href='#ntd'><p>Natural Time Domain</p></a></li>
<li><a href='#parseFilename'><p>Parse a filename</p></a></li>
<li><a href='#pd_dietrich2004'><p>Pulse detection using Dietrich (2004)</p></a></li>
<li><a href='#pd_simple'><p>Simplified pulse detection using Dietrich (2004)</p></a></li>
<li><a href='#pseudoWave'><p>Create a PseudoWave object</p></a></li>
<li><a href='#PseudoWave-class'><p>An S4 class to represent a PseudoWave object that is converted to a</p>
Wave object when operated on.</a></li>
<li><a href='#pulse'><p>Generate a single pulse</p></a></li>
<li><a href='#pulseDetection'><p>Pulse detection</p></a></li>
<li><a href='#pulseIntervals'><p>Pulse intervals</p></a></li>
<li><a href='#radarPower'><p>The radar equation</p></a></li>
<li><a href='#radarRange'><p>Radar range</p></a></li>
<li><a href='#radialPolygon'><p>Plot a radial polygon</p></a></li>
<li><a href='#rainfallDetection'><p>Rainfall detection</p></a></li>
<li><a href='#readAudacityLabels'><p>Read an Audacity label file</p></a></li>
<li><a href='#readAudio'><p>Read an audio file</p></a></li>
<li><a href='#readBirdNet'><p>Read output files from BirdNet Analyser</p></a></li>
<li><a href='#readRespeaker6'><p>Read a file from Seeed Studio Respeaker 6 mic array</p></a></li>
<li><a href='#referenceIntensity'><p>Reference intensity</p></a></li>
<li><a href='#referencePressure'><p>Reference pressure</p></a></li>
<li><a href='#region'><p>Specify a region with a file to analyse</p></a></li>
<li><a href='#resonantFrequency'><p>Calculate the resonant frequency</p></a></li>
<li><a href='#sDuration'><p>Sample duration</p></a></li>
<li><a href='#sheepFrequencyStats'><p>Sheep frequencyStats</p></a></li>
<li><a href='#shimmer'><p>Calculate the shimmer in a Wave object</p></a></li>
<li><a href='#soundSpeed'><p>Calculate the speed of sound in a medium</p></a></li>
<li><a href='#specStats'><p>Calculate and plot statistics on a  frequency spectrum</p></a></li>
<li><a href='#ste'><p>Short term energy</p></a></li>
<li><a href='#STP'><p>STP: Standard Temperature and Pressure</p></a></li>
<li><a href='#subtractSpectra'><p>Subtract two spectra from seewave</p></a></li>
<li><a href='#sweptsine'><p>Generate a sine sweep</p></a></li>
<li><a href='#TaggedWave-class'><p>A S4 class for tagged waves</p></a></li>
<li><a href='#TaggedWaveMC-class'><p>A S4 class for tagged multi-channel waves</p></a></li>
<li><a href='#tagWave'><p>Tag a Wave or WaveMC object</p></a></li>
<li><a href='#TimeRegion-class'><p>An S4 class to represent a TimeRegion within a Wave object.</p></a></li>
<li><a href='#tSamples'><p>Samples per time period</p></a></li>
<li><a href='#typicalVolume'><p>Typical volumes</p></a></li>
<li><a href='#tzRot'><p>Converts a timezone offset into a rotation</p></a></li>
<li><a href='#untagWave'><p>Untag a TaggedWave or TaggedWaveMC object</p></a></li>
<li><a href='#upsample'><p>Upsample a wave</p></a></li>
<li><a href='#validateIsWave'><p>Check an object is a Wave object</p></a></li>
<li><a href='#WaveFilter-class'><p>WaveFilter object for audio filters</p></a></li>
<li><a href='#windowing'><p>Windowing Function for Wave Objects</p></a></li>
<li><a href='#writeAudacityLabels'><p>Write an Audacity label file</p></a></li>
<li><a href='#yearlyFraction'><p>Calculate the fraction of a year given by a value</p></a></li>
<li><a href='#yearlyLabels'><p>Generate labels for a yearly plot</p></a></li>
<li><a href='#yearlyPlot'><p>Create a yearly plot</p></a></li>
<li><a href='#yearlyPositions'><p>Generate positions of labels for a yearly plot</p></a></li>
<li><a href='#zerocross'><p>Identify zero crossings in a Wave object</p></a></li>
<li><a href='#zeroSpectrum'><p>Zero spectrum</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Bioacoustic Analysis and Publication Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.7</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools for manipulating sound files for bioacoustic
  analysis, and preparing analyses these for publication. The package validates
  that values are physically possible wherever feasible. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, ggplot2, hms, jsonlite, mime, Rdpack, seewave,
stringi, suncalc, tuneR</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>Suggests:</td>
<td>av, covr, devtools, googleCloudStorageR, googleLanguageR,
knitr, parallel, pbapply, plotrix, reticulate, rmarkdown,
soundecology, spelling, testthat (&ge; 3.0.0), WaveletComp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://sonicscrewdriver.ebaker.me.uk">https://sonicscrewdriver.ebaker.me.uk</a>,
<a href="https://github.com/edwbaker/SonicScrewdriveR">https://github.com/edwbaker/SonicScrewdriveR</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/edwbaker/SonicScrewdriveR/issues">https://github.com/edwbaker/SonicScrewdriveR/issues</a></td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-11 20:34:31 UTC; edwab</td>
</tr>
<tr>
<td>Author:</td>
<td>Ed Baker <a href="https://orcid.org/0000-0002-5887-9543"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Quentin Geissman [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ed Baker &lt;ed@ebaker.me.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-11 20:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='-+2CPseudoWave+2Cnumeric-method'>PseudoWave scalar subtraction</h2><span id='topic+-+2CPseudoWave+2Cnumeric-method'></span>

<h3>Description</h3>

<p>PseudoWave scalar subtraction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PseudoWave,numeric'
e1 - e2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="-+2B2CPseudoWave+2B2Cnumeric-method_+3A_e1">e1</code></td>
<td>
<p>Input 1</p>
</td></tr>
<tr><td><code id="-+2B2CPseudoWave+2B2Cnumeric-method_+3A_e2">e2</code></td>
<td>
<p>Input 2</p>
</td></tr>
</table>

<hr>
<h2 id='+5B+2CWave+2CTimeRegion-method'>Allow subsetting a Wave object with a TimeRegion</h2><span id='topic++5B+2CWave+2CTimeRegion-method'></span>

<h3>Description</h3>

<p>Allow subsetting a Wave object with a TimeRegion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Wave,TimeRegion'
x[i]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B5B+2B2CWave+2B2CTimeRegion-method_+3A_x">x</code></td>
<td>
<p>Wave Object</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CWave+2B2CTimeRegion-method_+3A_i">i</code></td>
<td>
<p>TimeRegion object</p>
</td></tr>
</table>

<hr>
<h2 id='+2A+2Cnumeric+2CPseudoWave-method'>Numeric multiplication by PseudoWave</h2><span id='topic++2A+2Cnumeric+2CPseudoWave-method'></span>

<h3>Description</h3>

<p>Numeric multiplication by PseudoWave
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numeric,PseudoWave'
e1 * e2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B2A+2B2Cnumeric+2B2CPseudoWave-method_+3A_e1">e1</code></td>
<td>
<p>Input 1</p>
</td></tr>
<tr><td><code id="+2B2A+2B2Cnumeric+2B2CPseudoWave-method_+3A_e2">e2</code></td>
<td>
<p>Input 2</p>
</td></tr>
</table>

<hr>
<h2 id='+2A+2CPseudoWave+2Cnumeric-method'>PseudoWave scalar manipulation</h2><span id='topic++2A+2CPseudoWave+2Cnumeric-method'></span>

<h3>Description</h3>

<p>PseudoWave scalar manipulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PseudoWave,numeric'
e1 * e2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B2A+2B2CPseudoWave+2B2Cnumeric-method_+3A_e1">e1</code></td>
<td>
<p>Input 1</p>
</td></tr>
<tr><td><code id="+2B2A+2B2CPseudoWave+2B2Cnumeric-method_+3A_e2">e2</code></td>
<td>
<p>Input 2</p>
</td></tr>
</table>

<hr>
<h2 id='+2F+2CPseudoWave+2Cnumeric-method'>PseudoWave scalar division</h2><span id='topic++2F+2CPseudoWave+2Cnumeric-method'></span>

<h3>Description</h3>

<p>PseudoWave scalar division
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PseudoWave,numeric'
e1 / e2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B2F+2B2CPseudoWave+2B2Cnumeric-method_+3A_e1">e1</code></td>
<td>
<p>Input 1</p>
</td></tr>
<tr><td><code id="+2B2F+2B2CPseudoWave+2B2Cnumeric-method_+3A_e2">e2</code></td>
<td>
<p>Input 2</p>
</td></tr>
</table>

<hr>
<h2 id='+2B+2Cnumeric+2CPseudoWave-method'>Numeric addition by PseudoWave</h2><span id='topic++2B+2Cnumeric+2CPseudoWave-method'></span>

<h3>Description</h3>

<p>Numeric addition by PseudoWave
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numeric,PseudoWave'
e1 + e2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B2B+2B2Cnumeric+2B2CPseudoWave-method_+3A_e1">e1</code></td>
<td>
<p>Input 1</p>
</td></tr>
<tr><td><code id="+2B2B+2B2Cnumeric+2B2CPseudoWave-method_+3A_e2">e2</code></td>
<td>
<p>Input 2</p>
</td></tr>
</table>

<hr>
<h2 id='+2B+2CPseudoWave+2Cnumeric-method'>PseudoWave scalar addition</h2><span id='topic++2B+2CPseudoWave+2Cnumeric-method'></span>

<h3>Description</h3>

<p>PseudoWave scalar addition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PseudoWave,numeric'
e1 + e2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B2B+2B2CPseudoWave+2B2Cnumeric-method_+3A_e1">e1</code></td>
<td>
<p>Input 1</p>
</td></tr>
<tr><td><code id="+2B2B+2B2CPseudoWave+2B2Cnumeric-method_+3A_e2">e2</code></td>
<td>
<p>Input 2</p>
</td></tr>
</table>

<hr>
<h2 id='ab_diel_traits'>Convert text times of day in audioblast traits to numeric values</h2><span id='topic+ab_diel_traits'></span>

<h3>Description</h3>

<p>This function takes a traits dataset retrieved from audioblast and converts
values such as &quot;day&quot; into a numeric time of day based on the date and location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ab_diel_traits(traits, date, lat, lon, overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ab_diel_traits_+3A_traits">traits</code></td>
<td>
<p>Traits dataset retrieved using audioblast().</p>
</td></tr>
<tr><td><code id="ab_diel_traits_+3A_date">date</code></td>
<td>
<p>The date used for conversion for time.</p>
</td></tr>
<tr><td><code id="ab_diel_traits_+3A_lat">lat</code></td>
<td>
<p>Latitude of location.</p>
</td></tr>
<tr><td><code id="ab_diel_traits_+3A_lon">lon</code></td>
<td>
<p>Longitude of location.</p>
</td></tr>
<tr><td><code id="ab_diel_traits_+3A_overwrite">overwrite</code></td>
<td>
<p>If TRUE then the function will overwrite any existing min/max.</p>
</td></tr>
</table>

<hr>
<h2 id='ab_seqss_nearestStart'>Nearest start time</h2><span id='topic+ab_seqss_nearestStart'></span>

<h3>Description</h3>

<p>Search audioBLAST! for recordings with a start time closest to
specified date/time which match specified criteria
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ab_seqss_nearestStart(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ab_seqss_nearestStart_+3A_...">...</code></td>
<td>
<p>Fields and values to filter on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of matching annotations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ab_seqss_nearestStart(date="2020-05-15",time="1500")

## End(Not run)

</code></pre>

<hr>
<h2 id='addProcess'>Add a process to a Tagged Wave or WaveMC object</h2><span id='topic+addProcess'></span><span id='topic+addProcess+2CTaggedWave-method'></span><span id='topic+addProcess+2CTaggedWaveMC-method'></span>

<h3>Description</h3>

<p>This function takes a <code>TaggedWave</code> or <code>TaggedWaveMC</code> object and adds a process
to the <code>processing</code> slot. This is used to keep a record of the processes that
have been applied to the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addProcess(object, process, output = NULL, duration = NULL)

## S4 method for signature 'TaggedWave'
addProcess(object, process, output = NULL, duration = NULL)

## S4 method for signature 'TaggedWaveMC'
addProcess(object, process, output = NULL, duration = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addProcess_+3A_object">object</code></td>
<td>
<p>An object.</p>
</td></tr>
<tr><td><code id="addProcess_+3A_process">process</code></td>
<td>
<p>A description of the process.</p>
</td></tr>
<tr><td><code id="addProcess_+3A_output">output</code></td>
<td>
<p>The output of the process.</p>
</td></tr>
<tr><td><code id="addProcess_+3A_duration">duration</code></td>
<td>
<p>The duration of the process in seconds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object with the process added.
</p>

<hr>
<h2 id='addSpectra'>Add two spectra from seewave</h2><span id='topic+addSpectra'></span>

<h3>Description</h3>

<p>This function takes two spectra from seewave (or equivalent) and adds their values. The spectra must have
the same bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addSpectra(s1, s2, coerceNegative = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addSpectra_+3A_s1">s1</code></td>
<td>
<p>First spectrum</p>
</td></tr>
<tr><td><code id="addSpectra_+3A_s2">s2</code></td>
<td>
<p>Second spectrum</p>
</td></tr>
<tr><td><code id="addSpectra_+3A_coercenegative">coerceNegative</code></td>
<td>
<p>Sets any values below zero to zero in output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A spectrum of s1+s2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
subtractSpectra(spec1, spec2)

## End(Not run)

</code></pre>

<hr>
<h2 id='allChannels'>Apply a function to all channels of a Wave or WaveMC object</h2><span id='topic+allChannels'></span>

<h3>Description</h3>

<p>Some functions (e.g. ffilter from seewave) only operate on a single
channel at a time. This function applies the function to each channel
and returns a list of analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allChannels(
  w,
  FUN,
  cl = NULL,
  channel.param = "channel",
  output.FUN = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allChannels_+3A_w">w</code></td>
<td>
<p>A Wave or WaveMC object</p>
</td></tr>
<tr><td><code id="allChannels_+3A_fun">FUN</code></td>
<td>
<p>Function to apply to the wave.</p>
</td></tr>
<tr><td><code id="allChannels_+3A_cl">cl</code></td>
<td>
<p>Optionally a cluster for parallel calculation.</p>
</td></tr>
<tr><td><code id="allChannels_+3A_channel.param">channel.param</code></td>
<td>
<p>Name of the channel parameter to FUN. Can be NULL.</p>
</td></tr>
<tr><td><code id="allChannels_+3A_output.fun">output.FUN</code></td>
<td>
<p>Optional. Function that processes the output of FUN.
The &quot;channels_se&quot; function provides standard functionality for the
soundecology package.</p>
</td></tr>
<tr><td><code id="allChannels_+3A_...">...</code></td>
<td>
<p>Optional. Additional parameters to pass to FUN.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of outputs.
</p>

<hr>
<h2 id='annotation'>Create a new Annotation object</h2><span id='topic+annotation'></span>

<h3>Description</h3>

<p>Create a new Annotation object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotation(
  file = NA_character_,
  metadata = list(),
  start = 0,
  end = Inf,
  low = 0,
  high = Inf,
  source = NA_character_,
  type = NA_character_,
  value = NA_character_
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="annotation_+3A_file">file</code></td>
<td>
<p>File being annotated.</p>
</td></tr>
<tr><td><code id="annotation_+3A_metadata">metadata</code></td>
<td>
<p>A list of metadata.</p>
</td></tr>
<tr><td><code id="annotation_+3A_start">start</code></td>
<td>
<p>Start time of annotation (seconds).</p>
</td></tr>
<tr><td><code id="annotation_+3A_end">end</code></td>
<td>
<p>End time of annotation (seconds).</p>
</td></tr>
<tr><td><code id="annotation_+3A_low">low</code></td>
<td>
<p>Low frequency of annotation (Hz).</p>
</td></tr>
<tr><td><code id="annotation_+3A_high">high</code></td>
<td>
<p>High frequency of annotation (Hz).</p>
</td></tr>
<tr><td><code id="annotation_+3A_source">source</code></td>
<td>
<p>Source of annotation.</p>
</td></tr>
<tr><td><code id="annotation_+3A_type">type</code></td>
<td>
<p>Type of annotation.</p>
</td></tr>
<tr><td><code id="annotation_+3A_value">value</code></td>
<td>
<p>Value of annotation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An Annotation object.
</p>

<hr>
<h2 id='Annotation-class'>A S4 class for annotations</h2><span id='topic+Annotation-class'></span>

<h3>Description</h3>

<p>The <code>Annotation</code> class is used to store annotations on <code>Wave</code>-like objects.
</p>


<h3>Slots</h3>


<dl>
<dt><code>file</code></dt><dd><p>File being annotated.</p>
</dd>
<dt><code>metadata</code></dt><dd><p>A list for storing metadata.</p>
</dd>
<dt><code>start</code></dt><dd><p>Start time of annotation.</p>
</dd>
<dt><code>end</code></dt><dd><p>End time of annotation.</p>
</dd>
<dt><code>low</code></dt><dd><p>Low frequency of annotation.</p>
</dd>
<dt><code>high</code></dt><dd><p>High frequency of annotation.</p>
</dd>
<dt><code>source</code></dt><dd><p>Source of annotation.</p>
</dd>
<dt><code>type</code></dt><dd><p>Type of annotation.</p>
</dd>
<dt><code>value</code></dt><dd><p>Value of annotation.</p>
</dd>
</dl>

<hr>
<h2 id='audio_filesize'>Calculated size of raw audio files</h2><span id='topic+audio_filesize'></span>

<h3>Description</h3>

<p>Calculates the raw size of audio date at set sample rate, bit depth and duration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>audio_filesize(
  samp.rate = 44100,
  bit.depth = 16,
  channels = 1,
  duration = 1,
  duration.unit = "seconds",
  output.unit = "bits"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="audio_filesize_+3A_samp.rate">samp.rate</code></td>
<td>
<p>Sample rate</p>
</td></tr>
<tr><td><code id="audio_filesize_+3A_bit.depth">bit.depth</code></td>
<td>
<p>Bit depth</p>
</td></tr>
<tr><td><code id="audio_filesize_+3A_channels">channels</code></td>
<td>
<p>The number of audio channels</p>
</td></tr>
<tr><td><code id="audio_filesize_+3A_duration">duration</code></td>
<td>
<p>Duration of recording</p>
</td></tr>
<tr><td><code id="audio_filesize_+3A_duration.unit">duration.unit</code></td>
<td>
<p>One of seconds, minutes, hours, days</p>
</td></tr>
<tr><td><code id="audio_filesize_+3A_output.unit">output.unit</code></td>
<td>
<p>&quot;bits&quot; or  &quot;bytes&quot;</p>
</td></tr>
</table>

<hr>
<h2 id='audioblast'>Get data or analyses from audioBlast</h2><span id='topic+audioblast'></span>

<h3>Description</h3>

<p>Search for data or analyses on audioBlast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>audioblast(
  type,
  name,
  endpoint = NULL,
  check = TRUE,
  max_pages = NULL,
  page = 1,
  quiet = FALSE,
  on.issue = stop,
  output = "data.frame",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="audioblast_+3A_type">type</code></td>
<td>
<p>One of data, analysis, standalone.</p>
</td></tr>
<tr><td><code id="audioblast_+3A_name">name</code></td>
<td>
<p>Name of data or analysis source.</p>
</td></tr>
<tr><td><code id="audioblast_+3A_endpoint">endpoint</code></td>
<td>
<p>Optionally specify endpoint of an audioBlast module.</p>
</td></tr>
<tr><td><code id="audioblast_+3A_check">check</code></td>
<td>
<p>Logical. Performs sanity check on input before sending to audioBLAST.</p>
</td></tr>
<tr><td><code id="audioblast_+3A_max_pages">max_pages</code></td>
<td>
<p>Maximum number of data pages to return, by default this is set to NULL and returns all pages.</p>
</td></tr>
<tr><td><code id="audioblast_+3A_page">page</code></td>
<td>
<p>First page of results to request, defaults to 1.</p>
</td></tr>
<tr><td><code id="audioblast_+3A_quiet">quiet</code></td>
<td>
<p>If true will not print progress. Silence is a virtue.</p>
</td></tr>
<tr><td><code id="audioblast_+3A_on.issue">on.issue</code></td>
<td>
<p>Function to call on error or warning. By default <code>stop</code> to raise
a standard R error. Setting to <code>warning</code> will instead a warning.</p>
</td></tr>
<tr><td><code id="audioblast_+3A_output">output</code></td>
<td>
<p>By default a <code>data.frame</code>. &quot;Annotations&quot; will return a list of
<code>Annotation</code> objects.</p>
</td></tr>
<tr><td><code id="audioblast_+3A_...">...</code></td>
<td>
<p>Fields and values to filter on. Any field defined by audioBLAST.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
audioblast("data", "recordings", taxon="Gryllotalpa vineae")

## End(Not run)

</code></pre>

<hr>
<h2 id='audioblastDownload'>Download audio files from audioBlast</h2><span id='topic+audioblastDownload'></span>

<h3>Description</h3>

<p>Downloads audio files associated with a search using the audioBlast() function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>audioblastDownload(
  d,
  metadata = TRUE,
  skip.existing = TRUE,
  dir = ".",
  quiet = FALSE,
  on.issue = .audioblastIssue
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="audioblastDownload_+3A_d">d</code></td>
<td>
<p>Data returned from a search using audioBlast().</p>
</td></tr>
<tr><td><code id="audioblastDownload_+3A_metadata">metadata</code></td>
<td>
<p>If true saves the data in d as a csv file.</p>
</td></tr>
<tr><td><code id="audioblastDownload_+3A_skip.existing">skip.existing</code></td>
<td>
<p>If true will not overwrite existing files.</p>
</td></tr>
<tr><td><code id="audioblastDownload_+3A_dir">dir</code></td>
<td>
<p>Directory to save files to.</p>
</td></tr>
<tr><td><code id="audioblastDownload_+3A_quiet">quiet</code></td>
<td>
<p>If true will not print progress.</p>
</td></tr>
<tr><td><code id="audioblastDownload_+3A_on.issue">on.issue</code></td>
<td>
<p>Function to call on error or warning. By default <code>stop</code> to raise
a standard R error. Setting to <code>warning</code> will instead a warning.</p>
</td></tr>
</table>

<hr>
<h2 id='audiomothConfig'>Read AudioMoth configuration file</h2><span id='topic+audiomothConfig'></span>

<h3>Description</h3>

<p>Reads and parses an AudioMoth configuration file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>audiomothConfig(filename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="audiomothConfig_+3A_filename">filename</code></td>
<td>
<p>Path to the configuration file to read</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of matching annotations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
audiomothConfig("./CONFIG.TXT")

## End(Not run)

</code></pre>

<hr>
<h2 id='audiomothWave'>Read AudioMoth metadata from a wave file</h2><span id='topic+audiomothWave'></span>

<h3>Description</h3>

<p>Reads and parses metadata stored in wave files produced by
AudioMoth devices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>audiomothWave(filename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="audiomothWave_+3A_filename">filename</code></td>
<td>
<p>Path to the wave file to read</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of extracted parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
audiomothWave("./FILENAME.WAV")

## End(Not run)

</code></pre>

<hr>
<h2 id='autoBandPass'>Automatic Band Pass Filter</h2><span id='topic+autoBandPass'></span>

<h3>Description</h3>

<p>Creates an automatic bandpass filter based on the strongest frequency. The
allowed bandwidth can be an integer multiple of the bandwidth at either -3dB
or -10dB.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoBandPass(wave, bw = "-3dB", n.bw = 1, lowcut = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autoBandPass_+3A_wave">wave</code></td>
<td>
<p>A Wave object</p>
</td></tr>
<tr><td><code id="autoBandPass_+3A_bw">bw</code></td>
<td>
<p>Either -3dB or -10dB. This is calculated by <code>frequencyStats</code></p>
</td></tr>
<tr><td><code id="autoBandPass_+3A_n.bw">n.bw</code></td>
<td>
<p>The number of bandwidths either side of the centre of the centre to keep</p>
</td></tr>
<tr><td><code id="autoBandPass_+3A_lowcut">lowcut</code></td>
<td>
<p>High-pass filtering is applied at this frequency before calculating the centre frequency and bandwidth</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A band-pass filtered Wave object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
autoBandPass(sheep)
autoBandPass(sheep, bw="-3dB", n.bw=1, lowcut=1000)
autoBandPass(sheep, bw="-10dB", n.bw=2, lowcut=0)

## End(Not run)
</code></pre>

<hr>
<h2 id='bandpass'>Simple bandpass filter</h2><span id='topic+bandpass'></span>

<h3>Description</h3>

<p>Creates a band pass WaveFilter between values specified to a Wave object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bandpass(from, to, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bandpass_+3A_from">from</code></td>
<td>
<p>Bottom of bandpass frequency (Hz).</p>
</td></tr>
<tr><td><code id="bandpass_+3A_to">to</code></td>
<td>
<p>Top of bandpass frequency (Hz).</p>
</td></tr>
<tr><td><code id="bandpass_+3A_...">...</code></td>
<td>
<p>Further arguments to pass to ffilter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a simple wrapper function to the seewave ffilter function allowing its
use with filterw and pipes.
</p>


<h3>Value</h3>

<p>A WaveFilter object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
nwave &lt;- noise("white", duration=44100, samp.rate=44100)

fwave &lt;- filterWave(nwave, bandpass(from=1000, to=2000))
nwave |&gt; filterWave(bandpass(from=1000, to=2000)) -&gt; fwave

## End(Not run)
</code></pre>

<hr>
<h2 id='beatComplexity'>Beat spectrum complexity</h2><span id='topic+beatComplexity'></span>

<h3>Description</h3>

<p>This function computes a <code>beatSpectrum</code> and calculates some basic
measurements of its complexity. The complexity value is calculated as the
maximum identified repeating period (in seconds) divided by the number of
peaks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beatComplexity(wave, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="beatComplexity_+3A_wave">wave</code></td>
<td>
<p>A Wave object</p>
</td></tr>
<tr><td><code id="beatComplexity_+3A_plot">plot</code></td>
<td>
<p>If TRUE a spectrogram overlaid with the peaks is plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the complexity, a vector of the peak periods, and the number of peaks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  beatComplexity(sheep)
  beatComplexity(sheep, plot=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='beatSpectrum'>Computes a beat spectrum</h2><span id='topic+beatSpectrum'></span>

<h3>Description</h3>

<p>Beat spectra represent the periodicity in signal amplitude.
It is computed by performing a continuous wavelet transform on
the envelope of a preprocessed signal, and processing
the average power per frequency band.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beatSpectrum(wave, min_period = 0.005, max_period = 30, dj = 1/32, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="beatSpectrum_+3A_wave">wave</code></td>
<td>
<p>an R object or path to a wave file</p>
</td></tr>
<tr><td><code id="beatSpectrum_+3A_min_period">min_period</code></td>
<td>
<p>the minimal rythmicity period expected, in seconds</p>
</td></tr>
<tr><td><code id="beatSpectrum_+3A_max_period">max_period</code></td>
<td>
<p>the maximal rythmicity period expected, in seconds</p>
</td></tr>
<tr><td><code id="beatSpectrum_+3A_dj">dj</code></td>
<td>
<p>the frequency resolution of the cwt (in voices per octave)</p>
</td></tr>
<tr><td><code id="beatSpectrum_+3A_...">...</code></td>
<td>
<p>extra arguments passed to <code>analyze.wavelet()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a spectrum as a data frame.
It contains two columns: <code>power</code> and <code>period</code>.
The number of rows depend on the resolution and frequency range.
</p>


<h3>Author(s)</h3>

<p>Quentin Geissmann
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
beatSpectrum(sheep)
beatSpectrum(sheep, min_period=0.005, max_period=30, dj=1/32)

## End(Not run)
</code></pre>

<hr>
<h2 id='birdNetAnalyse'>Analyse sound files using BirdNET-Analyzer</h2><span id='topic+birdNetAnalyse'></span>

<h3>Description</h3>

<p>This function takes a list of sound files and analyses them using the
<code>BirdNET-Analyzer</code> (Kahl et al. 2021). The function
either returns a data frame with the results of the analysis or a list of
<code>Annotation</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>birdNetAnalyse(
  files,
  lat = NULL,
  lon = NULL,
  date = NULL,
  output = "Annotation"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="birdNetAnalyse_+3A_files">files</code></td>
<td>
<p>A character vector of file paths.</p>
</td></tr>
<tr><td><code id="birdNetAnalyse_+3A_lat">lat</code></td>
<td>
<p>A latitude or  vector of latitudes.</p>
</td></tr>
<tr><td><code id="birdNetAnalyse_+3A_lon">lon</code></td>
<td>
<p>A longitude or  vector of longitudes.</p>
</td></tr>
<tr><td><code id="birdNetAnalyse_+3A_date">date</code></td>
<td>
<p>A <code>Date</code> or list of <code>Date</code> objects .</p>
</td></tr>
<tr><td><code id="birdNetAnalyse_+3A_output">output</code></td>
<td>
<p>One of &quot;data.frame&quot; or &quot;Annotation&quot;.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Kahl S, Wood CM, Eibl M, Klinck H (2021).
&ldquo;BirdNET: A deep learning solution for avian diversity monitoring.&rdquo;
<em>Ecological Informatics</em>, <b>61</b>, 101236.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  birdnetAnalyse(files=c("path/to/file1.wav", "path/to/file2.wav"), output="data.frame")

## End(Not run)
</code></pre>

<hr>
<h2 id='birdNetInstall'>Install the BirdNET environment</h2><span id='topic+birdNetInstall'></span>

<h3>Description</h3>

<p>This function installs BirdNET in the <code>ssd_birdnet</code> environment using <code>reticulate</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>birdNetInstall(unattended = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="birdNetInstall_+3A_unattended">unattended</code></td>
<td>
<p>If TRUE then the function will not prompt the user to install
the environment in a non-interactive session.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
birdnetInstall()
birdNetInstall(unattended=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='channels_se'>Channels for sound ecology</h2><span id='topic+channels_se'></span>

<h3>Description</h3>

<p>Used to process the output of acoustic index functions from the soundecology
package when using allChannels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>channels_se(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="channels_se_+3A_...">...</code></td>
<td>
<p>Export from a bioacoustic index function from the soundecology package</p>
</td></tr>
</table>

<hr>
<h2 id='circularise'>Circularise a dataset</h2><span id='topic+circularise'></span>

<h3>Description</h3>

<p>When plotting rings or horizons that are meant to cover the entirety of the time period in a
dielPlot() or yearlyPlot() this function append the beginning values to the end to ensure an entire
loop is created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circularise(values)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circularise_+3A_values">values</code></td>
<td>
<p>A vector if values</p>
</td></tr>
</table>

<hr>
<h2 id='concat'>Concatenate two or more Wave-like objects.</h2><span id='topic+concat'></span><span id='topic+concat+2CWave-method'></span><span id='topic+concat+2CWaveMC-method'></span><span id='topic+concat+2CTaggedWave-method'></span><span id='topic+concat+2CTaggedWaveMC-method'></span>

<h3>Description</h3>

<p>The <code>concat()</code> method is a more flexible version of the <code>bind()</code> method
from <code>tuneR</code> package, that allows specifying more advanced types of
concatenation. Setting <code>method</code> to &quot;noClick&quot; will remove any click between
Wave objects caused by sudden jumps in amplitude by applying <code>tuneR::prepComb()</code>
appropriately with default value of zero (this is only effective for the left
channel or stereo or multi-channel recordings).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concat(object, ..., method = "bind")

## S4 method for signature 'Wave'
concat(object, ..., method = "bind")

## S4 method for signature 'WaveMC'
concat(object, ..., method = "bind")

## S4 method for signature 'TaggedWave'
concat(object, ..., method = "bind")

## S4 method for signature 'TaggedWaveMC'
concat(object, ..., method = "bind")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="concat_+3A_object">object</code></td>
<td>
<p>A Wave like object.</p>
</td></tr>
<tr><td><code id="concat_+3A_...">...</code></td>
<td>
<p>Wave like objects to concatenate to object.</p>
</td></tr>
<tr><td><code id="concat_+3A_method">method</code></td>
<td>
<p>One of &quot;bind&quot;, &quot;noClick&quot;. Default is &quot;bind&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A concatenated Wave like object, with type of <code>object</code>.
</p>

<hr>
<h2 id='convert2bytes'>Convert bits to bytes</h2><span id='topic+convert2bytes'></span>

<h3>Description</h3>

<p>Converts time measurements into seconds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert2bytes(S, input = "bits")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert2bytes_+3A_s">S</code></td>
<td>
<p>The value to convert</p>
</td></tr>
<tr><td><code id="convert2bytes_+3A_input">input</code></td>
<td>
<p>The unit  to convert, allowed values are &quot;bits&quot;, &quot;kB&quot;, &quot;MB&quot;, &quot;GB&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The numeric value in seconds
</p>

<hr>
<h2 id='convert2Celsius'>Convert temperature to Celsius</h2><span id='topic+convert2Celsius'></span>

<h3>Description</h3>

<p>Converts temperature measurements into Celsius
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert2Celsius(temp, input = "K")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert2Celsius_+3A_temp">temp</code></td>
<td>
<p>The value of the temperature to convert</p>
</td></tr>
<tr><td><code id="convert2Celsius_+3A_input">input</code></td>
<td>
<p>The unit of the temperature to convert, allowed values are &quot;K&quot;, &quot;F&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value in degrees Celsius
</p>


<h3>Examples</h3>

<pre><code class='language-R'>convert2Celsius(15, input="K")
convert2Celsius(15, input="F")

</code></pre>

<hr>
<h2 id='convert2degrees'>Convert angle to degrees</h2><span id='topic+convert2degrees'></span>

<h3>Description</h3>

<p>Converts angle measurements into degrees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert2degrees(A, input = "radians")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert2degrees_+3A_a">A</code></td>
<td>
<p>The angle value to convert</p>
</td></tr>
<tr><td><code id="convert2degrees_+3A_input">input</code></td>
<td>
<p>The unit of angle to convert, allowed values are &quot;radians&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The numeric value in degrees
</p>

<hr>
<h2 id='convert2dyne_cm2'>Convert pressure to dyne per square centimetre</h2><span id='topic+convert2dyne_cm2'></span>

<h3>Description</h3>

<p>Converts pressure measurements into dyne per square centimetre
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert2dyne_cm2(P, input = "kPa")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert2dyne_cm2_+3A_p">P</code></td>
<td>
<p>The value of the pressure to convert</p>
</td></tr>
<tr><td><code id="convert2dyne_cm2_+3A_input">input</code></td>
<td>
<p>The unit of the pressure to convert, allowed values are &quot;kPa&quot;, &quot;P&quot;.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>convert2dyne_cm2(1, input="Pa")
convert2dyne_cm2(1, input="kPa")
</code></pre>

<hr>
<h2 id='convert2Fahrenheit'>Convert temperature to Fahrenheit</h2><span id='topic+convert2Fahrenheit'></span>

<h3>Description</h3>

<p>Converts temperature measurements into Fahrenheit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert2Fahrenheit(temp, input)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert2Fahrenheit_+3A_temp">temp</code></td>
<td>
<p>The value of the temperature to convert</p>
</td></tr>
<tr><td><code id="convert2Fahrenheit_+3A_input">input</code></td>
<td>
<p>The unit of the temperature to convert, allowed values are &quot;K&quot;, &quot;C&quot;.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
convert2Fahrenheit(15, input = "C")

## End(Not run)

</code></pre>

<hr>
<h2 id='convert2Kelvin'>Convert temperature to Kelvin</h2><span id='topic+convert2Kelvin'></span>

<h3>Description</h3>

<p>Converts temperature measurements into Kelvin
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert2Kelvin(temp, input = "C")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert2Kelvin_+3A_temp">temp</code></td>
<td>
<p>The value of the temperature to convert</p>
</td></tr>
<tr><td><code id="convert2Kelvin_+3A_input">input</code></td>
<td>
<p>The unit of the temperature to convert, allowed values are &quot;C&quot;, &quot;F&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value in Kelvin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>convert2Kelvin(15, input="C")
convert2Kelvin(15, input="F")

</code></pre>

<hr>
<h2 id='convert2Pascals'>Convert pressure to Pascals</h2><span id='topic+convert2Pascals'></span>

<h3>Description</h3>

<p>Converts pressure measurements into Pascals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert2Pascals(P, input = "kPa")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert2Pascals_+3A_p">P</code></td>
<td>
<p>The value of the pressure to convert</p>
</td></tr>
<tr><td><code id="convert2Pascals_+3A_input">input</code></td>
<td>
<p>The unit of the pressure to convert, allowed values are &quot;kPa&quot;, &quot;dyne_cm2&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The numeric value in Pascals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>convert2Pascals(1000, input="kPa")
convert2Pascals(10, input="dyne_cm2")

</code></pre>

<hr>
<h2 id='convert2radians'>Convert angle to radians</h2><span id='topic+convert2radians'></span>

<h3>Description</h3>

<p>Converts angle measurements into radians
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert2radians(A, input = "degrees")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert2radians_+3A_a">A</code></td>
<td>
<p>The angle value to convert</p>
</td></tr>
<tr><td><code id="convert2radians_+3A_input">input</code></td>
<td>
<p>The unit of angle to convert, allowed values are &quot;degrees&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The numeric value in radians
</p>

<hr>
<h2 id='convert2seconds'>Convert time to seconds</h2><span id='topic+convert2seconds'></span>

<h3>Description</h3>

<p>Converts time measurements into seconds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert2seconds(T, input = "minutes", origin = "day")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert2seconds_+3A_t">T</code></td>
<td>
<p>The time value to convert</p>
</td></tr>
<tr><td><code id="convert2seconds_+3A_input">input</code></td>
<td>
<p>The unit of time to convert, allowed values are &quot;minutes&quot;,
&quot;hours&quot;, &quot;days&quot;, &quot;years&quot;, &quot;HHMM&quot;.</p>
</td></tr>
<tr><td><code id="convert2seconds_+3A_origin">origin</code></td>
<td>
<p>For POSIX whether to return relative to start of day (&quot;day&quot;) or Unix epoch (&quot;unix&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The numeric value in seconds
</p>

<hr>
<h2 id='corWaveMC'>Correlate channels in a WaveMC object</h2><span id='topic+corWaveMC'></span>

<h3>Description</h3>

<p>Uses the corenv function from seewave to calculate the envelope correlation for timed
events between the channels of a WaveMC object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corWaveMC(wave, times, window, temp = 25, cluster = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="corWaveMC_+3A_wave">wave</code></td>
<td>
<p>A WaveMC object</p>
</td></tr>
<tr><td><code id="corWaveMC_+3A_times">times</code></td>
<td>
<p>One or more times of events to correlate</p>
</td></tr>
<tr><td><code id="corWaveMC_+3A_window">window</code></td>
<td>
<p>Width of the window to correlate in seconds (centred on times)</p>
</td></tr>
<tr><td><code id="corWaveMC_+3A_temp">temp</code></td>
<td>
<p>Air temperature in Celsius</p>
</td></tr>
<tr><td><code id="corWaveMC_+3A_cluster">cluster</code></td>
<td>
<p>A cluster for parallel execution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of corenv lists for events, and a list of the time differences between channels
</p>

<hr>
<h2 id='cutws'>Cut wave by samples</h2><span id='topic+cutws'></span>

<h3>Description</h3>

<p>Extract a section of a Wave object based on sample positions. This function
will automatically detect if a Wave object is stereo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutws(wave, from = 1, to = Inf, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cutws_+3A_wave">wave</code></td>
<td>
<p>A Wave object</p>
</td></tr>
<tr><td><code id="cutws_+3A_from">from</code></td>
<td>
<p>First sample to return</p>
</td></tr>
<tr><td><code id="cutws_+3A_to">to</code></td>
<td>
<p>Last sample to return</p>
</td></tr>
<tr><td><code id="cutws_+3A_plot">plot</code></td>
<td>
<p>If TRUE shows the cut region within the original waveform</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Wave object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
cutws(sheep, 1, 20)
cutws(sheep, 1, 20, plot=TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='data2Wave'>Convert data into a Wave object</h2><span id='topic+data2Wave'></span>

<h3>Description</h3>

<p>Make a sequence of data into a normalised Wave object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data2Wave(
  left,
  samp.rate = 44100,
  bit = 16,
  unit = NULL,
  remove.offset = TRUE,
  normalise = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data2Wave_+3A_left">left</code></td>
<td>
<p>Data for mono audio channel</p>
</td></tr>
<tr><td><code id="data2Wave_+3A_samp.rate">samp.rate</code></td>
<td>
<p>Sampling rate for Wave object</p>
</td></tr>
<tr><td><code id="data2Wave_+3A_bit">bit</code></td>
<td>
<p>Bit depth of Wave object</p>
</td></tr>
<tr><td><code id="data2Wave_+3A_unit">unit</code></td>
<td>
<p>See tuneR::normalize. If NULL this is handled automatically.</p>
</td></tr>
<tr><td><code id="data2Wave_+3A_remove.offset">remove.offset</code></td>
<td>
<p>If TRUE any DC offset is removed</p>
</td></tr>
<tr><td><code id="data2Wave_+3A_normalise">normalise</code></td>
<td>
<p>IF TRUE the output Wave is normalised to -1:1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A mono Wave object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pattern &lt;- seq(from=-1, to=1, length.out=100)
data &lt;- rep.int(pattern, 100)
w &lt;- data2Wave(data)
</code></pre>

<hr>
<h2 id='dayPhase'>Phase of day</h2><span id='topic+dayPhase'></span>

<h3>Description</h3>

<p>Given a start time and (optionally) a duration returns the phase of day at a given
location. This is primarily used to calculate phase of day information for soundscape
recording projects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dayPhase(
  time = Sys.time(),
  duration = 40000,
  lat = 50.1,
  lon = 1.83,
  tz = "UTC"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dayPhase_+3A_time">time</code></td>
<td>
<p>A time object representing the start time of a recording</p>
</td></tr>
<tr><td><code id="dayPhase_+3A_duration">duration</code></td>
<td>
<p>Duration of recording</p>
</td></tr>
<tr><td><code id="dayPhase_+3A_lat">lat</code></td>
<td>
<p>Latitude of recording device</p>
</td></tr>
<tr><td><code id="dayPhase_+3A_lon">lon</code></td>
<td>
<p>Longitude of recording device</p>
</td></tr>
<tr><td><code id="dayPhase_+3A_tz">tz</code></td>
<td>
<p>Time-zone of recording device when recording was made</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame of day phases with absolute timestamps and relative times within file
</p>

<hr>
<h2 id='dayPhases'>Phases of day</h2><span id='topic+dayPhases'></span>

<h3>Description</h3>

<p>Wrapper for suncalc::getSunlightTimes that formats output for this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dayPhases(time = as.Date(Sys.time()), lat = 50.1, lon = 1.83, tz = "UTC")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dayPhases_+3A_time">time</code></td>
<td>
<p>A time object representing the start time of a recording</p>
</td></tr>
<tr><td><code id="dayPhases_+3A_lat">lat</code></td>
<td>
<p>Latitude of recording device</p>
</td></tr>
<tr><td><code id="dayPhases_+3A_lon">lon</code></td>
<td>
<p>Longitude of recording device</p>
</td></tr>
<tr><td><code id="dayPhases_+3A_tz">tz</code></td>
<td>
<p>Time-zone of recording device when recording was made</p>
</td></tr>
</table>

<hr>
<h2 id='daysPhases'>Phases of days</h2><span id='topic+daysPhases'></span>

<h3>Description</h3>

<p>Phases of days
</p>


<h3>Usage</h3>

<pre><code class='language-R'>daysPhases(
  date = Sys.Date(),
  period = "year",
  plot = FALSE,
  lat = 50.1,
  lon = 1.83,
  tz = "UTC"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="daysPhases_+3A_date">date</code></td>
<td>
<p>A time object representing the start time of a recording</p>
</td></tr>
<tr><td><code id="daysPhases_+3A_period">period</code></td>
<td>
<p>&quot;month&quot; or &quot;year&quot;</p>
</td></tr>
<tr><td><code id="daysPhases_+3A_plot">plot</code></td>
<td>
<p>If true plots the data, default FALSE</p>
</td></tr>
<tr><td><code id="daysPhases_+3A_lat">lat</code></td>
<td>
<p>Latitude of recording device</p>
</td></tr>
<tr><td><code id="daysPhases_+3A_lon">lon</code></td>
<td>
<p>Longitude of recording device</p>
</td></tr>
<tr><td><code id="daysPhases_+3A_tz">tz</code></td>
<td>
<p>Time-zone of recording device when recording was made</p>
</td></tr>
</table>

<hr>
<h2 id='defaultCluster'>Create Default Cluster for Windowing</h2><span id='topic+defaultCluster'></span>

<h3>Description</h3>

<p>Creates a default cluster using one less than the total cores available on
the system. By default this uses forking, which is not be available on Windows.
Hence, the fork parameter has no effect on Windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defaultCluster(fork = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="defaultCluster_+3A_fork">fork</code></td>
<td>
<p>If TRUE uses forking to create the cluster (Unix like systems only)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cluster object for parallel processing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
cl &lt;- defaultCluster()
stopCluster(cl)
cl &lt;- defaultCluster(FALSE)
stopCluster(cl)

## End(Not run)

</code></pre>

<hr>
<h2 id='dielFraction'>Calculate the fraction of a day given by a value</h2><span id='topic+dielFraction'></span>

<h3>Description</h3>

<p>Given an object that can be coerced to POSIXlt or is in a supported string
format, return the fraction of a day represented by the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dielFraction(t, input = "POSIX", unit = "radians")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dielFraction_+3A_t">t</code></td>
<td>
<p>Object to be converted to a fraction</p>
</td></tr>
<tr><td><code id="dielFraction_+3A_input">input</code></td>
<td>
<p>One of POSIX (default) or HHMM</p>
</td></tr>
<tr><td><code id="dielFraction_+3A_unit">unit</code></td>
<td>
<p>If set to radians outputs a position around a circle. If set to fraction outputs the raw fraction.</p>
</td></tr>
</table>

<hr>
<h2 id='dielHistogram'>Diel Histogram</h2><span id='topic+dielHistogram'></span>

<h3>Description</h3>

<p>Draws a histogram on a dielPlot() using pre-defined bins related to time of day.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dielHistogram(
  times,
  by = "hour",
  col = "grey",
  maxval = NA,
  presence.only = FALSE,
  limits = c(1, 2)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dielHistogram_+3A_times">times</code></td>
<td>
<p>A vector of times that can be pocessed by dielFraction().</p>
</td></tr>
<tr><td><code id="dielHistogram_+3A_by">by</code></td>
<td>
<p>Controls the size of histogram bins, one of &quot;hour&quot;, &quot;15minute&quot;, &quot;30minute&quot;.</p>
</td></tr>
<tr><td><code id="dielHistogram_+3A_col">col</code></td>
<td>
<p>Colour of the plot.</p>
</td></tr>
<tr><td><code id="dielHistogram_+3A_maxval">maxval</code></td>
<td>
<p>By default scales histogram within limits, specifying a maximum value here allows comparison between plots.</p>
</td></tr>
<tr><td><code id="dielHistogram_+3A_presence.only">presence.only</code></td>
<td>
<p>Only show presence/absence not values.</p>
</td></tr>
<tr><td><code id="dielHistogram_+3A_limits">limits</code></td>
<td>
<p>Limits of the plotting (see dielPlot()).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of start and end points of bins.
</p>

<hr>
<h2 id='dielLabels'>Generate labels for a diel plot</h2><span id='topic+dielLabels'></span>

<h3>Description</h3>

<p>Generates labels for a dielPlot() in 12- or 24-hour format. Labels are generated
at three hourly intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dielLabels(format = "clock24")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dielLabels_+3A_format">format</code></td>
<td>
<p>One of clock24 (default) or clock12</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dielLabels()
dielLabels("clock12")
</code></pre>

<hr>
<h2 id='dielPlot'>Create a diel plot</h2><span id='topic+dielPlot'></span>

<h3>Description</h3>

<p>A diel plot shows the times of night, twilight and the maximum altitude of the sun for a given date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dielPlot(
  date,
  lat,
  lon,
  limits = c(0, 2),
  plot = NULL,
  rot = tzRot(0),
  method = "plotrix",
  legend = F
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dielPlot_+3A_date">date</code></td>
<td>
<p>Date to plot.</p>
</td></tr>
<tr><td><code id="dielPlot_+3A_lat">lat</code></td>
<td>
<p>Numeric latitude.</p>
</td></tr>
<tr><td><code id="dielPlot_+3A_lon">lon</code></td>
<td>
<p>Numeric longitude.</p>
</td></tr>
<tr><td><code id="dielPlot_+3A_limits">limits</code></td>
<td>
<p>Plotting limits of the daylight regions, default to c(1,2)</p>
</td></tr>
<tr><td><code id="dielPlot_+3A_plot">plot</code></td>
<td>
<p>Character vector of components to plot</p>
</td></tr>
<tr><td><code id="dielPlot_+3A_rot">rot</code></td>
<td>
<p>Either &quot;Solar Noon&quot; or an offset calculated by tz</p>
</td></tr>
<tr><td><code id="dielPlot_+3A_method">method</code></td>
<td>
<p>Plotting library to use</p>
</td></tr>
<tr><td><code id="dielPlot_+3A_legend">legend</code></td>
<td>
<p>Whether to show a legend</p>
</td></tr>
</table>

<hr>
<h2 id='dielPositions'>Generate positions of labels for a diel plot</h2><span id='topic+dielPositions'></span>

<h3>Description</h3>

<p>Generates positions for three-hourly labels of a dielPlot() in radians.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dielPositions(format = "3hourly")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dielPositions_+3A_format">format</code></td>
<td>
<p>One of &quot;3hours&quot; (default), &quot;hours&quot;, or &quot;minutes&quot;</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dielPositions()
dielPositions("hours")
dielPositions("minutes")
</code></pre>

<hr>
<h2 id='dielRings'>Plot rings on a diel plot</h2><span id='topic+dielRings'></span>

<h3>Description</h3>

<p>Plot rings on a diel plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dielRings(
  names,
  starts,
  ends,
  cols = "grey",
  format = "HHMM",
  limits = c(1, 2),
  legend = T
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dielRings_+3A_names">names</code></td>
<td>
<p>Labels for the rings</p>
</td></tr>
<tr><td><code id="dielRings_+3A_starts">starts</code></td>
<td>
<p>Start times for rings in HHMM string format</p>
</td></tr>
<tr><td><code id="dielRings_+3A_ends">ends</code></td>
<td>
<p>End times for rings in HHMM string format</p>
</td></tr>
<tr><td><code id="dielRings_+3A_cols">cols</code></td>
<td>
<p>Colours of the rings</p>
</td></tr>
<tr><td><code id="dielRings_+3A_format">format</code></td>
<td>
<p>Defaults to HHMM</p>
</td></tr>
<tr><td><code id="dielRings_+3A_limits">limits</code></td>
<td>
<p>Region of a dielPlot() to plot rings. Defaults to c(1,2)</p>
</td></tr>
<tr><td><code id="dielRings_+3A_legend">legend</code></td>
<td>
<p>Boolean. Whether to plot a legend.</p>
</td></tr>
</table>

<hr>
<h2 id='dolbear'>Dolbear's law</h2><span id='topic+dolbear'></span>

<h3>Description</h3>

<p>Calculates either chirps per minute based on temperature or vice versa
using Dolbear's law (or equivalent laws for other species)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dolbear(n = NULL, t = NULL, species = "Oecanthus fultoni")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dolbear_+3A_n">n</code></td>
<td>
<p>Chirps per minute</p>
</td></tr>
<tr><td><code id="dolbear_+3A_t">t</code></td>
<td>
<p>Temperature in Celsius</p>
</td></tr>
<tr><td><code id="dolbear_+3A_species">species</code></td>
<td>
<p>Species to use (by default Oecanthus fultoni)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Missing value of n or t
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dolbear(n=6)
dolbear(t=25)

</code></pre>

<hr>
<h2 id='dutyCycle'>Calculate the duty cycle of a wave</h2><span id='topic+dutyCycle'></span>

<h3>Description</h3>

<p>Proportion of a wave with signal above the limit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dutyCycle(wave, limit = 0.1, output = "unit", normalise = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dutyCycle_+3A_wave">wave</code></td>
<td>
<p>A Wave object</p>
</td></tr>
<tr><td><code id="dutyCycle_+3A_limit">limit</code></td>
<td>
<p>Threshold above which to consider the signal</p>
</td></tr>
<tr><td><code id="dutyCycle_+3A_output">output</code></td>
<td>
<p>If &quot;unit&quot; the duty cycle will be in the range 0-1. For a percentage use &quot;percent&quot;.</p>
</td></tr>
<tr><td><code id="dutyCycle_+3A_normalise">normalise</code></td>
<td>
<p>If TRUE the Wave is normalised using tuneR</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical value for the duty cycle between 0 and 1 (or 0 and 100% if percentage output).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wave &lt;- tuneR::sine(2000)
dc &lt;- dutyCycle(wave)
pc &lt;- dutyCycle(wave, output="percent")
</code></pre>

<hr>
<h2 id='emptyDiel'>Create an empty diel plot</h2><span id='topic+emptyDiel'></span>

<h3>Description</h3>

<p>Create a diel plot with labels but without sun altitude or times of day plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emptyDiel(method = "plotrix", rot = pi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="emptyDiel_+3A_method">method</code></td>
<td>
<p>Plotting package to use</p>
</td></tr>
<tr><td><code id="emptyDiel_+3A_rot">rot</code></td>
<td>
<p>Rotation of the origin (defaults to pi)</p>
</td></tr>
</table>

<hr>
<h2 id='emptyYearly'>Create an empty yearly plot</h2><span id='topic+emptyYearly'></span>

<h3>Description</h3>

<p>Create a yearly plot with labels but without sun or night duration plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emptyYearly(year = 2022, method = "plotix", rot = pi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="emptyYearly_+3A_year">year</code></td>
<td>
<p>Year to plot (allows for leap years)</p>
</td></tr>
<tr><td><code id="emptyYearly_+3A_method">method</code></td>
<td>
<p>Plotting package to use</p>
</td></tr>
<tr><td><code id="emptyYearly_+3A_rot">rot</code></td>
<td>
<p>Rotation of the origin (defaults to pi)</p>
</td></tr>
</table>

<hr>
<h2 id='entropyStats'>Various measurements of frequency values for a Wave object</h2><span id='topic+entropyStats'></span>

<h3>Description</h3>

<p>Calculates the peak, centre, bandwidth and quality factor. The quality factor (Q) is calculated at both
-3dB and -10dB as discussed by Bennett-Clark (1999)  <a href="doi:10.1080/09524622.1999.9753408">doi:10.1080/09524622.1999.9753408</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entropyStats(wave)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="entropyStats_+3A_wave">wave</code></td>
<td>
<p>A Wave object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of spectral entropy types.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
entropyStats(sheep)

## End(Not run)

</code></pre>

<hr>
<h2 id='filterWave'>Apply a WaveFilter object to a Wave object</h2><span id='topic+filterWave'></span>

<h3>Description</h3>

<p>A WaveFilter object is an object containing information necessary for the
filterw function to apply the filter to a Wave object. This is designed to
allow a pipe operator (either magrittr or base R) to be used to apply filters
to a Wave in a pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterWave(w, filt, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filterWave_+3A_w">w</code></td>
<td>
<p>A Wave object.</p>
</td></tr>
<tr><td><code id="filterWave_+3A_filt">filt</code></td>
<td>
<p>Wave object with the selected filter applied.</p>
</td></tr>
<tr><td><code id="filterWave_+3A_cl">cl</code></td>
<td>
<p>Optional. If a cluster is specified, the filter will be applied in parallel.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Supported filters include those from the seewave package.
</p>

<hr>
<h2 id='frequencySound'>Get the frequency from wavelength and speed of sound</h2><span id='topic+frequencySound'></span>

<h3>Description</h3>

<p>Calculates the frequency of a sound wave given the wavelength and speed of sound in that medium.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frequencySound(wl, s = soundSpeed(medium = "air"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="frequencySound_+3A_wl">wl</code></td>
<td>
<p>Wavelength</p>
</td></tr>
<tr><td><code id="frequencySound_+3A_s">s</code></td>
<td>
<p>Speed of sound (defaults to the speed of sound in air)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Frequency of the sound in Hertz
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- frequencySound(wl=100, s=343)
</code></pre>

<hr>
<h2 id='frequencyStats'>Various measurements of frequency values for a Wave object</h2><span id='topic+frequencyStats'></span>

<h3>Description</h3>

<p>Calculates the peak, centre, bandwidth and quality factor. The quality factor (Q) is calculated at both
-3dB and -10dB as discussed by Bennett-Clark (1999)  &lt;doi: 10.1080/09524622.1999.9753408&gt;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frequencyStats(wave, wave_spec = NULL, warn = TRUE, lowcut = 1, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="frequencyStats_+3A_wave">wave</code></td>
<td>
<p>A Wave object</p>
</td></tr>
<tr><td><code id="frequencyStats_+3A_wave_spec">wave_spec</code></td>
<td>
<p>A precomputed spectrum (optional, if not present will be generated)</p>
</td></tr>
<tr><td><code id="frequencyStats_+3A_warn">warn</code></td>
<td>
<p>If TRUE provides warnings when values are not consistent</p>
</td></tr>
<tr><td><code id="frequencyStats_+3A_lowcut">lowcut</code></td>
<td>
<p>Frequency (in kHz) values below which are ignored.</p>
</td></tr>
<tr><td><code id="frequencyStats_+3A_plot">plot</code></td>
<td>
<p>IF TRUE displays values</p>
</td></tr>
</table>

<hr>
<h2 id='generateNoise'>Add noise to a Wave like object</h2><span id='topic+generateNoise'></span>

<h3>Description</h3>

<p>Adding noise to a Wave like object allows for testing of the robustness of
automated identification algorithms to noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateNoise(
  wave,
  noise = c("white"),
  noise.add = FALSE,
  noise.ratio = 0.5,
  noise.ref = "file",
  output = "list"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generateNoise_+3A_wave">wave</code></td>
<td>
<p>Object to add noise to (<code>Wave</code>, <code>WaveMC</code>, or Tagged versions), or
a list of such objects.</p>
</td></tr>
<tr><td><code id="generateNoise_+3A_noise">noise</code></td>
<td>
<p>Vector of noise to add (unif, gaussian, white, pink, power, red)</p>
</td></tr>
<tr><td><code id="generateNoise_+3A_noise.add">noise.add</code></td>
<td>
<p>If TRUE all noise sources are added to wave. If FALSE
separate outputs are created for each noise source.</p>
</td></tr>
<tr><td><code id="generateNoise_+3A_noise.ratio">noise.ratio</code></td>
<td>
<p>Ratio of maximum noise amplitude to the maximum amplitude in wave.</p>
</td></tr>
<tr><td><code id="generateNoise_+3A_noise.ref">noise.ref</code></td>
<td>
<p>Reference maximum for noise.ratio. If &quot;max&quot; then the maximum
amplitude, if &quot;file&quot; then the maximum amplitude of wave.</p>
</td></tr>
<tr><td><code id="generateNoise_+3A_output">output</code></td>
<td>
<p>TODO: Is this implemented?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of Wave objects with the required noise added.
</p>

<hr>
<h2 id='generateTimeMask'>Generate time masked Wave-like objects</h2><span id='topic+generateTimeMask'></span>

<h3>Description</h3>

<p>Given a <code>Wave</code>-like object (or a list of <code>Wave</code>-like objects), generate
new <code>Wave</code>-like objects with time masking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateTimeMask(wave, method = "squarewave", dutyCycle = 0.95, n.periods = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generateTimeMask_+3A_wave">wave</code></td>
<td>
<p>A <code>Wave</code>-like object (or a list of <code>Wave</code>-like objects).</p>
</td></tr>
<tr><td><code id="generateTimeMask_+3A_method">method</code></td>
<td>
<p>The method to use for time masking (one of &quot;squarewave&quot;, &quot;random).</p>
</td></tr>
<tr><td><code id="generateTimeMask_+3A_dutycycle">dutyCycle</code></td>
<td>
<p>The duty cycle of the output. A value of 0.95 means that 5%
of the time is masked.</p>
</td></tr>
<tr><td><code id="generateTimeMask_+3A_n.periods">n.periods</code></td>
<td>
<p>The number of waves to generate in the squarewave method.</p>
</td></tr>
</table>

<hr>
<h2 id='generateTimeShift'>Generated time-shifted versions of a Wave-like object</h2><span id='topic+generateTimeShift'></span>

<h3>Description</h3>

<p>Given a Wave-like object (or list of Wave-like objects), this function generates
time-shifted versions of the object. The time-shifted versions are generated by
adding a constant amount of time to the start or end of the object. This is achieved
by either inserting silence and truncating the object to the original length, or by
rotating the audio within the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateTimeShift(
  wave,
  type = "silent",
  amount = c(1, 2),
  where = "start",
  output = "list"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generateTimeShift_+3A_wave">wave</code></td>
<td>
<p>A Wave-like object or list of Wave-like objects.</p>
</td></tr>
<tr><td><code id="generateTimeShift_+3A_type">type</code></td>
<td>
<p>The type of time-shift to apply. Either &quot;silent&quot; or &quot;rotate&quot;.</p>
</td></tr>
<tr><td><code id="generateTimeShift_+3A_amount">amount</code></td>
<td>
<p>Vector of amount of time to shift by (seconds).</p>
</td></tr>
<tr><td><code id="generateTimeShift_+3A_where">where</code></td>
<td>
<p>Where to insert silence if <code>type</code> is &quot;silent&quot;.</p>
</td></tr>
<tr><td><code id="generateTimeShift_+3A_output">output</code></td>
<td>
<p>Return a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Wave-like object or list of Wave-like objects.
</p>

<hr>
<h2 id='gs_transcribe'>Google Speech API Transcribe</h2><span id='topic+gs_transcribe'></span>

<h3>Description</h3>

<p>Wrapper around various Google packages to simplify speech transcription.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs_transcribe(filename, bucket = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gs_transcribe_+3A_filename">filename</code></td>
<td>
<p>Path to file for analysis</p>
</td></tr>
<tr><td><code id="gs_transcribe_+3A_bucket">bucket</code></td>
<td>
<p>Storage bucket on Google Cloud for larger files</p>
</td></tr>
<tr><td><code id="gs_transcribe_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to gl_speech()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A gs_transcribe object containing details of the transcription
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
gs_transcribe("demo.wav")

## End(Not run)

</code></pre>

<hr>
<h2 id='humanBytes'>Converts bytes in human readable form</h2><span id='topic+humanBytes'></span>

<h3>Description</h3>

<p>Given an input of bytes calculates the result in a sensible output unit (e.g.
MB, GB, PB).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>humanBytes(S)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="humanBytes_+3A_s">S</code></td>
<td>
<p>Number of bytes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>String in human readable format
</p>

<hr>
<h2 id='humanTime'>Converts time to human readable form</h2><span id='topic+humanTime'></span>

<h3>Description</h3>

<p>Given an input of bytes calculates the result in a sensible output unit (e.g.
minutes, hours).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>humanTime(S, unit = "seconds")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="humanTime_+3A_s">S</code></td>
<td>
<p>Time to convert in unit</p>
</td></tr>
<tr><td><code id="humanTime_+3A_unit">unit</code></td>
<td>
<p>The unit of time to convert</p>
</td></tr>
</table>


<h3>Value</h3>

<p>String in human readable format
</p>

<hr>
<h2 id='jitter'>Calculate the jitter in a Wave object</h2><span id='topic+jitter'></span>

<h3>Description</h3>

<p>Jitter is a measure of the variability of periods in the waveform. Relative
jitter is scaled by the jitter in the analysed waveform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jitter(wave, method = "absolute")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jitter_+3A_wave">wave</code></td>
<td>
<p>A Wave object</p>
</td></tr>
<tr><td><code id="jitter_+3A_method">method</code></td>
<td>
<p>One of &quot;absolute&quot; or &quot;relative&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of zero crossing locations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
jitter(sheep, method="absolute")
jitter(sheep, method="relative")

## End(Not run)
</code></pre>

<hr>
<h2 id='labelPadding'>Pad labels with interval</h2><span id='topic+labelPadding'></span>

<h3>Description</h3>

<p>Takes labels from Google Speech API transcript and pads the time by a specified number of seconds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labelPadding(t, pad = 0.5, max_t = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="labelPadding_+3A_t">t</code></td>
<td>
<p>Transcript from Google Speech API</p>
</td></tr>
<tr><td><code id="labelPadding_+3A_pad">pad</code></td>
<td>
<p>Amount of time (in seconds) to add to start and end</p>
</td></tr>
<tr><td><code id="labelPadding_+3A_max_t">max_t</code></td>
<td>
<p>Optional. The duration of the file, so padding does not exceed length of file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified Google Speech API transcript object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
labelPadding(t, pad=2, max_t=duration(wave))

## End(Not run)

</code></pre>

<hr>
<h2 id='labelReduction'>Combines labels which overlap into single continuous regions</h2><span id='topic+labelReduction'></span>

<h3>Description</h3>

<p>Takes labels from Google Speech API transcript and combines overlapping labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labelReduction(t)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="labelReduction_+3A_t">t</code></td>
<td>
<p>Transcript from Google Speech API</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing start and end times of speech containing regions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
labelReduction(t)

## End(Not run)

</code></pre>

<hr>
<h2 id='map2RGB'>Map three vectors to RGB</h2><span id='topic+map2RGB'></span>

<h3>Description</h3>

<p>Maps three vectors of equal length to RGB for use in false-colour index
spectrograms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map2RGB(red, green, blue)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map2RGB_+3A_red">red</code></td>
<td>
<p>The red channel vector</p>
</td></tr>
<tr><td><code id="map2RGB_+3A_green">green</code></td>
<td>
<p>The green channel vector</p>
</td></tr>
<tr><td><code id="map2RGB_+3A_blue">blue</code></td>
<td>
<p>The blue channel vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of RGB values
</p>

<hr>
<h2 id='naturalFrequency'>Calculate the natural frequency</h2><span id='topic+naturalFrequency'></span>

<h3>Description</h3>

<p>Calculates the natural frequency given the inductance, capacitance and resistance. In the acoustic case
the inductance is inertia or mass, the capacitance is elasticity (bulk modulus) and resistance is composed of air
resistance and related quantities. All units are SI.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>naturalFrequency(L, C = "default", R)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="naturalFrequency_+3A_l">L</code></td>
<td>
<p>Inductance</p>
</td></tr>
<tr><td><code id="naturalFrequency_+3A_c">C</code></td>
<td>
<p>Capacitance, by default IUPAC standard pressure.</p>
</td></tr>
<tr><td><code id="naturalFrequency_+3A_r">R</code></td>
<td>
<p>Resistance</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For isothermal compression, the bulk modulus is equal to the pressure. The default value of C therefore is the IUPAC
standard pressure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>naturalFrequency(L=20,R=0.5)
naturalFrequency(L=20,C=1/4,R=0.5)
</code></pre>

<hr>
<h2 id='normalise'>Normalise a Wave object</h2><span id='topic+normalise'></span>

<h3>Description</h3>

<p>Similar to normalize() from the tuneR package but automatically identifies the
unit parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalise(wave, unit = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalise_+3A_wave">wave</code></td>
<td>
<p>Wave or WaveMC object</p>
</td></tr>
<tr><td><code id="normalise_+3A_unit">unit</code></td>
<td>
<p>If not null behaves as in normalize() from tuneR, if null the unit
is automatically identified.</p>
</td></tr>
<tr><td><code id="normalise_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to normalize() from tuneR</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Normalised Wave or WaveMC object
</p>

<hr>
<h2 id='ntd'>Natural Time Domain</h2><span id='topic+ntd'></span>

<h3>Description</h3>

<p>Runs a function on the wave and outputs values in the Natural Time Domain (see Varotsos, Sarlis &amp; Skordas(2011) <a href="doi:10.1007/978-3-642-16449-1">doi:10.1007/978-3-642-16449-1</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ntd(wave, events, FUN, normalise = FALSE, argument = "wave", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ntd_+3A_wave">wave</code></td>
<td>
<p>A Wave object containing pulses</p>
</td></tr>
<tr><td><code id="ntd_+3A_events">events</code></td>
<td>
<p>Onset of detected events, e.g. from pulseDetection()</p>
</td></tr>
<tr><td><code id="ntd_+3A_fun">FUN</code></td>
<td>
<p>The function to run</p>
</td></tr>
<tr><td><code id="ntd_+3A_normalise">normalise</code></td>
<td>
<p>If TRUE the output is a probability density</p>
</td></tr>
<tr><td><code id="ntd_+3A_argument">argument</code></td>
<td>
<p>If &quot;wave&quot; supplies a weave object to the function, if &quot;vector&quot; supplies the left channel as a numeric vector.</p>
</td></tr>
<tr><td><code id="ntd_+3A_...">...</code></td>
<td>
<p>Additional arguments to FUN</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of outputs form the applied function
</p>

<hr>
<h2 id='parseFilename'>Parse a filename</h2><span id='topic+parseFilename'></span>

<h3>Description</h3>

<p>Attempts to extract meaningful information from a filename, typically the
date and time a recording started.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseFilename(file, format = NULL, timezone = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parseFilename_+3A_file">file</code></td>
<td>
<p>A filename (or list of filenames).</p>
</td></tr>
<tr><td><code id="parseFilename_+3A_format">format</code></td>
<td>
<p>Optionally force a given format (see Details). If NULL (default)
an attempt is made to automatically detect the format for each file. If &quot;match&quot;
and a list of filenames is given then an attempt will be made to find a format
that matches all files. This may give incorrect results if the filename is
ambiguous (see Details).</p>
</td></tr>
<tr><td><code id="parseFilename_+3A_timezone">timezone</code></td>
<td>
<p>Optionally set a timezone.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Determining the format</h4>

<p>It is sometimes impossible to accurately determine the format of
a filename, e.g. when an eight-digit 'AudioMoth HEX' only contains numbers it
could be confused with a YYYYMMDD format. If a list of filenames is given
and the &quot;match&quot; format is specified then an effort will be made to determine
the most likely format that applies to all filenames.
</p>



<h4>Supported formats</h4>


<ul>
<li> <p><strong>AudioMoth</strong> - The newer format for AudioMoth devices consists of a
standard YYYYMMDD_HHMMSS.wav format. Specifying 'AudioMoth' forces a call
to the <code>audiomoth()</code> function from the <code>seewave</code> package
(Sueur et al. 2008).
</p>
</li>
<li> <p><strong>AudioMoth HEX</strong> - Older format for AudioMoth devices consisting of eight
hexadecimal characters. Conversion is handled by a call to
<code>seewave::audiomoth()</code>.
</p>
</li>
<li> <p><strong>timestamp</strong> - A standard date-time format. Uses the R standard origin of
1970-01-01 00:00:00 UTC.
</p>
</li>
<li> <p><strong>Wildlife Acoustics SM2</strong> - Can also be used for Wildlife Acoustics SM4
devices. Conversion is handled by a call to <code>seewave::songmeter()</code>.
</p>
</li>
<li> <p><strong>Wildlife Acoustics SM3</strong> - Conversion is handled by a call to
<code>seewave::songmeter()</code>.
</p>
</li>
<li> <p><strong>YYYYMMDD_HHMMSS</strong> - A standard date-time format.
</p>
</li></ul>




<h3>Value</h3>

<p>A list of file, type of match, datetime.
<br /><br />
It is possible to determine additional properties from some files, these will
be added to the list.
</p>


<h3>References</h3>

<p>Sueur J, Aubin T, Simonis C (2008).
&ldquo;Seewave, a free modular tool for sound analysis and synthesis.&rdquo;
<em>Bioacoustics</em>, <b>18</b>(2), 213&ndash;226.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parseFilename("5E90A4D4.wav")

</code></pre>

<hr>
<h2 id='pd_dietrich2004'>Pulse detection using Dietrich (2004)</h2><span id='topic+pd_dietrich2004'></span>

<h3>Description</h3>

<p>Detects pulses in a Wave using the method described in Dietrich et al (2004) <a href="doi:10.1016/j.patcog.2004.04.004">doi:10.1016/j.patcog.2004.04.004</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pd_dietrich2004(
  wave,
  U = 120,
  gamma = 0.05,
  alpha = 1.4,
  scaling = 32,
  V = 480,
  psi = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pd_dietrich2004_+3A_wave">wave</code></td>
<td>
<p>A Wave object</p>
</td></tr>
<tr><td><code id="pd_dietrich2004_+3A_u">U</code></td>
<td>
<p>Window length</p>
</td></tr>
<tr><td><code id="pd_dietrich2004_+3A_gamma">gamma</code></td>
<td>
<p>Gamma</p>
</td></tr>
<tr><td><code id="pd_dietrich2004_+3A_alpha">alpha</code></td>
<td>
<p>Alpha</p>
</td></tr>
<tr><td><code id="pd_dietrich2004_+3A_scaling">scaling</code></td>
<td>
<p>Scaling</p>
</td></tr>
<tr><td><code id="pd_dietrich2004_+3A_v">V</code></td>
<td>
<p>V Window length</p>
</td></tr>
<tr><td><code id="pd_dietrich2004_+3A_psi">psi</code></td>
<td>
<p>Psi</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of input values plus the onset and offset times of pulses
</p>

<hr>
<h2 id='pd_simple'>Simplified pulse detection using Dietrich (2004)</h2><span id='topic+pd_simple'></span>

<h3>Description</h3>

<p>Detects pulses in a Wave.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pd_simple(
  wave,
  U = 120,
  gamma = 0.05,
  alpha = 1.4,
  scaling = 32,
  V = 480,
  psi = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pd_simple_+3A_wave">wave</code></td>
<td>
<p>A Wave object</p>
</td></tr>
<tr><td><code id="pd_simple_+3A_u">U</code></td>
<td>
<p>Window length</p>
</td></tr>
<tr><td><code id="pd_simple_+3A_gamma">gamma</code></td>
<td>
<p>Gamma</p>
</td></tr>
<tr><td><code id="pd_simple_+3A_alpha">alpha</code></td>
<td>
<p>Alpha</p>
</td></tr>
<tr><td><code id="pd_simple_+3A_scaling">scaling</code></td>
<td>
<p>Scaling</p>
</td></tr>
<tr><td><code id="pd_simple_+3A_v">V</code></td>
<td>
<p>V Window length</p>
</td></tr>
<tr><td><code id="pd_simple_+3A_psi">psi</code></td>
<td>
<p>Psi</p>
</td></tr>
</table>

<hr>
<h2 id='pseudoWave'>Create a PseudoWave object</h2><span id='topic+pseudoWave'></span>

<h3>Description</h3>

<p>This function is used to create a PseudoWave object that can be used to
generate a Wave object when operated on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudoWave(
  type = NA_character_,
  subtype = NA_character_,
  scale = 1,
  offset = 0,
  seed = 1,
  params = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pseudoWave_+3A_type">type</code></td>
<td>
<p>Type of PseudoWave (e.g. &quot;noise&quot;, &quot;sine&quot;)</p>
</td></tr>
<tr><td><code id="pseudoWave_+3A_subtype">subtype</code></td>
<td>
<p>Subtype of PseudoWave (e.g. &quot;white&quot; if type is &quot;noise&quot;)</p>
</td></tr>
<tr><td><code id="pseudoWave_+3A_scale">scale</code></td>
<td>
<p>The Wave channels are multiplied by this value</p>
</td></tr>
<tr><td><code id="pseudoWave_+3A_offset">offset</code></td>
<td>
<p>This value is added to the  Wave channels</p>
</td></tr>
<tr><td><code id="pseudoWave_+3A_seed">seed</code></td>
<td>
<p>Random seed for reproducible output. NA for no</p>
</td></tr>
<tr><td><code id="pseudoWave_+3A_params">params</code></td>
<td>
<p>List of additional parameters to pass to generating function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A PseudoWave object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pw &lt;- pseudoWave("noise", "white")

pw &lt;- pseudoWave("sine", params=list("f0"=440))

</code></pre>

<hr>
<h2 id='PseudoWave-class'>An S4 class to represent a PseudoWave object that is converted to a
Wave object when operated on.</h2><span id='topic+PseudoWave-class'></span>

<h3>Description</h3>

<p>An S4 class to represent a PseudoWave object that is converted to a
Wave object when operated on.
</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Type of PseudoWave (e.g. &quot;noise&quot;)</p>
</dd>
<dt><code>subtype</code></dt><dd><p>Subtype of PseudoWave (e.g. &quot;white&quot; if type is &quot;noise&quot;)</p>
</dd>
<dt><code>scale</code></dt><dd><p>The Wave channels are multiplied by this value</p>
</dd>
<dt><code>offset</code></dt><dd><p>This value is added to the  Wave channels</p>
</dd>
<dt><code>seed</code></dt><dd><p>Random seed for reproducible output, NA for no seed</p>
</dd>
<dt><code>scale</code></dt><dd><p>Logical. Whether to use the random seed value</p>
</dd>
<dt><code>params</code></dt><dd><p>List of additional parameters to pass to generating function</p>
</dd>
</dl>

<hr>
<h2 id='pulse'>Generate a single pulse</h2><span id='topic+pulse'></span>

<h3>Description</h3>

<p>Generate a single pulse, either a Dirac pulse (Dirac delta)  or a square pulse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pulse(
  type = "dirac",
  leading = 22050,
  pulse.length = 1,
  duration = samp.rate,
  samp.rate = 44100,
  bit = 1,
  pcm = FALSE,
  stereo = FALSE,
  output = "Wave",
  invert = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pulse_+3A_type">type</code></td>
<td>
<p>Either &quot;dirac&quot; or &quot;square&quot;.</p>
</td></tr>
<tr><td><code id="pulse_+3A_leading">leading</code></td>
<td>
<p>The number of samples before the pulse.</p>
</td></tr>
<tr><td><code id="pulse_+3A_pulse.length">pulse.length</code></td>
<td>
<p>The number of samples in the pulse (for &quot;square&quot;).</p>
</td></tr>
<tr><td><code id="pulse_+3A_duration">duration</code></td>
<td>
<p>The total number of samples generated.</p>
</td></tr>
<tr><td><code id="pulse_+3A_samp.rate">samp.rate</code></td>
<td>
<p>The sample rate.</p>
</td></tr>
<tr><td><code id="pulse_+3A_bit">bit</code></td>
<td>
<p>The bit depth.</p>
</td></tr>
<tr><td><code id="pulse_+3A_pcm">pcm</code></td>
<td>
<p>Whether Wave generated is PCM (see tuneR).</p>
</td></tr>
<tr><td><code id="pulse_+3A_stereo">stereo</code></td>
<td>
<p>Whether Wave generated is stereo.</p>
</td></tr>
<tr><td><code id="pulse_+3A_output">output</code></td>
<td>
<p>The output format (&quot;Wave&quot;).</p>
</td></tr>
<tr><td><code id="pulse_+3A_invert">invert</code></td>
<td>
<p>Whether to invert the pulse.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Specified by output.
</p>

<hr>
<h2 id='pulseDetection'>Pulse detection</h2><span id='topic+pulseDetection'></span>

<h3>Description</h3>

<p>Detects pulses in a Wave, defaults to using Dietrich (2004).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pulseDetection(wave, method = "simple", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pulseDetection_+3A_wave">wave</code></td>
<td>
<p>A Wave object containing pulses</p>
</td></tr>
<tr><td><code id="pulseDetection_+3A_method">method</code></td>
<td>
<p>Which method to use for pulse detection</p>
</td></tr>
<tr><td><code id="pulseDetection_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to pulse detection function</p>
</td></tr>
</table>

<hr>
<h2 id='pulseIntervals'>Pulse intervals</h2><span id='topic+pulseIntervals'></span>

<h3>Description</h3>

<p>Used to locate area of no pulses from the results of pulseDetection().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pulseIntervals(pulses, nsd = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pulseIntervals_+3A_pulses">pulses</code></td>
<td>
<p>The result of a pulseDetection.</p>
</td></tr>
<tr><td><code id="pulseIntervals_+3A_nsd">nsd</code></td>
<td>
<p>The number of standard deviations each sid of the mean pulse interval to discard</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of onset and offset times for pulses
</p>

<hr>
<h2 id='radarPower'>The radar equation</h2><span id='topic+radarPower'></span>

<h3>Description</h3>

<p>Calculates the power returned from an echolocation pulse
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radarPower(P_t, r, area, G_t = 1, G_r = 1, wl = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="radarPower_+3A_p_t">P_t</code></td>
<td>
<p>Power transmitted (from sender)</p>
</td></tr>
<tr><td><code id="radarPower_+3A_r">r</code></td>
<td>
<p>Range of the target</p>
</td></tr>
<tr><td><code id="radarPower_+3A_area">area</code></td>
<td>
<p>Effective cross-sectional area of the target</p>
</td></tr>
<tr><td><code id="radarPower_+3A_g_t">G_t</code></td>
<td>
<p>Transmitter gain</p>
</td></tr>
<tr><td><code id="radarPower_+3A_g_r">G_r</code></td>
<td>
<p>Receiver gain</p>
</td></tr>
<tr><td><code id="radarPower_+3A_wl">wl</code></td>
<td>
<p>Wavelength (use only with G_r and G_t)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The received power
</p>


<h3>Examples</h3>

<pre><code class='language-R'>radarPower(12, 20, 0.05)
radarPower(12, 20, 0.05, G_t=1.2, G_r=1.5, wl=0.045)

</code></pre>

<hr>
<h2 id='radarRange'>Radar range</h2><span id='topic+radarRange'></span>

<h3>Description</h3>

<p>Calculates the distance of an object based on the round trip time of an
echolocation pulse
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radarRange(t, c = soundSpeed(medium = "air"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="radarRange_+3A_t">t</code></td>
<td>
<p>Time in seconds</p>
</td></tr>
<tr><td><code id="radarRange_+3A_c">c</code></td>
<td>
<p>Speed of sound in transmission medium m/s (by default air)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Distance to object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>radarRange(2)
radarRange(2, c=343)
radarRange(2, c=soundSpeed(medium = "sea water"))

</code></pre>

<hr>
<h2 id='radialPolygon'>Plot a radial polygon</h2><span id='topic+radialPolygon'></span>

<h3>Description</h3>

<p>Used to plot sectors, annuli and horizons on a dielPlot() or yearlyPlot(). The polygon
has an inner and outer horizon - which can be set to a fixed radius or a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radialPolygon(
  angle1,
  angle2,
  radius1,
  radius2,
  col = "grey",
  border = NA,
  rot = -pi,
  angleinc = 0.01,
  reverse = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="radialPolygon_+3A_angle1">angle1</code></td>
<td>
<p>Angles for the inner line</p>
</td></tr>
<tr><td><code id="radialPolygon_+3A_angle2">angle2</code></td>
<td>
<p>Angles for the outer line</p>
</td></tr>
<tr><td><code id="radialPolygon_+3A_radius1">radius1</code></td>
<td>
<p>Radii for the inner line</p>
</td></tr>
<tr><td><code id="radialPolygon_+3A_radius2">radius2</code></td>
<td>
<p>Radii for the outer line</p>
</td></tr>
<tr><td><code id="radialPolygon_+3A_col">col</code></td>
<td>
<p>Colour of the polygon</p>
</td></tr>
<tr><td><code id="radialPolygon_+3A_border">border</code></td>
<td>
<p>Border colour (see polygon() for details)</p>
</td></tr>
<tr><td><code id="radialPolygon_+3A_rot">rot</code></td>
<td>
<p>Rotation of the plot, defaults to pi to match dielPlot() and yearlyPlot()</p>
</td></tr>
<tr><td><code id="radialPolygon_+3A_angleinc">angleinc</code></td>
<td>
<p>The angular increment in radians for calculating circular lines</p>
</td></tr>
<tr><td><code id="radialPolygon_+3A_reverse">reverse</code></td>
<td>
<p>If FALSE plots in an anti-clockwise direction</p>
</td></tr>
<tr><td><code id="radialPolygon_+3A_...">...</code></td>
<td>
<p>Other parameters passed to polygon()</p>
</td></tr>
</table>

<hr>
<h2 id='rainfallDetection'>Rainfall detection</h2><span id='topic+rainfallDetection'></span>

<h3>Description</h3>

<p>Detects rainfall in a Wave. An uncalibrated version of Bedoya et al (2017) <a href="doi:10.1016/j.ecolind.2016.12.018">doi:10.1016/j.ecolind.2016.12.018</a> is available in this package. The hardRain
package can also be accessed via this wrapper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rainfallDetection(wave, method = "bedoya2017", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rainfallDetection_+3A_wave">wave</code></td>
<td>
<p>A Wave object to detect rainfall in</p>
</td></tr>
<tr><td><code id="rainfallDetection_+3A_method">method</code></td>
<td>
<p>Which rainfall detection method to use (&quot;bedoya2017&quot;)</p>
</td></tr>
<tr><td><code id="rainfallDetection_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to rain detection function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value from the rainfall detection algorithm chosen.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rainfallDetection(sheep, method="bedoya2017")

## End(Not run)

</code></pre>

<hr>
<h2 id='readAudacityLabels'>Read an Audacity label file</h2><span id='topic+readAudacityLabels'></span>

<h3>Description</h3>

<p>Reads an Audacity label file and returns either a list of <code>Annotation</code> objects
or a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readAudacityLabels(file, output = "annotations")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readAudacityLabels_+3A_file">file</code></td>
<td>
<p>Path to the Audacity label file.</p>
</td></tr>
<tr><td><code id="readAudacityLabels_+3A_output">output</code></td>
<td>
<p>One of &quot;annotations&quot; or &quot;data.frame&quot;.</p>
</td></tr>
</table>

<hr>
<h2 id='readAudio'>Read an audio file</h2><span id='topic+readAudio'></span>

<h3>Description</h3>

<p>This file is used to read an audio file and return a Wave object, it is an abstraction
function for various specific audio reading functions. If no existing method can be identified
an attempt is made to use the av package to read the audio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readAudio(file, mime = "auto", from = 0, to = Inf, units = "seconds")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readAudio_+3A_file">file</code></td>
<td>
<p>File to read</p>
</td></tr>
<tr><td><code id="readAudio_+3A_mime">mime</code></td>
<td>
<p>MIME type of file to read, or &quot;auto&quot;. Supported types are &quot;audio/x-wav&quot; and &quot;audio/mpeg&quot; (MP3)</p>
</td></tr>
<tr><td><code id="readAudio_+3A_from">from</code></td>
<td>
<p>Start point in file to return</p>
</td></tr>
<tr><td><code id="readAudio_+3A_to">to</code></td>
<td>
<p>End point in file to return</p>
</td></tr>
<tr><td><code id="readAudio_+3A_units">units</code></td>
<td>
<p>One of &quot;samples&quot;, &quot;seconds&quot;, &quot;minutes&quot;, &quot;hours&quot;. Default is &quot;seconds&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Wave object
</p>

<hr>
<h2 id='readBirdNet'>Read output files from BirdNet Analyser</h2><span id='topic+readBirdNet'></span>

<h3>Description</h3>

<p>Reads a single file, or directory of files, output by BirdNet Analyser.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readBirdNet(file, filename_parsing = "none")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readBirdNet_+3A_file">file</code></td>
<td>
<p>Filename or directory</p>
</td></tr>
<tr><td><code id="readBirdNet_+3A_filename_parsing">filename_parsing</code></td>
<td>
<p>Allows for filename parsing, accepted values are one of none, audiomoth, timestamp.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame.
</p>

<hr>
<h2 id='readRespeaker6'>Read a file from Seeed Studio Respeaker 6 mic array</h2><span id='topic+readRespeaker6'></span>

<h3>Description</h3>

<p>The Seeed Studio Respeaker-6 when used as described in the documentation saves an eight
channel audio file with channels 7 and 8 not containing input audio. This function reads
such a file and saves it as a six channel file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readRespeaker6(filename, from = 1, to = Inf, units = "samples", header = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readRespeaker6_+3A_filename">filename</code></td>
<td>
<p>file to read.</p>
</td></tr>
<tr><td><code id="readRespeaker6_+3A_from">from</code></td>
<td>
<p>Where to start reading the wave in units.</p>
</td></tr>
<tr><td><code id="readRespeaker6_+3A_to">to</code></td>
<td>
<p>Where to stop reading the wave in units.</p>
</td></tr>
<tr><td><code id="readRespeaker6_+3A_units">units</code></td>
<td>
<p>Units in which from and to is given, the default is &quot;samples&quot;, but can be set to time intervals such as &quot;seconds&quot;.</p>
</td></tr>
<tr><td><code id="readRespeaker6_+3A_header">header</code></td>
<td>
<p>If TRUE, just header information of the Wave file are returned, otherwise (the default) the whole Wave object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A WaveMC object.
</p>

<hr>
<h2 id='referenceIntensity'>Reference intensity</h2><span id='topic+referenceIntensity'></span>

<h3>Description</h3>

<p>Provides the standard reference intensity level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>referenceIntensity(unit = "watt_cm2")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="referenceIntensity_+3A_unit">unit</code></td>
<td>
<p>Unit to return, &quot;watt_cm2&quot;</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ri &lt;- referenceIntensity()
</code></pre>

<hr>
<h2 id='referencePressure'>Reference pressure</h2><span id='topic+referencePressure'></span>

<h3>Description</h3>

<p>Provides the standard reference pressure level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>referencePressure(unit = "Pa")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="referencePressure_+3A_unit">unit</code></td>
<td>
<p>Unit to return, &quot;Pa&quot; or &quot;dyne_cm2&quot;</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>rp &lt;- referencePressure()
rp &lt;- referencePressure(unit="dyne_cm2")
</code></pre>

<hr>
<h2 id='region'>Specify a region with a file to analyse</h2><span id='topic+region'></span>

<h3>Description</h3>

<p>Specifies a time-bounded region to analyse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>region(unit, from = 0, to = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="region_+3A_unit">unit</code></td>
<td>
<p>Unit of time (one of samples, seconds, minutes, hours)</p>
</td></tr>
<tr><td><code id="region_+3A_from">from</code></td>
<td>
<p>Start time</p>
</td></tr>
<tr><td><code id="region_+3A_to">to</code></td>
<td>
<p>End time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A TimeRegion object.
</p>

<hr>
<h2 id='resonantFrequency'>Calculate the resonant frequency</h2><span id='topic+resonantFrequency'></span>

<h3>Description</h3>

<p>Calculates the resonant frequency given the inductance and capacitance. In the acoustic case
the inductance is inertia or mass, the capacitance is elasticity (bulk modulus) and resistance is composed of air
resistance and related quantities. All units are SI.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resonantFrequency(L, C = "default")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resonantFrequency_+3A_l">L</code></td>
<td>
<p>Inductance</p>
</td></tr>
<tr><td><code id="resonantFrequency_+3A_c">C</code></td>
<td>
<p>Capacitance, by default IUPAC standard pressure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For isothermal compression, the bulk modulus is equal to the pressure. The default value of C therefore is the IUPAC
standard pressure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- resonantFrequency(L=1)
</code></pre>

<hr>
<h2 id='sDuration'>Sample duration</h2><span id='topic+sDuration'></span>

<h3>Description</h3>

<p>Calculates the time represented by n samples in a Wave.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sDuration(n = 1, wave = NULL, samp.rate = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sDuration_+3A_n">n</code></td>
<td>
<p>The number of the samples</p>
</td></tr>
<tr><td><code id="sDuration_+3A_wave">wave</code></td>
<td>
<p>A Wave object containing pulses</p>
</td></tr>
<tr><td><code id="sDuration_+3A_samp.rate">samp.rate</code></td>
<td>
<p>Integer sampling rate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value in seconds
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sDuration(n=20, samp.rate=44100)
## Not run: 
sDuration(n=20, wave=sheep)#'

## End(Not run)


</code></pre>

<hr>
<h2 id='sheepFrequencyStats'>Sheep frequencyStats</h2><span id='topic+sheepFrequencyStats'></span>

<h3>Description</h3>

<p>The frequencyStats of the sheep data file from the seewave package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sheepFrequencyStats
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 3.
</p>

<hr>
<h2 id='shimmer'>Calculate the shimmer in a Wave object</h2><span id='topic+shimmer'></span>

<h3>Description</h3>

<p>Jitter is a measure of the variability of amplitudes within periods in the waveform. Relative
shimmer is scaled by the shimmer in the analysed waveform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shimmer(wave)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shimmer_+3A_wave">wave</code></td>
<td>
<p>A Wave object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of zero crossing locations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
shimmer(sheep)

## End(Not run)
</code></pre>

<hr>
<h2 id='soundSpeed'>Calculate the speed of sound in a medium</h2><span id='topic+soundSpeed'></span>

<h3>Description</h3>

<p>Given sufficient parameters (i.e. wavelength and frequency, bulk modulus and density) this
function calculates the speed of sound.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>soundSpeed(
  medium = NULL,
  method = NULL,
  wl = NULL,
  f = NULL,
  bulkModulus = NULL,
  density = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="soundSpeed_+3A_medium">medium</code></td>
<td>
<p>Propagation medium (e.g. &quot;air&quot;), or &quot;all&quot; to return a list of all available media.</p>
</td></tr>
<tr><td><code id="soundSpeed_+3A_method">method</code></td>
<td>
<p>Use a specific method to calculate the speed of sound (see Details).</p>
</td></tr>
<tr><td><code id="soundSpeed_+3A_wl">wl</code></td>
<td>
<p>Wavelength</p>
</td></tr>
<tr><td><code id="soundSpeed_+3A_f">f</code></td>
<td>
<p>Frequency</p>
</td></tr>
<tr><td><code id="soundSpeed_+3A_bulkmodulus">bulkModulus</code></td>
<td>
<p>Bulk modulus</p>
</td></tr>
<tr><td><code id="soundSpeed_+3A_density">density</code></td>
<td>
<p>Density</p>
</td></tr>
<tr><td><code id="soundSpeed_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The speed of sound can be calculated using the following methods:
</p>

<ul>
<li> <p><strong>cramer</strong> Uses the method described in Cramer (1993).
Additional parameters are:
</p>

<ul>
<li><p> temp Temperature
</p>
</li>
<li><p> temp.unit Temperature unit
</p>
</li>
<li><p> pressure Pressure
</p>
</li>
<li><p> pressure.unit Pressure unit
</p>
</li>
<li><p> RH Relative humidity
</p>
</li>
<li><p> MoleFracCO2 Mole fraction of CO2
</p>
</li></ul>

</li>
<li> <p><strong>seewave</strong> Delegates the calculation of the speed of sound in air to the
package <code>seewave</code> (Sueur et al. 2008). This calculation is
.  performed as <code class="reqn">\text{speed} = 331.4 + 0.6 \times \text{temp}</code>.
Additional parameters are:
</p>

<ul>
<li><p> temp Temperature
</p>
</li></ul>

</li></ul>



<h3>References</h3>

<p>Cramer O (1993).
&ldquo;The variation of the specific heat ratio and the speed of sound in air with temperature, pressure, humidity, and CO2 concentration.&rdquo;
<em>The Journal of the Acoustical Society of America</em>, <b>93</b>(5), 2510-2516.
ISSN 0001-4966, <a href="https://doi.org/10.1121/1.405827">doi:10.1121/1.405827</a>.<br /><br /> Sueur J, Aubin T, Simonis C (2008).
&ldquo;Seewave, a free modular tool for sound analysis and synthesis.&rdquo;
<em>Bioacoustics</em>, <b>18</b>(2), 213&ndash;226.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>soundSpeed(medium="air")
soundSpeed(medium="sea water")

soundSpeed(method="cramer", temp=14, pressure=3, RH=10)
soundSpeed(method="cramer", temp=14, temp.unit="C", pressure=3, pressure.unit="kPa", RH=10)

t &lt;- 1:30
s &lt;- lapply(t, \(x){soundSpeed(method="cramer", temp=x)})
</code></pre>

<hr>
<h2 id='specStats'>Calculate and plot statistics on a  frequency spectrum</h2><span id='topic+specStats'></span>

<h3>Description</h3>

<p>Given a list of outputs from meanspec generates a plot with the mean shown by
a line, and either the minimum/maximum values or one standard deviation
shown by a ribbon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specStats(spectra, stats = "minMax", line.col = "black", ribbon.col = "grey70")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="specStats_+3A_spectra">spectra</code></td>
<td>
<p>A list of spectra</p>
</td></tr>
<tr><td><code id="specStats_+3A_stats">stats</code></td>
<td>
<p>Either minMax or sd</p>
</td></tr>
<tr><td><code id="specStats_+3A_line.col">line.col</code></td>
<td>
<p>Colour for the line</p>
</td></tr>
<tr><td><code id="specStats_+3A_ribbon.col">ribbon.col</code></td>
<td>
<p>Colour for the ribbon</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object
</p>

<hr>
<h2 id='ste'>Short term energy</h2><span id='topic+ste'></span>

<h3>Description</h3>

<p>Computes the short term energy of a Wave.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ste(wave, method = "dietrich2004", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ste_+3A_wave">wave</code></td>
<td>
<p>A Wave object</p>
</td></tr>
<tr><td><code id="ste_+3A_method">method</code></td>
<td>
<p>Which method used to calculate the short term energy,
by default &quot;dietrich2004&quot; to use (Dietrich et al. 2004).</p>
</td></tr>
<tr><td><code id="ste_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to ste method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of short term energy values
</p>


<h3>References</h3>

<p>Dietrich C, Palm G, Riede K, Schwenker F (2004).
&ldquo;Classification of bioacoustic time series based on the combination of global and local decisions.&rdquo;
<em>Pattern Recognition</em>, <b>37</b>(12), 2293&ndash;2305.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ste(sheep, method="dietrich2004")

## End(Not run)

</code></pre>

<hr>
<h2 id='STP'>STP: Standard Temperature and Pressure</h2><span id='topic+STP'></span>

<h3>Description</h3>

<p>Dataset compiled from various sources for differing values of STP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>STP
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>

<hr>
<h2 id='subtractSpectra'>Subtract two spectra from seewave</h2><span id='topic+subtractSpectra'></span>

<h3>Description</h3>

<p>This function takes two spectra from seewave (or equivalent) and subtracts their values. The spectra must have
the same bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subtractSpectra(s1, s2, coerceNegative = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subtractSpectra_+3A_s1">s1</code></td>
<td>
<p>First spectrum</p>
</td></tr>
<tr><td><code id="subtractSpectra_+3A_s2">s2</code></td>
<td>
<p>Second spectrum</p>
</td></tr>
<tr><td><code id="subtractSpectra_+3A_coercenegative">coerceNegative</code></td>
<td>
<p>Sets any values below zero to zero in output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A spectrum of s1 - s2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
subtractSpectra(spec1, spec2)
subtractSpectra(spec1, spec2, coerceNegative=TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='sweptsine'>Generate a sine sweep</h2><span id='topic+sweptsine'></span>

<h3>Description</h3>

<p>Generates a frequency swept sine wave (either linear or logarithmic) and
returns it as a Wave object or vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sweptsine(
  f0 = 100,
  f1 = 2500,
  mode = "linear",
  sweep.time = 1,
  time.unit = "seconds",
  samp.rate = 44100,
  output = "wave",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sweptsine_+3A_f0">f0</code></td>
<td>
<p>Start frequency</p>
</td></tr>
<tr><td><code id="sweptsine_+3A_f1">f1</code></td>
<td>
<p>End frequency</p>
</td></tr>
<tr><td><code id="sweptsine_+3A_mode">mode</code></td>
<td>
<p>One of &quot;linear&quot;, &quot;log&quot;</p>
</td></tr>
<tr><td><code id="sweptsine_+3A_sweep.time">sweep.time</code></td>
<td>
<p>Duration of swept wave</p>
</td></tr>
<tr><td><code id="sweptsine_+3A_time.unit">time.unit</code></td>
<td>
<p>One of &quot;seconds&quot;, &quot;samples&quot;</p>
</td></tr>
<tr><td><code id="sweptsine_+3A_samp.rate">samp.rate</code></td>
<td>
<p>Sample rate of swept wave</p>
</td></tr>
<tr><td><code id="sweptsine_+3A_output">output</code></td>
<td>
<p>&quot;wave&quot; for a Wave object, or &quot;vector&quot;</p>
</td></tr>
<tr><td><code id="sweptsine_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to data2Wave</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A swept wave object of the type specified in output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate a swept sine wave between 0Hz and 10kHz.
w &lt;- sweptsine(0, 10e3)

#Generate a swept sine wave between 0Hz and 10kHz and normalise it.
w &lt;- normalise(sweptsine(0, 10e3))

#Generate a stereo swept sine wave between 100Hz and 1KHz.
w &lt;- tuneR::stereo(sweptsine(100, 1e3))

#Generate an exponentially swept sine wave between 100Hz and 1KHz.
w &lt;- sweptsine(100, 1e3, mode="log")

</code></pre>

<hr>
<h2 id='TaggedWave-class'>A S4 class for tagged waves</h2><span id='topic+TaggedWave-class'></span>

<h3>Description</h3>

<p>The TaggedWave class extended the Wave class from the tuneR package so
that it can include extended metadata and the results of analyses.
</p>


<h3>Slots</h3>


<dl>
<dt><code>metadata</code></dt><dd><p>A list for storing metadata.</p>
</dd>
<dt><code>analyses</code></dt><dd><p>A list for storing analyses.</p>
</dd>
</dl>

<hr>
<h2 id='TaggedWaveMC-class'>A S4 class for tagged multi-channel waves</h2><span id='topic+TaggedWaveMC-class'></span>

<h3>Description</h3>

<p>The TaggedWaveMC class extended the WaveMC class from the tuneR package so
that it can include extended metadata and the results of analyses.
</p>


<h3>Slots</h3>


<dl>
<dt><code>metadata</code></dt><dd><p>A list for storing metdata.</p>
</dd>
<dt><code>analyses</code></dt><dd><p>A list for storing analyses.</p>
</dd>
</dl>

<hr>
<h2 id='tagWave'>Tag a Wave or WaveMC object</h2><span id='topic+tagWave'></span>

<h3>Description</h3>

<p>This function takes a <code>Wave</code>/<code>WaveMC</code> object (or a list of such objects) and
returns a corresponding tagged version (<code>TaggedWave</code> or <code>TaggedWaveMC</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tagWave(w, origin = "user")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tagWave_+3A_w">w</code></td>
<td>
<p>A <code>Wave</code> or <code>WaveMC</code> object (or list of such objects).</p>
</td></tr>
<tr><td><code id="tagWave_+3A_origin">origin</code></td>
<td>
<p>The origin of the object (default &quot;user&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>TaggedWave</code> or <code>TaggedWaveMC</code> object (or list of such objects).
</p>

<hr>
<h2 id='TimeRegion-class'>An S4 class to represent a TimeRegion within a Wave object.</h2><span id='topic+TimeRegion-class'></span>

<h3>Description</h3>

<p>An S4 class to represent a TimeRegion within a Wave object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>from</code></dt><dd><p>Start position</p>
</dd>
<dt><code>to</code></dt><dd><p>End position</p>
</dd>
<dt><code>unit</code></dt><dd><p>Time unit (one of seconds, minutes, hours)</p>
</dd>
</dl>

<hr>
<h2 id='tSamples'>Samples per time period</h2><span id='topic+tSamples'></span>

<h3>Description</h3>

<p>Calculates the number of samples for a given duration of a wave
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tSamples(time = 1, wave = NULL, samp.rate = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tSamples_+3A_time">time</code></td>
<td>
<p>The duration in seconds</p>
</td></tr>
<tr><td><code id="tSamples_+3A_wave">wave</code></td>
<td>
<p>A Wave object containing pulses</p>
</td></tr>
<tr><td><code id="tSamples_+3A_samp.rate">samp.rate</code></td>
<td>
<p>Integer sampling rate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of samples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tSamples(10, samp.rate=44100)
## Not run: 
tSamples(10, wave=sheep)

## End(Not run)


</code></pre>

<hr>
<h2 id='typicalVolume'>Typical volumes</h2><span id='topic+typicalVolume'></span>

<h3>Description</h3>

<p>Typical volumes of everyday things.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>typicalVolume(thing = NA_character_)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="typicalVolume_+3A_thing">thing</code></td>
<td>
<p>Volume of thing, if missing then returns all volumes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Typical volume of thing in dBA, or if no thing parameter a data frame of all volumes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>typicalVolume()
typicalVolume("rocket launch")

</code></pre>

<hr>
<h2 id='tzRot'>Converts a timezone offset into a rotation</h2><span id='topic+tzRot'></span>

<h3>Description</h3>

<p>Given a timezone offset in hours returns a rotation in radians to apply to values for a diel plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tzRot(tz, init = pi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tzRot_+3A_tz">tz</code></td>
<td>
<p>Timezone numeric</p>
</td></tr>
<tr><td><code id="tzRot_+3A_init">init</code></td>
<td>
<p>Initial rotation. Defaults to pi.</p>
</td></tr>
</table>

<hr>
<h2 id='untagWave'>Untag a TaggedWave or TaggedWaveMC object</h2><span id='topic+untagWave'></span>

<h3>Description</h3>

<p>This function takes a TaggedWave/TaggedWaveMC object (or a list of such
objects) and returns a corresponding Wave/WaveMC object (or list of such
objects).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>untagWave(w)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="untagWave_+3A_w">w</code></td>
<td>
<p>A TaggedWave or TaggedWaveMC object (or list of such objects).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Wave or WaveMC object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
w &lt;- noise("white")
tw &lt;- tagWave(w)
w2 &lt;- untagWave(tw)

## End(Not run)
</code></pre>

<hr>
<h2 id='upsample'>Upsample a wave</h2><span id='topic+upsample'></span>

<h3>Description</h3>

<p>Used to upsample a Wave object. The upsampled sample rate must be an natural multiple
of the current sample rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upsample(wave, upsample.rate, method = "basic")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="upsample_+3A_wave">wave</code></td>
<td>
<p>Wave object to upsample.</p>
</td></tr>
<tr><td><code id="upsample_+3A_upsample.rate">upsample.rate</code></td>
<td>
<p>The sample rate to upsample to.</p>
</td></tr>
<tr><td><code id="upsample_+3A_method">method</code></td>
<td>
<p>&quot;basic&quot; for linear, or a function to interpolate NAs in a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A resampled Wave object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wave &lt;- tuneR::sine(4000, samp.rate=44100)
wave2 &lt;- upsample(wave, 88200)

</code></pre>

<hr>
<h2 id='validateIsWave'>Check an object is a Wave object</h2><span id='topic+validateIsWave'></span>

<h3>Description</h3>

<p>Helper function to test that the input is a Wave object. Will create an error if not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validateIsWave(wave)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validateIsWave_+3A_wave">wave</code></td>
<td>
<p>Object to test</p>
</td></tr>
</table>

<hr>
<h2 id='WaveFilter-class'>WaveFilter object for audio filters</h2><span id='topic+WaveFilter-class'></span>

<h3>Description</h3>

<p>A <code>WaveFilter</code> object is an object containing information necessary for the
<code>filterWave()</code> function to apply the filter to a <code>Wave</code> or <code>TaggedWave</code>
object. This is designed to allow a pipe operator (either magrittr or base R)
to be used to apply filters to a Wave in a pipeline. If used with a
<code>TaggedWave</code> object the function adds information to the <code>processing</code> slot
documenting its action.
</p>


<h3>Slots</h3>


<dl>
<dt><code>description</code></dt><dd><p>Description of the filter.</p>
</dd>
<dt><code>func</code></dt><dd><p>Name of function.</p>
</dd>
<dt><code>params</code></dt><dd><p>List of additional parameters to pass to the function.</p>
</dd>
</dl>

<hr>
<h2 id='windowing'>Windowing Function for Wave Objects</h2><span id='topic+windowing'></span>

<h3>Description</h3>

<p>Separates a Wave object into windows of a defined length and runs a function
on the window section. Windows may overlap, and the function can make use of
'parallel' package for multi-core processing. It will also show a progress bar
if the 'pbapply' package is installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>windowing(
  wave,
  window.length = 1000,
  FUN,
  window.overlap = 0,
  bind.wave = FALSE,
  complete.windows = TRUE,
  cluster = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="windowing_+3A_wave">wave</code></td>
<td>
<p>A Wave object or filename. Using filenames may save loading an
entire large file into memory.</p>
</td></tr>
<tr><td><code id="windowing_+3A_window.length">window.length</code></td>
<td>
<p>The length of the analysis window (in samples).</p>
</td></tr>
<tr><td><code id="windowing_+3A_fun">FUN</code></td>
<td>
<p>FUN to be applied to windows.</p>
</td></tr>
<tr><td><code id="windowing_+3A_window.overlap">window.overlap</code></td>
<td>
<p>The overlap between successive windows (in samples), a
negative value will result in a gap between windows.</p>
</td></tr>
<tr><td><code id="windowing_+3A_bind.wave">bind.wave</code></td>
<td>
<p>If TRUE and FUN returns wave objects, then these are
combined into a single object</p>
</td></tr>
<tr><td><code id="windowing_+3A_complete.windows">complete.windows</code></td>
<td>
<p>If TRUE (default) the final window will not be
processed unless it has a length equal to window.length.</p>
</td></tr>
<tr><td><code id="windowing_+3A_cluster">cluster</code></td>
<td>
<p>A cluster form the 'parallel' package for multi-core computation.</p>
</td></tr>
<tr><td><code id="windowing_+3A_...">...</code></td>
<td>
<p>Additional parameters to FUN</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
windowing(wave, window.length=1000, FUN=duration, window.overlap=0, bind.wave=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='writeAudacityLabels'>Write an Audacity label file</h2><span id='topic+writeAudacityLabels'></span>

<h3>Description</h3>

<p>Writes a list of <code>Annotation</code> objects to an Audacity label file.
<br /><br />
Internally this uses the <code>write.audacity()</code> function from the <code>seewave</code>
package (Sueur et al. 2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeAudacityLabels(annotations, file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="writeAudacityLabels_+3A_annotations">annotations</code></td>
<td>
<p>A list of <code>Annotation</code> objects.</p>
</td></tr>
<tr><td><code id="writeAudacityLabels_+3A_file">file</code></td>
<td>
<p>Path to the Audacity label file.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Sueur J, Aubin T, Simonis C (2008).
&ldquo;Seewave, a free modular tool for sound analysis and synthesis.&rdquo;
<em>Bioacoustics</em>, <b>18</b>(2), 213&ndash;226.
</p>

<hr>
<h2 id='yearlyFraction'>Calculate the fraction of a year given by a value</h2><span id='topic+yearlyFraction'></span>

<h3>Description</h3>

<p>Given an object that can be coerced to POSIXlt, return the fraction of a year represented by the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yearlyFraction(t, year = 2022, input = "POSIX", unit = "radians")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="yearlyFraction_+3A_t">t</code></td>
<td>
<p>Object to be converted to a fraction</p>
</td></tr>
<tr><td><code id="yearlyFraction_+3A_year">year</code></td>
<td>
<p>Year to calculate fractions of (allows for leap years)</p>
</td></tr>
<tr><td><code id="yearlyFraction_+3A_input">input</code></td>
<td>
<p>One of POSIXlt (default)</p>
</td></tr>
<tr><td><code id="yearlyFraction_+3A_unit">unit</code></td>
<td>
<p>If set to radians outputs a position around a circle. If set to fraction outputs the raw fraction.</p>
</td></tr>
</table>

<hr>
<h2 id='yearlyLabels'>Generate labels for a yearly plot</h2><span id='topic+yearlyLabels'></span>

<h3>Description</h3>

<p>Generates monthly labels for a yearlyPlot()..
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yearlyLabels()
</code></pre>

<hr>
<h2 id='yearlyPlot'>Create a yearly plot</h2><span id='topic+yearlyPlot'></span>

<h3>Description</h3>

<p>ToDO......
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yearlyPlot(
  year = 2022,
  lat,
  lon,
  limits = c(0, 2),
  plot = NULL,
  method = "plotrix",
  legend = F
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="yearlyPlot_+3A_year">year</code></td>
<td>
<p>Year to plot (allows for leap years).</p>
</td></tr>
<tr><td><code id="yearlyPlot_+3A_lat">lat</code></td>
<td>
<p>Numeric latitude.</p>
</td></tr>
<tr><td><code id="yearlyPlot_+3A_lon">lon</code></td>
<td>
<p>Numeric longitude.</p>
</td></tr>
<tr><td><code id="yearlyPlot_+3A_limits">limits</code></td>
<td>
<p>Plotting limits of the daylight regions, default to c(1,2)</p>
</td></tr>
<tr><td><code id="yearlyPlot_+3A_plot">plot</code></td>
<td>
<p>Character vector of components to plot</p>
</td></tr>
<tr><td><code id="yearlyPlot_+3A_method">method</code></td>
<td>
<p>Plotting library to use</p>
</td></tr>
<tr><td><code id="yearlyPlot_+3A_legend">legend</code></td>
<td>
<p>Whether to show a legend</p>
</td></tr>
</table>

<hr>
<h2 id='yearlyPositions'>Generate positions of labels for a yearly plot</h2><span id='topic+yearlyPositions'></span>

<h3>Description</h3>

<p>Generates positions for monthly labels of a dielPlot() in radians. The positions can either be for the
start of the month, or middle of the month.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yearlyPositions(year = 2022, format = "months")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="yearlyPositions_+3A_year">year</code></td>
<td>
<p>Year to calculate</p>
</td></tr>
<tr><td><code id="yearlyPositions_+3A_format">format</code></td>
<td>
<p>One of months, mid-months, days</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function allows for leap years if the year parameter is provided.
</p>

<hr>
<h2 id='zerocross'>Identify zero crossings in a Wave object</h2><span id='topic+zerocross'></span>

<h3>Description</h3>

<p>Returns a vector of the position (in samples) of zero crossings in
a Wave object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zerocross(wave)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zerocross_+3A_wave">wave</code></td>
<td>
<p>A Wave object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of zero crossing locations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
zerocross(sheep)

## End(Not run)
</code></pre>

<hr>
<h2 id='zeroSpectrum'>Zero spectrum</h2><span id='topic+zeroSpectrum'></span>

<h3>Description</h3>

<p>This function takes a spectrum from seewave and creates a new zero-valued spectrum with the same structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zeroSpectrum(s1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zeroSpectrum_+3A_s1">s1</code></td>
<td>
<p>Spectrum to emulate the structure of.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A zero-valued spectrum.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
zeroSpectrum(spec)

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
