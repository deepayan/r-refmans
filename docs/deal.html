<!DOCTYPE html><html><head><title>Help for package deal</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {deal}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#autosearch'><p>Greedy search</p></a></li>
<li><a href='#deal-internal'><p>deal internal functions</p></a></li>
<li><a href='#drawnetwork'><p>Graphical interface for editing networks</p></a></li>
<li><a href='#genlatex'><p>From a network family, generate LaTeX output</p></a></li>
<li><a href='#insert'><p>Insert/remove an arrow in network</p></a></li>
<li><a href='#jointprior'><p>Calculates the joint prior distribution</p></a></li>
<li><a href='#ksl'><p>Health and social characteristics</p></a></li>
<li><a href='#learn'><p>Estimation of parameters in the local probability</p>
distributions</a></li>
<li><a href='#makesimprob'><p>Make a suggestion for simulation probabilities</p></a></li>
<li><a href='#maketrylist'><p>Creates the full trylist</p></a></li>
<li><a href='#network'><p>Bayesian network data structure</p></a></li>
<li><a href='#Network tools'><p>Tools for manipulating networks</p></a></li>
<li><a href='#networkfamily'><p>Generates and learns all networks for a set of variables.</p></a></li>
<li><a href='#node'><p>Representation of nodes</p></a></li>
<li><a href='#numbermixed'><p>The number of possible networks</p></a></li>
<li><a href='#nwfsort'><p>Sorts a list of networks</p></a></li>
<li><a href='#perturb'><p>Perturbs a network</p></a></li>
<li><a href='#prob'><p>Local probability distributions</p></a></li>
<li><a href='#rats'><p>Weightloss of rats</p></a></li>
<li><a href='#readnet'><p>Reads/saves .net file</p></a></li>
<li><a href='#rnetwork'><p>Simulation of data sets with a given dependency structure</p></a></li>
<li><a href='#score'><p>Network score</p></a></li>
<li><a href='#unique.networkfamily'><p>Makes a network family unique.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.2-42</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-09</td>
</tr>
<tr>
<td>Title:</td>
<td>Learning Bayesian Networks with Mixed Variables</td>
</tr>
<tr>
<td>Author:</td>
<td>Susanne Gammelgaard Bottcher, Claus Dethlefsen.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Claus Dethlefsen &lt;rpackage.deal@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.0.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Bayesian networks with continuous and/or discrete
        variables can be learned and compared from data. The method is described in Boettcher and Dethlefsen (2003), &lt;<a href="https://doi.org/10.18637%2Fjss.v008.i20">doi:10.18637/jss.v008.i20</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Collate:</td>
<td>addarrows.R autosearch.R conditional.R cycletest.R
drawnetwork.R findex.R generic.R genlatex.R heuristic.R
inspectprob.R jointcont.R jointdisc.R jointprior.R learning.R
makesimprob.R fullsimprob.R maketrylist.R master.R network.R
networkfamily.R node.R numbermixed.R perturb.R postc.R postc0.R
postdist.R readnet.R rnetwork.R savenet.R unique.R</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-09 19:33:37 UTC; clausdethlefsen</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-09 21:50:23 UTC</td>
</tr>
</table>
<hr>
<h2 id='autosearch'>Greedy search</h2><span id='topic+autosearch'></span><span id='topic+heuristic'></span><span id='topic+gettable'></span>

<h3>Description</h3>

<p>From initial network, does local perturbations to increase network score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autosearch(initnw,data,prior=jointprior(network(data)),maxiter=50,
           trylist= vector("list",size(initnw)),trace=TRUE,
           timetrace=TRUE,showban=FALSE,removecycles=FALSE) 

heuristic(initnw,data,prior=jointprior(network(data)),
          maxiter=100,restart=10,degree=size(initnw),
          trylist= vector("list",size(initnw)),trace=TRUE,
          timetrace=TRUE,removecycles=FALSE)
gettable(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autosearch_+3A_initnw">initnw</code></td>
<td>
<p>an object of class <code><a href="#topic+network">network</a></code>, from which the
search is started. </p>
</td></tr> 
<tr><td><code id="autosearch_+3A_data">data</code></td>
<td>
<p>a data frame used for learning the network, see
<code><a href="#topic+network">network</a></code>.</p>
</td></tr> 
<tr><td><code id="autosearch_+3A_prior">prior</code></td>
<td>
<p>a list containing parameter priors, generated by
<code><a href="#topic+jointprior">jointprior</a></code>.</p>
</td></tr> 
<tr><td><code id="autosearch_+3A_maxiter">maxiter</code></td>
<td>
<p>an integer, which gives the maximum number of steps in the
search algorithm.</p>
</td></tr> 
<tr><td><code id="autosearch_+3A_restart">restart</code></td>
<td>
<p>an integer, which gives the number of times to perturb
<code>initnw</code> and rerun the 
search.</p>
</td></tr>
<tr><td><code id="autosearch_+3A_degree">degree</code></td>
<td>
<p>an integer, which gives the degree of perturbation, see
<code><a href="#topic+perturb">perturb</a></code>.</p>
</td></tr> 
<tr><td><code id="autosearch_+3A_trylist">trylist</code></td>
<td>
<p>a list used internally for reusing learning of nodes,
see <code><a href="#topic+maketrylist">maketrylist</a></code>.</p>
</td></tr> 
<tr><td><code id="autosearch_+3A_trace">trace</code></td>
<td>
<p>a logical. If <code>TRUE</code>, plots the accepted networks
during search.</p>
</td></tr> 
<tr><td><code id="autosearch_+3A_timetrace">timetrace</code></td>
<td>
<p>a logical. If <code>TRUE</code>, prints some timing
information on the screen.</p>
</td></tr> 
<tr><td><code id="autosearch_+3A_showban">showban</code></td>
<td>
<p>a logical passed to  the plot method for network
objects. If
<code>FALSE</code>, the banned arrows are not shown in the plots (if
<code>trace</code> is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="autosearch_+3A_removecycles">removecycles</code></td>
<td>
<p>a logical. If <code>TRUE</code>, all networks explored in the
search is returned, except for networks containing a cycle. If <code>FALSE</code>, all networks are returned, including
cyclic networks.</p>
</td></tr>
<tr><td><code id="autosearch_+3A_x">x</code></td>
<td>
<p>an output object from a search.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code>autosearch</code>, a list of networks is in each step
created with either one
arrow added, one arrow deleted or one arrow turned (if a cycle is not
generated). The network scores of all the proposal networks are
calculated and the network with the highest score is chosen for the
next step in the search. If no proposed network has a higher network
score than the previous network, the search is terminated. The
network with the highest network score is returned, along with a list
containing all tried networks (depending on the value of <code>removecycles</code>).
</p>
<p><code>heuristic</code> restarts by perturbing <code>initnw</code>
<code>degree</code> times and calling 
<code>autosearch</code> again. The number
of restarts is given by the option <code>restart</code>.
</p>


<h3>Value</h3>

<p><code>autosearch</code> and <code>heuristic</code> returns a list with three
elements, that may be accessed using <code><a href="#topic+getnetwork">getnetwork</a></code>,
<code><a href="#topic+gettable">gettable</a></code> and <code><a href="#topic+gettrylist">gettrylist</a></code>. The elements are
</p>
<table>
<tr><td><code>nw</code></td>
<td>
<p>an object of class <code><a href="#topic+network">network</a></code>, which gives the
network with the highest score.</p>
</td></tr>
<tr><td><code>table</code></td>
<td>
<p>a table with all tried
networks. If removecycles is <code>FALSE</code>, the networks may contain
cycles. The table contains two columns: <code>model</code> with a 
string representation of the model and <code>score</code> with the
corresponding log network score. The table can be translated to a
<code><a href="#topic+networkfamily">networkfamily</a></code> using <code><a href="#topic+makenw">makenw</a></code>.</p>
</td></tr>  
<tr><td><code>trylist</code></td>
<td>
<p>an updated list used internally for reusing learning
of nodes, see <code><a href="#topic+maketrylist">maketrylist</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Susanne Gammelgaard Bottcher, <br />
Claus Dethlefsen <a href="mailto:rpackage.deal@gmail.com">rpackage.deal@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+perturb">perturb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rats)
fit       &lt;- network(rats)
fit.prior &lt;- jointprior(fit,12)
fit       &lt;- getnetwork(learn(fit,rats,fit.prior))
fit       &lt;- getnetwork(insert(fit,2,1,rats,fit.prior))
fit       &lt;- getnetwork(insert(fit,1,3,rats,fit.prior))
hisc      &lt;- autosearch(fit,rats,fit.prior,trace=FALSE)
hisc      &lt;- autosearch(fit,rats,fit.prior,trace=FALSE,removecycles=TRUE) # slower
plot(getnetwork(hisc))

hisc2     &lt;- heuristic(fit,rats,fit.prior,restart=10,trace=FALSE)
plot(getnetwork(hisc2))
print(modelstring(getnetwork(hisc2)))
plot(makenw(gettable(hisc2),fit))
</code></pre>

<hr>
<h2 id='deal-internal'>deal internal functions</h2><span id='topic+printline'></span><span id='topic+post'></span><span id='topic+reinis'></span><span id='topic+post0'></span><span id='topic+postc'></span><span id='topic+postc0c'></span><span id='topic+postcc'></span><span id='topic+learnnode'></span><span id='topic+udisclik'></span><span id='topic+addrandomarrow'></span><span id='topic+turnrandomarrow'></span><span id='topic+deleterandomarrow'></span><span id='topic+addarrows'></span><span id='topic+addarrow'></span><span id='topic+turnarrow'></span><span id='topic+removearrow'></span><span id='topic+cycletest'></span><span id='topic+findleaf'></span><span id='topic+conditional.cont'></span><span id='topic+conditional.disc'></span><span id='topic+conditional'></span><span id='topic+cond.node'></span><span id='topic+cond'></span><span id='topic+elementin'></span><span id='topic+findex'></span><span id='topic+jointdisc'></span><span id='topic+jointcont'></span><span id='topic+localmaster'></span><span id='topic+postdist'></span><span id='topic+postdist.node'></span><span id='topic+nwequal'></span><span id='topic+inspectprob'></span><span id='topic+DealTestClass-class'></span><span id='topic+networkclass-class'></span><span id='topic+integerOrNULL-class'></span><span id='topic+graphComponents-methods'></span><span id='topic+graphComponents+2Cnetworkclass-method'></span><span id='topic+setGraphComponents-methods'></span><span id='topic+setGraphComponents+2Cnetworkclass-method'></span><span id='topic+Str-methods'></span><span id='topic+Str+2Cnetworkclass-method'></span><span id='topic+label+2CDealTestClass-method'></span><span id='topic+width+2CDealTestClass-method'></span><span id='topic+dynamic.Graph-methods'></span><span id='topic+dynamic.Graph+2Cnetworkclass-method'></span><span id='topic+testEdge-methods'></span><span id='topic+modifyModel-methods'></span><span id='topic+modifyModel+2Cnetworkclass-method'></span><span id='topic+testEdge+2Cnetworkclass-method'></span>

<h3>Description</h3>

<p>These are functions internally called by other functions
in the package <code>deal</code> and not meant to be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printline(s="-",n=60)

post   (mu,tau,rho,phi,y,z,timetrace=FALSE) 
postc  (mu,tau,rho,phi,y,z,timetrace=FALSE) 
postcc (mu,tau,rho,phi,y,z,timetrace=FALSE) 
post0  (mu,tau,rho,phi,y,timetrace=FALSE) 
postc0c(mu,tau,rho,phi,y,timetrace=FALSE) 

learnnode(node,nw,df,prior=jointprior(nw),timetrace=FALSE)
udisclik(node,nw,df)

addrandomarrow(nw,data,prior,trylist=vector("list",size(nw)),nocalc=FALSE,
               timetrace=FALSE)
turnrandomarrow(nw,data,prior,trylist=vector("list",size(nw)),nocalc=FALSE,
               timetrace=FALSE)
deleterandomarrow(nw,data,prior,trylist=vector("list",size(nw)),nocalc=FALSE,
               timetrace=timetrace)

addarrows(nw, node, data, prior,trylist=vector("list",size(nw)))

addarrow   (nw,df,prior,trylist=vector("list",size(nw))) 
turnarrow  (nw,df,prior,trylist=vector("list",size(nw))) 
removearrow(nw,df,prior,trylist=vector("list",size(nw))) 

cycletest(nw)
findleaf (nw) 

conditional.cont(A,mu,nu,rho,phi) 
conditional(A,master,nw) 
conditional.disc(A,master) 
cond.node(node,nw,nw.prior=jointprior(nw)) 

elementin(nw,nwl)

findex (i, dim, config=TRUE)

jointdisc(nw,timetrace=FALSE)
jointcont(nw,timetrace=FALSE)

localmaster(family,nw,prior=jointprior(nw))

postdist(nw) 
postdist.node(nd,nw,vtype = "mode")

nwequal(nw1,nw2)

inspectprob(nw,unitscale=20,cexscale=8,
            arrowlength=.25,xr=c(0,350),yr=xr,...) 

	     </code></pre>


<h3>Author(s)</h3>

<p>Susanne Gammelgaard Bottcher, <br />
Claus Dethlefsen <a href="mailto:rpackage.deal@gmail.com">rpackage.deal@gmail.com</a>.
</p>

<hr>
<h2 id='drawnetwork'>Graphical interface for editing networks</h2><span id='topic+drawnetwork'></span>

<h3>Description</h3>

<p><code>drawnetwork</code> allows the user to specify a Bayesian network through a point and click interface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawnetwork(nw,df,prior,trylist=vector("list",size(nw)),
            unitscale=20,cexscale=8,
            arrowlength=.25,nocalc=FALSE,
            yr=c(0,350),xr=yr,...)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawnetwork_+3A_nw">nw</code></td>
<td>
<p>an object of class <code><a href="#topic+network">network</a></code> to be edited.</p>
</td></tr>
<tr><td><code id="drawnetwork_+3A_df">df</code></td>
<td>
<p>a data frame used for learning the network, see
<code><a href="#topic+network">network</a></code>.</p>
</td></tr> 
<tr><td><code id="drawnetwork_+3A_prior">prior</code></td>
<td>
<p>a list containing parameter priors, generated by
<code><a href="#topic+jointprior">jointprior</a></code>.</p>
</td></tr> 
<tr><td><code id="drawnetwork_+3A_trylist">trylist</code></td>
<td>
<p>a list used internally for reusing learning of nodes,
see <code><a href="#topic+maketrylist">maketrylist</a></code>.</p>
</td></tr> 
<tr><td><code id="drawnetwork_+3A_cexscale">cexscale</code></td>
<td>
<p>a numeric passed to the plot method for network
objects. Measures the scaled size of text and symbols.</p>
</td></tr> 
<tr><td><code id="drawnetwork_+3A_arrowlength">arrowlength</code></td>
<td>
<p>a numeric passed to
the plot method for network
objects. Measures the length of the edges of the arrowheads.</p>
</td></tr>
<tr><td><code id="drawnetwork_+3A_nocalc">nocalc</code></td>
<td>
<p>a logical. If <code>TRUE</code>, no learning procedure is called, see eg. <code><a href="#topic+rnetwork">rnetwork</a></code>.</p>
</td></tr>
<tr><td><code id="drawnetwork_+3A_unitscale">unitscale</code></td>
<td>
<p>a numeric passed to
the plot method for network
objects. Scale parameter for chopping off arrow heads.</p>
</td></tr>
<tr><td><code id="drawnetwork_+3A_xr">xr</code></td>
<td>
<p>a numeric vector with two components containing the range on x-axis.</p>
</td></tr>
<tr><td><code id="drawnetwork_+3A_yr">yr</code></td>
<td>
<p>a numeric vector with two components containing the range on y-axis.</p>
</td></tr>
<tr><td><code id="drawnetwork_+3A_...">...</code></td>
<td>
<p>additional plot arguments, passed to  the plot method for network
objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To insert an arrow from node 'A' to node 'B', first click node 'A' and
then click node 'B'. When the graph is finished, click 'stop'.
</p>
<p>To specify that an arrow must not be present, press 'ban' (a toggle)
and draw the arrow. This is shown as a red dashed arrow. It is possible
to ban both directions between nodes. The ban list is stored with the
network in the property <code>banlist</code>. It is a matrix with two
columns. Each row is the 'from' node index and the 'to' node index,
where the indices are the column number in the data frame.
</p>
<p>Note that the network score changes as the network is re-learned
whenever a change is made (unless <code>nocalc</code> is <code>TRUE</code>).
</p>


<h3>Value</h3>

<p>A list with two elements that may be accessed using
<code><a href="#topic+getnetwork">getnetwork</a></code> and <code><a href="#topic+gettrylist">gettrylist</a></code>. The elements are
</p>
<table>
<tr><td><code>nw</code></td>
<td>
<p>an object of class <code><a href="#topic+network">network</a></code> with the final network.</p>
</td></tr>
<tr><td><code>trylist</code></td>
<td>
<p>an updated list used internally for reusing learning
of nodes, see <code><a href="#topic+maketrylist">maketrylist</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Susanne Gammelgaard Bottcher, <br />
Claus Dethlefsen <a href="mailto:rpackage.deal@gmail.com">rpackage.deal@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+network">network</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rats)
rats.nw    &lt;- network(rats)
rats.prior &lt;- jointprior(rats.nw,12)
rats.nw    &lt;- getnetwork(learn(rats.nw,rats,rats.prior))

## Not run: newrat  &lt;- getnetwork(drawnetwork(rats.nw,rats,rats.prior))
</code></pre>

<hr>
<h2 id='genlatex'>From a network family, generate LaTeX output</h2><span id='topic+genlatex'></span><span id='topic+genpicfile'></span>

<h3>Description</h3>

<p>The networks in a network family is arranged as
pictex-graphs in a LaTeX-table. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genlatex(nwl,outdir="pic/",prefix="scoretable",picdir="",picpre="pic",
         ncol=5,nrow=7,width=12/ncol,vadjust=-1.8)
genpicfile (nwl,outdir="pic/",prefix="pic",w=1.6,h=1.6,bigscale=3) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genlatex_+3A_nwl">nwl</code></td>
<td>
<p>object of class <code>networkfamily</code> containing a list of
objects of class <code>network</code>.</p>
</td></tr>
<tr><td><code id="genlatex_+3A_outdir">outdir</code></td>
<td>
<p>character string, the directory for storing output.</p>
</td></tr>
<tr><td><code id="genlatex_+3A_prefix">prefix</code></td>
<td>
<p>character string, the filename (without extension) of the LaTeX file. The
filenames of the picfiles begin with the given prefix.</p>
</td></tr> 
<tr><td><code id="genlatex_+3A_picdir">picdir</code></td>
<td>
<p>character string, the directory where pic-files are stored.</p>
</td></tr>
<tr><td><code id="genlatex_+3A_picpre">picpre</code></td>
<td>
<p>character string, prefix for pic-files.</p>
</td></tr>
<tr><td><code id="genlatex_+3A_ncol">ncol</code></td>
<td>
<p>integer, the number of columns in LaTeX table.</p>
</td></tr>
<tr><td><code id="genlatex_+3A_nrow">nrow</code></td>
<td>
<p>integer, the number of rows in LaTeX table.</p>
</td></tr>
<tr><td><code id="genlatex_+3A_width">width</code></td>
<td>
<p>numeric, the width of each cell in the LaTeX table.</p>
</td></tr>
<tr><td><code id="genlatex_+3A_vadjust">vadjust</code></td>
<td>
<p>numeric, the vertical adjustment in LaTeX table.</p>
</td></tr>
<tr><td><code id="genlatex_+3A_w">w</code></td>
<td>
<p>numeric, the width of pictex objects</p>
</td></tr>
<tr><td><code id="genlatex_+3A_h">h</code></td>
<td>
<p>numeric, the height of pictex objects</p>
</td></tr>
<tr><td><code id="genlatex_+3A_bigscale">bigscale</code></td>
<td>
<p>numeric, the scaling of the best network, which is output in 'nice.tex'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Files:
</p>
<table>
<tr><td><code>{outdir}{picpre}xx.tex</code></td>
<td>
<p>one pictex file for each network in the
network family, indexed by xx.</p>
</td></tr>
<tr><td><code>{outdir}{prefix}.tex</code></td>
<td>
<p>LaTeX file with table including all pictex files.</p>
</td></tr>
<tr><td><code>{outdir}{picpre}nice.tex</code></td>
<td>
<p>pictex file with the best network.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Susanne Gammelgaard Bottcher, <br />
Claus Dethlefsen <a href="mailto:rpackage.deal@gmail.com">rpackage.deal@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+networkfamily">networkfamily</a></code>, <code><a href="grDevices.html#topic+pictex">pictex</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rats)
allrats &lt;- getnetwork(networkfamily(rats,network(rats)))
allrats &lt;- nwfsort(allrats)

## Not run: dir.create("c:/temp")
## Not run: genpicfile(allrats,outdir="c:/temp/pic/")
## Not run: genlatex(allrats,outdir="c:/temp/pic/",picdir="c:/temp/pic/")

## LATEX FILE:
#\documentclass{article}
#\usepackage{array,pictex}
#\begin{document}
#\input{scoretable}
#\input{picnice}
#\end{document}

#data(ksl)
#ksl.nw  &lt;- network(ksl)
#ksl.prior &lt;- jointprior(ksl.nw,64)
#mybanlist &lt;- matrix(c(5,5,6,6,7,7,9,
#                    8,9,8,9,8,9,8),ncol=2)
#banlist(ksl.nw) &lt;- mybanlist                  
#ksl.nw &lt;- getnetwork(learn(ksl.nw,ksl,ksl.prior))
#ksl.search &lt;- autosearch(ksl.nw,ksl,ksl.prior,
#                      trace=TRUE)
#ksl.searchlist &lt;- makenw(ksl.search$table,ksl.search$nw)
#ksl.searchlist &lt;- nwfsort(ksl.searchlist)
## Not run: genpicfile(ksl.searchlist)
## Not run: genlatex(ksl.searchlist)

</code></pre>

<hr>
<h2 id='insert'>Insert/remove an arrow in network</h2><span id='topic+insert'></span><span id='topic+remover'></span>

<h3>Description</h3>

<p>Inserts/removes one arrow in a network (if legal)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insert (nw,j,i,df,prior,nocalc=FALSE,trylist=vector("list",size(nw))) 
remover(nw,j,i,df,prior,nocalc=FALSE,trylist=vector("list",size(nw))) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insert_+3A_nw">nw</code></td>
<td>
<p>an object of class <code><a href="#topic+network">network</a></code>.</p>
</td></tr>
<tr><td><code id="insert_+3A_j">j</code></td>
<td>
<p>integer, giving the index of the 'from' node.</p>
</td></tr>
<tr><td><code id="insert_+3A_i">i</code></td>
<td>
<p>integer, giving the index of the 'to' node.</p>
</td></tr>
<tr><td><code id="insert_+3A_df">df</code></td>
<td>
<p>a data frame used for learning the network, see
<code><a href="#topic+network">network</a></code>.</p>
</td></tr> 
<tr><td><code id="insert_+3A_prior">prior</code></td>
<td>
<p>a list describing parameter priors, generated by
<code><a href="#topic+jointprior">jointprior</a></code>.</p>
</td></tr> 
<tr><td><code id="insert_+3A_nocalc">nocalc</code></td>
<td>
<p>a logical. If <code>TRUE</code>, learning is not called.</p>
</td></tr>
<tr><td><code id="insert_+3A_trylist">trylist</code></td>
<td>
<p>a list, used internally for reusing learning of nodes,
see <code><a href="#topic+maketrylist">maketrylist</a></code>.</p>
</td></tr> </table>


<h3>Details</h3>

<p>Examines if the arrow from <code>j</code> to <code>i</code> is legal according to
the following criteria
</p>
<p>Arrows from/to the same node are not legal.
</p>
<p>Arrows from continous nodes to discrete nodes are not legal.
</p>
<p>Arrows banned in ban list are not legal, see <code><a href="#topic+drawnetwork">drawnetwork</a></code>.
</p>
<p>Arrows already existing in the network are not legal.
</p>
<p>If the arrow is not legal, a <code>NULL</code> network is returned. Otherwise, the
arrow is inserted/removed, the network is re-learned (if
<code>nocalc</code> is <code>FALSE</code>). The trylist is updated.
</p>


<h3>Value</h3>

<p>A list with two elements
</p>
<table>
<tr><td><code>nw</code></td>
<td>
<p>an object of class <code><a href="#topic+network">network</a></code> with the arrow
added/removed if this is possible. If not, <code>NULL</code> is returned.</p>
</td></tr>
<tr><td><code>trylist</code></td>
<td>
<p>an updated list, used internally for reusing learning
of nodes, see <code><a href="#topic+maketrylist">maketrylist</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Susanne Gammelgaard Bottcher, <br />
Claus Dethlefsen <a href="mailto:rpackage.deal@gmail.com">rpackage.deal@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rats)
rats.nw    &lt;- network(rats)
rats.nw    &lt;- getnetwork(insert(rats.nw,2,1,nocalc=TRUE))
rats.prior &lt;- jointprior(rats.nw,12)

rats.nw2   &lt;- network(rats)
rats.nw2   &lt;- getnetwork(learn(rats.nw2,rats,rats.prior))
rats.nw2   &lt;- getnetwork(insert(rats.nw2,1,2,rats,rats.prior))

rats.nw3   &lt;- getnetwork(remover(rats.nw2,1,2,rats,rats.prior))
</code></pre>

<hr>
<h2 id='jointprior'>Calculates the joint prior distribution</h2><span id='topic+jointprior'></span>

<h3>Description</h3>

<p>Given a network with a <code>prob</code> property for each node, derives the
joint probability distribution. Then the quantities needed in
the local master procedure for finding the local parameter priors are
deduced.</p>


<h3>Usage</h3>

<pre><code class='language-R'>jointprior(nw,N=NA,phiprior="bottcher",timetrace=FALSE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jointprior_+3A_nw">nw</code></td>
<td>
<p>an object of class <code><a href="#topic+network">network</a></code>. Each node must
have a <code>prob</code> property to describe the local probability
distribution. The <code>prob</code> property
is created using <code><a href="#topic+prob">prob</a></code> method for network objects, which is called by the
<code><a href="#topic+network">network</a></code> function.</p>
</td></tr>
<tr><td><code id="jointprior_+3A_n">N</code></td>
<td>
<p>an integer, which gives the size of the imaginary data base. If
this is too small, 
<code>NA</code>'s may be created in the output, resulting in errors in
<code><a href="#topic+learn">learn</a></code>. If no <code>N</code> is given, the procedure tries to 
set a value as low as possible.</p>
</td></tr> 
<tr><td><code id="jointprior_+3A_phiprior">phiprior</code></td>
<td>
<p>a string, which specifies how the prior for phi is
calculated. Either <code>phiprior="bottcher"</code> or
<code>phiprior="heckerman"</code> can be used.</p>
</td></tr> 
<tr><td><code id="jointprior_+3A_timetrace">timetrace</code></td>
<td>
<p>a logical. If <code>TRUE</code>, prints some timing
information on the screen.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>For the discrete part of the network, the joint probability
distribution is 
calculated by multiplying together the local probability
distributions. Then, <code>jointalpha</code> is determined by multiplying
each entry in the joint probability distribution by the size of the
imaginary data base <code>N</code>. 
</p>
<p>For the mixed part of the network, for each configuration of the discrete
variables, the joint Gaussian distribution of the continuous
variables is constructed and represented by <code>jointmu</code> (one
row for each configuration of the discrete parents) and
<code>jointsigma</code> (a list of matrices &ndash; one for each configuration of
the discrete parents). The configurations of the discrete parents are
ordered according to <code><a href="#topic+findex">findex</a></code>. The algorithm for
constructing the joint distribution of the continuous variables is
described in Shachter and Kenley (1989). 
</p>
<p>Then, <code>jointalpha</code>, <code>jointnu</code>, <code>jointrho</code>, <code>mu</code> and
<code>jointphi</code> are deduced. These quantities are later used for
deriving local parameter priors.
</p>
<p>For each configuration <code>i</code> of the discrete variables,
</p>
<p style="text-align: center;"><code class="reqn">\nu_i=\rho_i=\alpha_i</code>
</p>
<p> and
</p>
<p style="text-align: center;"><code class="reqn">\phi_i = (\nu_i -1)\Sigma_i</code>
</p>

<p>if <code>phiprior="bottcher"</code>, see Bottcher(2001) and
</p>
<p style="text-align: center;"><code class="reqn">\phi_i = \nu_i(\rho_i -2)\Sigma_i/(\nu_i+1)</code>
</p>

<p>if <code>phiprior="heckerman"</code>, see Heckerman, Geiger and Chickering (1995).
</p>


<h3>Value</h3>

<p>A list with the following elements,
</p>
<table>
<tr><td><code>jointalpha</code></td>
<td>
<p>a table used in the local master procedure for discrete variables.</p>
</td></tr>
<tr><td><code>jointnu</code></td>
<td>
<p>a table used in the local master procedure for continuous variables.</p>
</td></tr>
<tr><td><code>jointrho</code></td>
<td>
<p>a table used in the local master procedure for continuous variables.</p>
</td></tr>
<tr><td><code>jointmu</code></td>
<td>
<p>a numeric matrix used in the local master procedure for continuous variables.</p>
</td></tr>
<tr><td><code>jointsigma</code></td>
<td>
<p>a list of numeric matrices (not used in further calculations).</p>
</td></tr>
<tr><td><code>jointphi</code></td>
<td>
<p>a list of numeric matrices used in the local master procedure for continuous variables.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Susanne Gammelgaard Bottcher, <br />
Claus Dethlefsen <a href="mailto:rpackage.deal@gmail.com">rpackage.deal@gmail.com</a>.
</p>


<h3>References</h3>

<p>Bottcher, S.G. (2001). Learning Bayesian Networks with Mixed Variables, Artificial Intelligence and Statistics 2001, Morgan Kaufmann, San Francisco, CA, USA, 149-156.
</p>
<p>Heckerman, D., Geiger, D. and Chickering, D. (1995). Learning Bayesian
networks: The combination of knowledge and statistical data. Machine
Learning, 20: 197-243.  
</p>
<p>Shachter, R.D. and Kenley, C.R. (1989), Gaussian influence diagrams. Management
Science, 35:527-550.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+network">network</a></code>, <code><a href="#topic+prob">prob</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rats)
rats.nw    &lt;- network(rats)
rats.prior &lt;- jointprior(rats.nw,12)

## Not run: savenet(rats.nw,file("rats.net"))
## Not run: rats.nw &lt;- readnet(file("rats.net"))
## Not run: rats.nw &lt;- prob(rats.nw,rats)
## Not run: rats.prior &lt;- jointprior(rats.nw,12)

</code></pre>

<hr>
<h2 id='ksl'>Health and social characteristics</h2><span id='topic+ksl'></span>

<h3>Description</h3>

<p>Data from a study measuring health and social characteristics of 
representative samples of Danish 70 year olds, taken in 1967 and 1984.
</p>


<h3>Format</h3>

<p>A data frame with variables of both discrete and continuous
types.
</p>

<dl>
<dt>FEV</dt><dd><p>Forced ejection volume</p>
</dd>
<dt>Kol</dt><dd><p>Cholesterol</p>
</dd>
<dt>Hyp</dt><dd><p>Hypertension (no/yes)</p>
</dd>
<dt>logBMI</dt><dd><p>Logarithm of Body Mass Index</p>
</dd>
<dt>Smok</dt><dd><p>Smoking (no/yes)</p>
</dd>
<dt>Alc</dt><dd><p>Alcohol consumption (seldom/frequently)</p>
</dd>
<dt>Work</dt><dd><p>Working (yes/no)</p>
</dd>
<dt>Sex</dt><dd><p>male/female</p>
</dd>
<dt>Year</dt><dd><p>Survey year (1967/1984)</p>
</dd>
</dl>


<hr>
<h2 id='learn'>Estimation of parameters in the local probability
distributions</h2><span id='topic+learn'></span>

<h3>Description</h3>

<p>Updates the distributions of the parameters in the network,
based on a prior network and data. Also, the network score is calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>learn (nw, df, prior=jointprior(nw),
               nodelist=1:size(nw),
               trylist=vector("list",size(nw)),
               timetrace=FALSE) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="learn_+3A_nw">nw</code></td>
<td>
<p>an object of class <code><a href="#topic+network">network</a></code>.</p>
</td></tr>
<tr><td><code id="learn_+3A_df">df</code></td>
<td>
<p>a data frame used for learning the network, see
<code><a href="#topic+network">network</a></code>.</p>
</td></tr> 
<tr><td><code id="learn_+3A_prior">prior</code></td>
<td>
<p>a list containing parameter priors, generated by
<code><a href="#topic+jointprior">jointprior</a></code>.</p>
</td></tr> 
<tr><td><code id="learn_+3A_nodelist">nodelist</code></td>
<td>
<p>a numeric vector of indices of nodes to be learned.</p>
</td></tr>
<tr><td><code id="learn_+3A_trylist">trylist</code></td>
<td>
<p>a list used internally for reusing learning of nodes,
see <code><a href="#topic+maketrylist">maketrylist</a></code>.</p>
</td></tr> 
<tr><td><code id="learn_+3A_timetrace">timetrace</code></td>
<td>
<p>a logical. If <code>TRUE</code>, prints some timing
information on the screen.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The procedure <code>learn</code> determines the master prior, local parameter
priors and local parameter posteriors, see Bottcher (2001). It may be called on all nodes
(default) or just a single node. 
</p>
<p>From the joint prior distribution, the marginal distribution of
all parameters in the family consisting of the node and its parents
can be determined. This is the master prior, see
<code><a href="#topic+localmaster">localmaster</a></code>.
</p>
<p>The local parameter priors are now determined by conditioning in
the master prior distribution, see
<code><a href="#topic+conditional">conditional</a></code>. The hyperparameters associated with the
local parameter prior distribution is attached to each node in the
property <code>condprior</code>.
</p>
<p>Finally, the local parameter posterior distributions are calculated (see
<code><a href="#topic+post">post</a></code>) and attached to each node in the property
<code>condposterior</code>. 
</p>
<p>A so-called trylist is maintained to speedup the learning process. The
trylist consists of a list of
matrices for each node. The matrix for a given node holds previously
evaluated parent configurations and the corresponding log-likelihood
contribution. If a node with a certain parent
configuration needs to be learned, it is checked, whether the node has
already been learned. The previously learned nodes are given as input
in the trylist parameter and is updated in the learning procedure. 
</p>
<p>When one or more nodes in a network have been learned, the network
score is updated and attached to the network in the property
<code>score</code>.  
</p>
<p>The learning procedure is called from various functions using the
principle, that networks should always be updated with their
score. Thus, e.g.\ <code><a href="#topic+drawnetwork">drawnetwork</a></code> keeps the network updated
when the graph is altered.
</p>


<h3>Value</h3>

<p>A list with two elements that may be accessed using
<code><a href="#topic+getnetwork">getnetwork</a></code> and <code><a href="#topic+gettrylist">gettrylist</a></code>. The elements are
</p>
<table>
<tr><td><code>nw</code></td>
<td>
<p>an object of class <code><a href="#topic+network">network</a></code>, with the
<code>condposterior</code> properties updated for 
the nodes. Also, the property <code>score</code> is updated and contains
the network score. The contribution to the network score for each
node is contained in the property <code>loglik</code> for each node.</p>
</td></tr>
<tr><td><code>trylist</code></td>
<td>
<p>an updated list used internally for reusing learning
of nodes, see <code><a href="#topic+maketrylist">maketrylist</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Susanne Gammelgaard Bottcher, <br />
Claus Dethlefsen <a href="mailto:rpackage.deal@gmail.com">rpackage.deal@gmail.com</a>.
</p>


<h3>References</h3>

<p>Bottcher, S.G. (2001). Learning Bayesian Networks with Mixed Variables, Artificial Intelligence and Statistics 2001, Morgan Kaufmann, San Francisco, CA, USA, 149-156.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+networkfamily">networkfamily</a></code>,
<code><a href="#topic+jointprior">jointprior</a></code>,
<code><a href="#topic+maketrylist">maketrylist</a></code>,
<code><a href="#topic+network">network</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rats)
fit       &lt;- network(rats)
fit.prior &lt;- jointprior(fit,12)
fit.learn &lt;- learn(fit,rats,fit.prior,timetrace=TRUE)
fit.nw    &lt;- getnetwork(fit.learn)
fit.learn2&lt;- learn(fit,rats,fit.prior,trylist=gettrylist(fit.learn),timetrace=TRUE)
</code></pre>

<hr>
<h2 id='makesimprob'>Make a suggestion for simulation probabilities</h2><span id='topic+makesimprob'></span>

<h3>Description</h3>

<p>Creates local probability distributions reflecting the
graph of the network. These are attached as a <code>simprob</code> property
to each node in the network and can be edited and used for
<code><a href="#topic+rnetwork">rnetwork</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makesimprob(nw,
                        s2=function(idx,cf) {
                          cf &lt;- as.vector(cf)
                          xs &lt;- (1:length(cf))
                          log(xs%*%cf+1)
                        },
                        m0=function(idx,cf) {
                          cf &lt;- as.vector(cf)
                          xs &lt;- (1:length(cf))^2
                          .69*(xs%*%cf)
                          },
                        m1=function(idx,cf) {
                          cf &lt;- as.vector(cf)
                          xs &lt;- (1:length(cf))*10
                          idx*(cf%*%xs)
                          })
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makesimprob_+3A_nw">nw</code></td>
<td>
<p>an object of class <code><a href="#topic+network">network</a></code>.</p>
</td></tr>
<tr><td><code id="makesimprob_+3A_s2">s2</code></td>
<td>
<p>function that returns the variance as a function of the node
index and the configuration of the discrete variables.</p>
</td></tr>
<tr><td><code id="makesimprob_+3A_m0">m0</code></td>
<td>
<p>function that returns the intercept  as a function of the node
index and the configuration of the discrete variables.</p>
</td></tr>
<tr><td><code id="makesimprob_+3A_m1">m1</code></td>
<td>
<p>function that returns the regression coefficients as a
function of the node 
index and the configuration of the discrete variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each node, the local <code>simprob</code> is determined. If the node is
discrete, the probability distribution is uniform (and thus not
reflecting the dependence in the graph, as it should). If the node is
continuous, one mean and variance is attached per configuration of the
discrete parents. The mean depends on the continuos parents and is the
regression coefficients determined by the functions <code>m0</code>
(intercept) and <code>m1</code> (regression coefficients). The variance is
determined by the function <code>s2</code>.
</p>


<h3>Value</h3>

<p>The network object <code>nw</code>, where each node has attached the
property  <code>simprob</code>.</p>


<h3>Author(s)</h3>

<p>Susanne Gammelgaard Bottcher, <br />
Claus Dethlefsen <a href="mailto:rpackage.deal@gmail.com">rpackage.deal@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rnetwork">rnetwork</a></code></p>

<hr>
<h2 id='maketrylist'>Creates the full trylist</h2><span id='topic+maketrylist'></span>

<h3>Description</h3>

<p>For faster learning, a trylist is maintained as a lookup
table for a given parent configuration of a node.</p>


<h3>Usage</h3>

<pre><code class='language-R'>maketrylist(initnw,data,prior=jointprior(network(data)),timetrace=FALSE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maketrylist_+3A_initnw">initnw</code></td>
<td>
<p>an object of class <code><a href="#topic+network">network</a></code>, from which the
search is started. </p>
</td></tr> 
<tr><td><code id="maketrylist_+3A_data">data</code></td>
<td>
<p>a data frame used for learning the network, see
<code><a href="#topic+network">network</a></code>.</p>
</td></tr> 
<tr><td><code id="maketrylist_+3A_prior">prior</code></td>
<td>
<p>a list containing parameter priors, generated by
<code><a href="#topic+jointprior">jointprior</a></code>.</p>
</td></tr> 
<tr><td><code id="maketrylist_+3A_timetrace">timetrace</code></td>
<td>
<p>a logical. If <code>TRUE</code>, prints some timing
information on the screen.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This procedure is included for illustrative purposes. For each
node in the 
network, all possible parent 
configurations are created and learned. The result is called a
trylist. To create the full trylist is very time-consuming,
and a better choice is to maintain a trylist while searching and
indeed this is automatically done. The trylist is given as output to
all functions that call the learning procedure and can be given as an
argument. 
</p>


<h3>Value</h3>

<p>A list with one element per node in the network. In the list,
element <em>i</em> is a matrix with two columns: a string with the
indices of the parent nodes, separated by &quot;:&quot;, and a numeric with the
log-likelihood contribution of the node given the parent
configuration. Whenever learning is performed of a node given a parent
configuration, the trylist is consulted to yield faster learning,
especially useful when using <code><a href="#topic+autosearch">autosearch</a></code> or
<code><a href="#topic+heuristic">heuristic</a></code>.
</p>


<h3>Author(s)</h3>

<p>Susanne Gammelgaard Bottcher, <br />
Claus Dethlefsen <a href="mailto:rpackage.deal@gmail.com">rpackage.deal@gmail.com</a>.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+networkfamily">networkfamily</a></code>,
<code><a href="#topic+autosearch">autosearch</a></code>
<code><a href="#topic+heuristic">heuristic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rats)
rats.nw &lt;- network(rats)
rats.pr &lt;- jointprior(rats.nw,12)
rats.nw &lt;- getnetwork(learn(rats.nw,rats,rats.pr))
rats.tr &lt;- maketrylist(rats.nw,rats,rats.pr)

rats.hi &lt;- getnetwork(heuristic(rats.nw,rats,rats.pr,trylist=rats.tr))
</code></pre>

<hr>
<h2 id='network'>Bayesian network data structure</h2><span id='topic+network'></span><span id='topic+plot.network'></span><span id='topic+print.network'></span>

<h3>Description</h3>

<p>A Bayesian network is represented as an object of class
<code>network</code>. Methods for printing and plotting are defined. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network(df,specifygraph=FALSE,inspectprob=FALSE,
        doprob=TRUE,yr=c(0,350),xr=yr) 
## S3 method for class 'network'
print(x,filename=NA,condposterior=FALSE,
                          condprior=FALSE,...) 
## S3 method for class 'network'
 plot(x,arrowlength=.25,
                        notext=FALSE,
                        sscale=7,showban=TRUE,yr=c(0,350),xr=yr,
                        unitscale=20,cexscale=8,...)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network_+3A_df">df</code></td>
<td>
<p>a data frame, where the columns define the variables. A
continuous variable should have type <code>numeric</code> and discrete varibles
should have type <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
<tr><td><code id="network_+3A_specifygraph">specifygraph</code></td>
<td>
<p>a logical. If <code>TRUE</code>, provides a call to
<code><a href="#topic+drawnetwork">drawnetwork</a></code> to interactively specify a directed
acyclic graph and possibly a ban list (see below).</p>
</td></tr>
<tr><td><code id="network_+3A_inspectprob">inspectprob</code></td>
<td>
<p>a logical. If <code>TRUE</code>, provides a plot of the
graph and possibility to inspect the calculated probability
distribution by clicking on the nodes.</p>
</td></tr>
<tr><td><code id="network_+3A_doprob">doprob</code></td>
<td>
<p>a logical. If <code>TRUE</code>, do not calculate a
probability distribution. Used 
for example in <code><a href="#topic+rnetwork">rnetwork</a></code>. </p>
</td></tr>
<tr><td><code id="network_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+network">network</a></code>.</p>
</td></tr>
<tr><td><code id="network_+3A_filename">filename</code></td>
<td>
<p>a string or <code>NA</code>. If not <code>NA</code>, output is
printed to a file.</p>
</td></tr> 
<tr><td><code id="network_+3A_condprior">condprior</code></td>
<td>
<p>a logical. If <code>TRUE</code>, the conditional prior is
printed, see <code><a href="#topic+conditional">conditional</a></code>.</p>
</td></tr>
<tr><td><code id="network_+3A_condposterior">condposterior</code></td>
<td>
<p>a logical. If <code>TRUE</code>, the conditional posterior is
printed, see <code><a href="#topic+learn">learn</a></code>.</p>
</td></tr>
<tr><td><code id="network_+3A_sscale">sscale</code></td>
<td>
<p>a numeric. The nodes are initially placed on a circle
with radius <code>sscale</code>.</p>
</td></tr> 
<tr><td><code id="network_+3A_unitscale">unitscale</code></td>
<td>
<p>a numeric. Scale parameter for chopping off arrow heads.</p>
</td></tr>
<tr><td><code id="network_+3A_cexscale">cexscale</code></td>
<td>
<p>a numeric. Scale parameter to set the size of the nodes.</p>
</td></tr>
<tr><td><code id="network_+3A_arrowlength">arrowlength</code></td>
<td>
<p>a numeric containing the length of the arrow heads.</p>
</td></tr>
<tr><td><code id="network_+3A_xr">xr</code></td>
<td>
<p>a numeric vector with two components containing the range on x-axis.</p>
</td></tr>
<tr><td><code id="network_+3A_yr">yr</code></td>
<td>
<p>a numeric vector with two components containing the range on y-axis.</p>
</td></tr>
<tr><td><code id="network_+3A_notext">notext</code></td>
<td>
<p>a logical. If <code>TRUE</code>, no text is displayed in the nodes on the plot.</p>
</td></tr>
<tr><td><code id="network_+3A_showban">showban</code></td>
<td>
<p>a logical. If <code>TRUE</code>, banned arrows are shown in red.</p>
</td></tr>
<tr><td><code id="network_+3A_...">...</code></td>
<td>
<p>additional plot arguments, passed to <code><a href="#topic+plot.node">plot.node</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>netork</code> creator function returns an object of class
<code>network</code>, which is a list with the following 
elements (properties),
</p>
<table>
<tr><td><code>nodes</code></td>
<td>
<p>a list of objects of class <code>node</code>. If
<code>doprob</code> is <code>TRUE</code>, the nodes are given the 
property <code>prob</code> which is the initial probability distribution used
by <code><a href="#topic+jointprior">jointprior</a></code>.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>an integer containing the number of nodes in the network.</p>
</td></tr>
<tr><td><code>discrete</code></td>
<td>
<p>a numeric vector of indices of discrete nodes.</p>
</td></tr>
<tr><td><code>continuous</code></td>
<td>
<p>a numeric vector of indices of continuous nodes.</p>
</td></tr>
<tr><td><code>banlist</code></td>
<td>
<p>a numeric matrix with two columns. Each row contains the
indices <code>i -&gt; j</code> of arrows that may not be allowed in the
directed acyclic graph.</p>
</td></tr>
<tr><td><code>score</code></td>
<td>
<p>a numeric added by <code><a href="#topic+learn">learn</a></code> and is the log network
score.</p>
</td></tr>
<tr><td><code>relscore</code></td>
<td>
<p>a numeric added by <code><a href="#topic+nwfsort">nwfsort</a></code> and is the relative
network score &ndash; compared with the best network in a network family.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Susanne Gammelgaard Bottcher, <br />
Claus Dethlefsen <a href="mailto:rpackage.deal@gmail.com">rpackage.deal@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+networkfamily">networkfamily</a></code>,
<code><a href="#topic+node">node</a></code>,
<code><a href="#topic+rnetwork">rnetwork</a></code>,
<code><a href="#topic+learn">learn</a></code>,
<code><a href="#topic+drawnetwork">drawnetwork</a></code>,
<code><a href="#topic+jointprior">jointprior</a></code>,
<code><a href="#topic+heuristic">heuristic</a></code>,
<code><a href="#topic+nwequal">nwequal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- factor(rep(c("A1","A2"),50))
B &lt;- factor(rep(rep(c("B1","B2"),25),2))
thisnet &lt;- network( data.frame(A,B) )

set.seed(109)
sex     &lt;- gl(2,4,label=c("male","female"))
age     &lt;- gl(2,2,8)
yield   &lt;- rnorm(length(sex))
weight  &lt;- rnorm(length(sex))
mydata  &lt;- data.frame(sex,age,yield,weight)
mynw    &lt;- network(mydata)

# adjust prior probability distribution
localprob(mynw,"sex")   &lt;- c(0.4,0.6)
localprob(mynw,"age")   &lt;- c(0.6,0.4)
localprob(mynw,"yield") &lt;- c(2,0)
localprob(mynw,"weight")&lt;- c(1,0)

print(mynw)
plot(mynw)

prior &lt;- jointprior(mynw)
mynw  &lt;- getnetwork(learn(mynw,mydata,prior))
thebest &lt;- getnetwork(autosearch(mynw,mydata,prior))

print(mynw,condposterior=TRUE)

## Not run: savenet(mynw,file("yield.net"))
</code></pre>

<hr>
<h2 id='Network+20tools'>Tools for manipulating networks</h2><span id='topic+modelstring'></span><span id='topic+makenw'></span><span id='topic+size'></span><span id='topic+as.network'></span><span id='topic+banlist'></span><span id='topic+getnetwork'></span><span id='topic+gettrylist'></span><span id='topic+banlist+3C-'></span>

<h3>Description</h3>

<p>Various extraction/replacement functions for networks</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelstring(x)
makenw(tb,template)
as.network(nwstring,template)
size(x)
banlist(x)
banlist(x) &lt;- value
getnetwork(x)
gettrylist(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Network+2B20tools_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+network">network</a></code>.</p>
</td></tr> 
<tr><td><code id="Network+2B20tools_+3A_tb">tb</code></td>
<td>
<p>a table output from <code><a href="#topic+autosearch">autosearch</a></code> or
<code><a href="#topic+heuristic">heuristic</a></code> in the list property <code>table</code>. Can be
translated into a <code><a href="#topic+networkfamily">networkfamily</a></code>.</p>
</td></tr>
<tr><td><code id="Network+2B20tools_+3A_template">template</code></td>
<td>
<p>an object of class <code><a href="#topic+network">network</a></code> with the same
nodes as the networks described in the table <code>tb</code>.</p>
</td></tr>
<tr><td><code id="Network+2B20tools_+3A_nwstring">nwstring</code></td>
<td>
<p>a string representing the network.</p>
</td></tr>
<tr><td><code id="Network+2B20tools_+3A_value">value</code></td>
<td>
<p>a numeric matrix with two columns. Each row contains the
indices <code>i -&gt; j</code> of arrows that may not be allowed in the
directed acyclic graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The string representation of a network is a minimal size
representation to speed up calculations. The functions
<code>modelstring</code>, <code>as.network</code> and <code>makenw</code> converts
between the string represention and network objects.
</p>
<p><code>size</code> extracts the number of nodes in a network object.
</p>
<p><code>banlist</code> extracts the banlist from a network object.
</p>
<p><code>getnetwork</code> and <code>gettrylist</code> are accessor function that
extracts a network object or trylist from the result from
<code><a href="#topic+autosearch">autosearch</a></code>, <code><a href="#topic+heuristic">heuristic</a></code>,
<code><a href="#topic+learn">learn</a></code>, <code><a href="#topic+perturb">perturb</a></code>, 
<code><a href="#topic+networkfamily">networkfamily</a></code>, <code><a href="#topic+drawnetwork">drawnetwork</a></code>.
</p>

<hr>
<h2 id='networkfamily'>Generates and learns all networks for a set of variables.</h2><span id='topic+networkfamily'></span><span id='topic+print.networkfamily'></span><span id='topic+plot.networkfamily'></span>

<h3>Description</h3>

<p>Method for generating and learning all networks that are
possible for a given set of variables. These may be
plotted or printed. Also, functions for
sorting according to the network score (see <code><a href="#topic+nwfsort">nwfsort</a></code>) and for 
making a network family unique (see the <code>unique</code> method for
<code>networkfamily</code> objects) are available.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>networkfamily(data,nw=network(data), prior=jointprior(nw),
              trylist=vector("list",size(nw)), timetrace=TRUE) 

## S3 method for class 'networkfamily'
print(x,...)
## S3 method for class 'networkfamily'
plot(x,layout=,
        cexscale=5,arrowlength=0.1,sscale=7,...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="networkfamily_+3A_nw">nw</code></td>
<td>
<p>an object of class <code><a href="#topic+network">network</a></code>. This should be the
empty network for the set of variables.</p>
</td></tr>
<tr><td><code id="networkfamily_+3A_data">data</code></td>
<td>
<p>a data frame used for learning the network, see
<code><a href="#topic+network">network</a></code>.</p>
</td></tr> 
<tr><td><code id="networkfamily_+3A_prior">prior</code></td>
<td>
<p>a list containing parameter priors, generated by
<code><a href="#topic+jointprior">jointprior</a></code>.</p>
</td></tr> 
<tr><td><code id="networkfamily_+3A_trylist">trylist</code></td>
<td>
<p>a list used internally for reusing learning of nodes,
see <code><a href="#topic+maketrylist">maketrylist</a></code>.</p>
</td></tr> 
<tr><td><code id="networkfamily_+3A_timetrace">timetrace</code></td>
<td>
<p>a logical. If <code>TRUE</code>, prints some timing
information on the screen.</p>
</td></tr> 
<tr><td><code id="networkfamily_+3A_x">x</code></td>
<td>
<p>an object of class <code>networkfamily</code>.</p>
</td></tr>
<tr><td><code id="networkfamily_+3A_layout">layout</code></td>
<td>
<p>a numeric two dimensional vector with the number of plots in the rows
and columns of each plotting page. Default set to <code>rep(min(1+floor(sqrt(length(x))),5),2)</code>.</p>
</td></tr>
<tr><td><code id="networkfamily_+3A_cexscale">cexscale</code></td>
<td>
<p>a numeric. A scaling parameter to set the size of the nodes.</p>
</td></tr>
<tr><td><code id="networkfamily_+3A_arrowlength">arrowlength</code></td>
<td>
<p>a numeric, which gives the length of the arrow heads.</p>
</td></tr>
<tr><td><code id="networkfamily_+3A_sscale">sscale</code></td>
<td>
<p>a numeric. The nodes are initially placed on a circle
with radius <code>sscale</code>.</p>
</td></tr> 
<tr><td><code id="networkfamily_+3A_...">...</code></td>
<td>
<p>additional plot arguments passed to the plot method for network
objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>networkfamily</code> generates and learns all possible networks with
the nodes given as in the initial network <code>nw</code>. This is done by
successively trying to generate the networks with all possible arrows
to/from each node (see <code><a href="#topic+addarrows">addarrows</a></code>). If there is a ban list
present in <code>nw</code> (see <code><a href="#topic+network">network</a></code>), then this is
respected, as are the restrictions described in <code><a href="#topic+insert">insert</a></code>.
</p>
<p>After generation of all possible networks, a test for cycles (see
<code><a href="#topic+cycletest">cycletest</a></code>) is performed and only networks with directed
acyclic graphs are returned.
</p>


<h3>Value</h3>

<p>The function <code>networkfamily</code> returns a list with two components,
</p>
<table>
<tr><td><code>nw</code></td>
<td>
<p>an object of class <code>networkfamily</code>.</p>
</td></tr>
<tr><td><code>trylist</code></td>
<td>
<p>an updated list used internally for reusing learning
of nodes, see <code><a href="#topic+maketrylist">maketrylist</a></code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Generating all possible networks can be <em>very</em> time consuming!
</p>


<h3>Author(s)</h3>

<p>Susanne Gammelgaard Bottcher, <br />
Claus Dethlefsen <a href="mailto:rpackage.deal@gmail.com">rpackage.deal@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+network">network</a></code>,
<code><a href="#topic+genlatex">genlatex</a></code>,
<code><a href="#topic+heuristic">heuristic</a></code>,
<code><a href="#topic+nwfsort">nwfsort</a></code>,
<code><a href="#topic+unique.networkfamily">unique.networkfamily</a></code>,
<code><a href="#topic+elementin">elementin</a></code>,
<code><a href="#topic+addarrows">addarrows</a></code>,
<code><a href="#topic+cycletest">cycletest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rats)
allrats &lt;- getnetwork(networkfamily(rats))
plot(allrats)
print(allrats)
</code></pre>

<hr>
<h2 id='node'>Representation of nodes</h2><span id='topic+node'></span><span id='topic+plot.node'></span><span id='topic+print.node'></span><span id='topic+nodes'></span><span id='topic+nodes+3C-'></span>

<h3>Description</h3>

<p>An important part of a <code><a href="#topic+network">network</a></code> is the list of
nodes. The nodes summarize the local properties of a node, given the
parents of the node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node (idx,parents,type="discrete",name=paste(idx),
                 levels=2,levelnames=paste(1:levels),position=c(0,0)) 
## S3 method for class 'node'
 print(x,filename=NA,condposterior=TRUE,condprior=TRUE,...) 
## S3 method for class 'node'
 plot(x,cexscale=10,notext=FALSE,...)
nodes(nw)
nodes(nw) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_+3A_x">x</code></td>
<td>
<p>an object of class <code>node</code>.</p>
</td></tr>
<tr><td><code id="node_+3A_parents">parents</code></td>
<td>
<p>a numeric vector with indices of the parents of the node.</p>
</td></tr>
<tr><td><code id="node_+3A_idx">idx</code></td>
<td>
<p>an integer, which gives the index of the node (the column number of the
corresponding data frame).</p>
</td></tr>
<tr><td><code id="node_+3A_type">type</code></td>
<td>
<p>a string, which gives the type of the node. Either
<code>"discrete"</code> (for factors) or <code>"continuous"</code> (for numeric).</p>
</td></tr>
<tr><td><code id="node_+3A_name">name</code></td>
<td>
<p>a string, which gives the name used when plotting and
printing. Defaults to the column 
name in the data frame.</p>
</td></tr>
<tr><td><code id="node_+3A_levels">levels</code></td>
<td>
<p>an integer. If <code>type</code> is <code>"discrete"</code>, this is
the number of levels for the discrete variable.</p>
</td></tr>
<tr><td><code id="node_+3A_levelnames">levelnames</code></td>
<td>
<p>if <code>type</code> is <code>"discrete"</code>, this is a vector of
strings (same length as <code>levels</code>) with the names of the
levels. If <code>type</code> is <code>"continuous"</code>, the argument is ignored.</p>
</td></tr>
<tr><td><code id="node_+3A_position">position</code></td>
<td>
<p>a numeric vector with coordinates where the node should
appear in the 
plot. Usually set by <code><a href="#topic+network">network</a></code> and <code><a href="#topic+drawnetwork">drawnetwork</a></code>.</p>
</td></tr>
<tr><td><code id="node_+3A_nw">nw</code></td>
<td>
<p>an object of class <code><a href="#topic+network">network</a></code>.</p>
</td></tr>
<tr><td><code id="node_+3A_value">value</code></td>
<td>
<p>a list of elements of class <code><a href="#topic+node">node</a></code>.</p>
</td></tr>
<tr><td><code id="node_+3A_filename">filename</code></td>
<td>
<p>a string or <code>NA</code>. If not <code>NA</code>, output is
printed to a file.</p>
</td></tr> 
<tr><td><code id="node_+3A_condprior">condprior</code></td>
<td>
<p>a logical. If <code>TRUE</code>, the conditional prior is
printed, see <code><a href="#topic+conditional">conditional</a></code>.</p>
</td></tr>
<tr><td><code id="node_+3A_condposterior">condposterior</code></td>
<td>
<p>a logical. If <code>TRUE</code>, the conditional posterior is
printed, see <code><a href="#topic+learn">learn</a></code>.</p>
</td></tr>
<tr><td><code id="node_+3A_cexscale">cexscale</code></td>
<td>
<p>a numeric. Scale parameter to set the size of the nodes.</p>
</td></tr>
<tr><td><code id="node_+3A_notext">notext</code></td>
<td>
<p>a logical. If <code>TRUE</code>, no text is displayed in the nodes on the plot.</p>
</td></tr>
<tr><td><code id="node_+3A_...">...</code></td>
<td>
<p>additional plot arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The operations on a node are typically done when operating on a
<code><a href="#topic+network">network</a></code>, so these functions are not to be called
directly. 
</p>
<p>When a network is created with <code>network</code>, the nodes in the
nodelist are created using the <code>node</code> procedure.
</p>
<p>Local
probability distributions are added as the property <code>prob</code> to
each node using <code>prob.node</code>. If the node is continuous, this is a
numeric vector with 
the conditional variance and the conditional regression coefficients
arising from a regression on the continuous parents, using data. If
the node has discrete parents, <code>prob</code> is a matrix with a row
for each configuration of the discrete parents. If the node is
discrete, <code>prob</code> is a multiway array which gives the conditional
probability distribution for each configuration of the discrete
parents. The generated <code>prob</code> can be replaced to match the prior
information available.
</p>
<p><code>nodes</code> gives the list of nodes of a network. <code>localprob</code>
gives the probability distribution for each node in the network.
</p>


<h3>Value</h3>

<p>The <code>node</code> creator function returns an object of class
<code>node</code>, which is a list with the following 
elements (properties),
</p>
<table>
<tr><td><code>idx</code></td>
<td>
<p>an integer. A unique index for this node. It MUST
correspond to the column index of the variable in the data frame.</p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p>a string. The printed name of the node.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>a string. Either <code>"continuous"</code> or <code>"discrete"</code>.</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p>an integer. If the node is of type <code>"discrete"</code>, this
integer is the 
number of levels of the node.</p>
</td></tr>
<tr><td><code>levelnames</code></td>
<td>
<p>if <code>type</code> is <code>"discrete"</code>, this is a vector of
strings (same length as <code>levels</code>) with the names of the
levels. If <code>type</code> is <code>"continuous"</code>, the node does not have this property.</p>
</td></tr>
<tr><td><code>parents</code></td>
<td>
<p>a vector of indices of the parents to this node. It is
best to manage this vector using the <code><a href="#topic+insert">insert</a></code> function.</p>
</td></tr>
<tr><td><code>prob</code></td>
<td>
<p>a numeric vector, matrix or multiway array, giving the
initial probability distribution. If the node is discrete,
<code>prob</code> is a multiway array. If the node is continuous,
<code>prob</code> is a matrix with one row for each configuration of the
discrete parents, reducing to a vector if the node has no discrete parents.</p>
</td></tr>
<tr><td><code>condprior</code></td>
<td>
<p>a list, generated by <code><a href="#topic+conditional">conditional</a></code> giving
the parameter priors deduced from
<code><a href="#topic+jointprior">jointprior</a></code> using the master prior procedure (see
<code><a href="#topic+localmaster">localmaster</a></code>). </p>
</td></tr>
<tr><td><code>condposterior</code></td>
<td>
<p>a list, which gives the parameter posteriors obtained from
<code><a href="#topic+learnnode">learnnode</a></code>.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>a numeric giving the log likelihood contribution for this node,
calculated in <code><a href="#topic+learnnode">learnnode</a></code>.</p>
</td></tr>
<tr><td><code>simprob</code></td>
<td>
<p>a numeric vector, matrix or multiway array similar to <code>prob</code>, added by
<code><a href="#topic+makesimprob">makesimprob</a></code> and used by <code><a href="#topic+rnetwork">rnetwork</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Susanne Gammelgaard Bottcher, <br />
Claus Dethlefsen <a href="mailto:rpackage.deal@gmail.com">rpackage.deal@gmail.com</a>.
</p>

<hr>
<h2 id='numbermixed'>The number of possible networks</h2><span id='topic+numbermixed'></span>

<h3>Description</h3>

<p>Calculates the number of different directed acyclic graphs
for a set of discrete and continuous nodes. </p>


<h3>Usage</h3>

<pre><code class='language-R'>numbermixed(nd,nc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numbermixed_+3A_nd">nd</code></td>
<td>
<p>an integer, which gives the number of discrete nodes.</p>
</td></tr>
<tr><td><code id="numbermixed_+3A_nc">nc</code></td>
<td>
<p>an integer, which gives the number of continuous nodes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No arrows are allowed from continuous nodes to discrete nodes. Cycles
are not allowed. The
number of networks is given by Bottcher (2003), using the result in
Robinson (1977).
</p>
<p>When nd+nc&gt;15, the procedure is quite slow.
</p>


<h3>Value</h3>

<p>A numeric containing the number of directed acyclic graphs with the given node
configuration. 
</p>


<h3>Author(s)</h3>

<p>Susanne Gammelgaard Bottcher, <br />
Claus Dethlefsen <a href="mailto:rpackage.deal@gmail.com">rpackage.deal@gmail.com</a>.
</p>


<h3>References</h3>

<p>Bottcher, S.G. (2003). Learning Conditional Gaussian
Networks. Aalborg University, 2003.
</p>
<p>Robinson, R.W. (1977). Counting unlabeled acyclic digraphs, Lecture
Notes in Mathematics, 622: Combinatorial Mathematics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>numbermixed(2,2)
## Not run: numbermixed(5,10)
</code></pre>

<hr>
<h2 id='nwfsort'>Sorts a list of networks</h2><span id='topic+nwfsort'></span>

<h3>Description</h3>

<p>According to the <code>score</code> property of the networks in
a network family, the networks are sorted and the relative score,
i.e.\ the score of a network relative to the
highest score, is attached to each network as the <code>relscore</code>
property. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nwfsort(nwf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nwfsort_+3A_nwf">nwf</code></td>
<td>
<p>an object of class <code>networkfamily</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Susanne Gammelgaard Bottcher, <br />
Claus Dethlefsen <a href="mailto:rpackage.deal@gmail.com">rpackage.deal@gmail.com</a>.
</p>

<hr>
<h2 id='perturb'>Perturbs a network</h2><span id='topic+perturb'></span>

<h3>Description</h3>

<p>Randomly insert/delete/turn arrows to obtain another network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perturb(nw,data,prior,degree=size(nw),trylist=vector("list",size(nw)),
        nocalc=FALSE,timetrace=TRUE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perturb_+3A_nw">nw</code></td>
<td>
<p>an object of class <code>network</code>, from which arrows are added/removed/turned.</p>
</td></tr>
<tr><td><code id="perturb_+3A_data">data</code></td>
<td>
<p>a data frame used for learning the network, see
<code><a href="#topic+network">network</a></code>.</p>
</td></tr> 
<tr><td><code id="perturb_+3A_prior">prior</code></td>
<td>
<p>a list containing parameter priors, generated by
<code><a href="#topic+jointprior">jointprior</a></code>.</p>
</td></tr> 
<tr><td><code id="perturb_+3A_degree">degree</code></td>
<td>
<p>an integer, which gives the number of attempts to randomly
insert/remove/turn an arrow.</p>
</td></tr>
<tr><td><code id="perturb_+3A_trylist">trylist</code></td>
<td>
<p>a list used internally for reusing learning of nodes,
see <code><a href="#topic+maketrylist">maketrylist</a></code>.</p>
</td></tr> 
<tr><td><code id="perturb_+3A_nocalc">nocalc</code></td>
<td>
<p>a logical. If <code>TRUE</code> no learning procedure is called, see eg. <code><a href="#topic+rnetwork">rnetwork</a></code>.</p>
</td></tr>
<tr><td><code id="perturb_+3A_timetrace">timetrace</code></td>
<td>
<p>a logical. If <code>TRUE</code>, prints some timing
information on the screen.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Given the initial network, a new network is constructed by randomly
choosing an action: remove, turn, add. After the action is chosen, we
choose randomly among all possibilities of that action. If there are
no possibilites, the unchanged network is returned.</p>


<h3>Value</h3>

<p>A list with two elements that may be accessed using
<code><a href="#topic+getnetwork">getnetwork</a></code> and <code><a href="#topic+gettrylist">gettrylist</a></code>. The elements are
</p>
<table>
<tr><td><code>nw</code></td>
<td>
<p>an object of class <code><a href="#topic+network">network</a></code> with the generated network.</p>
</td></tr>
<tr><td><code>trylist</code></td>
<td>
<p>an updated list used internally for reusing learning
of nodes, see <code><a href="#topic+maketrylist">maketrylist</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Susanne Gammelgaard Bottcher, <br />
Claus Dethlefsen <a href="mailto:rpackage.deal@gmail.com">rpackage.deal@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(200)
data(rats)
fit       &lt;- network(rats)
fit.prior &lt;- jointprior(fit)
fit       &lt;- getnetwork(learn(fit,rats,fit.prior))
fit.new   &lt;- getnetwork(perturb(fit,rats,fit.prior,degree=10))

data(ksl)
ksl.nw    &lt;- network(ksl)
ksl.rand  &lt;- getnetwork(perturb(ksl.nw,nocalc=TRUE,degree=10))
plot(ksl.rand)
</code></pre>

<hr>
<h2 id='prob'>Local probability distributions</h2><span id='topic+prob'></span><span id='topic+prob.network'></span><span id='topic+prob.node'></span><span id='topic+localprob'></span><span id='topic+localprob+3C-'></span><span id='topic+localprior'></span><span id='topic+localposterior'></span>

<h3>Description</h3>

<p>Methods for accessing or changing the local probability
distributions and for accessing the local prior and posterior distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob(x,df,...)

## S3 method for class 'node'
 prob(x,df,nw,...)
## S3 method for class 'network'
 prob(x,df,...)

localprob(nw)
localprob(nw,name) &lt;- value

localprior(node)
localposterior(node)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prob_+3A_x">x</code></td>
<td>
<p>an object of class <code>node</code> or <code>network</code>.</p>
</td></tr>
<tr><td><code id="prob_+3A_df">df</code></td>
<td>
<p>a data frame, where the columns define the variables. A
continuous variable should have type <code>numeric</code> and discrete varibles
should have type <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
<tr><td><code id="prob_+3A_nw">nw</code></td>
<td>
<p>an object of class <code><a href="#topic+network">network</a></code>.</p>
</td></tr>
<tr><td><code id="prob_+3A_node">node</code></td>
<td>
<p>an object of class <code><a href="#topic+node">node</a></code>.</p>
</td></tr>
<tr><td><code id="prob_+3A_name">name</code></td>
<td>
<p>a string, which gives the node name.</p>
</td></tr>
<tr><td><code id="prob_+3A_...">...</code></td>
<td>
<p>additional arguments for specific methods.</p>
</td></tr>
<tr><td><code id="prob_+3A_value">value</code></td>
<td>
<p>If the node is continuous, this is a
numeric vector with the conditional variance and the conditional
regression coefficients arising from a regression on the continuous
parents, using data. If the node has discrete parents, it is a matrix
with a row for each configuration of the discrete parents. If the node is
discrete, it is a multiway array which gives the conditional
probability distribution for each configuration of the discrete
parents.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>prob</code> methods add local
probability distributions to
each node. If the node is continuous, this is a
numeric vector with 
the conditional variance and the conditional regression coefficients
arising from a regression on the continuous parents, using data. If
the node has discrete parents, <code>prob</code> is a matrix with a row
for each configuration of the discrete parents. If the node is
discrete, <code>prob</code> is a multiway array which gives the conditional
probability distribution for each configuration of the discrete
parents. The generated <code>prob</code> can be replaced to match the prior
information available.
</p>
<p><code>localprob</code> returns the probability distribution
for each node in the network.
</p>
<p>In a learned network, the local prior and posterior can be accessed
for each node using <code>localprior</code> and <code>localposterior</code>.
</p>


<h3>Author(s)</h3>

<p>Susanne Gammelgaard Bottcher, <br />
Claus Dethlefsen <a href="mailto:rpackage.deal@gmail.com">rpackage.deal@gmail.com</a>.
</p>

<hr>
<h2 id='rats'>Weightloss of rats</h2><span id='topic+rats'></span>

<h3>Description</h3>

<p>An artificial data set. 24 rats (12 female, 12 male) have been
randomized to use one of three drugs (products for loosing
weight). The weightloss for each rat is noted after one and two
weeks. 
</p>


<h3>Format</h3>

<p>A data frame with 4 variables.
</p>

<dl>
<dt>Sex</dt><dd><p>a factor with two levels: &quot;M&quot; (male), &quot;F&quot; (female)</p>
</dd>
<dt>Drug</dt><dd><p>a factor with three levels: &quot;D1&quot;, &quot;D2&quot;, &quot;D3&quot; (three types)</p>
</dd>
<dt>W1</dt><dd><p>a numeric: weightloss, week one.</p>
</dd>
<dt>W2</dt><dd><p>a numeric: weightloss, week 2.</p>
</dd>
</dl>



<h3>References</h3>

<p>Morrison, D.F. (1976). Multivariate Statistical Methods. McGraw-Hill, USA.
</p>
<p>Edwards, D. (1995). Introduction to Graphical Modelling,
Springer-Verlag. New York.
</p>

<hr>
<h2 id='readnet'>Reads/saves .net file</h2><span id='topic+readnet'></span><span id='topic+savenet'></span>

<h3>Description</h3>

<p>Reads/saves a Bayesian network specification in the <code>.net</code> language used by Hugin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readnet(con=file("default.net"))
savenet(nw, con=file("default.net"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readnet_+3A_con">con</code></td>
<td>
<p>a connection.</p>
</td></tr>
<tr><td><code id="readnet_+3A_nw">nw</code></td>
<td>
<p>an object of class <code><a href="#topic+network">network</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>readnet</code> reads only the structure of a network, i.e.\ the
directed acyclic graph.
</p>
<p><code>savenet</code> exports the <code>prob</code> property for each node in the
network object along with the network structure defined by the parents
of each node. 
</p>


<h3>Value</h3>

<p><code>readnet</code> creates an object of class <code><a href="#topic+network">network</a></code> with
the nodes specified as 
in the <code>.net</code> connection. The network 
has not been learned and the nodes do not have <code>prob</code> properties
(see <code><a href="#topic+prob.network">prob.network</a></code>).
</p>
<p><code>savenet</code> writes the object to the connection.
</p>


<h3>Note</h3>

<p>The call to <code>readnet(savenet(network))</code> is <em>not</em> the identity
function as information is thrown away in both <code>savenet</code> and
<code>readnet</code>.</p>


<h3>Author(s)</h3>

<p>Susanne Gammelgaard Bottcher, <br />
Claus Dethlefsen <a href="mailto:rpackage.deal@gmail.com">rpackage.deal@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+network">network</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rats)
nw &lt;- network(rats)
## Not run: savenet(nw,file("default.net"))
## Not run: nw2 &lt;- readnet(file("default.net"))
## Not run: nw2 &lt;- prob(nw2,rats)

</code></pre>

<hr>
<h2 id='rnetwork'>Simulation of data sets with a given dependency structure</h2><span id='topic+rnetwork'></span>

<h3>Description</h3>

<p>Given a network with nodes having the <code>simprob</code> property,
<code>rnetwork</code> simulates
a data set.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>rnetwork(nw, n=24, file="") 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnetwork_+3A_nw">nw</code></td>
<td>
<p>an object of class <code><a href="#topic+network">network</a></code>, where each node
has the property <code>simprob</code> (see <code><a href="#topic+makesimprob">makesimprob</a></code>).</p>
</td></tr>
<tr><td><code id="rnetwork_+3A_n">n</code></td>
<td>
<p>an integer, which gives the number of cases to simulate.</p>
</td></tr>
<tr><td><code id="rnetwork_+3A_file">file</code></td>
<td>
<p>a string. If non-empty, the data set is stored there.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variables are simulated one at a time in an order that ensures
that the parents of the node have already been simulated. For discrete
variables a multinomial distribution is used and for continuous
variables, a Gaussian distribution is used, according to the
<code>simprob</code> property in each node.
</p>


<h3>Value</h3>

<p>A data frame with one row per case. If a file name is given, a file is
created with the data set.
</p>


<h3>Author(s)</h3>

<p>Susanne Gammelgaard Bottcher, <br />
Claus Dethlefsen <a href="mailto:rpackage.deal@gmail.com">rpackage.deal@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A  &lt;- factor(NA,levels=paste("A",1:2,sep=""))
B  &lt;- factor(NA,levels=paste("B",1:3,sep=""))
c1 &lt;- NA
c2 &lt;- NA
df &lt;- data.frame(A,B,c1,c2)

nw &lt;- network(df,doprob=FALSE) # doprob must be FALSE
nw &lt;- makesimprob(nw)          # create simprob properties

set.seed(944) 
sim &lt;- rnetwork(nw,n=100)    # create simulated data frame
</code></pre>

<hr>
<h2 id='score'>Network score</h2><span id='topic+score'></span><span id='topic+score.network'></span><span id='topic+score.node'></span>

<h3>Description</h3>

<p>Accessor for the score from a node or network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score(x,...)

## S3 method for class 'node'
    score(x,...)
## S3 method for class 'network'
 score(x,...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score_+3A_x">x</code></td>
<td>
<p>an object of class <code>node</code> or <code>network</code>.</p>
</td></tr>
<tr><td><code id="score_+3A_...">...</code></td>
<td>
<p>additional arguments for specific methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For networks, the log network score is returned. For nodes, the
contribution to the log network score is returned.
</p>


<h3>Author(s)</h3>

<p>Susanne Gammelgaard Bottcher, <br />
Claus Dethlefsen <a href="mailto:rpackage.deal@gmail.com">rpackage.deal@gmail.com</a>.
</p>

<hr>
<h2 id='unique.networkfamily'>Makes a network family unique.</h2><span id='topic+unique.networkfamily'></span>

<h3>Description</h3>

<p>Removes networks that are equal or equivalent to networks already in the network family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'networkfamily'
unique(x,incomparables=FALSE,equi=FALSE,timetrace=FALSE,epsilon=1e-12,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unique.networkfamily_+3A_x">x</code></td>
<td>
<p>an object of class <code>networkfamily</code>.</p>
</td></tr>
<tr><td><code id="unique.networkfamily_+3A_incomparables">incomparables</code></td>
<td>
<p>a logical, but has no effect.</p>
</td></tr>
<tr><td><code id="unique.networkfamily_+3A_equi">equi</code></td>
<td>
<p>a logical. If <code>TRUE</code>, also equivalent networks are
thrown out 
(<em>i.e.</em> if
their score is within <code>epsilon</code> from another network).</p>
</td></tr>
<tr><td><code id="unique.networkfamily_+3A_timetrace">timetrace</code></td>
<td>
<p>a logical. If <code>TRUE</code>, prints some timing
information on the screen.</p>
</td></tr> 
<tr><td><code id="unique.networkfamily_+3A_epsilon">epsilon</code></td>
<td>
<p>a numeric, which measures how close network scores are
allowed to be from each other to be 'equivalent'.</p>
</td></tr>
<tr><td><code id="unique.networkfamily_+3A_...">...</code></td>
<td>
<p>further arguments (no effect)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Susanne Gammelgaard Bottcher, <br />
Claus Dethlefsen <a href="mailto:rpackage.deal@gmail.com">rpackage.deal@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rats)
rats.nwf &lt;- networkfamily(rats)
rats.nwf2&lt;- unique(getnetwork(rats.nwf),equi=TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
