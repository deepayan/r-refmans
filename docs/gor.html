<!DOCTYPE html><html><head><title>Help for package gor</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gor}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#apply_incidence_map'><p>Apply incidence map of a graph to an edge vector</p></a></li>
<li><a href='#bfs_tree'><p>Breadth-first search tree</p></a></li>
<li><a href='#build_cover_approx'><p>2-approximation algorithm for vertex cover</p></a></li>
<li><a href='#build_cover_greedy'><p>Greedy algorithm for vertex cover in a graph</p></a></li>
<li><a href='#build_cover_random'><p>Random vertex covers</p></a></li>
<li><a href='#build_cut_greedy'><p>Greedy algorithm aimed to build a large weight cut in a</p>
graph</a></li>
<li><a href='#build_cut_random'><p>Random cut generation on a graph</p></a></li>
<li><a href='#build_tour_2tree'><p>Double-tree heuristic for TSP</p></a></li>
<li><a href='#build_tour_greedy'><p>Building a tour for a TSP using the greedy heuristic</p></a></li>
<li><a href='#build_tour_nn'><p>Building a tour for a TSP using the nearest neighbor</p>
heuristic</a></li>
<li><a href='#build_tour_nn_best'><p>Build a tour for a TSP using the best nearest neighbor</p>
heuristic</a></li>
<li><a href='#color_graph_greedy'><p>Greedy coloring of a graph</p></a></li>
<li><a href='#compute_cut_weight'><p>Compute cut weight and size</p></a></li>
<li><a href='#compute_distance_matrix'><p><code class="reqn">p</code>-distance matrix computation</p></a></li>
<li><a href='#compute_gain_transp'><p>Distance gain when transposing two cities in a tour</p></a></li>
<li><a href='#compute_lower_bound_1tree'><p>Computing the 1-tree lower bound for a TSP instance</p></a></li>
<li><a href='#compute_lower_bound_HK'><p>Held-Karp lower bound estimate</p></a></li>
<li><a href='#compute_p_distance'><p>Distance-p between two-dimensional points</p></a></li>
<li><a href='#compute_path_distance'><p>Compute the distance of a TSP path</p></a></li>
<li><a href='#compute_tour_distance'><p>Compute the distance of a TSP tour</p></a></li>
<li><a href='#crossover_sequences'><p>Crossover of sequences</p></a></li>
<li><a href='#crossover_tours'><p>Crossover operation used by the TSP genetic algorithm</p></a></li>
<li><a href='#dfs_tree'><p>Depth-first search tree</p></a></li>
<li><a href='#dijk'><p>Dijkstra' algorithm for shortest paths</p></a></li>
<li><a href='#find_cover_BB'><p>Branch-and-Bound algorithm for the Vertex-Cover problem</p></a></li>
<li><a href='#find_euler'><p>Constructing an Eulerian Cycle</p></a></li>
<li><a href='#find_tour_BB'><p>Branch-and-Bound algorithm for the TSP</p></a></li>
<li><a href='#gauge_tour'><p>Gauging a tour</p></a></li>
<li><a href='#generate_fundamental_cycles'><p>Generate fundamental cycles in a connected graph</p></a></li>
<li><a href='#gor'><p>Graphs and Network Optimization algorithms</p></a></li>
<li><a href='#improve_cover_flip'><p>Improving a cover with local search</p></a></li>
<li><a href='#improve_cut_flip'><p>Improving a cut with local search</p></a></li>
<li><a href='#improve_tour_2opt'><p>Tour improving for a TSP using the 2-opt heuristic</p></a></li>
<li><a href='#improve_tour_3opt'><p>Tour improving for a TSP using the 3-opt heuristic</p></a></li>
<li><a href='#improve_tour_LinKer'><p>Tour improving for a TSP using a poor version of the Lin-Kernighan heuristic</p></a></li>
<li><a href='#is_cover'><p>Check vertex cover</p></a></li>
<li><a href='#mutate_binary_sequence'><p>Binary sequence mutation</p></a></li>
<li><a href='#neigh_index'><p>Previous, current, and next positions of a given index in a</p>
cycle.</a></li>
<li><a href='#next_index'><p>Next position to i in a cycle</p></a></li>
<li><a href='#perturb_tour_4exc'><p>Random 4-exchange transformation</p></a></li>
<li><a href='#plot_cover'><p>Vertex cover plotting</p></a></li>
<li><a href='#plot_cut'><p>Cut plotting</p></a></li>
<li><a href='#plot_tour'><p>TSP tour simple plotting</p></a></li>
<li><a href='#search_cover_ants'><p>Ant colony optimization algorithm for Vertex-Cover</p></a></li>
<li><a href='#search_cover_random'><p>Random vertex covers</p></a></li>
<li><a href='#search_cut_genetic'><p>Genetic Algorithm for Max-Cut</p></a></li>
<li><a href='#search_tour_ants'><p>Ant colony optimization algorithm for the TSP</p></a></li>
<li><a href='#search_tour_chain2opt'><p>Chained 2-opt search with multiple, random starting tours</p></a></li>
<li><a href='#search_tour_genetic'><p>Genetic Algorithm for the TSP</p></a></li>
<li><a href='#shave_cycle'><p>Shaving a hairy cycle</p></a></li>
<li><a href='#sum_g'><p>Sum of the higher terms of a list</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Algorithms for the Subject Graphs and Network Optimization</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Informal implementation of some algorithms from Graph
  Theory and Combinatorial Optimization which arise in the subject
  "Graphs and Network Optimization" from first course of the EUPLA
  (Escuela Universitaria Politecnica de La Almunia) degree of Data
  Engineering in Industrial Processes.
  References used are:
  Cook et al (1998, ISBN:0-471-55894-X),
  Korte, Vygen (2018) &lt;<a href="https://doi.org/10.1007%2F978-3-662-56039-6">doi:10.1007/978-3-662-56039-6</a>&gt;,
  Hromkovic (2004) &lt;<a href="https://doi.org/10.1007%2F978-3-662-05269-3">doi:10.1007/978-3-662-05269-3</a>&gt;,
  Hartmann, Weigt (2005, ISBN:978-3-527-40473-5).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>igraph, graphics, stats</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-02 11:55:32 UTC; admin</td>
</tr>
<tr>
<td>Author:</td>
<td>Cesar Asensio <a href="https://orcid.org/0000-0002-7538-1501"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Cesar Asensio &lt;casencha@unizar.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-03 18:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='apply_incidence_map'>Apply incidence map of a graph to an edge vector</h2><span id='topic+apply_incidence_map'></span>

<h3>Description</h3>

<p>Apply incidence map of a graph to an edge vector.  It uses the
edgelist of the graph instead of the incidence matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_incidence_map(eG, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_incidence_map_+3A_eg">eG</code></td>
<td>
<p>Graph in edgelist representation, see <a href="igraph.html#topic+as_edgelist">as_edgelist</a>.</p>
</td></tr>
<tr><td><code id="apply_incidence_map_+3A_v">v</code></td>
<td>
<p>Edge vector to which the incidence map will be applied.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The incidence map is the linear transformation from the edge
vector space to the vertex vector space of a graph associating
to each edge its incident vertices.  It is customarily
represented by the incidence matrix, which is a very large
matrix for large graphs; for this reason it not efficient to
use directly the incidence matrix.  This function uses the
edgelist of the graph as returned by the <a href="igraph.html#topic+as_edgelist">as_edgelist</a>
function to compute the result of the incidence map on an edge
vector, which is interpreted with respect to the same
edgelist.
</p>


<h3>Value</h3>

<p>A vertex vector, having the degree of each vertex in the
subgraph specified by the edge vector.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p><a href="#topic+shave_cycle">shave_cycle</a>, for shaving hairy cycles, which makes use
of this routine, and <a href="#topic+generate_fundamental_cycles">generate_fundamental_cycles</a>, using the
former.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_graph("Dodecahedron")
eG &lt;- as_edgelist(g)
set.seed(1)
v &lt;- sample(0:1, gsize(g), replace = TRUE) # Random edge vector
apply_incidence_map(eG, v) # 1 1 0 1 2 0 1 1 3 2 0 1 1 1 1 1 0 0 1 2
## Plotting the associated subgraph
h &lt;- make_graph(t(eG[v==1,]))
z &lt;- layout_with_gem(g)
plot(g, layout = z)
plot(h, layout = z, add = TRUE, edge.color = "red3", edge.width = 3)

</code></pre>

<hr>
<h2 id='bfs_tree'>Breadth-first search tree</h2><span id='topic+bfs_tree'></span>

<h3>Description</h3>

<p>Computation of the breadth-first tree search in an undirected graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bfs_tree(g, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bfs_tree_+3A_g">g</code></td>
<td>
<p>Graph</p>
</td></tr>
<tr><td><code id="bfs_tree_+3A_r">r</code></td>
<td>
<p>Root: Starting vertex growing the tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Starting from a root vertex, the tree is grown by adding neighbors
of the first vertex added to the tree until no more neighbors
are left; then it passes to another vertex with neighbors
outside the tree.  In this way, the tree has few levels and
many branches and leaves.
</p>


<h3>Value</h3>

<p>A directed spanning subgraph of g containing the edges of
the BFS tree.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_graph("Frucht")
T &lt;- bfs_tree(g, 2)  # Root at v = 2
z &lt;- layout_with_gem(g)
plot(g, layout = z, main = "Breadth-first search tree")
plot(T, layout = z, add = TRUE, edge.color = "cyan4", edge.width = 2)
plot(T, layout = layout_as_tree(T))

</code></pre>

<hr>
<h2 id='build_cover_approx'>2-approximation algorithm for vertex cover</h2><span id='topic+build_cover_approx'></span>

<h3>Description</h3>

<p>Gavril's 2-approximation algorithm to build a vertex cover.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_cover_approx(G)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_cover_approx_+3A_g">G</code></td>
<td>
<p>Graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm computes a maximal matching and takes the ends of
the edges in the matching as a vertex cover.  No edge is
uncovered by this vertex subset, or the matching would not be
maximal; therefore, the vertex set thus found is indeed a
vertex cover.
</p>
<p>Since no vertex can be incident to two edges of a matching M, at
least |M| vertices are needed to cover the edges of the
matching; thus, any vertex cover X should satisfy |X| &gt;= |M|.
Moreover, the vertices incident to the matching are always a
vertex cover, which implies that, if X* is a vertex cover of
minimum sise, |X*| &lt;= 2|M|.
</p>


<h3>Value</h3>

<p>A list with two components: $set contains the cover, $size
contains the number of vertices of the cover.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>References</h3>

<p>Korte, Vygen <em>Combinatorial Optimization. Theory
and Algorithms.</em>
</p>


<h3>See Also</h3>

<p><a href="#topic+is_cover">is_cover</a> checks if a vertex subset is a vertex cover,
<a href="#topic+build_cover_greedy">build_cover_greedy</a> builds a cover using a greedy heuristic,
<a href="#topic+improve_cover_flip">improve_cover_flip</a> improves a cover using local
search, <a href="#topic+search_cover_random">search_cover_random</a> looks for a random cover of
fixed size, <a href="#topic+search_cover_ants">search_cover_ants</a> looks for a random cover using
a version of the ant-colony optimization heuristic,
<a href="#topic+find_cover_BB">find_cover_BB</a> finds covers using a branch-and-bound
technique, <a href="#topic+plot_cover">plot_cover</a> plots a cover.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example with known vertex cover
K25 &lt;- make_full_graph(25)   # Cover of size 24
X0 &lt;- build_cover_approx(K25)
X0$size  # 24
plot_cover(X0, K25)

## Vertex-cover of a random graph
set.seed(1)
n &lt;- 25
g &lt;- sample_gnp(n, p=0.25)
X2 &lt;- build_cover_approx(g)
X2$size   # 20
plot_cover(X2, g)

</code></pre>

<hr>
<h2 id='build_cover_greedy'>Greedy algorithm for vertex cover in a graph</h2><span id='topic+build_cover_greedy'></span>

<h3>Description</h3>

<p>This routine uses a greedy algorithm to build a cover selecting
the highest degree vertex first and removing its incident
edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_cover_greedy(G)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_cover_greedy_+3A_g">G</code></td>
<td>
<p>Graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm builds a vertex cover since no edge remains to be
covered when it returns.  However, it is no guaranteed that
the cover found by this algorithm has minimum cardinality.
</p>


<h3>Value</h3>

<p>A list with two components: $set contains the cover, $size
contains the number of vertices of the cover.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>References</h3>

<p>Korte, Vygen <em>Combinatorial Optimization. Theory
and Algorithms.</em>
</p>


<h3>See Also</h3>

<p><a href="#topic+is_cover">is_cover</a> checks if a vertex subset is a vertex cover,
<a href="#topic+build_cover_approx">build_cover_approx</a> builds a cover using a 2-approximation
algorithm, <a href="#topic+improve_cover_flip">improve_cover_flip</a> improves a cover using local
search, <a href="#topic+search_cover_random">search_cover_random</a> looks for a random cover of
fixed size, <a href="#topic+search_cover_ants">search_cover_ants</a> looks for a random cover using
a version of the ant-colony optimization heuristic,
<a href="#topic+find_cover_BB">find_cover_BB</a> finds covers using a branch-and-bound
technique, <a href="#topic+plot_cover">plot_cover</a> plots a cover.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example with known cover
K25 &lt;- make_full_graph(25)   # Cover of size 24
X0 &lt;- build_cover_greedy(K25)
X0$size  # 24
plot_cover(X0, K25)
plot_cover(list(set = c(1,2), size = 2), K25)

## Vertex-cover of a random graph
set.seed(1)
n &lt;- 25
g &lt;- sample_gnp(n, p=0.25)
X1 &lt;- build_cover_greedy(g)
X1$size   # 17
plot_cover(X1, g)

</code></pre>

<hr>
<h2 id='build_cover_random'>Random vertex covers</h2><span id='topic+build_cover_random'></span>

<h3>Description</h3>

<p>Random algorithm for vertex-cover.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_cover_random(G, N, p = 0.75)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_cover_random_+3A_g">G</code></td>
<td>
<p>Graph.</p>
</td></tr>
<tr><td><code id="build_cover_random_+3A_n">N</code></td>
<td>
<p>Number of random vertex set to try.</p>
</td></tr>
<tr><td><code id="build_cover_random_+3A_p">p</code></td>
<td>
<p>Probability of each element to be selected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It builds N random vertex sets by inserting elements with
probability p, and it verifies if the subset so chosen is a
vertex cover by running <a href="#topic+is_cover">is_cover</a> on it.  It is very
difficult to find a good vertex cover in this way, so this
algorithm is very inefficient and it finds no specially good
covers.
</p>
<p>Currently, this function is <em>not</em> exported.  The random sampling
performed by <a href="#topic+search_cover_random">search_cover_random</a> is faster and more
efficient.
</p>


<h3>Value</h3>

<p>A list with four components: $set contains the subset of
V(g) representing the cover and $size contains the number of
vertices of the cover; $found is the number of vertex covers
found and $failed is the number of generated subset that were
not vertex covers.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 25
g &lt;- sample_gnp(n, p=0.25)  # Random graph
X5 &lt;- build_cover_random(g,10000,p=0.65)
X5$size            # 19
plot_cover(X5, g)
X6 &lt;- improve_cover_flip(g, X5)   # Improved : 17
plot_cover(X6, g)

</code></pre>

<hr>
<h2 id='build_cut_greedy'>Greedy algorithm aimed to build a large weight cut in a
graph</h2><span id='topic+build_cut_greedy'></span>

<h3>Description</h3>

<p>This routine uses a greedy algorithm to build a cut with large
weight.  This is a 2-approximation algorithm, which means that
the weight of the cut returned by this algorithm is larger
than half the maximum possible cut weight for a given graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_cut_greedy(G, w = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_cut_greedy_+3A_g">G</code></td>
<td>
<p>Graph</p>
</td></tr>
<tr><td><code id="build_cut_greedy_+3A_w">w</code></td>
<td>
<p>Weight matrix (defaults to NA).  It should be zero for
those edges not in G</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm builds a vertex subset S a step a a time.  It starts
with S = c(v1), and with vertices v1 and v2 marked.  Then it
iterates from vertex v3 to vn checking if the weight of the
edges joining vi with marked vertices belonging to S is less
than the weight of the edges joining vi with marked vertices
not belonging to S.  If the former weight is less than the
latter, then vi is adjoined to S.  At the end of each
iteration, vertex vi is marked.  When all vertices are marked
the algorithm ends and S is already built.
</p>


<h3>Value</h3>

<p>A list with four components: $set contains the subset of
V(g) representing the cut, $size contains the number of edges
of the cut, $weight contains the weight of the cut (which
coincides with $size if w is NA) and $cut contains the edges
of the cut, joining vertices inside $set with vertices outside
$set.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>References</h3>

<p>Korte, Vygen <em>Combinatorial Optimization. Theory
and Algorithms.</em>
</p>


<h3>See Also</h3>

<p><a href="#topic+build_cut_random">build_cut_random</a> builds a random cut,
<a href="#topic+improve_cut_flip">improve_cut_flip</a> uses local search to improve a cut obtained
by other methods, <a href="#topic+compute_cut_weight">compute_cut_weight</a> computes cut size,
weight and edges, <a href="#topic+plot_cut">plot_cut</a> plots a cut.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example with known maximum cut
K10 &lt;- make_full_graph(10)   # Max cut of size 25
c0 &lt;- build_cut_greedy(K10)
c0$size  # 25
plot_cut(c0, K10)

## Max-cut of a random graph
set.seed(1)
n &lt;- 25
g &lt;- sample_gnp(n, p=0.25)
c2 &lt;- build_cut_greedy(g)
c2$size   # 59
plot_cut(c2, g)

</code></pre>

<hr>
<h2 id='build_cut_random'>Random cut generation on a graph</h2><span id='topic+build_cut_random'></span>

<h3>Description</h3>

<p>Random cut generation on a graph.  This function generates a
hopefully large cut on a graph by randomly selecting vertices;
it does not attempt to maximize the cut size or weigth, so it
is intended to be used as part of some smarter strategy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_cut_random(G, w = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_cut_random_+3A_g">G</code></td>
<td>
<p>Graph</p>
</td></tr>
<tr><td><code id="build_cut_random_+3A_w">w</code></td>
<td>
<p>Weight matrix (defaults to NA).  It should be zero for
those edges not in G</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It selects a random subset of the vertex set of the graph,
computing the associated cut, its size and its weigth,
provided by the user as a weight matrix.  If the weight
argument w is NA, the weights are taken as 1.
</p>


<h3>Value</h3>

<p>A list with four components: $set contains the subset of
V(g) representing the cut, $size contains the number of edges
of the cut, $weight contains the weight of the cut (which
coincides with $size if w is NA) and $cut contains the edges
of the cut, joining vertices inside $set with vertices outside
$set.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p><a href="#topic+build_cut_greedy">build_cut_greedy</a> builds a cut using a greedy algorithm,
<a href="#topic+compute_cut_weight">compute_cut_weight</a> computes cut size, weight and edges,
<a href="#topic+improve_cut_flip">improve_cut_flip</a> uses local search to improve a cut obtained
by other methods, <a href="#topic+plot_cut">plot_cut</a> plots a cut.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example with known maximum cut
K10 &lt;- make_full_graph(10)   # Max cut of size 25
c0 &lt;- build_cut_random(K10)
c0$size  # Different results: 24, 21, ...
plot_cut(c0, K10)

## Max-cut of a random graph
set.seed(1)
n &lt;- 25
g &lt;- sample_gnp(n, p=0.25)
c1 &lt;- build_cut_random(g)   # Repeat as you like
c1$size  # Different results: 43, 34, 39, 46, 44, 48...
plot_cut(c1, g)

</code></pre>

<hr>
<h2 id='build_tour_2tree'>Double-tree heuristic for TSP</h2><span id='topic+build_tour_2tree'></span>

<h3>Description</h3>

<p>Double-tree heuristic tour-building algorithm for the Traveling
Salesperson Problem
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_tour_2tree(d, n, v0 = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_tour_2tree_+3A_d">d</code></td>
<td>
<p>Distance matrix defining the TSP instance</p>
</td></tr>
<tr><td><code id="build_tour_2tree_+3A_n">n</code></td>
<td>
<p>Number of cities to consider with respect to the distance matrix</p>
</td></tr>
<tr><td><code id="build_tour_2tree_+3A_v0">v0</code></td>
<td>
<p>Initial vertex to find the eulerian walk; it defaults to 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <strong>double-tree</strong> heuristic is a 2-factor approximation
algorithm which begins by forming a minimum distance spanning
tree, then it forms the double-tree by doubling each edge of
the spanning tree.  The double tree is Eulerian, so an
Eulerian walk can be computed, which gives a well-defined
order of visiting the cities of the problem, thereby yielding
the tour.
</p>
<p>In practice, this algorithm performs poorly when compared with
another simple heuristics such as nearest-neighbor or
insertion methods.
</p>


<h3>Value</h3>

<p>A list with two components: $tour contains a permutation
of the 1:n sequence representing the tour constructed by the
algorithm, and $distance contains the value of the distance
covered by the tour.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p><a href="#topic+build_tour_nn">build_tour_nn</a> uses the nearest heighbor heuristic,
<a href="#topic+build_tour_nn_best">build_tour_nn_best</a> repeats the previous algorithm with all
possible starting points, <a href="#topic+compute_tour_distance">compute_tour_distance</a> computes
tour distances, <a href="#topic+compute_distance_matrix">compute_distance_matrix</a> computes a distance
matrix, <a href="#topic+plot_tour">plot_tour</a> plots a tour, <a href="#topic+find_euler">find_euler</a> finds an
Eulerian walk.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Regular example with obvious solution (minimum distance 48)
m &lt;- 10   # Generate some points in the plane
z &lt;- cbind(c(rep(0,m), rep(2,m), rep(5,m), rep(7,m)), rep(seq(0,m-1),4))
n &lt;- nrow(z)
d &lt;- compute_distance_matrix(z)
b &lt;- build_tour_2tree(d, n)
b$distance    # Distance 57.86
plot_tour(z,b)

## Random points
set.seed(1)
n &lt;- 25
z &lt;- cbind(runif(n,min=1,max=10),runif(n,min=1,max=10))
d &lt;- compute_distance_matrix(z)
b &lt;- build_tour_2tree(d, n)
b$distance    # Distance 48.63
plot_tour(z,b)

</code></pre>

<hr>
<h2 id='build_tour_greedy'>Building a tour for a TSP using the greedy heuristic</h2><span id='topic+build_tour_greedy'></span>

<h3>Description</h3>

<p>Greedy heuristic tour-building algorithm for the Traveling
Salesperson Problem
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_tour_greedy(d, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_tour_greedy_+3A_d">d</code></td>
<td>
<p>Distance matrix of the TSP.</p>
</td></tr>
<tr><td><code id="build_tour_greedy_+3A_n">n</code></td>
<td>
<p>Number of vertices of the TSP complete graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The greedy heuristic begins by sorting the edges by increasing
distance.  The tour is constructed by adding an edge under the
condition that the final tour is a connected spanning cycle.
</p>


<h3>Value</h3>

<p>A list with two components: $tour contains a permutation
of the 1:n sequence representing the tour constructed by the
algorithm, and $distance contains the value of the distance
covered by the tour.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p><a href="#topic+build_tour_nn">build_tour_nn</a> uses the nearest heighbor heuristic,
<a href="#topic+build_tour_nn_best">build_tour_nn_best</a> repeats the previous algorithm with all
possible starting points, <a href="#topic+compute_tour_distance">compute_tour_distance</a> computes
tour distances, <a href="#topic+compute_distance_matrix">compute_distance_matrix</a> computes a distance
matrix, <a href="#topic+plot_tour">plot_tour</a> plots a tour, <a href="#topic+build_tour_2tree">build_tour_2tree</a>
constructs a tour using the double tree 2-factor approximation
algorithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Regular example with obvious solution (minimum distance 48)
m &lt;- 10   # Generate some points in the plane
z &lt;- cbind(c(rep(0,m), rep(2,m), rep(5,m), rep(7,m)), rep(seq(0,m-1),4))
n &lt;- nrow(z)
d &lt;- compute_distance_matrix(z)
b &lt;- build_tour_greedy(d, n)
b$distance    # Distance 50
plot_tour(z,b)

## Random points
set.seed(1)
n &lt;- 25
z &lt;- cbind(runif(n,min=1,max=10),runif(n,min=1,max=10))
d &lt;- compute_distance_matrix(z)
b &lt;- build_tour_greedy(d, n)
b$distance    # Distance 36.075
plot_tour(z,b)

</code></pre>

<hr>
<h2 id='build_tour_nn'>Building a tour for a TSP using the nearest neighbor
heuristic</h2><span id='topic+build_tour_nn'></span>

<h3>Description</h3>

<p>Nearest neighbor heuristic tour-building algorithm for the
Traveling Salesperson Problem
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_tour_nn(d, n, v0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_tour_nn_+3A_d">d</code></td>
<td>
<p>Distance matrix of the TSP.</p>
</td></tr>
<tr><td><code id="build_tour_nn_+3A_n">n</code></td>
<td>
<p>Number of vertices of the TSP complete graph.</p>
</td></tr>
<tr><td><code id="build_tour_nn_+3A_v0">v0</code></td>
<td>
<p>Starting vertex.  Valid values are integers between 1
and n.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Starting from a vertex, the algorithm takes its nearest neighbor
and incorporates it to the tour, repeating until the tour is
complete.  The result is dependent of the initial vertex.
This algorithm is very efficient but its output can be very
far from the minimum.
</p>


<h3>Value</h3>

<p>A list with two components: $tour contains a permutation
of the 1:n sequence representing the tour constructed by the
algorithm, and $distance contains the value of the distance
covered by the tour.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p><a href="#topic+build_tour_nn_best">build_tour_nn_best</a> repeats this algorithm with all
possible starting points, <a href="#topic+compute_tour_distance">compute_tour_distance</a> computes
tour distances, <a href="#topic+compute_distance_matrix">compute_distance_matrix</a> computes a distance
matrix, <a href="#topic+plot_tour">plot_tour</a> plots a tour, <a href="#topic+build_tour_greedy">build_tour_greedy</a>
constructs a tour using the greedy heuristic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Regular example with obvious solution (minimum distance 48)
m &lt;- 10   # Generate some points in the plane
z &lt;- cbind(c(rep(0,m), rep(2,m), rep(5,m), rep(7,m)), rep(seq(0,m-1),4))
n &lt;- nrow(z)
d &lt;- compute_distance_matrix(z)
b &lt;- build_tour_nn(d, n, 1)
b$distance    # Distance 50
plot_tour(z,b)
b &lt;- build_tour_nn(d, n, 5)
b$distance    # Distance 52.38
plot_tour(z,b)

## Random points
set.seed(1)
n &lt;- 25
z &lt;- cbind(runif(n,min=1,max=10),runif(n,min=1,max=10))
d &lt;- compute_distance_matrix(z)
b &lt;- build_tour_nn(d, n, 1)
b$distance    # Distance 46.4088
plot_tour(z,b)
b &lt;- build_tour_nn(d, n, 9)
b$distance    # Distance 36.7417
plot_tour(z,b)

</code></pre>

<hr>
<h2 id='build_tour_nn_best'>Build a tour for a TSP using the best nearest neighbor
heuristic</h2><span id='topic+build_tour_nn_best'></span>

<h3>Description</h3>

<p>Nearest neighbor heuristic tour-building algorithm for the
Traveling Salesperson Problem - Better starting point
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_tour_nn_best(d, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_tour_nn_best_+3A_d">d</code></td>
<td>
<p>Distance matrix of the TSP.</p>
</td></tr>
<tr><td><code id="build_tour_nn_best_+3A_n">n</code></td>
<td>
<p>Number of vertices of the TSP complete graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It applies the nearest neighbor heuristic with all possible
starting vertices, retaining the best tour returned by
<a href="#topic+build_tour_nn">build_tour_nn</a>.
</p>


<h3>Value</h3>

<p>A list with four components: $tour contains a permutation
of the 1:n sequence representing the tour constructed by the
algorithm, $distance contains the value of the distance
covered by the tour, $start contains the better starting
vertex found, and $Lall contains the distances found by
starting from each vertex.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p><a href="#topic+build_tour_nn">build_tour_nn</a> nearest neighbor heuristic with a single
starting point, <a href="#topic+compute_tour_distance">compute_tour_distance</a> computes tour
distances, <a href="#topic+compute_distance_matrix">compute_distance_matrix</a> computes a distance
matrix, <a href="#topic+plot_tour">plot_tour</a> plots a tour.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Regular example with obvious solution (minimum distance 48)
m &lt;- 10   # Generate some points in the plane
z &lt;- cbind(c(rep(0,m), rep(2,m), rep(5,m), rep(7,m)), rep(seq(0,m-1),4))
n &lt;- nrow(z)
d &lt;- compute_distance_matrix(z)
b &lt;- build_tour_nn_best(d, n)
b$distance    # Distance 48.6055
b$start       # Vertex 12
plot_tour(z,b)

## Random points
set.seed(1)
n &lt;- 25
z &lt;- cbind(runif(n,min=1,max=10),runif(n,min=1,max=10))
d &lt;- compute_distance_matrix(z)
b &lt;- build_tour_nn_best(d, n)
b$distance    # Distance 36.075
b$start       # Vertex 13
plot_tour(z,b)

</code></pre>

<hr>
<h2 id='color_graph_greedy'>Greedy coloring of a graph</h2><span id='topic+color_graph_greedy'></span>

<h3>Description</h3>

<p>Greedy algorithm for coloring the vertices of a graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>color_graph_greedy(g, ord = NULL, ran = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="color_graph_greedy_+3A_g">g</code></td>
<td>
<p>Graph to be colored</p>
</td></tr>
<tr><td><code id="color_graph_greedy_+3A_ord">ord</code></td>
<td>
<p>Specified vertex ordering or NULL if natural vertex
ordering is preferred</p>
</td></tr>
<tr><td><code id="color_graph_greedy_+3A_ran">ran</code></td>
<td>
<p>Choose random vertex ordering; it defaults to FALSE.
It is ignored if ord is non-NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;Colors&quot; are integers from 1 to the order of the graph to be
colored.  The greedy strategy assigns to each vertex v the least
color not assigned to the neighbors of v.
</p>


<h3>Value</h3>

<p>Vertex colors in a vector, with component i being the
(integer) color of vertex i.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
g &lt;- make_graph("Petersen")
cg &lt;- color_graph_greedy(g)
plot(g, vertex.color = rainbow(6)[cg])
max(cg)         # = 3: Number of colors used by the algorithm
sum(g[cg == 1, cg == 1])  # = 0: Color classes are stable sets

g &lt;- make_graph("Dodecahedron")
cg &lt;- color_graph_greedy(g)
plot(g, vertex.color = rainbow(6)[cg])
max(cg)   # = 4: Number of colors used by the algorithm
sum(g[cg == 1, cg == 1])  # = 0: Color classes are stable sets

## However, the dodecahedron has a 3-coloring:
cdod &lt;- rep(1, 20)
cdod[c(1,3,7,12,13,20)] &lt;- 2
cdod[c(5,8,9,11,17,19)] &lt;- 3
plot(g, vertex.color = rainbow(6)[cdod])
sum(g[cdod == 1, cdod == 1]) # = 0
sum(g[cdod == 2, cdod == 2]) # = 0
sum(g[cdod == 3, cdod == 3]) # = 0

## Some vertex orderings can use less colors:
cg &lt;- color_graph_greedy(g, ord = 20:1)
plot(g, vertex.color = rainbow(6)[cg])
max(cg)         # = 3: Number of colors used by the algorithm

</code></pre>

<hr>
<h2 id='compute_cut_weight'>Compute cut weight and size</h2><span id='topic+compute_cut_weight'></span>

<h3>Description</h3>

<p>Compute cut weight and size from its associated vertex set.  It
can also return the edges in the cut.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_cut_weight(S, n, eG, w = NA, return.cut = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_cut_weight_+3A_s">S</code></td>
<td>
<p>Subset of the vertex set of the graph.</p>
</td></tr>
<tr><td><code id="compute_cut_weight_+3A_n">n</code></td>
<td>
<p>Size of the graph.</p>
</td></tr>
<tr><td><code id="compute_cut_weight_+3A_eg">eG</code></td>
<td>
<p>Edgelist of the graph as returned by <a href="igraph.html#topic+as_edgelist">as_edgelist</a>, that
is, a matrix with q rows and 2 columns.  Note that this is the
graph format used by the routine.</p>
</td></tr>
<tr><td><code id="compute_cut_weight_+3A_w">w</code></td>
<td>
<p>Weight matrix or NA if all edge weights are 1.  It should
be zero for those edges not in G</p>
</td></tr>
<tr><td><code id="compute_cut_weight_+3A_return.cut">return.cut</code></td>
<td>
<p>Boolean.  Should the routine return the edges in
the cut? It defaults to FALSE.  When TRUE, the routine also
returns the input subset S, for easier cut plotting with
<a href="#topic+plot_cut">plot_cut</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a graph, a cut K is defined by means of a vertex subset S as
the edges joining vertices inside S with vertices outside S.
This routine computes these edges and their associated weight.
</p>


<h3>Value</h3>

<p>A list with two components: $size is the number of edges
in the cut, $weight is the weight of the cut, that is, the sum
of the weights of the edges in the cut.  If w=NA these two
numbers coincide.  When return.cut is TRUE, there are two
additional components of the list: $cut, which contains the
edges in the cut as rows of a two-column matrix, and $set,
which contains the input set, as a convenience for plotting
with <a href="#topic+plot_cut">plot_cut</a>.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p><a href="#topic+build_cut_random">build_cut_random</a> builds a random cut,
<a href="#topic+build_cut_greedy">build_cut_greedy</a> builds a cut using a greedy algorithm,
<a href="#topic+improve_cut_flip">improve_cut_flip</a> uses local search to improve a cut obtained
by other methods, <a href="#topic+plot_cut">plot_cut</a> plots a cut.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>K10 &lt;- make_full_graph(10)
S &lt;- c(1,4,7)
compute_cut_weight(S, gorder(K10), as_edgelist(K10))
cS &lt;- compute_cut_weight(S, gorder(K10), as_edgelist(K10),
    return.cut = TRUE)
plot_cut(cS, K10)

</code></pre>

<hr>
<h2 id='compute_distance_matrix'><code class="reqn">p</code>-distance matrix computation</h2><span id='topic+compute_distance_matrix'></span>

<h3>Description</h3>

<p>It computes the distance matrix of a set of <code class="reqn">n</code>
two-dimensional points given by a <code class="reqn">n\times 2</code> matrix using
the distance-<code class="reqn">p</code> with <code class="reqn">p=2</code> by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_distance_matrix(z, p = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_distance_matrix_+3A_z">z</code></td>
<td>
<p>A <code class="reqn">n\times 2</code> matrix with the two-dimensional points</p>
</td></tr>
<tr><td><code id="compute_distance_matrix_+3A_p">p</code></td>
<td>
<p>The <code class="reqn">p</code> parameter of the distance-<code class="reqn">p</code>.  It
defaults to 2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a set of <code class="reqn">n</code> points <code class="reqn">\{z_j\}_{j=1,...,n}</code>, the
distance matrix is a <code class="reqn">n\times n</code> symmetric matrix with
matrix elements </p>
<p style="text-align: center;"><code class="reqn">d_{ij} = d(z_i,z_j)</code>
</p>
<p> computed using the
distance-<code class="reqn">p</code> given by </p>
<p style="text-align: center;"><code class="reqn">d_p(x,y) = \left(\sum_i
    (x_i-y_i)^p\right)^{\frac{1}{p}}</code>
</p>
<p>.
</p>


<h3>Value</h3>

<p>The distance-<code class="reqn">p</code> of the points.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p><a href="#topic+compute_p_distance">compute_p_distance</a> computes the distance-<code class="reqn">p</code>,
<a href="#topic+compute_tour_distance">compute_tour_distance</a> computes tour distances.  A distance
matrix can also be computed using <a href="stats.html#topic+dist">dist</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n &lt;- 25
z &lt;- cbind(runif(n,min=1,max=10),runif(n,min=1,max=10))
d &lt;- compute_distance_matrix(z)

</code></pre>

<hr>
<h2 id='compute_gain_transp'>Distance gain when transposing two cities in a tour</h2><span id='topic+compute_gain_transp'></span>

<h3>Description</h3>

<p>Distance gain when two cities in a TSP tour are interchanged, that
is, the neighbors of the first become the neighbors of the
second and vice versa.  It is used to detect favorable moves
in a Lin-Kernighan-based routine for the TSP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_gain_transp(C, tr, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_gain_transp_+3A_c">C</code></td>
<td>
<p>Tour represented as a non-repeated vertex sequence.
Equivalently, a permutation of the sequence from 1 to length(C).</p>
</td></tr>
<tr><td><code id="compute_gain_transp_+3A_tr">tr</code></td>
<td>
<p>Transposition, represented as a pair of indices between
1 and length(C).</p>
</td></tr>
<tr><td><code id="compute_gain_transp_+3A_d">d</code></td>
<td>
<p>Distance matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It computes the gain in distance when interchanging two cities in
a tour.  The transformation is akin to a 2-interchange; in
fact, if the transposed vertices are neighbors in the tour or
share a common neighbor, the transposition is a
2-interchange.  If the transposed vertices in the tour do not
share any neighbors, then the transposition is a pair of
2-interchanges.
</p>
<p>This gain is used in <a href="#topic+improve_tour_LinKer">improve_tour_LinKer</a>, where the
transposition neighborhood is used instead of the variable
k-opt neighborhood for simplicity.
</p>


<h3>Value</h3>

<p>The gain in distance after performing transposition tr in
tour C with distance matrix d.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p><a href="#topic+improve_tour_LinKer">improve_tour_LinKer</a>, a where this function is used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n &lt;- 25
z &lt;- cbind(runif(n,min=1,max=10),runif(n,min=1,max=10))
d &lt;- compute_distance_matrix(z)
compute_gain_transp(sample(n),c(4,23),d)  # -6.661
compute_gain_transp(sample(n),c(17,3),d)  #  4.698

</code></pre>

<hr>
<h2 id='compute_lower_bound_1tree'>Computing the 1-tree lower bound for a TSP instance</h2><span id='topic+compute_lower_bound_1tree'></span>

<h3>Description</h3>

<p>It computes the 1-tree lower bound for an optimum tour for a TSP instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_lower_bound_1tree(d, n, degree = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_lower_bound_1tree_+3A_d">d</code></td>
<td>
<p>Distance matrix.</p>
</td></tr>
<tr><td><code id="compute_lower_bound_1tree_+3A_n">n</code></td>
<td>
<p>Number of vertices of the TSP complete graph.</p>
</td></tr>
<tr><td><code id="compute_lower_bound_1tree_+3A_degree">degree</code></td>
<td>
<p>Boolean: Should the routine return the degree
seguence of the internal minimum spanning tree? Defaults to
FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It computes the 1-tree lower bound for an optimum tour for a TSP
instance from vertex 1.  Internally, it creates the graph Kn-v1
and invokes <a href="igraph.html#topic+mst">mst</a> from package <a href="igraph.html#topic+igraph">igraph</a> to compute the minimum
weight spanning tree.  If optional argument &quot;degree&quot; is TRUE, it
returns the degree seguence of this internal minimum spanning
tree, which is very convenient when embedding this routine in the
Held-Karp lower bound estimation routine.
</p>


<h3>Value</h3>

<p>The 1-tree lower bound &ndash; A scalar if the optional
argument &quot;degree&quot; is FALSE.  Otherwise, a list with the
previous 1-tree lower bound in the $bound component and the
degree sequence of the internal minimum spanning tree in the
$degree component.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p><a href="#topic+improve_tour_2opt">improve_tour_2opt</a> tour improving using 2-opt,
<a href="#topic+improve_tour_3opt">improve_tour_3opt</a> tour improving using 3-opt,
<a href="#topic+compute_lower_bound_HK">compute_lower_bound_HK</a> for Held-Karp lower bound estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- 10   # Generate some points in the plane
z &lt;- cbind(c(rep(0,m), rep(2,m), rep(5,m), rep(7,m)), rep(seq(0,m-1),4))
n &lt;- nrow(z)
d &lt;- compute_distance_matrix(z)
b &lt;- build_tour_2tree(d, n)
b$distance           # Distance 57.868
bi &lt;- improve_tour_2opt(d, n, b$tour)
bi$distance          # Distance 48 (optimum)
compute_lower_bound_1tree(d,n)       # 45

## Random points
set.seed(1)
n &lt;- 25
z &lt;- cbind(runif(n,min=1,max=10),runif(n,min=1,max=10))
d &lt;- compute_distance_matrix(z)
compute_lower_bound_1tree(d,n)       # 31.4477
bn &lt;- build_tour_nn_best(d,n)
b3 &lt;- improve_tour_3opt(d,n,bn$tour)
b3$distance                          # 35.081

</code></pre>

<hr>
<h2 id='compute_lower_bound_HK'>Held-Karp lower bound estimate</h2><span id='topic+compute_lower_bound_HK'></span>

<h3>Description</h3>

<p>Held-Karp lower bound estimate for the minimum distance of an
optimum tour in the TSP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_lower_bound_HK(d, n, U, tsmall = 0.001, it = 0.2 * n, block = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_lower_bound_HK_+3A_d">d</code></td>
<td>
<p>Distance matrix of the TSP instance.</p>
</td></tr>
<tr><td><code id="compute_lower_bound_HK_+3A_n">n</code></td>
<td>
<p>Number of vertices of the TSP complete graph.</p>
</td></tr>
<tr><td><code id="compute_lower_bound_HK_+3A_u">U</code></td>
<td>
<p>Upper bound of the minimum distance.</p>
</td></tr>
<tr><td><code id="compute_lower_bound_HK_+3A_tsmall">tsmall</code></td>
<td>
<p>Stop criterion: Is the step size decreases beyond
this point the algorithm stops.  Defaults to 0.001.</p>
</td></tr>
<tr><td><code id="compute_lower_bound_HK_+3A_it">it</code></td>
<td>
<p>Iterates inside each block.  Some experimentation is
required to adjust this parameter: If it is large, the run
time will be larger; if it is small, the accuracy will
decrease.</p>
</td></tr>
<tr><td><code id="compute_lower_bound_HK_+3A_block">block</code></td>
<td>
<p>Number of blocks of &quot;it&quot; iterations.  In each block
the size of the multiplier is halved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An implementation of the Held-Karp iterative algorithm towards the
minimum distance tour of a TSP instance.  As the algorithm
converges slowly, only an estimate will be achieved.  The
accuracy of the estimate depends on the stopping requirements
through the number of iteration blocks &quot;block&quot; and the number
of iterations per block &quot;it&quot;, as well as the smallest allowed
multiplier size &quot;tsmall&quot;: When it is reached the algorithm
stops.  It is also crucial to a good estimate the quality of
the upper bound &quot;U&quot; obtained by other methods.
</p>
<p>The Held-Karp bound has the following uses: (1) assessing the
quality of solutions not known to be optimal; (2) giving an
optimality proof of a given solution; and (3) providing the
&quot;bound&quot; part in a branch-and-bound technique.
</p>
<p>Please note that recommended computation of the Held-Karp bound
uses Lagrangean relaxation on an integer programming formulation
of the TSP, whereas this routine uses the Cook algorithm to be
found in the reference below.
</p>


<h3>Value</h3>

<p>An estimate of the Held-Karp lower bound &ndash; A scalar.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>References</h3>

<p>Cook et al.  <em>Combinatorial Optimization</em> (1998)
sec. 7.3.
</p>


<h3>See Also</h3>

<p><a href="#topic+compute_distance_matrix">compute_distance_matrix</a> computes distance matrix of a
set of points, <a href="#topic+build_tour_nn_best">build_tour_nn_best</a> builds a tour using the
best-nearest-neighbor heuristic, <a href="#topic+improve_tour_2opt">improve_tour_2opt</a> improves
a tour using 2-opt, <a href="#topic+improve_tour_3opt">improve_tour_3opt</a> improves a tour using
3-opt, <a href="#topic+compute_lower_bound_1tree">compute_lower_bound_1tree</a> computes the 1-tree lower
bound.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- 10   # Generate some points in the plane
z &lt;- cbind(c(rep(0,m), rep(2,m), rep(5,m), rep(7,m)), rep(seq(0,m-1),4))
n &lt;- nrow(z)
d &lt;- compute_distance_matrix(z)
b &lt;- build_tour_nn_best(d, n)
b$distance           # Distance 48.6055
bi &lt;- improve_tour_2opt(d, n, b$tour)
bi$distance          # Distance 48 (optimum)
compute_lower_bound_HK(d,n,U=48.61)                    # 45.927
compute_lower_bound_HK(d,n,U=48.61,it=20,tsmall=1e-6)  # 45.791

## Random points
set.seed(1)
n &lt;- 25
z &lt;- cbind(runif(n,min=1,max=10),runif(n,min=1,max=10))
d &lt;- compute_distance_matrix(z)
bn &lt;- build_tour_nn_best(d,n)
b3 &lt;- improve_tour_3opt(d,n,bn$tour)
b3$distance                                                    # 35.08155
compute_lower_bound_HK(d, n, U=35.1)                           # 34.80512
compute_lower_bound_HK(d, n, U=35.0816, it=20)                 # 35.02892
compute_lower_bound_HK(d, n, U=35.0816, tsmall = 1e-5)         # 34.81119
compute_lower_bound_HK(d, n, U=35.0816, it=50, tsmall = 1e-9)  # 35.06789

</code></pre>

<hr>
<h2 id='compute_p_distance'>Distance-p between two-dimensional points</h2><span id='topic+compute_p_distance'></span>

<h3>Description</h3>

<p>It computes the distance-<code class="reqn">p</code> between two-dimensional points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_p_distance(x, y, p = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_p_distance_+3A_x">x</code></td>
<td>
<p>A two-dimensional point</p>
</td></tr>
<tr><td><code id="compute_p_distance_+3A_y">y</code></td>
<td>
<p>A two-dimensional point</p>
</td></tr>
<tr><td><code id="compute_p_distance_+3A_p">p</code></td>
<td>
<p>The <code class="reqn">p</code>-parameter of the distance-<code class="reqn">p</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distance-<code class="reqn">p</code> is defined by </p>
<p style="text-align: center;"><code class="reqn">d_p(x,y) = \left(\sum_i
    (x_i-y_i)^p\right)^{\frac{1}{p}}</code>
</p>
<p>.
</p>


<h3>Value</h3>

<p>The distance-<code class="reqn">p</code> between points <code class="reqn">x</code> and <code class="reqn">y</code>.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p><a href="#topic+compute_distance_matrix">compute_distance_matrix</a> computes the distance matrix of
a set of two-dimensional points, <a href="#topic+compute_tour_distance">compute_tour_distance</a>
computes tour distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>compute_p_distance(c(1,2),c(3,4))      # 2.8284
compute_p_distance(c(1,2),c(3,4),p=1)  # 4

</code></pre>

<hr>
<h2 id='compute_path_distance'>Compute the distance of a TSP path</h2><span id='topic+compute_path_distance'></span>

<h3>Description</h3>

<p>It computes the distance covered by a path in a Traveling Salesman Problem
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_path_distance(h, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_path_distance_+3A_h">h</code></td>
<td>
<p>A path specified by a vertex sequence</p>
</td></tr>
<tr><td><code id="compute_path_distance_+3A_d">d</code></td>
<td>
<p>Distance matrix to use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simply add the distances in a distance matrix
indicated by a vertex sequence defining a path.  It takes into
account that, in a path, the last vertex is <strong>not</strong>
joined to the first one by an edge, unlike <a href="#topic+compute_tour_distance">compute_tour_distance</a>.
</p>


<h3>Value</h3>

<p>The path distance </p>
<p style="text-align: center;"><code class="reqn">d(\{v_1,...,v_n\}) = \sum_{j=1}^{n-1}
    d(v_j,v_{j + 1}).</code>
</p>



<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p><a href="#topic+build_tour_nn">build_tour_nn</a> nearest neighbor heuristic with a single
starting point, <a href="#topic+build_tour_nn_best">build_tour_nn_best</a> repeats the previous
algorithm with all possible starting points,
<a href="#topic+compute_distance_matrix">compute_distance_matrix</a> computes a distance matrix,
<a href="#topic+compute_tour_distance">compute_tour_distance</a> computes tour distances, <a href="#topic+plot_tour">plot_tour</a>
plots a tour.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n &lt;- 25
z &lt;- cbind(runif(n,min=1,max=10),runif(n,min=1,max=10))
d &lt;- compute_distance_matrix(z)
h &lt;- sample(1:n)              # A random tour
compute_path_distance(h, d)   # 107.246
compute_tour_distance(h, d) - compute_path_distance(h, d) - d[h[1], h[n]]

</code></pre>

<hr>
<h2 id='compute_tour_distance'>Compute the distance of a TSP tour</h2><span id='topic+compute_tour_distance'></span>

<h3>Description</h3>

<p>It computes the distance covered by a tour in a Traveling Salesman Problem
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_tour_distance(h, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_tour_distance_+3A_h">h</code></td>
<td>
<p>A tour specified by a vertex sequence</p>
</td></tr>
<tr><td><code id="compute_tour_distance_+3A_d">d</code></td>
<td>
<p>Distance matrix to use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simply add the distances in a distance matrix
indicated by a vertex sequence defining a tour.  It takes into
account that, in a tour, the last vertex is joined to the
first one by an edge, and adds its distance to the result,
unlike <a href="#topic+compute_path_distance">compute_path_distance</a>.
</p>


<h3>Value</h3>

<p>The tour distance </p>
<p style="text-align: center;"><code class="reqn">d(\{v_1,...,v_n\}) = \sum_{j=1}^n
    d(v_j,v_{(j mod n) + 1}).</code>
</p>



<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p><a href="#topic+build_tour_nn">build_tour_nn</a> nearest neighbor heuristic with a single
starting point, <a href="#topic+build_tour_nn_best">build_tour_nn_best</a> repeats the previous
algorithm with all possible starting points,
<a href="#topic+compute_distance_matrix">compute_distance_matrix</a> computes a distance matrix,
<a href="#topic+compute_path_distance">compute_path_distance</a> computes path distances, <a href="#topic+plot_tour">plot_tour</a>
plots a tour.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n &lt;- 25
z &lt;- cbind(runif(n,min=1,max=10),runif(n,min=1,max=10))
d &lt;- compute_distance_matrix(z)
h &lt;- sample(1:n)              # A random tour
compute_tour_distance(h, d)   # 114.58

</code></pre>

<hr>
<h2 id='crossover_sequences'>Crossover of sequences</h2><span id='topic+crossover_sequences'></span>

<h3>Description</h3>

<p>Crossover sequence operation for use in the genetic cut-search algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossover_sequences(s1, s2, cpoint = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossover_sequences_+3A_s1">s1</code></td>
<td>
<p>Sequence</p>
</td></tr>
<tr><td><code id="crossover_sequences_+3A_s2">s2</code></td>
<td>
<p>Sequence of the same lenght as s1</p>
</td></tr>
<tr><td><code id="crossover_sequences_+3A_cpoint">cpoint</code></td>
<td>
<p>Crossover point, an integer between 1 and
length(s1)-1.  Defaults to NA, in which case it will be
randomly chosen</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This operation takes two sequences of the same lenght &quot;n&quot; and
splits them in two at a crossover point between 1 and &quot;n-1&quot;.
Then it produces two &quot;offsprings&quot; by interchanging the pieces
and gluing them together.
</p>
<p>The crossover point can be specified in argument cpoint.  By
providing NA (the default), cpoint is chosen randomly.
</p>
<p>Note that this crossover operation is the &quot;classic&quot; crossover
included in the original genetic algorithm, and it is adequate
when applied to binary sequences.  However, when applied to
permutations, the result of this function can have repeated
elements; hence, it is not adequate for the TSP.
</p>


<h3>Value</h3>

<p>A two-row matrix.  Rows are the offsprings produced by the
crossover
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p><a href="#topic+search_cut_genetic">search_cut_genetic</a> genetic algorithm cut-search,
<a href="#topic+mutate_binary_sequence">mutate_binary_sequence</a> binary sequence mutation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
s1 &lt;- sample(0:1, 10, replace = TRUE)
s2 &lt;- sample(0:1, 10, replace = TRUE)
crossover_sequences(s1, s2)

set.seed(1)
s1 &lt;- sample(1:10, 10)
s2 &lt;- sample(1:10, 10)
crossover_sequences(s1, s2, cpoint = 5)

</code></pre>

<hr>
<h2 id='crossover_tours'>Crossover operation used by the TSP genetic algorithm</h2><span id='topic+crossover_tours'></span>

<h3>Description</h3>

<p>Crossover operation used by the TSP genetic algorithm.  It takes
two tours and it computes two &quot;offsprings&quot; trying to exploit
the structure of the cycles, see below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossover_tours(C1, C2, d, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossover_tours_+3A_c1">C1</code></td>
<td>
<p>Vertex numeric vector of the first parent tour.</p>
</td></tr>
<tr><td><code id="crossover_tours_+3A_c2">C2</code></td>
<td>
<p>Vertex numeric vector of the second parent tour.</p>
</td></tr>
<tr><td><code id="crossover_tours_+3A_d">d</code></td>
<td>
<p>Distance matrix of the TSP instance.  It is used in the
computation of the low-weight perfect matching.</p>
</td></tr>
<tr><td><code id="crossover_tours_+3A_n">n</code></td>
<td>
<p>The number of vertices of the TSP complete graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the genetic algorithm, the crossover operation is a
generalization of local search in which two tours are combined
somehow to produce two tours, hopefully different from their
parents and with better fitting function values.  Crossover
widens the search while trying to keep the good peculiarities
of the parents.  However, in practice crossover almost never
lowers the fitting function when parents are near the optimum,
but it helps to explore new routes.  Therefore, it is always a
good idea to complement crossover with some deterministic
local search procedure which can find another local optima;
crossover also helps in evading local minima.
</p>
<p>In this routine, crossover is performed as follows.  Firstly, the
edges of the parents are combined in a single graph, and the
repeated edges are eliminated.  Then, the odd degree vertices
of the resulting graph are matched looking for a low-weight
perfect matching using a greedy algorithm.  Adding the
matching to the previous graph yields an Eulerian graph, as in
Christofides algorithm, whose final step leads to the first
offspring tour.  The second tour is constructed by recording
the second visit of each vertex by the Eulerian walk, and
completing the resulting partial tour with the nearest
neighbor heuristic.
</p>


<h3>Value</h3>

<p>A two-row matrix containing the two offsprings as vertex
numeric vectors.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p><a href="#topic+search_tour_genetic">search_tour_genetic</a> implements a version of the genetic
algorithm for the TSP.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n &lt;- 25
z &lt;- cbind(runif(n,min=1,max=10),runif(n,min=1,max=10))
d &lt;- compute_distance_matrix(z)
c1 &lt;- sample(1:n)
c2 &lt;- sample(1:n)
c12 &lt;- crossover_tours(c1, c2, d, n)
compute_tour_distance(c1, d)        # 114.5848
compute_tour_distance(c2, d)        # 112.8995
compute_tour_distance(c12[1,], d)   # 116.3589
compute_tour_distance(c12[2,], d)   # 111.5184

</code></pre>

<hr>
<h2 id='dfs_tree'>Depth-first search tree</h2><span id='topic+dfs_tree'></span>

<h3>Description</h3>

<p>Computation of the depth-first tree search in an undirected graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfs_tree(g, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfs_tree_+3A_g">g</code></td>
<td>
<p>Graph</p>
</td></tr>
<tr><td><code id="dfs_tree_+3A_r">r</code></td>
<td>
<p>Root: Starting vertex growing the tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Starting from a root vertex, the tree is grown by adding neighbors
of the last vertex added to the tree.  In this way, the tree
has many levels and few branches and leaves.  When the tree
cannot grow further, it backtracks to previously added
vertices with neighbors outside the tree, adding them until
none is left.
</p>


<h3>Value</h3>

<p>A directed spanning subgraph of g containing the edges of
the DFS tree.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p><a href="#topic+bfs_tree">bfs_tree</a> breadth-first search tree; <a href="igraph.html#topic+bfs">bfs</a> and <a href="igraph.html#topic+dfs">dfs</a> in
the igraph package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_graph("Frucht")
T &lt;- dfs_tree(g, 5)  # Root at v = 5
z &lt;- layout_with_gem(g)
plot(g, layout = z, main = "Depth-first search tree")
plot(T, layout = z, add = TRUE, edge.color = "cyan4", edge.width = 2)
plot(T, layout = layout_as_tree(T))

</code></pre>

<hr>
<h2 id='dijk'>Dijkstra' algorithm for shortest paths</h2><span id='topic+dijk'></span>

<h3>Description</h3>

<p>Dijkstra's algorithm finding the sorthest paths from a root vertex
to the remaining vertices of a graph using a spanning tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dijk(g, d, r = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dijk_+3A_g">g</code></td>
<td>
<p>An igraph Graph</p>
</td></tr>
<tr><td><code id="dijk_+3A_d">d</code></td>
<td>
<p>Weights (lengths) of the edges of <code class="reqn">g</code></p>
</td></tr>
<tr><td><code id="dijk_+3A_r">r</code></td>
<td>
<p>Starting vertex &mdash; root of the output tree</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An implementation of Dijkstra's algorithm.
</p>


<h3>Value</h3>

<p>A list with components: $tree, which is a sequence of
pairs of vertices parent-son; $distances, which is a
<code class="reqn">2\times n</code> matrix with distances from the root vertex to
the remaining vertices, and $parents, which contains the
parent of each vertex in the tree, except for the root which
has no parent, so its entry is NA.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p><a href="igraph.html#topic+shortest_paths">shortest_paths</a> in the <a href="igraph.html#topic+igraph">igraph</a> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
g &lt;- make_graph("Frucht")
n &lt;- gorder(g)
set.seed(1);
d &lt;- matrix(round(runif(n^2, min = 1, max = 10)), nrow = n)  # Distances
d &lt;- d + t(d); for (i in 1:n) { d[i,i] &lt;- 0 }          # Distance matrix
Td &lt;- dijk(g, d, r = 1)
Td$distances
Td$parents
gTd &lt;- make_graph(Td$tree, n = gorder(g))   # igraph tree
Eg &lt;- as_edgelist(g)
dl &lt;- c()   # We convert the matrix in a list:
for (e in 1:nrow(Eg)) { dl &lt;- c(dl, d[Eg[e,1], Eg[e,2]]) }
z &lt;- layout_with_kk(g)
plot(g, layout = z, edge.label = dl)
plot(gTd, layout = z, edge.color = "red3", add = TRUE)

</code></pre>

<hr>
<h2 id='find_cover_BB'>Branch-and-Bound algorithm for the Vertex-Cover problem</h2><span id='topic+find_cover_BB'></span>

<h3>Description</h3>

<p>This routine performs a version of the Branch-and-Bound algorithm
for the VCP.  It is an exact algorithm with exponential
worst-case running time; therefore, it can be run only with a
small number of vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_cover_BB(
  g,
  verb = TRUE,
  save.best.result = FALSE,
  filename.best.result = "best_result_find_cover_BB.Rdata",
  nu = gorder(g),
  X = c(),
  Xmin = c(),
  marks = rep("F", gorder(g)),
  call = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_cover_BB_+3A_g">g</code></td>
<td>
<p>Graph.</p>
</td></tr>
<tr><td><code id="find_cover_BB_+3A_verb">verb</code></td>
<td>
<p>Boolean: Should echo each newly found cover to the
console? Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="find_cover_BB_+3A_save.best.result">save.best.result</code></td>
<td>
<p>Boolean: Should the algorithm save the
result of the algorithm in a file?  It defaults to FALSE.
When save.best.result = TRUE, a file is created with the
variable &quot;Xbest&quot; being the best result achieved by the
algorithm before its termination.</p>
</td></tr>
<tr><td><code id="find_cover_BB_+3A_filename.best.result">filename.best.result</code></td>
<td>
<p>Name of the file created when
save.best.result = TRUE.  It defaults to
&quot;best_result_find_cover_BB.Rdata&quot;.</p>
</td></tr>
<tr><td><code id="find_cover_BB_+3A_nu">nu</code></td>
<td>
<p>Size of the best cover currently found.</p>
</td></tr>
<tr><td><code id="find_cover_BB_+3A_x">X</code></td>
<td>
<p>Partial cover.</p>
</td></tr>
<tr><td><code id="find_cover_BB_+3A_xmin">Xmin</code></td>
<td>
<p>Best cover found so far.</p>
</td></tr>
<tr><td><code id="find_cover_BB_+3A_marks">marks</code></td>
<td>
<p>Mark sequence storing the current state of the
algorithm, see details.</p>
</td></tr>
<tr><td><code id="find_cover_BB_+3A_call">call</code></td>
<td>
<p>Number of recursive calls performed by the algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm traverses a binary tree in which each bifurcation
represents if a vertex is included in or excluded from a
partial cover.  The leaves of the tree represent vertex
subsets; the algorithm checks if at some point the partial
cover cannot become a full cover because of too many uncovered
edges with too few remaining vertices to decide.  In this way,
the exponential complexity is somewhat reduced.  Furthermore,
the vertices are considered in decreasing degree order, as in
the greedy algorithm, so that some cover is found in the early
steps of the algorithm and thus a good upper bound on the
solution can be used to exclude more subsets from being
explored.  The full algorithm has been extracted from the
reference below.
</p>
<p>In this routine, the binary tree search is implemented by
recursive calls (that is, a dynamic programming algorithm).
Although the worst case time complexity is exponential (recall
that the Minimum Vertex Cover Problem is NP-hard), the
approach is fairly efficient for a branch-and-bound technique.
</p>
<p>The tree node in which the algorithm is when it is called (by the
user or by itself) is encoded in a sequence of vertex marks.
Marks come in three flavors: &quot;C&quot; is assigned to &quot;Covered&quot;
vertices, that is, already included in the partial cover.  &quot;U&quot;
is asigned to &quot;Uncovered&quot; vertices, that is, those excluded
from the partial cover.  Mark &quot;F&quot; is assigned to &quot;Free&quot;
vertices, those not considered yet by the algorithm; one of
them is considered in the actual function call, and the
subtree under this vertex is explored before returning.  This
mark sequence starts and ends with all vertices marked &quot;F&quot;,
and is used only by the algorithm, which modifies and passes
it on to succesive calls to itself.
</p>
<p>When the verb argument is TRUE, the routine echoes to the console
the newly found cover only if it is better than the last.
This report includes the size, actual cover and number call of
the routine.
</p>
<p>The routine can drop the best cover found so far in a file so that
the user can stop the run afterwards; this technique might be
useful when the full run takes too much time to complete.
</p>


<h3>Value</h3>

<p>A list with five components: $set contains the subset of
V(g) representing the cover and $size contains the number of
vertices of the cover. Component $call is the number of calls
the algorithm did on itself.  The remaining components are
used to transfer the state of the algorithm in the search
three from one call to the next; they are $partial, the
partially constructed cover, and $marks, a sequence encoding
the tree node in which the algorithm is when this function is
called, see details.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p><a href="#topic+is_cover">is_cover</a> checks if a vertex subset is a vertex cover,
<a href="#topic+build_cover_greedy">build_cover_greedy</a> builds a cover using a greedy heuristic,
<a href="#topic+build_cover_approx">build_cover_approx</a> builds a cover using a 2-approximation
algorithm, <a href="#topic+improve_cover_flip">improve_cover_flip</a> improves a cover using local
search, <a href="#topic+search_cover_random">search_cover_random</a> looks for a random cover of
fixed size, <a href="#topic+search_cover_ants">search_cover_ants</a> looks for a random cover using
a version of the ant-colony optimization heuristic,
<a href="#topic+plot_cover">plot_cover</a> plots a cover.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
g &lt;- sample_gnp(25, p=0.25)        # Random graph
X7 &lt;- find_cover_BB(g)
X7$size                            # Exact result: 16
X7$call                            # 108 recursive calls!
plot_cover(X7, g)

## Saving best result in a file (useful if the algorithm takes too
## long and should be interrupted by the user)
## It uses tempdir() to store the file
## The variable is called "Xbest"
find_cover_BB(g, save.best.result = TRUE, filename.best.result = "BestResult_BB.Rdata")

</code></pre>

<hr>
<h2 id='find_euler'>Constructing an Eulerian Cycle</h2><span id='topic+find_euler'></span>

<h3>Description</h3>

<p>It finds an <strong>Eulerian cycle</strong> using a
<code class="reqn">O(q)</code> algorithm where <code class="reqn">q</code> is the number of edges of
the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_euler(G, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_euler_+3A_g">G</code></td>
<td>
<p>Eulerian and connected graph</p>
</td></tr>
<tr><td><code id="find_euler_+3A_v">v</code></td>
<td>
<p>Any vertex as starting point of the cycle</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Recursive algorithm for undirected graphs.
The input graph should be Eulerian and connected.
</p>


<h3>Value</h3>

<p>A two-element list: the $walk component is a
<code class="reqn">q\times2</code> matrix edgelist, and the $graph component is
the input graph with no edges; it is used in intermediate
steps, when the function calls itself.
</p>


<h3>Disclaimer</h3>

<p>This function is part of the subject &quot;Graphs and Network
Optimization&quot;.  It is designed for teaching purposes only, and
not for production.
</p>

<ul>
<li><p> It is introduced in the &quot;Connectivity&quot; section.
</p>
</li>
<li><p> It is used as a subroutine in the &quot;TSP&quot; section.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Cesar Asensio (2021)
</p>


<h3>References</h3>

<p><em>Korte, Vygen: Combinatorial Optimization (Springer)</em> sec 2.4.
</p>


<h3>See Also</h3>

<p><a href="#topic+build_tour_2tree">build_tour_2tree</a> double-tree algorithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
find_euler(make_full_graph(5), 1)$walk   # Walk of length 10

</code></pre>

<hr>
<h2 id='find_tour_BB'>Branch-and-Bound algorithm for the TSP</h2><span id='topic+find_tour_BB'></span>

<h3>Description</h3>

<p>This routine performs a version of the Branch-and-Bound algorithm
for the Traveling Salesperson Problem (TSP).  It is an exact
algorithm with exponential worst-case running time; therefore,
it can be run only with a very small number of cities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_tour_BB(
  d,
  n,
  verb = FALSE,
  plot = TRUE,
  z = NA,
  tour = rep(0, n),
  distance = 0,
  upper = Inf,
  col = c(1, rep(0, n - 1)),
  last = 1,
  partial = c(1, rep(NA, n - 1)),
  covered = 0,
  call = 0,
  save.best.result = FALSE,
  filename.best.result = "best_result_find_tour_BB.Rdata",
  order = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_tour_BB_+3A_d">d</code></td>
<td>
<p>Distance matrix of the TSP instance</p>
</td></tr>
<tr><td><code id="find_tour_BB_+3A_n">n</code></td>
<td>
<p>Number of vertices of the TSP complete graph</p>
</td></tr>
<tr><td><code id="find_tour_BB_+3A_verb">verb</code></td>
<td>
<p>If detailed operation of the algorithm should be
echoed to the console.  It defaults to FALSE</p>
</td></tr>
<tr><td><code id="find_tour_BB_+3A_plot">plot</code></td>
<td>
<p>If tours found by the algorithm should be plotted
using <a href="#topic+plot_tour">plot_tour</a>.  It defaults to TRUE</p>
</td></tr>
<tr><td><code id="find_tour_BB_+3A_z">z</code></td>
<td>
<p>Points to plot the tours found by the algorithm.  It
defaults to NA; it should be set if plot is TRUE or else
<a href="#topic+plot_tour">plot_tour</a> will not plot the tours</p>
</td></tr>
<tr><td><code id="find_tour_BB_+3A_tour">tour</code></td>
<td>
<p>Best tour found by the algorithm.  If the algorithm
has ended its complete run, this is the optimum of the TSP
instance.  This variable is used to store the internal state
of the algorithm and it should not be set by the user</p>
</td></tr>
<tr><td><code id="find_tour_BB_+3A_distance">distance</code></td>
<td>
<p>Distance covered by the best tour found.  This
variable is used to store the internal state of the algorithm
and it should not be set by the user</p>
</td></tr>
<tr><td><code id="find_tour_BB_+3A_upper">upper</code></td>
<td>
<p>Upper bound on the distance covered by the optimum
tour.  It can be provided by the user or the routine will use
the result found by the heuristic <a href="#topic+build_tour_nn_best">build_tour_nn_best</a></p>
</td></tr>
<tr><td><code id="find_tour_BB_+3A_col">col</code></td>
<td>
<p>Vectors of &quot;colors&quot; of vertices.  This variable is used
to store the internal state of the algorithm and it should not
be set by the user</p>
</td></tr>
<tr><td><code id="find_tour_BB_+3A_last">last</code></td>
<td>
<p>Last vertex added to the tour being built by the
algorithm.  This variable is used to store the internal state
of the algorithm and it should not be set by the user</p>
</td></tr>
<tr><td><code id="find_tour_BB_+3A_partial">partial</code></td>
<td>
<p>Partial tour built by the algorithm.  This variable
is used to store the internal state of the algorithm and it
should not be set by the user</p>
</td></tr>
<tr><td><code id="find_tour_BB_+3A_covered">covered</code></td>
<td>
<p>Partial distance covered by the partial tour built
by the algorithm.  This variable is used to store the internal
state of the algorithm and it should not be set by the user</p>
</td></tr>
<tr><td><code id="find_tour_BB_+3A_call">call</code></td>
<td>
<p>Number of calls that the algorithm performs on itself.
This variable is used to store the internal state of the
algorithm and it should not be set by the user</p>
</td></tr>
<tr><td><code id="find_tour_BB_+3A_save.best.result">save.best.result</code></td>
<td>
<p>The time needed for a complete run of this
algorithm may be exponentially large.  Since it only will
return its results if it ends properly, we can save to a file
the best result found by the routine at a given time when
save.best.result = TRUE (default is FALSE).  Then, the user
will be allowed to stop the run of the algorithm without
losing the (possibly suboptimal) result.</p>
</td></tr>
<tr><td><code id="find_tour_BB_+3A_filename.best.result">filename.best.result</code></td>
<td>
<p>The name of the file used to store the
best result found so far when save.best.result = TRUE.  It
defaults to &quot;best_result_find_tour_BB.Rdata&quot;.  When loaded,
this file will define the best tour in variable &quot;Cbest&quot;.</p>
</td></tr>
<tr><td><code id="find_tour_BB_+3A_order">order</code></td>
<td>
<p>Numeric vector giving the order in which vertices
will be search by the algorithm.  It defaults to NA, in which
case the algorithm will take the order of the tour found by
the heuristic <a href="#topic+build_tour_nn_best">build_tour_nn_best</a>.  If the user knows in
advance some good tour and he/she wishes to use the order of
its vertices, it should be taken into account that the third
vertex used by the algorithm is the last vertex of the tour!</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm starts at city 1 (to avoid the cyclic permutation
tour equivalence) and the &quot;branch&quot; phase consists on the
decision of which city follows next.  In order to avoid the
equivalence between a tour and its reverse, it only considers
those tours for which the second city has a smaller vertex id
that the last.  With <code class="reqn">n</code> cities, the total number of tours
explored in this way is <code class="reqn">(n-1)!/2</code>, which clearly is
infeasible unless <code class="reqn">n</code> is small.  Hence the &quot;bound&quot; phase
estimates a lower bound on the distance covered by the tours
which already are partially constructed.  When this lower
bound grows larger than an upper bound on the optimum supplied
by the user or computed on the fly, the search stops in this
branch and the algorithm proceeds to the next.  This
complexity reduction does not help in the worst case, though.
</p>
<p>This routine represents the tree search by iterating over the
sucessors of the present tree vertex and calling itself when
descending one level.  The leaves of the three are the actual
tours, and the algorithm only reaches those tours whose cost
is less than the upper bound provided.  By default, the
algorithm will plot the tour found if the coordinates of the
cities are supplied in the &quot;z&quot; input argument.
</p>
<p>When the routine takes too much time to complete, interrupting the
run would result in losing the best tour found.  To prevent
this, the routine can store the best tour found so far so that
the user can stop the run afterwards.
</p>


<h3>Value</h3>

<p>A list with nine components: $tour contains a permutation
of the 1:n sequence representing the best tour constructed by
the algorithm, $distance contains the value of the distance
covered by the tour, which if the algorithm has ended properly
will be the optimum distance.  Component $call is the number
of calls the algorithm did on itself.  The remaining
components are used to transfer the state of the algorithm in
the search three from one call to the next; they are $upper
for the current upper bound on the distance covered by the
optimum tour, $col for the &quot;vertex colors&quot; used to mark the
vertices added to the partially constructed tour, which is
stored in $partial.  The distance covered by this partial tour
is stored in $covered, the last vertex added to the partial
tour is stored in $last, and the &quot;save.best.result&quot; and
&quot;filename.best.result&quot; input arguments are stored in
$save.best.result and $filename.best.result.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Random points
set.seed(1)
n &lt;- 10
z &lt;- cbind(runif(n, min=1, max=10), runif(n, min=1, max=10))
d &lt;- compute_distance_matrix(z)
bb &lt;- find_tour_BB(d, n)
bb$distance                        # Optimum 26.05881
plot_tour(z,bb)
## Saving tour to a file (useful when the run takes too long):
## Can be stopped after tour is found
## File is stored in tempdir(), variable is called "Cbest"
find_tour_BB(d, n, save.best.result = TRUE, z = z)

</code></pre>

<hr>
<h2 id='gauge_tour'>Gauging a tour</h2><span id='topic+gauge_tour'></span>

<h3>Description</h3>

<p>Gauging a tour for easy comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gauge_tour(To, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gauge_tour_+3A_to">To</code></td>
<td>
<p>Tour to be gauged, a vector containing a permutation of
the 1:n sequence</p>
</td></tr>
<tr><td><code id="gauge_tour_+3A_n">n</code></td>
<td>
<p>Number of elements of the tour T</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tour of <code class="reqn">n</code> vertices is a permutation of the ordered
sequence 1:<code class="reqn">n</code>, and it is represented as a vector
containing the integers from 1 to <code class="reqn">n</code> in the permuted
sequence.  As a subgraph of the complete graph with <code class="reqn">n</code>
vertices, it is assumed that each vertex is adjacent with the
anterior and posterior ones, with the first and last being
also adjacent.
</p>
<p>With respect to the TSP, a tour is invariant under cyclic
permutation and inversion, so that there exists <code class="reqn">(n-1)!/2</code>
different tours in a complete graph of <code class="reqn">n</code> vertices.  When
searching for tours it is common to find the same tour under a
different representation.  Therefore, we need to establish
wheter two tours are equivalent or not.  To this end, we can
&quot;gauge&quot; the tour by permuting cyclically its elements until
the first vertex is at position 1, and fix the orientation so
that the second vertex is less than the last.  Two equivalent
tours will have the same &quot;gauged&quot; representation.
</p>
<p>This function is used in <a href="#topic+search_tour_genetic">search_tour_genetic</a> to discard repeated
tours which can be found during the execution of the
algorithm.
</p>


<h3>Value</h3>

<p>The gauged tour.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p><a href="#topic+search_tour_genetic">search_tour_genetic</a> implements a version of the genetic
algorithm for the TSP.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2)
T0 &lt;- sample(1:9,9)   #        T0 = 2 6 5 9 7 4 1 8 3
gauge_tour(T0, 9)     # gauged T0 = 1 4 7 9 5 6 2 3 8

</code></pre>

<hr>
<h2 id='generate_fundamental_cycles'>Generate fundamental cycles in a connected graph</h2><span id='topic+generate_fundamental_cycles'></span>

<h3>Description</h3>

<p>Generation of a system of fundamental cycles in a connected graph
with respect of a given spanning tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_fundamental_cycles(eT, eG)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_fundamental_cycles_+3A_et">eT</code></td>
<td>
<p>Spanning tree of the graph in edgelist representation,
see <a href="igraph.html#topic+as_edgelist">as_edgelist</a>.</p>
</td></tr>
<tr><td><code id="generate_fundamental_cycles_+3A_eg">eG</code></td>
<td>
<p>Graph in edgelist representation, see <a href="igraph.html#topic+as_edgelist">as_edgelist</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The routine loops through the edges of the graph outside the
spanning tree (there are |E| - |V| + 1 of them); in each step,
it adds an edge to the tree, thus closing a cycle, which has
some &quot;hair&quot; in it in the form of dangling vertices.  Then all
those dangling vertices are removed from the cycle (the &quot;hair&quot;
is &quot;shaven&quot;).
</p>


<h3>Value</h3>

<p>A matrix with the fundamental cycles in its rows, in edge
vector representation, that is, a binary vector with 1 if the
edge belongs to the cycle and 0 otherwise.  This interpretation
of the edge vectors of each fundamental cycle refers to the
edgelist of the graph given in eG.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p><a href="#topic+shave_cycle">shave_cycle</a> shaves hairy cycles, <a href="#topic+apply_incidence_map">apply_incidence_map</a>
applies the incidence map of a graph to an edge vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_graph("Dodecahedron")
n &lt;- gorder(g)
b &lt;- bfs(g, 1, father = TRUE)                 # BFS tree
T &lt;- make_graph(rbind(b$father[2:n], 2:n), n) # Tree as igraph graph
eT &lt;- as_edgelist(T)
eG &lt;- as_edgelist(g)
C &lt;- generate_fundamental_cycles(eT, eG)      # Fundamental cycles
mu &lt;- gsize(g) - gorder(g) + 1                # Cyclomatic number
z &lt;- layout_with_gem(g)
for (i in 1:mu) {                             # Cycle drawing
    c1 &lt;- make_graph(t(eG[which(C[i,] == 1),]) , dir = FALSE)
    plot(g, layout = z)
    plot(c1, layout = z, add = TRUE, edge.color = "cyan4",
         edge.lty = "dashed", edge.width = 3)
    title(paste0("Cycle ", i, " of ", mu))
    #Sys.sleep(1) # Adjust time to see the cycles
}

</code></pre>

<hr>
<h2 id='gor'>Graphs and Network Optimization algorithms</h2><span id='topic+gor'></span>

<h3>Description</h3>

<p>This is a hardly complete collection of algorithms
from the subject &quot;Graphs and Network Optimization&quot;.
</p>


<h3>Details</h3>

<p>Functions in this package have been written for teaching
purposes.  Therefore, no attempt at production versions of the
algorithms has been made.  They are neither complete nor
completely correct, although a great effort has been invested
in their construction and debugging.  All of them pass a
series of tests given in the examples sections of the
corresponding help pages.  Comments and suggestions are
welcome, even if I cannot guarantee that they will be
incorporated to the package.
</p>
<p>This package makes extensive use of the <a href="igraph.html#topic+igraph">igraph</a> package
functions, which should be loaded before using &quot;gor&quot;.
</p>
<p>Some functions in this package perform tasks which can be found in
other well-tested packages such as <a href="igraph.html#topic+igraph">igraph</a> or TSP.  As said
before, these functions have been written with teaching in
mind, and I do not claim that <a href="#topic+gor">gor</a> functions are better than
any other in any way whatsoever.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio (2021-2023)
</p>

<hr>
<h2 id='improve_cover_flip'>Improving a cover with local search</h2><span id='topic+improve_cover_flip'></span>

<h3>Description</h3>

<p>Local search to improve a cover by using &quot;neighboring&quot; vertex
subsets differing in just one element from the initial subset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>improve_cover_flip(G, X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="improve_cover_flip_+3A_g">G</code></td>
<td>
<p>A graph</p>
</td></tr>
<tr><td><code id="improve_cover_flip_+3A_x">X</code></td>
<td>
<p>A cover list with components $set, $size as returned by
routines <a href="#topic+build_cover_greedy">build_cover_greedy</a> or <a href="#topic+build_cover_approx">build_cover_approx</a>.  X
represents the cover to be improved</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given some cover specified by a vertex subset X in a graph, this
routine scans the neighboring subsets obtained from X by
removing a vertex from X looking for a smaller cover.  If such
a cover is found, it replaces the starting cover and the
search starts again.  This iterative procedure continues until
no smaller cover can be found.  Of course, the resulting cover
is only a local minimum.
</p>


<h3>Value</h3>

<p>A list with two components: $set contains the subset of
V(g) representing the cover and $size contains the number of
vertices of the cover.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p><a href="#topic+is_cover">is_cover</a> checks if a vertex subset is a vertex cover,
<a href="#topic+build_cover_greedy">build_cover_greedy</a> builds a cover using a greedy heuristic,
<a href="#topic+build_cover_approx">build_cover_approx</a> builds a cover using a 2-approximation
algorithm, <a href="#topic+search_cover_random">search_cover_random</a> looks for a random cover of
fixed size, <a href="#topic+search_cover_ants">search_cover_ants</a> looks for a random cover using
a version of the ant-colony optimization heuristic,
<a href="#topic+find_cover_BB">find_cover_BB</a> finds covers using a branch-and-bound
technique, <a href="#topic+plot_cover">plot_cover</a> plots a cover.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n &lt;- 25
g &lt;- sample_gnp(n, p=0.25)  # Random graph

X1 &lt;- build_cover_greedy(g)
X1$size    # 17
plot_cover(X1, g)

X2 &lt;- build_cover_approx(g)
X2$size    # 20
plot_cover(X2, g)

X3 &lt;- improve_cover_flip(g, X1)
X3$size    # 17 : Not improved
plot_cover(X3,g)

X4 &lt;- improve_cover_flip(g, X2)
X4$size    # 19 : It is improved by a single vertex
plot_cover(X4,g)

# Vertex subsets or n-1 elements are always vertex covers:
for (i in 1:25) {
   X3 &lt;- improve_cover_flip(g, list(set = setdiff(1:25,i), size = 24))
   print(X3$size)
} # 19 18 18 18 18 18 17 20 19 17 17 18 18 18 17 19 20 19 19 17 19 19 19 19 19
 
</code></pre>

<hr>
<h2 id='improve_cut_flip'>Improving a cut with local search</h2><span id='topic+improve_cut_flip'></span>

<h3>Description</h3>

<p>Local search to improve a cut by using &quot;neighboring&quot; vertex
subsets differing in just one element from the initial subset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>improve_cut_flip(G, K, w = NA, return.cut = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="improve_cut_flip_+3A_g">G</code></td>
<td>
<p>A graph</p>
</td></tr>
<tr><td><code id="improve_cut_flip_+3A_k">K</code></td>
<td>
<p>A cut list with components $set, $size, $weight and $cut
as returned by routines <a href="#topic+build_cut_greedy">build_cut_greedy</a>, <a href="#topic+build_cut_random">build_cut_random</a>
or <a href="#topic+compute_cut_weight">compute_cut_weight</a>.  Only the $set and $weight components
are used.  K represents the cut to be improved</p>
</td></tr>
<tr><td><code id="improve_cut_flip_+3A_w">w</code></td>
<td>
<p>Weight matrix (defaults to NA).  It should be zero for
those edges not in G</p>
</td></tr>
<tr><td><code id="improve_cut_flip_+3A_return.cut">return.cut</code></td>
<td>
<p>Boolean.  Should the routine return the cut?  It
is passed on to <a href="#topic+compute_cut_weight">compute_cut_weight</a> on return.  It defaults
to TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given some cut specified by a vertex subset S in a graph, this
routine scans the neighboring subsets obtained from S by
adding/removing a vertex from S looking for a larger cut.  If
such a cut is found, it replaces the starting cut and the
search starts again.  This iterative procedure continues until
no larger cut can be found.  Of course, the resulting cut is
only a local maximum.
</p>


<h3>Value</h3>

<p>A list with four components: $set contains the subset of
V(g) representing the cut, $size contains the number of edges
of the cut, $weight contains the weight of the cut (which
coincides with $size if w is NA) and $cut contains the edges
of the cut, joining vertices inside $set with vertices outside
$set.  When return.cut is FALSE, components $set and $cut are
omitted.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p><a href="#topic+build_cut_random">build_cut_random</a> builds a random cut,
<a href="#topic+build_cut_greedy">build_cut_greedy</a> builds a cut using a greedy algorithm,
<a href="#topic+compute_cut_weight">compute_cut_weight</a> computes cut size, weight and edges,
<a href="#topic+plot_cut">plot_cut</a> plots a cut.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n &lt;- 25
g &lt;- sample_gnp(n, p=0.25)  # Random graph

c1 &lt;- build_cut_random(g)
c1$size    # 44
plot_cut(c1, g)

c2 &lt;- build_cut_greedy(g)
c2$size    # 59
plot_cut(c2, g)

c3 &lt;- improve_cut_flip(g, c1)
c3$size    # 65
plot_cut(c3,g)

c4 &lt;- improve_cut_flip(g, c2)
c4$size    # 60
plot_cut(c4,g)

</code></pre>

<hr>
<h2 id='improve_tour_2opt'>Tour improving for a TSP using the 2-opt heuristic</h2><span id='topic+improve_tour_2opt'></span>

<h3>Description</h3>

<p>2-opt heuristic tour-improving algorithm for the Traveling
Salesperson Problem
</p>


<h3>Usage</h3>

<pre><code class='language-R'>improve_tour_2opt(d, n, C)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="improve_tour_2opt_+3A_d">d</code></td>
<td>
<p>Distance matrix of the TSP.</p>
</td></tr>
<tr><td><code id="improve_tour_2opt_+3A_n">n</code></td>
<td>
<p>Number of vertices of the TSP complete graph.</p>
</td></tr>
<tr><td><code id="improve_tour_2opt_+3A_c">C</code></td>
<td>
<p>Starting tour to be improved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It applies the 2-opt algorithm to a starting tour of a TSP
instance until no further improvement can be found.  The tour
thus improved is a 2-opt local minimum.
</p>
<p>The 2-opt algorithm consists of applying all possible
2-interchanges on the starting tour.  Informally, a
2-interchange is the operation of cutting the tour in two
pieces (by removing two nonincident edges) and gluing the
pieces together to form a new tour by interchanging the
endpoints.
</p>


<h3>Value</h3>

<p>A list with two components: $tour contains a permutation
of the 1:n sequence representing the tour constructed by the
algorithm, $distance contains the value of the distance
covered by the tour.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p><a href="#topic+improve_tour_3opt">improve_tour_3opt</a> improves a tour using the 3-opt
algorithm, <a href="#topic+build_tour_nn_best">build_tour_nn_best</a> nearest neighbor heuristic,
<a href="#topic+build_tour_2tree">build_tour_2tree</a> double-tree heuristic,
<a href="#topic+compute_tour_distance">compute_tour_distance</a> computes tour distances,
<a href="#topic+compute_distance_matrix">compute_distance_matrix</a> computes a distance matrix,
<a href="#topic+plot_tour">plot_tour</a> plots a tour.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Regular example with obvious solution (minimum distance 48)
m &lt;- 10   # Generate some points in the plane
z &lt;- cbind(c(rep(0,m), rep(2,m), rep(5,m), rep(7,m)), rep(seq(0,m-1),4))
n &lt;- nrow(z)
d &lt;- compute_distance_matrix(z)
b &lt;- build_tour_2tree(d, n)
b$distance    # Distance 57.868
bi &lt;- improve_tour_2opt(d, n, b$tour)
bi$distance   # Distance 48 (optimum)
plot_tour(z,b)
plot_tour(z,bi)

## Random points
set.seed(1)
n &lt;- 25
z &lt;- cbind(runif(n,min=1,max=10),runif(n,min=1,max=10))
d &lt;- compute_distance_matrix(z)
b &lt;- build_tour_2tree(d, n)
b$distance    # Distance 48.639
bi &lt;- improve_tour_2opt(d, n, b$tour)
bi$distance   # Distance 37.351
plot_tour(z,b)
plot_tour(z,bi)

</code></pre>

<hr>
<h2 id='improve_tour_3opt'>Tour improving for a TSP using the 3-opt heuristic</h2><span id='topic+improve_tour_3opt'></span>

<h3>Description</h3>

<p>3-opt heuristic tour-improving algorithm for the Traveling
Salesperson Problem
</p>


<h3>Usage</h3>

<pre><code class='language-R'>improve_tour_3opt(d, n, C)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="improve_tour_3opt_+3A_d">d</code></td>
<td>
<p>Distance matrix of the TSP.</p>
</td></tr>
<tr><td><code id="improve_tour_3opt_+3A_n">n</code></td>
<td>
<p>Number of vertices of the TSP complete graph.</p>
</td></tr>
<tr><td><code id="improve_tour_3opt_+3A_c">C</code></td>
<td>
<p>Starting tour to be improved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It applies the 3-opt algorithm to a starting tour of a TSP
instance until no further improvement can be found.  The tour
thus improved is a 3-opt local minimum.
</p>
<p>The 3-opt algorithm consists of applying all possible
3-interchanges on the starting tour.  A 3-interchange removes
three non-indicent edges from the tour, leaving three pieces,
and combine them to form a new tour by interchanging the
endpoints in all possible ways and gluing them together by
adding the missing edges.
</p>


<h3>Value</h3>

<p>A list with two components: $tour contains a permutation
of the 1:n sequence representing the tour constructed by the
algorithm, $distance contains the value of the distance
covered by the tour.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p><a href="#topic+improve_tour_2opt">improve_tour_2opt</a> improves a tour using the 2-opt
algorithm, <a href="#topic+build_tour_nn_best">build_tour_nn_best</a> nearest neighbor heuristic,
<a href="#topic+build_tour_2tree">build_tour_2tree</a> double-tree heuristic,
<a href="#topic+compute_tour_distance">compute_tour_distance</a> computes tour distances,
<a href="#topic+compute_distance_matrix">compute_distance_matrix</a> computes a distance matrix,
<a href="#topic+plot_tour">plot_tour</a> plots a tour.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Regular example with obvious solution (minimum distance 32)
m &lt;- 6   # Generate some points in the plane
z &lt;- cbind(c(rep(0,m), rep(2,m), rep(5,m), rep(7,m)), rep(seq(0,m-1),4))
n &lt;- nrow(z)
d &lt;- compute_distance_matrix(z)
b &lt;- build_tour_2tree(d, n)
b$distance    # Distance 38.43328
bi &lt;- improve_tour_3opt(d, n, b$tour)
bi$distance   # Distance 32 (optimum)
plot_tour(z,b)
plot_tour(z,bi)

## Random points
set.seed(1)
n &lt;- 15
z &lt;- cbind(runif(n,min=1,max=10),runif(n,min=1,max=10))
d &lt;- compute_distance_matrix(z)
b &lt;- build_tour_2tree(d, n)
b$distance    # Distance 45.788
bi &lt;- improve_tour_3opt(d, n, b$tour)
bi$distance   # Distance 32.48669
plot_tour(z,b)
plot_tour(z,bi)

</code></pre>

<hr>
<h2 id='improve_tour_LinKer'>Tour improving for a TSP using a poor version of the Lin-Kernighan heuristic</h2><span id='topic+improve_tour_LinKer'></span>

<h3>Description</h3>

<p>Lin-Kernighan heuristic tour-improving algorithm for the Traveling
Salesperson Problem using fixed 2-opt instead of variable
k-opt exchanges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>improve_tour_LinKer(d, n, C, try = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="improve_tour_LinKer_+3A_d">d</code></td>
<td>
<p>Distance matrix of the TSP.</p>
</td></tr>
<tr><td><code id="improve_tour_LinKer_+3A_n">n</code></td>
<td>
<p>Number of vertices of the TSP complete graph.</p>
</td></tr>
<tr><td><code id="improve_tour_LinKer_+3A_c">C</code></td>
<td>
<p>Starting tour to be improved.</p>
</td></tr>
<tr><td><code id="improve_tour_LinKer_+3A_try">try</code></td>
<td>
<p>Number of tries before quitting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It applies a version of the core Lin-Kernighan algorithm to a
starting tour of a TSP instance until no further improvement
can be found.  The tour thus improved is a local minimum.
</p>
<p>The Lin-Kernighan algorithm implemented here is based on the core
routine described in the reference below.  It is provided here
as an example of a local search routine which can be embedded
in larger search strategies.  However, instead of using
variable k-opt moves to improve the tour, it uses 2-exhanges
only, which is far easier to program.  Tours improved with
this technique are of course 2-opt.
</p>
<p>The TSP library provides an interface to the Lin-Kernighan
algorithm with all its available improvements in the external
program Concorde, which should be installed separately.
</p>


<h3>Value</h3>

<p>A list with two components: $tour contains a permutation
of the 1:n sequence representing the tour constructed by the
algorithm, $distance contains the value of the distance
covered by the tour.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>References</h3>

<p>Hromkovic <em>Algorithmics for Hard Problems</em> (2004)
</p>


<h3>See Also</h3>

<p><a href="#topic+improve_tour_2opt">improve_tour_2opt</a> improves a tour using the 2-opt
algorithm, <a href="#topic+improve_tour_3opt">improve_tour_3opt</a> improves a tour using the 3-opt
algorithm, <a href="#topic+build_tour_nn_best">build_tour_nn_best</a> nearest neighbor heuristic,
<a href="#topic+build_tour_2tree">build_tour_2tree</a> double-tree heuristic,
<a href="#topic+compute_tour_distance">compute_tour_distance</a> computes tour distances,
<a href="#topic+compute_distance_matrix">compute_distance_matrix</a> computes a distance matrix,
<a href="#topic+plot_tour">plot_tour</a> plots a tour.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Regular example with obvious solution (minimum distance 48)
m &lt;- 10   # Generate some points in the plane
z &lt;- cbind(c(rep(0,m), rep(2,m), rep(5,m), rep(7,m)), rep(seq(0,m-1),4))
n &lt;- nrow(z)
d &lt;- compute_distance_matrix(z)
b &lt;- build_tour_2tree(d, n)
b$distance    # Distance 57.868
bi &lt;- improve_tour_LinKer(d, n, b$tour)
bi$distance   # Distance 48 (optimum)
plot_tour(z,b)
plot_tour(z,bi)

## Random points
set.seed(1)
n &lt;- 25
z &lt;- cbind(runif(n,min=1,max=10),runif(n,min=1,max=10))
d &lt;- compute_distance_matrix(z)
b &lt;- build_tour_2tree(d, n)
b$distance    # Distance 48.639
bi &lt;- improve_tour_LinKer(d, n, b$tour)
bi$distance   # Distance 37.351 (2-opt)
plot_tour(z,b)
plot_tour(z,bi)

</code></pre>

<hr>
<h2 id='is_cover'>Check vertex cover</h2><span id='topic+is_cover'></span>

<h3>Description</h3>

<p>Check if some vertex subset of a graph covers all its edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_cover(X, eG)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_cover_+3A_x">X</code></td>
<td>
<p>Vertex subset to check.</p>
</td></tr>
<tr><td><code id="is_cover_+3A_eg">eG</code></td>
<td>
<p>Edgelist of the graph as returned by <a href="igraph.html#topic+as_edgelist">as_edgelist</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The routine simply goes through the edge list of the graph to see
if both ends of each edge are inside the vertex subset to be
checked.  When an edge with both ends ouside X is
encountered, the routine returns FALSE; otherwise, it returns
TRUE.
</p>


<h3>Value</h3>

<p>Boolean: TRUE if X is a vertex cover of the graph
represented by eG, FALSE otherwise.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p><a href="#topic+build_cover_greedy">build_cover_greedy</a> builds a cover using a greedy heuristic,
<a href="#topic+build_cover_approx">build_cover_approx</a> builds a cover using a 2-approximation
algorithm, <a href="#topic+improve_cover_flip">improve_cover_flip</a> improves a cover using local
search, <a href="#topic+search_cover_random">search_cover_random</a> looks for a random cover of
fixed size, <a href="#topic+search_cover_ants">search_cover_ants</a> looks for a random cover using
a version of the ant-colony optimization heuristic,
<a href="#topic+find_cover_BB">find_cover_BB</a> finds covers using a branch-and-bound
technique, <a href="#topic+plot_cover">plot_cover</a> plots a cover.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n &lt;- 25
g &lt;- sample_gnp(n, p=0.25)  # Random graph
eg &lt;- as_edgelist(g)

X1 &lt;- build_cover_greedy(g)
is_cover(X1$set, eg)   # TRUE
is_cover(c(1:10),eg)   # FALSE
plot_cover(list(set = 1:10, size = 10), g)  # See uncovered edges

</code></pre>

<hr>
<h2 id='mutate_binary_sequence'>Binary sequence mutation</h2><span id='topic+mutate_binary_sequence'></span>

<h3>Description</h3>

<p>Mutation of binary sequences for use in the genetic algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutate_binary_sequence(s, p = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutate_binary_sequence_+3A_s">s</code></td>
<td>
<p>Sequence consisting of 0 and 1</p>
</td></tr>
<tr><td><code id="mutate_binary_sequence_+3A_p">p</code></td>
<td>
<p>Mutation probability.  Defaults to 0.1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine takes a binary sequence and it flips (&quot;mutates&quot;) each
bit with a fixed probability.  In the genetic algorithm
context, this operation randomly explores regions of
configuration space which are far away from the starting
point, thus trying to avoid local optima.  The fitting
function values of mutated individuals are generically very
poor, and this behavior is to be expected.  Thus, mutation is
not an optimization procedure per se.
</p>


<h3>Value</h3>

<p>A mutated binary sequence
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p><a href="#topic+search_cut_genetic">search_cut_genetic</a> genetic cut-searching algorithm,
<a href="#topic+crossover_sequences">crossover_sequences</a> crossover operation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
s &lt;- sample(0:1, 10, replace = TRUE)  # 0 0 1 1 0 1 1 1 1 0
mutate_binary_sequence(s, p = 0.5)    # 1 1 1 0 0 0 1 1 0 0
mutate_binary_sequence(s, p = 1)      # 1 1 0 0 1 0 0 0 0 1

</code></pre>

<hr>
<h2 id='neigh_index'>Previous, current, and next positions of a given index in a
cycle.</h2><span id='topic+neigh_index'></span>

<h3>Description</h3>

<p>Previous, current, and next positions of a given index in a cycle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neigh_index(i, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neigh_index_+3A_i">i</code></td>
<td>
<p>Position in a cycle</p>
</td></tr>
<tr><td><code id="neigh_index_+3A_n">n</code></td>
<td>
<p>Lenght of the cycle</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given some position i in a n-lenght cycle, this function returns
the triple c(i-1,i,i+1) taking into account that the next
position of i=n is 1 and the previous position of i=1 is n.
It is used to perform a 4-exchange in a cycle.
</p>


<h3>Value</h3>

<p>A three component vector c(previous, current, next)
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>Examples</h3>

<pre><code class='language-R'>neigh_index(6, 9)  # 5 6 7
neigh_index(9, 9)  # 8 9 1
neigh_index(1, 9)  # 9 1 2

</code></pre>

<hr>
<h2 id='next_index'>Next position to i in a cycle</h2><span id='topic+next_index'></span>

<h3>Description</h3>

<p>Next position to i in a cycle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>next_index(i, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="next_index_+3A_i">i</code></td>
<td>
<p>Position in cycle</p>
</td></tr>
<tr><td><code id="next_index_+3A_n">n</code></td>
<td>
<p>Lenght of cycle</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a cycle, the next slot to the i-th position is i+1 unless i=n.
In this case, the next is 1.
</p>


<h3>Value</h3>

<p>The next position in cycle
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>Examples</h3>

<pre><code class='language-R'>next_index(5, 7)   # 6
next_index(7, 7)   # 1

</code></pre>

<hr>
<h2 id='perturb_tour_4exc'>Random 4-exchange transformation</h2><span id='topic+perturb_tour_4exc'></span>

<h3>Description</h3>

<p>It performs a random 4-exchange transformation to a cycle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perturb_tour_4exc(C, V, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perturb_tour_4exc_+3A_c">C</code></td>
<td>
<p>Cycle to be 4-exchanged</p>
</td></tr>
<tr><td><code id="perturb_tour_4exc_+3A_v">V</code></td>
<td>
<p>1:n list, positions to draw from</p>
</td></tr>
<tr><td><code id="perturb_tour_4exc_+3A_n">n</code></td>
<td>
<p>Number of vertices of the cycle</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The transformation is carried out by randomly selecting four
non-mutually incident edges from the cycle.  Upon eliminating
these four edges, we obtain four pieces ci of the original
cycle.  The 4-exchanged cycle is c1, c4, c3, c2.  This is a
typical 4-exchange which cannot be constructed using
2-exchanges and therefore it is used by local search routines
as an escape from 2-opt local minima.
</p>


<h3>Value</h3>

<p>The 4-exchanged cycle.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
perturb_tour_4exc(1:9, 1:9, 9)   # 2 3 9 1 7 8 4 5 6

</code></pre>

<hr>
<h2 id='plot_cover'>Vertex cover plotting</h2><span id='topic+plot_cover'></span>

<h3>Description</h3>

<p>Plot of a vertex cover in a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_cover(X, G)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_cover_+3A_x">X</code></td>
<td>
<p>Cover to be plotted; an output list returned by some
cover-building function, see below.</p>
</td></tr>
<tr><td><code id="plot_cover_+3A_g">G</code></td>
<td>
<p>Graph on which to superimpose the cover.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It plots a graph, then superimposes a vertex cover in a different
color.  It also draws the covered edges, to help in detecting
non-covers by inspection.
</p>


<h3>Value</h3>

<p>This function is called for its side effect of plotting.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p><a href="#topic+is_cover">is_cover</a> checks if a vertex subset is a vertex cover,
<a href="#topic+build_cover_greedy">build_cover_greedy</a> builds a cover using a greedy heuristic,
<a href="#topic+build_cover_approx">build_cover_approx</a> builds a cover using a 2-approximation
algorithm, <a href="#topic+improve_cover_flip">improve_cover_flip</a> improves a cover using local
search, <a href="#topic+search_cover_random">search_cover_random</a> looks for a random cover of
fixed size, <a href="#topic+search_cover_ants">search_cover_ants</a> looks for a random cover using
a version of the ant-colony optimization heuristic,
<a href="#topic+find_cover_BB">find_cover_BB</a> finds covers using a branch-and-bound
technique.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
g &lt;- sample_gnp(25, p=0.25)   # Random graph
X1 &lt;- build_cover_greedy(g)
plot_cover(X1, g)

st &lt;- 1:5   # Not a vertex cover
plot_cover(list(set = st, size = length(st)), g)  # See covered edges

</code></pre>

<hr>
<h2 id='plot_cut'>Cut plotting</h2><span id='topic+plot_cut'></span>

<h3>Description</h3>

<p>Plot of a cut in a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_cut(K, G)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_cut_+3A_k">K</code></td>
<td>
<p>Cut to be plotted; an output list returned by some
cut-building function, see below.</p>
</td></tr>
<tr><td><code id="plot_cut_+3A_g">G</code></td>
<td>
<p>Graph on which to superimpose the cut.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It plots a graph, then superimposes a cut, drawing the associated
vertex set in a different color.
</p>


<h3>Value</h3>

<p>This function is called for its side effect of plotting.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p><a href="#topic+build_cut_random">build_cut_random</a> builds a random cut,
<a href="#topic+build_cut_greedy">build_cut_greedy</a> builds a cut using a greedy algorithm,
<a href="#topic+improve_cut_flip">improve_cut_flip</a> uses local search to improve a cut obtained
by other methods, <a href="#topic+compute_cut_weight">compute_cut_weight</a> computes cut size,
weight and edges.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>K10 &lt;- make_full_graph(10)   # Max cut of size 25
c0 &lt;- build_cut_random(K10)
plot_cut(c0, K10)

</code></pre>

<hr>
<h2 id='plot_tour'>TSP tour simple plotting</h2><span id='topic+plot_tour'></span>

<h3>Description</h3>

<p>Plotting tours constructed by tour-building routines for TSP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_tour(z, h, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_tour_+3A_z">z</code></td>
<td>
<p>Set of points of a TSP</p>
</td></tr>
<tr><td><code id="plot_tour_+3A_h">h</code></td>
<td>
<p>List with $tour and $distance components returned from a
TSP tour building algorithm</p>
</td></tr>
<tr><td><code id="plot_tour_+3A_...">...</code></td>
<td>
<p>Parameters to be passed to <a href="graphics.html#topic+plot">plot</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>It plots the two-dimensional cities of a TSP and a tour among them
for visualization purposes.  No aesthetically appealing effort
has been invested in this function.
</p>


<h3>Value</h3>

<p>This function is called by its side effect.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p><a href="#topic+build_tour_nn">build_tour_nn</a> nearest neighbor heuristic with a single
starting point, <a href="#topic+build_tour_nn_best">build_tour_nn_best</a> repeats the previous
algorithm with all possible starting points,
<a href="#topic+compute_distance_matrix">compute_distance_matrix</a> computes the distance matrix of a
set of two-dimensional points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n &lt;- 25
z &lt;- cbind(runif(n,min=1,max=10),runif(n,min=1,max=10))
d &lt;- compute_distance_matrix(z)
b &lt;- build_tour_nn_best(d, n)
plot_tour(z,b)

</code></pre>

<hr>
<h2 id='search_cover_ants'>Ant colony optimization algorithm for Vertex-Cover</h2><span id='topic+search_cover_ants'></span>

<h3>Description</h3>

<p>Ant colony optimization (ACO) heuristic algorithm to search for a
vertex cover of small size in a graph.  ACO is a random
algorithm; as such, it yields better results when longer
searches are run.  To guess the adequate parameter values
resulting in better performance in particular instances
requires some experimentation, since no universal values of
the parameters seem to be appropriate to all examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_cover_ants(g, K, N, alpha = 2, beta = 2, dt = 1, rho = 0.1, verb = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_cover_ants_+3A_g">g</code></td>
<td>
<p>Graph.</p>
</td></tr>
<tr><td><code id="search_cover_ants_+3A_k">K</code></td>
<td>
<p>Number of ants per iteration.</p>
</td></tr>
<tr><td><code id="search_cover_ants_+3A_n">N</code></td>
<td>
<p>Number of iterations.</p>
</td></tr>
<tr><td><code id="search_cover_ants_+3A_alpha">alpha</code></td>
<td>
<p>Exponent of the pheronome index, see details.</p>
</td></tr>
<tr><td><code id="search_cover_ants_+3A_beta">beta</code></td>
<td>
<p>Exponent of the vertex degree, see details.</p>
</td></tr>
<tr><td><code id="search_cover_ants_+3A_dt">dt</code></td>
<td>
<p>Pheromone increment.</p>
</td></tr>
<tr><td><code id="search_cover_ants_+3A_rho">rho</code></td>
<td>
<p>Pheromone evaporation rate.</p>
</td></tr>
<tr><td><code id="search_cover_ants_+3A_verb">verb</code></td>
<td>
<p>Boolean; if TRUE (default) it echoes to the console
the routine progress .</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ACO is an optimization paradigm that tries to replicate the
behavior of a colony of ants when looking for food.  Ants
leave after them a soft pheromone trail to help others follow
the path just in case some food has been found.  Pheromones
evaporate, but following again the trail reinforces it, making
it easier to find and follow.  Thus, a team of ants search a
vertex cover in a graph, leaving a pheromone trail on the
chosen vertices.  At each step, each ant decides the next
vertex to add based on the pheromone level and on the degree
of the remaining vertices, according to the formula <code class="reqn">P(v)
    ~ phi(v)^alpha*exp(beta*d(v))</code>, where <code class="reqn">phi(v)</code> is the
pheromone level, <code class="reqn">d(v)</code> is the degree of the vertex
<code class="reqn">v</code>, and <code class="reqn">alpha</code>, <code class="reqn">beta</code> are two exponents to
broad or sharpen the probability distribution.  After each
vertex has been added to the subset, its incident adges are
removed, following a randomized version of the greedy
heuristic.  In a single iteration, each ant builds a vertex
cover, and the best of them is recorded.  Then the pheromone
level of the vertices of the best cover are enhanced, and the
remaining pheromones begin to evaporate.
</p>
<p>Default parameter values have been chosen in order to find the
optimum in the examples considered below.  However, it cannot
be guarateed that this is the best choice for all cases.  Keep
in mind that no polynomial time exact algorithm can exist for
the VCP, and thus harder instances will require to fine-tune
the parameters.  In any case, no guarantee of optimality of
covers found by this method can be given, so they might be
improved further by other methods.
</p>


<h3>Value</h3>

<p>A list with three components: $set contains the subset of
V(g) representing the cover and $size contains the number of
vertices of the cover; $found is the number of vertex covers
found in subsequent iterations (often they are repeated, that
is, different explorations may find the same vertex cover).
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p><a href="#topic+is_cover">is_cover</a> checks if a vertex subset is a vertex cover,
<a href="#topic+build_cover_greedy">build_cover_greedy</a> builds a cover using a greedy heuristic,
<a href="#topic+build_cover_approx">build_cover_approx</a> builds a cover using a 2-approximation
algorithm, <a href="#topic+improve_cover_flip">improve_cover_flip</a> improves a cover using local
search, <a href="#topic+search_cover_random">search_cover_random</a> looks for a random cover of
fixed size, <a href="#topic+find_cover_BB">find_cover_BB</a> finds covers using a
branch-and-bound technique, <a href="#topic+plot_cover">plot_cover</a> plots covers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
g &lt;- sample_gnp(25, p=0.25)                  # Random graph

X6 &lt;- search_cover_ants(g, K = 20, N = 10)
plot_cover(X6, g)
X6$found

</code></pre>

<hr>
<h2 id='search_cover_random'>Random vertex covers</h2><span id='topic+search_cover_random'></span>

<h3>Description</h3>

<p>Random algorithm for vertex-cover.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_cover_random(G, N, k, alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_cover_random_+3A_g">G</code></td>
<td>
<p>Graph.</p>
</td></tr>
<tr><td><code id="search_cover_random_+3A_n">N</code></td>
<td>
<p>Number of random vertex set to try.</p>
</td></tr>
<tr><td><code id="search_cover_random_+3A_k">k</code></td>
<td>
<p>Cardinality of the random vertex sets generated by the
algorithm.</p>
</td></tr>
<tr><td><code id="search_cover_random_+3A_alpha">alpha</code></td>
<td>
<p>Exponent of the probability distribution from which
vertices are drawn: P(v) ~ d(v)^alpha.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine performs N iterations of the simple procedure of
selecting a random sample of size k on the vertex set of a
graph and check if it is a vertex cover, counting successes
and failures.  The last cover found is returned, or an empty
set if none is found.
</p>


<h3>Value</h3>

<p>A list with four components: $set contains the subset of
V(g) representing the cover and $size contains the number of
vertices of the cover (it coincides with k).  $found is the
number of vertex covers found and $failed is the number of
generated subset that were not vertex covers.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p><a href="#topic+is_cover">is_cover</a> checks if a vertex subset is a vertex cover,
<a href="#topic+build_cover_greedy">build_cover_greedy</a> builds a cover using a greedy heuristic,
<a href="#topic+build_cover_approx">build_cover_approx</a> builds a cover using a 2-approximation
algorithm, <a href="#topic+improve_cover_flip">improve_cover_flip</a> improves a cover using local
search, <a href="#topic+search_cover_ants">search_cover_ants</a> looks for a random cover using a
version of the ant-colony optimization heuristic,
<a href="#topic+find_cover_BB">find_cover_BB</a> finds covers using a branch-and-bound
technique, <a href="#topic+plot_cover">plot_cover</a> plots a cover.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n &lt;- 25
g &lt;- sample_gnp(n, p=0.25)  # Random graph
X7 &lt;- search_cover_random(g, 10000, 17, alpha = 3)
plot_cover(X7, g)
X7$found    # 21 (of 10000) covers of size 17

## Looking for a cover of size 16...
X8 &lt;- search_cover_random(g, 10000, 16, alpha = 3)  # ...we don't find any!
plot_cover(X8, g)   # All edges uncovered
X8$found    # 0

</code></pre>

<hr>
<h2 id='search_cut_genetic'>Genetic Algorithm for Max-Cut</h2><span id='topic+search_cut_genetic'></span>

<h3>Description</h3>

<p>Genetic algorithm for Max-Cut.  In addition to crossover and
mutation, which are described below, the algorithm performs
also local search on offsprings and mutants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_cut_genetic(
  G,
  w = NA,
  Npop = 5,
  Ngen = 20,
  pmut = 0.1,
  beta = 1,
  elite = 2,
  Pini = NA,
  verb = TRUE,
  log = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_cut_genetic_+3A_g">G</code></td>
<td>
<p>Graph.</p>
</td></tr>
<tr><td><code id="search_cut_genetic_+3A_w">w</code></td>
<td>
<p>Weight matrix.</p>
</td></tr>
<tr><td><code id="search_cut_genetic_+3A_npop">Npop</code></td>
<td>
<p>Population size.</p>
</td></tr>
<tr><td><code id="search_cut_genetic_+3A_ngen">Ngen</code></td>
<td>
<p>Number of generations (iterations of the algorithm).</p>
</td></tr>
<tr><td><code id="search_cut_genetic_+3A_pmut">pmut</code></td>
<td>
<p>Mutation probability.  It defaults to 0.1.</p>
</td></tr>
<tr><td><code id="search_cut_genetic_+3A_beta">beta</code></td>
<td>
<p>Control parameter of the crossing and selection
probabilities.  It defaults to 1.</p>
</td></tr>
<tr><td><code id="search_cut_genetic_+3A_elite">elite</code></td>
<td>
<p>Number of better fitted individuals to pass on to the
next generation.  It defaults to 2.</p>
</td></tr>
<tr><td><code id="search_cut_genetic_+3A_pini">Pini</code></td>
<td>
<p>Initial population.  If it is NA, a random initial
population of Npop individuals is generated.  Otherwise, it
should be a matrix; each row should be an individual (a
permutation of the 1:n sequence) and then Npop is set to the
number of rows of Pini.  This option allows to chain several
runs of the genetic algorithms, which could be needed in the
hardest cases.</p>
</td></tr>
<tr><td><code id="search_cut_genetic_+3A_verb">verb</code></td>
<td>
<p>Boolean to activate console echo.  It defaults to
TRUE.</p>
</td></tr>
<tr><td><code id="search_cut_genetic_+3A_log">log</code></td>
<td>
<p>Boolean to activate the recording of the weights of all
cuts found by the algorithm.  It defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm manipulates cuts by means of its associated binary
sequences defined as follows.  Each cut K is defined by its
associated vertex subset S of V(G): K contains all edges
joining vertices inside S with vertices outside S.  If
|V(G)|=n, we can construct a n-bit binary sequence b =
(b1,b2,...,bn) with bi = 1 if vertex vi belongs to S, and 0
otherwise.
</p>
<p>The genetic algorithm consists of starting with a cut population,
where each cut is represented by its corresponding binary
sequence defined above, and thus the population is simply a
binary matrix.  This initial cut population can be provided by
the user or can be random.  The initial population can be the
output of a previous run of the genetic algorithm, thus
allowing a chained execution.  Then the routine sequentially
perform over the cuts of the population the
<strong>crossover</strong>, <strong>mutation</strong>, <strong>local search</strong>
and <strong>selection</strong> operations.
</p>
<p>The <strong>crossover</strong> operation takes two cuts as &quot;parents&quot; and
forms two &quot;offsprings&quot; by cutting and interchanging the binary
sequences of the parents; see <a href="#topic+crossover_sequences">crossover_sequences</a> for more
information.
</p>
<p>The <strong>mutation</strong> operation performs a &quot;small&quot; perturbation of
each cut trying to escape from local optima.  It uses a random
flip on each bit of the binary sequence associated with the
cut, see <a href="#topic+mutate_binary_sequence">mutate_binary_sequence</a> for more information.
</p>
<p>The <strong>local search</strong> operation takes the cuts found by the
crossover and mutation operations and improves them using some
local search heuristic, in this case <a href="#topic+improve_cut_flip">improve_cut_flip</a>.  This
allows this algorithm to approach local maxima faster.
</p>
<p>The <strong>selection</strong> operation is used when selecting pairs of
parents for crossover and when selecting individuals to form
the population for the next generation.  In both cases, it
uses a probability exponential in the weight with rate
parameter &quot;beta&quot;, favouring the better fitted to be selected.
Lower values of beta favours the inclusion of cuts with worse
fitting function values.  When selecting the next population,
the selection uses <em>elitism</em>, which is to save the best
fitted individuals to the next generation; this is controlled
with parameter &quot;elite&quot;.
</p>
<p>The usefulness of the crossover and mutation operations stems from
its abitily to escape from the local maxima.  Of course, more
iterations (Ngen) and larger populations (Npop) might improve
the result, but recall that no random algorithm can guarantee
to find the optimum of a given Max-Cut instance.
</p>
<p>This algorithm calls many times the routines <a href="#topic+compute_cut_weight">compute_cut_weight</a>,
<a href="#topic+crossover_sequences">crossover_sequences</a>, <a href="#topic+mutate_binary_sequence">mutate_binary_sequence</a> and
<a href="#topic+improve_cut_flip">improve_cut_flip</a>; therefore, it is not especially efficient
when called on large problems or with high populations or many
generations.  Please consider chaining the algorithm:  perform
short runs, using the output of a run as the input of the
next.
</p>


<h3>Value</h3>

<p>A list with several components: $set contains the subset
of V(g) representing the cut, $size contains the number of
edges of the cut, $weight contains the weight of the cut
(which coincides with $size if w is NA) and $cut contains the
edges of the cut, joining vertices inside $set with vertices
outside $set; $generation contains the generation when the
maximum was found and $population contains the final cut
population.  When log=TRUE, the output includes several lists
of weights of cuts found by the algorithm, separated by
initial cuts, offsprings, mutants, local maxima and selected
cuts.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>References</h3>

<p>Hromkovic <em>Algorithms for hard problems</em> (2004),
Hartmann, Weigt, <em>Phase transitions in combinatorial
optimization problems</em> (2005).
</p>


<h3>See Also</h3>

<p><a href="#topic+crossover_sequences">crossover_sequences</a> performs crossover operation,
<a href="#topic+mutate_binary_sequence">mutate_binary_sequence</a> performs mutation operation,
<a href="#topic+build_cut_random">build_cut_random</a> builds a random cut, <a href="#topic+build_cut_greedy">build_cut_greedy</a>
builds a cut using a greedy algorithm, <a href="#topic+improve_cut_flip">improve_cut_flip</a>
improves a cut by local search, <a href="#topic+compute_cut_weight">compute_cut_weight</a> computes
cut size, weight and edges, <a href="#topic+plot_cut">plot_cut</a> plots a cut.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n &lt;- 10
g &lt;- sample_gnp(n, p=0.5)  # Random graph
c5 &lt;- search_cut_genetic(g)
plot_cut(c5, g)
improve_cut_flip(g, c5)     # It does not improve
for (i in 1:5) {            # Weights of final population
   s5 &lt;- which(c5$population[i,] == 1)
   cs5 &lt;- compute_cut_weight(s5, gorder(g), as_edgelist(g))
   print(cs5$weight)
}


## Longer examples
c5 &lt;- search_cut_genetic(g, Npop=10, Ngen=50, log = TRUE)
boxplot(c5$Wini, c5$Woff, c5$Wmut, c5$Wvec, c5$Wsel,
        names=c("Ini", "Off", "Mut", "Neigh", "Sel"))

set.seed(1)
n &lt;- 20
g &lt;- sample_gnp(n, p=0.25)
Wg &lt;- matrix(sample(1:3, n^2, replace=TRUE), nrow=n)
Wg &lt;- Wg + t(Wg)
A &lt;- as_adjacency_matrix(g)
Wg &lt;- Wg * A
c6 &lt;- search_cut_genetic(g, Wg, Ngen = 9)   # Size 38, weigth 147
plot_cut(c6, g)


</code></pre>

<hr>
<h2 id='search_tour_ants'>Ant colony optimization algorithm for the TSP</h2><span id='topic+search_tour_ants'></span>

<h3>Description</h3>

<p>Ant colony optimization (ACO) heuristic algorithm to search for a
low-distance tour of a TSP instance.  ACO is a random
algorithm; as such, it yields better results when longer
searches are run.  To guess the adequate parameter values
resulting in better performance in particular instances
requires some experimentation, since no universal values of
the parameters seem to be appropriate to all examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_tour_ants(
  d,
  n,
  K = 200,
  N = 50,
  beta = 3,
  alpha = 5,
  dt = 1,
  rho = 0.05,
  log = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_tour_ants_+3A_d">d</code></td>
<td>
<p>Distance matrix of the TSP instance.</p>
</td></tr>
<tr><td><code id="search_tour_ants_+3A_n">n</code></td>
<td>
<p>Number of vertices of the complete TSP graph.  It can be
less than the number of rows of the distance matrix d.</p>
</td></tr>
<tr><td><code id="search_tour_ants_+3A_k">K</code></td>
<td>
<p>Number of tour-searching ants.  Defaults to 200.</p>
</td></tr>
<tr><td><code id="search_tour_ants_+3A_n">N</code></td>
<td>
<p>Number of iterations.  Defaults to 50.</p>
</td></tr>
<tr><td><code id="search_tour_ants_+3A_beta">beta</code></td>
<td>
<p>Inverse temperature which determines the thermal
probability in selecting the next vertex in tour.  High beta
(low temperature) rewards lower distances (and thus it gets
stuck sooner in local minima), while low beta (high
temperature) rewards longer tours, thus escaping from local
minima.  Defaults to 3.</p>
</td></tr>
<tr><td><code id="search_tour_ants_+3A_alpha">alpha</code></td>
<td>
<p>Exponent enhancing the pheromone trail.  High alpha
means a clearer trail, low alpha means more options.  It
defaults to 5.</p>
</td></tr>
<tr><td><code id="search_tour_ants_+3A_dt">dt</code></td>
<td>
<p>Basic pheromone enhancement at each iteration.  It
defaults to 1.</p>
</td></tr>
<tr><td><code id="search_tour_ants_+3A_rho">rho</code></td>
<td>
<p>Parameter in the (0,1) interval controlling pheromone
evaporation rate.  Pheromones of the chosen tour increase in
dt*rho, while excluded pheromones diminish in 1-rho.  A rho
value near 1 means select just one tour, while lower values of
rho spread the probability and more tours can be explored.  It
defaults to 0.05.</p>
</td></tr>
<tr><td><code id="search_tour_ants_+3A_log">log</code></td>
<td>
<p>Boolean.  When TRUE, it also outputs two vectos
recording the performance of the algorithm.  It defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ACO is an optimization paradigm that tries to replicate the
behavior of a colony of ants when looking for food.  Ants
leave after them a soft pheromone trail to help others follow
the path just in case some food has been found.  Pheromones
evaporate, but following again the trail reinforces it, making
it easier to find and follow.  Thus, a team of ants search a
tour in a TSP instance, leaving a pheromone trail on the edges
of the tour.  At each step, each ant decides the next step
based on the pheromone level and on the distance of each
neighboring edge.  In a single iteration, each ant completes a
tour, and the best tour is recorded.  Then the pheromone level
of the edges of the best tour are enhanced, and the remaining
pheromones evaporate.
</p>
<p>Default parameter values have been chosen in order to find the
optimum in the examples considered below.  However, it cannot
be guarateed that this is the best choice for all cases.  Keep
in mind that no polynomial time exact algorithm can exist for
the TSP, and thus harder instances will require to fine-tune
the parameters.  In any case, no guarantee of optimality of
tours found by this method can be given, so they might be
improved further by other methods.
</p>


<h3>Value</h3>

<p>A list with two components: $tour contains a permutation
of the 1:n sequence representing the tour constructed by the
algorithm, $distance contains the value of the distance
covered by the tour.  When log=TRUE, the output list contains
also the component $Lant, best tour distance found in the current
iteration, and component $Lopt, best tour distance found
before and including the current iteration.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p><a href="#topic+compute_distance_matrix">compute_distance_matrix</a> computes matrix distances using
2d points, <a href="#topic+improve_tour_2opt">improve_tour_2opt</a> improves a tour using
2-exchanges, <a href="#topic+plot_tour">plot_tour</a> draws a tour
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Regular example with obvious solution (minimum distance 32)
m &lt;- 6   # Generate some points in the plane
z &lt;- cbind(c(rep(0,m), rep(2,m), rep(5,m), rep(7,m)), rep(seq(0,m-1),4))
n &lt;- nrow(z)
d &lt;- compute_distance_matrix(z)
set.seed(2)
b &lt;- search_tour_ants(d, n, K = 70, N = 20)
b$distance    # Distance 32 (optimum)
plot_tour(z,b)

## Random points
set.seed(1)
n &lt;- 15
z &lt;- cbind(runif(n,min=1,max=10),runif(n,min=1,max=10))
d &lt;- compute_distance_matrix(z)
b &lt;- search_tour_ants(d, n, K = 50, N = 20)
b$distance    # Distance 32.48669 
plot_tour(z,b)

</code></pre>

<hr>
<h2 id='search_tour_chain2opt'>Chained 2-opt search with multiple, random starting tours</h2><span id='topic+search_tour_chain2opt'></span>

<h3>Description</h3>

<p>Random heuristic algorithm for TSP which performs chained 2-opt
local search with multiple, random starting tours.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_tour_chain2opt(d, n, Nit, Nper, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_tour_chain2opt_+3A_d">d</code></td>
<td>
<p>Distance matrix of the TSP instance.</p>
</td></tr>
<tr><td><code id="search_tour_chain2opt_+3A_n">n</code></td>
<td>
<p>Number of vertices of the TSP complete graph.</p>
</td></tr>
<tr><td><code id="search_tour_chain2opt_+3A_nit">Nit</code></td>
<td>
<p>Number of iterations of the algorithm, see details.</p>
</td></tr>
<tr><td><code id="search_tour_chain2opt_+3A_nper">Nper</code></td>
<td>
<p>Number of chained perturbations of 2-opt minima, see details.</p>
</td></tr>
<tr><td><code id="search_tour_chain2opt_+3A_log">log</code></td>
<td>
<p>Boolean: Whether the algorithm should record the
distances of the tours it finds during execution.  It
defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Chained local search consists of starting with a random tour,
improving it using 2-opt, and then perturb it using a random
4-exchange.  The result is 2-optimized again, and then
4-exchanged...  This sequence of chained
2-optimizations/perturbations is repeated Nper times for each
random starting tour.  The entire process is repeated Nit
times, drawing a fresh random tour each iteration.
</p>
<p>The purpose of supplement the deterministic 2-opt algorithm with
random additions (random starting point and random 4-exchange)
is escaping from the 2-opt local minima.  Of course, more
iterations and more perturbations might lower the result, but
recall that no random algorithm can guarantee to find the
optimum in a reasonable amount of time.
</p>
<p>This technique is most often applied in conjunction with the
Lin-Kernighan local search heuristic.
</p>
<p>It should be warned that this algorithm calls Nper*Nit times the
routine <a href="#topic+improve_tour_2opt">improve_tour_2opt</a>, and thus it is not especially efficient.
</p>


<h3>Value</h3>

<p>A list with two components: $tour contains a permutation
of the 1:n sequence representing the tour constructed by the
algorithm, $distance contains the value of the distance
covered by the tour.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>References</h3>

<p>Cook et al. <em>Combinatorial Optimization</em> (1998)
</p>


<h3>See Also</h3>

<p><a href="#topic+perturb_tour_4exc">perturb_tour_4exc</a> transforms a tour using a random
4-exchange, <a href="#topic+improve_tour_2opt">improve_tour_2opt</a> improves a tour using the 2-opt
algorithm, <a href="#topic+improve_tour_3opt">improve_tour_3opt</a> improves a tour using the 3-opt
algorithm, <a href="#topic+build_tour_nn_best">build_tour_nn_best</a> nearest neighbor heuristic,
<a href="#topic+build_tour_2tree">build_tour_2tree</a> double-tree heuristic,
<a href="#topic+compute_tour_distance">compute_tour_distance</a> computes tour distances,
<a href="#topic+compute_distance_matrix">compute_distance_matrix</a> computes a distance matrix,
<a href="#topic+plot_tour">plot_tour</a> plots a tour.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Regular example with obvious solution (minimum distance 32)
m &lt;- 6   # Generate some points in the plane
z &lt;- cbind(c(rep(0,m), rep(2,m), rep(5,m), rep(7,m)), rep(seq(0,m-1),4))
n &lt;- nrow(z)
d &lt;- compute_distance_matrix(z)
bc &lt;- search_tour_chain2opt(d, n, 5, 3)
bc     # Distance 48
plot_tour(z,bc)

## Random points
set.seed(1)
n &lt;- 15
z &lt;- cbind(runif(n,min=1,max=10),runif(n,min=1,max=10))
d &lt;- compute_distance_matrix(z)
bc &lt;- search_tour_chain2opt(d, n, 5, 3)
bc     # Distance 32.48669
plot_tour(z,bc)

</code></pre>

<hr>
<h2 id='search_tour_genetic'>Genetic Algorithm for the TSP</h2><span id='topic+search_tour_genetic'></span>

<h3>Description</h3>

<p>Genetic algorithm for TSP.  In addition to crossover and mutation,
which are described below, the algorithm performs also 2-opt
local search on offsprings and mutants.  In this way, this
algorithm is at least as good as chained 2-opt search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_tour_genetic(
  d,
  n,
  Npop = 20,
  Ngen = 50,
  beta = 1,
  elite = 2,
  Pini = NA,
  local = 1,
  verb = TRUE,
  log = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_tour_genetic_+3A_d">d</code></td>
<td>
<p>Distance matrix of the TSP instance.</p>
</td></tr>
<tr><td><code id="search_tour_genetic_+3A_n">n</code></td>
<td>
<p>Number of vertices of the TSP complete graph.</p>
</td></tr>
<tr><td><code id="search_tour_genetic_+3A_npop">Npop</code></td>
<td>
<p>Population size.</p>
</td></tr>
<tr><td><code id="search_tour_genetic_+3A_ngen">Ngen</code></td>
<td>
<p>Number of generations (iterations of the algorithm).</p>
</td></tr>
<tr><td><code id="search_tour_genetic_+3A_beta">beta</code></td>
<td>
<p>Control parameter of the crossing and selection
probabilities.  It defaults to 1.</p>
</td></tr>
<tr><td><code id="search_tour_genetic_+3A_elite">elite</code></td>
<td>
<p>Number of better fitted individuals to pass on to the
next generation.  It defaults to 2.</p>
</td></tr>
<tr><td><code id="search_tour_genetic_+3A_pini">Pini</code></td>
<td>
<p>Initial population.  If it is NA, a random initial
population of Npop individuals is generated.  Otherwise, it
should be a matrix; each row should be an individual (a
permutation of the 1:n sequence) and then Npop is set to the
number of rows of Pini.  This option allows to chain several
runs of the genetic algorithm, which could be needed in the
hardest cases.</p>
</td></tr>
<tr><td><code id="search_tour_genetic_+3A_local">local</code></td>
<td>
<p>Average fraction of parents + offsprings + mutants
that will be taken as starting tours by the local search
algorithm <a href="#topic+improve_tour_2opt">improve_tour_2opt</a>.  It should be a number between
0 and 1.  It defauls to 1.</p>
</td></tr>
<tr><td><code id="search_tour_genetic_+3A_verb">verb</code></td>
<td>
<p>Boolean to activate console echo.  It defaults to
TRUE.</p>
</td></tr>
<tr><td><code id="search_tour_genetic_+3A_log">log</code></td>
<td>
<p>Boolean to activate the recording of the distances of
all tours found by the algorithm.  It defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The genetic algorithm consists of starting with a tour population,
which can be provided by the user or can be random.  The
initial population can be the output of a previous run of the
genetic algorithm, thus allowing a chained execution.  Then
the routine sequentially perform over the tours of the
population the <strong>crossover</strong>, <strong>mutation</strong>,
<strong>local search</strong> and <strong>selection</strong> operations.
</p>
<p>The <strong>crossover</strong> operation takes two tours and forms two
offsprings trying to exploit the good structure of the
parents; see <a href="#topic+crossover_tours">crossover_tours</a> for more information.
</p>
<p>The <strong>mutation</strong> operation performs a &quot;small&quot; perturbation of
each tour trying to escape from local optima.  It uses a
random 4-exchange, see <a href="#topic+perturb_tour_4exc">perturb_tour_4exc</a> and
<a href="#topic+search_tour_chain2opt">search_tour_chain2opt</a> for more information.
</p>
<p>The <strong>local search</strong> operation takes the tours found by the
crossover and mutation operations and improves them using the
2-opt local search heuristic, see <a href="#topic+improve_tour_2opt">improve_tour_2opt</a>.  This
makes this algorithm at least as good as chained local search,
see <a href="#topic+search_tour_chain2opt">search_tour_chain2opt</a>.
</p>
<p>The <strong>selection</strong> operation is used when selecting pairs of
parents for crossover and when selecting individuals to form
the population for the next generation.  In both cases, it
uses a probability exponential in the distance with rate
parameter &quot;beta&quot;, favouring the better fitted to be selected.
Lower values of beta favours the inclusion of tours with worse
fitting function values.  When selecting the next population,
the selection uses <em>elitism</em>, which is to save the best
fitted individuals to the next generation; this is controlled
with parameter &quot;elite&quot;.
</p>
<p>The usefulness of the crossover and mutation operations stems from
its abitily to escape from the 2-opt local minima in a way
akin to the perturbation used in chained local search
<a href="#topic+search_tour_chain2opt">search_tour_chain2opt</a>.  Of course, more iterations (Ngen)
and larger populations (Npop) might lower the result, but
recall that no random algorithm can guarantee to find the
optimum of a given TSP instance.
</p>
<p>This algorithm calls many times the routines <a href="#topic+crossover_tours">crossover_tours</a>,
<a href="#topic+improve_tour_2opt">improve_tour_2opt</a> and <a href="#topic+perturb_tour_4exc">perturb_tour_4exc</a>; therefore, it is
not especially efficient when called on large problems or with
high populations of many generations.  Input parameter &quot;local&quot;
can be used to randomly select which tours will start local
search, thus diminishing the run time of the algorithm.
Please consider chaining the algorithm:  perform short runs,
using the output of a run as the input of the next.
</p>


<h3>Value</h3>

<p>A list with four components: $tour contains a permutation
of the 1:n sequence representing the tour constructed by the
algorithm, $distance contains the value of the distance
covered by the tour, $generation contains the generation is
which the minimum was found and $population contains the final
tour population.  When log=TRUE, the output includes several
lists of distances of tours found by the algorithm, separated
by initial tours, offsprings, mutants, local minima and
selected tours.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>References</h3>

<p>Hromkovic <em>Algorithms for hard problems</em> (2004),
Hartmann, Weigt, <em>Phase transitions in combinatorial
optimization problems</em> (2005).
</p>


<h3>See Also</h3>

<p><a href="#topic+crossover_tours">crossover_tours</a> performs the crosover of two tours,
<a href="#topic+gauge_tour">gauge_tour</a> transforms a tour into a canonical sequence for
comparison, <a href="#topic+search_tour_chain2opt">search_tour_chain2opt</a> performs a chained 2-opt
search, <a href="#topic+perturb_tour_4exc">perturb_tour_4exc</a> transforms a tour using a random
4-exchange, <a href="#topic+improve_tour_2opt">improve_tour_2opt</a> improves a tour using the
2-opt algorithm, <a href="#topic+improve_tour_3opt">improve_tour_3opt</a> improves a tour using the
3-opt algorithm, <a href="#topic+build_tour_nn_best">build_tour_nn_best</a> nearest neighbor
heuristic, <a href="#topic+build_tour_2tree">build_tour_2tree</a> double-tree heuristic,
<a href="#topic+compute_tour_distance">compute_tour_distance</a> computes tour distances,
<a href="#topic+compute_distance_matrix">compute_distance_matrix</a> computes a distance matrix,
<a href="#topic+plot_tour">plot_tour</a> plots a tour.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Regular example with obvious solution (minimum distance 32)
m &lt;- 6   # Generate some points in the plane
z &lt;- cbind(c(rep(0,m), rep(2,m), rep(5,m), rep(7,m)), rep(seq(0,m-1),4))
n &lt;- nrow(z)
d &lt;- compute_distance_matrix(z)
bc &lt;- search_tour_genetic(d, n, Npop = 5, Ngen = 3, local = 0.2)
bc     # Distance 32
plot_tour(z,bc)

## Random points
set.seed(1)
n &lt;- 15
z &lt;- cbind(runif(n,min=1,max=10),runif(n,min=1,max=10))
d &lt;- compute_distance_matrix(z)
bg &lt;- search_tour_genetic(d, n, 5, 3, local = 0.25)
bg     # Distance 32.48669
plot_tour(z,bg)

</code></pre>

<hr>
<h2 id='shave_cycle'>Shaving a hairy cycle</h2><span id='topic+shave_cycle'></span>

<h3>Description</h3>

<p>Removing dangling vertices of a cycle obtained by adding a single
edge to a spanning tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shave_cycle(v, eG)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shave_cycle_+3A_v">v</code></td>
<td>
<p>Edge vector of the hairy cycle</p>
</td></tr>
<tr><td><code id="shave_cycle_+3A_eg">eG</code></td>
<td>
<p>Graph given as edgelist, see <a href="igraph.html#topic+as_edgelist">as_edgelist</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>When generating a fundamental cycle in a graph, addition of a
single edge to a spanning tree gives a &quot;hairy&quot; cycle, that is,
a single cycle with some dangling branches of the tree.  This
routine removes iteratively all leaves from this &quot;hairy&quot; tree
until only a 2-regular, connected cycle remains, which is a
fundamental cycle of the graph with respect the given spanning
tree.
</p>


<h3>Value</h3>

<p>Edge vector of the shaven cycle, to be interpreted with
respect to the edgelist eG.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p><a href="#topic+generate_fundamental_cycles">generate_fundamental_cycles</a> generates the edge vectors
of a system of fundamental cycles of a graph,
<a href="#topic+apply_incidence_map">apply_incidence_map</a> applies the incidence map of a graph to
an edge vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## It is used as a subroutine in [generate_fundamental_cycles].

</code></pre>

<hr>
<h2 id='sum_g'>Sum of the higher terms of a list</h2><span id='topic+sum_g'></span>

<h3>Description</h3>

<p>Sum of the higher terms of a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_g(L, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_g_+3A_l">L</code></td>
<td>
<p>A numeric sequence</p>
</td></tr>
<tr><td><code id="sum_g_+3A_m">m</code></td>
<td>
<p>A scalar</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It sorts the list L in decreasing order and returns the sum of the
first m components of the ordered list.
</p>


<h3>Value</h3>

<p>The sum of the m higher terms of the list L
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sum_g(1:10, 3)  # 8 + 9 + 10 = 27

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
