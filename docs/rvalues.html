<!DOCTYPE html><html><head><title>Help for package rvalues</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rvalues}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#batavgs'>
<p>Batting Averages Data</p></a></li>
<li><a href='#bcwest'>
<p>Breast Cancer Gene Expression Data</p></a></li>
<li><a href='#FDRCurve'>
<p>FDR Curve</p></a></li>
<li><a href='#fluEnrich'>
<p>Flu Enrichment Data</p></a></li>
<li><a href='#hiv'>
<p>HIV Data Set</p></a></li>
<li><a href='#MakeGrid'>
<p>Grid Construction</p></a></li>
<li><a href='#MCMCtest'>
<p>MCMC sample output</p></a></li>
<li><a href='#mroot'>
<p>Multi-dimensional Root (Zero) Finding</p></a></li>
<li><a href='#NBA1314'>
<p>National Basketball Association, free throw data, 2013-2014 season</p></a></li>
<li><a href='#npmixapply'>
<p>Apply Functions over estimated unit-specific posterior</p>
distributions</a></li>
<li><a href='#npmle'>
<p>Maximum Likelihood Estimate of a Mixing Distribution.</p></a></li>
<li><a href='#OverlapCurve'>
<p>Overlap Curve</p></a></li>
<li><a href='#PostPercentile'>
<p>Posterior expected percentiles</p></a></li>
<li><a href='#PostSummaries'>
<p>R-values from posterior summary quantities</p></a></li>
<li><a href='#rvalueBoot'>
<p>Bootstrapped r-values</p></a></li>
<li><a href='#rvalues'>
<p>R-values</p></a></li>
<li><a href='#rvaluesMCMC'>
<p>R-values from MCMC output.</p></a></li>
<li><a href='#tdist'>
<p>t-distribution family object</p></a></li>
<li><a href='#TopList'>
<p>List of Top Units</p></a></li>
<li><a href='#Valpha'>
<p>R-values from a matrix of posterior tail probabilities.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>R-Values for Ranking in High-Dimensional Settings</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-03-10</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nicholas Henderson &lt;nchender@umich.edu&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, utils</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions for computing "r-values" from various
    kinds of user input such as MCMC output or a list of effect size estimates
    and associated standard errors. Given a large collection of measurement units,
    the r-value, r, of a particular unit is a reported percentile that may be
    interpreted as the smallest percentile at which the unit should be placed in the
    top r-fraction of units.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://doi.org/10.1111/rssb.12131">https://doi.org/10.1111/rssb.12131</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-03-11 05:57:17 UTC; nchender</td>
</tr>
<tr>
<td>Author:</td>
<td>Nicholas Henderson [cre],
  Michael Newton [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-03-11 07:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='batavgs'>
Batting Averages Data
</h2><span id='topic+batavgs'></span>

<h3>Description</h3>

<p>Data set containing number of at-bats and number of hits for Major League baseball players over
the 2005 season.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(batavgs)</code></pre>


<h3>Format</h3>

<p>A data frame with 929 observations on the following 7 variables.
</p>

<dl>
<dt><code>First.Name</code></dt><dd><p>factor; player's last name</p>
</dd>
<dt><code>Last.Name</code></dt><dd><p>factor; player's first name</p>
</dd>
<dt><code>Pitcher</code></dt><dd><p>numeric vector; an indicator of whether or not the player is a pitcher</p>
</dd>
<dt><code>midseasonAB</code></dt><dd><p>numeric vector; number of at-bats during the first half of the season</p>
</dd>
<dt><code>midseasonH</code></dt><dd><p>numeric vector; number of hits during the first half of the season</p>
</dd>
<dt><code>TotalAB</code></dt><dd><p>numeric vector; total number of at-bats over the season</p>
</dd>
<dt><code>TotalH</code></dt><dd><p>numeric vector; total number of hits over the season</p>
</dd>
</dl>



<h3>Details</h3>

<p>The 2005 Major League Baseball season was roughly six months starting from the beginning
of April and ending at the beginning of October. Data from postseason play is not 
included. The midseason data were obtained by only considering the first three months
of the season.
</p>


<h3>Source</h3>

<p>http://projecteuclid.org/DPubS?service=UI&amp;version=1.0&amp;verb=Display&amp;handle=euclid.aoas/1206367815
</p>


<h3>References</h3>

<p>Brown, L. D. (2008), In-Season prediction of batting averages: a field test
of empirical Bayes and Bayes Methodologies, 
<em>The Annals of Applied Statistics</em>, <b>2</b>, 1, 113&ndash;152.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(batavgs)
head(batavgs)
</code></pre>

<hr>
<h2 id='bcwest'>
Breast Cancer Gene Expression Data
</h2><span id='topic+bcwest'></span>

<h3>Description</h3>

<p>Effect size estimates and standard errors obtained from 
gene expression measurements on 7129 genes across 49 samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bcwest)</code></pre>


<h3>Format</h3>

<p>A data frame with 7129 observations on the following 2 variables.
</p>

<dl>
<dt><code>estimates</code></dt><dd><p>a vector of effect size estimates</p>
</dd>
<dt><code>std.err</code></dt><dd><p>standard errors associated with effect size estimates</p>
</dd>
</dl>



<h3>Details</h3>

<p>A description of the original data may be found in West et al. (2001).
For each gene, the effect size estimate was computed from the difference
in the mean expression levels of the two groups (i.e., 
mean(bc-positive group) - mean(bc-negative group)).
</p>


<h3>Source</h3>

<p>T. Hothorn, P. Buehlmann, T. Kneib, M. Schmid, and B. Hofner (2013). 
mboost: Model-Based Boosting, R package version 2.2-3, http://CRAN.R-project.org/package=mboost.
</p>


<h3>References</h3>

<p>Mike West, Carrie Blanchette, Holly Dressman, Erich Huang,
Seiichi Ishida, Rainer Spang, Harry Zuzan, John A. Olson Jr.,
Jeffrey R. Marks and Joseph R. Nevins (2001),
Predicting the clinical status of human breast cancer by using
gene expression profiles, <em>Proceedings of the National Academy of Sciences</em>,
<b>98</b>, 11462-11467.
</p>

<hr>
<h2 id='FDRCurve'>
FDR Curve
</h2><span id='topic+FDRCurve'></span>

<h3>Description</h3>

<p>Estimates the expected proportion of misclassified units
when using a given r-value threshold. If plot=TRUE, the 
curve is plotted before the estimated function is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FDRCurve(object, q, threshold = 1, plot = TRUE, xlim, ylim, xlab, ylab, main, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FDRCurve_+3A_object">object</code></td>
<td>

<p>An object of class &quot;rvals&quot;
</p>
</td></tr>
<tr><td><code id="FDRCurve_+3A_q">q</code></td>
<td>

<p>A value in between 0 and 1; the desired level of FDR control.
</p>
</td></tr>
<tr><td><code id="FDRCurve_+3A_threshold">threshold</code></td>
<td>

<p>The r-value threshold.
</p>
</td></tr>
<tr><td><code id="FDRCurve_+3A_plot">plot</code></td>
<td>

<p>logical; if TRUE, the estimated FDR curve is plotted.
</p>
</td></tr>
<tr><td><code id="FDRCurve_+3A_xlim">xlim</code>, <code id="FDRCurve_+3A_ylim">ylim</code></td>
<td>

<p>x and y - axis limits for the plot
</p>
</td></tr>
<tr><td><code id="FDRCurve_+3A_xlab">xlab</code>, <code id="FDRCurve_+3A_ylab">ylab</code></td>
<td>

<p>x and y - axis labels
</p>
</td></tr>
<tr><td><code id="FDRCurve_+3A_main">main</code></td>
<td>

<p>the title of the plot
</p>
</td></tr>
<tr><td><code id="FDRCurve_+3A_...">...</code></td>
<td>

<p>additional arguments to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider parameters of interest <code class="reqn">(\theta_1,...,\theta_n)</code> with an effect of size of interest 
<code class="reqn">\tau</code>. That is, a unit is taken to be &quot;null&quot; if <code class="reqn">\theta_i \le \tau</code> and
taken to be &quot;non-null&quot; if <code class="reqn">\theta_i &gt; \tau</code>.
</p>
<p>For r-values <code class="reqn">r_1,...,r_n</code> and a procedure which &quot;rejects&quot; units 
satisfying <code class="reqn">r_i \le c</code>, the FDR is defined to be
</p>
<p style="text-align: center;"><code class="reqn">FDR(c) = P(\theta_i &lt; \tau,r_i \le c)/P(r_i \le c).</code>
</p>

<p><code>FDRCurve</code> estimates <code class="reqn">FDR(c)</code>
for values of <code class="reqn">c</code> across (0,1) and plots (if <code>plot=TRUE</code>)
the resulting curve.
</p>


<h3>Value</h3>

<p>A list with the following two components
</p>
<table>
<tr><td><code>fdrcurve</code></td>
<td>
<p>A function which returns the estimated FDR for each r-value threshold.</p>
</td></tr>
<tr><td><code>Rval.cut</code></td>
<td>
<p>The largest r-value cutoff which still gives an estimated FDR less than q.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicholas Henderson and Michael Newton
</p>


<h3>See Also</h3>

<p><code><a href="#topic+OverlapCurve">OverlapCurve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 500
theta &lt;- rnorm(n)
ses &lt;- sqrt(rgamma(n,shape=1,scale=1))
XX &lt;- theta + ses*rnorm(n)
dd &lt;- cbind(XX,ses)

rvs &lt;- rvalues(dd, family = gaussian)

FDRCurve(rvs, q = .1, threshold = .3, cex.main = 1.5)
</code></pre>

<hr>
<h2 id='fluEnrich'>
Flu Enrichment Data
</h2><span id='topic+fluEnrich'></span>

<h3>Description</h3>

<p>Gene-set enrichment for genes that have been identified as
having an effect on influenza-virus replication.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fluEnrich)</code></pre>


<h3>Format</h3>

<p>A data frame with 5719 observations on the following 3 variables.
</p>

<dl>
<dt><code>nflugenes</code></dt><dd><p>number of genes both annotated to the given GO term and in the collection of flu genes</p>
</dd>
<dt><code>setsize</code></dt><dd><p>number of genes annotated to the given GO term</p>
</dd>
<dt><code>GO_terms</code></dt><dd><p>the GO (gene ontology) term label</p>
</dd> 
</dl>



<h3>Details</h3>

<p>These data were produced by associating the 984 genes (the collection of flu genes)
identified in the Hao et al. (2013) meta-analysis with gene ontology (GO) gene sets (GO terms). 
In total, 17959 human genes were annotated to at least one GO term and 16572
GO terms were available, though this data set only contains the 5719 terms 
which annotated between 10 and 1000 human genes.
</p>


<h3>References</h3>

<p>Hao, L. Q. He, Z. Wang, M. Craven, M. A. Newton, and P. Ahlquist (2013). 
Limited agreement of independent RNAi screens for virus-required host genes
owes more to false-negatives than false-positive factors.
<em>PLoS computational biology</em>, <b>9</b>, 9, e1003235.
</p>

<hr>
<h2 id='hiv'>
HIV Data Set
</h2><span id='topic+hiv'></span>

<h3>Description</h3>

<p>These data contain effect size estimates and standard errors obtained from 
gene expression measurements on 7680 genes across 8 samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hiv)</code></pre>


<h3>Format</h3>

<p>A data frame with 7680 observations on the following 2 variables.
</p>

<dl>
<dt><code>estimates</code></dt><dd><p>a vector of effect size estimates</p>
</dd>
<dt><code>std.err</code></dt><dd><p>standard errors associated with effect size estimates</p>
</dd>
</dl>



<h3>References</h3>

<p>van't Wout, et. al. (2003), Cellular gene 
expression upon human immuno-deficiency virus type 1 infection of
CD4+-T-Cell lines, <em>Journal ofVirology</em>, <b>77</b>, 1392&ndash;1402.
</p>

<hr>
<h2 id='MakeGrid'>
Grid Construction
</h2><span id='topic+MakeGrid'></span>

<h3>Description</h3>

<p>Computes a grid of points on the interval (0,1). This function is
useful for constructing the &quot;alpha-grid&quot; used in various r-value computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeGrid(nunits, type = "log", ngrid = NULL, lower = 1/nunits, upper = 1 - lower)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MakeGrid_+3A_nunits">nunits</code></td>
<td>

<p>The number of units in the data for which r-values
are to be calculated.
</p>
</td></tr>
<tr><td><code id="MakeGrid_+3A_type">type</code></td>
<td>

<p>The type of grid; type can be set to <code>type="uniform"</code>,
<code>type="log"</code>, or <code>type="log.symmetric"</code>.
</p>
</td></tr>
<tr><td><code id="MakeGrid_+3A_ngrid">ngrid</code></td>
<td>

<p>a number specifying the number of grid points
</p>
</td></tr>
<tr><td><code id="MakeGrid_+3A_lower">lower</code></td>
<td>

<p>the smallest grid point; must be greater than zero  
</p>
</td></tr>
<tr><td><code id="MakeGrid_+3A_upper">upper</code></td>
<td>

<p>the largest grid point; must be less than one
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>nunits</code> <code class="reqn">\le 1000</code>, the default number of grid points is
equal to <code>nunits</code>. When <code>nunits</code> <code class="reqn">&gt; 1000</code>, the default 
number of grid points is determined by 
</p>
<p style="text-align: center;"><code class="reqn">1000 + 25*log(nunits - 1000)*(nunits - 1000)^{1/4}</code>
</p>
<p>.
</p>


<h3>Value</h3>

<p>A vector of grid points in (0,1).
</p>


<h3>Author(s)</h3>

<p>Nicholas Henderson and Michael Newton
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rvalues">rvalues</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha.grid &lt;- MakeGrid(1000,type="uniform",ngrid=200)

log.grid &lt;- MakeGrid(40,type="log")
log.grid
hist(log.grid)
</code></pre>

<hr>
<h2 id='MCMCtest'>
MCMC sample output
</h2><span id='topic+MCMCtest'></span>

<h3>Description</h3>

<p>a matrix of test MCMC output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(MCMCtest)</code></pre>


<h3>Format</h3>

<p>A 2000 x 400 numeric matrix. Data in the ith row should be thought of 
as a sample from the posterior for the ith case of interest.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rvaluesMCMC">rvaluesMCMC</a></code>
</p>

<hr>
<h2 id='mroot'>
Multi-dimensional Root (Zero) Finding
</h2><span id='topic+mroot'></span>

<h3>Description</h3>

<p>For a given multi-dimensional function with both a vector of lower bounds
and upper bounds, <code>mroot</code> finds a vector such that each 
component of the function is zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mroot(f, lower, upper, ..., f.lower = f(lower, ...), f.upper = f(upper, ...),
      tol = .Machine$double.eps^0.25, maxiter = 5000) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mroot_+3A_f">f</code></td>
<td>

<p>the function for which the root is sought
</p>
</td></tr>
<tr><td><code id="mroot_+3A_lower">lower</code></td>
<td>

<p>a vector of lower end points 
</p>
</td></tr>
<tr><td><code id="mroot_+3A_upper">upper</code></td>
<td>

<p>a vector of upper end points
</p>
</td></tr>
<tr><td><code id="mroot_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed to <code>f</code>
</p>
</td></tr>
<tr><td><code id="mroot_+3A_f.lower">f.lower</code>, <code id="mroot_+3A_f.upper">f.upper</code></td>
<td>

<p>the same as <code>f(lower)</code> and <code>f(upper)</code>
</p>
</td></tr>
<tr><td><code id="mroot_+3A_tol">tol</code></td>
<td>

<p>the convergence tolerance
</p>
</td></tr>
<tr><td><code id="mroot_+3A_maxiter">maxiter</code></td>
<td>

<p>the maximum number of iterations
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>f</code> is from <code class="reqn">R^{n}</code> to <code class="reqn">R^{n}</code> with 
<code class="reqn">f(x_1,\dots,x_n) = (f_1(x_1),\dots,f_n(x_n))</code>.
</p>
<p>A root <code class="reqn">x = (x_1,\dots,x_n)</code> of <code class="reqn">f</code> satisfies
<code class="reqn">f_k(x_k) = 0</code> for each component <code class="reqn">k</code>.
</p>
<p><code>lower</code> <code class="reqn"> = (l_1,\ldots,l_n)</code> and <code>upper</code> 
<code class="reqn">= (u_1,\dots,u_n)</code> are both n-dimensional vectors
such that, for each <code class="reqn">k</code>, <code class="reqn">f_k</code> changes sign over the
interval <code class="reqn"> [l_k, u_k]</code>. 
</p>


<h3>Value</h3>

<p>a vector giving the estimated root of the function
</p>


<h3>Author(s)</h3>

<p>Nicholas Henderson
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+uniroot">uniroot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ff &lt;- function(x,a) {
    ans &lt;- qnorm(x) - a
    return(ans)
}
n &lt;- 10000
a &lt;- rnorm(n)
low &lt;- rep(0,n)
up &lt;- rep(1,n)

## Find the roots of ff, first using mroot and
## then by using uniroot inside a loop.

system.time(mr &lt;- mroot(ff, lower = low, upper = up, a = a))

ur &lt;- rep(0,n)
system.time({
for(i in 1:n) {
   ur[i] &lt;- uniroot(ff, lower = 0, upper = 1, a = a[i])$root    
}
})

</code></pre>

<hr>
<h2 id='NBA1314'>
National Basketball Association, free throw data, 2013-2014 season
</h2><span id='topic+NBA1314'></span>

<h3>Description</h3>

<p>Free throw statistics on 482 active players, 2013-2014 season</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(NBA1314)</code></pre>


<h3>Format</h3>

<p>A data frame with 482 players (rows) variables including.
</p>

<dl>
<dt><code>RK</code></dt><dd><p>rank of player by proportion of free throws made</p>
</dd>
<dt><code>PLAYER</code></dt><dd><p>name of player</p>
</dd> 
<dt><code>TEAM</code></dt><dd><p>player's team</p>
</dd>
<dt><code>GP</code></dt><dd><p>games played</p>
</dd>
<dt><code>PPG</code></dt><dd><p>points per game</p>
</dd> 
<dt><code>FTM0</code></dt><dd><p>FTM/GP</p>
</dd>
<dt><code>FTA0</code></dt><dd><p>FTA/GP</p>
</dd>
<dt><code>FTA</code></dt><dd><p>free throws attempted</p>
</dd> 
<dt><code>FTM</code></dt><dd><p>free throws made</p>
</dd> 
<dt><code>FTprop</code></dt><dd><p>FTA/FTM</p>
</dd> 
</dl>



<h3>Details</h3>

<p>Data obtained from ESPN.
</p>


<h3>References</h3>

<p>See data analyzed in Henderson and Newton, 2015</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(NBA1314)
nba.dat &lt;- cbind(NBA1314$FTM, NBA1314$FTA)
rownames(nba.dat) &lt;- NBA1314$PLAYER

rvals.nba &lt;- rvalues(nba.dat, family=binomial)
</code></pre>

<hr>
<h2 id='npmixapply'>
Apply Functions over estimated unit-specific posterior
distributions
</h2><span id='topic+npmixapply'></span>

<h3>Description</h3>

<p>Using a nonparametric estimate of the mixing distribution, computes
a posterior quantity of interest for each unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>npmixapply(object, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="npmixapply_+3A_object">object</code></td>
<td>
 
<p>an object of class &quot;npmix&quot;
</p>
</td></tr>
<tr><td><code id="npmixapply_+3A_fun">FUN</code></td>
<td>

<p>a user provided function
</p>
</td></tr>
<tr><td><code id="npmixapply_+3A_...">...</code></td>
<td>

<p>optional arguments to FUN  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>object</code> is an object of class &quot;npmix&quot; containing 
a nonparametric estimate of the mixing distribution <code class="reqn">F</code>
in the following two-level sampling model
<code class="reqn"> X_i|\theta_i</code> ~ <code class="reqn">p(x|\theta_i,\eta_i)</code>
and <code class="reqn">\theta_i</code> ~ <code class="reqn">F</code> for <code class="reqn">i = 1,...,n</code>.
</p>
<p>Using <code>npmixapply(object, f)</code>, then returns the 
posterior expectation of <code class="reqn">f</code>:
<code class="reqn"> E[ f(\theta_i) | X_i, \eta_i] </code>, for <code class="reqn">i = 1,...,n</code>.  
</p>


<h3>Value</h3>

<p>a vector with length equal to <code class="reqn">n</code>
</p>


<h3>Author(s)</h3>

<p>Nicholas Henderson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+npmle">npmle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(hiv)
npobj &lt;- npmle(hiv, family = gaussian, maxiter = 4)

### Compute unit-specific posterior means
pmean &lt;- npmixapply(npobj, function(x) { x })

### Compute post. prob that \theta_i &lt; .1
pp &lt;- npmixapply(npobj, function(x) { x &lt; .1})

## End(Not run)
</code></pre>

<hr>
<h2 id='npmle'>
Maximum Likelihood Estimate of a Mixing Distribution.
</h2><span id='topic+npmle'></span>

<h3>Description</h3>

<p>Estimates the mixture distribution nonparametrically using an EM algorithm.
The estimate is discrete with the results being returned as a vector of support
points and a vector of associated mixture probabilities.
The available choices for the sampling distribution include: Normal, Poisson, Binomial
and t-distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>npmle(data, family = gaussian, maxiter = 500, tol = 1e-4,
      smooth = TRUE, bass = 0, nmix = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="npmle_+3A_data">data</code></td>
<td>

<p>A data frame or a matrix with the number of rows equal
to the number of sampling units. The first column should
contain the main estimates, and the second column should
contain the nuisance terms.
</p>
</td></tr>
<tr><td><code id="npmle_+3A_family">family</code></td>
<td>

<p>family determining the sampling distribution (see <cite><a href="stats.html#topic+family">family</a></cite>)
</p>
</td></tr>
<tr><td><code id="npmle_+3A_maxiter">maxiter</code></td>
<td>

<p>the maximum number of EM iterations
</p>
</td></tr>
<tr><td><code id="npmle_+3A_tol">tol</code></td>
<td>

<p>the convergence tolerance
</p>
</td></tr>
<tr><td><code id="npmle_+3A_smooth">smooth</code></td>
<td>

<p>logical; whether or not to smooth the estimated cdf
</p>
</td></tr>
<tr><td><code id="npmle_+3A_bass">bass</code></td>
<td>

<p>controls the smoothness level; only relevant if <code>smooth=TRUE</code>. 
Values of up to 10 indicate increasing smoothness.
</p>
</td></tr>
<tr><td><code id="npmle_+3A_nmix">nmix</code></td>
<td>

<p>optional; the number of mixture components
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assuming the following two-level sampling model
<code class="reqn"> X_i|\theta_i</code> ~ <code class="reqn">p(x|\theta_i,\eta_i)</code>
and <code class="reqn">\theta_i</code> ~ <code class="reqn">F</code> for <code class="reqn">i = 1,...,n</code>.
The function <code>npmle</code> seeks to find an estimate of the mixing distribution
<code class="reqn">F</code> which maximizes the marginal log-likelihood 
</p>
<p style="text-align: center;"><code class="reqn">
l(F) = \sum_i \int p( X_i |\theta, \eta_i) dF(\theta).
</code>
</p>

<p>The distribution function maximizing <code class="reqn">l(F)</code> is
known to be discrete; and thus, the estimated mixture distribution is
returned as a set of support points and associated mixture
probabilities.
</p>


<h3>Value</h3>

<p>An object of class npmix which is a list containing at least 
the following components 
</p>
<table>
<tr><td><code>support</code></td>
<td>
<p>a vector of estimated support points</p>
</td></tr>
<tr><td><code>mix.prop</code></td>
<td>
<p>a vector of estimated mixture proportions</p>
</td></tr>
<tr><td><code>Fhat</code></td>
<td>
<p> a function; obtained through interpolation of
the estimated discrete cdf</p>
</td></tr>
<tr><td><code>fhat</code></td>
<td>
<p> a function; estimate of the mixture density</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p> value of the log-likelihood at each iteration</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p> 0 indicates convergence; 1 indicates
that convergence was not achieved</p>
</td></tr>
<tr><td><code>numiter</code></td>
<td>
<p>the number of EM iterations required</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicholas Henderson and Michael Newton
</p>


<h3>References</h3>

<p>Laird, N.M. (1978), Nonparametric maximum likelihood estimation of a 
mixing distribution, <em>Journal of the American Statistical Association</em>, <b>73</b>, 805&ndash;811. 
</p>
<p>Lindsay, B.G. (1983), The geometry of mixture likelihoods: a general theory. <em>The
Annals of Statistics</em>, <b>11</b>, 86&ndash;94
</p>


<h3>See Also</h3>

<p><code><a href="#topic+npmixapply">npmixapply</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(hiv)
npobj &lt;- npmle(hiv, family = tdist(df=6), maxiter = 25)


###  Generate Binomial data with Beta mixing distribution
n &lt;- 3000
theta &lt;- rbeta(n, shape1 = 2, shape2 = 10)
ntrials &lt;- rpois(n, lambda = 10)
x &lt;- rbinom(n, size = ntrials, prob = theta)

###  Estimate mixing distribution 
dd &lt;- cbind(x,ntrials)
npest &lt;- npmle(dd, family = binomial, maxiter = 25)

### compare with true mixture cdf
tt &lt;- seq(1e-4,1 - 1e-4, by = .001)
plot(npest, lwd = 2)
lines(tt, pbeta(tt, shape1 = 2, shape2 = 10), lwd = 2, lty = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='OverlapCurve'>
Overlap Curve
</h2><span id='topic+OverlapCurve'></span>

<h3>Description</h3>

<p>Estimates the expected proportion of units in the top fraction
and those deemed to be in the top fraction by the r-value
procedure. If plot=TRUE, the curve is plotted before the
estimated function is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OverlapCurve(object, plot = TRUE, xlim, ylim, xlab, ylab, main, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OverlapCurve_+3A_object">object</code></td>
<td>

<p>An object of class &quot;rvals&quot;
</p>
</td></tr>
<tr><td><code id="OverlapCurve_+3A_plot">plot</code></td>
<td>

<p>logical. If TRUE, the estimated overlap curve is plotted.
</p>
</td></tr>
<tr><td><code id="OverlapCurve_+3A_xlim">xlim</code>, <code id="OverlapCurve_+3A_ylim">ylim</code></td>
<td>

<p>x and y - axis limits for the plot
</p>
</td></tr>
<tr><td><code id="OverlapCurve_+3A_xlab">xlab</code>, <code id="OverlapCurve_+3A_ylab">ylab</code></td>
<td>

<p>x and y - axis labels
</p>
</td></tr>
<tr><td><code id="OverlapCurve_+3A_main">main</code></td>
<td>

<p>the title of the plot
</p>
</td></tr>
<tr><td><code id="OverlapCurve_+3A_...">...</code></td>
<td>

<p>additional arguments to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For parameters of interest <code class="reqn">\theta_1,...,\theta_n</code> and corresponding
r-values <code class="reqn">r_1,...,r_n</code>, the overlap at a particular value of <code class="reqn">\alpha</code> 
is defined to be 
</p>
<p style="text-align: center;"><code class="reqn"> overlap(\alpha) = P(\theta_i \ge \theta_\alpha, r_i \le \alpha), </code>
</p>

<p>where the threshold <code class="reqn">\theta_\alpha</code> is the upper-<code class="reqn">\alpha</code>th quantile of 
the distribution of the <code class="reqn">\theta_i</code> (i.e., <code class="reqn">P(\theta_i \ge \theta_\alpha) = \alpha</code>).
<code>OverlapCurve</code> estimates this overlap
for values of alpha across (0,1) and plots (if <code>plot=TRUE</code>)
the resulting curve.
</p>


<h3>Value</h3>

<p>A function returning estimated overlap values.
</p>


<h3>Author(s)</h3>

<p>Nicholas Henderson and Michael Newton
</p>


<h3>References</h3>

<p>Henderson, N.C. and Newton, M.A. (2016). <em>Making the cut: improved ranking and selection
for large-scale inference</em>. J. Royal Statist. Soc. B., 78(4), 781-804.
doi: <a href="https://doi.org/10.1111/rssb.12131">10.1111/rssb.12131</a>
<a href="https://arxiv.org/abs/1312.5776">https://arxiv.org/abs/1312.5776</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 500
theta &lt;- rnorm(n)
ses &lt;- sqrt(rgamma(n,shape=1,scale=1))
XX &lt;- theta + ses*rnorm(n)
dd &lt;- cbind(XX,ses)

rvs &lt;- rvalues(dd, family = gaussian)

OverlapCurve(rvs, cex.main = 1.5)
</code></pre>

<hr>
<h2 id='PostPercentile'>
Posterior expected percentiles
</h2><span id='topic+PostPercentile'></span>

<h3>Description</h3>

<p>Computes posterior expected percentiles for both parametric
and nonparametric models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PostPercentile(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PostPercentile_+3A_object">object</code></td>
<td>

<p>An object of class &quot;rvals&quot;
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With parameters of interest <code class="reqn">\theta_1,...,\theta_n</code> the rank of 
the ith parameter (when we set the ranking so that the largest <code class="reqn">\theta_i</code>
gets rank 1) is defined as <code class="reqn"> rank(\theta_i) = sum_j(\theta_j \ge \theta_i)</code> 
and the associated percentile is 
<code class="reqn"> perc(\theta_i) = rank(\theta_i)/(n+1).</code> The posterior expected percentile 
for the ith unit (see e.g., Lin et. al. (2006)) is simply
the expected value of <code class="reqn">perc(\theta_i)</code> given the data.
</p>
<p>The function <code>PostPercentile</code> computes an asymptotic version of the 
posterior expected percentile, which is defined as 
</p>
<p style="text-align: center;"><code class="reqn"> P(\theta_i \le \theta|data),</code>
</p>

<p>where <code class="reqn">\theta</code> has the same distribution as <code class="reqn">\theta_i</code> and is 
independent of both <code class="reqn">\theta_i</code> and the data.  
See Henderson and Newton (2014) for additional details.
</p>


<h3>Value</h3>

<p>A vector of estimated posterior expected percentiles.
</p>


<h3>Author(s)</h3>

<p>Nicholas Henderson and Michael Newton
</p>


<h3>References</h3>

<p>Henderson, N.C. and Newton, M.A. (2016). <em>Making the cut: improved ranking and selection
for large-scale inference</em>. J. Royal Statist. Soc. B., 78(4), 781-804.
doi: <a href="https://doi.org/10.1111/rssb.12131">10.1111/rssb.12131</a>
<a href="https://arxiv.org/abs/1312.5776">https://arxiv.org/abs/1312.5776</a>
</p>
<p>Lin, R., Louis, T.A., Paddock, S.M., and Ridgeway, G. (2006). Loss function based
ranking in two-stage, hierarchical models. <em>Bayesian Analysis</em>, <b>1</b>, 
915&ndash;946.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rvalues">rvalues</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 3000
theta &lt;- rnorm(n, sd = 3)
ses &lt;- sqrt(rgamma(n, shape = 1, scale = 1))
XX &lt;- theta + ses*rnorm(n)
dd &lt;- cbind(XX,ses)

rv &lt;- rvalues(dd, family = gaussian)

perc &lt;- PostPercentile(rv)
plot(rv$rvalues, perc)
</code></pre>

<hr>
<h2 id='PostSummaries'>
R-values from posterior summary quantities
</h2><span id='topic+PostSummaries'></span>

<h3>Description</h3>

<p>Computes r-values assuming that, for each parameter of interest, the
user supplies a value for the posterior mean and the 
posterior standard deviation. The assumption here is
that the posterior distributions are Normal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PostSummaries(post.means, post.sds, hypers = NULL, qtheta = NULL, alpha.grid = NULL, 
               ngrid = NULL, smooth = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PostSummaries_+3A_post.means">post.means</code></td>
<td>

<p>a vector of posterior means
</p>
</td></tr>
<tr><td><code id="PostSummaries_+3A_post.sds">post.sds</code></td>
<td>

<p>a vector of posterior standard deviations
</p>
</td></tr>
<tr><td><code id="PostSummaries_+3A_hypers">hypers</code></td>
<td>

<p>a list with two elements: mean and sd. These represent
the parameters in the (Normal) prior which was used
to generate the posterior means and sds. If hypers
is not supplied then one must supply the quantile
function qtheta.
</p>
</td></tr>
<tr><td><code id="PostSummaries_+3A_qtheta">qtheta</code></td>
<td>

<p>a function which returns the quantiles (for upper tail probs.) of 
theta. If this is not supplied,
the hyperparameter must be supplied.
</p>
</td></tr>
<tr><td><code id="PostSummaries_+3A_alpha.grid">alpha.grid</code></td>
<td>

<p>grid of values in (0,1); used for the discrete approximation
approach for computing r-values.
</p>
</td></tr>
<tr><td><code id="PostSummaries_+3A_ngrid">ngrid</code></td>
<td>

<p>number of grid points for alpha.grid; only relevant when <code>alpha.grid = NULL</code>
</p>
</td></tr>
<tr><td><code id="PostSummaries_+3A_smooth">smooth</code></td>
<td>

<p>either <code>smooth="none"</code> or <code>smooth</code> takes 
a value between 0 and 10; this determines the level of smoothing applied to the
estimate of <code class="reqn">\lambda(\alpha)</code>; if <code>smooth</code> is given a number, the
number is used as the <code>bass</code> argument in <code><a href="stats.html#topic+supsmu">supsmu</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;rvals&quot;
</p>


<h3>Author(s)</h3>

<p>Nicholas Henderson and Michael Newton
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rvalues">rvalues</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 500
theta &lt;- rnorm(n)
sig_sq &lt;- rgamma(n,shape=1,scale=1)
X &lt;- theta + sqrt(sig_sq)*rnorm(n)

pm &lt;- X/(sig_sq + 1)
psd &lt;- sqrt(sig_sq/(sig_sq + 1))

rvs &lt;- PostSummaries(post.means=pm,post.sds=psd,hypers=list(mean=0,sd=1))
hist(rvs$rvalues)
</code></pre>

<hr>
<h2 id='rvalueBoot'>
Bootstrapped r-values
</h2><span id='topic+rvalueBoot'></span>

<h3>Description</h3>

<p>Estimates a new prior for each bootstrap replications ... (need to add) 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvalueBoot(object, statistic = median, R, type = "nonparametric")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rvalueBoot_+3A_object">object</code></td>
<td>

<p>An object of class &quot;rvals&quot;
</p>
</td></tr>
<tr><td><code id="rvalueBoot_+3A_statistic">statistic</code></td>
<td>

<p>The statistic used to summarize the bootstrap replicates.
</p>
</td></tr>
<tr><td><code id="rvalueBoot_+3A_r">R</code></td>
<td>

<p>Number of bootstrap replicates
</p>
</td></tr>
<tr><td><code id="rvalueBoot_+3A_type">type</code></td>
<td>

<p>Either <code>type="nonparametric"</code> or <code>type="parametric"</code>; the nonparametric type
corresponds to the usual bootstrap where units are sampled with replacement.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>type="nonparametric"</code>, the prior is re-estimated (using the resampled data) 
in each bootstrap replication, and r-values are re-computed with respect to this new model.
</p>
<p>When <code>type="parametric"</code>, 
</p>


<h3>Value</h3>

<p>A list with the following two components
</p>
<table>
<tr><td><code>rval.repmat</code></td>
<td>
<p> A matrix where each column corresponds to a separate bootstrap replication.    </p>
</td></tr>
<tr><td><code>rval.boot</code></td>
<td>
<p>A vector of r-values obtained by applying the statistic to each row
of <code>rval.repmat</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicholas Henderson and Michael Newton
</p>


<h3>References</h3>

<p>Henderson, N.C. and Newton, M.A. (2016). <em>Making the cut: improved ranking and selection
for large-scale inference</em>. J. Royal Statist. Soc. B., 78(4), 781-804.
doi: <a href="https://doi.org/10.1111/rssb.12131">10.1111/rssb.12131</a>
<a href="https://arxiv.org/abs/1312.5776">https://arxiv.org/abs/1312.5776</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rvalues">rvalues</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n &lt;- 3000
theta &lt;- rnorm(n, sd = 3)
ses &lt;- sqrt(rgamma(n, shape = 10, rate = 1))
XX &lt;- theta + ses*rnorm(n)
dd &lt;- cbind(XX,ses)

rv &lt;- rvalues(dd, family = gaussian, prior = "conjugate")

rvb &lt;- rvalueBoot(rv, R = 10) 
summary(rvb$rval.repmat[512,])

## End(Not run)
</code></pre>

<hr>
<h2 id='rvalues'>
R-values
</h2><span id='topic+rvalues'></span>

<h3>Description</h3>

<p>Given data on a collection of units, this
function computes
r-values which are percentiles constructed
to maximize the agreement between the reported
percentiles and the percentiles of the effect of
interest. Additional details about r-values are provided below and can also be found
in the listed references.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvalues(data, family = gaussian, hypers = "estimate", prior = "conjugate",
       alpha.grid = NULL, ngrid = NULL, smooth = "none", control = list()) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rvalues_+3A_data">data</code></td>
<td>
<p>A data frame or a matrix with the number of rows equal to the number of sampling units. 
The first column should contain the main estimates, and the second column should contain 
the nuisance terms.</p>
</td></tr>
<tr><td><code id="rvalues_+3A_family">family</code></td>
<td>
<p>An argument which determines the sampling distribution; this could be either
<code>family = gaussian</code>, <code>family = tdist</code>, <code>family = binomial</code>,
<code>family = poisson</code></p>
</td></tr>
<tr><td><code id="rvalues_+3A_hypers">hypers</code></td>
<td>
<p>values of the hyperparameters; only meaningful when the conjugate prior is used; if set to &quot;estimate&quot;, 
the hyperparameters are found through maximum likelihood; if not set to &quot;estimate&quot; the user
should supply a vector of length two.</p>
</td></tr>
<tr><td><code id="rvalues_+3A_prior">prior</code></td>
<td>
<p>the form of the prior; either <code>prior="conjugate"</code> or <code>prior="nonparametric"</code>.</p>
</td></tr>
<tr><td><code id="rvalues_+3A_alpha.grid">alpha.grid</code></td>
<td>
<p>a numeric vector of points in (0,1); this grid is used in the 
discrete approximation of r-values</p>
</td></tr>
<tr><td><code id="rvalues_+3A_ngrid">ngrid</code></td>
<td>
<p>number of grid points for alpha.grid; only relevant when <code>alpha.grid=NULL</code></p>
</td></tr>
<tr><td><code id="rvalues_+3A_smooth">smooth</code></td>
<td>
<p>either <code>smooth="none"</code> or <code>smooth</code> takes 
a value between 0 and 10; this determines the level of smoothing applied to the
estimate of <code class="reqn">\lambda(\alpha)</code> (see below for the definition of
<code class="reqn">\lambda(\alpha)</code>); if <code>smooth</code> is given a number, the
number is used as the <code>bass</code> argument in <code><a href="stats.html#topic+supsmu">supsmu</a></code>.</p>
</td></tr>
<tr><td><code id="rvalues_+3A_control">control</code></td>
<td>
<p>a list of control parameters for estimation of the prior; only used 
when the prior is nonparametric</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The r-value computation assumes the following two-level sampling model
<code class="reqn"> X_i|\theta_i</code> ~ <code class="reqn">p(x|\theta_i,\eta_i)</code>
and <code class="reqn">\theta_i</code> ~ <code class="reqn">F</code>, for <code class="reqn">i = 1,...,n</code>,
with parameters of interest <code class="reqn">\theta_i</code>, effect size estimates <code class="reqn">X_i</code>,
and nuisance terms <code class="reqn">\eta_i</code>. The form of <code class="reqn">p(x|\theta_i,\eta_i)</code> is determined
by the <code>family</code> argument. When <code>family = gaussian</code>, it is assumed that
<code class="reqn">X_i|\theta_i,\eta_i</code> ~ N(<code class="reqn">\theta_i,\eta_i^{2})</code>.
When <code>family = binomial</code>, the <code class="reqn">(X_i,\eta_i)</code> represent the number of successes
and number of trials respectively, and it is assumed that <code class="reqn">X_i|\theta_i,\eta_i</code> ~
Binomial<code class="reqn">(\theta_i,\eta_i)</code>. When <code>family = poisson</code>, the <code class="reqn">{X_i}</code> should be
counts, and it is assumed that <code class="reqn">X_i|\theta_i,\eta_i</code> ~ Poisson(<code class="reqn">\theta_i * \eta_i)</code>. 
</p>
<p>The distribution of the effect sizes <code class="reqn">F</code> may be a parametric distribution
that is conjugate to the corresponding <code>family</code> argument,
or it may be estimated nonparametrically. When it is desired that <code class="reqn">F</code> be
parametric (i.e., <code>prior = "conjugate"</code>), the default is to estimate the 
hyperparameters (i.e., <code>hypers = "estimate"</code>), but these may be supplied by the 
user as a vector of length two. To estimate <code class="reqn">F</code> nonparametrically, one
should use <code>prior = "nonparametric"</code> (see <code><a href="#topic+npmle">npmle</a></code> for
further details about nonparametric estimation of <code class="reqn">F</code>).
</p>
<p>The <em>r-value</em>, <code class="reqn">r_i</code>, assigned to the ith case of interest is determined by
<code class="reqn">  r_i = </code> inf[ <code class="reqn">0 &lt; \alpha &lt; 1: V_\alpha(X_i,\eta_i) \ge \lambda(\alpha) </code> ]
where <code class="reqn">V_\alpha(X_i,\eta_i) = P( \theta_i \ge \theta_\alpha|X_i,\eta_i) </code>
is the posterior probability that <code class="reqn">\theta_i</code> exceeds the threshold <code class="reqn">\theta_\alpha</code>,
and <code class="reqn">\lambda(\alpha)</code> is the upper-<code class="reqn">\alpha</code>th quantile associated
with the marginal distribution of <code class="reqn">V_\alpha(X_i,\eta_i)</code> (i.e., 
<code class="reqn"> P(V_\alpha(X_i,\eta_i) \ge \lambda(\alpha)) = \alpha). </code> Similarly, 
the threshold <code class="reqn">\theta_\alpha</code> is the upper-<code class="reqn">\alpha</code>th quantile of 
<code class="reqn">F</code> (i.e., <code class="reqn">P(\theta_i \ge \theta_\alpha) = \alpha</code> ). 
</p>


<h3>Value</h3>

<p>An object of class &quot;rvals&quot; which is a list containing at least the following components:
</p>
<table>
<tr><td><code>main</code></td>
<td>
<p>a data frame containing the r-values, the r-value rankings along with
the rankings from several other common procedures</p>
</td></tr>
<tr><td><code>aux</code></td>
<td>
<p>a list containing other extraneous information</p>
</td></tr>
<tr><td><code>rvalues</code></td>
<td>
<p>a vector of r-values</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicholas C. Henderson and Michael A. Newton
</p>


<h3>References</h3>

<p>Henderson, N.C. and Newton, M.A. (2016). <em>Making the cut: improved ranking and selection
for large-scale inference</em>. J. Royal Statist. Soc. B., 78(4), 781-804.
doi: <a href="https://doi.org/10.1111/rssb.12131">10.1111/rssb.12131</a>
<a href="https://arxiv.org/abs/1312.5776">https://arxiv.org/abs/1312.5776</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rvaluesMCMC">rvaluesMCMC</a></code>, <code><a href="#topic+PostSummaries">PostSummaries</a></code>, <code><a href="#topic+Valpha">Valpha</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Binomial example with Beta prior:
data(fluEnrich)
flu.rvals &lt;- rvalues(fluEnrich, family = binomial)
hist(flu.rvals$rvalues)

### look at the r-values for indices 10 and 2484
fig_indices  &lt;- c(10,2484)
fluEnrich[fig_indices,]

flu.rvals$rvalues[fig_indices]

### Gaussian sampling distribution with nonparametric prior
### Use a maximum of 5 iterations for the nonparam. estimate
data(hiv)
hiv.rvals &lt;- rvalues(hiv, prior = "nonparametric")

## End(Not run)
</code></pre>

<hr>
<h2 id='rvaluesMCMC'>
R-values from MCMC output.
</h2><span id='topic+rvaluesMCMC'></span>

<h3>Description</h3>

<p>Returns r-values from an array of MCMC output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvaluesMCMC(output, qtheta, alpha.grid = NULL, ngrid = NULL, smooth = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rvaluesMCMC_+3A_output">output</code></td>
<td>

<p>a matrix contatining mcmc ouput. The ith row should
represent a sample from the posterior of the ith parameter
of interest. 
</p>
</td></tr>
<tr><td><code id="rvaluesMCMC_+3A_qtheta">qtheta</code></td>
<td>

<p>either a function which returns the quantiles (for upper tail probs.) of 
theta or a vector of theta-quantiles. 
</p>
</td></tr>
<tr><td><code id="rvaluesMCMC_+3A_alpha.grid">alpha.grid</code></td>
<td>

<p>grid of values in (0,1); used for the discrete approximation
approach for computing r-values.
</p>
</td></tr>
<tr><td><code id="rvaluesMCMC_+3A_ngrid">ngrid</code></td>
<td>

<p>number of grid points for alpha.grid; only relevant when <code>alpha.grid = NULL</code>
</p>
</td></tr>
<tr><td><code id="rvaluesMCMC_+3A_smooth">smooth</code></td>
<td>

<p>either <code>smooth="none"</code> or <code>smooth</code> takes 
a value between 0 and 10; this determines the level of smoothing applied to the
estimate of <code class="reqn">\lambda(\alpha)</code>; if <code>smooth</code> is given a number, the
number is used as the <code>bass</code> argument in <code><a href="stats.html#topic+supsmu">supsmu</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;rvals&quot; which is a list containing at least the following components:
</p>
<table>
<tr><td><code>main</code></td>
<td>
<p>a data frame containing the r-values, the r-value rankings along with
the rankings from several other common procedures</p>
</td></tr>
<tr><td><code>aux</code></td>
<td>
<p>a list containing other extraneous information</p>
</td></tr>
<tr><td><code>rvalues</code></td>
<td>
<p>a vector of r-values</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicholas Henderson and Michael Newton
</p>


<h3>References</h3>

<p>Henderson, N.C. and Newton, M.A. (2016). <em>Making the cut: improved ranking and selection
for large-scale inference</em>. J. Royal Statist. Soc. B., 78(4), 781-804.
doi: <a href="https://doi.org/10.1111/rssb.12131">10.1111/rssb.12131</a>
<a href="https://arxiv.org/abs/1312.5776">https://arxiv.org/abs/1312.5776</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rvalues">rvalues</a></code>, <code><a href="#topic+PostSummaries">PostSummaries</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MCMCtest)

### For the MCMC output in MCMC_test, the prior assumed for the effect sizes of 
### interest was a mixture of two t-distributions. The function qthetaTMix 
### computes the quantiles for this prior.

qthetaTMix &lt;- function(p) {
    ### function to compute quantiles (for upper tail probabilities) for a 
    ###  mixture of two t-distributions
    mu &lt;- c(.35,-.12)
    sig &lt;- c(.2,.08)
    mix.prop &lt;- c(.25,.75)

    ff &lt;- function(x,pp) {
        prob_less &lt;- 0
        for(k in 1:2) {
            prob_less &lt;- prob_less + pt((x - mu[k])/sig[k],df=4,lower.tail=FALSE)*mix.prop[k] 
        }
        return(prob_less - pp)
    }

    nn &lt;- length(p)
    ans &lt;- numeric(nn)
    for(i in 1:nn) {
        ans[i] &lt;- uniroot(ff,interval=c(-5,5),tol=1e-6,pp=p[i])$root
    }
    return(ans)
}

rvs &lt;- rvaluesMCMC(MCMCtest, qtheta = qthetaTMix)
</code></pre>

<hr>
<h2 id='tdist'>
t-distribution family object
</h2><span id='topic+tdist'></span>

<h3>Description</h3>

<p>A t-distribution family object which allows one to specify
a t-density for the sampling distribution. Modeled after <code><a href="stats.html#topic+family">family</a></code> objects
often used in the glm function. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tdist(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tdist_+3A_df">df</code></td>
<td>

<p>vector containing the degrees of freedom
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"newfam"</code>, which is a list
containing the following components
</p>
<table>
<tr><td><code>family</code></td>
<td>
<p>The family name</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The degrees of freedom</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicholas Henderson and Michael Newton
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+family">family</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="#topic+npmle">npmle</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- tdist(df=5)
</code></pre>

<hr>
<h2 id='TopList'>
List of Top Units
</h2><span id='topic+TopList'></span>

<h3>Description</h3>

<p>Returns a list of the top units ranked according
to &quot;r-value&quot; or another specified statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TopList(object, topnum = 10, sorted.by = c("RValue","PostMean","MLE","PVal"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TopList_+3A_object">object</code></td>
<td>

<p>An object of class &quot;rvals&quot;
</p>
</td></tr>
<tr><td><code id="TopList_+3A_topnum">topnum</code></td>
<td>

<p>The length of the top list.
</p>
</td></tr>
<tr><td><code id="TopList_+3A_sorted.by">sorted.by</code></td>
<td>

<p>The statistic by which to sort; this could be <code>sorted.by = "RValue"</code>,
<code>sorted.by = "PostMean"</code>, <code>sorted.by = "MLE"</code>, or
<code>sorted.by = "PVal"</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with <code>topnum</code> rows and columns containing the
r-value, mle, posterior mean, and p-value rankings.
</p>


<h3>Author(s)</h3>

<p>Nicholas Henderson and Michael Newton
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rvalues">rvalues</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 500
theta &lt;- rnorm(n)
ses &lt;- sqrt(rgamma(n,shape=1,scale=1))
XX &lt;- theta + ses*rnorm(n)
dd &lt;- cbind(XX,ses)

rvs &lt;- rvalues(dd, family = gaussian)

TopList(rvs, topnum = 12)
TopList(rvs, topnum = 15, sorted.by = "MLE")

</code></pre>

<hr>
<h2 id='Valpha'>
R-values from a matrix of posterior tail probabilities.
</h2><span id='topic+Valpha'></span>

<h3>Description</h3>

<p>Computes r-values directly from a &quot;Valpha&quot; matrix V where each
column of Valpha contains posterior tail probabilities relative
to a threshold indexed by alpha. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Valpha(V, alpha.grid, smooth = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Valpha_+3A_v">V</code></td>
<td>
<p>a numeric vector with (i,j) entry: V[i,j] = P(theta_i &gt;= theta[alpha_j]|data) </p>
</td></tr>
<tr><td><code id="Valpha_+3A_alpha.grid">alpha.grid</code></td>
<td>
<p>grid of values in (0,1); used for the discrete approximation
approach for computing r-values.</p>
</td></tr>
<tr><td><code id="Valpha_+3A_smooth">smooth</code></td>
<td>
<p>either <code>smooth="none"</code> or <code>smooth</code> takes 
a value between 0 and 10; this determines the level of smoothing applied to the
estimate of <code class="reqn">\lambda(\alpha)</code>; if <code>smooth</code> is given a number, the
number is used as the <code>bass</code> argument in <code><a href="stats.html#topic+supsmu">supsmu</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components
</p>
<table>
<tr><td><code>rvalues</code></td>
<td>
<p>a vector of computed r-values</p>
</td></tr>
<tr><td><code>Vmarginals</code></td>
<td>
<p>The estimated V-marginals along the alpha grid points</p>
</td></tr>
<tr><td><code>Vmarginals.smooth</code></td>
<td>
<p>a function obtained through interpolation
and smoothing (if desired) the Vmarginals; i.e., an estimate of
<code class="reqn">\lambda(\alpha)</code> (see <code><a href="#topic+rvalues">rvalues</a></code>)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicholas Henderson and Michael Newton
</p>


<h3>References</h3>

<p>Henderson, N.C. and Newton, M.A. (2016). <em>Making the cut: improved ranking and selection
for large-scale inference</em>. J. Royal Statist. Soc. B., 78(4), 781-804.
doi: <a href="https://doi.org/10.1111/rssb.12131">10.1111/rssb.12131</a>
<a href="https://arxiv.org/abs/1312.5776">https://arxiv.org/abs/1312.5776</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rvalues">rvalues</a></code>  <code><a href="#topic+rvaluesMCMC">rvaluesMCMC</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fluEnrich)
rvobj &lt;- rvalues(fluEnrich, family = binomial)

Vrvals &lt;- Valpha(rvobj$aux$V, rvobj$aux$alpha.grid)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
