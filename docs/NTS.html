<!DOCTYPE html><html lang="en"><head><title>Help for package NTS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {NTS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ACMx'><p>Estimation of Autoregressive Conditional Mean Models</p></a></li>
<li><a href='#backTAR'><p>Backtest for Univariate TAR Models</p></a></li>
<li><a href='#backtest'><p>Backtest</p></a></li>
<li><a href='#clutterKF'><p>Kalman Filter for Tracking in Clutter</p></a></li>
<li><a href='#cvlm'><p>Check linear models with cross validation</p></a></li>
<li><a href='#est_cfar'><p>Estimation of a CFAR Process</p></a></li>
<li><a href='#est_cfarh'><p>Estimation of a CFAR Process with Heteroscedasticity and Irregualar Observation Locations</p></a></li>
<li><a href='#F_test_cfar'><p>F Test for a CFAR Process</p></a></li>
<li><a href='#F_test_cfarh'><p>F Test for a CFAR Process with Heteroscedasticity and Irregular Observation Locations</p></a></li>
<li><a href='#F.test'><p>F Test for Nonlinearity</p></a></li>
<li><a href='#g_cfar'><p>Generate a CFAR Process</p></a></li>
<li><a href='#g_cfar1'><p>Generate a CFAR(1) Process</p></a></li>
<li><a href='#g_cfar2'><p>Generate a CFAR(2) Process</p></a></li>
<li><a href='#g_cfar2h'><p>Generate a CFAR(2) Process with Heteroscedasticity and Irregular Observation Locations</p></a></li>
<li><a href='#hfDummy'><p>Create Dummy Variables for High-Frequency Intraday Seasonality</p></a></li>
<li><a href='#MKF.Full.RB'><p>Full Information Propagation Step under Mixture Kalman Filter</p></a></li>
<li><a href='#MKFstep.fading'><p>One Propagation Step under Mixture Kalman Filter for Fading Channels</p></a></li>
<li><a href='#MSM.fit'><p>Fitting Univariate Autoregressive Markov Switching Models</p></a></li>
<li><a href='#MSM.sim'><p>Generate Univariate 2-regime Markov Switching Models</p></a></li>
<li><a href='#mTAR'><p>Estimation of a Multivariate Two-Regime SETAR Model</p></a></li>
<li><a href='#mTAR.est'><p>Estimation of Multivariate TAR Models</p></a></li>
<li><a href='#mTAR.pred'><p>Prediction of A Fitted Multivariate TAR Model</p></a></li>
<li><a href='#mTAR.sim'><p>Generate Two-Regime (TAR) Models</p></a></li>
<li><a href='#NNsetting'><p>Setting Up The Predictor Matrix in A Neural Network for Time Series Data</p></a></li>
<li><a href='#p_cfar'><p>Prediction of CFAR Processes</p></a></li>
<li><a href='#p_cfar_part'><p>Partial Curve Prediction of CFAR Processes</p></a></li>
<li><a href='#PRnd'><p>ND Test</p></a></li>
<li><a href='#rankQ'><p>Rank-Based Portmanteau Tests</p></a></li>
<li><a href='#rcAR'><p>Estimating of Random-Coefficient AR Models</p></a></li>
<li><a href='#ref.mTAR'><p>Refine A Fitted 2-Regime Multivariate TAR Model</p></a></li>
<li><a href='#simPassiveSonar'><p>Simulate A Sample Trajectory</p></a></li>
<li><a href='#simu_fading'><p>Simulate Signals from A System with Rayleigh Flat-Fading Channels</p></a></li>
<li><a href='#simuTargetClutter'><p>Simulate A Moving Target in Clutter</p></a></li>
<li><a href='#SISstep.fading'><p>Sequential Importance Sampling Step for Fading Channels</p></a></li>
<li><a href='#SMC'><p>Generic Sequential Monte Carlo Method</p></a></li>
<li><a href='#SMC.Full'><p>Generic Sequential Monte Carlo Using Full Information Proposal Distribution</p></a></li>
<li><a href='#SMC.Full.RB'><p>Generic Sequential Monte Carlo Using Full Information Proposal Distribution and Rao-Blackwellization</p></a></li>
<li><a href='#SMC.Smooth'><p>Generic Sequential Monte Carlo Smoothing with Marginal Weights</p></a></li>
<li><a href='#Sstep.Clutter'><p>Sequential Monte Carlo for A Moving Target under Clutter Environment</p></a></li>
<li><a href='#Sstep.Clutter.Full'><p>Sequential Importance Sampling under Clutter Environment</p></a></li>
<li><a href='#Sstep.Clutter.Full.RB'><p>Sequential Importance Sampling under Clutter Environment</p></a></li>
<li><a href='#Sstep.Smooth.Sonar'><p>Sequential Importance Sampling for A Target with Passive Sonar</p></a></li>
<li><a href='#Sstep.Sonar'><p>Sequential Importance Sampling Step for A Target with Passive Sonar</p></a></li>
<li><a href='#thr.test'><p>Threshold Nonlinearity Test</p></a></li>
<li><a href='#Tsay'><p>Tsay Test for Nonlinearity</p></a></li>
<li><a href='#tvAR'><p>Estimate Time-Varying Coefficient AR Models</p></a></li>
<li><a href='#tvARFiSm'><p>Filtering and Smoothing for Time-Varying AR Models</p></a></li>
<li><a href='#uTAR'><p>Estimation of a Univariate Two-Regime SETAR Model</p></a></li>
<li><a href='#uTAR.est'><p>General Estimation of TAR Models</p></a></li>
<li><a href='#uTAR.pred'><p>Prediction of A Fitted Univariate TAR Model</p></a></li>
<li><a href='#uTAR.sim'><p>Generate Univariate SETAR Models</p></a></li>
<li><a href='#wrap.SMC'><p>Sequential Monte Carlo Using Sequential Importance Sampling for Stochastic Volatility Models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Nonlinear Time Series Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Ruey Tsay [aut],
  Rong Chen [aut],
  Xialu Liu [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xialu Liu &lt;xialu.liu@sdsu.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulation, estimation, prediction procedure, and model identification methods for nonlinear time series analysis, including threshold autoregressive models, Markov-switching models, convolutional functional autoregressive models, nonlinearity tests, Kalman filters and various sequential Monte Carlo methods. More examples and details about this package can be found in the book "Nonlinear Time Series Analysis" by Ruey S. Tsay and Rong Chen, John Wiley &amp; Sons, 2018 (ISBN: 978-1-119-26407-1).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>base,dlm,graphics,MASS,MSwM,Rdpack,parallel,splines,stats,tensor</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-24 20:11:22 UTC; Xialu</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-24 21:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='ACMx'>Estimation of Autoregressive Conditional Mean Models</h2><span id='topic+ACMx'></span>

<h3>Description</h3>

<p>Estimation of autoregressive conditional mean models with exogenous variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ACMx(y, order = c(1, 1), X = NULL, cond.dist = "po", ini = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ACMx_+3A_y">y</code></td>
<td>
<p>time series of counts.</p>
</td></tr>
<tr><td><code id="ACMx_+3A_order">order</code></td>
<td>
<p>the order of ACM model.</p>
</td></tr>
<tr><td><code id="ACMx_+3A_x">X</code></td>
<td>
<p>matrix of exogenous variables.</p>
</td></tr>
<tr><td><code id="ACMx_+3A_cond.dist">cond.dist</code></td>
<td>
<p>conditional distributions. &quot;po&quot; for Poisson, &quot;nb&quot; for negative binomial, &quot;dp&quot; for double Poisson.</p>
</td></tr>
<tr><td><code id="ACMx_+3A_ini">ini</code></td>
<td>
<p>initial parameter estimates designed for use in &quot;nb&quot; and &quot;dp&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ACMx returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>time series.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>matrix of exogenous variables.</p>
</td></tr>
<tr><td><code>estimates</code></td>
<td>
<p>estimated values.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>residuals.</p>
</td></tr>
<tr><td><code>sresi</code></td>
<td>
<p>standardized residuals.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x=rnorm(1000)*0.1
y=matrix(0,1000,1)
y[1]=2
lambda=matrix(0,1000,1)
for (i in 2:1000){
	lambda[i]=2+0.2*y[i-1]/exp(x[i-1])+0.5*lambda[i-1]
	y[i]=rpois(1,exp(x[i])*lambda[i])
}
ACMx(y,order=c(1,1),x,"po")
</code></pre>

<hr>
<h2 id='backTAR'>Backtest for Univariate TAR Models</h2><span id='topic+backTAR'></span>

<h3>Description</h3>

<p>Perform back-test of a univariate SETAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>backTAR(model, orig, h = 1, iter = 3000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="backTAR_+3A_model">model</code></td>
<td>
<p>SETAR model.</p>
</td></tr>
<tr><td><code id="backTAR_+3A_orig">orig</code></td>
<td>
<p>forecast origin.</p>
</td></tr>
<tr><td><code id="backTAR_+3A_h">h</code></td>
<td>
<p>forecast horizon.</p>
</td></tr>
<tr><td><code id="backTAR_+3A_iter">iter</code></td>
<td>
<p>number of iterations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>backTAR</code> returns a list of components:
</p>
<table role = "presentation">
<tr><td><code>model</code></td>
<td>
<p>SETAR model.</p>
</td></tr>
<tr><td><code>error</code></td>
<td>
<p>prediction errors.</p>
</td></tr>
<tr><td><code>State</code></td>
<td>
<p>predicted states.</p>
</td></tr>
</table>

<hr>
<h2 id='backtest'>Backtest</h2><span id='topic+backtest'></span>

<h3>Description</h3>

<p>Backtest for an ARIMA time series model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>backtest(m1, rt, orig, h, xre = NULL, fixed = NULL, include.mean = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="backtest_+3A_m1">m1</code></td>
<td>
<p>an ARIMA time series model object.</p>
</td></tr>
<tr><td><code id="backtest_+3A_rt">rt</code></td>
<td>
<p>the time series.</p>
</td></tr>
<tr><td><code id="backtest_+3A_orig">orig</code></td>
<td>
<p>forecast origin.</p>
</td></tr>
<tr><td><code id="backtest_+3A_h">h</code></td>
<td>
<p>forecast horizon.</p>
</td></tr>
<tr><td><code id="backtest_+3A_xre">xre</code></td>
<td>
<p>the independent variables.</p>
</td></tr>
<tr><td><code id="backtest_+3A_fixed">fixed</code></td>
<td>
<p>parameter constraint.</p>
</td></tr>
<tr><td><code id="backtest_+3A_include.mean">include.mean</code></td>
<td>
<p>a logical value for constant term of the model. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with following components:
</p>
<table role = "presentation">
<tr><td><code>orig</code></td>
<td>
<p>the starting forecast origin.</p>
</td></tr>
<tr><td><code>err</code></td>
<td>
<p>observed value minus fitted value.</p>
</td></tr>
<tr><td><code>rmse</code></td>
<td>
<p>RMSE of out-of-sample forecasts.</p>
</td></tr>
<tr><td><code>mabso</code></td>
<td>
<p>mean absolute error of out-of-sample forecasts.</p>
</td></tr>
<tr><td><code>bias</code></td>
<td>
<p>bias of out-of-sample forecasts.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data=arima.sim(n=100,list(ar=c(0.5,0.3)))
model=arima(data,order=c(2,0,0))
backtest(model,data,orig=70,h=1)
</code></pre>

<hr>
<h2 id='clutterKF'>Kalman Filter for Tracking in Clutter</h2><span id='topic+clutterKF'></span>

<h3>Description</h3>

<p>This function implements Kalman filter to track a moving target under clutter environment with known indicators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clutterKF(nobs, ssw, ssv, yy, ii)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clutterKF_+3A_nobs">nobs</code></td>
<td>
<p>the number of observations.</p>
</td></tr>
<tr><td><code id="clutterKF_+3A_ssw">ssw</code></td>
<td>
<p>the standard deviation in the state equation.</p>
</td></tr>
<tr><td><code id="clutterKF_+3A_ssv">ssv</code></td>
<td>
<p>the standard deviation for the observation noise.</p>
</td></tr>
<tr><td><code id="clutterKF_+3A_yy">yy</code></td>
<td>
<p>the data.</p>
</td></tr>
<tr><td><code id="clutterKF_+3A_ii">ii</code></td>
<td>
<p>the indicators.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>xhat</code></td>
<td>
<p>the fitted location.</p>
</td></tr>
<tr><td><code>shat</code></td>
<td>
<p>the fitted speed.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tsay, R. and Chen, R. (2018). Nonlinear Time Series Analysis. John Wiley &amp; Sons, New Jersey.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nobs &lt;- 100; pd &lt;- 0.95; ssw &lt;- 0.1; ssv &lt;- 0.5;
xx0 &lt;- 0; ss0 &lt;- 0.1; nyy &lt;- 50;
yrange &lt;- c(-80,80); xdim &lt;- 2; ydim &lt;- nyy;
simu &lt;- simuTargetClutter(nobs,pd,ssw,ssv,xx0,ss0,nyy,yrange)
outKF &lt;- clutterKF(nobs,ssw,ssv,simu$yy,simu$ii)
</code></pre>

<hr>
<h2 id='cvlm'>Check linear models with cross validation</h2><span id='topic+cvlm'></span>

<h3>Description</h3>

<p>The function checks linear models with cross-validation (out-of-sample prediction).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cvlm(y, x, subsize, iter = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cvlm_+3A_y">y</code></td>
<td>
<p>dependent variable.</p>
</td></tr>
<tr><td><code id="cvlm_+3A_x">x</code></td>
<td>
<p>design matrix (should include constant if it is needed).</p>
</td></tr>
<tr><td><code id="cvlm_+3A_subsize">subsize</code></td>
<td>
<p>sample size of subsampling.</p>
</td></tr>
<tr><td><code id="cvlm_+3A_iter">iter</code></td>
<td>
<p>number of iterations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with following components.
</p>
<table role = "presentation">
<tr><td><code>rmse</code></td>
<td>
<p>root mean squares of forecast errors for all iterations.</p>
</td></tr>
<tr><td><code>mae</code></td>
<td>
<p>mean absolute forecast errors for all iterations.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tsay, R. and Chen, R. (2018). Nonlinear Time Series Analysis. John Wiley &amp; Sons, New Jersey.
</p>

<hr>
<h2 id='est_cfar'>Estimation of a CFAR Process</h2><span id='topic+est_cfar'></span>

<h3>Description</h3>

<p>Estimation of a CFAR process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_cfar(f, p = 3, df_b = 10, grid = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="est_cfar_+3A_f">f</code></td>
<td>
<p>the functional time series.</p>
</td></tr>
<tr><td><code id="est_cfar_+3A_p">p</code></td>
<td>
<p>the CFAR order.</p>
</td></tr>
<tr><td><code id="est_cfar_+3A_df_b">df_b</code></td>
<td>
<p>the degrees of freedom for natural cubic splines. Default is 10.</p>
</td></tr>
<tr><td><code id="est_cfar_+3A_grid">grid</code></td>
<td>
<p>the number of gird points used to construct the functional time series and noise process. Default is 1000.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>phi_coef</code></td>
<td>
<p>the estimated spline coefficients for convolutional function values, a (2*grid+1)-by-p matrix.</p>
</td></tr>
<tr><td><code>phi_func</code></td>
<td>
<p>the estimated convolutional function(s), a (df_b+1)-by-p matrix.</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>estimated rho for O-U process (noise process).</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>estimated sigma for O-U process (noise process).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Liu, X., Xiao, H., and Chen, R. (2016) Convolutional autoregressive models for functional time series. <em>Journal of Econometrics</em>, 194, 263-282.
</p>

<hr>
<h2 id='est_cfarh'>Estimation of a CFAR Process with Heteroscedasticity and Irregualar Observation Locations</h2><span id='topic+est_cfarh'></span>

<h3>Description</h3>

<p>Estimation of a CFAR process with heteroscedasticity and irregualar observation locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_cfarh(
  f,
  weight,
  p = 2,
  grid = 1000,
  df_b = 5,
  num_obs = NULL,
  x_pos = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="est_cfarh_+3A_f">f</code></td>
<td>
<p>the functional time series.</p>
</td></tr>
<tr><td><code id="est_cfarh_+3A_weight">weight</code></td>
<td>
<p>the covariance functions of noise process.</p>
</td></tr>
<tr><td><code id="est_cfarh_+3A_p">p</code></td>
<td>
<p>the CFAR order.</p>
</td></tr>
<tr><td><code id="est_cfarh_+3A_grid">grid</code></td>
<td>
<p>the number of gird points used to construct the functional time series and noise process. Default is 1000.</p>
</td></tr>
<tr><td><code id="est_cfarh_+3A_df_b">df_b</code></td>
<td>
<p>the degrees of freedom for natural cubic splines. Default is 10.</p>
</td></tr>
<tr><td><code id="est_cfarh_+3A_num_obs">num_obs</code></td>
<td>
<p>the numbers of observations. It is a t-by-1 vector, where t is the length of time.</p>
</td></tr>
<tr><td><code id="est_cfarh_+3A_x_pos">x_pos</code></td>
<td>
<p>the observation location matrix. If the locations are regular, it is a t-by-(n+1) matrix with all entries 1/n.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>phi_coef</code></td>
<td>
<p>the estimated spline coefficients for convolutional function(s).</p>
</td></tr>
<tr><td><code>phi_func</code></td>
<td>
<p>the estimated convolutional function(s).</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>estimated rho for O-U process (noise process).</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>estimated sigma for O-U process (noise process).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Liu, X., Xiao, H., and Chen, R. (2016) Convolutional autoregressive models for functional time series. <em>Journal of Econometrics</em>, 194, 263-282.
</p>

<hr>
<h2 id='F_test_cfar'>F Test for a CFAR Process</h2><span id='topic+F_test_cfar'></span>

<h3>Description</h3>

<p>F test for a CFAR process to specify the CFAR order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F_test_cfar(f, p.max = 6, df_b = 10, grid = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="F_test_cfar_+3A_f">f</code></td>
<td>
<p>the functional time series.</p>
</td></tr>
<tr><td><code id="F_test_cfar_+3A_p.max">p.max</code></td>
<td>
<p>the maximum CFAR order. Default is 6.</p>
</td></tr>
<tr><td><code id="F_test_cfar_+3A_df_b">df_b</code></td>
<td>
<p>the degrees of freedom for natural cubic splines. Default is 10.</p>
</td></tr>
<tr><td><code id="F_test_cfar_+3A_grid">grid</code></td>
<td>
<p>the number of gird points used to construct the functional time series and noise process. Default is 1000.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function outputs F test statistics and their p-values.
</p>


<h3>References</h3>

<p>Liu, X., Xiao, H., and Chen, R. (2016) Convolutional autoregressive models for functional time series. <em>Journal of Econometrics</em>, 194, 263-282.
</p>

<hr>
<h2 id='F_test_cfarh'>F Test for a CFAR Process with Heteroscedasticity and Irregular Observation Locations</h2><span id='topic+F_test_cfarh'></span>

<h3>Description</h3>

<p>F test for a CFAR process with heteroscedasticity and irregular observation locations to specify the CFAR order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F_test_cfarh(
  f,
  weight,
  p.max = 3,
  grid = 1000,
  df_b = 10,
  num_obs = NULL,
  x_pos = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="F_test_cfarh_+3A_f">f</code></td>
<td>
<p>the functional time series.</p>
</td></tr>
<tr><td><code id="F_test_cfarh_+3A_weight">weight</code></td>
<td>
<p>the covariance functions for noise process.</p>
</td></tr>
<tr><td><code id="F_test_cfarh_+3A_p.max">p.max</code></td>
<td>
<p>the maximum CFAR order. Default is 3.</p>
</td></tr>
<tr><td><code id="F_test_cfarh_+3A_grid">grid</code></td>
<td>
<p>the number of gird points used to construct the functional time series and noise process. Default is 1000.</p>
</td></tr>
<tr><td><code id="F_test_cfarh_+3A_df_b">df_b</code></td>
<td>
<p>the degrees of freedom for natural cubic splines. Default is 10.</p>
</td></tr>
<tr><td><code id="F_test_cfarh_+3A_num_obs">num_obs</code></td>
<td>
<p>the numbers of observations. It is a t-by-1 vector, where t is the length of time.</p>
</td></tr>
<tr><td><code id="F_test_cfarh_+3A_x_pos">x_pos</code></td>
<td>
<p>the observation location matrix. If the locations are regular, it is a t-by-(n+1) matrix with all entries 1/n.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function outputs F test statistics and their p-values.
</p>


<h3>References</h3>

<p>Liu, X., Xiao, H., and Chen, R. (2016) Convolutional autoregressive models for functional time series. <em>Journal of Econometrics</em>, 194, 263-282.
</p>

<hr>
<h2 id='F.test'>F Test for Nonlinearity</h2><span id='topic+F.test'></span>

<h3>Description</h3>

<p>Compute the F-test statistic for nonlinearity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F.test(x, order, thres = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="F.test_+3A_x">x</code></td>
<td>
<p>time series.</p>
</td></tr>
<tr><td><code id="F.test_+3A_order">order</code></td>
<td>
<p>AR order.</p>
</td></tr>
<tr><td><code id="F.test_+3A_thres">thres</code></td>
<td>
<p>threshold value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function outputs the test statistic and its p-value, and return a list with components:
</p>
<table role = "presentation">
<tr><td><code>test.stat</code></td>
<td>
<p>test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>p-value.</p>
</td></tr>
<tr><td><code>order</code></td>
<td>
<p>AR order.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>y=rnorm(100)
F.test(y,2,0)
</code></pre>

<hr>
<h2 id='g_cfar'>Generate a CFAR Process</h2><span id='topic+g_cfar'></span>

<h3>Description</h3>

<p>Generate a convolutional functional autoregressive process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_cfar(
  tmax = 1001,
  rho = 5,
  phi_list = NULL,
  grid = 1000,
  sigma = 1,
  ini = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="g_cfar_+3A_tmax">tmax</code></td>
<td>
<p>length of time.</p>
</td></tr>
<tr><td><code id="g_cfar_+3A_rho">rho</code></td>
<td>
<p>parameter for O-U process (noise process).</p>
</td></tr>
<tr><td><code id="g_cfar_+3A_phi_list">phi_list</code></td>
<td>
<p>the convolutional function(s). Default is the density function of normal distribution with mean 0 and standard deviation 0.1.</p>
</td></tr>
<tr><td><code id="g_cfar_+3A_grid">grid</code></td>
<td>
<p>the number of grid points used to construct the functional time series. Default is 1000.</p>
</td></tr>
<tr><td><code id="g_cfar_+3A_sigma">sigma</code></td>
<td>
<p>the standard deviation of O-U process. Default is 1.</p>
</td></tr>
<tr><td><code id="g_cfar_+3A_ini">ini</code></td>
<td>
<p>the burn-in period.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>cfar</code></td>
<td>
<p>a tmax-by-(grid+1) matrix following a CFAR(p) process.</p>
</td></tr>
<tr><td><code>epsilon</code></td>
<td>
<p>the innovation at time tmax.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Liu, X., Xiao, H., and Chen, R. (2016) Convolutional autoregressive models for functional time series. <em>Journal of Econometrics</em>, 194, 263-282.
</p>

<hr>
<h2 id='g_cfar1'>Generate a CFAR(1) Process</h2><span id='topic+g_cfar1'></span>

<h3>Description</h3>

<p>Generate a convolutional functional autoregressive process with order 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_cfar1(
  tmax = 1001,
  rho = 5,
  phi_func = NULL,
  grid = 1000,
  sigma = 1,
  ini = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="g_cfar1_+3A_tmax">tmax</code></td>
<td>
<p>length of time.</p>
</td></tr>
<tr><td><code id="g_cfar1_+3A_rho">rho</code></td>
<td>
<p>parameter for O-U process (noise process).</p>
</td></tr>
<tr><td><code id="g_cfar1_+3A_phi_func">phi_func</code></td>
<td>
<p>convolutional function. Default is density function of normal distribution with mean 0 and standard deviation 0.1.</p>
</td></tr>
<tr><td><code id="g_cfar1_+3A_grid">grid</code></td>
<td>
<p>the number of grid points used to construct the functional time series. Default is 1000.</p>
</td></tr>
<tr><td><code id="g_cfar1_+3A_sigma">sigma</code></td>
<td>
<p>the standard deviation of O-U process. Default is 1.</p>
</td></tr>
<tr><td><code id="g_cfar1_+3A_ini">ini</code></td>
<td>
<p>the burn-in period.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>cfar1</code></td>
<td>
<p>a tmax-by-(grid+1) matrix following a CFAR(1) process.</p>
</td></tr>
<tr><td><code>epsilon</code></td>
<td>
<p>the innovation at time tmax.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Liu, X., Xiao, H., and Chen, R. (2016) Convolutional autoregressive models for functional time series. <em>Journal of Econometrics</em>, 194, 263-282.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi_func= function(x)
{
 	return(dnorm(x,mean=0,sd=0.1))
}
y=g_cfar1(100,5,phi_func,grid=1000,sigma=1,ini=100)
</code></pre>

<hr>
<h2 id='g_cfar2'>Generate a CFAR(2) Process</h2><span id='topic+g_cfar2'></span>

<h3>Description</h3>

<p>Generate a convolutional functional autoregressive process with order 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_cfar2(
  tmax = 1001,
  rho = 5,
  phi_func1 = NULL,
  phi_func2 = NULL,
  grid = 1000,
  sigma = 1,
  ini = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="g_cfar2_+3A_tmax">tmax</code></td>
<td>
<p>length of time.</p>
</td></tr>
<tr><td><code id="g_cfar2_+3A_rho">rho</code></td>
<td>
<p>parameter for O-U process (noise process).</p>
</td></tr>
<tr><td><code id="g_cfar2_+3A_phi_func1">phi_func1</code></td>
<td>
<p>the first convolutional function. Default is 0.5*x^2+0.5*x+0.13.</p>
</td></tr>
<tr><td><code id="g_cfar2_+3A_phi_func2">phi_func2</code></td>
<td>
<p>the second convolutional function. Default is 0.7*x^4-0.1*x^3-0.15*x.</p>
</td></tr>
<tr><td><code id="g_cfar2_+3A_grid">grid</code></td>
<td>
<p>the number of grid points used to construct the functional time series. Default is 1000.</p>
</td></tr>
<tr><td><code id="g_cfar2_+3A_sigma">sigma</code></td>
<td>
<p>the standard deviation of O-U process. Default is 1.</p>
</td></tr>
<tr><td><code id="g_cfar2_+3A_ini">ini</code></td>
<td>
<p>the burn-in period.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>cfar2</code></td>
<td>
<p>a tmax-by-(grid+1) matrix following a CFAR(1) process.</p>
</td></tr>
<tr><td><code>epsilon</code></td>
<td>
<p>the innovation at time tmax.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Liu, X., Xiao, H., and Chen, R. (2016) Convolutional autoregressive models for functional time series. <em>Journal of Econometrics</em>, 194, 263-282.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi_func1= function(x){
return(0.5*x^2+0.5*x+0.13)
}
phi_func2= function(x){
return(0.7*x^4-0.1*x^3-0.15*x)
}
y=g_cfar2(100,5,phi_func1,phi_func2,grid=1000,sigma=1,ini=100)
</code></pre>

<hr>
<h2 id='g_cfar2h'>Generate a CFAR(2) Process with Heteroscedasticity and Irregular Observation Locations</h2><span id='topic+g_cfar2h'></span>

<h3>Description</h3>

<p>Generate a convolutional functional autoregressive process of order 2 with heteroscedasticity, irregular observation locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_cfar2h(
  tmax = 1001,
  grid = 1000,
  rho = 1,
  min_obs = 40,
  pois = 5,
  phi_func1 = NULL,
  phi_func2 = NULL,
  weight = NULL,
  ini = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="g_cfar2h_+3A_tmax">tmax</code></td>
<td>
<p>length of time.</p>
</td></tr>
<tr><td><code id="g_cfar2h_+3A_grid">grid</code></td>
<td>
<p>the number of grid points used to construct the functional time series.</p>
</td></tr>
<tr><td><code id="g_cfar2h_+3A_rho">rho</code></td>
<td>
<p>parameter for O-U process (noise process).</p>
</td></tr>
<tr><td><code id="g_cfar2h_+3A_min_obs">min_obs</code></td>
<td>
<p>the minimum number of observations at each time.</p>
</td></tr>
<tr><td><code id="g_cfar2h_+3A_pois">pois</code></td>
<td>
<p>the mean for Poisson distribution. The number of observations at each follows a Poisson distribution plus min_obs.</p>
</td></tr>
<tr><td><code id="g_cfar2h_+3A_phi_func1">phi_func1</code></td>
<td>
<p>the first convolutional function. Default is 0.5*x^2+0.5*x+0.13.</p>
</td></tr>
<tr><td><code id="g_cfar2h_+3A_phi_func2">phi_func2</code></td>
<td>
<p>the second convolutional function. Default is 0.7*x^4-0.1*x^3-0.15*x.</p>
</td></tr>
<tr><td><code id="g_cfar2h_+3A_weight">weight</code></td>
<td>
<p>the weight function to determine the standard deviation of O-U process (noise process). Default is 1.</p>
</td></tr>
<tr><td><code id="g_cfar2h_+3A_ini">ini</code></td>
<td>
<p>the burn-in period.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>cfar2</code></td>
<td>
<p>a tmax-by-(grid+1) matrix following a CFAR(1) process.</p>
</td></tr>
<tr><td><code>epsilon</code></td>
<td>
<p>the innovation at time tmax.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Liu, X., Xiao, H., and Chen, R. (2016) Convolutional autoregressive models for functional time series. <em>Journal of Econometrics</em>, 194, 263-282.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi_func1= function(x){
return(0.5*x^2+0.5*x+0.13)
}
phi_func2= function(x){
return(0.7*x^4-0.1*x^3-0.15*x)
}
y=g_cfar2h(200,1000,1,40,5,phi_func1=phi_func1,phi_func2=phi_func2)
</code></pre>

<hr>
<h2 id='hfDummy'>Create Dummy Variables for High-Frequency Intraday Seasonality</h2><span id='topic+hfDummy'></span>

<h3>Description</h3>

<p>Create dummy variables for high-frequency intraday seasonality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hfDummy(int = 1, Fopen = 10, Tend = 10, days = 1, pooled = 1, skipmin = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hfDummy_+3A_int">int</code></td>
<td>
<p>length of time interval in minutes.</p>
</td></tr>
<tr><td><code id="hfDummy_+3A_fopen">Fopen</code></td>
<td>
<p>number of dummies/intervals from the market open.</p>
</td></tr>
<tr><td><code id="hfDummy_+3A_tend">Tend</code></td>
<td>
<p>number of dummies/intervals to the market close.</p>
</td></tr>
<tr><td><code id="hfDummy_+3A_days">days</code></td>
<td>
<p>number of trading days in the data.</p>
</td></tr>
<tr><td><code id="hfDummy_+3A_pooled">pooled</code></td>
<td>
<p>a logical value indicating whether the data are pooled.</p>
</td></tr>
<tr><td><code id="hfDummy_+3A_skipmin">skipmin</code></td>
<td>
<p>the number of minites omitted from the opening.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x=hfDummy(5,Fopen=4,Tend=4,days=2,skipmin=15)
</code></pre>

<hr>
<h2 id='MKF.Full.RB'>Full Information Propagation Step under Mixture Kalman Filter</h2><span id='topic+MKF.Full.RB'></span>

<h3>Description</h3>

<p>This function implements the full information propagation step under mixture Kalman filter with full information proposal distribution and Rao-Blackwellization, no delay.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MKF.Full.RB(
  MKFstep.Full.RB,
  nobs,
  yy,
  mm,
  par,
  II.init,
  mu.init,
  SS.init,
  xdim,
  ydim,
  resample.sch
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MKF.Full.RB_+3A_mkfstep.full.rb">MKFstep.Full.RB</code></td>
<td>
<p>a function that performs one step propagation under mixture Kalman filter, with full information proposal distribution.
Its input includes <code>(mm,II,mu,SS,logww,yyy,par,xdim,ydim)</code>, where
<code>II</code>, <code>mu</code>, and <code>SS</code> are the indicators and its corresponding mean and variance matrix of the Kalman filter components in the last iterations.
<code>logww</code> is the log weight of the last iteration. <code>yyy</code> is the
observation at current time step. It should return the Rao-Blackwellization estimation of the mean and variance.</p>
</td></tr>
<tr><td><code id="MKF.Full.RB_+3A_nobs">nobs</code></td>
<td>
<p>the number of observations <code>T</code>.</p>
</td></tr>
<tr><td><code id="MKF.Full.RB_+3A_yy">yy</code></td>
<td>
<p>the observations with <code>T</code> columns and <code>ydim</code> rows.</p>
</td></tr>
<tr><td><code id="MKF.Full.RB_+3A_mm">mm</code></td>
<td>
<p>the Monte Carlo sample size <code>m</code>.</p>
</td></tr>
<tr><td><code id="MKF.Full.RB_+3A_par">par</code></td>
<td>
<p>a list of parameter values to pass to <code>Sstep</code>.</p>
</td></tr>
<tr><td><code id="MKF.Full.RB_+3A_ii.init">II.init</code></td>
<td>
<p>the initial indicators.</p>
</td></tr>
<tr><td><code id="MKF.Full.RB_+3A_mu.init">mu.init</code></td>
<td>
<p>the initial mean.</p>
</td></tr>
<tr><td><code id="MKF.Full.RB_+3A_ss.init">SS.init</code></td>
<td>
<p>the initial variance.</p>
</td></tr>
<tr><td><code id="MKF.Full.RB_+3A_xdim">xdim</code></td>
<td>
<p>the dimension of the state varible <code>x_t</code>.</p>
</td></tr>
<tr><td><code id="MKF.Full.RB_+3A_ydim">ydim</code></td>
<td>
<p>the dimension of the observation <code>y_t</code>.</p>
</td></tr>
<tr><td><code id="MKF.Full.RB_+3A_resample.sch">resample.sch</code></td>
<td>
<p>a binary vector of length <code>nobs</code>, reflecting the resampling schedule. resample.sch[i]= 1 indicating resample should be carried out at step <code>i</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>xhat</code></td>
<td>
<p>the fitted value.</p>
</td></tr>
<tr><td><code>xhatRB</code></td>
<td>
<p>the fitted value using Rao-Blackwellization.</p>
</td></tr>
<tr><td><code>Iphat</code></td>
<td>
<p>the estimated indicators.</p>
</td></tr>
<tr><td><code>IphatRB</code></td>
<td>
<p>the estimated indicators using Rao-Blackwellization.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tsay, R. and Chen, R. (2018). Nonlinear Time Series Analysis. John Wiley &amp; Sons, New Jersey.
</p>

<hr>
<h2 id='MKFstep.fading'>One Propagation Step under Mixture Kalman Filter for Fading Channels</h2><span id='topic+MKFstep.fading'></span>

<h3>Description</h3>

<p>This function implements the one propagation step under mixture Kalman filter for fading channels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MKFstep.fading(mm, II, mu, SS, logww, yyy, par, xdim, ydim, resample)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MKFstep.fading_+3A_mm">mm</code></td>
<td>
<p>the Monte Carlo sample size.</p>
</td></tr>
<tr><td><code id="MKFstep.fading_+3A_ii">II</code></td>
<td>
<p>the indicators.</p>
</td></tr>
<tr><td><code id="MKFstep.fading_+3A_mu">mu</code></td>
<td>
<p>the mean in the last iteration.</p>
</td></tr>
<tr><td><code id="MKFstep.fading_+3A_ss">SS</code></td>
<td>
<p>the covariance matrix of the Kalman filter components in the last iteration.</p>
</td></tr>
<tr><td><code id="MKFstep.fading_+3A_logww">logww</code></td>
<td>
<p>is the log weight of the last iteration.</p>
</td></tr>
<tr><td><code id="MKFstep.fading_+3A_yyy">yyy</code></td>
<td>
<p>the observations with <code>T</code> columns and <code>ydim</code> rows.</p>
</td></tr>
<tr><td><code id="MKFstep.fading_+3A_par">par</code></td>
<td>
<p>a list of parameter values. <code>HH</code> is the state coefficient matrix, <code>WW*t(WW)</code> is the state innovation covariance matrix,
<code>VV*t(VV)</code> is the covariance matrix of the observation noise, <code>GG1</code> and <code>GG2</code> are the observation coefficient matrix.</p>
</td></tr>
<tr><td><code id="MKFstep.fading_+3A_xdim">xdim</code></td>
<td>
<p>the dimension of the state variable <code>x_t</code>.</p>
</td></tr>
<tr><td><code id="MKFstep.fading_+3A_ydim">ydim</code></td>
<td>
<p>the dimension of the observation <code>y_t</code>.</p>
</td></tr>
<tr><td><code id="MKFstep.fading_+3A_resample">resample</code></td>
<td>
<p>a binary vector of length <code>obs</code>, reflecting the resampling schedule. resample.sch[i]= 1 indicating resample should be carried out at step <code>i</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>xhat</code></td>
<td>
<p>the fitted value.</p>
</td></tr>
<tr><td><code>xhatRB</code></td>
<td>
<p>the fitted value using Rao-Blackwellization.</p>
</td></tr>
<tr><td><code>Iphat</code></td>
<td>
<p>the estimated indicators.</p>
</td></tr>
<tr><td><code>IphatRB</code></td>
<td>
<p>the estimated indicators using Rao-Blackwellization.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tsay, R. and Chen, R. (2018). Nonlinear Time Series Analysis. John Wiley &amp; Sons, New Jersey.
</p>

<hr>
<h2 id='MSM.fit'>Fitting Univariate Autoregressive Markov Switching Models</h2><span id='topic+MSM.fit'></span>

<h3>Description</h3>

<p>Fit autoregressive Markov switching models to a univariate time series using the package MSwM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MSM.fit(y, p, nregime = 2, include.mean = T, sw = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MSM.fit_+3A_y">y</code></td>
<td>
<p>a time series.</p>
</td></tr>
<tr><td><code id="MSM.fit_+3A_p">p</code></td>
<td>
<p>AR order.</p>
</td></tr>
<tr><td><code id="MSM.fit_+3A_nregime">nregime</code></td>
<td>
<p>the number of regimes.</p>
</td></tr>
<tr><td><code id="MSM.fit_+3A_include.mean">include.mean</code></td>
<td>
<p>a logical value for including constant terms.</p>
</td></tr>
<tr><td><code id="MSM.fit_+3A_sw">sw</code></td>
<td>
<p>logical values for whether coefficients are switching. The length of <code>sw</code> has to be equal to the number of coefficients in the model plus include.mean.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>MSM.fit</code> returns an object of class codeMSM.lm or <code>MSM.glm</code>, depending on the input model.
</p>

<hr>
<h2 id='MSM.sim'>Generate Univariate 2-regime Markov Switching Models</h2><span id='topic+MSM.sim'></span>

<h3>Description</h3>

<p>Generate univariate 2-regime Markov switching models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MSM.sim(
  nob,
  order = c(1, 1),
  phi1 = NULL,
  phi2 = NULL,
  epsilon = c(0.1, 0.1),
  sigma = c(1, 1),
  cnst = c(0, 0),
  ini = 500
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MSM.sim_+3A_nob">nob</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="MSM.sim_+3A_order">order</code></td>
<td>
<p>AR order for each regime.</p>
</td></tr>
<tr><td><code id="MSM.sim_+3A_phi1">phi1</code>, <code id="MSM.sim_+3A_phi2">phi2</code></td>
<td>
<p>AR coefficients.</p>
</td></tr>
<tr><td><code id="MSM.sim_+3A_epsilon">epsilon</code></td>
<td>
<p>transition probabilities (switching out of regime 1 and 2).</p>
</td></tr>
<tr><td><code id="MSM.sim_+3A_sigma">sigma</code></td>
<td>
<p>standard errors for each regime.</p>
</td></tr>
<tr><td><code id="MSM.sim_+3A_cnst">cnst</code></td>
<td>
<p>constant term for each regime.</p>
</td></tr>
<tr><td><code id="MSM.sim_+3A_ini">ini</code></td>
<td>
<p>burn-in period.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MSM.sim returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>series</code></td>
<td>
<p>a time series following SETAR model.</p>
</td></tr>
<tr><td><code>at</code></td>
<td>
<p>innovation of the time series.</p>
</td></tr>
<tr><td><code>state</code></td>
<td>
<p>states for the time series.</p>
</td></tr>
<tr><td><code>epsilon</code></td>
<td>
<p>transition probabilities (switching out of regime 1 and 2).</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>standard error for each regime.</p>
</td></tr>
<tr><td><code>cnst</code></td>
<td>
<p>constant terms.</p>
</td></tr>
<tr><td><code>order</code></td>
<td>
<p>AR-order for each regime.</p>
</td></tr>
<tr><td><code>phi1</code>, <code>phi2</code></td>
<td>
<p>the AR coefficients for two regimes.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>y=MSM.sim(100,c(1,1),0.7,-0.5,c(0.5,0.6),c(1,1),c(0,0),500)
</code></pre>

<hr>
<h2 id='mTAR'>Estimation of a Multivariate Two-Regime SETAR Model</h2><span id='topic+mTAR'></span>

<h3>Description</h3>

<p>Estimation of a multivariate two-regime SETAR model, including threshold.
The procedure of Li and Tong (2016) is used to search for the threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mTAR(
  y,
  p1,
  p2,
  thr = NULL,
  thrV = NULL,
  delay = c(1, 1),
  Trim = c(0.1, 0.9),
  k0 = 300,
  include.mean = TRUE,
  score = "AIC"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mTAR_+3A_y">y</code></td>
<td>
<p>a (<code>nT</code>-by-<code>k</code>) data matrix of multivariate time series, where <code>nT</code> is the sample size and <code>k</code> is the dimension.</p>
</td></tr>
<tr><td><code id="mTAR_+3A_p1">p1</code></td>
<td>
<p>AR-order of regime 1.</p>
</td></tr>
<tr><td><code id="mTAR_+3A_p2">p2</code></td>
<td>
<p>AR-order of regime 2.</p>
</td></tr>
<tr><td><code id="mTAR_+3A_thr">thr</code></td>
<td>
<p>threshold variable. Estimation is needed if <code>thr</code> = NULL.</p>
</td></tr>
<tr><td><code id="mTAR_+3A_thrv">thrV</code></td>
<td>
<p>vector of threshold variable. If it is not null, thrV must have the same sample size of that of y.</p>
</td></tr>
<tr><td><code id="mTAR_+3A_delay">delay</code></td>
<td>
<p>two elements (i,d) with &quot;i&quot; being the component and &quot;d&quot; the delay for threshold variable.</p>
</td></tr>
<tr><td><code id="mTAR_+3A_trim">Trim</code></td>
<td>
<p>lower and upper quantiles for possible threshold value.</p>
</td></tr>
<tr><td><code id="mTAR_+3A_k0">k0</code></td>
<td>
<p>the maximum number of threshold values to be evaluated.</p>
</td></tr>
<tr><td><code id="mTAR_+3A_include.mean">include.mean</code></td>
<td>
<p>logical values indicating whether constant terms are included.</p>
</td></tr>
<tr><td><code id="mTAR_+3A_score">score</code></td>
<td>
<p>the choice of criterion used in selection threshold, namely (AIC, det(RSS)).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mTAR returns a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>the data matrix, y.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>a (<code>p*k+1</code>)-by-(<code>2k</code>) matrices. The first <code>k</code> columns show the estimation results in regime 1, and the second <code>k</code> columns show these in regime 2.</p>
</td></tr>
<tr><td><code>arorder</code></td>
<td>
<p>AR orders of regimes 1 and 2.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>estimated innovational covariance matrices of regimes 1 and 2.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>estimated innovations.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>numbers of observations in regimes 1 and 2.</p>
</td></tr>
<tr><td><code>model1</code>, <code>model2</code></td>
<td>
<p>estimated models of regimes 1 and 2.</p>
</td></tr>
<tr><td><code>thr</code></td>
<td>
<p>threshold value.</p>
</td></tr>
<tr><td><code>delay</code></td>
<td>
<p>two elements (<code>i</code>,<code>d</code>) with &quot;<code>i</code>&quot; being the component and &quot;<code>d</code>&quot; the delay for threshold variable.</p>
</td></tr>
<tr><td><code>thrV</code></td>
<td>
<p>vector of threshold variable.</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>a set of positive threshold values.</p>
</td></tr>
<tr><td><code>RSS</code></td>
<td>
<p>residual sum of squares.</p>
</td></tr>
<tr><td><code>information</code></td>
<td>
<p>overall information criteria.</p>
</td></tr>
<tr><td><code>cnst</code></td>
<td>
<p>logical values indicating whether the constant terms are included in regimes 1 and 2.</p>
</td></tr>
<tr><td><code>sresi</code></td>
<td>
<p>standardized residuals.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Li, D., and Tong. H. (2016) Nested sub-sample search algorithm for estimation of threshold models. <em>Statisitca Sinica</em>, 1543-1554.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi1=matrix(c(0.5,0.7,0.3,0.2),2,2)
phi2=matrix(c(0.4,0.6,0.5,-0.5),2,2)
sigma1=matrix(c(1,0,0,1),2,2)
sigma2=matrix(c(1,0,0,1),2,2)
c1=c(0,0)
c2=c(0,0)
delay=c(1,1)
Trim=c(0.2,0.8)
include.mean=TRUE
y=mTAR.sim(1000,0,phi1,phi2,sigma1,sigma2,c1,c2,delay,ini=500)
est=mTAR(y$series,1,1,0,y$series,delay,Trim,300,include.mean,"AIC")
est2=mTAR(y$series,1,1,NULL,y$series,delay,Trim,300,include.mean,"AIC")
</code></pre>

<hr>
<h2 id='mTAR.est'>Estimation of Multivariate TAR Models</h2><span id='topic+mTAR.est'></span>

<h3>Description</h3>

<p>Estimation of multivariate TAR models with given thresholds. It can handle multiple regimes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mTAR.est(
  y,
  arorder = c(1, 1),
  thr = c(0),
  delay = c(1, 1),
  thrV = NULL,
  include.mean = c(TRUE, TRUE),
  output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mTAR.est_+3A_y">y</code></td>
<td>
<p>vector time series.</p>
</td></tr>
<tr><td><code id="mTAR.est_+3A_arorder">arorder</code></td>
<td>
<p>AR order of each regime. The number of regime is length of arorder.</p>
</td></tr>
<tr><td><code id="mTAR.est_+3A_thr">thr</code></td>
<td>
<p>threshold value(s). There are k-1 threshold for a k-regime model.</p>
</td></tr>
<tr><td><code id="mTAR.est_+3A_delay">delay</code></td>
<td>
<p>two elements (i,d) with &quot;i&quot; being the component and &quot;d&quot; the delay for threshold variable.</p>
</td></tr>
<tr><td><code id="mTAR.est_+3A_thrv">thrV</code></td>
<td>
<p>external threshold variable if any. If thrV is not null, it must have the same number of observations as y-series.</p>
</td></tr>
<tr><td><code id="mTAR.est_+3A_include.mean">include.mean</code></td>
<td>
<p>logical values indicating whether constant terms are included. Default is TRUE for all.</p>
</td></tr>
<tr><td><code id="mTAR.est_+3A_output">output</code></td>
<td>
<p>a logical value indicating four output. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mTAR.est returns a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>the data matrix, <code>y</code>.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>the dimension of <code>y</code>.</p>
</td></tr>
<tr><td><code>arorder</code></td>
<td>
<p>AR orders of regimes 1 and 2.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>a (<code>p*k+1</code>)-by-(<code>2k</code>) matrices. The first <code>k</code> columns show the estimation results in regime 1, and the second <code>k</code> columns show these in regime 2.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>estimated innovational covariance matrices of regimes 1 and 2.</p>
</td></tr>
<tr><td><code>thr</code></td>
<td>
<p>threshold value.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>estimated innovations.</p>
</td></tr>
<tr><td><code>sresi</code></td>
<td>
<p>standardized residuals.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>numbers of observations in different regimes.</p>
</td></tr>
<tr><td><code>cnst</code></td>
<td>
<p>logical values indicating whether the constant terms are included in different regimes.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>AIC value.</p>
</td></tr>
<tr><td><code>delay</code></td>
<td>
<p>two elements (<code>i,d</code>) with &quot;<code>i</code>&quot; being the component and &quot;<code>d</code>&quot; the delay for threshold variable.</p>
</td></tr>
<tr><td><code>thrV</code></td>
<td>
<p>values of threshold variable.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>phi1=matrix(c(0.5,0.7,0.3,0.2),2,2)
phi2=matrix(c(0.4,0.6,0.5,-0.5),2,2)
sigma1=matrix(c(1,0,0,1),2,2)
sigma2=matrix(c(1,0,0,1),2,2)
c1=c(0,0)
c2=c(0,0)
delay=c(1,1)
y=mTAR.sim(100,0,phi1,phi2,sigma1,sigma2,c1,c2,delay,ini=500)
est=mTAR.est(y$series,c(1,1),0,delay)
</code></pre>

<hr>
<h2 id='mTAR.pred'>Prediction of A Fitted Multivariate TAR Model</h2><span id='topic+mTAR.pred'></span>

<h3>Description</h3>

<p>Prediction of a fitted multivariate TAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mTAR.pred(model, orig, h = 1, iterations = 3000, ci = 0.95, output = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mTAR.pred_+3A_model">model</code></td>
<td>
<p>multivariate TAR model.</p>
</td></tr>
<tr><td><code id="mTAR.pred_+3A_orig">orig</code></td>
<td>
<p>forecast origin.</p>
</td></tr>
<tr><td><code id="mTAR.pred_+3A_h">h</code></td>
<td>
<p>forecast horizon.</p>
</td></tr>
<tr><td><code id="mTAR.pred_+3A_iterations">iterations</code></td>
<td>
<p>number of iterations.</p>
</td></tr>
<tr><td><code id="mTAR.pred_+3A_ci">ci</code></td>
<td>
<p>confidence level.</p>
</td></tr>
<tr><td><code id="mTAR.pred_+3A_output">output</code></td>
<td>
<p>a logical value for output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mTAR.pred returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>model</code></td>
<td>
<p>the multivariate TAR model.</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>prediction.</p>
</td></tr>
<tr><td><code>Ysim</code></td>
<td>
<p>fitted <code>y</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>phi1=matrix(c(0.5,0.7,0.3,0.2),2,2)
phi2=matrix(c(0.4,0.6,0.5,-0.5),2,2)
sigma1=matrix(c(1,0,0,1),2,2)
sigma2=matrix(c(1,0,0,1),2,2)
c1=c(0,0)
c2=c(0,0)
delay=c(1,1)
y=mTAR.sim(100,0,phi1,phi2,sigma1,sigma2,c1,c2,delay,ini=500)
est=mTAR.est(y$series,c(1,1),0,delay)
pred=mTAR.pred(est,100,1,300,0.90,TRUE)
</code></pre>

<hr>
<h2 id='mTAR.sim'>Generate Two-Regime (TAR) Models</h2><span id='topic+mTAR.sim'></span>

<h3>Description</h3>

<p>Generates multivariate two-regime threshold autoregressive models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mTAR.sim(
  nob,
  thr,
  phi1,
  phi2,
  sigma1,
  sigma2 = NULL,
  c1 = NULL,
  c2 = NULL,
  delay = c(1, 1),
  ini = 500
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mTAR.sim_+3A_nob">nob</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="mTAR.sim_+3A_thr">thr</code></td>
<td>
<p>threshold value.</p>
</td></tr>
<tr><td><code id="mTAR.sim_+3A_phi1">phi1</code></td>
<td>
<p>VAR coefficient matrix of regime 1.</p>
</td></tr>
<tr><td><code id="mTAR.sim_+3A_phi2">phi2</code></td>
<td>
<p>VAR coefficient matrix of regime 2.</p>
</td></tr>
<tr><td><code id="mTAR.sim_+3A_sigma1">sigma1</code></td>
<td>
<p>innovational covariance matrix of regime 1.</p>
</td></tr>
<tr><td><code id="mTAR.sim_+3A_sigma2">sigma2</code></td>
<td>
<p>innovational covariance matrix of regime 2.</p>
</td></tr>
<tr><td><code id="mTAR.sim_+3A_c1">c1</code></td>
<td>
<p>constant vector of regime 1.</p>
</td></tr>
<tr><td><code id="mTAR.sim_+3A_c2">c2</code></td>
<td>
<p>constant vector of regime 2.</p>
</td></tr>
<tr><td><code id="mTAR.sim_+3A_delay">delay</code></td>
<td>
<p>two elements (i,d) with &quot;i&quot; being the component index and &quot;d&quot; the delay for threshold variable.</p>
</td></tr>
<tr><td><code id="mTAR.sim_+3A_ini">ini</code></td>
<td>
<p>burn-in period.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mTAR.sim returns a list with following components:
</p>
<table role = "presentation">
<tr><td><code>series</code></td>
<td>
<p>a time series following the multivariate two-regime  VAR model.</p>
</td></tr>
<tr><td><code>at</code></td>
<td>
<p>innovation of the time series.</p>
</td></tr>
<tr><td><code>threshold</code></td>
<td>
<p>threshold value.</p>
</td></tr>
<tr><td><code>delay</code></td>
<td>
<p>two elements (i,d) with &quot;i&quot; being the component index and &quot;d&quot; the delay for threshold variable.</p>
</td></tr>
<tr><td><code>n1</code></td>
<td>
<p>number of observations in regime 1.</p>
</td></tr>
<tr><td><code>n2</code></td>
<td>
<p>number of observations in regime 2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>phi1=matrix(c(0.5,0.7,0.3,0.2),2,2)
phi2=matrix(c(0.4,0.6,0.5,-0.5),2,2)
sigma1=matrix(c(1,0,0,1),2,2)
sigma2=matrix(c(1,0,0,1),2,2)
c1=c(0,0)
c2=c(0,0)
delay=c(1,1)
y=mTAR.sim(100,0,phi1,phi2,sigma1,sigma2,c1,c2,delay,ini=500)
</code></pre>

<hr>
<h2 id='NNsetting'>Setting Up The Predictor Matrix in A Neural Network for Time Series Data</h2><span id='topic+NNsetting'></span>

<h3>Description</h3>

<p>The function sets up the predictor matrix in a neural network for time series data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNsetting(zt, locY = 1, nfore = 0, lags = c(1:5), include.lagY = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NNsetting_+3A_zt">zt</code></td>
<td>
<p>data matrix, including the dependent variable <code>Y(t)</code>.</p>
</td></tr>
<tr><td><code id="NNsetting_+3A_locy">locY</code></td>
<td>
<p>location of the dependent variable (column number).</p>
</td></tr>
<tr><td><code id="NNsetting_+3A_nfore">nfore</code></td>
<td>
<p>number of out-of-sample prediction (1-step ahead).</p>
</td></tr>
<tr><td><code id="NNsetting_+3A_lags">lags</code></td>
<td>
<p>a vector containing the lagged variables used to form the x-matrix.</p>
</td></tr>
<tr><td><code id="NNsetting_+3A_include.lagy">include.lagY</code></td>
<td>
<p>indicator for including lagged <code>Y(t)</code> in the predictor matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with following components.
</p>
<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p><code>x</code>-matrix for training a neural network.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p><code>y</code>-output for training a neural network.</p>
</td></tr>
<tr><td><code>predX</code></td>
<td>
<p><code>x</code>-matrix for the prediction subsample.</p>
</td></tr>
<tr><td><code>predY</code></td>
<td>
<p><code>y</code>-output for the prediction subsample.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tsay, R. and Chen, R. (2018). Nonlinear Time Series Analysis. John Wiley &amp; Sons, New Jersey.
</p>

<hr>
<h2 id='p_cfar'>Prediction of CFAR Processes</h2><span id='topic+p_cfar'></span>

<h3>Description</h3>

<p>Prediction of CFAR processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_cfar(model, f, m = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_cfar_+3A_model">model</code></td>
<td>
<p>CFAR model.</p>
</td></tr>
<tr><td><code id="p_cfar_+3A_f">f</code></td>
<td>
<p>the functional time series data.</p>
</td></tr>
<tr><td><code id="p_cfar_+3A_m">m</code></td>
<td>
<p>the forecast horizon.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a prediction of the CFAR process.
</p>


<h3>References</h3>

<p>Liu, X., Xiao, H., and Chen, R. (2016) Convolutional autoregressive models for functional time series. <em>Journal of Econometrics</em>, 194, 263-282.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi_func= function(x)
{
 	return(dnorm(x,mean=0,sd=0.1))
}
y=g_cfar1(100,5,phi_func)
f_grid=y$cfar
index=seq(1,1001,by=50)
f=f_grid[,index]
est=est_cfar(f,1)
pred=p_cfar(est,f,1)
</code></pre>

<hr>
<h2 id='p_cfar_part'>Partial Curve Prediction of CFAR Processes</h2><span id='topic+p_cfar_part'></span>

<h3>Description</h3>

<p>Partial prediction for CFAR processes. t curves are given and we want to predit the curve at time t+1, but we know the first n observations in the curve, to predict the n+1 observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_cfar_part(model, f, new.obs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_cfar_part_+3A_model">model</code></td>
<td>
<p>CFAR model.</p>
</td></tr>
<tr><td><code id="p_cfar_part_+3A_f">f</code></td>
<td>
<p>the functional time series data.</p>
</td></tr>
<tr><td><code id="p_cfar_part_+3A_new.obs">new.obs</code></td>
<td>
<p>the given first <code>n</code> observations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a prediction of the CFAR process.
</p>


<h3>References</h3>

<p>Liu, X., Xiao, H., and Chen, R. (2016) Convolutional autoregressive models for functional time series. <em>Journal of Econometrics</em>, 194, 263-282.
</p>

<hr>
<h2 id='PRnd'>ND Test</h2><span id='topic+PRnd'></span>

<h3>Description</h3>

<p>Compute the ND test statistic of Pena and Rodriguez (2006, JSPI).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PRnd(x, m = 10, p = 0, q = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PRnd_+3A_x">x</code></td>
<td>
<p>time series.</p>
</td></tr>
<tr><td><code id="PRnd_+3A_m">m</code></td>
<td>
<p>the maximum number of lag of correlation to test.</p>
</td></tr>
<tr><td><code id="PRnd_+3A_p">p</code></td>
<td>
<p>AR order.</p>
</td></tr>
<tr><td><code id="PRnd_+3A_q">q</code></td>
<td>
<p>MA order.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>PRnd</code> function outputs the ND test statistic and its p-value.
</p>


<h3>References</h3>

<p>Pena, D., and Rodriguez, J. (2006) A powerful Portmanteau test of lack of fit for time series. series. <em>Journal of American Statistical Association</em>, 97, 601-610.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y=arima.sim(n=500,list(ar=c(0.8,-0.6,0.7)))
PRnd(y,10,3,0)
</code></pre>

<hr>
<h2 id='rankQ'>Rank-Based Portmanteau Tests</h2><span id='topic+rankQ'></span>

<h3>Description</h3>

<p>Performs rank-based portmanteau statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rankQ(zt, lag = 10, output = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rankQ_+3A_zt">zt</code></td>
<td>
<p>time series.</p>
</td></tr>
<tr><td><code id="rankQ_+3A_lag">lag</code></td>
<td>
<p>the maximum lag to calculate the test statistic.</p>
</td></tr>
<tr><td><code id="rankQ_+3A_output">output</code></td>
<td>
<p>a logical value for output. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>rankQ</code> function outputs the test statistics and p-values for Portmanteau tests, and returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>Qstat</code></td>
<td>
<p>test statistics.</p>
</td></tr>
<tr><td><code>pv</code></td>
<td>
<p>p-values.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>phi=t(matrix(c(-0.3, 0.5,0.6,-0.3),2,2))
y=uTAR.sim(nob=2000, arorder=c(2,2), phi=phi, d=2, thr=0.2, cnst=c(1,-1),sigma=c(1, 1))
rankQ(y$series,10,output=TRUE)
</code></pre>

<hr>
<h2 id='rcAR'>Estimating of Random-Coefficient AR Models</h2><span id='topic+rcAR'></span>

<h3>Description</h3>

<p>Estimate random-coefficient AR models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcAR(x, lags = c(1), include.mean = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rcAR_+3A_x">x</code></td>
<td>
<p>a time series of data.</p>
</td></tr>
<tr><td><code id="rcAR_+3A_lags">lags</code></td>
<td>
<p>the lag of AR models. This is more flexible than using order. It can skip unnecessary lags.</p>
</td></tr>
<tr><td><code id="rcAR_+3A_include.mean">include.mean</code></td>
<td>
<p>a logical value indicating whether the constant terms are included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>rcAR</code> function returns a list with following components:
</p>
<table role = "presentation">
<tr><td><code>par</code></td>
<td>
<p>estimated parameters.</p>
</td></tr>
<tr><td><code>se.est</code></td>
<td>
<p>standard errors.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>residuals.</p>
</td></tr>
<tr><td><code>sresiduals</code></td>
<td>
<p>standardized residuals.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>t=50
x=rnorm(t)
phi1=matrix(0.4,t,1)
for (i in 2:t){
   phi1[i]=0.7*phi1[i-1]+rnorm(1,0,0.1)
	x[i]=phi1[i]*x[i-1]+rnorm(1)
}
est=rcAR(x,1,FALSE)
</code></pre>

<hr>
<h2 id='ref.mTAR'>Refine A Fitted 2-Regime Multivariate TAR Model</h2><span id='topic+ref.mTAR'></span>

<h3>Description</h3>

<p>Refine a fitted 2-regime multivariate TAR model using &quot;thres&quot; as threshold for t-ratios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ref.mTAR(m1, thres = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ref.mTAR_+3A_m1">m1</code></td>
<td>
<p>a fitted mTAR object.</p>
</td></tr>
<tr><td><code id="ref.mTAR_+3A_thres">thres</code></td>
<td>
<p>threshold value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ref.mTAR returns a list with following components:
</p>
<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>data matrix, <code>y</code>.</p>
</td></tr>
<tr><td><code>arorder</code></td>
<td>
<p>AR orders of regimes 1 and 2.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>estimated innovational covariance matrices of regimes 1 and 2.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>a (<code>p*k+1</code>)-by-(<code>2k</code>) matrices. The first <code>k</code> columns show the estimation results in regime 1, and the second <code>k</code> columns shows these in regime 2.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>estimated innovations.</p>
</td></tr>
<tr><td><code>sresi</code></td>
<td>
<p>standard residuals.</p>
</td></tr>
<tr><td><code>criteria</code></td>
<td>
<p>overall information criteria.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>phi1=matrix(c(0.5,0.7,0.3,0.2),2,2)
phi2=matrix(c(0.4,0.6,0.5,-0.5),2,2)
sigma1=matrix(c(1,0,0,1),2,2)
sigma2=matrix(c(1,0,0,1),2,2)
c1=c(0,0)
c2=c(0,0)
delay=c(1,1)
y=mTAR.sim(100,0,phi1,phi2,sigma1,sigma2,c1,c2,delay,ini=500)
est=mTAR.est(y$series,c(1,1),0,delay)
ref.mTAR(est,0)
</code></pre>

<hr>
<h2 id='simPassiveSonar'>Simulate A Sample Trajectory</h2><span id='topic+simPassiveSonar'></span>

<h3>Description</h3>

<p>The function generates a sample trajectory of the target and the corresponding observations with sensor locations at (0,0)
and (20,0).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simPassiveSonar(nn = 200, q, r, start, seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simPassiveSonar_+3A_nn">nn</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="simPassiveSonar_+3A_q">q</code></td>
<td>
<p>contains the information about the covariance of the noise.</p>
</td></tr>
<tr><td><code id="simPassiveSonar_+3A_r">r</code></td>
<td>
<p>contains the information about <code>V</code>, where <code>V*t(V)</code> is the covariance matrix of the observation noise.</p>
</td></tr>
<tr><td><code id="simPassiveSonar_+3A_start">start</code></td>
<td>
<p>the initial value.</p>
</td></tr>
<tr><td><code id="simPassiveSonar_+3A_seed">seed</code></td>
<td>
<p>the seed of random number generator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>xx</code></td>
<td>
<p>the state data.</p>
</td></tr>
<tr><td><code>yy</code></td>
<td>
<p>the observed data.</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>the state coefficient matrix.</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
 <p><code>W*t(W)</code> is the state innovation covariance matrix.</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p><code>V*t(V)</code> is the observation noise covariance matrix.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>s2 &lt;- 20 #second sonar location at (s2,0)
q &lt;- c(0.03,0.03)
r &lt;- c(0.02,0.02)
nobs &lt;- 200
start &lt;- c(10,10,0.01,0.01)
H &lt;- c(1,0,1,0,0,1,0,1,0,0,1,0,0,0,0,1)
H &lt;- matrix(H,ncol=4,nrow=4,byrow=TRUE)
W &lt;- c(0.5*q[1], 0,0, 0.5*q[2],q[1],0,0,q[2])
W &lt;- matrix(W,ncol=2,nrow=4,byrow=TRUE)
V &lt;- diag(r)
mu0 &lt;- start
SS0 &lt;- diag(c(1,1,1,1))*0.01
simu_out &lt;- simPassiveSonar(nobs,q,r,start,seed=20)
yy&lt;- simu_out$yy
tt&lt;- 100:200
plot(simu_out$xx[1,tt],simu_out$xx[2,tt],xlab='x',ylab='y')
</code></pre>

<hr>
<h2 id='simu_fading'>Simulate Signals from A System with Rayleigh Flat-Fading Channels</h2><span id='topic+simu_fading'></span>

<h3>Description</h3>

<p>The function generates a sample from a system with Rayleigh flat-fading channels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simu_fading(nobs, par)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simu_fading_+3A_nobs">nobs</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="simu_fading_+3A_par">par</code></td>
<td>
<p>a list with following components: <code>HH</code> is the state coefficient matrix; <code>WW</code>, <code>WW*t(WW)</code> is the state innovation covariance matrix;
<code>VV</code>, <code>VV*t(VV)</code> is the observation noise covariance matrix; <code>GG</code> is the observation model.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>HH &lt;- matrix(c(2.37409, -1.92936, 0.53028,0,1,0,0,0,0,1,0,0,0,0,1,0),ncol=4,byrow=TRUE)
WW &lt;- matrix(c(1,0,0,0),nrow=4)
GG &lt;- matrix(0.01*c(0.89409,2.68227,2.68227,0.89409),nrow=1)
VV &lt;- 1.3**15*0.0001
par &lt;- list(HH=HH,WW=WW,GG=GG,VV=VV)
set.seed(1)
simu &lt;- simu_fading(200,par)
</code></pre>

<hr>
<h2 id='simuTargetClutter'>Simulate A Moving Target in Clutter</h2><span id='topic+simuTargetClutter'></span>

<h3>Description</h3>

<p>The function simulates a target signal under clutter environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simuTargetClutter(nobs, pd, ssw, ssv, xx0, ss0, nyy, yrange)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simuTargetClutter_+3A_nobs">nobs</code></td>
<td>
<p>the number observations.</p>
</td></tr>
<tr><td><code id="simuTargetClutter_+3A_pd">pd</code></td>
<td>
<p>the probability to observe the true signal.</p>
</td></tr>
<tr><td><code id="simuTargetClutter_+3A_ssw">ssw</code></td>
<td>
<p>the standard deviation in the state equation.</p>
</td></tr>
<tr><td><code id="simuTargetClutter_+3A_ssv">ssv</code></td>
<td>
<p>the standard deviation for the observation noise.</p>
</td></tr>
<tr><td><code id="simuTargetClutter_+3A_xx0">xx0</code></td>
<td>
<p>the initial location.</p>
</td></tr>
<tr><td><code id="simuTargetClutter_+3A_ss0">ss0</code></td>
<td>
<p>the initial speed.</p>
</td></tr>
<tr><td><code id="simuTargetClutter_+3A_nyy">nyy</code></td>
<td>
<p>the dimension of the data.</p>
</td></tr>
<tr><td><code id="simuTargetClutter_+3A_yrange">yrange</code></td>
<td>
<p>the range of data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>xx</code></td>
<td>
<p>the location.</p>
</td></tr>
<tr><td><code>ss</code></td>
<td>
<p>the speed.</p>
</td></tr>
<tr><td><code>ii</code></td>
<td>
<p>the indicators for whether the observation is the true signal.</p>
</td></tr>
<tr><td><code>yy</code></td>
<td>
<p>the data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tsay, R. and Chen, R. (2018). Nonlinear Time Series Analysis. John Wiley &amp; Sons, New Jersey.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data=simuTargetClutter(30,0.5,0.5,0.5,0,0.3,3,c(-30,30))
</code></pre>

<hr>
<h2 id='SISstep.fading'>Sequential Importance Sampling Step for Fading Channels</h2><span id='topic+SISstep.fading'></span>

<h3>Description</h3>

<p>This function implements one step of the sequential importance sampling method for fading channels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SISstep.fading(mm, xx, logww, yyy, par, xdim2, ydim)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SISstep.fading_+3A_mm">mm</code></td>
<td>
<p>the Monte Carlo sample size <code>m</code>.</p>
</td></tr>
<tr><td><code id="SISstep.fading_+3A_xx">xx</code></td>
<td>
<p>the sample in the last iteration.</p>
</td></tr>
<tr><td><code id="SISstep.fading_+3A_logww">logww</code></td>
<td>
<p>the log weight in the last iteration.</p>
</td></tr>
<tr><td><code id="SISstep.fading_+3A_yyy">yyy</code></td>
<td>
<p>the observations with <code>T</code> columns and <code>ydim</code> rows.</p>
</td></tr>
<tr><td><code id="SISstep.fading_+3A_par">par</code></td>
<td>
<p>a list of parameter values.  <code>HH</code> is the state coefficient model, <code>WW*t(WW)</code> is the state innovation covariance matrix,
<code>VV*t(VV)</code> is the covariance of the observation noise, <code>GG</code> is the observation model.</p>
</td></tr>
<tr><td><code id="SISstep.fading_+3A_xdim2">xdim2</code></td>
<td>
<p>the dimension of the state variable <code>x_t</code>.</p>
</td></tr>
<tr><td><code id="SISstep.fading_+3A_ydim">ydim</code></td>
<td>
<p>the dimension of the observation <code>y_t</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>xx</code></td>
<td>
<p>the new sample.</p>
</td></tr>
<tr><td><code>logww</code></td>
<td>
<p>the log weights.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tsay, R. and Chen, R. (2018). Nonlinear Time Series Analysis. John Wiley &amp; Sons, New Jersey.
</p>

<hr>
<h2 id='SMC'>Generic Sequential Monte Carlo Method</h2><span id='topic+SMC'></span>

<h3>Description</h3>

<p>Function of generic sequential Monte Carlo method with delay weighting not using full information proposal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SMC(
  Sstep,
  nobs,
  yy,
  mm,
  par,
  xx.init,
  xdim,
  ydim,
  resample.sch,
  delay = 0,
  funH = identity
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SMC_+3A_sstep">Sstep</code></td>
<td>
<p>a function that performs one step propagation using a proposal distribution.
Its input includes <code>(mm,xx,logww,yyy,par,xdim,ydim)</code>, where
<code>xx</code> and <code>logww</code> are the last iteration samples and log weight. <code>yyy</code> is the
observation at current time step. It should return <code>xx</code> (the samples xt) and
<code>logww</code> (their corresponding log weight).</p>
</td></tr>
<tr><td><code id="SMC_+3A_nobs">nobs</code></td>
<td>
<p>the number of observations <code>T</code>.</p>
</td></tr>
<tr><td><code id="SMC_+3A_yy">yy</code></td>
<td>
<p>the observations with <code>T</code> columns and <code>ydim</code> rows.</p>
</td></tr>
<tr><td><code id="SMC_+3A_mm">mm</code></td>
<td>
<p>the Monte Carlo sample size.</p>
</td></tr>
<tr><td><code id="SMC_+3A_par">par</code></td>
<td>
<p>a list of parameter values to pass to <code>Sstep</code>.</p>
</td></tr>
<tr><td><code id="SMC_+3A_xx.init">xx.init</code></td>
<td>
<p>the initial samples of <code>x_0</code>.</p>
</td></tr>
<tr><td><code id="SMC_+3A_xdim">xdim</code></td>
<td>
<p>the dimension of the state variable <code>x_t</code>.</p>
</td></tr>
<tr><td><code id="SMC_+3A_ydim">ydim</code></td>
<td>
<p>the dimension of the observation <code>y_t</code>.</p>
</td></tr>
<tr><td><code id="SMC_+3A_resample.sch">resample.sch</code></td>
<td>
<p>a binary vector of length <code>nobs</code>, reflecting the resampling schedule. resample.sch[i]= 1 indicating resample should be carried out at step <code>i</code>.</p>
</td></tr>
<tr><td><code id="SMC_+3A_delay">delay</code></td>
<td>
<p>the maximum delay lag for delayed weighting estimation. Default is zero.</p>
</td></tr>
<tr><td><code id="SMC_+3A_funh">funH</code></td>
<td>
<p>a user supplied function <code>h()</code> for estimation <code>E(h(x_t) | y_t+d</code>). Default
is identity for estimating the mean. The function should be able to take vector or matrix as input and operates on each element of the input.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns <code>xhat</code>, an array with dimensions <code>(xdim; nobs; delay+1)</code>,
and the scaled log-likelihood value <code>loglike</code>. If <code>loglike</code> is needed, the log weight
calculation in the <code>Sstep</code> function should retain all constants that are related to
the parameters involved. Otherwise, <code>Sstep</code> function may remove all constants
that are common to all the Monte Carlo samples. It needs a utility function
<code>circular2ordinal</code>, also included in the <code>NTS</code> package, for efficient memory management.
</p>


<h3>References</h3>

<p>Tsay, R. and Chen, R. (2018). Nonlinear Time Series Analysis. John Wiley &amp; Sons, New Jersey.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nobs= 100; pd= 0.95; ssw= 0.1; ssv= 0.5;
xx0= 0; ss0= 0.1; nyy= 50;
yrange= c(-80,80); xdim= 2; ydim= nyy;
mm= 10000
yr=yrange[2]-yrange[1]
par=list(ssw=ssw,ssv=ssv,nyy=nyy,pd=pd,yr=yr)
simu=simuTargetClutter(nobs,pd,ssw,ssv,xx0,ss0,nyy,yrange)
xx.init=matrix(nrow=2,ncol=mm)
xx.init[1,]=yrange[1]+runif(mm)*yr
xx.init[2,]=rep(0.1,mm)
resample.sch=rep.int(1,nobs)
out= SMC(Sstep.Clutter,nobs,simu$yy,mm,par,xx.init,xdim,ydim,resample.sch)
</code></pre>

<hr>
<h2 id='SMC.Full'>Generic Sequential Monte Carlo Using Full Information Proposal Distribution</h2><span id='topic+SMC.Full'></span>

<h3>Description</h3>

<p>Generic sequential Monte Carlo using full information proposal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SMC.Full(
  SISstep.Full,
  nobs,
  yy,
  mm,
  par,
  xx.init,
  xdim,
  ydim,
  resample.sch,
  delay = 0,
  funH = identity
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SMC.Full_+3A_sisstep.full">SISstep.Full</code></td>
<td>
<p>a function that performs one step propagation using a proposal distribution.
Its input includes <code>(mm,xx,logww,yyy,par,xdim,ydim,resample)</code>, where
<code>xx</code> and <code>logww</code> are the last iteration samples and log weight. <code>yyy</code> is the
observation at current time step. It should return <code>xx</code> (the samples xt) and
<code>logww</code> (their corresponding log weight), <code>resample</code> is a binary value for resampling.</p>
</td></tr>
<tr><td><code id="SMC.Full_+3A_nobs">nobs</code></td>
<td>
<p>the number of observations <code>T</code>.</p>
</td></tr>
<tr><td><code id="SMC.Full_+3A_yy">yy</code></td>
<td>
<p>the observations with <code>T</code> columns and <code>ydim</code> rows.</p>
</td></tr>
<tr><td><code id="SMC.Full_+3A_mm">mm</code></td>
<td>
<p>the Monte Carlo sample size <code>m</code>.</p>
</td></tr>
<tr><td><code id="SMC.Full_+3A_par">par</code></td>
<td>
<p>a list of parameter values to pass to <code>Sstep</code>.</p>
</td></tr>
<tr><td><code id="SMC.Full_+3A_xx.init">xx.init</code></td>
<td>
<p>the initial samples of <code>x_0</code>.</p>
</td></tr>
<tr><td><code id="SMC.Full_+3A_xdim">xdim</code></td>
<td>
<p>the dimension of the state varible <code>x_t</code>.</p>
</td></tr>
<tr><td><code id="SMC.Full_+3A_ydim">ydim</code></td>
<td>
<p>the dimension of the observation <code>y_t</code>.</p>
</td></tr>
<tr><td><code id="SMC.Full_+3A_resample.sch">resample.sch</code></td>
<td>
<p>a binary vector of length <code>nobs</code>, reflecting the resampling schedule. resample.sch[i]= 1 indicating resample should be carried out at step <code>i</code>.</p>
</td></tr>
<tr><td><code id="SMC.Full_+3A_delay">delay</code></td>
<td>
<p>the maximum delay lag for delayed weighting estimation. Default is zero.</p>
</td></tr>
<tr><td><code id="SMC.Full_+3A_funh">funH</code></td>
<td>
<p>a user supplied function <code>h()</code> for estimation <code>E(h(x_t) | y_t+d</code>). Default
is identity for estimating the mean. The function should be able to take vector or matrix as input and operates on each element of the input.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>xhat</code></td>
<td>
<p>the fitted values.</p>
</td></tr>
<tr><td><code>loglike</code></td>
<td>
<p>the log-likelihood.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tsay, R. and Chen, R. (2018). Nonlinear Time Series Analysis. John Wiley &amp; Sons, New Jersey.
</p>

<hr>
<h2 id='SMC.Full.RB'>Generic Sequential Monte Carlo Using Full Information Proposal Distribution and Rao-Blackwellization</h2><span id='topic+SMC.Full.RB'></span>

<h3>Description</h3>

<p>Generic sequential Monte Carlo using full information proposal distribution with Rao-Blackwellization estimate, and delay is 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SMC.Full.RB(
  SISstep.Full.RB,
  nobs,
  yy,
  mm,
  par,
  xx.init,
  xdim,
  ydim,
  resample.sch
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SMC.Full.RB_+3A_sisstep.full.rb">SISstep.Full.RB</code></td>
<td>
<p>a function that performs one step propagation using a proposal distribution.
Its input includes <code>(mm,xx,logww,yyy,par,xdim,ydim,resample)</code>, where
<code>xx</code> and <code>logww</code> are the last iteration samples and log weight. <code>yyy</code> is the
observation at current time step. It should return <code>xx</code> (the samples xt) and
<code>logww</code> (their corresponding log weight), <code>resample</code> is a binary value for resampling.</p>
</td></tr>
<tr><td><code id="SMC.Full.RB_+3A_nobs">nobs</code></td>
<td>
<p>the number of observations <code>T</code>.</p>
</td></tr>
<tr><td><code id="SMC.Full.RB_+3A_yy">yy</code></td>
<td>
<p>the observations with <code>T</code> columns and <code>ydim</code> rows.</p>
</td></tr>
<tr><td><code id="SMC.Full.RB_+3A_mm">mm</code></td>
<td>
<p>the Monte Carlo sample size <code>m</code>.</p>
</td></tr>
<tr><td><code id="SMC.Full.RB_+3A_par">par</code></td>
<td>
<p>a list of parameter values to pass to <code>Sstep</code>.</p>
</td></tr>
<tr><td><code id="SMC.Full.RB_+3A_xx.init">xx.init</code></td>
<td>
<p>the initial samples of <code>x_0</code>.</p>
</td></tr>
<tr><td><code id="SMC.Full.RB_+3A_xdim">xdim</code></td>
<td>
<p>the dimension of the state varible <code>x_t</code>.</p>
</td></tr>
<tr><td><code id="SMC.Full.RB_+3A_ydim">ydim</code></td>
<td>
<p>the dimension of the observation <code>y_t</code>.</p>
</td></tr>
<tr><td><code id="SMC.Full.RB_+3A_resample.sch">resample.sch</code></td>
<td>
<p>a binary vector of length <code>nobs</code>, reflecting the resampling schedule. resample.sch[i]= 1 indicating resample should be carried out at step <code>i</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>xhat</code></td>
<td>
<p>the fitted values.</p>
</td></tr>
<tr><td><code>xhatRB</code></td>
<td>
<p>the fitted values using Rao-Blackwellization.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tsay, R. and Chen, R. (2018). Nonlinear Time Series Analysis. John Wiley &amp; Sons, New Jersey.
</p>

<hr>
<h2 id='SMC.Smooth'>Generic Sequential Monte Carlo Smoothing with Marginal Weights</h2><span id='topic+SMC.Smooth'></span>

<h3>Description</h3>

<p>Generic sequential Monte Carlo smoothing with marginal weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SMC.Smooth(
  SISstep,
  SISstep.Smooth,
  nobs,
  yy,
  mm,
  par,
  xx.init,
  xdim,
  ydim,
  resample.sch,
  funH = identity
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SMC.Smooth_+3A_sisstep">SISstep</code></td>
<td>
<p>a function that performs one propagation step using a proposal distribution.
Its input includes <code>(mm,xx,logww,yyy,par,xdim,ydim)</code>, where
<code>xx</code> and <code>logww</code> are the last iteration samples and log weight. <code>yyy</code> is the
observation at current time step. It should return xx (the samples xt) and
logww (their corresponding log weight).</p>
</td></tr>
<tr><td><code id="SMC.Smooth_+3A_sisstep.smooth">SISstep.Smooth</code></td>
<td>
<p>the function for backward smoothing step.</p>
</td></tr>
<tr><td><code id="SMC.Smooth_+3A_nobs">nobs</code></td>
<td>
<p>the number of observations <code>T</code>.</p>
</td></tr>
<tr><td><code id="SMC.Smooth_+3A_yy">yy</code></td>
<td>
<p>the observations with <code>T</code> columns and <code>ydim</code> rows.</p>
</td></tr>
<tr><td><code id="SMC.Smooth_+3A_mm">mm</code></td>
<td>
<p>the Monte Carlo sample size <code>m</code>.</p>
</td></tr>
<tr><td><code id="SMC.Smooth_+3A_par">par</code></td>
<td>
<p>a list of parameter values.</p>
</td></tr>
<tr><td><code id="SMC.Smooth_+3A_xx.init">xx.init</code></td>
<td>
<p>the initial samples of <code>x_0</code>.</p>
</td></tr>
<tr><td><code id="SMC.Smooth_+3A_xdim">xdim</code></td>
<td>
<p>the dimension of the state variable <code>x_t</code>.</p>
</td></tr>
<tr><td><code id="SMC.Smooth_+3A_ydim">ydim</code></td>
<td>
<p>the dimension of the observation <code>y_t</code>.</p>
</td></tr>
<tr><td><code id="SMC.Smooth_+3A_resample.sch">resample.sch</code></td>
<td>
<p>a binary vector of length <code>nobs</code>, reflecting the resampling schedule. resample.sch[i]= 1 indicating resample should be carried out at step <code>i</code>.</p>
</td></tr>
<tr><td><code id="SMC.Smooth_+3A_funh">funH</code></td>
<td>
<p>a user supplied function <code>h()</code> for estimation <code>E(h(x_t) | y_1,...,y_T</code>). Default
is identity for estimating the mean. The function should be able to take vector or matrix as input and operates on each element of the input.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the smoothed values.
</p>


<h3>References</h3>

<p>Tsay, R. and Chen, R. (2018). Nonlinear Time Series Analysis. John Wiley &amp; Sons, New Jersey.
</p>

<hr>
<h2 id='Sstep.Clutter'>Sequential Monte Carlo for A Moving Target under Clutter Environment</h2><span id='topic+Sstep.Clutter'></span>

<h3>Description</h3>

<p>The function performs one step propagation using the sequential Monte Carlo method with partial state proposal for tracking in clutter problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sstep.Clutter(mm, xx, logww, yyy, par, xdim, ydim)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Sstep.Clutter_+3A_mm">mm</code></td>
<td>
<p>the Monte Carlo sample size <code>m</code>.</p>
</td></tr>
<tr><td><code id="Sstep.Clutter_+3A_xx">xx</code></td>
<td>
<p>the sample in the last iteration.</p>
</td></tr>
<tr><td><code id="Sstep.Clutter_+3A_logww">logww</code></td>
<td>
<p>the log weight in the last iteration.</p>
</td></tr>
<tr><td><code id="Sstep.Clutter_+3A_yyy">yyy</code></td>
<td>
<p>the observations.</p>
</td></tr>
<tr><td><code id="Sstep.Clutter_+3A_par">par</code></td>
<td>
<p>a list of parameter values <code>(ssw,ssv,pd,nyy,yr)</code>, where <code>ssw</code> is the standard deviation in the state equation,
<code>ssv</code> is the standard deviation for the observation noise, <code>pd</code> is the probability to observe the true signal, <code>nyy</code> the dimension of the data,
and <code>yr</code> is the range of the data.</p>
</td></tr>
<tr><td><code id="Sstep.Clutter_+3A_xdim">xdim</code></td>
<td>
<p>the dimension of the state varible.</p>
</td></tr>
<tr><td><code id="Sstep.Clutter_+3A_ydim">ydim</code></td>
<td>
<p>the dimension of the observation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>xx</code></td>
<td>
<p>the new sample.</p>
</td></tr>
<tr><td><code>logww</code></td>
<td>
<p>the log weights.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tsay, R. and Chen, R. (2018). Nonlinear Time Series Analysis. John Wiley &amp; Sons, New Jersey.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nobs &lt;- 100; pd &lt;- 0.95; ssw &lt;- 0.1; ssv &lt;- 0.5;
xx0 &lt;- 0; ss0 &lt;- 0.1; nyy &lt;- 50;
yrange &lt;- c(-80,80); xdim &lt;- 2; ydim &lt;- nyy;
simu &lt;- simuTargetClutter(nobs,pd,ssw,ssv,xx0,ss0,nyy,yrange)
resample.sch &lt;- rep(1,nobs)
mm &lt;- 10000
yr &lt;- yrange[2]-yrange[1]
par &lt;- list(ssw=ssw,ssv=ssv,nyy=nyy,pd=pd,yr=yr)
yr&lt;- yrange[2]-yrange[1]
xx.init &lt;- matrix(nrow=2,ncol=mm)
xx.init[1,] &lt;- yrange[1]+runif(mm)*yr
xx.init[2,] &lt;- rep(0.1,mm)
out &lt;- SMC(Sstep.Clutter,nobs,simu$yy,mm,par,xx.init,xdim,ydim,resample.sch)
</code></pre>

<hr>
<h2 id='Sstep.Clutter.Full'>Sequential Importance Sampling under Clutter Environment</h2><span id='topic+Sstep.Clutter.Full'></span>

<h3>Description</h3>

<p>This function performs one step propagation using the sequential importance sampling with full information proposal distribution under clutter environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sstep.Clutter.Full(mm, xx, logww, yyy, par, xdim, ydim, resample.sch)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Sstep.Clutter.Full_+3A_mm">mm</code></td>
<td>
<p>the Monte Carlo sample size <code>m</code>.</p>
</td></tr>
<tr><td><code id="Sstep.Clutter.Full_+3A_xx">xx</code></td>
<td>
<p>the samples in the last iteration.</p>
</td></tr>
<tr><td><code id="Sstep.Clutter.Full_+3A_logww">logww</code></td>
<td>
<p>the log weight in the last iteration.</p>
</td></tr>
<tr><td><code id="Sstep.Clutter.Full_+3A_yyy">yyy</code></td>
<td>
<p>the observations.</p>
</td></tr>
<tr><td><code id="Sstep.Clutter.Full_+3A_par">par</code></td>
<td>
<p>a list of parameter values <code>(ssw,ssv,pd,nyy,yr)</code>, where <code>ssw</code> is the standard deviation in the state equation,
<code>ssv</code> is the standard deviation for the observation noise, <code>pd</code> is the probability to observe the true signal, <code>nyy</code> the dimension of the data,
and <code>yr</code> is the range of the data.</p>
</td></tr>
<tr><td><code id="Sstep.Clutter.Full_+3A_xdim">xdim</code></td>
<td>
<p>the dimension of the state variable <code>x_t</code>.</p>
</td></tr>
<tr><td><code id="Sstep.Clutter.Full_+3A_ydim">ydim</code></td>
<td>
<p>the dimension of the observation <code>y_t</code>.</p>
</td></tr>
<tr><td><code id="Sstep.Clutter.Full_+3A_resample.sch">resample.sch</code></td>
<td>
<p>a binary vector of length <code>obs</code>, reflecting the resampling schedule. resample.sch[i]= 1 indicating resample should be carried out at step <code>i</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>xx</code></td>
<td>
<p>the new sample.</p>
</td></tr>
<tr><td><code>logww</code></td>
<td>
<p>the log weights.</p>
</td></tr>
<tr><td><code>r.index</code></td>
<td>
<p>resample index, if <code>resample.sch=1</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tsay, R. and Chen, R. (2018). Nonlinear Time Series Analysis. John Wiley &amp; Sons, New Jersey.
</p>

<hr>
<h2 id='Sstep.Clutter.Full.RB'>Sequential Importance Sampling under Clutter Environment</h2><span id='topic+Sstep.Clutter.Full.RB'></span>

<h3>Description</h3>

<p>This function performs one step propagation using the sequential importance sampling with full information proposal distribution and returns Rao-Blackwellization estimate of mean under clutter environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sstep.Clutter.Full.RB(mm, xx, logww, yyy, par, xdim, ydim, resample.sch)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Sstep.Clutter.Full.RB_+3A_mm">mm</code></td>
<td>
<p>the Monte Carlo sample size <code>m</code>.</p>
</td></tr>
<tr><td><code id="Sstep.Clutter.Full.RB_+3A_xx">xx</code></td>
<td>
<p>the samples in the last iteration.</p>
</td></tr>
<tr><td><code id="Sstep.Clutter.Full.RB_+3A_logww">logww</code></td>
<td>
<p>the log weight in the last iteration.</p>
</td></tr>
<tr><td><code id="Sstep.Clutter.Full.RB_+3A_yyy">yyy</code></td>
<td>
<p>the observations.</p>
</td></tr>
<tr><td><code id="Sstep.Clutter.Full.RB_+3A_par">par</code></td>
<td>
<p>a list of parameter values <code>(ssw,ssv,pd,nyy,yr)</code>, where <code>ssw</code> is the standard deviation in the state equation,
<code>ssv</code> is the standard deviation for the observation noise, <code>pd</code> is the probability to observe the true signal, <code>nyy</code> the dimension of the data,
and <code>yr</code> is the range of the data.</p>
</td></tr>
<tr><td><code id="Sstep.Clutter.Full.RB_+3A_xdim">xdim</code></td>
<td>
<p>the dimension of the state variable <code>x_t</code>.</p>
</td></tr>
<tr><td><code id="Sstep.Clutter.Full.RB_+3A_ydim">ydim</code></td>
<td>
<p>the dimension of the observation <code>y_t</code>.</p>
</td></tr>
<tr><td><code id="Sstep.Clutter.Full.RB_+3A_resample.sch">resample.sch</code></td>
<td>
<p>a binary vector of length <code>obs</code>, reflecting the resampling schedule. resample.sch[i]= 1 indicating resample should be carried out at step <code>i</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>xx</code></td>
<td>
<p>the new sample.</p>
</td></tr>
<tr><td><code>logww</code></td>
<td>
<p>the log weights.</p>
</td></tr>
<tr><td><code>xhat</code></td>
<td>
<p>the fitted vlaues.</p>
</td></tr>
<tr><td><code>xhatRB</code></td>
<td>
<p>the fitted values using Rao-Blackwellization.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tsay, R. and Chen, R. (2018). Nonlinear Time Series Analysis. John Wiley &amp; Sons, New Jersey.
</p>

<hr>
<h2 id='Sstep.Smooth.Sonar'>Sequential Importance Sampling for A Target with Passive Sonar</h2><span id='topic+Sstep.Smooth.Sonar'></span>

<h3>Description</h3>

<p>This function uses the sequential importance sampling method to deal with a target with passive sonar for smoothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sstep.Smooth.Sonar(mm, xxt, xxt1, ww, vv, par)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Sstep.Smooth.Sonar_+3A_mm">mm</code></td>
<td>
<p>the Monte Carlo sample size <code>m</code>.</p>
</td></tr>
<tr><td><code id="Sstep.Smooth.Sonar_+3A_xxt">xxt</code></td>
<td>
<p>the sample in the last iteration.</p>
</td></tr>
<tr><td><code id="Sstep.Smooth.Sonar_+3A_xxt1">xxt1</code></td>
<td>
<p>the sample in the next iteration.</p>
</td></tr>
<tr><td><code id="Sstep.Smooth.Sonar_+3A_ww">ww</code></td>
<td>
<p>the forward filtering weight.</p>
</td></tr>
<tr><td><code id="Sstep.Smooth.Sonar_+3A_vv">vv</code></td>
<td>
<p>the backward smoothing weight.</p>
</td></tr>
<tr><td><code id="Sstep.Smooth.Sonar_+3A_par">par</code></td>
<td>
<p>a list of parameter values. <code>H</code> is the state coefficient matrix, and <code>W*t(W)</code> is the state innovation covariance matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>xx</code></td>
<td>
<p>the new sample.</p>
</td></tr>
<tr><td><code>logww</code></td>
<td>
<p>the log weights.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tsay, R. and Chen, R. (2018). Nonlinear Time Series Analysis. John Wiley &amp; Sons, New Jersey.
</p>

<hr>
<h2 id='Sstep.Sonar'>Sequential Importance Sampling Step for A Target with Passive Sonar</h2><span id='topic+Sstep.Sonar'></span>

<h3>Description</h3>

<p>This function implements one step of the sequential importance sampling method for a target with passive sonar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sstep.Sonar(mm, xx, logww, yy, par, xdim = 1, ydim = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Sstep.Sonar_+3A_mm">mm</code></td>
<td>
<p>the Monte Carlo sample size <code>m</code>.</p>
</td></tr>
<tr><td><code id="Sstep.Sonar_+3A_xx">xx</code></td>
<td>
<p>the sample in the last iteration.</p>
</td></tr>
<tr><td><code id="Sstep.Sonar_+3A_logww">logww</code></td>
<td>
<p>the log weight in the last iteration.</p>
</td></tr>
<tr><td><code id="Sstep.Sonar_+3A_yy">yy</code></td>
<td>
<p>the observations with <code>T</code> columns and <code>ydim</code> rows.</p>
</td></tr>
<tr><td><code id="Sstep.Sonar_+3A_par">par</code></td>
<td>
<p>a list of parameter values. <code>H</code> is the state coefficient matrix, <code>W*t(W)</code> is the state innovation covariance matrix,
<code>V*t(V)</code> is the covariance matrix of the observation noise, <code>s2</code> is the second sonar location.</p>
</td></tr>
<tr><td><code id="Sstep.Sonar_+3A_xdim">xdim</code></td>
<td>
<p>the dimension of the state variable <code>x_t</code>.</p>
</td></tr>
<tr><td><code id="Sstep.Sonar_+3A_ydim">ydim</code></td>
<td>
<p>the dimension of the observation <code>y_t</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>xx</code></td>
<td>
<p>the new sample.</p>
</td></tr>
<tr><td><code>logww</code></td>
<td>
<p>the log weights.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tsay, R. and Chen, R. (2018). Nonlinear Time Series Analysis. John Wiley &amp; Sons, New Jersey.
</p>

<hr>
<h2 id='thr.test'>Threshold Nonlinearity Test</h2><span id='topic+thr.test'></span>

<h3>Description</h3>

<p>Threshold nonlinearity test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thr.test(y, p = 1, d = 1, thrV = NULL, ini = 40, include.mean = T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="thr.test_+3A_y">y</code></td>
<td>
<p>a time series.</p>
</td></tr>
<tr><td><code id="thr.test_+3A_p">p</code></td>
<td>
<p>AR order.</p>
</td></tr>
<tr><td><code id="thr.test_+3A_d">d</code></td>
<td>
<p>delay for the threshold variable.</p>
</td></tr>
<tr><td><code id="thr.test_+3A_thrv">thrV</code></td>
<td>
<p>threshold variable.</p>
</td></tr>
<tr><td><code id="thr.test_+3A_ini">ini</code></td>
<td>
<p>initial number of data to start RLS estimation.</p>
</td></tr>
<tr><td><code id="thr.test_+3A_include.mean">include.mean</code></td>
<td>
<p>a logical value for including constant terms.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>thr.test</code> returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>F-ratio</code></td>
<td>
<p>F statistic.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the numerator and denominator degrees of freedom.</p>
</td></tr>
<tr><td><code>ini</code></td>
<td>
<p>initial number of data to start RLS estimation.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tsay, R. (1989) Testing and Modeling Threshold Autoregressive Processes. <em>Journal of the American Statistical Associations</em> <strong>84</strong>(405), 231-240.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi=t(matrix(c(-0.3, 0.5,0.6,-0.3),2,2))
y=uTAR.sim(nob=2000, arorder=c(2,2), phi=phi, d=2, thr=0.2, cnst=c(1,-1),sigma=c(1, 1))
thr.test(y$series,p=2,d=2,ini=40,include.mean=TRUE)
</code></pre>

<hr>
<h2 id='Tsay'>Tsay Test for Nonlinearity</h2><span id='topic+Tsay'></span>

<h3>Description</h3>

<p>Perform Tsay (1986) nonlinearity test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Tsay(y, p = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Tsay_+3A_y">y</code></td>
<td>
<p>time series.</p>
</td></tr>
<tr><td><code id="Tsay_+3A_p">p</code></td>
<td>
<p>AR order.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function outputs the F statistic, p value, and the degrees of freedom. The null hypothesis is there is no nonlinearity.
</p>


<h3>References</h3>

<p>Tsay, R. (1986) Nonlinearity tests for time series. <em>Biometrika</em> <strong>73</strong>(2), 461-466.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi=t(matrix(c(-0.3, 0.5,0.6,-0.3),2,2))
y=uTAR.sim(nob=2000, arorder=c(2,2), phi=phi, d=2, thr=0.2, cnst=c(1,-1),sigma=c(1, 1))
Tsay(y$series,2)
</code></pre>

<hr>
<h2 id='tvAR'>Estimate Time-Varying Coefficient AR Models</h2><span id='topic+tvAR'></span>

<h3>Description</h3>

<p>Estimate time-varying coefficient AR models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tvAR(x, lags = c(1), include.mean = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tvAR_+3A_x">x</code></td>
<td>
<p>a time series of data.</p>
</td></tr>
<tr><td><code id="tvAR_+3A_lags">lags</code></td>
<td>
<p>the lagged variables used, e.g. lags=c(1,3) means lag-1 and lag-3 are used as regressors.
It is more flexible than specifying an order.</p>
</td></tr>
<tr><td><code id="tvAR_+3A_include.mean">include.mean</code></td>
<td>
<p>a logical value indicating whether the constant terms are included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>trAR</code> function returns the value from function <code>dlmMLE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t=50
x=rnorm(t)
phi1=matrix(0.4,t,1)
for (i in 2:t){
   phi1[i]=0.7*phi1[i-1]+rnorm(1,0,0.1)
	x[i]=phi1[i]*x[i-1]+rnorm(1)
}
est=tvAR(x,1)
</code></pre>

<hr>
<h2 id='tvARFiSm'>Filtering and Smoothing for Time-Varying AR Models</h2><span id='topic+tvARFiSm'></span>

<h3>Description</h3>

<p>This function performs forward filtering and backward smoothing for a fitted time-varying AR model with parameters in 'par'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tvARFiSm(x, lags = c(1), include.mean = TRUE, par)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tvARFiSm_+3A_x">x</code></td>
<td>
<p>a time series of data.</p>
</td></tr>
<tr><td><code id="tvARFiSm_+3A_lags">lags</code></td>
<td>
<p>the lag of AR order.</p>
</td></tr>
<tr><td><code id="tvARFiSm_+3A_include.mean">include.mean</code></td>
<td>
<p>a logical value indicating whether the constant terms are included.</p>
</td></tr>
<tr><td><code id="tvARFiSm_+3A_par">par</code></td>
<td>
<p>the fitted time-varying AR models. It can be an object returned by function. <code>tvAR</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>trARFiSm</code> function return values returned by function <code>dlmFilter</code> and <code>dlmSmooth</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t=50
x=rnorm(t)
phi1=matrix(0.4,t,1)
for (i in 2:t){
   phi1[i]=0.7*phi1[i-1]+rnorm(1,0,0.1)
	x[i]=phi1[i]*x[i-1]+rnorm(1)
}
est=tvAR(x,1)
tvARFiSm(x,1,FALSE,est$par)
</code></pre>

<hr>
<h2 id='uTAR'>Estimation of a Univariate Two-Regime SETAR Model</h2><span id='topic+uTAR'></span>

<h3>Description</h3>

<p>Estimation of a univariate two-regime SETAR model, including threshold value, performing recursive least squares method or nested sub-sample search algorithm.
The procedure of Li and Tong (2016) is used to search for the threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uTAR(
  y,
  p1,
  p2,
  d = 1,
  thrV = NULL,
  thrQ = c(0, 1),
  Trim = c(0.1, 0.9),
  include.mean = TRUE,
  method = "RLS",
  k0 = 300
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uTAR_+3A_y">y</code></td>
<td>
<p>a vector of time series.</p>
</td></tr>
<tr><td><code id="uTAR_+3A_p1">p1</code>, <code id="uTAR_+3A_p2">p2</code></td>
<td>
<p>AR-orders of regime 1 and regime 2.</p>
</td></tr>
<tr><td><code id="uTAR_+3A_d">d</code></td>
<td>
<p>delay for threshold variable, default is 1.</p>
</td></tr>
<tr><td><code id="uTAR_+3A_thrv">thrV</code></td>
<td>
<p>threshold variable. If thrV is not null, it must have the same length as that of y.</p>
</td></tr>
<tr><td><code id="uTAR_+3A_thrq">thrQ</code></td>
<td>
<p>lower and upper quantiles to search for threshold value.</p>
</td></tr>
<tr><td><code id="uTAR_+3A_trim">Trim</code></td>
<td>
<p>lower and upper quantiles for possible threshold values.</p>
</td></tr>
<tr><td><code id="uTAR_+3A_include.mean">include.mean</code></td>
<td>
<p>a logical value indicating whether constant terms are included.</p>
</td></tr>
<tr><td><code id="uTAR_+3A_method">method</code></td>
<td>
<p>&quot;RLS&quot;: estimate the model by conditional least squares method implemented by recursive least squares; &quot;NeSS&quot;: estimate the model by conditional least squares method implemented by Nested sub-sample search (NeSS) algorithm.</p>
</td></tr>
<tr><td><code id="uTAR_+3A_k0">k0</code></td>
<td>
<p>the maximum number of threshold values to be evaluated, when the nested sub-sample search (NeSS) method is used. If the sample size is large (&gt; 3000), then k0 = floor(nT*0.5). The default is k0=300. But k0 = floor(nT*0.8) if nT &lt; 300.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>uTAR returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>the data matrix, y.</p>
</td></tr>
<tr><td><code>arorder</code></td>
<td>
<p>AR orders of regimes 1 and 2.</p>
</td></tr>
<tr><td><code>delay</code></td>
<td>
<p>the delay for threshold variable.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>estimated innovations.</p>
</td></tr>
<tr><td><code>sresi</code></td>
<td>
<p>standardized residuals.</p>
</td></tr>
<tr><td><code>coef</code></td>
<td>
<p>a 2-by-(p+1) matrices. The first row shows the estimation results in regime 1, and the second row shows these in regime 2.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>estimated innovational covariance matrices of regimes 1 and 2.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>numbers of observations in regimes 1 and 2.</p>
</td></tr>
<tr><td><code>model1</code>, <code>model2</code></td>
<td>
<p>estimated models of regimes 1 and 2.</p>
</td></tr>
<tr><td><code>thr</code></td>
<td>
<p>threshold value.</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>a set of threshold values.</p>
</td></tr>
<tr><td><code>RSS</code></td>
<td>
<p>RSS</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>AIC value</p>
</td></tr>
<tr><td><code>cnst</code></td>
<td>
<p>logical values indicating whether the constant terms are included in regimes 1 and 2.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Li, D., and Tong. H. (2016) Nested sub-sample search algorithm for estimation of threshold models. <em>Statisitca Sinica</em>, 1543-1554.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi=t(matrix(c(-0.3, 0.5,0.6,-0.3),2,2))
y=uTAR.sim(nob=2000, arorder=c(2,2), phi=phi, d=2, thr=0.2, cnst=c(1,-1),sigma=c(1, 1))$series
est=uTAR(y=y,p1=2,p2=2,d=2,thrQ=c(0,1),Trim=c(0.1,0.9),include.mean=TRUE,method="NeSS",k0=50)
</code></pre>

<hr>
<h2 id='uTAR.est'>General Estimation of TAR Models</h2><span id='topic+uTAR.est'></span>

<h3>Description</h3>

<p>General estimation of TAR models with known threshold values.
It perform LS estimation of a univariate TAR model, and can handle multiple regimes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uTAR.est(
  y,
  arorder = c(1, 1),
  thr = c(0),
  d = 1,
  thrV = NULL,
  include.mean = c(TRUE, TRUE),
  output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uTAR.est_+3A_y">y</code></td>
<td>
<p>time series.</p>
</td></tr>
<tr><td><code id="uTAR.est_+3A_arorder">arorder</code></td>
<td>
<p>AR order of each regime. The number of regime is the length of arorder.</p>
</td></tr>
<tr><td><code id="uTAR.est_+3A_thr">thr</code></td>
<td>
<p>given threshold(s). There are k-1 threshold for a k-regime model.</p>
</td></tr>
<tr><td><code id="uTAR.est_+3A_d">d</code></td>
<td>
<p>delay for threshold variable, default is 1.</p>
</td></tr>
<tr><td><code id="uTAR.est_+3A_thrv">thrV</code></td>
<td>
<p>external threshold variable if any. If it is not NULL, thrV must have the same length as that of y.</p>
</td></tr>
<tr><td><code id="uTAR.est_+3A_include.mean">include.mean</code></td>
<td>
<p>a logical value indicating whether constant terms are included. Default is TRUE.</p>
</td></tr>
<tr><td><code id="uTAR.est_+3A_output">output</code></td>
<td>
<p>a logical value for output. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>uTAR.est returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>the data matrix, y.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>the number of regimes.</p>
</td></tr>
<tr><td><code>arorder</code></td>
<td>
<p>AR orders of regimes 1 and 2.</p>
</td></tr>
<tr><td><code>coefs</code></td>
<td>
<p>a k-by-(p+1) matrices, where <code>k</code> is the number of regimes. The i-th row shows the estimation results in regime i.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>estimated innovational covariances for all the regimes.</p>
</td></tr>
<tr><td><code>thr</code></td>
<td>
<p>threshold value.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>estimated innovations.</p>
</td></tr>
<tr><td><code>sresi</code></td>
<td>
<p>standardized residuals.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>numbers of observations in different regimes.</p>
</td></tr>
<tr><td><code>delay</code></td>
<td>
<p>delay for threshold variable.</p>
</td></tr>
<tr><td><code>cnst</code></td>
<td>
<p>logical values indicating whether the constant terms are included in different regimes.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>AIC value.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>phi=t(matrix(c(-0.3, 0.5,0.6,-0.3),2,2))
y=uTAR.sim(nob=200, arorder=c(2,2), phi=phi, d=2, thr=0.2, cnst=c(1,-1),sigma=c(1, 1))
thr.est=uTAR(y=y$series, p1=2, p2=2, d=2, thrQ=c(0,1),Trim=c(0.1,0.9), method="RLS")
est=uTAR.est(y=y$series, arorder=c(2,2), thr=thr.est$thr, d=2)
</code></pre>

<hr>
<h2 id='uTAR.pred'>Prediction of A Fitted Univariate TAR Model</h2><span id='topic+uTAR.pred'></span>

<h3>Description</h3>

<p>Prediction of a fitted univariate TAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uTAR.pred(model, orig, h = 1, iterations = 3000, ci = 0.95, output = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uTAR.pred_+3A_model">model</code></td>
<td>
<p>univariate TAR model.</p>
</td></tr>
<tr><td><code id="uTAR.pred_+3A_orig">orig</code></td>
<td>
<p>forecast origin.</p>
</td></tr>
<tr><td><code id="uTAR.pred_+3A_h">h</code></td>
<td>
<p>forecast horizon.</p>
</td></tr>
<tr><td><code id="uTAR.pred_+3A_iterations">iterations</code></td>
<td>
<p>number of iterations.</p>
</td></tr>
<tr><td><code id="uTAR.pred_+3A_ci">ci</code></td>
<td>
<p>confidence level.</p>
</td></tr>
<tr><td><code id="uTAR.pred_+3A_output">output</code></td>
<td>
<p>a logical value for output, default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>uTAR.pred returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>model</code></td>
<td>
<p>univariate TAR model.</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>prediction.</p>
</td></tr>
<tr><td><code>Ysim</code></td>
<td>
<p>fitted y.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>phi=t(matrix(c(-0.3, 0.5,0.6,-0.3),2,2))
y=uTAR.sim(nob=2000, arorder=c(2,2), phi=phi, d=2, thr=0.2, cnst=c(1,-1), sigma=c(1, 1))
thr.est=uTAR(y=y$series, p1=2, p2=2, d=2, thrQ=c(0,1), Trim=c(0.1,0.9), method="RLS")
est=uTAR.est(y=y$series, arorder=c(2,2), thr=thr.est$thr, d=2)
uTAR.pred(mode=est, orig=2000,h=1,iteration=100,ci=0.95,output=TRUE)
</code></pre>

<hr>
<h2 id='uTAR.sim'>Generate Univariate SETAR Models</h2><span id='topic+uTAR.sim'></span>

<h3>Description</h3>

<p>Generate univariate SETAR model for up to 3 regimes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uTAR.sim(
  nob,
  arorder,
  phi,
  d = 1,
  thr = c(0, 0),
  sigma = c(1, 1, 1),
  cnst = rep(0, 3),
  ini = 500
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uTAR.sim_+3A_nob">nob</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="uTAR.sim_+3A_arorder">arorder</code></td>
<td>
<p>AR-order for each regime. The length of arorder controls the number of regimes.</p>
</td></tr>
<tr><td><code id="uTAR.sim_+3A_phi">phi</code></td>
<td>
<p>a 3-by-p matrix. Each row contains the AR coefficients for a regime.</p>
</td></tr>
<tr><td><code id="uTAR.sim_+3A_d">d</code></td>
<td>
<p>delay for threshold variable.</p>
</td></tr>
<tr><td><code id="uTAR.sim_+3A_thr">thr</code></td>
<td>
<p>threshold values.</p>
</td></tr>
<tr><td><code id="uTAR.sim_+3A_sigma">sigma</code></td>
<td>
<p>standard error for each regime.</p>
</td></tr>
<tr><td><code id="uTAR.sim_+3A_cnst">cnst</code></td>
<td>
<p>constant terms.</p>
</td></tr>
<tr><td><code id="uTAR.sim_+3A_ini">ini</code></td>
<td>
<p>burn-in period.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>uTAR.sim returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>series</code></td>
<td>
<p>a time series following SETAR model.</p>
</td></tr>
<tr><td><code>at</code></td>
<td>
<p>innovation of the time seres.</p>
</td></tr>
<tr><td><code>arorder</code></td>
<td>
<p>AR-order for each regime.</p>
</td></tr>
<tr><td><code>thr</code></td>
<td>
<p>threshold value.</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>a 3-by-p matrix. Each row contains the AR coefficients for a regime.</p>
</td></tr>
<tr><td><code>cnst</code></td>
<td>
<p>constant terms</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>standard error for each regime.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>arorder=rep(1,2)
ar.coef=matrix(c(0.7,-0.8),2,1)
y=uTAR.sim(100,arorder,ar.coef,1,0)
</code></pre>

<hr>
<h2 id='wrap.SMC'>Sequential Monte Carlo Using Sequential Importance Sampling for Stochastic Volatility Models</h2><span id='topic+wrap.SMC'></span>

<h3>Description</h3>

<p>The function implements the sequential Monte Carlo method using sequential importance sampling for stochastic volatility models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrap.SMC(par.natural, yy, mm, setseed = T, resample = T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wrap.SMC_+3A_par.natural">par.natural</code></td>
<td>
<p>contains three parameters in AR(1) model. The first one is the stationary mean, the second is the AR coefficient, and the third is stationary variance.</p>
</td></tr>
<tr><td><code id="wrap.SMC_+3A_yy">yy</code></td>
<td>
<p>the data.</p>
</td></tr>
<tr><td><code id="wrap.SMC_+3A_mm">mm</code></td>
<td>
<p>the Monte Carlo sample size.</p>
</td></tr>
<tr><td><code id="wrap.SMC_+3A_setseed">setseed</code></td>
<td>
<p>the seed number.</p>
</td></tr>
<tr><td><code id="wrap.SMC_+3A_resample">resample</code></td>
<td>
<p>the logical value indicating for resampling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the log-likelihood of the data.
</p>


<h3>References</h3>

<p>Tsay, R. and Chen, R. (2018). Nonlinear Time Series Analysis. John Wiley &amp; Sons, New Jersey.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
