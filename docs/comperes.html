<!DOCTYPE html><html lang="en"><head><title>Help for package comperes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {comperes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#comperes-package'><p>comperes: Manage Competition Results</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#convert-pair-value'><p>Convert between long pair-value data and matrix</p></a></li>
<li><a href='#get_matchups'><p>Get matchups from competition results</p></a></li>
<li><a href='#h2h_funs'><p>Common Head-to-Head functions</p></a></li>
<li><a href='#h2h_long'><p>Compute long format of Head-to-Head values</p></a></li>
<li><a href='#h2h_mat'><p>Compute matrix format of Head-to-Head values</p></a></li>
<li><a href='#hp_survey'><p>Results of Harry Potter Books Survey</p></a></li>
<li><a href='#item-summary'><p>Compute item summary</p></a></li>
<li><a href='#item-summary-join'><p>Join item summary</p></a></li>
<li><a href='#levels2'><p>Levels of vector</p></a></li>
<li><a href='#longcr'><p>Long format of competition results</p></a></li>
<li><a href='#ncaa2005'><p>Example competition results from 2005 NCAA football season</p></a></li>
<li><a href='#num_wins'><p>Compute number of wins</p></a></li>
<li><a href='#pairgames'><p>Competition results with games between two players</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#summary_funs'><p>Common item summary functions</p></a></li>
<li><a href='#tidyeval'><p>Tidy eval helpers</p></a></li>
<li><a href='#widecr'><p>Wide format of competition results</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Manage Competition Results</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.7</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for storing and managing competition results.
    Competition is understood as a set of games in which players gain some
    abstract scores.  There are two ways for storing results: in long (one
    row per game-player) and wide (one row per game with fixed amount of
    players) formats. This package provides functions for creation and
    conversion between them. Also there are functions for computing their
    summary and Head-to-Head values for players. They leverage grammar of
    data manipulation from 'dplyr'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/echasnovski/comperes">https://github.com/echasnovski/comperes</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/echasnovski/comperes/issues">https://github.com/echasnovski/comperes/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 0.7.0), magrittr, rlang (&ge; 0.1.2), tibble, tidyr
(&ge; 0.7.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-28 18:36:57 UTC; evgeni</td>
</tr>
<tr>
<td>Author:</td>
<td>Evgeni Chasnovski <a href="https://orcid.org/0000-0002-1617-4019"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Evgeni Chasnovski &lt;evgeni.chasnovski@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-28 19:42:30 UTC</td>
</tr>
</table>
<hr>
<h2 id='comperes-package'>comperes: Manage Competition Results</h2><span id='topic+comperes'></span><span id='topic+comperes-package'></span>

<h3>Description</h3>

<p><code>comperes</code> offers a set of tools for storing and managing competition
results. <strong>Competition</strong> is understood as a set of <strong>games</strong> (abstract event)
in which <strong>players</strong> (abstract entity) gain some abstract <strong>scores</strong>. The
most natural example is sport results, however not the only one. For example,
product rating can be considered as a competition between products as
&quot;players&quot;. Here a &quot;game&quot; is a customer that reviews a set of products by
rating them with numerical &quot;score&quot; (stars, points, etc.).
</p>


<h3>Details</h3>

<p>This package provides the following functionality:
</p>

<ul>
<li> <p><strong>Store and convert</strong> competition results:
</p>

<ul>
<li><p> In <a href="#topic+longcr">long format</a> as a <a href="tibble.html#topic+tibble">tibble</a> with one row per
game-player pair.
</p>
</li>
<li><p> In <a href="#topic+widecr">wide format</a> as a <code>tibble</code> with one row per game with fixed
amount of players.
</p>
</li></ul>

</li>
<li> <p><strong>Summarise</strong>:
</p>

<ul>
<li><p> Compute <a href="#topic+item-summary">item summaries</a> with functions using
<a href="https://dplyr.tidyverse.org">dplyr</a>'s grammar of data manipulation.
</p>
</li>
<li><p> Compute and <a href="#topic+item-summary-join">join</a> item summaries to data for easy
transformation.
</p>
</li>
<li><p> Use <a href="#topic+summary_funs">common item summary functions</a> with
<a href="https://CRAN.R-project.org/package=rlang">rlang</a>'s
<a href="rlang.html#topic+topic-inject">unquoting</a> mechanism.
</p>
</li></ul>

</li>
<li> <p><strong>Compute Head-to-Head values</strong> (a summary statistic of direct
confrontation between two players) with functions also using dplyr's grammar:
</p>

<ul>
<li><p> Store output in <a href="#topic+h2h_long">long format</a> as a <code>tibble</code> with one row per
pair of players.
</p>
</li>
<li><p> Store output in <a href="#topic+h2h_mat">matrix format</a> as a matrix with rows and
columns describing players and entries - Head-to-Head values.
</p>
</li>
<li><p> Use <a href="#topic+h2h_funs">common Head-to-Head functions</a> with rlang's unquoting
mechanism.
</p>
</li></ul>

</li></ul>

<p>To learn more about <code>comperes</code> browse vignettes with
<code>browseVignettes(package = "comperes")</code>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Evgeni Chasnovski <a href="mailto:evgeni.chasnovski@gmail.com">evgeni.chasnovski@gmail.com</a> (<a href="https://orcid.org/0000-0002-1617-4019">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/echasnovski/comperes">https://github.com/echasnovski/comperes</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/echasnovski/comperes/issues">https://github.com/echasnovski/comperes/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='convert-pair-value'>Convert between long pair-value data and matrix</h2><span id='topic+convert-pair-value'></span><span id='topic+long_to_mat'></span><span id='topic+mat_to_long'></span>

<h3>Description</h3>

<p>Functions for conversion between long pair-value data (data frame with
columns for pair identifiers and value column) and matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>long_to_mat(tbl, row_key, col_key, value = NULL, fill = NULL,
  silent = FALSE)

mat_to_long(mat, row_key, col_key, value, drop = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert-pair-value_+3A_tbl">tbl</code></td>
<td>
<p>Data frame with pair-value data.</p>
</td></tr>
<tr><td><code id="convert-pair-value_+3A_row_key">row_key</code></td>
<td>
<p>String name of column for first key in pair.</p>
</td></tr>
<tr><td><code id="convert-pair-value_+3A_col_key">col_key</code></td>
<td>
<p>String name of column for second key in pair.</p>
</td></tr>
<tr><td><code id="convert-pair-value_+3A_value">value</code></td>
<td>
<p>String name of column for value (or <code>NULL</code> for <code>long_to_mat()</code>).</p>
</td></tr>
<tr><td><code id="convert-pair-value_+3A_fill">fill</code></td>
<td>
<p>Value to fill for missing pairs.</p>
</td></tr>
<tr><td><code id="convert-pair-value_+3A_silent">silent</code></td>
<td>
<p>Use <code>TRUE</code> to omit message about guessed value column (see
Details).</p>
</td></tr>
<tr><td><code id="convert-pair-value_+3A_mat">mat</code></td>
<td>
<p>Matrix with pair-value data.</p>
</td></tr>
<tr><td><code id="convert-pair-value_+3A_drop">drop</code></td>
<td>
<p>Use <code>TRUE</code> to drop rows with missing value (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pair-value data is commonly used in description of pairs of objects.
Pair is described by two keys (usually integer or character) and value is an
object of arbitrary nature.
</p>
<p>In <strong>long format</strong> there are at least three columns: for first key in pair,
for second key and for value (might be more). In <strong>matrix format</strong> pair-value
data is represented as matrix of values with row names as character
representation of first key, column names - second key.
</p>
<p><code>long_to_mat()</code> works as follows:
</p>

<ul>
<li><p> Pair identifiers are taken from columns with names <code>row_key</code> (to be used as
row names) and <code>col_key</code> (to be used as column names). Unique identifiers
(and future dimension names) are determined with <code><a href="#topic+levels2">levels2()</a></code>. This is a way
to target function on specific set of pairs by using factor columns. <strong>Note</strong>
that <code>NA</code>s are treated as single unknown key and put on last place (in case
of non-factor).
</p>
</li>
<li><p> Values are taken from column with name <code>value</code>. <strong>Note</strong> that if <code>value</code>
has length 0 (typically <code>NULL</code>) then <code>long_to_mat()</code> will take first
non-key column. If there is no such column, it will use vector of dummy
values (<code>NA</code>s or <code>fill</code>s). In both cases a message is given if <code>silent = FALSE</code>.
</p>
</li>
<li><p> Output is a matrix with described row and column names. Value of pair
&quot;key_1&quot; and &quot;key_2&quot; is stored at intersection of row &quot;key_1&quot; and &quot;key_2&quot;.
<strong>Note</strong> that in case of duplicated pairs the value from first occurrence is
taken.
</p>
</li></ul>

<p><code>mat_to_long()</code> basically performs inverse operation to <code>long_to_mat()</code> but
pair identifiers are always character. If <code>drop = TRUE</code> it drops rows with
values (but not keys) being missing.
</p>


<h3>Value</h3>

<p><code>long_to_mat()</code> returns a matrix with selected values where row names
indicate first key in pair, col names - second.
</p>
<p><code>mat_to_long()</code> returns a <code>tibble</code> with three columns: the
one for first key in pair, the one for second, and the one for value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>long_data &lt;- data.frame(
  key_1 = c("a", "a", "b"),
  key_2 = c("c", "d", "c"),
  val = 1:3,
  stringsAsFactors = FALSE
)

mat_data &lt;- long_data %&gt;% long_to_mat("key_1", "key_2", "val")
print(mat_data)

# Converts to tibble
mat_data %&gt;% mat_to_long("new_key_1", "new_key_2", "new_val")

# Drops rows with valuus missing
mat_data %&gt;% mat_to_long("new_key_1", "new_key_2", "new_val", drop = TRUE)
</code></pre>

<hr>
<h2 id='get_matchups'>Get matchups from competition results</h2><span id='topic+get_matchups'></span>

<h3>Description</h3>

<p>This function powers computing Head-to-Head values (both <a href="#topic+h2h_long">long</a> and
<a href="#topic+h2h_mat">matrix</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_matchups(cr_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_matchups_+3A_cr_data">cr_data</code></td>
<td>
<p>Competition results ready for <code><a href="#topic+as_longcr">as_longcr()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>get_matchups()</code> returns a <a href="tibble.html#topic+tibble">tibble</a> of all
matchups (pairs of players from one game) <strong>actually present</strong> in <code>cr_data</code>
(including matchups of players with themselves).
It has following columns:
</p>

<ul>
<li> <p><code>game</code> - game identifier of matchup.
</p>
</li>
<li> <p><code>player1</code> - identifier of first player in matchup.
</p>
</li>
<li> <p><code>score1</code> - score of the first player in matchup.
</p>
</li>
<li> <p><code>player2</code> - identifier of second player in matchup.
</p>
</li>
<li> <p><code>score2</code> - score of the second player in matchup.
</p>
</li></ul>

<p><strong>Important notes</strong>:
</p>

<ul>
<li><p> Matchups are not symmetrical: matchup &quot;player1&quot;-&quot;player2&quot; is considered
different from &quot;player2&quot;-&quot;player1&quot; in order to except more advanced, not
symmetrical Head-to-Head values.
</p>
</li>
<li><p> Missing values in <code>player</code> column after conversion to <code>longcr</code> are treated
as separate players. It allows operating with games where multiple players'
identifiers are not known. However, when computing Head-to-Head values they
treated as single player.
</p>
</li></ul>



<h3>Value</h3>

<p>A <a href="#topic+widecr">widecr</a> for games with two players.
</p>


<h3>See Also</h3>

<p><a href="#topic+h2h_long">Long format</a> of Head-to-Head values.
</p>
<p><a href="#topic+h2h_mat">Matrix format</a> of Head-to-Head values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_matchups(ncaa2005)
</code></pre>

<hr>
<h2 id='h2h_funs'>Common Head-to-Head functions</h2><span id='topic+h2h_funs'></span>

<h3>Description</h3>

<p>List of commonly used functions for computing Head-to-Head values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h2h_funs
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 9.
</p>


<h3>Details</h3>

<p><code>h2h_funs</code> is a named list of <a href="rlang.html#topic+expr">expressions</a>
representing commonly used expressions of Head-to-Head functions for
computing Head-to-Head values with <code><a href="#topic+h2h_long">h2h_long()</a></code> or <code><a href="#topic+h2h_mat">h2h_mat()</a></code>. Names of the
elements will be used as Head-to-Head value names. To use them inside
<code>h2h_long()</code> or <code>h2h_mat()</code> use <a href="rlang.html#topic+topic-inject">unquoting</a> mechanism
from rlang package.
</p>
<p>Currently present functions:
</p>

<ul>
<li> <p><code>mean_score_diff</code> - computes mean score difference of <code>player1</code> compared to
<code>player2</code>.
</p>
</li>
<li> <p><code>mean_score_diff_pos</code> - equivalent to <code>mean_score_diff</code> but returns 0 if
result is negative.
</p>
</li>
<li> <p><code>mean_score</code> - computes mean score of <code>player1</code>.
</p>
</li>
<li> <p><code>sum_score_diff</code> - computes sum of score differences of <code>player1</code> compared
to <code>player2</code>.
</p>
</li>
<li> <p><code>sum_score_diff_pos</code> - equivalent to <code>sum_score_diff</code> but returns 0 if
result is negative.
</p>
</li>
<li> <p><code>sum_score</code> - computes sum of scores of <code>player1</code>.
</p>
</li>
<li> <p><code>num_wins</code> - computes number of matchups <code>player1</code> scored <strong>more</strong> than
<code>player2</code>. Draws (determined by <code><a href="dplyr.html#topic+near">dplyr::near()</a></code>) are omitted.
</p>
</li>
<li> <p><code>num_wins2</code> - computes number of matchups <code>player1</code> scored <strong>more</strong> than
<code>player2</code> <strong>plus</strong> half the number of matchups where they had draw. <strong>Note</strong>
that for equal <code>player1</code> and <code>player2</code> there might be non-zero output.
</p>
</li>
<li> <p><code>num</code> - computes number of matchups.
</p>
</li></ul>

<p><strong>Note</strong> that it is generally better to subset <code>h2h_funs</code> using names
rather than indices because the order of elements might change in future
versions.
</p>


<h3>See Also</h3>

<p><a href="#topic+h2h_long">Long format</a> of Head-to-Head values.
</p>
<p><a href="#topic+h2h_mat">Matrix format</a> of Head-to-Head values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ncaa2005 %&gt;% h2h_long(!!!h2h_funs)

ncaa2005 %&gt;% h2h_mat(!!!h2h_funs["num_wins2"])
</code></pre>

<hr>
<h2 id='h2h_long'>Compute long format of Head-to-Head values</h2><span id='topic+h2h_long'></span><span id='topic+to_h2h_long'></span><span id='topic+as_tibble.h2h_long'></span>

<h3>Description</h3>

<p>Functions to compute Head-to-Head values in long pair-value format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h2h_long(cr_data, ..., fill = list())

to_h2h_long(mat, value = "h2h_value", drop = FALSE)

## S3 method for class 'h2h_long'
as_tibble(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="h2h_long_+3A_cr_data">cr_data</code></td>
<td>
<p>Competition results ready for <code><a href="#topic+as_longcr">as_longcr()</a></code>.</p>
</td></tr>
<tr><td><code id="h2h_long_+3A_...">...</code></td>
<td>
<p>Name-value pairs of Head-to-Head functions (see Details).</p>
</td></tr>
<tr><td><code id="h2h_long_+3A_fill">fill</code></td>
<td>
<p>A named list that for each variable supplies a single value to
use instead of <code>NA</code> for missing pairs (see tidyr's
<a href="tidyr.html#topic+complete">complete()</a>).</p>
</td></tr>
<tr><td><code id="h2h_long_+3A_mat">mat</code></td>
<td>
<p>Matrix of Head-to-Head values.</p>
</td></tr>
<tr><td><code id="h2h_long_+3A_value">value</code></td>
<td>
<p>String name to be used for column with Head-to-Head value.</p>
</td></tr>
<tr><td><code id="h2h_long_+3A_drop">drop</code></td>
<td>
<p>Use <code>TRUE</code> to drop rows with missing Head-to-Head values (see
Details).</p>
</td></tr>
<tr><td><code id="h2h_long_+3A_x">x</code></td>
<td>
<p>Object to be converted to <a href="tibble.html#topic+tibble">tibble</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>h2h_long()</code> computes Head-to-Head values in
<a href="#topic+convert-pair-value">long</a> format. It allows computation of multiple
Head-to-Head values at the same time by supplying multiple summary functions
in <code>...</code>. If no function is supplied in <code>...</code>, it returns all appropriate
combinations of <a href="#topic+get_matchups">matchups</a> (see next paragraph).
</p>
<p>After computing Head-to-Head values of actually present matchups, they are
aligned with &quot;levels&quot; (see <code><a href="#topic+levels2">levels2()</a></code>) of <code>player</code> vector (after applying
<code>as_longcr()</code>). This is a way to target function on fixed set of players by
using factor columns. The procedure is:
</p>

<ul>
<li><p> Implicit missing matchups are turned into explicit (by adding corresponding
rows with filling values in Head-to-Head columns) by using tidyr's
<a href="tidyr.html#topic+complete">complete()</a>.
</p>
</li>
<li><p> All matchups not containing players from &quot;levels&quot; are removed.
</p>
</li></ul>

<p>Use <code>fill</code> as in <code>complete()</code> to control filling values. To drop those rows
use tidyr's <a href="tidyr.html#topic+drop_na">drop_na()</a>.
</p>
<p><code>to_h2h_long()</code> takes <strong>object of <a href="#topic+h2h_mat">h2h_mat</a> structure</strong> and converts
it into <code>h2h_long</code> object with value column named as stored in <code>value</code>. Use
<code>drop = TRUE</code> to remove rows with missing values in value column (but not in
players').
</p>


<h3>Value</h3>

<p>An object of class <code>h2h_long</code> which is a <a href="tibble.html#topic+tibble">tibble</a>
with columns <code>player1</code>, <code>player2</code> and those, produced by Head-to-Head
functions (for <code>h2h_long()</code> maybe none).
</p>
<p><a href="tibble.html#topic+as_tibble">as_tibble()</a> applied to <code>h2h_long</code> object drops
<code>h2h_long</code> class.
</p>


<h3>Head-to-Head value</h3>

<p>Head-to-Head value is a summary statistic of direct confrontation between two
players. It is assumed that this value can be computed based only on the
players' <a href="#topic+get_matchups">matchups</a>. In other words, every game is converted
into series of &quot;subgames&quot; between ordered pairs of players (including
selfplay) which is stored as <a href="#topic+widecr">widecr</a> object. After that, summary of item,
defined by columns <code>player1</code> and <code>player2</code>, is computed using
<code><a href="#topic+summarise_item">summarise_item()</a></code>.
</p>
<p>That said, name-value pairs of Head-to-Head functions should be defined as
for <code>summarise_item()</code> applied to data with columns <code>game</code>, <code>player1</code>,
<code>score1</code>, <code>player2</code>, <code>score2</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+h2h_mat">Matrix format</a> of Head-to-Head values.
</p>
<p><a href="#topic+h2h_funs">Common Head-to-Head functions</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ncaa2005 %&gt;%
  h2h_long(
    mean_score = mean(score1),
    mean_abs_score = mean(abs(score1 - score2))
  )

ncaa2005[-(1:2), ] %&gt;%
  h2h_long(
    mean_score = mean(score1),
    fill = list(mean_score = 0)
  )
</code></pre>

<hr>
<h2 id='h2h_mat'>Compute matrix format of Head-to-Head values</h2><span id='topic+h2h_mat'></span><span id='topic+to_h2h_mat'></span>

<h3>Description</h3>

<p>Functions to compute Head-to-Head values in matrix pair-value format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h2h_mat(cr_data, ..., fill = NULL)

to_h2h_mat(tbl, value = NULL, fill = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="h2h_mat_+3A_cr_data">cr_data</code></td>
<td>
<p>Competition results ready for <code><a href="#topic+as_longcr">as_longcr()</a></code>.</p>
</td></tr>
<tr><td><code id="h2h_mat_+3A_...">...</code></td>
<td>
<p>Name-value pairs of Head-to-Head functions (see Details).</p>
</td></tr>
<tr><td><code id="h2h_mat_+3A_fill">fill</code></td>
<td>
<p>A single value to use instead of <code>NA</code> for missing pairs.</p>
</td></tr>
<tr><td><code id="h2h_mat_+3A_tbl">tbl</code></td>
<td>
<p>Data frame in <a href="#topic+h2h_long">long format</a> of Head-to-Head values.</p>
</td></tr>
<tr><td><code id="h2h_mat_+3A_value">value</code></td>
<td>
<p>String name for column with Head-to-Head value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>h2h_mat()</code> computes Head-to-Head values in
<a href="#topic+convert-pair-value">matrix</a> format. It allows multiple Head-to-Head
functions in <code>...</code> but only first (if present) will be used. Basically, it
uses supplied function to compute long format of Head-to-Head values and then
<a href="#topic+long_to_mat">transforms</a> it naturally to matrix, filling missing values
with <code>fill</code>.
</p>
<p><code>to_h2h_mat()</code> takes <strong>object of <a href="#topic+h2h_long">h2h_long</a> structure</strong> and converts it into
<code>h2h_mat</code> using column with name <code>value</code> for values and filling data for
implicitly missing (not explicitly provided in <code>tbl</code>) player pairs with
<code>fill</code>. If <code>value</code> is <code>NULL</code> it takes first non-player column. If there is no
such column, it will use vector of dummy values (<code>NA</code>s or <code>fill</code>s).
</p>


<h3>Value</h3>

<p>An object of class <code>h2h_mat</code> which is a <a href="base.html#topic+matrix">matrix</a> with row names
indicating first player in matchup, col names - second and values -
Head-to-Head values.
</p>


<h3>Head-to-Head value</h3>

<p>Head-to-Head value is a summary statistic of direct confrontation between two
players. It is assumed that this value can be computed based only on the
players' <a href="#topic+get_matchups">matchups</a>. In other words, every game is converted
into series of &quot;subgames&quot; between ordered pairs of players (including
selfplay) which is stored as <a href="#topic+widecr">widecr</a> object. After that, summary of item,
defined by columns <code>player1</code> and <code>player2</code>, is computed using
<code><a href="#topic+summarise_item">summarise_item()</a></code>.
</p>
<p>That said, name-value pairs of Head-to-Head functions should be defined as
for <code>summarise_item()</code> applied to data with columns <code>game</code>, <code>player1</code>,
<code>score1</code>, <code>player2</code>, <code>score2</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+h2h_long">Long format</a> of Head-to-Head values.
</p>
<p><a href="#topic+h2h_funs">Common Head-to-Head functions</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Only first function is used
ncaa2005 %&gt;%
  h2h_mat(
    mean_score = mean(score1),
    mean_abs_score = mean(abs(score1 - score2))
  )

ncaa2005[-(1:2), ] %&gt;%
  h2h_mat(mean_score = mean(score1), fill = 0)
</code></pre>

<hr>
<h2 id='hp_survey'>Results of Harry Potter Books Survey</h2><span id='topic+hp_survey'></span>

<h3>Description</h3>

<p><code>hp_survey</code> contains results of the survey with a goal to collect data enough
to rate Harry Potter books.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hp_survey
</code></pre>


<h3>Format</h3>

<p>A <a href="tibble.html#topic+tibble">tibble</a> with answers from 182 respondents and the
following columns:
</p>

<ul>
<li> <p><strong>person</strong> <code style="white-space: pre;">&#8288;&lt;int&gt;&#8288;</code>: Identifier of a person.
</p>
</li>
<li> <p><strong>book</strong> <code style="white-space: pre;">&#8288;&lt;chr&gt;&#8288;</code>: Identifier of a Harry Potter book. Its values are of the
form &quot;HP_x&quot; where &quot;x&quot; represents book's number in the series (from 1 to 7).
</p>
</li>
<li> <p><strong>score</strong> <code style="white-space: pre;">&#8288;&lt;chr&gt;&#8288;</code>: Book's score. Can be one of &quot;1 - Poor&quot;, &quot;2 - Fair&quot;, &quot;3 -
Good&quot;, &quot;4 - Very Good&quot;, &quot;5 - Excellent&quot;.
</p>
</li></ul>

<p>Rows are ordered by person and then by book identifier.
</p>


<h3>Details</h3>

<p>Survey was done via
<a href="https://www.google.com/intl/en/forms/about/">Google Forms</a> service. To
participate in it, respondent is asked to log in into her/his Google account
(to ensure that one person takes part only once). It was popularized mostly
among R users via <a href="https://www.r-bloggers.com/">R-bloggers</a> and
<a href="https://twitter.com/">Twitter</a>.
</p>
<p>At the beginning of the survey, there was the following text:
</p>
<p><em>This is a survey with goal to collect data enough to rate Harry Potter books.
Data will be made public with complete anonymity of respondents. Please, take
part only if you have read all seven original J. K. Rowling Harry Potter
books and are willing to give an honest feedback about your impressions.</em>
</p>
<p>Analyzed books were coded with the following names:
</p>

<ul>
<li><p> “HP and the Philosopher’s (Sorcerer’s) Stone (#1)”.
</p>
</li>
<li><p> “HP and the Chamber of Secrets (#2)”.
</p>
</li>
<li><p> “HP and the Prisoner of Azkaban (#3)”.
</p>
</li>
<li><p> “HP and the Goblet of Fire (#4)”.
</p>
</li>
<li><p> “HP and the Order of the Phoenix (#5)”.
</p>
</li>
<li><p> “HP and the Half-Blood Prince (#6)”.
</p>
</li>
<li><p> “HP and the Deathly Hallows (#7)”.
</p>
</li></ul>

<p>Survey had the following procedure:
</p>

<ul>
<li><p> At first, respondent is asked to choose the first element in the randomly
shuffled list of number from 1 to 127. This simulates the random generation
of books subset in the next question.
</p>
</li>
<li><p> Next he/she is presented with a question &quot;What is your impression of these
Harry Potter BOOKS?&quot; (singular if there is one book) and the following
question grid:
</p>

<ul>
<li><p> Rows represent randomly shuffled subset of books corresponding to the
number chosen in the first step.
</p>
</li>
<li><p> Columns contain the following scale of answers: “1 - Poor”, “2 - Fair”,
“3 - Good”, “4 - Very Good”, “5 - Excellent”. Respondent is asked and
allowed to choose only one answer per book (every book should be rated).
</p>
</li></ul>

</li></ul>


<hr>
<h2 id='item-summary'>Compute item summary</h2><span id='topic+item-summary'></span><span id='topic+summarise_item'></span><span id='topic+summarise_game'></span><span id='topic+summarise_player'></span><span id='topic+summarize_item'></span><span id='topic+summarize_game'></span><span id='topic+summarize_player'></span>

<h3>Description</h3>

<p>Functions for computing item summary, i.e. some summary measurements (of
arbitrary nature) of item (one or more columns) present in data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarise_item(tbl, item, ..., .prefix = "")

summarise_game(tbl, ..., .prefix = "")

summarise_player(tbl, ..., .prefix = "")

summarize_item(tbl, item, ..., .prefix = "")

summarize_game(tbl, ..., .prefix = "")

summarize_player(tbl, ..., .prefix = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="item-summary_+3A_tbl">tbl</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="item-summary_+3A_item">item</code></td>
<td>
<p>Character vector of columns to group by.</p>
</td></tr>
<tr><td><code id="item-summary_+3A_...">...</code></td>
<td>
<p>Name-value pairs of summary functions (as in <a href="dplyr.html#topic+summarise">dplyr::summarise</a>).</p>
</td></tr>
<tr><td><code id="item-summary_+3A_.prefix">.prefix</code></td>
<td>
<p>A string to be added to all summary functions' names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Basically, <code>summarise_item()</code> performs the following steps:
</p>

<ul>
<li><p> Group <code>tbl</code> by columns stored in <code>item</code>. <strong>Note</strong> that starting from 0.8.0
version of <code>dplyr</code> this might give a warning in case of implicit <code>NA</code>s in
factor columns (<code>NA</code> present in column values but not in its levels)
suggesting to add <code>NA</code> to levels.
</p>
</li>
<li><p> Apply dplyr's <code>summarise()</code>.
</p>
</li>
<li><p> Ungroup result.
</p>
</li>
<li><p> Convert to <a href="tibble.html#topic+tibble">tibble</a>.
</p>
</li>
<li><p> Add <code>.prefix</code> to names of summary functions.
</p>
</li></ul>

<p><code>summarise_game()</code> and <code>summarise_player()</code> are wrappers for
<code>summarise_item()</code> using <code>item = "game"</code> and <code>item = "player"</code> respectively.
</p>


<h3>Value</h3>

<p>Output of <code>summarise()</code> as not grouped <code>tibble</code>.
</p>


<h3>See Also</h3>

<p>Common item <a href="#topic+summary_funs">summary functions</a> for competition
results.
</p>
<p><a href="#topic+item-summary-join">Join item summary</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ncaa2005 %&gt;%
  dplyr::mutate(game_type = game %% 2) %&gt;%
  summarise_item(c("game_type", "player"), mean_score = mean(score))

ncaa2005 %&gt;%
  summarise_game(mean_score = mean(score), min_score = min(score))
</code></pre>

<hr>
<h2 id='item-summary-join'>Join item summary</h2><span id='topic+item-summary-join'></span><span id='topic+join_item_summary'></span><span id='topic+join_game_summary'></span><span id='topic+join_player_summary'></span>

<h3>Description</h3>

<p>Functions for joining summary data to data frame. They perform respective
variant of <a href="#topic+item-summary">summarise item functions</a> and then <a href="dplyr.html#topic+mutate-joins">left join</a> to the input its result (by <code>item</code> columns).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join_item_summary(tbl, item, ..., .prefix = "")

join_game_summary(tbl, ..., .prefix = "")

join_player_summary(tbl, ..., .prefix = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="item-summary-join_+3A_tbl">tbl</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="item-summary-join_+3A_item">item</code></td>
<td>
<p>Character vector of columns to group by.</p>
</td></tr>
<tr><td><code id="item-summary-join_+3A_...">...</code></td>
<td>
<p>Name-value pairs of summary functions (as in <a href="dplyr.html#topic+summarise">dplyr::summarise</a>).</p>
</td></tr>
<tr><td><code id="item-summary-join_+3A_.prefix">.prefix</code></td>
<td>
<p>A string to be added to all summary functions' names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>join_game_summary()</code> and <code>join_player_summary()</code> are wrappers for
<code>join_item_summary()</code> using <code>item = "game"</code> and <code>item = "player"</code>
respectively.
</p>


<h3>Value</h3>

<p>Result of <code>left_join()</code> to the input data frame.
</p>


<h3>See Also</h3>

<p><a href="#topic+item-summary">Compute item summary</a>
</p>
<p>Common item <a href="#topic+summary_funs">summary functions</a> for competition results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ncaa2005 %&gt;% join_player_summary(player_mean_score = mean(score))
</code></pre>

<hr>
<h2 id='levels2'>Levels of vector</h2><span id='topic+levels2'></span>

<h3>Description</h3>

<p>Extension of <code><a href="base.html#topic+levels">levels()</a></code> function. If <code>levels(x)</code> is not <code>NULL</code>, it is
returned. Otherwise, character representation of unique sorted values is
returned (with <code>NA</code> treated based on <code>na.last</code> as in <code><a href="base.html#topic+sort">sort()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>levels2(x, na.last = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="levels2_+3A_x">x</code></td>
<td>
<p>An object of interest.</p>
</td></tr>
<tr><td><code id="levels2_+3A_na.last">na.last</code></td>
<td>
<p>Argument for controlling the treatment of <code>NA</code>s. See <code><a href="base.html#topic+sort">sort()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>fac_vec &lt;- factor(c("a", "b"), levels = c("a", "b", "c"))
levels2(fac_vec)

levels2(c(10, 1, 2, NA, 11))
</code></pre>

<hr>
<h2 id='longcr'>Long format of competition results</h2><span id='topic+longcr'></span><span id='topic+is_longcr'></span><span id='topic+as_longcr'></span><span id='topic+as_tibble.longcr'></span>

<h3>Description</h3>

<p>Functions for dealing with competition results in long format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_longcr(cr_data)

as_longcr(cr_data, repair = TRUE, ...)

## S3 method for class 'longcr'
as_tibble(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="longcr_+3A_cr_data">cr_data</code></td>
<td>
<p>Data of competition results (convertible to tabular).</p>
</td></tr>
<tr><td><code id="longcr_+3A_repair">repair</code></td>
<td>
<p>Whether to repair input.</p>
</td></tr>
<tr><td><code id="longcr_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="longcr_+3A_x">x</code></td>
<td>
<p>Object to be converted to <a href="tibble.html#topic+tibble">tibble</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as_longcr()</code> is S3 method for converting data to <code>longcr</code>. When
using <strong>default</strong> method if <code>repair</code> is <code>TRUE</code> it also tries to fix possible
problems (see &quot;Repairing&quot;). If <code>repair</code> is <code>FALSE</code> it converts <code>cr_data</code> to
<a href="tibble.html#topic+tibble">tibble</a> and adds <code>longcr</code> class to it.
</p>
<p>When applying <code>as_longcr()</code> to proper (check via <code><a href="#topic+is_widecr">is_widecr()</a></code> is made)
<strong><code>widecr</code></strong> object, conversion is made:
</p>

<ul>
<li><p> If there is column <code>game</code> then it is used as game identifier. Else
treat every row as separate game data.
</p>
</li>
<li><p> Every &quot;player&quot;-&quot;score&quot; pair for every game is converted to separate row
with adding the appropriate extra columns.
</p>
</li>
<li><p> Result is arranged by <code>game</code> and identifier of a &quot;player&quot;-&quot;score&quot; pair
(extra symbols after &quot;player&quot; and &quot;score&quot; strings in input column names) in
increasing order.
</p>
</li>
<li><p> If <code>repair</code> is <code>TRUE</code> then repair is done.
</p>
</li></ul>

<p>For appropriate <strong><code>longcr</code></strong> objects <code>as_longcr()</code> returns its input and
throws error otherwise.
</p>


<h3>Value</h3>

<p><code>is_longcr()</code> returns <code>TRUE</code> if its argument is appropriate object of
class <code>longcr</code>: it should inherit classes <code>longcr</code>, <code>tbl_df</code> (in other
words, to be <a href="tibble.html#topic+tibble">tibble</a>) and have &quot;game&quot;, &quot;player&quot;, &quot;score&quot;
among column names.
</p>
<p><code>as_longcr()</code> returns an object of class <code>longcr</code>.
</p>
<p><a href="tibble.html#topic+as_tibble">as_tibble()</a> applied to <code>longcr</code> object drops <code>longcr</code>
class.
</p>


<h3>Long format of competition results</h3>

<p>It is assumed that competition consists from multiple games (matches,
comparisons, etc.). One game can consist from <strong>variable</strong> number of
players. Inside a game all players are treated equally.
In every game every player has some score: the value of arbitrary nature
that fully characterizes player's performance in particular game (in most
cases it is some numeric value).
</p>
<p><code>longcr</code> inherits from <code>tibble</code>. Data should have at least three columns with
the following names:
</p>

<ul>
<li> <p><code>game</code> - game identifier.
</p>
</li>
<li> <p><code>player</code> - player identifier.
</p>
</li>
<li> <p><code>score</code> - score of particular player in particular game.
</p>
</li></ul>

<p>Extra columns are allowed. <strong>Note</strong> that if object is converted to
<a href="#topic+widecr">widecr</a>, they will be dropped. So it is better to store
extra information about &quot;game&quot;-&quot;player&quot; pair as list-column &quot;score&quot; which
will stay untouched.
</p>


<h3>Repairing</h3>

<p>Option <code>repair = TRUE</code> (default) in <code>as_longcr()</code> means that its result is
going to be repaired with following actions:
</p>

<ul>
<li><p> Detect columns exactly matching &quot;game&quot;, &quot;player&quot; or &quot;score&quot;. Those are used
in the output. If all are detected matched columns are put in the beginning.
Other columns are preserved.
</p>
</li>
<li><p> If not all columns were exactly matched, detect first columns with names
containing &quot;game&quot;, &quot;player&quot; or &quot;score&quot; (ignoring case). If there are many
matching names for one output name then the first one is used. In case of
imperfect match, message is given. All other columns are treated as &quot;extra&quot;.
</p>
</li>
<li><p> If some legitimate names aren't detected, respective columns are created
and filled with <code>NA_integer_</code>. Also a message is given.
</p>
</li>
<li><p> If in one game some player listed more than once, the first record is
taken.
</p>
</li>
<li><p> Return the tibble with at least 3 appropriate for <code>longcr</code> columns and
column names.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+widecr">Wide format</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Repairing example
cr_data &lt;- data.frame(
  playerscoregame_ID = rep(1:5, times = 2),
  gameId = rep(1:5, each = 2),
  scoreS = 31:40,
  scoreSS = 41:50
)
cr_data_long &lt;- as_longcr(cr_data, repair = TRUE)

is_longcr(cr_data_long)

as_tibble(cr_data_long)
</code></pre>

<hr>
<h2 id='ncaa2005'>Example competition results from 2005 NCAA football season</h2><span id='topic+ncaa2005'></span>

<h3>Description</h3>

<p><code>ncaa2005</code> is an example competition results of an isolated group of
Atlantic Coast Conference teams provided in book &quot;Who's #1&quot; by Langville and
Meyer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncaa2005
</code></pre>


<h3>Format</h3>

<p>An object of class <a href="#topic+longcr">longcr</a> containing information
about 10 games.
</p>

<hr>
<h2 id='num_wins'>Compute number of wins</h2><span id='topic+num_wins'></span>

<h3>Description</h3>

<p>Function to accompany <code>num_wins</code> and <code>num_wins2</code> in <a href="#topic+h2h_funs">h2h_funs</a>. May be useful
for outer usage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num_wins(score_1, score_2, half_for_draw = FALSE, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="num_wins_+3A_score_1">score_1</code></td>
<td>
<p>Vector of scores for first player.</p>
</td></tr>
<tr><td><code id="num_wins_+3A_score_2">score_2</code></td>
<td>
<p>Vector of scores for second player.</p>
</td></tr>
<tr><td><code id="num_wins_+3A_half_for_draw">half_for_draw</code></td>
<td>
<p>Use <code>TRUE</code> to add half the matchups with draws.</p>
</td></tr>
<tr><td><code id="num_wins_+3A_na.rm">na.rm</code></td>
<td>
<p>Use <code>TRUE</code> to not count pair of scores with at least one <code>NA</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='pairgames'>Competition results with games between two players</h2><span id='topic+pairgames'></span><span id='topic+to_pairgames'></span><span id='topic+is_pairgames'></span>

<h3>Description</h3>

<p>Functions for competition results with games between two players.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_pairgames(cr_data)

is_pairgames(cr_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairgames_+3A_cr_data">cr_data</code></td>
<td>
<p>Competition results in format ready for <code><a href="#topic+as_longcr">as_longcr()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pairgames is a term for competition results with games between two
players.
</p>
<p><code>to_pairgames()</code> is a function that converts competition results into
pairwise games: it drops games with one player and for every game with 3 and
more players this function transforms it into set of separate games between
unordered pairs of players. In other words the result is a set of unordered
<a href="#topic+get_matchups">matchups</a> (<strong>as different games</strong>) between different
players.
</p>
<p><strong>Important notes</strong>:
</p>

<ul>
<li><p> New game identifiers are integers, order of which respects order of
games stored in <code>cr_data</code> (based on first occurrence in long format). There
is no particular order in subgames of games with 3 and more players.
</p>
</li>
<li><p> Order in which players are assigned to <code>player1</code> or <code>player2</code> column in
general shouldn't agree with any order in <code>cr_data</code>.
</p>
</li>
<li><p> Any column except <code>game</code>, <code>player</code> and <code>score</code> will be dropped after
conversion to <a href="#topic+longcr">longcr</a>.
</p>
</li>
<li> <p><code>NA</code> and <code>NaN</code> in <code>players</code> are allowed. They are treated as different
players.
</p>
</li>
<li> <p><code>to_pairgames()</code> is rather compute-intensive and can take much time for
competition results with many games.
</p>
</li></ul>



<h3>Value</h3>

<p><code>to_pairgames()</code> returns a competition results of pairwise games as
<a href="#topic+widecr">widecr</a> object with two players.
</p>
<p><code>is_pairgames()</code> returns a boolean value of whether <code>cr_data</code> contains only
games between two players.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cr_data &lt;- data.frame(
  game = c(rep(1:5, each = 3), 6),
  player = c(rep(1:5, times = 3), 1),
  score = 101:116,
  extraCol = -(1:16)
)

to_pairgames(cr_data)

# Missing values
cr_data_na &lt;- data.frame(
  game = rep(1L, 3),
  player = c(1, NA, NA),
  score = 1:3
)
to_pairgames(cr_data_na)

# Checks
is_pairgames(cr_data)
is_pairgames(to_pairgames(cr_data))
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+as_tibble'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>tibble</dt><dd><p><code><a href="tibble.html#topic+as_tibble">as_tibble</a></code></p>
</dd>
</dl>

<hr>
<h2 id='summary_funs'>Common item summary functions</h2><span id='topic+summary_funs'></span>

<h3>Description</h3>

<p>List of commonly used functions for summarising competition results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_funs
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 8.
</p>


<h3>Details</h3>

<p><code>summary_funs</code> is a named list of <a href="rlang.html#topic+expr">expressions</a>
representing commonly used expressions of summary functions for summarising
competition results with <code><a href="#topic+summarise_item">summarise_item()</a></code>. Names of the elements will be
used as summary names. It is designed primarily to be used with <a href="#topic+longcr">long format</a> of competition results. To use them inside <code>summarise_item()</code>
use <a href="rlang.html#topic+topic-inject">unquoting</a> mechanism from rlang package.
</p>
<p>Currently present functions:
</p>

<ul>
<li> <p><strong>min_score</strong> - <code>min(score)</code>.
</p>
</li>
<li> <p><strong>max_score</strong> - <code>max(score)</code>.
</p>
</li>
<li> <p><strong>mean_score</strong> - <code>mean(score)</code>.
</p>
</li>
<li> <p><strong>median_score</strong> - <code>median(score)</code>.
</p>
</li>
<li> <p><strong>sd_score</strong> - <code>sd(score)</code>.
</p>
</li>
<li> <p><strong>sum_score</strong> - <code>sum(score)</code>.
</p>
</li>
<li> <p><strong>num_games</strong> - <code>length(unique(game))</code>.
</p>
</li>
<li> <p><strong>num_players</strong> - <code>length(unique(player))</code>.
</p>
</li></ul>

<p><strong>Note</strong> that it is generally better to subset <code>summary_funs</code> using names
rather than indices because the order of elements might change in future
versions.
</p>


<h3>See Also</h3>

<p><a href="#topic+item-summary">Compute item summary</a>, <a href="#topic+item-summary-join">Join item summary</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ncaa2005 %&gt;% summarise_game(!!!summary_funs, .prefix = "game_")
</code></pre>

<hr>
<h2 id='tidyeval'>Tidy eval helpers</h2><span id='topic+tidyeval'></span><span id='topic+quo'></span><span id='topic+enquo'></span><span id='topic+sym'></span><span id='topic+syms'></span><span id='topic+expr'></span><span id='topic+enexpr'></span>

<h3>Description</h3>

<p>These functions provide tidy eval-compatible ways to capture symbols
(<code>sym()</code>, <code>syms()</code>), expressions (<code>expr()</code>, <code>enexpr()</code>), and quosures
(<code>quo()</code>, <code>enquo()</code>).
</p>

<hr>
<h2 id='widecr'>Wide format of competition results</h2><span id='topic+widecr'></span><span id='topic+is_widecr'></span><span id='topic+as_widecr'></span><span id='topic+as_tibble.widecr'></span>

<h3>Description</h3>

<p>Functions for dealing with competition results in wide format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_widecr(cr_data)

as_widecr(cr_data, repair = TRUE, ...)

## S3 method for class 'widecr'
as_tibble(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="widecr_+3A_cr_data">cr_data</code></td>
<td>
<p>Data of competition results (convertible to tabular).</p>
</td></tr>
<tr><td><code id="widecr_+3A_repair">repair</code></td>
<td>
<p>Whether to repair input.</p>
</td></tr>
<tr><td><code id="widecr_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="widecr_+3A_x">x</code></td>
<td>
<p>Object to be converted to <a href="tibble.html#topic+tibble">tibble</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as_widecr()</code> is S3 method for converting data to <code>widecr</code>. When
using <strong>default</strong> method if <code>repair</code> is <code>TRUE</code> it also tries to fix
possible problems (see &quot;Repairing&quot;). If <code>repair</code> is <code>FALSE</code> it converts
<code>cr_data</code> to <a href="tibble.html#topic+tibble">tibble</a> and adds <code>widecr</code> class to it.
</p>
<p>When applying <code>as_widecr()</code> to proper (check via <code><a href="#topic+is_longcr">is_longcr()</a></code> is made)
<strong><code>longcr</code></strong> object, conversion is made:
</p>

<ul>
<li><p> All columns except &quot;game&quot;, &quot;player&quot; and &quot;score&quot; are dropped.
</p>
</li>
<li><p> Conversion from long to wide format is made. The number of &quot;player&quot;-&quot;score&quot;
pairs is taken as the maximum number of players in game. If not all games are
played between the same number of players then there will be <code>NA</code>'s in some
pairs. Column <code>game</code> is preserved in output and is used for arranging in
increasing order.
</p>
</li></ul>

<p>For appropriate <strong><code>widecr</code></strong> objects <code>as_widecr</code> returns its input  and
throws error otherwise.
</p>


<h3>Value</h3>

<p><code>is_widecr()</code> returns <code>TRUE</code> if its argument is appropriate object
of class <code>widecr</code>: it should inherit classes <code>widecr</code>, <code>tbl_df</code> (in other
words, to be <a href="tibble.html#topic+tibble">tibble</a>) and have complete pairs of
&quot;player&quot;-&quot;score&quot; columns where pair is detected by <strong>digits</strong> after strings
&quot;player&quot; and &quot;score&quot; respectively. Columns of &quot;player&quot; and &quot;score&quot; types
shouldn't have any extra symbols except type name and digits after it. All
other columns are considered as &quot;extra columns&quot;.
</p>
<p><code>as_widecr()</code> returns an object of class <code>widecr</code>.
</p>
<p><a href="tibble.html#topic+as_tibble">as_tibble()</a> applied to <code>widecr</code> object drops <code>widecr</code>
class.
</p>


<h3>Wide format of competition results</h3>

<p>It is assumed that competition consists from multiple games (matches,
comparisons, etc.). One game can consist only from <strong>constant</strong> number
of players. Inside a game all players are treated equally.
In every game every player has some score: the value of arbitrary nature
that fully characterizes player's performance in particular game (in most
cases it is some numeric value).
</p>
<p><code>widecr</code> inherits from <code>tibble</code>. Data should be organized in pairs of columns
&quot;player&quot;-&quot;score&quot;. Identifier of a pair should go after respective keyword and
consist only from digits. For example: player1, score1, player2, score2.
Order doesn't matter. Extra columns are allowed.
</p>
<p>To account for R standard string ordering, identifiers of pairs should be
formatted with leading zeros (when appropriate). For example: player01,
score01, ..., player10, score10.
</p>
<p>Column <code>game</code> for game identifier is optional. If present it will be used in
conversion to <code>longcr</code> format via <code><a href="#topic+as_longcr">as_longcr()</a></code>.
</p>


<h3>Repairing</h3>

<p>Option <code>repair = TRUE</code> (default) in <code>as_widecr()</code> means that its result is
going to be repaired with following actions:
</p>

<ul>
<li><p> Detect columns with names containing &quot;player&quot; or &quot;score&quot; (ignoring case).
All other columns are treated as &quot;extra&quot;.
</p>
</li>
<li><p> Extract first occurrence of &quot;player&quot; or &quot;score&quot; (ignoring case) from names
of detected columns. Everything after extracted word is treated as identifier
of &quot;player&quot;-&quot;score&quot; pair.
</p>
</li>
<li><p> Convert these identifiers to numeric form with
<code>as.integer(as.factor(...))</code>.
</p>
</li>
<li><p> Convert identifiers once again to character form with possible leading
zeros (to account for R standard string ordering).
</p>
</li>
<li><p> Spread pairs to appropriate columns with possible column adding (which
were missed in original pairs based on information of pair identifier) with
<code>NA_integer_</code>.
</p>
</li>
<li> <p><strong>Note</strong> that if there is column <code>game</code> (exactly matched) it is placed as
first column.
<strong>Note</strong> that the order (and numeration) of pairs can change.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+longcr">Long format</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cr_data &lt;- data.frame(
  playerA = 1:10,
  playerB = 2:11,
  scoreC = 11:20,
  scoreB = 12:21,
  otherColumn = 101:110
)
cr_data_wide &lt;- as_widecr(cr_data, repair = TRUE)

is_widecr(cr_data_wide)

as_tibble(cr_data_wide)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
