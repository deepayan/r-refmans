<!DOCTYPE html><html lang="en"><head><title>Help for package DatabionicSwarm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DatabionicSwarm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DatabionicSwarm-package'>
<p>Swarm Intelligence for Self-Organized Clustering</p></a></li>
<li><a href='#DBSclustering'>
<p>Databonic swarm clustering (DBS)</p></a></li>
<li><a href='#DefaultColorSequence'>
<p>Default color sequence for plots</p></a></li>
<li><a href='#Delaunay4Points'>
<p>Adjacency matrix of the delaunay graph for BestMatches of Points</p></a></li>
<li><a href='#Delta3DWeightsC'>
<p>intern function, do not use yourself</p></a></li>
<li><a href='#DijkstraSSSP'>
<p>Internal function: Dijkstra SSSP</p></a></li>
<li><a href='#findPossiblePositionsCsingle'>
<p>Intern function, do not use yourself</p></a></li>
<li><a href='#GeneratePswarmVisualization'>
<p>Generates the Umatrix for Pswarm algorithm</p></a></li>
<li><a href='#getCartesianCoordinates'><p>Intern function: Transformation of Databot indizes to coordinates</p></a></li>
<li><a href='#getUmatrix4Projection'><p>depricated! see GeneralizedUmatrix() Generalisierte U-Matrix fuer Projektionsverfahren</p></a></li>
<li><a href='#Hepta'>
<p>Hepta is part of the Fundamental Clustering Problem Suit (FCPS) [Thrun/Ultsch, 2020].</p></a></li>
<li><a href='#Lsun3D'>
<p>Lsun3D is part of the Fundamental Clustering Problem Suit (FCPS) [Thrun/Ultsch, 2020].</p></a></li>
<li><a href='#plotSwarm'>
<p>Intern function for plotting during the Pswarm annealing process</p></a></li>
<li><a href='#ProjectedPoints2Grid'>
<p>Transforms ProjectedPoints to a grid</p></a></li>
<li><a href='#Pswarm'>
<p>A Swarm of Databots based on polar coordinates (Polar Swarm).</p></a></li>
<li><a href='#PswarmEpochsParallel'><p>Intern function, do not use yourself</p></a></li>
<li><a href='#PswarmEpochsSequential'><p>Intern function, do not use yourself</p></a></li>
<li><a href='#PswarmRadiusParallel'><p>Intern function, do not use yourself</p></a></li>
<li><a href='#PswarmRadiusSequential'><p>intern function, do not use yourself</p></a></li>
<li><a href='#rDistanceToroidCsingle'>
<p>Intern function for <code>Pswarm</code></p></a></li>
<li><a href='#RelativeDifference'>
<p>Relative Difference</p></a></li>
<li><a href='#RobustNorm_BackTrafo'>
<p>Transforms the Robust Normalization back</p></a></li>
<li><a href='#RobustNormalization'>
<p>RobustNormalization</p></a></li>
<li><a href='#sESOM4BMUs'>
<p>Intern function: Simplified Emergent Self-Organizing Map</p></a></li>
<li><a href='#setdiffMatrix'><p>setdiffMatrix shortens Matrix2Curt by those rows that are in both</p>
matrices.</a></li>
<li><a href='#setGridSize'>
<p>Sets the grid size for the Pswarm algorithm</p></a></li>
<li><a href='#setPolarGrid'>
<p>Intern function: Sets the polar grid</p></a></li>
<li><a href='#setRmin'><p>Intern function: Estimates the minimal radius for the Databot scent</p></a></li>
<li><a href='#ShortestGraphPathsC'>
<p>Shortest GraphPaths = geodesic distances</p></a></li>
<li><a href='#trainstepC'>
<p>internal function for s-esom</p></a></li>
<li><a href='#trainstepC2'>
<p>internal function for s-esom</p></a></li>
<li><a href='#UniquePoints'>
<p>Unique Points</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Title:</td>
<td>Swarm Intelligence for Self-Organized Clustering</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-20</td>
</tr>
<tr>
<td>Description:</td>
<td>Algorithms implementing populations of agents that interact with one another and sense their environment may exhibit emergent behavior such as self-organization and swarm intelligence. Here, a swarm system called Databionic swarm (DBS) is introduced which was published in Thrun, M.C., Ultsch A.: "Swarm Intelligence for Self-Organized Clustering" (2020), Artificial Intelligence, &lt;<a href="https://doi.org/10.1016%2Fj.artint.2020.103237">doi:10.1016/j.artint.2020.103237</a>&gt;. DBS is able to adapt itself to structures of high-dimensional data such as natural clusters characterized by distance and/or density based structures in the data space. The first module is the parameter-free projection method called Pswarm (Pswarm()), which exploits the concepts of self-organization and emergence, game theory, swarm intelligence and symmetry considerations. The second module is the parameter-free high-dimensional data visualization technique, which generates projected points on the topographic map with hypsometric tints defined by the generalized U-matrix (GeneratePswarmVisualization()). The third module is the clustering method itself with non-critical parameters (DBSclustering()). Clustering can be verified by the visualization and vice versa. The term DBS refers to the method as a whole. It enables even a non-professional in the field of data mining to apply its algorithms for visualization and/or clustering to data sets with completely different structures drawn from diverse research fields. The comparison to common projection methods can be found in the book of Thrun, M.C.: "Projection Based Clustering through Self-Organization and Swarm Intelligence" (2018) &lt;<a href="https://doi.org/10.1007%2F978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>&gt;.</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.8), RcppParallel (&ge; 5.1.4), deldir,
GeneralizedUmatrix, ABCanalysis, ggplot2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>DataVisualizations, knitr (&ge; 1.12), rmarkdown (&ge; 0.9),
plotrix, geometry, sp, spdep, parallel, rgl, png,
ProjectionBasedClustering, parallelDist, pracma, dendextend</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppParallel</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make, pandoc (&gt;=1.12.3, needed for vignettes)</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.deepbionics.org/">https://www.deepbionics.org/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Mthrun/DatabionicSwarm/issues">https://github.com/Mthrun/DatabionicSwarm/issues</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-20 09:08:14 UTC; quiri</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Thrun <a href="https://orcid.org/0000-0001-9542-5543"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Quirin Stier <a href="https://orcid.org/0000-0002-7896-4737"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, rev]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Thrun &lt;m.thrun@gmx.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-20 10:10:16 UTC</td>
</tr>
</table>
<hr>
<h2 id='DatabionicSwarm-package'>
Swarm Intelligence for Self-Organized Clustering
</h2><span id='topic+DatabionicSwarm-package'></span><span id='topic+DatabionicSwarm'></span>

<h3>Description</h3>

<p>Algorithms implementing populations of agents that interact with one another and sense their environment may exhibit emergent behavior such as self-organization and swarm intelligence. Here, a swarm system called Databionic swarm (DBS) is introduced which was published in Thrun, M.C., Ultsch A.: &quot;Swarm Intelligence for Self-Organized Clustering&quot; (2020), Artificial Intelligence, &lt;DOI:10.1016/j.artint.2020.103237&gt;. DBS is able to adapt itself to structures of high-dimensional data such as natural clusters characterized by distance and/or density based structures in the data space. The first module is the parameter-free projection method called Pswarm (Pswarm()), which exploits the concepts of self-organization and emergence, game theory, swarm intelligence and symmetry considerations. The second module is the parameter-free high-dimensional data visualization technique, which generates projected points on the topographic map with hypsometric tints defined by the generalized U-matrix (GeneratePswarmVisualization()). The third module is the clustering method itself with non-critical parameters (DBSclustering()). Clustering can be verified by the visualization and vice versa. The term DBS refers to the method as a whole. It enables even a non-professional in the field of data mining to apply its algorithms for visualization and/or clustering to data sets with completely different structures drawn from diverse research fields. The comparison to common projection methods can be found in the book of Thrun, M.C.: &quot;Projection Based Clustering through Self-Organization and Swarm Intelligence&quot; (2018) &lt;DOI:10.1007/978-3-658-20540-9&gt;.
</p>


<h3>Details</h3>

<p>For a brief introduction to <span class="pkg">DatabionicSwarm</span> please see the vignette <a href="../doc/DatabionicSwarm.html">Short Intro to the Databionic Swarm (DBS)</a>.
The license is CC BY-NC-SA 4.0.
</p>

<p>Index of help topics:
</p>
<pre>
DBSclustering           Databonic swarm clustering (DBS)
DatabionicSwarm-package
                        Swarm Intelligence for Self-Organized
                        Clustering
DefaultColorSequence    Default color sequence for plots
Delaunay4Points         Adjacency matrix of the delaunay graph for
                        BestMatches of Points
Delta3DWeightsC         intern function, do not use yourself
DijkstraSSSP            Internal function: Dijkstra SSSP
GeneratePswarmVisualization
                        Generates the Umatrix for Pswarm algorithm
Hepta                   Hepta is part of the Fundamental Clustering
                        Problem Suit (FCPS) [Thrun/Ultsch, 2020].
Lsun3D                  Lsun3D is part of the Fundamental Clustering
                        Problem Suit (FCPS) [Thrun/Ultsch, 2020].
ProjectedPoints2Grid    Transforms ProjectedPoints to a grid
Pswarm                  A Swarm of Databots based on polar coordinates
                        (Polar Swarm).
PswarmEpochsParallel    Intern function, do not use yourself
PswarmEpochsSequential
                        Intern function, do not use yourself
PswarmRadiusParallel    Intern function, do not use yourself
PswarmRadiusSequential
                        intern function, do not use yourself
RelativeDifference      Relative Difference
RobustNorm_BackTrafo    Transforms the Robust Normalization back
RobustNormalization     RobustNormalization
ShortestGraphPathsC     Shortest GraphPaths = geodesic distances
UniquePoints            Unique Points
findPossiblePositionsCsingle
                        Intern function, do not use yourself
getCartesianCoordinates
                        Intern function: Transformation of Databot
                        indizes to coordinates
getUmatrix4Projection   depricated! see GeneralizedUmatrix()
                        Generalisierte U-Matrix fuer
                        Projektionsverfahren
plotSwarm               Intern function for plotting during the Pswarm
                        annealing process
rDistanceToroidCsingle
                        Intern function for 'Pswarm'
sESOM4BMUs              Intern function: Simplified Emergent
                        Self-Organizing Map
setGridSize             Sets the grid size for the Pswarm algorithm
setPolarGrid            Intern function: Sets the polar grid
setRmin                 Intern function: Estimates the minimal radius
                        for the Databot scent
setdiffMatrix           setdiffMatrix shortens Matrix2Curt by those
                        rows that are in both matrices.
trainstepC              internal function for s-esom
trainstepC2             internal function for s-esom
</pre>


<h3>Note</h3>

<p>For interactive Island Generation of a generalized Umatrix  
see <code>interactiveGeneralizedUmatrixIsland</code> function in the package <span class="pkg">ProjectionBasedClustering</span>.
</p>
<p>If you want to verifiy your clustering result externally, you can use <code>Heatmap</code> or <code>SilhouettePlot</code> of the CRAN package <span class="pkg">DataVisualizations</span>.
</p>


<h3>Author(s)</h3>

<p>Michal Thrun
</p>
<p>Maintainer: Michael Thrun &lt;m.thrun@gmx.net&gt;
</p>


<h3>References</h3>

<p>[Thrun/Ultsch, 2021]  Thrun, M. C., and Ultsch, A.: Swarm Intelligence for Self-Organized Clustering, Artificial Intelligence, Vol. 290, pp. 103237, <a href="https://doi.org/10.1016/j.artint.2020.103237">doi:10.1016/j.artint.2020.103237</a>, 2021.
</p>
<p>[Thrun/Ultsch, 2021] Thrun, M. C., &amp; Ultsch, A.: Swarm Intelligence for Self-Organized Clustering (Extended Abstract), in Bessiere, C. (Ed.), 29th International Joint Conference on Artificial Intelligence (IJCAI), Vol. IJCAI-20, pp. 5125&ndash;5129, <a href="https://doi.org/10.24963/ijcai.2020/720">doi:10.24963/ijcai.2020/720</a>, Yokohama, Japan, Jan., 2021. 
</p>
<p>[Thrun/Ultsch, 2020]  Thrun, M. C., &amp; Ultsch, A.: Uncovering High-Dimensional Structures of Projections from Dimensionality Reduction Methods, MethodsX, Vol. 7, pp. 101093, DOI <a href="https://doi.org/10.1016/j.mex.2020.101093">doi:10.1016/j.mex.2020.101093</a>, 2020. 
</p>
<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer, Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018. 
</p>
<p>[Ultsch/Thrun, 2017]  Ultsch, A., &amp; Thrun, M. C.: Credible Visualizations for Planar Projections, in Cottrell, M. (Ed.), 12th International Workshop on Self-Organizing Maps and Learning Vector Quantization, Clustering and Data Visualization (WSOM), IEEE Xplore, France, 2017.
</p>
<p>[Thrun et al., 2016]  Thrun, M. C., Lerch, F., Loetsch, J., &amp; Ultsch, A.: Visualization and 3D Printing of Multivariate Data of Biomarkers, in Skala, V. (Ed.), International Conference in Central Europe on Computer Graphics, Visualization and Computer Vision (WSCG), Vol. 24, Plzen, http://wscg.zcu.cz/wscg2016/short/A43-full.pdf, 2016.
</p>
<p>Successfully used in
</p>
<p>[Thrun et al., 2018]   Thrun, M. C., Breuer, L., &amp; Ultsch, A. : Knowledge discovery from low-frequency stream nitrate concentrations: hydrology and biology contributions, Proc. European Conference on Data Analysis (ECDA), pp. 46-47, Paderborn, Germany, 2018. 
</p>
<p>[Weyer-Menkhoff et al., 2018]  Weyer-Menkhoff, I., Thrun, M. C., &amp; Loetsch, J.: Machine-learned analysis of quantitative sensory testing responses to noxious cold stimulation in healthy subjects, European Journal of Pain, Vol. 22(5), pp. 862-874, DOI <a href="https://doi.org/10.1002/ejp.1173">doi:10.1002/ejp.1173</a>, 2018. 
</p>
<p>[Kringel et al., 2018]  Kringel, D., Geisslinger, G., Resch, E., Oertel, B. G., Thrun, M. C., Heinemann, S., &amp; Loetsch, J. : Machine-learned analysis of the association of next-generation sequencing based human TRPV1 and TRPA1 genotypes with the sensitivity to heat stimuli and topically applied capsaicin, Pain, Vol. 159 (7 ), pp. 1366-1381, DOI <a href="https://doi.org/10.1097/j.pain.0000000000001222">doi:10.1097/j.pain.0000000000001222</a>, 2018 
</p>
<p>[Thrun, 2019]  Thrun, M. C.: : Cluster Analysis of Per Capita Gross Domestic Products, Entrepreneurial Business and Economics Review (EBER), Vol. 7(1), pp. 217-231, DOI: <a href="https://doi.org/10.15678/EBER.2019.070113">doi:10.15678/EBER.2019.070113</a>, 2019.
</p>
<p>[Lopez-Garcia et al., 2020]  Lopez-Garcia, P., Argote, D. L., &amp; Thrun, M. C.: Projection-based Classification of Chemical Groups and Provenance Analysis of Archaeological Materials, IEEE Access, Vol. 8, pp. 152439-152451, DOI <a href="https://doi.org/10.1109/ACCESS.2020.3016244">doi:10.1109/ACCESS.2020.3016244</a>, 2020. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('Lsun3D')
##2d projection, without instant visualization of steps

#Alternative I:
#DistanceMatrix hast to be defined by the user.
InputDistances=as.matrix(dist(Lsun3D$Data))

projection=Pswarm(InputDistances)
#2d projection, with instant visualization 

## Not run: 
#Alternative II: DataMatrix, Distance is Euclidean per default
projection=Pswarm(Lsun3D$Data,Cls=Lsun3D$Cls,PlotIt=T)

## End(Not run)
#
##Computation of Generalized Umatrix
# If Non Euclidean Distances are used, Please Use \code{MDS}
# from the ProjectionBasedClustering package with the correct OutputDimension
# to generate a new DataMatrix from the distances (see SheppardDiagram
# or KruskalStress)
genUmatrixList=GeneratePswarmVisualization(Data = Lsun3D$Data,

projection$ProjectedPoints,projection$LC)
## Visualizuation of GenerelizedUmatrix, 
# Estimation of the Number of Clusters=Number of valleys
library(GeneralizedUmatrix)#install if not installed
GeneralizedUmatrix::plotTopographicMap(genUmatrixList$Umatrix,genUmatrixList$Bestmatches)
## Automatic Clustering
# number of Cluster from dendrogram (PlotIt=TRUE) or visualization 
Cls=DBSclustering(k=3, Lsun3D$Data, genUmatrixList$Bestmatches,
genUmatrixList$LC,PlotIt=FALSE)
# Verification, often its better to mark Outliers manually

GeneralizedUmatrix::plotTopographicMap(genUmatrixList$Umatrix,genUmatrixList$Bestmatches,Cls)

## Not run: 
# To generate the 3D landscape in the shape of an island 
# from the toroidal topograpic map visualization
# you may cut your island interactivly around high mountain ranges
Imx = ProjectionBasedClustering::interactiveGeneralizedUmatrixIsland(genUmatrixList$Umatrix,
genUmatrixList$Bestmatches,Cls)

GeneralizedUmatrix::plotTopographicMap(genUmatrixList$Umatrix,
genUmatrixList$Bestmatches, Cls=Cls,Imx = Imx)

## End(Not run)
## Not run: 
library(ProjectionBasedClustering)#install if not installed
Cls2=ProjectionBasedClustering::interactiveClustering(genUmatrixList$Umatrix, 
genUmatrixList$Bestmatches, Cls)

## End(Not run)


</code></pre>

<hr>
<h2 id='DBSclustering'>
Databonic swarm clustering (DBS)
</h2><span id='topic+DBSclustering'></span>

<h3>Description</h3>

<p>DBS is a flexible and robust clustering framework that consists
of three independent modules. The first module is the parameter-free
projection method Pswarm <code><a href="#topic+Pswarm">Pswarm</a></code>, which exploits the concepts of
self-organization and emergence, game theory, swarm intelligence and symmetry
considerations [Thrun/Ultsch, 2021]. The second module is a parameter-free
high-dimensional data visualization technique, which generates projected points
on a topographic map with hypsometric colors
<code><a href="#topic+GeneratePswarmVisualization">GeneratePswarmVisualization</a></code>, called the generalized U-matrix.
The third module is a clustering method with no sensitive parameters
<code><a href="#topic+DBSclustering">DBSclustering</a></code> (see [Thrun, 2018, p. 104 ff]). The clustering can
be verified by the visualization and vice versa. The term DBS refers to the
method as a whole.
</p>
<p>The <code><a href="#topic+DBSclustering">DBSclustering</a></code> function applies the automated Clustering
approach of the Databonic swarm using abstract U distances, which are the
geodesic distances based on high-dimensional distances combined with low
dimensional graph paths by using <code>ShortestGraphPathsC</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DBSclustering(k, DataOrDistance, BestMatches, LC, StructureType = TRUE,
PlotIt = FALSE, ylab,main, method = "euclidean",...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DBSclustering_+3A_k">k</code></td>
<td>
<p>number of clusters, how many to you see in the topographic map
(3D landscape)?</p>
</td></tr>
<tr><td><code id="DBSclustering_+3A_dataordistance">DataOrDistance</code></td>
<td>
<p>Either [1:n,1:d] Matrix of Data (n cases, d dimensions)
that will be used. One DataPoint per row or symmetric Distance matrix [1:n,1:n]</p>
</td></tr>
<tr><td><code id="DBSclustering_+3A_bestmatches">BestMatches</code></td>
<td>
<p>[1:n,1:2] Matrix with positions of Bestmatches or
ProjectedPoints, one matrix line per data point</p>
</td></tr>
<tr><td><code id="DBSclustering_+3A_lc">LC</code></td>
<td>
<p>grid size c(Lines,Columns), please see details</p>
</td></tr>
<tr><td><code id="DBSclustering_+3A_structuretype">StructureType</code></td>
<td>
<p>Optional, bool; = TRUE: compact structure of clusters
assumed, =FALSE: connected structure of clusters assumed. For the two options
for Clusters, see [Thrun, 2018] or Handl et al. 2006</p>
</td></tr>
<tr><td><code id="DBSclustering_+3A_plotit">PlotIt</code></td>
<td>
<p>Optional, bool, Plots Dendrogramm</p>
</td></tr>
<tr><td><code id="DBSclustering_+3A_ylab">ylab</code></td>
<td>
<p>Optional, character vector, ylabel of dendrogramm</p>
</td></tr>
<tr><td><code id="DBSclustering_+3A_main">main</code></td>
<td>
<p>Optional, character vctor, title of dendrogramm</p>
</td></tr>
<tr><td><code id="DBSclustering_+3A_method">method</code></td>
<td>
<p>Optional, one of 39 distance methods of <code>parDist</code> of package
parallelDist,  if Data matrix is chosen above</p>
</td></tr>
<tr><td><code id="DBSclustering_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to the <code>parDist</code> function, e.g.
user-defined distance functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input of the <code>LC</code> parameter depends on the choice of <code>Bestmatches</code>
input argument. Usually as the name of the argument states, the Bestmatches of
the <code><a href="#topic+GeneratePswarmVisualization">GeneratePswarmVisualization</a></code> function are used which is define
in the notation of self-organizing map. In this case please see example one.
</p>
<p>However, as written above, clustering and visualization can be applied
independently of each other. In this case the places of Lines L and Columns C
are switched because Lines is a value slightly above the maximum of the x-coordinates and Columns is a value slightly above the maximum of the y-coordinates  of ProjectedPoint. 
Hence, one should give  <code><a href="#topic+DBSclustering">DBSclustering</a></code> the argument
<code>LC</code> as shown in example 2. 
</p>
<p>Often it is better to mark the outliers  manually after the prozess of
clustering and sometimes a clustering can be improved through human interaction
[Thrun/Ultsch,2017] &lt;DOI:10.13140/RG.2.2.13124.53124&gt;; use in this case the
visualization <code><a href="GeneralizedUmatrix.html#topic+plotTopographicMap">plotTopographicMap</a></code> of the
package GeneralizedUmatrix. If you would like to mark the outliers interactivly
in the visualization use the <span class="pkg">ProjectionBasedClustering</span> package with the
function <code>interactiveClustering()</code>, or for full interactive clustering
<code>IPBC()</code>. The package is available on CRAN. An example is shown in case
of  <code>interactiveClustering()</code> function in the third example.
</p>


<h3>Value</h3>

<p>[1:n] numerical vector of numbers defining the classification as the main output
of this cluster analysis for the n cases of data corresponding to the n
bestmatches. It has k unique numbers representing the arbitrary labels of the
clustering. You can use <code>plotTopographicMap(Umatrix,Bestmatches,Cls)</code> for
verification.
</p>


<h3>Note</h3>

<p>If you want to verifiy your clustering result externally, you can use
<code>Heatmap</code> or <code>SilhouettePlot</code> of the package <span class="pkg">DataVisualizations</span>
available on CRAN.
</p>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>[Thrun/Ultsch, 2021]  Thrun, M. C., and Ultsch, A.: Swarm Intelligence for
Self-Organized Clustering, Artificial Intelligence, Vol. 290, pp. 103237,
<a href="https://doi.org/10.1016/j.artint.2020.103237">doi:10.1016/j.artint.2020.103237</a>, 2021.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Lsun3D")
Data=Lsun3D$Data
InputDistances=as.matrix(dist(Data))

projection=Pswarm(InputDistances)

## Example One

genUmatrixList=GeneratePswarmVisualization(Data,
projection$ProjectedPoints,projection$LC)
Cls=DBSclustering(k=3, Data, genUmatrixList$Bestmatches,
genUmatrixList$LC,PlotIt=TRUE)


## Example Two
#automatic Clustering without GeneralizedUmatrix visualization
Cls=DBSclustering(k=3, Data, projection$ProjectedPoints,projection$LC,
PlotIt=TRUE)

## Not run: 
## Example Three
## Sometimes an automatic Clustering can be improved 
## through an interactive approach, 
## e.g. if Outliers exist (see [Thrun/Ultsch, 2017])
library(ProjectionBasedClustering)
Cls2=ProjectionBasedClustering::interactiveClustering(genUmatrixList$Umatrix, 
genUmatrixList$Bestmatches, Cls)

## End(Not run)

</code></pre>

<hr>
<h2 id='DefaultColorSequence'>
Default color sequence for plots
</h2><span id='topic+DefaultColorSequence'></span>

<h3>Description</h3>

<p>Defines the default color sequence for plots made within the Projections package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DefaultColorSequence")</code></pre>


<h3>Format</h3>

<p>A vector with 562 different strings describing colors for plots.
</p>

<hr>
<h2 id='Delaunay4Points'>
Adjacency matrix of the delaunay graph for BestMatches of Points
</h2><span id='topic+Delaunay4Points'></span>

<h3>Description</h3>

<p>Calculates the adjacency matrix of the delaunay graph for BestMatches (BMs) in tiled form if BestMatches are located on a toroid grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Delaunay4Points(Points, IsToroid = TRUE,LC,PlotIt=FALSE,Gabriel=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Delaunay4Points_+3A_points">Points</code></td>
<td>
<p>[1:n,1:3] matrix containing the BMKey, X and Y coordinates of the n,  BestMatches NEED NOT to be UNIQUE,  however, there is an edge in the Deaunay between duplicate points!</p>
</td></tr>
<tr><td><code id="Delaunay4Points_+3A_istoroid">IsToroid</code></td>
<td>
<p>Optional, logical, indicating if BM's are on a toroid grid. Default is True</p>
</td></tr>
<tr><td><code id="Delaunay4Points_+3A_lc">LC</code></td>
<td>
<p>Optional, A vector of length 2, containing the number of lines and columns of the Grid</p>
</td></tr>
<tr><td><code id="Delaunay4Points_+3A_plotit">PlotIt</code></td>
<td>
<p>Optional, bool, Plots the graph</p>
</td></tr>
<tr><td><code id="Delaunay4Points_+3A_gabriel">Gabriel</code></td>
<td>
<p>Optional, bool, default: FALSE, If TRUE: calculates the gabriel graph instead of the delaunay graph</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Delaunay[1:n,1:n]               adjacency matrix of the Delaunay-Graph
</p>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer, Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018. 
</p>

<hr>
<h2 id='Delta3DWeightsC'>
intern function, do not use yourself
</h2><span id='topic+Delta3DWeightsC'></span>

<h3>Description</h3>

<p>Delta3DWeightsC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Delta3DWeightsC(vx, Datasample)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Delta3DWeightsC_+3A_vx">vx</code></td>
<td>
<p>Array [1:n,1:m,1:d] of neuron weights on a nxm grid with d dimensional
weights.</p>
</td></tr>
<tr><td><code id="Delta3DWeightsC_+3A_datasample">Datasample</code></td>
<td>
<p>One observation of a d-dimensional datapoint.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Algorithm is described in [Thrun, 2018, p. 95, Listing 8.1].
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>vx</code></td>
<td>
<p>Array [1:n,1:m,1:l]</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer, Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018. 
</p>

<hr>
<h2 id='DijkstraSSSP'>
Internal function: Dijkstra SSSP
</h2><span id='topic+DijkstraSSSP'></span>

<h3>Description</h3>

<p>Dijkstra's SSSP (Single source shortest path) algorithm:
</p>
<p>gets the shortest path (geodesic distance) from source vertice(point) to all other vertices(points) defined by 
the edges of the adjasency matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DijkstraSSSP(Adj, Costs, source)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DijkstraSSSP_+3A_adj">Adj</code></td>
<td>

<p>[1:n,1:n]         0/1 adjascency matrix, e.g. from delaunay graph or gabriel graph
</p>
</td></tr>
<tr><td><code id="DijkstraSSSP_+3A_costs">Costs</code></td>
<td>

<p>[1:n,1:n]       matrix, distances between n points (normally euclidean)
</p>
</td></tr>
<tr><td><code id="DijkstraSSSP_+3A_source">source</code></td>
<td>

<p>int, vertice(point) from which to calculate the geodesic distance to all other points
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Preallocating space for DataStructures accordingly to the maximum possible number of vertices which is fixed set at 
the number 10001.
This is an internal function of <code><a href="#topic+ShortestGraphPathsC">ShortestGraphPathsC</a></code>, no errors or mis-usage is caught here.
</p>


<h3>Value</h3>

<p>ShortestPaths[1:n]   vector, shortest paths (geodesic) to all other vertices including the source vertice itself
</p>


<h3>Note</h3>

<p>runs in O(E*Log(V))
</p>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>uses a changed code which is inspired by Shreyans Sheth 28.05.2015, see 
<a href="https://ideone.com/qkmt31">https://ideone.com/qkmt31</a>
</p>

<hr>
<h2 id='findPossiblePositionsCsingle'>
Intern function, do not use yourself
</h2><span id='topic+findPossiblePositionsCsingle'></span>

<h3>Description</h3>

<p>Finds all possible jumping position regarding a grid anda Radius for DataBots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findPossiblePositionsCsingle(RadiusPositionsschablone,
 jumplength, alpha, Lines)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findPossiblePositionsCsingle_+3A_radiuspositionsschablone">RadiusPositionsschablone</code></td>
<td>
<p>NumericMatrix, see <code><a href="#topic+setPolarGrid">setPolarGrid</a></code></p>
</td></tr>
<tr><td><code id="findPossiblePositionsCsingle_+3A_jumplength">jumplength</code></td>
<td>
<p>double radius of databots regarding neighborhood, they can jump to</p>
</td></tr>
<tr><td><code id="findPossiblePositionsCsingle_+3A_alpha">alpha</code></td>
<td>
<p>double, zu streichen</p>
</td></tr>
<tr><td><code id="findPossiblePositionsCsingle_+3A_lines">Lines</code></td>
<td>
<p>double, jumpinglength has to smaller than Lines/2 and Lines/2 has to yield to a integer number. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Algorithm is described in [Thrun, 2018, p. 95, Listing 8.1].
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>OpenPositions</code></td>
<td>
<p>NumericMatrix, indizes of open positions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer, Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setPolarGrid">setPolarGrid</a></code>
</p>

<hr>
<h2 id='GeneratePswarmVisualization'>
Generates the Umatrix for Pswarm algorithm
</h2><span id='topic+GeneratePswarmVisualization'></span>

<h3>Description</h3>

<p>DBS is a flexible and robust clustering framework that consists
of three independent modules. The first module is the parameter-free
projection method Pswarm <code><a href="#topic+Pswarm">Pswarm</a></code>, which exploits the concepts of self-organization
and emergence, game theory, swarm intelligence and symmetry considerations. 
The second module is a parameter-free high-dimensional data visualization technique, 
which generates projected points on a topographic map with hypsometric colors <code><a href="#topic+GeneratePswarmVisualization">GeneratePswarmVisualization</a></code>, 
called the generalized U-matrix. The third module is a clustering method with no 
sensitive parameters <code><a href="#topic+DBSclustering">DBSclustering</a></code>. The clustering can be verified by the visualization and vice versa. 
The term DBS refers to the method as a whole. 
</p>
<p>The <code><a href="#topic+GeneratePswarmVisualization">GeneratePswarmVisualization</a></code> function generates the special case (please see [Thrun, 2018]) of the generalized Umatrix with the help of an unsupervised neural network (simplified emergent self-organizing map  published in [Thrun/Ultsch, 2020]). From the generalized Umatrix a topographic map with hypsometric tints can be visualized. To see this visualization use <code><a href="GeneralizedUmatrix.html#topic+plotTopographicMap">plotTopographicMap</a></code> of the package <span class="pkg">GeneralizedUmatrix</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeneratePswarmVisualization(Data, ProjectedPoints, LC, PlotIt=FALSE,
ComputeInR=FALSE, Parallel=TRUE, Tiled = FALSE, DataPerEpoch = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GeneratePswarmVisualization_+3A_data">Data</code></td>
<td>
<p>[1:n,1:d] array of data: n cases in rows, d variables in columns</p>
</td></tr>
<tr><td><code id="GeneratePswarmVisualization_+3A_projectedpoints">ProjectedPoints</code></td>
<td>
<p>matrix, ProjectedPoints[1:n,1:2]  n by 2 matrix containing coordinates of the Projection: A matrix of the fitted configuration. see output of <code><a href="#topic+Pswarm">Pswarm</a></code> for further details</p>
</td></tr>
<tr><td><code id="GeneratePswarmVisualization_+3A_lc">LC</code></td>
<td>
<p>size of the grid c(Lines,Columns), number of Lines and Columns automatic calculated by <code><a href="#topic+setGridSize">setGridSize</a></code> in <code><a href="#topic+Pswarm">Pswarm</a></code>
</p>
<p>Sometimes is better to choose a different grid size, e.g. to to reduce computional effort
contrary to SOM, here the grid size defined only the resolution of the visualizations
The real grid size is predfined by Pswarm, but you may choose a factor x*res$LC if you so desire.
Therefore, The resulting grid size is given back in the Output.
</p>
</td></tr>
<tr><td><code id="GeneratePswarmVisualization_+3A_plotit">PlotIt</code></td>
<td>
<p>Optional, default(FALSE), If TRUE than uses <code>plotTopographicMap</code> of the package GeneralizedUmatrix is plotted as a topview in the tiled option, see details for explanation.</p>
</td></tr>
<tr><td><code id="GeneratePswarmVisualization_+3A_computeinr">ComputeInR</code></td>
<td>
<p>Optional, =TRUE: Rcode, =FALSE C++ implementation</p>
</td></tr>
<tr><td><code id="GeneratePswarmVisualization_+3A_parallel">Parallel</code></td>
<td>
<p>Optional, =TRUE: Parallel C++ implementation, =FALSE Sequential C++ implementation</p>
</td></tr>
<tr><td><code id="GeneratePswarmVisualization_+3A_tiled">Tiled</code></td>
<td>
<p>Optional, =TRUE: arrangement of four grids for better understanding of edge behaviour, =FALSE: single grid.</p>
</td></tr>
<tr><td><code id="GeneratePswarmVisualization_+3A_dataperepoch">DataPerEpoch</code></td>
<td>
<p>Optional: Number between 0 and 1 stating the ratio of data per epoch for training of the generalized u-matrix approach.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tiled: The topographic map is visualized 4 times because the projection is toroidal. The reason is that there are no border in the visualizations and clusters (if they exist) are not disrupted by borders of the plot.
</p>
<p>If you used <code><a href="#topic+Pswarm">Pswarm</a></code> with distance matrix instead of a data matrix (in the sense that you do not have any data matrix available), you may transform your distances into data by using <code>MDS</code> of the <span class="pkg">ProjectionBasedClustering</span> package in order to use the <code><a href="#topic+GeneratePswarmVisualization">GeneratePswarmVisualization</a></code> function. The correct dimension can be found through the Sheppard diagram or kruskals stress.
</p>


<h3>Value</h3>

<p>list of
</p>
<table role = "presentation">
<tr><td><code>Bestmatches</code></td>
<td>
<p>matrix [1:n,1:2], BestMatches of the Umatrix, contrary to ESOM they are always fixed, because predefined by GridPoints.</p>
</td></tr>
<tr><td><code>Umatrix</code></td>
<td>
<p>matrix [1:Lines,1:Columns],</p>
</td></tr>
<tr><td><code>WeightsOfNeurons</code></td>
<td>
<p>array [1:Lines,1:Columns,1:d], d is the dimension of the weights, the same as in the ESOM algorithm</p>
</td></tr>
<tr><td><code>GridPoints</code></td>
<td>
<p>matrix [1:n,1:2],quantized projected points: projected points now lie on a predefined grid.</p>
</td></tr>
<tr><td><code>LC</code></td>
<td>
<p>c(Lines,Columns), normally equal to grid size of Pswarm, sometimes it a better or a lower resolution for the visualization is better.
Therefore here the grid size of the neurons is given back.
</p>
</td></tr>
<tr><td><code>PlotlyHandle</code></td>
<td>
<p>If PlotIt=FALSE: NULL, otherwise plotly object for ploting topview of topographic map
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If you used pswarm with distance matrix instead of a data matrix you can mds transform your distances into data (see the <code>MDS</code> function of the ProjectionBasedClustering package.). The correct dimension can be found through the Sheppard diagram or kruskals stress.
</p>


<h3>Note</h3>

<p>The extraction of an island out of the generalized Umatrix can be performed using the <code>interactiveGeneralizedUmatrixIsland</code> function in the package <span class="pkg">ProjectionBasedClustering</span>.
</p>
<p>The main code of both functions <code>GeneralizedUmatrix</code> and
<code>GeneratePswarmVisualization</code> is the same C++ function
<code>sESOM4BMUs</code> which is described in [Thrun/Ultsch, 2020].
</p>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer, Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018. 
</p>
<p>[Thrun/Ultsch, 2020]  Thrun, M. C., &amp; Ultsch, A.: Uncovering High-Dimensional Structures of Projections from Dimensionality Reduction Methods, MethodsX, Vol. 7, pp. 101093, <a href="https://doi.org/10.1016/j.mex.2020.101093">doi:10.1016/j.mex.2020.101093</a>, 2020. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Pswarm">Pswarm</a></code> and
<code><a href="GeneralizedUmatrix.html#topic+plotTopographicMap">plotTopographicMap</a></code> and <code><a href="GeneralizedUmatrix.html#topic+GeneralizedUmatrix">GeneralizedUmatrix</a></code> of the package <span class="pkg">GeneralizedUmatrix</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Lsun3D")
Data=Lsun3D$Data
Cls=Lsun3D$Cls
InputDistances=as.matrix(dist(Data))

projList=Pswarm(InputDistances)
genUmatrixList=GeneratePswarmVisualization(Data,projList$ProjectedPoints,projList$LC)
library(GeneralizedUmatrix)
plotTopographicMap(genUmatrixList$Umatrix,genUmatrixList$Bestmatches,Cls)



</code></pre>

<hr>
<h2 id='getCartesianCoordinates'>Intern function: Transformation of Databot indizes to coordinates</h2><span id='topic+getCartesianCoordinates'></span>

<h3>Description</h3>

<p>Transforms Databot indizes to exact cartesian coordinates on an toroid two dimensional grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCartesianCoordinates(DataBotsPosRe, DataBotsPosIm, GridRadius, GridAngle,
QuadOrHexa = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getCartesianCoordinates_+3A_databotsposre">DataBotsPosRe</code></td>
<td>
<p>[1:N] real part of complex vector Two Indizes per Databot
describing its positions in an two dimensional grid</p>
</td></tr>
<tr><td><code id="getCartesianCoordinates_+3A_databotsposim">DataBotsPosIm</code></td>
<td>
<p>[1:N] imaginary part of complex vector Two Indizes per
Databot describing its positions in an two dimensional grid</p>
</td></tr>
<tr><td><code id="getCartesianCoordinates_+3A_gridradius">GridRadius</code></td>
<td>
<p>[Columns, Lines] Radii Matrix of all possible Positions of
DataBots in Grid, see also documentation of <code><a href="#topic+setPolarGrid">setPolarGrid</a></code></p>
</td></tr>
<tr><td><code id="getCartesianCoordinates_+3A_gridangle">GridAngle</code></td>
<td>
<p>[Columns, Lines] Angle Matrix of all possible Positions of
DataBots in Grid, see also documentation of <code><a href="#topic+setPolarGrid">setPolarGrid</a></code></p>
</td></tr>
<tr><td><code id="getCartesianCoordinates_+3A_quadorhexa">QuadOrHexa</code></td>
<td>
<p>Optional, FALSE=If DataPos on hexadiagonal grid, round to 2
decimals after value, Default=TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Transformation is described in [Thrun, 2018, p. 93].</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>BestMatchingUnits</code></td>
<td>
<p>[1:N,2] coordinates on an two dimensional grid for
each databot excluding unique key, such that by using
<code><a href="#topic+GeneratePswarmVisualization">GeneratePswarmVisualization</a></code> a visualization of the Pswarm
projection is possible</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Thrun</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer, Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018. 
</p>

<hr>
<h2 id='getUmatrix4Projection'>depricated! see GeneralizedUmatrix() Generalisierte U-Matrix fuer Projektionsverfahren </h2><span id='topic+getUmatrix4Projection'></span>

<h3>Description</h3>

<p>depricated! see GeneralizedUmatrix()</p>


<h3>Usage</h3>

<pre><code class='language-R'>getUmatrix4Projection(Data,ProjectedPoints,
PlotIt=TRUE,Cls=NULL,toroid=T,Tiled=F,ComputeInR=F)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getUmatrix4Projection_+3A_data">Data</code></td>
<td>
<p>[1:n,1:d] array of data: n cases in rows, d variables in columns</p>
</td></tr>
<tr><td><code id="getUmatrix4Projection_+3A_projectedpoints">ProjectedPoints</code></td>
<td>
<p>[1:n,2]n by 2 matrix containing coordinates of the Projection: A matrix of the fitted configuration.</p>
</td></tr>
<tr><td><code id="getUmatrix4Projection_+3A_plotit">PlotIt</code></td>
<td>

<p>Optional,bool, defaut=FALSE, if =TRUE: U-Marix of every current Position of Databots will be shown
</p>
</td></tr>
<tr><td><code id="getUmatrix4Projection_+3A_cls">Cls</code></td>
<td>

<p>Optional, For plotting, see <code>plotUmatrix</code> in package Umatrix
</p>
</td></tr>
<tr><td><code id="getUmatrix4Projection_+3A_toroid">toroid</code></td>
<td>

<p>Optional, Default=FALSE, 
</p>
<p>==FALSE planar computation
</p>
<p>==TRUE: toroid borderless computation, set so only if projection method is also toroidal
</p>
</td></tr>
<tr><td><code id="getUmatrix4Projection_+3A_tiled">Tiled</code></td>
<td>

<p>Optional,For plotting see <code>plotUmatrix</code> in package Umatrix
</p>
</td></tr>
<tr><td><code id="getUmatrix4Projection_+3A_computeinr">ComputeInR</code></td>
<td>

<p>Optional,  =T: Rcode, =F Cpp Code
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with
</p>
<table role = "presentation">
<tr><td><code>Umatrix</code></td>
<td>

<p>[1:Lines,1:Columns] (see <code>ReadUMX</code> in package DataIO)
</p>
</td></tr>
<tr><td><code>EsomNeurons</code></td>
<td>

<p>[Lines,Columns,weights]       3-dimensional numeric array (wide format), not wts (long format)
</p>
</td></tr>
<tr><td><code>Bestmatches</code></td>
<td>

<p>[1:n,OutputDimension]   GridConverted Projected Points information converted by convertProjectionProjectedPoints() to predefined Grid by Lines and Columns
</p>
</td></tr>
<tr><td><code>gplotres</code></td>
<td>

<p>Ausgabe von ggplot
</p>
</td></tr>
<tr><td><code>unbesetztePositionen</code></td>
<td>

<p>Umatrix[unbesetztePositionen] =NA
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Thrun</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer, ISBN: 978-3-658-20539-3, Heidelberg, 2018.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Lsun3D")
Data=Lsun3D$Data
Cls=Lsun3D$Cls
InputDistances=as.matrix(dist(Data))
res=cmdscale(d=InputDistances, k = 2, eig = TRUE, add = FALSE, x.ret = FALSE)
ProjectedPoints=as.matrix(res$points)
# Stress = KruskalStress(InputDistances, as.matrix(dist(ProjectedPoints)))
#resUmatrix=GeneralizedUmatrix(Data,ProjectedPoints)
#plotTopographicMap(resUmatrix$Umatrix,resUmatrix$Bestmatches,Cls)
</code></pre>

<hr>
<h2 id='Hepta'>
Hepta is part of the Fundamental Clustering Problem Suit (FCPS) [Thrun/Ultsch, 2020].
</h2><span id='topic+Hepta'></span>

<h3>Description</h3>

<p>clearly defined clusters, different variances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Hepta")</code></pre>


<h3>Details</h3>

<p>Size 212, Dimensions 3, stored in <code>Hepta$Data</code>
</p>
<p>Classes 7, stored in <code>Hepta$Cls</code>
</p>


<h3>References</h3>

<p>[Thrun/Ultsch, 2020]	Thrun, M. C., &amp; Ultsch, A.: Clustering Benchmark Datasets Exploiting the Fundamental Clustering Problems, Data in Brief,Vol. 30(C), pp. 105501, DOI 10.1016/j.dib.2020.105501 , 2020. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Hepta)
str(Hepta)
</code></pre>

<hr>
<h2 id='Lsun3D'>
Lsun3D is part of the Fundamental Clustering Problem Suit (FCPS) [Thrun/Ultsch, 2020].
</h2><span id='topic+Lsun3D'></span>

<h3>Description</h3>

<p>clearly defined clusters, different variances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Lsun3D")</code></pre>


<h3>Details</h3>

<p>Size 404, Dimensions 3
</p>
<p>Dataset defined discontinuites, where the clusters have different variances.
Three main Clusters, and four Outliers (in Cluster 4). See for a more detailed description in [Thrun, 2018].
</p>


<h3>References</h3>

<p>[Thrun/Ultsch, 2020]	Thrun, M. C., &amp; Ultsch, A.: Clustering Benchmark Datasets Exploiting the Fundamental Clustering Problems, Data in Brief,Vol. 30(C), pp. 105501, DOI 10.1016/j.dib.2020.105501 , 2020. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Lsun3D)
str(Lsun3D)
Cls=Lsun3D$Cls
Data=Lsun3D$Data
</code></pre>

<hr>
<h2 id='plotSwarm'>
Intern function for plotting during the Pswarm annealing process
</h2><span id='topic+plotSwarm'></span>

<h3>Description</h3>

<p>Intern function, generates a scatter plot of the progess of the Pswarm algorithm after every nash equlibirum.
Every point symbolizes a Databot. If a prior classification is given (<code>Cls</code>) then the Databots have the colors defined by the class labels. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSwarm(Points,Cls,xlab,ylab,main)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotSwarm_+3A_points">Points</code></td>
<td>
<p>ProjectedPoints or DataBot positions in cartesian coordinates</p>
</td></tr>
<tr><td><code id="plotSwarm_+3A_cls">Cls</code></td>
<td>
<p>optional, Classification as a numeric vector, if given</p>
</td></tr>
<tr><td><code id="plotSwarm_+3A_xlab">xlab</code></td>
<td>
<p>='X', optional, string</p>
</td></tr>
<tr><td><code id="plotSwarm_+3A_ylab">ylab</code></td>
<td>
<p>='Y', optional, string</p>
</td></tr>
<tr><td><code id="plotSwarm_+3A_main">main</code></td>
<td>
<p>=&quot;DataBots&quot;, optional, string</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Pswarm">Pswarm</a></code> with <code>PlotIt</code>=TRUE
</p>

<hr>
<h2 id='ProjectedPoints2Grid'>
Transforms ProjectedPoints to a grid
</h2><span id='topic+ProjectedPoints2Grid'></span>

<h3>Description</h3>

<p>quantized xy cartesianncoordinates of ProjectedPoints
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ProjectedPoints2Grid(ProjectedPoints, Lines, Columns, PlotIt=FALSE, Cls)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ProjectedPoints2Grid_+3A_projectedpoints">ProjectedPoints</code></td>
<td>
<p>[1:n,1:2] matrix of cartesian xy coordinates</p>
</td></tr>
<tr><td><code id="ProjectedPoints2Grid_+3A_lines">Lines</code></td>
<td>
<p>double, length of small side of the rectangular grid</p>
</td></tr>
<tr><td><code id="ProjectedPoints2Grid_+3A_columns">Columns</code></td>
<td>
<p>double, length of big side of the rectangular grid</p>
</td></tr>
<tr><td><code id="ProjectedPoints2Grid_+3A_plotit">PlotIt</code></td>
<td>
<p>optional, bool, shows the result if TRUE</p>
</td></tr>
<tr><td><code id="ProjectedPoints2Grid_+3A_cls">Cls</code></td>
<td>
<p>Numeric vector containing the classification vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>intern function, described in [Thrun, 2018, p.47]
</p>


<h3>Value</h3>

<p>BestMatches[1:n,1:3] columns in order: Key,Lines,Columns
</p>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer, Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeneratePswarmVisualization">GeneratePswarmVisualization</a></code>
</p>

<hr>
<h2 id='Pswarm'>
A Swarm of Databots based on polar coordinates (Polar Swarm).
</h2><span id='topic+Pswarm'></span>

<h3>Description</h3>

<p>This projetion method is a part of the databionic swarm which uses the nash
equlibrium [Thrun/Ultsch, 2021]. Using polar coordinates for agents (here
Databots) in two dimensions has many advantages, for further details see
[Thrun, 2018] and [Thrun/Ultsch, 2021].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pswarm(DataOrDistance, Cls = NULL, QuadOrHexa = "Hexa", NumJumps = 4,
LC = NULL, Parallel = FALSE, NCores = "max", Verbose = 1,
PlotIt = FALSE, Debug = FALSE, DistanceMeasure = "euclidean",
Eps = 0.001)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Pswarm_+3A_dataordistance">DataOrDistance</code></td>
<td>

<p>Numeric matrix nxd. Two cases here: d=n  =&gt; assuming distance matrix d!=n =&gt;
assuming data matrix with n cases and d features implying the need to compute
the distance matrix internally.
</p>
</td></tr>
<tr><td><code id="Pswarm_+3A_cls">Cls</code></td>
<td>

<p>Numeric vector [1:n] with class labels for each observation in DataOrDistance.
</p>
</td></tr>
<tr><td><code id="Pswarm_+3A_quadorhexa">QuadOrHexa</code></td>
<td>

<p>Optional, Boolean indicating the geometry of tiles the 2D projection plane is
built with.
</p>
</td></tr>
<tr><td><code id="Pswarm_+3A_numjumps">NumJumps</code></td>
<td>

<p>Integer indicating the number of jumps to be considered for each single databot
selected for jumping.
</p>
</td></tr>
<tr><td><code id="Pswarm_+3A_lc">LC</code></td>
<td>

<p>Optional, grid size c(Columns, Lines), sometimes it is better to call
<code><a href="#topic+setGridSize">setGridSize</a></code> separately.
</p>
</td></tr>
<tr><td><code id="Pswarm_+3A_parallel">Parallel</code></td>
<td>

<p>Optional, Boolean: TRUE  = parallel execution, FALSE = single thread execution.
</p>
</td></tr>
<tr><td><code id="Pswarm_+3A_ncores">NCores</code></td>
<td>

<p>Character or integer: choice of number of cores of CPU (in case). Can be 'max'
or a number. The max will always be 'all available cores - 1', to avoid core
overload.
</p>
</td></tr>
<tr><td><code id="Pswarm_+3A_plotit">PlotIt</code></td>
<td>

<p>Optional, bool, default=FALSE, If =TRUE, Plots the projection during the
computation prozess after every nash equlibirum.
</p>
</td></tr>
<tr><td><code id="Pswarm_+3A_debug">Debug</code></td>
<td>

<p>Optional, Debug, default=FALSE, =TRUE results in various console messages,
depricated for CRAN, because cout is not allowed.
</p>
</td></tr>
<tr><td><code id="Pswarm_+3A_distancemeasure">DistanceMeasure</code></td>
<td>

<p>Optional, one of 39 distance methods of <code>parDist</code> of package parallelDist,
if Data matrix is chosen above
</p>
</td></tr>
<tr><td><code id="Pswarm_+3A_verbose">Verbose</code></td>
<td>
<p>optional, integer stating the degree of textual feedback. 0 = no
output, 1 = basic notifications, 2 = progress bar, 3 = details.</p>
</td></tr>
<tr><td><code id="Pswarm_+3A_eps">Eps</code></td>
<td>
<p>optional, double: Stop criterion for convergence of each epoche.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>DBS is a flexible and robust clustering framework that consists of three
independent modules. The first module is the parameter-free projection method
Pswarm <code><a href="#topic+Pswarm">Pswarm</a></code>, which exploits the concepts of self-organization
and emergence, game theory, swarm intelligence and symmetry considerations. The
second module is a parameter-free high-dimensional data visualization technique,
which generates projected points on a topographic map with hypsometric colors
<code><a href="#topic+GeneratePswarmVisualization">GeneratePswarmVisualization</a></code>, called the generalized U-matrix. The
third module is a clustering method with no sensitive parameters
<code><a href="#topic+DBSclustering">DBSclustering</a></code>. The clustering can be verified by the visualization
and vice versa. The term DBS refers to the method as a whole. 
</p>


<h3>Value</h3>

<p>List with
</p>
<table role = "presentation">
<tr><td><code>ProjectedPoints</code></td>
<td>

<p>[1:n,1:2] xy cartesian coordinates of projection
</p>
</td></tr>
<tr><td><code>LC</code></td>
<td>

<p>number of Lines and Columns in c(Lines, Columns)
</p>
</td></tr>
<tr><td><code>Control</code></td>
<td>

<p>List, only for intern debugging
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>LC is now automatically estimated; LC is the size of the grid c(Lines, Columns),
number of Lines and Columns, default c(NULL,NULL) and automatic calculation by
<code><a href="#topic+setGridSize">setGridSize</a></code>.
</p>


<h3>Author(s)</h3>

<p>Michael Thrun, Quirin Stier
</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through
Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer,
Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018.
</p>
<p>[Thrun/Ultsch, 2021]  Thrun, M. C., and Ultsch, A.: Swarm Intelligence for
Self-Organized Clustering, Artificial Intelligence, Vol. 290, pp. 103237,
<a href="https://doi.org/10.1016/j.artint.2020.103237">doi:10.1016/j.artint.2020.103237</a>, 2021.
</p>
<p>[Stier/Thrun, 2024] Stier, Q. and Thrun, M. C.: An efficient multicore CPU
implementation of the DatabionicSwarm, 18th conference of the International
Federation of Classification Societies (IFCS), San José, Costa Rica, July 14-19,
2024.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Lsun3D")
Data=Lsun3D$Data
Cls=Lsun3D$Cls
InputDistances=as.matrix(dist(Data))
#If not called separately setGridSize() is called in Pswarm
LC=setGridSize(InputDistances)
res=Pswarm(InputDistances,LC=LC,Cls=Cls,PlotIt=TRUE)


</code></pre>

<hr>
<h2 id='PswarmEpochsParallel'>Intern function, do not use yourself</h2><span id='topic+PswarmEpochsParallel'></span>

<h3>Description</h3>

<p>Finds the weak Nash equilibirium of the data bots for one epoch depending on a
radius, which requires the setting of constants, grid, and so on in, see
<code><a href="#topic+Pswarm">Pswarm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PswarmEpochsParallel(AllDataBotsPosRe, AllDataBotsPosIm, MyDistanceMatrix,
AllFreePosR0, GridRadii, GridAngle, JumpsPerRadius, NumJumps, NumAllDB, Lines,
Columns, Origin, Happiness, QuadOrHexa, RadiusVector, Rmin, Rmax, Cls, Debug,
pp, PlotIt = FALSE, Verbose = 1, Eps = 0.0001)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PswarmEpochsParallel_+3A_alldatabotsposre">AllDataBotsPosRe</code></td>
<td>
<p>Numeric vector [1:n] of the current positions for the databots on first of two dimensions.</p>
</td></tr>
<tr><td><code id="PswarmEpochsParallel_+3A_alldatabotsposim">AllDataBotsPosIm</code></td>
<td>
<p>Numeric vector [1:n] of the current positions for the databots on second of two dimensions.</p>
</td></tr>
<tr><td><code id="PswarmEpochsParallel_+3A_mydistancematrix">MyDistanceMatrix</code></td>
<td>
<p>Numeric vector with vectorized distance matrix of the datapoints in the original (high-dimensional) data space</p>
</td></tr>
<tr><td><code id="PswarmEpochsParallel_+3A_allfreeposr0">AllFreePosR0</code></td>
<td>
<p>NumericMatrix, see <code>AllallowedDBPosR0</code> in <code><a href="#topic+setPolarGrid">setPolarGrid</a></code></p>
</td></tr>
<tr><td><code id="PswarmEpochsParallel_+3A_gridradii">GridRadii</code></td>
<td>
<p>Numeric matrix with radius information of polar transformation for each grid position</p>
</td></tr>
<tr><td><code id="PswarmEpochsParallel_+3A_gridangle">GridAngle</code></td>
<td>
<p>Numeric matrix with angle information of polar transformation for each grid position</p>
</td></tr>
<tr><td><code id="PswarmEpochsParallel_+3A_jumpsperradius">JumpsPerRadius</code></td>
<td>
<p>Numeric Vector of possible positions of the 1st coordinate.</p>
</td></tr>
<tr><td><code id="PswarmEpochsParallel_+3A_numjumps">NumJumps</code></td>
<td>
<p>Integer number of jumps.</p>
</td></tr>
<tr><td><code id="PswarmEpochsParallel_+3A_numalldb">NumAllDB</code></td>
<td>
<p>Integer total number of databots</p>
</td></tr>
<tr><td><code id="PswarmEpochsParallel_+3A_lines">Lines</code></td>
<td>
<p>Integer stating the number of Lines the polar grid consists of.</p>
</td></tr>
<tr><td><code id="PswarmEpochsParallel_+3A_columns">Columns</code></td>
<td>
<p>Integer stating the number of columns the polar grid consists of.</p>
</td></tr>
<tr><td><code id="PswarmEpochsParallel_+3A_origin">Origin</code></td>
<td>
<p>Numeric origin of the positions of grid in two dimensions</p>
</td></tr>
<tr><td><code id="PswarmEpochsParallel_+3A_happiness">Happiness</code></td>
<td>
<p>Numeric value indicating the global happiness over all databots</p>
</td></tr>
<tr><td><code id="PswarmEpochsParallel_+3A_quadorhexa">QuadOrHexa</code></td>
<td>
<p>optional, bool: If TRUE prints status every 100 iterations</p>
</td></tr>
<tr><td><code id="PswarmEpochsParallel_+3A_radiusvector">RadiusVector</code></td>
<td>
<p>Numeric vector stating all moving radius in a descending order (cooling down scheme).</p>
</td></tr>
<tr><td><code id="PswarmEpochsParallel_+3A_rmin">Rmin</code></td>
<td>
<p>Integer stating minimum radius.</p>
</td></tr>
<tr><td><code id="PswarmEpochsParallel_+3A_rmax">Rmax</code></td>
<td>
<p>Integer stating maximum radius.</p>
</td></tr>
<tr><td><code id="PswarmEpochsParallel_+3A_cls">Cls</code></td>
<td>
<p>Integer vector stating the classification vector for each datapoints/databots.</p>
</td></tr>
<tr><td><code id="PswarmEpochsParallel_+3A_debug">Debug</code></td>
<td>
<p>optional, bool: If TRUE prints information for debugging.</p>
</td></tr>
<tr><td><code id="PswarmEpochsParallel_+3A_pp">pp</code></td>
<td>
<p>Numeric vector stating ratio of number of jumping simultaneously DataBots of one eppoch (per nash-equilibirum), this vector is linearly monotonically decreasing.</p>
</td></tr>
<tr><td><code id="PswarmEpochsParallel_+3A_plotit">PlotIt</code></td>
<td>
<p>optional, bool: If TRUE creates plot of projection after each epoch.</p>
</td></tr>
<tr><td><code id="PswarmEpochsParallel_+3A_verbose">Verbose</code></td>
<td>
<p>optional, integer stating degree of textual feedback. 0 = no output, 1 = basic notifications, 2 = progress bar, 3 = details.</p>
</td></tr>
<tr><td><code id="PswarmEpochsParallel_+3A_eps">Eps</code></td>
<td>
<p>optional, double: Stop criterion for convergence of each epoche.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Algorithm is described in [Thrun, 2018, p. 95, Listing 8.1].
</p>


<h3>Value</h3>

<p>list of
</p>
<table role = "presentation">
<tr><td><code>AllDataBotsPosRe</code></td>
<td>
<p>Numeric vector [1:n] of the current positions for the databots on first of two dimensions.</p>
</td></tr>
<tr><td><code>AllDataBotsPosIm</code></td>
<td>
<p>Numeric vector [1:n] of the current positions for the databots on second of two dimensions.</p>
</td></tr>
<tr><td><code>CourseOfHappiness</code></td>
<td>
<p>NumericVector, states the global happiness value per epoch.</p>
</td></tr>
<tr><td><code>RadiusPerEpoch</code></td>
<td>
<p>NumericVector, stating the radius used per epoch in order of computation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Quirin Stier
</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through
Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer,
Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018. 
</p>
<p>[Thrun/Ultsch, 2021]  Thrun, M. C., and Ultsch, A.: Swarm Intelligence for
Self-Organized Clustering, Artificial Intelligence, Vol. 290, pp. 103237,
<a href="https://doi.org/10.1016/j.artint.2020.103237">doi:10.1016/j.artint.2020.103237</a>, 2021.
</p>
<p>[Stier/Thrun, 2024] Stier, Q. and Thrun, M. C.: An efficient multicore CPU
implementation of the DatabionicSwarm, 18th conference of the International
Federation of Classification Societies (IFCS), San José, Costa Rica, July 14-19,
2024.
</p>

<hr>
<h2 id='PswarmEpochsSequential'>Intern function, do not use yourself</h2><span id='topic+PswarmEpochsSequential'></span>

<h3>Description</h3>

<p>Finds the weak Nash equilibirium of the data bots for one epoch depending on a
radius, which requires the setting of constants, grid, and so on in, see
<code><a href="#topic+Pswarm">Pswarm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PswarmEpochsSequential(AllDataBotsPos, MyDistanceMatrix, IndPossibleDBPosR,
AllFreePosR0, NumAllDB, Lines, Columns, Origin, Happiness, GridRadii, GridAngle,
QuadOrHexa, RadiusVector, Rmin, Rmax, Cls, Debug, pp, PlotIt = FALSE,
Verbose = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PswarmEpochsSequential_+3A_alldatabotspos">AllDataBotsPos</code></td>
<td>
<p>Complex vector [1:n] of the current positions for the databots on a 2d and real plane in complex numbers.</p>
</td></tr>
<tr><td><code id="PswarmEpochsSequential_+3A_mydistancematrix">MyDistanceMatrix</code></td>
<td>
<p>Numeric vector with vectorized distance matrix of the datapoints in the original (high-dimensional) data space</p>
</td></tr>
<tr><td><code id="PswarmEpochsSequential_+3A_indpossibledbposr">IndPossibleDBPosR</code></td>
<td>
<p>Numeric vector containing the possible positions around a databot dependent on the radius.</p>
</td></tr>
<tr><td><code id="PswarmEpochsSequential_+3A_allfreeposr0">AllFreePosR0</code></td>
<td>
<p>NumericMatrix, see <code>AllallowedDBPosR0</code> in <code><a href="#topic+setPolarGrid">setPolarGrid</a></code>.</p>
</td></tr>
<tr><td><code id="PswarmEpochsSequential_+3A_numalldb">NumAllDB</code></td>
<td>
<p>Integer total number of databots</p>
</td></tr>
<tr><td><code id="PswarmEpochsSequential_+3A_lines">Lines</code></td>
<td>
<p>Integer stating the number of Lines the polar grid consists of.</p>
</td></tr>
<tr><td><code id="PswarmEpochsSequential_+3A_columns">Columns</code></td>
<td>
<p>Integer stating the number of columns the polar grid consists of.</p>
</td></tr>
<tr><td><code id="PswarmEpochsSequential_+3A_origin">Origin</code></td>
<td>
<p>Numeric origin of the positions of grid in two dimensions</p>
</td></tr>
<tr><td><code id="PswarmEpochsSequential_+3A_happiness">Happiness</code></td>
<td>
<p>Numeric value indicating the global happiness over all databots</p>
</td></tr>
<tr><td><code id="PswarmEpochsSequential_+3A_gridradii">GridRadii</code></td>
<td>
<p>Numeric matrix with radius information of polar transformation for each grid position</p>
</td></tr>
<tr><td><code id="PswarmEpochsSequential_+3A_gridangle">GridAngle</code></td>
<td>
<p>Numeric matrix with angle information of polar transformation for each grid position</p>
</td></tr>
<tr><td><code id="PswarmEpochsSequential_+3A_quadorhexa">QuadOrHexa</code></td>
<td>
<p>optional, bool: If TRUE prints status every 100 iterations</p>
</td></tr>
<tr><td><code id="PswarmEpochsSequential_+3A_radiusvector">RadiusVector</code></td>
<td>
<p>Numeric vector stating all moving radius in a descending order (cooling down scheme).</p>
</td></tr>
<tr><td><code id="PswarmEpochsSequential_+3A_rmin">Rmin</code></td>
<td>
<p>Integer stating minimum radius.</p>
</td></tr>
<tr><td><code id="PswarmEpochsSequential_+3A_rmax">Rmax</code></td>
<td>
<p>Integer stating maximum radius.</p>
</td></tr>
<tr><td><code id="PswarmEpochsSequential_+3A_cls">Cls</code></td>
<td>
<p>Integer vector stating the classification vector for each datapoints/databots.</p>
</td></tr>
<tr><td><code id="PswarmEpochsSequential_+3A_debug">Debug</code></td>
<td>
<p>optional, bool: If TRUE prints information for debugging.</p>
</td></tr>
<tr><td><code id="PswarmEpochsSequential_+3A_pp">pp</code></td>
<td>
<p>Numeric vector stating ratio of number of jumping simultaneously DataBots of one eppoch (per nash-equilibirum), this vector is linearly monotonically decreasing.</p>
</td></tr>
<tr><td><code id="PswarmEpochsSequential_+3A_plotit">PlotIt</code></td>
<td>
<p>optional, bool: If TRUE creates plot of projection after each epoch.</p>
</td></tr>
<tr><td><code id="PswarmEpochsSequential_+3A_verbose">Verbose</code></td>
<td>
<p>optional, integer stating degree of textual feedback. 0 = no output, 1 = basic notifications, 2 = progress bar, 3 = details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Algorithm is described in [Thrun, 2018, p. 95, Listing 8.1].
</p>


<h3>Value</h3>

<p>list of
</p>
<table role = "presentation">
<tr><td><code>AllDataBotsPosRe</code></td>
<td>
<p>Numeric vector [1:n] of the current positions for the databots on first of two dimensions.</p>
</td></tr>
<tr><td><code>AllDataBotsPosIm</code></td>
<td>
<p>Numeric vector [1:n] of the current positions for the databots on second of two dimensions.</p>
</td></tr>
<tr><td><code>CourseOfHappiness</code></td>
<td>
<p>NumericVector, states the global happiness value per epoch.</p>
</td></tr>
<tr><td><code>RadiusPerEpoch</code></td>
<td>
<p>NumericVector, stating the radius used per epoch in order of computation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Quirin Stier
</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer, Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018. 
</p>

<hr>
<h2 id='PswarmRadiusParallel'>Intern function, do not use yourself</h2><span id='topic+PswarmRadiusParallel'></span>

<h3>Description</h3>

<p>Finds the weak Nash equilibirium of the data bots for one epoch depending on a
radius, which requires the setting of constants, grid, and so on in, see
<code><a href="#topic+Pswarm">Pswarm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PswarmRadiusParallel(DataBotsPos, DataDists, AllallowedDBPosR0, IndPossibleDBPosRe,
IndPossibleDBPosIm, Lines, Columns, Radius, NumAllDB, NumChoDB, NumFreeShape1,
NumJumps, Origin1, Origin2, Happiness, MinIterations, HappinessInclination, Eps, debug)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PswarmRadiusParallel_+3A_databotspos">DataBotsPos</code></td>
<td>
<p>Numeric vector [1:NumJumps*n*2] containing the current
positions and all positions for considered/possible jumps which can be
computed (depending on number of jumps parameter NumJumps) for the databots
on two dimensions.</p>
</td></tr>
<tr><td><code id="PswarmRadiusParallel_+3A_datadists">DataDists</code></td>
<td>
<p>Numeric vector with vectorized distance matrix of the datapoints in the original (high-dimensional) data space</p>
</td></tr>
<tr><td><code id="PswarmRadiusParallel_+3A_allalloweddbposr0">AllallowedDBPosR0</code></td>
<td>
<p>NumericMatrix, see <code>AllallowedDBPosR0</code> in <code><a href="#topic+setPolarGrid">setPolarGrid</a></code></p>
</td></tr>
<tr><td><code id="PswarmRadiusParallel_+3A_indpossibledbposre">IndPossibleDBPosRe</code></td>
<td>
<p>Numeric Vector of possible positions of the 1st coordinate.</p>
</td></tr>
<tr><td><code id="PswarmRadiusParallel_+3A_indpossibledbposim">IndPossibleDBPosIm</code></td>
<td>
<p>Numeric Vector of possible positions of the 2nd coordinate.</p>
</td></tr>
<tr><td><code id="PswarmRadiusParallel_+3A_lines">Lines</code></td>
<td>
<p>Integer stating the number of Lines the polar grid consists of.</p>
</td></tr>
<tr><td><code id="PswarmRadiusParallel_+3A_columns">Columns</code></td>
<td>
<p>Integer stating the number of columns the polar grid consists of.</p>
</td></tr>
<tr><td><code id="PswarmRadiusParallel_+3A_radius">Radius</code></td>
<td>
<p>Numeric (Integer) stating the moving radius of the databots</p>
</td></tr>
<tr><td><code id="PswarmRadiusParallel_+3A_numalldb">NumAllDB</code></td>
<td>
<p>Integer total number of databots</p>
</td></tr>
<tr><td><code id="PswarmRadiusParallel_+3A_numchodb">NumChoDB</code></td>
<td>
<p>Integer number of databots chosen for moving/jumps.</p>
</td></tr>
<tr><td><code id="PswarmRadiusParallel_+3A_numfreeshape1">NumFreeShape1</code></td>
<td>
<p>Integer stating the first dimension of the numeric matrix book keeping the possible position grid</p>
</td></tr>
<tr><td><code id="PswarmRadiusParallel_+3A_numjumps">NumJumps</code></td>
<td>
<p>Integer number of jumps</p>
</td></tr>
<tr><td><code id="PswarmRadiusParallel_+3A_origin1">Origin1</code></td>
<td>
<p>Numeric origin coordinate 1</p>
</td></tr>
<tr><td><code id="PswarmRadiusParallel_+3A_origin2">Origin2</code></td>
<td>
<p>Numeric origin coordinate 2</p>
</td></tr>
<tr><td><code id="PswarmRadiusParallel_+3A_happiness">Happiness</code></td>
<td>
<p>Numeric value indicating the global happiness over all databots</p>
</td></tr>
<tr><td><code id="PswarmRadiusParallel_+3A_miniterations">MinIterations</code></td>
<td>
<p>asdf</p>
</td></tr>
<tr><td><code id="PswarmRadiusParallel_+3A_happinessinclination">HappinessInclination</code></td>
<td>
<p>asdf</p>
</td></tr>
<tr><td><code id="PswarmRadiusParallel_+3A_eps">Eps</code></td>
<td>
<p>optional, double: Stop criterion for convergence of each epoche.</p>
</td></tr>
<tr><td><code id="PswarmRadiusParallel_+3A_debug">debug</code></td>
<td>
<p>optional, bool: If TRUE prints status every 100 iterations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Algorithm is described in [Thrun, 2018, p. 95, Listing 8.1].
</p>


<h3>Value</h3>

<p>list of
</p>
<table role = "presentation">
<tr><td><code>AllDataBotsPos</code></td>
<td>
<p>ComplexVector, indizes of DataBot Positions after a weak Nash equlibrium is found</p>
</td></tr>
<tr><td><code>stressverlauf</code></td>
<td>
<p>NumericVector, intern result, for debugging only</p>
</td></tr>
<tr><td><code>fokussiertlaufind</code></td>
<td>
<p>NumericVector, intern result, for debugging only</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Quirin Stier
</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through
Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer,
Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018.
</p>
<p>[Thrun/Ultsch, 2021]  Thrun, M. C., and Ultsch, A.: Swarm Intelligence for
Self-Organized Clustering, Artificial Intelligence, Vol. 290, pp. 103237,
<a href="https://doi.org/10.1016/j.artint.2020.103237">doi:10.1016/j.artint.2020.103237</a>, 2021.
</p>
<p>[Stier/Thrun, 2024] Stier, Q. and Thrun, M. C.: An efficient multicore CPU
implementation of the DatabionicSwarm, 18th conference of the International
Federation of Classification Societies (IFCS), San José, Costa Rica, July 14-19,
2024.
</p>

<hr>
<h2 id='PswarmRadiusSequential'>intern function, do not use yourself</h2><span id='topic+PswarmRadiusSequential'></span>

<h3>Description</h3>

<p>Finds the weak Nash equilibirium for DataBots in one epoch(Radius), requires the setting of constants, grid, and so on in <code><a href="#topic+Pswarm">Pswarm</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PswarmRadiusSequential( AllDataBotsPosOld, Radius, DataDists,
IndPossibleDBPosR, RadiusPositionsschablone, pp, Nullpunkt, Lines, Columns,
nBots, limit, steigungsverlaufind, Happiness, debug)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PswarmRadiusSequential_+3A_alldatabotsposold">AllDataBotsPosOld</code></td>
<td>
<p>ComplexVector [1:n,1], DataBots position in the last Nash-Equlibriuum</p>
</td></tr>
<tr><td><code id="PswarmRadiusSequential_+3A_radius">Radius</code></td>
<td>
<p>double, Radius of payoff function, neighborhood, where other DatsBots can be smelled</p>
</td></tr>
<tr><td><code id="PswarmRadiusSequential_+3A_datadists">DataDists</code></td>
<td>
<p>NumericMatrix, Inputdistances[1:n,1:n]</p>
</td></tr>
<tr><td><code id="PswarmRadiusSequential_+3A_indpossibledbposr">IndPossibleDBPosR</code></td>
<td>
<p>ComplexVector, see output of <code><a href="#topic+findPossiblePositionsCsingle">findPossiblePositionsCsingle</a></code></p>
</td></tr>
<tr><td><code id="PswarmRadiusSequential_+3A_radiuspositionsschablone">RadiusPositionsschablone</code></td>
<td>
<p>NumericMatrix, see <code>AllallowedDBPosR0</code> in <code><a href="#topic+setPolarGrid">setPolarGrid</a></code></p>
</td></tr>
<tr><td><code id="PswarmRadiusSequential_+3A_pp">pp</code></td>
<td>
<p>NumericVector, number of jumping simultaneously DataBots of one eppoch (per nash-equilibirum), this vector is linearly monotonically decreasing</p>
</td></tr>
<tr><td><code id="PswarmRadiusSequential_+3A_nullpunkt">Nullpunkt</code></td>
<td>
<p>NumericVector, equals <code>which(AllallowedDBPosR0==0,arr.ind=T)</code>, see see <code>AllallowedDBPosR0</code> in <code><a href="#topic+setPolarGrid">setPolarGrid</a></code></p>
</td></tr>
<tr><td><code id="PswarmRadiusSequential_+3A_lines">Lines</code></td>
<td>
<p>double, small edge length of rectangulare grid</p>
</td></tr>
<tr><td><code id="PswarmRadiusSequential_+3A_columns">Columns</code></td>
<td>
<p>double, big edge length of rectangulare grid</p>
</td></tr>
<tr><td><code id="PswarmRadiusSequential_+3A_nbots">nBots</code></td>
<td>
<p>double, intern constant, equals <code>round(pp[Radius]*DBAnzahl)</code></p>
</td></tr>
<tr><td><code id="PswarmRadiusSequential_+3A_limit">limit</code></td>
<td>
<p>int, intern constant, equals <code>ceiling(1/pp[Radius])</code></p>
</td></tr>
<tr><td><code id="PswarmRadiusSequential_+3A_steigungsverlaufind">steigungsverlaufind</code></td>
<td>
<p>int, intern constant</p>
</td></tr>
<tr><td><code id="PswarmRadiusSequential_+3A_happiness">Happiness</code></td>
<td>
<p>double, intern constant, sum of payoff of all databots in random condition before the algorithm starts</p>
</td></tr>
<tr><td><code id="PswarmRadiusSequential_+3A_debug">debug</code></td>
<td>
<p>optional, bool: If TRUE prints status every 100 iterations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Algorithm is described in [Thrun, 2018, p. 95, Listing 8.1].
</p>


<h3>Value</h3>

<p>list of
</p>
<table role = "presentation">
<tr><td><code>AllDataBotsPos</code></td>
<td>
<p>ComplexVector, indizes of DataBot Positions after a weak Nash equlibrium is found</p>
</td></tr>
<tr><td><code>stressverlauf</code></td>
<td>
<p>NumericVector, intern result, for debugging only</p>
</td></tr>
<tr><td><code>fokussiertlaufind</code></td>
<td>
<p>NumericVector, intern result, for debugging only</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer, Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018. 
</p>

<hr>
<h2 id='rDistanceToroidCsingle'>
Intern function for <code><a href="#topic+Pswarm">Pswarm</a></code>
</h2><span id='topic+rDistanceToroidCsingle'></span>

<h3>Description</h3>

<p>toroid distance calculation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rDistanceToroidCsingle( AllDataBotsPosX, 
 AllDataBotsPosY, AllallowedDBPosR0,
 Lines, Columns,  Nullpunkt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rDistanceToroidCsingle_+3A_alldatabotsposx">AllDataBotsPosX</code></td>
<td>
<p>NumericVector [1:n,1], positions of on grid</p>
</td></tr>
<tr><td><code id="rDistanceToroidCsingle_+3A_alldatabotsposy">AllDataBotsPosY</code></td>
<td>
<p>NumericVector [1:n,1], positions of on grid</p>
</td></tr>
<tr><td><code id="rDistanceToroidCsingle_+3A_allalloweddbposr0">AllallowedDBPosR0</code></td>
<td>
<p>NumericMatrix</p>
</td></tr>
<tr><td><code id="rDistanceToroidCsingle_+3A_lines">Lines</code></td>
<td>
<p>double</p>
</td></tr>
<tr><td><code id="rDistanceToroidCsingle_+3A_columns">Columns</code></td>
<td>
<p>double</p>
</td></tr>
<tr><td><code id="rDistanceToroidCsingle_+3A_nullpunkt">Nullpunkt</code></td>
<td>
<p>NumericVector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Part of the algorithm described in [Thrun, 2018, p. 95, Listing 8.1].
</p>


<h3>Value</h3>

<p>numeric matrix of toroid Distances[1:n,1:n]
</p>


<h3>Note</h3>

<p>do not use yourself</p>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer, Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Pswarm">Pswarm</a></code>
</p>

<hr>
<h2 id='RelativeDifference'>
Relative Difference
</h2><span id='topic+RelativeDifference'></span>

<h3>Description</h3>

<p>Calculates the difference between positive x and y values 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RelativeDifference(X, Y, epsilon = 10^-10,na.rm=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RelativeDifference_+3A_x">X</code></td>
<td>
<p>either a value or numerical vector of [1:n]</p>
</td></tr>
<tr><td><code id="RelativeDifference_+3A_y">Y</code></td>
<td>
<p>either a value or numerical vector of [1:n]</p>
</td></tr>
<tr><td><code id="RelativeDifference_+3A_epsilon">epsilon</code></td>
<td>
<p>Optional, If both x and y are approximatly zero the output is
also zero</p>
</td></tr>
<tr><td><code id="RelativeDifference_+3A_na.rm">na.rm</code></td>
<td>
<p>Optional, function does not work with non finite values. If these
cases should be automatically removed, set parameter TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Contrary to other approaches in this cases the range of values lies between
[-2,2]. The approach is only valid for positive values of<code>X</code> and <code>Y</code>.
The realtive difference <code>R</code> is defined with </p>
<p style="text-align: center;"><code class="reqn">R=\frac{Y-X}{0.5*(X+Y)}</code>
</p>

<p>Negative value indicate that <code>X</code>  is higher than <code>Y</code> and positive
values that <code>X</code> is lower than <code>Y</code>.
</p>


<h3>Value</h3>

<p>R</p>


<h3>Note</h3>

<p>It can be combined with the <code>GabrielClassificationError</code> if a clear baseline is defined.
</p>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>Ultsch, A.: Is Log Ratio a Good Value for Measuring Return in Stock Investments?
GfKl 2008, pp, 505-511, 2008.
</p>


<h3>See Also</h3>

<p><code><a href="DRquality.html#topic+GabrielClassificationError">GabrielClassificationError</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=c(1:5)
y=runif(5,min=1,max=10)
RelativeDifference(x,y)
</code></pre>

<hr>
<h2 id='RobustNorm_BackTrafo'>
Transforms the Robust Normalization back
</h2><span id='topic+RobustNorm_BackTrafo'></span>

<h3>Description</h3>

<p>Transforms the Robust Normalization back if <code>Capped=FALSE</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RobustNorm_BackTrafo(TransformedData,

MinX,Denom,Center=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RobustNorm_BackTrafo_+3A_transformeddata">TransformedData</code></td>
<td>
<p>[1:n,1:d]  matrix</p>
</td></tr>
<tr><td><code id="RobustNorm_BackTrafo_+3A_minx">MinX</code></td>
<td>
<p>scalar</p>
</td></tr>
<tr><td><code id="RobustNorm_BackTrafo_+3A_denom">Denom</code></td>
<td>
<p>scalar</p>
</td></tr>
<tr><td><code id="RobustNorm_BackTrafo_+3A_center">Center</code></td>
<td>
<p>scalar</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details see <code><a href="#topic+RobustNormalization">RobustNormalization</a></code>
</p>


<h3>Value</h3>

<p>[1:n,1:d]  Data matrix
</p>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RobustNormalization">RobustNormalization</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Hepta)
Data = Hepta$Data
TransList = RobustNormalization(Data, Centered = TRUE, WithBackTransformation = TRUE)

HeptaData = RobustNorm_BackTrafo(TransList$TransformedData,
                                 TransList$MinX,
                                 TransList$Denom,
                                 TransList$Center)

sum(HeptaData - Data) #&lt;e-15
</code></pre>

<hr>
<h2 id='RobustNormalization'>
RobustNormalization
</h2><span id='topic+RobustNormalization'></span>

<h3>Description</h3>

<p>RobustNormalization as described in [Milligan/Cooper, 1988].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RobustNormalization(Data,Centered=FALSE,Capped=FALSE,

na.rm=TRUE,WithBackTransformation=FALSE,

pmin=0.01,pmax=0.99) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RobustNormalization_+3A_data">Data</code></td>
<td>
<p>[1:n,1:d] data matrix of n cases and d features
</p>
</td></tr>
<tr><td><code id="RobustNormalization_+3A_centered">Centered</code></td>
<td>
<p> centered data around zero by median if TRUE
</p>
</td></tr>
<tr><td><code id="RobustNormalization_+3A_capped">Capped</code></td>
<td>
<p>TRUE: outliers are capped above 1 or below -1 and set to 1 or -1.
</p>
</td></tr>
<tr><td><code id="RobustNormalization_+3A_na.rm">na.rm</code></td>
<td>
<p>If TRUE, infinite vlaues are disregarded
</p>
</td></tr>
<tr><td><code id="RobustNormalization_+3A_withbacktransformation">WithBackTransformation</code></td>
<td>

<p>If in the case for forecasting with neural networks a backtransformation is required, this parameter can be set to 'TRUE'.
</p>
</td></tr>
<tr><td><code id="RobustNormalization_+3A_pmin">pmin</code></td>
<td>
<p>defines outliers on the lower end of scale</p>
</td></tr>
<tr><td><code id="RobustNormalization_+3A_pmax">pmax</code></td>
<td>
<p>defines outliers on the higher end of scale</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Normalizes features either between -1 to 1 (Centered=TRUE) or 0-1 (Centered=TRUE) without changing the distribution of a feature itself. For a more precise description please read [Thrun, 2018, p.17].
</p>
<p>&quot;[The] scaling of the inputs determines the effective scaling of the weights in the last layer of a MLP with BP neural netowrk, it can have a large effect on the quality of the final solution. At the outset it is besto to standardize all inputs to have mean zero and standard deviation 1 [(or at least the range under 1)]. This ensures all inputs are treated equally in the regularization prozess, and allows to choose a meaningful range for the random starting weights.&quot;[Friedman et al., 2012]
</p>


<h3>Value</h3>

<p>if <code>WithBackTransformation=FALSE</code>: TransformedData[1:n,1:d] i.e., normalized data matrix of n cases and d features
</p>
<p>if <code>WithBackTransformation=TRUE</code>: List with
</p>
<table role = "presentation">
<tr><td><code>TransformedData</code></td>
<td>
<p>[1:n,1:d]  normalized data matrix of n cases and d features</p>
</td></tr>
<tr><td><code>MinX</code></td>
<td>
<p>[1:d] numerical vector used for manual back-transformation of each feature</p>
</td></tr>
<tr><td><code>MaxX</code></td>
<td>
<p>[1:d] numerical vector used for manual back-transformation of each feature</p>
</td></tr>
<tr><td><code>Denom</code></td>
<td>
<p>[1:d] numerical vector used for manual back-transformation of each feature</p>
</td></tr>
<tr><td><code>Center</code></td>
<td>
<p>[1:d] numerical vector used for manual back-transformation of each feature</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>[Milligan/Cooper, 1988]  Milligan, G. W., &amp; Cooper, M. C.: A study of standardization of variables in cluster analysis, Journal of Classification, Vol. 5(2), pp. 181-204. 1988.
</p>
<p>[Friedman et al., 2012]  Friedman, J., Hastie, T., &amp; Tibshirani, R.: The Elements of Statistical Learning, (Second ed. Vol. 1), Springer series in statistics New York, NY, USA:, ISBN, 2012.
</p>
<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer, Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RobustNorm_BackTrafo">RobustNorm_BackTrafo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Scaled = RobustNormalization(rnorm(1000, 2, 100), Capped = TRUE)
hist(Scaled)

m = cbind(c(1, 2, 3), c(2, 6, 4))
List = RobustNormalization(m, FALSE, FALSE, FALSE, TRUE)
TransformedData = List$TransformedData

mback = RobustNorm_BackTrafo(TransformedData, List$MinX, List$Denom, List$Center)

sum(m - mback)
</code></pre>

<hr>
<h2 id='sESOM4BMUs'>
Intern function: Simplified Emergent Self-Organizing Map
</h2><span id='topic+sESOM4BMUs'></span>

<h3>Description</h3>

<p>Intern function for the simplified ESOM (sESOM) algorithm for fixed
BestMatchingUnits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sESOM4BMUs(BMUs,Data, esom, toroid, CurrentRadius, ComputeInR=FALSE,
Parallel=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sESOM4BMUs_+3A_bmus">BMUs</code></td>
<td>
<p>[1:Lines,1:Columns], BestMAtchingUnits generated by
ProjectedPoints2Grid()</p>
</td></tr>
<tr><td><code id="sESOM4BMUs_+3A_data">Data</code></td>
<td>
<p>[1:n,1:d] array of data: n cases in rows, d variables in columns</p>
</td></tr>
<tr><td><code id="sESOM4BMUs_+3A_esom">esom</code></td>
<td>
<p>[1:Lines,1:Columns,1:weights] array of NeuronWeights, see
ListAsEsomNeurons()</p>
</td></tr>
<tr><td><code id="sESOM4BMUs_+3A_toroid">toroid</code></td>
<td>
<p>TRUE/FALSE - topology of points</p>
</td></tr>
<tr><td><code id="sESOM4BMUs_+3A_currentradius">CurrentRadius</code></td>
<td>
<p>number betweeen 1 to x</p>
</td></tr>
<tr><td><code id="sESOM4BMUs_+3A_computeinr">ComputeInR</code></td>
<td>
<p>=T: Rcode, =F Cpp Code.</p>
</td></tr>
<tr><td><code id="sESOM4BMUs_+3A_parallel">Parallel</code></td>
<td>
<p>Optional, =TRUE: Parallel C++ implementation, =FALSE C++ implementation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Algorithm is described in [Thrun, 2018, p. 48, Listing 5.1].
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>esom</code></td>
<td>
<p>numeric array [1:Lines,1:Columns,1:d], d is the dimension of the
weights, the same as in the ESOM algorithm. modified esomneuros regarding a
predefined neighborhood defined by a radius</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Usually not for seperated usage!</p>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through
Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer,
Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeneratePswarmVisualization">GeneratePswarmVisualization</a></code>
</p>

<hr>
<h2 id='setdiffMatrix'>setdiffMatrix shortens Matrix2Curt by those rows that are in both
matrices.</h2><span id='topic+setdiffMatrix'></span>

<h3>Description</h3>

<p>setdiffMatrix shortens Matrix2Curt by those rows that are in both matrices.</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setdiffMatrix_+3A_matrix2curt">Matrix2Curt</code></td>
<td>
<p>[n,k] matrix, which will be shortened by x rows</p>
</td></tr>
<tr><td><code id="setdiffMatrix_+3A_matrix2compare">Matrix2compare</code></td>
<td>
<p>[m,k] matrix whose rows will be compared to those of
Matrix2Curt x rows in Matrix2compare equal rows of Matrix2Curt (order of rows is
irrelevant). Has the same number of columns as Matrix2Curt.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>V$CurtedMatrix[n-x,k] Shortened Matrix2Curt</p>


<h3>Author(s)</h3>

<p>CL,MT 12/2014</p>

<hr>
<h2 id='setGridSize'>
Sets the grid size for the Pswarm algorithm
</h2><span id='topic+setGridSize'></span>

<h3>Description</h3>

<p>Automatically sets the size of the grid, formula see [Thrun, 2018, p. 93-94].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setGridSize(InputDistances,minp=0.01,maxp=0.99,alpha=4, Verbose = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setGridSize_+3A_inputdistances">InputDistances</code></td>
<td>
<p> [1:n,1:n] symmetric matrix of input distances</p>
</td></tr>
<tr><td><code id="setGridSize_+3A_minp">minp</code></td>
<td>
<p>default value: 0.01,see <code><a href="stats.html#topic+quantile">quantile</a></code>, first value in the vector of <code>probs</code> estimates robust minimum of distances</p>
</td></tr>
<tr><td><code id="setGridSize_+3A_maxp">maxp</code></td>
<td>
<p>default value: 0.99, see <code><a href="stats.html#topic+quantile">quantile</a></code>, last value of the vector of <code>probs</code> estimates robust maximum of distances</p>
</td></tr>
<tr><td><code id="setGridSize_+3A_alpha">alpha</code></td>
<td>

<p>Do not change! Intern parameter, Only if Java Version of Pswarm instead of C++ version is used.
</p>
</td></tr>
<tr><td><code id="setGridSize_+3A_verbose">Verbose</code></td>
<td>

<p>optional, integer stating degree of textual feedback. 0 = no output, 1 = basic
notifications, 2 = progress bar, 3 = details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>grid is set such that minimum and maximum distances can be shown on the grid</p>


<h3>Value</h3>

<p>LC=c(Lines, Columns) size of the grid for <code>Pswarm</code>
</p>


<h3>Author(s)</h3>

<p>Michael Thrun, Florian Lerch
</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer, Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018. 
</p>


<h3>See Also</h3>

<p>automatic choice of LC for <code><a href="#topic+Pswarm">Pswarm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Lsun3D")
Data=Lsun3D$Data
Cls=Lsun3D$Cls
InputDistances=as.matrix(dist(Data))
#If not called separately setGridSize() is called in Pswarm
LC=setGridSize(InputDistances)
</code></pre>

<hr>
<h2 id='setPolarGrid'>
Intern function: Sets the polar grid
</h2><span id='topic+setPolarGrid'></span>

<h3>Description</h3>

<p>Sets a polar grid for a swarm in an rectangular shape
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setPolarGrid(Lines,Columns,QuadOrHexa,PlotIt,global)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setPolarGrid_+3A_lines">Lines</code></td>
<td>
<p>Integer, hast to be able to be divided by 2</p>
</td></tr>
<tr><td><code id="setPolarGrid_+3A_columns">Columns</code></td>
<td>
<p>Integer, with Columns&gt;=Lines</p>
</td></tr>
<tr><td><code id="setPolarGrid_+3A_quadorhexa">QuadOrHexa</code></td>
<td>
<p>bool, default(TRUE) If False Hexagonal grid, default quad grid</p>
</td></tr>
<tr><td><code id="setPolarGrid_+3A_plotit">PlotIt</code></td>
<td>
<p>bool, default(FALSE)</p>
</td></tr>
<tr><td><code id="setPolarGrid_+3A_global">global</code></td>
<td>
<p>bool,  default(TRUE), intern parameter, how shall the radii be calculated?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Part of the Algorithm described in [Thrun, 2018, p. 95, Listing 8.1].
</p>


<h3>Value</h3>

<p>list of 
</p>
<table role = "presentation">
<tr><td><code>GridRadii</code></td>
<td>
<p>matrix [1:Lines,1:Columns], Radii Matrix of all possible Positions of DataBots in Grid</p>
</td></tr>
<tr><td><code>GridAngle</code></td>
<td>
<p>matrix [1:Lines,1:Columns], Angle Matrix of all possible Positions of DataBots in Grid</p>
</td></tr>
<tr><td><code>AllallowedDBPosR0</code></td>
<td>
<p>matrix [1:Lines+1,1:Columns+1],  Matrix of radii in polar coordinates respecting origin (0,0) of all allowed DataBots Positions in one jump</p>
</td></tr>
<tr><td><code>AllallowedDBPosPhi0</code></td>
<td>
<p>matrix [1:Lines+1,1:Columns+1], 
# V$AllallowedDBPosPhi0[Lines+1,Lines+1]        Matrix of angle in polar coordinates respecting origin (0,0) of all allowed DataBots Positions in one jump</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer, Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Pswarm">Pswarm</a></code>
</p>

<hr>
<h2 id='setRmin'>Intern function: Estimates the minimal radius for the Databot scent</h2><span id='topic+setRmin'></span>

<h3>Description</h3>

<p>estimates the minimal radius on apolar grid in the automated annealing process of Pswarm, details of how can be read in [Thrun, 2018, p. 97]</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setRmin_+3A_lines">Lines</code></td>
<td>
<p>x-value determining the size of the map, i.e. how many open places for DataBots will be available  on the 2-dimensional grid BEWARE: has to be able to be divided by 2</p>
</td></tr>
<tr><td><code id="setRmin_+3A_columns">Columns</code></td>
<td>
<p>y-value  determining the size of the map, i.e. how many open places for DataBots will be available on the 2-dimensional grid Columns&gt;Lines</p>
</td></tr>
<tr><td><code id="setRmin_+3A_allalloweddbposr0">AllallowedDBPosR0</code></td>
<td>
<p>[1:Lines+1,1:Lines+1]Matrix of radii in polar coordinates respecting origin (0,0) of all allowed DataBots Positions in one jump</p>
</td></tr>
<tr><td><code id="setRmin_+3A_p">p</code></td>
<td>
<p>percent of gitterpositions, which should be considered</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Rmin Minimum Radius</p>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer, Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018. 
</p>

<hr>
<h2 id='ShortestGraphPathsC'>
Shortest GraphPaths = geodesic distances
</h2><span id='topic+ShortestGraphPathsC'></span>

<h3>Description</h3>

<p>Dijkstra's SSSP (Single source shortest path) algorithm, from all points to all points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ShortestGraphPathsC(Adj, Cost)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ShortestGraphPathsC_+3A_adj">Adj</code></td>
<td>

<p>[1:n,1:n]         0/1 adjascency matrix, e.g. from delaunay graph or gabriel graph
</p>
</td></tr>
<tr><td><code id="ShortestGraphPathsC_+3A_cost">Cost</code></td>
<td>

<p>[1:n,1:n]       matrix, distances between n points (normally euclidean)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vertices are the points, edges have the costs defined by weights (normally a distance).
The algorithm runs in runs in O(n*E*Log(V)), see also [Jungnickel, 2013, p. 87]. Further details can be foubd in 
[Jungnickel, 2013, p. 83-87] and [Thrun, 2018, p. 12].
</p>


<h3>Value</h3>

<p>ShortestPaths[1:n,1:n]   
vector, shortest paths (geodesic) to all other vertices including the source vertice itself
from al vertices to all vertices, stored as a matrix
</p>


<h3>Note</h3>

<p>require C++11 standard (set flag in Compiler, if not set automatically)
</p>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>[Dijkstra,1959]	Dijkstra, E. W.: A note on two problems in connexion with graphs, Numerische mathematik, Vol. 1(1), pp. 269-271. 1959.
</p>
<p>[Jungnickel, 2013]	Jungnickel, D.: Graphs, networks and algorithms, (4th ed ed. Vol. 5), Berlin, Heidelberg, Germany, Springer, ISBN: 978-3-642-32278-5, 2013.
</p>
<p>[Thrun/Ultsch, 2017]	Thrun, M.C., Ultsch, A.: Projection based Clustering, Conf. Int. Federation of Classification Societies (IFCS),DOI:10.13140/RG.2.2.13124.53124, Tokyo, 2017.
</p>
<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer, Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DijkstraSSSP">DijkstraSSSP</a></code>
</p>

<hr>
<h2 id='trainstepC'>
internal function for s-esom
</h2><span id='topic+trainstepC'></span>

<h3>Description</h3>

<p>Does the training for fixed bestmatches in one epoch of the sESOM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trainstepC(vx,vy, DataSampled,BMUsampled,Lines,Columns, Radius, toroid, NoCases)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trainstepC_+3A_vx">vx</code></td>
<td>
<p>array [1:Lines,1:Columns,1:Weights], WeightVectors that will be trained, internally transformed von NumericVector to cube</p>
</td></tr>
<tr><td><code id="trainstepC_+3A_vy">vy</code></td>
<td>
<p>array [1:Lines,1:Columns,1:2], meshgrid for output distance computation</p>
</td></tr>
<tr><td><code id="trainstepC_+3A_datasampled">DataSampled</code></td>
<td>
<p>NumericMatrix, n cases shuffled Dataset[1:n,1:d] by <code>sample</code> </p>
</td></tr>
<tr><td><code id="trainstepC_+3A_bmusampled">BMUsampled</code></td>
<td>
<p>NumericMatrix, n cases shuffled BestMatches[1:n,1:2] by <code>sample</code> in the same way as <code>DataSampled</code> </p>
</td></tr>
<tr><td><code id="trainstepC_+3A_lines">Lines</code></td>
<td>
<p>double, Height of the grid</p>
</td></tr>
<tr><td><code id="trainstepC_+3A_columns">Columns</code></td>
<td>
<p>double, Width of the grid</p>
</td></tr>
<tr><td><code id="trainstepC_+3A_radius">Radius</code></td>
<td>
<p>double, The current Radius that should be used to define neighbours to the bm</p>
</td></tr>
<tr><td><code id="trainstepC_+3A_toroid">toroid</code></td>
<td>
<p>bool, Should the grid be considered with cyclically connected borders?</p>
</td></tr>
<tr><td><code id="trainstepC_+3A_nocases">NoCases</code></td>
<td>
<p>int, number of samples in the given non-sampled dataset</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Algorithm is described in [Thrun, 2018, p. 48, Listing 5.1].
</p>


<h3>Value</h3>

<p>WeightVectors, array[1:Lines,1:Columns,1:weights] with the adjusted Weights</p>


<h3>Note</h3>

<p>Usually not for seperated usage!</p>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer, Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018. 
</p>

<hr>
<h2 id='trainstepC2'>
internal function for s-esom
</h2><span id='topic+trainstepC2'></span>

<h3>Description</h3>

<p>Does the training for fixed bestmatches in one epoch of the sESOM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trainstepC2(esomwts,aux, DataSampled,BMUsampled,Lines,Columns, Weights, Radius,
toroid, NoCases)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trainstepC2_+3A_esomwts">esomwts</code></td>
<td>
<p>array [1:Lines,1:Columns,1:Weights], WeightVectors that will be trained, internally transformed von NumericVector to cube</p>
</td></tr>
<tr><td><code id="trainstepC2_+3A_aux">aux</code></td>
<td>
<p>array [1:Lines,1:Columns,1:2], meshgrid for output distance computation</p>
</td></tr>
<tr><td><code id="trainstepC2_+3A_datasampled">DataSampled</code></td>
<td>
<p>NumericMatrix, n cases shuffled Dataset[1:n,1:d] by <code>sample</code> </p>
</td></tr>
<tr><td><code id="trainstepC2_+3A_bmusampled">BMUsampled</code></td>
<td>
<p>NumericMatrix, n cases shuffled BestMatches[1:n,1:2] by <code>sample</code> in the same way as <code>DataSampled</code> </p>
</td></tr>
<tr><td><code id="trainstepC2_+3A_lines">Lines</code></td>
<td>
<p>double, Height of the grid</p>
</td></tr>
<tr><td><code id="trainstepC2_+3A_columns">Columns</code></td>
<td>
<p>double, Width of the grid</p>
</td></tr>
<tr><td><code id="trainstepC2_+3A_weights">Weights</code></td>
<td>
<p>double, number of weights</p>
</td></tr>
<tr><td><code id="trainstepC2_+3A_radius">Radius</code></td>
<td>
<p>double, The current Radius that should be used to define neighbours to the bm</p>
</td></tr>
<tr><td><code id="trainstepC2_+3A_toroid">toroid</code></td>
<td>
<p>bool, Should the grid be considered with cyclically connected borders?</p>
</td></tr>
<tr><td><code id="trainstepC2_+3A_nocases">NoCases</code></td>
<td>
<p>int, number of samples in the given non-sampled dataset</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Algorithm is described in [Thrun, 2018, p. 48, Listing 5.1].
</p>


<h3>Value</h3>

<p>WeightVectors, array[1:Lines,1:Columns,1:weights] with the adjusted Weights</p>


<h3>Note</h3>

<p>Usually not for seperated usage!</p>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer, Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018. 
</p>

<hr>
<h2 id='UniquePoints'>
Unique Points
</h2><span id='topic+UniquePoints'></span>

<h3>Description</h3>

<p>return only the unique points in Datapoints
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UniquePoints(Datapoints, Eps=1e-10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="UniquePoints_+3A_datapoints">Datapoints</code></td>
<td>

<p>[1:n,1:d] matrix of Datapoints points of dimension d, the points are in the  rows
</p>
</td></tr>
<tr><td><code id="UniquePoints_+3A_eps">Eps</code></td>
<td>

<p>Optional,scalar above zero that defines minimum non-identical euclidean distance between two points
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Euclidean distance is computed and used within. Setting <code>Eps</code> to a very small number results in the identification of unique data points. Setting epsilon to a higher number results in the definition of mesh points within an d-dimensional R-ball graph.
</p>


<h3>Value</h3>

<p>List with
</p>
<table role = "presentation">
<tr><td><code>Unique</code></td>
<td>
<p>[1:k,1:d] Datapoints points  without duplicate points</p>
</td></tr>
<tr><td><code>IsDuplicate</code></td>
<td>
<p>[1:n,1:n] matrix,for i!=j IsDuplicate[i,j]== 1  if Datapoints[i,] == Datapoints[j,]    IsDuplicate[i,i]==0</p>
</td></tr>
<tr><td><code>UniqueInd</code></td>
<td>
<p>[1:k] index vector such that Unique ==  Datapoints[UniqueInd,], it has k non-consecutive numbers or labels, each label defines a row number within Datapoints[1:n,1:d] of a unique data point</p>
</td></tr>
<tr><td><code>Uniq2DatapointsInd</code></td>
<td>
<p> [1:n] index vector. It has k unique index numbers representing the arbitrary labels. Each labels is mapped uniquely to a point in <code>Unique</code>. Logically in a way such that Datapoints ==  Unique[Uniq2DatapointsInd,] (will not work directly in R this way) </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Datapoints2D=rbind(c(1,2),c(1,2),c(1,3),c(3,1))
V=UniquePoints(Datapoints2D)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
