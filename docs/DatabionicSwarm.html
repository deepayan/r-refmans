<!DOCTYPE html><html><head><title>Help for package DatabionicSwarm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DatabionicSwarm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DatabionicSwarm-package'>
<p>Swarm Intelligence for Self-Organized Clustering</p></a></li>
<li><a href='#DBSclustering'>
<p>Databonic swarm clustering (DBS)</p></a></li>
<li><a href='#DefaultColorSequence'>
<p>Default color sequence for plots</p></a></li>
<li><a href='#Delaunay4Points'>
<p>Adjacency matrix of the delaunay graph for BestMatches of Points</p></a></li>
<li><a href='#Delta3DWeightsC'>
<p>Intern function</p></a></li>
<li><a href='#DijkstraSSSP'>
<p>Internal function: Dijkstra SSSP</p></a></li>
<li><a href='#findPossiblePositionsCsingle'>
<p>Intern function, do not use yourself</p></a></li>
<li><a href='#GeneratePswarmVisualization'>
<p>Generates the Umatrix for Pswarm algorithm</p></a></li>
<li><a href='#getCartesianCoordinates'><p>Intern function: Transformation of Databot indizes to coordinates</p></a></li>
<li><a href='#getUmatrix4Projection'><p>depricated! see GeneralizedUmatrix() Generalisierte U-Matrix fuer</p>
Projektionsverfahren</a></li>
<li><a href='#Hepta'>
<p>Hepta is part of the Fundamental Clustering Problem Suit (FCPS) [Thrun/Ultsch, 2020].</p></a></li>
<li><a href='#Lsun3D'>
<p>Lsun3D is part of the Fundamental Clustering Problem Suit (FCPS) [Thrun/Ultsch, 2020].</p></a></li>
<li><a href='#plotSwarm'>
<p>Intern function for plotting during the Pswarm annealing process</p></a></li>
<li><a href='#ProjectedPoints2Grid'>
<p>Transforms ProjectedPoints to a grid</p></a></li>
<li><a href='#Pswarm'>
<p>A Swarm of Databots based on polar coordinates (Polar Swarm).</p></a></li>
<li><a href='#PswarmCurrentRadiusC2botsPositive'>
<p>intern function, do not use yourself</p></a></li>
<li><a href='#rDistanceToroidCsingle'>
<p>Intern function for <code>Pswarm</code></p></a></li>
<li><a href='#RelativeDifference'>
<p>Relative Difference</p></a></li>
<li><a href='#sESOM4BMUs'>
<p>Intern function: Simplified Emergent Self-Organizing Map</p></a></li>
<li><a href='#setdiffMatrix'><p>setdiffMatrix shortens Matrix2Curt by those rows that are in both</p>
matrices.</a></li>
<li><a href='#setGridSize'>
<p>Sets the grid size for the Pswarm algorithm</p></a></li>
<li><a href='#setPolarGrid'>
<p>Intern function: Sets the polar grid</p></a></li>
<li><a href='#setRmin'><p>Intern function: Estimates the minimal radius for the Databot scent</p></a></li>
<li><a href='#ShortestGraphPathsC'>
<p>Shortest GraphPaths = geodesic distances</p></a></li>
<li><a href='#trainstepC'>
<p>Internal function for sESOM</p></a></li>
<li><a href='#UniquePoints'><p>Unique Points</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Title:</td>
<td>Swarm Intelligence for Self-Organized Clustering</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-12</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Thrun &lt;m.thrun@gmx.net&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Algorithms implementing populations of agents that interact with one another and sense their environment may exhibit emergent behavior such as self-organization and swarm intelligence. Here, a swarm system called Databionic swarm (DBS) is introduced which was published in Thrun, M.C., Ultsch A.: "Swarm Intelligence for Self-Organized Clustering" (2020), Artificial Intelligence, &lt;<a href="https://doi.org/10.1016%2Fj.artint.2020.103237">doi:10.1016/j.artint.2020.103237</a>&gt;. DBS is able to adapt itself to structures of high-dimensional data such as natural clusters characterized by distance and/or density based structures in the data space. The first module is the parameter-free projection method called Pswarm (Pswarm()), which exploits the concepts of self-organization and emergence, game theory, swarm intelligence and symmetry considerations. The second module is the parameter-free high-dimensional data visualization technique, which generates projected points on the topographic map with hypsometric tints defined by the generalized U-matrix (GeneratePswarmVisualization()). The third module is the clustering method itself with non-critical parameters (DBSclustering()). Clustering can be verified by the visualization and vice versa. The term DBS refers to the method as a whole. It enables even a non-professional in the field of data mining to apply its algorithms for visualization and/or clustering to data sets with completely different structures drawn from diverse research fields. The comparison to common projection methods can be found in the book of Thrun, M.C.: "Projection Based Clustering through Self-Organization and Swarm Intelligence" (2018) &lt;<a href="https://doi.org/10.1007%2F978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>&gt;.</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.8), RcppParallel (&ge; 5.1.4), deldir,
GeneralizedUmatrix</td>
</tr>
<tr>
<td>Suggests:</td>
<td>DataVisualizations, knitr (&ge; 1.12), rmarkdown (&ge; 0.9),
plotrix, geometry, sp, spdep, parallel, rgl, png,
ProjectionBasedClustering, parallelDist, pracma, dendextend</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppParallel</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make, pandoc (&gt;=1.12.3, needed for vignettes)</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.deepbionics.org/">https://www.deepbionics.org/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Mthrun/DatabionicSwarm/issues">https://github.com/Mthrun/DatabionicSwarm/issues</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-12 11:58:31 UTC; MCT</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Thrun <a href="https://orcid.org/0000-0001-9542-5543"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Quirin Stier [aut, rev]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-13 11:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='DatabionicSwarm-package'>
Swarm Intelligence for Self-Organized Clustering
</h2><span id='topic+DatabionicSwarm-package'></span><span id='topic+DatabionicSwarm'></span>

<h3>Description</h3>

<p>Algorithms implementing populations of agents that interact with one another and sense their environment may exhibit emergent behavior such as self-organization and swarm intelligence. Here, a swarm system called Databionic swarm (DBS) is introduced which was published in Thrun, M.C., Ultsch A.: &quot;Swarm Intelligence for Self-Organized Clustering&quot; (2020), Artificial Intelligence, &lt;DOI:10.1016/j.artint.2020.103237&gt;. DBS is able to adapt itself to structures of high-dimensional data such as natural clusters characterized by distance and/or density based structures in the data space. The first module is the parameter-free projection method called Pswarm (Pswarm()), which exploits the concepts of self-organization and emergence, game theory, swarm intelligence and symmetry considerations. The second module is the parameter-free high-dimensional data visualization technique, which generates projected points on the topographic map with hypsometric tints defined by the generalized U-matrix (GeneratePswarmVisualization()). The third module is the clustering method itself with non-critical parameters (DBSclustering()). Clustering can be verified by the visualization and vice versa. The term DBS refers to the method as a whole. It enables even a non-professional in the field of data mining to apply its algorithms for visualization and/or clustering to data sets with completely different structures drawn from diverse research fields. The comparison to common projection methods can be found in the book of Thrun, M.C.: &quot;Projection Based Clustering through Self-Organization and Swarm Intelligence&quot; (2018) &lt;DOI:10.1007/978-3-658-20540-9&gt;.
</p>


<h3>Details</h3>

<p>For a brief introduction to <span class="pkg">DatabionicSwarm</span> please see the vignette <a href="../doc/DatabionicSwarm.html">Short Intro to the Databionic Swarm (DBS)</a>.
The license is CC BY-NC-SA 4.0.
</p>

<p>Index of help topics:
</p>
<pre>
DBSclustering           Databonic swarm clustering (DBS)
DatabionicSwarm-package
                        Swarm Intelligence for Self-Organized
                        Clustering
DefaultColorSequence    Default color sequence for plots
Delaunay4Points         Adjacency matrix of the delaunay graph for
                        BestMatches of Points
Delta3DWeightsC         Intern function
DijkstraSSSP            Internal function: Dijkstra SSSP
GeneratePswarmVisualization
                        Generates the Umatrix for Pswarm algorithm
Hepta                   Hepta is part of the Fundamental Clustering
                        Problem Suit (FCPS) [Thrun/Ultsch, 2020].
Lsun3D                  Lsun3D is part of the Fundamental Clustering
                        Problem Suit (FCPS) [Thrun/Ultsch, 2020].
ProjectedPoints2Grid    Transforms ProjectedPoints to a grid
Pswarm                  A Swarm of Databots based on polar coordinates
                        (Polar Swarm).
PswarmCurrentRadiusC2botsPositive
                        intern function, do not use yourself
RelativeDifference      Relative Difference
ShortestGraphPathsC     Shortest GraphPaths = geodesic distances
UniquePoints            Unique Points
findPossiblePositionsCsingle
                        Intern function, do not use yourself
getCartesianCoordinates
                        Intern function: Transformation of Databot
                        indizes to coordinates
getUmatrix4Projection   depricated! see GeneralizedUmatrix()
                        Generalisierte U-Matrix fuer
                        Projektionsverfahren
plotSwarm               Intern function for plotting during the Pswarm
                        annealing process
rDistanceToroidCsingle
                        Intern function for 'Pswarm'
sESOM4BMUs              Intern function: Simplified Emergent
                        Self-Organizing Map
setGridSize             Sets the grid size for the Pswarm algorithm
setPolarGrid            Intern function: Sets the polar grid
setRmin                 Intern function: Estimates the minimal radius
                        for the Databot scent
setdiffMatrix           setdiffMatrix shortens Matrix2Curt by those
                        rows that are in both matrices.
trainstepC              Internal function for sESOM
</pre>


<h3>Note</h3>

<p>For interactive Island Generation of a generalized Umatrix  
see <code>interactiveGeneralizedUmatrixIsland</code> function in the package <span class="pkg">ProjectionBasedClustering</span>.
</p>
<p>If you want to verifiy your clustering result externally, you can use <code>Heatmap</code> or <code>SilhouettePlot</code> of the CRAN package <span class="pkg">DataVisualizations</span>.
</p>


<h3>Author(s)</h3>

<p>Michal Thrun
</p>
<p>Maintainer: Michael Thrun &lt;m.thrun@gmx.net&gt;
</p>


<h3>References</h3>

<p>[Thrun/Ultsch, 2021]  Thrun, M. C., and Ultsch, A.: Swarm Intelligence for Self-Organized Clustering, Artificial Intelligence, Vol. 290, pp. 103237, <a href="https://doi.org/10.1016/j.artint.2020.103237">doi:10.1016/j.artint.2020.103237</a>, 2021.
</p>
<p>[Thrun/Ultsch, 2021] Thrun, M. C., &amp; Ultsch, A.: Swarm Intelligence for Self-Organized Clustering (Extended Abstract), in Bessiere, C. (Ed.), 29th International Joint Conference on Artificial Intelligence (IJCAI), Vol. IJCAI-20, pp. 5125&ndash;5129, <a href="https://doi.org/10.24963/ijcai.2020/720">doi:10.24963/ijcai.2020/720</a>, Yokohama, Japan, Jan., 2021. 
</p>
<p>[Thrun/Ultsch, 2020]  Thrun, M. C., &amp; Ultsch, A.: Uncovering High-Dimensional Structures of Projections from Dimensionality Reduction Methods, MethodsX, Vol. 7, pp. 101093, DOI <a href="https://doi.org/10.1016/j.mex.2020.101093">doi:10.1016/j.mex.2020.101093</a>, 2020. 
</p>
<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer, Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018. 
</p>
<p>[Ultsch/Thrun, 2017]  Ultsch, A., &amp; Thrun, M. C.: Credible Visualizations for Planar Projections, in Cottrell, M. (Ed.), 12th International Workshop on Self-Organizing Maps and Learning Vector Quantization, Clustering and Data Visualization (WSOM), IEEE Xplore, France, 2017.
</p>
<p>[Thrun et al., 2016]  Thrun, M. C., Lerch, F., Loetsch, J., &amp; Ultsch, A.: Visualization and 3D Printing of Multivariate Data of Biomarkers, in Skala, V. (Ed.), International Conference in Central Europe on Computer Graphics, Visualization and Computer Vision (WSCG), Vol. 24, Plzen, http://wscg.zcu.cz/wscg2016/short/A43-full.pdf, 2016.
</p>
<p>Successfully used in
</p>
<p>[Thrun et al., 2018]   Thrun, M. C., Breuer, L., &amp; Ultsch, A. : Knowledge discovery from low-frequency stream nitrate concentrations: hydrology and biology contributions, Proc. European Conference on Data Analysis (ECDA), pp. 46-47, Paderborn, Germany, 2018. 
</p>
<p>[Weyer-Menkhoff et al., 2018]  Weyer-Menkhoff, I., Thrun, M. C., &amp; Loetsch, J.: Machine-learned analysis of quantitative sensory testing responses to noxious cold stimulation in healthy subjects, European Journal of Pain, Vol. 22(5), pp. 862-874, DOI <a href="https://doi.org/10.1002/ejp.1173">doi:10.1002/ejp.1173</a>, 2018. 
</p>
<p>[Kringel et al., 2018]  Kringel, D., Geisslinger, G., Resch, E., Oertel, B. G., Thrun, M. C., Heinemann, S., &amp; Loetsch, J. : Machine-learned analysis of the association of next-generation sequencing based human TRPV1 and TRPA1 genotypes with the sensitivity to heat stimuli and topically applied capsaicin, Pain, Vol. 159 (7 ), pp. 1366-1381, DOI <a href="https://doi.org/10.1097/j.pain.0000000000001222">doi:10.1097/j.pain.0000000000001222</a>, 2018 
</p>
<p>[Thrun, 2019]  Thrun, M. C.: : Cluster Analysis of Per Capita Gross Domestic Products, Entrepreneurial Business and Economics Review (EBER), Vol. 7(1), pp. 217-231, DOI: <a href="https://doi.org/10.15678/EBER.2019.070113">doi:10.15678/EBER.2019.070113</a>, 2019.
</p>
<p>[Lopez-Garcia et al., 2020]  Lopez-Garcia, P., Argote, D. L., &amp; Thrun, M. C.: Projection-based Classification of Chemical Groups and Provenance Analysis of Archaeological Materials, IEEE Access, Vol. 8, pp. 152439-152451, DOI <a href="https://doi.org/10.1109/ACCESS.2020.3016244">doi:10.1109/ACCESS.2020.3016244</a>, 2020. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('Lsun3D')
##2d projection, without instant visualization of steps

#Alternative I:
#DistanceMatrix hast to be defined by the user.
InputDistances=as.matrix(dist(Lsun3D$Data))

projection=Pswarm(InputDistances)
#2d projection, with instant visualization 

## Not run: 
#Alternative II: DataMatrix, Distance is Euclidean per default
projection=Pswarm(Lsun3D$Data,Cls=Lsun3D$Cls,PlotIt=T)

## End(Not run)
#
##Computation of Generalized Umatrix
# If Non Euclidean Distances are used, Please Use \code{MDS}
# from the ProjectionBasedClustering package with the correct OutputDimension
# to generate a new DataMatrix from the distances (see SheppardDiagram
# or KruskalStress)
genUmatrixList=GeneratePswarmVisualization(Data = Lsun3D$Data,

projection$ProjectedPoints,projection$LC)
## Visualizuation of GenerelizedUmatrix, 
# Estimation of the Number of Clusters=Number of valleys
library(GeneralizedUmatrix)#install if not installed
GeneralizedUmatrix::plotTopographicMap(genUmatrixList$Umatrix,genUmatrixList$Bestmatches)
## Automatic Clustering
# number of Cluster from dendrogram (PlotIt=TRUE) or visualization 
Cls=DBSclustering(k=3, Lsun3D$Data, 

genUmatrixList$Bestmatches, genUmatrixList$LC,PlotIt=FALSE)
# Verification, often its better to mark Outliers manually

GeneralizedUmatrix::plotTopographicMap(genUmatrixList$Umatrix,genUmatrixList$Bestmatches,Cls)

## Not run: 
# To generate the 3D landscape in the shape of an island 
# from the toroidal topograpic map visualization
# you may cut your island interactivly around high mountain ranges
Imx = ProjectionBasedClustering::interactiveGeneralizedUmatrixIsland(genUmatrixList$Umatrix,
genUmatrixList$Bestmatches,Cls)

GeneralizedUmatrix::plotTopographicMap(genUmatrixList$Umatrix,
genUmatrixList$Bestmatches, Cls=Cls,Imx = Imx)

## End(Not run)
## Not run: 
library(ProjectionBasedClustering)#install if not installed
Cls2=ProjectionBasedClustering::interactiveClustering(genUmatrixList$Umatrix, 
genUmatrixList$Bestmatches, Cls)

## End(Not run)


</code></pre>

<hr>
<h2 id='DBSclustering'>
Databonic swarm clustering (DBS)
</h2><span id='topic+DBSclustering'></span>

<h3>Description</h3>

<p>DBS is a flexible and robust clustering framework that consists
of three independent modules. The first module is the parameter-free
projection method Pswarm <code><a href="#topic+Pswarm">Pswarm</a></code>, which exploits the concepts of
self-organization and emergence, game theory, swarm intelligence and symmetry
considerations [Thrun/Ultsch, 2021]. The second module is a parameter-free
high-dimensional data visualization technique, which generates projected points
on a topographic map with hypsometric colors
<code><a href="#topic+GeneratePswarmVisualization">GeneratePswarmVisualization</a></code>, called the generalized U-matrix.
The third module is a clustering method with no sensitive parameters
<code><a href="#topic+DBSclustering">DBSclustering</a></code> (see [Thrun, 2018, p. 104 ff]). The clustering can
be verified by the visualization and vice versa. The term DBS refers to the
method as a whole.
</p>
<p>The <code><a href="#topic+DBSclustering">DBSclustering</a></code> function applies the automated Clustering
approach of the Databonic swarm using abstract U distances, which are the
geodesic distances based on high-dimensional distances combined with low
dimensional graph paths by using <code>ShortestGraphPathsC</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DBSclustering(k, DataOrDistance, BestMatches, LC, StructureType = TRUE,
PlotIt = FALSE, ylab,main, method = "euclidean",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DBSclustering_+3A_k">k</code></td>
<td>
<p>number of clusters, how many to you see in the topographic map
(3D landscape)?</p>
</td></tr>
<tr><td><code id="DBSclustering_+3A_dataordistance">DataOrDistance</code></td>
<td>
<p>Either [1:n,1:d] Matrix of Data (n cases, d dimensions)
that will be used. One DataPoint per row or symmetric Distance matrix [1:n,1:n]</p>
</td></tr>
<tr><td><code id="DBSclustering_+3A_bestmatches">BestMatches</code></td>
<td>
<p>[1:n,1:2] Matrix with positions of Bestmatches or
ProjectedPoints, one matrix line per data point</p>
</td></tr>
<tr><td><code id="DBSclustering_+3A_lc">LC</code></td>
<td>
<p>grid size c(Lines,Columns), please see details</p>
</td></tr>
<tr><td><code id="DBSclustering_+3A_structuretype">StructureType</code></td>
<td>
<p>Optional, bool; = TRUE: compact structure of clusters
assumed, =FALSE: connected structure of clusters assumed. For the two options
for Clusters, see [Thrun, 2018] or Handl et al. 2006</p>
</td></tr>
<tr><td><code id="DBSclustering_+3A_plotit">PlotIt</code></td>
<td>
<p>Optional, bool, Plots Dendrogramm</p>
</td></tr>
<tr><td><code id="DBSclustering_+3A_ylab">ylab</code></td>
<td>
<p>Optional, character vector, ylabel of dendrogramm</p>
</td></tr>
<tr><td><code id="DBSclustering_+3A_main">main</code></td>
<td>
<p>Optional, character vctor, title of dendrogramm</p>
</td></tr>
<tr><td><code id="DBSclustering_+3A_method">method</code></td>
<td>
<p>Optional, one of 39 distance methods of <code>parDist</code> of package
parallelDist,  if Data matrix is chosen above</p>
</td></tr>
<tr><td><code id="DBSclustering_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to the <code>parDist</code> function, e.g.
user-defined distance functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input of the <code>LC</code> parameter depends on the choice of <code>Bestmatches</code>
input argument. Usually as the name of the argument states, the Bestmatches of
the <code><a href="#topic+GeneratePswarmVisualization">GeneratePswarmVisualization</a></code> function are used which is define
in the notation of self-organizing map. In this case please see example one.
</p>
<p>However, as written above, clustering and visualization can be applied
independently of each other. In this case the places of Lines L and Columns C
are switched because Lines is a value slightly above the maximum of the x-coordinates and Columns is a value slightly above the maximum of the y-coordinates  of ProjectedPoint. 
Hence, one should give  <code><a href="#topic+DBSclustering">DBSclustering</a></code> the argument
<code>LC[2,1]</code> as shown in example 2. 
</p>
<p>Often it is better to mark the outliers  manually after the prozess of
clustering and sometimes a clustering can be improved through human interaction
[Thrun/Ultsch,2017] &lt;DOI:10.13140/RG.2.2.13124.53124&gt;; use in this case the
visualization <code><a href="GeneralizedUmatrix.html#topic+plotTopographicMap">plotTopographicMap</a></code> of the
package GeneralizedUmatrix. If you would like to mark the outliers interactivly
in the visualization use the <span class="pkg">ProjectionBasedClustering</span> package with the
function <code>interactiveClustering()</code>, or for full interactive clustering
<code>IPBC()</code>. The package is available on CRAN. An example is shown in case
of  <code>interactiveClustering()</code> function in the third example.
</p>


<h3>Value</h3>

<p>[1:n] numerical vector of numbers defining the classification as the main output
of this cluster analysis for the n cases of data corresponding to the n
bestmatches. It has k unique numbers representing the arbitrary labels of the
clustering. You can use <code>plotTopographicMap(Umatrix,Bestmatches,Cls)</code> for
verification.
</p>


<h3>Note</h3>

<p>If you want to verifiy your clustering result externally, you can use
<code>Heatmap</code> or <code>SilhouettePlot</code> of the package <span class="pkg">DataVisualizations</span>
available on CRAN.
</p>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>[Thrun/Ultsch, 2021]  Thrun, M. C., and Ultsch, A.: Swarm Intelligence for
Self-Organized Clustering, Artificial Intelligence, Vol. 290, pp. 103237,
<a href="https://doi.org/10.1016/j.artint.2020.103237">doi:10.1016/j.artint.2020.103237</a>, 2021.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Lsun3D")
Data=Lsun3D$Data
InputDistances=as.matrix(dist(Data))
projection=Pswarm(InputDistances)
## Example One
genUmatrixList=GeneratePswarmVisualization(Data,

projection$ProjectedPoints,projection$LC)

Cls=DBSclustering(k=3, Data, 

genUmatrixList$Bestmatches, genUmatrixList$LC,PlotIt=TRUE)


## Example Two
#automatic Clustering without GeneralizedUmatrix visualization
Cls=DBSclustering(k=3, Data, 

projection$ProjectedPoints, projection$LC[c(2,1)],PlotIt=TRUE)

## Not run: 
## Example Three
## Sometimes an automatic Clustering can be improved 
## thorugh an interactive approach, 
## e.g. if Outliers exist (see [Thrun/Ultsch, 2017])
library(ProjectionBasedClustering)
Cls2=ProjectionBasedClustering::interactiveClustering(genUmatrixList$Umatrix, 
genUmatrixList$Bestmatches, Cls)

## End(Not run)


</code></pre>

<hr>
<h2 id='DefaultColorSequence'>
Default color sequence for plots
</h2><span id='topic+DefaultColorSequence'></span>

<h3>Description</h3>

<p>Defines the default color sequence for plots made within the Projections package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DefaultColorSequence")</code></pre>


<h3>Format</h3>

<p>A vector with 562 different strings describing colors for plots.
</p>

<hr>
<h2 id='Delaunay4Points'>
Adjacency matrix of the delaunay graph for BestMatches of Points
</h2><span id='topic+Delaunay4Points'></span>

<h3>Description</h3>

<p>Calculates the adjacency matrix of the delaunay graph for BestMatches (BMs) in
tiled form if BestMatches are located on a toroid grid.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Delaunay4Points(Points, IsToroid = TRUE,LC,PlotIt=FALSE,
Gabriel=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Delaunay4Points_+3A_points">Points</code></td>
<td>
<p>[1:n,1:3] matrix containing the BMKey, X and Y coordinates of the
n,  BestMatches NEED NOT to be UNIQUE,  however, there is an edge in the Deaunay
between duplicate points!</p>
</td></tr>
<tr><td><code id="Delaunay4Points_+3A_istoroid">IsToroid</code></td>
<td>
<p>Optional, logical, indicating if BM's are on a toroid grid.
Default is True</p>
</td></tr>
<tr><td><code id="Delaunay4Points_+3A_lc">LC</code></td>
<td>
<p>Optional, A vector of length 2, containing the number of lines and columns of the Grid. Lines is a value slightly above the maximum of the x-coordinates and Columns is a value slightly above the maximum of the y-coordinates  of Points.</p>
</td></tr>
<tr><td><code id="Delaunay4Points_+3A_plotit">PlotIt</code></td>
<td>
<p>Optional, bool, Plots the graph</p>
</td></tr>
<tr><td><code id="Delaunay4Points_+3A_gabriel">Gabriel</code></td>
<td>
<p>Optional, bool, default: FALSE, If TRUE: calculates the gabriel
graph instead of the delaunay graph</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Delaunay[1:n,1:n] adjacency matrix of the Delaunay-Graph</p>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through
Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer,
Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018. 
</p>

<hr>
<h2 id='Delta3DWeightsC'>
Intern function
</h2><span id='topic+Delta3DWeightsC'></span>

<h3>Description</h3>

<p>Implementation of the main equation for SOM, ESOM or the sESOM algorithms</p>


<h3>Usage</h3>

<pre><code class='language-R'>Delta3DWeightsC(vx,Datasample)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Delta3DWeightsC_+3A_vx">vx</code></td>
<td>
<p> array of weights [1:Lines,1:Columns,1:Weights]</p>
</td></tr>
<tr><td><code id="Delta3DWeightsC_+3A_datasample">Datasample</code></td>
<td>
<p>NumericVector of one Datapoint[1:n]</p>
</td></tr>
</table>


<h3>Details</h3>

<p>intern function in case of <code>ComputeInR==FALSE</code> in <code><a href="#topic+GeneratePswarmVisualization">GeneratePswarmVisualization</a></code>,
see chapter 5.3 of [Thrun, 2018] for generalized Umatrix and especially the <code>sESOM4BMUs</code> algorithm.
</p>


<h3>Value</h3>

<p>modified array of weights [1:Lines,1:Columns,1:]
</p>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer, Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018. 
</p>

<hr>
<h2 id='DijkstraSSSP'>
Internal function: Dijkstra SSSP
</h2><span id='topic+DijkstraSSSP'></span>

<h3>Description</h3>

<p>Dijkstra's SSSP (Single source shortest path) algorithm:
</p>
<p>gets the shortest path (geodesic distance) from source vertice(point) to all other vertices(points) defined by 
the edges of the adjasency matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DijkstraSSSP(Adj, Costs, source)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DijkstraSSSP_+3A_adj">Adj</code></td>
<td>
<p>[1:n,1:n] 0/1 adjascency matrix, e.g. from delaunay graph or gabriel
graph</p>
</td></tr>
<tr><td><code id="DijkstraSSSP_+3A_costs">Costs</code></td>
<td>
<p>[1:n,1:n]   matrix, distances between n points (normally
euclidean)</p>
</td></tr>
<tr><td><code id="DijkstraSSSP_+3A_source">source</code></td>
<td>
<p>integer vertice(point) from which to calculate the geodesic
distance to all other points</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Preallocating space for DataStructures accordingly to the maximum possible number of vertices which is fixed set at 
the number 10001.
This is an internal function of <code><a href="#topic+ShortestGraphPathsC">ShortestGraphPathsC</a></code>, no errors or mis-usage is caught here.
</p>


<h3>Value</h3>

<p>ShortestPaths[1:n] vector, shortest paths (geodesic) to all other vertices
including the source vertice itself</p>


<h3>Note</h3>

<p>runs in O(E*Log(V))
</p>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>uses a changed code which is inspired by Shreyans Sheth 28.05.2015, see 
<a href="https://ideone.com/qkmt31">https://ideone.com/qkmt31</a>
</p>

<hr>
<h2 id='findPossiblePositionsCsingle'>
Intern function, do not use yourself
</h2><span id='topic+findPossiblePositionsCsingle'></span>

<h3>Description</h3>

<p>Finds all possible jumping position regarding a grid anda Radius for DataBots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findPossiblePositionsCsingle(RadiusPositionsschablone,
jumplength, alpha, Lines)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findPossiblePositionsCsingle_+3A_radiuspositionsschablone">RadiusPositionsschablone</code></td>
<td>
<p>NumericMatrix, see <code><a href="#topic+setPolarGrid">setPolarGrid</a></code></p>
</td></tr>
<tr><td><code id="findPossiblePositionsCsingle_+3A_jumplength">jumplength</code></td>
<td>
<p>double radius of databots regarding neighborhood, they can
jump to</p>
</td></tr>
<tr><td><code id="findPossiblePositionsCsingle_+3A_alpha">alpha</code></td>
<td>
<p>double, zu streichen</p>
</td></tr>
<tr><td><code id="findPossiblePositionsCsingle_+3A_lines">Lines</code></td>
<td>
<p>double, jumpinglength has to smaller than Lines/2 and Lines/2 has
to yield to a integer number. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Algorithm is described in [Thrun, 2018, p. 95, Listing 8.1].
</p>


<h3>Value</h3>

<table>
<tr><td><code>OpenPositions</code></td>
<td>
<p>NumericMatrix, indizes of open positions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through
Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer,
Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setPolarGrid">setPolarGrid</a></code>
</p>

<hr>
<h2 id='GeneratePswarmVisualization'>
Generates the Umatrix for Pswarm algorithm
</h2><span id='topic+GeneratePswarmVisualization'></span>

<h3>Description</h3>

<p>DBS is a flexible and robust clustering framework that consists of three
independent modules. The first module is the parameter-free projection method
Pswarm <code><a href="#topic+Pswarm">Pswarm</a></code>, which exploits the concepts of self-organization 
and emergence, game theory, swarm intelligence and symmetry considerations. The
second module is a parameter-free high-dimensional data visualization technique,
which generates projected points on a topographic map with hypsometric colors
<code><a href="#topic+GeneratePswarmVisualization">GeneratePswarmVisualization</a></code>, called the generalized U-matrix. The
third module is a clustering method with no sensitive parameters
<code><a href="#topic+DBSclustering">DBSclustering</a></code>. The clustering can be verified by the visualization
and vice versa. The term DBS refers to the method as a whole.
</p>
<p>The <code><a href="#topic+GeneratePswarmVisualization">GeneratePswarmVisualization</a></code> function generates the special
case (please see [Thrun, 2018]) of the generalized Umatrix with the help of an
unsupervised neural network (simplified emergent self-organizing map  published
in [Thrun/Ultsch, 2020]). From the generalized Umatrix a topographic map with
hypsometric tints can be visualized. To see this visualization use
<code><a href="GeneralizedUmatrix.html#topic+plotTopographicMap">plotTopographicMap</a></code> of the package
<span class="pkg">GeneralizedUmatrix</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeneratePswarmVisualization(Data,ProjectedPoints,LC,PlotIt=FALSE,
ComputeInR=FALSE,Parallel=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeneratePswarmVisualization_+3A_data">Data</code></td>
<td>
<p>[1:n,1:d] array of data: n cases in rows, d variables in columns</p>
</td></tr>
<tr><td><code id="GeneratePswarmVisualization_+3A_projectedpoints">ProjectedPoints</code></td>
<td>
<p>matrix, ProjectedPoints[1:n,1:2]  n by 2 matrix
containing coordinates of the Projection: A matrix of the fitted configuration.
See output of <code><a href="#topic+Pswarm">Pswarm</a></code> for further details</p>
</td></tr>
<tr><td><code id="GeneratePswarmVisualization_+3A_lc">LC</code></td>
<td>
<p>size of the grid c(Lines,Columns), number of Lines and Columns
automatic calculated by <code><a href="#topic+setGridSize">setGridSize</a></code> in <code><a href="#topic+Pswarm">Pswarm</a></code>
</p>
<p>Sometimes is better to choose a different grid size, e.g. to to reduce
computional effort contrary to SOM, here the grid size defined only the
resolution of the visualizations. The real grid size is predefined by Pswarm,
but you may choose a factor x*res$LC if you so desire. Therefore, The resulting
grid size is given back in the Output.</p>
</td></tr>
<tr><td><code id="GeneratePswarmVisualization_+3A_plotit">PlotIt</code></td>
<td>
<p>Optional, default(FALSE), If TRUE than uses
<code>plotTopographicMap</code> of the package GeneralizedUmatrix is plotted as a
topview in the tiled option, see details for explanation.</p>
</td></tr>
<tr><td><code id="GeneratePswarmVisualization_+3A_computeinr">ComputeInR</code></td>
<td>
<p>Optional, =TRUE: Rcode, =FALSE C++ implementation</p>
</td></tr>
<tr><td><code id="GeneratePswarmVisualization_+3A_parallel">Parallel</code></td>
<td>
<p>Optional, =TRUE: Parallel C++ implementation, =FALSE C++ implementation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tiled: The topographic map is visualized 4 times because the projection is
toroidal. The reason is that there are no border in the visualizations and
clusters (if they exist) are not disrupted by borders of the plot.
</p>
<p>If you used <code><a href="#topic+Pswarm">Pswarm</a></code> with distance matrix instead of a data matrix
(in the sense that you do not have any data matrix available), you may transform
your distances into data by using <code>MDS</code> of the
<span class="pkg">ProjectionBasedClustering</span> package in order to use the
<code><a href="#topic+GeneratePswarmVisualization">GeneratePswarmVisualization</a></code> function. The correct dimension can be
found through the Sheppard diagram or kruskals stress.
</p>


<h3>Value</h3>

<p>list of
</p>
<table>
<tr><td><code>Bestmatches</code></td>
<td>
<p>Numeric matrix [1:n,1:2], BestMatches of the Umatrix,
contrary to ESOM they are always fixed, because predefined by GridPoints.</p>
</td></tr>
<tr><td><code>Umatrix</code></td>
<td>
<p>Numeric matrix [1:Lines,1:Columns],</p>
</td></tr>
<tr><td><code>WeightsOfNeurons</code></td>
<td>
<p>Numeric 3D array [1:Lines,1:Columns,1:d], d is the
dimension of the weights, the same as in the ESOM algorithm</p>
</td></tr>
<tr><td><code>GridPoints</code></td>
<td>
<p>Integer matrix [1:n,1:2], quantized projected points:
projected points now lie on a predefined grid.</p>
</td></tr>
<tr><td><code>LC</code></td>
<td>
<p>c(Lines,Columns), normally equal to grid size of Pswarm, sometimes it
a better or a lower resolution for the visualization is better. Therefore here
the grid size of the neurons is given back.
</p>
</td></tr>
<tr><td><code>PlotlyHandle</code></td>
<td>
<p>If PlotIt=FALSE: NULL, otherwise plotly object for ploting
topview of topographic map.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If you used pswarm with distance matrix instead of a data matrix you can mds
transform your distances into data (see the <code>MDS</code> function of the
ProjectionBasedClustering package.). The correct dimension can be found through
the Sheppard diagram or kruskals stress.
</p>


<h3>Note</h3>

<p>The extraction of an island out of the generalized Umatrix can be performed
using the <code>interactiveGeneralizedUmatrixIsland</code> function in the package
<span class="pkg">ProjectionBasedClustering</span>.
</p>
<p>The main code of both functions <code>GeneralizedUmatrix</code> and
<code>GeneratePswarmVisualization</code> is the same C++ function
<code>sESOM4BMUs</code> which is described in [Thrun/Ultsch, 2020].
</p>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through
Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer,
Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018. 
</p>
<p>[Thrun/Ultsch, 2020]  Thrun, M. C., &amp; Ultsch, A.: Uncovering High-Dimensional
Structures of Projections from Dimensionality Reduction Methods, MethodsX,
Vol. 7, pp. 101093, <a href="https://doi.org/10.1016/j.mex.2020.101093">doi:10.1016/j.mex.2020.101093</a>, 2020. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Pswarm">Pswarm</a></code> and
<code><a href="GeneralizedUmatrix.html#topic+plotTopographicMap">plotTopographicMap</a></code> and
<code><a href="GeneralizedUmatrix.html#topic+GeneralizedUmatrix">GeneralizedUmatrix</a></code> of the package
<span class="pkg">GeneralizedUmatrix</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Lsun3D")
Data=Lsun3D$Data
Cls=Lsun3D$Cls
InputDistances=as.matrix(dist(Data))

projList=Pswarm(InputDistances)
genUmatrixList=GeneratePswarmVisualization(Data,
  projList$ProjectedPoints,projList$LC,
  Parallel=FALSE)#CRAN guidelines do not allow =TRUE for testing
library(GeneralizedUmatrix)
plotTopographicMap(genUmatrixList$Umatrix,genUmatrixList$Bestmatches,Cls)



</code></pre>

<hr>
<h2 id='getCartesianCoordinates'>Intern function: Transformation of Databot indizes to coordinates</h2><span id='topic+getCartesianCoordinates'></span>

<h3>Description</h3>

<p>Transforms Databot indizes to exact cartesian coordinates on an toroid two
dimensional grid.</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCartesianCoordinates_+3A_databotspos">DataBotsPos</code></td>
<td>
<p>[1:N] complex vector Two Indizes per Databot describing its
positions in an two dimensional grid</p>
</td></tr>
<tr><td><code id="getCartesianCoordinates_+3A_gridradius">GridRadius</code></td>
<td>
<p>[Lines,Columns] Radii Matrix of all possible Positions of
DataBots in Grid, see also documentation of <code><a href="#topic+setPolarGrid">setPolarGrid</a></code></p>
</td></tr>
<tr><td><code id="getCartesianCoordinates_+3A_gridangle">GridAngle</code></td>
<td>
<p>[Lines,Columns] Angle Matrix of all possible Positions of
DataBots in Grid, see also documentation of <code><a href="#topic+setPolarGrid">setPolarGrid</a></code></p>
</td></tr>
<tr><td><code id="getCartesianCoordinates_+3A_lines">Lines</code></td>
<td>
<p>Defines Size of planar toroid two dimensional grid</p>
</td></tr>
<tr><td><code id="getCartesianCoordinates_+3A_columns">Columns</code></td>
<td>
<p>Defines Size of planar toroid two dimensional grid</p>
</td></tr>
<tr><td><code id="getCartesianCoordinates_+3A_quadorhexa">QuadOrHexa</code></td>
<td>
<p>Optional, FALSE=If DataPos on hexadiagonal grid, round to 2
decimals after value, Default=TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Transformation is described in [Thrun, 2018, p. 93].
</p>


<h3>Value</h3>

<p>BestMatchingUnits[1:N,2] coordinates on an two dimensional grid for each
databot excluding unique key, such that by using
<code><a href="#topic+GeneratePswarmVisualization">GeneratePswarmVisualization</a></code> a visualization of the Pswarm
projection is possible</p>


<h3>Author(s)</h3>

<p>Michael Thrun</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through
Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer,
Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018. 
</p>

<hr>
<h2 id='getUmatrix4Projection'>depricated! see GeneralizedUmatrix() Generalisierte U-Matrix fuer
Projektionsverfahren </h2><span id='topic+getUmatrix4Projection'></span>

<h3>Description</h3>

<p>depricated! see GeneralizedUmatrix()</p>


<h3>Usage</h3>

<pre><code class='language-R'>getUmatrix4Projection(Data,ProjectedPoints,
PlotIt=TRUE,Cls=NULL,toroid=T,Tiled=F,ComputeInR=F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getUmatrix4Projection_+3A_data">Data</code></td>
<td>
<p>[1:n,1:d] Numeric matrix: n cases in rows, d variables in columns</p>
</td></tr>
<tr><td><code id="getUmatrix4Projection_+3A_projectedpoints">ProjectedPoints</code></td>
<td>
<p>[1:n,2]n by 2 matrix containing coordinates of the
Projection: A matrix of the fitted configuration.</p>
</td></tr>
<tr><td><code id="getUmatrix4Projection_+3A_plotit">PlotIt</code></td>
<td>
<p>Optional,bool, defaut=FALSE, if =TRUE: U-Marix of every current
Position of Databots will be shown</p>
</td></tr>
<tr><td><code id="getUmatrix4Projection_+3A_cls">Cls</code></td>
<td>
<p>Optional, For plotting, see <code>plotUmatrix</code> in package Umatrix</p>
</td></tr>
<tr><td><code id="getUmatrix4Projection_+3A_toroid">toroid</code></td>
<td>
<p>Optional, Default=FALSE,
==FALSE planar computation
==TRUE: toroid borderless computation, set so only if projection method is also toroidal
</p>
</td></tr>
<tr><td><code id="getUmatrix4Projection_+3A_tiled">Tiled</code></td>
<td>
<p>Optional,For plotting see <code>plotUmatrix</code> in package Umatrix</p>
</td></tr>
<tr><td><code id="getUmatrix4Projection_+3A_computeinr">ComputeInR</code></td>
<td>
<p>Optional,  =T: Rcode, =F Cpp Code</p>
</td></tr></table>


<h3>Value</h3>

<p>List with
</p>
<table>
<tr><td><code>Umatrix</code></td>
<td>
<p>[1:Lines,1:Columns] (see <code>ReadUMX</code> in package DataIO)</p>
</td></tr>
<tr><td><code>EsomNeurons</code></td>
<td>
<p>[Lines,Columns,weights] 3-dimensional numeric array
(wide format), not wts (long format)</p>
</td></tr>
<tr><td><code>Bestmatches</code></td>
<td>
<p>[1:n,OutputDimension] GridConverted Projected Points
information converted by convertProjectionProjectedPoints() to predefined Grid
by Lines and Columns</p>
</td></tr>
<tr><td><code>gplotres</code></td>
<td>
<p>Ausgabe von ggplot</p>
</td></tr>
<tr><td><code>unbesetztePositionen</code></td>
<td>
<p>Umatrix[unbesetztePositionen] = NA</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Thrun</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer, ISBN: 978-3-658-20539-3, Heidelberg, 2018.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Lsun3D")
Data=Lsun3D$Data
Cls=Lsun3D$Cls
InputDistances=as.matrix(dist(Data))
res=cmdscale(d=InputDistances, k = 2, eig = TRUE, add = FALSE, x.ret = FALSE)
ProjectedPoints=as.matrix(res$points)
# Stress = KruskalStress(InputDistances, as.matrix(dist(ProjectedPoints)))
#resUmatrix=GeneralizedUmatrix(Data,ProjectedPoints)
#plotTopographicMap(resUmatrix$Umatrix,resUmatrix$Bestmatches,Cls)
</code></pre>

<hr>
<h2 id='Hepta'>
Hepta is part of the Fundamental Clustering Problem Suit (FCPS) [Thrun/Ultsch, 2020].
</h2><span id='topic+Hepta'></span>

<h3>Description</h3>

<p>clearly defined clusters, different variances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Hepta")</code></pre>


<h3>Details</h3>

<p>Size 212, Dimensions 3, stored in <code>Hepta$Data</code>
</p>
<p>Classes 7, stored in <code>Hepta$Cls</code>
</p>


<h3>References</h3>

<p>[Thrun/Ultsch, 2020]	Thrun, M. C., &amp; Ultsch, A.: Clustering Benchmark Datasets Exploiting the Fundamental Clustering Problems, Data in Brief,Vol. 30(C), pp. 105501, DOI 10.1016/j.dib.2020.105501 , 2020. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Hepta)
str(Hepta)
</code></pre>

<hr>
<h2 id='Lsun3D'>
Lsun3D is part of the Fundamental Clustering Problem Suit (FCPS) [Thrun/Ultsch, 2020].
</h2><span id='topic+Lsun3D'></span>

<h3>Description</h3>

<p>clearly defined clusters, different variances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Lsun3D")</code></pre>


<h3>Details</h3>

<p>Size 404, Dimensions 3
</p>
<p>Dataset defined discontinuites, where the clusters have different variances.
Three main Clusters, and four Outliers (in Cluster 4). See for a more detailed description in [Thrun, 2018].
</p>


<h3>References</h3>

<p>[Thrun/Ultsch, 2020]	Thrun, M. C., &amp; Ultsch, A.: Clustering Benchmark Datasets Exploiting the Fundamental Clustering Problems, Data in Brief,Vol. 30(C), pp. 105501, DOI 10.1016/j.dib.2020.105501 , 2020. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Lsun3D)
str(Lsun3D)
Cls=Lsun3D$Cls
Data=Lsun3D$Data
</code></pre>

<hr>
<h2 id='plotSwarm'>
Intern function for plotting during the Pswarm annealing process
</h2><span id='topic+plotSwarm'></span>

<h3>Description</h3>

<p>Intern function, generates a scatter plot of the progess of the Pswarm algorithm
after every nash equlibirum. Every point symbolizes a Databot. If a prior
classification is given (<code>Cls</code>) then the Databots have the colors defined
by the class labels.</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSwarm(Points,Cls,xlab,ylab,main)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSwarm_+3A_points">Points</code></td>
<td>
<p>ProjectedPoints or DataBot positions in cartesian coordinates</p>
</td></tr>
<tr><td><code id="plotSwarm_+3A_cls">Cls</code></td>
<td>
<p>optional, Classification as a numeric vector, if given</p>
</td></tr>
<tr><td><code id="plotSwarm_+3A_xlab">xlab</code></td>
<td>
<p>='X', optional, string</p>
</td></tr>
<tr><td><code id="plotSwarm_+3A_ylab">ylab</code></td>
<td>
<p>='Y', optional, string</p>
</td></tr>
<tr><td><code id="plotSwarm_+3A_main">main</code></td>
<td>
<p>=&quot;DataBots&quot;, optional, string</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Pswarm">Pswarm</a></code> with <code>PlotIt</code>=TRUE
</p>

<hr>
<h2 id='ProjectedPoints2Grid'>
Transforms ProjectedPoints to a grid
</h2><span id='topic+ProjectedPoints2Grid'></span>

<h3>Description</h3>

<p>quantized xy cartesianncoordinates of ProjectedPoints
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ProjectedPoints2Grid(ProjectedPoints, Lines, Columns,PlotIt=FALSE, Cls)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ProjectedPoints2Grid_+3A_projectedpoints">ProjectedPoints</code></td>
<td>
<p>[1:n,1:2] numeric matrix of cartesian xy coordinates</p>
</td></tr>
<tr><td><code id="ProjectedPoints2Grid_+3A_lines">Lines</code></td>
<td>
<p>double, length of small side of the rectangular grid</p>
</td></tr>
<tr><td><code id="ProjectedPoints2Grid_+3A_columns">Columns</code></td>
<td>
<p>double, length of big side of the rectangular grid</p>
</td></tr>
<tr><td><code id="ProjectedPoints2Grid_+3A_plotit">PlotIt</code></td>
<td>
<p>optional, bool, shows the result if TRUE</p>
</td></tr>
<tr><td><code id="ProjectedPoints2Grid_+3A_cls">Cls</code></td>
<td>
<p>[1:n] numeric vector of classes for each projected point</p>
</td></tr>
</table>


<h3>Details</h3>

<p>intern function, described in [Thrun, 2018, p.47]
</p>


<h3>Value</h3>

<p>BestMatches[1:n,1:3] columns in order: Key,Lines,Columns
</p>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer, Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeneratePswarmVisualization">GeneratePswarmVisualization</a></code>
</p>

<hr>
<h2 id='Pswarm'>
A Swarm of Databots based on polar coordinates (Polar Swarm).
</h2><span id='topic+pswarmCpp'></span><span id='topic+Pswarm'></span><span id='topic+pswarm'></span>

<h3>Description</h3>

<p>This projetion method is a part of the databionic swarm which uses the nash
equlibrium [Thrun/Ultsch, 2021]. Using polar coordinates for agents (here
Databots) in two dimensions has many advantages, for further details see
[Thrun, 2018] and [Thrun/Ultsch, 2021].</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pswarm(DataOrDistance,PlotIt=FALSE,Cls=NULL,Silent=TRUE,
Debug=FALSE,LC=c(NULL,NULL),method= "euclidean",Parallel=FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pswarm_+3A_dataordistance">DataOrDistance</code></td>
<td>
<p>Numeric matrix [1:n,1:n]: symmetric matrix of
dissimilarities, if variable unsymmetric (Numeric matrix [1:d,1:n]) it is
assumed as a dataset and the euclidean distances are calculated of d variables
and n cases.</p>
</td></tr>
<tr><td><code id="Pswarm_+3A_plotit">PlotIt</code></td>
<td>
<p>Optional, bool, default=FALSE, If =TRUE, Plots the projection
during the computation prozess after every nash equlibirum.</p>
</td></tr>
<tr><td><code id="Pswarm_+3A_cls">Cls</code></td>
<td>
<p>Optional, numeric vector [1:n], given Classification in numbers, only
for plotting if PlotIt=TRUE, irrelevant for computations.</p>
</td></tr>
<tr><td><code id="Pswarm_+3A_silent">Silent</code></td>
<td>
<p>Optional, bool, default=FALSE, If =TRUE results in various console
messages</p>
</td></tr>
<tr><td><code id="Pswarm_+3A_debug">Debug</code></td>
<td>
<p>Optional, Debug, default=FALSE, =TRUE results in various console
messages, depricated for CRAN, because cout is not allowed.</p>
</td></tr>
<tr><td><code id="Pswarm_+3A_lc">LC</code></td>
<td>
<p>Optional, grid size c(Lines, Columns), sometimes it is better to call
<code><a href="#topic+setGridSize">setGridSize</a></code> separately.</p>
</td></tr>
<tr><td><code id="Pswarm_+3A_method">method</code></td>
<td>
<p>Optional, one of 39 distance methods of <code>parDist</code> of package
parallelDist,  if Data matrix is chosen above</p>
</td></tr>
<tr><td><code id="Pswarm_+3A_parallel">Parallel</code></td>
<td>
<p>Optional, =TRUE: Parallel C++ implementation, =FALSE C++ implementation</p>
</td></tr>
<tr><td><code id="Pswarm_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to the <code>parDist</code> function, e.g.
user-defined distance functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>DBS is a flexible and robust clustering framework that consists of three
independent modules. The first module is the parameter-free projection method
Pswarm <code><a href="#topic+Pswarm">Pswarm</a></code>, which exploits the concepts of self-organization
and emergence, game theory, swarm intelligence and symmetry considerations. The
second module is a parameter-free high-dimensional data visualization technique,
which generates projected points on a topographic map with hypsometric colors
<code><a href="#topic+GeneratePswarmVisualization">GeneratePswarmVisualization</a></code>, called the generalized U-matrix. The
third module is a clustering method with no sensitive parameters
<code><a href="#topic+DBSclustering">DBSclustering</a></code>. The clustering can be verified by the visualization
and vice versa. The term DBS refers to the method as a whole. </p>


<h3>Value</h3>

<p>List with
</p>
<table>
<tr><td><code>ProjectedPoints</code></td>
<td>
<p>[1:n,1:2] xy cartesian coordinates of projection</p>
</td></tr>
<tr><td><code>LC</code></td>
<td>
<p>number of Lines and Columns in c(Lines,Columns). Lines is a value slightly above the maximum of the x-coordinates and Columns is a value slightly above the maximum of the y-coordinates  of ProjectedPoints</p>
</td></tr>
<tr><td><code>Control</code></td>
<td>
<p>List, only for intern debugging</p>
</td></tr>
</table>


<h3>Note</h3>

<p>LC is now automatically estimated; LC is the size of the grid c(Lines,Columns), number of Lines and Columns, default c(NULL,NULL) and automatic calculation by <code><a href="#topic+setGridSize">setGridSize</a></code>
</p>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer, Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018. 
</p>
<p>[Thrun/Ultsch, 2021]  Thrun, M. C., and Ultsch, A.: Swarm Intelligence for Self-Organized Clustering, Artificial Intelligence, Vol. 290, pp. 103237, <a href="https://doi.org/10.1016/j.artint.2020.103237">doi:10.1016/j.artint.2020.103237</a>, 2021.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Lsun3D")
Data=Lsun3D$Data
Cls=Lsun3D$Cls
InputDistances=as.matrix(dist(Data))
#If not called separately setGridSize() is called in Pswarm
LC=setGridSize(InputDistances)
res=Pswarm(InputDistances,LC=LC,Cls=Cls,PlotIt=TRUE)


</code></pre>

<hr>
<h2 id='PswarmCurrentRadiusC2botsPositive'>
intern function, do not use yourself
</h2><span id='topic+PswarmCurrentRadiusC2botsPositive'></span>

<h3>Description</h3>

<p>Finds the weak Nash equilibirium for DataBots in one epoch(Radius), requires the
setting of constants, grid, and so on in <code><a href="#topic+Pswarm">Pswarm</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PswarmCurrentRadiusC2botsPositive( AllDataBotsPosOld, Radius, DataDists,
IndPossibleDBPosR, RadiusPositionsschablone, pp, Nullpunkt, Lines, Columns,
nBots, limit, steigungsverlaufind, StressConstAditiv, debug)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PswarmCurrentRadiusC2botsPositive_+3A_alldatabotsposold">AllDataBotsPosOld</code></td>
<td>
<p>ComplexVector [1:n,1], DataBots position in the last
Nash-Equlibriuum</p>
</td></tr>
<tr><td><code id="PswarmCurrentRadiusC2botsPositive_+3A_radius">Radius</code></td>
<td>
<p>double, Radius of payoff function, neighborhood, where other
DatsBots can be smelled</p>
</td></tr>
<tr><td><code id="PswarmCurrentRadiusC2botsPositive_+3A_datadists">DataDists</code></td>
<td>
<p>NumericMatrix, Inputdistances[1:n,1:n]</p>
</td></tr>
<tr><td><code id="PswarmCurrentRadiusC2botsPositive_+3A_indpossibledbposr">IndPossibleDBPosR</code></td>
<td>
<p>ComplexVector, see output of
<code><a href="#topic+findPossiblePositionsCsingle">findPossiblePositionsCsingle</a></code></p>
</td></tr>
<tr><td><code id="PswarmCurrentRadiusC2botsPositive_+3A_radiuspositionsschablone">RadiusPositionsschablone</code></td>
<td>
<p>NumericMatrix, see <code>AllallowedDBPosR0</code> in
<code><a href="#topic+setPolarGrid">setPolarGrid</a></code></p>
</td></tr>
<tr><td><code id="PswarmCurrentRadiusC2botsPositive_+3A_pp">pp</code></td>
<td>
<p>NumericVector, number of jumping simultaneously DataBots of one epoch
(per nash-equilibirum), this vector is linearly monotonically decreasing</p>
</td></tr>
<tr><td><code id="PswarmCurrentRadiusC2botsPositive_+3A_nullpunkt">Nullpunkt</code></td>
<td>
<p>NumericVector, equals
<code>which(AllallowedDBPosR0==0,arr.ind=T)</code>, see see <code>AllallowedDBPosR0</code>
in <code><a href="#topic+setPolarGrid">setPolarGrid</a></code></p>
</td></tr>
<tr><td><code id="PswarmCurrentRadiusC2botsPositive_+3A_lines">Lines</code></td>
<td>
<p>double, small edge length of rectangulare grid</p>
</td></tr>
<tr><td><code id="PswarmCurrentRadiusC2botsPositive_+3A_columns">Columns</code></td>
<td>
<p>double, big edge length of rectangulare grid</p>
</td></tr>
<tr><td><code id="PswarmCurrentRadiusC2botsPositive_+3A_nbots">nBots</code></td>
<td>
<p>double, intern constant, equals <code>round(pp[Radius]*DBAnzahl)</code></p>
</td></tr>
<tr><td><code id="PswarmCurrentRadiusC2botsPositive_+3A_limit">limit</code></td>
<td>
<p>int, intern constant, equals <code>ceiling(1/pp[Radius])</code></p>
</td></tr>
<tr><td><code id="PswarmCurrentRadiusC2botsPositive_+3A_steigungsverlaufind">steigungsverlaufind</code></td>
<td>
<p>int, intern constant</p>
</td></tr>
<tr><td><code id="PswarmCurrentRadiusC2botsPositive_+3A_stressconstaditiv">StressConstAditiv</code></td>
<td>
<p>double, intern constant, sum of payoff of all databots
in random condition before the algorithm starts</p>
</td></tr>
<tr><td><code id="PswarmCurrentRadiusC2botsPositive_+3A_debug">debug</code></td>
<td>
<p>optional, bool: If TRUE prints status every 100 iterations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Algorithm is described in [Thrun, 2018, p. 95, Listing 8.1].
</p>


<h3>Value</h3>

<p>list of
</p>
<table>
<tr><td><code>AllDataBotsPos</code></td>
<td>
<p>ComplexVector, indizes of DataBot Positions after a weak
Nash equlibrium is found</p>
</td></tr>
<tr><td><code>stressverlauf</code></td>
<td>
<p>NumericVector, intern result, for debugging only</p>
</td></tr>
<tr><td><code>fokussiertlaufind</code></td>
<td>
<p>NumericVector, intern result, for debugging only</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through
Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer,
Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018.</p>

<hr>
<h2 id='rDistanceToroidCsingle'>
Intern function for <code><a href="#topic+Pswarm">Pswarm</a></code>
</h2><span id='topic+rDistanceToroidCsingle'></span>

<h3>Description</h3>

<p>toroid distance calculation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rDistanceToroidCsingle(AllDataBotsPosX, AllDataBotsPosY, AllallowedDBPosR0,
Lines, Columns,  Nullpunkt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rDistanceToroidCsingle_+3A_alldatabotsposx">AllDataBotsPosX</code></td>
<td>
<p>NumericVector [1:n,1], positions of on grid</p>
</td></tr>
<tr><td><code id="rDistanceToroidCsingle_+3A_alldatabotsposy">AllDataBotsPosY</code></td>
<td>
<p>NumericVector [1:n,1], positions of on grid</p>
</td></tr>
<tr><td><code id="rDistanceToroidCsingle_+3A_allalloweddbposr0">AllallowedDBPosR0</code></td>
<td>
<p>NumericMatrix</p>
</td></tr>
<tr><td><code id="rDistanceToroidCsingle_+3A_lines">Lines</code></td>
<td>
<p>double</p>
</td></tr>
<tr><td><code id="rDistanceToroidCsingle_+3A_columns">Columns</code></td>
<td>
<p>double</p>
</td></tr>
<tr><td><code id="rDistanceToroidCsingle_+3A_nullpunkt">Nullpunkt</code></td>
<td>
<p>NumericVector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Part of the algorithm described in [Thrun, 2018, p. 95, Listing 8.1].
</p>


<h3>Value</h3>

<p>numeric matrix of toroid Distances[1:n,1:n]
</p>


<h3>Note</h3>

<p>do not use yourself</p>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through
Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer,
Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018.</p>


<h3>See Also</h3>

<p><code><a href="#topic+Pswarm">Pswarm</a></code>
</p>

<hr>
<h2 id='RelativeDifference'>
Relative Difference
</h2><span id='topic+RelativeDifference'></span>

<h3>Description</h3>

<p>Calculates the difference between positive x and y values 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RelativeDifference(X, Y, epsilon = 10^-10,na.rm=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RelativeDifference_+3A_x">X</code></td>
<td>
<p>either a value or numerical vector of [1:n]</p>
</td></tr>
<tr><td><code id="RelativeDifference_+3A_y">Y</code></td>
<td>
<p>either a value or numerical vector of [1:n]</p>
</td></tr>
<tr><td><code id="RelativeDifference_+3A_epsilon">epsilon</code></td>
<td>
<p>Optional, If both x and y are approximatly zero the output is
also zero</p>
</td></tr>
<tr><td><code id="RelativeDifference_+3A_na.rm">na.rm</code></td>
<td>
<p>Optional, function does not work with non finite values. If these
cases should be automatically removed, set parameter TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Contrary to other approaches in this cases the range of values lies between
[-2,2]. The approach is only valid for positive values of<code>X</code> and <code>Y</code>.
The realtive difference <code>R</code> is defined with </p>
<p style="text-align: center;"><code class="reqn">R=\frac{Y-X}{0.5*(X+Y)}</code>
</p>

<p>Negative value indicate that <code>X</code>  is higher than <code>Y</code> and positive
values that <code>X</code> is lower than <code>Y</code>.
</p>


<h3>Value</h3>

<p>R</p>


<h3>Note</h3>

<p>It can be combined with the <code>GabrielClassificationError</code> if a clear baseline is defined.
</p>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>Ultsch, A.: Is Log Ratio a Good Value for Measuring Return in Stock Investments?
GfKl 2008, pp, 505-511, 2008.
</p>


<h3>See Also</h3>

<p><code><a href="DRquality.html#topic+GabrielClassificationError">GabrielClassificationError</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=c(1:5)
y=runif(5,min=1,max=10)
RelativeDifference(x,y)
</code></pre>

<hr>
<h2 id='sESOM4BMUs'>
Intern function: Simplified Emergent Self-Organizing Map
</h2><span id='topic+sESOM4BMUs'></span>

<h3>Description</h3>

<p>Intern function for the simplified ESOM (sESOM) algorithm for fixed
BestMatchingUnits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sESOM4BMUs(BMUs,Data, esom, toroid, CurrentRadius,

ComputeInR=FALSE,Parallel=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sESOM4BMUs_+3A_bmus">BMUs</code></td>
<td>
<p>[1:Lines,1:Columns], BestMAtchingUnits generated by
ProjectedPoints2Grid()</p>
</td></tr>
<tr><td><code id="sESOM4BMUs_+3A_data">Data</code></td>
<td>
<p>[1:n,1:d] array of data: n cases in rows, d variables in columns</p>
</td></tr>
<tr><td><code id="sESOM4BMUs_+3A_esom">esom</code></td>
<td>
<p>[1:Lines,1:Columns,1:weights] array of NeuronWeights, see
ListAsEsomNeurons()</p>
</td></tr>
<tr><td><code id="sESOM4BMUs_+3A_toroid">toroid</code></td>
<td>
<p>TRUE/FALSE - topology of points</p>
</td></tr>
<tr><td><code id="sESOM4BMUs_+3A_currentradius">CurrentRadius</code></td>
<td>
<p>number betweeen 1 to x</p>
</td></tr>
<tr><td><code id="sESOM4BMUs_+3A_computeinr">ComputeInR</code></td>
<td>
<p>=TRUE: Rcode, =FALSE: Cpp</p>
</td></tr>
<tr><td><code id="sESOM4BMUs_+3A_parallel">Parallel</code></td>
<td>
<p>Optional, =TRUE: Parallel C++ implementation, =FALSE C++ implementation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Algorithm is described in [Thrun, 2018, p. 48, Listing 5.1].
</p>


<h3>Value</h3>

<table>
<tr><td><code>esom</code></td>
<td>
<p>numeric array [1:Lines,1:Columns,1:d], d is the dimension of the
weights, the same as in the ESOM algorithm. modified esomneuros regarding a
predefined neighborhood defined by a radius</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Usually not for seperated usage!</p>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through
Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer,
Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeneratePswarmVisualization">GeneratePswarmVisualization</a></code>
</p>

<hr>
<h2 id='setdiffMatrix'>setdiffMatrix shortens Matrix2Curt by those rows that are in both
matrices.</h2><span id='topic+setdiffMatrix'></span>

<h3>Description</h3>

<p>setdiffMatrix shortens Matrix2Curt by those rows that are in both matrices.</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="setdiffMatrix_+3A_matrix2curt">Matrix2Curt</code></td>
<td>
<p>[n,k] matrix, which will be shortened by x rows</p>
</td></tr>
<tr><td><code id="setdiffMatrix_+3A_matrix2compare">Matrix2compare</code></td>
<td>
<p>[m,k] matrix whose rows will be compared to those of
Matrix2Curt x rows in Matrix2compare equal rows of Matrix2Curt (order of rows is
irrelevant). Has the same number of columns as Matrix2Curt.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>V$CurtedMatrix[n-x,k] Shortened Matrix2Curt</p>


<h3>Author(s)</h3>

<p>CL,MT 12/2014</p>

<hr>
<h2 id='setGridSize'>
Sets the grid size for the Pswarm algorithm
</h2><span id='topic+setGridSize'></span>

<h3>Description</h3>

<p>Automatically sets the size of the grid, formula see [Thrun, 2018, p. 93-94].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setGridSize(InputDistances,minp=0.01,maxp=0.99,alpha=4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setGridSize_+3A_inputdistances">InputDistances</code></td>
<td>
<p> [1:n,1:n] symmetric matrix of input distances</p>
</td></tr>
<tr><td><code id="setGridSize_+3A_minp">minp</code></td>
<td>
<p>default value: 0.01,see <code><a href="stats.html#topic+quantile">quantile</a></code>, first value in the
vector of <code>probs</code> estimates robust minimum of distances</p>
</td></tr>
<tr><td><code id="setGridSize_+3A_maxp">maxp</code></td>
<td>
<p>default value: 0.99, see <code><a href="stats.html#topic+quantile">quantile</a></code>, last value of the
vector of <code>probs</code> estimates robust maximum of distances</p>
</td></tr>
<tr><td><code id="setGridSize_+3A_alpha">alpha</code></td>
<td>

<p>Do not change! Intern parameter, Only if Java Version of Pswarm instead of C++
version is used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>grid is set such that minimum and maximum distances can be shown on the grid</p>


<h3>Value</h3>

<p>LC=c(Lines,Columns) size of the grid for <code>Pswarm</code>
</p>


<h3>Author(s)</h3>

<p>Michael Thrun, Florian Lerch
</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through
Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer,
Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018. 
</p>


<h3>See Also</h3>

<p>automatic choice of LC for <code><a href="#topic+Pswarm">Pswarm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Lsun3D")
Data=Lsun3D$Data
Cls=Lsun3D$Cls
InputDistances=as.matrix(dist(Data))
#If not called separately setGridSize() is called in Pswarm
LC=setGridSize(InputDistances)
</code></pre>

<hr>
<h2 id='setPolarGrid'>
Intern function: Sets the polar grid
</h2><span id='topic+setPolarGrid'></span>

<h3>Description</h3>

<p>Sets a polar grid for a swarm in an rectangular shape
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setPolarGrid(Lines,Columns,QuadOrHexa,PlotIt,global)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setPolarGrid_+3A_lines">Lines</code></td>
<td>
<p>Integer, hast to be able to be divided by 2</p>
</td></tr>
<tr><td><code id="setPolarGrid_+3A_columns">Columns</code></td>
<td>
<p>Integer, with Columns&gt;=Lines</p>
</td></tr>
<tr><td><code id="setPolarGrid_+3A_quadorhexa">QuadOrHexa</code></td>
<td>
<p>bool, default(TRUE) If False Hexagonal grid, default quad
grid</p>
</td></tr>
<tr><td><code id="setPolarGrid_+3A_plotit">PlotIt</code></td>
<td>
<p>bool, default(FALSE)</p>
</td></tr>
<tr><td><code id="setPolarGrid_+3A_global">global</code></td>
<td>
<p>bool,  default(TRUE), intern parameter, how shall the radii be
calculated?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Part of the Algorithm described in [Thrun, 2018, p. 95, Listing 8.1].
</p>


<h3>Value</h3>

<p>list of 
</p>
<table>
<tr><td><code>GridRadii</code></td>
<td>
<p>matrix [1:Lines,1:Columns], Radii Matrix of all possible
Positions of DataBots in Grid</p>
</td></tr>
<tr><td><code>GridAngle</code></td>
<td>
<p>matrix [1:Lines,1:Columns], Angle Matrix of all possible
Positions of DataBots in Grid</p>
</td></tr>
<tr><td><code>AllallowedDBPosR0</code></td>
<td>
<p>matrix [1:Lines+1,1:Columns+1],  Matrix of radii in
polar coordinates respecting origin (0,0) of all allowed DataBots Positions
in one jump</p>
</td></tr>
<tr><td><code>AllallowedDBPosPhi0</code></td>
<td>
<p>matrix [1:Lines+1,1:Columns+1], 
# V$AllallowedDBPosPhi0[Lines+1,Lines+1] Matrix of angle in polar
coordinates respecting origin (0,0) of all allowed DataBots Positions in one jump</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through
Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer,
Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Pswarm">Pswarm</a></code>
</p>

<hr>
<h2 id='setRmin'>Intern function: Estimates the minimal radius for the Databot scent</h2><span id='topic+setRmin'></span>

<h3>Description</h3>

<p>estimates the minimal radius on apolar grid in the automated annealing process
of Pswarm, details of how can be read in [Thrun, 2018, p. 97]</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="setRmin_+3A_lines">Lines</code></td>
<td>
<p>x-value determining the size of the map, i.e. how many open places
for DataBots will be available  on the 2-dimensional grid BEWARE: has to be able
to be divided by 2</p>
</td></tr>
<tr><td><code id="setRmin_+3A_columns">Columns</code></td>
<td>
<p>y-value  determining the size of the map, i.e. how many open
places for DataBots will be available on the 2-dimensional grid Columns&gt;Lines</p>
</td></tr>
<tr><td><code id="setRmin_+3A_allalloweddbposr0">AllallowedDBPosR0</code></td>
<td>
<p>[1:Lines+1,1:Lines+1]Matrix of radii in polar
coordinates respecting origin (0,0) of all allowed DataBots Positions in one jump</p>
</td></tr>
<tr><td><code id="setRmin_+3A_p">p</code></td>
<td>
<p>percent of gitterpositions, which should be considered</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Rmin Minimum Radius</p>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through
Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer,
Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018. 
</p>

<hr>
<h2 id='ShortestGraphPathsC'>
Shortest GraphPaths = geodesic distances
</h2><span id='topic+ShortestGraphPathsC'></span>

<h3>Description</h3>

<p>Dijkstra's SSSP (Single source shortest path) algorithm, from all points to all
points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ShortestGraphPathsC(Adj, Cost)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ShortestGraphPathsC_+3A_adj">Adj</code></td>
<td>
<p>[1:n,1:n] 0/1 adjascency matrix, e.g. from delaunay graph or gabriel
graph.</p>
</td></tr>
<tr><td><code id="ShortestGraphPathsC_+3A_cost">Cost</code></td>
<td>
<p>[1:n,1:n] matrix, distances between n points (normally euclidean)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vertices are the points, edges have the costs defined by weights (normally a
distance).
The algorithm runs in runs in O(n*E*Log(V)), see also [Jungnickel, 2013, p. 87].
Further details can be foubd in 
[Jungnickel, 2013, p. 83-87] and [Thrun, 2018, p. 12].
</p>


<h3>Value</h3>

<p>ShortestPaths[1:n,1:n]   
vector, shortest paths (geodesic) to all other vertices including the source
vertice itself
from al vertices to all vertices, stored as a matrix
</p>


<h3>Note</h3>

<p>require C++11 standard (set flag in Compiler, if not set automatically)
</p>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>[Dijkstra,1959]	Dijkstra, E. W.: A note on two problems in connexion with
graphs, Numerische mathematik, Vol. 1(1), pp. 269-271. 1959.
</p>
<p>[Jungnickel, 2013]	Jungnickel, D.: Graphs, networks and algorithms,
(4th ed ed. Vol. 5), Berlin, Heidelberg, Germany, Springer, ISBN:
978-3-642-32278-5, 2013.
</p>
<p>[Thrun/Ultsch, 2017]	Thrun, M.C., Ultsch, A.: Projection based Clustering,
Conf. Int. Federation of Classification Societies
(IFCS),DOI:10.13140/RG.2.2.13124.53124, Tokyo, 2017.
</p>
<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through
Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer,
Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DijkstraSSSP">DijkstraSSSP</a></code>
</p>

<hr>
<h2 id='trainstepC'>
Internal function for sESOM
</h2><span id='topic+trainstepC'></span>

<h3>Description</h3>

<p>Does the training for fixed bestmatches in one epoch of the sESOM algorithm (see [Thrun, 2018] for details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trainstepC(vx,vy, DataSampled,BMUsampled,Lines,Columns, Radius, toroid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trainstepC_+3A_vx">vx</code></td>
<td>
<p>array [1:Lines,1:Columns,1:Weights], WeightVectors that will be
trained, internally transformed von NumericVector to cube</p>
</td></tr>
<tr><td><code id="trainstepC_+3A_vy">vy</code></td>
<td>
<p>array [1:Lines,1:Columns,1:2], meshgrid for output distance
computation</p>
</td></tr>
<tr><td><code id="trainstepC_+3A_datasampled">DataSampled</code></td>
<td>
<p>NumericMatrix, n cases shuffled Dataset[1:n,1:d] by
<code>sample</code> </p>
</td></tr>
<tr><td><code id="trainstepC_+3A_bmusampled">BMUsampled</code></td>
<td>
<p>NumericMatrix, n cases shuffled BestMatches[1:n,1:2] by
<code>sample</code> in the same way as <code>DataSampled</code></p>
</td></tr>
<tr><td><code id="trainstepC_+3A_lines">Lines</code></td>
<td>
<p>double, Height of the grid</p>
</td></tr>
<tr><td><code id="trainstepC_+3A_columns">Columns</code></td>
<td>
<p>double, Width of the grid</p>
</td></tr>
<tr><td><code id="trainstepC_+3A_radius">Radius</code></td>
<td>
<p>double, The current Radius that should be used to define
neighbours to the bm</p>
</td></tr>
<tr><td><code id="trainstepC_+3A_toroid">toroid</code></td>
<td>
<p>bool, Should the grid be considered with cyclically connected
borders?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Algorithm is described in [Thrun, 2018, p. 48, Listing 5.1].
</p>


<h3>Value</h3>

<p>WeightVectors, array[1:Lines,1:Columns,1:weights] with the adjusted Weights</p>


<h3>Note</h3>

<p>Usually not for seperated usage!</p>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>[Thrun, 2018]  Thrun, M. C.: Projection Based Clustering through Self-Organization and Swarm Intelligence, doctoral dissertation 2017, Springer, Heidelberg, ISBN: 978-3-658-20539-3, <a href="https://doi.org/10.1007/978-3-658-20540-9">doi:10.1007/978-3-658-20540-9</a>, 2018. 
</p>

<hr>
<h2 id='UniquePoints'>Unique Points</h2><span id='topic+UniquePoints'></span>

<h3>Description</h3>

<p>return only the unique points in Datapoints
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UniquePoints(Datapoints, Cls, Eps=1e-10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UniquePoints_+3A_datapoints">Datapoints</code></td>
<td>
<p>[1:n,1:d] numeric matrix of Datapoints points of dimension d, the
points are in the  rows</p>
</td></tr>
<tr><td><code id="UniquePoints_+3A_cls">Cls</code></td>
<td>
<p>[1:n] numeric vector of classes for each datapoint.</p>
</td></tr>
<tr><td><code id="UniquePoints_+3A_eps">Eps</code></td>
<td>
<p>Optional,scalar above zero that defines minimum non-identical
euclidean distance between two points</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Euclidean distance is computed and used within. Setting <code>Eps</code> to a very small number results in the identification of unique data points. Setting epsilon to a higher number results in the definition of mesh points within an d-dimensional R-ball graph.
</p>


<h3>Value</h3>

<p>List with
</p>
<table>
<tr><td><code>Unique</code></td>
<td>
<p>[1:k,1:d] Datapoints points  without duplicate points</p>
</td></tr>
<tr><td><code>UniqueInd</code></td>
<td>
<p>[1:k] index vector such that Unique ==  Datapoints[UniqueInd,],
it has k non-consecutive numbers or labels, each label defines a row number
within Datapoints[1:n,1:d] of a unique data point</p>
</td></tr>
<tr><td><code>Uniq2DatapointsInd</code></td>
<td>
<p> [1:n] index vector. It has k unique index numbers
representing the arbitrary labels. Each labels is mapped uniquely to a point in
<code>Unique</code>. Logically in a way such that
Datapoints ==  Unique[Uniq2DatapointsInd,] (will not work directly in R this
way)</p>
</td></tr>
<tr><td><code>NewUniqueInd</code></td>
<td>
<p>[1:k] index vector stating the index of the newly defined
datastructure Unique.</p>
</td></tr>
<tr><td><code>NewUniq2DataIdx</code></td>
<td>
<p>[1:k] index vector such that
Unique[NewUniq2DataIdx,] ==  Datapoints[Uniq2DatapointsInd,], it has n
non-consecutive numbers or labels, each label defines a row number within
Unique[1:k,1:d] of a unique data point</p>
</td></tr>
<tr><td><code>IsDuplicate</code></td>
<td>
<p>[1:n,1:n] matrix,for i!=j IsDuplicate[i,j]== 1
if Datapoints[i,] == Datapoints[j,]    IsDuplicate[i,i]==0</p>
</td></tr>
<tr><td><code>Eps</code></td>
<td>
<p>Numeric stating the neighborhood radius around unique points.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Datapoints  = rbind(c(0,0), c(1,1), c(2,2))
Datapoints2 = rbind(Datapoints, Datapoints+0.001)
Datapoints3 = rbind(Datapoints2, c(1,1)-0.001)

Datapoints  = rbind(c(0,0), c(0,0.015), c(0,0.01), c(0,0.015))

V1 = UniquePoints(Datapoints = Datapoints, Eps = 0.01)
V2 = UniquePoints(Datapoints = Datapoints2, Eps = 0.01)
V3 = UniquePoints(Datapoints = Datapoints3, Eps = 0.01)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
