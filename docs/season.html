<!DOCTYPE html><html><head><title>Help for package season</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {season}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aaft'><p>Amplitude Adjusted Fourier Transform (AAFT)</p></a></li>
<li><a href='#AFL'><p>Australian Football League (AFL) Players' Birthdays for the 2009 Season</p></a></li>
<li><a href='#casecross'><p>Case&ndash;crossover Analysis to Control for Seasonality</p></a></li>
<li><a href='#ciPhase'><p>Mean and Confidence Interval for Circular Phase</p></a></li>
<li><a href='#cipolygon'><p>Function to Draw CI Polygon</p></a></li>
<li><a href='#cosinor'><p>Cosinor Regression Model for Detecting Seasonality in Yearly Data or</p>
Circadian Patterns in Hourly Data</a></li>
<li><a href='#createAdj'><p>Creates an Adjacency Matrix</p></a></li>
<li><a href='#CVD'><p>Cardiovascular Deaths in Los Angeles, 1987&ndash;2000</p></a></li>
<li><a href='#CVDdaily'><p>Daily Cardiovascular Deaths in Los Angeles, 1987&ndash;2000</p></a></li>
<li><a href='#exercise'><p>Exercise Data from Queensland, 2005&ndash;2007</p></a></li>
<li><a href='#flagleap'><p>Count the Number of Days in the Month</p></a></li>
<li><a href='#indoor'><p>Indoor Temperature Data</p></a></li>
<li><a href='#invyrfraction'><p>Inverse Fraction of the Year or Hour</p></a></li>
<li><a href='#kalfil'><p>Forward and Backward Sweep of the Kalman Filter</p></a></li>
<li><a href='#monthglm'><p>Fit a GLM with Month</p></a></li>
<li><a href='#monthmean'><p>Monthly Means</p></a></li>
<li><a href='#nochars'><p>Remove Letters and Characters from a String</p></a></li>
<li><a href='#nonlintest'><p>Test of Non-linearity of a Time Series</p></a></li>
<li><a href='#nscosinor'><p>Non-stationary Cosinor</p></a></li>
<li><a href='#nscosinor.initial'><p>Initial Values for Non-stationary Cosinor</p></a></li>
<li><a href='#peri'><p>Periodogram</p></a></li>
<li><a href='#phasecalc'><p>Phase from Cosinor Estimates</p></a></li>
<li><a href='#plot.Cosinor'><p>Plot the Results of a Cosinor</p></a></li>
<li><a href='#plot.monthglm'><p>Plot of Monthly Estimates</p></a></li>
<li><a href='#plot.Monthmean'><p>Plot of Monthly Mean Estimates</p></a></li>
<li><a href='#plot.nonlintest'><p>Plot the Results of the Non-linear Test</p></a></li>
<li><a href='#plot.nsCosinor'><p>Plot the Results of a Non-stationary Cosinor</p></a></li>
<li><a href='#plotCircle'><p>Circular Plot</p></a></li>
<li><a href='#plotCircular'><p>Circular Plot Using Segments</p></a></li>
<li><a href='#plotMonth'><p>Plot Results by Month</p></a></li>
<li><a href='#print.casecross'><p>Print the Results of a Case-Crossover Model</p></a></li>
<li><a href='#print.Cosinor'><p>Print the Results of a Cosinor</p></a></li>
<li><a href='#print.monthglm'><p>Print <code>monthglm</code></p></a></li>
<li><a href='#print.Monthmean'><p>Print the Results from Monthmean</p></a></li>
<li><a href='#print.nonlintest'><p>Print the Results of the Non-linear Test</p></a></li>
<li><a href='#print.nsCosinor'><p>Print the Results of a Non-stationary Cosinor</p></a></li>
<li><a href='#print.summary.Cosinor'><p>printing a summary of a Cosinor</p></a></li>
<li><a href='#print.summary.monthglm'><p>printing a summary of a month.glm</p></a></li>
<li><a href='#print.summary.nscosinor'><p>printing a summary of an nscosinor</p></a></li>
<li><a href='#rinvgamma'><p>Random Inverse Gamma Distribution</p></a></li>
<li><a href='#schz'><p>Schizophrenia Births in Australia, 1930&ndash;1971</p></a></li>
<li><a href='#season-package'><p>season: Tools for Uncovering and Estimating Seasonal Patterns.</p></a></li>
<li><a href='#seasrescheck'><p>Seasonal Residual Checks</p></a></li>
<li><a href='#sinusoid'><p>Plot a Sinusoid</p></a></li>
<li><a href='#stillbirth'><p>Stillbirths in Queensland, 1998&ndash;2000</p></a></li>
<li><a href='#summary.casecross'><p>Summary of the Results of a Case-crossover Model</p></a></li>
<li><a href='#summary.Cosinor'><p>Summary for a Cosinor</p></a></li>
<li><a href='#summary.monthglm'><p>Summary for a Monthglm</p></a></li>
<li><a href='#summary.nsCosinor'><p>Summary for a Non-stationary Cosinor</p></a></li>
<li><a href='#third'><p>Third-order Moment</p></a></li>
<li><a href='#wtest'><p>Walter and Elwood's Test of Seasonality</p></a></li>
<li><a href='#yrfraction'><p>Fraction of the Year</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Seasonal Analysis of Health Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.15</td>
</tr>
<tr>
<td>Author:</td>
<td>Adrian Barnett and Peter Baker and Oliver Hughes</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adrian Barnett &lt;a.barnett@qut.edu.au&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.1), ggplot2 (&ge; 0.9.3), MASS, survival</td>
</tr>
<tr>
<td>Description:</td>
<td>Routines for the seasonal analysis of health data, including regression models, time-stratified case-crossover, plotting functions and residual checks, see Barnett and Dobson (2010) ISBN 978-3-642-10748-1. Thanks to Yuming Guo for checking the case-crossover code. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, mgcv, dlnm, coda, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-20 06:54:30 UTC; barnetta</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-21 08:30:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='aaft'>Amplitude Adjusted Fourier Transform (AAFT)</h2><span id='topic+aaft'></span>

<h3>Description</h3>

<p>Generates random linear surrogate data of a time series with the same
second-order properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aaft(data, nsur)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aaft_+3A_data">data</code></td>
<td>
<p>a vector of equally spaced numeric observations (time series).</p>
</td></tr>
<tr><td><code id="aaft_+3A_nsur">nsur</code></td>
<td>
<p>the number of surrogates to generate (1 or more).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The AAFT uses phase-scrambling to create a surrogate of the time series that
has a similar spectrum (and hence similar second-order statistics). The AAFT
is useful for testing for non-linearity in a time series, and is used by
<code>nonlintest</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>surrogates</code></td>
<td>
<p>a matrix of the <code>nsur</code> surrogates.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>References</h3>

<p>Kugiumtzis D (2000) Surrogate data test for nonlinearity
including monotonic transformations, <em>Phys. Rev. E</em>, vol 62
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(CVD)
surr = aaft(CVD$cvd, nsur=1)
plot(CVD$cvd, type='l')
lines(surr[,1], col='red')


</code></pre>

<hr>
<h2 id='AFL'>Australian Football League (AFL) Players' Birthdays for the 2009 Season</h2><span id='topic+AFL'></span>

<h3>Description</h3>

<p>The data are: a) the monthly frequencies of birthdays and an expected number
based on monthly birth statistics for 1975 to 1991. b) all 617 players'
initials and birthdays (excluding non-Australian born players).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AFL
</code></pre>


<h3>Format</h3>

<p>A list with the following 5 variables. 
</p>

<dl>
<dt>month</dt><dd><p>integer month (1 to 12)</p>
</dd> <dt>players</dt><dd><p>number
of players born in each month (12 observations)</p>
</dd>
<dt>expected</dt><dd><p>expected number of players born in each month (12
observations)</p>
</dd> <dt>initials</dt><dd><p>player initials (617 observations)</p>
</dd>
<dt>dob</dt><dd><p>date of birth in date format (617 observations;
year-month-day format)</p>
</dd> </dl>



<h3>Source</h3>

<p>Dates of birth from Wikipedia.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(AFL)
barplot(AFL$players, names.arg=month.abb)


</code></pre>

<hr>
<h2 id='casecross'>Case&ndash;crossover Analysis to Control for Seasonality</h2><span id='topic+casecross'></span>

<h3>Description</h3>

<p>Fits a time-stratified case&ndash;crossover to regularly spaced time series data.
The function is not suitable for irregularly spaced individual data. The
function only uses a time-stratified design, and other designs such as the
symmetric bi-directional design, are not available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>casecross(
  formula,
  data,
  exclusion = 2,
  stratalength = 28,
  matchdow = FALSE,
  usefinalwindow = FALSE,
  matchconf = "",
  confrange = 0,
  stratamonth = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="casecross_+3A_formula">formula</code></td>
<td>
<p>formula. The dependent variable should be an integer count
(e.g., daily number of deaths).</p>
</td></tr>
<tr><td><code id="casecross_+3A_data">data</code></td>
<td>
<p>data set as a data frame.</p>
</td></tr>
<tr><td><code id="casecross_+3A_exclusion">exclusion</code></td>
<td>
<p>exclusion period (in days) around cases, set to 2
(default). Must be greater than or equal to zero and smaller than
<code>stratalength</code>.</p>
</td></tr>
<tr><td><code id="casecross_+3A_stratalength">stratalength</code></td>
<td>
<p>length of stratum in days, set to 28 (default).</p>
</td></tr>
<tr><td><code id="casecross_+3A_matchdow">matchdow</code></td>
<td>
<p>match case and control days using day of the week
(TRUE/default=FALSE). This matching is in addition to the strata matching.</p>
</td></tr>
<tr><td><code id="casecross_+3A_usefinalwindow">usefinalwindow</code></td>
<td>
<p>use the last stratum in the time series, which is
likely to contain less days than all the other strata (TRUE/default=FALSE).</p>
</td></tr>
<tr><td><code id="casecross_+3A_matchconf">matchconf</code></td>
<td>
<p>match case and control days using an important confounder
(optional; must be in quotes). <code>matchconf</code> is the variable to match on.
This matching is in addition to the strata matching.</p>
</td></tr>
<tr><td><code id="casecross_+3A_confrange">confrange</code></td>
<td>
<p>range of the confounder within which case and control days
will be treated as a match (optional). Range = <code>matchconf</code> (on case
day) <code class="reqn">+/-</code> <code>confrange</code>.</p>
</td></tr>
<tr><td><code id="casecross_+3A_stratamonth">stratamonth</code></td>
<td>
<p>use strata based on months, default=FALSE. Instead of a
fixed strata size when using <code>stratalength</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The case&ndash;crossover method compares &ldquo;case&rdquo; days when events occurred
(e.g., deaths) with control days to look for differences in exposure that
might explain differences in the number of cases. Control days are selected
to be nearby to case days, which means that only recent changes in the
independent variable(s) are compared. By only comparing recent values, any
long-term or seasonal variation in the dependent and independent variable(s)
can be eliminated. This elimination depends on the definition of nearby and
on the seasonal and long-term patterns in the independent variable(s).
</p>
<p>Control and case days are only compared if they are in the same stratum. The
stratum is controlled by <code>stratalength</code>, the default value is 28 days,
so that cases and controls are compared in four week sections.  Smaller
stratum lengths provide a closer control for season, but reduce the
available number of controls.  Control days that are close to the case day
may have similar levels of the independent variable(s). To reduce this
correlation it is possible to place an <code>exclusion</code> around the cases.
The default is 2, which means that the smallest gap between a case and
control will be 3 days.
</p>
<p>To remove any confounding by day of the week it is possible to additionally
match by day of the week (<code>matchdow</code>), although this usually reduces
the number of available controls. This matching is in addition to the strata
matching.
</p>
<p>It is possible to additionally match case and control days by an important
confounder (<code>matchconf</code>) in order to remove its effect. Control days
are matched to case days if they are: i) in the same strata, ii) have the
same day of the week if <code>matchdow=TRUE</code>, iii) have a value of
<code>matchconf</code> that is within plus/minus <code>confrange</code> of the value of
<code>matchconf</code> on the case day. If the range is set too narrow then the
number of available controls will become too small, which in turn means the
number of case days with at least one control day is compromised.
</p>
<p>The method uses conditional logistic regression (see <code><a href="survival.html#topic+coxph">coxph</a></code> and
so the parameter estimates are odds ratios.)
</p>
<p>The code assumes that the data frame contains a date variable (in
<code><a href="base.html#topic+Date">Date</a></code> format) called &lsquo;date&rsquo;.
</p>


<h3>Value</h3>

<table>
<tr><td><code>call</code></td>
<td>
<p>the original call to the casecross function.</p>
</td></tr>
<tr><td><code>c.model</code></td>
<td>
<p>conditional logistic regression model of class <code>coxph</code>.</p>
</td></tr>
<tr><td><code>ncases</code></td>
<td>
<p>total number of cases.</p>
</td></tr> <tr><td><code>ncasedays</code></td>
<td>
<p>number of case days
with at least one control day.</p>
</td></tr> <tr><td><code>ncontroldayss</code></td>
<td>
<p>average number of
control days per case day.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>References</h3>

<p>Janes, H., Sheppard, L., Lumley, T. (2005) Case-crossover
analyses of air pollution exposure data: Referent selection strategies and
their implications for bias. <em>Epidemiology</em> 16(6), 717&ndash;726.
</p>
<p>Barnett, A.G., Dobson, A.J. (2010) <em>Analysing Seasonal Health Data</em>.
Springer.
</p>


<h3>See Also</h3>

<p><code>summary.casecross</code>, <code>coxph</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># cardiovascular disease data
data(CVDdaily)
CVDdaily = subset(CVDdaily, date&lt;=as.Date('1987-12-31')) # subset for example
# Effect of ozone on CVD death
model1 = casecross(cvd ~ o3mean+tmpd+Mon+Tue+Wed+Thu+Fri+Sat, data=CVDdaily)
summary(model1)
# match on day of the week
model2 = casecross(cvd ~ o3mean+tmpd, matchdow=TRUE, data=CVDdaily)
summary(model2)
# match on temperature to within a degree
model3 = casecross(cvd ~ o3mean+Mon+Tue+Wed+Thu+Fri+Sat, data=CVDdaily,
                   matchconf='tmpd', confrange=1)
summary(model3)


</code></pre>

<hr>
<h2 id='ciPhase'>Mean and Confidence Interval for Circular Phase</h2><span id='topic+ciPhase'></span>

<h3>Description</h3>

<p>Calculates the mean and confidence interval for the phase based on a chain
of MCMC samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ciPhase(theta, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ciPhase_+3A_theta">theta</code></td>
<td>
<p>chain of Markov chain Monte Carlo (MCMC) samples of the phase.</p>
</td></tr>
<tr><td><code id="ciPhase_+3A_alpha">alpha</code></td>
<td>
<p>the confidence level (default = 0.05 for a 95% confidence
interval).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimates of the phase are rotated to have a centre of <code class="reqn">\pi</code>, the
point on the circumference of a unit radius circle that is furthest from
zero. The mean and confidence interval are calculated on the rotated values,
then the estimates are rotated back.
</p>


<h3>Value</h3>

<table>
<tr><td><code>mean</code></td>
<td>
<p>the estimated mean phase.</p>
</td></tr> <tr><td><code>lower</code></td>
<td>
<p>the estimated
lower limit of the confidence interval.</p>
</td></tr> <tr><td><code>upper</code></td>
<td>
<p>the estimated upper
limit of the confidence interval.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>References</h3>

<p>Fisher, N. (1993) <em>Statistical Analysis of Circular Data</em>.
Cambridge University Press. Page 36.
</p>
<p>Barnett, A.G., Dobson, A.J. (2010) <em>Analysing Seasonal Health Data</em>.
Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
theta = rnorm(n=2000, mean=0, sd=pi/50) # 2000 normal samples, centred on zero
hist(theta, breaks=seq(-pi/8, pi/8, pi/30))
ciPhase(theta)


</code></pre>

<hr>
<h2 id='cipolygon'>Function to Draw CI Polygon</h2><span id='topic+cipolygon'></span>

<h3>Description</h3>

<p>Internal function to draw a confidence interval for multiple times as a grey
area. For internal use only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cipolygon(time, lower, upper)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cipolygon_+3A_time">time</code></td>
<td>
<p>x-axis.</p>
</td></tr>
<tr><td><code id="cipolygon_+3A_lower">lower</code></td>
<td>
<p>lower limit of the confidence level.</p>
</td></tr>
<tr><td><code id="cipolygon_+3A_upper">upper</code></td>
<td>
<p>upper limit of the confidence level.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>

<hr>
<h2 id='cosinor'>Cosinor Regression Model for Detecting Seasonality in Yearly Data or
Circadian Patterns in Hourly Data</h2><span id='topic+cosinor'></span>

<h3>Description</h3>

<p>Fits a cosinor model as part of a generalized linear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cosinor(
  formula,
  date,
  data,
  family = gaussian(),
  alpha = 0.05,
  cycles = 1,
  rescheck = FALSE,
  type = "daily",
  offsetmonth = FALSE,
  offsetpop = NULL,
  text = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cosinor_+3A_formula">formula</code></td>
<td>
<p>regression formula.</p>
</td></tr>
<tr><td><code id="cosinor_+3A_date">date</code></td>
<td>
<p>a date variable if type=&ldquo;daily&rdquo;, or an integer between 1
and 53 if type=&ldquo;weekly&rdquo;, or an integer between 1 and 12 if
type=&ldquo;monthly&rdquo;, or a <a href="base.html#topic+POSIXct">POSIXct</a> date if type=&ldquo;hourly&rdquo;.</p>
</td></tr>
<tr><td><code id="cosinor_+3A_data">data</code></td>
<td>
<p>data set as a data frame.</p>
</td></tr>
<tr><td><code id="cosinor_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to
be used in the model. Available link functions: identity, log, logit,
cloglog. Note, it must have the parentheses.</p>
</td></tr>
<tr><td><code id="cosinor_+3A_alpha">alpha</code></td>
<td>
<p>significance level, set to 0.05 (default).</p>
</td></tr>
<tr><td><code id="cosinor_+3A_cycles">cycles</code></td>
<td>
<p>number of seasonal cycles per year if type=&ldquo;daily&rdquo;,
&ldquo;weekly&rdquo; or &ldquo;monthly&rdquo;; number of cycles per 24 hours if
type=&ldquo;hourly&rdquo;</p>
</td></tr>
<tr><td><code id="cosinor_+3A_rescheck">rescheck</code></td>
<td>
<p>plot the residual checks (TRUE/FALSE), see
<code><a href="#topic+seasrescheck">seasrescheck</a></code>.</p>
</td></tr>
<tr><td><code id="cosinor_+3A_type">type</code></td>
<td>
<p>&ldquo;daily&rdquo; for daily data (default), or &ldquo;weekly&rdquo; for
weekly data, or &ldquo;monthly&rdquo; for monthly data, or &ldquo;hourly&rdquo; for
hourly data.</p>
</td></tr>
<tr><td><code id="cosinor_+3A_offsetmonth">offsetmonth</code></td>
<td>
<p>include an offset to account for the uneven number of
days in the month (TRUE/FALSE). Should be used for monthly counts
(type=&ldquo;monthly&rdquo;) (with <code>family=poisson()</code>).</p>
</td></tr>
<tr><td><code id="cosinor_+3A_offsetpop">offsetpop</code></td>
<td>
<p>include an offset for the population (optional), this
should be a variable in the data frame. Do not log-transform this offset, as
the transform is applied by the code.</p>
</td></tr>
<tr><td><code id="cosinor_+3A_text">text</code></td>
<td>
<p>add explanatory text to the returned phase value (TRUE) or
return a number (FALSE). Passed to the <code>invyrfraction</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cosinor model captures a seasonal pattern using a sinusoid. It is
therefore suitable for relatively simple seasonal patterns that are
symmetric and stationary. The default is to fit an annual seasonal pattern
(<code>cycle</code>=1), but other higher frequencies are possible (e.g., twice per
year: <code>cycle</code>=2). The model is fitted using a sine and cosine term that
together describe the sinusoid. These parameters are added to a generalized
linear model, so the model can be fitted to a range of dependent data (e.g.,
Normal, Poisson, Binomial). Unlike the <code>nscosinor</code> model, the cosinor
model can be applied to unequally spaced data.
</p>


<h3>Value</h3>

<p>Returns an object of class &ldquo;Cosinor&rdquo; with the following
parts: </p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the original call to the cosinor function.</p>
</td></tr> <tr><td><code>glm</code></td>
<td>
<p>an
object of class <code>glm</code> (see <code><a href="stats.html#topic+glm">glm</a></code>).</p>
</td></tr> <tr><td><code>fitted</code></td>
<td>
<p>fitted
values for intercept and cosinor only (ignoring other independent
variables).</p>
</td></tr> <tr><td><code>fitted.plus</code></td>
<td>
<p>standard fitted values, including all other
independent variables.</p>
</td></tr> <tr><td><code>residuals</code></td>
<td>
<p>residuals.</p>
</td></tr> <tr><td><code>date</code></td>
<td>
<p>name of the
date variable (in Date format when type=&lsquo;daily&rsquo;).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>References</h3>

<p>Barnett, A.G., Dobson, A.J. (2010) <em>Analysing Seasonal
Health Data</em>. Springer.
</p>


<h3>See Also</h3>

<p><code>summary.Cosinor</code>, <code>plot.Cosinor</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## cardiovascular disease data (offset based on number of days in...
## ...the month scaled to an average month length)
data(CVD)
res = cosinor(cvd~1, date='month', data=CVD, type='monthly',
              family=poisson(), offsetmonth=TRUE)
summary(res)
seasrescheck(res$residuals) # check the residuals
## stillbirth data
data(stillbirth)
res = cosinor(stillborn~1, date='dob', data=stillbirth,
              family=binomial(link='cloglog'))
summary(res)
plot(res)
## hourly indoor temperature data
res = cosinor(bedroom~1, date='datetime', type='hourly', data=indoor)
summary(res)
# to get the p-values for the sine and cosine estimates
summary(res$glm)

</code></pre>

<hr>
<h2 id='createAdj'>Creates an Adjacency Matrix</h2><span id='topic+createAdj'></span>

<h3>Description</h3>

<p>Creates an adjacency matrix in a form suitable for using in <code>BRugs</code> or
WinBUGS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createAdj(matrix, filename = "Adj.txt", suffix = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createAdj_+3A_matrix">matrix</code></td>
<td>
<p>square matrix with 1's for neighbours and NA's for
non-neighbours.</p>
</td></tr>
<tr><td><code id="createAdj_+3A_filename">filename</code></td>
<td>
<p>filename that the adjacency matrix file will be written to
(default=&lsquo;Adj.txt&rsquo;).</p>
</td></tr>
<tr><td><code id="createAdj_+3A_suffix">suffix</code></td>
<td>
<p>string to be appended to &lsquo;num&rsquo;, &lsquo;adj&rsquo; and
&lsquo;weights&rsquo; object names</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Adjacency matrices are used by conditional autoregressive (CAR) models to
smooth estimates according to some neighbourhood map.  The basic idea is
that neighbouring areas have more in common than non-neighbouring areas and
so will be positively correlated.
</p>
<p>As well as correlations in space it is possible to use CAR models to model
similarities in time.
</p>
<p>In this case the matrix represents those time points that we wish to assume
to be correlated.
</p>


<h3>Value</h3>

<p>Creates a text file named <code>filename</code> that contains the total
number of neighbours (num), the index number of the adjacent neighbours
(adj) and the weights (weights).
</p>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Nearest neighbour matrix for 5 time points
x = c(NA,1,NA,NA,NA)
(V = toeplitz(x))
createAdj(V)


</code></pre>

<hr>
<h2 id='CVD'>Cardiovascular Deaths in Los Angeles, 1987&ndash;2000</h2><span id='topic+CVD'></span>

<h3>Description</h3>

<p>Monthly number of deaths from cardiovascular disease in people aged 75 and
over in Los Angeles for the years 1987 to 2000.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CVD
</code></pre>


<h3>Format</h3>

<p>A data frame with 168 observations on the following 8 variables.
</p>
 <dl>
<dt>year</dt><dd><p>year of death</p>
</dd> <dt>month</dt><dd><p>month of
death</p>
</dd> <dt>yrmon</dt><dd><p>a combination of year and month:
<code class="reqn">year+(month-1)/12</code></p>
</dd> <dt>cvd</dt><dd><p>monthly number of CVD deaths</p>
</dd>
<dt>tmpd</dt><dd><p>mean monthly temperature (degrees Fahrenheit)</p>
</dd>
<dt>pop</dt><dd><p>Los Angeles population aged 75+ in the year 2000 (this
value is constant as only one year was available, but in general the
population will (of course) change over time)</p>
</dd>
<dt>ndaysmonth</dt><dd><p>number of days in each month (used as an offset)</p>
</dd>
<dt>adj</dt><dd><p>adjusted number of CVD deaths per month using a
standardised month length. Monthly number of CVD deaths multiplied by
(365.25/12)/ndaysmonth. So the standard month length is 30.4 days.</p>
</dd> </dl>



<h3>Source</h3>

<p>From the NMMAPS study.
</p>


<h3>References</h3>

<p>Samet JM, Dominici F, Zeger SL, Schwartz J, Dockery DW (2000).
<em>The National Morbidity, Mortality, and Air Pollution Study, Part I:
Methods and Methodologic Issues</em>.  Research Report 94, Health Effects
Institute, Cambridge MA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(CVD)
plot(CVD$yrmon, CVD$cvd, type='o', xlab='Date',
     ylab='Number of CVD deaths per month')

</code></pre>

<hr>
<h2 id='CVDdaily'>Daily Cardiovascular Deaths in Los Angeles, 1987&ndash;2000</h2><span id='topic+CVDdaily'></span>

<h3>Description</h3>

<p>Daily number of deaths from cardiovascular disease in people aged 75 and
over in Los Angeles for the years 1987 to 2000.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CVDdaily
</code></pre>


<h3>Format</h3>

<p>A data frame with 5114 observations on the following 16 variables.
</p>
 <dl>
<dt>date</dt><dd><p>date of death in date format
(year-month-day)</p>
</dd> <dt>cvd</dt><dd><p>daily number of CVD deaths</p>
</dd>
<dt>dow</dt><dd><p>day of the week (character)</p>
</dd> <dt>tmpd</dt><dd><p>daily
mean temperature (degrees Fahrenheit)</p>
</dd> <dt>o3mean</dt><dd><p>daily mean
ozone (parts per billion)</p>
</dd> <dt>o3tmean</dt><dd><p>daily trimmed mean ozone
(parts per billion)</p>
</dd> <dt>Mon</dt><dd><p>indicator variable for Monday</p>
</dd>
<dt>Tue</dt><dd><p>indicator variable for Tuesday</p>
</dd>
<dt>Wed</dt><dd><p>indicator variable for Wednesday</p>
</dd>
<dt>Thu</dt><dd><p>indicator variable for Thursday</p>
</dd>
<dt>Fri</dt><dd><p>indicator variable for Friday</p>
</dd>
<dt>Sat</dt><dd><p>indicator variable for Saturday</p>
</dd>
<dt>month</dt><dd><p>month (integer from 1 to 12)</p>
</dd>
<dt>winter</dt><dd><p>indicator variable for winter</p>
</dd>
<dt>spring</dt><dd><p>indicator variable for spring</p>
</dd>
<dt>summer</dt><dd><p>indicator variable for summer</p>
</dd>
<dt>autumn</dt><dd><p>indicator variable for autumn</p>
</dd> </dl>



<h3>Source</h3>

<p>From the NMMAPS study.
</p>


<h3>References</h3>

<p>Samet JM, Dominici F, Zeger SL, Schwartz J, Dockery DW (2000).
<em>The National Morbidity, Mortality, and Air Pollution Study, Part I:
Methods and Methodologic Issues</em>. Research Report 94, Health Effects
Institute, Cambridge MA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(CVDdaily)
plot(CVDdaily$date, CVDdaily$cvd, type='p', xlab='Date',
     ylab='Number of CVD deaths')

</code></pre>

<hr>
<h2 id='exercise'>Exercise Data from Queensland, 2005&ndash;2007</h2><span id='topic+exercise'></span>

<h3>Description</h3>

<p>Exercise data in longitudinal format from a physical activity intervention
study in Logan, Queensland. Some subjects were lost to follow-up, so all
three visits are not available for all subjects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exercise
</code></pre>


<h3>Format</h3>

<p>A data frame with 1302 observations on the following 7 variables.
</p>
 <dl>
<dt>id</dt><dd><p>subject number</p>
</dd> <dt>visit</dt><dd><p>visit
number (1, 2 or 3)</p>
</dd> <dt>date</dt><dd><p>date of interview (year-month-day)</p>
</dd>
<dt>year</dt><dd><p>year of interview</p>
</dd> <dt>month</dt><dd><p>month of
interview</p>
</dd> <dt>bmi</dt><dd><p>body mass index at visit 1 (kg/m<code class="reqn">^2</code>)</p>
</dd>
<dt>walking</dt><dd><p>walking time per week (in minutes) at each visit</p>
</dd> </dl>



<h3>Source</h3>

<p>From Prof Elizabeth Eakin and colleagues, The University of
Queensland, Brisbane.
</p>


<h3>References</h3>

<p>Eakin E, et al (2009) Telephone counselling for physical
activity and diet in type 2 diabetes and hypertension, <em>Am J of Prev
Med</em>, vol 36, pages 142&ndash;9
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(exercise)
boxplot(exercise$walking ~ exercise$month)

</code></pre>

<hr>
<h2 id='flagleap'>Count the Number of Days in the Month</h2><span id='topic+flagleap'></span>

<h3>Description</h3>

<p>Counts the number of days per month given a range of dates. Used to adjust
monthly count data for the at-risk time period. For internal use only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flagleap(data, report = TRUE, matchin = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flagleap_+3A_data">data</code></td>
<td>
<p>data.</p>
</td></tr>
<tr><td><code id="flagleap_+3A_report">report</code></td>
<td>
<p>produce a brief report on the range of time used
(default=TRUE).</p>
</td></tr>
<tr><td><code id="flagleap_+3A_matchin">matchin</code></td>
<td>
<p>expand the result to match the start and end dates, otherwise
only dates in the data will be returned (default=FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data should contain the numeric variable called &lsquo;year&rsquo; as a 4
digit year (e.g., 1973).
</p>


<h3>Value</h3>

<table>
<tr><td><code>year</code></td>
<td>
<p>year (4 digits).</p>
</td></tr> <tr><td><code>month</code></td>
<td>
<p>month (2 digits).</p>
</td></tr>
<tr><td><code>ndaysmonth</code></td>
<td>
<p>number of days in the month (either 28, 29, 30 or 31).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>

<hr>
<h2 id='indoor'>Indoor Temperature Data</h2><span id='topic+indoor'></span>

<h3>Description</h3>

<p>The data are indoor temperatures (in degrees C) for a bedroom and living
room in a house in Brisbane, Australia for the dates 10 July 2013 to 3
October 2013.  Temperatures were recorded using data loggers which recorded
every hour to the nearest 0.5 degrees.
</p>


<h3>Format</h3>

<p>A <code>data.frame</code> with the following 3 variables.  </p>

<dl>
<dt>datetime</dt><dd><p>date and time in <code>POSIXlt</code> format</p>
</dd>
<dt>living</dt><dd><p>the living room temperature</p>
</dd>
<dt>bedroom</dt><dd><p>the bedroom temperature</p>
</dd> </dl>



<h3>Source</h3>

<p>Adrian G Barnett.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(indoor)
res = cosinor(bedroom~1, date='datetime', type='hourly', data=indoor)
summary(res)

</code></pre>

<hr>
<h2 id='invyrfraction'>Inverse Fraction of the Year or Hour</h2><span id='topic+invyrfraction'></span>

<h3>Description</h3>

<p>Inverts a fraction of the year or hour to a useful time scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invyrfraction(frac, type = "daily", text = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invyrfraction_+3A_frac">frac</code></td>
<td>
<p>a vector of fractions of the year, all between 0 and 1.</p>
</td></tr>
<tr><td><code id="invyrfraction_+3A_type">type</code></td>
<td>
<p>&ldquo;<code>daily</code>&rdquo; for dates, &ldquo;<code>monthly</code>&rdquo; for
months, &ldquo;<code>hourly</code>&rdquo; for hours.</p>
</td></tr>
<tr><td><code id="invyrfraction_+3A_text">text</code></td>
<td>
<p>add an explanatory text to the returned value (TRUE) or return a
number (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the day and month (for <code>daily</code>) or fraction of the month (for
<code>monthly</code>) given a fraction of the year. Assumes a year length of
365.25 days for <code>daily</code>. When using <code>monthly</code> the 1st of January
is 1, the 1st of December is 12, and the 31st of December is 12.9. For
<code>hourly</code> it returns the fraction of the 24-hour clock starting from
zero (midnight).
</p>


<h3>Value</h3>

<table>
<tr><td><code>daym</code></td>
<td>
<p>date (day and month for <code>daily</code>) or fractional
month (for <code>monthly</code>) or fractional of the 24-hour clock (for
<code>hourly</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
invyrfraction(c(0, 0.5, 0.99), type='daily')
invyrfraction(c(0, 0.5, 0.99), type='monthly')
invyrfraction(c(0, 0.5, 0.99), type='hourly')

</code></pre>

<hr>
<h2 id='kalfil'>Forward and Backward Sweep of the Kalman Filter</h2><span id='topic+kalfil'></span>

<h3>Description</h3>

<p>Internal function to do a forward and backward sweep of the Kalman filter,
used by <code>nscosinor</code>. For internal use only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kalfil(data, f, vartheta, w, tau, lambda, cmean)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kalfil_+3A_data">data</code></td>
<td>
<p>a data frame.</p>
</td></tr>
<tr><td><code id="kalfil_+3A_f">f</code></td>
<td>
<p>vector of cycles in units of time.</p>
</td></tr>
<tr><td><code id="kalfil_+3A_vartheta">vartheta</code></td>
<td>
<p>variance for noise.</p>
</td></tr>
<tr><td><code id="kalfil_+3A_w">w</code></td>
<td>
<p>variance of seasonal component.</p>
</td></tr>
<tr><td><code id="kalfil_+3A_tau">tau</code></td>
<td>
<p>controls flexibility of trend and season.</p>
</td></tr>
<tr><td><code id="kalfil_+3A_lambda">lambda</code></td>
<td>
<p>distance between observations.</p>
</td></tr>
<tr><td><code id="kalfil_+3A_cmean">cmean</code></td>
<td>
<p>used to give a vague prior for the starting values.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>

<hr>
<h2 id='monthglm'>Fit a GLM with Month</h2><span id='topic+monthglm'></span>

<h3>Description</h3>

<p>Fit a generalized linear model with a categorical variable of month.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monthglm(
  formula,
  data,
  family = gaussian(),
  refmonth = 1,
  monthvar = "month",
  offsetmonth = FALSE,
  offsetpop = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="monthglm_+3A_formula">formula</code></td>
<td>
<p>regression model formula, e.g., <code>y~x1+x2</code>, (do not add
month to the regression equation, it will be added automatically).</p>
</td></tr>
<tr><td><code id="monthglm_+3A_data">data</code></td>
<td>
<p>a data frame.</p>
</td></tr>
<tr><td><code id="monthglm_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to
be used in the model (default=<code>gaussian()</code>). (See <code><a href="stats.html#topic+family">family</a></code>
for details of family functions.).</p>
</td></tr>
<tr><td><code id="monthglm_+3A_refmonth">refmonth</code></td>
<td>
<p>reference month, must be between 1 and 12 (default=1 for
January).</p>
</td></tr>
<tr><td><code id="monthglm_+3A_monthvar">monthvar</code></td>
<td>
<p>name of the month variable which is either an integer (1 to
12) or a character or factor (&lsquo;Jan&rsquo; to &lsquo;Dec&rsquo; or &lsquo;January&rsquo; to &lsquo;December&rsquo;)
(default='month').</p>
</td></tr>
<tr><td><code id="monthglm_+3A_offsetmonth">offsetmonth</code></td>
<td>
<p>include an offset to account for the uneven number of
days in the month (TRUE/FALSE). Should be used for monthly counts (with
<code>family=poisson()</code>).</p>
</td></tr>
<tr><td><code id="monthglm_+3A_offsetpop">offsetpop</code></td>
<td>
<p>include an offset for the population (optional), this
should be a variable in the data frame. Do not log-transform the offset as
the log-transform is applied by the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Month is fitted as a categorical variable as part of a generalized linear
model. Other independent variables can be added to the right-hand side of
<code>formula</code>.
</p>
<p>This model is useful for examining non-sinusoidal seasonal patterns. For
sinusoidal seasonal patterns see <code><a href="#topic+cosinor">cosinor</a></code>.
</p>
<p>The data frame should contain the integer months and the year as a 4 digit
number. These are used to calculate the number of days in each month
accounting for leap years.
</p>


<h3>Value</h3>

<table>
<tr><td><code>call</code></td>
<td>
<p>the original call to the monthglm function.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>GLM model.</p>
</td></tr> <tr><td><code>fitted</code></td>
<td>
<p>fitted values.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>residuals.</p>
</td></tr> <tr><td><code>out</code></td>
<td>
<p>details on the monthly estimates.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>References</h3>

<p>Barnett, A.G., Dobson, A.J. (2010) <em>Analysing Seasonal
Health Data</em>. Springer.
</p>


<h3>See Also</h3>

<p><code>summary.monthglm</code>, <code>plot.monthglm</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(CVD)
mmodel = monthglm(formula=cvd~1 ,data=CVD, family=poisson(),
                  offsetpop=expression(pop/100000), offsetmonth=TRUE)
summary(mmodel)

</code></pre>

<hr>
<h2 id='monthmean'>Monthly Means</h2><span id='topic+monthmean'></span>

<h3>Description</h3>

<p>Calculate the monthly mean or adjusted monthly mean for count data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monthmean(data, resp, offsetpop = NULL, adjmonth = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="monthmean_+3A_data">data</code></td>
<td>
<p>data set as a data frame.</p>
</td></tr>
<tr><td><code id="monthmean_+3A_resp">resp</code></td>
<td>
<p>response variable in the data set for which the means will be
calculated.</p>
</td></tr>
<tr><td><code id="monthmean_+3A_offsetpop">offsetpop</code></td>
<td>
<p>optional population, used as an offset (default=NULL).</p>
</td></tr>
<tr><td><code id="monthmean_+3A_adjmonth">adjmonth</code></td>
<td>
<p>adjust monthly counts and scale to a 30 day month
(&lsquo;<code>thirty</code>&rsquo;) or the average month length
(&lsquo;<code>average</code>&rsquo;) (default=FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For time series recorded at monthly intervals it is often useful to examine
(and plot) the average in each month. When using count data we should adjust
the mean to account for the unequal number of days in the month (e.g., 31 in
January and 28 or 29 in February).
</p>
<p>This function assumes that the data set (<code>data</code>) contains variables for
the year and month called year and month, respectively.
</p>


<h3>Value</h3>

<p>Returns an object of class &ldquo;Monthmean&rdquo; with the following
parts: </p>
<table>
<tr><td><code>mean</code></td>
<td>
<p>a vector of length 12 with the monthly means.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>References</h3>

<p>Barnett, A.G., Dobson, A.J. (2010) <em>Analysing Seasonal
Health Data</em>. Springer.
</p>


<h3>See Also</h3>

<p><code>plot.Monthmean</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# cardiovascular disease data
data(CVD)
mmean = monthmean(data=CVD, resp='cvd', offsetpop=expression(pop/100000), adjmonth='average')
mmean
plot(mmean)


</code></pre>

<hr>
<h2 id='nochars'>Remove Letters and Characters from a String</h2><span id='topic+nochars'></span>

<h3>Description</h3>

<p>Remove letters and characters from a string to leave only numbers. Removes
all letters (upper and lower case) and the characters &ldquo;.&rdquo;, &ldquo;(&rdquo;
and &ldquo;)&rdquo;. For internal use only.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="nochars_+3A_text">text</code></td>
<td>
<p>text string.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>

<hr>
<h2 id='nonlintest'>Test of Non-linearity of a Time Series</h2><span id='topic+nonlintest'></span>

<h3>Description</h3>

<p>A bootstrap test of non-linearity in a time series using the third-order
moment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nonlintest(data, n.lag, n.boot, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nonlintest_+3A_data">data</code></td>
<td>
<p>a vector of equally spaced numeric observations (time series).</p>
</td></tr>
<tr><td><code id="nonlintest_+3A_n.lag">n.lag</code></td>
<td>
<p>the number of lags tested using the third-order moment, maximum
= length of time series.</p>
</td></tr>
<tr><td><code id="nonlintest_+3A_n.boot">n.boot</code></td>
<td>
<p>the number of bootstrap replications (suggested minimum of
100; 1000 or more would be better).</p>
</td></tr>
<tr><td><code id="nonlintest_+3A_alpha">alpha</code></td>
<td>
<p>statistical significance level of test (default=0.05).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test uses <code>aaft</code> to create linear surrogates with the same
second-order properties, but no (third-order) non-linearity. The third-order
moments (<code>third</code>) of these linear surrogates and the actual series are
then compared from lags 0 up to <code>n.lag</code> (excluding the skew at the
co-ordinates (0,0)). The bootstrap test works on the overall area outside
the limits, and gives an indication of the overall non-linearity. The plot
using <code>region</code> shows those co-ordinates of the third order moment that
exceed the null hypothesis limits, and can be a useful clue for guessing the
type of non-linearity. For example, a large value at the co-ordinates (0,1)
might be caused by a bi-linear series <code class="reqn">X_t=\alpha
X_{t-1}\varepsilon_{t-1} +\varepsilon_t</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class &ldquo;nonlintest&rdquo; with the following
parts: </p>
<table>
<tr><td><code>region</code></td>
<td>
<p>the region of the third order moment where the test
exceeds the limits (up to <code>n.lag</code>).</p>
</td></tr> <tr><td><code>n.lag</code></td>
<td>
<p>the maximum lag
tested using the third-order moment.</p>
</td></tr> <tr><td><code>stats</code></td>
<td>
<p>a list of following
statistics for the area outside the test limits:</p>
</td></tr> <tr><td><code>outside</code></td>
<td>
<p>the total
area outside of limits (summed over the whole third-order moment).</p>
</td></tr>
<tr><td><code>stan</code></td>
<td>
<p>the total area outside the limits divided by its standard
deviation to give a standardised estimate.</p>
</td></tr> <tr><td><code>median</code></td>
<td>
<p>the median area
outside the test limits.</p>
</td></tr> <tr><td><code>upper</code></td>
<td>
<p>the (1-<code>alpha</code>)th percentile of
the area outside the limits.</p>
</td></tr> <tr><td><code>pvalue</code></td>
<td>
<p>Bootstrap p-value of the area
outside the limits to test if the series is linear.</p>
</td></tr> <tr><td><code>test</code></td>
<td>
<p>Reject the
null hypothesis that the series is linear (TRUE/FALSE).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>References</h3>

<p>Barnett AG &amp; Wolff RC (2005) A Time-Domain Test for Some Types
of Nonlinearity, <em>IEEE Transactions on Signal Processing</em>, vol 53,
pages 26&ndash;33
</p>


<h3>See Also</h3>

<p><code>print.nonlintest</code>, <code>plot.nonlintest</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(CVD)
## Not run: test.res = nonlintest(data=CVD$cvd, n.lag=4, n.boot=1000)


</code></pre>

<hr>
<h2 id='nscosinor'>Non-stationary Cosinor</h2><span id='topic+nscosinor'></span>

<h3>Description</h3>

<p>Decompose a time series using a non-stationary cosinor for the seasonal
pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nscosinor(
  data,
  response,
  cycles,
  niters = 1000,
  burnin = 500,
  tau,
  lambda = 1/12,
  div = 50,
  monthly = TRUE,
  alpha = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nscosinor_+3A_data">data</code></td>
<td>
<p>a data frame.</p>
</td></tr>
<tr><td><code id="nscosinor_+3A_response">response</code></td>
<td>
<p>response variable.</p>
</td></tr>
<tr><td><code id="nscosinor_+3A_cycles">cycles</code></td>
<td>
<p>vector of cycles in units of time, e.g., for a six and twelve
month pattern <code>cycles=c(6,12)</code>.</p>
</td></tr>
<tr><td><code id="nscosinor_+3A_niters">niters</code></td>
<td>
<p>total number of MCMC samples (default=1000).</p>
</td></tr>
<tr><td><code id="nscosinor_+3A_burnin">burnin</code></td>
<td>
<p>number of MCMC samples discarded as a burn-in (default=500).</p>
</td></tr>
<tr><td><code id="nscosinor_+3A_tau">tau</code></td>
<td>
<p>vector of smoothing parameters, tau[1] for trend, tau[2] for 1st
seasonal parameter, tau[3] for 2nd seasonal parameter, etc. Larger values of
tau allow more change between observations and hence a greater potential
flexibility in the trend and season.</p>
</td></tr>
<tr><td><code id="nscosinor_+3A_lambda">lambda</code></td>
<td>
<p>distance between observations (lambda=1/12 for monthly data,
default).</p>
</td></tr>
<tr><td><code id="nscosinor_+3A_div">div</code></td>
<td>
<p>divisor at which MCMC sample progress is reported (default=50).</p>
</td></tr>
<tr><td><code id="nscosinor_+3A_monthly">monthly</code></td>
<td>
<p>TRUE for monthly data.</p>
</td></tr>
<tr><td><code id="nscosinor_+3A_alpha">alpha</code></td>
<td>
<p>Statistical significance level used by the confidence
intervals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This model is designed to decompose an equally spaced time series into a
trend, season(s) and noise. A seasonal estimate is estimated as
<code class="reqn">s_t=A_t\cos(\omega_t-P_t)</code>, where <em>t</em> is time, <code class="reqn">A_t</code> is the
non-stationary amplitude, <code class="reqn">P_t</code> is the non-stationary phase and
<code class="reqn">\omega_t</code> is the frequency.
</p>
<p>A non-stationary seasonal pattern is one that changes over time, hence this
model gives potentially very flexible seasonal estimates.
</p>
<p>The frequency of the seasonal estimate(s) are controlled by <code>cycle</code>.
The cycles should be specified in units of time. If the data is monthly,
then setting <code>lambda=1/12</code> and <code>cycles=12</code> will fit an annual
seasonal pattern. If the data is daily, then setting <code>lambda=</code>
<code>1/365.25</code> and <code>cycles=365.25</code> will fit an annual seasonal
pattern. Specifying <code>cycles=</code> <code>c(182.6,365.25)</code> will fit two
seasonal patterns, one with a twice-annual cycle, and one with an annual
cycle.
</p>
<p>The estimates are made using a forward and backward sweep of the Kalman
filter. Repeated estimates are made using Markov chain Monte Carlo (MCMC).
For this reason the model can take a long time to run. To give stable
estimates a reasonably long sample should be used (<code>niters</code>), and the
possibly poor initial estimates should be discarded (<code>burnin</code>).
</p>


<h3>Value</h3>

<p>Returns an object of class &ldquo;nsCosinor&rdquo; with the following
parts: </p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the original call to the nscosinor function.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>the year and month for monthly data.</p>
</td></tr> <tr><td><code>trend</code></td>
<td>
<p>mean trend
and 95% confidence interval.</p>
</td></tr> <tr><td><code>season</code></td>
<td>
<p>mean season(s) and 95%
confidence interval(s).</p>
</td></tr> <tr><td><code>oseason</code></td>
<td>
<p>overall season(s) and 95%
confidence interval(s). This will be the same as <code>season</code> if there is
only one seasonal cycle.</p>
</td></tr> <tr><td><code>fitted</code></td>
<td>
<p>fitted values and 95% confidence
interval, based on trend + season(s).</p>
</td></tr> <tr><td><code>residuals</code></td>
<td>
<p>residuals based on
mean trend and season(s).</p>
</td></tr> <tr><td><code>n</code></td>
<td>
<p>the length of the series.</p>
</td></tr>
<tr><td><code>chains</code></td>
<td>
<p>MCMC chains (of class mcmc) of variance estimates: standard
error for overall noise (std.error), standard error for season(s)
(std.season), phase(s) and amplitude(s)</p>
</td></tr> <tr><td><code>cycles</code></td>
<td>
<p>vector of cycles in
units of time.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>References</h3>

<p>Barnett, A.G., Dobson, A.J. (2010) <em>Analysing Seasonal
Health Data</em>. Springer.
</p>
<p>Barnett, A.G., Dobson, A.J. (2004) Estimating trends and seasonality in
coronary heart disease <em>Statistics in Medicine</em>. 23(22) 3505&ndash;23.
</p>


<h3>See Also</h3>

<p><code>plot.nsCosinor</code>, <code>summary.nsCosinor</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(CVD)
# model to fit an annual pattern to the monthly cardiovascular disease data
f = c(12)
tau = c(10,50)
## Not run: res12 = nscosinor(data=CVD, response='adj', cycles=f, niters=5000,
         burnin=1000, tau=tau)
summary(res12)
plot(res12)

## End(Not run)


</code></pre>

<hr>
<h2 id='nscosinor.initial'>Initial Values for Non-stationary Cosinor</h2><span id='topic+nscosinor.initial'></span>

<h3>Description</h3>

<p>Creates initial values for the non-stationary cosinor decomposition
<code>nscosinor</code>. For internal use only.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="nscosinor.initial_+3A_data">data</code></td>
<td>
<p>a data frame.</p>
</td></tr>
<tr><td><code id="nscosinor.initial_+3A_response">response</code></td>
<td>
<p>response variable.</p>
</td></tr>
<tr><td><code id="nscosinor.initial_+3A_tau">tau</code></td>
<td>
<p>vector of smoothing parameters, tau[1] for trend, tau[2] for 1st
seasonal parameter, tau[3] for 2nd seasonal parameter, etc. Larger values of
tau allow more change between observations and hence a greater potential
flexibility in the trend and season.</p>
</td></tr>
<tr><td><code id="nscosinor.initial_+3A_lambda">lambda</code></td>
<td>
<p>distance between observations (lambda=1/12 for monthly data,
default).</p>
</td></tr>
<tr><td><code id="nscosinor.initial_+3A_n.season">n.season</code></td>
<td>
<p>number of seasons.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>

<hr>
<h2 id='peri'>Periodogram</h2><span id='topic+peri'></span>

<h3>Description</h3>

<p>Estimated periodogram using the fast Fourier transform (<code>fft</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peri(data, adjmean = TRUE, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="peri_+3A_data">data</code></td>
<td>
<p>a data frame.</p>
</td></tr>
<tr><td><code id="peri_+3A_adjmean">adjmean</code></td>
<td>
<p>subtract the mean from the series before calculating the
periodogram (default=TRUE).</p>
</td></tr>
<tr><td><code id="peri_+3A_plot">plot</code></td>
<td>
<p>plot the estimated periodogram (default=TRUE).</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>peri</code></td>
<td>
<p>periodogram, I(<code class="reqn">\omega</code>).</p>
</td></tr> <tr><td><code>f</code></td>
<td>
<p>frequencies in
radians, <code class="reqn">\omega</code>.</p>
</td></tr> <tr><td><code>c</code></td>
<td>
<p>frequencies in cycles of time,
<code class="reqn">2\pi/\omega</code>.</p>
</td></tr> <tr><td><code>amp</code></td>
<td>
<p>amplitude periodogram.</p>
</td></tr> <tr><td><code>phase</code></td>
<td>
<p>phase
periodogram.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(CVD)
p = peri(CVD$cvd)


</code></pre>

<hr>
<h2 id='phasecalc'>Phase from Cosinor Estimates</h2><span id='topic+phasecalc'></span>

<h3>Description</h3>

<p>Calculate the phase given the estimated sine and cosine values from a
cosinor model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phasecalc(cosine, sine)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phasecalc_+3A_cosine">cosine</code></td>
<td>
<p>estimated cosine value from a cosinor model.</p>
</td></tr>
<tr><td><code id="phasecalc_+3A_sine">sine</code></td>
<td>
<p>estimated sine value from a cosinor model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the phase in radians, in the range <code class="reqn">[0,2\pi)</code>. The phase is the
peak in the sinusoid.
</p>


<h3>Value</h3>

<table>
<tr><td><code>phaser</code></td>
<td>
<p>Estimated phase in radians.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>References</h3>

<p>Fisher, N.I. (1993) <em>Statistical Analysis of Circular
Data</em>. Cambridge University Press, Cambridge. Page 31.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
phasecalc(cosine=0, sine=1) # pi/2

</code></pre>

<hr>
<h2 id='plot.Cosinor'>Plot the Results of a Cosinor</h2><span id='topic+plot.Cosinor'></span>

<h3>Description</h3>

<p>Plots the fitted sinusoid from a <code>Cosinor</code> object produced by
<code>cosinor</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Cosinor'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Cosinor_+3A_x">x</code></td>
<td>
<p>a <code>Cosinor</code> object produced by <code>cosinor</code>.</p>
</td></tr>
<tr><td><code id="plot.Cosinor_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the sinusoid plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code produces the fitted sinusoid based on the intercept and sinusoid.
The y-axis is on the scale of probability if the link function is
&lsquo;logit&rsquo; or &lsquo;cloglog&rsquo;. If the analysis was based on monthly
data then month is shown on the x-axis. If the analysis was based on daily
data then time is shown on the x-axis.
</p>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>See Also</h3>

<p><code>cosinor</code>, <code>summary.Cosinor</code>, <code>seasrescheck</code>
</p>

<hr>
<h2 id='plot.monthglm'>Plot of Monthly Estimates</h2><span id='topic+plot.monthglm'></span>

<h3>Description</h3>

<p>Plots the estimated from a generalized linear model with a categorical
variable of month.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'monthglm'
plot(x, alpha = 0.05, ylim = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.monthglm_+3A_x">x</code></td>
<td>
<p>a <code>monthglm</code> object produced by <code>monthglm</code>.</p>
</td></tr>
<tr><td><code id="plot.monthglm_+3A_alpha">alpha</code></td>
<td>
<p>statistical significance level of confidence intervals.</p>
</td></tr>
<tr><td><code id="plot.monthglm_+3A_ylim">ylim</code></td>
<td>
<p>y coordinates ranges (the default is NULL, and the limits are
automatically calculated).</p>
</td></tr>
<tr><td><code id="plot.monthglm_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the plot.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>See Also</h3>

<p><code>monthglm</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(CVD)
mmodel = monthglm(formula=cvd~1, data=CVD, family=poisson(),
                  offsetpop=expression(pop/100000), offsetmonth=TRUE, refmonth=6)
plot(mmodel)


</code></pre>

<hr>
<h2 id='plot.Monthmean'>Plot of Monthly Mean Estimates</h2><span id='topic+plot.Monthmean'></span>

<h3>Description</h3>

<p>Plots estimated monthly means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Monthmean'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Monthmean_+3A_x">x</code></td>
<td>
<p>a <code>Monthmean</code> object produced by <code>monthmean</code>.</p>
</td></tr>
<tr><td><code id="plot.Monthmean_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the plot.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>See Also</h3>

<p><code>monthmean</code>
</p>

<hr>
<h2 id='plot.nonlintest'>Plot the Results of the Non-linear Test</h2><span id='topic+plot.nonlintest'></span>

<h3>Description</h3>

<p>Creates a contour plot of the region of the third-order moment outside the
test limits generated by <code>nonlintest</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nonlintest'
plot(x, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.nonlintest_+3A_x">x</code></td>
<td>
<p>a <code>nonlintest</code> object produced by <code>nonlintest</code>.</p>
</td></tr>
<tr><td><code id="plot.nonlintest_+3A_plot">plot</code></td>
<td>
<p>display plot (TRUE) or return plot (FALSE)</p>
</td></tr>
<tr><td><code id="plot.nonlintest_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>plot</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>See Also</h3>

<p><code>nonlintest</code>
</p>

<hr>
<h2 id='plot.nsCosinor'>Plot the Results of a Non-stationary Cosinor</h2><span id='topic+plot.nsCosinor'></span>

<h3>Description</h3>

<p>Plots the trend and season(s) from a <code>nsCosinor</code> object produced by
<code>nscosinor</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nsCosinor'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.nsCosinor_+3A_x">x</code></td>
<td>
<p>a <code>nsCosinor</code> object produced by <code>nscosinor</code>.</p>
</td></tr>
<tr><td><code id="plot.nsCosinor_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code produces the season(s) and trend estimates.
</p>


<h3>Value</h3>

<table>
<tr><td><code>gplot</code></td>
<td>
<p>A plot of class <code>ggplot</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>See Also</h3>

<p><code>nscosinor</code>
</p>

<hr>
<h2 id='plotCircle'>Circular Plot</h2><span id='topic+plotCircle'></span>

<h3>Description</h3>

<p>Circular plot of a monthly variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCircle(months, dp = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCircle_+3A_months">months</code></td>
<td>
<p>monthly variable to plot, the shades of grey of the 12
segments are proportional to this variable. The first result is assumed to
be January, the second February, and so on.</p>
</td></tr>
<tr><td><code id="plotCircle_+3A_dp">dp</code></td>
<td>
<p>decimal places for statistics, default=1.</p>
</td></tr>
<tr><td><code id="plotCircle_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This circular plot can be useful for estimates of an annual seasonal
pattern. Darker shades of grey correspond to larger numbers.
</p>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plotCircle(months=seq(1,12,1),dp=0)


</code></pre>

<hr>
<h2 id='plotCircular'>Circular Plot Using Segments</h2><span id='topic+plotCircular'></span>

<h3>Description</h3>

<p>A circular plot useful for visualising monthly or weekly data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCircular(
  area1,
  area2 = NULL,
  spokes = NULL,
  scale = 0.8,
  labels,
  stats = TRUE,
  dp = 1,
  clockwise = TRUE,
  spoke.col = "black",
  lines = FALSE,
  centrecirc = 0.03,
  main = "",
  xlab = "",
  ylab = "",
  pieces.col = c("white", "gray"),
  length = FALSE,
  legend = TRUE,
  auto.legend = list(x = "bottomright", fill = NULL, labels = NULL, title = ""),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCircular_+3A_area1">area1</code></td>
<td>
<p>variable to plot, the area of the segments (or petals) are
proportional to this variable.</p>
</td></tr>
<tr><td><code id="plotCircular_+3A_area2">area2</code></td>
<td>
<p>2nd variable to plot (optional), the area of the segments are
plotted in grey.</p>
</td></tr>
<tr><td><code id="plotCircular_+3A_spokes">spokes</code></td>
<td>
<p>spokes that overlay segments, for example standard errors
(optional).</p>
</td></tr>
<tr><td><code id="plotCircular_+3A_scale">scale</code></td>
<td>
<p>scale the overall size of the segments (default:0.8).</p>
</td></tr>
<tr><td><code id="plotCircular_+3A_labels">labels</code></td>
<td>
<p>optional labels to appear at the ends of the segments (there
should be as many labels as there are <code>area1</code>).</p>
</td></tr>
<tr><td><code id="plotCircular_+3A_stats">stats</code></td>
<td>
<p>put area values at the ends of the segments, default:TRUE.</p>
</td></tr>
<tr><td><code id="plotCircular_+3A_dp">dp</code></td>
<td>
<p>decimal places for statistics, default:1.</p>
</td></tr>
<tr><td><code id="plotCircular_+3A_clockwise">clockwise</code></td>
<td>
<p>plot in a clockwise direction, default:TRUE.</p>
</td></tr>
<tr><td><code id="plotCircular_+3A_spoke.col">spoke.col</code></td>
<td>
<p>spoke colour, default:black.</p>
</td></tr>
<tr><td><code id="plotCircular_+3A_lines">lines</code></td>
<td>
<p>add dotted lines to separate petals, default:FALSE.</p>
</td></tr>
<tr><td><code id="plotCircular_+3A_centrecirc">centrecirc</code></td>
<td>
<p>controls the size of the circle at the centre of the plot,
default:0.03.</p>
</td></tr>
<tr><td><code id="plotCircular_+3A_main">main</code></td>
<td>
<p>title for plot, default:blank</p>
</td></tr>
<tr><td><code id="plotCircular_+3A_xlab">xlab</code></td>
<td>
<p>x axis label, default:blank</p>
</td></tr>
<tr><td><code id="plotCircular_+3A_ylab">ylab</code></td>
<td>
<p>y axis label, default:blank</p>
</td></tr>
<tr><td><code id="plotCircular_+3A_pieces.col">pieces.col</code></td>
<td>
<p>colours for circular pieces, default:&lsquo;white&rsquo; for
1st and &lsquo;grey&rsquo; for second variable. Note that a list of available
colours may be found with &lsquo;colors()&rsquo;</p>
</td></tr>
<tr><td><code id="plotCircular_+3A_length">length</code></td>
<td>
<p>make the length of the segments proportional to the dependent
variable, default:FALSE</p>
</td></tr>
<tr><td><code id="plotCircular_+3A_legend">legend</code></td>
<td>
<p>whether to include legend or not, default:TRUE when plotting
two variables</p>
</td></tr>
<tr><td><code id="plotCircular_+3A_auto.legend">auto.legend</code></td>
<td>
<p>list of parameters for legend, see <code><a href="graphics.html#topic+legend">legend</a></code></p>
</td></tr>
<tr><td><code id="plotCircular_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="graphics.html#topic+plot">plot</a></code> and/or
<code><a href="graphics.html#topic+legend">legend</a></code>. See <code><a href="graphics.html#topic+par">par</a></code> for more details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A circular plot can be useful for spotting the shape of the seasonal
pattern. This function can be used to plot any circular patterns, e.g.,
weekly or monthly. The number of segments will be the length of the variable
<code>area1</code>.
</p>
<p>The plots are also called rose diagrams, with the segments then called
&lsquo;petals&rsquo;.
</p>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>References</h3>

<p>Fisher, N.I. (1993) <em>Statistical Analysis of Circular
Data</em>. Cambridge University Press, Cambridge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# months (dummy data)
plotCircular(area1=seq(1,12,1), scale=0.7, labels=month.abb, dp=0)
# weeks (random data)
daysoftheweek = c('Monday','Tuesday','Wednesday','Thursday','Friday',
'Saturday','Sunday')
weekfreq = table(round(runif(100, min=1, max=7)))
plotCircular(area1=weekfreq, labels=daysoftheweek, dp=0)
# Observed number of AFL players with expected values
data(AFL)
plotCircular(area1=AFL$players, area2=AFL$expected, scale=0.72,
  labels=month.abb, dp=0, lines=TRUE, legend=FALSE)
plotCircular(area1=AFL$players, area2=AFL$expected, scale=0.72,
  labels=month.abb, dp=0, lines=TRUE, pieces.col=c("green","red"),
  auto.legend=list(labels=c("Obs","Exp"), title="# players"),
  main="Observed and Expected AFL players")


</code></pre>

<hr>
<h2 id='plotMonth'>Plot Results by Month</h2><span id='topic+plotMonth'></span>

<h3>Description</h3>

<p>Plots results by month.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMonth(data, resp, panels = 12, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMonth_+3A_data">data</code></td>
<td>
<p>a data frame.</p>
</td></tr>
<tr><td><code id="plotMonth_+3A_resp">resp</code></td>
<td>
<p>response variable to plot.</p>
</td></tr>
<tr><td><code id="plotMonth_+3A_panels">panels</code></td>
<td>
<p>number of panels to use in plot (1 or 12). 12 gives one panel
per month, 1 plots all the months in the same panel.</p>
</td></tr>
<tr><td><code id="plotMonth_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assumes the data frame contains variables called year and month.
</p>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>References</h3>

<p>Barnett, A.G., Dobson, A.J. (2010) <em>Analysing Seasonal
Health Data</em>. Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(CVD)
plotMonth(data=CVD, resp='cvd', panels=12)


</code></pre>

<hr>
<h2 id='print.casecross'>Print the Results of a Case-Crossover Model</h2><span id='topic+print.casecross'></span>

<h3>Description</h3>

<p>The default print method for a <code>casecross</code> object produced by
<code>casecross</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'casecross'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.casecross_+3A_x">x</code></td>
<td>
<p>a <code>casecross</code> object produced by <code>casecross</code>.</p>
</td></tr>
<tr><td><code id="print.casecross_+3A_...">...</code></td>
<td>
<p>optional arguments to <code>print</code> or <code>plot</code> methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code>print.coxph</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>See Also</h3>

<p><code>casecross</code>, <code>summary.casecross</code>, <code>coxph</code>
</p>

<hr>
<h2 id='print.Cosinor'>Print the Results of a Cosinor</h2><span id='topic+print.Cosinor'></span>

<h3>Description</h3>

<p>The default print method for a <code>Cosinor</code> object produced by
<code>cosinor</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Cosinor'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.Cosinor_+3A_x">x</code></td>
<td>
<p>a <code>Cosinor</code> object produced by <code>cosinor</code>.</p>
</td></tr>
<tr><td><code id="print.Cosinor_+3A_...">...</code></td>
<td>
<p>optional arguments to <code>print</code> or <code>plot</code> methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code>print.glm</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>See Also</h3>

<p><code>cosinor</code>, <code>summary.Cosinor</code>, <code>glm</code>
</p>

<hr>
<h2 id='print.monthglm'>Print <code>monthglm</code></h2><span id='topic+print.monthglm'></span>

<h3>Description</h3>

<p>Print <code>monthglm</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'monthglm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.monthglm_+3A_x">x</code></td>
<td>
<p>Object of class <code>monthglm</code></p>
</td></tr>
<tr><td><code id="print.monthglm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='print.Monthmean'>Print the Results from Monthmean</h2><span id='topic+print.Monthmean'></span>

<h3>Description</h3>

<p>Print the monthly means from a <code>Monthmean</code> object produced by
<code>monthmean</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Monthmean'
print(x, digits = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.Monthmean_+3A_x">x</code></td>
<td>
<p>a <code>Monthmean</code> object produced by <code>monthmean</code>.</p>
</td></tr>
<tr><td><code id="print.Monthmean_+3A_digits">digits</code></td>
<td>
<p>minimal number of significant digits, see <code>print.default</code></p>
</td></tr>
<tr><td><code id="print.Monthmean_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the print.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code prints the monthly mean estimates.
</p>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>See Also</h3>

<p><code>monthmean</code>
</p>

<hr>
<h2 id='print.nonlintest'>Print the Results of the Non-linear Test</h2><span id='topic+print.nonlintest'></span>

<h3>Description</h3>

<p>The default print method for a <code>nonlintest</code> object produced by
<code>nonlintest</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nonlintest'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.nonlintest_+3A_x">x</code></td>
<td>
<p>a <code>nonlintest</code> object produced by <code>nonlintest</code>.</p>
</td></tr>
<tr><td><code id="print.nonlintest_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>plot</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>See Also</h3>

<p><code>nonlintest</code>, <code>plot.nonlintest</code>
</p>

<hr>
<h2 id='print.nsCosinor'>Print the Results of a Non-stationary Cosinor</h2><span id='topic+print.nsCosinor'></span>

<h3>Description</h3>

<p>The default print method for a <code>nsCosinor</code> object produced by
<code>nscosinor</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nsCosinor'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.nsCosinor_+3A_x">x</code></td>
<td>
<p>a <code>nsCosinor</code> object produced by <code>nscosinor</code>.</p>
</td></tr>
<tr><td><code id="print.nsCosinor_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints out the model call, number of MCMC samples, sample size and residual
summary statistics.
</p>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>See Also</h3>

<p><code>nscosinor</code>, <code>summary.nsCosinor</code>
</p>

<hr>
<h2 id='print.summary.Cosinor'>printing a summary of a Cosinor</h2><span id='topic+print.summary.Cosinor'></span>

<h3>Description</h3>

<p>printing a summary of a Cosinor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.Cosinor'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.Cosinor_+3A_x">x</code></td>
<td>
<p>a <code>summary.Cosinor</code> object produced by <code>summary.Cosinor</code></p>
</td></tr>
<tr><td><code id="print.summary.Cosinor_+3A_...">...</code></td>
<td>
<p>optional arguments to <code>print</code> or <code>plot</code> methods.</p>
</td></tr>
</table>

<hr>
<h2 id='print.summary.monthglm'>printing a summary of a month.glm</h2><span id='topic+print.summary.monthglm'></span>

<h3>Description</h3>

<p>printing a summary of a month.glm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.monthglm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.monthglm_+3A_x">x</code></td>
<td>
<p>a <code>summary.monthglm</code> object produced by
<code>summary.monthglm</code>.</p>
</td></tr>
<tr><td><code id="print.summary.monthglm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='print.summary.nscosinor'>printing a summary of an nscosinor</h2><span id='topic+print.summary.nscosinor'></span>

<h3>Description</h3>

<p>printing a summary of an nscosinor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.nscosinor'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.nscosinor_+3A_x">x</code></td>
<td>
<p>a <code>summary.nsCosinor</code> object produced by
<code>summary.nsCosinor</code></p>
</td></tr>
<tr><td><code id="print.summary.nscosinor_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='rinvgamma'>Random Inverse Gamma Distribution</h2><span id='topic+rinvgamma'></span>

<h3>Description</h3>

<p>Internal function to simulate a value from an inverse Gamma distribution,
used by <code>nscosinor</code>. See the MCMCpack library. For internal use only.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="rinvgamma_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="rinvgamma_+3A_shape">shape</code></td>
<td>
<p>Gamma shape parameter.</p>
</td></tr>
<tr><td><code id="rinvgamma_+3A_scale">scale</code></td>
<td>
<p>Gamma scale parameter (default=1).</p>
</td></tr>
</table>

<hr>
<h2 id='schz'>Schizophrenia Births in Australia, 1930&ndash;1971</h2><span id='topic+schz'></span>

<h3>Description</h3>

<p>Monthly number of babies born with schizophrenia in Australia from 1930 to
1971. The national number of births and number of cases are missing for
January 1960 are missing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>schz
</code></pre>


<h3>Format</h3>

<p>A data frame with 504 observations on the following 6 variables.
</p>
 <dl>
<dt>year</dt><dd><p>year of birth</p>
</dd> <dt>month</dt><dd><p>month of
birth</p>
</dd> <dt>yrmon</dt><dd><p>a combination of year and month:
<code class="reqn">year+(month-1)/12</code></p>
</dd> <dt>NBirths</dt><dd><p>monthly number of births in
Australia, used as an offset</p>
</dd> <dt>SczBroad</dt><dd><p>monthly number of
schizophrenia births using the broad diagnostic criteria</p>
</dd>
<dt>SOI</dt><dd><p>southern oscillation index</p>
</dd> </dl>



<h3>Source</h3>

<p>From Prof John McGrath and colleagues, The University of Queensland,
Brisbane.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(schz)
plot(schz$yrmon, schz$SczBroad, type='o', xlab='Date',
     ylab='Number of schizophrenia births')

</code></pre>

<hr>
<h2 id='season-package'>season: Tools for Uncovering and Estimating Seasonal Patterns.</h2><span id='topic+season-package'></span><span id='topic+season'></span>

<h3>Description</h3>

<p>The package contains graphical methods for displaying seasonal data and
regression models for detecting and estimating seasonal patterns.
</p>


<h3>Details</h3>

<p>The regression models can be applied to normal, Poisson or binomial
dependent data distributions. Tools are available for both time series data
(equally spaced in time) and survey data (unequally spaced in time).
</p>
<p>Sinusoidal (parametric) seasonal patterns are available
(<code><a href="#topic+cosinor">cosinor</a></code>, <code><a href="#topic+nscosinor">nscosinor</a></code>), as well as models for
monthly data (<code><a href="#topic+monthglm">monthglm</a></code>), and the case-crossover method to
control for seasonality (<code><a href="#topic+casecross">casecross</a></code>).
</p>
<p><code>season</code> aims to fill an important gap in the software by providing a
range of tools for analysing seasonal data. The examples are based on health
data, but the functions are equally applicable to any data with a seasonal
pattern.
</p>


<h3>Author(s)</h3>

<p>Adrian Barnett &lt;a.barnett@qut.edu.au&gt;<br /> Peter Baker<br /> Oliver Hughes 
</p>
<p>Maintainer: Adrian Barnett &lt;a.barnett@qut.edu.au&gt;
</p>


<h3>References</h3>

<p>Barnett, A.G., Dobson, A.J. (2010) <em>Analysing Seasonal
Health Data</em>. Springer.
</p>

<hr>
<h2 id='seasrescheck'>Seasonal Residual Checks</h2><span id='topic+seasrescheck'></span>

<h3>Description</h3>

<p>Tests the residuals for any remaining seasonality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seasrescheck(res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seasrescheck_+3A_res">res</code></td>
<td>
<p>residuals from some time series regression model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots: i) histogram of the residuals, ii) a scatter plot against residual
order, iii) the autocovariance, iv) the cumulative periodogram (see
<code><a href="stats.html#topic+cpgram">cpgram</a></code>)
</p>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# cardiovascular disease data
# (use an offset of the scaled number of days in a month)
data(CVD)
model = cosinor(cvd~1, date='month', data=CVD, type='monthly',
                family=poisson(), offsetmonth=TRUE)
seasrescheck(resid(model))


</code></pre>

<hr>
<h2 id='sinusoid'>Plot a Sinusoid</h2><span id='topic+sinusoid'></span>

<h3>Description</h3>

<p>Plots a sinusoid over 0 to 2<code class="reqn">\pi</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sinusoid(amplitude, frequency, phase, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sinusoid_+3A_amplitude">amplitude</code></td>
<td>
<p>the amplitude of the sinsuoid (its maximum value).</p>
</td></tr>
<tr><td><code id="sinusoid_+3A_frequency">frequency</code></td>
<td>
<p>the frequency of the sinusoid in 0 to 2<code class="reqn">\pi</code> (number of
cycles).</p>
</td></tr>
<tr><td><code id="sinusoid_+3A_phase">phase</code></td>
<td>
<p>the phase of the sinusoid (location of the peak).</p>
</td></tr>
<tr><td><code id="sinusoid_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sinusoidal curves are useful for modelling seasonal data. A sinusoid is
plotted using the equation: <code class="reqn">A\cos(ft-P), t=0,\ldots,2 \pi</code>, where
<code class="reqn">A</code> is the amplitude, <code class="reqn">f</code> is the frequency, <code class="reqn">t</code> is time and
<code class="reqn">P</code> is the phase.
</p>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>References</h3>

<p>Barnett, A.G., Dobson, A.J. (2010) <em>Analysing Seasonal
Health Data</em>. Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sinusoid(amplitude=1, frequency=1, phase=1)

</code></pre>

<hr>
<h2 id='stillbirth'>Stillbirths in Queensland, 1998&ndash;2000</h2><span id='topic+stillbirth'></span>

<h3>Description</h3>

<p>Monthly number of stillbirths in Australia from 1998 to 2000. It is a rare
event; there are 352 stillbirths out of 60,110 births.  To preserve
confidentiality the day of birth has been randomly re-ordered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stillbirth
</code></pre>


<h3>Format</h3>

<p>A data frame with 60,110 observations on the following 7 variables.
</p>
 <dl>
<dt>dob</dt><dd><p>date of birth (year-month-day)</p>
</dd>
<dt>year</dt><dd><p>year of birth</p>
</dd> <dt>month</dt><dd><p>month of birth</p>
</dd>
<dt>yrmon</dt><dd><p>a combination of year and month:
<code class="reqn">year+(month-1)/12</code></p>
</dd> <dt>seifa</dt><dd><p>SEIFA score, an area level
measure of socioeconomic status in quintiles</p>
</dd>
<dt>gestation</dt><dd><p>gestation in weeks</p>
</dd>
<dt>stillborn</dt><dd><p>stillborn (yes/no); 1=Yes, 0=No</p>
</dd> </dl>



<h3>Source</h3>

<p>From Queensland Health.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(stillbirth)
table(stillbirth$month, stillbirth$stillborn)

</code></pre>

<hr>
<h2 id='summary.casecross'>Summary of the Results of a Case-crossover Model</h2><span id='topic+summary.casecross'></span>

<h3>Description</h3>

<p>The default summary method for a <code>casecross</code> object produced by
<code>casecross</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'casecross'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.casecross_+3A_object">object</code></td>
<td>
<p>a <code>casecross</code> object produced by <code>casecross</code>.</p>
</td></tr>
<tr><td><code id="summary.casecross_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Shows the number of control days, the average number of control days per
case days, and the parameter estimates.
</p>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>See Also</h3>

<p><code>casecross</code>
</p>

<hr>
<h2 id='summary.Cosinor'>Summary for a Cosinor</h2><span id='topic+summary.Cosinor'></span>

<h3>Description</h3>

<p>The default print method for a <code>Cosinor</code> object produced by
<code>cosinor</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Cosinor'
summary(object, digits = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.Cosinor_+3A_object">object</code></td>
<td>
<p>a <code>Cosinor</code> object produced by <code>cosinor</code>.</p>
</td></tr>
<tr><td><code id="summary.Cosinor_+3A_digits">digits</code></td>
<td>
<p>minimal number of significant digits, see <code>print.default</code></p>
</td></tr>
<tr><td><code id="summary.Cosinor_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Summarises the sinusoidal seasonal pattern and tests whether there is
statistically significant seasonal or circadian pattern (assuming a smooth
sinusoidal pattern). The amplitude describes the average height of the
sinusoid, and the phase describes the location of the peak. The scale of the
amplitude depends on the link function. For logistic regression the
amplitude is given on a probability scale. For Poisson regression the
amplitude is given on an absolute scale.
</p>


<h3>Value</h3>

<table>
<tr><td><code>n</code></td>
<td>
<p>sample size.</p>
</td></tr> <tr><td><code>amp</code></td>
<td>
<p>estimated amplitude.</p>
</td></tr>
<tr><td><code>amp.scale</code></td>
<td>
<p>the scale of the estimated amplitude (empty for standard
regression; &lsquo;probability scale&rsquo; for logistic regession;
&lsquo;absolute scale&rsquo; for Poisson regression).</p>
</td></tr> <tr><td><code>phase</code></td>
<td>
<p>estimated
peak phase on a time scale.</p>
</td></tr> <tr><td><code>lphase</code></td>
<td>
<p>estimated low phase on a time
scale (half a year after/before <code>phase</code>).</p>
</td></tr>
<tr><td><code>significant</code></td>
<td>
<p>statistically significant sinusoid (TRUE/FALSE).</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>statistical significance level.</p>
</td></tr> <tr><td><code>digits</code></td>
<td>
<p>minimal number
of significant digits.</p>
</td></tr> <tr><td><code>text</code></td>
<td>
<p>add explanatory text to the returned
phase value (TRUE) or return a number (FALSE).</p>
</td></tr> <tr><td><code>type</code></td>
<td>
<p>type of data
(yearly/monthly/weekly/hourly).</p>
</td></tr> <tr><td><code>ctable</code></td>
<td>
<p>table of regression
coefficients.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>See Also</h3>

<p><code>cosinor</code>, <code>plot.Cosinor</code>, <code>invyrfraction</code>
</p>

<hr>
<h2 id='summary.monthglm'>Summary for a Monthglm</h2><span id='topic+summary.monthglm'></span>

<h3>Description</h3>

<p>The default summary method for a <code>monthglm</code> object produced by
<code>monthglm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'monthglm'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.monthglm_+3A_object">object</code></td>
<td>
<p>a <code>monthglm</code> object produced by <code>nscosinor</code>.</p>
</td></tr>
<tr><td><code id="summary.monthglm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimates are the mean, 95% confidence interval, Z-value and associated
p-value (comparing each month to the reference month). If Poisson regression
was used then the estimates are shown as rate ratios. If logistic regression
was used then the estimates are shown as odds ratios.
</p>


<h3>Value</h3>

<table>
<tr><td><code>n</code></td>
<td>
<p>sample size.</p>
</td></tr> <tr><td><code>month.ests</code></td>
<td>
<p>parameter estimates for the
intercept and months.</p>
</td></tr> <tr><td><code>month.effect</code></td>
<td>
<p>scale of the monthly effects.
&lsquo;RR&rsquo; for &lsquo;rate ratios&rsquo;, &lsquo;OR&rsquo; for &lsquo;odds ratios&rsquo;,
or empty otherwise.</p>
</td></tr> <tr><td><code>x</code></td>
<td>
<p>object of class <code>monthglm</code></p>
</td></tr>
<tr><td><code>object</code></td>
<td>
<p>object of class <code>monthglm</code></p>
</td></tr> <tr><td><code>list()</code></td>
<td>
<p>further
arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>See Also</h3>

<p><code>monthglm</code>, <code>plot.monthglm</code>
</p>

<hr>
<h2 id='summary.nsCosinor'>Summary for a Non-stationary Cosinor</h2><span id='topic+summary.nsCosinor'></span>

<h3>Description</h3>

<p>The default summary method for a <code>nsCosinor</code> object produced by
<code>nscosinor</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nsCosinor'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.nsCosinor_+3A_object">object</code></td>
<td>
<p>a <code>nsCosinor</code> object produced by <code>nscosinor</code>.</p>
</td></tr>
<tr><td><code id="summary.nsCosinor_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The amplitude describes the average height of each seasonal cycle, and the
phase describes the location of the peak. The results for the phase are
given in radians (0 to 2<code class="reqn">\pi</code>), they can be transformed to the time
scale using the <code>invyrfraction</code> making sure to first divide by
2<code class="reqn">\pi</code>.
</p>
<p>The larger the standard deviation for the seasonal cycles, the greater the
non-stationarity. This is because a larger standard deviation means more
change over time.
</p>


<h3>Value</h3>

<table>
<tr><td><code>cycles</code></td>
<td>
<p>vector of cycles in units of time, e.g., for a six and
twelve month pattern <code>cycles=c(6,12)</code>.</p>
</td></tr> <tr><td><code>niters</code></td>
<td>
<p>total number of
MCMC samples.</p>
</td></tr> <tr><td><code>burnin</code></td>
<td>
<p>number of MCMC samples discarded as a burn-in.</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>vector of smoothing parameters, tau[1] for trend, tau[2] for 1st
seasonal parameter, tau[3] for 2nd seasonal parameter, etc.</p>
</td></tr>
<tr><td><code>stats</code></td>
<td>
<p>summary statistics (mean and confidence interval) for the
residual standard deviation, the standard deviation for each seasonal cycle,
and the amplitude and phase for each cycle.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>See Also</h3>

<p><code>nscosinor</code>, <code>plot.nsCosinor</code>
</p>

<hr>
<h2 id='third'>Third-order Moment</h2><span id='topic+third'></span>

<h3>Description</h3>

<p>Estimated third order moment for a time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>third(data, n.lag, centre = TRUE, outmax = TRUE, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="third_+3A_data">data</code></td>
<td>
<p>a vector of equally spaced numeric observations (time series).</p>
</td></tr>
<tr><td><code id="third_+3A_n.lag">n.lag</code></td>
<td>
<p>the number of lags, maximum = length of time series.</p>
</td></tr>
<tr><td><code id="third_+3A_centre">centre</code></td>
<td>
<p>centre series by subtracting mean (default=TRUE).</p>
</td></tr>
<tr><td><code id="third_+3A_outmax">outmax</code></td>
<td>
<p>display the (x,y) lag co-ordinates for the maximum and minimum
values (default=TRUE).</p>
</td></tr>
<tr><td><code id="third_+3A_plot">plot</code></td>
<td>
<p>contour plot of the third order moment (default=TRUE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The third-order moment is the extension of the second-order moment
(essentially the autocovariance). The equation for the third order moment at
lags (j,k) is: <code class="reqn">n^{-1}\sum X_t X_{t+j} X_{t+k}</code>. The third-order moment
is useful for testing for non-linearity in a time series, and is used by
<code>nonlintest</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>waxis</code></td>
<td>
<p>The axis &ndash;<code>n.lag</code> to <code>n.lag</code>.</p>
</td></tr>
<tr><td><code>third</code></td>
<td>
<p>The estimated third order moment in the range &ndash;n.lag to n.lag,
including the symmetries.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(CVD)
third(CVD$cvd, n.lag=12)

</code></pre>

<hr>
<h2 id='wtest'>Walter and Elwood's Test of Seasonality</h2><span id='topic+wtest'></span>

<h3>Description</h3>

<p>Tests for a seasonal pattern in Binomial data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wtest(cases, offset, data, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wtest_+3A_cases">cases</code></td>
<td>
<p>variable name for cases (&ldquo;successes&rdquo;).</p>
</td></tr>
<tr><td><code id="wtest_+3A_offset">offset</code></td>
<td>
<p>variable name for at-risk population (&ldquo;trials&rdquo;).</p>
</td></tr>
<tr><td><code id="wtest_+3A_data">data</code></td>
<td>
<p>data frame (optional).</p>
</td></tr>
<tr><td><code id="wtest_+3A_alpha">alpha</code></td>
<td>
<p>significance level (default=0.05).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A test of whether monthly data has a sinusoidal seasonal pattern. The test
has low power compared with the <code><a href="#topic+cosinor">cosinor</a></code> test.
</p>


<h3>Value</h3>

<table>
<tr><td><code>test</code></td>
<td>
<p>test statistic.</p>
</td></tr> <tr><td><code>pvalue</code></td>
<td>
<p>p-value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>References</h3>

<p>Walter, S.D., Elwood, J.M. (1975) A test for seasonality of
events with a variable population at risk. <em>British Journal of
Preventive and Social Medicine</em> 29, 18&ndash;21.
</p>
<p>Barnett, A.G., Dobson, A.J. (2010) <em>Analysing Seasonal Health Data</em>.
Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(stillbirth)
# tabulate the total number of births and the number of stillbirths
freqs = table(stillbirth$month,stillbirth$stillborn)
data = list()
data$trials = as.numeric(freqs[,1]+freqs[,2])
data$success = as.numeric(freqs[,2])
# test for a seasonal pattern in stillbirth
test = wtest(cases='success', offset='trials', data=data)

</code></pre>

<hr>
<h2 id='yrfraction'>Fraction of the Year</h2><span id='topic+yrfraction'></span>

<h3>Description</h3>

<p>Calculate the fraction of the year for a date variable (after accounting for
leap years) or for month.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yrfraction(date, type = "daily")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yrfraction_+3A_date">date</code></td>
<td>
<p>a date variable if type=&lsquo;<code>daily</code>&rsquo;, or an integer
between 1 and 12 if type=&lsquo;<code>monthly</code>&rsquo;.</p>
</td></tr>
<tr><td><code id="yrfraction_+3A_type">type</code></td>
<td>
<p>&lsquo;daily&rsquo; for dates, or &lsquo;<code>monthly</code>&rsquo; for months.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the fraction of the year in the range [0,1).
</p>


<h3>Value</h3>

<table>
<tr><td><code>yrfrac</code></td>
<td>
<p>Fraction of the year.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Barnett <a href="mailto:a.barnett@qut.edu.au">a.barnett@qut.edu.au</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create fractions for the start, middle and end of the year
date = as.Date(c(0, 181, 364), origin='1991-01-01')
# create fractions based on these dates
yrfraction(date)
yrfraction(1:12, type='monthly')

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
