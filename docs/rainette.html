<!DOCTYPE html><html lang="en"><head><title>Help for package rainette</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rainette}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cluster_tab'><p>Split a dtm into two clusters with reinert algorithm</p></a></li>
<li><a href='#clusters_by_doc_table'><p>Returns the number of segment of each cluster for each source document</p></a></li>
<li><a href='#cutree'><p>Cut a tree into groups</p></a></li>
<li><a href='#cutree_rainette'><p>Cut a rainette result tree into groups of documents</p></a></li>
<li><a href='#cutree_rainette2'><p>Cut a rainette2 result object into groups of documents</p></a></li>
<li><a href='#docs_by_cluster_table'><p>Returns, for each cluster, the number of source documents with at least n</p>
segments of this cluster</a></li>
<li><a href='#import_corpus_iramuteq'><p>Import a corpus in Iramuteq format</p></a></li>
<li><a href='#merge_segments'><p>Merges segments according to minimum segment size</p></a></li>
<li><a href='#order_docs'><p>return documents indices ordered by CA first axis coordinates</p></a></li>
<li><a href='#rainette'><p>Corpus clustering based on the Reinert method - Simple clustering</p></a></li>
<li><a href='#rainette_explor'><p>Shiny gadget for rainette clustering exploration</p></a></li>
<li><a href='#rainette_plot'><p>Generate a clustering description plot from a rainette result</p></a></li>
<li><a href='#rainette_stats'><p>Generate cluster keyness statistics from a rainette result</p></a></li>
<li><a href='#rainette2'><p>Corpus clustering based on the Reinert method - Double clustering</p></a></li>
<li><a href='#rainette2_complete_groups'><p>Complete groups membership with knn classification</p></a></li>
<li><a href='#rainette2_explor'><p>Shiny gadget for rainette2 clustering exploration</p></a></li>
<li><a href='#rainette2_plot'><p>Generate a clustering description plot from a rainette2 result</p></a></li>
<li><a href='#select_features'><p>Remove features from dtm of each group base don cc_test and tsj</p></a></li>
<li><a href='#split_segments'><p>Split a character string or corpus into segments</p></a></li>
<li><a href='#switch_docs'><p>Switch documents between two groups to maximize chi-square value</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>The Reinert Method for Textual Data Clustering</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-27</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Julien Barnier &lt;julien.barnier@cnrs.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An R implementation of the Reinert text clustering method. For more 
    details about the algorithm see the included vignettes or Reinert (1990) 
    &lt;<a href="https://doi.org/10.1177%2F075910639002600103">doi:10.1177/075910639002600103</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://juba.github.io/rainette/">https://juba.github.io/rainette/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/juba/rainette/issues">https://github.com/juba/rainette/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 1.1.0), tidyr, purrr, ggplot2, stringr, quanteda (&ge;
2.1), quanteda.textstats, RSpectra, dendextend, ggwordcloud,
gridExtra, rlang, shiny, miniUI, highr, progressr, Rcpp (&ge;
1.0.3)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, tm, FNN, vdiffr,
quanteda.textmodels</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-27 07:35:10 UTC; julien</td>
</tr>
<tr>
<td>Author:</td>
<td>Julien Barnier [aut, cre],
  Florian Privé [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-28 16:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cluster_tab'>Split a dtm into two clusters with reinert algorithm</h2><span id='topic+cluster_tab'></span>

<h3>Description</h3>

<p>Split a dtm into two clusters with reinert algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_tab(dtm, cc_test = 0.3, tsj = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cluster_tab_+3A_dtm">dtm</code></td>
<td>
<p>to be split, passed by <code>rainette</code></p>
</td></tr>
<tr><td><code id="cluster_tab_+3A_cc_test">cc_test</code></td>
<td>
<p>maximum contingency coefficient value for the
feature to be kept in both groups.</p>
</td></tr>
<tr><td><code id="cluster_tab_+3A_tsj">tsj</code></td>
<td>
<p>minimum feature frequency in the dtm</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal function, not to be used directly
</p>


<h3>Value</h3>

<p>An object of class <code>hclust</code> and <code>rainette</code>
</p>

<hr>
<h2 id='clusters_by_doc_table'>Returns the number of segment of each cluster for each source document</h2><span id='topic+clusters_by_doc_table'></span>

<h3>Description</h3>

<p>Returns the number of segment of each cluster for each source document
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusters_by_doc_table(obj, clust_var = NULL, doc_id = NULL, prop = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clusters_by_doc_table_+3A_obj">obj</code></td>
<td>
<p>a corpus, tokens or dtm object</p>
</td></tr>
<tr><td><code id="clusters_by_doc_table_+3A_clust_var">clust_var</code></td>
<td>
<p>name of the docvar with the clusters</p>
</td></tr>
<tr><td><code id="clusters_by_doc_table_+3A_doc_id">doc_id</code></td>
<td>
<p>docvar identifying the source document</p>
</td></tr>
<tr><td><code id="clusters_by_doc_table_+3A_prop">prop</code></td>
<td>
<p>if TRUE, returns the percentage of each cluster by document</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is only useful for previously segmented corpus. If <code>doc_id</code>
is NULL and there is a <code>sement_source</code> docvar, it will be used instead.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+docs_by_cluster_table">docs_by_cluster_table()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(quanteda)
corpus &lt;- data_corpus_inaugural
corpus &lt;- head(corpus, n = 10)
corpus &lt;- split_segments(corpus)
tok &lt;- tokens(corpus, remove_punct = TRUE)
tok &lt;- tokens_remove(tok, stopwords("en"))
dtm &lt;- dfm(tok, tolower = TRUE)
dtm &lt;- dfm_trim(dtm, min_docfreq = 2)
res &lt;- rainette(dtm, k = 3, min_segment_size = 15)
corpus$cluster &lt;- cutree(res, k = 3)
clusters_by_doc_table(corpus, clust_var = "cluster", prop = TRUE)

</code></pre>

<hr>
<h2 id='cutree'>Cut a tree into groups</h2><span id='topic+cutree'></span>

<h3>Description</h3>

<p>Cut a tree into groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutree(tree, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cutree_+3A_tree">tree</code></td>
<td>
<p>the hclust tree object to be cut</p>
</td></tr>
<tr><td><code id="cutree_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>tree</code> is of class <code>rainette</code>, invokes <code><a href="#topic+cutree_rainette">cutree_rainette()</a></code>. Otherwise, just run <code><a href="stats.html#topic+cutree">stats::cutree()</a></code>.
</p>


<h3>Value</h3>

<p>A vector with group membership.
</p>

<hr>
<h2 id='cutree_rainette'>Cut a rainette result tree into groups of documents</h2><span id='topic+cutree_rainette'></span>

<h3>Description</h3>

<p>Cut a rainette result tree into groups of documents
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutree_rainette(hres, k = NULL, h = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cutree_rainette_+3A_hres">hres</code></td>
<td>
<p>the <code>rainette</code> result object to be cut</p>
</td></tr>
<tr><td><code id="cutree_rainette_+3A_k">k</code></td>
<td>
<p>the desired number of clusters</p>
</td></tr>
<tr><td><code id="cutree_rainette_+3A_h">h</code></td>
<td>
<p>unsupported</p>
</td></tr>
<tr><td><code id="cutree_rainette_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with group membership.
</p>

<hr>
<h2 id='cutree_rainette2'>Cut a rainette2 result object into groups of documents</h2><span id='topic+cutree_rainette2'></span>

<h3>Description</h3>

<p>Cut a rainette2 result object into groups of documents
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutree_rainette2(res, k, criterion = c("chi2", "n"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cutree_rainette2_+3A_res">res</code></td>
<td>
<p>the <code>rainette2</code> result object to be cut</p>
</td></tr>
<tr><td><code id="cutree_rainette2_+3A_k">k</code></td>
<td>
<p>the desired number of clusters</p>
</td></tr>
<tr><td><code id="cutree_rainette2_+3A_criterion">criterion</code></td>
<td>
<p>criterion to use to choose the best partition. <code>chi2</code> means
the partition with the maximum sum of chi2, <code>n</code> the partition with the
maximum size.</p>
</td></tr>
<tr><td><code id="cutree_rainette2_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with group membership.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rainette2_complete_groups">rainette2_complete_groups()</a></code>
</p>

<hr>
<h2 id='docs_by_cluster_table'>Returns, for each cluster, the number of source documents with at least n
segments of this cluster</h2><span id='topic+docs_by_cluster_table'></span>

<h3>Description</h3>

<p>Returns, for each cluster, the number of source documents with at least n
segments of this cluster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>docs_by_cluster_table(obj, clust_var = NULL, doc_id = NULL, threshold = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="docs_by_cluster_table_+3A_obj">obj</code></td>
<td>
<p>a corpus, tokens or dtm object</p>
</td></tr>
<tr><td><code id="docs_by_cluster_table_+3A_clust_var">clust_var</code></td>
<td>
<p>name of the docvar with the clusters</p>
</td></tr>
<tr><td><code id="docs_by_cluster_table_+3A_doc_id">doc_id</code></td>
<td>
<p>docvar identifying the source document</p>
</td></tr>
<tr><td><code id="docs_by_cluster_table_+3A_threshold">threshold</code></td>
<td>
<p>the minimal number of segments of a given cluster that a document
must include to be counted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is only useful for previously segmented corpus. If <code>doc_id</code> is NULL
and there is a <code>sement_source</code> docvar, it will be used instead.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clusters_by_doc_table">clusters_by_doc_table()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(quanteda)
corpus &lt;- data_corpus_inaugural
corpus &lt;- head(corpus, n = 10)
corpus &lt;- split_segments(corpus)
tok &lt;- tokens(corpus, remove_punct = TRUE)
tok &lt;- tokens_remove(tok, stopwords("en"))
dtm &lt;- dfm(tok, tolower = TRUE)
dtm &lt;- dfm_trim(dtm, min_docfreq = 2)
res &lt;- rainette(dtm, k = 3, min_segment_size = 15)
corpus$cluster &lt;- cutree(res, k = 3)
docs_by_cluster_table(corpus, clust_var = "cluster")

</code></pre>

<hr>
<h2 id='import_corpus_iramuteq'>Import a corpus in Iramuteq format</h2><span id='topic+import_corpus_iramuteq'></span>

<h3>Description</h3>

<p>Import a corpus in Iramuteq format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_corpus_iramuteq(f, id_var = NULL, thematics = c("remove", "split"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="import_corpus_iramuteq_+3A_f">f</code></td>
<td>
<p>a file name or a connection</p>
</td></tr>
<tr><td><code id="import_corpus_iramuteq_+3A_id_var">id_var</code></td>
<td>
<p>name of metadata variable to be used as documents id</p>
</td></tr>
<tr><td><code id="import_corpus_iramuteq_+3A_thematics">thematics</code></td>
<td>
<p>if &quot;remove&quot;, thematics lines are removed. If &quot;split&quot;, texts as splitted at each thematic, and metadata duplicated accordingly</p>
</td></tr>
<tr><td><code id="import_corpus_iramuteq_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="base.html#topic+connections">file</a></code> if <code>f</code> is a file name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A description of the Iramuteq corpus format can be found here : <a href="http://www.iramuteq.org/documentation/html/2-2-2-les-regles-de-formatages">http://www.iramuteq.org/documentation/html/2-2-2-les-regles-de-formatages</a>
</p>


<h3>Value</h3>

<p>A quanteda corpus object. Note that metadata variables in docvars are all imported as characters.
</p>

<hr>
<h2 id='merge_segments'>Merges segments according to minimum segment size</h2><span id='topic+merge_segments'></span>

<h3>Description</h3>

<p><code>rainette_uc_index</code> docvar
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_segments(dtm, min_segment_size = 10, doc_id = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge_segments_+3A_dtm">dtm</code></td>
<td>
<p>dtm of segments</p>
</td></tr>
<tr><td><code id="merge_segments_+3A_min_segment_size">min_segment_size</code></td>
<td>
<p>minimum number of forms by segment</p>
</td></tr>
<tr><td><code id="merge_segments_+3A_doc_id">doc_id</code></td>
<td>
<p>character name of a dtm docvar which identifies source documents.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>min_segment_size == 0</code>, no segments are merged together.
If <code>min_segment_size &gt; 0</code> then <code>doc_id</code> must be provided
unless the corpus comes from <code>split_segments</code>, in this case
<code>segment_source</code> is used by default.
</p>


<h3>Value</h3>

<p>the original dtm with a new <code>rainette_uc_id</code> docvar.
</p>

<hr>
<h2 id='order_docs'>return documents indices ordered by CA first axis coordinates</h2><span id='topic+order_docs'></span>

<h3>Description</h3>

<p>return documents indices ordered by CA first axis coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_docs(m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="order_docs_+3A_m">m</code></td>
<td>
<p>dtm on which to compute the CA and order documents, converted to an integer matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal function, not to be used directly
</p>


<h3>Value</h3>

<p>ordered list of document indices
</p>

<hr>
<h2 id='rainette'>Corpus clustering based on the Reinert method - Simple clustering</h2><span id='topic+rainette'></span>

<h3>Description</h3>

<p>Corpus clustering based on the Reinert method - Simple clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rainette(
  dtm,
  k = 10,
  min_segment_size = 0,
  doc_id = NULL,
  min_split_members = 5,
  cc_test = 0.3,
  tsj = 3,
  min_members,
  min_uc_size
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rainette_+3A_dtm">dtm</code></td>
<td>
<p>quanteda dfm object of documents to cluster, usually the
result of <code><a href="#topic+split_segments">split_segments()</a></code></p>
</td></tr>
<tr><td><code id="rainette_+3A_k">k</code></td>
<td>
<p>maximum number of clusters to compute</p>
</td></tr>
<tr><td><code id="rainette_+3A_min_segment_size">min_segment_size</code></td>
<td>
<p>minimum number of forms by document</p>
</td></tr>
<tr><td><code id="rainette_+3A_doc_id">doc_id</code></td>
<td>
<p>character name of a dtm docvar which identifies source documents.</p>
</td></tr>
<tr><td><code id="rainette_+3A_min_split_members">min_split_members</code></td>
<td>
<p>don't try to split groups with fewer members</p>
</td></tr>
<tr><td><code id="rainette_+3A_cc_test">cc_test</code></td>
<td>
<p>contingency coefficient value for feature selection</p>
</td></tr>
<tr><td><code id="rainette_+3A_tsj">tsj</code></td>
<td>
<p>minimum frequency value for feature selection</p>
</td></tr>
<tr><td><code id="rainette_+3A_min_members">min_members</code></td>
<td>
<p>deprecated, use <code>min_split_members</code> instead</p>
</td></tr>
<tr><td><code id="rainette_+3A_min_uc_size">min_uc_size</code></td>
<td>
<p>deprecated, use <code>min_segment_size</code> instead</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the references for original articles on the method. Computations and results may differ
quite a bit, see the package vignettes for more details.
</p>
<p>The dtm object is automatically converted to boolean.
</p>
<p>If <code>min_segment_size &gt; 0</code> then <code>doc_id</code> must be provided unless the corpus comes from <code>split_segments</code>,
in this case <code>segment_source</code> is used by default.
</p>


<h3>Value</h3>

<p>The result is a list of both class <code>hclust</code> and <code>rainette</code>. Besides the elements
of an <code>hclust</code> object, two more results are available :
</p>

<ul>
<li> <p><code>uce_groups</code> give the group of each document for each k
</p>
</li>
<li> <p><code>group</code> give the group of each document for the maximum value of k available
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> Reinert M, Une méthode de classification descendante hiérarchique : application à l'analyse lexicale par contexte, Cahiers de l'analyse des données, Volume 8, Numéro 2, 1983. <a href="http://www.numdam.org/item/?id=CAD_1983__8_2_187_0">http://www.numdam.org/item/?id=CAD_1983__8_2_187_0</a>
</p>
</li>
<li><p> Reinert M., Alceste une méthodologie d'analyse des données textuelles et une application: Aurelia De Gerard De Nerval, Bulletin de Méthodologie Sociologique, Volume 26, Numéro 1, 1990. <a href="https://doi.org/10.1177/075910639002600103">doi:10.1177/075910639002600103</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+split_segments">split_segments()</a></code>, <code><a href="#topic+rainette2">rainette2()</a></code>, <code><a href="#topic+cutree_rainette">cutree_rainette()</a></code>, <code><a href="#topic+rainette_plot">rainette_plot()</a></code>, <code><a href="#topic+rainette_explor">rainette_explor()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(quanteda)
corpus &lt;- data_corpus_inaugural
corpus &lt;- head(corpus, n = 10)
corpus &lt;- split_segments(corpus)
tok &lt;- tokens(corpus, remove_punct = TRUE)
tok &lt;- tokens_remove(tok, stopwords("en"))
dtm &lt;- dfm(tok, tolower = TRUE)
dtm &lt;- dfm_trim(dtm, min_docfreq = 3)
res &lt;- rainette(dtm, k = 3, min_segment_size = 15)


</code></pre>

<hr>
<h2 id='rainette_explor'>Shiny gadget for rainette clustering exploration</h2><span id='topic+rainette_explor'></span>

<h3>Description</h3>

<p>Shiny gadget for rainette clustering exploration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rainette_explor(res, dtm = NULL, corpus_src = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rainette_explor_+3A_res">res</code></td>
<td>
<p>result object of a <code>rainette</code> clustering</p>
</td></tr>
<tr><td><code id="rainette_explor_+3A_dtm">dtm</code></td>
<td>
<p>the dfm object used to compute the clustering</p>
</td></tr>
<tr><td><code id="rainette_explor_+3A_corpus_src">corpus_src</code></td>
<td>
<p>the quanteda corpus object used to compute the dtm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>See Also</h3>

<p><code>rainette_plot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(quanteda)
corpus &lt;- data_corpus_inaugural
corpus &lt;- head(corpus, n = 10)
corpus &lt;- split_segments(corpus)
tok &lt;- tokens(corpus, remove_punct = TRUE)
tok &lt;- tokens_remove(tok, stopwords("en"))
dtm &lt;- dfm(tok, tolower = TRUE)
dtm &lt;- dfm_trim(dtm, min_docfreq = 3)
res &lt;- rainette(dtm, k = 3, min_segment_size = 15)
rainette_explor(res, dtm, corpus)

## End(Not run)

</code></pre>

<hr>
<h2 id='rainette_plot'>Generate a clustering description plot from a rainette result</h2><span id='topic+rainette_plot'></span>

<h3>Description</h3>

<p>Generate a clustering description plot from a rainette result
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rainette_plot(
  res,
  dtm,
  k = NULL,
  type = c("bar", "cloud"),
  n_terms = 15,
  free_scales = FALSE,
  measure = c("chi2", "lr", "frequency", "docprop"),
  show_negative = FALSE,
  text_size = NULL,
  show_na_title = TRUE,
  cluster_label = NULL,
  keyness_plot_xlab = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rainette_plot_+3A_res">res</code></td>
<td>
<p>result object of a <code>rainette</code> clustering</p>
</td></tr>
<tr><td><code id="rainette_plot_+3A_dtm">dtm</code></td>
<td>
<p>the dfm object used to compute the clustering</p>
</td></tr>
<tr><td><code id="rainette_plot_+3A_k">k</code></td>
<td>
<p>number of groups. If NULL, use the biggest number possible</p>
</td></tr>
<tr><td><code id="rainette_plot_+3A_type">type</code></td>
<td>
<p>type of term plots : barplot or wordcloud</p>
</td></tr>
<tr><td><code id="rainette_plot_+3A_n_terms">n_terms</code></td>
<td>
<p>number of terms to display in keyness plots</p>
</td></tr>
<tr><td><code id="rainette_plot_+3A_free_scales">free_scales</code></td>
<td>
<p>if TRUE, all the keyness plots will have the same scale</p>
</td></tr>
<tr><td><code id="rainette_plot_+3A_measure">measure</code></td>
<td>
<p>statistics to compute</p>
</td></tr>
<tr><td><code id="rainette_plot_+3A_show_negative">show_negative</code></td>
<td>
<p>if TRUE, show negative keyness features</p>
</td></tr>
<tr><td><code id="rainette_plot_+3A_text_size">text_size</code></td>
<td>
<p>font size for barplots, max word size for wordclouds</p>
</td></tr>
<tr><td><code id="rainette_plot_+3A_show_na_title">show_na_title</code></td>
<td>
<p>if TRUE, show number of NA as plot title</p>
</td></tr>
<tr><td><code id="rainette_plot_+3A_cluster_label">cluster_label</code></td>
<td>
<p>define a specific term for clusters identification in keyness plots.
Default is &quot;Cluster&quot; or &quot;Cl.&quot; depending on the number of groups.</p>
</td></tr>
<tr><td><code id="rainette_plot_+3A_keyness_plot_xlab">keyness_plot_xlab</code></td>
<td>
<p>define a specific x label for keyness plots.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A gtable object.
</p>


<h3>See Also</h3>

<p><code><a href="quanteda.textstats.html#topic+textstat_keyness">quanteda.textstats::textstat_keyness()</a></code>, <code><a href="#topic+rainette_explor">rainette_explor()</a></code>, <code><a href="#topic+rainette_stats">rainette_stats()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(quanteda)
corpus &lt;- data_corpus_inaugural
corpus &lt;- head(corpus, n = 10)
corpus &lt;- split_segments(corpus)
tok &lt;- tokens(corpus, remove_punct = TRUE)
tok &lt;- tokens_remove(tok, stopwords("en"))
dtm &lt;- dfm(tok, tolower = TRUE)
dtm &lt;- dfm_trim(dtm, min_docfreq = 3)
res &lt;- rainette(dtm, k = 3, min_segment_size = 15)
rainette_plot(res, dtm)


</code></pre>

<hr>
<h2 id='rainette_stats'>Generate cluster keyness statistics from a rainette result</h2><span id='topic+rainette_stats'></span>

<h3>Description</h3>

<p>Generate cluster keyness statistics from a rainette result
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rainette_stats(
  groups,
  dtm,
  measure = c("chi2", "lr", "frequency", "docprop"),
  n_terms = 15,
  show_negative = TRUE,
  max_p = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rainette_stats_+3A_groups">groups</code></td>
<td>
<p>groups membership computed by <code>cutree_rainette</code> or <code>cutree_rainette2</code></p>
</td></tr>
<tr><td><code id="rainette_stats_+3A_dtm">dtm</code></td>
<td>
<p>the dfm object used to compute the clustering</p>
</td></tr>
<tr><td><code id="rainette_stats_+3A_measure">measure</code></td>
<td>
<p>statistics to compute</p>
</td></tr>
<tr><td><code id="rainette_stats_+3A_n_terms">n_terms</code></td>
<td>
<p>number of terms to display in keyness plots</p>
</td></tr>
<tr><td><code id="rainette_stats_+3A_show_negative">show_negative</code></td>
<td>
<p>if TRUE, show negative keyness features</p>
</td></tr>
<tr><td><code id="rainette_stats_+3A_max_p">max_p</code></td>
<td>
<p>maximum keyness statistic p-value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with, for each group, a data.frame of keyness statistics for the most specific
n_terms features.
</p>


<h3>See Also</h3>

<p><code><a href="quanteda.textstats.html#topic+textstat_keyness">quanteda.textstats::textstat_keyness()</a></code>, <code><a href="#topic+rainette_explor">rainette_explor()</a></code>, <code><a href="#topic+rainette_plot">rainette_plot()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(quanteda)
corpus &lt;- data_corpus_inaugural
corpus &lt;- head(corpus, n = 10)
corpus &lt;- split_segments(corpus)
tok &lt;- tokens(corpus, remove_punct = TRUE)
tok &lt;- tokens_remove(tok, stopwords("en"))
dtm &lt;- dfm(tok, tolower = TRUE)
dtm &lt;- dfm_trim(dtm, min_docfreq = 3)
res &lt;- rainette(dtm, k = 3, min_segment_size = 15)
groups &lt;- cutree_rainette(res, k = 3)
rainette_stats(groups, dtm)

</code></pre>

<hr>
<h2 id='rainette2'>Corpus clustering based on the Reinert method - Double clustering</h2><span id='topic+rainette2'></span>

<h3>Description</h3>

<p>Corpus clustering based on the Reinert method - Double clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rainette2(
  x,
  y = NULL,
  max_k = 5,
  min_segment_size1 = 10,
  min_segment_size2 = 15,
  doc_id = NULL,
  min_members = 10,
  min_chi2 = 3.84,
  parallel = FALSE,
  full = TRUE,
  uc_size1,
  uc_size2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rainette2_+3A_x">x</code></td>
<td>
<p>either a quanteda dfm object or the result of <code><a href="#topic+rainette">rainette()</a></code></p>
</td></tr>
<tr><td><code id="rainette2_+3A_y">y</code></td>
<td>
<p>if <code>x</code> is a <code><a href="#topic+rainette">rainette()</a></code> result, this must be another <code><a href="#topic+rainette">rainette()</a></code>
result from same dfm but with different uc size.</p>
</td></tr>
<tr><td><code id="rainette2_+3A_max_k">max_k</code></td>
<td>
<p>maximum number of clusters to compute</p>
</td></tr>
<tr><td><code id="rainette2_+3A_min_segment_size1">min_segment_size1</code></td>
<td>
<p>if <code>x</code> is a dfm, minimum uc size for first clustering</p>
</td></tr>
<tr><td><code id="rainette2_+3A_min_segment_size2">min_segment_size2</code></td>
<td>
<p>if <code>x</code> is a dfm, minimum uc size for second clustering</p>
</td></tr>
<tr><td><code id="rainette2_+3A_doc_id">doc_id</code></td>
<td>
<p>character name of a dtm docvar which identifies source documents.</p>
</td></tr>
<tr><td><code id="rainette2_+3A_min_members">min_members</code></td>
<td>
<p>minimum members of each cluster</p>
</td></tr>
<tr><td><code id="rainette2_+3A_min_chi2">min_chi2</code></td>
<td>
<p>minimum chi2 for each cluster</p>
</td></tr>
<tr><td><code id="rainette2_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE, use <code>parallel::mclapply</code> to compute partitions
(won't work on Windows, uses more RAM)</p>
</td></tr>
<tr><td><code id="rainette2_+3A_full">full</code></td>
<td>
<p>if TRUE, all crossed groups are kept to compute optimal partitions, otherwise
only the most mutually associated groups are kept.</p>
</td></tr>
<tr><td><code id="rainette2_+3A_uc_size1">uc_size1</code></td>
<td>
<p>deprecated, use min_segment_size1 instead</p>
</td></tr>
<tr><td><code id="rainette2_+3A_uc_size2">uc_size2</code></td>
<td>
<p>deprecated, use min_segment_size2 instead</p>
</td></tr>
<tr><td><code id="rainette2_+3A_...">...</code></td>
<td>
<p>if <code>x</code> is a dfm object, parameters passed to <code><a href="#topic+rainette">rainette()</a></code> for both
simple clusterings</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can pass a quanteda dfm as <code>x</code> object, the function then performs two simple
clustering with varying minimum uc size, and then proceed to find optimal partitions
based on the results of both clusterings.
</p>
<p>If both clusterings have already been computed, you can pass them as <code>x</code> and <code>y</code> arguments
and the function will only look for optimal partitions.
</p>
<p><code>doc_id</code> must be provided unless the corpus comes from <code>split_segments</code>,
in this case <code>segment_source</code> is used by default.
</p>
<p>If <code>full = FALSE</code>, computation may be much faster, but the chi2 criterion will be the only
one available for best partition detection, and the result may not be optimal.
</p>
<p>For more details on optimal partitions search algorithm, please see package vignettes.
</p>


<h3>Value</h3>

<p>A tibble with optimal partitions found for each available value of <code>k</code> as rows, and the following
columns :
</p>

<ul>
<li> <p><code>clusters</code> list of the crossed original clusters used in the partition
</p>
</li>
<li> <p><code>k</code> the number of clusters
</p>
</li>
<li> <p><code>chi2</code> sum of the chi2 value of each cluster
</p>
</li>
<li> <p><code>n</code> sum of the size of each cluster
</p>
</li>
<li> <p><code>groups</code> group membership of each document for this partition (<code>NA</code> if not assigned)
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> Reinert M, Une méthode de classification descendante hiérarchique : application à l'analyse lexicale par contexte, Cahiers de l'analyse des données, Volume 8, Numéro 2, 1983. <a href="http://www.numdam.org/item/?id=CAD_1983__8_2_187_0">http://www.numdam.org/item/?id=CAD_1983__8_2_187_0</a>
</p>
</li>
<li><p> Reinert M., Alceste une méthodologie d'analyse des données textuelles et une application: Aurelia De Gerard De Nerval, Bulletin de Méthodologie Sociologique, Volume 26, Numéro 1, 1990.  <a href="https://doi.org/10.1177/075910639002600103">doi:10.1177/075910639002600103</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+rainette">rainette()</a></code>, <code><a href="#topic+cutree_rainette2">cutree_rainette2()</a></code>, <code><a href="#topic+rainette2_plot">rainette2_plot()</a></code>, <code><a href="#topic+rainette2_explor">rainette2_explor()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(quanteda)
corpus &lt;- data_corpus_inaugural
corpus &lt;- head(corpus, n = 10)
corpus &lt;- split_segments(corpus)
tok &lt;- tokens(corpus, remove_punct = TRUE)
tok &lt;- tokens_remove(tok, stopwords("en"))
dtm &lt;- dfm(tok, tolower = TRUE)
dtm &lt;- dfm_trim(dtm, min_docfreq = 3)

res1 &lt;- rainette(dtm, k = 5, min_segment_size = 10)
res2 &lt;- rainette(dtm, k = 5, min_segment_size = 15)

res &lt;- rainette2(res1, res2, max_k = 4)


</code></pre>

<hr>
<h2 id='rainette2_complete_groups'>Complete groups membership with knn classification</h2><span id='topic+rainette2_complete_groups'></span>

<h3>Description</h3>

<p>Starting with groups membership computed from a <code>rainette2</code> clustering,
every document not assigned to a cluster is reassigned using a k-nearest
neighbour classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rainette2_complete_groups(dfm, groups, k = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rainette2_complete_groups_+3A_dfm">dfm</code></td>
<td>
<p>dfm object used for <code>rainette2</code> clustering.</p>
</td></tr>
<tr><td><code id="rainette2_complete_groups_+3A_groups">groups</code></td>
<td>
<p>group membership computed by <code>cutree</code> on <code>rainette2</code> result.</p>
</td></tr>
<tr><td><code id="rainette2_complete_groups_+3A_k">k</code></td>
<td>
<p>number of neighbours considered.</p>
</td></tr>
<tr><td><code id="rainette2_complete_groups_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>FNN::knn</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Completed group membership vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cutree_rainette2">cutree_rainette2()</a></code>, <code><a href="FNN.html#topic+knn">FNN::knn()</a></code>
</p>

<hr>
<h2 id='rainette2_explor'>Shiny gadget for rainette2 clustering exploration</h2><span id='topic+rainette2_explor'></span>

<h3>Description</h3>

<p>Shiny gadget for rainette2 clustering exploration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rainette2_explor(res, dtm = NULL, corpus_src = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rainette2_explor_+3A_res">res</code></td>
<td>
<p>result object of a <code>rainette2</code> clustering</p>
</td></tr>
<tr><td><code id="rainette2_explor_+3A_dtm">dtm</code></td>
<td>
<p>the dfm object used to compute the clustering</p>
</td></tr>
<tr><td><code id="rainette2_explor_+3A_corpus_src">corpus_src</code></td>
<td>
<p>the quanteda corpus object used to compute the dtm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rainette2_plot">rainette2_plot()</a></code>
</p>

<hr>
<h2 id='rainette2_plot'>Generate a clustering description plot from a rainette2 result</h2><span id='topic+rainette2_plot'></span>

<h3>Description</h3>

<p>Generate a clustering description plot from a rainette2 result
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rainette2_plot(
  res,
  dtm,
  k = NULL,
  criterion = c("chi2", "n"),
  complete_groups = FALSE,
  type = c("bar", "cloud"),
  n_terms = 15,
  free_scales = FALSE,
  measure = c("chi2", "lr", "frequency", "docprop"),
  show_negative = FALSE,
  text_size = 10
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rainette2_plot_+3A_res">res</code></td>
<td>
<p>result object of a <code>rainette2</code> clustering</p>
</td></tr>
<tr><td><code id="rainette2_plot_+3A_dtm">dtm</code></td>
<td>
<p>the dfm object used to compute the clustering</p>
</td></tr>
<tr><td><code id="rainette2_plot_+3A_k">k</code></td>
<td>
<p>number of groups. If NULL, use the biggest number possible</p>
</td></tr>
<tr><td><code id="rainette2_plot_+3A_criterion">criterion</code></td>
<td>
<p>criterion to use to choose the best partition. <code>chi2</code> means
the partition with the maximum sum of chi2, <code>n</code> the partition with the
maximum size.</p>
</td></tr>
<tr><td><code id="rainette2_plot_+3A_complete_groups">complete_groups</code></td>
<td>
<p>if TRUE, documents with NA cluster are reaffected by
k-means clustering initialised with current groups centers.</p>
</td></tr>
<tr><td><code id="rainette2_plot_+3A_type">type</code></td>
<td>
<p>type of term plots : barplot or wordcloud</p>
</td></tr>
<tr><td><code id="rainette2_plot_+3A_n_terms">n_terms</code></td>
<td>
<p>number of terms to display in keyness plots</p>
</td></tr>
<tr><td><code id="rainette2_plot_+3A_free_scales">free_scales</code></td>
<td>
<p>if TRUE, all the keyness plots will have the same scale</p>
</td></tr>
<tr><td><code id="rainette2_plot_+3A_measure">measure</code></td>
<td>
<p>statistics to compute</p>
</td></tr>
<tr><td><code id="rainette2_plot_+3A_show_negative">show_negative</code></td>
<td>
<p>if TRUE, show negative keyness features</p>
</td></tr>
<tr><td><code id="rainette2_plot_+3A_text_size">text_size</code></td>
<td>
<p>font size for barplots, max word size for wordclouds</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A gtable object.
</p>


<h3>See Also</h3>

<p><code><a href="quanteda.textstats.html#topic+textstat_keyness">quanteda.textstats::textstat_keyness()</a></code>, <code><a href="#topic+rainette2_explor">rainette2_explor()</a></code>, <code><a href="#topic+rainette2_complete_groups">rainette2_complete_groups()</a></code>
</p>

<hr>
<h2 id='select_features'>Remove features from dtm of each group base don cc_test and tsj</h2><span id='topic+select_features'></span>

<h3>Description</h3>

<p>Remove features from dtm of each group base don cc_test and tsj
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_features(m, indices1, indices2, cc_test = 0.3, tsj = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_features_+3A_m">m</code></td>
<td>
<p>global dtm</p>
</td></tr>
<tr><td><code id="select_features_+3A_indices1">indices1</code></td>
<td>
<p>indices of documents of group 1</p>
</td></tr>
<tr><td><code id="select_features_+3A_indices2">indices2</code></td>
<td>
<p>indices of documents of group 2</p>
</td></tr>
<tr><td><code id="select_features_+3A_cc_test">cc_test</code></td>
<td>
<p>maximum contingency coefficient value for the
feature to be kept in both groups.</p>
</td></tr>
<tr><td><code id="select_features_+3A_tsj">tsj</code></td>
<td>
<p>minimum feature frequency in the dtm</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal function, not to be used directly
</p>


<h3>Value</h3>

<p>a list of two character vectors : <code>cols1</code> is the name of features to
keep in group 1, <code>cols2</code> the name of features to keep in group 2
</p>

<hr>
<h2 id='split_segments'>Split a character string or corpus into segments</h2><span id='topic+split_segments'></span><span id='topic+split_segments.character'></span><span id='topic+split_segments.Corpus'></span><span id='topic+split_segments.corpus'></span><span id='topic+split_segments.tokens'></span>

<h3>Description</h3>

<p>Split a character string or corpus into segments, taking into account punctuation where possible
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_segments(obj, segment_size = 40, segment_size_window = NULL)

## S3 method for class 'character'
split_segments(obj, segment_size = 40, segment_size_window = NULL)

## S3 method for class 'Corpus'
split_segments(obj, segment_size = 40, segment_size_window = NULL)

## S3 method for class 'corpus'
split_segments(obj, segment_size = 40, segment_size_window = NULL)

## S3 method for class 'tokens'
split_segments(obj, segment_size = 40, segment_size_window = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_segments_+3A_obj">obj</code></td>
<td>
<p>character string, quanteda or tm corpus object</p>
</td></tr>
<tr><td><code id="split_segments_+3A_segment_size">segment_size</code></td>
<td>
<p>segment size (in words)</p>
</td></tr>
<tr><td><code id="split_segments_+3A_segment_size_window">segment_size_window</code></td>
<td>
<p>window around segment size to look for best splitting point</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If obj is a tm or quanteda corpus object, the result is a quanteda corpus.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(quanteda)
split_segments(data_corpus_inaugural)

</code></pre>

<hr>
<h2 id='switch_docs'>Switch documents between two groups to maximize chi-square value</h2><span id='topic+switch_docs'></span>

<h3>Description</h3>

<p>Switch documents between two groups to maximize chi-square value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>switch_docs(m, indices, max_index, max_chisq)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="switch_docs_+3A_m">m</code></td>
<td>
<p>original dtm</p>
</td></tr>
<tr><td><code id="switch_docs_+3A_indices">indices</code></td>
<td>
<p>documents indices orderes by first CA axis coordinates</p>
</td></tr>
<tr><td><code id="switch_docs_+3A_max_index">max_index</code></td>
<td>
<p>document index where the split is maximum</p>
</td></tr>
<tr><td><code id="switch_docs_+3A_max_chisq">max_chisq</code></td>
<td>
<p>maximum chi-square value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal function, not to be used directly
</p>


<h3>Value</h3>

<p>a list of two vectors <code>indices1</code> and <code>indices2</code>, which contain
the documents indices of each group after documents switching, and a <code>chisq</code> value,
the new corresponding chi-square value after switching
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
