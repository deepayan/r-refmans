<!DOCTYPE html><html lang="en"><head><title>Help for package nsROC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nsROC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#nsROC-package'><p>nsROC</p></a></li>
<li><a href='#cdROC'><p>Cumulative/dynamic ROC curve estimate</p></a></li>
<li><a href='#checkROC'><p>Check data to compute an ROC curve</p></a></li>
<li><a href='#compareROCdep'><p>Comparison of k paired ROC curves</p></a></li>
<li><a href='#compareROCindep'><p>Comparison of k independent ROC curves</p></a></li>
<li><a href='#gROC'><p>ROC curve estimation (generalization included)</p></a></li>
<li><a href='#interleukin6'>
<p>Interleukin 6 (IL6) data</p></a></li>
<li><a href='#metaROC'><p>Non-parametric ROC curve estimate for meta-analysis</p></a></li>
<li><a href='#plot'>
<p>Plot an ROC curve object</p></a></li>
<li><a href='#print'>
<p>Print an ROC curve object</p></a></li>
<li><a href='#ROCbands'><p>Confidence bands for ROC curves</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Non-Standard ROC Curve Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Sonia Perez Fernandez</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sonia Perez Fernandez &lt;uo217889@uniovi.es&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for estimating Receiver Operating Characteristic (ROC) curves,
        building confidence bands, comparing several curves both for dependent and 
        independent data, estimating the cumulative-dynamic ROC curve in presence of
        censored data, and performing meta-analysis studies, among others.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, methods, utils, graphics, sde, survival</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mvtnorm</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-08-07 08:35:28 UTC; sonia</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-08-07 09:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='nsROC-package'>nsROC</h2><span id='topic+nsROC-package'></span><span id='topic+nsROC'></span>

<h3>Description</h3>

<p>Tools for estimating Receiver Operating Characteristic (ROC) curves,
building confidence bands, comparing several curves both for dependent and
independent data, estimating the cumulative-dynamic ROC curve in presence
of censored data, and performing meta-analysis studies, among others.
</p>


<h3>Details</h3>

<p>The basic function of the nsROC package is the <code><a href="#topic+gROC">gROC</a></code> function. It
will estimate an ROC curve under one of these considerations: larger values of
the marker are associated with a higher probability of being positive (right-sided),
the opposite (left-sided) or when both smaller and larger values of the marker
are associated with having more probability of being positive (both).
</p>
<p>Confidence bands for an ROC curve estimate resulting of the previous function can
be computed and displayed by the <code><a href="#topic+ROCbands">ROCbands</a></code> function. Three different
methods are provided to compute them.
</p>
<p>Several paired or unpaired ROC curves can be compared with the <code><a href="#topic+compareROCdep">compareROCdep</a></code>
or <code><a href="#topic+compareROCindep">compareROCindep</a></code> function, respectively. In order to compare ROC curves
different statistics can be used, and to approximate the distribution of the statistic in
the paired case both permutation and bootstrap procedures are computed.
</p>
<p>Time-dependent ROC curves can be estimated by the cumulative/dynamic approach using
the <code><a href="#topic+cdROC">cdROC</a></code> function. In order to deal with the right censored problem three
different statistics can be considered.
</p>
<p>Meta-analysis of ROC curves following a non-parametric approach can be performed with
the <code><a href="#topic+metaROC">metaROC</a></code> function. Both the fixed-effects and random-effects model can
be considered.
</p>


<h3>Abbreviations</h3>

<p>The following abbreviations are frequently used in this package:
</p>

<ul>
<li><p> ROC: Receiver Operating Characteristic
</p>
</li>
<li><p> AUC: Area Under the (ROC) Curve
</p>
</li>
<li><p> Sp: Specificity
</p>
</li>
<li><p> Se: Sensitivity
</p>
</li>
<li><p> TPR: True-Positive Rate
</p>
</li>
<li><p> FPR: False-Positive Rate
</p>
</li></ul>



<h3>Functions</h3>


<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+gROC">gROC</a></code> </td><td style="text-align: left;"> ROC curve estimate (generalization included) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+ROCbands">ROCbands</a></code> </td><td style="text-align: left;"> Confidence bands for ROC curves </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+compareROCdep">compareROCdep</a></code> </td><td style="text-align: left;"> Comparison of k paired ROC curves </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+compareROCindep">compareROCindep</a></code> </td><td style="text-align: left;"> Comparison of k independent ROC curves </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+cdROC">cdROC</a></code> </td><td style="text-align: left;"> Cumulative/dynamic ROC curve estimate </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+metaROC">metaROC</a></code> </td><td style="text-align: left;"> Non-parametric ROC curve estimate for meta-analysis </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+plot.groc">plot</a></code> </td><td style="text-align: left;"> Plot an ROC curve </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+plot.rocbands">plot</a></code> </td><td style="text-align: left;"> Plot confidence bands for an ROC curve </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+plot.cdroc">plot</a></code> </td><td style="text-align: left;"> Plot a time-dependent ROC curve </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+print.groc">print</a></code> </td><td style="text-align: left;"> Print a <code>groc</code> object </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+print.rocbands">print</a></code> </td><td style="text-align: left;"> Print a <code>rocbands</code> object </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+print.cdroc">print</a></code> </td><td style="text-align: left;"> Print a <code>cdroc</code> object </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+checkROC">checkROC</a></code> </td><td style="text-align: left;"> Check the data to compute an ROC curve (internal function)
  </td>
</tr>

</table>



<h3>Dataset</h3>

<p>This package comes with a dataset of 9 papers (meta-analysis) with the number of TP
(true positive), FP (false positive), TN (true negative) and FN (false negative)
about the use of the Interleukin6 (IL6) as a marker for the early detection of
neonatal sepsis: <code><a href="#topic+interleukin6">interleukin6</a></code>.
</p>


<h3>Installing and using</h3>

<p>To install this package:
</p>
<pre>
    install.packages("nsROC")
  </pre>
<p>To load the package:
</p>
<pre>
    library(nsROC)
  </pre>


<h3>Author(s)</h3>

<p>Sonia Perez-Fernandez
</p>
<p>Maintainer: Sonia Perez Fernandez &lt;uo217889@uniovi.es&gt;
</p>


<h3>See Also</h3>

<p>CRAN packages <span class="pkg">sde</span> and <span class="pkg">survival</span> employed in this package.
</p>

<hr>
<h2 id='cdROC'>Cumulative/dynamic ROC curve estimate
</h2><span id='topic+cdROC'></span><span id='topic+cdROC.default'></span>

<h3>Description</h3>

<p>This function estimates a time-dependent ROC curve following the cumulative/dynamic approach and returns a 'cdroc' object. This object can be <code>printed</code> or <code>plotted</code>. To deal with the right censored problem different statistics can be considered: those ones proposed by <em>Martinez-Camblor et al. (2016)</em> based on the hazard Cox regression model (semiparametric) or the Kaplan-Meier estimator (non-parametric); and the one included in <em>Li et al. (2016)</em> based on the kernel-weighted Kaplan-Meier method. See <em>References</em> below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdROC(stime, status, marker, predict.time, ...)
## Default S3 method:
cdROC(stime, status, marker, predict.time, method=c('Cox', 'KM', 'wKM'),
      kernel=c('normal', 'Epanechnikov', 'other'), h=1,
      kernel.fun = function(x,xi,h){u &lt;- (x-xi)/h; 1/(2*h)*(abs(u) &lt;= 1)},
      ci=FALSE, boot.n=100, conf.level=0.95, seed=2032, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cdROC_+3A_stime">stime</code></td>
<td>

<p>vector of observed times.</p>
</td></tr>
<tr><td><code id="cdROC_+3A_status">status</code></td>
<td>

<p>vector of status (takes the value 0 if the subject is censored and 1 otherwise).</p>
</td></tr>
<tr><td><code id="cdROC_+3A_marker">marker</code></td>
<td>

<p>vector of (bio)marker values.</p>
</td></tr>
<tr><td><code id="cdROC_+3A_predict.time">predict.time</code></td>
<td>

<p>considered time point (scalar).</p>
</td></tr>
<tr><td><code id="cdROC_+3A_method">method</code></td>
<td>

<p>procedure used to estimate the probability. One of &quot;Cox&quot; (method based on Cox regression), &quot;KM&quot; (method based on Kaplan-Meier estimator) or &quot;wKM&quot; (method based on kernel-weighted Kaplan-Meier estimator).</p>
</td></tr>
<tr><td><code id="cdROC_+3A_kernel">kernel</code></td>
<td>

<p>procedure used to calculate the kernel function. One of &quot;normal&quot;, &quot;Epanechnikov&quot; or &quot;other&quot;.  Only considered if <code>method='wKM'</code>.</p>
</td></tr>
<tr><td><code id="cdROC_+3A_h">h</code></td>
<td>

<p>bandwith used to calculate the kernel function. Only considered if <code>method='wKM'</code>.</p>
</td></tr>
<tr><td><code id="cdROC_+3A_kernel.fun">kernel.fun</code></td>
<td>

<p>if <code>method='wKM'</code> and <code>kernel='other'</code>, function used to calculate the kernel function. It has three input parameters: <code>x</code>=vector, <code>xi</code>=value around which the kernel weight should be computed, <code>h</code>=bandwidth. Default: Uniform kernel.</p>
</td></tr>
<tr><td><code id="cdROC_+3A_ci">ci</code></td>
<td>

<p>if TRUE, a confidence interval for the area under the curve is computed.</p>
</td></tr>
<tr><td><code id="cdROC_+3A_boot.n">boot.n</code></td>
<td>

<p>number of bootstrap replicates considered to build the confidence interval. Default: 100.</p>
</td></tr>
<tr><td><code id="cdROC_+3A_conf.level">conf.level</code></td>
<td>

<p>the width of the confidence band as a number in (0,1). Default: 0.95, resulting in a 95% confidence band.</p>
</td></tr>
<tr><td><code id="cdROC_+3A_seed">seed</code></td>
<td>

<p>seed considered to generate bootstrap replicates (for reproducibility).
</p>
</td></tr>
<tr><td><code id="cdROC_+3A_...">...</code></td>
<td>

<p>additional arguments for <code>cdROC</code>. Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assuming that larger values of the marker are associated with higher probabilities of occurrence of the event, the cumulative sensitivity and the dynamic specificity are defined by:
</p>
<p><code class="reqn">Se^C(x,t) = P(</code><code>marker</code> <code class="reqn">&gt; x | </code><code>stime</code> <code class="reqn">\le t)</code>   and   <code class="reqn">Sp^D(x,t) = P(</code><code>marker</code> <code class="reqn">\le x |</code> <code>stime</code> <code class="reqn">&gt; t)</code>.
</p>
<p>The resulting ROC curve is known as the cumulative/dynamic ROC curve, <code class="reqn">R_t^{C/D}</code>, where <code class="reqn">t = </code> <code>predict.time</code>.
</p>
<p>Data censored before <code class="reqn">t</code> is the major handicap with regard to the estimation of the time-dependent ROC curve. In order to estimate the probability of surviving beyond <code class="reqn">t</code> for the <code class="reqn">i</code>-th subject, <code class="reqn">\hat{P}_i</code>, three different methods are considered:
</p>

<ul>
<li><p>A semiparametric one, using a proportional hazard Cox regression model:
</p>
<p>The hazard function is estimated by <code class="reqn">\lambda(t) = \lambda_0(t) \cdot exp(\beta \cdot X)</code> where <code class="reqn">X</code> denotes the marker.
</p>
<p>The probability is estimated by <code class="reqn">\hat{P}_i = \frac{\hat{S}(t | X = x_i)}{\hat{S}(z_i | X = x_i)}</code> where <code class="reqn">z_i</code> stands for the observed time of the <code class="reqn">i</code>-th subject and <code class="reqn">\hat{S}</code> is the survival function estimated from the Cox regression model.
</p>
</li>
<li><p>A non-parametric one, using the Kaplan-Meier estimator directly:
</p>
<p>The probability is estimated by <code class="reqn">\hat{P}_i = \frac{\hat{S}(t)}{\hat{S}(z_i)}</code> where <code class="reqn">z_i</code> stands for the observed time of the <code class="reqn">i</code>-th subject and <code class="reqn">\hat{S}</code> is the survival function estimated by the Kaplan-Meier method referred to those subjects satisfying <code class="reqn">X \le x_i</code>.
</p>
</li>
<li><p>A non-parametric one, using the kernel-weighted Kaplan-Meier estimator:
</p>
<p>The survival function is estimated by <code class="reqn">\hat{S}(t | X = x_i) = \prod_{s \leq t} \left[ 1- \frac{\sum_{j=1}^n K_h(x_j,x_i) I(z_j = s) status_j}{\sum_{j=1}^n K_h(x_j,x_i) I(z_j = s)} \right]</code> where <code class="reqn">z_j</code> stands for the observed time of the <code class="reqn">j</code>-th subject, <code class="reqn">I</code> is the indicator function and <code class="reqn">status_j</code> takes the value 0 if the <code class="reqn">j</code>-th subject is censored and 1 otherwise.
</p>
<p>Two different methods can be considered in order to define the kernel function, <code class="reqn">K_h(x_j,x_i)</code>:
</p>

<ul>
<li><p><code>kernel='normal'</code>: 
</p>
<p><code class="reqn">K_h(x_j,x_i) =  \frac{1}{h \sqrt{2 \pi}} exp\{ - \frac{(x_j - x_i)^2}{2 h^2} \}</code>
</p>
</li>
<li><p><code>kernel='Epanechnikov'</code>: 
</p>
<p><code class="reqn">K_h(x_j,x_i) = \frac{3}{4h} \left( 1 - \frac{x_j - x_i}{h}  \right) I(|x_j - x_i| \le h)</code>
</p>
</li></ul>

<p>where <code class="reqn">h</code> is the bandwidth considered for kernel weights.
</p>
<p>If the user decide to use another kernel function, <code>kernel='other'</code>, it should be defined by the <code>kernel.fun</code> input parameter, which has three parameters following this order: <code>x</code> is a vector, <code>xi</code> is the value around which the kernel weight should be computed and <code>h</code> is the bandwidth.
</p>
<p>The probability is estimated by <code class="reqn">\hat{P}_i = \frac{\hat{S}(t | X = x_i)}{\hat{S}(z_i | X = x_i)}</code> where <code class="reqn">z_i</code> stands for the observed time of the <code class="reqn">i</code>-th subject and <code class="reqn">\hat{S}</code> is the survival function estimated by the kernel-weighted Kaplan-Meier method considered above.
</p>
</li></ul>



<h3>Value</h3>

<p>A list of class 'cdroc' with the following content:
</p>
<table role = "presentation">
<tr><td><code>TP</code></td>
<td>

<p>vector of sensitivities (true positive rates).</p>
</td></tr>
<tr><td><code>TN</code></td>
<td>

<p>vector of specificities (true negative rates).</p>
</td></tr>
<tr><td><code>cutPoints</code></td>
<td>

<p>vector of thresholds considered for the (bio)marker. It coincides with the <code>marker</code> vector adding <code class="reqn">min(</code><code>marker</code><code class="reqn">)-1</code> and <code class="reqn">max(</code><code>marker</code><code class="reqn">)+1</code>.</p>
</td></tr>
<tr><td><code>auc</code></td>
<td>

<p>area under the curve estimate by trapezoidal rule.</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>

<p>if TRUE, a confidence interval for the area under the curve has been computed.</p>
</td></tr>
<tr><td><code>boot.n</code></td>
<td>

<p>number of bootstrap replicates considered to build the confidence interval. Default: 100.</p>
</td></tr>
<tr><td><code>conf.level</code></td>
<td>

<p>the width of the confidence band as a number in (0,1). Default: 0.95, resulting in a 95% confidence band.</p>
</td></tr>
<tr><td><code>seed</code></td>
<td>

<p>seed considered to generate bootstrap replicates (for reproducibility).
</p>
</td></tr>
<tr><td><code>meanAuc</code></td>
<td>

<p>bootstrap area under the curve estimate (mean along bootstrap replicates).
</p>
</td></tr>
<tr><td><code>ciAuc</code></td>
<td>

<p>bootstrap confidence interval for the area under the curve.
</p>
</td></tr>
<tr><td><code>aucs</code></td>
<td>

<p>vector of bootstrap area under the curve estimates.
</p>
</td></tr>
<tr><td><code>stime</code></td>
<td>

<p>vector of observed times.</p>
</td></tr>
<tr><td><code>status</code></td>
<td>

<p>vector of status (takes the value 0 if the subject is censored and 1 otherwise).</p>
</td></tr>
<tr><td><code>marker</code></td>
<td>

<p>vector of (bio)marker values.</p>
</td></tr>
<tr><td><code>predict.time</code></td>
<td>

<p>considered time point (scalar).</p>
</td></tr>
<tr><td><code>method</code></td>
<td>

<p>procedure used in order to estimate the probability.</p>
</td></tr>
<tr><td><code>kernel</code></td>
<td>

<p>procedure used to calculate the kernel function. Only considered if <code>method='wKM'</code>.</p>
</td></tr>
<tr><td><code>h</code></td>
<td>

<p>bandwith used to calculate the kernel function. Only considered if <code>method='wKM'</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>survfit</code> and <code>Surv</code> functions in <code>survival</code> package are used in order to estimate the survival functions in both methodologies. Additionally, <code>coxph</code> from the same package is used to fit the Cox proportional hazard regression model in the semiparametric approach.
</p>


<h3>References</h3>

<p>Martinez-Camblor P., F-Bayon G., Perez-Fernandez S., 2016, Cumulative/dynamic ROC curve estimation, <em>Journal of Statistical Computation and Simulation</em>, <b>86</b>(17), 3582-3594.
</p>
<p>Li L., Greene T., Hu B., 2016, A simple method to estimate the time-dependent receiver operating characteristic curve and the area under the curve with right censored data, <em>Statistical Methods in Medical Research</em>, DOI: 10.1177/0962280216680239.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Basic example. Data
set.seed(123)
stime &lt;- rchisq(50,3)
status &lt;- sample(c(rep(1,40), rep(0,10)))
marker &lt;- max(stime) - stime + rnorm(50,0,2)

# Cumulative/dynamic ROC curve estimate at time 2.8 (Cox method is used) with 0.95 confidence
# interval for the area under the curve
cdROC(stime, status, marker, 2.8, ci=TRUE)

# Cumulative/dynamic ROC curve estimate at time 3.1 (Kaplan-Meier method is used)
cdROC(stime, status, marker, 3.1, method="KM")

# Cumulative/dynamic ROC curve estimate at time 3 (kernel-weighted Kaplan-Meier method with
# gaussian kernel and bandwidth 1 is used)
cdROC(stime, status, marker, 3, method="wKM")

# Cumulative/dynamic ROC curve estimate at time 3 (kernel-weighted Kaplan-Meier method with
# biweight kernel and bandwidth equals to 2 is used)
cdROC(stime, status, marker, 3, method="wKM", kernel="other", h=2,
      kernel.fun = function(x,xi,h){u &lt;- (x-xi)/h; 15/(16*h)*(1-u^2)^2*(abs(u)&lt;=1)})
</code></pre>

<hr>
<h2 id='checkROC'>Check data to compute an ROC curve
</h2><span id='topic+checkROC'></span>

<h3>Description</h3>

<p>This internal function checks if the data introduced for building the curve is correct or not. It shows if there are some missing marker or response values and whether there are less or more than two levels at the response vector, D.
It also splits the data into two groups: controls and cases, depending on the corresponding value in the response vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkROC(X,D)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkROC_+3A_x">X</code></td>
<td>

<p>vector of (bio)marker values. It should be numeric.</p>
</td></tr>
<tr><td><code id="checkROC_+3A_d">D</code></td>
<td>

<p>vector of response values. It should contain at least two different levels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code will not run and an error will be showed in these cases:
</p>
<ul>
<li><p><code>X</code> or <code>D</code> is missing,
</p>
</li>
<li><p><code>X</code> or <code>D</code> is NULL or full of NA's,
</p>
</li>
<li><p><code>X</code> is not a numeric vector,
</p>
</li>
<li><p><code>D</code> has less than two different values, and/or
</p>
</li>
<li><p><code>X</code> and <code>D</code> have different lengths.
</p>
</li></ul>

<p>If the response vector has more than two different levels, only the two first ones are considered as controls and cases, respectively.
</p>
<p>If the user does not agree with the codification, it can be changed modifying the order of the levels using the <code>factor</code> function; for instance, <code>factor(D, levels=c("1","0"))</code>.</p>


<h3>Value</h3>

<p>If the marker and response vectors are correct a list with the following fields is returned:
</p>
<table role = "presentation">
<tr><td><code>levels</code></td>
<td>
<p>levels in <code>D</code>. The two first ones are the labels of <code>D</code> considered as controls and cases, respectively.</p>
</td></tr>
<tr><td><code>controls</code></td>
<td>
<p>marker values for controls.</p>
</td></tr>
<tr><td><code>cases</code></td>
<td>
<p>marker values for cases.</p>
</td></tr>
<tr><td><code>n0</code></td>
<td>
<p>number of controls.</p>
</td></tr>
<tr><td><code>n1</code></td>
<td>
<p>number of cases.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>marker values corresponding to controls and cases (in this order).</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>response vector consisting of <code>n0</code> repetitions of <code>levels[1]</code> and <code>n1</code> repetitions of <code>levels[2]</code> (in this order).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Basic example with full information
set.seed(123)
X &lt;- c(rnorm(45), rnorm(30,2,1.5))
D &lt;- c(rep(0,45), rep(1,30))
checkROC(X,D)

# Example with some missing values and more than two levels
X &lt;- replace(c(rnorm(25), rnorm(30,2,1.5), rnorm(20,-3,1)), seq(1,75,5), NA)
D &lt;- replace(c(rep(0,25), rep(1,30), rep(2,20)), seq(1,75,11), NA)
checkROC(X,D)
</code></pre>

<hr>
<h2 id='compareROCdep'>Comparison of k paired ROC curves</h2><span id='topic+compareROCdep'></span><span id='topic+compareROCdep.default'></span>

<h3>Description</h3>

<p>This function compares k ROC curves from dependent data. Different statistics can be considered in order to perform the comparison: those ones included in <em>Martinez-Camblor et al. (2013)</em> based on general distances between functions, the <em>Venkatraman et al. (1996)</em> methodology for comparing diagnostic the accuracy of the k markers based on data from a paired design and the <em>DeLong et al. (1988)</em> one based on the AUC (area under the curve) comparison. Two different methods could be considered to approximate the distribution function of the statistic: the procedure proposed by <em>Venkatraman et al. (1996)</em> (based on permutated samples) or the one introduced by <em>Martinez-Camblor et al. (2012)</em> (based on bootstrap samples). See <em>References</em> below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareROCdep(X, D, ...)
## Default S3 method:
compareROCdep(X, D, method=c("general.bootstrap","permutation","auc"),
              statistic=c("KS","L1","L2","CR","VK","other"),
              FUN.dist=function(g){max(abs(g))}, side=c("right","left"),
              Ni=1000, B=500, perm=500, seed=123, h.fun=function(H,x){
              H*sd(x)*length(x)^{-1/3}}, H=1, plot.roc=TRUE, type='s', lwd=3,
              lwd.curves=rep(2,ncol(X)), lty=1, lty.curves=rep(1,ncol(X)),
              col='black',col.curves=rainbow(ncol(X)), cex.lab=1.2,
              legend=c(sapply(1:ncol(X), function(i){eval(bquote(expression(
              hat(R)[.(i)](t))))}), expression(hat(R)(t))),
              legend.position='bottomright', legend.inset=0.03,
              cex.legend=1, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compareROCdep_+3A_x">X</code></td>
<td>

<p>a matrix of k columns in which each column is the vector of (bio)marker values corresponding to each sample.</p>
</td></tr>
<tr><td><code id="compareROCdep_+3A_d">D</code></td>
<td>

<p>the vector of response values.</p>
</td></tr>
<tr><td><code id="compareROCdep_+3A_method">method</code></td>
<td>

<p>the method used to approximate the statistic distribution. One of &quot;general.bootstrap&quot; (<em>Martinez-Camblor et al. (2012)</em>), &quot;permutation&quot; (<em>Venkatraman et al. (1996)</em>) or &quot;auc&quot; (<em>DeLong et al. (1988)</em>).</p>
</td></tr>
<tr><td><code id="compareROCdep_+3A_statistic">statistic</code></td>
<td>

<p>the statistic used to compare the curves. One of &quot;KS&quot; (Kolmogorov-Smirnov criteria), &quot;L1&quot; (<code class="reqn">L_1</code>-measure), &quot;L2&quot; (<code class="reqn">L_2</code>-measure), &quot;CR&quot; (Cramer-von Mises), &quot;other&quot; (another statistic defined by the <code>FUN.dist</code> input parameter), &quot;VK&quot; (Venkatraman) or &quot;AUC&quot; (area under the curve).</p>
</td></tr>
<tr><td><code id="compareROCdep_+3A_fun.dist">FUN.dist</code></td>
<td>

<p>the distance considered as a function of one variable. If <code>statistic="other"</code> the statistic considered is <code class="reqn">\sum_{i=1}^k</code> <code>FUN.dist</code>(<code class="reqn">\sqrt{n_1}(\hat{R}_i(t) - \hat{R}(t)</code>) where <code class="reqn">n_1</code> is the number of cases, <code class="reqn">\hat{R}_i(t)</code> is the ROC curve estimate from the i-th sample and <code class="reqn">\hat{R}(t) := k^{-1} \sum_{i=1}^k \hat{R}_i(t)</code>.</p>
</td></tr>
<tr><td><code id="compareROCdep_+3A_side">side</code></td>
<td>

<p>type of ROC curve. One of &quot;right&quot; or &quot;left&quot;. If <code>method="VK"</code> only right-sided could be considered.</p>
</td></tr>
<tr><td><code id="compareROCdep_+3A_ni">Ni</code></td>
<td>

<p>number of subintervals of the unit interval (FPR values) considered to calculate the curve. Default: 1000.</p>
</td></tr>
<tr><td><code id="compareROCdep_+3A_b">B</code></td>
<td>

<p>number of bootstrap samples if <code>method="general.bootstrap"</code>. Default: 500.</p>
</td></tr>
<tr><td><code id="compareROCdep_+3A_perm">perm</code></td>
<td>

<p>number of permutations if <code>method="permutation"</code>. Default: 500.</p>
</td></tr>
<tr><td><code id="compareROCdep_+3A_seed">seed</code></td>
<td>

<p>seed considered to generate the permutations (for reproducibility). Default: 123.
</p>
</td></tr>
<tr><td><code id="compareROCdep_+3A_h.fun">h.fun</code></td>
<td>

<p>a function defining the bandwidth calculus used to generate the bootstrap samples if <code>method="general.bootstrap"</code>. It has two arguments: the first one referred to the <code>H</code> value and the second one, <code>x</code>, referred to the sample. Default: <code>function(H,x){H*sd(x)*length(x)^{-1/3}}</code>.</p>
</td></tr>
<tr><td><code id="compareROCdep_+3A_h">H</code></td>
<td>

<p>the value used to compute <code>h.fun</code>, that is, the bandwidth. Default: 1.
</p>
</td></tr>
<tr><td><code id="compareROCdep_+3A_plot.roc">plot.roc</code></td>
<td>

<p>if TRUE, a plot including ROC curve estimates for the k samples and the mean of all of them is displayed.</p>
</td></tr>
<tr><td><code id="compareROCdep_+3A_type">type</code></td>
<td>

<p>what type of plot should be drawn.</p>
</td></tr>
<tr><td><code id="compareROCdep_+3A_lwd">lwd</code></td>
<td>

<p>the line width to be used for mean ROC curve estimate.</p>
</td></tr>
<tr><td><code id="compareROCdep_+3A_lwd.curves">lwd.curves</code></td>
<td>

<p>a vector with the line widths to be used for ROC curve estimates of each sample.</p>
</td></tr>
<tr><td><code id="compareROCdep_+3A_lty">lty</code></td>
<td>

<p>the line type to be used for mean ROC curve estimate.</p>
</td></tr>
<tr><td><code id="compareROCdep_+3A_lty.curves">lty.curves</code></td>
<td>

<p>a vector with the line types to be used for ROC curve estimates of each sample.</p>
</td></tr>
<tr><td><code id="compareROCdep_+3A_col">col</code></td>
<td>

<p>the color to be used for mean ROC curve estimate.</p>
</td></tr>
<tr><td><code id="compareROCdep_+3A_col.curves">col.curves</code></td>
<td>

<p>a vector with the colors to be used for ROC curve estimates of each sample.</p>
</td></tr>
<tr><td><code id="compareROCdep_+3A_cex.lab">cex.lab</code></td>
<td>

<p>the magnification to be used for x and y labels relative to the current setting of <code>cex</code>.</p>
</td></tr>
<tr><td><code id="compareROCdep_+3A_legend">legend</code></td>
<td>

<p>a character or expression vector to appear in the legend.</p>
</td></tr>
<tr><td><code id="compareROCdep_+3A_legend.position">legend.position</code>, <code id="compareROCdep_+3A_legend.inset">legend.inset</code>, <code id="compareROCdep_+3A_cex.legend">cex.legend</code></td>
<td>

<p>the position of the legend, the inset distance from the margins as a fraction of the plot region when legend is placed and the character expansion factor relative to current <code>par("cex")</code>, respectively.</p>
</td></tr>
<tr><td><code id="compareROCdep_+3A_...">...</code></td>
<td>

<p>another graphical parameters to be passed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First of all, the data introduced is checked and those subjects with some missing information (marker or response value(s)) are removed. Data from a paired design should have the same length along the samples. If this is not fulfilled the code will not run and an error will be showed.
</p>
<p>If the Venkatraman statistic is chosen in order to compare left-sided ROC curves, an error will be displayed and it will not work. The Venkatraman methodology is just implemented for right-sided ROC curves. Furthermore, for this statistics, <code>method="permutation"</code> is automatically assigned.
</p>
<p>The statistic is defined by <code class="reqn">\sum_{i=1}^k</code> <code>FUN.dist</code>(<code class="reqn">\sqrt{n_1} \cdot (\hat{R}_i(t) - \hat{R}(t))</code>) where <code>FUN.dist</code> stands by the distance function, <code class="reqn">n_1</code> is the number of cases, <code class="reqn">\hat{R}_i(t)</code> is the ROC curve estimate from the i-th sample and <code class="reqn">\hat{R}(t) := k^{-1} \sum_{i=1}^k \hat{R}_i(t)</code>.
</p>
<p>The statistics implemented are defined by the following <code>FUN.dist</code> functions:
</p>

<ul>
<li><p><code>statistic="KS"</code>:
</p>
<p><code>FUN.dist(g) = max(abs(g))</code>
</p>
</li>
<li><p><code>statistic="L1"</code>:
</p>
<p><code>FUN.dist(g) = mean(abs(g))</code>
</p>
</li>
<li><p><code>statistic="L2"</code>:
</p>
<p><code>FUN.dist(g) = mean(g^2)</code>
</p>
</li>
<li><p><code>statistic="CR"</code>:
</p>
<p><code>FUN.dist.CR(g,h) = sum(g[-length(g)]^2*(h[-1]-h[-length(h)]))</code>
</p>
<p><em>Cramer von-Mises</em> statistic is defined by <code class="reqn">\sum_{i=1}^k</code> <code>FUN.dist.CR</code>(<code class="reqn">\sqrt{n_1} \cdot (\hat{R}_i(t) - \hat{R}(t))</code>, <code class="reqn">\hat{R}(t)</code>)
</p>
</li></ul>

<p>In case of <code>statistic="VK"</code> the Venkatraman methodology (see <em>References</em> below) is computed to calculate the statistic. If <code class="reqn">k&gt;2</code> the statistic value is the sum of statistic values of each pair such that <code class="reqn">i &lt; j</code>.
</p>
<p>If <code>method="general.bootstrap"</code> it is necessary to have a bandwidth in order to compute the bootstrap samples from the smoothed (the gaussian kernel is considered) multivariate empirical distribution functions referred to controls and cases. This bandwidth is defined by the <code>h.FUN</code> function whose parameters are a bandwidth constant parameter defined by the user, <code>H</code>, and the sample (cases or controls values of the marker) considered, <code>x</code>.
</p>
<p>If <code>method="auc"</code>, the methodology proposed by <em>DeLong et al.</em> is implemented. This option is slower because of the Mann-Whitney statistic inside requires <code class="reqn">number~of~cases \cdot number~of~controls</code> comparisons. In this case, <code>statistic</code> returns the value of the Mann-Whitney statistic estimate and <code>test.statistic</code> the final test statistic estimate (formula (5) in the paper) which follows a chi-square distribution.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>n.controls</code></td>
<td>

<p>the number of controls.
</p>
</td></tr>
<tr><td><code>n.cases</code></td>
<td>

<p>the number of cases.
</p>
</td></tr>
<tr><td><code>controls.k</code></td>
<td>

<p>a matrix whose columns are the controls along the k samples.
</p>
</td></tr>
<tr><td><code>cases.k</code></td>
<td>

<p>a matrix whose columns are the cases along the k samples.
</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>

<p>the value of the test statistic.
</p>
</td></tr>
<tr><td><code>stat.boot</code></td>
<td>

<p>a vector of statistic values for bootstrap replicates if <code>method="general.bootstrap"</code>.
</p>
</td></tr>
<tr><td><code>stat.perm</code></td>
<td>

<p>a vector of statistic values for permutations if <code>method="permutation"</code>.
</p>
</td></tr>
<tr><td><code>test.statistic</code></td>
<td>

<p>statistic estimate given in formula (5) of <em>DeLong et al. (1988)</em> (See <em>References</em> below) if <code>method="auc"</code>.
</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>

<p>the p-value for the test.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Venkatraman E.S., Begg C.B., 1996, A distribution-free procedure for comparing receiver operating characteristic curves from a paired experiment, <em>Biometrika</em>, <b>83</b>(4), 835-848.
</p>
<p>Martinez-Camblor P., Corral, N., 2012, A general bootstrap algorithm for hypothesis testing, <em>Journal of Statistical Planning and Inference</em>, <b>142</b>, 589-600.
</p>
<p>Martinez-Camblor P., Carleos C., Corral N., 2013, General nonparametric ROC curve comparison, <em>Journal of the Korean Statistical Society</em>, <b>42</b>(1), 71-81.
</p>
<p>DeLong E.R., DeLong D.M., Clarke-Pearson D.L., 1988, Comparing the areas under two or more correlated receiver operating characteristic curves: a nonparametric approach, <em>Biometrics</em>, <b>44</b>, 837-845.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n0 &lt;- 45; n1 &lt;- 60
set.seed(123)
D &lt;- c(rep(0,n0), rep(1,n1))

library(mvtnorm)
rho.12 &lt;- 1/4; rho.13 &lt;- 1/4; rho.23 &lt;- 0.5
sd.controls &lt;- c(1,1,1)
sd.cases &lt;- c(1,1,1)
var.controls &lt;- sd.controls%*%t(sd.controls)
var.cases &lt;- sd.cases%*%t(sd.cases)
sigma.controls &lt;- var.controls*matrix(c(1,rho.12,rho.13,rho.12,1,rho.23,rho.13,rho.23,1),3,3)
sigma.cases &lt;- var.cases*matrix(c(1,rho.12,rho.13,rho.12,1,rho.23,rho.13,rho.23,1),3,3)
controls &lt;- rmvnorm(n0, mean=rep(0,3), sigma=sigma.controls)
cases &lt;- rmvnorm(n1, mean=rep(1.19,3), sigma=sigma.cases)
marker.samples &lt;- rbind(controls,cases)

# Default method: KS statistic proposed in Martinez-Camblor by general bootstrap
output &lt;- compareROCdep(marker.samples, D)

# L1 statistic proposed in Martinez-Camblor by general bootstrap
output1 &lt;- compareROCdep(marker.samples, D, statistic="L1")

# CR statistic proposed in Martinez-Camblor by permutation method
output2 &lt;- compareROCdep(marker.samples, D, method="permutation", statistic="CR")

# Venkatraman statistic
output3 &lt;- compareROCdep(marker.samples, D, statistic="VK")

# DeLong AUC comparison methodology
output4 &lt;- compareROCdep(marker.samples, D, method="auc")

</code></pre>

<hr>
<h2 id='compareROCindep'>Comparison of k independent ROC curves
</h2><span id='topic+compareROCindep'></span><span id='topic+compareROCindep.default'></span>

<h3>Description</h3>

<p>This function compares k ROC curves from independent data. Different statistics can be considered in order to perform the comparison: those ones included in <em>Martinez-Camblor et al. (2011)</em> based on distances, the <em>Venkatraman (2000)</em> methodology for comparing curves for continuous unpaired data and one based in AUC (area under the curve) comparison. See <em>References</em> below.</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareROCindep(X, G, D, ...)
## Default S3 method:
compareROCindep(X, G, D, statistic=c("L1","L2","CR","other","VK","AUC"),
                FUN.stat.int=function(roc.i, roc){mean(abs(roc.i - roc))},
                FUN.stat.cons=function(n.cases, n.controls){sqrt(n.cases)},
                side=c("right","left"), Ni=1000, raw=FALSE, perm=500,
                seed=123, plot.roc=TRUE, type='s', lwd=3,
                lwd.curves=rep(2,length(table(G))), lty=1,
                lty.curves=rep(1,length(table(G))), col='black',
                col.curves=rainbow(length(table(G))), cex.lab=1.2,
                legend=c(sapply(1:length(table(G)),function(i){
                eval(bquote(expression(hat(R)[.(i)](t))))}),
                expression(hat(R)(t))), legend.position='bottomright',
                legend.inset=0.03, cex.legend=1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compareROCindep_+3A_x">X</code></td>
<td>

<p>vector of (bio)marker values.</p>
</td></tr>
<tr><td><code id="compareROCindep_+3A_g">G</code></td>
<td>

<p>vector of group identifier values (it should have as levels as independent samples to compare).</p>
</td></tr>
<tr><td><code id="compareROCindep_+3A_d">D</code></td>
<td>

<p>the vector of response values.</p>
</td></tr>
<tr><td><code id="compareROCindep_+3A_statistic">statistic</code></td>
<td>

<p>the statistic used in order to compare the curves. One of &quot;L1&quot; (<code class="reqn">L_1</code>-measure), &quot;L2&quot; (<code class="reqn">L_2</code>-measure), &quot;CR&quot; (Cramer-von Mises), &quot;other&quot; (another statistic defined by <code class="reqn">\sum_{i=1}^k</code> <code>FUN.stat.cons</code> <code class="reqn">\cdot</code> <code>FUN.stat.int</code>), &quot;VK&quot; (Venkatraman) or &quot;AUC&quot; (area under the curve).</p>
</td></tr>
<tr><td><code id="compareROCindep_+3A_fun.stat.int">FUN.stat.int</code></td>
<td>

<p>a function of two variables, <code>roc.i</code> and <code>roc</code> standing for ROC curve estimate for the <code class="reqn">i-th</code> sample and mean ROC curve estimate along the k samples, respectively. This function represents the integral to consider in case of <code>statistic="other"</code>.
</p>
</td></tr>
<tr><td><code id="compareROCindep_+3A_fun.stat.cons">FUN.stat.cons</code></td>
<td>

<p>a function of two variables, <code>n.cases</code> and <code>n.controls</code> standing for the cases and controls sample size, respectively. This function represents the constant to multiply <code>FUN.stat.int</code> above in case of <code>statistic="other"</code>.</p>
</td></tr>
<tr><td><code id="compareROCindep_+3A_side">side</code></td>
<td>

<p>type of ROC curve. One of &quot;right&quot; or &quot;left&quot;. If <code>method="VK"</code> only right-sided could be considered.</p>
</td></tr>
<tr><td><code id="compareROCindep_+3A_ni">Ni</code></td>
<td>

<p>number of subintervals of the unit interval (FPR values) considered to calculate the curve. Default: 1000.</p>
</td></tr>
<tr><td><code id="compareROCindep_+3A_raw">raw</code></td>
<td>

<p>if TRUE, raw data is considered; if FALSE, data is ranked and a method to break ties in the permutations is considered (see <em>Venkatraman (2000)</em> in <em>References</em>). Default: FALSE.</p>
</td></tr>
<tr><td><code id="compareROCindep_+3A_perm">perm</code></td>
<td>

<p>number of permutations. Default: 500.</p>
</td></tr>
<tr><td><code id="compareROCindep_+3A_seed">seed</code></td>
<td>

<p>seed considered to generate the permutations (for reproducibility). Default: 123.
</p>
</td></tr>
<tr><td><code id="compareROCindep_+3A_plot.roc">plot.roc</code></td>
<td>

<p>if TRUE, a plot including ROC curve estimates for the k samples and the mean of all of them is displayed.</p>
</td></tr>
<tr><td><code id="compareROCindep_+3A_type">type</code></td>
<td>

<p>what type of plot should be drawn.</p>
</td></tr>
<tr><td><code id="compareROCindep_+3A_lwd">lwd</code></td>
<td>

<p>the line width to be used for mean ROC curve estimate.</p>
</td></tr>
<tr><td><code id="compareROCindep_+3A_lwd.curves">lwd.curves</code></td>
<td>

<p>a vector with the line widths to be used for ROC curve estimates of each sample.</p>
</td></tr>
<tr><td><code id="compareROCindep_+3A_lty">lty</code></td>
<td>

<p>the line type to be used for mean ROC curve estimate.</p>
</td></tr>
<tr><td><code id="compareROCindep_+3A_lty.curves">lty.curves</code></td>
<td>

<p>a vector with the line types to be used for ROC curve estimates of each sample.</p>
</td></tr>
<tr><td><code id="compareROCindep_+3A_col">col</code></td>
<td>

<p>the color to be used for mean ROC curve estimate.</p>
</td></tr>
<tr><td><code id="compareROCindep_+3A_col.curves">col.curves</code></td>
<td>

<p>a vector with the colors to be used for ROC curve estimates of each sample.</p>
</td></tr>
<tr><td><code id="compareROCindep_+3A_cex.lab">cex.lab</code></td>
<td>

<p>the magnification to be used for x and y labels relative to the current setting of <code>cex</code>.</p>
</td></tr>
<tr><td><code id="compareROCindep_+3A_legend">legend</code></td>
<td>

<p>a character or expression vector to appear in the legend.</p>
</td></tr>
<tr><td><code id="compareROCindep_+3A_legend.position">legend.position</code>, <code id="compareROCindep_+3A_legend.inset">legend.inset</code>, <code id="compareROCindep_+3A_cex.legend">cex.legend</code></td>
<td>

<p>the position of the legend, the inset distance from the margins as a fraction of the plot region when legend is placed, and the character expansion factor relative to current <code>par("cex")</code>, respectively.</p>
</td></tr>
<tr><td><code id="compareROCindep_+3A_...">...</code></td>
<td>

<p>another graphical parameters to be passed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the Venkatraman statistic is chosen in order to compare left-sided ROC curves, an error will be displayed and it will not work. The Venkatraman methodology is just implemented for right-sided ROC curves.
</p>
<p>If <code>raw=FALSE</code> the data will be ranked in each sample using the <code>rank</code> function with <code>ties.method='first'</code> option. Furthermore, the permutation samples possible ties will be broken using <code>ties.method='random'</code> option.
</p>
<p>The statistic is defined by <code class="reqn">\sum_{i=1}^k</code> <code>statistic.cons</code> <code class="reqn">\cdot</code> <code>statistic.int</code> where <code>statistic.cons</code> = <code>FUN.stat.cons</code>('number of cases in the i-th sample', 'number of controls in the i-th sample') and <code>statistic.int</code> = <code>FUN.stat.int</code>('ROC curve estimate from the i-th sample', 'mean ROC curve estimate along the k samples'). It is usual to consider the function <code>FUN.stat.int</code> as an integral of a distance between <code class="reqn">\hat{R}_i(t)</code> and <code class="reqn">\hat{R}(t)</code> where <code class="reqn">\hat{R}(t) := k^{-1} \sum_{i=1}^k \hat{R}_i(t)</code>.
</p>
<p>The statistics implemented are defined by the following <code>FUN.stat.cons</code> and <code>FUN.stat.int</code> functions:
</p>

<ul>
<li><p><code>statistic="L1"</code>:
</p>
<p><code>FUN.stat.int(roc.i, roc) = mean(abs(roc.i - roc))</code>
</p>
<p><code>FUN.stat.cons(n.cases, n.controls) = sqrt(n.cases)</code>
</p>
</li>
<li><p><code>statistic="L2"</code>:
</p>
<p><code>FUN.stat.int(roc.i, roc) = mean((roc.i - roc)^2)</code>
</p>
<p><code>FUN.stat.cons(n.cases, n.controls) = n.cases</code>
</p>
</li>
<li><p><code>statistic="CR"</code>:
</p>
<p><code>FUN.stat.int(roc.i, roc) = mean((roc.i[seq(2,2*Ni+1,2)] -</code>
</p>
<p><code>      roc[seq(2,2*Ni+1,2)])^2 * (roc[seq(3,2*Ni+1,2)] - roc[seq(1,2*Ni-1,2)]))</code>.
</p>
<p><code>FUN.stat.cons(n.cases, n.controls) = n.cases</code>
</p>
<p>In order to use this statistic, the ROC curves have been estimated in a grid with <code>2*Ni</code> subintervals of the unit interval.
</p>
</li></ul>

<p>The permutation method proposed in <em>Venkatraman (2000)</em> is used in order to generate the <code>perm</code> samples in all methodologies (i.e., any <code>statistic</code>).
</p>
<p>In case of <code>statistic="VK"</code> the Venkatraman methodology (see <em>References</em> below) is computed to calculate the statistic. If <code class="reqn">k&gt;2</code> the statistic value is the sum of the statistic values of each pair such that <code class="reqn">i &lt; j</code>.
</p>
<p>In case of <code>statistic="AUC"</code>, the statistic considered is <code class="reqn">k^{-1} \sum_{i=1}^k | \widehat{AUC}_i - \widehat{AUC} |</code> where <code class="reqn">\hat{AUC}</code> is the mean of <code class="reqn">\hat{AUC}_i</code> along the k samples.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>n.controls</code></td>
<td>

<p>vector of number of controls in each sample.
</p>
</td></tr>
<tr><td><code>n.cases</code></td>
<td>

<p>vector of number of cases in each sample.
</p>
</td></tr>
<tr><td><code>controls.k</code></td>
<td>

<p>a vector of all controls along the k samples, ordered by sample.
</p>
</td></tr>
<tr><td><code>cases.k</code></td>
<td>

<p>a vector of all cases along the k samples, ordered by sample.
</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>

<p>the value of the test statistic.
</p>
</td></tr>
<tr><td><code>stat.perm</code></td>
<td>

<p>a vector of statistic values for permutations.
</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>

<p>the p-value for the test.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Venkatraman E.S., 2000, A permutation test to compare receiver operating characteristic curves, <em>Biometrics</em>, <b>56</b>, 1134-1138.
</p>
<p>Martinez-Camblor P., Carleos C., Corral N., 2011, Powerful nonparametric statistics to compare k independent ROC curves, <em>Journal of Applied Statistics</em>, <b>38</b>(7), 1317-1332.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
X1 &lt;- c(rnorm(45), rnorm(30,2,1.5))
D1 &lt;- c(rep(0,45), rep(1,30))
X2 &lt;- c(rnorm(45), rnorm(38,3,1.5))
D2 &lt;- c(rep(0,45), rep(1,38))
X3 &lt;- c(rnorm(30), rnorm(42,3,1))
D3 &lt;- c(rep(0,30), rep(1,42))
X &lt;- c(X1, X2, X3)
D &lt;- c(D1, D2, D3)
G &lt;- c(rep(1,75), rep(2,83), rep(3,72))

# Default method: L1 statistic proposed in Martinez-Camblor
output &lt;- compareROCindep(X, G, D)

# Venkatraman statistic
output1 &lt;- compareROCindep(X, G, D, statistic="VK")

# DeLong AUC comparison methodology
output2 &lt;- compareROCindep(X, G, D, statistic="AUC")

</code></pre>

<hr>
<h2 id='gROC'>ROC curve estimation (generalization included)
</h2><span id='topic+gROC'></span><span id='topic+gROC.default'></span>

<h3>Description</h3>

<p>This function estimates the Receiver Operating Characteristic curve and returns a 'groc' object. This object can be <code>printed</code> or <code>plotted</code>. It is the main function of the package and it includes the ROC curve generalization for non-monotone relationships (see <em>References</em> below).</p>


<h3>Usage</h3>

<pre><code class='language-R'>gROC(X, D, ...)
## Default S3 method:
gROC(X, D, side=c("right", "left", "both", "both2", "auto"),
          Ni = NULL,  plot.roc = FALSE, plot.density = FALSE,
          pval.auc = FALSE, B = 500, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gROC_+3A_x">X</code></td>
<td>

<p>vector of (bio)marker values.</p>
</td></tr>
<tr><td><code id="gROC_+3A_d">D</code></td>
<td>

<p>vector of response values.</p>
</td></tr>
<tr><td><code id="gROC_+3A_side">side</code></td>
<td>

<p>type of ROC curve. One of &quot;right&quot;, &quot;left&quot;, &quot;both&quot;, &quot;both2&quot; or &quot;auto&quot;. If the user does not specify the method, &quot;right&quot; is considered, i.e., the right-sided ROC curve is estimated. If &quot;auto&quot;, one of &quot;right&quot; or &quot;left&quot; is assigned automatically according to the Wilcoxon statistic. If the estimate is lower than <code class="reqn">\frac{number \; of \; controls \times number \; of \; cases}{2}</code>, the right-sided ROC curve is computed, otherwise the left one is considered. If &quot;both&quot;, the gROC curve is estimated in the usual way (controls inside the interval) and if &quot;both2&quot;, the opposite direction is considered.</p>
</td></tr>
<tr><td><code id="gROC_+3A_ni">Ni</code></td>
<td>

<p>number of subintervals of the unit interval (FPR values) considered to calculate the curve. Default: NULL (in this case the fast algorithm considering as many FPR values as number of controls is considered).</p>
</td></tr>
<tr><td><code id="gROC_+3A_plot.roc">plot.roc</code></td>
<td>

<p>if TRUE, ROC curve estimate considered is displayed.
</p>
</td></tr>
<tr><td><code id="gROC_+3A_plot.density">plot.density</code></td>
<td>

<p>if TRUE, density estimates for the (bio)marker in the positive and negative subjects are displayed in the same plot.
</p>
</td></tr>
<tr><td><code id="gROC_+3A_pval.auc">pval.auc</code></td>
<td>

<p>if TRUE, a permutation test to test if the AUC differs from $0.5$ is performed. Available if Ni is NULL. Default: FALSE.
</p>
</td></tr>
<tr><td><code id="gROC_+3A_b">B</code></td>
<td>

<p>number of permutations used for testing. Default: 500.
</p>
</td></tr>
<tr><td><code id="gROC_+3A_...">...</code></td>
<td>

<p>additional arguments for <code>gROC</code>. Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First of all, the data introduced is checked by the <code>ROCcheck</code> function.
</p>
<p>If <code>side</code> is not specified, one of &quot;right&quot; or &quot;left&quot; options is considered according to the comparison of the Wilcoxon test estimate and <code class="reqn">\frac{number \; of \; controls \times number \; of \; cases}{2}</code>. In this case, Wilcoxon rank test is performed in order to test the alternative hypothesis <code class="reqn">median(controls)&lt;median(cases)</code> and the resulting p-value is shown but side selection is just based in the aforementioned comparison, without taking into account the p-value of the test.
</p>
<p>If <code>Ni</code> is <code>NULL</code>, the general ROC curve, <code class="reqn">R_g(.)</code> is estimated considering every different pair (t, <code class="reqn">\gamma</code> <code class="reqn">\cdot</code> t) available on data. Otherwise it is estimated using {0, 1e-3, 2e-3, ..., 1} as a grid for <code class="reqn">\gamma</code> in the unit interval.
</p>
<p>If both <code>plot.density</code> and <code>plot.roc</code> are <code>TRUE</code> they are displayed in the same window.
</p>


<h3>Value</h3>

<p>A list of class &quot;groc&quot; with the following content:
</p>
<table role = "presentation">
<tr><td><code>levels</code></td>
<td>
<p>levels in <code>D</code>. The two first ones are the labels of <code>D</code> considered controls and cases, respectively.</p>
</td></tr>
<tr><td><code>controls</code></td>
<td>
<p>marker values for controls.</p>
</td></tr>
<tr><td><code>cases</code></td>
<td>
<p>marker values for cases.</p>
</td></tr>
<tr><td><code>side</code></td>
<td>
<p>direction of the comparison between controls and cases. One of &quot;right&quot;, &quot;left&quot;, &quot;both&quot; or &quot;both2&quot;. If <code>side</code> is <code>auto</code> in input arguments, the output will be the one considered by the function (according to the comparison specified above).</p>
</td></tr>
<tr><td><code>pvalue.wilcox</code></td>
<td>
<p>p-value of Wilcoxon test performed to compare cases and controls. Alternative hypothesis: <code class="reqn">median(controls)&lt;median(cases)</code>.</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>vector of values of t: {0, 1/<code>Ni</code>, 2/<code>Ni</code>, ..., 1}.</p>
</td></tr>
<tr><td><code>roc</code></td>
<td>
<p>vector of values of <code class="reqn">R(t)</code> for each <code class="reqn">t</code>.</p>
</td></tr>
<tr><td><code>auc</code></td>
<td>
<p>area under the ROC curve estimate by trapezoidal rule.</p>
</td></tr>
<tr><td><code>pval.auc</code></td>
<td>
<p>p-value of the permutation test over the AUC.</p>
</td></tr>
<tr><td><code>Paucs</code></td>
<td>
<p>different permutation AUCs displayed if the hypothesis test is performed.</p>
</td></tr>
<tr><td><code>points.coordinates</code></td>
<td>
<p>coordinates of the points (FPR, TPR) where the ROC curve estimate has a step in case of right or left-sided curves. The first column corresponds to the values of the <code>points</code> vector providing these coordinates.</p>
</td></tr>
<tr><td><code>pairpoints.coordinates</code></td>
<td>
<p>coordinates of the points (FPR, TPR) where the ROC curve estimate has a step in case of general curves. The first and second columns correspond to the values of the <code>pairpoints</code> matrix providing these coordinates.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>a logical value indicating if the estimation procedure whether parametric or not.</p>
</td></tr>
<tr><td><code>Ni</code></td>
<td>
<p>number of subintervals of the unit interval considered to build the curve.</p>
</td></tr>
<tr><td><code>points</code></td>
<td>
<p>if <code>Ni</code> != <code>NULL</code>, vector of cut-off points of the (bio)marker considered to estimate left or right-sided ROC curves. It corresponds to the sorted marker-values, including <code class="reqn">-\infty</code> and <code class="reqn">\infty</code>.</p>
</td></tr>
<tr><td><code>pairpoints</code></td>
<td>
<p>if <code>Ni</code> != <code>NULL</code>, matrix whose rows correspond to each pair of cut-off points (xl,xu) such that xl&lt;xu of the (bio)marker considered to estimate general ROC curves.</p>
</td></tr>
<tr><td><code>specificities</code></td>
<td>
<p>if <code>Ni</code> != <code>NULL</code>, vector of specificities associated to <code>points</code> if left or right-sided ROC curves are considered and those ones corresponding to <code>pairpoints</code> in case of general ROC curves. It could contain repeated values in both cases.</p>
</td></tr>
<tr><td><code>sensitivities</code></td>
<td>
<p>if <code>Ni</code> != <code>NULL</code>, vector of sensitivities associated to <code>points</code> if left or right-sided ROC curves are considered and those ones corresponding to <code>pairpoints</code> in case of general ROC curves. It could contain repeated values in both cases.</p>
</td></tr>
<tr><td><code>coordinates</code></td>
<td>
<p>if <code>Ni</code> != <code>NULL</code>, matrix whose first column is constituted by the unique values of FPR (1-<code>specificities</code>) and its second column is formed by the corresponding values of TPR (<code>sensitivities</code>). In the case of general ROC curves, several TPR values could be associated with the same FPR value.</p>
</td></tr>
<tr><td><code>index</code></td>
<td>
<p>if <code>Ni</code> != <code>NULL</code>, in general ROC curves, a vector displaying which row(s) of the <code>pairpoints</code> matrix correspond(s) to <code>pairpoints.coordinates</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Martinez-Camblor P., Corral N., Rey C., Pascual J., Cernuda-Morollon E., 2014, ROC curve generalization for non-monotone relationships, <em>Statistical Methods in Medical Research</em>, <b>26</b>(1), 113-123.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Basic example (side="auto") -&gt; Output side is "right"
set.seed(123)
X &lt;- c(rnorm(45), rnorm(30,2,1.5))
D &lt;- c(rep(0,45), rep(1,30))
gROC(X,D)

# Basic example (side="auto") -&gt; Output side is "left"
X &lt;- c(rnorm(45), rnorm(30,-2,1.5))
D &lt;- c(rep(0,45), rep(1,30))
gROC(X,D)

# General ROC curve example
X &lt;- c(rnorm(45), rnorm(30,1,4))
D &lt;- c(rep(0,45), rep(1,30))
gROC(X, D, side="both")

# Plot density estimates and ROC curve in the same plot
X &lt;- c(rnorm(45), rnorm(30,2,1.5))
D &lt;- c(rep(0,45), rep(1,30))
gROC(X, D, plot.roc=TRUE, plot.density=TRUE)
</code></pre>

<hr>
<h2 id='interleukin6'>
Interleukin 6 (IL6) data</h2><span id='topic+interleukin6'></span>

<h3>Description</h3>

<p>This dataset includes the true-positives (TP), false-positives (FP), true-negatives (TN) and false-negatives (FN) reported by 9 different papers which study the use of the Interleukin 6 (IL6) as a marker for the early detection of neonatal sepsis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interleukin6</code></pre>


<h3>Format</h3>

<p>A data frame with 19 observations of the following 5 variables.
</p>

<dl>
<dt><code>Author</code></dt><dd><p>a vector assigning different numbers to each paper</p>
</dd>
<dt><code>TP</code></dt><dd><p>vector of true positives</p>
</dd>
<dt><code>FP</code></dt><dd><p>vector of false positives</p>
</dd>
<dt><code>FN</code></dt><dd><p>vector of false negatives</p>
</dd>
<dt><code>TN</code></dt><dd><p>vector of true negatives</p>
</dd>
</dl>



<h3>Details</h3>

<p>In those papers providing more than one pair of Sensitivity-Specificity all of them are collected.
</p>


<h3>References</h3>

<p>Martinez-Camblor P., 2017, Fully non-parametric receiver operating characteristic curve estimation for random-effects meta-analysis, <em>Statistical Methods in Medical Research</em>, <b>26</b>(1), 5-20.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the dataset
data(interleukin6)

# Plot pairs (FPR, TPR) for each Author

attach(interleukin6)

TPR &lt;- TP/(TP+FN)
FPR &lt;- FP/(FP+TN)
plot(FPR, TPR, xlim=c(0,1), ylim=c(0,1), lwd=10, pch=1, col='gray', xlab="False-Positive Rate",
    ylab="True-Positive Rate", main=paste("ROC curve interpolation"))

S &lt;- unique(Author)
ind &lt;- order(Author, FPR, TPR)
ord.data &lt;- cbind(Author[ind], FPR[ind], TPR[ind])
roc.j &lt;- sapply(S, function(j){
  lines(c(0,ord.data[Author==j,2],1), c(0,ord.data[Author==j,3],1), col='gray')})
for(i in 1:19){text(ord.data[i,2],ord.data[i,3],ord.data[i,1],cex=0.5)}
</code></pre>

<hr>
<h2 id='metaROC'>Non-parametric ROC curve estimate for meta-analysis</h2><span id='topic+metaROC'></span><span id='topic+metaROC.default'></span>

<h3>Description</h3>

<p>This function performs meta-analytic studies of diagnostic tests for both the fixed and random-effects models. In particular it reports a fully non-parametric ROC curve estimate when data come from a meta-analysis study using the information of all cut-off points available in the selected original studies. The approach considered is the one proposed by <em>Martinez-Camblor et al. (2017)</em> based on weighting each individual interpolated ROC curve. See <em>References</em> below.</p>


<h3>Usage</h3>

<pre><code class='language-R'>metaROC(data, ...)
## Default S3 method:
metaROC(data, Ni=1000, model=c("fixed-effects","random-effects"),
        plot.Author=FALSE, plot.bands=TRUE, plot.inter.var=FALSE,
        cex.Author=0.7, lwd.Author=12, col.curve='blue',
        col.bands='light blue', alpha.trans=0.5, col.border='blue', ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="metaROC_+3A_data">data</code></td>
<td>

<p>a data frame containing at least the following variables (with these names):
</p>

<ul>
<li><p><code>Author</code>: a vector assigning different numbers to each paper/author.
</p>
</li>
<li><p><code>TP</code>: true positives.
</p>
</li>
<li><p><code>FP</code>: false positives.
</p>
</li>
<li><p><code>TN</code>: true negatives.
</p>
</li>
<li><p><code>FN</code>: false negatives.
</p>
</li></ul>

</td></tr>
<tr><td><code id="metaROC_+3A_ni">Ni</code></td>
<td>

<p>number of points of the unit interval (FPR values) considered to calculate the curve. Default: 1000.</p>
</td></tr>
<tr><td><code id="metaROC_+3A_model">model</code></td>
<td>

<p>the meta-analysis model used to estimate the ROC curve. One of &quot;fixed-effects&quot; (it only considers the within-study variability) or &quot;random-effects&quot; (it takes into account the variability between the studies).
</p>
</td></tr>
<tr><td><code id="metaROC_+3A_plot.author">plot.Author</code></td>
<td>

<p>if TRUE, a plot including ROC curve estimates (by linear interpolation) for each paper under study is displayed.
</p>
</td></tr>
<tr><td><code id="metaROC_+3A_plot.bands">plot.bands</code></td>
<td>

<p>if TRUE, confidence interval estimate for the curve is added to the plot of the ROC curve estimate.
</p>
</td></tr>
<tr><td><code id="metaROC_+3A_plot.inter.var">plot.inter.var</code></td>
<td>

<p>if TRUE, a plot including inter-study variability estimate is displayed on an additional window.
</p>
</td></tr>
<tr><td><code id="metaROC_+3A_cex.author">cex.Author</code></td>
<td>

<p>the magnification to be used to display the paper/author points labels relative to the current setting of <code>cex</code>.
</p>
</td></tr>
<tr><td><code id="metaROC_+3A_lwd.author">lwd.Author</code></td>
<td>

<p>the size to be used for the paper/author points.
</p>
</td></tr>
<tr><td><code id="metaROC_+3A_col.curve">col.curve</code></td>
<td>

<p>the color to be used for the (summary) ROC curve estimate. Default: blue.
</p>
</td></tr>
<tr><td><code id="metaROC_+3A_col.bands">col.bands</code></td>
<td>

<p>the color to be used for the confidence interval of ROC curve estimate. Default: light blue.
</p>
</td></tr>
<tr><td><code id="metaROC_+3A_alpha.trans">alpha.trans</code></td>
<td>

<p>proportion of opacity to be used for the confidence interval of ROC curve estimate. A number in the unit interval where 0 means transparent. Default: 0.5.
</p>
</td></tr>
<tr><td><code id="metaROC_+3A_col.border">col.border</code></td>
<td>

<p>the color to be used for the border of confidence interval of ROC curve estimate. Default: blue.
</p>
</td></tr>
<tr><td><code id="metaROC_+3A_...">...</code></td>
<td>

<p>another graphical parameters to be passed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The slight modification considered to ensure the monotonicity of the summary ROC curve estimate is the following
<code class="reqn">sRA(t) = max(sup_{z \in [0,t]} sRA(z), RA(t)).</code>
</p>
<p>Some basic information about the model used and the results obtained are printed.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>data</code></td>
<td>

<p>the data-frame considered ordered by Author-FPR-TPR and including the following variables:    </p>

<ul>
<li><p><code>n</code>: positive subjects sample size.
</p>
</li>
<li><p><code>m</code>: negative subjects sample size.
</p>
</li>
<li><p><code>FPR</code>: false positive rate.
</p>
</li>
<li><p><code>TPR</code>: true positive rate.
</p>
</li></ul>

</td></tr>
<tr><td><code>t</code></td>
<td>

<p>values of the unit interval (FPR values) considered to calculate the curve.
</p>
</td></tr>
<tr><td><code>model</code></td>
<td>

<p>the meta-analysis model used to estimate the ROC curve. One of &quot;fixed-effects&quot; (it only considers the within-study variability) or &quot;random-effects&quot; (it takes into account the variability between the studies).
</p>
</td></tr>
<tr><td><code>sRA</code></td>
<td>

<p>non-parametric summary ROC curve estimate following the <code>model</code> considered with a slight modification to ensure the monotonicity. This is the one reported in graphics.
</p>
</td></tr>
<tr><td><code>RA</code></td>
<td>

<p>non-parametric summary ROC curve estimate following the <code>model</code> without modifications.
</p>
</td></tr>
<tr><td><code>se.RA</code></td>
<td>

<p>standard-error of summary ROC curve estimate.
</p>
</td></tr>
<tr><td><code>area</code></td>
<td>

<p>area under the summary ROC curve estimate by trapezoidal rule.
</p>
</td></tr>
<tr><td><code>youden.index</code></td>
<td>

<p>the optimal specificity and sensitivity (in the Youden index sense).
</p>
</td></tr>
<tr><td><code>roc.j</code></td>
<td>

<p>a matrix whose column j contains the estimated ROC curve for the j-th study in each point <code>t</code> considered.
</p>
</td></tr>
<tr><td><code>w.j</code></td>
<td>

<p>a matrix whose column j contains the weights in fixed-effects model for the j-th study in each point <code>t</code> considered.
</p>
</td></tr>
<tr><td><code>w.j.rem</code></td>
<td>

<p>a matrix whose column j contains the weights in random-effects model for the j-th study in each point <code>t</code> considered.
</p>
</td></tr>
<tr><td><code>inter.var</code></td>
<td>

<p>inter-study variability estimate in each point <code>t</code> considered. Only computed if <code>model</code> is <code>"random-effects"</code>.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Martinez-Camblor P., 2017, Fully non-parametric receiver operating characteristic curve estimation for random-effects meta-analysis, <em>Statistical Methods in Medical Research</em>, <b>26</b>(1), 5-20.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(interleukin6)

# Fixed-effects meta-analysis showing linear interpolations of the papers considered in the graphic
output1 &lt;- metaROC(interleukin6, plot.Author=TRUE)

# Random-effects meta-analysis displaying also a window with a plot of the inter-study
# variability estimate
output2 &lt;- metaROC(interleukin6, model="random-effects", plot.Author=TRUE)
</code></pre>

<hr>
<h2 id='plot'>
Plot an ROC curve object</h2><span id='topic+plot.groc'></span><span id='topic+plot.rocbands'></span><span id='topic+plot.cdroc'></span>

<h3>Description</h3>

<p>This function plots a 'groc', 'rocbands' or 'cdroc' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'groc'
plot(x, lwd = 2, xlab = "False-Positive Rate",
      ylab = "True-Positive Rate", main = "ROC curve", ...)
## S3 method for class 'rocbands'
plot(x, type='s', lwd=2, xlim=c(0,1), ylim=c(0,1),
     xlab="False-Positive Rate", ylab="True-Positive Rate",
     main=paste("ROC curve \n (", obj$method, " confidence bands)", sep=""),
     col='aquamarine3', col.inside="azure2", col.frontier="azure3",
     lwd.frontier=2, ...)
## S3 method for class 'cdroc'
plot(x, type='s', lwd=3, xlab='1 - Specificity',
     ylab='Sensitivity', xaxs='i', yaxs='i',
     main=paste("ROC curve at time", obj$predict.time), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_+3A_x">x</code></td>
<td>

<p>a 'groc', 'rocbands' or 'cdroc' object from the <code>gROC</code>, <code>ROCbands</code> or <code>cdROC</code> respectively.</p>
</td></tr>
<tr><td><code id="plot_+3A_type">type</code></td>
<td>

<p>what type of plot should be drawn.</p>
</td></tr>
<tr><td><code id="plot_+3A_lwd">lwd</code></td>
<td>

<p>the line width to be used for ROC curve estimate, a positive number. See <code>par</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_col">col</code></td>
<td>

<p>the color to be used for ROC curve estimate. See <code>par</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_lwd.frontier">lwd.frontier</code></td>
<td>

<p>the line width to be used for ROC curve confidence bands estimate.
</p>
</td></tr>
<tr><td><code id="plot_+3A_col.inside">col.inside</code>, <code id="plot_+3A_col.frontier">col.frontier</code></td>
<td>

<p>the color to be used for ROC curve confidence bands estimate (<code>col.frontier</code>) and for the area inside (<code>col.inside</code>).</p>
</td></tr>
<tr><td><code id="plot_+3A_xlim">xlim</code>, <code id="plot_+3A_ylim">ylim</code></td>
<td>

<p>numeric vectors of length 2, giving the x and y coordinates ranges. See <code>plot.window</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_xlab">xlab</code>, <code id="plot_+3A_ylab">ylab</code></td>
<td>

<p>a title for the x and y axis, respectively. See <code>title</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_xaxs">xaxs</code>, <code id="plot_+3A_yaxs">yaxs</code></td>
<td>

<p>the style of axis interval calculation to be used for the x and y axis, respectively. See <code>par</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_main">main</code></td>
<td>

<p>an overall title for the plot. See <code>title</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>

<p>further arguments to be passed to methods, such as graphical parameters. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>These functions return a plot of the object they were passed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data generation
set.seed(123)
X &lt;- c(rnorm(45), rnorm(30,2,1.5))
D &lt;- c(rep(0,45), rep(1,30))

# Plot an ROC curve
grocobj &lt;- gROC(X,D)
plot(grocobj)

# Plot ROC curve confidence bands
rocbandsobj &lt;- ROCbands(grocobj)
plot(rocbandsobj)

# Plot cumulative/dynamic ROC curve
set.seed(123)
stime &lt;- rchisq(50,3)
status &lt;- sample(c(rep(1,40), rep(0,10)))
marker &lt;- max(stime) - stime + rnorm(50,0,2)
cdrocobj &lt;- cdROC(stime, status, marker, 2.8, ci=TRUE)
plot(cdrocobj)
</code></pre>

<hr>
<h2 id='print'>
Print an ROC curve object</h2><span id='topic+print.groc'></span><span id='topic+print.rocbands'></span><span id='topic+print.cdroc'></span>

<h3>Description</h3>

<p>This function prints a 'groc', 'rocbands' or 'cdroc' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'groc'
print(x, ...)
## S3 method for class 'rocbands'
print(x, ...)
## S3 method for class 'cdroc'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_+3A_x">x</code></td>
<td>

<p>a 'groc', 'rocbands' or 'cdroc' object from the <code>gROC</code>, <code>ROCbands</code> or <code>cdROC</code> respectively.</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>

<p>further arguments to be passed to other methods. Ignored.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>These functions return information about the object they were passed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gROC">gROC</a></code>, <code><a href="#topic+ROCbands">ROCbands</a></code>, <code><a href="#topic+cdROC">cdROC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data generation
set.seed(123)
X &lt;- c(rnorm(45), rnorm(30,2,1.5))
D &lt;- c(rep(0,45), rep(1,30))

# Print a groc object
grocobj &lt;- gROC(X,D)
print(grocobj)

# Print an rocbands object
grocobj &lt;- ROCbands(grocobj)
print(grocobj)

# Print a cdroc object
set.seed(123)
stime &lt;- rchisq(50,3)
status &lt;- sample(c(rep(1,45), rep(0,5)))
marker &lt;- max(stime) - stime + rnorm(50,0,2)
cdrocobj &lt;- cdROC(stime, status, marker, 3, ci=TRUE)
print(cdrocobj)
</code></pre>

<hr>
<h2 id='ROCbands'>Confidence bands for ROC curves</h2><span id='topic+ROCbands'></span><span id='topic+ROCbands.default'></span>

<h3>Description</h3>

<p>This function computes and plots confidence bands for ROC curves (both left/right-sided and general one) using three different procedures. Particularly, one parametric approach assuming the binormal model (<em>Demidenko</em>) and two non-parametric techniques (<em>Jensen et al.</em> and <em>Martinez-Camblor et al.</em>). See <em>References</em> below.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ROCbands(groc, ...)
## Default S3 method:
ROCbands(groc, method = c("PSN", "JMS", "DEK"), conf.level = 0.95,
          B = 500, bootstrap.bar = TRUE, alpha1 = NULL, s = 1, a.J = NULL, b.J = NULL,
          plot.bands = FALSE, plot.var = FALSE, seed = 123, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ROCbands_+3A_groc">groc</code></td>
<td>

<p>a 'groc' object from the <code>gROC</code> function.</p>
</td></tr>
<tr><td><code id="ROCbands_+3A_method">method</code></td>
<td>

<p>method used to compute the confidence bands. One of &quot;PSN&quot; (<em>Martinez-Camblor et al.</em>), &quot;JMS&quot; (<em>Jensen et al.</em>) or &quot;DEK&quot; (<em>Demidenko</em>).</p>
</td></tr>
<tr><td><code id="ROCbands_+3A_conf.level">conf.level</code></td>
<td>

<p>the width of the confidence band as a number in (0,1). Default: 0.95, resulting in a 95% confidence band.
</p>
</td></tr>
<tr><td><code id="ROCbands_+3A_b">B</code></td>
<td>

<p>number of bootstrap replicates. Default: 500 (only used in &quot;PSN&quot; and &quot;JMS&quot; methods).
</p>
</td></tr>
<tr><td><code id="ROCbands_+3A_bootstrap.bar">bootstrap.bar</code></td>
<td>

<p>if TRUE, a bar showing bootstrap replication progress is displayed.
</p>
</td></tr>
<tr><td><code id="ROCbands_+3A_alpha1">alpha1</code></td>
<td>

<p><code class="reqn">\alpha_1</code> in &quot;PSN&quot; approach a number in (0,1) affecting the width between the lower band and the ROC curve estimate. Default: NULL, the one which minimizes the theoretical area between lower and upper bands is considered.
</p>
</td></tr>
<tr><td><code id="ROCbands_+3A_s">s</code></td>
<td>

<p>scale parameter used to compute the smoothed kernel distribution functions in &quot;PSN&quot; method. The bandwidth <code class="reqn">h = s \cdot min(m,n)^{1/5} \cdot \hat{\sigma}</code> where <code class="reqn">m</code> and <code class="reqn">n</code> stand by the number of controls and cases, respectively, is considered. Default: 1.</p>
</td></tr>
<tr><td><code id="ROCbands_+3A_a.j">a.J</code>, <code id="ROCbands_+3A_b.j">b.J</code></td>
<td>

<p>extremes of interval in (0,1) in which compute the regional confidence bands by &quot;JMS&quot; methodology. Default: (1/Ni, 1 - 1/Ni.).
</p>
</td></tr>
<tr><td><code id="ROCbands_+3A_plot.bands">plot.bands</code></td>
<td>

<p>if TRUE, confidence bands at level <code>conf.level</code> are displayed.
</p>
</td></tr>
<tr><td><code id="ROCbands_+3A_plot.var">plot.var</code></td>
<td>

<p>if TRUE, a plot of <code class="reqn">\sigma_n^{*,1}(t)</code> with <code class="reqn">t</code> in [0,1] (if &quot;PSN&quot; method is selected) or <code class="reqn">Var(\Psi(p))</code> with <code class="reqn">p</code> in (<code>a.J</code>, <code>b.J</code>) (if &quot;JMS&quot; method is selected) is displayed.
</p>
</td></tr>
<tr><td><code id="ROCbands_+3A_seed">seed</code></td>
<td>

<p>seed used to compute the bootstrap controls and cases samples in &quot;PSN&quot; method or Brownian Bridges in &quot;JMS&quot; method.
</p>
</td></tr>
<tr><td><code id="ROCbands_+3A_...">...</code></td>
<td>

<p>additional arguments for <code>ROCbands</code>. Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p><em>Martinez-Camblor et al. methodology</em> - &quot;PSN&quot; <code>method</code>
</p>
<p>The <code>theoretical.area</code> is computed as <code class="reqn">(c_{\alpha_1} - c_{\alpha_2}) n^{-1/2} \int \sigma_n^*(t) dt</code> where <code class="reqn">\sigma_n^*(t)</code> is the standard deviation estimate of <code class="reqn">\sqrt{n} [\hat{R}(\omega, .) - R(.)]</code> and <code class="reqn">n</code> is the cases sample size.
</p>
<p>Due to computation can take some time depending on the number of bootstrap replicates considered, a progress bar is shown.
</p>
<p>Confidence bands are truncated in the following way: on one hand, if the lower band is lower than 0 or higher than 0.95 it is forced to be 0 or 0.95, respectively; on the other hand, if the upper band is higher than 1 or lower than 0.05 it is forced to be 1 or 0.05, respectively.
</p>
</li>
<li><p><em>Jensen et al. methodology</em> - &quot;JMS&quot; <code>method</code>
</p>
<p><code class="reqn">K^\alpha_{a,b}</code> denote the upper <code class="reqn">\alpha/2</code>-quantile of the distribution of <code class="reqn">\sup_{a \le p \le b} \frac{|\Psi(p)|}{\sqrt{Var \Psi(p)}}</code> where <code class="reqn">(a,b)</code> is the interval in which the regional confidence bands are calculated and <code class="reqn">\Psi(.)</code> is the limiting process of the stochastic process <code class="reqn">\Delta_N = \sqrt{N} [\hat{R}(\omega, .) - R(.)]</code> with <code class="reqn">N</code> being the total sample size.
</p>
<p>Extremes of the interval (<code>a.J</code>, <code>b.J</code>) used in order to display the regional confidence bands must be divisors of <code>Ni</code> in the interval <code class="reqn">[0,1]</code>.
</p>
<p>Confidence bands are truncated in a similar way as in &quot;PSN&quot; method in order not to have bands lower than 0 or higher than 1.
</p>
</li>
<li><p><em>Demidenko methodology</em> - &quot;DEK&quot; <code>method</code>
</p>
<p>Demidenko ROC curve estimate does not correspond to the empirical one due to the fact that the (bio)marker values in controls and cases are supposed to come from a normal distribution is exploited.
</p>
</li></ul>



<h3>Value</h3>

<p>A list of class 'rocbands' with the following content:
</p>
<table role = "presentation">
<tr><td><code>method</code></td>
<td>
<p>method used to compute the confidence bands. One of &quot;PSN&quot; (Martinez-Camblor et al.), &quot;JMS&quot; (Jensen et al.) or &quot;DEK&quot; (Demidenko).</p>
</td></tr>
<tr><td><code>conf.level</code></td>
<td>
<p>the width of the confidence band as a number in (0,1).</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>number of bootstrap replicates used in &quot;PSN&quot; and &quot;JMS&quot; methods.</p>
</td></tr>
<tr><td><code>L</code>, <code>U</code></td>
<td>
<p>vectors containing the values of lower and upper bands, respectively, for each <code class="reqn">t \in</code> {0, 1/Ni, 2/Ni, ..., 1}. In case of &quot;JMS&quot; method <code>p</code> is considered as <code class="reqn">t</code>.</p>
</td></tr>
<tr><td><code>practical.area</code></td>
<td>
<p>area between lower and upper bands (<code>L</code> and <code>U</code>) computed by trapezoidal rule.</p>
</td></tr>
<tr><td><code>Ni</code></td>
<td>
<p>number of subintervals of the unit interval considered to build the curve.</p>
</td></tr>
<tr><td><code>ROC.t</code></td>
<td>
<p>vector of values of <code class="reqn">R(t)</code> for each <code class="reqn">t \in</code> {0, 1/Ni, 2/Ni, ..., 1}.</p>
</td></tr>
</table>
<p>If the <code>method</code> is &quot;PSN&quot;:
</p>
<table role = "presentation">
<tr><td><code>s</code></td>
<td>
<p>scale parameter used to compute the smoothed kernel distribution functions.</p>
</td></tr>
<tr><td><code>alpha1</code>, <code>alpha2</code></td>
<td>
<p>if the <code>alpha1</code> input argument is not specified, <code class="reqn">\alpha_1</code> and <code class="reqn">\alpha_2</code> values which minimize area between bands are automatically computed. If <code>alpha1</code> is chosen by the user, <code>alpha2</code> is computed by <code>alpha1</code> = (1 - <code>conf.level</code>) - <code>alpha1</code>.</p>
</td></tr>
<tr><td><code>fixed.alpha1</code></td>
<td>
<p>if TRUE, <code>alpha1</code> has been fixed by the user.</p>
</td></tr>
<tr><td><code>c1</code>, <code>c2</code></td>
<td>
<p><code class="reqn">c_{\alpha_1}</code> and <code class="reqn">c_{\alpha_2}</code> resulting from the algorithm to compute confidence bands.</p>
</td></tr>
<tr><td><code>ROC.B</code></td>
<td>
<p>matrix of size <code>Ni</code>+1, <code>B</code> whose columns contain the ROC curve estimate for each bootstrap sample.</p>
</td></tr>
<tr><td><code>sd.PSN</code></td>
<td>
<p>vector <code class="reqn">\sigma_n^*(t)</code> which is the estimate of the standard deviation of the empirical process considered.</p>
</td></tr>
<tr><td><code>theoretical.area</code></td>
<td>
<p>theoretical area between confidence bands by trapezoidal rule.</p>
</td></tr>
</table>
<p>If the <code>method</code> is &quot;JMS&quot;:
</p>
<table role = "presentation">
<tr><td><code>a.J</code>, <code>b.J</code></td>
<td>
<p>extremes of the interval in which the regional confidence bands have been computed.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>vector of FPR points considered in the interval (<code>a.J</code>, <code>b.J</code>).</p>
</td></tr>
<tr><td><code>smoothROC.p</code></td>
<td>
<p>smooth ROC curve estimate for each value of <code>p</code>.</p>
</td></tr>
<tr><td><code>K.alpha</code></td>
<td>
<p>value of <code class="reqn">K_{a,b}^\alpha</code> computed to calculate confidence bands (see Details above).</p>
</td></tr>
<tr><td><code>var.JMS</code></td>
<td>
<p>value of <code class="reqn">Var(\Psi(p))</code> estimated from the formula given by Hsieh and Turnbull (see <em>Jensen et al.</em> in <em>References</em>).</p>
</td></tr>
</table>
<p>If the <code>method</code> is &quot;DEK&quot;:
</p>
<table role = "presentation">
<tr><td><code>DEK.fpr</code>, <code>DEK.tpr</code></td>
<td>
<p>values of FPR and TPR computed to calculate the Demidenko confidence bands taking into account that it is a binormal technique.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Brownian bridges needed to estimate <code class="reqn">\Psi(.)</code> in &quot;JMS&quot; method are computed using the <code>BBridge</code> function in the <code>sde</code> package.
</p>
<p>It should be noted that both the &quot;PSN&quot; and &quot;JMS&quot; methods are non-parametric, while the &quot;DEK&quot; approach is designed assuming the binormal model, so it is not convenient to use this method when distribution assumptions are not fulfilled. Furthermore, both the &quot;JMS&quot; and &quot;DEK&quot; methodologies are implemented just for the right-sided ROC curve. If <code>side</code> is <code>left</code> or <code>both</code> only the &quot;PSN&quot; method provides confidence bands.
</p>


<h3>References</h3>

<p>Martinez-Camblor P., Perez-Fernandez S., Corral N., 2016, Efficient nonparametric confidence bands for receiver operating-characteristic curves, <em>Statistical Methods in Medical Research</em>, DOI: 10.1177/0962280216672490.
</p>
<p>Jensen K., Muller H-H., Schafer H., 2000, Regional confidence bands for ROC curves, <em>Statistical in Medicine</em>, <b>19</b>, 493-509.
</p>
<p>Demidenko E., 2012, Confidence intervals and bands for the binormal ROC curve, <em>Journal of Applied Statistics</em>, <b>39</b>(1), 67-79.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Basic example
set.seed(123)
X &lt;- c(rnorm(45), rnorm(30,2,1.5))
D &lt;- c(rep(0,45), rep(1,30))
groc.obj &lt;- gROC(X,D)

# PSN confidence bands with conf.level=0.95
ROCbands(groc.obj)
# Plot standard deviation estimate of the curve and confidence bands in the same window
ROCbands(groc.obj, plot.bands=TRUE, plot.var=TRUE)
# PSN confidence bands with alpha1 fixed (alpha1=0.025)
ROCbands(groc.obj, alpha1=0.025)

# JMS confidence bands in (0.2,0.7) interval
ROCbands(groc.obj, method="JMS", a.J=0.2, b.J=0.7)
# Plot variance estimate of the curve and confidence bands in the same window
ROCbands(groc.obj, method="JMS", a.J=0.2, b.J=0.7, plot.bands=TRUE, plot.var=TRUE)

# DEK confidence bands with conf.level=0.99
ROCbands(groc.obj, method="DEK", conf.level=0.99)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
