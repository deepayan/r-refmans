<!DOCTYPE html><html><head><title>Help for package RTriangle</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RTriangle}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#RTriangle-package'><p>Generate 2D Quality meshes and constrained Delaunay triangulations</p></a></li>
<li><a href='#plot.pslg'><p>Plot pslg object</p></a></li>
<li><a href='#plot.triangulation'><p>Plot a triangulation object produced with triangulate</p></a></li>
<li><a href='#pslg'><p>Create a Planar Straight Line Graph object</p></a></li>
<li><a href='#read.pslg'><p>Read a Planar Straight Line Graph from file</p></a></li>
<li><a href='#triangulate'><p>Triangulate a Planar Straight Line Graph</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Copyright:</td>
<td>1993, 1995, 1997, 1998, 2002, 2005 Jonathan Richard
Shewchuk; 2011-2018 David Sterratt</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a></td>
</tr>
<tr>
<td>Title:</td>
<td>Triangle - A 2D Quality Mesh Generator and Delaunay Triangulator</td>
</tr>
<tr>
<td>Description:</td>
<td>This is a port of Jonathan Shewchuk's Triangle library to
    R. From his description: "Triangle generates exact Delaunay
    triangulations, constrained Delaunay triangulations, conforming
    Delaunay triangulations, Voronoi diagrams, and high-quality
    triangular meshes. The latter can be generated with no small or
    large angles, and are thus suitable for finite element analysis."</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6-0.13</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/davidcsterratt/RTriangle">https://github.com/davidcsterratt/RTriangle</a>,
<a href="http://www.cs.cmu.edu/~quake/triangle.html">http://www.cs.cmu.edu/~quake/triangle.html</a></td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-04</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, geometry</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/davidcsterratt/RTriangle/issues">https://github.com/davidcsterratt/RTriangle/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-05 23:46:29 UTC; dcs</td>
</tr>
<tr>
<td>Author:</td>
<td>Jonathan Richard Shewchuk [ctb, cph],
  David C. Sterratt [cph, aut, cre],
  Elias Pipping [ctb],
  Michael Sumner [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David C. Sterratt &lt;david.c.sterratt@ed.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-09 10:10:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='RTriangle-package'>Generate 2D Quality meshes and constrained Delaunay triangulations</h2><span id='topic+RTriangle-package'></span><span id='topic+RTriangle'></span>

<h3>Description</h3>

<p>Generate 2D Quality meshes and constrained Delaunay triangulations
</p>


<h3>Details</h3>

<p>This package is a wrapper of  Jonathan Richard Shewchuk's Triangle
package.  <code><a href="#topic+triangulate">triangulate</a></code> triangulates a <em>Planar
Straight Line Graph</em> (PSLG),  a collection of vertices and
segments created with <code><a href="#topic+pslg">pslg</a></code>.   A mesh in  the  can be
created within an arbitrary closed outline and the maximum area
and minimum angle of the triangles  in the mesh can be specified.
</p>


<h3>Author(s)</h3>

<p>David C. Sterratt <a href="mailto:david.c.sterratt@ed.ac.uk">david.c.sterratt@ed.ac.uk</a>
</p>


<h3>References</h3>


<ul>
<li> <p><a href="http://www.cs.cmu.edu/~quake/triangle.html">http://www.cs.cmu.edu/~quake/triangle.html</a>
</p>
</li>
<li><p> Jonathan Richard Shewchuk, <em>Triangle: Engineering a 2D Quality Mesh
Generator and Delaunay Triangulator</em>, in &ldquo;Applied Computational
Geometry: Towards Geometric Engineering&rdquo; (Ming C. Lin and Dinesh
Manocha, editors), volume 1148 of Lecture Notes in Computer
Science, pages 203-222, Springer-Verlag, Berlin, May 1996. (From
the First ACM Workshop on Applied Computational Geometry.) 
</p>
</li>
<li><p> Jonathan Richard Shewchuk, <em>Delaunay Refinement Algorithms for
Triangular Mesh Generation</em>, Computational Geometry: Theory and
Applications 22(1-3):21-74, May 2002.</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+triangulate">triangulate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create an object with a concavity
p &lt;- pslg(P=rbind(c(0, 0), c(0, 1), c(0.5, 0.5), c(1, 1), c(1, 0)),
          S=rbind(c(1, 2), c(2, 3), c(3, 4), c(4, 5), c(5, 1)))
## Plot it
plot(p)
## Triangulate it
tp &lt;- triangulate(p)
plot(tp)
## Triangulate it subject to minimum area constraint
tp &lt;- triangulate(p, a=0.01)
plot(tp)
## Load a data set containing a hole
A &lt;- read.pslg(file.path(system.file(package = "RTriangle"), "extdata", "A.poly"))
plot(A)
## Triangulate the PSLG
tA &lt;- triangulate(A)
plot(tA)
## Triangulate the PSLG with triangles in which no angle
## is smaller than 20 degrees
tA &lt;- triangulate(A, q=20)
plot(tA)
## Triangulate the PSLG with triangles in which no triangle has
## area greater than 0.001
tA &lt;- triangulate(A, a=0.001)
plot(tA)
</code></pre>

<hr>
<h2 id='plot.pslg'>Plot pslg object</h2><span id='topic+plot.pslg'></span>

<h3>Description</h3>

<p>Plot <code><a href="#topic+pslg">pslg</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pslg'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.pslg_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+pslg">pslg</a></code> object</p>
</td></tr>
<tr><td><code id="plot.pslg_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='plot.triangulation'>Plot a triangulation object produced with triangulate</h2><span id='topic+plot.triangulation'></span>

<h3>Description</h3>

<p>Plots a triangulation object produced with <code><a href="#topic+triangulate">triangulate</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'triangulation'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.triangulation_+3A_x">x</code></td>
<td>
<p>Triangulation object produced with <code><a href="#topic+triangulate">triangulate</a></code>.</p>
</td></tr>
<tr><td><code id="plot.triangulation_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='pslg'>Create a Planar Straight Line Graph object</h2><span id='topic+pslg'></span>

<h3>Description</h3>

<p>A Planar Straight Line Graph (PSLG) is a collection of vertices
and segments. Segments are edges whose endpoints are vertices in
the PSLG, and whose presence in any mesh generated from the PSLG
is enforced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pslg(P, PB = NA, PA = NA, S = NA, SB = NA, H = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pslg_+3A_p">P</code></td>
<td>
<p>A 2-column matrix of x-y co-ordinates of vertices. There
is one row per vertex.</p>
</td></tr>
<tr><td><code id="pslg_+3A_pb">PB</code></td>
<td>
<p>Vector of <em>boundary markers</em> of vertices. For each
vertex this is 1 if the point should be on a boundary of any mesh
generated from the PSLG and 0 otherwise. There should be as many
elements in <code>VB</code> as there are vertices in <code>V</code>.</p>
</td></tr>
<tr><td><code id="pslg_+3A_pa">PA</code></td>
<td>
<p>Matrix of <em>attributes</em> which are typically
floating-point values of physical quantities (such as mass or
conductivity) associated with the nodes of a finite element
mesh. When triangulating using <code><a href="#topic+triangulate">triangulate</a></code> these are
copied unchanged to existing points in the output mesh and each
new Steiner point added to the mesh will have quantities assigned
to it by linear interpolation.</p>
</td></tr>
<tr><td><code id="pslg_+3A_s">S</code></td>
<td>
<p>A 2-column matrix of <em>segments</em> in which each row is
a <em>segment</em>. Segments are edges whose endpoints are vertices
in the PSLG, and whose presence in any mesh generated from the
PSLG is enforced. Each segment refers to the indices in <code>V</code>
of the endpoints of the segment. By default the segments are not
specified (<code>NA</code>), in which case the convex hull of the
vertices are taken to be the segments. Any vertices outside the
region enclosed by the segments are eaten away by the
triangulation algorithm. If the segments do not enclose a region
the whole triangulation may be eaten away.</p>
</td></tr>
<tr><td><code id="pslg_+3A_sb">SB</code></td>
<td>
<p>Vector of boundary markers of segments. For each segment
this is 1 if the segment should be on a boundary of any mesh
generated from the PSLG and 0 otherwise. There should be as many
elements in <code>SB</code> as there are segments in <code>S</code>.</p>
</td></tr>
<tr><td><code id="pslg_+3A_h">H</code></td>
<td>
<p>2-column matrix of <em>holes</em>,  with one hole per
row.Holes are specified by identifying a point inside each
hole. After the triangulation is formed, Triangle creates holes by
eating triangles, spreading out from each hole point until its
progress is blocked by PSLG segments; you must be careful to
enclose each hole in segments, or your whole triangulation might
be eaten away. If the two triangles abutting a segment are eaten,
the segment itself is also eaten. Do not place a hole directly on
a segment; if you do, Triangle will choose one side of the segment
arbitrarily.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object containing the input of type <code>pslg</code> that
contains the information supplied in the inputs. This function
does some sanity checking of its inputs.
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='read.pslg'>Read a Planar Straight Line Graph from file</h2><span id='topic+read.pslg'></span>

<h3>Description</h3>

<p>Read a Planar Straight Line Graph from a <code>.poly</code> file, as
used in Shewchuk's Triangle library
(<a href="http://www.cs.cmu.edu/~quake/triangle.poly.html">http://www.cs.cmu.edu/~quake/triangle.poly.html</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.pslg(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.pslg_+3A_file">file</code></td>
<td>
<p>File name of <code>.poly</code> file to read.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>pslg</code> object. See <code><a href="#topic+pslg">pslg</a></code>.
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='triangulate'>Triangulate a Planar Straight Line Graph</h2><span id='topic+triangulate'></span>

<h3>Description</h3>

<p>Triangulate a planar straight line graph using the Triangle
library (<a href="http://www.cs.cmu.edu/~quake/triangle.html">http://www.cs.cmu.edu/~quake/triangle.html</a>).  The
triangulation is a constrained conforming Delaunay triangulation
in which additional vertices, called Steiner points, can be
inserted into segments to improved the quality of the
triangulation.  To prevent the insertion of Steiner points on
boundary segments, specify <code>Y=TRUE</code>. If the maximum triangle
area <code>a</code> is specified, the area of each triangle is not
allowed to exceed this value. If the the minimum angle <code>q</code> is
specified, no triangle angle is allowed to be below this value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triangulate(
  p,
  a = NULL,
  q = NULL,
  Y = FALSE,
  j = FALSE,
  D = FALSE,
  S = 10000,
  V = 0,
  Q = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triangulate_+3A_p">p</code></td>
<td>
<p>Planar straight line graph object; see
<code><a href="#topic+pslg">pslg</a></code>.</p>
</td></tr>
<tr><td><code id="triangulate_+3A_a">a</code></td>
<td>
<p>Maximum triangle area. If specified, triangles cannot be
larger than this area.</p>
</td></tr>
<tr><td><code id="triangulate_+3A_q">q</code></td>
<td>
<p>Minimum triangle angle in degrees.</p>
</td></tr>
<tr><td><code id="triangulate_+3A_y">Y</code></td>
<td>
<p>If <code>TRUE</code> prohibits the insertion of Steiner points
on the mesh boundary.</p>
</td></tr>
<tr><td><code id="triangulate_+3A_j">j</code></td>
<td>
<p>If <code>TRUE</code> jettisons vertices that are not part of
the final triangulation from the output.</p>
</td></tr>
<tr><td><code id="triangulate_+3A_d">D</code></td>
<td>
<p>If <code>TRUE</code> produce a conforming Delaunay
triangulation. This ensures that all the triangles in the mesh
are truly Delaunay, and not merely constrained Delaunay. This
option invokes Ruppert's original algorithm, which splits every
subsegment whose diametral circle is encroached. It usually
increases the number of vertices and triangles.</p>
</td></tr>
<tr><td><code id="triangulate_+3A_s">S</code></td>
<td>
<p>Specifies the maximum number of added Steiner points. If
set to <code>Inf</code>, there is no limit on the number of Steine
points added - but this can lead to huge amounts of memory being
allocated.</p>
</td></tr>
<tr><td><code id="triangulate_+3A_v">V</code></td>
<td>
<p>Verbosity level. Specify higher values for more detailed
information about what the Triangle library is doing.</p>
</td></tr>
<tr><td><code id="triangulate_+3A_q">Q</code></td>
<td>
<p>If <code>TRUE</code> suppresses all explanation of what the
Triangle library is doing, unless an error occurs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A object with class <code>triangulation</code>. This contains
the information in the same format as the PSLG, <code>p</code>, with
an updated list of points <code>P</code> and point attributes
<code>PA</code>, along with the following variables:
</p>
<table>
<tr><td><code>T</code></td>
<td>
<p>Triangulation specified as 3 column matrix
in which each row contains indices in <code>P</code> of vertices.</p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>Set of edges in the triangulation.</p>
</td></tr>
<tr><td><code>EB</code></td>
<td>
<p>Boundary markers of edges. For each edge this is 1 if
the point is on a boundary of the triangulation and 0
otherwise.</p>
</td></tr>
<tr><td><code>VP</code></td>
<td>
<p>The points of the Voronoi tessalation as a 2-column matrix</p>
</td></tr>
<tr><td><code>VE</code></td>
<td>
<p>Set of edges of the Voronoi tessalation. An index of -1 indicates an infinite ray.</p>
</td></tr>
<tr><td><code>VN</code></td>
<td>
<p>Directions of infinite rays of Voroni tessalation as a 2-column matrix with the same number of rows as <code>VP</code>.</p>
</td></tr>
<tr><td><code>VA</code></td>
<td>
<p>Matrix of <em>attributes</em> associated with the
polygons of the Voronoi tessalation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create an object with a concavity
p &lt;- pslg(P=rbind(c(0, 0), c(0, 1), c(0.5, 0.5), c(1, 1), c(1, 0)),
          S=rbind(c(1, 2), c(2, 3), c(3, 4), c(4, 5), c(5, 1)))
## Plot it
plot(p)
## Triangulate it
tp &lt;- triangulate(p)
plot(tp)
## Triangulate it subject to minimum area constraint
tp &lt;- triangulate(p, a=0.01)
plot(tp)
## Load a data set containing a hole
A &lt;- read.pslg(file.path(system.file(package = "RTriangle"), "extdata", "A.poly"))
plot(A)
## Produce a constrained Delaunay triangulation of the PSLG
tA &lt;- triangulate(A, Y=TRUE)
plot(tA)
## Produce a conforming Delaunay triangulation of the PSLG
tA &lt;- triangulate(A, D=TRUE)
plot(tA)
## Triangulate the PSLG with triangles in which no angle
## is smaller than 20 degrees
tA &lt;- triangulate(A, q=20)
plot(tA)
## Triangulate the PSLG with triangles in which no triangle has
## area greater than 0.001
tA &lt;- triangulate(A, a=0.001)
plot(tA)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
