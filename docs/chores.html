<!DOCTYPE html><html lang="en"><head><title>Help for package chores</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {chores}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#chores-package'><p>chores: A Collection of Large Language Model Assistants</p></a></li>
<li><a href='#.init_addin'><p>Run the chores addin</p></a></li>
<li><a href='#.init_helper'><p>Initialize a Helper object</p></a></li>
<li><a href='#cli_helper'><p>The cli helper</p></a></li>
<li><a href='#directory'><p>The prompt directory</p></a></li>
<li><a href='#helper_options'><p>Options used by the chores package</p></a></li>
<li><a href='#prompt'><p>Working with helper prompts</p></a></li>
<li><a href='#roxygen_helper'><p>The roxygen helper</p></a></li>
<li><a href='#testthat_helper'><p>The testthat helper</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>A Collection of Large Language Model Assistants</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a collection of ergonomic large language model assistants 
    designed to help you complete repetitive, hard-to-automate tasks quickly. 
    After selecting some code, press the keyboard shortcut you've chosen to 
    trigger the package app, select an assistant, and watch your chore be 
    carried out. While the package ships with a number of chore helpers for R 
    package development, users can create custom helpers just by writing some
    instructions in a markdown file.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/simonpcouch/chores">https://github.com/simonpcouch/chores</a>,
<a href="https://simonpcouch.github.io/chores/">https://simonpcouch.github.io/chores/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/simonpcouch/chores/issues">https://github.com/simonpcouch/chores/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>cli (&ge; 3.6.3), glue (&ge; 1.8.0), ellmer, miniUI (&ge; 0.1.1.1),
rlang (&ge; 1.1.4), rstudioapi (&ge; 0.17.1), shiny (&ge; 1.9.1),
streamy</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gt, knitr, rmarkdown, testthat (&ge; 3.0.0), tibble, withr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-20 20:05:47 UTC; simoncouch</td>
</tr>
<tr>
<td>Author:</td>
<td>Simon Couch <a href="https://orcid.org/0000-0001-5676-5107"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Simon Couch &lt;simon.couch@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-21 11:50:33 UTC</td>
</tr>
</table>
<hr>
<h2 id='chores-package'>chores: A Collection of Large Language Model Assistants</h2><span id='topic+chores'></span><span id='topic+chores-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Provides a collection of ergonomic large language model assistants designed to help you complete repetitive, hard-to-automate tasks quickly. After selecting some code, press the keyboard shortcut you've chosen to trigger the package app, select an assistant, and watch your chore be carried out. While the package ships with a number of chore helpers for R package development, users can create custom helpers just by writing some instructions in a markdown file.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Simon Couch <a href="mailto:simon.couch@posit.co">simon.couch@posit.co</a> (<a href="https://orcid.org/0000-0001-5676-5107">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/simonpcouch/chores">https://github.com/simonpcouch/chores</a>
</p>
</li>
<li> <p><a href="https://simonpcouch.github.io/chores/">https://simonpcouch.github.io/chores/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/simonpcouch/chores/issues">https://github.com/simonpcouch/chores/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.init_addin'>Run the chores addin</h2><span id='topic+.init_addin'></span>

<h3>Description</h3>

<p>The chores addin allows users to interactively select a chore helper to
interface with the current selection. <strong>This function is not
intended to be interfaced with in regular usage of the package.</strong>
To launch the chores addin in RStudio, navigate to <code>Addins &gt; Chores</code>
and/or register the addin with a shortcut via
<code style="white-space: pre;">&#8288;Tools &gt; Modify Keyboard Shortcuts &gt; Search "Chores"&#8288;</code>&ndash;we suggest <code>Ctrl+Alt+C</code>
(or <code>Ctrl+Cmd+C</code> on macOS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.init_addin()
</code></pre>


<h3>Value</h3>

<p><code>NULL</code>, invisibly. Called for the side effect of launching the chores addin
and interfacing with selected text.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  .init_addin()
}
</code></pre>

<hr>
<h2 id='.init_helper'>Initialize a Helper object</h2><span id='topic+.init_helper'></span>

<h3>Description</h3>

<p><strong>Users typically should not need to call this function.</strong>
</p>

<ul>
<li><p> Create new helpers that will automatically be registered with this function
with <code><a href="#topic+prompt_new">prompt_new()</a></code>.
</p>
</li>
<li><p> The <a href="#topic+.init_addin">chores addin</a> will initialize needed helpers on-the-fly.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>.init_helper(chore = NULL, .chores_chat = getOption(".chores_chat"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".init_helper_+3A_chore">chore</code></td>
<td>
<p>The identifier for a helper prompt. By default one
of <a href="#topic+cli_helper">&quot;cli&quot;</a>, <a href="#topic+testthat_helper">&quot;testthat&quot;</a> or <a href="#topic+roxygen_helper">&quot;roxygen&quot;</a>,
though custom helpers can be added with <code><a href="#topic+prompt_new">prompt_new()</a></code>.</p>
</td></tr>
<tr><td><code id=".init_helper_+3A_.chores_chat">.chores_chat</code></td>
<td>
<p>An ellmer Chat, e.g.
<code>function() ellmer::chat_claude()</code>. Defaults to the option by the same name,
so e.g. set <code>options(.chores_chat = ellmer::chat_claude())</code> in your
<code>.Rprofile</code> to configure chores with ellmer every time you start a new R session.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Helper object, which is a subclass of an ellmer chat.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># requires an API key and sets options
## Not run: 
# to create a chat with claude:
.init_helper(.chores_chat = ellmer::chat_claude())

# or with OpenAI's 4o-mini:
.init_helper(.chores_chat = ellmer::chat_openai(model = "gpt-4o-mini"))

# to set OpenAI's 4o-mini as the default model powering chores, for example,
# set the following option (possibly in your .Rprofile, if you'd like
# them to persist across sessions):
options(
  .chores_chat = ellmer::chat_openai(model = "gpt-4o-mini")
)

## End(Not run)
</code></pre>

<hr>
<h2 id='cli_helper'>The cli helper</h2><span id='topic+cli_helper'></span>

<h3>Description</h3>

<p>A couple years ago, the tidyverse team began migrating to the cli R package
for raising errors, transitioning away from base R (e.g. <code>stop()</code>),
rlang (e.g. <code>rlang::abort()</code>), glue, and homegrown combinations of them.
cli's new syntax is easier to work with as a developer and more visually
pleasing as a user.
</p>
<p>In some cases, transitioning is as simple as Finding + Replacing
<code>rlang::abort()</code> to <code>cli::cli_abort()</code>. In others, there's a mess of
ad-hoc pluralization, <code>paste0()</code>s, glue interpolations, and other
assorted nonsense to sort through. Total pain, especially with thousands
upon thousands of error messages thrown across the tidyverse, r-lib, and
tidymodels organizations.
</p>
<p>The cli helper helps you convert your R package to use cli for error messages.
</p>


<h3>Cost</h3>

<p>The system prompt for a cli helper includes something like 4,000 tokens.
Add in (a generous) 100 tokens for the code that's actually highlighted
and also sent off to the model and you're looking at 4,100 input tokens.
The model returns approximately the same number of output tokens as it
receives, so we'll call that 100 output tokens per refactor.
</p>
<p>As of the time of writing (October 2024), the recommended chores model Claude
Sonnet 3.5 costs $3 per million input tokens and $15 per million output
tokens. So, using the recommended model,
<strong>cli helpers cost around $15 for every 1,000 refactored pieces of code</strong>. GPT-4o
Mini, by contrast, doesn't tend to get cli markup classes right but <em>does</em>
return syntactically valid calls to cli functions, and it would cost around
75 cents per 1,000 refactored pieces of code.
</p>


<h3>Gallery</h3>

<p>This section includes a handful of examples
<a href="https://github.com/tidymodels/tune/blob/f8d734ac0fa981fae3a87ed2871a46e9c40d509d/R/checks.R">&quot;from the wild&quot;</a>
and are generated with the recommended model, Claude Sonnet 3.5.
</p>
<p>At its simplest, a one-line message with a little bit of markup:
</p>
<div class="sourceCode r"><pre>rlang::abort("`save_pred` can only be used if the initial results saved predictions.")
</pre></div>
<p>Returns:
</p>
<div class="sourceCode r"><pre>cli::cli_abort("{.arg save_pred} can only be used if the initial results saved predictions.")
</pre></div>
<p>Some strange vector collapsing and funky line breaking:
</p>
<div class="sourceCode r"><pre>extra_grid_params &lt;- glue::single_quote(extra_grid_params)
extra_grid_params &lt;- glue::glue_collapse(extra_grid_params, sep = ", ")

msg &lt;- glue::glue(
  "The provided `grid` has the following parameter columns that have ",
  "not been marked for tuning by `tune()`: {extra_grid_params}."
)

rlang::abort(msg)
</pre></div>
<p>Returns:
</p>
<div class="sourceCode r"><pre>cli::cli_abort(
  "The provided {.arg grid} has parameter columns that have not been
   marked for tuning by {.fn tune}: {.val {extra_grid_params}}."
)
</pre></div>
<p>A message that probably best lives as two separate elements:
</p>
<div class="sourceCode r"><pre>rlang::abort(
  paste(
    "Some model parameters require finalization but there are recipe",
    "parameters that require tuning. Please use ",
    "`extract_parameter_set_dials()` to set parameter ranges ",
    "manually and supply the output to the `param_info` argument."
  )
)
</pre></div>
<p>Returns:
</p>
<div class="sourceCode r"><pre>cli::cli_abort(
  c(
    "Some model parameters require finalization but there are recipe
     parameters that require tuning.",
    "i" = "Please use {.fn extract_parameter_set_dials} to set parameter
           ranges manually and supply the output to the {.arg param_info}
           argument."
  )
)
</pre></div>
<p>Gnarly ad-hoc pluralization:
</p>
<div class="sourceCode r"><pre>msg &lt;- "Creating pre-processing data to finalize unknown parameter"
unk_names &lt;- pset$id[unk]
if (length(unk_names) == 1) {
  msg &lt;- paste0(msg, ": ", unk_names)
} else {
  msg &lt;- paste0(msg, "s: ", paste0("'", unk_names, "'", collapse = ", "))
}
rlang::inform(msg)
</pre></div>
<p>Returns:
</p>
<div class="sourceCode r"><pre>cli::cli_inform(
  "Creating pre-processing data to finalize unknown parameter{?s}: {.val {unk_names}}"
)
</pre></div>
<p>Some <code>paste0()</code> wonk:
</p>
<div class="sourceCode r"><pre>rlang::abort(paste0(
  "The workflow has arguments to be tuned that are missing some ",
  "parameter objects: ",
  paste0("'", pset$id[!params], "'", collapse = ", ")
))
</pre></div>
<p>Returns:
</p>
<div class="sourceCode r"><pre>cli::cli_abort(
  "The workflow has arguments to be tuned that are missing some
   parameter objects: {.val {pset$id[!params]}}"
)
</pre></div>
<p>The model is instructed to only return a call to a cli function, so
erroring code that's run conditionally can get borked:
</p>
<div class="sourceCode r"><pre>cls &lt;- paste(cls, collapse = " or ")
if (!fine) {
  msg &lt;- glue::glue("Argument '{deparse(cl$x)}' should be a {cls} or NULL")
  if (!is.null(where)) {
    msg &lt;- glue::glue(msg, " in `{where}`")
  }
  rlang::abort(msg)
}
</pre></div>
<p>Returns:
</p>
<div class="sourceCode r"><pre>cli::cli_abort(
  "Argument {.code {deparse(cl$x)}} should be {?a/an} {.cls {cls}} or {.code NULL}{?in {where}}."
)
</pre></div>
<p>Note that <code style="white-space: pre;">&#8288;?in where&#8288;</code> is not valid cli markup.
</p>
<p>Sprintf-style statements aren't an issue:
</p>
<div class="sourceCode r"><pre>abort(sprintf("No such '%s' function: `%s()`.", package, name))
</pre></div>
<p>Returns:
</p>
<div class="sourceCode r"><pre>cli::cli_abort("No such {.pkg {package}} function: {.fn {name}}.")
</pre></div>


<h3>Interfacing manually with the cli helper</h3>

<p>Chore helpers are typically interfaced with via the chores addin. To call the cli
helper directly, use:
</p>
<div class="sourceCode r"><pre>helper_cli &lt;- .init_helper("cli")
</pre></div>
<p>Then, to submit a query, run:
</p>
<div class="sourceCode r"><pre>helper_cli$chat({x})
</pre></div>

<hr>
<h2 id='directory'>The prompt directory</h2><span id='topic+directory'></span><span id='topic+directory_load'></span><span id='topic+directory_list'></span><span id='topic+directory_path'></span><span id='topic+directory_set'></span>

<h3>Description</h3>

<p>The chores package's prompt directory is a directory of markdown files that
is automatically registered with the chores package on package load.
<code style="white-space: pre;">&#8288;directory_*()&#8288;</code> functions allow users to interface with the directory,
making new &quot;chores&quot; available:
</p>

<ul>
<li> <p><code>directory_path()</code> returns the path to the prompt directory.
</p>
</li>
<li> <p><code>directory_set()</code> changes the path to the prompt directory (by setting
the option <code>.chores_dir</code>).
</p>
</li>
<li> <p><code>directory_list()</code> enumerates all of the different prompts that currently
live in the directory (and provides clickable links to each).
</p>
</li>
<li> <p><code>directory_load()</code> registers each of the prompts in the prompt
directory with the chores package.
</p>
</li></ul>

<p><a href="#topic+prompt">Functions prefixed with</a> <code style="white-space: pre;">&#8288;prompt*()&#8288;</code> allow users to conveniently create, edit,
and delete the prompts in chores' prompt directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>directory_load(dir = directory_path())

directory_list()

directory_path()

directory_set(dir)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="directory_+3A_dir">dir</code></td>
<td>
<p>Path to a directory of markdown files&ndash;see <code>Details</code> for more.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>directory_path()</code> returns the path to the prompt directory (which is
not created by default unless explicitly requested by the user).
</p>
</li>
<li> <p><code>directory_set()</code> return the path to the new prompt directory.
</p>
</li>
<li> <p><code>directory_list()</code> returns the file paths of all of the prompts that
currently live in the directory (and provides clickable links to each).
</p>
</li>
<li> <p><code>directory_load()</code> returns <code>NULL</code> invisibly.
</p>
</li></ul>



<h3>Format of the prompt directory</h3>

<p>Prompts are markdown files with the
name <code>chore-interface.md</code>, where interface is one of
&quot;replace&quot;, &quot;prefix&quot; or &quot;suffix&quot;.
An example directory might look like:
</p>
<div class="sourceCode"><pre>/
|-- .config/
|   |-- chores/
|       |-- proofread-replace.md
|       |-- summarize-prefix.md
</pre></div>
<p>In that case, chores will register two custom helpers when you call <code>library(chores)</code>.
One of them is for the &quot;proofread&quot; chore and will replace the selected text with
a proofread version (according to the instructions contained in the markdown
file itself). The other is for the &quot;summarize&quot; chore and will prefix the selected
text with a summarized version (again, according to the markdown file's
instructions). Note:
</p>

<ul>
<li><p> Files without a <code>.md</code> extension are ignored.
</p>
</li>
<li><p> Files with a <code>.md</code> extension must contain only one hyphen in their filename,
and the text following the hyphen must be one of <code>replace</code>, <code>prefix</code>, or
<code>suffix</code>.
</p>
</li></ul>

<p>To load custom prompts every time the package is loaded, place your
prompts in <code>directory_path()</code>. To change the prompt directory without
loading the package, just set the <code>.chores_dir</code> option with
<code>options(.chores_dir = some_dir)</code>. To load a directory of files that's not
the prompt directory, provide a <code>dir</code> argument to <code>directory_load()</code>.
</p>


<h3>See Also</h3>

<p>The &quot;Custom helpers&quot; vignette, at
<code>vignette("custom", package = "chores")</code>,for more on adding your own
helper prompts, sharing them with others, and using prompts from others.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># choose a path for the prompt directory
tmp_dir &lt;- withr::local_tempdir()
directory_set(tmp_dir)

# print out the current prompt directory
directory_path()

# list out prompts currently in the directory
directory_list()

# create a prompt in the prompt directory
prompt_new("boop", "replace")

# view updated list of prompts
directory_list()

# register the prompt with the package
# (this will also happen automatically on reload)
directory_load()

</code></pre>

<hr>
<h2 id='helper_options'>Options used by the chores package</h2><span id='topic+helper_options'></span><span id='topic+.chores_dir'></span><span id='topic+.chores_chat'></span>

<h3>Description</h3>

<p>The chores package makes use of three notable user-facing options:
</p>

<ul>
<li> <p><code>.chores_dir</code> is the directory where helper prompts live. See the helper <a href="#topic+directory">directory</a>
help-page for more information.
</p>
</li>
<li> <p><code>.chores_chat</code> determines the underlying LLM powering each helper.
See the &quot;Choosing a model&quot; section of <code>vignette("chores", package = "chores")</code>
for more information.
</p>
</li></ul>


<hr>
<h2 id='prompt'>Working with helper prompts</h2><span id='topic+prompt'></span><span id='topic+prompt_new'></span><span id='topic+prompt_remove'></span><span id='topic+prompt_edit'></span>

<h3>Description</h3>

<p>The chores package provides a number of tools for working on system <em>prompts</em>.
System prompts are what instruct helpers on how to behave and provide
information to live in the models' &quot;short-term memory.&quot;
</p>
<p><code style="white-space: pre;">&#8288;prompt_*()&#8288;</code> functions allow users to conveniently create, edit, remove,
the prompts in chores' &quot;<a href="#topic+directory">prompt directory</a>.&quot;
</p>

<ul>
<li> <p><code>prompt_new()</code> creates a new markdown file that will automatically
create a helper with the specified chore, prompt, and interface on package load.
Specify a <code>contents</code> argument to prefill with contents from a markdown file
on your computer or the web.
</p>
</li>
<li> <p><code>prompt_edit()</code> and <code>prompt_remove()</code> open and delete, respectively, the
file that defines the given chore's system prompt.
</p>
</li></ul>

<p>Load the prompts you create with these functions using <code><a href="#topic+directory_load">directory_load()</a></code>
(which is automatically called when the package loads).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prompt_new(chore, interface, contents = NULL)

prompt_remove(chore)

prompt_edit(chore)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prompt_+3A_chore">chore</code></td>
<td>
<p>A single string giving a descriptor of the helper's functionality.
Cand only contain letters and numbers.</p>
</td></tr>
<tr><td><code id="prompt_+3A_interface">interface</code></td>
<td>
<p>One of <code>"replace"</code>, <code>"prefix"</code>, or <code>"suffix"</code>, describing
how the helper will interact with the selection. For example, the
<a href="#topic+cli_helper">cli helper</a> <code>"replace"</code>s the selection, while the
<a href="#topic+roxygen_helper">roxygen helper</a> <code>"prefixes"</code> the selected code with documentation.</p>
</td></tr>
<tr><td><code id="prompt_+3A_contents">contents</code></td>
<td>
<p>Optional. Path to a markdown file with contents that will
&quot;pre-fill&quot; the file. Anything file ending in <code>.md</code> or <code>.markdown</code> that can be
read with <code>readLines()</code> is fair game; this could be a local file, a &quot;raw&quot;
URL to a GitHub Gist or file in a GitHub repository, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Each <code style="white-space: pre;">&#8288;prompt_*()&#8288;</code> function returns the file path to the created, edited, or
removed filepath, invisibly.
</p>


<h3>See Also</h3>

<p>The <a href="#topic+directory">directory</a> help-page for more on working with prompts in
batch using <code style="white-space: pre;">&#8288;directory_*()&#8288;</code> functions, and <code>vignette("custom", package = "chores")</code>
for more on sharing helper prompts and using prompts from others.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
# create a new helper for chore `"boop"` that replaces the selected text:
prompt_new("boop")

# after writing a prompt, register it with the chores package with:
directory_load()

# after closing the file, reopen with:
prompt_edit("boop")

# remove the prompt (next time the package is loaded) with:
prompt_remove("boop")

# pull prompts from files on local drives or the web with
# `prompt_new(contents)`. for example, here is a GitHub Gist:
# paste0(
#  "https://gist.githubusercontent.com/simonpcouch/",
#  "daaa6c4155918d6f3efd6706d022e584/raw/ed1da68b3f38a25b58dd9fdc8b9c258d",
#  "58c9b4da/summarize-prefix.md"
# )
#
# press "Raw" and then supply that URL as `contents` (you don't actually
# have to use the paste0() to write out the URL--we're just keeping
# the characters per line under 80):
prompt_new(
  chore = "summarize",
  interface = "prefix",
  contents =
    paste0(
      "https://gist.githubusercontent.com/simonpcouch/",
      "daaa6c4155918d6f3efd6706d022e584/raw/ed1da68b3f38a25b58dd9fdc8b9c258d",
      "58c9b4da/summarize-prefix.md"
    )
)
}
</code></pre>

<hr>
<h2 id='roxygen_helper'>The roxygen helper</h2><span id='topic+roxygen_helper'></span>

<h3>Description</h3>

<p>The roxygen helper prefixes the selected function with a minimal roxygen2
documentation template. The helper is instructed to only generate a subset
of a complete documentation entry, to be then completed by a developer:
</p>

<ul>
<li><p> Stub <code style="white-space: pre;">&#8288;@param&#8288;</code> descriptions based on defaults and inferred types
</p>
</li>
<li><p> Stub <code style="white-space: pre;">&#8288;@returns&#8288;</code> entry that describes the return value as well as important
errors and warnings users might encounter.
</p>
</li></ul>



<h3>Cost</h3>

<p>The system prompt from a roxygen helper includes something like 1,000 tokens.
Add in 200 tokens for the code that's actually highlighted
and also sent off to the model and you're looking at 1,200 input tokens.
The model returns maybe 10 to 15 lines of relatively barebones royxgen
documentation, so we'll call that 200 output tokens per refactor.
</p>
<p>As of the time of writing (October 2024), the recommended chores model Claude
Sonnet 3.5 costs $3 per million input tokens and $15 per million output
tokens. So, using the recommended model,
<strong>roxygen helpers cost around $4 for every 1,000 generated roxygen documentation
entries</strong>. GPT-4o Mini, by contrast, doesn't tend to infer argument types
correctly as often and
often fails to line-break properly, but <em>does</em> usually return syntactically
valid documentation entries, and it would cost around
20 cents per 1,000 generated roxygen documentation entries.
</p>


<h3>Gallery</h3>

<p>This section includes a handful of examples &quot;from the wild&quot;
and are generated with the recommended model, Claude Sonnet 3.5.
</p>
<p>Documenting a function factory:
</p>
<div class="sourceCode r"><pre>deferred_method_transform &lt;- function(lambda_expr, transformer, eval_env) {
  transformer &lt;- enexpr(transformer)
  force(eval_env)

  unique_id &lt;- new_id()
  env_bind_lazy(
    generators,
    !!unique_id := inject((!!transformer)(!!lambda_expr)),
    eval.env = eval_env
  )

  inject(
    function(...) {
      (!!generators)[[!!unique_id]](self, private, ...)
    }
  )
}
</pre></div>
<p>Returns:
</p>
<div class="sourceCode r"><pre>#' #' Transform a deferred method
#'
#' @description
#' A short description...
#'
#' @param lambda_expr A lambda expression to transform.
#' @param transformer A transformer function or expression.
#' @param eval_env The environment in which to evaluate the transformer.
#'
#' @returns
#' A function that, when called, will evaluate the transformed lambda expression.
#' The returned function accepts `...` arguments which are passed to the generated function.
#'
#' @export
</pre></div>
<p>A function that may raise a condition:
</p>
<div class="sourceCode r"><pre>set_default &lt;- function(value, default, arg = caller_arg(value)) {
  if (is.null(value)) {
    if (!is_testing() || is_snapshot()) {
      cli::cli_inform("Using {.field {arg}} = {.val {default}}.")
    }
    default
  } else {
    value
  }
}
</pre></div>
<p>Returns:
</p>
<div class="sourceCode r"><pre>#' Set default value
#'
#' @description
#' A short description...
#'
#' @param value A value to check.
#' @param default The default value to use if `value` is NULL.
#' @param arg Optional. The name of the argument being set.
#'
#' @returns
#' Returns `value` if it's not NULL, otherwise returns `default`.
#' Informs the user when using the default value.
#'
#' @export
</pre></div>
<p>A function with some tricky indexing:
</p>
<div class="sourceCode r"><pre>find_index &lt;- function(left, e_right) {
  if (!is.list(e_right) || !has_name(e_right, "index") || !is.numeric(e_right$index)) {
    return(NA)
  }

  matches_idx &lt;- map_lgl(left, function(e_left) e_left$index == e_right$index)
  if (sum(matches_idx) != 1) {
    return(NA)
  }
  which(matches_idx)[[1]]
}
</pre></div>
<p>Returns:
</p>
<div class="sourceCode"><pre>#' Find matching index
#'
#' @description
#' A short description...
#'
#' @param left A list of elements, each expected to have an 'index' field.
#' @param e_right A list with an 'index' field to search for in `left`.
#'
#' @returns
#' The numeric index in `left` where `e_right$index` matches, or NA if not found
#' or if inputs are invalid. Returns NA if multiple matches are found.
#'
#' @export
</pre></div>


<h3>Interfacing manually with the roxygen helper</h3>

<p>Chore helpers are typically interfaced with via the chores addin. To call the roxygen
helper directly, use:
</p>
<div class="sourceCode r"><pre>helper_roxygen &lt;- .init_helper("roxygen")
</pre></div>
<p>Then, to submit a query, run:
</p>
<div class="sourceCode r"><pre>helper_roxygen$chat({x})
</pre></div>

<hr>
<h2 id='testthat_helper'>The testthat helper</h2><span id='topic+testthat_helper'></span>

<h3>Description</h3>

<p>testthat 3.0.0 was released in 2020, bringing with it numerous changes
that were both huge quality of life improvements for package developers
and also highly breaking changes.
</p>
<p>While some of the task of converting legacy unit testing code to testthat
3e is quite is pretty straightforward, other components can be quite tedious.
The testthat helper helps you transition your R package's unit tests to
the third edition of testthat, namely via:
</p>

<ul>
<li><p> Converting to snapshot tests
</p>
</li>
<li><p> Disentangling nested expectations
</p>
</li>
<li><p> Transitioning from deprecated functions like <code style="white-space: pre;">&#8288;expect_known_*()&#8288;</code>
</p>
</li></ul>



<h3>Cost</h3>

<p>The system prompt from a testthat helper includes something like 1,000 tokens.
Add in (a generous) 100 tokens for the code that's actually highlighted
and also sent off to the model and you're looking at 1,100 input tokens.
The model returns approximately the same number of output tokens as it
receives, so we'll call that 100 output tokens per refactor.
</p>
<p>As of the time of writing (October 2024), the recommended chores model Claude
Sonnet 3.5 costs $3 per million input tokens and $15 per million output
tokens. So, using the recommended model,
<strong>testthat helpers cost around $4 for every 1,000 refactored pieces of code</strong>. GPT-4o
Mini, by contrast, doesn't tend to get many pieces of formatting right and
often fails to line-break properly, but <em>does</em> usually return syntactically
valid calls to testthat functions, and it would cost around
20 cents per 1,000 refactored pieces of code.
</p>


<h3>Gallery</h3>

<p>This section includes a handful of examples
&quot;<a href="https://github.com/tidymodels/broom/tree/7fa26488ab522bf577092e99aad1f2003f21b327/tests">from</a>
the <a href="https://github.com/tidymodels/tune/tree/f8d734ac0fa981fae3a87ed2871a46e9c40d509d/tests">wild</a>&quot;
and are generated with the recommended model, Claude Sonnet 3.5.
</p>
<p>Testthat helpers convert <code>expect_error()</code> (and <code style="white-space: pre;">&#8288;*_warning()&#8288;</code> and <code style="white-space: pre;">&#8288;*_message()&#8288;</code>
and <code style="white-space: pre;">&#8288;*_condition()&#8288;</code>) calls to use <code>expect_snapshot()</code> when there's a
regular expression present:
</p>
<div class="sourceCode r"><pre>expect_warning(
  check_ellipses("exponentiate", "tidy", "boop", exponentiate = TRUE, quick = FALSE),
  "\\`exponentiate\\` argument is not supported in the \\`tidy\\(\\)\\` method for \\`boop\\` objects"
)
</pre></div>
<p>Returns:
</p>
<div class="sourceCode r"><pre>expect_snapshot(
  .res &lt;- check_ellipses(
    "exponentiate", "tidy", "boop", exponentiate = TRUE, quick = FALSE
  )
)
</pre></div>
<p>Note, as well, that intermediate results are assigned to an object so as
not to be snapshotted when their contents weren't previously tests.
</p>
<p>Another example with multiple, redudant calls:
</p>
<div class="sourceCode r"><pre>augment_error &lt;- "augment is only supported for fixest models estimated with feols, feglm, or femlm"
expect_error(augment(res_fenegbin, df), augment_error)
expect_error(augment(res_feNmlm, df), augment_error)
expect_error(augment(res_fepois, df), augment_error)
</pre></div>
<p>Returns:
</p>
<div class="sourceCode r"><pre>expect_snapshot(error = TRUE, augment(res_fenegbin, df))
expect_snapshot(error = TRUE, augment(res_feNmlm, df))
expect_snapshot(error = TRUE, augment(res_fepois, df))
</pre></div>
<p>They know about <code>regexp = NA</code>, which means &quot;no error&quot; (or warning, or message):
</p>
<div class="sourceCode r"><pre>expect_error(
  p4_b &lt;- check_parameters(w4, p4_a, data = mtcars),
  regex = NA
)
</pre></div>
<p>Returns:
</p>
<div class="sourceCode r"><pre>expect_no_error(p4_b &lt;- check_parameters(w4, p4_a, data = mtcars))
</pre></div>
<p>They also know not to adjust calls to those condition expectations when
there's a <code>class</code> argument present (which usually means that one is
testing a condition from another package, which should be able to change
the wording of the message without consequence):
</p>
<div class="sourceCode r"><pre>expect_error(tidy(pca, matrix = "u"), class = "pca_error")
</pre></div>
<p>Returns:
</p>
<div class="sourceCode r"><pre>expect_error(tidy(pca, matrix = "u"), class = "pca_error")
</pre></div>
<p>When converting non-erroring code, testthat helpers will assign intermediate
results so as not to snapshot both the result and the warning:
</p>
<div class="sourceCode r"><pre>expect_warning(
  tidy(fit, robust = TRUE),
  '"robust" argument has been deprecated'
)
</pre></div>
<p>Returns:
</p>
<div class="sourceCode r"><pre>expect_snapshot(
  .res &lt;- tidy(fit, robust = TRUE)
)
</pre></div>
<p>Nested expectations can generally be disentangled without issue:
</p>
<div class="sourceCode r"><pre>expect_equal(
  fit_resamples(decision_tree(cost_complexity = 1), bootstraps(mtcars)),
  expect_warning(tune_grid(decision_tree(cost_complexity = 1), bootstraps(mtcars)))
)
</pre></div>
<p>Returns:
</p>
<div class="sourceCode r"><pre>expect_snapshot({
  fit_resamples_result &lt;- fit_resamples(decision_tree(cost_complexity = 1),
                                        bootstraps(mtcars))
  tune_grid_result &lt;- tune_grid(decision_tree(cost_complexity = 1),
                                bootstraps(mtcars))
})
expect_equal(fit_resamples_result, tune_grid_result)
</pre></div>
<p>There are also a few edits the helper knows to make to third-edition code.
For example, it transitions <code>expect_snapshot_error()</code> and friends to
use <code>expect_snapshot(error = TRUE)</code> so that the error context is snapshotted
in addition to the message itself:
</p>
<div class="sourceCode r"><pre>expect_snapshot_error(
  fit_best(knn_pca_res, parameters = tibble(neighbors = 2))
)
</pre></div>
<p>Returns:
</p>
<div class="sourceCode r"><pre>expect_snapshot(
  error = TRUE,
  fit_best(knn_pca_res, parameters = tibble(neighbors = 2))
)
</pre></div>


<h3>Interfacing manually with the testthat helper</h3>

<p>Chore helpers are typically interfaced with via the chores addin. To call the testthat
helper directly, use:
</p>
<div class="sourceCode r"><pre>helper_testthat &lt;- .init_helper("testthat")
</pre></div>
<p>Then, to submit a query, run:
</p>
<div class="sourceCode r"><pre>helper_testthat$chat({x})
</pre></div>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
