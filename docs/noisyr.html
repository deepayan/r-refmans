<!DOCTYPE html><html><head><title>Help for package noisyr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {noisyr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calculate_expression_profile'><p>Calculate the expression profile of a gene</p></a></li>
<li><a href='#calculate_expression_similarity_counts'><p>Calcualate the expression levels and expression levels similarity matrices using the count matrix</p></a></li>
<li><a href='#calculate_expression_similarity_transcript'><p>Calcualte the distance matrices using the BAM files</p></a></li>
<li><a href='#calculate_first_minimum_density'><p>Function to find the first local minimum of the density of a vector</p></a></li>
<li><a href='#calculate_noise_threshold'><p>Function to calculate the noise threshold for a given expression matrix and parameters</p></a></li>
<li><a href='#calculate_noise_threshold_method_statistics'><p>Function to tabulate statistics for different methods of calculating the noise threshold</p></a></li>
<li><a href='#cast_gtf_to_genes'><p>Function to extract exon names and positions from a gtf file</p></a></li>
<li><a href='#cast_matrix_to_numeric'><p>Cast a matrix of any type to numeric</p></a></li>
<li><a href='#filter_genes_transcript'><p>Function to filter the gene table for the transcript approach</p></a></li>
<li><a href='#get_methods_calculate_noise_threshold'><p>Show the methods for calculating a noise threshold</p></a></li>
<li><a href='#get_methods_correlation_distance'><p>Show the methods for calculating correlation or distance</p></a></li>
<li><a href='#noisyr'><p>Run the noisyR pipeline</p></a></li>
<li><a href='#noisyr_counts'><p>Run the noisyR pipeline for the count matrix approach</p></a></li>
<li><a href='#noisyr_transcript'><p>Run the noisyR pipeline for the transcript approach</p></a></li>
<li><a href='#optimise_window_length'><p>Optimise the elements per window for the count matrix approach</p></a></li>
<li><a href='#plot_expression_similarity'><p>Plot the similarity against expression levels</p></a></li>
<li><a href='#remove_noise_from_bams'><p>Function to remove the noisy reads from the BAM files</p></a></li>
<li><a href='#remove_noise_from_matrix'><p>Function to remove the noisy reads from the expression matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Noise Quantification in High Throughput Sequencing Output</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ilias Moutsopoulos &lt;im383@cam.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Quantifies and removes technical noise from high-throughput 
        sequencing data. Two approaches are used, one based on the count
        matrix, and one using the alignment BAM files directly.
        Contains several options for every step of the process, as well
        as tools to quality check and assess the stability of output.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, grDevices, tibble, dplyr, magrittr, ggplot2,
preprocessCore, IRanges, GenomicRanges, Rsamtools, philentropy,
doParallel, foreach</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, roxygen2, knitr, rmarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Core-Bioinformatics/noisyR">https://github.com/Core-Bioinformatics/noisyR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Core-Bioinformatics/noisyR/issues">https://github.com/Core-Bioinformatics/noisyR/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-04-16 08:59:10 UTC; Ilias Moutsopoulos</td>
</tr>
<tr>
<td>Author:</td>
<td>Ilias Moutsopoulos [aut, cre],
  Irina Mohorianu [aut, ctb],
  Hajk-Georg Drost [ctb],
  Elze Lauzikaite [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-04-16 10:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='calculate_expression_profile'>Calculate the expression profile of a gene</h2><span id='topic+calculate_expression_profile'></span>

<h3>Description</h3>

<p>This function calculates the expression profile of an exon in a selection
of BAM files. The expression profile is defined as the number of reads overlapping
with each position of the exon's transcript.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_expression_profile(
  gene,
  bams,
  unique.only = TRUE,
  mapq.unique = c(50, 255),
  slack = 200
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_expression_profile_+3A_gene">gene</code></td>
<td>
<p>The exon for which the expression profile is calculated; this should be
a row from the tibble generated by <code><a href="#topic+cast_gtf_to_genes">cast_gtf_to_genes</a></code>; for a manual input,
a tibble with 1 row and named columns (seqid, start, end) would be needed</p>
</td></tr>
<tr><td><code id="calculate_expression_profile_+3A_bams">bams</code></td>
<td>
<p>a vector of paths to the BAM files from which the profile is extracted</p>
</td></tr>
<tr><td><code id="calculate_expression_profile_+3A_unique.only">unique.only</code></td>
<td>
<p>whether only uniquely mapped reads should contribute to the profile;
default is TRUE</p>
</td></tr>
<tr><td><code id="calculate_expression_profile_+3A_mapq.unique">mapq.unique</code></td>
<td>
<p>The values of the mapping quality field in the BAM file that corresponds
to uniquely mapped reads; by default, values of 50 and 255 are used as these correspond to
the most popular aligners, but an adjustment might be needed</p>
</td></tr>
<tr><td><code id="calculate_expression_profile_+3A_slack">slack</code></td>
<td>
<p>slack needs to be &gt;=readLength, adjust for efficiency; the default is 200,
as it is higher than most modern sequencing experiments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function outputs a list: the first element is a matrix of expression profiles.
Rows correspond to positions in the exon transcript and each column corresponds to an input
BAM file. Each read is counted for all the positions with which it overlaps (so a read of
length 100 that completely overlaps with the exon would be counted for all 100 positions).
The second list element is a vector of raw expression of the gene in the different BAM files
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bams &lt;- rep(system.file("extdata", "ex1.bam", package="Rsamtools", mustWork=TRUE), 2)
genes &lt;- data.frame("id" = 1:2,
                    "gene_id" = c("gene1", "gene2"),
                    "seqid" = c("seq1", "seq2"),
                    "start" = 1,
                    "end" = 100)
profile &lt;- calculate_expression_profile(
  gene = genes[1,],
  bams = bams,
  mapq.unique = 99
)

ggplot2::ggplot(tibble::tibble(y = profile$profile[,1],
                               x = seq_along(y))) +
ggplot2::geom_bar(ggplot2::aes(x, y), stat = "identity") +
ggplot2::theme_minimal()
</code></pre>

<hr>
<h2 id='calculate_expression_similarity_counts'>Calcualate the expression levels and expression levels similarity matrices using the count matrix</h2><span id='topic+calculate_expression_similarity_counts'></span>

<h3>Description</h3>

<p>This function generates an average similarity (correlation/inverse distance) coefficient
for every sliding window, for each sample in the expression matrix.
That is done by comparing the distribution of genes in each window across samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_expression_similarity_counts(
  expression.matrix,
  similarity.measure = "correlation_pearson",
  n.elements.per.window = NULL,
  n.step = NULL,
  n.step.fraction = 0.05,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_expression_similarity_counts_+3A_expression.matrix">expression.matrix</code></td>
<td>
<p>the expression matrix, can be normalized or not</p>
</td></tr>
<tr><td><code id="calculate_expression_similarity_counts_+3A_similarity.measure">similarity.measure</code></td>
<td>
<p>one of the correlation or distance metrics to be used,
defaults to pearson correlation; list of all methods in
<code><a href="#topic+get_methods_correlation_distance">get_methods_correlation_distance</a></code></p>
</td></tr>
<tr><td><code id="calculate_expression_similarity_counts_+3A_n.elements.per.window">n.elements.per.window</code></td>
<td>
<p>number of elements to have in a window,
default 10% of the number of rows</p>
</td></tr>
<tr><td><code id="calculate_expression_similarity_counts_+3A_n.step">n.step</code></td>
<td>
<p>step size to slide across, default 1% of n.elements.per.window</p>
</td></tr>
<tr><td><code id="calculate_expression_similarity_counts_+3A_n.step.fraction">n.step.fraction</code></td>
<td>
<p>an alternative way to specify the step size, as a fraction of
the window length; default is 5%</p>
</td></tr>
<tr><td><code id="calculate_expression_similarity_counts_+3A_...">...</code></td>
<td>
<p>arguments passed on to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with three elements: the first element is the expression matrix,
as supplied; the other two are the expression levels matrix and
expression levels similarity matrix;
they have the same # of columns as the expression matrix,
and n.elements.per.window * n.step rows.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calculate_expression_similarity_transcript">calculate_expression_similarity_transcript</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>calculate_expression_similarity_counts(
    expression.matrix = matrix(1:100, ncol = 5),
    similarity.measure = "correlation_pearson",
    n.elements.per.window = 3)
</code></pre>

<hr>
<h2 id='calculate_expression_similarity_transcript'>Calcualte the distance matrices using the BAM files</h2><span id='topic+calculate_expression_similarity_transcript'></span>

<h3>Description</h3>

<p>This function generates an average correlation/distance coefficient
for every exon present in the BAM files. This is done by calculating
the point-to-point correlation/distance of the distribution of reads
across the transcript of each exon and comparing it across samples.
The reason why exons are used instead of full length genes is that long
intronic regions artificially increase the correlation since there is
consistently no expression there, across samples. The user has the
option to use genes instead, by running <code><a href="#topic+cast_gtf_to_genes">cast_gtf_to_genes</a></code> separately,
with non default parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_expression_similarity_transcript(
  bams = NULL,
  path.bams = ".",
  genes = NULL,
  path.gtf = list.files(".", pattern = "\\.g[tf]f$"),
  expression.matrix = NULL,
  subsample.genes = FALSE,
  make.index = FALSE,
  unique.only = TRUE,
  mapq.unique = 255,
  slack = 200,
  similarity.measure = "correlation_pearson",
  save.image.every.1000 = FALSE,
  ncores = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_expression_similarity_transcript_+3A_bams">bams</code>, <code id="calculate_expression_similarity_transcript_+3A_path.bams">path.bams</code></td>
<td>
<p>either a path to the directory where the BAM files are
or a vector of paths to each individual file; if a path is specified,
it extracts all files that end in .bam; looks in the working directory by default</p>
</td></tr>
<tr><td><code id="calculate_expression_similarity_transcript_+3A_genes">genes</code></td>
<td>
<p>a tibble of the exons extracted from the gtf file;
this is meant for speed if the output of <code><a href="#topic+cast_gtf_to_genes">cast_gtf_to_genes</a></code> is already generated,
or if the user wants to only calculate similarity for a subset of exons</p>
</td></tr>
<tr><td><code id="calculate_expression_similarity_transcript_+3A_path.gtf">path.gtf</code></td>
<td>
<p>the path to the gtf/gff annotation file (only used if genes is not
provided); if unspecified, looks for one in the working directory</p>
</td></tr>
<tr><td><code id="calculate_expression_similarity_transcript_+3A_expression.matrix">expression.matrix</code></td>
<td>
<p>expression matrix; not necessary but is used to filter the
gtf to fewer entries and for subsampling if subsample.genes=TRUE;
if not provided, raw read counts per exon are extracted from the BAM files</p>
</td></tr>
<tr><td><code id="calculate_expression_similarity_transcript_+3A_subsample.genes">subsample.genes</code></td>
<td>
<p>logical, whether to subsample low abundance genes to decrease
computational time; the first minimum of the distribution of abundances is calculated,
and genes lower than it are subsampled to match the number of genes higher than it;
the expression matrix needs to be provided for this calculation;
a plot is generated to show that minimum</p>
</td></tr>
<tr><td><code id="calculate_expression_similarity_transcript_+3A_make.index">make.index</code></td>
<td>
<p>whether a BAM index should be generated; if this is FALSE (the default)
and no index exists, the function will exit with an error; the index needs to have
the same name as each BAM file, but ending with .bam.bai</p>
</td></tr>
<tr><td><code id="calculate_expression_similarity_transcript_+3A_unique.only">unique.only</code></td>
<td>
<p>whether only uniquely mapped reads should contribute to the expression
of a gene/exon; default is TRUE</p>
</td></tr>
<tr><td><code id="calculate_expression_similarity_transcript_+3A_mapq.unique">mapq.unique</code></td>
<td>
<p>The values of the mapping quality field in the BAM file that corresponds
to uniquely mapped reads; by default, values of 255 are used as these correspond to
the most popular aligners, but an adjustment might be needed;
the mapq scores should be as follows: 255 for STAR, 60 for hisat2,
255 for bowtie in -k mode, 40 for bowtie2 default, 50 for tophat</p>
</td></tr>
<tr><td><code id="calculate_expression_similarity_transcript_+3A_slack">slack</code></td>
<td>
<p>slack needs to be &gt;=readLength, adjust for efficiency; the default is 200,
as it is higher than most modern sequencing experiments</p>
</td></tr>
<tr><td><code id="calculate_expression_similarity_transcript_+3A_similarity.measure">similarity.measure</code></td>
<td>
<p>one of the similarity metrics to be used, defaults to pearson correlation;
currently, only correlation is supported</p>
</td></tr>
<tr><td><code id="calculate_expression_similarity_transcript_+3A_save.image.every.1000">save.image.every.1000</code></td>
<td>
<p>whether to save a workspace image after every 1000 exons
are processed; default is FALSE</p>
</td></tr>
<tr><td><code id="calculate_expression_similarity_transcript_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for parallel computation; defaults to sequential computation,
but parallelisation is highly encouraged; it is set to detectCores() if higher</p>
</td></tr>
<tr><td><code id="calculate_expression_similarity_transcript_+3A_...">...</code></td>
<td>
<p>arguments passed on to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with three elements: the first element is the expression matrix,
as supplied or calculated; the other two are the expression levels matrix and
expression levels similarity matrix;
they have the same # of columns as the expression matrix,
and as many rows as exons processed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calculate_expression_similarity_counts">calculate_expression_similarity_counts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bams &lt;- rep(system.file("extdata", "ex1.bam", package="Rsamtools", mustWork=TRUE), 2)
genes &lt;- data.frame("id" = 1:2,
                    "gene_id" = c("gene1", "gene2"),
                    "seqid" = c("seq1", "seq2"),
                    "start" = 1,
                    "end" = 1600)
expression.summary &lt;- calculate_expression_similarity_transcript(
  bams = bams,
  genes = genes,
  mapq.unique = 99
)
</code></pre>

<hr>
<h2 id='calculate_first_minimum_density'>Function to find the first local minimum of the density of a vector</h2><span id='topic+calculate_first_minimum_density'></span>

<h3>Description</h3>

<p>This function is used to estimate the first local minimum of the
density of a vector.
It is meant to be used on the distribution of expression of genes in a sample;
since the distribution tails off, finding the global minimum is not appropriate.
The plot option can be used to visualise the process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_first_minimum_density(
  mat,
  log.transform = TRUE,
  adjust = 2,
  makeplots = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_first_minimum_density_+3A_mat">mat</code></td>
<td>
<p>matrix whose columns will be used; usually an expression matrix; it
can also be a vector</p>
</td></tr>
<tr><td><code id="calculate_first_minimum_density_+3A_log.transform">log.transform</code></td>
<td>
<p>whether to log-transform the data before the density estimation;
default is TRUE</p>
</td></tr>
<tr><td><code id="calculate_first_minimum_density_+3A_adjust">adjust</code></td>
<td>
<p>adjust factor for the smoothing, passed to density(); default is 2</p>
</td></tr>
<tr><td><code id="calculate_first_minimum_density_+3A_makeplots">makeplots</code></td>
<td>
<p>a logical value of whether a plot with a vertical line on the minimum found
should be printed for each column of the matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function outputs a single value corresponding to the median of the minima calculated
for each column of the matrix. floor() is taken as a conservative estimate
</p>


<h3>Examples</h3>

<pre><code class='language-R'>calculate_first_minimum_density(
  matrix(c(rep(0,100),rep(3,30),rep(10,50),12,13,15,20),ncol=1),
  log.transform=FALSE, makeplots=TRUE
)

</code></pre>

<hr>
<h2 id='calculate_noise_threshold'>Function to calculate the noise threshold for a given expression matrix and parameters</h2><span id='topic+calculate_noise_threshold'></span>

<h3>Description</h3>

<p>This function is used to calculate the noise threshold for a given expression matrix.
It uses as input an expression profile, or just an expression matrix for a simple calculation based on density.
A variety of methods are available to obtain a noise threshold using an input similarity threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_noise_threshold(
  expression,
  similarity.threshold = 0.25,
  method.chosen = "Boxplot-IQR",
  binsize = 0.1,
  minimum.observations.per.bin = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_noise_threshold_+3A_expression">expression</code></td>
<td>
<p>either an expression summary (as calculated by
<code><a href="#topic+calculate_expression_similarity_counts">calculate_expression_similarity_counts</a></code> or <code><a href="#topic+calculate_expression_similarity_transcript">calculate_expression_similarity_transcript</a></code>),
which should be a list with 3 slots: expression.matrix, expression.levels, expression.levels.similarity;
alternatively, just an expression matrix; only density based methods are available for the latter case</p>
</td></tr>
<tr><td><code id="calculate_noise_threshold_+3A_similarity.threshold">similarity.threshold</code></td>
<td>
<p>similarity (correlation or inverse distance) threshold to be used
to find corresponding noise threshold; the default, 0.25 is usually suitable for the
Pearson correlation (the default similarity measure)</p>
</td></tr>
<tr><td><code id="calculate_noise_threshold_+3A_method.chosen">method.chosen</code></td>
<td>
<p>method to use to obtain a vector of noise thresholds,
must be one of <code><a href="#topic+get_methods_calculate_noise_threshold">get_methods_calculate_noise_threshold</a></code>; defaults to Boxplot-IQR</p>
</td></tr>
<tr><td><code id="calculate_noise_threshold_+3A_binsize">binsize</code></td>
<td>
<p>size of each bin in the boxplot methods; defaults to 0.1 (on a log-scale)</p>
</td></tr>
<tr><td><code id="calculate_noise_threshold_+3A_minimum.observations.per.bin">minimum.observations.per.bin</code></td>
<td>
<p>minumum number of observations allowed in each bin of the boxplot;
if a bin has fewer observations, it is merged with the one to its left; default is calculated as:
ceiling(number of observations / number of bins / 10)</p>
</td></tr>
<tr><td><code id="calculate_noise_threshold_+3A_...">...</code></td>
<td>
<p>arguments passed on to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is a vector of noise thresholds, the same length as the number of columns in
the expression matrix, or a single value in the case of density based methods.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calculate_noise_threshold_method_statistics">calculate_noise_threshold_method_statistics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expression.summary &lt;- calculate_expression_similarity_counts(
    expression.matrix = matrix(1:100, ncol=5),
    method = "correlation_pearson",
    n.elements.per.window = 3)
calculate_noise_threshold(expression.summary)
</code></pre>

<hr>
<h2 id='calculate_noise_threshold_method_statistics'>Function to tabulate statistics for different methods of calculating the noise threshold</h2><span id='topic+calculate_noise_threshold_method_statistics'></span>

<h3>Description</h3>

<p>This function is used to tabulate and compare different combinations of similarity
threshold and method to calculate the noise threshold for a given expression matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_noise_threshold_method_statistics(
  expression,
  similarity.threshold.sequence = 0.25,
  method.chosen.sequence = noisyr::get_methods_calculate_noise_threshold(),
  dump.stats = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_noise_threshold_method_statistics_+3A_expression">expression</code></td>
<td>
<p>either an expression summary (as calculated by
<code><a href="#topic+calculate_expression_similarity_counts">calculate_expression_similarity_counts</a></code> or <code><a href="#topic+calculate_expression_similarity_transcript">calculate_expression_similarity_transcript</a></code>),
which should be a list with 3 slots: expression.matrix, expression.levels, expression.levels.similarity;
alternatively, just an expression matrix; only density based methods are available for the latter case</p>
</td></tr>
<tr><td><code id="calculate_noise_threshold_method_statistics_+3A_similarity.threshold.sequence">similarity.threshold.sequence</code></td>
<td>
<p>similarity (correlation or inverse distance) threshold(s) to be used
to find corresponding noise threshold; can be a single value or a numeric vector;
the default, 0.25 is usually suitable for the Pearson correlation (the default similarity measure)</p>
</td></tr>
<tr><td><code id="calculate_noise_threshold_method_statistics_+3A_method.chosen.sequence">method.chosen.sequence</code></td>
<td>
<p>methods to use to calculate the noise thresholds,
must be a subset of <code><a href="#topic+get_methods_calculate_noise_threshold">get_methods_calculate_noise_threshold</a></code>; defaults to all</p>
</td></tr>
<tr><td><code id="calculate_noise_threshold_method_statistics_+3A_dump.stats">dump.stats</code></td>
<td>
<p>name of csv to export different thresholds calculated (optional)</p>
</td></tr>
<tr><td><code id="calculate_noise_threshold_method_statistics_+3A_...">...</code></td>
<td>
<p>other arguments (for the boxplot methods) passed to <code><a href="#topic+calculate_noise_threshold">calculate_noise_threshold</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble containing information on noise thresholds calculated using the input
similarity thresholds and methods (optionally written in a csv file).
The columns list the chosen method and similarity threshold, the minimum, mean,
coefficient of variation, and maximum of the noise thresholds, and all the noise thresholds
concatenated as a string.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calculate_noise_threshold">calculate_noise_threshold</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expression.summary &lt;- calculate_expression_similarity_counts(
    expression.matrix = matrix(1:100, ncol=5),
    method = "correlation_pearson",
    n.elements.per.window = 3)
calculate_noise_threshold_method_statistics(expression.summary)
</code></pre>

<hr>
<h2 id='cast_gtf_to_genes'>Function to extract exon names and positions from a gtf file</h2><span id='topic+cast_gtf_to_genes'></span>

<h3>Description</h3>

<p>This function is used to extract all exons and their positions
in the genome from an input gtf file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cast_gtf_to_genes(filename, feature = "exon", att_of_interest = "gene_id", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cast_gtf_to_genes_+3A_filename">filename</code></td>
<td>
<p>path to the gtf file</p>
</td></tr>
<tr><td><code id="cast_gtf_to_genes_+3A_feature">feature</code></td>
<td>
<p>the feature type name to filter the feature (3rd) column of the gtf/gff file;
default is exon</p>
</td></tr>
<tr><td><code id="cast_gtf_to_genes_+3A_att_of_interest">att_of_interest</code></td>
<td>
<p>the attribute to extract from the last column of the gtf/gff file;
default in gene_id</p>
</td></tr>
<tr><td><code id="cast_gtf_to_genes_+3A_...">...</code></td>
<td>
<p>arguments passed on to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble of the ids, gene names, chromosomes, start and end positions
of each exon found in the gtf file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fl &lt;- system.file("extdata", "example.gtf.gz", package="Rsamtools", mustWork=TRUE)
cast_gtf_to_genes(fl)
</code></pre>

<hr>
<h2 id='cast_matrix_to_numeric'>Cast a matrix of any type to numeric</h2><span id='topic+cast_matrix_to_numeric'></span>

<h3>Description</h3>

<p>Transforms values in the expression matrix to numeric,
to make it compatible with the rest of the functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cast_matrix_to_numeric(expression.matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cast_matrix_to_numeric_+3A_expression.matrix">expression.matrix</code></td>
<td>
<p>The expression matrix (usually read from a file)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The expression matrix transformed to numeric, preserving row and column names.
Any values that are not coercible to numeric are replaced by 0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cast_matrix_to_numeric(matrix(
    c(1, "2", 3.0, 4),
    ncol=2,
    dimnames=list(paste0("X", 1:2),
                  paste0("Y", 1:2))))
</code></pre>

<hr>
<h2 id='filter_genes_transcript'>Function to filter the gene table for the transcript approach</h2><span id='topic+filter_genes_transcript'></span>

<h3>Description</h3>

<p>This function is used to filter the gene table (usually created with
<code><a href="#topic+cast_gtf_to_genes">cast_gtf_to_genes</a></code>), only keeping genes above the noise thresholds.
It uses as input the gene table (usually containing individual exons),
an expression matrix for each of these and a vector of abundance thresholds.
This function is used internally by <code><a href="#topic+remove_noise_from_bams">remove_noise_from_bams</a></code> to determine
which genes to retain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_genes_transcript(
  genes,
  expression.matrix,
  noise.thresholds,
  filter.by = c("gene", "exon"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_genes_transcript_+3A_genes">genes</code></td>
<td>
<p>a tibble of the exons extracted from the gtf file;
(usually the the output of <code><a href="#topic+cast_gtf_to_genes">cast_gtf_to_genes</a></code>)</p>
</td></tr>
<tr><td><code id="filter_genes_transcript_+3A_expression.matrix">expression.matrix</code></td>
<td>
<p>the expression matrix, usually
calculated by <code><a href="#topic+calculate_expression_similarity_transcript">calculate_expression_similarity_transcript</a></code></p>
</td></tr>
<tr><td><code id="filter_genes_transcript_+3A_noise.thresholds">noise.thresholds</code></td>
<td>
<p>a vector of expression thresholds by sample</p>
</td></tr>
<tr><td><code id="filter_genes_transcript_+3A_filter.by">filter.by</code></td>
<td>
<p>Either &quot;gene&quot; (default) or &quot;exon&quot;; if filter.by=&quot;gene&quot;, a gene
(as determined by its ENSEMBL id) is removed
if and only if all of its exons are below the corresponding noise thresholds;
if filter.by=&quot;exon&quot;, then each exon is individually removed
if it is below the corresponding noise thresholds.</p>
</td></tr>
<tr><td><code id="filter_genes_transcript_+3A_...">...</code></td>
<td>
<p>arguments passed on to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a filtered tibble of exons, with the noise removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bams &lt;- rep(system.file("extdata", "ex1.bam", package="Rsamtools", mustWork=TRUE), 2)
genes &lt;- data.frame("id" = 1:2,
                    "gene_id" = c("gene1", "gene2"),
                    "seqid" = c("seq1", "seq2"),
                    "start" = 1,
                    "end" = 1600)
noise.thresholds &lt;- c(0, 1)
expression.summary = calculate_expression_similarity_transcript(
  bams = bams,
  genes = genes,
  mapq.unique = 99
)
filter_genes_transcript(
    genes = genes,
    expression.matrix = expression.summary$expression.matrix,
    noise.thresholds = noise.thresholds,
)

</code></pre>

<hr>
<h2 id='get_methods_calculate_noise_threshold'>Show the methods for calculating a noise threshold</h2><span id='topic+get_methods_calculate_noise_threshold'></span>

<h3>Description</h3>

<p>This function outputs the methods available for the calculation of
the noise threshold. To be used as input in <code><a href="#topic+calculate_noise_threshold">calculate_noise_threshold</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_methods_calculate_noise_threshold()
</code></pre>


<h3>Value</h3>

<p>A character vector of options for the method.chosen arguement of
<code><a href="#topic+calculate_noise_threshold">calculate_noise_threshold</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_methods_calculate_noise_threshold()
</code></pre>

<hr>
<h2 id='get_methods_correlation_distance'>Show the methods for calculating correlation or distance</h2><span id='topic+get_methods_correlation_distance'></span>

<h3>Description</h3>

<p>This function outputs the methods available for the calculation of
the correlation or distance. The standard correlation methods use stats::cor and
a wide variety of distance methods are available using the philentropy package.
To be used as input in <code><a href="#topic+calculate_expression_similarity_counts">calculate_expression_similarity_counts</a></code> or
<code><a href="#topic+calculate_expression_similarity_transcript">calculate_expression_similarity_transcript</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_methods_correlation_distance(names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_methods_correlation_distance_+3A_names">names</code></td>
<td>
<p>whether to output names (default) or characterisation
as similarity or dissimilarity (used internally to invert dissimilarity measures)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of options for the method arguement of the similarity calculation;
if names=FALSE, a vector of types (similarity/dissimilarity measure) of the same length
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_methods_correlation_distance()
</code></pre>

<hr>
<h2 id='noisyr'>Run the noisyR pipeline</h2><span id='topic+noisyr'></span>

<h3>Description</h3>

<p>Calls one of noisyr_counts or noisyr_transcript, with the specified parameters.
See the individual function documentation for more details and required arguments:
<code><a href="#topic+noisyr_counts">noisyr_counts</a></code>, <code><a href="#topic+noisyr_transcript">noisyr_transcript</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noisyr(approach.for.similarity.calculation = c("counts", "transcript"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noisyr_+3A_approach.for.similarity.calculation">approach.for.similarity.calculation</code></td>
<td>
<p>which approach to use for the similarity calculation;
defaults to counts</p>
</td></tr>
<tr><td><code id="noisyr_+3A_...">...</code></td>
<td>
<p>arguments to be passed on to noisyr_counts or noisyr_transcript; see their documentation
for more details and required arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the counts approach, the denoised expression matrix. For the transcript approach,
the numeric vector of noise thresholds per sample. For more details, see their respective documentation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>noisyr(approach.for.similarity.calculation = "counts",
       expression.matrix = matrix(1:100, ncol = 5))
</code></pre>

<hr>
<h2 id='noisyr_counts'>Run the noisyR pipeline for the count matrix approach</h2><span id='topic+noisyr_counts'></span>

<h3>Description</h3>

<p>Calls the functions to run each of the three steps of the pipeline
(similarity calculation, noise quantification, noise removal), with the specified parameters.
See the individual function documentation for more details and required arguments.
Required steps: <code><a href="#topic+calculate_expression_similarity_counts">calculate_expression_similarity_counts</a></code>,
<code><a href="#topic+calculate_noise_threshold">calculate_noise_threshold</a></code>. <code><a href="#topic+remove_noise_from_matrix">remove_noise_from_matrix</a></code>.
Optional steps: <code><a href="#topic+optimise_window_length">optimise_window_length</a></code>,
<code><a href="#topic+calculate_noise_threshold_method_statistics">calculate_noise_threshold_method_statistics</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noisyr_counts(
  expression.matrix,
  n.elements.per.window = NULL,
  optimise.window.length.logical = FALSE,
  similarity.threshold = 0.25,
  method.chosen = "Boxplot-IQR",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noisyr_counts_+3A_expression.matrix">expression.matrix</code></td>
<td>
<p>the expression matrix used as input for the similarity calculation;
this argument is required</p>
</td></tr>
<tr><td><code id="noisyr_counts_+3A_n.elements.per.window">n.elements.per.window</code></td>
<td>
<p>number of elements to have in a window passed to
calculate_expression_similarity_counts(); default 10% of the number of rows</p>
</td></tr>
<tr><td><code id="noisyr_counts_+3A_optimise.window.length.logical">optimise.window.length.logical</code></td>
<td>
<p>whether to call optimise_window_length to try and
optimise the value of n.elements.per.window</p>
</td></tr>
<tr><td><code id="noisyr_counts_+3A_similarity.threshold">similarity.threshold</code>, <code id="noisyr_counts_+3A_method.chosen">method.chosen</code></td>
<td>
<p>parameters passed on to
<code><a href="#topic+calculate_noise_threshold">calculate_noise_threshold</a></code>; they can be single values or vectors;
if they are vectors optimal values are computed by calling
<code><a href="#topic+calculate_noise_threshold_method_statistics">calculate_noise_threshold_method_statistics</a></code> and
minimising the coefficient of variation across samples; all possible values for
method.chosen can be viewed by <code><a href="#topic+get_methods_calculate_noise_threshold">get_methods_calculate_noise_threshold</a></code></p>
</td></tr>
<tr><td><code id="noisyr_counts_+3A_...">...</code></td>
<td>
<p>arguments to be passed on to individual pipeline steps</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The denoised expression matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+noisyr">noisyr</a></code>, <code><a href="#topic+noisyr_transcript">noisyr_transcript</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>noisyr_counts(
    expression.matrix = matrix(1:100, ncol = 5),
    similarity.measure = "correlation_pearson",
    n.elements.per.window = 3)
</code></pre>

<hr>
<h2 id='noisyr_transcript'>Run the noisyR pipeline for the transcript approach</h2><span id='topic+noisyr_transcript'></span>

<h3>Description</h3>

<p>Calls the functions to run each of the three steps of the pipeline
(similarity calculation, noise quantification, noise removal), with the specified parameters.
See the individual function documentation for more details and required arguments.
Required steps: <code><a href="#topic+calculate_expression_similarity_transcript">calculate_expression_similarity_transcript</a></code>,
<code><a href="#topic+calculate_noise_threshold">calculate_noise_threshold</a></code>. <code><a href="#topic+remove_noise_from_bams">remove_noise_from_bams</a></code>.
Optional steps: <code><a href="#topic+calculate_noise_threshold_method_statistics">calculate_noise_threshold_method_statistics</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noisyr_transcript(
  bams = NULL,
  path.bams = ".",
  genes = NULL,
  path.gtf = list.files(".", pattern = "\\.g[tf]f$"),
  ncores = 1,
  similarity.threshold = 0.25,
  method.chosen = "Boxplot-IQR",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noisyr_transcript_+3A_bams">bams</code>, <code id="noisyr_transcript_+3A_path.bams">path.bams</code></td>
<td>
<p>either a path to the directory where the BAM files are
or a vector of paths to each individual file; if a path is specified,
it extracts all files that end in .bam; looks in the working directory by default</p>
</td></tr>
<tr><td><code id="noisyr_transcript_+3A_genes">genes</code></td>
<td>
<p>a tibble of the exons extracted from the gtf file;
this is meant for speed if the output of <code><a href="#topic+cast_gtf_to_genes">cast_gtf_to_genes</a></code> is already generated,
or if the user wants to only calculate similarity for a subset of exons</p>
</td></tr>
<tr><td><code id="noisyr_transcript_+3A_path.gtf">path.gtf</code></td>
<td>
<p>the path to the gtf/gff annotation file (only used if genes is not
provided); if unspecified, looks for one in the working directory</p>
</td></tr>
<tr><td><code id="noisyr_transcript_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for parallel computation; defaults to sequential computation,
but parallelisation is highly encouraged; it is set to detectCores() if higher</p>
</td></tr>
<tr><td><code id="noisyr_transcript_+3A_similarity.threshold">similarity.threshold</code>, <code id="noisyr_transcript_+3A_method.chosen">method.chosen</code></td>
<td>
<p>parameters passed on to
<code><a href="#topic+calculate_noise_threshold">calculate_noise_threshold</a></code>; they can be single values or vectors;
if they are vectors optimal values are computed by calling
<code><a href="#topic+calculate_noise_threshold_method_statistics">calculate_noise_threshold_method_statistics</a></code> and
minimising the coefficient of variation across samples; all possible values for
method.chosen can be viewed by <code><a href="#topic+get_methods_calculate_noise_threshold">get_methods_calculate_noise_threshold</a></code>;
only boxplot based methods are accepted for the transcript approach due to the number of observations
and high variance</p>
</td></tr>
<tr><td><code id="noisyr_transcript_+3A_...">...</code></td>
<td>
<p>arguments to be passed on to individual pipeline steps; see their documentation
for more details and required arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The denoised BAM files are created, as specified by the destination.files argument
of remove_noise_from_bams()
</p>


<h3>See Also</h3>

<p><code><a href="#topic+noisyr">noisyr</a></code>, <code><a href="#topic+noisyr_counts">noisyr_counts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bams &lt;- rep(system.file("extdata", "ex1.bam", package="Rsamtools", mustWork=TRUE), 2)
genes &lt;- data.frame("id" = 1:2,
                    "gene_id" = c("gene1", "gene2"),
                    "seqid" = c("seq1", "seq2"),
                    "start" = 1,
                    "end" = 1600)
noisyr_transcript(
  bams = bams,
  genes = genes,
  destination.files = paste0(tempdir(), "/", basename(bams), ".noisefiltered.bam")
)
</code></pre>

<hr>
<h2 id='optimise_window_length'>Optimise the elements per window for the count matrix approach</h2><span id='topic+optimise_window_length'></span>

<h3>Description</h3>

<p>This function optimises the number of elements per window
that is used in <code><a href="#topic+calculate_expression_similarity_counts">calculate_expression_similarity_counts</a></code>, by requiring
the distribution of correlations/distances to stabilise to a
uniform distribution. The Jensen-Shannon divergence is used to assess
the stability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimise_window_length(
  expression.matrix,
  similarity.measure = "correlation_pearson",
  window.length.min = NULL,
  window.length.max = NULL,
  window.length.by = NULL,
  n.step.fraction = 0.05,
  iteration.number = 50,
  minimum.similar.windows = 3,
  save.plot = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimise_window_length_+3A_expression.matrix">expression.matrix</code></td>
<td>
<p>expression matrix, can be normalized or not</p>
</td></tr>
<tr><td><code id="optimise_window_length_+3A_similarity.measure">similarity.measure</code></td>
<td>
<p>one of the correlation or distance metrics to be used,
defaults to pearson correlation; list of all methods in
<code><a href="#topic+get_methods_correlation_distance">get_methods_correlation_distance</a></code></p>
</td></tr>
<tr><td><code id="optimise_window_length_+3A_window.length.min">window.length.min</code>, <code id="optimise_window_length_+3A_window.length.max">window.length.max</code>, <code id="optimise_window_length_+3A_window.length.by">window.length.by</code></td>
<td>
<p>definition of the parameter search space;
default is between 1% and 33% of the number of rows in the expression matrix,
incremented by 1%</p>
</td></tr>
<tr><td><code id="optimise_window_length_+3A_n.step.fraction">n.step.fraction</code></td>
<td>
<p>step size to slide across, as a fraction of
the window length; default is 5%</p>
</td></tr>
<tr><td><code id="optimise_window_length_+3A_iteration.number">iteration.number</code></td>
<td>
<p>number of iterations for the subsampling and calculation of JSE;
subsampling is needed because shorter windows have fewer points; default is 100</p>
</td></tr>
<tr><td><code id="optimise_window_length_+3A_minimum.similar.windows">minimum.similar.windows</code></td>
<td>
<p>number of windows that a window needs to be similar to (including itself)
in order to be accepted as optimal; default is 3, but can be reduced to 2 if no optimum is found</p>
</td></tr>
<tr><td><code id="optimise_window_length_+3A_save.plot">save.plot</code></td>
<td>
<p>name of the pdf in which to print the output plot
showing the distribution of JSE by window; output to the console by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single value of the optimal number of elements per window.
If no optimal value was found, this function returns NULL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>optimise_window_length(
  matrix(1:100+runif(100), ncol=5, byrow=TRUE),
  window.length.min=3, window.length.max=5, iteration.number=5
)
</code></pre>

<hr>
<h2 id='plot_expression_similarity'>Plot the similarity against expression levels</h2><span id='topic+plot_expression_similarity'></span>

<h3>Description</h3>

<p>Creates the expression-similarity line and box plots for each sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_expression_similarity(
  expression.summary,
  sample.names = NULL,
  similarity.name = "Pearson correlation",
  log.transform = TRUE,
  min.y = NULL,
  max.y = NULL,
  smooth.span = 0.1,
  only.boxplot = FALSE,
  binsize = 1,
  last.together = 0,
  show.counts = TRUE,
  add.threshold = NULL,
  file.name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_expression_similarity_+3A_expression.summary">expression.summary</code></td>
<td>
<p>list containing expression_levels and expression_levels_similarity
matrices, as calculated by <code><a href="#topic+calculate_expression_similarity_counts">calculate_expression_similarity_counts</a></code> or
<code><a href="#topic+calculate_expression_similarity_transcript">calculate_expression_similarity_transcript</a></code></p>
</td></tr>
<tr><td><code id="plot_expression_similarity_+3A_sample.names">sample.names</code></td>
<td>
<p>names for the plots, defaults to the column names of the expression matrix</p>
</td></tr>
<tr><td><code id="plot_expression_similarity_+3A_similarity.name">similarity.name</code></td>
<td>
<p>similarity metric used (for the y-axis title)</p>
</td></tr>
<tr><td><code id="plot_expression_similarity_+3A_log.transform">log.transform</code></td>
<td>
<p>should the count matrix be log-transformed? If not, boxplot is skipped</p>
</td></tr>
<tr><td><code id="plot_expression_similarity_+3A_min.y">min.y</code>, <code id="plot_expression_similarity_+3A_max.y">max.y</code></td>
<td>
<p>limits for the y axis. If unset default to symmetric including all values
in expression.levels.similarity; min is set to 0 if there are no negative values</p>
</td></tr>
<tr><td><code id="plot_expression_similarity_+3A_smooth.span">smooth.span</code></td>
<td>
<p>span to be used for smoothing in the line plot; defaults to 0.1</p>
</td></tr>
<tr><td><code id="plot_expression_similarity_+3A_only.boxplot">only.boxplot</code></td>
<td>
<p>option to skip the line plot (usually a good idea if there are too many points
and lines are too erratic); sets log.transform to TRUE</p>
</td></tr>
<tr><td><code id="plot_expression_similarity_+3A_binsize">binsize</code></td>
<td>
<p>size of each bin in the boxplot; defaults to 0.5</p>
</td></tr>
<tr><td><code id="plot_expression_similarity_+3A_last.together">last.together</code></td>
<td>
<p>groups observations so the highest abundance bin has at least this many</p>
</td></tr>
<tr><td><code id="plot_expression_similarity_+3A_show.counts">show.counts</code></td>
<td>
<p>whether to show how many observations are in each bin</p>
</td></tr>
<tr><td><code id="plot_expression_similarity_+3A_add.threshold">add.threshold</code></td>
<td>
<p>adds a horizontal line at this value</p>
</td></tr>
<tr><td><code id="plot_expression_similarity_+3A_file.name">file.name</code></td>
<td>
<p>name of pdf to output the plots; if not provided (default), no printing is done</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of all the plots (returned silently)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plots &lt;- plot_expression_similarity(
  expression.summary=list(
    "expression.levels" = matrix(2^(10*seq(0,1,length.out=100))),
    "expression.levels.similarity" = matrix(seq(0,1,length.out=100)+(runif(100)/5))))
plots[[1]]
plots[[2]]
</code></pre>

<hr>
<h2 id='remove_noise_from_bams'>Function to remove the noisy reads from the BAM files</h2><span id='topic+remove_noise_from_bams'></span>

<h3>Description</h3>

<p>This function is used to remove the noisy reads from the BAM files.
It uses as input the BAM file names, a gene table (usually containing individual exons,
made using <code><a href="#topic+cast_gtf_to_genes">cast_gtf_to_genes</a></code>), an expression matrix for each of these genes and
a vector of abundance thresholds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_noise_from_bams(
  bams,
  genes,
  expression,
  noise.thresholds,
  destination.files = base::paste0(base::basename(bams), ".noisefiltered.bam"),
  filter.by = c("gene", "exon"),
  make.index = FALSE,
  unique.only = TRUE,
  mapq.unique = 255,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_noise_from_bams_+3A_bams">bams</code></td>
<td>
<p>a character vector of the BAM file names</p>
</td></tr>
<tr><td><code id="remove_noise_from_bams_+3A_genes">genes</code></td>
<td>
<p>a tibble of the exons extracted from the gtf file;
(usually the the output of <code><a href="#topic+cast_gtf_to_genes">cast_gtf_to_genes</a></code>)</p>
</td></tr>
<tr><td><code id="remove_noise_from_bams_+3A_expression">expression</code></td>
<td>
<p>the expression matrix or expression summary list,
as calculated by <code><a href="#topic+calculate_expression_similarity_transcript">calculate_expression_similarity_transcript</a></code></p>
</td></tr>
<tr><td><code id="remove_noise_from_bams_+3A_noise.thresholds">noise.thresholds</code></td>
<td>
<p>a vector of expression thresholds by sample;
must be the same length as the number of BAM files,
or a singular value to be used as a fixed noise threshold</p>
</td></tr>
<tr><td><code id="remove_noise_from_bams_+3A_destination.files">destination.files</code></td>
<td>
<p>names for the output denoised BAM files; by default the same as
the original files, appended with &quot;.noisefiltered.bam&quot;, but created in the working directory</p>
</td></tr>
<tr><td><code id="remove_noise_from_bams_+3A_filter.by">filter.by</code></td>
<td>
<p>Either &quot;gene&quot; (default) or &quot;exon&quot;; if filter.by=&quot;gene&quot;, a gene is removed from all BAM files
if and only if all of its exons are below the corresponding noise thresholds;
if filter.by=&quot;exon&quot;, then each exon is individually removed (from all samples)
if it is below the corresponding noise thresholds.</p>
</td></tr>
<tr><td><code id="remove_noise_from_bams_+3A_make.index">make.index</code></td>
<td>
<p>whether a BAM index should be generated; if this is FALSE (the default)
and no index exists, the function will exit with an error; the index needs to have
the same name as each BAM file, but ending with .bam.bai</p>
</td></tr>
<tr><td><code id="remove_noise_from_bams_+3A_unique.only">unique.only</code></td>
<td>
<p>whether only uniquely mapped reads should contribute to the expression
of a gene/exon; default is TRUE</p>
</td></tr>
<tr><td><code id="remove_noise_from_bams_+3A_mapq.unique">mapq.unique</code></td>
<td>
<p>The values of the mapping quality field in the BAM file that corresponds
to uniquely mapped reads; by default, values of 255 are used as these correspond to
the most popular aligners, but an adjustment might be needed;
the mapq scores should be as follows: 255 for STAR, 60 for hisat2,
255 for bowtie in -k mode, 40 for bowtie2 default, 50 for tophat</p>
</td></tr>
<tr><td><code id="remove_noise_from_bams_+3A_...">...</code></td>
<td>
<p>arguments passed on to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of the same dims as the expression matrix, with the noise removed.
This matrix has no entries remaining below the noise threshold.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+remove_noise_from_matrix">remove_noise_from_matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bams &lt;- rep(system.file("extdata", "ex1.bam", package="Rsamtools", mustWork=TRUE), 2)
genes &lt;- data.frame("id" = 1:2,
                    "gene_id" = c("gene1", "gene2"),
                    "seqid" = c("seq1", "seq2"),
                    "start" = 1,
                    "end" = 1600)
noise.thresholds &lt;- c(0, 1)
expression.summary = calculate_expression_similarity_transcript(
  bams = bams,
  genes = genes,
  mapq.unique = 99
)
remove_noise_from_bams(
    bams = bams,
    genes = genes,
    expression = expression.summary,
    noise.thresholds = noise.thresholds,
    destination.files = paste0(tempdir(), "/", basename(bams), ".noisefiltered.bam"),
    mapq.unique = 99
)

</code></pre>

<hr>
<h2 id='remove_noise_from_matrix'>Function to remove the noisy reads from the expression matrix</h2><span id='topic+remove_noise_from_matrix'></span>

<h3>Description</h3>

<p>This function is used to remove the noisy reads from the expression matrix.
It uses as input a vector of abundance thresholds;
all entries below the noise threshold are replaced with the noise threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_noise_from_matrix(
  expression.matrix,
  noise.thresholds,
  add.threshold = TRUE,
  average.threshold = TRUE,
  remove.noisy.features = TRUE,
  export.csv = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_noise_from_matrix_+3A_expression.matrix">expression.matrix</code></td>
<td>
<p>the expression matrix</p>
</td></tr>
<tr><td><code id="remove_noise_from_matrix_+3A_noise.thresholds">noise.thresholds</code></td>
<td>
<p>a vector of expression thresholds by sample;
must be the same length as the number of columns of the expression matrix,
or a singular value to be used as a fixed noise threshold</p>
</td></tr>
<tr><td><code id="remove_noise_from_matrix_+3A_add.threshold">add.threshold</code></td>
<td>
<p>whether to add the noise threshold to all values in the expression matrix
(default), or set entries below the threshold to the threshold</p>
</td></tr>
<tr><td><code id="remove_noise_from_matrix_+3A_average.threshold">average.threshold</code></td>
<td>
<p>if TRUE (default), uses tthe average of the vector of thresholds across all samples;
if FALSE, uses the thresholds as supplied</p>
</td></tr>
<tr><td><code id="remove_noise_from_matrix_+3A_remove.noisy.features">remove.noisy.features</code></td>
<td>
<p>logical, whether rows of the expression matrix that are
fully under the noise threshold should be removed (default TRUE)</p>
</td></tr>
<tr><td><code id="remove_noise_from_matrix_+3A_export.csv">export.csv</code></td>
<td>
<p>option to write the matrix into a csv after the noise removal;
should be NULL or the name of the output file</p>
</td></tr>
<tr><td><code id="remove_noise_from_matrix_+3A_...">...</code></td>
<td>
<p>arguments passed on to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the expression matrix with the noise removed. Under default parameters,
the denoised matrix will have fewer rows than the input matrix and will have
no entries remaining below the noise threshold.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+remove_noise_from_bams">remove_noise_from_bams</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expression.matrix &lt;- matrix(1:100, ncol=5)
noise.thresholds &lt;- c(5,30,45,62,83)
remove_noise_from_matrix(
    expression.matrix = expression.matrix,
    noise.thresholds = noise.thresholds
)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
