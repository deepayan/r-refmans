<!DOCTYPE html><html><head><title>Help for package BCE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BCE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BCE-package'>
<p>The Bayesian Compositional Estimator Package</p></a></li>
<li><a href='#BCE'><p>Bayesian Composition Estimator</p></a></li>
<li><a href='#bce1'><p>Bayesian Composition Estimator</p></a></li>
<li><a href='#bceInput'>
<p>ratiomatrix and datamatrix for demonstration of BCE().</p></a></li>
<li><a href='#bceOutput'><p>bce output generated by running the bceInput example</p></a></li>
<li><a href='#export.bce'><p>export BCE</p></a></li>
<li><a href='#pairs.bce'><p>Pairs plot of a BCE</p></a></li>
<li><a href='#plot.bce'><p>plot BCE</p></a></li>
<li><a href='#rescaleRows'><p>rescale rows</p></a></li>
<li><a href='#summary.bce'><p>summary BCE</p></a></li>
<li><a href='#tlsce'><p>Total Least Squares Composition Estimator</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.2.0</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Composition Estimator: Estimating Sample (Taxonomic)
Composition from Biomarker Data</td>
</tr>
<tr>
<td>Author:</td>
<td>Karel Van den Meersche &lt;karel.van_den_meersche@cirad.fr&gt;, Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Karel Van den Meersche &lt;karel.van_den_meersche@cirad.fr&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.0.1), FME, limSolve, Matrix</td>
</tr>
<tr>
<td>Description:</td>
<td>Function to estimate taxonomic compositions from biomarker data, using a Bayesian approach.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-12 16:03:17 UTC; vandenmeersche</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-12 21:00:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='BCE-package'>
The Bayesian Compositional Estimator Package
</h2><span id='topic+BCE-package'></span>

<h3>Description</h3>

<p>Functions that estimate sample (taxonomic) composition from
biomarker data
</p>
<p><code>bce1</code> estimates probability distributions of a sample composition
based on an <b>input ratio matrix</b>, <code>A</code>, containing
biomarker ratios in (field) samples, and an <b>input data matrix</b>,
<code>B</code>, containing the biomarker ratios for several taxonomic groups
</p>
<p><code>tlsce</code> estimates the total least squares solution
</p>
<p>This version differs from the previous version &lt;2 in that a different
MCMC method is used that shows better convergence properties and
has a more sound underlying statistical model.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
    Package: </td><td style="text-align: left;"> BCE</td>
</tr>
<tr>
 <td style="text-align: left;">
    Type:    </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
    License: </td><td style="text-align: left;"> GNU Public License 2 or above</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Karel Van den Meersche (Maintainer)
</p>
<p>Karline Soetaert
</p>


<h3>References</h3>

<p>Van den Meersche, K., K. Soetaert and J.J. Middelburg (2008) <em>A
Bayesian compositional estimator for microbial taxonomy
based on biomarkers</em>, Limnology and Oceanography Methods 6, 190-199
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bce">bce</a></code> the new function, with better convergence properties
</p>
<p><code><a href="#topic+BCE">BCE</a></code> the original function (versions &lt; 2)
</p>
<p><code><a href="#topic+tlsce">tlsce</a></code> total least squares compositional estimator
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## show examples (see respective help pages for details)
example(bce)
example(tlsce)

## show package vignette
browseURL(paste(system.file(package = "BCE"), "/doc", sep = ""))

## End(Not run)
</code></pre>

<hr>
<h2 id='BCE'>Bayesian Composition Estimator</h2><span id='topic+BCE'></span>

<h3>Description</h3>

<p><b>this function is now superseded by the alternative
<code>link{bce1}</code>.</b>
</p>
<p>estimates probability distributions of a sample composition
based on an <b>input ratio matrix</b>, <code>Rat</code>, containing
biomarker ratios in (field) samples, and an <b>input data matrix</b>,
<code>Dat</code>, containing the biomarker ratios for several taxonomic groups</p>


<h3>Usage</h3>

<pre><code class='language-R'>BCE(Rat, Dat, relsdRat = 0, abssdRat = 0, minRat = 0, 
  maxRat = +Inf, relsdDat = 0, abssdDat = 0, tol = 1e-4, tolX = 1e-4,
  positive = 1:ncol(Rat), iter = 100, outputlength = 1000,
  burninlength = 0, jmpRat = 0.01, jmpX = 0.01, unif = FALSE,
  verbose = TRUE, initRat = Rat, initX = NULL, userProb = NULL,
  confInt = 2/3, export = FALSE, file = "BCE")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BCE_+3A_rat">Rat</code></td>
<td>
<p>initial ratio matrix. Each row of <code>Rat</code> contains the
biomarker composition of one taxon. As a result of the Bayesian
procedure, this initial ratio matrix will be altered.
</p>
</td></tr>
<tr><td><code id="BCE_+3A_dat">Dat</code></td>
<td>
<p>initial data matrix. Each row of <code>Dat</code> contains the
biomarker composition of one (field) sample.
</p>
</td></tr>
<tr><td><code id="BCE_+3A_relsdrat">relsdRat</code></td>
<td>
<p>relative standard deviation on ratio matrix. Either one
number or a matrix with the same dimensions as <code>Rat</code>.
</p>
</td></tr>
<tr><td><code id="BCE_+3A_abssdrat">abssdRat</code></td>
<td>
<p>absolute standard deviation on ratio matrix. Either one
number or a matrix with the same dimensions as <code>Rat</code>.
</p>
</td></tr>
<tr><td><code id="BCE_+3A_minrat">minRat</code></td>
<td>
<p>minimum values of ratio matrix. Either one number or a
matrix with the same dimensions as <code>Rat</code>.
</p>
</td></tr>
<tr><td><code id="BCE_+3A_maxrat">maxRat</code></td>
<td>
<p>maximum values of ratio matrix. Either one number or a
matrix with the same dimensions as <code>Rat</code>.
</p>
</td></tr>
<tr><td><code id="BCE_+3A_relsddat">relsdDat</code></td>
<td>
<p>relative standard deviation on data matrix. Either one
number or a matrix with the same dimensions as <code>Dat</code>.
</p>
</td></tr>
<tr><td><code id="BCE_+3A_abssddat">abssdDat</code></td>
<td>
<p>absolute standard deviation on data matrix. Either one
number or a matrix with the same dimensions as <code>Dat</code>.
</p>
</td></tr>
<tr><td><code id="BCE_+3A_tol">tol</code></td>
<td>
<p>minimum standard deviation for data matrix <code>Dat</code>. One
value.
</p>
</td></tr>
<tr><td><code id="BCE_+3A_tolx">tolX</code></td>
<td>
<p>minimum x values. Used for MCMC initiation. One value.
</p>
</td></tr>
<tr><td><code id="BCE_+3A_positive">positive</code></td>
<td>
<p>A vector containing numbers of columns that should
contain strictly positive data.  Only these columns are rescaled. The
other columns (not in <code>positive</code>) are not rescaled, and can become
negative.
</p>
</td></tr>
<tr><td><code id="BCE_+3A_iter">iter</code></td>
<td>
<p>number of iterations for MCMC.
</p>
</td></tr>
<tr><td><code id="BCE_+3A_outputlength">outputlength</code></td>
<td>
<p>number of iterations kept in the output.
</p>
</td></tr>
<tr><td><code id="BCE_+3A_burninlength">burninlength</code></td>
<td>
<p>number of initial iterations to be removed from
output.
</p>
</td></tr>
<tr><td><code id="BCE_+3A_jmprat">jmpRat</code></td>
<td>
<p>jump length of the ratio matrix <code>Rat</code> (in normal
space).  Either a number, a vector with length equal to the number of
biomarkers (number of columns in <code>Rat</code>), or a or matrix with the
same dimensions as the ratio matrix <code>rat</code>.
</p>
</td></tr>
<tr><td><code id="BCE_+3A_jmpx">jmpX</code></td>
<td>
<p>jump length of the composition matrix (in a
simplex). Either one number, a vector of length equal to the number of
taxa (number of rows in <code>Rat</code>)
or a matrix with the same dimensions = c(number of taxa, number of
field samples).
</p>
</td></tr>
<tr><td><code id="BCE_+3A_unif">unif</code></td>
<td>
<p>logical; if TRUE a uniform distribution for ratio matrix
is used. This is similar as in chemtax.
</p>
</td></tr>
<tr><td><code id="BCE_+3A_verbose">verbose</code></td>
<td>
<p>logical; if TRUE, extra information is provided during
the run of the function, such as extra warnings, elapsed time and
expected time until the end of the MCMC.
</p>
</td></tr>
<tr><td><code id="BCE_+3A_initrat">initRat</code></td>
<td>
<p>ratio matrix used to start the markov chain: defaults
to the initial ratio matrix.
</p>
</td></tr>
<tr><td><code id="BCE_+3A_initx">initX</code></td>
<td>
<p>composition matrix used to start the markov chain:
default the LSEI solution of Ax=B.
</p>
</td></tr>
<tr><td><code id="BCE_+3A_userprob">userProb</code></td>
<td>
<p>function taking two arguments: ratio matrix RAT and
composition matrix X, and returning the posterior probability.
Dependence of the probability on the data should be incorporated in
the function. If not specified, the default probability distribution
is the product of a non-informative distribution on the composition
matrix, and gamma distributions for the ratio matrix and the data
given the model output.
</p>
</td></tr>
<tr><td><code id="BCE_+3A_confint">confInt</code></td>
<td>
<p>confidence interval in output; because the
distributions may not be symmetrical, standard deviations are not
always a useful measure; instead, upper and lower boundaries of the
given confidence interval are given.  Default is 2/3, i.e there is a
probability of 0.66 for a value to be contained within the interval.
</p>
</td></tr>
<tr><td><code id="BCE_+3A_export">export</code></td>
<td>
<p>logical; if <code>TRUE</code>, the function
<code><a href="#topic+export.bce">export.bce</a></code> is called and a list of variables and plots
are exported to the specified <code>file</code>.
</p>
</td></tr>
<tr><td><code id="BCE_+3A_file">file</code></td>
<td>
<p>Only if <code>export</code> is TRUE. If not NULL, a
character string specifying the file to which objects are saved.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>BCE</code> searches probability distributions for all
elements of a taxonomical composition matrix <code>X</code> and a ratio
matrix <code>Rat</code> for which:
</p>
<p style="text-align: center;"><code class="reqn">X\%*\%Rat \simeq Dat</code>
</p>

<p>It does this by returning <code>iter</code> samples for X and Rat, organized
in three-dimensional arrays. The input
data matrix <code>Dat</code> and ratio matrix <code>Rat</code> should be
in the following formats, with the relative concentrations per
biomarker organized in columns:
</p>
<p>data matrix:
</p>

<table>
<tr>
 <td style="text-align: center;">
    </td><td style="text-align: center;">  marker1 </td><td style="text-align: center;">  marker2 </td><td style="text-align: center;">  marker3 </td><td style="text-align: center;">  marker4  </td>
</tr>
<tr>
 <td style="text-align: center;">
    sample1  </td><td style="text-align: center;">  0.14 </td><td style="text-align: center;">  0.005  </td><td style="text-align: center;">  0.35	 </td><td style="text-align: center;">	0.033  </td>
</tr>
<tr>
 <td style="text-align: center;">
    sample2  </td><td style="text-align: center;">  0.15	</td><td style="text-align: center;">  0.004  </td><td style="text-align: center;">  0.36	 </td><td style="text-align: center;">	0.034  </td>
</tr>
<tr>
 <td style="text-align: center;">
    sample3  </td><td style="text-align: center;">  0.13	</td><td style="text-align: center;">  0.004  </td><td style="text-align: center;">  0.31  </td><td style="text-align: center;">	0.030  </td>
</tr>
<tr>
 <td style="text-align: center;">
    sample4  </td><td style="text-align: center;">  0.13	</td><td style="text-align: center;">  0.005  </td><td style="text-align: center;">  0.33	 </td><td style="text-align: center;">	0.031  </td>
</tr>
<tr>
 <td style="text-align: center;">
    sample5  </td><td style="text-align: center;">  0.14	</td><td style="text-align: center;">  0.008  </td><td style="text-align: center;">  0.33  </td><td style="text-align: center;">	0.036  </td>
</tr>
<tr>
 <td style="text-align: center;">
    sample6  </td><td style="text-align: center;">  0.11	</td><td style="text-align: center;">  0.082  </td><td style="text-align: center;">  0.34  </td><td style="text-align: center;">	0.044
  </td>
</tr>

</table>

<p>and ratio matrix:
</p>

<table>
<tr>
 <td style="text-align: center;">
    </td><td style="text-align: center;">  marker1  </td><td style="text-align: center;">  marker2 </td><td style="text-align: center;">	marker3	</td><td style="text-align: center;">	marker4	</td>
</tr>
<tr>
 <td style="text-align: center;">
    species1  </td><td style="text-align: center;">  0.27     </td><td style="text-align: center;">  0.13	   </td><td style="text-align: center;">	0.35	</td><td style="text-align: center;">	0.076	</td>
</tr>
<tr>
 <td style="text-align: center;">
    species2  </td><td style="text-align: center;">  0.084    </td><td style="text-align: center;">  0	   </td><td style="text-align: center;">	0.5	</td><td style="text-align: center;">	0.24	</td>
</tr>
<tr>
 <td style="text-align: center;">
    species3  </td><td style="text-align: center;">  0.195    </td><td style="text-align: center;">  0.3	   </td><td style="text-align: center;">	0	</td><td style="text-align: center;">	0.1	</td>
</tr>
<tr>
 <td style="text-align: center;">
    species4  </td><td style="text-align: center;">  0.06     </td><td style="text-align: center;">  0	   </td><td style="text-align: center;">	0	</td><td style="text-align: center;">	0	</td>
</tr>
<tr>
 <td style="text-align: center;">
    species5  </td><td style="text-align: center;">  0	     </td><td style="text-align: center;">  0	   </td><td style="text-align: center;">	0	</td><td style="text-align: center;">	0	</td>
</tr>
<tr>
 <td style="text-align: center;">
    species6  </td><td style="text-align: center;">  0	     </td><td style="text-align: center;">  0	   </td><td style="text-align: center;">	0	</td><td style="text-align: center;">	0
  </td>
</tr>

</table>



<h3>Value</h3>

<p>A bce (bayesian compositional estimator) object; a list containing 4 elements
</p>
<table>
<tr><td><code>Rat</code></td>
<td>
<p> Array with dimension c(nrow(<code>Rat</code>),ncol(<code>Rat</code>),
<code>iter</code>) containing the random walk values of the ratio
matrix <code>Rat</code>.
</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p> Array with dimension c(nrow(<code>X</code>),ncol(<code>X</code>),<code>iter</code>)
containing the random walk values of the composition matrix <code>X</code>.
</p>
</td></tr>
<tr><td><code>logp</code></td>
<td>
<p> vector with length <code>iter</code> containing the random
walk values of the (log) posterior probability.
</p>
</td></tr>
<tr><td><code>naccepted</code></td>
<td>
<p> integer indicating the number of runs that were accepted.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Producing sensible output:
</p>
<p>Markov Chain Monte Carlo simulations are not as straightforward as one
might wish; several preliminary runs might be necessary to determine
the desired number of iterations, burn-in length and jump
length. For all estimated values of Rat and X, their trace
(evolution of the values over all iterations) has to display random
behaviour; no obvious trends should appear. A few parameters can be
tuned to obtain such behaviour:
</p>

<ul>
<li><p><b>jump length</b> The jump length determines how big the jumps are
for each step in the random walk. A longer jump length will make you
jump around faster in the parameter space, but acceptance of new
points can get very low. Smaller jump lengths increase the
acceptance rate, but the algorithm will move too slowly, and a lot
more runs will be needed to scan the whole parameter space. A good
way to find a good jump length, is look at the number of points
accepted. If the output is saved under the name <code>MCMC</code>, you
can find the number of accepted points under
<code>MCMC$naccepted</code>. It is also given if you run the model with
<code>verbose=TRUE</code> (default). This value should be somewhere
between 5% and 40%. For long runs, 5 % can be acceptable, for
short runs, you will prefer a higher acceptance in order to have
enough different points. 20% accepted is usually a good number. Do
some preliminary runs with <code>iter=1000-10000</code> and tune the
jump length parameters <code>jmpRat</code> and <code>jmpX</code>. You can set
different jump lengths for each column of
the ratio matrix, or 1 jump length for the whole ratio matrix, and 1
jump length for the composition matrix. Decreasing the jump lengths
will generally increase the acceptance rate and vice versa. Also the
mixing rate (the speed with which accepted points change their
values) will be influenced. You want this mixing rate to be as high
as possible, whilst maintaining enough accepted points. 
</p>
</li>
<li><p><b>burninlength</b> The program uses the solution of lsei using the
original ratio matrix as starting values for the MCMC. This might in
some cases be far from the optimal solution, and the MCMC algorithm
will start with moving towards this optimal solution. This is called
a burn-in. When there is a slow mixing rate, this can take a
considerable number of cycles. As it can influence the averages and
standard deviations, you might want to remove it from the mcmc
objects. By defining a burnin length, the first
'<code>burninlength</code>' cycles will not be written to the output. Look
at some plots to determine if you need to specify a burnin length.
</p>
</li>
<li><p><b>iter</b> the number of iterations: start with 10000 runs
or less; check the output and estimate how many runs you will need
to get a random pattern in the output.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Karel Van den Meersche &lt;karel.van_den_meersche@cirad.fr&gt;,
Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;.
</p>


<h3>References</h3>

<p>Van den Meersche, K., K. Soetaert and J.J. Middelburg (2008) <em>A
Bayesian compositional estimator for microbial taxonomy
based on biomarkers</em>, Limnology and Oceanography Methods 6, 190-199
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.bce">summary.bce</a></code>, <code><a href="#topic+plot.bce">plot.bce</a></code>,
<code><a href="#topic+export.bce">export.bce</a></code>, <code><a href="#topic+pairs.bce">pairs.bce</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##====================================

# example using bceInput data
# first try

X &lt;- BCE(bceInput$Rat,bceInput$Dat,relsdRat=.2,relsdDat=.2,
         iter=1000,outputlength=5000,jmpX=.01,jmpRat=.01)

## the number of accepted runs is too low;
## we play around with the jump lengths jmpX and jmpRat

X &lt;- BCE(bceInput$Rat,bceInput$Dat,relsdRat=.2,relsdDat=.2,
         iter=1000,outputlength=5000,jmpX=.02,jmpRat=.002)

## we inspect the output:
plot(X)

## For every element of X and Rat, we want to obtain a well-mixed,
## random trace. In this case, mixing is still a little poor.
## to optimize mixing in the ratio matrix, it is a good idea
## to make the jump length linear to the ratio matrix
## standard deviation (sdrat=.2*rat) :
X &lt;- BCE(bceInput$Rat,bceInput$Dat,relsdRat=.2,relsdDat=.2,
         iter=1000,outputlength=5000,jmpX=.02,
         jmpRat=.2*(.2*bceInput$Rat))
plot(X)

## mixing improved a lot; we repeat the run with more iterations
## to improve the reliability of the results.
## the following run can take a few minutes - so it is toggled off
#X &lt;- BCE(bceInput$Rat,bceInput$Dat,relsdRat=.2,relsdDat=.2,
#         iter=100000,outputlength=5000,jmpX=.02,
#         jmpRat=.2*(.2*bceInput$Rat))
#plot(X)
## you can see in the plots that traces for all elements of Rat and X
## are well-mixed. This run was saved in "bceOutput"

Sum &lt;-summary(bceOutput)

# show results as mean with ranges
print(Sum$meanX)

# plot estimated means and ranges (lbX=lower, ubX=upper bound)
xlim &lt;- range(c(Sum$lbX,Sum$ubX))

# first the mean
dotchart(x=t(Sum$meanX),xlim=xlim,                                                          
         main="Taxonomic composition",
         sub="using bce",pch=16)

# then ranges
nr &lt;- nrow(Sum$meanX)
nc &lt;- ncol(Sum$meanX)

for (i in 1:nr) 
{ip &lt;-(nr-i)*(nc+2)+1
 cc &lt;- ip : (ip+nc-1)
 segments(t(Sum$lbX[i,]),cc,t(Sum$ubX[i,]),cc)
 }

# show results as pairs plot
pairs(bceOutput,sample=3,main="Station 3")

</code></pre>

<hr>
<h2 id='bce1'>Bayesian Composition Estimator</h2><span id='topic+bce1'></span><span id='topic+bce'></span>

<h3>Description</h3>

<p>This function estimates taxonomic compositions of algal communities
based on biomarker field data. More precisely, it estimates the probability distributions of a sample composition
based on an <b>input ratio matrix</b>, <code>A</code> that contains
prior estimates of biomarker ratios in different taxa, and an <b>input data matrix</b>,
<code>B</code>, containing biomarker ratios measured in field samples.
</p>
<p>Probability distributions are estimated based on an adaptive metropolis
MCMC method, function <code>modMCMC</code> from package <code>FME</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bce1(A, B, Wa=NULL, Wb=NULL,
       jmpType="default", jmpA=.1,jmpX=.1, jmpCovar=NULL,
       initX=NULL, initA=NULL, priorA="normal", minA=NULL, maxA=NULL, 
       var0=NULL, wvar0=1e-6, Xratios=TRUE, verbose=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bce1_+3A_a">A</code></td>
<td>
<p>input (group) ratio matrix; can be a matrix or a dataframe
</p>
</td></tr>
<tr><td><code id="bce1_+3A_b">B</code></td>
<td>
<p>input (field) data matrix; can be a matrix or a  dataframe
</p>
</td></tr>
<tr><td><code id="bce1_+3A_wa">Wa</code></td>
<td>
<p>elementwise weight matrix for A, with the
same dimensions as A. </p>
<p style="text-align: center;"><code class="reqn">[Wa*(A-A_0)]^2</code>
</p>
<p> is minimized
</p>
</td></tr>
<tr><td><code id="bce1_+3A_wb">Wb</code></td>
<td>
<p>elementwise weight matrix for B, with the same dimensions
as B. </p>
<p style="text-align: center;"><code class="reqn">[Wb*(A\%*\%X-B)]^2</code>
</p>
<p> is minimized
</p>
</td></tr>
<tr><td><code id="bce1_+3A_jmptype">jmpType</code></td>
<td>
<p>one of &quot;default&quot;, &quot;estimate&quot; or &quot;covar&quot;; if default, jmpA and jmpX
are the jump lengths. if jmpA or jmpX is a number,
then this is the jump length for all elements of A
resp. X. If &quot;estimate&quot;, the initial jump length is
proportional to an estimated covariance matrix for the
tlsce fit for A and the lsei fit of X (or Q if
Xratios). jmpA and jmpX are then used as rescaling
factors for the jump covariance matrix. If &quot;covar&quot;, a jump
covariance matrix with the correct dimensions, obtained
from a previous run, is given as parameter jmpCovar.
Covariances can be calculated from the result. 
</p>
</td></tr>
<tr><td><code id="bce1_+3A_jmpa">jmpA</code></td>
<td>
<p>jump length of A: a number or a matrix with dim(A); see
details jmpType
</p>
</td></tr>
<tr><td><code id="bce1_+3A_jmpx">jmpX</code></td>
<td>
<p>jump lenth of X: a number or a matrix with dim(X); see
details jmpType
</p>
</td></tr>
<tr><td><code id="bce1_+3A_jmpcovar">jmpCovar</code></td>
<td>
<p>only if jmpType=&quot;covar&quot;, the covariance matrix to
initiate the jumps - see details jmpType
</p>
</td></tr>
<tr><td><code id="bce1_+3A_initx">initX</code></td>
<td>
<p>composition matrix used to start the markov chain:
default the tlsce solution of Ax=B
</p>
</td></tr>
<tr><td><code id="bce1_+3A_inita">initA</code></td>
<td>
<p>ratio matrix used to start the markov chain:
default the input ratio matrix A
</p>
</td></tr>
<tr><td><code id="bce1_+3A_priora">priorA</code></td>
<td>
<p>&quot;normal&quot; (gaussian - default) or &quot;uniform&quot;.
</p>
</td></tr>
<tr><td><code id="bce1_+3A_mina">minA</code></td>
<td>
<p>minimum values for A
</p>
</td></tr>
<tr><td><code id="bce1_+3A_maxa">maxA</code></td>
<td>
<p>maximum values for A
</p>
</td></tr>
<tr><td><code id="bce1_+3A_var0">var0</code></td>
<td>
<p>initial model variance; if 'NULL', then the model
variance of tlsce(A,B,...) is used
</p>
</td></tr>
<tr><td><code id="bce1_+3A_wvar0">wvar0</code></td>
<td>
<p>relative weight of the initial model variance
(see modMCMC). Ideally this would be 0 (initial model variance is
not taken into account); because wvar0=0 is a special case in
modMCMC() (fixed model variance), the default value is set to a small
number (wvar0=1e-6)
</p>
</td></tr>
<tr><td><code id="bce1_+3A_xratios">Xratios</code></td>
<td>
<p>does the composition matrix contain ratios (TRUE) or
estimated biomass concentrations (TRUE) per sample? In the
latter case, B must contain the pigment concentrations as
measured in the samples (not rescaled)
</p>
</td></tr>
<tr><td><code id="bce1_+3A_verbose">verbose</code></td>
<td>
<p>when <code>TRUE</code> will give more verbose output
</p>
</td></tr>
<tr><td><code id="bce1_+3A_...">...</code></td>
<td>
<p>arguments to pass on to modMCMC()
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>bce1</code> searches probability distributions for all
elements of a taxonomical composition matrix <code>X</code> and a ratio
matrix <code>A</code> for which:
</p>
<p style="text-align: center;"><code class="reqn">A\%*\%X \simeq B</code>
</p>

<p>It does this by returning <code>niter</code> samples for A and X, organized
in three-dimensional arrays. The input
data matrix <code>B</code> and ratio matrix <code>A</code> should be
in the following formats, with the relative concentrations per
biomarker organized in columns:
</p>
<p>data matrix B:
</p>

<table>
<tr>
 <td style="text-align: center;">
    </td><td style="text-align: center;">  sample1 </td><td style="text-align: center;">  sample2 </td><td style="text-align: center;">  sample3 </td><td style="text-align: center;">  sample4  </td>
</tr>
<tr>
 <td style="text-align: center;">
    marker1  </td><td style="text-align: center;">  0.14 </td><td style="text-align: center;">  0.005  </td><td style="text-align: center;">  0.35	 </td><td style="text-align: center;">	0.033  </td>
</tr>
<tr>
 <td style="text-align: center;">
    marker2  </td><td style="text-align: center;">  0.15	</td><td style="text-align: center;">  0.004  </td><td style="text-align: center;">  0.36	 </td><td style="text-align: center;">	0.034  </td>
</tr>
<tr>
 <td style="text-align: center;">
    marker3  </td><td style="text-align: center;">  0.13	</td><td style="text-align: center;">  0.004  </td><td style="text-align: center;">  0.31  </td><td style="text-align: center;">	0.030  </td>
</tr>
<tr>
 <td style="text-align: center;">
    marker4  </td><td style="text-align: center;">  0.13	</td><td style="text-align: center;">  0.005  </td><td style="text-align: center;">  0.33	 </td><td style="text-align: center;">	0.031  </td>
</tr>
<tr>
 <td style="text-align: center;">
    marker5  </td><td style="text-align: center;">  0.14	</td><td style="text-align: center;">  0.008  </td><td style="text-align: center;">  0.33  </td><td style="text-align: center;">	0.036  </td>
</tr>
<tr>
 <td style="text-align: center;">
    marker6  </td><td style="text-align: center;">  0.11	</td><td style="text-align: center;">  0.082  </td><td style="text-align: center;">  0.34  </td><td style="text-align: center;">	0.044
  </td>
</tr>

</table>

<p>and ratio matrix A:
</p>

<table>
<tr>
 <td style="text-align: center;">
    </td><td style="text-align: center;">  species1  </td><td style="text-align: center;">  species2 </td><td style="text-align: center;">	species3	</td><td style="text-align: center;">	species4	</td>
</tr>
<tr>
 <td style="text-align: center;">
    marker1  </td><td style="text-align: center;">  0.27     </td><td style="text-align: center;">  0.13	   </td><td style="text-align: center;">	0.35	</td><td style="text-align: center;">	0.076	</td>
</tr>
<tr>
 <td style="text-align: center;">
    marker2  </td><td style="text-align: center;">  0.084    </td><td style="text-align: center;">  0	   </td><td style="text-align: center;">	0.5	</td><td style="text-align: center;">	0.24	</td>
</tr>
<tr>
 <td style="text-align: center;">
    marker3  </td><td style="text-align: center;">  0.195    </td><td style="text-align: center;">  0.3	   </td><td style="text-align: center;">	0	</td><td style="text-align: center;">	0.1	</td>
</tr>
<tr>
 <td style="text-align: center;">
    marker4  </td><td style="text-align: center;">  0.06     </td><td style="text-align: center;">  0	   </td><td style="text-align: center;">	0	</td><td style="text-align: center;">	0	</td>
</tr>
<tr>
 <td style="text-align: center;">
    marker5  </td><td style="text-align: center;">  0	     </td><td style="text-align: center;">  0	   </td><td style="text-align: center;">	0	</td><td style="text-align: center;">	0	</td>
</tr>
<tr>
 <td style="text-align: center;">
    marker6  </td><td style="text-align: center;">  0	     </td><td style="text-align: center;">  0	   </td><td style="text-align: center;">	0	</td><td style="text-align: center;">	0
  </td>
</tr>

</table>



<h3>Value</h3>

<p>An object of class bce and _modMCMC_ (returned by the function
modMCMC). This object has methods for the generic
functions 'summary', 'plot', 'pairs'- see ?modMCMC.
It is distinguished from other modMCMC objects by 3 extra attributes
that allow to extract matrices A and X from the mcmc result: &quot;dim_A&quot;
(dimensions of A), &quot;A_not_null&quot; (which elements of A are not zero and
thus included in the mcmc) and Xratios (whether X was rescaled, yes or
no). 
</p>


<h3>Note</h3>

<p>Producing sensible output:
</p>
<p>Markov Chain Monte Carlo simulations are not as straightforward as one
might wish; several preliminary runs might be necessary to determine
the desired number of iterations, burn-in length and jump
length. For all estimated values of Rat and X, their trace
(evolution of the values over all iterations) has to display random
behaviour; no obvious trends should appear. A few parameters can be
tuned to obtain such behaviour:
</p>

<ul>
<li><p><b>jump length</b> The jump length determines how big the jumps are
for each step in the random walk. A longer jump length will make you
jump around faster in the parameter space, but acceptance of new
points can get very low. Smaller jump lengths increase the
acceptance rate, but the algorithm will move too slowly, and a lot
more runs will be needed to scan the whole parameter space. A good
way to find a good jump length, is look at the number of points
accepted. If the output is saved under the name <code>MCMC</code>, you
can find the number of accepted points under
<code>MCMC$naccepted</code>. It is also given if you run the model with
<code>verbose=TRUE</code> (default). This value should be somewhere
between 5% and 40%. For long runs, 5 % can be acceptable, for
short runs, you will prefer a higher acceptance in order to have
enough different points. 20% accepted is usually a good number. Do
some preliminary runs with <code>niter=1000-10000</code> and tune the
jump length parameters <code>jmpRat</code> and <code>jmpX</code>. You can set
different jump lengths for each column of
the ratio matrix, or 1 jump length for the whole ratio matrix, and 1
jump length for the composition matrix. Decreasing the jump lengths
will generally increase the acceptance rate and vice versa. Also the
mixing rate (the speed with which accepted points change their
values) will be influenced. You want this mixing rate to be as high
as possible, whilst maintaining enough accepted points. 
</p>
</li>
<li><p><b>burninlength</b> The program uses the solution of lsei using the
original ratio matrix as starting values for the MCMC. This might in
some cases be far from the optimal solution, and the MCMC algorithm
will start with moving towards this optimal solution. This is called
a burn-in. When there is a slow mixing rate, this can take a
considerable number of cycles. As it can influence the averages and
standard deviations, you might want to remove it from the mcmc
objects. By defining a burnin length, the first
'<code>burninlength</code>' cycles will not be written to the output. Look
at some plots to determine if you need to specify a burnin length.
</p>
</li>
<li><p><b>niter</b> the number of iterations: start with 10000 runs
or less; check the output and estimate how many runs you will need
to get a random pattern in the output.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Karel Van den Meersche &lt;karel.van_den_meersche@cirad.fr&gt;,
Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;.
</p>


<h3>References</h3>

<p>Van den Meersche, K., K. Soetaert and J.J. Middelburg (2008) <em>A
Bayesian compositional estimator for microbial taxonomy
based on biomarkers</em>, Limnology and Oceanography Methods 6, 190-199
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.bce">summary.bce</a></code>, <code><a href="#topic+plot.bce">plot.bce</a></code>,
<code><a href="#topic+export.bce">export.bce</a></code>, <code><a href="#topic+pairs.bce">pairs.bce</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##====================================

# example using bceInput data
# !!! should be weighted to correspond better to example of BCE!!!
A &lt;- t(bceInput$Rat)
B &lt;- t(bceInput$Dat)


result &lt;- bce1(A,B,niter=1000)

## the number of accepted runs is zero;
## try different starting values

result &lt;- bce1(A,B,niter=1000,initX=matrix(1/ncol(A),ncol(A),ncol(B)))

## number of accepted runs is still low;
## smaller jumps

result &lt;- bce1(A,B,niter=1000,initX=matrix(1/ncol(A),ncol(A),ncol(B)),jmpA=.01,jmpX=.01)
Sum &lt;-summary(result)

## did the algorithm converge?
plot(result$SS,type="l")
## no


## more runs, using the output of previous run as input.
result &lt;- bce1(A,B,niter=1e4,jmpA=.01,jmpX=.01,updatecov=1e3,
               initX=Sum$lastX,initA=Sum$lastA,
               jmpCovar=Sum$covar*2.4^2/ncol(result$pars),
               )
Sum &lt;-summary(result)

## we inspect the output:
plot(result$SS,type="l")
plot(result,ask=TRUE)
## looks already pretty good; to get a better result, repeat one more
## time with a  longer run. Uncomment the following paragraph and run.
## go get some coffee, this might take a while (~30s).

## result &lt;- bce1(A,B,niter=1e5,jmpA=.01,jmpX=.01,updatecov=1e3,
##                outputlength=1e3,burninlength=.35e5,
##                initX=Sum$lastX,initA=Sum$lastA,
##                jmpCovar=Sum$covar*2.4^2/ncol(result$pars),
##                )
## Sum &lt;-summary(result)
## plot(result$SS,type="l")
## plot(result,ask=TRUE)

# show results as mean with ranges
print(Sum$meanX)

# plot estimated means and ranges (lbX=lower, ubX=upper bound)
xlim &lt;- range(c(Sum$lbX,Sum$ubX))

# first the mean
dotchart(x=t(Sum$meanX),xlim=xlim,                                                          
         main="Taxonomic composition",
         sub="using bce",pch=16)

# then ranges
nr &lt;- nrow(Sum$meanX)
nc &lt;- ncol(Sum$meanX)

for (i in 1:nr) 
  {ip &lt;-(nr-i)*(nc+2)+1
   cc &lt;- ip : (ip+nc-1)
   segments(t(Sum$lbX[i,]),cc,t(Sum$ubX[i,]),cc)
  }

</code></pre>

<hr>
<h2 id='bceInput'>
ratiomatrix and datamatrix for demonstration of BCE().
</h2><span id='topic+bceInput'></span>

<h3>Description</h3>

<p>The datamatrix contains a set of biomarker measurements for a number
of field samples.
</p>
<p>The ratiomatrix contains biomarker data of a number of biological taxa.
<code>BCE()</code> uses these matrices to estimate the taxonomical composition
of the samples based on the provided taxa.
For use with the function <code>bce1()</code>, they have to be transposed. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bceInput</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>##====================================
## Graphical representation of the example input data
palette(rainbow(12, s = 0.6, v = 0.75))

mp     &lt;- apply(bceInput$Rat,MARGIN=2,max)
mp2    &lt;- apply(bceInput$Dat,MARGIN=2,max)
pstars &lt;- rbind(t(t(bceInput$Rat)/mp),t(t(bceInput$Dat)/mp2))

stars(pstars, len = 0.9, key.loc = c(7.2, -2),scale=FALSE,
      ncol=5,ylim=c(0,3),main = "bce Input: species + field samples", 
      draw.segments = TRUE, flip.labels=FALSE)
</code></pre>

<hr>
<h2 id='bceOutput'>bce output generated by running the bceInput example</h2><span id='topic+bceOutput'></span>

<h3>Description</h3>

<p>Result generated by running BCE using data <code>bceInput</code> as input.
</p>
<p>the run was initiated with the following command:
</p>
<p><code>bceOutput &lt;- BCE(bceInput$Rat,bceInput$Dat,relsdRat=.2,relsdDat=.2,</code>
</p>
<p><code>iter=100000,outputlength=5000,jmpX=.02,jmpRat=.2*(.2*bceInput$Rat))</code>
</p>
<p>this run took several minutes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bceOutput</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>
summary(bceOutput)$meanX

</code></pre>

<hr>
<h2 id='export.bce'>export BCE</h2><span id='topic+export.bce'></span>

<h3>Description</h3>

<p>export function: writes a BCE-object and its summary
statistics to a series of files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export.bce(x, file="BCE", input.list=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export.bce_+3A_x">x</code></td>
<td>
<p>a bce object, output of the function BCE().
</p>
</td></tr>
<tr><td><code id="export.bce_+3A_file">file</code></td>
<td>
<p>file to which the bce object is written.
</p>
</td></tr>
<tr><td><code id="export.bce_+3A_input.list">input.list</code></td>
<td>
<p>a list of the arguments in bce() can be provided
and saved as well.
</p>
</td></tr>
<tr><td><code id="export.bce_+3A_...">...</code></td>
<td>
<p>additional arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bce object is saved (<code><a href="base.html#topic+save">save</a></code>) to the specified file.
For people not familiar to R, it can be more 'user-friendly' to export
summary results to comma delimited textfiles, that can be
easily imported into a spreadsheet program. The function
<code><a href="#topic+summary.bce">summary.bce</a></code> is called to
calculate summary statistics of a BCE object; These are then written
to a series of .csv files with a name that combines the specified
filename and a string indicating the content of the .csv files. 
Traces and marginal probabilities of all estimated values are plotted
and saved in .png files. These traces should be inspected carefully
before accepting any results (see also <code><a href="#topic+plot.bce">plot.bce</a></code>).
</p>


<h3>Author(s)</h3>

<p>Karel Van den Meersche</p>


<h3>See Also</h3>

<p><code><a href="#topic+BCE">BCE</a></code>, <code><a href="#topic+summary.bce">summary.bce</a></code>,
<code><a href="#topic+plot.bce">plot.bce</a></code>, <code><a href="#topic+pairs.bce">pairs.bce</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: export.bce(bceOutput, file="bceOutput")

</code></pre>

<hr>
<h2 id='pairs.bce'>Pairs plot of a BCE</h2><span id='topic+pairs.bce'></span>

<h3>Description</h3>

<p>produces pairs plots of the random walks of the BCE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bce'
 pairs(x, sample = 1, gap = 0,upper.panel = NA,
  diag.panel = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairs.bce_+3A_x">x</code></td>
<td>
<p>either a bce object or the random walk values (<code>X</code>)
of the composition matrix.
</p>
</td></tr>
<tr><td><code id="pairs.bce_+3A_sample">sample</code></td>
<td>
<p>the sample number for which the pairs plot is to be drawn.
</p>
</td></tr>
<tr><td><code id="pairs.bce_+3A_gap">gap</code></td>
<td>
<p>Distance between subplots, in margin lines - a <code>pairs</code>
parameter.
</p>
</td></tr>
<tr><td><code id="pairs.bce_+3A_upper.panel">upper.panel</code></td>
<td>
<p>panel function to be used above the diagonal - the
default writes the correlations.
</p>
</td></tr>
<tr><td><code id="pairs.bce_+3A_diag.panel">diag.panel</code></td>
<td>
<p>panel function to be used on the diagonal - the default
plots a histogram.
</p>
</td></tr>
<tr><td><code id="pairs.bce_+3A_...">...</code></td>
<td>
<p>any other parameters passed to function <code>pairs</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Karline Soetaert</p>


<h3>See Also</h3>

<p><code><a href="#topic+BCE">BCE</a></code>, <code><a href="#topic+summary.bce">summary.bce</a></code>,
<code><a href="#topic+plot.bce">plot.bce</a></code>, <code><a href="#topic+export.bce">export.bce</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># bceOutput is an example output based on bceInput

pairs(bceOutput,sample=2,main="Station 2")
</code></pre>

<hr>
<h2 id='plot.bce'>plot BCE</h2><span id='topic+plot.bce'></span>

<h3>Description</h3>

<p>produces summary plots of the random walks of the BCE; these are
intended for inspection only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bce'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bce_+3A_x">x</code></td>
<td>
<p>an object of class bce and/or _modMCMC_. Output of one of
the functions <code><a href="#topic+BCE">BCE</a></code> or <code><a href="#topic+bce1">bce1</a></code>. 
</p>
</td></tr>
<tr><td><code id="plot.bce_+3A_...">...</code></td>
<td>
<p>additional arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the argument an object is of class _modMCMC_, which is the case
if it is the output of <code>bce1()</code>, it is treated as such (see
<code><a href="FME.html#topic+modMCMC">modMCMC</a></code>). 
</p>
<p>Calling the plot-function with the output of <code><a href="#topic+BCE">BCE</a></code> as argument, will produce
a series of plots with the random walks of each variable. The layout
of these plots is kept very sober, as they are primarily intended for
inspection of the random walk (see <code><a href="#topic+BCE">BCE</a></code>). Users
are free to write their own publication quality plots. Click or hit
Enter to see the next plot, hit Esc to stop seeing new plots. 
</p>


<h3>Author(s)</h3>

<p>Karel Van den Meersche</p>


<h3>See Also</h3>

<p><code><a href="#topic+BCE">BCE</a></code>, <code><a href="#topic+summary.bce">summary.bce</a></code>,
<code><a href="#topic+export.bce">export.bce</a></code>, <code><a href="#topic+pairs.bce">pairs.bce</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># bceOutput is an example output based on bceInput

plot(bceOutput)
</code></pre>

<hr>
<h2 id='rescaleRows'>rescale rows</h2><span id='topic+rescaleRows'></span>

<h3>Description</h3>

<p>returns a row-rescaled matrix (<code>rowSums(.)==1</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescaleRows(A, columns=1:ncol(A))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescaleRows_+3A_a">A</code></td>
<td>
<p>matrix or dataframe to be row-rescaled:
<code>rowSums(rescaleRows(A))==1</code>.
</p>
</td></tr>
<tr><td><code id="rescaleRows_+3A_columns">columns</code></td>
<td>
<p>vector containing indices of the columns that should
be included in the normalisation.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>A</code></td>
<td>
<p>row-rescaled matrix or partially row-rescaled matrix.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Karel Van den Meersche</p>

<hr>
<h2 id='summary.bce'>summary BCE</h2><span id='topic+summary.bce'></span>

<h3>Description</h3>

<p>basic statistics of a bce object</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bce'
summary(object, confInt = 2/3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bce_+3A_object">object</code></td>
<td>
<p>a bce-object, output of the function bce1() or BCE().
</p>
</td></tr>
<tr><td><code id="summary.bce_+3A_confint">confInt</code></td>
<td>
<p>confidence interval of values of composion matrix and
ratio matrix.
</p>
</td></tr>
<tr><td><code id="summary.bce_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if object is output of the function bce1():
</p>
<p>a list containing:
</p>
<table>
<tr><td><code>meanA</code></td>
<td>
<p>Average solution of the ratio matrix,found through MCMC.
</p>
</td></tr>
<tr><td><code>meanX</code></td>
<td>
<p>Average solution of the composition matrix, found
through MCMC.
</p>
</td></tr>
<tr><td><code>bestA</code></td>
<td>
<p>Ratio matrix for which the posterior probability is
maximal.
</p>
</td></tr>
<tr><td><code>bestX</code></td>
<td>
<p>Composition matrix for which the posterior probability is
maximal.
</p>
</td></tr>
<tr><td><code>sdA</code></td>
<td>
<p>standard deviation of the ratio matrix.
</p>
</td></tr>
<tr><td><code>sdX</code></td>
<td>
<p>standard deviation of the composition matrix.
</p>
</td></tr>
<tr><td><code>lastA</code></td>
<td>
<p>Last value for the ratio matrix in the MCMC run. 
</p>
</td></tr>
<tr><td><code>lastX</code></td>
<td>
<p>Last value for the composition matrix in the MCMC run. 
</p>
</td></tr>
<tr><td><code>medianA</code></td>
<td>
<p>Median of the ratio matrix.
</p>
</td></tr>
<tr><td><code>medianX</code></td>
<td>
<p>Median of the composition matrix.
</p>
</td></tr>
<tr><td><code>ubA</code></td>
<td>
<p>Upper boundary of the confidence interval of the elements of
the ratio matrix.
</p>
</td></tr>
<tr><td><code>ubX</code></td>
<td>
<p>Upper boundary of the confidence interval of the elements of
the composition matrix.
</p>
</td></tr>
<tr><td><code>lbA</code></td>
<td>
<p>Lower boundary of the confidence interval of the elements of
the ratio matrix.
</p>
</td></tr>
<tr><td><code>lbX</code></td>
<td>
<p>Lower boundary of the confidence interval of the elements of
the composition matrix.
</p>
</td></tr>
<tr><td><code>covar</code></td>
<td>
<p>Covariance matrix of all elements of A and X.
</p>
</td></tr>
</table>
<p>if object is output of the function BCE():
</p>
<p>a list containing:
</p>
<table>
<tr><td><code>firstX</code></td>
<td>
<p>X determined through least squares regression from the
initial ratio matrix and the data matrix.
</p>
</td></tr>
<tr><td><code>bestRat</code></td>
<td>
<p>Ratio matrix for which the posterior probability is maximal.
</p>
</td></tr>
<tr><td><code>bestX</code></td>
<td>
<p>Composition matrix for which the posterior probability is
maximal.
</p>
</td></tr>
<tr><td><code>bestp</code></td>
<td>
<p>Maximal posterior probability.
</p>
</td></tr>
<tr><td><code>bestDat</code></td>
<td>
<p>Product of <code>bestRat</code> and <code>bestX</code>.
</p>
</td></tr>
<tr><td><code>meanRat</code></td>
<td>
<p>Means of the elements of the ratio matrix.
</p>
</td></tr>
<tr><td><code>sdRat</code></td>
<td>
<p>Standard deviation of the elements of the ratio matrix.
</p>
</td></tr>
<tr><td><code>lbRat</code></td>
<td>
<p>Lower boundary of the confidence interval of the elements
of the ratio matrix.
</p>
</td></tr>
<tr><td><code>ubRat</code></td>
<td>
<p>Upper boundary of the confidence interval of the elements
of the ratio matrix.
</p>
</td></tr>
<tr><td><code>covRat</code></td>
<td>
<p>Covariance matrix of the elements of the ratio matrix.
</p>
</td></tr>
<tr><td><code>meanX</code></td>
<td>
<p>Means of the elements of the composition matrix.
</p>
</td></tr>
<tr><td><code>sdX</code></td>
<td>
<p>Standard deviation of the elements of the composition matrix.
</p>
</td></tr>
<tr><td><code>lbX</code></td>
<td>
<p>Lower boundary of the confidence interval of the elements of
the composition matrix.
</p>
</td></tr>
<tr><td><code>ubX</code></td>
<td>
<p>Upper boundary of the confidence interval of the elements
of the composition matrix.
</p>
</td></tr>
<tr><td><code>covX</code></td>
<td>
<p>Covariance matrix of the elements of the composition matrix.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Karel Van den Meersche
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bce1">bce1</a></code>, <code><a href="#topic+BCE">BCE</a></code>, <code><a href="#topic+plot.bce">plot.bce</a></code>,
<code><a href="#topic+export.bce">export.bce</a></code>, <code><a href="#topic+pairs.bce">pairs.bce</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># bceOutput is an example output based on bceInput

summary(bceOutput)
</code></pre>

<hr>
<h2 id='tlsce'>Total Least Squares Composition Estimator</h2><span id='topic+tlsce'></span>

<h3>Description</h3>

<p>estimates a matrix X for which:
</p>
<p style="text-align: center;"><code class="reqn">(A+\epsilon_A)X = B+\epsilon_B</code>
</p>

<p>minimize <code class="reqn">\sum{\epsilon_A^2 + \epsilon_B^2}</code>
</p>
<p style="text-align: center;"><code class="reqn">\sum{X_{i,}}=1 \forall i</code>
</p>

<p style="text-align: center;"><code class="reqn">X&gt;0</code>
</p>

<p>the elements of <code class="reqn">\epsilon_A</code> are NULL if the corresponding
elements of A are NULL. 
A typically contains biomarker concentrations for several taxonomic groups,
and B field measurements of the same biomarkers. X is then an estimate
of the taxonomic composition of the field sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tlsce(A, B, Wa=NULL, Wb=NULL, minA=NULL, maxA=NULL,
       A_init=A, Xratios=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tlsce_+3A_a">A</code></td>
<td>
<p>a matrix or data frame. If A contains biomarker data for
taxonomic groups, the biomarkers have to be organized per row, and
the taxonomic groups per column.
</p>
</td></tr>
<tr><td><code id="tlsce_+3A_b">B</code></td>
<td>
<p>a matrix or data frame. If B contains biomarker field data,
the biomarkers have to be organized per row, and the samples per
column.
</p>
</td></tr>
<tr><td><code id="tlsce_+3A_wa">Wa</code></td>
<td>
<p>weighting of A, a matrix with the same dimensions of A. If
<code>Wa=NULL</code>, Wa defaults to 1. This parameter can be used to give
more importance to elements of A or A in total compared to
B. weights are implemented as
proportional to <code class="reqn">1/s</code> (as opposed to <code class="reqn">1/s^2</code>) with s the
standard deviation of the error term.
</p>
</td></tr>
<tr><td><code id="tlsce_+3A_wb">Wb</code></td>
<td>
<p>weighting of B, a matrix with the same dimensions of B. If
<code>Wb=NULL</code>, Wb defaults to 1. This parameter can be used to give
more importance to elements of B or B in total compared to
A. weights are implemented as
proportional to <code class="reqn">1/s</code> (as opposed to <code class="reqn">1/s^2</code>) with s the
standard deviation of the error term.
</p>
</td></tr>
<tr><td><code id="tlsce_+3A_mina">minA</code></td>
<td>
<p>minimum values for A
</p>
</td></tr>
<tr><td><code id="tlsce_+3A_maxa">maxA</code></td>
<td>
<p>maximum values for A
</p>
</td></tr>
<tr><td><code id="tlsce_+3A_a_init">A_init</code></td>
<td>
<p>a matrix with the same structure as A. a general,
non-linear optimization routine (default <code>nlminb</code>) is used to
minimize the sum of squared residuals of A versus the fitted matrix
A\_fit (see value). This optimization routine requires a set of
starting values, by default the non-zero elements of A. This
provides a good fit, but when in doubt about the convergence of the
algorithm, one can provide different starting values for the
optimization routine in A\_init.</p>
</td></tr>
<tr><td><code id="tlsce_+3A_xratios">Xratios</code></td>
<td>
<p>TRUE or FALSE: are the colSums of the matrix X equal
to 1? This is for example the case in a compositional matrix.
(only if A and B are both expressed
relative to the unit of biomass) if
Xratios =TRUE, A has pigment
concentrations per biomass unit, B
has pigment concentrations per
biomass unit per sample, and X
contains ratios of biomass unit per
sample.  if Xratios =FALSE, A has
pigment concentrations per biomass
unit, B has pigment concentrations
per sample, and X has biomass units
per sample
</p>
</td></tr>
<tr><td><code id="tlsce_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to lsei()
or to modFit()
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>instead of a linear least squares regression, in which the
elements of A would be fixed, the function <code>tlsce</code> includes the
non-zero elements of A in the least squares regression. This is
similar to other total least squares regression methods (also called
orthogonal regression), with the main
difference that only non-zero elements of A contain an error term. 
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p> Array with dimension c(ncol(<code>A</code>),ncol(<code>B</code>),
<code>iter</code>) containing the species composition of each sample
</p>
</td></tr>
<tr><td><code>A\_fit</code></td>
<td>
<p> Array with same dimension as <code>A</code>, containing the
best-fit values of the input biomarker data per taxonomic group
</p>
</td></tr>
<tr><td><code>B\_fit</code></td>
<td>
<p> Array with same dimension as <code>B</code>, containing the
biomarker field data, corresponding to Afit
</p>
</td></tr>
<tr><td><code>solutionNorms</code></td>
<td>
<p>a vector of 3 values:
</p>
<p>the value of the minimised quadratic function at the solution, in this case
<code class="reqn">\sum{(Afit-A)*Wa)^2 + (Bfit-B)^2}</code>,
</p>
<p>and the shares of this value attributed to A and to B
</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>An integer code. '0' indicates successful convergence.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Karel Van den Meersche &lt;karel.van_den_meersche@cirad.fr&gt;,
Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>References</h3>

<p>Van den Meersche, K., K. Soetaert and J.J. Middelburg (2008) <em>A
Bayesian compositional estimator for microbial taxonomy
based on biomarkers</em>, Limnology and Oceanography Methods 6, 190-199
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BCE">BCE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- t(bceInput$Rat)
B &lt;- t(bceInput$Dat)
tlsce(A,B)
## weighting Wa inversely proportional to A
tlsce(A,B,Wa=1/A)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
