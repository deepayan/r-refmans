<!DOCTYPE html><html lang="en"><head><title>Help for package MASSExtra</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MASSExtra}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.normalise'><p>Normalise a vector</p></a></li>
<li><a href='#as_complex'><p>Coerce to complex</p></a></li>
<li><a href='#avoid'><p>Avoid overlaps</p></a></li>
<li><a href='#bc'><p>Box-Cox transform</p></a></li>
<li><a href='#bc_inv'><p>Box-Cox transform inverse</p></a></li>
<li><a href='#Boston'><p>Boston</p></a></li>
<li><a href='#box_cox'><p>Box-cox constructor function</p></a></li>
<li><a href='#Cars93'><p>Cars93</p></a></li>
<li><a href='#default_test'><p>Guess the default test</p></a></li>
<li><a href='#eigen2'><p>Generalized eigenvalue problem</p></a></li>
<li><a href='#GIC'><p>Intermediate Information Criterion</p></a></li>
<li><a href='#givens_orth'><p>Givens orthogonalisation</p></a></li>
<li><a href='#gs_orth_modified'><p>Gram-Schmidt orthogonalization</p></a></li>
<li><a href='#hr_levels'><p>#' @rdname kde_1d</p>
#' @export
kernelBiweight &lt;- function(x, mean = 0, sd = 1)
h &lt;- sqrt(7)*sd
ifelse((z &lt;- abs(x-mean)) &lt; h, 15/16*(1 - (z/h)^2)^2/h, 0)</a></li>
<li><a href='#kde_1d'><p>One-dimensional Kernel Density Estimate</p></a></li>
<li><a href='#kde_2d'><p>A Two-dimensional Kernel Density Estimate</p></a></li>
<li><a href='#lambda'><p>Find the box-cox transform exponent estimate</p></a></li>
<li><a href='#makepredictcall.normalise'><p>Method function for safe prediction</p></a></li>
<li><a href='#mean_c'><p>Mean and variance for a circular sample</p></a></li>
<li><a href='#plot.drop_term'><p>drop_term plot method</p></a></li>
<li><a href='#print.lambda'><p>Print method for Box-Cox objects</p></a></li>
<li><a href='#quine'><p>quine</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#step_AIC'><p>Stepwise model construction and inspection</p></a></li>
<li><a href='#step_down'><p>Naive backeward elimination</p></a></li>
<li><a href='#unitChange'><p>Unit change functions</p></a></li>
<li><a href='#usr2in'><p>Conversion functions for plotting</p></a></li>
<li><a href='#vcovx'><p>Extended variance matrix</p></a></li>
<li><a href='#which_tri'><p>Which in lower/upper triangle</p></a></li>
<li><a href='#whiteside'><p>whiteside</p></a></li>
<li><a href='#xy-class'><p>An S4 class to represent alternavive complex, matrix or list input forms.</p></a></li>
<li><a href='#zs'><p>Standardisation functions for models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Some 'MASS' Enhancements</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Bill Venables</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bill Venables &lt;bill.venables@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Some enhancements, extensions and additions
    to the facilities of the recommended 'MASS' package 
    that are useful mainly for teaching purposes, with
    more convenient default settings and user interfaces.
    Key functions from 'MASS' are imported and re-exported
    to avoid masking conflicts.  In addition we provide
    some additional functions mainly used to illustrate
    coding paradigms and techniques, such as Gramm-Schmidt
    orthogonalisation and generalised eigenvalue problems.  </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, graphics, stats, MASS, utils, grDevices, demoKde</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, patchwork, visreg, dplyr, ggplot2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-16 07:19:30 UTC; bill</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-16 07:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.normalise'>Normalise a vector</h2><span id='topic+.normalise'></span>

<h3>Description</h3>

<p>Similar to base::scale() but returning a vector with class attribute.
Used for safe prediction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.normalise(x, location, scale)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".normalise_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id=".normalise_+3A_location">location</code></td>
<td>
<p>A numeric vector of length 1</p>
</td></tr>
<tr><td><code id=".normalise_+3A_scale">scale</code></td>
<td>
<p>A numeric vector of length 1, usually positive</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A normalised vector inheriting from class &quot;normalise&quot;
</p>

<hr>
<h2 id='as_complex'>Coerce to complex</h2><span id='topic+as_complex'></span><span id='topic+as_complex+2Cxy+2Cmissing-method'></span><span id='topic+as_complex+2Cnumeric+2Cnumeric-method'></span><span id='topic+as_complex+2Cnumeric+2Cmissing-method'></span><span id='topic+as_complex+2Cmissing+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Utility function to create complex vectors from arguments
specified as in grDevices::xy.coords() or otherwise
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_complex(x, y)

## S4 method for signature 'xy,missing'
as_complex(x)

## S4 method for signature 'numeric,numeric'
as_complex(x, y)

## S4 method for signature 'numeric,missing'
as_complex(x, y)

## S4 method for signature 'missing,numeric'
as_complex(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_complex_+3A_x">x</code></td>
<td>
<p>A numeric vector or missing, or an object inheriting from class &quot;xy&quot;</p>
</td></tr>
<tr><td><code id="as_complex_+3A_y">y</code></td>
<td>
<p>If x is a numeric an optional numeric vector, or missing. If x or y are
missing they are taken as 0, but only one may be missing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A complex vector specifying 2-dimensional coordinates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as_complex(cbind(1:3, 3:1))
as_complex(y = 1:3)  ## real parts all zero
</code></pre>

<hr>
<h2 id='avoid'>Avoid overlaps</h2><span id='topic+avoid'></span><span id='topic+avoid+2Cnumeric-method'></span><span id='topic+avoid+2Cxy-method'></span>

<h3>Description</h3>

<p>Generate a vector of positions to use to minimise text overlaps in labelled scatterplots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avoid(x, ...)

## S4 method for signature 'numeric'
avoid(
  x,
  y,
  ...,
  xlog = par("xlog"),
  ylog = par("ylog"),
  usr = par("usr"),
  pin = par("pin"),
  eps = .Machine$double.eps,
  pi = base::pi
)

## S4 method for signature 'xy'
avoid(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="avoid_+3A_x">x</code>, <code id="avoid_+3A_y">y</code></td>
<td>
<p>any of the forms that the coordinates of a scatterplot may be specified</p>
</td></tr>
<tr><td><code id="avoid_+3A_...">...</code></td>
<td>
<p>additional arguments for methods</p>
</td></tr>
<tr><td><code id="avoid_+3A_xlog">xlog</code>, <code id="avoid_+3A_ylog">ylog</code></td>
<td>
<p>logicals: are the x- and/or y-scales logarithmic?</p>
</td></tr>
<tr><td><code id="avoid_+3A_usr">usr</code>, <code id="avoid_+3A_pin">pin</code></td>
<td>
<p>graphics parameters <code>par("usr"), par("pin")</code> (or replacements)</p>
</td></tr>
<tr><td><code id="avoid_+3A_eps">eps</code></td>
<td>
<p>numeric: a zero tolerance</p>
</td></tr>
<tr><td><code id="avoid_+3A_pi">pi</code></td>
<td>
<p>numeric: the value of the arithmetic constant of the same name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of integers all of which are 1, 2, 3, or 4, indicating placement positions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
z &lt;- complex(real = runif(50), imaginary = runif(50))
mz &lt;- mean(z)
z &lt;- z[order(Arg(z - mz))]
plot(z, axes = FALSE, ann = FALSE)
segments(Re(mz), Im(mz), Re(z), Im(z))
abline(h = Im(mz), v = Re(mz), lwd = 0.5)
box()
text(Re(z), Im(z), pos = avoid(z), cex = 0.7, offset = 0.25,
     col = "red", font = 2, xpd = NA)
</code></pre>

<hr>
<h2 id='bc'>Box-Cox transform</h2><span id='topic+bc'></span>

<h3>Description</h3>

<p>Compute the box-cox transform of a vector of values, handling
the region near lambda = 0 with some care
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bc(y, lambda, eps = 1e-04)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bc_+3A_y">y</code></td>
<td>
<p>numeric, the original observations</p>
</td></tr>
<tr><td><code id="bc_+3A_lambda">lambda</code></td>
<td>
<p>numeric, the box-cox power</p>
</td></tr>
<tr><td><code id="bc_+3A_eps">eps</code></td>
<td>
<p>numeric, a guard aroung lambda = 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of transformed quantities
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(12:50, bc(12:50, -1), type = "l", xlab = "MPG", ylab = "bc(MPG, -1)",
     las = 1, col = "sky blue", panel.first = grid())
points(bc(MPG.city, -1) ~ MPG.city, data = Cars93, pch = 16, cex = 0.7)
</code></pre>

<hr>
<h2 id='bc_inv'>Box-Cox transform inverse</h2><span id='topic+bc_inv'></span>

<h3>Description</h3>

<p>Find the original value corresponding to a box-cox transform
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bc_inv(z, lambda, eps = 1e-05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bc_inv_+3A_z">z</code></td>
<td>
<p>numeric, the transformed value</p>
</td></tr>
<tr><td><code id="bc_inv_+3A_lambda">lambda</code></td>
<td>
<p>numeric, the power of the box-cox transform</p>
</td></tr>
<tr><td><code id="bc_inv_+3A_eps">eps</code></td>
<td>
<p>numeric, a guard around lambda = 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of original quantities
</p>


<h3>Examples</h3>

<pre><code class='language-R'>invy &lt;- with(Cars93, bc(MPG.city, lambda = -1))
mpgc &lt;- bc_inv(invy, lambda = -1)
range(mpgc - Cars93$MPG.city)
</code></pre>

<hr>
<h2 id='Boston'>Boston</h2><span id='topic+Boston'></span>

<h3>Description</h3>

<p>Taken from the MASS data sets.  See MASS::&lt;data set&gt; for more information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Boston
</code></pre>


<h3>Format</h3>

<p>A data frame with 506 rows and 14 columns:
</p>

<dl>
<dt>crim</dt><dd><p>numeric: As for MASS dataset of the same name. </p>
</dd>
<dt>zn</dt><dd><p>numeric: As for MASS dataset of the same name. </p>
</dd>
<dt>indus</dt><dd><p>numeric: As for MASS dataset of the same name. </p>
</dd>
<dt>chas</dt><dd><p>integer: As for MASS dataset of the same name. </p>
</dd>
<dt>nox</dt><dd><p>numeric: As for MASS dataset of the same name. </p>
</dd>
<dt>rm</dt><dd><p>numeric: As for MASS dataset of the same name. </p>
</dd>
<dt>age</dt><dd><p>numeric: As for MASS dataset of the same name. </p>
</dd>
<dt>dis</dt><dd><p>numeric: As for MASS dataset of the same name. </p>
</dd>
<dt>rad</dt><dd><p>integer: As for MASS dataset of the same name. </p>
</dd>
<dt>tax</dt><dd><p>numeric: As for MASS dataset of the same name. </p>
</dd>
<dt>ptratio</dt><dd><p>numeric: As for MASS dataset of the same name. </p>
</dd>
<dt>black</dt><dd><p>numeric: As for MASS dataset of the same name. </p>
</dd>
<dt>lstat</dt><dd><p>numeric: As for MASS dataset of the same name. </p>
</dd>
<dt>medv</dt><dd><p>numeric: As for MASS dataset of the same name. </p>
</dd>
</dl>


<hr>
<h2 id='box_cox'>Box-cox constructor function</h2><span id='topic+box_cox'></span><span id='topic+box_cox+2Cformula-method'></span><span id='topic+box_cox+2Clm-method'></span><span id='topic+plot.box_cox'></span><span id='topic+print.box_cox'></span>

<h3>Description</h3>

<p>A front-end to <code><a href="MASS.html#topic+boxcox">boxcox</a></code> with slicker display and better defaults
</p>


<h3>Usage</h3>

<pre><code class='language-R'>box_cox(object, ...)

## S4 method for signature 'formula'
box_cox(object, data = sys.parent(), ...)

## S4 method for signature 'lm'
box_cox(object, ..., plotit, flap = 0.4)

## S3 method for class 'box_cox'
plot(
  x,
  ...,
  las = 1,
  xlab = expression(lambda),
  ylab,
  col.lines = "steel blue"
)

## S3 method for class 'box_cox'
print(
  x,
  ...,
  las = 1,
  xlab = expression(lambda),
  ylab,
  col.lines = "steel blue"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="box_cox_+3A_object">object</code></td>
<td>
<p>either a <code>"box_cox"</code> object, a formula,data pair, a linear model object or an xy-lixt</p>
</td></tr>
<tr><td><code id="box_cox_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to methods</p>
</td></tr>
<tr><td><code id="box_cox_+3A_data">data</code></td>
<td>
<p>a data frame or environment</p>
</td></tr>
<tr><td><code id="box_cox_+3A_plotit">plotit</code></td>
<td>
<p>currently ignored.  Plotting is done by <code>plot</code> or <code>print</code> methods</p>
</td></tr>
<tr><td><code id="box_cox_+3A_flap">flap</code></td>
<td>
<p>fraction of the central 95% notional confidence to expand the range of lambda for the display</p>
</td></tr>
<tr><td><code id="box_cox_+3A_x">x</code></td>
<td>
<p>a <code>"box_cox"</code> object to be displayed</p>
</td></tr>
<tr><td><code id="box_cox_+3A_xlab">xlab</code>, <code id="box_cox_+3A_ylab">ylab</code>, <code id="box_cox_+3A_las">las</code></td>
<td>
<p>as for <code>plot</code></p>
</td></tr>
<tr><td><code id="box_cox_+3A_col.lines">col.lines</code></td>
<td>
<p>colour to use for indicator lines in the display</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"box_cox"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>box_cox(MPG.city ~ Weight, Cars93)
</code></pre>

<hr>
<h2 id='Cars93'>Cars93</h2><span id='topic+Cars93'></span>

<h3>Description</h3>

<p>Taken from the MASS data sets.  See MASS::&lt;data set&gt; for more information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cars93
</code></pre>


<h3>Format</h3>

<p>A data frame with 93 rows and 27 columns:
</p>

<dl>
<dt>Manufacturer</dt><dd><p>factor: As for MASS dataset of the same name. </p>
</dd>
<dt>Model</dt><dd><p>factor: As for MASS dataset of the same name. </p>
</dd>
<dt>Type</dt><dd><p>factor: As for MASS dataset of the same name. </p>
</dd>
<dt>Min.Price</dt><dd><p>numeric: As for MASS dataset of the same name. </p>
</dd>
<dt>Price</dt><dd><p>numeric: As for MASS dataset of the same name. </p>
</dd>
<dt>Max.Price</dt><dd><p>numeric: As for MASS dataset of the same name. </p>
</dd>
<dt>MPG.city</dt><dd><p>integer: As for MASS dataset of the same name. </p>
</dd>
<dt>MPG.highway</dt><dd><p>integer: As for MASS dataset of the same name. </p>
</dd>
<dt>AirBags</dt><dd><p>factor: As for MASS dataset of the same name. </p>
</dd>
<dt>DriveTrain</dt><dd><p>factor: As for MASS dataset of the same name. </p>
</dd>
<dt>Cylinders</dt><dd><p>factor: As for MASS dataset of the same name. </p>
</dd>
<dt>EngineSize</dt><dd><p>numeric: As for MASS dataset of the same name. </p>
</dd>
<dt>Horsepower</dt><dd><p>integer: As for MASS dataset of the same name. </p>
</dd>
<dt>RPM</dt><dd><p>integer: As for MASS dataset of the same name. </p>
</dd>
<dt>Rev.per.mile</dt><dd><p>integer: As for MASS dataset of the same name. </p>
</dd>
<dt>Man.trans.avail</dt><dd><p>factor: As for MASS dataset of the same name. </p>
</dd>
<dt>Fuel.tank.capacity</dt><dd><p>numeric: As for MASS dataset of the same name. </p>
</dd>
<dt>Passengers</dt><dd><p>integer: As for MASS dataset of the same name. </p>
</dd>
<dt>Length</dt><dd><p>integer: As for MASS dataset of the same name. </p>
</dd>
<dt>Wheelbase</dt><dd><p>integer: As for MASS dataset of the same name. </p>
</dd>
<dt>Width</dt><dd><p>integer: As for MASS dataset of the same name. </p>
</dd>
<dt>Turn.circle</dt><dd><p>integer: As for MASS dataset of the same name. </p>
</dd>
<dt>Rear.seat.room</dt><dd><p>numeric: As for MASS dataset of the same name. </p>
</dd>
<dt>Luggage.room</dt><dd><p>integer: As for MASS dataset of the same name. </p>
</dd>
<dt>Weight</dt><dd><p>integer: As for MASS dataset of the same name. </p>
</dd>
<dt>Origin</dt><dd><p>factor: As for MASS dataset of the same name. </p>
</dd>
<dt>Make</dt><dd><p>factor: As for MASS dataset of the same name. </p>
</dd>
</dl>


<hr>
<h2 id='default_test'>Guess the default test</h2><span id='topic+default_test'></span><span id='topic+default_test.default'></span><span id='topic+default_test.negbin'></span><span id='topic+default_test.lmerMod'></span><span id='topic+default_test.glmerMod'></span><span id='topic+default_test.multinom'></span><span id='topic+default_test.polr'></span><span id='topic+default_test.glm'></span><span id='topic+default_test.lm'></span>

<h3>Description</h3>

<p>Find an appropriate test to use in <code><a href="MASS.html#topic+dropterm">dropterm</a></code> if not specified
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_test(object)

## Default S3 method:
default_test(object)

## S3 method for class 'negbin'
default_test(object)

## S3 method for class 'lmerMod'
default_test(object)

## S3 method for class 'glmerMod'
default_test(object)

## S3 method for class 'multinom'
default_test(object)

## S3 method for class 'polr'
default_test(object)

## S3 method for class 'glm'
default_test(object)

## S3 method for class 'lm'
default_test(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="default_test_+3A_object">object</code></td>
<td>
<p>a fitted model object accommodated by <code><a href="MASS.html#topic+dropterm">dropterm</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string, one of <code>"F", "Chisq", or "none"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm &lt;- glm.nb(Days ~ .^3, quine)
default_test(fm)
</code></pre>

<hr>
<h2 id='eigen2'>Generalized eigenvalue problem</h2><span id='topic+eigen2'></span>

<h3>Description</h3>

<p>Solves the generalized eigenvalue problem (B - lambda*W)*alpha = 0,
where B and W are symmetric matrices of the same size, W is positive
definite, lambda is a scalar and alpha and 0 are vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigen2(B, W)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eigen2_+3A_b">B</code>, <code id="eigen2_+3A_w">W</code></td>
<td>
<p>Similarly sized symmetric matrices with W positive definite.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If W is not specified, W = I is assumed.
</p>


<h3>Value</h3>

<p>A list with components <code>values</code> and <code>vectors</code> as for <code><a href="base.html#topic+eigen">eigen</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- as.matrix(subset(iris, select = -Species))
W &lt;- crossprod(resid(aov(X ~ Species, iris)))
B &lt;- crossprod(resid(aov(X ~ 1,       iris))) - W
n &lt;- nrow(iris)
p &lt;- length(levels(iris$Species))
(ev &lt;- eigen2(B/(p - 1), W/(n - p)))  ## hand-made discriminant analysis
DF &lt;- X %*% ev$vectors[, 1:2]
with(iris, {
     plot(DF, col = Species, pch = 20,
          xlab = expression(DF[1]), ylab = expression(DF[2]))
     legend("topleft", levels(Species), pch = 20, col = 1:3)
})
</code></pre>

<hr>
<h2 id='GIC'>Intermediate Information Criterion</h2><span id='topic+GIC'></span>

<h3>Description</h3>

<p>An AIC-variant criterion that weights complexity with a penalty
mid-way between 2 (as for AIC) and log(n) (as for BIC).  I.e.
&quot;not too soft&quot; and &quot;not too hard&quot;, just &quot;Glodilocks&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GIC(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GIC_+3A_object">object</code></td>
<td>
<p>a fitted model object for which the criterion is desired</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The GIC criterion value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gm &lt;- glm.nb(Days ~ Sex/(Age + Eth*Lrn), quine)
c(AIC = AIC(gm), GIC = GIC(gm), BIC = BIC(gm))
</code></pre>

<hr>
<h2 id='givens_orth'>Givens orthogonalisation</h2><span id='topic+givens_orth'></span>

<h3>Description</h3>

<p>Orthogonalization using Givens' method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>givens_orth(X, nullspace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="givens_orth_+3A_x">X</code></td>
<td>
<p>a numeric matrix with ncol(X) &lt;= nrow(X)</p>
</td></tr>
<tr><td><code id="givens_orth_+3A_nullspace">nullspace</code></td>
<td>
<p>logical: do you want an orthogonal basis for the null space?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components Q, R, as normally defined, and if nullspace is TRUE
a further component N giving the basis for the requested null space of X
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
X &lt;- matrix(rnorm(7*6), 7)
givens_orth(X, nullspace = TRUE)
</code></pre>

<hr>
<h2 id='gs_orth_modified'>Gram-Schmidt orthogonalization</h2><span id='topic+gs_orth_modified'></span><span id='topic+gs_orth'></span>

<h3>Description</h3>

<p>Either classical or modified algorithms.
The modified algorithm is the more accurate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs_orth_modified(X)

gs_orth(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gs_orth_modified_+3A_x">X</code></td>
<td>
<p>a numerical matrix with ncol(X) &lt;= nrow(X)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two components, Q, R, as usually defined.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
X &lt;- matrix(rnorm(10*7), 10)
gs_orth_modified(X)
all.equal(gs_orth(X), gs_orth_modified(X))
all.equal(gs_orth_modified(X), givens_orth(X))
</code></pre>

<hr>
<h2 id='hr_levels'>#' @rdname kde_1d
#' @export
kernelBiweight &lt;- function(x, mean = 0, sd = 1) 
h &lt;- sqrt(7)*sd
ifelse((z &lt;- abs(x-mean)) &lt; h, 15/16*(1 - (z/h)^2)^2/h, 0)
</h2><span id='topic+hr_levels'></span><span id='topic+hr_levels.default'></span><span id='topic+hr_levels.kde_2d'></span>

<h3>Description</h3>

<p>#' @rdname kde_1d
#' @export
kernelCosine &lt;- function(x, mean = 0, sd = 1) 
h &lt;- sqrt(1/(1-8/pi^2))*sd
ifelse((z &lt;- abs(x-mean)) &lt; h, pi/4*cos((pi*z)/(2*h))/h, 0)

</p>


<h3>Usage</h3>

<pre><code class='language-R'>hr_levels(x, ...)

## Default S3 method:
hr_levels(x, p = (1:9)/10, ...)

## S3 method for class 'kde_2d'
hr_levels(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hr_levels_+3A_x">x</code></td>
<td>
<p>an object whose <code>z</code> component represents the KDE</p>
</td></tr>
<tr><td><code id="hr_levels_+3A_...">...</code></td>
<td>
<p>extra arguments (currently not used)</p>
</td></tr>
<tr><td><code id="hr_levels_+3A_p">p</code></td>
<td>
<p>a vector of probability levels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>#' @rdname kde_1d
#' @export
kernelEpanechnikov &lt;- function(x, mean = 0, sd = 1) 
h &lt;- sqrt(5)*sd
ifelse((z &lt;- abs(x-mean)) &lt; h, 3/4*(1 - (z/h)^2)/h, 0)

</p>
<p>#' @rdname kde_1d
#' @export
kernelGaussian &lt;- function(x, mean = 0, sd = 1)
dnorm(x, mean = mean, sd = sd)
</p>
<p>#' @rdname kde_1d
#' @export
kernelLogistic &lt;- function(x, mean = 0, sd = 1)
stats::dlogis(x, mean, sqrt(3)/pi*sd)
</p>
<p>#' @rdname kde_1d
#' @export
kernelOptCosine &lt;- function(x, mean = 0, sd = 1) 
h &lt;- sqrt(1/(1-8/pi^2))*sd
ifelse((z &lt;- abs(x-mean)) &lt; h, pi/4*cos((pi*z)/(2*h))/h, 0)

</p>
<p>#' @rdname kde_1d
#' @export
kernelRectangular &lt;- function(x, mean = 0, sd = 1) 
h &lt;- sqrt(3)*sd
ifelse(abs(x-mean) &lt; h, 1/(2*h), 0)

</p>
<p>#' @rdname kde_1d
#' @export
kernelSquaredCosine &lt;- function(x, mean = 0, sd = 1) 
h &lt;- sqrt(3/(1-6/pi^2))*sd
ifelse((z &lt;- abs(x-mean)) &lt; h, cos(pi*z/(2*h))^2/h, 0)

</p>
<p>#' @rdname kde_1d
#' @export
kernelTriangular &lt;- function(x, mean = 0, sd = 1) 
h &lt;- sqrt(24)*sd/2
ifelse((z &lt;- abs(x-mean)) &lt; h, (1 - z/h)/h, 0)

</p>
<p>#' @rdname kde_1d
#' @export
kernelTricube &lt;- function(x, mean = 0, sd = 1) 
h &lt;- sqrt(243/35)*sd
ifelse((z &lt;- abs(x - mean)) &lt; h, 70/81*(1 - (z/h)^3)^3/h, 0)

</p>
<p>#' @rdname kde_1d
#' @export
kernelTriweight &lt;- function(x, mean = 0, sd = 1) 
h &lt;- sqrt(9)*sd
ifelse((z &lt;- abs(x-mean)) &lt; h, 35/32*(1 - (z/h)^2)^3/h, 0)

</p>
<p>#' @rdname kde_1d
#' @export
kernelUniform &lt;- function(x, mean = 0, sd = 1) 
h &lt;- sqrt(3)*sd
ifelse(abs(x-mean) &lt; h, 1/(2*h), 0)

Home Range levels
</p>
<p>For an object representing a 2-dimensional kernel density estimate
find the level(s) defining a central &quot;home range&quot; region, that is,
a region of probability content p for which all density points
within the region are higher than any density point outside the region.
This makes it a region of probability p with smallest area.
</p>


<h3>Value</h3>

<p>A vector of density levels defining the home range contours
</p>


<h3>Examples</h3>

<pre><code class='language-R'>krc &lt;- with(Boston, {
  criminality &lt;- log(crim)
  spaciousness &lt;- sqrt(rm)
  kde_2d(criminality, spaciousness)
})
plot(krc, xlab = expression(italic(Criminality)),
          ylab = expression(italic(Spaciousness)))
home &lt;- hr_levels(krc, p = 0.5)
contour(krc, add = TRUE, levels = home, labels = "50%")
</code></pre>

<hr>
<h2 id='kde_1d'>One-dimensional Kernel Density Estimate</h2><span id='topic+kde_1d'></span><span id='topic+print.kde_1d'></span><span id='topic+plot.kde_1d'></span>

<h3>Description</h3>

<p>A pure R implementation of an approximate one-dimensional KDE, similar
to <code><a href="stats.html#topic+density">density</a></code> but using a different algorithm not involving
<code><a href="stats.html#topic+fft">fft</a></code>.  Two extra facilities are provided, namely
(a) the kernel may be given either as a character string to select one of a
number of kernel functions provided, or a user defined R function, and (b) the
kde may be fitted beyond the prescribed limits for the result, and folded back
to emulate the effect of having known bounds for the distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kde_1d(
  x,
  bw = bw.nrd0,
  kernel = c("gaussian", "biweight", "cosine", "epanechnikov", "logistic", "optCosine",
    "rectangular", "squaredCosine", "triangular", "tricube", "triweight", "uniform"),
  n = 512,
  limits = c(rx[1] - cut * bw, rx[2] + cut * bw),
  cut = 3,
  na.rm = FALSE,
  adjust = 1,
  fold = FALSE,
  ...
)

## S3 method for class 'kde_1d'
print(x, ...)

## S3 method for class 'kde_1d'
plot(
  x,
  ...,
  col = "steel blue",
  las = 1,
  xlab = bquote(x == italic(.(x$data_name))),
  ylab = expression(kde(italic(x)))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kde_1d_+3A_x">x</code></td>
<td>
<p>A numeric vector for which the kde is required or (in methods)
an object of class <code>"kde_1d"</code></p>
</td></tr>
<tr><td><code id="kde_1d_+3A_bw">bw</code></td>
<td>
<p>The bandwidth or the bandwidth function.</p>
</td></tr>
<tr><td><code id="kde_1d_+3A_kernel">kernel</code></td>
<td>
<p>The kernel function, specified either as a character string or as
an R function. Partial matching of the character string is allowed.</p>
</td></tr>
<tr><td><code id="kde_1d_+3A_n">n</code></td>
<td>
<p>Integer, the number of equally-spaced values in the abscissa of the kde</p>
</td></tr>
<tr><td><code id="kde_1d_+3A_limits">limits</code></td>
<td>
<p>numeric vector of length 2.  Prescribed x-range limits for the
x-range of the result.  May be infinite, but infinite values will be
pruned back to an appropriate value as determined by the data.</p>
</td></tr>
<tr><td><code id="kde_1d_+3A_cut">cut</code></td>
<td>
<p>The number of bandwidths beyond the range of the input x-values to use</p>
</td></tr>
<tr><td><code id="kde_1d_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical value: should any missing values in x be silently removed?</p>
</td></tr>
<tr><td><code id="kde_1d_+3A_adjust">adjust</code></td>
<td>
<p>numeric value: a multiplier to be applied to the computed bandwidth.</p>
</td></tr>
<tr><td><code id="kde_1d_+3A_fold">fold</code></td>
<td>
<p>Logical value: should the kde be estimated beyond the prescribed limits
for the result and 'folded back' to emulate the effect of having known
range boundaries for the underlying distribution?</p>
</td></tr>
<tr><td><code id="kde_1d_+3A_...">...</code></td>
<td>
<p>currently ignored, except in method functions</p>
</td></tr>
<tr><td><code id="kde_1d_+3A_las">las</code>, <code id="kde_1d_+3A_col">col</code>, <code id="kde_1d_+3A_xlab">xlab</code>, <code id="kde_1d_+3A_ylab">ylab</code></td>
<td>
<p>base graphics parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of results specifying the result of the kde computation, of class <code>"kde_1d"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
u &lt;- runif(5000)
kdeu0 &lt;- kde_1d(u, limits = c(-Inf, Inf))
kdeu1 &lt;- kde_1d(u, limits = 0:1, kernel = "epan", fold = TRUE)
plot(kdeu0, col = 4)
lines(kdeu1, col = "dark green")
fun &lt;- function(x) (0 &lt; x &amp; x &lt; 1) + 0
curve(fun, add=TRUE, col = "grey", n = 1000)
</code></pre>

<hr>
<h2 id='kde_2d'>A Two-dimensional Kernel Density Estimate</h2><span id='topic+kde_2d'></span><span id='topic+print.kde_2d'></span><span id='topic+plot.kde_2d'></span>

<h3>Description</h3>

<p>A pure R implementation of an approximate two-dimensional kde computation, where
the approximation depends on the x- and y-resolution being fine, i.e. the number
of both x- and y-points should be reasonably large, at least 256.  The coding
follows the same idea as used in <code><a href="MASS.html#topic+kde2d">kde2d</a></code>, but scales much better
for large data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kde_2d(
  x,
  y = NULL,
  bw = list(x = bw.nrd0, y = bw.nrd0),
  kernel = c("gaussian", "biweight", "cosine", "epanechnikov", "logistic", "optCosine",
    "rectangular", "squaredCosine", "triangular", "tricube", "triweight", "uniform"),
  n = 128,
  x_limits = c(rx[1] - cut * bw["x"], rx[2] + cut * bw["x"]),
  y_limits = c(ry[1] - cut * bw["y"], ry[2] + cut * bw["y"]),
  cut = 1,
  na.rm = FALSE,
  adjust = 53/45,
  ...
)

## S3 method for class 'kde_2d'
print(x, ...)

## S3 method for class 'kde_2d'
plot(
  x,
  ...,
  las = 1,
  xlab = bquote(italic(.(x$data_name[["x"]]))),
  ylab = bquote(italic(.(x$data_name[["y"]]))),
  col = hcl.colors(50, "YlOrRd", rev = TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kde_2d_+3A_x">x</code>, <code id="kde_2d_+3A_y">y</code></td>
<td>
<p>Numeric vectors of the same length specified in any way acceptable
to <code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code>.  In methods, <code>x</code> will be
an object of class <code>"kde_2d"</code></p>
</td></tr>
<tr><td><code id="kde_2d_+3A_bw">bw</code></td>
<td>
<p>bandwidths. May be a numeric vector of length 1 or 2, or a function,
or list of two bandwidth computation functions.  Short entities will
be repeated to length 1.  The first relates to the x-coordinate and
the second to the y.</p>
</td></tr>
<tr><td><code id="kde_2d_+3A_kernel">kernel</code></td>
<td>
<p>As for <code><a href="#topic+kde_1d">kde_1d</a></code> though 1 or 2 values may be specified
relating to x- and y-coordinates respectively.  Short entities will
be repeated to length 2</p>
</td></tr>
<tr><td><code id="kde_2d_+3A_n">n</code></td>
<td>
<p>positive integer vector of length 1 or 2 specifying the resolution required
in the x- and y-coordinates respectively.  Short values will be repeated to
length 2.</p>
</td></tr>
<tr><td><code id="kde_2d_+3A_x_limits">x_limits</code>, <code id="kde_2d_+3A_y_limits">y_limits</code></td>
<td>
<p>Numeric vectors specifying the limits required for the result</p>
</td></tr>
<tr><td><code id="kde_2d_+3A_cut">cut</code></td>
<td>
<p>The number of bandwidths beyond the x- and y-range limits for the resuls.</p>
</td></tr>
<tr><td><code id="kde_2d_+3A_na.rm">na.rm</code></td>
<td>
<p>Should missing values be silently removed?</p>
</td></tr>
<tr><td><code id="kde_2d_+3A_adjust">adjust</code></td>
<td>
<p>A factor to adjust both bandwidths to regulate smoothness</p>
</td></tr>
<tr><td><code id="kde_2d_+3A_...">...</code></td>
<td>
<p>currently ignored, except in method functions</p>
</td></tr>
<tr><td><code id="kde_2d_+3A_las">las</code>, <code id="kde_2d_+3A_col">col</code>, <code id="kde_2d_+3A_xlab">xlab</code>, <code id="kde_2d_+3A_ylab">ylab</code></td>
<td>
<p>base graphics parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of results of class <code>"kde_2d"</code>.  The result may be used directly
in <code><a href="graphics.html#topic+image">image</a></code> or <code><a href="graphics.html#topic+contour">contour</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>krc &lt;- with(Boston, {
  criminality &lt;- log(crim)
  spaciousness &lt;- sqrt(rm)
  kde_2d(criminality, spaciousness, n = 128, kernel = "biweight")
})
plot(krc, xlab = expression(italic(Criminality)), ylab = expression(italic(Spaciousness)))
levs &lt;- hr_levels(krc)
contour(krc, add = TRUE, levels = levs, labels = names(levs))

with(krc, persp(x, 10*y, 3*z, border="transparent", col = "powder blue",
                theta = 30, phi = 15, r = 20, scale = FALSE, shade = TRUE,
                xlab = "Criminality", ylab = "Spaciousness", zlab = "density"))
</code></pre>

<hr>
<h2 id='lambda'>Find the box-cox transform exponent estimate</h2><span id='topic+lambda'></span><span id='topic+lambda.formula'></span><span id='topic+lambda.lm'></span><span id='topic+lambda.box_cox'></span><span id='topic+lambda.default'></span>

<h3>Description</h3>

<p>Estimates the box-cox power transformation appropriate for
a linear model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambda(bc, ...)

## S3 method for class 'formula'
lambda(bc, data = sys.parent(), ..., span = 5)

## S3 method for class 'lm'
lambda(bc, ..., span = 5)

## S3 method for class 'box_cox'
lambda(bc, ..., span = 5)

## Default S3 method:
lambda(bc, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lambda_+3A_bc">bc</code></td>
<td>
<p>either a <code>"box_cox"</code> object, a formula,data pair, a linear model object or an xy-lixt</p>
</td></tr>
<tr><td><code id="lambda_+3A_...">...</code></td>
<td>
<p>additional parameters passed on to <code>box_cox</code></p>
</td></tr>
<tr><td><code id="lambda_+3A_data">data</code></td>
<td>
<p>a data frame or envinonment</p>
</td></tr>
<tr><td><code id="lambda_+3A_span">span</code></td>
<td>
<p>integer: how many steps on either side of the maximum to use for the quadratic interpolation to find the maximum</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric: the maximum likelihood estimate of the exponent
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lambda(medv ~ ., Boston, span = 10)
</code></pre>

<hr>
<h2 id='makepredictcall.normalise'>Method function for safe prediction</h2><span id='topic+makepredictcall.normalise'></span>

<h3>Description</h3>

<p>This is an internal function not intended to be called directly by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'normalise'
makepredictcall(var, call)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makepredictcall.normalise_+3A_var">var</code></td>
<td>
<p>A numeric variable</p>
</td></tr>
<tr><td><code id="makepredictcall.normalise_+3A_call">call</code></td>
<td>
<p>A single term from a linear model formula</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A call object used in safe prediction
</p>

<hr>
<h2 id='mean_c'>Mean and variance for a circular sample</h2><span id='topic+mean_c'></span><span id='topic+var_c'></span>

<h3>Description</h3>

<p>Mean and variance for a circular sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_c(theta)

var_c(theta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean_c_+3A_theta">theta</code></td>
<td>
<p>A vector of angles (in radians)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The mean (rsp. variance) of the angle sample
</p>


<h3>Examples</h3>

<pre><code class='language-R'>th &lt;- 2*base::pi*(rbeta(2000, 1.5, 1.5) - 0.5)
c(mn = mean_c(th), va = var_c(th))
rm(th)
</code></pre>

<hr>
<h2 id='plot.drop_term'>drop_term plot method</h2><span id='topic+plot.drop_term'></span>

<h3>Description</h3>

<p>drop_term plot method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'drop_term'
plot(
  x,
  ...,
  horiz = TRUE,
  las = ifelse(horiz, 1, 2),
  col = c("#DF536B", "#2297E6"),
  border = c("#DF536B", "#2297E6"),
  show.model = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.drop_term_+3A_x">x</code></td>
<td>
<p>An object of class <code>"drop_term"</code> generated by tither <code>drop_term</code> or <code>add_term</code></p>
</td></tr>
<tr><td><code id="plot.drop_term_+3A_...">...</code>, <code id="plot.drop_term_+3A_horiz">horiz</code></td>
<td>
<p>arguments past on to <code>graphics::barplot</code></p>
</td></tr>
<tr><td><code id="plot.drop_term_+3A_las">las</code></td>
<td>
<p>graphics parameter</p>
</td></tr>
<tr><td><code id="plot.drop_term_+3A_col">col</code>, <code id="plot.drop_term_+3A_border">border</code></td>
<td>
<p><code>barplot</code> fill and border colour(s) for positive and negative changes to the criterion, respectively</p>
</td></tr>
<tr><td><code id="plot.drop_term_+3A_show.model">show.model</code></td>
<td>
<p>logical: should the model itself be displayed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>boston_quad &lt;- lm(medv ~ . + (rm + tax + lstat)^2 + poly(rm, 2) + 
         poly(tax, 2) + poly(lstat, 2), Boston)
dboston_quad &lt;- drop_term(boston_quad, k = "bic")
plot(dboston_quad)
plot(dboston_quad, horiz = FALSE)
</code></pre>

<hr>
<h2 id='print.lambda'>Print method for Box-Cox objects</h2><span id='topic+print.lambda'></span>

<h3>Description</h3>

<p>Print method for Box-Cox objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lambda'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.lambda_+3A_x">x</code></td>
<td>
<p>an object of class <code>"box_cox"</code></p>
</td></tr>
<tr><td><code id="print.lambda_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x, invisibly
</p>

<hr>
<h2 id='quine'>quine</h2><span id='topic+quine'></span>

<h3>Description</h3>

<p>Taken from the MASS data sets.  See MASS::&lt;data set&gt; for more information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quine
</code></pre>


<h3>Format</h3>

<p>A data frame with 146 rows and 5 columns:
</p>

<dl>
<dt>Eth</dt><dd><p>factor: As for MASS dataset of the same name. </p>
</dd>
<dt>Sex</dt><dd><p>factor: As for MASS dataset of the same name. </p>
</dd>
<dt>Age</dt><dd><p>factor: As for MASS dataset of the same name. </p>
</dd>
<dt>Lrn</dt><dd><p>factor: As for MASS dataset of the same name. </p>
</dd>
<dt>Days</dt><dd><p>integer: As for MASS dataset of the same name. </p>
</dd>
</dl>


<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+Null'></span><span id='topic+fractions'></span><span id='topic+ginv'></span><span id='topic+glm.convert'></span><span id='topic+glm.nb'></span><span id='topic+glmmPQL'></span><span id='topic+isoMDS'></span><span id='topic+kde2d'></span><span id='topic+lda'></span><span id='topic+lm.gls'></span><span id='topic+logtrans'></span><span id='topic+lqs'></span><span id='topic+mvrnorm'></span><span id='topic+negative.binomial'></span><span id='topic+polr'></span><span id='topic+qda'></span><span id='topic+rlm'></span><span id='topic+rnegbin'></span><span id='topic+sammon'></span><span id='topic+stdres'></span><span id='topic+studres'></span><span id='topic+theta.ml'></span><span id='topic+theta.mm'></span><span id='topic+theta.md'></span><span id='topic+ucv'></span><span id='topic+width.SJ'></span><span id='topic+stepAIC'></span><span id='topic+dropterm'></span><span id='topic+boxcox'></span><span id='topic+addterm'></span><span id='topic+ns'></span><span id='topic+bs'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>MASS</dt><dd><p><code><a href="MASS.html#topic+Null">Null</a></code>, <code><a href="MASS.html#topic+addterm">addterm</a></code>, <code><a href="MASS.html#topic+boxcox">boxcox</a></code>, <code><a href="MASS.html#topic+dropterm">dropterm</a></code>, <code><a href="MASS.html#topic+fractions">fractions</a></code>, <code><a href="MASS.html#topic+ginv">ginv</a></code>, <code><a href="MASS.html#topic+glm.convert">glm.convert</a></code>, <code><a href="MASS.html#topic+glm.nb">glm.nb</a></code>, <code><a href="MASS.html#topic+glmmPQL">glmmPQL</a></code>, <code><a href="MASS.html#topic+isoMDS">isoMDS</a></code>, <code><a href="MASS.html#topic+kde2d">kde2d</a></code>, <code><a href="MASS.html#topic+lda">lda</a></code>, <code><a href="MASS.html#topic+lm.gls">lm.gls</a></code>, <code><a href="MASS.html#topic+logtrans">logtrans</a></code>, <code><a href="MASS.html#topic+lqs">lqs</a></code>, <code><a href="MASS.html#topic+mvrnorm">mvrnorm</a></code>, <code><a href="MASS.html#topic+negative.binomial">negative.binomial</a></code>, <code><a href="MASS.html#topic+polr">polr</a></code>, <code><a href="MASS.html#topic+qda">qda</a></code>, <code><a href="MASS.html#topic+rlm">rlm</a></code>, <code><a href="MASS.html#topic+rnegbin">rnegbin</a></code>, <code><a href="MASS.html#topic+sammon">sammon</a></code>, <code><a href="MASS.html#topic+stdres">stdres</a></code>, <code><a href="MASS.html#topic+stepAIC">stepAIC</a></code>, <code><a href="MASS.html#topic+studres">studres</a></code>, <code><a href="MASS.html#topic+theta.md">theta.md</a></code>, <code><a href="MASS.html#topic+theta.md">theta.ml</a></code>, <code><a href="MASS.html#topic+theta.md">theta.mm</a></code>, <code><a href="MASS.html#topic+ucv">ucv</a></code>, <code><a href="MASS.html#topic+width.SJ">width.SJ</a></code></p>
</dd>
<dt>splines</dt><dd><p><code><a href="splines.html#topic+bs">bs</a></code>, <code><a href="splines.html#topic+ns">ns</a></code></p>
</dd>
</dl>

<hr>
<h2 id='step_AIC'>Stepwise model construction and inspection</h2><span id='topic+step_AIC'></span><span id='topic+step_BIC'></span><span id='topic+step_GIC'></span><span id='topic+drop_term'></span><span id='topic+add_term'></span>

<h3>Description</h3>

<p>Front-ends to <code><a href="MASS.html#topic+stepAIC">stepAIC</a></code> and <code><a href="MASS.html#topic+dropterm">dropterm</a></code> with changed defaults.
<code>step_BIC</code> implements a stepwise selection with BIC as the criterion and
<code>step_GIC</code> uses an experimental criterion with a penalty midway between AIC and BIC: the
&quot;Goldilocks&quot; criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_AIC(object, ..., trace = 0, k = 2)

step_BIC(object, ..., trace = 0, k = max(2, log(nobs(object))))

step_GIC(object, ..., trace = 0, k = (2 + log(nobs(object)))/2)

drop_term(
  object,
  ...,
  test = default_test(object),
  k,
  sorted = TRUE,
  decreasing = TRUE,
  delta = TRUE
)

add_term(
  object,
  ...,
  test = default_test(object),
  k,
  sorted = TRUE,
  decreasing = TRUE,
  delta = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="step_AIC_+3A_object">object</code></td>
<td>
<p>as for <code><a href="MASS.html#topic+stepAIC">stepAIC</a></code></p>
</td></tr>
<tr><td><code id="step_AIC_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to main function in <code>MASS</code></p>
</td></tr>
<tr><td><code id="step_AIC_+3A_trace">trace</code>, <code id="step_AIC_+3A_k">k</code></td>
<td>
<p>as for <code><a href="MASS.html#topic+stepAIC">stepAIC</a></code></p>
</td></tr>
<tr><td><code id="step_AIC_+3A_sorted">sorted</code>, <code id="step_AIC_+3A_test">test</code></td>
<td>
<p>as for <code><a href="MASS.html#topic+dropterm">dropterm</a></code> and <code><a href="MASS.html#topic+addterm">addterm</a></code></p>
</td></tr>
<tr><td><code id="step_AIC_+3A_decreasing">decreasing</code></td>
<td>
<p>in <code>drop_term</code> should the rows be displayed in decreasing order,
that is best to worst terms, from that of <code><a href="MASS.html#topic+dropterm">dropterm</a></code>?</p>
</td></tr>
<tr><td><code id="step_AIC_+3A_delta">delta</code></td>
<td>
<p>Should the criterion be displayed (FALSE) or the change in the
in the criterion relative to the present model (TRUE)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A fitted model object after stepwise refinement, or a data frame with
extra class membership for single term functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm &lt;- glm.nb(Days ~ .^3, quine)
drop_term(fm_aic &lt;- step_AIC(fm))
drop_term(fm_bic &lt;- step_BIC(fm))
</code></pre>

<hr>
<h2 id='step_down'>Naive backeward elimination</h2><span id='topic+step_down'></span>

<h3>Description</h3>

<p>A simple facility to refine models by backward elimination.
Covers cases where <code><a href="#topic+drop_term">drop_term</a></code> works but <code><a href="#topic+step_AIC">step_AIC</a></code>
does not
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_down(object, ..., trace = FALSE, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="step_down_+3A_object">object</code></td>
<td>
<p>A fitted model object</p>
</td></tr>
<tr><td><code id="step_down_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+drop_term">drop_term</a></code> such as <code>k</code></p>
</td></tr>
<tr><td><code id="step_down_+3A_trace">trace</code></td>
<td>
<p>logical: do you want a trace of the process printed?</p>
</td></tr>
<tr><td><code id="step_down_+3A_k">k</code></td>
<td>
<p>penalty (default 2, as for AIC)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A refined fitted model object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm &lt;- lm(medv ~ . + (rm + tax + lstat)^2 +
           I((rm - 6)^2) + I((tax - 400)^2) + I((lstat - 12)^2), Boston)
sfm &lt;- step_down(fm, trace = TRUE, k = "bic")
</code></pre>

<hr>
<h2 id='unitChange'>Unit change functions</h2><span id='topic+unitChange'></span><span id='topic+cm2in'></span><span id='topic+mm2in'></span><span id='topic+in2cm'></span><span id='topic+in2mm'></span>

<h3>Description</h3>

<p>Convert imperial to metric units, and vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cm2in(cm)

mm2in(mm)

in2cm(inch)

in2mm(inch)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unitChange_+3A_cm">cm</code>, <code id="unitChange_+3A_inch">inch</code>, <code id="unitChange_+3A_mm">mm</code></td>
<td>
<p>numeric vectors in the appropriate units</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector of values in the new units
</p>

<hr>
<h2 id='usr2in'>Conversion functions for plotting</h2><span id='topic+usr2in'></span><span id='topic+usr2in+2Cnumeric-method'></span><span id='topic+usr2in+2Cxy-method'></span><span id='topic+in2usr'></span><span id='topic+in2usr+2Cnumeric-method'></span><span id='topic+in2usr+2Cxy-method'></span>

<h3>Description</h3>

<p>Convert user coordinates to inch-based cordinates for the open display,
and back again
</p>


<h3>Usage</h3>

<pre><code class='language-R'>usr2in(x, ...)

## S4 method for signature 'numeric'
usr2in(
  x,
  y,
  usr = par("usr"),
  pin = par("pin"),
  xlog = par("xlog"),
  ylog = par("ylog"),
  ...
)

## S4 method for signature 'xy'
usr2in(x, ...)

in2usr(x, ...)

## S4 method for signature 'numeric'
in2usr(
  x,
  y,
  usr = par("usr"),
  pin = par("pin"),
  xlog = par("xlog"),
  ylog = par("ylog"),
  ...
)

## S4 method for signature 'xy'
in2usr(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="usr2in_+3A_x">x</code>, <code id="usr2in_+3A_y">y</code></td>
<td>
<p>any of the forms that the coordinates of a scatterplot may be specified</p>
</td></tr>
<tr><td><code id="usr2in_+3A_...">...</code></td>
<td>
<p>additional arguments for methods</p>
</td></tr>
<tr><td><code id="usr2in_+3A_usr">usr</code>, <code id="usr2in_+3A_pin">pin</code></td>
<td>
<p>graphics parameters <code>par("usr"), par("pin")</code> (or replacements)</p>
</td></tr>
<tr><td><code id="usr2in_+3A_xlog">xlog</code>, <code id="usr2in_+3A_ylog">ylog</code></td>
<td>
<p>logicals: are the x- and/or y-scales logarithmic?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>complex</code> vector of converted coordinates
</p>

<hr>
<h2 id='vcovx'>Extended variance matrix</h2><span id='topic+vcovx'></span><span id='topic+vcovx.default'></span><span id='topic+vcovx.negbin'></span>

<h3>Description</h3>

<p>An extension to the <code><a href="stats.html#topic+vcov">vcov</a></code> function mainly to
cover the additional parameter involved in negative binomial models.
(Currently the same as <code><a href="stats.html#topic+vcov">vcov</a></code> apart from negative binomial models.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcovx(object, ...)

## Default S3 method:
vcovx(object, ...)

## S3 method for class 'negbin'
vcovx(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcovx_+3A_object">object</code></td>
<td>
<p>A fitted mdel objeds</p>
</td></tr>
<tr><td><code id="vcovx_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An extended variance matrix including parameters addition to the regression coefficients
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm &lt;- glm.nb(Days ~ Sex/(Age + Eth*Lrn), quine)
Sigma &lt;- vcovx(fm)
</code></pre>

<hr>
<h2 id='which_tri'>Which in lower/upper triangle</h2><span id='topic+which_tri'></span>

<h3>Description</h3>

<p>Find where the original positions of components are
in a matrix given a logical vector corresponding
to the lower or upper triangle stored by columns.  Similar
to which(.., arr.ind = TRUE)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_tri(cond, diag = FALSE, lower = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="which_tri_+3A_cond">cond</code></td>
<td>
<p>logical vector of length that of the lower triangle</p>
</td></tr>
<tr><td><code id="which_tri_+3A_diag">diag</code></td>
<td>
<p>logical: are the diagonal entries included?</p>
</td></tr>
<tr><td><code id="which_tri_+3A_lower">lower</code></td>
<td>
<p>logical: is this the lower triangle?  If FALSE it is the upper.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a two column matrix with the row and column indices as the rows
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
X &lt;- matrix(rnorm(20*2), 20, 2)
plot(X, asp = 1, pch = 16, las = 1, xlab = "x", ylab = "y")
dX &lt;- dist(X)
ij &lt;- which_tri(dX == max(dX))
points(X[as.vector(ij), ], col = "red", cex = 2, pch = 1)
segments(X[ij[1], 1], X[ij[1], 2],
         X[ij[2], 1], X[ij[2], 2], col = "red")
ij &lt;- which_tri(dX == sort(dX, decreasing = TRUE)[2])
points(X[as.vector(ij), ], col = "blue", cex = 2, pch = 1)
segments(X[ij[1], 1], X[ij[1], 2],
         X[ij[2], 1], X[ij[2], 2], col = "blue")
polygon(X[chull(X), ], border = "sky blue")
rm(X, dX, ij)
</code></pre>

<hr>
<h2 id='whiteside'>whiteside</h2><span id='topic+whiteside'></span>

<h3>Description</h3>

<p>Taken from the MASS data sets.  See MASS::&lt;data set&gt; for more information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whiteside
</code></pre>


<h3>Format</h3>

<p>A data frame with 56 rows and 3 columns:
</p>

<dl>
<dt>Insul</dt><dd><p>factor: As for MASS dataset of the same name. </p>
</dd>
<dt>Temp</dt><dd><p>numeric: As for MASS dataset of the same name. </p>
</dd>
<dt>Gas</dt><dd><p>numeric: As for MASS dataset of the same name. </p>
</dd>
</dl>


<hr>
<h2 id='xy-class'>An S4 class to represent alternavive complex, matrix or list input forms.</h2><span id='topic+xy-class'></span>

<h3>Description</h3>

<p>An S4 class to represent alternavive complex, matrix or list input forms.
</p>

<hr>
<h2 id='zs'>Standardisation functions for models</h2><span id='topic+zs'></span><span id='topic+zu'></span><span id='topic+zr'></span><span id='topic+zq'></span>

<h3>Description</h3>

<p>These functions are for use in fitting linear models (or allies) with scaled
predictors, in such a way that when the fitted model objects are used for
prediction (or visualisation) the same scaling parameters will be used with
the new data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zs(x)

zu(x)

zr(x)

zq(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zs_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a standardised vector containing the parameters needed for use in prediction with new data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm &lt;- lm(Gas ~ Insul/zs(Temp), whiteside)
gm &lt;- lm(Gas ~ Insul/zu(Temp), whiteside)
hm &lt;- lm(Gas ~ Insul/Temp,     whiteside)
c(fm = unname(predict(fm, data.frame(Insul = "Before", Temp = 0.0))),
  gm = unname(predict(gm, data.frame(Insul = "Before", Temp = 0.0))),
  hm = unname(predict(hm, data.frame(Insul = "Before", Temp = 0.0))))
rm(fm, gm, hm)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
