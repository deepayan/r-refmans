<!DOCTYPE html><html lang="en"><head><title>Help for package gMCP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gMCP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#gMCP-package'>
<p>Graphical described Multiple Comparison Procedures</p></a></li>
<li><a href='#bdiagNA'><p>Create a Block Diagonal Matrix with NA outside the diagonal</p></a></li>
<li><a href='#bonferroni.test'><p>Weighted Bonferroni-test</p></a></li>
<li><a href='#bonferroni.trimmed.simes.test'><p>Trimmed Simes test for intersections of two hypotheses and otherwise weighted Bonferroni-test</p></a></li>
<li><a href='#calcPower'><p>Calculate power values</p></a></li>
<li><a href='#corMatWizard'><p>Graphical User Interface for the creation of correlation matrices</p></a></li>
<li><a href='#doInterim'><p>EXPERIMENTAL: Evaluate conditional errors at interim for a pre-planned</p>
graphical procedure</a></li>
<li><a href='#entangledMCP-class'><p>Class entangledMCP</p></a></li>
<li><a href='#exampleGraphs'><p>Functions that create different example graphs</p></a></li>
<li><a href='#extractPower'><p>Calculate power values</p></a></li>
<li><a href='#generateBounds'><p>generateBounds</p></a></li>
<li><a href='#generatePvals'><p>generatePvals</p></a></li>
<li><a href='#generateTest'><p>generateTest</p></a></li>
<li><a href='#generateWeights'><p>generateWeights</p></a></li>
<li><a href='#getJavaInfo'><p>Get Memory and Runtime Info from JVM</p></a></li>
<li><a href='#gMCP'><p>Graph based Multiple Comparison Procedures</p></a></li>
<li><a href='#gMCP.extended'><p>Graph based Multiple Comparison Procedures</p></a></li>
<li><a href='#gMCPReport'><p>Automatic Generation of gMCP Reports</p></a></li>
<li><a href='#gMCPResult-class'><p>Class gMCPResult</p></a></li>
<li><a href='#gPADInterim-class'><p>Class gPADInterim</p></a></li>
<li><a href='#graph2latex'><p>Graph2LaTeX</p></a></li>
<li><a href='#graphAnalysis'><p>Analysis of a gMCP-Graph</p></a></li>
<li><a href='#graphGUI'><p>Graphical User Interface for graphical described multiple comparison</p>
procedures</a></li>
<li><a href='#graphMCP-class'><p>Class graphMCP</p></a></li>
<li><a href='#graphTest'><p>Multiple testing using graphs</p></a></li>
<li><a href='#hydroquinone'><p>Hydroquinone Mutagenicity Assay</p></a></li>
<li><a href='#joinGraphs'><p>Joins two graphMCP objects</p></a></li>
<li><a href='#matrix2graph'><p>Matrix2Graph and Graph2Matrix</p></a></li>
<li><a href='#parametric.test'><p>Weighted parametric test</p></a></li>
<li><a href='#placeNodes'><p>Placement of graph nodes</p></a></li>
<li><a href='#plotSimCI'><p>Plot confidence intervals</p></a></li>
<li><a href='#rejectNode'><p>Rejects a node/hypothesis and updates the graph accordingly.</p></a></li>
<li><a href='#replaceVariables'><p>Replaces variables in a general graph with specified numeric values</p></a></li>
<li><a href='#rqmvnorm'><p>Random sample from the multivariate normal distribution</p></a></li>
<li><a href='#sampSize'><p>Sample size calculations</p></a></li>
<li><a href='#sampSizeCore'><p>Function for sample size calculation</p></a></li>
<li><a href='#secondStageTest'><p>EXPERIMENTAL: Construct a valid level alpha test for the second stage of an</p>
adaptive design that is based on a pre-planned graphical MCP</a></li>
<li><a href='#simConfint'>
<p>Simultaneous confidence intervals for sequentially rejective multiple test procedures</p></a></li>
<li><a href='#simes.on.subsets.test'><p>Simes on subsets, otherwise Bonferroni</p></a></li>
<li><a href='#simes.test'><p>Weighted Simes test</p></a></li>
<li><a href='#simvastatin'><p>Simvastatin and Colesevelam Treatment in Patients with Primary Hypercholesterolemia</p></a></li>
<li><a href='#subgraph'><p>Get a subgraph</p></a></li>
<li><a href='#substituteEps'><p>Substitute Epsilon</p></a></li>
<li><a href='#unitTestsGMCP'><p>Run the R unit (and optional the JUnit) test suite for gMCP</p></a></li>
<li><a href='#weighted.test.functions'><p>Weighted Test Functions for use with gMCP</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Graph Based Multiple Comparison Procedures</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8-17</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kornelius Rohmeyer &lt;rohmeyer@small-projects.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions and a graphical user interface for graphical described
    multiple test procedures.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, PolynomF, multcomp (&ge; 1.1), mvtnorm, Matrix,
CommonJavaJars (&ge; 1.1.0), rJava (&ge; 0.6-3), JavaGD, xlsxjars
(&ge; 0.6.1), stats4</td>
</tr>
<tr>
<td>Suggests:</td>
<td>RUnit, knitr, graph (&ge; 1.20), mutoss, boot, coin</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Java (&gt;= 5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/kornl/gMCP">https://github.com/kornl/gMCP</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kornl/gMCP/issues">https://github.com/kornl/gMCP/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'analysis.R' 'calcPower.R' 'graphMCP.R' 'closure.R'
'convertFromOldClassDefinition.R' 'doRUnitTests.R'
'exampleGraphs.R' 'gACT-internal.R' 'gMCP.R' 'gMCP.extended.R'
'gPAD.R' 'generateBounds.R' 'generatePvals.R' 'generateTest.R'
'generateWeights.R' 'graph2latex.R' 'graphTest.R' 'helperGUI.R'
'initJava.R' 'matrix2graph.R' 'misc.R' 'modifyGraphs.R'
'onLoad.R' 'plotCI.R' 'powerPlot.R' 'rqmvnorm.R' 'sampSize.R'
'startGUIs.R' 'subVariables.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-24 08:24:08 UTC; kornel</td>
</tr>
<tr>
<td>Author:</td>
<td>Kornelius Rohmeyer [aut, cre],
  Florian Klinglmueller [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-25 23:50:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='gMCP-package'>
Graphical described Multiple Comparison Procedures
</h2><span id='topic+gMCP-package'></span>

<h3>Description</h3>

<p>This package provides functions and graphical user interfaces 
for graphical described multiple comparison procedures.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
    Package: </td><td style="text-align: left;"> gMCP</td>
</tr>
<tr>
 <td style="text-align: left;">
    Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
    License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>The package gMCP helps with the following steps of performing a multiple test procedure:
</p>
<p>1. Creating a object of <code><a href="#topic+graphMCP">graphMCP</a></code> that represents a sequentially rejective multiple test procedure.
This can be either done directly via the <code>new</code> function or converter functions like <code><a href="#topic+matrix2graph">matrix2graph</a></code> 
at the R command line or by using a graphical user interface started with function <code><a href="#topic+graphGUI">graphGUI</a></code>.
</p>
<p>2. Calling <code><a href="#topic+gMCP">gMCP</a></code> or <code><a href="#topic+graphGUI">graphGUI</a></code>.
</p>
<p>3. Exporting the results (optional with all sequential steps) as LaTeX or Word report.
</p>


<h3>Note</h3>

<p>We use the following Java libraries:
</p>

<ul>
<li><p> Apache Commons Logging under the Apache License, Version 2.0, January 2004, <a href="https://commons.apache.org/logging/">https://commons.apache.org/logging/</a>, Copyright 2001-2007 The Apache Software Foundation 
</p>
</li>
<li><p> Apache jog4j under Apache License 2.0, <a href="https://logging.apache.org/log4j/">https://logging.apache.org/log4j/</a>, Copyright 2007 The Apache Software Foundation
</p>
</li>
<li><p> Apache Commons Lang under Apache License 2.0, <a href="https://commons.apache.org/lang/">https://commons.apache.org/lang/</a>, Copyright 2001-2011 The Apache Software Foundation
</p>
</li>
<li><p> Apache POI under Apache License 2.0, <a href="https://poi.apache.org/">https://poi.apache.org/</a>, Copyright The Apache Software Foundation
</p>
</li>
<li><p> JLaTeXMath under GPL &gt;= 2.0, <a href="https://forge.scilab.org/index.php/p/jlatexmath/">https://forge.scilab.org/index.php/p/jlatexmath/</a>, Copyright 2004-2007, 2009 Calixte, Coolsaet, Cleemput, Vermeulen and Universiteit Gent
</p>
</li>
<li><p> JRI under Lesser General Public License (LGPL) 2.1, <a href="https://www.rforge.net/rJava/">https://www.rforge.net/rJava/</a>, Copyright 2004-2007 Simon Urbanek 
</p>
</li>
<li><p> iText 2.1.4 under LGPL, <a href="https://itextpdf.com/">https://itextpdf.com/</a>, Copyright by Bruno Lowagie 
</p>
</li>
<li><p> SwingWorker under LGPL, from java.net/projects/swingworker/, Copyright (c) 2005 Sun Microsystems 
</p>
</li>
<li><p> JXLayer under BSD License, from java.net/projects/jxlayer/, Copyright 2006-2009, Alexander Potochkin 
</p>
</li>
<li><p> JGoodies Forms under BSD License, <a href="https://www.jgoodies.com/freeware/libraries/forms/">https://www.jgoodies.com/freeware/libraries/forms/</a>, Copyright JGoodies Karsten Lentzsch  
</p>
</li>
<li><p> AFCommons under BSD License, <a href="https://web.archive.org/web/20180828002833/http://www.algorithm-forge.com/afcommons/">https://web.archive.org/web/20180828002833/http://www.algorithm-forge.com/afcommons/</a>, Copyright (c) 2007-2014 by Kornelius Rohmeyer and Bernd Bischl
</p>
</li>
<li><p> JHLIR under BSD License, <a href="https://jhlir.r-forge.r-project.org/">https://jhlir.r-forge.r-project.org/</a>, Copyright (c) 2008-2014 by Bernd Bischl and Kornelius Rohmeyer
</p>
</li></ul>
 


<h3>Author(s)</h3>

<p>Kornelius Rohmeyer, 
R code for correlated tests and adaptive designs from Florian Klinglmueller.
</p>
<p>Maintainer: Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>References</h3>

<p>Frank Bretz, Martin Posch, Ekkehard Glimm, Florian Klinglmueller, Willi Maurer, Kornelius Rohmeyer (2011):
Graphical approaches for multiple comparison procedures using weighted Bonferroni, Simes or parametric tests.
Biometrical Journal 53 (6), pages 894-913, Wiley.
<a href="https://doi.org/10.1002/bimj.201000239">doi:10.1002/bimj.201000239</a>
</p>
<p>Frank Bretz, Willi Maurer, Werner Brannath, Martin Posch:
A graphical approach to sequentially rejective multiple test procedures.
Statistics in Medicine 2009 vol. 28 issue 4 page 586-604. 
<a href="https://www.meduniwien.ac.at/fwf_adaptive/papers/bretz_2009_22.pdf">https://www.meduniwien.ac.at/fwf_adaptive/papers/bretz_2009_22.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g5 &lt;- BonferroniHolm(5)
## Not run: 
graphGUI("g5")
## End(Not run)
gMCP(g5, pvalues=c(0.1,0.2,0.4,0.4,0.4))
</code></pre>

<hr>
<h2 id='bdiagNA'>Create a Block Diagonal Matrix with NA outside the diagonal</h2><span id='topic+bdiagNA'></span>

<h3>Description</h3>

<p>Build a block diagonal matrix with NA values outside the diagonal given
several building block matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdiagNA(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bdiagNA_+3A_...">...</code></td>
<td>
<p>individual matrices or a <code>list</code> of matrices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is usefull to build the correlation matrices, when only
partial knowledge of the correlation exists.
</p>


<h3>Value</h3>

<p>A block diagonal matrix with NA values outside the diagonal.
</p>


<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gMCP">gMCP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

bdiagNA(diag(3), matrix(1/2,nr=3,nc=3), diag(2))


</code></pre>

<hr>
<h2 id='bonferroni.test'>Weighted Bonferroni-test</h2><span id='topic+bonferroni.test'></span>

<h3>Description</h3>

<p>Weighted Bonferroni-test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bonferroni.test(
  pvalues,
  weights,
  alpha = 0.05,
  adjPValues = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bonferroni.test_+3A_pvalues">pvalues</code></td>
<td>
<p>A numeric vector specifying the p-values.</p>
</td></tr>
<tr><td><code id="bonferroni.test_+3A_weights">weights</code></td>
<td>
<p>A numeric vector of weights.</p>
</td></tr>
<tr><td><code id="bonferroni.test_+3A_alpha">alpha</code></td>
<td>
<p>A numeric specifying the maximal allowed type one error rate. If <code>adjPValues==TRUE</code> (default) the parameter <code>alpha</code> is not used.</p>
</td></tr>
<tr><td><code id="bonferroni.test_+3A_adjpvalues">adjPValues</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code> (the default) an adjusted p-value for the weighted Bonferroni-test is returned.
Otherwise if <code>adjPValues==FALSE</code> a logical value is returned whether the null hypothesis can be rejected.</p>
</td></tr>
<tr><td><code id="bonferroni.test_+3A_verbose">verbose</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code> verbose output is generated.</p>
</td></tr>
<tr><td><code id="bonferroni.test_+3A_...">...</code></td>
<td>
<p>Further arguments possibly passed by <code>gMCP</code> which will be used by other test procedures but not this one.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
bonferroni.test(pvalues=c(0.1,0.2,0.05), weights=c(0.5,0.5,0))
bonferroni.test(pvalues=c(0.1,0.2,0.05), weights=c(0.5,0.5,0), adjPValues=FALSE)

</code></pre>

<hr>
<h2 id='bonferroni.trimmed.simes.test'>Trimmed Simes test for intersections of two hypotheses and otherwise weighted Bonferroni-test</h2><span id='topic+bonferroni.trimmed.simes.test'></span>

<h3>Description</h3>

<p>Trimmed Simes test for intersections of two hypotheses and otherwise weighted Bonferroni-test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bonferroni.trimmed.simes.test(
  pvalues,
  weights,
  alpha = 0.05,
  adjPValues = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bonferroni.trimmed.simes.test_+3A_pvalues">pvalues</code></td>
<td>
<p>A numeric vector specifying the p-values.</p>
</td></tr>
<tr><td><code id="bonferroni.trimmed.simes.test_+3A_weights">weights</code></td>
<td>
<p>A numeric vector of weights.</p>
</td></tr>
<tr><td><code id="bonferroni.trimmed.simes.test_+3A_alpha">alpha</code></td>
<td>
<p>A numeric specifying the maximal allowed type one error rate. If <code>adjPValues==TRUE</code> (default) the parameter <code>alpha</code> is not used.</p>
</td></tr>
<tr><td><code id="bonferroni.trimmed.simes.test_+3A_adjpvalues">adjPValues</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code> (the default) an adjusted p-value for the weighted test is returned.
Otherwise if <code>adjPValues==FALSE</code> a logical value is returned whether the null hypothesis can be rejected.</p>
</td></tr>
<tr><td><code id="bonferroni.trimmed.simes.test_+3A_verbose">verbose</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code> verbose output is generated.</p>
</td></tr>
<tr><td><code id="bonferroni.trimmed.simes.test_+3A_...">...</code></td>
<td>
<p>Further arguments possibly passed by <code>gMCP</code> which will be used by other test procedures but not this one.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Brannath, W., Bretz, F., Maurer, W., &amp; Sarkar, S. (2009). 
Trimmed Weighted Simes Test for Two One-Sided Hypotheses With Arbitrarily Correlated Test Statistics. 
Biometrical Journal, 51(6), 885-898.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bonferroni.trimmed.simes.test(pvalues=c(0.1,0.2,0.05), weights=c(0.5,0.5,0))
bonferroni.trimmed.simes.test(pvalues=c(0.1,0.2,0.05), weights=c(0.5,0.5,0), adjPValues=FALSE)

</code></pre>

<hr>
<h2 id='calcPower'>Calculate power values</h2><span id='topic+calcPower'></span>

<h3>Description</h3>

<p>Given the distribution under the alternative (assumed to be multivariate
normal), this function calculates the power to reject at least one
hypothesis, the local power for the hypotheses as well as the expected
number of rejections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcPower(
  weights,
  alpha,
  G,
  mean = rep(0, nrow(corr.sim)),
  corr.sim = diag(length(mean)),
  corr.test = NULL,
  n.sim = 10000,
  type = c("quasirandom", "pseudorandom"),
  f = list(),
  upscale = FALSE,
  graph,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcPower_+3A_weights">weights</code></td>
<td>
<p>Initial weight levels for the test procedure (see graphTest
function). Alternatively a <code><a href="#topic+graphMCP">graphMCP</a></code> object can be given as parameter <code>graph</code>.</p>
</td></tr>
<tr><td><code id="calcPower_+3A_alpha">alpha</code></td>
<td>
<p>Overall alpha level of the procedure, see graphTest function.
(For entangled graphs <code>alpha</code> should be a numeric vector of length 
equal to the number of graphs, each element specifying the partial alpha 
for the respective graph.
The overall alpha level equals <code>sum(alpha)</code>.)</p>
</td></tr>
<tr><td><code id="calcPower_+3A_g">G</code></td>
<td>
<p>Matrix determining the graph underlying the test procedure. Note
that the diagonal need to contain only 0s, while the rows need to sum to 1.
When multiple graphs should be used this needs to be a list containing the
different graphs as elements. Alternatively a <code><a href="#topic+graphMCP">graphMCP</a></code> object can be given as parameter <code>graph</code>.</p>
</td></tr>
<tr><td><code id="calcPower_+3A_mean">mean</code></td>
<td>
<p>Mean under the alternative</p>
</td></tr>
<tr><td><code id="calcPower_+3A_corr.sim">corr.sim</code></td>
<td>
<p>Covariance matrix under the alternative.</p>
</td></tr>
<tr><td><code id="calcPower_+3A_corr.test">corr.test</code></td>
<td>
<p>Correlation matrix that should be used for the parametric test.
If <code>corr.test==NULL</code> the Bonferroni based test procedure is used. Can contain
NAs.</p>
</td></tr>
<tr><td><code id="calcPower_+3A_n.sim">n.sim</code></td>
<td>
<p>Monte Carlo sample size. If type = &quot;quasirandom&quot; this number is
rounded up to the next power of 2, e.g. 1000 is rounded up to
<code class="reqn">1024=2^10</code> and at least 1024.</p>
</td></tr>
<tr><td><code id="calcPower_+3A_type">type</code></td>
<td>
<p>What type of random numbers to use. <code>quasirandom</code> uses a
randomized Lattice rule, and should be more efficient than
<code>pseudorandom</code> that uses ordinary (pseudo) random numbers.</p>
</td></tr>
<tr><td><code id="calcPower_+3A_f">f</code></td>
<td>
<p>List of user defined power functions (or just a single power
function).  If one is interested in the power to reject hypotheses 1 and 3
one could specify: <br /><code>f=function(x) {x[1] &amp;&amp; x[3]}</code>.<br /> If the power
of rejecting hypotheses 1 and 2 is also of interest one would use a
(optionally named) list: <br /> 
<code>f=list(power1and3=function(x) {x[1] &amp;&amp; x[3]},</code><br />
<code>power1and2=function(x) {x[1] &amp;&amp; x[2]})</code>.
If the list has no names, the functions will be referenced 
to as &quot;func1&quot;, &quot;func2&quot;, etc. in the output.</p>
</td></tr>
<tr><td><code id="calcPower_+3A_upscale">upscale</code></td>
<td>
<p>Logical. If <code>upscale=FALSE</code> then for each intersection 
of hypotheses (i.e. each subgraph) a weighted test is performed at the 
possibly reduced level alpha of sum(w)*alpha, 
where sum(w) is the sum of all node weights in this subset.
If <code>upscale=TRUE</code> all weights are upscaled, so that sum(w)=1.</p>
</td></tr>
<tr><td><code id="calcPower_+3A_graph">graph</code></td>
<td>
<p>A graph of class <code><a href="#topic+graphMCP">graphMCP</a></code>.</p>
</td></tr>
<tr><td><code id="calcPower_+3A_...">...</code></td>
<td>
<p>For backwards compatibility. For example up to version 0.8-7
the parameters <code>corr.model</code> and <code>corr.test</code> were called <code>sigma</code>
and <code>cr</code>. Also instead of supplying a graph object one could 
supply a parameter <code>weights</code> and a transition matrix <code>G</code>.</p>
</td></tr>
<tr><td><code id="calcPower_+3A_test">test</code></td>
<td>
<p>In the parametric case there is more than one way to handle
subgraphs with less than the full alpha. If the parameter <code>test</code> is
missing, the tests are performed as described by Bretz et al. (2011), i.e.
tests of intersection null hypotheses always exhaust the full alpha level
even if the sum of weights is strictly smaller than one. If
<code>test="simple-parametric"</code> the tests are performed as defined in
Equation (3) of Bretz et al. (2011).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containg three elements
</p>

<dl>
<dt><code>LocalPower</code></dt><dd><p>A numeric giving the local powers for the hypotheses</p>
</dd>
<dt><code>ExpRejections</code></dt><dd><p>The expected number of rejections</p>
</dd>
<dt><code>PowAtlst1</code></dt><dd><p>The power to reject at least one hypothesis</p>
</dd>
</dl>



<h3>References</h3>

<p>Bretz, F., Maurer, W., Brannath, W. and Posch, M. (2009) A graphical
approach to sequentially rejective multiple test procedures. Statistics in
Medicine, 28, 586&ndash;604
</p>
<p>Bretz, F., Maurer, W. and Hommel, G. (2010) Test and power considerations
for multiple endpoint analyses using sequentially rejective graphical
procedures, to appear in Statistics in Medicine
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## reproduce example from Stat Med paper (Bretz et al. 2010, Table I)
## first only consider line 2 of Table I
## significance levels
graph &lt;- simpleSuccessiveII()
## alternative (mvn distribution)
corMat &lt;- rbind(c(1, 0.5, 0.5, 0.5/2),
                c(0.5,1,0.5/2,0.5),
                c(0.5,0.5/2,1,0.5),
                c(0.5/2,0.5,0.5,1))
theta &lt;- c(3, 0, 0, 0)
calcPower(graph=graph, alpha=0.025, mean=theta, corr.sim=corMat, n.sim= 100000)


## now reproduce all 14 simulation scenarios
## different graphs
weights1 &lt;- c(rep(1/2, 12), 1, 1)
weights2 &lt;- c(rep(1/2, 12), 0, 0)
eps &lt;- 0.01
gam1 &lt;- c(rep(0.5, 10), 1-eps, 0, 0, 0)
gam2 &lt;- gam1
## different multivariate normal alternatives
rho &lt;- c(rep(0.5, 8), 0, 0.99, rep(0.5,4))
th1 &lt;- c(0, 3, 3, 3, 2, 1, rep(3, 7), 0)
th2 &lt;- c(rep(0, 6), 3, 3, 3, 3, 0, 0, 0, 3)
th3 &lt;- c(0, 0, 3, 3, 3, 3, 0, 2, 2, 2, 3, 3, 3, 3)
th4 &lt;- c(0,0,0,3,3,3,0,2,2,2,0,0,0,0)

## function that calculates power values for one scenario
simfunc &lt;- function(nSim, a1, a2, g1, g2, rh, t1, t2, t3, t4, Gr){
  al &lt;- c(a1, a2, 0, 0)
  G &lt;- rbind(c(0, g1, 1-g1, 0), c(g2, 0, 0, 1-g2), c(0, 1, 0, 0), c(1, 0, 0, 0))
  corMat &lt;- rbind(c(1, 0.5, rh, rh/2), c(0.5,1,rh/2,rh), c(rh,rh/2,1,0.5), c(rh/2,rh,0.5,1))
  mean &lt;- c(t1, t2, t3, t4)
  calcPower(weights=al, alpha=0.025, G=G, mean=mean, corr.sim=corMat, n.sim = nSim)
}

## calculate power for all 14 scenarios
outList &lt;- list()
for(i in 1:14){
  outList[[i]] &lt;- simfunc(10000, weights1[i], weights2[i], 
                    gam1[i], gam2[i], rho[i], th1[i], th2[i], th3[i], th4[i])
}

## summarize data as in Stat Med paper Table I 
atlst1 &lt;- as.numeric(lapply(outList, function(x) x$PowAtlst1))
locpow &lt;- do.call("rbind", lapply(outList, function(x) x$LocalPower))

round(cbind(atlst1, locpow), 5)

</code></pre>

<hr>
<h2 id='corMatWizard'>Graphical User Interface for the creation of correlation matrices</h2><span id='topic+corMatWizard'></span>

<h3>Description</h3>

<p>Starts a graphical user interface for the correlation matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corMatWizard(n, matrix, names, envir = globalenv())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="corMatWizard_+3A_n">n</code></td>
<td>
<p>Square root of the dimension of the quadratic <code class="reqn">n\times n</code>-Matrix.</p>
</td></tr>
<tr><td><code id="corMatWizard_+3A_matrix">matrix</code></td>
<td>
<p>Variable name of matrix of dimension <code class="reqn">n\times n</code> to start with.</p>
</td></tr>
<tr><td><code id="corMatWizard_+3A_names">names</code></td>
<td>
<p>Row and column names. (Default will be H1,H2,...,Hn.)</p>
</td></tr>
<tr><td><code id="corMatWizard_+3A_envir">envir</code></td>
<td>
<p>Environment where the object <var>matrix</var> is located and/or it
should be saved (default is the global environment).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function itself returns NULL.  But with the dialog a symmetric
matrix of dimension <code class="reqn">n\times n</code> can be created or edited that will
be available in R under the specified variable name after saving.
</p>


<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
corMatWizard(5) # is equivalent to
corMatWizard(matrix=diag(5))
corMatWizard(names=c("H1", "H2", "H3", "E1", "E2"))
C &lt;- cor(matrix(rnorm(100),10), matrix(rnorm(100),10))
corMatWizard(matrix="C") # or
corMatWizard(matrix=C) 

## End(Not run)

</code></pre>

<hr>
<h2 id='doInterim'>EXPERIMENTAL: Evaluate conditional errors at interim for a pre-planned
graphical procedure</h2><span id='topic+doInterim'></span>

<h3>Description</h3>

<p>Computes partial conditional errors (PCE) for a pre-planned graphical
procedure given information fractions and first stage z-scores. -
Implementation of adaptive procedures is still in an early stage and may
change in the near future
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doInterim(graph, z1, v, alpha = 0.025)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="doInterim_+3A_graph">graph</code></td>
<td>
<p>A graph of class <code><a href="#topic+graphMCP">graphMCP</a></code>.</p>
</td></tr>
<tr><td><code id="doInterim_+3A_z1">z1</code></td>
<td>
<p>A numeric vector giving first stage z-scores.</p>
</td></tr>
<tr><td><code id="doInterim_+3A_v">v</code></td>
<td>
<p>A numeric vector giving the proportions of pre-planned measurements
collected up to the interim analysis. Will be recycled of length different
than the number of elementary hypotheses.</p>
</td></tr>
<tr><td><code id="doInterim_+3A_alpha">alpha</code></td>
<td>
<p>A numeric specifying the maximal allowed type one error rate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details see the given references.
</p>


<h3>Value</h3>

<p>An object of class <code>gPADInterim</code>, more specifically a list with
elements
</p>

<dl>
<dt><code>Aj</code></dt><dd><p>a matrix of PCEs for all elementary hypotheses in each
intersection hypothesis</p>
</dd>
<dt><code>BJ</code></dt><dd><p>a numeric vector giving sum of PCEs per intersection
hypothesis</p>
</dd>
<dt><code>preplanned</code></dt><dd><p>Pre planned test represented by an object of class</p>
</dd>
</dl>
<p><code><a href="#topic+graphMCP">graphMCP</a></code>

</p>


<h3>Author(s)</h3>

<p>Florian Klinglmueller <a href="mailto:float@lefant.net">float@lefant.net</a>
</p>


<h3>References</h3>

<p>Frank Bretz, Willi Maurer, Werner Brannath, Martin Posch: A
graphical approach to sequentially rejective multiple test procedures.
Statistics in Medicine 2009 vol. 28 issue 4 page 586-604.
<a href="https://www.meduniwien.ac.at/fwf_adaptive/papers/bretz_2009_22.pdf">https://www.meduniwien.ac.at/fwf_adaptive/papers/bretz_2009_22.pdf</a>
</p>
<p>Frank Bretz, Martin Posch, Ekkehard Glimm, Florian Klinglmueller, Willi
Maurer, Kornelius Rohmeyer (2011): Graphical approaches for multiple
comparison procedures using weighted Bonferroni, Simes or parametric tests.
Biometrical Journal 53 (6), pages 894-913, Wiley.
<a href="https://doi.org/10.1002/bimj.201000239">doi:10.1002/bimj.201000239</a>
</p>
<p>Posch M, Futschik A (2008): A Uniform Improvement of Bonferroni-Type Tests
by Sequential Tests JASA 103/481, 299-308
</p>
<p>Posch M, Maurer W, Bretz F (2010): Type I error rate control in adaptive
designs for confirmatory clinical trials with treatment selection at interim
Pharm Stat 10/2, 96-104
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graphMCP">graphMCP</a></code>, <code><a href="#topic+secondStageTest">secondStageTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Simple successive graph (Maurer et al. 2011)
## two treatments two hierarchically ordered endpoints
a &lt;- .025
G &lt;- simpleSuccessiveI()
## some z-scores:

p1=c(.1,.12,.21,.16)
z1 &lt;- qnorm(1-p1)
p2=c(.04,1,.14,1)
z2 &lt;- qnorm(1-p2)
v &lt;- c(1/2,1/3,1/2,1/3)

intA &lt;- doInterim(G,z1,v)

## select only the first treatment 
fTest &lt;- secondStageTest(intA,c(1,0,1,0))



</code></pre>

<hr>
<h2 id='entangledMCP-class'>Class entangledMCP</h2><span id='topic+entangledMCP-class'></span><span id='topic+entangledMCP'></span><span id='topic+print+2CentangledMCP-method'></span><span id='topic+getWeights+2CentangledMCP-method'></span><span id='topic+getMatrices'></span><span id='topic+getMatrices+2CentangledMCP-method'></span><span id='topic+getRejected+2CentangledMCP-method'></span><span id='topic+getXCoordinates+2CentangledMCP-method'></span><span id='topic+getYCoordinates+2CentangledMCP-method'></span><span id='topic+getNodes+2CentangledMCP-method'></span>

<h3>Description</h3>

<p>A entangledMCP object describes ... TODO</p>


<h3>Slots</h3>

  
    
<dl>
<dt><code>subgraphs</code>:</dt><dd><p>A list of graphs of class graphMCP.</p>
</dd>
<dt><code>weights</code>:</dt><dd><p>A numeric.</p>
</dd>
<dt><code>graphAttr</code>:</dt><dd><p>A list for graph attributes like color, etc.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>print</dt><dd><p><code>signature(object = "entangledMCP")</code>: A method for printing the data of the entangled graph to the R console.</p>
</dd>
<dt>getMatrices</dt><dd><p><code>signature(object = "entangledMCP")</code>: A method for getting the list of transition matrices of the entangled graph.</p>
</dd>
<dt>getWeights</dt><dd><p><code>signature(object = "entangledMCP")</code>: A method for getting the matrix of weights of the entangled graph.</p>
</dd>
<dt>getRejected</dt><dd><p><code>signature(object = "entangledMCP")</code>: 
A method for getting the information whether the hypotheses are marked in the graph as already rejected.
If a second optional argument <code>node</code> is specified, only for these nodes the boolean vector will be returned.</p>
</dd>
<dt>getXCoordinates</dt><dd><p><code>signature(object = "entangledMCP")</code>: 
A method for getting the x coordinates of the graph.
If a second optional argument <code>node</code> is specified, only for these nodes the x coordinates will be returned.
If x coordinates are not yet set, <code>NULL</code> is returned.</p>
</dd>
<dt>getYCoordinates</dt><dd><p><code>signature(object = "entangledMCP")</code>: 
A method for getting the y coordinates of the graph
If a second optional argument <code>node</code> is specified, only for these nodes the x coordinates will be returned.
If y coordinates are not yet set, <code>NULL</code> is returned.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+graphMCP-class">graphMCP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g1 &lt;- BonferroniHolm(2)
g2 &lt;- BonferroniHolm(2)

graph &lt;- new("entangledMCP", subgraphs=list(g1,g2), weights=c(0.5,0.5))

getMatrices(graph)
getWeights(graph)

</code></pre>

<hr>
<h2 id='exampleGraphs'>Functions that create different example graphs</h2><span id='topic+exampleGraphs'></span><span id='topic+BonferroniHolm'></span><span id='topic+BretzEtAl2011'></span><span id='topic+parallelGatekeeping'></span><span id='topic+improvedParallelGatekeeping'></span><span id='topic+HommelEtAl2007'></span><span id='topic+HommelEtAl2007Simple'></span><span id='topic+HungEtWang2010'></span><span id='topic+MaurerEtAl1995'></span><span id='topic+improvedFallbackI'></span><span id='topic+improvedFallbackII'></span><span id='topic+cycleGraph'></span><span id='topic+fixedSequence'></span><span id='topic+generalSuccessive'></span><span id='topic+simpleSuccessiveI'></span><span id='topic+simpleSuccessiveII'></span><span id='topic+truncatedHolm'></span><span id='topic+fallback'></span><span id='topic+HuqueAloshEtBhore2011'></span><span id='topic+BauerEtAl2001'></span><span id='topic+BretzEtAl2009a'></span><span id='topic+BretzEtAl2009b'></span><span id='topic+BretzEtAl2009c'></span><span id='topic+Ferber2011'></span><span id='topic+Entangled1Maurer2012'></span><span id='topic+Entangled2Maurer2012'></span><span id='topic+FerberTimeDose2011'></span><span id='topic+WangTing2014'></span>

<h3>Description</h3>

<p>Functions that creates example graphs, e.g. graphs that represents a
Bonferroni-Holm adjustment, parallel gatekeeping or special procedures from
selected papers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BonferroniHolm(n, weights = rep(1/n, n))

BretzEtAl2011()

BauerEtAl2001()

BretzEtAl2009a()

BretzEtAl2009b()

BretzEtAl2009c()

HommelEtAl2007()

HommelEtAl2007Simple()

parallelGatekeeping()

improvedParallelGatekeeping()

fallback(weights)

fixedSequence(n)

simpleSuccessiveI()

simpleSuccessiveII()

truncatedHolm(gamma)

generalSuccessive(weights = c(1/2, 1/2), gamma, delta)

HuqueAloshEtBhore2011()

HungEtWang2010(nu, tau, omega)

MaurerEtAl1995()

cycleGraph(nodes, weights)

improvedFallbackI(weights = rep(1/3, 3))

improvedFallbackII(weights = rep(1/3, 3))

FerberTimeDose2011(times, doses, w = "\\nu")

Ferber2011(w)

Entangled1Maurer2012()

Entangled2Maurer2012()

WangTing2014(nu, tau)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exampleGraphs_+3A_n">n</code></td>
<td>
<p>Number of hypotheses.</p>
</td></tr>
<tr><td><code id="exampleGraphs_+3A_weights">weights</code></td>
<td>
<p>Numeric vector of node weights.</p>
</td></tr>
<tr><td><code id="exampleGraphs_+3A_gamma">gamma</code></td>
<td>
<p>An optional number in [0,1] specifying the value for variable gamma.</p>
</td></tr>
<tr><td><code id="exampleGraphs_+3A_delta">delta</code></td>
<td>
<p>An optional number in [0,1] specifying the value for variable delta.</p>
</td></tr>
<tr><td><code id="exampleGraphs_+3A_nu">nu</code></td>
<td>
<p>An optional number in [0,1] specifying the value for variable nu.</p>
</td></tr>
<tr><td><code id="exampleGraphs_+3A_tau">tau</code></td>
<td>
<p>An optional number in [0,1] specifying the value for variable tau.</p>
</td></tr>
<tr><td><code id="exampleGraphs_+3A_omega">omega</code></td>
<td>
<p>An optional number in [0,1] specifying the value for variable omega.</p>
</td></tr>
<tr><td><code id="exampleGraphs_+3A_nodes">nodes</code></td>
<td>
<p>Character vector of node names.</p>
</td></tr>
<tr><td><code id="exampleGraphs_+3A_times">times</code></td>
<td>
<p>Number of time points.</p>
</td></tr>
<tr><td><code id="exampleGraphs_+3A_doses">doses</code></td>
<td>
<p>Number of dose levels.</p>
</td></tr>
<tr><td><code id="exampleGraphs_+3A_w">w</code></td>
<td>
<p>Further variable weight(s) in graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We are providing functions and not the resulting graphs directly because
this way you have additional examples: You can look at the function body
with <code><a href="base.html#topic+body">body</a></code> and see how the graph is built.
</p>
 <dl>
<dt>list(&quot;BonferroniHolm&quot;)</dt><dd><p> Returns a graph that represents a
Bonferroni-Holm adjustment.  The result is a complete graph, where all nodes
have the same weights and each edge weight is <code class="reqn">\frac{1}{n-1}</code>.
</p>
</dd> <dt>list(&quot;BretzEtAl2011&quot;)</dt><dd><p> Graph in figure 2 from Bretz et al. See
references (Bretz et al. 2011).  </p>
</dd> <dt>list(&quot;HommelEtAl2007&quot;)</dt><dd><p> Graph from
Hommel et al. See references (Hommel et al. 2007).  </p>
</dd>
<dt>list(&quot;parallelGatekeeping&quot;)</dt><dd><p> Graph for parallel gatekeeping. See
references (Dmitrienko et al. 2003).  </p>
</dd>
<dt>list(&quot;improvedParallelGatekeeping&quot;)</dt><dd><p> Graph for improved parallel
gatekeeping. See references (Hommel et al. 2007).  </p>
</dd>
<dt>list(&quot;HungEtWang2010&quot;)</dt><dd><p> Graph from Hung et Wang. See references (Hung
et Wang 2010).  </p>
</dd> <dt>list(&quot;MaurerEtAl1995&quot;)</dt><dd><p> Graph from Maurer et al.
See references (Maurer et al. 1995).  </p>
</dd> <dt>list(&quot;cycleGraph&quot;)</dt><dd><p> Cycle
graph. The weight <code>weights[i]</code> specifies the edge weight from node
<code class="reqn">i</code> to node <code class="reqn">i+1</code> for <code class="reqn">i=1,\ldots,n-1</code> and
<code>weight[n]</code> from node <code class="reqn">n</code> to node 1.  </p>
</dd>
<dt>list(&quot;improvedFallbackI&quot;)</dt><dd><p> Graph for the improved Fallback Procedure
by Wiens &amp; Dmitrienko. See references (Wiens et Dmitrienko 2005).  </p>
</dd>
<dt>list(&quot;improvedFallbackII&quot;)</dt><dd><p> Graph for the improved Fallback Procedure
by Hommel &amp; Bretz. See references (Hommel et Bretz 2008).  </p>
</dd>
<dt>list(&quot;Ferber2011&quot;)</dt><dd><p> Graph from Ferber et al. See references (Ferber
et al. 2011).  </p>
</dd> <dt>list(&quot;FerberTimeDose2011&quot;)</dt><dd><p> Graph from Ferber et al.
See references (Ferber et al. 2011).  </p>
</dd> <dt>list(&quot;Entangled1Maurer2012&quot;)</dt><dd>
<p>Entangled graph from Maurer et al. TODO: Add references as soon as they are
available.  </p>
</dd> </dl>



<h3>Value</h3>

<p>A graph of class <code><a href="#topic+graphMCP">graphMCP</a></code> that represents a
sequentially rejective multiple test procedure.
</p>


<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>References</h3>

<p>Holm, S. (1979). A simple sequentally rejective multiple test
procedure. Scandinavian Journal of Statistics 6, 65-70.
</p>
<p>Dmitrienko, A., Offen, W., Westfall, P.H. (2003). Gatekeeping strategies for
clinical trials that do not require all primary effects to be significant.
Statistics in Medicine. 22, 2387-2400.
</p>
<p>Bretz, F., Maurer, W., Brannath, W., Posch, M.: A graphical approach to
sequentially rejective multiple test procedures. Statistics in Medicine 2009
vol. 28 issue 4 page 586-604.
<a href="https://www.meduniwien.ac.at/fwf_adaptive/papers/bretz_2009_22.pdf">https://www.meduniwien.ac.at/fwf_adaptive/papers/bretz_2009_22.pdf</a>
</p>
<p>Bretz, F., Maurer, W. and Hommel, G. (2011), Test and power considerations
for multiple endpoint analyses using sequentially rejective graphical
procedures. Statistics in Medicine, 30: 1489&ndash;1501.
</p>
<p>Hommel, G., Bretz, F. und Maurer, W. (2007). Powerful short-cuts for
multiple testing procedures with special reference to gatekeeping
strategies. Statistics in Medicine, 26(22), 4063-4073.
</p>
<p>Hommel, G., Bretz, F. (2008): Aesthetics and power considerations in
multiple testing - a contradiction? Biometrical Journal 50:657-666.
</p>
<p>Hung H.M.J., Wang S.-J. (2010). Challenges to multiple testing in clinical
trials. Biometrical Journal 52, 747-756.
</p>
<p>W. Maurer, L. Hothorn, W. Lehmacher: Multiple comparisons in drug clinical
trials and preclinical assays: a-priori ordered hypotheses. In Biometrie in
der chemisch-pharmazeutischen Industrie, Vollmar J (ed.). Fischer Verlag:
Stuttgart, 1995; 3-18.
</p>
<p>Maurer, W., &amp; Bretz, F. (2013). Memory and other properties of multiple test 
procedures generated by entangled graphs. Statistics in medicine, 32 (10), 1739-1753.
</p>
<p>Wiens, B.L., Dmitrienko, A. (2005): The fallback procedure for evaluating a
single family of hypotheses. Journal of Biopharmaceutical Statistics
15:929-942.
</p>
<p>Wang, B., Ting, N. (2014). An Application of Graphical Approach to 
Construct Multiple Testing Procedures in a Hypothetical Phase III Design. 
Frontiers in public health, 1 (75).
</p>
<p>Ferber, G. Staner, L. and Boeijinga, P. (2011): Structured multiplicity and
confirmatory statistical analyses in pharmacodynamic studies using the
quantitative electroencephalogram, Journal of neuroscience methods, Volume
201, Issue 1, Pages 204-212.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- BonferroniHolm(5)

gMCP(g, pvalues=c(0.1, 0.2, 0.4, 0.4, 0.7))

HungEtWang2010()
HungEtWang2010(nu=1)

</code></pre>

<hr>
<h2 id='extractPower'>Calculate power values</h2><span id='topic+extractPower'></span>

<h3>Description</h3>

<p>Calculates local power values, expected number of rejections, the power to
reject at least one hypothesis and the power to reject all hypotheses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractPower(x, f = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractPower_+3A_x">x</code></td>
<td>
<p>A matrix containing the rejected hypothesis, as produces by the
graphTest function.</p>
</td></tr>
<tr><td><code id="extractPower_+3A_f">f</code></td>
<td>
<p>List of user defined power functions. If one is interested in the
power to reject hypotheses 1 and 3 one could specify <code>function(x) {x[1]
&amp;&amp; x[3]}</code>. If f is a named list, the result will contain corresponding items 
with the same names (among the default elements described in the following).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containg at least the following four elements and
an element for each element in the parameter <code>f</code>.
</p>

<dl>
<dt><code>LocPower</code></dt><dd><p>A numeric giving the local powers for the hypotheses</p>
</dd>
<dt><code>ExpNrRej</code></dt><dd><p>The expected number of rejections</p>
</dd>
<dt><code>PowAtlst1</code></dt><dd><p>The power to reject at least one hypothesis</p>
</dd>
<dt><code>RejectAll</code></dt><dd><p>The power to reject all hypotheses</p>
</dd>
</dl>


<hr>
<h2 id='generateBounds'>generateBounds</h2><span id='topic+generateBounds'></span>

<h3>Description</h3>

<p>compute rejection bounds for z-scores of each elementary hypotheses within
each intersection hypotheses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateBounds(
  g,
  w,
  cr,
  al = 0.05,
  hint = generateWeights(g, w),
  upscale = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generateBounds_+3A_g">g</code></td>
<td>
<p>graph defined as a matrix, each element defines how much of the
local alpha reserved for the hypothesis corresponding to its row index is
passed on to the hypothesis corresponding to its column index</p>
</td></tr>
<tr><td><code id="generateBounds_+3A_w">w</code></td>
<td>
<p>vector of weights, defines how much of the overall alpha is
initially reserved for each elementary hypothesis</p>
</td></tr>
<tr><td><code id="generateBounds_+3A_cr">cr</code></td>
<td>
<p>correlation matrix if p-values arise from one-sided tests with
multivariate normal distributed test statistics for which the correlation is
partially known. Unknown values can be set to NA. (See details for more
information)</p>
</td></tr>
<tr><td><code id="generateBounds_+3A_al">al</code></td>
<td>
<p>overall alpha level at which the family error is controlled</p>
</td></tr>
<tr><td><code id="generateBounds_+3A_hint">hint</code></td>
<td>
<p>if intersection hypotheses weights have already been computed
(output of <code><a href="#topic+generateWeights">generateWeights</a></code>) can be passed here otherwise will
be computed during execution</p>
</td></tr>
<tr><td><code id="generateBounds_+3A_upscale">upscale</code></td>
<td>
<p>if <code>FALSE</code> (default) the parametric test is performed at
the reduced level alpha of sum(w)*alpha. (See details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is assumed that under the global null hypothesis
<code class="reqn">(\Phi^{-1}(1-p_1),...,\Phi^{-1}(1-p_m))</code> follow a multivariate normal
distribution with correlation matrix <code>cr</code> where <code class="reqn">\Phi^{-1}</code> denotes
the inverse of the standard normal distribution function.
</p>
<p>For example, this is the case if <code class="reqn">p_1,..., p_m</code> are the raw p-values
from one-sided z-tests for each of the elementary hypotheses where the
correlation between z-test statistics is generated by an overlap in the
observations (e.g. comparison with a common control, group-sequential
analyses etc.). An application of the transformation <code class="reqn">\Phi^{-1}(1-p_i)</code>
to raw p-values from a two-sided test will not in general lead to a
multivariate normal distribution. Partial knowledge of the correlation
matrix is supported. The correlation matrix has to be passed as a numeric
matrix with elements of the form: <code class="reqn">correlation[i,i] = 1</code> for diagonal
elements, <code class="reqn">correlation[i,j] = \rho_{ij}</code>, where <code class="reqn">\rho_{ij}</code> is the
known value of the correlation between <code class="reqn">\Phi^{-1}(1-p_i)</code> and
<code class="reqn">\Phi^{-1}(1-p_j)</code> or <code>NA</code> if the corresponding correlation is
unknown. For example correlation[1,2]=0 indicates that the first and second
test statistic are uncorrelated, whereas correlation[2,3] = NA means that
the true correlation between statistics two and three is unknown and may
take values between -1 and 1. The correlation has to be specified for
complete blocks (ie.: if cor(i,j), and cor(i,k) for i!=j!=k are specified
then cor(j,k) has to be specified as well) otherwise the corresponding
intersection null hypotheses tests are not uniquely defined and an error is
returned.
</p>
<p>The parametric tests in (Bretz et al. (2011)) are defined such that the
tests of intersection null hypotheses always exhaust the full alpha level
even if the sum of weights is strictly smaller than one. This has the
consequence that certain test procedures that do not test each intersection
null hypothesis at the full level alpha may not be implemented (e.g., a
single step Dunnett test). If <code>upscale</code> is set to <code>FALSE</code>
(default) the parametric tests are performed at a reduced level alpha of
sum(w) * alpha and p-values adjusted accordingly such that test procedures
with non-exhaustive weighting strategies may be implemented. If set to
<code>TRUE</code> the tests are performed as defined in Equation (3) of (Bretz et
al. (2011)).
</p>


<h3>Value</h3>

<p>Returns a matrix of rejection bounds. Each row corresponds to an
intersection hypothesis. The intersection corresponding to each line is
given by conversion of the line number into binary (eg. 13 is binary 1101
and corresponds to (H1,H2,H4))
</p>


<h3>Author(s)</h3>

<p>Florian Klinglmueller
</p>


<h3>References</h3>

<p>Bretz F, Maurer W, Brannath W, Posch M; (2008) - A graphical
approach to sequentially rejective multiple testing procedures. - Stat Med -
28/4, 586-604
</p>
<p>Frank Bretz, Martin Posch, Ekkehard Glimm, Florian Klinglmueller, Willi
Maurer, Kornelius Rohmeyer (2011): Graphical approaches for multiple
comparison procedures using weighted Bonferroni, Simes or parametric tests.
Biometrical Journal 53 (6), pages 894-913, Wiley.
<a href="https://doi.org/10.1002/bimj.201000239">doi:10.1002/bimj.201000239</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Define some graph as matrix
 g &lt;- matrix(c(0,0,1,0,
               0,0,0,1,
               0,1,0,0,
               1,0,0,0), nrow = 4,byrow=TRUE)
 ## Choose weights
 w &lt;- c(.5,.5,0,0)
 ## Some correlation (upper and lower first diagonal 1/2)
 c &lt;- diag(4)
 c[1:2,3:4] &lt;- NA
 c[3:4,1:2] &lt;- NA
 c[1,2] &lt;- 1/2
 c[2,1] &lt;- 1/2
 c[3,4] &lt;- 1/2
 c[4,3] &lt;- 1/2

 ## Boundaries for correlated test statistics at alpha level .05:
 generateBounds(g,w,c,.05)

</code></pre>

<hr>
<h2 id='generatePvals'>generatePvals</h2><span id='topic+generatePvals'></span>

<h3>Description</h3>

<p>compute adjusted p-values either for the closed test defined by the graph or
for each elementary hypotheses within each intersection hypotheses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generatePvals(
  g,
  w,
  cr,
  p,
  adjusted = TRUE,
  hint = generateWeights(g, w),
  upscale = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generatePvals_+3A_g">g</code></td>
<td>
<p>graph defined as a matrix, each element defines how much of the
local alpha reserved for the hypothesis corresponding to its row index is
passed on to the hypothesis corresponding to its column index</p>
</td></tr>
<tr><td><code id="generatePvals_+3A_w">w</code></td>
<td>
<p>vector of weights, defines how much of the overall alpha is
initially reserved for each elementary hypothesis</p>
</td></tr>
<tr><td><code id="generatePvals_+3A_cr">cr</code></td>
<td>
<p>correlation matrix if p-values arise from one-sided tests with
multivariate normal distributed test statistics for which the correlation is
partially known. Unknown values can be set to NA. (See details for more
information)</p>
</td></tr>
<tr><td><code id="generatePvals_+3A_p">p</code></td>
<td>
<p>vector of observed unadjusted p-values, that belong to
test-statistics with a joint multivariate normal null distribution with
(partially) known correlation matrix <code>cr</code></p>
</td></tr>
<tr><td><code id="generatePvals_+3A_adjusted">adjusted</code></td>
<td>
<p>logical, if TRUE (default) adjusted p-values for the closed
test are returned, else a matrix of p-values adjusted only for each
intersection hypothesis is returned</p>
</td></tr>
<tr><td><code id="generatePvals_+3A_hint">hint</code></td>
<td>
<p>if intersection hypotheses weights have already been computed
(output of <code><a href="#topic+generateWeights">generateWeights</a></code>) can be passed here otherwise will
be computed during execution</p>
</td></tr>
<tr><td><code id="generatePvals_+3A_upscale">upscale</code></td>
<td>
<p>if <code>FALSE</code> (default) the p-values are additionally
adjusted for the case that non-exhaustive weights are specified. (See
details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is assumed that under the global null hypothesis
<code class="reqn">(\Phi^{-1}(1-p_1),...,\Phi^{-1}(1-p_m))</code> follow a multivariate normal
distribution with correlation matrix <code>cr</code> where <code class="reqn">\Phi^{-1}</code> denotes
the inverse of the standard normal distribution function.
</p>
<p>For example, this is the case if <code class="reqn">p_1,..., p_m</code> are the raw p-values
from one-sided z-tests for each of the elementary hypotheses where the
correlation between z-test statistics is generated by an overlap in the
observations (e.g. comparison with a common control, group-sequential
analyses etc.). An application of the transformation <code class="reqn">\Phi^{-1}(1-p_i)</code>
to raw p-values from a two-sided test will not in general lead to a
multivariate normal distribution. Partial knowledge of the correlation
matrix is supported. The correlation matrix has to be passed as a numeric
matrix with elements of the form: <code class="reqn">cr[i,i] = 1</code> for diagonal elements,
<code class="reqn">cr[i,j] = \rho_{ij}</code>, where <code class="reqn">\rho_{ij}</code> is the known value of the
correlation between <code class="reqn">\Phi^{-1}(1-p_i)</code> and <code class="reqn">\Phi^{-1}(1-p_j)</code> or
<code>NA</code> if the corresponding correlation is unknown. For example cr[1,2]=0
indicates that the first and second test statistic are uncorrelated, whereas
cr[2,3] = NA means that the true correlation between statistics two and
three is unknown and may take values between -1 and 1. The correlation has
to be specified for complete blocks (ie.: if cor(i,j), and cor(i,k) for
i!=j!=k are specified then cor(j,k) has to be specified as well) otherwise
the corresponding intersection null hypotheses tests are not uniquely
defined and an error is returned.
</p>
<p>The parametric tests in (Bretz et al. (2011)) are defined such that the
tests of intersection null hypotheses always exhaust the full alpha level
even if the sum of weights is strictly smaller than one. This has the
consequence that certain test procedures that do not test each intersection
null hypothesis at the full level alpha may not be implemented (e.g., a
single step Dunnett test). If <code>upscale</code> is set to <code>FALSE</code>
(default) the parametric tests are performed at a reduced level alpha of
sum(w) * alpha and p-values adjusted accordingly such that test procedures
with non-exhaustive weighting strategies may be implemented. If set to
<code>TRUE</code> the tests are performed as defined in Equation (3) of (Bretz et
al. (2011)).
</p>


<h3>Value</h3>

<p>If adjusted is set to true returns a vector of adjusted p-values.
Any elementary null hypothesis is rejected if its corresponding adjusted
p-value is below the predetermined alpha level. For adjusted set to false a
matrix with p-values adjusted only within each intersection hypotheses is
returned.  The intersection corresponding to each line is given by
conversion of the line number into binary (eg. 13 is binary 1101 and
corresponds to (H1,H2,H4)). If any adjusted p-value within a given line
falls below alpha, then the corresponding intersection hypotheses can be
rejected.
</p>


<h3>Author(s)</h3>

<p>Florian Klinglmueller
</p>


<h3>References</h3>

<p>Bretz F, Maurer W, Brannath W, Posch M; (2008) - A graphical
approach to sequentially rejective multiple testing procedures. - Stat Med -
28/4, 586-604 Bretz F, Posch M, Glimm E, Klinglmueller F, Maurer W, Rohmeyer
K; (2011) - Graphical approaches for multiple endpoint problems using
weighted Bonferroni, Simes or parametric tests - to appear
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Define some graph as matrix
g &lt;- matrix(c(0,0,1,0, 0,0,0,1, 0,1,0,0, 1,0,0,0), nrow = 4, byrow=TRUE)
## Choose weights
w &lt;- c(.5,.5,0,0)
## Some correlation (upper and lower first diagonal 1/2)
c &lt;- diag(4)
c[1:2,3:4] &lt;- NA
c[3:4,1:2] &lt;- NA
c[1,2] &lt;- 1/2
c[2,1] &lt;- 1/2
c[3,4] &lt;- 1/2
c[4,3] &lt;- 1/2
## p-values as Section 3 of Bretz et al. (2011),
p &lt;- c(0.0121,0.0337,0.0084,0.0160)

## Boundaries for correlated test statistics at alpha level .05:
generatePvals(g,w,c,p)

g &lt;- Entangled2Maurer2012()
generatePvals(g=g, cr=diag(5), p=rep(0.1,5))

</code></pre>

<hr>
<h2 id='generateTest'>generateTest</h2><span id='topic+generateTest'></span>

<h3>Description</h3>

<p>generates a test function for the multiple comparison procedure with
correlated test statistics defined by a graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateTest(g, w, cr, al, upscale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generateTest_+3A_g">g</code></td>
<td>
<p>graph defined as a matrix, each element defines how much of the
local alpha reserved for the hypothesis corresponding to its row index is
passed on to the hypothesis corresponding to its column index</p>
</td></tr>
<tr><td><code id="generateTest_+3A_w">w</code></td>
<td>
<p>vector of weights, defines how much of the overall alpha is
initially reserved for each elementary hypothesis</p>
</td></tr>
<tr><td><code id="generateTest_+3A_cr">cr</code></td>
<td>
<p>correlation matrix if p-values arise from one-sided tests with
multivariate normal distributed test statistics for which the correlation is
partially known. Unknown values can be set to NA. (See details for more
information)</p>
</td></tr>
<tr><td><code id="generateTest_+3A_al">al</code></td>
<td>
<p>overall alpha level at which the family error is controlled</p>
</td></tr>
<tr><td><code id="generateTest_+3A_upscale">upscale</code></td>
<td>
<p>if <code>FALSE</code> (default) the parametric tests are performed 
at a reduced level alpha of sum(w) * alpha. (See details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is assumed that under the global null hypothesis
<code class="reqn">(\Phi^{-1}(1-p_1),...,\Phi^{-1}(1-p_m))</code> follow a multivariate normal
distribution with correlation matrix <code>cr</code> where <code class="reqn">\Phi^{-1}</code> denotes
the inverse of the standard normal distribution function.
</p>
<p>For example, this is the case if <code class="reqn">p_1,..., p_m</code> are the raw p-values
from one-sided z-tests for each of the elementary hypotheses where the
correlation between z-test statistics is generated by an overlap in the
observations (e.g. comparison with a common control, group-sequential
analyses etc.). An application of the transformation <code class="reqn">\Phi^{-1}(1-p_i)</code>
to raw p-values from a two-sided test will not in general lead to a
multivariate normal distribution. Partial knowledge of the correlation
matrix is supported. The correlation matrix has to be passed as a numeric
matrix with elements of the form: <code class="reqn">cr[i,i] = 1</code> for diagonal elements,
<code class="reqn">cr[i,j] = \rho_{ij}</code>, where <code class="reqn">\rho_{ij}</code> is the known value of the
correlation between <code class="reqn">\Phi^{-1}(1-p_i)</code> and <code class="reqn">\Phi^{-1}(1-p_j)</code> or
<code>NA</code> if the corresponding correlation is unknown. For example cr[1,2]=0
indicates that the first and second test statistic are uncorrelated, whereas
cr[2,3] = NA means that the true correlation between statistics two and
three is unknown and may take values between -1 and 1. The correlation has
to be specified for complete blocks (ie.: if cor(i,j), and cor(i,k) for
i!=j!=k are specified then cor(j,k) has to be specified as well) otherwise
the corresponding intersection null hypotheses tests are not uniquely
defined and an error is returned.
</p>
<p>The parametric tests in (Bretz et al. (2011)) are defined such that the
tests of intersection null hypotheses always upscale the full alpha level
even if the sum of weights is strictly smaller than one. This has the
consequence that certain test procedures that do not test each intersection
null hypothesis at the full level alpha may not be implemented (e.g., a
single step Dunnett test). If <code>upscale</code> is set to <code>FALSE</code>
(default) the parametric tests are performed at a reduced level alpha of
sum(w) * alpha. If set to
<code>TRUE</code> the tests are performed as defined in Equation (3) of (Bretz et
al. (2011)).
</p>


<h3>Value</h3>

<p>Returns a function that will take a vector of z-scores to which the
test will be applied. This function in turn will return a boolean vector
with elements false if the particular elementary hypothesis can not be
rejected and true otherwise.
</p>


<h3>Author(s)</h3>

<p>Florian Klinglmueller
</p>


<h3>References</h3>

<p>Bretz F, Maurer W, Brannath W, Posch M; (2008) - A graphical
approach to sequentially rejective multiple testing procedures. - Stat Med -
28/4, 586-604 Bretz F, Posch M, Glimm E, Klinglmueller F, Maurer W, Rohmeyer
K; (2011) - Graphical approaches for multiple endpoint problems using
weighted Bonferroni, Simes or parametric tests - to appear
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Define some graph as matrix
 g &lt;- matrix(c(0,0,1,0,
               0,0,0,1,
               0,1,0,0,
               1,0,0,0), nrow = 4,byrow=TRUE)
 ## Choose weights
 w &lt;- c(.5,.5,0,0)
 ## Some correlation (upper and lower first diagonal 1/2)
 c &lt;- diag(4)
 c[1:2,3:4] &lt;- NA
 c[3:4,1:2] &lt;- NA
 c[1,2] &lt;- 1/2
 c[2,1] &lt;- 1/2
 c[3,4] &lt;- 1/2
 c[4,3] &lt;- 1/2

 ## Test function for further use:
 myTest &lt;- generateTest(g,w,c,.05)
 myTest(c(3,2,1,2))

</code></pre>

<hr>
<h2 id='generateWeights'>generateWeights</h2><span id='topic+generateWeights'></span>

<h3>Description</h3>

<p>compute Weights for each intersection Hypotheses in the closure of a graph
based multiple testing procedure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateWeights(g, w)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generateWeights_+3A_g">g</code></td>
<td>
<p>Graph either defined as a matrix (each element defines how much of the
local alpha reserved for the hypothesis corresponding to its row index is
passed on to the hypothesis corresponding to its column index), as <code>graphMCP</code>
object or as <code>entangledMCP</code> object.</p>
</td></tr>
<tr><td><code id="generateWeights_+3A_w">w</code></td>
<td>
<p>Vector of weights, defines how much of the overall alpha is
initially reserved for each elementary hypthosis. Can be missing if <code>g</code>
is a <code>graphMCP</code> object (in which case the weights from the graph object are used).
Will be ignored if <code>g</code> is an <code>entangledMCP</code> object (since then the matrix
of weights from this object is used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns matrix with each row corresponding to one intersection
hypothesis in the closure of the multiple testing problem. The first half of
elements indicate whether an elementary hypotheses is in the intersection
(1) or not (0). The second half of each row gives the weights allocated to
each elementary hypotheses in the intersection.
</p>


<h3>Author(s)</h3>

<p>Florian Klinglmueller &lt;float@lefant.net&gt;, Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>References</h3>

<p>Bretz F, Maurer W, Brannath W, Posch M; (2008) - A graphical
approach to sequentially rejective multiple testing procedures. - Stat Med -
28/4, 586-604 Bretz F, Posch M, Glimm E, Klinglmueller F, Maurer W, Rohmeyer
K; (2011) - Graphical approaches for multiple endpoint problems using
weighted Bonferroni, Simes or parametric tests - to appear
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 g &lt;- matrix(c(0,0,1,0,
               0,0,0,1,
               0,1,0,0,
               1,0,0,0), nrow = 4,byrow=TRUE)
 ## Choose weights
 w &lt;- c(.5,.5,0,0)
 ## Weights of conventional gMCP test:
 generateWeights(g,w)
 
g &lt;- Entangled2Maurer2012()
generateWeights(g)

</code></pre>

<hr>
<h2 id='getJavaInfo'>Get Memory and Runtime Info from JVM</h2><span id='topic+getJavaInfo'></span>

<h3>Description</h3>

<p>Get Memory and Runtime Info from JVM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getJavaInfo(memory = TRUE, filesystem = TRUE, runtime = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getJavaInfo_+3A_memory">memory</code></td>
<td>
<p>Logical whether to include memory information + number of available cores</p>
</td></tr>
<tr><td><code id="getJavaInfo_+3A_filesystem">filesystem</code></td>
<td>
<p>Logical whether to include filesystem information (Total, free and usable space)</p>
</td></tr>
<tr><td><code id="getJavaInfo_+3A_runtime">runtime</code></td>
<td>
<p>Logical whether to include runtime information (Class Path, Library Path, Input Arguments)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of length 1 containing the memory and runtime info.
</p>


<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
cat(getJavaInfo())

## End(Not run)

</code></pre>

<hr>
<h2 id='gMCP'>Graph based Multiple Comparison Procedures</h2><span id='topic+gMCP'></span>

<h3>Description</h3>

<p>Performs a graph based multiple test procedure for a given graph and
unadjusted p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gMCP(
  graph,
  pvalues,
  test,
  correlation,
  alpha = 0.05,
  approxEps = TRUE,
  eps = 10^(-3),
  ...,
  upscale = ifelse(missing(test) &amp;&amp; !missing(correlation) || !missing(test) &amp;&amp; test ==
    "Bretz2011", TRUE, FALSE),
  useC = FALSE,
  verbose = FALSE,
  keepWeights = FALSE,
  adjPValues = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gMCP_+3A_graph">graph</code></td>
<td>
<p>A graph of class <code><a href="#topic+graphMCP">graphMCP</a></code>.</p>
</td></tr>
<tr><td><code id="gMCP_+3A_pvalues">pvalues</code></td>
<td>
<p>A numeric vector specifying the p-values for the graph based
MCP. Note the assumptions in the details section for the parametric tests, 
when a correlation is specified.</p>
</td></tr>
<tr><td><code id="gMCP_+3A_test">test</code></td>
<td>
<p>Should be either <code>"Bonferroni"</code>, <code>"Simes"</code> or <code>"parametric"</code>.
If not specified by default the Bonferroni-based test procedure is used if no
correlation is specified or the algorithm from Bretz et al. 2011 if a
correlation is specified. If <code>test</code> is set to <code>"Simes"</code> the weighted
Simes test will be performed for each subset of hypotheses.</p>
</td></tr>
<tr><td><code id="gMCP_+3A_correlation">correlation</code></td>
<td>
<p>Optional correlation matrix.  If the weighted Simes test
is performed, it is checked whether type I error rate can be ensured and a
warning is given if this is not the case.  For parametric tests the p-values
must arise from one-sided tests with multivariate normal distributed test
statistics for which the correlation is (partially) known. In that case a
weighted parametric closed test is performed (also see
<code><a href="#topic+generatePvals">generatePvals</a></code>). Unknown values can be set to NA. (See details
for more information)</p>
</td></tr>
<tr><td><code id="gMCP_+3A_alpha">alpha</code></td>
<td>
<p>A numeric specifying the maximal allowed type one error rate.</p>
</td></tr>
<tr><td><code id="gMCP_+3A_approxeps">approxEps</code></td>
<td>
<p>A boolean specifying whether epsilon values should be
substituted with the value given in the parameter <code>eps</code>.</p>
</td></tr>
<tr><td><code id="gMCP_+3A_eps">eps</code></td>
<td>
<p>A numeric scalar specifying a value for epsilon edges.</p>
</td></tr>
<tr><td><code id="gMCP_+3A_...">...</code></td>
<td>
<p>Test specific arguments can be given here.</p>
</td></tr>
<tr><td><code id="gMCP_+3A_upscale">upscale</code></td>
<td>
<p>Logical. If <code>upscale=FALSE</code> then for each intersection 
of hypotheses (i.e. each subgraph) a weighted test is performed at the 
possibly reduced level alpha of sum(w)*alpha, 
where sum(w) is the sum of all node weights in this subset.
If <code>upscale=TRUE</code> all weights are upscaled, so that sum(w)=1.
</p>
<p>For backward comptibility the default value is TRUE if a the parameter <code>test</code>
is missing, but parameter <code>correlation</code> is specified or if <code>test=="Bretz2011"</code>.</p>
</td></tr>
<tr><td><code id="gMCP_+3A_usec">useC</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code> neither adjusted p-values nor
intermediate graphs are returned, but the calculation is sped up by using
code written in C. THIS CODE IS NOT FOR PRODUCTIVE USE YET!  If approxEps is
<code>FALSE</code> and the graph contains epsilon edges, a warning is thrown and
<code>useC</code> will be ignored.</p>
</td></tr>
<tr><td><code id="gMCP_+3A_verbose">verbose</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code> verbose output is generated.</p>
</td></tr>
<tr><td><code id="gMCP_+3A_keepweights">keepWeights</code></td>
<td>
<p>Logical scalar. If <code>FALSE</code> the weight of a node
without outgoing edges is set to 0 if it is removed.  Otherwise it keeps its
weight.</p>
</td></tr>
<tr><td><code id="gMCP_+3A_adjpvalues">adjPValues</code></td>
<td>
<p>Logical scalar. If <code>FALSE</code> no adjusted p-values will
be calculated.  Especially for the weighted Simes test this will result in
significantly less calculations in most cases.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the Bonferroni procedure the p-values can arise from any statistical
test, but if you improve the test by specifying a correlation matrix, the
following assumptions apply:
</p>
<p>It is assumed that under the global null hypothesis
<code class="reqn">(\Phi^{-1}(1-p_1),...,\Phi^{-1}(1-p_m))</code> follow a multivariate normal
distribution with correlation matrix <code>correlation</code> where
<code class="reqn">\Phi^{-1}</code> denotes the inverse of the standard normal distribution
function.
</p>
<p>For example, this is the case if <code class="reqn">p_1,..., p_m</code> are the raw p-values
from one-sided z-tests for each of the elementary hypotheses where the
correlation between z-test statistics is generated by an overlap in the
observations (e.g. comparison with a common control, group-sequential
analyses etc.). An application of the transformation <code class="reqn">\Phi^{-1}(1-p_i)</code>
to raw p-values from a two-sided test will not in general lead to a
multivariate normal distribution. Partial knowledge of the correlation
matrix is supported. The correlation matrix has to be passed as a numeric
matrix with elements of the form: <code class="reqn">correlation[i,i] = 1</code> for diagonal
elements, <code class="reqn">correlation[i,j] = \rho_{ij}</code>, where <code class="reqn">\rho_{ij}</code> is the
known value of the correlation between <code class="reqn">\Phi^{-1}(1-p_i)</code> and
<code class="reqn">\Phi^{-1}(1-p_j)</code> or <code>NA</code> if the corresponding correlation is
unknown. For example correlation[1,2]=0 indicates that the first and second
test statistic are uncorrelated, whereas correlation[2,3] = NA means that
the true correlation between statistics two and three is unknown and may
take values between -1 and 1. The correlation has to be specified for
complete blocks (ie.: if cor(i,j), and cor(i,j') for i!=j!=j' are specified
then cor(j,j') has to be specified as well) otherwise the corresponding
intersection null hypotheses tests are not uniquely defined and an error is
returned.
</p>
<p>For further details see the given references.
</p>


<h3>Value</h3>

<p>An object of class <code>gMCPResult</code>, more specifically a list with
elements
</p>

<dl>
<dt><code>graphs</code></dt><dd><p>list of graphs</p>
</dd>
<dt><code>pvalues</code></dt><dd><p>p-values</p>
</dd>
<dt><code>rejected</code></dt><dd><p>logical whether hyptheses could be rejected</p>
</dd>
<dt><code>adjPValues</code></dt><dd><p>adjusted p-values</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>References</h3>

<p>Frank Bretz, Willi Maurer, Werner Brannath, Martin Posch: A
graphical approach to sequentially rejective multiple test procedures.
Statistics in Medicine 2009 vol. 28 issue 4 page 586-604.
<a href="https://www.meduniwien.ac.at/fwf_adaptive/papers/bretz_2009_22.pdf">https://www.meduniwien.ac.at/fwf_adaptive/papers/bretz_2009_22.pdf</a>
</p>
<p>Bretz F., Posch M., Glimm E., Klinglmueller F., Maurer W., Rohmeyer K.
(2011): Graphical approaches for multiple endpoint problems using weighted
Bonferroni, Simes or parametric tests. Biometrical Journal 53 (6), pages 894-913, Wiley.
<a href="https://doi.org/10.1002/bimj.201000239">doi:10.1002/bimj.201000239</a>
</p>
<p>Strassburger K., Bretz F.: Compatible simultaneous lower confidence bounds
for the Holm procedure and other Bonferroni based closed tests. Statistics
in Medicine 2008; 27:4914-4927.
</p>
<p>Hommel G., Bretz F., Maurer W.: Powerful short-cuts for multiple testing
procedures with special reference to gatekeeping strategies. Statistics in
Medicine 2007; 26:4063-4073.
</p>
<p>Guilbaud O.: Simultaneous confidence regions corresponding to Holm's
stepdown procedure and other closed-testing procedures. Biometrical Journal
2008; 50:678-692.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graphMCP">graphMCP</a></code> <code><a href="multcomp.html#topic+contrMat">graphNEL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

g &lt;- BonferroniHolm(5)
gMCP(g, pvalues=c(0.01, 0.02, 0.04, 0.04, 0.7))
# Simple Bonferroni with empty graph:
g2 &lt;- matrix2graph(matrix(0, nrow=5, ncol=5))
gMCP(g2, pvalues=c(0.01, 0.02, 0.04, 0.04, 0.7))
# With 'upscale=TRUE' equal to BonferroniHolm:
gMCP(g2, pvalues=c(0.01, 0.02, 0.04, 0.04, 0.7), upscale=TRUE)

# Entangled graphs:
g3 &lt;- Entangled2Maurer2012()
gMCP(g3, pvalues=c(0.01, 0.02, 0.04, 0.04, 0.7), correlation=diag(5))

</code></pre>

<hr>
<h2 id='gMCP.extended'>Graph based Multiple Comparison Procedures</h2><span id='topic+gMCP.extended'></span>

<h3>Description</h3>

<p>Performs a graph based multiple test procedure for a given graph and unadjusted p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gMCP.extended(
  graph,
  pvalues,
  test,
  alpha = 0.05,
  eps = 10^(-3),
  upscale = FALSE,
  verbose = FALSE,
  adjPValues = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gMCP.extended_+3A_graph">graph</code></td>
<td>
<p>A graph of class <code><a href="#topic+graphMCP">graphMCP</a></code>.</p>
</td></tr>
<tr><td><code id="gMCP.extended_+3A_pvalues">pvalues</code></td>
<td>
<p>A numeric vector specifying the p-values for the graph based
MCP. Note the assumptions in the description of the selected test (if there are any -
for example <code>test=bonferroni.test</code> has no further assumptions, but
<code>test=parametric.test</code> assumes p-values from a multivariate normal distribution).</p>
</td></tr>
<tr><td><code id="gMCP.extended_+3A_test">test</code></td>
<td>
<p>A weighted test function.
</p>
<p>The package gMCP provides the following weighted test functions:
</p>

<dl>
<dt>bonferroni.test</dt><dd><p>Bonferroni test - see <code>?bonferroni.test</code> for details.</p>
</dd>
<dt>parametric.test</dt><dd><p>Parametric test - see <code>?parametric.test</code> for details.</p>
</dd>
<dt>simes.test</dt><dd><p>Simes test - see <code>?simes.test</code> for details.</p>
</dd>
<dt>bonferroni.trimmed.simes.test</dt><dd><p>Trimmed Simes test for intersections of two hypotheses and otherwise Bonferroni - see <code>?bonferroni.trimmed.simes.test</code> for details.</p>
</dd>
<dt>simes.on.subsets.test</dt><dd><p>Simes test for intersections of hypotheses from certain sets and otherwise Bonferroni - see <code>?simes.on.subsets.test</code> for details.</p>
</dd>
</dl>

<p>To provide your own test function see <code>?weighted.test.function</code>.</p>
</td></tr>
<tr><td><code id="gMCP.extended_+3A_alpha">alpha</code></td>
<td>
<p>A numeric specifying the maximal allowed type one error rate.</p>
</td></tr>
<tr><td><code id="gMCP.extended_+3A_eps">eps</code></td>
<td>
<p>A numeric scalar specifying a value for epsilon edges.</p>
</td></tr>
<tr><td><code id="gMCP.extended_+3A_upscale">upscale</code></td>
<td>
<p>Logical. If <code>upscale=FALSE</code> then for each intersection 
of hypotheses (i.e. each subgraph) a weighted test is performed at the 
possibly reduced level alpha of sum(w)*alpha, 
where sum(w) is the sum of all node weights in this subset.
If <code>upscale=TRUE</code> all weights are upscaled, so that sum(w)=1.</p>
</td></tr>
<tr><td><code id="gMCP.extended_+3A_verbose">verbose</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code> verbose output is generated
during sequentially rejection steps.</p>
</td></tr>
<tr><td><code id="gMCP.extended_+3A_adjpvalues">adjPValues</code></td>
<td>
<p>Logical scalar. If <code>FALSE</code> no adjusted p-values will
be calculated. Especially for the weighted Simes test this will result in
significantly less calculations in most cases.</p>
</td></tr>
<tr><td><code id="gMCP.extended_+3A_...">...</code></td>
<td>
<p>Test specific arguments can be given here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>gMCPResult</code>, more specifically a list with
elements
</p>

<dl>
<dt><code>graphs</code></dt><dd><p>list of graphs</p>
</dd>
<dt><code>pvalues</code></dt><dd><p>p-values</p>
</dd>
<dt><code>rejected</code></dt><dd><p>logical whether hyptheses could be rejected</p>
</dd>
<dt><code>adjPValues</code></dt><dd><p>adjusted p-values</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>References</h3>

<p>Frank Bretz, Willi Maurer, Werner Brannath, Martin Posch: A
graphical approach to sequentially rejective multiple test procedures.
Statistics in Medicine 2009 vol. 28 issue 4 page 586-604.
<a href="https://www.meduniwien.ac.at/fwf_adaptive/papers/bretz_2009_22.pdf">https://www.meduniwien.ac.at/fwf_adaptive/papers/bretz_2009_22.pdf</a>
</p>
<p>Bretz F., Posch M., Glimm E., Klinglmueller F., Maurer W., Rohmeyer K.
(2011): Graphical approaches for multiple endpoint problems using weighted
Bonferroni, Simes or parametric tests. Biometrical Journal 53 (6), pages 894-913, Wiley.
<a href="https://doi.org/10.1002/bimj.201000239">doi:10.1002/bimj.201000239</a>
</p>
<p>Strassburger K., Bretz F.: Compatible simultaneous lower confidence bounds
for the Holm procedure and other Bonferroni based closed tests. Statistics
in Medicine 2008; 27:4914-4927.
</p>
<p>Hommel G., Bretz F., Maurer W.: Powerful short-cuts for multiple testing
procedures with special reference to gatekeeping strategies. Statistics in
Medicine 2007; 26:4063-4073.
</p>
<p>Guilbaud O.: Simultaneous confidence regions corresponding to Holm's
stepdown procedure and other closed-testing procedures. Biometrical Journal
2008; 50:678-692.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graphMCP">graphMCP</a></code> <code><a href="multcomp.html#topic+contrMat">graphNEL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

g &lt;- BonferroniHolm(5)
gMCP(g, pvalues=c(0.01, 0.02, 0.04, 0.04, 0.7))
# Simple Bonferroni with empty graph:
g2 &lt;- matrix2graph(matrix(0, nrow=5, ncol=5))
gMCP(g2, pvalues=c(0.01, 0.02, 0.04, 0.04, 0.7))
# With 'upscale=TRUE' equal to BonferroniHolm:
gMCP(g2, pvalues=c(0.01, 0.02, 0.04, 0.04, 0.7), upscale=TRUE)

# Entangled graphs:
g3 &lt;- Entangled2Maurer2012()
gMCP(g3, pvalues=c(0.01, 0.02, 0.04, 0.04, 0.7), correlation=diag(5))

</code></pre>

<hr>
<h2 id='gMCPReport'>Automatic Generation of gMCP Reports</h2><span id='topic+gMCPReport'></span>

<h3>Description</h3>

<p>Creates a LaTeX file with a gMCP Report.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gMCPReport(object, file = "", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gMCPReport_+3A_object">object</code></td>
<td>
<p>A graph of class <code><a href="#topic+graphMCP">graphMCP</a></code> or an object of class
<code><a href="#topic+gMCPResult">gMCPResult</a></code>.</p>
</td></tr>
<tr><td><code id="gMCPReport_+3A_file">file</code></td>
<td>
<p>A connection, or a character string naming the file to print to.
If <code>""</code> (the default), the report is printed to the standard output
connection (the console unless redirected by <code>sink</code>).  If it is
<code>"|cmd"</code>, the output is piped to the command given by <code>cmd</code>, by
opening a pipe connection [taken from the manual page of <code>cat</code>, which
is called in this function].</p>
</td></tr>
<tr><td><code id="gMCPReport_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to method <code><a href="#topic+graph2latex">graph2latex</a></code> like
<code>package</code> and <code>scale</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses <code>cat</code> and <code>graph2latex</code>.
</p>


<h3>Value</h3>

<p>None (invisible <code>NULL</code>).
</p>


<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>References</h3>

<p>The TikZ and PGF Packages Manual for version 2.00, Till Tantau,
<a href="https://www.ctan.org/pkg/pgf/">https://www.ctan.org/pkg/pgf/</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+cat">cat</a></code> <code><a href="#topic+graph2latex">graph2latex</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- BretzEtAl2011()

result &lt;- gMCP(g, pvalues=c(0.1, 0.008, 0.005, 0.15, 0.04, 0.006))

gMCPReport(result)

</code></pre>

<hr>
<h2 id='gMCPResult-class'>Class gMCPResult</h2><span id='topic+gMCPResult-class'></span><span id='topic+gMCPResult'></span><span id='topic+print+2CgMCPResult-method'></span><span id='topic+plot+2CgMCPResult+2CANY-method'></span><span id='topic+plot+2CgMCPResult-method'></span><span id='topic+getWeights+2CgMCPResult-method'></span><span id='topic+getRejected+2CgMCPResult-method'></span>

<h3>Description</h3>

<p>A gMCPResult object describes an evaluated sequentially rejective multiple test procedure.</p>


<h3>Slots</h3>


<dl>
<dt><code>graphs</code>:</dt><dd><p>Object of class <code>list</code>. </p>
</dd>        
<dt><code>alpha</code>:</dt><dd><p>A <code>numeric</code> specifying the maximal type I error rate.</p>
</dd>
<dt><code>pvalues</code>:</dt><dd><p>The <code>numeric</code> vector of pvalues.</p>
</dd>
<dt><code>rejected</code>:</dt><dd><p>The <code>logical</code> vector of rejected null hypotheses.</p>
</dd>
<dt><code>adjPValues</code>:</dt><dd><p>The <code>numeric</code> vector of adjusted pvalues.</p>
</dd>    
</dl>



<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gMCP">gMCP</a></code>
</p>

<hr>
<h2 id='gPADInterim-class'>Class gPADInterim</h2><span id='topic+gPADInterim-class'></span><span id='topic+gPADInterim'></span><span id='topic+print+2CgPADInterim-method'></span><span id='topic+plot+2CgPADInterim-method'></span><span id='topic+getWeights+2CgPADInterim-method'></span><span id='topic+getRejected+2CgPADInterim-method'></span>

<h3>Description</h3>

<p>A gPADInterim object describes an object holding interim
information for an adaptive procedure that is based on a preplanned
graphical procedure.</p>


<h3>Slots</h3>


<dl>
<dt><code>Aj</code>:</dt><dd><p>Object of class <code>numeric</code>. Giving partial
conditional errors (PCEs) for all elementary hypotheses in each
intersection hypothesis </p>
</dd>        
<dt><code>BJ</code>:</dt><dd><p>A <code>numeric</code> specifying the sum of PCEs per
intersection hypothesis.</p>
</dd>
<dt><code>z1</code>:</dt><dd><p>The <code>numeric</code> vector of first stage
z-scores.</p>
</dd>
<dt><code>v</code>:</dt><dd><p>A <code>numeric</code> specifying the proportion of
measurements collected up to interim</p>
</dd>
<dt><code>preplanned</code>:</dt><dd><p>Object of class <code><a href="#topic+graphMCP">graphMCP</a></code>
specifying the preplanned graphical procedure.</p>
</dd>
<dt><code>alpha</code>:</dt><dd><p>A <code>numeric</code> giving the alpha level of the
pre-planned test</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Florian Klinglmueller <a href="mailto:float@lefant.net">float@lefant.net</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gMCP">gMCP</a></code>, <code><a href="#topic+doInterim">doInterim</a></code>, <code><a href="#topic+secondStageTest">secondStageTest</a></code>
</p>

<hr>
<h2 id='graph2latex'>Graph2LaTeX</h2><span id='topic+graph2latex'></span>

<h3>Description</h3>

<p>Creates LaTeX code that represents the given graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph2latex(
  graph,
  package = "TikZ",
  scale = 1,
  showAlpha = FALSE,
  alpha = 0.05,
  pvalues,
  fontsize,
  nodeTikZ,
  labelTikZ = "near start,above,fill=blue!20",
  tikzEnv = TRUE,
  offset = c(0, 0),
  fill = list(reject = "red!80", retain = "green!80"),
  fig = FALSE,
  fig.label = NULL,
  fig.caption = NULL,
  fig.caption.short = NULL,
  nodeR = 25,
  scaleText = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph2latex_+3A_graph">graph</code></td>
<td>
<p>A graph of class <code><a href="#topic+graphMCP">graphMCP</a></code>.</p>
</td></tr>
<tr><td><code id="graph2latex_+3A_package">package</code></td>
<td>
<p>A character string specifying the LaTeX package that should
be used.  Up to now only <code>TikZ</code> is available.</p>
</td></tr>
<tr><td><code id="graph2latex_+3A_scale">scale</code></td>
<td>
<p>A numeric scalar specifying a possible scaling of the graph.
It is only used if <code>tikzEnv==TRUE</code>.
Note that this does only effect the fontsize of the graph if <code>scaleText==FALSE</code>.
(Coordinates are interpreted in big points: 72 bp = 1 inch).</p>
</td></tr>
<tr><td><code id="graph2latex_+3A_showalpha">showAlpha</code></td>
<td>
<p>Logical whether local alpha levels or weights should be shown.</p>
</td></tr>
<tr><td><code id="graph2latex_+3A_alpha">alpha</code></td>
<td>
<p>An optional numeric argument to specify the type I error rate.</p>
</td></tr>
<tr><td><code id="graph2latex_+3A_pvalues">pvalues</code></td>
<td>
<p>If the optional numeric argument pvalues is given, nodes that
can be rejected, will be marked.</p>
</td></tr>
<tr><td><code id="graph2latex_+3A_fontsize">fontsize</code></td>
<td>
<p>An optional character vector specifying the fontsize for the
graph, must be one of <code>"tiny"</code>, <code>"scriptsize"</code>,
<code>"footnotesize"</code>, <code>"small"</code>, <code>"normalsize"</code>, <code>"large"</code>,
<code>"Large"</code>, <code>"LARGE"</code>, <code>"huge"</code> or <code>"Huge"</code>.</p>
</td></tr>
<tr><td><code id="graph2latex_+3A_nodetikz">nodeTikZ</code></td>
<td>
<p>A character string with additional arguments for the TikZ
<code>node</code> command like for example <code>nodeTikZ="minimum size=2cm"</code>.</p>
</td></tr>
<tr><td><code id="graph2latex_+3A_labeltikz">labelTikZ</code></td>
<td>
<p>A character string with arguments for the TikZ <code>node</code>
command within an edge.</p>
</td></tr>
<tr><td><code id="graph2latex_+3A_tikzenv">tikzEnv</code></td>
<td>
<p>Logical whether the LaTeX code should be wrapped in a TikZ
environment.</p>
</td></tr>
<tr><td><code id="graph2latex_+3A_offset">offset</code></td>
<td>
<p>A numeric of length 2 specifying the x and y offset in the
TikZ environment.</p>
</td></tr>
<tr><td><code id="graph2latex_+3A_fill">fill</code></td>
<td>
<p>A list containing 2 elements <code>reject</code> and <code>retain</code>
specifying node fill colour of rejected and retained (or not yet rejected)
nodes.</p>
</td></tr>
<tr><td><code id="graph2latex_+3A_fig">fig</code></td>
<td>
<p>Logical whether a figure environment should be created.</p>
</td></tr>
<tr><td><code id="graph2latex_+3A_fig.label">fig.label</code></td>
<td>
<p>Label for figure environment (if <code>fig==TRUE</code>).</p>
</td></tr>
<tr><td><code id="graph2latex_+3A_fig.caption">fig.caption</code></td>
<td>
<p>Caption for figure environment (if <code>fig==TRUE</code>).</p>
</td></tr>
<tr><td><code id="graph2latex_+3A_fig.caption.short">fig.caption.short</code></td>
<td>
<p>Optional short version of fig.caption for list of figures (if <code>fig==TRUE</code>).</p>
</td></tr>
<tr><td><code id="graph2latex_+3A_noder">nodeR</code></td>
<td>
<p>Radius of nodes (pixel in Java, bp in LaTeX).</p>
</td></tr>
<tr><td><code id="graph2latex_+3A_scaletext">scaleText</code></td>
<td>
<p>Only used if scale is unequal 1 and <code>tikzEnv==TRUE</code>. 
If <code>scaleText</code> is <code>TRUE</code> (the default) a scalebox environment is used.
If it is <code>FALSE</code> the optional parameter <code>scale</code> from the
tikzpicture environment is used and font size will not change. 
Note that while you easily can change the scale in the scalebox environment,
it is more problematic to adjust the scale in the tikzpicture environment
afterwards in the LaTeX document, since for curved edges the parameters
are calculated for a certain relative node size which changes if the graph
is scaled but the text size stays the same.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details see the given references.
</p>


<h3>Value</h3>

<p>A character string that contains LaTeX code representing the given
graph.
</p>


<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>References</h3>

<p>The TikZ and PGF Packages Manual for version 2.00, Till Tantau,
<a href="https://www.ctan.org/pkg/pgf/">https://www.ctan.org/pkg/pgf/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graphMCP">graphMCP</a></code>, <code><a href="#topic+gMCPReport">gMCPReport</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

g &lt;- BonferroniHolm(5)

graph2latex(g)


</code></pre>

<hr>
<h2 id='graphAnalysis'>Analysis of a gMCP-Graph</h2><span id='topic+graphAnalysis'></span>

<h3>Description</h3>

<p>Creates LaTeX code that represents the given graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphAnalysis(graph, file = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graphAnalysis_+3A_graph">graph</code></td>
<td>
<p>A graph of class <code><a href="#topic+graphMCP">graphMCP</a></code>.</p>
</td></tr>
<tr><td><code id="graphAnalysis_+3A_file">file</code></td>
<td>
<p>A connection, or a character string naming the file to print to.
If <code>""</code> (the default), the analysis is printed to the standard output
connection (the console unless redirected by <code>sink</code>).  If it is
<code>"|cmd"</code>, the output is piped to the command given by <code>cmd</code>, by
opening a pipe connection [taken from the manual page of <code>cat</code>, which
is called in this function].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the moment it is only tested whether each node is accessible from each
other node. Further analysis will be added in future versions.
</p>


<h3>Value</h3>

<p>A character string that contains the printed analysis.
</p>


<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graphMCP">graphMCP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

g &lt;- BonferroniHolm(5)

graphAnalysis(g)


</code></pre>

<hr>
<h2 id='graphGUI'>Graphical User Interface for graphical described multiple comparison
procedures</h2><span id='topic+graphGUI'></span>

<h3>Description</h3>

<p>Starts a graphical user interface for the creation/modification of directed
weighted graphs and applying graphical described multiple comparison
procedures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphGUI(
  graph = "createdGraph",
  pvalues = numeric(0),
  grid = 0,
  debug = FALSE,
  experimentalFeatures = FALSE,
  envir = globalenv()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graphGUI_+3A_graph">graph</code></td>
<td>
<p>Either a variable name for the graph, given as a character
string.  (If it is not a syntactically valid name, <code><a href="base.html#topic+make.names">make.names</a></code>
is called to change it to a valid one.)  Or an object of class
<code><a href="#topic+graphMCP">graphMCP</a></code>.  If the object is modified (even just by updating
the class definition or arranging the nodes) it will be saved in the
specified environment (default is the global environment).</p>
</td></tr>
<tr><td><code id="graphGUI_+3A_pvalues">pvalues</code></td>
<td>
<p>Numeric value that optionally specifies the p-values.</p>
</td></tr>
<tr><td><code id="graphGUI_+3A_grid">grid</code></td>
<td>
<p>Positive integer that sets the grid size for easier placement of
nodes.  (Therefore grid size 1 allows unrestricted placement and disables
the grid.)  The default grid=0 uses the last used grid value or if the GUI
is started the first time a value of 50.</p>
</td></tr>
<tr><td><code id="graphGUI_+3A_debug">debug</code></td>
<td>
<p>Logical. If <code>TRUE</code> debug output is printed to the R
console.</p>
</td></tr>
<tr><td><code id="graphGUI_+3A_experimentalfeatures">experimentalFeatures</code></td>
<td>
<p>Logical. If <code>TRUE</code> some unfinished /
insufficiently tested experimental features are available in the GUI.</p>
</td></tr>
<tr><td><code id="graphGUI_+3A_envir">envir</code></td>
<td>
<p>Environment where the object <var>graph</var> is located and/or it
should be saved (default is the global environment).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the vignette of this package for further details, since describing a GUI
interface is better done with a lot of nice pictures.
</p>
<p>The GUI can save result files if asked to, can look for a new version on CRAN
(if this behaviour has been approved by the user), will change the random seed in 
the R session if this is specified by the user in the options (default: no)
and could send bug reports if an error occurs and the user approves it.
</p>


<h3>Value</h3>

<p>The function itself returns NULL. But with the GUI a graph can be
created or edited that will be available in R under the specified variable
name after saving in the specified environment.
</p>


<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 
graphGUI()
pvalues &lt;- c(9.7, 1.5, 0.5, 0.6, 0.4, 0.8, 4)/100 
graphGUI(HommelEtAl2007(), pvalues=pvalues)

x &lt;- new.env()
assign("graph", BonferroniHolm(3), envir=x)
graphGUI("graph", envir=x)
## End(Not run)


</code></pre>

<hr>
<h2 id='graphMCP-class'>Class graphMCP</h2><span id='topic+graphMCP-class'></span><span id='topic+graphMCP'></span><span id='topic+print+2CgraphMCP-method'></span><span id='topic+plot+2CgraphMCP+2CANY-method'></span><span id='topic+plot+2CgraphMCP-method'></span><span id='topic+getWeights'></span><span id='topic+getWeights+2CgraphMCP-method'></span><span id='topic+getMatrix'></span><span id='topic+getMatrix+2CgraphMCP-method'></span><span id='topic+setWeights'></span><span id='topic+setWeights+2CgraphMCP-method'></span><span id='topic+setRejected+3C-'></span><span id='topic+setRejected+3C-+2CgraphMCP-method'></span><span id='topic+getRejected'></span><span id='topic+getRejected+2CgraphMCP-method'></span><span id='topic+getXCoordinates'></span><span id='topic+getXCoordinates+2CgraphMCP-method'></span><span id='topic+getYCoordinates'></span><span id='topic+getYCoordinates+2CgraphMCP-method'></span><span id='topic+setEdge'></span><span id='topic+setEdge+2Ccharacter+2Ccharacter+2CgraphMCP+2Ccharacter-method'></span><span id='topic+setEdge+2Ccharacter+2Ccharacter+2CgraphMCP+2Cnumeric-method'></span><span id='topic+getNodes'></span><span id='topic+getNodes+2CgraphMCP-method'></span><span id='topic+edgeAttr'></span><span id='topic+edgeAttr+3C-'></span><span id='topic+edgeAttr+2CgraphMCP+2Ccharacter+2Ccharacter+2Ccharacter-method'></span><span id='topic+edgeAttr+3C-+2CgraphMCP+2Ccharacter+2Ccharacter+2Ccharacter-method'></span><span id='topic+nodeAttr'></span><span id='topic+nodeAttr+3C-'></span><span id='topic+nodeAttr+2CgraphMCP+2Ccharacter+2Ccharacter-method'></span><span id='topic+nodeAttr+3C-+2CgraphMCP+2Ccharacter+2Ccharacter-method'></span>

<h3>Description</h3>

<p>A graphMCP object describes a sequentially rejective multiple test procedure.</p>


<h3>Slots</h3>

  
    
<dl>
<dt><code>m</code>:</dt><dd><p>A transition matrix. Can be either <code>numerical</code> or <code>character</code>
depending whether the matrix contains variables or not. Row and column names will
be the names of the nodes.</p>
</dd>
<dt><code>weights</code>:</dt><dd><p>A numeric.</p>
</dd>        
<dt><code>edgeAttr</code>:</dt><dd><p>A list for edge attributes.</p>
</dd>
<dt><code>nodeAttr</code>:</dt><dd><p>A list for node attributes.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>getMatrix</dt><dd><p><code>signature(object = "graphMCP")</code>: A method for getting the transition matrix of the graph.</p>
</dd>
<dt>getWeights</dt><dd><p><code>signature(object = "graphMCP")</code>: A method for getting the weights.
If a third optional argument <code>node</code> is specified, only for these nodes the weight will be returned.</p>
</dd>
<dt>setWeights</dt><dd><p><code>signature(object = "graphMCP")</code>: A method for setting the weights.
If a third optional argument <code>node</code> is specified, only for these nodes the weight will be set.</p>
</dd>
<dt>getRejected</dt><dd><p><code>signature(object = "graphMCP")</code>: 
A method for getting the information whether the hypotheses are marked in the graph as already rejected.
If a second optional argument <code>node</code> is specified, only for these nodes the boolean vector will be returned.</p>
</dd>
<dt>getXCoordinates</dt><dd><p><code>signature(object = "graphMCP")</code>: 
A method for getting the x coordinates of the graph.
If a second optional argument <code>node</code> is specified, only for these nodes the x coordinates will be returned.
If x coordinates are not set yet <code>NULL</code> is returned.</p>
</dd>
<dt>getYCoordinates</dt><dd><p><code>signature(object = "graphMCP")</code>: 
A method for getting the y coordinates of the graph
If a second optional argument <code>node</code> is specified, only for these nodes the x coordinates will be returned.
If y coordinates are not set yet <code>NULL</code> is returned.</p>
</dd>
<dt>setEdge</dt><dd><p><code>signature(from="character", to="character", graph="graphNEL", weights="numeric")</code>: 
A method for adding new edges with the given weights.</p>
</dd>
<dt>setEdge</dt><dd><p><code>signature(from="character", to="character", graph="graphMCP", weights="character")</code>: 
A method for adding new edges with the given weights.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- rbind(H11=c(0,   0.5, 0,   0.5, 0,   0  ),
			H21=c(1/3, 0,   1/3, 0,   1/3, 0  ),
			H31=c(0,   0.5, 0,   0,   0,   0.5),
			H12=c(0,   1,   0,   0,   0,   0  ),
			H22=c(0.5, 0,   0.5, 0,   0,   0  ),
			H32=c(0,   1,   0,   0,   0,   0  ))	

weights &lt;- c(1/3, 1/3, 1/3, 0, 0, 0)

# Graph creation
graph &lt;- new("graphMCP", m=m, weights=weights)

# Visualization settings
nodeX &lt;- rep(c(100, 300, 500), 2)
nodeY &lt;- rep(c(100, 300), each=3)
graph@nodeAttr$X &lt;- nodeX
graph@nodeAttr$Y &lt;- nodeY	

getWeights(graph)

getRejected(graph)

pvalues &lt;- c(0.1, 0.008, 0.005, 0.15, 0.04, 0.006)
result &lt;- gMCP(graph, pvalues)

getWeights(result@graphs[[4]])
getRejected(result@graphs[[4]])

</code></pre>

<hr>
<h2 id='graphTest'>Multiple testing using graphs</h2><span id='topic+graphTest'></span>

<h3>Description</h3>

<p>Implements the graphical test procedure described in Bretz et al. (2009).
Note that the gMCP function in the gMCP package performs the same task.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphTest(
  pvalues,
  weights = NULL,
  alpha = 0.05,
  G = NULL,
  cr = NULL,
  graph = NULL,
  verbose = FALSE,
  test,
  upscale = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graphTest_+3A_pvalues">pvalues</code></td>
<td>
<p>Either a vector or a matrix containing the local p-values for
the hypotheses in the rows.</p>
</td></tr>
<tr><td><code id="graphTest_+3A_weights">weights</code></td>
<td>
<p>Initial weight levels for the test procedure, in case of
multiple graphs this needs to be a matrix.</p>
</td></tr>
<tr><td><code id="graphTest_+3A_alpha">alpha</code></td>
<td>
<p>Overall alpha level of the procedure. For entangled graphs
<code>alpha</code> should be a numeric vector of length equal to the number of
graphs, each element specifying the partial alpha for the respective graph.
The overall alpha level equals <code>sum(alpha)</code>.</p>
</td></tr>
<tr><td><code id="graphTest_+3A_g">G</code></td>
<td>
<p>For simple graphs <code>G</code> should be a numeric matrix determining
the graph underlying the test procedure. Note that the diagonal need to
contain only 0s, while the rows need to sum to 1.  For entangled graphs it
needs to be a list containing the different graph matrices as elements.</p>
</td></tr>
<tr><td><code id="graphTest_+3A_cr">cr</code></td>
<td>
<p>Correlation matrix that should be used for the parametric test.
If <code>cr==NULL</code> the Bonferroni based test procedure is used.</p>
</td></tr>
<tr><td><code id="graphTest_+3A_graph">graph</code></td>
<td>
<p>As an alternative to the specification via <code>weights</code> and
<code>G</code> one can also hand over a <code>graphMCP</code> object to the code.
<code>graphMCP</code> objects can be created for example with the <code>graphGUI</code>
function.</p>
</td></tr>
<tr><td><code id="graphTest_+3A_verbose">verbose</code></td>
<td>
<p>If verbose is TRUE, additional information about the
graphical rejection procedure is displayed.</p>
</td></tr>
<tr><td><code id="graphTest_+3A_test">test</code></td>
<td>
<p>In the parametric case there is more than one way to handle
subgraphs with less than the full alpha. If the parameter <code>test</code> is
missing, the tests are performed as described by Bretz et al. (2011), i.e.
tests of intersection null hypotheses always exhaust the full alpha level
even if the sum of weights is strictly smaller than one. If
<code>test="simple-parametric"</code> the tests are performed as defined in
Equation (3) of Bretz et al. (2011).</p>
</td></tr>
<tr><td><code id="graphTest_+3A_upscale">upscale</code></td>
<td>
<p>Logical. If <code>upscale=FALSE</code> then for each intersection
of hypotheses (i.e. each subgraph) a weighted test is performed at the
possibly reduced level alpha of sum(w)*alpha,
where sum(w) is the sum of all node weights in this subset.
If <code>upscale=TRUE</code> all weights are upscaled, so that sum(w)=1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or a matrix containing the test results for the hypotheses
under consideration. Significant tests are denoted by a 1, non-significant
results by a 0.
</p>


<h3>References</h3>

<p>Bretz, F., Maurer, W., Brannath, W. and Posch, M. (2009) A graphical
approach to sequentially rejective multiple test procedures. Statistics in
Medicine, 28, 586&ndash;604
</p>
<p>Bretz, F., Maurer, W. and Hommel, G. (2010) Test and power considerations
for multiple endpoint analyses using sequentially rejective graphical
procedures, to appear in Statistics in Medicine
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#### example from Bretz et al. (2010)
weights &lt;- c(1/3, 1/3, 1/3, 0, 0, 0)
graph &lt;- rbind(c(0,       0.5, 0,     0.5, 0,      0),
               c(1/3,     0,   1/3,    0,   1/3,    0),
               c(0,       0.5, 0,     0,   0,      0.5),
               c(0,       1,   0,     0,   0,      0),
               c(0.5,     0,   0.5,   0,   0,      0),
               c(0,       1,   0,     0,   0,      0))
pvals &lt;- c(0.1, 0.008, 0.005, 0.15, 0.04, 0.006)
graphTest(pvals, weights, alpha=0.025, graph)

## observe graphical procedure in detail
graphTest(pvals, weights, alpha=0.025, graph, verbose = TRUE)

## now use many p-values (useful for power simulations)
pvals &lt;- matrix(rbeta(6e4, 1, 30), ncol = 6)
out &lt;- graphTest(pvals, weights, alpha=0.025, graph)
head(out)

## example using multiple graphs (instead of 1)
G1 &lt;- rbind(c(0,0.5,0.5,0,0), c(0,0,1,0,0),
            c(0, 0, 0, 1-0.01, 0.01), c(0, 1, 0, 0, 0),
            c(0, 0, 0, 0, 0))
G2 &lt;- rbind(c(0,0,1,0,0), c(0.5,0,0.5,0,0),
            c(0, 0, 0, 0.01, 1-0.01), c(0, 0, 0, 0, 0),
            c(1, 0, 0, 0, 0))
weights &lt;- rbind(c(1, 0, 0, 0, 0), c(0, 1, 0, 0, 0))
pvals &lt;- c(0.012, 0.025, 0.005, 0.0015, 0.0045)
out &lt;- graphTest(pvals, weights, alpha=c(0.0125, 0.0125), G=list(G1, G2), verbose = TRUE)

## now again with many p-values
pvals &lt;- matrix(rbeta(5e4, 1, 30), ncol = 5)
out &lt;- graphTest(pvals, weights, alpha=c(0.0125, 0.0125), G=list(G1, G2))
head(out)

</code></pre>

<hr>
<h2 id='hydroquinone'>Hydroquinone Mutagenicity Assay</h2><span id='topic+hydroquinone'></span>

<h3>Description</h3>

<p>This data set gives the number of micronuclei per animal and 2000 scored cells 
for six different groups of differently treated male mice: The negative control (C-),
four doses (30, 50, 75, 100 mg hydroquinone / kg) of hydroquinone 
and an active control (C+) (with 25 mg/kg cyclophosphamide).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hydroquinone)</code></pre>


<h3>Format</h3>

<p>A data frame with 31 observations on the following 2 variables:
</p>

<dl>
<dt>group</dt><dd><p>A factor with levels &quot;C-&quot;, &quot;30 mg/kg&quot;, &quot;50 mg/kg&quot;, &quot;75 mg/kg&quot;, &quot;100 mg/kg&quot; and &quot;C+&quot; specifying the groups.</p>
</dd>
<dt>micronuclei</dt><dd><p>A numeric vector, giving the counts of micronuclei per animal and 2000 scored cells after 24h.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Adler, I.-D. and Kliesch, U. (1990):
<em>Comparison of single and multiple treatment regimens in the mouse bone marrow micronucleus assay for hydroquinone and cyclophosphamide</em>.
Mutation Research 234, 115-123.
</p>


<h3>References</h3>

<p>Bauer, P., Roehmel, J., Maurer, W., and Hothorn, L. (1998):
<em>Testing strategies in multi-dose experiments including active control</em>.
Statistics in Medicine 17, 2133-2146.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(hydroquinone)
  boxplot(micronuclei~group, data=hydroquinone)
</code></pre>

<hr>
<h2 id='joinGraphs'>Joins two graphMCP objects</h2><span id='topic+joinGraphs'></span>

<h3>Description</h3>

<p>Creates a new graphMCP object by joining two given graphMCP objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joinGraphs(graph1, graph2, xOffset = 0, yOffset = 200)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="joinGraphs_+3A_graph1">graph1</code></td>
<td>
<p>A graph of class <code><a href="#topic+graphMCP">graphMCP</a></code>.</p>
</td></tr>
<tr><td><code id="joinGraphs_+3A_graph2">graph2</code></td>
<td>
<p>A graph of class <code><a href="#topic+graphMCP">graphMCP</a></code>.</p>
</td></tr>
<tr><td><code id="joinGraphs_+3A_xoffset">xOffset</code></td>
<td>
<p>A numeric specifying an offset (on the x-axis) for placing
the nodes and edge labels of the second graph.</p>
</td></tr>
<tr><td><code id="joinGraphs_+3A_yoffset">yOffset</code></td>
<td>
<p>A numeric specifying an offset (on the y-axis) for placing
the nodes and edge labels of the second graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>graph1</code> and <code>graph2</code> have duplicates in the node names, the
nodes of the second graph will be renamed.
</p>
<p>If and only if the sum of the weights of graph1 and graph2 exceeds 1, the
weights are scaled so that the sum equals 1.
</p>
<p>A description attribute of either graph will be discarded.
</p>


<h3>Value</h3>

<p>A graphMCP object that represents a graph that consists of the two
given graphs.
</p>


<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graphMCP">graphMCP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

g1 &lt;- BonferroniHolm(2)
g2 &lt;- BonferroniHolm(3)

joinGraphs(g1, g2)


</code></pre>

<hr>
<h2 id='matrix2graph'>Matrix2Graph and Graph2Matrix</h2><span id='topic+matrix2graph'></span><span id='topic+graph2matrix'></span>

<h3>Description</h3>

<p>Creates a graph of class <code><a href="#topic+graphMCP">graphMCP</a></code> from a given transition
matrix or vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix2graph(m, weights = rep(1/dim(m)[1], dim(m)[1]))

graph2matrix(graph)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matrix2graph_+3A_m">m</code></td>
<td>
<p>A transition matrix.</p>
</td></tr>
<tr><td><code id="matrix2graph_+3A_weights">weights</code></td>
<td>
<p>A numeric for the initial weights.</p>
</td></tr>
<tr><td><code id="matrix2graph_+3A_graph">graph</code></td>
<td>
<p>A graph of class <code><a href="#topic+graphMCP">graphMCP</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The hypotheses names are the row names or if these are <code>NULL</code>, the
column names or if these are also <code>NULL</code> of type H1, H2, H3, ...
</p>
<p>If the diagonal of the matrix is unequal zero, the values are ignored and a
warning is given.
</p>


<h3>Value</h3>

<p>A graph of class <code><a href="#topic+graphMCP">graphMCP</a></code> with the given transition
matrix for matrix2graph.  The transition matrix of a <code><a href="#topic+graphMCP">graphMCP</a></code>
graph for graph2matrix.
</p>


<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Bonferroni-Holm:
m &lt;- matrix(rep(1/3, 16), nrow=4)
diag(m) &lt;- c(0, 0, 0, 0)
graph &lt;- matrix2graph(m)
print(graph)
graph2matrix(graph)


</code></pre>

<hr>
<h2 id='parametric.test'>Weighted parametric test</h2><span id='topic+parametric.test'></span>

<h3>Description</h3>

<p>It is assumed that under the global null hypothesis
<code class="reqn">(\Phi^{-1}(1-p_1),...,\Phi^{-1}(1-p_m))</code> follow a multivariate normal
distribution with correlation matrix <code>correlation</code> where
<code class="reqn">\Phi^{-1}</code> denotes the inverse of the standard normal distribution
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parametric.test(
  pvalues,
  weights,
  alpha = 0.05,
  adjPValues = TRUE,
  verbose = FALSE,
  correlation,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parametric.test_+3A_pvalues">pvalues</code></td>
<td>
<p>A numeric vector specifying the p-values.</p>
</td></tr>
<tr><td><code id="parametric.test_+3A_weights">weights</code></td>
<td>
<p>A numeric vector of weights.</p>
</td></tr>
<tr><td><code id="parametric.test_+3A_alpha">alpha</code></td>
<td>
<p>A numeric specifying the maximal allowed type one error rate. If <code>adjPValues==TRUE</code> (default) the parameter <code>alpha</code> is not used.</p>
</td></tr>
<tr><td><code id="parametric.test_+3A_adjpvalues">adjPValues</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code> (the default) an adjusted p-value for the weighted parametric test is returned.
Otherwise if <code>adjPValues==FALSE</code> a logical value is returned whether the null hypothesis can be rejected.</p>
</td></tr>
<tr><td><code id="parametric.test_+3A_verbose">verbose</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code> verbose output is generated.</p>
</td></tr>
<tr><td><code id="parametric.test_+3A_correlation">correlation</code></td>
<td>
<p>Correlation matrix. For parametric tests the p-values
must arise from one-sided tests with multivariate normal distributed test
statistics for which the correlation is (partially) known. In that case a
weighted parametric closed test is performed (also see
<code><a href="#topic+generatePvals">generatePvals</a></code>). Unknown values can be set to NA. (See details
for more information)</p>
</td></tr>
<tr><td><code id="parametric.test_+3A_...">...</code></td>
<td>
<p>Further arguments possibly passed by <code>gMCP</code> which will be used by other test procedures but not this one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For example, this is the case if <code class="reqn">p_1,..., p_m</code> are the raw p-values
from one-sided z-tests for each of the elementary hypotheses where the
correlation between z-test statistics is generated by an overlap in the
observations (e.g. comparison with a common control, group-sequential
analyses etc.). An application of the transformation <code class="reqn">\Phi^{-1}(1-p_i)</code>
to raw p-values from a two-sided test will not in general lead to a
multivariate normal distribution. Partial knowledge of the correlation
matrix is supported. The correlation matrix has to be passed as a numeric
matrix with elements of the form: <code class="reqn">correlation[i,i] = 1</code> for diagonal
elements, <code class="reqn">correlation[i,j] = \rho_{ij}</code>, where <code class="reqn">\rho_{ij}</code> is the
known value of the correlation between <code class="reqn">\Phi^{-1}(1-p_i)</code> and
<code class="reqn">\Phi^{-1}(1-p_j)</code> or <code>NA</code> if the corresponding correlation is
unknown. For example correlation[1,2]=0 indicates that the first and second
test statistic are uncorrelated, whereas correlation[2,3] = NA means that
the true correlation between statistics two and three is unknown and may
take values between -1 and 1. The correlation has to be specified for
complete blocks (ie.: if cor(i,j), and cor(i,j') for i!=j!=j' are specified
then cor(j,j') has to be specified as well) otherwise the corresponding
intersection null hypotheses tests are not uniquely defined and an error is
returned.
</p>
<p>For further details see the given references.
</p>


<h3>References</h3>

<p>Bretz F., Posch M., Glimm E., Klinglmueller F., Maurer W., Rohmeyer K.
(2011): Graphical approaches for multiple endpoint problems using weighted
Bonferroni, Simes or parametric tests. Biometrical Journal 53 (6), pages 894-913, Wiley.
<a href="https://doi.org/10.1002/bimj.201000239">doi:10.1002/bimj.201000239</a>
</p>

<hr>
<h2 id='placeNodes'>Placement of graph nodes</h2><span id='topic+placeNodes'></span>

<h3>Description</h3>

<p>Places the nodes of a graph according to a specified layout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>placeNodes(graph, nrow, ncol, byrow = TRUE, topdown = TRUE, force = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="placeNodes_+3A_graph">graph</code></td>
<td>
<p>A graph of class <code><a href="#topic+graphMCP">graphMCP</a></code> or class
<code><a href="#topic+entangledMCP">entangledMCP</a></code>.</p>
</td></tr>
<tr><td><code id="placeNodes_+3A_nrow">nrow</code></td>
<td>
<p>The desired number of rows.</p>
</td></tr>
<tr><td><code id="placeNodes_+3A_ncol">ncol</code></td>
<td>
<p>The desired number of columns.</p>
</td></tr>
<tr><td><code id="placeNodes_+3A_byrow">byrow</code></td>
<td>
<p>Logical whether the graph is filled by rows (otherwise by
columns).</p>
</td></tr>
<tr><td><code id="placeNodes_+3A_topdown">topdown</code></td>
<td>
<p>Logical whether the rows are filled top-down or bottom-up.</p>
</td></tr>
<tr><td><code id="placeNodes_+3A_force">force</code></td>
<td>
<p>Logical whether a graph that has already a layout should be
given the specified new layout.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If one of <code>nrow</code> or <code>ncol</code> is not given, an attempt is made to
infer it from the number of nodes of the <code>graph</code> and the other
parameter.  If neither is given, the graph is placed as a circle.
</p>


<h3>Value</h3>

<p>The graph with nodes placed according to the specified layout.
</p>


<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graphMCP">graphMCP</a></code>, <code><a href="#topic+entangledMCP">entangledMCP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

g &lt;- matrix2graph(matrix(0, nrow=6, ncol=6))

g &lt;- placeNodes(g, nrow=2, force=TRUE)

## Not run: 
graphGUI(g)


## End(Not run)


</code></pre>

<hr>
<h2 id='plotSimCI'>Plot confidence intervals</h2><span id='topic+plotSimCI'></span>

<h3>Description</h3>

<p>A function for convenient plotting of confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSimCI(ci)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotSimCI_+3A_ci">ci</code></td>
<td>
<p>a (named) matrix containing the lower confidence bounds in the
first column, the point estimates in the second and the upper confidence
bounds in the third column.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Code adapted from plotCII from Frank Schaarschmidt
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

est &lt;- c("H1"=0.860382, "H2"=0.9161474, "H3"=0.9732953)
# Sample standard deviations:
ssd &lt;- c("H1"=0.8759528, "H2"=1.291310, "H3"=0.8570892)

pval &lt;- c(0.01260, 0.05154, 0.02124)/2

ci &lt;- simConfint(BonferroniHolm(3), pvalues=pval, 
  	confint="t", df=9, estimates=est, alpha=0.025, alternative="greater")

plotSimCI(ci)


</code></pre>

<hr>
<h2 id='rejectNode'>Rejects a node/hypothesis and updates the graph accordingly.</h2><span id='topic+rejectNode'></span>

<h3>Description</h3>

<p>Rejects a node/hypothesis and updates the graph accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rejectNode(graph, node, upscale = FALSE, verbose = FALSE, keepWeights = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rejectNode_+3A_graph">graph</code></td>
<td>
<p>A graph of class <code><a href="#topic+graphMCP">graphMCP</a></code> or <code><a href="#topic+entangledMCP">entangledMCP</a></code>.</p>
</td></tr>
<tr><td><code id="rejectNode_+3A_node">node</code></td>
<td>
<p>A character string specifying the node to reject.</p>
</td></tr>
<tr><td><code id="rejectNode_+3A_upscale">upscale</code></td>
<td>
<p>Logical. If <code>upscale=TRUE</code> then the weights of all non-rejected
nodes are scaled so that the sum is equal to 1. This forces <code>keepWeights=FALSE</code>
to reduce confusion, since otherwise the sum of weights could become bigger than 1.</p>
</td></tr>
<tr><td><code id="rejectNode_+3A_verbose">verbose</code></td>
<td>
<p>Logical scalar.  If <code>TRUE</code> verbose output is generated
during sequentially rejection steps.</p>
</td></tr>
<tr><td><code id="rejectNode_+3A_keepweights">keepWeights</code></td>
<td>
<p>Logical scalar. If <code>FALSE</code> the weight of a node
without outgoing edges is set to 0 if it is removed.  Otherwise it keeps its
weight.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details see the given references.
</p>


<h3>Value</h3>

<p>An updated graph of class <code><a href="#topic+graphMCP">graphMCP</a></code> or <code><a href="#topic+entangledMCP">entangledMCP</a></code>.
</p>


<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>References</h3>

<p>Frank Bretz, Willi Maurer, Werner Brannath, Martin Posch: A
graphical approach to sequentially rejective multiple test procedures.
Statistics in Medicine 2009 vol. 28 issue 4 page 586-604.
<a href="https://www.meduniwien.ac.at/fwf_adaptive/papers/bretz_2009_22.pdf">https://www.meduniwien.ac.at/fwf_adaptive/papers/bretz_2009_22.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graphMCP">graphMCP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- BonferroniHolm(5)

rejectNode(g, "H1")

</code></pre>

<hr>
<h2 id='replaceVariables'>Replaces variables in a general graph with specified numeric values</h2><span id='topic+replaceVariables'></span>

<h3>Description</h3>

<p>Given a list of variables and real values a general graph is processed and
each variable replaced with the specified numeric value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replaceVariables(
  graph,
  variables = list(),
  ask = TRUE,
  partial = FALSE,
  expand = TRUE,
  list = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="replaceVariables_+3A_graph">graph</code></td>
<td>
<p>A graph of class <code><a href="#topic+graphMCP">graphMCP</a></code> or class
<code><a href="#topic+entangledMCP">entangledMCP</a></code>.</p>
</td></tr>
<tr><td><code id="replaceVariables_+3A_variables">variables</code></td>
<td>
<p>A named list with one or more specified real values, for example
<code>list(a=0.5, b=0.8, "tau"=0.5)</code> or <code>list(a=c(0.5, 0.8), b=0.8, "tau"=0.5)</code>.  
If <code>ask=TRUE</code> and this list is
missing at all or single variables are missing from the list, the user is
asked for the values (if the session is not interactive an error is thrown).
For interactively entered values only single numbers are supported.</p>
</td></tr>
<tr><td><code id="replaceVariables_+3A_ask">ask</code></td>
<td>
<p>If <code>FALSE</code> all variables that are not specified are not
replaced.</p>
</td></tr>
<tr><td><code id="replaceVariables_+3A_partial">partial</code></td>
<td>
<p>IF <code>TRUE</code> only specified variables are replaced and 
parameter <code>ask</code> is ignored.</p>
</td></tr>
<tr><td><code id="replaceVariables_+3A_expand">expand</code></td>
<td>
<p>Used internally. Don't use yourself.</p>
</td></tr>
<tr><td><code id="replaceVariables_+3A_list">list</code></td>
<td>
<p>If <code>TRUE</code> the result will always be a list, even if only one
graph is returned in this list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A graph or a matrix with variables replaced by the specified numeric
values. Or a list of theses graphs and matrices if a variable had more than one value.
</p>


<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graphMCP">graphMCP</a></code>, <code><a href="#topic+entangledMCP">entangledMCP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

graph &lt;- HungEtWang2010()
## Not run: 
replaceVariables(graph)

## End(Not run)
replaceVariables(graph, list("tau"=0.5,"omega"=0.5, "nu"=0.5))
replaceVariables(graph, list("tau"=c(0.1, 0.5, 0.9),"omega"=c(0.2, 0.8), "nu"=0.4))

</code></pre>

<hr>
<h2 id='rqmvnorm'>Random sample from the multivariate normal distribution</h2><span id='topic+rqmvnorm'></span>

<h3>Description</h3>

<p>Draw a quasi or pseudo random sample from the MVN distribution. For details
on the implemented lattice rule for quasi-random numbers see Cools et al.
(2006).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rqmvnorm(
  n,
  mean = rep(0, nrow(sigma)),
  sigma = diag(length(mean)),
  type = c("quasirandom", "pseudorandom")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rqmvnorm_+3A_n">n</code></td>
<td>
<p>Number of samples, when type = &quot;quasirandom&quot; is used this number is
rounded up to the next power of 2 (e.g. 1000 to 1024=2^10) and at least
1024.</p>
</td></tr>
<tr><td><code id="rqmvnorm_+3A_mean">mean</code></td>
<td>
<p>Mean vector</p>
</td></tr>
<tr><td><code id="rqmvnorm_+3A_sigma">sigma</code></td>
<td>
<p>Covariance matrix</p>
</td></tr>
<tr><td><code id="rqmvnorm_+3A_type">type</code></td>
<td>
<p>What type of random numbers to use. <code>quasirandom</code> uses a
randomized Lattice rule, and should be more efficient than
<code>pseudorandom</code> that uses ordinary (pseudo) random numbers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of simulated values
</p>


<h3>Author(s)</h3>

<p>We thank Dr. Frances Kuo for the permission to use
the generating vectors (order 2 lattice rule) obtained from her website
<a href="https://web.maths.unsw.edu.au/~fkuo/lattice/">https://web.maths.unsw.edu.au/~fkuo/lattice/</a>.
</p>


<h3>References</h3>

<p>Cools, R., Kuo, F. Y., and Nuyens, D. (2006) Constructing
embedded lattice rules for multivariate integration. SIAM Journal of
Scientific Computing, 28, 2162-2188.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sims &lt;- rqmvnorm(100, mean = 1:2, sigma = diag(2))
plot(sims)


</code></pre>

<hr>
<h2 id='sampSize'>Sample size calculations</h2><span id='topic+sampSize'></span>

<h3>Description</h3>

<p>Sample size calculations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampSize(
  graph,
  esf,
  effSize,
  powerReqFunc,
  target,
  corr.sim,
  alpha,
  corr.test = NULL,
  type = c("quasirandom", "pseudorandom"),
  upscale = FALSE,
  n.sim = 10000,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampSize_+3A_graph">graph</code></td>
<td>
<p>A graph of class <code><a href="#topic+graphMCP">graphMCP</a></code>.</p>
</td></tr>
<tr><td><code id="sampSize_+3A_esf">esf</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="sampSize_+3A_effsize">effSize</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="sampSize_+3A_powerreqfunc">powerReqFunc</code></td>
<td>
<p>One power requirement function or a list of these. 
If one is interested in the power to reject hypotheses 1 and 3
one could specify: <br /><code>f=function(x) {x[1] &amp;&amp; x[3]}</code>.<br /> If the power
of rejecting hypotheses 1 and 2 is also of interest one would use a
(optionally named) list: <br /> 
<code>f=list(power1and3=function(x) {x[1] &amp;&amp; x[3]},</code><br />
<code>power1and2=function(x) {x[1] &amp;&amp; x[2]})</code>.
If the list has no names, the functions will be referenced 
to as &quot;func1&quot;, &quot;func2&quot;, etc. in the output.</p>
</td></tr>
<tr><td><code id="sampSize_+3A_target">target</code></td>
<td>
<p>Target power that should be at least achieved. Either a numeric scalar between 0 and 1 or if parameter <code>powerReqFunc</code> is a list a numeric vector of the same length as <code>powerReqFunc</code>.</p>
</td></tr>
<tr><td><code id="sampSize_+3A_corr.sim">corr.sim</code></td>
<td>
<p>Covariance matrix under the alternative.</p>
</td></tr>
<tr><td><code id="sampSize_+3A_alpha">alpha</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="sampSize_+3A_corr.test">corr.test</code></td>
<td>
<p>Correlation matrix that should be used for the parametric test.
If <code>corr.test==NULL</code> the Bonferroni based test procedure is used. Can contain
NAs.</p>
</td></tr>
<tr><td><code id="sampSize_+3A_type">type</code></td>
<td>
<p>What type of random numbers to use. <code>quasirandom</code> uses a
randomized Lattice rule, and should be more efficient than
<code>pseudorandom</code> that uses ordinary (pseudo) random numbers.</p>
</td></tr>
<tr><td><code id="sampSize_+3A_upscale">upscale</code></td>
<td>
<p>Logical. If <code>upscale=FALSE</code> then for each intersection 
of hypotheses (i.e. each subgraph) a weighted test is performed at the 
possibly reduced level alpha of sum(w)*alpha, 
where sum(w) is the sum of all node weights in this subset.
If <code>upscale=TRUE</code> all weights are upscaled, so that sum(w)=1.</p>
</td></tr>
<tr><td><code id="sampSize_+3A_n.sim">n.sim</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="sampSize_+3A_verbose">verbose</code></td>
<td>
<p>Logical, whether verbose output should be printed.</p>
</td></tr>
<tr><td><code id="sampSize_+3A_...">...</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="sampSize_+3A_test">test</code></td>
<td>
<p>In the parametric case there is more than one way to handle
subgraphs with less than the full alpha. If the parameter <code>test</code> is
missing, the tests are performed as described by Bretz et al. (2011), i.e.
tests of intersection null hypotheses always exhaust the full alpha level
even if the sum of weights is strictly smaller than one. If
<code>test="simple-parametric"</code> the tests are performed as defined in
Equation (3) of Bretz et al. (2011).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
graph &lt;- BonferroniHolm(4)
powerReqFunc &lt;- function(x) { (x[1] &amp;&amp; x[2]) || x[3] }
#TODO Still causing errors / loops.
#sampSize(graph, alpha=0.05, powerReqFunc, target=0.8, mean=c(6,4,2) )
#sampSize(graph, alpha=0.05, powerReqFunc, target=0.8, mean=c(-1,-1,-1), nsim=100)
sampSize(graph, esf=c(1,1,1,1), effSize=c(1,1,1,1), 
         corr.sim=diag(4), powerReqFunc=powerReqFunc, target=0.8, alpha=0.05)
powerReqFunc=list('all(x[c(1,2)])'=function(x) {all(x[c(1,2)])},
                  'any(x[c(0,1)])'=function(x) {any(x[c(0,1)])})
sampSize(graph=graph, 
         effSize=list("Scenario 1"=c(2, 0.2, 0.2, 0.2), 
                      "Scenario 2"=c(0.2, 4, 0.2, 0.2)), 
         esf=c(0.5, 0.7071067811865476, 0.5, 0.7071067811865476),
         powerReqFunc=powerReqFunc, 
         corr.sim=diag(4), target=c(0.8, 0.8), alpha=0.025)

## End(Not run)
</code></pre>

<hr>
<h2 id='sampSizeCore'>Function for sample size calculation</h2><span id='topic+sampSizeCore'></span>

<h3>Description</h3>

<p>Function for sample size calculation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampSizeCore(
  upperN,
  lowerN = floor(upperN/2),
  targFunc,
  target,
  tol = 0.001,
  alRatio,
  Ntype = c("arm", "total"),
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampSizeCore_+3A_uppern">upperN</code></td>
<td>
<p><code>targFunc(upperN)</code> should be bigger than target (otherwise <code>upperN</code> is doubled until this is the case).</p>
</td></tr>
<tr><td><code id="sampSizeCore_+3A_lowern">lowerN</code></td>
<td>
<p><code>targFunc(lowerN)</code> should be smaller than target (otherwise <code>lowerN</code> is halfed until this is the case).</p>
</td></tr>
<tr><td><code id="sampSizeCore_+3A_targfunc">targFunc</code></td>
<td>
<p>The target (power) function that should be monotonically increasing in <code>n</code>.</p>
</td></tr>
<tr><td><code id="sampSizeCore_+3A_target">target</code></td>
<td>
<p>The target value. The function searches the <code>n</code> with <code>targFunc(n)-target&lt;tol</code> and <code>targFunc(n)&gt;target</code>.</p>
</td></tr>
<tr><td><code id="sampSizeCore_+3A_tol">tol</code></td>
<td>
<p>Tolerance: The function searches the <code>n</code> with <code>targFunc(n)-target&lt;tol</code> and <code>targFunc(n)&gt;target</code>.</p>
</td></tr>
<tr><td><code id="sampSizeCore_+3A_alratio">alRatio</code></td>
<td>
<p>Allocation ratio.</p>
</td></tr>
<tr><td><code id="sampSizeCore_+3A_ntype">Ntype</code></td>
<td>
<p>Either <code>"arm"</code> or <code>"total"</code>.</p>
</td></tr>
<tr><td><code id="sampSizeCore_+3A_verbose">verbose</code></td>
<td>
<p>Logical, whether verbose output should be printed.</p>
</td></tr>
<tr><td><code id="sampSizeCore_+3A_...">...</code></td>
<td>
<p>...</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details see the manual and examples.
</p>


<h3>Value</h3>

<p>Integer value <code>n</code> (of type numeric) with <code>targFunc(n)-target&lt;tol</code> and <code>targFunc(n)&gt;target</code>.
</p>


<h3>Author(s)</h3>

<p>This function is taken from package DoseFinding under GPL from Bjoern Bornkamp, Jose Pinheiro and Frank Bretz
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- function(x){1/100*log(x)}
gMCP:::sampSizeCore(upperN=1000, targFunc=f, target=0.008, verbose=TRUE, alRatio=1)

</code></pre>

<hr>
<h2 id='secondStageTest'>EXPERIMENTAL: Construct a valid level alpha test for the second stage of an
adaptive design that is based on a pre-planned graphical MCP</h2><span id='topic+secondStageTest'></span>

<h3>Description</h3>

<p>Based on a pre-planned graphical multiple comparison procedure, construct a
valid multiple level alpha test that conserves the family wise error in the
strong sense regardless of any trial adaptations during an unblinded interim
analysis. - Implementation of adaptive procedures is still in an early stage
and may change in the near future
</p>


<h3>Usage</h3>

<pre><code class='language-R'>secondStageTest(
  interim,
  select,
  matchCE = TRUE,
  zWeights = "reject",
  G2 = interim@preplanned
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="secondStageTest_+3A_interim">interim</code></td>
<td>
<p>An object of class <code><a href="#topic+gPADInterim">gPADInterim</a></code>.</p>
</td></tr>
<tr><td><code id="secondStageTest_+3A_select">select</code></td>
<td>
<p>A logical vector giving specifying which hypotheses are
carried forward to the second stage</p>
</td></tr>
<tr><td><code id="secondStageTest_+3A_matchce">matchCE</code></td>
<td>
<p>Logical specifying whether second stage weights should be
computed proportional to corresponding PCEs</p>
</td></tr>
<tr><td><code id="secondStageTest_+3A_zweights">zWeights</code></td>
<td>
<p>Either &quot;reject&quot;,&quot;accept&quot;, or &quot;strict&quot; giving the rule what
should be done in cases where none of the selected hypotheses has positive
second stage weight.</p>
</td></tr>
<tr><td><code id="secondStageTest_+3A_g2">G2</code></td>
<td>
<p>An object of class <code><a href="#topic+graphMCP">graphMCP</a></code> laying down the rule to
compute second stage weights. Defaults to pre-planned graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details see the given references.
</p>


<h3>Value</h3>

<p>A function of signature <code>function(z2)</code> with arguments
<code>z2</code> a numeric vector with second stage z-scores (Z-scores of
dropped hypotheses should be set no <code>NA</code>)
that returns objects of class <code><a href="#topic+gMCPResult">gMCPResult</a></code>.
</p>


<h3>Author(s)</h3>

<p>Florian Klinglmueller <a href="mailto:float@lefant.net">float@lefant.net</a>
</p>


<h3>References</h3>

<p>Frank Bretz, Willi Maurer, Werner Brannath, Martin Posch: A
graphical approach to sequentially rejective multiple test procedures.
Statistics in Medicine 2009 vol. 28 issue 4 page 586-604.
<a href="https://www.meduniwien.ac.at/fwf_adaptive/papers/bretz_2009_22.pdf">https://www.meduniwien.ac.at/fwf_adaptive/papers/bretz_2009_22.pdf</a>
</p>
<p>Bretz F., Posch M., Glimm E., Klinglmueller F., Maurer W., Rohmeyer K.
(2011): Graphical approaches for multiple endpoint problems using weighted
Bonferroni, Simes or parametric tests - to appear.
</p>
<p>Posch M, Futschik A (2008): A Uniform Improvement of Bonferroni-Type Tests
by Sequential Tests JASA 103/481, 299-308
</p>
<p>Posch M, Maurer W, Bretz F (2010): Type I error rate control in adaptive
designs for confirmatory clinical trials with treatment selection at interim
Pharm Stat 10/2, 96-104
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graphMCP">graphMCP</a></code>, <code><a href="#topic+doInterim">doInterim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Simple successive graph (Maurer et al. 2011)
## two treatments two hierarchically ordered endpoints
a &lt;- .025
G &lt;- simpleSuccessiveI()
## some z-scores:

p1=c(.1,.12,.21,.16)
z1 &lt;- qnorm(1-p1)
p2=c(.04,1,.14,1)
z2 &lt;- qnorm(1-p2)
v &lt;- c(1/2,1/3,1/2,1/3)

intA &lt;- doInterim(G,z1,v)

## select only the first treatment 
fTest &lt;- secondStageTest(intA,c(1,0,1,0))



</code></pre>

<hr>
<h2 id='simConfint'>
Simultaneous confidence intervals for sequentially rejective multiple test procedures
</h2><span id='topic+simConfint'></span><span id='topic+simConfint+2CgraphMCP-method'></span>

<h3>Description</h3>

<p>Calculates simultaneous confidence intervals for sequentially rejective multiple test procedures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	simConfint(object, pvalues, confint, alternative=c("less", "greater"), 
             estimates, df, alpha=0.05, mu=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simConfint_+3A_object">object</code></td>
<td>

<p>A graph of class <code><a href="#topic+graphMCP">graphMCP</a></code>.
</p>
</td></tr>  
<tr><td><code id="simConfint_+3A_pvalues">pvalues</code></td>
<td>

<p>A numeric vector specifying the p-values for the sequentially rejective MTP.
</p>
</td></tr> 
<tr><td><code id="simConfint_+3A_confint">confint</code></td>
<td>

<p>One of the following:
A character string <code>"normal"</code>, <code>"t"</code> or a function that 
calculates the confidence intervals.
If <code>confint=="t"</code> the parameter <code>df</code> must be specified. 
If <code>confint</code> is a function it must be of signature 
<code>("character", "numeric")</code>,	where the first parameter is the 
hypothesis name and the second the marginal confidence level (see examples).
</p>
</td></tr>  
<tr><td><code id="simConfint_+3A_alternative">alternative</code></td>
<td>

<p>A character string specifying the alternative hypothesis,
must be &quot;greater&quot; or &quot;less&quot;.
</p>
</td></tr>
<tr><td><code id="simConfint_+3A_estimates">estimates</code></td>
<td>

<p>Point estimates for the parameters of interest.
</p>
</td></tr>  
<tr><td><code id="simConfint_+3A_df">df</code></td>
<td>

<p>Degree of freedom as numeric.
</p>
</td></tr>
<tr><td><code id="simConfint_+3A_alpha">alpha</code></td>
<td>

<p>The overall alpha level as numeric scalar.
</p>
</td></tr>
<tr><td><code id="simConfint_+3A_mu">mu</code></td>
<td>

<p>The numerical parameter vector under null hypothesis.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details see the given references.
</p>


<h3>Value</h3>

<p>A matrix with columns giving lower confidence limits, point estimates and upper
confidence limits for each parameter. These will be labeled as
&quot;lower bound&quot;, &quot;estimate&quot; and &quot;upper bound&quot;.
</p>


<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>References</h3>

<p>Frank Bretz, Willi Maurer, Werner Brannath, Martin Posch:
A graphical approach to sequentially rejective multiple test procedures.
Statistics in Medicine 2009 vol. 28 issue 4 page 586-604. 
<a href="http://www.meduniwien.ac.at/fwf_adaptive/papers/bretz_2009_22.pdf">http://www.meduniwien.ac.at/fwf_adaptive/papers/bretz_2009_22.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graphMCP">graphMCP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
est &lt;- c("H1"=0.860382, "H2"=0.9161474, "H3"=0.9732953)
# Sample standard deviations:
ssd &lt;- c("H1"=0.8759528, "H2"=1.291310, "H3"=0.8570892)

pval &lt;- c(0.01260, 0.05154, 0.02124)/2

simConfint(BonferroniHolm(3), pvalues=pval, 
		confint=function(node, alpha) {
			c(est[node]-qt(1-alpha,df=9)*ssd[node]/sqrt(10), Inf)
		}, estimates=est, alpha=0.025, mu=0, alternative="greater")

# Note that the sample standard deviations in the following call
# will be calculated from the pvalues and estimates.
ci &lt;- simConfint(BonferroniHolm(3), pvalues=pval, 
		confint="t", df=9, estimates=est, alpha=0.025, alternative="greater")
ci
	
plotSimCI(ci)

</code></pre>

<hr>
<h2 id='simes.on.subsets.test'>Simes on subsets, otherwise Bonferroni</h2><span id='topic+simes.on.subsets.test'></span>

<h3>Description</h3>

<p>Weighted Simes test introduced by Benjamini and Hochberg (1997)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simes.on.subsets.test(
  pvalues,
  weights,
  alpha = 0.05,
  adjPValues = TRUE,
  verbose = FALSE,
  subsets,
  subset,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simes.on.subsets.test_+3A_pvalues">pvalues</code></td>
<td>
<p>A numeric vector specifying the p-values.</p>
</td></tr>
<tr><td><code id="simes.on.subsets.test_+3A_weights">weights</code></td>
<td>
<p>A numeric vector of weights.</p>
</td></tr>
<tr><td><code id="simes.on.subsets.test_+3A_alpha">alpha</code></td>
<td>
<p>A numeric specifying the maximal allowed type one error rate. If <code>adjPValues==TRUE</code> (default) the parameter <code>alpha</code> is not used.</p>
</td></tr>
<tr><td><code id="simes.on.subsets.test_+3A_adjpvalues">adjPValues</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code> (the default) an adjusted p-value for the weighted test is returned.
Otherwise if <code>adjPValues==FALSE</code> a logical value is returned whether the null hypothesis can be rejected.</p>
</td></tr>
<tr><td><code id="simes.on.subsets.test_+3A_verbose">verbose</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code> verbose output is generated.</p>
</td></tr>
<tr><td><code id="simes.on.subsets.test_+3A_subsets">subsets</code></td>
<td>
<p>A list of subsets given by numeric vectors containing the indices of the elementary hypotheses for which the weighted Simes test is applicable.</p>
</td></tr>
<tr><td><code id="simes.on.subsets.test_+3A_subset">subset</code></td>
<td>
<p>A numeric vector containing the numbers of the indices of the currently tested elementary hypotheses.</p>
</td></tr>
<tr><td><code id="simes.on.subsets.test_+3A_...">...</code></td>
<td>
<p>Further arguments possibly passed by <code>gMCP</code> which will be used by other test procedures but not this one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As an additional argument a list of subsets must be provided, that states in which cases a Simes test is applicable (i.e. if all hypotheses to test belong to one of these subsets), e.g.
subsets &lt;- list(c(&quot;H1&quot;, &quot;H2&quot;, &quot;H3&quot;), c(&quot;H4&quot;, &quot;H5&quot;, &quot;H6&quot;))
Trimmed Simes test for intersections of two hypotheses and otherwise weighted Bonferroni-test
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simes.on.subsets.test(pvalues=c(0.1,0.2,0.05), weights=c(0.5,0.5,0))
simes.on.subsets.test(pvalues=c(0.1,0.2,0.05), weights=c(0.5,0.5,0), adjPValues=FALSE)

graph &lt;- BonferroniHolm(4)
pvalues &lt;- c(0.01, 0.05, 0.03, 0.02)

gMCP.extended(graph=graph, pvalues=pvalues, test=simes.on.subsets.test, subsets=list(1:2, 3:4))

</code></pre>

<hr>
<h2 id='simes.test'>Weighted Simes test</h2><span id='topic+simes.test'></span>

<h3>Description</h3>

<p>Weighted Simes test introduced by Benjamini and Hochberg (1997)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simes.test(
  pvalues,
  weights,
  alpha = 0.05,
  adjPValues = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simes.test_+3A_pvalues">pvalues</code></td>
<td>
<p>A numeric vector specifying the p-values.</p>
</td></tr>
<tr><td><code id="simes.test_+3A_weights">weights</code></td>
<td>
<p>A numeric vector of weights.</p>
</td></tr>
<tr><td><code id="simes.test_+3A_alpha">alpha</code></td>
<td>
<p>A numeric specifying the maximal allowed type one error rate. If <code>adjPValues==TRUE</code> (default) the parameter <code>alpha</code> is not used.</p>
</td></tr>
<tr><td><code id="simes.test_+3A_adjpvalues">adjPValues</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code> (the default) an adjusted p-value for the weighted Simes test is returned.
Otherwise if <code>adjPValues==FALSE</code> a logical value is returned whether the null hypothesis can be rejected.</p>
</td></tr>
<tr><td><code id="simes.test_+3A_verbose">verbose</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code> verbose output is generated.</p>
</td></tr>
<tr><td><code id="simes.test_+3A_...">...</code></td>
<td>
<p>Further arguments possibly passed by <code>gMCP</code> which will be used by other test procedures but not this one.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
simes.test(pvalues=c(0.1,0.2,0.05), weights=c(0.5,0.5,0))
simes.test(pvalues=c(0.1,0.2,0.05), weights=c(0.5,0.5,0), adjPValues=FALSE)

</code></pre>

<hr>
<h2 id='simvastatin'>Simvastatin and Colesevelam Treatment in Patients with Primary Hypercholesterolemia</h2><span id='topic+simvastatin'></span>

<h3>Description</h3>

<p>This data set gives the results from a study investigating the 
efficacy and safety of simvastatin and colesevelam treatment in patients with primary hypercholesterolemia.
It shows the sample sizes, the mean LDL cholesterol levels and the number of patients with adverse events after 6 weeks. 
The treatment groups are: The Placebo control,
two doses 10 mg and 20 mg of simvastatin and an combined treatment 20 mg + 2.3 g colesevelam. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simvastatin)</code></pre>


<h3>Format</h3>

<p>A data frame with a summary table for ...:
</p>

<dl>
<dt>group</dt><dd><p>A factor with levels &quot;Placebo&quot;, &quot;10 mg&quot;, &quot;20 mg&quot;, &quot;20 mg + 2.3 g Colesevelam&quot; specifying the groups.</p>
</dd>
<dt>sampleSize</dt><dd><p>A numeric vector, giving the number of patients in the groups.</p>
</dd>
<dt>means</dt><dd><p>A numeric vector, giving the mean LDL cholesterol levels.</p>
</dd>
<dt>sd</dt><dd><p>A numeric vector, giving the standard deviation of the LDL cholesterol levels.</p>
</dd>
<dt>adverseEvents</dt><dd><p>An integer vector, giving the number of patients with adverse events after 6 weeks.</p>
</dd>
</dl>



<h3>Source</h3>

  
<p>Knapp, H.H. and Schrott, H. and Ma, P. and Knopp, R. and Chin, B. and Gaziano, J.M. and Donovan, J.M. and Burke, S.K. and Davidson, M.H. (2001):
<em>Efficacy and safety of combination simvastatin and colesevelam in patients with primary hypercholesterolemia</em>
The American journal of medicine 110, 352-360.
</p>


<h3>References</h3>

<p>Bretz, F., Hothorn, L. A. and Hsu, J. C. (2003): 
<em>Identifying effective and/or safe doses by stepwise confidence intervals for ratios</em>
Statistics in Medicine 22, 847-858.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(simvastatin)
  barplot(simvastatin$means, names.arg=simvastatin$group)
</code></pre>

<hr>
<h2 id='subgraph'>Get a subgraph</h2><span id='topic+subgraph'></span>

<h3>Description</h3>

<p>Given a set of nodes and a graph this function creates the subgraph
containing only the specified nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subgraph(graph, subset)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subgraph_+3A_graph">graph</code></td>
<td>
<p>A graph of class <code><a href="#topic+graphMCP">graphMCP</a></code>.</p>
</td></tr>
<tr><td><code id="subgraph_+3A_subset">subset</code></td>
<td>
<p>A logical or character vector specifying the nodes in the
subgraph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A subgraph containing only the specified nodes.
</p>


<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graphMCP">graphMCP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

graph &lt;- improvedParallelGatekeeping()
subgraph(graph, c(TRUE, FALSE, TRUE, FALSE))
subgraph(graph, c("H1", "H3"))


</code></pre>

<hr>
<h2 id='substituteEps'>Substitute Epsilon</h2><span id='topic+substituteEps'></span>

<h3>Description</h3>

<p>Substitute Epsilon with a given value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>substituteEps(graph, eps = 10^(-3))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="substituteEps_+3A_graph">graph</code></td>
<td>
<p>A graph of class <code><a href="#topic+graphMCP">graphMCP</a></code> or class
<code><a href="#topic+entangledMCP">entangledMCP</a></code>.</p>
</td></tr>
<tr><td><code id="substituteEps_+3A_eps">eps</code></td>
<td>
<p>A numeric scalar specifying a value for epsilon edges.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details see the given references.
</p>


<h3>Value</h3>

<p>A graph where all epsilons have been replaced with the given value.
</p>


<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graphMCP">graphMCP</a></code>, <code><a href="#topic+entangledMCP">entangledMCP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

graph &lt;- improvedParallelGatekeeping()
graph
substituteEps(graph, eps=0.01)


</code></pre>

<hr>
<h2 id='unitTestsGMCP'>Run the R unit (and optional the JUnit) test suite for gMCP</h2><span id='topic+unitTestsGMCP'></span>

<h3>Description</h3>

<p>Runs the R unit (and optional the JUnit) test suite for gMCP and prints the
results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unitTestsGMCP(
  extended = FALSE,
  java = FALSE,
  interactive = FALSE,
  junitLibrary,
  outputPath
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unitTestsGMCP_+3A_extended">extended</code></td>
<td>
<p>If <code>TRUE</code> (or if the environment variable
GMCP_UNIT_TESTS equals &quot;extended&quot; or &quot;all&quot;) an extended version of the R
unit test suite for gMCP will be used.  The run will take significantly
longer time.</p>
</td></tr>
<tr><td><code id="unitTestsGMCP_+3A_java">java</code></td>
<td>
<p>If <code>TRUE</code> (or if the environment variable
GMCP_UNIT_TESTS equals &quot;java&quot; or &quot;all&quot;) the GUI and its logic is tested with JUnit tests.
You need JUnit 4 classes in the classpath or specify the path to a JUnit 4
jar file via the parameter junitLibrary.</p>
</td></tr>
<tr><td><code id="unitTestsGMCP_+3A_interactive">interactive</code></td>
<td>
<p>If <code>TRUE</code> (or if the environment variable
GMCP_UNIT_TESTS equals &quot;interactive&quot; or &quot;all&quot;) the interactive part of the RUnit tests is
run.  The user have to look at results and answer questions.</p>
</td></tr>
<tr><td><code id="unitTestsGMCP_+3A_junitlibrary">junitLibrary</code></td>
<td>
<p>A character String specifying the path to a JUnit 4 jar
file to run the JUnit tests.  You can download it from
<a href="https://junit.org/">https://junit.org/</a>.  Alternatively you can use the environment
variable GMCP_JUNIT_LIBRARY to specify the path.</p>
</td></tr>
<tr><td><code id="unitTestsGMCP_+3A_outputpath">outputPath</code></td>
<td>
<p>During the RUnit tests files maybe produced at this
location.  If missing the current working directory is used if nothing else
is specified in the environment variable GMCP_UNIT_TEST_OPATH.
Also the log of the results of the test suite is saved in this place.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The environment variable GMCP_UNIT_TESTS may be used to specify which
unit tests should run: &quot;extended&quot;, &quot;interactive&quot;, &quot;java&quot; or a combination
of these separated by comma (without blanks). A short cut for all three is
&quot;all&quot;.
</p>


<h3>Value</h3>

<p>None of interest so far - the function prints the results to the
standard output.  (Perhaps in future versions a value will be returned that
can be processed by the GUI.)
</p>


<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 
unitTestsGMCP()
unitTestsGMCP(extended=TRUE, java=TRUE, interactive=TRUE, outputPath="~/RUnitTests")


## End(Not run)


</code></pre>

<hr>
<h2 id='weighted.test.functions'>Weighted Test Functions for use with gMCP</h2><span id='topic+weighted.test.functions'></span>

<h3>Description</h3>

<p>The package gMCP provides the following weighted test functions:
</p>

<dl>
<dt>bonferroni.test</dt><dd><p>Bonferroni test - see <code>?bonferroni.test</code> for details.</p>
</dd>
<dt>parametric.test</dt><dd><p>Parametric test - see <code>?parametric.test</code> for details.</p>
</dd>
<dt>simes.test</dt><dd><p>Simes test - see <code>?simes.test</code> for details.</p>
</dd>
<dt>bonferroni.trimmed.simes.test</dt><dd><p>Trimmed Simes test for intersections of two hypotheses and otherwise Bonferroni - see <code>?bonferroni.trimmed.simes.test</code> for details.</p>
</dd>
<dt>simes.on.subsets.test</dt><dd><p>Simes test for intersections of hypotheses from certain sets and otherwise Bonferroni - see <code>?simes.on.subsets.test</code> for details.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Depending on whether <code>adjPValues==TRUE</code> these test functions return different values:
</p>

<ul>
<li><p> If <code>adjPValues==TRUE</code> the minimal value for alpha is returned for which the null hypothesis can be rejected. If that's not possible (for example in case of the trimmed Simes test adjusted p-values can not be calculated), the test function may throw an error.
</p>
</li>
<li><p> If <code>adjPValues==FALSE</code> a logical value is returned whether the null hypothesis can be rejected.
</p>
</li></ul>

<p>To provide your own test function write a function that takes at least the following arguments:
</p>

<dl>
<dt>pvalues</dt><dd><p>A numeric vector specifying the p-values.</p>
</dd>
<dt>weights</dt><dd><p>A numeric vector of weights.</p>
</dd>
<dt>alpha</dt><dd><p>A numeric specifying the maximal allowed type one error rate. If <code>adjPValues==TRUE</code> (default) the parameter <code>alpha</code> should not be used.</p>
</dd>
<dt>adjPValues</dt><dd><p>Logical scalar. If <code>TRUE</code> an adjusted p-value for the weighted test is returned (if possible - if not the function should call <code>stop</code>).
Otherwise if <code>adjPValues==FALSE</code> a logical value is returned whether the null hypothesis can be rejected.</p>
</dd>
<dt>...</dt><dd><p> Further arguments possibly passed by <code>gMCP</code> which will be used by other test procedures but not this one.</p>
</dd>
</dl>

<p>Further the following parameters have a predefined meaning:
</p>

<dl>
<dt>verbose</dt><dd><p>Logical scalar. If <code>TRUE</code> verbose output should be generated and printed to the standard output</p>
</dd>
<dt>subset</dt><dd></dd>
<dt>correlation</dt><dd></dd>
</dl>



<h3>Author(s)</h3>

<p>Kornelius Rohmeyer <a href="mailto:rohmeyer@small-projects.de">rohmeyer@small-projects.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The test function 'bonferroni.test' is used in by gMCP in the following call:
graph &lt;- BonferroniHolm(4)
pvalues &lt;- c(0.01, 0.05, 0.03, 0.02)
alpha &lt;- 0.05
r &lt;- gMCP.extended(graph=graph, pvalues=pvalues, test=bonferroni.test, verbose=TRUE)

# For the intersection of all four elementary hypotheses this results in a call
bonferroni.test(pvalues=pvalues, weights=getWeights(graph))
bonferroni.test(pvalues=pvalues, weights=getWeights(graph), adjPValues=FALSE)

# bonferroni.test function: 
bonferroni.test &lt;- function(pvalues, weights, alpha=0.05, adjPValues=TRUE, verbose=FALSE, ...) {
  if (adjPValues) {
    return(min(pvalues/weights))
  } else {
    return(any(pvalues&lt;=alpha*weights))
  }
}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
