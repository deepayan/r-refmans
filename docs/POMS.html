<!DOCTYPE html><html lang="en"><head><title>Help for package POMS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {POMS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#abun_isometric_log_ratios'><p>Compute isometric log ratio based on abundance of feature sets</p></a></li>
<li><a href='#compute_node_balances'><p>Compute balances at tree nodes.</p></a></li>
<li><a href='#filter_rare_table_cols'><p>Filters out columns of dataframe based on number of proportion of non-zero cells</p></a></li>
<li><a href='#genome_content_phylo_regress'><p>Phylogenetic regression of input vector against function presence/absence.</p></a></li>
<li><a href='#node_taxa'><p>Determine taxa labels of tips on each side of a node<br /></p></a></li>
<li><a href='#phylolm_summary'><p>Wrapper for running phylogenetic regression with phylolm<br /></p></a></li>
<li><a href='#POMS_pipeline'><p>Main function to run POMS pipeline</p></a></li>
<li><a href='#prep_func_node_info'><p>Get node indices of FSN and BSN categories across tree for a given function</p></a></li>
<li><a href='#prevalence_norm_logit'><p>Compute additive smoothed prevalence of features (e.g, taxa), restricted to samples of a particular metadata category.<br /></p></a></li>
<li><a href='#specificity_scores'><p>Compute shrunken specificity score of a feature, which represents how the presence of a feature is associated with a given sample grouping.</p></a></li>
<li><a href='#subset_by_col_and_filt'><p>Subset dataframe by column names and then post-filter</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Phylogenetic Organization of Metagenomic Signals</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Code to identify functional enrichments across diverse taxa
    in phylogenetic tree, particularly where these taxa differ in
    abundance across samples in a non-random pattern. The motivation for
    this approach is to identify microbial functions encoded by diverse
    taxa that are at higher abundance in certain samples compared to
    others, which could indicate that such functions are broadly adaptive
    under certain conditions. See 'GitHub' repository for tutorial and
    examples: <a href="https://github.com/gavinmdouglas/POMS/wiki">https://github.com/gavinmdouglas/POMS/wiki</a>. Citation: Gavin M. Douglas, Molly G. Hayes, Morgan G. I. Langille, Elhanan Borenstein (2022) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtac655">doi:10.1093/bioinformatics/btac655</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>ape (&ge; 3.0), data.table, MASS, parallel (&ge; 3.3.0), phangorn
(&ge; 2.0.0), phylolm (&ge; 2.6), utils, XNomial (&ge; 1.0.4)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-13 14:44:20 UTC; gavin</td>
</tr>
<tr>
<td>Author:</td>
<td>Gavin Douglas [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gavin Douglas &lt;gavinmdouglas@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-14 11:40:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='abun_isometric_log_ratios'>Compute isometric log ratio based on abundance of feature sets</h2><span id='topic+abun_isometric_log_ratios'></span>

<h3>Description</h3>

<p>Computes isometric log ratio between two sets of feature abundances, for each sample separately. Requires an abundance table,
with two sets of features for which the ratio will be computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abun_isometric_log_ratios(
  abun_table,
  set1_features,
  set2_features,
  pseudocount = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="abun_isometric_log_ratios_+3A_abun_table">abun_table</code></td>
<td>
<p>Abundance table, e.g., read counts or relative abundance.
Should be dataframe with column names correspond to sample names and row names corresponding to the feature ids.
No 0's are permitted unless the &quot;pseudocount&quot; option is set.</p>
</td></tr>
<tr><td><code id="abun_isometric_log_ratios_+3A_set1_features">set1_features</code></td>
<td>
<p>Features (rows of abundance table) that make up one side of the ratio to be computed (numerator).</p>
</td></tr>
<tr><td><code id="abun_isometric_log_ratios_+3A_set2_features">set2_features</code></td>
<td>
<p>Same as &quot;set1_features&quot;, but for the other side of the ratio (denominator).</p>
</td></tr>
<tr><td><code id="abun_isometric_log_ratios_+3A_pseudocount">pseudocount</code></td>
<td>
<p>Constant to add to all abundance values, to ensure that there are only non-zero values. For read count data this would typically be 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of the computed isometric log ratio for each sample (where samples are taken to be each column in the input table).
</p>

<hr>
<h2 id='compute_node_balances'>Compute balances at tree nodes.</h2><span id='topic+compute_node_balances'></span>

<h3>Description</h3>

<p>Computes balances (i.e., isometric log ratios, for each sample separately) of feature abundances at each non-negligible node in the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_node_balances(
  tree,
  abun_table,
  min_num_tips = 10,
  ncores = 1,
  pseudocount = NULL,
  derep_nodes = FALSE,
  jaccard_cutoff = 0.75,
  subset_to_test = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_node_balances_+3A_tree">tree</code></td>
<td>
<p>Phylo object with tip labels matching row names of input abundance table. Note that node labels are required.</p>
</td></tr>
<tr><td><code id="compute_node_balances_+3A_abun_table">abun_table</code></td>
<td>
<p>Abundance table, e.g., read counts or relative abundance.
Should be dataframe with column names correspond to sample names and row names corresponding to the tips of the tree.
No 0's are permitted unless the &quot;pseudocount&quot; option is set.</p>
</td></tr>
<tr><td><code id="compute_node_balances_+3A_min_num_tips">min_num_tips</code></td>
<td>
<p>Minimum number of tips that must be found on each side of a node for it to be included (i.e., to be considered non-negligible).</p>
</td></tr>
<tr><td><code id="compute_node_balances_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use for steps of function that can be run in parallel.</p>
</td></tr>
<tr><td><code id="compute_node_balances_+3A_pseudocount">pseudocount</code></td>
<td>
<p>Optional constant to add to all abundance values, to ensure that there are only non-zero values. For read count data this would typically be 1.</p>
</td></tr>
<tr><td><code id="compute_node_balances_+3A_derep_nodes">derep_nodes</code></td>
<td>
<p>Boolean setting to specify whether nodes should be dereplicated based on the Jaccard similarity of the underlying tips.
When TRUE, nodes with pairwise Jaccard similarity &gt;= jaccard_cutoff will be collapsed into the same cluster. A node will be added to a cluster if it is adequately similar to any nodes in a cluster.
One representative per cluster will be retained, which will correspond to the node with the fewest underlying tips. Note that this step is performed after the step involving the min_num_tips screening.</p>
</td></tr>
<tr><td><code id="compute_node_balances_+3A_jaccard_cutoff">jaccard_cutoff</code></td>
<td>
<p>Numeric vector of length 1. Must be between 0 and 1 (inclusive). Corresponds to the Jaccard cut-off used for clustering nodes based on similar sets of underlying tips.</p>
</td></tr>
<tr><td><code id="compute_node_balances_+3A_subset_to_test">subset_to_test</code></td>
<td>
<p>Optional vector of node labels (<em>not indices</em>) that correspond to the subset of nodes that should be considered.
Note that balances will still only be computed at each of these nodes if they have a sufficient number of underlying tips (as specified by the &quot;min_num_tips&quot; argument).
If this argument is not specified then all nodes will be considered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing three objects:
</p>
<p>&quot;tips_underlying_nodes&quot;: the tips on the left-hand side (lhs; the numerator) and right-hand side (rhs; the denominator) of each node.
Note that which side of the node is denoted as the left-hand or right-hand side is arbitrary.
</p>
<p>&quot;balances&quot;: list with each non-negligible node as a separate element. The sample balances for each node are provided as a numeric vector within each of these elements.
</p>
<p>&quot;negligible_nodes&quot;: character vector of node labels considered negligible. This is defined as those with fewer tips on either side of the node than specified by the &quot;min_num_tips&quot; argument.
</p>
<p>When derep_nodes = TRUE, additional elements will also be returned:
</p>
<p>&quot;ignored_redundant_nodes&quot;: character vector of (non-negligible) node labels ignored due to being in sharing high Jaccard similarity with at least one other node.
</p>
<p>&quot;node_pairwise_jaccard&quot;: dataframe of pairwise Jaccard similarity for all non-negligible nodes.
</p>
<p>&quot;node_clusters&quot;: list with the node labels clustered into each unique cluster of nodes based on Jaccard similarities.
Each list element is a separate cluster for which only one node was selected as a representative (whichever one had the fewest underlying tips).
</p>

<hr>
<h2 id='filter_rare_table_cols'>Filters out columns of dataframe based on number of proportion of non-zero cells</h2><span id='topic+filter_rare_table_cols'></span>

<h3>Description</h3>

<p>Filters dataframe columns with either a low absolute count of non-zero values or a low proportion of rows with non-zero counts.
Note that this function is intended for positively-bounded data only (e.g., the function or taxon abundance tables), and will not work properly
if the table contains negative values. Included in package simply to make running workflow easier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_rare_table_cols(
  in_tab,
  min_nonzero_count,
  min_nonzero_prop,
  drop_missing_rows = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_rare_table_cols_+3A_in_tab">in_tab</code></td>
<td>
<p>input dataframe</p>
</td></tr>
<tr><td><code id="filter_rare_table_cols_+3A_min_nonzero_count">min_nonzero_count</code></td>
<td>
<p>minimum number of cells in column that must be non-zero for column to be retained.</p>
</td></tr>
<tr><td><code id="filter_rare_table_cols_+3A_min_nonzero_prop">min_nonzero_prop</code></td>
<td>
<p>minimum proportion of cells in column that must be non-zero for column to be retained.</p>
</td></tr>
<tr><td><code id="filter_rare_table_cols_+3A_drop_missing_rows">drop_missing_rows</code></td>
<td>
<p>boolean flag to indicate whether rows with all zero values (after dropping columns based on specified cut-offs) should be removed.</p>
</td></tr>
<tr><td><code id="filter_rare_table_cols_+3A_verbose">verbose</code></td>
<td>
<p>boolean flag to indicate that the number of columns removed should be written to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe with columns that did not meet the <code>min_nonzero_count</code> and/or <code>min_nonzero_prop</code> options removed (and potentially rows dropped too if drop_missing_rows=TRUE).
</p>

<hr>
<h2 id='genome_content_phylo_regress'>Phylogenetic regression of input vector against function presence/absence.</h2><span id='topic+genome_content_phylo_regress'></span>

<h3>Description</h3>

<p>Runs phylogenetic regression with phylolm on each function (or trait) in the specified function table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genome_content_phylo_regress(y, func, in_tree, ncores = 1, model_type = "BM")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genome_content_phylo_regress_+3A_y">y</code></td>
<td>
<p>variable to use for y component of model. Typically would be either a binary vector indicating which taxa are significantly different, or the normalized specicity or normalized prevalence values.
Must be a named numeric vector with names matching the rows of the func dataframe.
These names also must match the tree tip labels, but they can be a subset and any missing tips will be dropped.</p>
</td></tr>
<tr><td><code id="genome_content_phylo_regress_+3A_func">func</code></td>
<td>
<p>dataframe of the number of copies of each function that are encoded by each input taxon.
This pipeline only considers the presence/absence of functions across taxa.
Taxa (with row names intersecting with the &quot;abun&quot; table) should be the rows and the functions should be the columns.</p>
</td></tr>
<tr><td><code id="genome_content_phylo_regress_+3A_in_tree">in_tree</code></td>
<td>
<p>phylo object. Tip labels must include the row names of the func dataframe and the names of the y input vector.</p>
</td></tr>
<tr><td><code id="genome_content_phylo_regress_+3A_ncores">ncores</code></td>
<td>
<p>integer specifying how many cores to use for parallelized sections of pipeline.</p>
</td></tr>
<tr><td><code id="genome_content_phylo_regress_+3A_model_type">model_type</code></td>
<td>
<p>length-one character vector specifying which phylogenetic model to use (must be a possible setting of the model argument to the phylolm function).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe summarizing the phylolm coefficients and model p-values for each y ~ function comparison.
Will include the intercept, slope, and p-value for each case. Row names will be function ids.
</p>

<hr>
<h2 id='node_taxa'>Determine taxa labels of tips on each side of a node<br /></h2><span id='topic+node_taxa'></span>

<h3>Description</h3>

<p>Takes in a tree, a table of taxa labels per tip, and either a node label or index.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_taxa(
  in_tree,
  taxon_labels,
  node_label = NULL,
  node_index = NULL,
  threshold = 0.75,
  combine_labels = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="node_taxa_+3A_in_tree">in_tree</code></td>
<td>
<p>Phylo object</p>
</td></tr>
<tr><td><code id="node_taxa_+3A_taxon_labels">taxon_labels</code></td>
<td>
<p>Dataframe of taxa labels for tips in tree.
All tips underlying the specified node must be present, although typically all tips in the tree would be present.
Row names must be the tip labels. The column names correspond to each taxonomic level, such as Kingdom, Phylum, etc.
The actual column names do not matter: it is just important that the order of the taxonomic levels goes from the highest taxonomic level present (e.g., Kingdom), to the lowest taxonomic level present (e.g., Species).</p>
</td></tr>
<tr><td><code id="node_taxa_+3A_node_label">node_label</code></td>
<td>
<p>Optional label of node for which the representative taxon label will be determined. Either this option or the node_index option must be specified, but not both.</p>
</td></tr>
<tr><td><code id="node_taxa_+3A_node_index">node_index</code></td>
<td>
<p>As above for the node_label option, but to specify a node by index rather than by label.</p>
</td></tr>
<tr><td><code id="node_taxa_+3A_threshold">threshold</code></td>
<td>
<p>Float &gt; 0.5 and &lt;= 1.0 specifying the proportion of tips that must share a taxon label for it to be considered representative.</p>
</td></tr>
<tr><td><code id="node_taxa_+3A_combine_labels">combine_labels</code></td>
<td>
<p>Boolean flag for whether taxon labels should be combined, so that all higher taxonomic labels are included.
Specifically, when TRUE, all higher labels are concatenated and delimited by &quot;; &quot;.
E.g., rather than just the genus &quot;Odoribacter&quot; the label would be &quot;Bacteria; Bacteroidetes; Bacteroidia; Bacteroidales; Porphyromonadaceae; Odoribacter&quot;,
given that those were the labels of the higher taxonomic levels of that genus.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>The format of the taxa label table is very important to note: it must have the tips as the rownames and taxonomic levels (ranging from highest to lowest) as the column names</strong>.
</p>
<p>For each side of the specified node separately, this function returns the lowest possible taxon label shared by at
least the specified proportion of tips (set by the &quot;threshold&quot; variable). Will return &quot;Unclear&quot; if there is no applicable taxon.<br />
</p>
<p>To clarify, the taxon that meets the threshold at the lowest possible taxonomic level will be used as the representative label.
For example, if all the tips on one side of the node are members of the Pseudomonas genus, but only 60% are members of the Pseudomonas aeruginosa species specifically,
then Pseudomonas will be used as the representative label (based on a threshold of 0.75 or higher and assuming that species are the last column in the table).
</p>


<h3>Value</h3>

<p>Character vector of size two with the representative taxon for tips on each side of the specified node.
</p>

<hr>
<h2 id='phylolm_summary'>Wrapper for running phylogenetic regression with phylolm<br /></h2><span id='topic+phylolm_summary'></span>

<h3>Description</h3>

<p>Runs basic case of single x and y variables (dummy or continuous). Note that the ordering of the input vectors
and the tree tip labels needs to be checked by the user beforehand:
this script does not require that the y and x variables are named, and so no name check is performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylolm_summary(y, x, in_tree, model_type = "BM")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="phylolm_summary_+3A_y">y</code></td>
<td>
<p>variable to use for y component of model.</p>
</td></tr>
<tr><td><code id="phylolm_summary_+3A_x">x</code></td>
<td>
<p>variable to use for x component of model.</p>
</td></tr>
<tr><td><code id="phylolm_summary_+3A_in_tree">in_tree</code></td>
<td>
<p>phylo object. Tip label order is assumed to match the y and x variables.</p>
</td></tr>
<tr><td><code id="phylolm_summary_+3A_model_type">model_type</code></td>
<td>
<p>length-one character vector specifying which phylogenetic model to use (must be a possible setting of the model argument to the phylolm function).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of length three, providing the estimated coefficients for the intercept and slope, along with the p-value.
</p>

<hr>
<h2 id='POMS_pipeline'>Main function to run POMS pipeline</h2><span id='topic+POMS_pipeline'></span>

<h3>Description</h3>

<p>See details below.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>POMS_pipeline(
  abun,
  func,
  tree,
  group1_samples = NULL,
  group2_samples = NULL,
  ncores = 1,
  pseudocount = 1,
  manual_BSNs = NULL,
  manual_balances = NULL,
  manual_BSN_dir = NULL,
  min_num_tips = 10,
  min_func_instances = 10,
  min_func_prop = 0.001,
  multinomial_min_FSNs = 5,
  derep_nodes = FALSE,
  jaccard_cutoff = 0.75,
  BSN_p_cutoff = 0.05,
  BSN_correction = "none",
  FSN_p_cutoff = 0.05,
  FSN_correction = "none",
  func_descrip_infile = NULL,
  multinomial_correction = "BH",
  detailed_output = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="POMS_pipeline_+3A_abun">abun</code></td>
<td>
<p>dataframe of taxa abundances that are at the tips of the input tree. These taxa are usually individual genomes.
The taxa need to be the rows and the samples the columns.</p>
</td></tr>
<tr><td><code id="POMS_pipeline_+3A_func">func</code></td>
<td>
<p>dataframe of the number of copies of each function that are encoded by each input taxon.
This pipeline only considers the presence/absence of functions across taxa.
Taxa (with row names intersecting with the &quot;abun&quot; table) should be the rows and the functions should be the columns.</p>
</td></tr>
<tr><td><code id="POMS_pipeline_+3A_tree">tree</code></td>
<td>
<p>phylo object with tip labels that match the row names of the &quot;abun&quot; and &quot;func&quot; tables.
This object is usually based on a newick-formatted tree that has been read into R with the ape R package.</p>
</td></tr>
<tr><td><code id="POMS_pipeline_+3A_group1_samples">group1_samples</code></td>
<td>
<p>character vector of column names of &quot;abun&quot; table that correspond to the first sample group.
This grouping is used for testing for significant sample balances at each node.
Required unless the &quot;manual_BSN_dir&quot; argument is set (i.e., if the binary directions of BSNs are specified manually).</p>
</td></tr>
<tr><td><code id="POMS_pipeline_+3A_group2_samples">group2_samples</code></td>
<td>
<p>same as &quot;group1_samples&quot;, but corresponding to the second sample group.</p>
</td></tr>
<tr><td><code id="POMS_pipeline_+3A_ncores">ncores</code></td>
<td>
<p>integer specifying how many cores to use for parallelized sections of pipeline.</p>
</td></tr>
<tr><td><code id="POMS_pipeline_+3A_pseudocount">pseudocount</code></td>
<td>
<p>number added to all cells of &quot;abun&quot; table to avoid 0 values.
Set this to be 0 if this is not desired. Note that there will be issues with the balance tree approach if any 0's are present.</p>
</td></tr>
<tr><td><code id="POMS_pipeline_+3A_manual_bsns">manual_BSNs</code></td>
<td>
<p>optional vector of node names that match node labels of input tree.
These nodes will be considered the set of balance-significant nodes, and the Wilcoxon tests will not be run.
The group means of the balances at each node will still be used to determine which group has higher values.
Note this requires that the &quot;manual_balances&quot; argument is also specified.</p>
</td></tr>
<tr><td><code id="POMS_pipeline_+3A_manual_balances">manual_balances</code></td>
<td>
<p>optional list of balance values which represent the balances at all tested nodes that resulted in the input to the manual_BSNs vector.
This list must include balances for all nodes in the manual_BSNs vector, but also all non-significant tested nodes as well.
These node labels must all be present in the input tree.
The required list format is the &quot;balances&quot; object in the output of compute_node_balances.
Note, however, that any approach for computing balances could be used, as long as they are in this list format.</p>
</td></tr>
<tr><td><code id="POMS_pipeline_+3A_manual_bsn_dir">manual_BSN_dir</code></td>
<td>
<p>optional character vector specifying &quot;group1&quot; or &quot;group2&quot;, depending on the direction of the BSN difference.
This must be a named vector, with all names matching the set of nodes specified by the manual_BSNs argument.
Although this requires that the exact labels &quot;group1&quot; or &quot;group2&quot; are specified, these categories could represent different binary divisions rather than strict sample groups.
For instance, &quot;group1&quot; could be used to represent nodes where sample balances are positively associated with a continuous variable (rather than a discrete grouping),
whereas &quot;group2&quot; could represent nodes where sample balances are negatively associated.</p>
</td></tr>
<tr><td><code id="POMS_pipeline_+3A_min_num_tips">min_num_tips</code></td>
<td>
<p>minimum number of tips on each side of the nodes that is required for them to be retained in the analysis.
This argument is ignored if significant nodes are specified manually.</p>
</td></tr>
<tr><td><code id="POMS_pipeline_+3A_min_func_instances">min_func_instances</code></td>
<td>
<p>minimum number of tips that must encode the function for it to be retained for the analysis.</p>
</td></tr>
<tr><td><code id="POMS_pipeline_+3A_min_func_prop">min_func_prop</code></td>
<td>
<p>minimum proportion of tips that must encode the function for it to be retained for the analysis.</p>
</td></tr>
<tr><td><code id="POMS_pipeline_+3A_multinomial_min_fsns">multinomial_min_FSNs</code></td>
<td>
<p>The minimum number of FSNs required to run a multinomial test for a given function.</p>
</td></tr>
<tr><td><code id="POMS_pipeline_+3A_derep_nodes">derep_nodes</code></td>
<td>
<p>boolean value specifying whether nodes should be dereplicated based on similar sets of underlying tips (EXPERIMENTAL setting).
More specifically, whether nodes should be clustered based on how similar their underlying tips are (given a Jaccard index cut-off, specified as separately),
and then only retaining the node with the fewest underlying tips per cluster.</p>
</td></tr>
<tr><td><code id="POMS_pipeline_+3A_jaccard_cutoff">jaccard_cutoff</code></td>
<td>
<p>Numeric vector of length 1. Must be between 0 and 1 (inclusive). Corresponds to the Jaccard cut-off used for clustering nodes based on similar sets of underlying tips (when derep_nodes = TRUE).</p>
</td></tr>
<tr><td><code id="POMS_pipeline_+3A_bsn_p_cutoff">BSN_p_cutoff</code></td>
<td>
<p>significance cut-off for identifying BSNs.</p>
</td></tr>
<tr><td><code id="POMS_pipeline_+3A_bsn_correction">BSN_correction</code></td>
<td>
<p>multiple-test correction to use on Wilcoxon test p-values when identifying BSNs.
Must be in p.adjust.methods.</p>
</td></tr>
<tr><td><code id="POMS_pipeline_+3A_fsn_p_cutoff">FSN_p_cutoff</code></td>
<td>
<p>significance cut-off for identifying FSNs.</p>
</td></tr>
<tr><td><code id="POMS_pipeline_+3A_fsn_correction">FSN_correction</code></td>
<td>
<p>multiple-test correction to use on Fisher's exact test p-values when identifying FSNs.
Must be in p.adjust.methods.</p>
</td></tr>
<tr><td><code id="POMS_pipeline_+3A_func_descrip_infile">func_descrip_infile</code></td>
<td>
<p>optional path to mapfile of function ids (column 1) to descriptions (column 2).
This should be tab-delimited with no header and one function per line.
If this option is specified then an additional description column will be added to the output table.</p>
</td></tr>
<tr><td><code id="POMS_pipeline_+3A_multinomial_correction">multinomial_correction</code></td>
<td>
<p>multiple-test correction to use on raw multinomial test p-values.
Must be in p.adjust.methods.</p>
</td></tr>
<tr><td><code id="POMS_pipeline_+3A_detailed_output">detailed_output</code></td>
<td>
<p>boolean flag to indicate that several intermediate objects should be included in the final output.
This is useful when troubleshooting issues, but is not expected to be useful for most users.<br />
The additional results include:
</p>

<ul>
<li><p> balance_comparisons (summary of Wilcoxon tests on balances)
</p>
</li>
<li><p> func_enrichments (Fisher's exact test output for all functions at each node)
</p>
</li>
<li><p> input_param (a list containing the specified input parameters)
</p>
</li></ul>
</td></tr>
<tr><td><code id="POMS_pipeline_+3A_verbose">verbose</code></td>
<td>
<p>boolean flag to indicate that log information should be written to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Identifies significant nodes based on sample balances, using a Wilcoxon test by default. Alternatively, significant nodes can be manually specified.
Either way, significant nodes based on sample balances are referred to as Balance-Significant Nodes (BSNs).<br />
</p>
<p>Fisher's exact tests are run at each node in the tree with sufficient numbers of underlying tips on each side to test for functional enrichment.
Significant nodes based on this test are referred to as Function-Significant Nodes (FSNs). The set of FSNs is determined independently for each tested function.<br />
</p>
<p>The key output is the tally of the intersecting nodes based on the sets of BSNs and FSNs.<br />
</p>
<p>Each FSN can be categorized in one of three ways:
</p>

<ul>
<li><p> It does not intersect with any BSN.
</p>
</li>
<li><p> It intersects with a BSN and the functional enrichment is within the taxa that are relatively more abundant in group 1 samples.
</p>
</li>
<li><p> Same as the second point, but enriched within taxa that are relatively more abundant in group 2 samples.
</p>
</li></ul>

<p>A multinomial test is run to see if the number of FSNs of each type is significantly different from the random expectation.
</p>


<h3>Value</h3>

<p>list containing (at minimum) these elements:
</p>

<ul>
<li><p> results: dataframe with each tested function as a row and the numbers of FSNs of each type as columns, as well as the multinomial test output.
</p>
</li>
<li><p> balance_info: list containing the tips underlying each node, which were what the balances are based on, the balances themselves at each tested node,
and the set of nodes that were determined to be negligible due to having too few underlying tips. Note that the balances and underlying tips are provided for
all non-negligible (i.e., tested) nodes, not just those identified as BSNs. Additional information on the dereplication and Jaccard similarity of nodes is returned as well when derep_nodes = TRUE.
</p>
</li>
<li><p> BSNs: character vector with BSNs as names and values of &quot;group1&quot; and &quot;group2&quot; to indicate for which sample group (or other binary division) the sample balances were higher.
</p>
</li>
<li><p> FSNs_summary: list containing each tested function as a separate element. The labels for nodes in each FSN category of the multinomial test are listed per function (or are empty if there were no such FSNs).
</p>
</li>
<li><p> tree: the prepped tree used by the pipeline, including the added node labels if a tree lacking labels was provided. This tree will also have been subset to only those tips found in the
abundance table, and midpoint rooted (if it was not already rooted).
</p>
</li>
<li><p> multinomial_exp_prop: expected proportions of the three FSN categories used for multinomial test.
</p>
</li></ul>


<hr>
<h2 id='prep_func_node_info'>Get node indices of FSN and BSN categories across tree for a given function</h2><span id='topic+prep_func_node_info'></span>

<h3>Description</h3>

<p>Parse POMS_pipeline output to look at FSNs for a specific function (e.g., a specific gene family). Will also parse BSN information (which is not dependent on a particular function).
This is convenient to do before plotting the distribution of FSNs and BSNs across the tree with the ggtree R package for instance.
When a taxa label table is specified, labels of tested nodes in the tree (found in the POMS_pipeline output object) will be renamed to be the representative taxa on each side.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_func_node_info(
  POMS_output,
  func_id,
  taxa_table = NULL,
  taxa_threshold = 0.75,
  full_taxon_label = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prep_func_node_info_+3A_poms_output">POMS_output</code></td>
<td>
<p>output object from POMS_pipeline function.</p>
</td></tr>
<tr><td><code id="prep_func_node_info_+3A_func_id">func_id</code></td>
<td>
<p>label of function for which should FSNs should be parsed. Must be present in POMS_output$FSNs_summary.</p>
</td></tr>
<tr><td><code id="prep_func_node_info_+3A_taxa_table">taxa_table</code></td>
<td>
<p>optional dataframe containing taxa labels for each tip of tree. Must be in same format as expected for node_taxa function.</p>
</td></tr>
<tr><td><code id="prep_func_node_info_+3A_taxa_threshold">taxa_threshold</code></td>
<td>
<p>float &gt; 0.5 and &lt;= 1.0 specifying the proportion of tips that must share a taxon label for it to be considered representative. Only relevant if taxa_table specified.</p>
</td></tr>
<tr><td><code id="prep_func_node_info_+3A_full_taxon_label">full_taxon_label</code></td>
<td>
<p>boolean flag for whether taxon labels should be combined, so that all higher taxonomic labels are included. Specifically, when TRUE, all higher labels are concatenated and delimited by &quot;; &quot;.
E.g., rather than just the genus &quot;Odoribacter&quot; the label would be &quot;Bacteria; Bacteroidetes; Bacteroidia; Bacteroidales; Porphyromonadaceae; Odoribacter&quot;. Only relevant if taxa_table specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing final tree as well as indices of nodes corresponding to different FSN and BSN categories.
If taxa_table was specified, then node labels in tree will correspond to representative taxa on each side of the
nodes that were tested (i.e., those that were non-negligible).
</p>

<hr>
<h2 id='prevalence_norm_logit'>Compute additive smoothed prevalence of features (e.g, taxa), restricted to samples of a particular metadata category.<br /></h2><span id='topic+prevalence_norm_logit'></span>

<h3>Description</h3>

<p>This code replicates the prevalence score introduced in phylogenize. The code here is modified from the phylogenize code base
(https://bitbucket.org/pbradz/phylogenize/src/master/package/phylogenize/R/; commit 6f1bdba9c5a9ff04e90a8ad77bcee8ec9281730d).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prevalence_norm_logit(
  abun_table,
  meta_table,
  focal_var_level,
  var_colname,
  sample_colname,
  silence_citation = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prevalence_norm_logit_+3A_abun_table">abun_table</code></td>
<td>
<p>abundance table to use for computing prevalence. Features must be rows and samples columns. All values greater than 0 will be interpreted as present.</p>
</td></tr>
<tr><td><code id="prevalence_norm_logit_+3A_meta_table">meta_table</code></td>
<td>
<p>dataframe object containing metadata for all samples. Must include at least one column corresponding to the sample ids and one column containing the metadata of interest that will be focused on when computing prevalence.</p>
</td></tr>
<tr><td><code id="prevalence_norm_logit_+3A_focal_var_level">focal_var_level</code></td>
<td>
<p>length-one character vector specifying the variable value to restrict inferences of prevalence to. In other words, prevalence will be computed based on the sample set that contain this value of the variable of interest in the metadata table.</p>
</td></tr>
<tr><td><code id="prevalence_norm_logit_+3A_var_colname">var_colname</code></td>
<td>
<p>length-one character vector specifying the name of column in the metadata table that contains the metadata of interest (e.g., where focal_var_level can be found).</p>
</td></tr>
<tr><td><code id="prevalence_norm_logit_+3A_sample_colname">sample_colname</code></td>
<td>
<p>length-one character vector specifying the name of column in the metadata table that contains the sample ids.</p>
</td></tr>
<tr><td><code id="prevalence_norm_logit_+3A_silence_citation">silence_citation</code></td>
<td>
<p>length-one Boolean vector specifying whether to silence message notifying user about phylogenize package and paper.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm is descibed in detail in Bradley et al. 2018. Phylogeny-corrected identification of microbial gene families relevant to human gut colonization. PLOS Computational Biology.
</p>


<h3>Value</h3>

<p>Numeric vector with the normalized prevalence score for each input feature (i.e., for each row of abun_table).
</p>

<hr>
<h2 id='specificity_scores'>Compute shrunken specificity score of a feature, which represents how the presence of a feature is associated with a given sample grouping.</h2><span id='topic+specificity_scores'></span>

<h3>Description</h3>

<p>This code replicates the environmental specificity score introduced in phylogenize. The code here is modified from the phylogenize code base
(https://bitbucket.org/pbradz/phylogenize/src/master/package/phylogenize/R/; commit 6f1bdba9c5a9ff04e90a8ad77bcee8ec9281730d).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specificity_scores(
  abun_table,
  meta_table,
  focal_var_level,
  var_colname,
  sample_colname,
  silence_citation = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="specificity_scores_+3A_abun_table">abun_table</code></td>
<td>
<p>abundance table to use for computing specificity Features must be rows and samples columns. All values greater than 0 will be interpreted as present.</p>
</td></tr>
<tr><td><code id="specificity_scores_+3A_meta_table">meta_table</code></td>
<td>
<p>dataframe object containing metadata for all samples. Must include at least one column corresponding to the sample ids and one column containing the metadata of interest that will be focused on.</p>
</td></tr>
<tr><td><code id="specificity_scores_+3A_focal_var_level">focal_var_level</code></td>
<td>
<p>length-one character vector specifying the variable value to restrict inferences of prevalence to. In other words, prevalence will be computed based on the sample set that contain this value of the variable of interest in the metadata table.</p>
</td></tr>
<tr><td><code id="specificity_scores_+3A_var_colname">var_colname</code></td>
<td>
<p>length-one character vector specifying the name of column in the metadata table that contains the metadata of interest (e.g., where focal_var_level can be found).</p>
</td></tr>
<tr><td><code id="specificity_scores_+3A_sample_colname">sample_colname</code></td>
<td>
<p>length-one character vector specifying the name of column in the metadata table that contains the sample ids.</p>
</td></tr>
<tr><td><code id="specificity_scores_+3A_silence_citation">silence_citation</code></td>
<td>
<p>length-one Boolean vector specifying whether to silence message notifying user about phylogenize package and paper.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm is descibed in detail in Bradley et al. 2018. Phylogeny-corrected identification of microbial gene families relevant to human gut colonization. PLOS Computational Biology.
</p>
<p>Note thee can be some random fluctuations between re-runs of this function. The differences are usually minor, but users are strongly suggested to set a random seed before use to ensure their workflow is reproducible.
</p>


<h3>Value</h3>

<p>Numeric vector with the specificity score for each input feature (i.e., for each row of abun_table).
</p>

<hr>
<h2 id='subset_by_col_and_filt'>Subset dataframe by column names and then post-filter</h2><span id='topic+subset_by_col_and_filt'></span>

<h3>Description</h3>

<p>Subset table by set of column names. After doing this, it will remove any rows and columns that are all 0's.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_by_col_and_filt(in_tab, col2keep, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subset_by_col_and_filt_+3A_in_tab">in_tab</code></td>
<td>
<p>input dataframe</p>
</td></tr>
<tr><td><code id="subset_by_col_and_filt_+3A_col2keep">col2keep</code></td>
<td>
<p>column names to retain in output (as long as they have at least one non-zero value).</p>
</td></tr>
<tr><td><code id="subset_by_col_and_filt_+3A_verbose">verbose</code></td>
<td>
<p>flag to indicate that the final number of rows and columns (as well as the number removed) should be reported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe with subset of specified columns (if they have at least one non-zero value), also with rows that only contain 0's removed.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
