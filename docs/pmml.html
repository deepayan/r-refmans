<!DOCTYPE html><html lang="en"><head><title>Help for package pmml</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pmml}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pmml-package'><p>pmml: Generate PMML for R Models</p></a></li>
<li><a href='#add_attributes'><p>Add attribute values to an existing element in a given PMML file.</p></a></li>
<li><a href='#add_data_field_attributes'><p>Add attribute values to an existing DataField element in a given PMML file</p></a></li>
<li><a href='#add_data_field_children'><p>Add 'Interval' and 'Value' child elements to a given DataField element in a</p>
given PMML file.</a></li>
<li><a href='#add_mining_field_attributes'><p>Add attribute values to an existing MiningField element in a given PMML</p>
file.</a></li>
<li><a href='#add_output_field'><p>Add Output nodes to a PMML object.</p></a></li>
<li><a href='#audit'><p>Audit: artificially constructed dataset</p></a></li>
<li><a href='#file_to_xml_node'><p>Read in a file and parse it into an object of type XMLNode.</p></a></li>
<li><a href='#function_to_pmml'><p>Convert an R expression to PMML.</p></a></li>
<li><a href='#houseVotes84'><p>Modified 1984 United States Congressional Voting Records Database</p></a></li>
<li><a href='#make_intervals'><p>Create Interval elements, most likely to add to a DataDictionary element.</p></a></li>
<li><a href='#make_output_nodes'><p>Add Output nodes to a PMML object.</p></a></li>
<li><a href='#make_values'><p>Create Values element, most likely to add to a DataDictionary element.</p></a></li>
<li><a href='#pmml'><p>Generate the PMML representation for R objects.</p></a></li>
<li><a href='#pmml.ada'><p>Generate the PMML representation for an ada object from the package <span class="pkg">ada</span>.</p></a></li>
<li><a href='#pmml.ARIMA'><p>Generate PMML for an ARIMA object the <b>forecast</b> package.</p></a></li>
<li><a href='#pmml.coxph'><p>Generate the PMML representation for a coxph object from the package</p>
<span class="pkg">survival</span>.</a></li>
<li><a href='#pmml.cv.glmnet'><p>Generate the PMML representation for a cv.glmnet object from the package</p>
<span class="pkg">glmnet</span>.</a></li>
<li><a href='#pmml.gbm'><p>Generate the PMML representation for a gbm object from the package <span class="pkg">gbm</span>.</p></a></li>
<li><a href='#pmml.glm'><p>Generate the PMML representation for a glm object from the package <span class="pkg">stats</span>.</p></a></li>
<li><a href='#pmml.hclust'><p>Generate the PMML representation for a hclust object from the package <span class="pkg">amap</span>.</p></a></li>
<li><a href='#pmml.iForest'><p>Generate PMML for an iForest object from the <b>isofor</b> package.</p></a></li>
<li><a href='#pmml.kmeans'><p>Generate the PMML representation for a kmeans object from</p>
the package <span class="pkg">stats</span>.</a></li>
<li><a href='#pmml.ksvm'><p>Generate the PMML representation for a ksvm object from the package</p>
<span class="pkg">kernlab</span>.</a></li>
<li><a href='#pmml.lm'><p>Generate the PMML representation for an lm object from the package <span class="pkg">stats</span>.</p></a></li>
<li><a href='#pmml.multinom'><p>Generate the PMML representation for a multinom object from package</p>
<span class="pkg">nnet</span>.</a></li>
<li><a href='#pmml.naiveBayes'><p>Generate the PMML representation for a naiveBayes object from the package</p>
<span class="pkg">e1071</span>.</a></li>
<li><a href='#pmml.neighbr'><p>Generate PMML for a neighbr object from the <b>neighbr</b> package.</p></a></li>
<li><a href='#pmml.nnet'><p>Generate the PMML representation for a nnet object from package <span class="pkg">nnet</span>.</p></a></li>
<li><a href='#pmml.randomForest'><p>Generate the PMML representation for a randomForest object from the package</p>
<span class="pkg">randomForest</span>.</a></li>
<li><a href='#pmml.rpart'><p>Generate the PMML representation for an rpart object from the package <span class="pkg">rpart</span>.</p></a></li>
<li><a href='#pmml.rules'><p>Generate the PMML representation for a rules or an itemset object from</p>
package <span class="pkg">arules</span>.</a></li>
<li><a href='#pmml.svm'><p>Generate the PMML representation of an svm object from the <span class="pkg">e1071</span> package.</p></a></li>
<li><a href='#pmml.xgb.Booster'><p>Generate PMML for a xgb.Booster object from the package <span class="pkg">xgboost</span>.</p></a></li>
<li><a href='#rename_wrap_var'><p>Rename a variable in the xform_wrap transform object.</p></a></li>
<li><a href='#save_pmml'><p>Save a pmml object as an external PMML file.</p></a></li>
<li><a href='#xform_discretize'><p>Discretize a continuous variable as indicated by interval mappings in</p>
accordance with the PMML element <b>Discretize</b>.</a></li>
<li><a href='#xform_function'><p>Add a function transformation to a xform_wrap object.</p></a></li>
<li><a href='#xform_map'><p>Implement a map between discrete values in accordance with the PMML element</p>
<b>MapValues</b>.</a></li>
<li><a href='#xform_min_max'><p>Normalize continuous values in accordance with the PMML element</p>
<b>NormContinuous</b>.</a></li>
<li><a href='#xform_norm_discrete'><p>Normalize discrete values in accordance with the PMML element <b>NormDiscrete</b>.</p></a></li>
<li><a href='#xform_wrap'><p>Wrap data in a data transformations object.</p></a></li>
<li><a href='#xform_z_score'><p>Perform a z-score normalization on continuous values in accordance with the</p>
PMML element <b>NormContinuous</b>.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generate PMML for Various Models</td>
</tr>
<tr>
<td>Version:</td>
<td>2.5.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>XML</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ada, amap, arules, caret, clue, data.table, forecast, gbm,
glmnet, Matrix, neighbr, nnet, rpart, randomForest, rattle,
kernlab, e1071, testthat, survival, xgboost, knitr, rmarkdown,
covr, tibble</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats, utils, stringr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>Description:</td>
<td>The Predictive Model Markup Language (PMML) is an XML-based language which provides a way for applications to define machine learning, statistical and data mining models and to share models between PMML compliant applications. More information about the PMML industry standard and the Data Mining Group can be found at <a href="http://dmg.org/">http://dmg.org/</a>. The generated PMML can be imported into any PMML consuming application, such as Zementis Predictive Analytics products. The package isofor (used for anomaly detection) can be installed with devtools::install_github("gravesee/isofor").</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://open-source.softwareag.com/r-pmml/">https://open-source.softwareag.com/r-pmml/</a>,
<a href="https://github.com/SoftwareAG/r-pmml">https://github.com/SoftwareAG/r-pmml</a>,
<a href="https://www.softwareag.com/corporate/products/az/zementis/default.html">https://www.softwareag.com/corporate/products/az/zementis/default.html</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/SoftwareAG/r-pmml/issues">https://github.com/SoftwareAG/r-pmml/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-04 06:28:57 UTC; dmbo</td>
</tr>
<tr>
<td>Author:</td>
<td>Dmitriy Bolotov [aut, cre],
  Tridivesh Jena [aut],
  Graham Williams [aut],
  Wen-Ching Lin [aut],
  Michael Hahsler [aut],
  Hemant Ishwaran [aut],
  Udaya B. Kogalur [aut],
  Rajarshi Guha [aut],
  Software AG [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dmitriy Bolotov &lt;dmitriy.bolotov@softwareag.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-04 11:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='pmml-package'>pmml: Generate PMML for R Models</h2><span id='topic+pmml-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>Export various R models to PMML and generate data transformations in PMML
format.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code><a href="#topic+pmml">pmml</a></code> exports R model objects to PMML format.
</p>
</li>
<li> <p><code><a href="#topic+xform_wrap">xform_wrap</a></code> creates an object with that can then be used
to describe transformations to be exported to PMML.
</p>
</li></ul>



<h3>Data Transformations</h3>

<p>The data transformation functions previously available in the separate
<span class="pkg">pmmlTransformations</span> package have been merged into <span class="pkg">pmml</span> starting
with version 2.0.0.
</p>
<p>The general methodology is to first wrap the data with <code>xform_wrap</code>,
and then perform transformations using the following functions:
<code>xform_discretize</code>, <code>xform_function</code>, <code>xform_map</code>,
<code>xform_min_max</code>, <code>xform_norm_discrete</code>, <code>xform_z_score</code>.
The model, including the transformations, can then be output in PMML format by
calling the <code>pmml</code> function. The <code>pmml</code> function in this
case has to be given an additional parameter, <code>transforms</code>.
</p>


<h3>PMML</h3>

<p>The Predictive Model Markup Language (PMML) is an XML-based language which
provides a way for applications to define machine learning, statistical and
data mining models and to share models between PMML compliant applications.
More information about the PMML industry standard and the Data Mining Group
can be found at &lt;http://www.dmg.org&gt;. The generated PMML can be imported
into any PMML consuming application, such as Zementis Predictive Analytics
products, which integrate with web services, relational database systems and
deploy natively on Hadoop in conjunction with Hive, Spark or Storm, as well
as allow predictive analytics to be executed for IBM z Systems mainframe
applications and real-time, streaming analytics platforms.
</p>


<h3>References</h3>


<ul>
<li> <p><a href="http://dmg.org/pmml/v4-4-1/GeneralStructure.html">PMML home page</a>
</p>
</li>
<li> <p><a href="http://dmg.org/pmml/v4-4-1/Transformations.html">PMML transformations</a>
</p>
</li>
<li><p> A. Guazzelli, W. Lin, T. Jena (2012), <em>PMML in Action: Unleashing
the Power of Open Standards for Data Mining and Predictive Analytics</em>.
CreativeSpace (Second Edition) -
<a href="https://www.amazon.com/dp/1470003244">Available on Amazon.com</a>.
</p>
</li>
<li><p> A. Guazzelli, M. Zeller, W. Lin, G. Williams (2009), PMML: An Open
Standard for Sharing Models. <em>The R journal</em>, Volume 1/1, 60-65
</p>
</li>
<li><p> T. Jena, A. Guazzelli, W. Lin, M. Zeller (2013).
<a href="https://kdd13pmml.files.wordpress.com/2013/07/jena_et_al.pdf">The R
pmmlTransformations Package.</a> In <em>Proceedings of the 19th ACM SIGKDD
Conference on Knowledge Discovery and Data Mining</em>
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Dmitriy Bolotov <a href="mailto:dmitriy.bolotov@softwareag.com">dmitriy.bolotov@softwareag.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Tridivesh Jena <a href="mailto:tridivesh.jena@softwareag.com">tridivesh.jena@softwareag.com</a>
</p>
</li>
<li><p> Graham Williams <a href="mailto:graham.williams@togaware.net">graham.williams@togaware.net</a>
</p>
</li>
<li><p> Wen-Ching Lin
</p>
</li>
<li><p> Michael Hahsler <a href="mailto:michael@hahsler.net">michael@hahsler.net</a>
</p>
</li>
<li><p> Hemant Ishwaran
</p>
</li>
<li><p> Udaya B. Kogalur
</p>
</li>
<li><p> Rajarshi Guha <a href="mailto:rguha@indiana.edu">rguha@indiana.edu</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Software AG [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://open-source.softwareag.com/r-pmml/">https://open-source.softwareag.com/r-pmml/</a>
</p>
</li>
<li> <p><a href="https://github.com/SoftwareAG/r-pmml">https://github.com/SoftwareAG/r-pmml</a>
</p>
</li>
<li> <p><a href="https://www.softwareag.com/corporate/products/az/zementis/default.html">https://www.softwareag.com/corporate/products/az/zementis/default.html</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/SoftwareAG/r-pmml/issues">https://github.com/SoftwareAG/r-pmml/issues</a>
</p>
</li></ul>


<hr>
<h2 id='add_attributes'>Add attribute values to an existing element in a given PMML file.</h2><span id='topic+add_attributes'></span>

<h3>Description</h3>

<p>Add attribute values to an existing element in a given PMML file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_attributes(
  xml_model = NULL,
  xpath = NULL,
  attributes = NULL,
  namespace = "4_4",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_attributes_+3A_xml_model">xml_model</code></td>
<td>
<p>The PMML model in a XML node format. If the model is a text
file, it should be converted to an XML node, for example, using the
file_to_xml_node function.</p>
</td></tr>
<tr><td><code id="add_attributes_+3A_xpath">xpath</code></td>
<td>
<p>The XPath to the element to which the attributes are to be
added.</p>
</td></tr>
<tr><td><code id="add_attributes_+3A_attributes">attributes</code></td>
<td>
<p>The attributes to be added to the data fields. The user
should make sure that the attributes being added are allowed in the PMML
schema.</p>
</td></tr>
<tr><td><code id="add_attributes_+3A_namespace">namespace</code></td>
<td>
<p>The namespace of the PMML model. This is frequently also
the PMML version of the model.</p>
</td></tr>
<tr><td><code id="add_attributes_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Add attributes to an arbitrary XML element. This is an experimental
function designed to be more general than the 'add_mining_field_attributes' and
'add_data_field_attributes' functions.
</p>
<p>The attribute information can be provided as a vector. Multiple attribute
names and values can be passes as vector elements to enable inserting
multiple attributes. However, this function overwrites any pre-existing
attribute values, so it must be used with care. This behavior is by design
as this feature is meant to help an user add new defined attribute values at
different times. The XPath has to include the namespace as shown in the
examples.
</p>


<h3>Value</h3>

<p>An object of class <code>XMLNode</code> as that defined by the <span class="pkg">XML</span> package.
This represents the top level, or root node, of the XML document and is of
type PMML. It can be written to file with <code>saveXML</code>.
</p>


<h3>Author(s)</h3>

<p>Tridivesh Jena
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make a sample model:
fit &lt;- lm(Sepal.Length ~ ., data = iris[, -5])
fit_pmml &lt;- pmml(fit)

# Add arbitrary attributes to the 1st 'NumericPredictor' element. The
# attributes are for demostration only (they are not allowed under
# the PMML schema). The command assumes the default namespace.
fit_pmml_2 &lt;- add_attributes(fit_pmml, "/p:PMML/descendant::p:NumericPredictor[1]",
  attributes = c(a = 1, b = "b")
)

# Add attributes to the NumericPredictor element which has
# 'Petal.Length' as the 'name' attribute:
fit_pmml_3 &lt;- add_attributes(fit_pmml,
  "/p:PMML/descendant::p:NumericPredictor[@name='Petal.Length']",
  attributes = c(a = 1, b = "b")
)

# 3 NumericElements exist which have '1' as the 'exponent' attribute.
# Add new attributes to the 3rd one:
fit_pmml_4 &lt;- add_attributes(fit_pmml,
  "/p:PMML/descendant::p:NumericPredictor[@exponent='1'][3]",
  attributes = c(a = 1, b = "b")
)

# Add attributes to the 1st element whose 'name' attribute contains
# 'Length':
fit_pmml_5 &lt;- add_attributes(fit_pmml,
  "/p:PMML/descendant::p:NumericPredictor[contains(@name,'Length')]",
  attributes = c(a = 1, b = "b")
)
</code></pre>

<hr>
<h2 id='add_data_field_attributes'>Add attribute values to an existing DataField element in a given PMML file</h2><span id='topic+add_data_field_attributes'></span>

<h3>Description</h3>

<p>Add attribute values to an existing DataField element in a given PMML file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_data_field_attributes(
  xml_model = NULL,
  attributes = NULL,
  field = NULL,
  namespace = "4_4",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_data_field_attributes_+3A_xml_model">xml_model</code></td>
<td>
<p>The PMML model in a XML node format. If the model is a text
file, it should be converted to an XML node, for example, using the
file_to_xml_node function.</p>
</td></tr>
<tr><td><code id="add_data_field_attributes_+3A_attributes">attributes</code></td>
<td>
<p>The attributes to be added to the data fields. The user
should make sure that the attributes being added are allowed in the PMML
schema.</p>
</td></tr>
<tr><td><code id="add_data_field_attributes_+3A_field">field</code></td>
<td>
<p>The field to which the attributes are to be added. This is used
when the attributes are a vector of name-value pairs, intended for this one
field.</p>
</td></tr>
<tr><td><code id="add_data_field_attributes_+3A_namespace">namespace</code></td>
<td>
<p>The namespace of the PMML model. This is frequently also the
PMML version of the model.</p>
</td></tr>
<tr><td><code id="add_data_field_attributes_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The PMML schema allows a DataField element to have various attributes,
which, although useful, may not always be present in a PMML model. This
function makes it possible to add such attributes to DataFields of an
existing PMML file.
</p>
<p>The attribute information can be provided as a dataframe or a vector. Each
row of the data frame corresponds to an attribute name and each column
corresponding to a variable name. This way one can add as many attributes to
as many variables as one wants in one step. A more convenient method to add
multiple attributes to one field might be to give the attribute name and
values as a vector. This function may be used multiple times to add new
attribute values step-by-step. However this function overwrites any
pre-existing attribute values, so it must be used with care. This behavior
is by design as this feature is meant to help an user add new defined
attribute values at different times. For example, one may use this to modify
the display name of a field at different times.
</p>


<h3>Value</h3>

<p>An object of class <code>XMLNode</code> as that defined by the <span class="pkg">XML</span> package.
This represents the top level, or root node, of the XML document and is of
type PMML. It can be written to file with <code>saveXML</code>.
</p>


<h3>Author(s)</h3>

<p>Tridivesh Jena
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make a sample model:
fit &lt;- lm(Sepal.Length ~ ., data = iris[, -5])
fit_pmml &lt;- pmml(fit)

# The resulting model has mining fields with no information besides
# fieldName, dataType and optype. This object is already an xml
# node (not an external text file), so there is no need to convert
# it to an xml node object.

# Create data frame with attribute information:

attributes &lt;- data.frame(c("FlowerWidth", 1), c("FlowerLength", 0),
  stringsAsFactors = FALSE
)
rownames(attributes) &lt;- c("displayName", "isCyclic")
colnames(attributes) &lt;- c("Sepal.Width", "Petal.Length")

# Although not needed in this first try, necessary to easily add
# new values later. Removes values as factors so that new values
# added later are not evaluated as factor values and thus rejected
# as invalid.
attributes[] &lt;- lapply(attributes, as.character)

fit_pmml_2 &lt;- add_data_field_attributes(fit_pmml,
  attributes,
  namespace = "4_4"
)

# Alternative method to add attributes to a single field,
# "Sepal.Width":
fit_pmml_3 &lt;- add_data_field_attributes(
  fit_pmml, c(displayName = "FlowerWidth", isCyclic = 1),
  "Sepal.Width"
)


mi &lt;- make_intervals(
  list("openClosed", "closedClosed", "closedOpen"),
  list(NULL, 1, 2), list(1, 2, NULL)
)
mv &lt;- make_values(
  list("A", "B", "C"), list(NULL, NULL, NULL),
  list("valid", NULL, "invalid")
)
fit_pmml_4 &lt;- add_data_field_children(fit_pmml,
  field = "Sepal.Length",
  interval = mi, values = mv
)
</code></pre>

<hr>
<h2 id='add_data_field_children'>Add 'Interval' and 'Value' child elements to a given DataField element in a
given PMML file.</h2><span id='topic+add_data_field_children'></span>

<h3>Description</h3>

<p>Add 'Interval' and 'Value' child elements to a given DataField element in a
given PMML file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_data_field_children(
  xml_model = NULL,
  field = NULL,
  intervals = NULL,
  values = NULL,
  namespace = "4_4",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_data_field_children_+3A_xml_model">xml_model</code></td>
<td>
<p>The PMML model in a XML node format. If the model is a text
file, it should be converted to an XML node, for example, using the
file_to_xml_node function.</p>
</td></tr>
<tr><td><code id="add_data_field_children_+3A_field">field</code></td>
<td>
<p>The field to which the attributes are to be added. This is used
when the attributes are a vector of name-value pairs, intended for this one
field.</p>
</td></tr>
<tr><td><code id="add_data_field_children_+3A_intervals">intervals</code></td>
<td>
<p>The 'Interval' elements given as a list</p>
</td></tr>
<tr><td><code id="add_data_field_children_+3A_values">values</code></td>
<td>
<p>The 'Value' elements given as a list.</p>
</td></tr>
<tr><td><code id="add_data_field_children_+3A_namespace">namespace</code></td>
<td>
<p>The namespace of the PMML model. This is frequently also
the PMML version of the model.</p>
</td></tr>
<tr><td><code id="add_data_field_children_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The PMML format allows a DataField element to have 'Interval' and 'Value'
child elements which although useful, may not always be present in a PMML
model. This function allows one to take an existing PMML file and add these
elements to the DataFields.
</p>
<p>The 'Interval' elements or the 'Value' elements can be typed in, but more
conveniently created by using the helper functions 'make_intervals' and
'MakeValues'. This function can then add these extra information to the
PMML.
</p>


<h3>Value</h3>

<p>An object of class <code>XMLNode</code> as that defined by the <span class="pkg">XML</span> package.
This represents the top level, or root node, of the XML document and is of
type PMML. It can be written to file with <code>saveXML</code>.
</p>


<h3>Author(s)</h3>

<p>Tridivesh Jena
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make a sample model:
fit &lt;- lm(Sepal.Length ~ ., data = iris[, -5])
fit_pmml &lt;- pmml(fit)

# The resulting model has data fields but with no 'Interval' or Value'
# elements. This object is already an xml node (not an external text
# file), so there is no need to convert it to an xml node object.

# Add an 'Interval' element node by typing it in
fit_pmml_2 &lt;- add_data_field_children(fit_pmml,
  field = "Sepal.Length",
  intervals = list(newXMLNode("Interval",
    attrs = c(closure = "openClosed", rightMargin = 3)
  ))
)

# Use helper functions to create list of 'Interval' and 'Value'
# elements. We define the 3 Intervals as ,1]  (1,2)  and [2,
mi &lt;- make_intervals(
  list("openClosed", "openOpen", "closedOpen"),
  list(NULL, 1, 2), list(1, 2, NULL)
)

# Define 3 values, none with a 'displayValue' attribute and 1 value
# defined as 'invalid'. The 2nd one is 'valid' by default.
mv &lt;- make_values(
  list(1.1, 2.2, 3.3), list(NULL, NULL, NULL),
  list("valid", NULL, "invalid")
)

# As an example, apply these to the Sepal.Length field:
fit_pmml_3 &lt;- add_data_field_children(fit_pmml, field = "Sepal.Length", intervals = mi, values = mv)

# Only defined 'Interval's:
fit_pmml_3 &lt;- add_data_field_children(fit_pmml, field = "Sepal.Length", intervals = mi)
</code></pre>

<hr>
<h2 id='add_mining_field_attributes'>Add attribute values to an existing MiningField element in a given PMML
file.</h2><span id='topic+add_mining_field_attributes'></span>

<h3>Description</h3>

<p>Add attribute values to an existing MiningField element in a given PMML
file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_mining_field_attributes(
  xml_model = NULL,
  attributes = NULL,
  namespace = "4_4",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_mining_field_attributes_+3A_xml_model">xml_model</code></td>
<td>
<p>The PMML model in a XML node format. If the model is a text
file, it should be converted to an XML node, for example, using the
file_to_xml_node function.</p>
</td></tr>
<tr><td><code id="add_mining_field_attributes_+3A_attributes">attributes</code></td>
<td>
<p>The attributes to be added to the mining fields. The user
should make sure that the attributes being added are allowed in the PMML
schema.</p>
</td></tr>
<tr><td><code id="add_mining_field_attributes_+3A_namespace">namespace</code></td>
<td>
<p>The namespace of the PMML model. This is frequently also
the PMML version of the model.</p>
</td></tr>
<tr><td><code id="add_mining_field_attributes_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The PMML format allows a MiningField element to have attributes 'usageType',
'missingValueReplacement' and 'invalidValueTreatment' which although useful,
may not always be present in a PMML model. This function allows one to take
an existing PMML file and add these attributes to the MiningFields.
</p>
<p>The attribute information should be provided as a dataframe; each row
corresponding to an attribute name and each column corresponding to a
variable name. This way one can add as many attributes to as many variables
as one wants in one step. On the other extreme, a one-by-one data frame may
be used to add one new attribute to one variable. This function may be used
multiple times to add new attribute values step-by-step. This function
overwrites any pre-existing attribute values, so it must be used with care.
However, this is by design as this feature is meant to help an user defined
new attribute values at different times. For example, one may use this to
impute missing values in a model at different times.
</p>


<h3>Value</h3>

<p>An object of class <code>XMLNode</code> as that defined by the <span class="pkg">XML</span> package.
This represents the top level, or root node, of the XML document and is of
type PMML. It can be written to file with <code>saveXML</code>.
</p>


<h3>Author(s)</h3>

<p>Tridivesh Jena
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make a sample model
fit &lt;- lm(Sepal.Length ~ ., data = iris[, -5])
fit_pmml &lt;- pmml(fit)

# The resulting model has mining fields with no information
# besides fieldName, dataType and optype. This object is
# already an xml node (not an external text file), so there
# is no need to convert it to an xml node object.

# Create data frame with attribute information:
attributes &lt;- data.frame(
  c("active", 1.1, "asIs"),
  c("active", 2.2, "asIs"),
  c("active", NA, "asMissing"),
  stringsAsFactors = TRUE
)
rownames(attributes) &lt;- c(
  "usageType", "missingValueReplacement",
  "invalidValueTreatment"
)
colnames(attributes) &lt;- c(
  "Sepal.Width", "Petal.Length",
  "Petal.Width"
)

# Although not needed in this first try, necessary to easily
# add new values later:
for (k in 1:ncol(attributes)) {
  attributes[[k]] &lt;- as.character(attributes[[k]])
}

fit_pmml &lt;- add_mining_field_attributes(fit_pmml, attributes, namespace = "4_4")
</code></pre>

<hr>
<h2 id='add_output_field'>Add Output nodes to a PMML object.</h2><span id='topic+add_output_field'></span>

<h3>Description</h3>

<p>Add Output nodes to a PMML object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_output_field(
  xml_model = NULL,
  outputNodes = NULL,
  at = "End",
  xformText = NULL,
  nodeName = NULL,
  attributes = NULL,
  whichOutput = 1,
  namespace = "4_4"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_output_field_+3A_xml_model">xml_model</code></td>
<td>
<p>The PMML model to which the OutputField elements are to be added</p>
</td></tr>
<tr><td><code id="add_output_field_+3A_outputnodes">outputNodes</code></td>
<td>
<p>The Output nodes to be added. These may be created using the
'make_output_nodes' helper function</p>
</td></tr>
<tr><td><code id="add_output_field_+3A_at">at</code></td>
<td>
<p>Given an Output element, the 1 based index after which the given Output
child element should be inserted at</p>
</td></tr>
<tr><td><code id="add_output_field_+3A_xformtext">xformText</code></td>
<td>
<p>Post-processing information to be included in the OutputField element.
This expression will be processed by the function_to_pmml function</p>
</td></tr>
<tr><td><code id="add_output_field_+3A_nodename">nodeName</code></td>
<td>
<p>The name of the element to be added</p>
</td></tr>
<tr><td><code id="add_output_field_+3A_attributes">attributes</code></td>
<td>
<p>The attributes to be added</p>
</td></tr>
<tr><td><code id="add_output_field_+3A_whichoutput">whichOutput</code></td>
<td>
<p>The index of the Output element</p>
</td></tr>
<tr><td><code id="add_output_field_+3A_namespace">namespace</code></td>
<td>
<p>The namespace of the PMML model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is meant to add any post-processing information to an existing model via
the OutputField element. One can also use this to tell the PMML model to output other values
not automatically added to the model output.
The first method is to use the 'make_output_nodes' helper function to make a list of output
elements to be added. 'whichOutput' lets the function know which of the Output elements we want to
work with; there may be more than one in a multiple model file. One can then add those elements there,
at the desired index given by the 'at' parameter; the elements are inserted after the OutputField
element at the 'at' index. In other words, find the 'whichOutput' Output element, add the 'outputNodes'
child elements (which should be OutputField nodes) at the 'at' position in the child nodes.
This function can also be used with the 'nodeName' and 'attributes' to add the list of attributes to
an OutputField element with name 'nodeName' element using the 'xml_model', 'outputNodes' and 'at' parameters.
Finally, one can use this to add the transformation expression given by the 'xformText' parameter
to the node with name 'nodeName'. The string given via 'xformText' is converted to an XML expression similarly
to the function_to_pmml function. In other words, find the OutputField node with the name 'nodeName' and add
the list of attributes given with 'attributes' and also, add the child transformations given in the 'xformText'
parameter.
</p>


<h3>Value</h3>

<p>Output node with the OutputField elements inserted.
</p>


<h3>Author(s)</h3>

<p>Tridivesh Jena
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the standard iris dataset
data(iris)

# Create a linear model and convert it to PMML
mod &lt;- lm(Sepal.Length ~ ., iris)
pmod &lt;- pmml(mod)

# Create additional output nodes
onodes0 &lt;- make_output_nodes(
  name = list("OutputField", "OutputField"),
  attributes = list(list(
    name = "dbl",
    optype = "continuous"
  ), NULL),
  expression = list("ln(x)", "ln(x/(1-x))")
)
onodes2 &lt;- make_output_nodes(
  name = list("OutputField", "OutputField"),
  attributes = list(
    list(
      name = "F1",
      dataType = "double", optype = "continuous"
    ),
    list(name = "F2")
  )
)

# Create new pmml objects with the output nodes appended
pmod2 &lt;- add_output_field(
  xml_model = pmod, outputNodes = onodes2, at = "End",
  xformText = NULL, nodeName = NULL, attributes = NULL,
  whichOutput = 1
)
pmod2 &lt;- add_output_field(
  xml_model = pmod, outputNodes = onodes0, at = "End",
  xformText = NULL, nodeName = NULL,
  attributes = NULL, whichOutput = 1
)

# Create nodes with attributes and transformations
pmod3 &lt;- add_output_field(xml_model = pmod2, outputNodes = onodes2, at = 2)
pmod4 &lt;- add_output_field(
  xml_model = pmod2, xformText = list("exp(x) &amp;&amp; !x"),
  nodeName = "Predicted_Sepal.Length"
)

att &lt;- list(datype = "dbl", optpe = "dsc")
pmod5 &lt;- add_output_field(
  xml_model = pmod2, nodeName = "Predicted_Sepal.Length",
  attributes = att
)
</code></pre>

<hr>
<h2 id='audit'>Audit: artificially constructed dataset</h2><span id='topic+audit'></span>

<h3>Description</h3>

<p>This is an artificial dataset consisting of fictional clients who have been
audited, perhaps for tax refund compliance. For each case an outcome is
recorded (whether the taxpayer's claims had to be adjusted or not) and any
amount of adjustment that resulted is also recorded.
</p>


<h3>Format</h3>

<p>A data frame containing: </p>

<table>
<tr>
 <td style="text-align: left;"> Age </td><td style="text-align: left;"> Numeric </td>
</tr>
<tr>
 <td style="text-align: left;">
Employment </td><td style="text-align: left;"> Categorical string with 7 levels </td>
</tr>
<tr>
 <td style="text-align: left;"> Education </td><td style="text-align: left;">
Categorical string with 16 levels </td>
</tr>
<tr>
 <td style="text-align: left;"> Marital </td><td style="text-align: left;"> Categorical string with 6
levels </td>
</tr>
<tr>
 <td style="text-align: left;"> Occupation </td><td style="text-align: left;"> Categorical string with 14 levels </td>
</tr>
<tr>
 <td style="text-align: left;"> Income </td><td style="text-align: left;">
Numeric </td>
</tr>
<tr>
 <td style="text-align: left;"> Sex </td><td style="text-align: left;"> Categorical string with 2 levels </td>
</tr>
<tr>
 <td style="text-align: left;"> Deductions </td><td style="text-align: left;">
Numeric </td>
</tr>
<tr>
 <td style="text-align: left;"> Hours </td><td style="text-align: left;"> Numeric </td>
</tr>
<tr>
 <td style="text-align: left;"> Accounts </td><td style="text-align: left;"> Categorical string with 32
levels </td>
</tr>
<tr>
 <td style="text-align: left;"> Adjustment </td><td style="text-align: left;"> Numeric </td>
</tr>
<tr>
 <td style="text-align: left;"> Adjusted </td><td style="text-align: left;"> Numeric value 0 or 1
</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>



<h3>References</h3>


<ul>
<li><p> Togaware rattle package : <em><b>Audit dataset</b></em> <br />
</p>
</li>
<li> <p><a href="http://dmg.org/pmml_examples/index.html">DMG description of the Audit dataset</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(audit, package = "pmml")
</code></pre>

<hr>
<h2 id='file_to_xml_node'>Read in a file and parse it into an object of type XMLNode.</h2><span id='topic+file_to_xml_node'></span>

<h3>Description</h3>

<p>Read in a file and parse it into an object of type XMLNode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file_to_xml_node(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="file_to_xml_node_+3A_file">file</code></td>
<td>
<p>The external file to be read in. This file can be any file in
PMML format, regardless of the source or model type.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Read in an external file and convert it into an XMLNode to be used
subsequently by other R functions.
</p>
<p>This format is the one that will be obtained when a model is constructed in
R and output in PMML format.
</p>
<p>This function is mainly meant to be used to read in external files instead
of depending on models saved in R. As an example, the pmml package requires
as input an object of type XMLNode before its functions can be applied.
Function 'file_to_xml_node' can be used to read in an existing PMML file,
convert it to an XML node and then make it available for use by any of the
pmml functions.
</p>


<h3>Value</h3>

<p>An object of class <code>XMLNode</code> as that defined by the <span class="pkg">XML</span> package.
This represents the top level, or root node, of the XML document and is of
type PMML. It can be written to file with <code>saveXML</code>.
</p>


<h3>Author(s)</h3>

<p>Tridivesh Jena
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Define some transformations:
iris_box &lt;- xform_wrap(iris)
iris_box &lt;- xform_z_score(iris_box, xform_info = "column1-&gt;d1")
iris_box &lt;- xform_z_score(iris_box, xform_info = "column2-&gt;d2")

# Make a LocalTransformations element and save it to an external file:
pmml_trans &lt;- pmml(NULL, transforms = iris_box)
write(toString(pmml_trans), file = "xform_iris.pmml")

# Later, we may need to read in the PMML model into R
# 'lt' below is now a XML Node, as opposed to a string:
lt &lt;- file_to_xml_node("xform_iris.pmml")

## End(Not run)

</code></pre>

<hr>
<h2 id='function_to_pmml'>Convert an R expression to PMML.</h2><span id='topic+function_to_pmml'></span>

<h3>Description</h3>

<p>Convert an R expression to PMML.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>function_to_pmml(expr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="function_to_pmml_+3A_expr">expr</code></td>
<td>
<p>An R expression enclosed in quotes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As long as the expression passed to the function is a valid R expression (e.g., no unbalanced parenthesis),
it can contain arbitrary function names not defined in R. Variables in the expression passed
to 'xform_function' are always assumed to be fields, and not substituted. That is, even if 'x' has a value in the
R environment, the resulting expression will still use 'x'.
</p>
<p>An expression such as 'foo(x)' is treated as a function 'foo' with argument 'x'. Consequently, passing in an
R vector 'c(1,2,3)' to 'function_to_pmml()' will produce PMML where 'c' is a function and '1,2,3' are the arguments.
</p>
<p>An expression starting with '-' or '+' (for example, &quot;-3&quot; or &quot;-(a+b)&quot;) will be treated as if there is a 0
before the initial '-' or '+' sign. This makes it possible to represent expressions that start with a sign,
since PMML's '-' and '+' functions require two arguments. The resulting PMML node will have a constant 0 as a child.
</p>


<h3>Value</h3>

<p>PMML version of the input expression
</p>


<h3>Author(s)</h3>

<p>Dmitriy Bolotov
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Operator precedence and parenthesis
func_pmml &lt;- function_to_pmml("1 + 3/5 - (4 * 2)")

# Nested arbitrary functions
func_pmml &lt;- function_to_pmml("foo(bar(x)) - bar(foo(y-z))")

# If-else expression
func_pmml &lt;- function_to_pmml("if (x==3) { 3 } else { 0 }")

# If-else with boolean output
func_pmml &lt;- function_to_pmml("if (x==3) { TRUE } else { FALSE }")

# Function with string argument types
func_pmml &lt;- function_to_pmml("colors('red','green','blue')")

# Sign in front of expression
func_pmml &lt;- function_to_pmml("-(x/y)")
</code></pre>

<hr>
<h2 id='houseVotes84'>Modified 1984 United States Congressional Voting Records Database</h2><span id='topic+houseVotes84'></span>

<h3>Description</h3>

<p>This data set includes votes for each of the U.S. House of Representatives
Congressmen on the 16 key votes identified by the CQA.  The CQA lists nine
different types of votes: voted for, paired for, and announced for (these
three simplified to yea), voted against, paired against, and announced
against (these three simplified to nay), voted present, voted present to
avoid conflict of interest, and did not vote or otherwise make a position
known (these three simplified to an unknown disposition).  Originally
containing a binomial variable &quot;class&quot; and 16 other binary variables, those
16 variables have been renamed to simply &quot;V1&quot;,&quot;V2&quot;,...,&quot;V16&quot;.
</p>


<h3>Format</h3>

<p>A data frame containing: </p>

<table>
<tr>
 <td style="text-align: left;"> Class </td><td style="text-align: left;"> Boolean variable
</td>
</tr>
<tr>
 <td style="text-align: left;"> V1 </td><td style="text-align: left;"> Boolean variable </td>
</tr>
<tr>
 <td style="text-align: left;"> V2 </td><td style="text-align: left;"> Boolean variable </td>
</tr>
<tr>
 <td style="text-align: left;"> V3 </td><td style="text-align: left;">
Boolean variable </td>
</tr>
<tr>
 <td style="text-align: left;"> V4 </td><td style="text-align: left;"> Boolean variable </td>
</tr>
<tr>
 <td style="text-align: left;"> V5 </td><td style="text-align: left;"> Boolean variable
</td>
</tr>
<tr>
 <td style="text-align: left;"> V6 </td><td style="text-align: left;"> Boolean variable </td>
</tr>
<tr>
 <td style="text-align: left;"> V7 </td><td style="text-align: left;"> Boolean variable </td>
</tr>
<tr>
 <td style="text-align: left;"> V8 </td><td style="text-align: left;">
Boolean variable </td>
</tr>
<tr>
 <td style="text-align: left;"> V9 </td><td style="text-align: left;"> Boolean variable </td>
</tr>
<tr>
 <td style="text-align: left;"> V10 </td><td style="text-align: left;"> Boolean variable
</td>
</tr>
<tr>
 <td style="text-align: left;"> V11 </td><td style="text-align: left;"> Boolean variable </td>
</tr>
<tr>
 <td style="text-align: left;"> V12 </td><td style="text-align: left;"> Boolean variable </td>
</tr>
<tr>
 <td style="text-align: left;"> V13 </td><td style="text-align: left;">
Boolean variable </td>
</tr>
<tr>
 <td style="text-align: left;"> V14 </td><td style="text-align: left;"> Boolean variable </td>
</tr>
<tr>
 <td style="text-align: left;"> V15 </td><td style="text-align: left;"> Boolean variable
</td>
</tr>
<tr>
 <td style="text-align: left;"> V16 </td><td style="text-align: left;"> Boolean variable </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>



<h3>References</h3>

<p><a href="http://archive.ics.uci.edu/ml/datasets/Congressional+Voting+Records">UCI
Machine Learning Repository</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(houseVotes84, package = "pmml")
</code></pre>

<hr>
<h2 id='make_intervals'>Create Interval elements, most likely to add to a DataDictionary element.</h2><span id='topic+make_intervals'></span>

<h3>Description</h3>

<p>Create Interval elements, most likely to add to a DataDictionary element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_intervals(
  closure = NULL,
  leftMargin = NULL,
  rightMargin = NULL,
  namespace = "4_4"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_intervals_+3A_closure">closure</code></td>
<td>
<p>The 'closure' attribute of each 'Interval' element to be created in order.</p>
</td></tr>
<tr><td><code id="make_intervals_+3A_leftmargin">leftMargin</code></td>
<td>
<p>The 'leftMargin' attribute of each 'Interval' element to be created in order.</p>
</td></tr>
<tr><td><code id="make_intervals_+3A_rightmargin">rightMargin</code></td>
<td>
<p>The 'rightMargin' attribute of each 'Interval' element to be created in order.</p>
</td></tr>
<tr><td><code id="make_intervals_+3A_namespace">namespace</code></td>
<td>
<p>The namespace of the PMML model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'Interval' element allows 3 attributes, all of which may be defined in the 'make_intervals'
function. The value of these attributes should be provided as a list. Thus the elements of the
'leftMargin' for example define the value of that attribute for each 'Interval' element in order.
</p>


<h3>Value</h3>

<p>PMML Intervals elements.
</p>


<h3>Author(s)</h3>

<p>Tridivesh Jena
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_values">make_values</a></code> to make Values child elements, <code><a href="#topic+add_data_field_children">add_data_field_children</a></code>
to add these xml fragments to the DataDictionary PMML element.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make 3 Interval elements
# we define the 3 Intervals as ,1]  (1,2)  and [2,
mi &lt;- make_intervals(
  list("openClosed", "openOpen", "closedOpen"),
  list(NULL, 1, 2), list(1, 2, NULL)
)
</code></pre>

<hr>
<h2 id='make_output_nodes'>Add Output nodes to a PMML object.</h2><span id='topic+make_output_nodes'></span>

<h3>Description</h3>

<p>Add Output nodes to a PMML object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_output_nodes(
  name = "OutputField",
  attributes = NULL,
  expression = NULL,
  namespace = "4_4"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_output_nodes_+3A_name">name</code></td>
<td>
<p>The name of the element to be created.</p>
</td></tr>
<tr><td><code id="make_output_nodes_+3A_attributes">attributes</code></td>
<td>
<p>The node attributes to be added.</p>
</td></tr>
<tr><td><code id="make_output_nodes_+3A_expression">expression</code></td>
<td>
<p>Post-processing information to be included in the element.
This expression will be processed by <code>function_to_pmml</code>.</p>
</td></tr>
<tr><td><code id="make_output_nodes_+3A_namespace">namespace</code></td>
<td>
<p>The namespace of the PMML model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Create a list of nodes with names <code>'name'</code>, attributes <code>'attributes'</code> and
child elements <code>'expression'</code>. <code>'expression'</code> is a string converted to XML
similar to <code>function_to_pmml</code>.
</p>
<p>Meant to create OutputField elements, 'expressions' can be used to add
post-processing transformations to a model. To create multiple such nodes,
all the parameters must be given as lists of equal length.
</p>


<h3>Value</h3>

<p>List of nodes
</p>


<h3>Author(s)</h3>

<p>Tridivesh Jena
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make two nodes, one with attributes
two_nodes &lt;- make_output_nodes(
  name = list("OutputField", "OutputField"),
  attributes = list(list(name = "dbl", optype = "continuous"), NULL),
  expression = list("ln(x)", "ln(x/(1-x))")
)
</code></pre>

<hr>
<h2 id='make_values'>Create Values element, most likely to add to a DataDictionary element.</h2><span id='topic+make_values'></span>

<h3>Description</h3>

<p>Create Values element, most likely to add to a DataDictionary element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_values(
  value = NULL,
  displayValue = NULL,
  property = NULL,
  namespace = "4_4"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_values_+3A_value">value</code></td>
<td>
<p>The 'value' attribute of each 'Value' element to be created in order.</p>
</td></tr>
<tr><td><code id="make_values_+3A_displayvalue">displayValue</code></td>
<td>
<p>The 'displayValue' attribute of each 'Value' element to be created in order.</p>
</td></tr>
<tr><td><code id="make_values_+3A_property">property</code></td>
<td>
<p>The 'property' attribute of each 'Value' element to be created in order.</p>
</td></tr>
<tr><td><code id="make_values_+3A_namespace">namespace</code></td>
<td>
<p>The namespace of the PMML model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used the same way as the <code>make_intervals</code> function. If certain attributes for an
element should not be included, they should be input in the list as NULL.
</p>


<h3>Value</h3>

<p>PMML Values elements.
</p>


<h3>Author(s)</h3>

<p>Tridivesh Jena
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_intervals">make_intervals</a></code> to make Interval child elements, <code><a href="#topic+add_data_field_children">add_data_field_children</a></code>
to add these xml fragments to the DataDictionary PMML element.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define 3 values, none with a 'displayValue' attribute and 1 value
# defined as 'invalid'. The 2nd one is 'valid' by default.
mv &lt;- make_values(
  list(1.1, 2.2, 3.3), list(NULL, NULL, NULL),
  list("valid", NULL, "invalid")
)
</code></pre>

<hr>
<h2 id='pmml'>Generate the PMML representation for R objects.</h2><span id='topic+pmml'></span>

<h3>Description</h3>

<p><code>pmml</code> is a generic function implementing S3 methods used to produce
the PMML (Predictive Model Markup Language) representation of an R model.
The resulting PMML file can then be imported into other systems that accept
PMML.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmml(
  model = NULL,
  model_name = "R_Model",
  app_name = "SoftwareAG PMML Generator",
  description = NULL,
  copyright = NULL,
  model_version = NULL,
  transforms = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmml_+3A_model">model</code></td>
<td>
<p>An object to be converted to PMML.</p>
</td></tr>
<tr><td><code id="pmml_+3A_model_name">model_name</code></td>
<td>
<p>A name to be given to the PMML model.</p>
</td></tr>
<tr><td><code id="pmml_+3A_app_name">app_name</code></td>
<td>
<p>The name of the application that generated the PMML.</p>
</td></tr>
<tr><td><code id="pmml_+3A_description">description</code></td>
<td>
<p>A descriptive text for the Header element of the PMML.</p>
</td></tr>
<tr><td><code id="pmml_+3A_copyright">copyright</code></td>
<td>
<p>The copyright notice for the model.</p>
</td></tr>
<tr><td><code id="pmml_+3A_model_version">model_version</code></td>
<td>
<p>A string specifying the model version.</p>
</td></tr>
<tr><td><code id="pmml_+3A_transforms">transforms</code></td>
<td>
<p>Data transformations.</p>
</td></tr>
<tr><td><code id="pmml_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data transformation functions previously available in the separate
<code>pmmlTransformations</code> package have been merged into <code>pmml</code>
starting with version 2.0.0.
</p>
<p>This function can also be used to output variable transformations in PMML
format. In particular, it can be used as a transformations generator.
Various transformation operations can be implemented in R and those
transformations can then be output in PMML format by calling the function
with a NULL value for the model input and a data transformation object as
the transforms input. Please see the documentation for <code>xform_wrap</code> for
more information on how to create a data transformation object.
</p>
<p>In addition, the <code>pmml</code> function can also be called using a
pre-existing PMML model as the first input and a data transformation object
as the transforms input.  The result is a new PMML model with the
transformation inserted as a &quot;LocalTransformations&quot; element in the original
model. If the original model already had a &quot;LocalTransformations&quot; element,
the new information will be appended to that element. If the model variables
are derived directly from a chain of transformations defined in the
transforms input, the field names in the model are replaced with the
original field names with the correct data types to make a consistent model.
The covered cases include model fields derived from an original field, model
fields derived from a chain of transformations starting from an original
field and multiple fields derived from the same original field.
</p>
<p>This package exports models to PMML version 4.4.1.
</p>
<p>Please note that package <span class="pkg">XML_3.95-0.1</span> or later is required to perform
the full and correct functionality of <span class="pkg">pmml</span>.
</p>
<p>If data used for an R model contains features of type <code>character</code>,
these must be converted to factors before the model is trained and converted
with <code>pmml</code>.
</p>
<p>A list of all the supported models and packages is available in the
vignette:
</p>
<p><code>vignette("packages_and_functions", package="pmml")</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>XMLNode</code> as that defined by the <span class="pkg">XML</span> package.
This represents the top level, or root node, of the XML document and is of
type PMML. It can be written to file with <code>saveXML</code>.
</p>


<h3>Author(s)</h3>

<p>Graham Williams
</p>


<h3>References</h3>


<ul>
<li> <p><a href="http://dmg.org/pmml/v4-4-1/GeneralStructure.html">PMML home page</a>
</p>
</li>
<li> <p><a href="http://dmg.org/pmml/v4-4-1/Transformations.html">PMML transformations</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+pmml.ada">pmml.ada</a></code>, <code><a href="#topic+pmml.rules">pmml.rules</a></code>,
<code><a href="#topic+pmml.coxph">pmml.coxph</a></code>, <code><a href="#topic+pmml.cv.glmnet">pmml.cv.glmnet</a></code>,
<code><a href="#topic+pmml.glm">pmml.glm</a></code>, <code><a href="#topic+pmml.hclust">pmml.hclust</a></code>,
<code><a href="#topic+pmml.kmeans">pmml.kmeans</a></code>, <code><a href="#topic+pmml.ksvm">pmml.ksvm</a></code>, <code><a href="#topic+pmml.lm">pmml.lm</a></code>,
<code><a href="#topic+pmml.multinom">pmml.multinom</a></code>, <code><a href="#topic+pmml.naiveBayes">pmml.naiveBayes</a></code>,
<code><a href="#topic+pmml.neighbr">pmml.neighbr</a></code>, <code><a href="#topic+pmml.nnet">pmml.nnet</a></code>,
<code><a href="#topic+pmml.rpart">pmml.rpart</a></code>, <code><a href="#topic+pmml.svm">pmml.svm</a></code>,
<code><a href="#topic+pmml.xgb.Booster">pmml.xgb.Booster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Build an lm model
iris_lm &lt;- lm(Sepal.Length ~ ., data = iris)

# Convert to pmml
iris_lm_pmml &lt;- pmml(iris_lm)

# Create a data transformation object
iris_trans &lt;- xform_wrap(iris)

# Transform the 'Sepal.Length' variable
iris_trans &lt;- xform_min_max(iris_trans, xform_info = "column1-&gt;d_sl")

# Output the tranformation in PMML format
iris_trans_pmml &lt;- pmml(NULL, transforms = iris_trans)
</code></pre>

<hr>
<h2 id='pmml.ada'>Generate the PMML representation for an ada object from the package <span class="pkg">ada</span>.</h2><span id='topic+pmml.ada'></span>

<h3>Description</h3>

<p>Generate the PMML representation for an ada object from the package <span class="pkg">ada</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ada'
pmml(
  model,
  model_name = "AdaBoost_Model",
  app_name = "SoftwareAG PMML Generator",
  description = "AdaBoost Model",
  copyright = NULL,
  model_version = NULL,
  transforms = NULL,
  missing_value_replacement = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmml.ada_+3A_model">model</code></td>
<td>
<p>An ada object.</p>
</td></tr>
<tr><td><code id="pmml.ada_+3A_model_name">model_name</code></td>
<td>
<p>A name to be given to the PMML model.</p>
</td></tr>
<tr><td><code id="pmml.ada_+3A_app_name">app_name</code></td>
<td>
<p>The name of the application that generated the PMML.</p>
</td></tr>
<tr><td><code id="pmml.ada_+3A_description">description</code></td>
<td>
<p>A descriptive text for the Header element of the PMML.</p>
</td></tr>
<tr><td><code id="pmml.ada_+3A_copyright">copyright</code></td>
<td>
<p>The copyright notice for the model.</p>
</td></tr>
<tr><td><code id="pmml.ada_+3A_model_version">model_version</code></td>
<td>
<p>A string specifying the model version.</p>
</td></tr>
<tr><td><code id="pmml.ada_+3A_transforms">transforms</code></td>
<td>
<p>Data transformations.</p>
</td></tr>
<tr><td><code id="pmml.ada_+3A_missing_value_replacement">missing_value_replacement</code></td>
<td>
<p>Value to be used as the 'missingValueReplacement'
attribute for all MiningFields.</p>
</td></tr>
<tr><td><code id="pmml.ada_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Export the ada model in the PMML MiningModel
(multiple models) format.  The MiningModel element consists of a list of
TreeModel elements, one in each model segment.
</p>
<p>This function implements the discrete adaboost algorithm only.  Note that
each segment tree is a classification model, returning either -1 or 1.
However the MiningModel (ada algorithm) is doing a weighted sum of the
returned value, -1 or 1.  So the value of attribute functionName of element
MiningModel is set to &quot;regression&quot;; the value of attribute functionName of
each segment tree is also set to &quot;regression&quot; (they have to be the same as
the parent MiningModel per PMML schema). Although each segment/tree is being
named a &quot;regression&quot; tree, the actual returned score can only be -1 or 1,
which practically turns each segment into a classification tree.
</p>
<p>The model in PMML format has 5 different outputs. The &quot;rawValue&quot; output is
the value of the model expressed as a tree model. The boosted tree model
uses a transformation of this value, this is the &quot;boostValue&quot; output. The
last 3 outputs are the predicted class and the probabilities of each of the
2 classes (The ada package Boosted Tree models can only handle binary
classification models).
</p>


<h3>Author(s)</h3>

<p>Wen Lin
</p>


<h3>References</h3>

<p><a href="https://CRAN.R-project.org/package=ada">ada: an R package for
stochastic boosting (on CRAN)</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(ada)
data(audit)

fit &lt;- ada(Adjusted ~ Employment + Education + Hours + Income, iter = 3, audit)
fit_pmml &lt;- pmml(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='pmml.ARIMA'>Generate PMML for an ARIMA object the <b>forecast</b> package.</h2><span id='topic+pmml.ARIMA'></span>

<h3>Description</h3>

<p>Generate PMML for an ARIMA object the <b>forecast</b> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ARIMA'
pmml(
  model,
  model_name = "ARIMA_model",
  app_name = "SoftwareAG PMML Generator",
  description = "ARIMA Time Series Model",
  copyright = NULL,
  model_version = NULL,
  transforms = NULL,
  missing_value_replacement = NULL,
  ts_type = "statespace",
  cpi_levels = c(80, 95),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmml.ARIMA_+3A_model">model</code></td>
<td>
<p>An ARIMA object from the package <span class="pkg">forecast</span>.</p>
</td></tr>
<tr><td><code id="pmml.ARIMA_+3A_model_name">model_name</code></td>
<td>
<p>A name to be given to the PMML model.</p>
</td></tr>
<tr><td><code id="pmml.ARIMA_+3A_app_name">app_name</code></td>
<td>
<p>The name of the application that generated the PMML.</p>
</td></tr>
<tr><td><code id="pmml.ARIMA_+3A_description">description</code></td>
<td>
<p>A descriptive text for the Header element of the PMML.</p>
</td></tr>
<tr><td><code id="pmml.ARIMA_+3A_copyright">copyright</code></td>
<td>
<p>The copyright notice for the model.</p>
</td></tr>
<tr><td><code id="pmml.ARIMA_+3A_model_version">model_version</code></td>
<td>
<p>A string specifying the model version.</p>
</td></tr>
<tr><td><code id="pmml.ARIMA_+3A_transforms">transforms</code></td>
<td>
<p>Data transformations.</p>
</td></tr>
<tr><td><code id="pmml.ARIMA_+3A_missing_value_replacement">missing_value_replacement</code></td>
<td>
<p>Value to be used as the 'missingValueReplacement'
attribute for all MiningFields.</p>
</td></tr>
<tr><td><code id="pmml.ARIMA_+3A_ts_type">ts_type</code></td>
<td>
<p>The type of time series representation for PMML: &quot;arima&quot; or &quot;statespace&quot;.</p>
</td></tr>
<tr><td><code id="pmml.ARIMA_+3A_cpi_levels">cpi_levels</code></td>
<td>
<p>Vector of confidence levels for prediction intervals.</p>
</td></tr>
<tr><td><code id="pmml.ARIMA_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is represented as a PMML TimeSeriesModel.
</p>
<p>When <code>ts_type = "statespace"</code> (by default), the R object is exported as StateSpaceModel in PMML.
</p>
<p>When <code>ts_type = "arima"</code>, the R object is exported as ARIMA in PMML with conditional
least squares (CLS). Note that ARIMA models in R are
estimated using a state space representation. Therefore, when using CLS with seasonal models,
forecast results between R and PMML may not match exactly. Additionally, when ts_type=&quot;arima&quot;, prediction intervals
are exported for non-seasonal models only. For ARIMA models with d=2, the prediction intervals
between R and PMML may not match.
</p>
<p>OutputField elements are exported with
dataType &quot;string&quot;, and contain a collection of all values up to and including the steps-ahead value supplied
during scoring.
String output in this form is facilitated by Extension elements in the PMML file,
and is supported by Zementis Server since version 10.6.0.0.
</p>
<p><code>cpi_levels</code> behaves similar to <code>levels</code> in <code>forecast::forecast</code>: values must be
between 0 and 100, non-inclusive.
</p>
<p>Models with a drift term will be supported in a future version.
</p>
<p>Transforms are currently not supported for ARIMA models.
</p>


<h3>Value</h3>

<p>PMML representation of the <code>ARIMA</code> object.
</p>


<h3>Author(s)</h3>

<p>Dmitriy Bolotov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(forecast)

# non-seasonal model
data("WWWusage")
mod &lt;- Arima(WWWusage, order = c(3, 1, 1))
mod_pmml &lt;- pmml(mod)

# seasonal model
data("JohnsonJohnson")
mod_02 &lt;- Arima(JohnsonJohnson,
  order = c(1, 1, 1),
  seasonal = c(1, 1, 1)
)
mod_02_pmml &lt;- pmml(mod_02)

# non-seasonal model exported with Conditional Least Squares
data("WWWusage")
mod &lt;- Arima(WWWusage, order = c(3, 1, 1))
mod_pmml &lt;- pmml(mod, ts_type = "arima")

## End(Not run)

</code></pre>

<hr>
<h2 id='pmml.coxph'>Generate the PMML representation for a coxph object from the package
<span class="pkg">survival</span>.</h2><span id='topic+pmml.coxph'></span>

<h3>Description</h3>

<p>Generate the PMML representation for a coxph object from the package
<span class="pkg">survival</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coxph'
pmml(
  model,
  model_name = "CoxPH_Survival_Regression_Model",
  app_name = "SoftwareAG PMML Generator",
  description = "CoxPH Survival Regression Model",
  copyright = NULL,
  model_version = NULL,
  transforms = NULL,
  missing_value_replacement = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmml.coxph_+3A_model">model</code></td>
<td>
<p>A coxph object.</p>
</td></tr>
<tr><td><code id="pmml.coxph_+3A_model_name">model_name</code></td>
<td>
<p>A name to be given to the PMML model.</p>
</td></tr>
<tr><td><code id="pmml.coxph_+3A_app_name">app_name</code></td>
<td>
<p>The name of the application that generated the PMML.</p>
</td></tr>
<tr><td><code id="pmml.coxph_+3A_description">description</code></td>
<td>
<p>A descriptive text for the Header element of the PMML.</p>
</td></tr>
<tr><td><code id="pmml.coxph_+3A_copyright">copyright</code></td>
<td>
<p>The copyright notice for the model.</p>
</td></tr>
<tr><td><code id="pmml.coxph_+3A_model_version">model_version</code></td>
<td>
<p>A string specifying the model version.</p>
</td></tr>
<tr><td><code id="pmml.coxph_+3A_transforms">transforms</code></td>
<td>
<p>Data transformations.</p>
</td></tr>
<tr><td><code id="pmml.coxph_+3A_missing_value_replacement">missing_value_replacement</code></td>
<td>
<p>Value to be used as the 'missingValueReplacement'
attribute for all MiningFields.</p>
</td></tr>
<tr><td><code id="pmml.coxph_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A coxph object is the result of fitting a proportional hazards regression
model, using the <code>coxph</code> function from the package <span class="pkg">survival</span>. Although
the <span class="pkg">survival</span> package supports special terms &quot;cluster&quot;, &quot;tt&quot; and
&quot;strata&quot;, only the special term &quot;strata&quot; is supported by the <span class="pkg">pmml</span>
package. Note that special term &quot;strata&quot; cannot be a multiplicative variable
and only numeric risk regression is supported.
</p>


<h3>Author(s)</h3>

<p>Graham Williams
</p>


<h3>References</h3>

<p><a href="https://CRAN.R-project.org/package=survival">coxph: Survival
Analysis</a>
</p>

<hr>
<h2 id='pmml.cv.glmnet'>Generate the PMML representation for a cv.glmnet object from the package
<span class="pkg">glmnet</span>.</h2><span id='topic+pmml.cv.glmnet'></span>

<h3>Description</h3>

<p>Generate the PMML representation for a cv.glmnet object from the package
<span class="pkg">glmnet</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.glmnet'
pmml(
  model,
  model_name = "Elasticnet_Model",
  app_name = "SoftwareAG PMML Generator",
  description = "Generalized Linear Regression Model",
  copyright = NULL,
  model_version = NULL,
  transforms = NULL,
  missing_value_replacement = NULL,
  dataset = NULL,
  s = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmml.cv.glmnet_+3A_model">model</code></td>
<td>
<p>A cv.glmnet object.</p>
</td></tr>
<tr><td><code id="pmml.cv.glmnet_+3A_model_name">model_name</code></td>
<td>
<p>A name to be given to the PMML model.</p>
</td></tr>
<tr><td><code id="pmml.cv.glmnet_+3A_app_name">app_name</code></td>
<td>
<p>The name of the application that generated the PMML.</p>
</td></tr>
<tr><td><code id="pmml.cv.glmnet_+3A_description">description</code></td>
<td>
<p>A descriptive text for the Header element of the PMML.</p>
</td></tr>
<tr><td><code id="pmml.cv.glmnet_+3A_copyright">copyright</code></td>
<td>
<p>The copyright notice for the model.</p>
</td></tr>
<tr><td><code id="pmml.cv.glmnet_+3A_model_version">model_version</code></td>
<td>
<p>A string specifying the model version.</p>
</td></tr>
<tr><td><code id="pmml.cv.glmnet_+3A_transforms">transforms</code></td>
<td>
<p>Data transformations.</p>
</td></tr>
<tr><td><code id="pmml.cv.glmnet_+3A_missing_value_replacement">missing_value_replacement</code></td>
<td>
<p>Value to be used as the 'missingValueReplacement'
attribute for all MiningFields.</p>
</td></tr>
<tr><td><code id="pmml.cv.glmnet_+3A_dataset">dataset</code></td>
<td>
<p>Data used to train the cv.glmnet model.</p>
</td></tr>
<tr><td><code id="pmml.cv.glmnet_+3A_s">s</code></td>
<td>
<p>'lambda' parameter at which to output the model. If not given, the
lambda.1se parameter from the model is used instead.</p>
</td></tr>
<tr><td><code id="pmml.cv.glmnet_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>glmnet</code> package expects the input and predicted values in a matrix
format - not as arrays or data frames. As of now, it will also accept
numerical values only. As such, any string variables must be converted to
numerical ones. One possible way to do so is to use data transformation
functions from this package. However, the result is a data frame. In all
cases, lists, arrays and data frames can be converted to a matrix format
using the data.matrix function from the base package. Given a data frame df,
a matrix m can thus be created by using <code>m &lt;- data.matrix(df)</code>.
</p>
<p>The PMML language requires variable names which will be read in as the
column names of the input matrix. If the matrix does not have variable
names, they will be given the default values of &quot;X1&quot;, &quot;X2&quot;, ...
</p>
<p>Currently, only <code>gaussian</code> and <code>poisson</code> family types are
supported.
</p>


<h3>Value</h3>

<p>PMML representation of the cv.glmnet object.
</p>


<h3>Author(s)</h3>

<p>Tridivesh Jena
</p>


<h3>References</h3>

<p><a href="https://CRAN.R-project.org/package=glmnet">glmnet: Lasso and
elastic-net regularized generalized linear models (on CRAN)</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(glmnet)

# Create a simple predictor (x) and response(y) matrices:
x &lt;- matrix(rnorm(100 * 20), 100, 20)
y &lt;- rnorm(100)

# Build a simple gaussian model:
model1 &lt;- cv.glmnet(x, y)

# Output the model in PMML format:
model1_pmml &lt;- pmml(model1)

# Shift y between 0 and 1 to create a poisson response:
y &lt;- y - min(y)

# Give the predictor variables names (default values are V1,V2,...):
name &lt;- NULL
for (i in 1:20) {
  name &lt;- c(name, paste("variable", i, sep = ""))
}
colnames(x) &lt;- name

# Create a simple poisson model:
model2 &lt;- cv.glmnet(x, y, family = "poisson")

# Output the regression model in PMML format at the lambda
# parameter = 0.006:
model2_pmml &lt;- pmml(model2, s = 0.006)

## End(Not run)
</code></pre>

<hr>
<h2 id='pmml.gbm'>Generate the PMML representation for a gbm object from the package <span class="pkg">gbm</span>.</h2><span id='topic+pmml.gbm'></span>

<h3>Description</h3>

<p>Generate the PMML representation for a gbm object from the package <span class="pkg">gbm</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gbm'
pmml(
  model,
  model_name = "GBM_Model",
  app_name = "SoftwareAG PMML Generator",
  description = "Generalized Boosted Tree Model",
  copyright = NULL,
  model_version = NULL,
  transforms = NULL,
  missing_value_replacement = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmml.gbm_+3A_model">model</code></td>
<td>
<p>A <code>gbm</code> object.</p>
</td></tr>
<tr><td><code id="pmml.gbm_+3A_model_name">model_name</code></td>
<td>
<p>A name to be given to the PMML model.</p>
</td></tr>
<tr><td><code id="pmml.gbm_+3A_app_name">app_name</code></td>
<td>
<p>The name of the application that generated the PMML.</p>
</td></tr>
<tr><td><code id="pmml.gbm_+3A_description">description</code></td>
<td>
<p>A descriptive text for the Header element of the PMML.</p>
</td></tr>
<tr><td><code id="pmml.gbm_+3A_copyright">copyright</code></td>
<td>
<p>The copyright notice for the model.</p>
</td></tr>
<tr><td><code id="pmml.gbm_+3A_model_version">model_version</code></td>
<td>
<p>A string specifying the model version.</p>
</td></tr>
<tr><td><code id="pmml.gbm_+3A_transforms">transforms</code></td>
<td>
<p>Data transformations.</p>
</td></tr>
<tr><td><code id="pmml.gbm_+3A_missing_value_replacement">missing_value_replacement</code></td>
<td>
<p>Value to be used as the 'missingValueReplacement'
attribute for all MiningFields.</p>
</td></tr>
<tr><td><code id="pmml.gbm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'gbm' function uses various distribution types to fit a model; currently
only the &quot;bernoulli&quot;, &quot;poisson&quot; and &quot;multinomial&quot; distribution types are
supported.
</p>
<p>For all cases, the model output includes the gbm prediction type
&quot;link&quot; and &quot;response&quot;.
</p>


<h3>Value</h3>

<p>PMML representation of the gbm object.
</p>


<h3>Author(s)</h3>

<p>Tridivesh Jena
</p>


<h3>References</h3>

<p><a href="https://CRAN.R-project.org/package=gbm">gbm: Generalized Boosted
Regression Models (on CRAN)</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(gbm)
data(audit)

mod &lt;- gbm(Adjusted ~ .,
  data = audit[, -c(1, 4, 6, 9, 10, 11, 12)],
  n.trees = 3, interaction.depth = 4
)

mod_pmml &lt;- pmml(mod)

# Classification example:
mod2 &lt;- gbm(Species ~ .,
  data = iris, n.trees = 2,
  interaction.depth = 3, distribution = "multinomial"
)

# The PMML will include a regression model to read the gbm object outputs
# and convert to a "response" prediction type.
mod2_pmml &lt;- pmml(mod2)

## End(Not run)
</code></pre>

<hr>
<h2 id='pmml.glm'>Generate the PMML representation for a glm object from the package <span class="pkg">stats</span>.</h2><span id='topic+pmml.glm'></span>

<h3>Description</h3>

<p>Generate the PMML representation for a glm object from the package <span class="pkg">stats</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glm'
pmml(
  model,
  model_name = "General_Regression_Model",
  app_name = "SoftwareAG PMML Generator",
  description = "Generalized Linear Regression Model",
  copyright = NULL,
  model_version = NULL,
  transforms = NULL,
  missing_value_replacement = NULL,
  weights = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmml.glm_+3A_model">model</code></td>
<td>
<p>A glm object.</p>
</td></tr>
<tr><td><code id="pmml.glm_+3A_model_name">model_name</code></td>
<td>
<p>A name to be given to the PMML model.</p>
</td></tr>
<tr><td><code id="pmml.glm_+3A_app_name">app_name</code></td>
<td>
<p>The name of the application that generated the PMML.</p>
</td></tr>
<tr><td><code id="pmml.glm_+3A_description">description</code></td>
<td>
<p>A descriptive text for the Header element of the PMML.</p>
</td></tr>
<tr><td><code id="pmml.glm_+3A_copyright">copyright</code></td>
<td>
<p>The copyright notice for the model.</p>
</td></tr>
<tr><td><code id="pmml.glm_+3A_model_version">model_version</code></td>
<td>
<p>A string specifying the model version.</p>
</td></tr>
<tr><td><code id="pmml.glm_+3A_transforms">transforms</code></td>
<td>
<p>Data transformations.</p>
</td></tr>
<tr><td><code id="pmml.glm_+3A_missing_value_replacement">missing_value_replacement</code></td>
<td>
<p>Value to be used as the 'missingValueReplacement'
attribute for all MiningFields.</p>
</td></tr>
<tr><td><code id="pmml.glm_+3A_weights">weights</code></td>
<td>
<p>The weights used for building the model.</p>
</td></tr>
<tr><td><code id="pmml.glm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function exports the glm model in the PMML GeneralRegressionModel
format.
</p>
<p>Note on glm models for 2-class problems: a dataset where the target
categorical variable has more than 2 classes may be turned into a 2-class
problem by creating a new target variable that is TRUE for a particular
class and FALSE for all other classes. While the R formula function allows
such a transformation to be passed directly to it, this may cause issues
when the model is converted to PMML. Therefore, it is advised to create a
new 2-class separately, and then pass that variable to glm(). This is shown
in an example below.
</p>


<h3>Value</h3>

<p>PMML representation of the glm object.
</p>


<h3>References</h3>

<p><a href="http://stat.ethz.ch/R-manual/R-devel/library/stats/html/glm.html">R project: Fitting Generalized Linear Models</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(iris)
mod &lt;- glm(Sepal.Length ~ ., data = iris, family = "gaussian")
mod_pmml &lt;- pmml(mod)
rm(mod, mod_pmml)

data(audit)
mod &lt;- glm(Adjusted ~ Age + Employment + Education + Income, data = audit, family = binomial(logit))
mod_pmml &lt;- pmml(mod)
rm(mod, mod_pmml)

# Create a new 2-class target from a 3-class variable:
data(iris)
dat &lt;- iris[, 1:4]
# Add a new 2-class target "Species_setosa" before passing it to glm():
dat$Species_setosa &lt;- iris$Species == "setosa"
mod &lt;- glm(Species_setosa ~ ., data = dat, family = binomial(logit))
mod_pmml &lt;- pmml(mod)
rm(dat, mod, mod_pmml)

## End(Not run)
</code></pre>

<hr>
<h2 id='pmml.hclust'>Generate the PMML representation for a hclust object from the package <span class="pkg">amap</span>.</h2><span id='topic+pmml.hclust'></span>

<h3>Description</h3>

<p>Generate the PMML representation for a hclust object from the package <span class="pkg">amap</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hclust'
pmml(
  model,
  model_name = "HClust_Model",
  app_name = "SoftwareAG PMML Generator",
  description = "Hierarchical Cluster Model",
  copyright = NULL,
  model_version = NULL,
  transforms = NULL,
  missing_value_replacement = NULL,
  centers,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmml.hclust_+3A_model">model</code></td>
<td>
<p>A hclust object.</p>
</td></tr>
<tr><td><code id="pmml.hclust_+3A_model_name">model_name</code></td>
<td>
<p>A name to be given to the PMML model.</p>
</td></tr>
<tr><td><code id="pmml.hclust_+3A_app_name">app_name</code></td>
<td>
<p>The name of the application that generated the PMML.</p>
</td></tr>
<tr><td><code id="pmml.hclust_+3A_description">description</code></td>
<td>
<p>A descriptive text for the Header element of the PMML.</p>
</td></tr>
<tr><td><code id="pmml.hclust_+3A_copyright">copyright</code></td>
<td>
<p>The copyright notice for the model.</p>
</td></tr>
<tr><td><code id="pmml.hclust_+3A_model_version">model_version</code></td>
<td>
<p>A string specifying the model version.</p>
</td></tr>
<tr><td><code id="pmml.hclust_+3A_transforms">transforms</code></td>
<td>
<p>Data transformations.</p>
</td></tr>
<tr><td><code id="pmml.hclust_+3A_missing_value_replacement">missing_value_replacement</code></td>
<td>
<p>Value to be used as the 'missingValueReplacement'
attribute for all MiningFields.</p>
</td></tr>
<tr><td><code id="pmml.hclust_+3A_centers">centers</code></td>
<td>
<p>A list of means to represent the clusters.</p>
</td></tr>
<tr><td><code id="pmml.hclust_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts a hclust object created by the <code>hclusterpar</code> function
from the <span class="pkg">amap</span> package.  A <code>hclust</code> object is a cluster model created
hierarchically. The data is divided recursively until a criteria is met.
This function then takes the final model and represents it as a standard
k-means cluster model. This is possible since while the method of
constructing the model is different, the final model can be represented in
the same way.
</p>
<p>To use this pmml function, therefore, one must pick the number of clusters
desired and the coordinate values at those cluster centers. This can be done
using the <code>hclusterpar</code> and <code>centers.hclust</code> functions from the
<span class="pkg">amap</span> and <code>rattle</code> packages respectively.
</p>
<p>The hclust object will be approximated by <code>k</code> centroids and is
converted into a PMML representation for kmeans clusters.
</p>


<h3>Value</h3>

<p>PMML representation of the hclust object.
</p>


<h3>Author(s)</h3>

<p>Graham Williams
</p>


<h3>References</h3>

<p><a href="http://stat.ethz.ch/R-manual/R-devel/library/stats/html/hclust.html">R project: Hierarchical Clustering</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Cluster the 4 numeric variables of the iris dataset.
library(amap)
library(rattle)

model &lt;- hclusterpar(iris[, -5])

# Get the information about the cluster centers. The last
# parameter of the function used is the number of clusters
# desired.
centerInfo &lt;- centers.hclust(iris[, -5], model, 3)

# Convert to pmml
model_pmml &lt;- pmml(model, centers = centerInfo)

## End(Not run)
</code></pre>

<hr>
<h2 id='pmml.iForest'>Generate PMML for an iForest object from the <b>isofor</b> package.</h2><span id='topic+pmml.iForest'></span>

<h3>Description</h3>

<p>Generate PMML for an iForest object from the <b>isofor</b> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'iForest'
pmml(
  model,
  model_name = "isolationForest_Model",
  app_name = "SoftwareAG PMML Generator",
  description = "Isolation Forest Model",
  copyright = NULL,
  model_version = NULL,
  transforms = NULL,
  missing_value_replacement = NULL,
  anomaly_threshold = 0.6,
  parent_invalid_value_treatment = "returnInvalid",
  child_invalid_value_treatment = "asIs",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmml.iForest_+3A_model">model</code></td>
<td>
<p>An iForest object from package <b>isofor</b>.</p>
</td></tr>
<tr><td><code id="pmml.iForest_+3A_model_name">model_name</code></td>
<td>
<p>A name to be given to the PMML model.</p>
</td></tr>
<tr><td><code id="pmml.iForest_+3A_app_name">app_name</code></td>
<td>
<p>The name of the application that generated the PMML.</p>
</td></tr>
<tr><td><code id="pmml.iForest_+3A_description">description</code></td>
<td>
<p>A descriptive text for the Header element of the PMML.</p>
</td></tr>
<tr><td><code id="pmml.iForest_+3A_copyright">copyright</code></td>
<td>
<p>The copyright notice for the model.</p>
</td></tr>
<tr><td><code id="pmml.iForest_+3A_model_version">model_version</code></td>
<td>
<p>A string specifying the model version.</p>
</td></tr>
<tr><td><code id="pmml.iForest_+3A_transforms">transforms</code></td>
<td>
<p>Data transformations.</p>
</td></tr>
<tr><td><code id="pmml.iForest_+3A_missing_value_replacement">missing_value_replacement</code></td>
<td>
<p>Value to be used as the 'missingValueReplacement'
attribute for all MiningFields.</p>
</td></tr>
<tr><td><code id="pmml.iForest_+3A_anomaly_threshold">anomaly_threshold</code></td>
<td>
<p>Double between 0 and 1. Predicted values greater than this are classified as anomalies.</p>
</td></tr>
<tr><td><code id="pmml.iForest_+3A_parent_invalid_value_treatment">parent_invalid_value_treatment</code></td>
<td>
<p>Invalid value treatment at the top MiningField level.</p>
</td></tr>
<tr><td><code id="pmml.iForest_+3A_child_invalid_value_treatment">child_invalid_value_treatment</code></td>
<td>
<p>Invalid value treatment at the model segment MiningField level.</p>
</td></tr>
<tr><td><code id="pmml.iForest_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts the iForest model object to the PMML format. The
PMML outputs the anomaly score as well as a boolean value indicating whether the
input is an anomaly or not. This is done by simply comparing the anomaly score with
<code>anomaly_threshold</code>, a parameter in the <code>pmml</code> function.
The iForest function automatically adds an extra level to all categorical variables,
labelled &quot;.&quot;; this is kept in the PMML representation even though the use of this extra
factor in the predict function is unclear.
</p>


<h3>Value</h3>

<p>PMML representation of the <code>iForest</code> object.
</p>


<h3>Author(s)</h3>

<p>Tridivesh Jena
</p>


<h3>References</h3>

<p><a href="https://github.com/gravesee/isofor">isofor package on GitHub</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pmml">pmml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Build iForest model using iris dataset. Create an isolation
# forest with 10 trees. Sample 30 data points at a time from
# the iris dataset to fit the trees.
library(isofor)
data(iris)
mod &lt;- iForest(iris, nt = 10, phi = 30)

# Convert to PMML:
mod_pmml &lt;- pmml(mod)

## End(Not run)

</code></pre>

<hr>
<h2 id='pmml.kmeans'>Generate the PMML representation for a kmeans object from
the package <span class="pkg">stats</span>.</h2><span id='topic+pmml.kmeans'></span>

<h3>Description</h3>

<p>The kmeans object (a cluster described by k centroids) is
converted into a PMML representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kmeans'
pmml(
  model,
  model_name = "KMeans_Model",
  app_name = "SoftwareAG PMML Generator",
  description = "KMeans cluster model",
  copyright = NULL,
  model_version = NULL,
  transforms = NULL,
  missing_value_replacement = NULL,
  algorithm_name = "KMeans: Hartigan and Wong",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmml.kmeans_+3A_model">model</code></td>
<td>
<p>A kmeans object.</p>
</td></tr>
<tr><td><code id="pmml.kmeans_+3A_model_name">model_name</code></td>
<td>
<p>A name to be given to the PMML model.</p>
</td></tr>
<tr><td><code id="pmml.kmeans_+3A_app_name">app_name</code></td>
<td>
<p>The name of the application that generated the PMML.</p>
</td></tr>
<tr><td><code id="pmml.kmeans_+3A_description">description</code></td>
<td>
<p>A descriptive text for the Header element of the PMML.</p>
</td></tr>
<tr><td><code id="pmml.kmeans_+3A_copyright">copyright</code></td>
<td>
<p>The copyright notice for the model.</p>
</td></tr>
<tr><td><code id="pmml.kmeans_+3A_model_version">model_version</code></td>
<td>
<p>A string specifying the model version.</p>
</td></tr>
<tr><td><code id="pmml.kmeans_+3A_transforms">transforms</code></td>
<td>
<p>Data transformations.</p>
</td></tr>
<tr><td><code id="pmml.kmeans_+3A_missing_value_replacement">missing_value_replacement</code></td>
<td>
<p>Value to be used as the 'missingValueReplacement'
attribute for all MiningFields.</p>
</td></tr>
<tr><td><code id="pmml.kmeans_+3A_algorithm_name">algorithm_name</code></td>
<td>
<p>The variety of kmeans used.</p>
</td></tr>
<tr><td><code id="pmml.kmeans_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A kmeans object is obtained by applying the <code>kmeans</code> function from the
<code>stats</code> package. This method typically requires the user to normalize
all the variables; these operations can be done using transforms so that the
normalization information is included in PMML.
</p>


<h3>Author(s)</h3>

<p>Graham Williams
</p>


<h3>References</h3>

<p><a href="http://stat.ethz.ch/R-manual/R-devel/library/stats/html/kmeans.html">R
project: K-Means Clustering</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ds &lt;- rbind(
  matrix(rnorm(100, sd = 0.3), ncol = 2),
  matrix(rnorm(100, mean = 1, sd = 0.3), ncol = 2)
)
colnames(ds) &lt;- c("Dimension1", "Dimension2")
cl &lt;- kmeans(ds, 2)
cl_pmml &lt;- pmml(cl)

## End(Not run)
</code></pre>

<hr>
<h2 id='pmml.ksvm'>Generate the PMML representation for a ksvm object from the package
<span class="pkg">kernlab</span>.</h2><span id='topic+pmml.ksvm'></span>

<h3>Description</h3>

<p>Generate the PMML representation for a ksvm object from the package
<span class="pkg">kernlab</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ksvm'
pmml(
  model,
  model_name = "SVM_model",
  app_name = "SoftwareAG PMML Generator",
  description = "Support Vector Machine Model",
  copyright = NULL,
  model_version = NULL,
  transforms = NULL,
  missing_value_replacement = NULL,
  dataset = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmml.ksvm_+3A_model">model</code></td>
<td>
<p>A ksvm object.</p>
</td></tr>
<tr><td><code id="pmml.ksvm_+3A_model_name">model_name</code></td>
<td>
<p>A name to be given to the PMML model.</p>
</td></tr>
<tr><td><code id="pmml.ksvm_+3A_app_name">app_name</code></td>
<td>
<p>The name of the application that generated the PMML.</p>
</td></tr>
<tr><td><code id="pmml.ksvm_+3A_description">description</code></td>
<td>
<p>A descriptive text for the Header element of the PMML.</p>
</td></tr>
<tr><td><code id="pmml.ksvm_+3A_copyright">copyright</code></td>
<td>
<p>The copyright notice for the model.</p>
</td></tr>
<tr><td><code id="pmml.ksvm_+3A_model_version">model_version</code></td>
<td>
<p>A string specifying the model version.</p>
</td></tr>
<tr><td><code id="pmml.ksvm_+3A_transforms">transforms</code></td>
<td>
<p>Data transformations.</p>
</td></tr>
<tr><td><code id="pmml.ksvm_+3A_missing_value_replacement">missing_value_replacement</code></td>
<td>
<p>Value to be used as the 'missingValueReplacement'
attribute for all MiningFields.</p>
</td></tr>
<tr><td><code id="pmml.ksvm_+3A_dataset">dataset</code></td>
<td>
<p>Data used to train the ksvm model.</p>
</td></tr>
<tr><td><code id="pmml.ksvm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both classification (multi-class and binary) as well as regression cases are
supported.
</p>
<p>The following ksvm kernels are currently supported: rbfdot, polydot,
vanilladot, tanhdot.
</p>
<p>The argument <code>dataset</code> is required since the <code>ksvm</code> object does not
contain information about the used categorical variable.
</p>


<h3>Value</h3>

<p>PMML representation of the ksvm object.
</p>


<h3>References</h3>

<p><a href="https://CRAN.R-project.org/package=kernlab">kernlab: Kernel-based
Machine Learning Lab (on CRAN)</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Train a support vector machine to perform classification.
library(kernlab)

model &lt;- ksvm(Species ~ ., data = iris)

model_pmml &lt;- pmml(model, dataset = iris)

## End(Not run)
</code></pre>

<hr>
<h2 id='pmml.lm'>Generate the PMML representation for an lm object from the package <span class="pkg">stats</span>.</h2><span id='topic+pmml.lm'></span>

<h3>Description</h3>

<p>Generate the PMML representation for an lm object from the package <span class="pkg">stats</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm'
pmml(
  model,
  model_name = "lm_Model",
  app_name = "SoftwareAG PMML Generator",
  description = "Linear Regression Model",
  copyright = NULL,
  model_version = NULL,
  transforms = NULL,
  missing_value_replacement = NULL,
  weights = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmml.lm_+3A_model">model</code></td>
<td>
<p>An lm object.</p>
</td></tr>
<tr><td><code id="pmml.lm_+3A_model_name">model_name</code></td>
<td>
<p>A name to be given to the PMML model.</p>
</td></tr>
<tr><td><code id="pmml.lm_+3A_app_name">app_name</code></td>
<td>
<p>The name of the application that generated the PMML.</p>
</td></tr>
<tr><td><code id="pmml.lm_+3A_description">description</code></td>
<td>
<p>A descriptive text for the Header element of the PMML.</p>
</td></tr>
<tr><td><code id="pmml.lm_+3A_copyright">copyright</code></td>
<td>
<p>The copyright notice for the model.</p>
</td></tr>
<tr><td><code id="pmml.lm_+3A_model_version">model_version</code></td>
<td>
<p>A string specifying the model version.</p>
</td></tr>
<tr><td><code id="pmml.lm_+3A_transforms">transforms</code></td>
<td>
<p>Data transformations.</p>
</td></tr>
<tr><td><code id="pmml.lm_+3A_missing_value_replacement">missing_value_replacement</code></td>
<td>
<p>Value to be used as the 'missingValueReplacement'
attribute for all MiningFields.</p>
</td></tr>
<tr><td><code id="pmml.lm_+3A_weights">weights</code></td>
<td>
<p>The weights used for building the model.</p>
</td></tr>
<tr><td><code id="pmml.lm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The resulting PMML representation will not encode interaction
terms. Currently, only numeric regression is supported.
</p>


<h3>Value</h3>

<p>PMML representation of the <code>lm</code> object.
</p>


<h3>Author(s)</h3>

<p>Rajarshi Guha
</p>


<h3>References</h3>

<p><a href="http://stat.ethz.ch/R-manual/R-devel/library/stats/html/lm.html">R project: Fitting Linear Models</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- lm(Sepal.Length ~ ., data = iris)
fit_pmml &lt;- pmml(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='pmml.multinom'>Generate the PMML representation for a multinom object from package
<span class="pkg">nnet</span>.</h2><span id='topic+pmml.multinom'></span>

<h3>Description</h3>

<p>Generate the multinomial logistic model in the PMML
RegressionModel format.  The function implements the use of numerical,
categorical and multiplicative terms involving both numerical and
categorical variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multinom'
pmml(
  model,
  model_name = "multinom_Model",
  app_name = "SoftwareAG PMML Generator",
  description = "Multinomial Logistic Model",
  copyright = NULL,
  model_version = NULL,
  transforms = NULL,
  missing_value_replacement = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmml.multinom_+3A_model">model</code></td>
<td>
<p>A multinom object.</p>
</td></tr>
<tr><td><code id="pmml.multinom_+3A_model_name">model_name</code></td>
<td>
<p>A name to be given to the PMML model.</p>
</td></tr>
<tr><td><code id="pmml.multinom_+3A_app_name">app_name</code></td>
<td>
<p>The name of the application that generated the PMML.</p>
</td></tr>
<tr><td><code id="pmml.multinom_+3A_description">description</code></td>
<td>
<p>A descriptive text for the Header element of the PMML.</p>
</td></tr>
<tr><td><code id="pmml.multinom_+3A_copyright">copyright</code></td>
<td>
<p>The copyright notice for the model.</p>
</td></tr>
<tr><td><code id="pmml.multinom_+3A_model_version">model_version</code></td>
<td>
<p>A string specifying the model version.</p>
</td></tr>
<tr><td><code id="pmml.multinom_+3A_transforms">transforms</code></td>
<td>
<p>Data transformations.</p>
</td></tr>
<tr><td><code id="pmml.multinom_+3A_missing_value_replacement">missing_value_replacement</code></td>
<td>
<p>Value to be used as the 'missingValueReplacement'
attribute for all MiningFields.</p>
</td></tr>
<tr><td><code id="pmml.multinom_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>PMML representation of the <code>multinom</code> object.
</p>


<h3>Author(s)</h3>

<p>Tridivesh Jena
</p>


<h3>References</h3>

<p><a href="https://CRAN.R-project.org/package=nnet">nnet: Feed-forward
Neural Networks and Multinomial Log-Linear Models (on CRAN)</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(nnet)
fit &lt;- multinom(Species ~ ., data = iris)
fit_pmml &lt;- pmml(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='pmml.naiveBayes'>Generate the PMML representation for a naiveBayes object from the package
<span class="pkg">e1071</span>.</h2><span id='topic+pmml.naiveBayes'></span>

<h3>Description</h3>

<p>Generate the PMML representation for a naiveBayes object from the package
<span class="pkg">e1071</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'naiveBayes'
pmml(
  model,
  model_name = "naiveBayes_Model",
  app_name = "SoftwareAG PMML Generator",
  description = "NaiveBayes Model",
  copyright = NULL,
  model_version = NULL,
  transforms = NULL,
  missing_value_replacement = NULL,
  predicted_field,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmml.naiveBayes_+3A_model">model</code></td>
<td>
<p>A naiveBayes object.</p>
</td></tr>
<tr><td><code id="pmml.naiveBayes_+3A_model_name">model_name</code></td>
<td>
<p>A name to be given to the PMML model.</p>
</td></tr>
<tr><td><code id="pmml.naiveBayes_+3A_app_name">app_name</code></td>
<td>
<p>The name of the application that generated the PMML.</p>
</td></tr>
<tr><td><code id="pmml.naiveBayes_+3A_description">description</code></td>
<td>
<p>A descriptive text for the Header element of the PMML.</p>
</td></tr>
<tr><td><code id="pmml.naiveBayes_+3A_copyright">copyright</code></td>
<td>
<p>The copyright notice for the model.</p>
</td></tr>
<tr><td><code id="pmml.naiveBayes_+3A_model_version">model_version</code></td>
<td>
<p>A string specifying the model version.</p>
</td></tr>
<tr><td><code id="pmml.naiveBayes_+3A_transforms">transforms</code></td>
<td>
<p>Data transformations.</p>
</td></tr>
<tr><td><code id="pmml.naiveBayes_+3A_missing_value_replacement">missing_value_replacement</code></td>
<td>
<p>Value to be used as the 'missingValueReplacement'
attribute for all MiningFields.</p>
</td></tr>
<tr><td><code id="pmml.naiveBayes_+3A_predicted_field">predicted_field</code></td>
<td>
<p>Required parameter; the name of the predicted field.</p>
</td></tr>
<tr><td><code id="pmml.naiveBayes_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The PMML representation of the NaiveBayes model implements the definition as
specified by the Data Mining Group: intermediate probability values which
are less than the threshold value are replaced by the threshold value. This
is different from the prediction function of the <span class="pkg">e1071</span> in which only
probability values of 0 and standard deviations of continuous variables of
with the value 0 are replaced by the threshold value. The two values will
therefore not match exactly for cases involving very small probabilities.
</p>


<h3>Value</h3>

<p>PMML representation of the naiveBayes object.
</p>


<h3>Author(s)</h3>

<p>Tridivesh Jena
</p>


<h3>References</h3>


<ul>
<li> <p><a href="https://CRAN.R-project.org/package=e1071">e1071: Misc Functions of the Department of Statistics, Probability Theory Group (Formerly: E1071), TU Wien (on CRAN)</a>
</p>
</li>
<li><p> A. Guazzelli, T. Jena, W. Lin, M. Zeller (2013). Extending the Naive
Bayes Model Element in PMML: Adding Support for Continuous Input Variables.
In <em>Proceedings of the 19th ACM SIGKDD Conference on Knowledge
Discovery and Data Mining</em>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(e1071)

data(houseVotes84)
house &lt;- na.omit(houseVotes84)

model &lt;- naiveBayes(Class ~ V1 + V2 + V3, data = house, threshold = 0.003)

model_pmml &lt;- pmml(model, dataset = house, predicted_field = "Class")

## End(Not run)
</code></pre>

<hr>
<h2 id='pmml.neighbr'>Generate PMML for a neighbr object from the <b>neighbr</b> package.</h2><span id='topic+pmml.neighbr'></span>

<h3>Description</h3>

<p>Generate PMML for a neighbr object from the <b>neighbr</b> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'neighbr'
pmml(
  model,
  model_name = "kNN_model",
  app_name = "SoftwareAG PMML Generator",
  description = "K Nearest Neighbors Model",
  copyright = NULL,
  model_version = NULL,
  transforms = NULL,
  missing_value_replacement = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmml.neighbr_+3A_model">model</code></td>
<td>
<p>A neighbr object.</p>
</td></tr>
<tr><td><code id="pmml.neighbr_+3A_model_name">model_name</code></td>
<td>
<p>A name to be given to the PMML model.</p>
</td></tr>
<tr><td><code id="pmml.neighbr_+3A_app_name">app_name</code></td>
<td>
<p>The name of the application that generated the PMML.</p>
</td></tr>
<tr><td><code id="pmml.neighbr_+3A_description">description</code></td>
<td>
<p>A descriptive text for the Header element of the PMML.</p>
</td></tr>
<tr><td><code id="pmml.neighbr_+3A_copyright">copyright</code></td>
<td>
<p>The copyright notice for the model.</p>
</td></tr>
<tr><td><code id="pmml.neighbr_+3A_model_version">model_version</code></td>
<td>
<p>A string specifying the model version.</p>
</td></tr>
<tr><td><code id="pmml.neighbr_+3A_transforms">transforms</code></td>
<td>
<p>Data transformations.</p>
</td></tr>
<tr><td><code id="pmml.neighbr_+3A_missing_value_replacement">missing_value_replacement</code></td>
<td>
<p>Value to be used as the 'missingValueReplacement' attribute for all MiningFields.</p>
</td></tr>
<tr><td><code id="pmml.neighbr_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is represented in the PMML NearestNeighborModel format.
</p>
<p>The current version of this converter does not support transformations (<code>transforms</code>
must be left as <code>NULL</code>), sets <code>categoricalScoringMethod</code> to &quot;majorityVote&quot;, sets
<code>continuousScoringMethod</code> to &quot;average&quot;, and <code>isTransoformed</code> to &quot;false&quot;.
</p>


<h3>Value</h3>

<p>PMML representation of the neighbr object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pmml">pmml</a></code>,
<a href="http://dmg.org/pmml/v4-4-1/KNN.html">PMML KNN specification</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Continuous features with continuous target, categorical target,
# and neighbor ranking:

library(neighbr)
data(iris)

# Add an ID column to the data for neighbor ranking:
iris$ID &lt;- c(1:150)

# Train set contains all predicted variables, features, and ID column:
train_set &lt;- iris[1:140, ]

# Omit predicted variables and ID column from test set:
test_set &lt;- iris[141:150, -c(4, 5, 6)]

fit &lt;- knn(
  train_set = train_set, test_set = test_set,
  k = 3,
  categorical_target = "Species",
  continuous_target = "Petal.Width",
  comparison_measure = "squared_euclidean",
  return_ranked_neighbors = 3,
  id = "ID"
)

fit_pmml &lt;- pmml(fit)


# Logical features with categorical target and neighbor ranking:

library(neighbr)
data("houseVotes84")

# Remove any rows with N/A elements:
dat &lt;- houseVotes84[complete.cases(houseVotes84), ]

# Change all {yes,no} factors to {0,1}:
feature_names &lt;- names(dat)[!names(dat) %in% c("Class", "ID")]
for (n in feature_names) {
  levels(dat[, n])[levels(dat[, n]) == "n"] &lt;- 0
  levels(dat[, n])[levels(dat[, n]) == "y"] &lt;- 1
}

# Change factors to numeric:
for (n in feature_names) {
  dat[, n] &lt;- as.numeric(levels(dat[, n]))[dat[, n]]
}

# Add an ID column for neighbor ranking:
dat$ID &lt;- c(1:nrow(dat))

# Train set contains features, predicted variable, and ID:
train_set &lt;- dat[1:225, ]

# Test set contains features only:
test_set &lt;- dat[226:232, !names(dat) %in% c("Class", "ID")]

fit &lt;- knn(
  train_set = train_set, test_set = test_set,
  k = 5,
  categorical_target = "Class",
  comparison_measure = "jaccard",
  return_ranked_neighbors = 3,
  id = "ID"
)

fit_pmml &lt;- pmml(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='pmml.nnet'>Generate the PMML representation for a nnet object from package <span class="pkg">nnet</span>.</h2><span id='topic+pmml.nnet'></span>

<h3>Description</h3>

<p>Generate the PMML representation for a nnet object from package <span class="pkg">nnet</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nnet'
pmml(
  model,
  model_name = "NeuralNet_model",
  app_name = "SoftwareAG PMML Generator",
  description = "Neural Network Model",
  copyright = NULL,
  model_version = NULL,
  transforms = NULL,
  missing_value_replacement = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmml.nnet_+3A_model">model</code></td>
<td>
<p>A nnet object.</p>
</td></tr>
<tr><td><code id="pmml.nnet_+3A_model_name">model_name</code></td>
<td>
<p>A name to be given to the PMML model.</p>
</td></tr>
<tr><td><code id="pmml.nnet_+3A_app_name">app_name</code></td>
<td>
<p>The name of the application that generated the PMML.</p>
</td></tr>
<tr><td><code id="pmml.nnet_+3A_description">description</code></td>
<td>
<p>A descriptive text for the Header element of the PMML.</p>
</td></tr>
<tr><td><code id="pmml.nnet_+3A_copyright">copyright</code></td>
<td>
<p>The copyright notice for the model.</p>
</td></tr>
<tr><td><code id="pmml.nnet_+3A_model_version">model_version</code></td>
<td>
<p>A string specifying the model version.</p>
</td></tr>
<tr><td><code id="pmml.nnet_+3A_transforms">transforms</code></td>
<td>
<p>Data transformations.</p>
</td></tr>
<tr><td><code id="pmml.nnet_+3A_missing_value_replacement">missing_value_replacement</code></td>
<td>
<p>Value to be used as the 'missingValueReplacement'
attribute for all MiningFields.</p>
</td></tr>
<tr><td><code id="pmml.nnet_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function supports both regression and classification neural
network models. The model is represented in the PMML NeuralNetwork format.
</p>


<h3>Value</h3>

<p>PMML representation of the nnet object.
</p>


<h3>Author(s)</h3>

<p>Tridivesh Jena
</p>


<h3>References</h3>

<p><a href="https://CRAN.R-project.org/package=nnet">nnet: Feed-forward
Neural Networks and Multinomial Log-Linear Models (on CRAN)</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(nnet)
fit &lt;- nnet(Species ~ ., data = iris, size = 4)
fit_pmml &lt;- pmml(fit)

rm(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='pmml.randomForest'>Generate the PMML representation for a randomForest object from the package
<span class="pkg">randomForest</span>.</h2><span id='topic+pmml.randomForest'></span>

<h3>Description</h3>

<p>Generate the PMML representation for a randomForest object from the package
<span class="pkg">randomForest</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'randomForest'
pmml(
  model,
  model_name = "randomForest_Model",
  app_name = "SoftwareAG PMML Generator",
  description = "Random Forest Tree Model",
  copyright = NULL,
  model_version = NULL,
  transforms = NULL,
  missing_value_replacement = NULL,
  parent_invalid_value_treatment = "returnInvalid",
  child_invalid_value_treatment = "asIs",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmml.randomForest_+3A_model">model</code></td>
<td>
<p>A randomForest object.</p>
</td></tr>
<tr><td><code id="pmml.randomForest_+3A_model_name">model_name</code></td>
<td>
<p>A name to be given to the PMML model.</p>
</td></tr>
<tr><td><code id="pmml.randomForest_+3A_app_name">app_name</code></td>
<td>
<p>The name of the application that generated the PMML.</p>
</td></tr>
<tr><td><code id="pmml.randomForest_+3A_description">description</code></td>
<td>
<p>A descriptive text for the Header element of the PMML.</p>
</td></tr>
<tr><td><code id="pmml.randomForest_+3A_copyright">copyright</code></td>
<td>
<p>The copyright notice for the model.</p>
</td></tr>
<tr><td><code id="pmml.randomForest_+3A_model_version">model_version</code></td>
<td>
<p>A string specifying the model version.</p>
</td></tr>
<tr><td><code id="pmml.randomForest_+3A_transforms">transforms</code></td>
<td>
<p>Data transformations.</p>
</td></tr>
<tr><td><code id="pmml.randomForest_+3A_missing_value_replacement">missing_value_replacement</code></td>
<td>
<p>Value to be used as the 'missingValueReplacement'
attribute for all MiningFields.</p>
</td></tr>
<tr><td><code id="pmml.randomForest_+3A_parent_invalid_value_treatment">parent_invalid_value_treatment</code></td>
<td>
<p>Invalid value treatment at the top
MiningField level.</p>
</td></tr>
<tr><td><code id="pmml.randomForest_+3A_child_invalid_value_treatment">child_invalid_value_treatment</code></td>
<td>
<p>Invalid value treatment at the model
segment MiningField level.</p>
</td></tr>
<tr><td><code id="pmml.randomForest_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function outputs a Random Forest in PMML format.
</p>


<h3>Value</h3>

<p>PMML representation of the randomForest object.
</p>


<h3>Author(s)</h3>

<p>Tridivesh Jena
</p>


<h3>References</h3>

<p><a href="https://CRAN.R-project.org/package=randomForest">randomForest:
Breiman and Cutler's random forests for classification and regression</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Build a randomForest model
library(randomForest)
iris_rf &lt;- randomForest(Species ~ ., data = iris, ntree = 20)

# Convert to pmml
iris_rf_pmml &lt;- pmml(iris_rf)

rm(iris_rf)

## End(Not run)
</code></pre>

<hr>
<h2 id='pmml.rpart'>Generate the PMML representation for an rpart object from the package <span class="pkg">rpart</span>.</h2><span id='topic+pmml.rpart'></span>

<h3>Description</h3>

<p>Generate the PMML representation for an rpart object from the package <span class="pkg">rpart</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rpart'
pmml(
  model,
  model_name = "RPart_Model",
  app_name = "SoftwareAG PMML Generator",
  description = "RPart Decision Tree Model",
  copyright = NULL,
  model_version = NULL,
  transforms = NULL,
  missing_value_replacement = NULL,
  dataset = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmml.rpart_+3A_model">model</code></td>
<td>
<p>An rpart object.</p>
</td></tr>
<tr><td><code id="pmml.rpart_+3A_model_name">model_name</code></td>
<td>
<p>A name to be given to the PMML model.</p>
</td></tr>
<tr><td><code id="pmml.rpart_+3A_app_name">app_name</code></td>
<td>
<p>The name of the application that generated the PMML.</p>
</td></tr>
<tr><td><code id="pmml.rpart_+3A_description">description</code></td>
<td>
<p>A descriptive text for the Header element of the PMML.</p>
</td></tr>
<tr><td><code id="pmml.rpart_+3A_copyright">copyright</code></td>
<td>
<p>The copyright notice for the model.</p>
</td></tr>
<tr><td><code id="pmml.rpart_+3A_model_version">model_version</code></td>
<td>
<p>A string specifying the model version.</p>
</td></tr>
<tr><td><code id="pmml.rpart_+3A_transforms">transforms</code></td>
<td>
<p>Data transformations.</p>
</td></tr>
<tr><td><code id="pmml.rpart_+3A_missing_value_replacement">missing_value_replacement</code></td>
<td>
<p>Value to be used as the 'missingValueReplacement'
attribute for all MiningFields.</p>
</td></tr>
<tr><td><code id="pmml.rpart_+3A_dataset">dataset</code></td>
<td>
<p>Data used to train the rpart model.</p>
</td></tr>
<tr><td><code id="pmml.rpart_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Supports regression tree as well as classification. The object is
represented in the PMML TreeModel format.
</p>


<h3>Value</h3>

<p>PMML representation of the rpart object.
</p>


<h3>Author(s)</h3>

<p>Graham Williams
</p>


<h3>References</h3>

<p><a href="https://CRAN.R-project.org/package=rpart">rpart: Recursive
Partitioning (on CRAN)</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(rpart)

fit &lt;- rpart(Species ~ ., data = iris)

fit_pmml &lt;- pmml(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='pmml.rules'>Generate the PMML representation for a rules or an itemset object from
package <span class="pkg">arules</span>.</h2><span id='topic+pmml.rules'></span><span id='topic+pmml.itemsets'></span>

<h3>Description</h3>

<p>Generate the PMML representation for a rules or an itemset object from
package <span class="pkg">arules</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rules'
pmml(
  model,
  model_name = "arules_Model",
  app_name = "SoftwareAG PMML Generator",
  description = "Association Rules Model",
  copyright = NULL,
  model_version = NULL,
  transforms = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmml.rules_+3A_model">model</code></td>
<td>
<p>A rules or itemsets object.</p>
</td></tr>
<tr><td><code id="pmml.rules_+3A_model_name">model_name</code></td>
<td>
<p>A name to be given to the PMML model.</p>
</td></tr>
<tr><td><code id="pmml.rules_+3A_app_name">app_name</code></td>
<td>
<p>The name of the application that generated the PMML.</p>
</td></tr>
<tr><td><code id="pmml.rules_+3A_description">description</code></td>
<td>
<p>A descriptive text for the Header element of the PMML.</p>
</td></tr>
<tr><td><code id="pmml.rules_+3A_copyright">copyright</code></td>
<td>
<p>The copyright notice for the model.</p>
</td></tr>
<tr><td><code id="pmml.rules_+3A_model_version">model_version</code></td>
<td>
<p>A string specifying the model version.</p>
</td></tr>
<tr><td><code id="pmml.rules_+3A_transforms">transforms</code></td>
<td>
<p>Data transformations.</p>
</td></tr>
<tr><td><code id="pmml.rules_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is represented in the PMML AssociationModel format.
</p>


<h3>Value</h3>

<p>PMML representation of the rules or itemsets object.
</p>


<h3>Author(s)</h3>

<p>Graham Williams, Michael Hahsler
</p>


<h3>References</h3>

<p><a href="https://CRAN.R-project.org/package=arules">arules: Mining Association
Rules and Frequent Itemsets</a>
</p>

<hr>
<h2 id='pmml.svm'>Generate the PMML representation of an svm object from the <span class="pkg">e1071</span> package.</h2><span id='topic+pmml.svm'></span>

<h3>Description</h3>

<p>Generate the PMML representation of an svm object from the <span class="pkg">e1071</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svm'
pmml(
  model,
  model_name = "LIBSVM_Model",
  app_name = "SoftwareAG PMML Generator",
  description = "Support Vector Machine Model",
  copyright = NULL,
  model_version = NULL,
  transforms = NULL,
  missing_value_replacement = NULL,
  dataset = NULL,
  detect_anomaly = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmml.svm_+3A_model">model</code></td>
<td>
<p>An svm object from package <span class="pkg">e1071</span>.</p>
</td></tr>
<tr><td><code id="pmml.svm_+3A_model_name">model_name</code></td>
<td>
<p>A name to be given to the PMML model.</p>
</td></tr>
<tr><td><code id="pmml.svm_+3A_app_name">app_name</code></td>
<td>
<p>The name of the application that generated the PMML.</p>
</td></tr>
<tr><td><code id="pmml.svm_+3A_description">description</code></td>
<td>
<p>A descriptive text for the Header element of the PMML.</p>
</td></tr>
<tr><td><code id="pmml.svm_+3A_copyright">copyright</code></td>
<td>
<p>The copyright notice for the model.</p>
</td></tr>
<tr><td><code id="pmml.svm_+3A_model_version">model_version</code></td>
<td>
<p>A string specifying the model version.</p>
</td></tr>
<tr><td><code id="pmml.svm_+3A_transforms">transforms</code></td>
<td>
<p>Data transformations.</p>
</td></tr>
<tr><td><code id="pmml.svm_+3A_missing_value_replacement">missing_value_replacement</code></td>
<td>
<p>Value to be used as the 'missingValueReplacement' attribute for all MiningFields.</p>
</td></tr>
<tr><td><code id="pmml.svm_+3A_dataset">dataset</code></td>
<td>
<p>Required for one-classification only; data used to train the one-class SVM model.</p>
</td></tr>
<tr><td><code id="pmml.svm_+3A_detect_anomaly">detect_anomaly</code></td>
<td>
<p>Required for one-classification only; boolean indicating whether to
detect anomalies (TRUE) or inliers (FALSE).</p>
</td></tr>
<tr><td><code id="pmml.svm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Classification and regression models are represented in the PMML
SupportVectorMachineModel format. One-Classification models are represented
in the PMML AnomalyDetectionModel format. Please see below for details on
the differences.
</p>


<h3>Value</h3>

<p>PMML representation of the svm object.
</p>


<h3>Classification and Regression Models</h3>

<p>Note that the sign of the coefficient of each support vector flips between the R object
and the exported PMML file for classification and regression models. This is due to the minor
difference in the training/scoring formula between the LIBSVM algorithm and the DMG specification.
Hence the output value of each support vector machine has a sign flip between the DMG definition and
the svm prediction function.
</p>
<p>In a classification model, even though the output of the support vector machine has
a sign flip, it does not affect the final predicted category. This is because in the
DMG definition, the winning category is defined as the left side of threshold 0 while
the LIBSVM defines the winning category as the right side of threshold 0.
</p>
<p>For a regression model, the exported PMML code has two OutputField elements. The OutputField
<code>predictedValue</code> shows the support vector machine output per DMG definition. The OutputField
<code>svm_predict_function</code> gives the value corresponding to the R predict function for the svm
model. This output should be used when making model predictions.
</p>


<h3>One-Classification SVM Models</h3>

<p>For a one-classification svm (OCSVM) model, the PMML has two OutputField elements:
<code>anomalyScore</code> and one of <code>anomaly</code> or <code>outlier</code>.
</p>
<p>The OutputField <code>anomalyScore</code> is the signed distance to the separating boundary;
<code>anomalyScore</code> corresponds to the <code>decision.values</code> attribute of the output of the
svm predict function in R.
</p>
<p>The second OutputField depends the value of <code>detect_anomaly</code>. By default, <code>detect_anomaly</code> is TRUE,
which results in the second OutputField being <code>anomaly</code>.
The <code>anomaly</code> OutputField is TRUE when an anomaly is detected.
This field conforms to the DMG definition of an anomaly detection model. This value is the
opposite of the prediction by the e1071::svm object in R.
</p>
<p>Setting <code>detect_anomaly</code> to FALSE results in the second field instead being <code>inlier</code>.
This OutputField is TRUE when an inlier is
detected, and conforms to the e1071 definition of one-class SVMs. This field is FALSE when
an anomaly is detected; that is, the R svm model predicts whether an observation belongs to the
class. When comparing the predictions from R and PMML, this field should be used, since it
will match R's output.
</p>
<p>For example, say that for an an observation, the R OCSVM model predicts a positive
decision value of 0.4 and label of TRUE. According to the R object, this means that the
observation is an inlier. By default, the PMML export of this model will give the following for the
same input: <code>anomalyScore = 0.4, anomaly = "false"</code>. According to the PMML, the observation is not an anomaly.
If the same R object is instead exported with <code>detect_anomaly = FALSE</code>,
the PMML will then give: <code>anomalyScore = 0.4, inlier = "true"</code>, and this result agrees with R.
</p>
<p>Note that there is no sign flip for <code>anomalyScore</code> between R and PMML for OCSVM models.
</p>
<p>To export a OCSVM model, an additional argument, <code>dataset</code>, is required by the function.
This argument expects a dataframe with data that was used to train the model. This is
necessary because for one-class svm, the R svm object does not contain information about
the data types of the features used to train the model. The exporter does not yet support
the formula interface for one-classification models, so the default S3 method must be used
to train the SVM. The data used to train the one-class SVM must be numeric and not of
integer class.
</p>


<h3>References</h3>

<p>* R project CRAN package: <em><b>e1071</b>: Misc Functions of the Department of Statistics,
Probability Theory Group (Formerly: E1071), TU Wien</em> <a href="https://CRAN.R-project.org/package=e1071">https://CRAN.R-project.org/package=e1071</a>
</p>
<p>* Chang, Chih-Chung and Lin, Chih-Jen, <em>LIBSVM: a library for Support Vector Machines</em>
<a href="https://www.csie.ntu.edu.tw/~cjlin/libsvm/">https://www.csie.ntu.edu.tw/~cjlin/libsvm/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pmml">pmml</a></code>,
<a href="http://dmg.org/pmml/v4-4-1/SupportVectorMachine.html">PMML SVM specification</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(e1071)
data(iris)

# Classification with a polynomial kernel
fit &lt;- svm(Species ~ ., data = iris, kernel = "polynomial")
fit_pmml &lt;- pmml(fit)

# Regression
fit &lt;- svm(Sepal.Length ~ Sepal.Width + Petal.Length + Petal.Width, data = iris)
fit_pmml &lt;- pmml(fit)

# Anomaly detection with one-classification
fit &lt;- svm(iris[, 1:4],
  y = NULL,
  type = "one-classification"
)
fit_pmml &lt;- pmml(fit, dataset = iris[, 1:4])

# Inlier detection with one-classification
fit &lt;- svm(iris[, 1:4],
  y = NULL,
  type = "one-classification",
  detect_anomaly = FALSE
)
fit_pmml &lt;- pmml(fit, dataset = iris[, 1:4])

## End(Not run)

</code></pre>

<hr>
<h2 id='pmml.xgb.Booster'>Generate PMML for a xgb.Booster object from the package <span class="pkg">xgboost</span>.</h2><span id='topic+pmml.xgb.Booster'></span>

<h3>Description</h3>

<p>Generate PMML for a xgb.Booster object from the package <span class="pkg">xgboost</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xgb.Booster'
pmml(
  model,
  model_name = "xboost_Model",
  app_name = "SoftwareAG PMML Generator",
  description = "Extreme Gradient Boosting Model",
  copyright = NULL,
  model_version = NULL,
  transforms = NULL,
  missing_value_replacement = NULL,
  input_feature_names = NULL,
  output_label_name = NULL,
  output_categories = NULL,
  xgb_dump_file = NULL,
  parent_invalid_value_treatment = "returnInvalid",
  child_invalid_value_treatment = "asIs",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmml.xgb.Booster_+3A_model">model</code></td>
<td>
<p>An object created by the 'xgboost' function.</p>
</td></tr>
<tr><td><code id="pmml.xgb.Booster_+3A_model_name">model_name</code></td>
<td>
<p>A name to be given to the PMML model.</p>
</td></tr>
<tr><td><code id="pmml.xgb.Booster_+3A_app_name">app_name</code></td>
<td>
<p>The name of the application that generated the PMML.</p>
</td></tr>
<tr><td><code id="pmml.xgb.Booster_+3A_description">description</code></td>
<td>
<p>A descriptive text for the Header element of the PMML.</p>
</td></tr>
<tr><td><code id="pmml.xgb.Booster_+3A_copyright">copyright</code></td>
<td>
<p>The copyright notice for the model.</p>
</td></tr>
<tr><td><code id="pmml.xgb.Booster_+3A_model_version">model_version</code></td>
<td>
<p>A string specifying the model version.</p>
</td></tr>
<tr><td><code id="pmml.xgb.Booster_+3A_transforms">transforms</code></td>
<td>
<p>Data transformations.</p>
</td></tr>
<tr><td><code id="pmml.xgb.Booster_+3A_missing_value_replacement">missing_value_replacement</code></td>
<td>
<p>Value to be used as the 'missingValueReplacement'
attribute for all MiningFields.</p>
</td></tr>
<tr><td><code id="pmml.xgb.Booster_+3A_input_feature_names">input_feature_names</code></td>
<td>
<p>Input variable names used in training the model.</p>
</td></tr>
<tr><td><code id="pmml.xgb.Booster_+3A_output_label_name">output_label_name</code></td>
<td>
<p>Name of the predicted field.</p>
</td></tr>
<tr><td><code id="pmml.xgb.Booster_+3A_output_categories">output_categories</code></td>
<td>
<p>Possible values of the predicted field, for classification models.</p>
</td></tr>
<tr><td><code id="pmml.xgb.Booster_+3A_xgb_dump_file">xgb_dump_file</code></td>
<td>
<p>Name of file saved using 'xgb.dump' function.</p>
</td></tr>
<tr><td><code id="pmml.xgb.Booster_+3A_parent_invalid_value_treatment">parent_invalid_value_treatment</code></td>
<td>
<p>Invalid value treatment at the top MiningField level.</p>
</td></tr>
<tr><td><code id="pmml.xgb.Booster_+3A_child_invalid_value_treatment">child_invalid_value_treatment</code></td>
<td>
<p>Invalid value treatment at the model segment MiningField level.</p>
</td></tr>
<tr><td><code id="pmml.xgb.Booster_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>xgboost</code> function takes as its input either an <code>xgb.DMatrix</code> object or
a numeric matrix. The input field information is not stored in the R model object,
hence the field information must be passed on as inputs. This enables the PMML
to specify field names in its model representation. The R model object does not store
information about the fitted tree structure either. However, this information can
be extracted from the <code>xgb.model.dt.tree</code> function and the file saved using the
<code>xgb.dump</code> function. The xgboost library is therefore needed in the environment and this
saved file is needed as an input as well.
</p>
<p>The following objectives are currently supported: <code>multi:softprob</code>,
<code>multi:softmax</code>, <code>binary:logistic</code>.
</p>
<p>The pmml exporter will throw an error if the xgboost model model only has one tree.
</p>
<p>The exporter only works with numeric matrices. Sparse matrices must be converted to
<code>matrix</code> objects before training an xgboost model for the export to work correctly.
</p>


<h3>Value</h3>

<p>PMML representation of the xgb.Booster object.
</p>


<h3>Author(s)</h3>

<p>Tridivesh Jena
</p>


<h3>References</h3>

<p><a href="https://CRAN.R-project.org/package=xgboost">xgboost: Extreme Gradient Boosting</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pmml">pmml</a></code>,
<a href="http://dmg.org/pmml/v4-4-1/GeneralStructure.html">PMML schema</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example using the xgboost package example model.

library(xgboost)
data(agaricus.train, package = "xgboost")
data(agaricus.test, package = "xgboost")

train &lt;- agaricus.train
test &lt;- agaricus.test

model1 &lt;- xgboost(
  data = train$data, label = train$label,
  max_depth = 2, eta = 1, nthread = 2,
  nrounds = 2, objective = "binary:logistic"
)

# Save the tree information in an external file:
xgb.dump(model1, "model1.dumped.trees")

# Convert to PMML:
model1_pmml &lt;- pmml(model1,
  input_feature_names = colnames(train$data),
  output_label_name = "prediction1",
  output_categories = c("0", "1"),
  xgb_dump_file = "model1.dumped.trees"
)

# Multinomial model using iris data:
model2 &lt;- xgboost(
  data = as.matrix(iris[, 1:4]),
  label = as.numeric(iris[, 5]) - 1,
  max_depth = 2, eta = 1, nthread = 2, nrounds = 2,
  objective = "multi:softprob", num_class = 3
)

# Save the tree information in an external file:
xgb.dump(model2, "model2.dumped.trees")

# Convert to PMML:
model2_pmml &lt;- pmml(model2,
  input_feature_names = colnames(as.matrix(iris[, 1:4])),
  output_label_name = "Species",
  output_categories = c(1, 2, 3), xgb_dump_file = "model2.dumped.trees"
)

## End(Not run)

</code></pre>

<hr>
<h2 id='rename_wrap_var'>Rename a variable in the xform_wrap transform object.</h2><span id='topic+rename_wrap_var'></span>

<h3>Description</h3>

<p>Rename a variable in the xform_wrap transform object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_wrap_var(wrap_object, xform_info = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rename_wrap_var_+3A_wrap_object">wrap_object</code></td>
<td>
<p>Wrapper object obtained by using the xform_wrap function on the
raw data.</p>
</td></tr>
<tr><td><code id="rename_wrap_var_+3A_xform_info">xform_info</code></td>
<td>
<p>Specification of details of the renaming.</p>
</td></tr>
<tr><td><code id="rename_wrap_var_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Once input data is wrapped by the <b>xform_wrap</b> function, it is somewhat
involved to rename a variable inside. This function makes it easier to do
so.  Given a variable named <b>input_var</b> and the name one wishes to
rename it to, <b>output_var</b>, the rename command options are:
</p>
<p>xform_info=&quot;input_var -&gt; output_var&quot;
</p>
<p>There are two methods in which the variables can be referred to. The first
method is to use its column number; given the <b>data</b> attribute of the
<b>boxData</b> object, this would be the order at which the variable
appears. This can be indicated in the format &quot;column#&quot;. The second method is
to refer to the variable by its name. This method will work even if the
renamed value already exists; in which case there will be two variables with
the same name.
</p>
<p>If no input variable name is provided, the original object is returned with
no renaming performed.
</p>


<h3>Value</h3>

<p>R object containing the raw data, the transformed data and data
statistics.
</p>


<h3>Author(s)</h3>

<p>Tridivesh Jena
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xform_wrap">xform_wrap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the standard iris dataset
data(iris)

# First wrap the data
iris_box &lt;- xform_wrap(iris)

# We wish to refer to the variables "Sepal.Length" and
# "Sepal.Width" as "SL" and "SW"
iris_box &lt;- rename_wrap_var(wrap_object = iris_box, xform_info = "column1-&gt;SL")
iris_box &lt;- rename_wrap_var(wrap_object = iris_box, xform_info = "Sepal.Width-&gt;SW")
</code></pre>

<hr>
<h2 id='save_pmml'>Save a pmml object as an external PMML file.</h2><span id='topic+save_pmml'></span>

<h3>Description</h3>

<p>Save a pmml object to an external PMML file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_pmml(doc, name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="save_pmml_+3A_doc">doc</code></td>
<td>
<p>The pmml model.</p>
</td></tr>
<tr><td><code id="save_pmml_+3A_name">name</code></td>
<td>
<p>The name of the external file where the PMML is to be saved.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tridivesh Jena
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Make a gbm model:
library(gbm)
data(audit)

mod &lt;- gbm(Adjusted ~ .,
  data = audit[, -c(1, 4, 6, 9, 10, 11, 12)],
  n.trees = 3,
  interaction.depth = 4
)

# Export to PMML:
pmod &lt;- pmml(mod)

# Save to an external file:
save_pmml(pmod, "GBMModel.pmml")

## End(Not run)

</code></pre>

<hr>
<h2 id='xform_discretize'>Discretize a continuous variable as indicated by interval mappings in
accordance with the PMML element <b>Discretize</b>.</h2><span id='topic+xform_discretize'></span>

<h3>Description</h3>

<p>Discretize a continuous variable as indicated by interval mappings in
accordance with the PMML element <b>Discretize</b>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xform_discretize(
  wrap_object,
  xform_info,
  table,
  default_value = NA,
  map_missing_to = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xform_discretize_+3A_wrap_object">wrap_object</code></td>
<td>
<p>Output of xform_wrap or another transformation function.</p>
</td></tr>
<tr><td><code id="xform_discretize_+3A_xform_info">xform_info</code></td>
<td>
<p>Specification of details of the transformation. This may be
a name of an external file or a list of data frames. Even if only 1 variable
is to be transformed, the information for that transform should be given as
a list with 1 element.</p>
</td></tr>
<tr><td><code id="xform_discretize_+3A_table">table</code></td>
<td>
<p>Name of external CSV file containing the map from input to
output values.</p>
</td></tr>
<tr><td><code id="xform_discretize_+3A_default_value">default_value</code></td>
<td>
<p>Value to be given to the transformed variable if the
value of the input variable does not lie in any of the defined intervals. If
'xform_info' is a list, this is a vector with each element corresponding to
the corresponding list element.</p>
</td></tr>
<tr><td><code id="xform_discretize_+3A_map_missing_to">map_missing_to</code></td>
<td>
<p>Value to be given to the transformed variable if the
value of the input variable is missing.  If 'xform_info' is a list, this is a
vector with each element corresponding to the corresponding list element.</p>
</td></tr>
<tr><td><code id="xform_discretize_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Create a discrete variable from a continuous one as indicated by interval
mappings. The discrete  variable value depends on interval in which the
continuous variable value  lies. The mapping from intervals to discrete
values can be given in an  external table file referred to in the
transform command or as a list of data frames.
</p>
<p>Given a list of intervals and the discrete value each interval is linked to,
a discrete variable is defined with the value indicated by the interval
where it lies in. If a continuous variable <b>InVar</b> of data type
<b>InType</b> is to be converted to a variable <b>OutVar</b> of data type
<b>OutType</b>, the transformation command is in the format:
</p>
<p>xform_info = &quot;[InVar-&gt;OutVar][InType-&gt;OutType]&quot;, table=&quot;TableFileName&quot;, <br />
default_value=&quot;defVal&quot;, map_missing_to=&quot;missingVal&quot;
</p>
<p>where <b>TableFileName</b> is the name of the CSV file containing the
interval to discrete value map.  The data types of the variables can be any
of the ones defined in the PMML format including integer, double or string.
<b>defVal</b> is the default value of the transformed variable and if any of
the input values are missing, <b>missingVal</b> is the value of the
transformed variable.
</p>
<p>The arguments InType, OutType, default_value and map_missing_to are optional.
The CSV file containing the table should not have any row and column
identifiers, and the values given must be in the same order as in the map
command. If the data types of the variables are not given, the data types of
the input variables are attempted to be determined from the <b>boxData</b>
argument.  If that is not possible, the data types are assumed to be string.
</p>
<p>Intervals are either given by the left or right limits, in which case the
other limit is considered as infinite. It may also be given by both the left
and right limits separated by the character &quot;:&quot;. An example of how intervals
should be defined in the external file are:
</p>
<pre>
rightVal1),outVal1
rightVal2],outVal2
[leftVal1:rightVal3),outVal3
(leftVal2:rightVal4],outVal4
(leftVal,outVal5
</pre>
<p>which, given an input value <b>inVal</b> and the output value to be
calculated <b>out</b>, means that:
</p>
<pre>
if(inVal &lt; rightVal1) out=outVal1
f(inVal &lt;= rightVal2) out=outVal2
if( (inVal &gt;= leftVal1) and (inVal &lt; rightVal3) ) out=outVal3
if( (inVal &gt; leftVal2) and (inVal &lt;= rightVal4) ) out=outVal4
if(inVal &gt; leftVal) out=outVal5
</pre>
<p>It is also possible to give the information about the transforms without an
external file, using a list of data frames.  Each data frame defines a
discretization operation for 1 input variable. The first row of the data
frame gives the original field name, the derived field name, the left
interval, the left value, the right interval and the right value. The second
row gives the data type of the values as listed in the first row. The second
row with the data types of the fields is not required. If not given, all
fields are assumed to be strings. In this input format, the 'default_value'
and 'map_missing_to' parameters should be vectors. The first element of each
vector will correspond to the derived field defined in the 1st element of
the 'xform_info' list etc. Although somewhat more complicated, this method is
designed to not require any external features. Further, once the initial list
is constructed, modifying it is a simple operation; making this a better
method to use if the parameters of the transformation are to be modified
frequently and/or automatically. This is made more clear in the example
below.
</p>


<h3>Value</h3>

<p>R object containing the raw data, the transformed data and data
statistics.
</p>


<h3>Author(s)</h3>

<p>Tridivesh Jena
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xform_wrap">xform_wrap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First wrap the data
iris_box &lt;- xform_wrap(iris)
## Not run: 
# Convert the continuous variable "Sepal.Length" to a discrete
# variable "dsl". The intervals to be used for this transformation is
# given in a file, "intervals.csv", whose content is, for example,:
#
#  5],val1
#  (5:6],22
#  (6,val2
#
# This will be used to create a discrete variable named "dsl" of dataType
# "string" such that:
#    if(Sepal.length &lt;= 5) then dsl = "val1"
#    if((Sepal.Lenght &gt; 5) and (Sepal.Length &lt;= 6)) then dsl = "22"
#    if(Sepal.Length &gt; 6) then dsl = "val2"
#
# Give "dsl" the value 0 if the input variable value is missing.
iris_box &lt;- xform_discretize(iris_box,
  xform_info = "[Sepal.Length -&gt; dsl][double -&gt; string]",
  table = "intervals.csv", map_missing_to = "0"
)

## End(Not run)

# A different transformation using a list of data frames, of size 1:
t &lt;- list()
m &lt;- data.frame(rbind(
  c(
    "Petal.Length", "dis_pl", "leftInterval", "leftValue",
    "rightInterval", "rightValue"
  ),
  c(
    "double", "integer", "string", "double", "string",
    "double"
  ),
  c("0)", 0, "open", NA, "Open", 0),
  c(NA, 1, "closed", 0, "Open", 1),
  c(NA, 2, "closed", 1, "Open", 2),
  c(NA, 3, "closed", 2, "Open", 3),
  c(NA, 4, "closed", 3, "Open", 4),
  c("[4", 5, "closed", 4, "Open", NA)
), stringsAsFactors = TRUE)

# Give column names to make it look nice; not necessary!
colnames(m) &lt;- c(
  "Petal.Length", "dis_pl", "leftInterval", "leftValue",
  "rightInterval", "rightValue"
)

# A textual representation of the data frame is:
#   Petal.Length  dis_pl leftInterval leftValue rightInterval rightValue
# 1 Petal.Length  dis_pl leftInterval leftValue rightInterval rightValue
# 2       double integer       string    double        string     double
# 3           0)       0         open      &lt;NA&gt;          Open          0
# 4         &lt;NA&gt;       1       closed         0          Open          1
# 5         &lt;NA&gt;       2       closed         1          Open          2
# 6         &lt;NA&gt;       3       closed         2          Open          3
# 7         &lt;NA&gt;       4       closed         3          Open          4
# 8           (4       5       closed         4          Open       &lt;NA&gt;
#
# This is a transformation that defines a derived field 'dis_pl'
# which has the integer value '0' if the original field
# 'Petal.Length' has a value less than 0. The derived field has a
# value '1' if the input is greater than or equal to 0 and less
# than 1. Note that the values of the 1st column after row 2 have
# been deliberately given NA values in the middle. This is to
# show that that column is meant for a textual representation of
# the transformation as defined for the method involving external
# files; however in this methodtheir values are not used.

# Add the data frame to a list. The default values and the missing
# values should be given as a vector, each element of the vector
# corresponding to the element at the same index in the list. If
# these values are not given as a vector, they will be used for the
# first list element only.
t[[1]] &lt;- m
def &lt;- c(11)
mis &lt;- c(22)
iris_box &lt;- xform_discretize(iris_box,
  xform_info = t, default_value = def,
  map_missing_to = mis
)

# Make a simple model to see the effect.
fit &lt;- lm(Petal.Width ~ ., iris_box$data[, -5])
fit_pmml &lt;- pmml(fit, transforms = iris_box)
</code></pre>

<hr>
<h2 id='xform_function'>Add a function transformation to a xform_wrap object.</h2><span id='topic+xform_function'></span>

<h3>Description</h3>

<p>Add a function transformation to a xform_wrap object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xform_function(
  wrap_object,
  orig_field_name,
  new_field_name = "newField",
  new_field_data_type = "numeric",
  expression,
  map_missing_to = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xform_function_+3A_wrap_object">wrap_object</code></td>
<td>
<p>Output of xform_wrap or another transformation function.</p>
</td></tr>
<tr><td><code id="xform_function_+3A_orig_field_name">orig_field_name</code></td>
<td>
<p>String specifying name(s) of the original data field(s) being used in the transformation.</p>
</td></tr>
<tr><td><code id="xform_function_+3A_new_field_name">new_field_name</code></td>
<td>
<p>Name of the new field created by the transformation.</p>
</td></tr>
<tr><td><code id="xform_function_+3A_new_field_data_type">new_field_data_type</code></td>
<td>
<p>R data type of the new field created by the transformation (&quot;numeric&quot; or &quot;factor&quot;).</p>
</td></tr>
<tr><td><code id="xform_function_+3A_expression">expression</code></td>
<td>
<p>String expression specifying the transformation.</p>
</td></tr>
<tr><td><code id="xform_function_+3A_map_missing_to">map_missing_to</code></td>
<td>
<p>Value to be given to the transformed variable if the value of any input variable is missing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate the expression provided
in <code>expression</code> for every row in the <code>wrap_object$data</code>
data frame. The <code>expression</code> argument must represent
a valid R expression, and any functions used in
<code>expression</code> must be defined in the current
environment.
</p>
<p>The name of the new field is optional (a default name is provided), but an error
will be thrown if attempting to create a field with a name that already exists in
the xform_wrap object.
</p>
<p>When <code>new_field_data_type = "numeric"</code>, the <code>DerivedField</code> attributes
in PMML will be <code>dataType = "double"</code> and <code>optype = "continuous"</code>.
When <code>new_field_data_type = "factor"</code>, these attributes will be
<code>dataType = "string"</code> and <code>optype = "categorical"</code>.
</p>


<h3>Value</h3>

<p>R object containing the raw data, the transformed data and data statistics.
The <code>data</code> data frame will contain a new <code>new_field_name</code> column, and
<code>field_data</code> will contain a new <code>new_field_name</code> row.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xform_wrap">xform_wrap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the standard iris dataset:
data(iris)

# Wrap the data:
iris_box &lt;- xform_wrap(iris)

# Perform a transform on the Sepal.Length field:
# the value is squared and then divided by 100
iris_box &lt;- xform_function(iris_box,
  orig_field_name = "Sepal.Length",
  new_field_name = "Sepal.Length.Transformed",
  expression = "(Sepal.Length^2)/100"
)

# Combine two fields to create another new feature:
iris_box &lt;- xform_function(iris_box,
  orig_field_name = "Sepal.Width, Petal.Width",
  new_field_name = "Width.Sum",
  expression = "Sepal.Width + Sepal.Length"
)

# Create linear model using the derived features:
fit &lt;- lm(Petal.Length ~
Sepal.Length.Transformed + Width.Sum, data = iris_box$data)

# Create pmml from the fit:
fit_pmml &lt;- pmml(fit, transform = iris_box)
</code></pre>

<hr>
<h2 id='xform_map'>Implement a map between discrete values in accordance with the PMML element
<b>MapValues</b>.</h2><span id='topic+xform_map'></span>

<h3>Description</h3>

<p>Implement a map between discrete values in accordance with the PMML element
<b>MapValues</b>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xform_map(
  wrap_object,
  xform_info,
  table = NA,
  default_value = NA,
  map_missing_to = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xform_map_+3A_wrap_object">wrap_object</code></td>
<td>
<p>Output of xform_wrap or another transformation function.</p>
</td></tr>
<tr><td><code id="xform_map_+3A_xform_info">xform_info</code></td>
<td>
<p>Specification of details of the transformation. It can be a
text giving the external file name or a list of data frames. Even if only 1
variable is to be transformed, the information for that map should be given
as a list with 1 element.</p>
</td></tr>
<tr><td><code id="xform_map_+3A_table">table</code></td>
<td>
<p>Name of external CSV file containing the map from input to
output values.</p>
</td></tr>
<tr><td><code id="xform_map_+3A_default_value">default_value</code></td>
<td>
<p>The default value to be given to the transformed
variable. If 'xform_info' is a list, this is a vector with each element
corresponding to the corresponding list element.</p>
</td></tr>
<tr><td><code id="xform_map_+3A_map_missing_to">map_missing_to</code></td>
<td>
<p>Value to be given to the transformed variable if the
value of the input variable is missing.  If 'xform_info' is a list, this is a
vector with each element corresponding to the corresponding list element.</p>
</td></tr>
<tr><td><code id="xform_map_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Map discrete values of an input variable to a discrete value of the
transformed variable. The map can be given in an external table file
referred to in the transform command or as a list of data frames, each data
frame defining a map transform for one variable.
</p>
<p>Given a map from the combination of variables <b>InVar1</b>, <b>InVar2</b>,
... to the transformed variable <b>OutVar</b>, where the variables have the
data types <b>InType1</b>, <b>InType2</b>, ... and <b>OutType</b>, the map
command is in the format:
</p>
<pre>
xform_info = "[InVar1,InVar2,... -&gt; OutVar][InType1,InType2,... -&gt; OutType]"
table = "TableFileName", default_value = "defVal", map_missing_to = "missingVal"
</pre>
<p>where <b>TableFileName</b> is the name of the CSV file containing the map.
The map can be a N to 1 map where N is greater or equal to 1. The data types
of the variables can be any of the ones defined in the PMML format including
integer, double or string. <b>defVal</b> is the default value of the
transformed variable and if any of the map input values are missing,
<b>missingVal</b> is the value of the transformed variable.
</p>
<p>The arguments InType, OutType, default_value and map_missing_to are optional.
The CSV file containing the table should not have any row and column
identifiers, and the values given must be in the same order as in the map
command. If the data types of the variables are not given, the data types of
the input variables are attempted to be determined from the <b>boxData</b>
argument.  If that is not possible, the data type is assumed to be string.
</p>
<p>It is also possible to give the maps to be implemented without an external
file using a list of data frames. Each data frame defines a map for 1 input
variable. Given a data frame with N+1 columns, it is assumed that the map is
a N to 1 map where the last column of the data frame corresponds to the
derived field. The 1st row is assumed to be the names of the fields and the
second row the data types of the fields. The rest of the rows define the
map; each combination of the input values in a row is mapped to the value in
the last column of that row. The second row with the data types of the
fields is not required. If not given, all fields are assumed to be strings.
In this input format, the 'default_value' and 'map_missing_to' parameters
should be vectors. The first element of each vector will correspond to the
derived field defined in the 1st element of the 'xform_info' list etc. These
are made clearer in the example below.
</p>


<h3>Value</h3>

<p>R object containing the raw data, the transformed data and data
statistics.
</p>


<h3>Author(s)</h3>

<p>Tridivesh Jena
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xform_wrap">xform_wrap</a></code>, <code><a href="#topic+pmml">pmml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the standard audit dataset, part of the pmml package:
data(audit)

# First wrap the data:
audit_box &lt;- xform_wrap(audit)
## Not run: 
# One of the variables, "Sex", has 2 possible values: "Male"
# and "Female". If these string values have to be mapped to a
# numeric value, a file has to be created, say "map_audit.csv",
# whose content is, for example:
#
#  Male,1
#  Female,2
#
# Transform the variable "Gender" to a variable "d_gender"
# such that:
#    if Sex = "Male" then d_sex = "1"
#    if Sex = "Female" then d_sex = "2"
#
# Give "d_sex" the value 0 if the input variable value is
# missing.
audit_box &lt;- xform_map(audit_box,
  xform_info = "[Sex -&gt; d_sex][string-&gt;integer]",
  table = "map_audit.csv", map_missing_to = "0"
)

## End(Not run)
# Same as above, with an extra variable, but using data frames.
# The top 2 rows give the variable names and their data types.
# The rest represent the map. For example, the third row
# indicates that when the input variable "Sex" has the value
# "Male" and the input variable "Employment" has
# the value "PSLocal", the output variable "d_sex" should have
# the value 1.
t &lt;- list()
m &lt;- data.frame(
  c("Sex", "string", "Male", "Female"),
  c("Employment", "string", "PSLocal", "PSState"),
  c("d_sex", "integer", 1, 0),
  stringsAsFactors = TRUE
)
t[[1]] &lt;- m

# Give default value as a vector and missing value as a string,
# this is only possible as there is only one map defined. If
# default values is not given, it will simply not be given in
# the PMML file as well. In general, the default values and the
# missing values should be given as a vector, each element of
# the vector corresponding to the element at the same index in
# the list. If these values are not given as a vector, they will
# be used for the first list element only.
audit_box &lt;- xform_map(audit_box,
  xform_info = t, default_value = c(3),
  map_missing_to = "2"
)

# check what the pmml looks like
fit &lt;- lm(Adjusted ~ ., data = audit_box$data)
fit_pmml &lt;- pmml(fit, transforms = audit_box)
</code></pre>

<hr>
<h2 id='xform_min_max'>Normalize continuous values in accordance with the PMML element
<b>NormContinuous</b>.</h2><span id='topic+xform_min_max'></span>

<h3>Description</h3>

<p>Normalize continuous values in accordance with the PMML element
<b>NormContinuous</b>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xform_min_max(wrap_object, xform_info = NA, map_missing_to = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xform_min_max_+3A_wrap_object">wrap_object</code></td>
<td>
<p>Output of xform_wrap or another transformation function.</p>
</td></tr>
<tr><td><code id="xform_min_max_+3A_xform_info">xform_info</code></td>
<td>
<p>Specification of details of the transformation.</p>
</td></tr>
<tr><td><code id="xform_min_max_+3A_map_missing_to">map_missing_to</code></td>
<td>
<p>Value to be given to the transformed variable if the
value of the input variable is missing.</p>
</td></tr>
<tr><td><code id="xform_min_max_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given input data in a xform_wrap format, normalize the given data values to
lie between provided limits.
</p>
<p>Given an input variable named <b>InputVar</b>, the name of the transformed
variable <b>OutputVar</b>, the desired minimum value the transformed
variable may have <b>low_limit</b>, the desired maximum value the
transformed variable may have <b>high_limit</b>, and the desired value of
the transformed variable if the input variable value is missing
<b>missingVal</b>, the <b>xform_min_max</b> command including all the optional
parameters is in the format:
</p>
<pre>
formInfo = "InputVar -&gt; OutputVar[low_limit,high_limit]"
map_missing_to = "missingVal"
</pre>
<p>There are two ways to refer to variables. The first way is
to use the variable's column number; given the <b>data</b> attribute of the
<b>boxData</b> object, this would be the order at which the variable
appears. This can be indicated in the format &quot;column#&quot;. The second way is
to refer to the variable by its name.
</p>
<p>The name of the transformed variable is optional; if the name is not
provided, the transformed variable is given the name: &quot;derived_&quot; +
<em>original_variable_name</em>. Similarly, the low and high limit values
are optional; they have the default values of 0 and 1 respectively.
<b>missingValue</b> is an optional parameter as well. It is the value of the
derived variable if the input value is missing.
</p>
<p>If no input variable names are provided, by default all numeric variables
are transformed. Note that in this case a replacement value for missing
input values cannot be specified; the same applies to the <b>low_limit</b>
and <b>high_limit</b> parameters.
</p>


<h3>Value</h3>

<p>R object containing the raw data, the transformed data and data
statistics.
</p>


<h3>Author(s)</h3>

<p>Tridivesh Jena
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xform_wrap">xform_wrap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the standard iris dataset:
data(iris)

# First wrap the data:
iris_box &lt;- xform_wrap(iris)

# Normalize all numeric variables of the loaded iris dataset to lie
# between 0 and 1. These would normalize "Sepal.Length", "Sepal.Width",
# "Petal.Length", "Petal.Width" to the 4 new derived variables named
# derived_Sepal.Length, derived_Sepal.Width, derived_Petal.Length,
# derived_Petal.Width.
iris_box_1 &lt;- xform_min_max(iris_box)

# Normalize the 1st column values of the dataset (Sepal.Length) to lie
# between 0 and 1 and give the derived variable the name "dsl".
iris_box_1 &lt;- xform_min_max(iris_box, xform_info = "column1 -&gt; dsl")

# Repeat the above operation; adding the new transformed variable to
# the iris_box object.
iris_box &lt;- xform_min_max(iris_box, xform_info = "column1 -&gt; dsl")

# Transform Sepal.Width(the 2nd column).
# The new transformed variable will be given the default name
# "derived_Sepal.Width".
iris_box_3 &lt;- xform_min_max(iris_box, xform_info = "column2")

# Repeat the same operation as above, this time using the variable name.
iris_box_4 &lt;- xform_min_max(iris_box, xform_info = "Sepal.Width")

# Repeat the same operation as above, now assigning the transformed variable,
# "derived_Sepal.Width", the value of 0.5 if the input value of the
# "Sepal.Width" variable is missing.
iris_box_5 &lt;- xform_min_max(iris_box, xform_info = "Sepal.Width", "map_missing_to=0.5")

# Transform Sepal.Width(the 2nd column) to lie between 2 and 3.
# The new transformed variable will be given the default name
# "derived_Sepal.Width".
iris_box_6 &lt;- xform_min_max(iris_box, xform_info = "column2-&gt;[2,3]")

# Repeat the above transformation, this time the transformed variable
# lies between 0 and 10.
iris_box_7 &lt;- xform_min_max(iris_box, xform_info = "column2-&gt;[,10]")
</code></pre>

<hr>
<h2 id='xform_norm_discrete'>Normalize discrete values in accordance with the PMML element <b>NormDiscrete</b>.</h2><span id='topic+xform_norm_discrete'></span>

<h3>Description</h3>

<p>Normalize discrete values in accordance with the PMML element <b>NormDiscrete</b>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xform_norm_discrete(
  wrap_object,
  xform_info = NA,
  input_var = NA,
  map_missing_to = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xform_norm_discrete_+3A_wrap_object">wrap_object</code></td>
<td>
<p>Output of xform_wrap or another transformation function.</p>
</td></tr>
<tr><td><code id="xform_norm_discrete_+3A_xform_info">xform_info</code></td>
<td>
<p>Specification of details of the transformation: the name of
the input variable to be transformed.</p>
</td></tr>
<tr><td><code id="xform_norm_discrete_+3A_input_var">input_var</code></td>
<td>
<p>The input variable name in the data on which the
transformation is to be applied.</p>
</td></tr>
<tr><td><code id="xform_norm_discrete_+3A_map_missing_to">map_missing_to</code></td>
<td>
<p>Value to be given to the transformed variable if the
value of the input variable is missing.</p>
</td></tr>
<tr><td><code id="xform_norm_discrete_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Define a new derived variable for each possible value of a categorical
variable. Given a categorical variable <b>catVar</b> with possible discrete
values <b>A</b> and <b>B</b>, this will create 2 derived variables
<b>catVar_A</b> and <b>catVar_B</b>. If, for example, the input value of
<b>catVar</b> is <b>A</b> then <b>catVar_A</b> equals 1 and <b>catVar_B</b>
equals 0.
</p>
<p>Given an input variable, <b>input_var</b> and <b>missingVal</b>, the desired
value of the transformed variable if the input variable value is missing,
the xform_norm_discrete command including all optional parameters is in the
format:
</p>
<p>xform_info=&quot;input_var=input_variable, map_missing_to=missingVal&quot;
</p>
<p>There are two methods in which the input variable can be referred to. The
first method is to use its column number; given the <b>data</b> attribute of
the <b>boxData</b> object, this would be the order at which the variable
appears. This can be indicated in the format &quot;column#&quot;. The second method is
to refer to the variable by its name.
</p>
<p>The <b>xform_info</b> and <b>input_var</b> parameters provide the same
information. While either one may be used when using this function, at least
one of them is required. If both parameters are given, the <b>input_var</b>
parameter is used as the default.
</p>
<p>The output of this transformation is a set of transformed variables, one for
each possible value of the input variable. For example, given possible
values of the input variable <b>val1</b>, <b>val2</b>, ... these transformed
variables are by default named <b>input_var_val1</b>, <b>input_var_val2</b>,
...
</p>


<h3>Value</h3>

<p>R object containing the raw data, the transformed data and data
statistics.
</p>


<h3>Author(s)</h3>

<p>Tridivesh Jena
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xform_wrap">xform_wrap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the standard iris dataset, already available in R
data(iris)

# First wrap the data
iris_box &lt;- xform_wrap(iris)

# Discretize the "Species" variable. This will find all possible
# values of the "Species" variable and define new variables. The
# parameter name used here should be replaced by the new preferred
# parameter name as shown in the next example below.
#
# 	"Species_setosa" such that it is 1 if
#      "Species" equals "setosa", else 0;
# 	"Species_versicolor" such that it is 1 if
#      "Species" equals "versicolor", else 0;
# 	"Species_virginica" such that it is 1 if
#      "Species" equals "virginica", else 0

iris_box &lt;- xform_norm_discrete(iris_box, input_var = "Species")

# Exact same operation performed with a different parameter name.
# Use of this new parameter is the preferred method as the previous
# parameter will be deprecated soon.

iris_box &lt;- xform_wrap(iris)
iris_box &lt;- xform_norm_discrete(iris_box, xform_info = "Species")
</code></pre>

<hr>
<h2 id='xform_wrap'>Wrap data in a data transformations object.</h2><span id='topic+xform_wrap'></span>

<h3>Description</h3>

<p>Wrap data in a data transformations object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xform_wrap(data, use_matrix = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xform_wrap_+3A_data">data</code></td>
<td>
<p>The raw data set.</p>
</td></tr>
<tr><td><code id="xform_wrap_+3A_use_matrix">use_matrix</code></td>
<td>
<p>Boolean value indicating whether data should be stored in
matrix format as well.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Wrap raw data read in an R object. This object can then be passed to various
transform functions, and the data in it transformed.
</p>
<p>The object consists of the data itself and various properties for each data
variable. Since the data is not always required to be in matrix format as
well as a data frame, the 'use_matrix' value lets the user decide if the data
should be stored in both formats, giving the user a choice in reducing the
speed of the transformation operations and the memory required. If there is
not enough information about the data, they are given default values; the
data is assumed to be the original data of data type string. The variable
names are assumed to be <b>X1</b>, <b>X2</b>, ...  This information is then
used by the transformation functions to calculate the derived variable
values.
</p>


<h3>Value</h3>

<p>An R object containing information on the data to be transformed.
</p>


<h3>Author(s)</h3>

<p>Tridivesh Jena
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pmml">pmml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the standard iris dataset
data(iris)

# Make a object for the iris dataset to use with
# transformation functions
iris_box &lt;- xform_wrap(iris)

# Output only the transformations in PMML format.
# This example will output just an empty "LocalTransformations"
# element as no transformations were performed.
trans_pmml &lt;- pmml(NULL, transforms = iris_box)

# The following will also work
trans_pmml_2 &lt;- pmml(, transforms = iris_box)
</code></pre>

<hr>
<h2 id='xform_z_score'>Perform a z-score normalization on continuous values in accordance with the
PMML element <b>NormContinuous</b>.</h2><span id='topic+xform_z_score'></span>

<h3>Description</h3>

<p>Perform a z-score normalization on continuous values in accordance with the
PMML element <b>NormContinuous</b>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xform_z_score(wrap_object, xform_info = NA, map_missing_to = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xform_z_score_+3A_wrap_object">wrap_object</code></td>
<td>
<p>Output of xform_wrap or another transformation function.</p>
</td></tr>
<tr><td><code id="xform_z_score_+3A_xform_info">xform_info</code></td>
<td>
<p>Specification of details of the transformation.</p>
</td></tr>
<tr><td><code id="xform_z_score_+3A_map_missing_to">map_missing_to</code></td>
<td>
<p>Value to be given to the transformed variable if the
value of the input variable is missing.</p>
</td></tr>
<tr><td><code id="xform_z_score_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Perform a z-score normalization on data given in <code>xform_wrap</code> format.
</p>
<p>Given an input variable named <b>InputVar</b>, the name of the transformed
variable <b>OutputVar</b>, and the desired value of the transformed variable
if the input variable value is missing <b>missingVal</b>, the xform_z_score
command including all the optional parameters is:
</p>
<p><code>
xform_info="InputVar -&gt; OutputVar", map_missing_to="missingVal"
</code>
</p>
<p>Two methods can be used to refer to the variables. The first
method is to use its column number; given the <b>data</b> attribute of the
<b>boxData</b> object, this would be the order at which the variable
appears. This can be indicated in the format &quot;column#&quot;. The second method is
to refer to the variable by its name.
</p>
<p>The name of the transformed
variable is optional; if the name is not provided, the transformed variable
is given the name: &quot;derived_&quot; + <em>original_variable_name</em>
</p>
<p><b>missingValue</b>, an optional parameter, is the value to be given to the
output variable if the input variable value is missing. If no input variable
names are provided, by default all numeric variables are transformed. Note
that in this case a replacement value for missing input values cannot be
specified.
</p>


<h3>Value</h3>

<p>R object containing the raw data, the transformed data and data
statistics.
</p>


<h3>Author(s)</h3>

<p>Tridivesh Jena
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xform_wrap">xform_wrap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load the standard iris dataset
data(iris)

# First wrap the data
iris_box &lt;- xform_wrap(iris)

# Perform a z-transform on all numeric variables of the loaded
# iris dataset. These would be Sepal.Length, Sepal.Width,
# Petal.Length, and Petal.Width. The 4 new derived variables
# will be named derived_Sepal.Length, derived_Sepal.Width,
# derived_Petal.Length, and derived_Petal.Width
iris_box_1 &lt;- xform_z_score(iris_box)

# Perform a z-transform on the 1st column of the dataset (Sepal.Length)
# and give the derived variable the name "dsl"
iris_box_2 &lt;- xform_z_score(iris_box, xform_info = "column1 -&gt; dsl")

# Repeat the above operation; adding the new transformed variable
# to the iris_box object
iris_box &lt;- xform_z_score(iris_box, xform_info = "column1 -&gt; dsl")

# Transform Sepal.Width(the 2nd column)
# The new transformed variable will be given the default name
# "derived_Sepal.Width"
iris_box_3 &lt;- xform_z_score(iris_box, xform_info = "column2")

# Repeat the same operation as above, this time using the variable
# name
iris_box_4 &lt;- xform_z_score(iris_box, xform_info = "Sepal.Width")

# Repeat the same operation as above, assign the transformed variable
# "derived_Sepal.Width". The value of 1.0 if the input value of the
# "Sepal.Width" variable is missing. Add the new information to the
# iris_box object.
iris_box &lt;- xform_z_score(iris_box,
  xform_info = "Sepal.Width",
  "map_missing_to=1.0"
)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
