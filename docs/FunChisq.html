<!DOCTYPE html><html><head><title>Help for package FunChisq</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FunChisq}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#FunChisq-package'>
<p>Model-Free Functional Chi-Squared and Exact Tests</p></a></li>
<li><a href='#add.noise'>
<p>Apply Noise to Discrete-Valued Tables</p></a></li>
<li><a href='#cond.fun.chisq.test'>
<p>Conditional Functional Chi-Squared Test</p></a></li>
<li><a href='#cp.fun.chisq.test'>
<p>Comparative Chi-Squared Test for Model-Free Functional Heterogeneity</p></a></li>
<li><a href='#Exact Functional Test'>
<p>Exact Functional Test on Two Discrete Random Variables</p></a></li>
<li><a href='#fun.chisq.test'>
<p>Model-Free Functional Chi-Squared and Exact Tests</p></a></li>
<li><a href='#FunChisq-deprecated'><p>Deprecated Functions in Package <span class="pkg">FunChisq</span></p></a></li>
<li><a href='#plot_table'>
<p>Plot a Table Using Color Intensity for Counts</p></a></li>
<li><a href='#simulate_tables'>
<p>Simulate Noisy Contingency Tables to Represent Diverse Discrete Patterns</p></a></li>
<li><a href='#test.interactions'><p>Functional Chi-Squared Test of Functional Dependency among Many Variables in a Data Set</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>2.5.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-05-25</td>
</tr>
<tr>
<td>Title:</td>
<td>Model-Free Functional Chi-Squared and Exact Tests</td>
</tr>
<tr>
<td>Author:</td>
<td>Yang Zhang [aut],
  Hua Zhong <a href="https://orcid.org/0000-0003-1962-2603"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Hien Nguyen <a href="https://orcid.org/0000-0002-7237-4752"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Ruby Sharma <a href="https://orcid.org/0000-0001-7774-4065"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Sajal Kumar <a href="https://orcid.org/0000-0003-0930-1582"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Yiyi Li [aut],
  Joe Song <a href="https://orcid.org/0000-0002-6883-6547"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joe Song &lt;joemsong@cs.nmsu.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Statistical hypothesis testing methods for
 inferring model-free functional dependency using asymptotic
 chi-squared or exact distributions. Functional test
 statistics are asymmetric and functionally optimal, unique
 from other related statistics. Tests in this package reveal
 evidence for causality based on the causality-by-
 functionality principle. They include asymptotic functional
 chi-squared tests (Zhang &amp; Song 2013) &lt;<a href="https://doi.org/10.48550/arXiv.1311.2707">doi:10.48550/arXiv.1311.2707</a>&gt;,
 an adapted functional chi-squared test (Kumar &amp; Song 2022) 
 &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtac206">doi:10.1093/bioinformatics/btac206</a>&gt;, 
 and an exact functional test (Zhong &amp; Song 2019)
 &lt;<a href="https://doi.org/10.1109%2FTCBB.2018.2809743">doi:10.1109/TCBB.2018.2809743</a>&gt; (Nguyen et al. 2020)
 &lt;<a href="https://doi.org/10.24963%2Fijcai.2020%2F372">doi:10.24963/ijcai.2020/372</a>&gt;. The normalized functional
 chi-squared test was used by Best Performer 'NMSUSongLab'
 in HPN-DREAM (DREAM8) Breast Cancer Network Inference
 Challenges (Hill et al. 2016) &lt;<a href="https://doi.org/10.1038%2Fnmeth.3773">doi:10.1038/nmeth.3773</a>&gt;. A
 function index (Zhong &amp; Song 2019)
 &lt;<a href="https://doi.org/10.1186%2Fs12920-019-0565-9">doi:10.1186/s12920-019-0565-9</a>&gt; (Kumar et al. 2018)
 &lt;<a href="https://doi.org/10.1109%2FBIBM.2018.8621502">doi:10.1109/BIBM.2018.8621502</a>&gt; derived from the
 functional test statistic offers a new effect size measure
 for the strength of functional dependency, a better
 alternative to conditional entropy in many aspects. For
 continuous data, these tests offer an advantage over
 regression analysis when a parametric functional form
 cannot be assumed; for categorical data, they provide a
 novel means to assess directional dependency not possible
 with symmetrical Pearson's chi-squared or Fisher's exact
 tests.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, Rdpack (&ge; 0.6-1), stats, dqrng</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH, Rcpp</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Ckmeans.1d.dp, DescTools, DiffXTables, GridOnClusters,
infotheo, knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.cs.nmsu.edu/~joemsong/publications/">https://www.cs.nmsu.edu/~joemsong/publications/</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-25 10:12:23 UTC; joesong</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-25 10:30:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='FunChisq-package'>
Model-Free Functional Chi-Squared and Exact Tests
</h2><span id='topic+FunChisq-package'></span>

<h3>Description</h3>

<p>Statistical hypothesis testing methods for model-free functional dependency using asymptotic chi-squared or exact distributions. Functional chi-squared test statistics (Zhang and Song 2013; Zhang 2014; Nguyen 2018; Zhong 2019; Zhong and Song 2019a; Nguyen et al. 2020) are asymmetric, functionally optimal, and model-free, unique from other related statistical measures.
</p>
<p>Tests in this package reveal evidence for causality based on the causality-by-functionality principle (Simon and Rescher 1966). The tests require data from two or more variables be formatted as a contingency table. Continuous variables need to be discretized first, for example, using R packages <span class="pkg">Ckmeans.1d.dp</span> or <span class="pkg">GridOnClusters</span>.
</p>
<p>The package implements an asymptotic functional chi-squared test (Zhang and Song 2013; Zhang 2014), an adapted functional chi-squared test (Kumar2022AFT), and an exact functional test (Nguyen 2018; Zhong 2019; Zhong and Song 2019a; Nguyen et al. 2020). The normalized functional chi-squared test was used by Best Performer NMSUSongLab in HPN-DREAM (DREAM8) Breast Cancer Network Inference Challenges (Hill et al. 2016).
</p>
<p>A function index derived from the functional chi-squared offers a new effect size measure for the strength of function dependency. It is asymmetrically functionally optimal, different from the symmetric Cramer's V, also a better alternative to conditional entropy in many aspects.
</p>
<p>A simulator is provided to generate functional, dependent non-functional, and independent patterns (Sharma et al. 2017).
</p>
<p>For continuous data, these tests offer an advantage over regression analysis when a parametric form cannot be reliably assumed for the underlying function. For categorical data, they provide a novel means to assess directional dependency not possible with symmetrical Pearson's chi-squared test, G-test, or Fisher's exact test.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> FunChisq</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Current version: </td><td style="text-align: left;"> 2.5.3</td>
</tr>
<tr>
 <td style="text-align: left;">
Initial release version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Initial release date: </td><td style="text-align: left;"> 2014-03-08</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> LGPL (&gt;= 3) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Yang Zhang, Hua Zhong, Hien Nguyen, Ruby Sharma, Sajal Kumar, Yiyi Li, and Joe Song
</p>


<h3>References</h3>

<p>Hill SM, Heiser LM, Cokelaer T, Unger M, Nesser NK, Carlin DE, Zhang Y, Sokolov A, Paull EO, Wong CK, Graim K, Bivol A, Wang H, Zhu F, Afsari B, Danilova LV, Favorov AV, Lee WS, Taylor D, Hu CW, Long BL, Noren DP, Bisberg AJ, The HPN-DREAM Consortium, Mills GB, Gray JW, Kellen M, Norman T, Friend S, Qutub AA, Fertig EJ, Guan Y, Song M, Stuart JM, Spellman PT, Koeppl H, Stolovitzky G, Saez-Rodriguez J, Mukherjee S (2016).
&ldquo;Inferring causal molecular networks: empirical assessment through a community-based effort.&rdquo;
<em>Nat Methods</em>, <b>13</b>, 310&ndash;318.
<a href="https://doi.org/10.1038/nmeth.3773">doi:10.1038/nmeth.3773</a>.<br /><br /> Nguyen HH (2018).
<em>Inference of Functional Dependency via Asymmetric, Optimal, and Model-free Statistics</em>.
Ph.D. thesis, Department of Computer Science, New Mexico State University, Las Cruces, NM, USA.<br /><br /> Nguyen HH, Zhong H, Song M (2020).
&ldquo;Optimality, accuracy, and efficiency of an exact functional test.&rdquo;
In <em>Proceedings of the Twenty-Ninth International Joint Conference on Artificial Intelligence, IJCAI-20</em>, 2683&ndash;2689.
<a href="https://doi.org/10.24963/ijcai.2020/372">doi:10.24963/ijcai.2020/372</a>.<br /><br /> Sharma R, Kumar S, Zhong H, Song M (2017).
&ldquo;Simulating noisy, nonparametric, and multivariate discrete patterns.&rdquo;
<em>The R Journal</em>, <b>9</b>(2), 366&ndash;377.
<a href="https://doi.org/10.32614/RJ-2017-053">doi:10.32614/RJ-2017-053</a>.<br /><br /> Simon HA, Rescher N (1966).
&ldquo;Cause and counterfactual.&rdquo;
<em>Philosophy of Science</em>, <b>33</b>(4), 323&ndash;340.<br /><br /> Zhang Y (2014).
<em>Nonparametric Statistical Methods for Biological Network Inference</em>.
Ph.D. thesis, Department of Computer Science, New Mexico State University, Las Cruces, NM, USA.<br /><br /> Zhang Y, Song M (2013).
&ldquo;Deciphering interactions in causal networks without parametric assumptions.&rdquo;
<em>arXiv Molecular Networks</em>, arXiv:1311.2707.
<a href="https://arxiv.org/abs/1311.2707">https://arxiv.org/abs/1311.2707</a>.<br /><br /> Zhong H (2019).
<em>Model-free Gene-to-zone Network Inference of Molecular Mechanisms in Biology</em>.
Ph.D. thesis, Department of Computer Science, New Mexico State University, Las Cruces, NM, USA.<br /><br /> Zhong H, Song M (2019a).
&ldquo;A fast exact functional test for directional association and cancer biology applications.&rdquo;
<em>IEEE/ACM Transactions on Computational Biology and Bioinformatics</em>, <b>16</b>(3), 818&ndash;826.
<a href="https://doi.org/10.1109/TCBB.2018.2809743">doi:10.1109/TCBB.2018.2809743</a>.
</p>


<h3>See Also</h3>

<p>For data discretization, an option is optimal univariate clustering via package <span class="pkg">Ckmeans.1d.dp</span>. A second option is joint multivariate discretization via package <span class="pkg">GridOnClusters</span>.
</p>
<p>For symmetric dependency tests on discrete data, see Pearson's chi-squared test (<code><a href="stats.html#topic+chisq.test">chisq.test</a></code>), Fisher's exact test (<code><a href="stats.html#topic+fisher.test">fisher.test</a></code>), mutual information (package <span class="pkg">entropy</span>), and G-test, implemented in packages <span class="pkg">DescTools</span> and <span class="pkg">RVAideMemoire</span>.
</p>

<hr>
<h2 id='add.noise'>
Apply Noise to Discrete-Valued Tables
</h2><span id='topic+add.noise'></span><span id='topic+add.house.noise'></span><span id='topic+add.candle.noise'></span>

<h3>Description</h3>

<p>The function can apply two types of noise to contingency tables of discrete values. A house noise model is designed for ordinal variables; a candle noise model is for categorical variables. Noise is applied independently for each data point in a table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.noise(tables, u, noise.model, margin=0)
add.house.noise(tables, u, margin=0)
add.candle.noise(tables, u, margin=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.noise_+3A_tables">tables</code></td>
<td>

<p>a list of tables or one table. A table can be either a matrix or a data frame of integer values.
</p>
</td></tr>
<tr><td><code id="add.noise_+3A_u">u</code></td>
<td>

<p>a numeric value between 0 and 1 to specify the noise level to be applied to the input tables. See Details.
</p>
</td></tr>
<tr><td><code id="add.noise_+3A_noise.model">noise.model</code></td>
<td>

<p>a character string indicating the noise model of either <code>"house"</code> for ordinal variables or <code>"candle"</code> for categorical variables. See Details.
</p>
</td></tr>
<tr><td><code id="add.noise_+3A_margin">margin</code></td>
<td>

<p>a value of either 0, 1, or 2. Default is 0.
</p>
<p>0: noise is applied along both rows and columns in a table. The sum of values in the table is the same before and after noise application.
</p>
<p>1: noise is applied along each row. The sum of each row is the same before and after noise application.
</p>
<p>2: noise is applied along each column. The sum of each column is the same before and after noise application.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each noise model defines a conditional probability function of a noisy version given an original discrete value and a noise level. In the house noise model for ordinal variables, defined in (Zhang et al. 2015), the probability decreases as the noisy version deviates from the original ordinal value. The shape of the function is like a pitched house roof. In the candle noise model for categorical variables, the probability of the noisy version for any value other than the original categorical value is the same given the noise level. The function shape is like a candle.
</p>
<p>At a minimum level of 0, no noise is applied on the input table(s). A maximum level of 1 indicates that the original sample will be changed to some other values with a probability of 1. For a discrete random variable of two possible values, a noise level of 1 will flip the values and create a non-random pattern; a noise level of 0.5 creates the most random pattern.
</p>


<h3>Value</h3>

<p>If <code>tables</code> is a list, the function returns a list of tables with noised applied. If <code>tables</code> is a numeric matrix or a data frame, the function returns one table with noise applied.
</p>


<h3>Author(s)</h3>

<p>Hua Zhong, Yang Zhang, and Joe Song.
</p>


<h3>References</h3>

<p>Zhang Y, Liu ZL, Song M (2015).
&ldquo;ChiNet uncovers rewired transcription subnetworks in tolerant yeast for advanced biofuels conversion.&rdquo;
<em>Nucleic Acids Research</em>, <b>43</b>(9), 4393&ndash;4407.
<a href="https://doi.org/10.1093/nar/gkv358">doi:10.1093/nar/gkv358</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_tables">simulate_tables</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Example 1. Add house noise to a single table

  # Create a 4x4 table
  t &lt;- matrix(c(3,0,0,0,
                0,2,2,0,
                0,0,0,4,
                3,3,2,0),
              nrow=4, ncol=4, byrow=TRUE)
  # Two ways to apply house noise at level 0.1 along both rows
  # and columns of the table:
  add.noise(t, 0.1, "house", 0)
  add.house.noise(t, 0.1, 0)


  # Example 2. Add candle noise to a list of tables

  # Create a list of tables
  t.list &lt;- list(t+5, t*10, t*2)
  # Two ways to apply candle noise at level 0.2 along the rows
  # of the table:
  add.noise(t.list, 0.2, "candle", 1)
  add.candle.noise(t.list, 0.2, 1)

</code></pre>

<hr>
<h2 id='cond.fun.chisq.test'>
Conditional Functional Chi-Squared Test
</h2><span id='topic+cond.fun.chisq.test'></span>

<h3>Description</h3>

<p>Asymptotic chi-squared test to determine the model-free functional dependency of effect variable <code class="reqn">Y</code> on a cause variable <code class="reqn">X</code>, conditioned on a third variable <code class="reqn">Z</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cond.fun.chisq.test(x, y, z=NULL, data=NULL, log.p = FALSE,
                    method = c("fchisq", "nfchisq"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cond.fun.chisq.test_+3A_x">x</code></td>
<td>

<p>vector or character; either a discrete random variable (cause) represented as vector or a character column name in <code>data</code>.
</p>
</td></tr>
<tr><td><code id="cond.fun.chisq.test_+3A_y">y</code></td>
<td>

<p>vector or character; either a discrete random variable (effect) represented as vector or a character column name in <code>data</code>.
</p>
</td></tr>
<tr><td><code id="cond.fun.chisq.test_+3A_z">z</code></td>
<td>

<p>vector or character; either a discrete random variable (condition) represented as vector or a character column name in <code>data</code>. In case of <code>NULL</code>, a <code>fun.chisq.test</code> on a contingency table, with <code>x</code> as row variable and <code>y</code> as column variable, is returned. See <code><a href="#topic+fun.chisq.test">fun.chisq.test</a></code> for details. The default is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="cond.fun.chisq.test_+3A_data">data</code></td>
<td>

<p>a data frame containing three or more columns whose names can be used as values for <code>x</code>, <code>y</code> and <code>z</code>. In case of <code>NULL</code>, <code>x</code>, <code>y</code> and <code>z</code> must be vectors. The default is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="cond.fun.chisq.test_+3A_log.p">log.p</code></td>
<td>

<p>logical; if <code>TRUE</code>, the p-value is given as <code>log(p)</code>. Taking the log improves numerical precision when the p-value is close to zero. The default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="cond.fun.chisq.test_+3A_method">method</code></td>
<td>

<p>a character string to specify the method to compute the conditional functional chi-squared test statistic and its p-value. The options are <code>"fchisq"</code> (default) and <code>"nfchisq"</code>. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The conditional functional chi-squared test introduces the concept of conditional functional depedency, where the functional association between two variables (<code>x</code> and <code>y</code>) is tested conditioned on a third variable (<code>z</code>) (Zhang 2014). Two methods are provided to compute the chi-squared statistic and its p-value. When <code>method = "fchisq"</code>, the p-value is computed using the chi-squared distribution; when <code>method = "nfchisq"</code>, a normalized statistic is obtained by shifting and scaling the original chi-squared statistic and a p-value is computed using the standard normal distribution (Box et al. 2005). The normalized test is more conservative on the degrees of freedom.
</p>


<h3>Value</h3>

<p>A list with class &quot;<code>htest</code>&quot; containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the conditional functional chi-squared statistic if <code>method = "fchisq"</code>; or the normalized conditional functional chi-squared statistic if <code>method = "nfchisq"</code>.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>degrees of freedom for the conditional functional chi-squared statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>p-value of the conditional functional test. If <code>method = "fchisq"</code>, the p-value is computed by an asymptotic chi-squared distribution; if <code>method = "nfchisq"</code>, the p-value is computed by the standard normal distribution.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>an estimate of the conditional function index between 0 and 1. The value of 1 indicates strong functional dependency between <code>x</code> and <code>y</code>, given <code>z</code>. It is asymmetrical with respect to whether <code>x</code> was chosen as the cause of effect <code>y</code> or vice versa.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sajal Kumar and Mingzhou Song
</p>


<h3>References</h3>

<p>Box GE, Hunter JS, Hunter WG (2005).
<em>Statistics for Experimenters: Design, Innovation and Discovery</em>, 2nd edition.
Wiley-Interscience, New York.<br /><br /> Zhang Y (2014).
<em>Nonparametric Statistical Methods for Biological Network Inference</em>.
Ph.D. thesis, Department of Computer Science, New Mexico State University, Las Cruces, NM, USA.
</p>


<h3>See Also</h3>

<p>See (unconditional) functional chi-squared test <code><a href="#topic+fun.chisq.test">fun.chisq.test</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a relationship between variables X and Z
xz = matrix(c(30,2,2, 2,2,40, 2,30,2),ncol=3,nrow=3,
            byrow = TRUE)
# Re-construct X
x = rep(c(1:nrow(xz)),rowSums(xz))
# Re-construct Z
z = c()
for(i in 1:nrow(xz))
  z = c(z,rep(c(1:ncol(xz)),xz[i,]))

# Generate a relationship between variables Z and Y
# Make sure Z retains its distribution
zy = matrix(c(4,30, 30,4, 4,40),ncol=2,nrow=3,
            byrow = TRUE)
# Re-construct Y
y = rep(0,length(z))
for(i in unique(z))
  y[z==i] = rep(c(1:ncol(zy)),zy[i,])

# Tables
table(x,z)
table(z,y)
table(x,y)

# Conditional functional dependency
# Y = f(X) | Z should be false
cond.fun.chisq.test(x=x,y=y,z=z)
# Z = f(X) | Y should be true
cond.fun.chisq.test(x=x,y=z,z=y)
# Y = f(Z) | X should be true
cond.fun.chisq.test(x=z,y=y,z=x)
</code></pre>

<hr>
<h2 id='cp.fun.chisq.test'>
Comparative Chi-Squared Test for Model-Free Functional Heterogeneity
</h2><span id='topic+cp.fun.chisq.test'></span>

<h3>Description</h3>

<p>Comparative functional chi-squared tests on two or more contingency tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cp.fun.chisq.test(
  x, method = c("fchisq", "nfchisq", "default", "normalized"),
  log.p = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cp.fun.chisq.test_+3A_x">x</code></td>
<td>

<p>a list of at least two matrices representing contingency tables of the same dimensionality.
</p>
</td></tr>
<tr><td><code id="cp.fun.chisq.test_+3A_method">method</code></td>
<td>

<p>a character string to specify the method to compute the functional chi-squared statistic and its p-value. The default is <code>"fchisq"</code> (equivalent to <code>"default"</code>). See Details.
</p>
<p>Note: <code>"default"</code> and <code>"normalized"</code> are deprecated.
</p>
</td></tr>
<tr><td><code id="cp.fun.chisq.test_+3A_log.p">log.p</code></td>
<td>

<p>logical; if <code>TRUE</code>, the p-value is given as <code>log(p)</code>. Taking the log improves the accuracy when p-value is close to zero. The default is <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The comparative functional chi-squared test determines whether the patterns underlying the contingency tables are heterogeneous in a functional way (Zhang 2014). Specifically, it evaluates whether the column variable is a changed function of the row variable across the contingency tables.
</p>
<p>Two methods are provided to compute the functional chi-squared statistic and its p-value. When <code>method = "fchisq"</code> (or <code>"default"</code>), the p-value is computed using the chi-squared distribution; when <code>method =</code> <code>"nfchisq"</code> (or <code>"normalized"</code>) a normalized statistic is obtained by shifting and scaling the original statistic and a p-value is computed using the standard normal distribution (Box et al. 2005)
(Box et al., 2005). The normalized test is more conservative on the degrees of freedom.
</p>


<h3>Value</h3>

<p>A list with class &quot;<code>htest</code>&quot; containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>functional heterogeneity statistic if <code>method = "fchisq"</code> (equivalent to <code>"default"</code>), or normalized statistic if <code>method = "nfchisq"</code> (equivalent to <code>"normalized"</code>).</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>degrees of freedom.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>p-value of the comparative functional chi-squared test. By default, it is computed by the chi-squared distribution. If <code>method = "normalized"</code>, it is the p-value of the normalized statistic computed by the standard normal distribution.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yang Zhang and Joe Song
</p>


<h3>References</h3>

<p>Box GE, Hunter JS, Hunter WG (2005).
<em>Statistics for Experimenters: Design, Innovation and Discovery</em>, 2nd edition.
Wiley-Interscience, New York.<br /><br /> Zhang Y (2014).
<em>Nonparametric Statistical Methods for Biological Network Inference</em>.
Ph.D. thesis, Department of Computer Science, New Mexico State University, Las Cruces, NM, USA.
</p>


<h3>See Also</h3>

<p>For comparative chi-squared test that does not consider functional dependencies, <code><a href="DiffXTables.html#topic+cp.chisq.test">cp.chisq.test</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix(c(4,0,4,0,4,0,1,0,1), 3)
y &lt;- t(x)
z &lt;- matrix(c(1,0,1,4,0,4,0,4,0), 3)
data &lt;- list(x,y,z)
cp.fun.chisq.test(data)
cp.fun.chisq.test(data, method="nfchisq")

</code></pre>

<hr>
<h2 id='Exact+20Functional+20Test'>
Exact Functional Test on Two Discrete Random Variables
</h2><span id='topic+Exact+20Functional+20Test'></span><span id='topic+EFTDP'></span><span id='topic+EFTDQP'></span>

<h3>Description</h3>

<p>Perform the exact functional test on a contingency table to determine if the column variable is a function of the row variable. The null population includes tables with fixed row and column sums as in the observed table. The null distribution follows an exact multivariate hypergeometric distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EFTDP(nm)
EFTDQP(nm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Exact+2B20Functional+2B20Test_+3A_nm">nm</code></td>
<td>

<p>a matrix of nonnegative integers representing a contingency table.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The exact functional test is performed using branch-and-bound with two algorithms (DP and DQP) to avoid re-calculation of bounds (Nguyen 2018; Nguyen et al. 2020).
</p>


<h3>Value</h3>

<p>The exact p-value of the test.
</p>


<h3>Note</h3>

<p>The functions provide a direct entry into the C++ implementations of the exact functional test (Nguyen 2018; Nguyen et al. 2020).
</p>


<h3>Author(s)</h3>

<p>Hien Nguyen, Hua Zhong, and Joe Song
</p>


<h3>References</h3>

<p>Nguyen HH (2018).
<em>Inference of Functional Dependency via Asymmetric, Optimal, and Model-free Statistics</em>.
Ph.D. thesis, Department of Computer Science, New Mexico State University, Las Cruces, NM, USA.<br /><br /> Nguyen HH, Zhong H, Song M (2020).
&ldquo;Optimality, accuracy, and efficiency of an exact functional test.&rdquo;
In <em>Proceedings of the Twenty-Ninth International Joint Conference on Artificial Intelligence, IJCAI-20</em>, 2683&ndash;2689.
<a href="https://doi.org/10.24963/ijcai.2020/372">doi:10.24963/ijcai.2020/372</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fun.chisq.test">fun.chisq.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = matrix(c(0, 6, 3, 0, 10, 5, 4, 4, 1), nrow=3)
EFTDQP(x)
EFTDQP(t(x))

EFTDP(x)
EFTDP(t(x))
</code></pre>

<hr>
<h2 id='fun.chisq.test'>
Model-Free Functional Chi-Squared and Exact Tests
</h2><span id='topic+fun.chisq.test'></span>

<h3>Description</h3>

<p>Asymptotic chi-squared, normalized chi-squared or exact tests on contingency tables to determine model-free functional dependency of the column variable on the row variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.chisq.test(
  x,
  method = c("fchisq", "nfchisq", "adapted",
             "exact", "exact.qp", "exact.dp", "exact.dqp",
             "default", "normalized", "simulate.p.value"),
  alternative = c("non-constant", "all"), log.p=FALSE,
  index.kind = c("conditional", "unconditional"),
  simulate.nruns = 2000,
  exact.mode.bound=TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fun.chisq.test_+3A_x">x</code></td>
<td>

<p>a matrix representing a contingency table. The row variable represents the independent variable or all unique combinations of multiple independent variables. The column variable is the dependent variable.
</p>
</td></tr>
<tr><td><code id="fun.chisq.test_+3A_method">method</code></td>
<td>

<p>a character string to specify the method to compute the functional chi-squared test statistic and its p-value. The options are <code>"fchisq"</code> (equivalent to <code>"default"</code>, the default), <code>"nfchisq"</code> (equivalent to <code>"normalized"</code>), <code>"exact"</code>, <code>"adapted"</code>, <code>"exact.qp"</code>, <code>"exact.dp"</code>, <code>"exact.dqp"</code> or <code>"simulate.p.value"</code>. See Details.
</p>
<p>Note: <code>"default"</code> and <code>"normalized"</code> are deprecated.
</p>
</td></tr>
<tr><td><code id="fun.chisq.test_+3A_alternative">alternative</code></td>
<td>

<p>a character string to specify the alternative hypothesis. The options are <code>"non-constant"</code> (default, non-constant functions) and <code>"all"</code> (all types of functions including constant ones).
</p>
</td></tr>
<tr><td><code id="fun.chisq.test_+3A_log.p">log.p</code></td>
<td>

<p>logical; if <code>TRUE</code>, the p-value is given as <code>log(p)</code>. Taking the log improves the accuracy when p-value is close to zero. The default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="fun.chisq.test_+3A_index.kind">index.kind</code></td>
<td>

<p>a character string to specify the kind of function index xi.f to be estimated. The options are <code>"conditional"</code> (default) and <code>"unconditional"</code>. See Details.
</p>
</td></tr>
<tr><td><code id="fun.chisq.test_+3A_simulate.nruns">simulate.nruns</code></td>
<td>

<p>A number to specify the number of tables generated to simulate the null distribution. Default is <code>2000</code>. Only used when <code>method="simulate.p.value"</code>.
</p>
</td></tr>
<tr><td><code id="fun.chisq.test_+3A_exact.mode.bound">exact.mode.bound</code></td>
<td>

<p>logical; if <code>TRUE</code>, a fast branch-and-bound algorithm is used for the exact functional test (<code>method="exact"</code>). If <code>FALSE</code>, a slow brute-force enumeration method is used to provide a  reference for runtime analysis. Both options provide the same exact p-value. The default is <code>TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functional chi-squared test determines whether the column variable is a function of the row variable in contingency table <code>x</code> (Zhang and Song 2013; Zhang 2014). This function supports three hypothesis testing methods:
</p>
<p>When <code>method="fchisq"</code> (equivalent to <code>"default"</code>, the default), the test statistic is computed as described in (Zhang and Song 2013; Zhang 2014) and the p-value is computed using the chi-squared distribution.
</p>
<p>When <code>method="nfchisq"</code> (equivalent to <code>"normalized"</code>), the test statistic is obtained by shifting and scaling the original test statistic (Zhang and Song 2013; Zhang 2014); and the p-value is computed using the standard normal distribution (Box et al. 2005). The normalized chi-squared, more conservative on the degrees of freedom, was used by the Best Performer NMSUSongLab in HPN-DREAM (DREAM8) Breast Cancer Network Inference Challenges.
</p>
<p>When <code>method="exact"</code>, <code>"exact.qp"</code> (quadratic programming) (Zhong and Song 2019a; Zhong 2019), <code>"exact.dp"</code> (dynamic programming) (Nguyen 2018; Nguyen et al. 2020), or <code>"exact.dqp"</code> (dynamic and quadratic programming) (Nguyen 2018; Nguyen et al. 2020), an exact functional test is performed. The option of <code>"exact"</code> uses <code>"exact.dqp"</code>, the fastest method. All methods compute an exact p-value.
</p>
<p>When <code>method="adapted"</code>, the adapted functional chi-squared test (Kumar and Song 2022) is used. The test statistic is obtained by evaluating the most populous portrait or square (number of rows &lt;= number of columns) table in the contingency table <code>x</code>. The p-value is computed using the chi-squared distribution. This option should be used to determine the functional direction between variables in <code>x</code>.
</p>
<p>For the <code>"exact.qp"</code> and <code>"exact.dp"</code> options, if the sample size is no more than 200 or the average cell count is less than five, and the table size is no more than 10 in either row or column, the exact test will not be called and the asymptotic functional chi-squared test (<code>method="fchisq"</code>) is used instead.  
</p>
<p>For <code>"exact.dqp"</code>, the exact functional test will always be performed.
</p>
<p>For 2-by-2 contingency tables, the asymptotic test options (<code>method="fchisq"</code> or <code>"nfchisq"</code>) are recommended to test functional dependency, instead of the exact functional test.
</p>
<p>When <code>method="simulate.p.value"</code>, a simulated null distribution is used to calculate <code>p-value</code>. The null distribution is a multinomial distribution that is the product of two marginal distributions. Like other Monte Carlo based methods, this method is slower but may be more accurate than other methods based on asymptotic distributions.
</p>
<p><code>index.kind</code> specifies the kind of function index to be computed. If the experimental design controls neither the row nor column marginal sums, <code>index.kind = "unconditional"</code> is recommended; If the column marginal sums are controlled, <code>index.kind = "conditional"</code> is recommended. The <code>conditional</code> function index is the square root of Goodman-Kruskal's tau (Goodman and Kruskal 1954). The choice of <code>index.kind</code> affects only the function index xi.f value, but not the test statistic or p-value.
</p>


<h3>Value</h3>

<p>A list with class &quot;<code>htest</code>&quot; containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the functional chi-squared statistic if <code>method = "fchisq"</code>, <code>"default"</code>, or <code>"exact"</code>; or the normalized functional chi-squared statistic if <code>method = "nfchisq"</code> or <code>"normalized"</code>.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>degrees of freedom for the functional chi-squared statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>p-value of the functional test. If <code>method = "fchisq"</code> (or <code>"default"</code>), it is computed by an asymptotic chi-squared distribution; if <code>method = "nfchisq"</code> (or <code>"normalized"</code>), it is computed by the standard normal distribution; if <code>method</code> <code>= "exact"</code>, it is computed by an exact hypergeometric distribution.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>an estimate of function index between 0 and 1. The value of 1 indicates a strictly mathematical function. It is asymmetrical with respect to transpose of the input contingency table, different from the symmetrical Cramer's V based on the Pearson's chi-squared test statistic. See (Zhong and Song 2019b; Kumar et al. 2018) for the definition of function index.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yang Zhang, Hua Zhong, Hien Nguyen, Sajal Kumar, and Joe Song
</p>


<h3>References</h3>

<p>Box GE, Hunter JS, Hunter WG (2005).
<em>Statistics for Experimenters: Design, Innovation and Discovery</em>, 2nd edition.
Wiley-Interscience, New York.<br /><br /> Goodman LA, Kruskal WH (1954).
&ldquo;Measures of Association for Cross Classifications.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>49</b>(268), 732&ndash;764.<br /><br /> Kumar S, Song M (2022).
&ldquo;Overcoming biases in causal inference of molecular interactions.&rdquo;
<em>Bioinformatics</em>, <b>38</b>(10), 2818&ndash;2825.
<a href="https://doi.org/10.1093/bioinformatics/btac206">doi:10.1093/bioinformatics/btac206</a>.<br /><br /> Kumar S, Zhong H, Sharma R, Li Y, Song M (2018).
&ldquo;Scrutinizing functional interaction networks from RNA-binding proteins to their targets in cancer.&rdquo;
In <em>IEEE International Conference on Bioinformatics and Biomedicine</em>, 185&ndash;190.
<a href="https://doi.org/10.1109/BIBM.2018.8621502">doi:10.1109/BIBM.2018.8621502</a>.<br /><br /> Nguyen HH (2018).
<em>Inference of Functional Dependency via Asymmetric, Optimal, and Model-free Statistics</em>.
Ph.D. thesis, Department of Computer Science, New Mexico State University, Las Cruces, NM, USA.<br /><br /> Nguyen HH, Zhong H, Song M (2020).
&ldquo;Optimality, accuracy, and efficiency of an exact functional test.&rdquo;
In <em>Proceedings of the Twenty-Ninth International Joint Conference on Artificial Intelligence, IJCAI-20</em>, 2683&ndash;2689.
<a href="https://doi.org/10.24963/ijcai.2020/372">doi:10.24963/ijcai.2020/372</a>.<br /><br /> Zhang Y (2014).
<em>Nonparametric Statistical Methods for Biological Network Inference</em>.
Ph.D. thesis, Department of Computer Science, New Mexico State University, Las Cruces, NM, USA.<br /><br /> Zhang Y, Song M (2013).
&ldquo;Deciphering interactions in causal networks without parametric assumptions.&rdquo;
<em>arXiv Molecular Networks</em>, arXiv:1311.2707.
<a href="https://arxiv.org/abs/1311.2707">https://arxiv.org/abs/1311.2707</a>.<br /><br /> Zhong H (2019).
<em>Model-free Gene-to-zone Network Inference of Molecular Mechanisms in Biology</em>.
Ph.D. thesis, Department of Computer Science, New Mexico State University, Las Cruces, NM, USA.<br /><br /> Zhong H, Song M (2019a).
&ldquo;A fast exact functional test for directional association and cancer biology applications.&rdquo;
<em>IEEE/ACM Transactions on Computational Biology and Bioinformatics</em>, <b>16</b>(3), 818&ndash;826.
<a href="https://doi.org/10.1109/TCBB.2018.2809743">doi:10.1109/TCBB.2018.2809743</a>.<br /><br /> Zhong H, Song M (2019b).
&ldquo;Directional association test reveals high-quality putative cancer driver biomarkers including noncoding RNAs.&rdquo;
<em>BMC Med Genomics</em>, <b>12</b>(7), 129.
<a href="https://doi.org/10.1186/s12920-019-0565-9">doi:10.1186/s12920-019-0565-9</a>.
</p>


<h3>See Also</h3>

<p>For data discretization, an option is optimal univariate clustering via package <span class="pkg">Ckmeans.1d.dp</span>. A second option is joint multivariate discretization via package <span class="pkg">GridOnClusters</span>.
</p>
<p>For symmetrical dependency tests on discrete data, see Pearson's chi-squared test <code><a href="stats.html#topic+chisq.test">chisq.test</a></code>, Fisher's exact test <code><a href="stats.html#topic+fisher.test">fisher.test</a></code>, and mutual information methods in package <span class="pkg">entropy</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1. Asymptotic functional chi-squared test
x &lt;- matrix(c(20,0,20,0,20,0,5,0,5), 3)
fun.chisq.test(x) # strong functional dependency
fun.chisq.test(t(x)) # weak functional dependency

# Example 2. Normalized functional chi-squared test
x &lt;- matrix(c(8,0,8,0,8,0,2,0,2), 3)
fun.chisq.test(x, method="nfchisq") # strong functional dependency
fun.chisq.test(t(x), method="nfchisq") # weak functional dependency

# Example 3. Exact functional chi-squared test
x &lt;- matrix(c(4,0,4,0,4,0,1,0,1), 3)
fun.chisq.test(x, method="exact") # strong functional dependency
fun.chisq.test(t(x), method="exact") # weak functional dependency

# Example 4. Exact functional chi-squared test on a real data set
#            (Shen et al., 2002)
# x is a contingency table with row variable for p53 mutation and
#   column variable for CIMP
x &lt;- matrix(c(12,26,18,0,8,12), nrow=2, ncol=3, byrow=TRUE)

# Example 5. Adpated functional chi-squared test
x &lt;- matrix(c(20, 0, 1, 0, 1, 20, 3, 2, 15, 2, 5, 2), 3, 4, byrow=TRUE)
fun.chisq.test(x, method="adapted") # strong functional dependency
fun.chisq.test(t(x), method="adapted") # weak functional dependency

# Test the functional dependency: p53 mutation -&gt; CIMP
fun.chisq.test(x, method="exact")

# Test the functional dependency CIMP -&gt; p53 mutation
fun.chisq.test(t(x), method="exact")

# Example 6. Asymptotic functional chi-squared test with simulated distribution
x &lt;- matrix(c(20,0,20,0,20,0,5,0,5), 3)
fun.chisq.test(x, method="simulate.p.value")
fun.chisq.test(x, method="simulate.p.value", simulate.n = 1000)

</code></pre>

<hr>
<h2 id='FunChisq-deprecated'>Deprecated Functions in Package <span class="pkg">FunChisq</span></h2><span id='topic+FunChisq-deprecated'></span><span id='topic+cp.chisq.test'></span>

<h3>Description</h3>

<p>These functions are provided for compatibility with older versions of package <span class="pkg">FunChisq</span> only, and may be removed eventually.
</p>


<h3>Details</h3>

<p>The following functions are deprecated and will be made defunct; use
the replacement indicated below:
</p>

<ul>
<li><p><code>cp.chisq.test</code>: now available as <code><a href="DiffXTables.html#topic+cp.chisq.test">cp.chisq.test</a></code> in package <span class="pkg">DiffXTables</span>
</p>
</li></ul>


<hr>
<h2 id='plot_table'>
Plot a Table Using Color Intensity for Counts
</h2><span id='topic+plot_table'></span>

<h3>Description</h3>

<p>A table is visualized as a matrix whose cells are shown with intensity of a given color proportional to the count in each cell. The count in a cell must be real: negative numbers or non-integers are acceptable. It provides a global understanding of the underlying pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_table(table, xlab = "Column", ylab = "Row", col = "green3",
           xaxt = "n", yaxt = "n", main = NULL,
           show.value = TRUE, value.cex = 2,
           highlight=c("row.maxima", "none"),
           highlight.col=col,
           mgp=c(0.5,0,0), mar=c(2,2,3,1.5), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_table_+3A_table">table</code></td>
<td>
<p>A data frame or a matrix.
</p>
</td></tr>
<tr><td><code id="plot_table_+3A_xlab">xlab</code></td>
<td>

<p>The lable of the horizontal axis.
</p>
</td></tr>
<tr><td><code id="plot_table_+3A_ylab">ylab</code></td>
<td>

<p>The lable of the vertical axis.
</p>
</td></tr>
<tr><td><code id="plot_table_+3A_col">col</code></td>
<td>

<p>The color corresponding to the maximum value in the table.
</p>
</td></tr>
<tr><td><code id="plot_table_+3A_xaxt">xaxt</code></td>
<td>

<p>The style of the horizontal axis. See <code><a href="graphics.html#topic+par">par</a></code>.
</p>
</td></tr>
<tr><td><code id="plot_table_+3A_yaxt">yaxt</code></td>
<td>

<p>The style of the vertical axis. See <code><a href="graphics.html#topic+par">par</a></code>.
</p>
</td></tr>
<tr><td><code id="plot_table_+3A_main">main</code></td>
<td>

<p>The title of the plot.
</p>
</td></tr>
<tr><td><code id="plot_table_+3A_show.value">show.value</code></td>
<td>

<p>logical. Show the value of each cell in the table on the plot.
</p>
</td></tr>
<tr><td><code id="plot_table_+3A_value.cex">value.cex</code></td>
<td>

<p>Relative magnification factor if values are to be put in the cell.
</p>
</td></tr>
<tr><td><code id="plot_table_+3A_...">...</code></td>
<td>

<p>Parameters acceptable to <code><a href="graphics.html#topic+image">image</a></code> function in the <span class="pkg">graphics</span> package.
</p>
</td></tr>
<tr><td><code id="plot_table_+3A_highlight">highlight</code></td>
<td>

<p>Specify to highlight row maxima or no highlight.
When highlighted, a box is placed around each row maximum.
</p>
</td></tr>
<tr><td><code id="plot_table_+3A_highlight.col">highlight.col</code></td>
<td>

<p>The color used to highlight a cell in the table.
</p>
</td></tr>
<tr><td><code id="plot_table_+3A_mgp">mgp</code></td>
<td>

<p>The margin (in mex units) for the axis title, labels and line. See <code><a href="graphics.html#topic+par">par</a></code>.
</p>
</td></tr>
<tr><td><code id="plot_table_+3A_mar">mar</code></td>
<td>

<p>The margins of the four sides of the plot. See <code><a href="graphics.html#topic+par">par</a></code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joe Song
</p>


<h3>Examples</h3>

<pre><code class='language-R'>opar &lt;- par(mfrow=c(2,2))
plot_table(matrix(1:6, nrow=2), col="seagreen2")

plot_table(matrix(rnorm(20), nrow=5), col="orange", show.value=FALSE)

plot_table(matrix(rpois(16, 2), nrow=4), col="cornflowerblue", highlight="none")

plot_table(matrix(rbinom(15, 8, 0.5), nrow=3), col="sienna2", highlight="none")
par(opar)
</code></pre>

<hr>
<h2 id='simulate_tables'>
Simulate Noisy Contingency Tables to Represent Diverse Discrete Patterns
</h2><span id='topic+simulate_tables'></span>

<h3>Description</h3>

<p>Generate random contingency tables representing various functional, non-functional, dependent, or independent patterns, without specifying a parametric model for the patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_tables(
  n = 100, nrow = 3, ncol = 3,
  type = c("functional", "many.to.one",
           "discontinuous", "independent",
           "dependent.non.functional"),
  n.tables = 1,
  row.marginal = NULL,
  col.marginal = NULL,
  noise = 0.0, noise.model = c("house", "candle"),
  margin = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_tables_+3A_n">n</code></td>
<td>

<p>a positive integer specifying the sample size to be distributed in each table. For <code>"functional"</code>,  <code>"many.to.one"</code>, and <code>"discontinuous"</code> tables, <code>n</code> must be no less than <code>nrow</code>. For <code>"dependent.non.functional"</code> tables, <code>n</code> must be no less than <code>nrow</code>*<code>ncol</code>. For <code>"independent"</code> tables, <code>n</code> must be a positive integer.
</p>
</td></tr>
<tr><td><code id="simulate_tables_+3A_nrow">nrow</code></td>
<td>

<p>a positive integer specifying the number of rows in each table. The value must be no less than 2. For <code>"many.to.one"</code> tables, <code>nrow</code> must be no less than 3.
</p>
</td></tr>
<tr><td><code id="simulate_tables_+3A_ncol">ncol</code></td>
<td>

<p>a positive integer specifying the number of columns in output table. <code>ncol</code> must be no less than 2.
</p>
</td></tr>
<tr><td><code id="simulate_tables_+3A_type">type</code></td>
<td>

<p>a character string to specify the type of pattern underlying the table. The options are <code>"functional"</code> (default),  <code>"many.to.one"</code>, <code>"discontinuous"</code>, <code>"independent"</code>, and <code>"dependent.non.functional"</code>. See Details.
</p>
</td></tr>
<tr><td><code id="simulate_tables_+3A_n.tables">n.tables</code></td>
<td>

<p>a positive integer value specifying the number of tables to be generated.
</p>
</td></tr>
<tr><td><code id="simulate_tables_+3A_row.marginal">row.marginal</code></td>
<td>

<p>a non-negative numeric vector of length <code>nrow</code> specifying row marginal probabilities. The vector is linearly scaled so that the sum is 1. The default is a uniform distribution.

</p>
</td></tr>
<tr><td><code id="simulate_tables_+3A_col.marginal">col.marginal</code></td>
<td>

<p>a non-negative numeric vector of length <code>ncol</code> specifying column marginal probabilities. The vector is linearly scaled so that the sum is 1.
This argument is ignored by <code>"dependent.non.functional"</code> tables.

</p>
</td></tr>
<tr><td><code id="simulate_tables_+3A_noise">noise</code></td>
<td>

<p>a numeric value between 0 and 1 specifying the noise level to be added to a table using function <code><a href="#topic+add.noise">add.noise</a></code>. The noise can be applied along row, column, or both, which can be specified by the <code>margin</code> argument. See <code><a href="#topic+add.noise">add.noise</a></code> for details.
</p>
</td></tr>
<tr><td><code id="simulate_tables_+3A_noise.model">noise.model</code></td>
<td>

<p>a character string indicating the noise model of either <code>"house"</code> for ordinal variables (Zhang et al. 2015) or <code>"candle"</code> for categorical variables. See <code><a href="#topic+add.noise">add.noise</a></code> for details.
</p>
</td></tr>
<tr><td><code id="simulate_tables_+3A_margin">margin</code></td>
<td>

<p>a numeric value of either 0, 1 or 2. Default is 0.
0: noise is applied along both rows and columns.
1: noise is applied along each row.
2: noise is applied along each column.
See <code><a href="#topic+add.noise">add.noise</a></code> for details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates five types of table representing different interaction patterns between row and column discrete random variables <code class="reqn">X</code> and <code class="reqn">Y</code>. Three of the five types are non-constant functional patterns (<code class="reqn">Y</code> is a non-constant function of <code class="reqn">X</code>):
</p>
<p><code>type="functional"</code>: <code class="reqn">Y</code> is a function of <code class="reqn">X</code> but <code class="reqn">X</code> may or may not be a function of <code class="reqn">Y</code>.
</p>
<p><code>type="many.to.one"</code>: <code class="reqn">Y</code> is a many-to-one function of <code class="reqn">X</code> but <code class="reqn">X</code> is not a function of <code class="reqn">Y</code>.
</p>
<p><code>type="discontinuous"</code>: <code class="reqn">Y</code> is a function of <code class="reqn">X</code>, where the function value of X must differ from its neighbors. <code class="reqn">X</code> may or may not be a function of <code class="reqn">Y</code>. A discontinuous function forms a contrast with those that are close to constant functions.
</p>
<p>The fourth <code>type</code> <code>"dependent.non.functional"</code> is non-functional patterns where <code class="reqn">X</code> and <code class="reqn">Y</code> are statistically dependent but not function of each other. The samples are distributed according to <code>row.marginal</code> probabilities.
</p>
<p>The fifth <code>type</code> <code>"independent"</code> represents patterns where <code class="reqn">X</code> and <code class="reqn">Y</code> are statistically independent whose joint probability mass function is the product of their marginal probability mass functions.
</p>
<p>For all functional tables (<code>type="functional"</code>, <code>type="many.to.one"</code>, <code>type="discontinuous"</code>), the samples are distributed using either the given row or column marginal probabilities. Theoretically, it is not always possible to enforce both marginals in a functional pattern. If both marginals are provided, one will be randomly selected to generate a table; about half of the time each equested marginal is used. If neither is provided, either row or column uniform marginal will be randomly selected to generate a table; half of the time a table will have a uniform row marginal and the other half a uniform column marginal.
</p>
<p>Random noise can be optionally applied to the tables using either the house or the candle noise model. See <code><a href="#topic+add.noise">add.noise</a></code> for details.
</p>
<p>Sharma et al. (2017) provide full mathematical and statistical details of the simulation strategies for the above table types except the <code>"discontinuous"</code> type which was introduced after the publication.
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr><td><code>pattern.list</code></td>
<td>
<p>a list of tables containing binary patterns in 0's and 1's. Each table is created by setting all non-zero entries in the corresponding sampled contingency table from <code>sample.list</code> to 1. Each table strictly satisfies the  mathematical relationship required for a given pattern <code>type</code> requested, but it does not meet the statistical requirements. As each table represents the truth regarding the mathematical relationship between the row and column variables, they can be used as the ground truth or gold standard for benchmarking.</p>
</td></tr>
<tr><td><code>sample.list</code></td>
<td>
<p>a list of tables satisfying both the mathematical and statistical requirements. These tables are noise free.</p>
</td></tr>
<tr><td><code>noise.list</code></td>
<td>
<p>a list of tables after applying noise to the corresponding tables in <code>sample.list</code>. Each table is the noisy version of the corresponding sampled contingency table. Due to the added noise, each table may no longer strictly satisfy the required mathematical or statistical relationships. These tables are the main output to be used for the evaluation of a discrete pattern discovery algorithm.</p>
</td></tr>
<tr><td><code>pvalue.list</code></td>
<td>
<p>a list of p-values reporting the statistical significance of the generated tables for the required type. When the pattern type specifies a functional relationship, the p-values are computed by the functional chi-square test (Zhang and Song 2013); otherwise, the Pearson's chi-square test of independence is used to calculate the p-value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ruby Sharma, Sajal Kumar, Hua Zhong, and Joe Song
</p>


<h3>References</h3>

<p>Sharma R, Kumar S, Zhong H, Song M (2017).
&ldquo;Simulating noisy, nonparametric, and multivariate discrete patterns.&rdquo;
<em>The R Journal</em>, <b>9</b>(2), 366&ndash;377.
<a href="https://doi.org/10.32614/RJ-2017-053">doi:10.32614/RJ-2017-053</a>.<br /><br /> Zhang Y, Liu ZL, Song M (2015).
&ldquo;ChiNet uncovers rewired transcription subnetworks in tolerant yeast for advanced biofuels conversion.&rdquo;
<em>Nucleic Acids Research</em>, <b>43</b>(9), 4393&ndash;4407.
<a href="https://doi.org/10.1093/nar/gkv358">doi:10.1093/nar/gkv358</a>.<br /><br /> Zhang Y, Song M (2013).
&ldquo;Deciphering interactions in causal networks without parametric assumptions.&rdquo;
<em>arXiv Molecular Networks</em>, arXiv:1311.2707.
<a href="https://arxiv.org/abs/1311.2707">https://arxiv.org/abs/1311.2707</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add.noise">add.noise</a></code> for details of the noise model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# In all examples, x is the row variable and y is the column
#    variable of a table.

# Example 1. Simulating a noisy function where y=f(x),
#            x may or may not be g(y) with given row.marginal.

tbls &lt;- simulate_tables(n=100, nrow=4, ncol=5, type="functional",
                noise=0.2, n.tables = 1,
                row.marginal = c(0.3,0.2,0.3,0.2))

par(mfrow=c(2,2))
plot_table(tbls$pattern.list[[1]], main="Ex 1. Functional pattern")
plot_table(tbls$sample.list[[1]], main="Ex 1. Sampled pattern (noise free)")
plot_table(tbls$noise.list[[1]], main="Ex 1. Sampled pattern with 0.2 noise")
plot.new()

# Example 2. Simulating a noisy functional pattern where
#            y=f(x), x may or may not be g(y) with given row.marginal.

tbls &lt;- simulate_tables(n=100, nrow=4, ncol=5, type="functional",
                noise=0.5, n.tables = 1,
                row.marginal = c(0.3,0.2,0.3,0.2))

par(mfrow=c(2,2))
plot_table(tbls$pattern.list[[1]], main="Ex 2. Functioal pattern", col="seagreen2")
plot_table(tbls$sample.list[[1]], main="Ex 2. Sampled pattern (noise free)", col="seagreen2")
plot_table(tbls$noise.list[[1]], main="Ex 2. Sampled pattern with 0.5 noise", col="seagreen2")
plot.new()


# Example 3. Simulating a noisy many.to.one function where
#            y=f(x), x!=f(y) with given row.marginal.

tbls &lt;- simulate_tables(n=100, nrow=4, ncol=5, type="many.to.one",
                noise=0.2, n.tables = 1,
                row.marginal = c(0.4,0.3,0.1,0.2))
par(mfrow=c(2,2))
plot_table(tbls$pattern.list[[1]], main="Ex 3. Many-to-one pattern", col="limegreen")
plot_table(tbls$sample.list[[1]], main="Ex 3. Sampled pattern (noise free)", col="limegreen")
plot_table(tbls$noise.list[[1]], main="Ex 3. Sampled pattern with 0.2 noise", col="limegreen")
plot.new()

# Example 4. Simulating noisy discontinuous
#   pattern where y=f(x), x may or may not be g(y) with given row.marginal.

tbls &lt;- simulate_tables(n=100, nrow=4, ncol=5,
                type="discontinuous", noise=0.2,
                n.tables = 1, row.marginal = c(0.2,0.4,0.2,0.2))

par(mfrow=c(2,2))
plot_table(tbls$pattern.list[[1]], main="Ex 4. Discontinuous pattern", col="springgreen3")
plot_table(tbls$sample.list[[1]], main="Ex 4. Sampled pattern (noise free)", col="springgreen3")
plot_table(tbls$noise.list[[1]], main="Ex 4. Sampled pattern with 0.2 noise", col="springgreen3")
plot.new()


# Example 5. Simulating noisy dependent.non.functional
#            pattern where y!=f(x) and x and y are statistically
#            dependent.

tbls &lt;- simulate_tables(n=100, nrow=4, ncol=5,
                type="dependent.non.functional", noise=0.3,
                n.tables = 1, row.marginal = c(0.2,0.4,0.2,0.2))

par(mfrow=c(2,2))
plot_table(tbls$pattern.list[[1]], main="Ex 5. Dependent.non.functional pattern",
col="sienna2", highlight="none")
plot_table(tbls$sample.list[[1]], main="Ex 5. Sampled pattern (noise free)",
col="sienna2", highlight="none")
plot_table(tbls$noise.list[[1]], main="Ex 5. Sampled pattern with 0.3 noise",
col="sienna2", highlight="none")
plot.new()

# Example 6. Simulating a pattern where x and y are
#            statistically independent.

tbls &lt;- simulate_tables(n=100, nrow=4, ncol=5, type="independent",
                noise=0.3, n.tables = 1,
                row.marginal = c(0.4,0.3,0.1,0.2),
                col.marginal = c(0.1,0.2,0.4,0.2,0.1))

par(mfrow=c(2,2))
plot_table(tbls$pattern.list[[1]], main="Ex 6. Independent pattern",
col="cornflowerblue", highlight="none")
plot_table(tbls$sample.list[[1]], main="Ex 6. Sampled pattern (noise free)",
col="cornflowerblue", highlight="none")
plot_table(tbls$noise.list[[1]], main="Ex 6. Sampled pattern with 0.3 noise",
col="cornflowerblue", highlight="none")
plot.new()


# Example 7. Simulating a noisy function where y=f(x),
#            x may or may not be g(y), with given column marginal


tbls &lt;- simulate_tables(n=100, nrow=4, ncol=5, type="functional",
                noise=0.2, n.tables = 1,
                col.marginal = c(0.2,0.1,0.4,0.2,0.1))

par(mfrow=c(2,2))
plot_table(tbls$pattern.list[[1]], main="Ex 7. Functional pattern")
plot_table(tbls$sample.list[[1]], main="Ex 7. Sampled pattern (noise free)")
plot_table(tbls$noise.list[[1]], main="Ex 7. Sampled pattern with 0.2 noise")
plot.new()


# Example 8. Simulating a noisy many.to.one function where
#            y=f(x), x!=f(y) with given column marginal.

tbls &lt;- simulate_tables(n=100, nrow=4, ncol=4, type="many.to.one",
                noise=0.2, n.tables = 1,
                col.marginal = c(0.4,0.3,0.1,0.2))
par(mfrow=c(2,2))
plot_table(tbls$pattern.list[[1]], main="Ex 8. Many-to-one pattern", col="limegreen")
plot_table(tbls$sample.list[[1]], main="Ex 8. Sampled pattern (noise free)", col="limegreen")
plot_table(tbls$noise.list[[1]], main="Ex 8. Sampled pattern with 0.2 noise", col="limegreen")
plot.new()


# Example 9. Simulating noisy discontinuous
#   pattern where y=f(x), x may or may not be g(y) with given column marginal

tbls &lt;- simulate_tables(n=100, nrow=4, ncol=4,
                type="discontinuous", noise=0.2,
                n.tables = 1, col.marginal = c(0.1,0.4,0.2,0.3))

par(mfrow=c(2,2))
plot_table(tbls$pattern.list[[1]], main="Ex 9. Discontinuous pattern", col="springgreen3")
plot_table(tbls$sample.list[[1]], main="Ex 9. Sampled pattern (noise free)", col="springgreen3")
plot_table(tbls$noise.list[[1]], main="Ex 9. Sampled pattern with 0.2 noise", col="springgreen3")
plot.new()






</code></pre>

<hr>
<h2 id='test.interactions'>Functional Chi-Squared Test of Functional Dependency among Many Variables in a Data Set
</h2><span id='topic+test.interactions'></span>

<h3>Description</h3>

<p>Apply functional chi-squared tests on many-to-one combinatorial relationships for functional dependency using multivariate discrete data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.interactions(
  x, list.ind.vars, dep.vars, var.names = rownames(x),
  index.kind = c("conditional", "unconditional")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test.interactions_+3A_x">x</code></td>
<td>

<p>A numeric matrix or data frame of discrete values. Rows represent variables and columns represent samples. Thus, each row index is a variable index, used by <code>list.ind.vars</code> and <code>dep.vars</code>.
</p>
</td></tr>
<tr><td><code id="test.interactions_+3A_list.ind.vars">list.ind.vars</code></td>
<td>

<p>A list of numeric or integer vectors, each vector representing independent variable indices in one interaction. Each vector (parents) forms a pair with a dependent variable (child) of the same position in <code>dep.vars</code> to represent a many-to-one directional interaction.
</p>
</td></tr>
<tr><td><code id="test.interactions_+3A_dep.vars">dep.vars</code></td>
<td>

<p>A numeric vector representing indices of dependent variables (children) in multiple interactions.
</p>
</td></tr>
<tr><td><code id="test.interactions_+3A_var.names">var.names</code></td>
<td>

<p>Optional. A character vector specifying names of all variables (rows). If not provided, the default is the row names of <code>x</code>; or <code>1:nrow(x)</code> if <code>x</code> does not have row names.
</p>
</td></tr>
<tr><td><code id="test.interactions_+3A_index.kind">index.kind</code></td>
<td>

<p>A character string to specify the kind of function index to return, identical to the same argument in <code>fun.chisq.test</code>. The value can be <code>"unconditional"</code> (default) or <code>"conditional"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>test.interactions</code> tests functional dependencies in multiple directional interactions. Each interaction, either one-to-one or many-to-one, is a parents-child pair representing a relationship from independent variables (parents) to a dependent variable (child). The parents-child pairs are specified in two input arguments <code>list.ind.vars</code> (a list of parents for each interaction) and <code>dep.vars</code> (vector of children in each interaction).
</p>
<p>The function automatically creates contingency tables for interactions of interest, thus convenient to use on multivariate data sets. As the function is implemented in C++ and capable of testing multiple many-to-one interactions in one call, it is much faster than calling the R function <code>fun.chisq.test</code> multiple times.
</p>
<p><code>test.interactions</code> implements only the <code>method="fchisq"</code> option in <code>fun.chisq.test</code>.
</p>
<p>When a contingency table is created for each interaction, all combinations of unique values of the independent variables (parents) form the rows and the unique values of dependent variable (child) form the columns in the contingency table. The table entries are the counts of the corresponding combination of parent and child values. Either rows or columns with all zero counts are removed from the contingency table before functional chi-squared test is applied.
</p>


<h3>Value</h3>

<p>A data frame with five columns. Each row represents the testing result of each directional interaction. The 1st column is either the indices or names (if <code>var.names</code> is not <code>NULL</code>) of independent variables (parents); The 2nd column is the indices or names of the dependent variable (child); The 3rd column named <code>p.value</code> are p-values; The 4th column named <code>statistic</code> is chi-squared values; and the 5th column named <code>estimate</code> is the function indices for each interaction.
</p>


<h3>Author(s)</h3>

<p>Hua Zhong and Joe Song
</p>


<h3>See Also</h3>

<p>This function calls functional chi-squared test implemented in C++ and is thus much faster than the R version <code><a href="#topic+fun.chisq.test">fun.chisq.test</a></code>.
</p>
<p>For data discretization by optimal univariate <var>k</var>-means clustering, see <span class="pkg">Ckmeans.1d.dp</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(
  c(0,0,1,0,1,
    1,0,2,1,0,
    2,2,0,0,0,
    1,2,1,1,2,
    1,0,2,1,2),
  nrow = 5, ncol = 5, byrow = TRUE)

list.ind.vars &lt;-list(
  c(1),c(1),c(1),
  c(2),c(2),c(2),
  c(1,2), c(2,3),
  c(3,4), c(4,5))
dep.vars &lt;- c(
  3,4,5,
  3,4,5,
  3,4,
  5,1)

# list.ind.vars and dep.vars together specify
#   the following ten interactions:
#   1 -&gt; 3
#   1 -&gt; 4
#   1 -&gt; 5
#   2 -&gt; 3
#   2 -&gt; 4
#   2 -&gt; 5
# 1,2 -&gt; 3
# 2,3 -&gt; 4
# 3,4 -&gt; 5
# 4,5 -&gt; 1

var.names &lt;- paste0("var", 1:5)

test.interactions(
  x = x,
  list.ind.vars = list.ind.vars,
  dep.vars = dep.vars,
  var.names = var.names,
  index.kind = "unconditional")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
