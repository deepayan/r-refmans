<!DOCTYPE html><html lang="en"><head><title>Help for package secsse</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {secsse}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#secsse-package'><p>secsse: Several Examined and Concealed States-Dependent Speciation and Extinction</p></a></li>
<li><a href='#cla_id_paramPos'><p>Parameter structure setting for cla_secsse</p>
It sets the parameters (speciation, extinction and transition)
IDs. Needed for ML calculation with cladogenetic options (cla_secsse_ml)</a></li>
<li><a href='#cla_secsse_loglik'><p>Likelihood for SecSSE model, using Rcpp</p>
Loglikelihood calculation for the cla_SecSSE model given a set of parameters
and data using Rcpp</a></li>
<li><a href='#cla_secsse_ml'><p>Maximum likehood estimation for (SecSSE)</p></a></li>
<li><a href='#cla_secsse_ml_func_def_pars'><p>Maximum likehood estimation for (SecSSE) with parameter as complex</p>
functions. Cladogenetic version</a></li>
<li><a href='#create_default_lambda_transition_matrix'><p>Helper function to create a default lambda list</p></a></li>
<li><a href='#create_default_shift_matrix'><p>Helper function to create a default <code>shift_matrix</code> list</p></a></li>
<li><a href='#create_lambda_list'><p>Helper function to automatically create lambda matrices, based on input</p></a></li>
<li><a href='#create_mu_vector'><p>Generate mus vector</p></a></li>
<li><a href='#create_q_matrix'><p>Helper function to neatly setup a Q matrix, without transitions to</p>
concealed states (only observed transitions shown)</a></li>
<li><a href='#default_params_doc'><p>Default parameter documentation</p></a></li>
<li><a href='#event_times'><p>Event times of a (possibly non-ultrametric) phylogenetic tree</p></a></li>
<li><a href='#example_phy_GeoSSE'><p>A phylogeny with traits at the tips</p></a></li>
<li><a href='#expand_q_matrix'><p>Function to expand an existing q_matrix to a number of concealed states</p></a></li>
<li><a href='#extract_par_vals'><p>Extract parameter values out of the result of a maximum likelihood inference</p>
run</a></li>
<li><a href='#fill_in'><p>Helper function to enter parameter value on their right place</p></a></li>
<li><a href='#id_paramPos'><p>Parameter structure setting</p>
Sets the parameters (speciation, extinction and transition) ids. Needed for
ML calculation (<code>secsse_ml()</code>).</a></li>
<li><a href='#phylo_vignette'><p>A phylogenetic reconstuction to run the vignette</p></a></li>
<li><a href='#plot_state_exact'><p>Plot the local probability along a tree</p></a></li>
<li><a href='#prepare_full_lambdas'><p>Prepares the entire set of lambda matrices for cla_secsse.</p>
It provides the set of matrices containing all the speciation rates</a></li>
<li><a href='#q_doubletrans'><p>Basic Qmatrix</p>
Sets a Q matrix where double transitions are not allowed</a></li>
<li><a href='#secsse_loglik'><p>Likelihood for SecSSE model</p>
Loglikelihood calculation for the SecSSE model given a set of parameters and
data</a></li>
<li><a href='#secsse_loglik_eval'><p>Likelihood for SecSSE model</p>
Logikelihood calculation for the SecSSE model given a set of parameters and
data, returning also the likelihoods along the branches</a></li>
<li><a href='#secsse_ml'><p>Maximum likehood estimation for (SecSSE)</p></a></li>
<li><a href='#secsse_ml_func_def_pars'><p>Maximum likehood estimation for (SecSSE) with parameter as complex</p>
functions.</a></li>
<li><a href='#secsse_sim'><p>Function to simulate a tree, conditional on observing all states.</p></a></li>
<li><a href='#sortingtraits'><p>Data checking and trait sorting</p>
In preparation for likelihood calculation, it orders trait data according
the tree tips</a></li>
<li><a href='#traits'><p>A table with trait info to run the vignette</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Several Examined and Concealed States-Dependent Speciation and
Extinction</td>
</tr>
<tr>
<td>Version:</td>
<td>3.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-04-26</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a> | file LICENSE</td>
</tr>
<tr>
<td>Description:</td>
<td>Simultaneously infers state-dependent diversification across
 two or more states of a single or multiple traits while accounting for the
 role of a possible concealed trait. See Herrera-Alsina et al. (2019)
 &lt;<a href="https://doi.org/10.1093%2Fsysbio%2Fsyy057">doi:10.1093/sysbio/syy057</a>&gt;.  </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, DDD (&ge; 5.0), ape, geiger, Rcpp (&ge; 1.0.10),
RcppParallel, ggplot2, tibble, rlang, treestats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>diversitree, phytools, testthat, subplex, knitr, rmarkdown</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppParallel, BH (&ge; 1.81.0-1)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://rsetienne.github.io/secsse/">https://rsetienne.github.io/secsse/</a>,
<a href="https://github.com/rsetienne/secsse">https://github.com/rsetienne/secsse</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rsetienne/secsse/issues">https://github.com/rsetienne/secsse/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-30 12:02:13 UTC; rampa</td>
</tr>
<tr>
<td>Author:</td>
<td>Leonel Herrera Alsina
    <a href="https://orcid.org/0000-0003-0474-3592"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Paul van Els <a href="https://orcid.org/0000-0002-9499-8873"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Thijs Janzen <a href="https://orcid.org/0000-0002-4162-1140"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Hanno Hildenbrandt
    <a href="https://orcid.org/0000-0002-6784-1037"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Pedro Santos Neves
    <a href="https://orcid.org/0000-0003-2561-4677"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Rampal S. Etienne <a href="https://orcid.org/0000-0003-2142-7612"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rampal S. Etienne &lt;r.s.etienne@rug.nl&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-30 20:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='secsse-package'>secsse: Several Examined and Concealed States-Dependent Speciation and Extinction</h2><span id='topic+secsse'></span><span id='topic+secsse-package'></span>

<h3>Description</h3>

<p>Simultaneously infers state-dependent diversification across two or more states of a single or multiple traits while accounting for the role of a possible concealed trait. See Herrera-Alsina et al. (2019) <a href="https://doi.org/10.1093/sysbio/syy057">doi:10.1093/sysbio/syy057</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Rampal S. Etienne <a href="mailto:r.s.etienne@rug.nl">r.s.etienne@rug.nl</a> (<a href="https://orcid.org/0000-0003-2142-7612">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Leonel Herrera Alsina <a href="mailto:leonelhalsina@gmail.com">leonelhalsina@gmail.com</a> (<a href="https://orcid.org/0000-0003-0474-3592">ORCID</a>)
</p>
</li>
<li><p> Paul van Els <a href="mailto:paulvanels@gmail.com">paulvanels@gmail.com</a> (<a href="https://orcid.org/0000-0002-9499-8873">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Thijs Janzen <a href="mailto:t.janzen@rug.nl">t.janzen@rug.nl</a> (<a href="https://orcid.org/0000-0002-4162-1140">ORCID</a>) [contributor]
</p>
</li>
<li><p> Hanno Hildenbrandt <a href="mailto:h.hildenbrandt@rug.nl">h.hildenbrandt@rug.nl</a> (<a href="https://orcid.org/0000-0002-6784-1037">ORCID</a>) [contributor]
</p>
</li>
<li><p> Pedro Santos Neves <a href="mailto:p.m.santos.neves@rug.nl">p.m.santos.neves@rug.nl</a> (<a href="https://orcid.org/0000-0003-2561-4677">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://rsetienne.github.io/secsse/">https://rsetienne.github.io/secsse/</a>
</p>
</li>
<li> <p><a href="https://github.com/rsetienne/secsse">https://github.com/rsetienne/secsse</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/rsetienne/secsse/issues">https://github.com/rsetienne/secsse/issues</a>
</p>
</li></ul>


<hr>
<h2 id='cla_id_paramPos'>Parameter structure setting for cla_secsse
It sets the parameters (speciation, extinction and transition)
IDs. Needed for ML calculation with cladogenetic options (cla_secsse_ml)</h2><span id='topic+cla_id_paramPos'></span>

<h3>Description</h3>

<p>Parameter structure setting for cla_secsse
It sets the parameters (speciation, extinction and transition)
IDs. Needed for ML calculation with cladogenetic options (cla_secsse_ml)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cla_id_paramPos(traits, num_concealed_states)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cla_id_paramPos_+3A_traits">traits</code></td>
<td>
<p>vector with trait states for each tip in the phylogeny. The
order of the states must be the same as the tree tips. For help, see
<code>vignette("starting_secsse", package = "secsse")</code>.</p>
</td></tr>
<tr><td><code id="cla_id_paramPos_+3A_num_concealed_states">num_concealed_states</code></td>
<td>
<p>number of concealed states, generally equivalent
to the number of examined states in the dataset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list that includes the ids of the parameters for ML analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>traits &lt;- sample(c(0,1,2), 45,replace = TRUE) #get some traits
num_concealed_states &lt;- 3
param_posit &lt;- cla_id_paramPos(traits, num_concealed_states)
</code></pre>

<hr>
<h2 id='cla_secsse_loglik'>Likelihood for SecSSE model, using Rcpp
Loglikelihood calculation for the cla_SecSSE model given a set of parameters
and data using Rcpp</h2><span id='topic+cla_secsse_loglik'></span>

<h3>Description</h3>

<p>Likelihood for SecSSE model, using Rcpp
Loglikelihood calculation for the cla_SecSSE model given a set of parameters
and data using Rcpp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cla_secsse_loglik(
  parameter,
  phy,
  traits,
  num_concealed_states,
  cond = "proper_cond",
  root_state_weight = "proper_weights",
  sampling_fraction,
  setting_calculation = NULL,
  see_ancestral_states = FALSE,
  loglik_penalty = 0,
  is_complete_tree = FALSE,
  num_threads = 1,
  method = "odeint::bulirsch_stoer",
  atol = 1e-08,
  rtol = 1e-07
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cla_secsse_loglik_+3A_parameter">parameter</code></td>
<td>
<p>list where first vector represents lambdas, the second
mus and the third transition rates.</p>
</td></tr>
<tr><td><code id="cla_secsse_loglik_+3A_phy">phy</code></td>
<td>
<p>phylogenetic tree of class <code>phylo</code>, rooted and with
branch lengths.</p>
</td></tr>
<tr><td><code id="cla_secsse_loglik_+3A_traits">traits</code></td>
<td>
<p>vector with trait states for each tip in the phylogeny. The
order of the states must be the same as the tree tips. For help, see
<code>vignette("starting_secsse", package = "secsse")</code>.</p>
</td></tr>
<tr><td><code id="cla_secsse_loglik_+3A_num_concealed_states">num_concealed_states</code></td>
<td>
<p>number of concealed states, generally equivalent
to the number of examined states in the dataset.</p>
</td></tr>
<tr><td><code id="cla_secsse_loglik_+3A_cond">cond</code></td>
<td>
<p>condition on the existence of a node root: <code>"maddison_cond"</code>,
<code>"proper_cond"</code> (default). For details, see vignette.</p>
</td></tr>
<tr><td><code id="cla_secsse_loglik_+3A_root_state_weight">root_state_weight</code></td>
<td>
<p>the method to weigh the states:
<code>"maddison_weights"</code>, <code>"proper_weights"</code> (default) or <code>"equal_weights"</code>.
It can also be specified for the root state: the vector <code>c(1, 0, 0)</code>
indicates state 1 was the root state.</p>
</td></tr>
<tr><td><code id="cla_secsse_loglik_+3A_sampling_fraction">sampling_fraction</code></td>
<td>
<p>vector that states the sampling proportion per
trait state. It must have as many elements as there are trait states.</p>
</td></tr>
<tr><td><code id="cla_secsse_loglik_+3A_setting_calculation">setting_calculation</code></td>
<td>
<p>argument used internally to speed up calculation.
It should be left blank (default : <code>setting_calculation = NULL</code>).</p>
</td></tr>
<tr><td><code id="cla_secsse_loglik_+3A_see_ancestral_states">see_ancestral_states</code></td>
<td>
<p>Boolean for whether the ancestral states should
be shown? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cla_secsse_loglik_+3A_loglik_penalty">loglik_penalty</code></td>
<td>
<p>the size of the penalty for all parameters; default is
0 (no penalty).</p>
</td></tr>
<tr><td><code id="cla_secsse_loglik_+3A_is_complete_tree">is_complete_tree</code></td>
<td>
<p>logical specifying whether or not a tree with all its
extinct species is provided. If set to <code>TRUE</code>, it also assumes that all
<em>all</em> extinct lineages are present on the tree. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cla_secsse_loglik_+3A_num_threads">num_threads</code></td>
<td>
<p>number of threads to be used. Default is one thread.</p>
</td></tr>
<tr><td><code id="cla_secsse_loglik_+3A_method">method</code></td>
<td>
<p>integration method used, available are:
<code>"odeint::runge_kutta_cash_karp54"</code>, <code>"odeint::runge_kutta_fehlberg78"</code>,
<code>"odeint::runge_kutta_dopri5"</code>, <code>"odeint::bulirsch_stoer"</code> and
<code>"odeint::runge_kutta4"</code>. Default method is: <code>"odeint::bulirsch_stoer"</code>.</p>
</td></tr>
<tr><td><code id="cla_secsse_loglik_+3A_atol">atol</code></td>
<td>
<p>A numeric specifying the absolute tolerance of integration.</p>
</td></tr>
<tr><td><code id="cla_secsse_loglik_+3A_rtol">rtol</code></td>
<td>
<p>A numeric specifying the relative tolerance of integration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The loglikelihood of the data given the parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rm(list=ls(all=TRUE))
library(secsse)
set.seed(13)
phylotree &lt;- ape::rcoal(12, tip.label = 1:12)
traits &lt;- sample(c(0,1,2),ape::Ntip(phylotree),replace=TRUE)
num_concealed_states &lt;- 3
sampling_fraction &lt;- c(1,1,1)
phy &lt;- phylotree
# the idparlist for a ETD model (dual state inheritance model of evolution)
# would be set like this:
idparlist &lt;- cla_id_paramPos(traits,num_concealed_states)
lambd_and_modeSpe &lt;- idparlist$lambdas
lambd_and_modeSpe[1,] &lt;- c(1,1,1,2,2,2,3,3,3)
idparlist[[1]] &lt;- lambd_and_modeSpe
idparlist[[2]][] &lt;- 0
masterBlock &lt;- matrix(4,ncol=3,nrow=3,byrow=TRUE)
diag(masterBlock) &lt;- NA
idparlist [[3]] &lt;- q_doubletrans(traits,masterBlock,diff.conceal = FALSE)
# Now, internally, clasecsse sorts the lambda matrices, so they look like:
prepare_full_lambdas(traits,num_concealed_states,idparlist[[1]])
# which is a list with 9 matrices, corresponding to the 9 states
# (0A,1A,2A,0B,etc)
# if we want to calculate a single likelihood:
parameter &lt;- idparlist
lambda_and_modeSpe &lt;- parameter$lambdas
lambda_and_modeSpe[1,] &lt;- c(0.2,0.2,0.2,0.4,0.4,0.4,0.01,0.01,0.01)
parameter[[1]] &lt;- prepare_full_lambdas(traits,num_concealed_states,
lambda_and_modeSpe)
parameter[[2]] &lt;- rep(0,9)
masterBlock &lt;- matrix(0.07, ncol=3, nrow=3, byrow=TRUE)
diag(masterBlock) &lt;- NA
parameter [[3]] &lt;- q_doubletrans(traits,masterBlock,diff.conceal = FALSE)
cla_secsse_loglik(parameter, phy, traits, num_concealed_states,
                 cond = 'maddison_cond',
                 root_state_weight = 'maddison_weights', sampling_fraction,
                 setting_calculation = NULL,
                 see_ancestral_states = FALSE,
                 loglik_penalty = 0)
# LL = -42.18407
</code></pre>

<hr>
<h2 id='cla_secsse_ml'>Maximum likehood estimation for (SecSSE)</h2><span id='topic+cla_secsse_ml'></span>

<h3>Description</h3>

<p>Maximum likehood estimation under Several examined and concealed
States-dependent Speciation and Extinction (SecSSE) with cladogenetic option
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cla_secsse_ml(
  phy,
  traits,
  num_concealed_states,
  idparslist,
  idparsopt,
  initparsopt,
  idparsfix,
  parsfix,
  cond = "proper_cond",
  root_state_weight = "proper_weights",
  sampling_fraction,
  tol = c(1e-04, 1e-05, 1e-07),
  maxiter = 1000 * round((1.25)^length(idparsopt)),
  optimmethod = "subplex",
  num_cycles = 1,
  loglik_penalty = 0,
  is_complete_tree = FALSE,
  verbose = (optimmethod == "simplex"),
  num_threads = 1,
  atol = 1e-08,
  rtol = 1e-07,
  method = "odeint::bulirsch_stoer"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cla_secsse_ml_+3A_phy">phy</code></td>
<td>
<p>phylogenetic tree of class <code>phylo</code>, rooted and with
branch lengths.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_+3A_traits">traits</code></td>
<td>
<p>vector with trait states for each tip in the phylogeny. The
order of the states must be the same as the tree tips. For help, see
<code>vignette("starting_secsse", package = "secsse")</code>.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_+3A_num_concealed_states">num_concealed_states</code></td>
<td>
<p>number of concealed states, generally equivalent
to the number of examined states in the dataset.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_+3A_idparslist">idparslist</code></td>
<td>
<p>overview of parameters and their values.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_+3A_idparsopt">idparsopt</code></td>
<td>
<p>a numeric vector with the ID of parameters to be estimated.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_+3A_initparsopt">initparsopt</code></td>
<td>
<p>a numeric vector with the initial guess of the parameters
to be estimated.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_+3A_idparsfix">idparsfix</code></td>
<td>
<p>a numeric vector with the ID of the fixed parameters.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_+3A_parsfix">parsfix</code></td>
<td>
<p>a numeric vector with the value of the fixed parameters.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_+3A_cond">cond</code></td>
<td>
<p>condition on the existence of a node root: <code>"maddison_cond"</code>,
<code>"proper_cond"</code> (default). For details, see vignette.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_+3A_root_state_weight">root_state_weight</code></td>
<td>
<p>the method to weigh the states:
<code>"maddison_weights"</code>, <code>"proper_weights"</code> (default) or <code>"equal_weights"</code>.
It can also be specified for the root state: the vector <code>c(1, 0, 0)</code>
indicates state 1 was the root state.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_+3A_sampling_fraction">sampling_fraction</code></td>
<td>
<p>vector that states the sampling proportion per
trait state. It must have as many elements as there are trait states.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_+3A_tol">tol</code></td>
<td>
<p>A numeric vector with the maximum tolerance of the optimization
algorithm. Default is <code>c(1e-04, 1e-05, 1e-05)</code>.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_+3A_maxiter">maxiter</code></td>
<td>
<p>max number of iterations. Default is
<code>1000 * round((1.25) ^ length(idparsopt))</code>.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_+3A_optimmethod">optimmethod</code></td>
<td>
<p>A string with method used for optimization. Default is
<code>"subplex"</code>. Alternative is <code>"simplex"</code> and it shouldn't be used in normal
conditions (only for debugging). Both are called from <code><a href="DDD.html#topic+optimizer">DDD::optimizer()</a></code>,
simplex is implemented natively in <a href="DDD.html#topic+DDD">DDD</a>, while subplex is ultimately
called from <code><a href="subplex.html#topic+subplex">subplex::subplex()</a></code>.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_+3A_num_cycles">num_cycles</code></td>
<td>
<p>Number of cycles of the optimization. When set to <code>Inf</code>,
the optimization will be repeated until the result is, within the
tolerance, equal to the starting values, with a maximum of 10 cycles.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_+3A_loglik_penalty">loglik_penalty</code></td>
<td>
<p>the size of the penalty for all parameters; default is
0 (no penalty).</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_+3A_is_complete_tree">is_complete_tree</code></td>
<td>
<p>logical specifying whether or not a tree with all its
extinct species is provided. If set to <code>TRUE</code>, it also assumes that all
<em>all</em> extinct lineages are present on the tree. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_+3A_verbose">verbose</code></td>
<td>
<p>sets verbose output; default is <code>TRUE</code> when <code>optimmethod</code> is
<code>"simplex"</code>. If <code>optimmethod</code> is set to <code>"simplex"</code>, then even if set to
<code>FALSE</code>, optimizer output will be shown.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_+3A_num_threads">num_threads</code></td>
<td>
<p>number of threads to be used. Default is one thread.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_+3A_atol">atol</code></td>
<td>
<p>A numeric specifying the absolute tolerance of integration.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_+3A_rtol">rtol</code></td>
<td>
<p>A numeric specifying the relative tolerance of integration.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_+3A_method">method</code></td>
<td>
<p>integration method used, available are:
<code>"odeint::runge_kutta_cash_karp54"</code>, <code>"odeint::runge_kutta_fehlberg78"</code>,
<code>"odeint::runge_kutta_dopri5"</code>, <code>"odeint::bulirsch_stoer"</code> and
<code>"odeint::runge_kutta4"</code>. Default method is: <code>"odeint::bulirsch_stoer"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Parameter estimated and maximum likelihood
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example of how to set the arguments for a ML search.
library(secsse)
library(DDD)
set.seed(13)
# Check the vignette for a better working exercise.
# lambdas for 0A and 1A and 2A are the same but need to be estimated
# (CTD model, see Syst Biol paper)
# mus are fixed to zero,
# the transition rates are constrained to be equal and fixed 0.01
phylotree &lt;- ape::rcoal(31, tip.label = 1:31)
#get some traits
traits &lt;-  sample(c(0,1,2), ape::Ntip(phylotree), replace = TRUE)
num_concealed_states &lt;- 3
idparslist &lt;- cla_id_paramPos(traits,num_concealed_states)
idparslist$lambdas[1,] &lt;- c(1,1,1,2,2,2,3,3,3)
idparslist[[2]][] &lt;- 4
masterBlock &lt;- matrix(5,ncol = 3,nrow = 3,byrow = TRUE)
diag(masterBlock) &lt;- NA
diff.conceal &lt;- FALSE
idparslist[[3]] &lt;- q_doubletrans(traits,masterBlock,diff.conceal)
startingpoint &lt;- bd_ML(brts = ape::branching.times(phylotree))
intGuessLamba &lt;- startingpoint$lambda0
intGuessMu &lt;- startingpoint$mu0
idparsopt &lt;- c(1,2,3)
initparsopt &lt;- c(rep(intGuessLamba,3))
idparsfix &lt;- c(0,4,5)
parsfix &lt;- c(0,0,0.01)
tol &lt;- c(1e-04, 1e-05, 1e-07)
maxiter &lt;- 1000 * round((1.25) ^ length(idparsopt))
optimmethod &lt;- 'subplex'
cond &lt;- 'proper_cond'
root_state_weight &lt;- 'proper_weights'
sampling_fraction &lt;- c(1,1,1)
model &lt;- cla_secsse_ml(
 phylotree,
 traits,
 num_concealed_states,
 idparslist,
 idparsopt,
 initparsopt,
 idparsfix,
 parsfix,
 cond,
 root_state_weight,
 sampling_fraction,
 tol,
 maxiter,
 optimmethod,
 num_cycles = 1,
 num_threads = 1,
 verbose = FALSE)
# [1] -90.97626
</code></pre>

<hr>
<h2 id='cla_secsse_ml_func_def_pars'>Maximum likehood estimation for (SecSSE) with parameter as complex
functions. Cladogenetic version</h2><span id='topic+cla_secsse_ml_func_def_pars'></span>

<h3>Description</h3>

<p>Maximum likehood estimation under cla Several examined and concealed
States-dependent Speciation and Extinction (SecSSE) where some paramaters are
functions of other parameters and/or factors. Offers the option of
cladogenesis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cla_secsse_ml_func_def_pars(
  phy,
  traits,
  num_concealed_states,
  idparslist,
  idparsopt,
  initparsopt,
  idfactorsopt,
  initfactors,
  idparsfix,
  parsfix,
  idparsfuncdefpar,
  functions_defining_params,
  cond = "proper_cond",
  root_state_weight = "proper_weights",
  sampling_fraction,
  tol = c(1e-04, 1e-05, 1e-07),
  maxiter = 1000 * round((1.25)^length(idparsopt)),
  optimmethod = "subplex",
  num_cycles = 1,
  loglik_penalty = 0,
  is_complete_tree = FALSE,
  verbose = (optimmethod == "simplex"),
  num_threads = 1,
  atol = 1e-12,
  rtol = 1e-12,
  method = "odeint::bulirsch_stoer"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cla_secsse_ml_func_def_pars_+3A_phy">phy</code></td>
<td>
<p>phylogenetic tree of class <code>phylo</code>, rooted and with
branch lengths.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_func_def_pars_+3A_traits">traits</code></td>
<td>
<p>vector with trait states for each tip in the phylogeny. The
order of the states must be the same as the tree tips. For help, see
<code>vignette("starting_secsse", package = "secsse")</code>.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_func_def_pars_+3A_num_concealed_states">num_concealed_states</code></td>
<td>
<p>number of concealed states, generally equivalent
to the number of examined states in the dataset.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_func_def_pars_+3A_idparslist">idparslist</code></td>
<td>
<p>overview of parameters and their values.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_func_def_pars_+3A_idparsopt">idparsopt</code></td>
<td>
<p>a numeric vector with the ID of parameters to be estimated.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_func_def_pars_+3A_initparsopt">initparsopt</code></td>
<td>
<p>a numeric vector with the initial guess of the parameters
to be estimated.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_func_def_pars_+3A_idfactorsopt">idfactorsopt</code></td>
<td>
<p>id of the factors that will be optimized. There are not
fixed factors, so use a constant within <code>functions_defining_params</code>.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_func_def_pars_+3A_initfactors">initfactors</code></td>
<td>
<p>the initial guess for a factor (it should be set to <code>NULL</code>
when no factors).</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_func_def_pars_+3A_idparsfix">idparsfix</code></td>
<td>
<p>a numeric vector with the ID of the fixed parameters.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_func_def_pars_+3A_parsfix">parsfix</code></td>
<td>
<p>a numeric vector with the value of the fixed parameters.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_func_def_pars_+3A_idparsfuncdefpar">idparsfuncdefpar</code></td>
<td>
<p>id of the parameters which will be a function of
optimized and/or fixed parameters. The order of id should match
<code>functions_defining_params</code>.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_func_def_pars_+3A_functions_defining_params">functions_defining_params</code></td>
<td>
<p>a list of functions. Each element will be a
function which defines a parameter e.g. <code>id_3 &lt;- (id_1 + id_2) / 2</code>. See
example.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_func_def_pars_+3A_cond">cond</code></td>
<td>
<p>condition on the existence of a node root: <code>"maddison_cond"</code>,
<code>"proper_cond"</code> (default). For details, see vignette.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_func_def_pars_+3A_root_state_weight">root_state_weight</code></td>
<td>
<p>the method to weigh the states:
<code>"maddison_weights"</code>, <code>"proper_weights"</code> (default) or <code>"equal_weights"</code>.
It can also be specified for the root state: the vector <code>c(1, 0, 0)</code>
indicates state 1 was the root state.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_func_def_pars_+3A_sampling_fraction">sampling_fraction</code></td>
<td>
<p>vector that states the sampling proportion per
trait state. It must have as many elements as there are trait states.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_func_def_pars_+3A_tol">tol</code></td>
<td>
<p>A numeric vector with the maximum tolerance of the optimization
algorithm. Default is <code>c(1e-04, 1e-05, 1e-05)</code>.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_func_def_pars_+3A_maxiter">maxiter</code></td>
<td>
<p>max number of iterations. Default is
<code>1000 * round((1.25) ^ length(idparsopt))</code>.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_func_def_pars_+3A_optimmethod">optimmethod</code></td>
<td>
<p>A string with method used for optimization. Default is
<code>"subplex"</code>. Alternative is <code>"simplex"</code> and it shouldn't be used in normal
conditions (only for debugging). Both are called from <code><a href="DDD.html#topic+optimizer">DDD::optimizer()</a></code>,
simplex is implemented natively in <a href="DDD.html#topic+DDD">DDD</a>, while subplex is ultimately
called from <code><a href="subplex.html#topic+subplex">subplex::subplex()</a></code>.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_func_def_pars_+3A_num_cycles">num_cycles</code></td>
<td>
<p>Number of cycles of the optimization. When set to <code>Inf</code>,
the optimization will be repeated until the result is, within the
tolerance, equal to the starting values, with a maximum of 10 cycles.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_func_def_pars_+3A_loglik_penalty">loglik_penalty</code></td>
<td>
<p>the size of the penalty for all parameters; default is
0 (no penalty).</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_func_def_pars_+3A_is_complete_tree">is_complete_tree</code></td>
<td>
<p>logical specifying whether or not a tree with all its
extinct species is provided. If set to <code>TRUE</code>, it also assumes that all
<em>all</em> extinct lineages are present on the tree. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_func_def_pars_+3A_verbose">verbose</code></td>
<td>
<p>sets verbose output; default is <code>TRUE</code> when <code>optimmethod</code> is
<code>"simplex"</code>. If <code>optimmethod</code> is set to <code>"simplex"</code>, then even if set to
<code>FALSE</code>, optimizer output will be shown.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_func_def_pars_+3A_num_threads">num_threads</code></td>
<td>
<p>number of threads to be used. Default is one thread.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_func_def_pars_+3A_atol">atol</code></td>
<td>
<p>A numeric specifying the absolute tolerance of integration.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_func_def_pars_+3A_rtol">rtol</code></td>
<td>
<p>A numeric specifying the relative tolerance of integration.</p>
</td></tr>
<tr><td><code id="cla_secsse_ml_func_def_pars_+3A_method">method</code></td>
<td>
<p>integration method used, available are:
<code>"odeint::runge_kutta_cash_karp54"</code>, <code>"odeint::runge_kutta_fehlberg78"</code>,
<code>"odeint::runge_kutta_dopri5"</code>, <code>"odeint::bulirsch_stoer"</code> and
<code>"odeint::runge_kutta4"</code>. Default method is: <code>"odeint::bulirsch_stoer"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Parameter estimated and maximum likelihood
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example of how to set the arguments for a ML search.
rm(list=ls(all=TRUE))
library(secsse)
library(DDD)
set.seed(16)
phylotree &lt;- ape::rbdtree(0.07,0.001,Tmax=50)
startingpoint &lt;- bd_ML(brts = ape::branching.times(phylotree))
intGuessLamba &lt;- startingpoint$lambda0
intGuessMu &lt;- startingpoint$mu0
traits &lt;-  sample(c(0,1,2),
                 ape::Ntip(phylotree), replace = TRUE) # get some traits
num_concealed_states &lt;- 3
idparslist &lt;- cla_id_paramPos(traits, num_concealed_states)
idparslist$lambdas[1,] &lt;- c(1,2,3,1,2,3,1,2,3)
idparslist[[2]][] &lt;- 4
masterBlock &lt;- matrix(c(5,6,5,6,5,6,5,6,5),ncol = 3, nrow=3, byrow = TRUE)
diag(masterBlock) &lt;- NA
diff.conceal &lt;- FALSE
idparslist[[3]] &lt;- q_doubletrans(traits,masterBlock,diff.conceal)
idparsfuncdefpar &lt;- c(3,5,6)
idparsopt &lt;- c(1,2)
idparsfix &lt;- c(0,4)
initparsopt &lt;- c(rep(intGuessLamba,2))
parsfix &lt;- c(0,0)
idfactorsopt &lt;- 1
initfactors &lt;- 4
# functions_defining_params is a list of functions. Each function has no
# arguments and to refer
# to parameters ids should be indicated as 'par_' i.e. par_3 refers to
# parameter 3. When a
# function is defined, be sure that all the parameters involved are either
# estimated, fixed or
# defined by previous functions (i.e, a function that defines parameter in
# 'functions_defining_params'). The user is responsible for this. In this
# example, par_3
# (i.e., parameter 3) is needed to calculate par_6. This is correct because
# par_3 is defined
# in the first function of 'functions_defining_params'. Notice that factor_1
# indicates a value
# that will be estimated to satisfy the equation. The same factor can be
# shared to define several parameters.
functions_defining_params &lt;- list()
functions_defining_params[[1]] &lt;- function() {
 par_3 &lt;- par_1 + par_2
}
functions_defining_params[[2]] &lt;- function() {
 par_5 &lt;- par_1 * factor_1
}
functions_defining_params[[3]] &lt;- function() {
 par_6 &lt;- par_3 * factor_1
}

tol = c(1e-02, 1e-03, 1e-04)
maxiter = 1000 * round((1.25)^length(idparsopt))
optimmethod = 'subplex'
cond &lt;- 'proper_cond'
root_state_weight &lt;- 'proper_weights'
sampling_fraction &lt;- c(1,1,1)
model &lt;- cla_secsse_ml_func_def_pars(phylotree,
traits,
num_concealed_states,
idparslist,
idparsopt,
initparsopt,
idfactorsopt,
initfactors,
idparsfix,
parsfix,
idparsfuncdefpar,
functions_defining_params,
cond,
root_state_weight,
sampling_fraction,
tol,
maxiter,
optimmethod,
num_cycles = 1)
# ML -136.5796
</code></pre>

<hr>
<h2 id='create_default_lambda_transition_matrix'>Helper function to create a default lambda list</h2><span id='topic+create_default_lambda_transition_matrix'></span>

<h3>Description</h3>

<p>This function generates a generic lambda list, assuming no transitions
between states, e.g. a species of observed state 0 generates daughter
species with state 0 as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_default_lambda_transition_matrix(
  state_names = c("0", "1"),
  model = "ETD"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_default_lambda_transition_matrix_+3A_state_names">state_names</code></td>
<td>
<p>vector of names of all observed states.</p>
</td></tr>
<tr><td><code id="create_default_lambda_transition_matrix_+3A_model">model</code></td>
<td>
<p>used model, choice of <code>"ETD"</code> (Examined Traits Diversification),
<code>"CTD"</code> (Concealed Traits Diversification) or <code>"CR"</code> (Constant Rate).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>lambda_matrix &lt;-
     create_default_lambda_transition_matrix(state_names = c(0, 1),
                                             model = "ETD")
lambda_list &lt;- create_lambda_list(state_names = c(0, 1),
                                  num_concealed_states = 2,
                                  transition_matrix = lambda_matrix,
                                  model = "ETD")
</code></pre>

<hr>
<h2 id='create_default_shift_matrix'>Helper function to create a default <code>shift_matrix</code> list</h2><span id='topic+create_default_shift_matrix'></span>

<h3>Description</h3>

<p>This function generates a generic shift matrix to be used with the function
<code><a href="#topic+create_q_matrix">create_q_matrix()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_default_shift_matrix(
  state_names = c("0", "1"),
  num_concealed_states = 2,
  mu_vector = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_default_shift_matrix_+3A_state_names">state_names</code></td>
<td>
<p>vector of names of all observed states.</p>
</td></tr>
<tr><td><code id="create_default_shift_matrix_+3A_num_concealed_states">num_concealed_states</code></td>
<td>
<p>number of concealed states, generally equivalent
to the number of examined states in the dataset.</p>
</td></tr>
<tr><td><code id="create_default_shift_matrix_+3A_mu_vector">mu_vector</code></td>
<td>
<p>previously defined mus - used to choose indicator number.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>shift_matrix &lt;- create_default_shift_matrix(state_names = c(0, 1),
                                            num_concealed_states = 2,
                                            mu_vector = c(1, 2, 1, 2))
q_matrix &lt;- create_q_matrix(state_names = c(0, 1),
                            num_concealed_states = 2,
                            shift_matrix = shift_matrix,
                            diff.conceal = FALSE)
</code></pre>

<hr>
<h2 id='create_lambda_list'>Helper function to automatically create lambda matrices, based on input</h2><span id='topic+create_lambda_list'></span>

<h3>Description</h3>

<p>Helper function to automatically create lambda matrices, based on input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_lambda_list(
  state_names = c(0, 1),
  num_concealed_states = 2,
  transition_matrix,
  model = "ETD",
  concealed_spec_rates = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_lambda_list_+3A_state_names">state_names</code></td>
<td>
<p>vector of names of all observed states.</p>
</td></tr>
<tr><td><code id="create_lambda_list_+3A_num_concealed_states">num_concealed_states</code></td>
<td>
<p>number of concealed states, generally equivalent
to the number of examined states in the dataset.</p>
</td></tr>
<tr><td><code id="create_lambda_list_+3A_transition_matrix">transition_matrix</code></td>
<td>
<p>a matrix containing a description of all speciation
events, where the first column indicates the source state, the second and
third column indicate the two daughter states, and the fourth column gives
the rate indicator used. E.g.: <code style="white-space: pre;">&#8288;["SA", "S", "A", 1]&#8288;</code> for a trait state
<code>"SA"</code> which upon speciation generates two daughter species with traits
<code>"S"</code> and <code>"A"</code>, where the number 1 is used as indicator for optimization
of the likelihood.</p>
</td></tr>
<tr><td><code id="create_lambda_list_+3A_model">model</code></td>
<td>
<p>used model, choice of <code>"ETD"</code> (Examined Traits Diversification),
<code>"CTD"</code> (Concealed Traits Diversification) or <code>"CR"</code> (Constant Rate).</p>
</td></tr>
<tr><td><code id="create_lambda_list_+3A_concealed_spec_rates">concealed_spec_rates</code></td>
<td>
<p>vector specifying the rate indicators for each
concealed state, length should be identical to <code>num_concealed_states</code>. If
left empty when using the CTD model, it is assumed that all available
speciation rates are distributed uniformly over the concealed states.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>trans_matrix &lt;- c(0, 0, 0, 1)
trans_matrix &lt;- rbind(trans_matrix, c(1, 1, 1, 2))
lambda_list &lt;- create_lambda_list(state_names = c(0, 1),
                                  num_concealed_states = 2,
                                  transition_matrix = trans_matrix,
                                  model = "ETD")

</code></pre>

<hr>
<h2 id='create_mu_vector'>Generate mus vector</h2><span id='topic+create_mu_vector'></span>

<h3>Description</h3>

<p>Generate mus vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_mu_vector(state_names, num_concealed_states, model = "CR", lambda_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_mu_vector_+3A_state_names">state_names</code></td>
<td>
<p>vector of names of all observed states.</p>
</td></tr>
<tr><td><code id="create_mu_vector_+3A_num_concealed_states">num_concealed_states</code></td>
<td>
<p>number of concealed states, generally equivalent
to the number of examined states in the dataset.</p>
</td></tr>
<tr><td><code id="create_mu_vector_+3A_model">model</code></td>
<td>
<p>used model, choice of <code>"ETD"</code> (Examined Traits Diversification),
<code>"CTD"</code> (Concealed Traits Diversification) or <code>"CR"</code> (Constant Rate).</p>
</td></tr>
<tr><td><code id="create_mu_vector_+3A_lambda_list">lambda_list</code></td>
<td>
<p>previously generated list of lambda matrices,
used to infer the rate number to start with.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mu vector
</p>

<hr>
<h2 id='create_q_matrix'>Helper function to neatly setup a Q matrix, without transitions to
concealed states (only observed transitions shown)</h2><span id='topic+create_q_matrix'></span>

<h3>Description</h3>

<p>Helper function to neatly setup a Q matrix, without transitions to
concealed states (only observed transitions shown)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_q_matrix(
  state_names,
  num_concealed_states,
  shift_matrix,
  diff.conceal = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_q_matrix_+3A_state_names">state_names</code></td>
<td>
<p>vector of names of all observed states.</p>
</td></tr>
<tr><td><code id="create_q_matrix_+3A_num_concealed_states">num_concealed_states</code></td>
<td>
<p>number of concealed states, generally equivalent
to the number of examined states in the dataset.</p>
</td></tr>
<tr><td><code id="create_q_matrix_+3A_shift_matrix">shift_matrix</code></td>
<td>
<p>matrix of shifts, indicating in order:
</p>

<ol>
<li><p> starting state (typically the column in the transition matrix)
</p>
</li>
<li><p> ending state (typically the row in the transition matrix)
</p>
</li>
<li><p> associated rate indicator.
</p>
</li></ol>
</td></tr>
<tr><td><code id="create_q_matrix_+3A_diff.conceal">diff.conceal</code></td>
<td>
<p>Boolean stating if the concealed states should be
different. E.g. that the transition rates for the concealed
states are different from the transition rates for the examined states.
Normally it should be <code>FALSE</code> in order to avoid having a huge number of
parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>transition matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>shift_matrix &lt;- c(0, 1, 5)
shift_matrix &lt;- rbind(shift_matrix, c(1, 0, 6))
q_matrix &lt;- secsse::create_q_matrix(state_names = c(0, 1),
                                    num_concealed_states = 2,
                                    shift_matrix = shift_matrix,
                                    diff.conceal = TRUE)
</code></pre>

<hr>
<h2 id='default_params_doc'>Default parameter documentation</h2><span id='topic+default_params_doc'></span>

<h3>Description</h3>

<p>This function's purpose is to list all parameter documentation to be
inherited by the relevant functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_params_doc(
  phy,
  traits,
  num_concealed_states,
  idparslist,
  initparsopt,
  idparsfix,
  idparsopt,
  idfactorsopt,
  parsfix,
  cond,
  root_state_weight,
  sampling_fraction,
  tol,
  maxiter,
  optimethod,
  num_cycles,
  loglik_penalty,
  is_complete_tree,
  verbose,
  num_threads,
  atol,
  rtol,
  method,
  parameter,
  setting_calculation,
  num_steps,
  see_ancestral_states,
  lambdas,
  mus,
  qs,
  crown_age,
  pool_init_states,
  maxSpec,
  conditioning,
  non_extinction,
  max_tries,
  drop_extinct,
  seed,
  prob_func,
  parameters,
  masterBlock,
  diff.conceal,
  trait_info,
  lambd_and_modeSpe,
  initloglik,
  initfactors,
  idparsfuncdefpar,
  functions_defining_params,
  state_names,
  transition_matrix,
  model,
  concealed_spec_rates,
  shift_matrix,
  q_matrix,
  lambda_list,
  object,
  params,
  param_posit,
  ml_pars,
  mu_vector,
  max_spec,
  min_spec,
  max_species_extant,
  tree_size_hist,
  start_at_crown,
  optimmethod
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="default_params_doc_+3A_phy">phy</code></td>
<td>
<p>phylogenetic tree of class <code>phylo</code>, rooted and with
branch lengths.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_traits">traits</code></td>
<td>
<p>vector with trait states for each tip in the phylogeny. The
order of the states must be the same as the tree tips. For help, see
<code>vignette("starting_secsse", package = "secsse")</code>.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_num_concealed_states">num_concealed_states</code></td>
<td>
<p>number of concealed states, generally equivalent
to the number of examined states in the dataset.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_idparslist">idparslist</code></td>
<td>
<p>overview of parameters and their values.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_initparsopt">initparsopt</code></td>
<td>
<p>a numeric vector with the initial guess of the parameters
to be estimated.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_idparsfix">idparsfix</code></td>
<td>
<p>a numeric vector with the ID of the fixed parameters.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_idparsopt">idparsopt</code></td>
<td>
<p>a numeric vector with the ID of parameters to be estimated.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_idfactorsopt">idfactorsopt</code></td>
<td>
<p>id of the factors that will be optimized. There are not
fixed factors, so use a constant within <code>functions_defining_params</code>.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_parsfix">parsfix</code></td>
<td>
<p>a numeric vector with the value of the fixed parameters.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_cond">cond</code></td>
<td>
<p>condition on the existence of a node root: <code>"maddison_cond"</code>,
<code>"proper_cond"</code> (default). For details, see vignette.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_root_state_weight">root_state_weight</code></td>
<td>
<p>the method to weigh the states:
<code>"maddison_weights"</code>, <code>"proper_weights"</code> (default) or <code>"equal_weights"</code>.
It can also be specified for the root state: the vector <code>c(1, 0, 0)</code>
indicates state 1 was the root state.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_sampling_fraction">sampling_fraction</code></td>
<td>
<p>vector that states the sampling proportion per
trait state. It must have as many elements as there are trait states.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_tol">tol</code></td>
<td>
<p>A numeric vector with the maximum tolerance of the optimization
algorithm. Default is <code>c(1e-04, 1e-05, 1e-05)</code>.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_maxiter">maxiter</code></td>
<td>
<p>max number of iterations. Default is
<code>1000 * round((1.25) ^ length(idparsopt))</code>.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_num_cycles">num_cycles</code></td>
<td>
<p>Number of cycles of the optimization. When set to <code>Inf</code>,
the optimization will be repeated until the result is, within the
tolerance, equal to the starting values, with a maximum of 10 cycles.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_loglik_penalty">loglik_penalty</code></td>
<td>
<p>the size of the penalty for all parameters; default is
0 (no penalty).</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_is_complete_tree">is_complete_tree</code></td>
<td>
<p>logical specifying whether or not a tree with all its
extinct species is provided. If set to <code>TRUE</code>, it also assumes that all
<em>all</em> extinct lineages are present on the tree. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_verbose">verbose</code></td>
<td>
<p>sets verbose output; default is <code>TRUE</code> when <code>optimmethod</code> is
<code>"simplex"</code>. If <code>optimmethod</code> is set to <code>"simplex"</code>, then even if set to
<code>FALSE</code>, optimizer output will be shown.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_num_threads">num_threads</code></td>
<td>
<p>number of threads to be used. Default is one thread.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_atol">atol</code></td>
<td>
<p>A numeric specifying the absolute tolerance of integration.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_rtol">rtol</code></td>
<td>
<p>A numeric specifying the relative tolerance of integration.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_method">method</code></td>
<td>
<p>integration method used, available are:
<code>"odeint::runge_kutta_cash_karp54"</code>, <code>"odeint::runge_kutta_fehlberg78"</code>,
<code>"odeint::runge_kutta_dopri5"</code>, <code>"odeint::bulirsch_stoer"</code> and
<code>"odeint::runge_kutta4"</code>. Default method is: <code>"odeint::bulirsch_stoer"</code>.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_parameter">parameter</code></td>
<td>
<p>list where first vector represents lambdas, the second
mus and the third transition rates.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_setting_calculation">setting_calculation</code></td>
<td>
<p>argument used internally to speed up calculation.
It should be left blank (default : <code>setting_calculation = NULL</code>).</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_num_steps">num_steps</code></td>
<td>
<p>number of substeps to show intermediate likelihoods
along a branch.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_see_ancestral_states">see_ancestral_states</code></td>
<td>
<p>Boolean for whether the ancestral states should
be shown? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_lambdas">lambdas</code></td>
<td>
<p>speciation rates, in the form of a list of matrices.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_mus">mus</code></td>
<td>
<p>extinction rates, in the form of a vector.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_qs">qs</code></td>
<td>
<p>The Q matrix, for example the result of function q_doubletrans, but
generally in the form of a matrix.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_crown_age">crown_age</code></td>
<td>
<p>crown age of the tree, tree will be simulated conditional
on non-extinction and this crown age.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_pool_init_states">pool_init_states</code></td>
<td>
<p>pool of initial states at the crown, in case this is
different from all available states, otherwise leave at NULL</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_conditioning">conditioning</code></td>
<td>
<p>can be <code>"obs_states"</code>, <code>"true_states"</code> or <code>"none"</code>, the
tree is simulated until one is generated that contains all observed states
(<code>"obs_states"</code>), all true states (e.g. all combinations of obs and hidden
states), or is always returned (<code>"none"</code>). Alternatively, a vector with
the names of required observed states can be provided, e.g. c(&quot;S&quot;, &quot;N&quot;).</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_non_extinction">non_extinction</code></td>
<td>
<p>boolean stating if the tree should be conditioned on
non-extinction of the crown lineages. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_max_tries">max_tries</code></td>
<td>
<p>maximum number of simulations to try to obtain a tree.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_drop_extinct">drop_extinct</code></td>
<td>
<p>boolean stating if extinct species should be dropped from
the tree. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_seed">seed</code></td>
<td>
<p>pseudo-random number generator seed.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_prob_func">prob_func</code></td>
<td>
<p>a function to calculate the probability of interest, see
description.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_parameters">parameters</code></td>
<td>
<p>list where first vector represents lambdas, the second mus
and the third transition rates.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_masterblock">masterBlock</code></td>
<td>
<p>matrix of transitions among only examined states, <code>NA</code> in
the main diagonal, used to build the full transition rates matrix.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_diff.conceal">diff.conceal</code></td>
<td>
<p>Boolean stating if the concealed states should be
different. E.g. that the transition rates for the concealed
states are different from the transition rates for the examined states.
Normally it should be <code>FALSE</code> in order to avoid having a huge number of
parameters.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_trait_info">trait_info</code></td>
<td>
<p>data frame where first column has species ids and the second
one is the trait associated information.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_lambd_and_modespe">lambd_and_modeSpe</code></td>
<td>
<p>a matrix with the 4 models of speciation possible.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_initloglik">initloglik</code></td>
<td>
<p>A numeric with the value of loglikehood obtained prior to
optimisation. Only used internally.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_initfactors">initfactors</code></td>
<td>
<p>the initial guess for a factor (it should be set to <code>NULL</code>
when no factors).</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_idparsfuncdefpar">idparsfuncdefpar</code></td>
<td>
<p>id of the parameters which will be a function of
optimized and/or fixed parameters. The order of id should match
<code>functions_defining_params</code>.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_functions_defining_params">functions_defining_params</code></td>
<td>
<p>a list of functions. Each element will be a
function which defines a parameter e.g. <code>id_3 &lt;- (id_1 + id_2) / 2</code>. See
example.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_state_names">state_names</code></td>
<td>
<p>vector of names of all observed states.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_transition_matrix">transition_matrix</code></td>
<td>
<p>a matrix containing a description of all speciation
events, where the first column indicates the source state, the second and
third column indicate the two daughter states, and the fourth column gives
the rate indicator used. E.g.: <code style="white-space: pre;">&#8288;["SA", "S", "A", 1]&#8288;</code> for a trait state
<code>"SA"</code> which upon speciation generates two daughter species with traits
<code>"S"</code> and <code>"A"</code>, where the number 1 is used as indicator for optimization
of the likelihood.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_model">model</code></td>
<td>
<p>used model, choice of <code>"ETD"</code> (Examined Traits Diversification),
<code>"CTD"</code> (Concealed Traits Diversification) or <code>"CR"</code> (Constant Rate).</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_concealed_spec_rates">concealed_spec_rates</code></td>
<td>
<p>vector specifying the rate indicators for each
concealed state, length should be identical to <code>num_concealed_states</code>. If
left empty when using the CTD model, it is assumed that all available
speciation rates are distributed uniformly over the concealed states.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_shift_matrix">shift_matrix</code></td>
<td>
<p>matrix of shifts, indicating in order:
</p>

<ol>
<li><p> starting state (typically the column in the transition matrix)
</p>
</li>
<li><p> ending state (typically the row in the transition matrix)
</p>
</li>
<li><p> associated rate indicator.
</p>
</li></ol>
</td></tr>
<tr><td><code id="default_params_doc_+3A_q_matrix">q_matrix</code></td>
<td>
<p><code>q_matrix</code> with only transitions between observed states.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_lambda_list">lambda_list</code></td>
<td>
<p>previously generated list of lambda matrices,
used to infer the rate number to start with.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_object">object</code></td>
<td>
<p>lambda matrices, <code>q_matrix</code> or mu vector.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_params">params</code></td>
<td>
<p>parameters in order, where each value reflects the value
of the parameter at that position, e.g. <code>c(0.3, 0.2, 0.1)</code> will fill out
the value 0.3 for the parameter with rate identifier 1, 0.2 for the
parameter with rate identifier 2 and 0.1 for the parameter with rate
identifier 3.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_param_posit">param_posit</code></td>
<td>
<p>initial parameter structure, consisting of a list with
three entries:
</p>

<ol>
<li><p> lambda matrices
</p>
</li>
<li><p> mus
</p>
</li>
<li><p> Q matrix
</p>
</li></ol>

<p>In each entry, integers numbers (1-n) indicate the parameter to be
optimized.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_ml_pars">ml_pars</code></td>
<td>
<p>resulting parameter estimates as returned by for instance
<code><a href="#topic+cla_secsse_ml">cla_secsse_ml()</a></code>, having the same structure as <code>param_post</code>.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_mu_vector">mu_vector</code></td>
<td>
<p>previously defined mus - used to choose indicator number.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_max_spec">max_spec</code></td>
<td>
<p>Maximum number of species in the tree (please note that the
tree is not conditioned on this number, but that this is a safeguard
against generating extremely large trees).</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_min_spec">min_spec</code></td>
<td>
<p>Minimum number of species in the tree.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_max_species_extant">max_species_extant</code></td>
<td>
<p>Should the maximum number of species be counted in
the reconstructed tree (if TRUE) or in the complete tree (if FALSE).</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_tree_size_hist">tree_size_hist</code></td>
<td>
<p>if TRUE, returns a vector of all found tree sizes.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_start_at_crown">start_at_crown</code></td>
<td>
<p>if FALSE, the simulation starts with one species
instead of the two assumed by default by secsse (also in ML), and
the resulting crown age will be lower than the set crown age. This allows
for direct comparison with BiSSE and facilitates implementing speciation
effects at the crown.</p>
</td></tr>
<tr><td><code id="default_params_doc_+3A_optimmethod">optimmethod</code></td>
<td>
<p>A string with method used for optimization. Default is
<code>"subplex"</code>. Alternative is <code>"simplex"</code> and it shouldn't be used in normal
conditions (only for debugging). Both are called from <code><a href="DDD.html#topic+optimizer">DDD::optimizer()</a></code>,
simplex is implemented natively in <a href="DDD.html#topic+DDD">DDD</a>, while subplex is ultimately
called from <code><a href="subplex.html#topic+subplex">subplex::subplex()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>

<hr>
<h2 id='event_times'>Event times of a (possibly non-ultrametric) phylogenetic tree</h2><span id='topic+event_times'></span>

<h3>Description</h3>

<p>Times at which speciation or extinction occurs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>event_times(phy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="event_times_+3A_phy">phy</code></td>
<td>
<p>phylogenetic tree of class phylo, without polytomies, rooted and
with branch lengths. Need not be ultrametric.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>times at which speciation or extinction happens.
</p>


<h3>Note</h3>

<p>This script has been modified from BAMMtools' internal function
NU.branching.times
</p>

<hr>
<h2 id='example_phy_GeoSSE'>A phylogeny with traits at the tips</h2><span id='topic+example_phy_GeoSSE'></span>

<h3>Description</h3>

<p>An example phylogeny for testing purposes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_phy_GeoSSE
</code></pre>


<h3>Format</h3>

<p>A phylogeny as created by GeoSSE (diversitree)
</p>

<hr>
<h2 id='expand_q_matrix'>Function to expand an existing q_matrix to a number of concealed states</h2><span id='topic+expand_q_matrix'></span>

<h3>Description</h3>

<p>Function to expand an existing q_matrix to a number of concealed states
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_q_matrix(q_matrix, num_concealed_states, diff.conceal = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expand_q_matrix_+3A_q_matrix">q_matrix</code></td>
<td>
<p><code>q_matrix</code> with only transitions between observed states.</p>
</td></tr>
<tr><td><code id="expand_q_matrix_+3A_num_concealed_states">num_concealed_states</code></td>
<td>
<p>number of concealed states, generally equivalent
to the number of examined states in the dataset.</p>
</td></tr>
<tr><td><code id="expand_q_matrix_+3A_diff.conceal">diff.conceal</code></td>
<td>
<p>Boolean stating if the concealed states should be
different. E.g. that the transition rates for the concealed
states are different from the transition rates for the examined states.
Normally it should be <code>FALSE</code> in order to avoid having a huge number of
parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>updated q matrix
</p>


<h3>Note</h3>

<p>This is highly similar to <code><a href="#topic+q_doubletrans">q_doubletrans()</a></code>.
</p>

<hr>
<h2 id='extract_par_vals'>Extract parameter values out of the result of a maximum likelihood inference
run</h2><span id='topic+extract_par_vals'></span>

<h3>Description</h3>

<p>Extract parameter values out of the result of a maximum likelihood inference
run
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_par_vals(param_posit, ml_pars)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_par_vals_+3A_param_posit">param_posit</code></td>
<td>
<p>initial parameter structure, consisting of a list with
three entries:
</p>

<ol>
<li><p> lambda matrices
</p>
</li>
<li><p> mus
</p>
</li>
<li><p> Q matrix
</p>
</li></ol>

<p>In each entry, integers numbers (1-n) indicate the parameter to be
optimized.</p>
</td></tr>
<tr><td><code id="extract_par_vals_+3A_ml_pars">ml_pars</code></td>
<td>
<p>resulting parameter estimates as returned by for instance
<code><a href="#topic+cla_secsse_ml">cla_secsse_ml()</a></code>, having the same structure as <code>param_post</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of parameter estimates.
</p>

<hr>
<h2 id='fill_in'>Helper function to enter parameter value on their right place</h2><span id='topic+fill_in'></span>

<h3>Description</h3>

<p>Helper function to enter parameter value on their right place
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_in(object, params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fill_in_+3A_object">object</code></td>
<td>
<p>lambda matrices, <code>q_matrix</code> or mu vector.</p>
</td></tr>
<tr><td><code id="fill_in_+3A_params">params</code></td>
<td>
<p>parameters in order, where each value reflects the value
of the parameter at that position, e.g. <code>c(0.3, 0.2, 0.1)</code> will fill out
the value 0.3 for the parameter with rate identifier 1, 0.2 for the
parameter with rate identifier 2 and 0.1 for the parameter with rate
identifier 3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>lambda matrices, <code>q_matrix</code> or mu vector with the correct values in
their right place.
</p>

<hr>
<h2 id='id_paramPos'>Parameter structure setting
Sets the parameters (speciation, extinction and transition) ids. Needed for
ML calculation (<code><a href="#topic+secsse_ml">secsse_ml()</a></code>).</h2><span id='topic+id_paramPos'></span>

<h3>Description</h3>

<p>Parameter structure setting
Sets the parameters (speciation, extinction and transition) ids. Needed for
ML calculation (<code><a href="#topic+secsse_ml">secsse_ml()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id_paramPos(traits, num_concealed_states)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="id_paramPos_+3A_traits">traits</code></td>
<td>
<p>vector with trait states for each tip in the phylogeny. The
order of the states must be the same as the tree tips. For help, see
<code>vignette("starting_secsse", package = "secsse")</code>.</p>
</td></tr>
<tr><td><code id="id_paramPos_+3A_num_concealed_states">num_concealed_states</code></td>
<td>
<p>number of concealed states, generally equivalent
to the number of examined states in the dataset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list that includes the ids of the parameters for ML analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>traits &lt;- sample(c(0,1,2), 45,replace = TRUE) #get some traits
num_concealed_states &lt;- 3
param_posit &lt;- id_paramPos(traits,num_concealed_states)
</code></pre>

<hr>
<h2 id='phylo_vignette'>A phylogenetic reconstuction to run the vignette</h2><span id='topic+phylo_vignette'></span>

<h3>Description</h3>

<p>An example phylogeny in the right format for secsse
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylo_vignette
</code></pre>


<h3>Format</h3>

<p>Phylogenetic tree in phy format, rooted, including branch lengths
</p>

<hr>
<h2 id='plot_state_exact'>Plot the local probability along a tree</h2><span id='topic+plot_state_exact'></span>

<h3>Description</h3>

<p>Plot the local probability along the tree, including the branches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_state_exact(
  parameters,
  phy,
  traits,
  num_concealed_states,
  sampling_fraction,
  cond = "proper_cond",
  root_state_weight = "proper_weights",
  is_complete_tree = FALSE,
  method = "odeint::bulirsch_stoer",
  atol = 1e-16,
  rtol = 1e-16,
  num_steps = 100,
  prob_func = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_state_exact_+3A_parameters">parameters</code></td>
<td>
<p>list where first vector represents lambdas, the second mus
and the third transition rates.</p>
</td></tr>
<tr><td><code id="plot_state_exact_+3A_phy">phy</code></td>
<td>
<p>phylogenetic tree of class <code>phylo</code>, rooted and with
branch lengths.</p>
</td></tr>
<tr><td><code id="plot_state_exact_+3A_traits">traits</code></td>
<td>
<p>vector with trait states for each tip in the phylogeny. The
order of the states must be the same as the tree tips. For help, see
<code>vignette("starting_secsse", package = "secsse")</code>.</p>
</td></tr>
<tr><td><code id="plot_state_exact_+3A_num_concealed_states">num_concealed_states</code></td>
<td>
<p>number of concealed states, generally equivalent
to the number of examined states in the dataset.</p>
</td></tr>
<tr><td><code id="plot_state_exact_+3A_sampling_fraction">sampling_fraction</code></td>
<td>
<p>vector that states the sampling proportion per
trait state. It must have as many elements as there are trait states.</p>
</td></tr>
<tr><td><code id="plot_state_exact_+3A_cond">cond</code></td>
<td>
<p>condition on the existence of a node root: <code>"maddison_cond"</code>,
<code>"proper_cond"</code> (default). For details, see vignette.</p>
</td></tr>
<tr><td><code id="plot_state_exact_+3A_root_state_weight">root_state_weight</code></td>
<td>
<p>the method to weigh the states:
<code>"maddison_weights"</code>, <code>"proper_weights"</code> (default) or <code>"equal_weights"</code>.
It can also be specified for the root state: the vector <code>c(1, 0, 0)</code>
indicates state 1 was the root state.</p>
</td></tr>
<tr><td><code id="plot_state_exact_+3A_is_complete_tree">is_complete_tree</code></td>
<td>
<p>logical specifying whether or not a tree with all its
extinct species is provided. If set to <code>TRUE</code>, it also assumes that all
<em>all</em> extinct lineages are present on the tree. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot_state_exact_+3A_method">method</code></td>
<td>
<p>integration method used, available are:
<code>"odeint::runge_kutta_cash_karp54"</code>, <code>"odeint::runge_kutta_fehlberg78"</code>,
<code>"odeint::runge_kutta_dopri5"</code>, <code>"odeint::bulirsch_stoer"</code> and
<code>"odeint::runge_kutta4"</code>. Default method is: <code>"odeint::bulirsch_stoer"</code>.</p>
</td></tr>
<tr><td><code id="plot_state_exact_+3A_atol">atol</code></td>
<td>
<p>A numeric specifying the absolute tolerance of integration.</p>
</td></tr>
<tr><td><code id="plot_state_exact_+3A_rtol">rtol</code></td>
<td>
<p>A numeric specifying the relative tolerance of integration.</p>
</td></tr>
<tr><td><code id="plot_state_exact_+3A_num_steps">num_steps</code></td>
<td>
<p>number of substeps to show intermediate likelihoods
along a branch.</p>
</td></tr>
<tr><td><code id="plot_state_exact_+3A_prob_func">prob_func</code></td>
<td>
<p>a function to calculate the probability of interest, see
description.</p>
</td></tr>
<tr><td><code id="plot_state_exact_+3A_verbose">verbose</code></td>
<td>
<p>sets verbose output; default is <code>TRUE</code> when <code>optimmethod</code> is
<code>"simplex"</code>. If <code>optimmethod</code> is set to <code>"simplex"</code>, then even if set to
<code>FALSE</code>, optimizer output will be shown.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will evaluate the log likelihood locally along
all branches and plot the result. When <code>num_steps</code> is left to <code>NULL</code>, all
likelihood evaluations during integration are used for plotting. This may
work for not too large trees, but may become very memory heavy for larger
trees. Instead, the user can indicate a number of steps, which causes the
probabilities to be evaluated at a distinct amount of steps along each branch
(and the probabilities to be properly integrated in between these steps).
This provides an approximation, but generally results look very similar to
using the full evaluation.
The function used for <code>prob_func</code> will be highly dependent on your system.
for instance, for a 3 observed, 2 hidden states model, the probability
of state A is <code>prob[1] + prob[2] + prob[3]</code>, normalized by the row sum.
<code>prob_func</code> will be applied to each row of the 'states' matrix (you can thus
test your function on the states matrix returned when
<code>'see_ancestral_states = TRUE'</code>). Please note that the first N columns of the
states matrix are the extinction rates, and the <code style="white-space: pre;">&#8288;(N+1):2N&#8288;</code> columns belong to
the speciation rates, where <code>N = num_obs_states * num_concealed_states</code>.
A typical <code>prob_func</code> function will look like:
</p>
<div class="sourceCode"><pre>my_prob_func &lt;- function(x) {
  return(sum(x[5:8]) / sum(x))
}
</pre></div>


<h3>Value</h3>

<p>ggplot2 object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5)
phy &lt;- ape::rphylo(n = 4, birth = 1, death = 0)
traits &lt;- c(0, 1, 1, 0)
params &lt;- secsse::id_paramPos(c(0, 1), 2)
params[[1]][] &lt;- c(0.2, 0.2, 0.1, 0.1)
params[[2]][] &lt;- 0.0
params[[3]][, ] &lt;- 0.1
diag(params[[3]]) &lt;- NA
#  Thus, we have for both, rates
# 0A, 1A, 0B and 1B. If we are interested in the posterior probability of
# trait 0,we have to provide a helper function that sums the probabilities of
# 0A and 0B, e.g.:
helper_function &lt;- function(x) {
  return(sum(x[c(5, 7)]) / sum(x)) # normalized by total sum, just in case.
}

out_plot &lt;- plot_state_exact(parameters = params,
                             phy = phy,
                             traits = traits,
                             num_concealed_states = 2,
                             sampling_fraction = c(1, 1),
                             num_steps = 10,
                             prob_func = helper_function)
</code></pre>

<hr>
<h2 id='prepare_full_lambdas'>Prepares the entire set of lambda matrices for cla_secsse.
It provides the set of matrices containing all the speciation rates</h2><span id='topic+prepare_full_lambdas'></span>

<h3>Description</h3>

<p>Prepares the entire set of lambda matrices for cla_secsse.
It provides the set of matrices containing all the speciation rates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_full_lambdas(traits, num_concealed_states, lambd_and_modeSpe)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prepare_full_lambdas_+3A_traits">traits</code></td>
<td>
<p>vector with trait states for each tip in the phylogeny. The
order of the states must be the same as the tree tips. For help, see
<code>vignette("starting_secsse", package = "secsse")</code>.</p>
</td></tr>
<tr><td><code id="prepare_full_lambdas_+3A_num_concealed_states">num_concealed_states</code></td>
<td>
<p>number of concealed states, generally equivalent
to the number of examined states in the dataset.</p>
</td></tr>
<tr><td><code id="prepare_full_lambdas_+3A_lambd_and_modespe">lambd_and_modeSpe</code></td>
<td>
<p>a matrix with the 4 models of speciation possible.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of lambdas, its length would be the same than the number of
trait states * num_concealed_states..
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(13)
phylotree &lt;- ape::rcoal(12, tip.label = 1:12)
traits &lt;- sample(c(0, 1, 2),
                 ape::Ntip(phylotree), replace = TRUE)
num_concealed_states &lt;- 3
# the idparlist for a ETD model (dual state inheritance model of evolution)
# would be set like this:
idparlist &lt;- secsse::cla_id_paramPos(traits, num_concealed_states)
lambd_and_modeSpe &lt;- idparlist$lambdas
lambd_and_modeSpe[1, ] &lt;- c(1, 1, 1, 2, 2, 2, 3, 3, 3)
idparlist[[1]] &lt;- lambd_and_modeSpe
idparlist[[2]][] &lt;- 0
masterBlock &lt;- matrix(4, ncol = 3, nrow = 3, byrow = TRUE)
diag(masterBlock) &lt;- NA
idparlist[[3]] &lt;- q_doubletrans(traits, masterBlock, diff.conceal = FALSE)
# Now, internally, clasecsse sorts the lambda matrices, so they look like
#  a list with 9 matrices, corresponding to the 9 states
# (0A,1A,2A,0B, etc)

parameter &lt;- idparlist
lambda_and_modeSpe &lt;- parameter$lambdas
lambda_and_modeSpe[1, ] &lt;- c(0.2, 0.2, 0.2, 0.4, 0.4, 0.4, 0.01, 0.01, 0.01)
parameter[[1]] &lt;- prepare_full_lambdas(traits, num_concealed_states,
                                       lambda_and_modeSpe)
</code></pre>

<hr>
<h2 id='q_doubletrans'>Basic Qmatrix
Sets a Q matrix where double transitions are not allowed</h2><span id='topic+q_doubletrans'></span>

<h3>Description</h3>

<p>This function expands the Q_matrix, but it does so assuming
that the number of concealed traits is equal to the number of examined
traits, if you have a different number, you should consider looking at
the function <code><a href="#topic+expand_q_matrix">expand_q_matrix()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>q_doubletrans(traits, masterBlock, diff.conceal)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="q_doubletrans_+3A_traits">traits</code></td>
<td>
<p>vector with trait states for each tip in the phylogeny. The
order of the states must be the same as the tree tips. For help, see
<code>vignette("starting_secsse", package = "secsse")</code>.</p>
</td></tr>
<tr><td><code id="q_doubletrans_+3A_masterblock">masterBlock</code></td>
<td>
<p>matrix of transitions among only examined states, <code>NA</code> in
the main diagonal, used to build the full transition rates matrix.</p>
</td></tr>
<tr><td><code id="q_doubletrans_+3A_diff.conceal">diff.conceal</code></td>
<td>
<p>Boolean stating if the concealed states should be
different. E.g. that the transition rates for the concealed
states are different from the transition rates for the examined states.
Normally it should be <code>FALSE</code> in order to avoid having a huge number of
parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Q matrix that includes both examined and concealed states, it should
be declared as the third element of idparslist.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>traits &lt;- sample(c(0,1,2), 45,replace = TRUE) #get some traits
# For a three-state trait
masterBlock &lt;- matrix(99,ncol = 3,nrow = 3,byrow = TRUE)
diag(masterBlock) &lt;- NA
masterBlock[1,2] &lt;- 6
masterBlock[1,3] &lt;- 7
masterBlock[2,1] &lt;- 8
masterBlock[2,3] &lt;- 9
masterBlock[3,1] &lt;- 10
masterBlock[3,2] &lt;- 11
myQ &lt;- q_doubletrans(traits,masterBlock,diff.conceal = FALSE)
# now, it can replace the Q matrix from id_paramPos
num_concealed_states &lt;- 3
param_posit &lt;- id_paramPos(traits,num_concealed_states)
param_posit[[3]] &lt;- myQ
</code></pre>

<hr>
<h2 id='secsse_loglik'>Likelihood for SecSSE model
Loglikelihood calculation for the SecSSE model given a set of parameters and
data</h2><span id='topic+secsse_loglik'></span>

<h3>Description</h3>

<p>Likelihood for SecSSE model
Loglikelihood calculation for the SecSSE model given a set of parameters and
data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>secsse_loglik(
  parameter,
  phy,
  traits,
  num_concealed_states,
  cond = "proper_cond",
  root_state_weight = "proper_weights",
  sampling_fraction,
  setting_calculation = NULL,
  see_ancestral_states = FALSE,
  loglik_penalty = 0,
  is_complete_tree = FALSE,
  num_threads = 1,
  atol = 1e-08,
  rtol = 1e-07,
  method = "odeint::bulirsch_stoer"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="secsse_loglik_+3A_parameter">parameter</code></td>
<td>
<p>list where first vector represents lambdas, the second
mus and the third transition rates.</p>
</td></tr>
<tr><td><code id="secsse_loglik_+3A_phy">phy</code></td>
<td>
<p>phylogenetic tree of class <code>phylo</code>, rooted and with
branch lengths.</p>
</td></tr>
<tr><td><code id="secsse_loglik_+3A_traits">traits</code></td>
<td>
<p>vector with trait states for each tip in the phylogeny. The
order of the states must be the same as the tree tips. For help, see
<code>vignette("starting_secsse", package = "secsse")</code>.</p>
</td></tr>
<tr><td><code id="secsse_loglik_+3A_num_concealed_states">num_concealed_states</code></td>
<td>
<p>number of concealed states, generally equivalent
to the number of examined states in the dataset.</p>
</td></tr>
<tr><td><code id="secsse_loglik_+3A_cond">cond</code></td>
<td>
<p>condition on the existence of a node root: <code>"maddison_cond"</code>,
<code>"proper_cond"</code> (default). For details, see vignette.</p>
</td></tr>
<tr><td><code id="secsse_loglik_+3A_root_state_weight">root_state_weight</code></td>
<td>
<p>the method to weigh the states:
<code>"maddison_weights"</code>, <code>"proper_weights"</code> (default) or <code>"equal_weights"</code>.
It can also be specified for the root state: the vector <code>c(1, 0, 0)</code>
indicates state 1 was the root state.</p>
</td></tr>
<tr><td><code id="secsse_loglik_+3A_sampling_fraction">sampling_fraction</code></td>
<td>
<p>vector that states the sampling proportion per
trait state. It must have as many elements as there are trait states.</p>
</td></tr>
<tr><td><code id="secsse_loglik_+3A_setting_calculation">setting_calculation</code></td>
<td>
<p>argument used internally to speed up calculation.
It should be left blank (default : <code>setting_calculation = NULL</code>).</p>
</td></tr>
<tr><td><code id="secsse_loglik_+3A_see_ancestral_states">see_ancestral_states</code></td>
<td>
<p>Boolean for whether the ancestral states should
be shown? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="secsse_loglik_+3A_loglik_penalty">loglik_penalty</code></td>
<td>
<p>the size of the penalty for all parameters; default is
0 (no penalty).</p>
</td></tr>
<tr><td><code id="secsse_loglik_+3A_is_complete_tree">is_complete_tree</code></td>
<td>
<p>logical specifying whether or not a tree with all its
extinct species is provided. If set to <code>TRUE</code>, it also assumes that all
<em>all</em> extinct lineages are present on the tree. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="secsse_loglik_+3A_num_threads">num_threads</code></td>
<td>
<p>number of threads to be used. Default is one thread.</p>
</td></tr>
<tr><td><code id="secsse_loglik_+3A_atol">atol</code></td>
<td>
<p>A numeric specifying the absolute tolerance of integration.</p>
</td></tr>
<tr><td><code id="secsse_loglik_+3A_rtol">rtol</code></td>
<td>
<p>A numeric specifying the relative tolerance of integration.</p>
</td></tr>
<tr><td><code id="secsse_loglik_+3A_method">method</code></td>
<td>
<p>integration method used, available are:
<code>"odeint::runge_kutta_cash_karp54"</code>, <code>"odeint::runge_kutta_fehlberg78"</code>,
<code>"odeint::runge_kutta_dopri5"</code>, <code>"odeint::bulirsch_stoer"</code> and
<code>"odeint::runge_kutta4"</code>. Default method is: <code>"odeint::bulirsch_stoer"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The loglikelihood of the data given the parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rm(list = ls(all = TRUE))
library(secsse)
set.seed(13)
phylotree &lt;- ape::rcoal(31, tip.label = 1:31)
traits &lt;- sample(c(0,1,2),ape::Ntip(phylotree),replace = TRUE)
num_concealed_states &lt;- 2
cond &lt;- "proper_cond"
root_state_weight &lt;- "proper_weights"
sampling_fraction &lt;- c(1,1,1)
drill &lt;- id_paramPos(traits,num_concealed_states)
drill[[1]][] &lt;- c(0.12,0.01,0.2,0.21,0.31,0.23)
drill[[2]][] &lt;- 0
drill[[3]][,] &lt;- 0.1
diag(drill[[3]]) &lt;- NA
secsse_loglik(parameter = drill,
phylotree,
traits,
num_concealed_states,
cond,
root_state_weight,
sampling_fraction,
see_ancestral_states = FALSE)

#[1] -113.1018
</code></pre>

<hr>
<h2 id='secsse_loglik_eval'>Likelihood for SecSSE model
Logikelihood calculation for the SecSSE model given a set of parameters and
data, returning also the likelihoods along the branches</h2><span id='topic+secsse_loglik_eval'></span>

<h3>Description</h3>

<p>Likelihood for SecSSE model
Logikelihood calculation for the SecSSE model given a set of parameters and
data, returning also the likelihoods along the branches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>secsse_loglik_eval(
  parameter,
  phy,
  traits,
  num_concealed_states,
  cond = "proper_cond",
  root_state_weight = "proper_weights",
  sampling_fraction,
  setting_calculation = NULL,
  loglik_penalty = 0,
  is_complete_tree = FALSE,
  num_threads = 1,
  atol = 1e-08,
  rtol = 1e-07,
  method = "odeint::bulirsch_stoer",
  num_steps = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="secsse_loglik_eval_+3A_parameter">parameter</code></td>
<td>
<p>list where first vector represents lambdas, the second
mus and the third transition rates.</p>
</td></tr>
<tr><td><code id="secsse_loglik_eval_+3A_phy">phy</code></td>
<td>
<p>phylogenetic tree of class <code>phylo</code>, rooted and with
branch lengths.</p>
</td></tr>
<tr><td><code id="secsse_loglik_eval_+3A_traits">traits</code></td>
<td>
<p>vector with trait states for each tip in the phylogeny. The
order of the states must be the same as the tree tips. For help, see
<code>vignette("starting_secsse", package = "secsse")</code>.</p>
</td></tr>
<tr><td><code id="secsse_loglik_eval_+3A_num_concealed_states">num_concealed_states</code></td>
<td>
<p>number of concealed states, generally equivalent
to the number of examined states in the dataset.</p>
</td></tr>
<tr><td><code id="secsse_loglik_eval_+3A_cond">cond</code></td>
<td>
<p>condition on the existence of a node root: <code>"maddison_cond"</code>,
<code>"proper_cond"</code> (default). For details, see vignette.</p>
</td></tr>
<tr><td><code id="secsse_loglik_eval_+3A_root_state_weight">root_state_weight</code></td>
<td>
<p>the method to weigh the states:
<code>"maddison_weights"</code>, <code>"proper_weights"</code> (default) or <code>"equal_weights"</code>.
It can also be specified for the root state: the vector <code>c(1, 0, 0)</code>
indicates state 1 was the root state.</p>
</td></tr>
<tr><td><code id="secsse_loglik_eval_+3A_sampling_fraction">sampling_fraction</code></td>
<td>
<p>vector that states the sampling proportion per
trait state. It must have as many elements as there are trait states.</p>
</td></tr>
<tr><td><code id="secsse_loglik_eval_+3A_setting_calculation">setting_calculation</code></td>
<td>
<p>argument used internally to speed up calculation.
It should be left blank (default : <code>setting_calculation = NULL</code>).</p>
</td></tr>
<tr><td><code id="secsse_loglik_eval_+3A_loglik_penalty">loglik_penalty</code></td>
<td>
<p>the size of the penalty for all parameters; default is
0 (no penalty).</p>
</td></tr>
<tr><td><code id="secsse_loglik_eval_+3A_is_complete_tree">is_complete_tree</code></td>
<td>
<p>logical specifying whether or not a tree with all its
extinct species is provided. If set to <code>TRUE</code>, it also assumes that all
<em>all</em> extinct lineages are present on the tree. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="secsse_loglik_eval_+3A_num_threads">num_threads</code></td>
<td>
<p>number of threads to be used. Default is one thread.</p>
</td></tr>
<tr><td><code id="secsse_loglik_eval_+3A_atol">atol</code></td>
<td>
<p>A numeric specifying the absolute tolerance of integration.</p>
</td></tr>
<tr><td><code id="secsse_loglik_eval_+3A_rtol">rtol</code></td>
<td>
<p>A numeric specifying the relative tolerance of integration.</p>
</td></tr>
<tr><td><code id="secsse_loglik_eval_+3A_method">method</code></td>
<td>
<p>integration method used, available are:
<code>"odeint::runge_kutta_cash_karp54"</code>, <code>"odeint::runge_kutta_fehlberg78"</code>,
<code>"odeint::runge_kutta_dopri5"</code>, <code>"odeint::bulirsch_stoer"</code> and
<code>"odeint::runge_kutta4"</code>. Default method is: <code>"odeint::bulirsch_stoer"</code>.</p>
</td></tr>
<tr><td><code id="secsse_loglik_eval_+3A_num_steps">num_steps</code></td>
<td>
<p>number of substeps to show intermediate likelihoods
along a branch.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing: &quot;output&quot;, observed states along evaluated time
points along all branches, used for plotting. &quot;states&quot; all ancestral states
on the nodes and &quot;duration&quot;, indicating the time taken for the total
evaluation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5)
phy &lt;- ape::rphylo(n = 4, birth = 1, death = 0)
traits &lt;- c(0, 1, 1, 0)
params &lt;- secsse::id_paramPos(c(0, 1), 2)
params[[1]][] &lt;- c(0.2, 0.2, 0.1, 0.1)
params[[2]][] &lt;- 0.0
params[[3]][, ] &lt;- 0.1
diag(params[[3]]) &lt;- NA

secsse_loglik_eval(parameter = params,
                   phy = phy,
                   traits = traits,
                   num_concealed_states = 2,
                   sampling_fraction = c(1, 1),
                   num_steps = 10)
</code></pre>

<hr>
<h2 id='secsse_ml'>Maximum likehood estimation for (SecSSE)</h2><span id='topic+secsse_ml'></span>

<h3>Description</h3>

<p>Maximum likehood estimation under Several examined and concealed
States-dependent Speciation and Extinction (SecSSE)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>secsse_ml(
  phy,
  traits,
  num_concealed_states,
  idparslist,
  idparsopt,
  initparsopt,
  idparsfix,
  parsfix,
  cond = "proper_cond",
  root_state_weight = "proper_weights",
  sampling_fraction,
  tol = c(1e-04, 1e-05, 1e-07),
  maxiter = 1000 * round((1.25)^length(idparsopt)),
  optimmethod = "subplex",
  num_cycles = 1,
  loglik_penalty = 0,
  is_complete_tree = FALSE,
  verbose = (optimmethod == "simplex"),
  num_threads = 1,
  atol = 1e-08,
  rtol = 1e-07,
  method = "odeint::bulirsch_stoer"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="secsse_ml_+3A_phy">phy</code></td>
<td>
<p>phylogenetic tree of class <code>phylo</code>, rooted and with
branch lengths.</p>
</td></tr>
<tr><td><code id="secsse_ml_+3A_traits">traits</code></td>
<td>
<p>vector with trait states for each tip in the phylogeny. The
order of the states must be the same as the tree tips. For help, see
<code>vignette("starting_secsse", package = "secsse")</code>.</p>
</td></tr>
<tr><td><code id="secsse_ml_+3A_num_concealed_states">num_concealed_states</code></td>
<td>
<p>number of concealed states, generally equivalent
to the number of examined states in the dataset.</p>
</td></tr>
<tr><td><code id="secsse_ml_+3A_idparslist">idparslist</code></td>
<td>
<p>overview of parameters and their values.</p>
</td></tr>
<tr><td><code id="secsse_ml_+3A_idparsopt">idparsopt</code></td>
<td>
<p>a numeric vector with the ID of parameters to be estimated.</p>
</td></tr>
<tr><td><code id="secsse_ml_+3A_initparsopt">initparsopt</code></td>
<td>
<p>a numeric vector with the initial guess of the parameters
to be estimated.</p>
</td></tr>
<tr><td><code id="secsse_ml_+3A_idparsfix">idparsfix</code></td>
<td>
<p>a numeric vector with the ID of the fixed parameters.</p>
</td></tr>
<tr><td><code id="secsse_ml_+3A_parsfix">parsfix</code></td>
<td>
<p>a numeric vector with the value of the fixed parameters.</p>
</td></tr>
<tr><td><code id="secsse_ml_+3A_cond">cond</code></td>
<td>
<p>condition on the existence of a node root: <code>"maddison_cond"</code>,
<code>"proper_cond"</code> (default). For details, see vignette.</p>
</td></tr>
<tr><td><code id="secsse_ml_+3A_root_state_weight">root_state_weight</code></td>
<td>
<p>the method to weigh the states:
<code>"maddison_weights"</code>, <code>"proper_weights"</code> (default) or <code>"equal_weights"</code>.
It can also be specified for the root state: the vector <code>c(1, 0, 0)</code>
indicates state 1 was the root state.</p>
</td></tr>
<tr><td><code id="secsse_ml_+3A_sampling_fraction">sampling_fraction</code></td>
<td>
<p>vector that states the sampling proportion per
trait state. It must have as many elements as there are trait states.</p>
</td></tr>
<tr><td><code id="secsse_ml_+3A_tol">tol</code></td>
<td>
<p>A numeric vector with the maximum tolerance of the optimization
algorithm. Default is <code>c(1e-04, 1e-05, 1e-05)</code>.</p>
</td></tr>
<tr><td><code id="secsse_ml_+3A_maxiter">maxiter</code></td>
<td>
<p>max number of iterations. Default is
<code>1000 * round((1.25) ^ length(idparsopt))</code>.</p>
</td></tr>
<tr><td><code id="secsse_ml_+3A_optimmethod">optimmethod</code></td>
<td>
<p>A string with method used for optimization. Default is
<code>"subplex"</code>. Alternative is <code>"simplex"</code> and it shouldn't be used in normal
conditions (only for debugging). Both are called from <code><a href="DDD.html#topic+optimizer">DDD::optimizer()</a></code>,
simplex is implemented natively in <a href="DDD.html#topic+DDD">DDD</a>, while subplex is ultimately
called from <code><a href="subplex.html#topic+subplex">subplex::subplex()</a></code>.</p>
</td></tr>
<tr><td><code id="secsse_ml_+3A_num_cycles">num_cycles</code></td>
<td>
<p>Number of cycles of the optimization. When set to <code>Inf</code>,
the optimization will be repeated until the result is, within the
tolerance, equal to the starting values, with a maximum of 10 cycles.</p>
</td></tr>
<tr><td><code id="secsse_ml_+3A_loglik_penalty">loglik_penalty</code></td>
<td>
<p>the size of the penalty for all parameters; default is
0 (no penalty).</p>
</td></tr>
<tr><td><code id="secsse_ml_+3A_is_complete_tree">is_complete_tree</code></td>
<td>
<p>logical specifying whether or not a tree with all its
extinct species is provided. If set to <code>TRUE</code>, it also assumes that all
<em>all</em> extinct lineages are present on the tree. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="secsse_ml_+3A_verbose">verbose</code></td>
<td>
<p>sets verbose output; default is <code>TRUE</code> when <code>optimmethod</code> is
<code>"simplex"</code>. If <code>optimmethod</code> is set to <code>"simplex"</code>, then even if set to
<code>FALSE</code>, optimizer output will be shown.</p>
</td></tr>
<tr><td><code id="secsse_ml_+3A_num_threads">num_threads</code></td>
<td>
<p>number of threads to be used. Default is one thread.</p>
</td></tr>
<tr><td><code id="secsse_ml_+3A_atol">atol</code></td>
<td>
<p>A numeric specifying the absolute tolerance of integration.</p>
</td></tr>
<tr><td><code id="secsse_ml_+3A_rtol">rtol</code></td>
<td>
<p>A numeric specifying the relative tolerance of integration.</p>
</td></tr>
<tr><td><code id="secsse_ml_+3A_method">method</code></td>
<td>
<p>integration method used, available are:
<code>"odeint::runge_kutta_cash_karp54"</code>, <code>"odeint::runge_kutta_fehlberg78"</code>,
<code>"odeint::runge_kutta_dopri5"</code>, <code>"odeint::bulirsch_stoer"</code> and
<code>"odeint::runge_kutta4"</code>. Default method is: <code>"odeint::bulirsch_stoer"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Parameter estimated and maximum likelihood
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example of how to set the arguments for a ML search.
library(secsse)
library(DDD)
set.seed(13)
# lambdas for 0A and 1A and 2A are the same but need to be estimated
# mus are fixed to
# the transition rates are constrained to be equal and fixed 0.01
phylotree &lt;- ape::rcoal(31, tip.label = 1:31)
traits &lt;-  sample(c(0,1,2), ape::Ntip(phylotree),replace=TRUE)#get some traits
num_concealed_states&lt;-3
idparslist &lt;- id_paramPos(traits, num_concealed_states)
idparslist[[1]][c(1,4,7)] &lt;- 1
idparslist[[1]][c(2,5,8)] &lt;- 2
idparslist[[1]][c(3,6,9)] &lt;- 3
idparslist[[2]][]&lt;-4
masterBlock &lt;- matrix(5,ncol = 3,nrow = 3,byrow = TRUE)
diag(masterBlock) &lt;- NA
diff.conceal &lt;- FALSE
idparslist[[3]] &lt;- q_doubletrans(traits,masterBlock,diff.conceal)
startingpoint &lt;- DDD::bd_ML(brts = ape::branching.times(phylotree))
intGuessLamba &lt;- startingpoint$lambda0
intGuessMu &lt;- startingpoint$mu0
idparsopt &lt;- c(1,2,3,5)
initparsopt &lt;- c(rep(intGuessLamba,3),rep((intGuessLamba/5),1))
idparsfix &lt;- c(0,4)
parsfix &lt;- c(0,0)
tol &lt;- c(1e-02, 1e-03, 1e-04)
maxiter &lt;- 1000 * round((1.25)^length(idparsopt))
optimmethod &lt;- 'subplex'
cond &lt;- 'proper_cond'
root_state_weight &lt;- 'proper_weights'
sampling_fraction &lt;- c(1,1,1)
model&lt;-secsse_ml(
phylotree,
traits,
num_concealed_states,
idparslist,
idparsopt,
initparsopt,
idparsfix,
parsfix,
cond,
root_state_weight,
sampling_fraction,
tol,
maxiter,
optimmethod,
num_cycles = 1,
verbose = FALSE)
# model$ML
# [1] -16.04127
</code></pre>

<hr>
<h2 id='secsse_ml_func_def_pars'>Maximum likehood estimation for (SecSSE) with parameter as complex
functions.</h2><span id='topic+secsse_ml_func_def_pars'></span>

<h3>Description</h3>

<p>Maximum likehood estimation under Several examined and concealed
States-dependent Speciation and Extinction (SecSSE) where some paramaters
are functions of other parameters and/or factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>secsse_ml_func_def_pars(
  phy,
  traits,
  num_concealed_states,
  idparslist,
  idparsopt,
  initparsopt,
  idfactorsopt,
  initfactors,
  idparsfix,
  parsfix,
  idparsfuncdefpar,
  functions_defining_params = NULL,
  cond = "proper_cond",
  root_state_weight = "proper_weights",
  sampling_fraction,
  tol = c(1e-04, 1e-05, 1e-07),
  maxiter = 1000 * round((1.25)^length(idparsopt)),
  optimmethod = "subplex",
  num_cycles = 1,
  loglik_penalty = 0,
  is_complete_tree = FALSE,
  num_threads = 1,
  atol = 1e-08,
  rtol = 1e-06,
  method = "odeint::bulirsch_stoer"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="secsse_ml_func_def_pars_+3A_phy">phy</code></td>
<td>
<p>phylogenetic tree of class <code>phylo</code>, rooted and with
branch lengths.</p>
</td></tr>
<tr><td><code id="secsse_ml_func_def_pars_+3A_traits">traits</code></td>
<td>
<p>vector with trait states for each tip in the phylogeny. The
order of the states must be the same as the tree tips. For help, see
<code>vignette("starting_secsse", package = "secsse")</code>.</p>
</td></tr>
<tr><td><code id="secsse_ml_func_def_pars_+3A_num_concealed_states">num_concealed_states</code></td>
<td>
<p>number of concealed states, generally equivalent
to the number of examined states in the dataset.</p>
</td></tr>
<tr><td><code id="secsse_ml_func_def_pars_+3A_idparslist">idparslist</code></td>
<td>
<p>overview of parameters and their values.</p>
</td></tr>
<tr><td><code id="secsse_ml_func_def_pars_+3A_idparsopt">idparsopt</code></td>
<td>
<p>a numeric vector with the ID of parameters to be estimated.</p>
</td></tr>
<tr><td><code id="secsse_ml_func_def_pars_+3A_initparsopt">initparsopt</code></td>
<td>
<p>a numeric vector with the initial guess of the parameters
to be estimated.</p>
</td></tr>
<tr><td><code id="secsse_ml_func_def_pars_+3A_idfactorsopt">idfactorsopt</code></td>
<td>
<p>id of the factors that will be optimized. There are not
fixed factors, so use a constant within <code>functions_defining_params</code>.</p>
</td></tr>
<tr><td><code id="secsse_ml_func_def_pars_+3A_initfactors">initfactors</code></td>
<td>
<p>the initial guess for a factor (it should be set to <code>NULL</code>
when no factors).</p>
</td></tr>
<tr><td><code id="secsse_ml_func_def_pars_+3A_idparsfix">idparsfix</code></td>
<td>
<p>a numeric vector with the ID of the fixed parameters.</p>
</td></tr>
<tr><td><code id="secsse_ml_func_def_pars_+3A_parsfix">parsfix</code></td>
<td>
<p>a numeric vector with the value of the fixed parameters.</p>
</td></tr>
<tr><td><code id="secsse_ml_func_def_pars_+3A_idparsfuncdefpar">idparsfuncdefpar</code></td>
<td>
<p>id of the parameters which will be a function of
optimized and/or fixed parameters. The order of id should match
<code>functions_defining_params</code>.</p>
</td></tr>
<tr><td><code id="secsse_ml_func_def_pars_+3A_functions_defining_params">functions_defining_params</code></td>
<td>
<p>a list of functions. Each element will be a
function which defines a parameter e.g. <code>id_3 &lt;- (id_1 + id_2) / 2</code>. See
example.</p>
</td></tr>
<tr><td><code id="secsse_ml_func_def_pars_+3A_cond">cond</code></td>
<td>
<p>condition on the existence of a node root: <code>"maddison_cond"</code>,
<code>"proper_cond"</code> (default). For details, see vignette.</p>
</td></tr>
<tr><td><code id="secsse_ml_func_def_pars_+3A_root_state_weight">root_state_weight</code></td>
<td>
<p>the method to weigh the states:
<code>"maddison_weights"</code>, <code>"proper_weights"</code> (default) or <code>"equal_weights"</code>.
It can also be specified for the root state: the vector <code>c(1, 0, 0)</code>
indicates state 1 was the root state.</p>
</td></tr>
<tr><td><code id="secsse_ml_func_def_pars_+3A_sampling_fraction">sampling_fraction</code></td>
<td>
<p>vector that states the sampling proportion per
trait state. It must have as many elements as there are trait states.</p>
</td></tr>
<tr><td><code id="secsse_ml_func_def_pars_+3A_tol">tol</code></td>
<td>
<p>A numeric vector with the maximum tolerance of the optimization
algorithm. Default is <code>c(1e-04, 1e-05, 1e-05)</code>.</p>
</td></tr>
<tr><td><code id="secsse_ml_func_def_pars_+3A_maxiter">maxiter</code></td>
<td>
<p>max number of iterations. Default is
<code>1000 * round((1.25) ^ length(idparsopt))</code>.</p>
</td></tr>
<tr><td><code id="secsse_ml_func_def_pars_+3A_optimmethod">optimmethod</code></td>
<td>
<p>A string with method used for optimization. Default is
<code>"subplex"</code>. Alternative is <code>"simplex"</code> and it shouldn't be used in normal
conditions (only for debugging). Both are called from <code><a href="DDD.html#topic+optimizer">DDD::optimizer()</a></code>,
simplex is implemented natively in <a href="DDD.html#topic+DDD">DDD</a>, while subplex is ultimately
called from <code><a href="subplex.html#topic+subplex">subplex::subplex()</a></code>.</p>
</td></tr>
<tr><td><code id="secsse_ml_func_def_pars_+3A_num_cycles">num_cycles</code></td>
<td>
<p>Number of cycles of the optimization. When set to <code>Inf</code>,
the optimization will be repeated until the result is, within the
tolerance, equal to the starting values, with a maximum of 10 cycles.</p>
</td></tr>
<tr><td><code id="secsse_ml_func_def_pars_+3A_loglik_penalty">loglik_penalty</code></td>
<td>
<p>the size of the penalty for all parameters; default is
0 (no penalty).</p>
</td></tr>
<tr><td><code id="secsse_ml_func_def_pars_+3A_is_complete_tree">is_complete_tree</code></td>
<td>
<p>logical specifying whether or not a tree with all its
extinct species is provided. If set to <code>TRUE</code>, it also assumes that all
<em>all</em> extinct lineages are present on the tree. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="secsse_ml_func_def_pars_+3A_num_threads">num_threads</code></td>
<td>
<p>number of threads to be used. Default is one thread.</p>
</td></tr>
<tr><td><code id="secsse_ml_func_def_pars_+3A_atol">atol</code></td>
<td>
<p>A numeric specifying the absolute tolerance of integration.</p>
</td></tr>
<tr><td><code id="secsse_ml_func_def_pars_+3A_rtol">rtol</code></td>
<td>
<p>A numeric specifying the relative tolerance of integration.</p>
</td></tr>
<tr><td><code id="secsse_ml_func_def_pars_+3A_method">method</code></td>
<td>
<p>integration method used, available are:
<code>"odeint::runge_kutta_cash_karp54"</code>, <code>"odeint::runge_kutta_fehlberg78"</code>,
<code>"odeint::runge_kutta_dopri5"</code>, <code>"odeint::bulirsch_stoer"</code> and
<code>"odeint::runge_kutta4"</code>. Default method is: <code>"odeint::bulirsch_stoer"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Parameter estimated and maximum likelihood
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example of how to set the arguments for a ML search.
rm(list=ls(all=TRUE))
library(secsse)
library(DDD)
set.seed(16)
phylotree &lt;- ape::rbdtree(0.07,0.001,Tmax=50)
startingpoint&lt;-bd_ML(brts = ape::branching.times(phylotree))
intGuessLamba &lt;- startingpoint$lambda0
intGuessMu &lt;- startingpoint$mu0
traits &lt;- sample(c(0,1,2), ape::Ntip(phylotree),replace=TRUE) #get some traits
num_concealed_states&lt;-3
idparslist&lt;-id_paramPos(traits, num_concealed_states)
idparslist[[1]][c(1,4,7)] &lt;- 1
idparslist[[1]][c(2,5,8)] &lt;- 2
idparslist[[1]][c(3,6,9)] &lt;- 3
idparslist[[2]][] &lt;- 4
masterBlock &lt;- matrix(c(5,6,5,6,5,6,5,6,5),ncol = 3,nrow = 3,byrow = TRUE)
diag(masterBlock) &lt;- NA
diff.conceal &lt;- FALSE
idparslist[[3]] &lt;- q_doubletrans(traits,masterBlock,diff.conceal)
idparsfuncdefpar &lt;- c(3,5,6)
idparsopt &lt;- c(1,2)
idparsfix &lt;- c(0,4)
initparsopt &lt;- c(rep(intGuessLamba,2))
parsfix &lt;- c(0,0)
idfactorsopt &lt;- 1
initfactors &lt;- 4
# functions_defining_params is a list of functions. Each function has no
# arguments and to refer
# to parameters ids should be indicated as "par_" i.e. par_3 refers to
# parameter 3. When a function is defined, be sure that all the parameters
# involved are either estimated, fixed or
# defined by previous functions (i.e, a function that defines parameter in
# 'functions_defining_params'). The user is responsible for this. In this
# exampl3, par_3 (i.e., parameter 3) is needed to calculate par_6. This is
# correct because par_3 is defined in
# the first function of 'functions_defining_params'. Notice that factor_1
# indicates a value that will be estimated to satisfy the equation. The same
# factor can be shared to define several parameters.
functions_defining_params &lt;- list()
functions_defining_params[[1]] &lt;- function(){
 par_3 &lt;- par_1 + par_2
}
functions_defining_params[[2]] &lt;- function(){
 par_5 &lt;- par_1 * factor_1
}
functions_defining_params[[3]] &lt;- function(){
 par_6 &lt;- par_3 * factor_1
}

tol = c(1e-02, 1e-03, 1e-04)
maxiter = 1000 * round((1.25)^length(idparsopt))
optimmethod = "subplex"
cond&lt;-"proper_cond"
root_state_weight &lt;- "proper_weights"
sampling_fraction &lt;- c(1,1,1)
model &lt;- secsse_ml_func_def_pars(phylotree,
traits,
num_concealed_states,
idparslist,
idparsopt,
initparsopt,
idfactorsopt,
initfactors,
idparsfix,
parsfix,
idparsfuncdefpar,
functions_defining_params,
cond,
root_state_weight,
sampling_fraction,
tol,
maxiter,
optimmethod,
num_cycles = 1)
# ML -136.5796
</code></pre>

<hr>
<h2 id='secsse_sim'>Function to simulate a tree, conditional on observing all states.</h2><span id='topic+secsse_sim'></span>

<h3>Description</h3>

<p>By default, secsse_sim assumes CLA-secsse simulation, e.g.
inheritance of traits at speciation need not be symmetrical, and can be
specified through usage of lambda-matrices. Hence, the input for lambdas
is typically a list of matrices.
</p>
<p>Simulation is performed with a randomly
sampled initial trait at the crown - if you, however - want a specific,
single, trait used at the crown, you can reduce the possible traits by
modifying <code>pool_init_states</code>.
</p>
<p>By default, the algorithm keeps simulating until it generates a tree where
both crown lineages survive to the present - this is to ensure that the tree
has a crown age that matches the used crown age. You can modify
'non-extinction' to deviate from this behaviour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>secsse_sim(
  lambdas,
  mus,
  qs,
  crown_age,
  num_concealed_states,
  pool_init_states = NULL,
  max_spec = 1e+05,
  min_spec = 2,
  max_species_extant = TRUE,
  tree_size_hist = FALSE,
  conditioning = "obs_states",
  non_extinction = TRUE,
  verbose = FALSE,
  max_tries = 1e+06,
  drop_extinct = TRUE,
  start_at_crown = TRUE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="secsse_sim_+3A_lambdas">lambdas</code></td>
<td>
<p>speciation rates, in the form of a list of matrices.</p>
</td></tr>
<tr><td><code id="secsse_sim_+3A_mus">mus</code></td>
<td>
<p>extinction rates, in the form of a vector.</p>
</td></tr>
<tr><td><code id="secsse_sim_+3A_qs">qs</code></td>
<td>
<p>The Q matrix, for example the result of function q_doubletrans, but
generally in the form of a matrix.</p>
</td></tr>
<tr><td><code id="secsse_sim_+3A_crown_age">crown_age</code></td>
<td>
<p>crown age of the tree, tree will be simulated conditional
on non-extinction and this crown age.</p>
</td></tr>
<tr><td><code id="secsse_sim_+3A_num_concealed_states">num_concealed_states</code></td>
<td>
<p>number of concealed states, generally equivalent
to the number of examined states in the dataset.</p>
</td></tr>
<tr><td><code id="secsse_sim_+3A_pool_init_states">pool_init_states</code></td>
<td>
<p>pool of initial states at the crown, in case this is
different from all available states, otherwise leave at NULL</p>
</td></tr>
<tr><td><code id="secsse_sim_+3A_max_spec">max_spec</code></td>
<td>
<p>Maximum number of species in the tree (please note that the
tree is not conditioned on this number, but that this is a safeguard
against generating extremely large trees).</p>
</td></tr>
<tr><td><code id="secsse_sim_+3A_min_spec">min_spec</code></td>
<td>
<p>Minimum number of species in the tree.</p>
</td></tr>
<tr><td><code id="secsse_sim_+3A_max_species_extant">max_species_extant</code></td>
<td>
<p>Should the maximum number of species be counted in
the reconstructed tree (if TRUE) or in the complete tree (if FALSE).</p>
</td></tr>
<tr><td><code id="secsse_sim_+3A_tree_size_hist">tree_size_hist</code></td>
<td>
<p>if TRUE, returns a vector of all found tree sizes.</p>
</td></tr>
<tr><td><code id="secsse_sim_+3A_conditioning">conditioning</code></td>
<td>
<p>can be <code>"obs_states"</code>, <code>"true_states"</code> or <code>"none"</code>, the
tree is simulated until one is generated that contains all observed states
(<code>"obs_states"</code>), all true states (e.g. all combinations of obs and hidden
states), or is always returned (<code>"none"</code>). Alternatively, a vector with
the names of required observed states can be provided, e.g. c(&quot;S&quot;, &quot;N&quot;).</p>
</td></tr>
<tr><td><code id="secsse_sim_+3A_non_extinction">non_extinction</code></td>
<td>
<p>boolean stating if the tree should be conditioned on
non-extinction of the crown lineages. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="secsse_sim_+3A_verbose">verbose</code></td>
<td>
<p>sets verbose output; default is <code>TRUE</code> when <code>optimmethod</code> is
<code>"simplex"</code>. If <code>optimmethod</code> is set to <code>"simplex"</code>, then even if set to
<code>FALSE</code>, optimizer output will be shown.</p>
</td></tr>
<tr><td><code id="secsse_sim_+3A_max_tries">max_tries</code></td>
<td>
<p>maximum number of simulations to try to obtain a tree.</p>
</td></tr>
<tr><td><code id="secsse_sim_+3A_drop_extinct">drop_extinct</code></td>
<td>
<p>boolean stating if extinct species should be dropped from
the tree. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="secsse_sim_+3A_start_at_crown">start_at_crown</code></td>
<td>
<p>if FALSE, the simulation starts with one species
instead of the two assumed by default by secsse (also in ML), and
the resulting crown age will be lower than the set crown age. This allows
for direct comparison with BiSSE and facilitates implementing speciation
effects at the crown.</p>
</td></tr>
<tr><td><code id="secsse_sim_+3A_seed">seed</code></td>
<td>
<p>pseudo-random number generator seed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with four properties: phy: reconstructed phylogeny,
true_traits: the true traits in order of tip label, obs_traits: observed
traits, ignoring hidden traits and lastly:
initialState, delineating the initial state at the root used.
</p>

<hr>
<h2 id='sortingtraits'>Data checking and trait sorting
In preparation for likelihood calculation, it orders trait data according
the tree tips</h2><span id='topic+sortingtraits'></span>

<h3>Description</h3>

<p>Data checking and trait sorting
In preparation for likelihood calculation, it orders trait data according
the tree tips
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortingtraits(trait_info, phy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sortingtraits_+3A_trait_info">trait_info</code></td>
<td>
<p>data frame where first column has species ids and the second
one is the trait associated information.</p>
</td></tr>
<tr><td><code id="sortingtraits_+3A_phy">phy</code></td>
<td>
<p>phylogenetic tree of class <code>phylo</code>, rooted and with
branch lengths.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of traits
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Some data we have prepared
data(traits)
data('phylo_vignette')
traits &lt;- sortingtraits(traits, phylo_vignette)
</code></pre>

<hr>
<h2 id='traits'>A table with trait info to run the vignette</h2><span id='topic+traits'></span>

<h3>Description</h3>

<p>An example of trait information in the right format for secsse
</p>


<h3>Usage</h3>

<pre><code class='language-R'>traits
</code></pre>


<h3>Format</h3>

<p>A data frame where each species has a trait state associated
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
