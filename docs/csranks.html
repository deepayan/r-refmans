<!DOCTYPE html><html><head><title>Help for package csranks</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {csranks}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#csranks'><p>Confidence sets for ranks</p></a></li>
<li><a href='#csranks_multinom'><p>Confidence sets for ranks based on multinomial data</p></a></li>
<li><a href='#cstaubest'><p>Confidence sets for the tau-best</p></a></li>
<li><a href='#irank'><p>Compute ranks</p></a></li>
<li><a href='#irank_against'><p>Compute integer ranks in another reference vector</p></a></li>
<li><a href='#lmranks'><p>Regressions Involving Ranks</p></a></li>
<li><a href='#parent_child_income'><p>Income of parents and children</p></a></li>
<li><a href='#pisa'><p>Cross-country comparison of students' achievement</p></a></li>
<li><a href='#pisa2018'><p>Cross-country comparison of students' achievement</p></a></li>
<li><a href='#plot.csranks'><p>Plot ranking with confidence sets</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Tools for Ranks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Account for uncertainty when working with ranks. 
    Estimate standard errors consistently in linear regression with ranked variables.
    Construct confidence sets of various kinds for positions of populations in a ranking 
    based on values of a certain feature and their estimation errors. 
    Theory based on Mogstad, Romano, Shaikh, and Wilhelm (2023)&lt;<a href="https://doi.org/10.1093%2Frestud%2Frdad006">doi:10.1093/restud/rdad006</a>&gt; and
    Chetverikov and Wilhelm (2023) &lt;<a href="https://doi.org/10.48550/arXiv.2310.15512">doi:10.48550/arXiv.2310.15512</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/danielwilhelm/R-CS-ranks">https://github.com/danielwilhelm/R-CS-ranks</a>,
<a href="https://danielwilhelm.github.io/R-CS-ranks/">https://danielwilhelm.github.io/R-CS-ranks/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/danielwilhelm/R-CS-ranks/issues">https://github.com/danielwilhelm/R-CS-ranks/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, ggplot2, scales, MASS, cli, lifecycle</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spelling, testthat (&ge; 2.1.0), grid, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-24 16:16:01 UTC; mrdomani</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Wilhelm [aut, cre],
  Pawel Morgen [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Wilhelm &lt;d.wilhelm@lmu.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-24 17:22:46 UTC</td>
</tr>
</table>
<hr>
<h2 id='csranks'>Confidence sets for ranks</h2><span id='topic+csranks'></span>

<h3>Description</h3>

<p>Marginal and simultaneous confidence sets for ranks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csranks(
  x,
  Sigma,
  coverage = 0.95,
  cstype = "two-sided",
  stepdown = TRUE,
  R = 1000,
  simul = TRUE,
  indices = NA,
  na.rm = FALSE,
  seed = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csranks_+3A_x">x</code></td>
<td>
<p>vector of estimates containing estimated features by which the <code>length</code> populations are to be ranked.</p>
</td></tr>
<tr><td><code id="csranks_+3A_sigma">Sigma</code></td>
<td>
<p>estimated covariance matrix of <code>x</code>.</p>
</td></tr>
<tr><td><code id="csranks_+3A_coverage">coverage</code></td>
<td>
<p>nominal coverage of the confidence set. Default is 0.95.</p>
</td></tr>
<tr><td><code id="csranks_+3A_cstype">cstype</code></td>
<td>
<p>type of confidence set (<code>two-sided</code>, <code>upper</code>, <code>lower</code>). Default is <code>two-sided</code>.</p>
</td></tr>
<tr><td><code id="csranks_+3A_stepdown">stepdown</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), stepwise procedure is used, otherwise single step procedure is used. See Details section for more.</p>
</td></tr>
<tr><td><code id="csranks_+3A_r">R</code></td>
<td>
<p>number of bootstrap replications. Default is 1000.</p>
</td></tr>
<tr><td><code id="csranks_+3A_simul">simul</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), then simultaneous confidence sets are computed, which jointly cover all populations indicated by <code>indices</code>.
Otherwise, for each population indicated in <code>indices</code> a marginal confidence set is computed.</p>
</td></tr>
<tr><td><code id="csranks_+3A_indices">indices</code></td>
<td>
<p>vector of indices of <code>x</code> for whose ranks the confidence sets are computed. <code>indices=NA</code> (default) means computation of confidence sets for all populations.</p>
</td></tr>
<tr><td><code id="csranks_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; if <code>TRUE</code>, then <code>NA</code>'s are removed from <code>x</code> and <code>Sigma</code> (if any).</p>
</td></tr>
<tr><td><code id="csranks_+3A_seed">seed</code></td>
<td>
<p>seed for bootstrap random variable draws. If set to <code>NA</code> (default), then seed is not set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>csranks</code> object, which is a list with three items:
</p>

<dl>
<dt><code>L</code></dt><dd><p>Lower bounds of the confidence sets for ranks indicated in <code>indices</code></p>
</dd>
<dt><code>rank</code></dt><dd><p>Estimated ranks from <code><a href="#topic+irank">irank</a></code> with default parameters</p>
</dd>
<dt><code>U</code></dt><dd><p>Upper bounds of the confidence sets.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Suppose <code class="reqn">j=1,\ldots,p</code> populations (e.g., schools, hospitals, political parties, countries) are to be ranked according to
some measure <code class="reqn">\theta=(\theta_1,\ldots,\theta_p)</code>. We do not observe the true values <code class="reqn">\theta_1,\ldots,\theta_p</code>. Instead, for each population,
we have data from which we have estimated these measures, <code class="reqn">\hat{\theta}=(\hat{\theta}_1,\ldots,\hat{\theta}_p)</code>. The values <code class="reqn">\hat{\theta}_1,\ldots,\hat{\theta}_p</code>
are estimates of the true values <code class="reqn">\theta_1,\ldots,\theta_p</code> and thus contain statistical uncertainty. In consequence, a ranking of the populations by
the values <code class="reqn">\hat{\theta}_1,\ldots,\hat{\theta}_p</code> contains statistical uncertainty and is not necessarily equal to the true ranking of <code class="reqn">\theta_1,\ldots,\theta_p</code>.
</p>
<p>The function computes confidence sets for the rank of one, several or all of the populations (<code>indices</code> indicates which of the <code class="reqn">1,\ldots,p</code> populations are of interest). <code>x</code> is a vector containing the estimates
<code class="reqn">\hat{\theta}_1,\ldots,\hat{\theta}_p</code> and <code>Sigma</code> is an estimate of the covariance matrix of <code>x</code>. The method assumes that the estimates are asymptotically normal and the sample sizes of the datasets
are large enough so that <code class="reqn">\hat{\theta}-\theta</code> is approximately distributed as <code class="reqn">N(0,\Sigma)</code>. The argument <code>Sigma</code> should contain an estimate of the covariance matrix <code class="reqn">\Sigma</code>. For instance, if for each population <code class="reqn">j</code>
</p>
<p style="text-align: center;"><code class="reqn">\sqrt{n_j} (\hat{\theta}_j-\theta_j) \to_d N(0, \sigma_j^2)</code>
</p>

<p>and the datasets for each population are drawn independently of each other, then <code>Sigma</code> is a diagonal matrix </p>
<p style="text-align: center;"><code class="reqn">diag(\hat{\sigma}_1^2/n_1,\ldots,\hat{\sigma}_p^2/n_p)</code>
</p>

<p>containing estimates of the asymptotic variances divided by the sample size. More generally, the estimates in <code>x</code> may be dependent, but then <code>Sigma</code>
must be an estimate of its covariance matrix including off-diagonal terms.
</p>
<p>Marginal confidence sets (<code>simul=FALSE</code>) are such that the confidence set for a population <code class="reqn">j</code> contains the true rank of that population <code class="reqn">j</code> with probability approximately
equal to the nominal coverage level. Simultaneous confidence sets (<code>simul=TRUE</code>) on the other hand are such that the confidence sets for populations indicated in <code>indices</code> cover the true ranks
of all of these populations simultaneously with probability approximately equal to the nominal coverage level. For instance, in the PISA example below, a marginal confidence set of a country <code class="reqn">j</code> covers the true
rank of country <code class="reqn">j</code> with probability approximately equal to 0.95. A simultaneous confidence set for all countries covers the true ranks of all countries simultaneously with probability approximately equal to 0.95.
</p>
<p>The function implements the procedures developed and described in more detail in Mogstad, Romano, Shaikh, and Wilhelm (2023). The procedure is based on
on testing a large family of hypotheses for pairwise comparisons. Stepwise methods can be used to improve the power of the procedure by, potentially,
rejecting more hypotheses without violating the desired coverage property of the resulting confidence set. These are employed when
<code>stepdown=TRUE</code>. From a practical point of view, <code>stepdown=TRUE</code> is computationally more demanding, but often results
in tighter confidence sets.
</p>
<p>The procedure uses a parametric bootstrap procedure based on the above approximate multivariate normal distribution.
</p>


<h3>References</h3>

<p>Mogstad, Romano, Shaikh, and Wilhelm (2023), &quot;Inference for Ranks with Applications to Mobility across Neighborhoods and Academic Achievements across Countries&quot;, forthcoming at Review of Economic Studies
<a href="http://dwilhelm.userweb.mwn.de/papers/cwp0323.pdf">cemmap working paper</a>
<a href="https://doi.org/10.1093/restud/rdad006">doi:10.1093/restud/rdad006</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple simulated example:
n &lt;- 100
p &lt;- 10
X &lt;- matrix(rep(1:p,n)/p, ncol=p, byrow=TRUE) + matrix(rnorm(n*p), 100, 10)
thetahat &lt;- colMeans(X)
Sigmahat &lt;- cov(X) / n
csranks(thetahat, Sigmahat)

# PISA example:
attach(pisa)
math_cov_mat &lt;- diag(math_se^2)

# marginal confidence set for each country:
csranks(math_score, math_cov_mat, simul=FALSE)

# simultaneous confidence set for all countries:
csranks(math_score, math_cov_mat, simul=TRUE)
</code></pre>

<hr>
<h2 id='csranks_multinom'>Confidence sets for ranks based on multinomial data</h2><span id='topic+csranks_multinom'></span>

<h3>Description</h3>

<p>Marginal and simultaneous confidence sets for ranks of categories, where categories are ranked by the probabilities of being chosen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csranks_multinom(
  x,
  coverage = 0.95,
  cstype = "two-sided",
  simul = TRUE,
  multcorr = "Holm",
  indices = NA,
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csranks_multinom_+3A_x">x</code></td>
<td>
<p>vector of counts indicating how often each category was chosen.</p>
</td></tr>
<tr><td><code id="csranks_multinom_+3A_coverage">coverage</code></td>
<td>
<p>nominal coverage of the confidence set. Default is 0.95.</p>
</td></tr>
<tr><td><code id="csranks_multinom_+3A_cstype">cstype</code></td>
<td>
<p>type of confidence set (<code>two-sided</code>, <code>upper</code>, <code>lower</code>). Default is <code>two-sided</code>.</p>
</td></tr>
<tr><td><code id="csranks_multinom_+3A_simul">simul</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), then simultaneous confidence sets are computed, which jointly cover all populations indicated by <code>indices</code>.
Otherwise, for each population indicated in <code>indices</code> a marginal confidence set is computed.</p>
</td></tr>
<tr><td><code id="csranks_multinom_+3A_multcorr">multcorr</code></td>
<td>
<p>multiplicity correction to be used: <code>Holm</code> (default) or <code>Bonferroni</code>. See Details section for more.</p>
</td></tr>
<tr><td><code id="csranks_multinom_+3A_indices">indices</code></td>
<td>
<p>vector of indices of <code>x</code> for whose ranks the confidence sets are computed. <code>indices=NA</code> (default) means computation of confidence sets for all populations.</p>
</td></tr>
<tr><td><code id="csranks_multinom_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; if <code>TRUE</code>, then <code>NA</code>'s are removed from <code>x</code> and <code>Sigma</code> (if any).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>csranks</code> object, which is a list with three items:
</p>

<dl>
<dt><code>L</code></dt><dd><p>Lower bounds of the confidence sets for ranks indicated in <code>indices</code></p>
</dd>
<dt><code>rank</code></dt><dd><p>Estimated ranks from <code><a href="#topic+irank">irank</a></code> with default parameters</p>
</dd>
<dt><code>U</code></dt><dd><p>Upper bounds of the confidence sets.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This function computes confidence sets for ranks similarly as <code><a href="#topic+csranks">csranks</a></code>, but it is tailored to the special case of
multinomial data. Suppose there are <code class="reqn">p</code> populations (for the case of multinomial data, we will refer to them as &quot;categories&quot;) such
as political parties, for example, that one wants to rank by the probabilities of them being chosen. For political parties, this would
correspond to the share of votes each party obtains. Here, the underlying data are multinomial: each observation corresponds to a choice
among the <code class="reqn">p</code> categories. The vector <code>x</code> contains the counts of how often each category was chosen in the data.
</p>
<p>In this setting, <code>link{csranks}</code> could be applied to compute confidence sets for the ranks of each category, but instead this function
implements a different method proposed by Bazylik, Mogstad, Romano, Shaikh, and Wilhelm (2023), which exploits the
multinomial structure of the problem and yields confidence sets for the ranks that are valid in finite samples (whereas <code><a href="#topic+csranks">csranks</a></code> produces
confidence sets that are valid only asymptotically).
</p>
<p>The procedure involves testing multiple hypotheses. The <code style="white-space: pre;">&#8288;\code{multcorr}&#8288;</code> indicates a method for multiplicity correction. See the paper for
details.
</p>


<h3>References</h3>

<p>Bazylik, Mogstad, Romano, Shaikh, and Wilhelm.
&quot;Finite-and large-sample inference for ranks using multinomial data with an application to ranking political parties&quot;.
<a href="http://dwilhelm.userweb.mwn.de/papers/cwp4021.pdf">cemmap working paper</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(rmultinom(1, 1000, 1:10))
csranks_multinom(x)
</code></pre>

<hr>
<h2 id='cstaubest'>Confidence sets for the tau-best</h2><span id='topic+cstaubest'></span><span id='topic+cstauworst'></span>

<h3>Description</h3>

<p>Computation of confidence sets for the identities of populations among the tau best.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cstaubest(
  x,
  Sigma,
  tau = 2,
  coverage = 0.95,
  stepdown = TRUE,
  R = 1000,
  na.rm = FALSE,
  seed = NA
)

cstauworst(
  x,
  Sigma,
  tau = 2,
  coverage = 0.95,
  stepdown = TRUE,
  R = 1000,
  na.rm = FALSE,
  seed = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cstaubest_+3A_x">x</code></td>
<td>
<p>vector of estimates containing estimated features by which the <code>length</code> populations are to be ranked.</p>
</td></tr>
<tr><td><code id="cstaubest_+3A_sigma">Sigma</code></td>
<td>
<p>estimated covariance matrix of <code>x</code>.</p>
</td></tr>
<tr><td><code id="cstaubest_+3A_tau">tau</code></td>
<td>
<p>the confidence set contains indicators for the elements in <code>x</code> whose rank is less than or equal to <code>tau</code>.</p>
</td></tr>
<tr><td><code id="cstaubest_+3A_coverage">coverage</code></td>
<td>
<p>nominal coverage of the confidence set. Default is 0.95.</p>
</td></tr>
<tr><td><code id="cstaubest_+3A_stepdown">stepdown</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), stepwise procedure is used, otherwise single step procedure is used. See Details section for more.</p>
</td></tr>
<tr><td><code id="cstaubest_+3A_r">R</code></td>
<td>
<p>number of bootstrap replications. Default is 1000.</p>
</td></tr>
<tr><td><code id="cstaubest_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; if <code>TRUE</code>, then <code>NA</code>'s are removed from <code>x</code> and <code>Sigma</code> (if any).</p>
</td></tr>
<tr><td><code id="cstaubest_+3A_seed">seed</code></td>
<td>
<p>seed for bootstrap random variable draws. If set to <code>NA</code> (default), then seed is not set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector indicating which of the elements of <code>x</code> are in the confidence set for the tau-best.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>cstauworst()</code>: Confidence sets for the tau-worst
</p>
<p>Equivalent to calling <code>cstaubest</code> with <code>-x</code>.
</p>
</li></ul>


<h3>Details</h3>

<p>The function computes a confidence set containing indicators for the elements in <code>x</code> whose rank is less than or equal to <code>tau</code> with probability approximately equal to the nominal coverage (<code>coverage</code>).
</p>
<p>The function implements the projection confidence set for the tau-best developed and described in more detail in Mogstad, Romano, Shaikh, and Wilhelm (2023).
</p>


<h3>References</h3>

<p>Mogstad, Romano, Shaikh, and Wilhelm (2023), &quot;Inference for Ranks with Applications to Mobility across Neighborhoods and Academic Achievements across Countries&quot;, forthcoming at Review of Economic Studies
<a href="http://dwilhelm.userweb.mwn.de/papers/cwp0323.pdf">cemmap working paper</a>, <a href="https://doi.org/10.1093/restud/rdad006">doi:10.1093/restud/rdad006</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple simulated example:
n &lt;- 100
p &lt;- 10
X &lt;- matrix(rep(1:p,n)/p, ncol=p, byrow=TRUE) + matrix(rnorm(n*p), 100, 10)
thetahat &lt;- colMeans(X)
Sigmahat &lt;- cov(X) / n

# confidence set for the populations that may be among the top-3 
# (with probability approximately 0.95):
cstaubest(thetahat, Sigmahat, tau=3)

# confidence set for the populations that may be among the bottom-3 
# (with probability approximately 0.95):
cstauworst(thetahat, Sigmahat, tau=3)

</code></pre>

<hr>
<h2 id='irank'>Compute ranks</h2><span id='topic+irank'></span><span id='topic+frank'></span>

<h3>Description</h3>

<p>Compute ranks with flexible handling of ties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irank(x, omega = 0, increasing = FALSE, na.rm = FALSE)

frank(x, omega = 0, increasing = FALSE, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irank_+3A_x">x</code></td>
<td>
<p>vector of values to be ranked</p>
</td></tr>
<tr><td><code id="irank_+3A_omega">omega</code></td>
<td>
<p>numeric value in [0,1], defining how ties in <code>x</code> (if any) are handled; default is <code>0</code>. See Details.</p>
</td></tr>
<tr><td><code id="irank_+3A_increasing">increasing</code></td>
<td>
<p>logical; if <code>FALSE</code> (default), then large elements in <code>x</code> receive a small rank. Otherwise, large elements in <code>x</code> receive a large rank.</p>
</td></tr>
<tr><td><code id="irank_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; if <code>TRUE</code>, then <code>NA</code>'s are removed from <code>x</code>. Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements all possible definitions of ranks of the values in <code>x</code>. Different definitions of the ranks are chosen through combinations of the two arguments
<code>omega</code> and <code>increasing</code>. Suppose <code>x</code> is of length <code class="reqn">p</code>. If <code>increasing=TRUE</code>, then the largest value in <code>x</code> receives the rank <code class="reqn">p</code> and the smallest
the rank <code class="reqn">1</code>. If <code>increasing=FALSE</code>, then the largest value in <code>x</code> receives the rank <code class="reqn">1</code> and the smallest
the rank <code class="reqn">p</code>.
</p>
<p>The value of <code>omega</code> indicates how ties are handled. If there are no ties in <code>x</code>, then the value of <code>omega</code> does not affect the ranks and the only choice to be made is whether
the ranks should be increasing or decreasing with the values in <code>x</code>. When there are ties in <code>x</code>, however, then there are infinitely
many possible ranks that can be assigned to a tied value.
</p>
<p>When <code>increasing=TRUE</code>, then <code>omega=0</code> leads to the smallest possible and <code>omega=1</code> to the largest possible rank of a tied value. Values of <code>omega</code> between
0 and 1 lead to values of the rank between the largest and smallest.
</p>


<h3>Value</h3>

<p>Integer vector of the same length as <code>x</code> containing the ranks.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>frank()</code>: Compute fractional ranks
</p>
<p>This function takes the ranking returned by <code>irank</code> and divides the result by <code>length(x)</code>. The result is a ranking with
ranks in the interval [0,1]. An important special case occurs for <code>increasing=TRUE</code> and <code>omega=1</code>: in this case, the rank
of the value <code>x[j]</code> is equal to the empirical cdf of <code>x</code> evaluated at <code>x[j]</code>.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># simple example without ties:
x &lt;- c(3,8,-4,10,2)
irank(x, increasing=TRUE)
irank(x, increasing=FALSE)

# since there are no ties, the value of omega has no impact:
irank(x, increasing=TRUE, omega=0)
irank(x, increasing=TRUE, omega=0.5)
irank(x, increasing=TRUE, omega=1)

# simple example with ties:
x &lt;- c(3,4,7,7,10,11,15,15,15,15)
irank(x, increasing=TRUE, omega=0) # smallest possible ranks
irank(x, increasing=TRUE, omega=0.5) # mid-ranks
irank(x, increasing=TRUE, omega=1) # largest possible ranks

# simple example of fractional ranks without ties:
x &lt;- c(3,8,-4,10,2)
frank(x, increasing=TRUE)
frank(x, increasing=FALSE)
</code></pre>

<hr>
<h2 id='irank_against'>Compute integer ranks in another reference vector</h2><span id='topic+irank_against'></span><span id='topic+frank_against'></span>

<h3>Description</h3>

<p>The method <code><a href="#topic+irank">irank</a></code> compares ranks using the same vector as reference.
This method returns ranks, that values from <code>x</code> would assume if (individually)
inserted into <code>v</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irank_against(x, v, omega = 0, increasing = FALSE, na.rm = FALSE)

frank_against(x, v, omega = 0, increasing = FALSE, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irank_against_+3A_x">x</code></td>
<td>
<p>numeric query vector.</p>
</td></tr>
<tr><td><code id="irank_against_+3A_v">v</code></td>
<td>
<p>numeric reference vector.</p>
</td></tr>
<tr><td><code id="irank_against_+3A_omega">omega</code></td>
<td>
<p>numeric value in [0,1], defining how ties in <code>x</code> (if any) are handled; default is <code>0</code>. See Details.</p>
</td></tr>
<tr><td><code id="irank_against_+3A_increasing">increasing</code></td>
<td>
<p>logical; if <code>FALSE</code> (default), then large elements in <code>x</code> receive a small rank. Otherwise, large elements in <code>x</code> receive a large rank.</p>
</td></tr>
<tr><td><code id="irank_against_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; if <code>TRUE</code>, then <code>NA</code>'s are removed from <code>x</code>. Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements all possible definitions of ranks of the values in <code>x</code>. Different definitions of the ranks are chosen through combinations of the two arguments
<code>omega</code> and <code>increasing</code>. Suppose <code>x</code> is of length <code class="reqn">p</code>. If <code>increasing=TRUE</code>, then the largest value in <code>x</code> receives the rank <code class="reqn">p</code> and the smallest
the rank <code class="reqn">1</code>. If <code>increasing=FALSE</code>, then the largest value in <code>x</code> receives the rank <code class="reqn">1</code> and the smallest
the rank <code class="reqn">p</code>.
</p>
<p>The value of <code>omega</code> indicates how ties are handled. If there are no ties in <code>x</code>, then the value of <code>omega</code> does not affect the ranks and the only choice to be made is whether
the ranks should be increasing or decreasing with the values in <code>x</code>. When there are ties in <code>x</code>, however, then there are infinitely
many possible ranks that can be assigned to a tied value.
</p>
<p>When <code>increasing=TRUE</code>, then <code>omega=0</code> leads to the smallest possible and <code>omega=1</code> to the largest possible rank of a tied value. Values of <code>omega</code> between
0 and 1 lead to values of the rank between the largest and smallest.
</p>


<h3>Value</h3>

<p>Integer vector of the same length as <code>x</code> containing the ranks.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>frank_against()</code>: Compute integer ranks in another reference vector
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>irank_against(1:10, c(4,4,4,3,1,10,7,7))
</code></pre>

<hr>
<h2 id='lmranks'>Regressions Involving Ranks</h2><span id='topic+lmranks'></span><span id='topic+plot.lmranks'></span><span id='topic+predict.lmranks'></span><span id='topic+summary.lmranks'></span><span id='topic+vcov.lmranks'></span>

<h3>Description</h3>

<p>Estimation and inference for regressions involving ranks, i.e. regressions in which the dependent and/or the independent
variable has been transformed into ranks before running the regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmranks(
  formula,
  data,
  subset,
  weights,
  na.action = stats::na.fail,
  method = "qr",
  model = TRUE,
  x = FALSE,
  qr = TRUE,
  y = FALSE,
  singular.ok = TRUE,
  contrasts = NULL,
  offset = offset,
  omega = 1,
  ...
)

## S3 method for class 'lmranks'
plot(x, which = 1, ...)

## S3 method for class 'lmranks'
predict(object, newdata, ...)

## S3 method for class 'lmranks'
summary(object, correlation = FALSE, symbolic.cor = FALSE, ...)

## S3 method for class 'lmranks'
vcov(object, complete = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmranks_+3A_formula">formula</code></td>
<td>
<p>An object of class &quot;<code><a href="stats.html#topic+formula">formula</a></code>&quot;: a symbolic description
of the model to be fitted. Exactly like the formula for linear model except that
variables to be ranked can be indicated by <code>r()</code>. See Details and Examples below.</p>
</td></tr>
<tr><td><code id="lmranks_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing
the variables in the model.  If not found in <code>data</code>, the
variables are taken from <code>environment(formula)</code>,
typically the environment from which <code>lm</code> is called.</p>
</td></tr>
<tr><td><code id="lmranks_+3A_subset">subset</code></td>
<td>
<p>currently not supported.</p>
</td></tr>
<tr><td><code id="lmranks_+3A_weights">weights</code></td>
<td>
<p>currently not supported.</p>
</td></tr>
<tr><td><code id="lmranks_+3A_na.action">na.action</code></td>
<td>
<p>currently not supported. User is expected to handle NA values prior to the use of this function.</p>
</td></tr>
<tr><td><code id="lmranks_+3A_method">method</code></td>
<td>
<p>the method to be used; for fitting, currently only
<code>method = "qr"</code> is supported; <code>method = "model.frame"</code> returns
the model frame (the same as with <code>model = TRUE</code>, see below).</p>
</td></tr>
<tr><td><code id="lmranks_+3A_model">model</code>, <code id="lmranks_+3A_y">y</code>, <code id="lmranks_+3A_qr">qr</code></td>
<td>
<p>logicals. If TRUE the corresponding components of the fit (the model frame, the response, the QR decomposition) are returned.</p>
</td></tr>
<tr><td><code id="lmranks_+3A_x">x</code></td>
<td>

<ul>
<li><p> For <code>lmranks</code>: Logical. Should model matrix be returned?
</p>
</li>
<li><p> For <code>plot</code> method: An <code>lmranks</code> object.
</p>
</li></ul>
</td></tr>
<tr><td><code id="lmranks_+3A_singular.ok">singular.ok</code></td>
<td>
<p>logical. If <code>FALSE</code> (the default in S but
not in <span class="rlang"><b>R</b></span>) a singular fit is an error.</p>
</td></tr>
<tr><td><code id="lmranks_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the <code>contrasts.arg</code>
of <code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.</p>
</td></tr>
<tr><td><code id="lmranks_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em> known
component to be included in the linear predictor during fitting.
This should be <code>NULL</code> or a numeric vector or matrix of extents
matching those of the response.  One or more <code><a href="stats.html#topic+offset">offset</a></code> terms can be
included in the formula instead or as well, and if more than one are
specified their sum is used.  See <code><a href="stats.html#topic+model.offset">model.offset</a></code>.</p>
</td></tr>
<tr><td><code id="lmranks_+3A_omega">omega</code></td>
<td>
<p>real number in the interval [0,1] defining how ties are handled (if there are any).
The value of <code>omega</code> is passed to <code><a href="#topic+frank">frank</a></code> for computation of ranks.
The default is 1 so that the rank of a realized value is defined as the
empirical cdf evaluated at that realized value. See Details below.</p>
</td></tr>
<tr><td><code id="lmranks_+3A_...">...</code></td>
<td>
<p>For <code>lm()</code>: additional arguments to be passed to the low level
regression fitting functions (see below).</p>
</td></tr>
<tr><td><code id="lmranks_+3A_which">which</code></td>
<td>
<p>As in <code><a href="stats.html#topic+plot.lm">plot.lm</a></code>. Currently only no.1 is available.</p>
</td></tr>
<tr><td><code id="lmranks_+3A_object">object</code></td>
<td>
<p>A <code>lmranks</code> object.</p>
</td></tr>
<tr><td><code id="lmranks_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame in which to look for variables with which to predict. If omitted, the fitted values are used.</p>
</td></tr>
<tr><td><code id="lmranks_+3A_correlation">correlation</code></td>
<td>
<p>logical; if <code>TRUE</code>, the correlation matrix of
the estimated parameters is returned and printed.</p>
</td></tr>
<tr><td><code id="lmranks_+3A_symbolic.cor">symbolic.cor</code></td>
<td>
<p>logical. If <code>TRUE</code>, print the correlations in
a symbolic form (see <code><a href="stats.html#topic+symnum">symnum</a></code>) rather than as numbers.</p>
</td></tr>
<tr><td><code id="lmranks_+3A_complete">complete</code></td>
<td>
<p>logical indicating if the full variance-covariance matrix
should be returned also in case of an over-determined system where
some coefficients are undefined and <code>coef(.)</code> contains NAs correspondingly.
When <code>complete = TRUE</code>, <code>vcov()</code> is compatible with <code>coef()</code> also in this singular case.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs estimation and inference for regressions involving ranks. Suppose there is a dependent variable <code class="reqn">Y_i</code> and independent
variables <code class="reqn">X_i</code> and <code class="reqn">W_i</code>, where <code class="reqn">X_i</code> is a scalar and <code class="reqn">W_i</code> a vector (possibly including a constant). Instead of running a linear regression of <code class="reqn">Y_i</code> on <code class="reqn">X_i</code> and <code class="reqn">W_i</code>, we want to first transform
<code class="reqn">Y_i</code> and/or <code class="reqn">X_i</code> into ranks. Denote by <code class="reqn">R_i^Y</code> the rank of <code class="reqn">Y_i</code> and <code class="reqn">R_i^X</code> the rank of <code class="reqn">X_i</code>. Then, a
<strong>rank-rank regression</strong>, </p>
<p style="text-align: center;"><code class="reqn">R_i^Y = \rho R_i^X + W_i'\beta + \varepsilon_i,</code>
</p>
<p> is run using the formula <code>r(Y)~r(X)+W</code>. Similarly, a
<strong>regression of the raw dependent variable on the ranked regressor</strong>,
</p>
<p style="text-align: center;"><code class="reqn">Y_i = \rho R_i^X + W_i'\beta + \varepsilon_i,</code>
</p>
<p> can be implemented by the formula <code>Y~r(X)+W</code>, and a
<strong>regression of the ranked dependent variable on the raw regressors</strong>, </p>
<p style="text-align: center;"><code class="reqn">R^Y_i = W_i'\beta + \varepsilon_i,</code>
</p>
<p> can be implemented by the formula <code>r(Y)~W</code>.
</p>
<p>The function works, in many ways, just like <code>lm</code> for linear regressions. Apart from some smaller details, there are two important differences:
first, in <code>lmranks</code>, the mark <code>r()</code> can be used in formulas to indicate variables to be ranked before running the regression and, second,
subsequent use of <code>summary</code> produces a summary table with the correct standard errors, t-values and p-values (while those of the <code>lm</code> are not correct for
regressions involving ranks). See Chetverikov and Wilhelm (2023) for more details.
</p>
<p>Many other aspects of the function are similar to <code>lm</code>. For instance,
<code>.</code> in a formula means 'all columns not otherwise in the formula' just as in <code>lm</code>. An
intercept is included by default.
In a model specified as <code>r(Y)~r(X)+.</code>, both <code>r(X)</code> and <code>X</code> will be
included in the model - as it would have been in <code>lm</code> and, say,
<code>log()</code> instead of <code>r()</code>.
One can exclude <code>X</code> with a <code>-</code>, i.e. <code>r(Y)~r(X)+.-X</code>. See
<code><a href="stats.html#topic+formula">formula</a></code> for more about model specification.
</p>
<p>The <code>r()</code> is a private alias for <code><a href="#topic+frank">frank</a></code>.
The <code>increasing</code> argument, provided at individual regressor level,
specifies whether the ranks should increase or decrease as regressor values increase.
The <code>omega</code> argument of <code><a href="#topic+frank">frank</a></code>, provided at <code>lmranks</code> function level,
specifies how ties in variables are to be handled and
can be supplied as argument in <code>lmranks</code>. For more details, see <code><a href="#topic+frank">frank</a></code>.
By default <code>increasing</code> is set to <code>TRUE</code> and <code>omega</code> is set equal to <code>1</code>,
which means <code>r()</code> computes ranks by transforming a variable through its empirical cdf.
</p>
<p>Many functions defined for <code>lm</code> also work correctly with <code>lmranks</code>.
These include <code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="stats.html#topic+model.frame">model.frame</a></code>,
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code>, <code><a href="stats.html#topic+resid">resid</a></code>,
<code><a href="stats.html#topic+update">update</a></code> and others.
On the other hand, some would return incorrect results if they treated
<code>lmranks</code> output in the same way as <code>lm</code>'s. The central contribution of this package
are <code>vcov</code>, <code>summary</code> and <code>confint</code> implementations using the correct asymptotic theory for regressions involving ranks.
</p>
<p>See the <code><a href="stats.html#topic+lm">lm</a></code> documentation for more.
</p>


<h3>Value</h3>

<p>An object of class <code>lmranks</code>, inheriting (as much as possible) from class <code>lm</code>.
</p>
<p>Additionally, it has an <code>omega</code> entry, corresponding to the <code>omega</code> argument,
a <code>ranked_response</code> logical entry, and
a <code>rank_terms_indices</code> - an integer vector with indices of entries of <code>terms.labels</code> attribute
of <code>terms(formula)</code>, which correspond to ranked regressors.
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>plot(lmranks)</code>: Plot diagnostics for an <code>lmranks</code> object
</p>
<p>Displays plots useful for assessing quality of model fit. Currently, only one
plot is available, which plots fitted values against residuals (for homoscedacity check).
</p>
</li>
<li> <p><code>predict(lmranks)</code>: Predict method for Linear Model for Ranks Fits
</p>
</li>
<li> <p><code>summary(lmranks)</code>: Summarizing fits of rank-rank regressions
</p>
</li>
<li> <p><code>vcov(lmranks)</code>: Calculate Variance-Covariance Matrix for a Fitted <code>lmranks</code> object
</p>
<p>Returns the variance-covariance matrix of the regression coefficients
(main parameters) of a fitted <code>lmranks</code> object. Its result is theoretically valid
and asymptotically consistent, in contrast to naively running <code>vcov(lm(...))</code>.
</p>
</li></ul>


<h3>Rank-rank regressions with clusters</h3>

<p>Sometimes, the data is divided into clusters (groups) and one is
interested in running rank-rank regressions separately within each cluster, where the ranks are not computed
within each cluster, but using all observations pooled across all clusters. Specifically, let <code class="reqn">G_i=1,\ldots,n_G</code> denote
a variable that indicates the cluster to which the i-th observation belongs. Then, the regression model of interest is
</p>
<p style="text-align: center;"><code class="reqn">R_i^Y = \sum_{g=1}^{n_G} 1\{G_i=g\}(\rho_g R_i^X + W_i'\beta_g) + \varepsilon_i,</code>
</p>

<p>where <code class="reqn">\rho_g</code> and <code class="reqn">\beta_g</code> are now cluster-specific coefficients, but the ranks <code class="reqn">R_i^Y</code> and <code class="reqn">R_i^X</code> are computed as
ranks among all observations <code class="reqn">Y_i</code> and <code class="reqn">X_i</code>, respectively. That means the rank of an observation is not computed among the other observations
in the same cluster, but rather among all available observations across all clusters.
</p>
<p>This type of regression is implemented in the <code>lmranks</code> function using interaction notation: <code>r(Y)~(r(X)+W):G</code>. Here, the variable
G <strong>must</strong> be a <code><a href="base.html#topic+factor">factor</a></code>.
</p>
<p>Since the theory for clustered regression mixing grouped and ungrouped (in)dependent variables is not yet developed, such a model will raise an error.
Also, by default the function includes a cluster-specific intercept, i.e. <code>r(Y)~(r(X)+W):G</code> is internally interpreted as <code>r(Y)~(r(X)+W):G+G-1</code>.
</p>
<p><code><a href="stats.html#topic+contrasts">contrasts</a></code> of <code>G</code> must be of <code>contr.treatment</code> kind,
which is the default.
</p>


<h3>Warning</h3>

<p>As a consequence of the order, in which <code><a href="stats.html#topic+model.frame">model.frame</a></code> applies operations,
<code>subset</code> and <code>na.action</code> would be applied after evaluation of <code>r()</code>.
That would drop some rank values from the final model frame and returned coefficients
and standard errors could no longer be correct.
The user must handle NA values and filter the data on their own prior to usage in <code>lmranks</code>.
</p>
<p>Wrapping <code>r()</code> with other functions (like <code>log(r(x))</code>) will not
recognize correctly the mark (because it will not be caught in <code>terms(formula, specials = "r")</code>).
The ranks will be calculated correctly, but their transformation will be treated later in <code>lm</code> as a regular
regressor. This means that the corresponding regression coefficient will be calculated correctly,
but the standard errors, statistics etc. will not.
</p>
<p><code>r</code>, <code>.r_predict</code> and <code>.r_cache</code> are special expressions, used
internally to interpret <code>r</code> mark correctly. Do not use them in <code>formula</code>.
</p>
<p>A number of methods defined for <code>lm</code> do not yield theoretically correct
results when applied to <code>lmranks</code> objects; errors or warnings are raised in those instances.
Also, the <code>df.residual</code> component is set to NA, since the notion of effects of freedom
for the rank models is not theoretically established (at time of 1.2 release).
</p>


<h3>References</h3>

<p>Chetverikov and Wilhelm (2023), &quot;Inference for Rank-Rank Regressions&quot;.
<a href="https://arxiv.org/pdf/2310.15512.pdf">arXiv preprint arXiv:2310.15512</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+lm">lm</a></code> for details about other arguments; <code><a href="#topic+frank">frank</a></code>.
</p>
<p>Generic functions <code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="stats.html#topic+effects">effects</a></code>,
<code><a href="stats.html#topic+residuals">residuals</a></code>,
<code><a href="stats.html#topic+fitted">fitted</a></code>, <code><a href="stats.html#topic+model.frame">model.frame</a></code>,
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code>, <code><a href="stats.html#topic+update">update</a></code> .
</p>


<h3>Examples</h3>

<pre><code class='language-R'># rank-rank regression:
X &lt;- rnorm(500)
Y &lt;- X + rnorm(500)
rrfit &lt;- lmranks(r(Y) ~ r(X))
summary(rrfit)

# naive version of the rank-rank regression:
RY &lt;- frank(Y, increasing=TRUE, omega=1)
RX &lt;- frank(X, increasing=TRUE, omega=1)
fit &lt;- lm(RY ~ RX)
summary(fit)
# the coefficient estimates are the same as in the lmranks function, but
# the standard errors, t-values, p-values are incorrect

# support of `data` argument:
data(mtcars)
lmranks(r(mpg) ~ r(hp) + ., data = mtcars)
# Same as above, but use the `hp` variable only through its rank
lmranks(r(mpg) ~ r(hp) + . - hp, data = mtcars)

# rank-rank regression with clusters:
G &lt;- factor(rep(LETTERS[1:4], each=nrow(mtcars) / 4))
lmr &lt;- lmranks(r(mpg) ~ r(hp):G, data = mtcars)
summary(lmr)
model.matrix(lmr)
# Include all columns of mtcars as usual covariates:
lmranks(r(mpg) ~ (r(hp) + .):G, data = mtcars)

</code></pre>

<hr>
<h2 id='parent_child_income'>Income of parents and children</h2><span id='topic+parent_child_income'></span>

<h3>Description</h3>

<p>An artificial dataset containing income of children and their parents together
with some information about them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parent_child_income
</code></pre>


<h3>Format</h3>

<p>A data frame with 3894 rows and 4 variables:
</p>

<dl>
<dt>c_faminc</dt><dd><p>Family income of a child</p>
</dd>
<dt>p_faminc</dt><dd><p>Family income of parent</p>
</dd>
<dt>gender</dt><dd><p>Gender</p>
</dd>
<dt>race</dt><dd><p>Race: hisp (Hispanic), black or neither</p>
</dd>
</dl>


<hr>
<h2 id='pisa'>Cross-country comparison of students' achievement</h2><span id='topic+pisa'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>New code should use <code>data(pisa2018)</code> instead.
</p>
<p>Dataset containing average scores on math, reading, and science
together with standard errors for all OECD countries. These are
from the 2018 Program for International Student Assessment (PISA)
study by the Organization for Economic Cooperation and Development (OECD).
The average scores are over all 15-year-old students in the study.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pisa
</code></pre>


<h3>Format</h3>

<p>A data frame with 37 rows and 7 variables:
</p>

<dl>
<dt>jurisdiction</dt><dd><p>country, from which data was collected</p>
</dd>
<dt>math_score</dt><dd><p>average score in math</p>
</dd>
<dt>math_se</dt><dd><p>standard error for the average score in math</p>
</dd>
<dt>reading_score</dt><dd><p>average score in reading</p>
</dd>
<dt>reading_se</dt><dd><p>standard error for the average score in reading</p>
</dd>
<dt>science_score</dt><dd><p>average score in science</p>
</dd>
<dt>science_se</dt><dd><p>standard error for the average score in science</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.oecd.org/pisa/data/">https://www.oecd.org/pisa/data/</a>
</p>

<hr>
<h2 id='pisa2018'>Cross-country comparison of students' achievement</h2><span id='topic+pisa2018'></span><span id='topic+pisa2022'></span>

<h3>Description</h3>

<p>Datasets containing average scores on math, reading, and science
together with standard errors for all OECD countries. These are
from the 2018 and 2022 editions of
Program for International Student Assessment (PISA)
study by the Organization for Economic Cooperation and Development (OECD).
The average scores are over all 15-year-old students in the study.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pisa2018

pisa2022
</code></pre>


<h3>Format</h3>


<dl>
<dt>jurisdiction</dt><dd><p>country, from which data was collected</p>
</dd>
<dt>math_score</dt><dd><p>average score in math</p>
</dd>
<dt>math_se</dt><dd><p>standard error for the average score in math</p>
</dd>
<dt>reading_score</dt><dd><p>average score in reading</p>
</dd>
<dt>reading_se</dt><dd><p>standard error for the average score in reading</p>
</dd>
<dt>science_score</dt><dd><p>average score in science</p>
</dd>
<dt>science_se</dt><dd><p>standard error for the average score in science</p>
</dd>
</dl>

<p>An object of class <code>data.frame</code> with 38 rows and 7 columns.
</p>


<h3>Source</h3>

<p><a href="https://www.oecd.org/pisa/data/">https://www.oecd.org/pisa/data/</a>
</p>

<hr>
<h2 id='plot.csranks'>Plot ranking with confidence sets</h2><span id='topic+plot.csranks'></span><span id='topic+plotranking'></span>

<h3>Description</h3>

<p>Display ranks together with their confidence set bounds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'csranks'
plot(x, ...)

plotranking(
  ranks,
  L,
  U,
  popnames = NULL,
  title = NULL,
  subtitle = NULL,
  caption = NULL,
  colorbins = 1,
  horizontal = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.csranks_+3A_x">x</code></td>
<td>
<p>An <code>csranks</code> object, likely produced by <code><a href="#topic+csranks">csranks</a></code>.</p>
</td></tr>
<tr><td><code id="plot.csranks_+3A_...">...</code></td>
<td>
<p>Other arguments, passed to <code>plotranking</code>.</p>
</td></tr>
<tr><td><code id="plot.csranks_+3A_ranks">ranks</code></td>
<td>
<p>vector of ranks</p>
</td></tr>
<tr><td><code id="plot.csranks_+3A_l">L</code></td>
<td>
<p>vector of lower bounds of confidence sets for the ranks</p>
</td></tr>
<tr><td><code id="plot.csranks_+3A_u">U</code></td>
<td>
<p>vector of lower bounds of confidence sets for the ranks</p>
</td></tr>
<tr><td><code id="plot.csranks_+3A_popnames">popnames</code></td>
<td>
<p>vector containing names of the populations whose ranks are in <code>ranks</code>. If <code>popnames=NULL</code> (default), then populations are automatically numbered.</p>
</td></tr>
<tr><td><code id="plot.csranks_+3A_title">title</code></td>
<td>
<p>character string containing the main title of the graph. <code>title=NULL</code> (default) means no title.</p>
</td></tr>
<tr><td><code id="plot.csranks_+3A_subtitle">subtitle</code></td>
<td>
<p>character string containing the subtitle of the graph. <code>subtitle=NULL</code> (default) means no subtitle.</p>
</td></tr>
<tr><td><code id="plot.csranks_+3A_caption">caption</code></td>
<td>
<p>character string containing the caption of the graph. <code>caption=NULL</code> (default) means no caption.</p>
</td></tr>
<tr><td><code id="plot.csranks_+3A_colorbins">colorbins</code></td>
<td>
<p>integer indicating the number of quantile bins into which populations are grouped and color-coded. Value has to lie between 1 (default) and the number of populations.</p>
</td></tr>
<tr><td><code id="plot.csranks_+3A_horizontal">horizontal</code></td>
<td>
<p>logical. Should be the bars displayed horizontally, or vertically?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot plot displaying confidence sets.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>plot(csranks)</code>: Plot <code>csranks</code> output
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(1, 3, length = 10)
V &lt;- diag(rep(0.04, 10))
CS &lt;- csranks(x, V)
grid::current.viewport()
plot(CS)
# Equivalent: 
plotranking(CS$rank, CS$L, CS$U)

# plotranking returns a ggplot object. It can be customized further:
library(ggplot2)
pl &lt;- plot(CS)
pl + xlab("position in ranking") + ylab("population label") + theme_gray()

# horizontal = FALSE uses ggplot2::coord_flip underneath. The x and y axes swap places.
pl &lt;- plot(CS, horizontal = FALSE)
pl + xlab("position in ranking") + # Note, that xlab refers to vertical axis now
  ylab("population label") + theme_gray()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
