<!DOCTYPE html><html><head><title>Help for package graphsim</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {graphsim}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#graphsim-package'><p>The graphsim package</p></a></li>
<li><a href='#generate_expression'><p>Generate Simulated Expression</p></a></li>
<li><a href='#make_adjmatrix'><p>Generate Adjacency Matrix</p></a></li>
<li><a href='#make_commonlink'><p>Generate Common Link Matrix</p></a></li>
<li><a href='#make_distance'><p>Generate Distance Matrix</p></a></li>
<li><a href='#make_laplacian'><p>Generate Laplacian Matrix</p></a></li>
<li><a href='#make_sigma'><p>Generate Sigma (<code class="reqn">\Sigma</code>) Matrix</p></a></li>
<li><a href='#make_state'><p>Make State Matrix</p></a></li>
<li><a href='#Pi3K_AKT_graph'><p>PI3K/AKT activation</p></a></li>
<li><a href='#Pi3K_graph'><p>PI3K Cascade</p></a></li>
<li><a href='#plot_directed'><p>Extensions to igraph for Customising plots</p></a></li>
<li><a href='#RAF_MAP_graph'><p>#' RAF/MAP kinase cascade</p></a></li>
<li><a href='#TGFBeta_Smad_graph'><p>TGF-<code class="reqn">\beta</code> receptor signaling activates SMADs</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulate Expression Data from 'igraph' Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-09-10</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to develop simulated continuous data (e.g., gene expression) from a sigma covariance matrix derived from a graph structure in 'igraph' objects. Intended to extend 'mvtnorm' to take 'igraph'  structures rather than sigma matrices as input. This allows the use of simulated data that correctly accounts for pathway relationships and correlations. This allows the use of simulated data that correctly accounts for pathway relationships and correlations. Here we present a versatile statistical framework to simulate  correlated gene expression data from biological pathways, by sampling from a multivariate normal distribution derived from a graph structure. This package allows the simulation of biological pathways from a graph structure based on a statistical model of gene expression. For example methods to infer biological pathways and gene regulatory networks from gene expression data can be tested on simulated datasets using this framework. This also allows for pathway structures to be considered as a confounding variable when simulating gene expression data to test the performance of genomic analyses.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/TomKellyGenetics/graphsim/">https://github.com/TomKellyGenetics/graphsim/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/TomKellyGenetics/graphsim/issues/">https://github.com/TomKellyGenetics/graphsim/issues/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>gplots, igraph, mvtnorm, matrixcalc, Matrix, graphics</td>
</tr>
<tr>
<td>Suggests:</td>
<td>devtools, knitr (&ge; 1.5), markdown, prettydoc, R.rsp,
rmarkdown, testthat, scales, vdiffr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-12 00:56:17 UTC; tom</td>
</tr>
<tr>
<td>Author:</td>
<td>S. Thomas Kelly [aut, cre],
  Michael A. Black [aut, ths],
  Robrecht Cannoodt [ctb],
  Jason Cory Brunson [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>S. Thomas Kelly &lt;tomkellygenetics@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-12 06:12:54 UTC</td>
</tr>
</table>
<hr>
<h2 id='graphsim-package'>The graphsim package</h2><span id='topic+graphsim-package'></span><span id='topic+graphsim'></span>

<h3>Description</h3>

<p>graphsim is a package to simulate normalised expression data from networks 
for biological pathways using &lsquo;<code>igraph</code>&rsquo; objects and multivariate
normal distributions.
</p>


<h3>Details</h3>

<p>This package provides functions to develop simulated continuous data 
(e.g., gene expression) from a Sigma (<code class="reqn">\Sigma</code>) covariance matrix derived from a 
graph structure in &lsquo;<code>igraph</code>&rsquo; objects. Intended to extend 
&lsquo;<code>mvtnorm</code>&rsquo; to take 'igraph' structures rather than sigma 
matrices as input. This allows the use of simulated data that correctly
accounts for pathway relationships and correlations. Here we present
a versatile statistical framework to simulate correlated gene expression
data from biological pathways, by sampling from a multivariate normal
distribution derived from a graph structure. This package allows the
simulation of biologicalpathways from a graph structure based on a
statistical model of gene expression, such as simulation of expression
profiles that of log-transformed and normalised data from microarray
and RNA-Seq data.
</p>


<h3>Introduction</h3>

<p>This package enables the generation of simulated gene expression datasets 
containing pathway relationships from a known underlying network.
These simulated datasets can be used to evaluate various bioinformatics 
methodologies, including statistical and network inference procedures.
</p>
<p>These are computed by 1) resolving inhibitory states to derive a consistent
matrix of positive and negative edges, 2) inferring relationships between
nodes from paths in the graph, 3) weighting these in a Sigma (<code class="reqn">\Sigma</code>) 
covariance matrix and 4) using this to sample a multivariate normal 
distribution.
</p>


<h3>Getting Started</h3>

<p>The <code><a href="#topic+generate_expression">generate_expression</a></code> function is a wrapper 
around all necessary functions to give a final simulated dataset.
</p>
<p>Here we set up an example graph object using the 
<code><a href="igraph.html#topic+aaa-igraph-package">igraph</a></code> package.
</p>
<pre>
library("igraph")
graph_structure_edges &lt;- rbind(c("A", "C"), c("B", "C"), c("C", "D"),c("D", "E"),
                               c("D", "F"), c("F", "G"), c("F", "I"), c("H", "I"))
graph_structure &lt;- graph.edgelist(graph_structure_edges, directed = TRUE)
</pre>
<p>Then we can call <code><a href="#topic+generate_expression">generate_expression</a></code> to return
the simulated data based on the relationships defined in the graph
structure. Various options are available to fine-tune this.
</p>
<pre>
expr &lt;- generate_expression(100, graph_structure,
                            cor = 0.8,
                            mean = 0,
                            sd = 1,
                            comm = FALSE,
                            dist = TRUE,
                            absolute = FALSE,
                            laplacian = FALSE)
</pre>
<p>Here we can see the final result. The graph
structure defines the covariance matrix used
by <code><a href="mvtnorm.html#topic+Mvnorm">rmvnorm</a></code> to
generate a multivariate distribution.
</p>
<pre>
dim(expr)

library("gplots")
heatmap.2(expr,
          scale = "none",
          trace = "none",
          col = bluered(50),
          colsep = 1:4,
          rowsep = 1:4)
</pre>
<p>This dataset consists of 9 rows (one for each vertex or gene)
in the graph and 100 columns (one for each sample or observation).
</p>
<p>Input with an adjacency matrix is available using the
<code><a href="#topic+generate_expression">generate_expression_mat</a></code>
function.
</p>


<h3>Creating Input Data</h3>

<p>Graph structures can be passed directly from the
<code><a href="igraph.html#topic+aaa-igraph-package">igraph</a></code> package.
Using this package, you can create an &lsquo;<code>igraph</code>&rsquo;
class object.
</p>
<pre>
&gt; class(graph_structure)
[1] "igraph"

&gt; graph_structure
IGRAPH ba7fa2f DN-- 9 8 -- 
  + attr: name (v/c)
  + edges from ba7fa2f (vertex names):
    [1] A-&gt;C B-&gt;C C-&gt;D D-&gt;E D-&gt;F F-&gt;G F-&gt;I H-&gt;I
</pre>
<p>This &lsquo;<code>igraph</code>&rsquo; object class can be passed
directly to <code><a href="#topic+generate_expression">generate_expression</a></code>
shown above and internal functions described below:
<code><a href="#topic+make_sigma">make_sigma_mat_graph</a></code>,
<code><a href="#topic+make_sigma">make_sigma_mat_dist_graph</a></code>,
<code><a href="#topic+make_distance">make_distance_graph</a></code>,
and
<code><a href="#topic+make_state">make_state_matrix</a></code>.
</p>
<p>The &lsquo;<code>graphsim</code>&rsquo; package also supports various
matrix formats and has functions to handle these.
The following functions will compute matrices from an
&lsquo;<code>igraph</code>&rsquo; object class:
</p>

<ul>
<li>  <p><code><a href="#topic+make_adjmatrix">make_adjmatrix_graph</a></code>
to derive the adjacency matrix for a graph structure.
</p>
</li>
<li>  <p><code><a href="#topic+make_commonlink">make_commonlink_graph</a></code>
to derive the &lsquo;common link&rsquo; matrix for a graph structure of
mutually shared neighbours.
</p>
</li>
<li>  <p><code><a href="#topic+make_laplacian">make_laplacian_graph</a></code>
to derive the Laplacian matrix for a graph structure.
</p>
</li></ul>
 
<p>The following functions will compute matrices from an
<code><a href="#topic+make_adjmatrix">adjacency matrix</a></code>:
</p>

<ul>
<li>  <p><code><a href="#topic+make_commonlink">make_commonlink_adjmat</a></code>
to derive the &lsquo;common link&rsquo; matrix for a graph structure of
mutually shared neighbours.
</p>
</li>
<li>  <p><code><a href="#topic+make_laplacian">make_laplacian_adjmat</a></code>
to derive the Laplacian matrix for a graph structure.
</p>
</li></ul>
 
<p>We provide some pre-generate pathways from Reactoem database
for testing and demonstrations:
</p>

<ul>
<li>  <p><code><a href="#topic+RAF_MAP_graph">RAF_MAP_graph </a></code>
for the interactions in the &ldquo;RAF/MAP kinase&rdquo; cascade (17 vertices
and 121 edges).
</p>
</li>
<li>  <p><code><a href="#topic+Pi3K_graph">Pi3K_graph</a></code>
for the phosphoinositide-3-kinase cascade (35 vertices and 251 edges).
</p>
</li>
<li>  <p><code><a href="#topic+Pi3K_AKT_graph">Pi3K_AKT_graph</a></code>
for the phosphoinositide-3-kinase activation of Protein kinase B
pathway &ldquo;PI3K/AKT activation&rdquo; (275 vertices and 21106 edges).
</p>
</li>
<li>  <p><code><a href="#topic+TGFBeta_Smad_graph">TGFBeta_Smad_graph</a></code>
for the TGF-<code class="reqn">\beta</code> receptor signaling activates SMADs
pathway (32 vertices and 173 edges).
</p>
</li></ul>
 
<p>Please note that demonstrations on larger graph objects. These
can be called directly from the pakage:
</p>
<pre>
&gt; graphsim::Pi3K_graph
IGRAPH 21437e3 DN-- 35 251 -- 
  + attr: name (v/c)
  + edges from 21437e3 (vertex names):
     [1] AKT1-&gt;AKT2  AKT1-&gt;AKT3  AKT1-&gt;CASP9 AKT1-&gt;CASP9
     [5] AKT1-&gt;CASP9 AKT1-&gt;FOXO1 AKT1-&gt;FOXO1 AKT1-&gt;FOXO1
     [9] AKT1-&gt;FOXO3 AKT1-&gt;FOXO3 AKT1-&gt;FOXO3 AKT1-&gt;FOXO4
     [13] AKT1-&gt;FOXO4 AKT1-&gt;FOXO4 AKT1-&gt;GSK3B AKT1-&gt;GSK3B
     [17] AKT1-&gt;GSK3B AKT1-&gt;NOS1  AKT1-&gt;NOS2  AKT1-&gt;NOS3 
     [21] AKT1-&gt;PDPK1 AKT2-&gt;AKT3  AKT2-&gt;CASP9 AKT2-&gt;CASP9
     [25] AKT2-&gt;CASP9 AKT2-&gt;FOXO1 AKT2-&gt;FOXO1 AKT2-&gt;FOXO1
     [29] AKT2-&gt;FOXO3 AKT2-&gt;FOXO3 AKT2-&gt;FOXO3 AKT2-&gt;FOXO4
     + ... omitted several edges
     + ... omitted several edges
</pre>
<p>They can also be imported into R:
</p>
<pre>
data(Pi3K_graph)
</pre>
<p>You can assign them to your local environment
by calling with from the package:
</p>
<pre>
graph_object &lt;- identity(Pi3K_graph)
</pre>
<p>You can also change the object class directly
from the package:
</p>
<pre>
library("igraph")
Pi3K_adjmat &lt;- as_adjacency_matrix(Pi3K_graph)
</pre>
<p><code><a href="#topic+Pi3K_AKT_graph">Pi3K_AKT_graph</a></code> and 
<code><a href="#topic+TGFBeta_Smad_graph">TGFBeta_Smad_graph</a></code>
contain graph edge attributes for the &lsquo;state&rsquo; parameter
described below.
</p>
<pre>
 &gt; TGFBeta_Smad_graph
 IGRAPH f3eac04 DN-- 32 173 -- 
   + attr: name (v/c), state (e/n)
   + edges from f3eac04 (vertex names):
     [1] BAMBI -&gt;SMAD7  BAMBI -&gt;TGFB1  BAMBI -&gt;TGFBR1 BAMBI -&gt;TGFBR2
     [5] CBL   -&gt;NEDD8  CBL   -&gt;NEDD8  CBL   -&gt;TGFBR2 CBL   -&gt;TGFBR2
     [9] CBL   -&gt;UBE2M  CBL   -&gt;UBE2M  FKBP1A-&gt;TGFB1  FKBP1A-&gt;TGFBR1
     [13] FKBP1A-&gt;TGFBR2 FURIN -&gt;TGFB1  FURIN -&gt;TGFB1  MTMR4 -&gt;SMAD2 
     [17] MTMR4 -&gt;SMAD2  MTMR4 -&gt;SMAD3  MTMR4 -&gt;SMAD3  NEDD4L-&gt;RPS27A
     [21] NEDD4L-&gt;SMAD7  NEDD4L-&gt;SMURF1 NEDD4L-&gt;SMURF2 NEDD4L-&gt;TGFB1 
     [25] NEDD4L-&gt;TGFBR1 NEDD4L-&gt;TGFBR2 NEDD4L-&gt;UBA52  NEDD4L-&gt;UBB   
     [29] NEDD4L-&gt;UBC    NEDD8 -&gt;TGFBR2 NEDD8 -&gt;UBE2M  PMEPA1-&gt;SMAD2 
     + ... omitted several edges
     
 &gt; E(TGFBeta_Smad_graph)$state
 [1] 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
 [32] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
 [63] 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
 [94] 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
 [125] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
 [156] 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 1 1 1
 
 &gt; states &lt;- E(TGFBeta_Smad_graph)$state
 &gt; table(states)
 states
 1   2 
 103  70 
 </pre>


<h3>Internal Functions</h3>

<p>The following functions are used by
<code><a href="#topic+generate_expression">generate_expression</a></code>
to compute a simulated dataset. They can be called separately
to summarise the steps used to compute the final data matrix
or for troubleshooting.
</p>

<ul>
<li> <p><code><a href="#topic+make_sigma">make_sigma_mat_adjmat</a></code>,
<code><a href="#topic+make_sigma">make_sigma_mat_comm</a></code>, 
<code><a href="#topic+make_sigma">make_sigma_mat_laplacian</a></code>, and
<code><a href="#topic+make_sigma">make_sigma_mat_graph</a></code> will
compute a Sigma (<code class="reqn">\Sigma</code>) covariance matrix from an
adjacency matrix, common link matrix, Laplacian matrix,
or an &lsquo;igraph&rsquo; object. There are computed as above
and passed to <code><a href="mvtnorm.html#topic+Mvnorm">rmvnorm</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+make_distance">make_distance_adjmat</a></code>,
<code><a href="#topic+make_distance">make_distance_comm</a></code>, 
<code><a href="#topic+make_distance">make_distance_laplacian</a></code>, and
<code><a href="#topic+make_distance">make_distance_graph</a></code> will
compute a distance matrix of relationships from an
adjacency matrix, common link matrix, Laplacian matrix,
or an &lsquo;igraph&rsquo; object. There are computed as above
and passed to <code><a href="#topic+make_sigma">make_sigma</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+make_state">make_state_matrix</a></code>
will compute a &ldquo;state matrix&rdquo; resolving positive and
negative correlations from a vector of edge properties. This
is called by <code><a href="#topic+make_sigma">make_sigma</a></code>
and <code><a href="#topic+generate_expression">generate_expression</a></code>
to ensure that the signs of correlations are consistent.
</p>
</li></ul>



<h3>Examining Step-by-Step</h3>

<p>These internal functions can be called to compute steps of
the simulation procedure and examine the results.
</p>
<p>1. first we create a graph structure and define the input parameters
</p>
<pre>
library("igraph")
graph_structure_edges &lt;- rbind(c("A", "C"), c("B", "C"), c("C", "D"),c("D", "E"),
                               c("D", "F"), c("F", "G"), c("F", "I"), c("H", "I"))
graph_structure &lt;- graph.edgelist(graph_structure_edges, directed = TRUE)
#sample size
data.n &lt;- 100
#data distributions
data.cor &lt;- 0.75
data.mean &lt;- 3
data.sd &lt;- 1.5
#inhibition states
edge_states &lt;- c(1, 1, -1, -1, 1, 1, 1, 1)
</pre>
<p>2. examine the relationships between the genes.
</p>
<p>Here we can see which nodes share an edge:
</p>
<pre>
&gt; adjacency_matrix &lt;- make_adjmatrix_graph(graph_structure)
&gt; adjacency_matrix
  A C B D E F G I H
A 0 1 0 0 0 0 0 0 0
C 1 0 1 1 0 0 0 0 0
B 0 1 0 0 0 0 0 0 0
D 0 1 0 0 1 1 0 0 0
E 0 0 0 1 0 0 0 0 0
F 0 0 0 1 0 0 1 1 0
G 0 0 0 0 0 1 0 0 0
I 0 0 0 0 0 1 0 0 1
H 0 0 0 0 0 0 0 1 0
</pre>
<p>Here we define a geometrically decreasing series of relationships
between genes based on distance by paths in the graph:
</p>
<pre>
&gt; relationship_matrix &lt;- make_distance_graph(graph_structure, absolute = FALSE)
&gt; relationship_matrix
  A          C          B          D          E          F          G          I          H
A 1.00000000 0.20000000 0.10000000 0.10000000 0.06666667 0.06666667 0.05000000 0.05000000 0.04000000
C 0.20000000 1.00000000 0.20000000 0.20000000 0.10000000 0.10000000 0.06666667 0.06666667 0.05000000
B 0.10000000 0.20000000 1.00000000 0.10000000 0.06666667 0.06666667 0.05000000 0.05000000 0.04000000
D 0.10000000 0.20000000 0.10000000 1.00000000 0.20000000 0.20000000 0.10000000 0.10000000 0.06666667
E 0.06666667 0.10000000 0.06666667 0.20000000 1.00000000 0.10000000 0.06666667 0.06666667 0.05000000
F 0.06666667 0.10000000 0.06666667 0.20000000 0.10000000 1.00000000 0.20000000 0.20000000 0.10000000
G 0.05000000 0.06666667 0.05000000 0.10000000 0.06666667 0.20000000 1.00000000 0.10000000 0.06666667
I 0.05000000 0.06666667 0.05000000 0.10000000 0.06666667 0.20000000 0.10000000 1.00000000 0.20000000
H 0.04000000 0.05000000 0.04000000 0.06666667 0.05000000 0.10000000 0.06666667 0.20000000 1.00000000
</pre>
<p>Here we can see the resolved edge states through paths in the
adjacency matrix:
</p>
<pre>
&gt; names(edge_states) &lt;- apply(graph_structure_edges, 1, paste, collapse = "-")
&gt; edge_states
A-C B-C C-D D-E D-F F-G F-I H-I 
1   1  -1  -1   1   1   1   1 
&gt; state_matrix &lt;- make_state_matrix(graph_structure, state = edge_states)
&gt; state_matrix
   A  C  B  D  E  F  G  I  H
A  1  1  1 -1  1 -1 -1 -1 -1
C  1  1  1 -1  1 -1 -1 -1 -1
B  1  1  1 -1  1 -1 -1 -1 -1
D -1 -1 -1  1 -1  1  1  1  1
E  1  1  1 -1  1 -1 -1 -1 -1
F -1 -1 -1  1 -1  1  1  1  1
G -1 -1 -1  1 -1  1  1  1  1
I -1 -1 -1  1 -1  1  1  1  1
H -1 -1 -1  1 -1  1  1  1  1
</pre>
<p>3. define a Sigma (<code class="reqn">\Sigma</code>) covariance matrix
</p>
<p>Here we can see that the signs match the <code>state_matrix</code>
and the covariance is based on the <code>relationship_matrix</code>
weighted by the correlation (<code>cor</code>) and standard
deviation (<code>sd</code>) parameters.
</p>
<p>Note that where <code>sd = 1</code>, the diagonals will be <code>1</code>
and the off-diagonal terms will be correlations.
</p>
<pre>
&gt; sigma_matrix &lt;- make_sigma_mat_dist_graph(
+     graph_structure,
+     state = edge_states,
+     cor = data.cor,
+     sd = data.sd,
+     absolute = FALSE
+ )
&gt; sigma_matrix
   A         C         B        D         E        F         G         I         H
A  2.250000  1.687500  0.843750 -0.84375  0.562500 -0.56250 -0.421875 -0.421875 -0.337500
C  1.687500  2.250000  1.687500 -1.68750  0.843750 -0.84375 -0.562500 -0.562500 -0.421875
B  0.843750  1.687500  2.250000 -0.84375  0.562500 -0.56250 -0.421875 -0.421875 -0.337500
D -0.843750 -1.687500 -0.843750  2.25000 -1.687500  1.68750  0.843750  0.843750  0.562500
E  0.562500  0.843750  0.562500 -1.68750  2.250000 -0.84375 -0.562500 -0.562500 -0.421875
F -0.562500 -0.843750 -0.562500  1.68750 -0.843750  2.25000  1.687500  1.687500  0.843750
G -0.421875 -0.562500 -0.421875  0.84375 -0.562500  1.68750  2.250000  0.843750  0.562500
I -0.421875 -0.562500 -0.421875  0.84375 -0.562500  1.68750  0.843750  2.250000  1.687500
H -0.337500 -0.421875 -0.337500  0.56250 -0.421875  0.84375  0.562500  1.687500  2.250000
</pre>
<p>4. generate an expression dataset using this sigma matrix
</p>
<p>We use <code>generate_expression</code> to compute and expression
dataset, simulated using these parameters:
</p>
<pre>
&gt; expression_data &lt;- generate_expression(
+     n = data.n,
+     graph_structure,
+     state = edge_states,
+     cor = data.cor,
+     mean = data.mean,
+     sd = data.sd,
+     comm = FALSE,
+     dist = FALSE,
+     absolute = FALSE,
+     laplacian = FALSE
+ )
&gt; dim(expression_data)
[1]   9 100
</pre>
<p>Here we also compute the final observed correlations
in the simulated dataset:
</p>
<pre>
&gt; cor_data &lt;- cor(t(expression_data))
&gt; dim(cor_data)
[1] 9 9
</pre>
<p>These functions are demonstrated in more detail
in the <a href="https://CRAN.R-project.org/package=graphsim/vignettes/simulate_expression.html">main</a> vignette.
</p>


<h3>Data Visualization</h3>

<p>Heatmaps can be used from the <code><a href="gplots.html#topic+heatmap.2">gplots</a></code>
package to display these simulated datasets.
</p>
<pre>
library("gplots")
heatmap.2(adjacency_matrix, scale = "none", trace = "none",
          col = colorpanel(50, "white", "black"), key = FALSE)
          
heatmap.2(relationship_matrix, scale = "none", trace = "none",
          col = colorpanel(50, "white", "red"))
          
heatmap.2(state_matrix, scale = "none", trace = "none",
          col = colorpanel(50, "royalblue", "palevioletred"),
          colsep = 1:length(V(graph_structure)),
          rowsep = 1:length(V(graph_structure)))

heatmap.2(sigma_matrix, scale = "none", trace = "none",
          col = colorpanel(50, "royalblue", "white", "palevioletred"),
          colsep = 1:length(V(graph_structure)),
          rowsep = 1:length(V(graph_structure)))
          
heatmap.2(expression_data, scale = "none", trace = "none",
          col = colorpanel(50, "royalblue", "white", "palevioletred"),
          colsep = 1:length(V(graph_structure)),
         rowsep = 1:length(V(graph_structure)))

heatmap.2(cor_data, scale = "none", trace = "none",
          col = colorpanel(50, "royalblue", "white", "palevioletred"),
          colsep = 1:length(V(graph_structure)),
          rowsep = 1:length(V(graph_structure)))
</pre>
<p>In particular we can see here that the expected correlations
show by the <code>sigma_matrix</code> are similar to the observed
correlations in the <code>cor_data</code>.
</p>


<h3>Graph Visualization</h3>

<p>The &lsquo;graphsim&rsquo; package comes with a built-in plotting
function to display graph objects. 
</p>
<pre>
graph_structure_edges &lt;- rbind(c("A", "C"), c("B", "C"), c("C", "D"),c("D", "E"),
                               c("D", "F"), c("F", "G"), c("F", "I"), c("H", "I"))
graph_structure &lt;- graph.edgelist(graph_structure_edges, directed = TRUE)
plot_directed(graph_structure, layout = layout.kamada.kawai)
</pre>
<p>This supports the &lsquo;state&rsquo; parameter to display
activating relationships (with positive correlations)
and inhibiting or repressive relationships (with
negative correlations).
</p>
<pre>
edge_states &lt;- c(1, 1, -1, -1, 1, -1, 1, -1)
graph_structure &lt;- graph.edgelist(graph_structure_edges, directed = TRUE)
plot_directed(graph_structure, state = edge_states,
              col.arrow = c("darkgreen", "red")[edge_states / 2 + 1.5]
              layout = layout.kamada.kawai)
</pre>
<p>These states can also be passed from the &lsquo;state&rsquo; edge
attribute of the graph object.
</p>
<pre>
graph_pathway &lt;- identity(TGFBeta_Smad_graph)
edge_properties &lt;- E(graph_pathway)$state
plot_directed(graph_pathway,
              col.arrow = c(alpha("navyblue", 0.25),
                            alpha("red", 0.25))[edge_properties],
              fill.node = c("lightblue"),
              layout = layout.kamada.kawai)
</pre>
<p>This plotting function is demonstrated in more detail
in the plots_directed.Rmd plotting vignette.
</p>


<h3>Further information</h3>

<p>The graphsim package is published in the <em>Journal of Open Source Software</em>.
See the paper here for more details:
<a href="https://doi.org/10.21105/joss.02161">doi:10.21105/joss.02161</a>
</p>
<p>The graphsim GitHub repository is here:
<a href="https://github.com/TomKellyGenetics/graphsim">TomKellyGenetics/graphsim</a>
You can find the development version and submit an
<a href="https://github.com/TomKellyGenetics/graphsim/issues/new/choose">issue</a>
if you have questions or comments.
</p>


<h3>Citation</h3>

<p>To cite package 'graphsim' in publications use:
</p>
<p>Kelly, S.T. and Black, M.A. (2020). graphsim: An R package for simulating gene
expression data from graph structures of biological pathways.
<em>Journal of Open Source Software</em>, <b>5</b>(51), 2161,
<a href="https://doi.org/10.21105/joss.02161">doi:10.21105/joss.02161</a>
</p>
<p>A BibTeX entry for LaTeX users is: </p>
<pre>
  @article{Kelly2020joss02161,
     doi = {10.21105/joss.02161},
     year = {2020},
     publisher = {The Open Journal},
     volume = {5},
     number = {51},
     pages = {2161},
     author = {S. Thomas Kelly and Michael A. Black},
     title = {graphsim: An R package for simulating gene expression data from graph structures of biological pathways},
     journal = {Journal of Open Source Software} 
   }
 </pre>


<h3>Author(s)</h3>

<p><b>Maintainer</b>:  Tom Kelly  <a href="mailto:tom.kelly@riken.jp">tom.kelly@riken.jp</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Tom Kelly (RIKEN IMS) <a href="https://orcid.org/0000-0003-3904-6690">ORCID</a>)
</p>
</li>
<li><p> Mik Black (Otago University) (<a href="https://orcid.org/0000-0003-1174-6054">ORCID</a>)
</p>
</li></ul>

<p>Reviewers:
</p>

<ul>
<li><p> Cory Brunson (UConn) (<a href="https://orcid.org/0000-0003-3126-9494">ORCID</a>)
</p>
</li>
<li><p> Robrecht Cannoodt (Ghent University) (<a href="https://orcid.org/0000-0003-3641-729X">ORCID</a>)
</p>
</li></ul>

<p>Editor: Mark Jensen (Frederick National Laboratory for Cancer Research)
</p>


<h3>See Also</h3>

<p>Publication at <em>Journal of Open Source Software</em>:
</p>

<ul>
<li> <p><a href="https://doi.org/10.21105/joss.02161">doi:10.21105/joss.02161</a>
</p>
</li></ul>

<p>GitHub repository:
</p>

<ul>
<li> <p><a href="https://github.com/TomKellyGenetics/graphsim/">https://github.com/TomKellyGenetics/graphsim/</a>
</p>
</li></ul>

<p>Report bugs:
</p>

<ul>
<li> <p><a href="https://github.com/TomKellyGenetics/graphsim/issues">https://github.com/TomKellyGenetics/graphsim/issues</a>
</p>
</li></ul>

<p>Contributions:
</p>

<ul>
<li> <p><a href="https://github.com/TomKellyGenetics/graphsim/blob/master/CONTRIBUTING.md">https://github.com/TomKellyGenetics/graphsim/blob/master/CONTRIBUTING.md</a>
</p>
</li></ul>


<hr>
<h2 id='generate_expression'>Generate Simulated Expression</h2><span id='topic+generate_expression'></span><span id='topic+generate_expression_mat'></span>

<h3>Description</h3>

<p>Compute simulated continuous expression data from a graph 
network structure. Requires an <code><a href="igraph.html#topic+aaa-igraph-package">igraph</a></code> pathway 
structure and a matrix of states (1 for activating and -1 for 
inhibiting) for link signed correlations, from a vector of edge states 
to a signed adjacency matrix for use in 
<code><a href="#topic+generate_expression">generate_expression</a></code>. 
Uses graph structure to pass a sigma covariance matrix from 
<code><a href="#topic+make_sigma">make_sigma_mat_graph</a></code> or 
<code><a href="#topic+make_sigma">make_sigma_mat_dist_graph</a></code> on to 
<code><a href="mvtnorm.html#topic+Mvnorm">rmvnorm</a></code>. By default data is generated with a mean of
0 and standard deviation of 1 for each gene (with correlations between 
derived from the graph structure).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_expression(
  n,
  graph,
  state = NULL,
  cor = 0.8,
  mean = 0,
  sd = 1,
  comm = FALSE,
  dist = FALSE,
  absolute = FALSE,
  laplacian = FALSE
)

generate_expression_mat(
  n,
  mat,
  state = NULL,
  cor = 0.8,
  mean = 0,
  sd = 1,
  comm = FALSE,
  dist = FALSE,
  absolute = FALSE,
  laplacian = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_expression_+3A_n">n</code></td>
<td>
<p>number of observations (simulated samples).</p>
</td></tr>
<tr><td><code id="generate_expression_+3A_graph">graph</code></td>
<td>
<p>An <code><a href="igraph.html#topic+aaa-igraph-package">igraph</a></code> object. May must be 
directed if states are used.</p>
</td></tr>
<tr><td><code id="generate_expression_+3A_state">state</code></td>
<td>
<p>numeric vector. Vector of length E(graph). Sign used
to calculate state matrix, may be an integer state or inferred directly
from expected correlations for each edge. May be applied a scalar across
all edges or as a vector for each edge respectively. May also be entered
as text for &quot;activating&quot; or &quot;inhibiting&quot; or as integers for activating (0,1)
or inhibiting (-1,2). Compatible with inputs for <code><a href="#topic+plot_directed">plot_directed</a></code>.
Also takes a pre-computed state matrix from <code><a href="#topic+make_state">make_state</a></code>
if applied to the same graph multiple times.</p>
</td></tr>
<tr><td><code id="generate_expression_+3A_cor">cor</code></td>
<td>
<p>numeric. Simulated maximum correlation/covariance of two 
adjacent nodes. Default to 0.8.</p>
</td></tr>
<tr><td><code id="generate_expression_+3A_mean">mean</code></td>
<td>
<p>mean value of each simulated gene. Defaults to 0.
May be entered as a scalar applying to 
all genes or a vector with a separate value for each.</p>
</td></tr>
<tr><td><code id="generate_expression_+3A_sd">sd</code></td>
<td>
<p>standard deviations of each gene. Defaults to 1.
May be entered as a scalar applying to 
all genes or a vector with a separate value for each.</p>
</td></tr>
<tr><td><code id="generate_expression_+3A_comm">comm</code>, <code id="generate_expression_+3A_absolute">absolute</code>, <code id="generate_expression_+3A_laplacian">laplacian</code></td>
<td>
<p>logical. Parameters for Sigma matrix
generation. Passed on to <code><a href="#topic+make_sigma">make_sigma</a></code> 
or <code><a href="#topic+make_sigma">make_sigma</a></code>.</p>
</td></tr>
<tr><td><code id="generate_expression_+3A_dist">dist</code></td>
<td>
<p>logical. Whether a graph distance 
<code><a href="#topic+make_sigma">make_sigma_mat_graph</a></code> or derived matrix
<code><a href="#topic+make_sigma">make_sigma_mat_dist_graph</a></code> is used to compute the
sigma matrix (using <code><a href="#topic+make_distance">make_distance</a></code>).</p>
</td></tr>
<tr><td><code id="generate_expression_+3A_mat">mat</code></td>
<td>
<p>precomputed adjacency, laplacian, commonlink, or scaled 
distance matrix (generated by <code><a href="#topic+make_distance">make_distance</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric matrix of simulated data (log-normalised counts)
</p>


<h3>Author(s)</h3>

<p>Tom Kelly <a href="mailto:tom.kelly@riken.jp">tom.kelly@riken.jp</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+make_sigma">make_sigma</a></code> for computing the Sigma (<code class="reqn">\Sigma</code>) matrix,
<code><a href="#topic+make_distance">make_distance</a></code> for computing distance from a graph object,
and
<code><a href="#topic+make_state">make_state</a></code> for resolving inhibiting states.
</p>
<p>See also <code><a href="#topic+plot_directed">plot_directed</a></code> for plotting graphs or 
<code><a href="gplots.html#topic+heatmap.2">heatmap.2</a></code> for plotting matrices.
</p>
<p>See also <code><a href="#topic+make_laplacian">make_laplacian</a></code>, <code><a href="#topic+make_commonlink">make_commonlink</a></code>, 
or <code><a href="#topic+make_adjmatrix">make_adjmatrix</a></code> for computing input matrices.
</p>
<p>See also <code><a href="igraph.html#topic+aaa-igraph-package">igraph</a></code> for handling graph objects.
</p>
<p>Other graphsim functions: 
<code><a href="#topic+make_adjmatrix">make_adjmatrix</a></code>,
<code><a href="#topic+make_commonlink">make_commonlink</a></code>,
<code><a href="#topic+make_distance">make_distance</a></code>,
<code><a href="#topic+make_laplacian">make_laplacian</a></code>,
<code><a href="#topic+make_sigma">make_sigma</a></code>,
<code><a href="#topic+make_state">make_state</a></code>,
<code><a href="#topic+plot_directed">plot_directed</a>()</code>
</p>
<p>Other generate simulated expression functions: 
<code><a href="#topic+make_distance">make_distance</a></code>,
<code><a href="#topic+make_sigma">make_sigma</a></code>,
<code><a href="#topic+make_state">make_state</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# construct a synthetic graph module
library("igraph")
graph_test_edges &lt;- rbind(c("A", "B"), c("B", "C"), c("B", "D"))
graph_test &lt;- graph.edgelist(graph_test_edges, directed = TRUE)

# compute a simulated dataset for toy example
# n = 100 samples
# cor = 0.8 max correlation between samples
# absolute = FALSE (geometric distance by default)
test_data &lt;- generate_expression(100, graph_test, cor = 0.8)
##' # visualise matrix
library("gplots")
# expression data
heatmap.2(test_data, scale = "none", trace = "none",
          col = colorpanel(50, "blue", "white", "red"))
# correlations
heatmap.2(cor(t(test_data)), scale = "none", trace = "none",
          col = colorpanel(50, "white", "red"))
# expected correlations (\eqn{\Sigma})
sigma_matrix &lt;- make_sigma_mat_graph(graph_test, cor = 0.8)
heatmap.2(make_sigma_mat_graph(graph_test, cor = 0.8),
          scale = "none", trace = "none", 
          col = colorpanel(50, "white", "red"))

# compute adjacency matrix for toy example
adjacency_matrix &lt;- make_adjmatrix_graph(graph_test)
# generate simulated data from adjacency matrix input
test_data &lt;- generate_expression_mat(100, adjacency_matrix, cor = 0.8)

# compute a simulated dataset for toy example
# n = 100 samples
# cor = 0.8 max correlation between samples
# absolute = TRUE (arithmetic distance)
test_data &lt;- generate_expression(100, graph_test, cor = 0.8, absolute = TRUE)
##' # visualise matrix
library("gplots")
# expression data
heatmap.2(test_data, scale = "none", trace = "none",
          col = colorpanel(50, "blue", "white", "red"))
# correlations
heatmap.2(cor(t(test_data)),
          scale = "none", trace = "none",
          col = colorpanel(50, "white", "red"))
# expected correlations (\eqn{\Sigma})
sigma_matrix &lt;- make_sigma_mat_graph(graph_test, cor = 0.8)
heatmap.2(make_sigma_mat_graph(graph_test, cor = 0.8),
          scale = "none", trace = "none",
          col = colorpanel(50, "white", "red"))

# construct a synthetic graph network
graph_structure_edges &lt;- rbind(c("A", "C"), c("B", "C"), c("C", "D"), c("D", "E"),
                               c("D", "F"), c("F", "G"), c("F", "I"), c("H", "I"))
graph_structure &lt;- graph.edgelist(graph_structure_edges, directed = TRUE)

# compute a simulated dataset for toy network
# n = 250 samples
# state = edge_state (properties of each edge)
# cor = 0.95 max correlation between samples
# absolute = FALSE (geometric distance by default)
edge_state &lt;- c(1, 1, -1, 1, 1, 1, 1, -1)
structure_data &lt;- generate_expression(250, graph_structure,
                                      state = edge_state, cor = 0.95)
##' # visualise matrix
library("gplots")
# expression data
heatmap.2(structure_data, scale = "none", trace = "none",
          col = colorpanel(50, "blue", "white", "red"))
# correlations
heatmap.2(cor(t(structure_data)), scale = "none", trace = "none",
          col = colorpanel(50, "blue", "white", "red"))
# expected correlations (\eqn{\Sigma})
sigma_matrix &lt;- make_sigma_mat_graph(graph_structure,
                                     state = edge_state, cor = 0.8)
heatmap.2(make_sigma_mat_graph(graph_structure,
                               state = edge_state, cor = 0.8),
          scale = "none", trace = "none",
          col = colorpanel(50, "blue", "white", "red"))

# compute adjacency matrix for toy network
graph_structure_adjacency_matrix &lt;- make_adjmatrix_graph(graph_structure)
# define states for for each edge
edge_state &lt;- c(1, 1, -1, 1, 1, 1, 1, -1)
# generate simulated data from adjacency matrix input
structure_data &lt;- generate_expression_mat(250, graph_structure_adjacency_matrix,
                                          state = edge_state, cor = 0.8)

# compute a simulated dataset for toy network
# n = 1000 samples
# state = TGFBeta_Smad_state (properties of each edge)
# cor = 0.75 max correlation between samples
# absolute = FALSE (geometric distance by default)
 # compute states directly from graph attributes for TGF-\eqn{\Beta} pathway
TGFBeta_Smad_state &lt;- E(TGFBeta_Smad_graph)$state
table(TGFBeta_Smad_state)
# generate simulated data
TGFBeta_Smad_data &lt;- generate_expression(1000, TGFBeta_Smad_graph, cor = 0.75)
##' # visualise matrix
library("gplots")
# expression data
heatmap.2(TGFBeta_Smad_data, scale = "none", trace = "none",
          col = colorpanel(50, "blue", "white", "red"))
# correlations
heatmap.2(cor(t(TGFBeta_Smad_data)), scale = "none", trace = "none",
          dendrogram = "none", Rowv = FALSE, Colv = FALSE,
          col = colorpanel(50, "blue", "white", "red"))
# expected correlations (\eqn{\Sigma})
sigma_matrix &lt;- make_sigma_mat_dist_graph(TGFBeta_Smad_graph, cor = 0.75)
heatmap.2(make_sigma_mat_dist_graph(TGFBeta_Smad_graph, cor = 0.75),
          scale = "none", trace = "none",
          dendrogram = "none", Rowv = FALSE, Colv = FALSE,
          col = colorpanel(50, "blue", "white", "red"))


# generate simulated data (absolute distance and shared edges)
TGFBeta_Smad_data &lt;- generate_expression(1000, TGFBeta_Smad_graph,
                                         cor = 0.75, absolute = TRUE, comm = TRUE)
##' # visualise matrix
library("gplots")
# expression data
heatmap.2(TGFBeta_Smad_data, scale = "none", trace = "none",
          col = colorpanel(50, "blue", "white", "red"))
# correlations
heatmap.2(cor(t(TGFBeta_Smad_data)), scale = "none", trace = "none",
          dendrogram = "none", Rowv = FALSE, Colv = FALSE,
          col = colorpanel(50, "blue", "white", "red"))
# expected correlations (\eqn{\Sigma})
sigma_matrix &lt;- make_sigma_mat_graph(TGFBeta_Smad_graph,
                                     cor = 0.75, comm = TRUE)
heatmap.2(make_sigma_mat_graph(TGFBeta_Smad_graph, cor = 0.75, comm = TRUE),
          scale = "none", trace = "none",
          dendrogram = "none", Rowv = FALSE, Colv = FALSE,
          col = colorpanel(50, "blue", "white", "red"))

</code></pre>

<hr>
<h2 id='make_adjmatrix'>Generate Adjacency Matrix</h2><span id='topic+make_adjmatrix'></span><span id='topic+make_adjmatrix_graph'></span>

<h3>Description</h3>

<p>Compute the adjacency matrix of a (directed) <code><a href="igraph.html#topic+aaa-igraph-package">igraph</a></code>
structure, preserving node/column/row names (and direction).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_adjmatrix_graph(graph, directed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_adjmatrix_+3A_graph">graph</code></td>
<td>
<p>An <code><a href="igraph.html#topic+aaa-igraph-package">igraph</a></code> object. May be directed or weighted.</p>
</td></tr>
<tr><td><code id="make_adjmatrix_+3A_directed">directed</code></td>
<td>
<p>logical. Whether directed information is passed to the adjacency matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An adjacency matrix compatible with generating an expression matrix
</p>


<h3>Author(s)</h3>

<p>Tom Kelly <a href="mailto:tom.kelly@riken.jp">tom.kelly@riken.jp</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+generate_expression">generate_expression</a></code> for computing the simulated data,
<code><a href="#topic+make_sigma">make_sigma</a></code> for computing the Sigma (<code class="reqn">\Sigma</code>) matrix,
<code><a href="#topic+make_distance">make_distance</a></code> for computing distance from a graph object,
<code><a href="#topic+make_state">make_state</a></code> for resolving inhibiting states.
</p>
<p>See also <code><a href="#topic+plot_directed">plot_directed</a></code> for plotting graphs or 
<code><a href="gplots.html#topic+heatmap.2">heatmap.2</a></code> for plotting matrices.
</p>
<p>See also <code><a href="#topic+make_laplacian">make_laplacian</a></code>
or  <code><a href="#topic+make_commonlink">make_commonlink</a></code> for computing input matrices.
</p>
<p>See also <code><a href="igraph.html#topic+aaa-igraph-package">igraph</a></code> for handling graph objects.
</p>
<p>Other graphsim functions: 
<code><a href="#topic+generate_expression">generate_expression</a>()</code>,
<code><a href="#topic+make_commonlink">make_commonlink</a></code>,
<code><a href="#topic+make_distance">make_distance</a></code>,
<code><a href="#topic+make_laplacian">make_laplacian</a></code>,
<code><a href="#topic+make_sigma">make_sigma</a></code>,
<code><a href="#topic+make_state">make_state</a></code>,
<code><a href="#topic+plot_directed">plot_directed</a>()</code>
</p>
<p>Other graph conversion functions: 
<code><a href="#topic+make_commonlink">make_commonlink</a></code>,
<code><a href="#topic+make_laplacian">make_laplacian</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# construct a synthetic graph module
library("igraph")
graph_test_edges &lt;- rbind(c("A", "B"), c("B", "C"), c("B", "D"))
graph_test &lt;- graph.edgelist(graph_test_edges, directed = TRUE)

# compute adjacency matrix for toy example
adjacency_matrix &lt;- make_adjmatrix_graph(graph_test)
adjacency_matrix

# construct a synthetic graph network
graph_structure_edges &lt;- rbind(c("A", "C"), c("B", "C"), c("C", "D"), c("D", "E"),
                               c("D", "F"), c("F", "G"), c("F", "I"), c("H", "I"))
graph_structure &lt;- graph.edgelist(graph_structure_edges, directed = TRUE)
# compute adjacency matrix for toy network
graph_structure_adjacency_matrix &lt;- make_adjmatrix_graph(graph_structure)
graph_structure_adjacency_matrix

# import graph from package for reactome pathway
# TGF-\eqn{\Beta} receptor signaling activates SMADs (R-HSA-2173789)
TGFBeta_Smad_graph &lt;- identity(TGFBeta_Smad_graph)

# compute adjacency matrix for TGF-\eqn{\Beta} receptor signaling activates SMADs
TGFBeta_Smad_adjacency_matrix &lt;- make_adjmatrix_graph(TGFBeta_Smad_graph)
dim(TGFBeta_Smad_adjacency_matrix)
TGFBeta_Smad_adjacency_matrix[1:12, 1:12]

</code></pre>

<hr>
<h2 id='make_commonlink'>Generate Common Link Matrix</h2><span id='topic+make_commonlink'></span><span id='topic+make_commonlink_adjmat'></span><span id='topic+make_commonlink_graph'></span>

<h3>Description</h3>

<p>Compute the common link matrix of a (directed) <code><a href="igraph.html#topic+aaa-igraph-package">igraph</a></code>
structure, preserving node / column / row names (and direction). We can compute the common 
links between each pair of nodes. This shows how many nodes are mutually connected to both
of the nodes in the matrix (how many paths of length 2 exist between them).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_commonlink_adjmat(adj_mat)

make_commonlink_graph(graph, directed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_commonlink_+3A_adj_mat">adj_mat</code></td>
<td>
<p>precomputed adjacency matrix.</p>
</td></tr>
<tr><td><code id="make_commonlink_+3A_graph">graph</code></td>
<td>
<p>An <code><a href="igraph.html#topic+aaa-igraph-package">igraph</a></code> object. May be directed or weighted.</p>
</td></tr>
<tr><td><code id="make_commonlink_+3A_directed">directed</code></td>
<td>
<p>logical. Whether directed information is passed to the adjacency matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer matrix of number of links shared between nodes
</p>


<h3>Author(s)</h3>

<p>Tom Kelly <a href="mailto:tom.kelly@riken.jp">tom.kelly@riken.jp</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+generate_expression">generate_expression</a></code> for computing the simulated data,
<code><a href="#topic+make_sigma">make_sigma</a></code> for computing the Sigma (<code class="reqn">\Sigma</code>) matrix,
<code><a href="#topic+make_distance">make_distance</a></code> for computing distance from a graph object,
<code><a href="#topic+make_state">make_state</a></code> for resolving inhibiting states.
</p>
<p>See also <code><a href="#topic+plot_directed">plot_directed</a></code> for plotting graphs or 
<code><a href="gplots.html#topic+heatmap.2">heatmap.2</a></code> for plotting matrices.
</p>
<p>See also <code><a href="#topic+make_laplacian">make_laplacian</a></code>
or <code><a href="#topic+make_adjmatrix">make_adjmatrix</a></code> for computing input matrices.
</p>
<p>See also <code><a href="igraph.html#topic+aaa-igraph-package">igraph</a></code> for handling graph objects.
</p>
<p>Other graphsim functions: 
<code><a href="#topic+generate_expression">generate_expression</a>()</code>,
<code><a href="#topic+make_adjmatrix">make_adjmatrix</a></code>,
<code><a href="#topic+make_distance">make_distance</a></code>,
<code><a href="#topic+make_laplacian">make_laplacian</a></code>,
<code><a href="#topic+make_sigma">make_sigma</a></code>,
<code><a href="#topic+make_state">make_state</a></code>,
<code><a href="#topic+plot_directed">plot_directed</a>()</code>
</p>
<p>Other graph conversion functions: 
<code><a href="#topic+make_adjmatrix">make_adjmatrix</a></code>,
<code><a href="#topic+make_laplacian">make_laplacian</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# construct a synthetic graph module
library("igraph")
graph_test_edges &lt;- rbind(c("A", "B"), c("B", "C"), c("B", "D"))
graph_test &lt;- graph.edgelist(graph_test_edges, directed = TRUE)

# compute adjacency matrix for toy example
adjacency_matrix &lt;- make_adjmatrix_graph(graph_test)
# compute nodes with shared edges to a 3rd node
common_link_matrix &lt;- make_commonlink_adjmat(adjacency_matrix)
common_link_matrix

# construct a synthetic graph network
graph_structure_edges &lt;- rbind(c("A", "C"), c("B", "C"), c("C", "D"), c("D", "E"),
                               c("D", "F"), c("F", "G"), c("F", "I"), c("H", "I"))
graph_structure &lt;- graph.edgelist(graph_structure_edges, directed = TRUE)
# compute adjacency matrix for toy network
graph_structure_adjacency_matrix &lt;- make_adjmatrix_graph(graph_structure)
# compute nodes with shared edges to a 3rd node
graph_structure_common_link_matrix &lt;- make_commonlink_adjmat(graph_structure_adjacency_matrix)
graph_structure_common_link_matrix

# import graph from package for reactome pathway
# TGF-\eqn{\Beta} receptor signaling activates SMADs (R-HSA-2173789)
TGFBeta_Smad_graph &lt;- identity(TGFBeta_Smad_graph)
# compute nodes with shared edges to a 3rd node 
TGFBeta_Smad_adjacency_matrix &lt;- make_adjmatrix_graph(TGFBeta_Smad_graph)
TGFBeta_Smad_common_link_matrix &lt;- make_commonlink_adjmat(TGFBeta_Smad_adjacency_matrix)
# we show summary statistics as the graph is large
dim(TGFBeta_Smad_common_link_matrix)
TGFBeta_Smad_common_link_matrix[1:12, 1:12]
# visualise matrix
library("gplots")
heatmap.2(TGFBeta_Smad_common_link_matrix, scale = "none", trace = "none",
          col = colorpanel(50, "white", "red"))

</code></pre>

<hr>
<h2 id='make_distance'>Generate Distance Matrix</h2><span id='topic+make_distance'></span><span id='topic+make_distance_graph'></span><span id='topic+make_relationship'></span><span id='topic+make_distance_adjmat'></span><span id='topic+make_distance_comm'></span><span id='topic+make_distance_laplacian'></span>

<h3>Description</h3>

<p>Compute the distance matrix of using shortest paths of a (directed)
<code><a href="igraph.html#topic+aaa-igraph-package">igraph</a></code> structure, normalising by the diameter of the network,
preserving node/column/row names (and direction). This is used to compute the
simulatted data for <code><a href="#topic+generate_expression">generate_expression</a></code> (when <code>dist = TRUE</code>)
by <code><a href="#topic+make_sigma">make_sigma_mat_dist_graph</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_distance_graph(graph, directed = FALSE, absolute = FALSE)

make_distance_adjmat(mat, directed = FALSE, absolute = FALSE)

make_distance_comm(mat, directed = FALSE, absolute = FALSE)

make_distance_laplacian(mat, directed = FALSE, absolute = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_distance_+3A_graph">graph</code></td>
<td>
<p>An <code><a href="igraph.html#topic+aaa-igraph-package">igraph</a></code> object. May be directed or weighted.</p>
</td></tr>
<tr><td><code id="make_distance_+3A_directed">directed</code></td>
<td>
<p>logical. Whether directed information is passed to the distance matrix.</p>
</td></tr>
<tr><td><code id="make_distance_+3A_absolute">absolute</code></td>
<td>
<p>logical. Whether distances are scaled as the absolute difference
from the diameter (maximum possible). Defaults to TRUE. The alternative is to
calculate a relative difference from the diameter for a geometric decay in distance.</p>
</td></tr>
<tr><td><code id="make_distance_+3A_mat">mat</code></td>
<td>
<p>precomputed adjacency or commonlink matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix of values in the range [0, 1] where higher values are closer in the network
</p>


<h3>Author(s)</h3>

<p>Tom Kelly <a href="mailto:tom.kelly@riken.jp">tom.kelly@riken.jp</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+generate_expression">generate_expression</a></code> for computing the simulated data,
<code><a href="#topic+make_sigma">make_sigma</a></code> for computing the Sigma (<code class="reqn">\Sigma</code>) matrix,
<code><a href="#topic+make_state">make_state</a></code> for resolving inhibiting states.
</p>
<p>See also <code><a href="#topic+plot_directed">plot_directed</a></code> for plotting graphs or 
<code><a href="gplots.html#topic+heatmap.2">heatmap.2</a></code> for plotting matrices.
</p>
<p>See also <code><a href="#topic+make_laplacian">make_laplacian</a></code>, <code><a href="#topic+make_commonlink">make_commonlink</a></code>, 
or <code><a href="#topic+make_adjmatrix">make_adjmatrix</a></code> for computing input matrices.
</p>
<p>See also <code><a href="igraph.html#topic+aaa-igraph-package">igraph</a></code> for handling graph objects.
</p>
<p>Other graphsim functions: 
<code><a href="#topic+generate_expression">generate_expression</a>()</code>,
<code><a href="#topic+make_adjmatrix">make_adjmatrix</a></code>,
<code><a href="#topic+make_commonlink">make_commonlink</a></code>,
<code><a href="#topic+make_laplacian">make_laplacian</a></code>,
<code><a href="#topic+make_sigma">make_sigma</a></code>,
<code><a href="#topic+make_state">make_state</a></code>,
<code><a href="#topic+plot_directed">plot_directed</a>()</code>
</p>
<p>Other generate simulated expression functions: 
<code><a href="#topic+generate_expression">generate_expression</a>()</code>,
<code><a href="#topic+make_sigma">make_sigma</a></code>,
<code><a href="#topic+make_state">make_state</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# construct a synthetic graph module
library("igraph")
graph_test_edges &lt;- rbind(c("A", "B"), c("B", "C"), c("B", "D"))
graph_test &lt;- graph.edgelist(graph_test_edges, directed = TRUE)

# compute adjacency matrix for toy example
adjacency_matrix &lt;- make_adjmatrix_graph(graph_test)
# compute nodes with relationships between nodes (geometrically decreasing by default)
distance_matrix_geom &lt;- make_distance_adjmat(adjacency_matrix)
distance_matrix_geom

# compute nodes with relationships between nodes (arithmetically decreasing)
distance_matrix_abs &lt;- make_distance_adjmat(adjacency_matrix, absolute = TRUE)
distance_matrix_abs

# compute Laplacian matrix
laplacian_matrix &lt;- make_laplacian_graph(graph_test)
# compute distances from Laplacian
distance_matrix &lt;- make_distance_laplacian(laplacian_matrix)

# construct a synthetic graph network
graph_structure_edges &lt;- rbind(c("A", "C"), c("B", "C"), c("C", "D"), c("D", "E"),
                               c("D", "F"), c("F", "G"), c("F", "I"), c("H", "I"))
graph_structure &lt;- graph.edgelist(graph_structure_edges, directed = TRUE)
# compute adjacency matrix for toy network
graph_structure_adjacency_matrix &lt;- make_adjmatrix_graph(graph_structure)
# compute nodes with relationships between nodes (geometrically decreasing by default)
graph_structure_distance_matrix_geom &lt;- make_distance_adjmat(graph_structure_adjacency_matrix)
graph_structure_distance_matrix_geom
# visualise matrix
library("gplots")
heatmap.2(graph_structure_distance_matrix_geom, scale = "none", trace = "none",
          col = colorpanel(50, "white", "red"))
# compute nodes with relationships between nodes (arithmetically decreasing)
graph_structure_distance_matrix_abs &lt;- make_distance_adjmat(graph_structure_adjacency_matrix,
                                                            absolute = TRUE)
graph_structure_distance_matrix_abs
# visualise matrix
library("gplots")
heatmap.2(graph_structure_distance_matrix_abs,
          scale = "none", trace = "none",
          col = colorpanel(50, "white", "red"))
          
# import graph from package for reactome pathway
# TGF-\eqn{\Beta} receptor signaling activates SMADs (R-HSA-2173789)
TGFBeta_Smad_graph &lt;- identity(TGFBeta_Smad_graph)
# compute nodes with relationships between nodes (geometrically decreasing by default)
TGFBeta_Smad_adjacency_matrix &lt;- make_adjmatrix_graph(TGFBeta_Smad_graph)
TGFBeta_Smad_distance_matrix_geom &lt;- make_distance_adjmat(TGFBeta_Smad_adjacency_matrix)
# visualise matrix
library("gplots")
heatmap.2(TGFBeta_Smad_distance_matrix_geom, scale = "none", trace = "none",
          col = colorpanel(50, "white", "red"))
# compute nodes with relationships between nodes (arithmetically decreasing)
TGFBeta_Smad_distance_matrix_abs &lt;- make_distance_adjmat(TGFBeta_Smad_adjacency_matrix,
                        absolute = TRUE)
# visualise matrix
library("gplots")
heatmap.2(TGFBeta_Smad_distance_matrix_abs, scale = "none", trace = "none",
          col = colorpanel(50, "white", "red"))

</code></pre>

<hr>
<h2 id='make_laplacian'>Generate Laplacian Matrix</h2><span id='topic+make_laplacian'></span><span id='topic+make_laplacian_adjmat'></span><span id='topic+make_laplacian_graph'></span>

<h3>Description</h3>

<p>Compute the Laplacian matrix of a (directed) <code><a href="igraph.html#topic+aaa-igraph-package">igraph</a></code>
structure, preserving node/column/row names (and direction).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_laplacian_adjmat(mat, directed = FALSE)

make_laplacian_graph(graph, directed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_laplacian_+3A_mat">mat</code></td>
<td>
<p>precomputed adjacency matrix.</p>
</td></tr>
<tr><td><code id="make_laplacian_+3A_directed">directed</code></td>
<td>
<p>logical. Whether directed information is passed to the Laplacian matrix.</p>
</td></tr>
<tr><td><code id="make_laplacian_+3A_graph">graph</code></td>
<td>
<p>An <code><a href="igraph.html#topic+aaa-igraph-package">igraph</a></code> object. May be directed or weighted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An Laplacian matrix compatible with generating an expression matrix
</p>


<h3>Author(s)</h3>

<p>Tom Kelly <a href="mailto:tom.kelly@riken.jp">tom.kelly@riken.jp</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+generate_expression">generate_expression</a></code> for computing the simulated data,
<code><a href="#topic+make_sigma">make_sigma</a></code> for computing the Sigma (<code class="reqn">\Sigma</code>) matrix,
<code><a href="#topic+make_distance">make_distance</a></code> for computing distance from a graph object,
<code><a href="#topic+make_state">make_state</a></code> for resolving inhibiting states.
</p>
<p>See also <code><a href="#topic+plot_directed">plot_directed</a></code> for plotting graphs or 
<code><a href="gplots.html#topic+heatmap.2">heatmap.2</a></code> for plotting matrices.
</p>
<p>See also <code><a href="#topic+make_commonlink">make_commonlink</a></code>
or <code><a href="#topic+make_adjmatrix">make_adjmatrix</a></code> for computing input matrices.
</p>
<p>See also <code><a href="igraph.html#topic+aaa-igraph-package">igraph</a></code> for handling graph objects.
</p>
<p>Other graphsim functions: 
<code><a href="#topic+generate_expression">generate_expression</a>()</code>,
<code><a href="#topic+make_adjmatrix">make_adjmatrix</a></code>,
<code><a href="#topic+make_commonlink">make_commonlink</a></code>,
<code><a href="#topic+make_distance">make_distance</a></code>,
<code><a href="#topic+make_sigma">make_sigma</a></code>,
<code><a href="#topic+make_state">make_state</a></code>,
<code><a href="#topic+plot_directed">plot_directed</a>()</code>
</p>
<p>Other graph conversion functions: 
<code><a href="#topic+make_adjmatrix">make_adjmatrix</a></code>,
<code><a href="#topic+make_commonlink">make_commonlink</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# construct a synthetic graph module
library("igraph") 
graph_test_edges &lt;- rbind(c("A", "B"), c("B", "C"), c("B", "D"))
graph_test &lt;- graph.edgelist(graph_test_edges, directed = TRUE)
# compute Laplacian matrix for toy example
laplacian_matrix &lt;- make_laplacian_graph(graph_test)
laplacian_matrix

# compute Laplacian matrix from adjacency matrix
adjacency_matrix &lt;- make_adjmatrix_graph(graph_test)
laplacian_matrix &lt;- make_laplacian_adjmat(adjacency_matrix)
laplacian_matrix

# construct a synthetic graph network
graph_structure_edges &lt;- rbind(c("A", "C"), c("B", "C"), c("C", "D"), c("D", "E"),
                               c("D", "F"), c("F", "G"), c("F", "I"), c("H", "I"))
graph_structure &lt;- graph.edgelist(graph_structure_edges, directed = TRUE)
# compute Laplacian matrix for toy network
graph_structure_laplacian_matrix &lt;- make_laplacian_graph(graph_structure)
graph_structure_laplacian_matrix
 
# import graph from package for reactome pathway
# TGF-\eqn{\Beta} receptor signaling activates SMADs (R-HSA-2173789)
TGFBeta_Smad_graph &lt;- identity(TGFBeta_Smad_graph)

# compute Laplacian matrix for TGF-\eqn{\Beta} receptor signaling activates SMADs
TGFBeta_Smad_laplacian_matrix &lt;- make_laplacian_graph(TGFBeta_Smad_graph)
dim(TGFBeta_Smad_laplacian_matrix)
TGFBeta_Smad_laplacian_matrix[1:12, 1:12]
# visualise matrix
library("gplots")
heatmap.2(TGFBeta_Smad_laplacian_matrix, scale = "none", trace = "none",
          col = colorpanel(50, "blue", "white", "red"))

</code></pre>

<hr>
<h2 id='make_sigma'>Generate Sigma (<code class="reqn">\Sigma</code>) Matrix</h2><span id='topic+make_sigma'></span><span id='topic+make_sigma_mat_adjmat'></span><span id='topic+make_sigma_mat_comm'></span><span id='topic+make_sigma_mat_laplacian'></span><span id='topic+make_sigma_mat_graph'></span><span id='topic+make_sigma_mat_dist_adjmat'></span><span id='topic+make_sigma_mat_dist_graph'></span>

<h3>Description</h3>

<p>Compute the Sigma (<code class="reqn">\Sigma</code>) matrix from an <code><a href="igraph.html#topic+aaa-igraph-package">igraph</a></code> structure 
or pre-computed matrix. These are compatible with <code><a href="mvtnorm.html#topic+Mvnorm">rmvnorm</a></code> and
<code><a href="#topic+generate_expression">generate_expression</a></code>.
By default data is generated with a mean of 0 and standard deviation of 1 for 
each gene (with correlations between derived from the graph structure).
Thus where the Sigma (<code class="reqn">\Sigma</code>) matrix has diagonals of 1 (for the variance of each gene)
then the symmetric non-diagonal terms (for covariance) determine the correlations
between each gene in the output from <code><a href="#topic+generate_expression">generate_expression</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_sigma_mat_adjmat(mat, state = NULL, cor = 0.8, sd = 1)

make_sigma_mat_comm(mat, state = NULL, cor = 0.8, sd = 1)

make_sigma_mat_laplacian(mat, state = NULL, cor = 0.8, sd = 1)

make_sigma_mat_graph(
  graph,
  state = NULL,
  cor = 0.8,
  sd = 1,
  comm = FALSE,
  laplacian = FALSE,
  directed = FALSE
)

make_sigma_mat_dist_adjmat(
  mat,
  state = NULL,
  cor = 0.8,
  sd = 1,
  absolute = FALSE
)

make_sigma_mat_dist_graph(
  graph,
  state = NULL,
  cor = 0.8,
  sd = 1,
  absolute = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_sigma_+3A_mat">mat</code></td>
<td>
<p>precomputed adjacency, laplacian, commonlink, or scaled distance matrix (generated by <code><a href="#topic+make_distance">make_distance</a></code>).</p>
</td></tr>
<tr><td><code id="make_sigma_+3A_state">state</code></td>
<td>
<p>numeric vector. Vector of length E(graph). Sign used to calculate 
state matrix, may be an integer state or inferred directly from expected correlations
for each edge. May be applied a scalar across all edges or as a vector for each edge
respectively. May also be entered as text for &quot;activating&quot; or &quot;inhibiting&quot; or as
integers for activating (0,1) or inhibiting (-1,2). Compatible with inputs for 
<code><a href="#topic+plot_directed">plot_directed</a></code>. Also takes a pre-computed state matrix from
<code><a href="#topic+make_state">make_state</a></code> if applied to the same graph multiple times.</p>
</td></tr>
<tr><td><code id="make_sigma_+3A_cor">cor</code></td>
<td>
<p>numeric. Simulated maximum correlation/covariance of two adjacent nodes.
Default to 0.8.</p>
</td></tr>
<tr><td><code id="make_sigma_+3A_sd">sd</code></td>
<td>
<p>standard deviations of each gene. Defaults to 1. May be entered as a scalar
applying to all genes or a vector with a separate value for each.</p>
</td></tr>
<tr><td><code id="make_sigma_+3A_graph">graph</code></td>
<td>
<p>An <code><a href="igraph.html#topic+aaa-igraph-package">igraph</a></code> object. May be directed or weighted.</p>
</td></tr>
<tr><td><code id="make_sigma_+3A_comm">comm</code></td>
<td>
<p>logical whether a common link matrix is used to compute sigma.
Defaults to FALSE (adjacency matrix).</p>
</td></tr>
<tr><td><code id="make_sigma_+3A_laplacian">laplacian</code></td>
<td>
<p>logical whether a Laplacian matrix is used to compute sigma.
Defaults to FALSE (adjacency matrix).</p>
</td></tr>
<tr><td><code id="make_sigma_+3A_directed">directed</code></td>
<td>
<p>logical. Whether directed information is passed to the distance matrix.</p>
</td></tr>
<tr><td><code id="make_sigma_+3A_absolute">absolute</code></td>
<td>
<p>logical. Whether distances are scaled as the absolute difference from
the diameter (maximum possible). Defaults to TRUE. The alternative is to calculate a
relative difference from the diameter for a geometric decay in distance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric covariance matrix of values in the range [-1, 1]
</p>


<h3>Author(s)</h3>

<p>Tom Kelly <a href="mailto:tom.kelly@riken.jp">tom.kelly@riken.jp</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+generate_expression">generate_expression</a></code> for computing the simulated data,
<code><a href="#topic+make_distance">make_distance</a></code> for computing distance from a graph object,
and
<code><a href="#topic+make_state">make_state</a></code> for resolving inhibiting states.
</p>
<p>See also <code><a href="#topic+plot_directed">plot_directed</a></code> for plotting graphs or 
<code><a href="gplots.html#topic+heatmap.2">heatmap.2</a></code> for plotting matrices.
</p>
<p>See also <code><a href="#topic+make_laplacian">make_laplacian</a></code>, <code><a href="#topic+make_commonlink">make_commonlink</a></code>, 
or <code><a href="#topic+make_adjmatrix">make_adjmatrix</a></code> for computing input matrices.
</p>
<p>See also <code><a href="igraph.html#topic+aaa-igraph-package">igraph</a></code> for handling graph objects.
</p>
<p>Other graphsim functions: 
<code><a href="#topic+generate_expression">generate_expression</a>()</code>,
<code><a href="#topic+make_adjmatrix">make_adjmatrix</a></code>,
<code><a href="#topic+make_commonlink">make_commonlink</a></code>,
<code><a href="#topic+make_distance">make_distance</a></code>,
<code><a href="#topic+make_laplacian">make_laplacian</a></code>,
<code><a href="#topic+make_state">make_state</a></code>,
<code><a href="#topic+plot_directed">plot_directed</a>()</code>
</p>
<p>Other generate simulated expression functions: 
<code><a href="#topic+generate_expression">generate_expression</a>()</code>,
<code><a href="#topic+make_distance">make_distance</a></code>,
<code><a href="#topic+make_state">make_state</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# construct a synthetic graph module
library("igraph")
graph_test_edges &lt;- rbind(c("A", "B"), c("B", "C"), c("B", "D"))
graph_test &lt;- graph.edgelist(graph_test_edges, directed = TRUE)
# compute sigma (\eqn{\Sigma}) matrix for toy example
sigma_matrix &lt;- make_sigma_mat_graph(graph_test, cor = 0.8)
sigma_matrix

# compute sigma (\eqn{\Sigma}) matrix  from adjacency matrix for toy example
adjacency_matrix &lt;- make_adjmatrix_graph(graph_test)
sigma_matrix &lt;- make_sigma_mat_adjmat(adjacency_matrix, cor = 0.8)
sigma_matrix

# compute sigma (\eqn{\Sigma}) matrix from shared edges for toy example
common_link_matrix &lt;- make_commonlink_graph(graph_test)
sigma_matrix &lt;- make_sigma_mat_comm(common_link_matrix, cor = 0.8)
sigma_matrix

# compute sigma (\eqn{\Sigma}) matrix from Laplacian for toy example
laplacian_matrix &lt;- make_laplacian_graph(graph_test)
sigma_matrix &lt;- make_sigma_mat_laplacian(laplacian_matrix, cor = 0.8)
sigma_matrix

# compute sigma (\eqn{\Sigma}) matrix from distance matrix for toy example
distance_matrix &lt;- make_distance_graph(graph_test, absolute = FALSE)
sigma_matrix &lt;- make_sigma_mat_dist_adjmat(distance_matrix, cor = 0.8)
sigma_matrix

# compute sigma (\eqn{\Sigma}) matrix from geometric distance directly from toy example graph
sigma_matrix &lt;- make_sigma_mat_dist_graph(graph_test, cor = 0.8)
sigma_matrix

# compute sigma (\eqn{\Sigma}) matrix from absolute distance directly from toy example graph
sigma_matrix &lt;- make_sigma_mat_dist_graph(graph_test, cor = 0.8, absolute = TRUE)
sigma_matrix

# compute sigma (\eqn{\Sigma}) matrix from geometric distance with sd = 2
sigma_matrix &lt;- make_sigma_mat_dist_graph(graph_test, cor = 0.8, sd = 2)
sigma_matrix

# construct a synthetic graph network
graph_structure_edges &lt;- rbind(c("A", "C"), c("B", "C"), c("C", "D"), c("D", "E"),
                               c("D", "F"), c("F", "G"), c("F", "I"), c("H", "I"))
graph_structure &lt;- graph.edgelist(graph_structure_edges, directed = TRUE)

# compute sigma (\eqn{\Sigma}) matrix from geometric distance directly from synthetic graph network
sigma_matrix_graph_structure &lt;- make_sigma_mat_dist_graph(graph_structure,
                                                          cor = 0.8, absolute = FALSE)
sigma_matrix_graph_structure
# visualise matrix
library("gplots")
heatmap.2(sigma_matrix_graph_structure, scale = "none", trace = "none",
                     col = colorpanel(50, "white", "red"))

# compute sigma (\eqn{\Sigma}) matrix from geometric distance directly from
# synthetic graph network with inhibitions
edge_state &lt;- c(1, 1, -1, 1, 1, 1, 1, -1)
# pass edge state as a parameter
sigma_matrix_graph_structure_inhib &lt;- make_sigma_mat_dist_graph(graph_structure, 
                                                                state = edge_state,
                                                                cor = 0.8,
                                                                absolute = FALSE)
sigma_matrix_graph_structure_inhib
# visualise matrix
library("gplots")
heatmap.2(sigma_matrix_graph_structure_inhib, scale = "none", trace = "none",
          col = colorpanel(50, "blue", "white", "red"))

# compute sigma (\eqn{\Sigma}) matrix from geometric distance directly from 
# synthetic graph network with inhibitions
E(graph_structure)$state &lt;-  c(1, 1, -1, 1, 1, 1, 1, -1)
# pass edge state as a graph attribute
sigma_matrix_graph_structure_inhib &lt;- make_sigma_mat_dist_graph(graph_structure,
                                                                cor = 0.8,
                                                                absolute = FALSE)
sigma_matrix_graph_structure_inhib
# visualise matrix
library("gplots")
heatmap.2(sigma_matrix_graph_structure_inhib, scale = "none", trace = "none",
          col = colorpanel(50, "blue", "white", "red"))

# import graph from package for reactome pathway
# TGF-\eqn{\Beta} receptor signaling activates SMADs (R-HSA-2173789)
TGFBeta_Smad_graph &lt;- identity(TGFBeta_Smad_graph)

# compute sigma (\eqn{\Sigma}) matrix from geometric distance directly from TGF-\eqn{\Beta} pathway
TFGBeta_Smad_state &lt;- E(TGFBeta_Smad_graph)$state
table(TFGBeta_Smad_state)
# states are edge attributes
 sigma_matrix_TFGBeta_Smad_inhib &lt;- make_sigma_mat_dist_graph(TGFBeta_Smad_graph,
                                                              cor = 0.8,
                                                              absolute = FALSE)
# visualise matrix
library("gplots")
heatmap.2(sigma_matrix_TFGBeta_Smad_inhib, scale = "none", trace = "none",
          col = colorpanel(50, "blue", "white", "red"))

# compute sigma (\eqn{\Sigma}) matrix from geometric distance directly from TGF-\eqn{\Beta} pathway
TGFBeta_Smad_graph &lt;- remove.edge.attribute(TGFBeta_Smad_graph, "state")
# compute with states removed (all negative)
sigma_matrix_TFGBeta_Smad &lt;- make_sigma_mat_dist_graph(TGFBeta_Smad_graph,
                                                       state = -1,
                                                       cor = 0.8,
                                                       absolute = FALSE)
# visualise matrix
library("gplots")
heatmap.2(sigma_matrix_TFGBeta_Smad, scale = "none", trace = "none",
          col = colorpanel(50, "white", "red"))
# compute with states removed (all positive)
sigma_matrix_TFGBeta_Smad &lt;- make_sigma_mat_dist_graph(TGFBeta_Smad_graph,
                                                       state = 1,
                                                       cor = 0.8,
                                                       absolute = FALSE)
# visualise matrix
library("gplots")
heatmap.2(sigma_matrix_TFGBeta_Smad, scale = "none", trace = "none",
          col = colorpanel(50, "white", "red"))

#restore edge attributes
TGFBeta_Smad_graph &lt;- set_edge_attr(TGFBeta_Smad_graph, "state",
                                    value = TFGBeta_Smad_state)
TFGBeta_Smad_state &lt;- E(TGFBeta_Smad_graph)$state
# states are edge attributes
 sigma_matrix_TFGBeta_Smad_inhib &lt;- make_sigma_mat_dist_graph(TGFBeta_Smad_graph,
                                                              cor = 0.8,
                                                              absolute = FALSE)
# visualise matrix
library("gplots")
heatmap.2(sigma_matrix_TFGBeta_Smad_inhib, scale = "none", trace = "none",
          col = colorpanel(50, "blue", "white", "red"))

</code></pre>

<hr>
<h2 id='make_state'>Make State Matrix</h2><span id='topic+make_state'></span><span id='topic+make_state_matrix'></span>

<h3>Description</h3>

<p>Functions to compute the matrix of states (1 for activating and -1 for inhibiting) 
for link signed correlations, from a vector of edge states to a signed adjacency matrix for use
in <code><a href="#topic+generate_expression">generate_expression</a></code>. This resolves edge states to determine the sign
of all correlations between nodes in a network. These are computed interally for sigma matrices
as required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_state_matrix(graph, state = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_state_+3A_graph">graph</code></td>
<td>
<p>An <code><a href="igraph.html#topic+aaa-igraph-package">igraph</a></code> object. May be directed or weighted as long as
a shortest path can be computed.</p>
</td></tr>
<tr><td><code id="make_state_+3A_state">state</code></td>
<td>
<p>numeric vector. Vector of length E(graph). Sign used to calculate state matrix,
may be an integer state or inferred directly from expected correlations for each edge. May be
applied a scalar across all edges or as a vector for each edge respectively. May also be
entered as text for &quot;activating&quot; or &quot;inhibiting&quot; or as integers for activating (0,1) or
inhibiting (-1,2). Compatible with inputs for <code><a href="#topic+plot_directed">plot_directed</a></code>. Vector 
input is supported either directly calling the function with a value for each edge in 
<code>E(graph)</code> or as an edge &quot;attribute&quot; in the igraph object (using 
<code>E(g)$state &lt;- states</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer matrix indicating the resolved state
(activating or inhibiting for each edge or path between nodes)
</p>


<h3>Author(s)</h3>

<p>Tom Kelly <a href="mailto:tom.kelly@riken.jp">tom.kelly@riken.jp</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+generate_expression">generate_expression</a></code> for computing the simulated data,
<code><a href="#topic+make_sigma">make_sigma</a></code> for computing the Sigma (<code class="reqn">\Sigma</code>) matrix,
and
<code><a href="#topic+make_distance">make_distance</a></code> for computing distance from a graph object.
</p>
<p>See also <code><a href="#topic+plot_directed">plot_directed</a></code> for plotting graphs or 
<code><a href="gplots.html#topic+heatmap.2">heatmap.2</a></code> for plotting matrices.
</p>
<p>See also <code><a href="#topic+make_laplacian">make_laplacian</a></code>, <code><a href="#topic+make_commonlink">make_commonlink</a></code>, 
or <code><a href="#topic+make_adjmatrix">make_adjmatrix</a></code> for computing input matrices.
</p>
<p>See also <code><a href="igraph.html#topic+aaa-igraph-package">igraph</a></code> for handling graph objects.
</p>
<p>Other graphsim functions: 
<code><a href="#topic+generate_expression">generate_expression</a>()</code>,
<code><a href="#topic+make_adjmatrix">make_adjmatrix</a></code>,
<code><a href="#topic+make_commonlink">make_commonlink</a></code>,
<code><a href="#topic+make_distance">make_distance</a></code>,
<code><a href="#topic+make_laplacian">make_laplacian</a></code>,
<code><a href="#topic+make_sigma">make_sigma</a></code>,
<code><a href="#topic+plot_directed">plot_directed</a>()</code>
</p>
<p>Other generate simulated expression functions: 
<code><a href="#topic+generate_expression">generate_expression</a>()</code>,
<code><a href="#topic+make_distance">make_distance</a></code>,
<code><a href="#topic+make_sigma">make_sigma</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# construct a synthetic graph module
library("igraph")
graph_test_edges &lt;- rbind(c("A", "B"), c("B", "C"), c("B", "D"))
graph_test &lt;- graph.edgelist(graph_test_edges, directed = TRUE)

 # compute state matrix for toy example
state_matrix &lt;- make_state_matrix(graph_test)

# construct a synthetic graph network
graph_structure_edges &lt;- rbind(c("A", "C"), c("B", "C"), c("C", "D"), c("D", "E"),
                               c("D", "F"), c("F", "G"), c("F", "I"), c("H", "I"))
graph_structure &lt;- graph.edgelist(graph_structure_edges, directed = TRUE)

# compute state matrix for toy network
graph_structure_state_matrix &lt;- make_state_matrix(graph_structure)
graph_structure_state_matrix

# compute state matrix for toy network with inhibitions
edge_state &lt;- c(1, 1, -1, 1, 1, 1, 1, -1)
# edge states are a variable
graph_structure_state_matrix &lt;- make_state_matrix(graph_structure, state = edge_state)
graph_structure_state_matrix

# compute state matrix for toy network with inhibitions
E(graph_structure)$state &lt;- c(1, 1, -1, 1, 1, 1, 1, -1)
# edge states are a graph attribute
graph_structure_state_matrix &lt;- make_state_matrix(graph_structure)
graph_structure_state_matrix

library("igraph")
graph_test_edges &lt;- rbind(c("A", "B"), c("B", "C"), c("B", "D"))
graph_test &lt;- graph.edgelist(graph_test_edges, directed = TRUE)
state_matrix &lt;- make_state_matrix(graph_test)

# import graph from package for reactome pathway
# TGF-\eqn{\Beta} receptor signaling activates SMADs (R-HSA-2173789)
TGFBeta_Smad_graph &lt;- identity(TGFBeta_Smad_graph)

# compute sigma (\eqn{\Sigma}) matrix from geometric distance directly from TGF-\eqn{\Beta} pathway
TFGBeta_Smad_state &lt;- E(TGFBeta_Smad_graph)$state
table(TFGBeta_Smad_state)
# states are edge attributes
state_matrix_TFGBeta_Smad &lt;- make_state_matrix(TGFBeta_Smad_graph)
# visualise matrix
library("gplots")
heatmap.2(state_matrix_TFGBeta_Smad , scale = "none", trace = "none",
          dendrogram = "none", Rowv = FALSE, Colv = FALSE,
          col = colorpanel(50, "blue", "white", "red"))

# compare the states to the sign of expected correlations in the sigma matrix
sigma_matrix_TFGBeta_Smad_inhib &lt;- make_sigma_mat_dist_graph(TGFBeta_Smad_graph,
                                                             cor = 0.8,
                                                             absolute = FALSE)
# visualise matrix
heatmap.2(sigma_matrix_TFGBeta_Smad_inhib,
          scale = "none", trace = "none",
          dendrogram = "none", Rowv = FALSE, Colv = FALSE,
          col = colorpanel(50, "blue", "white", "red"))

# compare the states to the sign of final correlations in the simulated matrix
TFGBeta_Smad_data &lt;- generate_expression(100, TGFBeta_Smad_graph, cor = 0.8)
heatmap.2(cor(t(TFGBeta_Smad_data)), scale = "none", trace = "none",
          dendrogram = "none", Rowv = FALSE, Colv = FALSE,
          col = colorpanel(50, "blue", "white", "red"))


</code></pre>

<hr>
<h2 id='Pi3K_AKT_graph'>PI3K/AKT activation</h2><span id='topic+Pi3K_AKT_graph'></span>

<h3>Description</h3>

<p>Reactome pathway R-HSA-198203 for the interactions in the phosphoinositide-3-kinase activation of Protein kinase B (PKB), also known as Akt
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pi3K_AKT_graph
</code></pre>


<h3>Format</h3>

<p>A graph object of 275 vertices and 21106 edges:
</p>

<dl>
<dt>V</dt><dd><p>gene symbol (human)</p>
</dd>
<dt>E</dt><dd><p>directed relationship for pathway</p>
</dd>
<dt>state</dt><dd><p>type of relationship (activating or inhibiting) as edge attribute</p>
</dd>
</dl>



<h3>Source</h3>

<p>PathwayCommons <a href="https://reactome.org/content/detail/R-HSA-198203">https://reactome.org/content/detail/R-HSA-198203</a>
</p>

<hr>
<h2 id='Pi3K_graph'>PI3K Cascade</h2><span id='topic+Pi3K_graph'></span>

<h3>Description</h3>

<p>Reactome pathway R-HSA-109704 for the interactions in the phosphoinositide-3-kinase cascade
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pi3K_graph
</code></pre>


<h3>Format</h3>

<p>A graph object of 35 vertices and 251 edges:
</p>

<dl>
<dt>V</dt><dd><p>gene symbol (human)</p>
</dd>
<dt>E</dt><dd><p>directed relationship for pathway</p>
</dd>
<dt>state</dt><dd><p>type of relationship (activating or inhibiting) as edge attribute</p>
</dd>
</dl>



<h3>Source</h3>

<p>PathwayCommons <a href="https://reactome.org/content/detail/R-HSA-109704">https://reactome.org/content/detail/R-HSA-109704</a>
</p>

<hr>
<h2 id='plot_directed'>Extensions to igraph for Customising plots</h2><span id='topic+plot_directed'></span><span id='topic+plot.directed'></span>

<h3>Description</h3>

<p>Functions to plot_directed or graph structures including customised colours, layout, states, arrows. Uses graphs functions as an extension of <code><a href="igraph.html#topic+aaa-igraph-package">igraph</a></code>. Designed for plotting directed graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_directed(
  graph,
  state = NULL,
  labels = NULL,
  layout = layout.fruchterman.reingold,
  cex.node = 1,
  cex.label = 0.75,
  cex.arrow = 1.25,
  cex.main = 0.8,
  cex.sub = 0.8,
  arrow_clip = 0.075,
  pch = 21,
  border.node = "grey33",
  fill.node = "grey66",
  col.label = NULL,
  col.arrow = NULL,
  main = NULL,
  sub = NULL,
  xlab = "",
  ylab = "",
  frame.plot = F
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_directed_+3A_graph">graph</code></td>
<td>
<p>An <code><a href="igraph.html#topic+aaa-igraph-package">igraph</a></code> object. Must be directed with known states.</p>
</td></tr>
<tr><td><code id="plot_directed_+3A_state">state</code></td>
<td>
<p>character or integer. Defaults to &quot;activating&quot; if no &quot;state&quot; edge attribute 
found. May be applied a scalar across all edges or as a vector for each edge respectively. 
Accepts non-integer values for weighted edges provided that the sign indicates whether links
are activating (positive) or inhibiting (negative). May also be entered as text for 
&quot;activating&quot; or &quot;inhibiting&quot; or as integers for activating (0,1) or inhibiting (-1,2). 
Compatible with inputs for make_state_matrix or generate_expression_graph in the graphsim 
package <a href="https://github.com/TomKellyGenetics/graphsim">https://github.com/TomKellyGenetics/graphsim</a>. Vector input is supported</p>
</td></tr>
<tr><td><code id="plot_directed_+3A_labels">labels</code></td>
<td>
<p>character vector. For labels to plot nodes. Defaults to vertex names in 
graph object. Entering &quot;&quot; would yield unlabelled nodes.</p>
</td></tr>
<tr><td><code id="plot_directed_+3A_layout">layout</code></td>
<td>
<p>function. Layout function as selected from <code><a href="igraph.html#topic+aaa-igraph-package">layout_</a></code>. 
Defaults to layout.fruchterman.reingold. Alternatives include layout.kamada.kawai, 
layout.reingold.tilford, layout.sugiyama, and layout.davidson.harel. A 2-column 
layout matrix giving x and y co-ordinates of each node can be given.</p>
</td></tr>
<tr><td><code id="plot_directed_+3A_cex.node">cex.node</code></td>
<td>
<p>numeric. Defaults to 1.</p>
</td></tr>
<tr><td><code id="plot_directed_+3A_cex.label">cex.label</code></td>
<td>
<p>numeric. Defaults to 0.75.</p>
</td></tr>
<tr><td><code id="plot_directed_+3A_cex.arrow">cex.arrow</code></td>
<td>
<p>numeric Defaults to 1.25. May take a scalar applied to all edges 
or a vector with values for each edge respectively.</p>
</td></tr>
<tr><td><code id="plot_directed_+3A_cex.main">cex.main</code></td>
<td>
<p>numeric. Defaults to 0.8.</p>
</td></tr>
<tr><td><code id="plot_directed_+3A_cex.sub">cex.sub</code></td>
<td>
<p>numeric. Defaults to 0.8.</p>
</td></tr>
<tr><td><code id="plot_directed_+3A_arrow_clip">arrow_clip</code></td>
<td>
<p>numeric Defaults to 0.075 (7.5%).</p>
</td></tr>
<tr><td><code id="plot_directed_+3A_pch">pch</code></td>
<td>
<p>parameter passed to plot. Defaults to 21. Recommends using selecting 
between 21-25 to preserve colour behaviour. Otherwise entire node will inherit 
border.node as it's colour, in which case a light colour is recommended to see labels.</p>
</td></tr>
<tr><td><code id="plot_directed_+3A_border.node">border.node</code></td>
<td>
<p>character. Specifies the colours of node border passed to plot.
Defaults to grey33. Applies to whole node shape if pch has only one colour.</p>
</td></tr>
<tr><td><code id="plot_directed_+3A_fill.node">fill.node</code></td>
<td>
<p>character. Specfies the colours of node fill passed to plot. 
Defaults to grey66.</p>
</td></tr>
<tr><td><code id="plot_directed_+3A_col.label">col.label</code></td>
<td>
<p>character. Specfies the colours of node labels passed to plot. 
Defaults to par(&quot;fg&quot;).</p>
</td></tr>
<tr><td><code id="plot_directed_+3A_col.arrow">col.arrow</code></td>
<td>
<p>character. Specfies the colours of arrows passed to plot. 
Defaults to par(&quot;fg&quot;).  May take a scalar applied to all edges or a vector
with colours for each edge respectively.</p>
</td></tr>
<tr><td><code id="plot_directed_+3A_main">main</code>, <code id="plot_directed_+3A_sub">sub</code>, <code id="plot_directed_+3A_xlab">xlab</code>, <code id="plot_directed_+3A_ylab">ylab</code></td>
<td>
<p>Plotting parameters to specify plot titles or axes labels</p>
</td></tr>
<tr><td><code id="plot_directed_+3A_frame.plot">frame.plot</code></td>
<td>
<p>logical. Whether to frame plot with a box. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>base R graphics
</p>


<h3>Author(s)</h3>

<p>Tom Kelly <a href="mailto:tom.kelly@riken.jp">tom.kelly@riken.jp</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+generate_expression">generate_expression</a></code> for computing the simulated data,
<code><a href="#topic+make_sigma">make_sigma</a></code> for computing the Sigma (<code class="reqn">\Sigma</code>) matrix,
<code><a href="#topic+make_distance">make_distance</a></code> for computing distance from a graph object,
<code><a href="#topic+make_state">make_state</a></code> for resolving inhibiting states.
</p>
<p>See also <code><a href="gplots.html#topic+heatmap.2">heatmap.2</a></code> for plotting matrices.
</p>
<p>See also <code><a href="#topic+make_laplacian">make_laplacian</a></code>, <code><a href="#topic+make_commonlink">make_commonlink</a></code>, 
or <code><a href="#topic+make_adjmatrix">make_adjmatrix</a></code> for computing input matrices.
</p>
<p>See also <code><a href="igraph.html#topic+aaa-igraph-package">igraph</a></code> for handling graph objects
and <code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code> for base R <code><a href="base.html#topic+plot">plot</a></code> methods.
</p>
<p>Other graphsim functions: 
<code><a href="#topic+generate_expression">generate_expression</a>()</code>,
<code><a href="#topic+make_adjmatrix">make_adjmatrix</a></code>,
<code><a href="#topic+make_commonlink">make_commonlink</a></code>,
<code><a href="#topic+make_distance">make_distance</a></code>,
<code><a href="#topic+make_laplacian">make_laplacian</a></code>,
<code><a href="#topic+make_sigma">make_sigma</a></code>,
<code><a href="#topic+make_state">make_state</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# generate example graphs
library("igraph")
graph_structure_edges &lt;- rbind(c("A", "C"), c("B", "C"), c("C", "D"), c("D", "E"),
                           c("D", "F"), c("F", "G"), c("F", "I"), c("H", "I"))
graph_structure &lt;- graph.edgelist(graph_structure_edges, directed = TRUE)

# plots with igraph defaults
plot(graph_structure, layout = layout.fruchterman.reingold)
plot(graph_structure, layout = layout.kamada.kawai)

# plots with scalar states
plot_directed(graph_structure, state="activating")
plot_directed(graph_structure, state="inhibiting")

# plots with vector states
plot_directed(graph_structure, state = c(1, 1, 1, 1, -1, 1, 1, 1))
plot_directed(graph_structure, state = c(1, 1, -1, 1, -1, 1, -1, 1))
plot_directed(graph_structure, state = c(1, 1, -1, 1, 1, 1, 1, -1))

# plots states with graph attributes
E(graph_structure)$state &lt;- 1
plot_directed(graph_structure)
E(graph_structure)$state &lt;- c(1, 1, -1, 1, -1, 1, -1, 1)
plot_directed(graph_structure)

# plot layout customised
plot_directed(graph_structure, state=c(1, 1, -1, 1, -1, 1, -1, 1), layout = layout.kamada.kawai)

</code></pre>

<hr>
<h2 id='RAF_MAP_graph'>#' RAF/MAP kinase cascade</h2><span id='topic+RAF_MAP_graph'></span>

<h3>Description</h3>

<p>Reactome pathway R-HSA-5673001 for the interactions in the RAF/MAP kinase cascade
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RAF_MAP_graph
</code></pre>


<h3>Format</h3>

<p>A graph object of 17 vertices and 121 edges:
</p>

<dl>
<dt>V</dt><dd><p>gene symbol (human)</p>
</dd>
<dt>E</dt><dd><p>directed relationship for pathway</p>
</dd>
</dl>



<h3>Source</h3>

<p>PathwayCommons <a href="https://reactome.org/content/detail/R-HSA-5673001">https://reactome.org/content/detail/R-HSA-5673001</a>
</p>

<hr>
<h2 id='TGFBeta_Smad_graph'>TGF-<code class="reqn">\beta</code> receptor signaling activates SMADs</h2><span id='topic+TGFBeta_Smad_graph'></span>

<h3>Description</h3>

<p>Reactome pathway R-HSA-2173789 for the interactions in the TGF-<code class="reqn">\beta</code> receptor signaling activates SMADs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TGFBeta_Smad_graph
</code></pre>


<h3>Format</h3>

<p>A graph object of 32 vertices and 173 edges:
</p>

<dl>
<dt>V</dt><dd><p>gene symbol (human)</p>
</dd>
<dt>E</dt><dd><p>directed relationship for pathway</p>
</dd>
<dt>state</dt><dd><p>type of relationship (activating or inhibiting) as edge attribute</p>
</dd>
</dl>



<h3>Source</h3>

<p>PathwayCommons <a href="https://reactome.org/content/detail/R-HSA-2173789">https://reactome.org/content/detail/R-HSA-2173789</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
