<!DOCTYPE html><html><head><title>Help for package sccore</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sccore}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adjacent_vertex_weights'><p>List of adjacent vertex weights from igraph object</p></a></li>
<li><a href='#adjacentVertices'><p>List of adjacent vertices from igraph object</p></a></li>
<li><a href='#appendSpecificityMetricsToDE'><p>Append specificity metrics to DE</p></a></li>
<li><a href='#as_factor'><p>convert character vector into a factor with names &quot;values&quot; and &quot;levels&quot;</p></a></li>
<li><a href='#cellAnnotations'><p>Conos cell annotations</p></a></li>
<li><a href='#checkPackageInstalled'><p>Check whether a package is installed and suggest how to install from CRAN, Bioconductor, or other external source</p></a></li>
<li><a href='#collapseCellsByType'><p>Collapse count matrices by cell type, given min/max number of cells</p></a></li>
<li><a href='#collapseGraphPaga'><p>Collapse graph using PAGA 1.2 algorithm, Wolf et al 2019, Genome Biology (2019) &lt;https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1663-x&gt;</p></a></li>
<li><a href='#collapseGraphSum'><p>Collapse Graph By Sum</p></a></li>
<li><a href='#colSumByFactor'><p>Calculates factor-stratified sums for each column</p></a></li>
<li><a href='#computeChebyshevCoeffs'><p>Compute Chebyshev Coefficients</p></a></li>
<li><a href='#conosClusterList'><p>Conos clusters list</p></a></li>
<li><a href='#conosGraph'><p>Conos graph</p></a></li>
<li><a href='#dotPlot'><p>Dot plot adapted from Seurat:::DotPlot, see ?Seurat:::DotPlot for details</p></a></li>
<li><a href='#embeddingColorsPlot'><p>Set colors for embedding plot. Used primarily in embeddingPlot().</p></a></li>
<li><a href='#embeddingGroupPlot'><p>Plotting function for cluster labels, names contain cell names. Used primarily in embeddingPlot().</p></a></li>
<li><a href='#embeddingPlot'><p>Plot embedding with provided labels / colors using ggplot2</p></a></li>
<li><a href='#embedGraphUmap'><p>Embed a graph into a UMAP, Uniform Manifold Approximation and Projection for Dimension Reduction, &lt;https://github.com/lmcinnes/umap&gt;, &lt;doi:10.21105/joss.00861&gt;</p></a></li>
<li><a href='#embedKnnGraph'><p>Embed a k-nearest neighbor (kNN) graph within a UMAP. Used within embedGraphUmap(). Please see McInnes et al &lt;doi:10.21105/joss.00861&gt; for the UMAP description and implementation.</p></a></li>
<li><a href='#extendMatrix'><p>Extend matrix to include new columns in matrix</p></a></li>
<li><a href='#fac2col'><p>Utility function to translate a factor into colors</p></a></li>
<li><a href='#fac2palette'><p>Encodes logic of how to handle named-vector and functional palettes. Used primarily within embeddingGroupPlot()</p></a></li>
<li><a href='#get_nearest_neighbors'><p>Get nearest neighbors method on graph</p></a></li>
<li><a href='#getClusterGraph'><p>Collapse vertices belonging to each cluster in a graph</p></a></li>
<li><a href='#graphToAdjList'><p>Convert igraph graph into an adjacency list</p></a></li>
<li><a href='#heatFilter'><p>Graph filter with the heat kernel: <code class="reqn">f(x) = exp(-\beta |x / \lambda_m - a|^b)</code></p></a></li>
<li><a href='#jsDist'><p>Jensen–Shannon distance metric (i.e. the square root of the Jensen–Shannon divergence) between the columns of a dense matrix m</p></a></li>
<li><a href='#mergeCountMatrices'><p>Merge list of count matrices into a common matrix, entering 0s for the missing entries</p></a></li>
<li><a href='#multi2dend'><p>Translate multilevel segmentation into a dendrogram, with the lowest level of the dendrogram listing the cells</p></a></li>
<li><a href='#plapply'><p>Parallel, optionally verbose lapply. See ?parallel::mclapply for more info.</p></a></li>
<li><a href='#propagate_labels'><p>Label propagation</p></a></li>
<li><a href='#propagateLabels'><p>Estimate labeling distribution for each vertex, based on provided labels.</p></a></li>
<li><a href='#propagateLabelsDiffusion'><p>Estimate labeling distribution for each vertex, based on provided labels using a Random Walk on graph</p></a></li>
<li><a href='#propagateLabelsSolver'><p>Propagate labels using Zhu, Ghahramani, Lafferty (2003) algorithm, &quot;Semi-Supervised Learning Using Gaussian Fields and Harmonic Functions&quot; &lt;http://mlg.eng.cam.ac.uk/zoubin/papers/zgl.pdf&gt;</p></a></li>
<li><a href='#saveDeAsJson'><p>Save DE results as JSON tables for viewing in browser</p></a></li>
<li><a href='#setMinMax'><p>Set range for values in object. Changes values outside of range to min or max. Adapted from Seurat::MinMax</p></a></li>
<li><a href='#smooth_count_matrix'><p>Smooth gene expression, used primarily within conos::correctGenes. Used to smooth gene expression values in order to better represent the graph structure.</p>
Use diffusion of expression on graph with the equation dv = exp(-a * (v + b))</a></li>
<li><a href='#smoothChebyshev'><p>Smooth with Chebyshev Polynomials</p></a></li>
<li><a href='#smoothSignalOnGraph'><p>Smooth Signal on Graph</p></a></li>
<li><a href='#sn'><p>Set names equal to values, a stats::setNames wrapper function</p></a></li>
<li><a href='#splitVectorByNodes'><p>splitVectorByNodes</p></a></li>
<li><a href='#styleEmbeddingPlot'><p>Set plot.theme, legend, ticks for embedding plot. Used primarily in embeddingPlot().</p></a></li>
<li><a href='#umapEmbedding'><p>UMAP embedding</p></a></li>
<li><a href='#val2col'><p>Utility function to translate values into colors.</p></a></li>
<li><a href='#val2ggcol'><p>Helper function to return a ggplot color gradient for a numeric vector</p>
ggplot(aes(color=x, ...), ...) + val2ggcol(x)</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Core Utilities for Single-Cell RNA-Seq</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Core utilities for single-cell RNA-seq data analysis. Contained within are utility functions for working with differential expression (DE) matrices and count matrices, a collection of functions for manipulating and plotting data via 'ggplot2', and functions to work with cell graphs and cell embeddings. Graph-based methods include embedding kNN cell graphs into a UMAP &lt;<a href="https://doi.org/10.21105%2Fjoss.00861">doi:10.21105/joss.00861</a>&gt;, collapsing vertices of each cluster in the graph, and propagating graph labels.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, ggplot2, ggrepel, graphics, grDevices, igraph, irlba,
magrittr, Matrix, methods, parallel, pbmcapply, pROC, Rcpp,
rlang, scales, stats, tibble, utils, uwot, withr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggrastr (&ge; 0.1.7), jsonlite, rmumps, testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppProgress, RcppEigen</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/kharchenkolab/sccore">https://github.com/kharchenkolab/sccore</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kharchenkolab/sccore/issues">https://github.com/kharchenkolab/sccore/issues</a></td>
</tr>
<tr>
<td>Author:</td>
<td>Viktor Petukhov [aut],
  Rasmus Rydbirk [aut],
  Peter Kharchenko [aut],
  Evan Biederstedt [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Evan Biederstedt &lt;evan.biederstedt@gmail.com&gt;</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-22 23:19:51 UTC; evanbiederstedt</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-23 00:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adjacent_vertex_weights'>List of adjacent vertex weights from igraph object</h2><span id='topic+adjacent_vertex_weights'></span>

<h3>Description</h3>

<p>List of adjacent vertex weights from igraph object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjacent_vertex_weights(edge_verts, edge_weights)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjacent_vertex_weights_+3A_edge_verts">edge_verts</code></td>
<td>
<p>edge vertices of igraph graph object</p>
</td></tr>
<tr><td><code id="adjacent_vertex_weights_+3A_edge_weights">edge_weights</code></td>
<td>
<p>edge weights of igraph graph object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of adjacent vertices
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
edges &lt;- igraph::as_edgelist(conosGraph)
edge.weights &lt;- igraph::edge.attributes(conosGraph)$weight
adjacent_vertex_weights(edges, edge.weights)

## End(Not run)
</code></pre>

<hr>
<h2 id='adjacentVertices'>List of adjacent vertices from igraph object</h2><span id='topic+adjacentVertices'></span>

<h3>Description</h3>

<p>List of adjacent vertices from igraph object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjacentVertices(edge_verts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjacentVertices_+3A_edge_verts">edge_verts</code></td>
<td>
<p>edge vertices of igraph graph object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of adjacent vertices
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
edges &lt;- igraph::as_edgelist(conosGraph)
adjacentVertices(edges)

## End(Not run)
</code></pre>

<hr>
<h2 id='appendSpecificityMetricsToDE'>Append specificity metrics to DE</h2><span id='topic+appendSpecificityMetricsToDE'></span>

<h3>Description</h3>

<p>Append specificity metrics to DE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>appendSpecificityMetricsToDE(
  de.df,
  clusters,
  cluster.id,
  p2.counts,
  low.expression.threshold = 0,
  append.auc = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="appendSpecificityMetricsToDE_+3A_de.df">de.df</code></td>
<td>
<p>data.frame of differential expression values</p>
</td></tr>
<tr><td><code id="appendSpecificityMetricsToDE_+3A_clusters">clusters</code></td>
<td>
<p>factor of clusters</p>
</td></tr>
<tr><td><code id="appendSpecificityMetricsToDE_+3A_cluster.id">cluster.id</code></td>
<td>
<p>names of 'clusters' factor. If a cluster.id doesn't exist in cluster names, an error is thrown.</p>
</td></tr>
<tr><td><code id="appendSpecificityMetricsToDE_+3A_p2.counts">p2.counts</code></td>
<td>
<p>counts from Pagoda2, refer to &lt;https://github.com/kharchenkolab/pagoda2&gt;</p>
</td></tr>
<tr><td><code id="appendSpecificityMetricsToDE_+3A_low.expression.threshold">low.expression.threshold</code></td>
<td>
<p>numeric Threshold to remove expression values (default=0). Values under this threshold are discarded.</p>
</td></tr>
<tr><td><code id="appendSpecificityMetricsToDE_+3A_append.auc">append.auc</code></td>
<td>
<p>boolean If TRUE, append AUC values (default=FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame of differential expression values with metrics attached
</p>

<hr>
<h2 id='as_factor'>convert character vector into a factor with names &quot;values&quot; and &quot;levels&quot;</h2><span id='topic+as_factor'></span>

<h3>Description</h3>

<p>convert character vector into a factor with names &quot;values&quot; and &quot;levels&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_factor(vals)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_factor_+3A_vals">vals</code></td>
<td>
<p>vector of values to evaluate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>factor with names &quot;values&quot; and &quot;levels&quot;
</p>

<hr>
<h2 id='cellAnnotations'>Conos cell annotations</h2><span id='topic+cellAnnotations'></span>

<h3>Description</h3>

<p>Conos cell annotations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cellAnnotations
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 3000.
</p>

<hr>
<h2 id='checkPackageInstalled'>Check whether a package is installed and suggest how to install from CRAN, Bioconductor, or other external source</h2><span id='topic+checkPackageInstalled'></span>

<h3>Description</h3>

<p>Check whether a package is installed and suggest how to install from CRAN, Bioconductor, or other external source
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkPackageInstalled(
  pkgs,
  details = "to run this function",
  install.help = NULL,
  bioc = FALSE,
  cran = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkPackageInstalled_+3A_pkgs">pkgs</code></td>
<td>
<p>character Package name(s)</p>
</td></tr>
<tr><td><code id="checkPackageInstalled_+3A_details">details</code></td>
<td>
<p>character Helper text (default = &quot;to run this function&quot;)</p>
</td></tr>
<tr><td><code id="checkPackageInstalled_+3A_install.help">install.help</code></td>
<td>
<p>character Additional information on how to install package (default = NULL)</p>
</td></tr>
<tr><td><code id="checkPackageInstalled_+3A_bioc">bioc</code></td>
<td>
<p>logical Package(s) is/are available from Bioconductor (default = FALSE)</p>
</td></tr>
<tr><td><code id="checkPackageInstalled_+3A_cran">cran</code></td>
<td>
<p>logical Package(s) is/are available from CRAN (default = FALSE)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
checkPackageInstalled("sccore", cran = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='collapseCellsByType'>Collapse count matrices by cell type, given min/max number of cells</h2><span id='topic+collapseCellsByType'></span>

<h3>Description</h3>

<p>Collapse count matrices by cell type, given min/max number of cells
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapseCellsByType(cm, groups, min.cell.count = 10, max.cell.count = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapseCellsByType_+3A_cm">cm</code></td>
<td>
<p>count matrix</p>
</td></tr>
<tr><td><code id="collapseCellsByType_+3A_groups">groups</code></td>
<td>
<p>factor specifying cell types</p>
</td></tr>
<tr><td><code id="collapseCellsByType_+3A_min.cell.count">min.cell.count</code></td>
<td>
<p>numeric Minimum number of cells to include (default=10)</p>
</td></tr>
<tr><td><code id="collapseCellsByType_+3A_max.cell.count">max.cell.count</code></td>
<td>
<p>numeric Maximum number of cells to include (default=Inf). If Inf, there is no maximum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Subsetted factor of collapsed cells by type, with NA cells omitted
</p>

<hr>
<h2 id='collapseGraphPaga'>Collapse graph using PAGA 1.2 algorithm, Wolf et al 2019, Genome Biology (2019) &lt;https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1663-x&gt;</h2><span id='topic+collapseGraphPaga'></span>

<h3>Description</h3>

<p>Collapse graph using PAGA 1.2 algorithm, Wolf et al 2019, Genome Biology (2019) &lt;https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1663-x&gt;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapseGraphPaga(graph, groups, linearize = TRUE, winsorize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapseGraphPaga_+3A_graph">graph</code></td>
<td>
<p>igraph graph object Graph to be collapsed</p>
</td></tr>
<tr><td><code id="collapseGraphPaga_+3A_groups">groups</code></td>
<td>
<p>factor on vertices describing cluster assignment (can specify integer vertex ids, or character vertex names which will be matched)</p>
</td></tr>
<tr><td><code id="collapseGraphPaga_+3A_linearize">linearize</code></td>
<td>
<p>should normally be always TRUE (default=TRUE)</p>
</td></tr>
<tr><td><code id="collapseGraphPaga_+3A_winsorize">winsorize</code></td>
<td>
<p>winsorize final connectivity statistics value (default=FALSE) Note: Original PAGA has it as always TRUE,
but in this case there is no way to distinguish level of connectivity for highly connected groups.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>collapsed graph
</p>

<hr>
<h2 id='collapseGraphSum'>Collapse Graph By Sum</h2><span id='topic+collapseGraphSum'></span>

<h3>Description</h3>

<p>Collapse Graph By Sum
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapseGraphSum(graph, groups, normalize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapseGraphSum_+3A_graph">graph</code></td>
<td>
<p>igraph graph object Graph to be collapsed</p>
</td></tr>
<tr><td><code id="collapseGraphSum_+3A_groups">groups</code></td>
<td>
<p>factor on vertices describing cluster assignment (can specify integer vertex ids, or character vertex names which will be matched)</p>
</td></tr>
<tr><td><code id="collapseGraphSum_+3A_normalize">normalize</code></td>
<td>
<p>boolean Whether to recalculate edge weight as observed/expected (default=TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>collapsed graph
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
collapsed = collapseGraphPaga(conosGraph, igraph::V(conosGraph), linearize=TRUE, winsorize=FALSE)


</code></pre>

<hr>
<h2 id='colSumByFactor'>Calculates factor-stratified sums for each column</h2><span id='topic+colSumByFactor'></span>

<h3>Description</h3>

<p>Calculates factor-stratified sums for each column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colSumByFactor(sY, rowSel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colSumByFactor_+3A_sy">sY</code></td>
<td>
<p>sparse matrix (dgCmatrix)</p>
</td></tr>
<tr><td><code id="colSumByFactor_+3A_rowsel">rowSel</code></td>
<td>
<p>integer factor. Note that the 0-th column will return sums for any NA values; 0 or negative values will be omitted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix
</p>

<hr>
<h2 id='computeChebyshevCoeffs'>Compute Chebyshev Coefficients</h2><span id='topic+computeChebyshevCoeffs'></span>

<h3>Description</h3>

<p>Compute Chebyshev Coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeChebyshevCoeffs(filt, l.max, m = 30, n = m + 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeChebyshevCoeffs_+3A_filt">filt</code></td>
<td>
<p>graph filter function</p>
</td></tr>
<tr><td><code id="computeChebyshevCoeffs_+3A_l.max">l.max</code></td>
<td>
<p>Maximum eigenvalue of the graph</p>
</td></tr>
<tr><td><code id="computeChebyshevCoeffs_+3A_m">m</code></td>
<td>
<p>numeric Maximum order of Chebyshev coeff to compute (default=30)</p>
</td></tr>
<tr><td><code id="computeChebyshevCoeffs_+3A_n">n</code></td>
<td>
<p>numeric grid order used to compute quadrature (default=m+1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of Chebyshev coefficients
</p>


<h3>See Also</h3>

<p>Other graph smoothing: 
<code><a href="#topic+heatFilter">heatFilter</a>()</code>,
<code><a href="#topic+smoothChebyshev">smoothChebyshev</a>()</code>,
<code><a href="#topic+smoothSignalOnGraph">smoothSignalOnGraph</a>()</code>
</p>

<hr>
<h2 id='conosClusterList'>Conos clusters list</h2><span id='topic+conosClusterList'></span>

<h3>Description</h3>

<p>Conos clusters list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conosClusterList
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>

<hr>
<h2 id='conosGraph'>Conos graph</h2><span id='topic+conosGraph'></span>

<h3>Description</h3>

<p>Conos graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conosGraph
</code></pre>


<h3>Format</h3>

<p>An object of class <code>igraph</code> of length 100.
</p>

<hr>
<h2 id='dotPlot'>Dot plot adapted from Seurat:::DotPlot, see ?Seurat:::DotPlot for details</h2><span id='topic+dotPlot'></span>

<h3>Description</h3>

<p>Dot plot adapted from Seurat:::DotPlot, see ?Seurat:::DotPlot for details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dotPlot(
  markers,
  count.matrix,
  cell.groups,
  marker.colour = "black",
  cluster.colour = "black",
  xlab = "Marker",
  ylab = "Cluster",
  n.cores = 1,
  text.angle = 45,
  gene.order = NULL,
  cols = c("blue", "red"),
  col.min = -2.5,
  col.max = 2.5,
  dot.min = 0,
  dot.scale = 6,
  scale.by = "radius",
  scale.center = FALSE,
  scale.min = NA,
  scale.max = NA,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dotPlot_+3A_markers">markers</code></td>
<td>
<p>Vector of gene markers to plot</p>
</td></tr>
<tr><td><code id="dotPlot_+3A_count.matrix">count.matrix</code></td>
<td>
<p>Merged count matrix, cells in rows and genes in columns</p>
</td></tr>
<tr><td><code id="dotPlot_+3A_cell.groups">cell.groups</code></td>
<td>
<p>Named factor containing cell groups (clusters) and cell names as names</p>
</td></tr>
<tr><td><code id="dotPlot_+3A_marker.colour">marker.colour</code></td>
<td>
<p>Character or numeric vector (default=&quot;black&quot;)</p>
</td></tr>
<tr><td><code id="dotPlot_+3A_cluster.colour">cluster.colour</code></td>
<td>
<p>Character or numeric vector (default=&quot;black&quot;)</p>
</td></tr>
<tr><td><code id="dotPlot_+3A_xlab">xlab</code></td>
<td>
<p>string X-axis title (default=&quot;Marker&quot;)</p>
</td></tr>
<tr><td><code id="dotPlot_+3A_ylab">ylab</code></td>
<td>
<p>string Y-axis title (default=&quot;Cluster&quot;)</p>
</td></tr>
<tr><td><code id="dotPlot_+3A_n.cores">n.cores</code></td>
<td>
<p>integer Number of cores (default=1)</p>
</td></tr>
<tr><td><code id="dotPlot_+3A_text.angle">text.angle</code></td>
<td>
<p>numeric Angle of text displayed (default=45)</p>
</td></tr>
<tr><td><code id="dotPlot_+3A_gene.order">gene.order</code></td>
<td>
<p>Either factor of genes passed to dplyr::mutate(levels=gene.order), or a boolean. (default=NULL) If TRUE, gene.order is set to the unique markers. If FALSE, gene.order is set to NULL. If NULL, the argument is ignored.</p>
</td></tr>
<tr><td><code id="dotPlot_+3A_cols">cols</code></td>
<td>
<p>Colors to plot (default=c(&quot;blue&quot;, &quot;red&quot;)). The name of a palette from 'RColorBrewer::brewer.pal.info', a pair of colors defining a gradient, or 3+ colors defining multiple gradients (if 'split.by' is set).</p>
</td></tr>
<tr><td><code id="dotPlot_+3A_col.min">col.min</code></td>
<td>
<p>numeric Minimum scaled average expression threshold (default=-2.5). Everything smaller will be set to this.</p>
</td></tr>
<tr><td><code id="dotPlot_+3A_col.max">col.max</code></td>
<td>
<p>numeric Maximum scaled average expression threshold (default=2.5). Everything larger will be set to this.</p>
</td></tr>
<tr><td><code id="dotPlot_+3A_dot.min">dot.min</code></td>
<td>
<p>numeric The fraction of cells at which to draw the smallest dot (default=0). All cell groups with less than this expressing the given gene will have no dot drawn.</p>
</td></tr>
<tr><td><code id="dotPlot_+3A_dot.scale">dot.scale</code></td>
<td>
<p>numeric Scale the size of the points, similar to cex (default=6)</p>
</td></tr>
<tr><td><code id="dotPlot_+3A_scale.by">scale.by</code></td>
<td>
<p>string Scale the size of the points by 'size' or by 'radius' (default=&quot;radius&quot;)</p>
</td></tr>
<tr><td><code id="dotPlot_+3A_scale.center">scale.center</code></td>
<td>
<p>boolean Center scaling, see 'scale()' argument 'center' (default=FALSE)</p>
</td></tr>
<tr><td><code id="dotPlot_+3A_scale.min">scale.min</code></td>
<td>
<p>numeric Set lower limit for scaling, use NA for default (default=NA)</p>
</td></tr>
<tr><td><code id="dotPlot_+3A_scale.max">scale.max</code></td>
<td>
<p>numeric Set upper limit for scaling, use NA for default (default=NA)</p>
</td></tr>
<tr><td><code id="dotPlot_+3A_verbose">verbose</code></td>
<td>
<p>boolean Verbose output (default=TRUE)</p>
</td></tr>
<tr><td><code id="dotPlot_+3A_...">...</code></td>
<td>
<p>Additional inputs passed to sccore::plapply(), see man for description.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
## Create merged count matrix
## In this example, cms is a list of count matrices from, e.g., Cellranger count,
## where cells are in columns and genes in rows
## cm &lt;- sccore:::mergeCountMatrices(cms, transposed = FALSE) %&gt;% Matrix::t()

## If coming from Conos, this can be extracted like so
## cm &lt;- conos.obj$getJointCountMatrix(raw = FALSE) # Either normalized or raw values can be used

## Here, we create a random sparse matrix
cm &lt;- Matrix::rsparsematrix(30,3,0.5) %&gt;% abs(.) %&gt;%
            `dimnames&lt;-`(list(1:30,c("gene1","gene2","gene3")))

## Create marker vector
markers &lt;- c("gene1","gene2","gene3")

## Additionally, color vectors can be included.
## These should have the same length as the input (markers, cell groups)
## Otherwise, they are recycled
col.markers &lt;- c("black","black","red") # or c(1,1,2)
col.clusters &lt;- c("black","red","black") # or c(1,2,1)

## Create annotation vector
annotation &lt;- c(rep("cluster1",10),rep("cluster2",10),rep("cluster3",10)) %&gt;%
    factor() %&gt;% setNames(1:30)

## Plot. Here, the expression colours range from gray (low expression) to purple (high expression)
sccore:::dotPlot(markers = markers, count.matrix = cm, cell.groups = annotation,
    marker.colour = col.markers, cluster.colour = col.clusters, cols=c("gray","purple"))

</code></pre>

<hr>
<h2 id='embeddingColorsPlot'>Set colors for embedding plot. Used primarily in embeddingPlot().</h2><span id='topic+embeddingColorsPlot'></span>

<h3>Description</h3>

<p>Set colors for embedding plot. Used primarily in embeddingPlot().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>embeddingColorsPlot(
  plot.df,
  colors,
  groups = NULL,
  geom_point_w = ggplot2::geom_point,
  gradient.range.quantile = 1,
  color.range = "symmetric",
  legend.title = NULL,
  palette = NULL,
  plot.na = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="embeddingColorsPlot_+3A_plot.df">plot.df</code></td>
<td>
<p>data.frame for plotting. In embeddingPlot(), this is a tibble from tibble::rownames_to_column().</p>
</td></tr>
<tr><td><code id="embeddingColorsPlot_+3A_colors">colors</code></td>
<td>
<p>vector of numbers, which must be shown with point colors, names contain cell names (default=NULL). This argument is ignored if groups are provided.</p>
</td></tr>
<tr><td><code id="embeddingColorsPlot_+3A_groups">groups</code></td>
<td>
<p>vector of cluster labels, names contain cell names (default=NULL)</p>
</td></tr>
<tr><td><code id="embeddingColorsPlot_+3A_geom_point_w">geom_point_w</code></td>
<td>
<p>function to work with geom_point layer from ggplot2 (default=ggplot2::geom_point)</p>
</td></tr>
<tr><td><code id="embeddingColorsPlot_+3A_gradient.range.quantile">gradient.range.quantile</code></td>
<td>
<p>Winsorization quantile for the numeric colors and gene gradient (default=1)</p>
</td></tr>
<tr><td><code id="embeddingColorsPlot_+3A_color.range">color.range</code></td>
<td>
<p>controls range, in which colors are estimated (default=&quot;symmetric&quot;). Pass &quot;all&quot; to estimate range based on all values of &quot;colors&quot;, pass &quot;data&quot; to estimate it only based on colors, presented in the embedding. Alternatively you can pass vector of length 2 with (min, max) values.</p>
</td></tr>
<tr><td><code id="embeddingColorsPlot_+3A_legend.title">legend.title</code></td>
<td>
<p>legend title (default=NULL)</p>
</td></tr>
<tr><td><code id="embeddingColorsPlot_+3A_palette">palette</code></td>
<td>
<p>vector or list or function (default=NULL). Accepts number of colors and return list of colors (i.e. see 'colorRampPalette') (default=NULL)</p>
</td></tr>
<tr><td><code id="embeddingColorsPlot_+3A_plot.na">plot.na</code></td>
<td>
<p>boolean/numeric Whether to plot points, for which groups / colors are missed (default=is.null(subgroups), i.e. FALSE). If plot.na passed a numeric value below 0, the NA symbols are plotted below the cells. Otherwise if values &gt;=0, they’re plotted above the cells. Note that this argument is FALSE if 'subgroups' is NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object
</p>

<hr>
<h2 id='embeddingGroupPlot'>Plotting function for cluster labels, names contain cell names. Used primarily in embeddingPlot().</h2><span id='topic+embeddingGroupPlot'></span>

<h3>Description</h3>

<p>Plotting function for cluster labels, names contain cell names. Used primarily in embeddingPlot().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>embeddingGroupPlot(
  plot.df,
  groups,
  geom_point_w,
  min.cluster.size,
  mark.groups,
  font.size,
  legend.title,
  shuffle.colors,
  palette,
  plot.na,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="embeddingGroupPlot_+3A_plot.df">plot.df</code></td>
<td>
<p>data.frame for plotting. In embeddingPlot(), this is a tibble from tibble::rownames_to_column().</p>
</td></tr>
<tr><td><code id="embeddingGroupPlot_+3A_groups">groups</code></td>
<td>
<p>vector of cluster labels, names contain cell names (default=NULL)</p>
</td></tr>
<tr><td><code id="embeddingGroupPlot_+3A_geom_point_w">geom_point_w</code></td>
<td>
<p>function to work with geom_point layer from ggplot2 (default=ggplot2::geom_point)</p>
</td></tr>
<tr><td><code id="embeddingGroupPlot_+3A_min.cluster.size">min.cluster.size</code></td>
<td>
<p>labels for all groups with number of cells fewer than this parameter are considered as missed (default=0). This argument is ignored if groups aren't provided</p>
</td></tr>
<tr><td><code id="embeddingGroupPlot_+3A_mark.groups">mark.groups</code></td>
<td>
<p>plot cluster labels above points (default=TRUE)</p>
</td></tr>
<tr><td><code id="embeddingGroupPlot_+3A_font.size">font.size</code></td>
<td>
<p>font size for cluster labels (default=c(3, 7)). It can either be single number for constant font size or pair (min, max) for font size depending on cluster size</p>
</td></tr>
<tr><td><code id="embeddingGroupPlot_+3A_legend.title">legend.title</code></td>
<td>
<p>legend title (default=NULL)</p>
</td></tr>
<tr><td><code id="embeddingGroupPlot_+3A_shuffle.colors">shuffle.colors</code></td>
<td>
<p>shuffle colors (default=FALSE)</p>
</td></tr>
<tr><td><code id="embeddingGroupPlot_+3A_palette">palette</code></td>
<td>
<p>vector or list or function (default=NULL). Accepts number of colors and return list of colors (i.e. see 'colorRampPalette') (default=NULL)</p>
</td></tr>
<tr><td><code id="embeddingGroupPlot_+3A_plot.na">plot.na</code></td>
<td>
<p>boolean/numeric Whether to plot points, for which groups / colors are missed (default=is.null(subgroups), i.e. FALSE). If plot.na passed a numeric value below 0, the NA symbols are plotted below the cells. Otherwise if values &gt;=0, they’re plotted above the cells. Note that this argument is FALSE if 'subgroups' is NULL</p>
</td></tr>
<tr><td><code id="embeddingGroupPlot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to ggplot2::geom_label_repel()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object
</p>

<hr>
<h2 id='embeddingPlot'>Plot embedding with provided labels / colors using ggplot2</h2><span id='topic+embeddingPlot'></span>

<h3>Description</h3>

<p>Plot embedding with provided labels / colors using ggplot2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>embeddingPlot(
  embedding,
  groups = NULL,
  colors = NULL,
  subgroups = NULL,
  plot.na = is.null(subgroups),
  min.cluster.size = 0,
  mark.groups = TRUE,
  show.legend = FALSE,
  alpha = 0.4,
  size = 0.8,
  title = NULL,
  plot.theme = NULL,
  palette = NULL,
  color.range = "symmetric",
  font.size = c(3, 7),
  show.ticks = FALSE,
  show.labels = FALSE,
  legend.position = NULL,
  legend.title = NULL,
  gradient.range.quantile = 1,
  raster = FALSE,
  raster.dpi = 300,
  shuffle.colors = FALSE,
  keep.limits = !is.null(subgroups),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="embeddingPlot_+3A_embedding">embedding</code></td>
<td>
<p>two-column matrix with x and y coordinates of the embedding, rownames contain cell names and are used to match coordinates with groups or colors</p>
</td></tr>
<tr><td><code id="embeddingPlot_+3A_groups">groups</code></td>
<td>
<p>vector of cluster labels, names contain cell names (default=NULL)</p>
</td></tr>
<tr><td><code id="embeddingPlot_+3A_colors">colors</code></td>
<td>
<p>vector of numbers, which must be shown with point colors, names contain cell names (default=NULL). This argument is ignored if groups are provided.</p>
</td></tr>
<tr><td><code id="embeddingPlot_+3A_subgroups">subgroups</code></td>
<td>
<p>subset of 'groups', selecting the cells for plot (default=NULL). Ignored if 'groups' is NULL</p>
</td></tr>
<tr><td><code id="embeddingPlot_+3A_plot.na">plot.na</code></td>
<td>
<p>boolean/numeric Whether to plot points, for which groups / colors are missed (default=is.null(subgroups), i.e. FALSE). If plot.na passed a numeric value below 0, the NA symbols are plotted below the cells. Otherwise if values &gt;=0, they’re plotted above the cells. Note that this argument is FALSE if 'subgroups' is NULL</p>
</td></tr>
<tr><td><code id="embeddingPlot_+3A_min.cluster.size">min.cluster.size</code></td>
<td>
<p>labels for all groups with number of cells fewer than this parameter are considered as missed (default=0). This argument is ignored if groups aren't provided</p>
</td></tr>
<tr><td><code id="embeddingPlot_+3A_mark.groups">mark.groups</code></td>
<td>
<p>plot cluster labels above points (default=TRUE)</p>
</td></tr>
<tr><td><code id="embeddingPlot_+3A_show.legend">show.legend</code></td>
<td>
<p>show legend (default=FALSE)</p>
</td></tr>
<tr><td><code id="embeddingPlot_+3A_alpha">alpha</code></td>
<td>
<p>opacity level [0, 1] (default=0.4)</p>
</td></tr>
<tr><td><code id="embeddingPlot_+3A_size">size</code></td>
<td>
<p>point size (default=0.8)</p>
</td></tr>
<tr><td><code id="embeddingPlot_+3A_title">title</code></td>
<td>
<p>plot title (default=NULL)</p>
</td></tr>
<tr><td><code id="embeddingPlot_+3A_plot.theme">plot.theme</code></td>
<td>
<p>theme for the plot (default=NULL)</p>
</td></tr>
<tr><td><code id="embeddingPlot_+3A_palette">palette</code></td>
<td>
<p>vector or list or function (default=NULL). Accepts number of colors and return list of colors (i.e. see 'colorRampPalette') (default=NULL)</p>
</td></tr>
<tr><td><code id="embeddingPlot_+3A_color.range">color.range</code></td>
<td>
<p>controls range, in which colors are estimated (default=&quot;symmetric&quot;). Pass &quot;all&quot; to estimate range based on all values of &quot;colors&quot;, pass &quot;data&quot; to estimate it only based on colors, presented in the embedding. Alternatively you can pass vector of length 2 with (min, max) values.</p>
</td></tr>
<tr><td><code id="embeddingPlot_+3A_font.size">font.size</code></td>
<td>
<p>font size for cluster labels (default=c(3, 7)). It can either be single number for constant font size or pair (min, max) for font size depending on cluster size</p>
</td></tr>
<tr><td><code id="embeddingPlot_+3A_show.ticks">show.ticks</code></td>
<td>
<p>show ticks and tick labels (default=FALSE)</p>
</td></tr>
<tr><td><code id="embeddingPlot_+3A_show.labels">show.labels</code></td>
<td>
<p>show labels (default=FALSE)</p>
</td></tr>
<tr><td><code id="embeddingPlot_+3A_legend.position">legend.position</code></td>
<td>
<p>vector with (x, y) positions of the legend (default=NULL)</p>
</td></tr>
<tr><td><code id="embeddingPlot_+3A_legend.title">legend.title</code></td>
<td>
<p>legend title (default=NULL)</p>
</td></tr>
<tr><td><code id="embeddingPlot_+3A_gradient.range.quantile">gradient.range.quantile</code></td>
<td>
<p>Winsorization quantile for the numeric colors and gene gradient (default=1)</p>
</td></tr>
<tr><td><code id="embeddingPlot_+3A_raster">raster</code></td>
<td>
<p>boolean whether layer with the points be rasterized (default=FALSE). Setting of this argument to TRUE is useful when you need to export a plot with large number of points</p>
</td></tr>
<tr><td><code id="embeddingPlot_+3A_raster.dpi">raster.dpi</code></td>
<td>
<p>dpi of the rasterized plot. (default=300). Ignored if raster == FALSE.</p>
</td></tr>
<tr><td><code id="embeddingPlot_+3A_shuffle.colors">shuffle.colors</code></td>
<td>
<p>shuffle colors (default=FALSE)</p>
</td></tr>
<tr><td><code id="embeddingPlot_+3A_keep.limits">keep.limits</code></td>
<td>
<p>Keep axis limits from original plot (default=!is.null(subgroups)). Useful when plotting subgroups, only meaningful it plot.na=FALSE</p>
</td></tr>
<tr><td><code id="embeddingPlot_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggrepel.html#topic+geom_text_repel">ggrepel::geom_label_repel</a></code>
</p>

<dl>
<dt><code>mapping</code></dt><dd><p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes</a></code> or
<code><a href="ggplot2.html#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), is combined with the default mapping at the top level of the
plot. You only need to supply <code>mapping</code> if there isn't a mapping
defined for the plot.</p>
</dd>
<dt><code>data</code></dt><dd><p>A data frame. If specified, overrides the default data frame
defined at the top level of the plot.</p>
</dd>
<dt><code>stat</code></dt><dd><p>The statistical transformation to use on the data for this
layer, as a string.</p>
</dd>
<dt><code>position</code></dt><dd><p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</dd>
<dt><code>parse</code></dt><dd><p>If TRUE, the labels will be parsed into expressions and
displayed as described in ?plotmath</p>
</dd>
<dt><code>box.padding</code></dt><dd><p>Amount of padding around bounding box, as unit or number.
Defaults to 0.25. (Default unit is lines, but other units can be specified
by passing <code>unit(x, "units")</code>).</p>
</dd>
<dt><code>label.padding</code></dt><dd><p>Amount of padding around label, as unit or number.
Defaults to 0.25. (Default unit is lines, but other units can be specified
by passing <code>unit(x, "units")</code>).</p>
</dd>
<dt><code>point.padding</code></dt><dd><p>Amount of padding around labeled point, as unit or
number. Defaults to 0. (Default unit is lines, but other units can be
specified by passing <code>unit(x, "units")</code>).</p>
</dd>
<dt><code>label.r</code></dt><dd><p>Radius of rounded corners, as unit or number. Defaults
to 0.15. (Default unit is lines, but other units can be specified by
passing <code>unit(x, "units")</code>).</p>
</dd>
<dt><code>label.size</code></dt><dd><p>Size of label border, in mm.</p>
</dd>
<dt><code>min.segment.length</code></dt><dd><p>Skip drawing segments shorter than this, as unit or
number. Defaults to 0.5. (Default unit is lines, but other units can be
specified by passing <code>unit(x, "units")</code>).</p>
</dd>
<dt><code>arrow</code></dt><dd><p>specification for arrow heads, as created by <code><a href="grid.html#topic+arrow">arrow</a></code></p>
</dd>
<dt><code>force</code></dt><dd><p>Force of repulsion between overlapping text labels. Defaults
to 1.</p>
</dd>
<dt><code>force_pull</code></dt><dd><p>Force of attraction between a text label and its
corresponding data point. Defaults to 1.</p>
</dd>
<dt><code>max.time</code></dt><dd><p>Maximum number of seconds to try to resolve overlaps.
Defaults to 0.5.</p>
</dd>
<dt><code>max.iter</code></dt><dd><p>Maximum number of iterations to try to resolve overlaps.
Defaults to 10000.</p>
</dd>
<dt><code>max.overlaps</code></dt><dd><p>Exclude text labels that overlap too many things.
Defaults to 10.</p>
</dd>
<dt><code>nudge_x,nudge_y</code></dt><dd><p>Horizontal and vertical adjustments to nudge the
starting position of each text label. The units for <code>nudge_x</code> and
<code>nudge_y</code> are the same as for the data units on the x-axis and y-axis.</p>
</dd>
<dt><code>xlim,ylim</code></dt><dd><p>Limits for the x and y axes. Text labels will be constrained
to these limits. By default, text labels are constrained to the entire plot
area.</p>
</dd>
<dt><code>na.rm</code></dt><dd><p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</dd>
<dt><code>direction</code></dt><dd><p>&quot;both&quot;, &quot;x&quot;, or &quot;y&quot; &ndash; direction in which to adjust position of labels</p>
</dd>
<dt><code>seed</code></dt><dd><p>Random seed passed to <code><a href="base.html#topic+set.seed">set.seed</a></code>. Defaults to
<code>NA</code>, which means that <code>set.seed</code> will not be called.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>If <code>TRUE</code>, some diagnostics of the repel algorithm are printed</p>
</dd>
<dt><code>inherit.aes</code></dt><dd><p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sccore)
embeddingPlot(umapEmbedding, show.ticks=TRUE, show.labels=TRUE, title="UMAP embedding")

</code></pre>

<hr>
<h2 id='embedGraphUmap'>Embed a graph into a UMAP, Uniform Manifold Approximation and Projection for Dimension Reduction, &lt;https://github.com/lmcinnes/umap&gt;, &lt;doi:10.21105/joss.00861&gt;</h2><span id='topic+embedGraphUmap'></span>

<h3>Description</h3>

<p>Embed a graph into a UMAP, Uniform Manifold Approximation and Projection for Dimension Reduction, &lt;https://github.com/lmcinnes/umap&gt;, &lt;doi:10.21105/joss.00861&gt;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>embedGraphUmap(
  graph,
  min.prob = 0.001,
  min.visited.verts = 1000,
  n.cores = 1,
  max.hitting.nn.num = 0,
  max.commute.nn.num = 0,
  min.prob.lower = 1e-07,
  n.neighbors = 40,
  n.epochs = 1000,
  spread = 15,
  min.dist = 0.001,
  return.all = FALSE,
  n.sgd.cores = n.cores,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="embedGraphUmap_+3A_graph">graph</code></td>
<td>
<p>input igraph object</p>
</td></tr>
<tr><td><code id="embedGraphUmap_+3A_min.prob">min.prob</code></td>
<td>
<p>numeric Minimum probability for proximity when calculating hitting time per neighbors (default=1e-3)</p>
</td></tr>
<tr><td><code id="embedGraphUmap_+3A_min.visited.verts">min.visited.verts</code></td>
<td>
<p>numeric Minimum number of vertices visted when calculating hitting time per neighbors (default=1000)</p>
</td></tr>
<tr><td><code id="embedGraphUmap_+3A_n.cores">n.cores</code></td>
<td>
<p>numeric Number of cores to use (default=1)</p>
</td></tr>
<tr><td><code id="embedGraphUmap_+3A_max.hitting.nn.num">max.hitting.nn.num</code></td>
<td>
<p>numeric Maximum adjacencies for calculating hitting time per neighbor, hitting_time_per_neighbors() (default=0)</p>
</td></tr>
<tr><td><code id="embedGraphUmap_+3A_max.commute.nn.num">max.commute.nn.num</code></td>
<td>
<p>numeric Maximum adjacencies for calculating commute time per neighbor, commute_time_per_node() (default=0)</p>
</td></tr>
<tr><td><code id="embedGraphUmap_+3A_min.prob.lower">min.prob.lower</code></td>
<td>
<p>numeric Probability threshold to continue iteration in depth first search hitting time, dfs_hitting_time() (default=1e-7)</p>
</td></tr>
<tr><td><code id="embedGraphUmap_+3A_n.neighbors">n.neighbors</code></td>
<td>
<p>numeric Number of neighbors (default=40)</p>
</td></tr>
<tr><td><code id="embedGraphUmap_+3A_n.epochs">n.epochs</code></td>
<td>
<p>numeric Number of epochs to use during the optimization of the embedded coordinates (default=1000). See 'n_epochs' in uwot::umap()</p>
</td></tr>
<tr><td><code id="embedGraphUmap_+3A_spread">spread</code></td>
<td>
<p>numeric The effective scale of embedded points (numeric default=15). See 'spread' in uwot::umap()</p>
</td></tr>
<tr><td><code id="embedGraphUmap_+3A_min.dist">min.dist</code></td>
<td>
<p>numeric The effective minimum distance between embedded points (default=0.001). See 'min.dist' in uwot::umap()</p>
</td></tr>
<tr><td><code id="embedGraphUmap_+3A_return.all">return.all</code></td>
<td>
<p>boolean If TRUE, return list(adj.info=adj.info, commute.times=commute.times, umap=umap). Otherwise, just return UMAP(default=FALSE)</p>
</td></tr>
<tr><td><code id="embedGraphUmap_+3A_n.sgd.cores">n.sgd.cores</code></td>
<td>
<p>numeric Number of cores to use during stochastic gradient descent. If set to &gt; 1, then results will not be reproducible, even if 'set.seed' is called with a fixed seed before running (default=n_threads) See 'n_sgd_threads' in uwot::umap()</p>
</td></tr>
<tr><td><code id="embedGraphUmap_+3A_verbose">verbose</code></td>
<td>
<p>boolean Verbose output (default=TRUE)</p>
</td></tr>
<tr><td><code id="embedGraphUmap_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to embedKnnGraph()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>resulting UMAP embedding
</p>

<hr>
<h2 id='embedKnnGraph'>Embed a k-nearest neighbor (kNN) graph within a UMAP. Used within embedGraphUmap(). Please see McInnes et al &lt;doi:10.21105/joss.00861&gt; for the UMAP description and implementation.</h2><span id='topic+embedKnnGraph'></span>

<h3>Description</h3>

<p>Embed a k-nearest neighbor (kNN) graph within a UMAP. Used within embedGraphUmap(). Please see McInnes et al &lt;doi:10.21105/joss.00861&gt; for the UMAP description and implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>embedKnnGraph(
  commute.times,
  n.neighbors,
  names = NULL,
  n.cores = 1,
  n.epochs = 1000,
  spread = 15,
  min.dist = 0.001,
  n.sgd.cores = n.cores,
  target.dims = 2,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="embedKnnGraph_+3A_commute.times">commute.times</code></td>
<td>
<p>graph commute times from get_nearest_neighbors(). The definition of commute_time(u, v) is the expected time starting at u = to reach v and then return to u .</p>
</td></tr>
<tr><td><code id="embedKnnGraph_+3A_n.neighbors">n.neighbors</code></td>
<td>
<p>numeric Number of neighbors</p>
</td></tr>
<tr><td><code id="embedKnnGraph_+3A_names">names</code></td>
<td>
<p>vector of names for UMAP rownames (default=NULL)</p>
</td></tr>
<tr><td><code id="embedKnnGraph_+3A_n.cores">n.cores</code></td>
<td>
<p>numeric Number of cores to use (except during stochastic gradient descent) (default=1). See 'n_threads' in uwot::umap()</p>
</td></tr>
<tr><td><code id="embedKnnGraph_+3A_n.epochs">n.epochs</code></td>
<td>
<p>numeric Number of epochs to use during the optimization of the embedded coordinates (default=1000). See 'n_epochs' in uwot::umap()</p>
</td></tr>
<tr><td><code id="embedKnnGraph_+3A_spread">spread</code></td>
<td>
<p>numeric The effective scale of embedded points (numeric default=15). See 'spread' in uwot::umap()</p>
</td></tr>
<tr><td><code id="embedKnnGraph_+3A_min.dist">min.dist</code></td>
<td>
<p>numeric The effective minimum distance between embedded points (default=0.001). See 'min.dist' in uwot::umap()</p>
</td></tr>
<tr><td><code id="embedKnnGraph_+3A_n.sgd.cores">n.sgd.cores</code></td>
<td>
<p>numeric Number of cores to use during stochastic gradient descent. If set to &gt; 1, then results will not be reproducible, even if 'set.seed' is called with a fixed seed before running (default=n.cores) See 'n_sgd_threads' in uwot::umap()</p>
</td></tr>
<tr><td><code id="embedKnnGraph_+3A_target.dims">target.dims</code></td>
<td>
<p>numeric Dimensions for 'n_components' in uwot::umap(n_components=target.dims) (default=2)</p>
</td></tr>
<tr><td><code id="embedKnnGraph_+3A_verbose">verbose</code></td>
<td>
<p>boolean Verbose output (default=TRUE)</p>
</td></tr>
<tr><td><code id="embedKnnGraph_+3A_...">...</code></td>
<td>
<p>arguments passed to uwot::umap()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>resulting kNN graph embedding within a UMAP
</p>

<hr>
<h2 id='extendMatrix'>Extend matrix to include new columns in matrix</h2><span id='topic+extendMatrix'></span>

<h3>Description</h3>

<p>Extend matrix to include new columns in matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extendMatrix(mtx, col.names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extendMatrix_+3A_mtx">mtx</code></td>
<td>
<p>Matrix</p>
</td></tr>
<tr><td><code id="extendMatrix_+3A_col.names">col.names</code></td>
<td>
<p>Columns that should be included in matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with new columns but rows retained
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
gene.union &lt;- lapply(conosClusterList, colnames) %&gt;% Reduce(union, .)
extendMatrix(conosClusterList[[1]], col.names=gene.union)

</code></pre>

<hr>
<h2 id='fac2col'>Utility function to translate a factor into colors</h2><span id='topic+fac2col'></span>

<h3>Description</h3>

<p>Utility function to translate a factor into colors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fac2col(
  x,
  s = 1,
  v = 1,
  shuffle = FALSE,
  min.group.size = 1,
  return.details = FALSE,
  unclassified.cell.color = "gray50",
  level.colors = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fac2col_+3A_x">x</code></td>
<td>
<p>input factor</p>
</td></tr>
<tr><td><code id="fac2col_+3A_s">s</code></td>
<td>
<p>numeric The &quot;saturation&quot; to be used to complete the HSV color descriptions (default=1) See ?rainbow in Palettes, grDevices</p>
</td></tr>
<tr><td><code id="fac2col_+3A_v">v</code></td>
<td>
<p>numeric The &quot;value&quot; to be used to complete the HSV color descriptions (default=1) See ?rainbow in Palettes, grDevices</p>
</td></tr>
<tr><td><code id="fac2col_+3A_shuffle">shuffle</code></td>
<td>
<p>boolean If TRUE, shuffles columns with shuffle(columns) (default=FALSE)</p>
</td></tr>
<tr><td><code id="fac2col_+3A_min.group.size">min.group.size</code></td>
<td>
<p>integer Exclude groups of size less than the min.group.size (default=1)</p>
</td></tr>
<tr><td><code id="fac2col_+3A_return.details">return.details</code></td>
<td>
<p>boolean If TRUE, returns a list list(colors=y, palette=col). Otherwise, just returns the factor (default=FALSE)</p>
</td></tr>
<tr><td><code id="fac2col_+3A_unclassified.cell.color">unclassified.cell.color</code></td>
<td>
<p>Color for unclassified cells (default='gray50')</p>
</td></tr>
<tr><td><code id="fac2col_+3A_level.colors">level.colors</code></td>
<td>
<p>(default=NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector or list of colors
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genes = factor(c("BRAF", "NPC1", "PAX3", "BRCA2", "FMR1"))
fac2col(genes)

</code></pre>

<hr>
<h2 id='fac2palette'>Encodes logic of how to handle named-vector and functional palettes. Used primarily within embeddingGroupPlot()</h2><span id='topic+fac2palette'></span>

<h3>Description</h3>

<p>Encodes logic of how to handle named-vector and functional palettes. Used primarily within embeddingGroupPlot()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fac2palette(groups, palette, unclassified.cell.color = "gray50")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fac2palette_+3A_groups">groups</code></td>
<td>
<p>vector of cluster labels, names contain cell names</p>
</td></tr>
<tr><td><code id="fac2palette_+3A_palette">palette</code></td>
<td>
<p>vector or list or function (default=NULL). Accepts number of colors and return list of colors (i.e. see 'colorRampPalette')</p>
</td></tr>
<tr><td><code id="fac2palette_+3A_unclassified.cell.color">unclassified.cell.color</code></td>
<td>
<p>Color for unclassified cells (default='gray50')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector or palette
</p>

<hr>
<h2 id='get_nearest_neighbors'>Get nearest neighbors method on graph</h2><span id='topic+get_nearest_neighbors'></span>

<h3>Description</h3>

<p>Get nearest neighbors method on graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_nearest_neighbors(
  adjacency_list,
  transition_probabilities,
  n_verts = 0L,
  n_cores = 1L,
  min_prob = 0.001,
  min_visited_verts = 1000L,
  min_prob_lower = 1e-05,
  max_hitting_nn_num = 0L,
  max_commute_nn_num = 0L,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_nearest_neighbors_+3A_adjacency_list">adjacency_list</code></td>
<td>
<p>igraph adjacency list</p>
</td></tr>
<tr><td><code id="get_nearest_neighbors_+3A_transition_probabilities">transition_probabilities</code></td>
<td>
<p>vector of transition probabilites</p>
</td></tr>
<tr><td><code id="get_nearest_neighbors_+3A_n_verts">n_verts</code></td>
<td>
<p>numeric Number of vertices (default=0)</p>
</td></tr>
<tr><td><code id="get_nearest_neighbors_+3A_n_cores">n_cores</code></td>
<td>
<p>numeric Number of cores to use (default=1)</p>
</td></tr>
<tr><td><code id="get_nearest_neighbors_+3A_min_prob">min_prob</code></td>
<td>
<p>numeric Minimum probability for proximity when calculating hitting time per neighbors (default=1e-3)</p>
</td></tr>
<tr><td><code id="get_nearest_neighbors_+3A_min_visited_verts">min_visited_verts</code></td>
<td>
<p>numeric Minimum number of vertices visted when calculating hitting time per neighbors (default=1000)</p>
</td></tr>
<tr><td><code id="get_nearest_neighbors_+3A_min_prob_lower">min_prob_lower</code></td>
<td>
<p>numeric Probability threshold to continue iteration in depth first search hitting time, dfs_hitting_time() (default=1e-5)</p>
</td></tr>
<tr><td><code id="get_nearest_neighbors_+3A_max_hitting_nn_num">max_hitting_nn_num</code></td>
<td>
<p>numeric Maximum adjacencies for calculating hitting time per neighbor, hitting_time_per_neighbors() (default=0)</p>
</td></tr>
<tr><td><code id="get_nearest_neighbors_+3A_max_commute_nn_num">max_commute_nn_num</code></td>
<td>
<p>numeric Maximum adjacencies for calculating commute time per neighbor, commute_time_per_node() (default=0)</p>
</td></tr>
<tr><td><code id="get_nearest_neighbors_+3A_verbose">verbose</code></td>
<td>
<p>boolean Whether to have verbose output (default=TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of commute times based on adjacencies
</p>

<hr>
<h2 id='getClusterGraph'>Collapse vertices belonging to each cluster in a graph</h2><span id='topic+getClusterGraph'></span>

<h3>Description</h3>

<p>Collapse vertices belonging to each cluster in a graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getClusterGraph(
  graph,
  groups,
  method = "sum",
  plot = FALSE,
  node.scale = 50,
  edge.scale = 50,
  edge.alpha = 0.3,
  seed = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getClusterGraph_+3A_graph">graph</code></td>
<td>
<p>igraph graph object Graph to be collapsed</p>
</td></tr>
<tr><td><code id="getClusterGraph_+3A_groups">groups</code></td>
<td>
<p>factor on vertices describing cluster assignment (can specify integer vertex ids, or character vertex names which will be matched)</p>
</td></tr>
<tr><td><code id="getClusterGraph_+3A_method">method</code></td>
<td>
<p>string Method to be used, either &quot;sum&quot; or &quot;paga&quot; (default=&quot;sum&quot;)</p>
</td></tr>
<tr><td><code id="getClusterGraph_+3A_plot">plot</code></td>
<td>
<p>boolean Whether to show collapsed graph plot (default=FALSE)</p>
</td></tr>
<tr><td><code id="getClusterGraph_+3A_node.scale">node.scale</code></td>
<td>
<p>numeric Scaling to control value of 'vertex.size' in plot.igraph() (default=50)</p>
</td></tr>
<tr><td><code id="getClusterGraph_+3A_edge.scale">edge.scale</code></td>
<td>
<p>numeric Scaling to control value of 'edge.width' in plot.igraph() (default=50)</p>
</td></tr>
<tr><td><code id="getClusterGraph_+3A_edge.alpha">edge.alpha</code></td>
<td>
<p>numeric Scaling to control value of 'alpha.f' in adjustcolor() within plot.igraph() (default=0.3)</p>
</td></tr>
<tr><td><code id="getClusterGraph_+3A_seed">seed</code></td>
<td>
<p>numeric Set seed via set.seed() for plotting (default=1)</p>
</td></tr>
<tr><td><code id="getClusterGraph_+3A_...">...</code></td>
<td>
<p>arguments passed to collapseGraphSum()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>collapsed graph
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cluster.graph = getClusterGraph(conosGraph, igraph::V(conosGraph))


</code></pre>

<hr>
<h2 id='graphToAdjList'>Convert igraph graph into an adjacency list</h2><span id='topic+graphToAdjList'></span>

<h3>Description</h3>

<p>Convert igraph graph into an adjacency list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphToAdjList(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graphToAdjList_+3A_graph">graph</code></td>
<td>
<p>input igraph object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>adjacency list, defined by list(idx=adj.list, probabilities=probs, names=edge.list.fact$levels
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
edge.list.fact &lt;- igraph::as_edgelist(conosGraph) %&gt;% as_factor()
edge.list &lt;- matrix(edge.list.fact$values, ncol=2)
n.nodes &lt;- length(igraph::V(conosGraph))
splitVectorByNodes(edge.list[,1], edge.list[,2], n.nodes)

</code></pre>

<hr>
<h2 id='heatFilter'>Graph filter with the heat kernel: <code class="reqn">f(x) = exp(-\beta |x / \lambda_m - a|^b)</code></h2><span id='topic+heatFilter'></span>

<h3>Description</h3>

<p>Graph filter with the heat kernel: <code class="reqn">f(x) = exp(-\beta |x / \lambda_m - a|^b)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heatFilter(x, l.max, order = 1, offset = 0, beta = 30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heatFilter_+3A_x">x</code></td>
<td>
<p>numeric Values to be filtered. Normally, these are graph laplacian engenvalues.</p>
</td></tr>
<tr><td><code id="heatFilter_+3A_l.max">l.max</code></td>
<td>
<p>numeric Maximum eigenvalue on the graph (<code class="reqn">\lambda_m</code> in the equation)</p>
</td></tr>
<tr><td><code id="heatFilter_+3A_order">order</code></td>
<td>
<p>numeric Parameter <code class="reqn">b</code> in the equation. Larger values correspond to the sharper kernel form (default=1). The values should be positive.</p>
</td></tr>
<tr><td><code id="heatFilter_+3A_offset">offset</code></td>
<td>
<p>numeric Mean kernel value (<code class="reqn">a</code> in the equation), must be in [0:1] (default=0)</p>
</td></tr>
<tr><td><code id="heatFilter_+3A_beta">beta</code></td>
<td>
<p>numeric Parameter <code class="reqn">\beta</code> in the equation. Larger values provide stronger smoothing. <code class="reqn">\beta=0</code> corresponds to no smoothing (default=30).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>smoothed values for 'x'
</p>


<h3>See Also</h3>

<p>Other graph smoothing: 
<code><a href="#topic+computeChebyshevCoeffs">computeChebyshevCoeffs</a>()</code>,
<code><a href="#topic+smoothChebyshev">smoothChebyshev</a>()</code>,
<code><a href="#topic+smoothSignalOnGraph">smoothSignalOnGraph</a>()</code>
</p>

<hr>
<h2 id='jsDist'>Jensen–Shannon distance metric (i.e. the square root of the Jensen–Shannon divergence) between the columns of a dense matrix m</h2><span id='topic+jsDist'></span>

<h3>Description</h3>

<p>Jensen–Shannon distance metric (i.e. the square root of the Jensen–Shannon divergence) between the columns of a dense matrix m
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jsDist(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jsDist_+3A_m">m</code></td>
<td>
<p>Input matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vectorized version of the lower triangle as an R distance object, stats::dist()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ex = matrix(1:9, nrow = 3, ncol = 3)
jsDist(ex)

</code></pre>

<hr>
<h2 id='mergeCountMatrices'>Merge list of count matrices into a common matrix, entering 0s for the missing entries</h2><span id='topic+mergeCountMatrices'></span>

<h3>Description</h3>

<p>Merge list of count matrices into a common matrix, entering 0s for the missing entries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeCountMatrices(cms, transposed = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeCountMatrices_+3A_cms">cms</code></td>
<td>
<p>List of count matrices</p>
</td></tr>
<tr><td><code id="mergeCountMatrices_+3A_transposed">transposed</code></td>
<td>
<p>boolean Indicate whether 'cms' is transposed, e.g. cells in rows and genes in columns (default=FALSE)</p>
</td></tr>
<tr><td><code id="mergeCountMatrices_+3A_...">...</code></td>
<td>
<p>Parameters for 'plapply' function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A merged extended matrix, with 0s for missing entries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mergeCountMatrices(conosClusterList, n.cores=1)
## 12 x 67388 sparse Matrix of class "dgCMatrix"

</code></pre>

<hr>
<h2 id='multi2dend'>Translate multilevel segmentation into a dendrogram, with the lowest level of the dendrogram listing the cells</h2><span id='topic+multi2dend'></span>

<h3>Description</h3>

<p>Translate multilevel segmentation into a dendrogram, with the lowest level of the dendrogram listing the cells
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi2dend(cl, counts, deep = FALSE, dist = "cor")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multi2dend_+3A_cl">cl</code></td>
<td>
<p>igraph communities object, returned from igraph community detection functions</p>
</td></tr>
<tr><td><code id="multi2dend_+3A_counts">counts</code></td>
<td>
<p>dgCmatrix of counts</p>
</td></tr>
<tr><td><code id="multi2dend_+3A_deep">deep</code></td>
<td>
<p>boolean If TRUE, take (cl$memberships[1,]). Otherwise, uses as.integer(membership(cl)) (default=FALSE)</p>
</td></tr>
<tr><td><code id="multi2dend_+3A_dist">dist</code></td>
<td>
<p>Distance metric used (default='cor'). Eiether 'cor' for the correlation distance in log10 space, or 'JS' for the Jensen–Shannon distance metric (i.e. the square root of the Jensen–Shannon divergence)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>resulting dendrogram
</p>

<hr>
<h2 id='plapply'>Parallel, optionally verbose lapply. See ?parallel::mclapply for more info.</h2><span id='topic+plapply'></span>

<h3>Description</h3>

<p>Parallel, optionally verbose lapply. See ?parallel::mclapply for more info.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plapply(
  ...,
  progress = FALSE,
  n.cores = parallel::detectCores(),
  mc.preschedule = FALSE,
  mc.allow.recursive = TRUE,
  fail.on.error = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plapply_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to mclapply(), lapply(), or pbmcapply::pbmclapply()</p>
</td></tr>
<tr><td><code id="plapply_+3A_progress">progress</code></td>
<td>
<p>Show progress bar via pbmcapply::pbmclapply() (default=FALSE).</p>
</td></tr>
<tr><td><code id="plapply_+3A_n.cores">n.cores</code></td>
<td>
<p>Number of cores to use (default=parallel::detectCores()). When n.cores=1, regular lapply() is used. Note: doesn't work when progress=TRUE</p>
</td></tr>
<tr><td><code id="plapply_+3A_mc.preschedule">mc.preschedule</code></td>
<td>
<p>if set to <code>TRUE</code> then the computation is
first divided to (at most) as many jobs are there are cores and then
the jobs are started, each job possibly covering more than one
value.  If set to <code>FALSE</code> then one job is forked for each value
of <code>X</code>.  The former is better for short computations or large
number of values in <code>X</code>, the latter is better for jobs that
have high variance of completion time and not too many values of
<code>X</code> compared to <code>mc.cores</code>.</p>
</td></tr>
<tr><td><code id="plapply_+3A_mc.allow.recursive">mc.allow.recursive</code></td>
<td>
<p>boolean Unless true, calling mclapply in a child process will use the child and not fork again (default=TRUE)</p>
</td></tr>
<tr><td><code id="plapply_+3A_fail.on.error">fail.on.error</code></td>
<td>
<p>boolean Whether to fail and report and error (using stop()) as long as any of the individual tasks has failed (default =FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list, as returned by lapply
</p>


<h3>Examples</h3>

<pre><code class='language-R'>square = function(x){ x**2 }
plapply(1:10, square, n.cores=1, progress=TRUE)

</code></pre>

<hr>
<h2 id='propagate_labels'>Label propagation</h2><span id='topic+propagate_labels'></span>

<h3>Description</h3>

<p>Label propagation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>propagate_labels(
  edge_verts,
  edge_weights,
  vert_labels,
  max_n_iters = 10L,
  verbose = TRUE,
  diffusion_fading = 10,
  diffusion_fading_const = 0.5,
  tol = 0.005,
  fixed_initial_labels = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="propagate_labels_+3A_edge_verts">edge_verts</code></td>
<td>
<p>edge vertices of igraph graph object</p>
</td></tr>
<tr><td><code id="propagate_labels_+3A_edge_weights">edge_weights</code></td>
<td>
<p>edge weights of igraph graph object</p>
</td></tr>
<tr><td><code id="propagate_labels_+3A_vert_labels">vert_labels</code></td>
<td>
<p>vector of factor or character labels, named by cell names</p>
</td></tr>
<tr><td><code id="propagate_labels_+3A_max_n_iters">max_n_iters</code></td>
<td>
<p>integer Maximal number of iterations (default=10)</p>
</td></tr>
<tr><td><code id="propagate_labels_+3A_verbose">verbose</code></td>
<td>
<p>boolean Verbose mode (default=TRUE)</p>
</td></tr>
<tr><td><code id="propagate_labels_+3A_diffusion_fading">diffusion_fading</code></td>
<td>
<p>numeric Constant used for diffusion on the graph, exp(-diffusion.fading * (edge_length + diffusion.fading.const)) (default=10.0)</p>
</td></tr>
<tr><td><code id="propagate_labels_+3A_diffusion_fading_const">diffusion_fading_const</code></td>
<td>
<p>numeric Another constant used for diffusion on the graph, exp(-diffusion.fading * (edge_length + diffusion.fading.const)) (default=0.5)</p>
</td></tr>
<tr><td><code id="propagate_labels_+3A_tol">tol</code></td>
<td>
<p>numeric Absolute tolerance as a stopping criteria (default=5e-3)</p>
</td></tr>
<tr><td><code id="propagate_labels_+3A_fixed_initial_labels">fixed_initial_labels</code></td>
<td>
<p>boolean Prohibit changes of initial labels during diffusion (default=FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix from input graph, with labels propagated
</p>

<hr>
<h2 id='propagateLabels'>Estimate labeling distribution for each vertex, based on provided labels.</h2><span id='topic+propagateLabels'></span>

<h3>Description</h3>

<p>Estimate labeling distribution for each vertex, based on provided labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>propagateLabels(graph, labels, method = "diffusion", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="propagateLabels_+3A_graph">graph</code></td>
<td>
<p>igraph graph object</p>
</td></tr>
<tr><td><code id="propagateLabels_+3A_labels">labels</code></td>
<td>
<p>vector of factor or character labels, named by cell names, used in propagateLabelsSolver() and propagateLabelsDiffusion()</p>
</td></tr>
<tr><td><code id="propagateLabels_+3A_method">method</code></td>
<td>
<p>string Type of propagation. Either 'diffusion' or 'solver'. (default='diffusion') 'solver' gives better result
but has bad asymptotics, so it is inappropriate for datasets &gt; 20k cells.</p>
</td></tr>
<tr><td><code id="propagateLabels_+3A_...">...</code></td>
<td>
<p>additional arguments passed to either propagateLabelsSolver() or propagateLabelsDiffusion()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with distribution of label probabilities for each vertex by rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>propagateLabels(conosGraph, labels=cellAnnotations)

</code></pre>

<hr>
<h2 id='propagateLabelsDiffusion'>Estimate labeling distribution for each vertex, based on provided labels using a Random Walk on graph</h2><span id='topic+propagateLabelsDiffusion'></span>

<h3>Description</h3>

<p>Estimate labeling distribution for each vertex, based on provided labels using a Random Walk on graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>propagateLabelsDiffusion(
  graph,
  labels,
  max.iters = 100,
  diffusion.fading = 10,
  diffusion.fading.const = 0.1,
  tol = 0.025,
  fixed.initial.labels = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="propagateLabelsDiffusion_+3A_graph">graph</code></td>
<td>
<p>igraph graph object Graph input</p>
</td></tr>
<tr><td><code id="propagateLabelsDiffusion_+3A_labels">labels</code></td>
<td>
<p>vector of factor or character labels, named by cell names</p>
</td></tr>
<tr><td><code id="propagateLabelsDiffusion_+3A_max.iters">max.iters</code></td>
<td>
<p>integer Maximal number of iterations (default=100)</p>
</td></tr>
<tr><td><code id="propagateLabelsDiffusion_+3A_diffusion.fading">diffusion.fading</code></td>
<td>
<p>numeric Constant used for diffusion on the graph, exp(-diffusion.fading * (edge_length + diffusion.fading.const)) (default=10.0)</p>
</td></tr>
<tr><td><code id="propagateLabelsDiffusion_+3A_diffusion.fading.const">diffusion.fading.const</code></td>
<td>
<p>numeric Another constant used for diffusion on the graph, exp(-diffusion.fading * (edge_length + diffusion.fading.const)) (default=0.1)</p>
</td></tr>
<tr><td><code id="propagateLabelsDiffusion_+3A_tol">tol</code></td>
<td>
<p>numeric Absolute tolerance as a stopping criteria (default=0.025)</p>
</td></tr>
<tr><td><code id="propagateLabelsDiffusion_+3A_fixed.initial.labels">fixed.initial.labels</code></td>
<td>
<p>boolean Prohibit changes of initial labels during diffusion (default=TRUE)</p>
</td></tr>
<tr><td><code id="propagateLabelsDiffusion_+3A_verbose">verbose</code></td>
<td>
<p>boolean Verbose mode (default=TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix from input graph, with labels propagated
</p>


<h3>Examples</h3>

<pre><code class='language-R'>propagateLabelsDiffusion(conosGraph, labels=cellAnnotations)

</code></pre>

<hr>
<h2 id='propagateLabelsSolver'>Propagate labels using Zhu, Ghahramani, Lafferty (2003) algorithm, &quot;Semi-Supervised Learning Using Gaussian Fields and Harmonic Functions&quot; &lt;http://mlg.eng.cam.ac.uk/zoubin/papers/zgl.pdf&gt;</h2><span id='topic+propagateLabelsSolver'></span>

<h3>Description</h3>

<p>Propagate labels using Zhu, Ghahramani, Lafferty (2003) algorithm, &quot;Semi-Supervised Learning Using Gaussian Fields and Harmonic Functions&quot; &lt;http://mlg.eng.cam.ac.uk/zoubin/papers/zgl.pdf&gt;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>propagateLabelsSolver(graph, labels, solver = "mumps")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="propagateLabelsSolver_+3A_graph">graph</code></td>
<td>
<p>igraph graph object Graph input</p>
</td></tr>
<tr><td><code id="propagateLabelsSolver_+3A_labels">labels</code></td>
<td>
<p>vector of factor or character labels, named by cell names</p>
</td></tr>
<tr><td><code id="propagateLabelsSolver_+3A_solver">solver</code></td>
<td>
<p>Method of solver to use (default=&quot;mumps&quot;), either &quot;Matrix&quot; or &quot;mumps&quot; (i.e. &quot;rmumps::Rmumps&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>result from Matrix::solve() or rmumps::Rmumps
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
propagateLabelsSolver(conosGraph, labels=cellAnnotations)

</code></pre>

<hr>
<h2 id='saveDeAsJson'>Save DE results as JSON tables for viewing in browser</h2><span id='topic+saveDeAsJson'></span>

<h3>Description</h3>

<p>Save DE results as JSON tables for viewing in browser
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveDeAsJson(
  de.raw,
  sample.groups = NULL,
  saveprefix = NULL,
  dir.name = "JSON",
  gene.metadata = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveDeAsJson_+3A_de.raw">de.raw</code></td>
<td>
<p>List of DE results from e.g. cacoa, conos</p>
</td></tr>
<tr><td><code id="saveDeAsJson_+3A_sample.groups">sample.groups</code></td>
<td>
<p>Sample groups as named list, each element containing a vector of samples. Can be retrieved from e.g. package cacoa (default=NULL)</p>
</td></tr>
<tr><td><code id="saveDeAsJson_+3A_saveprefix">saveprefix</code></td>
<td>
<p>Prefix for created files (default=NULL)</p>
</td></tr>
<tr><td><code id="saveDeAsJson_+3A_dir.name">dir.name</code></td>
<td>
<p>Name for directory with results. If it doesn't exist, it will be created. To disable, set as NULL (default=&quot;JSON&quot;)</p>
</td></tr>
<tr><td><code id="saveDeAsJson_+3A_gene.metadata">gene.metadata</code></td>
<td>
<p>(default=NULL) # Needs explanation</p>
</td></tr>
<tr><td><code id="saveDeAsJson_+3A_verbose">verbose</code></td>
<td>
<p>Show progress (default=TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>JSON files, table of content, and viewer files for viewing DE results in browser
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
saveDeAsJson(de.raw, sample.groups)

## End(Not run)
## The results can be viewed in a webbrowser by opening toc.html

</code></pre>

<hr>
<h2 id='setMinMax'>Set range for values in object. Changes values outside of range to min or max. Adapted from Seurat::MinMax</h2><span id='topic+setMinMax'></span>

<h3>Description</h3>

<p>Set range for values in object. Changes values outside of range to min or max. Adapted from Seurat::MinMax
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setMinMax(obj, min, max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setMinMax_+3A_obj">obj</code></td>
<td>
<p>Object to manipulate</p>
</td></tr>
<tr><td><code id="setMinMax_+3A_min">min</code></td>
<td>
<p>Minimum value</p>
</td></tr>
<tr><td><code id="setMinMax_+3A_max">max</code></td>
<td>
<p>Maximum value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with the same dimensions as input but with altered range in values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example_matrix =  matrix(rep(c(1:5), 3), 5)
setMinMax(example_matrix, 2, 4)

</code></pre>

<hr>
<h2 id='smooth_count_matrix'>Smooth gene expression, used primarily within conos::correctGenes. Used to smooth gene expression values in order to better represent the graph structure.
Use diffusion of expression on graph with the equation dv = exp(-a * (v + b))</h2><span id='topic+smooth_count_matrix'></span>

<h3>Description</h3>

<p>Smooth gene expression, used primarily within conos::correctGenes. Used to smooth gene expression values in order to better represent the graph structure.
Use diffusion of expression on graph with the equation dv = exp(-a * (v + b))
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_count_matrix(
  edge_verts,
  edge_weights,
  count_matrix,
  is_label_fixed,
  max_n_iters = 10L,
  diffusion_fading = 1,
  diffusion_fading_const = 0.1,
  tol = 0.001,
  verbose = TRUE,
  normalize = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_count_matrix_+3A_edge_verts">edge_verts</code></td>
<td>
<p>edge vertices of igraph graph object</p>
</td></tr>
<tr><td><code id="smooth_count_matrix_+3A_edge_weights">edge_weights</code></td>
<td>
<p>edge weights of igraph graph object</p>
</td></tr>
<tr><td><code id="smooth_count_matrix_+3A_count_matrix">count_matrix</code></td>
<td>
<p>gene count matrix</p>
</td></tr>
<tr><td><code id="smooth_count_matrix_+3A_is_label_fixed">is_label_fixed</code></td>
<td>
<p>boolean Whether label is fixed</p>
</td></tr>
<tr><td><code id="smooth_count_matrix_+3A_max_n_iters">max_n_iters</code></td>
<td>
<p>integer Maximal number of iterations (default=10)</p>
</td></tr>
<tr><td><code id="smooth_count_matrix_+3A_diffusion_fading">diffusion_fading</code></td>
<td>
<p>numeric Constant used for diffusion on the graph, exp(-diffusion.fading * (edge_length + diffusion.fading.const)) (default=1.0)</p>
</td></tr>
<tr><td><code id="smooth_count_matrix_+3A_diffusion_fading_const">diffusion_fading_const</code></td>
<td>
<p>numeric Another constant used for diffusion on the graph, exp(-diffusion.fading * (edge_length + diffusion.fading.const)) (default=0.1)</p>
</td></tr>
<tr><td><code id="smooth_count_matrix_+3A_tol">tol</code></td>
<td>
<p>numeric Absolute tolerance as a stopping criteria (default=1e-3)</p>
</td></tr>
<tr><td><code id="smooth_count_matrix_+3A_verbose">verbose</code></td>
<td>
<p>boolean Verbose mode (default=TRUE)</p>
</td></tr>
<tr><td><code id="smooth_count_matrix_+3A_normalize">normalize</code></td>
<td>
<p>boolean Whether to normalize values (default=FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix from input graph, with labels propagated
</p>

<hr>
<h2 id='smoothChebyshev'>Smooth with Chebyshev Polynomials</h2><span id='topic+smoothChebyshev'></span>

<h3>Description</h3>

<p>Smooth with Chebyshev Polynomials
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothChebyshev(
  lap,
  coeffs,
  signal,
  l.max,
  n.cores = 1,
  progress.chunks = 5,
  progress = (progress.chunks &gt; 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoothChebyshev_+3A_lap">lap</code></td>
<td>
<p>graph laplacian</p>
</td></tr>
<tr><td><code id="smoothChebyshev_+3A_coeffs">coeffs</code></td>
<td>
<p>numeric vector Chebyshev coefficients for a filter</p>
</td></tr>
<tr><td><code id="smoothChebyshev_+3A_signal">signal</code></td>
<td>
<p>Matrix or vector Signal to smooth</p>
</td></tr>
<tr><td><code id="smoothChebyshev_+3A_l.max">l.max</code></td>
<td>
<p>numeric maximal eigenvalue of the graph</p>
</td></tr>
<tr><td><code id="smoothChebyshev_+3A_n.cores">n.cores</code></td>
<td>
<p>numeric Number of cores for parallel run (default=1)</p>
</td></tr>
<tr><td><code id="smoothChebyshev_+3A_progress.chunks">progress.chunks</code></td>
<td>
<p>numeric Number of chunks per core for estimating progress (default=5). Large values are not suggested, as it may bring overhead.</p>
</td></tr>
<tr><td><code id="smoothChebyshev_+3A_progress">progress</code></td>
<td>
<p>boolean Flag on whether progress must be shown (default=TRUE, i.e. 'progress.chunks &gt; 1')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>smoothed signal
</p>


<h3>See Also</h3>

<p>Other graph smoothing: 
<code><a href="#topic+computeChebyshevCoeffs">computeChebyshevCoeffs</a>()</code>,
<code><a href="#topic+heatFilter">heatFilter</a>()</code>,
<code><a href="#topic+smoothSignalOnGraph">smoothSignalOnGraph</a>()</code>
</p>

<hr>
<h2 id='smoothSignalOnGraph'>Smooth Signal on Graph</h2><span id='topic+smoothSignalOnGraph'></span>

<h3>Description</h3>

<p>Smooth Signal on Graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothSignalOnGraph(
  signal,
  filter,
  graph = NULL,
  lap = NULL,
  l.max = NULL,
  m = 50,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoothSignalOnGraph_+3A_signal">signal</code></td>
<td>
<p>signal to be smoothed</p>
</td></tr>
<tr><td><code id="smoothSignalOnGraph_+3A_filter">filter</code></td>
<td>
<p>function that accepts signal 'x' and the maximal Laplacian eigenvalue 'l.max'. See <code><a href="#topic+heatFilter">heatFilter</a></code> as an example.</p>
</td></tr>
<tr><td><code id="smoothSignalOnGraph_+3A_graph">graph</code></td>
<td>
<p>igraph object with the graph (default=NULL)</p>
</td></tr>
<tr><td><code id="smoothSignalOnGraph_+3A_lap">lap</code></td>
<td>
<p>graph laplacian (default=NULL). If NULL, 'lap' estimated from graph.</p>
</td></tr>
<tr><td><code id="smoothSignalOnGraph_+3A_l.max">l.max</code></td>
<td>
<p>maximal eigenvalue of 'lap' (default=NULL). If NULL, estimated from 'lap'.</p>
</td></tr>
<tr><td><code id="smoothSignalOnGraph_+3A_m">m</code></td>
<td>
<p>numeric Maximum order of Chebyshev coeff to compute (default=50)</p>
</td></tr>
<tr><td><code id="smoothSignalOnGraph_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+smoothChebyshev">smoothChebyshev</a></code>
</p>

<dl>
<dt><code>n.cores</code></dt><dd><p>numeric Number of cores for parallel run (default=1)</p>
</dd>
<dt><code>progress.chunks</code></dt><dd><p>numeric Number of chunks per core for estimating progress (default=5). Large values are not suggested, as it may bring overhead.</p>
</dd>
<dt><code>progress</code></dt><dd><p>boolean Flag on whether progress must be shown (default=TRUE, i.e. 'progress.chunks &gt; 1')</p>
</dd>
</dl>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other graph smoothing: 
<code><a href="#topic+computeChebyshevCoeffs">computeChebyshevCoeffs</a>()</code>,
<code><a href="#topic+heatFilter">heatFilter</a>()</code>,
<code><a href="#topic+smoothChebyshev">smoothChebyshev</a>()</code>
</p>

<hr>
<h2 id='sn'>Set names equal to values, a stats::setNames wrapper function</h2><span id='topic+sn'></span>

<h3>Description</h3>

<p>Set names equal to values, a stats::setNames wrapper function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sn(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sn_+3A_x">x</code></td>
<td>
<p>an object for which names attribute will be meaningful</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with names assigned equal to values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vec = c(1, 2, 3, 4)
sn(vec)

</code></pre>

<hr>
<h2 id='splitVectorByNodes'>splitVectorByNodes</h2><span id='topic+splitVectorByNodes'></span>

<h3>Description</h3>

<p>splitVectorByNodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitVectorByNodes(vec, nodes, n.nodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitVectorByNodes_+3A_vec">vec</code></td>
<td>
<p>input vector to be divided</p>
</td></tr>
<tr><td><code id="splitVectorByNodes_+3A_nodes">nodes</code></td>
<td>
<p>nodes used to divide the vector 'vec' via split()</p>
</td></tr>
<tr><td><code id="splitVectorByNodes_+3A_n.nodes">n.nodes</code></td>
<td>
<p>numeric The number of nodes for splitting</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list from vec with names given by the nodes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adjList = graphToAdjList(conosGraph)
print(names(adjList))
## [1] "idx" "probabilities" "names" 
length(adjList$names)
## [1] 12000

</code></pre>

<hr>
<h2 id='styleEmbeddingPlot'>Set plot.theme, legend, ticks for embedding plot. Used primarily in embeddingPlot().</h2><span id='topic+styleEmbeddingPlot'></span>

<h3>Description</h3>

<p>Set plot.theme, legend, ticks for embedding plot. Used primarily in embeddingPlot().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>styleEmbeddingPlot(
  gg,
  plot.theme = NULL,
  title = NULL,
  legend.position = NULL,
  show.legend = TRUE,
  show.ticks = TRUE,
  show.labels = TRUE,
  relabel.axis = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="styleEmbeddingPlot_+3A_gg">gg</code></td>
<td>
<p>ggplot2 object to plot</p>
</td></tr>
<tr><td><code id="styleEmbeddingPlot_+3A_plot.theme">plot.theme</code></td>
<td>
<p>theme for the plot (default=NULL)</p>
</td></tr>
<tr><td><code id="styleEmbeddingPlot_+3A_title">title</code></td>
<td>
<p>plot title (default=NULL)</p>
</td></tr>
<tr><td><code id="styleEmbeddingPlot_+3A_legend.position">legend.position</code></td>
<td>
<p>vector with (x, y) positions of the legend (default=NULL)</p>
</td></tr>
<tr><td><code id="styleEmbeddingPlot_+3A_show.legend">show.legend</code></td>
<td>
<p>show legend (default=TRUE)</p>
</td></tr>
<tr><td><code id="styleEmbeddingPlot_+3A_show.ticks">show.ticks</code></td>
<td>
<p>show ticks and tick labels (default=TRUE)</p>
</td></tr>
<tr><td><code id="styleEmbeddingPlot_+3A_show.labels">show.labels</code></td>
<td>
<p>show labels (default=TRUE)</p>
</td></tr>
<tr><td><code id="styleEmbeddingPlot_+3A_relabel.axis">relabel.axis</code></td>
<td>
<p>boolean If TRUE, relabel axes with ggplot2::labs(x='Component 1', y='Component 2') (default=TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object
</p>

<hr>
<h2 id='umapEmbedding'>UMAP embedding</h2><span id='topic+umapEmbedding'></span>

<h3>Description</h3>

<p>UMAP embedding
</p>


<h3>Usage</h3>

<pre><code class='language-R'>umapEmbedding
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 12000 rows and 2 columns.
</p>

<hr>
<h2 id='val2col'>Utility function to translate values into colors.</h2><span id='topic+val2col'></span>

<h3>Description</h3>

<p>Utility function to translate values into colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>val2col(x, gradientPalette = NULL, zlim = NULL, gradient.range.quantile = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="val2col_+3A_x">x</code></td>
<td>
<p>input values</p>
</td></tr>
<tr><td><code id="val2col_+3A_gradientpalette">gradientPalette</code></td>
<td>
<p>gradient palette (default=NULL). If NULL, use colorRampPalette(c('gray90','red'), space = &quot;Lab&quot;)(1024) if the values are non-negative; otherwise colorRampPalette(c(&quot;blue&quot;, &quot;grey90&quot;, &quot;red&quot;), space = &quot;Lab&quot;)(1024) is used</p>
</td></tr>
<tr><td><code id="val2col_+3A_zlim">zlim</code></td>
<td>
<p>a two-value vector specifying limits of the values that should correspond to the extremes of the color gradient</p>
</td></tr>
<tr><td><code id="val2col_+3A_gradient.range.quantile">gradient.range.quantile</code></td>
<td>
<p>extreme quantiles of values that should be trimmed prior to color mapping (default=0.95)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>colors &lt;- val2col( rnorm(10) )

</code></pre>

<hr>
<h2 id='val2ggcol'>Helper function to return a ggplot color gradient for a numeric vector
ggplot(aes(color=x, ...), ...) + val2ggcol(x)</h2><span id='topic+val2ggcol'></span>

<h3>Description</h3>

<p>Helper function to return a ggplot color gradient for a numeric vector
ggplot(aes(color=x, ...), ...) + val2ggcol(x)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>val2ggcol(
  values,
  gradient.range.quantile = 1,
  color.range = "symmetric",
  palette = NULL,
  midpoint = NULL,
  oob = scales::squish,
  return.fill = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="val2ggcol_+3A_values">values</code></td>
<td>
<p>values by which the color gradient is determined</p>
</td></tr>
<tr><td><code id="val2ggcol_+3A_gradient.range.quantile">gradient.range.quantile</code></td>
<td>
<p>numeric Trimming quantile (default=1). Either a single number or two numbers - for lower and upper quantile.</p>
</td></tr>
<tr><td><code id="val2ggcol_+3A_color.range">color.range</code></td>
<td>
<p>either a vector of two values explicitly specifying the values corresponding to the start/end of the gradient, or string &quot;symmetric&quot; or &quot;all&quot; (default=&quot;symmetric&quot;). &quot;symmetric&quot;: range will fit data, but will be symmetrized around zeros, &quot;all&quot;: gradient will match the span of the range of the data (after gradient.range.quantile)</p>
</td></tr>
<tr><td><code id="val2ggcol_+3A_palette">palette</code></td>
<td>
<p>an optional palette (default=NULL). The default becomes blue-gray90-red; if the values do not straddle 0, then truncated gradients (blue-gray90 or gray90-red) will be used</p>
</td></tr>
<tr><td><code id="val2ggcol_+3A_midpoint">midpoint</code></td>
<td>
<p>optional midpoint (default=NULL). Set for the center of the resulting range by default</p>
</td></tr>
<tr><td><code id="val2ggcol_+3A_oob">oob</code></td>
<td>
<p>function to determine what to do with the values outside of the range (default =scales::squish). Refer to 'oob' parameter in ggplot</p>
</td></tr>
<tr><td><code id="val2ggcol_+3A_return.fill">return.fill</code></td>
<td>
<p>boolean Whether to return fill gradients instead of color (default=FALSE)</p>
</td></tr>
<tr><td><code id="val2ggcol_+3A_...">...</code></td>
<td>
<p>additional arguments are passed to ggplot2::scale_color_gradient* functions, i.e. scale_color_gradient(), scale_color_gradient2(), scale_color_gradientn()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2::scale_colour_gradient object
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
