<!DOCTYPE html><html lang="en"><head><title>Help for package spectrolab</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spectrolab}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#spectrolab-package'><p>Spectrolab</p></a></li>
<li><a href='#+5B.spectra'><p>Subset spectra</p></a></li>
<li><a href='#+5B+26lt+3B-.spectra'><p>Assign values to spectra</p></a></li>
<li><a href='#aggregate.spectra'><p>Aggregate spectra</p></a></li>
<li><a href='#apply_by_band'><p>Apply numeric function by band</p></a></li>
<li><a href='#as_spectra'><p>Convert matrix or data frame to spectra</p></a></li>
<li><a href='#as_spectra.data.frame'><p>Convert data.frame to spectra</p></a></li>
<li><a href='#as_spectra.matrix'><p>Convert matrix to spectra</p></a></li>
<li><a href='#as.data.frame.spectra'><p>Convert spectra to data.frame</p></a></li>
<li><a href='#as.matrix.spectra'><p>Convert spectra to matrix</p></a></li>
<li><a href='#bands'><p>Get spectra band labels</p></a></li>
<li><a href='#bands+26lt+3B-'><p>Set band labels</p></a></li>
<li><a href='#combine'><p>Combine spectral datasets</p></a></li>
<li><a href='#default_spec_regions'><p>Return default spectral regions matrix</p></a></li>
<li><a href='#dim.spectra'><p>Get dimension of spectra</p></a></li>
<li><a href='#fwhm_from_band_diff'><p>Get the FWHM from the difference between band values</p></a></li>
<li><a href='#guess_splice_at'><p>Guess splice bands (bounds between senors)</p></a></li>
<li><a href='#i_bands'><p>Internal band constructor for spectra</p></a></li>
<li><a href='#i_find_sensor_overlap_bounds'><p>Find sensor overlap bounds</p></a></li>
<li><a href='#i_index_pairwise_combn'><p>Pairwise index combinations</p></a></li>
<li><a href='#i_is_increasing'><p>Is increasing</p></a></li>
<li><a href='#i_is_index'><p>Compatible with being an index?</p></a></li>
<li><a href='#i_is_whole'><p>Is whole number?</p></a></li>
<li><a href='#i_make_fwhm'><p>Resample the FWHM to a new set of bands using a gaussian model</p></a></li>
<li><a href='#i_match_ij_spectra'><p>Get internal indexes for spectra attributes</p></a></li>
<li><a href='#i_match_label'><p>Match label</p></a></li>
<li><a href='#i_match_label_or_idx'><p>Match label or index</p></a></li>
<li><a href='#i_mav'><p>Moving Average</p></a></li>
<li><a href='#i_meta'><p>Internal metadata constructor for spectra</p></a></li>
<li><a href='#i_mind_the_gap_smoothing'><p>Warn if gap between bands is too wide</p></a></li>
<li><a href='#i_names'><p>Internal constructor for sample names</p></a></li>
<li><a href='#i_plot_boundaries'><p>Find plot boundaries in user space</p></a></li>
<li><a href='#i_plot_exists'><p>Tests if a plot device exists</p></a></li>
<li><a href='#i_read_ascii_metadata'><p>Read metadata</p></a></li>
<li><a href='#i_read_ascii_spectra'><p>Internal parser for ASCII format</p></a></li>
<li><a href='#i_read_asd_spectra'><p>Parser for ASD's '.asd'</p></a></li>
<li><a href='#i_trim_sensor_overlap'><p>Trim sensor overlap</p></a></li>
<li><a href='#i_value'><p>Internal constructor for value matrix</p></a></li>
<li><a href='#i_verify_path_and_format'><p>Internal function to verify file paths and format</p></a></li>
<li><a href='#is_spectra'><p>Is it a spectra object?</p></a></li>
<li><a href='#make_fwhm'><p>Resample the FWHM to a new set of bands using a gaussian model</p></a></li>
<li><a href='#match_sensors'><p>Match spectra at sensor transitions</p></a></li>
<li><a href='#max.spectra'><p>Maximum value</p></a></li>
<li><a href='#mean.spectra'><p>Mean spectrum</p></a></li>
<li><a href='#median.spectra'><p>Median spectrum</p></a></li>
<li><a href='#meta'><p>Get metadata</p></a></li>
<li><a href='#meta+26lt+3B-'><p>Set metadata</p></a></li>
<li><a href='#min.spectra'><p>Minimum value</p></a></li>
<li><a href='#names.spectra'><p>Get spectra sample names</p></a></li>
<li><a href='#names+26lt+3B-.spectra'><p>Set spectra sample names</p></a></li>
<li><a href='#normalize'><p>Vector normalize spectra</p></a></li>
<li><a href='#Ops.spectra'><p>Arithmetic operators for spectra</p></a></li>
<li><a href='#pairwise_indices'><p>Pairwise indices</p></a></li>
<li><a href='#pairwise_ratio'><p>Pairwise value ratios</p></a></li>
<li><a href='#plot_interactive'><p>Plot spectra interactively</p></a></li>
<li><a href='#plot_quantile'><p>Plot spectra quantiles</p></a></li>
<li><a href='#plot_regions'><p>Plot polygons for spectral regions</p></a></li>
<li><a href='#plot.spectra'><p>Plot spectra</p></a></li>
<li><a href='#print.spectra'><p>Print spectra</p></a></li>
<li><a href='#quantile.spectra'><p>Compute spectra quantiles</p></a></li>
<li><a href='#range.spectra'><p>Range of spectral values</p></a></li>
<li><a href='#read_spectra'><p>Read files from various formats into 'spectra'</p></a></li>
<li><a href='#resample'><p>Resample spectra</p></a></li>
<li><a href='#sd'><p>Standard deviation</p></a></li>
<li><a href='#sd.default'><p>Default standard deviation</p></a></li>
<li><a href='#sd.spectra'><p>Standard deviation spectrum</p></a></li>
<li><a href='#smooth'><p>Generic Smoothing function</p></a></li>
<li><a href='#smooth_fwhm'><p>Smooth spectra with a gaussian model</p></a></li>
<li><a href='#smooth_moving_avg'><p>Smooth moving average for spectra</p></a></li>
<li><a href='#smooth_spline'><p>Smooth spline functions for spectra</p></a></li>
<li><a href='#smooth.default'><p>Default smoothing function</p></a></li>
<li><a href='#smooth.spectra'><p>Smooth spectra</p></a></li>
<li><a href='#spec_matrix_example'><p>Example spectral dataset</p></a></li>
<li><a href='#spectra'><p>Spectra object constructor</p></a></li>
<li><a href='#split.spectra'><p>Split spectra</p></a></li>
<li><a href='#str.spectra'><p>Structure of the spectra object</p></a></li>
<li><a href='#subset_by'><p>Subset spectra by factor</p></a></li>
<li><a href='#summary.spectra'><p>Summarize spectra</p></a></li>
<li><a href='#t.spectra'><p>Spectra Transpose</p></a></li>
<li><a href='#try_keep_txt'><p>Wrap function to try to keep text</p></a></li>
<li><a href='#value'><p>Get spectra value</p></a></li>
<li><a href='#value+26lt+3B-'><p>Set spectra value</p></a></li>
<li><a href='#var'><p>Variance</p></a></li>
<li><a href='#var.default'><p>Variance</p></a></li>
<li><a href='#var.spectra'><p>Variance spectrum</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Class and Methods for Spectral Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.19</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-01-07</td>
</tr>
<tr>
<td>Description:</td>
<td>Input/Output, processing and visualization of spectra taken with different spectrometers, including SVC (Spectra Vista), ASD and PSR (Spectral Evolution). Implements an S3 class spectra that other packages can build on. Provides methods to access, plot, manipulate, splice sensor overlap, vector normalize and smooth spectra.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://CRAN.R-project.org/package=spectrolab">https://CRAN.R-project.org/package=spectrolab</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0), stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, tinytex, knitr (&ge; 1.30), rmarkdown (&ge; 2.5), testthat
(&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, parallel, RColorBrewer (&ge; 1.0), shiny (&ge; 1.5.0),
shinyjs (&ge; 1.1)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-10 16:59:40 UTC; meireles</td>
</tr>
<tr>
<td>Author:</td>
<td>Jose Eduardo Meireles [aut, cre],
  Anna K. Schweiger [aut],
  Jeannine Cavender-Bares [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jose Eduardo Meireles &lt;jemeireles@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-13 17:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='spectrolab-package'>Spectrolab</h2><span id='topic+spectrolab'></span><span id='topic+spectrolab-package'></span>

<h3>Description</h3>

<p>Class and methods for hyperspectral data.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jose Eduardo Meireles <a href="mailto:jemeireles@gmail.com">jemeireles@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Anna K. Schweiger <a href="mailto:anna.k.schweiger@gmail.com">anna.k.schweiger@gmail.com</a>
</p>
</li>
<li><p> Jeannine Cavender-Bares <a href="mailto:cavender@umn.edu">cavender@umn.edu</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://CRAN.R-project.org/package=spectrolab">https://CRAN.R-project.org/package=spectrolab</a>
</p>
</li></ul>


<hr>
<h2 id='+5B.spectra'>Subset spectra</h2><span id='topic++5B.spectra'></span>

<h3>Description</h3>

<p><code>`[`</code> Subsets spectra by sample names (rows) or (and) bands (columns)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spectra'
x[i, j, simplify = TRUE]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B5B.spectra_+3A_x">x</code></td>
<td>
<p>spectra object</p>
</td></tr>
<tr><td><code id="+2B5B.spectra_+3A_i">i</code></td>
<td>
<p>Sample names (preferred), index, or a logical vector of length nrow(x)</p>
</td></tr>
<tr><td><code id="+2B5B.spectra_+3A_j">j</code></td>
<td>
<p>band labels, as numeric or character
or a logical vector of length ncol(x). Do not use indexes!</p>
</td></tr>
<tr><td><code id="+2B5B.spectra_+3A_simplify">simplify</code></td>
<td>
<p>Boolean. If TRUE (default), single band selections
are returned as a named vector of values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Subset operations based on samples (first argument) will match sample
names or indexes, in that order. The spectra constructor ensures that names are
not numeric nor are coercible to numeric, such that x[1:2, ] will return the
first and second samples in the 'spectra' object. Subsetting based on bands
(second argument) matches the band labels, not indices! That is, x[ , 600]
will give you the value data for the 600nm band and not the 600th
band. Boolean vectors of the appropriate length can be used to subset samples
and bands.
</p>


<h3>Value</h3>

<p>usually a spectra object, but see param 'simplify'
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec = as_spectra(spec_matrix_example, name_idx = 1)
head(names(spec), n = 3)
# by name
spec1 = spec[ "species_7" , ]
spec1
# by band
spec2 = spec[ , 400:700 ]
spec2
</code></pre>

<hr>
<h2 id='+5B+26lt+3B-.spectra'>Assign values to spectra</h2><span id='topic++5B+3C-.spectra'></span>

<h3>Description</h3>

<p><code>`[&lt;-`</code> assigns the rhs values to spectra
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 replacement method for class 'spectra'
x[i, j] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B5B+2B26lt+2B3B-.spectra_+3A_x">x</code></td>
<td>
<p>spectra object (lhs)</p>
</td></tr>
<tr><td><code id="+2B5B+2B26lt+2B3B-.spectra_+3A_i">i</code></td>
<td>
<p>Sample names (preferred), index, or a logical vector of length nrow(x)</p>
</td></tr>
<tr><td><code id="+2B5B+2B26lt+2B3B-.spectra_+3A_j">j</code></td>
<td>
<p>band labels, as numeric or character
or a logical vector of length ncol(x). Do not use indexes!</p>
</td></tr>
<tr><td><code id="+2B5B+2B26lt+2B3B-.spectra_+3A_value">value</code></td>
<td>
<p>value to be assigned (rhs). Must either data coercible to numeric
or another 'spectra' obj</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing. modifies spectra as side effect
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec = as_spectra(spec_matrix_example, name_idx = 1)
spec[ , 400:500] = spec[ , 400:500] * 1.2
spec
</code></pre>

<hr>
<h2 id='aggregate.spectra'>Aggregate spectra</h2><span id='topic+aggregate.spectra'></span>

<h3>Description</h3>

<p>Applies FUN (and FUN_meta) over spectra aggregating by factor 'by'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spectra'
aggregate(x, by, FUN, FUN_meta = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aggregate.spectra_+3A_x">x</code></td>
<td>
<p>spectra object</p>
</td></tr>
<tr><td><code id="aggregate.spectra_+3A_by">by</code></td>
<td>
<p>vector of factors to guide the aggregation</p>
</td></tr>
<tr><td><code id="aggregate.spectra_+3A_fun">FUN</code></td>
<td>
<p>function to be applied to value (and meta if FUN_meta is NULL)</p>
</td></tr>
<tr><td><code id="aggregate.spectra_+3A_fun_meta">FUN_meta</code></td>
<td>
<p>function to be applied to metadata. If NULL (default), same
FUN applied to value is used.</p>
</td></tr>
<tr><td><code id="aggregate.spectra_+3A_...">...</code></td>
<td>
<p>extra args to FUN</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument FUN_meta is useful if you want to apply a different function to
metadata and value. If you want to aggregate spectra and metadata
using 'mean', 'sd', 'median' etc. but try to keep the text values, wrap your
function in <code>try_keep_txt(f)</code>.
</p>


<h3>Value</h3>

<p>spectra object
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec = as_spectra(spec_matrix_example, name_idx = 1)
spec_mean = aggregate(spec, by = names(spec), mean, try_keep_txt(mean))
</code></pre>

<hr>
<h2 id='apply_by_band'>Apply numeric function by band</h2><span id='topic+apply_by_band'></span><span id='topic+apply_by_band.spectra'></span>

<h3>Description</h3>

<p><code>apply_by_band</code> is conceptually similar to apply(as.matrix(x), 2, fun),
but returns a spectra object while dealing with metadata and attributes.
Applying a function that does not act on numeric values may crash the function
or render all values NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_by_band(x, fun, na.rm = TRUE, keep_txt_meta = TRUE, name = NULL, ...)

## S3 method for class 'spectra'
apply_by_band(x, fun, na.rm = TRUE, keep_txt_meta = TRUE, name = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_by_band_+3A_x">x</code></td>
<td>
<p>spectra</p>
</td></tr>
<tr><td><code id="apply_by_band_+3A_fun">fun</code></td>
<td>
<p>numeric function to be applied to each band.</p>
</td></tr>
<tr><td><code id="apply_by_band_+3A_na.rm">na.rm</code></td>
<td>
<p>boolean. remove NAs?</p>
</td></tr>
<tr><td><code id="apply_by_band_+3A_keep_txt_meta">keep_txt_meta</code></td>
<td>
<p>boolean. try to keep text in the metadata?</p>
</td></tr>
<tr><td><code id="apply_by_band_+3A_name">name</code></td>
<td>
<p>name for each sample in the output spectra. The default (NULL) will
give samples sequential numeric names. Recycled if necessary.</p>
</td></tr>
<tr><td><code id="apply_by_band_+3A_...">...</code></td>
<td>
<p>extra arguments passed to fun</p>
</td></tr>
</table>


<h3>Value</h3>

<p>spectra
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>apply_by_band(spectra)</code>: Apply a numeric function by band
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec = as_spectra(spec_matrix_example, name_idx = 1)
spec_mean = apply_by_band(spec, mean)
</code></pre>

<hr>
<h2 id='as_spectra'>Convert matrix or data frame to spectra</h2><span id='topic+as_spectra'></span>

<h3>Description</h3>

<p>Convert matrix or data frame to spectra
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_spectra(x, name_idx = NULL, meta_idxs = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_spectra_+3A_x">x</code></td>
<td>
<p>matrix or dataframe. Samples are in rows and bands in columns.
Any data that are not the spectra themselves (labels or metadata)
must have their column index included in 'name_idx' or 'meta_idxs'.</p>
</td></tr>
<tr><td><code id="as_spectra_+3A_name_idx">name_idx</code></td>
<td>
<p>column index with sample names. Defaults to NULL. If NULL
or 0, rownames(x) or a sequence of integers will be assigned
as names.</p>
</td></tr>
<tr><td><code id="as_spectra_+3A_meta_idxs">meta_idxs</code></td>
<td>
<p>column indices with metadata (not name and not value).
Defaults to NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>spectra object
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
as_spectra(spec_matrix_example, name_idx = 1)
</code></pre>

<hr>
<h2 id='as_spectra.data.frame'>Convert data.frame to spectra</h2><span id='topic+as_spectra.data.frame'></span>

<h3>Description</h3>

<p>Convert data.frame to spectra
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
as_spectra(x, name_idx = NULL, meta_idxs = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_spectra.data.frame_+3A_x">x</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="as_spectra.data.frame_+3A_name_idx">name_idx</code></td>
<td>
<p>column index with sample names. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="as_spectra.data.frame_+3A_meta_idxs">meta_idxs</code></td>
<td>
<p>column indices with metadata (not name and not value).
Defaults to NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>spectra object
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>

<hr>
<h2 id='as_spectra.matrix'>Convert matrix to spectra</h2><span id='topic+as_spectra.matrix'></span>

<h3>Description</h3>

<p>Convert matrix to spectra
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
as_spectra(x, name_idx = NULL, meta_idxs = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_spectra.matrix_+3A_x">x</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="as_spectra.matrix_+3A_name_idx">name_idx</code></td>
<td>
<p>column index with sample names. Defaults to NULL</p>
</td></tr>
<tr><td><code id="as_spectra.matrix_+3A_meta_idxs">meta_idxs</code></td>
<td>
<p>column indices with metadata (not name and not value).
Defaults to NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>spectra object
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>

<hr>
<h2 id='as.data.frame.spectra'>Convert spectra to data.frame</h2><span id='topic+as.data.frame.spectra'></span>

<h3>Description</h3>

<p>Returns a data.frame that includes sample names, metadata (if present) and
value data. One advantage over as.matrix, is that the metadata are
returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spectra'
as.data.frame(
  x,
  row.names = NULL,
  optional = FALSE,
  fix_names = "none",
  metadata = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.frame.spectra_+3A_x">x</code></td>
<td>
<p>spectra object</p>
</td></tr>
<tr><td><code id="as.data.frame.spectra_+3A_row.names">row.names</code></td>
<td>
<p>does nothing. Here for compatibility with S3 generics</p>
</td></tr>
<tr><td><code id="as.data.frame.spectra_+3A_optional">optional</code></td>
<td>
<p>does nothing. Here for compatibility with S3 generics</p>
</td></tr>
<tr><td><code id="as.data.frame.spectra_+3A_fix_names">fix_names</code></td>
<td>
<p>Use make.names to normalize names?
Pick one: &quot;none&quot; &quot;row&quot; &quot;col&quot; &quot;both&quot;.</p>
</td></tr>
<tr><td><code id="as.data.frame.spectra_+3A_metadata">metadata</code></td>
<td>
<p>boolean. Include spectral metadata? Defaults to TRUE</p>
</td></tr>
<tr><td><code id="as.data.frame.spectra_+3A_...">...</code></td>
<td>
<p>extra parameters passed to the generic as_spectra</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with: sample_name, metadata (if any) and value.
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec = as_spectra(spec_matrix_example, name_idx = 1)
df   = as.data.frame(spec, fix_names = "none")
</code></pre>

<hr>
<h2 id='as.matrix.spectra'>Convert spectra to matrix</h2><span id='topic+as.matrix.spectra'></span>

<h3>Description</h3>

<p>Convert spectra to matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spectra'
as.matrix(x, fix_names = "none", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.matrix.spectra_+3A_x">x</code></td>
<td>
<p>spectra object</p>
</td></tr>
<tr><td><code id="as.matrix.spectra_+3A_fix_names">fix_names</code></td>
<td>
<p>Use make.names to normalize names?
Pick one: &quot;none&quot; &quot;row&quot; &quot;col&quot; &quot;both&quot;.</p>
</td></tr>
<tr><td><code id="as.matrix.spectra_+3A_...">...</code></td>
<td>
<p>does nothing. Here for compatibility with S3 generics</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of spectral value. columns are bands and rows are
samples
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec = as_spectra(spec_matrix_example, name_idx = 1)
mat  = as.matrix(spec)
</code></pre>

<hr>
<h2 id='bands'>Get spectra band labels</h2><span id='topic+bands'></span><span id='topic+bands.spectra'></span>

<h3>Description</h3>

<p><code>bands</code> returns a vector of band labels from spectra
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bands(x, min = NULL, max = NULL, return_num = TRUE)

## S3 method for class 'spectra'
bands(x, min = NULL, max = NULL, return_num = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bands_+3A_x">x</code></td>
<td>
<p>spectra object</p>
</td></tr>
<tr><td><code id="bands_+3A_min">min</code></td>
<td>
<p>= NULL</p>
</td></tr>
<tr><td><code id="bands_+3A_max">max</code></td>
<td>
<p>= NULL</p>
</td></tr>
<tr><td><code id="bands_+3A_return_num">return_num</code></td>
<td>
<p>boolean. return vector of numeric values (default).
otherwise, a vector of strings is returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of bands. numeric if 'return_num' = TRUE (default).
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>bands(spectra)</code>: Get spectra band labels
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec = as_spectra(spec_matrix_example, name_idx = 1)
head(bands(spec))
</code></pre>

<hr>
<h2 id='bands+26lt+3B-'>Set band labels</h2><span id='topic+bands+3C-'></span>

<h3>Description</h3>

<p><code>bands</code> sets band labels of lhs to the rhs values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bands(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bands+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>spectra object (lhs)</p>
</td></tr>
<tr><td><code id="bands+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>rhs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing. called for its side effect.
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec = as_spectra(spec_matrix_example, name_idx = 1)
bands(spec) = bands(spec) / 1000
</code></pre>

<hr>
<h2 id='combine'>Combine spectral datasets</h2><span id='topic+combine'></span><span id='topic+combine.spectra'></span>

<h3>Description</h3>

<p><code>combine</code> binds two spectral datasets. Both spectra must have the
very same band labels, but different metadata are acceptable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine(s1, s2)

## S3 method for class 'spectra'
combine(s1, s2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine_+3A_s1">s1</code></td>
<td>
<p>spectra object 1</p>
</td></tr>
<tr><td><code id="combine_+3A_s2">s2</code></td>
<td>
<p>spectra object 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>combined spectra object
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>combine(spectra)</code>: Combines two spectral datasets
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)

# Create dummy spectra datasets. Pretend that these are all different...
s1 = as_spectra(spec_matrix_example, name_idx = 1)
s2 = as_spectra(spec_matrix_example, name_idx = 1)
s3 = as_spectra(spec_matrix_example, name_idx = 1)

# combine 2 spectra objects
s_1and2 = combine(s1, s2)

# combine n spectra objects using the `Reduce` function
s_n = Reduce(combine, list(s1, s2, s3))
</code></pre>

<hr>
<h2 id='default_spec_regions'>Return default spectral regions matrix</h2><span id='topic+default_spec_regions'></span>

<h3>Description</h3>

<p>Return default spectral regions matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_spec_regions()
</code></pre>


<h3>Value</h3>

<p>matrix with default_spec_regions
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
# matrix that defines regions on the spectra
# Useful for plotting w/ plot_regions()
</code></pre>

<hr>
<h2 id='dim.spectra'>Get dimension of spectra</h2><span id='topic+dim.spectra'></span>

<h3>Description</h3>

<p><code>dim</code> returns a vector with number of samples and bands (bands)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spectra'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dim.spectra_+3A_x">x</code></td>
<td>
<p>spectra object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tuple of integers: c(&quot;n_samples&quot;, &quot;n_bands&quot;)
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec = as_spectra(spec_matrix_example, name_idx = 1)
dim(spec)
</code></pre>

<hr>
<h2 id='fwhm_from_band_diff'>Get the FWHM from the difference between band values</h2><span id='topic+fwhm_from_band_diff'></span>

<h3>Description</h3>

<p>Get the FWHM from the difference between band values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fwhm_from_band_diff(bands)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fwhm_from_band_diff_+3A_bands">bands</code></td>
<td>
<p>band values. numeric</p>
</td></tr>
</table>


<h3>Value</h3>

<p>FWHM as a numeric vector
</p>

<hr>
<h2 id='guess_splice_at'>Guess splice bands (bounds between senors)</h2><span id='topic+guess_splice_at'></span><span id='topic+guess_splice_at.spectra'></span>

<h3>Description</h3>

<p>Guess splice bands (bounds between senors)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess_splice_at(x)

## S3 method for class 'spectra'
guess_splice_at(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="guess_splice_at_+3A_x">x</code></td>
<td>
<p>spectra object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of band values
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>guess_splice_at(spectra)</code>: Guess splice bands (bounds between senors)
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>

<hr>
<h2 id='i_bands'>Internal band constructor for spectra</h2><span id='topic+i_bands'></span>

<h3>Description</h3>

<p><code>i_bands</code> constructs band labels in the appropriate format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_bands(x, nbands = NULL, warn_dup_band = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_bands_+3A_x">x</code></td>
<td>
<p>vector of bands. Either numeric or character</p>
</td></tr>
<tr><td><code id="i_bands_+3A_nbands">nbands</code></td>
<td>
<p>Integer of expected number of bands.
If NULL (default) checking is skipped.</p>
</td></tr>
<tr><td><code id="i_bands_+3A_warn_dup_band">warn_dup_band</code></td>
<td>
<p>Warn about duplicated bands?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of bands
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>

<hr>
<h2 id='i_find_sensor_overlap_bounds'>Find sensor overlap bounds</h2><span id='topic+i_find_sensor_overlap_bounds'></span>

<h3>Description</h3>

<p><code>i_find_sensor_overlap_bounds</code> finds the overlap bounds between sensors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_find_sensor_overlap_bounds(x, idx = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_find_sensor_overlap_bounds_+3A_x">x</code></td>
<td>
<p>wavelength vector</p>
</td></tr>
<tr><td><code id="i_find_sensor_overlap_bounds_+3A_idx">idx</code></td>
<td>
<p>boolean. return indices? defaults to TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with sensor bounds
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>

<hr>
<h2 id='i_index_pairwise_combn'>Pairwise index combinations</h2><span id='topic+i_index_pairwise_combn'></span>

<h3>Description</h3>

<p><code>i_index_pairwise_combn</code> returns the split pairwise combination of idxs
in a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_index_pairwise_combn(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_index_pairwise_combn_+3A_n">n</code></td>
<td>
<p>number of indices</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of matrices. For each focal index up to n - 1, a matrix with the
other indexes it interacts with (2nd col) and the &quot;absolute position&quot; of that
pairwise interaction (1st column) is returned.
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>

<hr>
<h2 id='i_is_increasing'>Is increasing</h2><span id='topic+i_is_increasing'></span>

<h3>Description</h3>

<p><code>i_is_increasing</code> tests if numerical values are increasing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_is_increasing(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_is_increasing_+3A_x">x</code></td>
<td>
<p>bands</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Many transform functions can only (or at least should only) be applied to
spectra with increasing band values. <code>i_is_increasing</code> tests for that.
</p>


<h3>Value</h3>

<p>boolean
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>

<hr>
<h2 id='i_is_index'>Compatible with being an index?</h2><span id='topic+i_is_index'></span>

<h3>Description</h3>

<p><code>i_is_index</code> Tests if x fit the requirements of being indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_is_index(x, max_value, allow_negative = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_is_index_+3A_x">x</code></td>
<td>
<p>numeric values</p>
</td></tr>
<tr><td><code id="i_is_index_+3A_max_value">max_value</code></td>
<td>
<p>Max acceptable values for x (inclusive). Must be greater than 1</p>
</td></tr>
<tr><td><code id="i_is_index_+3A_allow_negative">allow_negative</code></td>
<td>
<p>boolean. Count negative integers as indices? defaults to FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function potentially allows negative indices, given that they may be used
with the intent of removing an entry that corresponds to the index. Conversely,
zero is never used as an index in R and is not recognized as such here.
</p>


<h3>Value</h3>

<p>boolean
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>

<hr>
<h2 id='i_is_whole'>Is whole number?</h2><span id='topic+i_is_whole'></span>

<h3>Description</h3>

<p><code>i_is_whole</code> Tests if x is (are) whole numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_is_whole(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_is_whole_+3A_x">x</code></td>
<td>
<p>single value or vector of numbers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>

<hr>
<h2 id='i_make_fwhm'>Resample the FWHM to a new set of bands using a gaussian model</h2><span id='topic+i_make_fwhm'></span>

<h3>Description</h3>

<p>Resample the FWHM to a new set of bands using a gaussian model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_make_fwhm(
  old_bands,
  old_fwhm,
  new_bands,
  new_fwhm,
  return_type = "max",
  k = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_make_fwhm_+3A_old_bands">old_bands</code></td>
<td>
<p>band values of the original spectra</p>
</td></tr>
<tr><td><code id="i_make_fwhm_+3A_old_fwhm">old_fwhm</code></td>
<td>
<p>FWHM for the original spectra</p>
</td></tr>
<tr><td><code id="i_make_fwhm_+3A_new_bands">new_bands</code></td>
<td>
<p>band values for the resampled spectra</p>
</td></tr>
<tr><td><code id="i_make_fwhm_+3A_new_fwhm">new_fwhm</code></td>
<td>
<p>FWHM for the resampled spectra</p>
</td></tr>
<tr><td><code id="i_make_fwhm_+3A_return_type">return_type</code></td>
<td>
<p>Either &quot;max&quot; (default) or &quot;old&quot;. Max returns the maximum from either the old or the new FWHM for each band</p>
</td></tr>
<tr><td><code id="i_make_fwhm_+3A_k">k</code></td>
<td>
<p>number of FWHM categories. Defaults to 0, which means, return the FWHM in as much detail as possible.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector of FWHM estimates
</p>

<hr>
<h2 id='i_match_ij_spectra'>Get internal indexes for spectra attributes</h2><span id='topic+i_match_ij_spectra'></span>

<h3>Description</h3>

<p><code>i_match_ij_spectra</code> gets index position matching i and j
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_match_ij_spectra(x, i = NULL, j = NULL, allow_negative = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_match_ij_spectra_+3A_x">x</code></td>
<td>
<p>spectra</p>
</td></tr>
<tr><td><code id="i_match_ij_spectra_+3A_i">i</code></td>
<td>
<p>sample names or indices or boolean vector</p>
</td></tr>
<tr><td><code id="i_match_ij_spectra_+3A_j">j</code></td>
<td>
<p>bands or boolean vector, NOT INDICES</p>
</td></tr>
<tr><td><code id="i_match_ij_spectra_+3A_allow_negative">allow_negative</code></td>
<td>
<p>boolean. Allow indices i to be negative? Defaults to
FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list if row indices and column indices
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>

<hr>
<h2 id='i_match_label'>Match label</h2><span id='topic+i_match_label'></span>

<h3>Description</h3>

<p>Match label
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_match_label(
  x,
  i,
  full = FALSE,
  allow_empty_lookup = FALSE,
  allow_negative = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_match_label_+3A_x">x</code></td>
<td>
<p>label vector</p>
</td></tr>
<tr><td><code id="i_match_label_+3A_i">i</code></td>
<td>
<p>picked label or NULL</p>
</td></tr>
<tr><td><code id="i_match_label_+3A_full">full</code></td>
<td>
<p>boolean. If TRUE, a full list of results is returned</p>
</td></tr>
<tr><td><code id="i_match_label_+3A_allow_empty_lookup">allow_empty_lookup</code></td>
<td>
<p>boolean. If TRUE, x is allowed to be NULL. Defaults
to false</p>
</td></tr>
<tr><td><code id="i_match_label_+3A_allow_negative">allow_negative</code></td>
<td>
<p>boolean. Allow labels to be negative? Defaults to FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matched indices, or list in case full = TRUE
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>

<hr>
<h2 id='i_match_label_or_idx'>Match label or index</h2><span id='topic+i_match_label_or_idx'></span>

<h3>Description</h3>

<p>Match label or index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_match_label_or_idx(
  x,
  i,
  full = FALSE,
  allow_empty_lookup = FALSE,
  allow_negative = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_match_label_or_idx_+3A_x">x</code></td>
<td>
<p>label vector</p>
</td></tr>
<tr><td><code id="i_match_label_or_idx_+3A_i">i</code></td>
<td>
<p>picked label or idx or NULL</p>
</td></tr>
<tr><td><code id="i_match_label_or_idx_+3A_full">full</code></td>
<td>
<p>boolean. If TRUE, a full list of results is returned</p>
</td></tr>
<tr><td><code id="i_match_label_or_idx_+3A_allow_empty_lookup">allow_empty_lookup</code></td>
<td>
<p>boolean. If TRUE, x is allowed to be NULL. Defaults
to false</p>
</td></tr>
<tr><td><code id="i_match_label_or_idx_+3A_allow_negative">allow_negative</code></td>
<td>
<p>boolean. Allow indices to be negative? Defaults to FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matched indices
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>

<hr>
<h2 id='i_mav'>Moving Average</h2><span id='topic+i_mav'></span>

<h3>Description</h3>

<p><code>i_mav</code> computes the moving average of a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_mav(x, n = 3, sides = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_mav_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="i_mav_+3A_n">n</code></td>
<td>
<p>number of points going into the average</p>
</td></tr>
<tr><td><code id="i_mav_+3A_sides">sides</code></td>
<td>
<p>TODO</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>References</h3>

<p>http://stackoverflow.com/questions/743812/calculating-moving-average-in-r
</p>

<hr>
<h2 id='i_meta'>Internal metadata constructor for spectra</h2><span id='topic+i_meta'></span>

<h3>Description</h3>

<p><code>i_meta</code> constructs a metadata data.frame in the appropriate format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_meta(x, nsample, allow_null = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_meta_+3A_x">x</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="i_meta_+3A_nsample">nsample</code></td>
<td>
<p>number of samples in spectra</p>
</td></tr>
<tr><td><code id="i_meta_+3A_allow_null">allow_null</code></td>
<td>
<p>boolean. If TRUE (default) and x is NULL, the function will
return NULL regardless of nsample</p>
</td></tr>
<tr><td><code id="i_meta_+3A_...">...</code></td>
<td>
<p>additional arguments passed to as.data.frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>

<hr>
<h2 id='i_mind_the_gap_smoothing'>Warn if gap between bands is too wide</h2><span id='topic+i_mind_the_gap_smoothing'></span>

<h3>Description</h3>

<p>Warn if gap between bands is too wide
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_mind_the_gap_smoothing(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_mind_the_gap_smoothing_+3A_x">x</code></td>
<td>
<p>spectra</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing. warn if gap is too wide
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>

<hr>
<h2 id='i_names'>Internal constructor for sample names</h2><span id='topic+i_names'></span>

<h3>Description</h3>

<p><code>i_names</code> constructs a sample name vector in the appropriate format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_names(x, nsample = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_names_+3A_x">x</code></td>
<td>
<p>vector of labels. Should be character.</p>
</td></tr>
<tr><td><code id="i_names_+3A_nsample">nsample</code></td>
<td>
<p>Integer of expected number of samples.
If NULL (default) checking is skipped.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of sample names coerced to character
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>

<hr>
<h2 id='i_plot_boundaries'>Find plot boundaries in user space</h2><span id='topic+i_plot_boundaries'></span>

<h3>Description</h3>

<p><code>i_plot_boundaries</code> gets plot boundaries in user space as matrix or vec
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_plot_boundaries(return_mat = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_plot_boundaries_+3A_return_mat">return_mat</code></td>
<td>
<p>return a matrix instead of vector? defaults to FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector or matrix, depending on return_mat value
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>

<hr>
<h2 id='i_plot_exists'>Tests if a plot device exists</h2><span id='topic+i_plot_exists'></span>

<h3>Description</h3>

<p>Tests if a plot device exists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_plot_exists()
</code></pre>


<h3>Value</h3>

<p>boolean
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>

<hr>
<h2 id='i_read_ascii_metadata'>Read metadata</h2><span id='topic+i_read_ascii_metadata'></span>

<h3>Description</h3>

<p>Read metadata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_read_ascii_metadata(
  file_paths,
  sample_type,
  max_lines,
  sep_char,
  meta_tags,
  tag_sep
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_read_ascii_metadata_+3A_file_paths">file_paths</code></td>
<td>
<p>paths</p>
</td></tr>
<tr><td><code id="i_read_ascii_metadata_+3A_sample_type">sample_type</code></td>
<td>
<p>target or reference</p>
</td></tr>
<tr><td><code id="i_read_ascii_metadata_+3A_max_lines">max_lines</code></td>
<td>
<p>max number of lines to read</p>
</td></tr>
<tr><td><code id="i_read_ascii_metadata_+3A_sep_char">sep_char</code></td>
<td>
<p>separator of data within a field</p>
</td></tr>
<tr><td><code id="i_read_ascii_metadata_+3A_meta_tags">meta_tags</code></td>
<td>
<p>tags that match the metadata fields in the file</p>
</td></tr>
<tr><td><code id="i_read_ascii_metadata_+3A_tag_sep">tag_sep</code></td>
<td>
<p>char that separates the tags from the data in the file</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>

<hr>
<h2 id='i_read_ascii_spectra'>Internal parser for ASCII format</h2><span id='topic+i_read_ascii_spectra'></span>

<h3>Description</h3>

<p>Generic parser for SVC's &lsquo;.sig' and PSR&rsquo;s '.sed'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_read_ascii_spectra(
  file_paths,
  skip_until_tag = NULL,
  sep_char,
  header,
  wl_col,
  refl_cols,
  divide_refl_by,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_read_ascii_spectra_+3A_file_paths">file_paths</code></td>
<td>
<p>paths for files already parsed by 'read_spectra'</p>
</td></tr>
<tr><td><code id="i_read_ascii_spectra_+3A_skip_until_tag">skip_until_tag</code></td>
<td>
<p>Tag that precedes the table of value data,
indicating that lines until that tag should be skipped.
Tag is matched with a regexpr.</p>
</td></tr>
<tr><td><code id="i_read_ascii_spectra_+3A_sep_char">sep_char</code></td>
<td>
<p>separator</p>
</td></tr>
<tr><td><code id="i_read_ascii_spectra_+3A_header">header</code></td>
<td>
<p>boolean. keep header?</p>
</td></tr>
<tr><td><code id="i_read_ascii_spectra_+3A_wl_col">wl_col</code></td>
<td>
<p>idx or name of band column</p>
</td></tr>
<tr><td><code id="i_read_ascii_spectra_+3A_refl_cols">refl_cols</code></td>
<td>
<p>idx or name of value columns. MULTIPLE</p>
</td></tr>
<tr><td><code id="i_read_ascii_spectra_+3A_divide_refl_by">divide_refl_by</code></td>
<td>
<p>divide values by this. MULTIPLE</p>
</td></tr>
<tr><td><code id="i_read_ascii_spectra_+3A_...">...</code></td>
<td>
<p>additional arguments passed to read table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>single 'spectra' or list of 'spectra'
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles and Anna Schweiger
</p>

<hr>
<h2 id='i_read_asd_spectra'>Parser for ASD's '.asd'</h2><span id='topic+i_read_asd_spectra'></span>

<h3>Description</h3>

<p>Parser for ASD's '.asd'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_read_asd_spectra(file_paths, type = "target_reflectance", divide_refl_by)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_read_asd_spectra_+3A_file_paths">file_paths</code></td>
<td>
<p>paths for files already parsed by 'read_spectra'</p>
</td></tr>
<tr><td><code id="i_read_asd_spectra_+3A_type">type</code></td>
<td>
<p>Data type to read. &quot;target_refl&quot;, &quot;target_rad&quot;, &quot;reference_rad&quot;.
Defaults to &quot;target_refl&quot;.</p>
</td></tr>
<tr><td><code id="i_read_asd_spectra_+3A_divide_refl_by">divide_refl_by</code></td>
<td>
<p>divide values by this</p>
</td></tr>
</table>


<h3>Value</h3>

<p>spectra object
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>

<hr>
<h2 id='i_trim_sensor_overlap'>Trim sensor overlap</h2><span id='topic+i_trim_sensor_overlap'></span>

<h3>Description</h3>

<p>Trim sensor overlap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_trim_sensor_overlap(x, splice_at)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_trim_sensor_overlap_+3A_x">x</code></td>
<td>
<p>spectra object</p>
</td></tr>
<tr><td><code id="i_trim_sensor_overlap_+3A_splice_at">splice_at</code></td>
<td>
<p>bands where to splice sensors. suggests where the
beginning of sensors 2 and 3 should be.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>spectra object
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>

<hr>
<h2 id='i_value'>Internal constructor for value matrix</h2><span id='topic+i_value'></span>

<h3>Description</h3>

<p><code>i_value</code> constructs value matrix in the appropriate format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_value(x, nbands = NULL, nsample = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_value_+3A_x">x</code></td>
<td>
<p>numeric matrix, dataframe or vector (in case of single spectrum)</p>
</td></tr>
<tr><td><code id="i_value_+3A_nbands">nbands</code></td>
<td>
<p>Integer of expected number of bands.
If NULL (default) checking is skipped.</p>
</td></tr>
<tr><td><code id="i_value_+3A_nsample">nsample</code></td>
<td>
<p>Integer of expected number of samples.
If NULL (default) checking is skipped.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Coerces input form different formats into data conformable to value,
which is a numeric matrix with no dimension names.
</p>


<h3>Value</h3>

<p>data conformable to relative value: numeric matrix
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>

<hr>
<h2 id='i_verify_path_and_format'>Internal function to verify file paths and format</h2><span id='topic+i_verify_path_and_format'></span>

<h3>Description</h3>

<p>Internal function to verify file paths and format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i_verify_path_and_format(
  path,
  format = NULL,
  exclude_if_matches = NULL,
  ignore_extension = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="i_verify_path_and_format_+3A_path">path</code></td>
<td>
<p>Path to directory or input files</p>
</td></tr>
<tr><td><code id="i_verify_path_and_format_+3A_format">format</code></td>
<td>
<p>File format. Defaults to NULL so spectrolab tries to guess it
from the file name. Alternatively, use &quot;asd&quot; for ASD; &quot;sig&quot;
for SVC (Spectra Vista); or &quot;sed&quot; for PSR (Spectral Evolution)</p>
</td></tr>
<tr><td><code id="i_verify_path_and_format_+3A_exclude_if_matches">exclude_if_matches</code></td>
<td>
<p>excludes files that match this regular expression.
Example: &quot;BAD&quot;</p>
</td></tr>
<tr><td><code id="i_verify_path_and_format_+3A_ignore_extension">ignore_extension</code></td>
<td>
<p>Boolean. If TRUE, the parser will try to read every
file in path regardless of the expected extension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing a vector of paths called 'i_path' and a char
with the file format called 'i_format'
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>

<hr>
<h2 id='is_spectra'>Is it a spectra object?</h2><span id='topic+is_spectra'></span>

<h3>Description</h3>

<p><code>is_spectra</code> tests if the argument is a spectra class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_spectra(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_spectra_+3A_x">x</code></td>
<td>
<p>any object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec  = as_spectra(spec_matrix_example, name_idx = 1)
spec1 = unclass(spec)
is_spectra(spec)
is_spectra(spec1)
</code></pre>

<hr>
<h2 id='make_fwhm'>Resample the FWHM to a new set of bands using a gaussian model</h2><span id='topic+make_fwhm'></span>

<h3>Description</h3>

<p>Resample the FWHM to a new set of bands using a gaussian model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_fwhm(spec, new_bands, new_fwhm = NULL, return_type = "max", k = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_fwhm_+3A_spec">spec</code></td>
<td>
<p>spectra object</p>
</td></tr>
<tr><td><code id="make_fwhm_+3A_new_bands">new_bands</code></td>
<td>
<p>band values to resample the spectra to</p>
</td></tr>
<tr><td><code id="make_fwhm_+3A_new_fwhm">new_fwhm</code></td>
<td>
<p>FWHM for the new bands</p>
</td></tr>
<tr><td><code id="make_fwhm_+3A_return_type">return_type</code></td>
<td>
<p>either &quot;max&quot; or &quot;old&quot;. If &quot;old&quot; (default), it returns the fwhm inferred from the original's spectra bands. If max (default), it returns the max between the new and old fwhm.</p>
</td></tr>
<tr><td><code id="make_fwhm_+3A_k">k</code></td>
<td>
<p>number of unique FHWM to estimate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>FWHM as a numeric vector
</p>

<hr>
<h2 id='match_sensors'>Match spectra at sensor transitions</h2><span id='topic+match_sensors'></span><span id='topic+match_sensors.spectra'></span>

<h3>Description</h3>

<p><code>match_sensors</code> scales values of sensors 1 (VIS) and 3 (SWIR 2)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_sensors(x, splice_at, fixed_sensor = 2, interpolate_wvl = c(5, 1))

## S3 method for class 'spectra'
match_sensors(x, splice_at, fixed_sensor = 2, interpolate_wvl = c(5, 2))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="match_sensors_+3A_x">x</code></td>
<td>
<p>spectra object</p>
</td></tr>
<tr><td><code id="match_sensors_+3A_splice_at">splice_at</code></td>
<td>
<p>bands that serve as splice points, i.e the beginnings
of the rightmost sensor. Must be length 1 or 2 (max 3 sensors)</p>
</td></tr>
<tr><td><code id="match_sensors_+3A_fixed_sensor">fixed_sensor</code></td>
<td>
<p>sensor to keep fixed. Can be 1 or 2 if matching 2 sensors.
If matching 3 sensors, 'fixed_sensor' must be 2 (default).</p>
</td></tr>
<tr><td><code id="match_sensors_+3A_interpolate_wvl">interpolate_wvl</code></td>
<td>
<p>extent around splice_at values over which the splicing
factors will be calculated. Defaults to 5</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Splice_at has no default because sensor transition points vary between vendors
and individual instruments.
The function <code>guess_splice_at</code> can help you guess what those values could
be. However, <code>splice_at</code> is an important parameter though, so you should
visually inspect your spectra before assigning it.
Typical values in our own individual instruments were:
SVC ~ c(990, 1900),
ASD ~ c(1001, 1801).
</p>
<p>If the factors used to match spectra are unreasonable, <code>match_sensors</code>
will throw. Unreasonable factors (f) are defined as 0.5 &gt; f &gt; 3 or NaN,
which happens when the value for the right sensor is 0.
</p>


<h3>Value</h3>

<p>spectra object
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>match_sensors(spectra)</code>: Match sensor overlap regions
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles and Anna Schweiger
</p>

<hr>
<h2 id='max.spectra'>Maximum value</h2><span id='topic+max.spectra'></span>

<h3>Description</h3>

<p><code>max</code> Returns the maximum value in a spectra object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spectra'
max(..., na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="max.spectra_+3A_...">...</code></td>
<td>
<p>spectra object</p>
</td></tr>
<tr><td><code id="max.spectra_+3A_na.rm">na.rm</code></td>
<td>
<p>boolean. remove NAs? Defaults to FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>single numeric value
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec = as_spectra(spec_matrix_example, name_idx = 1)
max(spec)
</code></pre>

<hr>
<h2 id='mean.spectra'>Mean spectrum</h2><span id='topic+mean.spectra'></span>

<h3>Description</h3>

<p><code>mean</code> computes the arithmetic mean spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spectra'
mean(x, na.rm = TRUE, keep_txt_meta = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean.spectra_+3A_x">x</code></td>
<td>
<p>spectra</p>
</td></tr>
<tr><td><code id="mean.spectra_+3A_na.rm">na.rm</code></td>
<td>
<p>boolean. remove NAs? Defaults to TRUE</p>
</td></tr>
<tr><td><code id="mean.spectra_+3A_keep_txt_meta">keep_txt_meta</code></td>
<td>
<p>try to keep text in the metadata</p>
</td></tr>
<tr><td><code id="mean.spectra_+3A_...">...</code></td>
<td>
<p>nothing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>single spectrum
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec = as_spectra(spec_matrix_example, name_idx = 1)
mean(spec)
</code></pre>

<hr>
<h2 id='median.spectra'>Median spectrum</h2><span id='topic+median.spectra'></span>

<h3>Description</h3>

<p><code>median</code> computes the median spectrum
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spectra'
median(x, na.rm = TRUE, keep_txt_meta = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="median.spectra_+3A_x">x</code></td>
<td>
<p>spectra</p>
</td></tr>
<tr><td><code id="median.spectra_+3A_na.rm">na.rm</code></td>
<td>
<p>boolean. remove NAs? Defaults to TRUE</p>
</td></tr>
<tr><td><code id="median.spectra_+3A_keep_txt_meta">keep_txt_meta</code></td>
<td>
<p>try to keep text in the metadata</p>
</td></tr>
<tr><td><code id="median.spectra_+3A_...">...</code></td>
<td>
<p>nothing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>single spectrum
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec = as_spectra(spec_matrix_example, name_idx = 1)
median(spec)
</code></pre>

<hr>
<h2 id='meta'>Get metadata</h2><span id='topic+meta'></span><span id='topic+meta.spectra'></span>

<h3>Description</h3>

<p><code>meta</code> returns metadata of spectra
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meta(x, label = NULL, sample = NULL, simplify = FALSE, quiet = TRUE)

## S3 method for class 'spectra'
meta(x, label = NULL, sample = NULL, simplify = FALSE, quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meta_+3A_x">x</code></td>
<td>
<p>spectra object</p>
</td></tr>
<tr><td><code id="meta_+3A_label">label</code></td>
<td>
<p>metadata column index or label</p>
</td></tr>
<tr><td><code id="meta_+3A_sample">sample</code></td>
<td>
<p>sample index or name</p>
</td></tr>
<tr><td><code id="meta_+3A_simplify">simplify</code></td>
<td>
<p>boolean. defaults to FALSE</p>
</td></tr>
<tr><td><code id="meta_+3A_quiet">quiet</code></td>
<td>
<p>boolean. warn about non-existent metadata? defaults to TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame or vector
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>meta(spectra)</code>: get metadata
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec = as_spectra(spec_matrix_example, name_idx = 1)
spec = normalize(spec)
meta(spec, "normalization_magnitude")
</code></pre>

<hr>
<h2 id='meta+26lt+3B-'>Set metadata</h2><span id='topic+meta+3C-'></span>

<h3>Description</h3>

<p><code>meta</code> sets metadata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meta(x, label = NULL, sample = NULL) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meta+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>spectra object (lhs)</p>
</td></tr>
<tr><td><code id="meta+2B26lt+2B3B-_+3A_label">label</code></td>
<td>
<p>metadata column label</p>
</td></tr>
<tr><td><code id="meta+2B26lt+2B3B-_+3A_sample">sample</code></td>
<td>
<p>sample name</p>
</td></tr>
<tr><td><code id="meta+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>rhs. TODO</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing. called for its side effect
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec = as_spectra(spec_matrix_example, name_idx = 1)
meta(spec, "random") = rnorm(nrow(spec), mean(10), sd = 2)
</code></pre>

<hr>
<h2 id='min.spectra'>Minimum value</h2><span id='topic+min.spectra'></span>

<h3>Description</h3>

<p><code>min</code> Returns the minimum  value in a spectra object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spectra'
min(..., na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="min.spectra_+3A_...">...</code></td>
<td>
<p>spectra object</p>
</td></tr>
<tr><td><code id="min.spectra_+3A_na.rm">na.rm</code></td>
<td>
<p>boolean. remove NAs? Defaults to FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>single numeric value
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec = as_spectra(spec_matrix_example, name_idx = 1)
min(spec)
</code></pre>

<hr>
<h2 id='names.spectra'>Get spectra sample names</h2><span id='topic+names.spectra'></span>

<h3>Description</h3>

<p><code>names</code> returns a vector of sample names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spectra'
names(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="names.spectra_+3A_x">x</code></td>
<td>
<p>spectra object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of sample names
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec = as_spectra(spec_matrix_example, name_idx = 1)
names(spec)
</code></pre>

<hr>
<h2 id='names+26lt+3B-.spectra'>Set spectra sample names</h2><span id='topic+names+3C-.spectra'></span>

<h3>Description</h3>

<p><code>names</code> assigns sample names to lhs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 replacement method for class 'spectra'
names(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="names+2B26lt+2B3B-.spectra_+3A_x">x</code></td>
<td>
<p>spectra object (lhs)</p>
</td></tr>
<tr><td><code id="names+2B26lt+2B3B-.spectra_+3A_value">value</code></td>
<td>
<p>values to be assigned (rhs)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing. called for its side effect.
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec = as_spectra(spec_matrix_example, name_idx = 1)
names(spec) = toupper(names(spec))
</code></pre>

<hr>
<h2 id='normalize'>Vector normalize spectra</h2><span id='topic+normalize'></span><span id='topic+normalize.spectra'></span>

<h3>Description</h3>

<p><code>normalize</code> returns a spectra obj with vector normalized values.
Normalization value for each spectrum computed as sqrt(sum(x^2))
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize(x, quiet = FALSE, ...)

## S3 method for class 'spectra'
normalize(x, quiet = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalize_+3A_x">x</code></td>
<td>
<p>spectra object. bands must be strictly increasing</p>
</td></tr>
<tr><td><code id="normalize_+3A_quiet">quiet</code></td>
<td>
<p>boolean. Warn about change in y value units? Defaults to FALSE</p>
</td></tr>
<tr><td><code id="normalize_+3A_...">...</code></td>
<td>
<p>nothing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>spectra object with normalized spectra
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>normalize(spectra)</code>: Vector normalize spectra
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec = as_spectra(spec_matrix_example, name_idx = 1)
spec = normalize(spec)
</code></pre>

<hr>
<h2 id='Ops.spectra'>Arithmetic operators for spectra</h2><span id='topic+Ops.spectra'></span>

<h3>Description</h3>

<p>Overloads arithmetic operators for spectra using 'Ops.'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spectra'
Ops(e1, e2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Ops.spectra_+3A_e1">e1</code></td>
<td>
<p>lhs</p>
</td></tr>
<tr><td><code id="Ops.spectra_+3A_e2">e2</code></td>
<td>
<p>rhs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depends on the operator. math operators will return spectra and logical
or comparison operators will return boolean matrices
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec  = as_spectra(spec_matrix_example, name_idx = 1)
spec1 = spec * 2
spec2 = spec + spec
all(spec1 == spec2)
</code></pre>

<hr>
<h2 id='pairwise_indices'>Pairwise indices</h2><span id='topic+pairwise_indices'></span>

<h3>Description</h3>

<p><code>pairwise_indices</code> computes pairwise spectral indices.
Indices are computed as (a - b) / (a + b) where a is the lower band.
The column names of the resulting matrix are given as &quot;a|b&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise_indices(x, max_out_elements = 5e+08)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairwise_indices_+3A_x">x</code></td>
<td>
<p>spectra</p>
</td></tr>
<tr><td><code id="pairwise_indices_+3A_max_out_elements">max_out_elements</code></td>
<td>
<p>maximum number of elements in the output object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list that includes the *indices* between bands a and b (column names a|b)
and the pairwise *band_combinations*
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec  = as_spectra(spec_matrix_example, name_idx = 1)

# Resampling spectra since a spectral dataset with 2,001 bands
# results in 2,001,000 unique spectral indices per sample
new_bands = seq(400, 2400, 10)
spec = resample(spec, new_bands, make_fwhm(spec, new_bands) )
p_idx = pairwise_indices(spec)

</code></pre>

<hr>
<h2 id='pairwise_ratio'>Pairwise value ratios</h2><span id='topic+pairwise_ratio'></span>

<h3>Description</h3>

<p><code>pairwise_ratio</code> computes pairwise ratios between bands
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise_ratio(x, simplify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairwise_ratio_+3A_x">x</code></td>
<td>
<p>spectra</p>
</td></tr>
<tr><td><code id="pairwise_ratio_+3A_simplify">simplify</code></td>
<td>
<p>coerce to matrix or keep result as list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list or matrix
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)

# Ratios of visible part of the spectrum
</code></pre>

<hr>
<h2 id='plot_interactive'>Plot spectra interactively</h2><span id='topic+plot_interactive'></span>

<h3>Description</h3>

<p>Interactively plots spectra with a shiny app. Useful to inspect large datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_interactive(
  spec,
  colpalette = function(n) RColorBrewer::brewer.pal(n, "Dark2"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_interactive_+3A_spec">spec</code></td>
<td>
<p>spectra object</p>
</td></tr>
<tr><td><code id="plot_interactive_+3A_colpalette">colpalette</code></td>
<td>
<p>a color palette function, e.g. rainbow, terrain.colors, or a
function returned by colorRampPalette() or colorRamps package</p>
</td></tr>
<tr><td><code id="plot_interactive_+3A_...">...</code></td>
<td>
<p>Other arguments passed to plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot_interact</code> limits the number of spectra displayed at once to 600 for
performance reasons. As of now, the function does not return anything and does
not have side effects. This means that spectra can be selected and highlighted
but not yet deleted or subset from the shiny app.
</p>


<h3>Value</h3>

<p>interactive plot
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles and Anna K. Schweiger
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
# Create a spectra object
spec = as_spectra(spec_matrix_example, name_idx = 1)

# Start interactive plot
plot_interactive(spec)
}
</code></pre>

<hr>
<h2 id='plot_quantile'>Plot spectra quantiles</h2><span id='topic+plot_quantile'></span>

<h3>Description</h3>

<p><code>plot_quantile</code> plots polygons for the quantiles of spectra per band.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_quantile(
  spec,
  total_prob = 0.95,
  col = rgb(0, 0, 0, 0.1),
  border = TRUE,
  add = FALSE,
  na.rm = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_quantile_+3A_spec">spec</code></td>
<td>
<p>spectra object</p>
</td></tr>
<tr><td><code id="plot_quantile_+3A_total_prob">total_prob</code></td>
<td>
<p>total probability mass to encompass. Single number
between 0.0 and 1.0. Defaults to 0.95.</p>
</td></tr>
<tr><td><code id="plot_quantile_+3A_col">col</code></td>
<td>
<p>polygon color</p>
</td></tr>
<tr><td><code id="plot_quantile_+3A_border">border</code></td>
<td>
<p>boolean. Draw border?</p>
</td></tr>
<tr><td><code id="plot_quantile_+3A_add">add</code></td>
<td>
<p>if add = FALSE (default), a new plot is created. Otherwise
(add = TRUE), the quantile is added to the current plot.</p>
</td></tr>
<tr><td><code id="plot_quantile_+3A_na.rm">na.rm</code></td>
<td>
<p>boolean. remove NAs to compute quantiles? Defaults to TRUE</p>
</td></tr>
<tr><td><code id="plot_quantile_+3A_...">...</code></td>
<td>
<p>other parameters passed to polygon() or to plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing. Called for its side effect.
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec  = as_spectra(spec_matrix_example, name_idx = 1)
plot_quantile(spec, total_prob = 0.5)
</code></pre>

<hr>
<h2 id='plot_regions'>Plot polygons for spectral regions</h2><span id='topic+plot_regions'></span>

<h3>Description</h3>

<p><code>plot_regions</code> plots polygons for default (VIS, NIR, SWIR 1, SWIR 2) or customized regions of the spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_regions(
  spec,
  regions = default_spec_regions(),
  col = grDevices::rgb(0.7, 0.7, 0.7, 0.3),
  border = FALSE,
  add = TRUE,
  add_label = TRUE,
  cex_label = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_regions_+3A_spec">spec</code></td>
<td>
<p>spectra object</p>
</td></tr>
<tr><td><code id="plot_regions_+3A_regions">regions</code></td>
<td>
<p>matrix with spectral regions in columns and only two rows named
&quot;begin&quot; and &quot;end&quot;. Values are the bands where a spectral
regions begins and ends. See details for how the default regions are defined.</p>
</td></tr>
<tr><td><code id="plot_regions_+3A_col">col</code></td>
<td>
<p>color for regions. Single value or vector of length ncol (regions).</p>
</td></tr>
<tr><td><code id="plot_regions_+3A_border">border</code></td>
<td>
<p>color for region borders. Defaults to FALSE (no border).</p>
</td></tr>
<tr><td><code id="plot_regions_+3A_add">add</code></td>
<td>
<p>boolean. If TRUE (default) adds polygons to current plot (if a plot
exists) or throws an error if a plot does not exist.
If FALSE, a new plot is created **without** any spectra.</p>
</td></tr>
<tr><td><code id="plot_regions_+3A_add_label">add_label</code></td>
<td>
<p>boolean. Add region column names on top of the polygons?</p>
</td></tr>
<tr><td><code id="plot_regions_+3A_cex_label">cex_label</code></td>
<td>
<p>label scale</p>
</td></tr>
<tr><td><code id="plot_regions_+3A_...">...</code></td>
<td>
<p>additional parameters passed to polygon().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Default regions:
spec_regions = cbind(&quot;VIS&quot;   = c(begin = 400,  end = 700),
&quot;NIR&quot;   = c(begin = 800,  end = 1300),
&quot;SWIR1&quot; = c(begin = 1550, end = 1800),
&quot;SWIR2&quot; = c(begin = 2000, end = 2400)).
</p>


<h3>Value</h3>

<p>nothing. Called for its side effect.
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec = as_spectra(spec_matrix_example, name_idx = 1)
plot_regions(spec, default_spec_regions())
plot(spec, add = TRUE)

# Alternatively, if you want to get fancy...
col_fun = colorRampPalette(c(rgb(1, 1, 0, 0.7),rgb(1, 0, 0, 0.7)), alpha = TRUE)
colors = col_fun(4)

plot_regions(spec,default_spec_regions(), col = colors)
plot(spec, add = TRUE)

</code></pre>

<hr>
<h2 id='plot.spectra'>Plot spectra</h2><span id='topic+plot.spectra'></span>

<h3>Description</h3>

<p><code>plot</code> plots spectra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spectra'
plot(x, ylab = "value", xlab = "band", col = "black", lty = 1, type = "l", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.spectra_+3A_x">x</code></td>
<td>
<p>spectra object</p>
</td></tr>
<tr><td><code id="plot.spectra_+3A_ylab">ylab</code></td>
<td>
<p>label for y axis. Defaults to &quot;value&quot;.</p>
</td></tr>
<tr><td><code id="plot.spectra_+3A_xlab">xlab</code></td>
<td>
<p>label for x axis. Defaults to &quot;band&quot;.</p>
</td></tr>
<tr><td><code id="plot.spectra_+3A_col">col</code></td>
<td>
<p>line color. Defaults to &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="plot.spectra_+3A_lty">lty</code></td>
<td>
<p>line type. Defaults to 1.</p>
</td></tr>
<tr><td><code id="plot.spectra_+3A_type">type</code></td>
<td>
<p>type of plot. Meant to take either line &quot;l&quot; or no plotting &quot;n&quot;.</p>
</td></tr>
<tr><td><code id="plot.spectra_+3A_...">...</code></td>
<td>
<p>other arguments passed to matplot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing. Called for side effect.
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec  = as_spectra(spec_matrix_example, name_idx = 1)
plot(spec, lwd = 1.2)
</code></pre>

<hr>
<h2 id='print.spectra'>Print spectra</h2><span id='topic+print.spectra'></span>

<h3>Description</h3>

<p><code>print</code> prints basic information about the spectra obj to the console
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spectra'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.spectra_+3A_x">x</code></td>
<td>
<p>spectra object</p>
</td></tr>
<tr><td><code id="print.spectra_+3A_...">...</code></td>
<td>
<p>other arguments passed to print. not implemented for spectra</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing. called for side effect
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec = as_spectra(spec_matrix_example, name_idx = 1)
print(spec)
## or simply
spec
</code></pre>

<hr>
<h2 id='quantile.spectra'>Compute spectra quantiles</h2><span id='topic+quantile.spectra'></span>

<h3>Description</h3>

<p><code>quantile</code> computes quantiles by band and returns them as 'spectra'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spectra'
quantile(
  x,
  probs = c(0.025, 0.25, 0.5, 0.75, 0.975),
  na.rm = TRUE,
  names = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quantile.spectra_+3A_x">x</code></td>
<td>
<p>spectra object. Must have at least the same number of sample that
length(probs) has.</p>
</td></tr>
<tr><td><code id="quantile.spectra_+3A_probs">probs</code></td>
<td>
<p>Probabilities to compute quantiles. Must be a vector of numerics
between 0.0 and 1.0. Defaults to c(0.025, 0.25, 0.5, 0.75, 0.975).
Duplicated probs will be removed.</p>
</td></tr>
<tr><td><code id="quantile.spectra_+3A_na.rm">na.rm</code></td>
<td>
<p>remove NAs before computing quantiles? Defaults to TRUE</p>
</td></tr>
<tr><td><code id="quantile.spectra_+3A_names">names</code></td>
<td>
<p>names for each quantile spectrum. If NULL (default), names are set
to 'probs'. A char vector should otherwise be given. Recycled.</p>
</td></tr>
<tr><td><code id="quantile.spectra_+3A_...">...</code></td>
<td>
<p>other arguments passed to quantile.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>spectra object with one spectrum for each prob
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec = as_spectra(spec_matrix_example, name_idx = 1)
quantile(spec, probs = c(0.25, 0.75))
</code></pre>

<hr>
<h2 id='range.spectra'>Range of spectral values</h2><span id='topic+range.spectra'></span>

<h3>Description</h3>

<p><code>range</code> Returns the range of (min, max) values in spectra
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spectra'
range(..., na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="range.spectra_+3A_...">...</code></td>
<td>
<p>spectra object</p>
</td></tr>
<tr><td><code id="range.spectra_+3A_na.rm">na.rm</code></td>
<td>
<p>boolean. remove NAs? Defaults to FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tuple of numeric values (min, max)
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spectrolab)
spec = as_spectra(spec_matrix_example, name_idx = 1)
range(spec)
</code></pre>

<hr>
<h2 id='read_spectra'>Read files from various formats into 'spectra'</h2><span id='topic+read_spectra'></span>

<h3>Description</h3>

<p>Read files from various formats into 'spectra'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_spectra(
  path,
  format = NULL,
  type = "target_reflectance",
  extract_metadata = FALSE,
  exclude_if_matches = NULL,
  ignore_extension = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_spectra_+3A_path">path</code></td>
<td>
<p>Path to directory or input files.</p>
</td></tr>
<tr><td><code id="read_spectra_+3A_format">format</code></td>
<td>
<p>File format. Defaults to NULL so spectrolab tries to guess it
from the file name. Alternatively, use &quot;asd&quot; for ASD; &quot;sig&quot;
for SVC (Spectra Vista); or &quot;sed&quot; for PSR (Spectral Evolution)</p>
</td></tr>
<tr><td><code id="read_spectra_+3A_type">type</code></td>
<td>
<p>Data type to read. &quot;target_reflectance&quot;, &quot;target_radiance&quot;, or
&quot;reference_radiance&quot;. Defaults to &quot;target_reflectance&quot;.</p>
</td></tr>
<tr><td><code id="read_spectra_+3A_extract_metadata">extract_metadata</code></td>
<td>
<p>Boolean. Defaults to FALSE. Only implemented for the
Spectra Vista (.sig) and Spectral Evolution (.sed)
file types.</p>
</td></tr>
<tr><td><code id="read_spectra_+3A_exclude_if_matches">exclude_if_matches</code></td>
<td>
<p>excludes files that match this regular expression.
Example: &quot;BAD&quot;</p>
</td></tr>
<tr><td><code id="read_spectra_+3A_ignore_extension">ignore_extension</code></td>
<td>
<p>Boolean. If TRUE, the parser will try to read every
file in path regardless of the expected extension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a single 'spectra' or a list of 'spectra' (in case files have
incompatible band number or bands values)
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
dir_path = system.file("extdata", "Acer_example", package = "spectrolab")

spec     = read_spectra(path = dir_path, format = "sig")
</code></pre>

<hr>
<h2 id='resample'>Resample spectra</h2><span id='topic+resample'></span>

<h3>Description</h3>

<p>Resample spectra
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample(spec, new_bands, fwhm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resample_+3A_spec">spec</code></td>
<td>
<p>spectra object</p>
</td></tr>
<tr><td><code id="resample_+3A_new_bands">new_bands</code></td>
<td>
<p>band values to resample the spectra to</p>
</td></tr>
<tr><td><code id="resample_+3A_fwhm">fwhm</code></td>
<td>
<p>FWHM for the new bands</p>
</td></tr>
</table>


<h3>Value</h3>

<p>resampled spectra
</p>

<hr>
<h2 id='sd'>Standard deviation</h2><span id='topic+sd'></span>

<h3>Description</h3>

<p><code>sd</code> computes the standard deviation spectrum. Note that values will not
reflect value anymore, but the sd of the value instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sd_+3A_x">x</code></td>
<td>
<p>a numeric vector or an R object which is coercible to one by as.double(x)</p>
</td></tr>
<tr><td><code id="sd_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values be removed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>standard deviation
</p>

<hr>
<h2 id='sd.default'>Default standard deviation</h2><span id='topic+sd.default'></span>

<h3>Description</h3>

<p><code>sd</code> computes the standard deviation of the values in x. If na.rm is TRUE then missing values are removed before computation proceeds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
sd(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sd.default_+3A_x">x</code></td>
<td>
<p>a numeric vector or an R object which is coercible to one by as.double(x)</p>
</td></tr>
<tr><td><code id="sd.default_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values be removed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>standard deviation of x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = rnorm(n = 200, mean = 0, sd = 1)
sd(x)

</code></pre>

<hr>
<h2 id='sd.spectra'>Standard deviation spectrum</h2><span id='topic+sd.spectra'></span>

<h3>Description</h3>

<p>Forces keep_txt_meta = TRUE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spectra'
sd(x, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sd.spectra_+3A_x">x</code></td>
<td>
<p>spectra</p>
</td></tr>
<tr><td><code id="sd.spectra_+3A_na.rm">na.rm</code></td>
<td>
<p>boolean. remove NAs?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>single spectrum
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec = as_spectra(spec_matrix_example, name_idx = 1)
sd(spec)
</code></pre>

<hr>
<h2 id='smooth'>Generic Smoothing function</h2><span id='topic+smooth'></span>

<h3>Description</h3>

<p>Generic Smoothing function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth_+3A_x">x</code></td>
<td>
<p>data to smooth over</p>
</td></tr>
<tr><td><code id="smooth_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>smoothed data
</p>

<hr>
<h2 id='smooth_fwhm'>Smooth spectra with a gaussian model</h2><span id='topic+smooth_fwhm'></span>

<h3>Description</h3>

<p>Smooth spectra with a gaussian model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_fwhm(x, fwhm = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth_fwhm_+3A_x">x</code></td>
<td>
<p>spectra</p>
</td></tr>
<tr><td><code id="smooth_fwhm_+3A_fwhm">fwhm</code></td>
<td>
<p>Full Width at Half Maximum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>smoothed spectra
</p>

<hr>
<h2 id='smooth_moving_avg'>Smooth moving average for spectra</h2><span id='topic+smooth_moving_avg'></span>

<h3>Description</h3>

<p>Smooth moving average for spectra
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_moving_avg(x, n = NULL, save_bands_to_meta = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth_moving_avg_+3A_x">x</code></td>
<td>
<p>spectra object</p>
</td></tr>
<tr><td><code id="smooth_moving_avg_+3A_n">n</code></td>
<td>
<p>= NULL</p>
</td></tr>
<tr><td><code id="smooth_moving_avg_+3A_save_bands_to_meta">save_bands_to_meta</code></td>
<td>
<p>boolean. keep lost ends of original wvls in metadata</p>
</td></tr>
</table>


<h3>Value</h3>

<p>spectra object
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>

<hr>
<h2 id='smooth_spline'>Smooth spline functions for spectra</h2><span id='topic+smooth_spline'></span>

<h3>Description</h3>

<p>Gets spline functions for each spectrum in a spectra object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_spline(x, parallel = TRUE, return_fn = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth_spline_+3A_x">x</code></td>
<td>
<p>spectra object. bands must be strictly increasing</p>
</td></tr>
<tr><td><code id="smooth_spline_+3A_parallel">parallel</code></td>
<td>
<p>boolean. Do computation in parallel? Defaults to TRUE.
Unfortunately, the parallelization does not work on Windows.</p>
</td></tr>
<tr><td><code id="smooth_spline_+3A_return_fn">return_fn</code></td>
<td>
<p>Boolean. If TRUE, <code>smooth_spline</code> returns the spline
functions instead of the smoothed spectra. Defaults to FALSE</p>
</td></tr>
<tr><td><code id="smooth_spline_+3A_...">...</code></td>
<td>
<p>additional parameters passed to smooth.spline except nknots, which
is computed internally</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Smoothed spectra or, if return_fn = TRUE, a list of spline functions.
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>

<hr>
<h2 id='smooth.default'>Default smoothing function</h2><span id='topic+smooth.default'></span>

<h3>Description</h3>

<p>Default smoothing function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
smooth(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth.default_+3A_x">x</code></td>
<td>
<p>data to smooth over</p>
</td></tr>
<tr><td><code id="smooth.default_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>smoothed data
</p>

<hr>
<h2 id='smooth.spectra'>Smooth spectra</h2><span id='topic+smooth.spectra'></span>

<h3>Description</h3>

<p><code>smooth</code> runs each spectrum by a smoothing and returns the spectra
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spectra'
smooth(x, method = "gaussian", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth.spectra_+3A_x">x</code></td>
<td>
<p>spectra object. bands must be strictly increasing</p>
</td></tr>
<tr><td><code id="smooth.spectra_+3A_method">method</code></td>
<td>
<p>Choose smoothing method: &quot;gaussian&quot; (default), &quot;spline&quot;, or &quot;moving_average&quot;</p>
</td></tr>
<tr><td><code id="smooth.spectra_+3A_...">...</code></td>
<td>
<p>additional parameters passed to methods <code>smooth_fwhm</code>, <code>smooth_spline</code>, <code>smooth_moving_avg</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a spectra object of with smoothed spectra
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)

spec = as_spectra(spec_matrix_example, name_idx = 1)
spec = smooth(spec)
</code></pre>

<hr>
<h2 id='spec_matrix_example'>Example spectral dataset</h2><span id='topic+spec_matrix_example'></span>

<h3>Description</h3>

<p>Simulated spectral dataset as a matrix. First column hold species names and
the remaining ones store the spectra values. band labels are given as
column names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spec_matrix_example
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 50 rows and 2102 columns.
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>

<hr>
<h2 id='spectra'>Spectra object constructor</h2><span id='topic+spectra'></span>

<h3>Description</h3>

<p><code>spectra</code> &quot;manually&quot; creates a spectra object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectra(value, bands, names, meta = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spectra_+3A_value">value</code></td>
<td>
<p>N by M numeric matrix. N samples in rows and M bands
in columns</p>
</td></tr>
<tr><td><code id="spectra_+3A_bands">bands</code></td>
<td>
<p>band names in vector of length M</p>
</td></tr>
<tr><td><code id="spectra_+3A_names">names</code></td>
<td>
<p>sample names in vector of length N</p>
</td></tr>
<tr><td><code id="spectra_+3A_meta">meta</code></td>
<td>
<p>spectra metadata. defaults to NULL. Must be either of length or nrow
equals to the number of samples (nrow(value) or length(names))</p>
</td></tr>
<tr><td><code id="spectra_+3A_...">...</code></td>
<td>
<p>additional arguments to metadata creation. not implemented yet</p>
</td></tr>
</table>


<h3>Value</h3>

<p>spectra object
</p>


<h3>Note</h3>

<p>This function resorts to an ugly hack to deal with metadata assignment.
Need to think a little harder to find a solution.
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
# 1. Create a value matrix.
#    In this case, by removing the first column that holds the species name
rf = spec_matrix_example[ , -1]

# (2) Create a vector with band labels that match
#     the value matrix columns.
wl = colnames(rf)

# (3) Create a vector with sample labels that match
#     the value matrix rows.
#     In this case, use the first colum of spec_matrix_example
sn = spec_matrix_example[ , 1]

# Finally, construct the spectra object using the `spectra` constructor
spec = spectra(value = rf, bands = wl, names = sn)
</code></pre>

<hr>
<h2 id='split.spectra'>Split spectra</h2><span id='topic+split.spectra'></span>

<h3>Description</h3>

<p><code>split</code> a spectra object into a list of spectra according to grouping f.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spectra'
split(x, f, drop = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split.spectra_+3A_x">x</code></td>
<td>
<p>spectra object</p>
</td></tr>
<tr><td><code id="split.spectra_+3A_f">f</code></td>
<td>
<p>factor vector defining the grouping. Must have length nrow(x)</p>
</td></tr>
<tr><td><code id="split.spectra_+3A_drop">drop</code></td>
<td>
<p>NOT used</p>
</td></tr>
<tr><td><code id="split.spectra_+3A_...">...</code></td>
<td>
<p>NOT used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of spectra
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec = as_spectra(spec_matrix_example, name_idx = 1)
spec_list = split(spec, names(spec))
</code></pre>

<hr>
<h2 id='str.spectra'>Structure of the spectra object</h2><span id='topic+str.spectra'></span>

<h3>Description</h3>

<p>Structure of the spectra object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spectra'
str(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="str.spectra_+3A_object">object</code></td>
<td>
<p>spectra object</p>
</td></tr>
<tr><td><code id="str.spectra_+3A_...">...</code></td>
<td>
<p>additional args. not implemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prints to console
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec = as_spectra(spec_matrix_example, name_idx = 1)
str(spec)
</code></pre>

<hr>
<h2 id='subset_by'>Subset spectra by factor</h2><span id='topic+subset_by'></span><span id='topic+subset_by.spectra'></span>

<h3>Description</h3>

<p><code>subset_by</code> subsets spectra by a factor 'by' ensuring that it appears at
most 'n_max' times **and** at least 'n_min' times in the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_by(x, by, n_min, n_max, random = TRUE)

## S3 method for class 'spectra'
subset_by(x, by, n_min, n_max, random = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subset_by_+3A_x">x</code></td>
<td>
<p>spectra object</p>
</td></tr>
<tr><td><code id="subset_by_+3A_by">by</code></td>
<td>
<p>vector coercible to factor and of same length as nrow(x)</p>
</td></tr>
<tr><td><code id="subset_by_+3A_n_min">n_min</code></td>
<td>
<p>int. only keep spectra with at least (inclusive) 'n_min' number
of samples per unique 'by'.</p>
</td></tr>
<tr><td><code id="subset_by_+3A_n_max">n_max</code></td>
<td>
<p>int. keep at most (incl) this number of spectra per unique 'by'</p>
</td></tr>
<tr><td><code id="subset_by_+3A_random">random</code></td>
<td>
<p>boolean. Sample randomly or keep first n_max? Defaults to TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>subset_by</code> forces you to provide both a minimum and a maximum
number of spectra to be kept for each unique value of &lsquo;by'. In case you&rsquo;re
interested in subsetting <em>only</em> based on 'n_min', set 'n_max' to 'Inf'.
</p>


<h3>Value</h3>

<p>spectra
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>subset_by(spectra)</code>: Subset spectra by factor
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec = as_spectra(spec_matrix_example, name_idx = 1)

# remove spec of species with less than 4 samples
spec = subset_by(spec, by = names(spec), n_min = 4, n_max = Inf)
</code></pre>

<hr>
<h2 id='summary.spectra'>Summarize spectra</h2><span id='topic+summary.spectra'></span>

<h3>Description</h3>

<p>Summarize spectra
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spectra'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.spectra_+3A_object">object</code></td>
<td>
<p>spectra object</p>
</td></tr>
<tr><td><code id="summary.spectra_+3A_...">...</code></td>
<td>
<p>additional params to summary. not used yet</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing yet (just prints to console)
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec = as_spectra(spec_matrix_example, name_idx = 1)
summary(spec)
</code></pre>

<hr>
<h2 id='t.spectra'>Spectra Transpose</h2><span id='topic+t.spectra'></span>

<h3>Description</h3>

<p>spectra are not transposable. Transpose the value instead
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spectra'
t(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="t.spectra_+3A_x">x</code></td>
<td>
<p>spectra</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Operation not allowed
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
s = as_spectra(spec_matrix_example, name_idx = 1)

t(value(s))
t(as.matrix(s))
</code></pre>

<hr>
<h2 id='try_keep_txt'>Wrap function to try to keep text</h2><span id='topic+try_keep_txt'></span>

<h3>Description</h3>

<p>Function operator returning a function f that tries to keep text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>try_keep_txt(f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="try_keep_txt_+3A_f">f</code></td>
<td>
<p>function to be applied</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>try_keep_txt</code> takes a function f as argument, typically a mathematical
operation such as mean, median, etc. and returns a modified version of it that
will try return a string of unique values in case function f emits a warning.
Useful when aggregating over spectral metadata that has both numeric values
(which you want to aggregate) and text values, which you want to keep.
</p>


<h3>Value</h3>

<p>modified function f (f').
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
g = try_keep_txt(mean)
g(c(1, 2))
g(c("a", "b"))
</code></pre>

<hr>
<h2 id='value'>Get spectra value</h2><span id='topic+value'></span><span id='topic+value.spectra'></span>

<h3>Description</h3>

<p><code>value</code> returns the value matrix from spectra
</p>


<h3>Usage</h3>

<pre><code class='language-R'>value(x)

## S3 method for class 'spectra'
value(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="value_+3A_x">x</code></td>
<td>
<p>spectra object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with samples in rows and bands in columns
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>value(spectra)</code>: Get spectra value
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec = as_spectra(spec_matrix_example, name_idx = 1)
is.matrix(value(spec))
</code></pre>

<hr>
<h2 id='value+26lt+3B-'>Set spectra value</h2><span id='topic+value+3C-'></span>

<h3>Description</h3>

<p><code>value&lt;-</code> Assigns the rhs to the value of the lhs spectra obj
</p>


<h3>Usage</h3>

<pre><code class='language-R'>value(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="value+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>spectra object</p>
</td></tr>
<tr><td><code id="value+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>value to be assigned to the lhs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing. called for its side effect
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec = as_spectra(spec_matrix_example, name_idx = 1)
# scale all refletance values by 2
value(spec) = value(spec) * 2
</code></pre>

<hr>
<h2 id='var'>Variance</h2><span id='topic+var'></span>

<h3>Description</h3>

<p><code>var</code> computes the variance spectrum. Note that values will not reflect
value anymore, but the variance of the value instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var(x, y = NULL, na.rm = FALSE, use)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var_+3A_x">x</code></td>
<td>
<p>a numeric vector, matrix or data frame</p>
</td></tr>
<tr><td><code id="var_+3A_y">y</code></td>
<td>
<p>NULL (default) or a vector, matrix or data frame with compatible
dimensions to x.</p>
</td></tr>
<tr><td><code id="var_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values be removed?</p>
</td></tr>
<tr><td><code id="var_+3A_use">use</code></td>
<td>
<p>an optional character string giving a method for computing covariances in
the presence of missing values. This must be (an abbreviation of) one of
the strings &quot;everything&quot;, &quot;all.obs&quot;, &quot;complete.obs&quot;, &quot;na.or.complete&quot;,
or &quot;pairwise.complete.obs&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>variance
</p>

<hr>
<h2 id='var.default'>Variance</h2><span id='topic+var.default'></span>

<h3>Description</h3>

<p><code>var</code> computes the variance spectrum. Note that values will not reflect
value anymore, but the variance of the value instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
var(x, y = NULL, na.rm = FALSE, use)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var.default_+3A_x">x</code></td>
<td>
<p>a numeric vector, matrix or data frame</p>
</td></tr>
<tr><td><code id="var.default_+3A_y">y</code></td>
<td>
<p>NULL (default) or a vector, matrix or data frame with compatible
dimensions to x.</p>
</td></tr>
<tr><td><code id="var.default_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values be removed?</p>
</td></tr>
<tr><td><code id="var.default_+3A_use">use</code></td>
<td>
<p>an optional character string giving a method for computing covariances in
the presence of missing values. This must be (an abbreviation of) one of
the strings &quot;everything&quot;, &quot;all.obs&quot;, &quot;complete.obs&quot;, &quot;na.or.complete&quot;,
or &quot;pairwise.complete.obs&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>variance
</p>

<hr>
<h2 id='var.spectra'>Variance spectrum</h2><span id='topic+var.spectra'></span>

<h3>Description</h3>

<p>Forces keep_txt_meta = TRUE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spectra'
var(x, y = NULL, na.rm = TRUE, use)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var.spectra_+3A_x">x</code></td>
<td>
<p>spectra</p>
</td></tr>
<tr><td><code id="var.spectra_+3A_y">y</code></td>
<td>
<p>nothing</p>
</td></tr>
<tr><td><code id="var.spectra_+3A_na.rm">na.rm</code></td>
<td>
<p>boolean. remove NAs?</p>
</td></tr>
<tr><td><code id="var.spectra_+3A_use">use</code></td>
<td>
<p>nothing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>single spectrum
</p>


<h3>Author(s)</h3>

<p>Jose Eduardo Meireles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectrolab)
spec = as_spectra(spec_matrix_example, name_idx = 1)
var(spec)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
