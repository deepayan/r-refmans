<!DOCTYPE html><html><head><title>Help for package tsapp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tsapp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ACCIDENT'><p>Monthly numbers of road traffic accidents with personal injury in BRD</p></a></li>
<li><a href='#acfmat'><p><code>acfmat</code> computes a sequence of autocorrelation matrices for a multivariate time series</p></a></li>
<li><a href='#acfpacf'><p><code>acfpacf</code> produces a plot of the acf and the pacf of a time series</p></a></li>
<li><a href='#ALCINCOME'><p>Alcohol Demand, UK, 1870-1938.</p></a></li>
<li><a href='#armathspec'><p><code>armathspec</code> determines the theoretical spectrum of an arma process</p></a></li>
<li><a href='#aspectratio'><p><code>aspectratio</code>  determines the aspect ratio to plot a time series</p></a></li>
<li><a href='#bandfilt'><p><code>bandfilt</code> does a bandpass filtering of a time series</p></a></li>
<li><a href='#BEER'><p>Monthly beer production in Australia: megalitres. Includes ale and stout. Does not include beverages with alcohol percentage less than 1.15.</p></a></li>
<li><a href='#bispeces'><p><code>bispeces</code> performs indirect bivariate spectral estimation of two series y1, y2 using lagwindows</p></a></li>
<li><a href='#BLACKOUT'><p>Weekly number of births in New York</p></a></li>
<li><a href='#BoxCox'><p><code>BoxCox</code> determines the power of a Box-Cox transformation to stabilize the variance of a time series</p></a></li>
<li><a href='#COFFEE'><p>U.S. annual coffee consumption</p></a></li>
<li><a href='#DAX'><p>Market value of DAX</p></a></li>
<li><a href='#DIABETES'><p>Incidences of insulin-dependent diabetes mellitus</p></a></li>
<li><a href='#DOMINANCE'><p>Running yield of public bonds in Austria and Germany</p></a></li>
<li><a href='#dynspecest'><p><code>dynspecest</code>  performs a dynamic  spectrum estimation</p></a></li>
<li><a href='#ENGINES'><p>ENGINES is an alias for MACHINES</p></a></li>
<li><a href='#FINANCE'><p>Portfolio-Insurance-Strategies</p></a></li>
<li><a href='#GDP'><p>Germany's gross domestic product adjusted for price changes</p></a></li>
<li><a href='#GDPORIG'><p>Germany's gross domestic product, values of Laspeyres index to base 2000</p></a></li>
<li><a href='#Grangercaus'><p><code>Grangercaus</code>  determines three values of BIC from a twodimensional VAR process</p></a></li>
<li><a href='#HAC'><p>HAC Covariance Matrix Estimation</p>
<code>HAC</code>  computes the central quantity (the meat) in the HAC covariance matrix estimator, also called
sandwich estimator. HAC is the abbreviation for &quot;heteroskedasticity and autocorrelation consistent&quot;.</a></li>
<li><a href='#HEARTBEAT'><p>Cardiac frequency of a patient</p></a></li>
<li><a href='#HSV'><p>HSV's position in the first German soccer league</p></a></li>
<li><a href='#IBM'><p>IBM's stock price</p></a></li>
<li><a href='#ICECREAM'><p>Temperature and consumption of ice cream</p></a></li>
<li><a href='#init_values'><p><code>init_values</code> is an auxiliary function for rlassoHAC, for fitting linear models with</p>
the method of least squares where only the variables in X with highest correlations
are considered; taken from package hdm.</a></li>
<li><a href='#INORDER'><p>Income orders of a company</p></a></li>
<li><a href='#interpol'><p><code>interpol</code> help function for missls</p></a></li>
<li><a href='#kweightsHAC'><p><code>kweightsHAC</code>  help function for HAC</p></a></li>
<li><a href='#L921'><p>Subsoil water level and precipitation at pilot well L921</p></a></li>
<li><a href='#lagwinba'><p><code>lagwinba</code> Bartlett's Lag-window for indirect spectrum estimation</p></a></li>
<li><a href='#lagwinpa'><p><code>lagwinpa</code> Parzen's Lag-window for indirect spectrum estimation</p></a></li>
<li><a href='#lagwintu'><p><code>lagwintu</code> Tukey's Lag-window for indirect spectrum estimation</p></a></li>
<li><a href='#lambdaCalculationHAC'><p><code>lambdaCalculationHAC</code> is an auxiliary function for rlassoHAC; it calculates the penalty parameters.</p></a></li>
<li><a href='#lambdaCalculationLoad'><p><code>lambdaCalculationLoad</code> is an auxiliary function for rlassoLoad; it calculates the penalty parameters</p>
with predefined loadings.</a></li>
<li><a href='#ldrec'><p><code>ldrec</code> does Levinson-Durbin recursion for determing all coefficients a(i,j)</p></a></li>
<li><a href='#LITH'><p>Daily subsoil water level and precipitation at pilot well Lith</p></a></li>
<li><a href='#LjungBoxPierceTest'><p><code>LjungBoxPierceTest</code> determines the test statistic and p values for several lags  for a residual series</p></a></li>
<li><a href='#LUHORMONE'><p>Level of Luteinzing hormone of a cow</p></a></li>
<li><a href='#LYNX'><p>Annual lynx trappings in a region of North-West Canada. Taken from Andrews and Herzberg (1985).</p></a></li>
<li><a href='#LYNXHARE'><p>Size of populations of lynxes and snow hares</p></a></li>
<li><a href='#MACHINES'><p>Number of incoming orders for machines</p></a></li>
<li><a href='#MAUNALOA'><p>Atmospheric CO2 concentrations (ppmv) derived from in situ air samples collected at Mauna Loa Observatory, Hawaii</p></a></li>
<li><a href='#MDAX'><p>Stock market price of MDAX</p></a></li>
<li><a href='#MELANOM'><p>Melanoma incidence in Connecticut</p></a></li>
<li><a href='#mfraccheck'><p>multifractal check</p>
<code>mfraccheck</code>  computes the absolute empirical moments of the differenced series for various lags
and moment orders. E.g. for lag = 3 and moment order = 1 the average absolute value of
the differences with lag 3 will be computed. By default, the maximum lag is determined
so that the differenced series contains at lest 50 observations.</a></li>
<li><a href='#missar'><p><code>missar</code> Substitution of missing values in a time series by</p>
conditional  exspectations of AR(p) models</a></li>
<li><a href='#missls'><p><code>missls</code> substitutes missing values in a time series using the LS approach with ARMA models</p></a></li>
<li><a href='#moveav'><p><code>moveav</code> smoothes a time series by moving averages</p></a></li>
<li><a href='#movemed'><p><code>movemed</code> smoothes a time series by moving medians</p></a></li>
<li><a href='#MUSKRAT'><p>Annual trade of muskrat pelts</p></a></li>
<li><a href='#NIKKEI'><p>Daily values of the Japanese stock market index Nikkei 225 between 02.02.2000 and 20.10.2020</p></a></li>
<li><a href='#outidentify'><p><code>outidentify</code> performs one iteration of Wei's iterative procedure to identify impact, locations and type</p>
of outliers in arma processes</a></li>
<li><a href='#OXYGEN'><p>Amount of an Oxygen isotope</p></a></li>
<li><a href='#pacfmat'><p><code>pacfmat</code> sequence of partial autocorrelation matrices and related statistics for a multivariate time series</p></a></li>
<li><a href='#PAPER'><p>Two measurements at a paper machine</p></a></li>
<li><a href='#periodogram'><p><code>periodogram</code> determines the periodogram of a time series</p></a></li>
<li><a href='#periodotest'><p><code>periodotest</code> computes the p-value of the test for a hidden periodicity</p></a></li>
<li><a href='#perwinba'><p><code>perwinba</code> Bartlett-Priestley  window for direct spectral estimation</p></a></li>
<li><a href='#perwinda'><p><code>perwinda</code> Daniell  window for direct spectral estimation</p></a></li>
<li><a href='#perwinpa'><p><code>perwinpa</code> Parzen's window for direct spectral estimation</p></a></li>
<li><a href='#pestep'><p><code>pestep</code> help function for missar</p></a></li>
<li><a href='#PIGPRICE'><p>Monthly prices for pigs</p></a></li>
<li><a href='#polymake'><p><code>polymake</code> generates the coefficients of an AR process given the zeros of the</p>
characteristic polynomial. The norm of the roots must be greater than  one  for stationary processes.</a></li>
<li><a href='#PPDEMAND'><p>Peak power demand in Berlin</p></a></li>
<li><a href='#PRODINDEX'><p>Production index of manufacturing industries</p></a></li>
<li><a href='#psifair'><p><code>psifair</code> is a psi-function for robust estimation</p></a></li>
<li><a href='#psihuber'><p><code>psihuber</code> is a psi-function for robust estimation</p></a></li>
<li><a href='#RAINFALL'><p>Annual amount of rainfall in Los Angeles</p></a></li>
<li><a href='#REDWINE'><p>Monthly sales of Australian red wine (1000 l)</p></a></li>
<li><a href='#rlassoHAC'><p><code>rlassoHAC</code> performs Lasso estimation under heteroscedastic and autocorrelated non-Gaussian disturbances.</p></a></li>
<li><a href='#rlassoLoad'><p><code>rlassoLoad</code> performs Lasso estimation under heteroscedastic and autocorrelated non-Gaussian disturbances</p>
with predefined penalty loadings.</a></li>
<li><a href='#robsplinedecomp'><p><code>robsplinedecomp</code> decomposes a vector into trend, season and irregular  component</p>
by robustified spline approach; a time series attribute is lost</a></li>
<li><a href='#RS'><p><code>RS</code> rescaled adjusted range statistic</p></a></li>
<li><a href='#SALES'><p>Monthly sales of a company</p></a></li>
<li><a href='#SCHAUINSLAND'><p>CO2-Concentration obtained in Schauinsland, Germany</p></a></li>
<li><a href='#simpledecomp'><p><code>simpledecomp</code> decomposes a vector into trend, season and irregular component</p>
by linear regression approach</a></li>
<li><a href='#smoothls'><p><code>smoothls</code> smoothes a time series by Whittaker graduation.</p>
The function depends on  the package Matrix.</a></li>
<li><a href='#smoothrb'><p><code>smoothrb</code> smoothes a time series robustly by using Huber's psi-function.</p>
The initialisation uses a moving median.</a></li>
<li><a href='#specest'><p><code>specest</code>  direct spectral estimation of series y</p>
using periodogram window win</a></li>
<li><a href='#specplot'><p><code>specplot</code>    plot of spectral estimate</p></a></li>
<li><a href='#splinedecomp'><p><code>splinedecomp</code> decomposes a time series into trend, season and irregular component</p>
by spline approach.</a></li>
<li><a href='#SPRUCE'><p>Annual logging of spruce wood.</p></a></li>
<li><a href='#statcheck'><p><code>statcheck</code> determines the means, standard deviations and acf's of segmets of a time series</p>
and plots the acf's for the segments.</a></li>
<li><a href='#subsets'><p><code>subsets</code> determines all subsets of  a set of n elements (labelled by  1,2,...,n ).</p></a></li>
<li><a href='#symplot'><p><code>symplot</code> produces a symmetry plot</p></a></li>
<li><a href='#taper'><p><code>taper</code> taper modification of a time series</p></a></li>
<li><a href='#TAXES'><p>Monthly community taxes in Germany (billions EURO)</p></a></li>
<li><a href='#TREERING'><p>Mean thickness of annual tree rings</p></a></li>
<li><a href='#TREMOR'><p>Measurements of physiological tremor</p></a></li>
<li><a href='#tsmat'><p><code>tsmat</code> constructs a (n-p+1,p) matrix from a time series</p>
where the first column is the shortened series y[p],...,y[n], the second is y[p-1],...,y[n-1],  etc.</a></li>
<li><a href='#USAPOP'><p>Population of USA</p></a></li>
<li><a href='#vartable'><p><code>vartable</code> determines table of variate differences</p></a></li>
<li><a href='#WHORMONE'><p>Concentration of growth hormone of a bull</p></a></li>
<li><a href='#wntest'><p><code>wntest</code>   graphical test for white noise for a time series  or a series of regression residuals</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Time Series, Analysis and Application</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Author:</td>
<td>Rainer Schlittgen</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rainer Schlittgen &lt;R.Schlittgen@t-online.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Accompanies the book Rainer Schlittgen and Cristina Sattarhoff (2020) <a href="https://www.degruyter.com/view/title/575978">https://www.degruyter.com/view/title/575978</a>  "Angewandte Zeitreihenanalyse mit R, 4. Auflage" . The package contains the time series and functions used therein. It was developed over many years teaching courses about time series analysis.  </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), Matrix , vars, fftwtools, hdm</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>under Linux, fftwtools needs libfftw3-dev</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-10-30 11:09:35 UTC; rainer</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-10-30 11:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ACCIDENT'>Monthly numbers of road traffic accidents with personal injury in BRD</h2><span id='topic+ACCIDENT'></span>

<h3>Description</h3>

<p>Monthly numbers of road traffic accidents with personal injury in BRD
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ACCIDENT
</code></pre>


<h3>Format</h3>

<p>ACCIDENT is a univariate time series of length 528, start  January 1974, frequency = 12   
</p>

<dl>
<dt>ACCIDENT</dt><dd><p>Monthly  numbers of  road traffic accidents with personal injury</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt; https://www-genesis.destatis.de/genesis//online?operation=table&amp;code=46241-0002&amp; <br />
levelindex=0&amp;levelid=1583749114977&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ACCIDENT)
## maybe  tsp(ACCIDENT) ; plot(ACCIDENT) 
</code></pre>

<hr>
<h2 id='acfmat'><code>acfmat</code> computes a sequence of autocorrelation matrices for a multivariate time series</h2><span id='topic+acfmat'></span>

<h3>Description</h3>

<p><code>acfmat</code> computes a sequence of autocorrelation matrices for a multivariate time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acfmat(y, lag.max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acfmat_+3A_y">y</code></td>
<td>
<p>multivariate time series</p>
</td></tr>
<tr><td><code id="acfmat_+3A_lag.max">lag.max</code></td>
<td>
<p>maximum number of lag</p>
</td></tr>
</table>


<h3>Value</h3>

<p>out   list with components: 
</p>
<table>
<tr><td><code>M</code></td>
<td>
<p> array with autocovariance matrices </p>
</td></tr>
<tr><td><code>M1</code></td>
<td>
<p>array with indicators if autocovariances are significantly greater (+),    
lower (-) than the critical value or insignificant (.) at 95 percent level        </p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(ICECREAM)
out &lt;- acfmat(ICECREAM,7) 
</code></pre>

<hr>
<h2 id='acfpacf'><code>acfpacf</code> produces a plot of the acf and the pacf of a time series</h2><span id='topic+acfpacf'></span>

<h3>Description</h3>

<p><code>acfpacf</code> produces a plot of the acf and the pacf of a time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acfpacf(x, lag, HV = "H")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acfpacf_+3A_x">x</code></td>
<td>
<p>the series, a vector or a time series</p>
</td></tr>
<tr><td><code id="acfpacf_+3A_lag">lag</code></td>
<td>
<p>scalar, maximal lag to be plotted</p>
</td></tr>
<tr><td><code id="acfpacf_+3A_hv">HV</code></td>
<td>
<p>character, controls division of graphic window: &quot;H&quot; horizontal, &quot;V&quot; vertical, default is &quot;H&quot;</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(LYNX)
  acfpacf(log(LYNX),15,HV="H") 
</code></pre>

<hr>
<h2 id='ALCINCOME'>Alcohol Demand, UK, 1870-1938.</h2><span id='topic+ALCINCOME'></span>

<h3>Description</h3>

<p>Alcohol Demand, UK, 1870-1938.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ALCINCOME
</code></pre>


<h3>Format</h3>

<p>ALCINCOME is a threevariate time series of length 69 and 3 variables; start 1870, frequency = 1
</p>
 
<dl>
<dt>Y</dt><dd><p>log consumption per head</p>
</dd>
<dt>Z</dt><dd><p>log real income per head</p>
</dd> 
<dt>X</dt><dd><p>log real price</p>
</dd>
</dl>



<h3>Source</h3>

<p>Durbin &amp; Watson (1951)  &lt;https://doi.org/10.1093/biomet/38.1-2.159&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ALCINCOME)
## maybe  tsp(ALCINCOME) ; plot(ALCINCOME) 
</code></pre>

<hr>
<h2 id='armathspec'><code>armathspec</code> determines the theoretical spectrum of an arma process</h2><span id='topic+armathspec'></span>

<h3>Description</h3>

<p><code>armathspec</code> determines the theoretical spectrum of an arma process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>armathspec(a, b, nf, s = 1, pl = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="armathspec_+3A_a">a</code></td>
<td>
<p>ar-coefficients</p>
</td></tr>
<tr><td><code id="armathspec_+3A_b">b</code></td>
<td>
<p>ma-coefficients</p>
</td></tr>
<tr><td><code id="armathspec_+3A_nf">nf</code></td>
<td>
<p>scalar, the number of equally spaced frequencies</p>
</td></tr>
<tr><td><code id="armathspec_+3A_s">s</code></td>
<td>
<p>variance of error process</p>
</td></tr>
<tr><td><code id="armathspec_+3A_pl">pl</code></td>
<td>
<p>logical,  if TRUE, the spectrum is plotted, FALSE for no plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>out   (nf+1,2) matrix, the frequencies and the spectrum
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;-armathspec(c(0.3,-0.5),c(-0.8,0.7),50,s=1,pl=FALSE) 

</code></pre>

<hr>
<h2 id='aspectratio'><code>aspectratio</code>  determines the aspect ratio to plot a time series</h2><span id='topic+aspectratio'></span>

<h3>Description</h3>

<p><code>aspectratio</code>  determines the aspect ratio to plot a time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aspectratio(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aspectratio_+3A_y">y</code></td>
<td>
<p>time series</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a      scalar, the aspect ratio
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(GDP)
a &lt;- aspectratio(GDP) 
</code></pre>

<hr>
<h2 id='bandfilt'><code>bandfilt</code> does a bandpass filtering of a time series</h2><span id='topic+bandfilt'></span>

<h3>Description</h3>

<p><code>bandfilt</code> does a bandpass filtering of a time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bandfilt(y, q, pl, pu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bandfilt_+3A_y">y</code></td>
<td>
<p>the series, a vector or a time series</p>
</td></tr>
<tr><td><code id="bandfilt_+3A_q">q</code></td>
<td>
<p>scalar, half of length of symmetric weights</p>
</td></tr>
<tr><td><code id="bandfilt_+3A_pl">pl</code></td>
<td>
<p>scalar, lower periodicity ( &gt;= 2 )</p>
</td></tr>
<tr><td><code id="bandfilt_+3A_pu">pu</code></td>
<td>
<p>scalar, upper periodicity ( &gt; pl )</p>
</td></tr>
</table>


<h3>Value</h3>

<p>yf (n,1) vector, the centered filtered time series with NA's at beginning and ending
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(GDP)
yf &lt;- bandfilt(GDP,5,2,6)
plot(GDP); lines(yf+mean(GDP),col="red")   
</code></pre>

<hr>
<h2 id='BEER'>Monthly beer production in Australia: megalitres. Includes ale and stout. Does not include beverages with alcohol percentage less than 1.15.</h2><span id='topic+BEER'></span>

<h3>Description</h3>

<p>Monthly beer production in Australia: megalitres. Includes ale and stout. Does not include beverages with alcohol percentage less than 1.15.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BEER
</code></pre>


<h3>Format</h3>

<p>BEER is a univariate time series of length 476, start January 1956, end Aug 1995, frequency = 12
</p>

<dl>
<dt>BEER</dt><dd><p>Monthly production of beer in Australia</p>
</dd>
</dl>



<h3>Source</h3>

<p>R package tsdl  &lt;https://github.com/FinYang/tsdl&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BEER)
## maybe  tsp(BEER) ; plot(BEER) 
</code></pre>

<hr>
<h2 id='bispeces'><code>bispeces</code> performs indirect bivariate spectral estimation of two series y1, y2 using lagwindows</h2><span id='topic+bispeces'></span>

<h3>Description</h3>

<p><code>bispeces</code> performs indirect bivariate spectral estimation of two series y1, y2 using lagwindows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bispeces(y1, y2, q, win = "bartlett")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bispeces_+3A_y1">y1</code></td>
<td>
<p>vector, the first time series</p>
</td></tr>
<tr><td><code id="bispeces_+3A_y2">y2</code></td>
<td>
<p>vector, the second time series</p>
</td></tr>
<tr><td><code id="bispeces_+3A_q">q</code></td>
<td>
<p>number of covariances used for indirect spectral estimation</p>
</td></tr>
<tr><td><code id="bispeces_+3A_win">win</code></td>
<td>
<p>lagwindow  (possible: &quot;bartlett&quot;, &quot;parzen&quot;, &quot;tukey&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>out  data frame with columns:
</p>
<table>
<tr><td><code>f</code></td>
<td>
<p>frequencies 0, 1/n, 2/n, ...  (&lt;= 1/2 )  </p>
</td></tr>
<tr><td><code>coh</code></td>
<td>
<p>estimated coherency at Fourier frequencies 0,1/n, ...</p>
</td></tr>
<tr><td><code>ph</code></td>
<td>
<p>estimated phase at Fourier frequencies 0,1/n, ...</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(ICECREAM)
y &lt;- ICECREAM
out &lt;- bispeces(y[,1],y[,2],8,win="bartlett") 
</code></pre>

<hr>
<h2 id='BLACKOUT'>Weekly number of births in New York</h2><span id='topic+BLACKOUT'></span>

<h3>Description</h3>

<p>Weekly number of births in New York
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BLACKOUT
</code></pre>


<h3>Format</h3>

<p>BLACKOUT is a univariate time series of length 313, 1961 &ndash; 1966
</p>

<dl>
<dt>BLACKOUT</dt><dd><p>Weekly numbers of births  in New York</p>
</dd>
</dl>



<h3>Source</h3>

<p>Izenman, A. J., and Zabell, S. L. (1981)  &lt;https://www.sciencedirect.com/science/article/abs/pii/
0049089X81900181&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BLACKOUT)
## maybe  tsp(BLACKOUT) ; plot(BLACKOUT) 
</code></pre>

<hr>
<h2 id='BoxCox'><code>BoxCox</code> determines the power of a Box-Cox transformation to stabilize the variance of a time series</h2><span id='topic+BoxCox'></span>

<h3>Description</h3>

<p><code>BoxCox</code> determines the power of a Box-Cox transformation to stabilize the variance of a time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BoxCox(y, seg, Plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BoxCox_+3A_y">y</code></td>
<td>
<p>the series, a vector or a time series</p>
</td></tr>
<tr><td><code id="BoxCox_+3A_seg">seg</code></td>
<td>
<p>scalar, number of segments</p>
</td></tr>
<tr><td><code id="BoxCox_+3A_plot">Plot</code></td>
<td>
<p>logical, should a plot be produced?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>l    scalar, the power of the Box-Cox transformation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(INORDER)
lambda &lt;-BoxCox(INORDER,6,Plot=FALSE)

</code></pre>

<hr>
<h2 id='COFFEE'>U.S. annual coffee consumption</h2><span id='topic+COFFEE'></span>

<h3>Description</h3>

<p>U.S. annual coffee consumption
</p>


<h3>Usage</h3>

<pre><code class='language-R'>COFFEE
</code></pre>


<h3>Format</h3>

<p>COFFEE is a univariate time series of length 61; start 1910, frequency = 1 
</p>

<dl>
<dt>COFFEE</dt><dd><p>annual coffee-consumption USA, logarithmic transformed</p>
</dd>
</dl>



<h3>Source</h3>

<p>R package tsdl &lt;https://github.com/FinYang/tsdl&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(COFFEE)
## maybe  tsp(COFFEE) ; plot(COFFEE) 
</code></pre>

<hr>
<h2 id='DAX'>Market value of DAX</h2><span id='topic+DAX'></span>

<h3>Description</h3>

<p>Market value of DAX
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DAX
</code></pre>


<h3>Format</h3>

<p>DAX is a multivariate time series of length 12180 and 4 variables
</p>

<dl>
<dt>DAY</dt><dd><p>Day of the week</p>
</dd> 
<dt>MONTH</dt><dd><p>Month</p>
</dd> 
<dt>Year</dt><dd><p>Year</p>
</dd> 
<dt>DAX30</dt><dd><p>Market value</p>
</dd> 
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(DAX)
## maybe  tsp(DAX) ; plot(DAX) 
</code></pre>

<hr>
<h2 id='DIABETES'>Incidences of insulin-dependent diabetes mellitus</h2><span id='topic+DIABETES'></span>

<h3>Description</h3>

<p>Incidences of insulin-dependent diabetes mellitus
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DIABETES
</code></pre>


<h3>Format</h3>

<p>DIABETES is a univariate time series of length 72, start  January 1979, frequency = 12
</p>

<dl>
<dt>DIABETES</dt><dd><p>Incidences of insulin-dependent diabetes mellitus</p>
</dd>
</dl>



<h3>Source</h3>

<p>Waldhoer, T., Schober, E. and Tuomilehto, J. (1997) &lt;https://www.sciencedirect.com/science/ <br /> article/abs/pii/S0895435696003344&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DIABETES)
## maybe  tsp(DIABETES) ; plot(DIABETES) 
</code></pre>

<hr>
<h2 id='DOMINANCE'>Running yield of public bonds in Austria and Germany</h2><span id='topic+DOMINANCE'></span>

<h3>Description</h3>

<p>Running yield of public bonds in Austria and Germany
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DOMINANCE
</code></pre>


<h3>Format</h3>

<p>DOMINANCE is a bivariate time series of length 167:
</p>

<dl>
<dt>X</dt><dd><p>Interest rate Germany</p>
</dd>
<dt>Y</dt><dd><p>Interest rate Austria</p>
</dd>
</dl>



<h3>Source</h3>

<p>Jaenicke, J. and Neck, R. (1996) &lt;https://doi.org/10.17713/ajs.v25i2.555&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DOMINANCE)
## maybe  tsp(DOMINANCE) ; plot(DOMINANCE) 
</code></pre>

<hr>
<h2 id='dynspecest'><code>dynspecest</code>  performs a dynamic  spectrum estimation</h2><span id='topic+dynspecest'></span>

<h3>Description</h3>

<p><code>dynspecest</code>  performs a dynamic  spectrum estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynspecest(y, nseg, nf, e, theta = 0, phi = 15, d, Plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dynspecest_+3A_y">y</code></td>
<td>
<p>time series or vector</p>
</td></tr>
<tr><td><code id="dynspecest_+3A_nseg">nseg</code></td>
<td>
<p>number of segments for which the spectrum is estimated</p>
</td></tr>
<tr><td><code id="dynspecest_+3A_nf">nf</code></td>
<td>
<p>number of equally spaced frequencies</p>
</td></tr>
<tr><td><code id="dynspecest_+3A_e">e</code></td>
<td>
<p>equal bandwidth</p>
</td></tr>
<tr><td><code id="dynspecest_+3A_theta">theta</code></td>
<td>
<p>azimuthal viewing direction, see R function persp</p>
</td></tr>
<tr><td><code id="dynspecest_+3A_phi">phi</code></td>
<td>
<p>colatitude viewing direction, see R function persp</p>
</td></tr>
<tr><td><code id="dynspecest_+3A_d">d</code></td>
<td>
<p>a value to vary the strength of the perspective transformation, see R function persp</p>
</td></tr>
<tr><td><code id="dynspecest_+3A_plot">Plot</code></td>
<td>
<p>logical, schould a plot be generated?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>out list with components
</p>
<table>
<tr><td><code>f</code></td>
<td>
<p>frequencies, vector of length nf </p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>time, vector of length nseg </p>
</td></tr>
<tr><td><code>spec</code></td>
<td>
<p>the spectral estimates, (nf,nt)-matrix    </p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(IBM) 
y &lt;- diff(log(IBM))
out &lt;- dynspecest(y,60,50,0.2,theta=0,phi=15,d=1,Plot=FALSE)
</code></pre>

<hr>
<h2 id='ENGINES'>ENGINES is an alias for MACHINES</h2><span id='topic+ENGINES'></span>

<h3>Description</h3>

<p>ENGINES is an alias for MACHINES
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ENGINES
</code></pre>


<h3>Format</h3>

<p>ENGINES is a univariate time series of length 188, start January 1972 frequency = 12
</p>

<dl>
<dt>ENGINES</dt><dd><p>Incoming orders for engines</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(ENGINES)
## maybe  tsp(ENGINES) ; plot(ENGINES)  
</code></pre>

<hr>
<h2 id='FINANCE'>Portfolio-Insurance-Strategies</h2><span id='topic+FINANCE'></span>

<h3>Description</h3>

<p>Portfolio-Insurance-Strategies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FINANCE
</code></pre>


<h3>Format</h3>

<p>FINANCE is a multivariate time series of length 7529:
</p>

<dl>
<dt>CPPI</dt><dd><p>first Portfolio-Insurance-Strategy</p>
</dd>
<dt>TIPP</dt><dd><p>second Portfolio-Insurance-Strategy</p>
</dd>
<dt>StopLoss</dt><dd><p>third Portfolio-Insurance-Strategy</p>
</dd>
<dt>SyntheticPut</dt><dd><p>fourth Portfolio-Insurance-Strategy</p>
</dd>
<dt>CASH</dt><dd><p>money market investment</p>
</dd>
</dl>



<h3>Source</h3>

<p>Dichtl, H. and Drobetz, W. (2011) &lt;doi:10.1016/j.jbankfin.2010.11.012&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(FINANCE)
## maybe  tsp(FINANCE) ; plot(FINANCE) 
</code></pre>

<hr>
<h2 id='GDP'>Germany's gross domestic product adjusted for price changes</h2><span id='topic+GDP'></span>

<h3>Description</h3>

<p>Germany's gross domestic product adjusted for price changes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GDP
</code></pre>


<h3>Format</h3>

<p>GDP is a univariate time series of length 159, start January 1970, frequency = 4
</p>

<dl>
<dt>GDP</dt><dd><p>Gross domestic product  adjusted for price changes</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;https://www-genesis.destatis.de/genesis//online?operation=table&amp;code=81000-0002&amp;levelindex <br /> =0&amp;levelid=1583750132341&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(GDP)
## maybe  tsp(GDP) ; plot(GDP) 
</code></pre>

<hr>
<h2 id='GDPORIG'>Germany's gross domestic product, values of Laspeyres index to base 2000</h2><span id='topic+GDPORIG'></span>

<h3>Description</h3>

<p>Germany's gross domestic product, values of Laspeyres index to base 2000
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GDPORIG
</code></pre>


<h3>Format</h3>

<p>GDPORIG is a univariate time series of length 159, start January 1970, frequency = 4
</p>

<dl>
<dt>GDPORIG</dt><dd><p>gross domestic product, values of Laspeyres index to the base 2000</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;https://www-genesis.destatis.de/genesis//online?operation=table&amp;code=81000-0002&amp;levelindex <br /> =0&amp;levelid=1583750132341&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(GDPORIG)
## maybe  tsp(GDPORIG) ; plot(GDPORIG) 
</code></pre>

<hr>
<h2 id='Grangercaus'><code>Grangercaus</code>  determines three values of BIC from a twodimensional VAR process</h2><span id='topic+Grangercaus'></span>

<h3>Description</h3>

<p><code>Grangercaus</code>  determines three values of BIC from a twodimensional VAR process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Grangercaus(x, y, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Grangercaus_+3A_x">x</code></td>
<td>
<p>first time series</p>
</td></tr>
<tr><td><code id="Grangercaus_+3A_y">y</code></td>
<td>
<p>second time series</p>
</td></tr>
<tr><td><code id="Grangercaus_+3A_p">p</code></td>
<td>
<p>maximal order of VAR process</p>
</td></tr>
</table>


<h3>Value</h3>

<p>out  list with components
</p>
<table>
<tr><td><code>BIC</code></td>
<td>
<p>vector of length 3: </p>
</td></tr>
</table>

<table>
<tr>
 <td style="text-align: left;">
   BIC1 </td><td style="text-align: left;"> minimum aic value for all possible lag structures </td>
</tr>
<tr>
 <td style="text-align: left;">
   BIC2 </td><td style="text-align: left;"> minimum aic value when Y is not included as regressor in the equation for X </td>
</tr>
<tr>
 <td style="text-align: left;">
   BIC3 </td><td style="text-align: left;"> minimum aic value when X is not included as regressor in the equation for Y  </td>
</tr>

</table>

<table>
<tr><td><code>out1</code></td>
<td>
<p>output of function lm for regression equation for x-series </p>
</td></tr>
<tr><td><code>out2</code></td>
<td>
<p>output of function lm for regression equation for y-series  </p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ICECREAM)
out &lt;- Grangercaus(ICECREAM[,1],ICECREAM[,2],3) 

</code></pre>

<hr>
<h2 id='HAC'>HAC Covariance Matrix Estimation
<code>HAC</code>  computes the central quantity (the meat) in the HAC covariance matrix estimator, also called
sandwich estimator. HAC is the abbreviation for &quot;heteroskedasticity and autocorrelation consistent&quot;.</h2><span id='topic+HAC'></span>

<h3>Description</h3>

<p>HAC Covariance Matrix Estimation
<code>HAC</code>  computes the central quantity (the meat) in the HAC covariance matrix estimator, also called
sandwich estimator. HAC is the abbreviation for &quot;heteroskedasticity and autocorrelation consistent&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HAC(mcond, method = "Bartlett", bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HAC_+3A_mcond">mcond</code></td>
<td>
<p>a q-dimensional multivariate time series. In the case of OLS regression with q regressors mcond 
contains the series of the form regressor*residual (see example below).</p>
</td></tr>
<tr><td><code id="HAC_+3A_method">method</code></td>
<td>
<p>kernel function, choose between &quot;Truncated&quot;, &quot;Bartlett&quot;, &quot;Parzen&quot;, &quot;Tukey-Hanning&quot;, &quot;Quadratic Spectral&quot;.</p>
</td></tr>
<tr><td><code id="HAC_+3A_bw">bw</code></td>
<td>
<p>bandwidth parameter, controls the number of lags considered in the estimation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mat      a (q,q)-matrix
</p>


<h3>Source</h3>

<p>Heberle, J. and Sattarhoff, C. (2017) &lt;doi:10.3390/econometrics5010009&gt;  &quot;A Fast Algorithm for the Computation of HAC
Covariance Matrix Estimators&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
data(MUSKRAT)
y &lt;- ts(log10(MUSKRAT))
n &lt;- length(y)
t &lt;- c(1:n)
t2 &lt;- t^2
out2 &lt;- lm(y ~ t +t2)
mat_xu &lt;- matrix(c(out2$residuals,t*out2$residuals, t2*out2$residuals),nrow=62,ncol=3)
hac &lt;- HAC(mat_xu, method="Bartlett", 4)

mat_regr&lt;- matrix(c(rep(1,62),t,t2),nrow=62,ncol=3)
mat_q &lt;- t(mat_regr)%*%mat_regr/62
vcov_HAC &lt;- solve(mat_q)%*%hac%*%solve(mat_q)/62
# vcov_HAC is the HAC covariance matrix estimation for the OLS coefficients. 
</code></pre>

<hr>
<h2 id='HEARTBEAT'>Cardiac frequency of a patient</h2><span id='topic+HEARTBEAT'></span>

<h3>Description</h3>

<p>Cardiac frequency of a patient
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HEARTBEAT
</code></pre>


<h3>Format</h3>

<p>HEARTBEAT is a univariate time series of length 30:
</p>

<dl>
<dt>HEARTBEAT</dt><dd><p>cardiac frequency of a patient</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(HEARTBEAT)
## maybe  tsp(HEARTBEAT) ; plot(HEARTBEAT) 
</code></pre>

<hr>
<h2 id='HSV'>HSV's position in the first German soccer league</h2><span id='topic+HSV'></span>

<h3>Description</h3>

<p>HSV's position in the first German soccer league
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HSV
</code></pre>


<h3>Format</h3>

<p>HSV is a univariate time series of length 47:
</p>

<dl>
<dt>HSV</dt><dd><p>HSV's position in the first German soccer league</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;https://www.transfermarkt.de/hamburger-sv/platzierungen/verein/41&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HSV)
## maybe  tsp(HSV) ; plot(HSV) 
</code></pre>

<hr>
<h2 id='IBM'>IBM's stock price</h2><span id='topic+IBM'></span>

<h3>Description</h3>

<p>IBM's stock price
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IBM
</code></pre>


<h3>Format</h3>

<p>IBM is a univariate time series of length 369, start 17 May  1961
</p>

<dl>
<dt>IBM</dt><dd><p>IBM's daily stock price</p>
</dd>
</dl>



<h3>Source</h3>

<p>Box, G. E. P.  and Jenkins, G. M. (1970, ISBN: 978-0816210947)  &quot;Time series analysis: forecasting and control&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(IBM)
## maybe  tsp(IBM) ; plot(IBM) 
</code></pre>

<hr>
<h2 id='ICECREAM'>Temperature and consumption of ice cream</h2><span id='topic+ICECREAM'></span>

<h3>Description</h3>

<p>Temperature and consumption of ice cream
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICECREAM
</code></pre>


<h3>Format</h3>

<p>ICECREAM is a bivariate time series of length 160:  
</p>
 
<dl>
<dt>ICE</dt><dd><p>consumption of ice cream</p>
</dd> 
<dt>TEMP</dt><dd><p>Temperature in Fahrenheit degrees</p>
</dd>  
</dl>



<h3>Source</h3>

<p>Hand, D. J., et al. (1994, ISBN: 9780412399206)  &quot;A Handbook of Small Data Sets&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ICECREAM)
## maybe  tsp(ICECREAM) ; plot(ICECREAM) 
</code></pre>

<hr>
<h2 id='init_values'><code>init_values</code> is an auxiliary function for rlassoHAC, for fitting linear models with
the method of least squares where only the variables in X with highest correlations
are considered; taken from package hdm.</h2><span id='topic+init_values'></span>

<h3>Description</h3>

<p><code>init_values</code> is an auxiliary function for rlassoHAC, for fitting linear models with
the method of least squares where only the variables in X with highest correlations
are considered; taken from package hdm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_values(X, y, number = 5, intercept = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_values_+3A_x">X</code></td>
<td>
<p>Regressors (matrix or object can be coerced to matrix).</p>
</td></tr>
<tr><td><code id="init_values_+3A_y">y</code></td>
<td>
<p>Dependent variable(s).</p>
</td></tr>
<tr><td><code id="init_values_+3A_number">number</code></td>
<td>
<p>How many regressors in X should be considered.</p>
</td></tr>
<tr><td><code id="init_values_+3A_intercept">intercept</code></td>
<td>
<p>Logical. If TRUE, intercept is included which is not penalized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>init_values returns a list containing the
following components:
</p>
<table>
<tr><td><code>residuals</code></td>
<td>
<p>Residuals.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>Estimated coefficients.</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Victor Chernozhukov, Chris Hansen, Martin Spindler (2016). hdm: High-Dimensional Metrics,
R Journal, 8(2), 185-199. URL https://journal.r-project.org/archive/2016/RJ-2016-040/index.html.
</p>

<hr>
<h2 id='INORDER'>Income orders of a company</h2><span id='topic+INORDER'></span>

<h3>Description</h3>

<p>Income orders of a company
</p>


<h3>Usage</h3>

<pre><code class='language-R'>INORDER
</code></pre>


<h3>Format</h3>

<p>INORDER is a univariate time series of length 237, start January 1968, frequency =12 
</p>

<dl>
<dt>INORDER</dt><dd><p>Income orders of a company</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(INORDER)
## maybe  tsp(INORDER) ; plot(INORDER) 
</code></pre>

<hr>
<h2 id='interpol'><code>interpol</code> help function for missls</h2><span id='topic+interpol'></span>

<h3>Description</h3>

<p><code>interpol</code> help function for missls
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpol(rho, xcent)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpol_+3A_rho">rho</code></td>
<td>
<p>autocorrelation function</p>
</td></tr>
<tr><td><code id="interpol_+3A_xcent">xcent</code></td>
<td>
<p>centered time series</p>
</td></tr>
</table>


<h3>Value</h3>

<p>z  new version of xcent
</p>

<hr>
<h2 id='kweightsHAC'><code>kweightsHAC</code>  help function for HAC</h2><span id='topic+kweightsHAC'></span>

<h3>Description</h3>

<p><code>kweightsHAC</code>  help function for HAC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kweightsHAC(
  kernel = c("Truncated", "Bartlett", "Parzen", "Tukey-Hanning", "Quadratic Spectral"),
  dimN,
  bw
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kweightsHAC_+3A_kernel">kernel</code></td>
<td>
<p>kernel function, choose between &quot;Truncated&quot;, &quot;Bartlett&quot;, &quot;Parzen&quot;, &quot;Tukey-Hanning&quot;, &quot;Quadratic Spectral&quot;.</p>
</td></tr>
<tr><td><code id="kweightsHAC_+3A_dimn">dimN</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="kweightsHAC_+3A_bw">bw</code></td>
<td>
<p>bandwidth parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ww weights
</p>

<hr>
<h2 id='L921'>Subsoil water level and precipitation at pilot well L921</h2><span id='topic+L921'></span>

<h3>Description</h3>

<p>Subsoil water level and precipitation at pilot well L921
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L921
</code></pre>


<h3>Format</h3>

<p>L921 is a trivariate time series of length 335:
</p>

<dl>
<dt>T</dt><dd><p>Day</p>
</dd>
<dt>Y</dt><dd><p>Water level</p>
</dd>
<dt>Z</dt><dd><p>Supplemented water level</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(L921)
## maybe  tsp(L921) ; plot(L921) 
</code></pre>

<hr>
<h2 id='lagwinba'><code>lagwinba</code> Bartlett's Lag-window for indirect spectrum estimation</h2><span id='topic+lagwinba'></span>

<h3>Description</h3>

<p><code>lagwinba</code> Bartlett's Lag-window for indirect spectrum estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lagwinba(NL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lagwinba_+3A_nl">NL</code></td>
<td>
<p>number of lags used for estimation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>win vector, one-sided weights
</p>


<h3>Examples</h3>

<pre><code class='language-R'>win &lt;-lagwinba(5) 
</code></pre>

<hr>
<h2 id='lagwinpa'><code>lagwinpa</code> Parzen's Lag-window for indirect spectrum estimation</h2><span id='topic+lagwinpa'></span>

<h3>Description</h3>

<p><code>lagwinpa</code> Parzen's Lag-window for indirect spectrum estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lagwinpa(NL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lagwinpa_+3A_nl">NL</code></td>
<td>
<p>number of lags used for estimation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>win vector, one-sided weights
</p>


<h3>Examples</h3>

<pre><code class='language-R'>win &lt;- lagwinpa(5)  
</code></pre>

<hr>
<h2 id='lagwintu'><code>lagwintu</code> Tukey's Lag-window for indirect spectrum estimation</h2><span id='topic+lagwintu'></span>

<h3>Description</h3>

<p><code>lagwintu</code> Tukey's Lag-window for indirect spectrum estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lagwintu(NL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lagwintu_+3A_nl">NL</code></td>
<td>
<p>number of lags used for estimation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>win vector, one-sided weights
</p>


<h3>Examples</h3>

<pre><code class='language-R'>win &lt;- lagwintu(5)   
</code></pre>

<hr>
<h2 id='lambdaCalculationHAC'><code>lambdaCalculationHAC</code> is an auxiliary function for rlassoHAC; it calculates the penalty parameters.</h2><span id='topic+lambdaCalculationHAC'></span>

<h3>Description</h3>

<p><code>lambdaCalculationHAC</code> is an auxiliary function for rlassoHAC; it calculates the penalty parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambdaCalculationHAC(
  X.dependent.lambda = FALSE,
  c = 2,
  gamma = 0.1,
  kernel,
  bands,
  bns,
  lns,
  nboot,
  y = NULL,
  x = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambdaCalculationHAC_+3A_x.dependent.lambda">X.dependent.lambda</code></td>
<td>
<p>Logical, TRUE, if the penalization parameter depends on the design 
of the matrix x. FALSE, if independent of the design matrix (default).</p>
</td></tr>
<tr><td><code id="lambdaCalculationHAC_+3A_c">c</code></td>
<td>
<p>Constant for the penalty with default c = 2 .</p>
</td></tr>
<tr><td><code id="lambdaCalculationHAC_+3A_gamma">gamma</code></td>
<td>
<p>Constant for the penalty with default gamma=0.1.</p>
</td></tr>
<tr><td><code id="lambdaCalculationHAC_+3A_kernel">kernel</code></td>
<td>
<p>String  kernel function, choose between &quot;Truncated&quot;, &quot;Bartlett&quot;, &quot;Parzen&quot;, 
&quot;Tukey-Hanning&quot;, &quot;Quadratic Spectral&quot;.</p>
</td></tr>
<tr><td><code id="lambdaCalculationHAC_+3A_bands">bands</code></td>
<td>
<p>Constant bandwidth parameter.</p>
</td></tr>
<tr><td><code id="lambdaCalculationHAC_+3A_bns">bns</code></td>
<td>
<p>Block length.</p>
</td></tr>
<tr><td><code id="lambdaCalculationHAC_+3A_lns">lns</code></td>
<td>
<p>Number of blocks.</p>
</td></tr>
<tr><td><code id="lambdaCalculationHAC_+3A_nboot">nboot</code></td>
<td>
<p>Number of bootstrap iterations.</p>
</td></tr>
<tr><td><code id="lambdaCalculationHAC_+3A_y">y</code></td>
<td>
<p>Residual which is used for calculation of the variance or the data-dependent loadings.</p>
</td></tr>
<tr><td><code id="lambdaCalculationHAC_+3A_x">x</code></td>
<td>
<p>Regressors (vector, matrix or object can be coerced to matrix).</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>lambda0</code></td>
<td>
<p>Penalty term</p>
</td></tr>
<tr><td><code>Ups0</code></td>
<td>
<p>Penalty loadings, vector of length p (no. of regressors)</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>This is lambda0 * Ups0</p>
</td></tr>
<tr><td><code>penalty</code></td>
<td>
<p>Summary of the used penalty function.</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Victor Chernozhukov, Chris Hansen, Martin Spindler (2016). hdm: High-Dimensional Metrics,
R Journal, 8(2), 185-199. URL https://journal.r-project.org/archive/2016/RJ-2016-040/index.html.
</p>

<hr>
<h2 id='lambdaCalculationLoad'><code>lambdaCalculationLoad</code> is an auxiliary function for rlassoLoad; it calculates the penalty parameters
with predefined loadings.</h2><span id='topic+lambdaCalculationLoad'></span>

<h3>Description</h3>

<p><code>lambdaCalculationLoad</code> is an auxiliary function for rlassoLoad; it calculates the penalty parameters
with predefined loadings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambdaCalculationLoad(
  X.dependent.lambda = FALSE,
  c = 2,
  gamma = 0.1,
  load,
  bns,
  lns,
  nboot,
  y = NULL,
  x = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambdaCalculationLoad_+3A_x.dependent.lambda">X.dependent.lambda</code></td>
<td>
<p>Logical, TRUE, if the penalization parameter depends on the design 
of the matrix x. FALSE, if independent of the design matrix (default).</p>
</td></tr>
<tr><td><code id="lambdaCalculationLoad_+3A_c">c</code></td>
<td>
<p>Constant for the penalty with default c = 2 .</p>
</td></tr>
<tr><td><code id="lambdaCalculationLoad_+3A_gamma">gamma</code></td>
<td>
<p>Constant for the penalty with default gamma=0.1.</p>
</td></tr>
<tr><td><code id="lambdaCalculationLoad_+3A_load">load</code></td>
<td>
<p>Penalty loadings, vector of length p (no. of regressors).</p>
</td></tr>
<tr><td><code id="lambdaCalculationLoad_+3A_bns">bns</code></td>
<td>
<p>Block length.</p>
</td></tr>
<tr><td><code id="lambdaCalculationLoad_+3A_lns">lns</code></td>
<td>
<p>Number of blocks.</p>
</td></tr>
<tr><td><code id="lambdaCalculationLoad_+3A_nboot">nboot</code></td>
<td>
<p>Number of bootstrap iterations.</p>
</td></tr>
<tr><td><code id="lambdaCalculationLoad_+3A_y">y</code></td>
<td>
<p>Residual which is used for calculation of the variance or the data-dependent penalty.</p>
</td></tr>
<tr><td><code id="lambdaCalculationLoad_+3A_x">x</code></td>
<td>
<p>Regressors (vector, matrix or object can be coerced to matrix).</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>lambda0</code></td>
<td>
<p>Penalty term</p>
</td></tr>
<tr><td><code>Ups0</code></td>
<td>
<p>Penalty loadings, vector of length p (no. of regressors)</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>This is lambda0 * Ups0</p>
</td></tr>
<tr><td><code>penalty</code></td>
<td>
<p>Summary of the used penalty function</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Victor Chernozhukov, Chris Hansen, Martin Spindler (2016). hdm: High-Dimensional Metrics,
R Journal, 8(2), 185-199. URL https://journal.r-project.org/archive/2016/RJ-2016-040/index.html.
</p>

<hr>
<h2 id='ldrec'><code>ldrec</code> does Levinson-Durbin recursion for determing all coefficients a(i,j)</h2><span id='topic+ldrec'></span>

<h3>Description</h3>

<p><code>ldrec</code> does Levinson-Durbin recursion for determing all coefficients a(i,j)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ldrec(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ldrec_+3A_a">a</code></td>
<td>
<p>(p+1,1)-vector of acf of a time series: acov(0),...,acov(p)
or  1,acor(1),..,acor(p)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mat (p,p+2)-matrix, coefficients in lower triangular,
pacf in colum p+2 and Q(p) in colum p+1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HEARTBEAT)
a &lt;- acf(HEARTBEAT,5,plot=FALSE)
mat &lt;- ldrec(a$acf)
</code></pre>

<hr>
<h2 id='LITH'>Daily subsoil water level and precipitation at pilot well Lith</h2><span id='topic+LITH'></span>

<h3>Description</h3>

<p>Daily subsoil water level and precipitation at pilot well Lith
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LITH
</code></pre>


<h3>Format</h3>

<p>LITH is a bivariate time series of length 1347:
</p>

<dl>
<dt>N</dt><dd><p>precipitation amount</p>
</dd>    
<dt>G</dt><dd><p>water level</p>
</dd> 
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(LITH)
## maybe  tsp(LITH) ; plot(LITH) 
</code></pre>

<hr>
<h2 id='LjungBoxPierceTest'><code>LjungBoxPierceTest</code> determines the test statistic and p values for several lags  for a residual series</h2><span id='topic+LjungBoxPierceTest'></span>

<h3>Description</h3>

<p><code>LjungBoxPierceTest</code> determines the test statistic and p values for several lags  for a residual series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LjungBoxPierceTest(y, n.par = 0, maxlag = 48)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LjungBoxPierceTest_+3A_y">y</code></td>
<td>
<p>the series of residuals, a vector or a time series</p>
</td></tr>
<tr><td><code id="LjungBoxPierceTest_+3A_n.par">n.par</code></td>
<td>
<p>number of parameters which had been estimated</p>
</td></tr>
<tr><td><code id="LjungBoxPierceTest_+3A_maxlag">maxlag</code></td>
<td>
<p>maximal lag up to which the test statistic is computed, default is maxlag = 48</p>
</td></tr>
</table>


<h3>Value</h3>

<p>BT     matrix with columns:  
lags,   degrees of freedom,    test statistic,   p-value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(COFFEE)
out &lt;- arima(COFFEE,order=c(1,0,0))
BT &lt;- LjungBoxPierceTest(out$residuals,1,20)

</code></pre>

<hr>
<h2 id='LUHORMONE'>Level of Luteinzing hormone of a cow</h2><span id='topic+LUHORMONE'></span>

<h3>Description</h3>

<p>Level of Luteinzing hormone of a cow
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LUHORMONE
</code></pre>


<h3>Format</h3>

<p>LUHORMONE is a bivariate time series of length 29:
</p>

<dl>
<dt>T</dt><dd><p>Time in minutes</p>
</dd>
<dt>X</dt><dd><p>Level of the Luteinzing-hormone</p>
</dd>
</dl>


<hr>
<h2 id='LYNX'>Annual lynx trappings in a region of North-West Canada. Taken from Andrews and Herzberg (1985).</h2><span id='topic+LYNX'></span>

<h3>Description</h3>

<p>Annual lynx trappings in a region of North-West Canada. Taken from Andrews and Herzberg (1985).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LYNX
</code></pre>


<h3>Format</h3>

<p>LYNX is a univariate time series of length 114; start 1821 frequency = 1
</p>

<dl>
<dt>LYNX</dt><dd><p>annual lynx trappings in a region of North-west Canada</p>
</dd>
</dl>



<h3>Source</h3>

<p>Andrews, D. F. and Herzberg, A. M.  (1985) &quot;Data&quot; &lt;https://www.springer.com/gp/book/9781461295631&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(LYNX)
## maybe  tsp(LYNX) ; plot(LYNX) 
</code></pre>

<hr>
<h2 id='LYNXHARE'>Size of populations of lynxes and snow hares</h2><span id='topic+LYNXHARE'></span>

<h3>Description</h3>

<p>Size of populations of lynxes and snow hares
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LYNXHARE
</code></pre>


<h3>Format</h3>

<p>LYNXHARE is a simulated bivariate  time series from a VAR[1]-model  of length 100:  
</p>
 
<dl>
<dt>X</dt><dd><p>Number of lynxes</p>
</dd> 
<dt>Y</dt><dd><p>Number of snow hares</p>
</dd>  
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(LYNXHARE)
</code></pre>

<hr>
<h2 id='MACHINES'>Number of incoming orders for machines</h2><span id='topic+MACHINES'></span>

<h3>Description</h3>

<p>Number of incoming orders for machines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MACHINES
</code></pre>


<h3>Format</h3>

<p>MACHINES is a univariate time series of length 188, start January 1972 frequency = 12
</p>

<dl>
<dt>MACHINES</dt><dd><p>Incoming orders for machines</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(MACHINES)
## maybe  tsp(MACHINES) ; plot(MACHINES)  
</code></pre>

<hr>
<h2 id='MAUNALOA'>Atmospheric CO2 concentrations (ppmv) derived from in situ air samples collected at Mauna Loa Observatory, Hawaii</h2><span id='topic+MAUNALOA'></span>

<h3>Description</h3>

<p>Atmospheric CO2 concentrations (ppmv) derived from in situ air samples collected at Mauna Loa Observatory, Hawaii
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MAUNALOA
</code></pre>


<h3>Format</h3>

<p>MAUNALOA is a univariate time series of length 735; start March 1958, frequency = 12   
</p>

<dl>
<dt>MAUNALOA</dt><dd><p>CO2-concentration at Mauna Loa</p>
</dd>
</dl>



<h3>Source</h3>

<p>Keeling, C. D. ,  Piper, S. C.,  Bacastow,  R. B., Wahlen, M. ,  Whorf, T. P., Heimann,  M.,  and Meijer, H. A.  (2001)  &lt;https://library.ucsd.edu/dc/object/bb3859642r&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MAUNALOA)
## maybe  tsp(MAUNALOA) ; plot(MAUNALOA) 
</code></pre>

<hr>
<h2 id='MDAX'>Stock market price of MDAX</h2><span id='topic+MDAX'></span>

<h3>Description</h3>

<p>Stock market price of MDAX
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MDAX
</code></pre>


<h3>Format</h3>

<p>MDAX is a multivariate time series of length 6181 and 4 variables
</p>

<dl>
<dt>DAY</dt><dd><p>Day of the week</p>
</dd> 
<dt>MONTH</dt><dd><p>Month</p>
</dd> 
<dt>YEAR</dt><dd><p>Year</p>
</dd> 
<dt>MDAX</dt><dd><p>Opening stock market price</p>
</dd> 
</dl>



<h3>Source</h3>

<p>&lt;https://www.onvista.de/index/MDAX-Index-323547&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MDAX)
## maybe  tsp(MDAX) ; plot(MDAX[,3]) 
</code></pre>

<hr>
<h2 id='MELANOM'>Melanoma incidence in Connecticut</h2><span id='topic+MELANOM'></span>

<h3>Description</h3>

<p>Melanoma incidence in Connecticut
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MELANOM
</code></pre>


<h3>Format</h3>

<p>MELANOM is a  multivariate time series of length 45 and 3 variables
</p>
 
<dl>
<dt>POP</dt><dd><p>Population</p>
</dd> 
<dt>RATE</dt><dd><p>Incidence</p>
</dd> 
<dt>SUN</dt><dd><p>Sunspots</p>
</dd> 
</dl>



<h3>Source</h3>

<p>Andrews, D. F. and Herzberg, A. M.  (1985) &quot;Data&quot; &lt;https://www.springer.com/gp/book/9781461295631&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MELANOM)
## maybe  tsp(MELANOM) ; plot(MELANOM[,-1]) 
</code></pre>

<hr>
<h2 id='mfraccheck'>multifractal check
<code>mfraccheck</code>  computes the absolute empirical moments of the differenced series for various lags
and moment orders. E.g. for lag = 3 and moment order = 1 the average absolute value of 
the differences with lag 3 will be computed. By default, the maximum lag is determined 
so that the differenced series contains at lest 50 observations.</h2><span id='topic+mfraccheck'></span>

<h3>Description</h3>

<p>multifractal check
<code>mfraccheck</code>  computes the absolute empirical moments of the differenced series for various lags
and moment orders. E.g. for lag = 3 and moment order = 1 the average absolute value of 
the differences with lag 3 will be computed. By default, the maximum lag is determined 
so that the differenced series contains at lest 50 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mfraccheck(p, q_max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mfraccheck_+3A_p">p</code></td>
<td>
<p>the series</p>
</td></tr>
<tr><td><code id="mfraccheck_+3A_q_max">q_max</code></td>
<td>
<p>maximum moment order</p>
</td></tr>
</table>


<h3>Value</h3>

<p>out list with components:
</p>
<table>
<tr><td><code>moments</code></td>
<td>
<p>matrix with lagmax raws and q_max columns containing the values of the absolute empirical moments </p>
</td></tr>
<tr><td><code>lagmax</code></td>
<td>
<p>the maximum lag for differencing</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(NIKKEI)
p &lt;- NIKKEI
out &lt;- mfraccheck(log(p),5)
mom &lt;- ts(out$moments,start=1)
ts.plot(mom, log ="xy",xlab="lag",ylab="abs. empirical moments", lty=c(1:5)) 
</code></pre>

<hr>
<h2 id='missar'><code>missar</code> Substitution of missing values in a time series by 
conditional  exspectations of AR(p) models</h2><span id='topic+missar'></span>

<h3>Description</h3>

<p><code>missar</code> Substitution of missing values in a time series by 
conditional  exspectations of AR(p) models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missar(x, p, iterout = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missar_+3A_x">x</code></td>
<td>
<p>vector, the time series</p>
</td></tr>
<tr><td><code id="missar_+3A_p">p</code></td>
<td>
<p>integer, the maximal order of ar polynom   0 &lt; p &lt; 18,</p>
</td></tr>
<tr><td><code id="missar_+3A_iterout">iterout</code></td>
<td>
<p>if = 1, iteration history is printed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>out list with   elements
</p>
<table>
<tr><td><code>a</code></td>
<td>
<p>(p,p)-matrix, estimated ar coefficients for ar-models   </p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>(n,1)-vector, completed time series </p>
</td></tr>
<tr><td><code>iterhist</code></td>
<td>
<p>matrix, NULL or the iteration history</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Miller R.B., Ferreiro O. (1984) &lt;doi.org/10.1007/978-1-4684-9403-7_12&gt; &quot;A Strategy to Complete a Time Series with Missing Observations&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HEARTBEAT)
x &lt;- HEARTBEAT
x[c(20,21)] &lt;- NA
out &lt;- missar(x,2)
</code></pre>

<hr>
<h2 id='missls'><code>missls</code> substitutes missing values in a time series using the LS approach with ARMA models</h2><span id='topic+missls'></span>

<h3>Description</h3>

<p><code>missls</code> substitutes missing values in a time series using the LS approach with ARMA models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missls(x, p = 0, tol = 0.001, theo = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missls_+3A_x">x</code></td>
<td>
<p>vector, the time series</p>
</td></tr>
<tr><td><code id="missls_+3A_p">p</code></td>
<td>
<p>integer, the  order of polynom   alpha(B)/beta(B)</p>
</td></tr>
<tr><td><code id="missls_+3A_tol">tol</code></td>
<td>
<p>tolerance that can be set; it enters via tol*sd(x,na.rm=TRUE)</p>
</td></tr>
<tr><td><code id="missls_+3A_theo">theo</code></td>
<td>
<p>(k,1)-vector, prespecified Inverse ACF, IACF (starting at lag 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>y    completed time series
</p>


<h3>Source</h3>

<p>S. R. Brubacher and G. Tunnicliffe Wilson (1976)   &lt;https://www.jstor.org/stable/2346678&gt;  &quot;Interpolating Time Series with Application to the 
Estimation of Holiday Effects on Electricity Demand Journal of the Royal Statistical Society&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HEARTBEAT)
x &lt;- HEARTBEAT
x[c(20,21)] &lt;- NA
out &lt;-  missls(x,p=2,tol=0.001,theo=0)
</code></pre>

<hr>
<h2 id='moveav'><code>moveav</code> smoothes a time series by moving averages</h2><span id='topic+moveav'></span>

<h3>Description</h3>

<p><code>moveav</code> smoothes a time series by moving averages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moveav(y, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moveav_+3A_y">y</code></td>
<td>
<p>the series, a vector or a time series</p>
</td></tr>
<tr><td><code id="moveav_+3A_q">q</code></td>
<td>
<p>scalar,  span of moving average</p>
</td></tr>
</table>


<h3>Value</h3>

<p>g vector,  smooth component
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(GDP)
g &lt;- moveav(GDP,12) 
 plot(GDP) ; lines(g,col="red")  
</code></pre>

<hr>
<h2 id='movemed'><code>movemed</code> smoothes a time series by moving medians</h2><span id='topic+movemed'></span>

<h3>Description</h3>

<p><code>movemed</code> smoothes a time series by moving medians
</p>


<h3>Usage</h3>

<pre><code class='language-R'>movemed(y, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="movemed_+3A_y">y</code></td>
<td>
<p>the series, a vector or a time series</p>
</td></tr>
<tr><td><code id="movemed_+3A_q">q</code></td>
<td>
<p>scalar,  span of moving median</p>
</td></tr>
</table>


<h3>Value</h3>

<p>g  vector,  smooth component
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BIP)
g &lt;- movemed(GDP,12) 
 plot(GDP) ; t &lt;- seq(from = 1970, to = 2009.5,by=0.25) ; lines(t,g,col="red")  
</code></pre>

<hr>
<h2 id='MUSKRAT'>Annual trade of muskrat pelts</h2><span id='topic+MUSKRAT'></span>

<h3>Description</h3>

<p>Annual trade of muskrat pelts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MUSKRAT
</code></pre>


<h3>Format</h3>

<p>MUSKRAT is a univariate time series of length 62; start 1848, frequency = 1 
</p>

<dl>
<dt>MUSKRAT</dt><dd><p>annual trade of muskrat pelts</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;https://archive.uea.ac.uk/~gj/book/data/mink.dat&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MUSKRAT)
## maybe  tsp(MUSKRAT) ; plot(MUSKRAT) 
</code></pre>

<hr>
<h2 id='NIKKEI'>Daily values of the Japanese stock market index Nikkei 225 between 02.02.2000 and 20.10.2020</h2><span id='topic+NIKKEI'></span>

<h3>Description</h3>

<p>Daily values of the Japanese stock market index Nikkei 225 between 02.02.2000 and 20.10.2020
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NIKKEI
</code></pre>


<h3>Format</h3>

<p>NIKKEI is a univariate time series of length 5057
</p>

<dl>
<dt>NIKKEI</dt><dd><p>Daily values of Nikkei</p>
</dd>
</dl>



<h3>Source</h3>

<p>Heber, G., Lunde, A., Shephard, N. and Sheppard, K. (2009) &quot;Oxford-Man Institute's realized library, version 0.3&quot;, 
Oxford-Man Institute, University of Oxford, Oxford    &lt;https://realized.oxford-man.ox.ac.uk/data&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(NIKKEI)
## maybe plot(NIKKEI) 
</code></pre>

<hr>
<h2 id='outidentify'><code>outidentify</code> performs one iteration of Wei's iterative procedure to identify impact, locations and type 
of outliers in arma processes</h2><span id='topic+outidentify'></span>

<h3>Description</h3>

<p><code>outidentify</code> performs one iteration of Wei's iterative procedure to identify impact, locations and type 
of outliers in arma processes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outidentify(x, object, alpha = 0.05, robust = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outidentify_+3A_x">x</code></td>
<td>
<p>vector, the time series</p>
</td></tr>
<tr><td><code id="outidentify_+3A_object">object</code></td>
<td>
<p>output of a model fit with the function  arima  (from stats)</p>
</td></tr>
<tr><td><code id="outidentify_+3A_alpha">alpha</code></td>
<td>
<p>the level of the tests for deciding which value is to be considered an outlier</p>
</td></tr>
<tr><td><code id="outidentify_+3A_robust">robust</code></td>
<td>
<p>logical, should the standard error be computed robustly?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>out list with   elements
</p>
<table>
<tr><td><code>outlier</code></td>
<td>
<p>matrix with time index (ind), type of outlier  (1 = AO, 2 = IO) and value of test statistic (lambda)</p>
</td></tr> 
<tr><td><code>arima.out</code></td>
<td>
<p>output of final arima model where the outliers are incorporated as fixed regressors    </p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(SPRUCE)
out &lt;- arima(SPRUCE,order=c(2,0,0))
out2 &lt;- outidentify(SPRUCE,out,alpha=0.05, robust = FALSE)
</code></pre>

<hr>
<h2 id='OXYGEN'>Amount of an Oxygen isotope</h2><span id='topic+OXYGEN'></span>

<h3>Description</h3>

<p>Amount of an Oxygen isotope
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OXYGEN
</code></pre>


<h3>Format</h3>

<p>OXYGEN is a  matrix with 164 rows and 2 columns   
</p>
 
<dl>
<dt>T</dt><dd><p>Time</p>
</dd> 
<dt>D</dt><dd><p>DELTA18O</p>
</dd>  
</dl>



<h3>Source</h3>

<p>Belecher, J., Hampton, J. S., and Tunnicliffe Wilson, T. (1994,  ISSN: 1369-7412)  &quot;Parameterization of Continuous Time Autoregressive Models for Irregularly Sampled Time Series Data&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(OXYGEN)
## maybe   plot(OXYGEN[,1],OXYGEN[,2],type="l"); rug(OXYGEN[,1])
</code></pre>

<hr>
<h2 id='pacfmat'><code>pacfmat</code> sequence of partial autocorrelation matrices and related statistics for a multivariate time series</h2><span id='topic+pacfmat'></span>

<h3>Description</h3>

<p><code>pacfmat</code> sequence of partial autocorrelation matrices and related statistics for a multivariate time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pacfmat(y, lag.max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pacfmat_+3A_y">y</code></td>
<td>
<p>multivariate time series</p>
</td></tr>
<tr><td><code id="pacfmat_+3A_lag.max">lag.max</code></td>
<td>
<p>maximum number of lag</p>
</td></tr>
</table>


<h3>Value</h3>

<p>out  list with components: 
</p>
<table>
<tr><td><code>M</code></td>
<td>
<p>array with matrices of partial autocovariances divided by their standard error</p>
</td></tr>
<tr><td><code>M1</code></td>
<td>
<p>array with indicators if partial autocovariances are significantly greater (+), lower (-) than the   
critical value or insignificant (.)  </p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>array with matrices of partial autocovariances  </p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>matrix of diagonals of residual covariances (row-wise) </p>
</td></tr>
<tr><td><code>Test</code></td>
<td>
<p>test statistic  </p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>p value of test</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(ICECREAM)
out &lt;- pacfmat(ICECREAM,7) 
</code></pre>

<hr>
<h2 id='PAPER'>Two measurements at a paper machine</h2><span id='topic+PAPER'></span>

<h3>Description</h3>

<p>Two measurements at a paper machine
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PAPER
</code></pre>


<h3>Format</h3>

<p>PAPER is a bivariate time series of length 160  
</p>
 
<dl>
<dt>H</dt><dd><p>High</p>
</dd> 
<dt>W</dt><dd><p>Weight</p>
</dd>  
</dl>



<h3>Source</h3>

<p>Janacek, G. J.  &amp; Swift, L. (1993, ISBN: 978-0139184598) &quot;Time Series: Forecasting, Simulation, Applications&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PAPER)
## maybe  tsp(PAPER) ; plot(PAPER) 
</code></pre>

<hr>
<h2 id='periodogram'><code>periodogram</code> determines the periodogram of a time series</h2><span id='topic+periodogram'></span>

<h3>Description</h3>

<p><code>periodogram</code> determines the periodogram of a time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>periodogram(y, nf, ACF = FALSE, type = "cov")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="periodogram_+3A_y">y</code></td>
<td>
<p>(n,1) vector, the time series or  an  acf at lags 0,1,...,n-1</p>
</td></tr>
<tr><td><code id="periodogram_+3A_nf">nf</code></td>
<td>
<p>scalar, the number of equally spaced frequencies; not necessay an integer</p>
</td></tr>
<tr><td><code id="periodogram_+3A_acf">ACF</code></td>
<td>
<p>logical, FALSE, if y is ts, TRUE, if y is acf</p>
</td></tr>
<tr><td><code id="periodogram_+3A_type">type</code></td>
<td>
<p>c(&quot;cov&quot;,&quot;cor&quot;), area under spectrum, can be variance or normed to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>out  (floor(nf/2)+1,2) matrix, the frequencies and the periodogram
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(WHORMONE)
## periodogram at Fourier frequencies and frequencies 0 and 0.5 
out &lt;-periodogram(WHORMONE,length(WHORMONE)/2,ACF=FALSE,type="cov") 
</code></pre>

<hr>
<h2 id='periodotest'><code>periodotest</code> computes the p-value of the test for a hidden periodicity</h2><span id='topic+periodotest'></span>

<h3>Description</h3>

<p><code>periodotest</code> computes the p-value of the test for a hidden periodicity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>periodotest(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="periodotest_+3A_y">y</code></td>
<td>
<p>vector, the time series</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pval the p-value of the test
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
data(PIGPRICE)
y &lt;- PIGPRICE
out &lt;- stl(y,s.window=6)  
e &lt;- out$time.series[,3]
out &lt;- periodotest(e)
</code></pre>

<hr>
<h2 id='perwinba'><code>perwinba</code> Bartlett-Priestley  window for direct spectral estimation</h2><span id='topic+perwinba'></span>

<h3>Description</h3>

<p><code>perwinba</code> Bartlett-Priestley  window for direct spectral estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perwinba(e, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perwinba_+3A_e">e</code></td>
<td>
<p>equal bandwidth  (at most n frequencies are used for averaging)</p>
</td></tr>
<tr><td><code id="perwinba_+3A_n">n</code></td>
<td>
<p>length of time series</p>
</td></tr>
</table>


<h3>Value</h3>

<p>w   weights (symmetric)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(WHORMONE)
w &lt;- perwinba(0.1,length(WHORMONE)) 

</code></pre>

<hr>
<h2 id='perwinda'><code>perwinda</code> Daniell  window for direct spectral estimation</h2><span id='topic+perwinda'></span>

<h3>Description</h3>

<p><code>perwinda</code> Daniell  window for direct spectral estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perwinda(e, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perwinda_+3A_e">e</code></td>
<td>
<p>equal bandwidth  (at most n frequencies are used for averaging)</p>
</td></tr>
<tr><td><code id="perwinda_+3A_n">n</code></td>
<td>
<p>length of time series</p>
</td></tr>
</table>


<h3>Value</h3>

<p>w   weights (symmetric)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(WHORMONE)
w &lt;- perwinda(0.1,length(WHORMONE)) 

</code></pre>

<hr>
<h2 id='perwinpa'><code>perwinpa</code> Parzen's window for direct spectral estimation</h2><span id='topic+perwinpa'></span>

<h3>Description</h3>

<p><code>perwinpa</code> Parzen's window for direct spectral estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perwinpa(e, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perwinpa_+3A_e">e</code></td>
<td>
<p>equal bandwidth  (at most n frequencies are used for averaging)</p>
</td></tr>
<tr><td><code id="perwinpa_+3A_n">n</code></td>
<td>
<p>length of time series</p>
</td></tr>
</table>


<h3>Value</h3>

<p>w   weights (symmetric)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(WHORMONE)
w &lt;- perwinpa(0.1,length(WHORMONE)) 

</code></pre>

<hr>
<h2 id='pestep'><code>pestep</code> help function for missar</h2><span id='topic+pestep'></span>

<h3>Description</h3>

<p><code>pestep</code> help function for missar
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pestep(f, xt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pestep_+3A_f">f</code></td>
<td>
<p>IACF, inverse ACF</p>
</td></tr>
<tr><td><code id="pestep_+3A_xt">xt</code></td>
<td>
<p>segment of the time series</p>
</td></tr>
</table>


<h3>Value</h3>

<p>xt new version of xt
</p>

<hr>
<h2 id='PIGPRICE'>Monthly prices for pigs</h2><span id='topic+PIGPRICE'></span>

<h3>Description</h3>

<p>Monthly prices for pigs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PIGPRICE
</code></pre>


<h3>Format</h3>

<p>PIGPRICE is a univariate time series of length 240; start January 1894, frequency =12
</p>

<dl>
<dt>PIGPRICE</dt><dd><p>Monthly prices for pigs</p>
</dd>
</dl>



<h3>Source</h3>

<p>Hanau, A. (1928)  &quot;Die Prognose der Schweinepreise&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PIGPRICE)
## maybe  tsp(PIGPRICE) ; plot(PIGPRICE) 
</code></pre>

<hr>
<h2 id='polymake'><code>polymake</code> generates the coefficients of an AR process given the zeros of the
characteristic polynomial. The norm of the roots must be greater than  one  for stationary processes.</h2><span id='topic+polymake'></span>

<h3>Description</h3>

<p><code>polymake</code> generates the coefficients of an AR process given the zeros of the
characteristic polynomial. The norm of the roots must be greater than  one  for stationary processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polymake(r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polymake_+3A_r">r</code></td>
<td>
<p>vector, the zeros of the characteristic polynomial</p>
</td></tr>
</table>


<h3>Value</h3>

<p>C      coefficients (a[1],a[2],...,a[p]) of the polynomial  1 - a[1]z -a[2]z^2 -...- a[p]z^p
</p>


<h3>Examples</h3>

<pre><code class='language-R'>C &lt;- polymake(c(2,-1.5,3))

</code></pre>

<hr>
<h2 id='PPDEMAND'>Peak power demand in Berlin</h2><span id='topic+PPDEMAND'></span>

<h3>Description</h3>

<p>Peak power demand in Berlin
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PPDEMAND
</code></pre>


<h3>Format</h3>

<p>PPDEMAND is a univariate time series of length 37; start 1955, frequency = 1
</p>

<dl>
<dt>PPDEMAND</dt><dd><p>annual peak power demand in Berlin, Megawatt</p>
</dd>
</dl>



<h3>Source</h3>

<p>Fiedler, H. (1979)  &quot;Verschiedene Verfahren zur Prognose des des Stromspitzenbedarfs in Berlin (West)&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PPDEMAND)
## maybe  tsp(PPDEMAND) ; plot(PPDEMAND) 
</code></pre>

<hr>
<h2 id='PRODINDEX'>Production index of manufacturing industries</h2><span id='topic+PRODINDEX'></span>

<h3>Description</h3>

<p>Production index of manufacturing industries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PRODINDEX
</code></pre>


<h3>Format</h3>

<p>PRODINDEX is a univariate time series of length 119:
</p>

<dl>
<dt>PRODINDEX</dt><dd><p>Production index of manufacturing industries</p>
</dd>
</dl>



<h3>Source</h3>

<p>Statistisches Bundesamt (2009)  &lt;https://www-genesis.destatis.de/genesis/online&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PRODINDEX)
## maybe  tsp(PRODINDEX) ; plot(PRODINDEX) 
</code></pre>

<hr>
<h2 id='psifair'><code>psifair</code> is a psi-function for robust estimation</h2><span id='topic+psifair'></span>

<h3>Description</h3>

<p><code>psifair</code> is a psi-function for robust estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psifair(u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psifair_+3A_u">u</code></td>
<td>
<p>vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>out  transformed vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
out &lt;- psifair(c(3.3,-0.7,2.1,1.8))

</code></pre>

<hr>
<h2 id='psihuber'><code>psihuber</code> is a psi-function for robust estimation</h2><span id='topic+psihuber'></span>

<h3>Description</h3>

<p><code>psihuber</code> is a psi-function for robust estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psihuber(u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psihuber_+3A_u">u</code></td>
<td>
<p>vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>out transformed vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- psihuber(c(3.3,-0.7,2.1,1.8)) 

</code></pre>

<hr>
<h2 id='RAINFALL'>Annual amount of rainfall in Los Angeles</h2><span id='topic+RAINFALL'></span>

<h3>Description</h3>

<p>Annual amount of rainfall in Los Angeles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RAINFALL
</code></pre>


<h3>Format</h3>

<p>RAINFALL is a univariate time series of length 119; start 1878, frequency = 1
</p>

<dl>
<dt>RAINFALL</dt><dd><p>Amount of  rainfall in Los Angeles</p>
</dd>
</dl>



<h3>Source</h3>

<p>LA Times (January 28. 1997)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(RAINFALL)
## maybe  tsp(RAINFALL) ; plot(RAINFALL) 
</code></pre>

<hr>
<h2 id='REDWINE'>Monthly sales of Australian red wine (1000 l)</h2><span id='topic+REDWINE'></span>

<h3>Description</h3>

<p>Monthly sales of Australian red wine (1000 l)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>REDWINE
</code></pre>


<h3>Format</h3>

<p>REDWINE is a univariate time series of length 187; start January 1980, frequency =12
</p>

<dl>
<dt>REDWINE</dt><dd><p>Monthly sales of Australian red wine </p>
</dd>
</dl>



<h3>Source</h3>

<p>R package tsdl &lt;https://github.com/FinYang/tsdl&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(REDWINE)
## maybe  tsp(REDWINE) ; plot(REDWINE) 
</code></pre>

<hr>
<h2 id='rlassoHAC'><code>rlassoHAC</code> performs Lasso estimation under heteroscedastic and autocorrelated non-Gaussian disturbances.</h2><span id='topic+rlassoHAC'></span>

<h3>Description</h3>

<p><code>rlassoHAC</code> performs Lasso estimation under heteroscedastic and autocorrelated non-Gaussian disturbances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlassoHAC(
  x,
  y,
  kernel = "Bartlett",
  bands = 10,
  bns = 10,
  lns = NULL,
  nboot = 5000,
  post = TRUE,
  intercept = TRUE,
  model = TRUE,
  X.dependent.lambda = FALSE,
  c = 2,
  gamma = NULL,
  numIter = 15,
  tol = 10^-5,
  threshold = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlassoHAC_+3A_x">x</code></td>
<td>
<p>Regressors (vector, matrix or object can be coerced to matrix).</p>
</td></tr>
<tr><td><code id="rlassoHAC_+3A_y">y</code></td>
<td>
<p>Dependent variable (vector, matrix or object can be coerced to matrix).</p>
</td></tr>
<tr><td><code id="rlassoHAC_+3A_kernel">kernel</code></td>
<td>
<p>Kernel function, choose between &quot;Truncated&quot;, &quot;Bartlett&quot; (by default), &quot;Parzen&quot;, 
&quot;Tukey-Hanning&quot;, &quot;Quadratic Spectral&quot;.</p>
</td></tr>
<tr><td><code id="rlassoHAC_+3A_bands">bands</code></td>
<td>
<p>Bandwidth parameter with default bands=10.</p>
</td></tr>
<tr><td><code id="rlassoHAC_+3A_bns">bns</code></td>
<td>
<p>Block length with default bns=10.</p>
</td></tr>
<tr><td><code id="rlassoHAC_+3A_lns">lns</code></td>
<td>
<p>Number of blocks with default lns = floor(T/bns).</p>
</td></tr>
<tr><td><code id="rlassoHAC_+3A_nboot">nboot</code></td>
<td>
<p>Number of bootstrap iterations with default nboot=5000.</p>
</td></tr>
<tr><td><code id="rlassoHAC_+3A_post">post</code></td>
<td>
<p>Logical. If TRUE (default), post-Lasso estimation is conducted, i.e. a refit of the model with the selected variables.</p>
</td></tr>
<tr><td><code id="rlassoHAC_+3A_intercept">intercept</code></td>
<td>
<p>Logical. If TRUE, intercept is included which is not penalized.</p>
</td></tr>
<tr><td><code id="rlassoHAC_+3A_model">model</code></td>
<td>
<p>Logical. If TRUE (default), model matrix is returned.</p>
</td></tr>
<tr><td><code id="rlassoHAC_+3A_x.dependent.lambda">X.dependent.lambda</code></td>
<td>
<p>Logical, TRUE, if the penalization parameter depends on the design
of the matrix x. FALSE (default), if independent of the design matrix.</p>
</td></tr>
<tr><td><code id="rlassoHAC_+3A_c">c</code></td>
<td>
<p>Constant for the penalty, default value is 2.</p>
</td></tr>
<tr><td><code id="rlassoHAC_+3A_gamma">gamma</code></td>
<td>
<p>Constant for the penalty, default gamma=0.1/log(T) with T=data length.</p>
</td></tr>
<tr><td><code id="rlassoHAC_+3A_numiter">numIter</code></td>
<td>
<p>Number of iterations for the algorithm for the estimation of the variance and
data-driven penalty, ie. loadings.</p>
</td></tr>
<tr><td><code id="rlassoHAC_+3A_tol">tol</code></td>
<td>
<p>Constant tolerance for improvement of the estimated variances.</p>
</td></tr>
<tr><td><code id="rlassoHAC_+3A_threshold">threshold</code></td>
<td>
<p>Constant applied to the final estimated lasso coefficients. Absolute values 
below the threshold are set to zero.</p>
</td></tr>
<tr><td><code id="rlassoHAC_+3A_...">...</code></td>
<td>
<p>further parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rlassoHAC returns an object of class &quot;rlasso&quot;. An object of class &quot;rlasso&quot; is a list containing at least the
following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>Parameter estimates.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>Parameter estimates (named vector of coefficients without intercept). </p>
</td></tr>
<tr><td><code>intercept</code></td>
<td>
<p>Value of the intercept. </p>
</td></tr>
<tr><td><code>index</code></td>
<td>
<p>Index of selected variables (logical vector). </p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>Data-driven penalty term for each variable, product of lambda0 (the penalization parameter) and the loadings. </p>
</td></tr>
<tr><td><code>lambda0</code></td>
<td>
<p>Penalty term. </p>
</td></tr>
<tr><td><code>loadings</code></td>
<td>
<p>Penalty loadings, vector of lenght p (no. of regressors). </p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Residuals, response minus fitted values. </p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Root of the variance of the residuals. </p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Function call. </p>
</td></tr>
<tr><td><code>options</code></td>
<td>
<p>Options. </p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>Model matrix (if model = TRUE in function call). </p>
</td></tr>
</table>


<h3>Source</h3>

<p>Victor Chernozhukov, Chris Hansen, Martin Spindler (2016). hdm: High-Dimensional Metrics,
R Journal, 8(2), 185-199. URL https://journal.r-project.org/archive/2016/RJ-2016-040/index.html.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 

set.seed(1)
T = 100 #sample size
p = 20 # number of variables
b = 5 # number of variables with non-zero coefficients
beta0 = c(rep(10,b), rep(0,p-b))
rho = 0.1 #AR parameter
Cov = matrix(0,p,p)
for(i in 1:p){
  for(j in 1:p){
     Cov[i,j] = 0.5^(abs(i-j))
  }
} 
C &lt;- chol(Cov)
X &lt;- matrix(rnorm(T*p),T,p)%*%C
eps &lt;- arima.sim(list(ar=rho), n = T+100)
eps &lt;- eps[101:(T+100)] 
Y = X%*%beta0 + eps
reg.lasso.hac1 &lt;- rlassoHAC(X, Y,"Bartlett") #lambda is chosen independent of regressor 
                                             #matrix X by default.

bn = 10 # block length
bwNeweyWest = 0.75*(T^(1/3))
reg.lasso.hac2 &lt;- rlassoHAC(X, Y,"Bartlett", bands=bwNeweyWest, bns=bn, nboot=5000,
                            X.dependent.lambda = TRUE, c=2.7) 

</code></pre>

<hr>
<h2 id='rlassoLoad'><code>rlassoLoad</code> performs Lasso estimation under heteroscedastic and autocorrelated non-Gaussian disturbances
with predefined penalty loadings.</h2><span id='topic+rlassoLoad'></span>

<h3>Description</h3>

<p><code>rlassoLoad</code> performs Lasso estimation under heteroscedastic and autocorrelated non-Gaussian disturbances
with predefined penalty loadings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlassoLoad(
  x,
  y,
  load,
  bns = 10,
  lns = NULL,
  nboot = 5000,
  post = TRUE,
  intercept = TRUE,
  model = TRUE,
  X.dependent.lambda = FALSE,
  c = 2,
  gamma = NULL,
  numIter = 15,
  tol = 10^-5,
  threshold = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlassoLoad_+3A_x">x</code></td>
<td>
<p>Regressors (vector, matrix or object can be coerced to matrix).</p>
</td></tr>
<tr><td><code id="rlassoLoad_+3A_y">y</code></td>
<td>
<p>Dependent variable (vector, matrix or object can be coerced to matrix).</p>
</td></tr>
<tr><td><code id="rlassoLoad_+3A_load">load</code></td>
<td>
<p>Penalty loadings, vector of length p (no. of regressors).</p>
</td></tr>
<tr><td><code id="rlassoLoad_+3A_bns">bns</code></td>
<td>
<p>Block length with default bns=10.</p>
</td></tr>
<tr><td><code id="rlassoLoad_+3A_lns">lns</code></td>
<td>
<p>Number of blocks with default lns = floor(T/bns).</p>
</td></tr>
<tr><td><code id="rlassoLoad_+3A_nboot">nboot</code></td>
<td>
<p>Number of bootstrap iterations with default nboot=5000.</p>
</td></tr>
<tr><td><code id="rlassoLoad_+3A_post">post</code></td>
<td>
<p>Logical. If TRUE (default), post-Lasso estimation is conducted, i.e. a refit of the model with the selected variables.</p>
</td></tr>
<tr><td><code id="rlassoLoad_+3A_intercept">intercept</code></td>
<td>
<p>Logical. If TRUE, intercept is included which is not penalized.</p>
</td></tr>
<tr><td><code id="rlassoLoad_+3A_model">model</code></td>
<td>
<p>Logical. If TRUE (default), model matrix is returned.</p>
</td></tr>
<tr><td><code id="rlassoLoad_+3A_x.dependent.lambda">X.dependent.lambda</code></td>
<td>
<p>Logical, TRUE, if the penalization parameter depends on the design
of the matrix x. FALSE (default), if independent of the design matrix.</p>
</td></tr>
<tr><td><code id="rlassoLoad_+3A_c">c</code></td>
<td>
<p>Constant for the penalty default is 2.</p>
</td></tr>
<tr><td><code id="rlassoLoad_+3A_gamma">gamma</code></td>
<td>
<p>Constant for the penalty default gamma=0.1/log(T) with T=data length.</p>
</td></tr>
<tr><td><code id="rlassoLoad_+3A_numiter">numIter</code></td>
<td>
<p>Number of iterations for the algorithm for the estimation of the variance and data-driven penalty.</p>
</td></tr>
<tr><td><code id="rlassoLoad_+3A_tol">tol</code></td>
<td>
<p>Constant tolerance for improvement of the estimated variances.</p>
</td></tr>
<tr><td><code id="rlassoLoad_+3A_threshold">threshold</code></td>
<td>
<p>Constant applied to the final estimated lasso coefficients. Absolute values 
below the threshold are set to zero.</p>
</td></tr>
<tr><td><code id="rlassoLoad_+3A_...">...</code></td>
<td>
<p>further parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rlassoLoad returns an object of class &quot;rlasso&quot;. An object of class &quot;rlasso&quot; is a list containing at least the
following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>Parameter estimates.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>Parameter estimates (named vector of coefficients without intercept). </p>
</td></tr>
<tr><td><code>intercept</code></td>
<td>
<p>Value of the intercept. </p>
</td></tr>
<tr><td><code>index</code></td>
<td>
<p>Index of selected variables (logical vector). </p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>Data-driven penalty term for each variable, product of lambda0 (the penalization parameter) and the loadings. </p>
</td></tr>
<tr><td><code>lambda0</code></td>
<td>
<p>Penalty term. </p>
</td></tr>
<tr><td><code>loadings</code></td>
<td>
<p>Penalty loadings, vector of lenght p (no. of regressors). </p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Residuals, response minus fitted values. </p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Root of the variance of the residuals. </p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Function call. </p>
</td></tr>
<tr><td><code>options</code></td>
<td>
<p>Options. </p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>Model matrix (if model = TRUE in function call). </p>
</td></tr>
</table>


<h3>Source</h3>

<p>Victor Chernozhukov, Chris Hansen, Martin Spindler (2016). hdm: High-Dimensional Metrics,
R Journal, 8(2), 185-199. URL https://journal.r-project.org/archive/2016/RJ-2016-040/index.html.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
set.seed(1)
T = 100 #sample size
p = 20 # number of variables
b = 5 # number of variables with non-zero coefficients
beta0 = c(rep(10,b), rep(0,p-b))
rho = 0.1 #AR parameter
Cov = matrix(0,p,p)
for(i in 1:p){
  for(j in 1:p){
     Cov[i,j] = 0.5^(abs(i-j))
  }
} 
C &lt;- chol(Cov)
X &lt;- matrix(rnorm(T*p),T,p)%*%C
eps &lt;- arima.sim(list(ar=rho), n = T+100)
eps &lt;- eps[101:(T+100)] 
Y = X%*%beta0 + eps

fit1 =  rlasso(X, Y, penalty = list(homoscedastic = "none",
              lambda.start = 2*0.5*sqrt(T)*qnorm(1-0.1/(2*p))), post=FALSE)
beta = fit1$beta
intercept = fit1$intercept
res = Y - X %*% beta - intercept * rep(1, length(Y))

load = rep(0,p)
for(i in 1:p){
  load[i] = sqrt(lrvar(X[,i]*res)*T)
  }
reg.lasso.load1 &lt;- rlassoLoad(X,Y,load) #lambda is chosen independent of regressor 
                                             #matrix X by default.

bn = 10 # block length
reg.lasso.load2 &lt;- rlassoLoad(X, Y,load, bns=bn, nboot=5000,
                            X.dependent.lambda = TRUE, c=2.7)
 
</code></pre>

<hr>
<h2 id='robsplinedecomp'><code>robsplinedecomp</code> decomposes a vector into trend, season and irregular  component
by robustified spline approach; a time series attribute is lost</h2><span id='topic+robsplinedecomp'></span>

<h3>Description</h3>

<p><code>robsplinedecomp</code> decomposes a vector into trend, season and irregular  component
by robustified spline approach; a time series attribute is lost
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robsplinedecomp(y, d, alpha, beta, Plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="robsplinedecomp_+3A_y">y</code></td>
<td>
<p>the series, a vector or a time series</p>
</td></tr>
<tr><td><code id="robsplinedecomp_+3A_d">d</code></td>
<td>
<p>seasonal period</p>
</td></tr>
<tr><td><code id="robsplinedecomp_+3A_alpha">alpha</code></td>
<td>
<p>smoothing parameter for trend component   (the larger alpha is, the smoother will the smooth component g be)</p>
</td></tr>
<tr><td><code id="robsplinedecomp_+3A_beta">beta</code></td>
<td>
<p>smoothing parameter for  seasonal  component</p>
</td></tr>
<tr><td><code id="robsplinedecomp_+3A_plot">Plot</code></td>
<td>
<p>logical, should a plot be produced?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>out   list with the elements trend, season, residual
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(GDP) 
out  &lt;- robsplinedecomp(GDP,4,2,10,Plot=FALSE) 
</code></pre>

<hr>
<h2 id='RS'><code>RS</code> rescaled adjusted range statistic</h2><span id='topic+RS'></span>

<h3>Description</h3>

<p><code>RS</code> rescaled adjusted range statistic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RS(x, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RS_+3A_x">x</code></td>
<td>
<p>univariate time series</p>
</td></tr>
<tr><td><code id="RS_+3A_k">k</code></td>
<td>
<p>length of the segments for which the statistic is computed. Starting with t=1, the segments do not overlap.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(l,3)-matrix, 1. column: k, second column: starting time of segment, third column: value of RS statistic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
 data(TREMOR)
 R &lt;- RS(TREMOR,10)  
</code></pre>

<hr>
<h2 id='SALES'>Monthly sales of a company</h2><span id='topic+SALES'></span>

<h3>Description</h3>

<p>Monthly sales of a company
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SALES
</code></pre>


<h3>Format</h3>

<p>SALES is a univariate time series of length 77:
</p>

<dl>
<dt>y</dt><dd><p>monthly  sales of a company</p>
</dd>
</dl>



<h3>Source</h3>

<p>Newton, H. J. (1988, ISBN: 978-0534091989): &quot;TIMESLAB: A time series analysis laboraty&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SALES)
## maybe  tsp(SALES) ; plot(SALES) 
</code></pre>

<hr>
<h2 id='SCHAUINSLAND'>CO2-Concentration obtained in Schauinsland, Germany</h2><span id='topic+SCHAUINSLAND'></span>

<h3>Description</h3>

<p>CO2-Concentration obtained in Schauinsland, Germany
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SCHAUINSLAND
</code></pre>


<h3>Format</h3>

<p>SCHAUINSLAND is a univariate time series of length 72:
</p>

<dl>
<dt>SCHAUINSLAND</dt><dd><p>CO2-Concentration obtained in Schauinsland</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;http://cdiac.ornl.gov/trends/co2/uba/uba-sc.html&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SCHAUINSLAND)
## maybe  tsp(SCHAUINSLAND) ; plot(SCHAUINSLAND) 
</code></pre>

<hr>
<h2 id='simpledecomp'><code>simpledecomp</code> decomposes a vector into trend, season and irregular component
by linear regression approach</h2><span id='topic+simpledecomp'></span>

<h3>Description</h3>

<p><code>simpledecomp</code> decomposes a vector into trend, season and irregular component
by linear regression approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simpledecomp(y, trend = 0, season = 0, Plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simpledecomp_+3A_y">y</code></td>
<td>
<p>the series, a vector or a time series</p>
</td></tr>
<tr><td><code id="simpledecomp_+3A_trend">trend</code></td>
<td>
<p>order of trend polynomial</p>
</td></tr>
<tr><td><code id="simpledecomp_+3A_season">season</code></td>
<td>
<p>period of seasonal component</p>
</td></tr>
<tr><td><code id="simpledecomp_+3A_plot">Plot</code></td>
<td>
<p>logical, should a plot be produced?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>out:  (n,3) matrix
</p>
<table>
<tr><td><code>1. column</code></td>
<td>
<p>smooth component </p>
</td></tr>
<tr><td><code>2. column</code></td>
<td>
<p>seasonal component </p>
</td></tr>
<tr><td><code>3. column</code></td>
<td>
<p>irregular component  </p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(GDP)
out  &lt;- simpledecomp(GDP,trend=3,season=4,Plot=FALSE) 
</code></pre>

<hr>
<h2 id='smoothls'><code>smoothls</code> smoothes a time series by Whittaker graduation.  
The function depends on  the package Matrix.</h2><span id='topic+smoothls'></span>

<h3>Description</h3>

<p><code>smoothls</code> smoothes a time series by Whittaker graduation.  
The function depends on  the package Matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothls(y, beta = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoothls_+3A_y">y</code></td>
<td>
<p>the series, a vector or a time series</p>
</td></tr>
<tr><td><code id="smoothls_+3A_beta">beta</code></td>
<td>
<p>smoothing parameter  &gt;=0 (the larger beta is, the smoother will g be)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>g     vector,  smooth component
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
data(GDP)
g &lt;- smoothls(GDP,12)

 plot(GDP)   
 t &lt;- seq(from = tsp(GDP)[1], to = tsp(GDP)[2],by=1/tsp(GDP)[3]) ; lines(t,g,col="red")  
</code></pre>

<hr>
<h2 id='smoothrb'><code>smoothrb</code> smoothes a time series robustly by using Huber's psi-function. 
The initialisation uses a moving median.</h2><span id='topic+smoothrb'></span>

<h3>Description</h3>

<p><code>smoothrb</code> smoothes a time series robustly by using Huber's psi-function. 
The initialisation uses a moving median.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothrb(y, beta = 0, q = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoothrb_+3A_y">y</code></td>
<td>
<p>the series, a vector or a time series</p>
</td></tr>
<tr><td><code id="smoothrb_+3A_beta">beta</code></td>
<td>
<p>smoothing parameter (The larger beta is, the smoother will the smooth component g be.)</p>
</td></tr>
<tr><td><code id="smoothrb_+3A_q">q</code></td>
<td>
<p>length of running median which is used to get initial values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>g       vector,  the smooth component
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(GDP)
g  &lt;- smoothrb(GDP,8,q=8)
 
 plot(GDP) ; t &lt;- seq(from = 1970, to = 2009.5,by=0.25) ; lines(t,g,col="red")  
</code></pre>

<hr>
<h2 id='specest'><code>specest</code>  direct spectral estimation of series y
using periodogram window win</h2><span id='topic+specest'></span>

<h3>Description</h3>

<p><code>specest</code>  direct spectral estimation of series y
using periodogram window win
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specest(
  y,
  nf,
  e,
  win = c("perwinba", "perwinpa", "perwinda"),
  conf = 0,
  type = "cov"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="specest_+3A_y">y</code></td>
<td>
<p>(n,1) vector, the ts</p>
</td></tr>
<tr><td><code id="specest_+3A_nf">nf</code></td>
<td>
<p>number of equally spaced frequencies</p>
</td></tr>
<tr><td><code id="specest_+3A_e">e</code></td>
<td>
<p>equal bandwidth, must be 0 &lt;= e &lt;0.5</p>
</td></tr>
<tr><td><code id="specest_+3A_win">win</code></td>
<td>
<p>string, name of periodogram window
(possible: &quot;perwinba&quot;, &quot;perwinpa&quot;, &quot;perwinda&quot;)</p>
</td></tr>
<tr><td><code id="specest_+3A_conf">conf</code></td>
<td>
<p>scalar, the level for confidence intervals</p>
</td></tr>
<tr><td><code id="specest_+3A_type">type</code></td>
<td>
<p>c(&quot;cov&quot;,&quot;cor&quot;), area under spectrum is variance or is normed to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>est  (nf+1,2)- or (nf+1,4)-matrix:   
</p>
<table>
<tr><td><code>column 1:</code></td>
<td>
<p>frequencies 0, 1/n, 2/n, ..., m/n </p>
</td></tr>
<tr><td><code>column 2:</code></td>
<td>
<p>the estimated spectrum  </p>
</td></tr>
<tr><td><code>column 3+4:</code></td>
<td>
<p>the confidence bounds   </p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(WHORMONE)
est &lt;- specest(WHORMONE,50,0.05,win = c("perwinba","perwinpa","perwinda"),conf=0,type="cov") 

</code></pre>

<hr>
<h2 id='specplot'><code>specplot</code>    plot of spectral estimate</h2><span id='topic+specplot'></span>

<h3>Description</h3>

<p><code>specplot</code>    plot of spectral estimate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specplot(s, Log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="specplot_+3A_s">s</code></td>
<td>
<p>(n,2) or (n,4) matrix, output of specest</p>
</td></tr>
<tr><td><code id="specplot_+3A_log">Log</code></td>
<td>
<p>logical, if TRUE, the logs of the spectral estimates are shown</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(WHORMONE)
est &lt;- specest(WHORMONE,50,0.05,win = c("perwinba","perwinpa"),conf=0,type="cov") 
specplot(est,Log=FALSE) 
</code></pre>

<hr>
<h2 id='splinedecomp'><code>splinedecomp</code> decomposes a time series into trend, season and irregular component
by spline approach.</h2><span id='topic+splinedecomp'></span>

<h3>Description</h3>

<p><code>splinedecomp</code> decomposes a time series into trend, season and irregular component
by spline approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splinedecomp(x, d, alpha, beta, Plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splinedecomp_+3A_x">x</code></td>
<td>
<p>the series, a vector or a time series</p>
</td></tr>
<tr><td><code id="splinedecomp_+3A_d">d</code></td>
<td>
<p>seasonal period</p>
</td></tr>
<tr><td><code id="splinedecomp_+3A_alpha">alpha</code></td>
<td>
<p>smoothing parameter for trend component   (The larger alpha is, the smoother will the smooth component g be.)</p>
</td></tr>
<tr><td><code id="splinedecomp_+3A_beta">beta</code></td>
<td>
<p>smoothing parameter for  seasonal component</p>
</td></tr>
<tr><td><code id="splinedecomp_+3A_plot">Plot</code></td>
<td>
<p>logical, should a plot be produced?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>out (n,3) matrix:
</p>
<table>
<tr><td><code>1. column</code></td>
<td>
<p>smooth component </p>
</td></tr>
<tr><td><code>2. column</code></td>
<td>
<p>seasonal component </p>
</td></tr>
<tr><td><code>3. column</code></td>
<td>
<p>irregular component    </p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(GDP)
out  &lt;- splinedecomp(GDP,4,2,4,Plot=FALSE) 
</code></pre>

<hr>
<h2 id='SPRUCE'>Annual logging of spruce wood.</h2><span id='topic+SPRUCE'></span>

<h3>Description</h3>

<p>Annual logging of spruce wood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SPRUCE
</code></pre>


<h3>Format</h3>

<p>SPRUCE is a univariate time series of length 42: 
</p>

<dl>
<dt>SPRUCE</dt><dd><p>Annual logging of spruce wood</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(SPRUCE)
## maybe  tsp(SPRUCE) ; plot(SPRUCE) 
</code></pre>

<hr>
<h2 id='statcheck'><code>statcheck</code> determines the means, standard deviations and acf's of segmets of a time series 
and plots the acf's for the segments.</h2><span id='topic+statcheck'></span>

<h3>Description</h3>

<p><code>statcheck</code> determines the means, standard deviations and acf's of segmets of a time series 
and plots the acf's for the segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statcheck(y, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="statcheck_+3A_y">y</code></td>
<td>
<p>the series, a vector or a time series</p>
</td></tr>
<tr><td><code id="statcheck_+3A_d">d</code></td>
<td>
<p>scalar, number of segments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>out list with components:
</p>
<table>
<tr><td><code>ms</code></td>
<td>
<p>matrix with means and standard deviations of the segments  </p>
</td></tr>
<tr><td><code>ac</code></td>
<td>
<p>matrix with acf's, the first column: acf of the series, the others: acf's  of the segments  </p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(COFFEE)  
out &lt;- statcheck(COFFEE,4)   
</code></pre>

<hr>
<h2 id='subsets'><code>subsets</code> determines all subsets of  a set of n elements (labelled by  1,2,...,n ).</h2><span id='topic+subsets'></span>

<h3>Description</h3>

<p><code>subsets</code> determines all subsets of  a set of n elements (labelled by  1,2,...,n ).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsets(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsets_+3A_n">n</code></td>
<td>
<p>scalar, integer &gt;= 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mat (2^n,n)-matrix, each row gives the membership indicators of the elements 1,2,...,n
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- subsets(4)

</code></pre>

<hr>
<h2 id='symplot'><code>symplot</code> produces a symmetry plot</h2><span id='topic+symplot'></span>

<h3>Description</h3>

<p><code>symplot</code> produces a symmetry plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symplot(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symplot_+3A_y">y</code></td>
<td>
<p>the series, a vector or a time series</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(LYNX)
symplot(LYNX)   
</code></pre>

<hr>
<h2 id='taper'><code>taper</code> taper modification of a time series</h2><span id='topic+taper'></span>

<h3>Description</h3>

<p><code>taper</code> taper modification of a time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taper(y, part)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="taper_+3A_y">y</code></td>
<td>
<p>the time series</p>
</td></tr>
<tr><td><code id="taper_+3A_part">part</code></td>
<td>
<p>scalar, 0 &lt;= part &lt;= 0.5, part of modification (at each end of y)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tp   tapered time series
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(WHORMONE)
out &lt;-taper(WHORMONE,0.3)
 
plot(WHORMONE) 
lines(out,col="red") 
</code></pre>

<hr>
<h2 id='TAXES'>Monthly community taxes in Germany (billions EURO)</h2><span id='topic+TAXES'></span>

<h3>Description</h3>

<p>Monthly community taxes in Germany (billions EURO)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TAXES
</code></pre>


<h3>Format</h3>

<p>TAXES is a univariate time series of length 246; start January 1999, frequency = 12
</p>

<dl>
<dt>TAXES</dt><dd><p>monthly community taxes in Germany</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;https://www-genesis.destatis.de/genesis/online?operation=previous&amp;levelindex=1&amp;step=1&amp;titel= <br /> Tabellenaufbau&amp;levelid=1583748637039&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(TAXES)
## maybe  tsp(TAXES) ; plot(TAXES) 
</code></pre>

<hr>
<h2 id='TREERING'>Mean thickness of annual tree rings</h2><span id='topic+TREERING'></span>

<h3>Description</h3>

<p>Mean thickness of annual tree rings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TREERING
</code></pre>


<h3>Format</h3>

<p>TREERING is a multivariate time series of length 66  with 3 variables:
</p>

<dl>
<dt>THICK</dt><dd><p>mean thickness of annual tree rings</p>
</dd>                                 
<dt>TEMP</dt><dd><p>mean temperature of the year</p>
</dd>             
<dt>RAIN</dt><dd><p>amount of rain of the year</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;https://ltrr.arizona.edu/&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(TREERING)
## maybe  tsp(TREERING) ; plot(TREERING) 
</code></pre>

<hr>
<h2 id='TREMOR'>Measurements of physiological tremor</h2><span id='topic+TREMOR'></span>

<h3>Description</h3>

<p>Measurements of physiological tremor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TREMOR
</code></pre>


<h3>Format</h3>

<p>TREMOR is a univariate time series of length 400.
</p>

<dl>
<dt>TREMOR</dt><dd><p>Tremor</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(TREMOR)
## maybe  tsp(TREMOR) ; plot(TREMOR) 
</code></pre>

<hr>
<h2 id='tsmat'><code>tsmat</code> constructs a (n-p+1,p) matrix from a time series 
where the first column is the shortened series y[p],...,y[n], the second is y[p-1],...,y[n-1],  etc.</h2><span id='topic+tsmat'></span>

<h3>Description</h3>

<p><code>tsmat</code> constructs a (n-p+1,p) matrix from a time series 
where the first column is the shortened series y[p],...,y[n], the second is y[p-1],...,y[n-1],  etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsmat(y, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsmat_+3A_y">y</code></td>
<td>
<p>the series, a vector or a time series of length n</p>
</td></tr>
<tr><td><code id="tsmat_+3A_p">p</code></td>
<td>
<p>desired number of columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mat (n-p+1,p) matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- tsmat(c(1:20),4)

</code></pre>

<hr>
<h2 id='USAPOP'>Population of USA</h2><span id='topic+USAPOP'></span>

<h3>Description</h3>

<p>Population of USA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>USAPOP
</code></pre>


<h3>Format</h3>

<p>USAPOP is a univariate time series  of length 39; start 1630, frequency = 0.1 
</p>

<dl>
<dt>USAPOP</dt><dd><p>Population of USA</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;https://www.worldometers.info/world-population/us-population/&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(USAPOP)
## maybe  tsp(USAPOP) ; plot(USAPOP) 
</code></pre>

<hr>
<h2 id='vartable'><code>vartable</code> determines table of variate differences</h2><span id='topic+vartable'></span>

<h3>Description</h3>

<p><code>vartable</code> determines table of variate differences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vartable(y, season)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vartable_+3A_y">y</code></td>
<td>
<p>the series, a vector or a time series  ( no NA's )</p>
</td></tr>
<tr><td><code id="vartable_+3A_season">season</code></td>
<td>
<p>scalar, period of seasonal component</p>
</td></tr>
</table>


<h3>Value</h3>

<p>d      matrix with ratios of variances for differend numbers of simple and seasonal differencing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(GDP)
out &lt;- vartable(GDP,4) 

</code></pre>

<hr>
<h2 id='WHORMONE'>Concentration of growth hormone of a bull</h2><span id='topic+WHORMONE'></span>

<h3>Description</h3>

<p>Concentration of growth hormone of a bull
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WHORMONE
</code></pre>


<h3>Format</h3>

<p>WHORMONE is a univariate time series of length 97:
</p>

<dl>
<dt>WHORMONE</dt><dd><p>Concentration of growth hormone of a bull</p>
</dd>
</dl>



<h3>Source</h3>

<p>Newton, H. J. (1988, ISBN: 978-0534091989): &quot;TIMESLAB: A time series analysis laboraty&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(WHORMONE)
## maybe  tsp(WHORMONE) ; plot(WHORMONE) 
</code></pre>

<hr>
<h2 id='wntest'><code>wntest</code>   graphical test for white noise for a time series  or a series of regression residuals</h2><span id='topic+wntest'></span>

<h3>Description</h3>

<p><code>wntest</code>   graphical test for white noise for a time series  or a series of regression residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wntest(e, a, k = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wntest_+3A_e">e</code></td>
<td>
<p>vector, the time series (k = 0) or residuals (k &gt; 0)</p>
</td></tr>
<tr><td><code id="wntest_+3A_a">a</code></td>
<td>
<p>scalar, level of significance</p>
</td></tr>
<tr><td><code id="wntest_+3A_k">k</code></td>
<td>
<p>scalar &gt;= 0, number of regressors used to compute e as residuals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tp vector,  value of test statistic and  p-value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(WHORMONE)
out &lt;- wntest(WHORMONE,0.05,0) 
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
