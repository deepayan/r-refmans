<!DOCTYPE html><html lang="en"><head><title>Help for package CodeDepends</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CodeDepends}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#asVarName'>
<p>asVarName</p></a></li>
<li><a href='#findWhenUnneeded'><p>Determine the code block after which a variable can be explicitly</p>
removed</a></li>
<li><a href='#funchandlers'><p>Specifying custom processing behavior, Function handlers and handler factories</p></a></li>
<li><a href='#getDependsThread'><p>Compute which code blocks in a script are inputs to define a variable</p></a></li>
<li><a href='#getDetailedTimelines'><p>Compute and plot life cycle of variables in code</p></a></li>
<li><a href='#getExpressionThread'><p>Find the sequence of expressions needed to get to a certain point in the code</p></a></li>
<li><a href='#getInputs'><p>Get input and output variables and literals from R expressions</p></a></li>
<li><a href='#getPropagateChanges'><p>Determine which expressions to update when a variable changes</p></a></li>
<li><a href='#getVariableDepends'><p>Determine dependencies for code blocks</p></a></li>
<li><a href='#getVariables'><p>Get the names of the variables used in code</p></a></li>
<li><a href='#guessTaskType'><p>Guess the type of high-level task of a code block</p></a></li>
<li><a href='#highlightCode'><p>Display R code with highlighting of variables, links to functions</p>
and packages</a></li>
<li><a href='#historyAsScript'><p>Convert R interactive history to a Script object</p></a></li>
<li><a href='#inputCollector'>
<p>Create customized input/output collector for use in getInputs</p></a></li>
<li><a href='#makeCallGraph'><p>Create a graph representing which functions call other functions</p></a></li>
<li><a href='#makeTaskGraph'><p>Create a graph connecting the tasks within a script</p></a></li>
<li><a href='#makeVariableGraph'><p>Create a graph describing the relationships between variables in</p>
a script</a></li>
<li><a href='#readScript'><p>Read the code blocks/chunks from a document</p></a></li>
<li><a href='#runUpToSection'><p>Evaluate the code blocks up to a particular section of a document</p></a></li>
<li><a href='#Script-class'><p>The Script class and elements</p></a></li>
<li><a href='#separateExpressionBlocks'><p>Convert a script into individual top-level calls</p></a></li>
<li><a href='#sourceVariable'><p>Evaluate code in document in order to define the specified variables</p></a></li>
<li><a href='#splitRedefinitions'><p>Divide a script into separate lists of code based on redefinition</p>
of a variable</a></li>
<li><a href='#updatingScript'><p>Create a Script object that re-reads the original file as needed</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.6.6</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of R Code for Reproducible Research and Code
Comprehension</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for analyzing R expressions
  or blocks of code and determining the dependencies between them.
  It focuses on R scripts, but can be used on the bodies of functions.
  There are many facilities including the ability to summarize  or get a high-level
  view of code, determining dependencies between variables,  code improvement
  suggestions.</td>
</tr>
<tr>
<td>Author:</td>
<td>Duncan Temple Lang, Roger Peng, Deborah Nolan, Gabriel Becker</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gabriel Becker &lt;gabembecker@gmail.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/duncantl/CodeDepends">https://github.com/duncantl/CodeDepends</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/duncantl/CodeDepends/issues">https://github.com/duncantl/CodeDepends/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>codetools, graph, XML, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Rgraphviz, RUnit, knitr, highlight, RJSONIO, RCurl, Rcpp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>classes.R librarySymbols.R functionHandlers.R codeDepends.R
sectionDepends.R sweave.R xml.R jss.R frags.R codeTypes.R gc.R
graph.R parallel.R deps.R separateBlocks.R callGraph.R isPlot.R
isOutput.R refScript.R sideEffects.R highlightCode.R
freeVariables.R convenienceFuns.R</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-07 21:08:18 UTC; gbecker</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-07 23:03:14 UTC</td>
</tr>
</table>
<hr>
<h2 id='asVarName'>
asVarName
</h2><span id='topic+asVarName'></span>

<h3>Description</h3>

<p>This function grabs a symbol out of an expression and returns it as a
character (see details for which symbol will be used).
</p>
<p>This is a convenience function for use when constructing custom function
handlers, it's unlikely to have much utility outside of that context.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asVarName(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="asVarName_+3A_x">x</code></td>
<td>
<p>The (sub)expression to extract a symbol from
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function always returns a character vector representing a single
symbol from <code>x</code>, but which code varies depending on the exact form
of <code>x</code>. When
</p>

<dl>
<dt><code>x</code> is a single symbol</dt><dd><p>the character representation of the symbol is returned</p>
</dd>
<dt><code>x</code> is a function call</dt><dd><p>asVarName is recursively called on
the sub-expression for the first argument</p>
</dd>
<dt><code>x</code> is an assignment</dt><dd><p>asVarName is called recursively on the
right-hand side (after <code>-&gt;</code> expressions are transformed to
<code>&lt;-</code> ones). This is a special case of the rule above.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A character vector of length one representing the symbol (or literal) as
described in the Details section.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>asVarName(quote(rnorm(x, y, z))) # "x"
asVarName(quote(rnorm(x, y, z))[[1]] ) # "rnorm" b/c [[1]] is called fun
asVarName(quote(rownames(a) &lt;- b )) # "a"
asVarName(quote(rnorm(10, y, z))) # "10"
</code></pre>

<hr>
<h2 id='findWhenUnneeded'>Determine the code block after which a variable can be explicitly
removed</h2><span id='topic+findWhenUnneeded'></span><span id='topic+addRemoveIntermediates'></span>

<h3>Description</h3>

<p>These functions analyze the meta-information about code blocks
and determine when a variable is no longer needed and
can add code to the relevant code block to remove the variable. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findWhenUnneeded(var, frags, info = lapply(frags, getInputs), simplify,
                 index = TRUE, end = NA, redefined = FALSE)
addRemoveIntermediates(doc, frags = readScript(doc),
                       info = getInputs(frags),
                       vars = getVariables(info))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findWhenUnneeded_+3A_var">var</code></td>
<td>
<p>the name of the variable(s) whose final </p>
</td></tr> <tr><td><code id="findWhenUnneeded_+3A_doc">doc</code></td>
<td>
<p>the
location of the script, given as a file name or a connection</p>
</td></tr>
<tr><td><code id="findWhenUnneeded_+3A_frags">frags</code></td>
<td>
<p>an object of class <code>Script</code> which is a list containing
the code blocks in the script. This is typically obtained via a call to
<code><a href="#topic+readScript">readScript</a></code>.</p>
</td></tr>  <tr><td><code id="findWhenUnneeded_+3A_info">info</code></td>
<td>
<p>an object of class
<code>ScriptInfo</code> which is a list of <code>ScriptNodeInfo</code> objects.</p>
</td></tr>
<tr><td><code id="findWhenUnneeded_+3A_simplify">simplify</code></td>
<td>
<p>ignored</p>
</td></tr> <tr><td><code id="findWhenUnneeded_+3A_index">index</code></td>
<td>
<p>a logical value indicating whether
<code>findWhenUnneeded</code> should return the indices of the code
blocks/fragments or the code fragments themselves.</p>
</td></tr>  <tr><td><code id="findWhenUnneeded_+3A_vars">vars</code></td>
<td>
<p>the
names of all the variables of interest</p>
</td></tr> <tr><td><code id="findWhenUnneeded_+3A_end">end</code></td>
<td>
<p>the value to use if
the variable is used in the last code block, i.e. the end of the
script.</p>
</td></tr>  <tr><td><code id="findWhenUnneeded_+3A_redefined">redefined</code></td>
<td>
<p>a logical value which controls whether we
return the earliest code block in which the variable is redefined rather
than when the variable is no longer used.  Redefinition is a kind of
&quot;no longer being used&quot; but for the value, not the variable.  </p>
</td></tr> </table>


<h3>Value</h3>

<p>A vector of indices indicating the last expression in which each of
the specified  variables is an input.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>See Also</h3>

<p><code><a href="#topic+readScript">readScript</a></code>
<code><a href="#topic+addRemoveIntermediates">addRemoveIntermediates</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f = system.file("samples", "cleanVars.R", package = "CodeDepends")
sc = readScript(f)
findWhenUnneeded("x", sc)
findWhenUnneeded(c("x", "y"), sc)  

# z is never used
findWhenUnneeded("z", sc)
findWhenUnneeded("z", sc, end = 1L)  

code = addRemoveIntermediates(f)
 # Note that rm(x), rm(y) and rm(d) are added.
code[c(4, 5, 6)]
</code></pre>

<hr>
<h2 id='funchandlers'>Specifying custom processing behavior, Function handlers and handler factories</h2><span id='topic+libreqhandler'></span><span id='topic+rmhandler'></span><span id='topic+dollarhandler'></span><span id='topic+assignhandler'></span><span id='topic+assignfunhandler'></span><span id='topic+funchandler'></span><span id='topic+formulahandler'></span><span id='topic+fullnsehandler'></span><span id='topic+nseafterfirst'></span><span id='topic+nsehandlerfactory'></span><span id='topic+groupbyhandler'></span><span id='topic+counthandler'></span><span id='topic+spreadhandler'></span><span id='topic+colonshandler'></span><span id='topic+pipehandler'></span><span id='topic+forhandler'></span><span id='topic+datahandler'></span><span id='topic+filterhandler'></span><span id='topic+funshandler'></span><span id='topic+applyhandlerfactory'></span><span id='topic+summarize_handlerfactory'></span><span id='topic+noophandler'></span><span id='topic+defhandler'></span><span id='topic+defaultFuncHandlers'></span><span id='topic+functionhandlers'></span><span id='topic+nseonlyhandlerfactory'></span>

<h3>Description</h3>

<p>Custom behavior when processing calls to certain functions is
implemented by specifying <em>function handlers</em> for those
functions. This can be used to alter CodeDepends' behavior when it
sees these functions, or if desired, to ignore them entirely when
processing the parent expression.
</p>
<p>Function handlers should never be called directly by end users.
</p>
<p>CodeDepends attempts to provide reasonable defaults, in the form of
the <code>defaultFuncHandlers</code> list, which should be suitable for most
users.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="funchandlers_+3A_e">e</code></td>
<td>
<p>The (sub)expression being processed. This will be a call to
the function your handler is assigned to work on.</p>
</td></tr>
<tr><td><code id="funchandlers_+3A_collector">collector</code></td>
<td>
<p>The input collector in use. Represents state as the
expression tree is walked.</p>
</td></tr>
<tr><td><code id="funchandlers_+3A_basedir">basedir</code></td>
<td>
<p>The base directory when checking if a string literal is
a file path</p>
</td></tr>
<tr><td><code id="funchandlers_+3A_input">input</code></td>
<td>
<p>Are we in a part of the whole expression that specifies
inputs</p>
</td></tr>
<tr><td><code id="funchandlers_+3A_formulainputs">formulaInputs</code></td>
<td>
<p>Are symbols within formulas to be counted as
inputs (<code>TRUE</code>) or non-standardly evaluated variables
(<code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="funchandlers_+3A_update">update</code></td>
<td>
<p>Are we in a part of the expression that indicates a
variable's value is being updated (i.e., complex right hand side)</p>
</td></tr>
<tr><td><code id="funchandlers_+3A_pipe">pipe</code></td>
<td>
<p>Are we in a direct pipe call</p>
</td></tr>
<tr><td><code id="funchandlers_+3A_nseval">nseval</code></td>
<td>
<p>Should any symbols that appear to be inputs be treated
as nonstandardly-evaluated instead</p>
</td></tr>
<tr><td><code id="funchandlers_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Custom handling of functions and, rarely, some types of non functions
(currently only inlined <code>NativeSymbol</code> objects) by the
<code>getInputs</code> function is specified via function handlers, which
are passed in a named list to <code>inputCollector</code> when creating a
collector for use by <code>getInputs</code>.
</p>
<p>Function handlers should only be used to construct an input collector
(i.e., as an argument to <code>inputCollector</code>). They should not ever
be called directly by end users.
</p>
<p>When creating new function handlers, they should accept the arguments
specified above (other than those to the factories). The first
argument, e, will be an expression representing a call to the function
the handler is specified for, and second <code>collector</code> will be the
collector object. Handlers are expected to recursively process all
aspects of the call expression to the extent desired. This will often
be done by calling getInputs again on, e.g., some or all arguments
passed into the function call.
</p>
<p>Function handlers are also expected to respect the <code>pipe</code> and
<code>nseval</code> arguments they receive. 
</p>

<hr>
<h2 id='getDependsThread'>Compute which code blocks in a script are inputs to define a variable</h2><span id='topic+getDependsThread'></span><span id='topic+getDependsThread+2Ccharacter-method'></span><span id='topic+getDependsThread+2Cname-method'></span><span id='topic+getDependsThread+2Cnumeric-method'></span>

<h3>Description</h3>

<p>This function is used to determine which code blocks in an R &quot;script&quot;
that are needed to define a particular variable.
This finds the smallest complete set of expressions or code blocks
that must be evaluated in order to define the specified
variable(s).  It omits expressions that do not provide
outputs that are not used as inputs  to (indirectly) define
the speciied variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDependsThread(var, info, reverse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getDependsThread_+3A_var">var</code></td>
<td>
<p>the name of a variable in the script</p>
</td></tr>
<tr><td><code id="getDependsThread_+3A_info">info</code></td>
<td>
<p>a list of the meta-information for each of the
code elements in the script.
</p>
</td></tr>
<tr><td><code id="getDependsThread_+3A_reverse">reverse</code></td>
<td>
<p>a logical value that determines whether
we reverse the indices of the expressions
or leave them as end-to-first.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector giving the indices of the
script code blocks which are required to define
<code>var</code>.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>See Also</h3>

<p><code><a href="#topic+getExpressionThread">getExpressionThread</a></code>
<code><a href="#topic+readScript">readScript</a></code>
<code><a href="#topic+getVariables">getVariables</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> sc = readScript(system.file("samples", "dual.R", package =
"CodeDepends"))
sci = getInputs(sc, formulaInputs = TRUE) ## script has formula with no data.frame
 idx = getDependsThread("fit", sci)
</code></pre>

<hr>
<h2 id='getDetailedTimelines'>Compute and plot life cycle of variables in code</h2><span id='topic+getDetailedTimelines'></span><span id='topic+plot.DetailedVariableTimeline'></span><span id='topic+coerce+2CDetailedVariableTimeline+2Cmatrix-method'></span>

<h3>Description</h3>

<p>These functions allow one to get and visualize information about
when variables are defined, redefined and used within
and across blocks of code in a script or the body of a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDetailedTimelines(doc, info = getInputs(doc, ...), vars =
getVariables(info, functions = functions), functions=TRUE, ...)
## S3 method for class 'DetailedVariableTimeline'
plot(x, var.srt = 0,
                                         var.mar = round(max(4,
.5*max(nchar(levels(x$var))))), var.cex = 1, main = attr(x, "scriptName"),...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getDetailedTimelines_+3A_doc">doc</code></td>
<td>
<p>the name of a file or a connection which identifies the
code to be analyzed</p>
</td></tr>
<tr><td><code id="getDetailedTimelines_+3A_info">info</code></td>
<td>
<p>meta-information extracted from the code identifying the
inputs and outputs. See <code><a href="#topic+getInputs">getInputs</a></code>.</p>
</td></tr>
<tr><td><code id="getDetailedTimelines_+3A_vars">vars</code></td>
<td>
<p>the variables of interest</p>
</td></tr>
<tr><td><code id="getDetailedTimelines_+3A_functions">functions</code></td>
<td>
<p>What type of functions should be included in the
timeline: <code>NULL</code> for none, <code>TRUE</code> for locally defined
only, <code>NA</code> for unknown provenance functions, or <code>FALSE</code>
for non-locally-defined functions. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="getDetailedTimelines_+3A_x">x</code></td>
<td>
<p>the <code>DetailedVariableTimeline</code> object being plotted</p>
</td></tr>
<tr><td><code id="getDetailedTimelines_+3A_var.srt">var.srt</code></td>
<td>
<p>rotation of the labels for the vertical axis listing
the variables</p>
</td></tr>
<tr><td><code id="getDetailedTimelines_+3A_var.mar">var.mar</code></td>
<td>
<p>the number of lines to leave for the vertical axis.
The labels for this are variable names so one often needs more space
or to change the size of the labels.</p>
</td></tr>
<tr><td><code id="getDetailedTimelines_+3A_var.cex">var.cex</code></td>
<td>
<p>character expansion factor for the variable labels on
</p>
<p>the vertical axis.</p>
</td></tr>
<tr><td><code id="getDetailedTimelines_+3A_main">main</code></td>
<td>
<p>the title of the plot</p>
</td></tr>
<tr><td><code id="getDetailedTimelines_+3A_...">...</code></td>
<td>
<p>Passed to down to getInputs for the default <code>info</code>
value in <code>getDetailedTimelines</code> and to underlying plotting
functions for <code>plot.DetailedTimelines</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>getDetailedTimelines</code> returns a data frame
with four columns: <code>step</code>, <code>used</code>, <code>defined</code>, and
<code>var</code>. Step represents steps within the timeline, with the same
value indicating that the described event are occuring at the same
time. <code>used</code> indicates whether <code>var</code> was used at that step,
and <code>defined</code> indicates whether <code>var</code> was defined. Many rows
will have <code>FALSE</code> for both as the variable is not used in that
code block.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>See Also</h3>

<p><code><a href="#topic+getInputs">getInputs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f = system.file("samples", "results-multi.R", package = "CodeDepends")
sc = readScript(f)
dtm = getDetailedTimelines(sc, getInputs(sc))
plot(dtm)
table(dtm$var)

 # A big/long function
info = getInputs(arima0)
dtm = getDetailedTimelines(info = info)
plot(dtm, var.cex = .7, mar = 4, srt = 30)
</code></pre>

<hr>
<h2 id='getExpressionThread'>Find the sequence of expressions needed to get to a certain point in the code</h2><span id='topic+getExpressionThread'></span>

<h3>Description</h3>

<p>What's the difference between this and getVariableInputs,
getVariableDepends, getSectionDepends?
</p>
<p>This does not currently attempt to get the minimal subset of expressions
within the code block. In other words, if there are extraneous
expressions
within these blocks that are not actually necessary, these are
evaluated. This is important for expressions with side effects, e.g.
writing files or generating plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getExpressionThread(target, expressions, info = lapply(expressions,
getInputs, ...), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getExpressionThread_+3A_target">target</code></td>
<td>
<p>either the index of the
expression of interest in <code>expressions</code> or the names of the variables.</p>
</td></tr>
<tr><td><code id="getExpressionThread_+3A_expressions">expressions</code></td>
<td>
<p>the list of expressions</p>
</td></tr>
<tr><td><code id="getExpressionThread_+3A_info">info</code></td>
<td>
<p>a list of objects giving information about the inputs
to each top-level expression in expressions.</p>
</td></tr>
<tr><td><code id="getExpressionThread_+3A_...">...</code></td>
<td>
<p>Passed to <code>getInputs</code> if <code>info</code> is not explicitly
specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+Script-class">Script-class</a></code> object containing the subset of the
code chunks pertinent to the target variable(s).
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>See Also</h3>

<p><code><a href="#topic+getDependsThread">getDependsThread</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> e = readScript(system.file("samples", "dual.R", package = "CodeDepends"))
 getExpressionThread("fit", e)

 getExpressionThread("y", e)
 getExpressionThread("x", e)

 getExpressionThread("k", e)

  # With several
 s = readScript(system.file("samples", "sitepairs.R", package = "CodeDepends"))
 o = getExpressionThread("covs", s)
</code></pre>

<hr>
<h2 id='getInputs'>Get input and output variables and literals from R expressions</h2><span id='topic+getInputs'></span><span id='topic+getInputs+2CANY-method'></span><span id='topic+getInputs+2CScript-method'></span><span id='topic+getInputs+2CScriptNode-method'></span><span id='topic+getInputs+2CScriptNodeInfo-method'></span><span id='topic+getInputs+2Cfunction-method'></span><span id='topic+scriptInfo'></span>

<h3>Description</h3>

<p>This function is used to analyze an R expression and
identify the input and output variables in the expressions and
related packages that are loaded and files that are referenced.
</p>
<p>This might be better called getCodeDepends. It is not to be confused
with <code>getVariableInputs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getInputs (e, collector = inputCollector(), basedir = ".", reset =
  FALSE, formulaInputs = FALSE, ...)


</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getInputs_+3A_e">e</code></td>
<td>
<p>the expression whose code we are to process</p>
</td></tr>
<tr><td><code id="getInputs_+3A_collector">collector</code></td>
<td>
<p>an object which collects the different elements of
interest in the code.</p>
</td></tr>
<tr><td><code id="getInputs_+3A_basedir">basedir</code></td>
<td>
<p>the directory for the code relative to which we can
resolve file names.</p>
</td></tr>
<tr><td><code id="getInputs_+3A_...">...</code></td>
<td>
<p>additional parameters for methods</p>
</td></tr>
<tr><td><code id="getInputs_+3A_reset">reset</code></td>
<td>
<p>a logical value that controls whether we call the
collector's reset method before starting to process the expressions in
the script.</p>
</td></tr>
<tr><td><code id="getInputs_+3A_formulainputs">formulaInputs</code></td>
<td>
<p> Logical indicating whether symbols appearing in
formulas should be treated as inputs to the expression. Defaults to
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ScriptInfo object containing information about the expression(s) in
e.
</p>
<p>Things tracked include:
</p>
<table role = "presentation">
<tr><td><code>files</code></td>
<td>
<p>the names of any strings used as arguments or literal
values that correspond to file names.</p>
</td></tr>
<tr><td><code>strings</code></td>
<td>
<p>A vector of literal strings which appeared in <code>e</code></p>
</td></tr>
<tr><td><code>libraries</code></td>
<td>
<p>the names of any libraries explicitly loaded within
this code.</p>
</td></tr>
<tr><td><code>inputs</code></td>
<td>
<p>a character vector naming the variables that are used as
inputs to the computations in this collection of expressions.</p>
</td></tr>
<tr><td><code>outputs</code></td>
<td>
<p>a character vector giving the names of the variables
that are assigned values in this block of code, including
assignments to elements of a variable, e.g. the variable x in the
expression <code>x[[1]] &lt;- 10</code>.</p>
</td></tr>
<tr><td><code>updates</code></td>
<td>
<p> character vector of variables which receive new values
when evaluating the expression, but must already exist. Note this
does not currently catch some situations, so checking if any symbols
appear in both inputs and outputs is still prudent.</p>
</td></tr>
<tr><td><code>functions</code></td>
<td>
<p>a named logical vector, where the names are the names
of the functions called and the values indicate whether the function
is local (TRUE), from a package (FALSE) or unknown (NA). Note that
this is not recursive.</p>
</td></tr>
<tr><td><code>removes</code></td>
<td>
<p>a vector of variables which were removed (via the
<code>rm</code> function) in <code>e</code></p>
</td></tr>
<tr><td><code>nsevalVars</code></td>
<td>
<p>A vector of variables which appear in appear in
<code>e</code>, but which are non-standarly evaluated and thus are not
typical inputs. Note this classification is determined by the
functionhandlers in use by <code>collector</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Users should never call <code>getInputs.langauge</code> directly. It is
listed here due to the vagaries of R CMD check documentation checks.</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+parse">parse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  frags = parse(system.file("samples", "dual.R", package = "CodeDepends"))  
  # formula involves non-df variables
  inputs = lapply(frags, getInputs, formulaInputs=TRUE)
  inputs
  sapply(inputs, slot, "outputs")

   # Specify the base directory in which to resolve the file names.
  getInputs(frags[[5]], basedir = system.file("samples", package = "CodeDepends"))


  f = system.file("samples", "namedAnnotatedScript.R", package = "CodeDepends")
  sc = readScript(f, "labeled")
  getInputs(sc)
  getInputs(sc[[2]])
</code></pre>

<hr>
<h2 id='getPropagateChanges'>Determine which expressions to update when a variable changes</h2><span id='topic+getPropagateChanges'></span>

<h3>Description</h3>

<p>This function allows us to determine which subsequent expressions
in the document need to be evaluated when a variable is assigned a new
value. This is the &quot;opposite&quot; of  determining on which variables a
given variable depends; this is for identifying which variables and
expressions need to be updated when a variable changes.
This is of use when propogating changes to dependent expressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
getPropagateChanges(var, expressions, info = lapply(expressions,
                    getInputs), recursive = FALSE, index = FALSE, envir
                    = globalenv(), eval = !missing(envir), verbose =
                    FALSE)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPropagateChanges_+3A_var">var</code></td>
<td>
<p>the name of the variable which has changed</p>
</td></tr>
<tr><td><code id="getPropagateChanges_+3A_expressions">expressions</code></td>
<td>
<p>the list of all expressions in the document</p>
</td></tr>
<tr><td><code id="getPropagateChanges_+3A_info">info</code></td>
<td>
<p>information extracted from the expressions about the
inputs to each expressions. See <code><a href="#topic+getInputs">getInputs</a></code>.</p>
</td></tr>
<tr><td><code id="getPropagateChanges_+3A_recursive">recursive</code></td>
<td>
<p>a logical value that controls whether to work
recursively on the expressions</p>
</td></tr>
<tr><td><code id="getPropagateChanges_+3A_index">index</code></td>
<td>
<p>a logical value which controls whether we return the
indices of the expressions that would need to be evaluated based on
the change to the variable <code>var</code>, or if <code>index</code> is
<code>FALSE</code>, we return the expressions themselves.</p>
</td></tr>
<tr><td><code id="getPropagateChanges_+3A_envir">envir</code></td>
<td>
<p>the environment in which to evaluate the expressions</p>
</td></tr>
<tr><td><code id="getPropagateChanges_+3A_eval">eval</code></td>
<td>
<p>a logical value controlling whether we evaluate the
expressions or just return them</p>
</td></tr>
<tr><td><code id="getPropagateChanges_+3A_verbose">verbose</code></td>
<td>
<p>a logical value that controls whether we output
information about the expressions and their evaluation on the R console.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>This returns
either the expressions or the indices of the expressions
that need to be re-evaluated due to a change in <code>var</code>.
</p>


<h3>Note</h3>

<p>The returned expression do NOT include the expression which
defines the variable <code>var</code>. Only expressions *after* that are
included.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>See Also</h3>

<p><code><a href="#topic+getExpressionThread">getExpressionThread</a></code>
<code><a href="#topic+getDependsThread">getDependsThread</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc = readScript(system.file("samples", "formula.R", package = "CodeDepends"))
info = getInputs(sc)
getPropagateChanges("x", sc, info = info)
getPropagateChanges("y", sc, info = info)
</code></pre>

<hr>
<h2 id='getVariableDepends'>Determine dependencies for code blocks</h2><span id='topic+getSectionDepends'></span><span id='topic+getVariableDepends'></span>

<h3>Description</h3>

<p>These functions provide ways to determine which code blocks
must be evaluated before others based on input and output variables.
<code>getVariableDepends</code> is used to determine the code blocks
that need to be run in order to define particlar variables.
<code>getSectionDepends</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getVariableDepends(vars, frags, info = lapply(frags, getInputs, ...),
checkLibraries = FALSE, asIndex = FALSE, functions = TRUE, ...)
getSectionDepends(sect, frags, info = lapply(frags, getInputs, ...), index =
FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getVariableDepends_+3A_vars">vars</code></td>
<td>
<p>the names of the variables of interest</p>
</td></tr>
<tr><td><code id="getVariableDepends_+3A_frags">frags</code></td>
<td>
<p>the blocks or groups of expressions from the document</p>
</td></tr>
<tr><td><code id="getVariableDepends_+3A_info">info</code></td>
<td>
<p>the information about the fragments that identify the
inputs. This is typically computed as the default value for the
parameter but can be provided explicitly when the caller has alreay
computed this and passes it to different functions.</p>
</td></tr>
<tr><td><code id="getVariableDepends_+3A_index">index</code></td>
<td>
<p>a logical value that controls whether we return the
indices of the fragments of interest (<code>TRUE</code>) or return the
fragments themselves (<code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="getVariableDepends_+3A_sect">sect</code></td>
<td>
<p>the index of the section/fragment to be analyzed</p>
</td></tr>
<tr><td><code id="getVariableDepends_+3A_checklibraries">checkLibraries</code></td>
<td>
<p>a logical value</p>
</td></tr>
<tr><td><code id="getVariableDepends_+3A_asindex">asIndex</code></td>
<td>
<p>a logical value that controls whether we return the
expressions/code blocks or their indices.</p>
</td></tr>
<tr><td><code id="getVariableDepends_+3A_functions">functions</code></td>
<td>
<p>passed to <code>getVariables</code>. What kind of functions
should be counted as variables (<code>TRUE</code> is local functions only,
the default)</p>
</td></tr>
<tr><td><code id="getVariableDepends_+3A_...">...</code></td>
<td>
<p>passed to <code>getInputs</code>. Ignored if <code>info</code> is
explicitly specified.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p><code>getVariableDepends</code> returns a <code><a href="#topic+Script-class">Script-class</a></code> object
consisting of the subset of code blocks relevant to the specified variables.
</p>
<p>If <code>asIndex</code> is <code>TRUE</code>, <code>getVariableDepends</code> returns the indices of the
code blocks in the original script.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>See Also</h3>

<p><code><a href="#topic+getPropagateChanges">getPropagateChanges</a></code>
<code><a href="#topic+getExpressionThread">getExpressionThread</a></code>   
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e = readScript(system.file("samples", "dual.R", package = "CodeDepends"))
getVariableDepends("fit", e, formulaInputs = TRUE)
getVariableDepends("fit", e, formulaInputs = TRUE, asIndex = TRUE)

getVariableDepends("y", e, asIndex = TRUE)
getVariableDepends("y", e)

</code></pre>

<hr>
<h2 id='getVariables'>Get the names of the variables used in code</h2><span id='topic+getVariables'></span><span id='topic+getVariables+2CScript-method'></span><span id='topic+getVariables+2CScriptInfo-method'></span><span id='topic+getVariables+2CScriptNode-method'></span><span id='topic+getVariables+2CScriptNodeInfo-method'></span><span id='topic+getVariables+2Cexpression-method'></span>

<h3>Description</h3>

<p>These functions and methods allow one to get the
names of the variables used within a script or block
of code and from various derived types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getVariables(x, inputs = FALSE, functions = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getVariables_+3A_x">x</code></td>
<td>
<p>the object with information about the variables</p>
</td></tr>
<tr><td><code id="getVariables_+3A_inputs">inputs</code></td>
<td>
<p>a logical indicating wether to include the input
variables or just return the output variables, i.e. those on the
left hand side of of an assignment. Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="getVariables_+3A_functions">functions</code></td>
<td>
<p>Indicates what types of functions should be
included. <code>NULL</code> Logical or NULL. Indicages what kind of functions
should be counted as variables: local (<code>TRUE</code>, the default)(default) indicates none, <code>TRUE</code>
indicates user-defined or unknown provenance functions, and
<code>FALSE</code> indicates all functions. Ignored if <code>inputs</code> is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="getVariables_+3A_...">...</code></td>
<td>
<p>Passed to <code>getInputs</code> when generating script
information to comput on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector, with possibly repeated values,
giving the names of the variables. If an annotated script was used,
the vector is named by the sections of the script.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>See Also</h3>

<p><code><a href="#topic+readScript">readScript</a></code>
<code><a href="#topic+getInputs">getInputs</a></code>    
</p>


<h3>Examples</h3>

<pre><code class='language-R'> f = system.file("samples", "namedAnnotatedScript.R", package = "CodeDepends")
 sc = readScript(f, "labeled")
 getVariables(sc)

 getVariables(sc[[3]])
</code></pre>

<hr>
<h2 id='guessTaskType'>Guess the type of high-level task of a code block</h2><span id='topic+guessTaskType'></span>

<h3>Description</h3>

<p>This attempts to infer the type of the task being performed.
There is a small set of known task types, listed in
<code>system.file("Vocabulary", package = "CodeDepends")</code>.
</p>
<p>Currently this uses simple rules. In the future, we might
use a classifier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guessTaskType(e, info = getInputs(e))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="guessTaskType_+3A_e">e</code></td>
<td>
<p>the code block to be analyzed. This can be a call or an
expression.
Typically it is an element of a <a href="#topic+Script-class">Script-class</a>, i.e. a
<code>ScriptNode-class</code> object</p>
</td></tr>
<tr><td><code id="guessTaskType_+3A_info">info</code></td>
<td>
<p>meta-information about the </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector giving the different task identifiers.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>See Also</h3>

<p><code><a href="#topic+readScript">readScript</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  guessTaskType(quote(plot(x, y)))

  e = expression({
          d = read.table("myData.txt")
          d$abc = d$a + log(d$b)
          d[ d$foo == 1, ] = sample(n)
      })
  guessTaskType(e)
</code></pre>

<hr>
<h2 id='highlightCode'>Display R code with highlighting of variables, links to functions
and packages</h2><span id='topic+highlightCode'></span>

<h3>Description</h3>

<p>This function leverages the <code>highlight</code> package to create
an HTML display of R code.
It connects all instances of a variable in the code  so that
a viewer can move the mouse over a variable and see all uses of it
in the code.
</p>
<p>The motivations for this is to help navigate a script and to allow us
to connect the code to plots of, for example, the time-line or
life-span of variables in a script.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
highlightCode(obj, out = NULL, addFunctionLinks = TRUE, checkURLs= TRUE,
              inline = TRUE, h = htmlRenderer(addFunctionLinks,
              checkURLs), css = system.file("CSS", "highlight.css",
              package = "CodeDepends"), jsCode =
              system.file("JavaScript", "highlightSymbols.js", package =
              "CodeDepends"))

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="highlightCode_+3A_obj">obj</code></td>
<td>
<p>the name of a file containing R code or an R expression or
function.
Currently, this needs to be a file.</p>
</td></tr>
<tr><td><code id="highlightCode_+3A_out">out</code></td>
<td>
<p>the name of a file to which the HTML document is written,
or <code>NULL</code> or <code>NA</code> to just return the in-memory document.</p>
</td></tr>
<tr><td><code id="highlightCode_+3A_addfunctionlinks">addFunctionLinks</code></td>
<td>
<p>how to generate the links for function
calls. This can be <code>NULL</code> to have no links for function calls, or
a logical value indicating whether to have links or not, or a
function.
If this is a function, it is called with a vector of  function names
and should return a character vector with links for each of them.</p>
</td></tr>
<tr><td><code id="highlightCode_+3A_checkurls">checkURLs</code></td>
<td>
<p>When sorting through possible link targets, should we
check for existing local files OR URLs. Defaults to <code>TRUE</code>, if
<code>FALSE</code> only locally existing files are checked for.</p>
</td></tr>
<tr><td><code id="highlightCode_+3A_inline">inline</code></td>
<td>
<p>a logical value indicating whether to put the CSS and
JavaScript code directly into the HTML document or just refer to them.</p>
</td></tr>
<tr><td><code id="highlightCode_+3A_h">h</code></td>
<td>
<p>the renderer to create the HTML. See <code><a href="highlight.html#topic+highlight">highlight</a></code></p>
</td></tr>
<tr><td><code id="highlightCode_+3A_css">css</code></td>
<td>
<p>the URL or local file name for the CSS content</p>
</td></tr>
<tr><td><code id="highlightCode_+3A_jscode">jsCode</code></td>
<td>
<p>the URL or local file name for the JavaScript code for
the highlighting of the variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This uses the <code><a href="highlight.html#topic+highlight">highlight</a></code> function
to create the basic information for the code. We provide
our own renderer to provide the links for function calls and
packages and to specify markup for the symbols.
Then we post-process the resulting HTML document to add our
own CSS content and JavaScript code.
</p>


<h3>Value</h3>

<p>An HTML document or the name of the file to which it was written if
<code>out</code> is specified.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f = system.file("samples", "sitepairs.R", package = "CodeDepends")
## url checking takes a while, too long for CRAN example
fout &lt;- file.path(tempdir(), "foo.html")
highlightCode(f, fout, checkURLs=FALSE)
</code></pre>

<hr>
<h2 id='historyAsScript'>Convert R interactive history to a Script object</h2><span id='topic+historyAsScript'></span>

<h3>Description</h3>

<p>This function is a means to capture the history
of R commands  interactively entered at the prompt
in this session (or saved across sessions)
as a <code><a href="#topic+Script-class">Script-class</a></code> object.
One can then analyze the expressions to find relationships
between variables and commands,  which are irrelevant, ...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>historyAsScript()
</code></pre>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+Script-class">Script-class</a></code>.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readScript">readScript</a></code>
<code><a href="utils.html#topic+history">history</a></code>
</p>

<hr>
<h2 id='inputCollector'>
Create customized input/output collector for use in getInputs
</h2><span id='topic+inputCollector'></span>

<h3>Description</h3>

<p>Create a custom input collector which will be used by getInputs to
process
to collect various aspects of the code as it is being processed. Custom
collector functions can be specified which will be called when a
particular function is called within the code.One major use for this is
leveraging knowledge of specific functions' behavior to track side
effects relevant to a particular use-case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inputCollector(..., functionHandlers = list(...), inclPrevOutput =
FALSE, checkLibrarySymbols = FALSE, funcsAsInputs = checkLibrarySymbols)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inputCollector_+3A_...">...</code></td>
<td>

<p>Custom information collection functions. Argument names correspond to
R functions, with the custom collection function being called when a
call to the named function is detected within the code being
processed. Overridden by <code>functionHandlers</code>
</p>
</td></tr>
<tr><td><code id="inputCollector_+3A_functionhandlers">functionHandlers</code></td>
<td>

<p>A named list of custom collection functions. 
</p>
</td></tr>
<tr><td><code id="inputCollector_+3A_inclprevoutput">inclPrevOutput</code></td>
<td>
<p>Should variables which were output previously
within the code be treated as inputs in subsequent expressions. If
<code>TRUE</code> each expression within the code is treated separately
with respect to detecting input variables, if <code>FALSE</code> the code
is treated as a single block. Defaults to <code>FALSE</code>
</p>
</td></tr>
<tr><td><code id="inputCollector_+3A_checklibrarysymbols">checkLibrarySymbols</code></td>
<td>
<p>If <code>TRUE</code> symbols exported by default
package and packages loaded within the code via <code>library</code> or
<code>require</code> calls are tracked and excluded from the list of input
variables. Defaults to<code>FALSE</code>
</p>
</td></tr>
<tr><td><code id="inputCollector_+3A_funcsasinputs">funcsAsInputs</code></td>
<td>
<p>If <code>TRUE</code> functions called by the code being
processed are treated as input variables and listed as
such. Defaults to the value of <code>checkLibrarySymbols</code>. A value
of <code>funcsAsInputs</code> which does not agree with the value of
<code>checkLibrarySymbols</code> is NOT recommended.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each custom collection function should accept three arguments:
</p>

<dl>
<dt>e: </dt><dd><p>the code or expression currently being processed</p>
</dd>
<dt>collector: </dt><dd><p>the current inputCollector</p>
</dd>
<dt>basedir: </dt><dd><p>the base directory in which the processing is taking place, e.g. to determine whether strings correspond to files</p>
</dd>
</dl>

<p>These functions should process the expression and then use
<code>collector</code>'s collection functions and/or the <code>&lt;&lt;-</code>
assignment operator to update the lists of found entities.
</p>
<p>Currently trackable entities, updatable by <code style="white-space: pre;">&#8288;&lt;entity&gt;&lt;&lt;-c(&lt;entity&gt;,
    value)&#8288;</code> or as specified, include:
</p>

<dl>
<dt>libraries: </dt><dd><p>libraries loaded by the code via <code>library</code> or
<code>require</code>. Updatable by calling <code>collector$library</code>
</p>
</dd>
<dt>libSymbols: </dt><dd><p>symbols exported by available libraries. Tracked
automatically within <code>collector$library</code>
</p>
</dd>
<dt>files: </dt><dd><p>string constants which correspond to an existing file in
<code>basedir</code>. Tracked automatically when strings are passed to
<code>collector$string</code>
</p>
</dd>
<dt>strings: </dt><dd><p>string constants which do not correspond to existing
files. Tracked automatically when strings are passed to
<code>collector$string</code>
</p>
</dd>
<dt>vars: </dt><dd><p>all variable names used in the code. Updatable by calling
<code>collector$vars</code> with <code>input</code> as <code>TRUE</code> or <code>FALSE</code>
as appropriate</p>
</dd>
<dt>set: </dt><dd><p>variable names which are assigned to in the code (input
variables). Updatable by calling <code>collector$set</code> or
<code>collector$vars</code> with <code>input=TRUE</code>
</p>
</dd>
<dt>functions: </dt><dd><p>functions called by the code. Updatable by calling
<code>collector$calls</code>. This will also update <code>vars</code> if the
collector was created with <code>funcsAsInputs=TRUE</code>
</p>
</dd>
<dt>removes: </dt><dd><p>variables removed by the vode via calls to
<code>collector$removes</code>
</p>
</dd>
<dt>updates: </dt><dd><p>variables which have had elements within them updated,
e.g. via <code>x$foo &lt;- bar</code>. Updatable via calls to
<code>collector$update</code>
</p>
</dd>
<dt>sideEffects: </dt><dd><p>side effects generated by the code. Experimental,
default side effect detection should not be assumed to be robust or
exhaustive. Updatable via calls to <code>sideEffects</code>
</p>
</dd>
<dt>formulaVariables: </dt><dd><p>If <code>formulaInputs</code> is <code>FALSE</code> within
the call to getInputs, this tracks variables which appear within
formulas, otherwise this is unused and such variables are treated as
input. Updatable via the modelVars argument in calls to
<code>collector$addInfo</code>
</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list of functions used to update internal tracking variables (see
Details) as well as the following:
</p>

<dl>
<dt>functionHandlers: </dt><dd><p>The list of function handlers in use by the
collector.</p>
</dd>
<dt>reset: </dt><dd><p>A function which resets the internal tracking variables.</p>
</dd>
<dt>results: </dt><dd><p>A function which returns a
<code><a href="#topic+ScriptNodeInfo-class">ScriptNodeInfo</a></code> object representing the current state of
the collection.</p>
</dd>
</dl>



<h3>Note</h3>

<p>Custom handlers take precedence over default proccessing
mechanism. Care should be taken when overriding core functions such as
<code>=</code>, <code>~</code>, <code>$</code>, <code>library</code>, etc.
</p>


<h3>Note</h3>

<p>Specific internal behaviors of the default collection mechanisms are
experimental and may change in future versions.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ScriptNodeInfo-class">ScriptNodeInfo</a></code> <code><a href="#topic+getInputs">getInputs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   f = system.file("samples", "results-multi.R", package="CodeDepends")
   sc = readScript(f)
  collector = inputCollector(library = function(e, collector, basedir, ...)
  {
    print(paste("loaded library",  e[[2]]))
    collector$library(as.character(e[[2]]))
})
  res = getInputs(sc, collector = collector )
  #[1] "loaded library splines"
  #[1] "loaded library tsModel"
</code></pre>

<hr>
<h2 id='makeCallGraph'>Create a graph representing which functions call other functions</h2><span id='topic+makeCallGraph'></span><span id='topic+makeCallGraph+2Clist-method'></span><span id='topic+makeCallGraph+2Ccharacter-method'></span><span id='topic+makeCallGraph+2Cfunction-method'></span>

<h3>Description</h3>

<p>This function and its methods provide facilities for constructing
a graph representing which functions call which other functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeCallGraph(obj, all = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeCallGraph_+3A_obj">obj</code></td>
<td>
<p>The name of one or more packages as a string, optionally prefixed with
<code>"package:"</code>. This can be a vector of package names.
Currently the packages should already be on the search path.
Other inputs may be supported in the future</p>
</td></tr>
<tr><td><code id="makeCallGraph_+3A_all">all</code></td>
<td>
<p>a logical value that controls whether the graph includes
all the functions called by any of the target functions. This will
greatly expand the graph.</p>
</td></tr>
<tr><td><code id="makeCallGraph_+3A_...">...</code></td>
<td>
<p>additional parameters for the methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="graph.html#topic+graphNEL-class">graphNEL-class</a></code>
</p>


<h3>Note</h3>

<p>We may extend this to deal with global variables and methods</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>See Also</h3>

<p>The <code>graph</code> and <code>Rgraphviz</code> packages.
</p>
<p>The <code>SVGAnnotation</code> package can be used to mae thee graphs interactive.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  gg = makeCallGraph("package:CodeDepends")
  if(require(Rgraphviz)) {
     plot(gg, "twopi")

     ag = agopen(gg, layoutType = "circo", name = "bob")
     plot(ag)
  }

  if(require(Rgraphviz)) {
      # Bigger fonts.
    zz = layoutGraph(gg)
    graph.par(list(nodes = list(fontsize = 48)))
    renderGraph(zz)
  }

    # Two packages
    library(codetools)
    gg = makeCallGraph(c("package:CodeDepends", "package:codetools"))
</code></pre>

<hr>
<h2 id='makeTaskGraph'>Create a graph connecting the tasks within a script</h2><span id='topic+makeTaskGraph'></span>

<h3>Description</h3>

<p>This function create a graph connecting the high-level
tasks within a script. The tasks are blocks of code that
perform a step in the process.
Each code block has input and output variables.
These are used to define the associations between the tasks
and which tasks are inputs to others and outputs that lead into
others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeTaskGraph(doc, frags = readScript(doc), info = as(frags, "ScriptInfo"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeTaskGraph_+3A_doc">doc</code></td>
<td>
<p>the name of the script file</p>
</td></tr>
<tr><td><code id="makeTaskGraph_+3A_frags">frags</code></td>
<td>
<p>the code blocks in the script</p>
</td></tr>
<tr><td><code id="makeTaskGraph_+3A_info">info</code></td>
<td>
<p>the meta-information detailing the inputs and outputs of
the different code blocks/fragments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="graph.html#topic+graphNEL-class">graphNEL-class</a></code>.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>See Also</h3>

<p><code><a href="#topic+readScript">readScript</a></code>
<code><a href="#topic+getInputs">getInputs</a></code>    
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 f = system.file("samples", "dual.R", package = "CodeDepends")
 g = makeTaskGraph(f)

 if(require(Rgraphviz))
   plot(g)

 f = system.file("samples", "parallel.R", package = "CodeDepends")
 g = makeTaskGraph(f)

 if(require(Rgraphviz))
   plot(g)

 f = system.file("samples", "disjoint.R", package = "CodeDepends")
 g = makeTaskGraph(f)

 if(require(Rgraphviz))
   plot(g)

## End(Not run)
</code></pre>

<hr>
<h2 id='makeVariableGraph'>Create a graph describing the relationships between variables in
a script</h2><span id='topic+makeVariableGraph'></span>

<h3>Description</h3>

<p>This creates a graph of nodes and edges describing the relationship
of how some variables are used in defining others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeVariableGraph(doc, frags = readScript(doc), info = getInputs(frags),
                   vars = getVariables(info, inputs = free), free = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeVariableGraph_+3A_doc">doc</code></td>
<td>
<p>the name of the script file</p>
</td></tr>
<tr><td><code id="makeVariableGraph_+3A_frags">frags</code></td>
<td>
<p>the code fragments from the script as a <code>Script</code> object.</p>
</td></tr>
<tr><td><code id="makeVariableGraph_+3A_info">info</code></td>
<td>
<p>the <code>ScriptInfo</code> list of <code>ScriptNodeInfo</code> objects describing each  node.</p>
</td></tr>
<tr><td><code id="makeVariableGraph_+3A_vars">vars</code></td>
<td>
<p>a character vector giving the names of the variables in
the scripts. By default, these are the variables defined in the script.</p>
</td></tr>
<tr><td><code id="makeVariableGraph_+3A_free">free</code></td>
<td>
<p>a logical value that is passed to <code>getInputs</code> and
controls whether we include the free/global variables in the script.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this collapses variables with the same name into a single
node.  Therefore, if the code uses the same name for two
unrelated variables, there may be some confusion.
</p>


<h3>Value</h3>

<p>An object of class <code>graphNEL</code> from the <code>graph</code> package.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>See Also</h3>

<p><code><a href="#topic+readScript">readScript</a></code>
<code><a href="#topic+getInputs">getInputs</a></code>    
<code><a href="#topic+getVariables">getVariables</a></code>
</p>
<p><code>graph</code>
<code>Rgraphviz</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 u = url("http://www.omegahat.net/CodeDepends/formula.R")
 sc = readScript(u)
 close(u)
 g = makeVariableGraph(, sc)

## End(Not run)

 f = system.file("samples", "results-multi.R", package = "CodeDepends")
 sc = readScript(f)
 g = makeVariableGraph( info = getInputs(sc))
 if(require(Rgraphviz))
   plot(g)
</code></pre>

<hr>
<h2 id='readScript'>Read the code blocks/chunks from a document</h2><span id='topic+readScript'></span><span id='topic+readScript+2Ccharacter-method'></span><span id='topic+readScript+2Cconnection-method'></span><span id='topic+readScript+2CXMLInternalDocument-method'></span><span id='topic+readScript+2Cmissing-method'></span><span id='topic+readAnnotatedScript'></span>

<h3>Description</h3>

<p>This is a general function that determines the type of the
document and then extracts the code from it.
</p>
<p>This is an S4 generic  and so can be extended by other packages
for document types that have a class, e.g. Word or OpenOffice
documents.
</p>
<p><code>readAnnotatedScript</code> is for reading scripts that use
a vocabulary to label code blocks with high-level task identifiers
to indicate what the code does in descriptive terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readScript(doc, type = NA, txt = readLines(doc), ...)
readAnnotatedScript(doc, txt = readLines(doc)) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readScript_+3A_doc">doc</code></td>
<td>
<p>the document, typically a string giving the file name. This
can also be a connection, e.g. created via <code><a href="base.html#topic+url">url</a></code>.</p>
</td></tr>
<tr><td><code id="readScript_+3A_type">type</code></td>
<td>
<p>a string indicating the type of the document. If this is
missing, the function calls <code>getDocType</code> to attempt to
determine this based on the &quot;common&quot; types of documents.</p>
</td></tr>
<tr><td><code id="readScript_+3A_txt">txt</code></td>
<td>
<p>the lines of text of the document.</p>
</td></tr>
<tr><td><code id="readScript_+3A_...">...</code></td>
<td>
<p>Passed to low-level input functions used by various methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the R expressions that constitute the code blocks.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang </p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+parse">parse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  e = readScript( system.file ("samples", "dual.R", package = "CodeDepends") )
  ## Not run: 
  readScript(url("http://www.omegahat.net/CodeDepends/formula.R"))

## End(Not run)
</code></pre>

<hr>
<h2 id='runUpToSection'>Evaluate the code blocks up to a particular section of a document</h2><span id='topic+runUpToSection'></span>

<h3>Description</h3>

<p>This function allows the caller to evaluate the code blocks within a
document all the way up to a specified section of the document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runUpToSection(section, doc, all = TRUE, env = globalenv(),
                nestedEnvironments = FALSE, frags = readScript(doc),
                 verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="runUpToSection_+3A_section">section</code></td>
<td>
<p>the index of the section, i.e. a number</p>
</td></tr>
<tr><td><code id="runUpToSection_+3A_doc">doc</code></td>
<td>
<p>the name of the file containing the code</p>
</td></tr>
<tr><td><code id="runUpToSection_+3A_all">all</code></td>
<td>
<p>a logical value. It should be <code>TRUE</code> for now. </p>
</td></tr>
<tr><td><code id="runUpToSection_+3A_env">env</code></td>
<td>
<p>the environment in which the expressions will be evaluated</p>
</td></tr>
<tr><td><code id="runUpToSection_+3A_nestedenvironments">nestedEnvironments</code></td>
<td>
<p>a logical value controlling whether the
each code block should be evaluated in its own environment which
are created with the previous code block's environment as a
parent environment.</p>
</td></tr>
<tr><td><code id="runUpToSection_+3A_frags">frags</code></td>
<td>
<p>the code fragments read from the document or specified
directly by the caller.</p>
</td></tr>
<tr><td><code id="runUpToSection_+3A_verbose">verbose</code></td>
<td>
<p>logical value indicating whether to display the code </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the results of evaluating the different fragments.
The list will have a length given by the section number.
</p>


<h3>Note</h3>

<p>Currently, <code>all = FALSE</code> is not implemented.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>See Also</h3>

<p><code><a href="#topic+sourceVariable">sourceVariable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> frags = parse(system.file("samples", "dual.R", package = "CodeDepends"))  
 runUpToSection(3, frags = frags, verbose = TRUE, all = TRUE)
</code></pre>

<hr>
<h2 id='Script-class'>The Script class and elements</h2><span id='topic+Script-class'></span><span id='topic+AnnotatedScript-class'></span><span id='topic+ScriptNode-class'></span><span id='topic+ScriptInfo-class'></span><span id='topic+ScriptNodeInfo-class'></span><span id='topic+coerce+2CScript+2CScriptInfo-method'></span><span id='topic+coerce+2CScriptNode+2CScriptNodeInfo-method'></span><span id='topic+coerce+2Cexpression+2CScriptNodeInfo-method'></span><span id='topic+coerce+2Clanguage+2CScriptNodeInfo-method'></span><span id='topic++5B+2CScript+2Cvector+2Cmissing-method'></span><span id='topic++5B+2CScript+2Ccharacter+2Cmissing-method'></span><span id='topic++24+2CScript-method'></span>

<h3>Description</h3>

<p>This package works with collections of expressions
or code blocks and such a sequence can be thought of as a script.
The <code>Script</code> class is a list of code elements.
Such objects are typically created via a call to
<code><a href="#topic+readScript">readScript</a></code>.
They can be read from XML files, tangled Sweave output,
regular R source files and R source files that are annotated
to identify the general task of each code block.
This last type of script has its own class named
<code>AnnotatedScript</code> and the code elements are annotated with labels
such as dataInput, simulate, plot, model, eda and so on.
</p>
<p>Each element of a <code>Script</code> list represents code.
These are stored as objects of class <code>ScriptNode</code>.
A <code>ScriptNode</code> class has slots for the
<code>code</code>, the <code>taskType</code> indicating the high-level nature of
the code, and an <code>id</code> so we can easily refer to it.
</p>
<p>While our focus is on the code elements in a <code>Script</code>, we work
with meta-data about the code elements. We identify information such
as the input variables required by a code element, the variables it
assigns (the outputs) and so on.  This information is stored
in a <code>ScriptNodeInfo</code> object.
And a collection of such objects that parallels a script
is a <code>ScriptInfo</code> object.
</p>
<p>We can easily map a <code>Script</code> or a <code>ScriptNode</code>
to the corresponding meta-information via the coercion methods
<code>as(script, "ScriptInfo")</code> and  <code>as(node, "ScriptNodeInfo")</code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects of class <code>Script</code> are created with
<code><a href="#topic+readScript">readScript</a></code>.
</p>
<p>Objects of class <code>ScriptInfo</code> are created with
<code><a href="#topic+getInputs">getInputs</a></code> or <code>as(, "ScriptInfo")</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>the elements of the list.</p>
</dd>
<dt><code>location</code>:</dt><dd><p>a character string that gives the file name
or URL of the code for this script.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="methods.html#topic+list-class">list</a>"</code>, from data part.
Class <code>"<a href="methods.html#topic+vector-class">vector</a>"</code>, by class &quot;list&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>coerce</dt><dd><p><code>signature(from = "Script", to = "ScriptInfo")</code>:
convert a <code>Script</code> to a <code>ScriptInfo</code> to access the meta-information</p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "ScriptNode", to =
	"ScriptNodeInfo")</code>: 
compute the meta-information from an individual code element.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Duncan Temple Lang</p>


<h3>See Also</h3>

<p><code><a href="#topic+readScript">readScript</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> f = system.file("samples", "results-multi.R", package = "CodeDepends")
 sc = readScript(f)
 info = as(sc, "ScriptInfo")
 info = getInputs(sc, basedir = dirname(f))

   # Providing our own handler for calls to source()
 sourceHandler = function(e, collector = NULL, basedir = ".", ...) {
     collector$string(e[[2]], , TRUE)
     collector$calls(as.character(e[[1]]))
 }
 h = CodeDepends:::inputCollector(source = sourceHandler)
 info = getInputs(sc, h, basedir = dirname(f))

## Not run: 
 u = url("http://www.omegahat.net/CodeDepends/formula.R")
 sc = readScript(u)
 as(sc, "ScriptInfo")

## End(Not run)
</code></pre>

<hr>
<h2 id='separateExpressionBlocks'>Convert a script into individual top-level calls</h2><span id='topic+separateExpressionBlocks'></span>

<h3>Description</h3>

<p>This function converts a script of code blocks (e.g. from Sweave, XML,
or an annotated script) with grouped expressions into
individual top-level calls.
The intent of this is to allow us to deal with the calls at a
higher-level
of granularity than code blocks.
In other words, we can easily compute the depenendcies
on the individual calls rather than on collections
of calls. This allows us to re-evaluate individual expressions rather
than entire code blocks when we have to update variables due to
changes in &quot;earlier&quot; variables, i.e. those defined earlier in the
script   and recomputed for various reasons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>separateExpressionBlocks(blocks)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="separateExpressionBlocks_+3A_blocks">blocks</code></td>
<td>
<p>a list of the expressions or calls, i.e. the code
blocks, in the script.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of call or assignment expressions.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>See Also</h3>

<p><code><a href="#topic+readScript">readScript</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'> f = system.file("samples", "dual.R", package = "CodeDepends")
 sc = readScript(f)
 separateExpressionBlocks(sc)
</code></pre>

<hr>
<h2 id='sourceVariable'>Evaluate code in document in order to define the specified variables</h2><span id='topic+sourceVariable'></span>

<h3>Description</h3>

<p>This function allows the caller to evaluate the code within the
document (or list of code chunks directly) in order to define
one or more variables and then terminate. This is similar
to <code>runUpToSection</code> but is oriented towards variables
rather than particular code blocks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sourceVariable(vars, doc, frags = readScript(doc), eval = TRUE, env = globalenv(), 
                nestedEnvironments = FALSE, verbose = TRUE,
                 checkLibraries = eval, force = FALSE, first = FALSE,
                  info = lapply(frags, getInputs)) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sourceVariable_+3A_vars">vars</code></td>
<td>
<p>the names of the variables which are of interest.
This need not include intermediate variables, but instead is the
vector of names of the variables that the caller wants defined ultimately.</p>
</td></tr>
<tr><td><code id="sourceVariable_+3A_doc">doc</code></td>
<td>
<p>the document containing the code blocks</p>
</td></tr>
<tr><td><code id="sourceVariable_+3A_frags">frags</code></td>
<td>
<p>the code fragments</p>
</td></tr>
<tr><td><code id="sourceVariable_+3A_eval">eval</code></td>
<td>
<p>whether to evaluate the necessary code blocks or just
return them.</p>
</td></tr>
<tr><td><code id="sourceVariable_+3A_env">env</code></td>
<td>
<p>the environment in which to evaluate the code blocks.</p>
</td></tr>
<tr><td><code id="sourceVariable_+3A_nestedenvironments">nestedEnvironments</code></td>
<td>
<p>a logical value indicating whether to
evaluate each of the different code blocks within their own
environment that is chained to the previous one.</p>
</td></tr>
<tr><td><code id="sourceVariable_+3A_verbose">verbose</code></td>
<td>
<p>a logical value indicating whether to print the
expression being evaluated before it is actually evaluated.</p>
</td></tr>
<tr><td><code id="sourceVariable_+3A_checklibraries">checkLibraries</code></td>
<td>
<p>a logical value that controls whether we check
for functions that are not currently available and if there are any
whether we add calls to load libraries in <code><a href="#topic+getVariableDepends">getVariableDepends</a></code>.</p>
</td></tr>
<tr><td><code id="sourceVariable_+3A_force">force</code></td>
<td>
<p>a logical value that controls whether we evaluate the
expressions if they variables appear to exist.</p>
</td></tr>
<tr><td><code id="sourceVariable_+3A_first">first</code></td>
<td>
<p>a logical value.
This is intended  to allow running up to the first instance of the variable, not all of them.</p>
</td></tr>
<tr><td><code id="sourceVariable_+3A_info">info</code></td>
<td>
<p>the information about each expression.  This is computed
automatically, but the caller can specify it to avoid redundant computations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>eval</code> is <code>TRUE</code>, a list of the results
of evaluating the code blocks. Alternatively,
if <code>eval</code> is <code>FALSE</code>, this returns the expressions
constituting the code blocks. In this case, the function is the same
as <code><a href="#topic+getVariableDepends">getVariableDepends</a></code>
</p>


<h3>Note</h3>

<p>We should add a <code>nestedEnvironments</code> parameter as in
runUpToSection.  In fact, consolidate the code so it can be shared.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>See Also</h3>

<p><code><a href="#topic+getVariableDepends">getVariableDepends</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> f = system.file("samples", "dual.R", package = "CodeDepends")
 e = readScript(f)
 getVariableDepends("k", frags = e)
 sourceVariable("k", frags = e, verbose = TRUE)
</code></pre>

<hr>
<h2 id='splitRedefinitions'>Divide a script into separate lists of code based on redefinition
of a variable</h2><span id='topic+splitRedefinitions'></span>

<h3>Description</h3>

<p>The purpose of this  function is to take a script consisting
of individual calls or code blocks and to divide
it into separate blocks in which a particular variable
has only one definition.
Within each block the variable is assigned a new value.
</p>
<p>At present, the code is quite simple and separates
code blocks that merely alter an existing variable's
characteristics, e.g. setting the names, an individual variable.
Ideally we want to separate very different uses of
a symbol/variable name which are unrelated. We will add more
sophisticated code to (heuristically) detect such different uses,
e.g. explicit assignments to a variable.
</p>
<p>Separating these code blocks can make it easier to treat the
definitions separately and the different stages of the script.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitRedefinitions(var, info)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splitRedefinitions_+3A_var">var</code></td>
<td>
<p>the name of the variable whose redefinition will identify
the different code blocks</p>
</td></tr>
<tr><td><code id="splitRedefinitions_+3A_info">info</code></td>
<td>
<p>a list of <code><a href="#topic+ScriptNodeInfo-class">ScriptNodeInfo-class</a></code> objects
identifying the input and output variables for each code block.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with as many elements as there are (re)definitions of the
variable each being a list of code blocks.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>See Also</h3>

<p><code><a href="#topic+readScript">readScript</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'> sc = readScript(system.file("samples", "redef.R", package =
  "CodeDepends"))
scinfo = getInputs(sc)
 groups = splitRedefinitions("x", scinfo)
</code></pre>

<hr>
<h2 id='updatingScript'>Create a Script object that re-reads the original file as needed</h2><span id='topic+updatingScript'></span><span id='topic+coerce+2CDynScript+2CScript-method'></span><span id='topic+getInputs+2CDynScript-method'></span>

<h3>Description</h3>

<p>This function reads the code in a particular document
and creates a <code><a href="#topic+Script-class">Script-class</a></code> object
to represent the code and allow us to do analysis
on that code.
Unlike <code><a href="#topic+readScript">readScript</a></code>, this object
continues to read any updates to the original code file
when we use this <code>Script</code> object in computations.
This allows us to modify the original source interactively
and  concurrently with our R session and still have the
script remain up-to-date  with that code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updatingScript(doc, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="updatingScript_+3A_doc">doc</code></td>
<td>
<p>the name/location of the document containing the R code</p>
</td></tr>
<tr><td><code id="updatingScript_+3A_...">...</code></td>
<td>
<p>any additional arguments, passed to <code><a href="#topic+readScript">readScript</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This uses a reference class to update state across calls.
</p>


<h3>Value</h3>

<p>an object of class <code>DynScript</code>
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readScript">readScript</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fil &lt;- file.path(tempdir(), "foo.R")
cat("x = 1:10\ny = 3*x + 7 + rnorm(length(x))\n",  file = fil)
sc = updatingScript(fil)

as(sc, "Script")

con = file(fil, "at")
cat("z = x + y", file = con)
close(con)

as(sc, "Script")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
