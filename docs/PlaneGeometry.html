<!DOCTYPE html><html><head><title>Help for package PlaneGeometry</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PlaneGeometry}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Affine'><p>R6 class representing an affine map.</p></a></li>
<li><a href='#AffineMappingEllipse2Ellipse'><p>Affine transformation mapping a given ellipse to a given ellipse</p></a></li>
<li><a href='#AffineMappingThreePoints'><p>Affine transformation mapping three given points to three given points</p></a></li>
<li><a href='#Arc'><p>R6 class representing a circular arc</p></a></li>
<li><a href='#Circle'><p>R6 class representing a circle</p></a></li>
<li><a href='#CircleAB'><p>Circle given by a diameter</p></a></li>
<li><a href='#CircleOA'><p>Circle given by its center and a point</p></a></li>
<li><a href='#crossRatio'><p>Cross ratio</p></a></li>
<li><a href='#draw'><p>Draw a geometric object</p></a></li>
<li><a href='#Ellipse'><p>R6 class representing an ellipse</p></a></li>
<li><a href='#EllipseEquationFromFivePoints'><p>Ellipse equation from five points</p></a></li>
<li><a href='#EllipseFromCenterAndMatrix'><p>Ellipse from center and matrix</p></a></li>
<li><a href='#EllipseFromEquation'><p>Ellipse from its implicit equation</p></a></li>
<li><a href='#EllipseFromFivePoints'><p>Ellipse from five points</p></a></li>
<li><a href='#EllipseFromFociAndOnePoint'><p>Ellipse from foci and one point</p></a></li>
<li><a href='#EllipseFromThreeBoundaryPoints'><p>Smallest ellipse that passes through three boundary points</p></a></li>
<li><a href='#EllipticalArc'><p>R6 class representing an elliptical arc</p></a></li>
<li><a href='#fitEllipse'><p>Fit an ellipse</p></a></li>
<li><a href='#GaussianEllipse'><p>Gaussian ellipse</p></a></li>
<li><a href='#Homothety'><p>R6 class representing a homothety</p></a></li>
<li><a href='#Hyperbola'><p>R6 class representing a hyperbola</p></a></li>
<li><a href='#HyperbolaFromEquation'><p>Hyperbola object from the hyperbola equation.</p></a></li>
<li><a href='#intersectionCircleCircle'><p>Intersection of two circles</p></a></li>
<li><a href='#intersectionCircleLine'><p>Intersection of a circle and a line</p></a></li>
<li><a href='#intersectionEllipseLine'><p>Intersection of an ellipse and a line</p></a></li>
<li><a href='#intersectionLineLine'><p>Intersection of two lines</p></a></li>
<li><a href='#Inversion'><p>R6 class representing an inversion</p></a></li>
<li><a href='#inversionFixingThreeCircles'><p>Inversion fixing three circles</p></a></li>
<li><a href='#inversionFixingTwoCircles'><p>Inversion fixing two circles</p></a></li>
<li><a href='#inversionFromCircle'><p>Inversion on a circle</p></a></li>
<li><a href='#inversionKeepingCircle'><p>Inversion keeping a circle unchanged</p></a></li>
<li><a href='#inversionSwappingTwoCircles'><p>Inversion swapping two circles</p></a></li>
<li><a href='#Line'><p>R6 class representing a line</p></a></li>
<li><a href='#LineFromEquation'><p>Line from general equation</p></a></li>
<li><a href='#LineFromInterceptAndSlope'><p>Line from intercept and slope</p></a></li>
<li><a href='#LownerJohnEllipse'><p>Löwner-John ellipse (ellipse hull)</p></a></li>
<li><a href='#maxAreaInscribedCircle'><p>Maximum area circle inscribed in a convex polygon</p></a></li>
<li><a href='#maxAreaInscribedEllipse'><p>Maximum area ellipse inscribed in a convex polygon</p></a></li>
<li><a href='#midCircles'><p>Mid-circle(s)</p></a></li>
<li><a href='#Mobius'><p>R6 class representing a Möbius transformation.</p></a></li>
<li><a href='#MobiusMappingCircle'><p>Möbius transformation mapping a given circle to a given circle</p></a></li>
<li><a href='#MobiusMappingThreePoints'><p>Möbius transformation mapping three given points to three given points</p></a></li>
<li><a href='#MobiusSwappingTwoPoints'><p>Möbius transformation swapping two given points</p></a></li>
<li><a href='#Projection'><p>R6 class representing a projection</p></a></li>
<li><a href='#radicalCenter'><p>Radical center</p></a></li>
<li><a href='#Reflection'><p>R6 class representing a reflection</p></a></li>
<li><a href='#Rotation'><p>R6 class representing a rotation</p></a></li>
<li><a href='#Scaling'><p>R6 class representing a (non-uniform) scaling</p></a></li>
<li><a href='#ScalingXY'><p>R6 class representing an axis-scaling</p></a></li>
<li><a href='#Shear'><p>R6 class representing a shear transformation</p></a></li>
<li><a href='#soddyCircle'><p>Inner Soddy circle</p></a></li>
<li><a href='#SteinerChain'><p>Steiner chain</p></a></li>
<li><a href='#Translation'><p>R6 class representing a translation</p></a></li>
<li><a href='#Triangle'><p>R6 class representing a triangle</p></a></li>
<li><a href='#TriangleThreeLines'><p>Triangle defined by three lines</p></a></li>
<li><a href='#unitCircle'><p>Unit circle</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Plane Geometry</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Stéphane Laurent</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stéphane Laurent &lt;laurent_step@outlook.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An extensive set of plane geometry routines. Provides R6
    classes representing triangles, circles, circular arcs, ellipses,
    elliptical arcs, lines, hyperbolae, and their plot methods. Also 
    provides R6 classes representing transformations: rotations, 
    reflections, homotheties, scalings, general affine transformations, 
    inversions, Möbius transformations.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/stla/PlaneGeometry">https://github.com/stla/PlaneGeometry</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stla/PlaneGeometry/issues">https://github.com/stla/PlaneGeometry/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Carlson, CVXR, fitConic, graphics, methods, R6, rcdd, sdpt3r,
stringr, uniformly</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ellipse, elliptic, freegroup, knitr, rgl, rmarkdown, sets,
testthat, viridisLite</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-09 13:05:29 UTC; SDL96354</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-09 21:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Affine'>R6 class representing an affine map.</h2><span id='topic+Affine'></span>

<h3>Description</h3>

<p>An affine map is given by a 2x2 matrix
(a linear transformation) and a vector (the &quot;intercept&quot;).
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>A</code></dt><dd><p>get or set the matrix <code>A</code></p>
</dd>
<dt><code>b</code></dt><dd><p>get or set the vector <code>b</code></p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Affine-new"><code>Affine$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Affine-print"><code>Affine$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Affine-get3x3matrix"><code>Affine$get3x3matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-Affine-inverse"><code>Affine$inverse()</code></a>
</p>
</li>
<li> <p><a href="#method-Affine-compose"><code>Affine$compose()</code></a>
</p>
</li>
<li> <p><a href="#method-Affine-transform"><code>Affine$transform()</code></a>
</p>
</li>
<li> <p><a href="#method-Affine-transformLine"><code>Affine$transformLine()</code></a>
</p>
</li>
<li> <p><a href="#method-Affine-transformEllipse"><code>Affine$transformEllipse()</code></a>
</p>
</li>
<li> <p><a href="#method-Affine-clone"><code>Affine$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Affine-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Affine</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Affine$new(A, b)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>A</code></dt><dd><p>the 2x2 matrix of the affine map</p>
</dd>
<dt><code>b</code></dt><dd><p>the shift vector of the affine map</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Affine</code> object.
</p>


<hr>
<a id="method-Affine-print"></a>



<h4>Method <code>print()</code></h4>

<p>Show instance of an <code>Affine</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Affine$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>Affine$new(rbind(c(3.5,2),c(0,4)), c(-1, 1.25))
</pre>
</div>


<hr>
<a id="method-Affine-get3x3matrix"></a>



<h4>Method <code>get3x3matrix()</code></h4>

<p>The 3x3 matrix representing the affine map.
</p>


<h5>Usage</h5>

<div class="r"><pre>Affine$get3x3matrix()</pre></div>


<hr>
<a id="method-Affine-inverse"></a>



<h4>Method <code>inverse()</code></h4>

<p>The inverse affine transformation, if it exists.
</p>


<h5>Usage</h5>

<div class="r"><pre>Affine$inverse()</pre></div>


<hr>
<a id="method-Affine-compose"></a>



<h4>Method <code>compose()</code></h4>

<p>Compose the reference affine map with another
affine map.
</p>


<h5>Usage</h5>

<div class="r"><pre>Affine$compose(transfo, left = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>transfo</code></dt><dd><p>an <code>Affine</code> object</p>
</dd>
<dt><code>left</code></dt><dd><p>logical, whether to compose at left or at right (i.e.
returns <code>f1 o f0</code> or <code>f0 o f1</code>)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An <code>Affine</code> object.
</p>


<hr>
<a id="method-Affine-transform"></a>



<h4>Method <code>transform()</code></h4>

<p>Transform a point or several points by the reference affine map.
</p>


<h5>Usage</h5>

<div class="r"><pre>Affine$transform(M)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>M</code></dt><dd><p>a point or a two-column matrix of points, one point per row</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Affine-transformLine"></a>



<h4>Method <code>transformLine()</code></h4>

<p>Transform a line by the reference affine transformation
(only for invertible affine maps).
</p>


<h5>Usage</h5>

<div class="r"><pre>Affine$transformLine(line)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>line</code></dt><dd><p>a <code>Line</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Line</code> object.
</p>


<hr>
<a id="method-Affine-transformEllipse"></a>



<h4>Method <code>transformEllipse()</code></h4>

<p>Transform an ellipse by the reference affine transformation
(only for an invertible affine map).
The result is an ellipse.
</p>


<h5>Usage</h5>

<div class="r"><pre>Affine$transformEllipse(ell)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ell</code></dt><dd><p>an <code>Ellipse</code> object or a <code>Circle</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An <code>Ellipse</code> object.
</p>


<hr>
<a id="method-Affine-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Affine$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `Affine$print`
## ------------------------------------------------

Affine$new(rbind(c(3.5,2),c(0,4)), c(-1, 1.25))
</code></pre>

<hr>
<h2 id='AffineMappingEllipse2Ellipse'>Affine transformation mapping a given ellipse to a given ellipse</h2><span id='topic+AffineMappingEllipse2Ellipse'></span>

<h3>Description</h3>

<p>Return the affine transformation which transforms
<code>ell1</code> to <code>ell2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AffineMappingEllipse2Ellipse(ell1, ell2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AffineMappingEllipse2Ellipse_+3A_ell1">ell1</code>, <code id="AffineMappingEllipse2Ellipse_+3A_ell2">ell2</code></td>
<td>
<p><code>Ellipse</code> or <code>Circle</code> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>Affine</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ell1 &lt;- Ellipse$new(c(1,1), 5, 1, 30)
( ell2 &lt;- Ellipse$new(c(4,-1), 3, 2, 50) )
f &lt;- AffineMappingEllipse2Ellipse(ell1, ell2)
f$transformEllipse(ell1) # should be ell2
</code></pre>

<hr>
<h2 id='AffineMappingThreePoints'>Affine transformation mapping three given points to three given points</h2><span id='topic+AffineMappingThreePoints'></span>

<h3>Description</h3>

<p>Return the affine transformation which sends
<code>P1</code> to <code>Q1</code>, <code>P2</code> to <code>Q2</code> and <code>P3</code> to <code>Q3</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AffineMappingThreePoints(P1, P2, P3, Q1, Q2, Q3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AffineMappingThreePoints_+3A_p1">P1</code>, <code id="AffineMappingThreePoints_+3A_p2">P2</code>, <code id="AffineMappingThreePoints_+3A_p3">P3</code></td>
<td>
<p>three non-collinear points</p>
</td></tr>
<tr><td><code id="AffineMappingThreePoints_+3A_q1">Q1</code>, <code id="AffineMappingThreePoints_+3A_q2">Q2</code>, <code id="AffineMappingThreePoints_+3A_q3">Q3</code></td>
<td>
<p>three non-collinear points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>Affine</code> object.
</p>

<hr>
<h2 id='Arc'>R6 class representing a circular arc</h2><span id='topic+Arc'></span>

<h3>Description</h3>

<p>An arc is given by a center, a radius, a starting angle and
an ending angle. They are respectively named <code>center</code>, <code>radius</code>,
<code>alpha1</code> and <code>alpha2</code>.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>center</code></dt><dd><p>get or set the center</p>
</dd>
<dt><code>radius</code></dt><dd><p>get or set the radius</p>
</dd>
<dt><code>alpha1</code></dt><dd><p>get or set the starting angle</p>
</dd>
<dt><code>alpha2</code></dt><dd><p>get or set the ending angle</p>
</dd>
<dt><code>degrees</code></dt><dd><p>get or set the <code>degrees</code> field</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Arc-new"><code>Arc$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Arc-print"><code>Arc$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Arc-startingPoint"><code>Arc$startingPoint()</code></a>
</p>
</li>
<li> <p><a href="#method-Arc-endingPoint"><code>Arc$endingPoint()</code></a>
</p>
</li>
<li> <p><a href="#method-Arc-isEqual"><code>Arc$isEqual()</code></a>
</p>
</li>
<li> <p><a href="#method-Arc-complementaryArc"><code>Arc$complementaryArc()</code></a>
</p>
</li>
<li> <p><a href="#method-Arc-path"><code>Arc$path()</code></a>
</p>
</li>
<li> <p><a href="#method-Arc-clone"><code>Arc$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Arc-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Arc</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Arc$new(center, radius, alpha1, alpha2, degrees = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>center</code></dt><dd><p>the center</p>
</dd>
<dt><code>radius</code></dt><dd><p>the radius</p>
</dd>
<dt><code>alpha1</code></dt><dd><p>the starting angle</p>
</dd>
<dt><code>alpha2</code></dt><dd><p>the ending angle</p>
</dd>
<dt><code>degrees</code></dt><dd><p>logical, whether <code>alpha1</code> and <code>alpha2</code> are
given in degrees</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Arc</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>arc &lt;- Arc$new(c(1,1), 1, 45, 90)
arc
arc$center
arc$center &lt;- c(0,0)
arc
</pre>
</div>


<hr>
<a id="method-Arc-print"></a>



<h4>Method <code>print()</code></h4>

<p>Show instance of an <code>Arc</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Arc$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>Arc$new(c(0,0), 2, pi/4, pi/2, FALSE)
</pre>
</div>


<hr>
<a id="method-Arc-startingPoint"></a>



<h4>Method <code>startingPoint()</code></h4>

<p>Starting point of the reference arc.
</p>


<h5>Usage</h5>

<div class="r"><pre>Arc$startingPoint()</pre></div>


<hr>
<a id="method-Arc-endingPoint"></a>



<h4>Method <code>endingPoint()</code></h4>

<p>Ending point of the reference arc.
</p>


<h5>Usage</h5>

<div class="r"><pre>Arc$endingPoint()</pre></div>


<hr>
<a id="method-Arc-isEqual"></a>



<h4>Method <code>isEqual()</code></h4>

<p>Check whether the reference arc equals another arc.
</p>


<h5>Usage</h5>

<div class="r"><pre>Arc$isEqual(arc)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>arc</code></dt><dd><p>an <code>Arc</code> object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Arc-complementaryArc"></a>



<h4>Method <code>complementaryArc()</code></h4>

<p>Complementary arc of the reference arc.
</p>


<h5>Usage</h5>

<div class="r"><pre>Arc$complementaryArc()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>arc &lt;- Arc$new(c(0,0), 1, 30, 60)
plot(NULL, type = "n", asp = 1, xlim = c(-1,1), ylim = c(-1,1),
     xlab = NA, ylab = NA)
draw(arc, lwd = 3, col = "red")
draw(arc$complementaryArc(), lwd = 3, col = "green")
</pre>
</div>


<hr>
<a id="method-Arc-path"></a>



<h4>Method <code>path()</code></h4>

<p>The reference arc as a path.
</p>


<h5>Usage</h5>

<div class="r"><pre>Arc$path(npoints = 100L)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>npoints</code></dt><dd><p>number of points of the path</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A matrix with two columns <code>x</code> and <code>y</code> of length
<code>npoints</code>. See &quot;Filling the lapping area of two circles&quot; in the
vignette for an example.
</p>


<hr>
<a id="method-Arc-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Arc$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `Arc$new`
## ------------------------------------------------

arc &lt;- Arc$new(c(1,1), 1, 45, 90)
arc
arc$center
arc$center &lt;- c(0,0)
arc

## ------------------------------------------------
## Method `Arc$print`
## ------------------------------------------------

Arc$new(c(0,0), 2, pi/4, pi/2, FALSE)

## ------------------------------------------------
## Method `Arc$complementaryArc`
## ------------------------------------------------

arc &lt;- Arc$new(c(0,0), 1, 30, 60)
plot(NULL, type = "n", asp = 1, xlim = c(-1,1), ylim = c(-1,1),
     xlab = NA, ylab = NA)
draw(arc, lwd = 3, col = "red")
draw(arc$complementaryArc(), lwd = 3, col = "green")
</code></pre>

<hr>
<h2 id='Circle'>R6 class representing a circle</h2><span id='topic+Circle'></span>

<h3>Description</h3>

<p>A circle is given by a center and a radius,
named <code>center</code> and <code>radius</code>.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>center</code></dt><dd><p>get or set the center</p>
</dd>
<dt><code>radius</code></dt><dd><p>get or set the radius</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Circle-new"><code>Circle$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Circle-print"><code>Circle$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Circle-pointFromAngle"><code>Circle$pointFromAngle()</code></a>
</p>
</li>
<li> <p><a href="#method-Circle-diameter"><code>Circle$diameter()</code></a>
</p>
</li>
<li> <p><a href="#method-Circle-tangent"><code>Circle$tangent()</code></a>
</p>
</li>
<li> <p><a href="#method-Circle-tangentsThroughExternalPoint"><code>Circle$tangentsThroughExternalPoint()</code></a>
</p>
</li>
<li> <p><a href="#method-Circle-isEqual"><code>Circle$isEqual()</code></a>
</p>
</li>
<li> <p><a href="#method-Circle-isDifferent"><code>Circle$isDifferent()</code></a>
</p>
</li>
<li> <p><a href="#method-Circle-isOrthogonal"><code>Circle$isOrthogonal()</code></a>
</p>
</li>
<li> <p><a href="#method-Circle-angle"><code>Circle$angle()</code></a>
</p>
</li>
<li> <p><a href="#method-Circle-includes"><code>Circle$includes()</code></a>
</p>
</li>
<li> <p><a href="#method-Circle-orthogonalThroughTwoPointsOnCircle"><code>Circle$orthogonalThroughTwoPointsOnCircle()</code></a>
</p>
</li>
<li> <p><a href="#method-Circle-orthogonalThroughTwoPointsWithinCircle"><code>Circle$orthogonalThroughTwoPointsWithinCircle()</code></a>
</p>
</li>
<li> <p><a href="#method-Circle-power"><code>Circle$power()</code></a>
</p>
</li>
<li> <p><a href="#method-Circle-radicalCenter"><code>Circle$radicalCenter()</code></a>
</p>
</li>
<li> <p><a href="#method-Circle-radicalAxis"><code>Circle$radicalAxis()</code></a>
</p>
</li>
<li> <p><a href="#method-Circle-rotate"><code>Circle$rotate()</code></a>
</p>
</li>
<li> <p><a href="#method-Circle-translate"><code>Circle$translate()</code></a>
</p>
</li>
<li> <p><a href="#method-Circle-invert"><code>Circle$invert()</code></a>
</p>
</li>
<li> <p><a href="#method-Circle-asEllipse"><code>Circle$asEllipse()</code></a>
</p>
</li>
<li> <p><a href="#method-Circle-randomPoints"><code>Circle$randomPoints()</code></a>
</p>
</li>
<li> <p><a href="#method-Circle-clone"><code>Circle$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Circle-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Circle</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Circle$new(center, radius)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>center</code></dt><dd><p>the center</p>
</dd>
<dt><code>radius</code></dt><dd><p>the radius</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Circle</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>circ &lt;- Circle$new(c(1,1), 1)
circ
circ$center
circ$center &lt;- c(0,0)
circ
</pre>
</div>


<hr>
<a id="method-Circle-print"></a>



<h4>Method <code>print()</code></h4>

<p>Show instance of a circle object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Circle$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>Circle$new(c(0,0), 2)
</pre>
</div>


<hr>
<a id="method-Circle-pointFromAngle"></a>



<h4>Method <code>pointFromAngle()</code></h4>

<p>Get a point on the reference circle from its polar angle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Circle$pointFromAngle(alpha, degrees = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>alpha</code></dt><dd><p>a number, the angle</p>
</dd>
<dt><code>degrees</code></dt><dd><p>logical, whether <code>alpha</code> is given in degrees</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The point on the circle with polar angle <code>alpha</code>.
</p>


<hr>
<a id="method-Circle-diameter"></a>



<h4>Method <code>diameter()</code></h4>

<p>Diameter of the reference circle for a given polar angle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Circle$diameter(alpha)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>alpha</code></dt><dd><p>an angle in radians, there is one diameter for each value of
<code>alpha</code> modulo <code>pi</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A segment (<code>Line</code> object).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>circ &lt;- Circle$new(c(1,1), 5)
diams &lt;- lapply(c(0, pi/3, 2*pi/3), circ$diameter)
plot(NULL, type="n", asp=1, xlim = c(-4,6), ylim = c(-5,7),
     xlab = NA, ylab = NA)
draw(circ, lwd = 2, col = "yellow")
invisible(lapply(diams, draw, col = "blue"))
</pre>
</div>


<hr>
<a id="method-Circle-tangent"></a>



<h4>Method <code>tangent()</code></h4>

<p>Tangent of the reference circle at a given polar angle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Circle$tangent(alpha)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>alpha</code></dt><dd><p>an angle in radians, there is one tangent for each value of
<code>alpha</code> modulo <code>2*pi</code></p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>circ &lt;- Circle$new(c(1,1), 5)
tangents &lt;- lapply(c(0, pi/3, 2*pi/3, pi, 4*pi/3, 5*pi/3), circ$tangent)
plot(NULL, type="n", asp=1, xlim = c(-4,6), ylim = c(-5,7),
     xlab = NA, ylab = NA)
draw(circ, lwd = 2, col = "yellow")
invisible(lapply(tangents, draw, col = "blue"))
</pre>
</div>


<hr>
<a id="method-Circle-tangentsThroughExternalPoint"></a>



<h4>Method <code>tangentsThroughExternalPoint()</code></h4>

<p>Return the two tangents of the reference circle passing
through an external point.
</p>


<h5>Usage</h5>

<div class="r"><pre>Circle$tangentsThroughExternalPoint(P)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>P</code></dt><dd><p>a point external to the reference circle</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of two <code>Line</code> objects, the two tangents; the
tangency points are in the <code>B</code> field of the lines.
</p>


<hr>
<a id="method-Circle-isEqual"></a>



<h4>Method <code>isEqual()</code></h4>

<p>Check whether the reference circle equals another circle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Circle$isEqual(circ)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>circ</code></dt><dd><p>a <code>Circle</code> object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Circle-isDifferent"></a>



<h4>Method <code>isDifferent()</code></h4>

<p>Check whether the reference circle differs from another circle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Circle$isDifferent(circ)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>circ</code></dt><dd><p>a <code>Circle</code> object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Circle-isOrthogonal"></a>



<h4>Method <code>isOrthogonal()</code></h4>

<p>Check whether the reference circle is orthogonal to a
given circle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Circle$isOrthogonal(circ)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>circ</code></dt><dd><p>a <code>Circle</code> object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Circle-angle"></a>



<h4>Method <code>angle()</code></h4>

<p>Angle between the reference circle and a given circle,
if they intersect.
</p>


<h5>Usage</h5>

<div class="r"><pre>Circle$angle(circ)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>circ</code></dt><dd><p>a <code>Circle</code> object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Circle-includes"></a>



<h4>Method <code>includes()</code></h4>

<p>Check whether a point belongs to the reference circle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Circle$includes(M)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>M</code></dt><dd><p>a point</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Circle-orthogonalThroughTwoPointsOnCircle"></a>



<h4>Method <code>orthogonalThroughTwoPointsOnCircle()</code></h4>

<p>Orthogonal circle passing through two points on the reference circle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Circle$orthogonalThroughTwoPointsOnCircle(alpha1, alpha2, arc = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>alpha1, alpha2</code></dt><dd><p>two angles defining two points on the reference circle</p>
</dd>
<dt><code>arc</code></dt><dd><p>logical, whether to return only the arc at the interior of the
reference circle</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Circle</code> object if <code>arc=FALSE</code>, an <code>Arc</code> object
if <code>arc=TRUE</code>, or a <code>Line</code> object: the diameter
of the reference circle defined by the two points in case when the two
angles differ by <code>pi</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># hyperbolic triangle
circ &lt;- Circle$new(c(5,5), 3)
arc1 &lt;- circ$orthogonalThroughTwoPointsOnCircle(0, 2*pi/3, arc = TRUE)
arc2 &lt;- circ$orthogonalThroughTwoPointsOnCircle(2*pi/3, 4*pi/3, arc = TRUE)
arc3 &lt;- circ$orthogonalThroughTwoPointsOnCircle(4*pi/3, 0, arc = TRUE)
opar &lt;- par(mar = c(0,0,0,0))
plot(0, 0, type = "n", asp = 1, xlim = c(2,8), ylim = c(2,8))
draw(circ)
draw(arc1, col = "red", lwd = 2)
draw(arc2, col = "green", lwd = 2)
draw(arc3, col = "blue", lwd = 2)
par(opar)
</pre>
</div>


<hr>
<a id="method-Circle-orthogonalThroughTwoPointsWithinCircle"></a>



<h4>Method <code>orthogonalThroughTwoPointsWithinCircle()</code></h4>

<p>Orthogonal circle passing through two points within the reference circle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Circle$orthogonalThroughTwoPointsWithinCircle(P1, P2, arc = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>P1, P2</code></dt><dd><p>two distinct points in the interior of the reference circle</p>
</dd>
<dt><code>arc</code></dt><dd><p>logical, whether to return the arc joining the two points
instead of the circle</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Circle</code> object or an <code>Arc</code> object,
or a <code>Line</code> object if the two points are on a diameter.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>circ &lt;- Circle$new(c(0,0),3)
P1 &lt;- c(1,1); P2 &lt;- c(1, 2)
ocirc &lt;- circ$orthogonalThroughTwoPointsWithinCircle(P1, P2)
arc &lt;- circ$orthogonalThroughTwoPointsWithinCircle(P1, P2, arc = TRUE)
plot(0, 0, type = "n", asp = 1, xlab = NA, ylab = NA,
     xlim = c(-3, 4), ylim = c(-3, 4))
draw(circ, lwd = 2)
draw(ocirc, lty = "dashed", lwd = 2)
draw(arc, lwd = 3, col = "blue")
</pre>
</div>


<hr>
<a id="method-Circle-power"></a>



<h4>Method <code>power()</code></h4>

<p>Power of a point with respect to the reference circle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Circle$power(M)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>M</code></dt><dd><p>point</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A number.
</p>


<hr>
<a id="method-Circle-radicalCenter"></a>



<h4>Method <code>radicalCenter()</code></h4>

<p>Radical center of two circles.
</p>


<h5>Usage</h5>

<div class="r"><pre>Circle$radicalCenter(circ2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>circ2</code></dt><dd><p>a <code>Circle</code> object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Circle-radicalAxis"></a>



<h4>Method <code>radicalAxis()</code></h4>

<p>Radical axis of two circles.
</p>


<h5>Usage</h5>

<div class="r"><pre>Circle$radicalAxis(circ2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>circ2</code></dt><dd><p>a <code>Circle</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Line</code> object.
</p>


<hr>
<a id="method-Circle-rotate"></a>



<h4>Method <code>rotate()</code></h4>

<p>Rotate the reference circle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Circle$rotate(alpha, O, degrees = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>alpha</code></dt><dd><p>angle of rotation</p>
</dd>
<dt><code>O</code></dt><dd><p>center of rotation</p>
</dd>
<dt><code>degrees</code></dt><dd><p>logical, whether <code>alpha</code> is given in degrees</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Circle</code> object.
</p>


<hr>
<a id="method-Circle-translate"></a>



<h4>Method <code>translate()</code></h4>

<p>Translate the reference circle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Circle$translate(v)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt><dd><p>the vector of translation</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Circle</code> object.
</p>


<hr>
<a id="method-Circle-invert"></a>



<h4>Method <code>invert()</code></h4>

<p>Invert the reference circle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Circle$invert(inversion)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>inversion</code></dt><dd><p>an <code>Inversion</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Circle</code> object or a <code>Line</code> object.
</p>


<hr>
<a id="method-Circle-asEllipse"></a>



<h4>Method <code>asEllipse()</code></h4>

<p>Convert the reference circle to an <code>Ellipse</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Circle$asEllipse()</pre></div>


<hr>
<a id="method-Circle-randomPoints"></a>



<h4>Method <code>randomPoints()</code></h4>

<p>Random points on or in the reference circle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Circle$randomPoints(n, where = "in")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>an integer, the desired number of points</p>
</dd>
<dt><code>where</code></dt><dd><p><code>"in"</code> to generate inside the circle,
<code>"on"</code> to generate on the circle</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The generated points in a two columns matrix with <code>n</code> rows.
</p>


<hr>
<a id="method-Circle-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Circle$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+radicalCenter">radicalCenter</a></code> for the radical center of three circles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `Circle$new`
## ------------------------------------------------

circ &lt;- Circle$new(c(1,1), 1)
circ
circ$center
circ$center &lt;- c(0,0)
circ

## ------------------------------------------------
## Method `Circle$print`
## ------------------------------------------------

Circle$new(c(0,0), 2)

## ------------------------------------------------
## Method `Circle$diameter`
## ------------------------------------------------

circ &lt;- Circle$new(c(1,1), 5)
diams &lt;- lapply(c(0, pi/3, 2*pi/3), circ$diameter)
plot(NULL, type="n", asp=1, xlim = c(-4,6), ylim = c(-5,7),
     xlab = NA, ylab = NA)
draw(circ, lwd = 2, col = "yellow")
invisible(lapply(diams, draw, col = "blue"))

## ------------------------------------------------
## Method `Circle$tangent`
## ------------------------------------------------

circ &lt;- Circle$new(c(1,1), 5)
tangents &lt;- lapply(c(0, pi/3, 2*pi/3, pi, 4*pi/3, 5*pi/3), circ$tangent)
plot(NULL, type="n", asp=1, xlim = c(-4,6), ylim = c(-5,7),
     xlab = NA, ylab = NA)
draw(circ, lwd = 2, col = "yellow")
invisible(lapply(tangents, draw, col = "blue"))

## ------------------------------------------------
## Method `Circle$orthogonalThroughTwoPointsOnCircle`
## ------------------------------------------------

# hyperbolic triangle
circ &lt;- Circle$new(c(5,5), 3)
arc1 &lt;- circ$orthogonalThroughTwoPointsOnCircle(0, 2*pi/3, arc = TRUE)
arc2 &lt;- circ$orthogonalThroughTwoPointsOnCircle(2*pi/3, 4*pi/3, arc = TRUE)
arc3 &lt;- circ$orthogonalThroughTwoPointsOnCircle(4*pi/3, 0, arc = TRUE)
opar &lt;- par(mar = c(0,0,0,0))
plot(0, 0, type = "n", asp = 1, xlim = c(2,8), ylim = c(2,8))
draw(circ)
draw(arc1, col = "red", lwd = 2)
draw(arc2, col = "green", lwd = 2)
draw(arc3, col = "blue", lwd = 2)
par(opar)

## ------------------------------------------------
## Method `Circle$orthogonalThroughTwoPointsWithinCircle`
## ------------------------------------------------

circ &lt;- Circle$new(c(0,0),3)
P1 &lt;- c(1,1); P2 &lt;- c(1, 2)
ocirc &lt;- circ$orthogonalThroughTwoPointsWithinCircle(P1, P2)
arc &lt;- circ$orthogonalThroughTwoPointsWithinCircle(P1, P2, arc = TRUE)
plot(0, 0, type = "n", asp = 1, xlab = NA, ylab = NA,
     xlim = c(-3, 4), ylim = c(-3, 4))
draw(circ, lwd = 2)
draw(ocirc, lty = "dashed", lwd = 2)
draw(arc, lwd = 3, col = "blue")
</code></pre>

<hr>
<h2 id='CircleAB'>Circle given by a diameter</h2><span id='topic+CircleAB'></span>

<h3>Description</h3>

<p>Return the circle given by a diameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CircleAB(A, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CircleAB_+3A_a">A</code>, <code id="CircleAB_+3A_b">B</code></td>
<td>
<p>the endpoints of the diameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Circle</code> object.
</p>

<hr>
<h2 id='CircleOA'>Circle given by its center and a point</h2><span id='topic+CircleOA'></span>

<h3>Description</h3>

<p>Return the circle given by its center and a point it
passes through.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CircleOA(O, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CircleOA_+3A_o">O</code></td>
<td>
<p>the center of the circle</p>
</td></tr>
<tr><td><code id="CircleOA_+3A_a">A</code></td>
<td>
<p>a point of the circle</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Circle</code> object.
</p>

<hr>
<h2 id='crossRatio'>Cross ratio</h2><span id='topic+crossRatio'></span>

<h3>Description</h3>

<p>The cross ratio of four points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossRatio(A, B, C, D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossRatio_+3A_a">A</code>, <code id="crossRatio_+3A_b">B</code>, <code id="crossRatio_+3A_c">C</code>, <code id="crossRatio_+3A_d">D</code></td>
<td>
<p>four distinct points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A complex number. It is real if and only if the four points lie on
a generalized circle (that is a circle or a line).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c &lt;- Circle$new(c(0, 0), 1)
A &lt;- c$pointFromAngle(0)
B &lt;- c$pointFromAngle(90)
C &lt;- c$pointFromAngle(180)
D &lt;- c$pointFromAngle(270)
crossRatio(A, B, C, D) # should be real
Mob &lt;- Mobius$new(rbind(c(1+1i,2),c(0,3-2i)))
MA &lt;- Mob$transform(A)
MB &lt;- Mob$transform(B)
MC &lt;- Mob$transform(C)
MD &lt;- Mob$transform(D)
crossRatio(MA, MB, MC, MD) # should be identical to `crossRatio(A, B, C, D)`
</code></pre>

<hr>
<h2 id='draw'>Draw a geometric object</h2><span id='topic+draw'></span><span id='topic+draw.Triangle'></span><span id='topic+draw.Circle'></span><span id='topic+draw.Arc'></span><span id='topic+draw.Ellipse'></span><span id='topic+draw.EllipticalArc'></span><span id='topic+draw.Line'></span>

<h3>Description</h3>

<p>Draw a geometric object on the current plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw(x, ...)

## S3 method for class 'Triangle'
draw(x, ...)

## S3 method for class 'Circle'
draw(x, npoints = 100L, ...)

## S3 method for class 'Arc'
draw(x, npoints = 100L, ...)

## S3 method for class 'Ellipse'
draw(x, npoints = 100L, ...)

## S3 method for class 'EllipticalArc'
draw(x, npoints = 100L, ...)

## S3 method for class 'Line'
draw(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_+3A_x">x</code></td>
<td>
<p>geometric object (<code>Triangle</code>, <code>Circle</code>, <code>Line</code>,
<code>Ellipse</code>, <code>Arc</code>, <code>EllipticalArc</code>)</p>
</td></tr>
<tr><td><code id="draw_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="graphics.html#topic+lines">lines</a></code> for a <code>Triangle</code>
object, an <code>Arc</code> object or an <code>EllipticalArc</code> object,
to <code><a href="graphics.html#topic+polypath">polypath</a></code> for a <code>Circle</code> object or an
<code>Ellipse</code> object, general graphical parameters for a <code>Line</code>
object, passed to <code><a href="graphics.html#topic+lines">lines</a></code>, <code><a href="graphics.html#topic+curve">curve</a></code>, or
<code><a href="graphics.html#topic+abline">abline</a></code>.</p>
</td></tr>
<tr><td><code id="draw_+3A_npoints">npoints</code></td>
<td>
<p>integer, the number of points of the path</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># open new plot window
plot(0, 0, type="n", asp = 1, xlim = c(0,2.5), ylim = c(0,2.5),
     xlab = NA, ylab = NA)
grid()
# draw a triangle
t &lt;- Triangle$new(c(0,0), c(1,0), c(0.5,sqrt(3)/2))
draw(t, col = "blue", lwd = 2)
draw(t$rotate(90, t$C), col = "green", lwd = 2)
# draw a circle
circ &lt;- t$incircle()
draw(circ, col = "orange", border = "brown", lwd = 2)
# draw an ellipse
S &lt;- Scaling$new(circ$center, direction = c(2,1), scale = 2)
draw(S$scaleCircle(circ), border = "grey", lwd = 2)
# draw a line
l &lt;- Line$new(c(1,1), c(1.5,1.5), FALSE, TRUE)
draw(l, col = "red", lwd = 2)
perp &lt;- l$perpendicular(c(2,1))
draw(perp, col = "yellow", lwd = 2)
</code></pre>

<hr>
<h2 id='Ellipse'>R6 class representing an ellipse</h2><span id='topic+Ellipse'></span>

<h3>Description</h3>

<p>An ellipse is given by a center, two radii (<code>rmajor</code>
and <code>rminor</code>), and the angle (<code>alpha</code>) between the major axis and
the horizontal direction.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>center</code></dt><dd><p>get or set the center</p>
</dd>
<dt><code>rmajor</code></dt><dd><p>get or set the major radius of the ellipse</p>
</dd>
<dt><code>rminor</code></dt><dd><p>get or set the minor radius of the ellipse</p>
</dd>
<dt><code>alpha</code></dt><dd><p>get or set the angle of the ellipse</p>
</dd>
<dt><code>degrees</code></dt><dd><p>get or set the <code>degrees</code> field</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Ellipse-new"><code>Ellipse$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Ellipse-print"><code>Ellipse$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Ellipse-isEqual"><code>Ellipse$isEqual()</code></a>
</p>
</li>
<li> <p><a href="#method-Ellipse-equation"><code>Ellipse$equation()</code></a>
</p>
</li>
<li> <p><a href="#method-Ellipse-includes"><code>Ellipse$includes()</code></a>
</p>
</li>
<li> <p><a href="#method-Ellipse-contains"><code>Ellipse$contains()</code></a>
</p>
</li>
<li> <p><a href="#method-Ellipse-matrix"><code>Ellipse$matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-Ellipse-path"><code>Ellipse$path()</code></a>
</p>
</li>
<li> <p><a href="#method-Ellipse-diameter"><code>Ellipse$diameter()</code></a>
</p>
</li>
<li> <p><a href="#method-Ellipse-perimeter"><code>Ellipse$perimeter()</code></a>
</p>
</li>
<li> <p><a href="#method-Ellipse-pointFromAngle"><code>Ellipse$pointFromAngle()</code></a>
</p>
</li>
<li> <p><a href="#method-Ellipse-pointFromEccentricAngle"><code>Ellipse$pointFromEccentricAngle()</code></a>
</p>
</li>
<li> <p><a href="#method-Ellipse-semiMajorAxis"><code>Ellipse$semiMajorAxis()</code></a>
</p>
</li>
<li> <p><a href="#method-Ellipse-semiMinorAxis"><code>Ellipse$semiMinorAxis()</code></a>
</p>
</li>
<li> <p><a href="#method-Ellipse-foci"><code>Ellipse$foci()</code></a>
</p>
</li>
<li> <p><a href="#method-Ellipse-tangent"><code>Ellipse$tangent()</code></a>
</p>
</li>
<li> <p><a href="#method-Ellipse-normal"><code>Ellipse$normal()</code></a>
</p>
</li>
<li> <p><a href="#method-Ellipse-theta2t"><code>Ellipse$theta2t()</code></a>
</p>
</li>
<li> <p><a href="#method-Ellipse-regressionLines"><code>Ellipse$regressionLines()</code></a>
</p>
</li>
<li> <p><a href="#method-Ellipse-boundingbox"><code>Ellipse$boundingbox()</code></a>
</p>
</li>
<li> <p><a href="#method-Ellipse-randomPoints"><code>Ellipse$randomPoints()</code></a>
</p>
</li>
<li> <p><a href="#method-Ellipse-clone"><code>Ellipse$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Ellipse-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Ellipse</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Ellipse$new(center, rmajor, rminor, alpha, degrees = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>center</code></dt><dd><p>a point, the center of the rotation</p>
</dd>
<dt><code>rmajor</code></dt><dd><p>positive number, the major radius</p>
</dd>
<dt><code>rminor</code></dt><dd><p>positive number, the minor radius</p>
</dd>
<dt><code>alpha</code></dt><dd><p>a number, the angle between the major axis and the
horizontal direction</p>
</dd>
<dt><code>degrees</code></dt><dd><p>logical, whether <code>alpha</code> is given in degrees</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Ellipse</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>Ellipse$new(c(1,1), 3, 2, 30)
</pre>
</div>


<hr>
<a id="method-Ellipse-print"></a>



<h4>Method <code>print()</code></h4>

<p>Show instance of an <code>Ellipse</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Ellipse$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Ellipse-isEqual"></a>



<h4>Method <code>isEqual()</code></h4>

<p>Check whether the reference ellipse equals an ellipse.
</p>


<h5>Usage</h5>

<div class="r"><pre>Ellipse$isEqual(ell)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ell</code></dt><dd><p>An <code>Ellipse</code> object.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Ellipse-equation"></a>



<h4>Method <code>equation()</code></h4>

<p>The coefficients of the implicit equation of the ellipse.
</p>


<h5>Usage</h5>

<div class="r"><pre>Ellipse$equation()</pre></div>



<h5>Details</h5>

<p>The implicit equation of the ellipse is
<code>Ax² + Bxy + Cy² + Dx + Ey + F = 0</code>. This method returns
A, B, C, D, E and F.
</p>



<h5>Returns</h5>

<p>A named numeric vector.
</p>


<hr>
<a id="method-Ellipse-includes"></a>



<h4>Method <code>includes()</code></h4>

<p>Check whether a point lies on the reference ellipse.
</p>


<h5>Usage</h5>

<div class="r"><pre>Ellipse$includes(M)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>M</code></dt><dd><p>a point</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Ellipse-contains"></a>



<h4>Method <code>contains()</code></h4>

<p>Check whether a point is contained in the reference ellipse.
</p>


<h5>Usage</h5>

<div class="r"><pre>Ellipse$contains(M)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>M</code></dt><dd><p>a point</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Ellipse-matrix"></a>



<h4>Method <code>matrix()</code></h4>

<p>Returns the 2x2 matrix <code>S</code> associated to the reference
ellipse. The equation of the ellipse is <code>t(M-O) %*% S %*% (M-O) = 1</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Ellipse$matrix()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>ell &lt;- Ellipse$new(c(1,1), 5, 1, 30)
S &lt;- ell$matrix()
O &lt;- ell$center
pts &lt;- ell$path(4L) # four points on the ellipse
apply(pts, 1L, function(M) t(M-O) %*% S %*% (M-O))
</pre>
</div>


<hr>
<a id="method-Ellipse-path"></a>



<h4>Method <code>path()</code></h4>

<p>Path that forms the reference ellipse.
</p>


<h5>Usage</h5>

<div class="r"><pre>Ellipse$path(npoints = 100L, closed = FALSE, outer = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>npoints</code></dt><dd><p>number of points of the path</p>
</dd>
<dt><code>closed</code></dt><dd><p>Boolean, whether to return a closed path; you don't need
a closed path if you want to plot it with
<code><a href="graphics.html#topic+polygon">polygon</a></code></p>
</dd>
<dt><code>outer</code></dt><dd><p>Boolean; if <code>TRUE</code>, the ellipse will be contained
inside the path, otherwise it will contain the path</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A matrix with two columns <code>x</code> and <code>y</code> of
length <code>npoints</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>library(PlaneGeometry)
ell &lt;- Ellipse$new(c(1, -1), rmajor = 3, rminor = 2, alpha = 30)
innerPath &lt;- ell$path(npoints = 10)
outerPath &lt;- ell$path(npoints = 10, outer = TRUE)
bbox &lt;- ell$boundingbox()
plot(NULL, asp = 1, xlim = bbox$x, ylim = bbox$y, xlab = NA, ylab = NA)
draw(ell, border = "red", lty = "dashed")
polygon(innerPath, border = "blue", lwd = 2)
polygon(outerPath, border = "green", lwd = 2)
</pre>
</div>


<hr>
<a id="method-Ellipse-diameter"></a>



<h4>Method <code>diameter()</code></h4>

<p>Diameter and conjugate diameter of the reference ellipse.
</p>


<h5>Usage</h5>

<div class="r"><pre>Ellipse$diameter(t, conjugate = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>a number, the diameter only depends on <code>t</code> modulo
<code>pi</code>; the axes correspond to <code>t=0</code> and <code>t=pi/2</code></p>
</dd>
<dt><code>conjugate</code></dt><dd><p>logical, whether to return the conjugate diameter as well</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Line</code> object or a list of two <code>Line</code> objects if
<code>conjugate = TRUE</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>ell &lt;- Ellipse$new(c(1,1), 5, 2, 30)
diameters &lt;- lapply(c(0, pi/3, 2*pi/3), ell$diameter)
plot(NULL, asp = 1, xlim = c(-4,6), ylim = c(-2,4),
     xlab = NA, ylab = NA)
draw(ell)
invisible(lapply(diameters, draw))
</pre>
</div>


<hr>
<a id="method-Ellipse-perimeter"></a>



<h4>Method <code>perimeter()</code></h4>

<p>Perimeter of the reference ellipse.
</p>


<h5>Usage</h5>

<div class="r"><pre>Ellipse$perimeter()</pre></div>


<hr>
<a id="method-Ellipse-pointFromAngle"></a>



<h4>Method <code>pointFromAngle()</code></h4>

<p>Intersection point of the ellipse with the half-line
starting at the ellipse center and forming angle <code>theta</code> with
the major axis.
</p>


<h5>Usage</h5>

<div class="r"><pre>Ellipse$pointFromAngle(theta, degrees = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>theta</code></dt><dd><p>a number, the angle, or a numeric vector</p>
</dd>
<dt><code>degrees</code></dt><dd><p>logical, whether <code>theta</code> is given in degrees</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A point of the ellipse if <code>length(theta)==1</code> or a
two-column matrix of points of the ellipse if
<code>length(theta) &gt; 1</code> (one point per row).
</p>


<hr>
<a id="method-Ellipse-pointFromEccentricAngle"></a>



<h4>Method <code>pointFromEccentricAngle()</code></h4>

<p>Point of the ellipse with given eccentric angle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Ellipse$pointFromEccentricAngle(t)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>a number, the eccentric angle in radians, or a numeric vector</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A point of the ellipse if <code>length(t)==1</code> or a
two-column matrix of points of the ellipse if
<code>length(t) &gt; 1</code> (one point per row).
</p>


<hr>
<a id="method-Ellipse-semiMajorAxis"></a>



<h4>Method <code>semiMajorAxis()</code></h4>

<p>Semi-major axis of the ellipse.
</p>


<h5>Usage</h5>

<div class="r"><pre>Ellipse$semiMajorAxis()</pre></div>



<h5>Returns</h5>

<p>A segment (<code>Line</code> object).
</p>


<hr>
<a id="method-Ellipse-semiMinorAxis"></a>



<h4>Method <code>semiMinorAxis()</code></h4>

<p>Semi-minor axis of the ellipse.
</p>


<h5>Usage</h5>

<div class="r"><pre>Ellipse$semiMinorAxis()</pre></div>



<h5>Returns</h5>

<p>A segment (<code>Line</code> object).
</p>


<hr>
<a id="method-Ellipse-foci"></a>



<h4>Method <code>foci()</code></h4>

<p>Foci of the reference ellipse.
</p>


<h5>Usage</h5>

<div class="r"><pre>Ellipse$foci()</pre></div>



<h5>Returns</h5>

<p>A list with the two foci.
</p>


<hr>
<a id="method-Ellipse-tangent"></a>



<h4>Method <code>tangent()</code></h4>

<p>Tangents of the reference ellipse at a point given by
its eccentric angle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Ellipse$tangent(t)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>eccentric angle, there is one tangent for each value of <code>t</code>
modulo <code>2*pi</code>; for <code>t = 0, pi/2, pi, -pi/2</code>, these are the
tangents at the vertices of the ellipse</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>ell &lt;- Ellipse$new(c(1,1), 5, 2, 30)
tangents &lt;- lapply(c(0, pi/3, 2*pi/3, pi, 4*pi/3, 5*pi/3), ell$tangent)
plot(NULL, asp = 1, xlim = c(-4,6), ylim = c(-2,4),
     xlab = NA, ylab = NA)
draw(ell, col = "yellow")
invisible(lapply(tangents, draw, col = "blue"))
</pre>
</div>


<hr>
<a id="method-Ellipse-normal"></a>



<h4>Method <code>normal()</code></h4>

<p>Normal unit vector to the ellipse.
</p>


<h5>Usage</h5>

<div class="r"><pre>Ellipse$normal(t)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>a number, the eccentric angle in radians of the point of the
ellipse at which we want the normal unit vector</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The normal unit vector to the ellipse at the point given by
eccentric angle <code>t</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>ell &lt;- Ellipse$new(c(1,1), 5, 2, 30)
t_ &lt;- seq(0, 2*pi, length.out = 13)[-1]
plot(NULL, asp = 1, xlim = c(-5,7), ylim = c(-3,5),
     xlab = NA, ylab = NA)
draw(ell, col = "magenta")
for(i in 1:length(t_)){
  t &lt;- t_[i]
  P &lt;- ell$pointFromEccentricAngle(t)
  v &lt;- ell$normal(t)
  draw(Line$new(P, P+v, FALSE, FALSE))
}
</pre>
</div>


<hr>
<a id="method-Ellipse-theta2t"></a>



<h4>Method <code>theta2t()</code></h4>

<p>Convert angle to eccentric angle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Ellipse$theta2t(theta, degrees = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>theta</code></dt><dd><p>angle between the major axis and the half-line starting
at the center of the ellipse and passing through the point of interest
on the ellipse</p>
</dd>
<dt><code>degrees</code></dt><dd><p>logical, whether <code>theta</code> is given in degrees</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The eccentric angle of the point of interest on the ellipse,
in radians.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>O &lt;- c(1, 1)
ell &lt;- Ellipse$new(O, 5, 2, 30)
theta &lt;- 20
P &lt;- ell$pointFromAngle(theta)
t &lt;- ell$theta2t(theta)
tg &lt;- ell$tangent(t)
OP &lt;- Line$new(O, P, FALSE, FALSE)
plot(NULL, asp = 1, xlim = c(-4,6), ylim = c(-2,5),
     xlab = NA, ylab = NA)
draw(ell, col = "antiquewhite")
points(P[1], P[2], pch = 19)
draw(tg, col = "red")
draw(OP)
draw(ell$semiMajorAxis())
text(t(O+c(1,0.9)), expression(theta))
</pre>
</div>


<hr>
<a id="method-Ellipse-regressionLines"></a>



<h4>Method <code>regressionLines()</code></h4>

<p>Regression lines. The regression line of y on x intersects
the ellipse at its rightmost point and its leftmost point.
The tangents at these points are vertical.
The regression line of x on y intersects the ellipse at its
topmost point and its bottommost point.
The tangents at these points are horizontal.
</p>


<h5>Usage</h5>

<div class="r"><pre>Ellipse$regressionLines()</pre></div>



<h5>Returns</h5>

<p>A list with two <code>Line</code> objects:
the regression line of y on x and the regression line of x on y.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>ell &lt;- Ellipse$new(c(1,1), 5, 2, 30)
reglines &lt;- ell$regressionLines()
plot(NULL, asp = 1, xlim = c(-4,6), ylim = c(-2,4),
     xlab = NA, ylab = NA)
draw(ell, lwd = 2)
draw(reglines$YonX, lwd = 2, col = "blue")
draw(reglines$XonY, lwd = 2, col = "green")
</pre>
</div>


<hr>
<a id="method-Ellipse-boundingbox"></a>



<h4>Method <code>boundingbox()</code></h4>

<p>Return the smallest rectangle parallel to the axes
which contains the reference ellipse.
</p>


<h5>Usage</h5>

<div class="r"><pre>Ellipse$boundingbox()</pre></div>



<h5>Returns</h5>

<p>A list with two components: the x-limits in <code>x</code> and the
y-limits in <code>y</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>ell &lt;- Ellipse$new(c(2,2), 5, 3, 40)
box &lt;- ell$boundingbox()
plot(NULL, asp = 1, xlim = box$x, ylim = box$y, xlab = NA, ylab = NA)
draw(ell, col = "seaShell", border = "blue")
abline(v = box$x, lty = 2); abline(h = box$y, lty = 2)
</pre>
</div>


<hr>
<a id="method-Ellipse-randomPoints"></a>



<h4>Method <code>randomPoints()</code></h4>

<p>Random points on or in the reference ellipse.
</p>


<h5>Usage</h5>

<div class="r"><pre>Ellipse$randomPoints(n, where = "in")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>an integer, the desired number of points</p>
</dd>
<dt><code>where</code></dt><dd><p><code>"in"</code> to generate inside the ellipse,
<code>"on"</code> to generate on the ellipse</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The generated points in a two columns matrix with <code>n</code> rows.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>ell &lt;- Ellipse$new(c(1,1), 5, 2, 30)
pts &lt;- ell$randomPoints(100)
plot(NULL, type="n", asp=1, xlim = c(-4,6), ylim = c(-2,4),
     xlab = NA, ylab = NA)
draw(ell, lwd = 2)
points(pts, pch = 19, col = "blue")
</pre>
</div>


<hr>
<a id="method-Ellipse-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Ellipse$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `Ellipse$new`
## ------------------------------------------------

Ellipse$new(c(1,1), 3, 2, 30)

## ------------------------------------------------
## Method `Ellipse$matrix`
## ------------------------------------------------

ell &lt;- Ellipse$new(c(1,1), 5, 1, 30)
S &lt;- ell$matrix()
O &lt;- ell$center
pts &lt;- ell$path(4L) # four points on the ellipse
apply(pts, 1L, function(M) t(M-O) %*% S %*% (M-O))

## ------------------------------------------------
## Method `Ellipse$path`
## ------------------------------------------------

library(PlaneGeometry)
ell &lt;- Ellipse$new(c(1, -1), rmajor = 3, rminor = 2, alpha = 30)
innerPath &lt;- ell$path(npoints = 10)
outerPath &lt;- ell$path(npoints = 10, outer = TRUE)
bbox &lt;- ell$boundingbox()
plot(NULL, asp = 1, xlim = bbox$x, ylim = bbox$y, xlab = NA, ylab = NA)
draw(ell, border = "red", lty = "dashed")
polygon(innerPath, border = "blue", lwd = 2)
polygon(outerPath, border = "green", lwd = 2)

## ------------------------------------------------
## Method `Ellipse$diameter`
## ------------------------------------------------

ell &lt;- Ellipse$new(c(1,1), 5, 2, 30)
diameters &lt;- lapply(c(0, pi/3, 2*pi/3), ell$diameter)
plot(NULL, asp = 1, xlim = c(-4,6), ylim = c(-2,4),
     xlab = NA, ylab = NA)
draw(ell)
invisible(lapply(diameters, draw))

## ------------------------------------------------
## Method `Ellipse$tangent`
## ------------------------------------------------

ell &lt;- Ellipse$new(c(1,1), 5, 2, 30)
tangents &lt;- lapply(c(0, pi/3, 2*pi/3, pi, 4*pi/3, 5*pi/3), ell$tangent)
plot(NULL, asp = 1, xlim = c(-4,6), ylim = c(-2,4),
     xlab = NA, ylab = NA)
draw(ell, col = "yellow")
invisible(lapply(tangents, draw, col = "blue"))

## ------------------------------------------------
## Method `Ellipse$normal`
## ------------------------------------------------

ell &lt;- Ellipse$new(c(1,1), 5, 2, 30)
t_ &lt;- seq(0, 2*pi, length.out = 13)[-1]
plot(NULL, asp = 1, xlim = c(-5,7), ylim = c(-3,5),
     xlab = NA, ylab = NA)
draw(ell, col = "magenta")
for(i in 1:length(t_)){
  t &lt;- t_[i]
  P &lt;- ell$pointFromEccentricAngle(t)
  v &lt;- ell$normal(t)
  draw(Line$new(P, P+v, FALSE, FALSE))
}

## ------------------------------------------------
## Method `Ellipse$theta2t`
## ------------------------------------------------

O &lt;- c(1, 1)
ell &lt;- Ellipse$new(O, 5, 2, 30)
theta &lt;- 20
P &lt;- ell$pointFromAngle(theta)
t &lt;- ell$theta2t(theta)
tg &lt;- ell$tangent(t)
OP &lt;- Line$new(O, P, FALSE, FALSE)
plot(NULL, asp = 1, xlim = c(-4,6), ylim = c(-2,5),
     xlab = NA, ylab = NA)
draw(ell, col = "antiquewhite")
points(P[1], P[2], pch = 19)
draw(tg, col = "red")
draw(OP)
draw(ell$semiMajorAxis())
text(t(O+c(1,0.9)), expression(theta))

## ------------------------------------------------
## Method `Ellipse$regressionLines`
## ------------------------------------------------

ell &lt;- Ellipse$new(c(1,1), 5, 2, 30)
reglines &lt;- ell$regressionLines()
plot(NULL, asp = 1, xlim = c(-4,6), ylim = c(-2,4),
     xlab = NA, ylab = NA)
draw(ell, lwd = 2)
draw(reglines$YonX, lwd = 2, col = "blue")
draw(reglines$XonY, lwd = 2, col = "green")

## ------------------------------------------------
## Method `Ellipse$boundingbox`
## ------------------------------------------------

ell &lt;- Ellipse$new(c(2,2), 5, 3, 40)
box &lt;- ell$boundingbox()
plot(NULL, asp = 1, xlim = box$x, ylim = box$y, xlab = NA, ylab = NA)
draw(ell, col = "seaShell", border = "blue")
abline(v = box$x, lty = 2); abline(h = box$y, lty = 2)

## ------------------------------------------------
## Method `Ellipse$randomPoints`
## ------------------------------------------------

ell &lt;- Ellipse$new(c(1,1), 5, 2, 30)
pts &lt;- ell$randomPoints(100)
plot(NULL, type="n", asp=1, xlim = c(-4,6), ylim = c(-2,4),
     xlab = NA, ylab = NA)
draw(ell, lwd = 2)
points(pts, pch = 19, col = "blue")
</code></pre>

<hr>
<h2 id='EllipseEquationFromFivePoints'>Ellipse equation from five points</h2><span id='topic+EllipseEquationFromFivePoints'></span>

<h3>Description</h3>

<p>The coefficients of the implicit equation of an ellipse from
five points on this ellipse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EllipseEquationFromFivePoints(P1, P2, P3, P4, P5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EllipseEquationFromFivePoints_+3A_p1">P1</code>, <code id="EllipseEquationFromFivePoints_+3A_p2">P2</code>, <code id="EllipseEquationFromFivePoints_+3A_p3">P3</code>, <code id="EllipseEquationFromFivePoints_+3A_p4">P4</code>, <code id="EllipseEquationFromFivePoints_+3A_p5">P5</code></td>
<td>
<p>the five points</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implicit equation of the ellipse is
<code>Ax² + Bxy + Cy² + Dx + Ey + F = 0</code>. This function returns
A, B, C, D, E and F.
</p>


<h3>Value</h3>

<p>A named numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ell &lt;- Ellipse$new(c(2,3), 5, 4, 30)
set.seed(666)
pts &lt;- ell$randomPoints(5, "on")
cf1 &lt;- EllipseEquationFromFivePoints(pts[1,],pts[2,],pts[3,],pts[4,],pts[5,])
cf2 &lt;- ell$equation() # should be the same up to a multiplicative factor
all.equal(cf1/cf1["F"], cf2/cf2["F"])
</code></pre>

<hr>
<h2 id='EllipseFromCenterAndMatrix'>Ellipse from center and matrix</h2><span id='topic+EllipseFromCenterAndMatrix'></span>

<h3>Description</h3>

<p>Returns the ellipse of equation
<code>t(X-center) %*% S %*% (X-center) = 1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EllipseFromCenterAndMatrix(center, S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EllipseFromCenterAndMatrix_+3A_center">center</code></td>
<td>
<p>a point, the center of the ellipse</p>
</td></tr>
<tr><td><code id="EllipseFromCenterAndMatrix_+3A_s">S</code></td>
<td>
<p>a positive symmetric matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>Ellipse</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ell &lt;- Ellipse$new(c(2,3), 4, 2, 20)
S &lt;- ell$matrix()
EllipseFromCenterAndMatrix(ell$center, S)
</code></pre>

<hr>
<h2 id='EllipseFromEquation'>Ellipse from its implicit equation</h2><span id='topic+EllipseFromEquation'></span>

<h3>Description</h3>

<p>Return an ellipse from the coefficients of its implicit equation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EllipseFromEquation(A, B, C, D, E, F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EllipseFromEquation_+3A_a">A</code>, <code id="EllipseFromEquation_+3A_b">B</code>, <code id="EllipseFromEquation_+3A_c">C</code>, <code id="EllipseFromEquation_+3A_d">D</code>, <code id="EllipseFromEquation_+3A_e">E</code>, <code id="EllipseFromEquation_+3A_f">F</code></td>
<td>
<p>the coefficients of the equation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implicit equation of the ellipse is
<code>Ax² + Bxy + Cy² + Dx + Ey + F = 0</code>. This function returns the ellipse
given A, B, C, D, E and F.
</p>


<h3>Value</h3>

<p>An <code>Ellipse</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ell &lt;- Ellipse$new(c(2,3), 5, 4, 30)
cf &lt;- ell$equation()
ell2 &lt;- EllipseFromEquation(cf[1], cf[2], cf[3], cf[4], cf[5], cf[6])
ell$isEqual(ell2)
</code></pre>

<hr>
<h2 id='EllipseFromFivePoints'>Ellipse from five points</h2><span id='topic+EllipseFromFivePoints'></span>

<h3>Description</h3>

<p>Return an ellipse from five given points on this ellipse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EllipseFromFivePoints(P1, P2, P3, P4, P5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EllipseFromFivePoints_+3A_p1">P1</code>, <code id="EllipseFromFivePoints_+3A_p2">P2</code>, <code id="EllipseFromFivePoints_+3A_p3">P3</code>, <code id="EllipseFromFivePoints_+3A_p4">P4</code>, <code id="EllipseFromFivePoints_+3A_p5">P5</code></td>
<td>
<p>the five points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>Ellipse</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ell &lt;- Ellipse$new(c(2,3), 5, 4, 30)
set.seed(666)
pts &lt;- ell$randomPoints(5, "on")
ell2 &lt;- EllipseFromFivePoints(pts[1,],pts[2,],pts[3,],pts[4,],pts[5,])
ell$isEqual(ell2)
</code></pre>

<hr>
<h2 id='EllipseFromFociAndOnePoint'>Ellipse from foci and one point</h2><span id='topic+EllipseFromFociAndOnePoint'></span>

<h3>Description</h3>

<p>Derive the ellipse with given foci and one point on the boundary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EllipseFromFociAndOnePoint(F1, F2, P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EllipseFromFociAndOnePoint_+3A_f1">F1</code>, <code id="EllipseFromFociAndOnePoint_+3A_f2">F2</code></td>
<td>
<p>points, the foci</p>
</td></tr>
<tr><td><code id="EllipseFromFociAndOnePoint_+3A_p">P</code></td>
<td>
<p>a point on the boundary of the ellipse</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>Ellipse</code> object.
</p>

<hr>
<h2 id='EllipseFromThreeBoundaryPoints'>Smallest ellipse that passes through three boundary points</h2><span id='topic+EllipseFromThreeBoundaryPoints'></span>

<h3>Description</h3>

<p>Returns the smallest area ellipse which passes through
three given boundary points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EllipseFromThreeBoundaryPoints(P1, P2, P3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EllipseFromThreeBoundaryPoints_+3A_p1">P1</code>, <code id="EllipseFromThreeBoundaryPoints_+3A_p2">P2</code>, <code id="EllipseFromThreeBoundaryPoints_+3A_p3">P3</code></td>
<td>
<p>three non-collinear points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>Ellipse</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P1 &lt;- c(-1,0); P2 &lt;- c(0, 2); P3 &lt;- c(3,0)
ell &lt;- EllipseFromThreeBoundaryPoints(P1, P2, P3)
ell$includes(P1); ell$includes(P2); ell$includes(P3)
</code></pre>

<hr>
<h2 id='EllipticalArc'>R6 class representing an elliptical arc</h2><span id='topic+EllipticalArc'></span>

<h3>Description</h3>

<p>An arc is given by an ellipse (<code>Ellipse</code> object),
a starting angle and an ending angle. They are respectively named
<code>ell</code>, <code>alpha1</code> and <code>alpha2</code>.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>ell</code></dt><dd><p>get or set the ellipse</p>
</dd>
<dt><code>alpha1</code></dt><dd><p>get or set the starting angle</p>
</dd>
<dt><code>alpha2</code></dt><dd><p>get or set the ending angle</p>
</dd>
<dt><code>degrees</code></dt><dd><p>get or set the <code>degrees</code> field</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-EllipticalArc-new"><code>EllipticalArc$new()</code></a>
</p>
</li>
<li> <p><a href="#method-EllipticalArc-print"><code>EllipticalArc$print()</code></a>
</p>
</li>
<li> <p><a href="#method-EllipticalArc-startingPoint"><code>EllipticalArc$startingPoint()</code></a>
</p>
</li>
<li> <p><a href="#method-EllipticalArc-endingPoint"><code>EllipticalArc$endingPoint()</code></a>
</p>
</li>
<li> <p><a href="#method-EllipticalArc-isEqual"><code>EllipticalArc$isEqual()</code></a>
</p>
</li>
<li> <p><a href="#method-EllipticalArc-complementaryArc"><code>EllipticalArc$complementaryArc()</code></a>
</p>
</li>
<li> <p><a href="#method-EllipticalArc-path"><code>EllipticalArc$path()</code></a>
</p>
</li>
<li> <p><a href="#method-EllipticalArc-length"><code>EllipticalArc$length()</code></a>
</p>
</li>
<li> <p><a href="#method-EllipticalArc-clone"><code>EllipticalArc$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-EllipticalArc-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>EllipticalArc</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>EllipticalArc$new(ell, alpha1, alpha2, degrees = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ell</code></dt><dd><p>the ellipse</p>
</dd>
<dt><code>alpha1</code></dt><dd><p>the starting angle</p>
</dd>
<dt><code>alpha2</code></dt><dd><p>the ending angle</p>
</dd>
<dt><code>degrees</code></dt><dd><p>logical, whether <code>alpha1</code> and <code>alpha2</code> are
given in degrees</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>EllipticalArc</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>ell &lt;- Ellipse$new(c(-4,0), 4, 2.5, 140)
EllipticalArc$new(ell, 45, 90)
</pre>
</div>


<hr>
<a id="method-EllipticalArc-print"></a>



<h4>Method <code>print()</code></h4>

<p>Show instance of an <code>EllipticalArc</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>EllipticalArc$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-EllipticalArc-startingPoint"></a>



<h4>Method <code>startingPoint()</code></h4>

<p>Starting point of the reference elliptical arc.
</p>


<h5>Usage</h5>

<div class="r"><pre>EllipticalArc$startingPoint()</pre></div>


<hr>
<a id="method-EllipticalArc-endingPoint"></a>



<h4>Method <code>endingPoint()</code></h4>

<p>Ending point of the reference elliptical arc.
</p>


<h5>Usage</h5>

<div class="r"><pre>EllipticalArc$endingPoint()</pre></div>


<hr>
<a id="method-EllipticalArc-isEqual"></a>



<h4>Method <code>isEqual()</code></h4>

<p>Check whether the reference elliptical arc equals
another elliptical arc.
</p>


<h5>Usage</h5>

<div class="r"><pre>EllipticalArc$isEqual(arc)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>arc</code></dt><dd><p>an <code>EllipticalArc</code> object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-EllipticalArc-complementaryArc"></a>



<h4>Method <code>complementaryArc()</code></h4>

<p>Complementary elliptical arc of the reference elliptical arc.
</p>


<h5>Usage</h5>

<div class="r"><pre>EllipticalArc$complementaryArc()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>ell &lt;- Ellipse$new(c(-4,0), 4, 2.5, 140)
arc &lt;- EllipticalArc$new(ell, 30, 60)
plot(NULL, type = "n", asp = 1, xlim = c(-8,0), ylim = c(-3.2,3.2),
     xlab = NA, ylab = NA)
draw(arc, lwd = 3, col = "red")
draw(arc$complementaryArc(), lwd = 3, col = "green")
</pre>
</div>


<hr>
<a id="method-EllipticalArc-path"></a>



<h4>Method <code>path()</code></h4>

<p>The reference elliptical arc as a path.
</p>


<h5>Usage</h5>

<div class="r"><pre>EllipticalArc$path(npoints = 100L)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>npoints</code></dt><dd><p>number of points of the path</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A matrix with two columns <code>x</code> and <code>y</code> of length
<code>npoints</code>.
</p>


<hr>
<a id="method-EllipticalArc-length"></a>



<h4>Method <code>length()</code></h4>

<p>The length of the elliptical arc.
</p>


<h5>Usage</h5>

<div class="r"><pre>EllipticalArc$length()</pre></div>



<h5>Returns</h5>

<p>A number, the arc length.
</p>


<hr>
<a id="method-EllipticalArc-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>EllipticalArc$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `EllipticalArc$new`
## ------------------------------------------------

ell &lt;- Ellipse$new(c(-4,0), 4, 2.5, 140)
EllipticalArc$new(ell, 45, 90)

## ------------------------------------------------
## Method `EllipticalArc$complementaryArc`
## ------------------------------------------------

ell &lt;- Ellipse$new(c(-4,0), 4, 2.5, 140)
arc &lt;- EllipticalArc$new(ell, 30, 60)
plot(NULL, type = "n", asp = 1, xlim = c(-8,0), ylim = c(-3.2,3.2),
     xlab = NA, ylab = NA)
draw(arc, lwd = 3, col = "red")
draw(arc$complementaryArc(), lwd = 3, col = "green")
</code></pre>

<hr>
<h2 id='fitEllipse'>Fit an ellipse</h2><span id='topic+fitEllipse'></span>

<h3>Description</h3>

<p>Fit an ellipse to a set of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitEllipse(points)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitEllipse_+3A_points">points</code></td>
<td>
<p>numeric matrix with two columns, one point per row</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>Ellipse</code> object representing the fitted ellipse. The
residual sum of squares is given in the <code>RSS</code> attribute.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PlaneGeometry)
# We add some noise to 30 points on an ellipse:
ell &lt;- Ellipse$new(c(1, 1), 3, 2, 30)
set.seed(666L)
points &lt;- ell$randomPoints(30, "on") + matrix(rnorm(30*2, sd = 0.2), ncol = 2)
# Now we fit an ellipse to these points:
ellFitted &lt;- fitEllipse(points)
# let's draw all this stuff:
box &lt;- ell$boundingbox()
plot(NULL, asp = 1, xlim = box$x, ylim = box$y, xlab = NA, ylab = NA)
draw(ell, border = "blue", lwd = 2)
points(points, pch = 19)
draw(ellFitted, border = "green", lwd = 2)
</code></pre>

<hr>
<h2 id='GaussianEllipse'>Gaussian ellipse</h2><span id='topic+GaussianEllipse'></span>

<h3>Description</h3>

<p>Return the ellipse equal to the highest <em>pdf</em> region of
a bivariate Gaussian distribution with a given probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GaussianEllipse(mean, Sigma, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GaussianEllipse_+3A_mean">mean</code></td>
<td>
<p>numeric vector of length 2, the mean of the bivariate Gaussian
distribution; this is the center of the ellipse</p>
</td></tr>
<tr><td><code id="GaussianEllipse_+3A_sigma">Sigma</code></td>
<td>
<p>covariance matrix of the bivariate Gaussian distribution</p>
</td></tr>
<tr><td><code id="GaussianEllipse_+3A_p">p</code></td>
<td>
<p>desired probability level, a number between 0 and 1 (strictly)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>Ellipse</code> object.
</p>

<hr>
<h2 id='Homothety'>R6 class representing a homothety</h2><span id='topic+Homothety'></span>

<h3>Description</h3>

<p>A homothety is given by a center and a scale factor.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>center</code></dt><dd><p>get or set the center</p>
</dd>
<dt><code>scale</code></dt><dd><p>get or set the scale factor of the homothety</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Homothety-new"><code>Homothety$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Homothety-print"><code>Homothety$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Homothety-transform"><code>Homothety$transform()</code></a>
</p>
</li>
<li> <p><a href="#method-Homothety-transformCircle"><code>Homothety$transformCircle()</code></a>
</p>
</li>
<li> <p><a href="#method-Homothety-getMatrix"><code>Homothety$getMatrix()</code></a>
</p>
</li>
<li> <p><a href="#method-Homothety-asAffine"><code>Homothety$asAffine()</code></a>
</p>
</li>
<li> <p><a href="#method-Homothety-clone"><code>Homothety$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Homothety-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Homothety</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Homothety$new(center, scale)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>center</code></dt><dd><p>a point, the center of the homothety</p>
</dd>
<dt><code>scale</code></dt><dd><p>a number, the scale factor of the homothety</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Homothety</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>Homothety$new(c(1,1), 2)
</pre>
</div>


<hr>
<a id="method-Homothety-print"></a>



<h4>Method <code>print()</code></h4>

<p>Show instance of a <code>Homothety</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Homothety$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Homothety-transform"></a>



<h4>Method <code>transform()</code></h4>

<p>Transform a point or several points by the reference homothety.
</p>


<h5>Usage</h5>

<div class="r"><pre>Homothety$transform(M)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>M</code></dt><dd><p>a point or a two-column matrix of points, one point per row</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Homothety-transformCircle"></a>



<h4>Method <code>transformCircle()</code></h4>

<p>Transform a circle by the reference homothety.
</p>


<h5>Usage</h5>

<div class="r"><pre>Homothety$transformCircle(circ)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>circ</code></dt><dd><p>a <code>Circle</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Circle</code> object.
</p>


<hr>
<a id="method-Homothety-getMatrix"></a>



<h4>Method <code>getMatrix()</code></h4>

<p>Augmented matrix of the homothety.
</p>


<h5>Usage</h5>

<div class="r"><pre>Homothety$getMatrix()</pre></div>



<h5>Returns</h5>

<p>A 3x3 matrix.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>H &lt;- Homothety$new(c(1,1), 2)
P &lt;- c(1,5)
H$transform(P)
H$getMatrix() %*% c(P,1)
</pre>
</div>


<hr>
<a id="method-Homothety-asAffine"></a>



<h4>Method <code>asAffine()</code></h4>

<p>Convert the reference homothety to an <code>Affine</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Homothety$asAffine()</pre></div>


<hr>
<a id="method-Homothety-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Homothety$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `Homothety$new`
## ------------------------------------------------

Homothety$new(c(1,1), 2)

## ------------------------------------------------
## Method `Homothety$getMatrix`
## ------------------------------------------------

H &lt;- Homothety$new(c(1,1), 2)
P &lt;- c(1,5)
H$transform(P)
H$getMatrix() %*% c(P,1)
</code></pre>

<hr>
<h2 id='Hyperbola'>R6 class representing a hyperbola</h2><span id='topic+Hyperbola'></span>

<h3>Description</h3>

<p>A hyperbola is given by two intersecting asymptotes, named
<code>L1</code> and <code>L2</code>, and a point on this hyperbola, named <code>M</code>.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>L1</code></dt><dd><p>get or set the asymptote <code>L1</code></p>
</dd>
<dt><code>L2</code></dt><dd><p>get or set the asymptote <code>L2</code></p>
</dd>
<dt><code>M</code></dt><dd><p>get or set the point <code>M</code></p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Hyperbola-new"><code>Hyperbola$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Hyperbola-center"><code>Hyperbola$center()</code></a>
</p>
</li>
<li> <p><a href="#method-Hyperbola-OAB"><code>Hyperbola$OAB()</code></a>
</p>
</li>
<li> <p><a href="#method-Hyperbola-vertices"><code>Hyperbola$vertices()</code></a>
</p>
</li>
<li> <p><a href="#method-Hyperbola-abce"><code>Hyperbola$abce()</code></a>
</p>
</li>
<li> <p><a href="#method-Hyperbola-foci"><code>Hyperbola$foci()</code></a>
</p>
</li>
<li> <p><a href="#method-Hyperbola-plot"><code>Hyperbola$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-Hyperbola-includes"><code>Hyperbola$includes()</code></a>
</p>
</li>
<li> <p><a href="#method-Hyperbola-equation"><code>Hyperbola$equation()</code></a>
</p>
</li>
<li> <p><a href="#method-Hyperbola-clone"><code>Hyperbola$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Hyperbola-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Hyperbola</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Hyperbola$new(L1, L2, M)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>L1, L2</code></dt><dd><p>two intersecting lines given as <code>Line</code> objects, the
asymptotes</p>
</dd>
<dt><code>M</code></dt><dd><p>a point on the hyperbola</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Hyperbola</code> object.
</p>


<hr>
<a id="method-Hyperbola-center"></a>



<h4>Method <code>center()</code></h4>

<p>Center of the hyperbola.
</p>


<h5>Usage</h5>

<div class="r"><pre>Hyperbola$center()</pre></div>



<h5>Returns</h5>

<p>The center of the hyperbola, i.e. the point where
the two asymptotes meet each other.
</p>


<hr>
<a id="method-Hyperbola-OAB"></a>



<h4>Method <code>OAB()</code></h4>

<p>Parametric equation <code class="reqn">O \pm cosh(t) A + sinh(t) B</code>
representing the hyperbola.
</p>


<h5>Usage</h5>

<div class="r"><pre>Hyperbola$OAB()</pre></div>



<h5>Returns</h5>

<p>The point <code>O</code> and the two vectors <code>A</code> and <code>B</code>
in a list.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>L1 &lt;- LineFromInterceptAndSlope(0, 2)
L2 &lt;- LineFromInterceptAndSlope(-2, -0.5)
M &lt;- c(4, 3)
hyperbola &lt;- Hyperbola$new(L1, L2, M)
hyperbola$OAB()
</pre>
</div>


<hr>
<a id="method-Hyperbola-vertices"></a>



<h4>Method <code>vertices()</code></h4>

<p>Vertices of the hyperbola.
</p>


<h5>Usage</h5>

<div class="r"><pre>Hyperbola$vertices()</pre></div>



<h5>Returns</h5>

<p>The two vertices <code>V1</code> and <code>V2</code> in a list.
</p>


<hr>
<a id="method-Hyperbola-abce"></a>



<h4>Method <code>abce()</code></h4>

<p>The numbers <code>a</code> (semi-major axis, i.e. distance
from center to vertex),
<code>b</code> (semi-minor axis),
<code>c</code> (linear eccentricity)
and <code>e</code> (eccentricity)
associated to the hyperbola.
</p>


<h5>Usage</h5>

<div class="r"><pre>Hyperbola$abce()</pre></div>



<h5>Returns</h5>

<p>The four numbers <code>a</code>, <code>b</code>, <code>c</code> and <code>e</code>
in a list.
</p>


<hr>
<a id="method-Hyperbola-foci"></a>



<h4>Method <code>foci()</code></h4>

<p>Foci of the hyperbola.
</p>


<h5>Usage</h5>

<div class="r"><pre>Hyperbola$foci()</pre></div>



<h5>Returns</h5>

<p>The two foci <code>F1</code> and <code>F2</code> in a list.
</p>


<hr>
<a id="method-Hyperbola-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>Plot hyperbola.
</p>


<h5>Usage</h5>

<div class="r"><pre>Hyperbola$plot(add = FALSE, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>add</code></dt><dd><p>Boolean, whether to add this plot to the current plot</p>
</dd>
<dt><code>...</code></dt><dd><p>named arguments passed to <code><a href="graphics.html#topic+lines">lines</a></code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Nothing, called for plotting.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>L1 &lt;- LineFromInterceptAndSlope(0, 2)
L2 &lt;- LineFromInterceptAndSlope(-2, -0.5)
M &lt;- c(4, 3)
hyperbola &lt;- Hyperbola$new(L1, L2, M)
plot(hyperbola, lwd = 2)
points(t(M), pch = 19, col = "blue")
O &lt;- hyperbola$center()
points(t(O), pch = 19)
draw(L1, col = "red")
draw(L2, col = "red")
vertices &lt;- hyperbola$vertices()
points(rbind(vertices$V1, vertices$V2), pch = 19)
majorAxis &lt;- Line$new(vertices$V1, vertices$V2)
draw(majorAxis, lty = "dashed")
foci &lt;- hyperbola$foci()
points(rbind(foci$F1, foci$F2), pch = 19, col = "green")
</pre>
</div>


<hr>
<a id="method-Hyperbola-includes"></a>



<h4>Method <code>includes()</code></h4>

<p>Whether a point belongs to the hyperbola.
</p>


<h5>Usage</h5>

<div class="r"><pre>Hyperbola$includes(P)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>P</code></dt><dd><p>a point</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A Boolean value.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>L1 &lt;- LineFromInterceptAndSlope(0, 2)
L2 &lt;- LineFromInterceptAndSlope(-2, -0.5)
M &lt;- c(4, 3)
hyperbola &lt;- Hyperbola$new(L1, L2, M)
hyperbola$includes(M)
</pre>
</div>


<hr>
<a id="method-Hyperbola-equation"></a>



<h4>Method <code>equation()</code></h4>

<p>Implicit quadratic equation of the hyperbola
A<sub>xx</sub>x<sup>2</sup> + 2A<sub>xy</sub>xy + A<sub>yy</sub>y<sup>2</sup> + 2B<sub>x</sub>x + 2B<sub>y</sub>y + C = 0
</p>


<h5>Usage</h5>

<div class="r"><pre>Hyperbola$equation()</pre></div>



<h5>Returns</h5>

<p>The coefficients of the equation in a named list.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>L1 &lt;- LineFromInterceptAndSlope(0, 2)
L2 &lt;- LineFromInterceptAndSlope(-2, -0.5)
M &lt;- c(4, 3)
hyperbola &lt;- Hyperbola$new(L1, L2, M)
eq &lt;- hyperbola$equation()
x &lt;- M[1]; y &lt;- M[2]
with(eq, Axx*x^2 + 2*Axy*x*y + Ayy*y^2 + 2*Bx*x + 2*By*y + C)
V1 &lt;- hyperbola$vertices()$V1
x &lt;- V1[1]; y &lt;- V1[2]
with(eq, Axx*x^2 + 2*Axy*x*y + Ayy*y^2 + 2*Bx*x + 2*By*y + C)
</pre>
</div>


<hr>
<a id="method-Hyperbola-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Hyperbola$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `Hyperbola$OAB`
## ------------------------------------------------

L1 &lt;- LineFromInterceptAndSlope(0, 2)
L2 &lt;- LineFromInterceptAndSlope(-2, -0.5)
M &lt;- c(4, 3)
hyperbola &lt;- Hyperbola$new(L1, L2, M)
hyperbola$OAB()

## ------------------------------------------------
## Method `Hyperbola$plot`
## ------------------------------------------------

L1 &lt;- LineFromInterceptAndSlope(0, 2)
L2 &lt;- LineFromInterceptAndSlope(-2, -0.5)
M &lt;- c(4, 3)
hyperbola &lt;- Hyperbola$new(L1, L2, M)
plot(hyperbola, lwd = 2)
points(t(M), pch = 19, col = "blue")
O &lt;- hyperbola$center()
points(t(O), pch = 19)
draw(L1, col = "red")
draw(L2, col = "red")
vertices &lt;- hyperbola$vertices()
points(rbind(vertices$V1, vertices$V2), pch = 19)
majorAxis &lt;- Line$new(vertices$V1, vertices$V2)
draw(majorAxis, lty = "dashed")
foci &lt;- hyperbola$foci()
points(rbind(foci$F1, foci$F2), pch = 19, col = "green")

## ------------------------------------------------
## Method `Hyperbola$includes`
## ------------------------------------------------

L1 &lt;- LineFromInterceptAndSlope(0, 2)
L2 &lt;- LineFromInterceptAndSlope(-2, -0.5)
M &lt;- c(4, 3)
hyperbola &lt;- Hyperbola$new(L1, L2, M)
hyperbola$includes(M)

## ------------------------------------------------
## Method `Hyperbola$equation`
## ------------------------------------------------

L1 &lt;- LineFromInterceptAndSlope(0, 2)
L2 &lt;- LineFromInterceptAndSlope(-2, -0.5)
M &lt;- c(4, 3)
hyperbola &lt;- Hyperbola$new(L1, L2, M)
eq &lt;- hyperbola$equation()
x &lt;- M[1]; y &lt;- M[2]
with(eq, Axx*x^2 + 2*Axy*x*y + Ayy*y^2 + 2*Bx*x + 2*By*y + C)
V1 &lt;- hyperbola$vertices()$V1
x &lt;- V1[1]; y &lt;- V1[2]
with(eq, Axx*x^2 + 2*Axy*x*y + Ayy*y^2 + 2*Bx*x + 2*By*y + C)
</code></pre>

<hr>
<h2 id='HyperbolaFromEquation'>Hyperbola object from the hyperbola equation.</h2><span id='topic+HyperbolaFromEquation'></span>

<h3>Description</h3>

<p>Create the <code>Hyperbola</code> object representing the hyperbola
with the given implicit equation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HyperbolaFromEquation(eq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HyperbolaFromEquation_+3A_eq">eq</code></td>
<td>
<p>named vector or list of the six parameters <code>Axx</code>, <code>Axy</code>,
<code>Ayy</code>, <code>Bx</code>, <code>By</code>, <code>C</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Hyperbola</code> object.
</p>

<hr>
<h2 id='intersectionCircleCircle'>Intersection of two circles</h2><span id='topic+intersectionCircleCircle'></span>

<h3>Description</h3>

<p>Return the intersection of two circles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersectionCircleCircle(circ1, circ2, epsilon = sqrt(.Machine$double.eps))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersectionCircleCircle_+3A_circ1">circ1</code>, <code id="intersectionCircleCircle_+3A_circ2">circ2</code></td>
<td>
<p>two <code>Circle</code> objects</p>
</td></tr>
<tr><td><code id="intersectionCircleCircle_+3A_epsilon">epsilon</code></td>
<td>
<p>a small positive number used for the numerical accuracy</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> if there is no intersection,
a point if the circles touch, a list of two points if the circles meet at
two points, a circle if the two circles are identical.
</p>

<hr>
<h2 id='intersectionCircleLine'>Intersection of a circle and a line</h2><span id='topic+intersectionCircleLine'></span>

<h3>Description</h3>

<p>Return the intersection of a circle and a line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersectionCircleLine(circ, line, strict = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersectionCircleLine_+3A_circ">circ</code></td>
<td>
<p>a <code>Circle</code> object</p>
</td></tr>
<tr><td><code id="intersectionCircleLine_+3A_line">line</code></td>
<td>
<p>a <code>Line</code> object</p>
</td></tr>
<tr><td><code id="intersectionCircleLine_+3A_strict">strict</code></td>
<td>
<p>logical, whether to take into account <code>line$extendA</code> and
<code>line$extendB</code> if they are not both <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> if there is no intersection;
a point if the infinite line is tangent to the circle, or <code>NULL</code>
if <code>strict=TRUE</code> and the point is not on the line (segment or half-line);
a list of two points if the circle and the infinite line meet at
two points, when <code>strict=FALSE</code>; if <code>strict=TRUE</code> and the line is
a segment or a half-line, this can return <code>NULL</code> or a single point.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>circ &lt;- Circle$new(c(1,1), 2)
line &lt;- Line$new(c(2,-2), c(1,2), FALSE, FALSE)
intersectionCircleLine(circ, line)
intersectionCircleLine(circ, line, strict = TRUE)
</code></pre>

<hr>
<h2 id='intersectionEllipseLine'>Intersection of an ellipse and a line</h2><span id='topic+intersectionEllipseLine'></span>

<h3>Description</h3>

<p>Return the intersection of an ellipse and a line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersectionEllipseLine(ell, line, strict = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersectionEllipseLine_+3A_ell">ell</code></td>
<td>
<p>an <code>Ellipse</code> object or a <code>Circle</code> object</p>
</td></tr>
<tr><td><code id="intersectionEllipseLine_+3A_line">line</code></td>
<td>
<p>a <code>Line</code> object</p>
</td></tr>
<tr><td><code id="intersectionEllipseLine_+3A_strict">strict</code></td>
<td>
<p>logical, whether to take into account <code>line$extendA</code> and
<code>line$extendB</code> if they are not both <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> if there is no intersection;
a point if the infinite line is tangent to the ellipse, or <code>NULL</code>
if <code>strict=TRUE</code> and the point is not on the line (segment or half-line);
a list of two points if the ellipse and the infinite line meet at
two points, when <code>strict=FALSE</code>; if <code>strict=TRUE</code> and the line is
a segment or a half-line, this can return <code>NULL</code> or a single point.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ell &lt;- Ellipse$new(c(1,1), 5, 1, 30)
line &lt;- Line$new(c(2,-2), c(0,4))
( Is &lt;- intersectionEllipseLine(ell, line) )
ell$includes(Is$I1); ell$includes(Is$I2)
</code></pre>

<hr>
<h2 id='intersectionLineLine'>Intersection of two lines</h2><span id='topic+intersectionLineLine'></span>

<h3>Description</h3>

<p>Return the intersection of two lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersectionLineLine(line1, line2, strict = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersectionLineLine_+3A_line1">line1</code>, <code id="intersectionLineLine_+3A_line2">line2</code></td>
<td>
<p>two <code>Line</code> objects</p>
</td></tr>
<tr><td><code id="intersectionLineLine_+3A_strict">strict</code></td>
<td>
<p>logical, whether to take into account the extensions of the
lines (<code>extendA</code> and <code>extendB</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>strict = FALSE</code> this returns either a point, or <code>NULL</code>
if the lines are parallel, or a bi-infinite line if the two lines coincide.
If <code>strict = TRUE</code>, this can also return a half-infinite line or
a segment.
</p>

<hr>
<h2 id='Inversion'>R6 class representing an inversion</h2><span id='topic+Inversion'></span>

<h3>Description</h3>

<p>An inversion is given by a pole (a point) and a power (a number,
possibly negative, but not zero).
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>pole</code></dt><dd><p>get or set the pole</p>
</dd>
<dt><code>power</code></dt><dd><p>get or set the power</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Inversion-new"><code>Inversion$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Inversion-print"><code>Inversion$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Inversion-invert"><code>Inversion$invert()</code></a>
</p>
</li>
<li> <p><a href="#method-Inversion-transform"><code>Inversion$transform()</code></a>
</p>
</li>
<li> <p><a href="#method-Inversion-invertCircle"><code>Inversion$invertCircle()</code></a>
</p>
</li>
<li> <p><a href="#method-Inversion-transformCircle"><code>Inversion$transformCircle()</code></a>
</p>
</li>
<li> <p><a href="#method-Inversion-invertLine"><code>Inversion$invertLine()</code></a>
</p>
</li>
<li> <p><a href="#method-Inversion-transformLine"><code>Inversion$transformLine()</code></a>
</p>
</li>
<li> <p><a href="#method-Inversion-invertGcircle"><code>Inversion$invertGcircle()</code></a>
</p>
</li>
<li> <p><a href="#method-Inversion-compose"><code>Inversion$compose()</code></a>
</p>
</li>
<li> <p><a href="#method-Inversion-clone"><code>Inversion$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Inversion-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Inversion</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Inversion$new(pole, power)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>pole</code></dt><dd><p>the pole</p>
</dd>
<dt><code>power</code></dt><dd><p>the power</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Inversion</code> object.
</p>


<hr>
<a id="method-Inversion-print"></a>



<h4>Method <code>print()</code></h4>

<p>Show instance of an inversion object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Inversion$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>Inversion$new(c(0,0), 2)
</pre>
</div>


<hr>
<a id="method-Inversion-invert"></a>



<h4>Method <code>invert()</code></h4>

<p>Inversion of a point.
</p>


<h5>Usage</h5>

<div class="r"><pre>Inversion$invert(M)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>M</code></dt><dd><p>a point or <code>Inf</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A point or <code>Inf</code>, the image of <code>M</code>.
</p>


<hr>
<a id="method-Inversion-transform"></a>



<h4>Method <code>transform()</code></h4>

<p>An alias of <code>invert</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Inversion$transform(M)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>M</code></dt><dd><p>a point or <code>Inf</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A point or <code>Inf</code>, the image of <code>M</code>.
</p>


<hr>
<a id="method-Inversion-invertCircle"></a>



<h4>Method <code>invertCircle()</code></h4>

<p>Inversion of a circle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Inversion$invertCircle(circ)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>circ</code></dt><dd><p>a <code>Circle</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Circle</code> object or a <code>Line</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># A Pappus chain
# https://www.cut-the-knot.org/Curriculum/Geometry/InversionInArbelos.shtml
opar &lt;- par(mar = c(0,0,0,0))
plot(0, 0, type = "n", asp = 1, xlim = c(0,6), ylim = c(-4,4),
     xlab = NA, ylab = NA, axes = FALSE)
A &lt;- c(0,0); B &lt;- c(6,0)
ABsqr &lt;- c(crossprod(A-B))
iota &lt;- Inversion$new(A, ABsqr)
C &lt;- iota$invert(c(8,0))
Sigma1 &lt;- Circle$new((A+B)/2, sqrt(ABsqr)/2)
Sigma2 &lt;- Circle$new((A+C)/2, sqrt(c(crossprod(A-C)))/2)
draw(Sigma1); draw(Sigma2)
circ0 &lt;- Circle$new(c(7,0), 1)
iotacirc0 &lt;- iota$invertCircle(circ0)
draw(iotacirc0)
for(i in 1:6){
  circ &lt;- circ0$translate(c(0,2*i))
  iotacirc &lt;- iota$invertCircle(circ)
  draw(iotacirc)
  circ &lt;- circ0$translate(c(0,-2*i))
  iotacirc &lt;- iota$invertCircle(circ)
  draw(iotacirc)
}
par(opar)
</pre>
</div>


<hr>
<a id="method-Inversion-transformCircle"></a>



<h4>Method <code>transformCircle()</code></h4>

<p>An alias of <code>invertCircle</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Inversion$transformCircle(circ)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>circ</code></dt><dd><p>a <code>Circle</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Circle</code> object or a <code>Line</code> object.
</p>


<hr>
<a id="method-Inversion-invertLine"></a>



<h4>Method <code>invertLine()</code></h4>

<p>Inversion of a line.
</p>


<h5>Usage</h5>

<div class="r"><pre>Inversion$invertLine(line)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>line</code></dt><dd><p>a <code>Line</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Circle</code> object or a <code>Line</code> object.
</p>


<hr>
<a id="method-Inversion-transformLine"></a>



<h4>Method <code>transformLine()</code></h4>

<p>An alias of <code>invertLine</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Inversion$transformLine(line)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>line</code></dt><dd><p>a <code>Line</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Circle</code> object or a <code>Line</code> object.
</p>


<hr>
<a id="method-Inversion-invertGcircle"></a>



<h4>Method <code>invertGcircle()</code></h4>

<p>Inversion of a generalized circle (i.e. a circle or a line).
</p>


<h5>Usage</h5>

<div class="r"><pre>Inversion$invertGcircle(gcircle)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>gcircle</code></dt><dd><p>a <code>Circle</code> object or a <code>Line</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Circle</code> object or a <code>Line</code> object.
</p>


<hr>
<a id="method-Inversion-compose"></a>



<h4>Method <code>compose()</code></h4>

<p>Compose the reference inversion with another inversion.
The result is a Möbius transformation.
</p>


<h5>Usage</h5>

<div class="r"><pre>Inversion$compose(iota1, left = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>iota1</code></dt><dd><p>an <code>Inversion</code> object</p>
</dd>
<dt><code>left</code></dt><dd><p>logical, whether to compose at left or at right (i.e.
returns <code>iota1 o iota0</code> or <code>iota0 o iota1</code>)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Mobius</code> object.
</p>


<hr>
<a id="method-Inversion-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Inversion$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+inversionSwappingTwoCircles">inversionSwappingTwoCircles</a></code>,
<code><a href="#topic+inversionFixingTwoCircles">inversionFixingTwoCircles</a></code>,
<code><a href="#topic+inversionFixingThreeCircles">inversionFixingThreeCircles</a></code> to create some inversions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `Inversion$print`
## ------------------------------------------------

Inversion$new(c(0,0), 2)

## ------------------------------------------------
## Method `Inversion$invertCircle`
## ------------------------------------------------

# A Pappus chain
# https://www.cut-the-knot.org/Curriculum/Geometry/InversionInArbelos.shtml
opar &lt;- par(mar = c(0,0,0,0))
plot(0, 0, type = "n", asp = 1, xlim = c(0,6), ylim = c(-4,4),
     xlab = NA, ylab = NA, axes = FALSE)
A &lt;- c(0,0); B &lt;- c(6,0)
ABsqr &lt;- c(crossprod(A-B))
iota &lt;- Inversion$new(A, ABsqr)
C &lt;- iota$invert(c(8,0))
Sigma1 &lt;- Circle$new((A+B)/2, sqrt(ABsqr)/2)
Sigma2 &lt;- Circle$new((A+C)/2, sqrt(c(crossprod(A-C)))/2)
draw(Sigma1); draw(Sigma2)
circ0 &lt;- Circle$new(c(7,0), 1)
iotacirc0 &lt;- iota$invertCircle(circ0)
draw(iotacirc0)
for(i in 1:6){
  circ &lt;- circ0$translate(c(0,2*i))
  iotacirc &lt;- iota$invertCircle(circ)
  draw(iotacirc)
  circ &lt;- circ0$translate(c(0,-2*i))
  iotacirc &lt;- iota$invertCircle(circ)
  draw(iotacirc)
}
par(opar)
</code></pre>

<hr>
<h2 id='inversionFixingThreeCircles'>Inversion fixing three circles</h2><span id='topic+inversionFixingThreeCircles'></span>

<h3>Description</h3>

<p>Return the inversion which lets invariant three given circles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inversionFixingThreeCircles(circ1, circ2, circ3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inversionFixingThreeCircles_+3A_circ1">circ1</code>, <code id="inversionFixingThreeCircles_+3A_circ2">circ2</code>, <code id="inversionFixingThreeCircles_+3A_circ3">circ3</code></td>
<td>
<p><code>Circle</code> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>Inversion</code> object, which lets each of <code>circ1</code>,
<code>circ2</code> and <code>circ3</code> invariant.
</p>

<hr>
<h2 id='inversionFixingTwoCircles'>Inversion fixing two circles</h2><span id='topic+inversionFixingTwoCircles'></span>

<h3>Description</h3>

<p>Return the inversion which lets invariant two given circles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inversionFixingTwoCircles(circ1, circ2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inversionFixingTwoCircles_+3A_circ1">circ1</code>, <code id="inversionFixingTwoCircles_+3A_circ2">circ2</code></td>
<td>
<p><code>Circle</code> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>Inversion</code> object, which maps <code>circ1</code> to <code>circ2</code>
and <code>circ2</code> to <code>circ2</code>.
</p>

<hr>
<h2 id='inversionFromCircle'>Inversion on a circle</h2><span id='topic+inversionFromCircle'></span>

<h3>Description</h3>

<p>Return the inversion on a given circle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inversionFromCircle(circ)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inversionFromCircle_+3A_circ">circ</code></td>
<td>
<p>a <code>Circle</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>Inversion</code> object
</p>

<hr>
<h2 id='inversionKeepingCircle'>Inversion keeping a circle unchanged</h2><span id='topic+inversionKeepingCircle'></span>

<h3>Description</h3>

<p>Return an inversion with a given pole which keeps a given
circle unchanged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inversionKeepingCircle(pole, circ)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inversionKeepingCircle_+3A_pole">pole</code></td>
<td>
<p>inversion pole, a point</p>
</td></tr>
<tr><td><code id="inversionKeepingCircle_+3A_circ">circ</code></td>
<td>
<p>a <code>Circle</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>Inversion</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>circ &lt;- Circle$new(c(4,3), 2)
iota &lt;- inversionKeepingCircle(c(1,2), circ)
iota$transformCircle(circ)
</code></pre>

<hr>
<h2 id='inversionSwappingTwoCircles'>Inversion swapping two circles</h2><span id='topic+inversionSwappingTwoCircles'></span>

<h3>Description</h3>

<p>Return the inversion which swaps two given circles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inversionSwappingTwoCircles(circ1, circ2, positive = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inversionSwappingTwoCircles_+3A_circ1">circ1</code>, <code id="inversionSwappingTwoCircles_+3A_circ2">circ2</code></td>
<td>
<p><code>Circle</code> objects</p>
</td></tr>
<tr><td><code id="inversionSwappingTwoCircles_+3A_positive">positive</code></td>
<td>
<p>logical, whether the sign of the desired inversion power
must be positive or negative</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>Inversion</code> object, which maps <code>circ1</code> to <code>circ2</code>
and <code>circ2</code> to <code>circ1</code>, except in the case when <code>circ1</code>
and <code>circ2</code> are congruent and tangent: in this case a <code>Reflection</code>
object is returned (a reflection is an inversion on a line).
</p>

<hr>
<h2 id='Line'>R6 class representing a line</h2><span id='topic+Line'></span>

<h3>Description</h3>

<p>A line is given by two distinct points,
named <code>A</code> and <code>B</code>, and two logical values <code>extendA</code>
and <code>extendB</code>, indicating whether the line must be extended
beyond <code>A</code> and <code>B</code> respectively. Depending on <code>extendA</code>
and <code>extendB</code>, the line is an infinite line, a half-line, or a segment.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>A</code></dt><dd><p>get or set the point A</p>
</dd>
<dt><code>B</code></dt><dd><p>get or set the point B</p>
</dd>
<dt><code>extendA</code></dt><dd><p>get or set <code>extendA</code></p>
</dd>
<dt><code>extendB</code></dt><dd><p>get or set <code>extendB</code></p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Line-new"><code>Line$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Line-print"><code>Line$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Line-length"><code>Line$length()</code></a>
</p>
</li>
<li> <p><a href="#method-Line-directionAndOffset"><code>Line$directionAndOffset()</code></a>
</p>
</li>
<li> <p><a href="#method-Line-isEqual"><code>Line$isEqual()</code></a>
</p>
</li>
<li> <p><a href="#method-Line-isParallel"><code>Line$isParallel()</code></a>
</p>
</li>
<li> <p><a href="#method-Line-isPerpendicular"><code>Line$isPerpendicular()</code></a>
</p>
</li>
<li> <p><a href="#method-Line-includes"><code>Line$includes()</code></a>
</p>
</li>
<li> <p><a href="#method-Line-perpendicular"><code>Line$perpendicular()</code></a>
</p>
</li>
<li> <p><a href="#method-Line-parallel"><code>Line$parallel()</code></a>
</p>
</li>
<li> <p><a href="#method-Line-projection"><code>Line$projection()</code></a>
</p>
</li>
<li> <p><a href="#method-Line-distance"><code>Line$distance()</code></a>
</p>
</li>
<li> <p><a href="#method-Line-reflection"><code>Line$reflection()</code></a>
</p>
</li>
<li> <p><a href="#method-Line-rotate"><code>Line$rotate()</code></a>
</p>
</li>
<li> <p><a href="#method-Line-translate"><code>Line$translate()</code></a>
</p>
</li>
<li> <p><a href="#method-Line-invert"><code>Line$invert()</code></a>
</p>
</li>
<li> <p><a href="#method-Line-clone"><code>Line$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Line-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Line</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Line$new(A, B, extendA = TRUE, extendB = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>A, B</code></dt><dd><p>points</p>
</dd>
<dt><code>extendA, extendB</code></dt><dd><p>logical values</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Line</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>l &lt;- Line$new(c(1,1), c(1.5,1.5), FALSE, TRUE)
l
l$A
l$A &lt;- c(0,0)
l
</pre>
</div>


<hr>
<a id="method-Line-print"></a>



<h4>Method <code>print()</code></h4>

<p>Show instance of a line object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Line$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>Line$new(c(0,0), c(1,0), FALSE, TRUE)
</pre>
</div>


<hr>
<a id="method-Line-length"></a>



<h4>Method <code>length()</code></h4>

<p>Segment length, returns the length of the segment joining
the two points defining the line.
</p>


<h5>Usage</h5>

<div class="r"><pre>Line$length()</pre></div>


<hr>
<a id="method-Line-directionAndOffset"></a>



<h4>Method <code>directionAndOffset()</code></h4>

<p>Direction (angle between 0 and 2pi)
and offset (positive number) of the reference line.
</p>


<h5>Usage</h5>

<div class="r"><pre>Line$directionAndOffset()</pre></div>



<h5>Details</h5>

<p>The equation of the line is
cos(&theta;)x+sin(&theta;)y=d
where &theta; is the direction
and d is the offset.
</p>


<hr>
<a id="method-Line-isEqual"></a>



<h4>Method <code>isEqual()</code></h4>

<p>Check whether the reference line equals a given line,
without taking into account <code>extendA</code> and <code>extendB</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Line$isEqual(line)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>line</code></dt><dd><p>a <code>Line</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>TRUE</code> or <code>FALSE</code>.
</p>


<hr>
<a id="method-Line-isParallel"></a>



<h4>Method <code>isParallel()</code></h4>

<p>Check whether the reference line is parallel to a given line.
</p>


<h5>Usage</h5>

<div class="r"><pre>Line$isParallel(line)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>line</code></dt><dd><p>a <code>Line</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>TRUE</code> or <code>FALSE</code>.
</p>


<hr>
<a id="method-Line-isPerpendicular"></a>



<h4>Method <code>isPerpendicular()</code></h4>

<p>Check whether the reference line is perpendicular to a given line.
</p>


<h5>Usage</h5>

<div class="r"><pre>Line$isPerpendicular(line)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>line</code></dt><dd><p>a <code>Line</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>TRUE</code> or <code>FALSE</code>.
</p>


<hr>
<a id="method-Line-includes"></a>



<h4>Method <code>includes()</code></h4>

<p>Whether a point belongs to the reference line.
</p>


<h5>Usage</h5>

<div class="r"><pre>Line$includes(M, strict = FALSE, checkCollinear = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>M</code></dt><dd><p>the point for which we want to test whether it belongs to the
line</p>
</dd>
<dt><code>strict</code></dt><dd><p>logical, whether to take into account <code>extendA</code>
and <code>extendB</code></p>
</dd>
<dt><code>checkCollinear</code></dt><dd><p>logical, whether to check the collinearity of
<code>A</code>, <code>B</code>, <code>M</code>; set to <code>FALSE</code> only if you are sure
that <code>M</code> is on the line <code>(AB)</code> in case if you use
<code>strict=TRUE</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>TRUE</code> or <code>FALSE</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A &lt;- c(0,0); B &lt;- c(1,2); M &lt;- c(3,6)
l &lt;- Line$new(A, B, FALSE, FALSE)
l$includes(M, strict = TRUE)
</pre>
</div>


<hr>
<a id="method-Line-perpendicular"></a>



<h4>Method <code>perpendicular()</code></h4>

<p>Perpendicular line passing through a given point.
</p>


<h5>Usage</h5>

<div class="r"><pre>Line$perpendicular(M, extendH = FALSE, extendM = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>M</code></dt><dd><p>the point through which the perpendicular passes.</p>
</dd>
<dt><code>extendH</code></dt><dd><p>logical, whether to extend the perpendicular line
beyond the meeting point</p>
</dd>
<dt><code>extendM</code></dt><dd><p>logical, whether to extend the perpendicular line
beyond the point <code>M</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Line</code> object; its two points are the
meeting point and the point <code>M</code>.
</p>


<hr>
<a id="method-Line-parallel"></a>



<h4>Method <code>parallel()</code></h4>

<p>Parallel to the reference line passing through a given point.
</p>


<h5>Usage</h5>

<div class="r"><pre>Line$parallel(M)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>M</code></dt><dd><p>a point</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Line</code> object.
</p>


<hr>
<a id="method-Line-projection"></a>



<h4>Method <code>projection()</code></h4>

<p>Orthogonal projection of a point to the reference line.
</p>


<h5>Usage</h5>

<div class="r"><pre>Line$projection(M)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>M</code></dt><dd><p>a point</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A point.
</p>


<hr>
<a id="method-Line-distance"></a>



<h4>Method <code>distance()</code></h4>

<p>Distance from a point to the reference line.
</p>


<h5>Usage</h5>

<div class="r"><pre>Line$distance(M)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>M</code></dt><dd><p>a point</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A positive number.
</p>


<hr>
<a id="method-Line-reflection"></a>



<h4>Method <code>reflection()</code></h4>

<p>Reflection of a point with respect to the reference line.
</p>


<h5>Usage</h5>

<div class="r"><pre>Line$reflection(M)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>M</code></dt><dd><p>a point</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A point.
</p>


<hr>
<a id="method-Line-rotate"></a>



<h4>Method <code>rotate()</code></h4>

<p>Rotate the reference line.
</p>


<h5>Usage</h5>

<div class="r"><pre>Line$rotate(alpha, O, degrees = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>alpha</code></dt><dd><p>angle of rotation</p>
</dd>
<dt><code>O</code></dt><dd><p>center of rotation</p>
</dd>
<dt><code>degrees</code></dt><dd><p>logical, whether <code>alpha</code> is given in degrees</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Line</code> object.
</p>


<hr>
<a id="method-Line-translate"></a>



<h4>Method <code>translate()</code></h4>

<p>Translate the reference line.
</p>


<h5>Usage</h5>

<div class="r"><pre>Line$translate(v)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt><dd><p>the vector of translation</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Line</code> object.
</p>


<hr>
<a id="method-Line-invert"></a>



<h4>Method <code>invert()</code></h4>

<p>Invert the reference line.
</p>


<h5>Usage</h5>

<div class="r"><pre>Line$invert(inversion)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>inversion</code></dt><dd><p>an <code>Inversion</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Circle</code> object or a <code>Line</code> object.
</p>


<hr>
<a id="method-Line-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Line$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `Line$new`
## ------------------------------------------------

l &lt;- Line$new(c(1,1), c(1.5,1.5), FALSE, TRUE)
l
l$A
l$A &lt;- c(0,0)
l

## ------------------------------------------------
## Method `Line$print`
## ------------------------------------------------

Line$new(c(0,0), c(1,0), FALSE, TRUE)

## ------------------------------------------------
## Method `Line$includes`
## ------------------------------------------------

A &lt;- c(0,0); B &lt;- c(1,2); M &lt;- c(3,6)
l &lt;- Line$new(A, B, FALSE, FALSE)
l$includes(M, strict = TRUE)
</code></pre>

<hr>
<h2 id='LineFromEquation'>Line from general equation</h2><span id='topic+LineFromEquation'></span>

<h3>Description</h3>

<p>Create a <code>Line</code> object representing the infinite line
with given equation <code class="reqn">ax + by + c = 0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LineFromEquation(a, b, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LineFromEquation_+3A_a">a</code>, <code id="LineFromEquation_+3A_b">b</code>, <code id="LineFromEquation_+3A_c">c</code></td>
<td>
<p>the parameters of the equation; <code>a</code> and <code>b</code> cannot
be both zero</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Line</code> object.
</p>

<hr>
<h2 id='LineFromInterceptAndSlope'>Line from intercept and slope</h2><span id='topic+LineFromInterceptAndSlope'></span>

<h3>Description</h3>

<p>Create a <code>Line</code> object representing the infinite line
with given intercept and given slope.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LineFromInterceptAndSlope(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LineFromInterceptAndSlope_+3A_a">a</code></td>
<td>
<p>intercept</p>
</td></tr>
<tr><td><code id="LineFromInterceptAndSlope_+3A_b">b</code></td>
<td>
<p>slope</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Line</code> object.
</p>

<hr>
<h2 id='LownerJohnEllipse'>Löwner-John ellipse (ellipse hull)</h2><span id='topic+LownerJohnEllipse'></span>

<h3>Description</h3>

<p>Minimum area ellipse containing a set of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LownerJohnEllipse(pts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LownerJohnEllipse_+3A_pts">pts</code></td>
<td>
<p>the points in a two-columns matrix (one point per row); at least
three distinct points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>Ellipse</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pts &lt;- cbind(rnorm(30, sd=2), rnorm(30))
ell &lt;- LownerJohnEllipse(pts)
box &lt;- ell$boundingbox()
plot(NULL, asp = 1, xlim = box$x, ylim = box$y, xlab = NA, ylab = NA)
draw(ell, col = "seaShell")
points(pts, pch = 19)
all(apply(pts, 1, ell$contains)) # should be TRUE
</code></pre>

<hr>
<h2 id='maxAreaInscribedCircle'>Maximum area circle inscribed in a convex polygon</h2><span id='topic+maxAreaInscribedCircle'></span>

<h3>Description</h3>

<p>Computes the circle inscribed in a convex polygon with
maximum area. This is the so-called <em>Chebyshev circle</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxAreaInscribedCircle(points, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxAreaInscribedCircle_+3A_points">points</code></td>
<td>
<p>the vertices of the polygon in a two-columns matrix; their
order has no importance, since the procedure takes the convex hull of
these points (and does not check the convexity)</p>
</td></tr>
<tr><td><code id="maxAreaInscribedCircle_+3A_verbose">verbose</code></td>
<td>
<p>argument passed to <code><a href="CVXR.html#topic+psolve">psolve</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Circle</code> object. The status of the optimization problem
is given as an attribute of this circle. A warning is thrown if it is
not optimal.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+maxAreaInscribedEllipse">maxAreaInscribedEllipse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PlaneGeometry)
hexagon &lt;- rbind(
  c(-1.7, -1),
  c(-1.4, 0.4),
  c(0.3, 1.3),
  c(1.7, 0.6),
  c(1.3, -0.3),
  c(-0.4, -1.8)
)
opar &lt;- par(mar = c(2, 2, 1, 1))
plot(NULL, xlim=c(-2, 2), ylim=c(-2, 2), xlab = NA, ylab = NA, asp = 1)
points(hexagon, pch = 19)
polygon(hexagon)
circ &lt;- maxAreaInscribedCircle(hexagon)
draw(circ, col = "yellow2", border = "blue", lwd = 2)
par(opar)
# check optimization status:
attr(circ, "status")
</code></pre>

<hr>
<h2 id='maxAreaInscribedEllipse'>Maximum area ellipse inscribed in a convex polygon</h2><span id='topic+maxAreaInscribedEllipse'></span>

<h3>Description</h3>

<p>Computes the ellipse inscribed in a convex polygon with
maximum area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxAreaInscribedEllipse(points, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxAreaInscribedEllipse_+3A_points">points</code></td>
<td>
<p>the vertices of the polygon in a two-columns matrix; their
order has no importance, since the procedure takes the convex hull of
these points (and does not check the convexity)</p>
</td></tr>
<tr><td><code id="maxAreaInscribedEllipse_+3A_verbose">verbose</code></td>
<td>
<p>argument passed to <code><a href="CVXR.html#topic+psolve">psolve</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>Ellipse</code> object. The status of the optimization problem
is given as an attribute of this ellipse. A warning is thrown if it is
not optimal.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+maxAreaInscribedCircle">maxAreaInscribedCircle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hexagon &lt;- rbind(
  c(-1.7, -1),
  c(-1.4, 0.4),
  c(0.3, 1.3),
  c(1.7, 0.6),
  c(1.3, -0.3),
  c(-0.4, -1.8)
)
opar &lt;- par(mar = c(2, 2, 1, 1))
plot(NULL, xlim=c(-2, 2), ylim=c(-2, 2), xlab = NA, ylab = NA, asp = 1)
points(hexagon, pch = 19)
polygon(hexagon)
ell &lt;- maxAreaInscribedEllipse(hexagon)
draw(ell, col = "yellow2", border = "blue", lwd = 2)
par(opar)
# check optimization status:
attr(ell, "status")
</code></pre>

<hr>
<h2 id='midCircles'>Mid-circle(s)</h2><span id='topic+midCircles'></span>

<h3>Description</h3>

<p>Return the mid-circle(s) of two circles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>midCircles(circ1, circ2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="midCircles_+3A_circ1">circ1</code>, <code id="midCircles_+3A_circ2">circ2</code></td>
<td>
<p><code>Circle</code> objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A mid-circle of two circles is a generalized circle (i.e. a circle
or a line) such that the inversion on this circle swaps the two circles.
The case of a line appears only when the two circles have equal radii.
</p>


<h3>Value</h3>

<p>A <code>Circle</code> object, or a <code>Line</code> object, or a list of two
such objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inversionSwappingTwoCircles">inversionSwappingTwoCircles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>circ1 &lt;- Circle$new(c(5,4),2)
circ2 &lt;- Circle$new(c(6,4),1)
midcircle &lt;- midCircles(circ1, circ2)
inversionFromCircle(midcircle)
inversionSwappingTwoCircles(circ1, circ2)
</code></pre>

<hr>
<h2 id='Mobius'>R6 class representing a Möbius transformation.</h2><span id='topic+Mobius'></span>

<h3>Description</h3>

<p>A Möbius transformation is given by a matrix of complex numbers
with non-null determinant.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>a</code></dt><dd><p>get or set <code>a</code></p>
</dd>
<dt><code>b</code></dt><dd><p>get or set <code>b</code></p>
</dd>
<dt><code>c</code></dt><dd><p>get or set <code>c</code></p>
</dd>
<dt><code>d</code></dt><dd><p>get or set <code>d</code></p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Mobius-new"><code>Mobius$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Mobius-print"><code>Mobius$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Mobius-getM"><code>Mobius$getM()</code></a>
</p>
</li>
<li> <p><a href="#method-Mobius-compose"><code>Mobius$compose()</code></a>
</p>
</li>
<li> <p><a href="#method-Mobius-inverse"><code>Mobius$inverse()</code></a>
</p>
</li>
<li> <p><a href="#method-Mobius-power"><code>Mobius$power()</code></a>
</p>
</li>
<li> <p><a href="#method-Mobius-gpower"><code>Mobius$gpower()</code></a>
</p>
</li>
<li> <p><a href="#method-Mobius-transform"><code>Mobius$transform()</code></a>
</p>
</li>
<li> <p><a href="#method-Mobius-fixedPoints"><code>Mobius$fixedPoints()</code></a>
</p>
</li>
<li> <p><a href="#method-Mobius-transformCircle"><code>Mobius$transformCircle()</code></a>
</p>
</li>
<li> <p><a href="#method-Mobius-transformLine"><code>Mobius$transformLine()</code></a>
</p>
</li>
<li> <p><a href="#method-Mobius-transformGcircle"><code>Mobius$transformGcircle()</code></a>
</p>
</li>
<li> <p><a href="#method-Mobius-clone"><code>Mobius$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Mobius-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Mobius</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Mobius$new(M)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>M</code></dt><dd><p>the matrix corresponding to the Möbius transformation</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Mobius</code> object.
</p>


<hr>
<a id="method-Mobius-print"></a>



<h4>Method <code>print()</code></h4>

<p>Show instance of a <code>Mobius</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Mobius$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>Mobius$new(rbind(c(1+1i,2),c(0,3-2i)))
</pre>
</div>


<hr>
<a id="method-Mobius-getM"></a>



<h4>Method <code>getM()</code></h4>

<p>Get the matrix corresponding to the Möbius transformation.
</p>


<h5>Usage</h5>

<div class="r"><pre>Mobius$getM()</pre></div>


<hr>
<a id="method-Mobius-compose"></a>



<h4>Method <code>compose()</code></h4>

<p>Compose the reference Möbius transformation with another
Möbius transformation
</p>


<h5>Usage</h5>

<div class="r"><pre>Mobius$compose(M1, left = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>M1</code></dt><dd><p>a <code>Mobius</code> object</p>
</dd>
<dt><code>left</code></dt><dd><p>logical, whether to compose at left or at right (i.e.
returns <code>M1 o M0</code> or <code>M0 o M1</code>)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Mobius</code> object.
</p>


<hr>
<a id="method-Mobius-inverse"></a>



<h4>Method <code>inverse()</code></h4>

<p>Inverse of the reference Möbius transformation.
</p>


<h5>Usage</h5>

<div class="r"><pre>Mobius$inverse()</pre></div>



<h5>Returns</h5>

<p>A <code>Mobius</code> object.
</p>


<hr>
<a id="method-Mobius-power"></a>



<h4>Method <code>power()</code></h4>

<p>Power of the reference Möbius transformation.
</p>


<h5>Usage</h5>

<div class="r"><pre>Mobius$power(k)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>k</code></dt><dd><p>an integer, possibly negative</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The Möbius transformation <code>M^k</code>,
where <code>M</code> is the reference Möbius transformation.
</p>


<hr>
<a id="method-Mobius-gpower"></a>



<h4>Method <code>gpower()</code></h4>

<p>Generalized power of the reference Möbius transformation.
</p>


<h5>Usage</h5>

<div class="r"><pre>Mobius$gpower(k)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>k</code></dt><dd><p>a real number, possibly negative</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Mobius</code> object, the generalized <code>k</code>-th power of
the reference Möbius transformation.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>M &lt;- Mobius$new(rbind(c(1+1i,2),c(0,3-2i)))
Mroot &lt;- M$gpower(1/2)
Mroot$compose(Mroot) # should be M
</pre>
</div>


<hr>
<a id="method-Mobius-transform"></a>



<h4>Method <code>transform()</code></h4>

<p>Transformation of a point by the reference Möbius transformation.
</p>


<h5>Usage</h5>

<div class="r"><pre>Mobius$transform(M)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>M</code></dt><dd><p>a point or <code>Inf</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A point or <code>Inf</code>, the image of <code>M</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>Mob &lt;- Mobius$new(rbind(c(1+1i,2),c(0,3-2i)))
Mob$transform(c(1,1))
Mob$transform(Inf)
</pre>
</div>


<hr>
<a id="method-Mobius-fixedPoints"></a>



<h4>Method <code>fixedPoints()</code></h4>

<p>Returns the fixed points of the reference Möbius transformation.
</p>


<h5>Usage</h5>

<div class="r"><pre>Mobius$fixedPoints()</pre></div>



<h5>Returns</h5>

<p>One point, or a list of two points, or a message in the case when the transformation is the identity map.
</p>


<hr>
<a id="method-Mobius-transformCircle"></a>



<h4>Method <code>transformCircle()</code></h4>

<p>Transformation of a circle by the reference Möbius transformation.
</p>


<h5>Usage</h5>

<div class="r"><pre>Mobius$transformCircle(circ)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>circ</code></dt><dd><p>a <code>Circle</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Circle</code> object or a <code>Line</code> object.
</p>


<hr>
<a id="method-Mobius-transformLine"></a>



<h4>Method <code>transformLine()</code></h4>

<p>Transformation of a line by the reference Möbius transformation.
</p>


<h5>Usage</h5>

<div class="r"><pre>Mobius$transformLine(line)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>line</code></dt><dd><p>a <code>Line</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Circle</code> object or a <code>Line</code> object.
</p>


<hr>
<a id="method-Mobius-transformGcircle"></a>



<h4>Method <code>transformGcircle()</code></h4>

<p>Transformation of a generalized circle (i.e. a circle or a
line) by the reference Möbius transformation.
</p>


<h5>Usage</h5>

<div class="r"><pre>Mobius$transformGcircle(gcirc)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>gcirc</code></dt><dd><p>a <code>Circle</code> object or a <code>Line</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Circle</code> object or a <code>Line</code> object.
</p>


<hr>
<a id="method-Mobius-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Mobius$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+MobiusMappingThreePoints">MobiusMappingThreePoints</a></code> to create a Möbius
transformation, and also the <code>compose</code> method of the
<code><a href="#topic+Inversion">Inversion</a></code> R6 class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `Mobius$print`
## ------------------------------------------------

Mobius$new(rbind(c(1+1i,2),c(0,3-2i)))

## ------------------------------------------------
## Method `Mobius$gpower`
## ------------------------------------------------

M &lt;- Mobius$new(rbind(c(1+1i,2),c(0,3-2i)))
Mroot &lt;- M$gpower(1/2)
Mroot$compose(Mroot) # should be M

## ------------------------------------------------
## Method `Mobius$transform`
## ------------------------------------------------

Mob &lt;- Mobius$new(rbind(c(1+1i,2),c(0,3-2i)))
Mob$transform(c(1,1))
Mob$transform(Inf)
</code></pre>

<hr>
<h2 id='MobiusMappingCircle'>Möbius transformation mapping a given circle to a given circle</h2><span id='topic+MobiusMappingCircle'></span>

<h3>Description</h3>

<p>Returns a Möbius transformation mapping a given circle to
another given circle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MobiusMappingCircle(circ1, circ2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MobiusMappingCircle_+3A_circ1">circ1</code>, <code id="MobiusMappingCircle_+3A_circ2">circ2</code></td>
<td>
<p><code>Circle</code> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Möbius transformation which maps <code>circ1</code> to <code>circ2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PlaneGeometry)
C1 &lt;- Circle$new(c(0, 0), 1)
C2 &lt;- Circle$new(c(1, 2), 3)
M &lt;- MobiusMappingCircle(C1, C2)
C3 &lt;- M$transformCircle(C1)
C3$isEqual(C2)
</code></pre>

<hr>
<h2 id='MobiusMappingThreePoints'>Möbius transformation mapping three given points to three given points</h2><span id='topic+MobiusMappingThreePoints'></span>

<h3>Description</h3>

<p>Return a Möbius transformation which sends
<code>P1</code> to <code>Q1</code>, <code>P2</code> to <code>Q2</code> and <code>P3</code> to <code>Q3</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MobiusMappingThreePoints(P1, P2, P3, Q1, Q2, Q3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MobiusMappingThreePoints_+3A_p1">P1</code>, <code id="MobiusMappingThreePoints_+3A_p2">P2</code>, <code id="MobiusMappingThreePoints_+3A_p3">P3</code></td>
<td>
<p>three distinct points, <code>Inf</code> allowed</p>
</td></tr>
<tr><td><code id="MobiusMappingThreePoints_+3A_q1">Q1</code>, <code id="MobiusMappingThreePoints_+3A_q2">Q2</code>, <code id="MobiusMappingThreePoints_+3A_q3">Q3</code></td>
<td>
<p>three distinct points, <code>Inf</code> allowed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Mobius</code> object.
</p>

<hr>
<h2 id='MobiusSwappingTwoPoints'>Möbius transformation swapping two given points</h2><span id='topic+MobiusSwappingTwoPoints'></span>

<h3>Description</h3>

<p>Return a Möbius transformation which sends
<code>A</code> to <code>B</code> and <code>B</code> to <code>A</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MobiusSwappingTwoPoints(A, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MobiusSwappingTwoPoints_+3A_a">A</code>, <code id="MobiusSwappingTwoPoints_+3A_b">B</code></td>
<td>
<p>two distinct points, <code>Inf</code> not allowed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Mobius</code> object.
</p>

<hr>
<h2 id='Projection'>R6 class representing a projection</h2><span id='topic+Projection'></span>

<h3>Description</h3>

<p>A projection on a line <code>D</code> parallel to another line
<code>Delta</code> is given by the line of projection (<code>D</code>)
and the directrix line (<code>Delta</code>).
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>D</code></dt><dd><p>get or set the projection line</p>
</dd>
<dt><code>Delta</code></dt><dd><p>get or set the directrix line</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Projection-new"><code>Projection$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Projection-print"><code>Projection$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Projection-project"><code>Projection$project()</code></a>
</p>
</li>
<li> <p><a href="#method-Projection-transform"><code>Projection$transform()</code></a>
</p>
</li>
<li> <p><a href="#method-Projection-getMatrix"><code>Projection$getMatrix()</code></a>
</p>
</li>
<li> <p><a href="#method-Projection-asAffine"><code>Projection$asAffine()</code></a>
</p>
</li>
<li> <p><a href="#method-Projection-clone"><code>Projection$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Projection-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Projection</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Projection$new(D, Delta)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>D, Delta</code></dt><dd><p>two <code>Line</code> objects such that the two lines meet
(not parallel); or <code>Delta = NULL</code> for orthogonal projection onto
<code>D</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Projection</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>D &lt;- Line$new(c(1,1), c(5,5))
Delta &lt;- Line$new(c(0,0), c(3,4))
Projection$new(D, Delta)
</pre>
</div>


<hr>
<a id="method-Projection-print"></a>



<h4>Method <code>print()</code></h4>

<p>Show instance of a projection object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Projection$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Projection-project"></a>



<h4>Method <code>project()</code></h4>

<p>Project a point.
</p>


<h5>Usage</h5>

<div class="r"><pre>Projection$project(M)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>M</code></dt><dd><p>a point</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>D &lt;- Line$new(c(1,1), c(5,5))
Delta &lt;- Line$new(c(0,0), c(3,4))
P &lt;- Projection$new(D, Delta)
M &lt;- c(1,3)
Mprime &lt;- P$project(M)
D$includes(Mprime) # should be TRUE
Delta$isParallel(Line$new(M, Mprime)) # should be TRUE
</pre>
</div>


<hr>
<a id="method-Projection-transform"></a>



<h4>Method <code>transform()</code></h4>

<p>An alias of <code>project</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Projection$transform(M)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>M</code></dt><dd><p>a point</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Projection-getMatrix"></a>



<h4>Method <code>getMatrix()</code></h4>

<p>Augmented matrix of the projection.
</p>


<h5>Usage</h5>

<div class="r"><pre>Projection$getMatrix()</pre></div>



<h5>Returns</h5>

<p>A 3x3 matrix.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>P &lt;- Projection$new(Line$new(c(2,2), c(4,5)), Line$new(c(0,0), c(1,1)))
M &lt;- c(1,5)
P$project(M)
P$getMatrix() %*% c(M,1)
</pre>
</div>


<hr>
<a id="method-Projection-asAffine"></a>



<h4>Method <code>asAffine()</code></h4>

<p>Convert the reference projection to an <code>Affine</code>
object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Projection$asAffine()</pre></div>


<hr>
<a id="method-Projection-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Projection$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Note</h3>

<p>For an orthogonal projection, you can use the <code>projection</code>
method of the <code><a href="#topic+Line">Line</a></code> R6 class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `Projection$new`
## ------------------------------------------------

D &lt;- Line$new(c(1,1), c(5,5))
Delta &lt;- Line$new(c(0,0), c(3,4))
Projection$new(D, Delta)

## ------------------------------------------------
## Method `Projection$project`
## ------------------------------------------------

D &lt;- Line$new(c(1,1), c(5,5))
Delta &lt;- Line$new(c(0,0), c(3,4))
P &lt;- Projection$new(D, Delta)
M &lt;- c(1,3)
Mprime &lt;- P$project(M)
D$includes(Mprime) # should be TRUE
Delta$isParallel(Line$new(M, Mprime)) # should be TRUE

## ------------------------------------------------
## Method `Projection$getMatrix`
## ------------------------------------------------

P &lt;- Projection$new(Line$new(c(2,2), c(4,5)), Line$new(c(0,0), c(1,1)))
M &lt;- c(1,5)
P$project(M)
P$getMatrix() %*% c(M,1)
</code></pre>

<hr>
<h2 id='radicalCenter'>Radical center</h2><span id='topic+radicalCenter'></span>

<h3>Description</h3>

<p>Returns the radical center of three circles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radicalCenter(circ1, circ2, circ3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="radicalCenter_+3A_circ1">circ1</code>, <code id="radicalCenter_+3A_circ2">circ2</code>, <code id="radicalCenter_+3A_circ3">circ3</code></td>
<td>
<p><code>Circle</code> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A point.
</p>

<hr>
<h2 id='Reflection'>R6 class representing a reflection</h2><span id='topic+Reflection'></span>

<h3>Description</h3>

<p>A reflection is given by a line.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>line</code></dt><dd><p>get or set the line of the reflection</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Reflection-new"><code>Reflection$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Reflection-print"><code>Reflection$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Reflection-reflect"><code>Reflection$reflect()</code></a>
</p>
</li>
<li> <p><a href="#method-Reflection-transform"><code>Reflection$transform()</code></a>
</p>
</li>
<li> <p><a href="#method-Reflection-reflectCircle"><code>Reflection$reflectCircle()</code></a>
</p>
</li>
<li> <p><a href="#method-Reflection-transformCircle"><code>Reflection$transformCircle()</code></a>
</p>
</li>
<li> <p><a href="#method-Reflection-reflectLine"><code>Reflection$reflectLine()</code></a>
</p>
</li>
<li> <p><a href="#method-Reflection-transformLine"><code>Reflection$transformLine()</code></a>
</p>
</li>
<li> <p><a href="#method-Reflection-getMatrix"><code>Reflection$getMatrix()</code></a>
</p>
</li>
<li> <p><a href="#method-Reflection-asAffine"><code>Reflection$asAffine()</code></a>
</p>
</li>
<li> <p><a href="#method-Reflection-clone"><code>Reflection$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Reflection-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Reflection</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Reflection$new(line)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>line</code></dt><dd><p>a <code>Line</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Reflection</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>l &lt;- Line$new(c(1,1), c(1.5,1.5), FALSE, TRUE)
Reflection$new(l)
</pre>
</div>


<hr>
<a id="method-Reflection-print"></a>



<h4>Method <code>print()</code></h4>

<p>Show instance of a reflection object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Reflection$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Reflection-reflect"></a>



<h4>Method <code>reflect()</code></h4>

<p>Reflect a point.
</p>


<h5>Usage</h5>

<div class="r"><pre>Reflection$reflect(M)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>M</code></dt><dd><p>a point, <code>Inf</code> allowed</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Reflection-transform"></a>



<h4>Method <code>transform()</code></h4>

<p>An alias of <code>reflect</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Reflection$transform(M)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>M</code></dt><dd><p>a point, <code>Inf</code> allowed</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Reflection-reflectCircle"></a>



<h4>Method <code>reflectCircle()</code></h4>

<p>Reflect a circle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Reflection$reflectCircle(circ)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>circ</code></dt><dd><p>a <code>Circle</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Circle</code> object.
</p>


<hr>
<a id="method-Reflection-transformCircle"></a>



<h4>Method <code>transformCircle()</code></h4>

<p>An alias of <code>reflectCircle</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Reflection$transformCircle(circ)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>circ</code></dt><dd><p>a <code>Circle</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Circle</code> object.
</p>


<hr>
<a id="method-Reflection-reflectLine"></a>



<h4>Method <code>reflectLine()</code></h4>

<p>Reflect a line.
</p>


<h5>Usage</h5>

<div class="r"><pre>Reflection$reflectLine(line)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>line</code></dt><dd><p>a <code>Line</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Line</code> object.
</p>


<hr>
<a id="method-Reflection-transformLine"></a>



<h4>Method <code>transformLine()</code></h4>

<p>An alias of <code>reflectLine</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Reflection$transformLine(line)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>line</code></dt><dd><p>a <code>Line</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Line</code> object.
</p>


<hr>
<a id="method-Reflection-getMatrix"></a>



<h4>Method <code>getMatrix()</code></h4>

<p>Augmented matrix of the reflection.
</p>


<h5>Usage</h5>

<div class="r"><pre>Reflection$getMatrix()</pre></div>



<h5>Returns</h5>

<p>A 3x3 matrix.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>R &lt;- Reflection$new(Line$new(c(2,2), c(4,5)))
P &lt;- c(1,5)
R$reflect(P)
R$getMatrix() %*% c(P,1)
</pre>
</div>


<hr>
<a id="method-Reflection-asAffine"></a>



<h4>Method <code>asAffine()</code></h4>

<p>Convert the reference reflection to an <code>Affine</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Reflection$asAffine()</pre></div>


<hr>
<a id="method-Reflection-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Reflection$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `Reflection$new`
## ------------------------------------------------

l &lt;- Line$new(c(1,1), c(1.5,1.5), FALSE, TRUE)
Reflection$new(l)

## ------------------------------------------------
## Method `Reflection$getMatrix`
## ------------------------------------------------

R &lt;- Reflection$new(Line$new(c(2,2), c(4,5)))
P &lt;- c(1,5)
R$reflect(P)
R$getMatrix() %*% c(P,1)
</code></pre>

<hr>
<h2 id='Rotation'>R6 class representing a rotation</h2><span id='topic+Rotation'></span>

<h3>Description</h3>

<p>A rotation is given by an angle (<code>theta</code>) and a center.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>theta</code></dt><dd><p>get or set the angle of the rotation</p>
</dd>
<dt><code>center</code></dt><dd><p>get or set the center</p>
</dd>
<dt><code>degrees</code></dt><dd><p>get or set the <code>degrees</code> field</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Rotation-new"><code>Rotation$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Rotation-print"><code>Rotation$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Rotation-rotate"><code>Rotation$rotate()</code></a>
</p>
</li>
<li> <p><a href="#method-Rotation-transform"><code>Rotation$transform()</code></a>
</p>
</li>
<li> <p><a href="#method-Rotation-rotateCircle"><code>Rotation$rotateCircle()</code></a>
</p>
</li>
<li> <p><a href="#method-Rotation-transformCircle"><code>Rotation$transformCircle()</code></a>
</p>
</li>
<li> <p><a href="#method-Rotation-rotateEllipse"><code>Rotation$rotateEllipse()</code></a>
</p>
</li>
<li> <p><a href="#method-Rotation-transformEllipse"><code>Rotation$transformEllipse()</code></a>
</p>
</li>
<li> <p><a href="#method-Rotation-rotateLine"><code>Rotation$rotateLine()</code></a>
</p>
</li>
<li> <p><a href="#method-Rotation-transformLine"><code>Rotation$transformLine()</code></a>
</p>
</li>
<li> <p><a href="#method-Rotation-getMatrix"><code>Rotation$getMatrix()</code></a>
</p>
</li>
<li> <p><a href="#method-Rotation-asAffine"><code>Rotation$asAffine()</code></a>
</p>
</li>
<li> <p><a href="#method-Rotation-clone"><code>Rotation$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Rotation-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Rotation</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rotation$new(theta, center, degrees = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>theta</code></dt><dd><p>a number, the angle of the rotation</p>
</dd>
<dt><code>center</code></dt><dd><p>a point, the center of the rotation</p>
</dd>
<dt><code>degrees</code></dt><dd><p>logical, whether <code>theta</code> is given in degrees</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Rotation</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>Rotation$new(60, c(1,1))
</pre>
</div>


<hr>
<a id="method-Rotation-print"></a>



<h4>Method <code>print()</code></h4>

<p>Show instance of a <code>Rotation</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rotation$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Rotation-rotate"></a>



<h4>Method <code>rotate()</code></h4>

<p>Rotate a point or several points.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rotation$rotate(M)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>M</code></dt><dd><p>a point or a two-column matrix of points, one point per row</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Rotation-transform"></a>



<h4>Method <code>transform()</code></h4>

<p>An alias of <code>rotate</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rotation$transform(M)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>M</code></dt><dd><p>a point or a two-column matrix of points, one point per row</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Rotation-rotateCircle"></a>



<h4>Method <code>rotateCircle()</code></h4>

<p>Rotate a circle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rotation$rotateCircle(circ)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>circ</code></dt><dd><p>a <code>Circle</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Circle</code> object.
</p>


<hr>
<a id="method-Rotation-transformCircle"></a>



<h4>Method <code>transformCircle()</code></h4>

<p>An alias of <code>rotateCircle</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rotation$transformCircle(circ)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>circ</code></dt><dd><p>a <code>Circle</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Circle</code> object.
</p>


<hr>
<a id="method-Rotation-rotateEllipse"></a>



<h4>Method <code>rotateEllipse()</code></h4>

<p>Rotate an ellipse.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rotation$rotateEllipse(ell)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ell</code></dt><dd><p>an <code>Ellipse</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An <code>Ellipse</code> object.
</p>


<hr>
<a id="method-Rotation-transformEllipse"></a>



<h4>Method <code>transformEllipse()</code></h4>

<p>An alias of <code>rotateEllipse</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rotation$transformEllipse(ell)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ell</code></dt><dd><p>an <code>Ellipse</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An <code>Ellipse</code> object.
</p>


<hr>
<a id="method-Rotation-rotateLine"></a>



<h4>Method <code>rotateLine()</code></h4>

<p>Rotate a line.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rotation$rotateLine(line)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>line</code></dt><dd><p>a <code>Line</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Line</code> object.
</p>


<hr>
<a id="method-Rotation-transformLine"></a>



<h4>Method <code>transformLine()</code></h4>

<p>An alias of <code>rotateLine</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rotation$transformLine(line)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>line</code></dt><dd><p>a <code>Line</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Line</code> object.
</p>


<hr>
<a id="method-Rotation-getMatrix"></a>



<h4>Method <code>getMatrix()</code></h4>

<p>Augmented matrix of the rotation.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rotation$getMatrix()</pre></div>



<h5>Returns</h5>

<p>A 3x3 matrix.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>R &lt;- Rotation$new(60, c(1,1))
P &lt;- c(1,5)
R$rotate(P)
R$getMatrix() %*% c(P,1)
</pre>
</div>


<hr>
<a id="method-Rotation-asAffine"></a>



<h4>Method <code>asAffine()</code></h4>

<p>Convert the reference rotation to an <code>Affine</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rotation$asAffine()</pre></div>


<hr>
<a id="method-Rotation-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rotation$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `Rotation$new`
## ------------------------------------------------

Rotation$new(60, c(1,1))

## ------------------------------------------------
## Method `Rotation$getMatrix`
## ------------------------------------------------

R &lt;- Rotation$new(60, c(1,1))
P &lt;- c(1,5)
R$rotate(P)
R$getMatrix() %*% c(P,1)
</code></pre>

<hr>
<h2 id='Scaling'>R6 class representing a (non-uniform) scaling</h2><span id='topic+Scaling'></span>

<h3>Description</h3>

<p>A (non-uniform) scaling is given by a center, a direction vector,
and a scale factor.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>center</code></dt><dd><p>get or set the center</p>
</dd>
<dt><code>direction</code></dt><dd><p>get or set the direction</p>
</dd>
<dt><code>scale</code></dt><dd><p>get or set the scale factor</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Scaling-new"><code>Scaling$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Scaling-print"><code>Scaling$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Scaling-transform"><code>Scaling$transform()</code></a>
</p>
</li>
<li> <p><a href="#method-Scaling-getMatrix"><code>Scaling$getMatrix()</code></a>
</p>
</li>
<li> <p><a href="#method-Scaling-asAffine"><code>Scaling$asAffine()</code></a>
</p>
</li>
<li> <p><a href="#method-Scaling-scaleCircle"><code>Scaling$scaleCircle()</code></a>
</p>
</li>
<li> <p><a href="#method-Scaling-clone"><code>Scaling$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Scaling-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Scaling</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Scaling$new(center, direction, scale)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>center</code></dt><dd><p>a point, the center of the scaling</p>
</dd>
<dt><code>direction</code></dt><dd><p>a vector, the direction of the scaling</p>
</dd>
<dt><code>scale</code></dt><dd><p>a number, the scale factor</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Scaling</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>Scaling$new(c(1,1), c(1,3), 2)
</pre>
</div>


<hr>
<a id="method-Scaling-print"></a>



<h4>Method <code>print()</code></h4>

<p>Show instance of a <code>Scaling</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Scaling$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Scaling-transform"></a>



<h4>Method <code>transform()</code></h4>

<p>Transform a point or several points by the reference scaling.
</p>


<h5>Usage</h5>

<div class="r"><pre>Scaling$transform(M)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>M</code></dt><dd><p>a point or a two-column matrix of points, one point per row</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Scaling-getMatrix"></a>



<h4>Method <code>getMatrix()</code></h4>

<p>Augmented matrix of the scaling.
</p>


<h5>Usage</h5>

<div class="r"><pre>Scaling$getMatrix()</pre></div>



<h5>Returns</h5>

<p>A 3x3 matrix.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>S &lt;- Scaling$new(c(1,1), c(2,3), 2)
P &lt;- c(1,5)
S$transform(P)
S$getMatrix() %*% c(P,1)
</pre>
</div>


<hr>
<a id="method-Scaling-asAffine"></a>



<h4>Method <code>asAffine()</code></h4>

<p>Convert the reference scaling to an <code>Affine</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Scaling$asAffine()</pre></div>


<hr>
<a id="method-Scaling-scaleCircle"></a>



<h4>Method <code>scaleCircle()</code></h4>

<p>Scale a circle. The result is an ellipse.
</p>


<h5>Usage</h5>

<div class="r"><pre>Scaling$scaleCircle(circ)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>circ</code></dt><dd><p>a <code>Circle</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An <code>Ellipse</code> object.
</p>


<hr>
<a id="method-Scaling-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Scaling$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>R. Goldman,
<em>An Integrated Introduction to Computer Graphics and Geometric Modeling</em>.
CRC Press, 2009.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Q &lt;- c(1,1); w &lt;- c(1,3); s &lt;- 2
S &lt;- Scaling$new(Q, w, s)
# the center is mapped to itself:
S$transform(Q)
# any vector \code{u} parallel to the direction vector is mapped to \code{s*u}:
u &lt;- 3*w
all.equal(s*u, S$transform(u) - S$transform(c(0,0)))
# any vector perpendicular to the direction vector is mapped to itself
wt &lt;- 3*c(-w[2], w[1])
all.equal(wt, S$transform(wt) - S$transform(c(0,0)))


## ------------------------------------------------
## Method `Scaling$new`
## ------------------------------------------------

Scaling$new(c(1,1), c(1,3), 2)

## ------------------------------------------------
## Method `Scaling$getMatrix`
## ------------------------------------------------

S &lt;- Scaling$new(c(1,1), c(2,3), 2)
P &lt;- c(1,5)
S$transform(P)
S$getMatrix() %*% c(P,1)
</code></pre>

<hr>
<h2 id='ScalingXY'>R6 class representing an axis-scaling</h2><span id='topic+ScalingXY'></span>

<h3>Description</h3>

<p>An axis-scaling is given by a center, and two scale factors
<code>sx</code> and <code>sy</code>, one for the x-axis and one for the y-axis.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>center</code></dt><dd><p>get or set the center</p>
</dd>
<dt><code>sx</code></dt><dd><p>get or set the scale factor of the x-axis</p>
</dd>
<dt><code>sy</code></dt><dd><p>get or set the scale factor of the y-ayis</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ScalingXY-new"><code>ScalingXY$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ScalingXY-print"><code>ScalingXY$print()</code></a>
</p>
</li>
<li> <p><a href="#method-ScalingXY-transform"><code>ScalingXY$transform()</code></a>
</p>
</li>
<li> <p><a href="#method-ScalingXY-getMatrix"><code>ScalingXY$getMatrix()</code></a>
</p>
</li>
<li> <p><a href="#method-ScalingXY-asAffine"><code>ScalingXY$asAffine()</code></a>
</p>
</li>
<li> <p><a href="#method-ScalingXY-clone"><code>ScalingXY$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ScalingXY-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>ScalingXY</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>ScalingXY$new(center, sx, sy)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>center</code></dt><dd><p>a point, the center of the scaling</p>
</dd>
<dt><code>sx</code></dt><dd><p>a number, the scale factor of the x-axis</p>
</dd>
<dt><code>sy</code></dt><dd><p>a number, the scale factor of the y-axis</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>ScalingXY</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>ScalingXY$new(c(1,1), 4, 2)
</pre>
</div>


<hr>
<a id="method-ScalingXY-print"></a>



<h4>Method <code>print()</code></h4>

<p>Show instance of a <code>ScalingXY</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>ScalingXY$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ScalingXY-transform"></a>



<h4>Method <code>transform()</code></h4>

<p>Transform a point or several points by the reference axis-scaling.
</p>


<h5>Usage</h5>

<div class="r"><pre>ScalingXY$transform(M)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>M</code></dt><dd><p>a point or a two-column matrix of points, one point per row</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A point or a two-column matrix of points.
</p>


<hr>
<a id="method-ScalingXY-getMatrix"></a>



<h4>Method <code>getMatrix()</code></h4>

<p>Augmented matrix of the axis-scaling.
</p>


<h5>Usage</h5>

<div class="r"><pre>ScalingXY$getMatrix()</pre></div>



<h5>Returns</h5>

<p>A 3x3 matrix.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>S &lt;- ScalingXY$new(c(1,1), 4, 2)
P &lt;- c(1,5)
S$transform(P)
S$getMatrix() %*% c(P,1)
</pre>
</div>


<hr>
<a id="method-ScalingXY-asAffine"></a>



<h4>Method <code>asAffine()</code></h4>

<p>Convert the reference axis-scaling to an <code>Affine</code>
object.
</p>


<h5>Usage</h5>

<div class="r"><pre>ScalingXY$asAffine()</pre></div>


<hr>
<a id="method-ScalingXY-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ScalingXY$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `ScalingXY$new`
## ------------------------------------------------

ScalingXY$new(c(1,1), 4, 2)

## ------------------------------------------------
## Method `ScalingXY$getMatrix`
## ------------------------------------------------

S &lt;- ScalingXY$new(c(1,1), 4, 2)
P &lt;- c(1,5)
S$transform(P)
S$getMatrix() %*% c(P,1)
</code></pre>

<hr>
<h2 id='Shear'>R6 class representing a shear transformation</h2><span id='topic+Shear'></span>

<h3>Description</h3>

<p>A shear is given by a vertex, two perpendicular vectors,
and an angle.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>vertex</code></dt><dd><p>get or set the vertex</p>
</dd>
<dt><code>vector</code></dt><dd><p>get or set the first vector</p>
</dd>
<dt><code>ratio</code></dt><dd><p>get or set the ratio between the length of <code>vector</code>
and the length of the second vector, perpendicular to the first one</p>
</dd>
<dt><code>angle</code></dt><dd><p>get or set the angle</p>
</dd>
<dt><code>degrees</code></dt><dd><p>get or set the <code>degrees</code> field</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Shear-new"><code>Shear$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Shear-print"><code>Shear$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Shear-transform"><code>Shear$transform()</code></a>
</p>
</li>
<li> <p><a href="#method-Shear-getMatrix"><code>Shear$getMatrix()</code></a>
</p>
</li>
<li> <p><a href="#method-Shear-asAffine"><code>Shear$asAffine()</code></a>
</p>
</li>
<li> <p><a href="#method-Shear-clone"><code>Shear$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Shear-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Shear</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Shear$new(vertex, vector, ratio, angle, degrees = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>vertex</code></dt><dd><p>a point</p>
</dd>
<dt><code>vector</code></dt><dd><p>a vector</p>
</dd>
<dt><code>ratio</code></dt><dd><p>a positive number, the ratio between the length of <code>vector</code>
and the length of the second vector, perpendicular to the first one</p>
</dd>
<dt><code>angle</code></dt><dd><p>an angle strictly between -90 degrees and 90 degrees</p>
</dd>
<dt><code>degrees</code></dt><dd><p>logical, whether <code>angle</code> is given in degrees</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Shear</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>Shear$new(c(1,1), c(1,3), 0.5, 30)
</pre>
</div>


<hr>
<a id="method-Shear-print"></a>



<h4>Method <code>print()</code></h4>

<p>Show instance of a <code>Shear</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Shear$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Shear-transform"></a>



<h4>Method <code>transform()</code></h4>

<p>Transform a point or several points by the reference shear.
</p>


<h5>Usage</h5>

<div class="r"><pre>Shear$transform(M)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>M</code></dt><dd><p>a point or a two-column matrix of points, one point per row</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Shear-getMatrix"></a>



<h4>Method <code>getMatrix()</code></h4>

<p>Augmented matrix of the shear.
</p>


<h5>Usage</h5>

<div class="r"><pre>Shear$getMatrix()</pre></div>



<h5>Returns</h5>

<p>A 3x3 matrix.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>S &lt;- Shear$new(c(1,1), c(1,3), 0.5, 30)
S$getMatrix()
</pre>
</div>


<hr>
<a id="method-Shear-asAffine"></a>



<h4>Method <code>asAffine()</code></h4>

<p>Convert the reference shear to an <code>Affine</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Shear$asAffine()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>Shear$new(c(0,0), c(1,0), 1, atan(30), FALSE)$asAffine()
</pre>
</div>


<hr>
<a id="method-Shear-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Shear$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>R. Goldman,
<em>An Integrated Introduction to Computer Graphics and Geometric Modeling</em>.
CRC Press, 2009.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- c(0,0); w &lt;- c(1,0); ratio &lt;- 1; angle &lt;- 45
shear &lt;- Shear$new(P, w, ratio, angle)
wt &lt;- ratio * c(-w[2], w[1])
Q &lt;- P + w; R &lt;- Q + wt; S &lt;- P + wt
A &lt;- shear$transform(P)
B &lt;- shear$transform(Q)
C &lt;- shear$transform(R)
D &lt;- shear$transform(S)
plot(0, 0, type = "n", asp = 1, xlim = c(0,1), ylim = c(0,2))
lines(rbind(P,Q,R,S,P), lwd = 2) # unit square
lines(rbind(A,B,C,D,A), lwd = 2, col = "blue") # image by the shear


## ------------------------------------------------
## Method `Shear$new`
## ------------------------------------------------

Shear$new(c(1,1), c(1,3), 0.5, 30)

## ------------------------------------------------
## Method `Shear$getMatrix`
## ------------------------------------------------

S &lt;- Shear$new(c(1,1), c(1,3), 0.5, 30)
S$getMatrix()

## ------------------------------------------------
## Method `Shear$asAffine`
## ------------------------------------------------

Shear$new(c(0,0), c(1,0), 1, atan(30), FALSE)$asAffine()
</code></pre>

<hr>
<h2 id='soddyCircle'>Inner Soddy circle</h2><span id='topic+soddyCircle'></span>

<h3>Description</h3>

<p>Inner Soddy circles associated to three circles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>soddyCircle(circ1, circ2, circ3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="soddyCircle_+3A_circ1">circ1</code>, <code id="soddyCircle_+3A_circ2">circ2</code>, <code id="soddyCircle_+3A_circ3">circ3</code></td>
<td>
<p>distinct circles</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Circle</code> object.
</p>

<hr>
<h2 id='SteinerChain'>Steiner chain</h2><span id='topic+SteinerChain'></span>

<h3>Description</h3>

<p>Return a Steiner chain of circles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SteinerChain(c0, n, phi, shift, ellipse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SteinerChain_+3A_c0">c0</code></td>
<td>
<p>exterior circle, a <code>Circle</code> object</p>
</td></tr>
<tr><td><code id="SteinerChain_+3A_n">n</code></td>
<td>
<p>number of circles, not including the inner circle; at least <code>3</code></p>
</td></tr>
<tr><td><code id="SteinerChain_+3A_phi">phi</code></td>
<td>
<p><code>-1 &lt; phi &lt; 1</code> controls the radii of the circles</p>
</td></tr>
<tr><td><code id="SteinerChain_+3A_shift">shift</code></td>
<td>
<p>any number; it produces a kind of rotation around the inner
circle; values between <code>0</code> and <code>n</code> cover all possibilities</p>
</td></tr>
<tr><td><code id="SteinerChain_+3A_ellipse">ellipse</code></td>
<td>
<p>logical; the centers of the circles of the Steiner chain lie
on an ellipse, and this ellipse is returned as an attribute if you set this
argument to <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>n+1</code> <code>Circle</code> objects. The inner circle is stored at the
last position.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c0 &lt;- Circle$new(c(1,1), 3)
chain &lt;- SteinerChain(c0, 5, 0.3, 0.5, ellipse = TRUE)
plot(0, 0, type = "n", asp = 1, xlim = c(-4,4), ylim = c(-4,4))
invisible(lapply(chain, draw, lwd = 2, border = "blue"))
draw(c0, lwd = 2)
draw(attr(chain, "ellipse"), lwd = 2, border = "red")
</code></pre>

<hr>
<h2 id='Translation'>R6 class representing a translation</h2><span id='topic+Translation'></span>

<h3>Description</h3>

<p>A translation is given by a vector <code>v</code>.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>v</code></dt><dd><p>get or set the vector of translation</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Translation-new"><code>Translation$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Translation-print"><code>Translation$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Translation-project"><code>Translation$project()</code></a>
</p>
</li>
<li> <p><a href="#method-Translation-transform"><code>Translation$transform()</code></a>
</p>
</li>
<li> <p><a href="#method-Translation-translateLine"><code>Translation$translateLine()</code></a>
</p>
</li>
<li> <p><a href="#method-Translation-transformLine"><code>Translation$transformLine()</code></a>
</p>
</li>
<li> <p><a href="#method-Translation-translateEllipse"><code>Translation$translateEllipse()</code></a>
</p>
</li>
<li> <p><a href="#method-Translation-transformEllipse"><code>Translation$transformEllipse()</code></a>
</p>
</li>
<li> <p><a href="#method-Translation-getMatrix"><code>Translation$getMatrix()</code></a>
</p>
</li>
<li> <p><a href="#method-Translation-asAffine"><code>Translation$asAffine()</code></a>
</p>
</li>
<li> <p><a href="#method-Translation-clone"><code>Translation$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Translation-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Translation</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Translation$new(v)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt><dd><p>a numeric vector of length two, the vector of translation</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Translation</code> object.
</p>


<hr>
<a id="method-Translation-print"></a>



<h4>Method <code>print()</code></h4>

<p>Show instance of a translation object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Translation$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Translation-project"></a>



<h4>Method <code>project()</code></h4>

<p>Transform a point or several points by the reference
translation.
</p>


<h5>Usage</h5>

<div class="r"><pre>Translation$project(M)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>M</code></dt><dd><p>a point or a two-column matrix of points, one point per row</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Translation-transform"></a>



<h4>Method <code>transform()</code></h4>

<p>An alias of <code>translate</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Translation$transform(M)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>M</code></dt><dd><p>a point or a two-column matrix of points, one point per row</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Translation-translateLine"></a>



<h4>Method <code>translateLine()</code></h4>

<p>Translate a line.
</p>


<h5>Usage</h5>

<div class="r"><pre>Translation$translateLine(line)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>line</code></dt><dd><p>a <code>Line</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Line</code> object.
</p>


<hr>
<a id="method-Translation-transformLine"></a>



<h4>Method <code>transformLine()</code></h4>

<p>An alias of <code>translateLine</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Translation$transformLine(line)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>line</code></dt><dd><p>a <code>Line</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Line</code> object.
</p>


<hr>
<a id="method-Translation-translateEllipse"></a>



<h4>Method <code>translateEllipse()</code></h4>

<p>Translate a circle or an ellipse.
</p>


<h5>Usage</h5>

<div class="r"><pre>Translation$translateEllipse(ell)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ell</code></dt><dd><p>an <code>Ellipse</code> object or a <code>Circle</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An <code>Ellipse</code> object or a <code>Circle</code> object.
</p>


<hr>
<a id="method-Translation-transformEllipse"></a>



<h4>Method <code>transformEllipse()</code></h4>

<p>An alias of <code>translateEllipse</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Translation$transformEllipse(ell)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ell</code></dt><dd><p>an <code>Ellipse</code> object or a <code>Circle</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An <code>Ellipse</code> object or a <code>Circle</code> object.
</p>


<hr>
<a id="method-Translation-getMatrix"></a>



<h4>Method <code>getMatrix()</code></h4>

<p>Augmented matrix of the translation.
</p>


<h5>Usage</h5>

<div class="r"><pre>Translation$getMatrix()</pre></div>



<h5>Returns</h5>

<p>A 3x3 matrix.
</p>


<hr>
<a id="method-Translation-asAffine"></a>



<h4>Method <code>asAffine()</code></h4>

<p>Convert the reference translation to an <code>Affine</code>
object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Translation$asAffine()</pre></div>


<hr>
<a id="method-Translation-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Translation$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='Triangle'>R6 class representing a triangle</h2><span id='topic+Triangle'></span>

<h3>Description</h3>

<p>A triangle has three vertices. They are named A, B, C.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>A</code></dt><dd><p>get or set the vertex <code>A</code></p>
</dd>
<dt><code>B</code></dt><dd><p>get or set the vertex <code>B</code></p>
</dd>
<dt><code>C</code></dt><dd><p>get or set the vertex <code>C</code></p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Triangle-new"><code>Triangle$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-print"><code>Triangle$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-flatness"><code>Triangle$flatness()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-a"><code>Triangle$a()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-b"><code>Triangle$b()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-c"><code>Triangle$c()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-edges"><code>Triangle$edges()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-perimeter"><code>Triangle$perimeter()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-orientation"><code>Triangle$orientation()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-contains"><code>Triangle$contains()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-isAcute"><code>Triangle$isAcute()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-angleA"><code>Triangle$angleA()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-angleB"><code>Triangle$angleB()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-angleC"><code>Triangle$angleC()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-angles"><code>Triangle$angles()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-X175"><code>Triangle$X175()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-VeldkampIsoperimetricPoint"><code>Triangle$VeldkampIsoperimetricPoint()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-centroid"><code>Triangle$centroid()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-orthocenter"><code>Triangle$orthocenter()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-area"><code>Triangle$area()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-incircle"><code>Triangle$incircle()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-inradius"><code>Triangle$inradius()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-incenter"><code>Triangle$incenter()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-excircles"><code>Triangle$excircles()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-excentralTriangle"><code>Triangle$excentralTriangle()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-BevanPoint"><code>Triangle$BevanPoint()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-medialTriangle"><code>Triangle$medialTriangle()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-orthicTriangle"><code>Triangle$orthicTriangle()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-incentralTriangle"><code>Triangle$incentralTriangle()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-NagelTriangle"><code>Triangle$NagelTriangle()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-NagelPoint"><code>Triangle$NagelPoint()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-GergonneTriangle"><code>Triangle$GergonneTriangle()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-GergonnePoint"><code>Triangle$GergonnePoint()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-tangentialTriangle"><code>Triangle$tangentialTriangle()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-symmedialTriangle"><code>Triangle$symmedialTriangle()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-symmedianPoint"><code>Triangle$symmedianPoint()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-circumcircle"><code>Triangle$circumcircle()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-circumcenter"><code>Triangle$circumcenter()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-circumradius"><code>Triangle$circumradius()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-BrocardCircle"><code>Triangle$BrocardCircle()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-BrocardPoints"><code>Triangle$BrocardPoints()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-LemoineCircleI"><code>Triangle$LemoineCircleI()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-LemoineCircleII"><code>Triangle$LemoineCircleII()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-LemoineTriangle"><code>Triangle$LemoineTriangle()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-LemoineCircleIII"><code>Triangle$LemoineCircleIII()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-ParryCircle"><code>Triangle$ParryCircle()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-outerSoddyCircle"><code>Triangle$outerSoddyCircle()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-pedalTriangle"><code>Triangle$pedalTriangle()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-CevianTriangle"><code>Triangle$CevianTriangle()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-MalfattiCircles"><code>Triangle$MalfattiCircles()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-AjimaMalfatti1"><code>Triangle$AjimaMalfatti1()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-AjimaMalfatti2"><code>Triangle$AjimaMalfatti2()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-equalDetourPoint"><code>Triangle$equalDetourPoint()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-trilinearToPoint"><code>Triangle$trilinearToPoint()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-pointToTrilinear"><code>Triangle$pointToTrilinear()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-isogonalConjugate"><code>Triangle$isogonalConjugate()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-rotate"><code>Triangle$rotate()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-translate"><code>Triangle$translate()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-SteinerEllipse"><code>Triangle$SteinerEllipse()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-SteinerInellipse"><code>Triangle$SteinerInellipse()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-MandartInellipse"><code>Triangle$MandartInellipse()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-randomPoints"><code>Triangle$randomPoints()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-hexylTriangle"><code>Triangle$hexylTriangle()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-plot"><code>Triangle$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-Triangle-clone"><code>Triangle$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Triangle-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Triangle</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$new(A, B, C)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>A, B, C</code></dt><dd><p>vertices</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Triangle</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>t &lt;- Triangle$new(c(0,0), c(1,0), c(1,1))
t
t$C
t$C &lt;- c(2,2)
t
</pre>
</div>


<hr>
<a id="method-Triangle-print"></a>



<h4>Method <code>print()</code></h4>

<p>Show instance of a triangle object
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>Triangle$new(c(0,0), c(1,0), c(1,1))
</pre>
</div>


<hr>
<a id="method-Triangle-flatness"></a>



<h4>Method <code>flatness()</code></h4>

<p>Flatness of the triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$flatness()</pre></div>



<h5>Returns</h5>

<p>A number between 0 and 1. A triangle is flat when its flatness is 1.
</p>


<hr>
<a id="method-Triangle-a"></a>



<h4>Method <code>a()</code></h4>

<p>Length of the side <code>BC</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$a()</pre></div>


<hr>
<a id="method-Triangle-b"></a>



<h4>Method <code>b()</code></h4>

<p>Length of the side <code>AC</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$b()</pre></div>


<hr>
<a id="method-Triangle-c"></a>



<h4>Method <code>c()</code></h4>

<p>Length of the side <code>AB</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$c()</pre></div>


<hr>
<a id="method-Triangle-edges"></a>



<h4>Method <code>edges()</code></h4>

<p>The lengths of the sides of the triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$edges()</pre></div>



<h5>Returns</h5>

<p>A named numeric vector.
</p>


<hr>
<a id="method-Triangle-perimeter"></a>



<h4>Method <code>perimeter()</code></h4>

<p>Perimeter of the triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$perimeter()</pre></div>



<h5>Returns</h5>

<p>The perimeter of the triangle.
</p>


<hr>
<a id="method-Triangle-orientation"></a>



<h4>Method <code>orientation()</code></h4>

<p>Determine the orientation of the triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$orientation()</pre></div>



<h5>Returns</h5>

<p>An integer: 1 for counterclockwise, -1 for clockwise, 0 for collinear.
</p>


<hr>
<a id="method-Triangle-contains"></a>



<h4>Method <code>contains()</code></h4>

<p>Determine whether a point lies inside the reference triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$contains(M)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>M</code></dt><dd><p>a point</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Triangle-isAcute"></a>



<h4>Method <code>isAcute()</code></h4>

<p>Determines whether the reference triangle is acute.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$isAcute()</pre></div>



<h5>Returns</h5>

<p>'TRUE' if the triangle is acute (or right), 'FALSE' otherwise.
</p>


<hr>
<a id="method-Triangle-angleA"></a>



<h4>Method <code>angleA()</code></h4>

<p>Angle at the vertex A.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$angleA()</pre></div>



<h5>Returns</h5>

<p>The angle at the vertex A in radians.
</p>


<hr>
<a id="method-Triangle-angleB"></a>



<h4>Method <code>angleB()</code></h4>

<p>Angle at the vertex B.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$angleB()</pre></div>



<h5>Returns</h5>

<p>The angle at the vertex B in radians.
</p>


<hr>
<a id="method-Triangle-angleC"></a>



<h4>Method <code>angleC()</code></h4>

<p>Angle at the vertex C.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$angleC()</pre></div>



<h5>Returns</h5>

<p>The angle at the vertex C in radians.
</p>


<hr>
<a id="method-Triangle-angles"></a>



<h4>Method <code>angles()</code></h4>

<p>The three angles of the triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$angles()</pre></div>



<h5>Returns</h5>

<p>A named vector containing the values of the angles in radians.
</p>


<hr>
<a id="method-Triangle-X175"></a>



<h4>Method <code>X175()</code></h4>

<p>Isoperimetric point, also known as the X(175) triangle
center; this is the center of the outer Soddy circle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$X175()</pre></div>


<hr>
<a id="method-Triangle-VeldkampIsoperimetricPoint"></a>



<h4>Method <code>VeldkampIsoperimetricPoint()</code></h4>

<p>Isoperimetric point in the sense of Veldkamp.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$VeldkampIsoperimetricPoint()</pre></div>



<h5>Returns</h5>

<p>The isoperimetric point in the sense of Veldkamp, if it exists.
Otherwise, returns 'NULL'.
</p>


<hr>
<a id="method-Triangle-centroid"></a>



<h4>Method <code>centroid()</code></h4>

<p>Centroid.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$centroid()</pre></div>


<hr>
<a id="method-Triangle-orthocenter"></a>



<h4>Method <code>orthocenter()</code></h4>

<p>Orthocenter.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$orthocenter()</pre></div>


<hr>
<a id="method-Triangle-area"></a>



<h4>Method <code>area()</code></h4>

<p>Area of the triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$area()</pre></div>


<hr>
<a id="method-Triangle-incircle"></a>



<h4>Method <code>incircle()</code></h4>

<p>Incircle of the triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$incircle()</pre></div>



<h5>Returns</h5>

<p>A <code>Circle</code> object.
</p>


<hr>
<a id="method-Triangle-inradius"></a>



<h4>Method <code>inradius()</code></h4>

<p>Inradius of the reference triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$inradius()</pre></div>


<hr>
<a id="method-Triangle-incenter"></a>



<h4>Method <code>incenter()</code></h4>

<p>Incenter of the reference triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$incenter()</pre></div>


<hr>
<a id="method-Triangle-excircles"></a>



<h4>Method <code>excircles()</code></h4>

<p>Excircles of the triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$excircles()</pre></div>



<h5>Returns</h5>

<p>A list with the three excircles, <code>Circle</code> objects.
</p>


<hr>
<a id="method-Triangle-excentralTriangle"></a>



<h4>Method <code>excentralTriangle()</code></h4>

<p>Excentral triangle of the reference triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$excentralTriangle()</pre></div>



<h5>Returns</h5>

<p>A <code>Triangle</code> object.
</p>


<hr>
<a id="method-Triangle-BevanPoint"></a>



<h4>Method <code>BevanPoint()</code></h4>

<p>Bevan point. This is the circumcenter of the
excentral triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$BevanPoint()</pre></div>


<hr>
<a id="method-Triangle-medialTriangle"></a>



<h4>Method <code>medialTriangle()</code></h4>

<p>Medial triangle. Its vertices are the mid-points of the
sides of the reference triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$medialTriangle()</pre></div>


<hr>
<a id="method-Triangle-orthicTriangle"></a>



<h4>Method <code>orthicTriangle()</code></h4>

<p>Orthic triangle. Its vertices are the feet of the altitudes
of the reference triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$orthicTriangle()</pre></div>


<hr>
<a id="method-Triangle-incentralTriangle"></a>



<h4>Method <code>incentralTriangle()</code></h4>

<p>Incentral triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$incentralTriangle()</pre></div>



<h5>Details</h5>

<p>It is the triangle whose vertices are the intersections of the
reference triangle's angle bisectors with the respective opposite sides.
</p>



<h5>Returns</h5>

<p>A <code>Triangle</code> object.
</p>


<hr>
<a id="method-Triangle-NagelTriangle"></a>



<h4>Method <code>NagelTriangle()</code></h4>

<p>Nagel triangle (or extouch triangle) of the reference triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$NagelTriangle(NagelPoint = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>NagelPoint</code></dt><dd><p>logical, whether to return the Nagel point as attribute</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Triangle</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>t &lt;- Triangle$new(c(0,-2), c(0.5,1), c(3,0.6))
lineAB &lt;- Line$new(t$A, t$B)
lineAC &lt;- Line$new(t$A, t$C)
lineBC &lt;- Line$new(t$B, t$C)
NagelTriangle &lt;- t$NagelTriangle(NagelPoint = TRUE)
NagelPoint &lt;- attr(NagelTriangle, "Nagel point")
excircles &lt;- t$excircles()
opar &lt;- par(mar = c(0,0,0,0))
plot(0, 0, type="n", asp = 1, xlim = c(-1,5), ylim = c(-3,3),
     xlab = NA, ylab = NA, axes = FALSE)
draw(t, lwd = 2)
draw(lineAB); draw(lineAC); draw(lineBC)
draw(excircles$A, border = "orange")
draw(excircles$B, border = "orange")
draw(excircles$C, border = "orange")
draw(NagelTriangle, lwd = 2, col = "red")
draw(Line$new(t$A, NagelTriangle$A, FALSE, FALSE), col = "blue")
draw(Line$new(t$B, NagelTriangle$B, FALSE, FALSE), col = "blue")
draw(Line$new(t$C, NagelTriangle$C, FALSE, FALSE), col = "blue")
points(rbind(NagelPoint), pch = 19)
par(opar)
</pre>
</div>


<hr>
<a id="method-Triangle-NagelPoint"></a>



<h4>Method <code>NagelPoint()</code></h4>

<p>Nagel point of the triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$NagelPoint()</pre></div>


<hr>
<a id="method-Triangle-GergonneTriangle"></a>



<h4>Method <code>GergonneTriangle()</code></h4>

<p>Gergonne triangle of the reference triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$GergonneTriangle(GergonnePoint = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>GergonnePoint</code></dt><dd><p>logical, whether to return the Gergonne point as an attribute</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The Gergonne triangle is also known as the
<em>intouch triangle</em> or the <em>contact triangle</em>.
This is the triangle made of the three tangency points of the incircle.
</p>



<h5>Returns</h5>

<p>A <code>Triangle</code> object.
</p>


<hr>
<a id="method-Triangle-GergonnePoint"></a>



<h4>Method <code>GergonnePoint()</code></h4>

<p>Gergonne point of the reference triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$GergonnePoint()</pre></div>


<hr>
<a id="method-Triangle-tangentialTriangle"></a>



<h4>Method <code>tangentialTriangle()</code></h4>

<p>Tangential triangle of the reference triangle.
This is the triangle formed by the lines tangent to the circumcircle of
the reference triangle at its vertices. It does not exist for a
right triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$tangentialTriangle()</pre></div>



<h5>Returns</h5>

<p>A <code>Triangle</code> object.
</p>


<hr>
<a id="method-Triangle-symmedialTriangle"></a>



<h4>Method <code>symmedialTriangle()</code></h4>

<p>Symmedial triangle of the reference triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$symmedialTriangle()</pre></div>



<h5>Returns</h5>

<p>A <code>Triangle</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>t &lt;- Triangle$new(c(0,-2), c(0.5,1), c(3,0.6))
symt &lt;- t$symmedialTriangle()
symmedianA &lt;- Line$new(t$A, symt$A, FALSE, FALSE)
symmedianB &lt;- Line$new(t$B, symt$B, FALSE, FALSE)
symmedianC &lt;- Line$new(t$C, symt$C, FALSE, FALSE)
K &lt;- t$symmedianPoint()
opar &lt;- par(mar = c(0,0,0,0))
plot(NULL, asp = 1, xlim = c(-1,5), ylim = c(-3,3),
     xlab = NA, ylab = NA, axes = FALSE)
draw(t, lwd = 2)
draw(symmedianA, lwd = 2, col = "blue")
draw(symmedianB, lwd = 2, col = "blue")
draw(symmedianC, lwd = 2, col = "blue")
points(rbind(K), pch = 19, col = "red")
par(opar)
</pre>
</div>


<hr>
<a id="method-Triangle-symmedianPoint"></a>



<h4>Method <code>symmedianPoint()</code></h4>

<p>Symmedian point of the reference triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$symmedianPoint()</pre></div>



<h5>Returns</h5>

<p>A point.
</p>


<hr>
<a id="method-Triangle-circumcircle"></a>



<h4>Method <code>circumcircle()</code></h4>

<p>Circumcircle of the reference triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$circumcircle()</pre></div>



<h5>Returns</h5>

<p>A <code>Circle</code> object.
</p>


<hr>
<a id="method-Triangle-circumcenter"></a>



<h4>Method <code>circumcenter()</code></h4>

<p>Circumcenter of the reference triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$circumcenter()</pre></div>


<hr>
<a id="method-Triangle-circumradius"></a>



<h4>Method <code>circumradius()</code></h4>

<p>Circumradius of the reference triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$circumradius()</pre></div>


<hr>
<a id="method-Triangle-BrocardCircle"></a>



<h4>Method <code>BrocardCircle()</code></h4>

<p>The Brocard circle of the reference triangle (also known
as the seven-point circle).
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$BrocardCircle()</pre></div>



<h5>Returns</h5>

<p>A <code>Circle</code> object.
</p>


<hr>
<a id="method-Triangle-BrocardPoints"></a>



<h4>Method <code>BrocardPoints()</code></h4>

<p>Brocard points of the reference triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$BrocardPoints()</pre></div>



<h5>Returns</h5>

<p>A list of two points, the first Brocard point and the second
Brocard point.
</p>


<hr>
<a id="method-Triangle-LemoineCircleI"></a>



<h4>Method <code>LemoineCircleI()</code></h4>

<p>The first Lemoine circle of the reference triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$LemoineCircleI()</pre></div>



<h5>Returns</h5>

<p>A <code>Circle</code> object.
</p>


<hr>
<a id="method-Triangle-LemoineCircleII"></a>



<h4>Method <code>LemoineCircleII()</code></h4>

<p>The second Lemoine circle of the reference triangle (also
known as the cosine circle)
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$LemoineCircleII()</pre></div>



<h5>Returns</h5>

<p>A <code>Circle</code> object.
</p>


<hr>
<a id="method-Triangle-LemoineTriangle"></a>



<h4>Method <code>LemoineTriangle()</code></h4>

<p>The Lemoine triangle of the reference triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$LemoineTriangle()</pre></div>



<h5>Returns</h5>

<p>A <code>Triangle</code> object.
</p>


<hr>
<a id="method-Triangle-LemoineCircleIII"></a>



<h4>Method <code>LemoineCircleIII()</code></h4>

<p>The third Lemoine circle of the reference triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$LemoineCircleIII()</pre></div>



<h5>Returns</h5>

<p>A <code>Circle</code> object.
</p>


<hr>
<a id="method-Triangle-ParryCircle"></a>



<h4>Method <code>ParryCircle()</code></h4>

<p>Parry circle of the reference triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$ParryCircle()</pre></div>



<h5>Returns</h5>

<p>A <code>Circle</code> object.
</p>


<hr>
<a id="method-Triangle-outerSoddyCircle"></a>



<h4>Method <code>outerSoddyCircle()</code></h4>

<p>Soddy outer circle of the reference triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$outerSoddyCircle()</pre></div>



<h5>Returns</h5>

<p>A <code>Circle</code> object.
</p>


<hr>
<a id="method-Triangle-pedalTriangle"></a>



<h4>Method <code>pedalTriangle()</code></h4>

<p>Pedal triangle of a point with respect to the reference
triangle. The pedal triangle of a point <code>P</code> is the triangle whose
vertices are the feet of the perpendiculars from <code>P</code> to the sides
of the reference triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$pedalTriangle(P)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>P</code></dt><dd><p>a point</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Triangle</code> object.
</p>


<hr>
<a id="method-Triangle-CevianTriangle"></a>



<h4>Method <code>CevianTriangle()</code></h4>

<p>Cevian triangle of a point with respect to the reference
triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$CevianTriangle(P)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>P</code></dt><dd><p>a point</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Triangle</code> object.
</p>


<hr>
<a id="method-Triangle-MalfattiCircles"></a>



<h4>Method <code>MalfattiCircles()</code></h4>

<p>Malfatti circles of the triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$MalfattiCircles(tangencyPoints = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tangencyPoints</code></dt><dd><p>logical, whether to retourn the tangency points of
the Malfatti circles as an attribute.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list with the three Malfatti circles, <code>Circle</code> objects.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>t &lt;- Triangle$new(c(0,0), c(2,0.5), c(1.5,2))
Mcircles &lt;- t$MalfattiCircles(TRUE)
plot(NULL, asp = 1, xlim = c(0,2.5), ylim = c(0,2.5),
     xlab = NA, ylab = NA)
grid()
draw(t, col = "blue", lwd = 2)
invisible(lapply(Mcircles, draw, col = "green", border = "red"))
invisible(lapply(attr(Mcircles, "tangencyPoints"), function(P){
  points(P[1], P[2], pch = 19)
}))
</pre>
</div>


<hr>
<a id="method-Triangle-AjimaMalfatti1"></a>



<h4>Method <code>AjimaMalfatti1()</code></h4>

<p>First Ajima-Malfatti point of the triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$AjimaMalfatti1()</pre></div>


<hr>
<a id="method-Triangle-AjimaMalfatti2"></a>



<h4>Method <code>AjimaMalfatti2()</code></h4>

<p>Second Ajima-Malfatti point of the triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$AjimaMalfatti2()</pre></div>


<hr>
<a id="method-Triangle-equalDetourPoint"></a>



<h4>Method <code>equalDetourPoint()</code></h4>

<p>Equal detour point of the triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$equalDetourPoint(detour = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>detour</code></dt><dd><p>logical, whether to return the detour as an attribute</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Also known as the X(176) triangle center.
</p>


<hr>
<a id="method-Triangle-trilinearToPoint"></a>



<h4>Method <code>trilinearToPoint()</code></h4>

<p>Point given by trilinear coordinates.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$trilinearToPoint(x, y, z)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x, y, z</code></dt><dd><p>trilinear coordinates</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The point with trilinear coordinates <code>x:y:z</code> with respect to
the reference triangle.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>t &lt;- Triangle$new(c(0,0), c(2,1), c(5,7))
incircle &lt;- t$incircle()
t$trilinearToPoint(1, 1, 1)
incircle$center
</pre>
</div>


<hr>
<a id="method-Triangle-pointToTrilinear"></a>



<h4>Method <code>pointToTrilinear()</code></h4>

<p>Give the trilinear coordinates of a point with respect to
the reference triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$pointToTrilinear(P)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>P</code></dt><dd><p>a point</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The trilinear coordinates, a numeric vector of length 3.
</p>


<hr>
<a id="method-Triangle-isogonalConjugate"></a>



<h4>Method <code>isogonalConjugate()</code></h4>

<p>Isogonal conjugate of a point with respect to
the reference triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$isogonalConjugate(P)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>P</code></dt><dd><p>a point</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A point, the isogonal conjugate of <code>P</code>.
</p>


<hr>
<a id="method-Triangle-rotate"></a>



<h4>Method <code>rotate()</code></h4>

<p>Rotate the triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$rotate(alpha, O, degrees = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>alpha</code></dt><dd><p>angle of rotation</p>
</dd>
<dt><code>O</code></dt><dd><p>center of rotation</p>
</dd>
<dt><code>degrees</code></dt><dd><p>logical, whether <code>alpha</code> is given in degrees</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Triangle</code> object.
</p>


<hr>
<a id="method-Triangle-translate"></a>



<h4>Method <code>translate()</code></h4>

<p>Translate the triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$translate(v)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt><dd><p>the vector of translation</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Triangle</code> object.
</p>


<hr>
<a id="method-Triangle-SteinerEllipse"></a>



<h4>Method <code>SteinerEllipse()</code></h4>

<p>The Steiner ellipse (or circumellipse) of the reference
triangle. This is the ellipse passing through the three vertices of
the triangle and centered at the centroid of the triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$SteinerEllipse()</pre></div>



<h5>Returns</h5>

<p>An <code>Ellipse</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>t &lt;- Triangle$new(c(0,0), c(2,0.5), c(1.5,2))
ell &lt;- t$SteinerEllipse()
plot(NULL, asp = 1, xlim = c(0,2.5), ylim = c(-0.7,2.4),
     xlab = NA, ylab = NA)
draw(t, col = "blue", lwd = 2)
draw(ell, border = "red", lwd =2)
</pre>
</div>


<hr>
<a id="method-Triangle-SteinerInellipse"></a>



<h4>Method <code>SteinerInellipse()</code></h4>

<p>The Steiner inellipse (or midpoint ellipse) of the reference
triangle. This is the ellipse tangent to the sides of the triangle at
their midpoints, and centered at the centroid of the triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$SteinerInellipse()</pre></div>



<h5>Returns</h5>

<p>An <code>Ellipse</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>t &lt;- Triangle$new(c(0,0), c(2,0.5), c(1.5,2))
ell &lt;- t$SteinerInellipse()
plot(NULL, asp = 1, xlim = c(0,2.5), ylim = c(-0.1,2.4),
     xlab = NA, ylab = NA)
draw(t, col = "blue", lwd = 2)
draw(ell, border = "red", lwd =2)
</pre>
</div>


<hr>
<a id="method-Triangle-MandartInellipse"></a>



<h4>Method <code>MandartInellipse()</code></h4>

<p>The Mandart inellipse of the reference triangle. This is
the unique ellipse tangent to the triangle's sides at the contact
points of its excircles
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$MandartInellipse()</pre></div>



<h5>Returns</h5>

<p>An <code>Ellipse</code> object.
</p>


<hr>
<a id="method-Triangle-randomPoints"></a>



<h4>Method <code>randomPoints()</code></h4>

<p>Random points on or in the reference triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$randomPoints(n, where = "in")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>an integer, the desired number of points</p>
</dd>
<dt><code>where</code></dt><dd><p><code>"in"</code> to generate inside the triangle,
<code>"on"</code> to generate on the sides of the triangle</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The generated points in a two columns matrix with <code>n</code> rows.
</p>


<hr>
<a id="method-Triangle-hexylTriangle"></a>



<h4>Method <code>hexylTriangle()</code></h4>

<p>Hexyl triangle.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$hexylTriangle()</pre></div>


<hr>
<a id="method-Triangle-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>Plot a <code>Triangle</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$plot(add = FALSE, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>add</code></dt><dd><p>Boolean, whether to add the plot to the current plot</p>
</dd>
<dt><code>...</code></dt><dd><p>named arguments passed to <code><a href="graphics.html#topic+polygon">polygon</a></code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Nothing, called for plotting only.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>trgl &lt;- Triangle$new(c(0, 0), c(1, 0), c(0.5, sqrt(3)/2))
trgl$plot(col = "yellow", border = "red")
</pre>
</div>


<hr>
<a id="method-Triangle-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Note</h3>

<p>The Steiner ellipse is also the smallest area ellipse which passes
through the vertices of the triangle, and thus can be obtained with
the function <code><a href="#topic+EllipseFromThreeBoundaryPoints">EllipseFromThreeBoundaryPoints</a></code>. We can also
note that the major axis of the Steiner ellipse is the Deming
least squares line of the three triangle vertices.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TriangleThreeLines">TriangleThreeLines</a></code> to define a triangle by three lines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># incircle and excircles
A &lt;- c(0,0); B &lt;- c(1,2); C &lt;- c(3.5,1)
t &lt;- Triangle$new(A, B, C)
incircle &lt;- t$incircle()
excircles &lt;- t$excircles()
JA &lt;- excircles$A$center
JB &lt;- excircles$B$center
JC &lt;- excircles$C$center
JAJBJC &lt;- Triangle$new(JA, JB, JC)
A_JA &lt;- Line$new(A, JA, FALSE, FALSE)
B_JB &lt;- Line$new(B, JB, FALSE, FALSE)
C_JC &lt;- Line$new(C, JC, FALSE, FALSE)
opar &lt;- par(mar = c(0,0,0,0))
plot(NULL, asp = 1, xlim = c(0,6), ylim = c(-4,4),
     xlab = NA, ylab = NA, axes = FALSE)
draw(t, lwd = 2)
draw(incircle, border = "orange")
draw(excircles$A); draw(excircles$B); draw(excircles$C)
draw(JAJBJC, col = "blue")
draw(A_JA, col = "green")
draw(B_JB, col = "green")
draw(C_JC, col = "green")
par(opar)


## ------------------------------------------------
## Method `Triangle$new`
## ------------------------------------------------

t &lt;- Triangle$new(c(0,0), c(1,0), c(1,1))
t
t$C
t$C &lt;- c(2,2)
t

## ------------------------------------------------
## Method `Triangle$print`
## ------------------------------------------------

Triangle$new(c(0,0), c(1,0), c(1,1))

## ------------------------------------------------
## Method `Triangle$NagelTriangle`
## ------------------------------------------------

t &lt;- Triangle$new(c(0,-2), c(0.5,1), c(3,0.6))
lineAB &lt;- Line$new(t$A, t$B)
lineAC &lt;- Line$new(t$A, t$C)
lineBC &lt;- Line$new(t$B, t$C)
NagelTriangle &lt;- t$NagelTriangle(NagelPoint = TRUE)
NagelPoint &lt;- attr(NagelTriangle, "Nagel point")
excircles &lt;- t$excircles()
opar &lt;- par(mar = c(0,0,0,0))
plot(0, 0, type="n", asp = 1, xlim = c(-1,5), ylim = c(-3,3),
     xlab = NA, ylab = NA, axes = FALSE)
draw(t, lwd = 2)
draw(lineAB); draw(lineAC); draw(lineBC)
draw(excircles$A, border = "orange")
draw(excircles$B, border = "orange")
draw(excircles$C, border = "orange")
draw(NagelTriangle, lwd = 2, col = "red")
draw(Line$new(t$A, NagelTriangle$A, FALSE, FALSE), col = "blue")
draw(Line$new(t$B, NagelTriangle$B, FALSE, FALSE), col = "blue")
draw(Line$new(t$C, NagelTriangle$C, FALSE, FALSE), col = "blue")
points(rbind(NagelPoint), pch = 19)
par(opar)

## ------------------------------------------------
## Method `Triangle$symmedialTriangle`
## ------------------------------------------------

t &lt;- Triangle$new(c(0,-2), c(0.5,1), c(3,0.6))
symt &lt;- t$symmedialTriangle()
symmedianA &lt;- Line$new(t$A, symt$A, FALSE, FALSE)
symmedianB &lt;- Line$new(t$B, symt$B, FALSE, FALSE)
symmedianC &lt;- Line$new(t$C, symt$C, FALSE, FALSE)
K &lt;- t$symmedianPoint()
opar &lt;- par(mar = c(0,0,0,0))
plot(NULL, asp = 1, xlim = c(-1,5), ylim = c(-3,3),
     xlab = NA, ylab = NA, axes = FALSE)
draw(t, lwd = 2)
draw(symmedianA, lwd = 2, col = "blue")
draw(symmedianB, lwd = 2, col = "blue")
draw(symmedianC, lwd = 2, col = "blue")
points(rbind(K), pch = 19, col = "red")
par(opar)

## ------------------------------------------------
## Method `Triangle$MalfattiCircles`
## ------------------------------------------------

t &lt;- Triangle$new(c(0,0), c(2,0.5), c(1.5,2))
Mcircles &lt;- t$MalfattiCircles(TRUE)
plot(NULL, asp = 1, xlim = c(0,2.5), ylim = c(0,2.5),
     xlab = NA, ylab = NA)
grid()
draw(t, col = "blue", lwd = 2)
invisible(lapply(Mcircles, draw, col = "green", border = "red"))
invisible(lapply(attr(Mcircles, "tangencyPoints"), function(P){
  points(P[1], P[2], pch = 19)
}))

## ------------------------------------------------
## Method `Triangle$trilinearToPoint`
## ------------------------------------------------

t &lt;- Triangle$new(c(0,0), c(2,1), c(5,7))
incircle &lt;- t$incircle()
t$trilinearToPoint(1, 1, 1)
incircle$center

## ------------------------------------------------
## Method `Triangle$SteinerEllipse`
## ------------------------------------------------

t &lt;- Triangle$new(c(0,0), c(2,0.5), c(1.5,2))
ell &lt;- t$SteinerEllipse()
plot(NULL, asp = 1, xlim = c(0,2.5), ylim = c(-0.7,2.4),
     xlab = NA, ylab = NA)
draw(t, col = "blue", lwd = 2)
draw(ell, border = "red", lwd =2)

## ------------------------------------------------
## Method `Triangle$SteinerInellipse`
## ------------------------------------------------

t &lt;- Triangle$new(c(0,0), c(2,0.5), c(1.5,2))
ell &lt;- t$SteinerInellipse()
plot(NULL, asp = 1, xlim = c(0,2.5), ylim = c(-0.1,2.4),
     xlab = NA, ylab = NA)
draw(t, col = "blue", lwd = 2)
draw(ell, border = "red", lwd =2)

## ------------------------------------------------
## Method `Triangle$plot`
## ------------------------------------------------

trgl &lt;- Triangle$new(c(0, 0), c(1, 0), c(0.5, sqrt(3)/2))
trgl$plot(col = "yellow", border = "red")
</code></pre>

<hr>
<h2 id='TriangleThreeLines'>Triangle defined by three lines</h2><span id='topic+TriangleThreeLines'></span>

<h3>Description</h3>

<p>Return the triangle formed by three lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TriangleThreeLines(line1, line2, line3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TriangleThreeLines_+3A_line1">line1</code>, <code id="TriangleThreeLines_+3A_line2">line2</code>, <code id="TriangleThreeLines_+3A_line3">line3</code></td>
<td>
<p><code>Line</code> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Triangle</code> object.
</p>

<hr>
<h2 id='unitCircle'>Unit circle</h2><span id='topic+unitCircle'></span>

<h3>Description</h3>

<p>Circle centered at the origin with radius 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unitCircle
</code></pre>


<h3>Format</h3>

<p>An object of class <code>Circle</code> (inherits from <code>R6</code>) of length 25.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
