<!DOCTYPE html><html lang="en"><head><title>Help for package sarima</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sarima}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sarima-package'><p>Package sarima</p>


Simulation and Prediction with Seasonal ARIMA Models</a></li>
<li><a href='#acfGarchTest'><p>Tests for weak white noise</p></a></li>
<li><a href='#acfIidTest'><p>Carry out IID tests using sample autocorrelations</p></a></li>
<li><a href='#acfMaTest'><p>Autocorrelation test for MA(q)</p></a></li>
<li><a href='#ar2Pacf'><p>Convert AR parameters to parcor</p></a></li>
<li><a href='#arma_Q0Gardner'><p>Computing the initial state covariance matrix of ARMA</p></a></li>
<li><a href='#arma_Q0gnb'><p>Compute the initial state covariance of ARMA model</p></a></li>
<li><a href='#armaccf_xe'><p>Crosscovariances between an ARMA process and its innovations</p></a></li>
<li><a href='#ArmaModel'><p>Create ARMA objects</p></a></li>
<li><a href='#ArmaModel-class'><p>Classes ArmaModel, ArModel and MaModel in package sarima</p></a></li>
<li><a href='#ArmaSpectrum-class'><p>Class <code>"ArmaSpectrum"</code></p></a></li>
<li><a href='#as.SarimaModel'><p>Convert S3 model objects to class SarimaModel</p></a></li>
<li><a href='#autocorrelations'><p>Compute autocorrelations and related quantities</p></a></li>
<li><a href='#autocorrelations-methods'><p>Methods for function autocorrelations()</p></a></li>
<li><a href='#autocovariances-methods'><p>Methods for function autocovariances()</p></a></li>
<li><a href='#coerce-methods'><p>setAs methods in package sarima</p></a></li>
<li><a href='#confint'>
<p>Confidence and acceptance intervals in package sarima</p></a></li>
<li><a href='#filterCoef'>
<p>Coefficients and other basic properties of filters</p>
</p></a></li>
<li><a href='#filterCoef-methods'><p>Methods for filterCoef()</p></a></li>
<li><a href='#filterOrder-methods'><p>Methods for function <code>filterOrder</code> in package <span class="pkg">sarima</span></p></a></li>
<li><a href='#filterPoly-methods'><p>Methods for <code>filterPoly</code> in package <span class="pkg">sarima</span></p></a></li>
<li><a href='#filterPolyCoef-methods'><p>Methods for filterPolyCoef</p></a></li>
<li><a href='#FisherInformation-methods'><p>Fisher information</p></a></li>
<li><a href='#fun.forecast'>
<p>Forecasting functions for seasonal ARIMA models</p></a></li>
<li><a href='#InterceptSpec-class'><p>Class InterceptSpec</p></a></li>
<li><a href='#isStationaryModel'><p>Check if a model is stationary</p></a></li>
<li><a href='#modelCenter'><p>model center</p></a></li>
<li><a href='#modelCoef'><p>Get the coefficients of models</p></a></li>
<li><a href='#modelCoef-methods'><p>Methods for generic function modelCoef</p></a></li>
<li><a href='#modelIntercept'><p>Give the intercept parameter of a model</p></a></li>
<li><a href='#modelOrder'><p>Get the model order and other properties of models</p></a></li>
<li><a href='#modelOrder-methods'><p>Get the order of a model</p></a></li>
<li><a href='#modelPoly-methods'><p>Get polynomials associated with SARIMA models</p></a></li>
<li><a href='#modelPolyCoef-methods'><p>Methods for modelPolyCoef</p></a></li>
<li><a href='#nSeasons'><p>Number of seasons</p></a></li>
<li><a href='#nUnitRoots'><p>Number of unit roots in a model</p></a></li>
<li><a href='#nvarOfAcfKP'><p>Compute variances of autocorrelations under ARCH-type hypothesis</p></a></li>
<li><a href='#nvcovOfAcf'><p>Covariances of sample autocorrelations</p></a></li>
<li><a href='#partialAutocorrelations-methods'><p>Methods for function partialAutocorrelations</p></a></li>
<li><a href='#periodogram'><p>Obtain the most important period lags of a time series according to</p>
a periodogram.</a></li>
<li><a href='#plot-methods'><p>Plot methods in package sarima</p></a></li>
<li><a href='#prepareSimSarima'><p>Prepare SARIMA simulations</p></a></li>
<li><a href='#rgarch1p1'><p>Simulate GARCH(1,1) models</p></a></li>
<li><a href='#sarima'><p>Fit extended SARIMA models</p></a></li>
<li><a href='#sarima.f'>
<p>Function used internally to compute forecasts</p></a></li>
<li><a href='#SarimaModel-class'><p>Class SarimaModel in package sarima</p></a></li>
<li><a href='#se'><p>Compute standard errors</p></a></li>
<li><a href='#show-methods'><p>Methods for <code>show</code> in package <span class="pkg">sarima</span></p></a></li>
<li><a href='#sigmaSq'><p>Get the innovation variance of models</p></a></li>
<li><a href='#sim_sarima'>
<p>Simulate trajectories of seasonal arima models</p></a></li>
<li><a href='#spectrum'><p>Spectral Density</p></a></li>
<li><a href='#Spectrum-class'><p>Class <code>"Spectrum"</code></p></a></li>
<li><a href='#summary.SarimaModel'><p>Methods for summary in package sarima</p></a></li>
<li><a href='#tsdiag.Sarima'><p>Diagnostic Plots for fitted seasonal ARIMA models</p></a></li>
<li><a href='#VirtualMonicFilter-class'><p>Undocumented classes in package sarima</p></a></li>
<li><a href='#whiteNoiseTest'><p>White noise tests</p></a></li>
<li><a href='#xarmaFilter'><p> Applies an extended ARMA filter to a time series</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulation and Prediction with Seasonal ARIMA Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions, classes and methods for time series modelling with ARIMA
    and related models. The aim of the package is to provide consistent
    interface for the user. For example, a single function autocorrelations()
    computes various kinds of theoretical and sample autocorrelations. This is
    work in progress, see the documentation and vignettes for the current
    functionality.  Function sarima() fits extended multiplicative seasonal
    ARIMA models with trends, exogenous variables and arbitrary roots on the
    unit circle, which can be fixed or estimated (for the algebraic basis for
    this see &lt;<a href="https://doi.org/10.48550%2FarXiv.2208.05055">doi:10.48550/arXiv.2208.05055</a>&gt;, a paper on the methodology is being prepared).</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://geobosh.github.io/sarima/">https://geobosh.github.io/sarima/</a> (doc)
<a href="https://github.com/GeoBosh/sarima">https://github.com/GeoBosh/sarima</a> (devel)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/GeoBosh/sarima/issues">https://github.com/GeoBosh/sarima/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), methods, stats4</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, utils, PolynomF (&ge; 1.0-0), Formula, lagged
(&ge; 0.2.1), Rcpp (&ge; 0.12.14), Rdpack, numDeriv, ltsa</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, KFAS, FKF, fGarch, forecast</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Collate:</td>
<td>RcppExports.R utils.R generics.R filterClasses.R
modelClasses.R sarima.R autocovariances.R armacalc.R fit.R
wrapKFAS.R arma_Q0dotdotstats.R Kalman.R fitTools.R
periodogram.R predict.Sarima.R zzz.R</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-18 09:34:16 UTC; georgi</td>
</tr>
<tr>
<td>Author:</td>
<td>Georgi N. Boshnakov [aut, cre],
  Jamie Halliday <a href="https://orcid.org/0000-0003-2839-346X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Georgi N. Boshnakov &lt;georgi.boshnakov@manchester.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-18 15:20:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='sarima-package'>Package sarima


Simulation and Prediction with Seasonal ARIMA Models
</h2><span id='topic+sarima-package'></span>

<h3>Description</h3>

<p>Functions, classes and methods for time series modelling with ARIMA
    and related models. The aim of the package is to provide consistent
    interface for the user. For example, a single function autocorrelations()
    computes various kinds of theoretical and sample autocorrelations. This is
    work in progress, see the documentation and vignettes for the current
    functionality.  Function sarima() fits extended multiplicative seasonal
    ARIMA models with trends, exogenous variables and arbitrary roots on the
    unit circle, which can be fixed or estimated (for the algebraic basis for
    this see &lt;doi:10.48550/arXiv.2208.05055&gt;, a paper on the methodology is being prepared).
</p>


<h3>Details</h3>

<p>There is a large number of packages for time series modelling. They provide a huge number of
functions, often with similar or overlapping functionality and different argument
conventions. One of the aims of package <span class="pkg">sarima</span> is to provide consistent interface to
some frequently used functionality.
</p>
<p>In package <span class="pkg">sarima</span> a consistent naming scheme is used as much as
possible. Names of functions start with a lowercase letter and consist
of whole words, acronyms or commonly used abbreviations. In multiword
names, the second and subsequent words start with capital letters
(camelCase).  Only the first letter in acronyms is capitalised,
e.g. Arma stands for ARMA.  Formal (S4) classes follow the same rules
but the first letter of the first word is capitalised, as well.
</p>
<p>For example, the functions that compute autocorrelations,
autocovariances, partial autocorrelations are called
<code>autocorrelations</code>, <code>autocovariances</code>, and
<code>partialAutocorrelations</code>, respectively. Moreover, they recognise
from their argument(s) what exactly is needed. If they are given times
series, they compute sample autocorrelations, etc; if they are given
model specifications, they compute the corresponding theoretical
properties.
</p>
<p>This is work in progress, see also the vignette(s).
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov [aut, cre],
  Jamie Halliday [aut] (&lt;https://orcid.org/0000-0003-2839-346X&gt;)
</p>
<p>Maintainer: Georgi N. Boshnakov &lt;georgi.boshnakov@manchester.ac.uk&gt;
</p>


<h3>References</h3>

<p>Boshnakov GN (1996).
&ldquo;Bartlett's formulae&mdash;closed forms and recurrent equations.&rdquo;
<em>Ann. Inst. Statist. Math.</em>, <b>48</b>(1), 49&ndash;59.
ISSN 0020-3157, <a href="https://doi.org/10.1007/BF00049288">doi:10.1007/BF00049288</a>.
</p>
<p>Halliday J, Boshnakov GN (2022).
&ldquo;Partial autocorrelation parameterisation of models with unit roots on the unit circle.&rdquo;
<a href="https://doi.org/10.48550/ARXIV.2208.05055">doi:10.48550/ARXIV.2208.05055</a>, <a href="https://arxiv.org/abs/2208.05055">https://arxiv.org/abs/2208.05055</a>.
</p>
<p>Brockwell PJ, Davis RA (1991).
<em>Time series: theory and methods. 2nd ed.</em>.
Springer Series in Statistics. Berlin etc.: Springer-Verlag..
</p>
<p>Francq C, Zakoian J (2010).
<em>GARCH models: structure, statistical inference and financial applications</em>.
John Wiley &amp; Sons.
ISBN 978-0-470-68391-0.
</p>
<p>Li WK (2004).
<em>Diagnostic checks in time series</em>.
Chapman &amp; Hall/CRC Press.
</p>
<p>McLeod AI, Yu H, Krougly Z (2007).
&ldquo;Algorithms for Linear Time Series Analysis: With R Package.&rdquo;
<em>Journal of Statistical Software</em>, <b>23</b>(5).
<a href="https://doi.org/10.18637/jss.v023.i05">doi:10.18637/jss.v023.i05</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ArmaModel">ArmaModel</a></code>
<code><a href="#topic+autocorrelations">autocorrelations</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulate a white noise ts (model from Francq &amp; Zakoian)
n &lt;- 5000
x &lt;- sarima:::rgarch1p1(n, alpha = 0.3, beta = 0.55, omega = 1, n.skip = 100)

## acf and pacf
( x.acf &lt;- autocorrelations(x) )
( x.pacf &lt;- partialAutocorrelations(x) )

## portmanteau test for iid, by default gives also ci's for the acf under H0
x.iid &lt;- whiteNoiseTest(x.acf, h0 = "iid", nlags = c(5,10,20), x = x, method = "LiMcLeod")
x.iid

x.iid2 &lt;- whiteNoiseTest(x.acf, h0 = "iid", nlags = c(5,10,20), x = x, method = "LjungBox")
x.iid2

## portmanteau test for garch H0
x.garch &lt;- whiteNoiseTest(x.acf, h0 = "garch", nlags = c(5,10,20), x = x)
x.garch

## plot methods give the CI's under H0
plot(x.acf)

## if the data are given, the CI's under garch H0 are also given.
plot(x.acf, data = x)

## Tests based on partial autocorrelations are also available:
plot(x.pacf)
plot(x.pacf, data = x)

## Models
## AR
( ar2a1 &lt;- ArModel(ar = c(-0.3, -0.7), sigma2 = 1) )
autocorrelations(ar2a1, maxlag = 6)
partialAutocorrelations(ar2a1, maxlag = 6)
autocovariances(ar2a1, maxlag = 6)
partialVariances(ar2a1, maxlag = 6)

## see examples for ArmaModel()
</code></pre>

<hr>
<h2 id='acfGarchTest'>Tests for weak white noise</h2><span id='topic+acfGarchTest'></span><span id='topic+acfWnTest'></span>

<h3>Description</h3>

<p>Carry out tests for weak white noise under GARCH, GARCH-type, and
stochastic volatility null hypotheses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acfGarchTest(acr, x, nlags, interval = 0.95)

acfWnTest(acr, x, nlags, interval = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="acfGarchTest_+3A_acr">acr</code></td>
<td>
<p>autocorrelations.</p>
</td></tr>
<tr><td><code id="acfGarchTest_+3A_x">x</code></td>
<td>
<p>time series.</p>
</td></tr>
<tr><td><code id="acfGarchTest_+3A_nlags">nlags</code></td>
<td>
<p>how many lags to use.</p>
</td></tr>
<tr><td><code id="acfGarchTest_+3A_interval">interval</code></td>
<td>
<p>If not NULL, compute also confidence intervals with
the specified coverage probability.</p>
</td></tr>
<tr><td><code id="acfGarchTest_+3A_...">...</code></td>
<td>

<p>additional arguments for the computation of the variance matrix
under the null hypothesis, passed on to <code><a href="#topic+nvarOfAcfKP">nvarOfAcfKP</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike the autocorrelation IID test, the time series is needed here to
estimate the covariance matrix of the autocorrelations under the null
hypothesis.
</p>
<p><code>acfGarchTest</code> performs a test for uncorrelatedness of a time
series. The null hypothesis is that the time series is GARCH,
see Francq and Zakoian (2010).
</p>
<p><code>acfWnTest</code> performs a test for uncorrelatedness of a time
series under a weaker null hypothesis.
The null hypothesis is that the time series is GARCH-type or
from a stochasitc volatily model,
see   Kokoszka and Politis (2011).
</p>
<p>See the references for details and precise specification of the
hypotheses.
</p>
<p>The format of the return value is the same as for <code>acfIidTest</code>.
</p>


<h3>Value</h3>

<p>a list with components &quot;test&quot; and &quot;ci&quot;
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>Francq C, Zakoian J (2010).
<em>GARCH models: structure, statistical inference and financial applications</em>.
John Wiley &amp; Sons.
ISBN 978-0-470-68391-0.<br /><br /> Kokoszka PS, Politis DN (2011).
&ldquo;Nonlinearity of ARCH and stochastic volatility models and Bartlett's formula.&rdquo;
<em>Probability and Mathematical Statistics</em>, <b>31</b>(1), 47&ndash;59.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+whiteNoiseTest">whiteNoiseTest</a></code>,
<code><a href="#topic+acfIidTest">acfIidTest</a></code>;
</p>
<p><code><a href="#topic+plot-methods">plot-methods</a></code> for graphical representations of results
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see also the examples for \code{\link{whiteNoiseTest}}
set.seed(1234)
n &lt;- 5000
x &lt;- sarima:::rgarch1p1(n, alpha = 0.3, beta = 0.55, omega = 1, n.skip = 100)
x.acf &lt;- autocorrelations(x)
x.pacf &lt;- partialAutocorrelations(x)

acfGarchTest(x.acf, x = x, nlags = c(5,10,20))
acfGarchTest(x.pacf, x = x, nlags = c(5,10,20))

# do not compute CI's:
acfGarchTest(x.pacf, x = x, nlags = c(5,10,20), interval = NULL)

## plot methods call acfGarchTest() suitably if 'x' is given:
plot(x.acf, data = x)
plot(x.pacf, data = x)

## use 90% limits:
plot(x.acf, data = x, interval = 0.90)

acfWnTest(x.acf, x = x, nlags = c(5,10,20))
nvarOfAcfKP(x, maxlag = 20)
whiteNoiseTest(x.acf, h0 = "arch-type", x = x, nlags = c(5,10,20))
</code></pre>

<hr>
<h2 id='acfIidTest'>Carry out IID tests using sample autocorrelations</h2><span id='topic+acfIidTest'></span><span id='topic+acfIidTest-methods'></span><span id='topic+acfIidTest+2CANY-method'></span><span id='topic+acfIidTest+2Cmissing-method'></span><span id='topic+acfIidTest+2CSampleAutocorrelations-method'></span>

<h3>Description</h3>

<p>Carry out tests for IID from sample autocorrelations.</p>


<h3>Usage</h3>

<pre><code class='language-R'>acfIidTest(acf, n, npar = 0, nlags = npar + 1,
           method = c("LiMcLeod", "LjungBox", "BoxPierce"),
           interval = 0.95, expandCI = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="acfIidTest_+3A_acf">acf</code></td>
<td>
<p>autocorrelations.</p>
</td></tr>
<tr><td><code id="acfIidTest_+3A_n">n</code></td>
<td>
<p>length of the corresponding time series.</p>
</td></tr>
<tr><td><code id="acfIidTest_+3A_npar">npar</code></td>
<td>
<p>number of df to subtract.</p>
</td></tr>
<tr><td><code id="acfIidTest_+3A_nlags">nlags</code></td>
<td>

<p>number of autocorrelations to use for the portmonteau
statistic, can be a vector to request several such statistics.
</p>
</td></tr>
<tr><td><code id="acfIidTest_+3A_method">method</code></td>
<td>

<p>a character string, one of &quot;LiMcLeod&quot;, &quot;LjungBox&quot; or &quot;BoxPierce&quot;.
</p>
</td></tr>
<tr><td><code id="acfIidTest_+3A_interval">interval</code></td>
<td>

<p>a number or NULL.
</p>
</td></tr>
<tr><td><code id="acfIidTest_+3A_expandci">expandCI</code></td>
<td>

<p>logical flag, if <code>TRUE</code> return a CI for each lag up to
<code>max(nlags)</code>. Used only if CI's are requested.
</p>
</td></tr>
<tr><td><code id="acfIidTest_+3A_...">...</code></td>
<td>

<p>additional arguments passed on to methods. In particular, some
methods have argument <code>x</code> for the time series.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs one of several tests for IID based on sample
autocorrelations. A correction of the degrees of freedom
for residuals from fitted models can be specified with argument
<code>npar</code>. <code>nlags</code> specifies the number of autocorrelations to
use in the test, it can be a vector to request several tests.
</p>
<p>The results of the test are gathered in a matrix with one row for each
element of <code>nlags</code>. The test statistic is in column &quot;ChiSq&quot;,
degrees of freedom in &quot;DF&quot; and the p-value in &quot;pvalue&quot;. The method is
in attribute &quot;method&quot;.
</p>
<p>If <code>interval</code> is not <code>NULL</code> confidence intervals for the
autocorrelations are computed, under the null hypothesis of
independence. The coverage probability (or probabilities) is
speciified by <code>interval</code>.
</p>
<p>If argument <code>expandCI</code> is <code>TRUE</code>, there is one row
for each lag, up to <code>max(nlags)</code>. It is best to use this feature
with a single coverage probability.
</p>
<p>If <code>expandCI</code> to <code>FALSE</code> the confidence intervals are put in
a matrix with one row for each coverage probability.
</p>


<h3>Value</h3>

<p>a list with components &quot;test&quot; and (if requested) &quot;ci&quot;, as described in
Details
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(acf = "ANY")</code></dt><dd>
<p>In this method <code>acf</code> contains the autocorrelations.
</p>
</dd>
<dt><code>signature(acf = "missing")</code></dt><dd>
<p>The autocorrelations are computed from argument <code>x</code> (the time series).
</p>
</dd>
<dt><code>signature(acf = "SampleAutocorrelations")</code></dt><dd>
<p>This is a convenience method in which argument <code>n</code> is taken from
<code>acf</code> and thus does not need to be specified by the user.
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>Li WK (2004).
<em>Diagnostic checks in time series</em>.
Chapman &amp; Hall/CRC Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+whiteNoiseTest">whiteNoiseTest</a></code>,
<code><a href="#topic+acfGarchTest">acfGarchTest</a></code>,
<code><a href="#topic+acfMaTest">acfMaTest</a></code>;
</p>
<p><code><a href="#topic+plot-methods">plot-methods</a></code> for graphical representations of results
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
ts1 &lt;- rnorm(100)

a1 &lt;- drop(acf(ts1)$acf)
acfIidTest(a1, n = 100, nlags = c(5, 10, 20))
acfIidTest(a1, n = 100, nlags = c(5, 10, 20), method = "LjungBox")
acfIidTest(a1, n = 100, nlags = c(5, 10, 20), interval = NULL)
acfIidTest(a1, n = 100, method = "LjungBox", interval = c(0.95, 0.90), expandCI = FALSE)


## acfIidTest() is called behind the scenes by methods for autocorrelation objects
ts1_acrf &lt;- autocorrelations(ts1)
class(ts1_acrf)  # "SampleAutocorrelations"
whiteNoiseTest(ts1_acrf, h0 = "iid", nlags = c(5,10,20), method = "LiMcLeod")
plot(ts1_acrf)

## use 10% level of significance in the plot:
plot(ts1_acrf, interval = 0.9)
</code></pre>

<hr>
<h2 id='acfMaTest'>Autocorrelation test for MA(q)</h2><span id='topic+acfMaTest'></span>

<h3>Description</h3>

<p>Carry out autocorrelation test for MA(q).</p>


<h3>Usage</h3>

<pre><code class='language-R'>acfMaTest(acf, ma, n, nlags, interval = 0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="acfMaTest_+3A_acf">acf</code></td>
<td>
<p>autocorrelations.</p>
</td></tr>
<tr><td><code id="acfMaTest_+3A_ma">ma</code></td>
<td>
<p>a positive integer, the moving average order.</p>
</td></tr>
<tr><td><code id="acfMaTest_+3A_n">n</code></td>
<td>
<p>length of the corresponding time series.</p>
</td></tr>
<tr><td><code id="acfMaTest_+3A_nlags">nlags</code></td>
<td>

<p>number of autocorrelations to use for the portmonteau
statistic, can be a vector to request several such statistics.
</p>
</td></tr>
<tr><td><code id="acfMaTest_+3A_interval">interval</code></td>
<td>

<p>a number or NULL.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>acfMaTest</code> performs a test that the time series is MA(<code>ma</code>), 
under the classical assumptions of Bartlett's formulas.
</p>
<p>When intervals are requested, they are confidence intervals for lags from 1 to
<code>ma</code>.  For lags greater than the moving average order, <code>ma</code>,
autocorrelations outside them suggest to reject the null hypothesis that the
process is MA(<code>ma</code>).
</p>


<h3>Value</h3>

<p>a list with components &quot;test&quot; and (if requested) &quot;ci&quot;
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+whiteNoiseTest">whiteNoiseTest</a></code>,
<code><a href="#topic+acfIidTest">acfIidTest</a></code>
<code><a href="#topic+acfGarchTest">acfGarchTest</a></code>
</p>

<hr>
<h2 id='ar2Pacf'>Convert AR parameters to parcor</h2><span id='topic+ar2Pacf'></span>

<h3>Description</h3>

<p>Convert AR parameters to parcor.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ar2Pacf(phi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ar2Pacf_+3A_phi">phi</code></td>
<td>

<p>numeric, the AR parameters. <code>numeric(0)</code> stands for AR(0).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is internal for now, could be exported under a better name.
</p>


<h3>Value</h3>

<p>numeric, the parcor coefficients
(but if <code>length(phi) &lt;= 1</code>, phi is returned as is)
</p>

<hr>
<h2 id='arma_Q0Gardner'>Computing the initial state covariance matrix of ARMA</h2><span id='topic+arma_Q0Gardner'></span><span id='topic+arma_Q0bis'></span><span id='topic+arma_Q0naive'></span><span id='topic+arma_Q0gnbR'></span>

<h3>Description</h3>

<p>Wrappers for the internals 'stats' functions used by arima()
to compute the initial state covariance matrix of ARMA models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>

arma_Q0naive(phi, theta, tol = .Machine$double.eps)

arma_Q0gnbR(phi, theta, tol = .Machine$double.eps)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arma_Q0Gardner_+3A_phi">phi</code></td>
<td>
<p>autoregressive coefficients.</p>
</td></tr>
<tr><td><code id="arma_Q0Gardner_+3A_theta">theta</code></td>
<td>
<p>moving average coefficients.</p>
</td></tr>
<tr><td><code id="arma_Q0Gardner_+3A_tol">tol</code></td>
<td>
<p>tollerance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>arima()</code> uses one of two methods to compute the initial state
covariance matrix of a stationary ARMA model. Both methods are
implemented by internal non-exported C functions.
<code>arma_Q0Gardner()</code> and <code>arma_Q0bis</code> are simple <span class="rlang"><b>R</b></span> wrappers
for those functions. They are defined in the tests (<strong>TODO:</strong> put
in the examples?) bit are not defined in the namespace of the package
since they use unexported functions. 
</p>
<p><code>arma_Q0Gardner()</code> implements the original method from Gardner et
al (1980). <code>arma_Q0bis()</code> is a more recent method that deals
better with roots very close to the unit circle.
</p>
<p>These functions can be useful for comparative testing.  They cannot be
put in package 'sarima' since they use <code>`:::`</code> operator and are
hence inadmissible to CRAN.
</p>


<h3>Value</h3>

<p>a matrix
</p>


<h3>References</h3>

<p>Gardner G, Harvey AC, Phillips GDA (1980).
&ldquo;Algorithm AS154. An algorithm for exact maximum likelihood estimation of autoregressive-moving average models by means of Kalman filtering.&rdquo;
<em>Applied Statistics</em>, 311&ndash;322.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## arma_Q0Gardner(phi, theta, tol = .Machine$double.eps)
## arma_Q0bis(phi, theta, tol = .Machine$double.eps)
</code></pre>

<hr>
<h2 id='arma_Q0gnb'>Compute the initial state covariance of ARMA model</h2><span id='topic+arma_Q0gnb'></span>

<h3>Description</h3>

<p>Compute the initial state covariance of ARMA model</p>


<h3>Usage</h3>

<pre><code class='language-R'>arma_Q0gnb(phi, theta, tol = 2.220446e-16)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arma_Q0gnb_+3A_phi">phi</code></td>
<td>
<p>autoregression parameters.</p>
</td></tr>
<tr><td><code id="arma_Q0gnb_+3A_theta">theta</code></td>
<td>
<p>moving average parameters.</p>
</td></tr>
<tr><td><code id="arma_Q0gnb_+3A_tol">tol</code></td>
<td>
<p>tollerance. (TODO: explain)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Experimental computation of the initial state covariance matrix of
ARMA models.
</p>
<p>The numerical results are comparable to
<code>SSinit = "Rossignol2011"</code> method in <code><a href="stats.html#topic+arima">arima</a></code> and
related functions.
The method seems about twice faster than &quot;Rossignol2011&quot; on the models
I tried but I haven't done systematic tests. 
</p>
<p>See section &lsquo;examples&rsquo; below and, for more tests based on the
tests from <span class="pkg">stats</span>, the tests in
<code style="white-space: pre;">&#8288;test/testthat/test-arma-q0.R&#8288;</code>.
</p>


<h3>Value</h3>

<p>a matrix
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>Gardner G, Harvey AC, Phillips GDA (1980).
&ldquo;Algorithm AS154. An algorithm for exact maximum likelihood estimation of autoregressive-moving average models by means of Kalman filtering.&rdquo;
<em>Applied Statistics</em>, 311&ndash;322.
</p>
<p>R bug report PR#14682 (2011-2013)
&lt;URL: https://bugs.r-project.org/bugzilla3/show_bug.cgi?id=14682&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+makeARIMA">makeARIMA</a></code>, 
<code><a href="stats.html#topic+arima">arima</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Q0a &lt;- arma_Q0gnb(c(0.2, 0.5), c(0.3)) 
Q0b &lt;- makeARIMA(c(0.2, 0.5), c(0.3), Delta = numeric(0))$Pn
all.equal(Q0a, Q0b) ## TRUE

## see test/testthat/test-arma-q0.R for more;
## these functions cannot be defined in the package due to their use of
## \code{:::} on exported base R functions.
##
## "Gardner1980"
arma_Q0Gardner &lt;- function(phi, theta, tol = .Machine$double.eps){
    ## tol is not used here
    .Call(stats:::C_getQ0, phi, theta)
}
## "Rossignol2011"
arma_Q0bis &lt;- function(phi, theta, tol = .Machine$double.eps){
    .Call(stats:::C_getQ0bis, phi, theta, tol)
}

arma_Q0Gardner(c(0.2, 0.5), c(0.3))
arma_Q0bis(c(0.2, 0.5), c(0.3)) 
Q0a
Q0b
</code></pre>

<hr>
<h2 id='armaccf_xe'>Crosscovariances between an ARMA process and its innovations</h2><span id='topic+armaccf_xe'></span><span id='topic+armaacf'></span>

<h3>Description</h3>

<p>Compute autocovariances of ARMA models and crosscovariances between an
ARMA process and its innovations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>armaccf_xe(model, lag.max = 1)
armaacf(model, lag.max, compare)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="armaccf_xe_+3A_model">model</code></td>
<td>

<p>the model, a list with components <code>ar</code>, <code>ma</code> and
<code>sigma2</code> (for the time being, <code>sigmasq</code> is also accepted,
if <code>model$sigma2</code> is NULL).
</p>
</td></tr>
<tr><td><code id="armaccf_xe_+3A_lag.max">lag.max</code></td>
<td>
<p>maximal lag for the result.</p>
</td></tr>
<tr><td><code id="armaccf_xe_+3A_compare">compare</code></td>
<td>

<p>if <code>TRUE</code> compute the autocovariances also using
<code>tacvfARMA()</code> and return both results for comparison.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a causal ARMA model, <code>armaccf_xe</code> computes theoretical
crosscovariances <code class="reqn">R_{xe}(0)</code>, <code class="reqn">R_{xe}(1)</code>,
<code class="reqn">R_{xe}(lag.max)</code>, where <code class="reqn">R_{xe}(k)=E(X_{t}e_{t-k})</code>, between
an ARMA process and its innovations. Negative lags are not considered
since <code class="reqn">R_{xe}(k)=0</code> for <code class="reqn">k&lt;0</code>. The moving average polynomial
may have roots on the unit circle.
</p>
<p>This is a simple illustration of the equations I give in my time
series courses.
</p>
<p><code>armaacf</code> computes ARMA autocovariances. The default method
computes computes the zero lag autocovariance using
<code>armaccf_xe()</code> and multiplies the autocorrelations obtained from
<code>ARMAacf</code> (which computes autocorrelations, not
autocovariances). If <code>compare = TRUE</code> it also uses
<code>tacvfARMA</code> from package <span class="pkg">ltsa</span> and returns both results in a
matrix for comparison. The matrix has columns <code>"native"</code>,
<code>"tacvfARMA"</code> and <code>"difference"</code>, where the last column
contains the (zapped) differences between the autocorrelations
obtained by the two methods.
</p>
<p>The ARMA parameters in argument <code>model</code> follow the
Brockwell-Davis convention for the signs. Since <code>tacvfARMA()</code>
uses the Box-Jenkins convention for the signs, the moving average
parameters are negated for calls to <code>tacvfARMA()</code>.
</p>


<h3>Value</h3>

<p>for <code>armaccf_xe</code>, the crosscovariances for lags 0, ..., maxlag.
</p>
<p>for <code>armaacf</code>, the autocovariances, see Details.
</p>


<h3>Note</h3>

<p><code>armaacf</code> is useful for exploratory computations but
<code><a href="#topic+autocovariances">autocovariances</a></code> is more convenient and eliminates the
need to know function names for particular cases.


</p>





<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>McLeod AI, Yu H, Krougly Z (2007).
&ldquo;Algorithms for Linear Time Series Analysis: With R Package.&rdquo;
<em>Journal of Statistical Software</em>, <b>23</b>(5).
<a href="https://doi.org/10.18637/jss.v023.i05">doi:10.18637/jss.v023.i05</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1 from ?ltsa::tacvfARMA
z &lt;- sqrt(sunspot.year)
n &lt;- length(z)
p &lt;- 9
q &lt;- 0
ML &lt;- 5
out &lt;- arima(z, order = c(p, 0, q))

phi &lt;- theta &lt;- numeric(0)
if (p &gt; 0) phi &lt;- coef(out)[1:p]
if (q &gt; 0) theta &lt;- coef(out)[(p+1):(p+q)]
zm &lt;- coef(out)[p+q+1]
sigma2 &lt;- out$sigma2

armaacf(list(ar = phi, ma = theta, sigma2 = sigma2), lag.max = 20)
## this illustrates that the methods
## based on ARMAacf and tacvARMA are equivalent:
armaacf(list(ar = phi, ma = theta, sigma2 = sigma2), lag.max = 20, compare = TRUE)

## In the original example in ?ltsa::tacvfARMA
## the comparison is with var(z), not with the theoretical variance:
rA &lt;- ltsa::tacvfARMA(phi, - theta, maxLag=n+ML-1, sigma2=sigma2)
rB &lt;- var(z) * ARMAacf(ar=phi, ma=theta, lag.max=n+ML-1)
## so rA and rB are different.
## but the difference is due to the variance:
rB2 &lt;- rA[1] * ARMAacf(ar=phi, ma=theta, lag.max=n+ML-1)
cbind(rA[1:5], rB[1:5], rB2[1:5])

## There is no need to use specific functions,
## autocovariances() is most convenient for routine use:
armalist &lt;- list(ar = phi, ma = theta, sigma2 = sigma2)
autocovariances(armalist, maxlag = 10)

## even better, set up an ARMA model:
mo &lt;- new("ArmaModel", ar = phi, ma = theta, sigma2 = sigma2)
autocovariances(mo, maxlag = 10)
</code></pre>

<hr>
<h2 id='ArmaModel'>Create ARMA objects</h2><span id='topic+ArmaModel'></span><span id='topic+ArModel'></span><span id='topic+MaModel'></span>

<h3>Description</h3>

<p>Create ARMA objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ArmaModel(...)
ArModel(...)
MaModel(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ArmaModel_+3A_...">...</code></td>
<td>
<p>the arguments are passed to <code>new()</code>. Typical
arguments are <code>ar</code>, <code>ma</code> and <code>mean</code>. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object representing an ARMA, AR or MA model
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+ArmaModel-class">ArmaModel</a></code>,
<code><a href="#topic+ArModel-class">ArModel</a></code>,
<code><a href="#topic+MaModel-class">MaModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## MA
( ma2a1 &lt;- MaModel(ma = c(0.3, 0.7), sigma2 = 1) )
autocorrelations(ma2a1, maxlag = 6)
partialAutocorrelations(ma2a1, maxlag = 6)
autocovariances(ma2a1, maxlag = 6)
partialVariances(ma2a1, maxlag = 6)

## sigma2 is set to NA if not specified
## but things that don't depend on it are computed:
( ma2a2 &lt;- MaModel(ma = c(0.3, 0.7)) )
autocorrelations(ma2a2, maxlag = 6)
partialAutocorrelations(ma2a2, maxlag = 6)

## AR
( ar2a1 &lt;- ArModel(ar = c(-0.3, -0.7), sigma2 = 1) )
autocorrelations(ar2a1, maxlag = 6)
partialAutocorrelations(ar2a1, maxlag = 6)
autocovariances(ar2a1, maxlag = 6)
partialVariances(ar2a1, maxlag = 6)

## ARMA
( arma2a1 &lt;- ArmaModel(ar = 0.5, ma = c(0.3, 0.7), sigma2 = 1) )
autocorrelations(arma2a1, maxlag = 6)
partialAutocorrelations(arma2a1, maxlag = 6)


## modelCoef() returns a list with components 'ar' and 'ma'
modelCoef(arma2a1)
modelCoef(ma2a1)
modelCoef(ar2a1)

## modelOrder() returns a list with components 'ar' and 'ma'
modelOrder(arma2a1)
modelOrder(ma2a1)
modelOrder(ar2a1)

as(ma2a1, "ArmaModel")  # success, as expected
as(ar2a1, "ArModel")  # success, as expected
as(ArmaModel(ar = c(-0.3, -0.7)), "ArModel")
## But these fail:
## as(ma2a1, "ArModel") # fails
## as(arma2a1, "ArModel") # fails
## as(arma2a1, "MaModel") # fails

</code></pre>

<hr>
<h2 id='ArmaModel-class'>Classes ArmaModel, ArModel and MaModel in package sarima</h2><span id='topic+ArmaModel-class'></span><span id='topic+ArModel-class'></span><span id='topic+MaModel-class'></span>

<h3>Description</h3>

<p>Classes ArmaModel, ArModel and MaModel in package sarima.</p>


<h3>Objects from the Class</h3>

<p>Classes <code>"ArModel"</code> and <code>"MaModel"</code> are subclasses of
<code>"ArmaModel"</code> with the corresponding order always zero.
</p>
<p>The recommended way to create objects from these classes is with the
functions <code><a href="#topic+ArmaModel">ArmaModel</a></code>, <code><a href="#topic+ArModel">ArModel</a></code> and
<code><a href="#topic+MaModel">MaModel</a></code>. Objects can also be created by calls of the
form <code>new("ArmaModel", ..., ar, ma, mean, check)</code>.  See also
<code><a href="#topic+coerce-methods">coerce-methods</a></code> for further ways to create objects from
these classes.
</p>


<h3>Slots</h3>


<dl>
<dt><code>center</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>intercept</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>sigma2</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>ar</code>:</dt><dd><p>Object of class <code>"BJFilter"</code> ~~ </p>
</dd>
<dt><code>ma</code>:</dt><dd><p>Object of class <code>"SPFilter"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+ArmaSpec-class">ArmaSpec</a>"</code>, directly.
Class <code>"<a href="#topic+VirtualArmaModel-class">VirtualArmaModel</a>"</code>, directly.
Class <code>"<a href="#topic+ArmaFilter-class">ArmaFilter</a>"</code>, by class &quot;ArmaSpec&quot;, distance 2.
Class <code>"<a href="#topic+VirtualFilterModel-class">VirtualFilterModel</a>"</code>, by class &quot;VirtualArmaModel&quot;, distance 2.
Class <code>"<a href="#topic+VirtualStationaryModel-class">VirtualStationaryModel</a>"</code>, by class &quot;VirtualArmaModel&quot;, distance 2.
Class <code>"<a href="#topic+VirtualArmaFilter-class">VirtualArmaFilter</a>"</code>, by class &quot;ArmaSpec&quot;, distance 3.
Class <code>"<a href="#topic+VirtualAutocovarianceModel-class">VirtualAutocovarianceModel</a>"</code>, by class &quot;VirtualArmaModel&quot;, distance 3.
Class <code>"<a href="#topic+VirtualMeanModel-class">VirtualMeanModel</a>"</code>, by class &quot;VirtualArmaModel&quot;, distance 3.
Class <code>"<a href="#topic+VirtualMonicFilter-class">VirtualMonicFilter</a>"</code>, by class &quot;ArmaSpec&quot;, distance 4.
</p>


<h3>Methods</h3>


<dl>
<dt>modelOrder</dt><dd><p><code>signature(object = "ArmaModel", convention = "ArFilter")</code>: ... </p>
</dd>
<dt>modelOrder</dt><dd><p><code>signature(object = "ArmaModel", convention = "MaFilter")</code>: ... </p>
</dd>
<dt>modelOrder</dt><dd><p><code>signature(object = "ArmaModel", convention = "missing")</code>: ... </p>
</dd>
<dt>modelOrder</dt><dd><p><code>signature(object = "SarimaModel", convention = "ArmaModel")</code>: ... </p>
</dd>
<dt>sigmaSq</dt><dd><p><code>signature(object = "ArmaModel")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+ArmaModel">ArmaModel</a></code>, <code><a href="#topic+ArModel">ArModel</a></code>, <code><a href="#topic+MaModel">MaModel</a></code>, 
<code><a href="#topic+coerce-methods">coerce-methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>arma1p1 &lt;- new("ArmaModel", ar = 0.5, ma = 0.9, sigma2 = 1)
autocovariances(arma1p1, maxlag = 10)
autocorrelations(arma1p1, maxlag = 10)
partialAutocorrelations(arma1p1, maxlag = 10)
partialAutocovariances(arma1p1, maxlag = 10)

new("ArmaModel", ar = 0.5, ma = 0.9, intercept = 4)
new("ArmaModel", ar = 0.5, ma = 0.9, center = 1.23)

new("ArModel", ar = 0.5,  center = 1.23)
new("MaModel", ma = 0.9,  center = 1.23)

# argument 'mean' is an alias for 'center':
new("ArmaModel", ar = 0.5, ma = 0.9, mean = 1.23)

##  both center and intercept may be given
## (the mean is not equal to the intercept in this case)
new("ArmaModel", ar = 0.5, ma = 0.9, center = 1.23, intercept = 2)

## Don't use 'mean' together with 'center' and/or 'intercept'.
##    new("ArmaModel", ar = 0.5, ma = 0.9, center = 1.23, mean  = 4)
##    new("ArmaModel", ar = 0.5, ma = 0.9, intercept = 2, mean  = 4)
## Both give error message:
##   Use argument 'mean' only when 'center' and 'intercept' are missing or zero
</code></pre>

<hr>
<h2 id='ArmaSpectrum-class'>Class <code>"ArmaSpectrum"</code></h2><span id='topic+ArmaSpectrum-class'></span><span id='topic+plot+2CArmaSpectrum+2CANY-method'></span><span id='topic+show+2CArmaSpectrum-method'></span><span id='topic+plot.ArmaSpectrum'></span><span id='topic+print.ArmaSpectrum'></span>

<h3>Description</h3>

<p>Objects from class <code>"ArmaSpectrum"</code> spectra computed by
<code><a href="#topic+spectrum">spectrum</a></code>. 
</p>


<h3>Details</h3>

<p>The methods for <code>show</code>, <code>print</code> and <code>plot</code> work
analogously to those for class <code>"<a href="#topic+Spectrum-class">Spectrum</a>"</code> (which
is a super class of <code>"ArmaSpectrum"</code>). In addition, <code>print</code>
and <code>show</code> print also the parameters of the ARMA model.
</p>


<h3>Objects from the Class</h3>

<p>Objects contain spectra produced by <code>sarima::spectrum</code>
(recommended), see <code><a href="#topic+spectrum">spectrum</a></code> for details.
</p>
<p>Objects can also be created by calls of the form
<code>new("ArmaSpectrum", ar = , ma = , sigma2 = , ...)</code>,
where <code>ar</code> and <code>ma</code> are numeric vectors and <code>sigma2</code> is
a number. <code>sigma2</code> may be omitted but then only normalized
spectra can be computed. There further possibilities for the arguments
but they should be considered internal and subject to change.
</p>


<h3>Slots</h3>

<p>All slots are inherited from class <code>"Spectrum"</code>.
</p>

<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"function"</code>.</p>
</dd>
<dt><code>call</code>:</dt><dd><p>Object of class <code>"call"</code>.</p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"ANY"</code>.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "ArmaSpectrum")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p>class <code>"<a href="#topic+Spectrum-class">Spectrum</a>"</code> for further details,
</p>
<p><code><a href="#topic+spectrum">spectrum</a></code> for further examples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## spectral density of the stationary part of a fitted 'airline model'
fit0 &lt;- arima(AirPassengers, order = c(0,1,1),
              seasonal = list(order = c(0,1,1), period = 12))
sd.air &lt;- spectrum(fit0)
show(sd.air)
plot(sd.air, log = "y") # plot log of the spectral density

## use the "ArmaSpectrum" object as a function to evaluate the sp. density:
sd.air(seq(0, 0.5, length.out = 13))
sd.air(seq(0, 0.5, length.out = 13), standardize = FALSE)

## white noise (constant spectral density)
sp.wn &lt;- spectrum(ArmaModel(sigma2 = 2))
sp.wn
print(sp.wn)
print(sp.wn, standardize=FALSE)
show(sp.wn)
</code></pre>

<hr>
<h2 id='as.SarimaModel'>Convert S3 model objects to class SarimaModel</h2><span id='topic+as.SarimaModel'></span><span id='topic+as.SarimaModel.Arima'></span>

<h3>Description</h3>

<p>Convert S3 model objects to class SarimaModel.</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.SarimaModel(x, ...)

## S3 method for class 'Arima'
as.SarimaModel(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.SarimaModel_+3A_x">x</code></td>
<td>
<p>an objects from a class representing Seasonal ARIMA models.</p>
</td></tr>
<tr><td><code id="as.SarimaModel_+3A_...">...</code></td>
<td>
<p>further arguments for methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be useful when one needs to manipulate the
components of SARIMA models.
</p>
<p>The method for class <code>Arima</code> (objects generated by <code>stats::arima()</code>)
extracts the model information and convert it to <code>"SarimaModel"</code>.
</p>
<p>For S4 classes, there are methods for <code>as()</code>, where
suitable. <code><a href="#topic+modelCoef">modelCoef</a></code> provides a more powerful conversion
mechanism.
</p>


<h3>Value</h3>

<p>an object from class <code>"SarimaModel"</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SarimaModel-class">SarimaModel</a></code>
</p>

<hr>
<h2 id='autocorrelations'>Compute autocorrelations and related quantities</h2><span id='topic+autocorrelations'></span><span id='topic+autocovariances'></span><span id='topic+partialAutocorrelations'></span><span id='topic+partialAutocovariances'></span><span id='topic+partialCoefficients'></span><span id='topic+partialVariances'></span><span id='topic+backwardPartialCoefficients'></span><span id='topic+backwardPartialVariances'></span>

<h3>Description</h3>

<p>Generic functions for computation of autocorrelations,
autocovariances and related quantities. The idea is to free the user
from the need to look for specific functions that compute the desired
property for their object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autocovariances(x, maxlag, ...)

autocorrelations(x, maxlag, lag_0, ...)

partialAutocorrelations(x, maxlag, lag_0 = TRUE, ...)

partialAutocovariances(x, maxlag, ...)

partialVariances(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autocorrelations_+3A_x">x</code></td>
<td>

<p>an object for which the requested property makes sense.
</p>
</td></tr>
<tr><td><code id="autocorrelations_+3A_maxlag">maxlag</code></td>
<td>
<p>the maximal lag to include in the result.</p>
</td></tr>
<tr><td><code id="autocorrelations_+3A_lag_0">lag_0</code></td>
<td>
<p>if TRUE include lag zero.</p>
</td></tr>
<tr><td><code id="autocorrelations_+3A_...">...</code></td>
<td>
<p>further arguments for methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>autocorrelations</code> is a generic function for computation of
autocorrelations.  It deduces the appropriate type of autocorrelation
from the class of the object.  For example, for models it computes
theoretical autocorrelations, while for time series it computes sample
autocorrelations.
</p>
<p>The other functions described are similar for other second order
properties of <code>x</code>.
</p>
<p>These functions return objects from suitable classes, all inheriting
from <code>"Lagged"</code>. The latter means that indexing starts from zero,
so the value for lag zero is accessed by <code>r[0]</code>). Subscripting
always returns the underlying data unclassed (i.e. ordinary vectors or
arrays). In particular, <code>"[]"</code> extracts the underlying data.
</p>
<p>Functions computing autocorrelations and partial autocorrelations have
argument <code>lag_0</code> &mdash; if it is set to <code>FALSE</code>, the value for
lag zero is dropped from the result and the returned object is an
ordinary vector or array, as appropriate.
</p>
<p>See the individual methods for the format of the result and further
details.
</p>
<p>There are plot methods for sample autocorrelations and sample partial
autocorrelations with overlaid significance limits under null
hypotheses for independence or weak white noise, see
<code><a href="#topic+plot-methods">plot-methods</a></code> and the examples there. More details can be
found in the vignettes, see section &lsquo;See also&rsquo; below. 
</p>


<h3>Value</h3>

<p>an object from a class suitable for the requested property and <code>x</code>
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot-methods">plot-methods</a></code> for plotting with significance limits
computed under strong white noise and weak white noise hypotheses;
</p>
<p><code><a href="#topic+autocorrelations-methods">autocorrelations-methods</a></code>,
<code><a href="#topic+partialAutocorrelations-methods">partialAutocorrelations-methods</a></code>
for details on individual methods;
</p>
<p><code>vignette("white_noise_tests", package = "sarima")</code> and <br />
<code>vignette("garch_tests_example", package = "sarima")</code> for
extensive worked examples.
</p>
<p><code><a href="#topic+armaccf_xe">armaccf_xe</a></code>,
<code><a href="#topic+armaacf">armaacf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
v1 &lt;- rnorm(100)
autocorrelations(v1)
v1.acf &lt;- autocorrelations(v1, maxlag = 10)

v1.acf[1:10] # drop lag zero value (and the class)
autocorrelations(v1, maxlag = 10, lag_0 = FALSE) # same

partialAutocorrelations(v1)
partialAutocorrelations(v1, maxlag = 10)

## compute 2nd order properties from raw data
autocovariances(v1)
autocovariances(v1, maxlag = 10)
partialAutocovariances(v1, maxlag = 6)
partialAutocovariances(v1)
partialVariances(v1, maxlag = 6)
pv1 &lt;- partialVariances(v1)

## compute 2nd order properties from raw data
autocovariances(AirPassengers, maxlag = 6)
autocorrelations(AirPassengers, maxlag = 6)
partialAutocorrelations(AirPassengers, maxlag = 6)
partialAutocovariances(AirPassengers, maxlag = 6)
partialVariances(AirPassengers, maxlag = 6)

acv &lt;- autocovariances(AirPassengers, maxlag = 6)
autocovariances(acv) # no-op
autocovariances(acv, maxlag = 4) # trim the available lags

## compute 2nd order properties from sample autocovariances
acr &lt;- autocorrelations(acv)
acr
partialAutocorrelations(acv)
partialAutocovariances(acv)
partialVariances(acv)

## compute 2nd order properties from sample autocorrelations
acr
partialAutocorrelations(acr)

## These cannot be computed, since the variance is needed but unknown:
##     autocovariances(acr)
##     partialAutocovariances(acr)
##     partialVariances(acr)

## to treat autocorrelations as autocovariances, 
## convert them to autocovariances explicitly:
as(acr, "Autocovariances")
as(acr, "SampleAutocovariances")

partialVariances(as(acr, "Autocovariances"))
partialVariances(as(acr, "SampleAutocovariances"))
</code></pre>

<hr>
<h2 id='autocorrelations-methods'>Methods for function autocorrelations()</h2><span id='topic+autocorrelations-methods'></span><span id='topic+autocorrelations+2CANY+2CANY+2CANY-method'></span><span id='topic+autocorrelations+2CANY+2CANY+2Cmissing-method'></span><span id='topic+autocorrelations+2CAutocorrelations+2CANY+2Cmissing-method'></span><span id='topic+autocorrelations+2CAutocorrelations+2Cmissing+2Cmissing-method'></span><span id='topic+autocorrelations+2CAutocovariances+2CANY+2Cmissing-method'></span><span id='topic+autocorrelations+2CPartialAutocorrelations+2CANY+2Cmissing-method'></span><span id='topic+autocorrelations+2CPartialAutocovariances+2CANY+2Cmissing-method'></span><span id='topic+autocorrelations+2CSamplePartialAutocorrelations+2CANY+2Cmissing-method'></span><span id='topic+autocorrelations+2CSamplePartialAutocovariances+2CANY+2Cmissing-method'></span><span id='topic+autocorrelations+2CVirtualArmaModel+2CANY+2Cmissing-method'></span><span id='topic+autocorrelations+2CVirtualSarimaModel+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Methods for function autocorrelations().</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "ANY", maxlag = "ANY", lag_0 = "ANY")</code></dt><dd>
</dd>
<dt><code>signature(x = "ANY", maxlag = "ANY", lag_0 = "missing")</code></dt><dd>
</dd>
<dt><code>signature(x = "Autocorrelations", maxlag = "ANY", lag_0 = "missing")</code></dt><dd>
</dd>
<dt><code>signature(x = "Autocorrelations", maxlag = "missing", lag_0 = "missing")</code></dt><dd>
</dd>
<dt><code>signature(x = "Autocovariances", maxlag = "ANY", lag_0 = "missing")</code></dt><dd>
</dd>
<dt><code>signature(x = "PartialAutocorrelations", maxlag = "ANY", lag_0 = "missing")</code></dt><dd>
</dd>
<dt><code>signature(x = "PartialAutocovariances", maxlag = "ANY", lag_0 = "missing")</code></dt><dd>
</dd>
<dt><code>signature(x = "SamplePartialAutocorrelations", maxlag = "ANY", lag_0 = "missing")</code></dt><dd>
</dd>
<dt><code>signature(x = "SamplePartialAutocovariances", maxlag = "ANY", lag_0 = "missing")</code></dt><dd>
</dd>
<dt><code>signature(x = "VirtualArmaModel", maxlag = "ANY", lag_0 = "missing")</code></dt><dd>

</dd><dt><code>signature(x = "VirtualSarimaModel", maxlag = "ANY", lag_0 = "missing")</code></dt><dd>

</dd></dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see the examples for ?autocorrelations
</code></pre>

<hr>
<h2 id='autocovariances-methods'>Methods for function autocovariances()</h2><span id='topic+autocovariances-methods'></span><span id='topic+autocovariances+2CANY+2CANY-method'></span><span id='topic+autocovariances+2CAutocovariances+2CANY-method'></span><span id='topic+autocovariances+2CAutocovariances+2Cmissing-method'></span><span id='topic+autocovariances+2CVirtualArmaModel+2CANY-method'></span><span id='topic+autocovariances+2CVirtualAutocovariances+2CANY-method'></span>

<h3>Description</h3>

<p>Methods for function autocovariances().</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "ANY", maxlag = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "Autocovariances", maxlag = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "Autocovariances", maxlag = "missing")</code></dt><dd>

</dd><dt><code>signature(x = "VirtualArmaModel", maxlag = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "VirtualAutocovariances", maxlag = "ANY")</code></dt><dd>

</dd></dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+autocorrelations">autocorrelations</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see the examples for ?autocorrelations
</code></pre>

<hr>
<h2 id='coerce-methods'>setAs methods in package sarima</h2><span id='topic+coerce-methods'></span><span id='topic+setAs'></span><span id='topic+coerce+2CANY+2CAutocorrelations-method'></span><span id='topic+coerce+2CANY+2CComboAutocorrelations-method'></span><span id='topic+coerce+2CANY+2CComboAutocovariances-method'></span><span id='topic+coerce+2CANY+2CPartialAutocorrelations-method'></span><span id='topic+coerce+2CANY+2CPartialAutocovariances-method'></span><span id='topic+coerce+2CANY+2CPartialVariances-method'></span><span id='topic+coerce+2CArmaSpec+2Clist-method'></span><span id='topic+coerce+2CAutocorrelations+2CComboAutocorrelations-method'></span><span id='topic+coerce+2CAutocorrelations+2CComboAutocovariances-method'></span><span id='topic+coerce+2CAutocovariances+2CComboAutocorrelations-method'></span><span id='topic+coerce+2CAutocovariances+2CComboAutocovariances-method'></span><span id='topic+coerce+2CBJFilter+2CSPFilter-method'></span><span id='topic+coerce+2Cnumeric+2CBJFilter-method'></span><span id='topic+coerce+2Cnumeric+2CSPFilter-method'></span><span id='topic+coerce+2CPartialVariances+2CAutocorrelations-method'></span><span id='topic+coerce+2CPartialVariances+2CAutocovariances-method'></span><span id='topic+coerce+2CPartialVariances+2CComboAutocorrelations-method'></span><span id='topic+coerce+2CPartialVariances+2CComboAutocovariances-method'></span><span id='topic+coerce+2CSarimaFilter+2CArmaFilter-method'></span><span id='topic+coerce+2CSarimaModel+2Clist-method'></span><span id='topic+coerce+2CSPFilter+2CBJFilter-method'></span><span id='topic+coerce+2Cvector+2CAutocorrelations-method'></span><span id='topic+coerce+2Cvector+2CAutocovariances-method'></span><span id='topic+coerce+2Cvector+2CPartialAutocorrelations-method'></span><span id='topic+coerce+2Cvector+2CPartialAutocovariances-method'></span><span id='topic+coerce+2CVirtualArmaFilter+2Clist-method'></span><span id='topic+coerce+2CVirtualSarimaModel+2CArmaModel-method'></span>

<h3>Description</h3>

<p>Methods for as() in package sarima.</p>


<h3>Methods</h3>

<p>This section shows the methods for converting objects from one class
to another, defined via <code>setAs()</code>. Use <code>as(obj, "classname")</code>
to convert object <code>obj</code> to class &quot;classname&quot;.
</p>

<dl>
<dt><code>signature(from = "ANY", to = "Autocorrelations")</code></dt><dd>
</dd>
<dt><code>signature(from = "ANY", to = "ComboAutocorrelations")</code></dt><dd>
</dd>
<dt><code>signature(from = "ANY", to = "ComboAutocovariances")</code></dt><dd>
</dd>
<dt><code>signature(from = "ANY", to = "PartialAutocorrelations")</code></dt><dd>
</dd>
<dt><code>signature(from = "ANY", to = "PartialAutocovariances")</code></dt><dd>
</dd>
<dt><code>signature(from = "ANY", to = "PartialVariances")</code></dt><dd>
</dd>
<dt><code>signature(from = "ArmaSpec", to = "list")</code></dt><dd>
</dd>
<dt><code>signature(from = "Autocorrelations", to = "ComboAutocorrelations")</code></dt><dd>
</dd>
<dt><code>signature(from = "Autocorrelations", to = "ComboAutocovariances")</code></dt><dd>
</dd>
<dt><code>signature(from = "Autocovariances", to = "ComboAutocorrelations")</code></dt><dd>
</dd>
<dt><code>signature(from = "Autocovariances", to = "ComboAutocovariances")</code></dt><dd>
</dd>
<dt><code>signature(from = "BJFilter", to = "SPFilter")</code></dt><dd>
</dd>
<dt><code>signature(from = "numeric", to = "BJFilter")</code></dt><dd>
<p>Convert a numeric vector to a BJFilter object.
This is a way to state that the coefficients follow the Box-Jenkins
convention for the signs, see the examples.
</p>
</dd>
<dt><code>signature(from = "numeric", to = "SPFilter")</code></dt><dd>
<p>Convert a numeric vector to an SPFilter object.  This is a way to
state that the coefficients follow the signal processing (SP)
convention for the signs, see the examples.
</p>
</dd>
<dt><code>signature(from = "PartialVariances", to = "Autocorrelations")</code></dt><dd>
</dd>
<dt><code>signature(from = "PartialVariances", to = "Autocovariances")</code></dt><dd>
</dd>
<dt><code>signature(from = "PartialVariances", to = "ComboAutocorrelations")</code></dt><dd>
</dd>
<dt><code>signature(from = "PartialVariances", to = "ComboAutocovariances")</code></dt><dd>
</dd>
<dt><code>signature(from = "SarimaFilter", to = "ArmaFilter")</code></dt><dd>
</dd>
<dt><code>signature(from = "SarimaModel", to = "list")</code></dt><dd>
</dd>
<dt><code>signature(from = "SPFilter", to = "BJFilter")</code></dt><dd>
</dd>
<dt><code>signature(from = "vector", to = "Autocorrelations")</code></dt><dd>
</dd>
<dt><code>signature(from = "vector", to = "Autocovariances")</code></dt><dd>
</dd>
<dt><code>signature(from = "vector", to = "PartialAutocorrelations")</code></dt><dd>
</dd>
<dt><code>signature(from = "vector", to = "PartialAutocovariances")</code></dt><dd>
</dd>
<dt><code>signature(from = "VirtualArmaFilter", to = "list")</code></dt><dd>
</dd>
<dt><code>signature(from = "VirtualSarimaModel", to = "ArmaModel")</code></dt><dd>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## the default for ARMA model is BJ for ar and SP for ma:
mo &lt;- new("ArmaModel", ar = 0.9, ma = 0.4, sigma2 = 1)
modelPoly(mo)

## here we declare explicitly that 0.4 uses the SP convention
##    (not necessary, the result is the same, but the intention is clear).
mo1 &lt;- new("ArmaModel", ar = 0.9, ma = as(0.4, "SPFilter"), sigma2 = 1)
modelPoly(mo1)
identical(mo, mo1) ## TRUE

## if the sign of theta follows the BJ convention, this can be stated unambiguously.
##   This creates the same model:
mo2 &lt;- new("ArmaModel", ar = 0.9, ma = as(-0.4, "BJFilter"), sigma2 = 1)
modelPoly(mo2)
identical(mo, mo2) ## TRUE

## And this gives the intended model whatever the default conventions:
ar3 &lt;- as(0.9, "BJFilter")
ma3 &lt;- as(-0.4, "BJFilter")
mo3 &lt;- new("ArmaModel", ar = ar3, ma = ma3, sigma2 = 1)
modelPoly(mo3)
identical(mo, mo3) ## TRUE

## The coefficients can be extracted in any particular form,
## e.g. to pass them to functions with specific requirements:
modelCoef(mo3) # coefficients of the model with the default (BD) sign convention
modelCoef(mo3, convention = "BD") # same result
modelCoef(mo3, convention = "SP") # signal processing convention


## for ltsa::tacvfARMA() the convention is BJ, so:
co &lt;- modelCoef(mo3, convention = "BJ") # Box-Jenkins convention

ltsa::tacvfARMA(co$ar, co$ma, maxLag = 6, sigma2 = 1)
autocovariances(mo3, maxlag = 6) ## same
</code></pre>

<hr>
<h2 id='confint'>
Confidence and acceptance intervals in package sarima
</h2><span id='topic+confint'></span><span id='topic+confint+2CSampleAutocorrelations-method'></span>

<h3>Description</h3>

<p>Compute confidence and acceptance intervals for sample
autocorrelations under assumptions chosen by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SampleAutocorrelations'
confint(object, parm, level = 0.95, se = FALSE, maxlag, ..., assuming)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint_+3A_object">object</code></td>
<td>

<p>an object containing sample autocorrelations (sacfs).
</p>
</td></tr>
<tr><td><code id="confint_+3A_parm">parm</code></td>
<td>
<p>which parameters to include, as for <code>stats::confint</code>.</p>
</td></tr>
<tr><td><code id="confint_+3A_level">level</code></td>
<td>
<p>coverage level, such as 0.95.</p>
</td></tr>
<tr><td><code id="confint_+3A_se">se</code></td>
<td>
<p>If <code>TRUE</code> return also standard errors.</p>
</td></tr>
<tr><td><code id="confint_+3A_assuming">assuming</code></td>
<td>

<p>under what assumptions to do the computations?
Currently can be <code>"iid"</code>, <code>"garch"</code>, a fitted model, or a
theoretical model, see Details.
</p>
</td></tr>
<tr><td><code id="confint_+3A_maxlag">maxlag</code></td>
<td>
<p>maximal lag to include</p>
</td></tr>
<tr><td><code id="confint_+3A_...">...</code></td>
<td>

<p>further arguments for <code>se</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For lags not fixed by the assumed model the computed intervals are
confidence intervals.
</p>
<p>The autocorrelations postulated by the null model (argument
<code>assuming</code>) are usually fixed for some lags. For such lags it
doesn't make sense to talk about confidence intervals.  We use the
term <em>acceptance interval</em> in this case since the sacfs for such
lags fall in the corresponding intervals with high probability if the
null model is correct.
</p>
<p>If <code>assuming</code> is <code>"iid"</code> (strong white noise), then all
autocorrelations in the null model are fixed (to zero) and the limits
of the resulting acceptance intervals are ethose from the familiar
plots produced by base-R's function <code><a href="stats.html#topic+acf">acf</a></code>.
</p>
<p>If <code>assuming</code> is a fitted MA(q) model, e.g. obtained from
<code>arima()</code>, then for lags <code class="reqn">1,\ldots,q</code> we get
confidence intervals, while for lags greater than <code class="reqn">q</code> the
intervals are acceptance intervals. 
</p>
<p>The autocorrelations of ARMA models with non-trivial autoregressive
part may also have structural patterns of zeroes (for example some
seasonal models), leading to acceptance intervals for such lags.
</p>
<p>If <code>assuming</code> specifies a theoretical (non-fitted) model, then
the autocorrelation function of the null model is completely fixed and
we get acceptance intervals for all lags.
</p>
<p>The return value is a matrix with one row for each requested lag,
containg the lag, lower bound, upper bound, estimate for acf(lag) and
the value of acf(lag) under H0 (if fixed) and <code>NA</code> if not fixed
under H0. The null model is stored as attribute <code>"assuming"</code>.
</p>
<p><strong>Note:</strong> When <code>assuming = "garch"</code> it is currently
necessary to submit the time series from which the autocorrelations
were computed as argument <code>x</code>.
</p>


<h3>Value</h3>

<p>a matrix as described in section &lsquo;Details&rsquo;;
</p>
<p>if <code>se = TRUE</code>, a column giving the standard errors of the sample
autocorrelations is appended. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+se">se</a></code>
</p>
<p><code>vignette("white_noise_tests", package = "sarima")</code>
</p>
<p><code>vignette("garch_tests_example", package = "sarima")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
v1 &lt;- arima.sim(n = 100, list(ma = c(0.8, 0.1), sd = 1))
v1.acf &lt;- autocorrelations(v1, maxlag = 10)

confint(v1.acf, parm = 1:4, assuming = "iid")
confint(v1.acf,  assuming = "iid", maxlag = 4) # same

## a fitted MA(2) - rho_1, rho_2 not fixed, the rest fixed
ma2fitted &lt;- arima(v1, order = c(0,0,2), include.mean=FALSE)
confint(v1.acf, assuming = ma2fitted, maxlag = 4)

## a theoretical MA(2) model, all acfs fixed under H0
ma2 &lt;- MaModel(ma = c(0.8, 0.1), sigma2 = 1)
confint(v1.acf, assuming = ma2, maxlag = 4)

# a weak white noise null
confint(v1.acf, assuming = "garch", maxlag = 4, x = v1)
</code></pre>

<hr>
<h2 id='filterCoef'>
Coefficients and other basic properties of filters
</h2><span id='topic+filterCoef'></span><span id='topic+filterOrder'></span><span id='topic+filterPoly'></span><span id='topic+filterPolyCoef'></span>

<h3>Description</h3>

<p>Coefficients and other basic properties of filters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterCoef(object, convention, ...)

filterOrder(object, ...)

filterPoly(object, ...)

filterPolyCoef(object, lag_0 = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filterCoef_+3A_object">object</code></td>
<td>
<p>object.</p>
</td></tr>
<tr><td><code id="filterCoef_+3A_convention">convention</code></td>
<td>
<p>convention for the sign.</p>
</td></tr>
<tr><td><code id="filterCoef_+3A_lag_0">lag_0</code></td>
<td>
<p>if FALSE, drop the coefficient of order zero.</p>
</td></tr>
<tr><td><code id="filterCoef_+3A_...">...</code></td>
<td>
<p>further arguments for methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic functions to extract basic properties of filters:
<code>filterCoef</code> returns coefficients,
<code>filterOrder</code> returns the order,
<code>filterPoly</code>, returns the characteristic polynomial,
<code>filterPolyCoef</code> gives the coefficients of the characteristic
polynomial.
</p>
<p>For further details on argument <code>convention</code> see 
<code><a href="#topic+filterCoef-methods">filterCoef-methods</a></code>.
</p>
<p>What exactly is returned depends on the specific filter classes, see
the description of the corresponding methods. For the core filters,
the values are as can be expected. For &quot;ArmaFilter&quot;, the value is a
list with components &quot;ar&quot; and &quot;ma&quot; giving the requested property for the
corresponding part of the filter. Similarly, for &quot;SarimaFilter&quot; the
values are lists, maybe with additional quantities.
</p>


<h3>Value</h3>

<p>the requested property as described in Details.
</p>


<h3>Note</h3>

<p>The <code>filterXXX()</code> functions are somewhat low level and
technical. They should be rarely needed in routine work.
The corresponding <code>modelXXX</code> are more flexible.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelOrder">modelOrder</a></code>,
<code><a href="#topic+modelCoef">modelCoef</a></code>,
<code><a href="#topic+modelPoly">modelPoly</a></code>,
<code><a href="#topic+modelPolyCoef">modelPolyCoef</a></code>,
for the recommended higher level alternatives for models.
</p>
<p><code><a href="#topic+filterOrder-methods">filterOrder-methods</a></code>,
<code><a href="#topic+filterCoef-methods">filterCoef-methods</a></code>,
<code><a href="#topic+filterPoly-methods">filterPoly-methods</a></code>,
<code><a href="#topic+filterPolyCoef-methods">filterPolyCoef-methods</a></code>,
for more information on the methods and the arguments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filterPoly(as(c(0.3, 0.5), "BJFilter"))   # 1 - 0.3*x - 0.5*x^2
filterPoly(as(c(0.3, 0.5), "SPFilter"))   # 1 + 0.3*x + 0.5*x^2

## now two representations of the same filter:
fi1 &lt;- as(c(0.3, 0.5), "BJFilter")
fi2 &lt;- as(c(-0.3, -0.5), "SPFilter")
identical(fi2, fi1) # FALSE, but
## fi1 and fi2 represent the same filter, eg. same ch. polynomials:
filterPoly(fi1)
filterPoly(fi2)
identical(filterPolyCoef(fi2), filterPolyCoef(fi1))

# same as above, using new()
fi1a &lt;- new("BJFilter", coef = c(0.3, 0.5))
identical(fi1a, fi1) # TRUE

fi2a &lt;- new("SPFilter", coef = c(-0.3, -0.5))
identical(fi2a, fi2) # TRUE

## conversion by as() changes the internal representation
## but represents the same filter:
identical(as(fi1, "SPFilter"), fi2) # TRUE

c(filterOrder(fi1), filterOrder(fi2))

## these give the internally stored coefficients:
filterCoef(fi1)
filterCoef(fi2)

## with argument 'convention' the result doesn't depend
## on the internal representation:
co1 &lt;- filterCoef(fi1, convention = "SP")
co2 &lt;- filterCoef(fi2, convention = "SP")
identical(co1, co2) # TRUE
</code></pre>

<hr>
<h2 id='filterCoef-methods'>Methods for filterCoef()</h2><span id='topic+filterCoef-methods'></span><span id='topic+filterCoef+2CBJFilter+2Ccharacter-method'></span><span id='topic+filterCoef+2CSPFilter+2Ccharacter-method'></span><span id='topic+filterCoef+2CVirtualArmaFilter+2Ccharacter-method'></span><span id='topic+filterCoef+2CVirtualArmaFilter+2Cmissing-method'></span><span id='topic+filterCoef+2CVirtualBJFilter+2Ccharacter-method'></span><span id='topic+filterCoef+2CVirtualSPFilter+2Ccharacter-method'></span><span id='topic+filterCoef+2CSarimaFilter+2Cmissing-method'></span><span id='topic+filterCoef+2CSarimaFilter+2Ccharacter-method'></span><span id='topic+filterCoef+2CVirtualMonicFilterSpec+2Cmissing-method'></span>

<h3>Description</h3>

<p>Methods for <code>filterCoef</code> in package <span class="pkg">sarima</span>.</p>


<h3>Methods</h3>

<p><code>filterCoef()</code> returns the coefficients of <code>object</code>. The
format of the result depends on the type of filter, see the
descriptions of the individual methods below.
</p>
<p>If argument <code>convention</code> is omitted, the sign convention for the
coefficients is the one used in the object. <code>convention</code> can be
set to &quot;BJ&quot; or &quot;SP&quot; to request, respectively, the Box-Jenkins or the
signal processing convention. Also, &quot;-&quot; is equivalent to &quot;BJ&quot; and &quot;+&quot;
to &quot;SP&quot;. 
</p>
<p>For ARMA filters, &quot;BJ&quot; and &quot;SP&quot; request the corresponding convention
for both parts (AR and MA). A widely used convention, e.g., by base R
and (Brockwell and Davis 1991), is &quot;BJ&quot; for the AR part
and &quot;SP&quot; for the MA part.  It can be requested with <code>convention =
  "BD"</code>.  For convenience, &quot;&ndash;&quot; is equivalent to &quot;BJ&quot;, &quot;++&quot; to &quot;SP&quot;,
&quot;-+&quot; to &quot;BD&quot;. For completeness, &quot;+-&quot; can be used to request &quot;SP&quot; for
the AR part and &quot;BJ&quot; for the MA part.
</p>
<p>Invalid values of <code>convention</code> throw error. In particular, low
level filters, such as &quot;BJFilter&quot; don't know if they are AR or MA, so
they throw error if <code>convention</code> is &quot;BD&quot; or &quot;+-&quot; (but &quot;++&quot; and
&quot;&ndash;&quot; are ok, since they are unambiguous). Similarly and to avoid
subtle errors, the ARMA filters do not accept &quot;+&quot; or &quot;-&quot;.
</p>

<dl>
<dt><code>signature(object = "VirtualMonicFilterSpec", convention = "missing")</code></dt><dd>
<p>returns  <code>object@coef</code>.
</p>
</dd>
<dt><code>signature(object = "VirtualBJFilter", convention = "character")</code></dt><dd>
<p>returns the filter coefficients in the requested convention.
</p>
</dd>
<dt><code>signature(object = "VirtualSPFilter", convention = "character")</code></dt><dd>
<p>returns the filter coefficients in the requested convention.
</p>
</dd>
<dt><code>signature(object = "BJFilter", convention = "character")</code></dt><dd>
<p>returns the filter coefficients in the requested convention.
</p>
</dd>
<dt><code>signature(object = "SPFilter", convention = "character")</code></dt><dd>
<p>returns the filter coefficients in the requested convention.
</p>
</dd>
<dt><code>signature(object = "VirtualArmaFilter", convention = "missing")</code></dt><dd></dd>
<dt><code>signature(object = "VirtualArmaFilter", convention = "character")</code></dt><dd>
<p>Conceptually, calls <code>filterCoef()</code>, with one argument, on the
AR and MA parts of the model. If <code>convention</code> is present,
converts the result to the specified convention.  Returns a list
with the following components:
</p>

<dl>
<dt>ar</dt><dd><p>AR coefficients.</p>
</dd>
<dt>ma</dt><dd><p>MA coefficients.</p>
</dd>
</dl>

</dd>
<dt><code>signature(object = "SarimaFilter", convention = "missing")</code></dt><dd></dd>
<dt><code>signature(object = "SarimaFilter", convention = "character")</code></dt><dd>
<p>If <code>convention</code> is present, converts the coefficients to the
specified convention. AR-like coefficients get the convention for
the AR part, Ma-like coefficients get the convention for the MA
part. Returns a list with the following components:
</p>

<dl>
<dt>nseasons</dt><dd><p>number of seasons.</p>
</dd>
<dt>iorder</dt><dd><p>integration order, number of (non-seasonal)
differences.</p>
</dd> 
<dt>siorder</dt><dd><p>seasonal integration order, number of seasonal
differences.</p>
</dd>
<dt>ar</dt><dd><p>ar coefficients.</p>
</dd>
<dt>ma</dt><dd><p>ma coefficients.</p>
</dd>
<dt>sar</dt><dd><p>seasonal ar coefficients.</p>
</dd>
<dt>sma</dt><dd><p>seasonal ma coefficients.</p>
</dd>
</dl>

</dd>
</dl>



<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>Brockwell PJ, Davis RA (1991).
<em>Time series: theory and methods. 2nd ed.</em>.
Springer Series in Statistics. Berlin etc.: Springer-Verlag..
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterCoef">filterCoef</a></code> for examples and related functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see the examples for ?filterCoef
</code></pre>

<hr>
<h2 id='filterOrder-methods'>Methods for function <code>filterOrder</code> in package <span class="pkg">sarima</span></h2><span id='topic+filterOrder-methods'></span><span id='topic+filterOrder+2CSarimaFilter-method'></span><span id='topic+filterOrder+2CVirtualArmaFilter-method'></span><span id='topic+filterOrder+2CVirtualMonicFilterSpec-method'></span>

<h3>Description</h3>

<p>Methods for function <code>filterOrder</code> in package <span class="pkg">sarima</span>.
</p>


<h3>Methods</h3>

<p>The following methods ensure that  all filters in package <span class="pkg">sarima</span>
have a method for <code>filterOrder</code>.
</p>

<dl>
<dt><code>signature(object = "VirtualMonicFilterSpec")</code></dt><dd>
<p>Returns <code>object@order</code>.
</p>
</dd>
<dt><code>signature(object = "SarimaFilter")</code></dt><dd>
<p>Returns a list with the following components:
</p>

<dl>
<dt>nseasons</dt><dd><p>number of seasons.</p>
</dd>
<dt>iorder</dt><dd><p>integration order, number of (non-seasonal) differences.</p>
</dd>
<dt>siorder</dt><dd><p>seasonal integration order, number of seasonal
differences.</p>
</dd>
<dt>ar</dt><dd><p>autoregression order</p>
</dd>
<dt>ma</dt><dd><p>moving average order</p>
</dd>
<dt>sar</dt><dd><p>seasonal autoregression order</p>
</dd>
<dt>sma</dt><dd><p>seasonal moving average order</p>
</dd>
</dl>

</dd>
<dt><code>signature(object = "VirtualArmaFilter")</code></dt><dd>
<p>Returns a list with the following components:
</p>

<dl>
<dt>ar</dt><dd><p>autoregression order.</p>
</dd>
<dt>ma</dt><dd><p>moving average order.</p>
</dd>
</dl>

</dd>
</dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterCoef">filterCoef</a></code> for examples and related functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see the examples for ?filterCoef
</code></pre>

<hr>
<h2 id='filterPoly-methods'>Methods for <code>filterPoly</code> in package <span class="pkg">sarima</span></h2><span id='topic+filterPoly-methods'></span><span id='topic+filterPoly+2CBJFilter-method'></span><span id='topic+filterPoly+2CSarimaFilter-method'></span><span id='topic+filterPoly+2CSPFilter-method'></span><span id='topic+filterPoly+2CVirtualArmaFilter-method'></span><span id='topic+filterPoly+2CVirtualMonicFilterSpec-method'></span>

<h3>Description</h3>

<p>Methods for <code>filterPoly</code> in package <span class="pkg">sarima</span>.</p>


<h3>Methods</h3>

<p>The methods for <code>filterPoly</code> take care implicitly for the sign
convention used to store the coefficients in the object.
</p>

<dl>
<dt><code>signature(object = "BJFilter")</code></dt><dd>
<p>A polynomial whose coefficients are the negated filter
coefficients.
</p>
</dd>
<dt><code>signature(object = "SPFilter")</code></dt><dd>
<p>A polynomial whose coefficients are as stored in the object.
</p>
</dd>
<dt><code>signature(object = "SarimaFilter")</code></dt><dd>
<p>Returns a list with the following components:
</p>

<dl>
<dt>nseasons</dt><dd><p>number of seasons.</p>
</dd>
<dt>iorder</dt><dd><p>integration order, number of (non-seasonal)
differences.</p>
</dd> 
<dt>siorder</dt><dd><p>seasonal integration order, number of seasonal
differences.</p>
</dd>
<dt>arpoly</dt><dd><p>autoregression polynomial</p>
</dd>
<dt>mapoly</dt><dd><p>moving average polynomial</p>
</dd>
<dt>sarpoly</dt><dd><p>seasonal autoregression polynomial</p>
</dd>
<dt>smapoly</dt><dd><p>seasonal moving average polynomial</p>
</dd>
<dt>fullarpoly</dt><dd><p>the polynomial obtained by multiplying out all
AR-like terms, including differences.</p>
</dd>
<dt>fullmapoly</dt><dd><p>the polynomial obtained by multiplying out all
MA terms</p>
</dd>
<dt>core_sarpoly</dt><dd><p>core seasonal autoregression polynomial. It
is such that sarpoly(<code class="reqn">z</code>) = core_sarpoly(<code class="reqn">z^{nseasons}</code>)</p>
</dd>
<dt>core_smapoly</dt><dd><p>core seasonal moving average polynomial. It
is such that smapoly(<code class="reqn">z</code>) = core_smapoly(<code class="reqn">z^{nseasons}</code>)</p>
</dd>
</dl>

</dd>
<dt><code>signature(object = "VirtualArmaFilter")</code></dt><dd>
<p>Returns a list with the following components:
</p>

<dl>
<dt>ar</dt><dd><p>autoregression polynomial.</p>
</dd>
<dt>ma</dt><dd><p>moving average polynomial.</p>
</dd>
</dl>

</dd>
<dt><code>signature(object = "VirtualMonicFilterSpec")</code></dt><dd>
<p>Calls <code>filterPolyCoef(object)</code> and converts the result to a
polynomial. Thus, it is sufficient to have a method for
<code>filterPolyCoef()</code>. 
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterCoef">filterCoef</a></code> for examples and related functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see the examples for ?filterCoef
</code></pre>

<hr>
<h2 id='filterPolyCoef-methods'>Methods for filterPolyCoef</h2><span id='topic+filterPolyCoef-methods'></span><span id='topic+filterPolyCoef+2CBJFilter-method'></span><span id='topic+filterPolyCoef+2CSarimaFilter-method'></span><span id='topic+filterPolyCoef+2CSPFilter-method'></span><span id='topic+filterPolyCoef+2CVirtualArmaFilter-method'></span><span id='topic+filterPolyCoef+2CVirtualBJFilter-method'></span><span id='topic+filterPolyCoef+2CVirtualSPFilter-method'></span>

<h3>Description</h3>

<p>Methods for <code>filterPolyCoef</code> in package <span class="pkg">sarima</span>.
</p>


<h3>Methods</h3>

<p>The <code>filterPolyCoef</code> methods return results with the same
structure as the corresponding methods for <code>filterPoly</code> but with
polynomials replaced by their coefficients. If <code>lag_0</code> is
<code>FALSE</code> the order 0 coefficients are dropped.
</p>

<dl>
<dt><code>signature(object = "VirtualBJFilter")</code></dt><dd>
<p>Calls <code>filterCoef(object)</code>, negates the result and prepends 1
if <code>lag_0</code> is <code>TRUE</code>. 
</p>
</dd>
<dt><code>signature(object = "VirtualSPFilter")</code></dt><dd>
<p>Calls <code>filterCoef(object)</code> and prepends 1 to the result if
<code>lag_0</code> is <code>TRUE</code>.
</p>
</dd>
<dt><code>signature(object = "VirtualArmaFilter")</code></dt><dd>
<p>Returns a list with the following components:
</p>

<dl>
<dt>ar</dt><dd><p>coefficients of the autoregression polynomial.</p>
</dd>
<dt>ma</dt><dd><p>coefficients of the moving average polynomial.</p>
</dd>
</dl>

</dd>
<dt><code>signature(object = "BJFilter")</code></dt><dd>
<p>The coefficients of a polynomial whose coefficients are the negated
filter coefficients. This is equivalent to the method for
&quot;VirtualBJFilter&quot; but somewhat more efficient.
</p>
</dd>
<dt><code>signature(object = "SPFilter")</code></dt><dd>
<p>The coefficients of a polynomial whose coefficients are as stored in
the object. This is equivalent to the method for &quot;VirtualSPFilter&quot;
but somewhat more efficient.
</p>
</dd>
<dt><code>signature(object = "SarimaFilter")</code></dt><dd>
<p>Returns a list with the same components as the &quot;SarimaFilter&quot; method
for <code><a href="#topic+filterPoly">filterPoly</a></code>, where the polynomials are replaced by
their coefficients. 
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterCoef">filterCoef</a></code> for examples and related functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see the examples for ?filterCoef
</code></pre>

<hr>
<h2 id='FisherInformation-methods'>Fisher information</h2><span id='topic+FisherInformation-methods'></span><span id='topic+FisherInformation'></span><span id='topic+FisherInformation.Arima'></span><span id='topic+FisherInformation+2CANY-method'></span><span id='topic+FisherInformation+2CSarimaModel-method'></span><span id='topic+FisherInformation+2CArmaModel-method'></span>

<h3>Description</h3>

<p>Compute the Fisher information for the parameters of a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FisherInformation(model, ...)

## S3 method for class 'Arima'
FisherInformation(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FisherInformation-methods_+3A_model">model</code></td>
<td>

<p>a fitted or theoretical model for which a method is available.
</p>
</td></tr>
<tr><td><code id="FisherInformation-methods_+3A_...">...</code></td>
<td>
<p>further arguments for methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>FisherInformation</code> computes the information matrix for the
parameters of <code>model</code>. This is a generic function. The methods
for objects from S4 classes are listed in section &lsquo;Methods&rsquo;.
</p>
<p>Currently package <span class="pkg">sarima</span> defines methods for objects
representing fitted or theoretical ARMA and seasonal ARMA models.
For integrated models the result should be interpreted as the
information matrix after differencing.
</p>
<p>For ARMA models the implementation is based on
Friedlander (1984) and (for the seasonal
specifics) Godolphin and Godolphin (2007).
</p>


<h3>Value</h3>

<p>a square matrix with attribute <code>"nseasons"</code>
</p>


<h3>Methods</h3>

<p>This section lists <code>FisherInformation</code> methods for S4
classes. 
</p>

<dl>
<dt><code>signature(model = "ANY")</code></dt><dd>
</dd>
<dt><code>signature(model = "SarimaModel")</code></dt><dd>
</dd>
<dt><code>signature(model = "ArmaModel")</code></dt><dd>

</dd></dl>


<h3>Author(s)</h3>

<p>Georgi Boshnakov</p>


<h3>References</h3>

<p>Friedlander B (1984).
&ldquo;On the computation of the Cramer-Rao bound for ARMA parameter estimation.&rdquo;
<em>IEEE Transactions on Acoustics, Speech, and Signal Processing</em>, <b>32</b>(4), 721-727.
<a href="https://doi.org/10.1109/TASSP.1984.1164391">doi:10.1109/TASSP.1984.1164391</a>.<br /><br /> Godolphin EJ, Godolphin JD (2007).
&ldquo;A Note on the Information Matrix for Multiplicative Seasonal Autoregressive Moving-Average Models.&rdquo;
<em>Journal of Time Series Analysis</em>, <b>28</b>, 783-791.
<a href="https://doi.org/10.1111/j.1467-9892.2007.00531.x">doi:10.1111/j.1467-9892.2007.00531.x</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a fitted model (over-parameterised)
seas_spec &lt;- list(order = c(1,0,1), period = 4)
fitted &lt;- arima(rnorm(100), order = c(1,0,1), seasonal = seas_spec)
(fi &lt;- FisherInformation(fitted))
## asymptotic covariance matrix of the ARMA parameters:
fitted$sigma2 * solve(fi) / 100

## a theoretical seasonal ARMA model:
sarima1 &lt;- new("SarimaModel", ar = 0.9, ma = 0.1, sar = 0.5, sma = 0.9, nseasons = 12)
FisherInformation(sarima1)

## a non-seasonal ARMA model:
arma2a1 &lt;- ArmaModel(ar = 0.5, ma = c(0.3, 0.7), sigma2 = 1)
FisherInformation(arma2a1)
## sigma2 is not needed for the information matrix:
arma2a1a &lt;- ArmaModel(ar = 0.5, ma = c(0.3, 0.7))
FisherInformation(arma2a1a) # same as above
</code></pre>

<hr>
<h2 id='fun.forecast'>
Forecasting functions for seasonal ARIMA models
</h2><span id='topic+fun.forecast'></span>

<h3>Description</h3>

<p>Forecasting functions for seasonal ARIMA models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.forecast(past, n = max(2 * length(past), 12), eps = numeric(n), pasteps, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fun.forecast_+3A_past">past</code></td>
<td>

<p>past values of the time series, by default zeroes.
</p>
</td></tr>
<tr><td><code id="fun.forecast_+3A_n">n</code></td>
<td>
<p>number of forecasts to compute.</p>
</td></tr>
<tr><td><code id="fun.forecast_+3A_eps">eps</code></td>
<td>
<p>values of the white noise sequence (for simulation  of
future). Currently not used!
</p>
</td></tr>
<tr><td><code id="fun.forecast_+3A_pasteps">pasteps</code></td>
<td>
<p>past values of the white noise sequence for models with
MA terms, 0 by default.
</p>
</td></tr>
<tr><td><code id="fun.forecast_+3A_...">...</code></td>
<td>
<p>specification of the model, passed to <code>new()</code> to
create a <code>"SarimaModel"</code> object, see Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fun.forecast</code> computes predictions from a SARIMA model.  The
model is specified using the &quot;...&quot; arguments which are passed to
<code>new("SarimaModel", ...)</code>, see the description of class
<code>"SarimaModel"</code> for details.
</p>
<p>Argument <code>past</code>, if provided, should contain a least as many values as
needed for the prediction equation. It is harmless to provide more
values than necessary, even a whole time series.
</p>
<p><code>fun.forecast</code> can be used to illustrate, for example, the
inherent difference for prediction of integrated and seasonally
integrated models to corresponding models with roots close to the unit
circle.
</p>


<h3>Value</h3>

<p>the forecasts as an object of class &quot;ts&quot;
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'>f1 &lt;- fun.forecast(past = 1, n = 100, ar = c(0.85), center = 5)
plot(f1)

f2 &lt;- fun.forecast(past = 8, n = 100, ar = c(0.85), center = 5)
plot(f2)

f3 &lt;- fun.forecast(past = 10, n = 100, ar = c(-0.85), center = 5)
plot(f3)

frw1 &lt;- fun.forecast(past = 1, n = 100, iorder = 1)
plot(frw1)

frw2 &lt;- fun.forecast(past = 3, n = 100, iorder = 1)
plot(frw2)

frwa1 &lt;- fun.forecast(past = c(1, 2), n = 100, ar = c(0.85), iorder = 1)
plot(frwa1)

fi2a &lt;- fun.forecast(past = c(3, 1), n = 100, iorder = 2)
plot(fi2a)

fi2b &lt;- fun.forecast(past = c(1, 3), n = 100, iorder = 2)
plot(fi2b)

fari1p2 &lt;- fun.forecast(past = c(0, 1, 3), ar = c(0.9), n = 20, iorder = 2)
plot(fari1p2)

fsi1 &lt;- fun.forecast(past = rnorm(4), n = 100, siorder = 1, nseasons = 4)
plot(fsi1)

fexa &lt;- fun.forecast(past = rnorm(5), n = 100, ar = c(0.85), siorder = 1,
                     nseasons = 4)
plot(fexa)

fi2a &lt;- fun.forecast(past = rnorm(24, sd = 5), n = 120, siorder = 2,
                     nseasons = 12)
plot(fi2a)

fi1si1a &lt;- fun.forecast(past = rnorm(24, sd = 5), n = 120, iorder = 1,
                        siorder = 1, nseasons = 12)
plot(fi1si1a)

fi1si1a &lt;- fun.forecast(past = AirPassengers[120:144], n = 120, iorder = 1,
                        siorder = 1, nseasons = 12)
plot(fi1si1a)


m1 &lt;- list(iorder = 1, siorder = 1, ma = 0.8, nseasons = 12, sigma2 = 1)
m1
x &lt;- sim_sarima(model = m1, n = 500)
acf(diff(diff(x), lag = 12), lag.max = 96)
pacf(diff(diff(x), lag = 12), lag.max = 96)

m2 &lt;- list(iorder = 1, siorder = 1, ma = 0.8, sma = 0.5, nseasons = 12,
           sigma2 = 1)
m2
x2 &lt;- sim_sarima(model = m2, n = 500)
acf(diff(diff(x2), lag = 12), lag.max = 96)
pacf(diff(diff(x2), lag = 12), lag.max = 96)
fit2 &lt;- arima(x2, order = c(0, 1, 1),
              seasonal = list(order = c(0, 1, 0), nseasons = 12))
fit2
tsdiag(fit2)
tsdiag(fit2, gof.lag = 96)

x2past &lt;- rnorm(13, sd = 10)
x2 &lt;- sim_sarima(model = m2, n = 500, x = list(init = x2past))
plot(x2)

fun.forecast(ar = 0.5, n = 100)
fun.forecast(ar = 0.5, n = 100, past = 1)
fun.forecast(ma = 0.5, n = 100, past = 1)
fun.forecast(iorder = 1, ma = 0.5, n = 100, past = 1)
fun.forecast(iorder = 1, ma = 0.5, ar = 0.8, n = 100, past = 1)

fun.forecast(m1, n = 100)
fun.forecast(m2, n = 100)
fun.forecast(iorder = 1, ar = 0.8, ma = 0.5, n = 100, past = 1)
</code></pre>

<hr>
<h2 id='InterceptSpec-class'>Class InterceptSpec</h2><span id='topic+InterceptSpec-class'></span>

<h3>Description</h3>

<p>A helper class from which a number of models inherit intercept,
centering and innovations variance.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("InterceptSpec", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>center</code>:</dt><dd><p>Object of class <code>"numeric"</code>,
centering parameter, defaults to zero.
</p>
</dd>
<dt><code>intercept</code>:</dt><dd><p>Object of class <code>"numeric"</code>,
intercept parameter, defaults to zero.
</p>
</dd>
<dt><code>sigma2</code>:</dt><dd><p>Object of class <code>"numeric"</code>,
innovations variance, defaults to NA.
</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>sigmaSq</dt><dd><p><code>signature(object = "InterceptSpec")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+ArmaModel-class">ArmaModel</a></code>,
<code><a href="#topic+SarimaModel-class">SarimaModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("InterceptSpec")
</code></pre>

<hr>
<h2 id='isStationaryModel'>Check if a model is stationary</h2><span id='topic+isStationaryModel'></span><span id='topic+isStationaryModel-methods'></span><span id='topic+isStationaryModel+2CSarimaSpec-method'></span><span id='topic+isStationaryModel+2CVirtualIntegratedModel-method'></span><span id='topic+isStationaryModel+2CVirtualStationaryModel-method'></span>

<h3>Description</h3>

<p>Check if a model is stationary.</p>


<h3>Usage</h3>

<pre><code class='language-R'>isStationaryModel(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isStationaryModel_+3A_object">object</code></td>
<td>
<p>an object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generic function.
It returns <code>TRUE</code> if <code>object</code> represents a stationary model
and FALSE otherwise.
</p>


<h3>Value</h3>

<p>TRUE or FALSE
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "SarimaSpec")</code></dt><dd>
</dd>
<dt><code>signature(object = "VirtualIntegratedModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "VirtualStationaryModel")</code></dt><dd>

</dd></dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+nUnitRoots">nUnitRoots</a></code>
</p>

<hr>
<h2 id='modelCenter'>model center</h2><span id='topic+modelCenter'></span><span id='topic+modelCenter-methods'></span><span id='topic+modelCenter+2CInterceptSpec-method'></span>

<h3>Description</h3>

<p>model center</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelCenter(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelCenter_+3A_object">object</code></td>
<td>
<p>an object
</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "InterceptSpec")</code></dt><dd>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>

<hr>
<h2 id='modelCoef'>Get the coefficients of models</h2><span id='topic+modelCoef'></span>

<h3>Description</h3>

<p>Get the coefficients of an object, optionally specifying
the expected format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelCoef(object, convention, component, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelCoef_+3A_object">object</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="modelCoef_+3A_convention">convention</code></td>
<td>

<p>the convention to use for the return value, a character string or any
object from a supported class, see Details.
</p>
</td></tr>
<tr><td><code id="modelCoef_+3A_component">component</code></td>
<td>

<p>if not missing, specifies a component to extract, see Details.
</p>
</td></tr>
<tr><td><code id="modelCoef_+3A_...">...</code></td>
<td>
<p>not used, further arguments for methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>modelCoef</code> is a generic function for extraction of coefficients
of model objects. What &lsquo;coeffcients&rsquo; means depends on the class of
<code>object</code> but it can be changed with the optional argument
<code>convention</code>. In effect, <code>modelCoef</code> provides a very
flexible and descriptive way of extracting coefficients from models in
various forms.
</p>
<p>The one-argument form, <code>modelCoef(object)</code>, gives the
coefficients of <code>object</code>. In effect it defines, for the purposes
of <code>modelCoef</code>, the meaning of &lsquo;coefficients&rsquo; for class
<code>class(modelCoef)</code>.
</p>
<p>Argument <code>convention</code> can be used to specify what kind of value
to return.
</p>
<p>If <code>convention</code> is not a character string, only its class is
used. Conceptually, the value will have the format and meaning of the
value that would be returned by a call to <code>modelCoef(obj)</code> with
<code>obj</code> from class <code>class(convention)</code>.
</p>
<p>If <code>convention</code> is a character string, it is typically the name
of a class. In this case <code>modelCoef(object, "someclass")</code> is
equivalent to <code>modelCoef(object, new("someclass"))</code>.  Note that
this is conceptual - argument <code>convention</code> can be the name of a
virtual class, for example.  Also, for some classes of <code>object</code>
character values other than names of classes may be supported.
</p>
<p>For example, if <code>obj</code> is from class &quot;ArmaModel&quot;,
<code>modelCoef(obj)</code> returns a list with components &quot;ar&quot; and &quot;ma&quot;,
which follow the &quot;BD&quot; convention. So, to get such a list of
coefficients from an <code>object</code> from any class capable of
representing ARMA models, set <code>convention = "ArmaModel"</code> in the
call to <code>modelCoef{}</code>.
</p>
<p><code>modelCoef()</code> will signal an error if <code>object</code> is not
compatible with <code>target</code> (e.g. if it contains unit roots).
(see <code>filterCoef</code> if you need to expand any multiplicative
filters).
<strong>TODO: rethink this, it does not reflect current behaviour!</strong>
</p>
<p>If there is no class which returns exactly what is needed some
additional computation may be necessary. In the above
&quot;ArmaModel&quot; example we might need the coefficients in the &quot;BJ&quot;
convention, so we would need to change the signs of the MA
coefficients to achieve this. Since this is a very common operation,
a convenience feature is available. Setting <code>convention = "BJ"</code>
requests ARMA coefficients with &quot;BJ&quot; convention. For completeness, the
the settings &quot;SP&quot; (signal processing) and &quot;BD&quot; (Brockwell-Davis) are
also available.
</p>
<p>The methods for <code>modelCoef()</code> in package &quot;sarima&quot; return a list
with components depending on argument &quot;convention&quot;, as outlined
above.
</p>


<h3>Value</h3>

<p>a list, with components depending on the target class, as described in
Details
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelOrder">modelOrder</a></code>, 
<code><a href="#topic+modelPoly">modelPoly</a></code>, 
<code><a href="#topic+modelPolyCoef">modelPolyCoef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## define a seasonal ARIMA model, it has a number of components
m1 &lt;- new("SarimaModel", iorder = 1, siorder = 1, ma = -0.3, sma = -0.1, nseasons = 12)
m1
## Get the coefficients corresponding to a 'flat' ARMA model,
## obtained by multiplying out AR-like and MA-like terms. 
## A simple way is to use modelCoef() with a suitable convention:
modelCoef(m1, "ArmaModel")
modelCoef(m1, "ArmaFilter") ## same

## Here is another model
m1a &lt;- new("SarimaModel", iorder = 1, siorder = 1,  ar = 0.6, nseasons = 12)
modelCoef(m1a, "ArmaModel")
modelCoef(m1a, "ArmaFilter") ## same

## if only AR-like terms are allowed in a computation,
## use convention = "ArModel" to state it explicitly.
##
## this works, since m1a contains only AR-like terms:
modelCoef(m1a, "ArModel")
modelCoef(m1a, "ArFilter") ## same
## ... but these would throw errors if evaluated,
## since model m1a contains both AR-like and MA-like terms,
## Not run: 
modelCoef(m1, "ArModel")
modelCoef(m1, "ArFilter")
modelCoef(m1, "MaModel")
modelCoef(m1, "MaFilter")

## End(Not run)
</code></pre>

<hr>
<h2 id='modelCoef-methods'>Methods for generic function modelCoef</h2><span id='topic+modelCoef-methods'></span><span id='topic+modelCoef+2CAutocorrelations+2CComboAutocorrelations+2Cmissing-method'></span><span id='topic+modelCoef+2CAutocorrelations+2CPartialAutocorrelations+2Cmissing-method'></span><span id='topic+modelCoef+2CAutocovariances+2CAutocorrelations+2Cmissing-method'></span><span id='topic+modelCoef+2CAutocovariances+2CComboAutocorrelations+2Cmissing-method'></span><span id='topic+modelCoef+2CAutocovariances+2CComboAutocovariances+2Cmissing-method'></span><span id='topic+modelCoef+2CAutocovariances+2CPartialAutocorrelations+2Cmissing-method'></span><span id='topic+modelCoef+2CComboAutocorrelations+2CAutocorrelations+2Cmissing-method'></span><span id='topic+modelCoef+2CComboAutocorrelations+2CPartialAutocorrelations+2Cmissing-method'></span><span id='topic+modelCoef+2CComboAutocovariances+2CAutocovariances+2Cmissing-method'></span><span id='topic+modelCoef+2CComboAutocovariances+2CPartialAutocovariances+2Cmissing-method'></span><span id='topic+modelCoef+2CComboAutocovariances+2CPartialVariances+2Cmissing-method'></span><span id='topic+modelCoef+2CComboAutocovariances+2CVirtualAutocovariances+2Cmissing-method'></span><span id='topic+modelCoef+2CPartialAutocorrelations+2CAutocorrelations+2Cmissing-method'></span><span id='topic+modelCoef+2CSarimaModel+2CArFilter+2Cmissing-method'></span><span id='topic+modelCoef+2CSarimaModel+2CArmaFilter+2Cmissing-method'></span><span id='topic+modelCoef+2CSarimaModel+2CMaFilter+2Cmissing-method'></span><span id='topic+modelCoef+2CSarimaModel+2CSarimaFilter+2Cmissing-method'></span><span id='topic+modelCoef+2CVirtualAutocovariances+2Ccharacter+2Cmissing-method'></span><span id='topic+modelCoef+2CVirtualAutocovariances+2Cmissing+2Cmissing-method'></span><span id='topic+modelCoef+2CVirtualAutocovariances+2CVirtualAutocovariances+2Cmissing-method'></span><span id='topic+modelCoef+2CPartialAutocovariances+2CPartialAutocorrelations+2Cmissing-method'></span><span id='topic+modelCoef+2CSarimaModel+2CArModel+2Cmissing-method'></span><span id='topic+modelCoef+2CSarimaModel+2CMaModel+2Cmissing-method'></span><span id='topic+modelCoef+2CVirtualFilterModel+2CBD+2Cmissing-method'></span><span id='topic+modelCoef+2CVirtualFilterModel+2CBJ+2Cmissing-method'></span><span id='topic+modelCoef+2CVirtualFilterModel+2Ccharacter+2Cmissing-method'></span><span id='topic+modelCoef+2CVirtualFilterModel+2Cmissing+2Cmissing-method'></span><span id='topic+modelCoef+2CVirtualFilterModel+2CSP+2Cmissing-method'></span><span id='topic+modelCoef+2CArmaModel+2CArmaFilter+2Cmissing-method'></span><span id='topic+modelCoef+2CVirtualAutocovariances+2CAutocovariances+2Cmissing-method'></span>

<h3>Description</h3>

<p>Methods for generic function modelCoef.</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "Autocorrelations", convention = "ComboAutocorrelations", component = "missing")</code></dt><dd>
</dd>
<dt><code>signature(object = "Autocorrelations", convention = "PartialAutocorrelations", component = "missing")</code></dt><dd>
</dd>
<dt><code>signature(object = "Autocovariances", convention = "Autocorrelations", component = "missing")</code></dt><dd>
</dd>
<dt><code>signature(object = "Autocovariances", convention = "ComboAutocorrelations", component = "missing")</code></dt><dd>
</dd>
<dt><code>signature(object = "Autocovariances", convention = "ComboAutocovariances", component = "missing")</code></dt><dd>
</dd>
<dt><code>signature(object = "Autocovariances", convention = "PartialAutocorrelations", component = "missing")</code></dt><dd>
</dd>
<dt><code>signature(object = "ComboAutocorrelations", convention = "Autocorrelations", component = "missing")</code></dt><dd>
</dd>
<dt><code>signature(object = "ComboAutocorrelations", convention = "PartialAutocorrelations", component = "missing")</code></dt><dd>
</dd>
<dt><code>signature(object = "ComboAutocovariances", convention = "Autocovariances", component = "missing")</code></dt><dd>
</dd>
<dt><code>signature(object = "ComboAutocovariances", convention = "PartialAutocovariances", component = "missing")</code></dt><dd>
</dd>
<dt><code>signature(object = "ComboAutocovariances", convention = "PartialVariances", component = "missing")</code></dt><dd>
</dd>
<dt><code>signature(object = "ComboAutocovariances", convention = "VirtualAutocovariances", component = "missing")</code></dt><dd>
</dd>
<dt><code>signature(object = "PartialAutocorrelations", convention = "Autocorrelations", component = "missing")</code></dt><dd>
</dd>
<dt><code>signature(object = "SarimaModel", convention = "ArFilter", component = "missing")</code></dt><dd>
</dd>
<dt><code>signature(object = "SarimaModel", convention = "ArmaFilter", component = "missing")</code></dt><dd>
</dd>
<dt><code>signature(object = "SarimaModel", convention = "MaFilter", component = "missing")</code></dt><dd>
</dd>
<dt><code>signature(object = "SarimaModel", convention = "SarimaFilter", component = "missing")</code></dt><dd>
</dd>
<dt><code>signature(object = "VirtualAutocovariances", convention = "character", component = "missing")</code></dt><dd>
</dd>
<dt><code>signature(object = "VirtualAutocovariances", convention = "missing", component = "missing")</code></dt><dd>
</dd>
<dt><code>signature(object = "VirtualAutocovariances", convention = "VirtualAutocovariances", component = "missing")</code></dt><dd>
</dd>
<dt><code>signature(object = "SarimaModel", convention = "ArModel", component = "missing")</code></dt><dd>

</dd><dt><code>signature(object = "SarimaModel", convention = "MaModel", component = "missing")</code></dt><dd>

</dd><dt><code>signature(object = "VirtualFilterModel", convention = "BD", component = "missing")</code></dt><dd>

</dd><dt><code>signature(object = "VirtualFilterModel", convention = "BJ", component = "missing")</code></dt><dd>

</dd><dt><code>signature(object = "VirtualFilterModel", convention = "character", component = "missing")</code></dt><dd>

</dd><dt><code>signature(object = "VirtualFilterModel", convention = "missing", component = "missing")</code></dt><dd>

</dd><dt><code>signature(object = "VirtualFilterModel", convention = "SP", component = "missing")</code></dt><dd>

</dd><dt><code>signature(object = "ArmaModel", convention = "ArmaFilter", 
          component = "missing")</code></dt><dd>

</dd><dt><code>signature(object = "VirtualAutocovariances", 
          convention = "Autocovariances", component = "missing")</code></dt><dd>

</dd></dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>

<hr>
<h2 id='modelIntercept'>Give the intercept parameter of a model</h2><span id='topic+modelIntercept'></span><span id='topic+modelIntercept-methods'></span><span id='topic+modelIntercept+2CInterceptSpec-method'></span>

<h3>Description</h3>

<p>Give the intercept parameter of a model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelIntercept(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelIntercept_+3A_object">object</code></td>
<td>
<p>an object from a class for which intercept is defined.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "InterceptSpec")</code></dt><dd>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>

<hr>
<h2 id='modelOrder'>Get the model order and other properties of models</h2><span id='topic+modelOrder'></span><span id='topic+modelPoly'></span><span id='topic+modelPolyCoef'></span>

<h3>Description</h3>

<p>Get the model order and other properties of models.</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelOrder(object, convention, ...)

modelPoly(object, convention, ...)

modelPolyCoef(object, convention, lag_0 = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelOrder_+3A_object">object</code></td>
<td>
<p>a model object.</p>
</td></tr>
<tr><td><code id="modelOrder_+3A_convention">convention</code></td>
<td>
<p>convention.</p>
</td></tr>
<tr><td><code id="modelOrder_+3A_lag_0">lag_0</code></td>
<td>
<p>if TRUE include lag_0 coef, otherwise drop it.</p>
</td></tr>
<tr><td><code id="modelOrder_+3A_...">...</code></td>
<td>
<p>further arguments for methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions return the requested quantity, optionally requesting
the returned value to follow a specific convention, see also
<code><a href="#topic+modelCoef">modelCoef</a></code>.
</p>
<p>When called with one argument, these functions return corresponding
property in the native format for the object's class.
</p>
<p>Argument <code>convention</code> requests the result in some other
format. The mental model is that the returned value is as if the
object was first converted to the class specified by <code>convention</code>
and then the property extracted or computed. Normally, the object is
not actually converted to that class. one obvious reason is efficiency
but it may also not be possible, for example if argument
<code>convention</code> is the name of a virtual class.
</p>
<p>For example, the order of a seasonal SARIMA model is specified by
several numbers. The call <code>modelOrder(object)</code> returns it as a
list with components ar, ma, sar, sma, iorder, siorder and nseasons.
For some computations all that is needed are the overall AR and MA
orders obtained by multiplying out the AR-like and MA-like terms in
the model.
The result would be an ARMA filter and could be requested  by
<code>modelOrder(object, "ArmaFilter")</code>.
</p>
<p>The above operation is valid for any ARIMA model, so will always
succeed.  On the other hand, if further computation would work only if
there are no moving average terms in the model one could use
<code>modelOrder(object, "ArFilter")</code>. Here, if <code>object</code> contains
MA terms an error will be raised.
</p>
<p>The concept is powerful and helps in writing expressive code.
In this example a simple check on the returned value would do but even
so, such a check may require additional care.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelCoef">modelCoef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- new("SarimaModel", iorder = 1, siorder = 1, ma = -0.3, sma = -0.1, nseasons = 12)
modelOrder(m1)
modelOrder(m1, "ArmaFilter")
modelOrder(m1, new("ArmaFilter"))

modelPoly(m1, "ArmaModel")
modelPolyCoef(m1, "ArmaModel")
</code></pre>

<hr>
<h2 id='modelOrder-methods'>Get the order of a model</h2><span id='topic+modelOrder-methods'></span><span id='topic+modelOrder+2CArmaModel+2CArFilter-method'></span><span id='topic+modelOrder+2CArmaModel+2CMaFilter-method'></span><span id='topic+modelOrder+2CSarimaModel+2CArFilter-method'></span><span id='topic+modelOrder+2CSarimaModel+2CArmaFilter-method'></span><span id='topic+modelOrder+2CSarimaModel+2CArmaModel-method'></span><span id='topic+modelOrder+2CSarimaModel+2CArModel-method'></span><span id='topic+modelOrder+2CSarimaModel+2CMaFilter-method'></span><span id='topic+modelOrder+2CSarimaModel+2CMaModel-method'></span><span id='topic+modelOrder+2CVirtualFilterModel+2Cmissing-method'></span><span id='topic+modelOrder+2CVirtualFilterModel+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Get the order of a model.</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "ArmaModel", convention = "ArFilter")</code></dt><dd>
</dd>
<dt><code>signature(object = "ArmaModel", convention = "MaFilter")</code></dt><dd>
</dd>
<dt><code>signature(object = "SarimaModel", convention = "ArFilter")</code></dt><dd>
</dd>
<dt><code>signature(object = "SarimaModel", convention = "ArmaFilter")</code></dt><dd>
</dd>
<dt><code>signature(object = "SarimaModel", convention = "ArmaModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "SarimaModel", convention = "ArModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "SarimaModel", convention = "MaFilter")</code></dt><dd>
</dd>
<dt><code>signature(object = "SarimaModel", convention = "MaModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "VirtualFilterModel", convention = "missing")</code></dt><dd>

</dd><dt><code>signature(object = "VirtualFilterModel", convention = "character")</code></dt><dd>

</dd></dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>

<hr>
<h2 id='modelPoly-methods'>Get polynomials associated with SARIMA models</h2><span id='topic+modelPoly-methods'></span><span id='topic+modelPoly+2CSarimaModel+2CArmaFilter-method'></span><span id='topic+modelPoly+2CVirtualMonicFilter+2Cmissing-method'></span><span id='topic+modelPoly+2CVirtualFilterModel+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Get polynomials associated with SARIMA models.</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "SarimaModel", convention = "ArmaFilter")</code></dt><dd>
</dd>
<dt><code>signature(object = "VirtualMonicFilter", convention = "missing")</code></dt><dd>

</dd><dt><code>signature(object = "VirtualFilterModel", convention = "character")</code></dt><dd>

</dd></dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>

<hr>
<h2 id='modelPolyCoef-methods'>Methods for modelPolyCoef</h2><span id='topic+modelPolyCoef-methods'></span><span id='topic+modelPolyCoef+2CSarimaModel+2CArmaFilter-method'></span><span id='topic+modelPolyCoef+2CVirtualMonicFilter+2Cmissing-method'></span><span id='topic+modelPolyCoef+2CVirtualFilterModel+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Methods for modelPolyCoef, e generic function for getting
the coefficients of polynomials associated with SARIMA models.</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "SarimaModel", convention = "ArmaFilter")</code></dt><dd>
</dd>
<dt><code>signature(object = "VirtualMonicFilter", convention = "missing")</code></dt><dd>

</dd><dt><code>signature(object = "VirtualFilterModel", convention = "character")</code></dt><dd>

</dd></dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>

<hr>
<h2 id='nSeasons'>Number of seasons</h2><span id='topic+nSeasons'></span><span id='topic+nSeasons-methods'></span><span id='topic+nSeasons+2CSarimaFilter-method'></span><span id='topic+nSeasons+2CVirtualArmaFilter-method'></span>

<h3>Description</h3>

<p>Number of seasons.</p>


<h3>Usage</h3>

<pre><code class='language-R'>nSeasons(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nSeasons_+3A_object">object</code></td>
<td>

<p>an object for which the notion of number of seasons makes sense.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generic function.
</p>


<h3>Value</h3>

<p>an integer number
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "SarimaFilter")</code></dt><dd>

</dd><dt><code>signature(object = "VirtualArmaFilter")</code></dt><dd>

</dd></dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>

<hr>
<h2 id='nUnitRoots'>Number of unit roots in a model</h2><span id='topic+nUnitRoots'></span><span id='topic+nUnitRoots-methods'></span><span id='topic+nUnitRoots+2CSarimaSpec-method'></span><span id='topic+nUnitRoots+2CVirtualStationaryModel-method'></span>

<h3>Description</h3>

<p>Gives the number of roots with modulus one in a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nUnitRoots(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nUnitRoots_+3A_object">object</code></td>
<td>
<p>an object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nUnitRoots()</code> gives the number of roots with modulus one in a
model. This number is zero for stationary models, see also
<code>isStationaryModel()</code>.
</p>


<h3>Value</h3>

<p>a non-negative integer number
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "SarimaSpec")</code></dt><dd>
</dd>
<dt><code>signature(object = "VirtualStationaryModel")</code></dt><dd>

</dd></dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>

<hr>
<h2 id='nvarOfAcfKP'>Compute variances of autocorrelations under ARCH-type hypothesis</h2><span id='topic+nvarOfAcfKP'></span>

<h3>Description</h3>

<p>Compute variances of autocorrelations under ARCH-type hypothesis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nvarOfAcfKP(x, maxlag, center = FALSE, acfscale = c("one", "mom"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nvarOfAcfKP_+3A_x">x</code></td>
<td>
<p>time series.</p>
</td></tr>
<tr><td><code id="nvarOfAcfKP_+3A_maxlag">maxlag</code></td>
<td>
<p>a positive integer, the maximal lag.</p>
</td></tr>
<tr><td><code id="nvarOfAcfKP_+3A_center">center</code></td>
<td>

<p>logical flag, if FALSE, the default, don't center the time series
before squaring, see Details.
</p>
</td></tr>
<tr><td><code id="nvarOfAcfKP_+3A_acfscale">acfscale</code></td>
<td>

<p>character string, specifying what factor to use for the
autocovariances. <code>"one"</code> stands for <code class="reqn">1/n</code>, <code>"mom"</code> for
<code class="reqn">1/(n-k)</code>, where <code class="reqn">n</code> is the length of <code>x</code> and <code class="reqn">k</code>
is lag.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nvarOfAcfKP</code> computes estimates of <code class="reqn">n</code> times the variances
of sample autocorrelations of white noise time series. It implements
the result of (Kokoszka and Politis 2011) which
holds under weak assumptions. In particular, it can be used to test if
the true autocorrelations of a time series are equal to zero in GARCH
modelling.
</p>


<h3>Value</h3>

<p>a numeric vector
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>Kokoszka PS, Politis DN (2011).
&ldquo;Nonlinearity of ARCH and stochastic volatility models and Bartlett's formula.&rdquo;
<em>Probability and Mathematical Statistics</em>, <b>31</b>(1), 47&ndash;59.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+whiteNoiseTest">whiteNoiseTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see examples for whiteNoisTest()
</code></pre>

<hr>
<h2 id='nvcovOfAcf'>Covariances of sample autocorrelations</h2><span id='topic+nvcovOfAcf'></span><span id='topic+nvcovOfAcfBD'></span><span id='topic+acfOfSquaredArmaModel'></span>

<h3>Description</h3>

<p>Compute covariances of autocorrelations.</p>


<h3>Usage</h3>

<pre><code class='language-R'>nvcovOfAcf(model, maxlag)

nvcovOfAcfBD(acf, ma, maxlag)

acfOfSquaredArmaModel(model, maxlag)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nvcovOfAcf_+3A_model">model</code></td>
<td>
<p>a model, see Details.</p>
</td></tr>
<tr><td><code id="nvcovOfAcf_+3A_maxlag">maxlag</code></td>
<td>
<p>a positive integer number, the maximal lag.</p>
</td></tr>
<tr><td><code id="nvcovOfAcf_+3A_acf">acf</code></td>
<td>
<p>autocorrelations.</p>
</td></tr>
<tr><td><code id="nvcovOfAcf_+3A_ma">ma</code></td>
<td>

<p>a positive integer number, the order of the MA(q) model. The default
is the maximal lag available in <code>acf</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nvcovOfAcf</code> computes the unscaled asymptotic autocovariances of
sample autocorrelations of ARMA models, under the classical
assumptions when the Bartlett's formulas are valid.  It works directly
with the parameters of the model and uses Boshnakov (1996).  Argument
<code>model</code> can be any specification of ARMA models for which
<code>autocorrelations()</code> will work, e.g. a list with components &quot;ar&quot;,
&quot;ma&quot;, and &quot;sigma2&quot;.
</p>
<p><code>nvcovOfAcfBD</code> computes the same quantities but uses the formula
given by Brockwell &amp; Davis (1991) (eq. (7.2.6.), p. 222), which is
based on the autocorrelations of the model. Argument
<code>acf</code> contains the autocorrelations.
</p>
<p>For <code>nvcovOfAcfBD</code>, argument <code>ma</code> asks to treat the provided
acf as that of MA(<code>ma</code>). Only the values for lags up to
<code>ma</code> are used and the rest are set to zero, since the
autocorrelations of MA(<code>ma</code>) models are zero for lags greater
than <code>ma</code>.
To force the use of all autocorrelations provided in <code>acf</code>, set
<code>ma</code> to the maximal lag available in <code>acf</code> or omit
<code>ma</code>, since this is its default.
</p>
<p><code>acfOfSquaredArmaModel(model, maxlag)</code> is a convenience function
which computes the autocovariances of the &quot;squared&quot; model, see
Boshnakov (1996).
</p>


<h3>Value</h3>

<p>an <code>(maxlag,maxlag)</code>-matrix
</p>


<h3>Note</h3>

<p>The name of <code>nvcovOfAcf</code> stands for &ldquo;<code>n</code> times the
variance-covariance matrix&rdquo;, so it needs to be divided by <code>n</code> to
get the asymptotic variances and covariances. 
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>Boshnakov GN (1996).
&ldquo;Bartlett's formulae&mdash;closed forms and recurrent equations.&rdquo;
<em>Ann. Inst. Statist. Math.</em>, <b>48</b>(1), 49&ndash;59.
ISSN 0020-3157, <a href="https://doi.org/10.1007/BF00049288">doi:10.1007/BF00049288</a>.
</p>
<p>Brockwell PJ, Davis RA (1991).
<em>Time series: theory and methods. 2nd ed.</em>.
Springer Series in Statistics. Berlin etc.: Springer-Verlag..
</p>


<h3>See Also</h3>

<p><code><a href="#topic+whiteNoiseTest">whiteNoiseTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## MA(2)
ma2 &lt;- list(ma = c(0.8, 0.1), sigma2 = 1)
nv &lt;- nvcovOfAcf(ma2, maxlag = 4)
d &lt;- diag(nvcovOfAcf(ma2, maxlag = 7))
cbind(ma2 = 1.96 * sqrt(d) / sqrt(200), iid = 1.96/sqrt(200))

acr &lt;- autocorrelations(list(ma = c(0.8, 0.1)), maxlag = 7)
nvBD &lt;- nvcovOfAcfBD(acr, 2, maxlag = 4)
all.equal(nv, nvBD) # TRUE
</code></pre>

<hr>
<h2 id='partialAutocorrelations-methods'>Methods for function partialAutocorrelations</h2><span id='topic+partialAutocorrelations-methods'></span><span id='topic+partialAutocorrelations+2CANY+2CANY+2CANY-method'></span><span id='topic+partialAutocorrelations+2Cmts+2CANY+2Cmissing-method'></span><span id='topic+partialAutocorrelations+2CPartialAutocovariances+2CANY+2Cmissing-method'></span><span id='topic+partialAutocorrelations+2Cts+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Methods for function partialAutocorrelations.</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "ANY", maxlag = "ANY", lag_0 = "ANY")</code></dt><dd>
</dd>
<dt><code>signature(x = "mts", maxlag = "ANY", lag_0 = "missing")</code></dt><dd>
</dd>
<dt><code>signature(x = "PartialAutocovariances", maxlag = "ANY", lag_0 = "missing")</code></dt><dd>
</dd>
<dt><code>signature(x = "ts", maxlag = "ANY", lag_0 = "missing")</code></dt><dd>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>

<hr>
<h2 id='periodogram'>Obtain the most important period lags of a time series according to 
a periodogram.</h2><span id='topic+periodogram'></span>

<h3>Description</h3>

<p>Obtain the most important period lags of a time series according to 
a periodogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>periodogram(x, ..., no.results = 20)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="periodogram_+3A_x">x</code></td>
<td>
<p>A vector containing the time series values</p>
</td></tr>
<tr><td><code id="periodogram_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code>spectrum</code></p>
</td></tr>
<tr><td><code id="periodogram_+3A_no.results">no.results</code></td>
<td>
<p>The number of results to be printed at the end. Defaults to 
the 20 most important frequencies.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using the <code>spectral</code> function, obtain spectral density estimates at a 
number of frequencies and rather than plotting, obtain the rank and 
period of the values. Return a given number of results based on the level
of interest of the user.
</p>


<h3>Value</h3>

<p>A data.frame containing the following columns:
</p>
<table role = "presentation">
<tr><td><code>rank</code></td>
<td>
<p>numeric vector containing the ranked importance of the 
frequency.</p>
</td></tr>
<tr><td><code>spectrum</code></td>
<td>
<p>estimates of the spectral density at frequencies 
corresponding to <code>freq</code>.</p>
</td></tr>
<tr><td><code>frequency</code></td>
<td>
<p>vector at which the spectral density is estimated.</p>
</td></tr>
<tr><td><code>period</code></td>
<td>
<p>vector of corresponding periods.</p>
</td></tr>
</table>

<hr>
<h2 id='plot-methods'>Plot methods in package sarima</h2><span id='topic+plot-methods'></span><span id='topic+plot+2CSampleAutocorrelations+2Cmatrix-method'></span><span id='topic+plot+2CSampleAutocorrelations+2Cmissing-method'></span><span id='topic+plot+2CSamplePartialAutocorrelations+2Cmissing-method'></span>

<h3>Description</h3>

<p>Plot methods in package sarima.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "SampleAutocorrelations", y = "matrix")</code></dt><dd>
</dd>
<dt><code>signature(x = "SampleAutocorrelations", y = "missing")</code></dt><dd>
<p>plots the sample autocorrelations with (individual) rejection limits
computed under the null hypothesis of i.i.d. (strong white noise) If
argument <code>data</code> is provided, it should be the time series from
which the autocorrelations were computed. In this case rejection
limits for null hypothesis that the time series is (garch) weak white
noise are provided, as well.
</p>
<p>Additional arguments can be supplied, see <code><a href="#topic+whiteNoiseTest">whiteNoiseTest</a></code>
the examples, and the vignettes.
</p>
</dd>
<dt><code>signature(x = "SamplePartialAutocorrelations", y =
    "missing")</code></dt><dd>
<p>plots the sample partial autocorrelations with rejection limits for
the hypotheses and controlling arguments as for <code>"SampleAutocorrelations"</code>.
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+whiteNoiseTest">whiteNoiseTest</a></code> for the computations for the rejection
levels;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
n &lt;- 5000
x &lt;- sarima:::rgarch1p1(n, alpha = 0.3, beta = 0.55, omega = 1, n.skip = 100)
x.acf &lt;- autocorrelations(x)
x.acf
x.pacf &lt;- partialAutocorrelations(x)
x.pacf

plot(x.acf)
## add limits for a weak white noise test:
plot(x.acf, data = x)

## similarly for pacf
plot(x.pacf)
plot(x.pacf, data = x)

plot(x.acf, data = x, main = "Autocorrelation test")
plot(x.pacf, data = x, main = "Partial autocorrelation test")

plot(x.acf, ylim = c(NA,1))
plot(x.acf, ylim.fac = 1.5)
plot(x.acf, data = x, ylim.fac = 1.5)
plot(x.acf, data = x, ylim = c(NA, 1))
</code></pre>

<hr>
<h2 id='prepareSimSarima'>Prepare SARIMA simulations</h2><span id='topic+prepareSimSarima'></span><span id='topic+print.simSarimaFun'></span>

<h3>Description</h3>

<p>Prepare SARIMA simulations.</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepareSimSarima(model, x = NULL, eps = NULL, n, n.start = NA,
                 xintercept = NULL, rand.gen = rnorm)

## S3 method for class 'simSarimaFun'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prepareSimSarima_+3A_model">model</code></td>
<td>
<p>an object from a suitable class or a list, see Details.</p>
</td></tr>
<tr><td><code id="prepareSimSarima_+3A_x">x</code></td>
<td>

<p>initial/before values of the time series, a list, a numeric
vector or time series, see Details.
</p>
</td></tr>
<tr><td><code id="prepareSimSarima_+3A_eps">eps</code></td>
<td>

<p>initial/before values of the innovations, a list or a numeric
vector, see Details.
</p>
</td></tr>
<tr><td><code id="prepareSimSarima_+3A_n">n</code></td>
<td>

<p>number of observations to generate, if missing an attempt is made to
infer it from <code>x</code> and <code>eps</code>.
</p>
</td></tr>
<tr><td><code id="prepareSimSarima_+3A_n.start">n.start</code></td>
<td>
<p>number of burn-in observations.
</p>
</td></tr>
<tr><td><code id="prepareSimSarima_+3A_xintercept">xintercept</code></td>
<td>

<p>non-constant intercept which may represent trend or covariate
effects.
</p>
</td></tr>
<tr><td><code id="prepareSimSarima_+3A_rand.gen">rand.gen</code></td>
<td>
<p>random number generator, defaults to N(0,1).</p>
</td></tr>
<tr><td><code id="prepareSimSarima_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>prepareSimSarima</code> does the preparatory work for simulation from
a Sarima model, given the specifications and returns a function, which
can be called as many times as needed.
</p>
<p>The variance of the innovations is specified by the model and the
simulated innovations are multiplied by the corresponding standard
deviation. So, it is expected that the random number generator
simulates from a standardised distribution.
</p>
<p>Argument <code>model</code> can be from any class representing models in the
SARIMA family, such as &quot;SarimaModel&quot;, or a list with components
suitable to be passed to =new()= for such models.
</p>
<p>The canonical form of argument <code>x</code> is a list with components
<code>before</code>, <code>init</code> and <code>main</code>. If any of these components
is missing or NULL, it is filled suitably.  Any other components of
<code>x</code> are ignored. If <code>x</code> is not a list, it is put in
component <code>main</code>. Conceptually, the three components are
concatenated in the given order, the simulated values are put in
<code>main</code> (<code>before</code> and <code>init</code> are not changed), the
<code>before</code> part is dropped and the rest is returned. In effect,
<code>before</code> and <code>init</code> can be viewed as initial values but
<code>init</code> is considered part of the generated series.
</p>
<p>The format for <code>eps</code> is the same as that of <code>x</code>. The lengths of
missing components in <code>x</code> are inferred from the corresponding
components of <code>eps</code>, and vice versa.
</p>
<p>The format for <code>xintercept</code> is the same as that of <code>x</code> and
<code>eps</code>.
</p>
<p><code>print.simSarimaFun</code> is a print method for the objects generated
by <code>prepareSimSarima</code>.
</p>


<h3>Value</h3>

<p>for <code>prepareSimSarima</code>, a function to simulate time series, see
Details.  it is typically called multiple times without arguments.
All arguments have defaults set by <code>prepareSimSarima</code>.
</p>
<table role = "presentation">
<tr><td><code>n</code></td>
<td>
<p>length of the simulated time series,</p>
</td></tr>
<tr><td><code>rand.gen</code></td>
<td>
<p>random number generator,</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>arguments for the random number generator, passed on to
<code>arima.sim</code>.</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_sarima">sim_sarima</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mo1 &lt;- list(ar = 0.9, iorder = 1, siorder = 1, nseasons = 4, sigma2 = 2)
fs1 &lt;- prepareSimSarima(mo1, x = list(before = rep(0,6)),  n = 100)
tmp1 &lt;- fs1()
tmp1
plot(ts(tmp1))

fs2 &lt;- prepareSimSarima(mo1, x = list(before = rep(1,6)),  n = 100)
tmp2 &lt;- fs2()
plot(ts(tmp2))

mo3 &lt;- mo1
mo3[["ar"]] &lt;- 0.5
fs3 &lt;- prepareSimSarima(mo3, x = list(before = rep(0,6)),  n = 100)
tmp3 &lt;- fs3()
plot(ts(tmp3))
</code></pre>

<hr>
<h2 id='rgarch1p1'>Simulate GARCH(1,1) models</h2><span id='topic+rgarch1p1'></span>

<h3>Description</h3>

<p>Simulate GARCH(1,1) models. This function is for internal purposes
to generate data for examples and testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgarch1p1(n, alpha, beta, omega, n.skip = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rgarch1p1_+3A_n">n</code></td>
<td>
<p>length of the generated time series.</p>
</td></tr>
<tr><td><code id="rgarch1p1_+3A_alpha">alpha</code></td>
<td>
<p>alpha parameters in the volatility equation.</p>
</td></tr>
<tr><td><code id="rgarch1p1_+3A_beta">beta</code></td>
<td>
<p>beta parameters in the volatility equation.</p>
</td></tr>
<tr><td><code id="rgarch1p1_+3A_omega">omega</code></td>
<td>
<p>constant term in the volatility equation.</p>
</td></tr>
<tr><td><code id="rgarch1p1_+3A_n.skip">n.skip</code></td>
<td>
<p>number of additional observation to generate at the
beginning of the time series.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rgarch1p1(100, alpha = 0.3, beta = 0.55, omega = 1, n.skip = 100)
## autocorrelations(x)
## partialAutocorrelations(x)
</code></pre>

<hr>
<h2 id='sarima'>Fit extended SARIMA models</h2><span id='topic+sarima'></span>

<h3>Description</h3>

<p>Fit extended SARIMA models, which can include lagged exogeneous
variables, general unit root non-stationary factors, multiple
periodicities, and multiplicative terms in the SARIMA
specification. The models are specified with a flexible formula syntax
and contain as special cases many models with specialised names, such
as ARMAX and reg-ARIMA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sarima(model, data = NULL, ss.method = "sarima", use.symmetry = FALSE, 
       SSinit = "Rossignol2011")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sarima_+3A_model">model</code></td>
<td>
<p>a model formula specifying the model.</p>
</td></tr>
<tr><td><code id="sarima_+3A_data">data</code></td>
<td>
<p>a list or data frame, usually can be omitted.</p>
</td></tr>
<tr><td><code id="sarima_+3A_ss.method">ss.method</code></td>
<td>
<p>state space engine to use, defaults to
<code>"sarima"</code>. (<strong>Note:</strong> this argument will
probably be renamed.)</p>
</td></tr>
<tr><td><code id="sarima_+3A_use.symmetry">use.symmetry</code></td>
<td>
<p>a logical argument indicating whether 
symmetry should be used to estimate the unit polynomial.</p>
</td></tr>
<tr><td><code id="sarima_+3A_ssinit">SSinit</code></td>
<td>
<p>method to use for computation of the stationary part of
the initial covariance matrix, one of &quot;Rossignol2011&quot;, &quot;gnb&quot;,
&quot;Gardner1980&quot;.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p><code>sarima</code> fits extended SARIMA models, which can include
exogeneous variables, general unit root non-stationary factors and
multiplicative terms in the SARIMA specification.
</p>
<p>Let <code class="reqn">\{Y_t\}</code> be a time series and <code class="reqn">f(t)</code> and <code class="reqn">g(t)</code> be
functions of time and/or (possibly lagged) exogeneous variables.
</p>
<p>An extended pure SARIMA model for <code class="reqn">Y_t</code> can be written with the
help of the backward shift operator as
</p>
<p style="text-align: center;"><code class="reqn">U(B)\Phi(B)Y_t = \Theta(B)\varepsilon_t,</code>
</p>

<p>where <code class="reqn">\{\varepsilon_t\}</code> is white noise, and 
<code class="reqn">U(z)</code>, <code class="reqn">\Phi(z)</code>, and <code class="reqn">\Theta(z)</code> are polynomials,
such that all roots of <code class="reqn">U(z)</code> are on the unit circle, while the
roots of <code class="reqn">\Phi(z)</code> and <code class="reqn">\Theta(z)</code> are outside the unit
circle. If unit roots are missing, ie <code class="reqn">U(z)\equiv 1</code>, the
model is stationary with mean zero.
</p>
<p>A reg-SARIMA or X-SARIMA model can be defined as a regression with
SARIMA residuals: 
</p>
<p style="text-align: center;"><code class="reqn">Y_t = f(t) + Y^c_t</code>
</p>

<p style="text-align: center;"><code class="reqn">U(B)\Phi(B)Y^c_t = \Theta(B)\varepsilon_t,</code>
</p>

<p>where <code class="reqn">Y^c_t = Y_t - f(t)</code> is the centred <code class="reqn">Y_t</code>.
This can be written equivalently as a single equation:
</p>
<p style="text-align: center;"><code class="reqn">U(B)\Phi(B)(Y_t - f(t)) = \Theta(B)\varepsilon_t.</code>
</p>

<p>The regression function <code class="reqn">f(t)</code> can depend on
time and/or (possibly lagged) exogeneous variables.  We call it
centering function. If <code class="reqn">Y^c_t</code> is stationary with mean zero,
<code>f(t)</code> is the mean of <code class="reqn">Y_t</code>. If <code>f(t)</code> is constant, say
<code>mu</code>, <code class="reqn">Y_t</code> is stationary with mean <code>mu</code>. Note that the
two-equation form above shows that in that case <code>mu</code> is the
intercept in the first equation, so it is perfectly reasonable to
refer to it also as intercept but to avoid confusion we reserve
the term <strong>intercept</strong> for  <code>g(t)</code> below.
</p>
<p>If the SARIMA part is stationary, then <code class="reqn">EY_t = f(t)</code>, so
<code class="reqn">f(t)</code> can be interpreted as trend. In this case the above
specification is often referred to as <strong>mean corrected form</strong> of
the model. 
</p>
<p>An alternative way to specify the regression part is to add the
regression function, say <code class="reqn">\{g(t)\}</code>, to the right-hand side of the SARIMA
equation:
</p>
<p style="text-align: center;"><code class="reqn">U(B)\Phi(B)Y_t = g(t) + \Theta(B)\varepsilon_t.</code>
</p>

<p>In the stationary case this is the classical ARMAX specification. 
This can be written in two-stage form in various ways, eg
</p>
<p style="text-align: center;"><code class="reqn">U(B)\Phi(B)Y_t = (1 - \Theta(B))\varepsilon_t + u_t,</code>
</p>

<p style="text-align: center;"><code class="reqn">u_t = g(t) + \varepsilon_t .</code>
</p>

<p>So, in a sense, g(t) is a trend associated with the residuals from the
SARIMA modelling. We refer to this form as intercept form of the
model (as opposed to the mean-corrected form discussed previously). 
</p>
<p>In general, if there are no exogeneous variables the mean-corrected
model is equivalent to some intercept model, which gives some
justification of the terminology, as well. If there are exogeneous
variables equivalence may be achievable but at the expense of
introducing more lags in the model, whish is not desirable in general.
</p>
<p>Some examples of equivalence. Let Y be a stationary SARIMA
process (<code class="reqn">U(z)=1</code>) with mean <code class="reqn">\mu</code>. Then the
mean-corrected form of the SARIMA model is 
</p>
<p style="text-align: center;"><code class="reqn">\Phi(B)(Y_t - \mu) = \Theta(B)\varepsilon_t,</code>
</p>

<p>while the intercept form is
</p>
<p style="text-align: center;"><code class="reqn">\Phi(B)Y_t = c + \Theta(B)\varepsilon_t,</code>
</p>

<p>where <code class="reqn">c = \Phi(B)\mu</code>. So, in this case the mean-corrected model
X-SARIMA model with <code class="reqn">f(t) = \mu</code> is equivalent to the
intercept model with <code class="reqn">g(t) = \Phi(B)\mu</code>.
</p>
<p>As another example, with <code class="reqn">f(t) = bt</code>, the mean-corrected model is
<code class="reqn">(1-B)(Y_t - bt) = \varepsilon_t</code>. Expanding the left-hand side
we obtain the intercept form  <code class="reqn">(1-B)Y_t = b + \varepsilon_t</code>,
which demonstrates that <code class="reqn">Y_t</code> is a random walk with drift <code class="reqn">g(t) = b</code>. 
</p>
<p><strong>Model specification</strong>
</p>
<p>Argument <code>model</code> specifies the model with a syntax similar to
other model fitting functions in <span class="rlang"><b>R</b></span>.  A formula can be given for each
of the components discussed above as <code>y ~ f | SARIMA | g</code>, where
<code>f</code>, <code>SARIMA</code> and <code>g</code> are model formulas giving the
specifications for the centering function <code>f</code>, the <code>SARIMA</code>
specification, and the intercept function <code>g</code>.  In normal use
only one of <code>f</code> or <code>g</code> will be different from zero. <code>f</code>
should always be given (use <code>0</code> to specify that it is identical
to zero), but <code>g</code> can be omitted altogether.  Sometimes we refer
to the terms specified by <code>f</code> and <code>g</code> by <code>xreg</code> and
<code>regx</code>, respectively.
</p>
<p><strong>Model formulas for trends and exogeneous regressions</strong>

</p>
<p>The formulas for the centering and intercept (ie <code>f</code> and
<code>g</code>) use the same syntax as in linear models with some additional
functions for trigonometric trends, polynomial trends and lagged
variables.
</p>
<p>Here are the available specialised terms:
</p>

<dl>
<dt>.p(d)</dt><dd>
<p>Orthogonal polynomials over <code>1:length(y)</code> of degree d
(starting from degree 1, no constant).
</p>
</dd>
<dt>t</dt><dd>
<p>Stands for <code>1:length(y)</code>. Note that powers need to be
protected by I(), e.g. <code>y ~ 1 + .t + I(.t^2)</code>.
</p>
</dd>
<dt>.cs(s, k)</dt><dd>
<p>cos/sin pair for the k-th harmonic of 2pi/s. Use vector k to
specify several harmonics.
</p>
</dd>
<dt>.B(x, lags)</dt><dd>
<p>Include lagged terms of x, <code class="reqn">B^{lags}(x[t]) = x[t - lags]</code>.
<code>lags</code> can be a vector.
If <code>x</code> is a matrix, the specified lags are taken from each
column. 
</p>
</dd>
</dl>

<p><strong>Model formulas for SARIMA models</strong>
</p>
<p>A flexible syntax is provided for the specification of the SARIMA part
of the model.  It is formed using a number of primitives for
stationary and unit root components, which have 
non-seasonal and seasonal variants. Arbitrary number of multiplicative
factors and multiple seasonalities can be specified.  
</p>
<p>The SARIMA part of the model can contain any of the following
terms. They can be repeated as needed. The first argument for all
seasonal operators is the number of seasons. 
</p>

<dl>
<dt>ar(p)</dt><dd><p>autoregression term of order p</p>
</dd>
<dt>ma(q)</dt><dd><p>moving average term of order q</p>
</dd>
<dt>sar(s,p)</dt><dd><p>seasonal autoregression term (s seasons, order p)</p>
</dd>
<dt>sma(s,q)</dt><dd><p>seasonal moving average term (s seasons, order q)</p>
</dd>
<dt>i(d)</dt><dd><p><code class="reqn">(1-B)^d</code></p>
</dd>
<dt>s(seas)</dt><dd><p>summation operator,
<code class="reqn">(1 + B + \cdots + B^{seas -1})</code>
</p>
</dd>
<dt>u(x)</dt><dd>
<p>quadratic unit root term, corresponding to a complex pair on the
unit circle. If <code class="reqn">x</code> is real, it specifies the argument of one
of the roots as a fraction of <code class="reqn">2\pi</code>. If <code class="reqn">z</code> is
complex, it is the root itself.
</p>
<p>The real roots of modulus one (1 and <code class="reqn">-1</code>) should be specified
using <code>i(1)</code> and <code>s(2)</code>, which correspond to <code class="reqn">1-B</code>
and <code class="reqn">1+B</code>, respectively.
</p>
</dd>
<dt>su(s, h)</dt><dd><p>quadratic unit root terms corresponding to seasonal
differencing factors. h specifies the desired harmonic which
should be one of 1,2, ..., [s/2]. Several harmonics can be
specified by setting h to a vector. 
</p>
</dd>    
<dt>ss(s, p)</dt><dd>
<p>seasonal summation operator,
<code class="reqn">(1 + B^s + \cdots + B^{(s-1)p})</code>
</p>
</dd>
</dl>

<p>Terms with parameters can contain additional arguments specifying
initial values, fixed parameters, and transforms. For <code>ar</code>,
<code>ma</code>, <code>sar</code>, <code>sma</code>, values of the coefficients can be
specified by an unnamed argument after the parameters given in the
descriptions above. In estimation these values will be taken as
initial values for optimisation.  By default, all coefficients are
taken to be non-fixed.
</p>
<p>Argument <code>fixed</code> can be used to fix some of them.  If it is a
logical vector it should be of length one or have the same length as
the coefficients. If <code>fixed</code> is of length one and <code>TRUE</code>, all
coefficients are fixed. If FALSE, all are non-fixed. Otherwise, the
TRUE/FALSE values in <code>fixed</code> determine the fixedness of the
corresponding coefficients.
</p>
<p><code>fixed</code> can also be a vector of positive integer numbers
specifying the indices of fixed coefficients, the rest are non-fixed.
</p>
<p>Sometimes it may be easier to declare more (e.g. all) coefficients as
fixed and then &lsquo;unfix&rsquo; selectively. Argument <code>nonfixed</code> can be
used to mark some coefficients as non-fixed after they have been
declared fixed. Its syntax is the same as for <code>fixed</code>.
</p>
<p>TODO: streamline &quot;atanh.tr&quot;
</p>
<p>TODO: describe <code>SSinit</code>
</p>


<h3>Value</h3>

<p>an object from S3 class Sarima
</p>
<p>(<strong>Note:</strong> the format of the object is still under development
and may change; use accessor functions, such as <code>coef()</code>, where provided.)
</p>


<h3>Note</h3>

<p>Currently the implementation of the intercept form (ie the third
part of the model formula) is incomplete. 
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>Halliday J, Boshnakov GN (2022).
&ldquo;Partial autocorrelation parameterisation of models with unit roots on the unit circle.&rdquo;
<a href="https://doi.org/10.48550/ARXIV.2208.05055">doi:10.48550/ARXIV.2208.05055</a>, <a href="https://arxiv.org/abs/2208.05055">https://arxiv.org/abs/2208.05055</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+arima">arima</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## AirPassengers example
## fit the classic airline model using arima()
ap.arima &lt;- arima(log(AirPassengers), order = c(0,1,1), seasonal = c(0,1,1))

## same model using two equivalent ways to specify it
ap.baseA &lt;- sarima(log(AirPassengers) ~ 
                   0 | ma(1, c(-0.3)) + sma(12,1, c(-0.1)) + i(1) + si(12,1), 
                   ss.method = "base")
ap.baseB &lt;- sarima(log(AirPassengers) ~ 
                   0 | ma(1, c(-0.3)) + sma(12,1, c(-0.1)) + i(2) + s(12), 
                   ss.method = "base")

ap.baseA
summary(ap.baseA)
ap.baseB
summary(ap.baseB)

## as above, but drop 1-B from the model:
ap2.arima &lt;- arima(log(AirPassengers), order = c(0,0,1), seasonal = c(0,1,1))
ap2.baseA &lt;- sarima(log(AirPassengers) ~ 
                    0 | ma(1, c(-0.3)) + sma(12,1, c(-0.1)) +     si(12,1), 
                    ss.method = "base")
ap2.baseB &lt;- sarima(log(AirPassengers) ~ 
                    0 | ma(1, c(-0.3)) + sma(12,1, c(-0.1)) + i(1) + s(12), 
                    ss.method = "base")

## for illustration, here the non-stationary part is 
##     (1-B)^2(1+B+...+B^5) = (1-B)(1-B^6)
##     (  compare to (1-B)(1-B^{12}) = (1-B)(1-B^6)(1+B^6) ) 
ap3.base &lt;- sarima(log(AirPassengers) ~ 
                   0 | ma(1, c(-0.3)) + sma(12,1, c(-0.1)) + i(2) + s(6), 
                   ss.method = "base")

## further unit roots, equivalent specifications for the airline model
tmp.su &lt;- sarima(log(AirPassengers) ~ 
                 0 | ma(1, c(-0.3)) + sma(12,1, c(-0.1)) + i(2) + s(2) + su(12,1:5), 
                 ss.method = "base")
tmp.su$interna$delta_poly
prod(tmp.su$interna$delta_poly)
zapsmall(coef(prod(tmp.su$interna$delta_poly)))
tmp.su

tmp.u &lt;- sarima(log(AirPassengers) ~ 
                0 | ma(1, c(-0.3)) + sma(12,1, c(-0.1)) + i(2) + s(2) + u((1:5)/12), 
                ss.method = "base")
tmp.u
</code></pre>

<hr>
<h2 id='sarima.f'>
Function used internally to compute forecasts
</h2><span id='topic+sarima.f'></span>

<h3>Description</h3>

<p>Function used internally to compute forecasts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sarima.f(past = numeric(length(ar)), n = max(2 * length(past), 12),
         ar = numeric(0), ma = numeric(0), intercept = 0,
         pasteps = numeric(length(ma)), trend = numeric(n))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sarima.f_+3A_past">past</code></td>
<td>
<p>past values of the time series.</p>
</td></tr>
<tr><td><code id="sarima.f_+3A_n">n</code></td>
<td>
<p>number of forecasts to generate.</p>
</td></tr>
<tr><td><code id="sarima.f_+3A_ar">ar</code></td>
<td>
<p>ar coefficients.</p>
</td></tr>
<tr><td><code id="sarima.f_+3A_ma">ma</code></td>
<td>
<p>ma coefficients.</p>
</td></tr>
<tr><td><code id="sarima.f_+3A_intercept">intercept</code></td>
<td>
<p>intercept.</p>
</td></tr>
<tr><td><code id="sarima.f_+3A_pasteps">pasteps</code></td>
<td>
<p>past values of the innovations.</p>
</td></tr>
<tr><td><code id="sarima.f_+3A_trend">trend</code></td>
<td>
<p>trend.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes predictions using the specified parameters and past values.
<code>ar</code> and <code>ma</code> are the coefficients of the fully expanded
polynomials of a SARIMA mmodel.
</p>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>

<hr>
<h2 id='SarimaModel-class'>Class SarimaModel in package sarima</h2><span id='topic+SarimaModel-class'></span>

<h3>Description</h3>

<p>Class SarimaModel in package sarima.</p>


<h3>Objects from the Class</h3>

<p>Class <code>"SarimaModel"</code> represents standard SARIMA models.  Objects
can be created by calls of the form
<code>new("SarimaModel", ..., ar, ma, sar, sma)</code>,
using named arguments in the form <code>slotname = value</code>, where
<code>slotname</code> is one of the slots, see below.  The arguments have
natural defaults. It may be somewhat surprising though that the
default for the variance of the innovations (slot <code>"sigma2"</code>) is
<code>NA</code>. The rationale for this choice is that for some calculations
the innovations' variance is not needed and, more importantly, it is
far too easy to forget to include it in the model (at least for the
author) when the variance matters. The latter may may lead silently to
wrong results if the &quot;natural&quot; default value of one is used when
<code>sigma2</code> matters.
</p>
<p>The models may be specified in intercept (<code>center = 0</code>) or
mean-corrected (<code>intercept = 0</code>) form. Setting both to non-zero
values is accepted but rarely needed.
</p>
<p>If you waih to modify an existing object from class
<code>"SarimaModel"</code>, give it as an unnamed argument to <code>"new"</code>
and specify only the slots to be changed, see the examples.
</p>
<p>Use <code><a href="#topic+as.SarimaModel">as.SarimaModel</a></code> to convert a model fitted with
<code>stats::arima()</code> to <code>"SarimaModel"</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>center</code>:</dt><dd><p>Object of class <code>"numeric"</code>,
a number, the ARIMA equation is for <code>X(t) - center</code>.
</p>
</dd>
<dt><code>intercept</code>:</dt><dd><p>Object of class <code>"numeric"</code>,
a number, the intercept in the ARIMA equation.
</p>
</dd>
<dt><code>sigma2</code>:</dt><dd><p>Object of class <code>"numeric"</code>,
a positive number, the innovations variance.
</p>
</dd>
<dt><code>nseasons</code>:</dt><dd><p>Object of class <code>"numeric"</code>,
a positive integer, the number of seasons. For non-seasonal models
this is NA.
</p>
</dd>
<dt><code>iorder</code>:</dt><dd><p>Object of class <code>"numeric"</code>,
non-negative integer, the integration order.
</p>
</dd>
<dt><code>siorder</code>:</dt><dd><p>Object of class <code>"numeric"</code>,
non-negative integer, the seasonal integration order.
</p>
</dd>
<dt><code>ar</code>:</dt><dd><p>Object of class <code>"BJFilter"</code>,
the non-seasonal AR part of the model.
</p>
</dd>
<dt><code>ma</code>:</dt><dd><p>Object of class <code>"SPFilter"</code>,
the non-seasonal MA part of the model.
</p>
</dd>
<dt><code>sar</code>:</dt><dd><p>Object of class <code>"BJFilter"</code>,
the seasonal AR part of the model.
</p>
</dd>
<dt><code>sma</code>:</dt><dd><p>Object of class <code>"SPFilter"</code>,
the seasonal MA part of the model.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+VirtualFilterModel-class">VirtualFilterModel</a>"</code>, directly.
Class <code>"<a href="#topic+SarimaSpec-class">SarimaSpec</a>"</code>, directly.
Class <code>"<a href="#topic+SarimaFilter-class">SarimaFilter</a>"</code>, by class &quot;SarimaSpec&quot;, distance 2.
Class <code>"<a href="#topic+VirtualSarimaFilter-class">VirtualSarimaFilter</a>"</code>, by class &quot;SarimaSpec&quot;, distance 3.
Class <code>"<a href="#topic+VirtualCascadeFilter-class">VirtualCascadeFilter</a>"</code>, by class &quot;SarimaSpec&quot;, distance 4.
Class <code>"<a href="#topic+VirtualMonicFilter-class">VirtualMonicFilter</a>"</code>, by class &quot;SarimaSpec&quot;, distance 5.
</p>


<h3>Methods</h3>

<p>SARIMA models contain as special cases a number of models.
The one-argument method of <code>modelCoef</code> is essentially a
definition of model coefficients for SARIMA models. The two-argument
methods request the model coefficients according to the convention of
the class of the second argument. The second argument may also be a
character string naming the target class.
</p>
<p>Essentially, the methods for <code>modelCoef</code> are a generalisation of
<code>as()</code> methods and can be interpreted as such (to an extent, the
result is not necessarilly from the target class, not least because
the target class may be virtual).
</p>

<dl>
<dt>modelCoef</dt><dd><p><code>signature(object = "SarimaModel", convention = "missing")</code>:
Converts <code>object</code> to &quot;SarimaFilter&quot;.
</p>
</dd>
<dt>modelCoef</dt><dd><p><code>signature(object = "SarimaModel", convention = "SarimaFilter")</code>:
Converts <code>object</code> to &quot;SarimaFilter&quot;, equivalent to the
one-argument call <code>modelCoef(object)</code>.
</p>
</dd>
<dt>modelCoef</dt><dd><p><code>signature(object = "SarimaModel", convention	= "ArFilter")</code>:
Convert <code>object</code> to &quot;ArFilter&quot;. An error is raised if
<code>object</code> has non-trivial moving average part.
</p>
</dd>
<dt>modelCoef</dt><dd><p><code>signature(object = "SarimaModel", convention	= "MaFilter")</code>:
Convert <code>object</code> to &quot;MaFilter&quot;. An error is raised if
<code>object</code> has non-trivial autoregressive part.
</p>
</dd>
<dt>modelCoef</dt><dd><p><code>signature(object = "SarimaModel", convention	= "ArmaFilter")</code>:
Convert <code>object</code> to &quot;ArmaFilter&quot;. This operation always successeds.
</p>
</dd>
<dt>modelCoef</dt><dd><p><code>signature(object = "SarimaModel", convention	= "character")</code>:
The second argument gives the name of the target class.
This is conceptually equivalent to <code>modelCoef(object, new(convention))</code>.
</p>
</dd>
</dl>

<p><code>modelOrder</code> gives the order of the model according to the
conventions of the target class. An error is raised if <code>object</code>
is not compatible with the target class.
</p>

<dl>
<dt>modelOrder</dt><dd><p><code>signature(object = "SarimaModel", convention = "ArFilter")</code>: ... </p>
</dd>
<dt>modelOrder</dt><dd><p><code>signature(object = "SarimaModel", convention = "ArmaFilter")</code>: ... </p>
</dd>
<dt>modelOrder</dt><dd><p><code>signature(object = "SarimaModel", convention = "ArmaModel")</code>: ... </p>
</dd>
<dt>modelOrder</dt><dd><p><code>signature(object = "SarimaModel", convention = "ArModel")</code>: ... </p>
</dd>
<dt>modelOrder</dt><dd><p><code>signature(object = "SarimaModel", convention = "MaFilter")</code>: ... </p>
</dd>
<dt>modelOrder</dt><dd><p><code>signature(object = "SarimaModel", convention = "MaModel")</code>: ... </p>
</dd>
<dt>modelOrder</dt><dd><p><code>signature(object = "SarimaModel", convention = "missing")</code>: ... </p>
</dd>
</dl>

<p>The polynomials associated with <code>object</code> can be obtained with the
following methods. Note that target &quot;ArmaFilter&quot; gives the fully
expanded products of the AR and MA polynomials, as needed, e.g., for
filtering.
</p>

<dl>
<dt>modelPoly</dt><dd><p><code>signature(object = "SarimaModel", convention = "ArmaFilter")</code>:
'      Gives the fully expanded polynomials as a list
</p>
</dd>
<dt>modelPoly</dt><dd><p><code>signature(object = "SarimaModel", convention = "missing")</code>:
Gives the polynomials associated with the model as a list.
</p>
</dd>
<dt>modelPolyCoef</dt><dd><p><code>signature(object = "SarimaModel", convention = "ArmaFilter")</code>:
Give the coefficients of the fully expanded polynomials as a list.
</p>
</dd>
<dt>modelPolyCoef</dt><dd><p><code>signature(object = "SarimaModel", convention = "missing")</code>:
Gives the coefficients of the polynomials associated with the model as a list.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+ArmaModel-class">ArmaModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ar1 &lt;- new("SarimaModel", ar = 0.9)
ar1c &lt;- new("SarimaModel", ar = 0.9, intercept = 3)
ar1c
ar1m &lt;- new("SarimaModel", ar = 0.9, center = 1)
ar1m

sm0 &lt;- new("SarimaModel", nseasons = 12)
sm1 &lt;- new("SarimaModel", nseasons = 12, intercept = 3)
sm1
## alternatively, pass a model and modify with named arguments
sm1b &lt;- new("SarimaModel", sm0, intercept = 3)
identical(sm1, sm1b) # TRUE

## in the above models sigma2 is NA

## sm2 - from scratch, the rest modefy an existing model
sm2  &lt;- new("SarimaModel", ar = 0.9, nseasons = 12, intercept = 3, sigma2 = 1)
sm2a &lt;- new("SarimaModel", sm0, ar = 0.9, intercept = 3, sigma2 = 1)
sm2b &lt;- new("SarimaModel", sm1, ar = 0.9, sigma2 = 1)
sm2c &lt;- new("SarimaModel", ar1c, nseasons =12, sigma2 = 1)
identical(sm2, sm2a) # TRUE
identical(sm2, sm2b) # TRUE
identical(sm2, sm2c) # TRUE

sm3 &lt;- new("SarimaModel", ar = 0.9, sar = 0.8, nseasons = 12, intercept = 3,
           sigma2 = 1)
sm3b &lt;- new("SarimaModel", sm2, sar = 0.8)
identical(sm3, sm3b) # TRUE

## The classic 'airline model' (from examples for AirPassengers)
(fit &lt;- arima(log10(AirPassengers), c(0, 1, 1),
              seasonal = list(order = c(0, 1, 1), period = 12)))

as.SarimaModel(fit)
</code></pre>

<hr>
<h2 id='se'>Compute standard errors</h2><span id='topic+se'></span><span id='topic+vcov'></span><span id='topic+vcov+2CSampleAutocorrelations-method'></span>

<h3>Description</h3>

<p>Compute standard errors.</p>


<h3>Usage</h3>

<pre><code class='language-R'>se(object, ...)

## S4 method for signature 'SampleAutocorrelations'
vcov(object, assuming = "iid", maxlag = maxLag(object), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="se_+3A_object">object</code></td>
<td>

<p>an object containing estimates, such as a fitted model.
</p>
</td></tr>
<tr><td><code id="se_+3A_...">...</code></td>
<td>

<p>further arguments for <code>vcov</code>.
</p>
</td></tr>
<tr><td><code id="se_+3A_assuming">assuming</code></td>
<td>

<p>under what assumptions to do the computations?
Currently can be <code>"iid"</code>, <code>"garch"</code>, a fitted model, or a
theoretical model, see Details.
</p>
</td></tr>
<tr><td><code id="se_+3A_maxlag">maxlag</code></td>
<td>
<p>maximal lag to include</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>se</code> is a convenience function for the typical case where only the
square root of the diagonal of the variance-covariance matrix is
needed.
</p>
<p>The method for <code>vcov</code> gives the variance-covariance matrix of the
first <code>maxlag</code> autocorrelation coefficients in the object. The
result depends on the underlying assumptions and the method of
calculation. These can be specifyed with the additional arguments.
</p>
<p>Argument <code>"assuming"</code> can be though also as specifying a null
hypothesis. Setting it to <code>"iid"</code> or <code>"garch"</code> corresponds
to strong white noise (iid) and weak white noise, respectively. 
</p>
<p>Setting <code>"assuming"</code> to an ARMA model (theoretical or fitted)
specifies that as the null model. 
</p>
<p><b>Note:</b> The method for <code>vcov</code> is not finalised yet. It is
used by a method for <code><a href="#topic+confint">confint</a></code>.  Bug
reports and requests on the github repo may bring this closer to the
top of my task list.
</p>


<h3>Value</h3>

<p>for <code>se</code>, a numeric vector giving standard errors;
</p>
<p>for the <code>vcov</code> method, a square matrix
</p>


<h3>See Also</h3>

<p><code>link{confint}</code>,
<code><a href="stats.html#topic+vcov">vcov</a></code>
</p>

<hr>
<h2 id='show-methods'>Methods for <code>show</code> in package <span class="pkg">sarima</span></h2><span id='topic+show-methods'></span><span id='topic+show+2CArmaFilter-method'></span><span id='topic+show+2CArmaModel-method'></span><span id='topic+show+2CArModel-method'></span><span id='topic+show+2CAutocorrelations-method'></span><span id='topic+show+2CAutocovariances-method'></span><span id='topic+show+2CBJFilter-method'></span><span id='topic+show+2CInterceptSpec-method'></span><span id='topic+show+2CMaModel-method'></span><span id='topic+show+2CMonicFilterSpec-method'></span><span id='topic+show+2CPartialAutocorrelations-method'></span><span id='topic+show+2CPartialAutocovariances-method'></span><span id='topic+show+2CPartialVariances-method'></span><span id='topic+show+2CSampleAutocorrelations-method'></span><span id='topic+show+2CSampleAutocovariances-method'></span><span id='topic+show+2CSamplePartialAutocorrelations-method'></span><span id='topic+show+2CSamplePartialAutocovariances-method'></span><span id='topic+show+2CSamplePartialVariances-method'></span><span id='topic+show+2CSarimaFilter-method'></span><span id='topic+show+2CSarimaModel-method'></span><span id='topic+show+2CSPFilter-method'></span><span id='topic+show+2CVirtualArmaFilter-method'></span>

<h3>Description</h3>

<p>Methods for <code>show</code> in package <span class="pkg">sarima</span>.</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "ArmaFilter")</code></dt><dd>
</dd>
<dt><code>signature(object = "ArmaModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "ArModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "Autocorrelations")</code></dt><dd>
</dd>
<dt><code>signature(object = "Autocovariances")</code></dt><dd>
</dd>
<dt><code>signature(object = "BJFilter")</code></dt><dd>
</dd>
<dt><code>signature(object = "InterceptSpec")</code></dt><dd>
</dd>
<dt><code>signature(object = "MaModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "MonicFilterSpec")</code></dt><dd>
</dd>
<dt><code>signature(object = "PartialAutocorrelations")</code></dt><dd>
</dd>
<dt><code>signature(object = "PartialAutocovariances")</code></dt><dd>
</dd>
<dt><code>signature(object = "PartialVariances")</code></dt><dd>
</dd>
<dt><code>signature(object = "SampleAutocorrelations")</code></dt><dd>
</dd>
<dt><code>signature(object = "SampleAutocovariances")</code></dt><dd>
</dd>
<dt><code>signature(object = "SamplePartialAutocorrelations")</code></dt><dd>
</dd>
<dt><code>signature(object = "SamplePartialAutocovariances")</code></dt><dd>
</dd>
<dt><code>signature(object = "SamplePartialVariances")</code></dt><dd>
</dd>
<dt><code>signature(object = "SarimaFilter")</code></dt><dd>
</dd>
<dt><code>signature(object = "SarimaModel")</code></dt><dd>
</dd>
<dt><code>signature(object = "Spectrum")</code></dt><dd>
</dd>
<dt><code>signature(object = "SPFilter")</code></dt><dd>
</dd>
<dt><code>signature(object = "VirtualArmaFilter")</code></dt><dd>
</dd>
</dl>

<hr>
<h2 id='sigmaSq'>Get the innovation variance of models</h2><span id='topic+sigmaSq'></span><span id='topic+sigmaSq-methods'></span><span id='topic+sigmaSq+2CInterceptSpec-method'></span>

<h3>Description</h3>

<p>Get the innovation variance of models.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigmaSq(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sigmaSq_+3A_object">object</code></td>
<td>
<p>an object from a suitable class.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sigmaSq()</code> gives the innovation variance of objects from classes
for which it makes sense, such as ARMA models.
</p>
<p>The value depends on the class of the object, e.g. for ARMA models it
is a scalar in the univariate case and a matrix in the multivariate one.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "InterceptSpec")</code></dt><dd>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>

<hr>
<h2 id='sim_sarima'>
Simulate trajectories of seasonal arima models
</h2><span id='topic+sim_sarima'></span>

<h3>Description</h3>

<p>Simulate trajectories of seasonal arima models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_sarima(model, n = NA, rand.gen = rnorm, n.start = NA, x, eps,
           xcenter = NULL, xintercept = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_sarima_+3A_model">model</code></td>
<td>

<p>specification of the model, a list or a model object, see &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="sim_sarima_+3A_rand.gen">rand.gen</code></td>
<td>

<p>random number generator for the innovations.
</p>
</td></tr>
<tr><td><code id="sim_sarima_+3A_n">n</code></td>
<td>
<p>length of the time series.</p>
</td></tr>
<tr><td><code id="sim_sarima_+3A_n.start">n.start</code></td>
<td>
<p>number of burn-in observations.</p>
</td></tr>
<tr><td><code id="sim_sarima_+3A_x">x</code></td>
<td>

<p>initial/before values of the time series, a list, a numeric
vector or time series, see Details.
</p>
</td></tr>
<tr><td><code id="sim_sarima_+3A_eps">eps</code></td>
<td>

<p>initial/before values of the innovations, a list or a numeric
vector, see Details.
</p>
</td></tr>
<tr><td><code id="sim_sarima_+3A_xintercept">xintercept</code></td>
<td>

<p>non-constant intercept which may represent trend or covariate
effects.
</p>
</td></tr>
<tr><td><code id="sim_sarima_+3A_xcenter">xcenter</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
<tr><td><code id="sim_sarima_+3A_...">...</code></td>
<td>
<p>additional arguments for <code>arima.sim</code> and
<code>rand.gen</code>, see &lsquo;Details&rsquo;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model can be specified by a model object, e.g., from class
<a href="#topic+SarimaModel-class">SarimaModel</a>. It can also be a list with elements
suitable to be passed to <code>new("SarimaModel", ...)</code>, see the
description of class <code>"SarimaModel"</code>. Here are some of the
possible components:
</p>

<dl>
<dt>nseasons</dt><dd><p>number of seasons in a year (or whatever is the larger
time unit)</p>
</dd>
<dt>iorder</dt><dd><p>order of differencing, specifies the factor
<code class="reqn">(1-B)^{d1}</code> for the model.
</p>
</dd>
<dt>siorder</dt><dd><p>order of seasonal differencing, specifies the factor
<code class="reqn">(1-B^{period})^{ds}</code>  for the model.</p>
</dd>
<dt>ar</dt><dd><p>ar parameters (non-seasonal)</p>
</dd>
<dt>ma</dt><dd><p>ma parameters (non-seasonal)</p>
</dd>
<dt>sar</dt><dd><p>seasonal ar parameters</p>
</dd>
<dt>sma</dt><dd><p>seasonal ma parameters</p>
</dd>
</dl>

<p>Additional arguments for <code>rand.gen</code> may be specified via the
&quot;...&quot; argument.  In particular, the length of the generated series
is specified with argument <code>n</code>. Arguments for <code>rand.gen</code> can
also be passed via the &quot;...&quot; argument.
</p>
<p>If the model is stationary the generated time series is stationary
starting with the first value. In particular, there is no need for a
&lsquo;warm-up&rsquo; period.
</p>
<p>Information about the model is printed on the screen if
<code>info = "print"</code>. To suppress this, set <code>info</code> to any other
value.
</p>
<p>For multple simulations with the same (or almost the same) setup, it is
better to execute <code><a href="#topic+prepareSimSarima">prepareSimSarima</a></code> once and call the
function returned by it as many times as needed. 
</p>


<h3>Value</h3>

<p>an object of class &quot;ts&quot;, a simulated time series from the given model
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'>require("PolynomF") # guaranteed to be available since package "sarima" imports it.

x &lt;- sim_sarima(n=144, model = list(ma=0.8))               # MA(1)
x &lt;- sim_sarima(n=144, model = list(ar=0.8))               # AR(1)

x &lt;- sim_sarima(n=144, model = list(ar=c(rep(0,11),0.8)))  # SAR(1), 12  seasons
x &lt;- sim_sarima(n=144, model = list(ma=c(rep(0,11),0.8)))  # SMA(1)

                                  # more enlightened SAR(1) and SMA(1)
x &lt;- sim_sarima(n=144,model=list(sar=0.8, nseasons=12, sigma2 = 1))  # SAR(1), 12 seasons
x &lt;- sim_sarima(n=144,model=list(sma=0.8, nseasons=12, sigma2 = 1))  # SMA(1)

x &lt;- sim_sarima(n=144, model = list(iorder=1, sigma2 = 1)) # (1-B)X_t = e_t (random walk)
acf(x)
acf(diff(x))

x &lt;- sim_sarima(n=144, model = list(iorder=2, sigma2 = 1))  # (1-B)^2 X_t = e_t
x &lt;- sim_sarima(n=144, model = list(siorder=1,
                                    nseasons=12, sigma2 = 1)) # (1-B)^{12} X_t = e_t

x &lt;- sim_sarima(n=144, model = list(iorder=1, siorder=1,
                                    nseasons=12, sigma2 = 1))
x &lt;- sim_sarima(n=144, model = list(ma=0.4, iorder=1, siorder=1,
                                    nseasons=12, sigma2 = 1))
x &lt;- sim_sarima(n=144, model = list(ma=0.4, sma=0.7, iorder=1, siorder=1,
                                    nseasons=12, sigma2 = 1))

x &lt;- sim_sarima(n=144, model = list(ar=c(1.2,-0.8), ma=0.4,
                                    sar=0.3, sma=0.7, iorder=1, siorder=1,
                                    nseasons=12, sigma2 = 1))

x &lt;- sim_sarima(n=144, model = list(iorder=1, siorder=1,
                                    nseasons=12, sigma2 = 1),
                x = list(init=AirPassengers[1:13]))

p &lt;- polynom(c(1,-1.2,0.8))
solve(p)
abs(solve(p))

sim_sarima(n=144, model = list(ar=c(1.2,-0.8), ma=0.4, sar=0.3, sma=0.7,
                               iorder=1, siorder=1, nseasons=12))

x &lt;- sim_sarima(n=144, model=list(ma=0.4, iorder=1, siorder=1, nseasons=12))
acf(x, lag.max=48)
x &lt;- sim_sarima(n=144, model=list(sma=0.4, iorder=1, siorder=1, nseasons=12))
acf(x, lag.max=48)
x &lt;- sim_sarima(n=144, model=list(sma=0.4, iorder=0, siorder=0, nseasons=12))
acf(x, lag.max=48)
x &lt;- sim_sarima(n=144, model=list(sar=0.4, iorder=0, siorder=0, nseasons=12))
acf(x, lag.max=48)
x &lt;- sim_sarima(n=144, model=list(sar=-0.4, iorder=0, siorder=0, nseasons=12))
acf(x, lag.max=48)

x &lt;- sim_sarima(n=144, model=list(ar=c(1.2, -0.8), ma=0.4, sar=0.3, sma=0.7,
                                  iorder=1, siorder=1, nseasons=12))
## use xintercept to include arbitrary trend/covariates
sim_sarima(n = 144, model = list(sma = 0.4, ma = 0.4, sar = 0.8, ar = 0.5, 
    nseasons = 12, sigma2 = 1), xintercept = 1:144)
</code></pre>

<hr>
<h2 id='spectrum'>Spectral Density</h2><span id='topic+spectrum'></span><span id='topic+spec'></span><span id='topic+spectrum.default'></span><span id='topic+spectrum.Arima'></span><span id='topic+spectrum.ArmaModel'></span><span id='topic+spectrum.SarimaModel'></span><span id='topic+spectrum+2CANY-method'></span><span id='topic+spectrum+2CArmaModel-method'></span><span id='topic+spectrum+2CSarimaModel-method'></span><span id='topic+print.genspec'></span><span id='topic+spectrum.function'></span>

<h3>Description</h3>

<p>Estimate the spectral density of a time series or compute the spectral
density associated with a time series model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectrum(x, standardize = TRUE, ...)

## Default S3 method:
spectrum(x, standardize = TRUE, raw = TRUE, taper = 0.1, 
         demean = FALSE, detrend = TRUE, ...)

## S3 method for class 'genspec'
print(x, n.head = min(length(x$spec), 6), sort = TRUE, ...)

## S3 method for class 'Arima'
spectrum(x, standardize = TRUE, ...)

## S3 method for class 'ArmaModel'
spectrum(x, standardize = TRUE, ...)

## S3 method for class 'SarimaModel'
spectrum(x, standardize = TRUE, ...)

## S3 method for class 'function'
spectrum(x, standardize = TRUE, param = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spectrum_+3A_x">x</code></td>
<td>

<p>a model or a univariate or multivariate time series.
</p>
</td></tr>
<tr><td><code id="spectrum_+3A_standardize">standardize</code></td>
<td>

<p>if <code>TRUE</code>, the default method standardises the time series
before computing the periodogram, while the methods for models scale
the spectral density so that it is a probability density function.
</p>
</td></tr>
<tr><td><code id="spectrum_+3A_raw">raw</code></td>
<td>

<p>if <code>TRUE</code>, the default, compute a completely raw periodogram,
unless further arguments request otherwise, see section Details.
</p>
</td></tr>
<tr><td><code id="spectrum_+3A_taper">taper</code>, <code id="spectrum_+3A_demean">demean</code>, <code id="spectrum_+3A_detrend">detrend</code></td>
<td>

<p>see <code><a href="stats.html#topic+spec.pgram">spec.pgram</a></code> and section &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="spectrum_+3A_...">...</code></td>
<td>

<p>further arguments for the default method. Currently not used by
other methods.
</p>
</td></tr>
<tr><td><code id="spectrum_+3A_n.head">n.head</code></td>
<td>
<p>how many rows to print?</p>
</td></tr>
<tr><td><code id="spectrum_+3A_sort">sort</code></td>
<td>
<p><code>TRUE</code>, <code>FALSE</code> or <code>"max"</code>, see section &lsquo;Details'&rsquo;.</p>
</td></tr>
<tr><td><code id="spectrum_+3A_param">param</code></td>
<td>

<p>a named list, specying model parameters for the <code>"function"</code>
method, see section &lsquo;Details&rsquo;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>spectrum</code> in package <span class="pkg">sarima</span> is a generic function with a
default method its namesake in package <span class="pkg">stats</span>, see
<code><a href="stats.html#topic+spectrum">spectrum</a></code> for a full description of its
functionality.
</p>
<p>Autoprinting of objects returned by <code>spectrum</code> prints concise
information and plots the spectrum. This means that a plot is
produced, for example, when the result of a call to <code>spectrum()</code>
is not assigned to a variable or if a command containing just the name
of the object is executed. If you don't want the graph, just assign
the result to a variable. For more control over the printing (for
example, number of digits) use <code>print(object, ...)</code>
explicitly. In that case no plot is produced. If additional graphical
parameters are desired, call <code>plot, ...</code>.
</p>
<p>All methods print some basic information about the object and a table
giving the most influential frequencies and their contributions to the
spectrum.
</p>
<p>Methods for objects representing ARIMA and SARIMA models (fitted or
theoretical) compute the corresponding spectral densities. For
non-stationary models, the spectral density for the stationary part.
These methods for <code>spectrum</code> return objects from class
<code>"Spectrum"</code>.  If <code>standardize = TRUE</code> the spectral density
is scaled, so that it integrates to one (and so is a probability
density function).  For fitted models confidence bands are not
computed currently.
</p>
<p>The method for class <code>"function"</code> can be used to create objects
from class <code>"Spectrum"</code> using a user specified function. The
first argument of that function needs to be a vector of frequencies
for which to calculate the spectrum. It is conventionally called
<code>freq</code> but this is not required.  If there are parameters they
should not be part of the signature of the function but need to be
listed and given values as a named list via argument <code>param</code>, see
the examples for class <code>"<a href="#topic+Spectrum-class">Spectrum</a>"</code>. This method is
somewhat experimental but the restrictions might be relaxed in a
future release.
</p>
<p>The rest of this section describes the default method. For futher
details on the other methods see <code>"<a href="#topic+Spectrum-class">Spectrum</a>"</code>.
</p>


<h4>The default method for <code>spectrum</code></h4>

<p>The default method is a wrapper for <code>stats::spectrum()</code>.
</p>
<p>The default method returns an object from class &quot;genspec&quot;. It
inherits from <code>"spec"</code>, the class returned by
<code>stats::spectrum</code>, and adds some additional components. The
main difference though is that it has a print method, which plots
the object as discussed above.  <code>raw = FALSE</code> with no further
arguments is equivalent to <code>stats::spectrum(object)</code> and
computes a raw periodogram (for the standardised time series if
<code>standardize = TRUE</code>). This still detrends and tapers the
series though.  <code>raw = TRUE</code> sets <code>detrend</code> to
<code>FALSE</code>, <code>taper</code> to zero, and <code>demean</code> to
<code>TRUE</code>, to compute a &lsquo;completely raw&rsquo; periodogram. In
both cases, further arguments are respected.
</p>
<p>Argument <code>sort</code> of the <code>print</code> method for <code>"genspec"</code>
controls the sorting order of the columns of the printed table. If
<code>FALSE</code>, no sorting is done.  If <code>TRUE</code>, the spectrum is
sorted in decreasing order, so the first row contains the frequency
with the highest value of the spectrum. If <code>"max"</code>, the local
maxima are found and sorted in decreasing order, followed by the
rest, also sorted in decreasing order. Note that due to aliasing the
local maxima may be shifted from the &ldquo;true&rdquo; frequency
(e.g. not be exactly on the harmonics of the number of
seasons). Tapering and smoothing parameters may help.
</p>
<p>The plot method for class <code>"genspec"</code> is inherited from that
for <code>"spec"</code>, see <code>?plot.spec</code>.
</p>



<h3>Value</h3>

<p>for the default method, an object of class <code>"genspec"</code>, which
inherits from <code>"spec"</code>, and contains the following additional
components:
</p>
<table role = "presentation">
<tr><td><code>standardized</code></td>
<td>
<p>TRUE or FALSE,</p>
</td></tr>
<tr><td><code>nseasons</code></td>
<td>
<p>number of seasons,</p>
</td></tr>
<tr><td><code>freq.range</code></td>
<td>
<p><code>numeric(2)</code>, the frequency range - <code style="white-space: pre;">&#8288;(-m/2, m/2]&#8288;</code>,
where <code>m = floor(frequency(x))</code>;</p>
</td></tr>
</table>
<p>for the remaining methods, an object of class <code>"<a href="#topic+Spectrum-class">Spectrum</a>"</code>.  
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+spectrum">spectrum</a></code> which is called by the default method to
do the work.
</p>
<p>class <code>"<a href="#topic+Spectrum-class">Spectrum</a>"</code> for further details on the
methods for objects returned by <code>spectrum()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## spectral density of the stationary part of a fitted 'airline model'
fit0 &lt;- arima(AirPassengers, order = c(0,1,1),
              seasonal = list(order = c(0,1,1), period = 12))
spectrum(fit0)

## spectral densities of some ARMA models models from Chan and Gray ().
##   (TODO: complete the reference)
spectrum(ArmaModel(ma = c(-1, 0.6), sigma2 = 1))
spectrum(ArmaModel(ar = 0.5, sigma2 = 1))
spectrum(ArmaModel(ar = 0.5, ma = -0.8, sigma2 = 1))
spectrum(new("SarimaModel", ar = 0.5, sar = 0.9, nseasons = 12, sigma2 = 1))

mo &lt;- new("SarimaModel", ma = -0.4, sma = -0.9, nseasons = 12, sigma2 = 1)
sp1.mo &lt;- spectrum(mo)
## this also plots the object.  (if you are reading the web version, generated
##     by pkgdown, it may not be showing some of the graphs,
##     I haven't figured out why.)
show(sp1.mo)  # equivalently, just sp1.mo

print(sp1.mo)
print(sp1.mo, digits = 4)
plot(sp1.mo)
plot(sp1.mo, standardize = FALSE)

## the object can be used as a function:
head(sp1.mo())
sp1.mo(seq(0, 0.5, length.out = 12))
sp1.mo(seq(0, 0.5, length.out = 12), standardize = FALSE)

sarima1b &lt;- new("SarimaModel", ar = 0.9, ma = 0.1, sar = 0.5, sma = 0.9,
                nseasons = 12, sigma2 = 1)
spectrum(sarima1b)

## default method for spectrum()

## frequency range is c(-1/2, 1/2] since frequency(x) = 1
frequency(lh)
spectrum(lh)

## frequency range is c(-12/2, 12/2] since frequency(x) = 12
frequency(ldeaths)
( sp &lt;- spectrum(ldeaths) )
print(sp) # equivalently: print(sp, sort = TRUE)
print(sp, sort = FALSE, n.head = 3)
print(sp, sort = "max")
plot(sp)
plot(sp, log = "dB")  # see ?plot.spec for further arguments
</code></pre>

<hr>
<h2 id='Spectrum-class'>Class <code>"Spectrum"</code></h2><span id='topic+Spectrum-class'></span><span id='topic+plot+2CSpectrum+2CANY-method'></span><span id='topic+show+2CSpectrum-method'></span><span id='topic+plot.Spectrum'></span><span id='topic+print.Spectrum'></span>

<h3>Description</h3>

<p>Objects from class <code>"Spectrum"</code> spectra computed by
<code><a href="#topic+spectrum">spectrum</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Spectrum'
print(x, ..., n = 128, standardize = TRUE)

## S3 method for class 'Spectrum'
plot(x, y, to, from = y, n = 128, standardize = TRUE,
    log = NULL, main = "Spectral density", xlab = "Frequency", ylab = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Spectrum-class_+3A_x">x</code></td>
<td>
<p>a <code>"Spectrum"</code> object.</p>
</td></tr>
<tr><td><code id="Spectrum-class_+3A_y">y</code></td>
<td>
<p>not used but same as <code>from</code></p>
</td></tr>
<tr><td><code id="Spectrum-class_+3A_from">from</code>, <code id="Spectrum-class_+3A_to">to</code></td>
<td>

<p>interval of frequencies to plot, defaults to <code class="reqn">[0,1/2]</code>.
</p>
</td></tr>
<tr><td><code id="Spectrum-class_+3A_n">n</code></td>
<td>

<p>number of points to plot (for the plot method), number of points to
look at for the peaks and troughs (print method).
</p>
</td></tr>
<tr><td><code id="Spectrum-class_+3A_standardize">standardize</code></td>
<td>

<p>if <code>TRUE</code> make the spectral density integrate to one (i.e., be
a probability density function).
</p>
</td></tr>
<tr><td><code id="Spectrum-class_+3A_log">log</code></td>
<td>

<p>if <code>log = "y"</code> plot the logarithm of the spectral density, see
<code>?plot.default</code>.
</p>
</td></tr>
<tr><td><code id="Spectrum-class_+3A_main">main</code></td>
<td>

<p>a character string, the title of the plot.
</p>
</td></tr>
<tr><td><code id="Spectrum-class_+3A_xlab">xlab</code></td>
<td>

<p>a character string, the label for the x-axis.
</p>
</td></tr>
<tr><td><code id="Spectrum-class_+3A_ylab">ylab</code></td>
<td>

<p>a character string, the label for the y-axis. If <code>NULL</code>, the
default, the label is set to <code>"Spd"</code> or <code>"log(Spd)"</code>,
depending on the value of argument <code>log</code>.
</p>
</td></tr>
<tr><td><code id="Spectrum-class_+3A_...">...</code></td>
<td>

<p>for <code>print</code>, further arguments for <code>print.default()</code>;
</p>
<p>for <code>plot</code>, further arguments for <code><a href="graphics.html#topic+curve">curve</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>"Spectrum"</code> is an S4 class and as such autoprinting calls the
<code>"Spectrum"</code> method for <code>show()</code>, which prints and
plots. <code>show</code> has a single argument, the object.  For more
control over printing, call <code>print</code> which has additional
arguments. Similarly, call <code>plot</code> for more flexible graphics.
</p>
<p><code>print(object)</code> (i.e., without further arguments) is equivalent
to <code>show(object)</code>, except that the former returns <code>object</code>
while the latter returns <code>NULL</code> (both invisibly), as is standard
for these functions.  If <code>print</code> is called with further
arguments. the spectrum is not plotted.
</p>
<p>The peaks and throughs printed by <code>print</code> are computed by
evaluating the spectral density at <code>n</code> equially spaced points and
recording the maxima of the resulting discrete sequence. Set argument
<code>n</code> to get a finer/coarser grid or to force calculations for
particular frequencies. For example, a multiple of 12 may be suitable
for <code>n</code> if the data is monthly.
</p>
<p>Except for <code>x</code> and <code>standardize</code> the arguments of the
<code>plot</code> method are as for <code>curve</code>. With the default
<code>standardize = TRUE</code> the spectral density integrates to one over
one whole period (usually <code class="reqn">(-1/2, 1/2]</code> but due to its symmetry it
is usually plotted over the second half of that interval.
</p>


<h3>Objects from the Class</h3>

<p>Objects contain spectra produced by <code>sarima::spectrum</code>,
see <code><a href="#topic+spectrum">spectrum</a></code> for details.
</p>
<p>Objects can also be created by calling <code>"new"</code> but this is not
recommended and currently considered internal.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"function"</code> ~~ </p>
</dd>
<dt><code>call</code>:</dt><dd><p>Object of class <code>"call"</code> ~~ </p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"ANY"</code>,
the underlying model.
</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>plot</dt><dd><p><code>signature(x = "Spectrum", y = "ANY")</code>:
plots <code>x</code>.
</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "Spectrum")</code>:
</p>
<p>plots <code>object</code> and prints succinct information about it,
including the peaks and troughs in the spectral density. It is
equivalent to calling <code>print</code> and <code>plot</code> with a single
argument, see section &lsquo;Details&rsquo;.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+spectrum">spectrum</a></code> for details and further examples,
</p>
<p><code><a href="#topic+ArmaSpectrum-class">ArmaSpectrum</a></code> for ARMA spectra
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ARFIMA(0,d,0) with parameters 'freq' and 'd'
spARFIMA0d0 &lt;- function(freq){  sigma2 / (2 * sin(2*pi*freq/2)^(2 * d)) }
sp &lt;- spectrum(spARFIMA0d0, param = list(sigma2 = 1, d = 0.2))
print(sp, digits = 4)
## evaluate the spd at selected frequencies 
sp(c(0:4 / 8))

## argument 'freq' doesn't need to be called 'freq' but it needs to be
##   the first one. This is equivalent to above:
spARFIMA0d0b &lt;- function(x){  sigma2 / (2 * sin(2*pi*x/2)^(2 * d)) }
spb &lt;- spectrum(spARFIMA0d0b, param = list(sigma2 = 1, d = 0.2))
plot(spb)

## An example without parameters, as above with sigma2 = 1, d = 0.2 hard
##   coded:
spARFIMA0d0c &lt;- function(freq){  1 / (2 * sin(2*pi*freq/2)^(2 * 0.2)) }
spc &lt;- spectrum(spARFIMA0d0c)
print(spc, digits = 4)

spc(c(0:4 / 8))
all.equal(spc(c(0:4 / 8)), sp(c(0:4 / 8))) # TRUE
</code></pre>

<hr>
<h2 id='summary.SarimaModel'>Methods for summary in package sarima</h2><span id='topic+summary.SarimaModel'></span><span id='topic+summary.SarimaFilter'></span><span id='topic+summary.SarimaSpec'></span>

<h3>Description</h3>

<p>Methods for summary in package sarima.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SarimaModel'
summary(object, ...)
## S3 method for class 'SarimaFilter'
summary(object, ...)
## S3 method for class 'SarimaSpec'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.SarimaModel_+3A_object">object</code></td>
<td>
<p>an object from the corresponding class.</p>
</td></tr>
<tr><td><code id="summary.SarimaModel_+3A_...">...</code></td>
<td>
<p>further arguments for methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>

<hr>
<h2 id='tsdiag.Sarima'>Diagnostic Plots for fitted seasonal ARIMA models</h2><span id='topic+tsdiag.Sarima'></span><span id='topic+tsdiag'></span>

<h3>Description</h3>

<p>Produce diagnostics for fitted seasonal ARIMA models. The method
offers several portmanteau tests (including Ljung-Box, Li-McLeod and
Box-Pierce), plots of autocorrelations and partial autocorrelations of
the residuals, ability to control which graphs are produced (including
interactively), as well as their layout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Sarima'
tsdiag(object, gof.lag = NULL, ask = FALSE, ..., plot = 1:3, layout = NULL)

# if 'object' is produced by stats::arima(), forecast::auto.arima() and
# similar, use the full name, 'tsdiag.Sarima()', in the call. The
# arguments are the same.
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsdiag.Sarima_+3A_object">object</code></td>
<td>

<p>fitted (seasonal) ARIMA model. currently the output of
<code>sarima</code>, <code>stats::arima</code> or compatible (e.g.,
<code>forecast::Arima</code> and <code>forecast::auto.arima</code>).  If
<code>object</code> is not from <code>sarima</code>, use the full name,
<code>tsdiag.Sarima</code>, of the method when calling it, see the
examples. 
</p>
</td></tr>
<tr><td><code id="tsdiag.Sarima_+3A_gof.lag">gof.lag</code></td>
<td>
<p>maximal lag for portmanteau tests.</p>
</td></tr>
<tr><td><code id="tsdiag.Sarima_+3A_ask">ask</code></td>
<td>

<p>if <code>TRUE</code> present a menu of available plots, see section
&lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="tsdiag.Sarima_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="tsdiag.Sarima_+3A_plot">plot</code></td>
<td>

<p>if <code>TRUE</code> all available plots; a vector of positive integers
specifies a subset of the available plots.
</p>
</td></tr>
<tr><td><code id="tsdiag.Sarima_+3A_layout">layout</code></td>
<td>

<p>a list with arguments for <code>graphics::layout</code> for the plots. The
default is as for the ARIMA method of <code>stats::tsdiag</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute and graph diagnostics for seasonal ARIMA models. For objects
of class <code>"Sarima"</code> (produced by <code>sarima</code>) just call the
generic, <code>tsdiag</code>. The method can be called also directly on the output
from base R's <code>arima()</code> with <code>tsdiag.Sarima()</code> or
<code>sarima::tsdiag.Sarima()</code>.
</p>
<p>The method offers several portmanteau tests (including Ljung-Box,
Li-McLeod and Box-Pierce), plots of autocorrelations and partial
autocorrelations of the residuals, ability to control which graphs are
produced (including interactively), as well as their layout.
</p>
<p>The method always makes a correction of the degrees of freedom of the
portmanteau tests (roughly, subtracting the number of estimated ARMA
parameters). Note that <code>stats::tsdiag</code> doesn't do that.
</p>
<p><code>plot</code> can be <code>TRUE</code> to ask for all plots or a vector of
positive integers specifying which plots to consider. Currently the
following options are available:
</p>

<table>
<tr>
 <td style="text-align: right;">1 </td><td style="text-align: left;"> residuals </td>
</tr>
<tr>
 <td style="text-align: right;">
 2 </td><td style="text-align: left;"> acf of residuals </td>
</tr>
<tr>
 <td style="text-align: right;">
 3 </td><td style="text-align: left;"> p values for Ljung-Box statistic </td>
</tr>
<tr>
 <td style="text-align: right;">
 4 </td><td style="text-align: left;"> p values for Li-McLeod statistic </td>
</tr>
<tr>
 <td style="text-align: right;">
 5 </td><td style="text-align: left;"> p values for Box-Pierce statistic </td>
</tr>
<tr>
 <td style="text-align: right;">
 6 </td><td style="text-align: left;"> pacf of residuals</td>
</tr>

</table>


<p>The default is <code>plot = 1:3</code>, which produces a plot similar to the
one from <code>stats::tsdiag</code> (but with adjusted d.f., see above). 
If <code>plot</code> is <code>TRUE</code>, you probably need also <code>ask = TRUE</code>.
</p>
<p>If argument <code>plot</code> is of length two the graphics window is split
into 2 equal subwindows. Argument <code>layout</code> can still be used to
change this.  If argument <code>plot</code> is of length one the graphics
window is not split at all.
</p>
<p>In interactive sessions, if the number of requested graphs (as
specified by argument <code>plot</code>) is larger than the number of graphs
specified by the layout (by default 3), the function makes the first
graph and then presents a menu of the requested plots. 
</p>
<p>Argument <code>layout</code> can be used to change the layout of the plot,
for example to put two graphs per plot, see the examples. Currently it
should be a list of arguments for <code><a href="graphics.html#topic+layout">layout</a></code>, see <code>?layout</code>.
Don't call <code>layout</code> youself, as that will change the graphics
device prematurely.
</p>
<p>The computed results are returned (invisibly). This is another
difference from <code>stats::tsdiag</code> which doesn't return them.
</p>


<h3>Value</h3>

<p>a list with components:
</p>
<table role = "presentation">
<tr><td><code>residuals</code></td>
<td>
<p>residuals</p>
</td></tr>
<tr><td><code>LjungBox</code></td>
<td>
<p>Ljung box test</p>
</td></tr>
<tr><td><code>LiMcLeod</code></td>
<td>
<p>LiMcLeod test</p>
</td></tr>
<tr><td><code>BoxPierce</code></td>
<td>
<p>BoxPierce test</p>
</td></tr>
</table>
<p>Only components that are actually computed are included, the rest are
NULL or absent.
</p>


<h3>Author(s)</h3>

<p>Georgi N. boshnakov</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+tsdiag">tsdiag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ap.baseA &lt;- sarima(log(AirPassengers) ~ 
    0 | ma(1, c(-0.3)) + sma(12,1, c(-0.1)) + i(1) + si(12,1), 
    ss.method = "base")
tsdiag(ap.baseA)

## apply the method on objects from arima()
ap.arima &lt;- arima(log(AirPassengers), order = c(0,1,1), seasonal = c(0,1,1))
tsdiag.Sarima(ap.arima)
## use Li-McLeod test instead of Ljung-Box
tsdiag.Sarima(ap.arima, plot = c(1:2,4))
## call R's tsdiag method, for comparison:
tsdiag(ap.arima, plot = c(1:2,4))

## plot only acf and p-values
tsd &lt;- tsdiag.Sarima(ap.arima, plot = c(2:3), layout = list(matrix(1:2, nrow = 2)))
## the results can be used for further calculations:
head(tsd$LjungBox$test, 4)


## plot resid, acf, and p-values, leaving half the space for residuals
tsdiag.Sarima(ap.arima, plot = c(1:3), layout = list(matrix(1:3, nrow = 3),
                                                     heights = c(1,2,2)))


## four plots arranged as a 2x2 matrix.
tsdiag.Sarima(ap.arima, plot = c(2:5), layout = list(matrix(1:4, nrow = 2)))
</code></pre>

<hr>
<h2 id='VirtualMonicFilter-class'>Undocumented classes in package sarima</h2><span id='topic+BJ-class'></span><span id='topic+SP-class'></span><span id='topic+BD-class'></span><span id='topic+VirtualMonicFilter-class'></span><span id='topic+VirtualBJFilter-class'></span><span id='topic+VirtualSPFilter-class'></span><span id='topic+VirtualArmaFilter-class'></span><span id='topic+VirtualAutocovarianceModel-class'></span><span id='topic+VirtualAutocorelationModel-class'></span><span id='topic+VirtualPartialAutocovarianceModel-class'></span><span id='topic+VirtualPartialAutocorelationModel-class'></span><span id='topic+VirtualIntegratedModel-class'></span><span id='topic+VirtualSarimaModel-class'></span><span id='topic+VirtualImaModel-class'></span><span id='topic+VirtualFilterModel-class'></span><span id='topic+VirtualArmaModel-class'></span><span id='topic+VirtualAutocovarianceSpec-class'></span><span id='topic+VirtualMonicFilterSpec-class'></span><span id='topic+VirtualWhiteNoiseModel-class'></span><span id='topic+VirtualArModel-class'></span><span id='topic+VirtualMaModel-class'></span><span id='topic+VirtualArimaModel-class'></span><span id='topic+VirtualMeanModel-class'></span><span id='topic+VirtualAriModel-class'></span><span id='topic+VirtualSarimaFilter-class'></span><span id='topic+VirtualStationaryModel-class'></span><span id='topic+VirtualCascadeFilter-class'></span><span id='topic+MonicFilterSpec-class'></span><span id='topic+BJFilter-class'></span><span id='topic+SPFilter-class'></span><span id='topic+ArmaFilter-class'></span><span id='topic+ArFilter-class'></span><span id='topic+MaFilter-class'></span><span id='topic+SarimaFilter-class'></span><span id='topic+SarimaSpec-class'></span><span id='topic+AutocovarianceSpec-class'></span><span id='topic+AutocovarianceModel-class'></span><span id='topic+ArmaSpec-class'></span><span id='topic+VirtualAutocorrelations-class'></span><span id='topic+VirtualAutocovariances-class'></span><span id='topic+Fitted-class'></span><span id='topic+Autocovariances-class'></span><span id='topic+Autocorrelations-class'></span><span id='topic+ComboAutocovariances-class'></span><span id='topic+ComboAutocorrelations-class'></span><span id='topic+PartialAutocovariances-class'></span><span id='topic+PartialAutocorrelations-class'></span><span id='topic+PartialVariances-class'></span><span id='topic+SampleAutocovariances-class'></span><span id='topic+SampleAutocorrelations-class'></span><span id='topic+SamplePartialAutocovariances-class'></span><span id='topic+SamplePartialAutocorrelations-class'></span><span id='topic+SamplePartialVariances-class'></span>

<h3>Description</h3>

<p>This page is for classes without proper documentation.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be
created from it.
</p>
<p>This page exists only to remind me which classes do not have
documentation yet. It exists to avoid cluttering the report from 'R
CMD check' during early stages of development.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;VirtualMonicFilter&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>

<hr>
<h2 id='whiteNoiseTest'>White noise tests</h2><span id='topic+whiteNoiseTest'></span>

<h3>Description</h3>

<p>White noise tests.</p>


<h3>Usage</h3>

<pre><code class='language-R'>whiteNoiseTest(object, h0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="whiteNoiseTest_+3A_object">object</code></td>
<td>

<p>an object, such as sample autocorrelations or partial autocorrelations.</p>
</td></tr>
<tr><td><code id="whiteNoiseTest_+3A_h0">h0</code></td>
<td>
<p>the null hypothesis, currently &quot;iid&quot; or &quot;garch&quot;.</p>
</td></tr>
<tr><td><code id="whiteNoiseTest_+3A_...">...</code></td>
<td>

<p>additional arguments passed on to methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>whiteNoiseTest</code> carries out tests for white noise.  The null
hypothesis is identified by argument <code>h0</code>, based on which
<code>whiteNoiseTest</code> chooses a suitable function to call.  The
functions implementing the tests are also available to be called
directly and their documentation should be consulted for further
arguments that are available.
</p>
<p>If <code>h0 = "iid"</code>, the test statistics and rejection regions can be
use to test if the underlying time series is iid. Argument
<code>method</code> specifies the method for portmanteau tests: one of
&quot;LiMcLeod&quot; (default), &quot;LjungBox&quot;, &quot;BoxPierce&quot;.
</p>
<p>If <code>h0 = "garch"</code>, the null hypothesis is that the time series is
GARCH, see Francq &amp; Zakoian (2010). The
tests in this case are based on a non-parametric estimate of the
asymptotic covariance matrix.
</p>
<p>Portmonteau statistics and p-values are computed for the lags
specified by argument <code>nlags</code>. If it is missing, suitable lags
are chosen automatically.
</p>
<p>If argument <code>interval</code> is TRUE, confidence intervals for the
individual autocorrelations or partial autocorrelations are computed.
</p>


<h3>Value</h3>

<p>a list with component <code>test</code> and, if <code>ci=TRUE</code>, component
<code>ci</code>.
</p>


<h3>Note</h3>

<p>Further methods will be added in the future.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>Francq C, Zakoian J (2010).
<em>GARCH models: structure, statistical inference and financial applications</em>.
John Wiley &amp; Sons.
ISBN 978-0-470-68391-0.
</p>
<p>Li WK (2004).
<em>Diagnostic checks in time series</em>.
Chapman &amp; Hall/CRC Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+acfGarchTest">acfGarchTest</a></code> (<code>h0 = "garch"</code>),
<code><a href="#topic+acfIidTest">acfIidTest</a></code> (<code>h0 = "iid"</code>);
</p>
<p><code><a href="#topic+acfMaTest">acfMaTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 5000
x &lt;- sarima:::rgarch1p1(n, alpha = 0.3, beta = 0.55, omega = 1, n.skip = 100)
x.acf &lt;- autocorrelations(x)
x.pacf &lt;- partialAutocorrelations(x)

x.iid &lt;- whiteNoiseTest(x.acf, h0 = "iid", nlags = c(5,10,20), x = x, method = "LiMcLeod")
x.iid

x.iid2 &lt;- whiteNoiseTest(x.acf, h0 = "iid", nlags = c(5,10,20), x = x, method = "LjungBox")
x.iid2

x.garch &lt;- whiteNoiseTest(x.acf, h0 = "garch", nlags = c(5,10,20), x = x)
x.garch
</code></pre>

<hr>
<h2 id='xarmaFilter'> Applies an extended ARMA filter to a time series </h2><span id='topic+xarmaFilter'></span>

<h3>Description</h3>

<p>Filter time series with an extended arma filter.
If <code>whiten</code> is <code>FALSE</code> (default) the function applies
the given ARMA filter to <code>eps</code> (<code>eps</code> is often
white noise).  If <code>whiten</code> is <code>TRUE</code> the function applies
the &ldquo;inverse filter&rdquo; to <code class="reqn">x</code>, effectively computing
residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xarmaFilter(model, x = NULL, eps = NULL, from = NULL, whiten = FALSE,
            xcenter = NULL, xintercept = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xarmaFilter_+3A_x">x</code></td>
<td>
<p> the time series to be filtered, a vector. </p>
</td></tr>
<tr><td><code id="xarmaFilter_+3A_eps">eps</code></td>
<td>
<p> residuals, a vector or NULL. </p>
</td></tr>
<tr><td><code id="xarmaFilter_+3A_model">model</code></td>
<td>

<p>the model parameters, a list with components <code>"ar"</code>,
<code>"ma"</code>, <code>"center"</code> and <code>"intercept"</code>, see Details.
</p>
</td></tr>
<tr><td><code id="xarmaFilter_+3A_from">from</code></td>
<td>
<p> the index from which to start filtering. </p>
</td></tr>
<tr><td><code id="xarmaFilter_+3A_whiten">whiten</code></td>
<td>

<p>if TRUE use <code>x</code> as input and apply the inverse filter to
produce <code>eps</code> (&quot;whiten&quot; <code>x</code>), if FALSE use <code>eps</code> as
input and generate <code>x</code> (&quot;colour&quot; <code>eps</code>).
</p>
</td></tr>
<tr><td><code id="xarmaFilter_+3A_xcenter">xcenter</code></td>
<td>

<p>a vector of means of the same length as the time series, see Details.
</p>
</td></tr>
<tr><td><code id="xarmaFilter_+3A_xintercept">xintercept</code></td>
<td>

<p>a vector of intercepts having the length of the series, see Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is specified by argument <code>model</code>, which is a list with
the following components:
</p>

<dl>
<dt><code>ar</code></dt><dd><p> the autoregression parameters,</p>
</dd>
<dt><code>ma</code></dt><dd><p> the moving average parameters,</p>
</dd>
<dt><code>center</code></dt><dd><p> center by this value,</p>
</dd>
<dt><code>intercept</code></dt><dd><p>intercept.</p>
</dd>
</dl>

<p><code>model$center</code> and <code>model$intercept</code> are scalars and usually
at most one of them is nonzero. They can be considered part of the
model specification. In contrast, arguments <code>xcenter</code> and
<code>xintercept</code> are vectors of the same length as <code>x</code>. They can
represent contributions from covariate variables. Usually at most one
of <code>xcenter</code> and <code>xintercept</code> is used.
</p>
<p>The description below uses <code class="reqn">\mu_t</code> and <code class="reqn">c_t</code> for
the contributions by <code>model$center</code> plus <code>xcenter</code> and
<code>model$intercept</code> plus <code>xintercept</code>, respectively.
The time series <code class="reqn">\{x_t\}</code> and <code class="reqn">\{\varepsilon_t\}</code> are
represented by <code>x</code> and <code>eps</code> in the <span class="rlang"><b>R</b></span> code.
Let
</p>
<p style="text-align: center;"><code class="reqn">y_t = x_t - \mu_t</code>
</p>

<p>be the centered series.  where the centering term <code class="reqn">\mu_t</code>
is essentially the sum of <code>center</code> and <code>xcenter</code> and is not
necessarilly the mean.  The equation relating the centered series,
<code class="reqn">y_t=x_t - \mu_t</code>, and <code>eps</code> is the
following:
</p>
<p style="text-align: center;"><code class="reqn"> y_t
    =   c_t
      + \sum_{i=1}^{p} \phi(i)y            _{t-i}
      + \sum_{i=1}^{q} \theta(i)\varepsilon_{t-i}
      + \varepsilon_t
    </code>
</p>

<p>where <code class="reqn">c_t</code> is the intercept (basically the sum of
<code>intercept</code> with <code>xintercept</code>).
</p>
<p>If <code>whiten = FALSE</code>, <code class="reqn">y_t</code> is computed for
<code>t=from,...,n</code> using the above formula, i.e. the filter is
applied to get <code>y</code> from <code>eps</code> (and some initial values). If
<code>eps</code> is white noise, it can be said that <code>y</code> is obtained by
&ldquo;colouring&rdquo; the white noise <code>eps</code>. This can be used, for
example, to simulate ARIMA time series.  Finally, the centering term
is added back, <code class="reqn">x_t=y_t+\mu_t</code> for <code>t=from,...,n</code>, and the
modified <code>x</code> is returned.  The first <code>from - 1</code> elements of
<code>x</code> are left unchanged.
</p>
<p>The inverse filter is obtained by rewriting the above equation as an equation
expressing <code class="reqn">\varepsilon_t</code> in terms of the remaining quantities:
</p>
<p style="text-align: center;"><code class="reqn"> \varepsilon_t
    = - c_t
      - \sum_{i=1}^{q} \theta(i)\varepsilon_{t-i}
      - \sum_{i=1}^{p} \phi  (i)y          _{t-i}
      + y_t
    </code>
</p>

<p>If <code>whiten = TRUE</code>, <code>xarmaFilter</code> uses this formula for
<code>t=from,...,n</code> to compute <code>eps</code> from <code>y</code> (and some
initial values). If <code>eps</code> is white noise, then it can be said
that the time series <code>y</code> has been whitened.
</p>
<p>In both cases the first few values in <code>x</code> and/or
<code>eps</code> are used as initial values.
</p>
<p>The centering is formed from <code>model$center</code> and argument
<code>xcenter</code>.  If <code>model$center</code> is supplied it is recycled
to the length of the series, <code>x</code>, and subtracted from
<code>x</code>. If argument <code>xcenter</code> is supplied, it is subtracted
from <code>x</code>. If both <code>model$center</code> and <code>xcenter</code> are
supplied their sum is subtracted from <code>x</code>.
</p>
<p><code>xarmaFilter</code> can be used to simulate ARMA series with the
default value of <code>whiten = FALSE</code>. In this case <code>eps</code> is the
input series and <code>y</code> the output:
Then <code>model$center</code> and/or <code>xcenter</code> are added to <code>y</code>
to form the output vector <code>x</code>.
</p>
<p>Residuals corresponding to a series <code>x</code> can be obtained by
setting <code>whiten = TRUE</code>. In this case <code>x</code> is the input series.
The elements of the output vector <code>eps</code> are calculated by the
formula for <code class="reqn">\varepsilon_{t}</code> given above.
There is no need in this case to restore <code>x</code> since <code>eps</code> is
returned.
</p>
<p>In both cases any necessary initial values are assumed to be already
in the vectors and provide the first <code>from - 1</code> values in the
returned vectors.  Argument <code>from</code> should not be smaller than the
default value <code>max(p,q)+1</code>.
</p>
<p><code>xarmaFilter</code> calls the lower level function <code>coreXarmaFilter</code>
to do the computation.
</p>


<h3>Value</h3>

<p>the result of applying the filter or its inverse, as descibed in Details:
if <code>whiten = FALSE</code>, the modified <code>x</code>;
if <code>whiten = TRUE</code>, the modified <code>eps</code>.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'>## define a seasonal ARIMA model
m1 &lt;- new("SarimaModel", iorder = 1, siorder = 1, ma = -0.3, sma = -0.1, nseasons = 12)

model0 &lt;- modelCoef(m1, "ArmaModel")
model1 &lt;- as(model0, "list")

ap.1 &lt;- xarmaFilter(model1, x = AirPassengers, whiten = TRUE)
ap.2 &lt;- xarmaFilter(model1, x = AirPassengers, eps = ap.1, whiten = FALSE)
ap &lt;- AirPassengers
ap[-(1:13)] &lt;- 0 # check that the filter doesn't use x, except for initial values.
ap.2a &lt;- xarmaFilter(model1, x = ap, eps = ap.1, whiten = FALSE)
ap.2a - ap.2 ## indeed = 0
##ap.3 &lt;- xarmaFilter(model1, x = list(init = AirPassengers[1:13]), eps = ap.1, whiten = TRUE)

## now set some non-zero initial values for eps
eps1 &lt;- numeric(length(AirPassengers))
eps1[1:13] &lt;- rnorm(13)
ap.A &lt;- xarmaFilter(model1, x = AirPassengers, eps = eps1, whiten = TRUE)
ap.Ainv &lt;- xarmaFilter(model1, x = ap, eps = ap.A, whiten = FALSE)
AirPassengers - ap.Ainv # = 0

## compare with sarima.f (an old function)
## compute predictions starting at from = 14
pred1 &lt;- sarima.f(past = AirPassengers[1:13], n = 131, ar = model1$ar, ma = model1$ma)
pred2 &lt;- xarmaFilter(model1, x = ap, whiten = FALSE)
pred2 &lt;- pred2[-(1:13)]
all(pred1 == pred2) ##TRUE
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
