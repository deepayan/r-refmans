<!DOCTYPE html><html><head><title>Help for package network</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {network}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add.edges'><p>Add Edges to a Network Object</p></a></li>
<li><a href='#add.vertices'><p>Add Vertices to an Existing Network</p></a></li>
<li><a href='#as.color'><p>Transform vector of values into color specification</p></a></li>
<li><a href='#as.data.frame.network'><p>Coerce a Network Object to a <code>data.frame</code></p></a></li>
<li><a href='#as.edgelist'><p>Convert a network object into a numeric edgelist matrix</p></a></li>
<li><a href='#as.matrix.network'><p>Coerce a Network Object to Matrix or Table Form</p></a></li>
<li><a href='#as.network.matrix'><p>Coercion from Matrices to Network Objects</p></a></li>
<li><a href='#as.sociomatrix'><p>Coerce One or More Networks to Sociomatrix Form</p></a></li>
<li><a href='#attribute.methods'><p>Attribute Interface Methods for the Network Class</p></a></li>
<li><a href='#deletion.methods'><p>Remove Elements from a Network Object</p></a></li>
<li><a href='#edgeset.constructors'><p>Edgeset Constructors for Network Objects</p></a></li>
<li><a href='#emon'><p>Interorganizational Search and Rescue Networks (Drabek et al.)</p></a></li>
<li><a href='#flo'><p>Florentine Wedding Data (Padgett)</p></a></li>
<li><a href='#get.edges'><p>Retrieve Edges or Edge IDs Associated with a Given Vertex</p></a></li>
<li><a href='#get.inducedSubgraph'><p>Retrieve Induced Subgraphs and Cuts</p></a></li>
<li><a href='#get.neighborhood'><p>Obtain the Neighborhood of a Given Vertex</p></a></li>
<li><a href='#has.edges'><p>Determine if specified vertices of a network have any edges (are not</p>
isolates)</a></li>
<li><a href='#is.adjacent'><p>Determine Whether Two Vertices Are Adjacent</p></a></li>
<li><a href='#loading.attributes'><p>Examples of how to load vertex and edge attributes into networks</p></a></li>
<li><a href='#missing.edges'><p>Identifying and Counting Missing Edges in a Network Object</p></a></li>
<li><a href='#mixingmatrix'><p>Mixing matrix</p></a></li>
<li><a href='#network'><p>Network Objects</p></a></li>
<li><a href='#network-internal'><p>Internal Network Package Functions</p></a></li>
<li><a href='#network-package'><p>Classes for Relational Data</p></a></li>
<li><a href='#network.arrow'><p>Add Arrows or Segments to a Plot</p></a></li>
<li><a href='#network.density'><p>Compute the Density of a Network</p></a></li>
<li><a href='#network.dyadcount'><p>Return the Number of (Possibly Directed) Dyads in a Network Object</p></a></li>
<li><a href='#network.edgecount'><p>Return the Number of Edges in a Network Object</p></a></li>
<li><a href='#network.edgelabel'><p>Plots a label corresponding to an edge in a network plot.</p></a></li>
<li><a href='#network.extraction'><p>Extraction and Replacement Operators for Network Objects</p></a></li>
<li><a href='#network.indicators'><p>Indicator Functions for Network Properties</p></a></li>
<li><a href='#network.initialize'><p>Initialize a Network Class Object</p></a></li>
<li><a href='#network.layout'><p>Vertex Layout Functions for plot.network</p></a></li>
<li><a href='#network.loop'><p>Add Loops to a Plot</p></a></li>
<li><a href='#network.operators'><p>Network Operators</p></a></li>
<li><a href='#network.size'><p>Return the Size of a Network</p></a></li>
<li><a href='#network.vertex'><p>Add Vertices to a Plot</p></a></li>
<li><a href='#permute.vertexIDs'><p>Permute (Relabel) the Vertices Within a Network</p></a></li>
<li><a href='#plot.network.default'><p>Two-Dimensional Visualization for Network Objects</p></a></li>
<li><a href='#plotArgs.network'><p>Expand and transform attributes of networks to values appropriate for</p>
aguments to plot.network</a></li>
<li><a href='#prod.network'><p>Combine Networks by Edge Value Multiplication</p></a></li>
<li><a href='#read.paj'><p>Read a Pajek Project or Network File and Convert to an R 'Network' Object</p></a></li>
<li><a href='#sum.network'><p>Combine Networks by Edge Value Addition</p></a></li>
<li><a href='#valid.eids'><p>Get the ids of all the edges that are valid in a network</p></a></li>
<li><a href='#which.matrix.type'><p>Heuristic Determination of Matrix Types for Network Storage</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.18.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-04</td>
</tr>
<tr>
<td>Title:</td>
<td>Classes for Relational Data</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Carter T. Butts &lt;buttsc@uci.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), utils</td>
</tr>
<tr>
<td>Imports:</td>
<td>tibble, magrittr, statnet.common (&ge; 4.5), stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>sna, testthat, covr</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools to create and modify network objects.  The network class can represent a range of relational data types, and supports arbitrary vertex/edge/graph attributes.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://statnet.org/">https://statnet.org/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Collate:</td>
<td>'access.R' 'as.edgelist.R' 'assignment.R' 'coercion.R'
'constructors.R' 'dataframe.R' 'fileio.R' 'layout.R' 'misc.R'
'network-package.R' 'operators.R' 'plot.R' 'printsum.R' 'zzz.R'</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-05 06:05:56 UTC; buttsc</td>
</tr>
<tr>
<td>Author:</td>
<td>Carter T. Butts [aut, cre],
  David Hunter [ctb],
  Mark Handcock [ctb],
  Skye Bender-deMoll [ctb],
  Jeffrey Horner [ctb],
  Li Wang [ctb],
  Pavel N. Krivitsky
    <a href="https://orcid.org/0000-0002-9101-3362"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Brendan Knapp <a href="https://orcid.org/0000-0003-3284-4972"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Micha≈Ç Bojanowski <a href="https://orcid.org/0000-0001-7503-852X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Chad Klumb [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-05 11:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add.edges'>Add Edges to a Network Object</h2><span id='topic+add.edges'></span><span id='topic+add.edge'></span><span id='topic+add.edges.network'></span><span id='topic+add.edge.network'></span>

<h3>Description</h3>

<p>Add one or more edges to an existing network object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.edge(
  x,
  tail,
  head,
  names.eval = NULL,
  vals.eval = NULL,
  edge.check = FALSE,
  ...
)

add.edges(x, tail, head, names.eval = NULL, vals.eval = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.edges_+3A_x">x</code></td>
<td>
<p>an object of class <code>network</code></p>
</td></tr>
<tr><td><code id="add.edges_+3A_tail">tail</code></td>
<td>
<p>for <code>add.edge</code>, a vector of vertex IDs reflecting the tail
set for the edge to be added; for <code>add.edges</code>, a list of such vectors</p>
</td></tr>
<tr><td><code id="add.edges_+3A_head">head</code></td>
<td>
<p>for <code>add.edge</code>, a vector of vertex IDs reflecting the head
set for the edge to be added; for <code>add.edges</code>, a list of such vectors</p>
</td></tr>
<tr><td><code id="add.edges_+3A_names.eval">names.eval</code></td>
<td>
<p>for <code>add.edge</code>, an optional list of names for edge
attributes; for <code>add.edges</code>, a list of length equal to the number of
edges, with each element containing a list of names for the attributes of
the corresponding edge</p>
</td></tr>
<tr><td><code id="add.edges_+3A_vals.eval">vals.eval</code></td>
<td>
<p>for <code>add.edge</code>, an optional list of edge attribute
values (matching <code>names.eval</code>); for <code>add.edges</code>, a list of such
lists</p>
</td></tr>
<tr><td><code id="add.edges_+3A_edge.check">edge.check</code></td>
<td>
<p>logical; should we perform (computationally expensive)
tests to check for the legality of submitted edges?</p>
</td></tr>
<tr><td><code id="add.edges_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The edge checking procedure is very slow, but should always be employed when
debugging; without it, one cannot guarantee that the network state is
consistent with network level variables (see
<code><a href="#topic+network.indicators">network.indicators</a></code>). For example, by default it is possible to
add multiple edges to a pair of vertices.
</p>
<p>Edges can also be added/removed via the extraction/replacement operators.
See the associated man page for details.
</p>


<h3>Value</h3>

<p>Invisibly, <code>add.edge</code> and <code>add.edges</code> return pointers to
their modified arguments; both functions modify their arguments in place..
</p>


<h3>Note</h3>

<p><code>add.edges</code> and <code>add.edge</code> were converted to an S3 generic
funtions in version 1.9, so they actually call <code>add.edges.network</code> and
<code>add.edge.network</code> by default, and may call other versions depending on
context (i.e. when called with a <code>networkDynamic</code> object).
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>References</h3>

<p>Butts, C. T.  (2008).  &ldquo;network: a Package for Managing
Relational Data in R.&rdquo; <em>Journal of Statistical Software</em>, 24(2).
<a href="https://www.jstatsoft.org/v24/i02/">https://www.jstatsoft.org/v24/i02/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+network">network</a></code>, <code><a href="#topic+add.vertices">add.vertices</a></code>,
<code><a href="#topic+network.extraction">network.extraction</a></code>, <code><a href="#topic+delete.edges">delete.edges</a></code>,
<code><a href="#topic+network.edgelist">network.edgelist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Initialize a small, empty network
g&lt;-network.initialize(3)

#Add an edge
add.edge(g,1,2)
g

#Can also add edges using the extraction/replacement operators
#note that replacement operators are much slower than add.edges()
g[,3]&lt;-1
g[,]

#Add multiple edges with attributes to a network

# pretend we just loaded in this data.frame from a file
# Note: network.edgelist() may be simpler for this case
elData&lt;-data.frame(
  from_id=c("1","2","3","1","3","1","2"),
  to_id=c("1", "1", "1", "2", "2", "3", "3"),
  myEdgeWeight=c(1, 2, 1, 2, 5, 3, 9.5),
  someLetters=c("B", "W", "L", "Z", "P", "Q", "E"),
  edgeCols=c("red","green","blue","orange","pink","brown","gray"),
  stringsAsFactors=FALSE
)

valueNet&lt;-network.initialize(3,loops=TRUE)

add.edges(valueNet,elData[,1],elData[,2],
    names.eval=rep(list(list("myEdgeWeight","someLetters","edgeCols")),nrow(elData)), 
    vals.eval=lapply(1:nrow(elData),function(r){as.list(elData[r,3:5])}))

list.edge.attributes(valueNet)


</code></pre>

<hr>
<h2 id='add.vertices'>Add Vertices to an Existing Network</h2><span id='topic+add.vertices'></span><span id='topic+add.vertices.network'></span>

<h3>Description</h3>

<p><code>add.vertices</code> adds a specified number of vertices to an existing
network; if desired, attributes for the new vertices may be specified as
well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.vertices(x, nv, vattr = NULL, last.mode = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.vertices_+3A_x">x</code></td>
<td>
<p>an object of class <code>network</code></p>
</td></tr>
<tr><td><code id="add.vertices_+3A_nv">nv</code></td>
<td>
<p>the number of vertices to add</p>
</td></tr>
<tr><td><code id="add.vertices_+3A_vattr">vattr</code></td>
<td>
<p>optionally, a list of attributes with one entry per new vertex</p>
</td></tr>
<tr><td><code id="add.vertices_+3A_last.mode">last.mode</code></td>
<td>
<p>logical; should the new vertices be added to the last
(rather than the first) mode of a bipartite network?</p>
</td></tr>
<tr><td><code id="add.vertices_+3A_...">...</code></td>
<td>
<p>possible additional arguments to add.vertices</p>
</td></tr>
</table>


<h3>Details</h3>

<p>New vertices are generally appended to the end of the network (i.e., their
vertex IDs begin with <code>network.size(x)</code> an count upward).  The one
exception to this rule is when <code>x</code> is bipartite and
<code>last.mode==FALSE</code>.  In this case, new vertices are added to the end of
the first mode, with existing second-mode vertices being permuted upward in
ID.  (<code>x</code>'s <code>bipartite</code> attribute is adjusted accordingly.)
</p>
<p>Note that the attribute format used here is based on the internal
(vertex-wise) storage method, as opposed to the attribute-wise format used
by <code><a href="#topic+network">network</a></code>.  Specifically, <code>vattr</code> should be a list with
one entry per new vertex, the ith element of which should be a list with an
element for every attribute of the ith vertex.  (If the required <code>na</code>
attribute is not given, it will be automatically created.)
</p>


<h3>Value</h3>

<p>Invisibly, a pointer to the updated <code>network</code> object;
<code>add.vertices</code> modifies its argument in place.
</p>


<h3>Note</h3>

<p><code>add.vertices</code> was converted to an S3 generic funtion in version
1.9, so it actually calls <code>add.vertices.network</code> by default and may
call other versions depending on context (i.e. when called with a
<code>networkDynamic</code> object).
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>References</h3>

<p>Butts, C. T.  (2008).  &ldquo;network: a Package for Managing
Relational Data in R.&rdquo; <em>Journal of Statistical Software</em>, 24(2).
<a href="https://www.jstatsoft.org/v24/i02/">https://www.jstatsoft.org/v24/i02/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+network">network</a></code>, <code><a href="#topic+get.vertex.attribute">get.vertex.attribute</a></code>,
<code><a href="#topic+set.vertex.attribute">set.vertex.attribute</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Initialize a network object
g&lt;-network.initialize(5)
g

#Add five more vertices
add.vertices(g,5)
g

#Create two more, with attributes
vat&lt;-replicate(2,list(is.added=TRUE,num.added=2),simplify=FALSE)
add.vertices(g,2,vattr=vat)
g%v%"is.added"       #Values are only present for the new cases
g%v%"num.added"

#Add to a bipartite network
bip &lt;-network.initialize(5,bipartite=3)
get.network.attribute(bip,'bipartite') # how many vertices in first mode?
add.vertices(bip,3,last.mode=FALSE)
get.network.attribute(bip,'bipartite')

</code></pre>

<hr>
<h2 id='as.color'>Transform vector of values into color specification</h2><span id='topic+as.color'></span><span id='topic+is.color'></span>

<h3>Description</h3>

<p>Convenience function to convert a vector of values into a color
specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.color(x, opacity = 1)

is.color(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.color_+3A_x">x</code></td>
<td>
<p>vector of numeric, character or factor values to be transformed</p>
</td></tr>
<tr><td><code id="as.color_+3A_opacity">opacity</code></td>
<td>
<p>optional numeric value in the range 0.0 to 1.0 used to specify
the opacity/transparency (alpha) of the colors to be returned. 0 means
fully opaque, 1 means fully transparent.
</p>
<p>Behavior of <code>as.color</code> is as follows: </p>
 <ul>
<li><p> integer numeric
values: unchanged, (assumed to corespond to values of R's active
<code><a href="grDevices.html#topic+palette">palette</a></code>) </p>
</li>
<li><p> integer real values: will be translated to into
grayscale values ranging between the max and min </p>
</li>
<li><p> factor: integer
values corresponding to factor levels will be used </p>
</li>
<li><p> character: if
values are valid colors (as determined by <code>is.color</code>) they will be
returned as is.  Otherwise converted to factor and numeric value of factor
returned. </p>
</li></ul>

<p>The optional <code>opacity</code> parameter can be used to make colors partially
transparent (as a shortcut for <code><a href="grDevices.html#topic+adjustcolor">adjustcolor</a></code>.  If used, colors
will be returned as hex rgb color string (i.e. <code>"#00FF0080"</code>)
</p>
<p>The <code>is.color</code> function checks if each character element of <code>x</code>
appears to be a color name by comparing it to <code><a href="grDevices.html#topic+colors">colors</a></code> and
checking if it is an HTML-style hex color code.  Note that it will return
FALSE for integer values.
</p>
<p>These functions are used for the color parameters of
<code><a href="#topic+plot.network">plot.network</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>as.color</code>, a vector integer values (corresponding to color
palette values) or character color name. For <code>is.color</code>, a logical
vector indicating if each element of x appears to be a color
</p>
<p><code>as.color()</code> returns TRUE if x is a character in a known color format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

as.color(1:3)
as.color(c('a','b','c'))

# add some transparency
as.color(c('red','green','blue'),0.5) # gives "#FF000080", "#00FF0080", "#0000FF80"

is.color(c('red',1,'foo',NA,'#FFFFFF55'))
</code></pre>

<hr>
<h2 id='as.data.frame.network'>Coerce a Network Object to a <code>data.frame</code></h2><span id='topic+as.data.frame.network'></span>

<h3>Description</h3>

<p>The <code>as.data.frame</code> method coerces its input to a <code>data.frame</code> containing
<code>x</code>'s edges or vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network'
as.data.frame(
  x,
  ...,
  unit = c("edges", "vertices"),
  na.rm = TRUE,
  attrs_to_ignore = "na",
  name_vertices = TRUE,
  sort_attrs = FALSE,
  store_eid = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.network_+3A_x">x</code></td>
<td>
<p>an object of class <code>network</code></p>
</td></tr>
<tr><td><code id="as.data.frame.network_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="as.data.frame.network_+3A_unit">unit</code></td>
<td>
<p>whether a <code>data.frame</code> of edge or vertex
attributes should be returned.</p>
</td></tr>
<tr><td><code id="as.data.frame.network_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; ignore missing edges/vertices when constructing the
data frame?</p>
</td></tr>
<tr><td><code id="as.data.frame.network_+3A_attrs_to_ignore">attrs_to_ignore</code></td>
<td>
<p>character; a vector of attribute names to
exclude from the returned <code>data.frame</code> (Default:
<code>"na"</code>)</p>
</td></tr>
<tr><td><code id="as.data.frame.network_+3A_name_vertices">name_vertices</code></td>
<td>
<p>logical; for <code>unit="edges"</code>, should the
<code>.tail</code> and the <code>.head</code> columns contain vertex names as opposed
to vertex indices?</p>
</td></tr>
<tr><td><code id="as.data.frame.network_+3A_sort_attrs">sort_attrs</code></td>
<td>
<p>logical; should the attribute columns in the
returned data frame be sorted alphabetically?</p>
</td></tr>
<tr><td><code id="as.data.frame.network_+3A_store_eid">store_eid</code></td>
<td>
<p>logical; for <code>unit="edges"</code>, should the edge ID in
the network's internal representation be stored in a column
<code>.eid</code>?</p>
</td></tr>
</table>

<hr>
<h2 id='as.edgelist'>Convert a network object into a numeric edgelist matrix</h2><span id='topic+as.edgelist'></span><span id='topic+as.edgelist.network'></span><span id='topic+edgelist'></span><span id='topic+as.edgelist.matrix'></span><span id='topic+as.edgelist.tbl_df'></span><span id='topic+is.edgelist'></span>

<h3>Description</h3>

<p>Constructs an edgelist in a sorted format with defined attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network'
as.edgelist(
  x,
  attrname = NULL,
  as.sna.edgelist = FALSE,
  output = c("matrix", "tibble"),
  ...
)

## S3 method for class 'matrix'
as.edgelist(
  x,
  n,
  directed = TRUE,
  bipartite = FALSE,
  loops = FALSE,
  vnames = seq_len(n),
  ...
)

## S3 method for class 'tbl_df'
as.edgelist(
  x,
  n,
  directed = TRUE,
  bipartite = FALSE,
  loops = FALSE,
  vnames = seq_len(n),
  ...
)

is.edgelist(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.edgelist_+3A_x">x</code></td>
<td>
<p>a <code>network</code> object with additional class added indicating how
it should be dispatched.</p>
</td></tr>
<tr><td><code id="as.edgelist_+3A_attrname">attrname</code></td>
<td>
<p>optionally, the name of an edge attribute to use for edge
values; may be a vector of names if <code>output="tibble"</code></p>
</td></tr>
<tr><td><code id="as.edgelist_+3A_as.sna.edgelist">as.sna.edgelist</code></td>
<td>
<p>logical; should the edgelist be returned in edgelist
form expected by the sna package? Ignored if <code>output="tibble"</code></p>
</td></tr>
<tr><td><code id="as.edgelist_+3A_output">output</code></td>
<td>
<p>return type: a <code><a href="base.html#topic+matrix">matrix</a></code> or a <code><a href="dplyr.html#topic+tibble">tibble</a></code>;
see <code><a href="#topic+as.matrix.network">as.matrix.network</a></code> for the difference.</p>
</td></tr>
<tr><td><code id="as.edgelist_+3A_...">...</code></td>
<td>
<p>additional arguments to other methods</p>
</td></tr>
<tr><td><code id="as.edgelist_+3A_n">n</code></td>
<td>
<p>integer number of vertices in network, value passed to the 'n' flag
on edgelist returned</p>
</td></tr>
<tr><td><code id="as.edgelist_+3A_directed">directed</code></td>
<td>
<p>logical; is network directed, value passed to the 'directed'
flag on edgelist returned</p>
</td></tr>
<tr><td><code id="as.edgelist_+3A_bipartite">bipartite</code></td>
<td>
<p>logical or integer; is network bipartite, value passed to
the 'bipartite' flag on edgelist returned</p>
</td></tr>
<tr><td><code id="as.edgelist_+3A_loops">loops</code></td>
<td>
<p>logical; are self-loops allowed in network?, value passed to
the 'loops' flag on edgelist returned</p>
</td></tr>
<tr><td><code id="as.edgelist_+3A_vnames">vnames</code></td>
<td>
<p>vertex names (defaults to vertex ids) to be attached to
edgelist for sna package compatibility</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Constructs a edgelist matrix or tibble from a network, sorted tails-major
order, with tails first, and, for undirected networks, tail &lt; head.  This
format is required by some reverse-depending packages (e.g. <code>ergm</code>)
</p>
<p>The <code><a href="#topic+as.matrix.network.edgelist">as.matrix.network.edgelist</a></code> provides similar functionality
but it does not enforce ordering or set the <code>edgelist</code> class and so
should be slightly faster.
</p>
<p><code>is.edgelist</code> tests if an object has the class <code>'edgelist'</code>
</p>


<h3>Value</h3>

<p>A matrix in which the first two columns are integers giving the tail
(source) and head (target) vertex ids of each edge. The matrix will be given
the class <code>edgelist</code>.
</p>
<p>The edgelist has additional attributes attached to it: </p>
 <ul>
<li>
<p><code>attr(,"n")</code> the number of vertices in the original network
</p>
</li>
<li> <p><code>attr(,"vnames")</code> the names of vertices in the original network
</p>
</li>
<li> <p><code>attr(,"directed")</code> logical, was the original network directed
</p>
</li>
<li> <p><code>attr(,"bipartite")</code> was the original network bipartite
</p>
</li>
<li> <p><code>attr(,"loops")</code> does the original network contain self-loops </p>
</li></ul>

<p>Note that if the <code>attrname</code> attribute is used the resulting edgelist
matrix will have three columns.  And if <code>attrname</code> refers to a
character attribute, the resulting edgelist matrix will be character rather
than numeric unless <code>output="tibble"</code>.
</p>


<h3>Note</h3>

<p>NOTE: this function was moved to network from the ergm package in
network version 1.13
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+as.matrix.network.edgelist">as.matrix.network.edgelist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   data(emon)
   as.edgelist(emon[[1]])
   as.edgelist(emon[[1]],output="tibble")
   # contrast with unsorted columns of
   as.matrix.network.edgelist(emon[[1]])
  
</code></pre>

<hr>
<h2 id='as.matrix.network'>Coerce a Network Object to Matrix or Table Form</h2><span id='topic+as.matrix.network'></span><span id='topic+as.matrix.network.adjacency'></span><span id='topic+as.matrix.network.edgelist'></span><span id='topic+as_tibble.network'></span><span id='topic+as.tibble.network'></span><span id='topic+as.matrix.network.incidence'></span>

<h3>Description</h3>

<p>The <code>as.matrix</code> methods attempt to coerce their input to a matrix in
adjacency, incidence, or edgelist form.  Edge values (from a stored
attribute) may be used if present. <code><a href="tibble.html#topic+as_tibble">as_tibble</a></code>
coerces into an edgelist in <code><a href="dplyr.html#topic+tibble">tibble</a></code> (a type of
<code><a href="base.html#topic+data.frame">data.frame</a></code>) form; this can be especially useful if extrecting
a character-type edge attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network'
as.matrix(x, matrix.type = NULL, attrname = NULL, ...)

## S3 method for class 'adjacency'
as.matrix.network(x, attrname=NULL, 
   expand.bipartite = FALSE, ...)

## S3 method for class 'edgelist'
as.matrix.network(x, attrname=NULL, 
   as.sna.edgelist = FALSE, na.rm = TRUE, ...)

## S3 method for class 'network'
as_tibble(
  x,
  attrnames = (match.arg(unit) == "vertices"),
  na.rm = TRUE,
  ...,
  unit = c("edges", "vertices"),
  store.eid = FALSE
)

as.tibble.network(
  x,
  attrnames = (match.arg(unit) == "vertices"),
  na.rm = TRUE,
  ...,
  unit = c("edges", "vertices"),
  store.eid = FALSE
)

## S3 method for class 'incidence'
as.matrix.network(x, attrname=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix.network_+3A_x">x</code></td>
<td>
<p>an object of class <code>network</code></p>
</td></tr>
<tr><td><code id="as.matrix.network_+3A_matrix.type">matrix.type</code></td>
<td>
<p>one of <code>"adjacency"</code>, <code>"incidence"</code>,
<code>"edgelist"</code>, or <code>NULL</code></p>
</td></tr>
<tr><td><code id="as.matrix.network_+3A_attrname">attrname</code></td>
<td>
<p>optionally, the name of an edge attribute to use for edge
values</p>
</td></tr>
<tr><td><code id="as.matrix.network_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
<tr><td><code id="as.matrix.network_+3A_expand.bipartite">expand.bipartite</code></td>
<td>
<p>logical; if <code>x</code> is bipartite, should we return
the full adjacency matrix (rather than the abbreviated, two-mode form)?</p>
</td></tr>
<tr><td><code id="as.matrix.network_+3A_as.sna.edgelist">as.sna.edgelist</code></td>
<td>
<p>logical; should the edgelist be returned in sna
edglist form?</p>
</td></tr>
<tr><td><code id="as.matrix.network_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; should missing edges/vertices be included in the
edgelist formats? Ignored if <code>as.sna.edgelist=TRUE</code>.</p>
</td></tr>
<tr><td><code id="as.matrix.network_+3A_attrnames">attrnames</code></td>
<td>
<p>optionally, either a character vector of the names of edge
attributes to use for edge values, or a numerical or logical vector to use
as indices for selecting them from <code><a href="#topic+list.edge.attributes">list.edge.attributes</a>(x)</code> or
<code><a href="#topic+list.vertex.attributes">list.vertex.attributes</a>(x)</code> (depending on <code>unit</code>); passing
<code>TRUE</code> therefore returns all edge attributes as columns</p>
</td></tr>
<tr><td><code id="as.matrix.network_+3A_unit">unit</code></td>
<td>
<p>whether a <code><a href="dplyr.html#topic+tibble">tibble</a></code> of edge or vertex attributes
should be returned.</p>
</td></tr>
<tr><td><code id="as.matrix.network_+3A_store.eid">store.eid</code></td>
<td>
<p>whether the edge ID should be stored in the third column (<code>.eid</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no matrix type is specified, <code><a href="#topic+which.matrix.type">which.matrix.type</a></code> will be used
to make an educated guess based on the shape of <code>x</code>.  Where edge values
are not specified, a dichotomous matrix will be assumed.
</p>
<p>Edgelists returned by the <code>as.matrix</code> methods are by default in a
slightly different form from the <code>sna</code> edgelist standard, but do
contain the <code>sna</code> extended matrix attributes (see
<code><a href="#topic+as.network.matrix">as.network.matrix</a></code>).  They should typically be compatible with
<code>sna</code> library functions.  To ensure compatibility, the
<code>as.sna.edgelist</code> argument can be set (which returns an exact
<code>sna</code> edgelist). The <code><a href="#topic+as.edgelist">as.edgelist</a></code> function also returns a
similar edgelist matrix but with an enforced sorting.
</p>
<p>For the <code>as.matrix</code> methods, if the <code>attrname</code> attribute is used
to include a charcter attribute, the resulting edgelist matrix will be
character rather than numeric. The <code>as_tibble</code> methods never coerce.
</p>
<p>Note that adjacency matrices may also be obtained using the extraction
operator.  See the relevant man page for details. Also note that which
attributes get returned by the <code>as_tibble</code> method by default depends on
<code>unit</code>: by default no edge attributes are returned but all vertex
attributes are.
</p>


<h3>Value</h3>

<p>For <code>as.matrix</code> methods, an adjacency, incidence, or edgelist
matrix. For the <code>as_tibble</code> method, a <code>tibble</code> whose first two
columns are <code>.head</code> and <code>.tail</code>, whose third column <code>.eid</code> is
the edge ID, and whose subsequent columns are the requested edge attributes.
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a> and David Hunter
<a href="mailto:dhunter@stat.psu.edu">dhunter@stat.psu.edu</a>
</p>


<h3>References</h3>

<p>Butts, C. T.  (2008).  &ldquo;network: a Package for Managing
Relational Data in R.&rdquo; <em>Journal of Statistical Software</em>, 24(2).
<a href="https://www.jstatsoft.org/v24/i02/">https://www.jstatsoft.org/v24/i02/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+which.matrix.type">which.matrix.type</a></code>, <code><a href="#topic+network">network</a></code>,
<code><a href="#topic+network.extraction">network.extraction</a></code>,<code><a href="#topic+as.edgelist">as.edgelist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create a random network
m &lt;- matrix(rbinom(25,4,0.159),5,5) # 50% density
diag(m) &lt;- 0
g &lt;- network(m, ignore.eval=FALSE, names.eval="a") # With values
g %e% "ac" &lt;- letters[g %e% "a"]

# Coerce to matrix form
# No attributes:
as.matrix(g,matrix.type="adjacency")
as.matrix(g,matrix.type="incidence")
as.matrix(g,matrix.type="edgelist")
# Attributes:
as.matrix(g,matrix.type="adjacency",attrname="a")
as.matrix(g,matrix.type="incidence",attrname="a")
as.matrix(g,matrix.type="edgelist",attrname="a")
as.matrix(g,matrix.type="edgelist",attrname="ac")

# Coerce to a tibble:
library(tibble)
as_tibble(g)
as_tibble(g, attrnames=c("a","ac"))
as_tibble(g, attrnames=TRUE)
# Get vertex attributes instead:
as_tibble(g, unit = "vertices")

# Missing data handling:
g[1,2] &lt;- NA
as.matrix(g,matrix.type="adjacency") # NA in the corresponding cell
as.matrix(g,matrix.type="edgelist", na.rm=TRUE) # (1,2) excluded
as.matrix(g,matrix.type="edgelist", na.rm=FALSE) # (1,2) included
as_tibble(g, attrnames="na", na.rm=FALSE) # Which edges are marked missing?

# Can also use the extraction operator
g[,]                            # Get entire adjacency matrix
g[1:2,3:5]                      # Obtain a submatrix

</code></pre>

<hr>
<h2 id='as.network.matrix'>Coercion from Matrices to Network Objects</h2><span id='topic+as.network.matrix'></span><span id='topic+as.network.default'></span>

<h3>Description</h3>

<p><code>as.network.matrix</code> attempts to coerce its first argument to an object
of class <code>network</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
as.network(x, ...)

## S3 method for class 'matrix'
as.network(
  x,
  matrix.type = NULL,
  directed = TRUE,
  hyper = FALSE,
  loops = FALSE,
  multiple = FALSE,
  bipartite = FALSE,
  ignore.eval = TRUE,
  names.eval = NULL,
  na.rm = FALSE,
  edge.check = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.network.matrix_+3A_x">x</code></td>
<td>
<p>a matrix containing an adjacency structure</p>
</td></tr>
<tr><td><code id="as.network.matrix_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="as.network.matrix_+3A_matrix.type">matrix.type</code></td>
<td>
<p>one of <code>"adjacency"</code>, <code>"edgelist"</code>,
<code>"incidence"</code>, or <code>NULL</code></p>
</td></tr>
<tr><td><code id="as.network.matrix_+3A_directed">directed</code></td>
<td>
<p>logical; should edges be interpreted as directed?</p>
</td></tr>
<tr><td><code id="as.network.matrix_+3A_hyper">hyper</code></td>
<td>
<p>logical; are hyperedges allowed?</p>
</td></tr>
<tr><td><code id="as.network.matrix_+3A_loops">loops</code></td>
<td>
<p>logical; should loops be allowed?</p>
</td></tr>
<tr><td><code id="as.network.matrix_+3A_multiple">multiple</code></td>
<td>
<p>logical; are multiplex edges allowed?</p>
</td></tr>
<tr><td><code id="as.network.matrix_+3A_bipartite">bipartite</code></td>
<td>
<p>count; should the network be interpreted as bipartite? If
present (i.e., non-NULL) it is the count of the number of actors in the
bipartite network. In this case, the number of nodes is equal to the number
of actors plus the number of events (with all actors preceding all events).
The edges are then interpreted as nondirected.</p>
</td></tr>
<tr><td><code id="as.network.matrix_+3A_ignore.eval">ignore.eval</code></td>
<td>
<p>logical; ignore edge values?</p>
</td></tr>
<tr><td><code id="as.network.matrix_+3A_names.eval">names.eval</code></td>
<td>
<p>optionally, the name of the attribute in which edge values
should be stored</p>
</td></tr>
<tr><td><code id="as.network.matrix_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; ignore missing entries when constructing the network?</p>
</td></tr>
<tr><td><code id="as.network.matrix_+3A_edge.check">edge.check</code></td>
<td>
<p>logical; perform consistency checks on new edges?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>matrix.type</code>, one of three edgeset constructor methods
will be employed to read the input matrix (see
<code><a href="#topic+edgeset.constructors">edgeset.constructors</a></code>).  If <code>matrix.type==NULL</code>,
<code><a href="#topic+which.matrix.type">which.matrix.type</a></code> will be used to guess the appropriate matrix
type.
</p>
<p>The coercion methods will recognize and attempt to utilize the <code>sna</code>
extended matrix attributes where feasible.  These are as follows: </p>

<ul>
<li><p><code>"n"</code>: taken to indicate number of vertices in the network.
</p>
</li>
<li><p><code>"bipartite"</code>: taken to indicate the network's <code>bipartite</code>
attribute, where present.  </p>
</li>
<li><p><code>"vnames"</code>: taken to contain vertex
names, where present.  </p>
</li></ul>
<p> These attributes are generally used with edgelists,
and indeed data in <code>sna</code> edgelist format should be transparently
converted in most cases.  Where the extended matrix attributes are in
conflict with the actual contents of <code>x</code>, results are no guaranteed
(but the latter will usually override the former). For an edge list, the
number of nodes in a network is determined by the number of unique nodes
specified. If there are isolate nodes not in the edge list, the &quot;n&quot;
attribute needs to be set. See example below.
</p>


<h3>Value</h3>

<p>An object of class <code>network</code>
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a> and David Hunter
<a href="mailto:dhunter@stat.psu.edu">dhunter@stat.psu.edu</a>
</p>


<h3>References</h3>

<p>Butts, C. T.  (2008).  &ldquo;network: a Package for Managing
Relational Data in R.&rdquo; <em>Journal of Statistical Software</em>, 24(2).
<a href="https://www.jstatsoft.org/v24/i02/">https://www.jstatsoft.org/v24/i02/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+edgeset.constructors">edgeset.constructors</a></code>, <code><a href="#topic+network">network</a></code>,
<code><a href="#topic+which.matrix.type">which.matrix.type</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Draw a random matrix
m&lt;-matrix(rbinom(25,1,0.5),5)
diag(m)&lt;-0

#Coerce to network form
g&lt;-as.network.matrix(m,matrix.type="adjacency")

# edge list example. Only 4 nodes in the edge list.
m = matrix(c(1,2, 2,3, 3,4), byrow = TRUE, nrow=3)
attr(m, 'n') = 7
as.network(m, matrix.type='edgelist')

</code></pre>

<hr>
<h2 id='as.sociomatrix'>Coerce One or More Networks to Sociomatrix Form</h2><span id='topic+as.sociomatrix'></span>

<h3>Description</h3>

<p><code>as.sociomatrix</code> takes adjacency matrices, adjacency arrays,
<code><a href="#topic+network">network</a></code> objects, or lists thereof, and returns one or more
sociomatrices (adjacency matrices) as appropriate.  This routine provides a
useful input-agnostic front-end to functions which process adjacency
matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.sociomatrix(
  x,
  attrname = NULL,
  simplify = TRUE,
  expand.bipartite = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.sociomatrix_+3A_x">x</code></td>
<td>
<p>an adjacency matrix, array, <code><a href="#topic+network">network</a></code> object, or list
thereof.</p>
</td></tr>
<tr><td><code id="as.sociomatrix_+3A_attrname">attrname</code></td>
<td>
<p>optionally, the name of a network attribute to use for
extracting edge values (if <code>x</code> is a <code><a href="#topic+network">network</a></code> object).</p>
</td></tr>
<tr><td><code id="as.sociomatrix_+3A_simplify">simplify</code></td>
<td>
<p>logical; should <code>as.sociomatrix</code> attempt to combine its
inputs into an adjacency array (<code>TRUE</code>), or return them as separate
list elements (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="as.sociomatrix_+3A_expand.bipartite">expand.bipartite</code></td>
<td>
<p>logical; if <code>x</code> is bipartite, should we return
the full adjacency matrix (rather than the abbreviated, two-mode form)?</p>
</td></tr>
<tr><td><code id="as.sociomatrix_+3A_...">...</code></td>
<td>
<p>additional arguments for the coercion routine.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as.sociomatrix</code> provides a more general means of coercing input into
adjacency matrix form than <code><a href="#topic+as.matrix.network">as.matrix.network</a></code>. In particular,
<code>as.sociomatrix</code> will attempt to coerce all input networks into the
appropriate form, and return the resulting matrices in a regularized manner.
If <code>simplify==TRUE</code>, <code>as.sociomatrix</code> attempts to return the
matrices as a single adjacency array.  If the input networks are of variable
size, or if <code>simplify==FALSE</code>, the networks in question are returned as
a list of matrices.  In any event, a single input network is always returned
as a lone matrix.
</p>
<p>If <code>attrname</code> is given, the specified edge attribute is used to extract
edge values from any <code><a href="#topic+network">network</a></code> objects contained in <code>x</code>.
Note that the same attribute will be used for all networks; if no attribute
is specified, the standard dichotomous default will be used instead.
</p>


<h3>Value</h3>

<p>One or more adjacency matrices.  If all matrices are of the same
dimension and <code>simplify==TRUE</code>, the matrices are joined into a single
array; otherwise, the return value is a list of single adjacency matrices.
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>References</h3>

<p>Butts, C. T.  (2008).  &ldquo;network: a Package for Managing
Relational Data in R.&rdquo; <em>Journal of Statistical Software</em>, 24(2).
<a href="https://www.jstatsoft.org/v24/i02/">https://www.jstatsoft.org/v24/i02/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.matrix.network">as.matrix.network</a></code>, <code><a href="#topic+network">network</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Generate an adjacency array
g&lt;-array(rbinom(100,1,0.5),dim=c(4,5,5))

#Generate a network object
net&lt;-network(matrix(rbinom(36,1,0.5),6,6))

#Coerce to adjacency matrix form using as.sociomatrix
as.sociomatrix(g,simplify=TRUE)   #Returns as-is
as.sociomatrix(g,simplify=FALSE)  #Returns as list
as.sociomatrix(net)               #Coerces to matrix
as.sociomatrix(list(net,g))       #Returns as list of matrices

</code></pre>

<hr>
<h2 id='attribute.methods'>Attribute Interface Methods for the Network Class</h2><span id='topic+attribute.methods'></span><span id='topic+delete.edge.attribute'></span><span id='topic+delete.edge.attribute.network'></span><span id='topic+delete.network.attribute'></span><span id='topic+delete.network.attribute.network'></span><span id='topic+delete.vertex.attribute'></span><span id='topic+delete.vertex.attribute.network'></span><span id='topic+get.edge.attribute'></span><span id='topic+get.edge.attribute.network'></span><span id='topic+get.edge.attribute.list'></span><span id='topic+get.edge.value'></span><span id='topic+get.edge.value.network'></span><span id='topic+get.edge.value.list'></span><span id='topic+get.network.attribute'></span><span id='topic+get.network.attribute.network'></span><span id='topic+get.vertex.attribute'></span><span id='topic+get.vertex.attribute.network'></span><span id='topic+list.edge.attributes'></span><span id='topic+list.edge.attributes.network'></span><span id='topic+list.network.attributes'></span><span id='topic+list.network.attributes.network'></span><span id='topic+list.vertex.attributes'></span><span id='topic+list.vertex.attributes.network'></span><span id='topic+network.vertex.names'></span><span id='topic+network.vertex.names+3C-'></span><span id='topic+set.edge.attribute'></span><span id='topic+set.edge.attribute.network'></span><span id='topic+set.edge.value'></span><span id='topic+set.edge.value.network'></span><span id='topic+set.network.attribute'></span><span id='topic+set.network.attribute.network'></span><span id='topic+set.vertex.attribute'></span><span id='topic+set.vertex.attribute.network'></span>

<h3>Description</h3>

<p>These methods get, set, list, and delete attributes at the
network, edge, and vertex level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete.edge.attribute(x, attrname, ...)

## S3 method for class 'network'
delete.edge.attribute(x, attrname, ...)

delete.network.attribute(x, attrname, ...)

## S3 method for class 'network'
delete.network.attribute(x, attrname, ...)

delete.vertex.attribute(x, attrname, ...)

## S3 method for class 'network'
delete.vertex.attribute(x, attrname, ...)

get.edge.attribute(x, ..., el)

## S3 method for class 'network'
get.edge.attribute(
  x,
  attrname,
  unlist = TRUE,
  na.omit = FALSE,
  null.na = FALSE,
  deleted.edges.omit = FALSE,
  ...,
  el
)

## S3 method for class 'list'
get.edge.attribute(
  x,
  attrname,
  unlist = TRUE,
  na.omit = FALSE,
  null.na = FALSE,
  deleted.edges.omit = FALSE,
  ...,
  el
)

get.edge.value(x, ...)

## S3 method for class 'network'
get.edge.value(
  x,
  attrname,
  unlist = TRUE,
  na.omit = FALSE,
  null.na = FALSE,
  deleted.edges.omit = FALSE,
  ...
)

## S3 method for class 'list'
get.edge.value(
  x,
  attrname,
  unlist = TRUE,
  na.omit = FALSE,
  null.na = FALSE,
  deleted.edges.omit = FALSE,
  ...
)

get.network.attribute(x, ...)

## S3 method for class 'network'
get.network.attribute(x, attrname, unlist = FALSE, ...)

get.vertex.attribute(x, ...)

## S3 method for class 'network'
get.vertex.attribute(
  x,
  attrname,
  na.omit = FALSE,
  null.na = TRUE,
  unlist = TRUE,
  ...
)

list.edge.attributes(x, ...)

## S3 method for class 'network'
list.edge.attributes(x, ...)

list.network.attributes(x, ...)

## S3 method for class 'network'
list.network.attributes(x, ...)

list.vertex.attributes(x, ...)

## S3 method for class 'network'
list.vertex.attributes(x, ...)

network.vertex.names(x)

network.vertex.names(x) &lt;- value

set.edge.attribute(x, attrname, value, e, ...)

## S3 method for class 'network'
set.edge.attribute(x, attrname, value, e = seq_along(x$mel), ...)

set.edge.value(x, attrname, value, e, ...)

## S3 method for class 'network'
set.edge.value(x, attrname, value, e = seq_along(x$mel), ...)

set.network.attribute(x, attrname, value, ...)

## S3 method for class 'network'
set.network.attribute(x, attrname, value, ...)

set.vertex.attribute(x, attrname, value, v = seq_len(network.size(x)), ...)

## S3 method for class 'network'
set.vertex.attribute(x, attrname, value, v = seq_len(network.size(x)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="attribute.methods_+3A_x">x</code></td>
<td>
<p>an object of class <code>network</code>, or a list of edges
(possibly <code>network$mel</code>) in <code>get.edge.attribute</code>.</p>
</td></tr>
<tr><td><code id="attribute.methods_+3A_attrname">attrname</code></td>
<td>
<p>the name of the attribute to get or set.</p>
</td></tr>
<tr><td><code id="attribute.methods_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="attribute.methods_+3A_el">el</code></td>
<td>
<p>Deprecated; use <code>x</code> instead.</p>
</td></tr>
<tr><td><code id="attribute.methods_+3A_unlist">unlist</code></td>
<td>
<p>logical; should retrieved attribute values be
<code><a href="base.html#topic+unlist">unlist</a></code>ed prior to being returned?</p>
</td></tr>
<tr><td><code id="attribute.methods_+3A_na.omit">na.omit</code></td>
<td>
<p>logical; should retrieved attribute values corresponding to
vertices/edges marked as 'missing' be removed?</p>
</td></tr>
<tr><td><code id="attribute.methods_+3A_null.na">null.na</code></td>
<td>
<p>logical; should <code>NULL</code> values (corresponding to vertices
or edges with no values set for the attribute) be replaced with <code>NA</code>s
in output?</p>
</td></tr>
<tr><td><code id="attribute.methods_+3A_deleted.edges.omit">deleted.edges.omit</code></td>
<td>
<p>logical: should the elements corresponding to
deleted edges be removed?</p>
</td></tr>
<tr><td><code id="attribute.methods_+3A_value">value</code></td>
<td>
<p>values of the attribute to be set; these should be in
<code>vector</code> or <code>list</code> form for the <code>edge</code> and <code>vertex</code>
cases, or <code>matrix</code> form for <code>set.edge.value</code>.</p>
</td></tr>
<tr><td><code id="attribute.methods_+3A_e">e</code></td>
<td>
<p>IDs for the edges whose attributes are to be altered.</p>
</td></tr>
<tr><td><code id="attribute.methods_+3A_v">v</code></td>
<td>
<p>IDs for the vertices whose attributes are to be altered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>list.attributes</code> functions return the names of all edge,
network, or vertex attributes (respectively) in the network.  All
attributes need not be defined for all elements; the union of all extant
attributes for the respective element type is returned.
</p>
<p>The <code>get.attribute</code> functions look for an edge, network, or vertex
attribute (respectively) with the name <code>attrname</code>, returning its
values.  Note that, to retrieve an edge attribute from all edges within
a network <code>x</code>, <code>x$mel</code> should be used as the first argument to
<code>get.edge.attribute</code>; <code>get.edge.value</code> is a convenience function
which does this automatically. As of v1.7.2, if a <code>network</code> object is
passed to <code>get.edge.attribute</code> it will automatically call
<code>get.edge.value</code> instead of returning NULL. When the parameters
<code>na.omit</code>,  or <code>deleted.edges.omit</code> are used, the position index
of the attribute values returned will not correspond to the vertex/edge
id.  To preserved backward compatibility, if the edge attribute
<code>attrname</code> does not exist for any edge, <code>get.edge.attribute</code>
will still return <code>NULL</code> even if <code>null.na=TRUE</code>
</p>
<p><code>network.vertex.names</code> is a convenience function to extract the
<code>"vertex.names"</code> attribute from all vertices.
</p>
<p>The <code>set.attribute</code> functions allow one to set the values of edge,
network, or vertex attributes.  <code>set.edge.value</code> is a convenience
function which allows edge attributes to be given in adjacency matrix
form, and the assignment form of <code>network.vertex.names</code> is likewise
a convenient front-end to <code>set.vertex.attribute</code> for vertex names.
The <code>delete.attribute</code> functions, by contrast, remove the named
attribute from the network, from all edges, or from all vertices (as
appropriate).  If <code>attrname</code> is a vector of attribute names, each
will be removed in turn.  These functions modify their arguments in place,
although a pointer to the modified object is also (invisibly) returned.
</p>
<p>Additional practical example of how to load and attach attributes are on the
<code><a href="#topic+loading.attributes">loading.attributes</a></code> page.
</p>
<p>Some attribute assignment/extraction can be performed conveniently through
the various extraction/replacement operators, although they may be less
efficient.  See the associated man page for details.
</p>


<h3>Value</h3>

<p>For the <code>list.attributes</code> methods, a vector containing
attribute names.  For the <code>get.attribute</code> methods, a list containing
the values of the attribute in question (or simply the value itself, for
<code>get.network.attribute</code>).  For the <code>set.attribute</code> and
<code>delete.attribute</code> methods, a pointer to the updated <code>network</code>
object.
</p>


<h3>Note</h3>

<p>As of version 1.9 the <code>set.vertex.attribute</code> function can accept
and modify multiple attributes in a single call to improve efficiency.
For this case <code>attrname</code> can be a list or vector of attribute names
and <code>value</code> is a list of values corresponding to the elements of
<code>attrname</code> (can also be a list of lists of values if elements in v
should have different values).
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>References</h3>

<p>Butts, C. T.  (2008).  &ldquo;network: a Package for Managing
Relational Data in R.&rdquo;  <em>Journal of Statistical Software</em>, 24(2).
<a href="https://www.jstatsoft.org/v24/i02/">https://www.jstatsoft.org/v24/i02/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loading.attributes">loading.attributes</a></code>,<code><a href="#topic+network">network</a></code>,
<code><a href="#topic+as.network.matrix">as.network.matrix</a></code>, <code><a href="#topic+as.sociomatrix">as.sociomatrix</a></code>,
<code><a href="#topic+as.matrix.network">as.matrix.network</a></code>, <code><a href="#topic+network.extraction">network.extraction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create a network with three edges
m&lt;-matrix(0,3,3)
m[1,2]&lt;-1; m[2,3]&lt;-1; m[3,1]&lt;-1
g&lt;-network(m)

#Create a matrix of values corresponding to edges
mm&lt;-m
mm[1,2]&lt;-7; mm[2,3]&lt;-4; mm[3,1]&lt;-2

#Assign some attributes
set.edge.attribute(g,"myeval",3:5)
set.edge.value(g,"myeval2",mm)
set.network.attribute(g,"mygval","boo")
set.vertex.attribute(g,"myvval",letters[1:3])
network.vertex.names(g) &lt;- LETTERS[1:10]

#List the attributes
list.edge.attributes(g)
list.network.attributes(g)
list.vertex.attributes(g)

#Retrieve the attributes
get.edge.attribute(g$mel,"myeval")  #Note the first argument!
get.edge.value(g,"myeval")          #Another way to do this
get.edge.attribute(g$mel,"myeval2") 
get.network.attribute(g,"mygval")
get.vertex.attribute(g,"myvval")
network.vertex.names(g)

#Purge the attributes
delete.edge.attribute(g,"myeval")
delete.edge.attribute(g,"myeval2")
delete.network.attribute(g,"mygval")
delete.vertex.attribute(g,"myvval")

#Verify that the attributes are gone
list.edge.attributes(g)
list.network.attributes(g)
list.vertex.attributes(g)

#Note that we can do similar things using operators
g %n% "mygval" &lt;- "boo"               #Set attributes, as above
g %v% "myvval" &lt;- letters[1:3]
g %e% "myeval" &lt;- mm
g[,,names.eval="myeval"] &lt;- mm          #Another way to do this
g %n% "mygval"                        #Retrieve the attributes
g %v% "myvval"
g %e% "mevval"
as.sociomatrix(g,"myeval")              # Or like this

</code></pre>

<hr>
<h2 id='deletion.methods'>Remove Elements from a Network Object</h2><span id='topic+deletion.methods'></span><span id='topic+delete.edges'></span><span id='topic+delete.edges.network'></span><span id='topic+delete.vertices'></span><span id='topic+delete.vertices.network'></span>

<h3>Description</h3>

<p><code>delete.edges</code> removes one or more edges (specified by
their internal ID numbers) from a network; <code>delete.vertices</code>
performs the same task for vertices (removing all associated edges in
the process).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete.edges(x, eid, ...)

## S3 method for class 'network'
delete.edges(x, eid, ...)

delete.vertices(x, vid, ...)

## S3 method for class 'network'
delete.vertices(x, vid, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deletion.methods_+3A_x">x</code></td>
<td>
<p>an object of class <code>network</code>.</p>
</td></tr>
<tr><td><code id="deletion.methods_+3A_eid">eid</code></td>
<td>
<p>a vector of edge IDs.</p>
</td></tr>
<tr><td><code id="deletion.methods_+3A_...">...</code></td>
<td>
<p>additional arguments to methods.</p>
</td></tr>
<tr><td><code id="deletion.methods_+3A_vid">vid</code></td>
<td>
<p>a vector of vertex IDs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that an edge's ID number corresponds to its order within
<code>x$mel</code>.  To determine edge IDs, see <code><a href="#topic+get.edgeIDs">get.edgeIDs</a></code>.
Likewise, vertex ID numbers reflect the order with which vertices are
listed internally (e.g., the order of <code>x$oel</code> and <code>x$iel</code>, or
that used by <code>as.matrix.network.adjacency</code>).  When vertices are
removed from a network, all edges having those vertices as endpoints are
removed as well.  When edges are removed, the remaining edge ids are NOT
permuted and <code>NULL</code> elements will be left on the list of edges, which
may complicate some functions that require eids (such as
<code><a href="#topic+set.edge.attribute">set.edge.attribute</a></code>).  The function <code><a href="#topic+valid.eids">valid.eids</a></code>
provides a means to determine the set of valid (non-NULL) edge ids.
</p>
<p>Edges can also be added/removed via the extraction/replacement operators.
See the associated man page for details.
</p>


<h3>Value</h3>

<p>Invisibly, a pointer to the updated network; these functions modify
their arguments in place.
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>References</h3>

<p>Butts, C. T.  (2008).  &ldquo;network: a Package for Managing
Relational Data in R.&rdquo;  <em>Journal of Statistical Software</em>, 24(2).
<a href="https://www.jstatsoft.org/v24/i02/">https://www.jstatsoft.org/v24/i02/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.edgeIDs">get.edgeIDs</a></code>, <code><a href="#topic+network.extraction">network.extraction</a></code>,
<code><a href="#topic+valid.eids">valid.eids</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create a network with three edges
m&lt;-matrix(0,3,3)
m[1,2]&lt;-1; m[2,3]&lt;-1; m[3,1]&lt;-1
g&lt;-network(m)

as.matrix.network(g)
delete.edges(g,2)              #Remove an edge
as.matrix.network(g)
delete.vertices(g,2)           #Remove a vertex
as.matrix.network(g)

#Can also remove edges using extraction/replacement operators
g&lt;-network(m)
g[1,2]&lt;-0                      #Remove an edge
g[,]
g[,]&lt;-0                        #Remove all edges
g[,]

</code></pre>

<hr>
<h2 id='edgeset.constructors'>Edgeset Constructors for Network Objects</h2><span id='topic+edgeset.constructors'></span><span id='topic+network.bipartite'></span><span id='topic+network.adjacency'></span><span id='topic+network.edgelist'></span><span id='topic+network.incidence'></span>

<h3>Description</h3>

<p>These functions convert relational data in matrix form to
network edge sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network.bipartite(x, g, ignore.eval = TRUE, names.eval = NULL, ...)

network.adjacency(x, g, ignore.eval = TRUE, names.eval = NULL, ...)

network.edgelist(x, g, ignore.eval = TRUE, names.eval = NULL, ...)

network.incidence(x, g, ignore.eval = TRUE, names.eval = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edgeset.constructors_+3A_x">x</code></td>
<td>
<p>a matrix containing edge information</p>
</td></tr>
<tr><td><code id="edgeset.constructors_+3A_g">g</code></td>
<td>
<p>an object of class <code>network</code></p>
</td></tr>
<tr><td><code id="edgeset.constructors_+3A_ignore.eval">ignore.eval</code></td>
<td>
<p>logical; ignore edge value information in x?</p>
</td></tr>
<tr><td><code id="edgeset.constructors_+3A_names.eval">names.eval</code></td>
<td>
<p>a name for the edge attribute under which to store edge
values, if any</p>
</td></tr>
<tr><td><code id="edgeset.constructors_+3A_...">...</code></td>
<td>
<p>possible additional arguments (such as <code>edge.check</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each of the above functions takes a <code>network</code> and a matrix
as input, and modifies the supplied <code>network</code> object by adding the
appropriate edges.  <code>network.adjacency</code> takes <code>x</code> to be an
adjacency matrix; <code>network.edgelist</code> takes <code>x</code> to be an edgelist
matrix; and <code>network.incidence</code> takes <code>x</code> to be an incidence
matrix.  <code>network.bipartite</code> takes <code>x</code> to be a two-mode
adjacency matrix where rows and columns reflect each respective mode
(conventionally, actors and events); If <code>ignore.eval==FALSE</code>,
(non-zero) edge values are stored as edgewise attributes with name
<code>names.eval</code>.  The <code>edge.check</code> argument can be added via
<code>...</code> and will be passed to <code><a href="#topic+add.edges">add.edges</a></code>.
</p>
<p>Edgelist matrices to be used with <code>network.edgelist</code> should have one
row per edge, with the first two columns indicating the sender and
receiver of each edge (respectively).  Edge values may be provided in
additional columns. The edge attributes will be created with names
corresponding to the column names unless alternate names are provided via
<code>names.eval</code>. The vertices specified in the first two columns, which
can be characters, are added to the network in default sort order. The
edges are added in the order specified by the edgelist matrix.
</p>
<p>Incidence matrices should contain one row per vertex, with one column per
edge. A non-zero entry in the matrix means that the edge with the id
corresponding to the column index will have an incident vertex with an
id corresponding to the row index. In the directed case, negative cell
values are taken to indicate tail vertices, while positive values
indicate head vertices.
</p>
<p>Results similar to <code>network.adjacency</code> can also be obtained by means
of extraction/replacement operators.  See the associated man page for
details.
</p>


<h3>Value</h3>

<p>Invisibly, an object of class <code>network</code>; these functions modify
their argument in place.
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a> and David Hunter
<a href="mailto:dhunter@stat.psu.edu">dhunter@stat.psu.edu</a>
</p>


<h3>References</h3>

<p>Butts, C. T.  (2008).  &ldquo;network: a Package for Managing
Relational Data in R.&rdquo;  <em>Journal of Statistical Software</em>, 24(2).
<a href="https://www.jstatsoft.org/v24/i02/">https://www.jstatsoft.org/v24/i02/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loading.attributes">loading.attributes</a></code>, <code><a href="#topic+network">network</a></code>,
<code><a href="#topic+network.initialize">network.initialize</a></code>, <code><a href="#topic+add.edges">add.edges</a></code>,
<code><a href="#topic+network.extraction">network.extraction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create an arbitrary adjacency matrix
m&lt;-matrix(rbinom(25,1,0.5),5,5)
diag(m)&lt;-0

g&lt;-network.initialize(5)    #Initialize the network
network.adjacency(m,g)      #Import the edge data

#Do the same thing, using replacement operators
g&lt;-network.initialize(5)
g[,]&lt;-m

# load edges from a data.frame via network.edgelist
edata &lt;-data.frame(
  tails=c(1,2,3),
  heads=c(2,3,1),
  love=c('yes','no','maybe'),
  hate=c(3,-5,2),
  stringsAsFactors=FALSE
  )

g&lt;-network.edgelist(edata,network.initialize(4),ignore.eval=FALSE)
as.sociomatrix(g,attrname='hate')
g%e%'love'

# load edges from an incidence matrix
inci&lt;-matrix(c(1,1,0,0, 0,1,1,0, 1,0,1,0),ncol=3,byrow=FALSE)
inci
g&lt;-network.incidence(inci,network.initialize(4,directed=FALSE))
as.matrix(g)




</code></pre>

<hr>
<h2 id='emon'>Interorganizational Search and Rescue Networks (Drabek et al.)</h2><span id='topic+emon'></span>

<h3>Description</h3>

<p>Drabek et al. (1981) provide seven case studies of emergent
multi-organizational networks (EMONs) in the context of search and rescue
(SAR) activities.  Networks of interaction frequency are reported, along
with several organizational attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(emon)
</code></pre>


<h3>Format</h3>

<p>A list of 7 <code><a href="#topic+network">network</a></code> objects:
</p>

<table>
<tr>
 <td style="text-align: right;">
<code style="white-space: pre;">&#8288;[[1]]&#8288;</code> </td><td style="text-align: left;"> Cheyenne     </td><td style="text-align: left;"> network </td><td style="text-align: left;"> Cheyenne SAR EMON</td>
</tr>
<tr>
 <td style="text-align: right;">
<code style="white-space: pre;">&#8288;[[2]]&#8288;</code> </td><td style="text-align: left;"> HurrFrederic </td><td style="text-align: left;"> network </td><td style="text-align: left;"> Hurricane Frederic SAR EMON</td>
</tr>
<tr>
 <td style="text-align: right;">
<code style="white-space: pre;">&#8288;[[3]]&#8288;</code> </td><td style="text-align: left;"> LakePomona   </td><td style="text-align: left;"> network </td><td style="text-align: left;"> Lake Pomona SAR EMON</td>
</tr>
<tr>
 <td style="text-align: right;">
<code style="white-space: pre;">&#8288;[[4]]&#8288;</code> </td><td style="text-align: left;"> MtSi         </td><td style="text-align: left;"> network </td><td style="text-align: left;"> Mt. Si SAR EMON</td>
</tr>
<tr>
 <td style="text-align: right;">
<code style="white-space: pre;">&#8288;[[5]]&#8288;</code> </td><td style="text-align: left;"> MtStHelens   </td><td style="text-align: left;"> network </td><td style="text-align: left;"> Mt. St. Helens SAR EMON</td>
</tr>
<tr>
 <td style="text-align: right;">
<code style="white-space: pre;">&#8288;[[6]]&#8288;</code> </td><td style="text-align: left;"> Texas        </td><td style="text-align: left;"> network </td><td style="text-align: left;"> Texas Hill Country SAR EMON</td>
</tr>
<tr>
 <td style="text-align: right;">
<code style="white-space: pre;">&#8288;[[7]]&#8288;</code> </td><td style="text-align: left;"> Wichita      </td><td style="text-align: left;"> network </td><td style="text-align: left;"> Wichita Falls SAR EMON
</td>
</tr>

</table>

<p>Each network has one edge attribute:
</p>

<table>
<tr>
 <td style="text-align: left;"> Frequency </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Interaction frequency (1-4;
1=most frequent) </td>
</tr>

</table>

<p>Each network also has 8 vertex attributes:
</p>

<table>
<tr>
 <td style="text-align: left;">
Command.Rank.Score  </td><td style="text-align: left;"> numeric   </td><td style="text-align: left;"> Mean rank in the command structure</td>
</tr>
<tr>
 <td style="text-align: left;">
Decision.Rank.Score </td><td style="text-align: left;"> numeric   </td><td style="text-align: left;"> Mean rank in the decision process</td>
</tr>
<tr>
 <td style="text-align: left;">
Formalization       </td><td style="text-align: left;"> numeric   </td><td style="text-align: left;"> Degree of formalization</td>
</tr>
<tr>
 <td style="text-align: left;">
Location            </td><td style="text-align: left;"> character </td><td style="text-align: left;"> Location code</td>
</tr>
<tr>
 <td style="text-align: left;">
Paid.Staff          </td><td style="text-align: left;"> numeric   </td><td style="text-align: left;"> Number of paid staff</td>
</tr>
<tr>
 <td style="text-align: left;">
Sponsorship         </td><td style="text-align: left;"> character </td><td style="text-align: left;"> Sponsorship type</td>
</tr>
<tr>
 <td style="text-align: left;">
vertex.names        </td><td style="text-align: left;"> character </td><td style="text-align: left;"> Organization name</td>
</tr>
<tr>
 <td style="text-align: left;">
Volunteer.Staff     </td><td style="text-align: left;"> numeric   </td><td style="text-align: left;"> Number of volunteer staff
</td>
</tr>

</table>



<h3>Details</h3>

<p>All networks collected by Drabek et al. reflect reported frequency of
organizational interaction during the search and rescue effort; the (i,j)
edge constitutes i's report regarding interaction with j, with non-adjacent
vertices reporting no contact.  Frequency is rated on a four-point scale,
with 1 indicating the highest frequency of interaction.  (Response options:
1=&ldquo;continuously&rdquo;, 2=&ldquo;about once an hour&rdquo;, 3=&ldquo;every few
hours&rdquo;, 4=&ldquo;about once a day or less&rdquo;) This is stored within the
<code>"Frequency"</code> edge attribute.
</p>
<p>For each network, several covariates are recorded as vertex attributes:
</p>

<dl>
<dt>Command.Rank.Score</dt><dd><p> Mean (reversed) rank for the
prominence of each organization in the command structure of the response, as
judged by organizational informants.</p>
</dd>
<dt>Decision.Rank.Score</dt><dd><p> Mean (reversed) rank for the
prominence of each organization in decision making
processes during the response, as judged by organizational informants.</p>
</dd>
<dt>Formalization</dt><dd><p> An index of organizational formalization, ranging from
0 (least formalized) to 4 (most formalized).</p>
</dd> <dt>Localization</dt><dd><p> For each
organization, <code>"L"</code> if the organization was sited locally to the impact
area, <code>"NL"</code> if the organization was not sited near the impact area,
<code>"B"</code> if the organization was sited at both local and non-local
locations.</p>
</dd>
<dt>Paid.Staff</dt><dd><p> Number of paid staff employed by each
organization at the time of the response.</p>
</dd>
<dt>Sponsorship</dt><dd><p> The level at which each organization
was sponsored (e.g., <code>"City"</code>, <code>"County"</code>,
<code>"State"</code>, <code>"Federal"</code>, and <code>"Private"</code>).</p>
</dd>
<dt>vertex.names</dt><dd><p> The identity of each organization.</p>
</dd>
<dt>Volunteer.Staff</dt><dd><p> Number of volunteer staff employed by each
organization at the time of the response.</p>
</dd>
</dl>

<p>Note that where intervals were given by the original source, midpoints have
been substituted.  For detailed information regarding data coding and
procedures, see Drabek et al. (1981).
</p>


<h3>Source</h3>

<p>Drabek, T.E.; Tamminga, H.L.; Kilijanek, T.S.; and Adams, C.R.
(1981).  <em>Data from Managing Multiorganizational Emergency Responses:
Emergent Search and Rescue Networks in Natural Disaster and Remote Area
Settings.</em> Program on Technology, Environment, and Man Monograph 33.
Institute for Behavioral Science, University of Colorado.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+network">network</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(emon)   #Load the emon data set

#Plot the EMONs
par(mfrow=c(3,3))
for(i in 1:length(emon))
  plot(emon[[i]],main=names(emon)[i],edge.lwd="Frequency")

</code></pre>

<hr>
<h2 id='flo'>Florentine Wedding Data (Padgett)</h2><span id='topic+flo'></span>

<h3>Description</h3>

<p>This is a data set of Padgett (1994), consisting of weddings among leading
Florentine families.  This data is stored in symmetric adjacency matrix
form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(flo)
</code></pre>


<h3>Source</h3>

<p>Padgett, John F.  (1994). &ldquo;Marriage and Elite Structure in
Renaissance Florence, 1282-1500.&rdquo; Paper delivered to the Social Science
History Association.
</p>


<h3>References</h3>

<p>Wasserman, S. and Faust, K. (1994) <em>Social Network
Analysis: Methods and Applications</em>, Cambridge: Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+network">network</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(flo)
nflo&lt;-network(flo,directed=FALSE)    #Convert to network object form
all(nflo[,]==flo)                    #Trust, but verify
                                     #A fancy display:
plot(nflo,displaylabels=TRUE,boxed.labels=FALSE,label.cex=0.75)

</code></pre>

<hr>
<h2 id='get.edges'>Retrieve Edges or Edge IDs Associated with a Given Vertex</h2><span id='topic+get.edges'></span><span id='topic+get.edgeIDs'></span><span id='topic+get.dyads.eids'></span>

<h3>Description</h3>

<p><code>get.edges</code> retrieves a list of edges incident on a given vertex;
<code>get.edgeIDs</code> returns the internal identifiers for those edges,
instead.  Both allow edges to be selected based on vertex neighborhood and
(optionally) an additional endpoint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.edgeIDs(
  x,
  v,
  alter = NULL,
  neighborhood = c("out", "in", "combined"),
  na.omit = TRUE
)

get.edges(
  x,
  v,
  alter = NULL,
  neighborhood = c("out", "in", "combined"),
  na.omit = TRUE
)

get.dyads.eids(
  x,
  tails,
  heads,
  neighborhood = c("out", "in", "combined"),
  na.omit = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.edges_+3A_x">x</code></td>
<td>
<p>an object of class <code>network</code></p>
</td></tr>
<tr><td><code id="get.edges_+3A_v">v</code></td>
<td>
<p>a vertex ID</p>
</td></tr>
<tr><td><code id="get.edges_+3A_alter">alter</code></td>
<td>
<p>optionally, the ID of another vertex</p>
</td></tr>
<tr><td><code id="get.edges_+3A_neighborhood">neighborhood</code></td>
<td>
<p>an indicator for whether we are interested in in-edges,
out-edges, or both (relative to <code>v</code>). defaults to <code>'combined'</code> for
undirected networks</p>
</td></tr>
<tr><td><code id="get.edges_+3A_na.omit">na.omit</code></td>
<td>
<p>logical; should we omit missing edges?</p>
</td></tr>
<tr><td><code id="get.edges_+3A_tails">tails</code></td>
<td>
<p>a vector of vertex ID for the 'tails' (v) side of the dyad</p>
</td></tr>
<tr><td><code id="get.edges_+3A_heads">heads</code></td>
<td>
<p>a vector of vertex ID for the 'heads' (alter) side of the dyad</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, <code>get.edges</code> returns all out-, in-, or out- and in-edges
containing <code>v</code>.  <code>get.edgeIDs</code> is identical, save in its return
value, as it returns only the ids of the edges.  Specifying a vertex in
<code>alter</code> causes these edges to be further selected such that alter must
also belong to the edge &ndash; this can be used to extract edges between two
particular vertices.  Omission of missing edges is accomplished via
<code>na.omit</code>.  Note that for multiplex networks, multiple edges or edge
ids can be returned.
</p>
<p>The function <code>get.dyads.eids</code> simplifies the process of looking up the
edge ids associated with a set of 'dyads' (tail and head vertex ids) for
edges. It only is intended for working with non-multiplex networks and will
return a warning and <code>NA</code> value for any dyads that correspond to
multiple edges. The value <code>numeric(0)</code> will be returned for any dyads
that do not have a corresponding edge.
</p>


<h3>Value</h3>

<p>For <code>get.edges</code>, a list of edges.  For <code>get.edgeIDs</code>, a
vector of edge ID numbers. For <code>get.dyads.eids</code>, a list of edge IDs
corresponding to the dyads defined by the vertex ids in <code>tails</code> and
<code>heads</code>
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>References</h3>

<p>Butts, C. T.  (2008).  &ldquo;network: a Package for Managing
Relational Data in R.&rdquo; <em>Journal of Statistical Software</em>, 24(2).
<a href="https://www.jstatsoft.org/v24/i02/">https://www.jstatsoft.org/v24/i02/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.neighborhood">get.neighborhood</a></code>, <code><a href="#topic+valid.eids">valid.eids</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Create a network with three edges
m&lt;-matrix(0,3,3)
m[1,2]&lt;-1; m[2,3]&lt;-1; m[3,1]&lt;-1
g&lt;-network(m)

get.edges(g,1,neighborhood="out")
get.edgeIDs(g,1,neighborhood="in")

</code></pre>

<hr>
<h2 id='get.inducedSubgraph'>Retrieve Induced Subgraphs and Cuts</h2><span id='topic+get.inducedSubgraph'></span><span id='topic++25s+25'></span>

<h3>Description</h3>

<p>Given a set of vertex IDs, <code>get.inducedSubgraph</code> returns the subgraph
induced by the specified vertices (i.e., the vertices and all associated
edges).  Optionally, passing a second set of alters returns the cut from the
first to the second set (i.e., all edges passing between the sets), along
with the associated endpoints. Alternatively, passing in a vector of edge
ids will induce a subgraph containing the specified edges and their incident
vertices.  In all cases, the result is returned as a network object, with
all attributes of the selected edges and/or vertices (and any network
attributes) preserved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.inducedSubgraph(x, v, alters = NULL, eid = NULL)

x %s% v
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.inducedSubgraph_+3A_x">x</code></td>
<td>
<p>an object of class <code>network</code>.</p>
</td></tr>
<tr><td><code id="get.inducedSubgraph_+3A_v">v</code></td>
<td>
<p>a vector of vertex IDs, or, for <code>%s%</code>, optionally a list containing two disjoint vectors of vertex IDs (see below).</p>
</td></tr>
<tr><td><code id="get.inducedSubgraph_+3A_alters">alters</code></td>
<td>
<p>optionally, a second vector of vertex IDs.  Must be disjoint
with <code>v</code>.</p>
</td></tr>
<tr><td><code id="get.inducedSubgraph_+3A_eid">eid</code></td>
<td>
<p>optionally, a numeric vector of valid edge ids in <code>x</code> that
should be retained (cannot be used with <code>v</code> or <code>alter</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>get.inducedSubgraph</code>, <code>v</code> can be a vector of vertex IDs.  If
<code>alter=NULL</code>, the subgraph induced by these vertices is returned.
Calling <code>%s%</code> with a single vector of vertices has an identical effect.
</p>
<p>Where <code>alters</code> is specified, it must be a vector of IDs disjoint with
<code>v</code>.  Where both are given, the edges spanning <code>v</code> and
<code>alters</code> are returned, along with the vertices in question.
(Technically, only the edges really constitute the &ldquo;cut,&rdquo; but the
vertices are included as well.)  The same result can be obtained with the
<code>%s%</code> operator by passing a two-element list on the right hand side;
the first element is then interpreted as <code>v</code>, and the second as
<code>alters</code>.
</p>
<p>When <code>eid</code> is specified, the <code>v</code> and <code>alters</code> argument will
be ignored and the subgraph induced by the specified edges and their
incident vertices will be returned.
</p>
<p>Any network, vertex, or edge attributes for the selected network elements
are retained (although features such as vertex IDs and the network size will
typically change).  These are copies of the elements in the original
network, which is not altered by this function.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+network">network</a></code> object containing the induced subgraph.
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+network">network</a></code>, <code><a href="#topic+network.extraction">network.extraction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Load the Drabek et al. EMON data
data(emon)

#For the Mt. St. Helens, EMON, several types of organizations are present:
type&lt;-emon$MtStHelens %v% "Sponsorship"

#Plot interactions among the state organizations
plot(emon$MtStHelens %s% which(type=="State"), displaylabels=TRUE)

#Plot state/federal interactions
plot(emon$MtStHelens %s% list(which(type=="State"), 
    which(type=="Federal")),  displaylabels=TRUE)

#Plot state interactions with everyone else
plot(emon$MtStHelens %s% list(which(type=="State"), 
    which(type!="State")), displaylabels=TRUE)
    
# plot only interactions with frequency of 2
subG2&lt;-get.inducedSubgraph(emon$MtStHelens,
            eid=which(emon$MtStHelens%e%'Frequency'==2))
plot(subG2,edge.label='Frequency')


</code></pre>

<hr>
<h2 id='get.neighborhood'>Obtain the Neighborhood of a Given Vertex</h2><span id='topic+get.neighborhood'></span>

<h3>Description</h3>

<p><code>get.neighborhood</code> returns the IDs of all vertices belonging to the in,
out, or combined neighborhoods of <code>v</code> within network <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.neighborhood(x, v, type = c("out", "in", "combined"), na.omit = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.neighborhood_+3A_x">x</code></td>
<td>
<p>an object of class <code>network</code></p>
</td></tr>
<tr><td><code id="get.neighborhood_+3A_v">v</code></td>
<td>
<p>a vertex ID</p>
</td></tr>
<tr><td><code id="get.neighborhood_+3A_type">type</code></td>
<td>
<p>the neighborhood to be computed</p>
</td></tr>
<tr><td><code id="get.neighborhood_+3A_na.omit">na.omit</code></td>
<td>
<p>logical; should missing edges be ignored when obtaining
vertex neighborhoods?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the combined neighborhood is the union of the in and out
neighborhoods &ndash; as such, no vertex will appear twice.
</p>


<h3>Value</h3>

<p>A vector containing the vertex IDs for the chosen neighborhood.
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>References</h3>

<p>Butts, C. T.  (2008).  &ldquo;network: a Package for Managing
Relational Data in R.&rdquo; <em>Journal of Statistical Software</em>, 24(2).
<a href="https://www.jstatsoft.org/v24/i02/">https://www.jstatsoft.org/v24/i02/</a>
</p>
<p>Wasserman, S. and Faust, K.  1994.  <em>Social Network Analysis: Methods
and Applications.</em> Cambridge: Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.edges">get.edges</a></code>, <code><a href="#topic+is.adjacent">is.adjacent</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Create a network with three edges
m&lt;-matrix(0,3,3)
m[1,2]&lt;-1; m[2,3]&lt;-1; m[3,1]&lt;-1
g&lt;-network(m)

#Examine the neighborhood of vertex 1
get.neighborhood(g,1,"out")
get.neighborhood(g,1,"in")
get.neighborhood(g,1,"combined")

</code></pre>

<hr>
<h2 id='has.edges'>Determine if specified vertices of a network have any edges (are not
isolates)</h2><span id='topic+has.edges'></span><span id='topic+is.isolate'></span>

<h3>Description</h3>

<p>Returns a logical value for each specified vertex, indicating if it has any
incident (in or out) edges.  Checks all vertices by default
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has.edges(net, v = seq_len(network.size(net)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has.edges_+3A_net">net</code></td>
<td>
<p>a <code><a href="#topic+network">network</a></code> object to be queried</p>
</td></tr>
<tr><td><code id="has.edges_+3A_v">v</code></td>
<td>
<p>integer vector of vertex ids to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a logical vector with the same length as v, with TRUE if the
vertex is involved in any edges, FALSE if it is an isolate.
</p>


<h3>Author(s)</h3>

<p>skyebend
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
test&lt;-network.initialize(5)
test[1,2]&lt;-1
has.edges(test)
has.edges(test,v=5)

</code></pre>

<hr>
<h2 id='is.adjacent'>Determine Whether Two Vertices Are Adjacent</h2><span id='topic+is.adjacent'></span>

<h3>Description</h3>

<p><code>is.adjacent</code> returns <code>TRUE</code> iff <code>vi</code> is adjacent to
<code>vj</code> in <code>x</code>.  Missing edges may be omitted or not, as per
<code>na.omit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.adjacent(x, vi, vj, na.omit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.adjacent_+3A_x">x</code></td>
<td>
<p>an object of class <code>network</code></p>
</td></tr>
<tr><td><code id="is.adjacent_+3A_vi">vi</code></td>
<td>
<p>a vertex ID</p>
</td></tr>
<tr><td><code id="is.adjacent_+3A_vj">vj</code></td>
<td>
<p>a second vertex ID</p>
</td></tr>
<tr><td><code id="is.adjacent_+3A_na.omit">na.omit</code></td>
<td>
<p>logical; should missing edges be ignored when assessing
adjacency?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vertex <code class="reqn">v</code> is said to be adjacent to vertex <code class="reqn">v'</code> within directed
network <code class="reqn">G</code> iff there exists some edge whose tail set contains <code class="reqn">v</code>
and whose head set contains <code class="reqn">v'</code>.  In the undirected case, head and tail
sets are exchangeable, and thus <code class="reqn">v</code> is adjacent to <code class="reqn">v'</code> if there
exists an edge such that <code class="reqn">v</code> belongs to one endpoint set and <code class="reqn">v'</code>
belongs to the other.  (In dyadic graphs, these sets are of cardinality 1,
but this may not be the case where hyperedges are admitted.)
</p>
<p>If an edge which would make <code class="reqn">v</code> and <code class="reqn">v'</code> adjacent is marked as
missing (via its <code>na</code> attribute), then the behavior of
<code>is.adjacent</code> depends upon <code>na.omit</code>.  If <code>na.omit==FALSE</code>
(the default), then the return value is considered to be <code>NA</code> unless
there is also <em>another</em> edge from <code class="reqn">v</code> to <code class="reqn">v'</code> which is
<em>not</em> missing (in which case the two are clearly adjacent).  If
<code>na.omit==TRUE</code>, on the other hand the missing edge is simply
disregarded in assessing adjacency (i.e., it effectively treated as not
present).  It is important not to confuse &ldquo;not present&rdquo; with
&ldquo;missing&rdquo; in this context: the former indicates that the edge in
question does not belong to the network, while the latter indicates that the
state of the corresponding edge is regarded as unknown.  By default, all
edge states are assumed &ldquo;known&rdquo; unless otherwise indicated (by
setting the edge's <code>na</code> attribute to <code>TRUE</code>; see
<code><a href="#topic+attribute.methods">attribute.methods</a></code>).
</p>
<p>Adjacency can also be determined via the extraction/replacement operators.
See the associated man page for details.
</p>


<h3>Value</h3>

<p>A logical, giving the status of the (i,j) edge
</p>


<h3>Note</h3>

<p>Prior to version 1.4, <code>na.omit</code> was set to <code>TRUE</code> by
default.
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>References</h3>

<p>Butts, C. T.  (2008).  &ldquo;network: a Package for Managing
Relational Data in R.&rdquo; <em>Journal of Statistical Software</em>, 24(2).
<a href="https://www.jstatsoft.org/v24/i02/">https://www.jstatsoft.org/v24/i02/</a>
</p>
<p>Wasserman, S. and Faust, K.  1994.  <em>Social Network Analysis: Methods
and Applications</em>.  Cambridge: Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.neighborhood">get.neighborhood</a></code>, <code><a href="#topic+network.extraction">network.extraction</a></code>,
<code><a href="#topic+attribute.methods">attribute.methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Create a very simple graph
g&lt;-network.initialize(3)
add.edge(g,1,2)
is.adjacent(g,1,2)  #TRUE
is.adjacent(g,2,1)  #FALSE
g[1,2]==1           #TRUE
g[2,1]==1           #FALSE

</code></pre>

<hr>
<h2 id='loading.attributes'>Examples of how to load vertex and edge attributes into networks</h2><span id='topic+loading.attributes'></span>

<h3>Description</h3>

<p>Additional examples of how to manipulate network attributes using the
functions documented in <code><a href="#topic+attribute.methods">attribute.methods</a></code>
</p>


<h3>Details</h3>

<p>The <code><a href="#topic+attribute.methods">attribute.methods</a></code> documentation gives details about the
use of the specific network attribute methods such as
<code>get.vertex.attribute</code> and <code>set.edge.attribute</code>.  This document
gives examples of how to load in and attach attribute data, drawing heavily
on material from the Sunbelt statnet workshops
<a href="https://statnet.org/workshops/">https://statnet.org/workshops/</a>.
</p>
<p>The examples section below give a quick overview of:
</p>

<ul>
<li><p> Loading in a matrix
</p>
</li>
<li><p> Attaching vertex attributes
</p>
</li>
<li><p> Attaching edge atributes from a matrix
</p>
</li>
<li><p> Loading in an edgelist
</p>
</li>
<li><p> Attaching edge atributes from an edgelist
</p>
</li></ul>

<p>The <code><a href="utils.html#topic+read.table">read.table</a></code> documentation provides more information about
reading data in from various tabular file formats prior to loading into a
network.  Note that the output is usually a <code><a href="base.html#topic+data.frame">data.frame</a></code> object
in which each columns is represented as a <code><a href="base.html#topic+factor">factor</a></code>.  This means
that in some cases when the output is directly loaded into a network the
variable values will appear as factor level numbers instead of text values.
The <code>stringsAsFactors=FALSE</code> flag may help with this, but some columns
may need to be converted using <code>as.numeric</code> or <code>as.character</code>
where appropriate.
</p>


<h3>References</h3>

<p>Acton, R. M., Jasny, L (2012) <em>An Introduction to Network
Analysis with R and statnet</em> Sunbelt XXXII Workshop Series, March 13, 2012.
</p>
<p>Butts, C. T.  (2008).  &ldquo;network: a Package for Managing Relational
Data in R.&rdquo; <em>Journal of Statistical Software</em>, 24(2).
<a href="https://www.jstatsoft.org/v24/i02/">https://www.jstatsoft.org/v24/i02/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+attribute.methods">attribute.methods</a></code>, <code><a href="#topic+as.network.matrix">as.network.matrix</a></code>,
<code><a href="#topic+as.sociomatrix">as.sociomatrix</a></code>, <code><a href="#topic+as.matrix.network">as.matrix.network</a></code>,
<code><a href="#topic+network.extraction">network.extraction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# read in a relational data adjacency matrix

# LOADING IN A MATRIX
## Not run: 
# can download matrix file from 
# https://statnet.csde.washington.edu/trac/raw-attachment/wiki/Resources/relationalData.csv
# and download vertex attribute file from
# https://statnet.csde.washington.edu/trac/raw-attachment/wiki/Resources/vertexAttributes.csv

# load in relation matrix from file
relations &lt;- read.csv("relationalData.csv",header=FALSE,stringsAsFactors=FALSE)

# convert to matrix format from data frame
relations &lt;- as.matrix(relations) 

# load in vertex attributes
nodeInfo &lt;- read.csv("vertexAttributes.csv",header=TRUE,stringsAsFactors=FALSE)

## End(Not run)
          
                  
print(relations) # peek at matrix 
print(nodeInfo)  # peek at attribute data

# Since our relational data has no row/column names, let's set them now
rownames(relations) &lt;- nodeInfo$name
colnames(relations) &lt;- nodeInfo$name

# create undirected network object from matrix
nrelations&lt;-network(relations,directed=FALSE)

# it read in vertex names from matrix col names ...
network.vertex.names(nrelations)

# ATTACHING VERTEX ATTRIBUTES

# ... but could also set vertex.names with 
nrelations%v%'vertex.names'&lt;- nodeInfo$name

# load in other attributes 
nrelations%v%"age" &lt;- nodeInfo$age
nrelations%v%"sex" &lt;- nodeInfo$sex
nrelations%v%"handed" &lt;- nodeInfo$handed
nrelations%v%"lastDocVisit" &lt;- nodeInfo$lastDocVisit

# Note: order of attributes in the data frame MUST match vertex ids
# otherwise the attribute will get assigned to the wrong vertex

# check that they got loaded
list.vertex.attributes(nrelations)


# what if we had an adjaceny  matrix like:
valuedMat&lt;-matrix(c(1,2,3, 2,0,9.5,1,5,0),ncol=3,byrow=TRUE)
valuedMat

# make a network from it
valuedNet&lt;-network(valuedMat,loops=TRUE,directed=TRUE)

# print it back out ...
as.matrix(valuedNet)

# wait, where did the values go!!?

# LOADING A MATRIX WITH VALUES

# to construct net from matrix with values:
valuedNet&lt;-network(valuedMat,loops=TRUE,directed=TRUE,
            ignore.eval=FALSE,names.eval='myEdgeWeight')
            
# also have to specify the name of the attribute when converting to matrix
as.matrix(valuedNet,attrname='myEdgeWeight')

# ATTACHING EDGE ATTRIBUTES FROM A MATRIX

# maybe we have edge attributes of a different sort in another matrix like:
edgeAttrs&lt;-matrix(c("B","Z","Q","W","A","E","L","P","A"),ncol=3,byrow=TRUE)
edgeAttrs

# we can still attach them
valuedNet&lt;-set.edge.value(valuedNet,'someLetters',edgeAttrs)

# and extract them
as.matrix(valuedNet,attrname='someLetters')
valuedNet%e%'someLetters'

# but notice that some of the values didn't get used 
# the ("A"s are missing) because there were no corresponding edges (loops)
# for the attribute to be attached to


# ATTACHING EDGE ATTRIBUTES FROM A LIST

# it is also possible to attach edge attributes directly from a list
edgeCols&lt;-c("red","green","blue","orange","pink","brown","gray")
valuedNet&lt;-set.edge.attribute(valuedNet,"edgeColors",edgeCols)

# but this can be risky, because we may not know the ordering of the edges,
# (especially if some have been deleted).  Does "green" go with the edge from 
# 1 to 2, or from 3 to 1?

# Usually if the edge data is only availible in list form, it is safer to construct
# the network from an edgelist in the first place

# LOADING IN AN EDGELIST

# pretend we just loaded in this data.frame from a file
elData&lt;-data.frame(
  from_id=c("1","2","3","1","3","1","2"),
  to_id=c("1", "1", "1", "2", "2", "3", "3"),
  myEdgeWeight=c(1, 2, 1, 2, 5, 3, 9.5),
  someLetters=c("B", "W", "L", "Z", "P", "Q", "E"),
  edgeCols=c("red","green","blue","orange","pink","brown","gray"),
  stringsAsFactors=FALSE
)

# peek at data
# each row corresponds to a relationship (edge) in the network
elData

# to make a network we just use the first two id columns
valuedNet2&lt;-network(elData[,1:2],loops=TRUE)

# print it out
as.matrix(valuedNet2)

# has right edges, but no values

# to include values (with names from the columns)

valuedNet2&lt;-network(elData,loops=TRUE)
list.edge.attributes(valuedNet2)
as.matrix(valuedNet2,attrname='someLetters')


</code></pre>

<hr>
<h2 id='missing.edges'>Identifying and Counting Missing Edges in a Network Object</h2><span id='topic+missing.edges'></span><span id='topic+is.na.network'></span><span id='topic+network.naedgecount'></span>

<h3>Description</h3>

<p><code>network.naedgecount</code> returns the number of edges within a
<code>network</code> object which are flagged as missing.  The <code>is.na</code>
network method returns a new network containing the missing edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network'
is.na(x)

network.naedgecount(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missing.edges_+3A_x">x</code></td>
<td>
<p>an object of class <code>network</code></p>
</td></tr>
<tr><td><code id="missing.edges_+3A_...">...</code></td>
<td>
<p>additional arguments, not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The missingness of an edge is controlled by its <code>na</code> attribute (which
is mandatory for all edges); <code>network.naedgecount</code> returns the number
of edges for which <code>na==TRUE</code>.  The <code>is.na</code> network method
produces a new network object whose edges correspond to the missing
(<code>na==TRUE</code>) edges of the original object, and is thus a covenient
method of extracting detailed missingness information on the entire network.
The network returned by <code>is.na</code> is guaranteed to have the same base
network attributes (directedness, loopness, hypergraphicity, multiplexity,
and bipartite constraint) as the original network object, but no other
information is copied; note too that edge IDs are <em>not</em> preserved by
this process (although adjacency obviously is).  Since the resulting object
is a <code><a href="#topic+network">network</a></code>, standard coercion, print/summary, and other
methods can be applied to it in the usual fashion.
</p>
<p>It should be borne in mind that &ldquo;missingness&rdquo; in the sense used here
reflects the assertion that an edge's presence or absence is unknown,
<em>not</em> that said edge is known not to be present.  Thus, the <code>na</code>
count for an empty graph is properly 0, since all edges are known to be
absent.  Edges can be flagged as missing by setting their <code>na</code>
attribute to <code>TRUE</code> using <code><a href="#topic+set.edge.attribute">set.edge.attribute</a></code>, or by
appropriate use of the network assignment operators; see below for an
example of the latter.
</p>


<h3>Value</h3>

<p><code>is.na(x)</code> returns a network object, and
<code>network.naedgecount(x)</code> returns the number of missing edges.
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>References</h3>

<p>Butts, C. T.  (2008).  &ldquo;network: a Package for Managing
Relational Data in R.&rdquo; <em>Journal of Statistical Software</em>, 24(2).
<a href="https://www.jstatsoft.org/v24/i02/">https://www.jstatsoft.org/v24/i02/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+network.edgecount">network.edgecount</a></code>,
<code><a href="#topic+get.network.attribute">get.network.attribute</a></code>, <code>is.adjacent</code>, <code><a href="Matrix.html#topic+is.na">is.na</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Create an empty network with no missing data
g&lt;-network.initialize(5)
g[,]                        #No edges present....
network.naedgecount(g)==0   #Edges not present are not "missing"!

#Now, add some missing edges
g[1,,add.edges=TRUE]&lt;-NA    #Establish that 1's ties are unknown
g[,]                        #Observe the missing elements
is.na(g)                    #Observe in network form
network.naedgecount(g)==4   #These elements do count!
network.edgecount(is.na(g)) #Same as above


</code></pre>

<hr>
<h2 id='mixingmatrix'>Mixing matrix</h2><span id='topic+mixingmatrix'></span><span id='topic+mixingmatrix.network'></span><span id='topic++5B+5B.mixingmatrix'></span><span id='topic++24.mixingmatrix'></span><span id='topic+is.directed.mixingmatrix'></span><span id='topic+is.bipartite.mixingmatrix'></span><span id='topic+print.mixingmatrix'></span>

<h3>Description</h3>

<p>Return the mixing matrix for a network, on a given attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixingmatrix(object, ...)

## S3 method for class 'network'
mixingmatrix(object, attrname, useNA = "ifany", expand.bipartite = FALSE, ...)

## S3 method for class 'mixingmatrix'
x[[...]]

## S3 method for class 'mixingmatrix'
x$name

## S3 method for class 'mixingmatrix'
is.directed(x, ...)

## S3 method for class 'mixingmatrix'
is.bipartite(x, ...)

## S3 method for class 'mixingmatrix'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixingmatrix_+3A_object">object</code></td>
<td>
<p>a network or some other data structure for which a mixing
matrix is meaningful.</p>
</td></tr>
<tr><td><code id="mixingmatrix_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="base.html#topic+table">table</a></code>.</p>
</td></tr>
<tr><td><code id="mixingmatrix_+3A_attrname">attrname</code></td>
<td>
<p>a vertex attribute name.</p>
</td></tr>
<tr><td><code id="mixingmatrix_+3A_usena">useNA</code></td>
<td>
<p>one of &quot;ifany&quot;, &quot;no&quot; or &quot;always&quot;. Argument passed to
<code><a href="base.html#topic+table">table</a></code>. By default (<code>useNA = "ifany"</code>) if there are any
<code>NA</code>s on the attribute corresponding row <em>and</em> column will be
contained in the result. See Details.</p>
</td></tr>
<tr><td><code id="mixingmatrix_+3A_expand.bipartite">expand.bipartite</code></td>
<td>
<p>logical; if <code>object</code> is bipartite, should we return
the <em>square</em> mixing matrix representing every level of <code>attrname</code> against
every other level, or a <em>rectangular</em> matrix considering only levels
present in each bipartition?</p>
</td></tr>
<tr><td><code id="mixingmatrix_+3A_x">x</code></td>
<td>
<p>mixingmatrix object</p>
</td></tr>
<tr><td><code id="mixingmatrix_+3A_name">name</code></td>
<td>
<p>name of the element to extract, one of &quot;matrix&quot; or &quot;type&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Handling of missing values on the attribute <code>attrname</code> almost
follows similar logic to <code><a href="base.html#topic+table">table</a></code>. If there are <code>NA</code>s on
the attribute and <code>useNA="ifany"</code> (default) the result will contain
both row and column for the missing values to ensure the resulting matrix
is square (essentially calling <code><a href="base.html#topic+table">table</a></code> with
<code>useNA="always"</code>). Also for that reason passing <code>exclude</code>
parameter with <code>NULL</code>, <code>NA</code> or <code>NaN</code> is ignored with a
warning as it may break the symmetry.
</p>


<h3>Value</h3>

<p>Function <code>mixingmatrix()</code> returns an object of class <code>mixingmatrix</code>
extending <code>table</code> with a cross-tabulation of edges in the <code>object</code>
according to the values of attribute <code>attrname</code> for the two incident
vertices. If <code>object</code> is a <em>directed</em> network rows correspond to the &quot;tie
sender&quot; and columns to the &quot;tie receiver&quot;. If <code>object</code> is an <em>undirected</em>
network there is no such distinction and the matrix is symmetrized. In both
cases the matrix is square and all the observed values of the attribute
<code>attrname</code> are represented in rows and columns. If <code>object</code> is a
<em>bipartite</em> network and <code>expand.bipartite</code> is <code>FALSE</code> the resulting matrix
does not have to be square as only the actually observed values of the
attribute are shown for each partition, if <code>expand.bipartite</code> is <code>TRUE</code> the
matrix will be square.
</p>
<p>Functions <code>is.directed()</code> and <code>is.bipartite()</code> return <code>TRUE</code> or
<code>FALSE</code>. The values will be identical for the input network <code>object</code>.
</p>


<h3>Note</h3>

<p>The <code>$</code> and <code>[[</code> methods are included only for backward-compatiblity
reason and will become defunct in future releases of the package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Interaction ties between Lake Pomona SAR organizations by sponsorship type
# of tie sender and receiver (data from Drabek et al. 1981)
data(emon)
mixingmatrix(emon$LakePomona, "Sponsorship")
</code></pre>

<hr>
<h2 id='network'>Network Objects</h2><span id='topic+network'></span><span id='topic+is.network'></span><span id='topic+as.network.network'></span><span id='topic+print.summary.network'></span><span id='topic++24+3C-.network'></span><span id='topic++3C-.network'></span><span id='topic+as.network'></span><span id='topic+network.copy'></span><span id='topic+as.network.data.frame'></span><span id='topic+print.network'></span><span id='topic+summary.network'></span>

<h3>Description</h3>

<p>Construct, coerce to, test for and print <code>network</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.network(x)

as.network(x, ...)

network(
  x,
  vertex.attr = NULL,
  vertex.attrnames = NULL,
  directed = TRUE,
  hyper = FALSE,
  loops = FALSE,
  multiple = FALSE,
  bipartite = FALSE,
  ...
)

network.copy(x)

## S3 method for class 'data.frame'
as.network(
  x,
  directed = TRUE,
  vertices = NULL,
  hyper = FALSE,
  loops = FALSE,
  multiple = FALSE,
  bipartite = FALSE,
  bipartite_col = "is_actor",
  ...
)

## S3 method for class 'network'
print(
  x,
  matrix.type = which.matrix.type(x),
  mixingmatrices = FALSE,
  na.omit = TRUE,
  print.adj = FALSE,
  ...
)

## S3 method for class 'network'
summary(object, na.omit = TRUE, mixingmatrices = FALSE, print.adj = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network_+3A_x">x</code></td>
<td>
<p>for <code>network</code>, a matrix giving the network structure in
adjacency, incidence, or edgelist form; otherwise, an object of class
<code>network</code>.</p>
</td></tr>
<tr><td><code id="network_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
<tr><td><code id="network_+3A_vertex.attr">vertex.attr</code></td>
<td>
<p>optionally, a list containing vertex attributes.</p>
</td></tr>
<tr><td><code id="network_+3A_vertex.attrnames">vertex.attrnames</code></td>
<td>
<p>optionally, a list containing vertex attribute
names.</p>
</td></tr>
<tr><td><code id="network_+3A_directed">directed</code></td>
<td>
<p>logical; should edges be interpreted as directed?</p>
</td></tr>
<tr><td><code id="network_+3A_hyper">hyper</code></td>
<td>
<p>logical; are hyperedges allowed?</p>
</td></tr>
<tr><td><code id="network_+3A_loops">loops</code></td>
<td>
<p>logical; should loops be allowed?</p>
</td></tr>
<tr><td><code id="network_+3A_multiple">multiple</code></td>
<td>
<p>logical; are multiplex edges allowed?</p>
</td></tr>
<tr><td><code id="network_+3A_bipartite">bipartite</code></td>
<td>
<p>count; should the network be interpreted as bipartite? If
present (i.e., non-NULL, non-FALSE) it is the count of the number of actors
in the bipartite network. In this case, the number of nodes is equal to the
number of actors plus the number of events (with all actors preceeding all
events). The edges are then interpreted as nondirected. Values of
bipartite==0 are permited, indicating a bipartite network with zero-sized
first partition.</p>
</td></tr>
<tr><td><code id="network_+3A_vertices">vertices</code></td>
<td>
<p>If <code>x</code> is a <code>data.frame</code>, <code>vertices</code> is an optional
<code>data.frame</code> containing the vertex attributes. The first column is assigned
to the <code>"vertex.names"</code> and additional columns are used to set vertex attributes
using their column names. If <code>bipartite</code> is <code>TRUE</code>, a <code>logical</code> column
named <code>"is_actor"</code> (or the name of a column specified using the
<code>bipartite_col</code> parameter) can be provided indicating which vertices
should be considered as actors. If not provided, vertices referenced in the
first column of <code>x</code> are assumed to be the network's actors. If your
network has isolates (i.e. there are vertices referenced in <code>vertices</code>
that are not referenced in <code>x</code>), the <code>"is_actor"</code> column is required.</p>
</td></tr>
<tr><td><code id="network_+3A_bipartite_col">bipartite_col</code></td>
<td>
<p><code>character(1L)</code>, default: <code>"is_actor"</code>.
The name of the <code>logical</code> column indicating which vertices should be
considered as actors in bipartite networks.</p>
</td></tr>
<tr><td><code id="network_+3A_matrix.type">matrix.type</code></td>
<td>
<p>one of <code>"adjacency"</code>, <code>"edgelist"</code>,
<code>"incidence"</code>. See <code><a href="#topic+edgeset.constructors">edgeset.constructors</a></code> for details and
optional additional arguments</p>
</td></tr>
<tr><td><code id="network_+3A_mixingmatrices">mixingmatrices</code></td>
<td>
<p>logical; print the mixing matrices for the discrete
attributes?</p>
</td></tr>
<tr><td><code id="network_+3A_na.omit">na.omit</code></td>
<td>
<p>logical; omit summarization of missing attributes in
<code>network</code>?</p>
</td></tr>
<tr><td><code id="network_+3A_print.adj">print.adj</code></td>
<td>
<p>logical; print the network adjacency structure?</p>
</td></tr>
<tr><td><code id="network_+3A_object">object</code></td>
<td>
<p>an object of class <code>network</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>network</code> constructs a <code>network</code> class object from a matrix
representation. If the <code>matrix.type</code> parameter is not specified, it
will make a guess as to the intended <code>edgeset.constructors</code> function to
call based on the format of these input matrices. If the class of <code>x</code>
is not a matrix, network construction can be dispatched to other methods.
For example, If the <code>ergm</code> package is loaded, <code>network()</code> can
function as a shorthand for <code>as.network.numeric</code> with
<code>x</code> as an integer specifying the number of nodes to be created in the
random graph.
</p>
<p>If the <code>ergm</code> package is loaded, <code>network</code> can function as a
shorthand for <code>as.network.numeric</code> if <code>x</code> is an integer specifying
the number of nodes. See the help page for
<code>as.network.numeric</code> in <code>ergm</code> package for details.
</p>
<p><code>network.copy</code> creates a new <code>network</code> object which duplicates its
supplied argument.  (Direct assignment with <code>&lt;-</code> should be used rather
than <code>network.copy</code> in most cases.)
</p>
<p><code>as.network</code> tries to coerce its argument to a network, using the
<code>as.network.matrix</code> functions if <code>x</code> is a matrix. (If the argument
is already a network object, it is returned as-is and all other arguments
are ignored.)
</p>
<p><code>is.network</code> tests whether its argument is a network (in the sense that
it has class <code>network</code>).
</p>
<p><code>print.network</code> prints a network object in one of several possible
formats.  It also prints the list of global attributes of the network.
</p>
<p><code>summary.network</code> provides similar information.
</p>


<h3>Value</h3>

<p><code>network</code>, <code>as.network</code>, and <code>print.network</code> all
return a network class object; <code>is.network</code> returns TRUE or FALSE.
</p>


<h3>Note</h3>

<p>Between versions 0.5 and 1.2, direct assignment of a network object
created a pointer to the original object, rather than a copy.  As of version
1.2, direct assignment behaves in the same manner as <code>network.copy</code>.
Direct use of the latter is thus superfluous in most situations, and is
discouraged.
</p>
<p>Many of the network package functions modify their network object arguments
in-place. For example, <code>set.network.attribute(net,"myVal",5)</code> will have
the same effect as <code>net&lt;-set.network.attribute(net,"myVal",5)</code>.
Unfortunately, the current implementation of in-place assignment breaks when
the network argument is an element of a list or a named part of another
object. So <code>set.network.attribute(myListOfNetworks[[1]],"myVal",5)</code>
will silently fail to modify its network argument, likely leading to
incorrect output.
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a> and David Hunter
<a href="mailto:dhunter@stat.psu.edu">dhunter@stat.psu.edu</a>
</p>


<h3>References</h3>

<p>Butts, C. T.  (2008).  &ldquo;network: a Package for Managing
Relational Data in R.&rdquo; <em>Journal of Statistical Software</em>, 24(2).
<a href="https://www.jstatsoft.org/v24/i02/">https://www.jstatsoft.org/v24/i02/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+network.initialize">network.initialize</a></code>, <code><a href="#topic+attribute.methods">attribute.methods</a></code>,
<code><a href="#topic+as.network.matrix">as.network.matrix</a></code>, <code><a href="#topic+as.matrix.network">as.matrix.network</a></code>,
<code><a href="#topic+deletion.methods">deletion.methods</a></code>, <code><a href="#topic+edgeset.constructors">edgeset.constructors</a></code>,
<code><a href="#topic+network.indicators">network.indicators</a></code>, <code><a href="#topic+plot.network">plot.network</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- matrix(rbinom(25,1,.4),5,5)
diag(m) &lt;- 0
g &lt;- network(m, directed=FALSE)
summary(g)

h &lt;- network.copy(g)       #Note: same as h&lt;-g
summary(h)

# networks from data frames ===========================================================
#* simple networks ====================================================================
simple_edge_df &lt;- data.frame(
  from = c("b", "c", "c", "d", "a"),
  to = c("a", "b", "a", "a", "b"),
  weight = c(1, 1, 2, 2, 3),
  stringsAsFactors = FALSE
)
simple_edge_df

as.network(simple_edge_df)

# simple networks with vertices =======================================================
simple_vertex_df &lt;- data.frame(
  name = letters[1:5],
  residence = c("urban", "rural", "suburban", "suburban", "rural"),
  stringsAsFactors = FALSE
)
simple_vertex_df

as.network(simple_edge_df, vertices = simple_vertex_df)

as.network(simple_edge_df,
  directed = FALSE, vertices = simple_vertex_df,
  multiple = TRUE
)

#* splitting multiplex data frames into multiple networks =============================
simple_edge_df$relationship &lt;- c(rep("friends", 3), rep("colleagues", 2))
simple_edge_df

lapply(split(simple_edge_df, f = simple_edge_df$relationship),
  as.network,
  vertices = simple_vertex_df
)

#* bipartite networks without isolates ================================================
bip_edge_df &lt;- data.frame(
  actor = c("a", "a", "b", "b", "c", "d", "d", "e"),
  event = c("e1", "e2", "e1", "e3", "e3", "e2", "e3", "e1"),
  actor_enjoyed_event = rep(c(TRUE, FALSE), 4),
  stringsAsFactors = FALSE
)
bip_edge_df

bip_node_df &lt;- data.frame(
  node_id = c("a", "e1", "b", "e2", "c", "e3", "d", "e"),
  node_type = c(
    "person", "event", "person", "event", "person",
    "event", "person", "person"
  ),
  color = c(
    "red", "blue", "red", "blue", "red", "blue",
    "red", "red"
  ),
  stringsAsFactors = FALSE
)
bip_node_df

as.network(bip_edge_df, directed = FALSE, bipartite = TRUE)
as.network(bip_edge_df, directed = FALSE, vertices = bip_node_df, bipartite = TRUE)

#* bipartite networks with isolates ===================================================
bip_nodes_with_isolates &lt;- rbind(
  bip_node_df,
  data.frame(
    node_id = c("f", "e4"),
    node_type = c("person", "event"),
    color = c("red", "blue"),
    stringsAsFactors = FALSE
  )
)
# indicate which vertices are actors via a column named `"is_actor"`
bip_nodes_with_isolates$is_actor &lt;- bip_nodes_with_isolates$node_type == "person"
bip_nodes_with_isolates

as.network(bip_edge_df,
  directed = FALSE, vertices = bip_nodes_with_isolates,
  bipartite = TRUE
)

#* hyper networks from data frames ====================================================
hyper_edge_df &lt;- data.frame(
  from = c("a/b", "b/c", "c/d/e", "d/e"),
  to = c("c/d", "a/b/e/d", "a/b", "d/e"),
  time = 1:4,
  stringsAsFactors = FALSE
)
tibble::as_tibble(hyper_edge_df)

# split "from" and "to" at `"/"`, coercing them to list columns
hyper_edge_df$from &lt;- strsplit(hyper_edge_df$from, split = "/")
hyper_edge_df$to &lt;- strsplit(hyper_edge_df$to, split = "/")
tibble::as_tibble(hyper_edge_df)

as.network(hyper_edge_df,
  directed = FALSE, vertices = simple_vertex_df,
  hyper = TRUE, loops = TRUE
)

# convert network objects back to data frames =========================================
simple_g &lt;- as.network(simple_edge_df, vertices = simple_vertex_df)
as.data.frame(simple_g)
as.data.frame(simple_g, unit = "vertices")

bip_g &lt;- as.network(bip_edge_df,
  directed = FALSE, vertices = bip_node_df,
  bipartite = TRUE
)
as.data.frame(bip_g)
as.data.frame(bip_g, unit = "vertices")

hyper_g &lt;- as.network(hyper_edge_df,
  directed = FALSE, vertices = simple_vertex_df,
  hyper = TRUE, loops = TRUE
)
as.data.frame(hyper_g)
as.data.frame(hyper_g, unit = "vertices")
</code></pre>

<hr>
<h2 id='network-internal'>Internal Network Package Functions</h2><span id='topic+network-internal'></span><span id='topic+is.discrete.numeric'></span><span id='topic+is.discrete.character'></span><span id='topic+is.discrete'></span><span id='topic+networkOperatorSetup'></span>

<h3>Description</h3>

<p>Internal network functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.discrete.numeric(x)

is.discrete.character(x)

is.discrete(x)

networkOperatorSetup(x, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network-internal_+3A_x">x</code></td>
<td>
<p>an object to be designated either discrete or continuous, or a
network.</p>
</td></tr>
<tr><td><code id="network-internal_+3A_y">y</code></td>
<td>
<p>a network or something coercible to one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most of these are not to be called by the user.
</p>


<h3>See Also</h3>

<p>network
</p>

<hr>
<h2 id='network-package'>Classes for Relational Data</h2><span id='topic+network-package'></span>

<h3>Description</h3>

<p>Tools to create and modify network objects.  The network class can represent
a range of relational data types, and supports arbitrary vertex/edge/graph
attributes.
</p>


<h3>Details</h3>

<p>The <code>network</code> package provides tools for creation, access, and
modification of <code>network</code> class objects.  These objects allow for the
representation of more complex structures than can be readily handled by
other means (e.g., adjacency matrices), and are substantially more efficient
in handling large, sparse networks.  While the full capabilities of the
<code>network</code> class can only be exploited by means of the various custom
interface methods (see below), many simple tasks are streamlined through the
use of operator overloading; in particular, network objects can often be
treated as if they were adjacency matrices (a representation which will be
familiar to users of the <code>sna</code> package).  <code>network</code> objects are
compatible with the <code>sna</code> package, and are required for many packages
in the <code>statnet</code> bundle.
</p>
<p>Basic information on the creation of <code>network</code> objects can be found by
typing <code>help(network)</code>.  To learn about setting, modifying, or deleting
network, vertex, or edge attributes, see <code>help(attribute.methods)</code>.
For information on custom network operators, type
<code>help(network.operators)</code>; information on overloaded operators can be
found via <code>help(network.extraction)</code>.  Additional help topics are
listed below.
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> network</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.14</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> May 7, 2016</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 2.10), utils</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> sna, statnet.common (&gt;= 3.1-0)</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Index of documentation pages:
</p>
<pre>
add.edges               Add Edges to a Network Object
add.vertices            Add Vertices to an Existing Network
as.matrix.network       Coerce a Network Object to Matrix Form
as.network.matrix       Coercion from Matrices to Network Objects
as.sociomatrix          Coerce One or More Networks to Sociomatrix Form
attribute.methods       Attribute Interface Methods for the Network
                        Class
deletion.methods        Remove Elements from a Network Object
edgeset.constructors    Edgeset Constructors for Network Objects
emon                    Interorganizational Search and Rescue Networks
                        (Drabek et al.)
flo                     Florentine Wedding Data (Padgett)
get.edges               Retrieve Edges or Edge IDs Associated with a
                        Given Vertex
get.inducedSubgraph     Retrieve Induced Subgraphs and Cuts
get.neighborhood        Obtain the Neighborhood of a Given Vertex
is.adjacent             Determine Whether Two Vertices Are Adjacent
loading.attributes      Examples of how to load vertex and edge
                        attributes into networks
missing.edges           Identifying and Counting Missing Edges in a
                        Network Object
network                 Network Objects
network.arrow           Add Arrows or Segments to a Plot
network.density         Compute the Density of a Network
network.dyadcount       Return the Number of (Possibly Directed) Dyads
                        in a Network Object
network.edgecount       Return the Number of Edges in a Network Object
network.edgelabel       Plots a label corresponding to an edge in a
                        network plot.
network.extraction      Extraction and Replacement Operators for
                        Network Objects
network.indicators      Indicator Functions for Network Properties
network.initialize      Initialize a Network Class Object
network.layout          Vertex Layout Functions for plot.network
network.loop            Add Loops to a Plot
network.operators       Network Operators
network-package         Classes for Relational Data
network.size            Return the Size of a Network
network.vertex          Add Vertices to a Plot
permute.vertexIDs       Permute (Relabel) the Vertices Within a Network
plotArgs.network        Expand and transform attributes of networks to
                        values appropriate for aguments to plot.network
plot.network.default    Two-Dimensional Visualization for Network
                        Objects
prod.network            Combine Networks by Edge Value Multiplication
read.paj                Read a Pajek Project or Network File and
                        Convert to an R 'Network' Object
sum.network             Combine Networks by Edge Value Addition
valid.eids              Get the valid edge which are valid in a network
which.matrix.type       Heuristic Determination of Matrix Types for
                        Network Storage
</pre>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>, with help from Mark S. Handcock
<a href="mailto:handcock@stat.ucla.edu">handcock@stat.ucla.edu</a>, David Hunter <a href="mailto:dhunter@stat.psu.edu">dhunter@stat.psu.edu</a>, Martina
Morris <a href="mailto:morrism@u.washington.edu">morrism@u.washington.edu</a>, Skye Bender-deMoll
<a href="mailto:skyebend@u.washington.edu">skyebend@u.washington.edu</a>, and Jeffrey Horner
<a href="mailto:jeffrey.horner@gmail.com">jeffrey.horner@gmail.com</a>.
</p>
<p>Maintainer: Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>

<hr>
<h2 id='network.arrow'>Add Arrows or Segments to a Plot</h2><span id='topic+network.arrow'></span>

<h3>Description</h3>

<p><code>network.arrow</code> draws a segment or arrow between two pairs of points;
unlike <code><a href="graphics.html#topic+arrows">arrows</a></code> or <code><a href="graphics.html#topic+segments">segments</a></code>, the new plot element
is drawn as a polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network.arrow(
  x0,
  y0,
  x1,
  y1,
  length = 0.1,
  angle = 20,
  width = 0.01,
  col = 1,
  border = 1,
  lty = 1,
  offset.head = 0,
  offset.tail = 0,
  arrowhead = TRUE,
  curve = 0,
  edge.steps = 50,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network.arrow_+3A_x0">x0</code></td>
<td>
<p>A vector of x coordinates for points of origin</p>
</td></tr>
<tr><td><code id="network.arrow_+3A_y0">y0</code></td>
<td>
<p>A vector of y coordinates for points of origin</p>
</td></tr>
<tr><td><code id="network.arrow_+3A_x1">x1</code></td>
<td>
<p>A vector of x coordinates for destination points</p>
</td></tr>
<tr><td><code id="network.arrow_+3A_y1">y1</code></td>
<td>
<p>A vector of y coordinates for destination points</p>
</td></tr>
<tr><td><code id="network.arrow_+3A_length">length</code></td>
<td>
<p>Arrowhead length, in current plotting units</p>
</td></tr>
<tr><td><code id="network.arrow_+3A_angle">angle</code></td>
<td>
<p>Arrowhead angle (in degrees)</p>
</td></tr>
<tr><td><code id="network.arrow_+3A_width">width</code></td>
<td>
<p>Width for arrow body, in current plotting units (can be a
vector)</p>
</td></tr>
<tr><td><code id="network.arrow_+3A_col">col</code></td>
<td>
<p>Arrow body color (can be a vector)</p>
</td></tr>
<tr><td><code id="network.arrow_+3A_border">border</code></td>
<td>
<p>Arrow border color (can be a vector)</p>
</td></tr>
<tr><td><code id="network.arrow_+3A_lty">lty</code></td>
<td>
<p>Arrow border line type (can be a vector)</p>
</td></tr>
<tr><td><code id="network.arrow_+3A_offset.head">offset.head</code></td>
<td>
<p>Offset for destination point (can be a vector)</p>
</td></tr>
<tr><td><code id="network.arrow_+3A_offset.tail">offset.tail</code></td>
<td>
<p>Offset for origin point (can be a vector)</p>
</td></tr>
<tr><td><code id="network.arrow_+3A_arrowhead">arrowhead</code></td>
<td>
<p>Boolean; should arrowheads be used?  (Can be a vector))</p>
</td></tr>
<tr><td><code id="network.arrow_+3A_curve">curve</code></td>
<td>
<p>Degree of edge curvature (if any), in current plotting units
(can be a vector)</p>
</td></tr>
<tr><td><code id="network.arrow_+3A_edge.steps">edge.steps</code></td>
<td>
<p>For curved edges, the number of steps to use in
approximating the curve (can be a vector)</p>
</td></tr>
<tr><td><code id="network.arrow_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="graphics.html#topic+polygon">polygon</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>network.arrow</code> provides a useful extension of <code><a href="graphics.html#topic+segments">segments</a></code>
and <code><a href="graphics.html#topic+arrows">arrows</a></code> when fine control is needed over the resulting
display.  (The results also look better.)  Note that edge curvature is
quadratic, with <code>curve</code> providing the maximum horizontal deviation of
the edge (left-handed).  Head/tail offsets are used to adjust the end/start
points of an edge, relative to the baseline coordinates; these are useful
for functions like <code><a href="#topic+plot.network">plot.network</a></code>, which need to draw edges
incident to vertices of varying radii.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Note</h3>

<p><code>network.arrow</code> is a direct adaptation of
<code><a href="sna.html#topic+gplot.arrow">gplot.arrow</a></code> from the <code>sna</code> package.
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>References</h3>

<p>Butts, C. T.  (2008).  &ldquo;network: a Package for Managing
Relational Data in R.&rdquo; <em>Journal of Statistical Software</em>, 24(2).
<a href="https://www.jstatsoft.org/v24/i02/">https://www.jstatsoft.org/v24/i02/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.network">plot.network</a></code>, <code><a href="#topic+network.loop">network.loop</a></code>,
<code><a href="graphics.html#topic+polygon">polygon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  #Plot two points
  plot(1:2,1:2)
  
  #Add an edge
  network.arrow(1,1,2,2,width=0.01,col="red",border="black")

</code></pre>

<hr>
<h2 id='network.density'>Compute the Density of a Network</h2><span id='topic+network.density'></span>

<h3>Description</h3>

<p><code>network.density</code> computes the density of its argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network.density(x, na.omit = TRUE, discount.bipartite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network.density_+3A_x">x</code></td>
<td>
<p>an object of class <code>network</code></p>
</td></tr>
<tr><td><code id="network.density_+3A_na.omit">na.omit</code></td>
<td>
<p>logical; omit missing edges from extant edges when assessing
density?</p>
</td></tr>
<tr><td><code id="network.density_+3A_discount.bipartite">discount.bipartite</code></td>
<td>
<p>logical; if <code>x</code> is bipartite, should
&ldquo;forbidden&rdquo; edges be excluded from the count of potential edges?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The density of a network is defined as the ratio of extant edges to
potential edges. We do not currently consider edge values; missing edges are
omitted from extent (but not potential) edge count when
<code>na.omit==TRUE</code>.
</p>


<h3>Value</h3>

<p>The network density.
</p>


<h3>Warning </h3>

<p><code>network.density</code> relies on network attributes (see
<a href="#topic+network.indicators">network.indicators</a>) to determine the properties of the underlying
network object.  If these are set incorrectly (e.g., multiple edges in a
non-multiplex network, network coded with directed edges but set to
&ldquo;undirected&rdquo;, etc.), surprising results may ensue.
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>References</h3>

<p>Butts, C. T.  (2008).  &ldquo;network: a Package for Managing
Relational Data in R.&rdquo; <em>Journal of Statistical Software</em>, 24(2).
<a href="https://www.jstatsoft.org/v24/i02/">https://www.jstatsoft.org/v24/i02/</a>
</p>
<p>Wasserman, S. and Faust, K.  (1994).  <em>Social Network Analysis: Methods
and Applications.</em> Cambridge: Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+network.edgecount">network.edgecount</a></code>, <code><a href="#topic+network.size">network.size</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Create an arbitrary adjacency matrix
m&lt;-matrix(rbinom(25,1,0.5),5,5)
diag(m)&lt;-0

g&lt;-network.initialize(5)    #Initialize the network
network.density(g)          #Calculate the density

</code></pre>

<hr>
<h2 id='network.dyadcount'>Return the Number of (Possibly Directed) Dyads in a Network Object</h2><span id='topic+network.dyadcount'></span><span id='topic+network.dyadcount.network'></span>

<h3>Description</h3>

<p><code>network.dyadcount</code> returns the number of possible dyads within a
<code>network</code>, removing those flagged as missing if desired.  If the
network is directed, directed dyads are counted accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network'
network.dyadcount(x, na.omit = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network.dyadcount_+3A_x">x</code></td>
<td>
<p>an object of class <code>network</code></p>
</td></tr>
<tr><td><code id="network.dyadcount_+3A_na.omit">na.omit</code></td>
<td>
<p>logical; omit edges with <code>na==TRUE</code> from the count?</p>
</td></tr>
<tr><td><code id="network.dyadcount_+3A_...">...</code></td>
<td>
<p>possible additional arguments, used by other implementations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The return value <code>network.dyadcount</code> is equal to the number of dyads,
minus the number of <code>NULL</code> edges (and missing edges, if
<code>na.omit==TRUE</code>).  If <code>x</code> is directed, the number of directed
dyads is returned. If the network allows loops, the number of possible
entries on the diagnonal is added.  Allthough the function does not give an
error on multiplex networks or hypergraphs, the results probably don't make
sense.
</p>


<h3>Value</h3>

<p>The number of dyads in the network
</p>


<h3>Author(s)</h3>

<p>Mark S. Handcock <a href="mailto:handcock@stat.washington.edu">handcock@stat.washington.edu</a>, skyebend
</p>


<h3>References</h3>

<p>Butts, C. T.  (2008).  &ldquo;network: a Package for Managing
Relational Data in R.&rdquo; <em>Journal of Statistical Software</em>, 24(2).
<a href="https://www.jstatsoft.org/v24/i02/">https://www.jstatsoft.org/v24/i02/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.network.attribute">get.network.attribute</a></code>,
<code><a href="#topic+network.edgecount">network.edgecount</a></code>, <code><a href="#topic+is.directed">is.directed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Create a directed network with three edges
m&lt;-matrix(0,3,3)
m[1,2]&lt;-1; m[2,3]&lt;-1; m[3,1]&lt;-1
g&lt;-network(m)
network.dyadcount(g)==6                 #Verify the directed dyad count
g&lt;-network(m|t(m),directed=FALSE)
network.dyadcount(g)==3                         #nC2 in undirected case

</code></pre>

<hr>
<h2 id='network.edgecount'>Return the Number of Edges in a Network Object</h2><span id='topic+network.edgecount'></span><span id='topic+network.edgecount.network'></span>

<h3>Description</h3>

<p><code>network.edgecount</code> returns the number of edges within a
<code>network</code>, removing those flagged as missing if desired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network'
network.edgecount(x, na.omit = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network.edgecount_+3A_x">x</code></td>
<td>
<p>an object of class <code>network</code></p>
</td></tr>
<tr><td><code id="network.edgecount_+3A_na.omit">na.omit</code></td>
<td>
<p>logical; omit edges with <code>na==TRUE</code> from the count?</p>
</td></tr>
<tr><td><code id="network.edgecount_+3A_...">...</code></td>
<td>
<p>additional arguments, used by extending functio</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The return value is the number of distinct edges within the network object,
including multiplex edges as appropriate.  (So if there are 3 edges from
vertex i to vertex j, each contributes to the total edge count.)
</p>
<p>The return value <code>network.edgecount</code> is in the present implementation
related to the (required) <code>mnext</code> network attribute.  <code>mnext</code> is
an internal legacy attribute that currently indicates the index number of
the next edge to be added to a network object.  (Do not modify it unless you
enjoy unfortunate surprises.)  The number of edges returned by
<code>network.edgecount</code> is equal to <code>x%n%"mnext"-1</code>, minus the number
of <code>NULL</code> edges (and missing edges, if <code>na.omit==TRUE</code>).  Note
that <code>g%n%"mnext"-1</code> cannot, by itself, be counted upon to be an
accurate count of the number of edges!  As <code>mnext</code> is not part of the
API (and is not guaranteed to remain), users and developers are urged to use
<code>network.edgecount</code> instead.
</p>


<h3>Value</h3>

<p>The number of edges
</p>


<h3>Warning </h3>

<p><code>network.edgecount</code> uses the real state of the
network object to count edges, not the state it hypothetically should have.
Thus, if you add extra edges to a non-multiplex network, directed edges to
an undirected network, etc., the actual number of edges in the object will
be returned (and not the number you would expect if you relied only on the
putative number of possible edges as reflected by the
<a href="#topic+network.indicators">network.indicators</a>).  Don't create <code>network</code> objects with
contradictory attributes unless you know what you are doing.
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>References</h3>

<p>Butts, C. T.  (2008).  &ldquo;network: a Package for Managing
Relational Data in R.&rdquo; <em>Journal of Statistical Software</em>, 24(2).
<a href="https://www.jstatsoft.org/v24/i02/">https://www.jstatsoft.org/v24/i02/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.network.attribute">get.network.attribute</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Create a network with three edges
m&lt;-matrix(0,3,3)
m[1,2]&lt;-1; m[2,3]&lt;-1; m[3,1]&lt;-1
g&lt;-network(m)
network.edgecount(g)==3   #Verify the edgecount

</code></pre>

<hr>
<h2 id='network.edgelabel'>Plots a label corresponding to an edge in a network plot.</h2><span id='topic+network.edgelabel'></span>

<h3>Description</h3>

<p>Draws a text labels on (or adjacent to) the line segments connecting
vertices on a network plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network.edgelabel(
  px0,
  py0,
  px1,
  py1,
  label,
  directed,
  loops = FALSE,
  cex,
  curve = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network.edgelabel_+3A_px0">px0</code></td>
<td>
<p>vector of x coordinates of tail vertex of the edge</p>
</td></tr>
<tr><td><code id="network.edgelabel_+3A_py0">py0</code></td>
<td>
<p>vector of y coordinates of tail vertex of the edge</p>
</td></tr>
<tr><td><code id="network.edgelabel_+3A_px1">px1</code></td>
<td>
<p>vector of x coordinates of head vertex of the edge</p>
</td></tr>
<tr><td><code id="network.edgelabel_+3A_py1">py1</code></td>
<td>
<p>vector of y coordinate of head vertex of the edge</p>
</td></tr>
<tr><td><code id="network.edgelabel_+3A_label">label</code></td>
<td>
<p>vector strings giving labels to be drawn for edge edge</p>
</td></tr>
<tr><td><code id="network.edgelabel_+3A_directed">directed</code></td>
<td>
<p>logical: is the underlying network directed? If FALSE,
labels will be drawn in the middle of the line segment, otherwise in the
first 3rd so that the labels for edges pointing in the opposite direction
will not overlap.</p>
</td></tr>
<tr><td><code id="network.edgelabel_+3A_loops">loops</code></td>
<td>
<p>logical: if true, assuming the labels to be drawn belong to
loop-type edges and render appropriately</p>
</td></tr>
<tr><td><code id="network.edgelabel_+3A_cex">cex</code></td>
<td>
<p>numeric vector giving the text expansion factor for each label</p>
</td></tr>
<tr><td><code id="network.edgelabel_+3A_curve">curve</code></td>
<td>
<p>numeric vector controling the extent of edge curvature (0 =
straight line edges)</p>
</td></tr>
<tr><td><code id="network.edgelabel_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code><a href="graphics.html#topic+text">text</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Called internally by <code><a href="#topic+plot.network">plot.network</a></code> when <code>edge.label</code>
parameter is used. For directed, non-curved edges, the labels are shifted
towards the tail of the edge. Labels for curved edges are not shifted
because opposite-direction edges curve the opposite way.  Makes a crude
attempt to shift labels to either side of line, and to draw the edge labels
for self-loops near the vertex. No attempt is made to avoid overlap between
vertex and edge labels.
</p>


<h3>Value</h3>

<p>no value is returned but text will be rendered on the active plot
</p>


<h3>Author(s)</h3>

<p>skyebend
</p>

<hr>
<h2 id='network.extraction'>Extraction and Replacement Operators for Network Objects</h2><span id='topic+network.extraction'></span><span id='topic++5B.network'></span><span id='topic++5B+3C-.network'></span><span id='topic++25e+25'></span><span id='topic++25e+25+3C-'></span><span id='topic++eattr+'></span><span id='topic++eattr+<-'></span><span id='topic++25n+25'></span><span id='topic++25n+25+3C-'></span><span id='topic++25nattr+25'></span><span id='topic++25nattr+25+3C-'></span><span id='topic++25v+25'></span><span id='topic++25v+25+3C-'></span><span id='topic++25vattr+25'></span><span id='topic++25vattr+25+3C-'></span>

<h3>Description</h3>

<p>Various operators which allow extraction or replacement of various
components of a <code>network</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network'
x[i, j, na.omit = FALSE]

## S3 replacement method for class 'network'
x[i, j, names.eval = NULL, add.edges = FALSE] &lt;- value

x %e% attrname

x %e% attrname &lt;- value

x %eattr% attrname

x %eattr% attrname &lt;- value

x %n% attrname

x %n% attrname &lt;- value

x %nattr% attrname

x %nattr% attrname &lt;- value

x %v% attrname

x %v% attrname &lt;- value

x %vattr% attrname

x %vattr% attrname &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network.extraction_+3A_x">x</code></td>
<td>
<p>an object of class <code>network</code>.</p>
</td></tr>
<tr><td><code id="network.extraction_+3A_i">i</code>, <code id="network.extraction_+3A_j">j</code></td>
<td>
<p>indices of the vertices with respect to which adjacency is to be
tested.  Empty values indicate that all vertices should be employed (see
below).</p>
</td></tr>
<tr><td><code id="network.extraction_+3A_na.omit">na.omit</code></td>
<td>
<p>logical; should missing edges be omitted (treated as
no-adjacency), or should <code>NA</code>s be returned?  (Default: return <code>NA</code>
on missing.)</p>
</td></tr>
<tr><td><code id="network.extraction_+3A_names.eval">names.eval</code></td>
<td>
<p>optionally, the name of an edge attribute to use for
assigning edge values.</p>
</td></tr>
<tr><td><code id="network.extraction_+3A_add.edges">add.edges</code></td>
<td>
<p>logical; should new edges be added to <code>x</code> where edges
are absent and the appropriate element of <code>value</code> is non-zero?</p>
</td></tr>
<tr><td><code id="network.extraction_+3A_value">value</code></td>
<td>
<p>the value (or set thereof) to be assigned to the selected
element of <code>x</code>.</p>
</td></tr>
<tr><td><code id="network.extraction_+3A_attrname">attrname</code></td>
<td>
<p>the name of a network or vertex attribute (as appropriate).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Indexing for edge extraction operates in a manner analogous to <code>matrix</code>
objects.  Thus, <code>x[,]</code> selects all vertex pairs, <code>x[1,-5]</code> selects
the pairing of vertex 1 with all vertices except for 5, etc.  Following
this, it is acceptable for <code>i</code> and/or <code>j</code> to be logical vectors
indicating which vertices are to be included.  During assignment, an attempt
is made to match the elements of <code>value</code> to the extracted pairs in an
intelligent way; in particular, elements of <code>value</code> will be replicated
if too few are supplied (allowing expressions like <code>x[1,]&lt;-1</code>).  Where
<code>names.eval==NULL</code>, zero and non-zero values are taken to indicate the
presence of absence of edges.  <code>x[2,4]&lt;-6</code> thus adds a single (2,4)
edge to <code>x</code>, and <code>x[2,4]&lt;-0</code> removes such an edge (if present).
If <code>x</code> is multiplex, assigning 0 to a vertex pair will eliminate
<em>all</em> edges on that pair.  Pairs are taken to be directed where
<code>is.directed(x)==TRUE</code>, and undirected where
<code>is.directed(x)==FALSE</code>.
</p>
<p>If an edge attribute is specified using <code>names.eval</code>, then the provided
values will be assigned to that attribute.  When assigning values, only
extant edges are employed (unless <code>add.edges==TRUE</code>); in the latter
case, any non-zero assignment results in the addition of an edge where
currently absent.  If the attribute specified is not present on a given
edge, it is added.  Otherwise, any existing value is overwritten.  The
<code>%e%</code> operator can also be used to extract/assign edge values; in those
roles, it is respectively equivalent to <code>get.edge.value(x,attrname)</code>
and <code>set.edge.value(x,attrname=attrname,value=value)</code> (if <code>value</code>
is a matrix) and <code>set.edge.attribute(x,attrname=attrname,value=value)</code>
(if <code>value</code> is anything else). That is, if <code>value</code> is a matrix,
the assignment operator treats it as an adjacency matrix; and if not, it
treats it as a vector (recycled as needed) in the internal ordering of edges
(i.e., edge IDs), skipping over deleted edges. In no case will attributes be
assigned to nonexisted edges.
</p>
<p>The <code>%n%</code> and <code>%v%</code> operators serve as front-ends to the network
and vertex extraction/assignment functions (respectively).  In the
extraction case, <code>x %n% attrname</code> is equivalent to
<code>get.network.attribute(x,attrname)</code>, with <code>x %v% attrname</code>
corresponding to <code>get.vertex.attribute(x,attrname)</code>.  In assignment,
the respective equivalences are to
<code>set.network.attribute(x,attrname,value)</code> and
<code>set.vertex.attribute(x,attrname,value)</code>.  Note that the <code>%%</code>
assignment forms are generally slower than the named versions of the
functions beause they will trigger an additional internal copy of the
network object.
</p>
<p>The <code>%eattr%</code>, <code>%nattr%</code>, and <code>%vattr%</code> operators are
equivalent to <code>%e%</code>, <code>%n%</code>, and <code>%v%</code> (respectively).  The
short forms are more succinct, but may produce less readable code.
</p>


<h3>Value</h3>

<p>The extracted data, or none.
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>References</h3>

<p>Butts, C. T.  (2008).  &ldquo;network: a Package for Managing
Relational Data in R.&rdquo; <em>Journal of Statistical Software</em>, 24(2).
<a href="https://www.jstatsoft.org/v24/i02/">https://www.jstatsoft.org/v24/i02/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.adjacent">is.adjacent</a></code>, <code><a href="#topic+as.sociomatrix">as.sociomatrix</a></code>,
<code><a href="#topic+attribute.methods">attribute.methods</a></code>, <code><a href="#topic+add.edges">add.edges</a></code>,
<code><a href="#topic+network.operators">network.operators</a></code>, and <code><a href="#topic+get.inducedSubgraph">get.inducedSubgraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  #Create a random graph (inefficiently)
  g&lt;-network.initialize(10)
  g[,]&lt;-matrix(rbinom(100,1,0.1),10,10)
  plot(g)
  
  #Demonstrate edge addition/deletion
  g[,]&lt;-0
  g[1,]&lt;-1
  g[2:3,6:7]&lt;-1
  g[,]
  
  #Set edge values
  g[,,names.eval="boo"]&lt;-5
  as.sociomatrix(g,"boo")
  #Assign edge values from a vector
  g %e% "hoo" &lt;- "wah"
  g %e% "hoo"
  g %e% "om" &lt;- c("wow","whee")
  g %e% "om"
  #Assign edge values as a sociomatrix
  g %e% "age" &lt;- matrix(1:100, 10, 10)
  g %e% "age"
  as.sociomatrix(g,"age")

  #Set/retrieve network and vertex attributes
  g %n% "blah" &lt;- "Pork!"                 #The other white meat?
  g %n% "blah" == "Pork!"                 #TRUE!
  g %v% "foo" &lt;- letters[10:1]            #Letter the vertices
  g %v% "foo" == letters[10:1]            #All TRUE

</code></pre>

<hr>
<h2 id='network.indicators'>Indicator Functions for Network Properties</h2><span id='topic+network.indicators'></span><span id='topic+has.loops'></span><span id='topic+is.bipartite'></span><span id='topic+is.bipartite.network'></span><span id='topic+is.directed'></span><span id='topic+is.directed.network'></span><span id='topic+is.hyper'></span><span id='topic+is.multiplex'></span>

<h3>Description</h3>

<p>Various indicators for properties of <code>network</code> class objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has.loops(x)

is.bipartite(x, ...)

## S3 method for class 'network'
is.bipartite(x, ...)

is.directed(x, ...)

## S3 method for class 'network'
is.directed(x, ...)

is.hyper(x)

is.multiplex(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network.indicators_+3A_x">x</code></td>
<td>
<p>an object of class <code>network</code></p>
</td></tr>
<tr><td><code id="network.indicators_+3A_...">...</code></td>
<td>
<p>other arguments passed to/from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These methods are the standard means of assessing the state of a
<code>network</code> object; other methods can (and should) use these routines in
governing their own behavior.  As such, improper setting of the associated
attributes may result in unpleasantly creative results.  (See the
<code>edge.check</code> argument to <code><a href="#topic+add.edges">add.edges</a></code> for an example of code
which makes use of these network properties.)
</p>
<p>The functions themselves behave has follows:
</p>
<p><code>has.loops</code> returns <code>TRUE</code> iff <code>x</code> is allowed to contain
loops (or loop-like edges, in the hypergraphic case).
</p>
<p><code>is.bipartite</code> returns <code>TRUE</code> iff the <code>x</code> has been explicitly
bipartite-coded. Values of <code>bipartite=NULL</code>, and <code>bipartite=FALSE</code>
will evaluate to <code>FALSE</code>, numeric values of <code>bipartite&gt;=0</code> will
evaluate to <code>TRUE</code>. (The value <code>bipartite==0</code> indicates that it is
a bipartite network with a zero-sized first partition.) Note that
<code>is.bipartite</code> refers only to the storage properties of <code>x</code> and
how it should be treated by some algorithms; <code>is.bipartite(x)==FALSE</code>
it does <em>not</em> mean that <code>x</code> cannot admit a bipartition!
</p>
<p><code>is.directed</code> returns <code>TRUE</code> iff the edges of <code>x</code> are to be
interpreted as directed.
</p>
<p><code>is.hyper</code> returns <code>TRUE</code> iff <code>x</code> is allowed to contain
hypergraphic edges.
</p>
<p><code>is.multiplex</code> returns <code>TRUE</code> iff <code>x</code> is allowed to contain
multiplex edges.
</p>


<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code>
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>References</h3>

<p>Butts, C. T.  (2008).  &ldquo;network: a Package for Managing
Relational Data in R.&rdquo; <em>Journal of Statistical Software</em>, 24(2).
<a href="https://www.jstatsoft.org/v24/i02/">https://www.jstatsoft.org/v24/i02/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+network">network</a></code>, <code><a href="#topic+get.network.attribute">get.network.attribute</a></code>,
<code>set.network.attribute</code>, <code><a href="#topic+add.edges">add.edges</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g&lt;-network.initialize(5)    #Initialize the network
is.bipartite(g)
is.directed(g)
is.hyper(g)
is.multiplex(g)
has.loops(g)

</code></pre>

<hr>
<h2 id='network.initialize'>Initialize a Network Class Object</h2><span id='topic+network.initialize'></span>

<h3>Description</h3>

<p>Create and initialize a <code>network</code> object with <code>n</code> vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network.initialize(
  n,
  directed = TRUE,
  hyper = FALSE,
  loops = FALSE,
  multiple = FALSE,
  bipartite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network.initialize_+3A_n">n</code></td>
<td>
<p>the number of vertices to initialize</p>
</td></tr>
<tr><td><code id="network.initialize_+3A_directed">directed</code></td>
<td>
<p>logical; should edges be interpreted as directed?</p>
</td></tr>
<tr><td><code id="network.initialize_+3A_hyper">hyper</code></td>
<td>
<p>logical; are hyperedges allowed?</p>
</td></tr>
<tr><td><code id="network.initialize_+3A_loops">loops</code></td>
<td>
<p>logical; should loops be allowed?</p>
</td></tr>
<tr><td><code id="network.initialize_+3A_multiple">multiple</code></td>
<td>
<p>logical; are multiplex edges allowed?</p>
</td></tr>
<tr><td><code id="network.initialize_+3A_bipartite">bipartite</code></td>
<td>
<p>count; should the network be interpreted as bipartite? If
present (i.e., non-NULL) it is the count of the number of actors in the
first mode of the bipartite network. In this case, the overall number of
vertices is equal to the number of 'actors' (first mode) plus the number of
&lsquo;events&rsquo; (second mode), with the vertex.ids of all actors preceeding all
events. The edges are then interpreted as nondirected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generally, <code>network.initialize</code> is called by other constructor
functions as part of the process of creating a network.
</p>


<h3>Value</h3>

<p>An object of class <code>network</code>
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>References</h3>

<p>Butts, C. T.  (2008).  &ldquo;network: a Package for Managing
Relational Data in R.&rdquo; <em>Journal of Statistical Software</em>, 24(2).
<a href="https://www.jstatsoft.org/v24/i02/">https://www.jstatsoft.org/v24/i02/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+network">network</a></code>, <code><a href="#topic+as.network.matrix">as.network.matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g&lt;-network.initialize(5)  #Create an empty graph on 5 vertices

</code></pre>

<hr>
<h2 id='network.layout'>Vertex Layout Functions for plot.network</h2><span id='topic+network.layout'></span><span id='topic+network.layout.circle'></span><span id='topic+network.layout.fruchtermanreingold'></span><span id='topic+network.layout.kamadakawai'></span>

<h3>Description</h3>

<p>Various functions which generate vertex layouts for the
<code><a href="#topic+plot.network">plot.network</a></code> visualization routine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network.layout.circle(nw, layout.par)

network.layout.fruchtermanreingold(nw, layout.par)

network.layout.kamadakawai(nw, layout.par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network.layout_+3A_nw">nw</code></td>
<td>
<p>a network object, as passed by <code><a href="#topic+plot.network">plot.network</a></code>.</p>
</td></tr>
<tr><td><code id="network.layout_+3A_layout.par">layout.par</code></td>
<td>
<p>a list of parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vertex layouts for network visualization pose a difficult problem &ndash; there
is no single, &ldquo;good&rdquo; layout algorithm, and many different approaches may
be valuable under different circumstances.  With this in mind,
<code><a href="#topic+plot.network">plot.network</a></code> allows for the use of arbitrary vertex layout
algorithms via the <code>network.layout.*</code> family of routines.  When called,
<code><a href="#topic+plot.network">plot.network</a></code> searches for a <code>network.layout</code> function
whose fourth name matches its <code>mode</code> argument (see
<code><a href="#topic+plot.network">plot.network</a></code> help for more information); this function is then
used to generate the layout for the resulting plot.  In addition to the
routines documented here, users may add their own layout functions as
needed.  The requirements for a <code>network.layout</code> function are as
follows:
</p>

<ol>
<li><p> the first argument, <code>nw</code>, must be a network object;
</p>
</li>
<li><p> the second argument, <code>layout.par</code>, must be a list of parameters
(or <code>NULL</code>, if no parameters are specified); and
</p>
</li>
<li><p> the return value must be a real matrix of dimension <code>c(2,network.size(nw))</code>,
whose rows contain the vertex coordinates.
</p>
</li></ol>

<p>Other than this, anything goes.  (In particular, note that <code>layout.par</code>
could be used to pass additional matrices or other information, if needed.
Alternately, it is possible to make layout methods that respond to
covariates on the network object, which are maintained intact by
plot.network.)
</p>
<p>The <code>network.layout</code> functions currently supplied by default are as
follows (with <code>n==network.size(nw)</code>):
</p>

<dl>
<dt>circle</dt><dd><p> This function places vertices uniformly in a circle; it takes no arguments.</p>
</dd>
<dt>fruchtermanreingold</dt><dd><p> This function generates a layout using a variant of Fruchterman and Reingold's force-directed placement algorithm.  It takes the following arguments:
</p>

<dl>
<dt>layout.par$niter</dt><dd><p> This argument controls the number of iterations to be employed.  Larger values take longer, but will provide a more refined layout.  (Defaults to 500.) </p>
</dd>
<dt>layout.par$max.delta</dt><dd><p> Sets the maximum change in position for any given iteration.  (Defaults to <code>n</code>.)</p>
</dd>
<dt>layout.par$area</dt><dd><p> Sets the &quot;area&quot; parameter for the F-R algorithm. (Defaults to <code>n^2</code>.)</p>
</dd>
<dt>layout.par$cool.exp</dt><dd><p> Sets the cooling exponent for the annealer. (Defaults to 3.)</p>
</dd>
<dt>layout.par$repulse.rad</dt><dd><p> Determines the radius at which vertex-vertex repulsion cancels out attraction of adjacent vertices. (Defaults to <code>area*log(n)</code>.)</p>
</dd>
<dt>layout.par$ncell</dt><dd><p> To speed calculations on large graphs, the plot region is divided at each iteration into <code>ncell</code> by <code>ncell</code> &ldquo;cells&rdquo;, which are used to define neighborhoods for force calculation.  Moderate numbers of cells result in fastest performance; too few cells (down to 1, which produces &ldquo;pure&rdquo; F-R results) can yield odd layouts, while too many will result in long layout times.  (Defaults to <code>n^0.4</code>.)</p>
</dd>
<dt>layout.par$cell.jitter</dt><dd><p> Jitter factor (in units of cell width) used in assigning vertices to cells. Small values may generate &ldquo;grid-like&rdquo; anomalies for graphs with many isolates.  (Defaults to <code>0.5</code>.)</p>
</dd>
<dt>layout.par$cell.pointpointrad</dt><dd><p> Squared &ldquo;radius&rdquo; (in units of cells) such that exact point interaction calculations are used for all vertices belonging to any two cells less than or equal to this distance apart.  Higher values approximate the true F-R solution, but increase computational cost.  (Defaults to <code>0</code>.)</p>
</dd>
<dt>layout.par$cell.pointcellrad</dt><dd><p> Squared &ldquo;radius&rdquo; (in units of cells) such that approximate point/cell interaction calculations are used for all vertices belonging to any two cells less than or equal to this distance apart (and not within the point/point radius). Higher values provide somewhat better approximations to the true F-R solution at slightly increased computational cost.  (Defaults to <code>18</code>.)</p>
</dd>
<dt>layout.par$cell.cellcellrad</dt><dd><p> Squared &ldquo;radius&rdquo; (in units of cells) such that approximate cell/cell interaction calculations are used for all vertices belonging to any two cells less than or equal to this distance apart (and not within the point/point or point/cell radii). Higher values provide somewhat better approximations to the true F-R solution at slightly increased computational cost.  Note that cells beyond this radius (if any) do not interact, save through edge attraction. (Defaults to <code>ncell^2</code>.)</p>
</dd>
<dt>layout.par$seed.coord</dt><dd><p> A two-column matrix of initial vertex coordinates.  (Defaults to a random circular layout.) </p>
</dd>
</dl>

</dd>
<dt>kamadakawai</dt><dd><p> This function generates a vertex layout using a version of the Kamada-Kawai force-directed placement algorithm.  It takes the following arguments:
</p>

<dl>
<dt>layout.par$niter</dt><dd><p> This argument controls the number of iterations to be employed.  (Defaults to 1000.) </p>
</dd>
<dt>layout.par$sigma</dt><dd><p> Sets the base standard deviation of position change proposals.  (Defaults to <code>n/4</code>.)</p>
</dd>
<dt>layout.par$initemp</dt><dd><p> Sets the initial &quot;temperature&quot; for the annealing algorithm. (Defaults to 10.)</p>
</dd>
<dt>layout.par$cool.exp</dt><dd><p> Sets the cooling exponent for the annealer. (Defaults to 0.99.)</p>
</dd>
<dt>layout.par$kkconst</dt><dd><p> Sets the Kamada-Kawai vertex attraction constant.  (Defaults to <code>n)^2</code>.)</p>
</dd>
<dt>layout.par$elen</dt><dd><p> Provides the matrix of interpoint distances to be approximated.  (Defaults to the geodesic distances of <code>nw</code> after symmetrizing, capped at <code>sqrt(n)</code>.)</p>
</dd>
<dt>layout.par$seed.coord</dt><dd><p> A two-column matrix of initial vertex coordinates.  (Defaults to a gaussian layout.) </p>
</dd>
</dl>

</dd>
</dl>



<h3>Value</h3>

<p>A matrix whose rows contain the x,y coordinates of the vertices of
<code>d</code>.
</p>


<h3>Note</h3>

<p>The <code>network.layout</code> routines shown here are adapted directly
from the <code><a href="sna.html#topic+gplot.layout">gplot.layout</a></code> routines of the <code>sna</code> package.
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>References</h3>

<p>Butts, C. T.  (2008).  &ldquo;network: a Package for Managing
Relational Data in R.&rdquo; <em>Journal of Statistical Software</em>, 24(2).
<a href="https://www.jstatsoft.org/v24/i02/">https://www.jstatsoft.org/v24/i02/</a>
</p>
<p>Fruchterman, T.M.J. and Reingold, E.M.  (1991).  &ldquo;Graph Drawing by
Force-directed Placement.&rdquo; <em>Software - Practice and Experience,</em>
21(11):1129-1164.
</p>
<p>Kamada, T. and Kawai, S.  (1989). &ldquo;An Algorithm for Drawing General
Undirected Graphs.&rdquo; <em>Information Processing Letters,</em> 31(1):7-15.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.network">plot.network</a></code>
</p>

<hr>
<h2 id='network.loop'>Add Loops to a Plot</h2><span id='topic+network.loop'></span>

<h3>Description</h3>

<p><code>network.loop</code> draws a &quot;loop&quot; at a specified location; this is used to
designate self-ties in <code><a href="#topic+plot.network">plot.network</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network.loop(
  x0,
  y0,
  length = 0.1,
  angle = 10,
  width = 0.01,
  col = 1,
  border = 1,
  lty = 1,
  offset = 0,
  edge.steps = 10,
  radius = 1,
  arrowhead = TRUE,
  xctr = 0,
  yctr = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network.loop_+3A_x0">x0</code></td>
<td>
<p>a vector of x coordinates for points of origin.</p>
</td></tr>
<tr><td><code id="network.loop_+3A_y0">y0</code></td>
<td>
<p>a vector of y coordinates for points of origin.</p>
</td></tr>
<tr><td><code id="network.loop_+3A_length">length</code></td>
<td>
<p>arrowhead length, in current plotting units.</p>
</td></tr>
<tr><td><code id="network.loop_+3A_angle">angle</code></td>
<td>
<p>arrowhead angle (in degrees).</p>
</td></tr>
<tr><td><code id="network.loop_+3A_width">width</code></td>
<td>
<p>width for loop body, in current plotting units (can be a
vector).</p>
</td></tr>
<tr><td><code id="network.loop_+3A_col">col</code></td>
<td>
<p>loop body color (can be a vector).</p>
</td></tr>
<tr><td><code id="network.loop_+3A_border">border</code></td>
<td>
<p>loop border color (can be a vector).</p>
</td></tr>
<tr><td><code id="network.loop_+3A_lty">lty</code></td>
<td>
<p>loop border line type (can be a vector).</p>
</td></tr>
<tr><td><code id="network.loop_+3A_offset">offset</code></td>
<td>
<p>offset for origin point (can be a vector).</p>
</td></tr>
<tr><td><code id="network.loop_+3A_edge.steps">edge.steps</code></td>
<td>
<p>number of steps to use in approximating curves.</p>
</td></tr>
<tr><td><code id="network.loop_+3A_radius">radius</code></td>
<td>
<p>loop radius (can be a vector).</p>
</td></tr>
<tr><td><code id="network.loop_+3A_arrowhead">arrowhead</code></td>
<td>
<p>boolean; should arrowheads be used?  (Can be a vector.)</p>
</td></tr>
<tr><td><code id="network.loop_+3A_xctr">xctr</code></td>
<td>
<p>x coordinate for the central location away from which loops
should be oriented.</p>
</td></tr>
<tr><td><code id="network.loop_+3A_yctr">yctr</code></td>
<td>
<p>y coordinate for the central location away from which loops
should be oriented.</p>
</td></tr>
<tr><td><code id="network.loop_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="graphics.html#topic+polygon">polygon</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>network.loop</code> is the companion to <code><a href="#topic+network.arrow">network.arrow</a></code>; like
the latter, plot elements produced by <code>network.loop</code> are drawn using
<code><a href="graphics.html#topic+polygon">polygon</a></code>, and as such are scaled based on the current plotting
device.  By default, loops are drawn so as to encompass a circular region of
radius <code>radius</code>, whose center is <code>offset</code> units from <code>x0,y0</code>
and at maximum distance from <code>xctr,yctr</code>.  This is useful for functions
like <code><a href="#topic+plot.network">plot.network</a></code>, which need to draw loops incident to
vertices of varying radii.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Note</h3>

<p><code>network.loop</code> is a direct adaptation of
<code><a href="sna.html#topic+gplot.loop">gplot.loop</a></code>, from the <code>sna</code> package.
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+network.arrow">network.arrow</a></code>, <code><a href="#topic+plot.network">plot.network</a></code>,
<code><a href="graphics.html#topic+polygon">polygon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Plot a few polygons with loops
plot(0,0,type="n",xlim=c(-2,2),ylim=c(-2,2),asp=1)
network.loop(c(0,0),c(1,-1),col=c(3,2),width=0.05,length=0.4,
  offset=sqrt(2)/4,angle=20,radius=0.5,edge.steps=50,arrowhead=TRUE)
polygon(c(0.25,-0.25,-0.25,0.25,NA,0.25,-0.25,-0.25,0.25), 
    c(1.25,1.25,0.75,0.75,NA,-1.25,-1.25,-0.75,-0.75),col=c(2,3))


</code></pre>

<hr>
<h2 id='network.operators'>Network Operators</h2><span id='topic+network.operators'></span><span id='topic++2B.network'></span><span id='topic++25c+25'></span><span id='topic+-.network'></span><span id='topic++2A.network'></span><span id='topic++21.network'></span><span id='topic++7C.network'></span><span id='topic++26.network'></span><span id='topic++25c+25.network'></span>

<h3>Description</h3>

<p>These operators allow for algebraic manipulation of relational structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network'
e1 + e2

## S3 method for class 'network'
e1 - e2

## S3 method for class 'network'
e1 * e2

## S3 method for class 'network'
!e1

## S3 method for class 'network'
e1 | e2

## S3 method for class 'network'
e1 &amp; e2

## S3 method for class 'network'
e1 %c% e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network.operators_+3A_e1">e1</code></td>
<td>
<p>an object of class <code>network</code>.</p>
</td></tr>
<tr><td><code id="network.operators_+3A_e2">e2</code></td>
<td>
<p>another <code>network</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In general, the binary network operators function by producing a new network
object whose edge structure is based on that of the input networks.  The
properties of the new structure depend upon the inputs as follows: </p>

<ul>
<li><p> The size of the new network is equal to the size of the input networks
(for all operators save <code>%c%</code>), which must themselves be of equal size.
Likewise, the <code>bipartite</code> attributes of the inputs must match, and this
is preserved in the output.  </p>
</li>
<li><p> If either input network allows loops,
multiplex edges, or hyperedges, the output acquires this property.  (If both
input networks do not allow these features, then the features are disallowed
in the output network.)  </p>
</li>
<li><p> If either input network is directed, the
output is directed; if exactly one input network is directed, the undirected
input is treated as if it were a directed network in which all edges are
reciprocated.  </p>
</li>
<li><p> Supplemental attributes (including vertex names, but
not edgwise missingness) are not transferred to the output.  </p>
</li></ul>
<p> The unary
operator acts per the above, but with a single input.  Thus, the output
network has the same properties as the input, with the exception of
supplemental attributes.
</p>
<p>The behavior of the composition operator, <code>%c%</code>, is somewhat more
complex than the others.  In particular, it will return a bipartite network
whenever either input network is bipartite <em>or</em> the vertex names of the
two input networks do not match (or are missing).  If both inputs are
non-bipartite and have identical vertex names, the return value will have
the same structure (but with loops).  This behavior corresponds to the
interpretation of the composition operator as counting walks on labeled sets
of vertices.
</p>
<p>Hypergraphs are not yet supported by these routines, but ultimately will be
(as suggested by the above).
</p>
<p>The specific operations carried out by these operators are generally
self-explanatory in the non-multiplex case, but semantics in the latter
circumstance bear elaboration.  The following summarizes the behavior of
each operator:
</p>

<dl>
<dt><code>+</code></dt><dd><p>An <code class="reqn">(i,j)</code> edge is created in
the return graph for every <code class="reqn">(i,j)</code> edge in each of the input graphs.</p>
</dd>
<dt><code>-</code></dt><dd><p>An <code class="reqn">(i,j)</code> edge is created in the return graph for
every <code class="reqn">(i,j)</code> edge in the first input that is not matched by an
<code class="reqn">(i,j)</code> edge in the second input; if the second input has more
<code class="reqn">(i,j)</code> edges than the first, no <code class="reqn">(i,j)</code> edges are created in the
return graph.</p>
</dd>
<dt><code>*</code></dt><dd><p>An <code class="reqn">(i,j)</code> edge is created for every
pairing of <code class="reqn">(i,j)</code> edges in the respective input graphs.</p>
</dd>
<dt><code>%c%</code></dt><dd><p>An <code class="reqn">(i,j)</code> edge is created in the return graph for
every edge pair <code class="reqn">(i,k),(k,j)</code> with the first edge in the first input and
the second edge in the second input.</p>
</dd>
<dt><code>!</code></dt><dd><p>An <code class="reqn">(i,j)</code> edge
is created in the return graph for every <code class="reqn">(i,j)</code> in the input not having
an edge.</p>
</dd>
<dt><code>|</code></dt><dd><p>An <code class="reqn">(i,j)</code> edge is created in the return
graph if either input contains an <code class="reqn">(i,j)</code> edge.</p>
</dd>
<dt><code>&amp;</code></dt><dd><p>An
<code class="reqn">(i,j)</code> edge is created in the return graph if both inputs contain an
<code class="reqn">(i,j)</code> edge.</p>
</dd>
</dl>

<p>Semantics for missing-edge cases follow from the above,
under the interpretation that edges with <code>na==TRUE</code> are viewed as
having an unknown state.  Thus, for instance, <code>x*y</code> with <code>x</code>
having 2 <code class="reqn">(i,j)</code> non-missing and 1 missing edge and <code>y</code> having 3
respective non-missing and 2 missing edges will yield an output network with
6 non-missing and 9 missing <code class="reqn">(i,j)</code> edges.
</p>


<h3>Value</h3>

<p>The resulting network.
</p>


<h3>Note</h3>

<p>Currently, there is a naming conflict between the composition operator
and the <code>%c%</code> operator in the <code><a href="sna.html#topic+sna">sna</a></code> package.  This
will be resolved in future releases; for the time being, one can determine
which version of <code>%c%</code> is in use by varying which package is loaded
first.
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>References</h3>

<p>Butts, C. T.  (2008).  &ldquo;network: a Package for Managing
Relational Data in R.&rdquo; <em>Journal of Statistical Software</em>, 24(2).
<a href="https://www.jstatsoft.org/v24/i02/">https://www.jstatsoft.org/v24/i02/</a>
</p>
<p>Wasserman, S. and Faust, K.  (1994).  <em>Social Network Analysis: Methods
and Applications.</em> Cambridge: University of Cambridge Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+network.extraction">network.extraction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Create an in-star
m&lt;-matrix(0,6,6)
m[2:6,1]&lt;-1
g&lt;-network(m)
plot(g)

#Compose g with its transpose
gcgt&lt;-g %c% (network(t(m)))
plot(gcgt)
gcgt

#Show the complement of g
!g

#Perform various arithmatic and logical operations
(g+gcgt)[,] == (g|gcgt)[,]             #All TRUE
(g-gcgt)[,] == (g&amp;(!(gcgt)))[,]
(g*gcgt)[,] == (g&amp;gcgt)[,]
</code></pre>

<hr>
<h2 id='network.size'>Return the Size of a Network</h2><span id='topic+network.size'></span>

<h3>Description</h3>

<p><code>network.size</code> returns the order of its argument (i.e., number of
vertices).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network.size(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network.size_+3A_x">x</code></td>
<td>
<p>an object of class <code>network</code></p>
</td></tr>
<tr><td><code id="network.size_+3A_...">...</code></td>
<td>
<p>additional arguments, not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>network.size(x)</code> is equivalent to <code>get.network.attribute(x,"n")</code>;
the function exists as a convenience.
</p>


<h3>Value</h3>

<p>The network size
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>References</h3>

<p>Butts, C. T.  (2008).  &ldquo;network: a Package for Managing
Relational Data in R.&rdquo; <em>Journal of Statistical Software</em>, 24(2).
<a href="https://www.jstatsoft.org/v24/i02/">https://www.jstatsoft.org/v24/i02/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.network.attribute">get.network.attribute</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Initialize a network
g&lt;-network.initialize(7)
network.size(g)

</code></pre>

<hr>
<h2 id='network.vertex'>Add Vertices to a Plot</h2><span id='topic+network.vertex'></span>

<h3>Description</h3>

<p><code>network.vertex</code> adds one or more vertices (drawn using
<code><a href="graphics.html#topic+polygon">polygon</a></code>) to a plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network.vertex(
  x,
  y,
  radius = 1,
  sides = 4,
  border = 1,
  col = 2,
  lty = NULL,
  rot = 0,
  lwd = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network.vertex_+3A_x">x</code></td>
<td>
<p>a vector of x coordinates.</p>
</td></tr>
<tr><td><code id="network.vertex_+3A_y">y</code></td>
<td>
<p>a vector of y coordinates.</p>
</td></tr>
<tr><td><code id="network.vertex_+3A_radius">radius</code></td>
<td>
<p>a vector of vertex radii.</p>
</td></tr>
<tr><td><code id="network.vertex_+3A_sides">sides</code></td>
<td>
<p>a vector containing the number of sides to draw for each
vertex.</p>
</td></tr>
<tr><td><code id="network.vertex_+3A_border">border</code></td>
<td>
<p>a vector of vertex border colors.</p>
</td></tr>
<tr><td><code id="network.vertex_+3A_col">col</code></td>
<td>
<p>a vector of vertex interior colors.</p>
</td></tr>
<tr><td><code id="network.vertex_+3A_lty">lty</code></td>
<td>
<p>a vector of vertex border line types.</p>
</td></tr>
<tr><td><code id="network.vertex_+3A_rot">rot</code></td>
<td>
<p>a vector of vertex rotation angles (in degrees).</p>
</td></tr>
<tr><td><code id="network.vertex_+3A_lwd">lwd</code></td>
<td>
<p>a vector of vertex border line widths.</p>
</td></tr>
<tr><td><code id="network.vertex_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="graphics.html#topic+polygon">polygon</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>network.vertex</code> draws regular polygons of specified radius and number
of sides, at the given coordinates.  This is useful for routines such as
<code><a href="#topic+plot.network">plot.network</a></code>, which use such shapes to depict vertices.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Note</h3>

<p><code>network.vertex</code> is a direct adaptation of
<code><a href="sna.html#topic+gplot.vertex">gplot.vertex</a></code> from the <code>sna</code> package.
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>References</h3>

<p>Butts, C. T.  (2008).  &ldquo;network: a Package for Managing
Relational Data in R.&rdquo; <em>Journal of Statistical Software</em>, 24(2).
<a href="https://www.jstatsoft.org/v24/i02/">https://www.jstatsoft.org/v24/i02/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.network">plot.network</a></code>, <code><a href="graphics.html#topic+polygon">polygon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#Open a plot window, and place some vertices
plot(0,0,type="n",xlim=c(-1.5,1.5),ylim=c(-1.5,1.5),asp=1)
network.vertex(cos((1:10)/10*2*pi),sin((1:10)/10*2*pi),col=1:10,
    sides=3:12,radius=0.1)


</code></pre>

<hr>
<h2 id='permute.vertexIDs'>Permute (Relabel) the Vertices Within a Network</h2><span id='topic+permute.vertexIDs'></span>

<h3>Description</h3>

<p><code>permute.vertexIDs</code> permutes the vertices within a given network in the
specified fashion.  Since this occurs internally (at the level of vertex
IDs), it is rarely of interest to end-users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permute.vertexIDs(x, vids)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permute.vertexIDs_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+network">network</a></code>.</p>
</td></tr>
<tr><td><code id="permute.vertexIDs_+3A_vids">vids</code></td>
<td>
<p>a vector of vertex IDs, in the order to which they are to be
permuted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>permute.vertexIDs</code> alters the internal ordering of vertices within a
<code><a href="#topic+network">network</a></code>.  For most practical applications, this should not be
necessary &ndash; de facto permutation can be accomplished by altering the
appropriate vertex attributes.  <code>permute.vertexIDs</code> is needed for
certain other routines (such as <code><a href="#topic+delete.vertices">delete.vertices</a></code>), where it is
used in various arcane and ineffable ways.
</p>


<h3>Value</h3>

<p>Invisibly, a pointer to the permuted network.
<code>permute.vertexIDs</code> modifies its argument in place.
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>References</h3>

<p>Butts, C. T.  (2008).  &ldquo;network: a Package for Managing
Relational Data in R.&rdquo; <em>Journal of Statistical Software</em>, 24(2).
<a href="https://www.jstatsoft.org/v24/i02/">https://www.jstatsoft.org/v24/i02/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+network">network</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(flo)                     #Load the Florentine Families data
nflo&lt;-network(flo)                      #Create a network object
n&lt;-network.size(nflo)                #Get the number of vertices
permute.vertexIDs(nflo,n:1)                #Reverse the vertices
all(flo[n:1,n:1]==as.sociomatrix(nflo))          #Should be TRUE

</code></pre>

<hr>
<h2 id='plot.network.default'>Two-Dimensional Visualization for Network Objects</h2><span id='topic+plot.network.default'></span><span id='topic+plot.network'></span>

<h3>Description</h3>

<p><code>plot.network</code> produces a simple two-dimensional plot of network
<code>x</code>, using optional attribute <code>attrname</code> to set edge values.  A
variety of options are available to control vertex placement, display
details, color, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network'
plot(x, ...)

## Default S3 method:
plot.network(x, attrname = NULL, 
   label = network.vertex.names(x), coord = NULL, jitter = TRUE,
   thresh = 0, usearrows = TRUE, mode = "fruchtermanreingold", 
   displayisolates = TRUE, interactive = FALSE, xlab = NULL, 
   ylab = NULL, xlim = NULL, ylim = NULL, pad = 0.2, label.pad = 0.5,
   displaylabels = !missing(label), boxed.labels = FALSE, label.pos = 0,
   label.bg = "white", vertex.sides = 50, vertex.rot = 0, vertex.lwd=1,
   arrowhead.cex = 1, label.cex = 1, loop.cex = 1, vertex.cex = 1,
   edge.col = 1, label.col = 1, vertex.col = 2, label.border = 1,
   vertex.border = 1, edge.lty = 1, label.lty = NULL, vertex.lty = 1,
   edge.lwd = 0, edge.label = NULL, edge.label.cex = 1,
   edge.label.col = 1, label.lwd = par("lwd"), edge.len = 0.5, 
   edge.curve = 0.1, edge.steps = 50, loop.steps = 20, 
   object.scale = 0.01, uselen = FALSE, usecurve = FALSE,
   suppress.axes = TRUE, vertices.last = TRUE, new = TRUE, 
   layout.par = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.network.default_+3A_x">x</code></td>
<td>
<p>an object of class <code>network</code>.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_attrname">attrname</code></td>
<td>
<p>an optional edge attribute, to be used to set edge values.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_label">label</code></td>
<td>
<p>a vector of vertex labels, if desired; defaults to the vertex
labels returned by <code><a href="#topic+network.vertex.names">network.vertex.names</a></code>. If <code>label</code> has
one element and it matches with a vertex attribute name, the value of the
attribute will be used. Note that labels may be set but hidden by the
<code>displaylabels</code> argument.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_coord">coord</code></td>
<td>
<p>user-specified vertex coordinates, in an network.size(x)x2
matrix.  Where this is specified, it will override the <code>mode</code> setting.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_jitter">jitter</code></td>
<td>
<p>boolean; should the output be jittered?</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_thresh">thresh</code></td>
<td>
<p>real number indicating the lower threshold for tie values.
Only ties of value &gt;<code>thresh</code> are displayed.  By default,
<code>thresh</code>=0.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_usearrows">usearrows</code></td>
<td>
<p>boolean; should arrows (rather than line segments) be used
to indicate edges?</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_mode">mode</code></td>
<td>
<p>the vertex placement algorithm; this must correspond to a
<code><a href="#topic+network.layout">network.layout</a></code> function.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_displayisolates">displayisolates</code></td>
<td>
<p>boolean; should isolates be displayed?</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_interactive">interactive</code></td>
<td>
<p>boolean; should interactive adjustment of vertex
placement be attempted?</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_xlab">xlab</code></td>
<td>
<p>x axis label.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_ylab">ylab</code></td>
<td>
<p>y axis label.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_xlim">xlim</code></td>
<td>
<p>the x limits (min, max) of the plot.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_ylim">ylim</code></td>
<td>
<p>the y limits of the plot.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_pad">pad</code></td>
<td>
<p>amount to pad the plotting range; useful if labels are being
clipped.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_label.pad">label.pad</code></td>
<td>
<p>amount to pad label boxes (if <code>boxed.labels==TRUE</code>),
in character size units.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_displaylabels">displaylabels</code></td>
<td>
<p>boolean; should vertex labels be displayed?</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_boxed.labels">boxed.labels</code></td>
<td>
<p>boolean; place vertex labels within boxes?</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_label.pos">label.pos</code></td>
<td>
<p>position at which labels should be placed, relative to
vertices.  <code>0</code> results in labels which are placed away from the center
of the plotting region; <code>1</code>, <code>2</code>, <code>3</code>, and <code>4</code> result in
labels being placed below, to the left of, above, and to the right of
vertices (respectively); and <code>label.pos&gt;=5</code> results in labels which are
plotted with no offset (i.e., at the vertex positions).</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_label.bg">label.bg</code></td>
<td>
<p>background color for label boxes (if
<code>boxed.labels==TRUE</code>); may be a vector, if boxes are to be of different
colors.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_vertex.sides">vertex.sides</code></td>
<td>
<p>number of polygon sides for vertices; may be given as a
vector or a vertex attribute name, if vertices are to be of different types.
As of v1.12, radius of polygons are scaled so that all shapes have equal
area</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_vertex.rot">vertex.rot</code></td>
<td>
<p>angle of rotation for vertices (in degrees); may be given
as a vector or a vertex attribute name, if vertices are to be rotated
differently.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_vertex.lwd">vertex.lwd</code></td>
<td>
<p>line width of vertex borders; may be given as a vector or
a vertex attribute name, if vertex borders are to have different line
widths.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_arrowhead.cex">arrowhead.cex</code></td>
<td>
<p>expansion factor for edge arrowheads.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_label.cex">label.cex</code></td>
<td>
<p>character expansion factor for label text.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_loop.cex">loop.cex</code></td>
<td>
<p>expansion factor for loops; may be given as a vector or a
vertex attribute name, if loops are to be of different sizes.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_vertex.cex">vertex.cex</code></td>
<td>
<p>expansion factor for vertices; may be given as a vector or
a vertex attribute name, if vertices are to be of different sizes.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_edge.col">edge.col</code></td>
<td>
<p>color for edges; may be given as a vector, adjacency matrix,
or edge attribute name, if edges are to be of different colors.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_label.col">label.col</code></td>
<td>
<p>color for vertex labels; may be given as a vector or a
vertex attribute name, if labels are to be of different colors.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_vertex.col">vertex.col</code></td>
<td>
<p>color for vertices; may be given as a vector or a vertex
attribute name, if vertices are to be of different colors.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_label.border">label.border</code></td>
<td>
<p>label border colors (if <code>boxed.labels==TRUE</code>); may
be given as a vector, if label boxes are to have different colors.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_vertex.border">vertex.border</code></td>
<td>
<p>border color for vertices; may be given as a vector or
a vertex attribute name, if vertex borders are to be of different colors.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_edge.lty">edge.lty</code></td>
<td>
<p>line type for edge borders; may be given as a vector,
adjacency matrix, or edge attribute name, if edge borders are to have
different line types.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_label.lty">label.lty</code></td>
<td>
<p>line type for label boxes (if <code>boxed.labels==TRUE</code>);
may be given as a vector, if label boxes are to have different line types.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_vertex.lty">vertex.lty</code></td>
<td>
<p>line type for vertex borders; may be given as a vector or
a vertex attribute name, if vertex borders are to have different line types.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_edge.lwd">edge.lwd</code></td>
<td>
<p>line width scale for edges; if set greater than 0, edge
widths are scaled by <code>edge.lwd*dat</code>.  May be given as a vector,
adjacency matrix, or edge attribute name, if edges are to have different
line widths.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_edge.label">edge.label</code></td>
<td>
<p>if non-<code>NULL</code>, labels for edges will be drawn. May be
given as a vector, adjacency matrix, or edge attribute name, if edges are to
have different labels. A single value of <code>TRUE</code> will use edge ids as
labels. NOTE: currently doesn't work for curved edges.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_edge.label.cex">edge.label.cex</code></td>
<td>
<p>character expansion factor for edge label text; may be
given as a vector or a edge attribute name, if edge labels are to have
different sizes.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_edge.label.col">edge.label.col</code></td>
<td>
<p>color for edge labels; may be given as a vector or a
edge attribute name, if labels are to be of different colors.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_label.lwd">label.lwd</code></td>
<td>
<p>line width for label boxes (if <code>boxed.labels==TRUE</code>);
may be given as a vector, if label boxes are to have different line widths.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_edge.len">edge.len</code></td>
<td>
<p>if <code>uselen==TRUE</code>, curved edge lengths are scaled by
<code>edge.len</code>.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_edge.curve">edge.curve</code></td>
<td>
<p>if <code>usecurve==TRUE</code>, the extent of edge curvature is
controlled by <code>edge.curv</code>.  May be given as a fixed value, vector,
adjacency matrix, or edge attribute name, if edges are to have different
levels of curvature.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_edge.steps">edge.steps</code></td>
<td>
<p>for curved edges (excluding loops), the number of line
segments to use for the curve approximation.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_loop.steps">loop.steps</code></td>
<td>
<p>for loops, the number of line segments to use for the
curve approximation.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_object.scale">object.scale</code></td>
<td>
<p>base length for plotting objects, as a fraction of the
linear scale of the plotting region. Defaults to 0.01.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_uselen">uselen</code></td>
<td>
<p>boolean; should we use <code>edge.len</code> to rescale edge
lengths?</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_usecurve">usecurve</code></td>
<td>
<p>boolean; should we use <code>edge.curve</code>?</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_suppress.axes">suppress.axes</code></td>
<td>
<p>boolean; suppress plotting of axes?</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_vertices.last">vertices.last</code></td>
<td>
<p>boolean; plot vertices after plotting edges?</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_new">new</code></td>
<td>
<p>boolean; create a new plot?  If <code>new==FALSE</code>, vertices and
edges will be added to the existing plot.</p>
</td></tr>
<tr><td><code id="plot.network.default_+3A_layout.par">layout.par</code></td>
<td>
<p>parameters to the <code><a href="#topic+network.layout">network.layout</a></code> function
specified in <code>mode</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot.network</code> is the standard visualization tool for the
<code>network</code> class.  By means of clever selection of display parameters, a
fair amount of display flexibility can be obtained.  Vertex layout &ndash; if not
specified directly using <code>coord</code> &ndash; is determined via one of the
various available algorithms.  These should be specified via the <code>mode</code>
argument; see <code><a href="#topic+network.layout">network.layout</a></code> for a full list.  User-supplied
layout functions are also possible &ndash; see the aforementioned man page for
details.
</p>
<p>Note that where <code>is.hyper(x)==TRUE</code>, the network is converted to
bipartite adjacency form prior to computing coordinates.  If
<code>interactive==TRUE</code>, then the user may modify the initial network
layout by selecting an individual vertex and then clicking on the location
to which this vertex is to be moved; this process may be repeated until the
layout is satisfactory.
</p>


<h3>Value</h3>

<p>A two-column matrix containing the vertex positions as x,y
coordinates
</p>


<h3>Note</h3>

<p><code>plot.network</code> is adapted (with minor modifications) from the
<code><a href="sna.html#topic+gplot">gplot</a></code> function of the <code>sna</code> library (authors: Carter
T. Butts and Alex Montgomery); eventually, these two packages will be
integrated.
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>References</h3>

<p>Butts, C. T.  (2008).  &ldquo;network: a Package for Managing
Relational Data in R.&rdquo; <em>Journal of Statistical Software</em>, 24(2).
<a href="https://www.jstatsoft.org/v24/i02/">https://www.jstatsoft.org/v24/i02/</a>
</p>
<p>Wasserman, S., and Faust, K.  (1994).  <em>Social Network Analysis:
Methods and Applications.</em> Cambridge: Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+network">network</a></code>, <code><a href="#topic+network.arrow">network.arrow</a></code>,
<code><a href="#topic+network.loop">network.loop</a></code>, <code><a href="#topic+network.vertex">network.vertex</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Construct a sparse graph
m&lt;-matrix(rbinom(100,1,1.5/9),10)
diag(m)&lt;-0
g&lt;-network(m)

#Plot the graph
plot(g)

#Load Padgett's marriage data
data(flo)
nflo&lt;-network(flo)
#Display the network, indicating degree and flagging the Medicis
plot(nflo, vertex.cex=apply(flo,2,sum)+1, usearrows=FALSE,
    vertex.sides=3+apply(flo,2,sum),
    vertex.col=2+(network.vertex.names(nflo)=="Medici"))
</code></pre>

<hr>
<h2 id='plotArgs.network'>Expand and transform attributes of networks to values appropriate for
aguments to plot.network</h2><span id='topic+plotArgs.network'></span>

<h3>Description</h3>

<p>This is primairly an internal function called by <code>plot.network</code> or by
external packages such as <code>ndtv</code> that want to prepare
<code>plot.network</code> graphic arguments in a standardized way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotArgs.network(x, argName, argValue, d = NULL, edgetouse = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotArgs.network_+3A_x">x</code></td>
<td>
<p>a <code>network</code> object which is going to be plotted</p>
</td></tr>
<tr><td><code id="plotArgs.network_+3A_argname">argName</code></td>
<td>
<p>character, the name of <code>plot.network</code> graphic parameter</p>
</td></tr>
<tr><td><code id="plotArgs.network_+3A_argvalue">argValue</code></td>
<td>
<p>value for the graphic paramter named in <code>argName</code> which
to be transformed/prepared.  For many attributes, if this is a single
character vector it will be assumed to be the name of a vertex or edge
attribute to be extracted and transformed</p>
</td></tr>
<tr><td><code id="plotArgs.network_+3A_d">d</code></td>
<td>
<p>is an edgelist matrix of edge values optionally used by some edge
attribute functions</p>
</td></tr>
<tr><td><code id="plotArgs.network_+3A_edgetouse">edgetouse</code></td>
<td>
<p>numeric vector giving set of edge ids to be used (in case
some edges are not being shown) required by some attributes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a network object, the name of graphic parameter argument to
<code>plot.network</code> and value, it will if necessary transform the value, or
extract it from the network, according to the description in
<code><a href="#topic+plot.network">plot.network</a></code>. For some attributes, if the value is the name of
a vertex or edge attribute, the appropriate values will be extracted from
the network before transformation.
</p>


<h3>Value</h3>

<p>returns a vector with length corresponding to the number of vertices
or edges (depending on the paramter type) giving the appropriately prepared
values for the parameter type.  If the values or specified attribute can not
be processed correctly, and Error may occur.
</p>


<h3>Author(s)</h3>

<p>skyebend@uw.edu
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+plot.network">plot.network</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  net&lt;-network.initialize(3)
  set.vertex.attribute(net,'color',c('red','green','blue'))
  set.vertex.attribute(net,'charm',1:3)
  # replicate a single colorname value
  plotArgs.network(net,'vertex.col','purple')
  # map the 'color' attribute to color
  plotArgs.network(net,'vertex.col','color')
  # similarly for a numeric attribute ...
  plotArgs.network(net,'vertex.cex',12)
  plotArgs.network(net,'vertex.cex','charm')

</code></pre>

<hr>
<h2 id='prod.network'>Combine Networks by Edge Value Multiplication</h2><span id='topic+prod.network'></span>

<h3>Description</h3>

<p>Given a series of networks, <code>prod.network</code> attempts to form a new
network by multiplication of edges.  If a non-null <code>attrname</code> is given,
the corresponding edge attribute is used to determine and store edge values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network'
prod(..., attrname = NULL, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prod.network_+3A_...">...</code></td>
<td>
<p>one or more <code>network</code> objects.</p>
</td></tr>
<tr><td><code id="prod.network_+3A_attrname">attrname</code></td>
<td>
<p>the name of an edge attribute to use when assessing edge
values, if desired.</p>
</td></tr>
<tr><td><code id="prod.network_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; should edges with missing data be ignored?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The network product method attempts to combine its arguments by edgewise
multiplication (<em>not</em> composition) of their respective adjacency
matrices; thus, this method is only applicable for networks whose adjacency
coercion is well-behaved.  Multiplication is effectively boolean unless
<code>attrname</code> is specified, in which case this is used to assess edge
values &ndash; net values of 0 will result in removal of the underlying edge.
</p>
<p>Other network attributes in the return value are carried over from the first
element in the list, so some persistence is possible (unlike the
multiplication operator).  Note that it is sometimes possible to
&ldquo;multiply&rdquo; networks and raw adjacency matrices using this routine (if
all dimensions are correct), but more exotic combinations may result in
regrettably exciting behavior.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+network">network</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>References</h3>

<p>Butts, C. T.  (2008).  &ldquo;network: a Package for Managing
Relational Data in R.&rdquo; <em>Journal of Statistical Software</em>, 24(2).
<a href="https://www.jstatsoft.org/v24/i02/">https://www.jstatsoft.org/v24/i02/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+network.operators">network.operators</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Create some networks
g&lt;-network.initialize(5)
h&lt;-network.initialize(5)
i&lt;-network.initialize(5)
g[1:3,,names.eval="marsupial",add.edges=TRUE]&lt;-1
h[1:2,,names.eval="marsupial",add.edges=TRUE]&lt;-2
i[1,,names.eval="marsupial",add.edges=TRUE]&lt;-3

#Combine by addition
pouch&lt;-prod(g,h,i,attrname="marsupial")
pouch[,]                                   #Edge values in the pouch?
as.sociomatrix(pouch,attrname="marsupial")     #Recover the marsupial

</code></pre>

<hr>
<h2 id='read.paj'>Read a Pajek Project or Network File and Convert to an R 'Network' Object</h2><span id='topic+read.paj'></span><span id='topic+read.paj.simplify'></span><span id='topic+switchArcDirection'></span><span id='topic+readAndVectorizeLine'></span>

<h3>Description</h3>

<p>Return a (list of) <code><a href="#topic+network">network</a></code> object(s) after reading a
corresponding .net or .paj file.  The code accepts ragged array edgelists,
but cannot currently handle 2-mode, multirelational (e.g. KEDS), or networks
with entries for both edges and arcs (e.g. GD-a99m).  See <code>network</code>,
<code>statnet</code>, or <code>sna</code> for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.paj(
  file,
  verbose = FALSE,
  debug = FALSE,
  edge.name = NULL,
  simplify = FALSE,
  time.format = c("pajekTiming", "networkDynamic")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.paj_+3A_file">file</code></td>
<td>
<p>the name of the file whence the data are to be read. If it does
not contain an absolute path, the file name is relative to the current
working directory (as returned by <code><a href="base.html#topic+getwd">getwd</a></code>).  <code>file</code> can
also be a complete URL.</p>
</td></tr>
<tr><td><code id="read.paj_+3A_verbose">verbose</code></td>
<td>
<p>logical: Should longer descriptions of the reading and
coercion process be printed out?</p>
</td></tr>
<tr><td><code id="read.paj_+3A_debug">debug</code></td>
<td>
<p>logical: Should very detailed descriptions of the reading and
coercion process be printed out? This is typically used to debug the reading
of files that are corrupted on coercion.</p>
</td></tr>
<tr><td><code id="read.paj_+3A_edge.name">edge.name</code></td>
<td>
<p>optional name for the edge variable read from the file. The
default is to use the value in the project file if found.</p>
</td></tr>
<tr><td><code id="read.paj_+3A_simplify">simplify</code></td>
<td>
<p>Should the returned network be simplified as much as
possible and saved? The values specifies the name of the file which the data
are to be stored. If it does not contain an absolute path, the file name is
relative to the current working directory (see <code><a href="base.html#topic+getwd">getwd</a></code>). If
<code>specify</code> is TRUE the file name is the name <code>file</code>.</p>
</td></tr>
<tr><td><code id="read.paj_+3A_time.format">time.format</code></td>
<td>
<p>if the network has timing information attached to
edges/vertices, how should it be processed?  <code>'pajekTiming'</code> will
attach the timing information unchanged in an attribute named
<code>pajek.timing</code>. <code>'networkDynamic'</code> will translate it to a spell
matrix format, attach it as an <code>'activity'</code> attribute and add the class
<code>'networkDynamic'</code> &ndash; formating it for use by the <code>networkDynamic</code>
package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>*Vertices</code> block includes the optional graphic attributes
(coordinates, shape, size, etc.) they will be read attached to the network
as vertex attributes but values will not be interperted (i.e. Pajek's color
names will not be translated to R color names).  Vertex attributes included
in a <code>*Vector</code> block will be attached as vertex attributes.
</p>
<p>Edges or Arc weights in the <code>*Arcs</code> or <code>*Edges</code> block are include
in the network as an attribute with the same name as the network. If no
weight is included, a default weight of 1 is used. Optional graphic
attributes or labels will be attached as edge attributes.
</p>
<p>If the file contains an empty <code>Arcs</code> block, an undirected network will
be returned. Otherwise the network will be directed, with two edges (one in
each direction) added for every row in the <code>*Edges</code> block.
</p>
<p>If the <code>*Vertices</code>, <code>*Arcs</code> or <code>*Edges</code> blocks having timing
information included in the rows (indicated by <code>...</code> tokens), it will be
attached to the vertices with behavior determined by the <code>time.format</code>
option.  If the <code>'networkDynamic'</code> format is used, times will be
translated to <code>networkDynamic</code>'s spell model with the assumtion that
the original Pajek representation was indicating discrete time chunks.  For
example <code>"[5-10]"</code> will become the spell <code>[5,11]</code>, <code>"[2-*]"</code>
will become <code>[2,Inf]</code> and <code>"[7]"</code> will become <code>[7,8]</code>. See
documentation for <code>networkDynamic</code>'s <code>?activity.attribute</code> for
details.
</p>
<p>The <code>*Arcslist</code>, <code>*Edgelist</code> and <code>*Events</code> blocks are not yet
supported.
</p>
<p>As there is no known single complete specification for the file format,
parsing behavior has been infered from references and examples below.
</p>


<h3>Value</h3>

<p>The structure of the object returned by <code>read.paj</code> depends on
the contents of the file it parses. </p>
 <ul>
<li><p> if input file contains
information about a single 'network' object (i.e .net input file) a single
network object is returned with attribute data set appropriately if
possible.  or a list of networks (for .paj input).  </p>
</li>
<li><p> if input file
contains multiple sets of relations for a single network, a list of network
objects ('network.series') is returned, along with a formula object?.  </p>
</li>
<li>
<p>if input .paj file contains additional information (like partition
information), or multiple <code>*Network</code> definitions a two element list is
returned.  The first element is a list of all the network objects created,
and the second is a list of partitions, etc.  (how are these matched up) </p>
</li></ul>



<h3>Author(s)</h3>

<p>Dave Schruth <a href="mailto:dschruth@u.washington.edu">dschruth@u.washington.edu</a>, Mark S. Handcock
<a href="mailto:handcock@stat.washington.edu">handcock@stat.washington.edu</a> (with additional input from Alex
Montgomery <a href="mailto:ahm@reed.edu">ahm@reed.edu</a>), Skye Bender-deMoll
<a href="mailto:skyebend@uw.edu">skyebend@uw.edu</a>
</p>


<h3>References</h3>

<p>Batagelj, Vladimir and Mrvar, Andrej (2011) Pajek Reference
Manual version 2.05
<a href="http://vlado.fmf.uni-lj.si/pub/networks/pajek/doc/pajekman.pdf">http://vlado.fmf.uni-lj.si/pub/networks/pajek/doc/pajekman.pdf</a> Section
5.3 pp 73-79
</p>
<p>Batageli, Vladimir (2008) &quot;Network Analysis Description of Networks&quot;
<a href="http://vlado.fmf.uni-lj.si/pub/networks/doc/ECPR/08/ECPR01.pdf">http://vlado.fmf.uni-lj.si/pub/networks/doc/ECPR/08/ECPR01.pdf</a>
</p>
<p>Pajek Datasets <a href="http://vlado.fmf.uni-lj.si/pub/networks/data/esna/">http://vlado.fmf.uni-lj.si/pub/networks/data/esna/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+network">network</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
require(network)

par(mfrow=c(2,2))

test.net.1 &lt;- read.paj("http://vlado.fmf.uni-lj.si/pub/networks/data/GD/gd98/A98.net")
plot(test.net.1,main=test.net.1%n%'title')

test.net.2 &lt;- read.paj("http://vlado.fmf.uni-lj.si/pub/networks/data/mix/USAir97.net")
# plot using coordinates from the file in the file
plot(test.net.2,main=test.net.2%n%'title',
               coord=cbind(test.net.2%v%'x',
               test.net.2%v%'y'),
               jitter=FALSE)
               
# read .paj project file
# notice output has $networks and $partitions
read.paj('http://vlado.fmf.uni-lj.si/vlado/podstat/AO/net/Tina.paj')

## End(Not run)

</code></pre>

<hr>
<h2 id='sum.network'>Combine Networks by Edge Value Addition</h2><span id='topic+sum.network'></span>

<h3>Description</h3>

<p>Given a series of networks, <code>sum.network</code> attempts to form a new
network by accumulation of edges.  If a non-null <code>attrname</code> is given,
the corresponding edge attribute is used to determine and store edge values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network'
sum(..., attrname = NULL, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum.network_+3A_...">...</code></td>
<td>
<p>one or more <code>network</code> objects.</p>
</td></tr>
<tr><td><code id="sum.network_+3A_attrname">attrname</code></td>
<td>
<p>the name of an edge attribute to use when assessing edge
values, if desired.</p>
</td></tr>
<tr><td><code id="sum.network_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; should edges with missing data be ignored?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The network summation method attempts to combine its arguments by addition
of their respective adjacency matrices; thus, this method is only applicable
for networks whose adjacency coercion is well-behaved.  Addition is
effectively boolean unless <code>attrname</code> is specified, in which case this
is used to assess edge values &ndash; net values of 0 will result in removal of
the underlying edge.
</p>
<p>Other network attributes in the return value are carried over from the first
element in the list, so some persistence is possible (unlike the addition
operator).  Note that it is sometimes possible to &ldquo;add&rdquo; networks and
raw adjacency matrices using this routine (if all dimensions are correct),
but more exotic combinations may result in regrettably exciting behavior.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+network">network</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>References</h3>

<p>Butts, C. T.  (2008).  &ldquo;network: a Package for Managing
Relational Data in R.&rdquo; <em>Journal of Statistical Software</em>, 24(2).
<a href="https://www.jstatsoft.org/v24/i02/">https://www.jstatsoft.org/v24/i02/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+network.operators">network.operators</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Create some networks
g&lt;-network.initialize(5)
h&lt;-network.initialize(5)
i&lt;-network.initialize(5)
g[1,,names.eval="marsupial",add.edges=TRUE]&lt;-1
h[1:2,,names.eval="marsupial",add.edges=TRUE]&lt;-2
i[1:3,,names.eval="marsupial",add.edges=TRUE]&lt;-3

#Combine by addition
pouch&lt;-sum(g,h,i,attrname="marsupial")
pouch[,]                                   #Edge values in the pouch?
as.sociomatrix(pouch,attrname="marsupial")     #Recover the marsupial

</code></pre>

<hr>
<h2 id='valid.eids'>Get the ids of all the edges that are valid in a network</h2><span id='topic+valid.eids'></span><span id='topic+valid.eids.network'></span>

<h3>Description</h3>

<p>Returns a vector of valid edge ids (corresponding to non-NULL edges) for a
network that may have some deleted edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valid.eids(x, ...)

## S3 method for class 'network'
valid.eids(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="valid.eids_+3A_x">x</code></td>
<td>
<p>a network object, possibly with some deleted edges.</p>
</td></tr>
<tr><td><code id="valid.eids_+3A_...">...</code></td>
<td>
<p>additional arguments to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The edge ids used in the network package are positional indices on the
internal &quot;mel&quot; list. When edges are removed using <code><a href="#topic+delete.edges">delete.edges</a></code>
<code>NULL</code> elements are left on the list.  The function <code>valid.eids</code>
returns the ids of all the valid (non-null) edge ids for its <code>network</code>
argument.
</p>


<h3>Value</h3>

<p>a vector of integer ids corresponding to the non-null edges in x
</p>


<h3>Note</h3>

<p>If it is known that x has no deleted edges, <code>seq_along(x$mel)</code> is
a faster way to generate the sequence of possible edge ids.
</p>


<h3>Author(s)</h3>

<p>skyebend
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+delete.edges">delete.edges</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
net&lt;-network.initialize(100)
add.edges(net,1:99,2:100)
delete.edges(net,eid=5:95)
# get the ids of the non-deleted edges
valid.eids(net)

</code></pre>

<hr>
<h2 id='which.matrix.type'>Heuristic Determination of Matrix Types for Network Storage</h2><span id='topic+which.matrix.type'></span>

<h3>Description</h3>

<p><code>which.matrix.type</code> attempts to choose an appropriate matrix expression
for a <code>network</code> object, or (if its argument is a matrix) attempts to
determine whether the matrix is of type adjacency, incidence, or edgelist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which.matrix.type(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which.matrix.type_+3A_x">x</code></td>
<td>
<p>a matrix, or an object of class <code>network</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The heuristics used to determine matrix types are fairly arbitrary, and
should be avoided where possible.  This function is intended to provide a
modestly intelligent fallback option when explicit identification by the
user is not possible.
</p>


<h3>Value</h3>

<p>One of <code>"adjacency"</code>, <code>"incidence"</code>, or <code>"edgelist"</code>
</p>


<h3>Author(s)</h3>

<p>David Hunter <a href="mailto:dhunter@stat.psu.edu">dhunter@stat.psu.edu</a>
</p>


<h3>References</h3>

<p>Butts, C. T.  (2008).  &ldquo;network: a Package for Managing
Relational Data in R.&rdquo; <em>Journal of Statistical Software</em>, 24(2).
<a href="https://www.jstatsoft.org/v24/i02/">https://www.jstatsoft.org/v24/i02/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.matrix.network">as.matrix.network</a></code>, <code><a href="#topic+as.network.matrix">as.network.matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  #Create an arbitrary adjacency matrix
  m&lt;-matrix(rbinom(25,1,0.5),5,5)
  diag(m)&lt;-0

  #Can we guess the type?
  which.matrix.type(m)

  #Try the same thing with a network
  g&lt;-network(m)
  which.matrix.type(g)
  which.matrix.type(as.matrix.network(g,matrix.type="incidence"))
  which.matrix.type(as.matrix.network(g,matrix.type="edgelist"))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
