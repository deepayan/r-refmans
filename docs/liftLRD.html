<!DOCTYPE html><html><head><title>Help for package liftLRD</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {liftLRD}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#liftLRD-package'>
<p>Wavelet lifting estimators of the Hurst exponent for regularly and irregularly sampled time series</p></a></li>
<li><a href='#artificial.levels'><p>artificial.levels</p></a></li>
<li><a href='#bootci'>
<p>bootstrap confidence interval calculation</p></a></li>
<li><a href='#Hfrombeta'>
<p>Compute Hurst exponent from wavelet scale - energy regression slope</p></a></li>
<li><a href='#idj'>
<p>Functions to perform summary calculations of wavelet scales and energies.</p></a></li>
<li><a href='#liftHurst'>
<p>Performs (non-decimated) lifting based estimation of the Hurst exponent</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Wavelet Lifting Estimators of the Hurst Exponent for Regularly
and Irregularly Sampled Time Series</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-9</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-20</td>
</tr>
<tr>
<td>Author:</td>
<td>Marina Knight [aut],
  Guy Nason [ctb],
  Matt Nunes [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matt Nunes &lt;nunesrpackages@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementations of Hurst exponent estimators based on the relationship between wavelet lifting scales and wavelet energy of Knight et al (2017) &lt;<a href="https://doi.org/10.1007%2Fs11222-016-9698-2">doi:10.1007/s11222-016-9698-2</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>adlift, nlt</td>
</tr>
<tr>
<td>Suggests:</td>
<td>fracdiff</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-17 08:27:29 UTC; matt</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-17 08:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='liftLRD-package'>
Wavelet lifting estimators of the Hurst exponent for regularly and irregularly sampled time series
</h2><span id='topic+liftLRD-package'></span><span id='topic+liftLRD'></span>

<h3>Description</h3>

<p>Implementations of Hurst exponent estimators based on the relationship between wavelet lifting scales and wavelet energy
</p>


<h3>Details</h3>

<p>This package exploits a wavelet transform for irregularly spaced data to form wavelet-like scale-based energy measures for a time series.  This is then used to estimate the Hurst exponent. The main routine is <br /><br />
<code><a href="#topic+liftHurst">liftHurst</a></code>
</p>


<h3>Author(s)</h3>

<p>Marina Knight, Guy Nason, Matt Nunes 
</p>
<p>Maintainer: Matt Nunes &lt;nunesrpackages@gmail.com&gt;
</p>


<h3>References</h3>

<p>Knight, M. I, Nason, G. P. and Nunes, M. A. (2017) A wavelet lifting approach to long-memory estimation. <em>Stat. Comput.</em> <b>27</b> (6), 1453&ndash;1471. DOI 10.1007/s11222-016-9698-2.<br /><br />
For related literature on the lifting methodology adopted in the technique, see<br /><br />
Nunes, M. A., Knight, M. I and Nason, G. P. (2006) Adaptive lifting for nonparametric regression. <em>Stat. Comput.</em> <b>16</b> (2), 143&ndash;159.<br /><br /> 
Knight, M. I. and Nason, G. P. (2009) A 'nondecimated' wavelet transform. <em>Stat. Comput.</em> <b>19</b> (1), 1&ndash;16. <br /><br />
For more information on long-memory processes, see e.g.<br /><br />
Beran, J. et al. (2013) Long-memory processes.  Springer.
</p>

<hr>
<h2 id='artificial.levels'>artificial.levels</h2><span id='topic+artificial.levels'></span>

<h3>Description</h3>

<p>This function splits the coefficients into levels according to either (i) increasing quantiles of the removed interval lengths or (ii) dyadic splitting relative 
to a fixed lowest scale    
</p>


<h3>Usage</h3>

<pre><code class='language-R'>artificial.levels(y, rem, time, tail = TRUE, type = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="artificial.levels_+3A_y">y</code></td>
<td>
<p>a vector of the removed interval lengths (in the order of <span class="env">removelist</span>). </p>
</td></tr>
<tr><td><code id="artificial.levels_+3A_rem">rem</code></td>
<td>
<p>vector of indices of the removed points (from the output of the forward transform). </p>
</td></tr>
<tr><td><code id="artificial.levels_+3A_time">time</code></td>
<td>
<p>vector of observed times for the decomposed signal. </p>
</td></tr>
<tr><td><code id="artificial.levels_+3A_tail">tail</code></td>
<td>
<p>a boolean variable indicating whether coarse levels with a small number of detail coefficients (less than 10 coefficients) should be combined.</p>
</td></tr> 
<tr><td><code id="artificial.levels_+3A_type">type</code></td>
<td>
<p>an integer indicating which type of artificial levels to compute.  If <code>type==1</code>, the &quot;usual&quot; artificial levels using quantiles of the scales; otherwise the levels
are computed using quantiles being a multiplicative factor of a fixed number.  See details for more information. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the so-called artificial levels of a set of removed integrals and corresponding detail coefficients, to mimic the dyadic level splitting in a classical 
wavelet framework.  Details on the &quot;usual&quot; quantile-based splitting can be found in <code><a href="adlift.html#topic+artlev">artlev</a></code>.  If <code>type==2</code> or <code>type==3</code>, the artificial levels are 
defined by intervals of the form [a0 2^j,a0 2^(j-1) ) as described in Jansen et al. (2009), with a0 = 0.5 for <code>type==2</code> and set to the minimum sampling interval for 
<code>type==3</code>.  The amalgamation of coarser artificial levels prevents variable energies at coarser scales affecting the predicted relationship between the wavelet scales 
and their corresponding energies.
</p>


<h3>Value</h3>

<table>
<tr><td><code>p</code></td>
<td>
<p>a list of the grouped indices of <span class="env">removelist</span> (in decreasing group size) indicating thresholding groups.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes, Marina Knight</p>


<h3>References</h3>

<p>Jansen, M, Nason, G. P. and Silverman, B. W. (2009) Multiscale methods for data on graphs and irregular
multidimensional situations. <em>J. Roy. Stat. Soc. B</em> <b>71</b>, Part 1, 97&ndash;125.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+liftHurst">liftHurst</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#create test signal data
#
library(adlift)
x&lt;-runif(100)
y&lt;-make.signal2("blocks",x=x)
#
#perform forward transform...
#
out&lt;-fwtnp(x,y,LocalPred=AdaptNeigh,neighbours=2)
#
al&lt;-artificial.levels(out$lengthsremove,out$removelist, x, type = 1)
#
#
# the indices of removelist split into levels:
al
#
</code></pre>

<hr>
<h2 id='bootci'>
bootstrap confidence interval calculation
</h2><span id='topic+bootci'></span>

<h3>Description</h3>

<p>This function uses the Hurst exponent estimates from different lifting trajectories to form a bootstrap confidence interval 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootci(x, level = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootci_+3A_x">x</code></td>
<td>
<p>a vector of estimates for the Hurst exponent.
</p>
</td></tr>
<tr><td><code id="bootci_+3A_level">level</code></td>
<td>
<p>the significance level for which to compute the bootstrap confidence interval.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 2, indicating the lower and upper confidence interval values.
</p>


<h3>Author(s)</h3>

<p>Matt Nunes
</p>


<h3>References</h3>

<p>Knight, M. I, Nason, G. P. and Nunes, M. A. (2017) A wavelet lifting approach to long-memory estimation. <em>Stat. Comput.</em> <b>27</b> (6), 1453&ndash;1471. DOI 10.1007/s11222-016-9698-2.<br /><br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+liftHurst">liftHurst</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x&lt;-rnorm(100,0.7,0.24)	# vector representing Hurst estimates from NLT

bootci(x)

</code></pre>

<hr>
<h2 id='Hfrombeta'>
Compute Hurst exponent from wavelet scale - energy regression slope 
</h2><span id='topic+Hfrombeta'></span>

<h3>Description</h3>

<p>Uses the slope of the relationship between wavelet scale and wavelet energy to compute an estimate of the Hurst exponent
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hfrombeta(beta, model = c("FBM","FGN","ID"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hfrombeta_+3A_beta">beta</code></td>
<td>
<p> The estimated slope of the relationship between wavelet scale and energy.</p>
</td></tr>
<tr><td><code id="Hfrombeta_+3A_model">model</code></td>
<td>
<p> The assumed long-range dependence model for the time series under analysis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is a theoretical linear relationship growth in the (log) wavelet energy for increasing wavelet scale.  This corresponds to the decay in the autocorrelation of a 
(long range dependent) time series being analysed, and therefore the Hurst exponent, H.  The specific relation to H is dependent to the assumed model; in particular for a 
Fractional Brownian motion, the relationship between H and the slope is H = abs(beta - 1)/2, whereas for Fractional Gaussian noise or dth order Fractional differenced series,
the relationship is H = (beta+1)/2.
</p>


<h3>Value</h3>

<table>
<tr><td><code>H</code></td>
<td>
<p>The Hurst exponent, computed for a specific beta and underlying model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes 
</p>


<h3>References</h3>

<p>Knight, M. I, Nason, G. P. and Nunes, M. A. (2017) A wavelet lifting approach to long-memory estimation. <em>Stat. Comput.</em> <b>27</b> (6), 1453&ndash;1471. DOI 10.1007/s11222-016-9698-2.<br /><br />
Beran, J. et al. (2013)  Long-Memory Processes.  Springer. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+liftHurst">liftHurst</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Hfrombeta(0.8,model="FGN")

</code></pre>

<hr>
<h2 id='idj'>
Functions to perform summary calculations of wavelet scales and energies.
</h2><span id='topic+idj'></span><span id='topic+meanj'></span><span id='topic+medj'></span><span id='topic+mean2'></span><span id='topic+mad2'></span><span id='topic+meanmo'></span>

<h3>Description</h3>

<p>To estimate the slope of the relationship between wavelet scale and wavelet energy, choices have to be made as to how these quantities are computed.  Examples of these choices are 
the functions listed here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idj(x, j) 
meanj(x, j) 
medj(x, j) 
mean2(x) 
mad2(x) 
meanmo(x) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idj_+3A_x">x</code></td>
<td>
<p>a vector of values, representing the integrals or detail coefficients in a particular artificial level</p>
</td></tr>
<tr><td><code id="idj_+3A_j">j</code></td>
<td>
<p>the index of the artificial level.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value corresponding to the average squared detail coefficient, squared mean absolute deviation, median scale etc.  
</p>


<h3>Author(s)</h3>

<p>Matt Nunes
</p>


<h3>References</h3>

<p>Knight, M. I, Nason, G. P. and Nunes, M. A. (2017) A wavelet lifting approach to long-memory estimation. <em>Stat. Comput.</em> <b>27</b> (6), 1453&ndash;1471. DOI 10.1007/s11222-016-9698-2.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+liftHurst">liftHurst</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x&lt;-rnorm(50,30,2)

# calculate the average squared value of x (i.e. energy)

mean2(x)

</code></pre>

<hr>
<h2 id='liftHurst'>
Performs (non-decimated) lifting based estimation of the Hurst exponent
</h2><span id='topic+liftHurst'></span>

<h3>Description</h3>

<p>The function exploits the linear relationship in wavelet energy per scale to estimate the long range dependence parameter of a irregular time series. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>liftHurst(x, grid = 1:length(x), model = "FGN", ntraj = 50, 
tradonly = FALSE, cutoffs = 0, cut.fine = TRUE, efun = meanmo, 
afun = idj, altype = 1, tail = TRUE, normalise = TRUE, 
level = 0.05, bc = TRUE, vc = TRUE, jsc = TRUE, BHonly=TRUE, 
verbose = FALSE, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="liftHurst_+3A_x">x</code></td>
<td>

<p>A time series, possibly irregularly spaced. 
</p>
</td></tr>
<tr><td><code id="liftHurst_+3A_grid">grid</code></td>
<td>
<p>The time samples corresponding to the time series <code>x</code>.</p>
</td></tr>
<tr><td><code id="liftHurst_+3A_model">model</code></td>
<td>
<p>The underlying model the time series is assumed to follow.  Possible values are <code>"FBM"</code>, <code>"FGN"</code>, and <code>"ID"</code>.</p>
</td></tr>
<tr><td><code id="liftHurst_+3A_ntraj">ntraj</code></td>
<td>
<p>The number of lifting trajectories (bootstraps) used for the estimation of the Hurst exponent.</p>
</td></tr>
<tr><td><code id="liftHurst_+3A_tradonly">tradonly</code></td>
<td>
<p>A boolean variable, indicating whether the &quot;traditional&quot; minimum integral lifting trajectory should be used for the estimation (<code>tradonly=TRUE</code>).  In this case,
the argument <code>ntraj</code> is not used.
</p>
</td></tr>
<tr><td><code id="liftHurst_+3A_cutoffs">cutoffs</code></td>
<td>

<p>A vector indicating if the coarsest scales are to be removed when estimating the linear slope in the energy-scale relationship; for example if <code>cutoffs = 0</code>, 
all levels will be used in the estimation.  For multiple cutoffs, all slopes will be calculated.
</p>
</td></tr>
<tr><td><code id="liftHurst_+3A_cut.fine">cut.fine</code></td>
<td>

<p>A boolean variable indicating if the finest (default) or coarsest scales are to be removed when estimating the linear slope in the energy-scale relationship; see <code>cutoffs</code> description for more information.
</p>
</td></tr>
<tr><td><code id="liftHurst_+3A_efun">efun</code></td>
<td>
<p>A function indicating which measure of wavelet energy to use.  The default is <code>meanmo</code>, corresponding to the average squared detail coefficient within a particular 
scale, scaled by (n-1).  Other measures could be <code>mad2</code> (squared median absolute deviation of the detail coefficients), but the average squared detail coefficient has been shown to be 
more reliable than other measures.
</p>
</td></tr>
<tr><td><code id="liftHurst_+3A_afun">afun</code></td>
<td>
<p>A function indicating which measure of wavelet integral (scale) to use (corresponding to the x-axis of the energy-scale relationship).  The default is <code>idj</code>, 
corresponding to the log2 of the dyadic wavelet scale, i.e an integer representing the scale.  Other measures could be <code>meanj</code> or <code>medj</code>, representing the  
average (respectively median) integral value for each artificial scale.
</p>
</td></tr>
<tr><td><code id="liftHurst_+3A_altype">altype</code></td>
<td>
<p>An integer indicating which type of artificial levels to be used, see <br /> 
<code><a href="#topic+artificial.levels">artificial.levels</a></code></p>
</td></tr></table>
<p> for more information.
</p>
<table>
<tr><td><code id="liftHurst_+3A_tail">tail</code></td>
<td>
<p>A boolean variable indicating whether to amalgamate artificial levels with few coefficients, see <code><a href="#topic+artificial.levels">artificial.levels</a></code></p>
</td></tr></table>
<p> for more information.
</p>
<table>
<tr><td><code id="liftHurst_+3A_normalise">normalise</code></td>
<td>
<p>A boolean variable indicating whether to normalise the detail coefficients by their individual (induced) standard deviations (computed using the diagonal of the 
lifting matrix). 
</p>
</td></tr>
<tr><td><code id="liftHurst_+3A_level">level</code></td>
<td>

<p>The significance level for the bootstrap confidence interval of the Hurst exponent estimate. 
</p>
</td></tr>
<tr><td><code id="liftHurst_+3A_bc">bc</code></td>
<td>

<p>A boolean variable indicating whether bias-correction should take place or not, using the approximate chi^2 distribution of the wavelet energies. 
</p>
</td></tr>
<tr><td><code id="liftHurst_+3A_vc">vc</code></td>
<td>

<p>A boolean variable indicating whether a weighted linear regression should be used when estimating the Hurst exponent.  If <code>TRUE</code>, the inverse of the variances of the approximate chi^2 distribution of the wavelet energies are used in the regression. 
</p>
</td></tr>
<tr><td><code id="liftHurst_+3A_jsc">jsc</code></td>
<td>
<p>A boolean variable indicating whether the slope of the log-linear relationship between the artificial scales and the log of the integrals should be computed and used to reweight the estimate of the Hurst exponent. 
</p>
</td></tr>
<tr><td><code id="liftHurst_+3A_bhonly">BHonly</code></td>
<td>
<p>A boolean variable indicating whether only the Hurst estimate should be returned.  If <code>FALSE</code>, then the (log) energies used in the calculation is also returned.  Note that if bootstrapping is performed (<code>tradonly=FALSE</code>), then the energies for the last trajectory will be returned.
</p>
</td></tr>
<tr><td><code id="liftHurst_+3A_verbose">verbose</code></td>
<td>
<p>A boolean variable indicating whether informative status messages should be printed to the screen. 
</p>
</td></tr>
<tr><td><code id="liftHurst_+3A_...">...</code></td>
<td>
<p>Any other optional arguments to the function <code>fwtnpperm</code> function from the <code>nlt</code> package, which performs wavelet lifting of the time series <code>x</code> according
to a specified lifting trajectory.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Wavelet lifting is performed on a time series to convert it into a set of wavelet coefficients and corresponding lifting integrals, specific to when the data were &quot;lifted&quot; 
during the decomposition.  The coefficients are then grouped into artificial levels, using the integrals to mimic the support of the wavelets in the classical wavelet setting, and 
therefore producing a notion of scale.  The coefficients in each artificial level are then used to compute values of the wavelet energy for a particular level.  The (slope of the)
linear relationship between the scales and their energies is then used in computing an estimate of the Hurst exponent for the series.  This procedure can be performed for multiple
(random) lifting trajectories, each producing a slightly different estimate.  
</p>


<h3>Value</h3>

<p>If <code>tradonly=TRUE</code>, the function returns a matrix of dimension <code>length(cutoffs)</code> x 2.  The first column are the slopes of the regression fits for each cutoff, whereas the 
second column are the corresponding estimates for the Hurst exponent. <br /><br />
If <code>tradonly=FALSE</code>, the function returns a matrix of dimension <code>length(cutoffs)</code> x 5.  The first column are the slopes of the regression fits for each cutoff, where the 
average is taken over the <code>ntraj</code> randomly generated lifting trajectories.  Similarly, the second column represents the average Hurst exponent for the cutoffs over all 
lifting paths.  The third column is the standard deviation of the <code>ntraj</code> Hurst estimates through performing non-decimated lifting.  The fourth and fifth columns are the lower and upper values of the bootstrap confidence interval of the Hurst exponent estimate.
</p>
<p>If <code>BHonly=FALSE</code>, the routine also returns the energies and scales (on a log scale) which are used in the regression to estimate the decay properties of the spectrum (for the last lifting trajectory), as well as the weights used in the regression (if <code>vc = TRUE</code>).  if <code>jsc = TRUE</code>, the slope of the integral log-linear relationship is also returned.
</p>


<h3>Author(s)</h3>

<p>Marina Knight, Matt Nunes
</p>


<h3>References</h3>

<p>Knight, M. I, Nason, G. P. and Nunes, M. A. (2017) A wavelet lifting approach to long-memory estimation. <em>Stat. Comput.</em>  <b>27</b> (6), 1453&ndash;1471. DOI 10.1007/s11222-016-9698-2.<br /><br />
</p>
<p>For more details on the weighted linear regression and bias calculations, see e.g.<br /> <br />
</p>
<p>Veitch, D. and Abry, P. (1999) A Wavelet-Based Joint Estimator of the Parameters of Long-Range Dependence. <em>IEEE Trans. Info. Theory</em> <b>45</b> (3), 878&ndash;897.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+artificial.levels">artificial.levels</a></code>, <code><a href="#topic+Hfrombeta">Hfrombeta</a></code>, <code><a href="nlt.html#topic+fwtnpperm">fwtnpperm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(fracdiff)

# simulate a long range dependent time series
x&lt;-fracdiff.sim(n = 200, d = 0.3)$series

# perform lifting-based estimation of the Hurst exponent

Hestx&lt;-liftHurst(x, tradonly=TRUE)

# An example with missingness
x1&lt;-fracdiff.sim(n = 500, d = 0.3)$series
gap1&lt;-30:40
gap2&lt;-77:90
gap3&lt;-146:166
timeindex&lt;-setdiff(1:500,c(gap1,gap2,gap3))

Hestx1&lt;-liftHurst(x1[timeindex],grid=timeindex, tradonly=TRUE)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
