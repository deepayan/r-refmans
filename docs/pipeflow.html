<!DOCTYPE html><html lang="en-US"><head><title>Help for package pipeflow</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pipeflow}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pipe_add'><p>Add pipeline step</p></a></li>
<li><a href='#pipe_append'><p>Append two pipelines</p></a></li>
<li><a href='#pipe_append_to_step_names'><p>Append string to all step names</p></a></li>
<li><a href='#pipe_clone'><p>Clone pipeline</p></a></li>
<li><a href='#pipe_collect_out'><p>Collect output from entire pipeline</p></a></li>
<li><a href='#pipe_discard_steps'><p>Discard steps from the pipeline</p></a></li>
<li><a href='#pipe_get_data'><p>Get data</p></a></li>
<li><a href='#pipe_get_depends'><p>Get step dependencies</p></a></li>
<li><a href='#pipe_get_graph'><p>Pipeline graph</p></a></li>
<li><a href='#pipe_get_out'><p>Get output of given step</p></a></li>
<li><a href='#pipe_get_params'><p>Get pipeline parameters</p></a></li>
<li><a href='#pipe_get_step'><p>Get step information</p></a></li>
<li><a href='#pipe_insert_after'><p>Insert step</p></a></li>
<li><a href='#pipe_length'><p>Length of the pipeline</p></a></li>
<li><a href='#pipe_lock_step'><p>Lock steps</p></a></li>
<li><a href='#pipe_new'><p>Create new pipeline</p></a></li>
<li><a href='#pipe_pop_step'><p>Pop steps from the pipeline</p></a></li>
<li><a href='#pipe_print'><p>Print the pipeline as a table</p></a></li>
<li><a href='#pipe_remove_step'><p>Remove certain step from the pipeline.</p></a></li>
<li><a href='#pipe_rename_step'><p>Rename step</p></a></li>
<li><a href='#pipe_replace_step'><p>Replace pipeline step</p></a></li>
<li><a href='#pipe_reset'><p>Reset pipeline</p></a></li>
<li><a href='#pipe_run'><p>Run pipeline</p></a></li>
<li><a href='#pipe_run_step'><p>Run specific step</p></a></li>
<li><a href='#pipe_set_data'><p>Set data</p></a></li>
<li><a href='#pipe_set_data_split'><p>Split-multiply pipeline by list of data sets</p></a></li>
<li><a href='#pipe_set_keep_out'><p>Change output flag</p></a></li>
<li><a href='#pipe_set_params'><p>Set pipeline parameters</p></a></li>
<li><a href='#pipe_set_params_at_step'><p>Set parameters at step</p></a></li>
<li><a href='#pipe_split'><p>Split-up pipeline</p></a></li>
<li><a href='#Pipeline'><p>Pipeline Class</p></a></li>
<li><a href='#set_log_layout'><p>Set pipeflow log layout</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Lightweight, General-Purpose Data Analysis Pipelines</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>Description:</td>
<td>A lightweight yet powerful framework for building robust data
    analysis pipelines. With 'pipeflow', you initialize a pipeline with your
    dataset and construct workflows step by step by adding R functions.
    You can modify, remove, or insert steps and parameters at any stage,
    while 'pipeflow' ensures the pipeline's integrity.
    Overall, this package offers a beginner-friendly framework that simplifies
    and streamlines the development of data analysis pipelines by making
    them modular, intuitive, and adaptable.</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, jsonlite, lgr, methods, R6, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, knitr, mockery, rmarkdown, testthat, visNetwork</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://rpahl.github.io/pipeflow/">https://rpahl.github.io/pipeflow/</a>,
<a href="https://github.com/rpahl/pipeflow">https://github.com/rpahl/pipeflow</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rpahl/pipeflow/issues">https://github.com/rpahl/pipeflow/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Roman Pahl &lt;roman.pahl@gmail.com&gt;</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-22 20:50:34 UTC; Roman</td>
</tr>
<tr>
<td>Author:</td>
<td>Roman Pahl [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-22 21:20:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='pipe_add'>Add pipeline step</h2><span id='topic+pipe_add'></span>

<h3>Description</h3>

<p>A pipeline consists of a series of steps, which usually
are added one by one. Each step is made up of a function computing
something once the pipeline is run. This function can be an existing
R function (e.g. <code><a href="base.html#topic+mean">mean()</a></code>) or an anonymous/lambda function specifically
defined for the pipeline. One useful feature is that function
parameters can refer to results of earlier pipeline steps using the
syntax <code>x = ~earlier_step_name</code> - see the Examples for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_add(
  pip,
  step,
  fun,
  params = list(),
  description = "",
  group = step,
  keepOut = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pipe_add_+3A_pip">pip</code></td>
<td>
<p><code>Pipeline</code> object</p>
</td></tr>
<tr><td><code id="pipe_add_+3A_step">step</code></td>
<td>
<p><code>string</code> the name of the step. Each step name must
be unique.</p>
</td></tr>
<tr><td><code id="pipe_add_+3A_fun">fun</code></td>
<td>
<p><code>function</code> or name of the function to be applied at
the step. Both existing and anonymous/lambda functions can be used.
All function parameters must have default values. If a parameter
is missing a default value in the function signature, alternatively,
it can be set via the <code>params</code> argument (see Examples section with
<code><a href="base.html#topic+mean">mean()</a></code> function).</p>
</td></tr>
<tr><td><code id="pipe_add_+3A_params">params</code></td>
<td>
<p><code>list</code> list of parameters to set or overwrite
parameters of the passed function.</p>
</td></tr>
<tr><td><code id="pipe_add_+3A_description">description</code></td>
<td>
<p><code>string</code> optional description of the step</p>
</td></tr>
<tr><td><code id="pipe_add_+3A_group">group</code></td>
<td>
<p><code>string</code> output collected after pipeline execution
(see <code><a href="#topic+pipe_collect_out">pipe_collect_out()</a></code> is grouped by the defined group
names. By default, this is the name of the step, which comes in
handy when the pipeline is copy-appended multiple times to keep
the results of the same function/step grouped at one place.</p>
</td></tr>
<tr><td><code id="pipe_add_+3A_keepout">keepOut</code></td>
<td>
<p><code>logical</code> if <code>FALSE</code> (default) the output of the
step is not collected when calling <code><a href="#topic+pipe_collect_out">pipe_collect_out()</a></code> after the pipeline
run. This option is used to only keep the results that matter
and skip intermediate results that are not needed. See also
function <code><a href="#topic+pipe_collect_out">pipe_collect_out()</a></code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the <code>Pipeline</code> object invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Add steps with lambda functions
p &lt;- pipe_new("myPipe", data = 1)
pipe_add(p, "s1", \(x = ~data) 2*x)  # use input data
pipe_add(p, "s2", \(x = ~data, y = ~s1) x * y)
try(pipe_add(p, "s2", \(z = 3) 3)) # error: step 's2' exists already
try(pipe_add(p, "s3", \(z = ~foo) 3)) # dependency 'foo' not found
p

# Add step with existing function
p &lt;- pipe_new("myPipe", data = c(1, 2, NA, 3, 4))
try(pipe_add(p, "calc_mean", mean))  # default value for x is missing
pipe_add(p, "calc_mean", mean, params = list(x = ~data, na.rm = TRUE))
p |&gt; pipe_run() |&gt; pipe_get_out("calc_mean")

# Step description
p &lt;- pipe_new("myPipe", data = 1:10)
pipe_add(p, "s1", \(x = ~data) 2*x, description = "multiply by 2")
print(p, verbose = TRUE) # print all columns including description


# Group output
p &lt;- pipe_new("myPipe", data = data.frame(x = 1:2, y = 3:4))
pipe_add(p, "prep_x", \(data = ~data) data$x, group = "prep")
pipe_add(p, "prep_y", \(data = ~data) (data$y)^2, group = "prep")
pipe_add(p, "sum", \(x = ~prep_x, y = ~prep_y) x + y)
p |&gt; pipe_run() |&gt; pipe_collect_out(all = TRUE)
</code></pre>

<hr>
<h2 id='pipe_append'>Append two pipelines</h2><span id='topic+pipe_append'></span>

<h3>Description</h3>

<p>When appending, <code>pipeflow</code> takes care of potential name
clashes with respect to step names and dependencies, that is, if
needed, it will automatically adapt step names and dependencies to
make sure they are unique in the merged pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_append(pip, p, outAsIn = FALSE, tryAutofixNames = TRUE, sep = ".")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pipe_append_+3A_pip">pip</code></td>
<td>
<p><code>Pipeline</code> object to be appended to.</p>
</td></tr>
<tr><td><code id="pipe_append_+3A_p">p</code></td>
<td>
<p><code>Pipeline</code> object to be appended.</p>
</td></tr>
<tr><td><code id="pipe_append_+3A_outasin">outAsIn</code></td>
<td>
<p><code>logical</code> if <code>TRUE</code>, output of first pipeline is used
as input for the second pipeline.</p>
</td></tr>
<tr><td><code id="pipe_append_+3A_tryautofixnames">tryAutofixNames</code></td>
<td>
<p><code>logical</code> if <code>TRUE</code>, name clashes are tried
to be automatically resolved by appending the 2nd pipeline's name.
Only set to <code>FALSE</code>, if you know what you are doing.</p>
</td></tr>
<tr><td><code id="pipe_append_+3A_sep">sep</code></td>
<td>
<p><code>string</code> separator used when auto-resolving step names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns new combined <code>Pipeline</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Append pipeline
p1 &lt;- pipe_new("pipe1")
pipe_add(p1, "step1", \(x = 1) x)
p2 &lt;- pipe_new("pipe2")
pipe_add(p2, "step2", \(y = 1) y)
p1 |&gt; pipe_append(p2)

# Append pipeline with potential name clashes
p3 &lt;- pipe_new("pipe3")
pipe_add(p3, "step1", \(z = 1) z)
p1 |&gt; pipe_append(p2) |&gt; pipe_append(p3)

# Use output of first pipeline as input for second pipeline
p1 &lt;- pipe_new("pipe1", data = 8)
p2 &lt;- pipe_new("pipe2")
pipe_add(p1, "square", \(x = ~data) x^2)
pipe_add(p2, "log2", \(x = ~data) log2(x))

p12 &lt;- p1 |&gt; pipe_append(p2, outAsIn = TRUE)
p12 |&gt; pipe_run() |&gt; pipe_get_out("log2")
p12

# Custom name separator for adapted step names
p1 |&gt; pipe_append(p2, sep = "___")
</code></pre>

<hr>
<h2 id='pipe_append_to_step_names'>Append string to all step names</h2><span id='topic+pipe_append_to_step_names'></span>

<h3>Description</h3>

<p>Appends string to all step names and takes care
of updating step dependencies accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_append_to_step_names(pip, postfix, sep = ".")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pipe_append_to_step_names_+3A_pip">pip</code></td>
<td>
<p><code>Pipeline</code> object</p>
</td></tr>
<tr><td><code id="pipe_append_to_step_names_+3A_postfix">postfix</code></td>
<td>
<p><code>string</code> to be appended to each step name.</p>
</td></tr>
<tr><td><code id="pipe_append_to_step_names_+3A_sep">sep</code></td>
<td>
<p><code>string</code> separator between step name and postfix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the <code>Pipeline</code> object invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- pipe_new("pipe")
pipe_add(p, "step1", \(x = 1) x)
pipe_add(p, "step2", \(y = 1) y)
pipe_append_to_step_names(p, "new")
p
pipe_append_to_step_names(p, "foo", sep = "__")
p
</code></pre>

<hr>
<h2 id='pipe_clone'>Clone pipeline</h2><span id='topic+pipe_clone'></span>

<h3>Description</h3>

<p>Creates a copy of a pipeline object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_clone(pip, deep = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pipe_clone_+3A_pip">pip</code></td>
<td>
<p><code>Pipeline</code> object</p>
</td></tr>
<tr><td><code id="pipe_clone_+3A_deep">deep</code></td>
<td>
<p><code>logical</code> whether to perform a deep copy</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the copied <code>Pipeline</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p1 &lt;- pipe_new("pipe")
pipe_add(p1, "step1", \(x = 1) x)
p2 &lt;- pipe_clone(p1)
pipe_add(p2, "step2", \(y = 1) y)
p1
p2
</code></pre>

<hr>
<h2 id='pipe_collect_out'>Collect output from entire pipeline</h2><span id='topic+pipe_collect_out'></span>

<h3>Description</h3>

<p>Collects output afer pipeline run, by default, from all
steps for which <code>keepOut</code> was set to <code>TRUE</code> when steps were added
(see <code><a href="#topic+pipe_add">pipe_add()</a></code>). The output is grouped by the group names (see
<code>group</code> parameter in <code><a href="#topic+pipe_add">pipe_add()</a></code>),
which by default are set identical to the step names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_collect_out(pip, groupBy = "group", all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pipe_collect_out_+3A_pip">pip</code></td>
<td>
<p><code>Pipeline</code> object</p>
</td></tr>
<tr><td><code id="pipe_collect_out_+3A_groupby">groupBy</code></td>
<td>
<p><code>string</code> column of pipeline by which to group the
output.</p>
</td></tr>
<tr><td><code id="pipe_collect_out_+3A_all">all</code></td>
<td>
<p><code>logical</code> if <code>TRUE</code> all output is collected
regardless of the <code>keepOut</code> flag. This can be useful for debugging.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list</code> containing the output, named after the groups, which,
by default, are the steps.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- pipe_new("pipe", data = 1:2)
pipe_add(p, "step1", \(x = ~data) x + 2)
pipe_add(p, "step2", \(x = ~step1) x + 2, keepOut = TRUE)
pipe_run(p)
pipe_collect_out(p)
pipe_collect_out(p, all = TRUE) |&gt; str()

# Grouped output
p &lt;- pipe_new("pipe", data = 1:2)
pipe_add(p, "step1", \(x = ~data) x + 2, group = "add")
pipe_add(p, "step2", \(x = ~step1, y = 2) x + y, group = "add")
pipe_add(p, "step3", \(x = ~data) x * 3, group = "mult")
pipe_add(p, "step4", \(x = ~data, y = 2) x * y, group = "mult")
p

pipe_run(p)
pipe_collect_out(p, all = TRUE) |&gt; str()

# Grouped by state
pipe_set_params(p, list(y = 5))
p

pipe_collect_out(p, groupBy = "state", all = TRUE) |&gt; str()
</code></pre>

<hr>
<h2 id='pipe_discard_steps'>Discard steps from the pipeline</h2><span id='topic+pipe_discard_steps'></span>

<h3>Description</h3>

<p>Discard all steps that match a given <code>pattern</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_discard_steps(pip, pattern, recursive = FALSE, fixed = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pipe_discard_steps_+3A_pip">pip</code></td>
<td>
<p><code>Pipeline</code> object</p>
</td></tr>
<tr><td><code id="pipe_discard_steps_+3A_pattern">pattern</code></td>
<td>
<p><code>string</code> containing a regular expression (or
character string for <code>fixed = TRUE</code>) to be matched.</p>
</td></tr>
<tr><td><code id="pipe_discard_steps_+3A_recursive">recursive</code></td>
<td>
<p><code>logical</code> if <code>TRUE</code> the step is removed together
with all its downstream dependencies.</p>
</td></tr>
<tr><td><code id="pipe_discard_steps_+3A_fixed">fixed</code></td>
<td>
<p><code>logical</code> If <code>TRUE</code>, <code>pattern</code> is a string to
be matched as is. Overrides all conflicting arguments.</p>
</td></tr>
<tr><td><code id="pipe_discard_steps_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="base.html#topic+grep">grep()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>Pipeline</code> object invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- pipe_new("pipe", data = 1:2)
pipe_add(p, "add1", \(x = ~data) x + 1)
pipe_add(p, "add2", \(x = ~add1) x + 2)
pipe_add(p, "mult3", \(x = ~add1) x * 3)
pipe_add(p, "mult4", \(x = ~add2) x * 4)
p

pipe_discard_steps(p, "mult")
p

# Re-add steps
pipe_add(p, "mult3", \(x = ~add1) x * 3)
pipe_add(p, "mult4", \(x = ~add2) x * 4)
p

# Discarding 'add1' does not work ...
try(pipe_discard_steps(p, "add1"))

# ... unless we enforce to remove its downstream dependencies as well
pipe_discard_steps(p, "add1", recursive = TRUE)
p

# Trying to discard non-existent steps is just ignored
pipe_discard_steps(p, "non-existent")
</code></pre>

<hr>
<h2 id='pipe_get_data'>Get data</h2><span id='topic+pipe_get_data'></span>

<h3>Description</h3>

<p>Get the data set for the pipeline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_get_data(pip)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pipe_get_data_+3A_pip">pip</code></td>
<td>
<p><code>Pipeline</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the output defined in the <code>data</code> step, which by default is
the first step of the pipeline
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- pipe_new("pipe", data = 1:2)
pipe_get_data(p)
pipe_set_data(p, 3:4)
pipe_get_data(p)
</code></pre>

<hr>
<h2 id='pipe_get_depends'>Get step dependencies</h2><span id='topic+pipe_get_depends'></span><span id='topic+pipe_get_depends_down'></span><span id='topic+pipe_get_depends_up'></span>

<h3>Description</h3>

<p>Get step dependencies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_get_depends(pip)

pipe_get_depends_down(pip, step, recursive = TRUE)

pipe_get_depends_up(pip, step, recursive = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pipe_get_depends_+3A_pip">pip</code></td>
<td>
<p><code>Pipeline</code> object</p>
</td></tr>
<tr><td><code id="pipe_get_depends_+3A_step">step</code></td>
<td>
<p><code>string</code> name of step</p>
</td></tr>
<tr><td><code id="pipe_get_depends_+3A_recursive">recursive</code></td>
<td>
<p><code>logical</code> if <code>TRUE</code>, dependencies of dependencies
are also returned.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>pipe_get_depends</code>: named list of dependencies for each step
</p>
</li>
<li> <p><code>pipe_get_depends_down</code>: list of downstream dependencies
</p>
</li>
<li> <p><code>pipe_get_depends_up</code>: list of downstream dependencies
</p>
</li></ul>



<h3>Methods</h3>


<ul>
<li> <p><code>pipe_get_depends</code>: get all dependencies for all steps defined
in the pipeline
</p>
</li>
<li> <p><code>pipe_get_depends_down</code>: get all downstream dependencies of a
given step, by default descending recursively.
</p>
</li>
<li> <p><code>pipe_get_depends_up</code>: get all upstream dependencies of a
given step, by default descending recursively.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># pipe_get_depends
p &lt;- pipe_new("pipe", data = 1:2)
pipe_add(p, "add1", \(x = ~data) x + 1)
pipe_add(p, "add2", \(x = ~data, y = ~add1) x + y)
pipe_get_depends(p)

# pipe_get_depends_down
p &lt;- pipe_new("pipe", data = 1:2)
pipe_add(p, "add1", \(x = ~data) x + 1)
pipe_add(p, "add2", \(x = ~data, y = ~add1) x + y)
pipe_add(p, "mult3", \(x = ~add1) x * 3)
pipe_add(p, "mult4", \(x = ~add2) x * 4)
pipe_get_depends_down(p, "add1")
pipe_get_depends_down(p, "add1", recursive = FALSE)

# pipe_get_depends_up
p &lt;- pipe_new("pipe", data = 1:2)
pipe_add(p, "add1", \(x = ~data) x + 1)
pipe_add(p, "add2", \(x = ~data, y = ~add1) x + y)
pipe_add(p, "mult3", \(x = ~add1) x * 3)
pipe_add(p, "mult4", \(x = ~add2) x * 4)
pipe_get_depends_up(p, "mult4")
pipe_get_depends_up(p, "mult4", recursive = FALSE)
</code></pre>

<hr>
<h2 id='pipe_get_graph'>Pipeline graph</h2><span id='topic+pipe_get_graph'></span>

<h3>Description</h3>

<p>Get the pipeline as a graph with nodes and edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_get_graph(pip, groups = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pipe_get_graph_+3A_pip">pip</code></td>
<td>
<p><code>Pipeline</code> object</p>
</td></tr>
<tr><td><code id="pipe_get_graph_+3A_groups">groups</code></td>
<td>
<p><code>character</code> if not <code>NULL</code>, only steps belonging to the
given groups are considered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with two data frames, one for nodes and one for edges
ready to be used with the <code><a href="visNetwork.html#topic+visNetwork">visNetwork::visNetwork()</a></code> function of the
<a href="visNetwork.html#topic+visNetwork">visNetwork</a> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- pipe_new("pipe", data = 1:2)
pipe_add(p, "add1", \(data = ~data, x = 1) x + data)
pipe_add(p, "add2", \(x = 1, y = ~add1) x + y)
pipe_add(p, "mult1", \(x = ~add1, y = ~add2) x * y)
graph &lt;- pipe_get_graph(p)
graph

if (require("visNetwork", quietly = TRUE)) {
    do.call(visNetwork, args = graph)
}
</code></pre>

<hr>
<h2 id='pipe_get_out'>Get output of given step</h2><span id='topic+pipe_get_out'></span>

<h3>Description</h3>

<p>Get output of given step
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_get_out(pip, step)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pipe_get_out_+3A_pip">pip</code></td>
<td>
<p><code>Pipeline</code> object</p>
</td></tr>
<tr><td><code id="pipe_get_out_+3A_step">step</code></td>
<td>
<p><code>string</code> name of step</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the output at the given step.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pipe_collect_out">pipe_collect_out()</a></code> to collect output of multiple steps.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- pipe_new("pipe", data = 1:2)
pipe_add(p, "add1", \(x = ~data) x + 1)
pipe_add(p, "add2", \(x = ~data, y = ~add1) x + y)
pipe_run(p)
pipe_get_out(p, "add1")
pipe_get_out(p, "add2")
</code></pre>

<hr>
<h2 id='pipe_get_params'>Get pipeline parameters</h2><span id='topic+pipe_get_params'></span><span id='topic+pipe_get_params_at_step'></span><span id='topic+pipe_get_params_unique'></span><span id='topic+pipe_get_params_unique_json'></span>

<h3>Description</h3>

<p>Retrieves unbound function parameters defined in
the pipeline where 'unbound' means parameters that are not linked
to other steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_get_params(pip, ignoreHidden = TRUE)

pipe_get_params_at_step(pip, step, ignoreHidden = TRUE)

pipe_get_params_unique(pip, ignoreHidden = TRUE)

pipe_get_params_unique_json(pip, ignoreHidden = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pipe_get_params_+3A_pip">pip</code></td>
<td>
<p><code>Pipeline</code> object</p>
</td></tr>
<tr><td><code id="pipe_get_params_+3A_ignorehidden">ignoreHidden</code></td>
<td>
<p><code>logical</code> if TRUE, hidden parameters (i.e. all
paramater names starting with a dot) are ignored and thus not returned.</p>
</td></tr>
<tr><td><code id="pipe_get_params_+3A_step">step</code></td>
<td>
<p><code>string</code> name of step</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>pipe_get_params</code>: list of parameters, sorted and named by step -
steps with no parameters are filtered out
</p>
</li>
<li> <p><code>pipe_get_params_at_step</code>: list of parameters at given step
</p>
</li>
<li> <p><code>pipe_get_params_unique</code>:  list of parameters where each parameter
is only listed once. The values of the parameters will be the values
of the first step where the parameters were defined, respectively.
</p>
</li>
<li> <p><code>get_params_unique_json</code>: flat unnamed json list of unique parameters
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># pipe_get_params
p &lt;- pipe_new("pipe", data = 1:2)
pipe_add(p, "add1", \(data = ~data, x = 1) x + data)
pipe_add(p, "add2", \(x = 1, y = 2, .z = 3) x + y + .z)
pipe_add(p, "add3", \() 1 + 2)
pipe_get_params(p, ) |&gt; str()
pipe_get_params(p, ignoreHidden = FALSE) |&gt; str()

# pipe_get_params_at_step
pipe_get_params_at_step(p, "add2")
pipe_get_params_at_step(p, "add2", ignoreHidden = FALSE)
pipe_get_params_at_step(p, "add3")

# pipe_get_params_unique
p &lt;- pipe_new("pipe", data = 1:2)
pipe_add(p, "add1", \(data = ~data, x = 1) x + data)
pipe_add(p, "add2", \(x = 1, y = 2, .z = 3) x + y + .z)
pipe_add(p, "mult1", \(x = 4, y = 5, .z = 6, b = ~add2) x * y * b)
pipe_get_params_unique(p)
pipe_get_params_unique(p, ignoreHidden = FALSE)

# get_params_unique_json
pipe_get_params_unique_json(p)
pipe_get_params_unique_json(p, ignoreHidden = FALSE)
</code></pre>

<hr>
<h2 id='pipe_get_step'>Get step information</h2><span id='topic+pipe_get_step'></span><span id='topic+pipe_get_step_names'></span><span id='topic+pipe_get_step_number'></span><span id='topic+pipe_has_step'></span>

<h3>Description</h3>

<p>Get step information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_get_step(pip, step)

pipe_get_step_names(pip)

pipe_get_step_number(pip, step)

pipe_has_step(pip, step)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pipe_get_step_+3A_pip">pip</code></td>
<td>
<p><code>Pipeline</code> object</p>
</td></tr>
<tr><td><code id="pipe_get_step_+3A_step">step</code></td>
<td>
<p><code>string</code> name of step</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>pipe_get_step</code>: <code>data.table</code> row containing the step
</p>
</li>
<li> <p><code>pipe_get_step_names</code>: <code>character</code> vector of step names
</p>
</li>
<li> <p><code>pipe_get_step_number</code>: the step number in the pipeline
</p>
</li>
<li> <p><code>pipe_get_step_number</code>: whether step exists
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- pipe_new("pipe", data = 1:2)
pipe_add(p, "add1", \(data = ~data, x = 1) x + data)
pipe_add(p, "add2", \(x = 1, y = 2, z = ~add1) x + y + z)
pipe_run(p)

# pipe_get_step_names
pipe_get_step_names(p)

# get_step_number
pipe_get_step_number(p, "add1")
pipe_get_step_number(p, "add2")

# pipe_has_step
pipe_has_step(p, "add1")
pipe_has_step(p, "foo")

# pipe_get_step
add1 &lt;- pipe_get_step(p, "add1")
add1

add1[["params"]]

add1[["fun"]]

try(p$get_step("foo")) # error: step 'foo' does not exist
</code></pre>

<hr>
<h2 id='pipe_insert_after'>Insert step</h2><span id='topic+pipe_insert_after'></span><span id='topic+pipe_insert_before'></span>

<h3>Description</h3>

<p>Insert step
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_insert_after(pip, afterStep, step, ...)

pipe_insert_before(pip, beforeStep, step, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pipe_insert_after_+3A_pip">pip</code></td>
<td>
<p><code>Pipeline</code> object</p>
</td></tr>
<tr><td><code id="pipe_insert_after_+3A_afterstep">afterStep</code></td>
<td>
<p><code>string</code> name of step after which to insert</p>
</td></tr>
<tr><td><code id="pipe_insert_after_+3A_step">step</code></td>
<td>
<p><code>string</code> name of step to insert</p>
</td></tr>
<tr><td><code id="pipe_insert_after_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="#topic+pipe_add">pipe_add()</a></code></p>
</td></tr>
<tr><td><code id="pipe_insert_after_+3A_beforestep">beforeStep</code></td>
<td>
<p><code>string</code> name of step before which to insert</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the <code>Pipeline</code> object invisibly
</p>


<h3>Methods</h3>


<ul>
<li> <p><code>pipe_insert_after</code>: insert step after a certain step of the pipeline
</p>
</li>
<li> <p><code>pipe_insert_before</code>: insert step before a certain step of the pipeline
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># pipe_insert_after
p &lt;- pipe_new("pipe", data = 1)
pipe_add(p, "f1", \(x = 1) x)
pipe_add(p, "f2", \(x = ~f1) x)
pipe_insert_after(p, "f1", step = "after_f1", \(x = ~f1) x)
p

# insert_before
pipe_insert_before(p, "f2", step = "before_f2", \(x = ~f1) 2 * x)
p
</code></pre>

<hr>
<h2 id='pipe_length'>Length of the pipeline</h2><span id='topic+pipe_length'></span>

<h3>Description</h3>

<p>Length of the pipeline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_length(pip)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pipe_length_+3A_pip">pip</code></td>
<td>
<p><code>Pipeline</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code> length of pipeline, that is, the total number of steps
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- pipe_new("pipe", data = 1:2)
pipe_add(p, "f1", \(x = 1) x)
pipe_add(p, "f2", \(y = 1) y)
p
pipe_length(p)
</code></pre>

<hr>
<h2 id='pipe_lock_step'>Lock steps</h2><span id='topic+pipe_lock_step'></span><span id='topic+pipe_unlock_step'></span>

<h3>Description</h3>

<p>Locking a step means that both its parameters and its
output (given it has output) are locked such that neither
setting new pipeline parameters nor future pipeline runs can change
the current parameter and output content. To unlock a locked step,
use <code><a href="#topic+pipe_unlock_step">pipe_unlock_step()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_lock_step(pip, step)

pipe_unlock_step(pip, step)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pipe_lock_step_+3A_pip">pip</code></td>
<td>
<p><code>Pipeline</code> object</p>
</td></tr>
<tr><td><code id="pipe_lock_step_+3A_step">step</code></td>
<td>
<p><code>string</code> name of step to lock or unlock</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>Pipeline</code> object invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'># pipe_lock_step
p &lt;- pipe_new("pipe", data = 1)
pipe_add(p, "add1", \(x = 1, data = ~data) x + data)
pipe_add(p, "add2", \(x = 1, data = ~data) x + data)
pipe_run(p)
pipe_get_out(p, "add1")
pipe_get_out(p, "add2")
pipe_lock_step(p, "add1")

pipe_set_data(p, 3)
pipe_set_params(p, list(x = 3))
pipe_run(p)
pipe_get_out(p, "add1")
pipe_get_out(p, "add2")

# pipe_unlock_step
pipe_unlock_step(p, "add1")
pipe_set_params(p, list(x = 3))
pipe_run(p)
pipe_get_out(p, "add1")
</code></pre>

<hr>
<h2 id='pipe_new'>Create new pipeline</h2><span id='topic+pipe_new'></span>

<h3>Description</h3>

<p>A new pipeline is always initialized with one 'data' step,
which basically is a function returning the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_new(name, data = NULL, logger = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pipe_new_+3A_name">name</code></td>
<td>
<p>the name of the Pipeline</p>
</td></tr>
<tr><td><code id="pipe_new_+3A_data">data</code></td>
<td>
<p>optional data used at the start of the pipeline. The
data also can be set later using the <code><a href="#topic+pipe_set_data">pipe_set_data()</a></code> function.</p>
</td></tr>
<tr><td><code id="pipe_new_+3A_logger">logger</code></td>
<td>
<p>custom logger to be used for logging. If no logger
is provided, the default logger is used, which should be sufficient
for most use cases.
If you do want to use your own custom log function, you need to
provide a function that obeys the following form:
</p>
<p><code style="white-space: pre;">&#8288;function(level, msg, ...) { your custom logging code here }&#8288;</code>
</p>
<p>The <code>level</code> argument is a string and will be one of <code>info</code>, <code>warn</code>,
or <code>error</code>. The <code>msg</code> argument is a string containing the message
to be logged. The <code>...</code> argument is a list of named parameters,
which can be used to add additional information to the log message.
Currently, this is only used to add the context in case of a step
giving a warning or error.
</p>
<p>Note that with the default logger, the log layout can be altered
any time via <code><a href="#topic+set_log_layout">set_log_layout()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the <code>Pipeline</code> object invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(x = 1:2, y = 3:4)
p &lt;- pipe_new("myPipe", data = data)
p |&gt; pipe_run() |&gt; pipe_get_out("data")

# Setting data later
p &lt;- pipe_new("myPipe")
pipe_get_data(p)

p &lt;- pipe_set_data(p, data)
pipe_get_data(p)
p |&gt; pipe_run() |&gt; pipe_get_out("data")

# Initialize with custom logger
my_logger &lt;- function(level, msg, ...) {
   cat(level, msg, "\n")
}
p &lt;- pipe_new("myPipe", data = data, logger = my_logger)
p |&gt; pipe_run() |&gt; pipe_get_out("data")
</code></pre>

<hr>
<h2 id='pipe_pop_step'>Pop steps from the pipeline</h2><span id='topic+pipe_pop_step'></span><span id='topic+pipe_pop_steps_after'></span><span id='topic+pipe_pop_steps_from'></span>

<h3>Description</h3>

<p>Use this function to drop steps from the end of the pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_pop_step(pip)

pipe_pop_steps_after(pip, step)

pipe_pop_steps_from(pip, step)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pipe_pop_step_+3A_pip">pip</code></td>
<td>
<p><code>Pipeline</code> object</p>
</td></tr>
<tr><td><code id="pipe_pop_step_+3A_step">step</code></td>
<td>
<p><code>string</code> name of step</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>string</code> the name of the step that was removed
</p>


<h3>Methods</h3>


<ul>
<li> <p><code>pipe_pop_step</code>: drop last step from the pipeline
</p>
</li>
<li> <p><code>pipe_pop_steps_after</code>: drop all steps after given steps
</p>
</li>
<li> <p><code>pipe_pop_steps_from</code>: drop all steps from and including given steps
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># pipe_pop_step
p &lt;- pipe_new("pipe", data = 1:2)
pipe_add(p, "f1", \(x = 1) x)
pipe_add(p, "f2", \(y = 1) y)
p
pipe_pop_step(p)
p

# pipe_pop_steps_after
pipe_add(p, "f2", \(y = 1) y)
pipe_add(p, "f3", \(z = 1) z)
p
pipe_pop_steps_after(p, "f1")
p

# pipe_pop_steps_from
pipe_add(p, "f2", \(y = 1) y)
pipe_add(p, "f3", \(z = 1) z)
p
pipe_pop_steps_from(p, "f1")
p
</code></pre>

<hr>
<h2 id='pipe_print'>Print the pipeline as a table</h2><span id='topic+pipe_print'></span>

<h3>Description</h3>

<p>Print the pipeline as a table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_print(pip, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pipe_print_+3A_pip">pip</code></td>
<td>
<p><code>Pipeline</code> object</p>
</td></tr>
<tr><td><code id="pipe_print_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> if <code>TRUE</code>, print all columns of the
pipeline, otherwise only the most relevant columns are displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>Pipeline</code> object invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- pipe_new("pipe", data = 1:2)
p$add("f1", \(x = 1) x)
p$add("f2", \(y = 1) y)
pipe_print(p)
pipe_print(p, verbose = TRUE)

# Also works with standard print function
print(p)
print(p, verbose = TRUE)
</code></pre>

<hr>
<h2 id='pipe_remove_step'>Remove certain step from the pipeline.</h2><span id='topic+pipe_remove_step'></span>

<h3>Description</h3>

<p>Can be used to remove any given step.
If other steps depend on the step to be removed, an error is
given and the removal is blocked, unless <code>recursive</code> was set to <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_remove_step(pip, step, recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pipe_remove_step_+3A_pip">pip</code></td>
<td>
<p><code>Pipeline</code> object</p>
</td></tr>
<tr><td><code id="pipe_remove_step_+3A_step">step</code></td>
<td>
<p><code>string</code> the name of the step to be removed</p>
</td></tr>
<tr><td><code id="pipe_remove_step_+3A_recursive">recursive</code></td>
<td>
<p><code>logical</code> if <code>TRUE</code> the step is removed together
with all its downstream dependencies.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>Pipeline</code> object invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- pipe_new("pipe", data = 1:2)
pipe_add(p, "add1", \(data = ~data, x = 1) x + data)
pipe_add(p, "add2", \(x = 1, y = ~add1) x + y)
pipe_add(p, "mult1", \(x = 1, y = ~add2) x * y)
p

pipe_remove_step(p, "mult1")
p

try(pipe_remove_step(p, "add1"))
pipe_remove_step(p, "add1", recursive = TRUE)
p
</code></pre>

<hr>
<h2 id='pipe_rename_step'>Rename step</h2><span id='topic+pipe_rename_step'></span>

<h3>Description</h3>

<p>Safely rename a step in the pipeline. If new step
name would result in a name clash, an error is given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_rename_step(pip, from, to)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pipe_rename_step_+3A_pip">pip</code></td>
<td>
<p><code>Pipeline</code> object</p>
</td></tr>
<tr><td><code id="pipe_rename_step_+3A_from">from</code></td>
<td>
<p><code>string</code> the name of the step to be renamed.</p>
</td></tr>
<tr><td><code id="pipe_rename_step_+3A_to">to</code></td>
<td>
<p><code>string</code> the new name of the step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>Pipeline</code> object invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- pipe_new("pipe", data = 1:2)
pipe_add(p, "add1", \(data = ~data, x = 1) x + data)
pipe_add(p, "add2", \(x = 1, y = ~add1) x + y)
p

try(pipe_rename_step(p, from = "add1", to = "add2"))

pipe_rename_step(p, from = "add1", to = "first_add")
p
</code></pre>

<hr>
<h2 id='pipe_replace_step'>Replace pipeline step</h2><span id='topic+pipe_replace_step'></span>

<h3>Description</h3>

<p>Replaces an existing pipeline step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_replace_step(
  pip,
  step,
  fun,
  params = list(),
  description = "",
  group = step,
  keepOut = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pipe_replace_step_+3A_pip">pip</code></td>
<td>
<p><code>Pipeline</code> object</p>
</td></tr>
<tr><td><code id="pipe_replace_step_+3A_step">step</code></td>
<td>
<p><code>string</code> the name of the step. Each step name must
be unique.</p>
</td></tr>
<tr><td><code id="pipe_replace_step_+3A_fun">fun</code></td>
<td>
<p><code>function</code> or name of the function to be applied at
the step. Both existing and anonymous/lambda functions can be used.
All function parameters must have default values. If a parameter
is missing a default value in the function signature, alternatively,
it can be set via the <code>params</code> argument (see Examples section with
<code><a href="base.html#topic+mean">mean()</a></code> function).</p>
</td></tr>
<tr><td><code id="pipe_replace_step_+3A_params">params</code></td>
<td>
<p><code>list</code> list of parameters to set or overwrite
parameters of the passed function.</p>
</td></tr>
<tr><td><code id="pipe_replace_step_+3A_description">description</code></td>
<td>
<p><code>string</code> optional description of the step</p>
</td></tr>
<tr><td><code id="pipe_replace_step_+3A_group">group</code></td>
<td>
<p><code>string</code> output collected after pipeline execution
(see function <code><a href="#topic+pipe_collect_out">pipe_collect_out()</a></code>) is grouped by the defined group
names. By default, this is the name of the step, which comes in
handy when the pipeline is copy-appended multiple times to keep
the results of the same function/step grouped at one place.</p>
</td></tr>
<tr><td><code id="pipe_replace_step_+3A_keepout">keepOut</code></td>
<td>
<p><code>logical</code> if <code>FALSE</code> (default) the output of the
step is not collected when calling <code><a href="#topic+pipe_collect_out">pipe_collect_out()</a></code> after the
pipeline run. This option is used to only keep the results that matter
and skip intermediate results that are not needed. See also
function <code><a href="#topic+pipe_collect_out">pipe_collect_out()</a></code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the <code>Pipeline</code> object invisibly
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pipe_add">pipe_add()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- pipe_new("pipe", data = 1)
pipe_add(p, "add1", \(x = ~data, y = 1) x + y)
pipe_add(p, "add2", \(x = ~data, y = 2) x + y)
pipe_add(p, "mult", \(x = 1, y = 2) x * y, keepOut = TRUE)
pipe_run(p) |&gt; pipe_collect_out()
pipe_replace_step(p, "mult", \(x = ~add1, y = ~add2) x * y, keepOut = TRUE)
pipe_run(p) |&gt; pipe_collect_out()
try(pipe_replace_step(p, "foo", \(x = 1) x))   # step 'foo' does not exist
</code></pre>

<hr>
<h2 id='pipe_reset'>Reset pipeline</h2><span id='topic+pipe_reset'></span>

<h3>Description</h3>

<p>Resets the pipeline to the state before it was run.
This means that all output is removed and the state of all steps
is reset to 'New'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_reset(pip)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pipe_reset_+3A_pip">pip</code></td>
<td>
<p><code>Pipeline</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the <code>Pipeline</code> object invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- pipe_new("pipe", data = 1:2)
pipe_add(p, "f1", \(x = 1) x)
pipe_add(p, "f2", \(y = 1) y)
pipe_run(p, )
p

pipe_reset(p)
p
</code></pre>

<hr>
<h2 id='pipe_run'>Run pipeline</h2><span id='topic+pipe_run'></span>

<h3>Description</h3>

<p>Runs all new and/or outdated pipeline steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_run(
  pip,
  force = FALSE,
  recursive = TRUE,
  cleanUnkept = FALSE,
  progress = NULL,
  showLog = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pipe_run_+3A_pip">pip</code></td>
<td>
<p><code>Pipeline</code> object</p>
</td></tr>
<tr><td><code id="pipe_run_+3A_force">force</code></td>
<td>
<p><code>logical</code> if <code>TRUE</code> all steps are run regardless of
whether they are outdated or not.</p>
</td></tr>
<tr><td><code id="pipe_run_+3A_recursive">recursive</code></td>
<td>
<p><code>logical</code> if <code>TRUE</code> and a step returns a new
pipeline, the run of the current pipeline is aborted and the
new pipeline is run recursively.</p>
</td></tr>
<tr><td><code id="pipe_run_+3A_cleanunkept">cleanUnkept</code></td>
<td>
<p><code>logical</code> if <code>TRUE</code> all output that was not
marked to be kept is removed after the pipeline run. This option
can be useful if temporary results require a lot of memory.</p>
</td></tr>
<tr><td><code id="pipe_run_+3A_progress">progress</code></td>
<td>
<p><code>function</code> this parameter can be used to provide a
custom progress function of the form <code style="white-space: pre;">&#8288;function(value, detail)&#8288;</code>,
which will show the progress of the pipeline run for each step,
where <code>value</code> is the current step number and <code>detail</code> is the name
of the step.</p>
</td></tr>
<tr><td><code id="pipe_run_+3A_showlog">showLog</code></td>
<td>
<p><code>logical</code> should the steps be logged during the
pipeline run?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the <code>Pipeline</code> object invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple pipeline
p &lt;- pipe_new("pipe", data = 1)
pipe_add(p, "add1", \(x = ~data, y = 1) x + y)
pipe_add(p, "add2", \(x = ~add1, z = 2) x + z)
pipe_add(p, "final", \(x = ~add1, y = ~add2) x * y, keepOut = TRUE)
p |&gt; pipe_run() |&gt; pipe_collect_out()
pipe_set_params(p, list(z = 4))  # outdates steps add2 and final
p

p |&gt; pipe_run() |&gt; pipe_collect_out()

pipe_run(p, cleanUnkept = TRUE)
p

# Recursive pipeline (for advanced users)
p &lt;- pipe_new("pipe", data = 1)
pipe_add(p, "add1", \(x = ~data, y = 1) x + y)
pipe_add(p, "new_pipe", \(x = ~add1) {
    p2 &lt;- pipe_new("new_pipe", data = x)
    pipe_add(p2, "add1", \(x = ~data) x + 1)
    pipe_add(p2, "add2", \(x = ~add1) x + 2, keepOut = TRUE)
  }
)
p |&gt; pipe_run() |&gt; pipe_collect_out()

# Run pipeline with progress bar
p &lt;- pipe_new("pipe", data = 1)
pipe_add(p, "first step", \() Sys.sleep(0.5))
pipe_add(p, "second step", \() Sys.sleep(0.5))
pipe_add(p, "last step", \() Sys.sleep(0.5))
pb &lt;- txtProgressBar(min = 1, max = pipe_length(p), style = 3)
fprogress &lt;- function(value, detail) {
   setTxtProgressBar(pb, value)
}
pipe_run(p, progress = fprogress, showLog = FALSE)
</code></pre>

<hr>
<h2 id='pipe_run_step'>Run specific step</h2><span id='topic+pipe_run_step'></span>

<h3>Description</h3>

<p>Run given pipeline step possibly together with
upstream and/or downstream dependencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_run_step(
  pip,
  step,
  upstream = TRUE,
  downstream = FALSE,
  cleanUnkept = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pipe_run_step_+3A_pip">pip</code></td>
<td>
<p><code>Pipeline</code> object</p>
</td></tr>
<tr><td><code id="pipe_run_step_+3A_step">step</code></td>
<td>
<p><code>string</code> name of step</p>
</td></tr>
<tr><td><code id="pipe_run_step_+3A_upstream">upstream</code></td>
<td>
<p><code>logical</code> if <code>TRUE</code>, run all dependent upstream
steps first.</p>
</td></tr>
<tr><td><code id="pipe_run_step_+3A_downstream">downstream</code></td>
<td>
<p><code>logical</code> if <code>TRUE</code>, run all depdendent
downstream afterwards.</p>
</td></tr>
<tr><td><code id="pipe_run_step_+3A_cleanunkept">cleanUnkept</code></td>
<td>
<p><code>logical</code> if <code>TRUE</code> all output that was not
marked to be kept is removed after the pipeline run. This option
can be useful if temporary results require a lot of memory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the <code>Pipeline</code> object invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- pipe_new("pipe", data = 1)
pipe_add(p, "add1", \(x = ~data, y = 1) x + y)
pipe_add(p, "add2", \(x = ~add1, z = 2) x + z)
pipe_add(p, "mult", \(x = ~add1, y = ~add2) x * y)
pipe_run_step(p, "add2")

pipe_run_step(p, "add2", downstream = TRUE)

pipe_run_step(p, "mult", upstream = TRUE)
</code></pre>

<hr>
<h2 id='pipe_set_data'>Set data</h2><span id='topic+pipe_set_data'></span>

<h3>Description</h3>

<p>Set data in first step of pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_set_data(pip, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pipe_set_data_+3A_pip">pip</code></td>
<td>
<p><code>Pipeline</code> object</p>
</td></tr>
<tr><td><code id="pipe_set_data_+3A_data">data</code></td>
<td>
<p>initial data set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the <code>Pipeline</code> object invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- pipe_new("pipe", data = 1)
pipe_add(p, "add1", \(x = ~data, y = 1) x + y, keepOut = TRUE)
p |&gt; pipe_run() |&gt; pipe_collect_out()

pipe_set_data(p, 3)
p |&gt; pipe_run() |&gt; pipe_collect_out()
</code></pre>

<hr>
<h2 id='pipe_set_data_split'>Split-multiply pipeline by list of data sets</h2><span id='topic+pipe_set_data_split'></span>

<h3>Description</h3>

<p>This function can be used to apply the pipeline
repeatedly to various data sets. For this, the pipeline split-copies
itself by the list of given data sets. Each sub-pipeline will have
one of the data sets set as input data.
The step names of the sub-pipelines will be the original
step names plus the name of the data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_set_data_split(
  pip,
  dataList,
  toStep = character(),
  groupBySplit = TRUE,
  sep = "."
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pipe_set_data_split_+3A_pip">pip</code></td>
<td>
<p><code>Pipeline</code> object</p>
</td></tr>
<tr><td><code id="pipe_set_data_split_+3A_datalist">dataList</code></td>
<td>
<p><code>list</code> of data sets</p>
</td></tr>
<tr><td><code id="pipe_set_data_split_+3A_tostep">toStep</code></td>
<td>
<p><code>string</code> step name marking optional subset of
the pipeline, to which the data split should be applied to.</p>
</td></tr>
<tr><td><code id="pipe_set_data_split_+3A_groupbysplit">groupBySplit</code></td>
<td>
<p><code>logical</code> whether to set step groups according
to data split.</p>
</td></tr>
<tr><td><code id="pipe_set_data_split_+3A_sep">sep</code></td>
<td>
<p><code>string</code> separator to be used between step name and
data set name when creating the new step names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>new combined <code>Pipeline</code> with each sub-pipeline having set
one of the data sets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Split by three data sets
dataList &lt;- list(a = 1, b = 2, c = 3)
p &lt;- pipe_new("pipe")
pipe_add(p, "add1", \(x = ~data) x + 1, keepOut = TRUE)
pipe_add(p, "mult", \(x = ~data, y = ~add1) x * y, keepOut = TRUE)
pipe_set_data_split(p, dataList)
p

p |&gt; pipe_run() |&gt; pipe_collect_out() |&gt; str()

# Don't group output by split
p &lt;- pipe_new("pipe")
pipe_add(p, "add1", \(x = ~data) x + 1, keepOut = TRUE)
pipe_add(p, "mult", \(x = ~data, y = ~add1) x * y, keepOut = TRUE)
pipe_set_data_split(p, dataList, groupBySplit = FALSE)
p

p |&gt; pipe_run() |&gt; pipe_collect_out() |&gt; str()

# Split up to certain step
p &lt;- pipe_new("pipe")
pipe_add(p, "add1", \(x = ~data) x + 1)
pipe_add(p, "mult", \(x = ~data, y = ~add1) x * y)
pipe_add(p, "average_result", \(x = ~mult) mean(unlist(x)), keepOut = TRUE)
p
pipe_get_depends(p)[["average_result"]]

pipe_set_data_split(p, dataList, toStep = "mult")
p
pipe_get_depends(p)[["average_result"]]

p |&gt; pipe_run() |&gt; pipe_collect_out() |&gt; str()
</code></pre>

<hr>
<h2 id='pipe_set_keep_out'>Change output flag</h2><span id='topic+pipe_set_keep_out'></span>

<h3>Description</h3>

<p>Change the <code>keepOut</code> flag at a given pipeline step,
which determines whether the output of that step is collected
when calling <code><a href="#topic+pipe_collect_out">pipe_collect_out()</a></code><code style="white-space: pre;">&#8288;after the pipeline was run. See column&#8288;</code>keepOut' when printing a pipeline to view the status.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_set_keep_out(pip, step, keepOut = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pipe_set_keep_out_+3A_pip">pip</code></td>
<td>
<p><code>Pipeline</code> object</p>
</td></tr>
<tr><td><code id="pipe_set_keep_out_+3A_step">step</code></td>
<td>
<p><code>string</code> name of step</p>
</td></tr>
<tr><td><code id="pipe_set_keep_out_+3A_keepout">keepOut</code></td>
<td>
<p><code>logical</code> whether to keep output of step</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>Pipeline</code> object invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- pipe_new("pipe", data = 1)
pipe_add(p, "add1", \(x = ~data, y = 1) x + y, keepOut = TRUE)
pipe_add(p, "add2", \(x = ~data, y = 2) x + y)
pipe_add(p, "mult", \(x = ~add1, y = ~add2) x * y)
p |&gt; pipe_run() |&gt; pipe_collect_out()

pipe_set_keep_out(p, "add1", keepOut = FALSE)
pipe_set_keep_out(p, "mult", keepOut = TRUE)
p |&gt; pipe_run() |&gt; pipe_collect_out()
</code></pre>

<hr>
<h2 id='pipe_set_params'>Set pipeline parameters</h2><span id='topic+pipe_set_params'></span>

<h3>Description</h3>

<p>Set unbound function parameters defined in
the pipeline where 'unbound' means parameters that are not linked
to other steps. Trying to set parameters that don't exist in
the pipeline is ignored, by default, with a warning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_set_params(pip, params, warnUndefined = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pipe_set_params_+3A_pip">pip</code></td>
<td>
<p><code>Pipeline</code> object</p>
</td></tr>
<tr><td><code id="pipe_set_params_+3A_params">params</code></td>
<td>
<p><code>list</code> of parameters to be set</p>
</td></tr>
<tr><td><code id="pipe_set_params_+3A_warnundefined">warnUndefined</code></td>
<td>
<p><code>logical</code> whether to give a warning when trying
to set a parameter that is not defined in the pipeline.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the <code>Pipeline</code> object invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- pipe_new("pipe", data = 1)
pipe_add(p, "add1", \(x = ~data, y = 2) x + y)
pipe_add(p, "add2", \(x = ~data, y = 3) x + y)
pipe_add(p, "mult", \(x = 4, z = 5) x * z)
pipe_get_params(p)
pipe_set_params(p, params = list(x = 3, y = 3))
pipe_get_params(p)
pipe_set_params(p, params = list(x = 5, z = 3))
pipe_get_params(p)

suppressWarnings(
  pipe_set_params(p, list(foo = 3)) # gives warning as 'foo' is undefined
)
pipe_set_params(p, list(foo = 3), warnUndefined = FALSE)
</code></pre>

<hr>
<h2 id='pipe_set_params_at_step'>Set parameters at step</h2><span id='topic+pipe_set_params_at_step'></span>

<h3>Description</h3>

<p>Set unbound function parameters defined at given pipeline
step where 'unbound' means parameters that are not linked to other
steps. If one or more parameters don't exist, an error is given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_set_params_at_step(pip, step, params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pipe_set_params_at_step_+3A_pip">pip</code></td>
<td>
<p><code>Pipeline</code> object</p>
</td></tr>
<tr><td><code id="pipe_set_params_at_step_+3A_step">step</code></td>
<td>
<p><code>string</code> the name of the step</p>
</td></tr>
<tr><td><code id="pipe_set_params_at_step_+3A_params">params</code></td>
<td>
<p><code>list</code> of parameters to be set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the <code>Pipeline</code> object invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- pipe_new("pipe", data = 1)
pipe_add(p, "add1", \(x = ~data, y = 2, z = 3) x + y)
pipe_set_params_at_step(p, step = "add1", params = list(y = 5, z = 6))
pipe_get_params(p)

try(
  pipe_set_params_at_step(p, step = "add1", params = list(foo = 3))
)
</code></pre>

<hr>
<h2 id='pipe_split'>Split-up pipeline</h2><span id='topic+pipe_split'></span>

<h3>Description</h3>

<p>Splits pipeline into its independent parts. This can be useful,
for example, to split-up the pipeline in order to run each part in parallel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_split(pip)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pipe_split_+3A_pip">pip</code></td>
<td>
<p><code>Pipeline</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of <code>Pipeline</code> objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example for two independent calculation paths
p &lt;- pipe_new("pipe", data = 1)
pipe_add(p, "f1", \(x = ~data) x)
pipe_add(p, "f2", \(x = 1) x)
pipe_add(p, "f3", \(x = ~f1) x)
pipe_add(p, "f4", \(x = ~f2) x)
pipe_split(p)

# Example of split by three data sets
dataList &lt;- list(a = 1, b = 2, c = 3)
p &lt;- pipe_new("pipe")
pipe_add(p, "add1", \(x = ~data) x + 1, keepOut = TRUE)
pipe_add(p, "mult", \(x = ~data, y = ~add1) x * y, keepOut = TRUE)
pipes &lt;- pipe_set_data_split(p, dataList) |&gt; pipe_split()
pipes
</code></pre>

<hr>
<h2 id='Pipeline'>Pipeline Class</h2><span id='topic+Pipeline'></span>

<h3>Description</h3>

<p>This class implements an analysis pipeline. A pipeline consists
of a sequence of analysis steps, which can be added one by one. Each added
step may or may not depend on one or more previous steps. The pipeline
keeps track of the dependencies among these steps and will ensure that
all dependencies are met on creation of the pipeline, that is, before the
the pipeline is run. Once the pipeline is run, the output is
stored in the pipeline along with each step and can be accessed later.
Different pipelines can be bound together while preserving all dependencies
within each pipeline.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>name</code></dt><dd><p><code>string</code> name of the pipeline</p>
</dd>
<dt><code>pipeline</code></dt><dd><p><code>data.table</code> the pipeline where each row represents one step.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Pipeline-new"><code>Pipeline$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-add"><code>Pipeline$add()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-append"><code>Pipeline$append()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-append_to_step_names"><code>Pipeline$append_to_step_names()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-collect_out"><code>Pipeline$collect_out()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-discard_steps"><code>Pipeline$discard_steps()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-get_data"><code>Pipeline$get_data()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-get_depends"><code>Pipeline$get_depends()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-get_depends_down"><code>Pipeline$get_depends_down()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-get_depends_up"><code>Pipeline$get_depends_up()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-get_graph"><code>Pipeline$get_graph()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-get_out"><code>Pipeline$get_out()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-get_params"><code>Pipeline$get_params()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-get_params_at_step"><code>Pipeline$get_params_at_step()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-get_params_unique"><code>Pipeline$get_params_unique()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-get_params_unique_json"><code>Pipeline$get_params_unique_json()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-get_step"><code>Pipeline$get_step()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-get_step_names"><code>Pipeline$get_step_names()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-get_step_number"><code>Pipeline$get_step_number()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-has_step"><code>Pipeline$has_step()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-insert_after"><code>Pipeline$insert_after()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-insert_before"><code>Pipeline$insert_before()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-length"><code>Pipeline$length()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-lock_step"><code>Pipeline$lock_step()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-pop_step"><code>Pipeline$pop_step()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-pop_steps_after"><code>Pipeline$pop_steps_after()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-pop_steps_from"><code>Pipeline$pop_steps_from()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-print"><code>Pipeline$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-remove_step"><code>Pipeline$remove_step()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-rename_step"><code>Pipeline$rename_step()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-replace_step"><code>Pipeline$replace_step()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-reset"><code>Pipeline$reset()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-run"><code>Pipeline$run()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-run_step"><code>Pipeline$run_step()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-set_data"><code>Pipeline$set_data()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-set_data_split"><code>Pipeline$set_data_split()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-set_keep_out"><code>Pipeline$set_keep_out()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-set_params"><code>Pipeline$set_params()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-set_params_at_step"><code>Pipeline$set_params_at_step()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-split"><code>Pipeline$split()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-unlock_step"><code>Pipeline$unlock_step()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-clone"><code>Pipeline$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Pipeline-new"></a>



<h4>Method <code>new()</code></h4>

<p>constructor
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$new(name, data = NULL, logger = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>the name of the Pipeline</p>
</dd>
<dt><code>data</code></dt><dd><p>optional data used at the start of the pipeline. The
data also can be set later using the <code>set_data</code> function.</p>
</dd>
<dt><code>logger</code></dt><dd><p>custom logger to be used for logging. If no logger
is provided, the default logger is used, which should be sufficient
for most use cases.
If you do want to use your own custom log function, you need to
provide a function that obeys the following form:
</p>
<p><code style="white-space: pre;">&#8288;function(level, msg, ...) { your custom logging code here }&#8288;</code>
</p>
<p>The <code>level</code> argument is a string and will be one of <code>info</code>, <code>warn</code>,
or <code>error</code>. The <code>msg</code> argument is a string containing the message
to be logged. The <code>...</code> argument is a list of named parameters,
which can be used to add additional information to the log message.
Currently, this is only used to add the context in case of a step
giving a warning or error.
</p>
<p>Note that with the default logger, the log layout can be altered
any time via <code><a href="#topic+set_log_layout">set_log_layout()</a></code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>returns the <code>Pipeline</code> object invisibly
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("myPipe", data = data.frame(x = 1:8))
p

# Passing custom logger
my_logger &lt;- function(level, msg, ...) {
   cat(level, msg, "\n")
}
p &lt;- Pipeline$new("myPipe", logger = my_logger)
</pre>
</div>


<hr>
<a id="method-Pipeline-add"></a>



<h4>Method <code>add()</code></h4>

<p>Add pipeline step
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$add(
  step,
  fun,
  params = list(),
  description = "",
  group = step,
  keepOut = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>step</code></dt><dd><p><code>string</code> the name of the step. Each step name must
be unique.</p>
</dd>
<dt><code>fun</code></dt><dd><p><code>function</code> or name of the function to be applied at
the step. Both existing and anonymous/lambda functions can be used.
All function parameters must have default values. If a parameter
is missing a default value in the function signature, alternatively,
it can be set via the <code>params</code> argument (see Examples section with
<code><a href="base.html#topic+mean">mean()</a></code> function).</p>
</dd>
<dt><code>params</code></dt><dd><p><code>list</code> list of parameters to set or overwrite
parameters of the passed function.</p>
</dd>
<dt><code>description</code></dt><dd><p><code>string</code> optional description of the step</p>
</dd>
<dt><code>group</code></dt><dd><p><code>string</code> output collected after pipeline execution
(see function <code>collect_out</code>) is grouped by the defined group
names. By default, this is the name of the step, which comes in
handy when the pipeline is copy-appended multiple times to keep
the results of the same function/step grouped at one place.</p>
</dd>
<dt><code>keepOut</code></dt><dd><p><code>logical</code> if <code>FALSE</code> (default) the output of the
step is not collected when calling <code>collect_out</code> after the pipeline
run. This option is used to only keep the results that matter
and skip intermediate results that are not needed. See also
function <code>collect_out</code> for more details.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>returns the <code>Pipeline</code> object invisibly
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Add steps with lambda functions
p &lt;- Pipeline$new("myPipe", data = 1)
p$add("s1", \(x = ~data) 2*x)  # use input data
p$add("s2", \(x = ~data, y = ~s1) x * y)
try(p$add("s2", \(z = 3) 3)) # error: step 's2' exists already
try(p$add("s3", \(z = ~foo) 3)) # dependency 'foo' not found
p

# Add step with existing function
p &lt;- Pipeline$new("myPipe", data = c(1, 2, NA, 3, 4))
p$add("calc_mean", mean, params = list(x = ~data, na.rm = TRUE))
p$run()$get_out("calc_mean")

# Step description
p &lt;- Pipeline$new("myPipe", data = 1:10)
p$add("s1", \(x = ~data) 2*x, description = "multiply by 2")
print(p)
print(p, verbose = TRUE) # print all columns

# Group output
p &lt;- Pipeline$new("myPipe", data = data.frame(x = 1:5, y = 1:5))
p$add("prep_x", \(data = ~data) data$x, group = "prep")
p$add("prep_y", \(data = ~data) (data$y)^2, group = "prep")
p$add("sum", \(x = ~prep_x, y = ~prep_y) x + y)
p$run()$collect_out(all = TRUE)
</pre>
</div>


<hr>
<a id="method-Pipeline-append"></a>



<h4>Method <code>append()</code></h4>

<p>Append another pipeline
When appending, <code>pipeflow</code> takes care of potential name clashes with
respect to step names and dependencies, that is, if needed, it will
automatically adapt step names and dependencies to make sure they
are unique in the merged pipeline.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$append(p, outAsIn = FALSE, tryAutofixNames = TRUE, sep = ".")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>p</code></dt><dd><p><code>Pipeline</code> object to be appended.</p>
</dd>
<dt><code>outAsIn</code></dt><dd><p><code>logical</code> if <code>TRUE</code>, output of first pipeline is used
as input for the second pipeline.</p>
</dd>
<dt><code>tryAutofixNames</code></dt><dd><p><code>logical</code> if <code>TRUE</code>, name clashes are tried
to be automatically resolved by appending the 2nd pipeline's name.
Only set to <code>FALSE</code>, if you know what you are doing.</p>
</dd>
<dt><code>sep</code></dt><dd><p><code>string</code> separator used when auto-resolving step names</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>returns new combined <code>Pipeline</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Append pipeline
p1 &lt;- Pipeline$new("pipe1")
p1$add("step1", \(x = 1) x)
p2 &lt;- Pipeline$new("pipe2")
p2$add("step2", \(y = 1) y)
p1$append(p2)

# Append pipeline with potential name clashes
p3 &lt;- Pipeline$new("pipe3")
p3$add("step1", \(z = 1) z)
p1$append(p2)$append(p3)

# Use output of first pipeline as input for second pipeline
p1 &lt;- Pipeline$new("pipe1", data = 8)
p2 &lt;- Pipeline$new("pipe2")
p1$add("square", \(x = ~data) x^2)
p2$add("log2", \(x = ~data) log2(x))

p12 &lt;- p1$append(p2, outAsIn = TRUE)
p12$run()$get_out("log2")
p12

# Custom name separator
p1$append(p2, sep = "___")
</pre>
</div>


<hr>
<a id="method-Pipeline-append_to_step_names"></a>



<h4>Method <code>append_to_step_names()</code></h4>

<p>Appends string to all step names and takes care
of updating step dependencies accordingly.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$append_to_step_names(postfix, sep = ".")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>postfix</code></dt><dd><p><code>string</code> to be appended to each step name.</p>
</dd>
<dt><code>sep</code></dt><dd><p><code>string</code> separator between step name and postfix.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>returns the <code>Pipeline</code> object invisibly
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe")
p$add("step1", \(x = 1) x)
p$add("step2", \(y = 1) y)
p$append_to_step_names("new")
p
p$append_to_step_names("foo", sep = "__")
p
</pre>
</div>


<hr>
<a id="method-Pipeline-collect_out"></a>



<h4>Method <code>collect_out()</code></h4>

<p>Collect output afer pipeline run, by default, from all
steps for which <code>keepOut</code> was set to <code>TRUE</code>. The output is grouped
by the group names (see <code>group</code> parameter in function <code>add</code>),
which by default are set identical to the step names.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$collect_out(groupBy = "group", all = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>groupBy</code></dt><dd><p><code>string</code> column of pipeline by which to group the
output.</p>
</dd>
<dt><code>all</code></dt><dd><p><code>logical</code> if <code>TRUE</code> all output is collected
regardless of the <code>keepOut</code> flag. This can be useful for debugging.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>list</code> containing the output, named after the groups, which,
by default, are the steps.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("step1", \(x = ~data) x + 2)
p$add("step2", \(x = ~step1) x + 2, keepOut = TRUE)
p$run()
p$collect_out()
p$collect_out(all = TRUE) |&gt; str()

# Grouped output
p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("step1", \(x = ~data) x + 2, group = "add")
p$add("step2", \(x = ~step1, y = 2) x + y, group = "add")
p$add("step3", \(x = ~data) x * 3, group = "mult")
p$add("step4", \(x = ~data, y = 2) x * y, group = "mult")
p
p$run()
p$collect_out(all = TRUE) |&gt; str()

# Grouped by state
p$set_params(list(y = 5))
p
p$collect_out(groupBy = "state", all = TRUE) |&gt; str()
</pre>
</div>


<hr>
<a id="method-Pipeline-discard_steps"></a>



<h4>Method <code>discard_steps()</code></h4>

<p>Discard all steps that match a given <code>pattern</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$discard_steps(pattern, recursive = FALSE, fixed = TRUE, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>pattern</code></dt><dd><p><code>string</code> containing a regular expression (or
character string for <code>fixed = TRUE</code>) to be matched.</p>
</dd>
<dt><code>recursive</code></dt><dd><p><code>logical</code> if <code>TRUE</code> the step is removed together
with all its downstream dependencies.</p>
</dd>
<dt><code>fixed</code></dt><dd><p><code>logical</code> If <code>TRUE</code>, <code>pattern</code> is a string to
be matched as is. Overrides all conflicting arguments.</p>
</dd>
<dt><code>...</code></dt><dd><p>further arguments passed to <code><a href="base.html#topic+grep">grep()</a></code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the <code>Pipeline</code> object invisibly
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("add1", \(x = ~data) x + 1)
p$add("add2", \(x = ~add1) x + 2)
p$add("mult3", \(x = ~add1) x * 3)
p$add("mult4", \(x = ~add2) x * 4)
p

p$discard_steps("mult")
p

# Re-add steps
p$add("mult3", \(x = ~add1) x * 3)
p$add("mult4", \(x = ~add2) x * 4)
p
# Discarding 'add1' does not work ...
try(p$discard_steps("add1"))

# ... unless we enforce to remove its downstream dependencies as well
p$discard_steps("add1", recursive = TRUE)   # this works
p

# Trying to discard non-existent steps is just ignored
p$discard_steps("non-existent")
</pre>
</div>


<hr>
<a id="method-Pipeline-get_data"></a>



<h4>Method <code>get_data()</code></h4>

<p>Get data
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$get_data()</pre></div>



<h5>Returns</h5>

<p>the output defined in the <code>data</code> step, which by default is
the first step of the pipeline
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1:2)
p$get_data()
p$set_data(3:4)
p$get_data()
</pre>
</div>


<hr>
<a id="method-Pipeline-get_depends"></a>



<h4>Method <code>get_depends()</code></h4>

<p>Get all dependencies defined in the pipeline
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$get_depends()</pre></div>



<h5>Returns</h5>

<p>named <code>list</code> of dependencies for each step
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("add1", \(x = ~data) x + 1)
p$add("add2", \(x = ~data, y = ~add1) x + y)
p$get_depends()
</pre>
</div>


<hr>
<a id="method-Pipeline-get_depends_down"></a>



<h4>Method <code>get_depends_down()</code></h4>

<p>Get all downstream dependencies of given step, by
default descending recursively.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$get_depends_down(step, recursive = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>step</code></dt><dd><p><code>string</code> name of step</p>
</dd>
<dt><code>recursive</code></dt><dd><p><code>logical</code> if <code>TRUE</code>, dependencies of dependencies
are also returned.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>list</code> of downstream dependencies
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("add1", \(x = ~data) x + 1)
p$add("add2", \(x = ~data, y = ~add1) x + y)
p$add("mult3", \(x = ~add1) x * 3)
p$add("mult4", \(x = ~add2) x * 4)
p$get_depends_down("add1")
p$get_depends_down("add1", recursive = FALSE)
</pre>
</div>


<hr>
<a id="method-Pipeline-get_depends_up"></a>



<h4>Method <code>get_depends_up()</code></h4>

<p>Get all upstream dependencies of given step, by
default descending recursively.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$get_depends_up(step, recursive = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>step</code></dt><dd><p><code>string</code> name of step</p>
</dd>
<dt><code>recursive</code></dt><dd><p><code>logical</code> if <code>TRUE</code>, dependencies of dependencies
are also returned.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>list</code> of upstream dependencies
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("add1", \(x = ~data) x + 1)
p$add("add2", \(x = ~data, y = ~add1) x + y)
p$add("mult3", \(x = ~add1) x * 3)
p$add("mult4", \(x = ~add2) x * 4)
p$get_depends_up("mult4")
p$get_depends_up("mult4", recursive = FALSE)
</pre>
</div>


<hr>
<a id="method-Pipeline-get_graph"></a>



<h4>Method <code>get_graph()</code></h4>

<p>Visualize the pipeline as a graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$get_graph(groups = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>groups</code></dt><dd><p><code>character</code> if not <code>NULL</code>, only steps belonging to the
given groups are considered.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>two data frames, one for nodes and one for edges ready to be
used with the <code>visNetwork</code> package.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("add1", \(data = ~data, x = 1) x + data)
p$add("add2", \(x = 1, y = ~add1) x + y)
p$add("mult1", \(x = ~add1, y = ~add2) x * y)
graph &lt;- pipe_get_graph(p)
graph

if (require("visNetwork", quietly = TRUE)) {
    do.call(visNetwork, args = p$get_graph())
}
</pre>
</div>


<hr>
<a id="method-Pipeline-get_out"></a>



<h4>Method <code>get_out()</code></h4>

<p>Get output of given step
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$get_out(step)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>step</code></dt><dd><p><code>string</code> name of step</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the output at the given step.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("add1", \(x = ~data) x + 1)
p$add("add2", \(x = ~data, y = ~add1) x + y)
p$run()
p$get_out("add1")
p$get_out("add2")
</pre>
</div>


<hr>
<a id="method-Pipeline-get_params"></a>



<h4>Method <code>get_params()</code></h4>

<p>Set unbound function parameters defined in
the pipeline where 'unbound' means parameters that are not linked
to other steps. Trying #' to set parameters that don't exist in
the pipeline is ignored, by default, with a warning.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$get_params(ignoreHidden = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ignoreHidden</code></dt><dd><p><code>logical</code> if TRUE, hidden parameters (i.e. all
names starting with a dot) are ignored and thus not returned.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>list</code> of parameters, sorted and named by step. Steps with
no parameters are filtered out.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("add1", \(data = ~data, x = 1) x + data)
p$add("add2", \(x = 1, y = 2, .z = 3) x + y + .z)
p$add("add3", \() 1 + 2)
p$get_params() |&gt; str()
p$get_params(ignoreHidden = FALSE) |&gt; str()
</pre>
</div>


<hr>
<a id="method-Pipeline-get_params_at_step"></a>



<h4>Method <code>get_params_at_step()</code></h4>

<p>Get all unbound (i.e. not referring to other steps)
at given step name.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$get_params_at_step(step, ignoreHidden = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>step</code></dt><dd><p><code>string</code> name of step</p>
</dd>
<dt><code>ignoreHidden</code></dt><dd><p><code>logical</code> if TRUE, hidden parameters (i.e. all
names starting with a dot) are ignored and thus not returned.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>list</code> of parameters defined at given step.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("add1", \(data = ~data, x = 1) x + data)
p$add("add2", \(x = 1, y = 2, .z = 3) x + y + .z)
p$add("add3", \() 1 + 2)
p$get_params_at_step("add2")
p$get_params_at_step("add2", ignoreHidden = FALSE)
p$get_params_at_step("add3")
</pre>
</div>


<hr>
<a id="method-Pipeline-get_params_unique"></a>



<h4>Method <code>get_params_unique()</code></h4>

<p>Get all unbound (i.e. not referring to other steps)
parameters defined in the pipeline,
but only list each parameter once. The values of the parameters,
will be the values of the first step where the parameter was defined.
This is particularly useful after the parameters where set using
the <code>set_params</code> function, which will set the same value
for all steps.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$get_params_unique(ignoreHidden = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ignoreHidden</code></dt><dd><p><code>logical</code> if TRUE, hidden parameters (i.e. all
names starting with a dot) are ignored and thus not returned.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>list</code> of unique parameters
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("add1", \(data = ~data, x = 1) x + data)
p$add("add2", \(x = 1, y = 2, .z = 3) x + y + .z)
p$add("mult1", \(x = 1, y = 2, .z = 3, b = ~add2) x * y * b)
p$get_params_unique()
p$get_params_unique(ignoreHidden = FALSE)
</pre>
</div>


<hr>
<a id="method-Pipeline-get_params_unique_json"></a>



<h4>Method <code>get_params_unique_json()</code></h4>

<p>Get all unique function parameters in json format.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$get_params_unique_json(ignoreHidden = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ignoreHidden</code></dt><dd><p><code>logical</code> if TRUE, hidden parameters (i.e. all
names starting with a dot) are ignored and thus not returned.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>list</code> flat unnamed json list of unique function parameters
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("add1", \(data = ~data, x = 1) x + data)
p$add("add2", \(x = 1, y = 2, .z = 3) x + y + .z)
p$add("mult1", \(x = 1, y = 2, .z = 3, b = ~add2) x * y * b)
p$get_params_unique_json()
p$get_params_unique_json(ignoreHidden = FALSE)
</pre>
</div>


<hr>
<a id="method-Pipeline-get_step"></a>



<h4>Method <code>get_step()</code></h4>

<p>Get step of pipeline
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$get_step(step)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>step</code></dt><dd><p><code>string</code> name of step</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>data.table</code> row containing the step.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("add1", \(data = ~data, x = 1) x + data)
p$add("add2", \(x = 1, y = 2, z = ~add1) x + y + z)
p$run()
add1 &lt;- p$get_step("add1")
print(add1)
add1[["params"]]
add1[["fun"]]
try()
try(p$get_step("foo")) # error: step 'foo' does not exist
</pre>
</div>


<hr>
<a id="method-Pipeline-get_step_names"></a>



<h4>Method <code>get_step_names()</code></h4>

<p>Get step names of pipeline
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$get_step_names()</pre></div>



<h5>Returns</h5>

<p><code>character</code> vector of step names
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("f1", \(x = 1) x)
p$add("f2", \(y = 1) y)
p$get_step_names()
</pre>
</div>


<hr>
<a id="method-Pipeline-get_step_number"></a>



<h4>Method <code>get_step_number()</code></h4>

<p>Get step number
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$get_step_number(step)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>step</code></dt><dd><p><code>string</code> name of step</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the step number in the pipeline
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("f1", \(x = 1) x)
p$add("f2", \(y = 1) y)
p$get_step_number("f2")
</pre>
</div>


<hr>
<a id="method-Pipeline-has_step"></a>



<h4>Method <code>has_step()</code></h4>

<p>Check if pipeline has given step
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$has_step(step)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>step</code></dt><dd><p><code>string</code> name of step</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>logical</code> whether step exists
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("f1", \(x = 1) x)
p$add("f2", \(y = 1) y)
p$has_step("f2")
p$has_step("foo")
</pre>
</div>


<hr>
<a id="method-Pipeline-insert_after"></a>



<h4>Method <code>insert_after()</code></h4>

<p>Insert step after a certain step
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$insert_after(afterStep, step, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>afterStep</code></dt><dd><p><code>string</code> name of step after which to insert</p>
</dd>
<dt><code>step</code></dt><dd><p><code>string</code> name of step to insert</p>
</dd>
<dt><code>...</code></dt><dd><p>further arguments passed to <code>add</code> method of the pipeline</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>returns the <code>Pipeline</code> object invisibly
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1)
p$add("f1", \(x = 1) x)
p$add("f2", \(x = ~f1) x)
p$insert_after("f1", "f3", \(x = ~f1) x)
p
</pre>
</div>


<hr>
<a id="method-Pipeline-insert_before"></a>



<h4>Method <code>insert_before()</code></h4>

<p>Insert step before a certain step
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$insert_before(beforeStep, step, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>beforeStep</code></dt><dd><p><code>string</code> name of step before which to insert</p>
</dd>
<dt><code>step</code></dt><dd><p><code>string</code> name of step to insert</p>
</dd>
<dt><code>...</code></dt><dd><p>further arguments passed to <code>add</code> method of the pipeline</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>returns the <code>Pipeline</code> object invisibly
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1)
p$add("f1", \(x = 1) x)
p$add("f2", \(x = ~f1) x)
p$insert_before("f2", "f3", \(x = ~f1) x)
p
</pre>
</div>


<hr>
<a id="method-Pipeline-length"></a>



<h4>Method <code>length()</code></h4>

<p>Length of the pipeline aka number of pipeline steps.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$length()</pre></div>



<h5>Returns</h5>

<p><code>numeric</code> length of pipeline.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("f1", \(x = 1) x)
p$add("f2", \(y = 1) y)
p$length()
</pre>
</div>


<hr>
<a id="method-Pipeline-lock_step"></a>



<h4>Method <code>lock_step()</code></h4>

<p>Locking a step means that both its parameters and its
output (given it has output) are locked such that neither
setting new pipeline parameters nor future pipeline runs can change
the current parameter and output content.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$lock_step(step)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>step</code></dt><dd><p><code>string</code> name of step</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the <code>Pipeline</code> object invisibly
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1)
p$add("add1", \(x = 1, data = ~data) x + data)
p$add("add2", \(x = 1, data = ~data) x + data)
p$run()
p$get_out("add1")
p$get_out("add2")
p$lock_step("add1")

p$set_data(3)
p$set_params(list(x = 3))
p$run()
p$get_out("add1")
p$get_out("add2")
</pre>
</div>


<hr>
<a id="method-Pipeline-pop_step"></a>



<h4>Method <code>pop_step()</code></h4>

<p>Drop last step from the pipeline.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$pop_step()</pre></div>



<h5>Returns</h5>

<p><code>string</code> the name of the step that was removed
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("f1", \(x = 1) x)
p$add("f2", \(y = 1) y)
p
p$pop_step() # "f2"
p
</pre>
</div>


<hr>
<a id="method-Pipeline-pop_steps_after"></a>



<h4>Method <code>pop_steps_after()</code></h4>

<p>Drop all steps after the given step.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$pop_steps_after(step)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>step</code></dt><dd><p><code>string</code> name of step</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>character</code> vector of steps that were removed.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("f1", \(x = 1) x)
p$add("f2", \(y = 1) y)
p$add("f3", \(z = 1) z)
p$pop_steps_after("f1")  # "f2", "f3"
p
</pre>
</div>


<hr>
<a id="method-Pipeline-pop_steps_from"></a>



<h4>Method <code>pop_steps_from()</code></h4>

<p>Drop all steps from and including the given step.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$pop_steps_from(step)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>step</code></dt><dd><p><code>string</code> name of step</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>character</code> vector of steps that were removed.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("f1", \(x = 1) x)
p$add("f2", \(y = 1) y)
p$add("f3", \(z = 1) z)
p$pop_steps_from("f2")  # "f2", "f3"
p
</pre>
</div>


<hr>
<a id="method-Pipeline-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print the pipeline as a table.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$print(verbose = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>verbose</code></dt><dd><p><code>logical</code> if <code>TRUE</code>, print all columns of the
pipeline, otherwise only the most relevant columns are displayed.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the <code>Pipeline</code> object invisibly
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("f1", \(x = 1) x)
p$add("f2", \(y = 1) y)
p$print()
</pre>
</div>


<hr>
<a id="method-Pipeline-remove_step"></a>



<h4>Method <code>remove_step()</code></h4>

<p>Remove certain step from the pipeline.
If other steps depend on the step to be removed, an error is
given and the removal is blocked, unless <code>recursive</code> was set to
<code>TRUE</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$remove_step(step, recursive = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>step</code></dt><dd><p><code>string</code> the name of the step to be removed.</p>
</dd>
<dt><code>recursive</code></dt><dd><p><code>logical</code> if <code>TRUE</code> the step is removed together
with all its downstream dependencies.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the <code>Pipeline</code> object invisibly
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("add1", \(data = ~data, x = 1) x + data)
p$add("add2", \(x = 1, y = ~add1) x + y)
p$add("mult1", \(x = 1, y = ~add2) x * y)
p$remove_step("mult1")
p
try(p$remove_step("add1"))  # fails because "add2" depends on "add1"
p$remove_step("add1", recursive = TRUE)  # removes "add1" and "add2"
p
</pre>
</div>


<hr>
<a id="method-Pipeline-rename_step"></a>



<h4>Method <code>rename_step()</code></h4>

<p>Safely rename a step in the pipeline. If new step
name would result in a name clash, an error is given.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$rename_step(from, to)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>from</code></dt><dd><p><code>string</code> the name of the step to be renamed.</p>
</dd>
<dt><code>to</code></dt><dd><p><code>string</code> the new name of the step.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the <code>Pipeline</code> object invisibly
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("add1", \(data = ~data, x = 1) x + data)
p$add("add2", \(x = 1, y = ~add1) x + y)
p
try(p$rename_step("add1", "add2"))  # fails because "add2" exists
p$rename_step("add1", "first_add")  # Ok
p
</pre>
</div>


<hr>
<a id="method-Pipeline-replace_step"></a>



<h4>Method <code>replace_step()</code></h4>

<p>Replaces an existing pipeline step.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$replace_step(
  step,
  fun,
  params = list(),
  description = "",
  group = step,
  keepOut = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>step</code></dt><dd><p><code>string</code> the name of the step to be replaced. Step must
exist.</p>
</dd>
<dt><code>fun</code></dt><dd><p><code>string</code> or <code>function</code> operation to be applied at the
step. Both existing and lambda/anonymous functions can be used.</p>
</dd>
<dt><code>params</code></dt><dd><p><code>list</code> list of parameters to overwrite default
parameters of existing functions.</p>
</dd>
<dt><code>description</code></dt><dd><p><code>string</code> optional description of the step</p>
</dd>
<dt><code>group</code></dt><dd><p><code>string</code> grouping information (by default the same as
the name of the step. Any output collected later (see function
<code>collect_out</code> by default is put together by these group names. This,
for example, comes in handy when the pipeline is copy-appended
multiple times to keep the results of the same function/step at one
place.</p>
</dd>
<dt><code>keepOut</code></dt><dd><p><code>logical</code> if <code>FALSE</code> the output of the function will
be cleaned at the end of the whole pipeline execution. This option
is used to only keep the results that matter.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the <code>Pipeline</code> object invisibly
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1)
p$add("add1", \(x = ~data, y = 1) x + y)
p$add("add2", \(x = ~data, y = 2) x + y)
p$add("mult", \(x = 1, y = 2) x * y, keepOut = TRUE)
p$run()$collect_out()
p$replace_step("mult", \(x = ~add1, y = ~add2) x * y, keepOut = TRUE)
p$run()$collect_out()
try(p$replace_step("foo", \(x = 1) x))   # step 'foo' does not exist
</pre>
</div>


<hr>
<a id="method-Pipeline-reset"></a>



<h4>Method <code>reset()</code></h4>

<p>Resets the pipeline to the state before it was run.
This means that all output is removed and the state of all steps
is reset to 'New'.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$reset()</pre></div>



<h5>Returns</h5>

<p>returns the <code>Pipeline</code> object invisibly
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("f1", \(x = 1) x)
p$add("f2", \(y = 1) y)
p$run()
p
p$reset()
p
</pre>
</div>


<hr>
<a id="method-Pipeline-run"></a>



<h4>Method <code>run()</code></h4>

<p>Run all new and/or outdated pipeline steps.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$run(
  force = FALSE,
  recursive = TRUE,
  cleanUnkept = FALSE,
  progress = NULL,
  showLog = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>force</code></dt><dd><p><code>logical</code> if <code>TRUE</code> all steps are run regardless of
whether they are outdated or not.</p>
</dd>
<dt><code>recursive</code></dt><dd><p><code>logical</code> if <code>TRUE</code> and a step returns a new
pipeline, the run of the current pipeline is aborted and the
new pipeline is run recursively.</p>
</dd>
<dt><code>cleanUnkept</code></dt><dd><p><code>logical</code> if <code>TRUE</code> all output that was not
marked to be kept is removed after the pipeline run. This option
can be useful if temporary results require a lot of memory.</p>
</dd>
<dt><code>progress</code></dt><dd><p><code>function</code> this parameter can be used to provide a
custom progress function of the form <code style="white-space: pre;">&#8288;function(value, detail)&#8288;</code>,
which will show the progress of the pipeline run for each step,
where <code>value</code> is the current step number and <code>detail</code> is the name
of the step.</p>
</dd>
<dt><code>showLog</code></dt><dd><p><code>logical</code> should the steps be logged during the
pipeline run?</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>returns the <code>Pipeline</code> object invisibly
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Simple pipeline
p &lt;- Pipeline$new("pipe", data = 1)
p$add("add1", \(x = ~data, y = 1) x + y)
p$add("add2", \(x = ~add1, z = 2) x + z)
p$add("final", \(x = ~add1, y = ~add2) x * y, keepOut = TRUE)
p$run()$collect_out()
p$set_params(list(z = 4))  # outdates steps add2 and final
p
p$run()$collect_out()
p$run(cleanUnkept = TRUE)  # clean up temporary results
p

# Recursive pipeline
p &lt;- Pipeline$new("pipe", data = 1)
p$add("add1", \(x = ~data, y = 1) x + y)
p$add("new_pipe", \(x = ~add1) {
    pp &lt;- Pipeline$new("new_pipe", data = x)
    pp$add("add1", \(x = ~data) x + 1)
    pp$add("add2", \(x = ~add1) x + 2, keepOut = TRUE)
    }
)
p$run(recursive = TRUE)$collect_out()

# Run pipeline with progress bar
p &lt;- Pipeline$new("pipe", data = 1)
p$add("first step", \() Sys.sleep(1))
p$add("second step", \() Sys.sleep(1))
p$add("last step", \() Sys.sleep(1))
pb &lt;- txtProgressBar(min = 1, max = p$length(), style = 3)
fprogress &lt;- function(value, detail) {
   setTxtProgressBar(pb, value)
}
p$run(progress = fprogress, showLog = FALSE)
</pre>
</div>


<hr>
<a id="method-Pipeline-run_step"></a>



<h4>Method <code>run_step()</code></h4>

<p>Run given pipeline step possibly together with
upstream and downstream dependencies.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$run_step(
  step,
  upstream = TRUE,
  downstream = FALSE,
  cleanUnkept = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>step</code></dt><dd><p><code>string</code> name of step</p>
</dd>
<dt><code>upstream</code></dt><dd><p><code>logical</code> if <code>TRUE</code>, run all dependent upstream
steps first.</p>
</dd>
<dt><code>downstream</code></dt><dd><p><code>logical</code> if <code>TRUE</code>, run all depdendent
downstream afterwards.</p>
</dd>
<dt><code>cleanUnkept</code></dt><dd><p><code>logical</code> if <code>TRUE</code> all output that was not
marked to be kept is removed after the pipeline run. This option
can be useful if temporary results require a lot of memory.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>returns the <code>Pipeline</code> object invisibly
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1)
p$add("add1", \(x = ~data, y = 1) x + y)
p$add("add2", \(x = ~add1, z = 2) x + z)
p$add("mult", \(x = ~add1, y = ~add2) x * y)
p$run_step("add2")
p$run_step("add2", downstream = TRUE)
p$run_step("mult", upstream = TRUE)
</pre>
</div>


<hr>
<a id="method-Pipeline-set_data"></a>



<h4>Method <code>set_data()</code></h4>

<p>Set data in first step of pipeline.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$set_data(data)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>initial data set</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>returns the <code>Pipeline</code> object invisibly
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1)
p$add("add1", \(x = ~data, y = 1) x + y, keepOut = TRUE)
p$run()$collect_out()
p$set_data(3)
p$run()$collect_out()
</pre>
</div>


<hr>
<a id="method-Pipeline-set_data_split"></a>



<h4>Method <code>set_data_split()</code></h4>

<p>This function can be used to apply the pipeline
repeatedly to various data sets. For this, the pipeline split-copies
itself by the list of given data sets. Each sub-pipeline will have
one of the data sets set as input data.
The step names of the sub-pipelines will be the original
step names plus the name of the data set.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$set_data_split(
  dataList,
  toStep = character(),
  groupBySplit = TRUE,
  sep = "."
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dataList</code></dt><dd><p><code>list</code> of data sets</p>
</dd>
<dt><code>toStep</code></dt><dd><p><code>string</code> step name marking optional subset of
the pipeline, at which the data split should be applied to.</p>
</dd>
<dt><code>groupBySplit</code></dt><dd><p><code>logical</code> whether to set step groups according
to data split.</p>
</dd>
<dt><code>sep</code></dt><dd><p><code>string</code> separator to be used between step name and
data set name when creating the new step names.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>new combined <code>Pipeline</code> with each sub-pipeline having set
one of the data sets.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Split by three data sets
dataList &lt;- list(a = 1, b = 2, c = 3)
p &lt;- Pipeline$new("pipe")
p$add("add1", \(x = ~data) x + 1, keepOut = TRUE)
p$add("mult", \(x = ~data, y = ~add1) x * y, keepOut = TRUE)
p$set_data_split(dataList)
p
p$run()$collect_out() |&gt; str()

# Don't group output by split
p &lt;- Pipeline$new("pipe")
p$add("add1", \(x = ~data) x + 1, keepOut = TRUE)
p$add("mult", \(x = ~data, y = ~add1) x * y, keepOut = TRUE)
p$set_data_split(dataList, groupBySplit = FALSE)
p
p$run()$collect_out() |&gt; str()

# Split up to certain step
p &lt;- Pipeline$new("pipe")
p$add("add1", \(x = ~data) x + 1)
p$add("mult", \(x = ~data, y = ~add1) x * y)
p$add("average_result", \(x = ~mult) mean(unlist(x)), keepOut = TRUE)
p
p$get_depends()[["average_result"]]

p$set_data_split(dataList, toStep = "mult")
p
p$get_depends()[["average_result"]]

p$run()$collect_out()
</pre>
</div>


<hr>
<a id="method-Pipeline-set_keep_out"></a>



<h4>Method <code>set_keep_out()</code></h4>

<p>Change the <code>keepOut</code> flag at a given pipeline step,
which determines whether the output of that step is collected
when calling <code>collect_out()</code> after the pipeline was run.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$set_keep_out(step, keepOut = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>step</code></dt><dd><p><code>string</code> name of step</p>
</dd>
<dt><code>keepOut</code></dt><dd><p><code>logical</code> whether to keep output of step</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the <code>Pipeline</code> object invisibly
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1)
p$add("add1", \(x = ~data, y = 1) x + y, keepOut = TRUE)
p$add("add2", \(x = ~data, y = 2) x + y)
p$add("mult", \(x = ~add1, y = ~add2) x * y)
p$run()$collect_out()
p$set_keep_out("add1", keepOut = FALSE)
p$set_keep_out("mult", keepOut = TRUE)
p$collect_out()
</pre>
</div>


<hr>
<a id="method-Pipeline-set_params"></a>



<h4>Method <code>set_params()</code></h4>

<p>Set parameters in the pipeline. If a parameter occurs
in several steps, the parameter is set commonly in all steps.
Trying to set parameters that don't exist in the pipeline is ignored,
by default, with a warning.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$set_params(params, warnUndefined = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p><code>list</code> of parameters to be set</p>
</dd>
<dt><code>warnUndefined</code></dt><dd><p><code>logical</code> whether to give a warning when trying
to set a parameter that is not defined in the pipeline.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>returns the <code>Pipeline</code> object invisibly
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1)
p$add("add1", \(x = ~data, y = 2) x + y)
p$add("add2", \(x = ~data, y = 3) x + y)
p$add("mult", \(x = 4, z = 5) x * z)
p$get_params()
p$set_params(list(x = 3, y = 3))
p$get_params()
p$set_params(list(x = 5, z = 3))
p$get_params()
suppressWarnings(
    p$set_params(list(foo = 3)) # gives warning as 'foo' is undefined
)
p$set_params(list(foo = 3), warnUndefined = FALSE)
</pre>
</div>


<hr>
<a id="method-Pipeline-set_params_at_step"></a>



<h4>Method <code>set_params_at_step()</code></h4>

<p>Set unbound function parameters defined at given
pipeline step where 'unbound' means parameters that are not
linked to other steps.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$set_params_at_step(step, params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>step</code></dt><dd><p><code>string</code> the name of the step</p>
</dd>
<dt><code>params</code></dt><dd><p><code>list</code> of parameters to be set</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>returns the <code>Pipeline</code> object invisibly
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1)
p$add("add1", \(x = ~data, y = 2, z = 3) x + y)
p$set_params_at_step("add1", list(y = 5, z = 6))
p$get_params()
try(p$set_params_at_step("add1", list(foo = 3))) # foo not defined
</pre>
</div>


<hr>
<a id="method-Pipeline-split"></a>



<h4>Method <code>split()</code></h4>

<p>Splits pipeline into its independent parts.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$split()</pre></div>



<h5>Returns</h5>

<p>list of <code>Pipeline</code> objects
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Example for two independent calculation paths
p &lt;- Pipeline$new("pipe", data = 1)
p$add("f1", \(x = ~data) x)
p$add("f2", \(x = 1) x)
p$add("f3", \(x = ~f1) x)
p$add("f4", \(x = ~f2) x)
p$split()

# Example of split by three data sets
dataList &lt;- list(a = 1, b = 2, c = 3)
p &lt;- Pipeline$new("pipe")
p$add("add1", \(x = ~data) x + 1, keepOut = TRUE)
p$add("mult", \(x = ~data, y = ~add1) x * y, keepOut = TRUE)
pipes &lt;- p$set_data_split(dataList)$split()
pipes
</pre>
</div>


<hr>
<a id="method-Pipeline-unlock_step"></a>



<h4>Method <code>unlock_step()</code></h4>

<p>Unlock previously locked step. If step was not locked,
the command is ignored.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$unlock_step(step)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>step</code></dt><dd><p><code>string</code> name of step</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the <code>Pipeline</code> object invisibly
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>p &lt;- Pipeline$new("pipe", data = 1)
p$add("add1", \(x = 1, data = ~data) x + data)
p$add("add2", \(x = 1, data = ~data) x + data)
p$lock_step("add1")
p$set_params(list(x = 3))
p$get_params()
p$unlock_step("add1")
p$set_params(list(x = 3))
p$get_params()
</pre>
</div>


<hr>
<a id="method-Pipeline-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Roman Pahl
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `Pipeline$new`
## ------------------------------------------------

p &lt;- Pipeline$new("myPipe", data = data.frame(x = 1:8))
p

# Passing custom logger
my_logger &lt;- function(level, msg, ...) {
   cat(level, msg, "\n")
}
p &lt;- Pipeline$new("myPipe", logger = my_logger)

## ------------------------------------------------
## Method `Pipeline$add`
## ------------------------------------------------

# Add steps with lambda functions
p &lt;- Pipeline$new("myPipe", data = 1)
p$add("s1", \(x = ~data) 2*x)  # use input data
p$add("s2", \(x = ~data, y = ~s1) x * y)
try(p$add("s2", \(z = 3) 3)) # error: step 's2' exists already
try(p$add("s3", \(z = ~foo) 3)) # dependency 'foo' not found
p

# Add step with existing function
p &lt;- Pipeline$new("myPipe", data = c(1, 2, NA, 3, 4))
p$add("calc_mean", mean, params = list(x = ~data, na.rm = TRUE))
p$run()$get_out("calc_mean")

# Step description
p &lt;- Pipeline$new("myPipe", data = 1:10)
p$add("s1", \(x = ~data) 2*x, description = "multiply by 2")
print(p)
print(p, verbose = TRUE) # print all columns

# Group output
p &lt;- Pipeline$new("myPipe", data = data.frame(x = 1:5, y = 1:5))
p$add("prep_x", \(data = ~data) data$x, group = "prep")
p$add("prep_y", \(data = ~data) (data$y)^2, group = "prep")
p$add("sum", \(x = ~prep_x, y = ~prep_y) x + y)
p$run()$collect_out(all = TRUE)

## ------------------------------------------------
## Method `Pipeline$append`
## ------------------------------------------------

# Append pipeline
p1 &lt;- Pipeline$new("pipe1")
p1$add("step1", \(x = 1) x)
p2 &lt;- Pipeline$new("pipe2")
p2$add("step2", \(y = 1) y)
p1$append(p2)

# Append pipeline with potential name clashes
p3 &lt;- Pipeline$new("pipe3")
p3$add("step1", \(z = 1) z)
p1$append(p2)$append(p3)

# Use output of first pipeline as input for second pipeline
p1 &lt;- Pipeline$new("pipe1", data = 8)
p2 &lt;- Pipeline$new("pipe2")
p1$add("square", \(x = ~data) x^2)
p2$add("log2", \(x = ~data) log2(x))

p12 &lt;- p1$append(p2, outAsIn = TRUE)
p12$run()$get_out("log2")
p12

# Custom name separator
p1$append(p2, sep = "___")

## ------------------------------------------------
## Method `Pipeline$append_to_step_names`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe")
p$add("step1", \(x = 1) x)
p$add("step2", \(y = 1) y)
p$append_to_step_names("new")
p
p$append_to_step_names("foo", sep = "__")
p

## ------------------------------------------------
## Method `Pipeline$collect_out`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("step1", \(x = ~data) x + 2)
p$add("step2", \(x = ~step1) x + 2, keepOut = TRUE)
p$run()
p$collect_out()
p$collect_out(all = TRUE) |&gt; str()

# Grouped output
p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("step1", \(x = ~data) x + 2, group = "add")
p$add("step2", \(x = ~step1, y = 2) x + y, group = "add")
p$add("step3", \(x = ~data) x * 3, group = "mult")
p$add("step4", \(x = ~data, y = 2) x * y, group = "mult")
p
p$run()
p$collect_out(all = TRUE) |&gt; str()

# Grouped by state
p$set_params(list(y = 5))
p
p$collect_out(groupBy = "state", all = TRUE) |&gt; str()

## ------------------------------------------------
## Method `Pipeline$discard_steps`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("add1", \(x = ~data) x + 1)
p$add("add2", \(x = ~add1) x + 2)
p$add("mult3", \(x = ~add1) x * 3)
p$add("mult4", \(x = ~add2) x * 4)
p

p$discard_steps("mult")
p

# Re-add steps
p$add("mult3", \(x = ~add1) x * 3)
p$add("mult4", \(x = ~add2) x * 4)
p
# Discarding 'add1' does not work ...
try(p$discard_steps("add1"))

# ... unless we enforce to remove its downstream dependencies as well
p$discard_steps("add1", recursive = TRUE)   # this works
p

# Trying to discard non-existent steps is just ignored
p$discard_steps("non-existent")

## ------------------------------------------------
## Method `Pipeline$get_data`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1:2)
p$get_data()
p$set_data(3:4)
p$get_data()

## ------------------------------------------------
## Method `Pipeline$get_depends`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("add1", \(x = ~data) x + 1)
p$add("add2", \(x = ~data, y = ~add1) x + y)
p$get_depends()

## ------------------------------------------------
## Method `Pipeline$get_depends_down`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("add1", \(x = ~data) x + 1)
p$add("add2", \(x = ~data, y = ~add1) x + y)
p$add("mult3", \(x = ~add1) x * 3)
p$add("mult4", \(x = ~add2) x * 4)
p$get_depends_down("add1")
p$get_depends_down("add1", recursive = FALSE)

## ------------------------------------------------
## Method `Pipeline$get_depends_up`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("add1", \(x = ~data) x + 1)
p$add("add2", \(x = ~data, y = ~add1) x + y)
p$add("mult3", \(x = ~add1) x * 3)
p$add("mult4", \(x = ~add2) x * 4)
p$get_depends_up("mult4")
p$get_depends_up("mult4", recursive = FALSE)

## ------------------------------------------------
## Method `Pipeline$get_graph`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("add1", \(data = ~data, x = 1) x + data)
p$add("add2", \(x = 1, y = ~add1) x + y)
p$add("mult1", \(x = ~add1, y = ~add2) x * y)
graph &lt;- pipe_get_graph(p)
graph

if (require("visNetwork", quietly = TRUE)) {
    do.call(visNetwork, args = p$get_graph())
}

## ------------------------------------------------
## Method `Pipeline$get_out`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("add1", \(x = ~data) x + 1)
p$add("add2", \(x = ~data, y = ~add1) x + y)
p$run()
p$get_out("add1")
p$get_out("add2")

## ------------------------------------------------
## Method `Pipeline$get_params`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("add1", \(data = ~data, x = 1) x + data)
p$add("add2", \(x = 1, y = 2, .z = 3) x + y + .z)
p$add("add3", \() 1 + 2)
p$get_params() |&gt; str()
p$get_params(ignoreHidden = FALSE) |&gt; str()

## ------------------------------------------------
## Method `Pipeline$get_params_at_step`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("add1", \(data = ~data, x = 1) x + data)
p$add("add2", \(x = 1, y = 2, .z = 3) x + y + .z)
p$add("add3", \() 1 + 2)
p$get_params_at_step("add2")
p$get_params_at_step("add2", ignoreHidden = FALSE)
p$get_params_at_step("add3")

## ------------------------------------------------
## Method `Pipeline$get_params_unique`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("add1", \(data = ~data, x = 1) x + data)
p$add("add2", \(x = 1, y = 2, .z = 3) x + y + .z)
p$add("mult1", \(x = 1, y = 2, .z = 3, b = ~add2) x * y * b)
p$get_params_unique()
p$get_params_unique(ignoreHidden = FALSE)

## ------------------------------------------------
## Method `Pipeline$get_params_unique_json`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("add1", \(data = ~data, x = 1) x + data)
p$add("add2", \(x = 1, y = 2, .z = 3) x + y + .z)
p$add("mult1", \(x = 1, y = 2, .z = 3, b = ~add2) x * y * b)
p$get_params_unique_json()
p$get_params_unique_json(ignoreHidden = FALSE)

## ------------------------------------------------
## Method `Pipeline$get_step`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("add1", \(data = ~data, x = 1) x + data)
p$add("add2", \(x = 1, y = 2, z = ~add1) x + y + z)
p$run()
add1 &lt;- p$get_step("add1")
print(add1)
add1[["params"]]
add1[["fun"]]
try()
try(p$get_step("foo")) # error: step 'foo' does not exist

## ------------------------------------------------
## Method `Pipeline$get_step_names`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("f1", \(x = 1) x)
p$add("f2", \(y = 1) y)
p$get_step_names()

## ------------------------------------------------
## Method `Pipeline$get_step_number`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("f1", \(x = 1) x)
p$add("f2", \(y = 1) y)
p$get_step_number("f2")

## ------------------------------------------------
## Method `Pipeline$has_step`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("f1", \(x = 1) x)
p$add("f2", \(y = 1) y)
p$has_step("f2")
p$has_step("foo")

## ------------------------------------------------
## Method `Pipeline$insert_after`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1)
p$add("f1", \(x = 1) x)
p$add("f2", \(x = ~f1) x)
p$insert_after("f1", "f3", \(x = ~f1) x)
p

## ------------------------------------------------
## Method `Pipeline$insert_before`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1)
p$add("f1", \(x = 1) x)
p$add("f2", \(x = ~f1) x)
p$insert_before("f2", "f3", \(x = ~f1) x)
p

## ------------------------------------------------
## Method `Pipeline$length`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("f1", \(x = 1) x)
p$add("f2", \(y = 1) y)
p$length()

## ------------------------------------------------
## Method `Pipeline$lock_step`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1)
p$add("add1", \(x = 1, data = ~data) x + data)
p$add("add2", \(x = 1, data = ~data) x + data)
p$run()
p$get_out("add1")
p$get_out("add2")
p$lock_step("add1")

p$set_data(3)
p$set_params(list(x = 3))
p$run()
p$get_out("add1")
p$get_out("add2")

## ------------------------------------------------
## Method `Pipeline$pop_step`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("f1", \(x = 1) x)
p$add("f2", \(y = 1) y)
p
p$pop_step() # "f2"
p

## ------------------------------------------------
## Method `Pipeline$pop_steps_after`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("f1", \(x = 1) x)
p$add("f2", \(y = 1) y)
p$add("f3", \(z = 1) z)
p$pop_steps_after("f1")  # "f2", "f3"
p

## ------------------------------------------------
## Method `Pipeline$pop_steps_from`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("f1", \(x = 1) x)
p$add("f2", \(y = 1) y)
p$add("f3", \(z = 1) z)
p$pop_steps_from("f2")  # "f2", "f3"
p

## ------------------------------------------------
## Method `Pipeline$print`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("f1", \(x = 1) x)
p$add("f2", \(y = 1) y)
p$print()

## ------------------------------------------------
## Method `Pipeline$remove_step`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("add1", \(data = ~data, x = 1) x + data)
p$add("add2", \(x = 1, y = ~add1) x + y)
p$add("mult1", \(x = 1, y = ~add2) x * y)
p$remove_step("mult1")
p
try(p$remove_step("add1"))  # fails because "add2" depends on "add1"
p$remove_step("add1", recursive = TRUE)  # removes "add1" and "add2"
p

## ------------------------------------------------
## Method `Pipeline$rename_step`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("add1", \(data = ~data, x = 1) x + data)
p$add("add2", \(x = 1, y = ~add1) x + y)
p
try(p$rename_step("add1", "add2"))  # fails because "add2" exists
p$rename_step("add1", "first_add")  # Ok
p

## ------------------------------------------------
## Method `Pipeline$replace_step`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1)
p$add("add1", \(x = ~data, y = 1) x + y)
p$add("add2", \(x = ~data, y = 2) x + y)
p$add("mult", \(x = 1, y = 2) x * y, keepOut = TRUE)
p$run()$collect_out()
p$replace_step("mult", \(x = ~add1, y = ~add2) x * y, keepOut = TRUE)
p$run()$collect_out()
try(p$replace_step("foo", \(x = 1) x))   # step 'foo' does not exist

## ------------------------------------------------
## Method `Pipeline$reset`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("f1", \(x = 1) x)
p$add("f2", \(y = 1) y)
p$run()
p
p$reset()
p

## ------------------------------------------------
## Method `Pipeline$run`
## ------------------------------------------------

# Simple pipeline
p &lt;- Pipeline$new("pipe", data = 1)
p$add("add1", \(x = ~data, y = 1) x + y)
p$add("add2", \(x = ~add1, z = 2) x + z)
p$add("final", \(x = ~add1, y = ~add2) x * y, keepOut = TRUE)
p$run()$collect_out()
p$set_params(list(z = 4))  # outdates steps add2 and final
p
p$run()$collect_out()
p$run(cleanUnkept = TRUE)  # clean up temporary results
p

# Recursive pipeline
p &lt;- Pipeline$new("pipe", data = 1)
p$add("add1", \(x = ~data, y = 1) x + y)
p$add("new_pipe", \(x = ~add1) {
    pp &lt;- Pipeline$new("new_pipe", data = x)
    pp$add("add1", \(x = ~data) x + 1)
    pp$add("add2", \(x = ~add1) x + 2, keepOut = TRUE)
    }
)
p$run(recursive = TRUE)$collect_out()

# Run pipeline with progress bar
p &lt;- Pipeline$new("pipe", data = 1)
p$add("first step", \() Sys.sleep(1))
p$add("second step", \() Sys.sleep(1))
p$add("last step", \() Sys.sleep(1))
pb &lt;- txtProgressBar(min = 1, max = p$length(), style = 3)
fprogress &lt;- function(value, detail) {
   setTxtProgressBar(pb, value)
}
p$run(progress = fprogress, showLog = FALSE)

## ------------------------------------------------
## Method `Pipeline$run_step`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1)
p$add("add1", \(x = ~data, y = 1) x + y)
p$add("add2", \(x = ~add1, z = 2) x + z)
p$add("mult", \(x = ~add1, y = ~add2) x * y)
p$run_step("add2")
p$run_step("add2", downstream = TRUE)
p$run_step("mult", upstream = TRUE)

## ------------------------------------------------
## Method `Pipeline$set_data`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1)
p$add("add1", \(x = ~data, y = 1) x + y, keepOut = TRUE)
p$run()$collect_out()
p$set_data(3)
p$run()$collect_out()

## ------------------------------------------------
## Method `Pipeline$set_data_split`
## ------------------------------------------------

# Split by three data sets
dataList &lt;- list(a = 1, b = 2, c = 3)
p &lt;- Pipeline$new("pipe")
p$add("add1", \(x = ~data) x + 1, keepOut = TRUE)
p$add("mult", \(x = ~data, y = ~add1) x * y, keepOut = TRUE)
p$set_data_split(dataList)
p
p$run()$collect_out() |&gt; str()

# Don't group output by split
p &lt;- Pipeline$new("pipe")
p$add("add1", \(x = ~data) x + 1, keepOut = TRUE)
p$add("mult", \(x = ~data, y = ~add1) x * y, keepOut = TRUE)
p$set_data_split(dataList, groupBySplit = FALSE)
p
p$run()$collect_out() |&gt; str()

# Split up to certain step
p &lt;- Pipeline$new("pipe")
p$add("add1", \(x = ~data) x + 1)
p$add("mult", \(x = ~data, y = ~add1) x * y)
p$add("average_result", \(x = ~mult) mean(unlist(x)), keepOut = TRUE)
p
p$get_depends()[["average_result"]]

p$set_data_split(dataList, toStep = "mult")
p
p$get_depends()[["average_result"]]

p$run()$collect_out()

## ------------------------------------------------
## Method `Pipeline$set_keep_out`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1)
p$add("add1", \(x = ~data, y = 1) x + y, keepOut = TRUE)
p$add("add2", \(x = ~data, y = 2) x + y)
p$add("mult", \(x = ~add1, y = ~add2) x * y)
p$run()$collect_out()
p$set_keep_out("add1", keepOut = FALSE)
p$set_keep_out("mult", keepOut = TRUE)
p$collect_out()

## ------------------------------------------------
## Method `Pipeline$set_params`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1)
p$add("add1", \(x = ~data, y = 2) x + y)
p$add("add2", \(x = ~data, y = 3) x + y)
p$add("mult", \(x = 4, z = 5) x * z)
p$get_params()
p$set_params(list(x = 3, y = 3))
p$get_params()
p$set_params(list(x = 5, z = 3))
p$get_params()
suppressWarnings(
    p$set_params(list(foo = 3)) # gives warning as 'foo' is undefined
)
p$set_params(list(foo = 3), warnUndefined = FALSE)

## ------------------------------------------------
## Method `Pipeline$set_params_at_step`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1)
p$add("add1", \(x = ~data, y = 2, z = 3) x + y)
p$set_params_at_step("add1", list(y = 5, z = 6))
p$get_params()
try(p$set_params_at_step("add1", list(foo = 3))) # foo not defined

## ------------------------------------------------
## Method `Pipeline$split`
## ------------------------------------------------

# Example for two independent calculation paths
p &lt;- Pipeline$new("pipe", data = 1)
p$add("f1", \(x = ~data) x)
p$add("f2", \(x = 1) x)
p$add("f3", \(x = ~f1) x)
p$add("f4", \(x = ~f2) x)
p$split()

# Example of split by three data sets
dataList &lt;- list(a = 1, b = 2, c = 3)
p &lt;- Pipeline$new("pipe")
p$add("add1", \(x = ~data) x + 1, keepOut = TRUE)
p$add("mult", \(x = ~data, y = ~add1) x * y, keepOut = TRUE)
pipes &lt;- p$set_data_split(dataList)$split()
pipes

## ------------------------------------------------
## Method `Pipeline$unlock_step`
## ------------------------------------------------

p &lt;- Pipeline$new("pipe", data = 1)
p$add("add1", \(x = 1, data = ~data) x + data)
p$add("add2", \(x = 1, data = ~data) x + data)
p$lock_step("add1")
p$set_params(list(x = 3))
p$get_params()
p$unlock_step("add1")
p$set_params(list(x = 3))
p$get_params()
</code></pre>

<hr>
<h2 id='set_log_layout'>Set pipeflow log layout</h2><span id='topic+set_log_layout'></span>

<h3>Description</h3>

<p>This function provides an easy way to set the basic log
layout of the pipeline logging. For a fine-grained control of the logger,
which you can retrieve via <code>lgr::get_logger("pipeflow")</code>, see e.g. the
<a href="lgr.html#topic+logger_config">logger_config</a> function from the <a href="lgr.html#topic+lgr">lgr</a> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_log_layout(layout = c("text", "json"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_log_layout_+3A_layout">layout</code></td>
<td>
<p>Layout name, which at this point can be either 'text' or
'json'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisibly returns a <code>Logger</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- Pipeline$new("pipe", data = 1:2)
p$add("add1", \(data = ~data, x = 1) x + data)
p$run()

lg &lt;- set_log_layout("json")
print(lg)

p$run()

set_log_layout("text")
p$run()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
