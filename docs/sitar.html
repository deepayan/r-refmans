<!DOCTYPE html><html lang="en"><head><title>Help for package sitar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sitar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sitar-package'><p>SITAR (SuperImposition by Translation And Rotation) growth curve analysis</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#anova.sitar'><p>Compare Likelihoods of Fitted SITAR Objects</p></a></li>
<li><a href='#apv_se'><p>Bootstrap standard errors for SITAR peak velocity and age at peak velocity</p></a></li>
<li><a href='#berkeley'><p>The Berkeley Child Guidance Study</p></a></li>
<li><a href='#BICadj'><p>Ways to compare SITAR models for fit</p></a></li>
<li><a href='#bupdate'><p>Update the b fixed effect to minimise the b-c random effect correlation</p></a></li>
<li><a href='#cdc2000'><p>The CDC 2000 growth reference</p></a></li>
<li><a href='#cLMS'><p>LMS conversion to and from z-scores</p></a></li>
<li><a href='#codeplot'><p>Plot and zap velocity outliers in growth curves</p></a></li>
<li><a href='#deren'><p>Deren prevalence data on child thinness, overweight and obesity</p></a></li>
<li><a href='#dfpower'><p>Tabulate BIC of SITAR models by degrees of freedom, fixed effects and xy power transformations</p></a></li>
<li><a href='#dfset'><p>Find degrees of freedom for a natural spline curve to minimise BIC or AIC</p></a></li>
<li><a href='#funcall'><p>Function call with optional inverse</p></a></li>
<li><a href='#getData.sitar'><p>Extract elements of fitted SITAR models</p></a></li>
<li><a href='#getPeakTrough'><p>Identify peak or trough on curve</p></a></li>
<li><a href='#heights'><p>Serial heights measured in 12 girls</p></a></li>
<li><a href='#ifun'><p>Invert an expression defining a data transformation</p></a></li>
<li><a href='#iotf'><p>IOTF international body mass index reference</p></a></li>
<li><a href='#LMS2z'><p>Convert to/from measurement from/to z-score with growth reference</p></a></li>
<li><a href='#LMSfit'><p>Estimate LMS curves from tabulated growth reference centiles</p></a></li>
<li><a href='#mplot'><p>Plot multiple growth curves</p></a></li>
<li><a href='#ob_convertr'><p>Convert between IOTF, WHO and CDC prevalence rates for child thinness,</p>
overweight and obesity</a></li>
<li><a href='#optimal_design'><p>Optimal design for growth reference centile studies</p></a></li>
<li><a href='#pdLMS'><p>Plot frequency distributions(s) for given L, M and S values in LMS method</p></a></li>
<li><a href='#plot.sitar'><p>Plot SITAR model</p></a></li>
<li><a href='#plotclean'><p>Plot multiple growth curves to identify outliers</p></a></li>
<li><a href='#predict.sitar'><p>Predict SITAR model</p></a></li>
<li><a href='#print.sitar'><p>Print SITAR model</p></a></li>
<li><a href='#print.summary.sitar'><p>Print summary of SITAR model</p></a></li>
<li><a href='#recalib'><p>Recalibrate x, y data using SITAR random effects</p></a></li>
<li><a href='#sitar'><p>Fit SITAR growth curve model</p></a></li>
<li><a href='#subsample'><p>Sample from SITAR dataset</p></a></li>
<li><a href='#summary.sitar'><p>Create summary of SITAR model</p></a></li>
<li><a href='#timegap'><p>Select equally spaced ages from a vector of ages</p></a></li>
<li><a href='#uk90'><p>UK 1990 growth reference</p></a></li>
<li><a href='#ukwhopt'><p>UK-WHO growth reference including preterm</p></a></li>
<li><a href='#ukwhoterm'><p>UK-WHO growth reference omitting preterm data</p></a></li>
<li><a href='#velout'><p>Identify outliers with abnormal velocity in growth curves</p></a></li>
<li><a href='#who06'><p>The WHO 2006 growth standard</p></a></li>
<li><a href='#who0607'><p>The WHO 2006 growth standard and WHO 2007 growth reference</p></a></li>
<li><a href='#xaxsd'><p>Par args xaxs and yaxs option d</p></a></li>
<li><a href='#xyadj'><p>Adjust x and y variables for SITAR random effects</p></a></li>
<li><a href='#z2cent'><p>Express z-scores as centile character strings for plotting</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Super Imposition by Translation and Rotation Growth Curve
Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tim Cole &lt;tim.cole@ucl.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for fitting and plotting SITAR (Super
    Imposition by Translation And Rotation) growth curve models. SITAR is
    a shape-invariant model with a regression B-spline mean curve and
    subject-specific random effects on both the measurement and age
    scales.  The model was first described by Lindstrom (1995)
    &lt;<a href="https://doi.org/10.1002%2Fsim.4780141807">doi:10.1002/sim.4780141807</a>&gt; and developed as the SITAR method by Cole
    et al (2010) &lt;<a href="https://doi.org/10.1093%2Fije%2Fdyq115">doi:10.1093/ije/dyq115</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/statist7/sitar">https://github.com/statist7/sitar</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>nlme, R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, forcats, ggplot2, glue, purrr, rlang, rsample, stats,
tibble, tidyr, magrittr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-23 15:25:33 UTC; timcole</td>
</tr>
<tr>
<td>Author:</td>
<td>Tim Cole <a href="https://orcid.org/0000-0001-5711-8200"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre,
    aut, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-23 15:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='sitar-package'>SITAR (SuperImposition by Translation And Rotation) growth curve analysis</h2><span id='topic+sitar-package'></span>

<h3>Description</h3>

<p>SITAR is a method of growth curve analysis, based on <span class="pkg">nlme</span>, that
estimates a single mean growth curve as a regression B-spline, plus a set of
up to four fixed and random effects (a, b, c and d) (d was added in version 1.2.0)
defining how individual
growth curves differ from the mean curve. SITAR stands for SuperImposition
by Translation And Rotation.
</p>


<h3>Details</h3>

<p>The package also contains some utility functions for the LMS method, as used
to construct growth reference centiles (see <span class="pkg">gamlss</span>).
</p>

<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> sitar</td>
</tr>
<tr>
 <td style="text-align: left;"> Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;"> Version: </td><td style="text-align: left;">
1.0</td>
</tr>
<tr>
 <td style="text-align: left;"> Date: </td><td style="text-align: left;"> 2013-09-23</td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>
<p> Effect a (or alpha)
measures size, and is a random intercept relative to the spline curve
intercept. Effect b (or beta) measures tempo, the timing of the growth
process, and reflects a shift on the x scale relative to the mean. Effect c
(or gamma) is velocity, and indicates how the x scale is stretched or shrunk
reflecting the rate at which 'time' passes for individuals. Effect d is a
rotation in the plane. The aim is for
individual curves, adjusted for abcd to lie on top of (i.e. be
superimposed on) the mean curve.
</p>
<p>The package creates an object of class <code>sitar</code>, based on <span class="pkg">nlme</span>,
representing the nonlinear mixed-effects model fit. Generic functions such
as <code>print</code>, <code>plot</code> and <code>summary</code> have methods to show the
results of the fit, along with <code>resid</code>, <code>coef</code>, <code>fitted</code>,
<code>fixed.effects</code> and <code>random.effects</code> to extract some of its
components. The functions <code>AICadj</code>, <code>BICadj</code> and <code>varexp</code>
compare respectively the AIC, BIC and variance explained of a series of
models, taking into account any transformations of the y variable. Functions
<code>plotclean</code>, <code>velout</code>, <code>codeplot</code> and <code>zapvelout</code> are
useful to clean the data file.
</p>


<h3>Author(s)</h3>

<p>Tim Cole <a href="mailto:tim.cole@ucl.ac.uk">tim.cole@ucl.ac.uk</a>
</p>


<h3>References</h3>

<p>The idea of SITAR growth curve analysis arose from the paper by
Beath (2007) and was first described in Cole et al (2010). The other
references describe applications of SITAR to a variety of data forms.
</p>
<p>Beath KJ. Infant growth modelling using a shape invariant model with random
efffects. Stat Med 2007;26:2547-64.
</p>
<p>Cole TJ, Cortina Borja M, Sandhu J, et al. Nonlinear growth generates age
changes in the moments of the frequency distribution: the example of height
in puberty. Biostatistics 2008;9:159-71.
</p>
<p>Cole TJ, Donaldson MD, Ben-Shlomo Y. SITAR&ndash;a useful instrument for growth
curve analysis. Int J Epidemiol 2010;39:1558-66.
</p>
<p>Gault EJ, Perry RJ, Cole TJ, et al. Effect of oxandrolone and timing of
pubertal induction on final height in Turner's syndrome: randomised, double
blind, placebo controlled trial. BMJ 2011;\-342:d1980.
</p>
<p>Johnson L, Llewellyn CH, van Jaarsveld CHM, et al. Genetic and environmental
influences on infant growth: prospective analysis of the Gemini twin birth
cohort. PLoS ONE 2011;6:e19918.
</p>
<p>Prentice A, Dibba B, Sawo Y, et al. The effect of prepubertal calcium
carbonate supplementation on the age of peak height velocity in Gambian
adolescents. Am J Clin Nutr 2012;96:1042-50.
</p>
<p>Dean MC, Cole TJ. Human life history evolution explains dissociation between
the timing of tooth eruption and peak rates of root growth. PLoS ONE
2013;8:e54534.
</p>
<p>Cole TJ, Statnikov Y, Santhakumaran S, et al. Birth weight and longitudinal
growth in infants born below 32 weeks gestation: a UK population study. Arch
Dis Child Fetal Neonatal Ed 2014;99:F34-F40.
</p>
<p>Cole TJ, Rousham EK, Hawley NL, et al. Ethnic and sex differences in
skeletal maturation among the Birth to Twenty cohort in South Africa. Arch
Dis Child 2014;100:138-43.
</p>
<p>Cole TJ, Pan H, Butler GE. A mixed effects model to estimate timing and
intensity of pubertal growth from height and secondary sexual
characteristics. Ann Hum Biol 2014;41:7683.
</p>
<p>Johnson L, van Jaarsveld CHM, Llewellyn CH, et al. Associations between
infant feeding and the size, tempo and velocity of infant weight gain: SITAR
analysis of the Gemini twin birth cohort. Int J Obes 2014;38:980-7.
</p>
<p>Pizzi C, Cole TJ, Richiardi L, et al. Prenatal influences on size, velocity
and tempo of iInfant growth: findings from three contemporary cohorts. PLoS
ONE 2014;9:e90291.
</p>
<p>Ward KA, Cole TJ, Laskey MA, et al. The Effect of Prepubertal Calcium
Carbonate Supplementation on Skeletal Development in Gambian Boys-A 12-Year
Follow-Up Study. J C E M 2014;99:3169-76.
</p>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='anova.sitar'>Compare Likelihoods of Fitted SITAR Objects</h2><span id='topic+anova.sitar'></span>

<h3>Description</h3>

<p>anova method for <code>sitar</code> objects, based on <code>anova.lme</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sitar'
anova(
  object,
  ...,
  test = TRUE,
  type = c("sequential", "marginal"),
  adjustSigma = TRUE,
  Terms,
  L,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anova.sitar_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>sitar</code>.</p>
</td></tr>
<tr><td><code id="anova.sitar_+3A_...">...</code></td>
<td>
<p>other optional fitted model objects.</p>
</td></tr>
<tr><td><code id="anova.sitar_+3A_test">test</code></td>
<td>
<p>an optional logical value controlling whether likelihood ratio
tests should be used.</p>
</td></tr>
<tr><td><code id="anova.sitar_+3A_type">type</code></td>
<td>
<p>an optional character string specifying the type of sum of
squares to be used.</p>
</td></tr>
<tr><td><code id="anova.sitar_+3A_adjustsigma">adjustSigma</code></td>
<td>
<p>see <code><a href="nlme.html#topic+anova.lme">anova.lme</a></code>.</p>
</td></tr>
<tr><td><code id="anova.sitar_+3A_terms">Terms</code></td>
<td>
<p>see <code><a href="nlme.html#topic+anova.lme">anova.lme</a></code>.</p>
</td></tr>
<tr><td><code id="anova.sitar_+3A_l">L</code></td>
<td>
<p>see <code><a href="nlme.html#topic+anova.lme">anova.lme</a></code>.</p>
</td></tr>
<tr><td><code id="anova.sitar_+3A_verbose">verbose</code></td>
<td>
<p>an optional logical value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame inheriting from class &quot;anova.lme&quot;.
</p>


<h3>Author(s)</h3>

<p>Tim Cole <a href="mailto:tim.cole@ucl.ac.uk">tim.cole@ucl.ac.uk</a>
</p>

<hr>
<h2 id='apv_se'>Bootstrap standard errors for SITAR peak velocity and age at peak velocity</h2><span id='topic+apv_se'></span>

<h3>Description</h3>

<p><code>apv_se</code> bootstraps a SITAR model to generate standard errors for
age at peak velocity (apv) and peak velocity (pv).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apv_se(object, fun = getPeak, nboot = 10, seed = NULL, plot = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apv_se_+3A_object">object</code></td>
<td>
<p>SITAR model.</p>
</td></tr>
<tr><td><code id="apv_se_+3A_fun">fun</code></td>
<td>
<p>function to extract apv and pv from velocity curve (default getPeak),
alternative getTakeoff or getTrough.</p>
</td></tr>
<tr><td><code id="apv_se_+3A_nboot">nboot</code></td>
<td>
<p>number of bootstrap samples (default 10).</p>
</td></tr>
<tr><td><code id="apv_se_+3A_seed">seed</code></td>
<td>
<p>integer to initialize the random number generator (default NULL).</p>
</td></tr>
<tr><td><code id="apv_se_+3A_plot">plot</code></td>
<td>
<p>logical to control plotting (default FALSE).</p>
</td></tr>
<tr><td><code id="apv_se_+3A_...">...</code></td>
<td>
<p>optional arguments defining the velocity curve to be bootstrapped
(<code>plot.sitar</code> arguments <code>xfun</code>, <code>yfun</code>, <code>subset</code>, <code>ns</code>
or <code>abc</code>), and graphical <code>par</code> parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>plot</code> is TRUE, the original velocity curve is plotted along with
each bootstrap sample's pv versus apv.
</p>


<h3>Value</h3>

<p>a 2x2 array giving the mean and standard error of apv and pv, with
attribute &quot;bs&quot; a tibble containing the bootstrap estimates of apv and pv,
with NAs removed.
</p>


<h3>Author(s)</h3>

<p>Tim Cole <a href="mailto:tim.cole@ucl.ac.uk">tim.cole@ucl.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(heights)
## fit sitar model for height
model &lt;- sitar(x = age, y = height, id = id, data = heights, df = 4)

## bootstrap standard errors for age at peak velocity and peak velocity
output &lt;- apv_se(model, nboot=3, seed=111, plot=TRUE)
</code></pre>

<hr>
<h2 id='berkeley'>The Berkeley Child Guidance Study</h2><span id='topic+berkeley'></span>

<h3>Description</h3>

<p>The Berkeley Child Guidance Study dataset contains longitudinal anthropometry
data for 136 children from birth to 21 years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>berkeley
</code></pre>


<h3>Format</h3>

<p>A data frame with 4884 observations on the following 10 variables:
</p>

<dl>
<dt>id</dt><dd><p>factor with levels 201-278 male and 301-385 female</p>
</dd>
<dt>age</dt><dd><p>years, numeric vector</p>
</dd>
<dt>height</dt><dd><p>cm, numeric vector</p>
</dd>
<dt>weight</dt><dd><p>kg, numeric vector</p>
</dd>
<dt>stem.length</dt><dd><p>cm, numeric vector</p>
</dd>
<dt>bi.acromial</dt><dd><p>cm, numeric vector</p>
</dd>
<dt>bi.iliac</dt><dd><p>cm, numeric vector</p>
</dd>
<dt>leg.circ</dt><dd><p>cm, numeric vector</p>
</dd>
<dt>strength</dt><dd><p>lb, numeric vector</p>
</dd>
<dt>sex</dt><dd><p>factor with level 1 male and level 2 female</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data are for 66 boys and 70 girls from Berkeley, California born in 1928-29
of north European ancestry, and followed from birth to 21 years. Measurements were
at ages 0, 0.085, 0.25 to 2 (3-monthly), 2 to 8 (annually), and 8 to 21 (6-monthly) years.
</p>
<p>The children were measured for height, weight (undressed), stem length, biacromial diameter,
bi-iliac diameter, leg circumference, and dynamometric strength.
The data were provided as an appendix to the book by Tuddenham and Snyder (1954),
and a few transcription errors are corrected here.
A further 19 errors in height and weight as reported in <code>sitar</code> issue #7 are also now corrected.
The <code>growth</code> dataset in the <code>fda</code> package uses heights from the same study.
</p>


<h3>References</h3>

<p>Tuddenham RD, Snyder MM. Physical growth of California boys and girls from birth to eighteen years.
University of California Publications in Child Development 1954;1:183-364.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(berkeley)
## frequencies of age of measurement for each variable
## weight and length/height from birth, other variables from 6-8 years
## few measurements after 18 years
. &lt;- as.factor(berkeley$age)
plot(levels(.), summary(.), type='s', las=1,
  xlab='age of measurement (years)', ylab='frequency of measurements')
points(levels(.), levels(.) &lt; 0, pch=15)
for (i in 3:9) {
  .. &lt;- .[!is.na(berkeley[, names(berkeley)[i]])]
  lines(levels(..), summary(..), type='s', col=i)
}
legend('topright', names(berkeley)[c(3:9)], text.col=c(3:9), bty='n', inset=0.04)
</code></pre>

<hr>
<h2 id='BICadj'>Ways to compare SITAR models for fit</h2><span id='topic+BICadj'></span><span id='topic+AICadj'></span><span id='topic+varexp'></span><span id='topic+getL'></span>

<h3>Description</h3>

<p><code>BICadj</code> and <code>AICadj</code> calculate the BIC and AIC for SITAR models,
adjusting the likelihood for Box-Cox transformed y variables. <code>varexp</code>
calculates the variance explained by SITAR models, compared to the
corresponding fixed effect models. <code>getL</code> is used by <code>[AB]ICadj</code> to
find what power the y variable is raised to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BICadj(..., pattern = NULL)

AICadj(..., k = 2, pattern = NULL)

varexp(..., pattern = NULL)

getL(expr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BICadj_+3A_...">...</code></td>
<td>
<p>one or more SITAR models.</p>
</td></tr>
<tr><td><code id="BICadj_+3A_pattern">pattern</code></td>
<td>
<p>regular expression defining names of models.</p>
</td></tr>
<tr><td><code id="BICadj_+3A_k">k</code></td>
<td>
<p>numeric, the penalty per parameter to be used; the default k = 2 is
the classical AIC.</p>
</td></tr>
<tr><td><code id="BICadj_+3A_expr">expr</code></td>
<td>
<p>quoted or unquoted expression containing a single variable name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The deviance is adjusted if the y variable is power-transformed, using the
formula
</p>
<p style="text-align: center;"><code class="reqn">adjusted deviance = deviance - 2n ( (\lambda-1) * log(gm) + %
log(abs(\lambda)) )</code>
</p>

<p>where <code class="reqn">\lambda</code> is the power transform, and <code class="reqn">n</code> and
<code class="reqn">gm</code> are the length and geometric mean of <code>y</code>.
</p>
<p>The variance explained is given by </p>
<p style="text-align: center;"><code class="reqn">\% explained = 100 * (1 -%
(\sigma_2/\sigma_1)^2)</code>
</p>
<p> where
<code class="reqn">\sigma_1</code> is the fixed effects RSD and <code class="reqn">\sigma_2</code>
the SITAR random effects RSD.
</p>
<p><code>BICadj</code> and <code>AICadj</code> accept non-<code>sitar</code> models with a
<code>logLik</code> class. <code>varexp</code> ignores objects not of class
<code>sitar</code>.
</p>
<p><code>getL</code> does not detect if the variable in <code>expr</code>, or its log, contains a multiplying constant,
so that the expressions <code>log(x)</code> and <code>1 + 2 * log(3 * x)</code> both return 0.
</p>


<h3>Value</h3>

<p>For <code>BICadj</code> and <code>AICadj</code> a named vector of deviances in
increasing order.  For <code>varexp</code> a named vector of percentages in
decreasing order. For <code>getL</code> the power the variable in <code>expr</code>
is raised to, or <code>NA</code> if <code>expr</code> is not a power of (a multiple of)
the variable.
</p>


<h3>Author(s)</h3>

<p>Tim Cole <a href="mailto:tim.cole@ucl.ac.uk">tim.cole@ucl.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+BIC">BIC</a></code>, <code><a href="stats.html#topic+AIC">AIC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(heights)
## fit sitar model for height
m1 &lt;- sitar(x=age, y=height, id=id, data=heights, df=5)

## update it for log(height)
m2 &lt;- update(m1, y=sqrt(height))

## compare variance explained in the two models
varexp(m1, m2)

## compare BIC adjusting for sqrt transform
## the pattern matches names starting with "m" followed by a digit
BICadj(pattern="^m[0-9]")

## find what power height is raised to
getL(quote(sqrt(sqrt(height))))
</code></pre>

<hr>
<h2 id='bupdate'>Update the b fixed effect to minimise the b-c random effect correlation</h2><span id='topic+bupdate'></span>

<h3>Description</h3>

<p>A function to update the value of <code>bstart</code>, the starting value for the
b fixed effect, to minimise the correlation between the random effects b and
c.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bupdate(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bupdate_+3A_x">x</code></td>
<td>
<p>a <code>sitar</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an updated value of the b fixed effect, based on the random
effect covariance matrix.
</p>


<h3>Author(s)</h3>

<p>Tim Cole <a href="mailto:tim.cole@ucl.ac.uk">tim.cole@ucl.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## fit sitar model with b fixed effect starting value defaulting to 'mean'
m1 &lt;- sitar(x=age, y=height, id=id, data=heights, df=5)
print(fixef(m1)['b'])

## refit with starting value chosen to minimise b-c correlation and df increased
m2 &lt;- update(m1, bstart=bupdate(m1), df=6)
print(fixef(m2)['b'])

</code></pre>

<hr>
<h2 id='cdc2000'>The CDC 2000 growth reference</h2><span id='topic+cdc2000'></span>

<h3>Description</h3>

<p>The CDC growth reference (Kuczmarski et al 2000) for height,
weight, body mass index and head circumference, fitted by the LMS method and
summarised by values of L, M and S by sex from birth to 19 years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdc2000
</code></pre>


<h3>Format</h3>

<p>A tibble with 484 observations on the following 14 variables:
</p>
 <dl>
<dt>years</dt><dd><p>age from 0 to 19 years</p>
</dd>
<dt>L.ht</dt><dd><p>numeric vector</p>
</dd>
<dt>M.ht</dt><dd><p>numeric vector</p>
</dd>
<dt>S.ht</dt><dd><p>numeric vector</p>
</dd>
<dt>L.wt</dt><dd><p>numeric vector</p>
</dd>
<dt>M.wt</dt><dd><p>numeric vector</p>
</dd>
<dt>S.wt</dt><dd><p>numeric vector</p>
</dd>
<dt>L.bmi</dt><dd><p>numeric vector</p>
</dd>
<dt>M.bmi</dt><dd><p>numeric vector</p>
</dd>
<dt>S.bmi</dt><dd><p>numeric vector</p>
</dd>
<dt>L.hc</dt><dd><p>numeric vector</p>
</dd>
<dt>M.hc</dt><dd><p>numeric vector</p>
</dd>
<dt>S.hc</dt><dd><p>numeric vector</p>
</dd>
<dt>sex</dt><dd><p>two-level factor with level 1 male and level 2 female</p>
</dd> </dl>



<h3>Details</h3>

<p>BMI starts at 2 years, and head circumference stops at 3 years.
</p>
<p>The L, M and S values for each measurement correspond respectively to the
Box-Cox power, median and coefficient of variation of the distribution by
age and sex (Cole &amp; Green 1992). The short names and units for each measurement
(see <code><a href="#topic+LMS2z">LMS2z</a></code>) are as follows: height (ht, cm), weight (wt, kg),
body mass index (bmi, kg/m2), head circumference (hc, cm).
</p>


<h3>References</h3>

<p>Cole TJ, Green PJ. Smoothing reference centile curves: the
LMS method and penalized likelihood. Stat Med 1992;11:1305-19.
</p>
<p>Kuczmarski RJ, Ogden CL, Guo SS, Grummer-Strawn LM, Flegal KM, Mei Z, Wei R,
Curtin LR, Roche AF, Johnson CL. 2000 CDC growth charts for the United States:
methods and development. Vital Health Stat, 2002, 11, 246, 1-190.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cdc2000)
## calculate 98th centile for weight in girls from birth to 19 years
round(
  setNames(
    LMS2z(x = 0:19, y = 2, sex = 2, measure = 'wt', ref = 'cdc2000',
      toz = FALSE), 0:19), 1)
</code></pre>

<hr>
<h2 id='cLMS'>LMS conversion to and from z-scores</h2><span id='topic+cLMS'></span><span id='topic+zLMS'></span>

<h3>Description</h3>

<p>Routines to handle references constructed with the LMS method. Given a set
of LMS values, the functions convert z-scores to measurement centiles and
vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cLMS(z, L = 1, M, S)

zLMS(x, L = 1, M, S)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cLMS_+3A_z">z</code></td>
<td>
<p>vector or one-column matrix of z-scores to be converted to measurements.</p>
</td></tr>
<tr><td><code id="cLMS_+3A_l">L</code></td>
<td>
<p>vector of Box-Cox transformation (lambda) values, L in the LMS
method.</p>
</td></tr>
<tr><td><code id="cLMS_+3A_m">M</code></td>
<td>
<p>vector of medians (mu), M in the LMS method.</p>
</td></tr>
<tr><td><code id="cLMS_+3A_s">S</code></td>
<td>
<p>vector of coefficients of variation (sigma), S in the LMS method.</p>
</td></tr>
<tr><td><code id="cLMS_+3A_x">x</code></td>
<td>
<p>vector or one-column matrix of measurements to be converted to z-scores.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>L, M and S &ndash; and if vectors then <code>x</code> and <code>z</code> &ndash;
should all be the same length, recycled if necessary.
The formulae converting <code>x</code> to <code>z</code> and vice versa are:
</p>
<p style="text-align: center;"><code class="reqn">z = \frac{(x/M)^L - 1}{L S}</code>
</p>

<p style="text-align: center;"><code class="reqn">x = M (1 + L S z)^{1/L})</code>
</p>
<p> where L is reset
to 10^-7 if it is zero. The LMS method is the same as the BCCG
family in the <code>gamlss</code> package, except that lambda in LMS is referred
to as nu in BCCG.
</p>


<h3>Value</h3>

<p>If <code>x</code> and <code>z</code> are vectors <code>zLMS</code> and <code>cLMS</code>
each return a vector, respectively of z-scores and measurement centiles, with length
matching the length of (the longest of) <code>x</code> or <code>z</code>, L, M and S.
If <code>x</code> or <code>z</code> are matrices <code>zLMS</code> and <code>cLMS</code> each return a matrix,
the number of rows matching the length of (the longest of) L, M and S,
and the number of columns matching the length of <code>x</code> or <code>z</code>.
</p>


<h3>Author(s)</h3>

<p>Tim Cole <a href="mailto:tim.cole@ucl.ac.uk">tim.cole@ucl.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+z2cent">z2cent</a></code>, <code><a href="#topic+LMS2z">LMS2z</a></code>, <code><a href="#topic+pdLMS">pdLMS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cLMS(z = as.matrix(-2:2), L = 1:-1, M = 5:7, S = rep(0.1, 3))
cLMS(z = 0:2, L = 1:-1, M = 7, S = 0.1)
cLMS(z = as.matrix(0:2), L = 1:-1, M = 7, S = 0.1)
zLMS(x = 6.5, L = 1:-1, M = 5:7, S = rep(0.1, 3))

</code></pre>

<hr>
<h2 id='codeplot'>Plot and zap velocity outliers in growth curves</h2><span id='topic+codeplot'></span><span id='topic+zapvelout'></span>

<h3>Description</h3>

<p>Handles output from <code>velout</code> function to display growth curves with
outlying points, either plotting or zapping the outliers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>codeplot(outliers, icode = 4, ..., print = TRUE)

zapvelout(outliers, icode)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="codeplot_+3A_outliers">outliers</code></td>
<td>
<p>Data frame returned from velout.</p>
</td></tr>
<tr><td><code id="codeplot_+3A_icode">icode</code></td>
<td>
<p>The code number(s) defining the subset of curves to be
displayed or zapped (between 1 and 6).</p>
</td></tr>
<tr><td><code id="codeplot_+3A_...">...</code></td>
<td>
<p>Optional plot parameters.</p>
</td></tr>
<tr><td><code id="codeplot_+3A_print">print</code></td>
<td>
<p>Option to print as well as plot information on each curve.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>velout</code> identifies putative outliers for <code>y</code> in
<code>data</code>, <code>codeplot</code> plots them, and <code>zapvelout</code> sets missing
those confirmed as outliers.  Codes range from 0 (normal) to 8, where 4 and
6 are conventional outliers (see <code><a href="#topic+velout">velout</a></code>).
</p>


<h3>Value</h3>

<p><code>codeplot</code> returns summary information on each curve with an
outlier of the relevant code, and optionally plots the curve.
<code>zapvelout</code> sets to NA values of <code>y</code> whose code is contained in
<code>icode</code>, and returns the modified data frame.
</p>


<h3>Author(s)</h3>

<p>Tim Cole <a href="mailto:tim.cole@ucl.ac.uk">tim.cole@ucl.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+velout">velout</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## identify outliers
outliers &lt;- velout(age, height, id, heights, limit=2)

## plot outliers with code 4 or 6
codeplot(outliers, icode=c(4,6))

## set the 8 outliers missing
newheights &lt;- zapvelout(outliers, icode=6)

</code></pre>

<hr>
<h2 id='deren'>Deren prevalence data on child thinness, overweight and obesity</h2><span id='topic+deren'></span>

<h3>Description</h3>

<p>Age-sex-specific prevalence rates of thinness, overweight and obesity in
Ukraine children based on body mass index and IOTF, WHO and CDC cut-offs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deren
</code></pre>


<h3>Format</h3>

<p>A tibble with 22 observations on the following 11 variables:
</p>

<dl>
<dt>Age</dt><dd><p>postnatal age from 7 to 17 completed years</p>
</dd>
<dt>Sex</dt><dd><p>two-level factor - Boys and Girls</p>
</dd>
<dt>N</dt><dd><p>integer - group sample size</p>
</dd>
<dt>IOTF18.5</dt><dd><p>thinness prevalence based on IOTF reference and 18.5 cutoff</p>
</dd>
<dt>WHO-2</dt><dd><p>thinness prevalence based on WHO reference and -2 cutoff</p>
</dd>
<dt>CDC5</dt><dd><p>thinness prevalence based on CDC reference and 5 cutoff</p>
</dd>
<dt>IOTF25</dt><dd><p>overweight prevalence based on IOTF reference and 25 cutoff</p>
</dd>
<dt>WHO+1</dt><dd><p>overweight prevalence based on WHO reference and +1 cutoff</p>
</dd>
<dt>CDC85</dt><dd><p>overweight prevalence based on CDC reference and 85 cutoff</p>
</dd>
<dt>IOTF30</dt><dd><p>obesity prevalence based on IOTF reference and 30 cutoff</p>
</dd>
<dt>WHO+2</dt><dd><p>obesity prevalence based on WHO reference and +2 cutoff</p>
</dd>
<dt>CDC95</dt><dd><p>obesity prevalence based on CDC reference and 95 cutoff</p>
</dd> </dl>



<h3>Details</h3>

<p>Note that the overweight prevalences are for overweight excluding obesity,
i.e. the prevalence for BMI between the overweight and obesity cutoffs.
</p>


<h3>Source</h3>

<p>The values are obtained from Table 2 of Deren et al (2020), recalculated to full accuracy.
<a href="https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0244300">https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0244300</a>.
</p>


<h3>References</h3>

<p>Deren K, Wyszynska J, Nyankovskyy S, Nyankovska O, Yatsula M,
Luszczki E, Sobolewski M, Mazur A. 2020. Assessment of body mass index in a
pediatric population aged 7-17 from Ukraine according to various
international criteria-A cross-sectional study. PLoS ONE 15.
</p>
<p>The IOTF reference for children aged 2-18 years is: Cole TJ, Bellizzi MC,
Flegal KM, Dietz WH. Establishing a standard definition for child overweight
and obesity worldwide: international survey. BMJ 2000; 320: 1240-5. Available
at <a href="https://doi.org/10.1136/bmj.320.7244.1240">doi:10.1136/bmj.320.7244.1240</a>
</p>
<p>The WHO reference for children aged 0-5 years is: WHO Child Growth Standards:
Length/height-for-age, weight-for-age, weight-for-length, weight-for-height
and body mass index-for-age: Methods and development. Geneva: World Health
Organization, 2006. Available at:
<a href="https://www.who.int/toolkits/child-growth-standards/standards">https://www.who.int/toolkits/child-growth-standards/standards</a>
</p>
<p>The WHO reference for children aged 5-19 years is: de Onis M, Onyango AW,
Borghi E, Siyam A, Nishida C, Siekmann J. Development of a WHO growth
reference for school-aged children and adolescents. Bulletin of the World
Health Organization 2007; 85: 660-7.
</p>
<p>The CDC reference for children aged 2-20 years is: Must A, Dallal GE, Dietz
WH. Reference data for obesity: 85th and 95th percentiles of body mass index
(wt/ht2) and triceps skinfold thickness. American Journal of Clinical
Nutrition 1991; 53: 839-46.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## convert IOTF obesity prevalence to WHO obesity prevalence
## and compare with true WHO obesity prevalence - boys and girls age 7-17
data(deren)
  ob_convertr(age = Age, sex = Sex, from = 'IOTF 30', to = 'WHO +2',
    pfrom = IOTF30, pto = `WHO+2`, data = deren, plot = 'compare')
</code></pre>

<hr>
<h2 id='dfpower'>Tabulate BIC of SITAR models by degrees of freedom, fixed effects and xy power transformations</h2><span id='topic+dfpower'></span>

<h3>Description</h3>

<p><code>dfpower</code> fits a series of <span class="pkg">sitar</span> models tabulated by combinations of
a) specified degrees of freedom for the spline curve,
b) specified fixed effects a, b, c, d,
c) specified power transformations of x, and
d) specified power transformations of y,
returning a four-way array of function values (e.g. BIC) applied to each model.
The function provides a convenient way to optimise the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfpower(
  object,
  df,
  fixed,
  xpowers,
  ypowers,
  FUN = BICadj,
  maxIter = 50,
  drop = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dfpower_+3A_object">object</code></td>
<td>
<p>fitted <span class="pkg">sitar</span> model to be updated.</p>
</td></tr>
<tr><td><code id="dfpower_+3A_df">df</code></td>
<td>
<p>vector of integer spline degrees of freedom to be fitted (defaults to <code>df</code> in <code>object</code>).</p>
</td></tr>
<tr><td><code id="dfpower_+3A_fixed">fixed</code></td>
<td>
<p>character vector of fixed effects to be included
(defaults to <code>fixed</code> in <code>object</code>, typically 'a + b + c').</p>
</td></tr>
<tr><td><code id="dfpower_+3A_xpowers">xpowers</code></td>
<td>
<p>vector of powers to apply to x (defaults to the power of x in <code>object</code>).</p>
</td></tr>
<tr><td><code id="dfpower_+3A_ypowers">ypowers</code></td>
<td>
<p>vector of powers to apply to y (defaults to the power of y in <code>object</code>).</p>
</td></tr>
<tr><td><code id="dfpower_+3A_fun">FUN</code></td>
<td>
<p>function to be tabulated (default <code>BICadj</code>).</p>
</td></tr>
<tr><td><code id="dfpower_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations per fit (default <code>nlmeControl()$maxIter</code>).</p>
</td></tr>
<tr><td><code id="dfpower_+3A_drop">drop</code></td>
<td>
<p>logical which if TRUE (default) drops redundant dimensions and labels from the returned array.</p>
</td></tr>
<tr><td><code id="dfpower_+3A_verbose">verbose</code></td>
<td>
<p>logical controlling monitoring, which gives <code>numIter</code> for each model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>xpowers</code> and <code>ypowers</code> treat power 0 as <code>log</code>. The formula for
<code>x</code> in <code>object</code> must be of the form <code>x^power</code> or <code>fun(x)</code>, e.g.
<code>x</code>, <code>x^0.5</code> or <code>log(x)</code>. More complex formulae e.g. <code>log(x + 1)</code>
will fail. In this case fit the model with the variable <code>x1 = x + 1</code> instead.
</p>
<p><code>FUN</code> can be any function returning a single numerical value, e.g.
<code>BICadj</code>, <code>BIC</code>, <code>AIC</code>, <code>varexp</code> or <code>sigma</code>.
</p>
<p>Other fixed effects in <code>object</code> for covariates in <code>a.formula</code>, <code>b.formula</code>,
<code>c.formula</code> or <code>d.formula</code> are propagated through all the models.
This also applies to the <code>control</code> argument if set in <code>object</code>.
</p>
<p>The run-time can be shortened by reducing <code>maxIter</code>,
as models often converge quickly or not at all.
</p>


<h3>Value</h3>

<p>Four-way array of returned values, ranked with the largest dimensions first,
and by default with single-level dimensions dropped.
</p>
<p>Values are returned with changed sign if the model fit generates a warning, or as
NA if there is an error.
</p>


<h3>Author(s)</h3>

<p>Tim Cole <a href="mailto:tim.cole@ucl.ac.uk">tim.cole@ucl.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+aperm">aperm</a></code> transposes the returned array;
<code><a href="stats.html#topic+addmargins">addmargins</a></code> adds margins.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(heights)
m1 &lt;- sitar(x = age, y = height, id = id, data = heights, df = 4)


dfpower(m1, df = 4:6, fixed = c('a', 'a+b', 'a+c', 'a+b+c'),
  xpowers = 0:1, ypowers = 0:1, maxIter = 8)

</code></pre>

<hr>
<h2 id='dfset'>Find degrees of freedom for a natural spline curve to minimise BIC or AIC</h2><span id='topic+dfset'></span>

<h3>Description</h3>

<p><code>dfset</code> fits a natural cubic spline for a range
of degrees of freedom, and returns the df minimising the BIC or AIC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfset(x, y, data = parent.frame(), FUN = BIC, df = 1:15, plot = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dfset_+3A_x">x</code></td>
<td>
<p>vector of x coordinates.</p>
</td></tr>
<tr><td><code id="dfset_+3A_y">y</code></td>
<td>
<p>vector of y coordinates.</p>
</td></tr>
<tr><td><code id="dfset_+3A_data">data</code></td>
<td>
<p>environment containing <code>x</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code id="dfset_+3A_fun">FUN</code></td>
<td>
<p>function to be minimised (e.g. BIC or AIC).</p>
</td></tr>
<tr><td><code id="dfset_+3A_df">df</code></td>
<td>
<p>vector of degrees of freedom to be searched.</p>
</td></tr>
<tr><td><code id="dfset_+3A_plot">plot</code></td>
<td>
<p>logical controlling plotting of FUN versus df.</p>
</td></tr>
<tr><td><code id="dfset_+3A_...">...</code></td>
<td>
<p>parameters to pass to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>degrees of freedom and value of FUN at minimum.
</p>


<h3>Author(s)</h3>

<p>Tim Cole <a href="mailto:tim.cole@ucl.ac.uk">tim.cole@ucl.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(heights)
dfset(age, height, heights, FUN=BIC, plot=TRUE)
dfset(age, height, heights, FUN=function(a) AIC(a, k=1))
</code></pre>

<hr>
<h2 id='funcall'>Function call with optional inverse</h2><span id='topic+funcall'></span>

<h3>Description</h3>

<p>Applies an expression to vector v, optionally inverting the expression
first. For example if the expression is log, funcall returns log(v) if
inverse is FALSE, and exp(v) if inverse is TRUE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funcall(v, vcall, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="funcall_+3A_v">v</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="funcall_+3A_vcall">vcall</code></td>
<td>
<p>expression</p>
</td></tr>
<tr><td><code id="funcall_+3A_inverse">inverse</code></td>
<td>
<p>logical</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Inverse covers functions log, exp, sqrt, ^, *, /, +, -.
</p>


<h3>Value</h3>

<p>Returns a vector of length v.
</p>


<h3>Author(s)</h3>

<p>Tim Cole <a href="mailto:tim.cole@ucl.ac.uk">tim.cole@ucl.ac.uk</a>
</p>

<hr>
<h2 id='getData.sitar'>Extract elements of fitted SITAR models</h2><span id='topic+getData.sitar'></span><span id='topic+getCovariate.sitar'></span><span id='topic+getVarCov.sitar'></span>

<h3>Description</h3>

<p>getData, getCovariate and getVarCov methods for <code>sitar</code> objects,
based on <code>lme</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sitar'
getData(object)

## S3 method for class 'sitar'
getCovariate(object, ...)

## S3 method for class 'sitar'
getVarCov(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getData.sitar_+3A_object">object</code>, <code id="getData.sitar_+3A_obj">obj</code></td>
<td>
<p>an object inheriting from class <code>sitar</code>.</p>
</td></tr>
<tr><td><code id="getData.sitar_+3A_...">...</code></td>
<td>
<p>other optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Respectively the data frame and <code>x</code> variable
used in the fit, and the returned variance-covariance matrix.
</p>


<h3>Author(s)</h3>

<p>Tim Cole <a href="mailto:tim.cole@ucl.ac.uk">tim.cole@ucl.ac.uk</a>
</p>

<hr>
<h2 id='getPeakTrough'>Identify peak or trough on curve</h2><span id='topic+getPeakTrough'></span><span id='topic+getPeak'></span><span id='topic+getTrough'></span><span id='topic+getTakeoff'></span>

<h3>Description</h3>

<p>Given vectors <code>x</code> and <code>y</code>, returns their values at the peak or
trough of the smooth (e.g. cubic spline) curve <code>y ~ x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPeakTrough(x, y = NULL, peak = TRUE, takeoff = FALSE)

getPeak(x, y = NULL, peak = TRUE, takeoff = FALSE)

getTrough(x, y = NULL, peak = FALSE, takeoff = FALSE)

getTakeoff(x, y = NULL, peak = FALSE, takeoff = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPeakTrough_+3A_x">x</code></td>
<td>
<p>vector.</p>
</td></tr>
<tr><td><code id="getPeakTrough_+3A_y">y</code></td>
<td>
<p>vector.</p>
</td></tr>
<tr><td><code id="getPeakTrough_+3A_peak">peak</code></td>
<td>
<p>logical determining whether peak or trough is returned.</p>
</td></tr>
<tr><td><code id="getPeakTrough_+3A_takeoff">takeoff</code></td>
<td>
<p>logical determining whether, if <code>peak</code> is FALSE, the
trough is takeoff.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Optionally the trough can be specified as takeoff, which is defined
for a growth velocity curve as the lowest velocity before the pubertal peak,
and if there is no peak then there is by definition no takeoff.
</p>


<h3>Value</h3>

<p>A length-2 vector containing the values of <code>x</code> and <code>y</code> at
the peak or trough. If none are identified NA's are returned.
</p>


<h3>Author(s)</h3>

<p>Tim Cole <a href="mailto:tim.cole@ucl.ac.uk">tim.cole@ucl.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create mean height velocity curve
data(heights)
m1 &lt;- sitar(age, height, id, heights, 4)
## plot velocity curve
plot(m1, 'v')
## mark peak, trough and takeoff
xy &lt;- plot_v(m1)
points(t(getPeak(xy)), pch=17)
points(t(getTrough(xy)), pch=25, col=2, bg=2)
points(t(getTakeoff(xy)), pch=25, col=3, bg=3)
</code></pre>

<hr>
<h2 id='heights'>Serial heights measured in 12 girls</h2><span id='topic+heights'></span>

<h3>Description</h3>

<p>Heights of 12 girls from the Chard Growth Study measured twice a year
between 8 and 16 years of age.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heights
</code></pre>


<h3>Format</h3>

<p>A data frame with 124 observations on the following 4 variables:
</p>

<dl>
<dt>id</dt><dd><p>factor of subject ids (levels 1:12).</p>
</dd>
<dt>age</dt><dd><p>vector of ages (years).</p>
</dd>
<dt>height</dt><dd><p>vector of heights (cm).</p>
</dd>
<dt>men</dt><dd><p>vector of ages at menarche (years), where negative values
are right censored.</p>
</dd> </dl>



<h3>Examples</h3>

<pre><code class='language-R'>  require(graphics)
  data(heights)
  coplot(height ~ age | id, data = heights, panel=panel.smooth,
    show.given=FALSE, xlab='age (years)', ylab='height (cm)', pch=19)
</code></pre>

<hr>
<h2 id='ifun'>Invert an expression defining a data transformation</h2><span id='topic+ifun'></span>

<h3>Description</h3>

<p>Given a transformed variable and the expression used to transform it, <code>ifun</code> creates
a function containing the inverse expression that will back-transform the variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifun(expr, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifun_+3A_expr">expr</code></td>
<td>
<p>a single-variable call or quoted expression to be inverted.
The variable's name in <code>expr</code> is referred to here as <code>varname</code>.</p>
</td></tr>
<tr><td><code id="ifun_+3A_verbose">verbose</code></td>
<td>
<p>a logical controlling printing of the intermediate functions
<code class="reqn">f(.)</code>, <code class="reqn">g(.)</code>, <code class="reqn">h(.)</code> etc (see 'Details').</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ifun</code> returns the inverting function such that
<code>ifun(expr)(eval(expr)) = varname</code>, where
<code>expr</code> can include any of the invertible functions in the <code>Math</code> and <code>Ops</code>
groups, plus <code>identity</code> and <code>I</code>.
</p>
<p>To illustrate its use, consider variants of the <code>sitar</code> model
<code>height ~ age</code> where <code>age</code> and/or <code>height</code> are transformed,
e.g. <code>height ~ log(age)</code> or <code>log(height) ~ sqrt(age)</code>. Each model
is of the form <code>y ~ x</code> but the units of <code>x</code> and <code>y</code> vary.
</p>
<p>The models are compared by plotting the fitted curves in their original units,
by first applying suitable functions to back-transform <code>x</code> and <code>y</code>.
For example with <code>log(age)</code>, where <code>expr = quote(log(age))</code>,
the function <code>ifun = function(x) exp(x)</code> back-transforms
<code>eval(expr)</code> to give <code>age</code>. See the first example.
</p>
<p><code>ifun</code> generalises this process for increasingly complex <code>expr</code>, as
the next two examples show.
</p>
<p>The final example shows <code>ifun</code> in action with <code><a href="#topic+plot.sitar">plot.sitar</a></code>,
which uses <code>ifun</code> as the default function for arguments <code>xfun</code> and
<code>yfun</code> - they are used to back-transform <code>x</code> and <code>y</code> using the
values of <code>expr</code> for <code>x</code> and <code>y</code> extracted from the model's
<code>sitar</code> call.
</p>
<p>Structuring <code>expr</code> suitably ensures it can be inverted - it should
contain a single mention of a single variable (<code>varname</code> here),
and possibly functions such as <code class="reqn">f(.)</code>, <code class="reqn">g(.)</code>, <code class="reqn">h(.)</code> etc
such that <code>expr</code> = <code class="reqn">f(g(h((varname))))</code>. The number of such functions
is in principle unlimited. <code>ifun</code> returns <code>function(x)</code>
<code class="reqn">h^{-1}(g^{-1}(f^{-1}((x))))</code>,
which ensures that
<code>expr</code> is invertible so long as the individual functions are invertible.
</p>


<h3>Value</h3>

<p>The required inverting function, with single argument <code>x</code>. Its
<code>"varname"</code> attribute contains <code>varname</code> as a character string.
</p>


<h3>Author(s)</h3>

<p>Tim Cole <a href="mailto:tim.cole@ucl.ac.uk">tim.cole@ucl.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.sitar">plot.sitar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## for best effect run all the code

## define varname variable
(age &lt;- 1:9)

## simple case - age transformed to log(age)
(expr &lt;- quote(log(age)))
## transformed age
eval(expr)
## inverting function, with "varname" attribute set to "age"
ifun(expr)
## inverted transformed age identical to age
all.equal(age, ifun(expr)(eval(expr)))

## more complex case - age transformed to log age since conception
(expr &lt;- quote(log(age + 0.75)))
## inverting function
ifun(expr)
## inverted transformed age identical to age
all.equal(age, ifun(expr)(eval(expr)))

## ludicrously complex case involving exp, log10, ^, pi and trigonometry
(expr &lt;- quote((exp(sin(pi * log10(age + 0.75)/2) - 1)^4)))
## inverting function, showing intermediate stages
ifun(expr, verbose=TRUE)
## identical to original
all.equal(age, ifun(expr)(eval(expr)))

## example of plot.sitar back-transforming transformed x and y in sitar models
## fit sitar models
m1 &lt;- sitar(x=age, y=height^2, id=id, data=heights, df=6)
m2 &lt;- update(m1, x=log(age+0.75), y=height)

## default plot options for xfun &amp; yfun back-transform x &amp; y to original scales
## xfun=ifun(x$call.sitar$x)
## yfun=ifun(x$call.sitar$y)
## compare mean curves for the two models where x &amp; y are on the original scales
plot(m1, 'd', las=1)
lines(m2, 'd', col=2)
</code></pre>

<hr>
<h2 id='iotf'>IOTF international body mass index reference</h2><span id='topic+iotf'></span>

<h3>Description</h3>

<p>The IOTF (International Obesity TaskForce) BMI growth reference
(Cole and Lobstein 2012), fitted by the LMS method and summarised by values
of L, M and S by sex and postnatal age from 2 to 18 years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iotf
</code></pre>


<h3>Format</h3>

<p>A tibble with 66 observations on the following 5 variables:
</p>

<dl>
<dt>years</dt><dd><p>numeric vector - postnatal age in years</p>
</dd>
<dt>L.bmi</dt><dd><p>numeric vector</p>
</dd>
<dt>M.bmi</dt><dd><p>numeric vector</p>
</dd>
<dt>S.bmi</dt><dd><p>numeric vector</p>
</dd>
<dt>sex</dt><dd><p>two-level factor with level 1 male and level 2 female</p>
</dd> </dl>



<h3>Details</h3>

<p>The IOTF cutoffs for overweight and obesity (and also thinness) (see
Cole et al 2000, 2007) can be obtained from this BMI reference.
See the example for how to convert between cutoffs and z-scores.
</p>
<p>The L, M and S values for each measurement correspond respectively to the
Box-Cox power, median and coefficient of variation of the distribution by
age and sex (Cole &amp; Green 1992). The measurement short name and units
for <code><a href="#topic+LMS2z">LMS2z</a></code> are bmi (kg/m2).
</p>


<h3>Source</h3>

<p>The values are tabulated in the Excel spreadsheet IOTF_LMS.xls
provided with the Excel add-in LMSgrowth from
https://www.healthforallchildren.com/shop-base/software/lmsgrowth/
</p>


<h3>References</h3>

<p>Cole TJ, Green PJ. Smoothing reference centile curves: the LMS
method and penalized likelihood. Stat Med 1992;11:1305-19.
</p>
<p>Cole TJ, Bellizzi MC, Flegal KM, Dietz WH. Establishing a standard
definition for child overweight and obesity worldwide: international survey.
BMJ 2000;320:1240-3.
</p>
<p>Cole TJ, Flegal KM, Nicholls D, Jackson AA. Body mass index cut offs to
define thinness in children and adolescents: international survey.
BMJ 2007;335:194-7.
</p>
<p>Cole TJ, Lobstein T. Extended international (IOTF) body mass index cut-offs
for thinness, overweight and obesity. Ped Obes 2012;7:284-94.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iotf)
## calculate z-scores by sex corresponding to IOTF cutoffs for thinness,
## overweight and obesity
co &lt;- data.frame(cutoff = c(16, 17, 18.5, 25, 30),
  grade = c('thinness 3', 'thinness 2', 'thinness 1',
    'overweight', 'obesity'))
sexes &lt;- c('boys', 'girls')
with(co,
  cbind(co, lapply(setNames(sexes, sexes), function(x)
    LMS2z(x = 18, y = cutoff, sex = x,
          measure = 'bmi', ref = 'iotf'))))
</code></pre>

<hr>
<h2 id='LMS2z'>Convert to/from measurement from/to z-score with growth reference</h2><span id='topic+LMS2z'></span>

<h3>Description</h3>

<p>A function to convert between measurements and z-scores using a growth
reference previously fitted by the LMS method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LMS2z(x, y, sex, measure, ref, toz = TRUE, LMStable = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LMS2z_+3A_x">x</code></td>
<td>
<p>vector of ages in units of years.</p>
</td></tr>
<tr><td><code id="LMS2z_+3A_y">y</code></td>
<td>
<p>vector or one-column matrix of either measurements or z-scores,
depending on the value of <code>toz</code>.</p>
</td></tr>
<tr><td><code id="LMS2z_+3A_sex">sex</code></td>
<td>
<p>vector where 1/2 = males/females = boys/girls = TRUE/FALSE, based
on the uppercased first character of the string.</p>
</td></tr>
<tr><td><code id="LMS2z_+3A_measure">measure</code></td>
<td>
<p>unique measurement name, as character string, the choice depending on
the choice of <code>ref</code> (see e.g. references <code>uk90</code>, <code>who06</code> and
<code>ukwhopt</code>).</p>
</td></tr>
<tr><td><code id="LMS2z_+3A_ref">ref</code></td>
<td>
<p>unique growth reference, either as name or character string, available as
a <code>data</code> object or data frame (e.g. <code>uk90</code>, <code>who06</code> or
<code>ukwhopt</code>).</p>
</td></tr>
<tr><td><code id="LMS2z_+3A_toz">toz</code></td>
<td>
<p>logical set to TRUE for conversion from measurement to z-score, or
FALSE for the reverse.</p>
</td></tr>
<tr><td><code id="LMS2z_+3A_lmstable">LMStable</code></td>
<td>
<p>logical set to TRUE to return the associated LMS table as a
data frame in attribute <code>LMStable</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Growth references fitted by the LMS method consist of a table of L, M and S
values by age and sex. Vectors of L, M and S corresponding to <code>x</code> and
<code>sex</code> are extracted using cubic interpolation and passed to either
<code><a href="#topic+cLMS">cLMS</a></code> or <code><a href="#topic+zLMS">zLMS</a></code>, depending on <code>toz</code>.
</p>
<p>Disjunct references are supported, where there is a disjunction in the
centiles at a particular age. This may be because the measurement changes,
e.g. from length to height, or because two different references have been
joined together. The disjunction is flagged by including two rows at the
common age, but with different L, M and S values, and measurements at this
age are ascribed to the older reference. For example the <code>who06</code>
reference has a disjunction at 2 years reflecting the switch from length to
height. As a result height at just below and just above 2 years returns a
different z-score.
</p>


<h3>Value</h3>

<p>A vector or matrix containing the transformed values. If <code>y</code> is
a vector then a vector of <code>length(x)</code> is returned, else if <code>y</code> is
a one-column matrix then a matrix is returned, with <code>length(x)</code> rows
and <code>length(y)</code> columns. The matrix row names are set to <code>x</code>, and
the column names to either <code>y</code> or if <code>toz</code> is FALSE,
<code>z2cent(y)</code>. If LMStable is TRUE the associated LMS table is returned
as a data frame in attribute <code>LMStable</code>.
</p>


<h3>Author(s)</h3>

<p>Tim Cole <a href="mailto:tim.cole@ucl.ac.uk">tim.cole@ucl.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+z2cent">z2cent</a></code>. The LMS method can be fitted to data using the
package <code>gamlss</code> with the <code>BCCG</code> or <code>BCCGo</code> family, where nu
(originally lambda), mu and sigma correspond to L, M and S respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## convert girls' heights data to UK 90 z-scores
data(heights)
data(uk90)
with(heights, LMS2z(age, height, sex = 2, measure = 'ht', ref = 'uk90'))

## construct table of boys' weight centiles by age for WHO standard
data(who06)
zs &lt;- -4:4*2/3 # z-scores for 9 centiles
ages &lt;- 0:20/4 # 3-month ages to 5 years
LMS2z(ages, as.matrix(zs), sex = 'm', measure = 'wt', ref = who06,
  toz = FALSE, LMStable = TRUE)

</code></pre>

<hr>
<h2 id='LMSfit'>Estimate LMS curves from tabulated growth reference centiles</h2><span id='topic+LMSfit'></span>

<h3>Description</h3>

<p>A function to summarise an existing set of growth reference centiles as the
L, M and S curves of the LMS method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LMSfit(
  x,
  y,
  sex,
  data = parent.frame(),
  centiles = c(3, 10, 25, 50, 75, 90, 97),
  df = c(6, 10, 8),
  L1 = FALSE,
  plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LMSfit_+3A_x">x</code></td>
<td>
<p>vector of tabulated ages.</p>
</td></tr>
<tr><td><code id="LMSfit_+3A_y">y</code></td>
<td>
<p>matrix of corresponding measurement centiles, e.g. of height or
weight, with <code>nrows = length(x)</code> and <code>ncols = length(centiles)</code>.</p>
</td></tr>
<tr><td><code id="LMSfit_+3A_sex">sex</code></td>
<td>
<p>two-level factor where level 1 corresponds to male and level 2 to
female.</p>
</td></tr>
<tr><td><code id="LMSfit_+3A_data">data</code></td>
<td>
<p>optional data frame containing <code>x</code>, <code>y</code> and
<code>sex</code>.</p>
</td></tr>
<tr><td><code id="LMSfit_+3A_centiles">centiles</code></td>
<td>
<p>vector of centiles corresponding to the columns of <code>y</code>,
default c(3, 10, 25, 50, 75, 90, 97).</p>
</td></tr>
<tr><td><code id="LMSfit_+3A_df">df</code></td>
<td>
<p>length-3 vector with the cubic smoothing spline equivalent degrees
of freedom (edf) for the L, M and S curves, default c(6, 10, 8).</p>
</td></tr>
<tr><td><code id="LMSfit_+3A_l1">L1</code></td>
<td>
<p>logical constraining the L curve to 1, i.e. a Normal distribution,
default FALSE.</p>
</td></tr>
<tr><td><code id="LMSfit_+3A_plot">plot</code></td>
<td>
<p>logical to plot the estimated L, M and S curves, default TRUE.</p>
</td></tr>
<tr><td><code id="LMSfit_+3A_...">...</code></td>
<td>
<p>optional graphical parameters for the plots.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At each age the optimal Box-Cox power Lopt is estimated to render the
centiles closest to Normal, and the corresponding median Mopt and
coefficient of variation Sopt are derived. The three sets of values are then
smoothed across age to give L, M and S.
</p>


<h3>Value</h3>

<p>A list with the results: </p>
 <dl>
<dt>list(&quot;LMS&quot;)</dt><dd><p>data frame of
sex, x, L, M, S, Lopt, Mopt, Sopt.</p>
</dd> <dt>list(&quot;ey&quot;)</dt><dd><p>matrix of predicted
values of <code>y</code>.</p>
</dd> <dt>list(&quot;ez&quot;)</dt><dd><p>matrix of predicted
values of <code>z</code>.</p>
</dd> <dt>list(&quot;fit&quot;)</dt><dd><p>matrix of summary statistics for
<code>ey</code>, giving for each column <code>cmean</code> the mean centile, <code>zmean</code>
the mean z-score, <code>zSD</code> the SD of the z-score, and <code>zmin</code> and
<code>zmax</code> the minimum and maximum z-scores.</p>
</dd> </dl>



<h3>Author(s)</h3>

<p>Tim Cole <a href="mailto:tim.cole@ucl.ac.uk">tim.cole@ucl.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LMS2z">LMS2z</a></code>, <code><a href="#topic+z2cent">z2cent</a></code>. The LMS method can be
fitted to data using the package <code>gamlss</code> with the <code>BCCG</code> family,
where nu (originally lambda), mu and sigma correspond to L, M and S
respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## first construct table of boys weight centiles by age for WHO standard
data(who06)
zs &lt;- -4:4*2/3 # z-scores for centiles
ages &lt;- 0:12/4 # ages 0-3 years by 3 months
v &lt;- vapply(as.list(zs), function(z)
 LMS2z(ages, z, sex = 1, measure = 'wt', ref = 'who06', toz = FALSE),
  rep(0, length(ages)))
round(v, 2)

## then back-calculate the original LMS curves and display summary statistics
LMSfit(x=ages, y=v, sex=1, centiles=pnorm(zs)*100, plot=FALSE)

</code></pre>

<hr>
<h2 id='mplot'>Plot multiple growth curves</h2><span id='topic+mplot'></span>

<h3>Description</h3>

<p>Function to plot multiple growth curves indexed by subject id.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mplot(x, y, id, data = parent.frame(), subset = NULL, add = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mplot_+3A_x">x</code></td>
<td>
<p>vector of x coordinates.</p>
</td></tr>
<tr><td><code id="mplot_+3A_y">y</code></td>
<td>
<p>vector of y coordinates.</p>
</td></tr>
<tr><td><code id="mplot_+3A_id">id</code></td>
<td>
<p>factor denoting subject levels.</p>
</td></tr>
<tr><td><code id="mplot_+3A_data">data</code></td>
<td>
<p>optional dataframe containing <code>x</code>, <code>y</code> and <code>id</code>.</p>
</td></tr>
<tr><td><code id="mplot_+3A_subset">subset</code></td>
<td>
<p>optional logical defining a subset of rows in <code>data</code>.</p>
</td></tr>
<tr><td><code id="mplot_+3A_add">add</code></td>
<td>
<p>optional logical defining whether the plot is pre-existing (TRUE)
or new (FALSE).</p>
</td></tr>
<tr><td><code id="mplot_+3A_...">...</code></td>
<td>
<p>Further graphical parameters (see <code><a href="graphics.html#topic+par">par</a></code>) may also
be supplied as arguments, particularly background colour <code>bg</code>,
character expansion <code>cex</code>, colour <code>col</code>, line type <code>lty</code>,
line width <code>lwd</code> and character <code>pch</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments <code>x</code>, <code>y</code> and <code>id</code> can be given as character
strings. The <code><a href="graphics.html#topic+par">par</a></code> parameters can be functions of vector
variables in <code>data</code>, e.g. to colour curves separately by <code>id</code> use:
<code>col = id</code>.
</p>


<h3>Author(s)</h3>

<p>Tim Cole <a href="mailto:tim.cole@ucl.ac.uk">tim.cole@ucl.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mplot(age, height, id, heights, col=id)

</code></pre>

<hr>
<h2 id='ob_convertr'>Convert between IOTF, WHO and CDC prevalence rates for child thinness,
overweight and obesity</h2><span id='topic+ob_convertr'></span><span id='topic+ob_convertr2'></span>

<h3>Description</h3>

<p>Child thinness, overweight and obesity are defined as the child's body mass
index (BMI) lying beyond a pre-specified reference cutoff. Three references
are compared: IOTF (International Obesity Task Force), WHO (World Health
Organization) and CDC (US Centers for Disease Control and Prevention), each
of which have their own cutoffs. <code>ob_convertr</code> takes age-sex-specific
prevalence rates of thinness, overweight or obesity based on one of the cutoffs,
and converts them to the corresponding rates based on a different cutoff.
<code>ob_convertr2</code> uses paired prevalence rates of overweight and obesity on
one cutoff to estimate those based on another cutoff.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ob_convertr(
  age,
  sex,
  from,
  to,
  pfrom = NA,
  pto = NA,
  data = parent.frame(),
  report = c("vector", "wider", "longer"),
  plot = c("no", "density", "compare")
)

ob_convertr2(
  age,
  sex,
  from,
  to,
  pfrom = NA,
  pto = NA,
  data = parent.frame(),
  report = c("vector", "wider", "longer"),
  plot = c("no", "density", "compare")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ob_convertr_+3A_age">age</code></td>
<td>
<p>vector of ages between 2 and 18 years corresponding to prevalence rates <code>pfrom</code>.</p>
</td></tr>
<tr><td><code id="ob_convertr_+3A_sex">sex</code></td>
<td>
<p>vector of sexes corresponding to <code>pfrom</code>, coded as either
'boys/girls' or 'male/female' or '1/2' (upper or lower case, based on the
first character).</p>
</td></tr>
<tr><td><code id="ob_convertr_+3A_from">from</code></td>
<td>
<p>name(s) of the BMI cutoff(s) on which the prevalence <code>pfrom</code>
is based (see Details).</p>
</td></tr>
<tr><td><code id="ob_convertr_+3A_to">to</code></td>
<td>
<p>name(s) of the BMI cutoff(s) on which to base the
predicted prevalence (see Details).</p>
</td></tr>
<tr><td><code id="ob_convertr_+3A_pfrom">pfrom</code></td>
<td>
<p>vector of age-sex-specific percentage prevalence rates
based on <code>from</code> (<code>ob_convertr</code>) or the names of two or more such
prevalence rates (<code>ob_convertr2</code>).</p>
</td></tr>
<tr><td><code id="ob_convertr_+3A_pto">pto</code></td>
<td>
<p>vector (needed for <code>plot = "compare"</code>) of known percentage prevalence rates
based on <code>to</code> (<code>ob_convertr</code>) or the names of two or more such
prevalence rates (<code>ob_convertr2</code>).</p>
</td></tr>
<tr><td><code id="ob_convertr_+3A_data">data</code></td>
<td>
<p>optional data frame containing <code>age</code>, <code>sex</code>, <code>pfrom</code> and
<code>pto</code>.</p>
</td></tr>
<tr><td><code id="ob_convertr_+3A_report">report</code></td>
<td>
<p>character controlling the format of the returned data: 'vector'
for the estimated prevalence rates, 'wider' for the working tibble in wide
format, i.e. the <code>from</code> and <code>to</code> data side by side, or 'longer'
for the tibble in long format, i.e. two rows per rate, one for <code>from</code>
and one for <code>to</code>. For <code>ob_convertr2</code> the three settings return
progressively more information.</p>
</td></tr>
<tr><td><code id="ob_convertr_+3A_plot">plot</code></td>
<td>
<p>character controlling what if anything is plotted: 'no' for no
plot, 'density' to display the BMI density distributions and cutoffs
corresponding to <code>from</code> and <code>to</code>, or 'compare' to display the
predicted prevalence rates plotted against the observed rates (<code>pto</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The IOTF cutoffs correspond to the value of BMI
(kg/m<sup>2</sup>) at age 18: IOTF 35
(morbid obesity), IOTF 30 (obesity), IOTF 25 (overweight), IOTF 18.5 (grade 1
thinness), IOTF 17 (grade 2 thinness) and IOTF 16 (grade 3 thinness).
</p>
<p>The WHO cutoffs correspond to BMI z_scores. Age 5-19 years, WHO +2 (obesity),
WHO +1 (overweight) and WHO -2 (thinness). Age 0-5 years, WHO +3 (obesity),
WHO +2 (overweight) and WHO -2 (thinness).
</p>
<p>The CDC cutoffs correspond to BMI centiles: CDC 95 (obesity), CDC 85
(overweight) and CDC 5 (thinness).
</p>
<p>Note: the overweight category needs to be analysed as overweight prevalence plus
obesity prevalence, i.e. the prevalence above the overweight cutoff. To predict
overweight prevalence excluding obesity prevalence, first calculate predicted
overweight prevalence including obesity then subtract predicted obesity prevalence.
</p>
<p>The algorithms for <code>ob_convertr</code> and <code>ob_convertr2</code> are distinguished
by the number of prevalence rates used for the prediction. For <code>ob_convertr</code>
(Cole &amp; Lobstein, 2022) just one
rate is used &ndash; in this case the algorithm is commutative, meaning that
converting a prevalence rate from cutoff A to cutoff B and then from B to A
returns the original value. <code>from</code> and <code>to</code> are
the names of the cutoffs, and <code>pfrom</code> and optionally <code>pto</code> are vectors
of percentage prevalence rates.
</p>
<p><code>ob_convertr2</code> uses two known prevalence rates (Cole &amp; Lobstein, 2023),
typically overweight and obesity based on one reference, returning the corresponding
rates based on another reference. It is more accurate than <code>ob_convertr</code> though
not exactly commutative. <code>from</code> and <code>to</code> are the names of the cutoffs as length-2
character strings, while <code>pfrom</code> and optionally <code>pto</code> are length-2
character strings giving the names of the corresponding vector prevalence rates.
For convenience the <code>from</code> or <code>to</code> names 'CDC', 'IOTF' or 'WHO'
expand to the corresponding pairs of cutoffs for overweight and obesity,
e.g. 'CDC' expands to c('CDC 85', 'CDC 95').
</p>
<p>Alternatively <code>ob_convertr2</code> can be used to interpolate or extrapolate
to one or more specified z-score cutoffs assuming the same reference for all cutoffs.
Here the values of <code>from</code> and <code>to</code> are numerical z-score cutoffs,
with at least two for <code>from</code>. See the final example.
</p>
<p>The algorithms require the prevalences of obesity and overweight net of obesity
to be non-zero, and if they are zero they are set to missing.
</p>


<h3>Value</h3>

<p>The predicted prevalence rates, optionally with a plot visualizing the
findings, depending on the <code>report</code> and <code>plot</code> settings. Each
predicted rate is given the name of the relevant cutoff followed by &quot; pred&quot;.
</p>
<p>With <code>report</code> set to &quot;wider&quot; or &quot;longer&quot;, extra information
is returned reflecting the internal workings of the algorithms. In particular
<code>ob_convertr2</code> returns <code>b</code> the regression coefficient of z-score
prevalence on z-score cutoff as described in Cole &amp; Lobstein (2023).
</p>
<p>If a <code>plot</code> is selected, the underlying data and plot are returned
invisibly with names <code>data</code> and <code>plot</code>.
</p>


<h3>Author(s)</h3>

<p>Tim Cole <a href="mailto:tim.cole@ucl.ac.uk">tim.cole@ucl.ac.uk</a>
</p>


<h3>References</h3>

<p>Cole TJ, Lobstein T. Exploring an algorithm to harmonize International Obesity
Task Force and World Health Organization child overweight and obesity prevalence
rates. Pediatr Obes 2022;17:e12905. Available at <a href="https://doi.org/10.1111/ijpo.12905">doi:10.1111/ijpo.12905</a>
</p>
<p>Cole TJ, Lobstein T. An improved algorithm to harmonize child overweight and
obesity prevalence rates. Pediatr Obes 2023;18:e12970. Available at <a href="https://doi.org/10.1111/ijpo.12970">doi:10.1111/ijpo.12970</a>
</p>
<p>The CDC reference for children aged 2-20 years is: Must A, Dallal GE, Dietz
WH. Reference data for obesity: 85th and 95th percentiles of body mass index
(wt/ht2) and triceps skinfold thickness. American Journal of Clinical
Nutrition 1991; 53: 839-46.
</p>
<p>The IOTF reference for children aged 2-18 years is: Cole TJ, Bellizzi MC,
Flegal KM, Dietz WH. Establishing a standard definition for child overweight
and obesity worldwide: international survey. BMJ 2000; 320: 1240-5. Available
at <a href="https://doi.org/10.1136/bmj.320.7244.1240">doi:10.1136/bmj.320.7244.1240</a>
</p>
<p>The WHO reference for children aged 0-5 years is: WHO Child Growth Standards:
Length/height-for-age, weight-for-age, weight-for-length, weight-for-height
and body mass index-for-age: Methods and development. Geneva: World Health
Organization, 2006. Available at:
<a href="https://www.who.int/toolkits/child-growth-standards/standards">https://www.who.int/toolkits/child-growth-standards/standards</a>
</p>
<p>The WHO reference for children aged 5-19 years is: de Onis M, Onyango AW,
Borghi E, Siyam A, Nishida C, Siekmann J. Development of a WHO growth
reference for school-aged children and adolescents. Bulletin of the World
Health Organization 2007; 85: 660-7.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## convert 10% IOTF overweight prevalence (cutoff IOTF 25, including obesity)
## in 8-year-old boys to overweight prevalence for cutoff WHO +1
ob_convertr(age = 8, sex = 'boys', from = 'IOTF 25', to = 'WHO +1', pfrom = 10)

## compare the BMI density functions and cutoffs for IOTF and WHO
## in 8-year-old boys
ob_convertr2(age = 8, sex = 'boys', from = 'IOTF', to = 'WHO', plot = 'density')

## convert IOTF overweight prevalence to WHO overweight prevalence
## and compare with true value - boys and girls aged 7-17 (22 groups)
## note the need to first add obesity prevalence to overweight prevalence
data(deren)
deren &lt;- within(deren, {
  CDC85 = CDC85 + CDC95
  IOTF25 = IOTF25 + IOTF30
  `WHO+1` = `WHO+1` + `WHO+2`})
ob_convertr(age = Age, sex = Sex, from = 'IOTF 25', to = 'WHO +1',
  pfrom = IOTF25, pto = `WHO+1`, data = deren, plot = 'compare')

## convert IOTF overweight and obesity prevalence to WHO using
## ob_convertr2 - which is more accurate than ob_convertr
ob_convertr2(age = Age, sex = Sex, from = 'IOTF', to = 'WHO',
  pfrom = c('IOTF25', 'IOTF30'), pto = c('WHO+1', 'WHO+2'),
  data = deren, plot = 'compare')

## extrapolate WHO overweight and obesity prevalence (cutoffs +1 and +2)
## to severe obesity prevalence based on cutoffs +2.5 or +3
ob_convertr2(Age, Sex, from = 1:2, to = c(2.5, 3),
  pfrom = c('WHO+1', 'WHO+2'), data = deren, report = 'wider')

</code></pre>

<hr>
<h2 id='optimal_design'>Optimal design for growth reference centile studies</h2><span id='topic+optimal_design'></span><span id='topic+n_agegp'></span>

<h3>Description</h3>

<p>Two functions for estimating optimal sample size and sample composition
when constructing growth reference centiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimal_design(z = -2, lambda = NA, N = NA, SEz = NA, age = 10)

n_agegp(
  z = -2,
  lambda = NA,
  N = NA,
  SEz = NA,
  minage = 0,
  maxage = 20,
  n_groups = 20
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optimal_design_+3A_z">z</code></td>
<td>
<p>z-score on which to base the design, with default -2 which
equates to the 2nd centile. If NA, optimal z is calculated from lambda.</p>
</td></tr>
<tr><td><code id="optimal_design_+3A_lambda">lambda</code></td>
<td>
<p>power of age that defines the sample composition.
The default NA means calculate optimal lambda from z.</p>
</td></tr>
<tr><td><code id="optimal_design_+3A_n">N</code></td>
<td>
<p>total sample size per sex. The default NA means calculate from
z or lambda, and SEz if provided.</p>
</td></tr>
<tr><td><code id="optimal_design_+3A_sez">SEz</code></td>
<td>
<p>target z-score standard error. The default NA means calculate
from z or lambda, and N if provided.</p>
</td></tr>
<tr><td><code id="optimal_design_+3A_age">age</code></td>
<td>
<p>age at which to calculate SEz. The default 10 returns mean SEz,
and if z or lambda are optimal SEz is independent of age.</p>
</td></tr>
<tr><td><code id="optimal_design_+3A_minage">minage</code></td>
<td>
<p>youngest age (default 0).</p>
</td></tr>
<tr><td><code id="optimal_design_+3A_maxage">maxage</code></td>
<td>
<p>oldest age (default 20).</p>
</td></tr>
<tr><td><code id="optimal_design_+3A_n_groups">n_groups</code></td>
<td>
<p>number of age groups (default 20).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Studies to construct growth reference centiles using <code>GAMLSS</code> need to
be of optimal size. Cole (SMMR, 2020) has shown that
the sample composition, i.e. the age distribution of the measurements,
needs to be optimised as well as the sample size. Sample composition is defined in terms of the age power
lambda which determines the degree of infant oversampling.
</p>
<p>There are two criteria that determine the optimal sample size and sample
composition: the centile of interest (as z-score z) and the required level
of precision for that centile (as the z-score standard error SEz).
</p>


<h3>Value</h3>

<p>For optimal_design, a tibble with columns:
</p>
<table role = "presentation">
<tr><td><code>z</code></td>
<td>
<p>as above.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>as above.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>as above.</p>
</td></tr>
<tr><td><code>SEz</code></td>
<td>
<p>as above.</p>
</td></tr>
<tr><td><code>age</code></td>
<td>
<p>as above.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>the centile corresponding to z.</p>
</td></tr>
<tr><td><code>plo</code></td>
<td>
<p>lower 95% confidence interval for p.</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>upper 95% confidence interval for p.</p>
</td></tr>
</table>
<p>For n_agegp, a tibble giving the numbers of measurements to be collected
per equal width age group, with columns:
</p>
<table role = "presentation">
<tr><td><code>n_varying</code></td>
<td>
<p>numbers for equal width age groups.</p>
</td></tr>
<tr><td><code>age</code></td>
<td>
<p>mean ages for equal width age groups.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number for each unequal width age group (only for longitudinal studies).</p>
</td></tr>
<tr><td><code>age_varying</code></td>
<td>
<p>target ages for unequal width age groups (only for longitudinal studies).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tim Cole <a href="mailto:tim.cole@ucl.ac.uk">tim.cole@ucl.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code>gamlss</code> to fit the centiles
with the <code>BCCG</code>, <code>BCT</code> or <code>BCPE</code> family.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## estimate optimal sample composition lambda and precision SEz for 9 centiles
## spaced 2/3 of a z-score apart, based on a sample of 10,000 children

optimal_design(z = -4:4*2/3, N = 10000)

## calculate age group sizes optimised for centiles from the 50th to the 99.6th
## (or equivalently from the 50th to the 0.4th)
## with a sample of 10,000 children from 0 to 20 years in one-year groups

purrr::map_dfc(0:4*2/3, ~{
  n_agegp(z = .x, N = 10000) %&gt;%
      dplyr::select(!!z2cent(.x) := n_varying)
      }) %&gt;%
        dplyr::bind_cols(tibble::tibble(age = paste(0:19, 1:20, sep='-')), .)
</code></pre>

<hr>
<h2 id='pdLMS'>Plot frequency distributions(s) for given L, M and S values in LMS method</h2><span id='topic+pdLMS'></span>

<h3>Description</h3>

<p>The LMS method defines frequency distributions in terms of L, M and S parameters.
<code>pdLMS</code> plots one or more LMS distributions and optionally returns specified
centiles on each distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdLMS(
  L = 1,
  M = 1,
  S = 0.2,
  zcent = NULL,
  zlim = 3.5,
  N = 1000,
  plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pdLMS_+3A_l">L</code></td>
<td>
<p>vector of Box-Cox transformation (lambda) values, L in the LMS
method (default 1 corresponding to the Normal distribution).</p>
</td></tr>
<tr><td><code id="pdLMS_+3A_m">M</code></td>
<td>
<p>vector of medians (mu), M in the LMS method (default 1).</p>
</td></tr>
<tr><td><code id="pdLMS_+3A_s">S</code></td>
<td>
<p>vector of coefficients of variation (sigma), S in the LMS method
(default 0.2).</p>
</td></tr>
<tr><td><code id="pdLMS_+3A_zcent">zcent</code></td>
<td>
<p>optional vector of z-scores for conversion to the measurement
scale under each distribution.</p>
</td></tr>
<tr><td><code id="pdLMS_+3A_zlim">zlim</code></td>
<td>
<p>scalar defining z-score limits underlying x-axis (default 3.5).</p>
</td></tr>
<tr><td><code id="pdLMS_+3A_n">N</code></td>
<td>
<p>number of points per distribution curve (default 1000).</p>
</td></tr>
<tr><td><code id="pdLMS_+3A_plot">plot</code></td>
<td>
<p>logical for plotting (default TRUE).</p>
</td></tr>
<tr><td><code id="pdLMS_+3A_...">...</code></td>
<td>
<p>Further graphical parameters (see <code><a href="graphics.html#topic+par">par</a></code>) may also
be supplied as arguments, particularly colour <code>col</code>, line type <code>lty</code>,
line width <code>lwd</code> and character <code>pch</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>L, M and S should all be the same length, recycled if necessary.
</p>


<h3>Value</h3>

<p>An invisible list with the following components:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>vector of x values for plotting.</p>
</td></tr>
<tr><td><code>density</code></td>
<td>
<p>matrix of densities for each distribution.</p>
</td></tr>
<tr><td><code>centile</code></td>
<td>
<p>matrix of measurement centiles corresponding to <code>zcent</code>
under each distribution.</p>
</td></tr>
</table>
<p>The distributions can be plotted with <code>matplot(x, density, type='l')</code>.
</p>


<h3>Author(s)</h3>

<p>Tim Cole <a href="mailto:tim.cole@ucl.ac.uk">tim.cole@ucl.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+z2cent">z2cent</a></code>, <code><a href="#topic+LMS2z">LMS2z</a></code>, <code><a href="#topic+cLMS">cLMS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## plot normal distribution
pdLMS()
## compare variety of distributions
## with centiles corresponding to +3 z-scores
pdLMS(L=-2:3, M=2:3, S=1:3/10, zcent=3, lty=1)

</code></pre>

<hr>
<h2 id='plot.sitar'>Plot SITAR model</h2><span id='topic+plot.sitar'></span><span id='topic+lines.sitar'></span><span id='topic+plot_d'></span><span id='topic+plot_v'></span><span id='topic+plot_D'></span><span id='topic+plot_V'></span><span id='topic+plot_u'></span><span id='topic+plot_a'></span><span id='topic+plot_c'></span>

<h3>Description</h3>

<p><code>plot</code> and <code>lines</code> methods for objects of class <code>sitar</code>,
providing various flavours of plot of the fitted growth curves. Also helper
functions to return the data for plotting, e.g. with <code>ggplot2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sitar'
plot(
  x,
  opt = "dv",
  labels = NULL,
  apv = FALSE,
  xfun = identity,
  yfun = identity,
  subset = NULL,
  ns = 101,
  design = NULL,
  abc = NULL,
  trim = 0,
  add = FALSE,
  nlme = FALSE,
  returndata = FALSE,
  ...,
  xlab = NULL,
  ylab = NULL,
  vlab = NULL,
  xlim = c(NA, NA),
  ylim = c(NA, NA),
  vlim = c(NA, NA),
  legend = list(x = "topleft", inset = 0.04, bty = "o")
)

## S3 method for class 'sitar'
lines(x, ...)

plot_d(x, ...)

plot_v(x, ...)

plot_D(x, ...)

plot_V(x, ...)

plot_u(x, ...)

plot_a(x, ...)

plot_c(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.sitar_+3A_x">x</code></td>
<td>
<p>object of class <code>sitar</code>.</p>
</td></tr>
<tr><td><code id="plot.sitar_+3A_opt">opt</code></td>
<td>
<p>character string containing a subset of letters corresponding to
the options: 'd' for fitted Distance curve, 'v' for fitted Velocity curve,
'c' for fitted Crosssectional distance curve, 'D' for individual fitted
Distance curves, 'V' for individual fitted Velocity curves, 'u' for
Unadjusted individual growth curves, and 'a' for Adjusted individual growth
curves. Options 'dvcDV' give spline curves, while 'ua' give data curves made
up as line segments. If both distance and velocity curves are specified, the
axis for the velocity curve appears on the right side of the plot (y2), and
a legend identifying the distance and velocity curves is provided.</p>
</td></tr>
<tr><td><code id="plot.sitar_+3A_labels">labels</code></td>
<td>
<p>optional character vector containing plot labels for <code>x</code>,
<code>y</code> and <code>y</code> velocity from the original SITAR model. The three
elements can alternatively be provided via parameters
<code>xlab</code>, <code>ylab</code> and <code>vlab</code>. The latter take precedence.
Default labels are the names of <code>x</code> and <code>y</code>, and
&quot;<code>y</code> velocity&quot;, suitably adjusted to reflect any back-transformation
via <code>xfun</code> and <code>yfun</code>.</p>
</td></tr>
<tr><td><code id="plot.sitar_+3A_apv">apv</code></td>
<td>
<p>optional logical specifying whether or not to calculate the age
at peak velocity from the velocity curve. If TRUE, age at peak velocity is
calculated as the age when the second derivative of the fitted curve changes
from positive to negative (after applying <code>xfun</code> and/or <code>yfun</code>). Age at peak velocity
is marked in the plot with a vertical dotted line, and its value, along with
peak velocity, is printed and returned. NB their standard errors can be
obtained using the bootstrap with the function <code>apv_se</code>. Values of <code>apv</code>
for individual subjects or groups are also returned invisibly.</p>
</td></tr>
<tr><td><code id="plot.sitar_+3A_xfun">xfun</code></td>
<td>
<p>optional function to be applied to the x variable prior to
plotting (default identity, see Details).</p>
</td></tr>
<tr><td><code id="plot.sitar_+3A_yfun">yfun</code></td>
<td>
<p>optional function to be applied to the y variable prior to
plotting (default identity, see Details).</p>
</td></tr>
<tr><td><code id="plot.sitar_+3A_subset">subset</code></td>
<td>
<p>optional logical vector of length <code>x</code> defining a subset
of <code>data</code> rows to be plotted, for <code>x</code> and <code>data</code> in the
original <code>sitar</code> call.</p>
</td></tr>
<tr><td><code id="plot.sitar_+3A_ns">ns</code></td>
<td>
<p>scalar defining the number of points for spline curves
(default 101).</p>
</td></tr>
<tr><td><code id="plot.sitar_+3A_design">design</code></td>
<td>
<p>formula defining the variables to use to group data for multiple
mean distance and/or velocity curves (<code>opt = 'dv'</code>). By default includes
all the categorical variables named in <code>a.formula</code>, <code>b.formula</code>,
<code>c.formula</code> and <code>d.formula</code>.</p>
</td></tr>
<tr><td><code id="plot.sitar_+3A_abc">abc</code></td>
<td>
<p>vector of named values of random effects a, b, c and d used to
define an individual growth curve, e.g. abc = c(a = 1, c = -0.1). Alternatively a
single character string defining an <code>id</code> level whose random effect
values are used. If <code>abc</code> is set, <code>level</code> is ignored. If
<code>abc</code> is NULL (default), or if a, b, c or d values are missing, values of
zero are assumed.</p>
</td></tr>
<tr><td><code id="plot.sitar_+3A_trim">trim</code></td>
<td>
<p>number (default 0) of long line segments to be excluded from plot
with option 'u' or 'a'. See Details.</p>
</td></tr>
<tr><td><code id="plot.sitar_+3A_add">add</code></td>
<td>
<p>optional logical defining if the plot is pre-existing (TRUE) or
new (FALSE). TRUE is equivalent to using <code>lines</code>.</p>
</td></tr>
<tr><td><code id="plot.sitar_+3A_nlme">nlme</code></td>
<td>
<p>optional logical which set TRUE plots the model as an
<code>nlme</code> object, using <code>plot.nlme</code> arguments.</p>
</td></tr>
<tr><td><code id="plot.sitar_+3A_returndata">returndata</code></td>
<td>
<p>logical defining whether to plot the data (default FALSE)
or just return the data for plotting (TRUE). See Value.</p>
</td></tr>
<tr><td><code id="plot.sitar_+3A_...">...</code></td>
<td>
<p>Further graphical parameters (see <code>par</code>) may also be
supplied as arguments, e.g. line
type <code>lty</code>, line width <code>lwd</code>, and colour <code>col</code>. For the
velocity (y2) plot <code>y2par</code> can be used (see Details).</p>
</td></tr>
<tr><td><code id="plot.sitar_+3A_xlab">xlab</code></td>
<td>
<p>optional label for x axis</p>
</td></tr>
<tr><td><code id="plot.sitar_+3A_ylab">ylab</code></td>
<td>
<p>optional label for y axis</p>
</td></tr>
<tr><td><code id="plot.sitar_+3A_vlab">vlab</code></td>
<td>
<p>optional label for v axis (velocity)</p>
</td></tr>
<tr><td><code id="plot.sitar_+3A_xlim">xlim</code></td>
<td>
<p>optional x axis limits</p>
</td></tr>
<tr><td><code id="plot.sitar_+3A_ylim">ylim</code></td>
<td>
<p>optional y axis limits</p>
</td></tr>
<tr><td><code id="plot.sitar_+3A_vlim">vlim</code></td>
<td>
<p>optional v axis limits</p>
</td></tr>
<tr><td><code id="plot.sitar_+3A_legend">legend</code></td>
<td>
<p>optional list of arguments for legend with distance-velocity plots</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For options involving both distance curves (options 'dcDua') and velocity curves
(options 'vV') the velocity curve plot (with right axis) can be annotated with
<code>par</code> parameters given as a named list called <code>y2par</code>.
To suppress the legend that comes with it set <code>legend = NULL</code>.
</p>
<p>The transformations <code>xfun</code> and <code>yfun</code> are applied to the x and y
variables after back-transforming any transformations in the original SITAR
call. So for example if <code>y = log(height)</code> in the SITAR call, then <code>yfun</code>
is applied to <code>height</code>. Thus the default <code>yfun = identity</code> has the effect of
back-transforming the SITAR call transformation - this is achieved by setting
<code>yfun = yfun(ifun(x$call.sitar$y))</code>.
For no transformation set <code>yfun = NULL</code>. The same applies to <code>xfun</code>.
</p>
<p>For models that include categorical fixed effects (e.g. <code>a.formula = ~sex + region</code>)
the options 'dv' plot mean curves for each distinct group. Any continuous (as opposed
to grouped) fixed effect variables are set to their mean values in the plots, to ensure that the mean curves are
smooth. Setting <code>design</code> allows the grouping variables to be selected, e.g. <code>design = ~sex</code>,
and <code>design = ~1</code> gives a single mean curve. The resulting plots can
be formatted with <code>par</code> in the usual way, indexed either by the individual grouping
variables (e.g. <code>sex</code> or <code>region</code> in the example) or the subject
factor <code>id</code> which indexes all the distinct plots.
</p>
<p>The helper functions <code>plot_d</code>, <code>plot_v</code>, <code>plot_D</code>,
<code>plot_V</code>, <code>plot_u</code>, <code>plot_a</code> and <code>plot_c</code>
correspond to the seven plot <code>option</code>s defined by their last letter,
and return the data for plotting as a <code>tibble</code>, e.g. for use with
<code>ggplot2</code>. Setting <code>returndata = TRUE</code> works similarly
but handles multiple <code>option</code>s, returning a list of tibbles corresponding
to each specified <code>option</code>.
</p>
<p>The <code>trim</code> option allows unsightly long line segments to be omitted
from plots with options 'a' or 'u'. It ranks the line segments on the basis
of the age gap (dx) and the distance of the midpoint of the line from the
mean curve (dy) using the formula <code>abs(dx)/mad(dx) + abs(dy)/mad(dy)</code>
and omits those with the largest values.
</p>


<h3>Value</h3>

<p>If <code>returndata</code> is FALSE returns invisibly a list of (up to) three objects:
</p>
<table role = "presentation">
<tr><td><code>usr</code></td>
<td>
<p>value of <code>par('usr')</code> for the main plot.</p>
</td></tr>
<tr><td><code>usr2</code></td>
<td>
<p>the value of <code>par('usr')</code> for the velocity (y2) plot.</p>
</td></tr>
<tr><td><code>apv</code></td>
<td>
<p>if argument <code>apv</code> is TRUE a named list giving the age at
peak velocity (apv) and peak velocity (pv) from the fitted velocity curve,
either overall or (with options D or V, invisibly) for all subjects.</p>
</td></tr>
</table>
<p>If <code>returndata</code> is TRUE (which it is with the helper functions) returns
invisibly either a tibble or named list of tibbles,
containing the data to be plotted. The helper functions each return a tibble
where the first three variables are '.x', '.y' and '.id', plus
variable '.groups' for curves grouped by <code>design</code>) and other covariates in the model.
Note that '.x' and '.y' are returned
after applying <code>xfun</code> and <code>yfun</code>. Hence if for example <code>x = log(age)</code>
in the SITAR call then '.x' corresponds by default to <code>age</code>.
</p>


<h3>Author(s)</h3>

<p>Tim Cole <a href="mailto:tim.cole@ucl.ac.uk">tim.cole@ucl.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mplot">mplot</a></code>,
<code><a href="#topic+plotclean">plotclean</a></code>, <code><a href="#topic+ifun">ifun</a></code>, <code><a href="#topic+apv_se">apv_se</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## fit sitar model
m1 &lt;- sitar(x = age, y = height, id = id, data = heights, df = 4)

## draw fitted distance and velocity curves
## with velocity curve in blue
## adding age at peak velocity (apv)
plot(m1, y2par = list(col = 'blue'), apv = TRUE)

## bootstrap standard errors for apv and pv
## Not run: 
res &lt;- apv_se(m1, nboot = 20, plot = TRUE)

## End(Not run)
## draw individually coloured growth curves adjusted for random effects
## using same x-axis limits as for previous plot
plot(m1, opt = 'a', col = id, xlim = xaxsd())

## add mean curve in red
lines(m1, opt = 'd', col = 'red', lwd = 2)

## add mean curve for a, b, c = -1 SD
lines(m1, opt = 'd', lwd = 2, abc = -sqrt(diag(getVarCov(m1))))

## use subset to plot mean curves by group
## compare curves for early versus late menarche
heights &lt;- within(sitar::heights, {
  men &lt;- abs(men)
    late &lt;- factor(men &gt; median(men))
  })
# fit model where size and timing differ by early vs late menarche
m2 &lt;- sitar(log(age), height, id, heights, 5,
  a.formula = ~late, b.formula = ~late)
## early group
plot(m2, subset = late == FALSE, col = 4, lwd = 3,
  y2par = list(col = 4, lwd = 2), ylim = range(heights$height))
## late group
lines(m2, subset = late == TRUE, col = 2, lwd = 3,
  y2par = list(col = 2, lwd = 2))
## add legend
legend('right', paste(c('early', 'late'), 'menarche'),
  lty = 1, col = c(4, 2), inset = 0.04)

## alternatively plot both groups together
plot(m2, lwd = 3, col = late, y2par = list(lwd = 3, col = late))
legend('right', paste(c('early', 'late'), 'menarche'),
  lwd = 3, col = 1:2, inset = 0.04)
## draw fitted height distance curves coloured by subject, using ggplot
## Not run: 
require(ggplot2)
ggplot(plot_D(m1), aes(.x, .y, colour = .id)) +
labs(x = 'age', y = 'height') +
geom_line(show.legend = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotclean'>Plot multiple growth curves to identify outliers</h2><span id='topic+plotclean'></span>

<h3>Description</h3>

<p>A version of <code>mplot</code> to plot growth curves and identify outliers. When
outliers are clicked on, and if id is specified, the corresponding growth
curve is highlighted.  If id is not specified the selected point is
highlighted. Use right-click to exit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotclean(
  x,
  y,
  id = NULL,
  data = parent.frame(),
  n = length(x),
  par.out = list(pch = 20),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotclean_+3A_x">x</code></td>
<td>
<p>vector of x coordinates.</p>
</td></tr>
<tr><td><code id="plotclean_+3A_y">y</code></td>
<td>
<p>vector of y coordinates.</p>
</td></tr>
<tr><td><code id="plotclean_+3A_id">id</code></td>
<td>
<p>factor of subject levels indexing each growth curve.</p>
</td></tr>
<tr><td><code id="plotclean_+3A_data">data</code></td>
<td>
<p>optional dataframe containing <code>x</code>, <code>y</code> and <code>id</code>.</p>
</td></tr>
<tr><td><code id="plotclean_+3A_n">n</code></td>
<td>
<p>maximum number of points to be identified.</p>
</td></tr>
<tr><td><code id="plotclean_+3A_par.out">par.out</code></td>
<td>
<p>list of optional graphical parameters to control appearance
of selected outlying points and lines.</p>
</td></tr>
<tr><td><code id="plotclean_+3A_...">...</code></td>
<td>
<p>Further graphical parameters (see <code><a href="graphics.html#topic+par">par</a></code>) may also
be supplied as arguments for lines and points, particularly line type, lty,
line width, lwd and color, col.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>plotclean</code> returns either a vector <code>rows</code> (if data is not
specified) or a list: </p>
<table role = "presentation">
<tr><td><code>rows</code></td>
<td>
<p>a vector of row numbers corresponding to
the selected points.</p>
</td></tr> <tr><td><code>data</code></td>
<td>
<p>a subset of <code>data</code> consisting of rows
<code>rows</code>, and columns <code>id</code>, <code>x</code> and <code>y</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tim Cole <a href="mailto:tim.cole@ucl.ac.uk">tim.cole@ucl.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive()) plotclean(age, height, id, heights)

</code></pre>

<hr>
<h2 id='predict.sitar'>Predict SITAR model</h2><span id='topic+predict.sitar'></span>

<h3>Description</h3>

<p>Predict method for <code>sitar</code> objects, based on <code>predict.lme</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sitar'
predict(
  object,
  newdata = getData(object),
  level = 1L,
  ...,
  deriv = 0L,
  abc = NULL,
  xfun = identity,
  yfun = identity
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.sitar_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>sitar</code>.</p>
</td></tr>
<tr><td><code id="predict.sitar_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame to be used for obtaining the
predictions, defaulting to the data used to fit <code>object</code>.
It requires named columns for <code>x</code>, and for <code>id</code> if
<code>level = 1</code>, matching the names in <code>object</code>. Variables with the
reserved names <code>x=.x</code> or <code>id=.id</code> take precedence over the model
<code>x</code> and <code>id</code> variables. Any covariates in
<code>a.formula</code>, <code>b.formula</code>, <code>c.formula</code> or <code>d.formula</code> can also be included.
By default their values are set to the mean, so when <code>level = 0</code> the
prediction represents the mean curve.</p>
</td></tr>
<tr><td><code id="predict.sitar_+3A_level">level</code></td>
<td>
<p>an optional integer vector giving the level(s) of grouping to be used
in obtaining the predictions, level 0 corresponding to the population
predictions. Defaults to level 1, and <code>level = 0:1</code> fits both levels.</p>
</td></tr>
<tr><td><code id="predict.sitar_+3A_...">...</code></td>
<td>
<p>other optional arguments: <code>asList</code>, <code>na.action</code> and
<code>naPattern</code>.</p>
</td></tr>
<tr><td><code id="predict.sitar_+3A_deriv">deriv</code></td>
<td>
<p>an optional integer specifying predictions corresponding to
either the fitted curve or its derivative. <code>deriv = 0</code> (default)
specifies the distance curve, <code>deriv = 1</code> the velocity curve and
<code>deriv = 2</code> the acceleration curve.</p>
</td></tr>
<tr><td><code id="predict.sitar_+3A_abc">abc</code></td>
<td>
<p>an optional named vector containing values of a subset of
<code>a</code>, <code>b</code>, <code>c</code> and <code>d</code>, default <code>NULL</code>. Ignored if
<code>level = 0</code>. It gives predictions for a single subject with the
specified values of <code>a</code>, <code>b</code>, <code>c</code> and <code>d</code>, where missing values
are set to 0. Alternatively <code>abc</code> can contain the value for a single id.</p>
</td></tr>
<tr><td><code id="predict.sitar_+3A_xfun">xfun</code></td>
<td>
<p>an optional function to apply to <code>x</code> to convert it back to
the original scale, e.g. if x = log(age) then xfun = exp. Only relevant if
<code>deriv &gt; 0</code> - see Details.</p>
</td></tr>
<tr><td><code id="predict.sitar_+3A_yfun">yfun</code></td>
<td>
<p>an optional function to apply to <code>y</code> to convert it back to
the original scale, e.g. if y = sqrt(height) then yfun = function(z) z^2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>deriv = 1</code> the returned velocity is in units of <code>yfun(y)</code>
per <code>xfun(x)</code>. So if <code>x</code> and/or <code>y</code> are transformed, velocity
in units of <code>y</code> per <code>x</code> can be obtained by specifying <code>xfun</code>
and/or <code>yfun</code> to back-transform them appropriately.
</p>


<h3>Value</h3>

<p>A vector of the predictions, or a list of vectors if <code>asList =
TRUE</code> and <code>level == 1</code>, or a data frame if <code>length(level) &gt; 1</code>.
</p>


<h3>Author(s)</h3>

<p>Tim Cole <a href="mailto:tim.cole@ucl.ac.uk">tim.cole@ucl.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ifun">ifun</a></code> for a way to generate the functions <code>xfun</code>
and <code>yfun</code> automatically from the <code>sitar</code> model call.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(heights)
## fit model
m1 &lt;- sitar(x=age, y=height, id=id, data=heights, df=5)

## predictions at level 0
predict(m1, newdata=data.frame(age=9:16), level=0)

## predictions at level 1 for subject 5
predict(m1, newdata=data.frame(age=9:16, id=5), level=1)

## velocity predictions for subjects with early and late puberty
vel1 &lt;- predict(m1, deriv=1, abc=c(b=-1))
mplot(age, vel1, id, heights, col=id)
vel1 &lt;- predict(m1, deriv=1, abc=c(b=1))
mplot(age, vel1, id, heights, col=id, add=TRUE)

</code></pre>

<hr>
<h2 id='print.sitar'>Print SITAR model</h2><span id='topic+print.sitar'></span>

<h3>Description</h3>

<p>Print method for <code>sitar</code> objects, based on <code>print.lme</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sitar'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.sitar_+3A_x">x</code></td>
<td>
<p>an object inheriting class <code>sitar</code>.</p>
</td></tr>
<tr><td><code id="print.sitar_+3A_...">...</code></td>
<td>
<p>other optional arguments.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tim Cole <a href="mailto:tim.cole@ucl.ac.uk">tim.cole@ucl.ac.uk</a>
</p>

<hr>
<h2 id='print.summary.sitar'>Print summary of SITAR model</h2><span id='topic+print.summary.sitar'></span>

<h3>Description</h3>

<p>A <code>print.summary</code> method for <code>sitar</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.sitar'
print(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.sitar_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>summary.sitar</code>.</p>
</td></tr>
<tr><td><code id="print.summary.sitar_+3A_verbose">verbose</code></td>
<td>
<p>a logical to control the amount of output.</p>
</td></tr>
<tr><td><code id="print.summary.sitar_+3A_...">...</code></td>
<td>
<p>to specify extra arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formatted summary of the object.
</p>


<h3>Author(s)</h3>

<p>Tim Cole <a href="mailto:tim.cole@ucl.ac.uk">tim.cole@ucl.ac.uk</a>
</p>

<hr>
<h2 id='recalib'>Recalibrate x, y data using SITAR random effects</h2><span id='topic+recalib'></span>

<h3>Description</h3>

<p>A function to recalibrate x,y data using SITAR random effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recalib(xc, yc, id = NULL, data, xcnew = NULL, ycnew = NULL, model, from, to)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recalib_+3A_xc">xc</code></td>
<td>
<p>character vector defining column name(s) of <code>x</code> data to be
recalibrated.</p>
</td></tr>
<tr><td><code id="recalib_+3A_yc">yc</code></td>
<td>
<p>character vector defining column name(s) of <code>y</code> data to be
recalibrated.</p>
</td></tr>
<tr><td><code id="recalib_+3A_id">id</code></td>
<td>
<p>factor defining <code>from</code> and <code>to</code> rows. If <code>NULL</code>
then recalibrate all rows.</p>
</td></tr>
<tr><td><code id="recalib_+3A_data">data</code></td>
<td>
<p>dataframe containing <code>xc</code>, <code>yc</code> and <code>id</code>.</p>
</td></tr>
<tr><td><code id="recalib_+3A_xcnew">xcnew</code></td>
<td>
<p>column names for replacement columns <code>xc</code>. If default
<code>NULL</code> then use names xcnew1... .</p>
</td></tr>
<tr><td><code id="recalib_+3A_ycnew">ycnew</code></td>
<td>
<p>column names for replacement columns <code>yc</code>. If default
<code>NULL</code> then use names ycnew1... .</p>
</td></tr>
<tr><td><code id="recalib_+3A_model">model</code></td>
<td>
<p><code>sitar</code> model defining the random effects to be used for
recalibration.</p>
</td></tr>
<tr><td><code id="recalib_+3A_from">from</code></td>
<td>
<p>level of <code>id</code> defining existing data (must be a single row
in <code>coef{model}</code>).</p>
</td></tr>
<tr><td><code id="recalib_+3A_to">to</code></td>
<td>
<p>level of <code>id</code> defining data to be recalibrated (a single row
in <code>coef{model}</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>recalib</code> recalibrates the values of <code>xc</code> and <code>yc</code> based on
<code>model</code>. <code>xc</code> values are changed to:
</p>
<p>(xc-c(coef[from,'b']))*exp(coef[from,'c']-coef[to,'c'])+coef[to,'b'].
</p>
<p><code>yc</code> values are changed to: <code>yc-coef[from,'a']+coef[to,'a']</code>.
</p>


<h3>Value</h3>

<p>Returns the dataframe <code>data</code> with the <code>from</code> rows of
<code>xc</code> and <code>yc</code> recalibrated.
</p>


<h3>Author(s)</h3>

<p>Tim Cole <a href="mailto:tim.cole@ucl.ac.uk">tim.cole@ucl.ac.uk</a>
</p>

<hr>
<h2 id='sitar'>Fit SITAR growth curve model</h2><span id='topic+sitar'></span><span id='topic+update.sitar'></span>

<h3>Description</h3>

<p>SITAR is a method of growth curve analysis, based on <span class="pkg">nlme</span>, that
summarises a set of growth curves with a mean growth curve as a regression
spline, plus a set of up to four fixed and random effects (a, b, c and d)
defining how individual growth curves differ from the mean curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sitar(
  x,
  y,
  id,
  data,
  df,
  knots,
  fixed = NULL,
  random = "a + b + c",
  pdDiag = FALSE,
  a.formula = ~1,
  b.formula = ~1,
  c.formula = ~1,
  d.formula = ~1,
  bounds = 0.04,
  start,
  xoffset = "mean",
  bstart = xoffset,
  returndata = FALSE,
  verbose = FALSE,
  correlation = NULL,
  weights = NULL,
  subset = NULL,
  method = "ML",
  na.action = na.fail,
  control = nlmeControl(msMaxIter = 100, returnObject = TRUE),
  keep.data = TRUE
)

## S3 method for class 'sitar'
update(object, ..., evaluate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sitar_+3A_x">x</code></td>
<td>
<p>vector of ages.</p>
</td></tr>
<tr><td><code id="sitar_+3A_y">y</code></td>
<td>
<p>vector of measurements.</p>
</td></tr>
<tr><td><code id="sitar_+3A_id">id</code></td>
<td>
<p>factor of subject identifiers.</p>
</td></tr>
<tr><td><code id="sitar_+3A_data">data</code></td>
<td>
<p>data frame containing variables <code>x</code>, <code>y</code> and
<code>id</code>.</p>
</td></tr>
<tr><td><code id="sitar_+3A_df">df</code></td>
<td>
<p>degrees of freedom for cubic regression spline (0 or more, see Details).</p>
</td></tr>
<tr><td><code id="sitar_+3A_knots">knots</code></td>
<td>
<p>vector of values for knots (default <code>df</code> quantiles of
<code>x</code> distribution).</p>
</td></tr>
<tr><td><code id="sitar_+3A_fixed">fixed</code></td>
<td>
<p>character string specifying a, b, c, d fixed effects (default
<code>random</code> or the subset of &quot;a + b + c + d&quot; within <code>random</code>).</p>
</td></tr>
<tr><td><code id="sitar_+3A_random">random</code></td>
<td>
<p>character string specifying a, b, c, d random effects (default
<code>"a+b+c"</code>). Alternatively <code>nlme</code> formula e.g.
<code>"list(id = pdDiag(a + b + c ~ 1))"</code>.</p>
</td></tr>
<tr><td><code id="sitar_+3A_pddiag">pdDiag</code></td>
<td>
<p>logical which if TRUE fits a diagonal random effects
covariance matrix, or if FALSE (default) a general covariance matrix.</p>
</td></tr>
<tr><td><code id="sitar_+3A_a.formula">a.formula</code></td>
<td>
<p>formula for fixed effect a (default <code>~ 1</code>).</p>
</td></tr>
<tr><td><code id="sitar_+3A_b.formula">b.formula</code></td>
<td>
<p>formula for fixed effect b (default <code>~ 1</code>).</p>
</td></tr>
<tr><td><code id="sitar_+3A_c.formula">c.formula</code></td>
<td>
<p>formula for fixed effect c (default <code>~ 1</code>).</p>
</td></tr>
<tr><td><code id="sitar_+3A_d.formula">d.formula</code></td>
<td>
<p>formula for fixed effect d (default <code>~ 1</code>).</p>
</td></tr>
<tr><td><code id="sitar_+3A_bounds">bounds</code></td>
<td>
<p>span of <code>x</code> for regression spline, or fractional
extension of range (default 0.04).</p>
</td></tr>
<tr><td><code id="sitar_+3A_start">start</code></td>
<td>
<p>optional numeric vector of initial estimates for the fixed
effects, or list of initial estimates for the fixed and random effects (see
<code><a href="nlme.html#topic+nlme">nlme</a></code>).</p>
</td></tr>
<tr><td><code id="sitar_+3A_xoffset">xoffset</code></td>
<td>
<p>optional value of offset for <code>x</code> (either &quot;mean&quot;
(default), &quot;apv&quot; or value).</p>
</td></tr>
<tr><td><code id="sitar_+3A_bstart">bstart</code></td>
<td>
<p>optional starting value for fixed effect <code>b</code> (either
&quot;mean&quot;, &quot;apv&quot; or value (default <code>xoffset</code>)).</p>
</td></tr>
<tr><td><code id="sitar_+3A_returndata">returndata</code></td>
<td>
<p>logical which if TRUE causes the model matrix to be
returned, or if FALSE (default) the fitted model. Setting returndata TRUE is
useful in conjunction with <code>subset</code> and <code><a href="#topic+subsample">subsample</a></code> for
simulation purposes.</p>
</td></tr>
<tr><td><code id="sitar_+3A_verbose">verbose</code></td>
<td>
<p>optional logical value to print information on the evolution
of the iterative algorithm (see <code><a href="nlme.html#topic+nlme">nlme</a></code>).</p>
</td></tr>
<tr><td><code id="sitar_+3A_correlation">correlation</code></td>
<td>
<p>optional <code>corStruct</code> object describing the
within-group correlation structure (see <code><a href="nlme.html#topic+nlme">nlme</a></code>).</p>
</td></tr>
<tr><td><code id="sitar_+3A_weights">weights</code></td>
<td>
<p>optional <code>varFunc</code> object or one-sided formula
describing the within-group heteroscedasticity structure (see
<code><a href="nlme.html#topic+nlme">nlme</a></code>).</p>
</td></tr>
<tr><td><code id="sitar_+3A_subset">subset</code></td>
<td>
<p>optional expression indicating the subset of the rows of data
that should be used in the fit (see <code><a href="nlme.html#topic+nlme">nlme</a></code>).</p>
</td></tr>
<tr><td><code id="sitar_+3A_method">method</code></td>
<td>
<p>character string, either &quot;REML&quot; or &quot;ML&quot; (default) (see
<code><a href="nlme.html#topic+nlme">nlme</a></code>).</p>
</td></tr>
<tr><td><code id="sitar_+3A_na.action">na.action</code></td>
<td>
<p>function for when the data contain NAs (see
<code><a href="nlme.html#topic+nlme">nlme</a></code>).</p>
</td></tr>
<tr><td><code id="sitar_+3A_control">control</code></td>
<td>
<p>list of control values for the estimation algorithm (see
<code><a href="nlme.html#topic+nlme">nlme</a></code>) (default nlmeControl(returnObject = TRUE)).</p>
</td></tr>
<tr><td><code id="sitar_+3A_keep.data">keep.data</code></td>
<td>
<p>logical to control saving <code>data</code> as part of the model
object (default TRUE).</p>
</td></tr>
<tr><td><code id="sitar_+3A_object">object</code></td>
<td>
<p>object of class <code>sitar</code>.</p>
</td></tr>
<tr><td><code id="sitar_+3A_...">...</code></td>
<td>
<p>further parameters for <code>update</code> consisting of any of the
above <code>sitar</code> parameters.</p>
</td></tr>
<tr><td><code id="sitar_+3A_evaluate">evaluate</code></td>
<td>
<p>logical to control evaluation.  If TRUE (default) the
expanded <code>update</code> call is passed to <code>sitar</code> for evaluation, while
if FALSE the expanded call itself is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The SITAR model usually has up to three random effects (a, b and c), termed
size, timing and intensity respectively. <code>df</code> sets the degrees of freedom
for the mean spline curve, taking values from 1 (i.e. linear) upwards. In
addition there is a random effect for the slope, d, which is fitted when
<code>df = 0</code>, and combined with a, it provides the classic random intercept random
slope model, which is similar to the 1 df spline model. In addition d can be
fitted, along with a, b and c, to extend
SITAR to model variability in the adult slope of the growth curve.
</p>
<p><code>xoffset</code> allows the origin of <code>x</code> to be varied, while
<code>bstart</code> specifies the starting value for <code>b</code>, both of which can
affect the model fit and particularly <code>b</code>. The values of <code>bstart</code>,
<code>knots</code> and <code>bounds</code> are offset by <code>xoffset</code> for fitting
purposes, and similarly for fixed effect <code>b</code>.
</p>
<p>The formulae <code>a.formula</code>, <code>b.formula</code>, <code>c.formula</code> and <code>d.formula</code>
allow for cov.names and
can include functions and interactions. <code><a href="base.html#topic+make.names">make.names</a></code> is used to
ensure that the names of the corresponding model terms are valid. The
modified not the original names need to be specified in <code>predict.sitar</code>.
</p>
<p><code>update</code> updates the model by taking the <code>object</code> call, adding any
new parameters and replacing changed ones. Where feasible the fixed and
random effects of the model being updated are suitably modified and passed
via the <code>start</code> argument.
</p>


<h3>Value</h3>

<p>An object inheriting from class <code>sitar</code> representing the
nonlinear mixed-effects model fit, with all the components returned by
<code>nlme</code> (see <code><a href="nlme.html#topic+nlmeObject">nlmeObject</a></code> for a full description) plus the
following components:
</p>
<table role = "presentation">
<tr><td><code>fitnlme</code></td>
<td>
<p>the function returning the predicted value of <code>y</code>.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>copy of <code>data</code> (if <code>keep.data</code> true).</p>
</td></tr>
<tr><td><code>constants</code></td>
<td>
<p>data frame of mean a-b-c-d values for unique combinations
of covariates (excluding <code>x</code>).</p>
</td></tr>
<tr><td><code>call.sitar</code></td>
<td>
<p>the internal <code>sitar</code> call that produced the object.</p>
</td></tr>
<tr><td><code>xoffset</code></td>
<td>
<p>the value of <code>xoffset</code>.</p>
</td></tr>
<tr><td><code>ns</code></td>
<td>
<p>the <code>lm</code> object providing starting values for the B-spline curve.</p>
</td></tr>
</table>
<p>Generic functions such as <code>print</code>, <code>plot</code>, <code>anova</code> and
<code>summary</code> have methods to show the results of the fit. The functions
<code>residuals</code>, <code>coef</code>, <code>fitted</code>, <code>fixed.effects</code>,
<code>random.effects</code>, <code>predict</code>, <code>getData</code>, <code>getGroups</code>,
<code>getCovariate</code> and <code>getVarCov</code> can be used to extract some of its
components.
</p>


<h3>Author(s)</h3>

<p>Tim Cole <a href="mailto:tim.cole@ucl.ac.uk">tim.cole@ucl.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(heights)
##  fit simple model
(m1 &lt;- sitar(x=age, y=height, id=id, data=heights, df=5))

##  relate random effects to age at menarche (with censored values +ve)
##  both a (size) and b (timing) are positively associated with age at menarche
(m2 &lt;- update(m1, a.formula = ~abs(men), b.formula = ~abs(men), c.formula = ~abs(men)))
</code></pre>

<hr>
<h2 id='subsample'>Sample from SITAR dataset</h2><span id='topic+subsample'></span>

<h3>Description</h3>

<p>A function to sample from a SITAR dataset for experimental design purposes.
Two different sampling schemes are offered, based on the values of <code>id</code>
and <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsample(x, id, data, prob = 1, xlim = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subsample_+3A_x">x</code></td>
<td>
<p>vector of age.</p>
</td></tr>
<tr><td><code id="subsample_+3A_id">id</code></td>
<td>
<p>factor of subject identifiers.</p>
</td></tr>
<tr><td><code id="subsample_+3A_data">data</code></td>
<td>
<p>dataframe containing <code>x</code> and <code>id</code>.</p>
</td></tr>
<tr><td><code id="subsample_+3A_prob">prob</code></td>
<td>
<p>scalar defining sampling probability. See Details.</p>
</td></tr>
<tr><td><code id="subsample_+3A_xlim">xlim</code></td>
<td>
<p>length 2 vector defining range of <code>x</code> to be selected. See
Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With the first sampling scheme <code>xlim</code> is set to <code>NULL</code> (default),
and rows of <code>data</code> are sampled with probability <code>prob</code> without
replacement.  With the second sampling scheme <code>xlim</code> is set to a range
within <code>range(x)</code>.  Subjects <code>id</code> are then sampled with
probability <code>prob</code> without replacement, and all their rows where
<code>x</code> is within <code>xlim</code> are selected.  The second scheme is useful
for testing the power of the model to predict later growth when data only up
to a certain age are available. Setting <code>xlim</code> to <code>range(x)</code>
allows data to be sampled by subject. The returned value can be used as the
<code>subset</code> argument in <code>sitar</code> or <code>update.sitar</code>.
</p>


<h3>Value</h3>

<p>Returns a logical the length of <code>x</code> where <code>TRUE</code> indicates
a sampled value.
</p>


<h3>Author(s)</h3>

<p>Tim Cole <a href="mailto:tim.cole@ucl.ac.uk">tim.cole@ucl.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sitar">sitar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## draw 50% random sample
s50 &lt;- subsample(age, id, heights, prob=0.5)

## truncate age range to 7-12 for 50% of subjects
t50 &lt;- subsample(age, id, heights, prob=0.5, xlim=c(7, 12))

</code></pre>

<hr>
<h2 id='summary.sitar'>Create summary of SITAR model</h2><span id='topic+summary.sitar'></span>

<h3>Description</h3>

<p>A <code>summary</code> method for <code>sitar</code> objects based on
<code><a href="nlme.html#topic+summary.lme">summary.lme</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sitar'
summary(object, adjustSigma = TRUE, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.sitar_+3A_object">object</code></td>
<td>
<p>object inheriting from class <code>sitar</code>.</p>
</td></tr>
<tr><td><code id="summary.sitar_+3A_adjustsigma">adjustSigma</code></td>
<td>
<p>optional logical (see <code><a href="nlme.html#topic+summary.lme">summary.lme</a></code>).</p>
</td></tr>
<tr><td><code id="summary.sitar_+3A_verbose">verbose</code></td>
<td>
<p>optional logical to control the amount of output in
<code>print.summary.sitar</code>.</p>
</td></tr>
<tr><td><code id="summary.sitar_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional arguments.
None are used in this method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object inheriting from class <code>summary.sitar</code> with all
components included in <code>object</code> (see <code><a href="nlme.html#topic+lmeObject">lmeObject</a></code> for a full
description of the components) plus the components for
<code><a href="nlme.html#topic+summary.lme">summary.lme</a></code> and the following components: </p>
<table role = "presentation">
<tr><td><code>x.adj</code></td>
<td>
<p>vector
of length <code>x</code> in <code>object</code> with <code>x</code> values adjusted for
subject-specific random effects b and c.</p>
</td></tr> <tr><td><code>y.adj</code></td>
<td>
<p>vector of length
<code>y</code> in <code>object</code> with <code>y</code> values adjusted for subject-specific
random effects a.</p>
</td></tr> <tr><td><code>apv</code></td>
<td>
<p>length 2 vector giving respectively age at
peak velocity and peak velocity based on the fitted distance curve (using
transformed <code>x</code> and <code>y</code> where specified).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tim Cole <a href="mailto:tim.cole@ucl.ac.uk">tim.cole@ucl.ac.uk</a>
</p>

<hr>
<h2 id='timegap'>Select equally spaced ages from a vector of ages</h2><span id='topic+timegap'></span><span id='topic+timegap.id'></span><span id='topic+diffid'></span>

<h3>Description</h3>

<p><code>timegap</code> indexes elements in a vector of ages such that the indexed
ages are spaced integer multiples of a time interval apart, to within a given
tolerance. <code>timegap.id</code> is a wrapper to apply <code>timegap</code> within levels
of factor <code>id</code>. The selected ages can then be split into age groups the
specified time interval wide, ensuring that (virtually) every subject
has at most one measurement per interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timegap(age, gap, tol = 0.1 * gap, multiple = FALSE)

timegap.id(
  age,
  id,
  data = parent.frame(),
  gap,
  tol = 0.1 * gap,
  multiple = FALSE
)

diffid(
  age,
  id,
  data = parent.frame(),
  lag = 1,
  differences = 1,
  sort = FALSE,
  keepNA = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="timegap_+3A_age">age</code></td>
<td>
<p>vector of ages.</p>
</td></tr>
<tr><td><code id="timegap_+3A_gap">gap</code></td>
<td>
<p>numeric, the required positive time gap between selected ages.</p>
</td></tr>
<tr><td><code id="timegap_+3A_tol">tol</code></td>
<td>
<p>numeric, the positive tolerance around the gap (default <code>0.1 * gap</code>).</p>
</td></tr>
<tr><td><code id="timegap_+3A_multiple">multiple</code></td>
<td>
<p>logical, whether or not to return multiple solutions
when found (default FALSE).</p>
</td></tr>
<tr><td><code id="timegap_+3A_id">id</code></td>
<td>
<p>factor of subject ids.</p>
</td></tr>
<tr><td><code id="timegap_+3A_data">data</code></td>
<td>
<p>data frame optionally containing <code>age</code> and <code>id</code>.</p>
</td></tr>
<tr><td><code id="timegap_+3A_lag">lag</code></td>
<td>
<p>an integer indicating which lag to use.</p>
</td></tr>
<tr><td><code id="timegap_+3A_differences">differences</code></td>
<td>
<p>an integer indicating the order of the difference.</p>
</td></tr>
<tr><td><code id="timegap_+3A_sort">sort</code></td>
<td>
<p>a logical indicating whether to first sort by id and age.</p>
</td></tr>
<tr><td><code id="timegap_+3A_keepna">keepNA</code></td>
<td>
<p>a logical indicating whether to keep generated NAs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>timegap</code> calculates all possible differences between pairs of ages,
expresses them as integer multiples of <code>gap</code>, restricts them to
those within tolerance and identifies those providing the longest sequences.
For sequences of the same length, those with the smallest standard deviation
of successive differences (modulo the time interval) are selected.
</p>


<h3>Value</h3>

<p>With <code>timegap</code>, for unique solutions, or multiple solutions with
<code>multiple FALSE</code>, a vector of indices named with <code>age</code>. With
<code>timegap.id</code> the subject vectors are returned invisibly, concatenated.
</p>
<p>With <code>multiple TRUE</code>, where there are multiple solutions
they are returned as a named matrix.
</p>
<p><code>diffid</code> returns <code>diff(age)</code> applied within <code>id</code>.
With <code>keepNA</code> TRUE a suitable number of <code>NA</code>s are added at the end,
while if FALSE all <code>NA</code>s are omitted.
</p>


<h3>Author(s)</h3>

<p>Tim Cole <a href="mailto:tim.cole@ucl.ac.uk">tim.cole@ucl.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(heights)

## bin age into 1-year groups by id
## gives multiple measurements per id per year
with(heights, table(floor(age), id))

## now select heights measured multiples of 1 year apart
(tg1 &lt;- timegap.id(age, id, heights, 1))

## no more than one measurement per id per year
with(heights[tg1, ], table(floor(age), id))

## most time intervals close to 1 year
summary(diffid(age, id, heights[tg1, ], lag=1))
</code></pre>

<hr>
<h2 id='uk90'>UK 1990 growth reference</h2><span id='topic+uk90'></span>

<h3>Description</h3>

<p>The UK 1990 growth reference (Freeman et al 1995, Cole et al 1998) for
height, weight, body mass index, circumferences and percent body fat, fitted
by the LMS method and summarised by values of L, M and S by sex from 23
weeks gestation to 23 years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uk90
</code></pre>


<h3>Format</h3>

<p>A tibble with 588 observations on the following 26 variables:
</p>

<dl>
<dt>years</dt><dd><p>numeric vector</p>
</dd>
<dt>L.ht</dt><dd><p>numeric vector</p>
</dd>
<dt>M.ht</dt><dd><p>numeric vector</p>
</dd>
<dt>S.ht</dt><dd><p>numeric vector</p>
</dd>
<dt>L.wt</dt><dd><p>numeric vector</p>
</dd>
<dt>M.wt</dt><dd><p>numeric vector</p>
</dd>
<dt>S.wt</dt><dd><p>numeric vector</p>
</dd>
<dt>L.bmi</dt><dd><p>numeric vector</p>
</dd>
<dt>M.bmi</dt><dd><p>numeric vector</p>
</dd>
<dt>S.bmi</dt><dd><p>numeric vector</p>
</dd>
<dt>L.head</dt><dd><p>numeric vector</p>
</dd>
<dt>M.head</dt><dd><p>numeric vector</p>
</dd>
<dt>S.head</dt><dd><p>numeric vector</p>
</dd>
<dt>L.sitht</dt><dd><p>numeric vector</p>
</dd>
<dt>M.sitht</dt><dd><p>numeric vector</p>
</dd>
<dt>S.sitht</dt><dd><p>numeric vector</p>
</dd>
<dt>L.leglen</dt><dd><p>numeric vector</p>
</dd>
<dt>M.leglen</dt><dd><p>numeric vector</p>
</dd>
<dt>S.leglen</dt><dd><p>numeric vector</p>
</dd>
<dt>L.waist</dt><dd><p>numeric vector</p>
</dd>
<dt>M.waist</dt><dd><p>numeric vector</p>
</dd>
<dt>S.waist</dt><dd><p>numeric vector</p>
</dd>
<dt>L.bfat</dt><dd><p>numeric vector</p>
</dd>
<dt>M.bfat</dt><dd><p>numeric vector</p>
</dd>
<dt>S.bfat</dt><dd><p>numeric vector</p>
</dd>
<dt>sex</dt><dd><p>two-level factor with level 1 male and level 2 female</p>
</dd> </dl>



<h3>Details</h3>

<p>The L, M and S values for each measurement correspond respectively to the
Box-Cox power, median and coefficient of variation of the distribution by
age and sex (Cole &amp; Green 1992). The short names and units for each measurement (see
<code><a href="#topic+LMS2z">LMS2z</a></code>) are as follows: height (ht, cm), weight (wt, kg), body mass
index (bmi, kg/m2), head circumference (head, cm), sitting height (sitht, cm), leg length
(leglen, cm), waist circumference (waist, cm) and percent body fat (fat, 
</p>


<h3>Source</h3>

<p>The values are tabulated in the spreadsheet British1990.xls provided
with the Excel add-in LMSgrowth from:
https://www.healthforallchildren.com/shop-base/software/lmsgrowth/
</p>


<h3>References</h3>

<p>Cole TJ, Green PJ. Smoothing reference centile curves: the LMS
method and penalized likelihood. Stat Med 1992;11:1305-19.
</p>
<p>Cole TJ, Freeman JV, Preece MA. British 1990 growth reference centiles for
weight, height, body mass index and head circumference fitted by maximum
penalized likelihood. Stat Med 1998;17:407-29.
</p>
<p>Freeman JV, Cole TJ, Chinn S, et al. Cross sectional stature and weight
reference curves for the UK, 1990. Arch Dis Child 1995;73:17-24.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(uk90)
## calculate median BMI in girls from birth to 10 years
LMS2z(x = 0:10, y = 0, sex = 2, measure = 'bmi', ref = 'uk90', toz = FALSE)
</code></pre>

<hr>
<h2 id='ukwhopt'>UK-WHO growth reference including preterm</h2><span id='topic+ukwhopt'></span>

<h3>Description</h3>

<p>The UK-WHO growth reference for height, weight, BMI and head circumference
(see Wright et al 2010), fitted by the LMS method and summarised by values of
L, M and S by sex from 26 weeks gestation to 20 years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ukwhopt
</code></pre>


<h3>Format</h3>

<p>A tibble with 542 observations on the following 17 variables:
</p>

<dl>
<dt>age_wm</dt><dd><p>numeric vector - age in weeks or months - see <code>wm</code></p>
</dd>
<dt>wm</dt><dd><p>three-level factor indicating weeks or months: wkga = gestational
weeks, wk = postnatal weeks, mth = postnatal months</p>
</dd>
<dt>years</dt><dd><p>numeric vector - age in years</p>
</dd>
<dt>L.ht</dt><dd><p>numeric vector</p>
</dd>
<dt>M.ht</dt><dd><p>numeric vector</p>
</dd>
<dt>S.ht</dt><dd><p>numeric vector</p>
</dd>
<dt>L.wt</dt><dd><p>numeric vector</p>
</dd>
<dt>M.wt</dt><dd><p>numeric vector</p>
</dd>
<dt>S.wt</dt><dd><p>numeric vector</p>
</dd>
<dt>L.bmi</dt><dd><p>numeric vector</p>
</dd>
<dt>M.bmi</dt><dd><p>numeric vector</p>
</dd>
<dt>S.bmi</dt><dd><p>numeric vector</p>
</dd>
<dt>L.head</dt><dd><p>numeric vector</p>
</dd>
<dt>M.head</dt><dd><p>numeric vector</p>
</dd>
<dt>S.head</dt><dd><p>numeric vector</p>
</dd>
<dt>origin</dt><dd><p>two-level factor indicating the provenance of the data, with
levels British1990 and WHO2006</p>
</dd>
<dt>sex</dt><dd><p>two-level factor with level 1 male and level 2 female</p>
</dd> </dl>



<h3>Details</h3>

<p>The growth reference combines the birth section of the British 1990 growth
reference (Cole et al 2011) from 26 to 42 weeks gestation, the WHO growth
standard from 2 postnatal weeks to 4 years, and the British 1990 reference
from 4 to 20 years.
</p>
<p>Age is measured in years, where 40 weeks gestation is 0 years. The conversion
from weeks gestation to years is:
<code>years = (weeks - 40) * 7 / 365.25</code>.
</p>
<p>The L, M and S values for each measurement correspond respectively to the
Box-Cox power, median and coefficient of variation of the distribution by
age and sex (Cole &amp; Green 1992). The measurement short names and units (see
<code><a href="#topic+LMS2z">LMS2z</a></code>) are as follows: height (ht, cm), weight (wt, kg),
BMI (bmi, kg/m2) and head circumference (head, cm).
</p>


<h3>Source</h3>

<p>The values are tabulated in the Excel spreadsheet UK_WHO_preterm.xls
provided with the Excel add-in LMSgrowth from
https://www.healthforallchildren.com/shop-base/software/lmsgrowth/
</p>


<h3>References</h3>

<p>Cole TJ, Green PJ. Smoothing reference centile curves: the LMS
method and penalized likelihood. Stat Med 1992;11:1305-19.
</p>
<p>Cole TJ, Williams AF, Wright CM, et al. Revised birth centiles for weight,
length and head circumference in the UK-WHO growth charts. Ann Hum Biol
2011;38:7-11.
</p>
<p>Wright CM, Williams AF, Elliman D, et al. Using the new UK-WHO growth
charts. BMJ 2010;340:c1140.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ukwhopt)
## calculate median birth weight (kg) in girls from 26 to 44 weeks gestation
v &lt;- LMS2z(x = (26:44-40) * 7 / 365.25, y = 0, sex = 2, measure = 'wt',
  ref = 'ukwhopt', toz = FALSE)
setNames(v, 26:44)
</code></pre>

<hr>
<h2 id='ukwhoterm'>UK-WHO growth reference omitting preterm data</h2><span id='topic+ukwhoterm'></span>

<h3>Description</h3>

<p>The UK-WHO growth reference for height, weight, BMI and head circumference
(see Wright et al 2010), fitted by the LMS method and summarised by values of
L, M and S by sex and postnatal age from term birth (see Details) to 20 years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ukwhoterm
</code></pre>


<h3>Format</h3>

<p>A tibble with 512 observations on the following 15 variables:
</p>

<dl>
<dt>years</dt><dd><p>numeric vector - postnatal age in years</p>
</dd>
<dt>L.ht</dt><dd><p>numeric vector</p>
</dd>
<dt>M.ht</dt><dd><p>numeric vector</p>
</dd>
<dt>S.ht</dt><dd><p>numeric vector</p>
</dd>
<dt>L.wt</dt><dd><p>numeric vector</p>
</dd>
<dt>M.wt</dt><dd><p>numeric vector</p>
</dd>
<dt>S.wt</dt><dd><p>numeric vector</p>
</dd>
<dt>L.bmi</dt><dd><p>numeric vector</p>
</dd>
<dt>M.bmi</dt><dd><p>numeric vector</p>
</dd>
<dt>S.bmi</dt><dd><p>numeric vector</p>
</dd>
<dt>L.head</dt><dd><p>numeric vector</p>
</dd>
<dt>M.head</dt><dd><p>numeric vector</p>
</dd>
<dt>S.head</dt><dd><p>numeric vector</p>
</dd>
<dt>origin</dt><dd><p>two-level factor indicating the provenance of the data, with
levels British1990 and WHO2006</p>
</dd>
<dt>sex</dt><dd><p>two-level factor with level 1 male and level 2 female</p>
</dd> </dl>



<h3>Details</h3>

<p>The growth reference combines term birth data from the British 1990 growth
reference (Cole et al 2011), the WHO growth standard from 2 postnatal weeks
to 4 years, and the British 1990 reference from 4 to 20 years.
</p>
<p>Age is measured in years, and term birth corresponds to ages between 37 and
42 weeks gestation, where 40 weeks gestation is 0 years. The conversion is:
<code>years = (weeks - 40) * 7 / 365.25</code>.
</p>
<p>The L, M and S values for each measurement correspond respectively to the
Box-Cox power, median and coefficient of variation of the distribution by
age and sex (Cole &amp; Green 1992). The measurement short names and units (see
<code><a href="#topic+LMS2z">LMS2z</a></code>) are as follows: height (ht, cm), weight (wt, kg),
BMI (bmi, kg/m2) and head circumference (head, cm).
</p>


<h3>Source</h3>

<p>The values are tabulated in the Excel spreadsheet UK_WHO_preterm.xls
provided with the Excel add-in LMSgrowth from
https://www.healthforallchildren.com/shop-base/software/lmsgrowth/
</p>


<h3>References</h3>

<p>Cole TJ, Green PJ. Smoothing reference centile curves: the LMS
method and penalized likelihood. Stat Med 1992;11:1305-19.
</p>
<p>Cole TJ, Williams AF, Wright CM, et al. Revised birth centiles for weight,
length and head circumference in the UK-WHO growth charts. Ann Hum Biol
2011;38:7-11.
</p>
<p>Wright CM, Williams AF, Elliman D, et al. Using the new UK-WHO growth
charts. BMJ 2010;340:c1140.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ukwhoterm)
## calculate median weight (kg) in girls from 0 to 10 years
v &lt;- LMS2z(x = 0:10, y = 0, sex = 2, measure = 'wt',
  ref = 'ukwhoterm', toz = FALSE)
setNames(v, 0:10)
</code></pre>

<hr>
<h2 id='velout'>Identify outliers with abnormal velocity in growth curves</h2><span id='topic+velout'></span>

<h3>Description</h3>

<p>Quickly identifies putative outliers in a large number of growth curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>velout(x, y, id, data, lag = 1, velpower = 0.5, limit = 5, linearise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="velout_+3A_x">x</code></td>
<td>
<p>age vector.</p>
</td></tr>
<tr><td><code id="velout_+3A_y">y</code></td>
<td>
<p>outcome vector, typically weight or height.</p>
</td></tr>
<tr><td><code id="velout_+3A_id">id</code></td>
<td>
<p>factor identifying each subject.</p>
</td></tr>
<tr><td><code id="velout_+3A_data">data</code></td>
<td>
<p>data frame containing x, y and id.</p>
</td></tr>
<tr><td><code id="velout_+3A_lag">lag</code></td>
<td>
<p>lag between measurements for defining growth velocity.</p>
</td></tr>
<tr><td><code id="velout_+3A_velpower">velpower</code></td>
<td>
<p>a value, typically between 0 and 1, defining the power of
delta x to use when calculating velocity as delta(y)/delta(x)^velpower. The
default of 0.5 is midway between velocity and increment.</p>
</td></tr>
<tr><td><code id="velout_+3A_limit">limit</code></td>
<td>
<p>the number of standard deviations beyond which a velocity is
deemed to be an outlier.</p>
</td></tr>
<tr><td><code id="velout_+3A_linearise">linearise</code></td>
<td>
<p>if TRUE y is converted to a residual about the median curve
of y versus x.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm works by viewing serial measurements in each growth curve as
triplets (A-B-C) and comparing the velocities between them. Velocity is
calculated as
</p>
<p>diff(y, lag = lag) / diff(x, lag = lag) ^ velpower
</p>
<p>Missing values for x or y are ignored. If any of the AB, BC or AC velocities
are abnormal (more than <code>limit</code> SDs in absolute value from the median
for the dataset) the code for B is non-zero.
</p>


<h3>Value</h3>

<p>Returns a data frame with columns: id, x, y (from the call), code
(as described below), vel1, vel2 and vel3 (corresponding to the velocities
AB, BC and AC above). The 'data' attribute contains the name of 'data'.
</p>
<p>Code is a factor taking values between 0 and 8, with 0 normal (see table
below). Values 1-6 depend on the pattern of abnormal velocities, while 7 and
8 indicate a duplicate age (7 for the first in an individual and 8 for later
ones). Edge outliers, i.e. first or last for an individual, have just one
velocity. Code 4 indicates a conventional outlier, with both AB and BC
abnormal and AC normal. Code 6 is an edge outlier. Other codes are not
necessarily outliers, e.g. codes 1 or 3 may be adjacent to a code 4. Use
<code>codeplot</code> to look at individual curves, and <code>zapvelout</code> to delete
outliers. </p>

<table>
<tr>
 <td style="text-align: center;"> code </td><td style="text-align: center;"> AB+BC </td><td style="text-align: center;"> AC </td><td style="text-align: left;"> interpretation</td>
</tr>
<tr>
 <td style="text-align: center;"> 0
</td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 0 </td><td style="text-align: left;"> no outlier</td>
</tr>
<tr>
 <td style="text-align: center;"> 0 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> NA </td><td style="text-align: left;"> no outlier</td>
</tr>
<tr>
 <td style="text-align: center;"> 1 </td><td style="text-align: center;">
0 </td><td style="text-align: center;"> 1 </td><td style="text-align: left;"> rare pattern</td>
</tr>
<tr>
 <td style="text-align: center;"> 2 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 0 </td><td style="text-align: left;"> complicated - look at
curve</td>
</tr>
<tr>
 <td style="text-align: center;"> 3 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 1 </td><td style="text-align: left;"> adjacent to simple outlier</td>
</tr>
<tr>
 <td style="text-align: center;"> 4 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 0
</td><td style="text-align: left;"> single outlier</td>
</tr>
<tr>
 <td style="text-align: center;"> 5 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 1 </td><td style="text-align: left;"> double outlier</td>
</tr>
<tr>
 <td style="text-align: center;"> 6 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;">
NA </td><td style="text-align: left;"> edge outlier</td>
</tr>
<tr>
 <td style="text-align: center;"> 7 </td><td style="text-align: center;"> - </td><td style="text-align: center;"> - </td><td style="text-align: left;"> first duplicate age</td>
</tr>
<tr>
 <td style="text-align: center;"> 8 </td><td style="text-align: center;"> -
</td><td style="text-align: center;"> - </td><td style="text-align: left;"> later duplicate age </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Tim Cole <a href="mailto:tim.cole@ucl.ac.uk">tim.cole@ucl.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+codeplot">codeplot</a></code>, <code><a href="#topic+zapvelout">zapvelout</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
outliers &lt;- velout(age, height, id, heights, limit=3)

</code></pre>

<hr>
<h2 id='who06'>The WHO 2006 growth standard</h2><span id='topic+who06'></span>

<h3>Description</h3>

<p>The WHO growth standard (WHO 2006) for height, weight, body mass index,
circumferences and skinfold thicknesses, fitted by the LMS method and
summarised by values of L, M and S by sex from birth to 5 years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>who06
</code></pre>


<h3>Format</h3>

<p>A tibble with 150 observations on the following 23 variables:
</p>
 <dl>
<dt>years</dt><dd><p>age from 0 to 5 years</p>
</dd>
<dt>L.ht</dt><dd><p>numeric vector</p>
</dd>
<dt>M.ht</dt><dd><p>numeric vector</p>
</dd>
<dt>S.ht</dt><dd><p>numeric vector</p>
</dd>
<dt>L.wt</dt><dd><p>numeric vector</p>
</dd>
<dt>M.wt</dt><dd><p>numeric vector</p>
</dd>
<dt>S.wt</dt><dd><p>numeric vector</p>
</dd>
<dt>L.bmi</dt><dd><p>numeric vector</p>
</dd>
<dt>M.bmi</dt><dd><p>numeric vector</p>
</dd>
<dt>S.bmi</dt><dd><p>numeric vector</p>
</dd>
<dt>L.head</dt><dd><p>numeric vector</p>
</dd>
<dt>M.head</dt><dd><p>numeric vector</p>
</dd>
<dt>S.head</dt><dd><p>numeric vector</p>
</dd>
<dt>L.arm</dt><dd><p>numeric vector</p>
</dd>
<dt>M.arm</dt><dd><p>numeric vector</p>
</dd>
<dt>S.arm</dt><dd><p>numeric vector</p>
</dd>
<dt>L.subscap</dt><dd><p>numeric vector</p>
</dd>
<dt>M.subscap</dt><dd><p>numeric vector</p>
</dd>
<dt>S.subscap</dt><dd><p>numeric vector</p>
</dd>
<dt>L.tricep</dt><dd><p>numeric vector</p>
</dd>
<dt>M.tricep</dt><dd><p>numeric vector</p>
</dd>
<dt>S.tricep</dt><dd><p>numeric vector</p>
</dd>
<dt>sex</dt><dd><p>two-level factor with level 1 male and level 2 female</p>
</dd> </dl>



<h3>Details</h3>

<p>The L, M and S values for each measurement correspond respectively to the
Box-Cox power, median and coefficient of variation of the distribution by
age and sex (Cole &amp; Green 1992). The short names and units for each measurement (see
<code><a href="#topic+LMS2z">LMS2z</a></code>) are as follows: height (ht, cm), weight (wt, kg), body mass
index (bmi, kg/m2), head circumference (head, cm), arm circumference (arm, cm), subscapular
skinfold (subscap, mm), and tricep skinfold (tricep, mm).
</p>


<h3>Source</h3>

<p><a href="https://www.who.int/toolkits/child-growth-standards">https://www.who.int/toolkits/child-growth-standards</a>
</p>


<h3>References</h3>

<p>World Health Organization. WHO Child Growth Standards: Methods
and development: Length/height-for-age, weight-for-age, weight-for-length,
weight-for-height and body mass index-for-age. Geneva: WHO; 2006.
</p>
<p>Cole TJ, Green PJ. Smoothing reference centile curves: the LMS method and
penalized likelihood. Stat Med 1992;11:1305-19.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(who06)
## calculate z-score for length 60 cm in boys at age 0:12 months
LMS2z(x = 0:12/12, y = 60, sex = 1, measure = 'ht', ref = 'who06')
</code></pre>

<hr>
<h2 id='who0607'>The WHO 2006 growth standard and WHO 2007 growth reference</h2><span id='topic+who0607'></span>

<h3>Description</h3>

<p>The WHO growth standard (WHO 2006) and growth reference (2007) for height,
weight and body mass index, fitted by the LMS method and
summarised by values of L, M and S by sex from birth to 19 years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>who0607
</code></pre>


<h3>Format</h3>

<p>A tibble with 486 observations on the following 11 variables:
</p>
 <dl>
<dt>years</dt><dd><p>age from 0 to 19 years</p>
</dd>
<dt>L.ht</dt><dd><p>numeric vector</p>
</dd>
<dt>M.ht</dt><dd><p>numeric vector</p>
</dd>
<dt>S.ht</dt><dd><p>numeric vector</p>
</dd>
<dt>L.wt</dt><dd><p>numeric vector</p>
</dd>
<dt>M.wt</dt><dd><p>numeric vector</p>
</dd>
<dt>S.wt</dt><dd><p>numeric vector</p>
</dd>
<dt>L.bmi</dt><dd><p>numeric vector</p>
</dd>
<dt>M.bmi</dt><dd><p>numeric vector</p>
</dd>
<dt>S.bmi</dt><dd><p>numeric vector</p>
</dd>
<dt>sex</dt><dd><p>two-level factor with level 1 male and level 2 female</p>
</dd> </dl>



<h3>Details</h3>

<p>The L, M and S values for each measurement correspond respectively to the
Box-Cox power, median and coefficient of variation of the distribution by
age and sex (Cole &amp; Green 1992). The short names and units for each measurement (see
<code><a href="#topic+LMS2z">LMS2z</a></code>) are as follows: height (ht, cm), weight (wt, kg) and body mass
index (bmi, kg/m2).
</p>


<h3>References</h3>

<p>Cole TJ, Green PJ. Smoothing reference centile curves: the
LMS method and penalized likelihood. Stat Med 1992;11:1305-19.
</p>
<p>World Health Organization. WHO Child Growth Standards: Methods
and development: Length/height-for-age, weight-for-age, weight-for-length,
weight-for-height and body mass index-for-age. Geneva: WHO; 2006.
</p>
<p>de Onis M, Onyango AW, Borghi E, Siyam A, Nishida C, Siekmann J. Development
of a WHO growth reference for school-aged children and adolescents.
Bull WHO 2007;85:660-7.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(who0607)
## calculate 98th centile for BMI in girls from birth to 19 years
round(
  setNames(
    LMS2z(x = 0:19, y = 2, sex = 2, measure = 'bmi', ref = 'who0607',
      toz = FALSE), 0:19), 1)
</code></pre>

<hr>
<h2 id='xaxsd'>Par args xaxs and yaxs option d</h2><span id='topic+xaxsd'></span><span id='topic+yaxsd'></span>

<h3>Description</h3>

<p>Implements par('xaxs') and par('yaxs') option 'd'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xaxsd(usr = par()$usr[1:2])

yaxsd(usr = par()$usr[3:4])
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xaxsd_+3A_usr">usr</code></td>
<td>
<p>a length-2 vector defining the length of the x-axis or y-axis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implements par('xaxs') and par('yaxs') option 'd', i.e. uses previous axis
scales in a new plot.
</p>


<h3>Value</h3>

<p>By default returns xlim/ylim args to match current setting of
par()$usr, i.e. previous plot scales.  Specifying <code>usr</code> gives scales
with the usr args at the extremes. If par('xlog') or par('ylog') are set the
returned limits are antilogged (to base 10).
</p>


<h3>Author(s)</h3>

<p>Tim Cole <a href="mailto:tim.cole@ucl.ac.uk">tim.cole@ucl.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## generate and plot 100 data points
x &lt;- rnorm(100)
y &lt;- rnorm(100)
plot(x, y, pch=19)

## generate and plot 10 more
## constraining axis scales to be as before
x &lt;- rnorm(10)
y &lt;- rnorm(10)
plot(x, y, pch=19, xlim=xaxsd(), ylim=yaxsd())

## force axis extremes to be -3 and 3
plot(x, y, pch=19, xlim=xaxsd(c(-3,3)), ylim=yaxsd(c(-3,3)))

</code></pre>

<hr>
<h2 id='xyadj'>Adjust x and y variables for SITAR random effects</h2><span id='topic+xyadj'></span>

<h3>Description</h3>

<p><code>xyadj</code> Adjusts <code>x</code> and <code>y</code> and optionally <code>v</code> values for subject-specific
random effects from a SITAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xyadj(object, x, y = 0, v = 0, id, abc = NULL, tomean = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xyadj_+3A_object">object</code></td>
<td>
<p>a SITAR model.</p>
</td></tr>
<tr><td><code id="xyadj_+3A_x">x</code></td>
<td>
<p>a vector of x coordinates. If missing, <code>x</code> and
<code>y</code> and <code>id</code> are obtained from <code>object</code>.</p>
</td></tr>
<tr><td><code id="xyadj_+3A_y">y</code></td>
<td>
<p>a vector of y coordinates (default 0).</p>
</td></tr>
<tr><td><code id="xyadj_+3A_v">v</code></td>
<td>
<p>a vector of velocity coordinates (default 0).</p>
</td></tr>
<tr><td><code id="xyadj_+3A_id">id</code></td>
<td>
<p>a factor denoting the subject levels corresponding to <code>x</code> and
<code>y</code> and <code>v</code>.</p>
</td></tr>
<tr><td><code id="xyadj_+3A_abc">abc</code></td>
<td>
<p>a data frame containing random effects for a, b, c and d (default
<code>ranef(object)[id, ]</code>).</p>
</td></tr>
<tr><td><code id="xyadj_+3A_tomean">tomean</code></td>
<td>
<p>a logical defining the direction of adjustment. TRUE (default)
indicates that individual curves are translated and rotated to match the
mean curve, while FALSE indicates the reverse, the mean curve being
translated and rotated to match individual curves.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>tomean = TRUE</code> the x and y and v values are adjusted to
</p>
<p style="text-align: center;"><code class="reqn">(x - xoffset - b&lt;fixed&gt; - b&lt;random&gt;) * exp(c&lt;random&gt;) + xoffset + b&lt;fixed&gt;</code>
</p>

<p style="text-align: center;"><code class="reqn">y - a&lt;random&gt; - d&lt;random&gt; * x</code>
</p>

<p style="text-align: center;"><code class="reqn">(v - d&lt;random&gt;) / exp(c&lt;random&gt;)</code>
</p>

<p>When <code>tomean = FALSE</code> they are adjusted to
</p>
<p style="text-align: center;"><code class="reqn">(x - xoffset - b&lt;fixed&gt;) / exp(c&lt;random&gt;) + xoffset + b&lt;fixed&gt; + b&lt;random&gt;</code>
</p>

<p style="text-align: center;"><code class="reqn">y + a&lt;random&gt; + d&lt;random&gt; * x</code>
</p>

<p style="text-align: center;"><code class="reqn">v * exp(c&lt;random&gt;) + d&lt;random&gt;</code>
</p>

<p>In each case missing values of the fixed or random effects are
set to zero.
</p>


<h3>Value</h3>

<p>The list of adjusted values: </p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>numeric vector.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>numeric vector the same length as x, or NULL.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>numeric vector the same length as x, or NULL.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tim Cole <a href="mailto:tim.cole@ucl.ac.uk">tim.cole@ucl.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(heights)
## fit sitar model for height
m1 &lt;- sitar(x = age, y = height, id = id, data = heights, df = 5)

## plot unadjusted data as growth curves
plot(m1, opt='u')

## overplot with adjusted data as points
with(heights, points(xyadj(m1), col='red', pch = 19))

</code></pre>

<hr>
<h2 id='z2cent'>Express z-scores as centile character strings for plotting</h2><span id='topic+z2cent'></span>

<h3>Description</h3>

<p>Converts z-scores, typically defining centiles in a growth chart, to
character strings that can be used to label the centile curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>z2cent(z)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="z2cent_+3A_z">z</code></td>
<td>
<p>a scalar or vector of z-scores.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string is returned, the same length as z. Z-scores between
the 1st and 99th centile are converted to centiles with one or two significant
figures (lower tail) or to their complement (upper tail). For larger z-scores
in absolute value the character consists of &quot;SDS&quot; appended to the z-score
rounded to one decimal place.
</p>


<h3>Author(s)</h3>

<p>Tim Cole <a href="mailto:tim.cole@ucl.ac.uk">tim.cole@ucl.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cLMS">cLMS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
z2cent(-4:4)
z2cent(qnorm(0:100/100))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
