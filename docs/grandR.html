<!DOCTYPE html><html><head><title>Help for package grandR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {grandR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Analyses'><p>Analysis table functions</p></a></li>
<li><a href='#AnalyzeGeneSets'><p>Gene set analysis</p></a></li>
<li><a href='#ApplyContrasts'><p>Apply a function over contrasts</p></a></li>
<li><a href='#as.Seurat.grandR'><p>Create Seurat object from a grandR object</p></a></li>
<li><a href='#CalibrateEffectiveLabelingTimeKineticFit'><p>Uses the kinetic model to calibrate the effective labeling time.</p></a></li>
<li><a href='#CalibrateEffectiveLabelingTimeMatchHalflives'><p>Calibrate the effective labeling time by matching half-lives to a .reference</p></a></li>
<li><a href='#check.analysis'><p>Internal functions to check for a valid analysis or slot names.</p></a></li>
<li><a href='#ClassifyGenes'><p>Build the type column for the gene info table.</p></a></li>
<li><a href='#Coldata'><p>Get the column annotation table or add additional columns to it</p></a></li>
<li><a href='#ComputeAbsolute'><p>Compute absolute expression using ERCC spike ins</p></a></li>
<li><a href='#ComputeColumnStatistics'><p>Compute statistics for all columns (i.e. samples or cells)</p></a></li>
<li><a href='#ComputeExpressionPercentage'><p>Expression percentage computation</p></a></li>
<li><a href='#ComputeNonConstantParam'><p>Compute and evaluate functions for non constant rates</p></a></li>
<li><a href='#ComputeNtrPosteriorQuantile'><p>Compute NTR quantiles</p></a></li>
<li><a href='#ComputePseudoNtr'><p>Compute pseudo NTRs from two count matrices</p></a></li>
<li><a href='#ComputeSteadyStateHalfLives'><p>Steady state half-lives for each sample</p></a></li>
<li><a href='#ComputeSummaryStatistics'><p>Compute summary statistics</p></a></li>
<li><a href='#Condition'><p>Get or set the conditions in the column annotation table.</p></a></li>
<li><a href='#correctdropout'><p>Correct for 4sU dropout</p></a></li>
<li><a href='#CreateConvolutionTable'><p>Create Convolution Table from a Seurat object</p></a></li>
<li><a href='#CreatePdfs'><p>Convencience methods for creating QC pdfs</p></a></li>
<li><a href='#CreatePseudobulkTable'><p>Create Pseudobulk Table from a Seurat object</p></a></li>
<li><a href='#data.apply'><p>Internal function to apply functions to all slots etc.</p></a></li>
<li><a href='#DefaultSlot'><p>Get or set the default slot for a grandR object.</p></a></li>
<li><a href='#Defer'><p>Defer calling a function</p></a></li>
<li><a href='#density2d'><p>Density estimation in 2d</p></a></li>
<li><a href='#DESeq2BIC'><p>Compute the Bayesian information criterion (BIC)</p></a></li>
<li><a href='#Design'><p>A list of predefined names for design vectors</p></a></li>
<li><a href='#DesignSemantics'><p>Build the design semantics list</p></a></li>
<li><a href='#dropout'><p>Perform 4sU dropout tests</p></a></li>
<li><a href='#dropoutpercent'><p>Estimate 4sU dropout percentages</p></a></li>
<li><a href='#estimate.dispersion'><p>Estimate dispersion parameters for a count matrix using DESeq2</p></a></li>
<li><a href='#EstimateRegulation'><p>Estimate regulation from snapshot experiments</p></a></li>
<li><a href='#f.nonconst'><p>Function to compute the abundance of new or old RNA at time t for non-constant rates.</p></a></li>
<li><a href='#f.nonconst.linear'><p>Function to compute the abundance of new or old RNA at time t for non-constant rates.</p></a></li>
<li><a href='#f.old.equi'><p>Functions to compute the abundance of new or old RNA at time t.</p></a></li>
<li><a href='#FilterGenes'><p>Filter genes</p></a></li>
<li><a href='#Findno4sUPairs'><p>Find equivalent no4sU samples for 4sU samples</p></a></li>
<li><a href='#FindReferences'><p>Obtain reference columns (samples or cells) for all columns (samples or cells) in the data set</p></a></li>
<li><a href='#FitKinetics'><p>Fit kinetic models to all genes.</p></a></li>
<li><a href='#FitKineticsGeneLeastSquares'><p>Fit a kinetic model according to non-linear least squares.</p></a></li>
<li><a href='#FitKineticsGeneLogSpaceLinear'><p>Fit a kinetic model using a linear model.</p></a></li>
<li><a href='#FitKineticsGeneNtr'><p>Fit a kinetic model using the degradation rate transformed NTR posterior distribution.</p></a></li>
<li><a href='#FitKineticsGeneSnapshot'><p>Compute the posterior distributions of RNA synthesis and degradation for a particular gene</p></a></li>
<li><a href='#FitKineticsPulseR'><p>Fit kinetics using pulseR</p></a></li>
<li><a href='#FitKineticsSnapshot'><p>Fits RNA kinetics from snapshot experiments</p></a></li>
<li><a href='#FormatCorrelation'><p>Formatting function for correlations</p></a></li>
<li><a href='#GeneInfo'><p>Get the gene annotation table or add additional columns to it</p></a></li>
<li><a href='#Genes'><p>Gene and sample (or cell) names</p></a></li>
<li><a href='#get.mode.slot'><p>Internal functions to parse mode.slot strings</p></a></li>
<li><a href='#GetAnalysisTable'><p>Obtain a table of analysis results values</p></a></li>
<li><a href='#GetContrasts'><p>Create a contrast matrix</p></a></li>
<li><a href='#GetData'><p>Obtain a tidy table of values for a gene or a small set of genes</p></a></li>
<li><a href='#GetDiagnosticParameters'><p>Describe parameters relevant to diagnostics</p></a></li>
<li><a href='#GetMatrix'><p>Obtain a genes x values table as a large matrix</p></a></li>
<li><a href='#GetPairContrasts'><p>Create a contrast matrix for two given conditions</p></a></li>
<li><a href='#GetSignificantGenes'><p>Significant genes</p></a></li>
<li><a href='#GetSummarizeMatrix'><p>Create a summarize matrix</p></a></li>
<li><a href='#GetTable'><p>Obtain a genes x values table</p></a></li>
<li><a href='#grandR'><p>Create a grandR object and retrieve basic information</p></a></li>
<li><a href='#IsParallel'><p>Checks for parallel execution</p></a></li>
<li><a href='#LFC'><p>Estimation of log2 fold changes</p></a></li>
<li><a href='#LikelihoodRatioTest'><p>Compute a likelihood ratio test.</p></a></li>
<li><a href='#ListGeneSets'><p>List available gene sets</p></a></li>
<li><a href='#MakeColdata'><p>Extract an annotation table from a formatted names vector</p></a></li>
<li><a href='#MAPlot'><p>Make an MA plot</p></a></li>
<li><a href='#Normalize'><p>Normalization</p></a></li>
<li><a href='#NormalizeBaseline'><p>Normalization to a baseline</p></a></li>
<li><a href='#Pairwise'><p>Log2 fold changes and Wald tests for differential expression</p></a></li>
<li><a href='#PairwiseDESeq2'><p>Perform Wald tests for differential expression</p></a></li>
<li><a href='#PlotAnalyses'><p>Convenience function to make the same type of plot for multple analyses.</p></a></li>
<li><a href='#PlotConversionFreq'><p>Diagnostic plot for conversion frequencies</p></a></li>
<li><a href='#PlotGeneGroupsBars'><p>Plot gene values as bars</p></a></li>
<li><a href='#PlotGeneGroupsPoints'><p>Plot gene groups as points</p></a></li>
<li><a href='#PlotGeneOldVsNew'><p>Gene plot comparing old vs new RNA</p></a></li>
<li><a href='#PlotGeneProgressiveTimecourse'><p>Plot progressive labeling timecourses</p></a></li>
<li><a href='#PlotGeneSnapshotTimecourse'><p>Gene plot for snapshot timecourse data</p></a></li>
<li><a href='#PlotGeneTotalVsNtr'><p>Gene plot comparing total RNA vs the NTR</p></a></li>
<li><a href='#PlotHeatmap'><p>Create heatmaps from grandR objects</p></a></li>
<li><a href='#PlotMismatchPositionForSample'><p>Diagnostic plot for mismatch position for columns (by sample)</p></a></li>
<li><a href='#PlotMismatchPositionForType'><p>Diagnostic plot for mismatch position for columns (by mismatch type)</p></a></li>
<li><a href='#PlotModelCompareConv'><p>Diagnostic plot for estimated models (global conversion rate)</p></a></li>
<li><a href='#PlotModelCompareErr'><p>Diagnostic plot for estimated models (global error rate)</p></a></li>
<li><a href='#PlotModelCompareErrPrior'><p>Diagnostic plot for estimated models (global error rate)</p></a></li>
<li><a href='#PlotModelCompareLL'><p>Diagnostic plot for estimated models (log likelihoods)</p></a></li>
<li><a href='#PlotModelCompareNtr'><p>Diagnostic plot for estimated models (global NTR)</p></a></li>
<li><a href='#PlotModelConv'><p>Diagnostic plot for estimated models (global conversion rate)</p></a></li>
<li><a href='#PlotModelErr'><p>Diagnostic plot for estimated models (global error rate)</p></a></li>
<li><a href='#PlotModelLabelTimeCourse'><p>Diagnostic plot for estimated models (4sU increase)</p></a></li>
<li><a href='#PlotModelNtr'><p>Diagnostic plot for estimated models (global NTR)</p></a></li>
<li><a href='#PlotModelShape'><p>Diagnostic plot for estimated models (global shape parameter)</p></a></li>
<li><a href='#PlotPCA'><p>Make a PCA plot</p></a></li>
<li><a href='#PlotProfileLikelihood'><p>Diagnostic plot for estimated models (global error rate)</p></a></li>
<li><a href='#Plots'><p>Stored plot functions</p></a></li>
<li><a href='#PlotScatter'><p>Make a scatter plot</p></a></li>
<li><a href='#PlotSimulation'><p>Plot simulated data</p></a></li>
<li><a href='#PlotTypeDistribution'><p>Plot the distribution of gene types</p></a></li>
<li><a href='#PoolColumns'><p>Pool reads across columns</p></a></li>
<li><a href='#psapply'><p>Parallel (s/l)apply</p></a></li>
<li><a href='#ReadCounts'><p>Read a count table</p></a></li>
<li><a href='#ReadFeatureCounts'><p>Read featureCounts</p></a></li>
<li><a href='#ReadGRAND'><p>Read the output of GRAND-SLAM 2.0 into a grandR object.</p></a></li>
<li><a href='#ReadGRAND3'><p>Read the output of GRAND-SLAM 3.0 into a grandR object.</p></a></li>
<li><a href='#ReadNewTotal'><p>Read sparse new/total matrices</p></a></li>
<li><a href='#RotatateAxisLabels'><p>Rotate x axis labels</p></a></li>
<li><a href='#SaveNtrSlot'><p>Copy the NTR slot and save under new name</p></a></li>
<li><a href='#Scale'><p>Scale data</p></a></li>
<li><a href='#Semantics.concentration'><p>Semantics for concentration columns</p></a></li>
<li><a href='#Semantics.time'><p>Semantics for time columns</p></a></li>
<li><a href='#ServeGrandR'><p>Serve a shiny web interface</p></a></li>
<li><a href='#SetParallel'><p>Set up parallel execution</p></a></li>
<li><a href='#SimulateKinetics'><p>Simulate the kinetics of old and new RNA for given parameters.</p></a></li>
<li><a href='#SimulateReadsForSample'><p>Simulate metabolic labeling - nucleotide conversion RNA-seq data.</p></a></li>
<li><a href='#SimulateTimeCourse'><p>Simulate a complete time course of metabolic labeling - nucleotide conversion RNA-seq data.</p></a></li>
<li><a href='#SimulateTimeCourseNonConstant'><p>Simulate a complete time course of metabolic labeling - nucleotide conversion RNA-seq data.</p></a></li>
<li><a href='#Slots'><p>Slot functions</p></a></li>
<li><a href='#structure2vector'><p>Convert a structure into a vector</p></a></li>
<li><a href='#ToIndex'><p>Obtain the indices of the given genes</p></a></li>
<li><a href='#Transform.no'><p>Transformations for PlotHeatmap</p></a></li>
<li><a href='#TransformSnapshot'><p>Estimate parameters for a one-shot experiment.</p></a></li>
<li><a href='#UpdateSymbols'><p>Update symbols using biomaRt</p></a></li>
<li><a href='#UseNtrSlot'><p>Copy the NTR slot and save under new name</p></a></li>
<li><a href='#VulcanoPlot'><p>Make a Vulcano plot</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.2.5</td>
</tr>
<tr>
<td>Title:</td>
<td>Comprehensive Analysis of Nucleotide Conversion Sequencing Data</td>
</tr>
<tr>
<td>Description:</td>
<td>Nucleotide conversion sequencing experiments have been
  developed to add a temporal dimension to RNA-seq and single-cell RNA-seq. Such 
  experiments require specialized tools for primary processing such as GRAND-SLAM,
  (see 'Jürges et al' &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbty256">doi:10.1093/bioinformatics/bty256</a>&gt;) and specialized tools for 
  downstream analyses. 'grandR' provides a comprehensive toolbox for quality control,
  kinetic modeling, differential gene expression analysis and visualization of such data.</td>
</tr>
<tr>
<td>Author:</td>
<td>Florian Erhard <a href="https://orcid.org/0000-0002-3574-6983"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Teresa Rummel [ctb],
  Lygeri Sakellaridi [ctb],
  Kevin Berg [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Florian Erhard &lt;Florian.Erhard@informatik.uni-regensburg.de&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/erhard-lab/grandR">https://github.com/erhard-lab/grandR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/erhard-lab/grandR/issues">https://github.com/erhard-lab/grandR/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, Matrix, rlang, ggplot2, grDevices, patchwork, RCurl,
plyr, parallel, reshape2, MASS, scales, cowplot, minpack.lm,
lfc, labeling, methods, utils, numDeriv</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, circlize, Seurat, ComplexHeatmap, ggrepel,
DESeq2, S4Vectors, data.table, clusterProfiler, biomaRt,
msigdbr, fgsea, rclipboard, cubature, DT, shinyjs, shinyjqui,
RColorBrewer, gsl, htmltools, matrixStats, monocle, VGAM,
quantreg, graphics, shiny, ggrastr, viridisLite, deSolve</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-09 11:51:15 UTC; erhard</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-15 15:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Analyses'>Analysis table functions</h2><span id='topic+Analyses'></span><span id='topic+AddAnalysis'></span><span id='topic+DropAnalysis'></span>

<h3>Description</h3>

<p>Get analysis names and add or remove analyses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Analyses(data, description = FALSE)

AddAnalysis(
  data,
  name,
  table,
  by = NULL,
  warn.present = TRUE,
  warn.genes = TRUE
)

DropAnalysis(data, pattern = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Analyses_+3A_data">data</code></td>
<td>
<p>A grandR object</p>
</td></tr>
<tr><td><code id="Analyses_+3A_description">description</code></td>
<td>
<p>if TRUE, also return the column names of each analysis table (i.e. a list named according to the analyses)</p>
</td></tr>
<tr><td><code id="Analyses_+3A_name">name</code></td>
<td>
<p>The user-defined analysis name</p>
</td></tr>
<tr><td><code id="Analyses_+3A_table">table</code></td>
<td>
<p>The analysis table to add</p>
</td></tr>
<tr><td><code id="Analyses_+3A_by">by</code></td>
<td>
<p>Specify a column that contains gene names or symbols (see details)</p>
</td></tr>
<tr><td><code id="Analyses_+3A_warn.present">warn.present</code></td>
<td>
<p>Warn if an analysis with the same name is already present (and then overwrite)</p>
</td></tr>
<tr><td><code id="Analyses_+3A_warn.genes">warn.genes</code></td>
<td>
<p>Warn if genes are missing (and then add NA)</p>
</td></tr>
<tr><td><code id="Analyses_+3A_pattern">pattern</code></td>
<td>
<p>A regular expression that is matched to analysis names</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The columns in the analysis tables are defined by the analysis method (e.g. &quot;Synthesis&quot;,&quot;Half-life&quot; and &quot;rmse&quot; by <code>FitKinetics</code>).
A call to an analysis function might produce more than one table (e.g. because kinetic modeling is done for multiple <a href="#topic+Condition">Condition</a>s). In this case,
AddAnalysisTable produces more than one analysis table.
</p>
<p><code>AddAnalysis</code> is in most cases  not called directly by the user, but is
used by analysis methods to add their final result to a grandR object (e.g., <a href="#topic+FitKinetics">FitKinetics</a>,<a href="#topic+LikelihoodRatioTest">LikelihoodRatioTest</a>,<a href="#topic+LFC">LFC</a>,<a href="#topic+PairwiseDESeq2">PairwiseDESeq2</a>).
</p>
<p>If it is called by the user (e.g. to add analysis results from external tools or from the literature, see pulse-chase vignette), then
the user must make sure that either the rownames of the given table can be recognized as genes (names or symbols), or that there is a column in the
table giving genes (this must be specified as the &quot;by&quot; parameter). The table does neither have to be sorted the same way the grandR object is, nor does
it have to be complete. <code>AddAnalysis</code> will take care or reordering and inserting NA for missing genes (and it will issue a warning in case of missing genes).
</p>


<h3>Value</h3>

<p>Either the analysis names or a grandR data with added/removed slots or the metatable to be used with AddAnalysis
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>Analyses()</code>: Obtain the analyses names
</p>
</li>
<li> <p><code>AddAnalysis()</code>: Add an analysis table
</p>
</li>
<li> <p><code>DropAnalysis()</code>: Remove analyses from the grandR object
</p>
</li></ul>


<h3>See Also</h3>

<p><a href="#topic+Slots">Slots</a>, <a href="#topic+DefaultSlot">DefaultSlot</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sars &lt;- ReadGRAND(system.file("extdata", "sars.tsv.gz", package = "grandR"),
                  design=c("Cell",Design$dur.4sU,Design$Replicate))

sars &lt;- Normalize(sars)     # default behavior is to update the default slot; this calls AddSlot
Slots(sars)
DefaultSlot(sars)
sars &lt;- DropSlot(sars,"norm")
sars                        # note that the default slot reverted to count

</code></pre>

<hr>
<h2 id='AnalyzeGeneSets'>Gene set analysis</h2><span id='topic+AnalyzeGeneSets'></span>

<h3>Description</h3>

<p>Perform gene-set enrichment and overrepresentation analysis (GSEA/ORA) for a specified
set of genes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AnalyzeGeneSets(
  data,
  analysis = Analyses(data)[1],
  criteria = LFC,
  genes = NULL,
  species = NULL,
  category = NULL,
  subcategory = NULL,
  verbose = TRUE,
  minSize = 10,
  maxSize = 500,
  process.genesets = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AnalyzeGeneSets_+3A_data">data</code></td>
<td>
<p>the grandR object that contains the data to analyze</p>
</td></tr>
<tr><td><code id="AnalyzeGeneSets_+3A_analysis">analysis</code></td>
<td>
<p>the analysis to use, can be more than one and can be regexes (see details)</p>
</td></tr>
<tr><td><code id="AnalyzeGeneSets_+3A_criteria">criteria</code></td>
<td>
<p>an expression to define criteria for GSEA/ORA (see details)</p>
</td></tr>
<tr><td><code id="AnalyzeGeneSets_+3A_genes">genes</code></td>
<td>
<p>specify genes directly (use analysis and criteria if NULL; see details)</p>
</td></tr>
<tr><td><code id="AnalyzeGeneSets_+3A_species">species</code></td>
<td>
<p>the species the genes belong to (eg &quot;Homo sapiens&quot;); can be NULL, then the species is inferred from gene ids (see details)</p>
</td></tr>
<tr><td><code id="AnalyzeGeneSets_+3A_category">category</code></td>
<td>
<p>the category defining gene sets (see <a href="#topic+ListGeneSets">ListGeneSets</a>)</p>
</td></tr>
<tr><td><code id="AnalyzeGeneSets_+3A_subcategory">subcategory</code></td>
<td>
<p>the category defining gene sets (see <a href="#topic+ListGeneSets">ListGeneSets</a>)</p>
</td></tr>
<tr><td><code id="AnalyzeGeneSets_+3A_verbose">verbose</code></td>
<td>
<p>Print status messages</p>
</td></tr>
<tr><td><code id="AnalyzeGeneSets_+3A_minsize">minSize</code></td>
<td>
<p>The minimal size of a gene set to be considered</p>
</td></tr>
<tr><td><code id="AnalyzeGeneSets_+3A_maxsize">maxSize</code></td>
<td>
<p>The maximal size of a gene set to be considered</p>
</td></tr>
<tr><td><code id="AnalyzeGeneSets_+3A_process.genesets">process.genesets</code></td>
<td>
<p>a function to process geneset names; can be NULL (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The analysis parameter (just like for <a href="#topic+GetAnalysisTable">GetAnalysisTable</a> can be a regex (that will be matched
against all available analysis names). It can also be a vector (of regexes). Be careful with this, if
more than one table e.g. with column LFC ends up in here, only the first is used (if criteria=LFC).
</p>
<p>The criteria parameter can be used to define how analyses are performed. The criteria must be an expression
that either evaluates into a numeric or logical vector. In the first case, GSEA is performed, in the latter it is ORA.
The columns of the given analysis table(s) can be used to build this expression.
</p>
<p>If no species is given, a very simple automatic inference is done, which will only work when having human or mouse ENSEMBL identifiers as gene ids.
</p>
<p>The process.genesets parameters can be function that takes the character vector representing the names of all gene sets. The original names are replaced
by the return value of this function.
</p>


<h3>Value</h3>

<p>the clusterprofile object representing the analysis results.
</p>


<h3>See Also</h3>

<p><a href="clusterProfiler.html#topic+GSEA">GSEA</a>,<a href="clusterProfiler.html#topic+enricher">enricher</a>,<a href="msigdbr.html#topic+msigdbr">msigdbr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See the differential-expression vignette!

</code></pre>

<hr>
<h2 id='ApplyContrasts'>Apply a function over contrasts</h2><span id='topic+ApplyContrasts'></span>

<h3>Description</h3>

<p>Helper function to run many pairwise comparisons using a contrast matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ApplyContrasts(
  data,
  analysis,
  name.prefix,
  contrasts,
  mode.slot = NULL,
  genes = NULL,
  verbose = FALSE,
  FUN,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ApplyContrasts_+3A_data">data</code></td>
<td>
<p>the grandR object</p>
</td></tr>
<tr><td><code id="ApplyContrasts_+3A_analysis">analysis</code></td>
<td>
<p>a plain name, only used for status messages</p>
</td></tr>
<tr><td><code id="ApplyContrasts_+3A_name.prefix">name.prefix</code></td>
<td>
<p>the prefix for the new analysis name; a dot and the column names of the contrast matrix are appended; can be NULL (then only the contrast matrix names are used)</p>
</td></tr>
<tr><td><code id="ApplyContrasts_+3A_contrasts">contrasts</code></td>
<td>
<p>contrast matrix that defines all pairwise comparisons, generated using <a href="#topic+GetContrasts">GetContrasts</a></p>
</td></tr>
<tr><td><code id="ApplyContrasts_+3A_mode.slot">mode.slot</code></td>
<td>
<p>which slot to take expression values from</p>
</td></tr>
<tr><td><code id="ApplyContrasts_+3A_genes">genes</code></td>
<td>
<p>restrict analysis to these genes; NULL means all genes</p>
</td></tr>
<tr><td><code id="ApplyContrasts_+3A_verbose">verbose</code></td>
<td>
<p>print status messages?</p>
</td></tr>
<tr><td><code id="ApplyContrasts_+3A_fun">FUN</code></td>
<td>
<p>a function taking 1. the data matrix, 2. a logical vector indicating condition A and 3. a logical vector indicating condition B</p>
</td></tr>
<tr><td><code id="ApplyContrasts_+3A_...">...</code></td>
<td>
<p>further parameters forward to FUN</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To implement most pairwise analyses, you only have to define FUN; see the source code of <a href="#topic+LFC">LFC</a> for an example!
</p>


<h3>Value</h3>

<p>a new grandR object with added analysis tables (that were returned by FUN)
</p>


<h3>See Also</h3>

<p><a href="#topic+LFC">LFC</a>,<a href="#topic+PairwiseDESeq2">PairwiseDESeq2</a>,<a href="#topic+GetContrasts">GetContrasts</a>
</p>

<hr>
<h2 id='as.Seurat.grandR'>Create Seurat object from a grandR object</h2><span id='topic+as.Seurat.grandR'></span>

<h3>Description</h3>

<p>Create Seurat object from a grandR object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.Seurat.grandR(
  data,
  modalities = c(RNA = "total", newRNA = "new"),
  hls = NULL,
  time = NULL,
  mode = c("assay", "cells", "genes", "list")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.Seurat.grandR_+3A_data">data</code></td>
<td>
<p>a grandR object</p>
</td></tr>
<tr><td><code id="as.Seurat.grandR_+3A_modalities">modalities</code></td>
<td>
<p>vector defining modalities to include in the Seurat object (see details)</p>
</td></tr>
<tr><td><code id="as.Seurat.grandR_+3A_hls">hls</code></td>
<td>
<p>half-lives for computing previous RNA, only required for &quot;prev&quot; modality (see details)</p>
</td></tr>
<tr><td><code id="as.Seurat.grandR_+3A_time">time</code></td>
<td>
<p>labeling time, only required for &quot;prev&quot; modality (see details)</p>
</td></tr>
<tr><td><code id="as.Seurat.grandR_+3A_mode">mode</code></td>
<td>
<p>how to integrate modalities into seurat object (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Modalities must be a named character vector. The only allowed elements are &quot;total&quot; (total counts),
&quot;new&quot; (new counts), &quot;old&quot; (old counts), &quot;prev&quot; (estimated previous time point counts). The names of the elements are further
used depending on mode.
</p>
<p>To compute the previous time point counts, a vector of half lives and the labeling time is required. The half-lives
must be given in the correct order (same as in the grandR object).
</p>
<p>The mode parameter defines how the defined modalities are represented in the Seurat object. &quot;assay&quot; means
that for each modality, the Seurat object will contain an assay (named according to the corresponding name in modalities).
&quot;cells&quot; means that cells will be copied for each modality and cell names are prefixed by the corresponding name in modalities
(i.e., if the grandR object has 1000 cells named c1,...,c1000, and modalities=c(RNA=&quot;total&quot;,newRNA=&quot;new&quot;), the Seurat object
will have 2000 cells named RNA.c1,...,RNA.c1000,newRNA.c1,...,newRNA.c1000). &quot;genes&quot; means that genes fill be copied for each
modality and gene names are prefixed by the corresponding name in modalities. &quot;list&quot; means that instead of a single Seurat object,
a list of Seurat objects is returned.
</p>


<h3>Value</h3>

<p>a Seurat object
</p>

<hr>
<h2 id='CalibrateEffectiveLabelingTimeKineticFit'>Uses the kinetic model to calibrate the effective labeling time.</h2><span id='topic+CalibrateEffectiveLabelingTimeKineticFit'></span>

<h3>Description</h3>

<p>The NTRs of each sample might be systematically too small (or large). This function identifies such systematic
deviations and computes labeling durations without systematic deviations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalibrateEffectiveLabelingTimeKineticFit(
  data,
  slot = DefaultSlot(data),
  time = Design$dur.4sU,
  time.name = "calibrated_time",
  time.conf.name = "calibrated_time_conf",
  CI.size = 0.95,
  compute.confidence = FALSE,
  n.estimate = 1000,
  n.iter = 10000,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalibrateEffectiveLabelingTimeKineticFit_+3A_data">data</code></td>
<td>
<p>A grandR object</p>
</td></tr>
<tr><td><code id="CalibrateEffectiveLabelingTimeKineticFit_+3A_slot">slot</code></td>
<td>
<p>The data slot to take expression values from</p>
</td></tr>
<tr><td><code id="CalibrateEffectiveLabelingTimeKineticFit_+3A_time">time</code></td>
<td>
<p>The column in the column annotation table representing the labeling duration</p>
</td></tr>
<tr><td><code id="CalibrateEffectiveLabelingTimeKineticFit_+3A_time.name">time.name</code></td>
<td>
<p>The name in the column annotation table to put the calibrated labeling durations</p>
</td></tr>
<tr><td><code id="CalibrateEffectiveLabelingTimeKineticFit_+3A_time.conf.name">time.conf.name</code></td>
<td>
<p>The name in the column annotation table to put the confidence values for the labeling durations (half-size of the confidence interval)</p>
</td></tr>
<tr><td><code id="CalibrateEffectiveLabelingTimeKineticFit_+3A_ci.size">CI.size</code></td>
<td>
<p>The level for confidence intervals</p>
</td></tr>
<tr><td><code id="CalibrateEffectiveLabelingTimeKineticFit_+3A_compute.confidence">compute.confidence</code></td>
<td>
<p>should CIs be computed or not?</p>
</td></tr>
<tr><td><code id="CalibrateEffectiveLabelingTimeKineticFit_+3A_n.estimate">n.estimate</code></td>
<td>
<p>the times are calibrated with the top n expressed genes</p>
</td></tr>
<tr><td><code id="CalibrateEffectiveLabelingTimeKineticFit_+3A_n.iter">n.iter</code></td>
<td>
<p>the maximal number of iterations for the numerical optimization</p>
</td></tr>
<tr><td><code id="CalibrateEffectiveLabelingTimeKineticFit_+3A_verbose">verbose</code></td>
<td>
<p>verbose output</p>
</td></tr>
<tr><td><code id="CalibrateEffectiveLabelingTimeKineticFit_+3A_...">...</code></td>
<td>
<p>forwarded to FitKinetics</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are many reasons why the nominal (wall-clock) time of 4sU labeling might be distinct from the effective labeling time. Most
importantly, 4sU needs some time to enter the cells and get activated to be ready for transcription. Therefore, the 4sU concentration
(relative to the U concentration) rises, based on observations, over the timeframe of 1-2h. GRAND-SLAM assumes a constant 4sU incorporation rate,
i.e. specifically new RNA made early during the labeling is underestimated. This, especially for short labeling (&lt;2h), the effective labeling duration
might be significantly less than the nominal labeling duration.
</p>
<p>It is impossible to obtain a perfect absolute calibration, i.e. all durations might be off by a factor.
</p>


<h3>Value</h3>

<p>A new grandR object containing the calibrated durations in the column data annotation
</p>


<h3>See Also</h3>

<p><a href="#topic+FitKinetics">FitKinetics</a>
</p>

<hr>
<h2 id='CalibrateEffectiveLabelingTimeMatchHalflives'>Calibrate the effective labeling time by matching half-lives to a .reference</h2><span id='topic+CalibrateEffectiveLabelingTimeMatchHalflives'></span>

<h3>Description</h3>

<p>The NTRs of each sample might be systematically too small (or large). This function identifies such systematic
deviations and computes labeling durations without systematic deviations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalibrateEffectiveLabelingTimeMatchHalflives(
  data,
  reference.halflives = NULL,
  reference.columns = NULL,
  slot = DefaultSlot(data),
  time.labeling = Design$dur.4sU,
  time.experiment = NULL,
  time.name = "calibrated_time",
  n.estimate = 1000,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalibrateEffectiveLabelingTimeMatchHalflives_+3A_data">data</code></td>
<td>
<p>A grandR object</p>
</td></tr>
<tr><td><code id="CalibrateEffectiveLabelingTimeMatchHalflives_+3A_reference.halflives">reference.halflives</code></td>
<td>
<p>a vector of reference Half-lives named by genes</p>
</td></tr>
<tr><td><code id="CalibrateEffectiveLabelingTimeMatchHalflives_+3A_reference.columns">reference.columns</code></td>
<td>
<p>the reference column description</p>
</td></tr>
<tr><td><code id="CalibrateEffectiveLabelingTimeMatchHalflives_+3A_slot">slot</code></td>
<td>
<p>The data slot to take expression values from</p>
</td></tr>
<tr><td><code id="CalibrateEffectiveLabelingTimeMatchHalflives_+3A_time.labeling">time.labeling</code></td>
<td>
<p>the column in the column annotation table denoting the labeling duration or the labeling duration itself</p>
</td></tr>
<tr><td><code id="CalibrateEffectiveLabelingTimeMatchHalflives_+3A_time.experiment">time.experiment</code></td>
<td>
<p>the column in the column annotation table denoting the experimental time point (can be NULL, see details)</p>
</td></tr>
<tr><td><code id="CalibrateEffectiveLabelingTimeMatchHalflives_+3A_time.name">time.name</code></td>
<td>
<p>The name in the column annotation table to put the calibrated labeling durations</p>
</td></tr>
<tr><td><code id="CalibrateEffectiveLabelingTimeMatchHalflives_+3A_n.estimate">n.estimate</code></td>
<td>
<p>the times are calibrated with the top n expressed genes</p>
</td></tr>
<tr><td><code id="CalibrateEffectiveLabelingTimeMatchHalflives_+3A_verbose">verbose</code></td>
<td>
<p>verbose output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new grandR object containing the calibrated durations in the column data annotation
</p>


<h3>See Also</h3>

<p><a href="#topic+FitKineticsGeneSnapshot">FitKineticsGeneSnapshot</a>
</p>

<hr>
<h2 id='check.analysis'>Internal functions to check for a valid analysis or slot names.</h2><span id='topic+check.analysis'></span><span id='topic+check.slot'></span><span id='topic+check.mode.slot'></span>

<h3>Description</h3>

<p>Internal functions to check for a valid analysis or slot names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.analysis(data, analyses, regex)

check.slot(data, slot, allow.ntr = TRUE)

check.mode.slot(data, mode.slot, allow.ntr = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.analysis_+3A_data">data</code></td>
<td>
<p>a grandR object</p>
</td></tr>
<tr><td><code id="check.analysis_+3A_analyses">analyses</code></td>
<td>
<p>a regex to be matched to analysis names</p>
</td></tr>
<tr><td><code id="check.analysis_+3A_regex">regex</code></td>
<td>
<p>interpret as regular expression</p>
</td></tr>
<tr><td><code id="check.analysis_+3A_slot">slot</code></td>
<td>
<p>a slot name</p>
</td></tr>
<tr><td><code id="check.analysis_+3A_allow.ntr">allow.ntr</code></td>
<td>
<p>whether to allow for the value &quot;ntr&quot; (and throw an error in case)</p>
</td></tr>
<tr><td><code id="check.analysis_+3A_mode.slot">mode.slot</code></td>
<td>
<p>a mode.slot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A mode.slot is a mode followed by a dot followed by a slot name, or just a slot name. A mode is either <em>total</em>, <em>new</em> or <em>old</em>.
</p>


<h3>Value</h3>

<p>Whether or not the given name is valid and unique for the grandR object
</p>

<hr>
<h2 id='ClassifyGenes'>Build the type column for the gene info table.</h2><span id='topic+ClassifyGenes'></span>

<h3>Description</h3>

<p>Returns a function to be used as <code>classify.genes</code> parameter for <code><a href="#topic+ReadGRAND">ReadGRAND</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClassifyGenes(
  ...,
  use.default = TRUE,
  drop.levels = TRUE,
  name.unknown = "Unknown"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ClassifyGenes_+3A_...">...</code></td>
<td>
<p>additional functions to define types (see details)</p>
</td></tr>
<tr><td><code id="ClassifyGenes_+3A_use.default">use.default</code></td>
<td>
<p>if TRUE, use the default type inference (priority after the user defined ones); see details</p>
</td></tr>
<tr><td><code id="ClassifyGenes_+3A_drop.levels">drop.levels</code></td>
<td>
<p>if TRUE, drop unused types from the factor that is generated</p>
</td></tr>
<tr><td><code id="ClassifyGenes_+3A_name.unknown">name.unknown</code></td>
<td>
<p>the type to be used for all genes where no type was identified</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a function. Usually, you do not use it yourself but <code>ClassifyGenes</code> is usually as <code>classify.genes</code> parameter
for  <code><a href="#topic+ReadGRAND">ReadGRAND</a></code> to build the <em>Type</em> column in the <code><a href="#topic+GeneInfo">GeneInfo</a></code> table. See the example
to see how to use it directly.
</p>
<p>Each ... parameter must be a function that receives the gene info table and must return a logical vector, indicating for each row
in the gene info table, whether it matches to a specific type. The name of the parameter is used as the type name.
</p>
<p>If a gene matches to multiple type, the first function returning TRUE for a row in the table is used.
</p>
<p>By default, this function will recognize mitochondrial genes (MT prefix of the gene symbol), ERCC spike-ins,
and Ensembl gene identifiers (which it will call &quot;cellular&quot;). These three are the last functions to be checked (in case a user defined type via ...) also
matches to, e.g., an Ensembl gene).
</p>


<h3>Value</h3>

<p>a function that takes the original <a href="#topic+GeneInfo">GeneInfo</a> table and adds the Type column
</p>


<h3>See Also</h3>

<p><a href="#topic+ReadGRAND">ReadGRAND</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
viral.genes &lt;- c('ORF3a','E','M','ORF6','ORF7a','ORF7b','ORF8','N','ORF10','ORF1ab','S')
sars &lt;- ReadGRAND(system.file("extdata", "sars.tsv.gz", package = "grandR"),
                  design=c("Cell",Design$dur.4sU,Design$Replicate),
                  classify.genes=ClassifyGenes(`SARS-CoV-2`=
                             function(gene.info) gene.info$Symbol %in% viral.genes),
                  verbose=TRUE)
table(GeneInfo(sars)$Type)

fun&lt;-ClassifyGenes(viral=function(gene.info) gene.info$Symbol %in% viral.genes)
table(fun(GeneInfo(sars)))

</code></pre>

<hr>
<h2 id='Coldata'>Get the column annotation table or add additional columns to it</h2><span id='topic+Coldata'></span><span id='topic+Coldata+3C-'></span>

<h3>Description</h3>

<p>The columns of a grandR object are samples or cells.
The column annotation table contains meta information for the columns of a grandR object.
When loaded from the GRAND-SLAM output, this this constructed from the sample/cell names by
<code><a href="#topic+MakeColdata">MakeColdata</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Coldata(data, column = NULL, value = NULL)

Coldata(data, column) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Coldata_+3A_data">data</code></td>
<td>
<p>A grandR object</p>
</td></tr>
<tr><td><code id="Coldata_+3A_column">column</code></td>
<td>
<p>The name of the additional annotation column; can also be a data frame (then value is ignored and the data frame is added)</p>
</td></tr>
<tr><td><code id="Coldata_+3A_value">value</code></td>
<td>
<p>The additional annotation per sample or cell</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A new column can be added either by <code>data&lt;-Coldata(data,name,values)</code> or by <code>Coldata(data,name)&lt;-values</code>.
</p>
<p>Several new columns can be added by <code>data&lt;-Coldata(data,df)</code> where df is either a data frame or matrix.
</p>
<p>The column named <em>Condition</em> has a special meaning in this table: It is used by several functions to stratify the columns
during the analysis (e.g. to estimate separate kinetic parameters with <code><a href="#topic+FitKinetics">FitKinetics</a></code> or it is used as covariate for
<code><a href="#topic+LFC">LFC</a></code> or <code><a href="#topic+LikelihoodRatioTest">LikelihoodRatioTest</a></code>). For that reason there are special functions to set and get this column.
</p>


<h3>Value</h3>

<p>Either the column annotation table or a new grandR object having an updated column annotation table
</p>


<h3>See Also</h3>

<p><a href="#topic+GeneInfo">GeneInfo</a>, <a href="#topic+MakeColdata">MakeColdata</a>, <a href="#topic+Condition">Condition</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sars &lt;- ReadGRAND(system.file("extdata", "sars.tsv.gz", package = "grandR"),
                  design=c("Cell",Design$dur.4sU,Design$Replicate))

head(GeneInfo(sars))
GeneInfo(sars,"LengthCategory")&lt;-cut(GeneInfo(sars)$Length,c(0,1500,2500,Inf),
                                          labels=c("Short","Medium","Long"))
table(GeneInfo(sars)$LengthCategory)

</code></pre>

<hr>
<h2 id='ComputeAbsolute'>Compute absolute expression using ERCC spike ins</h2><span id='topic+ComputeAbsolute'></span>

<h3>Description</h3>

<p>Compute absolute expression in a grandR object and puts the normalized data into a new slot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComputeAbsolute(
  data,
  dilution = 40000,
  volume = 10,
  slot = "tpm",
  name = "absolute"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ComputeAbsolute_+3A_data">data</code></td>
<td>
<p>the grandR object</p>
</td></tr>
<tr><td><code id="ComputeAbsolute_+3A_dilution">dilution</code></td>
<td>
<p>the dilution of the spikein transcript in the lysis reaction mix</p>
</td></tr>
<tr><td><code id="ComputeAbsolute_+3A_volume">volume</code></td>
<td>
<p>the approximate volume of the lysis chamber (nanoliters)</p>
</td></tr>
<tr><td><code id="ComputeAbsolute_+3A_slot">slot</code></td>
<td>
<p>the slot containing relative expression values</p>
</td></tr>
<tr><td><code id="ComputeAbsolute_+3A_name">name</code></td>
<td>
<p>the name of the new slot to put absolute expression values in</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a new grandR object with an additional slot
</p>


<h3>See Also</h3>

<p><a href="monocle.html#topic+relative2abs">relative2abs</a>
</p>

<hr>
<h2 id='ComputeColumnStatistics'>Compute statistics for all columns (i.e. samples or cells)</h2><span id='topic+ComputeColumnStatistics'></span>

<h3>Description</h3>

<p>Compute statistics for all columns (i.e. samples or cells)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComputeColumnStatistics(data, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ComputeColumnStatistics_+3A_data">data</code></td>
<td>
<p>a grandR object</p>
</td></tr>
<tr><td><code id="ComputeColumnStatistics_+3A_verbose">verbose</code></td>
<td>
<p>output status messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a new grandR object containing additional columns in the <a href="#topic+Coldata">Coldata</a> table:
</p>

<ul>
<li><p>p.conv.X: the T-to-C mismatch frequency in the given (&quot;X&quot;) subread category
</p>
</li>
<li><p>percent.new: new overall percentage of new RNA
</p>
</li>
<li><p>total.reads: the total number of reads (or UMIs, if UMIs were sequences)
</p>
</li>
<li><p>total.genes: the total number of genes detected
</p>
</li>
<li><p>percentage per type: the percentage (up to 100!) of the counts of each type in the GeneInfo
</p>
</li></ul>


<hr>
<h2 id='ComputeExpressionPercentage'>Expression percentage computation</h2><span id='topic+ComputeExpressionPercentage'></span>

<h3>Description</h3>

<p>Compute the expression percentage for a particular set of genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComputeExpressionPercentage(
  data,
  name,
  genes = Genes(data),
  mode.slot = DefaultSlot(data),
  genes.total = Genes(data),
  mode.slot.total = mode.slot,
  multiply.by.100 = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ComputeExpressionPercentage_+3A_data">data</code></td>
<td>
<p>the grandR object</p>
</td></tr>
<tr><td><code id="ComputeExpressionPercentage_+3A_name">name</code></td>
<td>
<p>the new name by which this is added to the Coldata</p>
</td></tr>
<tr><td><code id="ComputeExpressionPercentage_+3A_genes">genes</code></td>
<td>
<p>define the set of genes to compute the percentage for</p>
</td></tr>
<tr><td><code id="ComputeExpressionPercentage_+3A_mode.slot">mode.slot</code></td>
<td>
<p>which mode.slot to take the values for computing the percentage from</p>
</td></tr>
<tr><td><code id="ComputeExpressionPercentage_+3A_genes.total">genes.total</code></td>
<td>
<p>define the set of genes defining the total value</p>
</td></tr>
<tr><td><code id="ComputeExpressionPercentage_+3A_mode.slot.total">mode.slot.total</code></td>
<td>
<p>which mode.slot to take the values for computing the total</p>
</td></tr>
<tr><td><code id="ComputeExpressionPercentage_+3A_multiply.by.100">multiply.by.100</code></td>
<td>
<p>if TRUE, compute percentage values, otherwise fractions between 0 and 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The percentages are computed for the given genes with the given mode.slot, w.r.t the mode.slot.total from the genes.total. Thus
to compute the percentage of mitochondrial gene expression in total RNA (unnormalized), only set genes=Genes(data,&quot;^MT-&quot;,regex=TRUE).
To compute the percentage of new RNA among all genes, set mode.slot=&quot;new.count&quot; and mode.slot.total=&quot;count&quot;.
</p>
<p>Genes can be referred to by their names, symbols, row numbers in the gene table, or a logical vector referring to the gene table rows.
</p>
<p>To refer to data slots, the mode.slot syntax can be used: Each name is either a data slot, or one of (new,old,total)
followed by a dot followed by a slot. For new or old, the data slot value is multiplied by ntr or 1-ntr. This can be used e.g. to filter by <em>new counts</em>.
</p>


<h3>Value</h3>

<p>a new grandR object having the expression percentage in its Coldata table
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Coldata">Coldata</a></code>
</p>

<hr>
<h2 id='ComputeNonConstantParam'>Compute and evaluate functions for non constant rates</h2><span id='topic+ComputeNonConstantParam'></span><span id='topic+EvaluateNonConstantParam'></span>

<h3>Description</h3>

<p>For simplicity, non constant rates here have the following form $o+f*t^e$.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComputeNonConstantParam(start, end = start, exponent = 1, end.time = 2)

EvaluateNonConstantParam(t, param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ComputeNonConstantParam_+3A_start">start</code></td>
<td>
<p>the value at t=0</p>
</td></tr>
<tr><td><code id="ComputeNonConstantParam_+3A_end">end</code></td>
<td>
<p>the value at t=end.time</p>
</td></tr>
<tr><td><code id="ComputeNonConstantParam_+3A_exponent">exponent</code></td>
<td>
<p>the exponent (e above)</p>
</td></tr>
<tr><td><code id="ComputeNonConstantParam_+3A_end.time">end.time</code></td>
<td>
<p>the end time</p>
</td></tr>
<tr><td><code id="ComputeNonConstantParam_+3A_t">t</code></td>
<td>
<p>vector of times</p>
</td></tr>
<tr><td><code id="ComputeNonConstantParam_+3A_param">param</code></td>
<td>
<p>output of <code>ComputeNonConstantParam()</code>, only a single row!</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame containing either the parameters o, f and e (ComputeNonConstantParam), or containing the value of $o+f*t^e$ for the given times (EvaluateNonConstantParam).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>ComputeNonConstantParam()</code>: compute a data frame containing the parameters for non constant rates
</p>
</li>
<li> <p><code>EvaluateNonConstantParam()</code>: compute a data frame containing the rates for the given parameter set (computed from <code>ComputeNonConstantParam</code>)
</p>
</li></ul>

<hr>
<h2 id='ComputeNtrPosteriorQuantile'>Compute NTR quantiles</h2><span id='topic+ComputeNtrPosteriorQuantile'></span><span id='topic+ComputeNtrCI'></span><span id='topic+ComputeNtrPosteriorLower'></span><span id='topic+ComputeNtrPosteriorUpper'></span>

<h3>Description</h3>

<p>Computes quantiles from the NTR posterior and puts them into a new slot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComputeNtrPosteriorQuantile(data, quantile, name)

ComputeNtrCI(data, CI.size = 0.95, name.lower = "lower", name.upper = "upper")

ComputeNtrPosteriorLower(data, CI.size = 0.95, name = "lower")

ComputeNtrPosteriorUpper(data, CI.size = 0.95, name = "upper")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ComputeNtrPosteriorQuantile_+3A_data">data</code></td>
<td>
<p>the grandR object</p>
</td></tr>
<tr><td><code id="ComputeNtrPosteriorQuantile_+3A_quantile">quantile</code></td>
<td>
<p>which quantile to compute</p>
</td></tr>
<tr><td><code id="ComputeNtrPosteriorQuantile_+3A_name">name</code></td>
<td>
<p>the name of the new slot to put quantile values in</p>
</td></tr>
<tr><td><code id="ComputeNtrPosteriorQuantile_+3A_ci.size">CI.size</code></td>
<td>
<p>A number between 0 and 1 representing the size of the credible interval</p>
</td></tr>
<tr><td><code id="ComputeNtrPosteriorQuantile_+3A_name.lower">name.lower</code></td>
<td>
<p>the name of the new slot to put the lower bound of the CI in</p>
</td></tr>
<tr><td><code id="ComputeNtrPosteriorQuantile_+3A_name.upper">name.upper</code></td>
<td>
<p>the name of the new slot to put the upper bound of the CI in</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The NTR posterior distribution can be approximated by a beta distribution.
</p>
<p>ComputeNtrPosteriorQuantile computes any quantile from this Beta approximation
</p>
<p>ComputeNtrPosteriorLower computes the (1-CI.size)/2 quantile
</p>
<p>ComputeNtrPosteriorUpper computes the 1-(1-CI.size)/2 quantile
</p>
<p>ComputeNtrCI computes both of these quantiles.
</p>


<h3>Value</h3>

<p>a new grandR object containing an additional slot
</p>

<hr>
<h2 id='ComputePseudoNtr'>Compute pseudo NTRs from two count matrices</h2><span id='topic+ComputePseudoNtr'></span>

<h3>Description</h3>

<p>NTRs can be computed from given new and total counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComputePseudoNtr(
  data,
  new.slot,
  total.slot = DefaultSlot(data),
  detection.rate = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ComputePseudoNtr_+3A_data">data</code></td>
<td>
<p>a grandR object</p>
</td></tr>
<tr><td><code id="ComputePseudoNtr_+3A_new.slot">new.slot</code></td>
<td>
<p>the slot containing new RNA counts</p>
</td></tr>
<tr><td><code id="ComputePseudoNtr_+3A_total.slot">total.slot</code></td>
<td>
<p>the slot containing total RNA counts</p>
</td></tr>
<tr><td><code id="ComputePseudoNtr_+3A_detection.rate">detection.rate</code></td>
<td>
<p>the detection rate of T-to-C mismatch reads (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To correct for some bias, a detection rate (as suggested by Cao et al., Nature Biotech 2020) should be provided. This detection rate
defines, how much new RNA is detected on average using the T-to-C mismatch reads.
</p>


<h3>Value</h3>

<p>a new grandR object
</p>

<hr>
<h2 id='ComputeSteadyStateHalfLives'>Steady state half-lives for each sample</h2><span id='topic+ComputeSteadyStateHalfLives'></span>

<h3>Description</h3>

<p>Transforms each NTR to a half-life value (assuming steady state gene expression) and puts them into a new slot or adds an analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComputeSteadyStateHalfLives(
  data,
  time = Design$dur.4sU,
  name = "HL",
  columns = NULL,
  max.HL = 48,
  CI.size = 0.95,
  compute.CI = FALSE,
  as.analysis = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ComputeSteadyStateHalfLives_+3A_data">data</code></td>
<td>
<p>the grandR object</p>
</td></tr>
<tr><td><code id="ComputeSteadyStateHalfLives_+3A_time">time</code></td>
<td>
<p>either a number indicating the labeling time, or a name of the <a href="#topic+Coldata">Coldata</a> table</p>
</td></tr>
<tr><td><code id="ComputeSteadyStateHalfLives_+3A_name">name</code></td>
<td>
<p>the name of the new slot/analysis to put half-life values in</p>
</td></tr>
<tr><td><code id="ComputeSteadyStateHalfLives_+3A_columns">columns</code></td>
<td>
<p>which columns (i.e. samples or cells) to return; sets as.analysis to TRUE (see details)</p>
</td></tr>
<tr><td><code id="ComputeSteadyStateHalfLives_+3A_max.hl">max.HL</code></td>
<td>
<p>all values above this will be set to this</p>
</td></tr>
<tr><td><code id="ComputeSteadyStateHalfLives_+3A_ci.size">CI.size</code></td>
<td>
<p>A number between 0 and 1 representing the size of the credible interval</p>
</td></tr>
<tr><td><code id="ComputeSteadyStateHalfLives_+3A_compute.ci">compute.CI</code></td>
<td>
<p>it TRUE, credible intervals are computed, this also sets as.analysis to TRUE</p>
</td></tr>
<tr><td><code id="ComputeSteadyStateHalfLives_+3A_as.analysis">as.analysis</code></td>
<td>
<p>if TRUE add the results as analysis and not as data slot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An NTR value p can be transformed into an RNA half-live using the equation
log(2)/(-1/t*log(1-p))
This is described in our GRAND-SLAM paper (Juerges et al., Bioinformatics 2018).
</p>
<p>Columns can be given as a logical, integer or character vector representing a selection of the columns (samples or cells).
The expression is evaluated in an environment havin the <code><a href="#topic+Coldata">Coldata</a></code>, i.e. you can use names of <code><a href="#topic+Coldata">Coldata</a></code> as variables to
conveniently build a logical vector (e.g., columns=Condition==&quot;x&quot;).
</p>


<h3>Value</h3>

<p>a new grandR object with an additional slot or analysis
</p>

<hr>
<h2 id='ComputeSummaryStatistics'>Compute summary statistics</h2><span id='topic+ComputeSummaryStatistics'></span>

<h3>Description</h3>

<p>Summary statistics are computed for all samples (or cells).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComputeSummaryStatistics(
  data,
  pairs = Findno4sUPairs(data),
  coldata = FALSE,
  do.bootstrap = FALSE,
  seed = 1337
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ComputeSummaryStatistics_+3A_data">data</code></td>
<td>
<p>a grandR object</p>
</td></tr>
<tr><td><code id="ComputeSummaryStatistics_+3A_pairs">pairs</code></td>
<td>
<p>a no4sU pairs list as generated by <a href="#topic+Findno4sUPairs">Findno4sUPairs</a></p>
</td></tr>
<tr><td><code id="ComputeSummaryStatistics_+3A_coldata">coldata</code></td>
<td>
<p>if TRUE, add the coldata table</p>
</td></tr>
<tr><td><code id="ComputeSummaryStatistics_+3A_do.bootstrap">do.bootstrap</code></td>
<td>
<p>if TRUE, also report standard errors of the 4sU dropout estimated via bootstrapping</p>
</td></tr>
<tr><td><code id="ComputeSummaryStatistics_+3A_seed">seed</code></td>
<td>
<p>the seed for the random number generator for bootstrapping</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a table of summary statistics including:
</p>

<ul>
<li><p>Mean LFC: the mean absolute log2 fold change of each sample vs the corresponding 4sU naive sample
</p>
</li>
<li><p>4sU dropout: the estimated 4sU dropout percentage
</p>
</li>
<li><p>p.conv: The 4sU incorporation frequency estimated by GRAND-SLAM
</p>
</li>
<li><p>Frction labelled: the global NTR
</p>
</li></ul>


<hr>
<h2 id='Condition'>Get or set the conditions in the column annotation table.</h2><span id='topic+Condition'></span><span id='topic+Condition+3C-'></span>

<h3>Description</h3>

<p>The conditions column from the column annotation table is used by several functions to stratify the columns (samples or cells)
during the analysis (e.g. to estimate separate kinetic parameters with <code><a href="#topic+FitKinetics">FitKinetics</a></code> or it is used as covariate for
<code><a href="#topic+LFC">LFC</a></code> or <code><a href="#topic+LikelihoodRatioTest">LikelihoodRatioTest</a></code>). For that reason there are special functions to set and get this column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Condition(data, value = NULL)

Condition(data) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Condition_+3A_data">data</code></td>
<td>
<p>A grandR object</p>
</td></tr>
<tr><td><code id="Condition_+3A_value">value</code></td>
<td>
<p>Either a vector of column names from the column annotation table, or the condition names themselves</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the conditions column does not exist (or has been set to NULL), all analysis functions will work without stratifying samples or cells.
The condition can also be set up directly when loading data, by using <em>Condition</em> as one of the design vector entries (see below).
</p>
<p>The condition can be set either by <code>data&lt;-Condition(data,names)</code> or by <code>Condition(data)&lt;-names</code>.
</p>


<h3>Value</h3>

<p>Either the values of the condition column for Condition(data) or the grandR data object having the new condition column
</p>


<h3>See Also</h3>

<p><a href="#topic+Coldata">Coldata</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sars &lt;- ReadGRAND(system.file("extdata", "sars.tsv.gz", package = "grandR"),
                  design=c("Cell",Design$dur.4sU,Design$Replicate))

Condition(sars)
Condition(sars) &lt;- c("Cell","duration.4sU.original")
Condition(sars)

sars &lt;- ReadGRAND(system.file("extdata", "sars.tsv.gz", package = "grandR"),
                  design=c("Condition",Design$dur.4sU,Design$Replicate))
Condition(sars)

</code></pre>

<hr>
<h2 id='correctdropout'>Correct for 4sU dropout</h2><span id='topic+correctdropout'></span><span id='topic+Correct4sUDropoutHLFactor'></span><span id='topic+Correct4sUDropoutHLSpline'></span>

<h3>Description</h3>

<p>For several potential reasons, a sample specific percentage of reads from labelled RNA might be lost.
This can be corrected for by increasing the amount of labelled RNA (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Correct4sUDropoutHLFactor(
  data,
  pairs = Findno4sUPairs(data),
  factors = Estimate4sUDropoutPercentage(data, pairs = pairs, ...),
  ...
)

Correct4sUDropoutHLSpline(data, pairs = Findno4sUPairs(data), spline.df = 15)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correctdropout_+3A_data">data</code></td>
<td>
<p>a grandR object</p>
</td></tr>
<tr><td><code id="correctdropout_+3A_pairs">pairs</code></td>
<td>
<p>a no4sU pairs list as generated by <a href="#topic+Findno4sUPairs">Findno4sUPairs</a></p>
</td></tr>
<tr><td><code id="correctdropout_+3A_factors">factors</code></td>
<td>
<p>the 4sU dropout percentages</p>
</td></tr>
<tr><td><code id="correctdropout_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
<tr><td><code id="correctdropout_+3A_spline.df">spline.df</code></td>
<td>
<p>the degrees of freedom to be used for smoothing splines</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The factor based correction approach requires estimates of the 4sU dropout percentage d. Labelled RNA is multiplied by 1/(1-d),
and total count and NTRs are adapted accordingly. alpha and beta are also adapted such that their sum is maintained, but the mean of the
corresponding beta function is the new NTR. All other slots are treated to be expression estimates (and are adapted accordingly).
</p>
<p>The spline approach uses quantile regression to fit a smoothing spline to the 4sU dropout rank plot, which is then used to correct labelled RNA.
</p>


<h3>Value</h3>

<p>a new grandR object that is corrected for 4sU dropout
</p>


<h3>See Also</h3>

<p><a href="#topic+Estimate4sUDropoutPercentage">Estimate4sUDropoutPercentage</a>,<a href="#topic+ComputeSummaryStatistics">ComputeSummaryStatistics</a>
</p>

<hr>
<h2 id='CreateConvolutionTable'>Create Convolution Table from a Seurat object</h2><span id='topic+CreateConvolutionTable'></span>

<h3>Description</h3>

<p>Create Convolution Table from a Seurat object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateConvolutionTable(data, n.neighbors = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateConvolutionTable_+3A_data">data</code></td>
<td>
<p>a Seurat object</p>
</td></tr>
<tr><td><code id="CreateConvolutionTable_+3A_n.neighbors">n.neighbors</code></td>
<td>
<p>the number of neighbors to be convoluted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a table which can be used as input for GRAND3. Note that a data set contatining multiple time points should be split before convolution.
</p>


<h3>Value</h3>

<p>a table with two columns &quot;Cell&quot; and &quot;Pseudobulk&quot;
</p>

<hr>
<h2 id='CreatePdfs'>Convencience methods for creating QC pdfs</h2><span id='topic+CreatePdfs'></span><span id='topic+CreatePdfsParameters'></span><span id='topic+CreatePdfsComparison'></span><span id='topic+CreatePdfsProfiles'></span>

<h3>Description</h3>

<p>These methods are invoked by GRAND3 to generate pdfs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreatePdfs(data, labels = NULL, estimators = NULL)

CreatePdfsParameters(data, labels = NULL, estimators = NULL)

CreatePdfsComparison(data, labels = NULL, estimators = NULL)

CreatePdfsProfiles(data, labels = NULL, estimators = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreatePdfs_+3A_data">data</code></td>
<td>
<p>a grandR object</p>
</td></tr>
<tr><td><code id="CreatePdfs_+3A_labels">labels</code></td>
<td>
<p>which label to consider (see <a href="#topic+GetDiagnosticParameters">GetDiagnosticParameters</a>); if NULL, all available estimators are used</p>
</td></tr>
<tr><td><code id="CreatePdfs_+3A_estimators">estimators</code></td>
<td>
<p>which estimator to consider (see <a href="#topic+GetDiagnosticParameters">GetDiagnosticParameters</a>); if NULL, all available estimators are used</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>CreatePdfs()</code>: Create all pdfs
</p>
</li>
<li> <p><code>CreatePdfsParameters()</code>: Create pdfs visualizing the estimated parameters
</p>
</li>
<li> <p><code>CreatePdfsComparison()</code>: Create pdfs comparing the estimated parameters
</p>
</li>
<li> <p><code>CreatePdfsProfiles()</code>: Create pdfs visualizing the profile likelihoods
</p>
</li></ul>

<hr>
<h2 id='CreatePseudobulkTable'>Create Pseudobulk Table from a Seurat object</h2><span id='topic+CreatePseudobulkTable'></span>

<h3>Description</h3>

<p>Create Pseudobulk Table from a Seurat object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreatePseudobulkTable(
  data,
  name.column = "Name",
  pseudobulk.column = "Condition"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreatePseudobulkTable_+3A_data">data</code></td>
<td>
<p>a Seurat object</p>
</td></tr>
<tr><td><code id="CreatePseudobulkTable_+3A_name.column">name.column</code></td>
<td>
<p>name of the metadata column containing the sample/cell names. Default &quot;Name&quot;.</p>
</td></tr>
<tr><td><code id="CreatePseudobulkTable_+3A_pseudobulk.column">pseudobulk.column</code></td>
<td>
<p>name of the metadata column containing the Pseudobulk names. Default &quot;Condition&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a table which can be used as input for GRAND3
</p>


<h3>Value</h3>

<p>a table with two columns &quot;Cell&quot; and &quot;Pseudobulk&quot;
</p>

<hr>
<h2 id='data.apply'>Internal function to apply functions to all slots etc.</h2><span id='topic+data.apply'></span>

<h3>Description</h3>

<p>Internal function to apply functions to all slots etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.apply(data, fun, fun.gene.info = NULL, fun.coldata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.apply_+3A_data">data</code></td>
<td>
<p>a grandR object</p>
</td></tr>
<tr><td><code id="data.apply_+3A_fun">fun</code></td>
<td>
<p>apply this function to each data slot (i.e. it receives each data matrix)</p>
</td></tr>
<tr><td><code id="data.apply_+3A_fun.gene.info">fun.gene.info</code></td>
<td>
<p>apply this function to the gene info table</p>
</td></tr>
<tr><td><code id="data.apply_+3A_fun.coldata">fun.coldata</code></td>
<td>
<p>apply this function to the column annotation table</p>
</td></tr>
<tr><td><code id="data.apply_+3A_...">...</code></td>
<td>
<p>passed further to fun, fun.gene.info and fun.coldata</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The additional parameters are provided to each of the functions.
</p>


<h3>Value</h3>

<p>A new grandR object
</p>

<hr>
<h2 id='DefaultSlot'>Get or set the default slot for a grandR object.</h2><span id='topic+DefaultSlot'></span><span id='topic+DefaultSlot+3C-'></span>

<h3>Description</h3>

<p>The default slot is used by default by many functions including
<code><a href="#topic+GetData">GetData</a></code>,<code><a href="#topic+GetTable">GetTable</a></code> or <code><a href="#topic+FitKinetics">FitKinetics</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DefaultSlot(data, value = NULL)

DefaultSlot(data) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DefaultSlot_+3A_data">data</code></td>
<td>
<p>A grandR object</p>
</td></tr>
<tr><td><code id="DefaultSlot_+3A_value">value</code></td>
<td>
<p>the name of the new default slot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default slot can be set either by <code>data&lt;-DefaultSlot(data,"norm")</code> or by <code>DefaultSlot(data)&lt;-"norm"</code>.
</p>


<h3>Value</h3>

<p>Either the name of the default slot for DefaultSlot(data)
or the grandR data object having the new default slot
</p>


<h3>See Also</h3>

<p><a href="#topic+Slots">Slots</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sars &lt;- ReadGRAND(system.file("extdata", "sars.tsv.gz", package = "grandR"),
                  design=c("Cell",Design$dur.4sU,Design$Replicate))

DefaultSlot(sars)
sars &lt;- Normalize(sars)     # default behavior is to update the default slot
DefaultSlot(sars)
DefaultSlot(sars)="count"

</code></pre>

<hr>
<h2 id='Defer'>Defer calling a function</h2><span id='topic+Defer'></span>

<h3>Description</h3>

<p>This generates a function with one mandatory parameter (and additional optional parameters)
that, when called, (i) also receives the parameters given when calling <code>Defer</code>, and (ii)
after calling it each element of the <code>add</code> list is appended by <code>+</code>. When no optional parameters
are given, the result is cached.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Defer(FUN, ..., add = NULL, cache = TRUE, width.height = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Defer_+3A_fun">FUN</code></td>
<td>
<p>the function to be deferred</p>
</td></tr>
<tr><td><code id="Defer_+3A_...">...</code></td>
<td>
<p>additional parameters to be used when the deferred function is called</p>
</td></tr>
<tr><td><code id="Defer_+3A_add">add</code></td>
<td>
<p>list containing additional elements to be added <code>+</code> to the result of the deferred function</p>
</td></tr>
<tr><td><code id="Defer_+3A_cache">cache</code></td>
<td>
<p>use caching mechanism</p>
</td></tr>
<tr><td><code id="Defer_+3A_width.height">width.height</code></td>
<td>
<p>a vector containing the desired width and height (not checked!)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following expressions are very similar: <code>f &lt;- function(d) Heavy.function(d)</code> and <code>f &lt;- Defer(Heavy.function)</code>. In
both cases, you get a function <code>f</code> that you can call for some <code>d</code>, which in turn calls <code>Heavy.function</code>. The only
difference is that in the second case, the result is cached: <code>Heavy.function</code> is called only once when first calling <code>f</code>,
if <code>f</code> is called a second time, the previous result is returned. This makes sense if the parameter <code>d</code> is constant (like a grandR object)
and if <code>Heavy.function</code> is deterministic.
</p>
<p>If additional parameters are provided to <code>f</code>, caching is disabled. If any of these additional parameters has the same name as the parameters
given to <code>Defer()</code>, the parameters given to <code>Defer()</code> are overwritten. Be careful if <code>Heavy.function</code> is not deterministic (see examples).
</p>
<p>Use case scenario: You want to produce a heatmap from a grandR object to be used as <code>plot.static</code> in the shiny web interface.
<code><a href="#topic+PlotHeatmap">PlotHeatmap</a></code> takes some time, and the resulting object is pretty large in memory. Saving the heatmap object to disk is very
inefficient (the Rdata file will be huge, especially with many heatmaps). Deferring the call without caching also is bad, because whenever
the user clicks onto the heatmap, it is regenerated.
</p>


<h3>Value</h3>

<p>a function that can be called
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Heavy.function &lt;- function(data) rnorm(5,mean=data)
f1=Defer(Heavy.function)
f2=function(d) Heavy.function(d)
f2(4)
f2(4) # these are not equal, as rnorm is called twice
f1(4)
f1(4) # these are equal, as the result of rnorm is cached

</code></pre>

<hr>
<h2 id='density2d'>Density estimation in 2d</h2><span id='topic+density2d'></span>

<h3>Description</h3>

<p>Estimate point densities on a regular grid for.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>density2d(x, y, facet = NULL, n = 100, margin = "n")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="density2d_+3A_x">x</code></td>
<td>
<p>x coordinates</p>
</td></tr>
<tr><td><code id="density2d_+3A_y">y</code></td>
<td>
<p>y coordinates</p>
</td></tr>
<tr><td><code id="density2d_+3A_facet">facet</code></td>
<td>
<p>factor: estimate for each unique factor; can be NULL</p>
</td></tr>
<tr><td><code id="density2d_+3A_n">n</code></td>
<td>
<p>size of the grid</p>
</td></tr>
<tr><td><code id="density2d_+3A_margin">margin</code></td>
<td>
<p>one of 'n','x' or 'y'; should the density be computed along both axes ('n'), or along 'x' or 'y' axis only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a density value for each point
</p>

<hr>
<h2 id='DESeq2BIC'>Compute the Bayesian information criterion (BIC)</h2><span id='topic+DESeq2BIC'></span>

<h3>Description</h3>

<p>Compute the delta BIC for a list of potential models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DESeq2BIC(
  data,
  name = "BIC",
  mode = "total",
  normalization = mode,
  formulas = list(Condition = ~Condition, Background = ~1),
  no4sU = FALSE,
  columns = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DESeq2BIC_+3A_data">data</code></td>
<td>
<p>A grandR object</p>
</td></tr>
<tr><td><code id="DESeq2BIC_+3A_name">name</code></td>
<td>
<p>the user defined analysis name to store the results</p>
</td></tr>
<tr><td><code id="DESeq2BIC_+3A_mode">mode</code></td>
<td>
<p>either &quot;total&quot;, &quot;new&quot; or &quot;old&quot;</p>
</td></tr>
<tr><td><code id="DESeq2BIC_+3A_normalization">normalization</code></td>
<td>
<p>normalize on &quot;total&quot;, &quot;new&quot;, or &quot;old&quot; (see details)</p>
</td></tr>
<tr><td><code id="DESeq2BIC_+3A_formulas">formulas</code></td>
<td>
<p>list of formulas specifying the models (you can use any column name from the <code><a href="#topic+Coldata">Coldata</a>(data)</code>)</p>
</td></tr>
<tr><td><code id="DESeq2BIC_+3A_no4su">no4sU</code></td>
<td>
<p>Use no4sU columns (TRUE) or not (FALSE)</p>
</td></tr>
<tr><td><code id="DESeq2BIC_+3A_columns">columns</code></td>
<td>
<p>logical vector of which columns (samples or cells) to use (or NULL: use all)</p>
</td></tr>
<tr><td><code id="DESeq2BIC_+3A_verbose">verbose</code></td>
<td>
<p>Print status updates</p>
</td></tr>
</table>


<h3>Details</h3>

<p>DESeq2 by default performs size factor normalization. When computing differential expression of new RNA,
it might be sensible to normalize w.r.t. to total RNA, i.e. use the size factors computed from total RNA instead of computed from new RNA.
This can be accomplished by setting mode to &quot;new&quot;, and normalization to &quot;total&quot;!
</p>


<h3>Value</h3>

<p>a new grandR object including a new analysis table. The columns of the new analysis table are named as &lt;name in list&gt;.dBIC
</p>

<hr>
<h2 id='Design'>A list of predefined names for design vectors</h2><span id='topic+Design'></span>

<h3>Description</h3>

<p>These predefined names mainly are implemented here to harmonize analyses.
It is good practise to use these names if sensible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Design
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 11.
</p>

<hr>
<h2 id='DesignSemantics'>Build the design semantics list</h2><span id='topic+DesignSemantics'></span>

<h3>Description</h3>

<p>This is used to add additional columns to the <code><a href="#topic+Coldata">Coldata</a></code> table by giving additional semantics to existing columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DesignSemantics(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DesignSemantics_+3A_...">...</code></td>
<td>
<p>named parameter list of functions (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>DesignSemantics returns a list of functions that is supposed to be used as <code>semantics</code> parameter when calling <code><a href="#topic+MakeColdata">MakeColdata</a></code>.
For each design vector element matching a name of this list the corresponding function is called by <a href="#topic+MakeColdata">MakeColdata</a> to add additional columns.
</p>
<p>Each function takes two parameters, the first being the original column in the <code>Coldata</code> table column, the second being its name.
</p>
<p>Semantics.time is such a predefined function: Contents such as 3h or 30min are converted into a numerical value (in hours), and no4sU is converted into 0.
</p>
<p>Semantics.concentration is such a predefined function: Contents such as 200uM or 1mM are converted into a numerical value (in uM), and no4sU is converted into 0.
</p>
<p>By default, Semantics.time is used for the names duration.4sU and Experimental.time, and Semantics.concentration is used for concentration.4sU
</p>


<h3>Value</h3>

<p>a named list; the names should correspond to column names in the <a href="#topic+Coldata">Coldata</a> table,
and the values are functions to add semantics to this table
</p>


<h3>See Also</h3>

<p><a href="#topic+MakeColdata">MakeColdata</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Semantics.time(c("5h","30min","no4sU"),"Test")


myfun &lt;- function(s,name) {
        r&lt;-Semantics.time(s,name)
        cbind(r,data.frame(hpi=paste0(r$duration.4sU+3,"h")))
}
sars &lt;- ReadGRAND(system.file("extdata", "sars.tsv.gz", package = "grandR"),
                  design=function(names)
                    MakeColdata(names,c("Cell",Design$dur.4sU,Design$Replicate),
                  semantics=DesignSemantics(duration.4sU=myfun)),
                  verbose=TRUE)
Coldata(sars)

</code></pre>

<hr>
<h2 id='dropout'>Perform 4sU dropout tests</h2><span id='topic+dropout'></span><span id='topic+Plot4sUDropoutRankAll'></span><span id='topic+Plot4sUDropoutAll'></span><span id='topic+Plot4sUDropoutDeferAll'></span><span id='topic+Plot4sUDropoutRankDeferAll'></span><span id='topic+Plot4sUDropoutRank'></span><span id='topic+Plot4sUDropout'></span>

<h3>Description</h3>

<p>Testing for RNA dropout of a 4sU sample is performed by comparing half-lives or NTR ranks against
the log2 fold change of the 4sU sample vs equivalent no4sU samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot4sUDropoutRankAll(data, pairs = Findno4sUPairs(data), ...)

Plot4sUDropoutAll(data, pairs = Findno4sUPairs(data), ...)

Plot4sUDropoutDeferAll(data, pairs = NULL, ...)

Plot4sUDropoutRankDeferAll(data, pairs = NULL, ...)

Plot4sUDropoutRank(
  data,
  w4sU,
  no4sU = Findno4sUPairs(data)[[w4sU]],
  ntr = w4sU,
  ylim = NULL,
  LFC.fun = lfc::PsiLFC,
  slot = "count",
  correction = 1,
  label.corr = TRUE,
  return.corr = FALSE,
  boxplot.bins = 10,
  title = w4sU,
  size = 1.5,
  invert.ranks = FALSE
)

Plot4sUDropout(
  data,
  w4sU,
  no4sU = Findno4sUPairs(data)[[w4sU]],
  ntr = w4sU,
  ylim = NULL,
  LFC.fun = lfc::PsiLFC,
  slot = "count",
  hl.quantile = 0.8,
  hl = NULL,
  correction = 1,
  label.corr = FALSE,
  return.corr = FALSE,
  title = w4sU,
  size = 1.5,
  color.by.ntr = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dropout_+3A_data">data</code></td>
<td>
<p>a grandR object</p>
</td></tr>
<tr><td><code id="dropout_+3A_pairs">pairs</code></td>
<td>
<p>a no4sU pairs list as generated by <a href="#topic+Findno4sUPairs">Findno4sUPairs</a></p>
</td></tr>
<tr><td><code id="dropout_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
<tr><td><code id="dropout_+3A_w4su">w4sU</code></td>
<td>
<p>the name of a 4sU sample</p>
</td></tr>
<tr><td><code id="dropout_+3A_no4su">no4sU</code></td>
<td>
<p>the name(s) of equivalent no4sU sample(s)</p>
</td></tr>
<tr><td><code id="dropout_+3A_ntr">ntr</code></td>
<td>
<p>the name of a sample to take NTRs from (usually equal to w4sU)</p>
</td></tr>
<tr><td><code id="dropout_+3A_ylim">ylim</code></td>
<td>
<p>y axis limits</p>
</td></tr>
<tr><td><code id="dropout_+3A_lfc.fun">LFC.fun</code></td>
<td>
<p>function to compute log fold change (default: <a href="lfc.html#topic+PsiLFC">PsiLFC</a>, other viable option: <a href="lfc.html#topic+NormLFC">NormLFC</a>)</p>
</td></tr>
<tr><td><code id="dropout_+3A_slot">slot</code></td>
<td>
<p>the slot of the grandR object to take the data from; for <a href="lfc.html#topic+PsiLFC">PsiLFC</a>, this really should be &quot;count&quot;!</p>
</td></tr>
<tr><td><code id="dropout_+3A_correction">correction</code></td>
<td>
<p>correction factor</p>
</td></tr>
<tr><td><code id="dropout_+3A_label.corr">label.corr</code></td>
<td>
<p>add statistics as subtitle</p>
</td></tr>
<tr><td><code id="dropout_+3A_return.corr">return.corr</code></td>
<td>
<p>instead of only the ggplot object, return a list with slots plot (what is normally returned) and label (the correlation statistics)</p>
</td></tr>
<tr><td><code id="dropout_+3A_boxplot.bins">boxplot.bins</code></td>
<td>
<p>how many boxplots for <code>Plot4sUDropoutRank</code></p>
</td></tr>
<tr><td><code id="dropout_+3A_title">title</code></td>
<td>
<p>the main title for the plot</p>
</td></tr>
<tr><td><code id="dropout_+3A_size">size</code></td>
<td>
<p>the point size</p>
</td></tr>
<tr><td><code id="dropout_+3A_invert.ranks">invert.ranks</code></td>
<td>
<p>if TRUE, left to right on the plot is largest NTR to smallest NTR</p>
</td></tr>
<tr><td><code id="dropout_+3A_hl.quantile">hl.quantile</code></td>
<td>
<p>the half-life quantile to cut the plot</p>
</td></tr>
<tr><td><code id="dropout_+3A_hl">hl</code></td>
<td>
<p>if NULL, compute half-lives from the ntr column; otherwise, must be a vector containing half-lives</p>
</td></tr>
<tr><td><code id="dropout_+3A_color.by.ntr">color.by.ntr</code></td>
<td>
<p>if true, compute the density colors along the ntr axis instead of globally</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The deferred versions are useful to be used in conjunction with <a href="#topic+ServeGrandR">ServeGrandR</a> plot.static. Their implementation
make sure that they are lightweight, i.e. when saving the returned function to an Rdata file, the grandR object is not stored.
</p>


<h3>Value</h3>

<p>either a ggplot object, a list of ggplot objects, or a list of deferred functions for plotting
</p>


<h3>See Also</h3>

<p><a href="#topic+Findno4sUPairs">Findno4sUPairs</a>,<a href="#topic+Defer">Defer</a>
</p>

<hr>
<h2 id='dropoutpercent'>Estimate 4sU dropout percentages</h2><span id='topic+dropoutpercent'></span><span id='topic+Estimate4sUDropoutPercentage'></span><span id='topic+Estimate4sUDropoutPercentageForSample'></span>

<h3>Description</h3>

<p>For several potential reasons, a sample specific percentage of reads from labelled RNA might be lost.
This percentage can be estimated from data of this sample and an equivalent 4sU naive control (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Estimate4sUDropoutPercentage(data, pairs = Findno4sUPairs(data), ...)

Estimate4sUDropoutPercentageForSample(
  data,
  w4sU,
  no4sU,
  ntr = w4sU,
  LFC.fun = lfc::PsiLFC,
  type = c("spearman", "quantreg", "linear", "lowess"),
  bootstrap = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dropoutpercent_+3A_data">data</code></td>
<td>
<p>a grandR object</p>
</td></tr>
<tr><td><code id="dropoutpercent_+3A_pairs">pairs</code></td>
<td>
<p>a no4sU pairs list as generated by <a href="#topic+Findno4sUPairs">Findno4sUPairs</a></p>
</td></tr>
<tr><td><code id="dropoutpercent_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
<tr><td><code id="dropoutpercent_+3A_w4su">w4sU</code></td>
<td>
<p>the name of a 4sU sample</p>
</td></tr>
<tr><td><code id="dropoutpercent_+3A_no4su">no4sU</code></td>
<td>
<p>the name(s) of equivalent no4sU sample(s)</p>
</td></tr>
<tr><td><code id="dropoutpercent_+3A_ntr">ntr</code></td>
<td>
<p>the name of a sample to take NTRs from (usually equal to w4sU)</p>
</td></tr>
<tr><td><code id="dropoutpercent_+3A_lfc.fun">LFC.fun</code></td>
<td>
<p>function to compute log fold change (default: <a href="lfc.html#topic+PsiLFC">PsiLFC</a>, other viable option: <a href="lfc.html#topic+NormLFC">NormLFC</a>)</p>
</td></tr>
<tr><td><code id="dropoutpercent_+3A_type">type</code></td>
<td>
<p>one of &quot;spearman&quot;,&quot;quantreg&quot;,&quot;linear&quot; or &quot;lowess&quot; (see details)</p>
</td></tr>
<tr><td><code id="dropoutpercent_+3A_bootstrap">bootstrap</code></td>
<td>
<p>if TRUE, perform a single bootstrap sample  (by drawing genes with replacement)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The percentage of 4sU dropout is estimated by numerical optimization of the factor f
that has to be multiplied with the NTR to mitigate the effect of 4sU dropout. The exact objective function depends on the type parameter:
</p>

<ul>
<li><p>spearman: f is estimated such that the spearman correlation coefficient of the log2 fold change 4sU/no4sU vs the ntr rank is 0
</p>
</li>
<li><p>quantreg: f is estimated such that the slope of a median regression with the the ntr rank as independent variable and the log2 fold change 4sU/no4sU as dependent variable is 0
</p>
</li>
<li><p>linear: f is estimated such that the slope of a linear regression with the the ntr rank as independent variable and the log2 fold change 4sU/no4sU as dependent variable is 0
</p>
</li>
<li><p>lowess: f is estimated by minimizing the sum-of-squares of the residuals from a lowess regression with the the ntr rank as independent variable and the log2 fold change 4sU/no4sU as dependent variable is 0
</p>
</li></ul>

<p>Once f is computed the percentage of 4sU dropout is f/(f+1).
</p>


<h3>Value</h3>

<p>the percentage of 4sU dropout for a single sample (Estimate4sUDropoutPercentageForSample) or all samples (Estimate4sUDropoutPercentage)
</p>


<h3>See Also</h3>

<p><a href="#topic+Correct4sUDropoutHLFactor">Correct4sUDropoutHLFactor</a>,<a href="#topic+ComputeSummaryStatistics">ComputeSummaryStatistics</a>
</p>

<hr>
<h2 id='estimate.dispersion'>Estimate dispersion parameters for a count matrix using DESeq2</h2><span id='topic+estimate.dispersion'></span>

<h3>Description</h3>

<p>Estimate dispersion parameters for a count matrix using DESeq2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate.dispersion(ss)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate.dispersion_+3A_ss">ss</code></td>
<td>
<p>the count matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of dispersion parameters (to be used as size=1/dispersion for Xnbinom functions)
</p>

<hr>
<h2 id='EstimateRegulation'>Estimate regulation from snapshot experiments</h2><span id='topic+EstimateRegulation'></span>

<h3>Description</h3>

<p>Compute the posterior log2 fold change distributions of RNA synthesis and degradation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EstimateRegulation(
  data,
  name.prefix = "Regulation",
  contrasts,
  reference.columns = NULL,
  slot = DefaultSlot(data),
  time.labeling = Design$dur.4sU,
  time.experiment = NULL,
  ROPE.max.log2FC = 0.25,
  sample.f0.in.ss = TRUE,
  N = 10000,
  N.max = N * 10,
  CI.size = 0.95,
  seed = 1337,
  dispersion = NULL,
  sample.level = 2,
  correct.labeling = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EstimateRegulation_+3A_data">data</code></td>
<td>
<p>the grandR object</p>
</td></tr>
<tr><td><code id="EstimateRegulation_+3A_name.prefix">name.prefix</code></td>
<td>
<p>the prefix for the new analysis name; a dot and the column names of the contrast matrix are appended; can be NULL (then only the contrast matrix names are used)</p>
</td></tr>
<tr><td><code id="EstimateRegulation_+3A_contrasts">contrasts</code></td>
<td>
<p>contrast matrix that defines all pairwise comparisons, generated using <a href="#topic+GetContrasts">GetContrasts</a></p>
</td></tr>
<tr><td><code id="EstimateRegulation_+3A_reference.columns">reference.columns</code></td>
<td>
<p>a reference matrix usually generated by <a href="#topic+FindReferences">FindReferences</a> to define reference samples for each sample; can be NULL if all conditions are at steady state (see details)</p>
</td></tr>
<tr><td><code id="EstimateRegulation_+3A_slot">slot</code></td>
<td>
<p>the data slot to take f0 and totals from</p>
</td></tr>
<tr><td><code id="EstimateRegulation_+3A_time.labeling">time.labeling</code></td>
<td>
<p>the column in the <a href="#topic+Coldata">Coldata</a> table denoting the labeling duration, or the numeric labeling duration itself</p>
</td></tr>
<tr><td><code id="EstimateRegulation_+3A_time.experiment">time.experiment</code></td>
<td>
<p>the column in the <a href="#topic+Coldata">Coldata</a> table denoting the experimental time point (can be NULL, see details)</p>
</td></tr>
<tr><td><code id="EstimateRegulation_+3A_rope.max.log2fc">ROPE.max.log2FC</code></td>
<td>
<p>the region of practical equivalence is [-ROPE.max.log2FC,ROPE.max.log2FC] in log2 fold change space</p>
</td></tr>
<tr><td><code id="EstimateRegulation_+3A_sample.f0.in.ss">sample.f0.in.ss</code></td>
<td>
<p>whether or not to sample f0 under steady state conditions</p>
</td></tr>
<tr><td><code id="EstimateRegulation_+3A_n">N</code></td>
<td>
<p>the sample size</p>
</td></tr>
<tr><td><code id="EstimateRegulation_+3A_n.max">N.max</code></td>
<td>
<p>the maximal number of samples (necessary if old RNA &gt; f0); if more are necessary, a warning is generated</p>
</td></tr>
<tr><td><code id="EstimateRegulation_+3A_ci.size">CI.size</code></td>
<td>
<p>A number between 0 and 1 representing the size of the credible interval</p>
</td></tr>
<tr><td><code id="EstimateRegulation_+3A_seed">seed</code></td>
<td>
<p>Seed for the random number generator</p>
</td></tr>
<tr><td><code id="EstimateRegulation_+3A_dispersion">dispersion</code></td>
<td>
<p>overdispersion parameter for each gene; if NULL this is estimated from data</p>
</td></tr>
<tr><td><code id="EstimateRegulation_+3A_sample.level">sample.level</code></td>
<td>
<p>Define how the NTR is sampled from the hierarchical Bayesian model (must be 0,1, or 2; see details)</p>
</td></tr>
<tr><td><code id="EstimateRegulation_+3A_correct.labeling">correct.labeling</code></td>
<td>
<p>Labeling times have to be unique; usually execution is aborted, if this is not the case; if this is set to true, the median labeling time is assumed</p>
</td></tr>
<tr><td><code id="EstimateRegulation_+3A_verbose">verbose</code></td>
<td>
<p>Print status messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The kinetic parameters s and d are computed using <a href="#topic+TransformSnapshot">TransformSnapshot</a>. For that, the sample either must be in steady state
(this is the case if defined in the reference.columns matrix), or if the levels at an earlier time point are known from separate samples,
so called temporal reference samples. Thus, if s and d are estimated for a set of samples x_1,...,x_k (that must be from the same time point t),
we need to find (i) the corresponding temporal reference samples from time t0, and (ii) the time difference between t and t0.
</p>
<p>The temporal reference samples are identified by the reference.columns matrix. This is a square matrix of logicals, rows and columns correspond to all samples
and TRUE indicates that the row sample is a temporal reference of the columns sample. This time point is defined by <code>time.experiment</code>. If <code>time.experiment</code>
is NULL, then the labeling time of the A or B samples is used (e.g. useful if labeling was started concomitantly with the perturbation, and the steady state samples
are unperturbed samples).
</p>
<p>By default, the hierarchical Bayesian model is estimated. If sample.level = 0, the NTRs are sampled from a beta distribution
that approximates the mixture of betas from the replicate samples. If sample.level = 1, only the first level from the hierarchical model
is sampled (corresponding to the uncertainty of estimating the biological variability). If sample.level = 2, the first and second levels
are estimated (corresponding to the full hierarchical model).
</p>
<p>if N is set to 0, then no sampling from the posterior is performed, but the transformed MAP estimates are returned
</p>


<h3>Value</h3>

<p>a new grandR object including a new analysis table. The columns of the new analysis table are
</p>
<table>
<tr><td><code>"s.A"</code></td>
<td>
<p>the posterior mean synthesis rate for sample A from the comparison</p>
</td></tr>
<tr><td><code>"s.B"</code></td>
<td>
<p>the posterior mean synthesis rate for sample B from the comparison</p>
</td></tr>
<tr><td><code>"HL.A"</code></td>
<td>
<p>the posterior mean RNA half-life for sample A from the comparison</p>
</td></tr>
<tr><td><code>"HL.B"</code></td>
<td>
<p>the posterior mean RNA half-life for sample B from the comparison</p>
</td></tr>
<tr><td><code>"s.log2FC"</code></td>
<td>
<p>the posterior mean synthesis rate log2 fold change</p>
</td></tr>
<tr><td><code>"s.cred.lower"</code></td>
<td>
<p>the lower CI boundary of the synthesis rate log2 fold change</p>
</td></tr>
<tr><td><code>"s.cred.upper"</code></td>
<td>
<p>the upper CI boundary of the synthesis rate log2 fold change</p>
</td></tr>
<tr><td><code>"s.ROPE"</code></td>
<td>
<p>the signed ROPE probability (negative means downregulation) for the synthesis rate fold change</p>
</td></tr>
<tr><td><code>"HL.log2FC"</code></td>
<td>
<p>the posterior mean half-life log2 fold change</p>
</td></tr>
<tr><td><code>"HL.cred.lower"</code></td>
<td>
<p>the lower CI boundary of the half-life log2 fold change</p>
</td></tr>
<tr><td><code>"HL.cred.upper"</code></td>
<td>
<p>the upper CI boundary of the half-life log2 fold change</p>
</td></tr>
<tr><td><code>"HL.ROPE"</code></td>
<td>
<p>the signed ROPE probability (negative means downregulation) for the half-life fold change</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+FitKineticsGeneSnapshot">FitKineticsGeneSnapshot</a>,<a href="#topic+FitKineticsSnapshot">FitKineticsSnapshot</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>banp &lt;- ReadGRAND(system.file("extdata", "BANP.tsv.gz", package = "grandR"),
          design=c("Cell","Experimental.time","Genotype",
                       Design$dur.4sU,Design$has.4sU,Design$Replicate))
contrasts &lt;- GetContrasts(banp,contrast=c("Experimental.time.original","0h"),name.format="$A")
reference.columns &lt;- FindReferences(banp,reference= Experimental.time==0)
banp &lt;- EstimateRegulation(banp,"Regulation",
                             contrasts=contrasts,
                             reference.columns=reference.columns,
                             verbose=TRUE,
                             time.experiment = "Experimental.time",
                             N=0,               # don't sample in the example
                             dispersion=0.1)    # don't estimate dispersion in the example
head(GetAnalysisTable(banp))

</code></pre>

<hr>
<h2 id='f.nonconst'>Function to compute the abundance of new or old RNA at time t for non-constant rates.</h2><span id='topic+f.nonconst'></span>

<h3>Description</h3>

<p>The standard mass action kinetics model of gene expression arises from the differential equation
<code class="reqn">df/dt = s(t) - d(t)  f(t)</code>, with s(t) being the synthesis rate at time t, d(t) the degradation rate at time t and <code class="reqn">f0=f(0)</code> (the abundance at time 0).
Here, both s and d have the following form <code class="reqn">s(t)=so+sf \cdot t^{se}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f.nonconst(t, f0, s, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f.nonconst_+3A_t">t</code></td>
<td>
<p>time in h (can be a vector)</p>
</td></tr>
<tr><td><code id="f.nonconst_+3A_f0">f0</code></td>
<td>
<p>the abundance at time t=0</p>
</td></tr>
<tr><td><code id="f.nonconst_+3A_s">s</code></td>
<td>
<p>the synthesis rate (see details)</p>
</td></tr>
<tr><td><code id="f.nonconst_+3A_d">d</code></td>
<td>
<p>the degradation rate (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both rates can be either (i) a single number (constant rate), (ii) a data frame with names &quot;offset&quot;,
&quot;factor&quot; and &quot;exponent&quot; (for linear functions, see <a href="#topic+ComputeNonConstantParam">ComputeNonConstantParam</a>; only one row allowed) or
(iii) a unary function time-&gt;rate. Functions
</p>


<h3>Value</h3>

<p>the RNA abundance at time t
</p>


<h3>See Also</h3>

<p><a href="#topic+f.nonconst.linear">f.nonconst.linear</a>
</p>

<hr>
<h2 id='f.nonconst.linear'>Function to compute the abundance of new or old RNA at time t for non-constant rates.</h2><span id='topic+f.nonconst.linear'></span>

<h3>Description</h3>

<p>The standard mass action kinetics model of gene expression arises from the differential equation
<code class="reqn">df/dt = s(t) - d(t)  f(t)</code>, with s(t) being the synthesis rate at time t, d(t) the degradation rate at time t and <code class="reqn">f0=f(0)</code> (the abundance at time 0).
Here, both s and d have the following form <code class="reqn">s(t)=so+sf \cdot t^{se}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f.nonconst.linear(t, f0, so, sf, se, do, df, de)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f.nonconst.linear_+3A_t">t</code></td>
<td>
<p>time in h (can be a vector)</p>
</td></tr>
<tr><td><code id="f.nonconst.linear_+3A_f0">f0</code></td>
<td>
<p>the abundance at time t=0</p>
</td></tr>
<tr><td><code id="f.nonconst.linear_+3A_so">so</code></td>
<td>
<p>synthesis date offset</p>
</td></tr>
<tr><td><code id="f.nonconst.linear_+3A_sf">sf</code></td>
<td>
<p>synthesis date factor</p>
</td></tr>
<tr><td><code id="f.nonconst.linear_+3A_se">se</code></td>
<td>
<p>synthesis date exponent</p>
</td></tr>
<tr><td><code id="f.nonconst.linear_+3A_do">do</code></td>
<td>
<p>degradation rate offset</p>
</td></tr>
<tr><td><code id="f.nonconst.linear_+3A_df">df</code></td>
<td>
<p>degradation rate factor</p>
</td></tr>
<tr><td><code id="f.nonconst.linear_+3A_de">de</code></td>
<td>
<p>degradation rate exponent</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the RNA abundance at time t
</p>


<h3>See Also</h3>

<p><a href="#topic+f.nonconst">f.nonconst</a>
</p>

<hr>
<h2 id='f.old.equi'>Functions to compute the abundance of new or old RNA at time t.</h2><span id='topic+f.old.equi'></span><span id='topic+f.old.nonequi'></span><span id='topic+f.new'></span>

<h3>Description</h3>

<p>The standard mass action kinetics model of gene expression arises from the differential equation
<code class="reqn">df/dt = s - d  f(t)</code>, with s being the constant synthesis rate, d the constant degradation rate and <code class="reqn">f0=f(0)</code> (the abundance at time 0).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f.old.equi(t, s, d)

f.old.nonequi(t, f0, s, d)

f.new(t, s, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f.old.equi_+3A_t">t</code></td>
<td>
<p>time in h</p>
</td></tr>
<tr><td><code id="f.old.equi_+3A_s">s</code></td>
<td>
<p>synthesis date in U/h (arbitrary unit U)</p>
</td></tr>
<tr><td><code id="f.old.equi_+3A_d">d</code></td>
<td>
<p>degradation rate in 1/h</p>
</td></tr>
<tr><td><code id="f.old.equi_+3A_f0">f0</code></td>
<td>
<p>the abundance at time t=0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the RNA abundance at time t
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>f.old.equi()</code>: abundance of old RNA assuming steady state (i.e. f0=s/d)
</p>
</li>
<li> <p><code>f.old.nonequi()</code>: abundance of old RNA without assuming steady state
</p>
</li>
<li> <p><code>f.new()</code>: abundance of new RNA (steady state does not matter)
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'> d=log(2)/2
 s=10

 f.new(2,s,d)  # Half-life 2, so after 2h the abundance should be half the steady state
 f.old.equi(2,s,d)
 s/d

 t&lt;-seq(0,10,length.out=100)
 plot(t,f.new(t,s,d),type='l',col='blue',ylim=c(0,s/d))
 lines(t,f.old.equi(t,s,d),col='red')
 abline(h=s/d,lty=2)
 abline(v=2,lty=2)
 # so old and new RNA are equal at t=HL (if it is at steady state at t=0)

 plot(t,f.new(t,s,d),type='l',col='blue')
 lines(t,f.old.nonequi(t,f0=15,s,d),col='red')
 abline(h=s/d,lty=2)
 abline(v=2,lty=2)
 # so old and new RNA are not equal at t=HL (if it is not at steady state at t=0)

</code></pre>

<hr>
<h2 id='FilterGenes'>Filter genes</h2><span id='topic+FilterGenes'></span>

<h3>Description</h3>

<p>Return a grandR object with fewer genes than the given grandR object (usually to filter out weakly expressed genes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FilterGenes(
  data,
  mode.slot = "count",
  minval = 100,
  mincol = ncol(data)/2,
  min.cond = NULL,
  use = NULL,
  keep = NULL,
  return.genes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FilterGenes_+3A_data">data</code></td>
<td>
<p>the grandR object</p>
</td></tr>
<tr><td><code id="FilterGenes_+3A_mode.slot">mode.slot</code></td>
<td>
<p>the mode.slot that is used for filtering (see details)</p>
</td></tr>
<tr><td><code id="FilterGenes_+3A_minval">minval</code></td>
<td>
<p>the minimal value for retaining a gene</p>
</td></tr>
<tr><td><code id="FilterGenes_+3A_mincol">mincol</code></td>
<td>
<p>the minimal number of columns (i.e. samples or cells) a gene has to have a value &gt;= minval</p>
</td></tr>
<tr><td><code id="FilterGenes_+3A_min.cond">min.cond</code></td>
<td>
<p>if not NULL, do not compare values per column, but per condition (see details)</p>
</td></tr>
<tr><td><code id="FilterGenes_+3A_use">use</code></td>
<td>
<p>if not NULL, defines the genes directly that are supposed to be retained (see details)</p>
</td></tr>
<tr><td><code id="FilterGenes_+3A_keep">keep</code></td>
<td>
<p>if not NULL, defines genes directly, that should be kept even though they do not adhere to the filtering criteria (see details)</p>
</td></tr>
<tr><td><code id="FilterGenes_+3A_return.genes">return.genes</code></td>
<td>
<p>if TRUE, return the gene names instead of a new grandR object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default genes are retained, if they have 100 read counts in at least half of the columns (i.e. samples or cells).
</p>
<p>The <code>use</code> parameter can be used to define genes to be retained directly. The <code>keep</code> parameter, in contrast, defines
<em>additional</em> genes to be retained. For both, genes can be referred to by their names, symbols, row numbers in the gene table,
or a logical vector referring to the gene table rows.
</p>
<p>To refer to data slots, the mode.slot syntax can be used: Each name is either a data slot, or one of (new,old,total)
followed by a dot followed by a slot. For new or old, the data slot value is multiplied by ntr or 1-ntr. This can be used e.g. to filter by <em>new counts</em>.
</p>
<p>if the <code>min.cond</code> parameter is given, first all columns belonging to the same <code><a href="#topic+Condition">Condition</a></code> are summed up, and then the usual filtering
is performed by conditions instead of by columns.
</p>


<h3>Value</h3>

<p>either a new grandR object (if return.genes=FALSE), or a vector containing the gene names that would be retained
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sars &lt;- ReadGRAND(system.file("extdata", "sars.tsv.gz", package = "grandR"),
                  design=c("Condition",Design$dur.4sU,Design$Replicate))

nrow(sars)
# This is already filtered and has 1045 genes
nrow(FilterGenes(sars,minval=1000))
# There are 966 genes with at least 1000 read counts in half of the samples
nrow(FilterGenes(sars,minval=10000,min.cond=1))
# There are 944 genes with at least 10000 read counts in the Mock or SARS condition
nrow(FilterGenes(sars,use=GeneInfo(sars,"Type")!="Cellular"))
# These are the 11 viral genes.

</code></pre>

<hr>
<h2 id='Findno4sUPairs'>Find equivalent no4sU samples for 4sU samples</h2><span id='topic+Findno4sUPairs'></span>

<h3>Description</h3>

<p>Identify all no4sU samples in the same condition, and return everything as a list to be used in
<a href="#topic+Plot4sUDropout">Plot4sUDropout</a>, <a href="#topic+Plot4sUDropoutRank">Plot4sUDropoutRank</a>, <a href="#topic+Plot4sUDropoutAll">Plot4sUDropoutAll</a>, <a href="#topic+Plot4sUDropoutRankAll">Plot4sUDropoutRankAll</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Findno4sUPairs(data, paired.replicates = FALSE, discard.no4sU = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Findno4sUPairs_+3A_data">data</code></td>
<td>
<p>a grandR object</p>
</td></tr>
<tr><td><code id="Findno4sUPairs_+3A_paired.replicates">paired.replicates</code></td>
<td>
<p>pair replicates, i.e. only no4sU.A is found for 4sU.A</p>
</td></tr>
<tr><td><code id="Findno4sUPairs_+3A_discard.no4su">discard.no4sU</code></td>
<td>
<p>do not report references for no4sU samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing, for each 4sU sample, a vector of equivalent no4sU samples
</p>


<h3>See Also</h3>

<p><a href="#topic+Plot4sUDropout">Plot4sUDropout</a>, <a href="#topic+Plot4sUDropoutRank">Plot4sUDropoutRank</a>, <a href="#topic+Plot4sUDropoutAll">Plot4sUDropoutAll</a>, <a href="#topic+Plot4sUDropoutRankAll">Plot4sUDropoutRankAll</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sars &lt;- ReadGRAND(system.file("extdata", "sars.tsv.gz", package = "grandR"),
                  design=c("Condition",Design$dur.4sU,Design$Replicate))
Findno4sUPairs(sars)

</code></pre>

<hr>
<h2 id='FindReferences'>Obtain reference columns (samples or cells) for all columns (samples or cells) in the data set</h2><span id='topic+FindReferences'></span>

<h3>Description</h3>

<p>In some situations (see examples) it is required to find a reference sample of some kind for each sample in a data set.
This is a convenience method to find such reference samples, and provide them as a lookup table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindReferences(
  data,
  reference = NULL,
  reference.function = NULL,
  group = NULL,
  as.list = FALSE,
  columns = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindReferences_+3A_data">data</code></td>
<td>
<p>A grandR object</p>
</td></tr>
<tr><td><code id="FindReferences_+3A_reference">reference</code></td>
<td>
<p>Expression evaluating to a logical vector to indicate which columns are reference columns; evaluated in an environment having the columns of <a href="#topic+Coldata">Coldata</a>(data)</p>
</td></tr>
<tr><td><code id="FindReferences_+3A_reference.function">reference.function</code></td>
<td>
<p>Function evaluating to a logical vector to indicate which columns are reference columns; called with the data frame row corresponding to the sample, and evaluated in an environment having the columns of <a href="#topic+Coldata">Coldata</a>(data)</p>
</td></tr>
<tr><td><code id="FindReferences_+3A_group">group</code></td>
<td>
<p>a vector of colnames in <a href="#topic+Coldata">Coldata</a>(data)</p>
</td></tr>
<tr><td><code id="FindReferences_+3A_as.list">as.list</code></td>
<td>
<p>return it as a list (names correspond to each sample, elements are the reference samples)</p>
</td></tr>
<tr><td><code id="FindReferences_+3A_columns">columns</code></td>
<td>
<p>find references only for a subset of the columns (samples or cells; can be NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Without any group, the list simply contains all references for each sample/cell. With groups defined, each list entry consists of all references from the same group.
</p>
<p>Columns can be given as a logical, integer or character vector representing a selection of the columns (samples or cells).
The expression is evaluated in an environment havin the <code><a href="#topic+Coldata">Coldata</a></code>, i.e. you can use names of <code><a href="#topic+Coldata">Coldata</a></code> as variables to
conveniently build a logical vector (e.g., columns=Condition==&quot;x&quot;).
</p>


<h3>Value</h3>

<p>A logical matrix that contains for each sample or cell (in columns) a TRUE for the corresponding corresponding reference samples or cells in rows
</p>


<h3>See Also</h3>

<p><a href="#topic+Coldata">Coldata</a>,<a href="#topic+Findno4sUPairs">Findno4sUPairs</a>, <a href="#topic+Condition">Condition</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sars &lt;- ReadGRAND(system.file("extdata", "sars.tsv.gz", package = "grandR"),
                  design=c("Condition",Design$dur.4sU,Design$Replicate))
FindReferences(sars,reference=no4sU)
# obtain the corresponding no4sU sample for each sample; use the Condition column
FindReferences(sars,Condition=="Mock",group="duration.4sU.original")
# obtain for each sample the corresponding sample in the Mock condition
FindReferences(sars,Condition=="Mock",group=c("duration.4sU.original","Replicate"))
# obtain for each sample the corresponding Mock sample, paying attention to replicates

</code></pre>

<hr>
<h2 id='FitKinetics'>Fit kinetic models to all genes.</h2><span id='topic+FitKinetics'></span>

<h3>Description</h3>

<p>Fit the standard mass action kinetics model of gene expression by different methods. Some methods require steady state assumptions, for others
data must be properly normalized. The parameters are fit per <a href="#topic+Condition">Condition</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FitKinetics(
  data,
  name.prefix = "kinetics",
  type = c("nlls", "ntr", "lm", "chase"),
  slot = DefaultSlot(data),
  time = Design$dur.4sU,
  CI.size = 0.95,
  return.fields = c("Synthesis", "Half-life"),
  return.extra = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FitKinetics_+3A_data">data</code></td>
<td>
<p>A grandR object</p>
</td></tr>
<tr><td><code id="FitKinetics_+3A_name.prefix">name.prefix</code></td>
<td>
<p>the prefix of the analysis name to be stored in the grandR object</p>
</td></tr>
<tr><td><code id="FitKinetics_+3A_type">type</code></td>
<td>
<p>Which method to use (either one of &quot;full&quot;,&quot;ntr&quot;,&quot;lm&quot;, &quot;chase&quot;)</p>
</td></tr>
<tr><td><code id="FitKinetics_+3A_slot">slot</code></td>
<td>
<p>The data slot to take expression values from</p>
</td></tr>
<tr><td><code id="FitKinetics_+3A_time">time</code></td>
<td>
<p>The column in the column annotation table representing the labeling duration</p>
</td></tr>
<tr><td><code id="FitKinetics_+3A_ci.size">CI.size</code></td>
<td>
<p>A number between 0 and 1 representing the size of the confidence interval</p>
</td></tr>
<tr><td><code id="FitKinetics_+3A_return.fields">return.fields</code></td>
<td>
<p>which statistics to return (see details)</p>
</td></tr>
<tr><td><code id="FitKinetics_+3A_return.extra">return.extra</code></td>
<td>
<p>additional statistics to return (see details)</p>
</td></tr>
<tr><td><code id="FitKinetics_+3A_...">...</code></td>
<td>
<p>forwarded to <code><a href="#topic+FitKineticsGeneNtr">FitKineticsGeneNtr</a></code>, <code><a href="#topic+FitKineticsGeneLeastSquares">FitKineticsGeneLeastSquares</a></code> or <code><a href="#topic+FitKineticsGeneLogSpaceLinear">FitKineticsGeneLogSpaceLinear</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The start of labeling for all samples should be the same experimental time point. The fit gets more precise with multiple samples from multiple
labeling durations.
</p>
<p>The standard mass action kinetics model of gene expression arises from the following differential equation:
</p>
<p style="text-align: center;"><code class="reqn">df/dt = s - d  f(t)</code>
</p>

<p>This model assumes constant synthesis and degradation rates. Based on this, there are different ways for fitting the parameters:
</p>

<ul>
<li><p><a href="#topic+FitKineticsGeneLeastSquares">FitKineticsGeneLeastSquares</a>: non-linear least squares fit on the full model; depends on proper normalization; can work without steady state; assumption of homoscedastic gaussian errors is theoretically not justified
</p>
</li>
<li><p><a href="#topic+FitKineticsGeneLogSpaceLinear">FitKineticsGeneLogSpaceLinear</a>: linear model fit on the old RNA; depends on proper normalization; assumes steady state for estimating the synthesis rate; assumption of homoscedastic gaussian errors in log space is problematic and theoretically not justified
</p>
</li>
<li><p><a href="#topic+FitKineticsGeneNtr">FitKineticsGeneNtr</a>: maximum a posteriori fit on the NTR posterior transformed to the degradation rate; as it is based on the NTR only, it is independent on proper normalization; assumes steady state; theoretically well justified
</p>
</li></ul>

<p>Pulse-chase designs are fit using <a href="#topic+FitKineticsGeneLeastSquares">FitKineticsGeneLeastSquares</a> while only considering the drop of labeled RNA. Note that in this case the notion &quot;new&quot; / &quot;old&quot; RNA is misleading,
since labeled RNA corresponds to pre-existing RNA!
</p>
<p>This function is flexible in what to put in the analysis table. You can specify the statistics using return.fields and return.extra (see <code><a href="#topic+kinetics2vector">kinetics2vector</a></code>)
</p>


<h3>Value</h3>

<p>A new grandR object with the fitted parameters as an analysis table
</p>


<h3>See Also</h3>

<p><a href="#topic+FitKineticsGeneNtr">FitKineticsGeneNtr</a>, <a href="#topic+FitKineticsGeneLeastSquares">FitKineticsGeneLeastSquares</a>, <a href="#topic+FitKineticsGeneLogSpaceLinear">FitKineticsGeneLogSpaceLinear</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sars &lt;- ReadGRAND(system.file("extdata", "sars.tsv.gz", package = "grandR"),
                  design=c("Cell",Design$dur.4sU,Design$Replicate))
sars &lt;- FilterGenes(sars,use=1:10)
sars&lt;-FitKinetics(sars,name="kinetics.ntr",type='ntr')
sars&lt;-Normalize(sars)
sars&lt;-FitKinetics(sars,name="kinetics.nlls",type='nlls')
sars&lt;-FitKinetics(sars,name="kinetics.lm",type='lm')
head(GetAnalysisTable(sars,columns="Half-life"))

</code></pre>

<hr>
<h2 id='FitKineticsGeneLeastSquares'>Fit a kinetic model according to non-linear least squares.</h2><span id='topic+FitKineticsGeneLeastSquares'></span>

<h3>Description</h3>

<p>Fit the standard mass action kinetics model of gene expression using least squares (i.e. assuming gaussian homoscedastic errors) for the given gene.
The fit takes both old and new RNA into account and requires proper normalization, but can be performed without assuming steady state.
The parameters are fit per <a href="#topic+Condition">Condition</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FitKineticsGeneLeastSquares(
  data,
  gene,
  slot = DefaultSlot(data),
  time = Design$dur.4sU,
  chase = FALSE,
  CI.size = 0.95,
  steady.state = NULL,
  use.old = TRUE,
  use.new = TRUE,
  maxiter = 250,
  compute.residuals = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FitKineticsGeneLeastSquares_+3A_data">data</code></td>
<td>
<p>A grandR object</p>
</td></tr>
<tr><td><code id="FitKineticsGeneLeastSquares_+3A_gene">gene</code></td>
<td>
<p>The gene for which to fit the model</p>
</td></tr>
<tr><td><code id="FitKineticsGeneLeastSquares_+3A_slot">slot</code></td>
<td>
<p>The data slot to take expression values from</p>
</td></tr>
<tr><td><code id="FitKineticsGeneLeastSquares_+3A_time">time</code></td>
<td>
<p>The column in the column annotation table representing the labeling duration</p>
</td></tr>
<tr><td><code id="FitKineticsGeneLeastSquares_+3A_chase">chase</code></td>
<td>
<p>is this a pulse-chase experiment? (see details)</p>
</td></tr>
<tr><td><code id="FitKineticsGeneLeastSquares_+3A_ci.size">CI.size</code></td>
<td>
<p>A number between 0 and 1 representing the size of the confidence interval</p>
</td></tr>
<tr><td><code id="FitKineticsGeneLeastSquares_+3A_steady.state">steady.state</code></td>
<td>
<p>either a named list of logical values representing conditions in steady state or not, or a single logical value for all conditions</p>
</td></tr>
<tr><td><code id="FitKineticsGeneLeastSquares_+3A_use.old">use.old</code></td>
<td>
<p>a logical vector to exclude old RNA from specific time points</p>
</td></tr>
<tr><td><code id="FitKineticsGeneLeastSquares_+3A_use.new">use.new</code></td>
<td>
<p>a logical vector to exclude new RNA from specific time points</p>
</td></tr>
<tr><td><code id="FitKineticsGeneLeastSquares_+3A_maxiter">maxiter</code></td>
<td>
<p>the maximal number of iterations for the Levenberg-Marquardt algorithm used to minimize the least squares</p>
</td></tr>
<tr><td><code id="FitKineticsGeneLeastSquares_+3A_compute.residuals">compute.residuals</code></td>
<td>
<p>set this to TRUE to compute the residual matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The start of labeling for all samples should be the same experimental time point. The fit gets more precise with multiple samples from multiple
labeling durations. In particular (but not only) without assuming steady state, also a sample without 4sU (representing time 0) is useful.
</p>
<p>The standard mass action kinetics model of gene expression arises from the following differential equation:
</p>
<p style="text-align: center;"><code class="reqn">df/dt = s - d  f(t)</code>
</p>

<p>This model assumes constant synthesis and degradation rates (but not necessarily that the system is in steady state at time 0).
From the solution of this differential equation, it is straight forward to derive the expected abundance of old and new RNA at time t
for given parameters s (synthesis rate), d (degradation rate) and f0=f(0) (the abundance at time 0). These equations are implemented in
<code><a href="#topic+f.old.equi">f.old.equi</a></code> (old RNA assuming steady state gene expression, i.e. f0=s/d),
<code><a href="#topic+f.old.nonequi">f.old.nonequi</a></code> (old RNA without assuming steady state gene expression) and
<code><a href="#topic+f.new">f.new</a></code> (new RNA; whether or not it is steady state does not matter).
</p>
<p>This function finds s and d such that the squared error between the observed values of old and new RNA and their corresponding functions
is minimized. For that to work, data has to be properly normalized.
</p>
<p>For pulse-chase designs, only the drop of the labeled RNA is considered. Note that in this case the notion &quot;new&quot; / &quot;old&quot; RNA is misleading,
since labeled RNA corresponds to pre-existing RNA!
</p>


<h3>Value</h3>

<p>A named list containing the model fit:
</p>

<ul>
<li><p>data: a data frame containing the observed value used for fitting
</p>
</li>
<li><p>residuals: the computed residuals if compute.residuals=TRUE, otherwise NA
</p>
</li>
<li><p>Synthesis: the synthesis rate (in U/h, where U is the unit of the slot)
</p>
</li>
<li><p>Degradation: the degradation rate (in 1/h)
</p>
</li>
<li><p>Half-life: the RNA half-life (in h, always equal to log(2)/degradation-rate
</p>
</li>
<li><p>conf.lower: a vector containing the lower confidence bounds for Synthesis, Degradation and Half-life
</p>
</li>
<li><p>conf.upper: a vector containing the lower confidence bounds for Synthesis, Degradation and Half-life
</p>
</li>
<li><p>f0: The abundance at time 0 (in U)
</p>
</li>
<li><p>logLik: the log likelihood of the model
</p>
</li>
<li><p>rmse: the total root mean square error
</p>
</li>
<li><p>rmse.new: the total root mean square error for all new RNA values used for fitting
</p>
</li>
<li><p>rmse.old: the total root mean square error for all old RNA values used for fitting
</p>
</li>
<li><p>total: the total sum of all new and old RNA values used for fitting
</p>
</li>
<li><p>type: non-equi or equi
</p>
</li></ul>

<p>If <code>Condition(data)</code> is not NULL, the return value is a named list (named according to the levels of <code>Condition(data)</code>), each
element containing such a structure.
</p>


<h3>See Also</h3>

<p><a href="#topic+FitKinetics">FitKinetics</a>, <a href="#topic+FitKineticsGeneLogSpaceLinear">FitKineticsGeneLogSpaceLinear</a>, <a href="#topic+FitKineticsGeneNtr">FitKineticsGeneNtr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sars &lt;- ReadGRAND(system.file("extdata", "sars.tsv.gz", package = "grandR"),
                  design=c("Condition",Design$dur.4sU,Design$Replicate))
sars &lt;- Normalize(sars)
FitKineticsGeneLeastSquares(sars,"SRSF6",steady.state=list(Mock=TRUE,SARS=FALSE))

</code></pre>

<hr>
<h2 id='FitKineticsGeneLogSpaceLinear'>Fit a kinetic model using a linear model.</h2><span id='topic+FitKineticsGeneLogSpaceLinear'></span>

<h3>Description</h3>

<p>Fit the standard mass action kinetics model of gene expression using a linear model after log-transforming the observed values
(i.e. assuming gaussian homoscedastic errors of the logarithmized values) for the given gene.
The fit takes only old RNA into account and requires proper normalization, but can be performed without assuming steady state for the degradation rate.
The parameters are fit per <a href="#topic+Condition">Condition</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FitKineticsGeneLogSpaceLinear(
  data,
  gene,
  slot = DefaultSlot(data),
  time = Design$dur.4sU,
  CI.size = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FitKineticsGeneLogSpaceLinear_+3A_data">data</code></td>
<td>
<p>A grandR object</p>
</td></tr>
<tr><td><code id="FitKineticsGeneLogSpaceLinear_+3A_gene">gene</code></td>
<td>
<p>The gene for which to fit the model</p>
</td></tr>
<tr><td><code id="FitKineticsGeneLogSpaceLinear_+3A_slot">slot</code></td>
<td>
<p>The data slot to take expression values from</p>
</td></tr>
<tr><td><code id="FitKineticsGeneLogSpaceLinear_+3A_time">time</code></td>
<td>
<p>The column in the column annotation table representing the labeling duration</p>
</td></tr>
<tr><td><code id="FitKineticsGeneLogSpaceLinear_+3A_ci.size">CI.size</code></td>
<td>
<p>A number between 0 and 1 representing the size of the confidence interval</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The start of labeling for all samples should be the same experimental time point. The fit gets more precise with multiple samples from multiple
labeling durations. Also a sample without 4sU (representing time 0) is useful.
</p>
<p>The standard mass action kinetics model of gene expression arises from the following differential equation:
</p>
<p style="text-align: center;"><code class="reqn">df/dt = s - d  f(t)</code>
</p>

<p>This model assumes constant synthesis and degradation rates (but not necessarily that the system is in steady state at time 0).
From the solution of this differential equation, it is straight forward to derive the expected abundance of old and new RNA at time t
for given parameters s (synthesis rate), d (degradation rate) and f0=f(0) (the abundance at time 0). These equations are implemented in
<code><a href="#topic+f.old.equi">f.old.equi</a></code> (old RNA assuming steady state gene expression, i.e. f0=s/d),
<code><a href="#topic+f.old.nonequi">f.old.nonequi</a></code> (old RNA without assuming steady state gene expression) and
<code><a href="#topic+f.new">f.new</a></code> (new RNA; whether or not it is steady state does not matter).
</p>
<p>This function primarily finds d such that the squared error between the observed values of old and new RNA and their corresponding functions
is minimized in log space. For that to work, data has to be properly normalized, but this is independent on any steady state assumptions. The synthesis
rate is computed (under the assumption of steady state) as <code class="reqn">s=f0 \cdot d</code>
</p>


<h3>Value</h3>

<p>A named list containing the model fit:
</p>

<ul>
<li><p>data: a data frame containing the observed value used for fitting
</p>
</li>
<li><p>Synthesis: the synthesis rate (in U/h, where U is the unit of the slot)
</p>
</li>
<li><p>Degradation: the degradation rate (in 1/h)
</p>
</li>
<li><p>Half-life: the RNA half-life (in h, always equal to log(2)/degradation-rate
</p>
</li>
<li><p>conf.lower: a vector containing the lower confidence bounds for Synthesis, Degradation and Half-life
</p>
</li>
<li><p>conf.upper: a vector containing the lower confidence bounds for Synthesis, Degradation and Half-life
</p>
</li>
<li><p>f0: The abundance at time 0 (in U)
</p>
</li>
<li><p>logLik: the log likelihood of the model
</p>
</li>
<li><p>rmse: the total root mean square error
</p>
</li>
<li><p>adj.r.squared: adjusted R^2 of the linear model fit
</p>
</li>
<li><p>total: the total sum of all new and old RNA values used for fitting
</p>
</li>
<li><p>type: always &quot;lm&quot;
</p>
</li></ul>

<p>If <code>Condition(data)</code> is not NULL, the return value is a named list (named according to the levels of <code>Condition(data)</code>), each
element containing such a structure.
</p>


<h3>See Also</h3>

<p><a href="#topic+FitKinetics">FitKinetics</a>, <a href="#topic+FitKineticsGeneLeastSquares">FitKineticsGeneLeastSquares</a>, <a href="#topic+FitKineticsGeneNtr">FitKineticsGeneNtr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sars &lt;- ReadGRAND(system.file("extdata", "sars.tsv.gz", package = "grandR"),
                  design=c("Condition",Design$dur.4sU,Design$Replicate))
sars &lt;- Normalize(sars)
FitKineticsGeneLogSpaceLinear(sars,"SRSF6")   # fit per condition

</code></pre>

<hr>
<h2 id='FitKineticsGeneNtr'>Fit a kinetic model using the degradation rate transformed NTR posterior distribution.</h2><span id='topic+FitKineticsGeneNtr'></span>

<h3>Description</h3>

<p>Fit the standard mass action kinetics model of gene expression by maximum a posteriori on a model based on the NTR posterior.
The fit takes only the NTRs into account and is completely independent on normalization, but it cannot be performed without assuming steady state.
The parameters are fit per <a href="#topic+Condition">Condition</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FitKineticsGeneNtr(
  data,
  gene,
  slot = DefaultSlot(data),
  time = Design$dur.4sU,
  CI.size = 0.95,
  transformed.NTR.MAP = TRUE,
  exact.ci = FALSE,
  total.fun = median
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FitKineticsGeneNtr_+3A_data">data</code></td>
<td>
<p>A grandR object</p>
</td></tr>
<tr><td><code id="FitKineticsGeneNtr_+3A_gene">gene</code></td>
<td>
<p>The gene for which to fit the model</p>
</td></tr>
<tr><td><code id="FitKineticsGeneNtr_+3A_slot">slot</code></td>
<td>
<p>The data slot to take expression values from</p>
</td></tr>
<tr><td><code id="FitKineticsGeneNtr_+3A_time">time</code></td>
<td>
<p>The column in the column annotation table representing the labeling duration</p>
</td></tr>
<tr><td><code id="FitKineticsGeneNtr_+3A_ci.size">CI.size</code></td>
<td>
<p>A number between 0 and 1 representing the size of the credible interval</p>
</td></tr>
<tr><td><code id="FitKineticsGeneNtr_+3A_transformed.ntr.map">transformed.NTR.MAP</code></td>
<td>
<p>Use the transformed NTR MAP estimator instead of the MAP of the transformed posterior</p>
</td></tr>
<tr><td><code id="FitKineticsGeneNtr_+3A_exact.ci">exact.ci</code></td>
<td>
<p>compute exact credible intervals (see details)</p>
</td></tr>
<tr><td><code id="FitKineticsGeneNtr_+3A_total.fun">total.fun</code></td>
<td>
<p>use this function to summarize the expression values (only relevant for computing the synthesis rate s)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The start of labeling for all samples should be the same experimental time point. The fit gets more precise with multiple samples from multiple
labeling durations.
</p>
<p>The standard mass action kinetics model of gene expression arises from the following differential equation:
</p>
<p style="text-align: center;"><code class="reqn">df/dt = s - d  f(t)</code>
</p>

<p>This model assumes constant synthesis and degradation rates. Further assuming steady state allows to derive the function transforming from
the NTR to the degradation rate d as <code class="reqn">d(ntr)=-1/t log(1-ntr)</code>. Furthermore, if the ntr is (approximately) beta distributed, it is possible to
derive the distribution of the transformed random variable for the degradation rate (see Juerges et al., Bioinformatics 2018).
</p>
<p>This function primarily finds d by maximizing the degradation rate posterior distribution. For that, data does not have to be normalized,
but this only works under steady-state conditions. The synthesis rate is then computed (under the assumption of steady state) as <code class="reqn">s=f0 \cdot d</code>
</p>
<p>The maximum-a-posteriori estimator is biased. Bias can be removed by a correction factor (which is done by default).
</p>
<p>By default the chi-squared approximation of the log-posterior function is used to compute credible intervals. If exact.ci is used, the
posterior is integrated numerically.
</p>


<h3>Value</h3>

<p>A named list containing the model fit:
</p>

<ul>
<li><p>data: a data frame containing the observed value used for fitting
</p>
</li>
<li><p>Synthesis: the synthesis rate (in U/h, where U is the unit of the slot)
</p>
</li>
<li><p>Degradation: the degradation rate (in 1/h)
</p>
</li>
<li><p>Half-life: the RNA half-life (in h, always equal to log(2)/degradation-rate
</p>
</li>
<li><p>conf.lower: a vector containing the lower confidence bounds for Synthesis, Degradation and Half-life
</p>
</li>
<li><p>conf.upper: a vector containing the lower confidence bounds for Synthesis, Degradation and Half-life
</p>
</li>
<li><p>f0: The abundance at time 0 (in U)
</p>
</li>
<li><p>logLik: the log likelihood of the model
</p>
</li>
<li><p>rmse: the total root mean square error
</p>
</li>
<li><p>total: the total sum of all new and old RNA values used for fitting
</p>
</li>
<li><p>type: always &quot;ntr&quot;
</p>
</li></ul>

<p>If <code>Condition(data)</code> is not NULL, the return value is a named list (named according to the levels of <code>Condition(data)</code>), each
element containing such a structure.
</p>


<h3>See Also</h3>

<p><a href="#topic+FitKinetics">FitKinetics</a>, <a href="#topic+FitKineticsGeneLeastSquares">FitKineticsGeneLeastSquares</a>, <a href="#topic+FitKineticsGeneLogSpaceLinear">FitKineticsGeneLogSpaceLinear</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sars &lt;- ReadGRAND(system.file("extdata", "sars.tsv.gz", package = "grandR"),
                  design=c("Condition",Design$dur.4sU,Design$Replicate))
sars &lt;- Normalize(sars)
sars &lt;- subset(sars,columns=Condition=="Mock")
FitKineticsGeneNtr(sars,"SRSF6")

</code></pre>

<hr>
<h2 id='FitKineticsGeneSnapshot'>Compute the posterior distributions of RNA synthesis and degradation for a particular gene</h2><span id='topic+FitKineticsGeneSnapshot'></span>

<h3>Description</h3>

<p>Compute the posterior distributions of RNA synthesis and degradation for a particular gene
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FitKineticsGeneSnapshot(
  data,
  gene,
  columns = NULL,
  reference.columns = NULL,
  dispersion = NULL,
  slot = DefaultSlot(data),
  time.labeling = Design$dur.4sU,
  time.experiment = NULL,
  sample.f0.in.ss = TRUE,
  sample.level = 2,
  beta.prior = NULL,
  return.samples = FALSE,
  return.points = FALSE,
  N = 10000,
  N.max = N * 10,
  CI.size = 0.95,
  correct.labeling = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FitKineticsGeneSnapshot_+3A_data">data</code></td>
<td>
<p>the grandR object</p>
</td></tr>
<tr><td><code id="FitKineticsGeneSnapshot_+3A_gene">gene</code></td>
<td>
<p>a gene name or symbol or index</p>
</td></tr>
<tr><td><code id="FitKineticsGeneSnapshot_+3A_columns">columns</code></td>
<td>
<p>samples or cell representing the same experimental condition (must refer to a unique labeling duration)</p>
</td></tr>
<tr><td><code id="FitKineticsGeneSnapshot_+3A_reference.columns">reference.columns</code></td>
<td>
<p>a reference matrix usually generated by <a href="#topic+FindReferences">FindReferences</a> to define reference samples for each sample (see details)</p>
</td></tr>
<tr><td><code id="FitKineticsGeneSnapshot_+3A_dispersion">dispersion</code></td>
<td>
<p>dispersion parameter for the given columns (if NULL, this is estimated from the data, takes a lot of time!)</p>
</td></tr>
<tr><td><code id="FitKineticsGeneSnapshot_+3A_slot">slot</code></td>
<td>
<p>the data slot to take f0 and totals from</p>
</td></tr>
<tr><td><code id="FitKineticsGeneSnapshot_+3A_time.labeling">time.labeling</code></td>
<td>
<p>the column in the column annotation table denoting the labeling duration or the labeling duration itself</p>
</td></tr>
<tr><td><code id="FitKineticsGeneSnapshot_+3A_time.experiment">time.experiment</code></td>
<td>
<p>the column in the column annotation table denoting the experimental time point (can be NULL, see details)</p>
</td></tr>
<tr><td><code id="FitKineticsGeneSnapshot_+3A_sample.f0.in.ss">sample.f0.in.ss</code></td>
<td>
<p>whether or not to sample f0 under steady state conditions</p>
</td></tr>
<tr><td><code id="FitKineticsGeneSnapshot_+3A_sample.level">sample.level</code></td>
<td>
<p>Define how the NTR is sampled from the hierarchical Bayesian model (must be 0,1, or 2; see details)</p>
</td></tr>
<tr><td><code id="FitKineticsGeneSnapshot_+3A_beta.prior">beta.prior</code></td>
<td>
<p>The beta prior for the negative binomial used to sample counts, if NULL, a beta distribution is fit to all expression values and given dispersions</p>
</td></tr>
<tr><td><code id="FitKineticsGeneSnapshot_+3A_return.samples">return.samples</code></td>
<td>
<p>return the posterior samples of the parameters?</p>
</td></tr>
<tr><td><code id="FitKineticsGeneSnapshot_+3A_return.points">return.points</code></td>
<td>
<p>return the point estimates per replicate as well?</p>
</td></tr>
<tr><td><code id="FitKineticsGeneSnapshot_+3A_n">N</code></td>
<td>
<p>the posterior sample size</p>
</td></tr>
<tr><td><code id="FitKineticsGeneSnapshot_+3A_n.max">N.max</code></td>
<td>
<p>the maximal number of posterior samples (necessary if old RNA &gt; f0); if more are necessary, a warning is generated</p>
</td></tr>
<tr><td><code id="FitKineticsGeneSnapshot_+3A_ci.size">CI.size</code></td>
<td>
<p>A number between 0 and 1 representing the size of the credible interval</p>
</td></tr>
<tr><td><code id="FitKineticsGeneSnapshot_+3A_correct.labeling">correct.labeling</code></td>
<td>
<p>whether to correct labeling times</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The kinetic parameters s and d are computed using <a href="#topic+TransformSnapshot">TransformSnapshot</a>. For that, the sample either must be in steady state
(this is the case if defined in the reference.columns matrix), or if the levels of reference samples from a specific prior time point are known. This time point is
defined by <code>time.experiment</code> (i.e. the difference between the reference samples and samples themselves). If
<code>time.experiment</code> is NULL, then the labeling time of the samples is used (e.g. useful if labeling was started concomitantly with
the perturbation, and the reference samples are unperturbed samples).
</p>
<p>By default, the hierarchical Bayesian model is estimated. If sample.level = 0, the NTRs are sampled from a beta distribution
that approximates the mixture of betas from the replicate samples. If sample.level = 1, only the first level from the hierarchical model
is sampled (corresponding to the uncertainty of estimating the biological variability). If sample.level = 2, the first and second levels
are estimated (corresponding to the full hierarchical model).
</p>
<p>Columns can be given as a logical, integer or character vector representing a selection of the columns (samples or cells).
The expression is evaluated in an environment having the <code><a href="#topic+Coldata">Coldata</a></code>, i.e. you can use names of <code><a href="#topic+Coldata">Coldata</a></code> as variables to
conveniently build a logical vector (e.g., columns=Condition==&quot;x&quot;).
</p>


<h3>Value</h3>

<p>a list containing the posterior mean of s and s, its credible intervals and,
if return.samples=TRUE a data frame containing all posterior samples
</p>

<hr>
<h2 id='FitKineticsPulseR'>Fit kinetics using pulseR</h2><span id='topic+FitKineticsPulseR'></span>

<h3>Description</h3>

<p>Fit kinetics using pulseR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FitKineticsPulseR(data, name = "pulseR", time = Design$dur.4sU)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FitKineticsPulseR_+3A_data">data</code></td>
<td>
<p>A grandR object</p>
</td></tr>
<tr><td><code id="FitKineticsPulseR_+3A_name">name</code></td>
<td>
<p>the user defined analysis name to store the results</p>
</td></tr>
<tr><td><code id="FitKineticsPulseR_+3A_time">time</code></td>
<td>
<p>The column in the column annotation table representing the labeling duration</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is adapted code from https://github.com/dieterich-lab/ComparisonOfMetabolicLabeling
</p>


<h3>Value</h3>

<p>a new grandR object containing the pulseR analyses in a new analysis table
</p>

<hr>
<h2 id='FitKineticsSnapshot'>Fits RNA kinetics from snapshot experiments</h2><span id='topic+FitKineticsSnapshot'></span>

<h3>Description</h3>

<p>Compute the posterior distributions of RNA synthesis and degradation from snapshot experiments for each condition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FitKineticsSnapshot(
  data,
  name.prefix = "Kinetics",
  reference.columns = NULL,
  slot = DefaultSlot(data),
  conditions = NULL,
  time.labeling = Design$dur.4sU,
  time.experiment = NULL,
  sample.f0.in.ss = TRUE,
  N = 10000,
  N.max = N * 10,
  CI.size = 0.95,
  seed = 1337,
  dispersion = NULL,
  sample.level = 2,
  correct.labeling = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FitKineticsSnapshot_+3A_data">data</code></td>
<td>
<p>the grandR object</p>
</td></tr>
<tr><td><code id="FitKineticsSnapshot_+3A_name.prefix">name.prefix</code></td>
<td>
<p>the prefix for the new analysis name; a dot and the column names of the contrast matrix are appended; can be NULL (then only the contrast matrix names are used)</p>
</td></tr>
<tr><td><code id="FitKineticsSnapshot_+3A_reference.columns">reference.columns</code></td>
<td>
<p>a reference matrix usually generated by <a href="#topic+FindReferences">FindReferences</a> to define reference samples for each sample (see details), can be NULL if all conditions are at steady state</p>
</td></tr>
<tr><td><code id="FitKineticsSnapshot_+3A_slot">slot</code></td>
<td>
<p>the data slot to take f0 and totals from</p>
</td></tr>
<tr><td><code id="FitKineticsSnapshot_+3A_conditions">conditions</code></td>
<td>
<p>character vector of all condition names to estimate kinetics for; can be NULL (i.e. all conditions)</p>
</td></tr>
<tr><td><code id="FitKineticsSnapshot_+3A_time.labeling">time.labeling</code></td>
<td>
<p>the column in the column annotation table denoting the labeling duration or the labeling duration itself</p>
</td></tr>
<tr><td><code id="FitKineticsSnapshot_+3A_time.experiment">time.experiment</code></td>
<td>
<p>the column in the column annotation table denoting the experimental time point (can be NULL, see details)</p>
</td></tr>
<tr><td><code id="FitKineticsSnapshot_+3A_sample.f0.in.ss">sample.f0.in.ss</code></td>
<td>
<p>whether or not to sample f0 under steady state conditions</p>
</td></tr>
<tr><td><code id="FitKineticsSnapshot_+3A_n">N</code></td>
<td>
<p>the sample size</p>
</td></tr>
<tr><td><code id="FitKineticsSnapshot_+3A_n.max">N.max</code></td>
<td>
<p>the maximal number of samples (necessary if old RNA &gt; f0); if more are necessary, a warning is generated</p>
</td></tr>
<tr><td><code id="FitKineticsSnapshot_+3A_ci.size">CI.size</code></td>
<td>
<p>A number between 0 and 1 representing the size of the credible interval</p>
</td></tr>
<tr><td><code id="FitKineticsSnapshot_+3A_seed">seed</code></td>
<td>
<p>Seed for the random number generator</p>
</td></tr>
<tr><td><code id="FitKineticsSnapshot_+3A_dispersion">dispersion</code></td>
<td>
<p>overdispersion parameter for each gene; if NULL this is estimated from data</p>
</td></tr>
<tr><td><code id="FitKineticsSnapshot_+3A_sample.level">sample.level</code></td>
<td>
<p>Define how the NTR is sampled from the hierarchical Bayesian model (must be 0,1, or 2; see details)</p>
</td></tr>
<tr><td><code id="FitKineticsSnapshot_+3A_correct.labeling">correct.labeling</code></td>
<td>
<p>Labeling times have to be unique; usually execution is aborted, if this is not the case; if this is set to true, the median labeling time is assumed</p>
</td></tr>
<tr><td><code id="FitKineticsSnapshot_+3A_verbose">verbose</code></td>
<td>
<p>Vebose output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The kinetic parameters s and d are computed using <a href="#topic+TransformSnapshot">TransformSnapshot</a>. For that, the sample either must be in steady state
(this is the case if defined in the reference.columns matrix), or if the levels at an earlier time point are known from separate samples,
so called temporal reference samples. Thus, if s and d are estimated for a set of samples x_1,...,x_k (that must be from the same time point t),
we need to find (i) the corresponding temporal reference samples from time t0, and (ii) the time difference between t and t0.
</p>
<p>The temporal reference samples are identified by the reference.columns matrix. This is a square matrix of logicals, rows and columns correspond to all samples
and TRUE indicates that the row sample is a temporal reference of the columns sample. This time point is defined by <code>time.experiment</code>. If <code>time.experiment</code>
is NULL, then the labeling time of the A or B samples is used (e.g. useful if labeling was started concomitantly with the perturbation, and the steady state samples
are unperturbed samples).
</p>
<p>By default, the hierarchical Bayesian model is estimated. If sample.level = 0, the NTRs are sampled from a beta distribution
that approximates the mixture of betas from the replicate samples. If sample.level = 1, only the first level from the hierarchical model
is sampled (corresponding to the uncertainty of estimating the biological variability). If sample.level = 2, the first and second levels
are estimated (corresponding to the full hierarchical model).
</p>
<p>if N is set to 0, then no sampling from the posterior is performed, but the transformed MAP estimates are returned
</p>


<h3>Value</h3>

<p>a new grandR object including new analysis tables (one per condition). The columns of the new analysis table are
</p>
<table>
<tr><td><code>"s"</code></td>
<td>
<p>the posterior mean synthesis rate</p>
</td></tr>
<tr><td><code>"HL"</code></td>
<td>
<p>the posterior mean RNA half-life</p>
</td></tr>
<tr><td><code>"s.cred.lower"</code></td>
<td>
<p>the lower CI boundary of the synthesis rate</p>
</td></tr>
<tr><td><code>"s.cred.upper"</code></td>
<td>
<p>the upper CI boundary of the synthesis rate</p>
</td></tr>
<tr><td><code>"HL.cred.lower"</code></td>
<td>
<p>the lower CI boundary of the half-life</p>
</td></tr>
<tr><td><code>"HL.cred.upper"</code></td>
<td>
<p>the upper CI boundary of the half-life</p>
</td></tr>
</table>

<hr>
<h2 id='FormatCorrelation'>Formatting function for correlations</h2><span id='topic+FormatCorrelation'></span>

<h3>Description</h3>

<p>Returns a function that takes x and y and returns a formatted output to describe the correlation of x and y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FormatCorrelation(
  method = "pearson",
  n.format = NULL,
  coeff.format = "%.2f",
  p.format = "%.2g",
  slope.format = NULL,
  rmsd.format = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FormatCorrelation_+3A_method">method</code></td>
<td>
<p>how to compute correlation coefficients (can be pearson, spearman or kendall)</p>
</td></tr>
<tr><td><code id="FormatCorrelation_+3A_n.format">n.format</code></td>
<td>
<p>format string for the number of data points (see <a href="base.html#topic+sprintf">sprintf</a>); can be NULL (don't output the number of data points)</p>
</td></tr>
<tr><td><code id="FormatCorrelation_+3A_coeff.format">coeff.format</code></td>
<td>
<p>format string for the correlation coefficient (see <a href="base.html#topic+sprintf">sprintf</a>); can be NULL (don't output the correlation coefficient)</p>
</td></tr>
<tr><td><code id="FormatCorrelation_+3A_p.format">p.format</code></td>
<td>
<p>format string for the P value (see <a href="base.html#topic+sprintf">sprintf</a>); can be NULL (don't output the P value)</p>
</td></tr>
<tr><td><code id="FormatCorrelation_+3A_slope.format">slope.format</code></td>
<td>
<p>format string for the slope (see <a href="base.html#topic+sprintf">sprintf</a>); can be NULL (don't output the slope)</p>
</td></tr>
<tr><td><code id="FormatCorrelation_+3A_rmsd.format">rmsd.format</code></td>
<td>
<p>format string for the root mean square deviation (see <a href="base.html#topic+sprintf">sprintf</a>); can be NULL (don't output the rmsd)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use this for the <code>correlation</code> parameter of <a href="#topic+PlotScatter">PlotScatter</a>
</p>
<p>The slope is computed via a principal component analysis and *not* by linear regression
</p>


<h3>Value</h3>

<p>a function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(42)
data &lt;- data.frame(u=runif(500))  # generate some correlated data
data$x &lt;- rnorm(500,mean=data$u)
data$y &lt;- rnorm(500,mean=data$u)

fun &lt;- FormatCorrelation()
fun(data$x,data$y)

fun &lt;- FormatCorrelation(method="spearman",p.format="%.4g")
fun(data$x,data$y)

</code></pre>

<hr>
<h2 id='GeneInfo'>Get the gene annotation table or add additional columns to it</h2><span id='topic+GeneInfo'></span><span id='topic+GeneInfo+3C-'></span>

<h3>Description</h3>

<p>The gene annotation table contains meta information for the rows of a grandR object.
When loaded from the GRAND-SLAM output, this this contains gene ids, gene symbols, the
transcript length and the type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeneInfo(data, column = NULL, value = NULL)

GeneInfo(data, column) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeneInfo_+3A_data">data</code></td>
<td>
<p>A grandR object</p>
</td></tr>
<tr><td><code id="GeneInfo_+3A_column">column</code></td>
<td>
<p>The name of the additional annotation column</p>
</td></tr>
<tr><td><code id="GeneInfo_+3A_value">value</code></td>
<td>
<p>The additional annotation per gene</p>
</td></tr>
</table>


<h3>Details</h3>

<p>New columns can be added either by <code>data&lt;-GeneInfo(data,name,values)</code> or by <code>GeneInfo(data,name)&lt;-values</code>.
</p>


<h3>Value</h3>

<p>Either the gene annotation table or a new grandR object having an updated gene annotation table
</p>


<h3>See Also</h3>

<p><a href="#topic+Genes">Genes</a>, <a href="#topic+Coldata">Coldata</a>, <a href="#topic+ReadGRAND">ReadGRAND</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sars &lt;- ReadGRAND(system.file("extdata", "sars.tsv.gz", package = "grandR"),
                  design=c("Cell",Design$dur.4sU,Design$Replicate))

head(GeneInfo(sars))
GeneInfo(sars,"LengthCategory")&lt;-cut(GeneInfo(sars)$Length,c(0,1500,2500,Inf),
                                          labels=c("Short","Medium","Long"))
table(GeneInfo(sars)$LengthCategory)

</code></pre>

<hr>
<h2 id='Genes'>Gene and sample (or cell) names</h2><span id='topic+Genes'></span><span id='topic+Columns'></span>

<h3>Description</h3>

<p>Get the genes and sample (or cell) names for a grandR object, or add an additional gene annotation column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Genes(data, genes = NULL, use.symbols = TRUE, regex = FALSE)

Columns(data, columns = NULL, reorder = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Genes_+3A_data">data</code></td>
<td>
<p>A grandR object</p>
</td></tr>
<tr><td><code id="Genes_+3A_genes">genes</code></td>
<td>
<p>which genes to use</p>
</td></tr>
<tr><td><code id="Genes_+3A_use.symbols">use.symbols</code></td>
<td>
<p>obtain the gene symbols instead of gene names</p>
</td></tr>
<tr><td><code id="Genes_+3A_regex">regex</code></td>
<td>
<p>treat genes as a regex, and return all that match</p>
</td></tr>
<tr><td><code id="Genes_+3A_columns">columns</code></td>
<td>
<p>which columns (i.e. samples or cells) to return (see details)</p>
</td></tr>
<tr><td><code id="Genes_+3A_reorder">reorder</code></td>
<td>
<p>if TRUE, do not enforce the current order of columns</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The genes are either the (often unreadable) gene ids (e.g. Ensembl ids), or the symbols.
</p>
<p><code>Genes(data,use.symbols=FALSE)</code> it the same as <code>rownames(data)</code>, and <code>Columns(data)</code> is the same as <code>colnames(data)</code>
</p>
<p>If both column and value are specified for <code>GeneInfo</code>, a new column is added to the gene annotation table
</p>
<p>Columns can be given as a logical, integer or character vector representing a selection of the columns (samples or cells).
The expression is evaluated in an environment having the <code><a href="#topic+Coldata">Coldata</a></code>, i.e. you can use names of <code><a href="#topic+Coldata">Coldata</a></code> as variables to
conveniently build a logical vector (e.g., columns=Condition==&quot;x&quot;).
</p>


<h3>Value</h3>

<p>Either the gene or column names of the grandR data object, or the columns of an analysis table in the grandR object
</p>


<h3>See Also</h3>

<p><a href="#topic+Coldata">Coldata</a>, <a href="#topic+GeneInfo">GeneInfo</a>, <a href="#topic+Analyses">Analyses</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sars &lt;- ReadGRAND(system.file("extdata", "sars.tsv.gz", package = "grandR"),
                  design=c("Cell",Design$dur.4sU,Design$Replicate))

all(Genes(sars,use.symbols = FALSE)==rownames(sars))
all(Columns(sars)==colnames(sars))


</code></pre>

<hr>
<h2 id='get.mode.slot'>Internal functions to parse mode.slot strings</h2><span id='topic+get.mode.slot'></span>

<h3>Description</h3>

<p>Internal functions to parse mode.slot strings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.mode.slot(data, mode.slot, allow.ntr = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.mode.slot_+3A_data">data</code></td>
<td>
<p>a grandR object</p>
</td></tr>
<tr><td><code id="get.mode.slot_+3A_mode.slot">mode.slot</code></td>
<td>
<p>a mode.slot</p>
</td></tr>
<tr><td><code id="get.mode.slot_+3A_allow.ntr">allow.ntr</code></td>
<td>
<p>whether to allow for the value &quot;ntr&quot; (and throw an error in case)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A mode.slot is a mode followed by a dot followed by a slot name, or just a slot name. A mode is either <em>total</em>, <em>new</em> or <em>old</em>
</p>


<h3>Value</h3>

<p>a named list with elements mode and slot (or only slot in case of <em>ntr</em>,<em>alpha</em> or <em>beta</em>)
</p>

<hr>
<h2 id='GetAnalysisTable'>Obtain a table of analysis results values</h2><span id='topic+GetAnalysisTable'></span>

<h3>Description</h3>

<p>This is the main function to access analysis results. For slot data, use <code><a href="#topic+GetTable">GetTable</a></code> (as a large matrix)
or <code><a href="#topic+GetData">GetData</a></code> (as tidy table).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetAnalysisTable(
  data,
  analyses = NULL,
  regex = TRUE,
  columns = NULL,
  genes = Genes(data),
  by.rows = FALSE,
  gene.info = TRUE,
  name.by = "Symbol",
  prefix.by.analysis = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetAnalysisTable_+3A_data">data</code></td>
<td>
<p>A grandR object</p>
</td></tr>
<tr><td><code id="GetAnalysisTable_+3A_analyses">analyses</code></td>
<td>
<p>One or several regex to be matched against analysis names (<a href="#topic+Analyses">Analyses</a>); all analysis tables if NULL</p>
</td></tr>
<tr><td><code id="GetAnalysisTable_+3A_regex">regex</code></td>
<td>
<p>Use regex for analyses (TRUE) or don't (FALSE, i.e. must specify the exact name)</p>
</td></tr>
<tr><td><code id="GetAnalysisTable_+3A_columns">columns</code></td>
<td>
<p>Regular expressions to select columns from the analysis table (all have to match!); all columns if NULL</p>
</td></tr>
<tr><td><code id="GetAnalysisTable_+3A_genes">genes</code></td>
<td>
<p>Restrict the output table to the given genes</p>
</td></tr>
<tr><td><code id="GetAnalysisTable_+3A_by.rows">by.rows</code></td>
<td>
<p>if TRUE, add rows if there are multiple analyses; otherwise, additional columns are appended; TRUE also sets prefix.by.analysis to FALSE!</p>
</td></tr>
<tr><td><code id="GetAnalysisTable_+3A_gene.info">gene.info</code></td>
<td>
<p>Should the table contain the <a href="#topic+GeneInfo">GeneInfo</a> values as well (at the beginning)?</p>
</td></tr>
<tr><td><code id="GetAnalysisTable_+3A_name.by">name.by</code></td>
<td>
<p>A column name of <a href="#topic+Coldata">Coldata</a>(data). This is used as the rownames of the output table</p>
</td></tr>
<tr><td><code id="GetAnalysisTable_+3A_prefix.by.analysis">prefix.by.analysis</code></td>
<td>
<p>Should the column names in the output prefixed by the analysis name?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The names for the output table are &lt;Analysis name&gt;.&lt;columns name&gt;
</p>


<h3>Value</h3>

<p>A data frame containing the analysis results
</p>


<h3>See Also</h3>

<p><a href="#topic+GetTable">GetTable</a>,<a href="#topic+GetData">GetData</a>,<a href="#topic+Genes">Genes</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sars &lt;- ReadGRAND(system.file("extdata", "sars.tsv.gz", package = "grandR"),
                  design=c("Condition",Design$dur.4sU,Design$Replicate))
sars&lt;-LFC(sars,contrasts=GetContrasts(sars,group = "duration.4sU"))
head(GetAnalysisTable(sars,columns="LFC"))

</code></pre>

<hr>
<h2 id='GetContrasts'>Create a contrast matrix</h2><span id='topic+GetContrasts'></span><span id='topic+GetContrasts.grandR'></span><span id='topic+GetContrasts.default'></span>

<h3>Description</h3>

<p>Each column of a contrast matrix represents a pairwise comparison of all samples or cells of
a grandR object (or a column annotation table). Elements being 1 are contrasted vs. elements being -1
(and all 0 are irrelevant for this comparison).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetContrasts(x, ...)

## S3 method for class 'grandR'
GetContrasts(
  x,
  contrast = "Condition",
  no4sU = FALSE,
  columns = NULL,
  group = NULL,
  name.format = NULL,
  ...
)

## Default S3 method:
GetContrasts(
  x,
  contrast,
  columns = NULL,
  group = NULL,
  name.format = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetContrasts_+3A_x">x</code></td>
<td>
<p>A grandR object or a column annotation table</p>
</td></tr>
<tr><td><code id="GetContrasts_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
<tr><td><code id="GetContrasts_+3A_contrast">contrast</code></td>
<td>
<p>A vector describing what should be contrasted</p>
</td></tr>
<tr><td><code id="GetContrasts_+3A_no4su">no4sU</code></td>
<td>
<p>Use no4sU columns (TRUE) or not (FALSE)</p>
</td></tr>
<tr><td><code id="GetContrasts_+3A_columns">columns</code></td>
<td>
<p>logical vector of which columns (samples or cells) to use (or NULL: use all); for grandR objects, see details</p>
</td></tr>
<tr><td><code id="GetContrasts_+3A_group">group</code></td>
<td>
<p>Split the samples or cells according to this column of the column annotation table (and adapt the of the output table)</p>
</td></tr>
<tr><td><code id="GetContrasts_+3A_name.format">name.format</code></td>
<td>
<p>Format string for generating the column from the contrast vector (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To compare one specific factor level <em>A</em> against another level <em>B</em> in
a particular column <em>COL</em> of the column annotation table, specify contrast=c(&quot;COL&quot;,&quot;A&quot;,&quot;B&quot;)
</p>
<p>To compare all levels against a specific level <em>A</em> in
a particular column <em>COL</em> of the column annotation table, specify contrast=c(&quot;COL&quot;,&quot;A&quot;)
</p>
<p>To perform all pairwise comparisons of all levels from
a particular column <em>COL</em> of the column annotation table, specify contrast=c(&quot;COL&quot;)
</p>
<p>If the column <em>COL</em> only has two levels, all three are equivalent.
</p>
<p>In all cases, if groups is not NULL, the columns annotation table is first split and contrasts are applied within all samples or cells
with the same <em>group</em> factor level.
</p>
<p>The format string specifies the column name in the generated contrast matrix (which is used as the <em>Analysis</em> name when calling
<code><a href="#topic+ApplyContrasts">ApplyContrasts</a></code>, <code><a href="#topic+LFC">LFC</a></code>, <code><a href="#topic+PairwiseDESeq2">PairwiseDESeq2</a></code>, etc.). The keywords <em>$GRP</em>, <em>$COL</em>, <em>$A</em> and <em>$B</em> are substituted
by the respective elements of the contrast vector or the group this comparison refers to. By default, it is &quot;$A vs $B&quot; if group is NULL, and &quot;$A vs $B.$GRP&quot; otherwise.
</p>
<p>The method for grandR objects simply calls the general method
</p>
<p>For grandR objects, columns can be given as a logical, integer or character vector representing a selection of the columns (samples or cells).
The expression is evaluated in an environment having the <code><a href="#topic+Coldata">Coldata</a></code>, i.e. you can use names of <code><a href="#topic+Coldata">Coldata</a></code> as variables to
conveniently build a logical vector (e.g., columns=Condition=&quot;x&quot;).
</p>


<h3>Value</h3>

<p>A data frame representig a contrast matrix to be used in <code><a href="#topic+ApplyContrasts">ApplyContrasts</a></code>, <code><a href="#topic+LFC">LFC</a></code>, <code><a href="#topic+PairwiseDESeq2">PairwiseDESeq2</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ApplyContrasts">ApplyContrasts</a></code>, <code><a href="#topic+LFC">LFC</a></code>, <code><a href="#topic+PairwiseDESeq2">PairwiseDESeq2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sars &lt;- ReadGRAND(system.file("extdata", "sars.tsv.gz", package = "grandR"),
                  design=c("Condition","Time",Design$Replicate))

GetContrasts(sars,contrast="Condition")
# Compare all Mock vs. all SARS
GetContrasts(sars,contrast=c("Condition","SARS","Mock"))
# This direction of the comparison is more reasonable
GetContrasts(sars,contrast=c("Condition","SARS","Mock"),group="Time")
# Compare SARS vs Mock per time point
GetContrasts(sars,contrast=c("Time.original","no4sU"), group="Condition",no4sU=TRUE,
                                                name.format="$A vs $B ($GRP)")
# Compare each sample against the respective no4sU sample

# See the differential-expression vignette for more examples!
</code></pre>

<hr>
<h2 id='GetData'>Obtain a tidy table of values for a gene or a small set of genes</h2><span id='topic+GetData'></span>

<h3>Description</h3>

<p>This is the main function to access slot data data from a particular gene
(or a small set of genes) as a tidy table. If data for all genes
must be retrieved (as a large matrix), use the <code><a href="#topic+GetTable">GetTable</a></code>
function. For analysis results, use the <code><a href="#topic+GetAnalysisTable">GetAnalysisTable</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetData(
  data,
  mode.slot = DefaultSlot(data),
  columns = NULL,
  genes = Genes(data),
  by.rows = FALSE,
  coldata = TRUE,
  ntr.na = TRUE,
  name.by = "Symbol"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetData_+3A_data">data</code></td>
<td>
<p>A grandR object</p>
</td></tr>
<tr><td><code id="GetData_+3A_mode.slot">mode.slot</code></td>
<td>
<p>Which kind of data to access (see details)</p>
</td></tr>
<tr><td><code id="GetData_+3A_columns">columns</code></td>
<td>
<p>A vector of columns (see details); all condition/cell names if NULL</p>
</td></tr>
<tr><td><code id="GetData_+3A_genes">genes</code></td>
<td>
<p>Restrict the output table to the given genes (this typically is a single gene, or very few genes)</p>
</td></tr>
<tr><td><code id="GetData_+3A_by.rows">by.rows</code></td>
<td>
<p>if TRUE, add rows if there are multiple genes / mode.slots; otherwise, additional columns are appended</p>
</td></tr>
<tr><td><code id="GetData_+3A_coldata">coldata</code></td>
<td>
<p>Should the table contain the <a href="#topic+Coldata">Coldata</a> values as well (at the beginning)?</p>
</td></tr>
<tr><td><code id="GetData_+3A_ntr.na">ntr.na</code></td>
<td>
<p>For columns representing a 4sU naive sample, should mode.slot <em>ntr</em>,<em>new.count</em> and <em>old.count</em> be 0,0 and count (ntr.na=FALSE; can be any other slot than count) or NA,NA and NA (ntr.na=TRUE)</p>
</td></tr>
<tr><td><code id="GetData_+3A_name.by">name.by</code></td>
<td>
<p>A column name of <a href="#topic+Coldata">Coldata</a>(data). This is used as the colnames of the output table</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To refer to data slots, the mode.slot syntax can be used: Each name is either a data slot, or one of (new,old,total) followed by a dot followed by a slot. For new or old, the data slot value is multiplied by ntr or 1-ntr. This can be used e.g. to obtain the <em>new counts</em>.
</p>
<p>If only one mode.slot and one gene is given, the output table contains one column (and potentially columns from <a href="#topic+Coldata">Coldata</a>) named <em>Value</em>. If one gene and multiple mode.slots are given, the columns are named according to the mode.slots. If one mode.slot and multiple genes are given, the columns are named according to the genes. If multiple genes and mode.slots are given, columns are named gene.mode.slot.
</p>
<p>If by.rows=TRUE, the table is molten such that each row contains only one value (for one of the genes and for one of the mode.slots). If only one gene and one mode.slot is given, melting does not have an effect.
</p>
<p>Columns can be given as a logical, integer or character vector representing a selection of the columns (samples or cells).
The expression is evaluated in an environment havin the <code><a href="#topic+Coldata">Coldata</a></code>, i.e. you can use names of <code><a href="#topic+Coldata">Coldata</a></code> as variables to
conveniently build a logical vector (e.g., columns=Condition==&quot;x&quot;).
</p>


<h3>Value</h3>

<p>A data frame containing the desired values
</p>


<h3>See Also</h3>

<p><a href="#topic+GetTable">GetTable</a>,<a href="#topic+GetAnalysisTable">GetAnalysisTable</a>,<a href="#topic+DefaultSlot">DefaultSlot</a>,<a href="#topic+Genes">Genes</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sars &lt;- ReadGRAND(system.file("extdata", "sars.tsv.gz", package = "grandR"),
                  design=c("Cell",Design$dur.4sU,Design$Replicate))
GetData(sars,mode.slot="ntr",gene="MYC")
# one gene, one mode.slot
GetData(sars,mode.slot=c("count","ntr"),gene="MYC",coldata = FALSE)
# one gene, multiple mode.slots
GetData(sars,mode.slot=c("count","ntr"),gene=c("SRSF6","MYC"),by.rows=TRUE)
# multiple genes, multiple mode.slots, by rows

</code></pre>

<hr>
<h2 id='GetDiagnosticParameters'>Describe parameters relevant to diagnostics</h2><span id='topic+GetDiagnosticParameters'></span>

<h3>Description</h3>

<p>Many of the diagnostics functions expect (optional or mandatory) parameters that are described by this function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetDiagnosticParameters(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetDiagnosticParameters_+3A_data">data</code></td>
<td>
<p>a grandR object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with
</p>

<ul>
<li><p>orientation: Sense or Antisense, only relevant to mismatches for strand unspecific data
</p>
</li>
<li><p>category: all available categories (Exonic/Intronic, genomes). Note that this might differ from what is available from GeneInfo(data,&quot;Category&quot;), since Grand3 might not have estimated NTRs for all categories!
</p>
</li>
<li><p>label: which nucleoside analogs have been used
</p>
</li>
<li><p>model: which model (binom or tbbinom) to inspect
</p>
</li>
<li><p>estimator: which estimator (joint or separate NTRs were estimated for subreads)
</p>
</li></ul>


<hr>
<h2 id='GetMatrix'>Obtain a genes x values table as a large matrix</h2><span id='topic+GetMatrix'></span>

<h3>Description</h3>

<p>This is the main function to access slot data for all genes as a (potentially sparse) matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetMatrix(
  data,
  mode.slot = DefaultSlot(data),
  columns = NULL,
  genes = Genes(data),
  name.by = "Symbol",
  summarize = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetMatrix_+3A_data">data</code></td>
<td>
<p>A grandR object</p>
</td></tr>
<tr><td><code id="GetMatrix_+3A_mode.slot">mode.slot</code></td>
<td>
<p>Which kind of data to access (see details)</p>
</td></tr>
<tr><td><code id="GetMatrix_+3A_columns">columns</code></td>
<td>
<p>which columns (i.e. samples or cells) to return (see details)</p>
</td></tr>
<tr><td><code id="GetMatrix_+3A_genes">genes</code></td>
<td>
<p>Restrict the output table to the given genes</p>
</td></tr>
<tr><td><code id="GetMatrix_+3A_name.by">name.by</code></td>
<td>
<p>A column name of <a href="#topic+Coldata">Coldata</a>(data). This is used as the rownames of the output table</p>
</td></tr>
<tr><td><code id="GetMatrix_+3A_summarize">summarize</code></td>
<td>
<p>Should replicates by summarized? see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To refer to data slots, the mode.slot syntax can be used: It is either a data slot, or one of (new,old,total) followed by a dot followed by a slot. For new or old, the data slot value is multiplied by ntr or 1-ntr. This can be used e.g. to obtain the <em>new counts</em>.
</p>
<p>Columns can be given as a logical, integer or character vector representing a selection of the columns (samples or cells).
The expression is evaluated in an environment havin the <code><a href="#topic+Coldata">Coldata</a></code>, i.e. you can use names of <code><a href="#topic+Coldata">Coldata</a></code> as variables to
conveniently build a logical vector (e.g., columns=Condition==&quot;x&quot;).
</p>
<p>The summarization parameter can only be specified if columns is NULL. It is either a summarization matrix (<a href="#topic+GetSummarizeMatrix">GetSummarizeMatrix</a>) or
TRUE (in which case <a href="#topic+GetSummarizeMatrix">GetSummarizeMatrix</a>(data) is called). If there a NA values, they are imputed as the mean per group!
</p>


<h3>Value</h3>

<p>A (potentially) sparse matrix containing the desired values
</p>


<h3>See Also</h3>

<p><a href="#topic+GetData">GetData</a>,<a href="#topic+GetAnalysisTable">GetAnalysisTable</a>,<a href="#topic+DefaultSlot">DefaultSlot</a>,<a href="#topic+Genes">Genes</a>,<a href="#topic+GetSummarizeMatrix">GetSummarizeMatrix</a>
</p>

<hr>
<h2 id='GetPairContrasts'>Create a contrast matrix for two given conditions</h2><span id='topic+GetPairContrasts'></span>

<h3>Description</h3>

<p>Each column of a contrast matrix represents a pairwise comparison of all samples or cells of
a grandR object (or a column annotation table). Elements being 1 are contrasted vs. elements being -1
(and all 0 are irrelevant for this comparison).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetPairContrasts(d, name, A, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetPairContrasts_+3A_d">d</code></td>
<td>
<p>A grandR object or a column annotation table</p>
</td></tr>
<tr><td><code id="GetPairContrasts_+3A_name">name</code></td>
<td>
<p>the name of the contrast</p>
</td></tr>
<tr><td><code id="GetPairContrasts_+3A_a">A</code></td>
<td>
<p>definition of the condition of interest, see details</p>
</td></tr>
<tr><td><code id="GetPairContrasts_+3A_b">B</code></td>
<td>
<p>definition of the reference condition , see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This creates a contrast A vs B (i.e. the fold change would be A/B)
</p>
<p>Columns that belong to A or B can be given as a logical, integer or character vector representing a selection of the columns (samples or cells).
The expression is evaluated in an environment having the <code><a href="#topic+Coldata">Coldata</a></code>, i.e. you can use names of <code><a href="#topic+Coldata">Coldata</a></code> as variables to
conveniently build a logical vector (e.g., columns=Condition=&quot;x&quot;).
</p>


<h3>Value</h3>

<p>A data frame with a single column representig a contrast matrix to be used in <code><a href="#topic+ApplyContrasts">ApplyContrasts</a></code>, <code><a href="#topic+LFC">LFC</a></code>, <code><a href="#topic+PairwiseDESeq2">PairwiseDESeq2</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ApplyContrasts">ApplyContrasts</a></code>, <code><a href="#topic+LFC">LFC</a></code>, <code><a href="#topic+PairwiseDESeq2">PairwiseDESeq2</a></code>, <code><a href="#topic+GetContrasts">GetContrasts</a></code>
</p>

<hr>
<h2 id='GetSignificantGenes'>Significant genes</h2><span id='topic+GetSignificantGenes'></span>

<h3>Description</h3>

<p>Return significant genes for this grandR object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetSignificantGenes(
  data,
  analysis = NULL,
  regex = TRUE,
  criteria = NULL,
  as.table = FALSE,
  use.symbols = TRUE,
  gene.info = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetSignificantGenes_+3A_data">data</code></td>
<td>
<p>the grandR object</p>
</td></tr>
<tr><td><code id="GetSignificantGenes_+3A_analysis">analysis</code></td>
<td>
<p>the analysis to use, can be more than one and can be regexes (see details)</p>
</td></tr>
<tr><td><code id="GetSignificantGenes_+3A_regex">regex</code></td>
<td>
<p>interpret analyses as regex?</p>
</td></tr>
<tr><td><code id="GetSignificantGenes_+3A_criteria">criteria</code></td>
<td>
<p>the criteria used to define what significant means; if NULL, Q&lt;0.05 &amp; abs(LFC)&gt;=1 is used; can use the column names of the analysis table as variables,  should be a logical or numerical value per gene (see Details)</p>
</td></tr>
<tr><td><code id="GetSignificantGenes_+3A_as.table">as.table</code></td>
<td>
<p>return a table</p>
</td></tr>
<tr><td><code id="GetSignificantGenes_+3A_use.symbols">use.symbols</code></td>
<td>
<p>return them as symbols (gene ids otherwise)</p>
</td></tr>
<tr><td><code id="GetSignificantGenes_+3A_gene.info">gene.info</code></td>
<td>
<p>add gene infos to the output table</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The analysis parameter (just like for <a href="#topic+GetAnalysisTable">GetAnalysisTable</a> can be a regex (that will be matched
against all available analysis names). It can also be a vector (of regexes). Be careful with this, if
more than one table e.g. with column LFC ends up in here, only the first is used (if criteria=LFC).
</p>
<p>The criteria parameter can be used to define how analyses are performed. If criteria is a logical,
it obtains significant genes defined by cut-offs (e.g. on q value and LFC).
If it is a numerical, all genes are returned sorted (descendingly) by this value.
The columns of the given analysis table(s) can be used to build this expression.
</p>


<h3>Value</h3>

<p>a vector of gene names (or symbols), or a table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sars &lt;- ReadGRAND(system.file("extdata", "sars.tsv.gz", package = "grandR"),
                  design=c(Design$Condition,Design$dur.4sU,Design$Replicate))
sars &lt;- subset(sars,Coldata(sars,Design$dur.4sU)==2)
sars&lt;-LFC(sars,mode="total",contrasts=GetContrasts(sars,contrast=c("Condition","Mock")))
GetSignificantGenes(sars,criteria=LFC&gt;1)

</code></pre>

<hr>
<h2 id='GetSummarizeMatrix'>Create a summarize matrix</h2><span id='topic+GetSummarizeMatrix'></span><span id='topic+GetSummarizeMatrix.grandR'></span><span id='topic+GetSummarizeMatrix.default'></span>

<h3>Description</h3>

<p>If this matrix is multiplied with a count table (e.g. obtained by <code><a href="#topic+GetTable">GetTable</a></code>),
either the average (average=TRUE) or the sum (average=FALSE) of all columns (samples or cells)
belonging to the same <code><a href="#topic+Condition">Condition</a></code> is computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetSummarizeMatrix(x, ...)

## S3 method for class 'grandR'
GetSummarizeMatrix(x, no4sU = FALSE, columns = NULL, average = TRUE, ...)

## Default S3 method:
GetSummarizeMatrix(x, subset = NULL, average = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetSummarizeMatrix_+3A_x">x</code></td>
<td>
<p>A grandR object or a named vector (the names indicate the sample names, the value the conditions to be summarized)</p>
</td></tr>
<tr><td><code id="GetSummarizeMatrix_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
<tr><td><code id="GetSummarizeMatrix_+3A_no4su">no4sU</code></td>
<td>
<p>Use no4sU columns (TRUE) or not (FALSE)</p>
</td></tr>
<tr><td><code id="GetSummarizeMatrix_+3A_columns">columns</code></td>
<td>
<p>which columns (i.e. samples or cells) to return (see details)</p>
</td></tr>
<tr><td><code id="GetSummarizeMatrix_+3A_average">average</code></td>
<td>
<p>matrix to compute the average (TRUE) or the sum (FALSE)</p>
</td></tr>
<tr><td><code id="GetSummarizeMatrix_+3A_subset">subset</code></td>
<td>
<p>logical vector of which elements of the vector v to use (or NULL: use all)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Columns can be given as a logical, integer or character vector representing a selection of the columns (samples or cells).
The expression is evaluated in an environment having the <code><a href="#topic+Coldata">Coldata</a></code>, i.e. you can use names of <code><a href="#topic+Coldata">Coldata</a></code> as variables to
conveniently build a logical vector (e.g., columns=Condition=&quot;x&quot;).
</p>
<p>The method for grandR object simply calls the general method
</p>


<h3>Value</h3>

<p>A matrix to be multiplied with a count table
</p>


<h3>See Also</h3>

<p><a href="#topic+GetTable">GetTable</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sars &lt;- ReadGRAND(system.file("extdata", "sars.tsv.gz", package = "grandR"),
                  design=c("Condition",Design$dur.4sU,Design$Replicate))

GetSummarizeMatrix(sars)
head(as.matrix(GetTable(sars)) %*% GetSummarizeMatrix(sars))   # average by matrix multiplication
head(GetTable(sars,summarize = TRUE))                          # shortcut, does the same

# See the data-matrices-and-analysis-results vignette for more examples!

</code></pre>

<hr>
<h2 id='GetTable'>Obtain a genes x values table</h2><span id='topic+GetTable'></span>

<h3>Description</h3>

<p>This is the main function to access slot data for all genes as a large matrix. If data from a particular gene (or a small set of genes)
must be retrieved, use the <code><a href="#topic+GetData">GetData</a></code> function. For analysis results, use the <code><a href="#topic+GetAnalysisTable">GetAnalysisTable</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetTable(
  data,
  type = DefaultSlot(data),
  columns = NULL,
  genes = Genes(data),
  ntr.na = TRUE,
  gene.info = FALSE,
  summarize = NULL,
  prefix = NULL,
  name.by = "Symbol"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetTable_+3A_data">data</code></td>
<td>
<p>A grandR object</p>
</td></tr>
<tr><td><code id="GetTable_+3A_type">type</code></td>
<td>
<p>Either a mode.slot (see details) or a regex to be matched against analysis names. Can also be a vector</p>
</td></tr>
<tr><td><code id="GetTable_+3A_columns">columns</code></td>
<td>
<p>A vector of columns (either condition/cell names if the type is a mode.slot, or names in the output table from an analysis; use <a href="#topic+Columns">Columns</a>(data,&lt;analysis&gt;) to learn which columns are available); all condition/cell names if NULL</p>
</td></tr>
<tr><td><code id="GetTable_+3A_genes">genes</code></td>
<td>
<p>Restrict the output table to the given genes</p>
</td></tr>
<tr><td><code id="GetTable_+3A_ntr.na">ntr.na</code></td>
<td>
<p>For columns representing a 4sU naive sample, should types <em>ntr</em>,<em>new.count</em> and <em>old.count</em> be 0,0 and count (ntr.na=FALSE; can be any other slot than count) or NA,NA and NA (ntr.na=TRUE)</p>
</td></tr>
<tr><td><code id="GetTable_+3A_gene.info">gene.info</code></td>
<td>
<p>Should the table contain the <a href="#topic+GeneInfo">GeneInfo</a> values as well (at the beginning)?</p>
</td></tr>
<tr><td><code id="GetTable_+3A_summarize">summarize</code></td>
<td>
<p>Should replicates by summarized? see details</p>
</td></tr>
<tr><td><code id="GetTable_+3A_prefix">prefix</code></td>
<td>
<p>Prepend each column in the output table (except for the gene.info columns) by the given prefix</p>
</td></tr>
<tr><td><code id="GetTable_+3A_name.by">name.by</code></td>
<td>
<p>A column name of <a href="#topic+Coldata">Coldata</a>(data). This is used as the rownames of the output table</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a convenience wrapper for <a href="#topic+GetData">GetData</a> (values from data slots) and <a href="#topic+GetAnalysisTable">GetAnalysisTable</a> (values from analyses).
Types can refer to any of the two (and can be mixed). If there are types from both data and analyses, columns must be NULL.
Otherwise columns must either be condition/cell names (if type refers to one or several data slots), or regular expressions
to match against the names in the analysis tables.
</p>
<p>Columns definitions for data slots can be given as a logical, integer or character vector representing a selection of the columns (samples or cells).
The expression is evaluated in an environment having the <code><a href="#topic+Coldata">Coldata</a></code>, i.e. you can use names of <code><a href="#topic+Coldata">Coldata</a></code> as variables to
conveniently build a logical vector (e.g., columns=Condition==&quot;x&quot;).
</p>
<p>To refer to data slots via <code>type</code>, the mode.slot syntax can be used: Each name is either a data slot, or one of (new,old,total)
followed by a dot followed by a slot. For new or old, the data slot value is multiplied by ntr or 1-ntr. This can be used e.g. to obtain the <em>new counts</em>.
</p>
<p>The summarization parameter can only be specified if columns is NULL. It is either a summarization matrix (<a href="#topic+GetSummarizeMatrix">GetSummarizeMatrix</a>) or
TRUE (in which case <a href="#topic+GetSummarizeMatrix">GetSummarizeMatrix</a>(data) is called). If there a NA values, they are imputed as the mean per group!
</p>


<h3>Value</h3>

<p>A data frame containing the desired values
</p>


<h3>See Also</h3>

<p><a href="#topic+GetData">GetData</a>,<a href="#topic+GetAnalysisTable">GetAnalysisTable</a>,<a href="#topic+DefaultSlot">DefaultSlot</a>,<a href="#topic+Genes">Genes</a>,<a href="#topic+GetSummarizeMatrix">GetSummarizeMatrix</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sars &lt;- ReadGRAND(system.file("extdata", "sars.tsv.gz", package = "grandR"),
                  design=c("Condition",Design$dur.4sU,Design$Replicate))
sars &lt;- Normalize(FilterGenes(sars))

head(GetTable(sars))
# DefaultSlot values, i.e. size factor normalized read counts for all samples
head(GetTable(sars,summarize=TRUE))
# DefaultSlot values averaged over the two conditions
head(GetTable(sars,type="new.count",columns=!no4sU))
# Estimated counts for new RNA for all samples with 4sU

sars&lt;-LFC(sars,contrasts=GetContrasts(sars,group = "duration.4sU"))
head(GetAnalysisTable(sars,columns="LFC"))
# Estimated fold changes SARS vs Mock for each time point



</code></pre>

<hr>
<h2 id='grandR'>Create a grandR object and retrieve basic information</h2><span id='topic+grandR'></span><span id='topic+Title'></span><span id='topic+IsSparse'></span><span id='topic+dim.grandR'></span><span id='topic+is.grandR'></span><span id='topic+dimnames.grandR'></span><span id='topic+print.grandR'></span><span id='topic+Metadata'></span><span id='topic+subset.grandR'></span><span id='topic+split.grandR'></span><span id='topic+RenameColumns'></span><span id='topic+SwapColumns'></span><span id='topic+merge.grandR'></span>

<h3>Description</h3>

<p>The grandR object contains
</p>

<ul>
<li><p>metadata about the origin (file/url) of the GRAND-SLAM output
</p>
</li>
<li><p>the current state (e.g., what is the current default slot) of the grandR object
</p>
</li>
<li><p>a gene info table (i.e. metadata for the rows of the data matrices)
</p>
</li>
<li><p>a column annotation table (i.e. metadata for the columns of the data matrices)
</p>
</li>
<li><p>several data matrices for read counts, normalized expression values, NTRs, etc. (genes x samples or genes x cells; stored in so-called <em>slots</em>)
</p>
</li>
<li><p>potentially several analysis output tables (for kinetic modeling, differential gene expression testing)
</p>
</li></ul>

<p>Usually, this constructor is not invoked directly (but by <code><a href="#topic+ReadGRAND">ReadGRAND</a></code> or <code><a href="#topic+SimulateTimeCourse">SimulateTimeCourse</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grandR(
  prefix = parent$prefix,
  gene.info = parent$gene.info,
  slots = parent$data,
  coldata = parent$coldata,
  metadata = parent$metadata,
  analyses = NULL,
  plots = NULL,
  parent = NULL
)

Title(data)

IsSparse(data)

## S3 method for class 'grandR'
dim(x)

is.grandR(x)

## S3 method for class 'grandR'
dimnames(x)

## S3 method for class 'grandR'
print(x, ...)

Metadata(x, ...)

## S3 method for class 'grandR'
subset(x, columns, reorder = TRUE, ...)

## S3 method for class 'grandR'
split(x, f = Design$Condition, drop = FALSE, ...)

RenameColumns(data, map = NULL, fun = NULL)

SwapColumns(data, s1, s2)

## S3 method for class 'grandR'
merge(..., list = NULL, column.name = Design$Origin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grandR_+3A_prefix">prefix</code></td>
<td>
<p>Can either be the prefix used to call GRAND-SLAM with, or the main output file ($prefix.tsv.gz);
if the RCurl package is installed, this can also be a URL</p>
</td></tr>
<tr><td><code id="grandR_+3A_gene.info">gene.info</code></td>
<td>
<p>a data frame with metadata for all genes</p>
</td></tr>
<tr><td><code id="grandR_+3A_slots">slots</code></td>
<td>
<p>A list of matrices representing the slots</p>
</td></tr>
<tr><td><code id="grandR_+3A_coldata">coldata</code></td>
<td>
<p>a data frame with metadata for all samples (or cells)</p>
</td></tr>
<tr><td><code id="grandR_+3A_metadata">metadata</code></td>
<td>
<p>a metadata list</p>
</td></tr>
<tr><td><code id="grandR_+3A_analyses">analyses</code></td>
<td>
<p>the analyses list</p>
</td></tr>
<tr><td><code id="grandR_+3A_plots">plots</code></td>
<td>
<p>the plots list</p>
</td></tr>
<tr><td><code id="grandR_+3A_parent">parent</code></td>
<td>
<p>A parent object containing default values for all other parameters (i.e. all parameters not specified are obtained from this object)</p>
</td></tr>
<tr><td><code id="grandR_+3A_data">data</code>, <code id="grandR_+3A_x">x</code></td>
<td>
<p>a grandR object</p>
</td></tr>
<tr><td><code id="grandR_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
<tr><td><code id="grandR_+3A_columns">columns</code></td>
<td>
<p>which columns (i.e. samples or cells) to return (see details)</p>
</td></tr>
<tr><td><code id="grandR_+3A_reorder">reorder</code></td>
<td>
<p>reorder all factors in coldata (if columns for subset define a different order)</p>
</td></tr>
<tr><td><code id="grandR_+3A_f">f</code></td>
<td>
<p>The name of the annotation table according to which the object is split or the new annotation table column name denoting the origin after merging</p>
</td></tr>
<tr><td><code id="grandR_+3A_drop">drop</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="grandR_+3A_map">map</code></td>
<td>
<p>named list or vector representing a lookup table (names are current column names)</p>
</td></tr>
<tr><td><code id="grandR_+3A_fun">fun</code></td>
<td>
<p>a function that maps a vector of names to a new vector of names</p>
</td></tr>
<tr><td><code id="grandR_+3A_s1">s1</code>, <code id="grandR_+3A_s2">s2</code></td>
<td>
<p>column names</p>
</td></tr>
<tr><td><code id="grandR_+3A_list">list</code></td>
<td>
<p>a list of grandR objects</p>
</td></tr>
<tr><td><code id="grandR_+3A_column.name">column.name</code></td>
<td>
<p>a new name for the Coldata table to annotate the merged objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dimensions (nrow, ncol) of the grandR object are considered to be the dimensions of the data tables,
i.e. <code>nrow(data)</code> provides the number of genes and <code>ncol(data)</code> the number of samples (or cells).
</p>
<p>Currently, the object is implemented as a list of the above mentioned items. This implementation is subject to change.
Make sure to use accessor functions to obtain the information you want.
</p>
<p>Columns can be given as a logical, integer or character vector representing a selection of the columns (samples or cells).
The expression is evaluated in an environment havin the <code><a href="#topic+Coldata">Coldata</a></code>, i.e. you can use names of <code><a href="#topic+Coldata">Coldata</a></code> as variables to
conveniently build a logical vector (e.g., columns=Condition==&quot;x&quot;).
</p>


<h3>Value</h3>

<p>A grandR object containing the read counts, NTRs, information on the NTR posterior distribution (alpha,beta)
and potentially additional information of all genes detected by GRAND-SLAM
</p>


<h3>Functions</h3>


<dl>
<dt>Title</dt><dd><p>Obtain a useful title for the project (from the prefix parameter)</p>
</dd>
<dt>dim</dt><dd><p>Obtain the dimensions (genes x samples or genes x cells)</p>
</dd>
<dt>is</dt><dd><p>Check whether it is a grandR object</p>
</dd>
<dt>dimnames</dt><dd><p>Obtain the row and column names of this object (genes x samples or genes x cells)</p>
</dd>
<dt>print</dt><dd><p>Print information on this grandR object</p>
</dd>
<dt>subset</dt><dd><p>Create a new grandR object with a subset of the columns (use <code><a href="#topic+FilterGenes">FilterGenes</a></code> to subset on genes)</p>
</dd>
<dt>split</dt><dd><p>Split the grandR object into a list of multiple grandR objects (according to the levels of an annotation table column)</p>
</dd>
<dt>RenameColumns</dt><dd><p>Rename the column names according to a lookup table (map) or a function (invoked on the current names)</p>
</dd>
<dt>SwapColumns</dt><dd><p>Swap two columns (samples or cells); this is what you do if samples were mislabeled!</p>
</dd>
<dt>Metadata</dt><dd><p>Obtain global metadata</p>
</dd>
<dt>merge</dt><dd><p>Merge several grandR objects into one</p>
</dd>
</dl>



<h3>See Also</h3>

<p><a href="#topic+Slots">Slots</a>, <a href="#topic+DefaultSlot">DefaultSlot</a>, <a href="#topic+Genes">Genes</a>, <a href="#topic+GeneInfo">GeneInfo</a>, <a href="#topic+Coldata">Coldata</a>, <a href="#topic+GetTable">GetTable</a>, <a href="#topic+GetData">GetData</a>, <a href="#topic+Analyses">Analyses</a>, <a href="#topic+GetAnalysisTable">GetAnalysisTable</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sars &lt;- ReadGRAND(system.file("extdata", "sars.tsv.gz", package = "grandR"),
                  design=c("Cell",Design$dur.4sU,Design$Replicate))
# this is part of the corona data from Finkel et al.
dim(sars)
head(rownames(sars))

</code></pre>

<hr>
<h2 id='IsParallel'>Checks for parallel execution</h2><span id='topic+IsParallel'></span>

<h3>Description</h3>

<p>Checks for parallel execution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IsParallel()
</code></pre>


<h3>Value</h3>

<p>whether or not parallelism is activated
</p>

<hr>
<h2 id='LFC'>Estimation of log2 fold changes</h2><span id='topic+LFC'></span>

<h3>Description</h3>

<p>Estimate the log fold changes based on a contrast matrix, requires the LFC package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LFC(
  data,
  name.prefix = mode,
  contrasts,
  slot = "count",
  LFC.fun = lfc::PsiLFC,
  mode = "total",
  normalization = NULL,
  compute.M = TRUE,
  genes = NULL,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LFC_+3A_data">data</code></td>
<td>
<p>the grandR object</p>
</td></tr>
<tr><td><code id="LFC_+3A_name.prefix">name.prefix</code></td>
<td>
<p>the prefix for the new analysis name; a dot and the column names of the contrast matrix are appended; can be NULL (then only the contrast matrix names are used)</p>
</td></tr>
<tr><td><code id="LFC_+3A_contrasts">contrasts</code></td>
<td>
<p>contrast matrix that defines all pairwise comparisons, generated using <a href="#topic+GetContrasts">GetContrasts</a></p>
</td></tr>
<tr><td><code id="LFC_+3A_slot">slot</code></td>
<td>
<p>the slot of the grandR object to take the data from; for <a href="lfc.html#topic+PsiLFC">PsiLFC</a>, this really should be &quot;count&quot;!</p>
</td></tr>
<tr><td><code id="LFC_+3A_lfc.fun">LFC.fun</code></td>
<td>
<p>function to compute log fold changes (default: <a href="lfc.html#topic+PsiLFC">PsiLFC</a>, other viable option: <a href="lfc.html#topic+NormLFC">NormLFC</a>)</p>
</td></tr>
<tr><td><code id="LFC_+3A_mode">mode</code></td>
<td>
<p>compute LFCs for &quot;total&quot;, &quot;new&quot;, or &quot;old&quot; RNA</p>
</td></tr>
<tr><td><code id="LFC_+3A_normalization">normalization</code></td>
<td>
<p>normalize on &quot;total&quot;, &quot;new&quot;, or &quot;old&quot; (see details)</p>
</td></tr>
<tr><td><code id="LFC_+3A_compute.m">compute.M</code></td>
<td>
<p>also compute the mean expression (in log10 space)</p>
</td></tr>
<tr><td><code id="LFC_+3A_genes">genes</code></td>
<td>
<p>restrict analysis to these genes; NULL means all genes</p>
</td></tr>
<tr><td><code id="LFC_+3A_verbose">verbose</code></td>
<td>
<p>print status messages?</p>
</td></tr>
<tr><td><code id="LFC_+3A_...">...</code></td>
<td>
<p>further arguments forwarded to LFC.fun</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both <a href="lfc.html#topic+PsiLFC">PsiLFC</a> and  <a href="lfc.html#topic+NormLFC">NormLFC</a>) by default perform normalization by subtracting the median log2 fold change from all log2 fold changes.
When computing LFCs of new RNA, it might be sensible to normalize w.r.t. to total RNA, i.e. subtract the median log2 fold change of total RNA from all the log2 fold change of new RNA.
This can be accomplished by setting mode to &quot;new&quot;, and normalization to &quot;total&quot;!
</p>
<p>Normalization can also be a mode.slot! Importantly, do not specify a slot containing normalized values, but specify a slot of unnormalized values
(which are used to compute the size factors for normalization!) Can also be a numeric vector of size factors with the same length as the data as columns.
Then each value is divided by the corresponding size factor entry.
</p>


<h3>Value</h3>

<p>a new grandR object including a new analysis table. The columns of the new analysis table are
</p>
<table>
<tr><td><code>"LFC"</code></td>
<td>
<p>the log2 fold change</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+PairwiseDESeq2">PairwiseDESeq2</a>,<a href="#topic+GetContrasts">GetContrasts</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sars &lt;- ReadGRAND(system.file("extdata", "sars.tsv.gz", package = "grandR"),
                  design=c(Design$Condition,Design$dur.4sU,Design$Replicate))
sars &lt;- subset(sars,Coldata(sars,Design$dur.4sU)==2)
sars&lt;-LFC(sars,mode="total",contrasts=GetContrasts(sars,contrast=c("Condition","Mock")))
sars&lt;-LFC(sars,mode="new",normalization="total",
                            contrasts=GetContrasts(sars,contrast=c("Condition","Mock")))
head(GetAnalysisTable(sars))

</code></pre>

<hr>
<h2 id='LikelihoodRatioTest'>Compute a likelihood ratio test.</h2><span id='topic+LikelihoodRatioTest'></span>

<h3>Description</h3>

<p>The test is computed on any of total/old/new counts using DESeq2 based on two nested models
specified using formulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LikelihoodRatioTest(
  data,
  name = "LRT",
  mode = "total",
  slot = "count",
  normalization = mode,
  target = ~Condition,
  background = ~1,
  columns = NULL,
  logFC = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LikelihoodRatioTest_+3A_data">data</code></td>
<td>
<p>A grandR object</p>
</td></tr>
<tr><td><code id="LikelihoodRatioTest_+3A_name">name</code></td>
<td>
<p>the user defined analysis name to store the results</p>
</td></tr>
<tr><td><code id="LikelihoodRatioTest_+3A_mode">mode</code></td>
<td>
<p>either &quot;total&quot;, &quot;new&quot; or &quot;old&quot;</p>
</td></tr>
<tr><td><code id="LikelihoodRatioTest_+3A_slot">slot</code></td>
<td>
<p>which slot to use (should be a count slot, not normalized values)</p>
</td></tr>
<tr><td><code id="LikelihoodRatioTest_+3A_normalization">normalization</code></td>
<td>
<p>normalize on &quot;total&quot;, &quot;new&quot;, or &quot;old&quot; (see details)</p>
</td></tr>
<tr><td><code id="LikelihoodRatioTest_+3A_target">target</code></td>
<td>
<p>formula specifying the target model (you can use any column name from the <code><a href="#topic+Coldata">Coldata</a>(data)</code>)</p>
</td></tr>
<tr><td><code id="LikelihoodRatioTest_+3A_background">background</code></td>
<td>
<p>formula specifying the background model (you can use any column name from the <code><a href="#topic+Coldata">Coldata</a>(data)</code>)</p>
</td></tr>
<tr><td><code id="LikelihoodRatioTest_+3A_columns">columns</code></td>
<td>
<p>logical vector of which columns (samples or cells) to use (or NULL: use all)</p>
</td></tr>
<tr><td><code id="LikelihoodRatioTest_+3A_logfc">logFC</code></td>
<td>
<p>compute and add the log2 fold change as well</p>
</td></tr>
<tr><td><code id="LikelihoodRatioTest_+3A_verbose">verbose</code></td>
<td>
<p>Print status updates</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a convenience wrapper around the likelihood ratio test implemented in DESeq2.
</p>
<p>DESeq2 by default performs size factor normalization. When computing differential expression of new RNA,
it might be sensible to normalize w.r.t. to total RNA, i.e. use the size factors computed from total RNA instead of computed from new RNA.
This can be accomplished by setting mode to &quot;new&quot;, and normalization to &quot;total&quot;!
</p>


<h3>Value</h3>

<p>a new grandR object including a new analysis table. The columns of the new analysis table are
</p>
<table>
<tr><td><code>"M"</code></td>
<td>
<p>the base mean</p>
</td></tr>
<tr><td><code>"S"</code></td>
<td>
<p>the difference in deviance between the reduced model and the full model</p>
</td></tr>
<tr><td><code>"P"</code></td>
<td>
<p>the likelihood ratio test P value</p>
</td></tr>
<tr><td><code>"Q"</code></td>
<td>
<p>same as P but Benjamini-Hochberg multiple testing corrected</p>
</td></tr>
<tr><td><code>"LFC"</code></td>
<td>
<p>the log2 fold change for the target model (only with the logFC parameter set to TRUE)</p>
</td></tr>
</table>

<hr>
<h2 id='ListGeneSets'>List available gene sets</h2><span id='topic+ListGeneSets'></span>

<h3>Description</h3>

<p>Helper function to return a table with all available gene sets for <a href="#topic+AnalyzeGeneSets">AnalyzeGeneSets</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ListGeneSets()
</code></pre>


<h3>Details</h3>

<p>This is a convenience wrapper for <a href="msigdbr.html#topic+msigdbr_collections">msigdbr_collections</a>.
</p>


<h3>Value</h3>

<p>the gene set table; use the values in the category and subcategory columns for the corresponding parameters of <a href="#topic+AnalyzeGeneSets">AnalyzeGeneSets</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+AnalyzeGeneSets">AnalyzeGeneSets</a>
</p>

<hr>
<h2 id='MakeColdata'>Extract an annotation table from a formatted names vector</h2><span id='topic+MakeColdata'></span>

<h3>Description</h3>

<p>If columns (i.e. sample or cell) follow a specific naming pattern, this can be used to conveniently set up an annotation table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeColdata(
  names,
  design,
  semantics = DesignSemantics(),
  rownames = TRUE,
  keep.originals = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MakeColdata_+3A_names">names</code></td>
<td>
<p>Formatted names vector (see details)</p>
</td></tr>
<tr><td><code id="MakeColdata_+3A_design">design</code></td>
<td>
<p>Titles for the columns of the annotation table</p>
</td></tr>
<tr><td><code id="MakeColdata_+3A_semantics">semantics</code></td>
<td>
<p>Additional semantics to apply to given annotations (see details)</p>
</td></tr>
<tr><td><code id="MakeColdata_+3A_rownames">rownames</code></td>
<td>
<p>Add rownames to the annotation table</p>
</td></tr>
<tr><td><code id="MakeColdata_+3A_keep.originals">keep.originals</code></td>
<td>
<p>To not discard the original values for all annotations where semantics were applied</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The names have to contain dots (.) to separate the fields for the column annotation table.
E.g. the name <em>Mock.4h.A</em> will be split into the fields <em>Mock</em>, <em>4h</em> and  <em>A</em>.
For such names, a design vector of length 3 has to be given, that describes the meaning of each field.
A reasonable design vector for the example would be <code>c("Treatment","Time","Replicate")</code>.
Some names are predefined in the list <a href="#topic+Design">Design</a>.
</p>
<p>The names given in the design vector might even have additional semantics:
E.g. for the name <em>duration.4sU</em> the values are interpreted (e.g. 4h is converted into the number 4, or 30min into 0.5, or no4sU into 0).
</p>
<p>Semantics can be user-defined via the <em>semantics</em> list:
For each name in the design vector matching to a name in this list, the corresponding function in the list is run.
Functions must accept 2 parameters, the first is the original column in the annotation table, the second the original name.
The function must return a data.frame with the number of rows matching to the annotation table.
In most cases it is easier to manipulate the returned data frame instead of changing the semantics.
However, the build-in semantics provide a convenient way to reduce this kind of manipulation in most cases.
</p>


<h3>Value</h3>

<p>A data frame representing the annotation table
</p>


<h3>See Also</h3>

<p><a href="#topic+ReadGRAND">ReadGRAND</a>,<a href="#topic+DesignSemantics">DesignSemantics</a>,<a href="#topic+Coldata">Coldata</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coldata &lt;- MakeColdata(c("Mock.0h.A","Mock.0h.B","Mock.2h.A","Mock.2h.B"),
                                   design=c("Cell",Design$dur.4sU,Design$Replicate))

</code></pre>

<hr>
<h2 id='MAPlot'>Make an MA plot</h2><span id='topic+MAPlot'></span>

<h3>Description</h3>

<p>Plot average expression vs. log2 fold changes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MAPlot(
  data,
  analysis = Analyses(data)[1],
  aest = aes(),
  p.cutoff = 0.05,
  lfc.cutoff = 1,
  label.numbers = TRUE,
  highlight = NULL,
  label = NULL,
  label.repel = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MAPlot_+3A_data">data</code></td>
<td>
<p>the grandR object that contains the data to be plotted</p>
</td></tr>
<tr><td><code id="MAPlot_+3A_analysis">analysis</code></td>
<td>
<p>the analysis to plot (default: first analysis)</p>
</td></tr>
<tr><td><code id="MAPlot_+3A_aest">aest</code></td>
<td>
<p>parameter to set visual attributes of the plot</p>
</td></tr>
<tr><td><code id="MAPlot_+3A_p.cutoff">p.cutoff</code></td>
<td>
<p>p-value cutoff (default: 0.05)</p>
</td></tr>
<tr><td><code id="MAPlot_+3A_lfc.cutoff">lfc.cutoff</code></td>
<td>
<p>log fold change cutoff (default: 1)</p>
</td></tr>
<tr><td><code id="MAPlot_+3A_label.numbers">label.numbers</code></td>
<td>
<p>if TRUE, label the number of genes</p>
</td></tr>
<tr><td><code id="MAPlot_+3A_highlight">highlight</code></td>
<td>
<p>highlight these genes; can be either numeric indices, gene names, gene symbols or a logical vector (see details)</p>
</td></tr>
<tr><td><code id="MAPlot_+3A_label">label</code></td>
<td>
<p>label these genes; can be either numeric indices, gene names, gene symbols or a logical vector (see details)</p>
</td></tr>
<tr><td><code id="MAPlot_+3A_label.repel">label.repel</code></td>
<td>
<p>force to repel labels from points and each other (increase if labels overlap)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>

<hr>
<h2 id='Normalize'>Normalization</h2><span id='topic+Normalize'></span><span id='topic+NormalizeFPKM'></span><span id='topic+NormalizeRPM'></span><span id='topic+NormalizeTPM'></span>

<h3>Description</h3>

<p>Normalizes data in a grandR object and puts the normalized data into a new slot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Normalize(
  data,
  genes = Genes(data),
  name = "norm",
  slot = "count",
  set.to.default = TRUE,
  size.factors = NULL,
  return.sf = FALSE
)

NormalizeFPKM(
  data,
  genes = Genes(data),
  name = "fpkm",
  slot = "count",
  set.to.default = TRUE,
  tlen = GeneInfo(data, "Length")
)

NormalizeRPM(
  data,
  genes = Genes(data),
  name = "rpm",
  slot = "count",
  set.to.default = TRUE,
  factor = 1e+06
)

NormalizeTPM(
  data,
  genes = Genes(data),
  name = "tpm",
  slot = "count",
  set.to.default = TRUE,
  tlen = GeneInfo(data, "Length")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Normalize_+3A_data">data</code></td>
<td>
<p>the grandR object</p>
</td></tr>
<tr><td><code id="Normalize_+3A_genes">genes</code></td>
<td>
<p>compute the normalization w.r.t. these genes (see details)</p>
</td></tr>
<tr><td><code id="Normalize_+3A_name">name</code></td>
<td>
<p>the name of the new slot for the normalized data</p>
</td></tr>
<tr><td><code id="Normalize_+3A_slot">slot</code></td>
<td>
<p>the name of the slot for the data to normalize</p>
</td></tr>
<tr><td><code id="Normalize_+3A_set.to.default">set.to.default</code></td>
<td>
<p>set the new slot as the default slot</p>
</td></tr>
<tr><td><code id="Normalize_+3A_size.factors">size.factors</code></td>
<td>
<p>numeric vector; if not NULL, use these size factors instead of computing size factors</p>
</td></tr>
<tr><td><code id="Normalize_+3A_return.sf">return.sf</code></td>
<td>
<p>return the size factors and not a grandR object</p>
</td></tr>
<tr><td><code id="Normalize_+3A_tlen">tlen</code></td>
<td>
<p>the transcript lengths (for FPKM and TPM)</p>
</td></tr>
<tr><td><code id="Normalize_+3A_factor">factor</code></td>
<td>
<p>the rpm factor (default: 1 (m)illion)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Normalize will perform DESeq2 normalization, i.e. it will use <a href="DESeq2.html#topic+estimateSizeFactorsForMatrix">estimateSizeFactorsForMatrix</a>
to estimate size factors, and divide each value by this. If genes are given, size factors will be computed only w.r.t. these genes (but then all genes are normalized).
</p>
<p>NormalizeFPKM will compute fragments per kilobase and million mapped reads. If genes are given, the scaling factor
will only be computed w.r.t. these genes (but then all genes are normalized).
</p>
<p>NormalizeRPM will compute reads per million mapped reads. If genes are given, the scaling factor
will only be computed w.r.t. these genes (but then all genes are normalized).
</p>
<p>NormalizeTPM will compute transcripts per million mapped reads. If genes are given, the scaling factor
will only be computed w.r.t. these genes (but then all genes are normalized).
</p>
<p>Genes can be referred to by their names, symbols, row numbers in the gene table, or a logical vector referring to the gene table rows.
</p>


<h3>Value</h3>

<p>a new grandR object with a new data slot
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NormalizeBaseline">NormalizeBaseline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sars &lt;- ReadGRAND(system.file("extdata", "sars.tsv.gz", package = "grandR"),
                  design=c("Cell",Design$dur.4sU,Design$Replicate))

sars &lt;- Normalize(sars)
DefaultSlot(sars)
</code></pre>

<hr>
<h2 id='NormalizeBaseline'>Normalization to a baseline</h2><span id='topic+NormalizeBaseline'></span>

<h3>Description</h3>

<p>Normalizes data in a grandR object to a baseline and puts the normalized data into a new slot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NormalizeBaseline(
  data,
  baseline = FindReferences(data, reference = Condition == levels(Condition)[1]),
  name = "baseline",
  slot = DefaultSlot(data),
  set.to.default = FALSE,
  LFC.fun = lfc::PsiLFC,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NormalizeBaseline_+3A_data">data</code></td>
<td>
<p>the grandR object</p>
</td></tr>
<tr><td><code id="NormalizeBaseline_+3A_baseline">baseline</code></td>
<td>
<p>matrix defining the corresponding baseline (row) for each column (sample or cell; see details)</p>
</td></tr>
<tr><td><code id="NormalizeBaseline_+3A_name">name</code></td>
<td>
<p>the name of the new slot for the normalized data</p>
</td></tr>
<tr><td><code id="NormalizeBaseline_+3A_slot">slot</code></td>
<td>
<p>the name of the slot for the data to normalize</p>
</td></tr>
<tr><td><code id="NormalizeBaseline_+3A_set.to.default">set.to.default</code></td>
<td>
<p>set the new slot as the default slot</p>
</td></tr>
<tr><td><code id="NormalizeBaseline_+3A_lfc.fun">LFC.fun</code></td>
<td>
<p>either <a href="lfc.html#topic+NormLFC">NormLFC</a> or <a href="lfc.html#topic+PsiLFC">PsiLFC</a> from the lfc package</p>
</td></tr>
<tr><td><code id="NormalizeBaseline_+3A_...">...</code></td>
<td>
<p>forwarded to LFC.fun</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Baseline normalization computes the log2 fold change for a column (i.e. sample or cell) to a baseline columns (or several baseline columns). This is by default done using the
<code><a href="lfc.html#topic+PsiLFC">PsiLFC</a></code> function from the lfc package, which, by default, also normalizes log2 fold changes by adding a constant
such that the median is zero.
</p>
<p>Baselines are defined by a square logical matrix, defining for each sample or cell of the grandR object, represented by the column of the matrix,
which samples or cells are indeed the baseline (represented by the rows). Such matrices can conveniently be obtained by <code><a href="#topic+FindReferences">FindReferences</a></code>.
</p>


<h3>Value</h3>

<p>a new grandR object with an additional slot
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Normalize">Normalize</a></code>,<code><a href="#topic+FindReferences">FindReferences</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sars &lt;- ReadGRAND(system.file("extdata", "sars.tsv.gz", package = "grandR"),
                  design=c("Cell",Design$dur.4sU,Design$Replicate))
blmat &lt;- FindReferences(sars,reference = duration.4sU==0, group = "Cell")
# the Mock.no4sU or SARS.no4sU sample are the baselines for each sample
sars &lt;- NormalizeBaseline(sars,baseline=blmat)
head(GetTable(sars,type="baseline"))
</code></pre>

<hr>
<h2 id='Pairwise'>Log2 fold changes and Wald tests for differential expression</h2><span id='topic+Pairwise'></span>

<h3>Description</h3>

<p>This function is a shortcut for first calling <a href="#topic+PairwiseDESeq2">PairwiseDESeq2</a> and then <a href="#topic+LFC">LFC</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pairwise(
  data,
  name.prefix = mode,
  contrasts,
  LFC.fun = lfc::PsiLFC,
  slot = "count",
  mode = "total",
  normalization = mode,
  genes = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pairwise_+3A_data">data</code></td>
<td>
<p>the grandR object</p>
</td></tr>
<tr><td><code id="Pairwise_+3A_name.prefix">name.prefix</code></td>
<td>
<p>the prefix for the new analysis name; a dot and the column names of the contrast matrix are appended; can be NULL (then only the contrast matrix names are used)</p>
</td></tr>
<tr><td><code id="Pairwise_+3A_contrasts">contrasts</code></td>
<td>
<p>contrast matrix that defines all pairwise comparisons, generated using <a href="#topic+GetContrasts">GetContrasts</a></p>
</td></tr>
<tr><td><code id="Pairwise_+3A_lfc.fun">LFC.fun</code></td>
<td>
<p>function to compute log fold changes (default: <a href="lfc.html#topic+PsiLFC">PsiLFC</a>, other viable option: <a href="lfc.html#topic+NormLFC">NormLFC</a>)</p>
</td></tr>
<tr><td><code id="Pairwise_+3A_slot">slot</code></td>
<td>
<p>the slot of the grandR object to take the data from; should contain counts!</p>
</td></tr>
<tr><td><code id="Pairwise_+3A_mode">mode</code></td>
<td>
<p>compute LFCs for &quot;total&quot;, &quot;new&quot;, or &quot;old&quot; RNA</p>
</td></tr>
<tr><td><code id="Pairwise_+3A_normalization">normalization</code></td>
<td>
<p>normalize on &quot;total&quot;, &quot;new&quot;, or &quot;old&quot; (see details)</p>
</td></tr>
<tr><td><code id="Pairwise_+3A_genes">genes</code></td>
<td>
<p>restrict analysis to these genes; NULL means all genes</p>
</td></tr>
<tr><td><code id="Pairwise_+3A_verbose">verbose</code></td>
<td>
<p>print status messages?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both <a href="lfc.html#topic+PsiLFC">PsiLFC</a> and  <a href="lfc.html#topic+NormLFC">NormLFC</a>) by default perform normalization by subtracting the median log2 fold change from all log2 fold changes.
When computing LFCs of new RNA, it might be sensible to normalize w.r.t. to total RNA, i.e. subtract the median log2 fold change of total RNA from all the log2 fold change of new RNA.
This can be accomplished by setting mode to &quot;new&quot;, and normalization to &quot;total&quot;!
</p>
<p>Normalization can also be a mode.slot! Importantly, do not specify a slot containing normalized values, but specify a slot of unnormalized values
(which are used to compute the size factors for normalization!) Can also be a numeric vector of size factors with the same length as the data as columns.
Then each value is divided by the corresponding size factor entry.
</p>


<h3>Value</h3>

<p>a new grandR object including a new analysis table. The columns of the new analysis table are
</p>
<table>
<tr><td><code>"M"</code></td>
<td>
<p>the base mean</p>
</td></tr>
<tr><td><code>"S"</code></td>
<td>
<p>the log2FoldChange divided by lfcSE</p>
</td></tr>
<tr><td><code>"P"</code></td>
<td>
<p>the Wald test P value</p>
</td></tr>
<tr><td><code>"Q"</code></td>
<td>
<p>same as P but Benjamini-Hochberg multiple testing corrected</p>
</td></tr>
<tr><td><code>"LFC"</code></td>
<td>
<p>the log2 fold change</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+PairwiseDESeq2">PairwiseDESeq2</a>,<a href="#topic+GetContrasts">GetContrasts</a>
</p>

<hr>
<h2 id='PairwiseDESeq2'>Perform Wald tests for differential expression</h2><span id='topic+PairwiseDESeq2'></span>

<h3>Description</h3>

<p>Apply DESeq2 for comparisons defined in a contrast matrix, requires the DESeq2 package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PairwiseDESeq2(
  data,
  name.prefix = mode,
  contrasts,
  separate = FALSE,
  mode = "total",
  slot = "count",
  normalization = NULL,
  logFC = FALSE,
  genes = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PairwiseDESeq2_+3A_data">data</code></td>
<td>
<p>the grandR object</p>
</td></tr>
<tr><td><code id="PairwiseDESeq2_+3A_name.prefix">name.prefix</code></td>
<td>
<p>the prefix for the new analysis name; a dot and the column names of the contrast matrix are appended; can be NULL (then only the contrast matrix names are used)</p>
</td></tr>
<tr><td><code id="PairwiseDESeq2_+3A_contrasts">contrasts</code></td>
<td>
<p>contrast matrix that defines all pairwise comparisons, generated using <a href="#topic+GetContrasts">GetContrasts</a></p>
</td></tr>
<tr><td><code id="PairwiseDESeq2_+3A_separate">separate</code></td>
<td>
<p>model overdispersion separately for all pairwise comparison (TRUE), or fit a single model per gene, and extract contrasts (FALSE)</p>
</td></tr>
<tr><td><code id="PairwiseDESeq2_+3A_mode">mode</code></td>
<td>
<p>compute LFCs for &quot;total&quot;, &quot;new&quot;, or &quot;old&quot; RNA</p>
</td></tr>
<tr><td><code id="PairwiseDESeq2_+3A_slot">slot</code></td>
<td>
<p>which slot to use (should be a count slot, not normalized values)</p>
</td></tr>
<tr><td><code id="PairwiseDESeq2_+3A_normalization">normalization</code></td>
<td>
<p>normalize on &quot;total&quot;, &quot;new&quot;, or &quot;old&quot; (see details)</p>
</td></tr>
<tr><td><code id="PairwiseDESeq2_+3A_logfc">logFC</code></td>
<td>
<p>compute and add the log2 fold change as well</p>
</td></tr>
<tr><td><code id="PairwiseDESeq2_+3A_genes">genes</code></td>
<td>
<p>restrict analysis to these genes; NULL means all genes</p>
</td></tr>
<tr><td><code id="PairwiseDESeq2_+3A_verbose">verbose</code></td>
<td>
<p>print status messages?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>DESeq2 by default performs size factor normalization. When computing differential expression of new RNA,
it might be sensible to normalize w.r.t. to total RNA, i.e. use the size factors computed from total RNA instead of computed from new RNA.
This can be accomplished by setting mode to &quot;new&quot;, and normalization to &quot;total&quot;!
</p>
<p>Normalization can also be a mode.slot! Importantly, do not specify a slot containing normalized values, but specify a slot of unnormalized values
(which are used to compute the size factors for normalization!) Can also be a numeric vector of size factors with the same length as the data as columns.
Then each value is divided by the corresponding size factor entry.
</p>


<h3>Value</h3>

<p>a new grandR object including a new analysis table. The columns of the new analysis table are
</p>
<table>
<tr><td><code>"M"</code></td>
<td>
<p>the base mean</p>
</td></tr>
<tr><td><code>"S"</code></td>
<td>
<p>the log2FoldChange divided by lfcSE</p>
</td></tr>
<tr><td><code>"P"</code></td>
<td>
<p>the Wald test P value</p>
</td></tr>
<tr><td><code>"Q"</code></td>
<td>
<p>same as P but Benjamini-Hochberg multiple testing corrected</p>
</td></tr>
<tr><td><code>"LFC"</code></td>
<td>
<p>the log2 fold change (only with the logFC parameter set to TRUE)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+LFC">LFC</a>,<a href="#topic+GetContrasts">GetContrasts</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sars &lt;- ReadGRAND(system.file("extdata", "sars.tsv.gz", package = "grandR"),
                  design=c(Design$Condition,Design$dur.4sU,Design$Replicate))
sars &lt;- subset(sars,Coldata(sars,Design$dur.4sU)==2)
sars&lt;-PairwiseDESeq2(sars,mode="total",
                              contrasts=GetContrasts(sars,contrast=c("Condition","Mock")))
sars&lt;-PairwiseDESeq2(sars,mode="new",normalization="total",
                              contrasts=GetContrasts(sars,contrast=c("Condition","Mock")))
head(GetAnalysisTable(sars,column="Q"))


</code></pre>

<hr>
<h2 id='PlotAnalyses'>Convenience function to make the same type of plot for multple analyses.</h2><span id='topic+PlotAnalyses'></span>

<h3>Description</h3>

<p>Convenience function to make the same type of plot for multple analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotAnalyses(data, plot.fun, analyses = Analyses(data), add = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotAnalyses_+3A_data">data</code></td>
<td>
<p>the grandR object that contains the data to be plotted</p>
</td></tr>
<tr><td><code id="PlotAnalyses_+3A_plot.fun">plot.fun</code></td>
<td>
<p>the plottinf function to apply</p>
</td></tr>
<tr><td><code id="PlotAnalyses_+3A_analyses">analyses</code></td>
<td>
<p>the analyses to plot (default: all)</p>
</td></tr>
<tr><td><code id="PlotAnalyses_+3A_add">add</code></td>
<td>
<p>additional ggplot (e.g., geoms) objects to add</p>
</td></tr>
<tr><td><code id="PlotAnalyses_+3A_...">...</code></td>
<td>
<p>passed further to plot.fun</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot objects
</p>

<hr>
<h2 id='PlotConversionFreq'>Diagnostic plot for conversion frequencies</h2><span id='topic+PlotConversionFreq'></span>

<h3>Description</h3>

<p>This is the second diagnostic plot (estimated conversions) generated by GRAND3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotConversionFreq(data, category, sample = NULL, max.columns = 120)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotConversionFreq_+3A_data">data</code></td>
<td>
<p>the grandR object</p>
</td></tr>
<tr><td><code id="PlotConversionFreq_+3A_category">category</code></td>
<td>
<p>show a specific category (see <a href="#topic+GetDiagnosticParameters">GetDiagnosticParameters</a>); cannot be NULL</p>
</td></tr>
<tr><td><code id="PlotConversionFreq_+3A_sample">sample</code></td>
<td>
<p>compare subreads for a specific sample; can be NULL, then compare all samples per subread</p>
</td></tr>
<tr><td><code id="PlotConversionFreq_+3A_max.columns">max.columns</code></td>
<td>
<p>if there are more columns (samples for bulk, cells for single cell) than this, show boxplots instead of points</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Show the percentage of all conversion types for all samples. In contrast to mismatches
(see <a href="#topic+PlotMismatchPositionForSample">PlotMismatchPositionForSample</a> and <a href="#topic+PlotMismatchPositionForType">PlotMismatchPositionForType</a>),
the correct strand is already inferred for conversions, i.e. conversions refer to
actual conversion events on RNA, whereas mismatches are observed events in mapped reads.
</p>


<h3>Value</h3>

<p>a list with a ggplot object, a description, and the desired size for the plot
</p>

<hr>
<h2 id='PlotGeneGroupsBars'>Plot gene values as bars</h2><span id='topic+PlotGeneGroupsBars'></span>

<h3>Description</h3>

<p>Plot old and new RNA of a gene in a row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotGeneGroupsBars(
  data,
  gene,
  slot = DefaultSlot(data),
  columns = NULL,
  show.CI = FALSE,
  xlab = NULL,
  transform = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotGeneGroupsBars_+3A_data">data</code></td>
<td>
<p>the grandR object to get the data to be plotted from</p>
</td></tr>
<tr><td><code id="PlotGeneGroupsBars_+3A_gene">gene</code></td>
<td>
<p>the gene to plot</p>
</td></tr>
<tr><td><code id="PlotGeneGroupsBars_+3A_slot">slot</code></td>
<td>
<p>the slot of the grandR object to get the data from</p>
</td></tr>
<tr><td><code id="PlotGeneGroupsBars_+3A_columns">columns</code></td>
<td>
<p>which columns (i.e. samples or cells) to show (see details)</p>
</td></tr>
<tr><td><code id="PlotGeneGroupsBars_+3A_show.ci">show.CI</code></td>
<td>
<p>show confidence intervals; one of TRUE/FALSE (default: FALSE)</p>
</td></tr>
<tr><td><code id="PlotGeneGroupsBars_+3A_xlab">xlab</code></td>
<td>
<p>The names to show at the x axis;</p>
</td></tr>
<tr><td><code id="PlotGeneGroupsBars_+3A_transform">transform</code></td>
<td>
<p>function that is called on the data frame directly before plotting (can be NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>xlab can be given as a character vector or an expression that evaluates into a character vector.
The expression is evaluated in an environment having the <code><a href="#topic+Coldata">Coldata</a></code>, i.e. you can use names of <code><a href="#topic+Coldata">Coldata</a></code> as variables to
conveniently it.
</p>
<p>Columns can be given as a logical, integer or character vector representing a selection of the columns (samples or cells).
The expression is evaluated in an environment having the <code><a href="#topic+Coldata">Coldata</a></code>, i.e. you can use names of <code><a href="#topic+Coldata">Coldata</a></code> as variables to
conveniently build a logical vector (e.g., columns=Condition==&quot;x&quot;).
</p>


<h3>Value</h3>

<p>a ggplot object.
</p>


<h3>See Also</h3>

<p><a href="#topic+GetData">GetData</a>, <a href="#topic+PlotGeneTotalVsNtr">PlotGeneTotalVsNtr</a>,<a href="#topic+PlotGeneOldVsNew">PlotGeneOldVsNew</a>,<a href="#topic+PlotGeneGroupsBars">PlotGeneGroupsBars</a>
</p>

<hr>
<h2 id='PlotGeneGroupsPoints'>Plot gene groups as points</h2><span id='topic+PlotGeneGroupsPoints'></span>

<h3>Description</h3>

<p>Plot either old, new or total RNA of a gene in a row, per condition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotGeneGroupsPoints(
  data,
  gene,
  group = "Condition",
  mode.slot = DefaultSlot(data),
  columns = NULL,
  log = TRUE,
  show.CI = FALSE,
  aest = NULL,
  size = 2,
  transform = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotGeneGroupsPoints_+3A_data">data</code></td>
<td>
<p>the grandR object to get the data to be plotted from</p>
</td></tr>
<tr><td><code id="PlotGeneGroupsPoints_+3A_gene">gene</code></td>
<td>
<p>the gene to plot</p>
</td></tr>
<tr><td><code id="PlotGeneGroupsPoints_+3A_group">group</code></td>
<td>
<p>how to group the genes (default: Condition)</p>
</td></tr>
<tr><td><code id="PlotGeneGroupsPoints_+3A_mode.slot">mode.slot</code></td>
<td>
<p>the  mode.slot of the grandR object to get the data from</p>
</td></tr>
<tr><td><code id="PlotGeneGroupsPoints_+3A_columns">columns</code></td>
<td>
<p>which columns (i.e. samples or cells) to show (see details)</p>
</td></tr>
<tr><td><code id="PlotGeneGroupsPoints_+3A_log">log</code></td>
<td>
<p>show the y axis in log scale</p>
</td></tr>
<tr><td><code id="PlotGeneGroupsPoints_+3A_show.ci">show.CI</code></td>
<td>
<p>show confidence intervals; one of TRUE/FALSE (default: FALSE)</p>
</td></tr>
<tr><td><code id="PlotGeneGroupsPoints_+3A_aest">aest</code></td>
<td>
<p>parameter to set the visual attributes of the plot</p>
</td></tr>
<tr><td><code id="PlotGeneGroupsPoints_+3A_size">size</code></td>
<td>
<p>the point size used for plotting; overridden if size is defined via aest</p>
</td></tr>
<tr><td><code id="PlotGeneGroupsPoints_+3A_transform">transform</code></td>
<td>
<p>function that is called on the data frame directly before plotting (can be NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The value of the aest parameter must be an <em>Aesthetic mapping</em> as generated by <a href="ggplot2.html#topic+aes">aes</a>.
</p>
<p>To refer to data slots, the mode.slot syntax can be used: Each name is either a data slot, or one of (new,old,total) followed by a
dot followed by a slot. For new or old, the data slot value is multiplied by ntr or 1-ntr. This can be used e.g. to obtain the <em>new counts</em>.
</p>
<p>The table used for plotting is the table returned by <a href="#topic+GetData">GetData</a> with coldata set to TRUE, i.e. you can use all names from the <a href="#topic+Coldata">Coldata</a> table for aest.
</p>
<p>By default, aest is set to aes(color=Condition,shape=Replicate) (if both Condition and Replicate are names in the Coldata table).
</p>
<p>Columns can be given as a logical, integer or character vector representing a selection of the columns (samples or cells).
The expression is evaluated in an environment having the <code><a href="#topic+Coldata">Coldata</a></code>, i.e. you can use names of <code><a href="#topic+Coldata">Coldata</a></code> as variables to
conveniently build a logical vector (e.g., columns=Condition==&quot;x&quot;).
</p>


<h3>Value</h3>

<p>a ggplot object.
</p>


<h3>See Also</h3>

<p><a href="#topic+GetData">GetData</a>, <a href="#topic+PlotGeneTotalVsNtr">PlotGeneTotalVsNtr</a>,<a href="#topic+PlotGeneOldVsNew">PlotGeneOldVsNew</a>,<a href="#topic+PlotGeneGroupsBars">PlotGeneGroupsBars</a>
</p>

<hr>
<h2 id='PlotGeneOldVsNew'>Gene plot comparing old vs new RNA</h2><span id='topic+PlotGeneOldVsNew'></span>

<h3>Description</h3>

<p>Plot the old vs new RNA values of a gene
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotGeneOldVsNew(
  data,
  gene,
  slot = DefaultSlot(data),
  columns = NULL,
  log = TRUE,
  show.CI = FALSE,
  aest = NULL,
  size = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotGeneOldVsNew_+3A_data">data</code></td>
<td>
<p>the grandR object to get the data to be plotted from</p>
</td></tr>
<tr><td><code id="PlotGeneOldVsNew_+3A_gene">gene</code></td>
<td>
<p>the gene to plot</p>
</td></tr>
<tr><td><code id="PlotGeneOldVsNew_+3A_slot">slot</code></td>
<td>
<p>the slot of the grandR object to get the data from</p>
</td></tr>
<tr><td><code id="PlotGeneOldVsNew_+3A_columns">columns</code></td>
<td>
<p>which columns (i.e. samples or cells) to show (see details)</p>
</td></tr>
<tr><td><code id="PlotGeneOldVsNew_+3A_log">log</code></td>
<td>
<p>show both axes in log scale</p>
</td></tr>
<tr><td><code id="PlotGeneOldVsNew_+3A_show.ci">show.CI</code></td>
<td>
<p>show confidence intervals; one of TRUE/FALSE (default: FALSE)</p>
</td></tr>
<tr><td><code id="PlotGeneOldVsNew_+3A_aest">aest</code></td>
<td>
<p>parameter to set the visual attributes of the plot</p>
</td></tr>
<tr><td><code id="PlotGeneOldVsNew_+3A_size">size</code></td>
<td>
<p>the point size used for plotting; overridden if size is defined via aest</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The value of the aest parameter must be an <em>Aesthetic mapping</em> as generated by <a href="ggplot2.html#topic+aes">aes</a>.
</p>
<p>The table used for plotting is the table returned by <a href="#topic+GetData">GetData</a> with coldata set to TRUE, i.e. you can use all names from the <a href="#topic+Coldata">Coldata</a> table for aest.
</p>
<p>By default, aest is set to aes(color=Condition,shape=Replicate) (if both Condition and Replicate are names in the Coldata table).
</p>
<p>Columns can be given as a logical, integer or character vector representing a selection of the columns (samples or cells).
The expression is evaluated in an environment having the <code><a href="#topic+Coldata">Coldata</a></code>, i.e. you can use names of <code><a href="#topic+Coldata">Coldata</a></code> as variables to
conveniently build a logical vector (e.g., columns=Condition==&quot;x&quot;).
</p>


<h3>Value</h3>

<p>a ggplot object.
</p>


<h3>See Also</h3>

<p><a href="#topic+GetData">GetData</a>, <a href="#topic+PlotGeneTotalVsNtr">PlotGeneTotalVsNtr</a>,<a href="#topic+PlotGeneGroupsPoints">PlotGeneGroupsPoints</a>,<a href="#topic+PlotGeneGroupsBars">PlotGeneGroupsBars</a>
</p>

<hr>
<h2 id='PlotGeneProgressiveTimecourse'>Plot progressive labeling timecourses</h2><span id='topic+PlotGeneProgressiveTimecourse'></span>

<h3>Description</h3>

<p>Plot the abundance of new and old RNA and the fitted model over time for a single gene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotGeneProgressiveTimecourse(
  data,
  gene,
  slot = DefaultSlot(data),
  time = Design$dur.4sU,
  type = c("nlls", "ntr", "lm"),
  exact.tics = TRUE,
  show.CI = FALSE,
  return.tables = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotGeneProgressiveTimecourse_+3A_data">data</code></td>
<td>
<p>a grandR object</p>
</td></tr>
<tr><td><code id="PlotGeneProgressiveTimecourse_+3A_gene">gene</code></td>
<td>
<p>the gene to be plotted</p>
</td></tr>
<tr><td><code id="PlotGeneProgressiveTimecourse_+3A_slot">slot</code></td>
<td>
<p>the data slot of the observed abundances</p>
</td></tr>
<tr><td><code id="PlotGeneProgressiveTimecourse_+3A_time">time</code></td>
<td>
<p>the labeling duration column in the column annotation table</p>
</td></tr>
<tr><td><code id="PlotGeneProgressiveTimecourse_+3A_type">type</code></td>
<td>
<p>how to fit the model (see <a href="#topic+FitKinetics">FitKinetics</a>)</p>
</td></tr>
<tr><td><code id="PlotGeneProgressiveTimecourse_+3A_exact.tics">exact.tics</code></td>
<td>
<p>use axis labels directly corresponding to the available labeling durations?</p>
</td></tr>
<tr><td><code id="PlotGeneProgressiveTimecourse_+3A_show.ci">show.CI</code></td>
<td>
<p>show confidence intervals; one of TRUE/FALSE (default: FALSE)</p>
</td></tr>
<tr><td><code id="PlotGeneProgressiveTimecourse_+3A_return.tables">return.tables</code></td>
<td>
<p>also return the tables used for plotting</p>
</td></tr>
<tr><td><code id="PlotGeneProgressiveTimecourse_+3A_...">...</code></td>
<td>
<p>given to the fitting procedures</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each <code><a href="#topic+Condition">Condition</a></code> there will be one panel containing the values and the corresponding model fit.
</p>


<h3>Value</h3>

<p>either a ggplot object, or a list containing all tables used for plotting and the ggplot object.
</p>


<h3>See Also</h3>

<p><a href="#topic+FitKineticsGeneNtr">FitKineticsGeneNtr</a>, <a href="#topic+FitKineticsGeneLeastSquares">FitKineticsGeneLeastSquares</a>, <a href="#topic+FitKineticsGeneLogSpaceLinear">FitKineticsGeneLogSpaceLinear</a>
</p>

<hr>
<h2 id='PlotGeneSnapshotTimecourse'>Gene plot for snapshot timecourse data</h2><span id='topic+PlotGeneSnapshotTimecourse'></span>

<h3>Description</h3>

<p>Plot the total RNA expression vs the new-to-total RNA ratio for a gene
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotGeneSnapshotTimecourse(
  data,
  gene,
  time = Design$dur.4sU,
  mode.slot = DefaultSlot(data),
  columns = NULL,
  average.lines = TRUE,
  exact.tics = TRUE,
  log = TRUE,
  show.CI = FALSE,
  aest = NULL,
  size = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotGeneSnapshotTimecourse_+3A_data">data</code></td>
<td>
<p>the grandR object to get the data to be plotted from</p>
</td></tr>
<tr><td><code id="PlotGeneSnapshotTimecourse_+3A_gene">gene</code></td>
<td>
<p>the gene to plot</p>
</td></tr>
<tr><td><code id="PlotGeneSnapshotTimecourse_+3A_time">time</code></td>
<td>
<p>the times to show on the x axis (see details)</p>
</td></tr>
<tr><td><code id="PlotGeneSnapshotTimecourse_+3A_mode.slot">mode.slot</code></td>
<td>
<p>the mode.slot of the grandR object to get the data from</p>
</td></tr>
<tr><td><code id="PlotGeneSnapshotTimecourse_+3A_columns">columns</code></td>
<td>
<p>which columns (i.e. samples or cells) to show (see details)</p>
</td></tr>
<tr><td><code id="PlotGeneSnapshotTimecourse_+3A_average.lines">average.lines</code></td>
<td>
<p>add average lines?</p>
</td></tr>
<tr><td><code id="PlotGeneSnapshotTimecourse_+3A_exact.tics">exact.tics</code></td>
<td>
<p>use axis labels directly corresponding to the available temporal values?</p>
</td></tr>
<tr><td><code id="PlotGeneSnapshotTimecourse_+3A_log">log</code></td>
<td>
<p>show the y axis in log scale</p>
</td></tr>
<tr><td><code id="PlotGeneSnapshotTimecourse_+3A_show.ci">show.CI</code></td>
<td>
<p>show confidence intervals; one of TRUE/FALSE (default: FALSE)</p>
</td></tr>
<tr><td><code id="PlotGeneSnapshotTimecourse_+3A_aest">aest</code></td>
<td>
<p>parameter to set the visual attributes of the plot</p>
</td></tr>
<tr><td><code id="PlotGeneSnapshotTimecourse_+3A_size">size</code></td>
<td>
<p>the point size used for plotting; overridden if size is defined via aest</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The x axis of this plot will show a temporal dimension. The time parameter defines a name in the <a href="#topic+Coldata">Coldata</a> table containing the temporal values for each sample.
</p>
<p>The value of the aest parameter must be an <em>Aesthetic mapping</em> as generated by <a href="ggplot2.html#topic+aes">aes</a>.
</p>
<p>The table used for plotting is the table returned by <a href="#topic+GetData">GetData</a> with coldata set to TRUE, i.e. you can use all names from the <a href="#topic+Coldata">Coldata</a> table for aest.
</p>
<p>By default, aest is set to aes(color=Condition,shape=Replicate) (if both Condition and Replicate are names in the Coldata table).
</p>
<p>Columns can be given as a logical, integer or character vector representing a selection of the columns (samples or cells).
The expression is evaluated in an environment having the <code><a href="#topic+Coldata">Coldata</a></code>, i.e. you can use names of <code><a href="#topic+Coldata">Coldata</a></code> as variables to
conveniently build a logical vector (e.g., columns=Condition==&quot;x&quot;).
</p>


<h3>Value</h3>

<p>a ggplot object.
</p>


<h3>See Also</h3>

<p><a href="#topic+GetData">GetData</a>, <a href="#topic+PlotGeneOldVsNew">PlotGeneOldVsNew</a>,<a href="#topic+PlotGeneGroupsPoints">PlotGeneGroupsPoints</a>,<a href="#topic+PlotGeneGroupsBars">PlotGeneGroupsBars</a>
</p>

<hr>
<h2 id='PlotGeneTotalVsNtr'>Gene plot comparing total RNA vs the NTR</h2><span id='topic+PlotGeneTotalVsNtr'></span>

<h3>Description</h3>

<p>Plot the total RNA expression vs the new-to-total RNA ratio for a gene
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotGeneTotalVsNtr(
  data,
  gene,
  slot = DefaultSlot(data),
  columns = NULL,
  log = TRUE,
  show.CI = FALSE,
  aest = NULL,
  size = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotGeneTotalVsNtr_+3A_data">data</code></td>
<td>
<p>the grandR object to get the data to be plotted from</p>
</td></tr>
<tr><td><code id="PlotGeneTotalVsNtr_+3A_gene">gene</code></td>
<td>
<p>the gene to plot</p>
</td></tr>
<tr><td><code id="PlotGeneTotalVsNtr_+3A_slot">slot</code></td>
<td>
<p>the slot of the grandR object to get the data from</p>
</td></tr>
<tr><td><code id="PlotGeneTotalVsNtr_+3A_columns">columns</code></td>
<td>
<p>which columns (i.e. samples or cells) to show (see details)</p>
</td></tr>
<tr><td><code id="PlotGeneTotalVsNtr_+3A_log">log</code></td>
<td>
<p>show the x axis (total RNA) in log scale</p>
</td></tr>
<tr><td><code id="PlotGeneTotalVsNtr_+3A_show.ci">show.CI</code></td>
<td>
<p>show confidence intervals; one of TRUE/FALSE (default: FALSE)</p>
</td></tr>
<tr><td><code id="PlotGeneTotalVsNtr_+3A_aest">aest</code></td>
<td>
<p>parameter to set the visual attributes of the plot</p>
</td></tr>
<tr><td><code id="PlotGeneTotalVsNtr_+3A_size">size</code></td>
<td>
<p>the point size used for plotting; overridden if size is defined via aest</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The value of the aest parameter must be an <em>Aesthetic mapping</em> as generated by <a href="ggplot2.html#topic+aes">aes</a>.
</p>
<p>The table used for plotting is the table returned by <a href="#topic+GetData">GetData</a> with coldata set to TRUE, i.e. you can use all names from the <a href="#topic+Coldata">Coldata</a> table for aest.
</p>
<p>By default, aest is set to aes(color=Condition,shape=Replicate) (if both Condition and Replicate are names in the Coldata table).
</p>
<p>Columns can be given as a logical, integer or character vector representing a selection of the columns (samples or cells).
The expression is evaluated in an environment having the <code><a href="#topic+Coldata">Coldata</a></code>, i.e. you can use names of <code><a href="#topic+Coldata">Coldata</a></code> as variables to
conveniently build a logical vector (e.g., columns=Condition==&quot;x&quot;).
</p>


<h3>Value</h3>

<p>a ggplot object.
</p>


<h3>See Also</h3>

<p><a href="#topic+GetData">GetData</a>, <a href="#topic+PlotGeneOldVsNew">PlotGeneOldVsNew</a>,<a href="#topic+PlotGeneGroupsPoints">PlotGeneGroupsPoints</a>,<a href="#topic+PlotGeneGroupsBars">PlotGeneGroupsBars</a>
</p>

<hr>
<h2 id='PlotHeatmap'>Create heatmaps from grandR objects</h2><span id='topic+PlotHeatmap'></span>

<h3>Description</h3>

<p>Convenience method to compare among more two variables (slot data or analyses results).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotHeatmap(
  data,
  type = DefaultSlot(data),
  columns = NULL,
  genes = NULL,
  summarize = NULL,
  transform = "Z",
  cluster.genes = TRUE,
  cluster.columns = FALSE,
  label.genes = NULL,
  xlab = NULL,
  breaks = NULL,
  colors = NULL,
  title = NULL,
  return.matrix = FALSE,
  na.to = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotHeatmap_+3A_data">data</code></td>
<td>
<p>the grandR object that contains the data to plot</p>
</td></tr>
<tr><td><code id="PlotHeatmap_+3A_type">type</code></td>
<td>
<p>Either a mode.slot (see details) or a regex to be matched against analysis names. Can also be a vector</p>
</td></tr>
<tr><td><code id="PlotHeatmap_+3A_columns">columns</code></td>
<td>
<p>a vector of columns (either condition/cell names if the type is a mode.slot, or names in the output table from an analysis; use <a href="#topic+Columns">Columns</a>(data,&lt;analysis&gt;) to learn which columns are available); all condition/cell names if NULL</p>
</td></tr>
<tr><td><code id="PlotHeatmap_+3A_genes">genes</code></td>
<td>
<p>the genes to be included in the plot (default: all genes)</p>
</td></tr>
<tr><td><code id="PlotHeatmap_+3A_summarize">summarize</code></td>
<td>
<p>Should replicates by summarized? Can only be specified if columns is NULL; either a summarization matrix (<a href="#topic+GetSummarizeMatrix">GetSummarizeMatrix</a>) or TRUE (in which case <a href="#topic+GetSummarizeMatrix">GetSummarizeMatrix</a>(data) is called)</p>
</td></tr>
<tr><td><code id="PlotHeatmap_+3A_transform">transform</code></td>
<td>
<p>apply a transformation to the selected data; can be a function, or a character (see details)</p>
</td></tr>
<tr><td><code id="PlotHeatmap_+3A_cluster.genes">cluster.genes</code></td>
<td>
<p>should genes be clustered?</p>
</td></tr>
<tr><td><code id="PlotHeatmap_+3A_cluster.columns">cluster.columns</code></td>
<td>
<p>should samples (or cells) be clustered?</p>
</td></tr>
<tr><td><code id="PlotHeatmap_+3A_label.genes">label.genes</code></td>
<td>
<p>should genes be labeled?</p>
</td></tr>
<tr><td><code id="PlotHeatmap_+3A_xlab">xlab</code></td>
<td>
<p>The names to show at the x axis (only works if type is a single slot)</p>
</td></tr>
<tr><td><code id="PlotHeatmap_+3A_breaks">breaks</code></td>
<td>
<p>vector of color breaks; can be NULL (see details)</p>
</td></tr>
<tr><td><code id="PlotHeatmap_+3A_colors">colors</code></td>
<td>
<p>an RColorBrewer palette name; can be NULL (see details)</p>
</td></tr>
<tr><td><code id="PlotHeatmap_+3A_title">title</code></td>
<td>
<p>the title for the plot; can be NULL</p>
</td></tr>
<tr><td><code id="PlotHeatmap_+3A_return.matrix">return.matrix</code></td>
<td>
<p>if TRUE, return a list containing the data matrix and the heatmap instead of the heatmap alone</p>
</td></tr>
<tr><td><code id="PlotHeatmap_+3A_na.to">na.to</code></td>
<td>
<p>convert NA values in the matrix to this value immediately before computing the heatmap</p>
</td></tr>
<tr><td><code id="PlotHeatmap_+3A_...">...</code></td>
<td>
<p>additional parameters forwarded to <a href="ComplexHeatmap.html#topic+Heatmap">Heatmap</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is just a convenience function which
</p>

<ol>
<li><p>Calls <a href="#topic+GetTable">GetTable</a> with the parameter <code>type,columns,summarize,genes</code>
</p>
</li>
<li><p>Transforms the returned table using the <code>transform</code> parameter
</p>
</li>
<li><p>Determines reasonable colors using <code>breaks</code> and <code>colors</code>
</p>
</li>
<li><p>and then calls ComplexHeatmap::Heatmap
</p>
</li></ol>

<p><code>type</code> and <code>columns</code> can refer to values from data slots values from analyses (and can be mixed).
If there are types from both data and analyses, columns must be NULL.
Otherwise columns must either be condition/cell names (if type refers to one or several data slots), or regular expressions
to match against the names in the analysis tables.
</p>
<p>Columns definitions for data slots can be given as a logical, integer or character vector representing a selection of the columns (samples or cells).
The expression is evaluated in an environment having the <code><a href="#topic+Coldata">Coldata</a></code>, i.e. you can use names of <code><a href="#topic+Coldata">Coldata</a></code> as variables to
conveniently build a logical vector (e.g., columns=Condition==&quot;x&quot;).
</p>
<p>To refer to data slots, the mode.slot syntax can be used: Each name is either a data slot, or one of (new,old,total)
followed by a dot followed by a slot. For new or old, the data slot value is multiplied by ntr or 1-ntr. This can be used e.g. to obtain the <em>new counts</em>.
</p>
<p>The transform parameter either is a function that transforms a matrix (which can conveniently be done using the Transform.XXX functions described next), or
a character (which must be the XXX to find such a function). Available data transformations are
</p>

<ul>
<li><p>transform=Transform.Z() or transform=&quot;Z&quot;: compute z scores for each row (see <a href="#topic+Transform.Z">Transform.Z</a>)
</p>
</li>
<li><p>transform=Transform.VST() or transform=&quot;VST&quot;: do a variance stabilizing transformation (see <a href="#topic+Transform.VST">Transform.VST</a>)
</p>
</li>
<li><p>transform=Transform.logFC() or transform=&quot;logFC&quot;: compute log2 fold changes to one or several reference columns; which must be defined via parameters (see <a href="#topic+Transform.logFC">Transform.logFC</a>)
</p>
</li>
<li><p>transform=Transform.no() or transform=&quot;no&quot;: do not transform (see <a href="#topic+Transform.no">Transform.no</a>)
</p>
</li></ul>

<p>Reasonable coloring is chosen depending on the value distribution in the matrix. If the values are zero centered (e.g. z scores or most often log fold changes), then
by default the 50
quantile with the larger value. The breaks are -q90,q50,0,q50,q90, and, by default, the red to blue &quot;RdBu&quot; palette from RColorBrewer is taken. If the values are not zero centered,
the 5
</p>
<p>xlab can be given as a character vector or an expression that evaluates into a character vector.
The expression is evaluated in an environment having the <code><a href="#topic+Coldata">Coldata</a></code>, i.e. you can use names of <code><a href="#topic+Coldata">Coldata</a></code> as variables.
</p>


<h3>Value</h3>

<p>a ComplexHeatmap object
</p>


<h3>See Also</h3>

<p><a href="#topic+GetTable">GetTable</a>,<a href="ComplexHeatmap.html#topic+Heatmap">Heatmap</a>
</p>

<hr>
<h2 id='PlotMismatchPositionForSample'>Diagnostic plot for mismatch position for columns (by sample)</h2><span id='topic+PlotMismatchPositionForSample'></span>

<h3>Description</h3>

<p>This belongs to the first diagnostic plots (raw mismatches) generated by GRAND3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotMismatchPositionForSample(
  data,
  sample,
  orientation = NULL,
  category = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotMismatchPositionForSample_+3A_data">data</code></td>
<td>
<p>a grandR object</p>
</td></tr>
<tr><td><code id="PlotMismatchPositionForSample_+3A_sample">sample</code></td>
<td>
<p>a sample name</p>
</td></tr>
<tr><td><code id="PlotMismatchPositionForSample_+3A_orientation">orientation</code></td>
<td>
<p>restrict to either Sense or Antisense; can be NULL</p>
</td></tr>
<tr><td><code id="PlotMismatchPositionForSample_+3A_category">category</code></td>
<td>
<p>restrict to a specific category (see <a href="#topic+GetDiagnosticParameters">GetDiagnosticParameters</a>); can be NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all positions along the reads (x axis; potentially paired end, shown left and right),
show the percentage of all mismatch types. The panel in column T and row C shows T-to-C mismatches.
Positions outside of shaded areas are clipped. Uncorrected and Retained means before and
after correcting multiply sequenced bases. Sense/Antisense means reads (first read for paired end)
that are (based on the annotation) oriented in sense or antisense direction to a gene
(i.e. this is only relevant for sequencing protocols that do not preserve strand information).
</p>


<h3>Value</h3>

<p>a list with a ggplot object, a description, and the desired size for the plot
</p>

<hr>
<h2 id='PlotMismatchPositionForType'>Diagnostic plot for mismatch position for columns (by mismatch type)</h2><span id='topic+PlotMismatchPositionForType'></span>

<h3>Description</h3>

<p>This belongs to the first diagnostic plots (raw mismatches) generated by GRAND3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotMismatchPositionForType(
  data,
  genomic,
  read,
  orientation = NULL,
  category = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotMismatchPositionForType_+3A_data">data</code></td>
<td>
<p>a grandR object</p>
</td></tr>
<tr><td><code id="PlotMismatchPositionForType_+3A_genomic">genomic</code></td>
<td>
<p>the nucleotide as it occurs in the genome</p>
</td></tr>
<tr><td><code id="PlotMismatchPositionForType_+3A_read">read</code></td>
<td>
<p>the nucleotide as it occurs in the read</p>
</td></tr>
<tr><td><code id="PlotMismatchPositionForType_+3A_orientation">orientation</code></td>
<td>
<p>restrict to either Sense or Antisense; can be NULL</p>
</td></tr>
<tr><td><code id="PlotMismatchPositionForType_+3A_category">category</code></td>
<td>
<p>restrict to a specific category (see <a href="#topic+GetDiagnosticParameters">GetDiagnosticParameters</a>); can be NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all positions along the reads (x axis; potentially paired end, shown left and right),
show the percentage of a specific mismatch type for all samples.
Positions outside of shaded areas are clipped. Uncorrected and Retained means before and
after correcting multiply sequenced bases. Sense/Antisense means reads (first read for paired end)
that are (based on the annotation) oriented in sense or antisense direction to a gene
(i.e. this is only relevant for sequencing protocols that do not preserve strand information).
</p>


<h3>Value</h3>

<p>a list with a ggplot object, a description, and the desired size for the plot
</p>

<hr>
<h2 id='PlotModelCompareConv'>Diagnostic plot for estimated models (global conversion rate)</h2><span id='topic+PlotModelCompareConv'></span>

<h3>Description</h3>

<p>This belongs to the fourth kind (model comparison) of diagnostic plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotModelCompareConv(data, label = "4sU", estimator = "Separate")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotModelCompareConv_+3A_data">data</code></td>
<td>
<p>a grandR object</p>
</td></tr>
<tr><td><code id="PlotModelCompareConv_+3A_label">label</code></td>
<td>
<p>which label to consider (see <a href="#topic+GetDiagnosticParameters">GetDiagnosticParameters</a>); cannot be NULL</p>
</td></tr>
<tr><td><code id="PlotModelCompareConv_+3A_estimator">estimator</code></td>
<td>
<p>which estimator to consider (see <a href="#topic+GetDiagnosticParameters">GetDiagnosticParameters</a>); cannot be NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compares the estimated conversion rate (i.e., the probability for a conversion
on a new RNA molecule) for the binom and tbbinom models (mean conversion rate).
</p>


<h3>Value</h3>

<p>a list with a ggplot object, a description, and the desired size for the plot
</p>

<hr>
<h2 id='PlotModelCompareErr'>Diagnostic plot for estimated models (global error rate)</h2><span id='topic+PlotModelCompareErr'></span>

<h3>Description</h3>

<p>This belongs to the fourth kind (model comparison) of diagnostic plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotModelCompareErr(data, label = "4sU", estimator = "Separate")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotModelCompareErr_+3A_data">data</code></td>
<td>
<p>a grandR object</p>
</td></tr>
<tr><td><code id="PlotModelCompareErr_+3A_label">label</code></td>
<td>
<p>which label to consider (see <a href="#topic+GetDiagnosticParameters">GetDiagnosticParameters</a>); cannot be NULL</p>
</td></tr>
<tr><td><code id="PlotModelCompareErr_+3A_estimator">estimator</code></td>
<td>
<p>which estimator to consider (see <a href="#topic+GetDiagnosticParameters">GetDiagnosticParameters</a>); cannot be NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compares the estimated error rate (i.e., the probability for a conversion
on an old RNA molecule) for the binom and tbbinom models.
</p>


<h3>Value</h3>

<p>a list with a ggplot object, a description, and the desired size for the plot
</p>

<hr>
<h2 id='PlotModelCompareErrPrior'>Diagnostic plot for estimated models (global error rate)</h2><span id='topic+PlotModelCompareErrPrior'></span>

<h3>Description</h3>

<p>This belongs to the fourth kind (model comparison) of diagnostic plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotModelCompareErrPrior(
  data,
  label = "4sU",
  estimator = "Separate",
  model = "Binom"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotModelCompareErrPrior_+3A_data">data</code></td>
<td>
<p>a grandR object</p>
</td></tr>
<tr><td><code id="PlotModelCompareErrPrior_+3A_label">label</code></td>
<td>
<p>which label to consider (see <a href="#topic+GetDiagnosticParameters">GetDiagnosticParameters</a>); cannot be NULL</p>
</td></tr>
<tr><td><code id="PlotModelCompareErrPrior_+3A_estimator">estimator</code></td>
<td>
<p>which estimator to consider (see <a href="#topic+GetDiagnosticParameters">GetDiagnosticParameters</a>); cannot be NULL</p>
</td></tr>
<tr><td><code id="PlotModelCompareErrPrior_+3A_model">model</code></td>
<td>
<p>which model to consider (see <a href="#topic+GetDiagnosticParameters">GetDiagnosticParameters</a>); cannot be NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compares the prior error rate (estimated from no4sU samples or from all other mismatch types)
against the final error rate estimate.
</p>


<h3>Value</h3>

<p>a list with a ggplot object, a description, and the desired size for the plot
</p>

<hr>
<h2 id='PlotModelCompareLL'>Diagnostic plot for estimated models (log likelihoods)</h2><span id='topic+PlotModelCompareLL'></span>

<h3>Description</h3>

<p>This belongs to the fourth kind (model comparison) of diagnostic plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotModelCompareLL(data, label = "4sU", estimator = "Separate")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotModelCompareLL_+3A_data">data</code></td>
<td>
<p>a grandR object</p>
</td></tr>
<tr><td><code id="PlotModelCompareLL_+3A_label">label</code></td>
<td>
<p>which label to consider (see <a href="#topic+GetDiagnosticParameters">GetDiagnosticParameters</a>); cannot be NULL</p>
</td></tr>
<tr><td><code id="PlotModelCompareLL_+3A_estimator">estimator</code></td>
<td>
<p>which estimator to consider (see <a href="#topic+GetDiagnosticParameters">GetDiagnosticParameters</a>); cannot be NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Shows the difference in log likelihoods between the binom and tbbinom models.
</p>


<h3>Value</h3>

<p>a list with a ggplot object, a description, and the desired size for the plot
</p>

<hr>
<h2 id='PlotModelCompareNtr'>Diagnostic plot for estimated models (global NTR)</h2><span id='topic+PlotModelCompareNtr'></span>

<h3>Description</h3>

<p>This belongs to the fourth kind (model comparison) of diagnostic plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotModelCompareNtr(data, label = "4sU", estimator = "Separate")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotModelCompareNtr_+3A_data">data</code></td>
<td>
<p>a grandR object</p>
</td></tr>
<tr><td><code id="PlotModelCompareNtr_+3A_label">label</code></td>
<td>
<p>which label to consider (see <a href="#topic+GetDiagnosticParameters">GetDiagnosticParameters</a>); cannot be NULL</p>
</td></tr>
<tr><td><code id="PlotModelCompareNtr_+3A_estimator">estimator</code></td>
<td>
<p>which estimator to consider (see <a href="#topic+GetDiagnosticParameters">GetDiagnosticParameters</a>); cannot be NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compares the global NTR (i.e. for all reads used for estimation of
global parameters, what is the percentage of new RNA) for the binom and tbbinom models.
</p>


<h3>Value</h3>

<p>a list with a ggplot object, a description, and the desired size for the plot
</p>

<hr>
<h2 id='PlotModelConv'>Diagnostic plot for estimated models (global conversion rate)</h2><span id='topic+PlotModelConv'></span>

<h3>Description</h3>

<p>This belongs to the third kind (model) of diagnostic plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotModelConv(data, label = "4sU", estimator = "Separate", model = "Binom")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotModelConv_+3A_data">data</code></td>
<td>
<p>a grandR object</p>
</td></tr>
<tr><td><code id="PlotModelConv_+3A_label">label</code></td>
<td>
<p>which label to consider (see <a href="#topic+GetDiagnosticParameters">GetDiagnosticParameters</a>); cannot be NULL</p>
</td></tr>
<tr><td><code id="PlotModelConv_+3A_estimator">estimator</code></td>
<td>
<p>which estimator to consider (see <a href="#topic+GetDiagnosticParameters">GetDiagnosticParameters</a>); cannot be NULL</p>
</td></tr>
<tr><td><code id="PlotModelConv_+3A_model">model</code></td>
<td>
<p>which model to consider (see <a href="#topic+GetDiagnosticParameters">GetDiagnosticParameters</a>); cannot be NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Shows the estimated conversion rate (i.e., the probability for a conversion
on a new RNA molecule) for each sample.
</p>


<h3>Value</h3>

<p>a list with a ggplot object, a description, and the desired size for the plot
</p>

<hr>
<h2 id='PlotModelErr'>Diagnostic plot for estimated models (global error rate)</h2><span id='topic+PlotModelErr'></span>

<h3>Description</h3>

<p>This belongs to the third kind (model) of diagnostic plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotModelErr(data, label = "4sU", estimator = "Separate", model = "Binom")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotModelErr_+3A_data">data</code></td>
<td>
<p>a grandR object</p>
</td></tr>
<tr><td><code id="PlotModelErr_+3A_label">label</code></td>
<td>
<p>which label to consider (see <a href="#topic+GetDiagnosticParameters">GetDiagnosticParameters</a>); cannot be NULL</p>
</td></tr>
<tr><td><code id="PlotModelErr_+3A_estimator">estimator</code></td>
<td>
<p>which estimator to consider (see <a href="#topic+GetDiagnosticParameters">GetDiagnosticParameters</a>); cannot be NULL</p>
</td></tr>
<tr><td><code id="PlotModelErr_+3A_model">model</code></td>
<td>
<p>which model to consider (see <a href="#topic+GetDiagnosticParameters">GetDiagnosticParameters</a>); cannot be NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Shows the estimated error rate (i.e., the probability for a conversion
on an old RNA molecule) for each sample.
</p>


<h3>Value</h3>

<p>a list with a ggplot object, a description, and the desired size for the plot
</p>

<hr>
<h2 id='PlotModelLabelTimeCourse'>Diagnostic plot for estimated models (4sU increase)</h2><span id='topic+PlotModelLabelTimeCourse'></span>

<h3>Description</h3>

<p>This belongs to the third kind (model) of diagnostic plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotModelLabelTimeCourse(data, label = "4sU", estimator = "Separate")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotModelLabelTimeCourse_+3A_data">data</code></td>
<td>
<p>a grandR object</p>
</td></tr>
<tr><td><code id="PlotModelLabelTimeCourse_+3A_label">label</code></td>
<td>
<p>which label to consider (see <a href="#topic+GetDiagnosticParameters">GetDiagnosticParameters</a>); cannot be NULL</p>
</td></tr>
<tr><td><code id="PlotModelLabelTimeCourse_+3A_estimator">estimator</code></td>
<td>
<p>which estimator to consider (see <a href="#topic+GetDiagnosticParameters">GetDiagnosticParameters</a>); cannot be NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Shows the estimated time evolution of 4sU increase in the tbbinom model for each sample.
</p>


<h3>Value</h3>

<p>a list with a ggplot object, a description, and the desired size for the plot
</p>

<hr>
<h2 id='PlotModelNtr'>Diagnostic plot for estimated models (global NTR)</h2><span id='topic+PlotModelNtr'></span>

<h3>Description</h3>

<p>This belongs to the third kind (model) of diagnostic plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotModelNtr(data, label = "4sU", estimator = "Separate", model = "Binom")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotModelNtr_+3A_data">data</code></td>
<td>
<p>a grandR object</p>
</td></tr>
<tr><td><code id="PlotModelNtr_+3A_label">label</code></td>
<td>
<p>which label to consider (see <a href="#topic+GetDiagnosticParameters">GetDiagnosticParameters</a>); cannot be NULL</p>
</td></tr>
<tr><td><code id="PlotModelNtr_+3A_estimator">estimator</code></td>
<td>
<p>which estimator to consider (see <a href="#topic+GetDiagnosticParameters">GetDiagnosticParameters</a>); cannot be NULL</p>
</td></tr>
<tr><td><code id="PlotModelNtr_+3A_model">model</code></td>
<td>
<p>which model to consider (see <a href="#topic+GetDiagnosticParameters">GetDiagnosticParameters</a>); cannot be NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Shows the estimated global NTR (i.e. for all reads used for estimation of
global paramters, what is the percentage of new RNA) for each sample.
</p>


<h3>Value</h3>

<p>a list with a ggplot object, a description, and the desired size for the plot
</p>

<hr>
<h2 id='PlotModelShape'>Diagnostic plot for estimated models (global shape parameter)</h2><span id='topic+PlotModelShape'></span>

<h3>Description</h3>

<p>This belongs to the third kind (model) of diagnostic plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotModelShape(data, label = "4sU", estimator = "Separate")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotModelShape_+3A_data">data</code></td>
<td>
<p>a grandR object</p>
</td></tr>
<tr><td><code id="PlotModelShape_+3A_label">label</code></td>
<td>
<p>which label to consider (see <a href="#topic+GetDiagnosticParameters">GetDiagnosticParameters</a>); cannot be NULL</p>
</td></tr>
<tr><td><code id="PlotModelShape_+3A_estimator">estimator</code></td>
<td>
<p>which estimator to consider (see <a href="#topic+GetDiagnosticParameters">GetDiagnosticParameters</a>); cannot be NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Shows the estimated shape parameter (describing the increase of 4sU over time) in the tbbinom model for each sample.
</p>


<h3>Value</h3>

<p>a list with a ggplot object, a description, and the desired size for the plot
</p>

<hr>
<h2 id='PlotPCA'>Make a PCA plot</h2><span id='topic+PlotPCA'></span>

<h3>Description</h3>

<p>Make a PCA plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotPCA(
  data,
  mode.slot = DefaultSlot(data),
  ntop = 500,
  aest = NULL,
  x = 1,
  y = 2,
  columns = NULL,
  do.vst = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotPCA_+3A_data">data</code></td>
<td>
<p>the grandR object that contains the data to plot</p>
</td></tr>
<tr><td><code id="PlotPCA_+3A_mode.slot">mode.slot</code></td>
<td>
<p>the mode and slot of data to plot; slot in the grandr object (eg &quot;count&quot;)</p>
</td></tr>
<tr><td><code id="PlotPCA_+3A_ntop">ntop</code></td>
<td>
<p>how many genes to use</p>
</td></tr>
<tr><td><code id="PlotPCA_+3A_aest">aest</code></td>
<td>
<p>parameter to set the visual attributes</p>
</td></tr>
<tr><td><code id="PlotPCA_+3A_x">x</code></td>
<td>
<p>number of principal component to show on the x axis (numeric)</p>
</td></tr>
<tr><td><code id="PlotPCA_+3A_y">y</code></td>
<td>
<p>number of principal component to show on the y axis (numeric)</p>
</td></tr>
<tr><td><code id="PlotPCA_+3A_columns">columns</code></td>
<td>
<p>which columns (i.e. samples or cells) to perform PCA on (see details)</p>
</td></tr>
<tr><td><code id="PlotPCA_+3A_do.vst">do.vst</code></td>
<td>
<p>perform a variance stabilizing transformation for count data?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Columns can be given as a logical, integer or character vector representing a selection of the columns (samples or cells).
The expression is evaluated in an environment having the <code><a href="#topic+Coldata">Coldata</a></code>, i.e. you can use names of <code><a href="#topic+Coldata">Coldata</a></code> as variables to
conveniently build a logical vector (e.g., columns=Condition==&quot;x&quot;).
</p>


<h3>Value</h3>

<p>a PCA plot
</p>

<hr>
<h2 id='PlotProfileLikelihood'>Diagnostic plot for estimated models (global error rate)</h2><span id='topic+PlotProfileLikelihood'></span>

<h3>Description</h3>

<p>This belongs to the fifth kind (profile likelihoods) of diagnostic plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotProfileLikelihood(
  data,
  label = "4sU",
  estimator = NULL,
  sample = NULL,
  subread = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotProfileLikelihood_+3A_data">data</code></td>
<td>
<p>a grandR object</p>
</td></tr>
<tr><td><code id="PlotProfileLikelihood_+3A_label">label</code></td>
<td>
<p>which label to consider (see <a href="#topic+GetDiagnosticParameters">GetDiagnosticParameters</a>); cannot be NULL</p>
</td></tr>
<tr><td><code id="PlotProfileLikelihood_+3A_estimator">estimator</code></td>
<td>
<p>which estimator to consider (see <a href="#topic+GetDiagnosticParameters">GetDiagnosticParameters</a>); cannot be NULL</p>
</td></tr>
<tr><td><code id="PlotProfileLikelihood_+3A_sample">sample</code></td>
<td>
<p>which sample to consider (see <a href="#topic+GetDiagnosticParameters">GetDiagnosticParameters</a>); cannot be NULL</p>
</td></tr>
<tr><td><code id="PlotProfileLikelihood_+3A_subread">subread</code></td>
<td>
<p>which subread to consider (see <a href="#topic+GetDiagnosticParameters">GetDiagnosticParameters</a>); cannot be NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Shows the profile likelihoods for all parameters of the tbbinom model.
</p>


<h3>Value</h3>

<p>a list with a ggplot object, a description, and the desired size for the plot
</p>

<hr>
<h2 id='Plots'>Stored plot functions</h2><span id='topic+Plots'></span><span id='topic+AddGenePlot'></span><span id='topic+AddGlobalPlot'></span><span id='topic+PlotGene'></span><span id='topic+PlotGlobal'></span><span id='topic+DropPlots'></span>

<h3>Description</h3>

<p>Get plot names and add or remove plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plots(data)

AddGenePlot(data, name, FUN)

AddGlobalPlot(data, name, FUN, floating = FALSE)

PlotGene(data, name, gene)

PlotGlobal(data, name)

DropPlots(data, pattern = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Plots_+3A_data">data</code></td>
<td>
<p>A grandR object</p>
</td></tr>
<tr><td><code id="Plots_+3A_name">name</code></td>
<td>
<p>The user-defined plot name</p>
</td></tr>
<tr><td><code id="Plots_+3A_fun">FUN</code></td>
<td>
<p>The plotting function to add</p>
</td></tr>
<tr><td><code id="Plots_+3A_floating">floating</code></td>
<td>
<p>whether or not the plot should be shown as a floating window</p>
</td></tr>
<tr><td><code id="Plots_+3A_gene">gene</code></td>
<td>
<p>The gene to plot</p>
</td></tr>
<tr><td><code id="Plots_+3A_pattern">pattern</code></td>
<td>
<p>A regular expression that is matched to plot names</p>
</td></tr>
</table>


<h3>Details</h3>

<p>FUN has to be a function with a single parameter for global plots (i.e., the grandR object) or two parameters for gene plots
(i.e., the grandR object and the gene name). Usually, it is either the name of a plotting function, such as <a href="#topic+PlotGeneOldVsNew">PlotGeneOldVsNew</a>, or, if it is
necessary to parametrize it, a call to <a href="#topic+Defer">Defer</a> (which takes care of caching plots without storing an additional copy of the grandR object).
</p>
<p>For floating window plots, if names are given in the format &lt;title&gt;.&lt;name&gt;, a plot is created for each &lt;title&gt; with several subplots.
</p>


<h3>Value</h3>

<p>Either the plot names or a grandR data with added/removed plots
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>Plots()</code>: Obtain the plot names
</p>
</li>
<li> <p><code>AddGenePlot()</code>: Add a gene plot to the grandR object
</p>
</li>
<li> <p><code>AddGlobalPlot()</code>: Add a global plot to the grandR object
</p>
</li>
<li> <p><code>PlotGene()</code>: Create a gene plot
</p>
</li>
<li> <p><code>PlotGlobal()</code>: Create a global plot
</p>
</li>
<li> <p><code>DropPlots()</code>: Remove plots from the grandR object
</p>
</li></ul>

<hr>
<h2 id='PlotScatter'>Make a scatter plot</h2><span id='topic+PlotScatter'></span>

<h3>Description</h3>

<p>Convenience method to compare two variables (slot data or analyses results).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotScatter(
  data,
  x = NULL,
  y = NULL,
  analysis = NULL,
  xcol = NULL,
  ycol = NULL,
  xlab = NULL,
  ylab = NULL,
  log = FALSE,
  log.x = log,
  log.y = log,
  axis = TRUE,
  axis.x = axis,
  axis.y = axis,
  remove.outlier = 1.5,
  show.outlier = TRUE,
  lim = NULL,
  xlim = lim,
  ylim = lim,
  size = 0.3,
  cross = NULL,
  diag = NULL,
  filter = NULL,
  genes = NULL,
  highlight = NULL,
  label = NULL,
  label.repel = 1,
  facet = NULL,
  color = NULL,
  colorpalette = NULL,
  color.label = NULL,
  density.margin = "n",
  density.n = 100,
  rasterize = NULL,
  correlation = NULL,
  correlation.x = -Inf,
  correlation.y = Inf,
  correlation.hjust = 0.5,
  correlation.vjust = 0.5,
  layers.below = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotScatter_+3A_data">data</code></td>
<td>
<p>the grandR object (can also be a plain data frame)</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_x">x</code></td>
<td>
<p>an expression to compute the x value or a character corresponding to a sample (or cell) name or a fully qualified analysis result name (see details)</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_y">y</code></td>
<td>
<p>an expression to compute the y value or a character corresponding to a sample (or cell) name or a fully qualified analysis result name (see details)</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_analysis">analysis</code></td>
<td>
<p>the name of an analysis table (can be NULL; see details)</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_xcol">xcol</code></td>
<td>
<p>a character corresponding to a sample (or cell) name or a fully qualified analysis result name (see details)</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_ycol">ycol</code></td>
<td>
<p>a character corresponding to a sample (or cell) name or a fully qualified analysis result name (see details)</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_xlab">xlab</code></td>
<td>
<p>the label for x (can be NULL, then the x parameter is used)</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_ylab">ylab</code></td>
<td>
<p>the label for y (can be NULL, then the y parameter is used)</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_log">log</code></td>
<td>
<p>if TRUE, use log scales for x and y axis</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_log.x">log.x</code></td>
<td>
<p>if TRUE, use log scale for the x axis</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_log.y">log.y</code></td>
<td>
<p>if TRUE, use log scale for the y axis</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_axis">axis</code></td>
<td>
<p>if FALSE, don't show x and y axes</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_axis.x">axis.x</code></td>
<td>
<p>if FALSE, don't show the x axis</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_axis.y">axis.y</code></td>
<td>
<p>if FALSE, don't show the y axis</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_remove.outlier">remove.outlier</code></td>
<td>
<p>configure how outliers are selected (is the coef parameter to <a href="grDevices.html#topic+boxplot.stats">boxplot.stats</a>); can be FALSE, in which case no points are considered outliers (see details)</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_show.outlier">show.outlier</code></td>
<td>
<p>if TRUE, show outlier as gray points at the border of the plotting plane</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_lim">lim</code></td>
<td>
<p>define the both x and y axis limits (vector of length 2 defining the lower and upper bound, respectively)</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_xlim">xlim</code></td>
<td>
<p>define the x axis limits (vector of length 2 defining the lower and upper bound, respectively)</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_ylim">ylim</code></td>
<td>
<p>define the y axis limits (vector of length 2 defining the lower and upper bound, respectively)</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_size">size</code></td>
<td>
<p>the point size to use</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_cross">cross</code></td>
<td>
<p>add horizontal and vertical lines through the origin?</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_diag">diag</code></td>
<td>
<p>if TRUE, add main diagonal; if numeric vector, add these diagonals</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_filter">filter</code></td>
<td>
<p>restrict to these rows; is evaluated for the data frame, and should result in a logical vector</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_genes">genes</code></td>
<td>
<p>restrict to these genes; can be either numeric indices, gene names, gene symbols or a logical vector</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_highlight">highlight</code></td>
<td>
<p>highlight these genes; can be either numeric indices, gene names, gene symbols or a logical vector (see details)</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_label">label</code></td>
<td>
<p>label these genes; can be either numeric indices, gene names, gene symbols or a logical vector (see details)</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_label.repel">label.repel</code></td>
<td>
<p>force to repel labels from points and each other (increase if labels overlap)</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_facet">facet</code></td>
<td>
<p>an expression (evaluated in the same environment as x and y); for each unique value a panel (facet) is created; can be NULL</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_color">color</code></td>
<td>
<p>either NULL (use point density colors), or a name of the <a href="#topic+GeneInfo">GeneInfo</a> table (use scale_color_xxx to define colors), or a color for all points</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_colorpalette">colorpalette</code></td>
<td>
<p>either NULL (use default colors), or a palette name from color brewer or viridis</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_color.label">color.label</code></td>
<td>
<p>the label for the color legend</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_density.margin">density.margin</code></td>
<td>
<p>for density colors, one of 'n','x' or 'y'; should the density be computed along both axes ('n'), or along 'x' or 'y' axis only</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_density.n">density.n</code></td>
<td>
<p>how many bins to use for density calculation (see <a href="MASS.html#topic+kde2d">kde2d</a>)</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_rasterize">rasterize</code></td>
<td>
<p>use ggrastr to rasterize points? (can be NULL, see details)</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_correlation">correlation</code></td>
<td>
<p>a function to format correlation statistics to be annotated (see details)</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_correlation.x">correlation.x</code></td>
<td>
<p>x coordinate to put the correlation annotation in the plot (see details)</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_correlation.y">correlation.y</code></td>
<td>
<p>y coordinate to put the correlation annotation in the plot (see details)</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_correlation.hjust">correlation.hjust</code></td>
<td>
<p>x adjustment to put the correlation annotation in the plot (see details)</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_correlation.vjust">correlation.vjust</code></td>
<td>
<p>y adjustment to put the correlation annotation in the plot (see details)</p>
</td></tr>
<tr><td><code id="PlotScatter_+3A_layers.below">layers.below</code></td>
<td>
<p>list of ggplot geoms to add before adding the layer containing the points</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both the x and y parameter are either expressions or names. Names are either sample (or cell, in case of single cell experiments) names or
fully qualified analysis results (analysis name followed by a dot and the analysis result table column). If the analysis parameter is given, the analysis
name must be omitted from x and y. These names can be used within expressions using non-standard evaluation.
Defining by names only works with character literals like &quot;kinetics.Synthesis&quot;, but if you give an expression (e.g. a variable name that contains a character),
the situation is more complicated, since PlotScatter will try to evaluate this for defining the values, not the name of the column. If the expression evaluates
into a single character string that is equal to a name (see above!), PlotScatter knows what to do. For more complicated situations that cannot be resolved by this,
you can use the xcol and ycol parameters instead of the x and y parameters!
</p>
<p>By default the limits of x and y axis are chosen after removing outliers (using the same algorithm used for <a href="graphics.html#topic+boxplot">boxplot</a>). Thus, larger numbers filter
less stringently. remove.outlier can also be set to FALSE (no outlier filtering). If xlim or ylim are set, this overrides outlier filtering. Points outside of the limits
(i.e. outliers or points outside of xlim or ylim) are set to infinity (such that they are shown at the border of the plot in gray)
</p>
<p>By default, all genes are shown. This can be restricted using the <code>genes</code> parameter (see <a href="#topic+ToIndex">ToIndex</a>). It is also possible to highlight a subset of the genes
using <code>highlight</code>. This parameter either describes a subset of the genes (either numeric indices, gene names, gene symbols or a logical vector), in which case these genes
are plotted in red and with larger points size, or it can be a list of such vectors. The names of this list must be valid colors. Genes can also be labeled (make sure that this
is really only a small subset of the genes).
</p>
<p>When rendering to vector based devices (such as svg or pds), a genome-wide scatterplot often is painfully big (and rendering therefore slow). The <code>rasterize</code>
parameter can be used to automatically rasterize the points only (via the ggrastr package). If this parameter is NULL, ggrastr is used if more than 1000 points are plotted!
</p>
<p>Often scatter plots show that x and y coordinates are correlated. Correlations can be annotated using the <a href="#topic+FormatCorrelation">FormatCorrelation</a> function. Most often you will use
<code>PlotScatter(data,x,y,correlation=FormatCorrelation())</code>. To use a different correlation measure, other formats for correlation coefficient and P values or omit one of these
statistics, parametrize <code>FormatCorrelation</code>. Use correlation.x and correlation.y to place the annotation in the plot, and correlation.hjust/correlation.vjust to align the
annotation at the given x,y coordinates. Infinite values for correlation.x/correlation.y will put the annotation at the border of the plot.
</p>


<h3>Value</h3>

<p>a ggplot object with the data frame used as the df attribute
</p>

<hr>
<h2 id='PlotSimulation'>Plot simulated data</h2><span id='topic+PlotSimulation'></span>

<h3>Description</h3>

<p>The input data is usually created by <code><a href="#topic+SimulateKinetics">SimulateKinetics</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotSimulation(
  sim.df,
  ntr = TRUE,
  old = TRUE,
  new = TRUE,
  total = TRUE,
  line.size = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotSimulation_+3A_sim.df">sim.df</code></td>
<td>
<p>the input data frame</p>
</td></tr>
<tr><td><code id="PlotSimulation_+3A_ntr">ntr</code></td>
<td>
<p>show the ntr?</p>
</td></tr>
<tr><td><code id="PlotSimulation_+3A_old">old</code></td>
<td>
<p>show old RNA?</p>
</td></tr>
<tr><td><code id="PlotSimulation_+3A_new">new</code></td>
<td>
<p>show new RNA?</p>
</td></tr>
<tr><td><code id="PlotSimulation_+3A_total">total</code></td>
<td>
<p>show total RNA?</p>
</td></tr>
<tr><td><code id="PlotSimulation_+3A_line.size">line.size</code></td>
<td>
<p>which line size to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>See Also</h3>

<p><a href="#topic+SimulateKinetics">SimulateKinetics</a> for creating the input data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PlotSimulation(SimulateKinetics(hl=2))
</code></pre>

<hr>
<h2 id='PlotTypeDistribution'>Plot the distribution of gene types</h2><span id='topic+PlotTypeDistribution'></span>

<h3>Description</h3>

<p>Plot the distribution of gene types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotTypeDistribution(data, mode.slot = DefaultSlot(data), relative = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotTypeDistribution_+3A_data">data</code></td>
<td>
<p>the grandR object to get the data to be plotted from</p>
</td></tr>
<tr><td><code id="PlotTypeDistribution_+3A_mode.slot">mode.slot</code></td>
<td>
<p>which mode and slot to use</p>
</td></tr>
<tr><td><code id="PlotTypeDistribution_+3A_relative">relative</code></td>
<td>
<p>show percentage values?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>

<hr>
<h2 id='PoolColumns'>Pool reads across columns</h2><span id='topic+PoolColumns'></span>

<h3>Description</h3>

<p>Pool read counts, ntrs, and alpha/beta values across columns defined by a pooling matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoolColumns(
  data,
  pooling = GetSummarizeMatrix(data, average = FALSE, no4sU = TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoolColumns_+3A_data">data</code></td>
<td>
<p>grandR object</p>
</td></tr>
<tr><td><code id="PoolColumns_+3A_pooling">pooling</code></td>
<td>
<p>a pooling matrix (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pooling matrix must have as many rows as there are columns (i.e., samples or cells) in data,
and as many columns as you want to have columns in the resulting object. The matrix should consist of 0 and 1,
where 1 indicates a column of the original object that should go into a column of the new object. In essence,
to obtain the new count matrix, the old count matrix is matrix-multiplied with the pooling matrix.
</p>
<p>The new ntr matrix is computed by componentwise division of the new count and total count matrices derived
as just described. alpha and beta are computed using matrix multiplication, i.e. summing up all alpha and beta values
of all the columns belonging to a pool.
</p>


<h3>Value</h3>

<p>a new grandR object
</p>

<hr>
<h2 id='psapply'>Parallel (s/l)apply</h2><span id='topic+psapply'></span><span id='topic+plapply'></span>

<h3>Description</h3>

<p>Depending on whether <a href="#topic+SetParallel">SetParallel</a> has been called, execute in parallel or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psapply(..., seed = NULL)

plapply(..., seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psapply_+3A_...">...</code></td>
<td>
<p>forwarded to lapply or parallel::mclapply</p>
</td></tr>
<tr><td><code id="psapply_+3A_seed">seed</code></td>
<td>
<p>Seed for the random number generator</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the code uses random number specify the seed to make it deterministic
</p>


<h3>Value</h3>

<p>a vector (psapply) or list (plapply)
</p>

<hr>
<h2 id='ReadCounts'>Read a count table</h2><span id='topic+ReadCounts'></span>

<h3>Description</h3>

<p>grandR can also be used to analyze standard RNA-seq data, and this function is here to read such data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadCounts(
  file,
  design = c(Design$Condition, Design$Replicate),
  classify.genes = ClassifyGenes(),
  rename.sample = NULL,
  filter.table = NULL,
  num.samples = NULL,
  verbose = FALSE,
  sep = "\t"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReadCounts_+3A_file">file</code></td>
<td>
<p>a file containing a count matrix</p>
</td></tr>
<tr><td><code id="ReadCounts_+3A_design">design</code></td>
<td>
<p>Either a design vector (see details), or a data.frame providing metadata for all columns (samples/cells),
or a function that is called with the condition name vector and is supposed to return this data.frame.</p>
</td></tr>
<tr><td><code id="ReadCounts_+3A_classify.genes">classify.genes</code></td>
<td>
<p>A function that is used to add the <em>type</em> column to the gene annotation table, always a call to <a href="#topic+ClassifyGenes">ClassifyGenes</a></p>
</td></tr>
<tr><td><code id="ReadCounts_+3A_rename.sample">rename.sample</code></td>
<td>
<p>function that is applied to each sample name before parsing (or NULL)</p>
</td></tr>
<tr><td><code id="ReadCounts_+3A_filter.table">filter.table</code></td>
<td>
<p>function that is applied to the table directly after read it (or NULL)</p>
</td></tr>
<tr><td><code id="ReadCounts_+3A_num.samples">num.samples</code></td>
<td>
<p>number of sample columns containing read counts (can be NULL, see details)</p>
</td></tr>
<tr><td><code id="ReadCounts_+3A_verbose">verbose</code></td>
<td>
<p>Print status updates</p>
</td></tr>
<tr><td><code id="ReadCounts_+3A_sep">sep</code></td>
<td>
<p>The column separator used in the file</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The table is assumed to have read counts in the last n columns, which must be named according to sample names.
If num.samples is NULL this n is automatically recognized as the number of numeric columns (so make sure to either
specify num.samples, or that the column immediately prior to the first sample column is *not* numeric).
</p>
<p>If these columns are named systematically in a particular way, the design vector provides
a powerful and easy way to create the column annotations.
</p>
<p>The column names have to contain dots (.) to separate the fields for the column annotation table.
E.g. the name <em>Mock.4h.A</em> will be split into the fields <em>Mock</em>, <em>4h</em> and  <em>A</em>.
For such names, a design vector of length 3 has to be given, that describes the meaning of each field.
A reasonable design vector for the example would be <code>c("Treatment","Time","Replicate")</code>.
Some names are predefined in the list <a href="#topic+Design">Design</a>.
</p>
<p>The names given in the design vector might even have additional semantics:
E.g. for the name <em>duration.4sU</em> the values are interpreted (e.g. 4h is converted into the number 4,
or 30min into 0.5, or no4sU into 0). Semantics can be user-defined by calling <code><a href="#topic+MakeColdata">MakeColdata</a></code>
and using the return value as the design parameter, or a function that calls MakeColdata.
In most cases it is easier to manipulate the <code><a href="#topic+Coldata">Coldata</a></code> table after loading data instead of using this mechanism;
the build-in semantics simply provide a convenient way to reduce this kind of manipulation in most cases.
</p>
<p>Sometimes you might have forgotten to name all samples consistently (or you simply messed something up).
In this case, the rename.sample parameter can be handy (e.g. to rename a particular misnamed sample).
</p>
<p>Sometimes the table contains more than you want to read. In this case, use the filter.table parameter to preprocess it.
This should be a function that receives a data.frame, and returns a data.frame.
</p>
<p>If there are no columns named &quot;Gene&quot; or &quot;Symbol&quot;, the first column is used!
</p>


<h3>Value</h3>

<p>a grandR object
</p>

<hr>
<h2 id='ReadFeatureCounts'>Read featureCounts</h2><span id='topic+ReadFeatureCounts'></span>

<h3>Description</h3>

<p>grandR can also be used to analyze standard RNA-seq data, and this function is here to read such data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadFeatureCounts(
  file,
  design = c(Design$Condition, Design$Replicate),
  classify.genes = ClassifyGenes(),
  rename.sample = NULL,
  filter.table = NULL,
  num.samples = NULL,
  verbose = FALSE,
  sep = "\t"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReadFeatureCounts_+3A_file">file</code></td>
<td>
<p>a file containing featureCounts</p>
</td></tr>
<tr><td><code id="ReadFeatureCounts_+3A_design">design</code></td>
<td>
<p>Either a design vector (see details), or a data.frame providing metadata for all columns (samples/cells),
or a function that is called with the condition name vector and is supposed to return this data.frame.</p>
</td></tr>
<tr><td><code id="ReadFeatureCounts_+3A_classify.genes">classify.genes</code></td>
<td>
<p>A function that is used to add the <em>type</em> column to the gene annotation table, always a call to <a href="#topic+ClassifyGenes">ClassifyGenes</a></p>
</td></tr>
<tr><td><code id="ReadFeatureCounts_+3A_rename.sample">rename.sample</code></td>
<td>
<p>function that is applied to each sample name before parsing (or NULL)</p>
</td></tr>
<tr><td><code id="ReadFeatureCounts_+3A_filter.table">filter.table</code></td>
<td>
<p>function that is applied to the table directly after read it (or NULL)</p>
</td></tr>
<tr><td><code id="ReadFeatureCounts_+3A_num.samples">num.samples</code></td>
<td>
<p>number of sample columns containing read counts (can be NULL, see details)</p>
</td></tr>
<tr><td><code id="ReadFeatureCounts_+3A_verbose">verbose</code></td>
<td>
<p>Print status updates</p>
</td></tr>
<tr><td><code id="ReadFeatureCounts_+3A_sep">sep</code></td>
<td>
<p>The column separator used in the file</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The table is assumed to have read counts in the last n columns, which must be named according to sample names.
If num.samples is NULL this n is automatically recognized as the number of columns containing .bam (so make sure to either
specify num.samples, or that the count columns are called after the bam files).
</p>
<p>If these columns are named systematically in a particular way, the design vector provides
a powerful and easy way to create the column annotations.
</p>
<p>The column names have to contain dots (.) to separate the fields for the column annotation table.
E.g. the name <em>Mock.4h.A</em> will be split into the fields <em>Mock</em>, <em>4h</em> and  <em>A</em>.
For such names, a design vector of length 3 has to be given, that describes the meaning of each field.
A reasonable design vector for the example would be <code>c("Treatment","Time","Replicate")</code>.
Some names are predefined in the list <a href="#topic+Design">Design</a>.
</p>
<p>The names given in the design vector might even have additional semantics:
E.g. for the name <em>duration.4sU</em> the values are interpreted (e.g. 4h is converted into the number 4,
or 30min into 0.5, or no4sU into 0). Semantics can be user-defined by calling <code><a href="#topic+MakeColdata">MakeColdata</a></code>
and using the return value as the design parameter, or a function that calls MakeColdata.
In most cases it is easier to manipulate the <code><a href="#topic+Coldata">Coldata</a></code> table after loading data instead of using this mechanism;
the build-in semantics simply provide a convenient way to reduce this kind of manipulation in most cases.
</p>
<p>Sometimes you might have forgotten to name all samples consistently (or you simply messed something up).
In this case, the rename.sample parameter can be handy (e.g. to rename a particular misnamed sample).
</p>
<p>Sometimes the table contains more than you want to read. In this case, use the filter.table parameter to preprocess it.
This should be a function that receives a data.frame, and returns a data.frame.
</p>
<p>If there are no columns named &quot;Geneid&quot;, &quot;Gene&quot; or &quot;Symbol&quot;, the first column is used!
</p>


<h3>Value</h3>

<p>a grandR object
</p>

<hr>
<h2 id='ReadGRAND'>Read the output of GRAND-SLAM 2.0 into a grandR object.</h2><span id='topic+ReadGRAND'></span>

<h3>Description</h3>

<p>Metabolic labeling - nucleotide conversion RNA-seq data (such as generated by SLAM-seq,TimeLapse-seq or TUC-seq)
must be carefully analyzed to remove bias due to incomplete labeling. GRAND-SLAM is a software package that
employs a binomial mixture modeling approach to obtain precise estimates of the new-to-total RNA ratio (NTR) per gene and sample (or cell).
This function directly reads the output of GRAND-SLAM 2.0 into a grandR object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadGRAND(
  prefix,
  design = c(Design$Condition, Design$Replicate),
  classify.genes = ClassifyGenes(),
  read.percent.conv = FALSE,
  read.min2 = FALSE,
  rename.sample = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReadGRAND_+3A_prefix">prefix</code></td>
<td>
<p>Can either be the prefix used to call GRAND-SLAM with, or the main output file ($prefix.tsv.gz);
if the RCurl package is installed, this can also be a URL</p>
</td></tr>
<tr><td><code id="ReadGRAND_+3A_design">design</code></td>
<td>
<p>Either a design vector (see details), or a data.frame providing metadata for all columns (samples/cells),
or a function that is called with the condition name vector and is supposed to return this data.frame.</p>
</td></tr>
<tr><td><code id="ReadGRAND_+3A_classify.genes">classify.genes</code></td>
<td>
<p>A function that is used to add the <em>type</em> column to the gene annotation table, always a call to <a href="#topic+ClassifyGenes">ClassifyGenes</a></p>
</td></tr>
<tr><td><code id="ReadGRAND_+3A_read.percent.conv">read.percent.conv</code></td>
<td>
<p>Should the percentage of conversions also be read?</p>
</td></tr>
<tr><td><code id="ReadGRAND_+3A_read.min2">read.min2</code></td>
<td>
<p>Should the read count with at least 2 mismatches also be read?</p>
</td></tr>
<tr><td><code id="ReadGRAND_+3A_rename.sample">rename.sample</code></td>
<td>
<p>function that is applied to each sample name before parsing (or NULL)</p>
</td></tr>
<tr><td><code id="ReadGRAND_+3A_verbose">verbose</code></td>
<td>
<p>Print status updates</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If columns (samples/cells) are named systematically in a particular way, the design vector provides
a powerful and easy way to create the column annotations.
</p>
<p>The column names have to contain dots (.) to separate the fields for the column annotation table.
E.g. the name <em>Mock.4h.A</em> will be split into the fields <em>Mock</em>, <em>4h</em> and  <em>A</em>.
For such names, a design vector of length 3 has to be given, that describes the meaning of each field.
A reasonable design vector for the example would be <code>c("Treatment","Time","Replicate")</code>.
Some names are predefined in the list <a href="#topic+Design">Design</a>.
</p>
<p>The names given in the design vector might even have additional semantics:
E.g. for the name <em>duration.4sU</em> the values are interpreted (e.g. 4h is converted into the number 4,
or 30min into 0.5, or no4sU into 0). Semantics can be user-defined by calling <code><a href="#topic+MakeColdata">MakeColdata</a></code>
and using the return value as the design parameter, or a function that calls MakeColdata.
In most cases it is easier to manipulate the <code><a href="#topic+Coldata">Coldata</a></code> table after loading data instead of using this mechanism;
the build-in semantics simply provide a convenient way to reduce this kind of manipulation in most cases.
</p>
<p>Sometimes you might have forgotten to name all samples consistently (or you simply messed something up).
In this case, the rename.sample parameter can be handy (e.g. to rename a particular misnamed sample).
</p>


<h3>Value</h3>

<p>A grandR object containing the read counts, NTRs, information on the NTR posterior distribution (alpha,beta)
and potentially additional information of all genes detected by GRAND-SLAM
</p>


<h3>See Also</h3>

<p><a href="#topic+ReadGRAND3">ReadGRAND3</a>,<a href="#topic+ClassifyGenes">ClassifyGenes</a>,<a href="#topic+MakeColdata">MakeColdata</a>,<a href="#topic+DesignSemantics">DesignSemantics</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sars &lt;- ReadGRAND("https://zenodo.org/record/5834034/files/sars.tsv.gz",
                      design=c("Cell",Design$dur.4sU,Design$Replicate), verbose=TRUE)


</code></pre>

<hr>
<h2 id='ReadGRAND3'>Read the output of GRAND-SLAM 3.0 into a grandR object.</h2><span id='topic+ReadGRAND3'></span>

<h3>Description</h3>

<p>Metabolic labeling - nucleotide conversion RNA-seq data (such as generated by SLAM-seq,TimeLapse-seq or TUC-seq)
must be carefully analyzed to remove bias due to incomplete labeling. GRAND-SLAM is a software package that
employs a binomial mixture modeling approach to obtain precise estimates of the new-to-total RNA ratio (NTR) per gene and sample (or cell).
This function directly reads the output of GRAND-SLAM 3.0 into a grandR object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadGRAND3(
  prefix,
  design = NULL,
  label = "4sU",
  estimator = "Binom",
  classify.genes = ClassifyGenes(),
  read.posterior = NULL,
  rename.sample = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReadGRAND3_+3A_prefix">prefix</code></td>
<td>
<p>the prefix used to call GRAND-SLAM</p>
</td></tr>
<tr><td><code id="ReadGRAND3_+3A_design">design</code></td>
<td>
<p>Either a design vector (see details), or a data.frame providing metadata for all columns (samples/cells),
or a function that is called with the condition name vector and is supposed to return this data.frame. if NULL, a
library,sample,barcode design is used for sparse data, and a condition,replicate design for dense data</p>
</td></tr>
<tr><td><code id="ReadGRAND3_+3A_label">label</code></td>
<td>
<p>which nucleoside analog</p>
</td></tr>
<tr><td><code id="ReadGRAND3_+3A_estimator">estimator</code></td>
<td>
<p>which estimator to use (one of Binom,TbBinom,TbBinomShape)</p>
</td></tr>
<tr><td><code id="ReadGRAND3_+3A_classify.genes">classify.genes</code></td>
<td>
<p>A function that is used to add the <em>type</em> column to the gene annotation table, always a call to <a href="#topic+ClassifyGenes">ClassifyGenes</a></p>
</td></tr>
<tr><td><code id="ReadGRAND3_+3A_read.posterior">read.posterior</code></td>
<td>
<p>also read the posterior parameters alpha and beta? if NULL, TRUE for dense data, FALSE for sparse data</p>
</td></tr>
<tr><td><code id="ReadGRAND3_+3A_rename.sample">rename.sample</code></td>
<td>
<p>function that is applied to each sample name before parsing (or NULL)</p>
</td></tr>
<tr><td><code id="ReadGRAND3_+3A_verbose">verbose</code></td>
<td>
<p>Print status updates</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If columns (samples/cells) are named systematically in a particular way, the design vector provides
a powerful and easy way to create the column annotations.
</p>
<p>The column names have to contain dots (.) to separate the fields for the column annotation table.
E.g. the name <em>Mock.4h.A</em> will be split into the fields <em>Mock</em>, <em>4h</em> and  <em>A</em>.
For such names, a design vector of length 3 has to be given, that describes the meaning of each field.
A reasonable design vector for the example would be <code>c("Treatment","Time","Replicate")</code>.
Some names are predefined in the list <a href="#topic+Design">Design</a>.
</p>
<p>The names given in the design vector might even have additional semantics:
E.g. for the name <em>duration.4sU</em> the values are interpreted (e.g. 4h is converted into the number 4,
or 30min into 0.5, or no4sU into 0). Semantics can be user-defined by calling <code><a href="#topic+MakeColdata">MakeColdata</a></code>
and using the return value as the design parameter, or a function that calls MakeColdata.
In most cases it is easier to manipulate the <code><a href="#topic+Coldata">Coldata</a></code> table after loading data instead of using this mechanism;
the build-in semantics simply provide a convenient way to reduce this kind of manipulation in most cases.
</p>
<p>Sometimes you might have forgotten to name all samples consistently (or you simply messed something up).
In this case, the rename.sample parameter can be handy (e.g. to rename a particular misnamed sample).
</p>


<h3>Value</h3>

<p>A grandR object containing the read counts, NTRs, information on the NTR posterior distribution (alpha,beta)
and potentially additional information of all genes detected by GRAND-SLAM
</p>


<h3>See Also</h3>

<p><a href="#topic+ReadGRAND">ReadGRAND</a>,<a href="#topic+ClassifyGenes">ClassifyGenes</a>,<a href="#topic+MakeColdata">MakeColdata</a>,<a href="#topic+DesignSemantics">DesignSemantics</a>
</p>

<hr>
<h2 id='ReadNewTotal'>Read sparse new/total matrices</h2><span id='topic+ReadNewTotal'></span>

<h3>Description</h3>

<p>This function can be used to load matrix market data in case genes were quantified by
(i) counting all reads (for total RNA) and (ii) counting T-to-C mismatch reads (for new RNA)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadNewTotal(
  genes,
  cells,
  new.matrix,
  total.matrix,
  detection.rate = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReadNewTotal_+3A_genes">genes</code></td>
<td>
<p>csv file (or URL) containing gene information</p>
</td></tr>
<tr><td><code id="ReadNewTotal_+3A_cells">cells</code></td>
<td>
<p>csv file (or URL) containing cell information</p>
</td></tr>
<tr><td><code id="ReadNewTotal_+3A_new.matrix">new.matrix</code></td>
<td>
<p>Matrix market file of new counts</p>
</td></tr>
<tr><td><code id="ReadNewTotal_+3A_total.matrix">total.matrix</code></td>
<td>
<p>Matrix market file of total counts</p>
</td></tr>
<tr><td><code id="ReadNewTotal_+3A_detection.rate">detection.rate</code></td>
<td>
<p>the detection rate of T-to-C mismatch reads (see details)</p>
</td></tr>
<tr><td><code id="ReadNewTotal_+3A_verbose">verbose</code></td>
<td>
<p>verbose output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Metabolic labeling - nucleotide conversion RNA-seq data (such as generated by SLAM-seq,TimeLapse-seq or TUC-seq)
must be carefully analyzed to remove bias due to incomplete labeling. We advice against counting read with and without T-to-C mismatches
for quantification, and encourage using a statistical method such as GRAND-SLAM that properly deals with incomplete labeling.
</p>
<p>To correct for some bias, a detection rate (as suggested by Cao et al., Nature Biotech 2020) should be provided. This detection rate
defines, how much new RNA is detected on average using the T-to-C mismatch reads.
</p>


<h3>Value</h3>

<p>a grandR object
</p>

<hr>
<h2 id='RotatateAxisLabels'>Rotate x axis labels</h2><span id='topic+RotatateAxisLabels'></span>

<h3>Description</h3>

<p>Add this to a ggplot object to rotate the x axis labels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RotatateAxisLabels(angle = 90)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RotatateAxisLabels_+3A_angle">angle</code></td>
<td>
<p>the angle by which to rotate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot theme object
</p>

<hr>
<h2 id='SaveNtrSlot'>Copy the NTR slot and save under new name</h2><span id='topic+SaveNtrSlot'></span>

<h3>Description</h3>

<p>Copy the NTR slot and save under new name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SaveNtrSlot(data, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SaveNtrSlot_+3A_data">data</code></td>
<td>
<p>the grandR object</p>
</td></tr>
<tr><td><code id="SaveNtrSlot_+3A_name">name</code></td>
<td>
<p>the name of the new slot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a grandR object
</p>

<hr>
<h2 id='Scale'>Scale data</h2><span id='topic+Scale'></span>

<h3>Description</h3>

<p>Compute values for all genes standardized (i.e. z scores) across samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Scale(
  data,
  name = "scaled",
  slot = DefaultSlot(data),
  set.to.default = FALSE,
  group = NULL,
  center = TRUE,
  scale = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Scale_+3A_data">data</code></td>
<td>
<p>a grandR object</p>
</td></tr>
<tr><td><code id="Scale_+3A_name">name</code></td>
<td>
<p>the new slot name</p>
</td></tr>
<tr><td><code id="Scale_+3A_slot">slot</code></td>
<td>
<p>the slot from where to take values</p>
</td></tr>
<tr><td><code id="Scale_+3A_set.to.default">set.to.default</code></td>
<td>
<p>set the new slot as default slot</p>
</td></tr>
<tr><td><code id="Scale_+3A_group">group</code></td>
<td>
<p>Perform standardization per group of columns (see details)</p>
</td></tr>
<tr><td><code id="Scale_+3A_center">center</code></td>
<td>
<p>Perform centering (forwarded to <a href="base.html#topic+scale">scale</a>)</p>
</td></tr>
<tr><td><code id="Scale_+3A_scale">scale</code></td>
<td>
<p>Perform scaling (forwarded to <a href="base.html#topic+scale">scale</a>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Standardization can be done per group. For this, the group parameter has to be a name of the <code><a href="#topic+Coldata">Coldata</a></code> table,
to define groups of columns (i.e. samples or cells).
</p>


<h3>Value</h3>

<p>a new grandR object with a new slot
</p>


<h3>See Also</h3>

<p><a href="base.html#topic+scale">scale</a>
</p>

<hr>
<h2 id='Semantics.concentration'>Semantics for concentration columns</h2><span id='topic+Semantics.concentration'></span>

<h3>Description</h3>

<p>Defines additional semantics for columns representing concentrations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Semantics.concentration(s, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Semantics.concentration_+3A_s">s</code></td>
<td>
<p>original column</p>
</td></tr>
<tr><td><code id="Semantics.concentration_+3A_name">name</code></td>
<td>
<p>the column name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with a single numeric column, where &lt;x&gt;uM from s is replaced by x, &lt;x&gt;mM is replaced by
x*1000, and no4sU is replaced by 0
</p>

<hr>
<h2 id='Semantics.time'>Semantics for time columns</h2><span id='topic+Semantics.time'></span>

<h3>Description</h3>

<p>Defines additional semantics for columns representing temporal dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Semantics.time(s, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Semantics.time_+3A_s">s</code></td>
<td>
<p>original column</p>
</td></tr>
<tr><td><code id="Semantics.time_+3A_name">name</code></td>
<td>
<p>the column name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with a single numeric column, where &lt;x&gt;h from s is replaced by x, &lt;x&gt;min is replaced by
x/60, and no4sU is replaced by 0
</p>

<hr>
<h2 id='ServeGrandR'>Serve a shiny web interface</h2><span id='topic+ServeGrandR'></span>

<h3>Description</h3>

<p>Fire up a shiny web server for exploratory analysis of grandR data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ServeGrandR(
  data,
  table = NULL,
  sizes = NA,
  height = 400,
  plot.gene = NULL,
  plot.global = NULL,
  plot.window = NULL,
  highlight = NULL,
  df.identifier = "Symbol",
  title = Title(data),
  show.sessionInfo = FALSE,
  help = list(".Q: multiple testing corrected p values", ".LFC: log2 fold changes")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ServeGrandR_+3A_data">data</code></td>
<td>
<p>the grandR object (or a file name to an rds file containing a grandR object)</p>
</td></tr>
<tr><td><code id="ServeGrandR_+3A_table">table</code></td>
<td>
<p>the table to display (can be NULL or a named list; see details)</p>
</td></tr>
<tr><td><code id="ServeGrandR_+3A_sizes">sizes</code></td>
<td>
<p>the widths for the gene plots to show (12 is full screen with); must be a vector as long as there are gene plots</p>
</td></tr>
<tr><td><code id="ServeGrandR_+3A_height">height</code></td>
<td>
<p>the height for the gene plots in pixel</p>
</td></tr>
<tr><td><code id="ServeGrandR_+3A_plot.gene">plot.gene</code></td>
<td>
<p>a list of gene plots; can be NULL, then the stored gene plots are used (see <a href="#topic+Plots">Plots</a>)</p>
</td></tr>
<tr><td><code id="ServeGrandR_+3A_plot.global">plot.global</code></td>
<td>
<p>a list of global plots; can be NULL, then the stored global plots are used (see <a href="#topic+Plots">Plots</a>)</p>
</td></tr>
<tr><td><code id="ServeGrandR_+3A_plot.window">plot.window</code></td>
<td>
<p>a list of static plots to show in a floating window; see details</p>
</td></tr>
<tr><td><code id="ServeGrandR_+3A_highlight">highlight</code></td>
<td>
<p>a vector of gene names that are highlighted in the beginning</p>
</td></tr>
<tr><td><code id="ServeGrandR_+3A_df.identifier">df.identifier</code></td>
<td>
<p>the main identifier (column name) from the table; this is used when calling the gene plot functions;</p>
</td></tr>
<tr><td><code id="ServeGrandR_+3A_title">title</code></td>
<td>
<p>the title to show in the header of the website</p>
</td></tr>
<tr><td><code id="ServeGrandR_+3A_show.sessioninfo">show.sessionInfo</code></td>
<td>
<p>whether to show session info</p>
</td></tr>
<tr><td><code id="ServeGrandR_+3A_help">help</code></td>
<td>
<p>a list of characters that is shown as help text at the beginning (when no gene plot is shown); should describe the contents of your table</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the table parameter is NULL, either an analysis table named &quot;ServeGrandR&quot; is
used (if it exists), otherwise the columns &quot;Q&quot;, &quot;LFC&quot;, &quot;Synthesis&quot; and &quot;Half-life&quot; of all analysis tables are used. If it is a list, a menu is created in the navbar
</p>
<p>plot.window must be a list of plotting functions that receive the grandR object and return a plot. It can also be a list of list, in which case more than one plotting windows are generated.
Each plot will be rendered with a size of 350x350.
</p>
<p>The gene plots must be functions that accept two parameters: the grandR object and a gene identifier. You can either use
functions directly (e.g. <code>plot.gene=list(PlotGeneOldVsNew)</code>), or use <a href="#topic+Defer">Defer</a> in cases you need to specify additional parameters,
e.g. <code>plot.gene=list(Defer(PlotGeneOldVsNew,log=FALSE))</code>. The global plots are functions accepting a single parameter (the grandR object). Here
the use of <a href="#topic+Defer">Defer</a> is encouraged due to its caching mechanism.
</p>


<h3>Value</h3>

<p>a shiny web server
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sars &lt;- ReadGRAND(system.file("extdata", "sars.tsv.gz", package = "grandR"),
                  design=c("Condition",Design$dur.4sU,Design$Replicate))
sars &lt;- Normalize(sars)
sars &lt;- Pairwise(sars,contrasts = GetContrasts(sars,contrast = c("Condition","SARS","Mock")))
sars &lt;- AddGenePlot(sars,"timecourse",
                    Defer(PlotGeneProgressiveTimecourse,steady.state=c(Mock=TRUE,SARS=FALSE)))
sars &lt;- AddGlobalPlot(sars,"Vulcano",VulcanoPlot)
ServeGrandR(sars)


## End(Not run)

</code></pre>

<hr>
<h2 id='SetParallel'>Set up parallel execution</h2><span id='topic+SetParallel'></span>

<h3>Description</h3>

<p>Set the number of cores for parallel execution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SetParallel(cores = max(1, parallel::detectCores() - 2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SetParallel_+3A_cores">cores</code></td>
<td>
<p>number of cores</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Whenever <a href="#topic+psapply">psapply</a> or <a href="#topic+plapply">plapply</a> are used, they are executed in parallel.
</p>


<h3>Value</h3>

<p>No return value, called for side effects
</p>

<hr>
<h2 id='SimulateKinetics'>Simulate the kinetics of old and new RNA for given parameters.</h2><span id='topic+SimulateKinetics'></span>

<h3>Description</h3>

<p>The standard mass action kinetics model of gene expression arises from the differential equation
<code class="reqn">df/dt = s - d  f(t)</code>, with s being the constant synthesis rate, d the constant degradation rate and <code class="reqn">f0=f(0)</code> (the abundance at time 0).
The RNA half-life is directly related to d via <code class="reqn">HL=log(2)/d</code>.
This model dictates the time evolution of old and new RNA abundance after metabolic labeling starting at time t=0.
This function simulates data according to this model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimulateKinetics(
  s = 100 * d,
  d = log(2)/hl,
  hl = 2,
  f0 = NULL,
  min.time = -1,
  max.time = 10,
  N = 1000,
  name = NULL,
  out = c("Old", "New", "Total", "NTR")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SimulateKinetics_+3A_s">s</code></td>
<td>
<p>the synthesis rate (see details)</p>
</td></tr>
<tr><td><code id="SimulateKinetics_+3A_d">d</code></td>
<td>
<p>the degradation rate (see details)</p>
</td></tr>
<tr><td><code id="SimulateKinetics_+3A_hl">hl</code></td>
<td>
<p>the RNA half-life</p>
</td></tr>
<tr><td><code id="SimulateKinetics_+3A_f0">f0</code></td>
<td>
<p>the abundance at time t=0</p>
</td></tr>
<tr><td><code id="SimulateKinetics_+3A_min.time">min.time</code></td>
<td>
<p>the start time to simulate</p>
</td></tr>
<tr><td><code id="SimulateKinetics_+3A_max.time">max.time</code></td>
<td>
<p>the end time to simulate</p>
</td></tr>
<tr><td><code id="SimulateKinetics_+3A_n">N</code></td>
<td>
<p>how many time points from min.time to max.time to simuate</p>
</td></tr>
<tr><td><code id="SimulateKinetics_+3A_name">name</code></td>
<td>
<p>add a Name column to the resulting data frame</p>
</td></tr>
<tr><td><code id="SimulateKinetics_+3A_out">out</code></td>
<td>
<p>which values to put into the data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both rates can be either (i) a single number (constant rate), (ii) a data frame with names &quot;offset&quot;,
&quot;factor&quot; and &quot;exponent&quot; (for linear functions, see <a href="#topic+ComputeNonConstantParam">ComputeNonConstantParam</a>) or (iii) a unary function time-&gt;rate. Functions
</p>


<h3>Value</h3>

<p>a data frame containing the simulated values
</p>


<h3>See Also</h3>

<p><a href="#topic+PlotSimulation">PlotSimulation</a> for plotting the simulation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(SimulateKinetics(hl=2))   # simulate steady state kinetics for an RNA with half-life 2h

</code></pre>

<hr>
<h2 id='SimulateReadsForSample'>Simulate metabolic labeling - nucleotide conversion RNA-seq data.</h2><span id='topic+SimulateReadsForSample'></span>

<h3>Description</h3>

<p>This function takes a vector of <em>true</em> relative abundances and NTRs, and then simulates
(i) read counts per gene and (ii) 4sU incorporation and conversion events. Subsequently, it
uses the same approach as implemented in the GRAND-SLAM 2.0 software (Juerges et al., Bioinformatics 2018)
to estimate the NTR from these simulated data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimulateReadsForSample(
  num.reads = 2e+07,
  rel.abundance = setNames(rlnorm(10000, meanlog = 4.5, sdlog = 1), paste0("Gene",
    1:10000)),
  ntr = setNames(rbeta(10000, 1.5, 3), paste0("Gene", 1:10000)),
  dispersion = 0.05,
  beta.approx = FALSE,
  conversion.reads = FALSE,
  u.content = 0.25,
  u.content.sd = 0.05,
  read.length = 75,
  p.old = 1e-04,
  p.new = 0.04,
  p.new.fit = p.new,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SimulateReadsForSample_+3A_num.reads">num.reads</code></td>
<td>
<p>the total amount of reads for simulation</p>
</td></tr>
<tr><td><code id="SimulateReadsForSample_+3A_rel.abundance">rel.abundance</code></td>
<td>
<p>named (according to genes) vector of the true relative abundances. Is divided by its sum.</p>
</td></tr>
<tr><td><code id="SimulateReadsForSample_+3A_ntr">ntr</code></td>
<td>
<p>vector of true NTRs</p>
</td></tr>
<tr><td><code id="SimulateReadsForSample_+3A_dispersion">dispersion</code></td>
<td>
<p>vector of dispersion parameters (should best be estimated by DESeq2)</p>
</td></tr>
<tr><td><code id="SimulateReadsForSample_+3A_beta.approx">beta.approx</code></td>
<td>
<p>should the beta approximation of the NTR posterior be computed?</p>
</td></tr>
<tr><td><code id="SimulateReadsForSample_+3A_conversion.reads">conversion.reads</code></td>
<td>
<p>also output the number of reads with conversion</p>
</td></tr>
<tr><td><code id="SimulateReadsForSample_+3A_u.content">u.content</code></td>
<td>
<p>the relative frequency of uridines in the reads</p>
</td></tr>
<tr><td><code id="SimulateReadsForSample_+3A_u.content.sd">u.content.sd</code></td>
<td>
<p>the standard deviation of the u content</p>
</td></tr>
<tr><td><code id="SimulateReadsForSample_+3A_read.length">read.length</code></td>
<td>
<p>the read length for simulation</p>
</td></tr>
<tr><td><code id="SimulateReadsForSample_+3A_p.old">p.old</code></td>
<td>
<p>the probability for a conversion in reads originating from old RNA</p>
</td></tr>
<tr><td><code id="SimulateReadsForSample_+3A_p.new">p.new</code></td>
<td>
<p>the probability for a conversion in reads originating from new RNA</p>
</td></tr>
<tr><td><code id="SimulateReadsForSample_+3A_p.new.fit">p.new.fit</code></td>
<td>
<p>the probability for a conversion in reads originating from new RNA that is used for fitting (to simulate bias in the estimation of p.new)</p>
</td></tr>
<tr><td><code id="SimulateReadsForSample_+3A_seed">seed</code></td>
<td>
<p>seed value for the random number generator (set to make it deterministic!)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simulation proceeds as follows:
</p>

<ol>
<li><p> Draw for each gene the number of reads from a negative binomial distribution parametrized with the relative abundances x read number and the dispersion parameter
</p>
</li>
<li><p> For each gene: Draw for each read the number of uridines according to a beta binomial distribution for the given read length
(the beta prior is parametrized to match the u.content and u.content.sd parameters)
</p>
</li>
<li><p> For each read: Draw the number of conversions according to the binomial mixture model of GRAND-SLAM
(parametrized with p_old, p_new, the gene specific NTR and the read specific number of uridines)
</p>
</li>
<li><p> Estimate the NTR by using the GRAND-SLAM approach
</p>
</li></ol>



<h3>Value</h3>

<p>a matrix containing, per column, the simulated counts, the simulated NTRs,
(potentially the shape parameters of the beta distribution approximation,) and the true relative frequencies and ntrs
</p>


<h3>See Also</h3>

<p><a href="#topic+SimulateTimeCourse">SimulateTimeCourse</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SimulateReadsForSample(num.reads = 10000,rel.abundance = rep(1,5),ntr=0.9)
SimulateReadsForSample(num.reads = 10000,rel.abundance = rep(1,5),ntr=0.9,seed=1337)
SimulateReadsForSample(num.reads = 10000,rel.abundance = rep(1,5),ntr=0.9,seed=1337)
# the second and third matrix should be equal, the first should be distinct

</code></pre>

<hr>
<h2 id='SimulateTimeCourse'>Simulate a complete time course of metabolic labeling - nucleotide conversion RNA-seq data.</h2><span id='topic+SimulateTimeCourse'></span>

<h3>Description</h3>

<p>This function takes a vector of <em>true</em> synthesis rates and RNA half-lives, and then simulates
data for multiple time points and replicates. Both synthesis rate and RNA half-lives are assumed to be constant,
but the system might not be in steady-state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimulateTimeCourse(
  condition,
  gene.info,
  s,
  d,
  f0 = s/d,
  s.variation = 1,
  d.variation = 1,
  dispersion,
  num.reads = 1e+07,
  timepoints = c(0, 0, 0, 1, 1, 1, 2, 2, 2, 4, 4, 4),
  beta.approx = FALSE,
  conversion.reads = FALSE,
  verbose = TRUE,
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SimulateTimeCourse_+3A_condition">condition</code></td>
<td>
<p>A user-defined condition name (which is placed into the <code><a href="#topic+Coldata">Coldata</a></code> of the final grandR object)</p>
</td></tr>
<tr><td><code id="SimulateTimeCourse_+3A_gene.info">gene.info</code></td>
<td>
<p>either a data frame containing gene annotation or a vector of gene names</p>
</td></tr>
<tr><td><code id="SimulateTimeCourse_+3A_s">s</code></td>
<td>
<p>a vector of synthesis rates</p>
</td></tr>
<tr><td><code id="SimulateTimeCourse_+3A_d">d</code></td>
<td>
<p>a vector of degradation rates (to get a specific half-life HL, use d=log(2)/HL)</p>
</td></tr>
<tr><td><code id="SimulateTimeCourse_+3A_f0">f0</code></td>
<td>
<p>the abundance at time t=0</p>
</td></tr>
<tr><td><code id="SimulateTimeCourse_+3A_s.variation">s.variation</code></td>
<td>
<p>biological variability of s among all samples (see details)</p>
</td></tr>
<tr><td><code id="SimulateTimeCourse_+3A_d.variation">d.variation</code></td>
<td>
<p>biological variability of d among all samples (see details)</p>
</td></tr>
<tr><td><code id="SimulateTimeCourse_+3A_dispersion">dispersion</code></td>
<td>
<p>a vector of dispersion parameters (estimate from data using DESeq2, e.g. by the estimate.dispersion utility function)</p>
</td></tr>
<tr><td><code id="SimulateTimeCourse_+3A_num.reads">num.reads</code></td>
<td>
<p>a vector representing the number of reads for each sample</p>
</td></tr>
<tr><td><code id="SimulateTimeCourse_+3A_timepoints">timepoints</code></td>
<td>
<p>a vector representing the labeling duration (in h) for each sample</p>
</td></tr>
<tr><td><code id="SimulateTimeCourse_+3A_beta.approx">beta.approx</code></td>
<td>
<p>should the beta approximation of the NTR posterior be computed?</p>
</td></tr>
<tr><td><code id="SimulateTimeCourse_+3A_conversion.reads">conversion.reads</code></td>
<td>
<p>also output the number of reads with conversion</p>
</td></tr>
<tr><td><code id="SimulateTimeCourse_+3A_verbose">verbose</code></td>
<td>
<p>Print status updates</p>
</td></tr>
<tr><td><code id="SimulateTimeCourse_+3A_seed">seed</code></td>
<td>
<p>seed value for the random number generator (set to make it deterministic!)</p>
</td></tr>
<tr><td><code id="SimulateTimeCourse_+3A_...">...</code></td>
<td>
<p>provided to <code><a href="#topic+SimulateReadsForSample">SimulateReadsForSample</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <em>s.variation</em> or <em>d.variation</em> are &gt; 1, then for each gene a random gaussian is added to s (or d)
such that 90
of the gaussian is log2(s.variation).
</p>


<h3>Value</h3>

<p>a grandR object containing the simulated data in its data slots and the true parameters in the gene annotation table
</p>

<hr>
<h2 id='SimulateTimeCourseNonConstant'>Simulate a complete time course of metabolic labeling - nucleotide conversion RNA-seq data.</h2><span id='topic+SimulateTimeCourseNonConstant'></span>

<h3>Description</h3>

<p>This function takes a vector of <em>true</em> synthesis rates and RNA half-lives, and then simulates
data for multiple time points and replicates. Both synthesis rate and RNA half-lives are assumed to be constant,
but the system might not be in steady-state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimulateTimeCourseNonConstant(
  condition,
  gene.info,
  s,
  d,
  dispersion,
  num.reads = 1e+07,
  t = 2,
  replicates = 3,
  beta.approx = FALSE,
  conversion.reads = FALSE,
  verbose = TRUE,
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SimulateTimeCourseNonConstant_+3A_condition">condition</code></td>
<td>
<p>A user-defined condition name (which is placed into the <code><a href="#topic+Coldata">Coldata</a></code> of the final grandR object)</p>
</td></tr>
<tr><td><code id="SimulateTimeCourseNonConstant_+3A_gene.info">gene.info</code></td>
<td>
<p>either a data frame containing gene annotation or a vector of gene names</p>
</td></tr>
<tr><td><code id="SimulateTimeCourseNonConstant_+3A_s">s</code></td>
<td>
<p>a vector of synthesis rates (see details)</p>
</td></tr>
<tr><td><code id="SimulateTimeCourseNonConstant_+3A_d">d</code></td>
<td>
<p>a vector of degradation rates (see details)</p>
</td></tr>
<tr><td><code id="SimulateTimeCourseNonConstant_+3A_dispersion">dispersion</code></td>
<td>
<p>a vector of dispersion parameters (estimate from data using DESeq2, e.g. by the estimate.dispersion utility function)</p>
</td></tr>
<tr><td><code id="SimulateTimeCourseNonConstant_+3A_num.reads">num.reads</code></td>
<td>
<p>a vector representing the number of reads for each sample</p>
</td></tr>
<tr><td><code id="SimulateTimeCourseNonConstant_+3A_t">t</code></td>
<td>
<p>a single number denoting the time</p>
</td></tr>
<tr><td><code id="SimulateTimeCourseNonConstant_+3A_replicates">replicates</code></td>
<td>
<p>a single number denoting the number of replicates</p>
</td></tr>
<tr><td><code id="SimulateTimeCourseNonConstant_+3A_beta.approx">beta.approx</code></td>
<td>
<p>should the beta approximation of the NTR posterior be computed?</p>
</td></tr>
<tr><td><code id="SimulateTimeCourseNonConstant_+3A_conversion.reads">conversion.reads</code></td>
<td>
<p>also output the number of reads with conversion</p>
</td></tr>
<tr><td><code id="SimulateTimeCourseNonConstant_+3A_verbose">verbose</code></td>
<td>
<p>Print status updates</p>
</td></tr>
<tr><td><code id="SimulateTimeCourseNonConstant_+3A_seed">seed</code></td>
<td>
<p>seed value for the random number generator (set to make it deterministic!)</p>
</td></tr>
<tr><td><code id="SimulateTimeCourseNonConstant_+3A_...">...</code></td>
<td>
<p>provided to <code><a href="#topic+SimulateReadsForSample">SimulateReadsForSample</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both rates can be either (i) a single number (constant rate), (ii) a data frame with names &quot;offset&quot;,
&quot;factor&quot; and &quot;exponent&quot; (for linear functions, see <a href="#topic+ComputeNonConstantParam">ComputeNonConstantParam</a>; only one row allowed) or
(iii) a unary function time-&gt;rate. Functions
</p>


<h3>Value</h3>

<p>a grandR object containing the simulated data in its data slots and the true parameters in the gene annotation table
</p>


<h3>See Also</h3>

<p><a href="#topic+SimulateTimeCourse">SimulateTimeCourse</a>
</p>

<hr>
<h2 id='Slots'>Slot functions</h2><span id='topic+Slots'></span><span id='topic+DropSlot'></span><span id='topic+AddSlot'></span>

<h3>Description</h3>

<p>Get slot names and add or remove slots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Slots(data)

DropSlot(data, pattern = NULL)

AddSlot(data, name, matrix, set.to.default = FALSE, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Slots_+3A_data">data</code></td>
<td>
<p>A grandR object</p>
</td></tr>
<tr><td><code id="Slots_+3A_pattern">pattern</code></td>
<td>
<p>a regular expression matched against slot names</p>
</td></tr>
<tr><td><code id="Slots_+3A_name">name</code></td>
<td>
<p>the slot name</p>
</td></tr>
<tr><td><code id="Slots_+3A_matrix">matrix</code></td>
<td>
<p>the data matrix for the new slot</p>
</td></tr>
<tr><td><code id="Slots_+3A_set.to.default">set.to.default</code></td>
<td>
<p>set the new slot as the default slot?</p>
</td></tr>
<tr><td><code id="Slots_+3A_warn">warn</code></td>
<td>
<p>issue a warning if the slot name already exists and is overwritten</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either the slot names or a grandR data with added/removed slots
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>Slots()</code>: Obtain the slot names
</p>
</li>
<li> <p><code>DropSlot()</code>: Remove one or several slots from this grandR object
</p>
</li>
<li> <p><code>AddSlot()</code>: Add an additional slot to this grandR object
</p>
</li></ul>


<h3>See Also</h3>

<p><a href="#topic+DefaultSlot">DefaultSlot</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sars &lt;- ReadGRAND(system.file("extdata", "sars.tsv.gz", package = "grandR"),
                  design=c("Cell",Design$dur.4sU,Design$Replicate))

sars &lt;- Normalize(sars)     # default behavior is to update the default slot
sars
sars &lt;- DropSlot(sars,"norm")
sars                        # note that the defauls slot reverted to count

</code></pre>

<hr>
<h2 id='structure2vector'>Convert a structure into a vector</h2><span id='topic+structure2vector'></span><span id='topic+kinetics2vector'></span>

<h3>Description</h3>

<p>The structure is supposed to be a list. Flattening is done by extracting the given fields (<code>return.fields</code>)
and applying the additional function (<code>return.extra</code>). This is mainly to be used within <code>sapply</code> and similar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>structure2vector(d, return.fields = NULL, return.extra = NULL)

kinetics2vector(
  d,
  condition = NULL,
  return.fields = c("Synthesis", "Half-life"),
  return.extra = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="structure2vector_+3A_d">d</code></td>
<td>
<p>the data structure</p>
</td></tr>
<tr><td><code id="structure2vector_+3A_return.fields">return.fields</code></td>
<td>
<p>which fields should be extracted directly (may be NULL)</p>
</td></tr>
<tr><td><code id="structure2vector_+3A_return.extra">return.extra</code></td>
<td>
<p>apply a function returning a flat list or vector (may be NULL)</p>
</td></tr>
<tr><td><code id="structure2vector_+3A_condition">condition</code></td>
<td>
<p>if the original grandR object had <code><a href="#topic+Condition">Condition</a></code> set, which condition to extract (NULL otherwise)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the data flattened into a vector
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>kinetics2vector()</code>: Convert the output of the FitKinetics methods into a vector
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>sars &lt;- ReadGRAND(system.file("extdata", "sars.tsv.gz", package = "grandR"),
                  design=c("Condition",Design$dur.4sU,Design$Replicate))
sars &lt;- Normalize(sars)
fit &lt;- FitKineticsGeneLeastSquares(sars,"SRSF6")$Mock
print(fit)
kinetics2vector(fit)

</code></pre>

<hr>
<h2 id='ToIndex'>Obtain the indices of the given genes</h2><span id='topic+ToIndex'></span>

<h3>Description</h3>

<p>Genes can be referred to by their names, symbols, row numbers in the gene table, or a logical vector referring to the gene table rows.
This function accepts all these possibilities and returns the row number in the gene table for the given genes,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ToIndex(data, gene, regex = FALSE, remove.missing = TRUE, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ToIndex_+3A_data">data</code></td>
<td>
<p>The grandR object</p>
</td></tr>
<tr><td><code id="ToIndex_+3A_gene">gene</code></td>
<td>
<p>A vector of genes. Can be either numeric indices, gene names, gene symbols or a logical vector</p>
</td></tr>
<tr><td><code id="ToIndex_+3A_regex">regex</code></td>
<td>
<p>Treat gene as a regex and return all that match</p>
</td></tr>
<tr><td><code id="ToIndex_+3A_remove.missing">remove.missing</code></td>
<td>
<p>if TRUE, do not return missing genes (return NA otherwise)</p>
</td></tr>
<tr><td><code id="ToIndex_+3A_warn">warn</code></td>
<td>
<p>if TRUE emit a warning if not all genes are found</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric indices corresponding to the given genes
</p>


<h3>See Also</h3>

<p><a href="#topic+GeneInfo">GeneInfo</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sars &lt;- ReadGRAND(system.file("extdata", "sars.tsv.gz", package = "grandR"),
                  design=c("Cell",Design$dur.4sU,Design$Replicate))
ToIndex(sars,c("MYC"))
ToIndex(sars,GeneInfo(sars)$Symbol=="MYC")

</code></pre>

<hr>
<h2 id='Transform.no'>Transformations for PlotHeatmap</h2><span id='topic+Transform.no'></span><span id='topic+Transform.Z'></span><span id='topic+Transform.VST'></span><span id='topic+Transform.logFC'></span>

<h3>Description</h3>

<p>Functions to perform transformations on the matrix used for <a href="#topic+PlotHeatmap">PlotHeatmap</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Transform.no(label = " ")

Transform.Z(label = "z score", center = TRUE, scale = TRUE)

Transform.VST(label = "VST")

Transform.logFC(label = "log2 FC", LFC.fun = NULL, columns = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Transform.no_+3A_label">label</code></td>
<td>
<p>label that is used for the heatmap legend</p>
</td></tr>
<tr><td><code id="Transform.no_+3A_center">center</code></td>
<td>
<p>perform centering when computing Z scores (see <a href="base.html#topic+scale">scale</a>)</p>
</td></tr>
<tr><td><code id="Transform.no_+3A_scale">scale</code></td>
<td>
<p>perform scaling when computing Z scores (see <a href="base.html#topic+scale">scale</a>)</p>
</td></tr>
<tr><td><code id="Transform.no_+3A_lfc.fun">LFC.fun</code></td>
<td>
<p>function to compute log fold changes (default: <a href="lfc.html#topic+PsiLFC">PsiLFC</a>, other viable option: <a href="lfc.html#topic+NormLFC">NormLFC</a>)</p>
</td></tr>
<tr><td><code id="Transform.no_+3A_columns">columns</code></td>
<td>
<p>which columns (i.e. samples or cells) to use as reference when computing log fold changes (see details)</p>
</td></tr>
<tr><td><code id="Transform.no_+3A_...">...</code></td>
<td>
<p>further parameters passed down to LFC.fun</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions should be used as transform parameter to <a href="#topic+PlotHeatmap">PlotHeatmap</a>. Available data transformations are
</p>

<ul>
<li><p>transform=Transform.Z(): compute z scores for each row; you can omit the usual centering or scaling by setting the respective parameters to false; see <a href="base.html#topic+scale">scale</a>
</p>
</li>
<li><p>transform=Transform.VST(): do a variance stabilizing transformation using <a href="DESeq2.html#topic+vst">vst</a>
</p>
</li>
<li><p>transform=Transform.logFC(): compute log2 fold changes to one or several reference columns; see below how to define them; fold changes are computed using the lfc package)
</p>
</li>
<li><p>transform=Transform.no(): do not transform
</p>
</li></ul>

<p>The label to be used in the heatmap legend can be changed by specifying the label parameter.
</p>
<p>For Transform.logFC, columns can be given as a logical, integer or character vector representing a selection of the columns (samples or cells).
</p>


<h3>Value</h3>

<p>A function that transforms a matrix.
</p>

<hr>
<h2 id='TransformSnapshot'>Estimate parameters for a one-shot experiment.</h2><span id='topic+TransformSnapshot'></span>

<h3>Description</h3>

<p>Under steady state conditions it is straight-forward to estimate s and d. Otherwise, the total levels at some other time point are needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TransformSnapshot(ntr, total, t, t0 = NULL, f0 = NULL, full.return = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TransformSnapshot_+3A_ntr">ntr</code></td>
<td>
<p>the new to total RNA ratio (measured)</p>
</td></tr>
<tr><td><code id="TransformSnapshot_+3A_total">total</code></td>
<td>
<p>the total level of RNA (measured)</p>
</td></tr>
<tr><td><code id="TransformSnapshot_+3A_t">t</code></td>
<td>
<p>the labeling duration</p>
</td></tr>
<tr><td><code id="TransformSnapshot_+3A_t0">t0</code></td>
<td>
<p>time before measurement at which f0 is total level (only necessary under non-steady-state conditions)</p>
</td></tr>
<tr><td><code id="TransformSnapshot_+3A_f0">f0</code></td>
<td>
<p>total level at t0 (only necessary under non-steady-state conditions)</p>
</td></tr>
<tr><td><code id="TransformSnapshot_+3A_full.return">full.return</code></td>
<td>
<p>also return the provided parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>t0 must be given as the total time in between the measurement of f0 and the given ntr and total values!
</p>


<h3>Value</h3>

<p>a named vector for s and d
</p>

<hr>
<h2 id='UpdateSymbols'>Update symbols using biomaRt</h2><span id='topic+UpdateSymbols'></span>

<h3>Description</h3>

<p>If your input files only contained ENSEMBL ids, use this to add gene symbols!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UpdateSymbols(data, species = NULL, current.value = "ensembl_gene_id")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UpdateSymbols_+3A_data">data</code></td>
<td>
<p>a grandR object</p>
</td></tr>
<tr><td><code id="UpdateSymbols_+3A_species">species</code></td>
<td>
<p>the species the genes belong to (eg &quot;Homo sapiens&quot;); can be NULL, then the species is inferred from gene ids (see details)</p>
</td></tr>
<tr><td><code id="UpdateSymbols_+3A_current.value">current.value</code></td>
<td>
<p>What it the current value in the symbols field?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no species is given, a very simple automatic inference is done, which will only work when having human or mouse ENSEMBL identifiers as gene ids.
If you need to specify species, it must be one of <code>biomaRt::listDatasets(biomaRt::useMart("ensembl"))$dataset</code>!
</p>
<p>Current.value must be one of <code>biomaRt::listAttributes(biomaRt::useMart("ensembl"))$name</code>!
</p>


<h3>Value</h3>

<p>a grandR object with updated symbol names
</p>

<hr>
<h2 id='UseNtrSlot'>Copy the NTR slot and save under new name</h2><span id='topic+UseNtrSlot'></span>

<h3>Description</h3>

<p>Copy the NTR slot and save under new name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UseNtrSlot(data, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UseNtrSlot_+3A_data">data</code></td>
<td>
<p>the grandR object</p>
</td></tr>
<tr><td><code id="UseNtrSlot_+3A_name">name</code></td>
<td>
<p>the name of the new slot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a grandR object
</p>

<hr>
<h2 id='VulcanoPlot'>Make a Vulcano plot</h2><span id='topic+VulcanoPlot'></span>

<h3>Description</h3>

<p>Plot log2 fold changes against -log10 multiple testing adjusted P values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VulcanoPlot(
  data,
  analysis = Analyses(data)[1],
  p.cutoff = 0.05,
  lfc.cutoff = 1,
  annotate.numbers = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VulcanoPlot_+3A_data">data</code></td>
<td>
<p>the grandR object that contains the data to be plotted</p>
</td></tr>
<tr><td><code id="VulcanoPlot_+3A_analysis">analysis</code></td>
<td>
<p>the analysis to plot (default: first analysis)</p>
</td></tr>
<tr><td><code id="VulcanoPlot_+3A_p.cutoff">p.cutoff</code></td>
<td>
<p>p-value cutoff (default: 0.05)</p>
</td></tr>
<tr><td><code id="VulcanoPlot_+3A_lfc.cutoff">lfc.cutoff</code></td>
<td>
<p>log fold change cutoff (default: 1)</p>
</td></tr>
<tr><td><code id="VulcanoPlot_+3A_annotate.numbers">annotate.numbers</code></td>
<td>
<p>if TRUE, label the number of genes</p>
</td></tr>
<tr><td><code id="VulcanoPlot_+3A_...">...</code></td>
<td>
<p>further parameters passed to <a href="#topic+PlotScatter">PlotScatter</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
