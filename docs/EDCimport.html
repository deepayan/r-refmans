<!DOCTYPE html><html lang="en"><head><title>Help for package EDCimport</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EDCimport}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#EDCimport-package'><p>EDCimport: Import Data from EDC Software</p></a></li>
<li><a href='#assert_no_duplicate'><p>Assert that a dataframe has one row per patient</p></a></li>
<li><a href='#build_lookup'><p>Generate a lookup table</p></a></li>
<li><a href='#crf_status_plot'><p>Show the current CRF status distribution</p></a></li>
<li><a href='#data_example'><p>Example databases</p></a></li>
<li><a href='#edc_data_warn'><p>Standardized warning system</p></a></li>
<li><a href='#edc_db_to_excel'><p>Save the database as an Excel file</p></a></li>
<li><a href='#edc_inform_code'><p>Shows how many code you wrote</p></a></li>
<li><a href='#edc_lookup'><p>Retrieve the lookup table from options</p></a></li>
<li><a href='#edc_options'><p>Set global options for <code>EDCimport</code></p></a></li>
<li><a href='#edc_peek_options'><p>See which <code>EDCimport</code> option is currently set.</p></a></li>
<li><a href='#edc_population_plot'><p>Plot the populations</p></a></li>
<li><a href='#edc_reset_options'><p>Reset all <code>EDCimport</code> options.</p></a></li>
<li><a href='#edc_swimmerplot'><p>Swimmer plot of all dates columns</p></a></li>
<li><a href='#edc_warn_extraction_date'><p>Warn if extraction is too old</p></a></li>
<li><a href='#edc_warn_patient_diffs'><p>Check the validity of the subject ID column</p></a></li>
<li><a href='#extend_lookup'><p>Extend the lookup table</p></a></li>
<li><a href='#fct_yesno'><p>Format factor levels as Yes/No</p></a></li>
<li><a href='#find_keyword'><p>Find a keyword in the whole database</p></a></li>
<li><a href='#get_common_cols'><p>Get columns that are common to multiple datasets</p></a></li>
<li><a href='#get_datasets'><p>Retrieve the datasets as a list of data.frames</p></a></li>
<li><a href='#get_key_cols'><p>Important column names</p></a></li>
<li><a href='#get_meta_cols'><p>Get columns shared by most datasets</p></a></li>
<li><a href='#get_subjid_cols'><p>Get key column names</p></a></li>
<li><a href='#harmonize_subjid'><p>Harmonize the subject ID of the database</p></a></li>
<li><a href='#lastnews_table'><p>Get a table with the latest date for each patient</p></a></li>
<li><a href='#load_as_list'><p>Load a <code>.RData</code> file as a list</p></a></li>
<li><a href='#load_list'><p>Load a list in an environment</p></a></li>
<li><a href='#manual_correction'><p>Manual correction</p></a></li>
<li><a href='#read_all_csv'><p>Read all <code>.csv</code> files in a directory</p></a></li>
<li><a href='#read_all_sas'><p>Read all <code>.sas7bdat</code> files in a directory</p></a></li>
<li><a href='#read_all_xpt'><p>Read all <code>.xpt</code> files in a directory</p></a></li>
<li><a href='#read_trialmaster'><p>Read the <code>.zip</code> archive of a TrialMaster export</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#save_list'><p>Save a list as <code>.RData</code> file</p></a></li>
<li><a href='#save_plotly'><p>Save a plotly to an HTML file</p></a></li>
<li><a href='#save_sessioninfo'><p>Save <code>sessionInfo()</code> output</p></a></li>
<li><a href='#search_for_newer_data'><p>Search for newer data</p></a></li>
<li><a href='#select_distinct'><p>Select only distinct columns</p></a></li>
<li><a href='#split_mixed_datasets'><p>Split mixed datasets</p></a></li>
<li><a href='#table_format'><p>Identify if a dataframe has a long or a wide format</p></a></li>
<li><a href='#unify'><p>Unify a vector</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.5.2</td>
</tr>
<tr>
<td>Title:</td>
<td>Import Data from EDC Software</td>
</tr>
<tr>
<td>Description:</td>
<td>A convenient toolbox to import data exported from Electronic Data Capture (EDC) software 'TrialMaster'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/DanChaltiel/EDCimport">https://github.com/DanChaltiel/EDCimport</a>,
<a href="https://danchaltiel.github.io/EDCimport/">https://danchaltiel.github.io/EDCimport/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/DanChaltiel/EDCimport/issues">https://github.com/DanChaltiel/EDCimport/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, dplyr, forcats, fs, glue, ggplot2, haven, purrr, readr,
rlang, scales, stringr, tibble, tidyr, tidyselect, utils,
lifecycle</td>
</tr>
<tr>
<td>Suggests:</td>
<td>callr, crosstable, gtools, htmlwidgets, janitor, knitr,
openxlsx, patchwork, plotly, quarto, rmarkdown, rstudioapi,
testthat (&ge; 3.1.8), usethis, vdiffr, withr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/start-first:</td>
<td>local, trialmaster, utils</td>
</tr>
<tr>
<td>Collate:</td>
<td>'7zip.R' 'EDCimport-package.R' 'assertions.R' 'burgled.R'
'crf_status.R' 'data.R' 'helpers.R' 'utils.R' 'lookup.R'
'options.R' 'population_plot.R' 'read_all_csv.R'
'read_all_sas.R' 'read_all_xpt.R' 'read_trialmaster.R'
'sanity_checks.R' 'sas_format.R' 'save_to_excel.R'
'search_for_newer_data.R' 'split_mixed.R' 'swimmerplot.R'
'utils_read.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-14 14:14:50 UTC; Dan</td>
</tr>
<tr>
<td>Author:</td>
<td>Dan Chaltiel <a href="https://orcid.org/0000-0003-3488-779X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dan Chaltiel &lt;dan.chaltiel@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-14 16:10:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='EDCimport-package'>EDCimport: Import Data from EDC Software</h2><span id='topic+EDCimport'></span><span id='topic+EDCimport-package'></span>

<h3>Description</h3>

<p>A convenient toolbox to import data exported from Electronic Data Capture (EDC) software 'TrialMaster'.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Dan Chaltiel <a href="mailto:dan.chaltiel@gmail.com">dan.chaltiel@gmail.com</a> (<a href="https://orcid.org/0000-0003-3488-779X">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/DanChaltiel/EDCimport">https://github.com/DanChaltiel/EDCimport</a>
</p>
</li>
<li> <p><a href="https://danchaltiel.github.io/EDCimport/">https://danchaltiel.github.io/EDCimport/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/DanChaltiel/EDCimport/issues">https://github.com/DanChaltiel/EDCimport/issues</a>
</p>
</li></ul>


<hr>
<h2 id='assert_no_duplicate'>Assert that a dataframe has one row per patient</h2><span id='topic+assert_no_duplicate'></span>

<h3>Description</h3>

<p>Check that there is no duplicate on the column holding patient ID in a pipeable style. <br />
Mostly useful after joining two datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_no_duplicate(df, by = NULL, id_col = get_subjid_cols())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assert_no_duplicate_+3A_df">df</code></td>
<td>
<p>a dataframe</p>
</td></tr>
<tr><td><code id="assert_no_duplicate_+3A_by">by</code></td>
<td>
<p><em>(optional)</em> grouping columns</p>
</td></tr>
<tr><td><code id="assert_no_duplicate_+3A_id_col">id_col</code></td>
<td>
<p>the name of the columns holding patient ID</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>df</code> dataset, unchanged
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#without duplicate =&gt; no error, continue the pipeline
tibble(subjid=c(1:10)) %&gt;% assert_no_duplicate() %&gt;% nrow()

#with duplicate =&gt; throws an error
tibble(subjid=c(1:10, 1:2)) %&gt;% assert_no_duplicate() %&gt;% nrow()

#By groups
df = tibble(subjid=rep(1:10, 4), visit=rep(c("V1", "V2"), 2, each=10), 
            group=rep(c("A", "B"), each=20))
df %&gt;% assert_no_duplicate() #error
df %&gt;% assert_no_duplicate(by=c(visit, group)) #no error

## End(Not run)
</code></pre>

<hr>
<h2 id='build_lookup'>Generate a lookup table</h2><span id='topic+build_lookup'></span>

<h3>Description</h3>

<p>Generate a lookup table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_lookup(data_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_lookup_+3A_data_list">data_list</code></td>
<td>
<p>a list containing at least 1 dataframe</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe summarizing column names and labels
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extend_lookup">extend_lookup()</a></code>, <code><a href="#topic+edc_lookup">edc_lookup()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = edc_example()
x$.lookup=NULL
lk = build_lookup(x)
lk
lk %&gt;% tidyr::unnest(c(names, labels))  

</code></pre>

<hr>
<h2 id='crf_status_plot'>Show the current CRF status distribution</h2><span id='topic+crf_status_plot'></span><span id='topic+edc_pal_crf'></span>

<h3>Description</h3>

<p>Generate a barplot showing the distribution of CRF status (Complete, Incomplete, ...) for each dataset of the database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crf_status_plot(
  crfstat_col = "CRFSTAT",
  ...,
  details = FALSE,
  pal = edc_pal_crf(),
  crfstat_lvls = names(pal),
  x_label = "{dataset}",
  treat_as_worst = NULL
)

edc_pal_crf()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crf_status_plot_+3A_crfstat_col">crfstat_col</code></td>
<td>
<p>the column name of the CRF status</p>
</td></tr>
<tr><td><code id="crf_status_plot_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="crf_status_plot_+3A_details">details</code></td>
<td>
<p>whether to show all the CRF status levels. When <code>FALSE</code> (default), recode the status into &quot;Complete&quot;, &quot;Incomplete&quot;, or &quot;No Data&quot;.</p>
</td></tr>
<tr><td><code id="crf_status_plot_+3A_pal">pal</code></td>
<td>
<p>the palette, defaulting to the helper <code>EDCimport:::edc_pal_crf()</code></p>
</td></tr>
<tr><td><code id="crf_status_plot_+3A_crfstat_lvls">crfstat_lvls</code></td>
<td>
<p>the CRF status levels, from &quot;best&quot; to &quot;worst&quot;. The plot is ordered by the &quot;worst&quot; level.</p>
</td></tr>
<tr><td><code id="crf_status_plot_+3A_x_label">x_label</code></td>
<td>
<p>a glue pattern determining the tick label in the x axis. Available variables are <code>c("nrow", "ncol", "n_id", "rows_per_id", "crfname")</code>, taken from <code><a href="#topic+edc_lookup">edc_lookup()</a></code>.</p>
</td></tr>
<tr><td><code id="crf_status_plot_+3A_treat_as_worst">treat_as_worst</code></td>
<td>
<p>a regex for levels that should be treated as worst in the ordering</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot
</p>


<h3>Source</h3>

<p><code>ggsci:::ggsci_db$lancet[["lanonc"]] %&gt;% dput()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#import a TM database and use load_list(), then:
crf_status_plot() + ggtitle(date_extraction)
crf_status_plot(pal=rev(edc_pal_crf()))
crf_status_plot(details=TRUE, treat_as_worst="No Data")
crf_status_plot(x_label="{crfname} (N={n_id}, n={nrow})")

p = crf_status_plot(details=TRUE)
p$data$crfstat %&gt;% unique()
#&gt; [1] "Incomplete"        "No Data Locked"    "No Data"           "Signed"           
#&gt; [5] "Partial Monitored" "Monitored"         "Complete Locked"   "Complete" 

## End(Not run)
</code></pre>

<hr>
<h2 id='data_example'>Example databases</h2><span id='topic+data_example'></span><span id='topic+edc_example_mixed'></span><span id='topic+edc_example'></span><span id='topic+edc_example_plot'></span><span id='topic+edc_example_ae'></span>

<h3>Description</h3>

<p>List of tables used in EDCimport examples:
</p>

<ul>
<li> <p><code>edc_example()</code> can be used as the result of <code><a href="#topic+read_trialmaster">read_trialmaster()</a></code>
</p>
</li>
<li> <p><code>edc_example_plot()</code> can be used to test <code><a href="#topic+edc_swimmerplot">edc_swimmerplot()</a></code>
</p>
</li>
<li> <p><code>edc_example_mixed()</code> can be used to test <code><a href="#topic+split_mixed_datasets">split_mixed_datasets()</a></code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>edc_example_mixed(N = 100, seed = 42)

edc_example(N = 50, seed = 42)

edc_example_plot(N = 50, seed = 42)

edc_example_ae(N = 50, seed = 42)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data_example_+3A_n">N</code></td>
<td>
<p>the number of patients</p>
</td></tr>
<tr><td><code id="data_example_+3A_seed">seed</code></td>
<td>
<p>the random seed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of tables
</p>

<hr>
<h2 id='edc_data_warn'>Standardized warning system</h2><span id='topic+edc_data_warn'></span><span id='topic+edc_data_stop'></span><span id='topic+edc_data_warnings'></span><span id='topic+assert_no_rows'></span>

<h3>Description</h3>

<p>When checking your data, filter your dataset to get only problematic rows. <br />
Then, use either:
</p>

<ul>
<li> <p><code>edc_data_warn()</code> to generate a standardized warning that can be forwarded to the datamanager
</p>
</li>
<li> <p><code>edc_data_warn()</code> to abort the script if the problem is too serious
</p>
</li></ul>

<p>Database issues should be traced in a separate file, each with an identifying row number, and the file should be shared with the data-manager. <br />
Use <code>edc_data_warnings()</code> to generate the table for such a file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edc_data_warn(
  df,
  message,
  ...,
  issue_n = "xx",
  max_subjid = 5,
  csv_path = FALSE,
  col_subjid = get_subjid_cols()
)

edc_data_stop(df, message, ..., issue_n, max_subjid, csv_path, col_subjid)

edc_data_warnings()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edc_data_warn_+3A_df">df</code></td>
<td>
<p>the filtered dataframe</p>
</td></tr>
<tr><td><code id="edc_data_warn_+3A_message">message</code></td>
<td>
<p>the message. Can use <a href="https://cli.r-lib.org/reference/inline-markup.html#classes">cli formats</a>. <code>df</code> can be accessed using the <code>.data</code> special keyword (see example)</p>
</td></tr>
<tr><td><code id="edc_data_warn_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="edc_data_warn_+3A_issue_n">issue_n</code></td>
<td>
<p>identifying row number</p>
</td></tr>
<tr><td><code id="edc_data_warn_+3A_max_subjid">max_subjid</code></td>
<td>
<p>max number of subject ID to show in the message</p>
</td></tr>
<tr><td><code id="edc_data_warn_+3A_csv_path">csv_path</code></td>
<td>
<p>a path to save <code>df</code> in a csv file that can be shared with the DM for more details.</p>
</td></tr>
<tr><td><code id="edc_data_warn_+3A_col_subjid">col_subjid</code></td>
<td>
<p>column name for subject ID. Set to <code>NULL</code> to ignore.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>df</code> invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
tm = edc_example()
load_list(tm)
db0 %&gt;% 
  filter(age&gt;70) %&gt;% 
  edc_data_warn("Age should not be &gt;70", issue_n=1)

db0 %&gt;% 
  filter(age&lt;25) %&gt;% 
  edc_data_warn("Age should not be &lt;25", issue_n=2)

db1 %&gt;% 
  filter(n()&gt;1, .by=SUBJID) %&gt;% 
  edc_data_warn("There are duplicated patients in `db1` ({nrow(.data)} rows)", issue_n=3)

db0 %&gt;% 
  filter(age&lt;25) %&gt;% 
  edc_data_warn("Age should not be &lt;25", issue_n=NULL)
  
edc_data_warnings()

## Not run: 
db0 %&gt;% 
  filter(age&lt;25) %&gt;% 
  edc_data_warn("Age should not be &lt;25", csv_path="check/check_age_25.csv")
  
db0 %&gt;% 
  filter(age&lt;25) %&gt;% 
  edc_data_stop("Age should *never* be &lt;25")

## End(Not run)
</code></pre>

<hr>
<h2 id='edc_db_to_excel'>Save the database as an Excel file</h2><span id='topic+edc_db_to_excel'></span><span id='topic+edc_browse_excel'></span>

<h3>Description</h3>

<p>Because RStudio is not very good at showing data, it can be more convenient to browse the
database using MS Excel. This function turns the whole TM export (or any named list of datasets)
into an Excel workbook, with one tab for each dataset.<br />
Use <code>edc_db_to_excel()</code> to create the file and <code>edc_browse_excel()</code> to open it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edc_db_to_excel(
  filename = tempfile(fileext = ".xlsx"),
  ...,
  datasets = get_datasets(),
  overwrite = FALSE,
  open = FALSE
)

edc_browse_excel()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edc_db_to_excel_+3A_filename">filename</code></td>
<td>
<p>the path to the Excel output file. Default to a temporary file. Use the special value <code>TRUE</code> to save in &quot;data/database_{date_extraction}.xlsx&quot;.</p>
</td></tr>
<tr><td><code id="edc_db_to_excel_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="edc_db_to_excel_+3A_datasets">datasets</code></td>
<td>
<p>a named list of dataframes. Default to the TM export.</p>
</td></tr>
<tr><td><code id="edc_db_to_excel_+3A_overwrite">overwrite</code></td>
<td>
<p>whether to overwrite any existing file. Default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="edc_db_to_excel_+3A_open">open</code></td>
<td>
<p>whether to open the Excel file afterward. Default to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  tm = edc_example()
  load_list(tm)  
  edc_db_to_excel() #default arguments are usually OK
  edc_db_to_excel(filename=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='edc_inform_code'>Shows how many code you wrote</h2><span id='topic+edc_inform_code'></span>

<h3>Description</h3>

<p>Shows how many code you wrote
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edc_inform_code(main = "main.R", Rdir = "R/")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edc_inform_code_+3A_main">main</code></td>
<td>
<p>the main R file, which sources the other ones</p>
</td></tr>
<tr><td><code id="edc_inform_code_+3A_rdir">Rdir</code></td>
<td>
<p>the R directory, where sourced R files are located</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>

<hr>
<h2 id='edc_lookup'>Retrieve the lookup table from options</h2><span id='topic+edc_lookup'></span><span id='topic+get_lookup'></span>

<h3>Description</h3>

<p>Retrieve the lookup table from options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edc_lookup(..., check_null = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edc_lookup_+3A_...">...</code></td>
<td>
<p>passed on to <code><a href="dplyr.html#topic+arrange">dplyr::arrange()</a></code></p>
</td></tr>
<tr><td><code id="edc_lookup_+3A_check_null">check_null</code></td>
<td>
<p>whether to stop if lookup is NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the lookup dataframe summarizing the database import
</p>


<h3>See Also</h3>

<p><code><a href="#topic+build_lookup">build_lookup()</a></code>, <code><a href="#topic+extend_lookup">extend_lookup()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tm = edc_example()
load_list(tm)
edc_lookup()
edc_lookup(dataset)
</code></pre>

<hr>
<h2 id='edc_options'>Set global options for <code>EDCimport</code></h2><span id='topic+edc_options'></span>

<h3>Description</h3>

<p>Use this function to manage your <code>EDCimport</code> parameters globally while taking advantage of autocompletion. <br />
Use <code><a href="#topic+edc_peek_options">edc_peek_options()</a></code> to see which option is currently set and <code><a href="#topic+edc_reset_options">edc_reset_options()</a></code> to set all options back to default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edc_options(
  ...,
  trialmaster_pw,
  path_7zip,
  edc_lookup,
  edc_subjid_ref,
  edc_plotly,
  edc_fct_yesno,
  edc_cols_subjid,
  edc_cols_meta,
  edc_cols_id,
  edc_cols_crfname,
  edc_meta_cols_pct,
  edc_warn_max_subjid,
  edc_read_verbose,
  edc_correction_verbose,
  edc_get_key_cols_verbose,
  edc_lookup_overwrite_warn,
  .local = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edc_options_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="edc_options_+3A_trialmaster_pw">trialmaster_pw</code></td>
<td>
<p>the password of the trialmaster zip archive. For instance, you can use <code>edc_options(trialmaster_pw="my_pwd")</code> in the console once per session, so that you don't have to write the password in clear in your R code</p>
</td></tr>
<tr><td><code id="edc_options_+3A_path_7zip">path_7zip</code></td>
<td>
<p>the path to the 7zip executable. Default to <code>"C:/Program Files/7-Zip/"</code>.</p>
</td></tr>
<tr><td><code id="edc_options_+3A_edc_lookup">edc_lookup</code></td>
<td>
<p><strong>(Internal)</strong> a reference to the lookup table (usually <code>.lookup</code>). Should usually not be changed manually.</p>
</td></tr>
<tr><td><code id="edc_options_+3A_edc_subjid_ref">edc_subjid_ref</code></td>
<td>
<p><strong>used in <a href="#topic+edc_warn_patient_diffs">edc_warn_patient_diffs</a></strong> the vector of the reference subject IDs. You should usually write <code>edc_options(edc_subjid_ref=enrolres$subjid)</code>.</p>
</td></tr>
<tr><td><code id="edc_options_+3A_edc_plotly">edc_plotly</code></td>
<td>
<p><strong>used in <a href="#topic+edc_swimmerplot">edc_swimmerplot</a></strong> whether to use plotly to visualize the plot.</p>
</td></tr>
<tr><td><code id="edc_options_+3A_edc_fct_yesno">edc_fct_yesno</code></td>
<td>
<p><strong>used in <a href="#topic+fct_yesno">fct_yesno</a></strong> list of values to be considered as Yes/No values. Defaults to <code>get_yesno_lvl()</code>.</p>
</td></tr>
<tr><td><code id="edc_options_+3A_edc_cols_subjid">edc_cols_subjid</code>, <code id="edc_options_+3A_edc_cols_meta">edc_cols_meta</code></td>
<td>
<p><strong>used in <a href="#topic+get_key_cols">get_key_cols</a></strong> the name of the columns holding the subject id (default to <code>c("ptno", "subjid")</code>) and the CRF form name (default to <code>c("crfname")</code>). It is case-insensitive.</p>
</td></tr>
<tr><td><code id="edc_options_+3A_edc_cols_id">edc_cols_id</code>, <code id="edc_options_+3A_edc_cols_crfname">edc_cols_crfname</code></td>
<td>
<p>deprecated</p>
</td></tr>
<tr><td><code id="edc_options_+3A_edc_meta_cols_pct">edc_meta_cols_pct</code></td>
<td>
<p>The minimal proportion of datasets a column has to reach to be considered &quot;meta&quot;</p>
</td></tr>
<tr><td><code id="edc_options_+3A_edc_warn_max_subjid">edc_warn_max_subjid</code></td>
<td>
<p>The max number of subject IDs to show in <a href="#topic+edc_data_warn">edc_data_warn</a></p>
</td></tr>
<tr><td><code id="edc_options_+3A_edc_read_verbose">edc_read_verbose</code>, <code id="edc_options_+3A_edc_correction_verbose">edc_correction_verbose</code>, <code id="edc_options_+3A_edc_get_key_cols_verbose">edc_get_key_cols_verbose</code></td>
<td>
<p>the verbosity of the output of functions <a href="#topic+read_trialmaster">read_trialmaster</a> and <a href="#topic+read_tm_all_xpt">read_tm_all_xpt</a>, <a href="#topic+manual_correction">manual_correction</a>, and <a href="#topic+get_key_cols">get_key_cols</a>. For example, set <code>edc_options(edc_read_verbose=0)</code> to silence the first 2.</p>
</td></tr>
<tr><td><code id="edc_options_+3A_edc_lookup_overwrite_warn">edc_lookup_overwrite_warn</code></td>
<td>
<p>default to TRUE. Whether there should be warning when overwriting <code>.lookup</code> (like when reading 2 databases successively)</p>
</td></tr>
<tr><td><code id="edc_options_+3A_.local">.local</code></td>
<td>
<p>if TRUE, the effect will only apply to the local frame (internally using <code>rlang::local_options()</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, called for its side effects
</p>

<hr>
<h2 id='edc_peek_options'>See which <code>EDCimport</code> option is currently set.</h2><span id='topic+edc_peek_options'></span>

<h3>Description</h3>

<p>See which <code>EDCimport</code> option is currently set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edc_peek_options(keep_null = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edc_peek_options_+3A_keep_null">keep_null</code></td>
<td>
<p>set to TRUE to get a list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of EDCimport options
</p>

<hr>
<h2 id='edc_population_plot'>Plot the populations</h2><span id='topic+edc_population_plot'></span>

<h3>Description</h3>

<p>In a RCT, you usually have several populations of analysis, and this function allow to show
which patient is in which population graphically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edc_population_plot(x, id_per_row = 50, ref = "first")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edc_population_plot_+3A_x">x</code></td>
<td>
<p>a named list of subject ID.</p>
</td></tr>
<tr><td><code id="edc_population_plot_+3A_id_per_row">id_per_row</code></td>
<td>
<p>number of patients per rows.</p>
</td></tr>
<tr><td><code id="edc_population_plot_+3A_ref">ref</code></td>
<td>
<p>the whole population. Default to the first member of <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#in real word code, use filter and pull to get these vectors
pop_total = c(1:180) %&gt;% setdiff(55) #screen failure, no patient 55
pop_itt = pop_total %&gt;% setdiff(10) #patient 10 has had the wrong treatment
pop_safety = pop_total %&gt;% setdiff(c(40,160)) #patients 40 and 160 didn't receive any treatment
pop_m_itt = pop_total %&gt;% setdiff(c(40,160,80)) #patient 80 had a wrong inclusion criterion
pop_evaluable = pop_total %&gt;% setdiff(c(40,160,101,147,186)) #patients with no recist evaluation

l = list(
  "Total population"=pop_total,
  "ITT population"=pop_itt,
  "Safety population"=pop_safety,
  "mITT population"=pop_m_itt,
  "Evaluable population"=pop_evaluable
)
edc_population_plot(l)
edc_population_plot(l[-1], ref=pop_total)
edc_population_plot(l, ref=1:200)
edc_population_plot(l, id_per_row=60)
</code></pre>

<hr>
<h2 id='edc_reset_options'>Reset all <code>EDCimport</code> options.</h2><span id='topic+edc_reset_options'></span>

<h3>Description</h3>

<p>Reset all <code>EDCimport</code> options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edc_reset_options(
  except = c("edc_lookup", "trialmaster_pw", "path_7zip"),
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edc_reset_options_+3A_except">except</code></td>
<td>
<p>options that are not reset by default</p>
</td></tr>
<tr><td><code id="edc_reset_options_+3A_quiet">quiet</code></td>
<td>
<p>set to <code>TRUE</code> to remove the message.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, called for its side effects
</p>

<hr>
<h2 id='edc_swimmerplot'>Swimmer plot of all dates columns</h2><span id='topic+edc_swimmerplot'></span>

<h3>Description</h3>

<p>Join all tables from <code>.lookup$dataset</code> on <code>id</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edc_swimmerplot(
  .lookup = edc_lookup(),
  ...,
  id = get_subjid_cols(),
  group = NULL,
  origin = NULL,
  id_lim = NULL,
  exclude = NULL,
  time_unit = c("days", "weeks", "months", "years"),
  aes_color = c("variable", "label"),
  plotly = getOption("edc_plotly", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edc_swimmerplot_+3A_.lookup">.lookup</code></td>
<td>
<p>the lookup table, default to <code>edc_lookup()</code></p>
</td></tr>
<tr><td><code id="edc_swimmerplot_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="edc_swimmerplot_+3A_id">id</code></td>
<td>
<p>the patient identifier. Will be coerced as numeric.</p>
</td></tr>
<tr><td><code id="edc_swimmerplot_+3A_group">group</code></td>
<td>
<p>a grouping variable, given as &quot;dataset$column&quot;</p>
</td></tr>
<tr><td><code id="edc_swimmerplot_+3A_origin">origin</code></td>
<td>
<p>a variable to consider as time 0, given as &quot;dataset$column&quot;</p>
</td></tr>
<tr><td><code id="edc_swimmerplot_+3A_id_lim">id_lim</code></td>
<td>
<p>a numeric vector of length 2 providing the minimum and maximum <code>id</code> to subset on.</p>
</td></tr>
<tr><td><code id="edc_swimmerplot_+3A_exclude">exclude</code></td>
<td>
<p>a character vector of variables to exclude, in the form <code>dataset$column</code>. Can be a regex, but <code>$</code> symbols don't count. Case-insensitive.</p>
</td></tr>
<tr><td><code id="edc_swimmerplot_+3A_time_unit">time_unit</code></td>
<td>
<p>if <code>origin!=NULL</code>, the unit to measure time. One of <code>c("days", "weeks", "months", "years")</code>.</p>
</td></tr>
<tr><td><code id="edc_swimmerplot_+3A_aes_color">aes_color</code></td>
<td>
<p>either <code>variable</code> (&quot;{dataset} - {column}&quot;) or <code>label</code> (the column label)</p>
</td></tr>
<tr><td><code id="edc_swimmerplot_+3A_plotly">plotly</code></td>
<td>
<p>whether to use <code>{plotly}</code> to get an interactive plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either a <code>plotly</code> or a <code>ggplot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#tm = read_trialmaster("filename.zip", pw="xx")
tm = edc_example_plot()
load_list(tm)
p = edc_swimmerplot(.lookup, id_lim=c(5,45))
p2 = edc_swimmerplot(.lookup, origin="db0$date_naissance", time_unit="weeks", 
                     exclude=c("DB1$DATE2", "db3$.*"))
p3 = edc_swimmerplot(.lookup, group="db0$group", aes_color="label")
## Not run: 
#save the plotly plot as HTML to share it
save_plotly(p, "edc_swimmerplot.html")

## End(Not run)
</code></pre>

<hr>
<h2 id='edc_warn_extraction_date'>Warn if extraction is too old</h2><span id='topic+edc_warn_extraction_date'></span>

<h3>Description</h3>

<p>Warn if extraction is too old
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edc_warn_extraction_date(max_days = 30)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edc_warn_extraction_date_+3A_max_days">max_days</code></td>
<td>
<p>the max acceptable age of the data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tm = edc_example()
load_list(tm)
edc_warn_extraction_date()
</code></pre>

<hr>
<h2 id='edc_warn_patient_diffs'>Check the validity of the subject ID column</h2><span id='topic+edc_warn_patient_diffs'></span><span id='topic+check_subjid'></span>

<h3>Description</h3>

<p>Compare a subject ID vector to the study's reference subject ID (usually something like <code>enrolres$subjid</code>), and warn if any patient is missing or extra. <br />
<code>check_subjid()</code> is the old, deprecated name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edc_warn_patient_diffs(
  x,
  ref = getOption("edc_subjid_ref"),
  issue_n = "xx",
  data_name = NULL,
  col_subjid = get_subjid_cols()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edc_warn_patient_diffs_+3A_x">x</code></td>
<td>
<p>the subject ID vector to check, or a dataframe which ID column will be guessed</p>
</td></tr>
<tr><td><code id="edc_warn_patient_diffs_+3A_ref">ref</code></td>
<td>
<p>the reference for subject ID. Should usually be set through <code>edc_options(edc_subjid_ref=xxx)</code>. See example.</p>
</td></tr>
<tr><td><code id="edc_warn_patient_diffs_+3A_issue_n">issue_n</code></td>
<td>
<p>identifying row number</p>
</td></tr>
<tr><td><code id="edc_warn_patient_diffs_+3A_data_name">data_name</code></td>
<td>
<p>the name of the data (for the warning message)</p>
</td></tr>
<tr><td><code id="edc_warn_patient_diffs_+3A_col_subjid">col_subjid</code></td>
<td>
<p>name of the subject ID column if <code>x</code> is a dataframe.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing, called for errors/warnings
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tm = edc_example()
load_list(tm)
options(edc_subjid_ref=db0$SUBJID)
#usually, you set something like:
#options(edc_subjid_ref=enrolres$subjid)
edc_warn_patient_diffs(db1)
db1 %&gt;% dplyr::filter(SUBJID&gt;1) %&gt;% edc_warn_patient_diffs()
edc_warn_patient_diffs(c(db1$SUBJID, 99, 999))
</code></pre>

<hr>
<h2 id='extend_lookup'>Extend the lookup table</h2><span id='topic+extend_lookup'></span>

<h3>Description</h3>

<p>This utility extends the lookup table to include:
</p>

<ul>
<li> <p><code>n_id</code> the number of patients present in the dataset
</p>
</li>
<li> <p><code>rows_per_id</code> the mean number of row per patient
</p>
</li>
<li> <p><code>crfname</code> the actual name of the dataset
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>extend_lookup(
  lookup,
  ...,
  id_cols = get_subjid_cols(lookup),
  crf_cols = get_crfname_cols(lookup),
  datasets = get_datasets(lookup, envir = parent.frame())
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extend_lookup_+3A_lookup">lookup</code></td>
<td>
<p>[<code>data.frame(1)</code>]<br /> the lookup table</p>
</td></tr>
<tr><td><code id="extend_lookup_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="extend_lookup_+3A_id_cols">id_cols</code>, <code id="extend_lookup_+3A_crf_cols">crf_cols</code></td>
<td>
<p>[<code>character(n)</code>]<br /> for experts only</p>
</td></tr>
<tr><td><code id="extend_lookup_+3A_datasets">datasets</code></td>
<td>
<p>[<code>data.frame(n)</code>]<br /> for experts only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the lookup, extended
</p>


<h3>See Also</h3>

<p><code><a href="#topic+build_lookup">build_lookup()</a></code>, <code><a href="#topic+edc_lookup">edc_lookup()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#tm = read_trialmaster("filename.zip", pw="xx")
tm = edc_example_mixed()
load_list(tm)
.lookup
.lookup = extend_lookup(.lookup)
.lookup
</code></pre>

<hr>
<h2 id='fct_yesno'>Format factor levels as Yes/No</h2><span id='topic+fct_yesno'></span>

<h3>Description</h3>

<p>Format factor levels as arbitrary values of Yes/No (with Yes always first) while <strong>leaving untouched</strong> all vectors that contain other information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fct_yesno(
  x,
  input = list(yes = c("Yes", "Oui"), no = c("No", "Non")),
  output = c("Yes", "No"),
  strict = FALSE,
  mutate_character = TRUE,
  fail = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fct_yesno_+3A_x">x</code></td>
<td>
<p>a vector of any type/class.</p>
</td></tr>
<tr><td><code id="fct_yesno_+3A_input">input</code></td>
<td>
<p>list of values to be considered as &quot;yes&quot; and &quot;no&quot;.</p>
</td></tr>
<tr><td><code id="fct_yesno_+3A_output">output</code></td>
<td>
<p>the output factor levels.</p>
</td></tr>
<tr><td><code id="fct_yesno_+3A_strict">strict</code></td>
<td>
<p>whether to match the input strictly or use <a href="stringr.html#topic+str_detect">stringr::str_detect</a> to find them.</p>
</td></tr>
<tr><td><code id="fct_yesno_+3A_mutate_character">mutate_character</code></td>
<td>
<p>whether to turn characters into factor.</p>
</td></tr>
<tr><td><code id="fct_yesno_+3A_fail">fail</code></td>
<td>
<p>whether to fail if some levels cannot be recoded to yes/no.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a factor, or <code>x</code> untouched.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fct_yesno(c("No", "Yes")) #levels are in order

set.seed(42)
N=6
x = tibble(
  a=sample(c("Yes", "No"), size=N, replace=TRUE),
  b=sample(c("Oui", "Non"), size=N, replace=TRUE),
  c=sample(0:1, size=N, replace=TRUE),
  d=sample(c(TRUE, FALSE), size=N, replace=TRUE),
  e=sample(c("1-Yes", "0-No"), size=N, replace=TRUE),
  
  y=sample(c("aaa", "bbb", "ccc"), size=N, replace=TRUE),
  z=1:N,
)
 
x          
#y and z are left untouched (or throw an error if fail=TRUE)   
sapply(x, fct_yesno, fail=FALSE)

# as "1-Yes" is not in `input`, x$e is untouched/fails if strict=TRUE
fct_yesno(x$e)
fct_yesno(x$e, strict=TRUE, fail=FALSE) 
fct_yesno(x$e, output=c("Ja", "Nein"))
</code></pre>

<hr>
<h2 id='find_keyword'>Find a keyword in the whole database</h2><span id='topic+find_keyword'></span>

<h3>Description</h3>

<p>Find a keyword in all names and labels of a list of datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_keyword(keyword, data = edc_lookup(), ignore_case = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_keyword_+3A_keyword">keyword</code></td>
<td>
<p>the keyword to search for. Can handle regular expressions (see examples).</p>
</td></tr>
<tr><td><code id="find_keyword_+3A_data">data</code></td>
<td>
<p>the lookup dataframe where to search the keyword. Can be set using <code>edc_options(edc_lookup=my_data)</code>, which is done automatically when calling <code><a href="#topic+read_trialmaster">read_trialmaster()</a></code>.</p>
</td></tr>
<tr><td><code id="find_keyword_+3A_ignore_case">ignore_case</code></td>
<td>
<p>should case differences be ignored in the match? Default to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
path = system.file("extdata/Example_Export_SAS_XPORT_2022_08_25_15_16.zip", 
                   package="EDCimport", mustWork=TRUE)
w = read_trialmaster(path, verbose=FALSE)

find_keyword("patient")

#with regex
find_keyword("patient$")
find_keyword("\\d")
find_keyword("(Trial|Form) Name")
find_keyword("\\(") #you need to escape special characters

## End(Not run)
</code></pre>

<hr>
<h2 id='get_common_cols'>Get columns that are common to multiple datasets</h2><span id='topic+get_common_cols'></span><span id='topic+summary.common_cols'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Attempt to list all columns in the database and group the ones that are
common to some datasets.
Useful to find keys to pivot or summarise data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_common_cols(lookup = edc_lookup(), min_datasets = 3)

## S3 method for class 'common_cols'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_common_cols_+3A_lookup">lookup</code></td>
<td>
<p>the lookup table, default to <code><a href="#topic+edc_lookup">edc_lookup()</a></code></p>
</td></tr>
<tr><td><code id="get_common_cols_+3A_min_datasets">min_datasets</code></td>
<td>
<p>the minimal number of datasets to be considered</p>
</td></tr>
<tr><td><code id="get_common_cols_+3A_object">object</code></td>
<td>
<p>an object of class &quot;common_cols&quot;</p>
</td></tr>
<tr><td><code id="get_common_cols_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble of class &quot;common_cols&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tm = edc_example()
load_list(tm)
x = get_common_cols(min_datasets=1)
x
summary(x)
</code></pre>

<hr>
<h2 id='get_datasets'>Retrieve the datasets as a list of data.frames</h2><span id='topic+get_datasets'></span>

<h3>Description</h3>

<p>Get the datasets from the lookup table as a list of data.frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_datasets(lookup = edc_lookup(), envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_datasets_+3A_lookup">lookup</code></td>
<td>
<p>the lookup table</p>
</td></tr>
<tr><td><code id="get_datasets_+3A_envir">envir</code></td>
<td>
<p>(internal use)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of all datasets
</p>

<hr>
<h2 id='get_key_cols'>Important column names</h2><span id='topic+get_key_cols'></span>

<h3>Description</h3>

<p>Retrieve names of <code>patient_id</code> (usually &quot;SUBJID&quot; and &quot;PATNO&quot;) and <code>crfname</code> (usually &quot;CRFNAME&quot;) from the actual names of the datasets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_key_cols(lookup = edc_lookup())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_key_cols_+3A_lookup">lookup</code></td>
<td>
<p>the lookup table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list(2) of characters with names <code>patient_id</code> and <code>crfname</code>
</p>

<hr>
<h2 id='get_meta_cols'>Get columns shared by most datasets</h2><span id='topic+get_meta_cols'></span>

<h3>Description</h3>

<p>In most trialmaster exports, many datasets share a certain amount of columns containing
meta-data that are often irrelevant to the point. This function identifies the columns
that are present in at least 95% of datasets (by default)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_meta_cols(min_pct = getOption("edc_meta_cols_pct", 0.95))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_meta_cols_+3A_min_pct">min_pct</code></td>
<td>
<p>Default=<code>0.95</code>. The minimal proportion of datasets a column has to reach. Subject ID is always excluded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tm = edc_example_mixed()
load_list(tm)
meta_cols = get_meta_cols()
long_mixed %&gt;% dplyr::select(-dplyr::any_of(meta_cols))
</code></pre>

<hr>
<h2 id='get_subjid_cols'>Get key column names</h2><span id='topic+get_subjid_cols'></span><span id='topic+get_crfname_cols'></span>

<h3>Description</h3>

<p>Retrieve names of patient ID and CRF name from the actual names of the datasets, without respect of the case. Default values should be set through options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_subjid_cols(lookup = edc_lookup())

get_crfname_cols(lookup = edc_lookup())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_subjid_cols_+3A_lookup">lookup</code></td>
<td>
<p>the lookup table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector
</p>


<h3>options</h3>

<p>Use <code>edc_options()</code> to set default values:
</p>

<ul>
<li> <p><code>edc_cols_subjid</code> defaults to <code>c("PTNO", "SUBJID")</code>
</p>
</li>
<li> <p><code>edc_cols_crfname</code> defaults to <code>c("CRFNAME")</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>get_subjid_cols()
get_crfname_cols()
</code></pre>

<hr>
<h2 id='harmonize_subjid'>Harmonize the subject ID of the database</h2><span id='topic+harmonize_subjid'></span>

<h3>Description</h3>

<p>Turns the subject ID columns of all datasets into a factor containing levels for all
the subjects of the database. Avoid problems when joining tables, and some checks can
be performed on the levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>harmonize_subjid(datalist, preprocess = NULL, col_subjid = get_subjid_cols())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="harmonize_subjid_+3A_datalist">datalist</code></td>
<td>
<p>a list of dataframes</p>
</td></tr>
<tr><td><code id="harmonize_subjid_+3A_preprocess">preprocess</code></td>
<td>
<p>an optional function to modify the subject ID column, for example <code>as.numeric()</code>. See examples.</p>
</td></tr>
<tr><td><code id="harmonize_subjid_+3A_col_subjid">col_subjid</code></td>
<td>
<p>the names of the columns holding the subject ID (as character)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>datalist, with subject id modified
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db = edc_example()
db$db0 = head(db$db0, 10)
db$db0$SUBJID %&gt;% head()
db = harmonize_subjid(db)
db$db0$SUBJID %&gt;% head()
db = harmonize_subjid(db, preprocess=function(x) paste0("#", x))
db$db0$SUBJID %&gt;% head()
</code></pre>

<hr>
<h2 id='lastnews_table'>Get a table with the latest date for each patient</h2><span id='topic+lastnews_table'></span>

<h3>Description</h3>

<p>This function search for date columns in every tables and returns the latest date
for each patient with the variable it comes from. Useful in survival analysis to get
the right censoring time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lastnews_table(
  except = NULL,
  with_ties = FALSE,
  numeric_id = TRUE,
  prefer = NULL,
  warn_if_future = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lastnews_table_+3A_except">except</code></td>
<td>
<p>the datasets/columns that should not be searched. Example: a scheduled visit for which the patient may have died before attending should not be considered.</p>
</td></tr>
<tr><td><code id="lastnews_table_+3A_with_ties">with_ties</code></td>
<td>
<p>in case of tie, whether to return the first <code>origin</code> (FALSE) or all the origins that share this tie (TRUE).</p>
</td></tr>
<tr><td><code id="lastnews_table_+3A_numeric_id">numeric_id</code></td>
<td>
<p>set to FALSE if the patient ID column is not numeric</p>
</td></tr>
<tr><td><code id="lastnews_table_+3A_prefer">prefer</code></td>
<td>
<p>preferred origins in the event of a tie. Usually the followup table.</p>
</td></tr>
<tr><td><code id="lastnews_table_+3A_warn_if_future">warn_if_future</code></td>
<td>
<p>whether to show a warning about dates that are after the extraction date</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tm = edc_example_plot()
load_list(tm)
lastnews_table()
lastnews_table(except="db3")
lastnews_table(except="db3$date9")
lastnews_table(prefer="db2") 
</code></pre>

<hr>
<h2 id='load_as_list'>Load a <code>.RData</code> file as a list</h2><span id='topic+load_as_list'></span>

<h3>Description</h3>

<p>Instead of loading a <code>.RData</code> file in the global environment, extract every object into a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_as_list(filename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="load_as_list_+3A_filename">filename</code></td>
<td>
<p>the filename, with the <code>.RData</code> extension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = list(a=1, b=mtcars)
save_list(x, "test.RData")
y = load_as_list("test.RData")
print(y$a)
</code></pre>

<hr>
<h2 id='load_list'>Load a list in an environment</h2><span id='topic+load_list'></span>

<h3>Description</h3>

<p>Load a list in an environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_list(x, env = parent.frame(), remove = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="load_list_+3A_x">x</code></td>
<td>
<p>a list</p>
</td></tr>
<tr><td><code id="load_list_+3A_env">env</code></td>
<td>
<p>the environment onto which the list should be loaded</p>
</td></tr>
<tr><td><code id="load_list_+3A_remove">remove</code></td>
<td>
<p>if <code>TRUE</code>, <code>x</code> will be removed from the environment afterward</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing, called for its side-effect
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x=list(a=1, b=mtcars)
load_list(x, remove=FALSE)
print(a)
print(nrow(b))

</code></pre>

<hr>
<h2 id='manual_correction'>Manual correction</h2><span id='topic+manual_correction'></span><span id='topic+reset_manual_correction'></span>

<h3>Description</h3>

<p>When finding wrong or unexpected values in an exported dataset, it can be useful to temporarily correct them by hard-coding a value.
However, this manual correction should be undone as soon as the central database is updated with the correction.
</p>

<ul>
<li> <p><code>manual_correction()</code> applies a correction in a specific dataset column location and throws an error if the correction is already in place. This check applies only once per R session so you can source your script without errors.
</p>
</li>
<li> <p><code>reset_manual_correction()</code> resets all checks. For instance, it is called by <code><a href="#topic+read_trialmaster">read_trialmaster()</a></code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>manual_correction(
  data,
  col,
  rows,
  wrong,
  correct,
  verbose = getOption("edc_correction_verbose", TRUE)
)

reset_manual_correction()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="manual_correction_+3A_data">data</code>, <code id="manual_correction_+3A_col">col</code>, <code id="manual_correction_+3A_rows">rows</code></td>
<td>
<p>the rows of a column of a dataframe where the error lies</p>
</td></tr>
<tr><td><code id="manual_correction_+3A_wrong">wrong</code></td>
<td>
<p>the actual wrong value</p>
</td></tr>
<tr><td><code id="manual_correction_+3A_correct">correct</code></td>
<td>
<p>the temporary correction value</p>
</td></tr>
<tr><td><code id="manual_correction_+3A_verbose">verbose</code></td>
<td>
<p>whether to print informations (once)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, used for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
x = iris %&gt;% mutate(id=row_number(), .before=1) %&gt;% as_tibble()
x$Sepal.Length[c(1,3,5)]

#1st correction is silent
manual_correction(x, Sepal.Length, rows=c(1,3,5),
                  wrong=c(5.1, 4.7, 5.0), correct=c(5, 4, 3))
x$Sepal.Length[c(1,3,5)]

#further correction is silent
manual_correction(x, Sepal.Length, rows=c(1,3,5),
                  wrong=c(5.1, 4.7, 5.0), correct=c(5, 4, 3)) 
                  
#if the database is corrected, an error is thrown
## Not run: 
reset_manual_correction()
x$Sepal.Length[c(1,3,5)] = c(5, 4, 3) #mimics db correction
manual_correction(x, Sepal.Length, rows=c(1,3,5),
                  wrong=c(5.1, 4.7, 5.0), correct=c(5, 4, 3))

## End(Not run)
</code></pre>

<hr>
<h2 id='read_all_csv'>Read all <code>.csv</code> files in a directory</h2><span id='topic+read_all_csv'></span>

<h3>Description</h3>

<p>Read all <code>.csv</code> files in a directory, with labels if specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_all_csv(
  path,
  ...,
  labels_from = NULL,
  clean_names_fun = NULL,
  read_fun = "guess",
  datetime_extraction = "guess",
  verbose = getOption("edc_read_verbose", 1)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_all_csv_+3A_path">path</code></td>
<td>
<p>[<code>character(1)</code>]<br /> path to the directory containing <code>.csv</code> files.</p>
</td></tr>
<tr><td><code id="read_all_csv_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="read_all_csv_+3A_labels_from">labels_from</code></td>
<td>
<p>[<code>misc</code>]<br /> list of path to file containing the labels.</p>
</td></tr>
<tr><td><code id="read_all_csv_+3A_clean_names_fun">clean_names_fun</code></td>
<td>
<p>[<code>function</code>]<br /> a function to clean column names, e.g. <a href="base.html#topic+tolower">tolower</a>, <code><a href="janitor.html#topic+clean_names">janitor::clean_names()</a></code>,...</p>
</td></tr>
<tr><td><code id="read_all_csv_+3A_read_fun">read_fun</code></td>
<td>
<p>[<code>function</code>]<br /> a function to read the files in path, e.g. <code>read.csv()</code>, <code>read.csv2()</code>,...</p>
</td></tr>
<tr><td><code id="read_all_csv_+3A_datetime_extraction">datetime_extraction</code></td>
<td>
<p>[<code>dateish(1)</code>]<br /> the datetime of database extraction (database lock). If &quot;guess&quot;, the datetime will be inferred from the files modification time.</p>
</td></tr>
<tr><td><code id="read_all_csv_+3A_verbose">verbose</code></td>
<td>
<p>[<code>numeric(1)</code>]<br /> the level of verbosity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing one dataframe for each <code>.csv</code> file in the folder, the extraction date (<code>datetime_extraction</code>), and a summary of all imported tables (<code>.lookup</code>).
</p>


<h3>Labels file</h3>

<p><code>labels_from</code> should contain the information about column labels. It should be a data file (<code>.csv</code>) containing 2 columns: one for the column name and the other for its associated label. Use <code>options(edc_col_name="xxx", edc_col_label="xxx")</code> to specify the names of the columns.
</p>

<hr>
<h2 id='read_all_sas'>Read all <code>.sas7bdat</code> files in a directory</h2><span id='topic+read_all_sas'></span>

<h3>Description</h3>

<p>Read all <code>.sas7bdat</code> files in a directory. Formats can be applied from a <code>procformat.sas</code> SAS file, from a .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_all_sas(
  path,
  ...,
  format_file = "procformat.sas",
  clean_names_fun = NULL,
  datetime_extraction = "guess",
  verbose = getOption("edc_read_verbose", 1)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_all_sas_+3A_path">path</code></td>
<td>
<p>[<code>character(1)</code>]<br /> the path to the directory containing all <code>.sas7bdat</code> files.</p>
</td></tr>
<tr><td><code id="read_all_sas_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="read_all_sas_+3A_format_file">format_file</code></td>
<td>
<p>[<code>character(1)</code>]<br /> the path to the file that should be used to apply formats. See details. Use <code>NULL</code> to not apply formats.</p>
</td></tr>
<tr><td><code id="read_all_sas_+3A_clean_names_fun">clean_names_fun</code></td>
<td>
<p>[<code>function</code>]<br /> a function to clean column names, e.g. <a href="base.html#topic+tolower">tolower</a>, <code><a href="janitor.html#topic+clean_names">janitor::clean_names()</a></code>,...</p>
</td></tr>
<tr><td><code id="read_all_sas_+3A_datetime_extraction">datetime_extraction</code></td>
<td>
<p>[<code>POSIXt(1)</code>]<br /> the datetime of the data extraction. Default to the most common date of last modification in <code>directory</code>.</p>
</td></tr>
<tr><td><code id="read_all_sas_+3A_verbose">verbose</code></td>
<td>
<p>[<code>logical(1)</code>]<br /> one of <code>c(0, 1, 2)</code>. The higher, the more information will be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing one dataframe for each <code>.xpt</code> file in the folder, the extraction date (<code>datetime_extraction</code>), and a summary of all imported tables (<code>.lookup</code>).
</p>


<h3>Format file</h3>

<p><code>format_file</code> should contain the information about SAS formats. It can be either
</p>

<ul>
<li><p> a <code>procformat.sas</code> file, containing the whole PROC FORMAT
</p>
</li>
<li><p> a catalog file (<code>.sas7bcat</code>)
</p>
</li>
<li><p> or a data file (<code>.csv</code> or <code>.sas7bdat</code>) containing 3 columns: the SAS format name (repeated),
each level, and its associated label. Use <code>options(edc_var_format_name="xxx", edc_var_level="xxx", edc_var_label="xxx")</code> to specify the names of the columns.
</p>
</li></ul>


<hr>
<h2 id='read_all_xpt'>Read all <code>.xpt</code> files in a directory</h2><span id='topic+read_all_xpt'></span><span id='topic+read_tm_all_xpt'></span>

<h3>Description</h3>

<p>Read all <code>.xpt</code> files in a directory (unzipped TrialMaster archive). <br />
If <code style="white-space: pre;">&#8288;7zip&#8288;</code> is installed, you should probably rather use <code><a href="#topic+read_trialmaster">read_trialmaster()</a></code> instead. <br />
If a <code>procformat.sas</code> file exists in the directory, formats will be applied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_all_xpt(
  path,
  ...,
  format_file = "procformat.sas",
  clean_names_fun = NULL,
  split_mixed = FALSE,
  extend_lookup = TRUE,
  datetime_extraction = "guess",
  verbose = getOption("edc_read_verbose", 1),
  directory = "deprecated",
  key_columns = "deprecated"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_all_xpt_+3A_path">path</code></td>
<td>
<p>[<code>character(1)</code>]<br /> the path to the directory containing all <code>.xpt</code> files.</p>
</td></tr>
<tr><td><code id="read_all_xpt_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="read_all_xpt_+3A_format_file">format_file</code></td>
<td>
<p>[<code>character(1)</code>]<br /> the path to the file that should be used to apply formats. See details. Use <code>NULL</code> to not apply formats.</p>
</td></tr>
<tr><td><code id="read_all_xpt_+3A_clean_names_fun">clean_names_fun</code></td>
<td>
<p>[<code>function</code>]<br /> a function to clean column names, e.g. <a href="base.html#topic+tolower">tolower</a>, <code><a href="janitor.html#topic+clean_names">janitor::clean_names()</a></code>,...</p>
</td></tr>
<tr><td><code id="read_all_xpt_+3A_split_mixed">split_mixed</code></td>
<td>
<p>[<code>logical(1): FALSE</code>]<br /> whether to split mixed datasets. See <a href="#topic+split_mixed_datasets">split_mixed_datasets</a>.</p>
</td></tr>
<tr><td><code id="read_all_xpt_+3A_extend_lookup">extend_lookup</code></td>
<td>
<p>[<code>character(1): FALSE</code>]<br /> whether to enrich the lookup table. See <a href="#topic+extend_lookup">extend_lookup</a>.</p>
</td></tr>
<tr><td><code id="read_all_xpt_+3A_datetime_extraction">datetime_extraction</code></td>
<td>
<p>[<code>POSIXt(1)</code>]<br /> the datetime of the data extraction. Default to the most common date of last modification in <code>directory</code>.</p>
</td></tr>
<tr><td><code id="read_all_xpt_+3A_verbose">verbose</code></td>
<td>
<p>[<code>logical(1)</code>]<br /> one of <code>c(0, 1, 2)</code>. The higher, the more information will be printed.</p>
</td></tr>
<tr><td><code id="read_all_xpt_+3A_directory">directory</code></td>
<td>
<p>deprecated</p>
</td></tr>
<tr><td><code id="read_all_xpt_+3A_key_columns">key_columns</code></td>
<td>
<p>deprecated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing one dataframe for each <code>.xpt</code> file in the folder, the extraction date (<code>datetime_extraction</code>), and a summary of all imported tables (<code>.lookup</code>).
</p>


<h3>Format file</h3>

<p><code>format_file</code> should contain the information about SAS formats. It can be either
</p>

<ul>
<li><p> a <code>procformat.sas</code> file, containing the whole PROC FORMAT
</p>
</li>
<li><p> or a data file (.csv or .sas7bdat) containing 3 columns: the SAS format name (repeated),
each level, and its associated label. Use <code>options(edc_var_format_name="xxx", edc_var_level="xxx", edc_var_label="xxx")</code> to specify the names of the columns.
</p>
</li></ul>


<hr>
<h2 id='read_trialmaster'>Read the <code>.zip</code> archive of a TrialMaster export</h2><span id='topic+read_trialmaster'></span>

<h3>Description</h3>

<p>Import the <code>.zip</code> archive of a TrialMaster trial export as a list of dataframes. The archive filename should be leaved untouched as it contains the project name and the date of extraction. <br />
Generate a <code>.rds</code> cache file for future reads. <br />
If <code style="white-space: pre;">&#8288;7zip&#8288;</code> is not installed or available, use <code><a href="#topic+read_tm_all_xpt">read_tm_all_xpt()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_trialmaster(
  archive,
  ...,
  use_cache = "write",
  clean_names_fun = NULL,
  split_mixed = FALSE,
  extend_lookup = TRUE,
  pw = getOption("trialmaster_pw"),
  verbose = getOption("edc_read_verbose", 1),
  key_columns = "deprecated"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_trialmaster_+3A_archive">archive</code></td>
<td>
<p>[<code>character(1)</code>]<br /> the path to the archive</p>
</td></tr>
<tr><td><code id="read_trialmaster_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="read_trialmaster_+3A_use_cache">use_cache</code></td>
<td>
<p>[<code>mixed(1)</code>: &quot;write&quot;]<br /> controls the <code>.rds</code> cache. If <code>TRUE</code>, read the cache if any or extract the archive and create a cache. If <code>FALSE</code> extract the archive without creating a cache file. Can also be <code>"read"</code> or <code>"write"</code>.</p>
</td></tr>
<tr><td><code id="read_trialmaster_+3A_clean_names_fun">clean_names_fun</code></td>
<td>
<p>[<code>function</code>]<br /> a function to clean column names, e.g. <a href="base.html#topic+tolower">tolower</a>, <code><a href="janitor.html#topic+clean_names">janitor::clean_names()</a></code>,...</p>
</td></tr>
<tr><td><code id="read_trialmaster_+3A_split_mixed">split_mixed</code></td>
<td>
<p>[<code>logical(1): FALSE</code>]<br /> whether to split mixed datasets. See <a href="#topic+split_mixed_datasets">split_mixed_datasets</a>.</p>
</td></tr>
<tr><td><code id="read_trialmaster_+3A_extend_lookup">extend_lookup</code></td>
<td>
<p>[<code>character(1): FALSE</code>]<br /> whether to enrich the lookup table. See <a href="#topic+extend_lookup">extend_lookup</a>.</p>
</td></tr>
<tr><td><code id="read_trialmaster_+3A_pw">pw</code></td>
<td>
<p>[<code>character(1)</code>]<br /> The password if the archive is protected. To avoid writing passwords in plain text, it is probably better to use <code>options(trialmaster_pw="xxx")</code> instead though.</p>
</td></tr>
<tr><td><code id="read_trialmaster_+3A_verbose">verbose</code></td>
<td>
<p>[<code>logical(1)</code>]<br /> one of <code>c(0, 1, 2)</code>. The higher, the more information will be printed.</p>
</td></tr>
<tr><td><code id="read_trialmaster_+3A_key_columns">key_columns</code></td>
<td>
<p>deprecated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing one dataframe for each <code>.xpt</code> file in the folder, the extraction date (<code>datetime_extraction</code>), and a summary of all imported tables (<code>.lookup</code>).
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span><span id='topic+tibble'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+reexports">%&gt;%</a></code></p>
</dd>
<dt>tibble</dt><dd><p><code><a href="tibble.html#topic+tibble">tibble</a></code></p>
</dd>
</dl>

<hr>
<h2 id='save_list'>Save a list as <code>.RData</code> file</h2><span id='topic+save_list'></span>

<h3>Description</h3>

<p>Save a list as <code>.RData</code> file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_list(x, filename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="save_list_+3A_x">x</code></td>
<td>
<p>a list</p>
</td></tr>
<tr><td><code id="save_list_+3A_filename">filename</code></td>
<td>
<p>the filename, with the <code>.RData</code> extension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing, called for its side-effect
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=list(a=1, b=mtcars)
save_list(x, "test.RData")
load("test.RData")
file.remove("test.RData")
print(a)
print(nrow(b))
</code></pre>

<hr>
<h2 id='save_plotly'>Save a plotly to an HTML file</h2><span id='topic+save_plotly'></span>

<h3>Description</h3>

<p>Save a plotly to an HTML file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_plotly(p, file, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="save_plotly_+3A_p">p</code></td>
<td>
<p>a plot object (<code>plotly</code> or <code>ggplot</code>)</p>
</td></tr>
<tr><td><code id="save_plotly_+3A_file">file</code></td>
<td>
<p>a file path to save the HTML file</p>
</td></tr>
<tr><td><code id="save_plotly_+3A_...">...</code></td>
<td>
<p>passed on to <a href="htmlwidgets.html#topic+saveWidget">htmlwidgets::saveWidget</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing, used for side effect
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
tm = edc_example_plot()
p = edc_swimmerplot(tm$.lookup, id_lim=c(5,45))
save_plotly(p, "graph/swimplots/edc_swimmerplot.html", title="My Swimmerplot")

## End(Not run)
</code></pre>

<hr>
<h2 id='save_sessioninfo'>Save <code>sessionInfo()</code> output</h2><span id='topic+save_sessioninfo'></span>

<h3>Description</h3>

<p>Save <code>sessionInfo()</code> output into a text file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_sessioninfo(path = "check/session_info.txt", with_date = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="save_sessioninfo_+3A_path">path</code></td>
<td>
<p>target path to write the file</p>
</td></tr>
<tr><td><code id="save_sessioninfo_+3A_with_date">with_date</code></td>
<td>
<p>whether to insert the date before the file extension</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   save_sessioninfo()

## End(Not run)
</code></pre>

<hr>
<h2 id='search_for_newer_data'>Search for newer data</h2><span id='topic+search_for_newer_data'></span>

<h3>Description</h3>

<p>Search in some folders if a TrialMaster database more recent than the current extraction is present. By default, it will search the &quot;data&quot; folder and the OS usual &quot;Downloads&quot; folder. If a newer database is found, user will be asked if they want to move it to the &quot;data&quot; folder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_for_newer_data(
  archive,
  ...,
  source = path_home("Downloads"),
  target = "data",
  ask = TRUE,
  advice = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="search_for_newer_data_+3A_archive">archive</code></td>
<td>
<p>TM archive path, giving the project name and date</p>
</td></tr>
<tr><td><code id="search_for_newer_data_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="search_for_newer_data_+3A_source">source</code></td>
<td>
<p>the path vector to be searched, default to both &quot;data&quot; and the usual &quot;Downloads&quot; folder</p>
</td></tr>
<tr><td><code id="search_for_newer_data_+3A_target">target</code></td>
<td>
<p>the path where files should be copied</p>
</td></tr>
<tr><td><code id="search_for_newer_data_+3A_ask">ask</code></td>
<td>
<p>whether to ask the user to move the file to &quot;data&quot;</p>
</td></tr>
<tr><td><code id="search_for_newer_data_+3A_advice">advice</code></td>
<td>
<p>whether to advice how to move it instead, if <code>ask==FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the path to the newer file, invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  archive = "data/MYPROJECT_ExportTemplate_xxx_SAS_XPORT_2024_06_01_12_00.zip"
  #tm = read_trialmaster(archive)
  search_for_newer_data(archive)

## End(Not run)
</code></pre>

<hr>
<h2 id='select_distinct'>Select only distinct columns</h2><span id='topic+select_distinct'></span>

<h3>Description</h3>

<p>Select all columns that has only one level for a given grouping scope.
Useful when dealing with mixed datasets containing both long data and repeated short data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_distinct(df, .by)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_distinct_+3A_df">df</code></td>
<td>
<p>a dataframe</p>
</td></tr>
<tr><td><code id="select_distinct_+3A_.by">.by</code></td>
<td>
<p>optional grouping columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>df</code> with less columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tm = edc_example_ae()
tm$ae %&gt;% names
tm$ae %&gt;% select_distinct() %&gt;% names
tm$ae %&gt;% select_distinct(.by=subjid) %&gt;% names
</code></pre>

<hr>
<h2 id='split_mixed_datasets'>Split mixed datasets</h2><span id='topic+split_mixed_datasets'></span>

<h3>Description</h3>

<p>Split mixed tables, i.e. tables that hold both long data (N values per patient) and short data (one value per patient, duplicated on N lines), into one long table and one short table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_mixed_datasets(
  datasets = get_datasets(),
  id = get_subjid_cols(),
  ...,
  ignore_cols = get_meta_cols(0.95),
  output_code = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_mixed_datasets_+3A_datasets">datasets</code></td>
<td>
<p>a dataframe or a list of dataframes to split. Default to all the datasets from <code>.lookup</code>.</p>
</td></tr>
<tr><td><code id="split_mixed_datasets_+3A_id">id</code></td>
<td>
<p>the patient identifier, probably &quot;SUBJID&quot;. Should be shared by all datasets. Case-insensitive.</p>
</td></tr>
<tr><td><code id="split_mixed_datasets_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="split_mixed_datasets_+3A_ignore_cols">ignore_cols</code></td>
<td>
<p>columns to ignore when considering a table as long. Default to <code>getOption("edc_cols_crfname", "CRFNAME")</code>. Case-insensitive.</p>
</td></tr>
<tr><td><code id="split_mixed_datasets_+3A_output_code">output_code</code></td>
<td>
<p>whether to print the code to explicitly write. Can also be a file path.</p>
</td></tr>
<tr><td><code id="split_mixed_datasets_+3A_verbose">verbose</code></td>
<td>
<p>whether to print informations about the process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the new long and short tables. Use <code><a href="#topic+load_list">load_list()</a></code> to load them into the global environment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#tm = read_trialmaster("filename.zip", pw="xx")
tm = edc_example_mixed()
names(tm)
#load_list(tm)
print(tm$long_mixed) #`val1` and `val2` are long but `val3` is short

mixed_data = split_mixed_datasets(tm, id="subjid", verbose=TRUE)
load_list(mixed_data)
print(long_mixed_short) 
print(long_mixed_long) 

#alternatively, get the code and only use the datasets you need
split_mixed_datasets(tm, id="SUBJID", output_code=TRUE)
filename = tempfile("mixed_code", fileext=".R")
split_mixed_datasets(tm, id="SUBJID", output_code=filename)
readLines(filename)
</code></pre>

<hr>
<h2 id='table_format'>Identify if a dataframe has a long or a wide format</h2><span id='topic+table_format'></span>

<h3>Description</h3>

<p>A dataset is either in the wide format or in the long format (<a href="https://towardsdatascience.com/long-and-wide-formats-in-data-explained-e48d7c9a06cb">link</a>).
This function identifies the format of a dataframe with respect to a subject ID.
If a dataframe has some wide and long columns, it is considered &quot;mixed&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_format(
  df,
  id = get_subjid_cols(),
  ...,
  ignore_cols = get_meta_cols(0.95),
  na_rm = FALSE,
  warn = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="table_format_+3A_df">df</code></td>
<td>
<p>a dataframe</p>
</td></tr>
<tr><td><code id="table_format_+3A_id">id</code></td>
<td>
<p>the identifying subject ID</p>
</td></tr>
<tr><td><code id="table_format_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="table_format_+3A_ignore_cols">ignore_cols</code></td>
<td>
<p>columns to ignore. Usually meta columns (see <a href="#topic+get_meta_cols">get_meta_cols</a>).</p>
</td></tr>
<tr><td><code id="table_format_+3A_na_rm">na_rm</code></td>
<td>
<p>whether to consider missing values</p>
</td></tr>
<tr><td><code id="table_format_+3A_warn">warn</code></td>
<td>
<p>whether to warn if ID is not found</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a string value in <code style="white-space: pre;">&#8288;c("wide", "long", "mixed)&#8288;</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tm = edc_example_mixed()
sapply(tm, table_format, warn=FALSE) 
</code></pre>

<hr>
<h2 id='unify'>Unify a vector</h2><span id='topic+unify'></span>

<h3>Description</h3>

<p>Turn a vector of length N to a vector of length 1 after checking that there is only one unique value. Useful to safely flatten a duplicated table. This preserves the <code>label</code> attribute if set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unify(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unify_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of length 1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>unify(c(1,1,1,1))
#unify(c(1,1,2,1)) #warning

library(dplyr)
x=tibble(id=rep(letters[1:5],10), value=rep(1:5,10))
x %&gt;% group_by(id) %&gt;% summarise(value=unify(value)) #safer than `value=value[1]`
x$value[2]=1
#x %&gt;% group_by(id) %&gt;% summarise(value=unify(value)) #warning about that non-unique value
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
