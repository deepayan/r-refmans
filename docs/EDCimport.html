<!DOCTYPE html><html><head><title>Help for package EDCimport</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EDCimport}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#assert_no_duplicate'><p>Assert that a dataset has one row per patient</p></a></li>
<li><a href='#check_subjid'><p>Check the completion of the subject ID column</p></a></li>
<li><a href='#data_example'><p>Example databases</p></a></li>
<li><a href='#edc_options'><p>Set global options for <code>EDCimport</code></p></a></li>
<li><a href='#edc_peek_options'><p>See which <code>EDCimport</code> option is currently set.</p></a></li>
<li><a href='#edc_reset_options'><p>Reset all <code>EDCimport</code> options.</p></a></li>
<li><a href='#edc_swimmerplot'><p>Swimmer plot of all dates columns</p></a></li>
<li><a href='#EDCimport-package'><p>EDCimport: Import Data from EDC Software</p></a></li>
<li><a href='#extend_lookup'><p>Extend the lookup table</p></a></li>
<li><a href='#find_keyword'><p>Find a keyword in the whole database</p></a></li>
<li><a href='#get_datasets'><p>Retrieve the datasets as a list of data.frames</p></a></li>
<li><a href='#get_key_cols'><p>Important column names</p></a></li>
<li><a href='#get_lookup'><p>Generate a lookup table</p></a></li>
<li><a href='#load_as_list'><p>Load a <code>.RData</code> file as a list</p></a></li>
<li><a href='#load_list'><p>Load a list in an environment</p></a></li>
<li><a href='#manual_correction'><p>Manual correction</p></a></li>
<li><a href='#read_tm_all_xpt'><p>Read all <code>.xpt</code> files in a directory</p></a></li>
<li><a href='#read_trialmaster'><p>Read the <code>.zip</code> archive of a TrialMaster export</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#save_list'><p>Save a list as <code>.RData</code> file</p></a></li>
<li><a href='#split_mixed_datasets'><p>Split mixed datasets</p></a></li>
<li><a href='#unify'><p>Unify a vector</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.4.1</td>
</tr>
<tr>
<td>Title:</td>
<td>Import Data from EDC Software</td>
</tr>
<tr>
<td>Description:</td>
<td>A convenient toolbox to import data exported from Electronic Data Capture (EDC) software 'TrialMaster'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/DanChaltiel/EDCimport">https://github.com/DanChaltiel/EDCimport</a>,
<a href="https://danchaltiel.github.io/EDCimport/">https://danchaltiel.github.io/EDCimport/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/DanChaltiel/EDCimport/issues">https://github.com/DanChaltiel/EDCimport/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, dplyr, forcats, glue, ggplot2, haven, labelled, purrr,
readr, rlang, stringr, tibble, tidyr, tidyselect, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>callr, gtools, janitor, knitr, plotly, testthat (&ge; 3.1.8),
vdiffr, withr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-18 15:24:43 UTC; Dan</td>
</tr>
<tr>
<td>Author:</td>
<td>Dan Chaltiel <a href="https://orcid.org/0000-0003-3488-779X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dan Chaltiel &lt;dan.chaltiel@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-19 13:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='assert_no_duplicate'>Assert that a dataset has one row per patient</h2><span id='topic+assert_no_duplicate'></span>

<h3>Description</h3>

<p>Check that there is no duplicate on the column holding patient ID in a pipeable style. <br />
Mostly useful after joining two datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_no_duplicate(df, id_col = get_key_cols())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assert_no_duplicate_+3A_df">df</code></td>
<td>
<p>the dataset</p>
</td></tr>
<tr><td><code id="assert_no_duplicate_+3A_id_col">id_col</code></td>
<td>
<p><em>(optional)</em> the name of the columns holding patient ID</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>df</code> dataset, unchanged
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#without duplicate =&gt; no error, continue the pipeline
tibble(subjid=c(1:10)) %&gt;% assert_no_duplicate() %&gt;% nrow()

#with duplicate =&gt; throws an error
#tibble(subjid=c(1:10, 1:2)) %&gt;% assert_no_duplicate() %&gt;% nrow()
</code></pre>

<hr>
<h2 id='check_subjid'>Check the completion of the subject ID column</h2><span id='topic+check_subjid'></span>

<h3>Description</h3>

<p>Compare a subject ID vector to the study's reference subject ID (usually something like <code>enrolres$subjid</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_subjid(x, ref = getOption("edc_subjid_ref"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_subjid_+3A_x">x</code></td>
<td>
<p>the subject ID column to check</p>
</td></tr>
<tr><td><code id="check_subjid_+3A_ref">ref</code></td>
<td>
<p>the reference for subject ID. Should usually be set through <code>options(edc_subjid_ref=xxx)</code>. See example.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing, called for warnings
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tm = edc_example()
load_list(tm)
options(edc_subjid_ref=db0$SUBJID)
#usually, you set something like:
#options(edc_subjid_ref=enrolres$subjid)
check_subjid(db1$SUBJID)
check_subjid(db1$SUBJID %&gt;% setdiff(2))
check_subjid(c(db1$SUBJID, 99))
</code></pre>

<hr>
<h2 id='data_example'>Example databases</h2><span id='topic+data_example'></span><span id='topic+edc_example_mixed'></span><span id='topic+edc_example_plot'></span><span id='topic+edc_example'></span>

<h3>Description</h3>

<p>List of tables used in EDCimport examples:
</p>

<ul>
<li> <p><code>edc_example()</code> can be used as the result of <code><a href="#topic+read_trialmaster">read_trialmaster()</a></code>
</p>
</li>
<li> <p><code>edc_example_plot()</code> can be used to test <code><a href="#topic+edc_swimmerplot">edc_swimmerplot()</a></code>
</p>
</li>
<li> <p><code>edc_example_mixed()</code> can be used to test <code><a href="#topic+split_mixed_datasets">split_mixed_datasets()</a></code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>edc_example_mixed(N = 100)

edc_example_plot(N = 50, seed = 42)

edc_example(N = 50, seed = 42)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_example_+3A_n">N</code></td>
<td>
<p>the number of patients</p>
</td></tr>
<tr><td><code id="data_example_+3A_seed">seed</code></td>
<td>
<p>the random seed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of tables
</p>

<hr>
<h2 id='edc_options'>Set global options for <code>EDCimport</code></h2><span id='topic+edc_options'></span>

<h3>Description</h3>

<p>Use this function to manage your <code>EDCimport</code> parameters globally while taking advantage of autocompletion. <br />
Use <code><a href="#topic+edc_peek_options">edc_peek_options()</a></code> to see which option is currently set and <code><a href="#topic+edc_reset_options">edc_reset_options()</a></code> to set all options back to default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edc_options(
  ...,
  trialmaster_pw,
  path_7zip,
  edc_lookup,
  edc_subjid_ref,
  edc_plotly,
  edc_cols_id,
  edc_cols_crfname,
  edc_read_verbose,
  edc_correction_verbose,
  edc_get_key_cols_verbose,
  edc_lookup_overwrite_warn,
  .local = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edc_options_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="edc_options_+3A_trialmaster_pw">trialmaster_pw</code></td>
<td>
<p>the password of the trialmaster zip archive. For instance, you can use <code>edc_options(trialmaster_pw="my_pwd")</code> in the console once per session, so that you don't have to write the password in clear in your R code</p>
</td></tr>
<tr><td><code id="edc_options_+3A_path_7zip">path_7zip</code></td>
<td>
<p>the path to the 7zip executable. Default to <code>"C:/Program Files/7-Zip/"</code>.</p>
</td></tr>
<tr><td><code id="edc_options_+3A_edc_lookup">edc_lookup</code></td>
<td>
<p><strong>(Internal)</strong> a reference to the lookup table (usually <code>.lookup</code>). Should usually not be changed manually.</p>
</td></tr>
<tr><td><code id="edc_options_+3A_edc_subjid_ref">edc_subjid_ref</code></td>
<td>
<p><strong>used in <a href="#topic+check_subjid">check_subjid</a></strong> the vector of the reference subject IDs. You should usually write <code>edc_options(edc_subjid_ref=enrolres$subjid)</code>.</p>
</td></tr>
<tr><td><code id="edc_options_+3A_edc_plotly">edc_plotly</code></td>
<td>
<p><strong>used in <a href="#topic+edc_swimmerplot">edc_swimmerplot</a></strong> whether to use plotly to visualize the plot.</p>
</td></tr>
<tr><td><code id="edc_options_+3A_edc_cols_id">edc_cols_id</code>, <code id="edc_options_+3A_edc_cols_crfname">edc_cols_crfname</code></td>
<td>
<p><strong>used in <a href="#topic+get_key_cols">get_key_cols</a></strong> the name of the columns holding the subject id (default to <code>c("ptno", "subjid")</code>) and the CRF form name (default to <code>c("crfname")</code>). It is case-insensitive.</p>
</td></tr>
<tr><td><code id="edc_options_+3A_edc_read_verbose">edc_read_verbose</code>, <code id="edc_options_+3A_edc_correction_verbose">edc_correction_verbose</code>, <code id="edc_options_+3A_edc_get_key_cols_verbose">edc_get_key_cols_verbose</code></td>
<td>
<p>the verbosity of the output of functions <a href="#topic+read_trialmaster">read_trialmaster</a> and <a href="#topic+read_tm_all_xpt">read_tm_all_xpt</a>, <a href="#topic+manual_correction">manual_correction</a>, and <a href="#topic+get_key_cols">get_key_cols</a>. For example, set <code>edc_options(edc_read_verbose=0)</code> to silence the first 2.</p>
</td></tr>
<tr><td><code id="edc_options_+3A_edc_lookup_overwrite_warn">edc_lookup_overwrite_warn</code></td>
<td>
<p>default to TRUE. Whether there should be warning when overwriting <code>.lookup</code> (like when reading 2 databases successively)</p>
</td></tr>
<tr><td><code id="edc_options_+3A_.local">.local</code></td>
<td>
<p>if TRUE, the effect will only apply to the local frame (internally using <code>rlang::local_options()</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, called for its side effects
</p>

<hr>
<h2 id='edc_peek_options'>See which <code>EDCimport</code> option is currently set.</h2><span id='topic+edc_peek_options'></span>

<h3>Description</h3>

<p>See which <code>EDCimport</code> option is currently set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edc_peek_options(keep_null = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edc_peek_options_+3A_keep_null">keep_null</code></td>
<td>
<p>set to TRUE to get a list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of EDCimport options
</p>

<hr>
<h2 id='edc_reset_options'>Reset all <code>EDCimport</code> options.</h2><span id='topic+edc_reset_options'></span>

<h3>Description</h3>

<p>Reset all <code>EDCimport</code> options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edc_reset_options(
  except = c("edc_lookup", "trialmaster_pw", "path_7zip"),
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edc_reset_options_+3A_except">except</code></td>
<td>
<p>options that are not reset by default</p>
</td></tr>
<tr><td><code id="edc_reset_options_+3A_quiet">quiet</code></td>
<td>
<p>set to <code>TRUE</code> to remove the message.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, called for its side effects
</p>

<hr>
<h2 id='edc_swimmerplot'>Swimmer plot of all dates columns</h2><span id='topic+edc_swimmerplot'></span>

<h3>Description</h3>

<p>Join all tables from <code>.lookup$dataset</code> on <code>id</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edc_swimmerplot(
  .lookup = getOption("edc_lookup"),
  ...,
  id = get_key_cols()$patient_id,
  group = NULL,
  origin = NULL,
  id_lim = NULL,
  exclude = NULL,
  time_unit = c("days", "weeks", "months", "years"),
  aes_color = c("variable", "label"),
  plotly = getOption("edc_plotly", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edc_swimmerplot_+3A_.lookup">.lookup</code></td>
<td>
<p>the lookup table, default to <code>getOption("edc_lookup")</code></p>
</td></tr>
<tr><td><code id="edc_swimmerplot_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="edc_swimmerplot_+3A_id">id</code></td>
<td>
<p>the patient identifier. Will be coerced as numeric.</p>
</td></tr>
<tr><td><code id="edc_swimmerplot_+3A_group">group</code></td>
<td>
<p>a grouping variable, given as &quot;dataset$column&quot;</p>
</td></tr>
<tr><td><code id="edc_swimmerplot_+3A_origin">origin</code></td>
<td>
<p>a variable to consider as time 0, given as &quot;dataset$column&quot;</p>
</td></tr>
<tr><td><code id="edc_swimmerplot_+3A_id_lim">id_lim</code></td>
<td>
<p>a numeric vector of length 2 providing the minimum and maximum <code>id</code> to subset on.</p>
</td></tr>
<tr><td><code id="edc_swimmerplot_+3A_exclude">exclude</code></td>
<td>
<p>a character vector of variables to exclude, in the form <code>dataset$column</code>. Can be a regex, but <code>$</code> symbols don't count. Case-insensitive.</p>
</td></tr>
<tr><td><code id="edc_swimmerplot_+3A_time_unit">time_unit</code></td>
<td>
<p>if <code>origin!=NULL</code>, the unit to measure time. One of <code>c("days", "weeks", "months", "years")</code>.</p>
</td></tr>
<tr><td><code id="edc_swimmerplot_+3A_aes_color">aes_color</code></td>
<td>
<p>either <code>variable</code> (&quot;{dataset} - {column}&quot;) or <code>label</code> (the column label)</p>
</td></tr>
<tr><td><code id="edc_swimmerplot_+3A_plotly">plotly</code></td>
<td>
<p>whether to use <code>{plotly}</code> to get an interactive plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either a <code>plotly</code> or a <code>ggplot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#tm = read_trialmaster("filename.zip", pw="xx")
tm = edc_example_plot()
load_list(tm)
p = edc_swimmerplot(.lookup, id_lim=c(5,45))
p2 = edc_swimmerplot(.lookup, origin="db0$date_naissance", time_unit="weeks", 
                     exclude=c("DB1$DATE2", "db3$.*"))
p3 = edc_swimmerplot(.lookup, group="db0$group", aes_color="label")
## Not run: 
#save the plotly plot as HTML to share it
htmlwidgets::saveWidget(p, "edc_swimmerplot.html", selfcontained=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='EDCimport-package'>EDCimport: Import Data from EDC Software</h2><span id='topic+EDCimport'></span><span id='topic+EDCimport-package'></span>

<h3>Description</h3>

<p>A convenient toolbox to import data exported from Electronic Data Capture (EDC) software 'TrialMaster'.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Dan Chaltiel <a href="mailto:dan.chaltiel@gmail.com">dan.chaltiel@gmail.com</a> (<a href="https://orcid.org/0000-0003-3488-779X">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/DanChaltiel/EDCimport">https://github.com/DanChaltiel/EDCimport</a>
</p>
</li>
<li> <p><a href="https://danchaltiel.github.io/EDCimport/">https://danchaltiel.github.io/EDCimport/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/DanChaltiel/EDCimport/issues">https://github.com/DanChaltiel/EDCimport/issues</a>
</p>
</li></ul>


<hr>
<h2 id='extend_lookup'>Extend the lookup table</h2><span id='topic+extend_lookup'></span>

<h3>Description</h3>

<p>This utility extends the lookup table to include:
</p>

<ul>
<li> <p><code>n_id</code> the number of patients present in the dataset
</p>
</li>
<li> <p><code>rows_per_id</code> the mean number of row per patient
</p>
</li>
<li> <p><code>crfname</code> the actual name of the dataset
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>extend_lookup(
  lookup,
  ...,
  key_columns = get_key_cols(lookup),
  datasets = get_datasets(lookup)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extend_lookup_+3A_lookup">lookup</code></td>
<td>
<p>[<code>data.frame(1)</code>]<br /> the lookup table</p>
</td></tr>
<tr><td><code id="extend_lookup_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="extend_lookup_+3A_key_columns">key_columns</code></td>
<td>
<p>[<code>list(n)</code>]<br /> for experts only</p>
</td></tr>
<tr><td><code id="extend_lookup_+3A_datasets">datasets</code></td>
<td>
<p>[<code>data.frame(n)</code>]<br /> for experts only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the lookup, extended
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#tm = read_trialmaster("filename.zip", pw="xx")
tm = edc_example_mixed()
load_list(tm)
.lookup
.lookup = extend_lookup(.lookup)
.lookup
</code></pre>

<hr>
<h2 id='find_keyword'>Find a keyword in the whole database</h2><span id='topic+find_keyword'></span>

<h3>Description</h3>

<p>Find a keyword in all names and labels of a list of datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_keyword(keyword, data = getOption("edc_lookup"), ignore_case = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_keyword_+3A_keyword">keyword</code></td>
<td>
<p>the keyword to search for. Can handle regular expressions (see examples).</p>
</td></tr>
<tr><td><code id="find_keyword_+3A_data">data</code></td>
<td>
<p>the lookup dataframe where to search the keyword. Can be set using <code>edc_options(edc_lookup=my_data)</code>, which is done automatically when calling <code><a href="#topic+read_trialmaster">read_trialmaster()</a></code>.</p>
</td></tr>
<tr><td><code id="find_keyword_+3A_ignore_case">ignore_case</code></td>
<td>
<p>should case differences be ignored in the match? Default to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
path = system.file("extdata/Example_Export_SAS_XPORT_2022_08_25_15_16.zip", 
                   package="EDCimport", mustWork=TRUE)
w = read_trialmaster(path, verbose=FALSE)

find_keyword("patient")

#with regex
find_keyword("patient$")
find_keyword("\\d")
find_keyword("(Trial|Form) Name")
find_keyword("\\(") #you need to escape special characters

## End(Not run)
</code></pre>

<hr>
<h2 id='get_datasets'>Retrieve the datasets as a list of data.frames</h2><span id='topic+get_datasets'></span>

<h3>Description</h3>

<p>Get the datasets from the lookup table as a list of data.frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_datasets(lookup = getOption("edc_lookup"), envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_datasets_+3A_lookup">lookup</code></td>
<td>
<p>the lookup table</p>
</td></tr>
<tr><td><code id="get_datasets_+3A_envir">envir</code></td>
<td>
<p>(internal use)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of all datasets
</p>

<hr>
<h2 id='get_key_cols'>Important column names</h2><span id='topic+get_key_cols'></span>

<h3>Description</h3>

<p>Retrieve names of <code>patient_id</code> (usually &quot;SUBJID&quot; and &quot;PATNO&quot;) and <code>crfname</code> (usually &quot;CRFNAME&quot;) from the actual names of the datasets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_key_cols(lookup = getOption("edc_lookup"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_key_cols_+3A_lookup">lookup</code></td>
<td>
<p>the lookup table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list(2) of characters with names <code>patient_id</code> and <code>crfname</code>
</p>

<hr>
<h2 id='get_lookup'>Generate a lookup table</h2><span id='topic+get_lookup'></span>

<h3>Description</h3>

<p>Generate a lookup table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_lookup(data_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_lookup_+3A_data_list">data_list</code></td>
<td>
<p>a list containing at least 1 dataframe</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe summarizing column names and labels
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = edc_example()
x$.lookup=NULL
lk = get_lookup(x)
lk
lk %&gt;% tidyr::unnest(c(names, labels))

</code></pre>

<hr>
<h2 id='load_as_list'>Load a <code>.RData</code> file as a list</h2><span id='topic+load_as_list'></span>

<h3>Description</h3>

<p>Instead of loading a <code>.RData</code> file in the global environment, extract every object into a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_as_list(filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_as_list_+3A_filename">filename</code></td>
<td>
<p>the filename, with the <code>.RData</code> extension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = list(a=1, b=mtcars)
save_list(x, "test.RData")
y = load_as_list("test.RData")
print(y$a)
</code></pre>

<hr>
<h2 id='load_list'>Load a list in an environment</h2><span id='topic+load_list'></span>

<h3>Description</h3>

<p>Load a list in an environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_list(x, env = parent.frame(), remove = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_list_+3A_x">x</code></td>
<td>
<p>a list</p>
</td></tr>
<tr><td><code id="load_list_+3A_env">env</code></td>
<td>
<p>the environment onto which the list should be loaded</p>
</td></tr>
<tr><td><code id="load_list_+3A_remove">remove</code></td>
<td>
<p>if <code>TRUE</code>, <code>x</code> will be removed from the environment afterward</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing, called for its side-effect
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x=list(a=1, b=mtcars)
load_list(x, remove=FALSE)
print(a)
print(nrow(b))

</code></pre>

<hr>
<h2 id='manual_correction'>Manual correction</h2><span id='topic+manual_correction'></span><span id='topic+reset_manual_correction'></span>

<h3>Description</h3>

<p>When finding wrong or unexpected values in an exported table, it can be useful to temporarily correct them by hard-coding a value.
However, this manual correction should be undone as soon as the central database is updated with the correction.
</p>

<ul>
<li> <p><code>manual_correction()</code> applies a correction in a specific table column location and throws an error if the correction is already in place. This check applies only once per R session so you can source your script without errors.
</p>
</li>
<li> <p><code>reset_manual_correction()</code> resets all checks. For instance, it is called by <code><a href="#topic+read_trialmaster">read_trialmaster()</a></code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>manual_correction(
  data,
  col,
  rows,
  wrong,
  correct,
  verbose = getOption("edc_correction_verbose", TRUE)
)

reset_manual_correction()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="manual_correction_+3A_data">data</code>, <code id="manual_correction_+3A_col">col</code>, <code id="manual_correction_+3A_rows">rows</code></td>
<td>
<p>the rows of a column of a dataframe where the error lies</p>
</td></tr>
<tr><td><code id="manual_correction_+3A_wrong">wrong</code></td>
<td>
<p>the actual wrong value</p>
</td></tr>
<tr><td><code id="manual_correction_+3A_correct">correct</code></td>
<td>
<p>the temporary correction value</p>
</td></tr>
<tr><td><code id="manual_correction_+3A_verbose">verbose</code></td>
<td>
<p>whether to print informations (once)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, used for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
x = iris %&gt;% mutate(id=row_number(), .before=1) %&gt;% as_tibble()
x$Sepal.Length[c(1,3,5)]

#1st correction is silent
manual_correction(x, Sepal.Length, rows=c(1,3,5),
                  wrong=c(5.1, 4.7, 5.0), correct=c(5, 4, 3))
x$Sepal.Length[c(1,3,5)]

#further correction is silent
manual_correction(x, Sepal.Length, rows=c(1,3,5),
                  wrong=c(5.1, 4.7, 5.0), correct=c(5, 4, 3)) 
                  
#if the database is corrected, an error is thrown
## Not run: 
reset_manual_correction()
x$Sepal.Length[c(1,3,5)] = c(5, 4, 3) #mimics db correction
manual_correction(x, Sepal.Length, rows=c(1,3,5),
                  wrong=c(5.1, 4.7, 5.0), correct=c(5, 4, 3))

## End(Not run)
</code></pre>

<hr>
<h2 id='read_tm_all_xpt'>Read all <code>.xpt</code> files in a directory</h2><span id='topic+read_tm_all_xpt'></span>

<h3>Description</h3>

<p>Read all <code>.xpt</code> files in a directory (unzipped TrialMaster archive). <br />
If <code style="white-space: pre;">&#8288;7zip&#8288;</code> is installed, you should probably rather use <code><a href="#topic+read_trialmaster">read_trialmaster()</a></code> instead. <br />
If a <code>procformat.sas</code> file exists in the directory, formats will be applied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_tm_all_xpt(
  directory,
  ...,
  format_file = "procformat.sas",
  clean_names_fun = NULL,
  split_mixed = FALSE,
  extend_lookup = TRUE,
  datetime_extraction = NULL,
  verbose = getOption("edc_read_verbose", 1),
  key_columns = "deprecated"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_tm_all_xpt_+3A_directory">directory</code></td>
<td>
<p>[<code>character(1)</code>]<br /> the path to the unzipped archive using SAS_XPORT format. Will read the extraction date from the directory name.</p>
</td></tr>
<tr><td><code id="read_tm_all_xpt_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="read_tm_all_xpt_+3A_format_file">format_file</code></td>
<td>
<p>[<code>character(1)</code>]<br /> the path to the <code>procformat.sas</code> file that should be used to apply formats. Use <code>NULL</code> to not apply formats.</p>
</td></tr>
<tr><td><code id="read_tm_all_xpt_+3A_clean_names_fun">clean_names_fun</code></td>
<td>
<p>[<code>function</code>]<br /> a function to clean column names, e.g. <a href="base.html#topic+tolower">tolower</a>, <code><a href="janitor.html#topic+clean_names">janitor::clean_names()</a></code>,...</p>
</td></tr>
<tr><td><code id="read_tm_all_xpt_+3A_split_mixed">split_mixed</code></td>
<td>
<p>[<code>logical(1): FALSE</code>]<br /> whether to split mixed datasets. See <a href="#topic+split_mixed_datasets">split_mixed_datasets</a>.</p>
</td></tr>
<tr><td><code id="read_tm_all_xpt_+3A_extend_lookup">extend_lookup</code></td>
<td>
<p>[<code>character(1): FALSE</code>]<br /> whether to enrich the lookup table. See <a href="#topic+extend_lookup">extend_lookup</a>.</p>
</td></tr>
<tr><td><code id="read_tm_all_xpt_+3A_datetime_extraction">datetime_extraction</code></td>
<td>
<p>[<code>POSIXt(1)</code>]<br /> the datetime of the data extraction. Default to the most common date of last modification in <code>directory</code>.</p>
</td></tr>
<tr><td><code id="read_tm_all_xpt_+3A_verbose">verbose</code></td>
<td>
<p>[<code>logical(1)</code>]<br /> one of <code>c(0, 1, 2)</code>. The higher, the more information will be printed.</p>
</td></tr>
<tr><td><code id="read_tm_all_xpt_+3A_key_columns">key_columns</code></td>
<td>
<p>deprecated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing one dataframe for each <code>.xpt</code> file in the folder, the extraction date (<code>datetime_extraction</code>), and a summary of all imported tables (<code>.lookup</code>). If not set yet, option <code>edc_lookup</code> is automatically set to <code>.lookup</code>.
</p>

<hr>
<h2 id='read_trialmaster'>Read the <code>.zip</code> archive of a TrialMaster export</h2><span id='topic+read_trialmaster'></span>

<h3>Description</h3>

<p>Import the <code>.zip</code> archive of a TrialMaster trial export as a list of dataframes. The archive filename should be leaved untouched as it contains the project name and the date of extraction. <br />
Generate a <code>.rds</code> cache file for future reads. <br />
If <code style="white-space: pre;">&#8288;7zip&#8288;</code> is not installed or available, use <code><a href="#topic+read_tm_all_xpt">read_tm_all_xpt()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_trialmaster(
  archive,
  ...,
  use_cache = "write",
  clean_names_fun = NULL,
  split_mixed = FALSE,
  extend_lookup = TRUE,
  pw = getOption("trialmaster_pw"),
  verbose = getOption("edc_read_verbose", 1),
  key_columns = "deprecated"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_trialmaster_+3A_archive">archive</code></td>
<td>
<p>[<code>character(1)</code>]<br /> the path to the archive</p>
</td></tr>
<tr><td><code id="read_trialmaster_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="read_trialmaster_+3A_use_cache">use_cache</code></td>
<td>
<p>[<code>mixed(1)</code>: &quot;write&quot;]<br /> controls the <code>.rds</code> cache. If <code>TRUE</code>, read the cache if any or extract the archive and create a cache. If <code>FALSE</code> extract the archive without creating a cache file. Can also be <code>"read"</code> or <code>"write"</code>.</p>
</td></tr>
<tr><td><code id="read_trialmaster_+3A_clean_names_fun">clean_names_fun</code></td>
<td>
<p>[<code>function</code>]<br /> a function to clean column names, e.g. <a href="base.html#topic+tolower">tolower</a>, <code><a href="janitor.html#topic+clean_names">janitor::clean_names()</a></code>,...</p>
</td></tr>
<tr><td><code id="read_trialmaster_+3A_split_mixed">split_mixed</code></td>
<td>
<p>[<code>logical(1): FALSE</code>]<br /> whether to split mixed datasets. See <a href="#topic+split_mixed_datasets">split_mixed_datasets</a>.</p>
</td></tr>
<tr><td><code id="read_trialmaster_+3A_extend_lookup">extend_lookup</code></td>
<td>
<p>[<code>character(1): FALSE</code>]<br /> whether to enrich the lookup table. See <a href="#topic+extend_lookup">extend_lookup</a>.</p>
</td></tr>
<tr><td><code id="read_trialmaster_+3A_pw">pw</code></td>
<td>
<p>[<code>character(1)</code>]<br /> The password if the archive is protected. To avoid writing passwords in plain text, it is probably better to use <code>options(trialmaster_pw="xxx")</code> instead though.</p>
</td></tr>
<tr><td><code id="read_trialmaster_+3A_verbose">verbose</code></td>
<td>
<p>[<code>logical(1)</code>]<br /> one of <code>c(0, 1, 2)</code>. The higher, the more information will be printed.</p>
</td></tr>
<tr><td><code id="read_trialmaster_+3A_key_columns">key_columns</code></td>
<td>
<p>deprecated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing one dataframe for each <code>.xpt</code> file in the folder, the extraction date (<code>datetime_extraction</code>), and a summary of all imported tables (<code>.lookup</code>). If not set yet, option <code>edc_lookup</code> is automatically set to <code>.lookup</code>.
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span><span id='topic+tibble'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+reexports">%&gt;%</a></code>, <code><a href="dplyr.html#topic+reexports">%&gt;%</a></code></p>
</dd>
<dt>tibble</dt><dd><p><code><a href="tibble.html#topic+tibble">tibble</a></code></p>
</dd>
</dl>

<hr>
<h2 id='save_list'>Save a list as <code>.RData</code> file</h2><span id='topic+save_list'></span>

<h3>Description</h3>

<p>Save a list as <code>.RData</code> file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_list(x, filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_list_+3A_x">x</code></td>
<td>
<p>a list</p>
</td></tr>
<tr><td><code id="save_list_+3A_filename">filename</code></td>
<td>
<p>the filename, with the <code>.RData</code> extension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing, called for its side-effect
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=list(a=1, b=mtcars)
save_list(x, "test.RData")
load("test.RData")
file.remove("test.RData")
print(a)
print(nrow(b))
</code></pre>

<hr>
<h2 id='split_mixed_datasets'>Split mixed datasets</h2><span id='topic+split_mixed_datasets'></span>

<h3>Description</h3>

<p>Split mixed tables, i.e. tables that hold both long data (N values per patient) and short data (one value per patient, duplicated on N lines), into one long table and one short table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_mixed_datasets(
  datasets = get_datasets(),
  id = get_key_cols()$patient_id,
  ...,
  ignore_cols = getOption("edc_cols_crfname", "CRFNAME"),
  output_code = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_mixed_datasets_+3A_datasets">datasets</code></td>
<td>
<p>a dataframe or a list of dataframes to split. Default to all the datasets from <code>.lookup</code>.</p>
</td></tr>
<tr><td><code id="split_mixed_datasets_+3A_id">id</code></td>
<td>
<p>the patient identifier, probably &quot;SUBJID&quot;. Should be shared by all datasets. Case-insensitive.</p>
</td></tr>
<tr><td><code id="split_mixed_datasets_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="split_mixed_datasets_+3A_ignore_cols">ignore_cols</code></td>
<td>
<p>columns to ignore when considering a table as long. Default to <code>getOption("edc_cols_crfname", "CRFNAME")</code>. Case-insensitive.</p>
</td></tr>
<tr><td><code id="split_mixed_datasets_+3A_output_code">output_code</code></td>
<td>
<p>whether to print the code to explicitly write. Can also be a file path.</p>
</td></tr>
<tr><td><code id="split_mixed_datasets_+3A_verbose">verbose</code></td>
<td>
<p>whether to print informations about the process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the new long and short tables. Use <code><a href="#topic+load_list">load_list()</a></code> to load them into the global environment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#tm = read_trialmaster("filename.zip", pw="xx")
tm = edc_example_mixed()
names(tm)
#load_list(tm)
print(tm$long_mixed) #`val1` and `val2` are long but `val3` is short

mixed_data = split_mixed_datasets(tm, id="subjid", verbose=TRUE)
load_list(mixed_data)
print(long_mixed_short) 
print(long_mixed_long) 

#alternatively, get the code and only use the datasets you need
split_mixed_datasets(tm, id="SUBJID", output_code=TRUE)
filename = tempfile("mixed_code", fileext=".R")
split_mixed_datasets(tm, id="SUBJID", output_code=filename)
readLines(filename)
</code></pre>

<hr>
<h2 id='unify'>Unify a vector</h2><span id='topic+unify'></span>

<h3>Description</h3>

<p>Turn a vector of length N to a vector of length 1 after checking that there is only one unique value. Useful to safely flatten a duplicated table. This preserves the <code>label</code> attribute if set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unify(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unify_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of length 1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>unify(c(1,1,1,1))
#unify(c(1,1,2,1)) #warning

library(dplyr)
x=tibble(id=rep(letters[1:5],10), value=rep(1:5,10))
x %&gt;% group_by(id) %&gt;% summarise(value=unify(value)) #safer than `value=value[1]`
x$value[2]=1
#x %&gt;% group_by(id) %&gt;% summarise(value=unify(value)) #warning about that non-unique value
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
