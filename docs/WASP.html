<!DOCTYPE html><html><head><title>Help for package WASP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {WASP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#at.vt'><p>Variance Transformation Operation - AT(a trous)</p></a></li>
<li><a href='#at.vt.val'><p>Variance Transformation Operation for Validation</p></a></li>
<li><a href='#at.wd'><p>a trous (AT) based additive decompostion using Daubechies family wavelet</p></a></li>
<li><a href='#aus.coast'><p>Sample data: Australia map</p></a></li>
<li><a href='#data.AWAP.2.5'><p>Sample data: AWAP rainfall data over Australia</p></a></li>
<li><a href='#data.CI'><p>Sample data: Climate indices strongly influencing Australia climate</p></a></li>
<li><a href='#data.gen.ar1'><p>Generate predictor and response data from AR1 model.</p></a></li>
<li><a href='#data.gen.ar4'><p>Generate predictor and response data from AR4 model.</p></a></li>
<li><a href='#data.gen.ar9'><p>Generate predictor and response data from AR9 model.</p></a></li>
<li><a href='#data.gen.HL'><p>Generate predictor and response data: Hysteresis Loop</p></a></li>
<li><a href='#data.gen.Rossler'><p>Generate predictor and response data: Rossler system</p></a></li>
<li><a href='#data.gen.SW'><p>Generate predictor and response data: Sinewave model</p></a></li>
<li><a href='#data.gen.tar1'><p>Generate predictor and response data from TAR1 model.</p></a></li>
<li><a href='#data.gen.tar2'><p>Generate predictor and response data from TAR2 model.</p></a></li>
<li><a href='#data.HL'><p>Sample data: Hysteresis loop</p></a></li>
<li><a href='#data.SW1'><p>Sample data: Sinewave model 1 (SW1)</p></a></li>
<li><a href='#data.SW3'><p>Sample data: Sinewave model 3 (SW3)</p></a></li>
<li><a href='#dwt.vt'><p>Variance Transformation Operation - MRA</p></a></li>
<li><a href='#dwt.vt.val'><p>Variance Transformation Operation for Validation</p></a></li>
<li><a href='#fig.dwt.vt'><p>Plot function: Variance structure before and after variance transformation</p></a></li>
<li><a href='#Ind_AWAP.2.5'><p>Sample data: Index of AWAP grids with no missing data</p></a></li>
<li><a href='#knn'><p>Modified k-nearest neighbour conditional bootstrap or regression function estimation with extrapolation</p></a></li>
<li><a href='#knnregl1cv'><p>Leave one out cross validation.</p></a></li>
<li><a href='#lat_lon.2.5'><p>Sample data: Latitude and longitude of AWAP grids</p></a></li>
<li><a href='#modwt.vt'><p>Variance Transformation Operation - MODWT</p></a></li>
<li><a href='#modwt.vt.val'><p>Variance Transformation Operation for Validation</p></a></li>
<li><a href='#mra.plot'><p>Plot function: Plot original time series and decomposed frequency components</p></a></li>
<li><a href='#non.bdy'><p>Replace Boundary Wavelet Coefficients with Missing Values (NA).</p></a></li>
<li><a href='#obs.mon'><p>Sample data: NCEP reanalysis data averaged over Sydney region</p></a></li>
<li><a href='#padding'><p>Padding data to dyadic sample size</p></a></li>
<li><a href='#r2.boot'><p>R2 threshold by re-sampling approach</p></a></li>
<li><a href='#rain.mon'><p>Sample data: Rainfall station data over Sydney region</p></a></li>
<li><a href='#scal2freqM'><p>Scale to frequency by Matlab</p></a></li>
<li><a href='#scal2freqR'><p>Scale to frequency by R</p></a></li>
<li><a href='#SPI.12'><p>Sample data: Standardized Precipitation Index with 12 month accumulation period.</p></a></li>
<li><a href='#stepwise.VT'><p>Calculate stepwise high order VT in calibration</p></a></li>
<li><a href='#stepwise.VT.val'><p>Calculate stepwise high order VT in validation</p></a></li>
<li><a href='#WASP-package'><p>WASP: WAvelet System Prediction</p></a></li>
<li><a href='#wave.var'><p>Produces an estimate of the multiscale variance along with approximate confidence intervals.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Wavelet System Prediction</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Ze Jiang <a href="https://orcid.org/0000-0002-3472-0829"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Md. Mamunur Rashid
    <a href="https://orcid.org/0000-0002-0315-9055"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Ashish Sharma <a href="https://orcid.org/0000-0002-6758-0519"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Fiona Johnson <a href="https://orcid.org/0000-0001-5708-1807"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ze Jiang &lt;ze.jiang@unsw.edu.au&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The wavelet-based variance transformation method is used for system modelling and prediction. It refines predictor spectral representation using Wavelet Theory, which leads to improved model specifications and prediction accuracy. Details of methodologies used in the package can be found in Jiang, Z., Sharma, A., &amp; Johnson, F. (2020) &lt;<a href="https://doi.org/10.1029%2F2019WR026962">doi:10.1029/2019WR026962</a>&gt;, Jiang, Z., Rashid, M. M., Johnson, F., &amp; Sharma, A. (2020) &lt;<a href="https://doi.org/10.1016%2Fj.envsoft.2020.104907">doi:10.1016/j.envsoft.2020.104907</a>&gt;, and Jiang, Z., Sharma, A., &amp; Johnson, F. (2021) &lt;<a href="https://doi.org/10.1016%2FJ.JHYDROL.2021.126816">doi:10.1016/J.JHYDROL.2021.126816</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/zejiang-unsw/WASP#readme">https://github.com/zejiang-unsw/WASP#readme</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/zejiang-unsw/WASP/issues">https://github.com/zejiang-unsw/WASP/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>waveslim, stats, tidyr, ggplot2, sp, rlang (&ge; 1.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>zoo, FNN, readr, knitr, cowplot, gridGraphics, bookdown,
rmarkdown, SPEI, NPRED, synthesis, kableExtra, fitdistrplus,
devtools, testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-22 01:28:59 UTC; Ze</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-22 07:50:24 UTC</td>
</tr>
</table>
<hr>
<h2 id='at.vt'>Variance Transformation Operation - AT(a trous)</h2><span id='topic+at.vt'></span>

<h3>Description</h3>

<p>Variance Transformation Operation - AT(a trous)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>at.vt(
  data,
  wf,
  J,
  boundary,
  cov.opt = "auto",
  flag = "biased",
  detrend = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="at.vt_+3A_data">data</code></td>
<td>
<p>A list of response x and dependent variables dp.</p>
</td></tr>
<tr><td><code id="at.vt_+3A_wf">wf</code></td>
<td>
<p>Name of the wavelet filter to use in the decomposition.</p>
</td></tr>
<tr><td><code id="at.vt_+3A_j">J</code></td>
<td>
<p>Specifies the depth of the decomposition. This must be a number less than or equal to log(length(x),2).</p>
</td></tr>
<tr><td><code id="at.vt_+3A_boundary">boundary</code></td>
<td>
<p>Character string specifying the boundary condition. If boundary==&quot;periodic&quot; the default, then the vector you decompose is assumed to be periodic on its defined interval, if boundary==&quot;reflection&quot;, the vector beyond its boundaries is assumed to be a symmetric reflection of itself.</p>
</td></tr>
<tr><td><code id="at.vt_+3A_cov.opt">cov.opt</code></td>
<td>
<p>Options of Covariance matrix sign. Use &quot;pos&quot;, &quot;neg&quot;, or &quot;auto&quot;.</p>
</td></tr>
<tr><td><code id="at.vt_+3A_flag">flag</code></td>
<td>
<p>Biased or Unbiased variance transformation, c(&quot;biased&quot;,&quot;unbiased&quot;).</p>
</td></tr>
<tr><td><code id="at.vt_+3A_detrend">detrend</code></td>
<td>
<p>Detrend the input time series or just center, default (F)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 8 elements: wf, J, boundary, x (data), dp (data), dp.n (variance transformed dp), and S (covariance matrix).
</p>


<h3>References</h3>

<p>Jiang, Z., Sharma, A., &amp; Johnson, F. (2020). Refining Predictor Spectral Representation Using Wavelet Theory for Improved Natural System Modeling. Water Resources Research, 56(3), e2019WR026962.
</p>
<p>Jiang, Z., Sharma, A., &amp; Johnson, F. (2021). Variable transformations in the spectral domain â€“ Implications for hydrologic forecasting. Journal of Hydrology, 126816.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rain.mon)
data(obs.mon)

## response SPI - calibration
# SPI.cal &lt;- SPI.calc(window(rain.mon, start=c(1949,1), end=c(1979,12)),sc=12)
SPI.cal &lt;- SPEI::spi(window(rain.mon, start = c(1949, 1), end = c(1979, 12)), scale = 12)$fitted

## create paired response and predictors dataset for each station
data.list &lt;- list()
for (id in seq_len(ncol(SPI.cal))) {
  x &lt;- window(SPI.cal[, id], start = c(1950, 1), end = c(1979, 12))
  dp &lt;- window(obs.mon, start = c(1950, 1), end = c(1979, 12))
  data.list[[id]] &lt;- list(x = as.numeric(x), dp = matrix(dp, nrow = nrow(dp)))
}

## variance transformation
dwt.list &lt;- lapply(
  data.list,
  function(x) at.vt(x, wf = "d4", J = 7, boundary = "periodic", cov.opt = "auto")
)

## plot original and reconstrcuted predictors for each station
for (i in seq_len(length(dwt.list))) {
  # extract data
  dwt &lt;- dwt.list[[i]]
  x &lt;- dwt$x # response
  dp &lt;- dwt$dp # original predictors
  dp.n &lt;- dwt$dp.n # variance transformed predictors

  plot.ts(cbind(x, dp))
  plot.ts(cbind(x, dp.n))
}
</code></pre>

<hr>
<h2 id='at.vt.val'>Variance Transformation Operation for Validation</h2><span id='topic+at.vt.val'></span>

<h3>Description</h3>

<p>Variance Transformation Operation for Validation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>at.vt.val(data, J, dwt, detrend = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="at.vt.val_+3A_data">data</code></td>
<td>
<p>A list of response x and dependent variables dp.</p>
</td></tr>
<tr><td><code id="at.vt.val_+3A_j">J</code></td>
<td>
<p>Specifies the depth of the decomposition. This must be a number less than or equal to log(length(x),2).</p>
</td></tr>
<tr><td><code id="at.vt.val_+3A_dwt">dwt</code></td>
<td>
<p>A class of &quot;at&quot; data. Output from at.vt().</p>
</td></tr>
<tr><td><code id="at.vt.val_+3A_detrend">detrend</code></td>
<td>
<p>Detrend the input time series or just center, default (F)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 8 elements: wf, J, boundary, x (data), dp (data), dp.n (variance transformed dp), and S (covariance matrix).
</p>


<h3>References</h3>

<p>Jiang, Z., Sharma, A., &amp; Johnson, F. (2020). Refining Predictor Spectral Representation Using Wavelet Theory for Improved Natural System Modeling. Water Resources Research, 56(3), e2019WR026962. doi:10.1029/2019wr026962
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rain.mon)
data(obs.mon)

## response SPI - calibration
# SPI.cal &lt;- SPI.calc(window(rain.mon, start=c(1949,1), end=c(1979,12)),sc=12)
SPI.cal &lt;- SPEI::spi(window(rain.mon, start = c(1949, 1), end = c(1979, 12)), scale = 12)$fitted

## create paired response and predictors dataset for each station
data.list &lt;- list()
for (id in seq_len(ncol(SPI.cal))) {
  x &lt;- window(SPI.cal[, id], start = c(1950, 1), end = c(1979, 12))
  dp &lt;- window(obs.mon, start = c(1950, 1), end = c(1979, 12))
  data.list[[id]] &lt;- list(x = as.numeric(x), dp = matrix(dp, nrow = nrow(dp)))
}

## variance transformation - calibration
dwt.list &lt;- lapply(
  data.list,
  function(x) at.vt(x, wf = "d4", J = 7, boundary = "periodic", cov.opt = "auto")
)

## response SPI - validation
# SPI.val &lt;- SPI.calc(window(rain.mon, start=c(1979,1), end=c(2009,12)),sc=12)
SPI.val &lt;- SPEI::spi(window(rain.mon, start = c(1979, 1), end = c(2009, 12)), scale = 12)$fitted

## create paired response and predictors dataset for each station
data.list &lt;- list()
for (id in seq_len(ncol(SPI.val))) {
  x &lt;- window(SPI.val[, id], start = c(1980, 1), end = c(2009, 12))
  dp &lt;- window(obs.mon, start = c(1980, 1), end = c(2009, 12))
  data.list[[id]] &lt;- list(x = as.numeric(x), dp = matrix(dp, nrow = nrow(dp)))
}

# variance transformation - validation
dwt.list.val &lt;- lapply(
  seq_len(length(data.list)),
  function(i) at.vt.val(data.list[[i]], J = 7, dwt.list[[i]])
)

## plot original and reconstrcuted predictors for each station
for (i in seq_len(length(dwt.list.val))) {
  # extract data
  dwt &lt;- dwt.list.val[[i]]
  x &lt;- dwt$x # response
  dp &lt;- dwt$dp # original predictors
  dp.n &lt;- dwt$dp.n # variance transformed predictors

  plot.ts(cbind(x, dp))
  plot.ts(cbind(x, dp.n))
}
</code></pre>

<hr>
<h2 id='at.wd'>a trous (AT) based additive decompostion using Daubechies family wavelet</h2><span id='topic+at.wd'></span>

<h3>Description</h3>

<p>a trous (AT) based additive decompostion using Daubechies family wavelet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>at.wd(x, wf, J, boundary = "periodic")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="at.wd_+3A_x">x</code></td>
<td>
<p>The input time series.</p>
</td></tr>
<tr><td><code id="at.wd_+3A_wf">wf</code></td>
<td>
<p>Name of the wavelet filter to use in the decomposition.</p>
</td></tr>
<tr><td><code id="at.wd_+3A_j">J</code></td>
<td>
<p>Specifies the depth of the decomposition. This must be a number less than or equal to log(length(x),2).</p>
</td></tr>
<tr><td><code id="at.wd_+3A_boundary">boundary</code></td>
<td>
<p>Character string specifying the boundary condition. If boundary==&quot;periodic&quot; the default, then the vector you decompose is assumed to be periodic on its defined interval, if boundary==&quot;reflection&quot;, the vector beyond its boundaries is assumed to be a symmetric reflection of itself.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of decomposed sub-time series.
</p>


<h3>References</h3>

<p>Nason, G. P. (1996). Wavelet shrinkage using cross-validation. Journal of the Royal Statistical Society: Series B (Methodological), 58(2), 463-479.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(obs.mon)

n &lt;- nrow(obs.mon)
v &lt;- 1
J &lt;- floor(log(n / (2 * v - 1)) / log(2)) # (Kaiser, 1994)

names &lt;- colnames(obs.mon)
at.atm &lt;- vector("list", ncol(obs.mon))
for (i in seq_len(ncol(obs.mon))) {
  tmp &lt;- as.numeric(scale(obs.mon[, i], scale = FALSE))
  at.atm &lt;- do.call(cbind, at.wd(tmp, wf = "haar", J = J, boundary = "periodic"))

  plot.ts(cbind(obs.mon[1:n, i], at.atm[1:n, 1:9]), main = names[i])
  print(sum(abs(scale(obs.mon[1:n, i], scale = FALSE) - rowSums(at.atm[1:n, ]))))
}
</code></pre>

<hr>
<h2 id='aus.coast'>Sample data: Australia map</h2><span id='topic+aus.coast'></span>

<h3>Description</h3>

<p>A dataset containing the Australia map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(aus.coast)
</code></pre>

<hr>
<h2 id='data.AWAP.2.5'>Sample data: AWAP rainfall data over Australia</h2><span id='topic+data.AWAP.2.5'></span>

<h3>Description</h3>

<p>A dataset containing 1320 rows (data length) and 252 columns (grids).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data.AWAP.2.5)
</code></pre>

<hr>
<h2 id='data.CI'>Sample data: Climate indices strongly influencing Australia climate</h2><span id='topic+data.CI'></span>

<h3>Description</h3>

<p>A dataset containing 1332 rows (data length) and 6 columns (indices).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data.CI)
</code></pre>

<hr>
<h2 id='data.gen.ar1'>Generate predictor and response data from AR1 model.</h2><span id='topic+data.gen.ar1'></span>

<h3>Description</h3>

<p>Generate predictor and response data from AR1 model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.ar1(nobs, ndim = 9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.gen.ar1_+3A_nobs">nobs</code></td>
<td>
<p>The data length to be generated.</p>
</td></tr>
<tr><td><code id="data.gen.ar1_+3A_ndim">ndim</code></td>
<td>
<p>The number of potential predictors (default is 9).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 2 elements: a vector of response (x), and a matrix of potential predictors (dp) with each column containing one potential predictor.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># AR1 model from paper with 9 dummy variables
data.ar1 &lt;- data.gen.ar1(500)
plot.ts(cbind(data.ar1$x, data.ar1$dp))
</code></pre>

<hr>
<h2 id='data.gen.ar4'>Generate predictor and response data from AR4 model.</h2><span id='topic+data.gen.ar4'></span>

<h3>Description</h3>

<p>Generate predictor and response data from AR4 model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.ar4(nobs, ndim = 9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.gen.ar4_+3A_nobs">nobs</code></td>
<td>
<p>The data length to be generated.</p>
</td></tr>
<tr><td><code id="data.gen.ar4_+3A_ndim">ndim</code></td>
<td>
<p>The number of potential predictors (default is 9).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 2 elements: a vector of response (x), and a matrix of potential predictors (dp) with each column containing one potential predictor.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># AR4 model from paper with total 9 dimensions
data.ar4 &lt;- data.gen.ar4(500)
plot.ts(cbind(data.ar4$x, data.ar4$dp))
</code></pre>

<hr>
<h2 id='data.gen.ar9'>Generate predictor and response data from AR9 model.</h2><span id='topic+data.gen.ar9'></span>

<h3>Description</h3>

<p>Generate predictor and response data from AR9 model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.ar9(nobs, ndim = 9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.gen.ar9_+3A_nobs">nobs</code></td>
<td>
<p>The data length to be generated.</p>
</td></tr>
<tr><td><code id="data.gen.ar9_+3A_ndim">ndim</code></td>
<td>
<p>The number of potential predictors (default is 9).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 2 elements: a vector of response (x), and a matrix of potential predictors (dp) with each column containing one potential predictor.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># AR9 model from paper with total 9 dimensions
data.ar9 &lt;- data.gen.ar9(500)
plot.ts(cbind(data.ar9$x, data.ar9$dp))
</code></pre>

<hr>
<h2 id='data.gen.HL'>Generate predictor and response data: Hysteresis Loop</h2><span id='topic+data.gen.HL'></span>

<h3>Description</h3>

<p>Generate predictor and response data: Hysteresis Loop
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.HL(n = 3, m = 5, nobs = 512, fp = 25, fd, sd.x = 0.1, sd.y = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.gen.HL_+3A_n">n</code></td>
<td>
<p>Positive integer for the split line parameter. If n=1, split line is linear; If n is even, split line has a u shape; If n is odd and higher than 1, split line has a chair or classical shape.</p>
</td></tr>
<tr><td><code id="data.gen.HL_+3A_m">m</code></td>
<td>
<p>Positive odd integer for the bulging parameter, indicates degree of outward curving (1=highest level of bulging).</p>
</td></tr>
<tr><td><code id="data.gen.HL_+3A_nobs">nobs</code></td>
<td>
<p>The data length to be generated.</p>
</td></tr>
<tr><td><code id="data.gen.HL_+3A_fp">fp</code></td>
<td>
<p>The frequency in the generated response.fp = 25 used in the WRR paper.</p>
</td></tr>
<tr><td><code id="data.gen.HL_+3A_fd">fd</code></td>
<td>
<p>A vector of frequencies for potential predictors. fd = c(3,5,10,15,25,30,55,70,95) used in the WRR paper.</p>
</td></tr>
<tr><td><code id="data.gen.HL_+3A_sd.x">sd.x</code></td>
<td>
<p>The noise level in the predictor.</p>
</td></tr>
<tr><td><code id="data.gen.HL_+3A_sd.y">sd.y</code></td>
<td>
<p>The noise level in the response.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Hysteresis is a common nonlinear phenomenon in natural systems and it can be numerical simulated by the following formulas:
</p>
<p style="text-align: center;"><code class="reqn">x_{t} = a*cos(2pi*f*t)</code>
</p>

<p style="text-align: center;"><code class="reqn">y_{t} = b*cos(2pi*f*t)^n + c*sin(2pi*f*t)^m</code>
</p>

<p>The default selection for the system parameters (<em>a</em> = 0.8, <em>b</em> = 0.6, <em>c</em> = -0.2, <em>n</em> = 3, <em>m</em> = 5) is known to generate a classical hysteresis loop.
</p>


<h3>Value</h3>

<p>A list of 3 elements: a vector of response (x), a matrix of potential predictors (dp) with each column containing one potential predictor, and a vector of true predictor numbers.
</p>


<h3>References</h3>

<p>LAPSHIN, R. V. 1995. Analytical model for the approximation of hysteresis loop and its application to the scanning tunneling microscope. Review of Scientific Instruments, 66, 4718-4730.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###synthetic example - Hysteresis loop
#frequency, sampled from a given range
fd &lt;- c(3,5,10,15,25,30,55,70,95)

data.HL &lt;- data.gen.HL(n=3,m=5,nobs=512,fp=25,fd=fd)
plot.ts(cbind(data.HL$x,data.HL$dp))
</code></pre>

<hr>
<h2 id='data.gen.Rossler'>Generate predictor and response data: Rossler system</h2><span id='topic+data.gen.Rossler'></span>

<h3>Description</h3>

<p>Generates a 3-dimensional time series using the Rossler equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.Rossler(
  a = 0.2,
  b = 0.2,
  w = 5.7,
  start = c(-2, -10, 0.2),
  time = seq(0, 50, length.out = 5000)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.gen.Rossler_+3A_a">a</code></td>
<td>
<p>The <em>a</em> parameter. Default:0.2.</p>
</td></tr>
<tr><td><code id="data.gen.Rossler_+3A_b">b</code></td>
<td>
<p>The <em>b</em> parameter. Default: 0.2.</p>
</td></tr>
<tr><td><code id="data.gen.Rossler_+3A_w">w</code></td>
<td>
<p>The <em>w</em> parameter. Default: 5.7.</p>
</td></tr>
<tr><td><code id="data.gen.Rossler_+3A_start">start</code></td>
<td>
<p>A 3-dimensional numeric vector indicating the starting point for the time series. Default: c(-2, -10, 0.2).</p>
</td></tr>
<tr><td><code id="data.gen.Rossler_+3A_time">time</code></td>
<td>
<p>The temporal interval at which the system will be generated.
Default: time=seq(0,50,length.out = 5000).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Rossler system is a system of ordinary differential equations defined as:
</p>
<p style="text-align: center;"><code class="reqn">\dot{x} = -(y + z)</code>
</p>

<p style="text-align: center;"><code class="reqn">\dot{y} = x+a \cdot y</code>
</p>

<p style="text-align: center;"><code class="reqn">\dot{z} = b + z*(x-w)</code>
</p>

<p>The default selection for the system parameters (<em>a</em> = 0.2, <em>b</em> = 0.2, <em>w</em> = 5.7) is known to
produce a deterministic chaotic time series.
</p>


<h3>Value</h3>

<p>A list with four vectors named <em>time</em>, <em>x</em>, <em>y</em>
and <em>z</em> containing the time, the x-components, the
y-components and the z-components of the Rossler system, respectively.
</p>


<h3>Note</h3>

<p>Some initial values may lead to an unstable system that will tend to infinity.
</p>


<h3>References</h3>

<p>RÃ–SSLER, O. E. 1976. An equation for continuous chaos. Physics Letters A, 57, 397-398.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### synthetic example - Rossler
ts.r &lt;- data.gen.Rossler(
  a = 0.2, b = 0.2, w = 5.7, start = c(-2, -10, 0.2),
  time = seq(0, 50, length.out = 1000)
)

# add noise
ts.r$x &lt;- ts(ts.r$x + rnorm(length(ts.r$time), mean = 0, sd = 1))
ts.r$y &lt;- ts(ts.r$y + rnorm(length(ts.r$time), mean = 0, sd = 1))
ts.r$z &lt;- ts(ts.r$z + rnorm(length(ts.r$time), mean = 0, sd = 1))

ts.plot(ts.r$x, ts.r$y, ts.r$z, col = c("black", "red", "blue"))
</code></pre>

<hr>
<h2 id='data.gen.SW'>Generate predictor and response data: Sinewave model</h2><span id='topic+data.gen.SW'></span>

<h3>Description</h3>

<p>Generate predictor and response data: Sinewave model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.SW(nobs = 512, fp = 25, fd, sd.x = 0.1, sd.y = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.gen.SW_+3A_nobs">nobs</code></td>
<td>
<p>The data length to be generated.</p>
</td></tr>
<tr><td><code id="data.gen.SW_+3A_fp">fp</code></td>
<td>
<p>The frequencies in the generated response.</p>
</td></tr>
<tr><td><code id="data.gen.SW_+3A_fd">fd</code></td>
<td>
<p>A vector of frequencies for potential predictors. fd = c(3,5,10,15,25,30,55,70,95) used in the WRR paper.</p>
</td></tr>
<tr><td><code id="data.gen.SW_+3A_sd.x">sd.x</code></td>
<td>
<p>The noise level in the predictor.</p>
</td></tr>
<tr><td><code id="data.gen.SW_+3A_sd.y">sd.y</code></td>
<td>
<p>The noise level in the response.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 3 elements: a vector of response (x), a matrix of potential predictors (dp) with each column containing one potential predictor, and a vector of true predictor numbers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###synthetic example
#frequency, sampled from a given range
fd &lt;- c(3,5,10,15,25,30,55,70,95)

data.SW1 &lt;- data.gen.SW(nobs=512,fp=25,fd=fd)
data.SW3 &lt;- data.gen.SW(nobs=512,fp=c(15,25,30),fd=fd)

ts.plot(ts(data.SW1$x),ts(data.SW3$x),col=c("black","red"))
plot.ts(cbind(data.SW1$x,data.SW1$dp))
plot.ts(cbind(data.SW3$x,data.SW3$dp))
</code></pre>

<hr>
<h2 id='data.gen.tar1'>Generate predictor and response data from TAR1 model.</h2><span id='topic+data.gen.tar1'></span>

<h3>Description</h3>

<p>Generate predictor and response data from TAR1 model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.tar1(nobs, ndim = 9, noise = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.gen.tar1_+3A_nobs">nobs</code></td>
<td>
<p>The data length to be generated.</p>
</td></tr>
<tr><td><code id="data.gen.tar1_+3A_ndim">ndim</code></td>
<td>
<p>The number of potential predictors (default is 9).</p>
</td></tr>
<tr><td><code id="data.gen.tar1_+3A_noise">noise</code></td>
<td>
<p>The white noise in the data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 2 elements: a vector of response (x), and a matrix of potential predictors (dp) with each column containing one potential predictor.
</p>


<h3>References</h3>

<p>Sharma, A. (2000). Seasonal to interannual rainfall probabilistic forecasts for improved water supply management: Part 1â€”A strategy for system predictor identification. Journal of Hydrology, 239(1-4), 232-239.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># TAR1 model from paper with total 9 dimensions
data.tar1 &lt;- data.gen.tar1(500)
plot.ts(cbind(data.tar1$x, data.tar1$dp))
</code></pre>

<hr>
<h2 id='data.gen.tar2'>Generate predictor and response data from TAR2 model.</h2><span id='topic+data.gen.tar2'></span>

<h3>Description</h3>

<p>Generate predictor and response data from TAR2 model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen.tar2(nobs, ndim = 9, noise = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.gen.tar2_+3A_nobs">nobs</code></td>
<td>
<p>The data length to be generated.</p>
</td></tr>
<tr><td><code id="data.gen.tar2_+3A_ndim">ndim</code></td>
<td>
<p>The number of potential predictors (default is 9).</p>
</td></tr>
<tr><td><code id="data.gen.tar2_+3A_noise">noise</code></td>
<td>
<p>The white noise in the data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 2 elements: a vector of response (x), and a matrix of potential predictors (dp) with each column containing one potential predictor.
</p>


<h3>References</h3>

<p>Sharma, A. (2000). Seasonal to interannual rainfall probabilistic forecasts for improved water supply management: Part 1â€”A strategy for system predictor identification. Journal of Hydrology, 239(1-4), 232-239.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># TAR2 model from paper with total 9 dimensions
data.tar2 &lt;- data.gen.tar2(500)
plot.ts(cbind(data.tar2$x, data.tar2$dp))
</code></pre>

<hr>
<h2 id='data.HL'>Sample data: Hysteresis loop</h2><span id='topic+data.HL'></span>

<h3>Description</h3>

<p>A dataset containing 3 lists: a vector of response (x), a matrix of 9 potential predictors (dp) with each column containing one potential predictor, and a vector of true predictor numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data.HL)
</code></pre>

<hr>
<h2 id='data.SW1'>Sample data: Sinewave model 1 (SW1)</h2><span id='topic+data.SW1'></span>

<h3>Description</h3>

<p>A dataset containing 3 lists: a vector of response (x), a matrix of 9 potential predictors (dp) with each column containing one potential predictor, and a vector of true predictor numbers.
The Sinewave model 1 (SW1) is defined as:
</p>
<p style="text-align: center;"><code class="reqn">x_{t}= sin(2pi*f*t)+eps</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>data(data.SW1)
</code></pre>

<hr>
<h2 id='data.SW3'>Sample data: Sinewave model 3 (SW3)</h2><span id='topic+data.SW3'></span>

<h3>Description</h3>

<p>A dataset containing 3 lists: a vector of response (x), a matrix of 9 potential predictors (dp) with each column containing one potential predictor, and a vector of true predictor numbers.
The Sinewave model 3 (SW3) is defined as:
</p>
<p style="text-align: center;"><code class="reqn">x_{t}= \sum_{i=1}^3 sin(2pi*f_{i}*t)+eps</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>data(data.SW3)
</code></pre>

<hr>
<h2 id='dwt.vt'>Variance Transformation Operation - MRA</h2><span id='topic+dwt.vt'></span>

<h3>Description</h3>

<p>Variance Transformation Operation - MRA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dwt.vt(
  data,
  wf,
  J,
  method,
  pad,
  boundary,
  cov.opt = "auto",
  flag = "biased",
  detrend = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dwt.vt_+3A_data">data</code></td>
<td>
<p>A list of response x and dependent variables dp.</p>
</td></tr>
<tr><td><code id="dwt.vt_+3A_wf">wf</code></td>
<td>
<p>Name of the wavelet filter to use in the decomposition.</p>
</td></tr>
<tr><td><code id="dwt.vt_+3A_j">J</code></td>
<td>
<p>Specifies the depth of the decomposition. This must be a number less than or equal to log(length(x),2).</p>
</td></tr>
<tr><td><code id="dwt.vt_+3A_method">method</code></td>
<td>
<p>Either &quot;dwt&quot; or &quot;modwt&quot;.</p>
</td></tr>
<tr><td><code id="dwt.vt_+3A_pad">pad</code></td>
<td>
<p>The method used for extend data to dyadic size. Use &quot;per&quot;, &quot;zero&quot;, or &quot;sym&quot;.</p>
</td></tr>
<tr><td><code id="dwt.vt_+3A_boundary">boundary</code></td>
<td>
<p>Character string specifying the boundary condition. If boundary==&quot;periodic&quot; the default, then the vector you decompose is assumed to be periodic on its defined interval, if boundary==&quot;reflection&quot;, the vector beyond its boundaries is assumed to be a symmetric reflection of itself.</p>
</td></tr>
<tr><td><code id="dwt.vt_+3A_cov.opt">cov.opt</code></td>
<td>
<p>Options of Covariance matrix sign. Use &quot;pos&quot;, &quot;neg&quot;, or &quot;auto&quot;.</p>
</td></tr>
<tr><td><code id="dwt.vt_+3A_flag">flag</code></td>
<td>
<p>Biased or Unbiased variance transformation, c(&quot;biased&quot;,&quot;unbiased&quot;).</p>
</td></tr>
<tr><td><code id="dwt.vt_+3A_detrend">detrend</code></td>
<td>
<p>Detrend the input time series or just center, default (F)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 8 elements: wf, method, boundary, pad, x (data), dp (data), dp.n (variance trasnformed dp), and S (covariance matrix).
</p>


<h3>References</h3>

<p>Jiang, Z., Sharma, A., &amp; Johnson, F. (2020). Refining Predictor Spectral Representation Using Wavelet Theory for Improved Natural System Modeling. Water Resources Research, 56(3), e2019WR026962.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rain.mon)
data(obs.mon)

## response SPI - calibration
# SPI.cal &lt;- SPI.calc(window(rain.mon, start=c(1949,1), end=c(1979,12)),sc=12)
SPI.cal &lt;- SPEI::spi(window(rain.mon, start = c(1949, 1), end = c(1979, 12)), scale = 12)$fitted

## create paired response and predictors dataset for each station
data.list &lt;- list()
for (id in seq_len(ncol(SPI.cal))) {
  x &lt;- window(SPI.cal[, id], start = c(1950, 1), end = c(1979, 12))
  dp &lt;- window(obs.mon, start = c(1950, 1), end = c(1979, 12))
  data.list[[id]] &lt;- list(x = as.numeric(x), dp = matrix(dp, nrow = nrow(dp)))
}

## variance transformation
dwt.list &lt;- lapply(data.list, function(x) {
  dwt.vt(x, wf = "d4", J = 7, method = "dwt", pad = "zero", boundary = "periodic", cov.opt = "auto")
})

## plot original and reconstrcuted predictors for each station
for (i in seq_len(length(dwt.list))) {
  # extract data
  dwt &lt;- dwt.list[[i]]
  x &lt;- dwt$x # response
  dp &lt;- dwt$dp # original predictors
  dp.n &lt;- dwt$dp.n # variance transformed predictors

  plot.ts(cbind(x, dp))
  plot.ts(cbind(x, dp.n))
}
</code></pre>

<hr>
<h2 id='dwt.vt.val'>Variance Transformation Operation for Validation</h2><span id='topic+dwt.vt.val'></span>

<h3>Description</h3>

<p>Variance Transformation Operation for Validation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dwt.vt.val(data, J, dwt, detrend = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dwt.vt.val_+3A_data">data</code></td>
<td>
<p>A list of response x and dependent variables dp.</p>
</td></tr>
<tr><td><code id="dwt.vt.val_+3A_j">J</code></td>
<td>
<p>Specifies the depth of the decomposition. This must be a number less than or equal to log(length(x),2).</p>
</td></tr>
<tr><td><code id="dwt.vt.val_+3A_dwt">dwt</code></td>
<td>
<p>A class of &quot;dwt&quot; data. Output from dwt.vt().</p>
</td></tr>
<tr><td><code id="dwt.vt.val_+3A_detrend">detrend</code></td>
<td>
<p>Detrend the input time series or just center, default (F)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 8 elements: wf, method, boundary, pad, x (data), dp (data), dp.n (variance trasnformed dp), and S (covariance matrix).
</p>


<h3>References</h3>

<p>Jiang, Z., Sharma, A., &amp; Johnson, F. (2020). Refining Predictor Spectral Representation Using Wavelet Theory for Improved Natural System Modeling. Water Resources Research, 56(3), e2019WR026962. doi:10.1029/2019wr026962
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rain.mon)
data(obs.mon)

## response SPI - calibration
# SPI.cal &lt;- SPI.calc(window(rain.mon, start=c(1949,1), end=c(1979,12)),sc=12)
SPI.cal &lt;- SPEI::spi(window(rain.mon, start = c(1949, 1), end = c(1979, 12)), scale = 12)$fitted

## create paired response and predictors dataset for each station
data.list &lt;- list()
for (id in seq_len(ncol(SPI.cal))) {
  x &lt;- window(SPI.cal[, id], start = c(1950, 1), end = c(1979, 12))
  dp &lt;- window(obs.mon, start = c(1950, 1), end = c(1979, 12))
  data.list[[id]] &lt;- list(x = as.numeric(x), dp = matrix(dp, nrow = nrow(dp)))
}

## variance transformation - calibration
dwt.list &lt;- lapply(data.list, function(x) {
  dwt.vt(x, wf = "d4", J = 7, method = "dwt", pad = "zero", boundary = "periodic", cov.opt = "auto")
})

## response SPI - validation
# SPI.val &lt;- SPI.calc(window(rain.mon, start=c(1979,1), end=c(2009,12)),sc=12)
SPI.val &lt;- SPEI::spi(window(rain.mon, start = c(1979, 1), end = c(2009, 12)), scale = 12)$fitted

## create paired response and predictors dataset for each station
data.list &lt;- list()
for (id in seq_len(ncol(SPI.val))) {
  x &lt;- window(SPI.val[, id], start = c(1980, 1), end = c(2009, 12))
  dp &lt;- window(obs.mon, start = c(1980, 1), end = c(2009, 12))
  data.list[[id]] &lt;- list(x = as.numeric(x), dp = matrix(dp, nrow = nrow(dp)))
}

# variance transformation - validation
dwt.list.val &lt;- lapply(
  seq_len(length(data.list)),
  function(i) dwt.vt.val(data.list[[i]], J = 7, dwt.list[[i]])
)

## plot original and reconstrcuted predictors for each station
for (i in seq_len(length(dwt.list.val))) {
  # extract data
  dwt &lt;- dwt.list.val[[i]]
  x &lt;- dwt$x # response
  dp &lt;- dwt$dp # original predictors
  dp.n &lt;- dwt$dp.n # variance transformed predictors

  plot.ts(cbind(x, dp))
  plot.ts(cbind(x, dp.n))
}
</code></pre>

<hr>
<h2 id='fig.dwt.vt'>Plot function: Variance structure before and after variance transformation</h2><span id='topic+fig.dwt.vt'></span>

<h3>Description</h3>

<p>Plot function: Variance structure before and after variance transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fig.dwt.vt(dwt.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fig.dwt.vt_+3A_dwt.data">dwt.data</code></td>
<td>
<p>Output data from variance transformation function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot with variance structure before and after variance transformation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("data.HL")
data("data.SW1")

# variance transfrom
dwt.SW1 &lt;- dwt.vt(data.SW1[[1]],
  wf = "d4", J = 7, method = "dwt",
  pad = "zero", boundary = "periodic", cov.opt = "auto"
)

# plot
fig1 &lt;- fig.dwt.vt(dwt.SW1)
fig1

# variance transfrom
dwt.HL &lt;- dwt.vt(data.HL[[1]],
  wf = "d4", J = 7, method = "dwt",
  pad = "zero", boundary = "periodic", cov.opt = "auto"
)

# plot
fig2 &lt;- fig.dwt.vt(dwt.HL)
fig2
</code></pre>

<hr>
<h2 id='Ind_AWAP.2.5'>Sample data: Index of AWAP grids with no missing data</h2><span id='topic+Ind_AWAP.2.5'></span>

<h3>Description</h3>

<p>A dataset containing 145 numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Ind_AWAP.2.5)
</code></pre>

<hr>
<h2 id='knn'>Modified k-nearest neighbour conditional bootstrap or regression function estimation with extrapolation</h2><span id='topic+knn'></span>

<h3>Description</h3>

<p>Modified k-nearest neighbour conditional bootstrap or regression function estimation with extrapolation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knn(
  x,
  z,
  zout,
  k = 0,
  pw,
  reg = TRUE,
  nensemble = 100,
  tailcorrection = TRUE,
  tailprob = 0.25,
  tailfac = 0.2,
  extrap = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knn_+3A_x">x</code></td>
<td>
<p>A vector of response.</p>
</td></tr>
<tr><td><code id="knn_+3A_z">z</code></td>
<td>
<p>A matrix of existing predictors.</p>
</td></tr>
<tr><td><code id="knn_+3A_zout">zout</code></td>
<td>
<p>A matrix of predictor values the response is to be estimated at.</p>
</td></tr>
<tr><td><code id="knn_+3A_k">k</code></td>
<td>
<p>The number of nearest neighbours used. The default value is 0, indicating Lall and Sharma default is used.</p>
</td></tr>
<tr><td><code id="knn_+3A_pw">pw</code></td>
<td>
<p>A vector of partial weights of the same length of z.</p>
</td></tr>
<tr><td><code id="knn_+3A_reg">reg</code></td>
<td>
<p>A logical operator to inform whether a conditional expectation should be output or not nensemble, Used if reg=F and represents the number of realisations that are generated Value.</p>
</td></tr>
<tr><td><code id="knn_+3A_nensemble">nensemble</code></td>
<td>
<p>An integer the specifies the number of ensembles used. The default is 100.</p>
</td></tr>
<tr><td><code id="knn_+3A_tailcorrection">tailcorrection</code></td>
<td>
<p>A logical value, T (default) or F, that denotes whether a reduced value of k (number of nearest neighbours) should be used in the tails of any conditioning plane. Whether one is in the tails or not is determined based on the nearest neighbour response value.</p>
</td></tr>
<tr><td><code id="knn_+3A_tailprob">tailprob</code></td>
<td>
<p>A scalar that denotes the p-value of the cdf (on either extreme) the tailcorrection takes effect. The default value is 0.25.</p>
</td></tr>
<tr><td><code id="knn_+3A_tailfac">tailfac</code></td>
<td>
<p>A scalar that specifies the lowest fraction of the default k that can be used in the tails. Depending on the how extreme one is in the tails, the actual k decreases linearly from k (for a p-value greater than tailprob) to tailfac*k proportional to the actual p-value of the nearest neighbour response, divided by tailprob. The default value is 0.2.</p>
</td></tr>
<tr><td><code id="knn_+3A_extrap">extrap</code></td>
<td>
<p>A logical value, T (default) or F, that denotes whether a kernel extraplation method is used to predict x.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of responses having same rows as zout if reg=T, or having nensemble columns is reg=F.
</p>


<h3>References</h3>

<p>Sharma, A., Tarboton, D.G. and Lall, U., 1997. Streamflow simulation: A nonparametric approach. Water resources research, 33(2), pp.291-308.
</p>
<p>Sharma, A. and O'Neill, R., 2002. A nonparametric approach for representing interannual dependence in monthly streamflow sequences. Water resources research, 38(7), pp.5-1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# AR9 model   x(i)=0.3*x(i-1)-0.6*x(i-4)-0.5*x(i-9)+eps
data.ar9 &lt;- data.gen.ar9(500)
x &lt;- data.ar9$x # response
py &lt;- data.ar9$dp # possible predictors

# identify the meaningful predictors and estimate partial weights
ans.ar9 &lt;- NPRED::stepwise.PIC(x, py)
z &lt;- py[, ans.ar9$cpy] # predictor matrix
pw &lt;- ans.ar9$wt # partial weights

# vector denoting where we want outputs, can be a matrix representing grid.
zout &lt;- apply(z, 2, mean)

knn(x, z, zout, reg = TRUE, pw = pw) # knn regression estimate using partial weights.

knn(x, z, zout, reg = FALSE, pw = pw) # alternatively, knn conditional bootstrap (100 realisations).
# Mean of the conditional bootstrap estimate should be
# approximately the same as the regression estimate.

zout &lt;- ts(data.gen.ar9(500, ndim = length(ans.ar9$cpy))$dp) # new input
xhat1 &lt;- xhat2 &lt;- x
xhat1 &lt;- knn(x, z, zout, k = 5, reg = TRUE, extrap = FALSE) # without extrapolation
xhat2 &lt;- knn(x, z, zout, k = 5, reg = TRUE, extrap = TRUE) # with extrapolation

ts.plot(ts(x), ts(xhat1), ts(xhat2), col = c("black", "red", "blue"),
ylim = c(-5, 5), lwd = c(2, 2, 1))

</code></pre>

<hr>
<h2 id='knnregl1cv'>Leave one out cross validation.</h2><span id='topic+knnregl1cv'></span>

<h3>Description</h3>

<p>Leave one out cross validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knnregl1cv(x, z, k = 0, pw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knnregl1cv_+3A_x">x</code></td>
<td>
<p>A vector of response.</p>
</td></tr>
<tr><td><code id="knnregl1cv_+3A_z">z</code></td>
<td>
<p>A matrix of predictors.</p>
</td></tr>
<tr><td><code id="knnregl1cv_+3A_k">k</code></td>
<td>
<p>The number of nearest neighbours used. The default is 0, indicating Lall and Sharma default is used.</p>
</td></tr>
<tr><td><code id="knnregl1cv_+3A_pw">pw</code></td>
<td>
<p>A vector of partial weights of the same length of z.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of L1CV estimates of the response.
</p>


<h3>References</h3>

<p>Lall, U., Sharma, A., 1996. A Nearest Neighbor Bootstrap For Resampling Hydrologic Time Series. Water Resources Research, 32(3): 679-693.
</p>
<p>Sharma, A., Mehrotra, R., 2014. An information theoretic alternative to model a natural system using observational information alone. Water Resources Research, 50(1): 650-660.
</p>

<hr>
<h2 id='lat_lon.2.5'>Sample data: Latitude and longitude of AWAP grids</h2><span id='topic+lat_lon.2.5'></span>

<h3>Description</h3>

<p>A dataset containing 252 rows (grids) and 2 columns (lat and lon).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lat_lon.2.5)
</code></pre>

<hr>
<h2 id='modwt.vt'>Variance Transformation Operation - MODWT</h2><span id='topic+modwt.vt'></span>

<h3>Description</h3>

<p>Variance Transformation Operation - MODWT
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modwt.vt(
  data,
  wf,
  J,
  boundary,
  cov.opt = "auto",
  flag = "biased",
  detrend = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modwt.vt_+3A_data">data</code></td>
<td>
<p>A list of response x and dependent variables dp.</p>
</td></tr>
<tr><td><code id="modwt.vt_+3A_wf">wf</code></td>
<td>
<p>Name of the wavelet filter to use in the decomposition.</p>
</td></tr>
<tr><td><code id="modwt.vt_+3A_j">J</code></td>
<td>
<p>Specifies the depth of the decomposition. This must be a number less than or equal to log(length(x),2).</p>
</td></tr>
<tr><td><code id="modwt.vt_+3A_boundary">boundary</code></td>
<td>
<p>Character string specifying the boundary condition. If boundary==&quot;periodic&quot; the default, then the vector you decompose is assumed to be periodic on its defined interval, if boundary==&quot;reflection&quot;, the vector beyond its boundaries is assumed to be a symmetric reflection of itself.</p>
</td></tr>
<tr><td><code id="modwt.vt_+3A_cov.opt">cov.opt</code></td>
<td>
<p>Options of Covariance matrix sign. Use &quot;pos&quot;, &quot;neg&quot;, or &quot;auto&quot;.</p>
</td></tr>
<tr><td><code id="modwt.vt_+3A_flag">flag</code></td>
<td>
<p>Biased or Unbiased variance transformation, c(&quot;biased&quot;,&quot;unbiased&quot;).</p>
</td></tr>
<tr><td><code id="modwt.vt_+3A_detrend">detrend</code></td>
<td>
<p>Detrend the input time series or just center, default (F)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 8 elements: wf, J, boundary, x (data), dp (data), dp.n (variance transformed dp), and S (covariance matrix).
</p>


<h3>References</h3>

<p>Jiang, Z., Sharma, A., &amp; Johnson, F. (2020). Refining Predictor Spectral Representation Using Wavelet Theory for Improved Natural System Modeling. Water Resources Research, 56(3), e2019WR026962.
</p>
<p>Jiang, Z., Rashid, M. M., Johnson, F., &amp; Sharma, A. (2020). A wavelet-based tool to modulate variance in predictors: an application to predicting drought anomalies. Environmental Modelling &amp; Software, 135, 104907.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### real-world example
data(Ind_AWAP.2.5)
data(obs.mon)
data(SPI.12)
x &lt;- window(SPI.12, start = c(1950, 1), end = c(2009, 12))
dp &lt;- window(obs.mon, start = c(1950, 1), end = c(2009, 12))

op &lt;- par(mfrow = c(ncol(dp), 1), pty = "m", mar = c(1, 4, 1, 2))
for (id in sample(Ind_AWAP.2.5, 1)) {
  data &lt;- list(x = x[, id], dp = dp)
  dwt &lt;- modwt.vt(data, wf = "d4", J = 7, boundary = "periodic", cov.opt = "auto")

  for (i in 1:ncol(dp)) {
    ts.plot(dwt$dp[, i], dwt$dp.n[, i], xlab = NA, col = c("black", "red"), lwd = c(2, 1))
  }
}
par(op)

### synthetic example
# frequency, sampled from a given range
fd &lt;- c(3, 5, 10, 15, 25, 30, 55, 70, 95)

data.SW1 &lt;- data.gen.SW(nobs = 512, fp = 25, fd = fd)
dwt.SW1 &lt;- modwt.vt(data.SW1, wf = "d4", J = 7, boundary = "periodic", cov.opt = "auto")

x.modwt &lt;- waveslim::modwt(dwt.SW1$x, wf = "d4", n.levels = 7, boundary = "periodic")
dp.modwt &lt;- waveslim::modwt(dwt.SW1$dp[, 1], wf = "d4", n.levels = 7, boundary = "periodic")
dp.vt.modwt &lt;- waveslim::modwt(dwt.SW1$dp.n[, 1], wf = "d4", n.levels = 7, boundary = "periodic")

sum(sapply(dp.modwt, var))
var(dwt.SW1$dp[, 1])
sum(sapply(dp.vt.modwt, var))
var(dwt.SW1$dp.n[, 1])

data &lt;- rbind(
  sapply(dp.modwt, var) / sum(sapply(dp.modwt, var)),
  sapply(dp.vt.modwt, var) / sum(sapply(dp.vt.modwt, var))
)

bar &lt;- barplot(data, beside = TRUE, col = c("red", "blue"))
lines(x = bar[2, ], y = sapply(x.modwt, var) / sum(sapply(x.modwt, var)))
points(x = bar[2, ], y = sapply(x.modwt, var) / sum(sapply(x.modwt, var)))

</code></pre>

<hr>
<h2 id='modwt.vt.val'>Variance Transformation Operation for Validation</h2><span id='topic+modwt.vt.val'></span>

<h3>Description</h3>

<p>Variance Transformation Operation for Validation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modwt.vt.val(data, J, dwt, detrend = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modwt.vt.val_+3A_data">data</code></td>
<td>
<p>A list of response x and dependent variables dp.</p>
</td></tr>
<tr><td><code id="modwt.vt.val_+3A_j">J</code></td>
<td>
<p>Specifies the depth of the decomposition. This must be a number less than or equal to log(length(x),2).</p>
</td></tr>
<tr><td><code id="modwt.vt.val_+3A_dwt">dwt</code></td>
<td>
<p>A class of &quot;modwt&quot; data. Output from modwt.vt().</p>
</td></tr>
<tr><td><code id="modwt.vt.val_+3A_detrend">detrend</code></td>
<td>
<p>Detrend the input time series or just center, default (F)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 8 elements: wf, J, boundary, x (data), dp (data), dp.n (variance transformed dp), and S (covariance matrix).
</p>


<h3>References</h3>

<p>Z Jiang, A Sharma, and F Johnson. WRR
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rain.mon)
data(obs.mon)

## response SPI - calibration
# SPI.cal &lt;- SPI.calc(window(rain.mon, start=c(1949,1), end=c(1979,12)),sc=12)
SPI.cal &lt;- SPEI::spi(window(rain.mon, start = c(1949, 1), end = c(1979, 12)), scale = 12)$fitted

## create paired response and predictors dataset for each station
data.list &lt;- list()
for (id in 1:ncol(SPI.cal)) {
  x &lt;- window(SPI.cal[, id], start = c(1950, 1), end = c(1979, 12))
  dp &lt;- window(obs.mon, start = c(1950, 1), end = c(1979, 12))
  data.list[[id]] &lt;- list(x = as.numeric(x), dp = matrix(dp, nrow = nrow(dp)))
}

## variance transformation - calibration
dwt.list &lt;- lapply(data.list, function(x) {
  modwt.vt(x, wf = "d4", J = 7, boundary = "periodic", cov.opt = "auto")
})

## response SPI - validation
# SPI.val &lt;- SPI.calc(window(rain.mon, start=c(1979,1), end=c(2009,12)),sc=12)
SPI.val &lt;- SPEI::spi(window(rain.mon, start = c(1979, 1), end = c(2009, 12)), scale = 12)$fitted

## create paired response and predictors dataset for each station
data.list &lt;- list()
for (id in 1:ncol(SPI.val)) {
  x &lt;- window(SPI.val[, id], start = c(1980, 1), end = c(2009, 12))
  dp &lt;- window(obs.mon, start = c(1980, 1), end = c(2009, 12))
  data.list[[id]] &lt;- list(x = as.numeric(x), dp = matrix(dp, nrow = nrow(dp)))
}

# variance transformation - validation
dwt.list.val &lt;- lapply(
  seq_along(data.list),
  function(i) modwt.vt.val(data.list[[i]], J = 7, dwt.list[[i]])
)

## plot original and reconstrcuted predictors for each station
for (i in seq_along(dwt.list.val)) {
  # extract data
  dwt &lt;- dwt.list.val[[i]]
  x &lt;- dwt$x # response
  dp &lt;- dwt$dp # original predictors
  dp.n &lt;- dwt$dp.n # variance transformed predictors

  plot.ts(cbind(x, dp))
  plot.ts(cbind(x, dp.n))
}
</code></pre>

<hr>
<h2 id='mra.plot'>Plot function: Plot original time series and decomposed frequency components</h2><span id='topic+mra.plot'></span>

<h3>Description</h3>

<p>Plot function: Plot original time series and decomposed frequency components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mra.plot(
  y,
  y.mra,
  limits.x,
  limits.y,
  type = c("details", "coefs"),
  ps = 12,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mra.plot_+3A_y">y</code></td>
<td>
<p>Original time series (Y).</p>
</td></tr>
<tr><td><code id="mra.plot_+3A_y.mra">y.mra</code></td>
<td>
<p>Decomposed frequency components (d1,d2,..,aJ).</p>
</td></tr>
<tr><td><code id="mra.plot_+3A_limits.x">limits.x</code></td>
<td>
<p>x limit for plot.</p>
</td></tr>
<tr><td><code id="mra.plot_+3A_limits.y">limits.y</code></td>
<td>
<p>y limit for plot.</p>
</td></tr>
<tr><td><code id="mra.plot_+3A_type">type</code></td>
<td>
<p>type of wavelet coefficients, details or approximations.</p>
</td></tr>
<tr><td><code id="mra.plot_+3A_ps">ps</code></td>
<td>
<p>integer; the point size of text (but not symbols).</p>
</td></tr>
<tr><td><code id="mra.plot_+3A_...">...</code></td>
<td>
<p>arguments for plot().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot with original time series and decomposed frequency components.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### synthetic example
# frequency, sampled from a given range
fd &lt;- c(3, 5, 10, 15, 25, 30, 55, 70, 95)
data.SW3 &lt;- data.gen.SW(nobs = 512, fp = c(15, 25, 30), fd = fd)

x &lt;- data.SW3$x
xx &lt;- padding(x, pad = "zero")
### wavelet transfrom
# wavelet family, extension mode and package
wf &lt;- "d4" # wavelet family D8 or db4
boundary &lt;- "periodic"
pad &lt;- "zero"
if (wf != "haar") v &lt;- as.integer(as.numeric(substr(wf, 2, 3)) / 2) else v &lt;- 1

# Maximum decomposition level J
n &lt;- length(x)
J &lt;- ceiling(log(n / (2 * v - 1)) / log(2)) # (Kaiser, 1994)

### decomposition
x.mra &lt;- waveslim::mra(xx, wf = wf, J = J, method = "dwt", boundary = "periodic")
x.mra.m &lt;- matrix(unlist(x.mra), ncol = J + 1)

print(sum(abs(x - rowSums(x.mra.m[1:n, ])))) # additive check
var(x)
sum(apply(x.mra.m[1:n, ], 2, var)) # variance check

limits.x &lt;- c(0, n)
limits.y &lt;- c(-3, 3)
mra.plot(x, x.mra.m, limits.x, limits.y, type = "details")
</code></pre>

<hr>
<h2 id='non.bdy'>Replace Boundary Wavelet Coefficients with Missing Values (NA).</h2><span id='topic+non.bdy'></span>

<h3>Description</h3>

<p>Replace Boundary Wavelet Coefficients with Missing Values (NA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>non.bdy(x, wf, method = c("dwt", "modwt", "mra"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="non.bdy_+3A_x">x</code></td>
<td>
<p>DWT/MODWT/AT object</p>
</td></tr>
<tr><td><code id="non.bdy_+3A_wf">wf</code></td>
<td>
<p>Character string; name of wavelet filter</p>
</td></tr>
<tr><td><code id="non.bdy_+3A_method">method</code></td>
<td>
<p>Either dwt or modwt or mra</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Same object as x only with some missing values (NA).
</p>


<h3>References</h3>

<p>Cornish, C. R., Bretherton, C. S., &amp; Percival, D. B. (2006). Maximal overlap wavelet statistical analysis with application to atmospheric turbulence. Boundary-Layer Meteorology, 119(2), 339-374.
</p>

<hr>
<h2 id='obs.mon'>Sample data: NCEP reanalysis data averaged over Sydney region</h2><span id='topic+obs.mon'></span>

<h3>Description</h3>

<p>A dataset containing 720 rows (data length) and 7 columns (atmospheric variables).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(obs.mon)
</code></pre>

<hr>
<h2 id='padding'>Padding data to dyadic sample size</h2><span id='topic+padding'></span>

<h3>Description</h3>

<p>Padding data to dyadic sample size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>padding(x, pad = c("per", "zero", "sym"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="padding_+3A_x">x</code></td>
<td>
<p>A vector or time series containing the data be to decomposed.</p>
</td></tr>
<tr><td><code id="padding_+3A_pad">pad</code></td>
<td>
<p>Method for padding, including periodic, zero and symetric padding.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dyadic length (power of 2) vector or time series.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(360)
x1 &lt;- padding(x, pad = "per")
x2 &lt;- padding(x, pad = "zero")
x3 &lt;- padding(x, pad = "sym")
ts.plot(cbind(x, x1, x2, x3), col = 1:4)
</code></pre>

<hr>
<h2 id='r2.boot'>R2 threshold by re-sampling approach</h2><span id='topic+r2.boot'></span>

<h3>Description</h3>

<p>R2 threshold by re-sampling approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r2.boot(z.vt, x, prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="r2.boot_+3A_z.vt">z.vt</code></td>
<td>
<p>Identified independent variables</p>
</td></tr>
<tr><td><code id="r2.boot_+3A_x">x</code></td>
<td>
<p>Response or dependent variable</p>
</td></tr>
<tr><td><code id="r2.boot_+3A_prob">prob</code></td>
<td>
<p>Probability with values in [0,1].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A quantile assosciated with prob.
</p>

<hr>
<h2 id='rain.mon'>Sample data: Rainfall station data over Sydney region</h2><span id='topic+rain.mon'></span>

<h3>Description</h3>

<p>A dataset containing 732 rows (data length) and 15 columns (stations).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rain.mon)
</code></pre>

<hr>
<h2 id='scal2freqM'>Scale to frequency by Matlab</h2><span id='topic+scal2freqM'></span>

<h3>Description</h3>

<p>Scale to frequency by Matlab
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scal2freqM(wf, scale, delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scal2freqM_+3A_wf">wf</code></td>
<td>
<p>wavelet name</p>
</td></tr>
<tr><td><code id="scal2freqM_+3A_scale">scale</code></td>
<td>
<p>a scale</p>
</td></tr>
<tr><td><code id="scal2freqM_+3A_delta">delta</code></td>
<td>
<p>the sampling period.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of two numbers: frequency and period.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>delta &lt;- 1 / 12 # monthly data
scales &lt;- 2^(1:7)

for (wf in c("haar", "d4", "d6", "d8", "d16")[1:5]) {
  df1 &lt;- scal2freqM(wf, scales, delta)
  df2 &lt;- scal2freqR(wf, scales, delta)

  print(cbind(df1$frequency, df2$frequency))
}
</code></pre>

<hr>
<h2 id='scal2freqR'>Scale to frequency by R</h2><span id='topic+scal2freqR'></span>

<h3>Description</h3>

<p>Scale to frequency by R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scal2freqR(wf, scale, delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scal2freqR_+3A_wf">wf</code></td>
<td>
<p>wavelet name</p>
</td></tr>
<tr><td><code id="scal2freqR_+3A_scale">scale</code></td>
<td>
<p>a scale</p>
</td></tr>
<tr><td><code id="scal2freqR_+3A_delta">delta</code></td>
<td>
<p>the sampling period.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of two numbers: frequency and period.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>delta &lt;- 1 / 12 # monthly data
scales &lt;- 2^(1:7)

for (wf in c("haar", "d4", "d6", "d8", "d16")[1:5]) {
  df1 &lt;- scal2freqM(wf, scales, delta)
  df2 &lt;- scal2freqR(wf, scales, delta)

  print(cbind(df1$frequency, df2$frequency))
}
</code></pre>

<hr>
<h2 id='SPI.12'>Sample data: Standardized Precipitation Index with 12 month accumulation period.</h2><span id='topic+SPI.12'></span>

<h3>Description</h3>

<p>A dataset containing 1200 rows (data length) and 252 columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SPI.12)
</code></pre>

<hr>
<h2 id='stepwise.VT'>Calculate stepwise high order VT in calibration</h2><span id='topic+stepwise.VT'></span>

<h3>Description</h3>

<p>Calculate stepwise high order VT in calibration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepwise.VT(
  data,
  alpha = 0.1,
  nvarmax = 4,
  mode = c("MRA", "MODWT", "AT"),
  wf,
  J,
  method = "dwt",
  pad = "zero",
  boundary = "periodic",
  cov.opt = "auto",
  flag = "biased",
  detrend = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepwise.VT_+3A_data">data</code></td>
<td>
<p>A list of data, including response and predictors</p>
</td></tr>
<tr><td><code id="stepwise.VT_+3A_alpha">alpha</code></td>
<td>
<p>The significance level used to judge whether the sample estimate is significant. A default alpha value is 0.1.</p>
</td></tr>
<tr><td><code id="stepwise.VT_+3A_nvarmax">nvarmax</code></td>
<td>
<p>The maximum number of variables to be selected.</p>
</td></tr>
<tr><td><code id="stepwise.VT_+3A_mode">mode</code></td>
<td>
<p>A mode of variance transformation, i.e., MRA, MODWT, or AT</p>
</td></tr>
<tr><td><code id="stepwise.VT_+3A_wf">wf</code></td>
<td>
<p>Wavelet family</p>
</td></tr>
<tr><td><code id="stepwise.VT_+3A_j">J</code></td>
<td>
<p>Specifies the depth of the decomposition. This must be a number less than or equal to log(length(x),2).</p>
</td></tr>
<tr><td><code id="stepwise.VT_+3A_method">method</code></td>
<td>
<p>Either &quot;dwt&quot; or &quot;modwt&quot; of MRA.</p>
</td></tr>
<tr><td><code id="stepwise.VT_+3A_pad">pad</code></td>
<td>
<p>The method used for extend data to dyadic size. Use &quot;per&quot;, &quot;zero&quot;, or &quot;sym&quot;.</p>
</td></tr>
<tr><td><code id="stepwise.VT_+3A_boundary">boundary</code></td>
<td>
<p>Character string specifying the boundary condition. If boundary==&quot;periodic&quot; the default, then the vector you decompose is assumed to be periodic on its defined interval, if boundary==&quot;reflection&quot;, the vector beyond its boundaries is assumed to be a symmetric reflection of itself.</p>
</td></tr>
<tr><td><code id="stepwise.VT_+3A_cov.opt">cov.opt</code></td>
<td>
<p>Options of Covariance matrix sign. Use &quot;pos&quot;, &quot;neg&quot;, or &quot;auto&quot;.</p>
</td></tr>
<tr><td><code id="stepwise.VT_+3A_flag">flag</code></td>
<td>
<p>Biased or Unbiased variance transformation.</p>
</td></tr>
<tr><td><code id="stepwise.VT_+3A_detrend">detrend</code></td>
<td>
<p>Detrend the input time series or just center, default (F).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 2 elements: the column numbers of the meaningful predictors (cpy), and partial informational correlation (cpyPIC).
</p>


<h3>References</h3>

<p>Sharma, A., Mehrotra, R., 2014. An information theoretic alternative to model a natural system using observational information alone. Water Resources Research, 50(1): 650-660.
</p>
<p>Jiang, Z., Sharma, A., &amp; Johnson, F. (2021). Variable transformations in the spectral domain â€“ Implications for hydrologic forecasting. Journal of Hydrology, 126816.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Real-world example
data("rain.mon")
data("obs.mon")
mode &lt;- switch(1,
  "MRA",
  "MODWT",
  "AT"
)
wf &lt;- "d4"
station.id &lt;- 5 # station to investigate
SPI.12 &lt;- SPEI::spi(rain.mon, scale = 12)$fitted
lab.names &lt;- colnames(obs.mon)
# plot.ts(SPI.12[,1:10])

x &lt;- window(SPI.12[, station.id], start = c(1950, 1), end = c(1979, 12))
dp &lt;- window(obs.mon[, lab.names], start = c(1950, 1), end = c(1979, 12))

data &lt;- list(x = x, dp = matrix(dp, ncol = ncol(dp)))

dwt &lt;- stepwise.VT(data, mode = mode, wf = wf, flag = "biased")

### plot transformed predictor before and after
cpy &lt;- dwt$cpy
op &lt;- par(mfrow = c(length(cpy), 1), mar = c(2, 3, 2, 1))
for (i in seq_along(cpy)) {
  ts.plot(cbind(dwt$dp[, i], dwt$dp.n[, i]), xlab = "NA", col = 1:2)
}
par(op)
</code></pre>

<hr>
<h2 id='stepwise.VT.val'>Calculate stepwise high order VT in validation</h2><span id='topic+stepwise.VT.val'></span>

<h3>Description</h3>

<p>Calculate stepwise high order VT in validation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepwise.VT.val(data, J, dwt, mode = c("MRA", "MODWT", "AT"), detrend = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepwise.VT.val_+3A_data">data</code></td>
<td>
<p>A list of data, including response and predictors</p>
</td></tr>
<tr><td><code id="stepwise.VT.val_+3A_j">J</code></td>
<td>
<p>Specifies the depth of the decomposition. This must be a number less than or equal to log(length(x),2).</p>
</td></tr>
<tr><td><code id="stepwise.VT.val_+3A_dwt">dwt</code></td>
<td>
<p>Output from dwt.vt(), including the transformation covariance</p>
</td></tr>
<tr><td><code id="stepwise.VT.val_+3A_mode">mode</code></td>
<td>
<p>A mode of variance transformation, i.e., MRA, MODWT, or AT</p>
</td></tr>
<tr><td><code id="stepwise.VT.val_+3A_detrend">detrend</code></td>
<td>
<p>Detrend the input time series or just center, default (F)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of objects, including transformed predictors
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Real-world example
data("rain.mon")
data("obs.mon")
mode &lt;- switch(1,
  "MRA",
  "MODWT",
  "a trous"
)
wf &lt;- "d4"
station.id &lt;- 5 # station to investigate
SPI.12 &lt;- SPEI::spi(rain.mon, scale = 12)$fitted
lab.names &lt;- colnames(obs.mon)
# plot.ts(SPI.12[,1:10])

#--------------------------------------
### calibration
x &lt;- window(SPI.12[, station.id], start = c(1950, 1), end = c(1979, 12))
dp &lt;- window(obs.mon[, lab.names], start = c(1950, 1), end = c(1979, 12))

data &lt;- list(x = x, dp = matrix(dp, ncol = ncol(dp)))
dwt &lt;- stepwise.VT(data, mode = mode, wf = wf, flag = "biased")
cpy &lt;- dwt$cpy
#--------------------------------------
### validation
x &lt;- window(SPI.12[, station.id], start = c(1980, 1), end = c(2009, 12))
dp &lt;- window(obs.mon[, lab.names], start = c(1980, 1), end = c(2009, 12))

data.n &lt;- list(x = x, dp = matrix(dp, ncol = ncol(dp)))
dwt.val &lt;- stepwise.VT.val(data = data.n, dwt = dwt, mode = mode)

### plot transformed predictor before and after
op &lt;- par(mfrow = c(length(cpy), 1), mar = c(0, 3, 2, 1))
for (i in seq_along(cpy))
{
  ts.plot(cbind(dwt.val$dp[, i], dwt.val$dp.n[, i]), xlab = "NA", col = 1:2)
}
par(op)
</code></pre>

<hr>
<h2 id='WASP-package'>WASP: WAvelet System Prediction</h2><span id='topic+WASP-package'></span>

<h3>Description</h3>

<p>The package WASP (variance transformation) is used for system modelling and prediction.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> WASP</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2020-03-17</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>WASP functions</h3>

<p>Variance transformation functions: dwt.vt, modwt.vt, at.vt and associated
</p>
<p>K-nearest neighbor function: knn
</p>
<p>Synthetic data generator functions: data.gen.SW,  data.gen.HL, data.gen.Rossler;
data.gen.ar1, data.gen.ar4, data.gen.ar9, data.gen.tar1, data.gen.tar2.
</p>


<h3>Author(s)</h3>

<p>Ze Jiang
</p>
<p>Maintainer: Ze Jiang &lt;ze.jiang@unsw.edu.au&gt;
</p>


<h3>References</h3>

<p>Jiang, Z., Sharma, A., &amp; Johnson, F. (2020). Refining Predictor Spectral Representation Using Wavelet Theory for Improved Natural System Modeling. Water Resources Research, 56(3), e2019WR026962. doi:10.1029/2019wr026962
</p>
<p>Percival, D. B. and A. T. Walden (2000) Wavelet Methods for Time Series Analysis, Cambridge: Cambridge University Press.
</p>

<hr>
<h2 id='wave.var'>Produces an estimate of the multiscale variance along with approximate confidence intervals.</h2><span id='topic+wave.var'></span>

<h3>Description</h3>

<p>Produces an estimate of the multiscale variance along with approximate confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wave.var(x, type = "eta3", p = 0.025)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wave.var_+3A_x">x</code></td>
<td>
<p>DWT/MODWT/AT object</p>
</td></tr>
<tr><td><code id="wave.var_+3A_type">type</code></td>
<td>
<p>character string describing confidence interval calculation; valid methods are gaussian, eta1, eta2, eta3, nongaussian</p>
</td></tr>
<tr><td><code id="wave.var_+3A_p">p</code></td>
<td>
<p>(one minus the) two-sided p-value for the confidence interval</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe with as many rows as levels in the wavelet transform object. The first column provides the point estimate for the wavelet variance followed by the lower and upper bounds from the confidence interval.
</p>


<h3>References</h3>

<p>Percival, D. B. (1995) Biometrika, 82, No. 3, 619-631.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
