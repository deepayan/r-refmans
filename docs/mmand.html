<!DOCTYPE html><html><head><title>Help for package mmand</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mmand}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#binarise'><p>Binarise a numeric array</p></a></li>
<li><a href='#binary'><p>Check for a binary array</p></a></li>
<li><a href='#components'><p>Find connected components</p></a></li>
<li><a href='#display'><p>Display a 2D image</p></a></li>
<li><a href='#distanceTransform'><p>Distance transforms</p></a></li>
<li><a href='#erode'><p>Standard mathematical morphology operations</p></a></li>
<li><a href='#gameOfLife'><p>Conway's Game of Life</p></a></li>
<li><a href='#gaussianSmooth'><p>Smooth a numeric array with a Gaussian kernel</p></a></li>
<li><a href='#isKernel'><p>Kernel-generating functions</p></a></li>
<li><a href='#meanFilter'><p>Apply a filter to an array</p></a></li>
<li><a href='#morph'><p>Morph an array with a kernel</p></a></li>
<li><a href='#neighbourhood'><p>Get neighbourhood information for an array</p></a></li>
<li><a href='#resample'><p>Resample an array</p></a></li>
<li><a href='#sampleKernelFunction'><p>Sampling and plotting kernels</p></a></li>
<li><a href='#skeletonise'><p>Skeletonise a numeric array</p></a></li>
<li><a href='#sketch'><p>Show an ASCII art representation of a 2D image or matrix</p></a></li>
<li><a href='#symmetric'><p>Check for a symmetric array</p></a></li>
<li><a href='#threshold'><p>Threshold a numeric array or vector</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.6.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-02-07</td>
</tr>
<tr>
<td>Title:</td>
<td>Mathematical Morphology in Any Number of Dimensions</td>
</tr>
<tr>
<td>Author:</td>
<td>Jon Clayden</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jon Clayden &lt;code@clayden.org&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, Rcpp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>loder, tinytest, covr</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools for performing mathematical morphology operations,
    such as erosion and dilation, on data of arbitrary dimensionality. Can also
    be used for finding connected components, resampling, filtering, smoothing
    and other image processing-style operations.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jonclayden/mmand">https://github.com/jonclayden/mmand</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jonclayden/mmand/issues">https://github.com/jonclayden/mmand/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-07 16:44:21 UTC; jon</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-07 17:22:31 UTC</td>
</tr>
</table>
<hr>
<h2 id='binarise'>Binarise a numeric array</h2><span id='topic+binarise'></span><span id='topic+binarize'></span>

<h3>Description</h3>

<p>This function binarises an array, setting all nonzero elements to unity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binarise(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binarise_+3A_x">x</code></td>
<td>
<p>An object that can be coerced to an array, or for which a
<code><a href="#topic+morph">morph</a></code> method exists.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A morphed array with the same dimensions as the original array.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+morph">morph</a></code> for the function underlying this operation, and
<code><a href="#topic+erode">erode</a></code> for mathematical morphology functions.
</p>

<hr>
<h2 id='binary'>Check for a binary array</h2><span id='topic+binary'></span>

<h3>Description</h3>

<p>This function checks whether a numeric array is binary, with only one unique
nonzero value, or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binary(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binary_+3A_x">x</code></td>
<td>
<p>An object that can be coerced to a numeric array.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value indicating whether the array is binary or not.
Binary in this case means that the array contains only one unique nonzero
value, which is stored with the return value in an attribute.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>

<hr>
<h2 id='components'>Find connected components</h2><span id='topic+components'></span><span id='topic+components.default'></span>

<h3>Description</h3>

<p>The <code>components</code> function finds connected components in a numeric
array. The kernel determines which neighbours are considered connected (e.g.
including or excluding diagonal neighbours), and will usually have width 3
in each dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>components(x, kernel, ...)

## Default S3 method:
components(x, kernel, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="components_+3A_x">x</code></td>
<td>
<p>Any object. For the default method, this must be coercible to an
array.</p>
</td></tr>
<tr><td><code id="components_+3A_kernel">kernel</code></td>
<td>
<p>An object representing the kernel to be used, which must be
coercible to an array. It must have odd width in all dimensions, but does
not have to be isotropic in size. The kernel's dimensionality may be less
than that of the target array, <code>x</code>. See <code><a href="#topic+kernels">kernels</a></code> for
kernel-generating functions.</p>
</td></tr>
<tr><td><code id="components_+3A_...">...</code></td>
<td>
<p>Additional arguments to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array of the same dimension as the original, whose integer-valued
elements identify the component to which each element in the array
belongs. Zero values in the original array will result in NAs.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kernels">kernels</a></code> for kernel-generating functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(0,0,1,0,0,0,1,1,1,0,0)
k &lt;- c(1,1,1)
components(x,k)
</code></pre>

<hr>
<h2 id='display'>Display a 2D image</h2><span id='topic+display'></span><span id='topic+display.default'></span><span id='topic+display.matrix'></span><span id='topic+display.array'></span>

<h3>Description</h3>

<p>This function displays a 2D greyscale or RGB colour image. It is a wrapper
around <code>image</code>, with more sensible defaults for images. It is (S3)
generic. A method for 3D arrays is provided, which assumes that the third
dimension corresponds to channel (grey/alpha for two channels, red/green/
blue for three, red/green/blue/alpha for four).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display(x, ...)

## Default S3 method:
display(x, transpose = TRUE, useRaster = TRUE,
  add = FALSE, col = grey(0:255/255), ...)

## S3 method for class 'matrix'
display(x, ...)

## S3 method for class 'array'
display(x, max = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display_+3A_x">x</code></td>
<td>
<p>An R object. For the default method, it must be coercible to a
numeric matrix.</p>
</td></tr>
<tr><td><code id="display_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>image</code>, or the default method.</p>
</td></tr>
<tr><td><code id="display_+3A_transpose">transpose</code></td>
<td>
<p>Whether to transpose the matrix before display. This is
usually necessary due to the conventions of <code>image</code>.</p>
</td></tr>
<tr><td><code id="display_+3A_useraster">useRaster</code></td>
<td>
<p>Whether to use raster graphics if possible. This is
generally preferred for speed. Passed to <code>image</code>.</p>
</td></tr>
<tr><td><code id="display_+3A_add">add</code></td>
<td>
<p>Whether to add the image to an existing plot. If <code>TRUE</code>,
zero values in the image will be converted to <code>NA</code>s for plotting
purposes, to make them transparent. This will not affect the original
image data.</p>
</td></tr>
<tr><td><code id="display_+3A_col">col</code></td>
<td>
<p>The colour scale to use. The default is 256 grey levels. The
array method overrides this appropriately.</p>
</td></tr>
<tr><td><code id="display_+3A_max">max</code></td>
<td>
<p>The maximum colour value for each channel. If <code>NULL</code>, the
default, this is taken from the <code>"range"</code> attribute, if there is one,
otherwise it is 255 for integer-mode arrays, and 1 otherwise. Passed to
<code><a href="grDevices.html#topic+rgb">rgb</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Relative to the defaults for <code>image</code> (from the <code>graphics</code>
package), this function transposes and then inverts the matrix along the
y-direction, uses a grey colour scale, fills the entire device with the
image, and tries to size the image correctly given the dot pitch of the
display. Unfortunately the latter is not always possible, due to downstream
limitations.
</p>
<p>If <code>x</code> has attributes <code>"range"</code>, <code>"background"</code>, <code>"asp"</code>
or <code>"dpi"</code>, these are respected.
</p>


<h3>Value</h3>

<p>This function is called for its side-effect of displaying an image
on a new R device.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>

<hr>
<h2 id='distanceTransform'>Distance transforms</h2><span id='topic+distanceTransform'></span><span id='topic+distanceTransform.default'></span>

<h3>Description</h3>

<p>The Euclidean distance transform produces an array like its argument, but
with element values representing the Euclidean distance to the nearest
nonzero element. The input is treated as logically binary, with all nonzero
values treated as &quot;on&quot;, and all zeroes as &quot;off&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distanceTransform(x, ...)

## Default S3 method:
distanceTransform(x, pixdim = TRUE, signed = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distanceTransform_+3A_x">x</code></td>
<td>
<p>Any object. For the default method, this must be coercible to an
array.</p>
</td></tr>
<tr><td><code id="distanceTransform_+3A_...">...</code></td>
<td>
<p>Additional arguments to methods.</p>
</td></tr>
<tr><td><code id="distanceTransform_+3A_pixdim">pixdim</code></td>
<td>
<p>An optional numeric vector or logical value. In the former
case it will be taken as giving the physical size of the array elements of
<code>x</code> along each dimension, and these will be incorporated into the
distance calculation. If <code>TRUE</code>, the default, the <code>"pixdim"</code>
attribute of <code>x</code> will be used for this purpose, if it is present. If
<code>FALSE</code>, any such attribute will be ignored, and distances will
always be counted in array elements, with all dimensions treated equally.</p>
</td></tr>
<tr><td><code id="distanceTransform_+3A_signed">signed</code></td>
<td>
<p>Logical value. If <code>TRUE</code>, the signed distance transform
is returned, such that distances from the region boundary are negative
within the region and positive outside. Otherwise, distances are zero
within the region.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array of the same dimension as the original, whose elements give
the Euclidean distance from that element to the nearest &quot;on&quot; element in
the original.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>References</h3>

<p>This implementation is based on the &quot;marching parabolas&quot;
algorithm described by Felzenszwalb and Huttenlocher in the paper below.
</p>
<p>P.F. Felzenszwalb &amp; D.P. Huttenlocher (2012). Distance transforms of
sampled functions. Theory of Computing 8(19):415-428.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(0,0,1,0,0,0,1,1,1,0,0)
distanceTransform(x)
distanceTransform(x, pixdim=2)
</code></pre>

<hr>
<h2 id='erode'>Standard mathematical morphology operations</h2><span id='topic+erode'></span><span id='topic+morphology'></span><span id='topic+dilate'></span><span id='topic+opening'></span><span id='topic+closing'></span>

<h3>Description</h3>

<p>These functions provide standard mathematical morphology operations, which
can be applied to array data with any number of dimensions. Binary and
greyscale morphology is supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>erode(x, kernel)

dilate(x, kernel)

opening(x, kernel)

closing(x, kernel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="erode_+3A_x">x</code></td>
<td>
<p>An object that can be coerced to an array, or for which a
<code><a href="#topic+morph">morph</a></code> method exists.</p>
</td></tr>
<tr><td><code id="erode_+3A_kernel">kernel</code></td>
<td>
<p>An array representing the kernel to be used. See
<code><a href="#topic+shapeKernel">shapeKernel</a></code> for functions to generate a suitable kernel.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>erode</code> function uses the kernel as an eraser, centring it on each
zero-valued pixel, which has the effect of eroding the extent of nonzero
areas. Dilation has the opposite effect, extending the nonzero regions in
the array. Opening is an erosion followed by a dilation, and closing is a
dilation followed by an erosion, using the same kernel in both cases.
</p>
<p>If the kernel has only one unique nonzero value, it is described as
&ldquo;flat&rdquo;. For a flat kernel, the erosion is the minimum value of <code>x</code>
within the nonzero region of <code>kernel</code>. For a nonflat kernel, this
becomes the minimum value of <code>x - kernel</code>. Dilation is the opposite
operation, taking the maximum within the kernel.
</p>


<h3>Value</h3>

<p>A morphed array with the same dimensions as the original array.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+morph">morph</a></code> for the function underlying all of these
operations, <code><a href="#topic+kernels">kernels</a></code> for kernel-generating functions,
<code><a href="#topic+binarise">binarise</a></code> for binarising an array, and
<code><a href="#topic+gaussianSmooth">gaussianSmooth</a></code> for smoothing. The <code>EBImage</code>
Bioconductor package also supplies functions to perform these operations,
and may be slightly faster, but only works in two dimensions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(0,0,1,0,0,0,1,1,1,0,0)
k &lt;- c(1,1,1)
erode(x,k)
dilate(x,k)
</code></pre>

<hr>
<h2 id='gameOfLife'>Conway's Game of Life</h2><span id='topic+gameOfLife'></span><span id='topic+gosperGliderGun'></span>

<h3>Description</h3>

<p>An implementation of Conway's Game of Life, a classical cellular automaton,
using the <code><a href="#topic+morph">morph</a></code> function. The <code><a href="#topic+gosperGliderGun">gosperGliderGun</a></code>
function provides an interesting starting configuration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gameOfLife(init, size, density = 0.3, steps = 200, viz = FALSE,
  tick = 0.5)

gosperGliderGun()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gameOfLife_+3A_init">init</code></td>
<td>
<p>The initial state of the automaton, a binary matrix. If missing,
the initial state will be randomly generated, with a population density
given by <code>density</code>.</p>
</td></tr>
<tr><td><code id="gameOfLife_+3A_size">size</code></td>
<td>
<p>The dimensions of the board. Defaults to the size of
<code>init</code>, but must be given if that parameter is missing. If both are
specified and <code>size</code> is larger than the dimensions of <code>init</code>,
then the latter will be padded with zeroes.</p>
</td></tr>
<tr><td><code id="gameOfLife_+3A_density">density</code></td>
<td>
<p>The approximate population density of the starting state.
Ignored if <code>init</code> is provided.</p>
</td></tr>
<tr><td><code id="gameOfLife_+3A_steps">steps</code></td>
<td>
<p>The number of generations of the automaton to simulate.</p>
</td></tr>
<tr><td><code id="gameOfLife_+3A_viz">viz</code></td>
<td>
<p>If <code>TRUE</code>, the state of the system at each generation is
plotted.</p>
</td></tr>
<tr><td><code id="gameOfLife_+3A_tick">tick</code></td>
<td>
<p>The amount of time, in seconds, to pause before plotting each
successive generation. Ignored if <code>viz</code> is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Conway's Game of Life is a simple cellular automaton, based on a 2D matrix
of &ldquo;cells&rdquo;. It shows complex behaviour based on four simple rules. These
are:
</p>

<ol>
<li><p> Any live cell with fewer than two live neighbours dies, as if caused
by under-population.
</p>
</li>
<li><p> Any live cell with two or three live neighbours lives on to the next
generation.
</p>
</li>
<li><p> Any live cell with more than three live neighbours dies, as if by
overcrowding.
</p>
</li>
<li><p> Any dead cell with exactly three live neighbours becomes a live
cell, as if by reproduction.
</p>
</li></ol>

<p>Live and dead cells are represented by 1s and 0s in the matrix,
respectively.
</p>
<p>The initial state and the rules above completely determine the behaviour of
the system. The Gosper glider gun is an interesting starting configuration
that generates so-called &ldquo;gliders&rdquo;, which propagate across the board.
</p>
<p>In principle the size of the board in a cellular automaton is infinite. Of
course this is not easy to simulate, but this implementation adds a border
of two extra cells around the board on all sides to approximate an infinite
board slightly better. These are not visualised, nor returned in the final
state.
</p>


<h3>Value</h3>

<p>A binary matrix representing the final state of the system after
<code>steps</code> generations.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+morph">morph</a></code> function, which powers this simulation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: gameOfLife(init=gosperGliderGun(), size=c(40,40), steps=50, viz=TRUE)
</code></pre>

<hr>
<h2 id='gaussianSmooth'>Smooth a numeric array with a Gaussian kernel</h2><span id='topic+gaussianSmooth'></span>

<h3>Description</h3>

<p>This function smoothes an array using a Gaussian kernel with a specified
standard deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussianSmooth(x, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussianSmooth_+3A_x">x</code></td>
<td>
<p>An object that can be coerced to an array, or for which a
<code><a href="#topic+morph">morph</a></code> method exists.</p>
</td></tr>
<tr><td><code id="gaussianSmooth_+3A_sigma">sigma</code></td>
<td>
<p>A numeric vector giving the standard deviation of the kernel in
each dimension. Can have lower dimensionality than the target array.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation takes advantage of the separability of the Gaussian
kernel for speed when working in multiple dimensions. It is therefore
equivalent to, but much faster than, directly applying a multidimensional
kernel.
</p>


<h3>Value</h3>

<p>A morphed array with the same dimensions as the original array.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+morph">morph</a></code> for the function underlying this operation,
<code><a href="#topic+gaussianKernel">gaussianKernel</a></code> for generating Gaussian kernels (which is
also used by this function), and <code><a href="#topic+erode">erode</a></code> for mathematical
morphology functions.
</p>

<hr>
<h2 id='isKernel'>Kernel-generating functions</h2><span id='topic+isKernel'></span><span id='topic+kernels'></span><span id='topic+isKernelArray'></span><span id='topic+isKernelFunction'></span><span id='topic+kernelArray'></span><span id='topic+shapeKernel'></span><span id='topic+gaussianKernel'></span><span id='topic+sobelKernel'></span><span id='topic+kernelFunction'></span><span id='topic+boxKernel'></span><span id='topic+triangleKernel'></span><span id='topic+mitchellNetravaliKernel'></span><span id='topic+mnKernel'></span><span id='topic+lanczosKernel'></span>

<h3>Description</h3>

<p>These functions can be used to generate kernels for morphological, smoothing
or resampling operations. There are two types of kernels: kernel arrays,
which are used with <code><a href="#topic+morph">morph</a></code>, and kernel functions, which are
used with <code><a href="#topic+resample">resample</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isKernel(object)

isKernelArray(object)

isKernelFunction(object)

kernelArray(values)

shapeKernel(width, dim = length(width), type = c("box", "disc", "diamond"),
  binary = TRUE, normalised = FALSE)

gaussianKernel(sigma, dim = length(sigma), size = 6 * sigma,
  normalised = TRUE)

sobelKernel(dim, axis = 1)

kernelFunction(name = c("box", "triangle", "mitchell-netravali", "lanczos"),
  ...)

boxKernel()

triangleKernel()

mitchellNetravaliKernel(B = 1/3, C = 1/3)

mnKernel(B = 1/3, C = 1/3)

lanczosKernel()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isKernel_+3A_object">object</code></td>
<td>
<p>Any object.</p>
</td></tr>
<tr><td><code id="isKernel_+3A_values">values</code></td>
<td>
<p>A numeric vector or array, containing the values of the kernel
array.</p>
</td></tr>
<tr><td><code id="isKernel_+3A_width">width</code></td>
<td>
<p>A numeric vector giving the width of the shape in each
dimension, in array elements. Does not need to be integer-valued, or equal
for all dimensions. Will be recycled to length <code>dim</code> if that
parameter is also specified.</p>
</td></tr>
<tr><td><code id="isKernel_+3A_dim">dim</code></td>
<td>
<p>An integer value giving the dimensionality of the kernel.
Defaults to the length of <code>width</code> or <code>sigma</code>, where available.</p>
</td></tr>
<tr><td><code id="isKernel_+3A_type">type</code></td>
<td>
<p>A string giving the type of shape to produce. In one dimension,
these shapes are all equivalent.</p>
</td></tr>
<tr><td><code id="isKernel_+3A_binary">binary</code></td>
<td>
<p>If <code>FALSE</code>, the value of the kernel at each point
represents the proportion of the array element within the shape. If
<code>TRUE</code>, these values are binarised to be 1 if at least half of the
element is within the shape, and 0 otherwise.</p>
</td></tr>
<tr><td><code id="isKernel_+3A_normalised">normalised</code></td>
<td>
<p>If <code>TRUE</code>, the sum of non-missing elements of the
kernel will be unity. Note that this is the default for
<code>gaussianKernel</code>, but not for <code>shapeKernel</code>.</p>
</td></tr>
<tr><td><code id="isKernel_+3A_sigma">sigma</code></td>
<td>
<p>A numeric vector giving the standard deviation of the
underlying Gaussian distribution in each dimension, in array elements.
Does not need to be equal for all dimensions. Will be recycled to length
<code>dim</code> if that parameter is also specified.</p>
</td></tr>
<tr><td><code id="isKernel_+3A_size">size</code></td>
<td>
<p>A numeric vector giving the width of the kernel in each
dimension, which will be rounded up to the nearest odd integer. Defaults
to four times the corresponding <code>sigma</code> value.</p>
</td></tr>
<tr><td><code id="isKernel_+3A_axis">axis</code></td>
<td>
<p>The axis along which the gradient operator will be applied.</p>
</td></tr>
<tr><td><code id="isKernel_+3A_name">name</code></td>
<td>
<p>A string giving the name of the kernel function required.</p>
</td></tr>
<tr><td><code id="isKernel_+3A_...">...</code></td>
<td>
<p>Parameters for the kernel function.</p>
</td></tr>
<tr><td><code id="isKernel_+3A_b">B</code>, <code id="isKernel_+3A_c">C</code></td>
<td>
<p>Mitchell-Netravali coefficients, each of which must be between 0
and 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two forms of kernel used by this package. Kernel arrays, otherwise
known in mathematical morphology as structuring elements, are numeric arrays
with class <code>kernelArray</code>. They are defined on a grid of odd width, and
are used by <code><a href="#topic+morph">morph</a></code> and related functions. Kernel functions, by
contrast, are represented in R as a list containing a name and, optionally,
some parameters. The real implementation is in C++. They are defined
everywhere within the support of the kernel, and are used by
<code><a href="#topic+resample">resample</a></code> and friends. The key distinction is in whether the
kernel will always be centred exactly on the location of an existing value
in the data (for kernel arrays) or not (for kernel functions).
</p>
<p>The <code>kernelArray</code> and <code>kernelFunction</code> functions create objects of
the corresponding classes, while <code>isKernelArray</code> and
<code>isKernelFunction</code> test for them. In addition, <code>isKernel</code> returns
<code>TRUE</code> if its argument is of either kernel class.
</p>
<p>The remaining functions generate special-case kernels: <code>shapeKernel</code>
generates arrays with nonzero elements in a box, disc or diamond shape for
use with <code><a href="#topic+morphology">morphology</a></code> functions; <code>gaussianKernel</code> generates
Gaussian coefficients and is used by <code><a href="#topic+gaussianSmooth">gaussianSmooth</a></code>;
<code>sobelKernel</code> generates the Sobel-Feldman gradient operator, for use by
<code><a href="#topic+sobelFilter">sobelFilter</a></code>; <code>boxKernel</code> is used for &ldquo;nearest
neighbour&rdquo; resampling, and <code>triangleKernel</code> for linear, bilinear, etc.
The Mitchell-Netravali kernel, a.k.a. BC-spline, is based on a family of
piecewise-cubic polynomial functions, with support of four times the pixel
separation in each dimension. The default parameters are the ones
recommended by Mitchell and Netravali as a good trade-off between various
artefacts, but other well-known special cases include B=1, C=0 (the cubic
B-spline) and B=0, C=0.5 (the Catmull-Rom spline). <code>mnKernel</code> is a
shorter alias for <code>mitchellNetravaliKernel</code>. Finally, the Lanczos
kernel is a five-lobe windowed sinc function.
</p>


<h3>Value</h3>

<p>For <code>isKernel</code>, <code>isKernelArray</code> and
<code>isKernelFunction</code>, a logical value. For <code>kernelArray</code>,
<code>shapeKernel</code>, <code>gaussianKernel</code> and <code>sobelKernel</code>, a kernel
array. For <code>kernelFunction</code>, <code>boxKernel</code>, <code>triangleKernel</code>,
<code>mitchellNetravaliKernel</code> and <code>mnKernel</code>, a kernel function.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>References</h3>

<p>The Mitchell-Netravali kernel is described in the following
paper.
</p>
<p>D.P. Mitchell &amp; A.N. Netravali (1988). Reconstruction filters in computer
graphics. Computer Graphics 22(4):221-228.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+morph">morph</a></code> for general application of kernel arrays to
data, <code><a href="#topic+morphology">morphology</a></code> for mathematical morphology functions,
<code><a href="#topic+resample">resample</a></code> for resampling, and <code><a href="#topic+gaussianSmooth">gaussianSmooth</a></code>
for smoothing. Also see <code><a href="#topic+sampleKernelFunction">sampleKernelFunction</a></code> for kernel
sampling and plotting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>shapeKernel(c(3,5), type="diamond")
gaussianKernel(c(0.3,0.3))
mnKernel()
</code></pre>

<hr>
<h2 id='meanFilter'>Apply a filter to an array</h2><span id='topic+meanFilter'></span><span id='topic+medianFilter'></span><span id='topic+sobelFilter'></span>

<h3>Description</h3>

<p>These functions apply mean, median or Sobel filters to an array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanFilter(x, kernel)

medianFilter(x, kernel)

sobelFilter(x, dim, axis = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanFilter_+3A_x">x</code></td>
<td>
<p>An object that can be coerced to an array, or for which a
<code><a href="#topic+morph">morph</a></code> method exists.</p>
</td></tr>
<tr><td><code id="meanFilter_+3A_kernel">kernel</code></td>
<td>
<p>A kernel array, indicating the scope of the filter.</p>
</td></tr>
<tr><td><code id="meanFilter_+3A_dim">dim</code></td>
<td>
<p>For <code>sobelFilter</code>, the dimensionality of the kernel. If
missing, this defaults to the dimensionality of <code>x</code>.</p>
</td></tr>
<tr><td><code id="meanFilter_+3A_axis">axis</code></td>
<td>
<p>For <code>sobelFilter</code>, the axis along which to apply the
operator, or 0 to apply it along all directions and generate a magnitude
image. See also <code><a href="#topic+sobelKernel">sobelKernel</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A morphed array with the same dimensions as the original array.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+morph">morph</a></code> for the function underlying these operations,
and <code><a href="#topic+kernels">kernels</a></code> for kernel-generating functions.
</p>

<hr>
<h2 id='morph'>Morph an array with a kernel</h2><span id='topic+morph'></span><span id='topic+morph.default'></span>

<h3>Description</h3>

<p>The <code>morph</code> function applies a kernel to a target array. Optionally,
applying the kernel to a particular array element can be made conditional on
its value, or the number of nonzero immediate neighbours that it has. The
<code>morph</code> function is (S3) generic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>morph(x, kernel, ...)

## Default S3 method:
morph(x, kernel, operator = c("+", "-", "*", "i", "1", "0",
  "=="), merge = c("sum", "min", "max", "mean", "median", "all", "any"),
  value = NULL, valueNot = NULL, nNeighbours = NULL,
  nNeighboursNot = NULL, renormalise = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="morph_+3A_x">x</code></td>
<td>
<p>Any object. For the default method, this must be coercible to an
array.</p>
</td></tr>
<tr><td><code id="morph_+3A_kernel">kernel</code></td>
<td>
<p>An object representing the kernel to be applied, which must be
coercible to an array. It must have odd width in all dimensions, but does
not have to be isotropic in size. The kernel's dimensionality may be less
than that of the target array, <code>x</code>. See <code><a href="#topic+kernels">kernels</a></code> for
kernel-generating functions.</p>
</td></tr>
<tr><td><code id="morph_+3A_...">...</code></td>
<td>
<p>Additional arguments to methods.</p>
</td></tr>
<tr><td><code id="morph_+3A_operator">operator</code></td>
<td>
<p>The operator applied elementwise within the kernel, as a
function of the original image value and the kernel value. Arithmetic
operators are as usual; <code>"i"</code> is the identity operator, where every
value within the kernel will be included as-is; <code>"1"</code> and <code>"0"</code>
include a 1 or 0 for each element within the kernel's nonzero region;
<code>"=="</code> produces a 1 where the image matches the kernel, and 0
elsewhere.</p>
</td></tr>
<tr><td><code id="morph_+3A_merge">merge</code></td>
<td>
<p>The operator applied to combine the elements into a final value
for the centre pixel. All have their usual meanings.</p>
</td></tr>
<tr><td><code id="morph_+3A_value">value</code></td>
<td>
<p>An optional vector of values in the target array for which to
apply the kernel. Takes priority over <code>valueNot</code> if both are
specified.</p>
</td></tr>
<tr><td><code id="morph_+3A_valuenot">valueNot</code></td>
<td>
<p>An optional vector of values in the target array for which
not to apply the kernel.</p>
</td></tr>
<tr><td><code id="morph_+3A_nneighbours">nNeighbours</code></td>
<td>
<p>An optional numeric vector giving allowable numbers of
nonzero neighbours (including diagonal neighbours) for array elements
where the kernel will be applied. Takes priority over
<code>nNeighboursNot</code> if both are specified.</p>
</td></tr>
<tr><td><code id="morph_+3A_nneighboursnot">nNeighboursNot</code></td>
<td>
<p>An optional numeric vector giving nonallowable numbers
of nonzero neighbours (including diagonal neighbours) for array elements
where the kernel will be applied.</p>
</td></tr>
<tr><td><code id="morph_+3A_renormalise">renormalise</code></td>
<td>
<p>If <code>TRUE</code>, the default, and <code>merge</code> is
<code>"sum"</code>, the sum will be renormalised relative to the sum over the
visited part of the kernel. This avoids low-intensity bands around the
edges of a morphed image.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A morphed array with the same dimensions as the original array.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kernels">kernels</a></code> for kernel-generating functions, and
<code><a href="#topic+morphology">morphology</a></code> for more specific mathematical morphology
functions. <code><a href="#topic+gameOfLife">gameOfLife</a></code> shows how this function can be used
for non-morphological purposes, in that case to power a cellular
automaton. See also the <code>kernel</code> and <code>kernapply</code> functions in
the <code>stats</code> package, particularly if you want to smooth time series.
</p>

<hr>
<h2 id='neighbourhood'>Get neighbourhood information for an array</h2><span id='topic+neighbourhood'></span>

<h3>Description</h3>

<p>This function provides information about the structure of a neighbourhood of
a given width within a specified array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighbourhood(x, width)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neighbourhood_+3A_x">x</code></td>
<td>
<p>An object that can be coerced to an array.</p>
</td></tr>
<tr><td><code id="neighbourhood_+3A_width">width</code></td>
<td>
<p>A vector giving the width of the neighbourhood in each
dimension, which will be recycled if necessary. Must not be greater than
the size of the array. Even values are rounded up to the next odd integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements.
</p>
<table>
<tr><td><code>widths</code></td>
<td>
<p>The width of the neighbourhood along each dimension.
Currently all elements of this vector will be the same.</p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>The number of pixels within the neighbourhood.</p>
</td></tr>
<tr><td><code>locs</code></td>
<td>
<p>A matrix giving the coordinates of each neighbourhood pixel
relative to the centre pixel, one per row.</p>
</td></tr>
<tr><td><code>offsets</code></td>
<td>
<p>Vector offsets of the neighbourhood values within
<code>x</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>

<hr>
<h2 id='resample'>Resample an array</h2><span id='topic+resample'></span><span id='topic+resample.default'></span><span id='topic+rescale'></span>

<h3>Description</h3>

<p>The <code>resample</code> function uses a kernel function to resample a target
array. This can be thought of as a generalisation of array indexing which
allows fractional indices. It is (S3) generic. The <code>rescale</code> function
is an alternative interface for the common case where the image is being
scaled to a new size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample(x, points, kernel, ...)

## Default S3 method:
resample(x, points, kernel, pointType = c("auto",
  "general", "grid"), ...)

rescale(x, factor, kernel, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_+3A_x">x</code></td>
<td>
<p>Any object. For the default method, this must be coercible to an
array.</p>
</td></tr>
<tr><td><code id="resample_+3A_points">points</code></td>
<td>
<p>Either a matrix giving the points to sample at, one per row,
or a list giving the locations on each axis, which will be made into a grid.</p>
</td></tr>
<tr><td><code id="resample_+3A_kernel">kernel</code></td>
<td>
<p>A kernel function object, used to provide coefficients for
each resampled value, or the name of one.</p>
</td></tr>
<tr><td><code id="resample_+3A_...">...</code></td>
<td>
<p>Additional options, such as kernel parameters.</p>
</td></tr>
<tr><td><code id="resample_+3A_pointtype">pointType</code></td>
<td>
<p>A string giving the type of the point specification being
used. Usually can be left as <code>"auto"</code>.</p>
</td></tr>
<tr><td><code id="resample_+3A_factor">factor</code></td>
<td>
<p>A vector of scale factors, which will be recycled to the
dimensionality of <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If a generalised sampling scheme is used (i.e. with <code>points</code> a
matrix), the result is a vector of sampled values. For a grid scheme (i.e.
with <code>points</code> a list, including for <code>rescale</code>), it is a
resampled array.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kernels">kernels</a></code> for kernel-generating functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>resample(c(0,0,1,0,0), seq(0.75,5.25,0.5), triangleKernel())
</code></pre>

<hr>
<h2 id='sampleKernelFunction'>Sampling and plotting kernels</h2><span id='topic+sampleKernelFunction'></span><span id='topic+plot.kernelArray'></span><span id='topic+plot.kernelFunction'></span>

<h3>Description</h3>

<p>These functions can be used to sample and plot kernel profiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleKernelFunction(kernel, values)

## S3 method for class 'kernelArray'
plot(x, y, axis = 1, lwd = 2, col = "red", ...)

## S3 method for class 'kernelFunction'
plot(x, y, xlim = c(-2, 2), lwd = 2,
  col = "red", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleKernelFunction_+3A_kernel">kernel</code></td>
<td>
<p>A kernel function object.</p>
</td></tr>
<tr><td><code id="sampleKernelFunction_+3A_values">values</code></td>
<td>
<p>A vector of values to sample the function at. These are in
units of pixels, with zero representing the centre of the kernel.</p>
</td></tr>
<tr><td><code id="sampleKernelFunction_+3A_x">x</code></td>
<td>
<p>A kernel object of the appropriate class.</p>
</td></tr>
<tr><td><code id="sampleKernelFunction_+3A_y">y</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="sampleKernelFunction_+3A_axis">axis</code></td>
<td>
<p>The axis to profile along.</p>
</td></tr>
<tr><td><code id="sampleKernelFunction_+3A_lwd">lwd</code></td>
<td>
<p>The line width to use for the kernel profile.</p>
</td></tr>
<tr><td><code id="sampleKernelFunction_+3A_col">col</code></td>
<td>
<p>The line colour to use for the kernel profile.</p>
</td></tr>
<tr><td><code id="sampleKernelFunction_+3A_...">...</code></td>
<td>
<p>Additional plot parameters.</p>
</td></tr>
<tr><td><code id="sampleKernelFunction_+3A_xlim">xlim</code></td>
<td>
<p>The limits of the range used to profile the kernel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>sampleKernelFunction</code> a vector of kernel values at the
locations requested. The <code>plot</code> methods are called for their
side-effects.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kernels">kernels</a></code> for kernel-generating functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sampleKernelFunction(mnKernel(), -2:2)
plot(mnKernel())
</code></pre>

<hr>
<h2 id='skeletonise'>Skeletonise a numeric array</h2><span id='topic+skeletonise'></span><span id='topic+skeletonize'></span>

<h3>Description</h3>

<p>Skeletonisation is the process of thinning a shape to a medial line or
surface, and can be achieved using elementary mathematical morphology
operations in a number of ways. Three methods are available through this
function. They are all iterative and therefore relatively time-consuming.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skeletonise(x, kernel = NULL, method = c("lantuejoul", "beucher",
  "hitormiss"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skeletonise_+3A_x">x</code></td>
<td>
<p>An object that can be coerced to an array, or for which a
<code><a href="#topic+morph">morph</a></code> method exists.</p>
</td></tr>
<tr><td><code id="skeletonise_+3A_kernel">kernel</code></td>
<td>
<p>An array representing the kernel to be used for the underlying
morphology operations. The kernel is fixed for the <code>"hitormiss"</code>
method, so this argument will be ignored.</p>
</td></tr>
<tr><td><code id="skeletonise_+3A_method">method</code></td>
<td>
<p>A string giving the method to use. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default method is Lantuéjoul's formula, a union across repeated
erosions, which works in any number of dimensions and may produce
reasonable results on greyscale images, but does not in general produce a
connected skeleton. Beucher introduced an alternative which may produce a
better result (although again the skeleton may not be connected), but this
implementation of the latter algorithm only applies to binary arrays. The
final method uses the so-called hit-or-miss transform, which searches for
exact patterns in the source array. This is guaranteed to produce a
connected skeleton, which is often desirable, but uses fixed kernels (so the
<code>kernel</code> argument is ignored) and is currently only implemented for 2D
binary arrays.
</p>


<h3>Value</h3>

<p>A skeletonised array with the same dimensions as the original array.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>References</h3>

<p>C. Lantuéjoul (1977). Sur le modèle de Johnson-Mehl généralisé. Technical
report, Centre de Morphologie Mathématique, Fontainebleau, France.
</p>
<p>S. Beucher (1994). Digital skeletons in Euclidean and geodesic spaces.
Signal Processing 38(1):127-141. <a href="https://doi.org/10.1016/0165-1684%2894%2990061-2">doi:10.1016/0165-1684(94)90061-2</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+morphology">morphology</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(0,0,1,0,0,0,1,1,1,0,0)
k &lt;- c(1,1,1)
skeletonise(x,k)
</code></pre>

<hr>
<h2 id='sketch'>Show an ASCII art representation of a 2D image or matrix</h2><span id='topic+sketch'></span>

<h3>Description</h3>

<p>This function prints a rough, text-only representation of an image argument
to the R terminal, mapping image intensities to a 10-level pseudo-greyscale.
The image is first rescaled to fit into the terminal or other specified
width, and downsampled in the row direction to correct for nonsquare
character shapes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sketch(x, invert = FALSE, width = getOption("width"), squash = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sketch_+3A_x">x</code></td>
<td>
<p>An object that can be coerced to a numeric matrix or array. 3D
arrays with third dimension no greater than 4 will be taken as
multichannel 2D images, and their channels averaged before display.
Plain vectors and 1D arrays will be treated as single-row matrices.</p>
</td></tr>
<tr><td><code id="sketch_+3A_invert">invert</code></td>
<td>
<p>By default the mapping uses heavier type for brighter areas.
If this option is <code>TRUE</code>, the sense of the scale will be reversed.</p>
</td></tr>
<tr><td><code id="sketch_+3A_width">width</code></td>
<td>
<p>The width of sketch to draw, in characters.</p>
</td></tr>
<tr><td><code id="sketch_+3A_squash">squash</code></td>
<td>
<p>The factor by which to scale the row direction of the image.
Generally this should be markedly less than one, to preserve the aspect
ratio of the image, since most fixed-width font characters are taller than
they are wide.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The result is a compact representation of a matrix that can be used for
visualising kernel arrays, sparse matrices and other non-images.
</p>


<h3>Value</h3>

<p>This function is called for the side-effect of printing an ASCII
representation of its argument.
</p>


<h3>Note</h3>

<p>If the terminal does not used a fixed-width font, the result is
unlikely to be useful.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+display">display</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sketch(shapeKernel(c(9,15), type="diamond"))
sketch(shapeKernel(c(9,15), type="diamond"), squash=1)
</code></pre>

<hr>
<h2 id='symmetric'>Check for a symmetric array</h2><span id='topic+symmetric'></span>

<h3>Description</h3>

<p>This function checks whether a numeric array is symmetric, in the sense of
transposition. This is tested by comparing the reversed vectorised array to
the unreversed equivalent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symmetric(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symmetric_+3A_x">x</code></td>
<td>
<p>An object that can be coerced to a numeric array.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value indicating whether the array is symmetric or not.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>

<hr>
<h2 id='threshold'>Threshold a numeric array or vector</h2><span id='topic+threshold'></span>

<h3>Description</h3>

<p>This function thresholds an array or vector, setting elements below the
threshold value to zero. The threshold can be given literally or calculated
using k-means clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>threshold(x, level, method = c("literal", "kmeans"), binarise = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="threshold_+3A_x">x</code></td>
<td>
<p>A numeric vector or array.</p>
</td></tr>
<tr><td><code id="threshold_+3A_level">level</code></td>
<td>
<p>The literal threshold level, if required.</p>
</td></tr>
<tr><td><code id="threshold_+3A_method">method</code></td>
<td>
<p>The method to use to calculate the threshold. If
<code>"literal"</code> (the default) then the value of <code>level</code> will be
used. If <code>"kmeans"</code> then the threshold value will be determined
implicitly using k-means clustering.</p>
</td></tr>
<tr><td><code id="threshold_+3A_binarise">binarise</code></td>
<td>
<p>Whether to set suprathreshold elements to unity (if
<code>TRUE</code>), or leave them at their original values (if <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+binarise">binarise</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(0.1, 0.05, 0.95, 0.85, 0.15, 0.9)
threshold(x, method="kmeans")
threshold(x, 0.5)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
