<!DOCTYPE html><html><head><title>Help for package MorphoTools2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MorphoTools2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#boxMTest'><p>Box's M-test for Homogeneity of Covariance Matrices</p></a></li>
<li><a href='#boxplotCharacter'><p>Box Plots</p></a></li>
<li><a href='#cda.calc'><p>Canonical Discriminant Analysis</p></a></li>
<li><a href='#cdadata'><p>Class Cdadata</p></a></li>
<li><a href='#centaurea'><p>25 Morphological Characters of Three Species of the <em>Centaurea phrygia</em> Complex</p></a></li>
<li><a href='#characters'><p>List Morphological Characters</p></a></li>
<li><a href='#classif.lda'><p>Classificatory Discriminant Analysis</p></a></li>
<li><a href='#classif.matrix'><p>Format the Classifdata to Summary Table</p></a></li>
<li><a href='#classifdata'><p>Class classifdata</p></a></li>
<li><a href='#classifSample.lda'><p>Classificatory Discriminant Analysis</p></a></li>
<li><a href='#clust'><p>Hierarchical Clustering</p></a></li>
<li><a href='#cormat'><p>Correlations of Characters</p></a></li>
<li><a href='#descrTaxon'><p>Descriptive Statistics</p></a></li>
<li><a href='#exportRes'><p>Export Data</p></a></li>
<li><a href='#head.morphodata'><p>Return the First or Last Parts of an Object</p></a></li>
<li><a href='#histCharacter'><p>Histograms of Characters</p></a></li>
<li><a href='#keepTaxon'><p>Keep Items (Taxa, Populations, Samples, Morphological Characters) in an Morphodata Object (and Remove Others)</p></a></li>
<li><a href='#knn.select'><p>Search for the Optimal K-nearest Neighbours</p></a></li>
<li><a href='#missingCharactersTable'><p>Summarize Missing Data</p></a></li>
<li><a href='#missingSamplesTable'><p>Summarize Missing Data</p></a></li>
<li><a href='#morphodata'><p>Class morphodata</p></a></li>
<li><a href='#naMeanSubst'><p>Replace Missing Data by Population Average</p></a></li>
<li><a href='#nmds.calc'><p>Non-metric Multidimensional Scaling (NMDS)</p></a></li>
<li><a href='#nmdsdata'><p>Class nmdsdata</p></a></li>
<li><a href='#pca.calc'><p>Principal Component Analysis</p></a></li>
<li><a href='#pcadata'><p>Class pcadata</p></a></li>
<li><a href='#pcoa.calc'><p>Principal Coordinates Analysis (PCoA)</p></a></li>
<li><a href='#pcoadata'><p>Class pcoadata</p></a></li>
<li><a href='#plot3Dpoints'><p>The Default Scatterplot 3D Function</p></a></li>
<li><a href='#plotAddEllipses'><p>Add Prediction Ellipses to a Plot</p></a></li>
<li><a href='#plotAddLabels.characters'><p>Add Labels to a Plot</p></a></li>
<li><a href='#plotAddLabels.points'><p>Add Labels to a Plot</p></a></li>
<li><a href='#plotAddLegend'><p>Add Legend to a Plot</p></a></li>
<li><a href='#plotAddSpiders'><p>Add Spiders to a Plot</p></a></li>
<li><a href='#plotCharacters'><p>Draws Character's Contribution as Arrows</p></a></li>
<li><a href='#plotPoints'><p>The Default Scatterplot Function</p></a></li>
<li><a href='#populOTU'><p>Population Means</p></a></li>
<li><a href='#qqnormCharacter'><p>Quantile-Quantile Plots</p></a></li>
<li><a href='#read.morphodata'><p>Data Input and Description</p></a></li>
<li><a href='#removeTaxon'><p>Remove Items (Taxa, Populations, Morphological Characters) from Morphodata Object</p></a></li>
<li><a href='#shapiroWilkTest'><p>Shapiro-Wilk Normality Test</p></a></li>
<li><a href='#stepdisc.calc'><p>Stepwise Discriminant Analysis</p></a></li>
<li><a href='#summary'><p>Object Summaries</p></a></li>
<li><a href='#transformCharacter'><p>Transformation of Character</p></a></li>
<li><a href='#viewMorphodata'><p>Invoke a Data Viewer</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate Morphometric Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-02-13</td>
</tr>
<tr>
<td>Author:</td>
<td>Marek Šlenker [aut, cre] (https://orcid.org/0000-0002-5919-890X)
        Petr Koutecký [ctb] (https://orcid.org/0000-0002-3455-850X)
        Karol Marhold [ctb] (https://orcid.org/0000-0002-7658-0844)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marek Šlenker &lt;marek.slenker@savba.sk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for multivariate analyses of morphological data, wrapped in one package, to make the workflow convenient and fast. Statistical and graphical tools provide a comprehensive framework for checking and manipulating input data, statistical analyses, and visualization of results. Several methods are provided for the analysis of raw data, to make the dataset ready for downstream analyses. Integrated statistical methods include hierarchical classification, principal component analysis, principal coordinates analysis, non-metric multidimensional scaling, and multiple discriminant analyses: canonical, stepwise, and classificatory (linear, quadratic, and the non-parametric k nearest neighbours). The philosophy of the package is described in Šlenker et al. 2022.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/MarekSlenker/MorphoTools2">https://github.com/MarekSlenker/MorphoTools2</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/MarekSlenker/MorphoTools2/issues">https://github.com/MarekSlenker/MorphoTools2/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>ade4, candisc, car, class, ellipse, heplots, MASS, methods,
plot3D, StatMatch, utils, vegan, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-13 07:51:36 UTC; HP</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-19 23:00:18 UTC</td>
</tr>
</table>
<hr>
<h2 id='boxMTest'>Box's M-test for Homogeneity of Covariance Matrices</h2><span id='topic+boxMTest'></span>

<h3>Description</h3>

<p>The <code>boxMTest</code> function performs Box's (1949) M-test for homogeneity of covariance matrices. The null hypothesis for this test is that the observed covariance matrices for the dependent variables are equal across groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boxMTest(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxMTest_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+morphodata">morphodata</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Used for its side effect.
</p>


<h3>References</h3>

<p><strong>Box G.E.P. (1949)</strong>. A general distribution theory for a class of likelihood criteria. <em>Biometrika</em> 36, 317-346.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)

# remove NAs and linearly dependent characters (characters with unique contributions
#                  can be identified by stepwise discriminant analysis.)
centaurea = naMeanSubst(centaurea)
centaurea = removePopulation(centaurea, populationName = c("LIP", "PREL"))
centaurea = keepCharacter(centaurea, c("MLW", "ML", "IW", "LS", "IV", "MW", "MF",
                                    "AP", "IS", "LBA", "LW", "AL", "ILW", "LBS",
                                    "SFT", "CG", "IL", "LM", "ALW", "AW", "SF") )
# add a small constant to characters witch are invariant within taxa
centaurea$data[ centaurea$Taxon == "hybr", "LM" ][1] =
             centaurea$data[ centaurea$Taxon == "hybr", "LM" ][1] + 0.000001
centaurea$data[ centaurea$Taxon == "ph", "IV" ][1] =
             centaurea$data[ centaurea$Taxon == "ph", "IV" ][1] + 0.000001
centaurea$data[ centaurea$Taxon == "st", "LBS"][1] =
             centaurea$data[ centaurea$Taxon == "st", "LBS"][1] + 0.000001

boxMTest(centaurea)
</code></pre>

<hr>
<h2 id='boxplotCharacter'>Box Plots</h2><span id='topic+boxplotCharacter'></span><span id='topic+boxplotAll'></span>

<h3>Description</h3>

<p>These functions produce a box-and-whisker plot(s) of the given morphological character(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boxplotCharacter(object, character, outliers = TRUE, lowerWhisker = 0.05,
          upperWhisker = 0.95, col = "white", border = "black", main = character,
          cex.main = 1.5, xlab = NULL, ylab = NULL, frame = TRUE, pch = 8,
          horizontal = FALSE, varwidth = FALSE, ...)

boxplotAll(object, folderName = "boxplots", outliers = TRUE, lowerWhisker = 0.05,
      upperWhisker = 0.95, col = "white", border = "black", main = character,
      cex.main = 1.5, xlab = NULL, ylab = NULL, frame = TRUE, pch = 8,
      horizontal = FALSE, varwidth = FALSE, width = 480, height = 480, units = "px", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxplotCharacter_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+morphodata">morphodata</a></code>.</p>
</td></tr>
<tr><td><code id="boxplotCharacter_+3A_character">character</code></td>
<td>
<p>a morphological character used to plot boxplot.</p>
</td></tr>
<tr><td><code id="boxplotCharacter_+3A_foldername">folderName</code></td>
<td>
<p>folder to save produced boxplots.</p>
</td></tr>
<tr><td><code id="boxplotCharacter_+3A_outliers">outliers</code></td>
<td>
<p>logical, if <code>TRUE</code>, the outliers are drawn.</p>
</td></tr>
<tr><td><code id="boxplotCharacter_+3A_lowerwhisker">lowerWhisker</code></td>
<td>
<p>percentile to which the lower whisker is extended.</p>
</td></tr>
<tr><td><code id="boxplotCharacter_+3A_upperwhisker">upperWhisker</code></td>
<td>
<p>percentile to which the upper whisker is extended.</p>
</td></tr>
<tr><td><code id="boxplotCharacter_+3A_col">col</code></td>
<td>
<p>background colour for the boxes.</p>
</td></tr>
<tr><td><code id="boxplotCharacter_+3A_border">border</code></td>
<td>
<p>colour of outliers and the lines.</p>
</td></tr>
<tr><td><code id="boxplotCharacter_+3A_frame">frame</code></td>
<td>
<p>logical, if <code>TRUE</code>, a 'frame' (box around the plot) is drawn.</p>
</td></tr>
<tr><td><code id="boxplotCharacter_+3A_main">main</code></td>
<td>
<p>main title for the plot.</p>
</td></tr>
<tr><td><code id="boxplotCharacter_+3A_cex.main">cex.main</code></td>
<td>
<p>magnification to be used for the main title.</p>
</td></tr>
<tr><td><code id="boxplotCharacter_+3A_pch">pch</code></td>
<td>
<p>plotting symbol of the outliers.</p>
</td></tr>
<tr><td><code id="boxplotCharacter_+3A_xlab">xlab</code>, <code id="boxplotCharacter_+3A_ylab">ylab</code></td>
<td>
<p>title of the respective axes.</p>
</td></tr>
<tr><td><code id="boxplotCharacter_+3A_horizontal">horizontal</code></td>
<td>
<p>logical, indicating if the boxplot should be horizontal.</p>
</td></tr>
<tr><td><code id="boxplotCharacter_+3A_varwidth">varwidth</code></td>
<td>
<p>logical, if <code>TRUE</code>, the boxes are drawn with widths proportional to the square-roots of the number of observations in the groups.</p>
</td></tr>
<tr><td><code id="boxplotCharacter_+3A_width">width</code></td>
<td>
<p>the width of the figure.</p>
</td></tr>
<tr><td><code id="boxplotCharacter_+3A_height">height</code></td>
<td>
<p>the height of the figure.</p>
</td></tr>
<tr><td><code id="boxplotCharacter_+3A_units">units</code></td>
<td>
<p>the units in which <code>height</code> and <code>width</code> are given. Can be <code>"px"</code> (pixels, the default), <code>"in"</code> (inches), <code>"cm"</code> or <code>"mm"</code>.</p>
</td></tr>
<tr><td><code id="boxplotCharacter_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="graphics.html#topic+boxplot">boxplot</a></code> or <code><a href="graphics.html#topic+bxp">bxp</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions modify the classical <code><a href="graphics.html#topic+boxplot">boxplot</a></code> function to allow whiskers to be extended to the desired percentiles. By default, the whiskers are extended to the 5th and 95th percentiles, because of the trimmed range (without the most extreme 10% of values) use to be used in taxa descriptions, determination keys, etc. Box defines 25th and 75th percentiles, bold horizontal line shows median (50th percentile). Missing values are ignored.
</p>
<p>The <code>boxplotAll</code> function produces boxplots for each morphological character and saves them to a folder defined by the <code>folderName</code> argument. If it does not exist, a new folder is created.
</p>


<h3>Value</h3>

<p>None. Used for its side effect of producing a plot(s).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)

boxplotCharacter(centaurea, character = "ST", col = "orange", border = "red")

boxplotCharacter(centaurea, character = "ST", outliers = FALSE,
          lowerWhisker = 0.1, upperWhisker = 0.9)

boxplotCharacter(centaurea, "ST", varwidth = TRUE, notch = TRUE,
          boxwex = 0.4, staplewex = 1.3, horizontal = TRUE)

boxplotCharacter(centaurea, "ST", boxlty = 1, medlwd = 5,
          whisklty = 2, whiskcol = "red", staplecol = "red",
          outcol = "grey30", pch = "-")

## Not run: boxplotAll(centaurea, folderName = "../boxplots")
</code></pre>

<hr>
<h2 id='cda.calc'>Canonical Discriminant Analysis</h2><span id='topic+cda.calc'></span>

<h3>Description</h3>

<p>This function performs canonical discriminant analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cda.calc(object, passiveSamples = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cda.calc_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+morphodata">morphodata</a></code>.</p>
</td></tr>
<tr><td><code id="cda.calc_+3A_passivesamples">passiveSamples</code></td>
<td>
<p>taxa or populations, which will be only predicted, see Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>cda.calc</code> function performs canonical discriminant analysis using the <code>candisc</code> method from the <code>candisc</code> package. Canonical discriminant analysis finds linear combination of the quantitative variables that maximize the difference in the mean discriminant score between groups. This function allows exclude subset of samples (<code>passiveSamples</code>) from computing the discriminant function, and only passively predict them in multidimensional space. This approach is advantageous for testing the positions of &ldquo;atypical&rdquo; populations (e.g., putative hybrids) or for assessing positions of selected individuals (e.g., type herbarium specimens).
</p>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+cdadata">cdadata</a></code> with the following elements:
</p>
<table>
<tr><td><code>objects</code></td>
<td>
</td></tr>
</table>

<table>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: right;"> <code>ID</code> </td><td style="text-align: left;"> IDs of each row of <code>scores</code> object. </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: right;"> <code>Population</code> </td><td style="text-align: left;"> population membership of each row of <code>scores</code> object. </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: right;"> <code>Taxon</code> </td><td style="text-align: left;"> taxon membership of each row of <code>scores</code> object. </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: right;"> <code>scores</code> </td><td style="text-align: left;"> ordination scores of cases (objects, OTUs). </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<table>
<tr><td><code>eigenValues</code></td>
<td>
<p>eigenvalues, i.e., proportion of variation of the original dataset expressed by individual axes.</p>
</td></tr>
<tr><td><code>eigenvaluesAsPercent</code></td>
<td>
<p>eigenvalues as percent, percentage of their total sum. </p>
</td></tr>
<tr><td><code>cumulativePercentageOfEigenvalues</code></td>
<td>
<p>cumulative percentage of eigenvalues. </p>
</td></tr>
<tr><td><code>groupMeans</code></td>
<td>
<p><code>data.frame</code> containing the means for the taxa.</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>number of non-zero eigenvalues.</p>
</td></tr>
<tr><td><code>coeffs.raw</code></td>
<td>
<p>matrix containing the raw canonical coefficients.</p>
</td></tr>
<tr><td><code>coeffs.std</code></td>
<td>
<p>matrix containing the standardized canonical coefficients.</p>
</td></tr>
<tr><td><code>totalCanonicalStructure</code></td>
<td>
<p>matrix containing the total canonical structure coefficients, i.e., total-sample correlations between the original variables and the canonical variables.</p>
</td></tr>
<tr><td><code>canrsq</code></td>
<td>
<p>squared canonical correlations.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)
centaurea = naMeanSubst(centaurea)
centaurea = removePopulation(centaurea, populationName = c("LIP", "PREL"))

cdaRes = cda.calc(centaurea)

summary(cdaRes)

plotPoints(cdaRes, col = c("red", "green", "blue", "red"),
  pch = c(20, 17, 8, 21), pt.bg = "orange", legend = TRUE)
</code></pre>

<hr>
<h2 id='cdadata'>Class Cdadata</h2><span id='topic+cdadata'></span>

<h3>Description</h3>

<p>The <code>cdadata</code> class is designed for storing results of canonical discriminant analysis.</p>


<h3>Format</h3>

<p>Class <code>cdadata</code>.
</p>

<dl>
<dt>objects</dt><dd>

<dl>
<dt>ID</dt><dd><p>IDs of each row of <code>scores</code> object.</p>
</dd>
<dt>Population</dt><dd><p>population membership of each row of <code>scores</code> object.</p>
</dd>
<dt>Taxon</dt><dd><p>taxon membership of each row of <code>scores</code> object.</p>
</dd>
<dt>scores</dt><dd><p>ordination scores of cases (objects, OTUs).</p>
</dd>
</dl>

</dd>
<dt>eigenValues</dt><dd><p>eigenvalues, i.e., proportion of variation of the original dataset expressed by individual axes.</p>
</dd>
<dt>eigenvaluesAsPercent</dt><dd><p>eigenvalues as percent, percentage of their total sum. </p>
</dd>
<dt>cumulativePercentageOfEigenvalues</dt><dd><p>cumulative percentage of eigenvalues. </p>
</dd>
<dt>groupMeans</dt><dd><p><code>data.frame</code> containing the means for the taxa.</p>
</dd>
<dt>rank</dt><dd><p>number of non-zero eigenvalues.</p>
</dd>
<dt>coeffs.raw</dt><dd><p>matrix containing the raw canonical coefficients.</p>
</dd>
<dt>coeffs.std</dt><dd><p>matrix containing the standardized canonical coefficients.</p>
</dd>
<dt>totalCanonicalStructure</dt><dd><p>matrix containing the total canonical structure coefficients, i.e., total-sample correlations between the original variables and the canonical variables.</p>
</dd>
<dt>canrsq</dt><dd><p>squared canonical correlations.</p>
</dd>
</dl>


<hr>
<h2 id='centaurea'>25 Morphological Characters of Three Species of the <em>Centaurea phrygia</em> Complex</h2><span id='topic+centaurea'></span>

<h3>Description</h3>

<p>The sample data include part of data sets from previously published studies by Koutecky (2007) and Koutecky et al. (2012): 25 morphological characters (see the cited studies for details) of the vegetative (stems and leaves) and reproductive structures (capitula and achenes) of three diploid species of the <em>Centaurea phrygia</em> complex: <em>C. phrygia</em> L. s.str. (abbreviated &ldquo;ph&rdquo;), <em>C. pseudophrygia</em> C.A.Mey. (&ldquo;ps&rdquo;) and <em>C. stenolepis</em> A.Kern. (&ldquo;st&rdquo;). Moreover, a fourth group includes the putative hybrid of the <em>C. pseudophrygia</em> and <em>C. stenolepis</em> (&ldquo;hybr&rdquo;). The data represent 8, 12, 7 and 6 populations for each group, respectively, and 20 individuals per population, with one exception in which only 12 individuals were available. All morphological characters are either quantitative (sizes, counts, or ratios) or binary (two characters states or presence/absence). In four characters of achenes (AL, AW, ALW, AP), there are missing data because fruits were not available in all individuals. In two populations of <em>C. stenolepis</em> (LIP, PREL) fruits were completely missing. In total, the data set includes 652 individuals (453 complete) from 33 populations (31 complete).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(centaurea)
</code></pre>


<h3>Format</h3>

<p>an object of class <code><a href="#topic+morphodata">morphodata</a></code> with the following elements:
</p>

<table>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: right;"> <code>ID</code> </td><td style="text-align: left;"> IDs of each row of <code>data</code> object. </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: right;"> <code>Population</code> </td><td style="text-align: left;"> population membership of each row of <code>data</code> object. </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: right;"> <code>Taxon</code> </td><td style="text-align: left;"> taxon membership of each row of <code>data</code> object. </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: right;"> <code>data</code> </td><td style="text-align: left;"> <code>data.frame</code> of individuals (rows) and values of morphological characters (columns). </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>References</h3>

<p><strong>Koutecky P. (2007)</strong>. Morphological and ploidy level variation of <em>Centaurea phrygia</em> agg.(Asteraceae) in the Czech Republic, Slovakia and Ukraine. <em>Folia Geobotanica</em> 42, 77-102.<br />
<strong>Koutecky P., Stepanek J., Badurova T. (2012)</strong>. Differentiation between diploid and tetraploid <em>Centaurea phrygia</em>: mating barriers, morphology and geographic distribution. <em>Preslia</em> 84, 1-32.</p>

<hr>
<h2 id='characters'>List Morphological Characters</h2><span id='topic+characters'></span>

<h3>Description</h3>

<p>Returns list morphological characters of object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>characters(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="characters_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+morphodata">morphodata</a></code>, <code><a href="#topic+pcadata">pcadata</a></code> or <code><a href="#topic+cdadata">cdadata</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector containing names of morphological characters of object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)

characters(centaurea)
</code></pre>

<hr>
<h2 id='classif.lda'>Classificatory Discriminant Analysis</h2><span id='topic+classif.lda'></span><span id='topic+classif.qda'></span><span id='topic+classif.knn'></span>

<h3>Description</h3>

<p>These functions computes discriminant function for classifying observations. Linear discriminant function (<code>classif.lda</code>), quadratic discriminant function (<code>classif.qda</code>), or nonparametric k-nearest neighbours classification method (<code>classif.knn</code>) can be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classif.lda(object, crossval = "indiv")

classif.qda(object, crossval = "indiv")

classif.knn(object, k, crossval = "indiv")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classif.lda_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+morphodata">morphodata</a></code>.</p>
</td></tr>
<tr><td><code id="classif.lda_+3A_crossval">crossval</code></td>
<td>
<p>crossvalidation mode, sets individual (<code>"indiv"</code>; default, one-leave-out method) or whole populations (<code>"pop"</code>) as leave-out unit.</p>
</td></tr>
<tr><td><code id="classif.lda_+3A_k">k</code></td>
<td>
<p>number of neighbours considered for the k-nearest neighbours method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>classif.lda</code> and <code>classif.qda</code> performs classification using linear and quadratic discriminant functions with cross-validation using the <code>lda</code> and <code>qda</code> functions from the package <code>MASS</code>. The prior probabilities of group memberships are equal.
</p>
<p>LDA and QDA analyses have some requirements: (1) no character can be a linear combination of any other character; (2) no pair of characters can be highly correlated; (3) no character can be invariant in any taxon; (4) for the number of taxa (g), characters (p) and total number of samples (n) should hold: 0 <code class="reqn">&lt;</code> p <code class="reqn">&lt;</code> (n - g), and (5) there must be at least two groups (taxa), and in each group there must be at least two objects. Violation of some of these assumptions may result in warnings or error messages (rank deficiency).
</p>
<p>Nonparametric classification method k-nearest neighbours is performed using the <code>knn</code> and <code>knn.cv</code> functions from the package <code>class</code>.
</p>
<p>The mode of crossvalidation is set by the parameter <code>crossval</code>. The default <code>"indiv"</code> uses the standard one-leave-out method. However, as some hierarchical structure is usually present in the data (individuals from a population are not completely independent observations, as they are morphologically closer to each other than to individuals from other populations), the value <code>"pop"</code> sets whole populations as leave-out units. The latter method does not allow classification if there is only one population for a taxon and is more sensitive to &ldquo;atypical&rdquo; populations, which usually leads to a somewhat lower classification success rate.
</p>
<p>The coefficients of the linear discriminant functions (above) can be directly applied to classify individuals of unknown group membership. The sums of constant and multiples of each character by the corresponding coefficient are compared among the groups. The unknown individual is classified into the group that shows the higher score. If the populations leave-out cross-validation mode is selected (<code>crossval = "pop"</code>): (1) each taxon must be represented by at least two populations; (2) coefficients of classification functions are computed as averages of coefficients retrieved after each run with one population removed.
</p>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+classifdata">classifdata</a></code> with the following elements:
</p>
<table>
<tr><td><code>ID</code></td>
<td>
<p>IDs of each row.</p>
</td></tr>
<tr><td><code>Population</code></td>
<td>
<p>population membership of each row.</p>
</td></tr>
<tr><td><code>Taxon</code></td>
<td>
<p>taxon membership of each row.</p>
</td></tr>
<tr><td><code>classif.funs</code></td>
<td>
<p>the classification functions computed for raw characters (descriptors). If <code>crossval = "pop"</code>, means of coefficients of classification functions are computed.</p>
</td></tr>
<tr><td><code>classif</code></td>
<td>
<p>classification from discriminant analysis.</p>
</td></tr>
<tr><td><code>prob</code></td>
<td>
<p>posterior probabilities of classification into each taxon (if calculated by <code><a href="#topic+classif.lda">classif.lda</a></code> or <code><a href="#topic+classif.qda">classif.qda</a></code>),
or proportion of the votes for the winning class (calculated by <code><a href="#topic+classif.knn">classif.knn</a></code>)</p>
</td></tr>
<tr><td><code>correct</code></td>
<td>
<p>logical, correctness of classification.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+classifSample.lda">classifSample.lda</a></code>,
<code><a href="#topic+classif.matrix">classif.matrix</a></code>,
<code><a href="#topic+knn.select">knn.select</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)

# remove NAs and linearly dependent characters (characters with unique contributions
#                  can be identified by stepwise discriminant analysis.)
centaurea = naMeanSubst(centaurea)
centaurea = removePopulation(centaurea, populationName = c("LIP", "PREL"))
centaurea = keepCharacter(centaurea, c("MLW", "ML", "IW", "LS", "IV", "MW", "MF",
                                    "AP", "IS", "LBA", "LW", "AL", "ILW", "LBS",
                                    "SFT", "CG", "IL", "LM", "ALW", "AW", "SF") )
# add a small constant to characters witch are invariant within taxa
centaurea$data[ centaurea$Taxon == "hybr", "LM" ][1] =
             centaurea$data[ centaurea$Taxon == "hybr", "LM" ][1] + 0.000001
centaurea$data[ centaurea$Taxon == "ph", "IV" ][1] =
             centaurea$data[ centaurea$Taxon == "ph", "IV" ][1] + 0.000001
centaurea$data[ centaurea$Taxon == "st", "LBS"][1] =
             centaurea$data[ centaurea$Taxon == "st", "LBS"][1] + 0.000001



# classification by linear discriminant function
classifRes.lda = classif.lda(centaurea, crossval = "indiv")

# classification by quadratic discriminant function
classifRes.qda = classif.qda(centaurea, crossval = "indiv")

# classification by nonparametric k-nearest neighbour method
# use knn.select to find the optimal K.
knn.select(centaurea, crossval = "pop")
classifRes.knn = classif.knn(centaurea, k = 12, crossval = "pop")

# exporting results
classif.matrix(classifRes.lda, level = "taxon")
classif.matrix(classifRes.qda, level = "taxon")
classif.matrix(classifRes.knn, level = "taxon")

</code></pre>

<hr>
<h2 id='classif.matrix'>Format the Classifdata to Summary Table</h2><span id='topic+classif.matrix'></span>

<h3>Description</h3>

<p>The <code>classif.matrix</code> method formats the results stored in <code>classifdata</code> class to a summary classification table of taxa, populations, or individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classif.matrix(result, level = "taxon")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classif.matrix_+3A_result">result</code></td>
<td>
<p>an object of class <code><a href="#topic+classifdata">classifdata</a></code>.</p>
</td></tr>
<tr><td><code id="classif.matrix_+3A_level">level</code></td>
<td>
<p>level of grouping of classification matrix, <code>"taxon"</code> (default), populations (<code>"pop"</code>), or individuals (<code>"indiv"</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>, summary classification table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)

centaurea = naMeanSubst(centaurea)
centaurea = removePopulation(centaurea, populationName = c("LIP", "PREL"))

# classification by linear discriminant function
classifRes.lda = classif.lda(centaurea, crossval = "indiv")

# exporting results
classif.matrix(classifRes.lda, level = "taxon")
classif.matrix(classifRes.lda, level = "pop")
</code></pre>

<hr>
<h2 id='classifdata'>Class classifdata</h2><span id='topic+classifdata'></span>

<h3>Description</h3>

<p>The <code>classifdata</code> class is designed for storing results of classificatory discriminant analysis.</p>


<h3>Format</h3>

<p>Class <code>classifdata</code>.
</p>

<dl>
<dt>ID</dt><dd><p>IDs of each row.</p>
</dd>
<dt>Population</dt><dd><p>population membership of each row.</p>
</dd>
<dt>Taxon</dt><dd><p>taxon membership of each row.</p>
</dd>
<dt>classif</dt><dd><p>classification from discriminant analysis.</p>
</dd>
<dt>classif.funs</dt><dd><p>the classification functions computed for raw characters (descriptors). If <code>crossval = "pop"</code>, means of coefficients of classification functions are computed.</p>
</dd>
<dt>prob</dt><dd><p>posterior probabilities of classification into each taxon (if calculated by <code><a href="#topic+classif.lda">classif.lda</a></code> or <code><a href="#topic+classif.qda">classif.qda</a></code>), or proportion of the votes for the winning class (calculated by <code><a href="#topic+classif.knn">classif.knn</a></code>)</p>
</dd>
<dt>correct</dt><dd><p>logical, correctness of classification.</p>
</dd>
</dl>


<hr>
<h2 id='classifSample.lda'>Classificatory Discriminant Analysis</h2><span id='topic+classifSample.knn'></span><span id='topic+classifSample.lda'></span><span id='topic+classifSample.qda'></span>

<h3>Description</h3>

<p>These functions compute discriminant function based on an independent training set and classify observations in sample set.
Linear discriminant function (<code>classifSample.lda</code>), quadratic discriminant function (<code>classifSample.qda</code>), or nonparametric k-nearest neighbour classification method (<code>classifSample.knn</code>) can be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classifSample.lda(sampleData, trainingData)

classifSample.qda(sampleData, trainingData)

classifSample.knn(sampleData, trainingData, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classifSample.lda_+3A_sampledata">sampleData</code></td>
<td>
<p>observations which should be classified. An object of class <code><a href="#topic+morphodata">morphodata</a></code>.</p>
</td></tr>
<tr><td><code id="classifSample.lda_+3A_trainingdata">trainingData</code></td>
<td>
<p>observations for computing discriminant function. An object of class <code><a href="#topic+morphodata">morphodata</a></code>.</p>
</td></tr>
<tr><td><code id="classifSample.lda_+3A_k">k</code></td>
<td>
<p>number of neighbours considered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>classifSample.lda</code> and <code>classifSample.qda</code> performs classification using linear and quadratic discriminant function using the <code>lda</code> and <code>qda</code> functions from the package <code>MASS</code>. Nonparametric classification method <code>classifSample.knn</code> (k-nearest neighbours) is performed using the <code>knn</code> functions from the package <code>class</code>. The <code>classifSample</code> functions are designed to classify hybrid populations, type herbarium specimens, atypical samples, entirely new data, etc. Discriminant criterion is developed from the original (training) dataset and applied to the specific sample (set).
</p>
<p>LDA and QDA analyses have some requirements: (1) no character can be a linear combination of any other character; (2) no pair of characters can be highly correlated; (3) no character can be invariant in any taxon (group); (4) for the number of taxa (g), characters (p) and total number of samples (n) should hold: 0 <code class="reqn">&lt;</code> p <code class="reqn">&lt;</code> (n - g), and (5) there must be at least two groups (taxa), and in each group there must be at least two objects. Violation of some of these assumptions may result in warnings or error messages (rank deficiency).
</p>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+classifdata">classifdata</a></code> with the following elements:
</p>
<table>
<tr><td><code>ID</code></td>
<td>
<p>IDs of each row.</p>
</td></tr>
<tr><td><code>Population</code></td>
<td>
<p>population membership of each row.</p>
</td></tr>
<tr><td><code>Taxon</code></td>
<td>
<p>taxon membership of each row.</p>
</td></tr>
<tr><td><code>classif</code></td>
<td>
<p>classification from discriminant analysis.</p>
</td></tr>
<tr><td><code>prob</code></td>
<td>
<p>posterior probabilities of classification into each taxon (if calculated by <code><a href="#topic+classif.lda">classif.lda</a></code> or <code><a href="#topic+classif.qda">classif.qda</a></code>),
or proportion of the votes for the winning class (calculated by <code><a href="#topic+classif.knn">classif.knn</a></code>)</p>
</td></tr>
<tr><td><code>correct</code></td>
<td>
<p>logical, correctness of classification.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+classif.lda">classif.lda</a></code>,
<code><a href="#topic+classif.matrix">classif.matrix</a></code>,
<code><a href="#topic+knn.select">knn.select</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)

# remove NAs and linearly dependent characters (characters with unique contributions
#                  can be identified by stepwise discriminant analysis.)
centaurea = naMeanSubst(centaurea)
centaurea = removePopulation(centaurea, populationName = c("LIP", "PREL"))
centaurea = keepCharacter(centaurea, c("MLW", "ML", "IW", "LS", "IV", "MW", "MF",
                                    "AP", "IS", "LBA", "LW", "AL", "ILW", "LBS",
                                    "SFT", "CG", "IL", "LM", "ALW", "AW", "SF") )
# add a small constant to characters witch are invariant within taxa
centaurea$data[ centaurea$Taxon == "hybr", "LM" ][1] =
             centaurea$data[ centaurea$Taxon == "hybr", "LM" ][1] + 0.000001
centaurea$data[ centaurea$Taxon == "ph", "IV" ][1] =
             centaurea$data[ centaurea$Taxon == "ph", "IV" ][1] + 0.000001
centaurea$data[ centaurea$Taxon == "st", "LBS"][1] =
             centaurea$data[ centaurea$Taxon == "st", "LBS"][1] + 0.000001


trainingSet = removePopulation(centaurea, populationName = "LES")
LES = keepPopulation(centaurea, populationName = "LES")


# classification by linear discriminant function
classifSample.lda(LES, trainingSet)

# classification by quadratic discriminant function
classifSample.qda(LES, trainingSet)

# classification by nonparametric k-nearest neighbour method
# use knn.select to find the optimal K.
knn.select(trainingSet)
classifSample.knn(LES, trainingSet, k = 12)
</code></pre>

<hr>
<h2 id='clust'>Hierarchical Clustering</h2><span id='topic+clust'></span>

<h3>Description</h3>

<p>Hierarchical cluster analysis of objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clust(object, distMethod = "Euclidean", clustMethod = "UPGMA", binaryChs = NULL,
              nominalChs = NULL, ordinalChs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clust_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+morphodata">morphodata</a></code>.</p>
</td></tr>
<tr><td><code id="clust_+3A_distmethod">distMethod</code></td>
<td>
<p>the distance measure to be used. This must be one of: <code>"Euclidean"</code> (default), <code>"Manhattan"</code>, <code>"Minkowski"</code>, <code>"Jaccard"</code>, <code>"simpleMatching"</code>, or <code>"Gower"</code>. See details.</p>
</td></tr>
<tr><td><code id="clust_+3A_clustmethod">clustMethod</code></td>
<td>
<p>the agglomeration method to be used: <code>"average"</code> (= <code>"UPGMA"</code>; default), <code>"complete"</code>, <code>"ward.D"</code> (= <code>"Ward"</code>), <code>"ward.D2"</code>, <code>"single"</code>, <code>"Mcquitty"</code> (= <code>"WPGMA"</code>), <code>"median"</code> (= <code>"WPGMC"</code>) or <code>"centroid"</code> (= <code>"UPGMC"</code>). See <code><a href="stats.html#topic+hclust">hclust</a></code> for details.</p>
</td></tr>
<tr><td><code id="clust_+3A_binarychs">binaryChs</code>, <code id="clust_+3A_nominalchs">nominalChs</code>, <code id="clust_+3A_ordinalchs">ordinalChs</code></td>
<td>
<p>names of categorical ordinal, categorical nominal (multistate), and binary characters. Needed for Gower's dissimilarity coefficient only, see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs agglomerative hierarchical clustering.
Typically, populations are used as OTUs (operational taxonomic units). Characters are standardised to a zero mean and a unit standard deviation.
</p>
<p>Various measures of distance between the observations (rows) are applicable: (1) coefficients of distance for quantitative and binary characters: <code>"Euclidean"</code>, <code>"Manhattan"</code>, <code>"Minkowski"</code>; (2) similarity coefficients for binary characters: <code>"Jaccard"</code> and simple matching (<code>"simpleMatching"</code>); (3) coefficient for mixed data: <code>"Gower"</code>.
Note that the other than default methods for clustering and distance measurement are rarely used in morphometric analyses.
</p>
<p>The Gower's dissimilarity coefficient can handle different types of variables. Characters have to be divided into four categories: (1) quantitative characters, (2) categorical ordinal characters, (3) categorical nominal (multistate) characters, and (4) binary characters. All characters are considered to be quantitative characters unless otherwise specified. Other types of characters have to be explicitly specified. To mark characters as ordinal, nominal, or binary, enumerate them by names using <code>ordinalChs</code>, <code>nominalChs</code>, and <code>binaryChs</code> arguments, respectively.
</p>


<h3>Value</h3>

<p>An object of class <code>'hclust'</code>. It encodes a stepwise dendrogram.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)

clustering.UPGMA = clust(centaurea)

plot(clustering.UPGMA, cex = 0.6, frame.plot = TRUE, hang = -1,
        main = "", sub = "", xlab = "", ylab = "distance")


# using Gower's method
data = list(
    ID = as.factor(c("id1","id2","id3","id4","id5","id6")),
    Population = as.factor(c("Pop1", "Pop1", "Pop2", "Pop2", "Pop3", "Pop3")),
    Taxon = as.factor(c("TaxA", "TaxA", "TaxA", "TaxB", "TaxB", "TaxB")),
    data = data.frame(
     stemBranching = c(1, 1, 1, 0, 0, 0),  # binaryChs
     petalColour = c(1, 1, 2, 3, 3, 3),  # nominalChs; 1=white, 2=red, 3=blue
     leaves = c(1,1,1,2,2,3), # nominalChs; 1=simple, 2=palmately compound, 3=pinnately compound
     taste = c(2, 2, 2, 3, 1, 1),   # ordinal; 1=hot, 2=hotter, 3=hottest
     stemHeight = c(10, 11, 14, 22, 23, 21),         # quantitative
     leafLength = c(8, 7.1, 9.4, 1.2, 2.3, 2.1)  )   # quantitative
)
attr(data, "class") = "morphodata"

clustering.GOWER = clust(data, distMethod = "Gower", clustMethod = "UPGMA",
                               binaryChs = c("stemBranching"),
                               nominalChs = c("petalColour", "leaves"),
                               ordinalChs = c("taste"))

plot(clustering.GOWER, cex = 0.6, frame.plot = TRUE, hang = -1,
        main = "", sub = "", xlab = "", ylab = "distance")

</code></pre>

<hr>
<h2 id='cormat'>Correlations of Characters</h2><span id='topic+cormat'></span><span id='topic+cormatSignifTest'></span>

<h3>Description</h3>

<p>The <code>cormat</code> function calculates the matrix of the correlation coefficients of the characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cormat(object, method = "Pearson")

cormatSignifTest(object, method = "Pearson", alternative = "two.sided")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cormat_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+morphodata">morphodata</a></code>.</p>
</td></tr>
<tr><td><code id="cormat_+3A_method">method</code></td>
<td>
<p>a character string indicating which correlation coefficient is to be used for the test.
One of <code>"Pearson"</code> (default), or <code>"Ppearman"</code> can be applied.</p>
</td></tr>
<tr><td><code id="cormat_+3A_alternative">alternative</code></td>
<td>
<p>indicates the alternative hypothesis and must be one of <code>"two.sided"</code> (default),
<code>"greater"</code> (positive association) or <code>"less"</code> (negative association).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns table with pairwise correlation coefficients for each pair of morphological characters. The result is formatted as a <code>data.frame</code> to allow export with the <code><a href="#topic+exportRes">exportRes</a></code> function.
</p>
<p>Significance tests are usually unnecessary for morphometric analysis. Anyway, if tests are needed, they can be computed using the <code><a href="#topic+cormatSignifTest">cormatSignifTest</a></code> function.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code>, storing correlation coefficients for each pair of morphological characters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)

correlations.p = cormat(centaurea, method = "Pearson")
correlations.s = cormat(centaurea, method = "Spearman")

## Not run: exportRes(correlations.p, file = "correlations.pearson.txt")
## Not run: exportRes(correlations.s, file = "correlations.spearman.txt")

correlations.p = cormatSignifTest(centaurea, method = "Pearson")
</code></pre>

<hr>
<h2 id='descrTaxon'>Descriptive Statistics</h2><span id='topic+descrTaxon'></span><span id='topic+descrPopulation'></span><span id='topic+descrAll'></span>

<h3>Description</h3>

<p>These functions calculate the descriptive statistics of each character in the whole dataset, each taxon and each population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>descrTaxon(object, format = NULL, decimalPlaces = 3)

descrPopulation(object, format = NULL, decimalPlaces = 3)

descrAll(object, format = NULL, decimalPlaces = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="descrTaxon_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+morphodata">morphodata</a></code>.</p>
</td></tr>
<tr><td><code id="descrTaxon_+3A_format">format</code></td>
<td>
<p>form to which will be formatted descriptive characters. See Details.</p>
</td></tr>
<tr><td><code id="descrTaxon_+3A_decimalplaces">decimalPlaces</code></td>
<td>
<p>the number of a digit to the right of a decimal point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following statistics are computed: number of observations, mean, standard deviation, and the percentiles: 0%
(minimum), 5%, 25% (lower quartile), 50% (median), 75% (upper quartile), 95% and 100% (maximum).
</p>
<p>The <code>format</code> argument brings a handy way how to receive only what is wanted and in format what is desired.
Otherways, if format remains <code>NULL</code>, output table contains all calculated descriptors.
The format argument is a single string, where keywords will be replaced by particular values.
</p>
<p>Keywords: <code>"$MEAN"</code> = mean; <code>"$SD"</code> = standard deviation; <code>"$MIN"</code> = minimum; <code>"$5%"</code> = 5th percentile;
<code>"$25%"</code> = 25th percentile (lower quartile); <code>"$MEDIAN"</code> = median (50th percentile); <code>"$75%"</code> = 75th percentile (upper quartile); <code>"$95%"</code> = 95th percentile; <code>"$MAX"</code> = maximum.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with calculated statistical descriptors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea, decimalPlaces = 3)

descrTaxon(centaurea)

descrTaxon(centaurea, format = "($MEAN ± $SD)")

descrPopulation(centaurea, format = "$MEAN ($MIN - $MAX)")

descrAll(centaurea, format = "$MEAN ± $SD ($5% - $95%)")
</code></pre>

<hr>
<h2 id='exportRes'>Export Data</h2><span id='topic+exportRes'></span>

<h3>Description</h3>

<p>This function is designed for exporting results, stored in objects of <code>MorphoTools2</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exportRes(object, file = "", dec = ".", sep = "\t",
          row.names = FALSE, col.names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exportRes_+3A_object">object</code></td>
<td>
<p>an object to be exported.</p>
</td></tr>
<tr><td><code id="exportRes_+3A_file">file</code></td>
<td>
<p>either a character string naming a file or a <code><a href="base.html#topic+connection">connection</a></code> opened for writing (e.g., <code>"clipboard"</code>). <code>""</code> indicates output to the console.</p>
</td></tr>
<tr><td><code id="exportRes_+3A_dec">dec</code></td>
<td>
<p>the character used for decimal points.</p>
</td></tr>
<tr><td><code id="exportRes_+3A_sep">sep</code></td>
<td>
<p>the column separator character.</p>
</td></tr>
<tr><td><code id="exportRes_+3A_row.names">row.names</code></td>
<td>
<p>logical, if <code>TRUE</code>, row names of the <code>object</code> are to be written.</p>
</td></tr>
<tr><td><code id="exportRes_+3A_col.names">col.names</code></td>
<td>
<p>logical, if <code>TRUE</code>, column names of the <code>object</code> are to be written.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Used for its side effect.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)

descr = descrTaxon(centaurea, format = "($MEAN ± $SD)")
## Not run: exportRes(descr, file = "centaurea_descrTax.txt")
</code></pre>

<hr>
<h2 id='head.morphodata'>Return the First or Last Parts of an Object</h2><span id='topic+head.classifdata'></span><span id='topic+tail.classifdata'></span><span id='topic+head.morphodata'></span><span id='topic+tail.morphodata'></span>

<h3>Description</h3>

<p>Returns the first or last parts of a object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'classifdata'
head(x, n = 6, ...)

## S3 method for class 'classifdata'
tail(x, n = 6, ...)

## S3 method for class 'morphodata'
head(x, n = 6, ...)

## S3 method for class 'morphodata'
tail(x, n = 6, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="head.morphodata_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+morphodata">morphodata</a></code> or <code><a href="#topic+classifdata">classifdata</a></code>.</p>
</td></tr>
<tr><td><code id="head.morphodata_+3A_n">n</code></td>
<td>
<p>number of rows to print.</p>
</td></tr>
<tr><td><code id="head.morphodata_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Object passed as parameter is formated to <code>data.frame</code>. A <code>head()</code> (<code>tail()</code>) returns the first (last) <code>n</code> rows when <code>n</code> &gt;= 0 or all but the last (first) <code>n</code> rows when <code>n</code> &lt; 0.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code>, containing the first or last <code>n</code> individuals of the passed object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)

head(centaurea)
tail(centaurea)
</code></pre>

<hr>
<h2 id='histCharacter'>Histograms of Characters</h2><span id='topic+histCharacter'></span><span id='topic+histAll'></span>

<h3>Description</h3>

<p>Histograms are produced for the level of taxa/groups, to displays a within-group distribution of each taxon for a particular character, and its deviation from the normal distribution (red line).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>histCharacter(object, character, taxon = levels(object$Taxon), histogram = TRUE,
        col = "lightgray", main = NULL, densityLine = TRUE, normDistLine = TRUE, ...)

histAll(object, folderName = "histograms", taxon = levels(object$Taxon),
		histogram = TRUE, col = "lightgray", main = NULL, densityLine = TRUE,
		normDistLine = TRUE, width = 480, height = 480, units = "px", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="histCharacter_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+morphodata">morphodata</a></code>.</p>
</td></tr>
<tr><td><code id="histCharacter_+3A_character">character</code></td>
<td>
<p>a morphological character used to plot histogram.</p>
</td></tr>
<tr><td><code id="histCharacter_+3A_foldername">folderName</code></td>
<td>
<p>folder to save produced histograms.</p>
</td></tr>
<tr><td><code id="histCharacter_+3A_col">col</code></td>
<td>
<p>colour to be used to fill the bars.</p>
</td></tr>
<tr><td><code id="histCharacter_+3A_taxon">taxon</code></td>
<td>
<p>taxa which should be plotted, default is to plot all of the taxa.</p>
</td></tr>
<tr><td><code id="histCharacter_+3A_main">main</code></td>
<td>
<p>a main title for the plot.</p>
</td></tr>
<tr><td><code id="histCharacter_+3A_histogram">histogram</code></td>
<td>
<p>logical, if <code>TRUE</code>, the histograms will be drawn.</p>
</td></tr>
<tr><td><code id="histCharacter_+3A_densityline">densityLine</code></td>
<td>
<p>logical, if <code>TRUE</code>, the density line smoothing out the histogram will be drawn.</p>
</td></tr>
<tr><td><code id="histCharacter_+3A_normdistline">normDistLine</code></td>
<td>
<p>logical, if <code>TRUE</code>, the normal distribution curve will be drawn.</p>
</td></tr>
<tr><td><code id="histCharacter_+3A_width">width</code></td>
<td>
<p>the width of the figure.</p>
</td></tr>
<tr><td><code id="histCharacter_+3A_height">height</code></td>
<td>
<p>the height of the figure.</p>
</td></tr>
<tr><td><code id="histCharacter_+3A_units">units</code></td>
<td>
<p>the units in which <code>height</code> and <code>width</code> are given. Can be <code>"px"</code> (pixels, the default), <code>"in"</code> (inches), <code>"cm"</code> or <code>"mm"</code>.</p>
</td></tr>
<tr><td><code id="histCharacter_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="graphics.html#topic+hist">hist</a></code> or graphical parameters <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Used for its side effect of producing a plot(s).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)

histCharacter(centaurea, character = "IW", breaks = seq(0.5, 2.5, 0.1))

## Not run: histAll(centaurea, folderName = "../histograms")
</code></pre>

<hr>
<h2 id='keepTaxon'>Keep Items (Taxa, Populations, Samples, Morphological Characters) in an Morphodata Object (and Remove Others)</h2><span id='topic+keepTaxon'></span><span id='topic+keepPopulation'></span><span id='topic+keepCharacter'></span><span id='topic+keepSample'></span>

<h3>Description</h3>

<p>These functions keep only selected taxa, populations, samples or morphological characters in <code>morphodata</code> object. The samples can be kept by names using <code>sampleName</code> argument, or by the threshold. Each sample holding less or equal portion of missing data than the desired threshold (<code>missingPercentage</code>) will be kept. Only one parameter can be specified in one run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keepTaxon(object, taxonName)

keepPopulation(object, populationName)

keepSample(object, sampleName = NULL, missingPercentage = NA)

keepCharacter(object, characterName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keepTaxon_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+morphodata">morphodata</a></code>.</p>
</td></tr>
<tr><td><code id="keepTaxon_+3A_taxonname">taxonName</code></td>
<td>
<p>vector of taxa to be kept.</p>
</td></tr>
<tr><td><code id="keepTaxon_+3A_populationname">populationName</code></td>
<td>
<p>vector of populations to be kept.</p>
</td></tr>
<tr><td><code id="keepTaxon_+3A_samplename">sampleName</code></td>
<td>
<p>vector of samples to be kept.</p>
</td></tr>
<tr><td><code id="keepTaxon_+3A_missingpercentage">missingPercentage</code></td>
<td>
<p>a numeric, samples holding less or equal portion of missing data than specified by <code>missingPercentage</code> will be kept.</p>
</td></tr>
<tr><td><code id="keepTaxon_+3A_charactername">characterName</code></td>
<td>
<p>vector of characters to be kept.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+morphodata">morphodata</a></code> with the following elements:
</p>
<table>
<tr><td><code>ID</code></td>
<td>
<p>IDs of each row of <code>data</code> object.</p>
</td></tr>
<tr><td><code>Population</code></td>
<td>
<p>population membership of each row of <code>data</code> object.</p>
</td></tr>
<tr><td><code>Taxon</code></td>
<td>
<p>taxon membership of each row of <code>data</code> object.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p><code>data.frame</code> of individuals (rows) and values of measured morphological characters (columns).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)

centaurea.hybr = keepTaxon(centaurea, "hybr")
centaurea.PhHybr = keepTaxon(centaurea, c("ph", "hybr"))

centaurea.PREL = keepPopulation(centaurea, "PREL")

centaurea.NA_0.1 = keepSample(centaurea, missingPercentage = 0.1)

centaurea.stem = keepCharacter(centaurea, c("SN", "SF", "ST"))
</code></pre>

<hr>
<h2 id='knn.select'>Search for the Optimal K-nearest Neighbours</h2><span id='topic+knn.select'></span>

<h3>Description</h3>

<p>This function search for the optimal number of neighbours for the given data set for k-nearest neighbour cross-validatory classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knn.select(object, crossval = "indiv")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knn.select_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+morphodata">morphodata</a></code>.</p>
</td></tr>
<tr><td><code id="knn.select_+3A_crossval">crossval</code></td>
<td>
<p>crossvalidation mode, sets individual (<code>"indiv"</code>; default, one-leave-out method) or whole populations (<code>"pop"</code>) as leave-out unit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>knn.select</code> function compute number of correctly classified individuals for k values ranging from 1 to 30 and highlight the value with the highest success rate. Ties (i.e., when there are the same numbers of votes for two or more groups) are broken at random, and thus several iterations may yield different results. Therefore, the functions compute 10 iterations, and the average success rates for each k are used; the minimum and maximum success rates for each k are also displayed as error bars. Note that several k values may have nearly the same success rates; if this is the case, the similarity of iterations may also be considered.
</p>
<p>The mode of crossvalidation is set by the parameter <code>crossval</code>. The default <code>"indiv"</code> uses the standard one-leave-out method. However, as some hierarchical structure is usually present in the data (individuals from a population are not completely independent observations, as they are morphologically closer to each other than to individuals from other populations), the value <code>"pop"</code> sets whole populations as leave-out units. The latter method does not allow classification if there is only one population for a taxon and is more sensitive to &ldquo;atypical&rdquo; populations, which usually leads to a somewhat lower classification success rate.
</p>


<h3>Value</h3>

<p>Optimal number of neighbours is written to the console, and plot displaying all Ks is produced.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+classif.lda">classif.lda</a></code>,
<code><a href="#topic+classifSample.lda">classifSample.lda</a></code>,
<code><a href="#topic+classif.qda">classif.qda</a></code>,
<code><a href="#topic+classifSample.qda">classifSample.qda</a></code>,
<code><a href="#topic+classif.knn">classif.knn</a></code>,
<code><a href="#topic+classifSample.knn">classifSample.knn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)
centaurea = naMeanSubst(centaurea)
centaurea = removePopulation(centaurea, populationName = c("LIP", "PREL"))

# classification by nonparametric k-nearest neighbour method
knn.select(centaurea, crossval = "indiv")
classifRes.knn = classif.knn(centaurea, k = 12, crossval = "indiv")
</code></pre>

<hr>
<h2 id='missingCharactersTable'>Summarize Missing Data</h2><span id='topic+missingCharactersTable'></span>

<h3>Description</h3>

<p>Summarize percentage and number of missing values on the desired grouping level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missingCharactersTable(object, level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missingCharactersTable_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+morphodata">morphodata</a></code>.</p>
</td></tr>
<tr><td><code id="missingCharactersTable_+3A_level">level</code></td>
<td>
<p>level of grouping, one of the following: <code>"taxon"</code>, populations (<code>"pop"</code>), or individuals (<code>"indiv"</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> summarizing a number of missing values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)

missingCharactersTable(centaurea, level = "pop")
</code></pre>

<hr>
<h2 id='missingSamplesTable'>Summarize Missing Data</h2><span id='topic+missingSamplesTable'></span>

<h3>Description</h3>

<p>Summarize number of missing values for each character on the desired grouping level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missingSamplesTable(object, level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missingSamplesTable_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+morphodata">morphodata</a></code>.</p>
</td></tr>
<tr><td><code id="missingSamplesTable_+3A_level">level</code></td>
<td>
<p>level of grouping, one of the following: <code>"taxon"</code>, populations (<code>"pop"</code>), or individuals (<code>"indiv"</code>.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> summarizing a number of missing values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)

missingSamplesTable(centaurea, level = "pop")
</code></pre>

<hr>
<h2 id='morphodata'>Class morphodata</h2><span id='topic+morphodata'></span>

<h3>Description</h3>

<p>The <code>morphodata</code> class is designed for storing morphological data of individuals, their IDs and it's appertaining to population and taxon.
</p>


<h3>Format</h3>

<p>Class <code>morphodata</code>.
</p>

<dl>
<dt>ID</dt><dd><p>IDs of each row of <code>data</code> object.</p>
</dd>
<dt>Population</dt><dd><p>population membership of each row of <code>data</code> object.</p>
</dd>
<dt>Taxon</dt><dd><p>taxon membership of each row of <code>data</code> object.</p>
</dd>
<dt>data</dt><dd><p><code>data.frame</code> of individuals (rows) and values of measured morphological characters (columns).</p>
</dd>
</dl>


<hr>
<h2 id='naMeanSubst'>Replace Missing Data by Population Average</h2><span id='topic+naMeanSubst'></span>

<h3>Description</h3>

<p>This function substitutes missing data using the average value of the respective character in the respective population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>naMeanSubst(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="naMeanSubst_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+morphodata">morphodata</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generally, most of the multivariate analyses require a full data matrix.
The preferred approach is to reduce the data set to complete observations only (i.e., perform the casewise deletion of
missing data) or to remove characters for which there are missing values.
The use of mean substitution, which introduces values that are not present in the original data, is justified only if
(1) there are relatively few missing values, (2) these missing values are scattered throughout many characters
(each character includes only a few missing values) and (3) removing all individuals or all characters
with missing data would unacceptably reduce the data set.
</p>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+morphodata">morphodata</a></code> with the following elements:
</p>
<table>
<tr><td><code>ID</code></td>
<td>
<p>IDs of each row of <code>data</code> object.</p>
</td></tr>
<tr><td><code>Population</code></td>
<td>
<p>population membership of each row of <code>data</code> object.</p>
</td></tr>
<tr><td><code>Taxon</code></td>
<td>
<p>taxon membership of each row of <code>data</code> object.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p><code>data.frame</code> of individuals (rows) and values of measured morphological characters (columns).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)

centaurea = naMeanSubst(centaurea)
</code></pre>

<hr>
<h2 id='nmds.calc'>Non-metric Multidimensional Scaling (NMDS)</h2><span id='topic+nmds.calc'></span>

<h3>Description</h3>

<p>This function performs Non-metric multidimensional scaling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nmds.calc(object, distMethod = "Euclidean", k = 3, binaryChs = NULL,
                    nominalChs = NULL, ordinalChs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmds.calc_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+morphodata">morphodata</a></code>.</p>
</td></tr>
<tr><td><code id="nmds.calc_+3A_distmethod">distMethod</code></td>
<td>
<p>the distance measure to be used. This must be one of: <code>"Euclidean"</code>, <code>"Manhattan"</code>, <code>"Minkowski"</code>, <code>"Jaccard"</code>, <code>"simpleMatching"</code>, or <code>"Gower"</code>. See details.</p>
</td></tr>
<tr><td><code id="nmds.calc_+3A_k">k</code></td>
<td>
<p>number of dimensions.</p>
</td></tr>
<tr><td><code id="nmds.calc_+3A_binarychs">binaryChs</code>, <code id="nmds.calc_+3A_nominalchs">nominalChs</code>, <code id="nmds.calc_+3A_ordinalchs">ordinalChs</code></td>
<td>
<p>names of categorical ordinal, categorical nominal (multistate), and binary characters. Needed for Gower's dissimilarity coefficient only, see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>nmds.calc</code> function performs non-metric multidimensional scaling using the <code><a href="vegan.html#topic+monoMDS">monoMDS</a></code> function from package <code><a href="vegan.html#topic+vegan">vegan</a></code>.
The main threat of NMDS is, that this method doesn't preserve distances among objects in the original character space and approximates only the order of the dissimilarities among objects, based on any coefficient of similarity or distance.
</p>
<p>Further, multiple runs of the NMDS analysis are needed to ensure that the stable ordination has been reached, as anyone run may get &ldquo;trapped&rdquo; in local optima which are not representative of true similarities.
</p>
<p>The <code>stress</code> value reflects how well the ordination summarizes the observed relationship among the samples. A rule of thumb, 0.1-0.2 is considered fairly good, but there is no general rule since the stress is greatly influenced by the number of points. Since stress decreases as dimensionality increases, the optimal solution is when the decrease in stress is small after decreasing the number of dimensions.
</p>
<p>Various measures of distance between the observations (rows) are applicable: (1) coefficients of distance for quantitative and binary characters: <code>"Euclidean"</code>, <code>"Manhattan"</code>, <code>"Minkowski"</code>; (2) similarity coefficients for binary characters: <code>"Jaccard"</code> and simple matching (<code>"simpleMatching"</code>); (3) coefficient for mixed data: (<code>"Gower"</code>).
</p>
<p>The Gower's dissimilarity coefficient can handle different types of variables. Characters have to be divided into four categories: (1) quantitative characters, (2) categorical ordinal characters, (3) categorical nominal (multistate) characters, and (4) binary characters. All characters are considered to be quantitative characters unless otherwise specified. Other types of characters have to be explicitly specified. To mark characters as ordinal, nominal, or binary, enumerate them by names using <code>ordinalChs</code>, <code>nominalChs</code>, and <code>binaryChs</code> arguments, respectively.
</p>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+nmdsdata">nmdsdata</a></code> with the following elements:
</p>
<table>
<tr><td><code>objects</code></td>
<td>
</td></tr>
</table>

<table>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: right;"> <code>ID</code> </td><td style="text-align: left;"> IDs of each row of <code>scores</code> object. </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: right;"> <code>Population</code> </td><td style="text-align: left;"> population membership of each row of <code>scores</code> object. </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: right;"> <code>Taxon</code> </td><td style="text-align: left;"> taxon membership of each row of <code>scores</code> object. </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: right;"> <code>scores</code> </td><td style="text-align: left;"> ordination scores of cases (objects, OTUs). </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<table>
<tr><td><code>stress</code></td>
<td>
<p>stress value, e.i., goodness of fit.</p>
</td></tr>
<tr><td><code>groupMeans</code></td>
<td>
<p><code>data.frame</code> containing the means for the taxa.</p>
</td></tr>
<tr><td><code>distMethod</code></td>
<td>
<p>used distance measure.</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>number of possitive eigenvalues.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)

nmdsRes = nmds.calc(centaurea, distMethod = "Euclidean", k = 3)

summary(nmdsRes)

plotPoints(nmdsRes, axes = c(1,2), col = c("red", "green", "blue", "black"),
  pch = c(20,17,8,21), pt.bg = "orange", legend = TRUE, legend.pos = "bottomright")

# using Gower's method
data = list(
    ID = as.factor(c("id1","id2","id3","id4","id5","id6")),
    Population = as.factor(c("Pop1", "Pop1", "Pop2", "Pop2", "Pop3", "Pop3")),
    Taxon = as.factor(c("TaxA", "TaxA", "TaxA", "TaxB", "TaxB", "TaxB")),
    data = data.frame(
     stemBranching = c(1, 1, 1, 0, 0, 0),  # binaryChs
     petalColour = c(1, 1, 2, 3, 3, 3),  # nominalChs; 1=white, 2=red, 3=blue
     leaves = c(1,1,1,2,2,3), # nominalChs; 1=simple, 2=palmately compound, 3=pinnately compound
     taste = c(2, 2, 2, 3, 1, 1),   # ordinal; 1=hot, 2=hotter, 3=hottest
     stemHeight = c(10, 11, 14, 22, 23, 21),         # quantitative
     leafLength = c(8, 7.1, 9.4, 1.2, 2.3, 2.1)  )   # quantitative
)
attr(data, "class") = "morphodata"

nmdsGower = nmds.calc(data, distMethod = "Gower", k = 2, binaryChs = c("stemBranching"),
                      nominalChs = c("petalColour", "leaves"), ordinalChs = c("taste"))

plotPoints(nmdsGower, axes = c(1,2), col = c("red","green"),
           pch = c(20,17), pt.bg = "orange", legend = TRUE, legend.pos = "bottomright")
</code></pre>

<hr>
<h2 id='nmdsdata'>Class nmdsdata</h2><span id='topic+nmdsdata'></span>

<h3>Description</h3>

<p>The <code>nmdsdata</code> class is designed for storing results of non-metric multidimensional scaling (NMDS).</p>


<h3>Format</h3>

<p>Class <code>nmdsdata</code>.
</p>

<dl>
<dt>objects</dt><dd>

<dl>
<dt>ID</dt><dd><p>IDs of each row of <code>scores</code> object.</p>
</dd>
<dt>Population</dt><dd><p>population membership of each row of <code>scores</code> object.</p>
</dd>
<dt>Taxon</dt><dd><p>taxon membership of each row of <code>scores</code> object.</p>
</dd>
<dt>scores</dt><dd><p>ordination scores of cases (objects, OTUs).</p>
</dd>
</dl>

</dd>
<dt>stress</dt><dd><p>stress value, e.i., goodness of fit.</p>
</dd>
<dt>groupMeans</dt><dd><p><code>data.frame</code> containing the means for the taxa.</p>
</dd>
<dt>distMethod</dt><dd><p>used distance measure.</p>
</dd>
<dt>rank</dt><dd><p>number of possitive eigenvalues.</p>
</dd>
</dl>


<hr>
<h2 id='pca.calc'>Principal Component Analysis</h2><span id='topic+pca.calc'></span>

<h3>Description</h3>

<p>This function performs principal component analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pca.calc(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pca.calc_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+morphodata">morphodata</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>pca.calc</code> function performs an R type principal component analysis using the R base <code><a href="stats.html#topic+princomp">princomp</a></code> function. Principal component analysis is a variable reduction procedure. It reduces original variables into a smaller number of principal components (artificial variables) that will account for most of the variance in the observed variables.
</p>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+pcadata">pcadata</a></code> with the following elements:
</p>
<table>
<tr><td><code>objects</code></td>
<td>
</td></tr>
</table>

<table>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: right;"> <code>ID</code> </td><td style="text-align: left;"> IDs of each row of <code>scores</code> object. </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: right;"> <code>Population</code> </td><td style="text-align: left;"> population membership of each row of <code>scores</code> object. </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: right;"> <code>Taxon</code> </td><td style="text-align: left;"> taxon membership of each row of <code>scores</code> object. </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: right;"> <code>scores</code> </td><td style="text-align: left;"> ordination scores of cases (objects, OTUs). </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<table>
<tr><td><code>eigenVectors</code></td>
<td>
<p>matrix of eigenvectors (i.e., a matrix of characters loadings).</p>
</td></tr>
<tr><td><code>eigenValues</code></td>
<td>
<p>eigenvalues of principal components, i.e., proportion of variation of the original dataset expressed by individual axes.</p>
</td></tr>
<tr><td><code>eigenvaluesAsPercent</code></td>
<td>
<p>eigenvalues as percent, percentage of their total sum. </p>
</td></tr>
<tr><td><code>cumulativePercentageOfEigenvalues</code></td>
<td>
<p>cumulative percentage of eigenvalues. </p>
</td></tr>
<tr><td><code>groupMeans</code></td>
<td>
<p><code>data.frame</code> containing the means for the taxa.</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>number of principal components.</p>
</td></tr>
<tr><td><code>center</code>, <code>scale</code></td>
<td>
<p>the centring and scaling of the input data.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)
centaurea = naMeanSubst(centaurea)
centaurea = removePopulation(centaurea, populationName = c("LIP", "PREL"))

pcaRes = pca.calc(centaurea)

summary(pcaRes)

plotPoints(pcaRes, axes = c(1,2), col = c("red", "green", "blue", "black"),
  pch = c(20,17,8,21), pt.bg = "orange", legend = TRUE, legend.pos = "bottomright")
</code></pre>

<hr>
<h2 id='pcadata'>Class pcadata</h2><span id='topic+pcadata'></span>

<h3>Description</h3>

<p>The <code>pcadata</code> class is designed for storing results of principal component analysis (PCA).
</p>


<h3>Format</h3>

<p>Class <code>pcadata</code>.
</p>

<dl>
<dt>objects</dt><dd>

<dl>
<dt>ID</dt><dd><p>IDs of each row of <code>scores</code> object.</p>
</dd>
<dt>Population</dt><dd><p>population membership of each row of <code>scores</code> object.</p>
</dd>
<dt>Taxon</dt><dd><p>taxon membership of each row of <code>scores</code> object.</p>
</dd>
<dt>scores</dt><dd><p>ordination scores of cases (objects, OTUs).</p>
</dd>
</dl>

</dd>
<dt>eigenVectors</dt><dd><p>matrix of eigenvectors (i.e., a matrix of characters loadings).</p>
</dd>
<dt>eigenValues</dt><dd><p>eigenvalues of principal components, i.e., proportion of variation of the original dataset expressed by individual axes.</p>
</dd>
<dt>eigenvaluesAsPercent</dt><dd><p>eigenvalues as percent, percentage of their total sum. </p>
</dd>
<dt>cumulativePercentageOfEigenvalues</dt><dd><p>cumulative percentage of eigenvalues. </p>
</dd>
<dt>groupMeans</dt><dd><p><code>data.frame</code> containing the means for the taxa.</p>
</dd>
<dt>rank</dt><dd><p>number of principal components.</p>
</dd>
<dt>center, scale</dt><dd><p>the centring and scaling of the input data.</p>
</dd>
</dl>


<hr>
<h2 id='pcoa.calc'>Principal Coordinates Analysis (PCoA)</h2><span id='topic+pcoa.calc'></span>

<h3>Description</h3>

<p>This function performs principal coordinates analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcoa.calc(object, distMethod = "Euclidean", binaryChs = NULL,
               nominalChs = NULL, ordinalChs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcoa.calc_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+morphodata">morphodata</a></code>.</p>
</td></tr>
<tr><td><code id="pcoa.calc_+3A_distmethod">distMethod</code></td>
<td>
<p>the distance measure to be used. This must be one of: <code>"Euclidean"</code>, <code>"Manhattan"</code>, <code>"Minkowski"</code>, <code>"Jaccard"</code>, <code>"simpleMatching"</code>, or <code>"Gower"</code>. See details.</p>
</td></tr>
<tr><td><code id="pcoa.calc_+3A_binarychs">binaryChs</code>, <code id="pcoa.calc_+3A_nominalchs">nominalChs</code>, <code id="pcoa.calc_+3A_ordinalchs">ordinalChs</code></td>
<td>
<p>names of categorical ordinal, categorical nominal (multistate), and binary characters. Needed for Gower's dissimilarity coefficient only, see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>pcoa.calc</code> function performs principal coordinates analysis using the <code><a href="stats.html#topic+cmdscale">cmdscale</a></code> function from package <code><a href="stats.html#topic+stats">stats</a></code>.
Principal coordinates analysis estimates coordinates for a set of objects in a space. Distances among objects is approximationy of the dissimilarities, based on any similarity or distance coefficient.
</p>
<p>Various measures of distance between the observations (rows) are applicable: (1) coefficients of distance for quantitative and binary characters: <code>"Euclidean"</code>, <code>"Manhattan"</code>, <code>"Minkowski"</code>; (2) similarity coefficients for binary characters: <code>"Jaccard"</code> and simple matching (<code>"simpleMatching"</code>); (3) coefficient for mixed data: (<code>"Gower"</code>).
</p>
<p>The Gower's dissimilarity coefficient can handle different types of variables. Characters have to be divided into four categories: (1) quantitative characters, (2) categorical ordinal characters, (3) categorical nominal (multistate) characters, and (4) binary characters. All characters are considered to be quantitative characters unless otherwise specified. Other types of characters have to be explicitly specified. To mark characters as ordinal, nominal, or binary, enumerate them by names using <code>ordinalChs</code>, <code>nominalChs</code>, and <code>binaryChs</code> arguments, respectively.
</p>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+pcoadata">pcoadata</a></code> with the following elements:
</p>
<table>
<tr><td><code>objects</code></td>
<td>
</td></tr>
</table>

<table>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: right;"> <code>ID</code> </td><td style="text-align: left;"> IDs of each row of <code>scores</code> object. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: right;"> <code>Population</code> </td><td style="text-align: left;"> population membership of each row of <code>scores</code> object. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: right;"> <code>Taxon</code> </td><td style="text-align: left;"> taxon membership of each row of <code>scores</code> object. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: right;"> <code>scores</code> </td><td style="text-align: left;"> ordination scores of cases (objects, OTUs). </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<table>
<tr><td><code>eigenValues</code></td>
<td>
<p>eigenvalues of principal coordinates.</p>
</td></tr>
<tr><td><code>eigenvaluesAsPercent</code></td>
<td>
<p>eigenvalues as percent, percentage of their total sum. </p>
</td></tr>
<tr><td><code>cumulativePercentageOfEigenvalues</code></td>
<td>
<p>cumulative percentage of eigenvalues. </p>
</td></tr>
<tr><td><code>groupMeans</code></td>
<td>
<p><code>data.frame</code> containing the means for the taxa.</p>
</td></tr>
<tr><td><code>distMethod</code></td>
<td>
<p>used distance measure.</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>number of possitive eigenvalues.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)

pcoRes = pcoa.calc(centaurea, distMethod = "Manhattan")

summary(pcoRes)

plotPoints(pcoRes, axes = c(1,2), col = c("red", "green", "blue", "black"),
  pch = c(20,17,8,21), pt.bg = "orange", legend = TRUE, legend.pos = "bottomright")

# using Gower's method
data = list(
    ID = as.factor(c("id1","id2","id3","id4","id5","id6")),
    Population = as.factor(c("Pop1", "Pop1", "Pop2", "Pop2", "Pop3", "Pop3")),
    Taxon = as.factor(c("TaxA", "TaxA", "TaxA", "TaxB", "TaxB", "TaxB")),
    data = data.frame(
     stemBranching = c(1, 1, 1, 0, 0, 0),  # binaryChs
     petalColour = c(1, 1, 2, 3, 3, 3),  # nominalChs; 1=white, 2=red, 3=blue
     leaves = c(1,1,1,2,2,3), # nominalChs; 1=simple, 2=palmately compound, 3=pinnately compound
     taste = c(2, 2, 2, 3, 1, 1),   # ordinal; 1=hot, 2=hotter, 3=hottest
     stemHeight = c(10, 11, 14, 22, 23, 21),         # quantitative
     leafLength = c(8, 7.1, 9.4, 1.2, 2.3, 2.1)  )   # quantitative
)
attr(data, "class") = "morphodata"

pcoaGower = pcoa.calc(data, distMethod = "Gower", binaryChs = c("stemBranching"),
                      nominalChs = c("petalColour", "leaves"), ordinalChs = c("taste"))

plotPoints(pcoaGower, axes = c(1,2), col = c("red","green"),
           pch = c(20,17), pt.bg = "orange", legend = TRUE, legend.pos = "bottomright")
</code></pre>

<hr>
<h2 id='pcoadata'>Class pcoadata</h2><span id='topic+pcoadata'></span>

<h3>Description</h3>

<p>The <code>pcoadata</code> class is designed for storing results of principal coordinates analysis (PCoA).</p>


<h3>Format</h3>

<p>Class <code>pcoadata</code>.
</p>

<dl>
<dt>objects</dt><dd>

<dl>
<dt>ID</dt><dd><p>IDs of each row of <code>scores</code> object.</p>
</dd>
<dt>Population</dt><dd><p>population membership of each row of <code>scores</code> object.</p>
</dd>
<dt>Taxon</dt><dd><p>taxon membership of each row of <code>scores</code> object.</p>
</dd>
<dt>scores</dt><dd><p>ordination scores of cases (objects, OTUs).</p>
</dd>
</dl>

</dd>
<dt>eigenValues</dt><dd><p>eigenvalues of principal coordinates.</p>
</dd>
<dt>eigenvaluesAsPercent</dt><dd><p>eigenvalues as percent, percentage of their total sum. </p>
</dd>
<dt>cumulativePercentageOfEigenvalues</dt><dd><p>cumulative percentage of eigenvalues. </p>
</dd>
<dt>groupMeans</dt><dd><p><code>data.frame</code> containing the means for the taxa.</p>
</dd>
<dt>distMethod</dt><dd><p>used distance measure.</p>
</dd>
<dt>rank</dt><dd><p>number of possitive eigenvalues.</p>
</dd>
</dl>


<hr>
<h2 id='plot3Dpoints'>The Default Scatterplot 3D Function</h2><span id='topic+plot3Dpoints'></span>

<h3>Description</h3>

<p>A generic function for plotting ordination scores stored in <code><a href="#topic+pcadata">pcadata</a></code>, <code><a href="#topic+pcoadata">pcoadata</a></code>, <code><a href="#topic+nmdsdata">nmdsdata</a></code>, and <code><a href="#topic+cdadata">cdadata</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot3Dpoints(result, axes = c(1,2,3), xlab = NULL, ylab = NULL, zlab = NULL,
  pch = 16, col = "black", pt.bg = "white", phi = 10, theta = 2,
  ticktype = "detailed", bty = "u", type = "p", labels = FALSE,
 legend = FALSE, legend.pos = "topright", ncol = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3Dpoints_+3A_result">result</code></td>
<td>
<p>an object of class <code><a href="#topic+pcadata">pcadata</a></code>, <code><a href="#topic+pcoadata">pcoadata</a></code>, <code><a href="#topic+nmdsdata">nmdsdata</a></code>, or <code><a href="#topic+cdadata">cdadata</a></code>.</p>
</td></tr>
<tr><td><code id="plot3Dpoints_+3A_axes">axes</code></td>
<td>
<p>x, y, z axes of plot.</p>
</td></tr>
<tr><td><code id="plot3Dpoints_+3A_xlab">xlab</code>, <code id="plot3Dpoints_+3A_ylab">ylab</code>, <code id="plot3Dpoints_+3A_zlab">zlab</code></td>
<td>
<p>a title of the respective axes.</p>
</td></tr>
<tr><td><code id="plot3Dpoints_+3A_pch">pch</code></td>
<td>
<p>a vector of plotting characters or symbols, see <code><a href="graphics.html#topic+points">points</a></code>.</p>
</td></tr>
<tr><td><code id="plot3Dpoints_+3A_col">col</code></td>
<td>
<p>the colours for points. Multiple colours can be specified so that each taxon can be given its own colour. If there are fewer colours than taxa, they are recycled in the standard fashion.</p>
</td></tr>
<tr><td><code id="plot3Dpoints_+3A_pt.bg">pt.bg</code></td>
<td>
<p>the background colours for points. Multiple colours can be specified, as above.</p>
</td></tr>
<tr><td><code id="plot3Dpoints_+3A_theta">theta</code>, <code id="plot3Dpoints_+3A_phi">phi</code></td>
<td>
<p>the angles defining the viewing direction. <code>Theta</code> gives the azimuthal direction and <code>phi</code> the colatitude, see <code><a href="graphics.html#topic+persp">persp</a></code>.</p>
</td></tr>
<tr><td><code id="plot3Dpoints_+3A_ticktype">ticktype</code></td>
<td>
<p>character: <code>"simple"</code> draws just an arrow parallel to the axis to indicate direction of increase; <code>"detailed"</code> draws normal ticks as per 2D plots.</p>
</td></tr>
<tr><td><code id="plot3Dpoints_+3A_bty">bty</code></td>
<td>
<p>the type of the box. One of <code>"g", "b2", "bl", "f", "u"</code> can be specified.</p>
</td></tr>
<tr><td><code id="plot3Dpoints_+3A_type">type</code></td>
<td>
<p>the type of plot points, <code>"p"</code> for points, or <code>"h"</code> for vertical spikes.</p>
</td></tr>
<tr><td><code id="plot3Dpoints_+3A_labels">labels</code></td>
<td>
<p>logical, if <code>TRUE</code>, point's labels are displayed.</p>
</td></tr>
<tr><td><code id="plot3Dpoints_+3A_legend">legend</code></td>
<td>
<p>logical, if <code>TRUE</code>, legend is displayed. Only restricted number of legend parameters are supported. For more precise legend plotting, use <code><a href="#topic+plotAddLegend">plotAddLegend</a></code> directly.</p>
</td></tr>
<tr><td><code id="plot3Dpoints_+3A_legend.pos">legend.pos</code></td>
<td>
<p>a single keyword from the list <code>"bottomright"</code>, <code>"bottom"</code>, <code>"bottomleft"</code>, <code>"left"</code>, <code>"topleft"</code>, <code>"top"</code>, <code>"topright"</code>, <code>"right"</code>, and <code>"center"</code>, to be used to position the legend.</p>
</td></tr>
<tr><td><code id="plot3Dpoints_+3A_ncol">ncol</code></td>
<td>
<p>the number of columns in which to set the legend items.</p>
</td></tr>
<tr><td><code id="plot3Dpoints_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="plot3D.html#topic+plot3D">plot3D</a></code>, <code><a href="graphics.html#topic+persp">persp</a></code>, <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Used for its side effect of producing a plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)
centaurea = naMeanSubst(centaurea)
centaurea = removePopulation(centaurea, populationName = c("LIP", "PREL"))

pcaRes = pca.calc(centaurea)

plot3Dpoints(pcaRes, col = c("red", "green", "blue", "black"), pch = c(20,17,8,21),
                 pt.bg = "orange")
</code></pre>

<hr>
<h2 id='plotAddEllipses'>Add Prediction Ellipses to a Plot</h2><span id='topic+plotAddEllipses'></span>

<h3>Description</h3>

<p>This function draws prediction ellipses around taxa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotAddEllipses(result, axes = c(1,2), probability = 0.95, col = "black",
                  type = "l", lty = 1, lwd = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotAddEllipses_+3A_result">result</code></td>
<td>
<p>result of <code><a href="#topic+pca.calc">pca.calc</a></code>, <code><a href="#topic+pcoa.calc">pcoa.calc</a></code>, <code><a href="#topic+nmds.calc">nmds.calc</a></code>, or <code><a href="#topic+cda.calc">cda.calc</a></code>, has to by plotted at first.</p>
</td></tr>
<tr><td><code id="plotAddEllipses_+3A_axes">axes</code></td>
<td>
<p>x, y axes of plot.</p>
</td></tr>
<tr><td><code id="plotAddEllipses_+3A_probability">probability</code></td>
<td>
<p>probability, that a new independent observation from the same population will fall in that ellipse.</p>
</td></tr>
<tr><td><code id="plotAddEllipses_+3A_col">col</code></td>
<td>
<p>the colours for labels.</p>
</td></tr>
<tr><td><code id="plotAddEllipses_+3A_type">type</code></td>
<td>
<p>character indicating the type of plotting, for details, see <code><a href="graphics.html#topic+plot">plot</a></code>: <code>"p"</code> for points, <code>"l"</code> for lines, <code>"b"</code> for both points and lines, <code>"c"</code> for empty points joined by lines, <code>"o"</code> for overplotted points and lines, <code>"s"</code> and <code>"S"</code> for stair steps and <code>"h"</code> for histogram-like vertical lines.</p>
</td></tr>
<tr><td><code id="plotAddEllipses_+3A_lty">lty</code></td>
<td>
<p>the line type. Line types can either be specified as one of following types: <code>0</code>=blank, <code>1</code>=solid (default), <code>2</code>=dashed, <code>3</code>=dotted, <code>4</code>=dotdash, <code>5</code>=longdash, <code>6</code>=twodash.</p>
</td></tr>
<tr><td><code id="plotAddEllipses_+3A_lwd">lwd</code></td>
<td>
<p>the line width.</p>
</td></tr>
<tr><td><code id="plotAddEllipses_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="graphics.html#topic+lines">lines</a></code> or other graphical parameters in <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prediction ellipses with given <code>probability</code> define the regions where will fall any new independent observation from the respective taxa. The prediction ellipses are quantified using covariance matrices of taxa scores and chi-squared distribution with two degrees of freedom (Friendly et al. 2013).
</p>


<h3>Value</h3>

<p>None. Used for its side effect of adding elements to a plot.
</p>


<h3>References</h3>

<p><strong>Friendly M., Monette G., Fox J. (2013)</strong>. Elliptical insights: understanding statistical methods through elliptical geometry. <em>Statistical Science</em> 28, 1-39.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)
centaurea = naMeanSubst(centaurea)
centaurea = removePopulation(centaurea, populationName = c("LIP", "PREL"))

pcaRes = pca.calc(centaurea)

plotPoints(pcaRes, col = c(rgb(255, 0, 0, max = 255, alpha = 150), # red
                           rgb(0, 255, 0, max = 255, alpha = 150), # green
                           rgb(0, 0, 255, max = 255, alpha = 150), # blue
                           rgb(0, 0, 0, max = 255, alpha = 150)), # black
            legend = FALSE, xlim = c(-5, 7.5), ylim = c(-5, 5.5))

plotAddLegend(pcaRes, col = c("red", "green", "blue", "black"), ncol = 2)

plotAddEllipses(pcaRes, col = c("red", "green", "blue", "black"), lwd = 3)
</code></pre>

<hr>
<h2 id='plotAddLabels.characters'>Add Labels to a Plot</h2><span id='topic+plotAddLabels.characters'></span>

<h3>Description</h3>

<p>This is a generic function for drawing labels to the character arrows of <code><a href="#topic+pcadata">pcadata</a></code> and <code><a href="#topic+cdadata">cdadata</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotAddLabels.characters(result, labels = characters(result), include = TRUE,
      axes = c(1,2), pos = NULL, offset = 0.5, cex = 0.7, col = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotAddLabels.characters_+3A_result">result</code></td>
<td>
<p>an object of class <code><a href="#topic+pcadata">pcadata</a></code> or <code><a href="#topic+cdadata">cdadata</a></code>.</p>
</td></tr>
<tr><td><code id="plotAddLabels.characters_+3A_labels">labels</code></td>
<td>
<p>a vector of label names, which should be included / excluded from plotting, see <code>include</code>.</p>
</td></tr>
<tr><td><code id="plotAddLabels.characters_+3A_include">include</code></td>
<td>
<p>logical, specify if labels in <code>labels</code> argument should be plotted or excluded from plotting.</p>
</td></tr>
<tr><td><code id="plotAddLabels.characters_+3A_axes">axes</code></td>
<td>
<p>x, y axes of plot.</p>
</td></tr>
<tr><td><code id="plotAddLabels.characters_+3A_pos">pos</code></td>
<td>
<p>a position specifier for the text. Values of 1, 2, 3 and 4, respectively indicate positions below, to the left of, above and to the right of the point.</p>
</td></tr>
<tr><td><code id="plotAddLabels.characters_+3A_offset">offset</code></td>
<td>
<p>when pos is specified, this value controls the distance (offset) of the text label from the point in fractions of a character width.</p>
</td></tr>
<tr><td><code id="plotAddLabels.characters_+3A_cex">cex</code></td>
<td>
<p>character expansion factor for text.</p>
</td></tr>
<tr><td><code id="plotAddLabels.characters_+3A_col">col</code></td>
<td>
<p>the colours for labels.</p>
</td></tr>
<tr><td><code id="plotAddLabels.characters_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="graphics.html#topic+text">text</a></code> or other graphical parameters in <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Used for its side effect of adding elements to a plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)
centaurea = naMeanSubst(centaurea)
centaurea = removePopulation(centaurea, populationName = c("LIP", "PREL"))


pcaRes = pca.calc(centaurea)

plotCharacters(pcaRes, labels = FALSE)
plotAddLabels.characters(pcaRes, labels = c("MW", "IW", "SFT", "SF", "LW"), pos = 2, cex = 1)
plotAddLabels.characters(pcaRes, labels = c("LLW", "ILW", "LBA"), pos = 4, cex = 1)
plotAddLabels.characters(pcaRes, labels = c("ML", "IV", "MLW"), pos = 1, cex = 1)
</code></pre>

<hr>
<h2 id='plotAddLabels.points'>Add Labels to a Plot</h2><span id='topic+plotAddLabels.points'></span>

<h3>Description</h3>

<p>This is a generic function for drawing labels to the data points of <code><a href="#topic+pcadata">pcadata</a></code>, <code><a href="#topic+pcoadata">pcoadata</a></code>, <code><a href="#topic+nmdsdata">nmdsdata</a></code>, and <code><a href="#topic+cdadata">cdadata</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotAddLabels.points(result, labels = result$objects$ID, include = TRUE,
      axes = c(1,2), pos = NULL, offset = 0.5, cex = 1, col = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotAddLabels.points_+3A_result">result</code></td>
<td>
<p>result of <code><a href="#topic+pca.calc">pca.calc</a></code>, <code><a href="#topic+pcoa.calc">pcoa.calc</a></code>, <code><a href="#topic+nmds.calc">nmds.calc</a></code>, or <code><a href="#topic+cda.calc">cda.calc</a></code>, has to by plotted at first.</p>
</td></tr>
<tr><td><code id="plotAddLabels.points_+3A_labels">labels</code></td>
<td>
<p>a vector of label names, which should be included / excluded from plotting, see <code>include</code>.</p>
</td></tr>
<tr><td><code id="plotAddLabels.points_+3A_include">include</code></td>
<td>
<p>logical, specify if labels in <code>labels</code> argument should be plotted or excluded from plotting.</p>
</td></tr>
<tr><td><code id="plotAddLabels.points_+3A_axes">axes</code></td>
<td>
<p>x, y axes of plot.</p>
</td></tr>
<tr><td><code id="plotAddLabels.points_+3A_pos">pos</code></td>
<td>
<p>a position specifier for the text. Values of 1, 2, 3 and 4, respectively indicate positions below, to the left of, above and to the right of the point.</p>
</td></tr>
<tr><td><code id="plotAddLabels.points_+3A_offset">offset</code></td>
<td>
<p>when <code>pos</code> is specified, this value controls the distance (offset) of the text label from the point in fractions of a character width.</p>
</td></tr>
<tr><td><code id="plotAddLabels.points_+3A_cex">cex</code></td>
<td>
<p>character expansion factor for text.</p>
</td></tr>
<tr><td><code id="plotAddLabels.points_+3A_col">col</code></td>
<td>
<p>the colours for labels.</p>
</td></tr>
<tr><td><code id="plotAddLabels.points_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="graphics.html#topic+text">text</a></code> or other graphical parameters in <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Used for its side effect of adding elements to a plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)
centaurea = naMeanSubst(centaurea)
centaurea = removePopulation(centaurea, populationName = c("LIP", "PREL"))
pops = populOTU(centaurea)


pcaRes = pca.calc(pops)
plotPoints(pcaRes, col = c("red", "green", "blue", "red"),
            pch = c(20, 17, 8, 21), pt.bg = "orange", legend = FALSE)

plotAddLabels.points(pcaRes, labels = c("LES", "BUK", "VOL", "OLE1"), include = TRUE)

plotPoints(pcaRes, col = c("red", "green", "blue", "red"),
            pch = c(20, 17, 8, 21), pt.bg = "orange", legend = FALSE)

plotAddLabels.points(pcaRes, labels = c("LES", "BUK", "VOL", "OLE1"), include = FALSE)
</code></pre>

<hr>
<h2 id='plotAddLegend'>Add Legend to a Plot</h2><span id='topic+plotAddLegend'></span>

<h3>Description</h3>

<p>This function can be used to add legend to plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotAddLegend(result, x = "topright", y = NULL, pch = 16, col = "black",
    pt.bg = "white", pt.cex = cex, pt.lwd = 1, x.intersp = 1,
    y.intersp = 1, box.type = "o", box.lty = "solid", box.lwd = 1,
    box.col = "black", box.bg = "white", cex = 1, ncol = 1, horiz = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotAddLegend_+3A_result">result</code></td>
<td>
<p>result of <code><a href="#topic+pca.calc">pca.calc</a></code>, <code><a href="#topic+pcoa.calc">pcoa.calc</a></code>, <code><a href="#topic+nmds.calc">nmds.calc</a></code>, or <code><a href="#topic+cda.calc">cda.calc</a></code>, has to by plotted at first.</p>
</td></tr>
<tr><td><code id="plotAddLegend_+3A_x">x</code>, <code id="plotAddLegend_+3A_y">y</code></td>
<td>
<p>the x and y coordinates or a single keyword from the list <code>"bottomright"</code>, <code>"bottom"</code>, <code>"bottomleft"</code>, <code>"left"</code>, <code>"topleft"</code>, <code>"top"</code>, <code>"topright"</code>, <code>"right"</code>, and <code>"center"</code>, to be used to position the legend.</p>
</td></tr>
<tr><td><code id="plotAddLegend_+3A_pch">pch</code></td>
<td>
<p>the plotting symbols of points appearing in the legend.</p>
</td></tr>
<tr><td><code id="plotAddLegend_+3A_col">col</code></td>
<td>
<p>the colours of points appearing in the legend.</p>
</td></tr>
<tr><td><code id="plotAddLegend_+3A_pt.bg">pt.bg</code></td>
<td>
<p>the background colour for the <code><a href="graphics.html#topic+points">points</a></code>, corresponding to its argument <code>bg</code>.</p>
</td></tr>
<tr><td><code id="plotAddLegend_+3A_pt.cex">pt.cex</code></td>
<td>
<p>character expansion factor for the points.</p>
</td></tr>
<tr><td><code id="plotAddLegend_+3A_pt.lwd">pt.lwd</code></td>
<td>
<p>the line width for the points.</p>
</td></tr>
<tr><td><code id="plotAddLegend_+3A_x.intersp">x.intersp</code>, <code id="plotAddLegend_+3A_y.intersp">y.intersp</code></td>
<td>
<p>character interspacing factor for horizontal (x) and vertical (y) line distances.</p>
</td></tr>
<tr><td><code id="plotAddLegend_+3A_box.type">box.type</code></td>
<td>
<p>the type of box to be drawn around the legend. The applicable values are <code>"o"</code> (the default) and <code>"n"</code>.</p>
</td></tr>
<tr><td><code id="plotAddLegend_+3A_box.lty">box.lty</code>, <code id="plotAddLegend_+3A_box.lwd">box.lwd</code>, <code id="plotAddLegend_+3A_box.col">box.col</code>, <code id="plotAddLegend_+3A_box.bg">box.bg</code></td>
<td>
<p>the line type, width colour and background colour for the legend box (if <code>box.type = "o"</code>).</p>
</td></tr>
<tr><td><code id="plotAddLegend_+3A_cex">cex</code></td>
<td>
<p>character expansion factor for text.</p>
</td></tr>
<tr><td><code id="plotAddLegend_+3A_ncol">ncol</code></td>
<td>
<p>the number of columns in which to set the legend item.</p>
</td></tr>
<tr><td><code id="plotAddLegend_+3A_horiz">horiz</code></td>
<td>
<p>logical; if <code>TRUE</code>, set the legend horizontally rather than vertically (specifying horiz overrides the <code>ncol</code> specification).</p>
</td></tr>
<tr><td><code id="plotAddLegend_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="graphics.html#topic+legend">legend</a></code> or other graphical parameters in <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Used for its side effect of adding elements to a plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)
centaurea = naMeanSubst(centaurea)
centaurea = removePopulation(centaurea, populationName = c("LIP", "PREL"))

pcaRes = pca.calc(centaurea)

plotPoints(pcaRes, col = c("red", "green", "blue", "red"),
            pch = c(20, 17, 8, 21), pt.bg = "orange", legend = FALSE)

plotAddLegend(pcaRes, x = "bottomright", col = c("red", "green", "blue", "red"),
               pch = c(20, 17, 8, 21), pt.bg = "orange", ncol = 2)
</code></pre>

<hr>
<h2 id='plotAddSpiders'>Add Spiders to a Plot</h2><span id='topic+plotAddSpiders'></span>

<h3>Description</h3>

<p>This function connects taxa's points with its centroids, thus forms a &ldquo;spider&rdquo; diagram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotAddSpiders(result, axes = c(1,2), col = "black", lty = 1, lwd = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotAddSpiders_+3A_result">result</code></td>
<td>
<p>result of <code><a href="#topic+pca.calc">pca.calc</a></code>, <code><a href="#topic+pcoa.calc">pcoa.calc</a></code>, <code><a href="#topic+nmds.calc">nmds.calc</a></code>, or <code><a href="#topic+cda.calc">cda.calc</a></code>, has to by plotted at first.</p>
</td></tr>
<tr><td><code id="plotAddSpiders_+3A_axes">axes</code></td>
<td>
<p>x, y axes of plot.</p>
</td></tr>
<tr><td><code id="plotAddSpiders_+3A_col">col</code></td>
<td>
<p>the colours for labels.</p>
</td></tr>
<tr><td><code id="plotAddSpiders_+3A_lty">lty</code></td>
<td>
<p>the line type. Line types can either be specified as one of following types: 0=blank, 1=solid (default), 2=dashed, 3=dotted, 4=dotdash, 5=longdash, 6=twodash.</p>
</td></tr>
<tr><td><code id="plotAddSpiders_+3A_lwd">lwd</code></td>
<td>
<p>the line width.</p>
</td></tr>
<tr><td><code id="plotAddSpiders_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="graphics.html#topic+lines">lines</a></code> or other graphical parameters in <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Used for its side effect of adding elements to a plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)
centaurea = naMeanSubst(centaurea)
centaurea = removePopulation(centaurea, populationName = c("LIP", "PREL"))

pcaRes = pca.calc(centaurea)

plotPoints(pcaRes, col = c(rgb(255, 0, 0, max = 255, alpha = 150), # red
                           rgb(0, 255, 0, max = 255, alpha = 150), # green
                           rgb(0, 0, 255, max = 255, alpha = 150), # blue
                           rgb(0, 0, 0, max = 255, alpha = 150)), # black
            legend = FALSE, xlim = c(-5, 7.5), ylim = c(-5, 5.5))

plotAddLegend(pcaRes, col = c("red", "green", "blue", "black"), ncol = 2)

plotAddSpiders(pcaRes, col = c("red", "green", "blue", "black"))


plotPoints(pcaRes, col = c("red", "green", "blue","black"), legend = TRUE, cex = 0.4)

plotAddSpiders(pcaRes, col = c(rgb(255, 0, 0, max = 255, alpha = 150), # red
                               rgb(0, 255, 0, max = 255, alpha = 150), # green
                               rgb(0, 0, 255, max = 255, alpha = 150), # blue
                               rgb(0, 0, 0, max = 255, alpha = 150))) # black
</code></pre>

<hr>
<h2 id='plotCharacters'>Draws Character's Contribution as Arrows</h2><span id='topic+plotCharacters'></span>

<h3>Description</h3>

<p>The character's contribution to ordination axes are visualised as arrows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCharacters(result, axes = c(1, 2), xlab = NULL, ylab = NULL,
    main = NULL, xlim = NULL, ylim = NULL, col = "red", length = 0.1,
    angle = 15, labels = TRUE, cex = 0.7, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCharacters_+3A_result">result</code></td>
<td>
<p>an object of class <code><a href="#topic+pcadata">pcadata</a></code> or <code><a href="#topic+cdadata">cdadata</a></code>.</p>
</td></tr>
<tr><td><code id="plotCharacters_+3A_axes">axes</code></td>
<td>
<p>x, y axes of plot.</p>
</td></tr>
<tr><td><code id="plotCharacters_+3A_xlab">xlab</code>, <code id="plotCharacters_+3A_ylab">ylab</code></td>
<td>
<p>a title of the respective axes.</p>
</td></tr>
<tr><td><code id="plotCharacters_+3A_xlim">xlim</code>, <code id="plotCharacters_+3A_ylim">ylim</code></td>
<td>
<p>numeric vectors of length 2, giving the x and y coordinates ranges.</p>
</td></tr>
<tr><td><code id="plotCharacters_+3A_main">main</code></td>
<td>
<p>a main title for the plot.</p>
</td></tr>
<tr><td><code id="plotCharacters_+3A_col">col</code></td>
<td>
<p>the colour for arrows.</p>
</td></tr>
<tr><td><code id="plotCharacters_+3A_length">length</code></td>
<td>
<p>length of the edges of the arrow head (in inches).</p>
</td></tr>
<tr><td><code id="plotCharacters_+3A_angle">angle</code></td>
<td>
<p>angle from the shaft of the arrow to the edge of the arrow head.</p>
</td></tr>
<tr><td><code id="plotCharacters_+3A_labels">labels</code></td>
<td>
<p>logical, if <code>TRUE</code>, labels are displayed. Only restricted number of parameters are supported. For more precise labels plotting, use <code><a href="#topic+plotAddLabels.characters">plotAddLabels.characters</a></code> directly.</p>
</td></tr>
<tr><td><code id="plotCharacters_+3A_cex">cex</code></td>
<td>
<p>character expansion factor for labels.</p>
</td></tr>
<tr><td><code id="plotCharacters_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="graphics.html#topic+arrows">arrows</a></code> or other graphical parameters in <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distribution of samples in ordination space is driven by morphological characters. Each character has its own contribution to ordination axes. These contributions are visualised as arrows. The direction and length of the arrows characterize the impact of the morphological characters on the separation of objects along a given axis. This information is stored in eigenvectors or total canonical structure coefficients for principal component analysis of canonical discriminant analysis, respectively.
</p>
<p>The <code>plotCharacters</code> method is not applicable to results of the principal coordinates analysis (<code><a href="#topic+pcoa.calc">pcoa.calc</a></code>) and non-metric multidimensional scaling (<code><a href="#topic+nmds.calc">nmds.calc</a></code>) analyses, as the influence of original characters on new axes can not be directly derived, and variation explained by individual axes is unknown.
</p>


<h3>Value</h3>

<p>None. Used for its side effect of producing a plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)
centaurea = naMeanSubst(centaurea)
centaurea = removePopulation(centaurea, populationName = c("LIP", "PREL"))

pcaRes = pca.calc(centaurea)

plotCharacters(pcaRes)
</code></pre>

<hr>
<h2 id='plotPoints'>The Default Scatterplot Function</h2><span id='topic+plotPoints'></span>

<h3>Description</h3>

<p>A generic function for plotting ordination scores stored in <code><a href="#topic+pcadata">pcadata</a></code>, <code><a href="#topic+pcoadata">pcoadata</a></code>, <code><a href="#topic+nmdsdata">nmdsdata</a></code>, and <code><a href="#topic+cdadata">cdadata</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPoints(result, axes = c(1,2), xlab = NULL, ylab = NULL,
      pch = 16, col = "black", pt.bg = "white", breaks = 1,
      ylim = NULL, xlim = NULL, labels = FALSE, legend = FALSE,
      legend.pos = "topright", ncol = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPoints_+3A_result">result</code></td>
<td>
<p>an object of class <code><a href="#topic+pcadata">pcadata</a></code>, <code><a href="#topic+pcoadata">pcoadata</a></code>, <code><a href="#topic+nmdsdata">nmdsdata</a></code>, or <code><a href="#topic+cdadata">cdadata</a></code>.</p>
</td></tr>
<tr><td><code id="plotPoints_+3A_axes">axes</code></td>
<td>
<p>x, y axes of plot.</p>
</td></tr>
<tr><td><code id="plotPoints_+3A_xlab">xlab</code>, <code id="plotPoints_+3A_ylab">ylab</code></td>
<td>
<p>a title of the respective axes.</p>
</td></tr>
<tr><td><code id="plotPoints_+3A_pch">pch</code></td>
<td>
<p>a vector of plotting characters or symbols: see <code><a href="graphics.html#topic+points">points</a></code>.</p>
</td></tr>
<tr><td><code id="plotPoints_+3A_col">col</code></td>
<td>
<p>the colours for points. Multiple colours can be specified so that each taxon can be given its own colour. If there are fewer colours than taxa, they are recycled in the standard fashion.</p>
</td></tr>
<tr><td><code id="plotPoints_+3A_pt.bg">pt.bg</code></td>
<td>
<p>the background colours for points. Multiple colours can be specified, as above.</p>
</td></tr>
<tr><td><code id="plotPoints_+3A_breaks">breaks</code></td>
<td>
<p>a numeric, giving the width of one histogram bar.</p>
</td></tr>
<tr><td><code id="plotPoints_+3A_xlim">xlim</code>, <code id="plotPoints_+3A_ylim">ylim</code></td>
<td>
<p>the range of x and y axes.</p>
</td></tr>
<tr><td><code id="plotPoints_+3A_labels">labels</code></td>
<td>
<p>logical, if <code>TRUE</code>, labels are displayed. Only restricted number of parameters are supported. For more precise labels plotting, use <code><a href="#topic+plotAddLabels.points">plotAddLabels.points</a></code> directly.</p>
</td></tr>
<tr><td><code id="plotPoints_+3A_legend">legend</code></td>
<td>
<p>logical, if <code>TRUE</code>, legend is displayed. Only restricted number of legend parameters are supported. For more precise legend plotting, use <code><a href="#topic+plotAddLegend">plotAddLegend</a></code> directly.</p>
</td></tr>
<tr><td><code id="plotPoints_+3A_legend.pos">legend.pos</code></td>
<td>
<p>a single keyword from the list <code>"bottomright"</code>, <code>"bottom"</code>, <code>"bottomleft"</code>, <code>"left"</code>, <code>"topleft"</code>, <code>"top"</code>, <code>"topright"</code>, <code>"right"</code>, and <code>"center"</code>, to be used to position the legend.</p>
</td></tr>
<tr><td><code id="plotPoints_+3A_ncol">ncol</code></td>
<td>
<p>the number of columns in which to set the legend items.</p>
</td></tr>
<tr><td><code id="plotPoints_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code> or other graphical parameters in <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This generic method holds separate implementations of plotting points for <code><a href="#topic+pcadata">pcadata</a></code>, <code><a href="#topic+pcoadata">pcoadata</a></code>, <code><a href="#topic+nmdsdata">nmdsdata</a></code>, and <code><a href="#topic+cdadata">cdadata</a></code> objects.
If only one axis exists, sample scores are displayed as a histogram.
</p>


<h3>Value</h3>

<p>None. Used for its side effect of producing a plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)
centaurea = naMeanSubst(centaurea)
centaurea = removePopulation(centaurea, populationName = c("LIP", "PREL"))

pcaRes = pca.calc(centaurea)

plotPoints(pcaRes, axes = c(1,2), col = c("red", "green", "blue", "red"),
  pch = c(20, 17, 8, 21), pt.bg = "orange", legend = TRUE, legend.pos = "bottomright")

plotPoints(pcaRes, main = "My PCA plot", frame.plot = FALSE, cex = 0.8)

cdaRes = cda.calc(centaurea)

plotPoints(cdaRes, col = c("red", "green", "blue", "red"),
  pch = c(20, 17, 8, 21), pt.bg = "orange", legend = TRUE)
</code></pre>

<hr>
<h2 id='populOTU'>Population Means</h2><span id='topic+populOTU'></span>

<h3>Description</h3>

<p>This function calculates the average value for each character in each population, with the pairwise deletion of missing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>populOTU(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="populOTU_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+morphodata">morphodata</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns <code>morphodata</code> object, where each population is used as the operational taxonomic unit (OTUs),
thus is represented by single &ldquo;individual&rdquo; (row) with average values for each character.
Note that when using populations as OTUs, they are handled with the same weight in all analyses
(disregarding population size, within-population variation, etc.)
</p>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+morphodata">morphodata</a></code> with the following elements:
</p>
<table>
<tr><td><code>ID</code></td>
<td>
<p>IDs of each row of <code>data</code> object.</p>
</td></tr>
<tr><td><code>Population</code></td>
<td>
<p>population membership of each row of <code>data</code> object.</p>
</td></tr>
<tr><td><code>Taxon</code></td>
<td>
<p>taxon membership of each row of <code>data</code> object.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p><code>data.frame</code> of individuals (rows) and values of measured morphological characters (columns).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)

pops = populOTU(centaurea)
</code></pre>

<hr>
<h2 id='qqnormCharacter'>Quantile-Quantile Plots</h2><span id='topic+qqnormCharacter'></span><span id='topic+qqnormAll'></span>

<h3>Description</h3>

<p>Q-Q plots are produced for the level of taxa/groups, to displays a deviation of morphological characters of each taxon from the normal distribution (line).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqnormCharacter(object, character, taxon = levels(object$Taxon), main = NULL, ...)

qqnormAll(object, folderName = "qqnormPlots", taxon = levels(object$Taxon),
          main = NULL, width = 480, height = 480, units = "px", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qqnormCharacter_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+morphodata">morphodata</a></code>.</p>
</td></tr>
<tr><td><code id="qqnormCharacter_+3A_character">character</code></td>
<td>
<p>a morphological character used to plot Q-Q plot.</p>
</td></tr>
<tr><td><code id="qqnormCharacter_+3A_foldername">folderName</code></td>
<td>
<p>folder to save produced Q-Q plots.</p>
</td></tr>
<tr><td><code id="qqnormCharacter_+3A_taxon">taxon</code></td>
<td>
<p>taxa which should be plotted, default is to plot all of the taxa.</p>
</td></tr>
<tr><td><code id="qqnormCharacter_+3A_main">main</code></td>
<td>
<p>main title for the plot.</p>
</td></tr>
<tr><td><code id="qqnormCharacter_+3A_width">width</code></td>
<td>
<p>the width of the figure.</p>
</td></tr>
<tr><td><code id="qqnormCharacter_+3A_height">height</code></td>
<td>
<p>the height of the figure.</p>
</td></tr>
<tr><td><code id="qqnormCharacter_+3A_units">units</code></td>
<td>
<p>the units in which <code>height</code> and <code>width</code> are given. Can be <code>"px"</code> (pixels, the default), <code>"in"</code> (inches), <code>"cm"</code> or <code>"mm"</code>.</p>
</td></tr>
<tr><td><code id="qqnormCharacter_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="stats.html#topic+qqnorm">qqnorm</a></code> or graphical parameters <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Used for its side effect of producing a plot(s).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)

qqnormCharacter(centaurea, character = "SF")

## Not run: qqnormAll(centaurea, folderName = "../qqnormPlots")
</code></pre>

<hr>
<h2 id='read.morphodata'>Data Input and Description</h2><span id='topic+read.morphodata'></span><span id='topic+samples'></span><span id='topic+populations'></span><span id='topic+taxa'></span>

<h3>Description</h3>

<p>This function imports data and produces a <code><a href="#topic+morphodata">morphodata</a></code> object from it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.morphodata(file, dec = ".", sep = "\t", ...)

## S3 method for class 'morphodata'

samples(object)

populations(object)

taxa(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.morphodata_+3A_file">file</code></td>
<td>
<p>the file which the data are to be read from or a <code><a href="base.html#topic+connection">connection</a></code> for reading (e.g., <code>"clipboard"</code>).</p>
</td></tr>
<tr><td><code id="read.morphodata_+3A_dec">dec</code></td>
<td>
<p>the character used for decimal points.</p>
</td></tr>
<tr><td><code id="read.morphodata_+3A_sep">sep</code></td>
<td>
<p>the column separator character.</p>
</td></tr>
<tr><td><code id="read.morphodata_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+morphodata">morphodata</a></code>.</p>
</td></tr>
<tr><td><code id="read.morphodata_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="utils.html#topic+read.table">read.table</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function expects the following data structure: <br />
(1) the first row contains variable names;<br />
(2) the following rows contains individuals, single individual per row;<br />
(3) the first three columns include unique identifiers for individuals, populations and taxa/groups, respectively. Columns have to be named as &ldquo;ID&rdquo;, &ldquo;Population&rdquo; and &ldquo;Taxon&rdquo;;<br />
(4) starting from the fourth column, any number of quantitative or binary morphological characters may be recorded. Any variable names can be used (avoiding spaces and special characters);
</p>
<p>If there are missing values in the data, they must be represented as empty cells or by the text <code>NA</code>, not zero, space or any other character. Example dataset in txt and xlsx formats are stored in the &ldquo;extdata&rdquo; directory of the MorphoTools2 package installation directory. To find the path to the package location run <code>system.file("extdata", package = "MorphoTools2")</code>.
</p>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+morphodata">morphodata</a></code> with the following elements:
</p>
<table>
<tr><td><code>ID</code></td>
<td>
<p>IDs of each row of <code>data</code> object.</p>
</td></tr>
<tr><td><code>Population</code></td>
<td>
<p>population membership of each row of <code>data</code> object.</p>
</td></tr>
<tr><td><code>Taxon</code></td>
<td>
<p>taxon membership of each row of <code>data</code> object.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p><code>data.frame</code> of individuals (rows) and values of measured morphological characters (columns).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+characters">characters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = read.morphodata(file = system.file("extdata", "centaurea.txt",
    package = "MorphoTools2"), dec = ".", sep = "\t")

## Not run: data = read.morphodata(file = "morphodata.txt", dec = ".", sep = "\t")

## Not run: data = read.morphodata("clipboard")

summary(data)
samples(data)
populations(data)
taxa(data)
</code></pre>

<hr>
<h2 id='removeTaxon'>Remove Items (Taxa, Populations, Morphological Characters) from Morphodata Object</h2><span id='topic+removeTaxon'></span><span id='topic+removePopulation'></span><span id='topic+removeSample'></span><span id='topic+removeCharacter'></span>

<h3>Description</h3>

<p>These functions remove particular taxa, populations, samples or morphological characters from <code>morphodata</code> object. The samples can be deleted by names using <code>sampleName</code> argument, or each sample above the desired threshold <code>missingPercentage</code> will be deleted. Only one parameter can be specified in one run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeTaxon(object, taxonName)

removePopulation(object, populationName)

removeSample(object, sampleName = NULL, missingPercentage = NA)

removeCharacter(object, characterName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeTaxon_+3A_object">object</code></td>
<td>
<p>object of class <code><a href="#topic+morphodata">morphodata</a></code>.</p>
</td></tr>
<tr><td><code id="removeTaxon_+3A_taxonname">taxonName</code></td>
<td>
<p>vector of taxa to be removed.</p>
</td></tr>
<tr><td><code id="removeTaxon_+3A_populationname">populationName</code></td>
<td>
<p>vector of populations to be removed.</p>
</td></tr>
<tr><td><code id="removeTaxon_+3A_samplename">sampleName</code></td>
<td>
<p>vector of samples to be removed.</p>
</td></tr>
<tr><td><code id="removeTaxon_+3A_missingpercentage">missingPercentage</code></td>
<td>
<p>a numeric, samples holding more missing data than specified by <code>missingPercentage</code> will be removed.</p>
</td></tr>
<tr><td><code id="removeTaxon_+3A_charactername">characterName</code></td>
<td>
<p>vector of characters to be removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+morphodata">morphodata</a></code> with the following elements:
</p>
<table>
<tr><td><code>ID</code></td>
<td>
<p>IDs of each row of <code>data</code> object.</p>
</td></tr>
<tr><td><code>Population</code></td>
<td>
<p>population membership of each row of <code>data</code> object.</p>
</td></tr>
<tr><td><code>Taxon</code></td>
<td>
<p>taxon membership of each row of <code>data</code> object.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p><code>data.frame</code> of individuals (rows) and values of measured morphological characters (columns).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)

centaurea.3tax = removeTaxon(centaurea, "hybr")
centaurea.PsSt = removeTaxon(centaurea, c("ph", "hybr"))

centaurea.short = removePopulation(centaurea, c("LIP", "PREL"))

centaurea.NA_0.1 = removeSample(centaurea, missingPercentage = 0.1)

centaurea.short = removeCharacter(centaurea, "LL")
</code></pre>

<hr>
<h2 id='shapiroWilkTest'>Shapiro-Wilk Normality Test</h2><span id='topic+shapiroWilkTest'></span>

<h3>Description</h3>

<p>Calculates the Shapiro-Wilk normality test of characters for taxa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shapiroWilkTest(object, p.value = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shapiroWilkTest_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+morphodata">morphodata</a></code>.</p>
</td></tr>
<tr><td><code id="shapiroWilkTest_+3A_p.value">p.value</code></td>
<td>
<p>a number or <code>NA</code> are acceptable. In the case of number, the output will be formatted as <code>"normally distributed"</code> or <code>"NOT normally distributed"</code>. In the case of <code>NA</code>, exact p-values will be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>, storing results of Shapiro-Wilk normality test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)

sW = shapiroWilkTest(centaurea)

## Not run: exportRes(sW, file = "sW_test.txt")

sW = shapiroWilkTest(centaurea, p.value = NA)

## Not run: exportRes(sW, file = "sW_test.txt")
</code></pre>

<hr>
<h2 id='stepdisc.calc'>Stepwise Discriminant Analysis</h2><span id='topic+stepdisc.calc'></span>

<h3>Description</h3>

<p>This function perform stepwise discriminant analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepdisc.calc(object, FToEnter = 0.15, FToStay = 0.15)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepdisc.calc_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+morphodata">morphodata</a></code>.</p>
</td></tr>
<tr><td><code id="stepdisc.calc_+3A_ftoenter">FToEnter</code></td>
<td>
<p>significance levels for a variable to enter the subset.</p>
</td></tr>
<tr><td><code id="stepdisc.calc_+3A_ftostay">FToStay</code></td>
<td>
<p>significance levels for a variable to stay in the subset.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>stepdisc.calc</code> function performs a stepwise discriminant analysis to select the &ldquo;best&rdquo; subset of the quantitative variables for use in discriminating among the groups (taxa).
</p>


<h3>Value</h3>

<p>None. Used for its side effect.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)
centaurea = naMeanSubst(centaurea)
centaurea = removePopulation(centaurea, populationName = c("LIP", "PREL"))

stepdisc.calc(centaurea)
</code></pre>

<hr>
<h2 id='summary'>Object Summaries</h2><span id='topic+summary'></span><span id='topic+summary.morphodata'></span><span id='topic+summary.pcadata'></span><span id='topic+summary.pcoadata'></span><span id='topic+summary.nmdsdata'></span><span id='topic+summary.cdadata'></span><span id='topic+summary.classifdata'></span>

<h3>Description</h3>

<p><code>summary</code> methods for classes <code><a href="#topic+morphodata">morphodata</a></code>, <code><a href="#topic+pcadata">pcadata</a></code>, <code><a href="#topic+pcoadata">pcoadata</a></code>, <code><a href="#topic+nmdsdata">nmdsdata</a></code>, <code><a href="#topic+cdadata">cdadata</a></code>, and <code><a href="#topic+classifdata">classifdata</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'morphodata'
summary(object, ...)

## S3 method for class 'pcadata'
summary(object, ...)

## S3 method for class 'pcoadata'
summary(object, ...)

## S3 method for class 'nmdsdata'
summary(object, ...)

## S3 method for class 'cdadata'
summary(object, ...)

## S3 method for class 'classifdata'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+morphodata">morphodata</a></code>, <code><a href="#topic+pcadata">pcadata</a></code>, <code><a href="#topic+pcoadata">pcoadata</a></code>, <code><a href="#topic+nmdsdata">nmdsdata</a></code>, <code><a href="#topic+cdadata">cdadata</a></code>, or <code><a href="#topic+classifdata">classifdata</a></code>.</p>
</td></tr>
<tr><td><code id="summary_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Used for its side effect.
</p>

<hr>
<h2 id='transformCharacter'>Transformation of Character</h2><span id='topic+transformCharacter'></span>

<h3>Description</h3>

<p>This function transforms morphological characters by applying another function passed in the argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformCharacter(object, character, FUN, newName = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transformCharacter_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+morphodata">morphodata</a></code>.</p>
</td></tr>
<tr><td><code id="transformCharacter_+3A_character">character</code></td>
<td>
<p>a morphological character that should be transformed.</p>
</td></tr>
<tr><td><code id="transformCharacter_+3A_fun">FUN</code></td>
<td>
<p>the transforming function to be applied to character.</p>
</td></tr>
<tr><td><code id="transformCharacter_+3A_newname">newName</code></td>
<td>
<p>a name to rename the original character. If <code>NULL</code>, the name of the transformed character remains the same.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Transformation is applied to characters to improve their distribution (to become normally distributed or at least to achieve lesser deviation from normality). The <code>FUN</code> argument takes any function, able to accept as input any value of the character specified by <code>character</code> argument.
</p>
<p>Note that, when using a log transformation, a constant should be added to all values to make them all positive before transformation (if there are zero values in the data), because the argument of the logarithm can be only positive numbers. The arcsine transformation is applicable for proportions and percentages (for values ranging from 0 to 1).
</p>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+morphodata">morphodata</a></code> with the following elements:
</p>
<table>
<tr><td><code>ID</code></td>
<td>
<p>IDs of each row of <code>data</code> object.</p>
</td></tr>
<tr><td><code>Population</code></td>
<td>
<p>population membership of each row of <code>data</code> object.</p>
</td></tr>
<tr><td><code>Taxon</code></td>
<td>
<p>taxon membership of each row of <code>data</code> object.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p><code>data.frame</code> of individuals (rows) and values of measured morphological characters (columns).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)

# For a right-skewed (positive) distribution can be used:
# Logarithmic transformation
cTransf = transformCharacter(centaurea, character = "SF", FUN = function(x) log(x+1))
cTransf = transformCharacter(centaurea, character = "SF", FUN = function(x) log10(x+1))
# Square root transformation
cTransf = transformCharacter(centaurea, character = "SF", FUN = function(x) sqrt(x))
# Cube root transformation
cTransf = transformCharacter(centaurea, character = "SF", FUN = function(x) x^(1/3))
# Arcsine transformation
cTransf = transformCharacter(centaurea, character = "SF", FUN = function(x) asin(sqrt(x)))

# For a left-skewed (negative) distribution can be used:
# Logarithmic transformation
cTransf = transformCharacter(centaurea, character="SF", FUN=function(x) log((max(x)+1)-x))
cTransf = transformCharacter(centaurea, character="SF", FUN=function(x) log10((max(x)+1)-x))
# Square root transformation
cTransf = transformCharacter(centaurea, character="SF", FUN=function(x) sqrt((max(x)+1)-x))
# Cube root transformation
cTransf = transformCharacter(centaurea, character="SF", FUN=function(x) ((max(x)+1)-x)^(1/3))
# Arcsine transformation
cTransf = transformCharacter(centaurea, character="SF", FUN=function(x) asin(sqrt((max(x))-x)))


</code></pre>

<hr>
<h2 id='viewMorphodata'>Invoke a Data Viewer</h2><span id='topic+viewMorphodata'></span>

<h3>Description</h3>

<p>Invoke a spreadsheet-style data viewer on a data stored in <code><a href="#topic+morphodata">morphodata</a></code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viewMorphodata(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="viewMorphodata_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+morphodata">morphodata</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Used for its side effect.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(centaurea)

## Not run: viewMorphodata(centaurea)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
