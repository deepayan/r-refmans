<!DOCTYPE html><html><head><title>Help for package RclusTool</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RclusTool}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.logoFrame'><p>Logo frame in the graphical user interface</p></a></li>
<li><a href='#abdPlot'><p>Abundances barplot</p></a></li>
<li><a href='#abdPlotTabs'><p>Abundances barplots inside Tk tabs.</p></a></li>
<li><a href='#abdPlotTabsGUI'><p>Abundances barplots inside Tk tabs.</p></a></li>
<li><a href='#addClustering'><p>Clustering addition</p></a></li>
<li><a href='#addIds2Sampling'><p>Adding Ids To a Sampling</p></a></li>
<li><a href='#addOperation'><p>Add operation</p></a></li>
<li><a href='#analyzePlot'><p>Plot for data exploration/analysis</p></a></li>
<li><a href='#applyPreprocessing'><p>Preprocessing application</p></a></li>
<li><a href='#bipartitionShi'><p>Spectral clustering</p></a></li>
<li><a href='#buildBatchTab'><p>Batch process tab</p></a></li>
<li><a href='#buildClusteringSample'><p>Clustering loading</p></a></li>
<li><a href='#buildConstraintsMatrix'><p>Constraints matrices</p></a></li>
<li><a href='#buildImportTab'><p>Build Import tab</p></a></li>
<li><a href='#buildNameOperation'><p>Build Name Operation</p></a></li>
<li><a href='#buildPreprocessTab'><p>build Preprocess tab</p></a></li>
<li><a href='#buildSemisupTab'><p>Semi-Supervised tab</p></a></li>
<li><a href='#buildsupTab'><p>Supervised tab</p></a></li>
<li><a href='#buildUnsupTab'><p>Unsupervised tab</p></a></li>
<li><a href='#clusterDensity'><p>Clusters density computation</p></a></li>
<li><a href='#clusterSummary'><p>Clusters summaries computation</p></a></li>
<li><a href='#computeCKmeans'><p>Constrained K-means clustering</p></a></li>
<li><a href='#computeCSC'><p>Constrained Spectral Clustering</p></a></li>
<li><a href='#computeEM'><p>Expectation-Maximization clustering</p></a></li>
<li><a href='#computeGap'><p>Gap computation</p></a></li>
<li><a href='#computeGap2'><p>Gap computation</p></a></li>
<li><a href='#computeGaussianSimilarity'><p>Gaussian similarity</p></a></li>
<li><a href='#computeGaussianSimilarityZP'><p>Gaussian similarity</p></a></li>
<li><a href='#computeItemsSample'><p>Prediction of number of cells in colonies</p></a></li>
<li><a href='#computeItemsSampleGUI'><p>GUI to estimate the number of cells in colonies for each cluster</p></a></li>
<li><a href='#computeKmeans'><p>K-means clustering</p></a></li>
<li><a href='#computePcaNbDims'><p>Number of dimensions for PCA</p></a></li>
<li><a href='#computePcaSample'><p>Principal Components Analysis</p></a></li>
<li><a href='#computeSampling'><p>Sampling raw data matrix</p></a></li>
<li><a href='#computeSemiSupervised'><p>Semi-supervised clustering</p></a></li>
<li><a href='#computeSpectralEmbeddingSample'><p>Spectral embedding</p></a></li>
<li><a href='#computeSupervised'><p>Supervised classification</p></a></li>
<li><a href='#computeUnSupervised'><p>Unsupervised clustering</p></a></li>
<li><a href='#convNamesPairsToIndexPairs'><p>Conversion of a set of names pairs to matrix of index pairs (2 columns)</p></a></li>
<li><a href='#convNamesToIndex'><p>Conversion of element names to indexes</p></a></li>
<li><a href='#cor.mtest'><p>Correlation test.</p></a></li>
<li><a href='#countItems'><p>Manually counting the number of cells in colonies</p></a></li>
<li><a href='#countItemsSampleGUI'><p>GUI to manually count the number of cells in colonies</p></a></li>
<li><a href='#createResFolder'><p>Results directories creation</p></a></li>
<li><a href='#critMNCut'><p>Multiple Normalized Cut</p></a></li>
<li><a href='#detailOperation'><p>detail Operation</p></a></li>
<li><a href='#dropTrainSetVars'><p>Parameters dropping</p></a></li>
<li><a href='#ElbowFinder'><p>Elbow Finder</p></a></li>
<li><a href='#ElbowPlot'><p>Elbow Plot.</p></a></li>
<li><a href='#extractFeaturesFromSummary'><p>Extraction of features from a summary object.</p></a></li>
<li><a href='#extractProtos'><p>Prototypes extraction</p></a></li>
<li><a href='#featSpaceNameConvert'><p>Feature Space Name Conversion</p></a></li>
<li><a href='#FindNumberK'><p>Automatic estimation of the number of clusters</p></a></li>
<li><a href='#formatLabelSample'><p>Labels formatting</p></a></li>
<li><a href='#formatParameterList'><p>Format Parameter List</p></a></li>
<li><a href='#guessFileEncoding'><p>File Encoding Identification.</p></a></li>
<li><a href='#imgClassif'><p>Images clustering</p></a></li>
<li><a href='#importLabelSample'><p>Labels importation</p></a></li>
<li><a href='#importSample'><p>Sample importation</p></a></li>
<li><a href='#initBatchTab'><p>batch tab</p></a></li>
<li><a href='#initImportTab'><p>import tab</p></a></li>
<li><a href='#initParameters'><p>Parameters initialization</p></a></li>
<li><a href='#initPreprocessTab'><p>build Preprocess tab</p></a></li>
<li><a href='#initSemisupTab'><p>Semi-Supervised tab</p></a></li>
<li><a href='#initSupTab'><p>supervised tab</p></a></li>
<li><a href='#initUnsupTab'><p>Unsupervised tab</p></a></li>
<li><a href='#itemsModel'><p>Predictive models computation for the number of cells in colonies</p></a></li>
<li><a href='#KmeansAutoElbow'><p>Kmeans clustering with automatic estimation of number of clusters</p></a></li>
<li><a href='#KmeansQuick'><p>Quick kmeans clustering</p></a></li>
<li><a href='#KwaySSSC'><p>Semi-supervised spectral clustering</p></a></li>
<li><a href='#listDerivableFeatureSpaces'><p>Builds list of derivable feature spaces</p></a></li>
<li><a href='#loadPreprocessFile'><p>Preprocessing loading</p></a></li>
<li><a href='#loadPreviousRes'><p>Previous clustering results loading</p></a></li>
<li><a href='#loadSample'><p>Sample loading</p></a></li>
<li><a href='#loadSummary'><p>Summaries loading</p></a></li>
<li><a href='#MainWindow'><p>Main window</p></a></li>
<li><a href='#makeFeatureSpaceOperations'><p>Make operation config object to build feature spaces</p></a></li>
<li><a href='#makeTitle'><p>RclusTool makeTitle.</p></a></li>
<li><a href='#matchNames'><p>Match Names</p></a></li>
<li><a href='#measureConstraintsOk'><p>Rates of constraints satisfaction</p></a></li>
<li><a href='#measureMNCut'><p>Multiple Normalized Cut</p></a></li>
<li><a href='#messageConsole'><p>RclusTool consoleMessage.</p></a></li>
<li><a href='#nameClusters'><p>Clusters renaming</p></a></li>
<li><a href='#plotDensity2D'><p>plot Variables Density</p></a></li>
<li><a href='#plotProfile'><p>Profile and image plotting</p></a></li>
<li><a href='#plotProfileExtract'><p>Profile and image plotting</p></a></li>
<li><a href='#plotSampleFeatures'><p>2D-features scatter-plot</p></a></li>
<li><a href='#previewCSVfile'><p>Preview CSV file</p></a></li>
<li><a href='#purgeSample'><p>Sample purging</p></a></li>
<li><a href='#RclusToolGUI'><p>Username and user type selection</p></a></li>
<li><a href='#readTrainSet'><p>Training set reading</p></a></li>
<li><a href='#removeZeros'><p>Zeros replacement</p></a></li>
<li><a href='#saveCalcul'><p>Object saving</p></a></li>
<li><a href='#saveClustering'><p>Clustering saving</p></a></li>
<li><a href='#saveCounts'><p>Count saving</p></a></li>
<li><a href='#saveLogFile'><p>Log file saving</p></a></li>
<li><a href='#saveManualProtos'><p>Manual prototypes saving</p></a></li>
<li><a href='#savePreprocess'><p>Preprocessing exportation</p></a></li>
<li><a href='#saveSummary'><p>Clusters summaries saving</p></a></li>
<li><a href='#search.neighbour'><p>Search neighbour</p></a></li>
<li><a href='#sigClassif'><p>Signals clustering</p></a></li>
<li><a href='#sortCharAsNum'><p>Character vector numeric sorting</p></a></li>
<li><a href='#sortLabel'><p>Clusters labels sorting</p></a></li>
<li><a href='#spectralClustering'><p>Spectral clustering</p></a></li>
<li><a href='#spectralClusteringNg'><p>Spectral clustering</p></a></li>
<li><a href='#spectralEmbeddingNg'><p>Spectral embedding</p></a></li>
<li><a href='#tk2add.notetab'><p>Add notetab.</p></a></li>
<li><a href='#tk2delete.notetab'><p>Delete notetab inside a tk-notebook</p></a></li>
<li><a href='#tk2draw.notetab'><p>Draw in a Notetab.</p></a></li>
<li><a href='#tk2notetab.RclusTool'><p>RclusTool tk2notetab.</p></a></li>
<li><a href='#tkEmptyLine'><p>RclusTool tkEmptyLine.</p></a></li>
<li><a href='#tkrplot.RclusTool'><p>RclusTool tkrplot.</p></a></li>
<li><a href='#tkrreplot.RclusTool'><p>RclusTool tkrreplot.</p></a></li>
<li><a href='#toStringDataFrame'><p>To String Data Frame</p></a></li>
<li><a href='#updateClustersNames'><p>Clusters names updating</p></a></li>
<li><a href='#visualizeSampleClustering'><p>Interactive figure with 2D scatter-plot</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Graphical Toolbox for Clustering and Classification of Data
Frames</td>
</tr>
<tr>
<td>Version:</td>
<td>0.91.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-07-27</td>
</tr>
<tr>
<td>Author:</td>
<td>Guillaume Wacquet [aut],
  Pierre-Alexandre Hebert [aut, cre],
  Emilie Poisson [aut],
  Pierre Talon [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pierre-Alexandre Hebert &lt;hebert@univ-littoral.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Graphical toolbox for clustering and classification of data frames.
    It proposes a graphical interface to process clustering and classification methods on features
    data-frames, and to view initial data as well as resulted cluster or classes. According to the
    level of available labels, different approaches are proposed: unsupervised clustering,
    semi-supervised clustering and supervised classification. 
    To assess the processed clusters or classes, the toolbox can import and show some supplementary
    data formats: either profile/time series, or images. 
    These added information can help the expert to label clusters (clustering), or to constrain data
    frame rows (semi-supervised clustering), using Constrained spectral embedding algorithm by 
    Wacquet et al. (2013) &lt;<a href="https://doi.org/10.1016%2Fj.patrec.2013.02.003">doi:10.1016/j.patrec.2013.02.003</a>&gt; and the methodology provided by 
    Wacquet et al. (2013) &lt;<a href="https://doi.org/10.1007%2F978-3-642-35638-4_21">doi:10.1007/978-3-642-35638-4_21</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), tcltk, tcltk2, tkrplot</td>
</tr>
<tr>
<td>Imports:</td>
<td>class, cluster, conclust, corrplot, e1071, factoextra,
FactoMineR, ggplot2, grid, jpeg, knitr, MASS, mclust, mda,
mmand, nnet, png, randomForest, reshape, rlang, SearchTrees,
sp, stats, stringi, stringr, tools</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>XQuartz (on OSX)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-27 17:49:13 UTC; hebert</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-27 19:10:02 UTC</td>
</tr>
<tr>
<td>URL:</td>
<td>mawenzi.univ-littoral.fr/RclusTool</td>
</tr>
</table>
<hr>
<h2 id='.logoFrame'>Logo frame in the graphical user interface</h2><span id='topic+.logoFrame'></span>

<h3>Description</h3>

<p>Create and position the logo frame and images in the graphical user interface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.logoFrame(window)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".logoFrame_+3A_window">window</code></td>
<td>
<p>window in which the logo frame is positioned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function to create and position the logo frame in the main window
</p>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='abdPlot'>Abundances barplot</h2><span id='topic+abdPlot'></span>

<h3>Description</h3>

<p>Display the abundances barplot of a clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abdPlot(
  label,
  title,
  charsize = 11,
  point.param = c("grey", "black", "red", "blue", "green", "cyan", "yellow", "orange",
    "rosybrown", "palevioletred", "darkblue", "deeppink", "blueviolet", "darkgoldenrod1",
    "chartreuse", "darkorchid1", "deeppink", "coral", "darkolivegreen1", "#66C2A5",
    "#9DAE8C", "#D49A73", "#F08F6D", "#C79693", "#9E9DBA", "#9F9BC9", "#C193C6",
    "#E28BC3", "#D2A29F", "#BABF77", "#AAD852", "#CBD844", "#ECD836", "#FAD53E",
    "#F1CD64", "#E7C689", "#D7BF9C", "#C5B9A7", "#B3B3B3", "#D53E4F", "#E04F4A",
    "#EB6046", "#F47346", "#F88B51", 
     "#FBA35C", "#FDB869", "#FDCA79", "#FDDD88",
    "#F6E68F", "#EDEE93", "#E2F398", "#CDEA9D", "#B7E2A1", "#A0D8A4", "#86CEA4",
    "#6DC4A4", "#58B2AB", "#459DB4", "#3288BD")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abdPlot_+3A_label">label</code></td>
<td>
<p>factor describing the clustering.</p>
</td></tr>
<tr><td><code id="abdPlot_+3A_title">title</code></td>
<td>
<p>naming the graph.</p>
</td></tr>
<tr><td><code id="abdPlot_+3A_charsize">charsize</code></td>
<td>
<p>character size</p>
</td></tr>
<tr><td><code id="abdPlot_+3A_point.param">point.param</code></td>
<td>
<p>specifying the colors and the symbols to use for clusters display.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>abdPlot displays the abundances barplot of a clustering.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 6, sd = 0.3), ncol = 2))
colnames(dat) &lt;- c("x","y")
tf &lt;- tempfile()
write.table(dat, tf, sep=",", dec=".")

x &lt;- importSample(file.features=tf)

x &lt;- computeUnSupervised(x, K=3, method.name='K-means')

abdPlot(x[["clustering"]][["K-means_preprocessed"]][["label"]], 'K-means_preprocessed')


</code></pre>

<hr>
<h2 id='abdPlotTabs'>Abundances barplots inside Tk tabs.</h2><span id='topic+abdPlotTabs'></span>

<h3>Description</h3>

<p>Display the abundances barplot of a clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abdPlotTabs(clusterings, nb, RclusTool.env = initParameters(), hscale = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abdPlotTabs_+3A_clusterings">clusterings</code></td>
<td>
<p>clustering list.</p>
</td></tr>
<tr><td><code id="abdPlotTabs_+3A_nb">nb</code></td>
<td>
<p>a notebook.</p>
</td></tr>
<tr><td><code id="abdPlotTabs_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>environment in which all global parameters, raw data and results are stored.</p>
</td></tr>
<tr><td><code id="abdPlotTabs_+3A_hscale">hscale</code></td>
<td>
<p>numeric value corresponding to the horizontal scale of graphic.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>abdPlotTabs displays the abundances barplot of a set of clusterings in Tk tabs of a notebook.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 6, sd = 0.3), ncol = 2))
colnames(dat) &lt;- c("x","y")
tf &lt;- tempfile()
write.table(dat, tf, sep=",", dec=".")

mainWindow &lt;- tktoplevel()
tktitle(mainWindow) &lt;- "Barplot clustering"  
mainWindow$env$nb &lt;- tk2notebook(mainWindow, tabs = c())
tkpack(mainWindow$env$nb, fill="both", expand= TRUE)

x &lt;- importSample(file.features=tf)
method &lt;- "K-means"

x &lt;- computeUnSupervised(x, K=3, method.name=method)

abdPlotTabs(x$clustering, mainWindow$env$nb)


</code></pre>

<hr>
<h2 id='abdPlotTabsGUI'>Abundances barplots inside Tk tabs.</h2><span id='topic+abdPlotTabsGUI'></span>

<h3>Description</h3>

<p>Display the abundances barplot of a clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abdPlotTabsGUI(RclusTool.env = initParameters())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abdPlotTabsGUI_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>environment in which all global parameters, raw data and results are stored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>abdPlotTabsGUI calls abdPlotTabs to display the abundances barplot of the clusterings of the current RclusTool.env$data.sample, inside the GUI.
</p>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='addClustering'>Clustering addition</h2><span id='topic+addClustering'></span>

<h3>Description</h3>

<p>adds a new clustering to an existing set of clusterings (replaces if exists).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addClustering(clustering, new.clustering.name, new.cluster.summary, new.label)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addClustering_+3A_clustering">clustering</code></td>
<td>
<p>list containing a set of clustering results.</p>
</td></tr>
<tr><td><code id="addClustering_+3A_new.clustering.name">new.clustering.name</code></td>
<td>
<p>string naming the clustering to add.</p>
</td></tr>
<tr><td><code id="addClustering_+3A_new.cluster.summary">new.cluster.summary</code></td>
<td>
<p>summary object containing statistics about the new clustering.</p>
</td></tr>
<tr><td><code id="addClustering_+3A_new.label">new.label</code></td>
<td>
<p>vector of labels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>addClustering adds a new clustering to an existing set of clusterings (replaces if exists)
</p>


<h3>Value</h3>

<p>updated list of clusterings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))

tf &lt;- tempfile()
write.table(dat, tf, sep=",", dec=".")

x &lt;- importSample(file.features=tf)

res_new &lt;- KmeansQuick(x$features$initial$x, K=3)
labels_new &lt;- formatLabelSample(res_new$cluster, x)
cluster.summary.new &lt;- clusterSummary(x, labels_new)

x$clustering &lt;- addClustering(clustering=x$clustering, new.clustering.name='clusterin_test', 
                              new.cluster.summary=cluster.summary.new, new.label=labels_new)
 

</code></pre>

<hr>
<h2 id='addIds2Sampling'>Adding Ids To a Sampling</h2><span id='topic+addIds2Sampling'></span>

<h3>Description</h3>

<p>adds some observations to set of sampled observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addIds2Sampling(sampling, toAdd = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addIds2Sampling_+3A_sampling">sampling</code></td>
<td>
<p>object of a data sample.</p>
</td></tr>
<tr><td><code id="addIds2Sampling_+3A_toadd">toAdd</code></td>
<td>
<p>vector of ids to add.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>addIds2Sampling adds some observations to set of sampled observations.
</p>


<h3>Value</h3>

<p>The completed sampling object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf &lt;- tempfile()
write.table(dat, tf, sep=",", dec=".")
x &lt;- importSample(file.features=tf)

res.sampling &lt;- computeSampling(x$features$initial$x)
completed.sampling &lt;- addIds2Sampling(res.sampling, rownames(x$features$initial$x[1:5,,drop=FALSE]))


</code></pre>

<hr>
<h2 id='addOperation'>Add operation</h2><span id='topic+addOperation'></span>

<h3>Description</h3>

<p>addOperation create configuration object for the datasample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addOperation(parameterList, featureOperations)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addOperation_+3A_parameterlist">parameterList</code></td>
<td>
<p>list of Preprocessing instructions for an operation.</p>
</td></tr>
<tr><td><code id="addOperation_+3A_featureoperations">featureOperations</code></td>
<td>
<p>matrix where to list Operations on features.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The configuration object created by the list of preprocessing instructions <code>parameterList</code> in <code>featureOperations</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>featOp &lt;- matrix(ncol=4,nrow=0)
#Adding two differents variables
featOp &lt;- addOperation(list("+","x","y"), featOp)
#Select a variable
featOp &lt;- addOperation(list("select","x"), featOp)
#Change a profile color
featOp &lt;- addOperation(list("signalColor","x","grey"), featOp)
#Make a PCA projection (with the number of dimensions)
featOp &lt;- addOperation(list("projection","pca","0"), featOp)
#Make a spectral projection
featOp &lt;- addOperation(list("projection","spectral"), featOp)
#Scale the data
featOp &lt;- addOperation(list("scaling","on"), featOp)
#Sample the data (with a sampling size)
featOp &lt;- addOperation(list("sampling","150"), featOp)
#Make a log transformation of a variable
featOp &lt;- addOperation(list("log","x"), featOp)

</code></pre>

<hr>
<h2 id='analyzePlot'>Plot for data exploration/analysis</h2><span id='topic+analyzePlot'></span>

<h3>Description</h3>

<p>Create some specific plots for data exploration/analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyzePlot(
  nb,
  data.sample,
  selectedVar,
  type = "boxplot",
  hscale = 1.2,
  K.max = 20,
  fontsize = 11
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyzePlot_+3A_nb">nb</code></td>
<td>
<p>notebook in which the analyze plot will be added.</p>
</td></tr>
<tr><td><code id="analyzePlot_+3A_data.sample">data.sample</code></td>
<td>
<p>list containing features, profiles and clustering results.</p>
</td></tr>
<tr><td><code id="analyzePlot_+3A_selectedvar">selectedVar</code></td>
<td>
<p>character vector containing the selected variables names to analyze.</p>
</td></tr>
<tr><td><code id="analyzePlot_+3A_type">type</code></td>
<td>
<p>character vector specifying the analysis type. Must be 'boxplot', 'gapSE', 'histo', 'pcaCorr' or 'pcaVar'.</p>
</td></tr>
<tr><td><code id="analyzePlot_+3A_hscale">hscale</code></td>
<td>
<p>numeric value corresponding to the horizontal scale of graphic.</p>
</td></tr>
<tr><td><code id="analyzePlot_+3A_k.max">K.max</code></td>
<td>
<p>maximal number of clusters (K.Max=20 by default).</p>
</td></tr>
<tr><td><code id="analyzePlot_+3A_fontsize">fontsize</code></td>
<td>
<p>size of font (fontsize=11 by default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>analyzePlot creates specific plot for data exploration/analysis.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 6, sd = 0.3), ncol = 2))
colnames(dat) &lt;- c("x","y")
tf &lt;- tempfile()
write.table(dat, tf, sep=",", dec=".")

x &lt;- importSample(file.features=tf)

mainWindow &lt;- tktoplevel()
tktitle(mainWindow) &lt;- "Barplot clustering"  
mainWindow$env$nb &lt;- tk2notebook(mainWindow, tabs = c())
tkpack(mainWindow$env$nb, fill="both", expand= TRUE)

analyzePlot(mainWindow$env$nb, x, selectedVar="x", type="boxplot")


</code></pre>

<hr>
<h2 id='applyPreprocessing'>Preprocessing application</h2><span id='topic+applyPreprocessing'></span>

<h3>Description</h3>

<p>Apply a new preprocess to a data.sample object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>applyPreprocessing(
  data.sample,
  operations = NULL,
  RclusTool.env = initParameters(),
  reset = TRUE,
  preprocessed.only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="applyPreprocessing_+3A_data.sample">data.sample</code></td>
<td>
<p>sample object.</p>
</td></tr>
<tr><td><code id="applyPreprocessing_+3A_operations">operations</code></td>
<td>
<p>list of data.frames describing all preprocessing operations.</p>
</td></tr>
<tr><td><code id="applyPreprocessing_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>environment in which all global parameters, raw data and results are stored.</p>
</td></tr>
<tr><td><code id="applyPreprocessing_+3A_reset">reset</code></td>
<td>
<p>boolean : if TRUE (default) the configuration is reset.</p>
</td></tr>
<tr><td><code id="applyPreprocessing_+3A_preprocessed.only">preprocessed.only</code></td>
<td>
<p>boolean : if TRUE (default) processing are restricted to the &quot;preprocessed&quot; features.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>applyPreprocessing applies a new preprocess to a data.sample object
</p>


<h3>Value</h3>

<p>The <code>data.sample</code> sample object on which was applied the <code>operations</code> or NULL if preprocessing operations fail.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loadPreprocessFile">loadPreprocessFile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(150, mean = 2, sd = 0.3), ncol = 3), 
             matrix(rnorm(150, mean = 4, sd = 0.3), ncol = 3), 
             matrix(rnorm(150, mean = 6, sd = 0.3), ncol = 3))
colnames(dat) &lt;- c("x","y","z")
tf1 &lt;- tempfile()
write.table(dat, tf1, sep=";", dec=",")
x &lt;- importSample(file.features=tf1, sepFeat=";", decFeat=",")

instr &lt;- rbind(c("select","x","log",""), c("select","y","log",""))
tf2 &lt;- tempfile()
write.table(instr, tf2, sep=",", col.names = FALSE, row.names = FALSE)

operations &lt;- loadPreprocessFile(tf2)
x &lt;- applyPreprocessing(x, operations)


</code></pre>

<hr>
<h2 id='bipartitionShi'>Spectral clustering</h2><span id='topic+bipartitionShi'></span>

<h3>Description</h3>

<p>Perform spectral clustering thanks to a similarity matrix (according to Shi and Malik, 2000).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bipartitionShi(sim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bipartitionShi_+3A_sim">sim</code></td>
<td>
<p>similarity matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>bipartitionShi returns a partition obtained by spectral clustering (according to Shi and Malik, 2000)
</p>


<h3>Value</h3>

<p>The function returns a list containing:
</p>
<table>
<tr><td><code>label</code></td>
<td>
<p>vector of labels.</p>
</td></tr>
<tr><td><code>eigenvector</code></td>
<td>
<p>matrix containing, in columns, the eigenvectors of the similarity matrix.</p>
</td></tr>
<tr><td><code>eigenvalue</code></td>
<td>
<p>vector containing the eigenvalues of the similarity matrix.</p>
</td></tr>
</table>


<h3>References</h3>

<p>J. Shi, J. Malik, Normalized cuts and image segmentation, IEEE Transactions on Pattern Analysis and Machine Intelligence, 2000, 22(8), 888-905.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2))

sim &lt;- computeGaussianSimilarity(dat, 1)
res &lt;- bipartitionShi(sim)

plot(dat[,1], dat[,2], type = "p", xlab = "x", ylab = "y", 
col = res$label, main = "Initial features space")
plot(res$eigenvector, type = "p", xlab = "Indices", ylab = "1st eigenvector", 
col = res$label, main = "Spectral embedding")
</code></pre>

<hr>
<h2 id='buildBatchTab'>Batch process tab</h2><span id='topic+buildBatchTab'></span>

<h3>Description</h3>

<p>Generate the batch process tab of the <code><a href="#topic+RclusToolGUI">RclusToolGUI</a></code>, in which the user can choose and configure the classification method to apply on several datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildBatchTab(RclusTool.env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildBatchTab_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>environment in which data and intermediate results are stored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function to create the 'batchTab' for data clustering in batch process
</p>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='buildClusteringSample'>Clustering loading</h2><span id='topic+buildClusteringSample'></span>

<h3>Description</h3>

<p>Load a clustering result from a csv file into a data.sample object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildClusteringSample(filename.csv, data.sample, noise.cluster = "Noise")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildClusteringSample_+3A_filename.csv">filename.csv</code></td>
<td>
<p>character vector specifying the path and the name of the csv file containing the clustering result.</p>
</td></tr>
<tr><td><code id="buildClusteringSample_+3A_data.sample">data.sample</code></td>
<td>
<p>matrix of raw data (point by line).</p>
</td></tr>
<tr><td><code id="buildClusteringSample_+3A_noise.cluster">noise.cluster</code></td>
<td>
<p>character name of the cluster &quot;Noise&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>buildClusteringSample builds a clustering result from a csv file to be later embedded into a data.sample object
</p>


<h3>Value</h3>

<p>The function returns a list 'clustering' containing:
</p>
<table>
<tr><td><code>label</code></td>
<td>
<p>vector of labels.</p>
</td></tr>
<tr><td><code>summary</code></td>
<td>
<p>data.frame containing clusters summaries (min, max, sum, average, sd).</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>number of clusters.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+saveClustering">saveClustering</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf1 &lt;- tempfile()
write.table(dat, tf1, sep=",", dec=".")
x &lt;- importSample(file.features=tf1)

lab &lt;- data.frame(ID=1:nrow(dat), label=c(rep("Cluster 1",50), rep("Cluster 2",50), 
                                          rep("Cluster 3",50)))
tf2 &lt;- tempfile()
write.table(lab, tf2, sep=",")

clustering &lt;- buildClusteringSample(tf2, x)

</code></pre>

<hr>
<h2 id='buildConstraintsMatrix'>Constraints matrices</h2><span id='topic+buildConstraintsMatrix'></span>

<h3>Description</h3>

<p>Compute the constraints matrix C, based on ML and CNL sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildConstraintsMatrix(n, list.ML = list(), list.CNL = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildConstraintsMatrix_+3A_n">n</code></td>
<td>
<p>total number of observations.</p>
</td></tr>
<tr><td><code id="buildConstraintsMatrix_+3A_list.ml">list.ML</code></td>
<td>
<p>list of ML (must-link) constrained pairs.</p>
</td></tr>
<tr><td><code id="buildConstraintsMatrix_+3A_list.cnl">list.CNL</code></td>
<td>
<p>list of CNL (cannot-link) constrained pairs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>buildConstraintsMatrix generate constraints matrix, based on ML and CNL sets
</p>


<h3>Value</h3>

<p>C constraints matrix (with 1 for must-link and -1 for cannot-link).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
           
ML &lt;- list()
ML[[1]] &lt;- c(sel="10",mem="20")
ML[[2]] &lt;- c(sel="60",mem="70")

CNL &lt;- list()
CNL[[1]] &lt;- c(sel="30",mem="80")
CNL[[2]] &lt;- c(sel="90",mem="120")

C &lt;- buildConstraintsMatrix(n=nrow(dat), list.ML=ML, list.CNL=CNL)

</code></pre>

<hr>
<h2 id='buildImportTab'>Build Import tab</h2><span id='topic+buildImportTab'></span>

<h3>Description</h3>

<p>Generate the files importation tab of the <code><a href="#topic+RclusToolGUI">RclusToolGUI</a></code>, in which the user can select original files (features, metadata, signals or images).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildImportTab(RclusTool.env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildImportTab_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>environment in which data and intermediate results are stored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function to create the 'importTab' for data importation (features, metadata, signals and images)
</p>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='buildNameOperation'>Build Name Operation</h2><span id='topic+buildNameOperation'></span>

<h3>Description</h3>

<p>buildNameOperation build name of a single operation from its parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildNameOperation(formatedRow, lowercase = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildNameOperation_+3A_formatedrow">formatedRow</code></td>
<td>
<p>vector describing preprocessing operations</p>
</td></tr>
<tr><td><code id="buildNameOperation_+3A_lowercase">lowercase</code></td>
<td>
<p>boolean to build lowercase operation name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>name of a single operation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
formatedRow&lt;-c(arg1="log", arg2="x", arg3="", arg4="")
buildNameOperation(formatedRow)

</code></pre>

<hr>
<h2 id='buildPreprocessTab'>build Preprocess tab</h2><span id='topic+buildPreprocessTab'></span>

<h3>Description</h3>

<p>Generate the data preprocessing tab of the <code><a href="#topic+RclusToolGUI">RclusToolGUI</a></code>, in which the user can select, transform, filter or create variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildPreprocessTab(RclusTool.env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildPreprocessTab_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>environment in which data and intermediate results are stored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function to build the 'preprocessTab' for data preprocessing (variables selection, transformation, creation, ...)
</p>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='buildSemisupTab'>Semi-Supervised tab</h2><span id='topic+buildSemisupTab'></span>

<h3>Description</h3>

<p>Generate the semi-supervised classification tab of the <code><a href="#topic+RclusToolGUI">RclusToolGUI</a></code>, in which the user can choose and configure the semi-supervised method to apply.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildSemisupTab(RclusTool.env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildSemisupTab_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>environment in which data and intermediate results are stored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function to build the 'semisupTab' for semi-supervised classification
</p>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='buildsupTab'>Supervised tab</h2><span id='topic+buildsupTab'></span>

<h3>Description</h3>

<p>Generate the supervised classification tab of the <code><a href="#topic+RclusToolGUI">RclusToolGUI</a></code>, in which the user can choose and configure the supervised method to apply.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildsupTab(RclusTool.env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildsupTab_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>: environment in which data and intermediate results are stored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function to create the 'supTab' for supervised classification
</p>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='buildUnsupTab'>Unsupervised tab</h2><span id='topic+buildUnsupTab'></span>

<h3>Description</h3>

<p>This function generates the unsupervised classification tab of the <code><a href="#topic+RclusToolGUI">RclusToolGUI</a></code>, in which the user can choose and configure the clustering method to apply.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildUnsupTab(RclusTool.env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildUnsupTab_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>: environment in which data and intermediate results are stored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function to create the 'unsupTab' for data clustering
</p>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='clusterDensity'>Clusters density computation</h2><span id='topic+clusterDensity'></span>

<h3>Description</h3>

<p>Save density summaries results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterDensity(
  data.sample,
  label,
  space,
  features.to.keep = colnames(data.sample$features[[space]]$x)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterDensity_+3A_data.sample">data.sample</code></td>
<td>
<p>list containing features, profiles and clustering results.</p>
</td></tr>
<tr><td><code id="clusterDensity_+3A_label">label</code></td>
<td>
<p>vector of labels.</p>
</td></tr>
<tr><td><code id="clusterDensity_+3A_space">space</code></td>
<td>
<p>space in which is the feature to deal with.</p>
</td></tr>
<tr><td><code id="clusterDensity_+3A_features.to.keep">features.to.keep</code></td>
<td>
<p>vector of features names on which the summaries are computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>clusterDensity computes the clusters density from a clustering result.
</p>


<h3>Value</h3>

<p>out data.frame containing the density summaries.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf1 &lt;- tempfile()
write.table(dat, tf1, sep=",", dec=".")

x &lt;- importSample(file.features=tf1)
x &lt;- computeUnSupervised(x, K=3, method.name="K-means")

label&lt;-x[["clustering"]][["K-means_preprocessed"]][["label"]]

cluster.density &lt;- clusterDensity(x, label, "preprocessed", features.to.keep='V1')


</code></pre>

<hr>
<h2 id='clusterSummary'>Clusters summaries computation</h2><span id='topic+clusterSummary'></span>

<h3>Description</h3>

<p>Save clusters summaries results in a csv file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterSummary(
  data.sample,
  label,
  features.to.keep = colnames(data.sample$features[["preprocessed"]]$x),
  summary.functions = c(Min = "min", Max = "max", Sum = "sum", Average = "mean", SD =
    "sd")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterSummary_+3A_data.sample">data.sample</code></td>
<td>
<p>list containing features, profiles and clustering results.</p>
</td></tr>
<tr><td><code id="clusterSummary_+3A_label">label</code></td>
<td>
<p>vector of labels.</p>
</td></tr>
<tr><td><code id="clusterSummary_+3A_features.to.keep">features.to.keep</code></td>
<td>
<p>vector of features names on which the summaries are computed.</p>
</td></tr>
<tr><td><code id="clusterSummary_+3A_summary.functions">summary.functions</code></td>
<td>
<p>vector of functions names for the summaries computation. Could be 'Min', 'Max', 'Sum', 'Average', 'sd'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>clusterSummary computes the clusters summaries (min, max, sum, average, sd) from a clustering result.
</p>


<h3>Value</h3>

<p>out data.frame containing the clusters summaries.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf1 &lt;- tempfile()
write.table(dat, tf1, sep=",", dec=".")

x &lt;- importSample(file.features=tf1)
res &lt;- KmeansQuick(x$features$initial$x, K=3)
labels &lt;- formatLabelSample(res$cluster, x)
cluster.summary &lt;- clusterSummary(x, labels)


</code></pre>

<hr>
<h2 id='computeCKmeans'>Constrained K-means clustering</h2><span id='topic+computeCKmeans'></span>

<h3>Description</h3>

<p>Perform Constrained K-means clustering, dealing with the number of clusters K, automatically or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeCKmeans(
  x,
  K = 0,
  K.max = 20,
  mustLink = NULL,
  cantLink = NULL,
  maxIter = 2,
  kmeans.variance.min = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeCKmeans_+3A_x">x</code></td>
<td>
<p>matrix of raw data (point by line).</p>
</td></tr>
<tr><td><code id="computeCKmeans_+3A_k">K</code></td>
<td>
<p>number of clusters. If K=0 (default), this number is automatically computed thanks to the Elbow method.</p>
</td></tr>
<tr><td><code id="computeCKmeans_+3A_k.max">K.max</code></td>
<td>
<p>maximal number of clusters (K.Max=20 by default).</p>
</td></tr>
<tr><td><code id="computeCKmeans_+3A_mustlink">mustLink</code></td>
<td>
<p>list of ML (must-link) constrained pairs.</p>
</td></tr>
<tr><td><code id="computeCKmeans_+3A_cantlink">cantLink</code></td>
<td>
<p>list of CNL (cannot-link) constrained pairs.</p>
</td></tr>
<tr><td><code id="computeCKmeans_+3A_maxiter">maxIter</code></td>
<td>
<p>number of iterations for mpckm algorithm.</p>
</td></tr>
<tr><td><code id="computeCKmeans_+3A_kmeans.variance.min">kmeans.variance.min</code></td>
<td>
<p>elbow method cumulative explained variance &gt; criteria to stop K-search.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>computeCKmeans performs Constrained K-means clustering, dealing with the number of clusters K, automatically or not
</p>


<h3>Value</h3>

<p>res.ckmeans results obtained from mpckm algorithm.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeSemiSupervised">computeSemiSupervised</a></code>, <code><a href="#topic+KwaySSSC">KwaySSSC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf &lt;- tempfile()
write.table(dat, tf, sep=",", dec=".")
x &lt;- importSample(file.features=tf)

ML=list(c(sel="10",mem="20"))
CNL=list(c(sel="1",mem="140"))

res.ckmeans &lt;- computeCKmeans(x$features$initial$x, K=0, mustLink=ML, cantLink=CNL)

plot(dat[,1], dat[,2], type = "p", xlab = "x", ylab = "y", 
col = res.ckmeans$label, main = "Constrained K-means clustering")


</code></pre>

<hr>
<h2 id='computeCSC'>Constrained Spectral Clustering</h2><span id='topic+computeCSC'></span>

<h3>Description</h3>

<p>Perform Constrained Spectral Clustering from a similarity matrix computation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeCSC(
  x,
  K = 0,
  K.max = 20,
  mustLink = list(),
  cantLink = list(),
  alphas = seq(from = 0, to = 1, length = 100)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeCSC_+3A_x">x</code></td>
<td>
<p>matrix of raw data (point by line).</p>
</td></tr>
<tr><td><code id="computeCSC_+3A_k">K</code></td>
<td>
<p>number of clusters. If K=0 (default), this number is automatically computed thanks to the Elbow method.</p>
</td></tr>
<tr><td><code id="computeCSC_+3A_k.max">K.max</code></td>
<td>
<p>maximal number of clusters (K.Max=20 by default).</p>
</td></tr>
<tr><td><code id="computeCSC_+3A_mustlink">mustLink</code></td>
<td>
<p>list of ML (must-link) constrained pairs.</p>
</td></tr>
<tr><td><code id="computeCSC_+3A_cantlink">cantLink</code></td>
<td>
<p>list of CNL (cannot-link) constrained pairs.</p>
</td></tr>
<tr><td><code id="computeCSC_+3A_alphas">alphas</code></td>
<td>
<p>numeric vector for the weight of constraints considered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>computeCSC performs Constrained Spectral Clustering from a similarity matrix computation
</p>


<h3>Value</h3>

<p>res.csc results obtained from KwaySSSC algorithm.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeSemiSupervised">computeSemiSupervised</a></code>, <code><a href="#topic+KwaySSSC">KwaySSSC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf &lt;- tempfile()
write.table(dat, tf, sep=",", dec=".")
x &lt;- importSample(file.features=tf)

ML=list(c(sel="10",mem="20"))
CNL=list(c(sel="1",mem="140"))

res.csc &lt;- computeCSC(x$features$preprocessed$x, K=0, mustLink=ML, cantLink=CNL)
plot(dat[,1], dat[,2], type = "p", xlab = "x", ylab = "y", 
col = res.csc$label, main = "Constrained Spectral clustering")


</code></pre>

<hr>
<h2 id='computeEM'>Expectation-Maximization clustering</h2><span id='topic+computeEM'></span>

<h3>Description</h3>

<p>Perform Expectation-Maximization clustering, dealing with the number of clusters K, automatically or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeEM(
  x,
  K = 0,
  K.max = 20,
  kmeans.variance.min = 0.95,
  graph = FALSE,
  Mclust.options = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeEM_+3A_x">x</code></td>
<td>
<p>matrix of raw data (point by line).</p>
</td></tr>
<tr><td><code id="computeEM_+3A_k">K</code></td>
<td>
<p>number of clusters. If K=0 (default), this number is automatically computed thanks to the Elbow method.</p>
</td></tr>
<tr><td><code id="computeEM_+3A_k.max">K.max</code></td>
<td>
<p>maximal number of clusters (K.Max=20 by default).</p>
</td></tr>
<tr><td><code id="computeEM_+3A_kmeans.variance.min">kmeans.variance.min</code></td>
<td>
<p>elbow method cumulative explained variance &gt; criteria to stop K-search.</p>
</td></tr>
<tr><td><code id="computeEM_+3A_graph">graph</code></td>
<td>
<p>boolean: if TRUE, figures for total of within-class inertia and explained variance are plotted.</p>
</td></tr>
<tr><td><code id="computeEM_+3A_mclust.options">Mclust.options</code></td>
<td>
<p>list of default parameters values for the function Mclust.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>computeEM performs Expectation-Maximization clustering, dealing with the number of clusters K, automatically or not
</p>


<h3>Value</h3>

<p>res.EM results obtained from Mclust algorithm.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeUnSupervised">computeUnSupervised</a></code>, <code><a href="#topic+computeKmeans">computeKmeans</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf &lt;- tempfile()
write.table(dat, tf, sep=",", dec=".")

x &lt;- importSample(file.features=tf)
res.em &lt;- computeEM(x$features$initial$x, K=0, graph=TRUE)
plot(dat[,1], dat[,2], type = "p", xlab = "x", ylab = "y", 
col = res.em$classification, main = "EM clustering")


</code></pre>

<hr>
<h2 id='computeGap'>Gap computation</h2><span id='topic+computeGap'></span>

<h3>Description</h3>

<p>Estimate the number of clusters thanks to the gap computation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeGap(sim, Kmax)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeGap_+3A_sim">sim</code></td>
<td>
<p>similarity matrix.</p>
</td></tr>
<tr><td><code id="computeGap_+3A_kmax">Kmax</code></td>
<td>
<p>maximal number of clusters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>computeGap returns an estimated number of clusters
</p>


<h3>Value</h3>

<p>The function returns a list containing:
</p>
<table>
<tr><td><code>val</code></td>
<td>
<p>vector containing the eigenvalues of the similarity matrix.</p>
</td></tr>
<tr><td><code>gap</code></td>
<td>
<p>vector containing gap values between two successive eigenvalues.</p>
</td></tr>
<tr><td><code>Kmax</code></td>
<td>
<p>estimated number of clusters.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))

sim &lt;- computeGaussianSimilarity(dat, 1)
res &lt;- computeGap(sim, Kmax = 20)

plot(res$val[1:20], type = "o", ann = FALSE, axes = FALSE)
abline(v = res$Kmax, col = "darkred")
abline(h = res$val[res$Kmax], col = "darkred")
axis(side = 1, at = c(seq(0,20,by=5), res$Kmax), 
     labels = c(seq(0,20,by=5), res$Kmax), cex.axis = .7)
axis(side = 2)
title("Automatic estimation of number of clusters - Gap method")
mtext("Number of clusters", side = 1, line = 3)
mtext("Eigenvalue", side = 2, line = 3)
box()
</code></pre>

<hr>
<h2 id='computeGap2'>Gap computation</h2><span id='topic+computeGap2'></span>

<h3>Description</h3>

<p>Estimate the number of clusters thanks to the gap computation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeGap2(sim, Kmax)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeGap2_+3A_sim">sim</code></td>
<td>
<p>similarity matrix.</p>
</td></tr>
<tr><td><code id="computeGap2_+3A_kmax">Kmax</code></td>
<td>
<p>maximal number of clusters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>computeGap2 returns an estimated number of clusters
</p>


<h3>Value</h3>

<p>The function returns a list containing:
</p>
<table>
<tr><td><code>val</code></td>
<td>
<p>vector containing the eigenvalues of the similarity matrix.</p>
</td></tr>
<tr><td><code>gap</code></td>
<td>
<p>vector containing gap values between two successive eigenvalues.</p>
</td></tr>
<tr><td><code>Kmax</code></td>
<td>
<p>estimated number of clusters.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))

sim &lt;- computeGaussianSimilarity(dat, 1)
res &lt;- computeGap2(sim, Kmax = 20)

plot(res$val[1:20], type = "o", ann = FALSE, axes = FALSE)
abline(v = res$Kmax, col = "darkred")
abline(h = res$val[res$Kmax], col = "darkred")
axis(side = 1, at = c(seq(0,20,by=5), res$Kmax), 
     labels = c(seq(0,20,by=5), res$Kmax), cex.axis = .7)
axis(side = 2)
title("Automatic estimation of number of clusters - Gap method")
mtext("Number of clusters", side = 1, line = 3)
mtext("Eigenvalue", side = 2, line = 3)
box()
</code></pre>

<hr>
<h2 id='computeGaussianSimilarity'>Gaussian similarity</h2><span id='topic+computeGaussianSimilarity'></span>

<h3>Description</h3>

<p>Compute a similarity matrix thanks a Gaussian kernel from a data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeGaussianSimilarity(dat, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeGaussianSimilarity_+3A_dat">dat</code></td>
<td>
<p>numeric matrix of data (point by line).</p>
</td></tr>
<tr><td><code id="computeGaussianSimilarity_+3A_sigma">sigma</code></td>
<td>
<p>smooth parameter of Gaussian kernel.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>computeGaussianSimilarity returns a similarity matrix computed thanks a Gaussian kernel
</p>


<h3>Value</h3>

<p>sim similarity matrix.
</p>


<h3>References</h3>

<p>U. Von Luxburg, A tutorial on spectral clustering, Statist. Comput., 17 (4) (2007), pp. 395-416
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeGaussianSimilarityZP">computeGaussianSimilarityZP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(grDevices)

dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))

sim &lt;- computeGaussianSimilarity(dat, 1)

pal &lt;- colorRampPalette(c("blue", "red"))
image(sim, col = pal(10))
</code></pre>

<hr>
<h2 id='computeGaussianSimilarityZP'>Gaussian similarity</h2><span id='topic+computeGaussianSimilarityZP'></span>

<h3>Description</h3>

<p>Compute a similarity matrix thanks a Gaussian kernel for which the parameters are self-tuned (according to Zelnik-Manor and Perona, 2004).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeGaussianSimilarityZP(dat, k = 7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeGaussianSimilarityZP_+3A_dat">dat</code></td>
<td>
<p>numeric matrix of data (point by line).</p>
</td></tr>
<tr><td><code id="computeGaussianSimilarityZP_+3A_k">k</code></td>
<td>
<p>number of neighbour for the computation of local sigma (smooth parameter of Gaussian kernel).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>computeGaussianSimilarityZP returns a similarity matrix computed thanks a Gaussian kernel for which the parameters are self-tuned (according to Zelnik-Manor and Perona, 2004)
</p>


<h3>Value</h3>

<p>sim similarity matrix.
</p>


<h3>References</h3>

<p>L. Zelnik-Manor, P. Perona, Self tuning spectral clustering, Adv. Neural Inf. Process. Systems (2004), pp. 1601-1608.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeGaussianSimilarity">computeGaussianSimilarity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(grDevices)

dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))

sim &lt;- computeGaussianSimilarityZP(dat, 10)

pal &lt;- colorRampPalette(c("blue", "red"))
image(sim, col = pal(10))
</code></pre>

<hr>
<h2 id='computeItemsSample'>Prediction of number of cells in colonies</h2><span id='topic+computeItemsSample'></span>

<h3>Description</h3>

<p>Apply a specific predictive model for counting of number of cells in colonies for each cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeItemsSample(data.sample, method, cluster, modelFile = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeItemsSample_+3A_data.sample">data.sample</code></td>
<td>
<p>list containing features, profiles and clustering results.</p>
</td></tr>
<tr><td><code id="computeItemsSample_+3A_method">method</code></td>
<td>
<p>character vector specifying the name of the clustering result to use.</p>
</td></tr>
<tr><td><code id="computeItemsSample_+3A_cluster">cluster</code></td>
<td>
<p>character vector specifying the name of the cluster to consider for the application of the specific model.</p>
</td></tr>
<tr><td><code id="computeItemsSample_+3A_modelfile">modelFile</code></td>
<td>
<p>character vector specifying the path and the name of the RData model file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>computeItemsSample applies a specific predictive model for counting of number of cells in colonies for each cluster
</p>


<h3>Value</h3>

<p>data.sample list containing features, profiles and clustering results with the number of cells for each particle.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+itemsModel">itemsModel</a></code>, <code><a href="#topic+countItems">countItems</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
dat &lt;- rbind(matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 6, sd = 0.3), ncol = 2))

colnames(dat) &lt;- c("x","y")
tf &lt;- tempfile()
write.table(dat, tf, sep=",", dec=".")
x &lt;- importSample(file.features=tf)

x &lt;- computeUnSupervised(x, K=3, method.name="K-means")
x &lt;- computeItemsSample(x, method="K-means", cluster="Cluster 1", modelFile=NULL)# to be fixed !



</code></pre>

<hr>
<h2 id='computeItemsSampleGUI'>GUI to estimate the number of cells in colonies for each cluster</h2><span id='topic+computeItemsSampleGUI'></span>

<h3>Description</h3>

<p>Open a Graphical User Interface allowing to choose cluster name and model file for the estimation and the saving of the number of cells in colonies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeItemsSampleGUI(
  data.sample,
  method.select = "K-means",
  RclusTool.env = initParameters()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeItemsSampleGUI_+3A_data.sample">data.sample</code></td>
<td>
<p>list containing features, profiles and clustering results.</p>
</td></tr>
<tr><td><code id="computeItemsSampleGUI_+3A_method.select">method.select</code></td>
<td>
<p>character vector specifying the name of the clustering result to use ('K-means' by default).</p>
</td></tr>
<tr><td><code id="computeItemsSampleGUI_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>environment in which all global parameters, raw data and results are stored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>computeItemsSampleGUI opens a Graphical User Interface allowing to choose cluster name and model file for the estimation and the saving of the number of cells in colonies
</p>


<h3>Value</h3>

<p>data.sample with saved count results
</p>
<p>csv file containing the counts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 

dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf &lt;- tempfile()
write.table(dat, tf, sep=",", dec=".")
x &lt;- importSample(file.features=tf)

x &lt;- computeUnSupervised(x, K=0, pca=TRUE, echo=TRUE)
computeItemsSampleGUI(x, method.select="K-means")
 

</code></pre>

<hr>
<h2 id='computeKmeans'>K-means clustering</h2><span id='topic+computeKmeans'></span>

<h3>Description</h3>

<p>Perform K-means clustering, dealing with the number of clusters K, automatically or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeKmeans(x, K = 0, K.max = 20, kmeans.variance.min = 0.95, graph = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeKmeans_+3A_x">x</code></td>
<td>
<p>matrix of raw data (point by line).</p>
</td></tr>
<tr><td><code id="computeKmeans_+3A_k">K</code></td>
<td>
<p>number of clusters. If K=0 (default), this number is automatically computed thanks to the Elbow method.</p>
</td></tr>
<tr><td><code id="computeKmeans_+3A_k.max">K.max</code></td>
<td>
<p>maximal number of clusters (K.Max=20 by default).</p>
</td></tr>
<tr><td><code id="computeKmeans_+3A_kmeans.variance.min">kmeans.variance.min</code></td>
<td>
<p>elbow method cumulative explained variance &gt; criteria to stop K-search.</p>
</td></tr>
<tr><td><code id="computeKmeans_+3A_graph">graph</code></td>
<td>
<p>boolean: if TRUE, figures for total of within-class inertia and explained variance are plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>computeKmeans performs K-means clustering, dealing with the number of clusters K, automatically or not
</p>


<h3>Value</h3>

<p>res.kmeans results obtained from kmeans algorithm.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeUnSupervised">computeUnSupervised</a></code>, <code><a href="#topic+computeEM">computeEM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf &lt;- tempfile()
write.table(dat, tf, sep=",", dec=".")

x &lt;- importSample(file.features=tf)
res.kmeans &lt;- computeKmeans(x$features$initial$x, K=0, graph=TRUE)
plot(dat[,1], dat[,2], type = "p", xlab = "x", ylab = "y", 
col = res.kmeans$cluster, main = "K-means clustering")



</code></pre>

<hr>
<h2 id='computePcaNbDims'>Number of dimensions for PCA</h2><span id='topic+computePcaNbDims'></span>

<h3>Description</h3>

<p>Compute the number of dimensions to keep after a Principal Components Analysis, according to a threshold on the cumulative variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computePcaNbDims(sdev, pca.variance.cum.min = 0.9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computePcaNbDims_+3A_sdev">sdev</code></td>
<td>
<p>standard deviation of the principal components (returned from prcomp).</p>
</td></tr>
<tr><td><code id="computePcaNbDims_+3A_pca.variance.cum.min">pca.variance.cum.min</code></td>
<td>
<p>minimal cumulative variance to retain.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>computePcaNbDims computes the number of dimensions to keep after a Principal Components Analysis, according to a threshold on the cumulative variance
</p>


<h3>Value</h3>

<p>pca.nb.dims number of dimensions kept.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computePcaSample">computePcaSample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf &lt;- tempfile()
write.table(dat, tf, sep=",", dec=".")

x &lt;- importSample(file.features=tf)
res.pca &lt;- computePcaSample(x)
computePcaNbDims(res.pca$pca$sdev)



</code></pre>

<hr>
<h2 id='computePcaSample'>Principal Components Analysis</h2><span id='topic+computePcaSample'></span>

<h3>Description</h3>

<p>Perform Principal Components Analysis, dealing with the number of dimensions, automatically or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computePcaSample(
  data.sample,
  pca.nb.dims = 0,
  selected.var = NULL,
  echo = FALSE,
  prcomp.options = list(center = TRUE, scale = TRUE),
  pca.variance.cum.min = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computePcaSample_+3A_data.sample">data.sample</code></td>
<td>
<p>list containing features, profiles and clustering results.</p>
</td></tr>
<tr><td><code id="computePcaSample_+3A_pca.nb.dims">pca.nb.dims</code></td>
<td>
<p>number of dimensions to keep after PCA. If pca.nb.dims=0 (default), this number is automatically computed.</p>
</td></tr>
<tr><td><code id="computePcaSample_+3A_selected.var">selected.var</code></td>
<td>
<p>vector of features names to consider for the PCA.</p>
</td></tr>
<tr><td><code id="computePcaSample_+3A_echo">echo</code></td>
<td>
<p>boolean: if FALSE (default), no description printed in the console.</p>
</td></tr>
<tr><td><code id="computePcaSample_+3A_prcomp.options">prcomp.options</code></td>
<td>
<p>list of default parameters values for the function prcomp.</p>
</td></tr>
<tr><td><code id="computePcaSample_+3A_pca.variance.cum.min">pca.variance.cum.min</code></td>
<td>
<p>minimal cumulative variance to retain in PCA.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>computePcaSample performs Principal Components Analysis, dealing with the number of dimensions, automatically or not
</p>


<h3>Value</h3>

<p>features list containing the results of PCA, returned by prcomp.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeSpectralEmbeddingSample">computeSpectralEmbeddingSample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf &lt;- tempfile()
write.table(dat, tf, sep=",", dec=".")
x &lt;- importSample(file.features=tf)

res &lt;- computePcaSample(x, echo = TRUE)

plot(res$pca_full$x[,1], res$pca_full$x[,2], main="PCA", xlab="PC1", ylab="PC2")


</code></pre>

<hr>
<h2 id='computeSampling'>Sampling raw data matrix</h2><span id='topic+computeSampling'></span>

<h3>Description</h3>

<p>computes sampling on raw data matrix to reduce the number of observations, with generalization step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeSampling(
  x,
  label = NULL,
  K = 0,
  toKeep = NULL,
  sampling.size.max = 3000,
  K.max = 20,
  kmeans.variance.min = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeSampling_+3A_x">x</code></td>
<td>
<p>matrix of raw data (point by line).</p>
</td></tr>
<tr><td><code id="computeSampling_+3A_label">label</code></td>
<td>
<p>vector of (named) labels.</p>
</td></tr>
<tr><td><code id="computeSampling_+3A_k">K</code></td>
<td>
<p>number of clusters. If K=0 (default), this number is automatically computed thanks to the Elbow method.</p>
</td></tr>
<tr><td><code id="computeSampling_+3A_tokeep">toKeep</code></td>
<td>
<p>vector of row.names to keep in the sample (for constrained algorithms).</p>
</td></tr>
<tr><td><code id="computeSampling_+3A_sampling.size.max">sampling.size.max</code></td>
<td>
<p>maximal number of observations to keep in the sample.</p>
</td></tr>
<tr><td><code id="computeSampling_+3A_k.max">K.max</code></td>
<td>
<p>maximal number of clusters (K.Max=20 by default).</p>
</td></tr>
<tr><td><code id="computeSampling_+3A_kmeans.variance.min">kmeans.variance.min</code></td>
<td>
<p>elbow method cumulative explained variance &gt; criteria to stop K-search.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>computeSampling computes sampling on raw data matrix to reduce the number of observations, with generalization step.
</p>


<h3>Value</h3>

<p>The function returns a list containing:
</p>
<table>
<tr><td><code>selection.ids</code></td>
<td>
<p>vector of selected row.names in the sample.</p>
</td></tr>
<tr><td><code>selection.labs</code></td>
<td>
<p>vector of selected labels in the sample.</p>
</td></tr>
<tr><td><code>matching</code></td>
<td>
<p>character specifying the matching for all observations and used for generalization of the clustering result.</p>
</td></tr>
<tr><td><code>size.max</code></td>
<td>
<p>maximal number of observations kept in the sample.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>number of clusters.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf &lt;- tempfile()
write.table(dat, tf, sep=",", dec=".")
x &lt;- importSample(file.features=tf)

res.sampling &lt;- computeSampling(x$features$initial$x)


</code></pre>

<hr>
<h2 id='computeSemiSupervised'>Semi-supervised clustering</h2><span id='topic+computeSemiSupervised'></span>

<h3>Description</h3>

<p>Perform semi-supervised clustering based on pairwise constraints, dealing with the number of clusters K, automatically or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeSemiSupervised(
  data.sample,
  ML,
  CNL,
  K = 0,
  kmax = 20,
  method.name = "Constrained_KM",
  maxIter = 2,
  pca = FALSE,
  pca.nb.dims = 0,
  spec = FALSE,
  use.sampling = FALSE,
  sampling.size.max = 0,
  scaling = FALSE,
  RclusTool.env = initParameters(),
  echo = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeSemiSupervised_+3A_data.sample">data.sample</code></td>
<td>
<p>list containing features, profiles and clustering results.</p>
</td></tr>
<tr><td><code id="computeSemiSupervised_+3A_ml">ML</code></td>
<td>
<p>list of ML (must-link) constrained pairs (as row.names of features).</p>
</td></tr>
<tr><td><code id="computeSemiSupervised_+3A_cnl">CNL</code></td>
<td>
<p>list of CNL (cannot-link) constrained pairs (as row.names of features).</p>
</td></tr>
<tr><td><code id="computeSemiSupervised_+3A_k">K</code></td>
<td>
<p>number of clusters. If K=0 (default), this number is automatically computed thanks to the Elbow method.</p>
</td></tr>
<tr><td><code id="computeSemiSupervised_+3A_kmax">kmax</code></td>
<td>
<p>maximum number of clusters.</p>
</td></tr>
<tr><td><code id="computeSemiSupervised_+3A_method.name">method.name</code></td>
<td>
<p>character vector specifying the constrained algorithm to use. Must be 'Constrained_KM' (default) or 'Constrained_SC' (Constrained Spectral Clustering).</p>
</td></tr>
<tr><td><code id="computeSemiSupervised_+3A_maxiter">maxIter</code></td>
<td>
<p>number of iterations for SemiSupervised algorithm</p>
</td></tr>
<tr><td><code id="computeSemiSupervised_+3A_pca">pca</code></td>
<td>
<p>boolean: if TRUE, Principal Components Analysis is applied to reduce the data space.</p>
</td></tr>
<tr><td><code id="computeSemiSupervised_+3A_pca.nb.dims">pca.nb.dims</code></td>
<td>
<p>number of principal components kept. If pca.nb.dims=0, this number is computed automatically.</p>
</td></tr>
<tr><td><code id="computeSemiSupervised_+3A_spec">spec</code></td>
<td>
<p>boolean: if TRUE, spectral embedding is applied to reduce the data space.</p>
</td></tr>
<tr><td><code id="computeSemiSupervised_+3A_use.sampling">use.sampling</code></td>
<td>
<p>boolean: if FALSE (default), data sampling is not used.</p>
</td></tr>
<tr><td><code id="computeSemiSupervised_+3A_sampling.size.max">sampling.size.max</code></td>
<td>
<p>numeric: maximal size of the sampling set.</p>
</td></tr>
<tr><td><code id="computeSemiSupervised_+3A_scaling">scaling</code></td>
<td>
<p>boolean: if TRUE, scaling is applied.</p>
</td></tr>
<tr><td><code id="computeSemiSupervised_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>environment in which data and intermediate results are stored.</p>
</td></tr>
<tr><td><code id="computeSemiSupervised_+3A_echo">echo</code></td>
<td>
<p>boolean: if FALSE (default), no description printed in the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>computeSemiSupervised performs semi-supervised clustering based on pairwise constraints, dealing with the number of clusters K, automatically or not
</p>


<h3>Value</h3>

<p>The function returns a list containing:
</p>
<table>
<tr><td><code>label</code></td>
<td>
<p>vector of labels.</p>
</td></tr>
<tr><td><code>summary</code></td>
<td>
<p>data.frame containing clusters summaries (min, max, sum, average, sd).</p>
</td></tr>
<tr><td><code>nbItems</code></td>
<td>
<p>number of observations.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+computeCKmeans">computeCKmeans</a></code>, <code><a href="#topic+computeCSC">computeCSC</a></code>, <code><a href="#topic+KwaySSSC">KwaySSSC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf &lt;- tempfile()
write.table(dat, tf, sep=",", dec=".")
x &lt;- importSample(file.features=tf)

pairs.abs &lt;- visualizeSampleClustering(x, selection.mode = "pairs", 
		    profile.mode="whole sample", wait.close=TRUE)

res.ckm &lt;- computeSemiSupervised(x, ML=pairs.abs$ML, CNL=pairs.abs$CNL, K=0)
plot(dat[,1], dat[,2], type = "p", xlab = "x", ylab = "y",
    col = res.ckm$label, main = "Constrained K-means clustering")




</code></pre>

<hr>
<h2 id='computeSpectralEmbeddingSample'>Spectral embedding</h2><span id='topic+computeSpectralEmbeddingSample'></span>

<h3>Description</h3>

<p>Perform spectral embedding for non-linear dimensionality reduction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeSpectralEmbeddingSample(
  data.sample,
  use.sampling = FALSE,
  sampling.size.max = 0,
  scale = FALSE,
  selected.var = NULL,
  echo = FALSE,
  RclusTool.env = initParameters()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeSpectralEmbeddingSample_+3A_data.sample">data.sample</code></td>
<td>
<p>list containing features, profiles and clustering results.</p>
</td></tr>
<tr><td><code id="computeSpectralEmbeddingSample_+3A_use.sampling">use.sampling</code></td>
<td>
<p>boolean: if FALSE (default), data sampling is not used.</p>
</td></tr>
<tr><td><code id="computeSpectralEmbeddingSample_+3A_sampling.size.max">sampling.size.max</code></td>
<td>
<p>numeric: maximal size of the sampling set.</p>
</td></tr>
<tr><td><code id="computeSpectralEmbeddingSample_+3A_scale">scale</code></td>
<td>
<p>boolean, if FALSE (default), data scaling is not used.</p>
</td></tr>
<tr><td><code id="computeSpectralEmbeddingSample_+3A_selected.var">selected.var</code></td>
<td>
<p>vector of features names to consider for the spectral embedding.</p>
</td></tr>
<tr><td><code id="computeSpectralEmbeddingSample_+3A_echo">echo</code></td>
<td>
<p>boolean: if FALSE (default), no description printed in the console.</p>
</td></tr>
<tr><td><code id="computeSpectralEmbeddingSample_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>environment in which all global parameters, raw data and results are stored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>computeSpectralEmbeddingSample performs Spectral embedding for non-linear dimensionality reduction
</p>


<h3>Value</h3>

<p>features list containing the results of spectral embedding, returned by spectralEmbeddingNg.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computePcaSample">computePcaSample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf &lt;- tempfile()
write.table(dat, tf, sep=",", dec=".")
x &lt;- importSample(file.features=tf)

res &lt;- computeSpectralEmbeddingSample(x)

plot(res$x[,1], res$x[,2], main="Spectral Embedding", xlab="SC1", ylab="SC2")


</code></pre>

<hr>
<h2 id='computeSupervised'>Supervised classification</h2><span id='topic+computeSupervised'></span>

<h3>Description</h3>

<p>Perform supervised classification based on the use of a training set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeSupervised(
  data.sample,
  prototypes,
  method.name = "K-NN",
  model = NULL,
  RclusTool.env = initParameters()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeSupervised_+3A_data.sample">data.sample</code></td>
<td>
<p>list containing features, profiles and clustering results.</p>
</td></tr>
<tr><td><code id="computeSupervised_+3A_prototypes">prototypes</code></td>
<td>
<p>data.frame containing the features of each prototype associated to a class.</p>
</td></tr>
<tr><td><code id="computeSupervised_+3A_method.name">method.name</code></td>
<td>
<p>character vector specifying the supervised algorithm to use. Must be 'K-NN' (K-Nearest Neighbor by default), 'MLP' (MultiLayer Perceptron), 'SVM' (Support Vector Machine) or 'RF' (Random Forest).</p>
</td></tr>
<tr><td><code id="computeSupervised_+3A_model">model</code></td>
<td>
<p>option to predict directly from model</p>
</td></tr>
<tr><td><code id="computeSupervised_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>environment in which all global parameters, raw data and results are stored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>computeSupervised performs supervised classification based on the use of a training set
</p>


<h3>Value</h3>

<p>The function returns a list containing:
</p>
<table>
<tr><td><code>label</code></td>
<td>
<p>vector of labels.</p>
</td></tr>
<tr><td><code>summary</code></td>
<td>
<p>data.frame containing classes summaries (min, max, sum, average, sd).</p>
</td></tr>
<tr><td><code>nbItems</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code>prototypes</code></td>
<td>
<p>data.frame containing the features of each prototype associated to a class.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+readTrainSet">readTrainSet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rep &lt;- system.file("extdata", package="RclusTool")
featuresFile &lt;- file.path(rep, "sample_example_features.csv")
features &lt;- read.csv(featuresFile, header = TRUE)
features$ID &lt;- NULL
traindir &lt;- file.path(rep, "train_example")
tf &lt;- tempfile()
write.table(features, tf, sep=",", dec=".")

x &lt;- importSample(file.features=tf, dir.save=dirname(tf))

train &lt;- readTrainSet(traindir)

res &lt;- computeSupervised(x, prototypes=train)

plot(features[,3], features[,4], type = "p", xlab = "x", ylab = "y", 
col = res$label, main = "K-Nearest-Neighbor classification")


</code></pre>

<hr>
<h2 id='computeUnSupervised'>Unsupervised clustering</h2><span id='topic+computeUnSupervised'></span>

<h3>Description</h3>

<p>Perform unsupervised clustering, dealing with the number of clusters K, automatically or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeUnSupervised(
  data.sample,
  K = 0,
  method.name = "K-means",
  pca = FALSE,
  pca.nb.dims = 0,
  spec = FALSE,
  use.sampling = FALSE,
  sampling.size.max = 0,
  scaling = FALSE,
  RclusTool.env = initParameters(),
  echo = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeUnSupervised_+3A_data.sample">data.sample</code></td>
<td>
<p>list containing features, profiles and clustering results.</p>
</td></tr>
<tr><td><code id="computeUnSupervised_+3A_k">K</code></td>
<td>
<p>number of clusters. If K=0 (default), this number is automatically computed thanks to the Elbow method.</p>
</td></tr>
<tr><td><code id="computeUnSupervised_+3A_method.name">method.name</code></td>
<td>
<p>character vector specifying the constrained algorithm to use. Must be 'K-means' (default), 'EM' (Expectation-Maximization), 'Spectral', 'HC' (Hierarchical Clustering) or 'PAM' (Partitioning Around Medoids).</p>
</td></tr>
<tr><td><code id="computeUnSupervised_+3A_pca">pca</code></td>
<td>
<p>boolean: if TRUE, Principal Components Analysis is applied to reduce the data space.</p>
</td></tr>
<tr><td><code id="computeUnSupervised_+3A_pca.nb.dims">pca.nb.dims</code></td>
<td>
<p>number of principal components kept. If pca.nb.dims=0, this number is computed automatically.</p>
</td></tr>
<tr><td><code id="computeUnSupervised_+3A_spec">spec</code></td>
<td>
<p>boolean: if TRUE, spectral embedding is applied to reduce the data space.</p>
</td></tr>
<tr><td><code id="computeUnSupervised_+3A_use.sampling">use.sampling</code></td>
<td>
<p>boolean: if FALSE (default), data sampling is not used.</p>
</td></tr>
<tr><td><code id="computeUnSupervised_+3A_sampling.size.max">sampling.size.max</code></td>
<td>
<p>numeric: maximal size of the sampling set.</p>
</td></tr>
<tr><td><code id="computeUnSupervised_+3A_scaling">scaling</code></td>
<td>
<p>boolean: if TRUE, scaling is applied.</p>
</td></tr>
<tr><td><code id="computeUnSupervised_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>environment in which all global parameters, raw data and results are stored.</p>
</td></tr>
<tr><td><code id="computeUnSupervised_+3A_echo">echo</code></td>
<td>
<p>boolean: if FALSE (default), no description printed in the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>computeUnSupervised performs unsupervised clustering, dealing with the number of clusters K, automatically or not
</p>


<h3>Value</h3>

<p>data.sample list containing features, profiles and updated clustering results (with vector of labels and clusters summaries).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeKmeans">computeKmeans</a></code>, <code><a href="#topic+computeEM">computeEM</a></code>, <code><a href="#topic+spectralClustering">spectralClustering</a></code>, <code><a href="#topic+computePcaSample">computePcaSample</a></code>, <code><a href="#topic+computeSpectralEmbeddingSample">computeSpectralEmbeddingSample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf &lt;- tempfile()
write.table(dat, tf, sep=",", dec=".")
x &lt;- importSample(file.features=tf)

x &lt;- computeUnSupervised(x, K=0, pca=TRUE, echo=TRUE)
label &lt;- x$clustering[["K-means_pca"]]$label
plot(dat[,1], dat[,2], type = "p", xlab = "x", ylab = "y", 
    col = label, main = "K-means clustering")


</code></pre>

<hr>
<h2 id='convNamesPairsToIndexPairs'>Conversion of a set of names pairs to matrix of index pairs (2 columns)</h2><span id='topic+convNamesPairsToIndexPairs'></span>

<h3>Description</h3>

<p>Performs conversion of list of names pairs to a matrix of index pairs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convNamesPairsToIndexPairs(pair.list, full.name.set)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convNamesPairsToIndexPairs_+3A_pair.list">pair.list</code></td>
<td>
<p>list of names pairs (vector of 2 names).</p>
</td></tr>
<tr><td><code id="convNamesPairsToIndexPairs_+3A_full.name.set">full.name.set</code></td>
<td>
<p>a vector of unique names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>convNamesPairsToIndexPairs performs conversion of list of names pairs to a matrix of index pairs.
</p>


<h3>Value</h3>

<p>the 2-column matrix of pairs of indexes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeSemiSupervised">computeSemiSupervised</a></code>, <code><a href="#topic+KwaySSSC">KwaySSSC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("a"=10, "b"=20, "c"=30 )

ML &lt;- list()
ML[[1]] &lt;- c("a","c")
ML[[2]] &lt;- c("c","d")

mustLink&lt;-convNamesPairsToIndexPairs(ML,names(x))

</code></pre>

<hr>
<h2 id='convNamesToIndex'>Conversion of element names to indexes</h2><span id='topic+convNamesToIndex'></span>

<h3>Description</h3>

<p>Performs conversion of an element name to its index inside a set of named objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convNamesToIndex(name.sample, full.name.set)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convNamesToIndex_+3A_name.sample">name.sample</code></td>
<td>
<p>a vector of element names.</p>
</td></tr>
<tr><td><code id="convNamesToIndex_+3A_full.name.set">full.name.set</code></td>
<td>
<p>a vector of unique names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>convNamesToIndex performs conversion of an element name to its index inside a set of named objects
</p>


<h3>Value</h3>

<p>the vector of indexes of the element named.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeSemiSupervised">computeSemiSupervised</a></code>, <code><a href="#topic+KwaySSSC">KwaySSSC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("a"=10, "b"=20, "c"=30 )

convNamesToIndex(c("b","a","c"),names(x))

</code></pre>

<hr>
<h2 id='cor.mtest'>Correlation test.</h2><span id='topic+cor.mtest'></span>

<h3>Description</h3>

<p>Display the abundances barplot of a clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor.mtest(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor.mtest_+3A_mat">mat</code></td>
<td>
<p>correlation matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>cor.mtest Correlation test on correlation matrix.
</p>


<h3>Value</h3>

<p>matrix with p-values.
</p>


<h3>References</h3>

<p><a href="http://www.sthda.com/french/wiki/visualiser-une-matrice-de-correlation-par-un-correlogramme">http://www.sthda.com/french/wiki/visualiser-une-matrice-de-correlation-par-un-correlogramme</a>
</p>

<hr>
<h2 id='countItems'>Manually counting the number of cells in colonies</h2><span id='topic+countItems'></span>

<h3>Description</h3>

<p>Display the profile and the image of each particle and allow the user to manually count the number of cells by simple left-clicking on each of them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countItems(profile, feature = NULL, imgdir = NULL, image = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="countItems_+3A_profile">profile</code></td>
<td>
<p>matrix of profile data (signals in columns).</p>
</td></tr>
<tr><td><code id="countItems_+3A_feature">feature</code></td>
<td>
<p>vector of features data.</p>
</td></tr>
<tr><td><code id="countItems_+3A_imgdir">imgdir</code></td>
<td>
<p>character vector specifying the path of the images directory.</p>
</td></tr>
<tr><td><code id="countItems_+3A_image">image</code></td>
<td>
<p>character vector specifying the name of the considered image in imgdir.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>countItems displays the profile and the image of each particle and allows the user to manually count the number of cells by simple left-clicking on each of them
</p>


<h3>Value</h3>

<p>nbItemsTot number of cells manually counted on each image.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+itemsModel">itemsModel</a></code>, <code><a href="#topic+computeItemsSample">computeItemsSample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
dat &lt;- rbind(matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 6, sd = 0.3), ncol = 2))
colnames(dat) &lt;- c("x","y")
tf1 &lt;- tempfile()
write.table(dat, tf1, sep=",", dec=".")

sig &lt;- data.frame(ID=rep(1:150, each=30), SIGNAL=rep(dnorm(seq(-2,2,length=30)),150))
tf2 &lt;- tempfile()
write.table(sig, tf2, sep=",", dec=".")

x &lt;- importSample(file.features=tf1, file.profiles=tf2)

nbItems &lt;- countItems(x$profiles[[1]])



</code></pre>

<hr>
<h2 id='countItemsSampleGUI'>GUI to manually count the number of cells in colonies</h2><span id='topic+countItemsSampleGUI'></span>

<h3>Description</h3>

<p>Open a Graphical User Interface allowing to choose the images directory, to count manually the number of cells in colonies and to build specific predictive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countItemsSampleGUI(data.sample, RclusTool.env = initParameters())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="countItemsSampleGUI_+3A_data.sample">data.sample</code></td>
<td>
<p>list containing features, profiles and clustering results.</p>
</td></tr>
<tr><td><code id="countItemsSampleGUI_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>environment in which all global parameters, raw data and results are stored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>countItemsSampleGUI opens a Graphical User Interface allowing to choose the images directory, to count manually the number of cells in colonies and to build specific predictive model
</p>


<h3>Value</h3>

<p>RDS file containing the counts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf &lt;- tempfile()
write.table(dat, tf, sep=",", dec=".")
x &lt;- importSample(file.features=tf)

x &lt;- computeUnSupervised(x, K=0, pca=TRUE, echo=TRUE)
countResult &lt;- countItemsSampleGUI(x)

</code></pre>

<hr>
<h2 id='createResFolder'>Results directories creation</h2><span id='topic+createResFolder'></span>

<h3>Description</h3>

<p>Create results directories for the sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createResFolder(data.sample, dir.name = "", dir.path = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createResFolder_+3A_data.sample">data.sample</code></td>
<td>
<p>sample object.</p>
</td></tr>
<tr><td><code id="createResFolder_+3A_dir.name">dir.name</code></td>
<td>
<p>directory name where to store results.</p>
</td></tr>
<tr><td><code id="createResFolder_+3A_dir.path">dir.path</code></td>
<td>
<p>path where to create results directory.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>createResFolder creates results directories for the sample.
</p>


<h3>Value</h3>

<p>data.sample updated with results directories.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf &lt;- tempfile()
write.table(dat, tf, sep=",", dec=".")

x &lt;- importSample(file.features=tf, dir.save=dirname(tf))

#Already called in importSample 
createResFolder(x, dir.path=dirname(tf))


</code></pre>

<hr>
<h2 id='critMNCut'>Multiple Normalized Cut</h2><span id='topic+critMNCut'></span>

<h3>Description</h3>

<p>Calculate the Multiple Normalized Cut value from a similarity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>critMNCut(sim, label)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="critMNCut_+3A_sim">sim</code></td>
<td>
<p>similarity matrix.</p>
</td></tr>
<tr><td><code id="critMNCut_+3A_label">label</code></td>
<td>
<p>vector of labels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>critMNCut returns the Multiple Normalized Cut value
</p>


<h3>Value</h3>

<p>MNCut Multiple Normalized Cut value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
           
sim &lt;- computeGaussianSimilarity(dat, 1)

ML &lt;- list(c("10","20"),  c("60","70"))
CNL &lt;- list(c("30","80"), c("90","120"))

res &lt;- KwaySSSC(sim, K=0, list.ML=ML, list.CNL=CNL)

critMNCut(sim, res$label)

</code></pre>

<hr>
<h2 id='detailOperation'>detail Operation</h2><span id='topic+detailOperation'></span>

<h3>Description</h3>

<p>detail operation which are in config list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detailOperation(config = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detailOperation_+3A_config">config</code></td>
<td>
<p>list of data.frames describing all preprocessing operations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>detailOperation develop short operations (combinations select+log for example)
</p>


<h3>Value</h3>

<p>newConfig
</p>
<p>instr &lt;- rbind(c(&quot;select&quot;,&quot;x&quot;,&quot;log&quot;,&quot;&quot;), c(&quot;select&quot;,&quot;y&quot;,&quot;log&quot;,&quot;&quot;))
tf2 &lt;- tempfile()
write.table(instr, tf2, sep=&quot;,&quot;, col.names = FALSE, row.names = FALSE)
operations &lt;- loadPreprocessFile(tf2)
</p>
<p>detailOperations&lt;-detailOperation(operations)
</p>

<hr>
<h2 id='dropTrainSetVars'>Parameters dropping</h2><span id='topic+dropTrainSetVars'></span>

<h3>Description</h3>

<p>Drop some parameters (columns) in the training set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dropTrainSetVars(dat, VarToDrop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dropTrainSetVars_+3A_dat">dat</code></td>
<td>
<p>data.frame containing the features of each prototype associated to a class.</p>
</td></tr>
<tr><td><code id="dropTrainSetVars_+3A_vartodrop">VarToDrop</code></td>
<td>
<p>character vector specifying variables to drop from the training set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>dropTrainSetVars drops some parameters (columns) in the training set
</p>


<h3>Value</h3>

<p>dat data.frame containing the kept features of each prototype associated to a class.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readTrainSet">readTrainSet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rep &lt;- system.file("extdata", package="RclusTool")
traindir &lt;- file.path(rep, "train_example")

train &lt;- readTrainSet(traindir)
train &lt;- dropTrainSetVars(train, c("Id", "i..ID", "ArrivalTime", "X"))

</code></pre>

<hr>
<h2 id='ElbowFinder'>Elbow Finder</h2><span id='topic+ElbowFinder'></span>

<h3>Description</h3>

<p>Perform Elbow method for the automatic estimation of the number of clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ElbowFinder(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ElbowFinder_+3A_x">x</code></td>
<td>
<p>: x-axis</p>
</td></tr>
<tr><td><code id="ElbowFinder_+3A_y">y</code></td>
<td>
<p>: y-axis</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ElbowFinder return K number of groups according to Elbow method
</p>


<h3>Value</h3>

<p>K number of clusters obtained by Elbow method
</p>


<h3>References</h3>

<p><a href="https://stackoverflow.com/a/42810075">https://stackoverflow.com/a/42810075</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y &lt;- c(824,248,32,28,26,19,20,20,17)           
x &lt;- 1:length(y) 
      
K &lt;- ElbowFinder(x,y)

plot(x,y,type='o')
abline(v=K,col="red")

</code></pre>

<hr>
<h2 id='ElbowPlot'>Elbow Plot.</h2><span id='topic+ElbowPlot'></span>

<h3>Description</h3>

<p>Display the Elbow Plot after a clustering step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ElbowPlot(nb, method.space.name, RclusTool.env, hscale = 1.2, charsize = 11)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ElbowPlot_+3A_nb">nb</code></td>
<td>
<p>tk-notebook in which the Elbow plot will be made.</p>
</td></tr>
<tr><td><code id="ElbowPlot_+3A_method.space.name">method.space.name</code></td>
<td>
<p>complete name of space.</p>
</td></tr>
<tr><td><code id="ElbowPlot_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>environment in which data and intermediate results are stored.</p>
</td></tr>
<tr><td><code id="ElbowPlot_+3A_hscale">hscale</code></td>
<td>
<p>numeric value corresponding to the horizontal scale of graphic</p>
</td></tr>
<tr><td><code id="ElbowPlot_+3A_charsize">charsize</code></td>
<td>
<p>character size</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ElbowPlot displays the Elbow plot after a clustering step.
</p>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='extractFeaturesFromSummary'>Extraction of features from a summary object.</h2><span id='topic+extractFeaturesFromSummary'></span>

<h3>Description</h3>

<p>Extract features from a summary object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractFeaturesFromSummary(summary, split = "...")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractFeaturesFromSummary_+3A_summary">summary</code></td>
<td>
<p>a summary object.</p>
</td></tr>
<tr><td><code id="extractFeaturesFromSummary_+3A_split">split</code></td>
<td>
<p>separator string</p>
</td></tr>
</table>


<h3>Details</h3>

<p>extractFeaturesFromSummary decomposes the summary column names into simple features (not combined to functions), statistic functions and features combined to the functions
</p>


<h3>Value</h3>

<p>list of simple features, features combined to functions, functions combined to features
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
summary &lt;- data.frame("x...min"=1,"x...max"=2,"count"=3,"length"=4)

extractFeaturesFromSummary(summary)

</code></pre>

<hr>
<h2 id='extractProtos'>Prototypes extraction</h2><span id='topic+extractProtos'></span>

<h3>Description</h3>

<p>Extract prototypes of each cluster automatically, according to a clustering result, and save them in different directories. 
In order to catch the whole variability, each cluster is divided into several sub-clusters, and medoids of each sub-cluster are considered as prototypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractProtos(
  data.sample,
  method,
  K.max = 20,
  kmeans.variance.min = 0.95,
  user.name = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractProtos_+3A_data.sample">data.sample</code></td>
<td>
<p>list containing features, profiles and clustering results.</p>
</td></tr>
<tr><td><code id="extractProtos_+3A_method">method</code></td>
<td>
<p>character vector specifying the clustering method (already performed) to use.</p>
</td></tr>
<tr><td><code id="extractProtos_+3A_k.max">K.max</code></td>
<td>
<p>maximal number of clusters (K.max=20 by default).</p>
</td></tr>
<tr><td><code id="extractProtos_+3A_kmeans.variance.min">kmeans.variance.min</code></td>
<td>
<p>elbow method cumulative explained variance &gt; criteria to stop K-search.</p>
</td></tr>
<tr><td><code id="extractProtos_+3A_user.name">user.name</code></td>
<td>
<p>character vector specifying the user name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>extractProtos extracts prototypes automatically according to a clustering result, and save them in different directories
</p>


<h3>Value</h3>

<p>csv file containing the prototypes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf1 &lt;- tempfile()
write.table(dat, tf1, sep=",", dec=".")

dir.results &lt;- tempdir()
x &lt;- importSample(file.features=tf1, dir.save=dir.results)
x &lt;- computeUnSupervised(x, K=3, method.name="K-means")

extractProtos(x, method = "K-means_preprocessed")


</code></pre>

<hr>
<h2 id='featSpaceNameConvert'>Feature Space Name Conversion</h2><span id='topic+featSpaceNameConvert'></span>

<h3>Description</h3>

<p>Converts Feature Space Name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>featSpaceNameConvert(
  name2convert,
  short2long = TRUE,
  RclusTool.env = initParameters()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="featSpaceNameConvert_+3A_name2convert">name2convert</code></td>
<td>
<p>character vector for name to convert.</p>
</td></tr>
<tr><td><code id="featSpaceNameConvert_+3A_short2long">short2long</code></td>
<td>
<p>boolean setting the direction of conversion (higher priority).</p>
</td></tr>
<tr><td><code id="featSpaceNameConvert_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>list of parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>featSpaceNameConvert converts feature space names: either long name to short name, or short name to long name.
</p>


<h3>Value</h3>

<p>character name.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
long.name &lt;- "Scaled - Principal Component Analysis"
short.name &lt;- "scaled.pca"

res1 &lt;- featSpaceNameConvert(long.name, short2long=TRUE)
res2 &lt;- featSpaceNameConvert(short.name, short2long=FALSE)

</code></pre>

<hr>
<h2 id='FindNumberK'>Automatic estimation of the number of clusters</h2><span id='topic+FindNumberK'></span>

<h3>Description</h3>

<p>Compute gap on a similarity matrix obtained from raw data matrix to estimate the number of clusters automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindNumberK(features, Kmax, StopCriteria = 0.99, graph = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindNumberK_+3A_features">features</code></td>
<td>
<p>matrix of raw data (point by line).</p>
</td></tr>
<tr><td><code id="FindNumberK_+3A_kmax">Kmax</code></td>
<td>
<p>maximum number of clusters.</p>
</td></tr>
<tr><td><code id="FindNumberK_+3A_stopcriteria">StopCriteria</code></td>
<td>
<p>elbow method cumulative explained variance &gt; criteria to stop K-search.</p>
</td></tr>
<tr><td><code id="FindNumberK_+3A_graph">graph</code></td>
<td>
<p>boolean: if TRUE, figures for total of within-class inertia and explained variance are plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>FindNumberK return K number according spectral gap on reduced points
</p>


<h3>Value</h3>

<p>K number of clusters obtained.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
           
res &lt;- FindNumberK(dat, Kmax=20, graph=TRUE)

</code></pre>

<hr>
<h2 id='formatLabelSample'>Labels formatting</h2><span id='topic+formatLabelSample'></span>

<h3>Description</h3>

<p>Format labels for unsupervised classification and add cleaned observations as 'Noise'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatLabelSample(
  label,
  data.sample,
  new.labels = TRUE,
  use.sampling = FALSE,
  noise.cluster = "Noise"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatLabelSample_+3A_label">label</code></td>
<td>
<p>vector of labels.</p>
</td></tr>
<tr><td><code id="formatLabelSample_+3A_data.sample">data.sample</code></td>
<td>
<p>sample object.</p>
</td></tr>
<tr><td><code id="formatLabelSample_+3A_new.labels">new.labels</code></td>
<td>
<p>boolean: if TRUE (default), new names are given for each cluster (beginning by 'Cluster').</p>
</td></tr>
<tr><td><code id="formatLabelSample_+3A_use.sampling">use.sampling</code></td>
<td>
<p>boolean: if TRUE (not default), data.sample$sampling is used to generalize label from sampling set to the whole set.</p>
</td></tr>
<tr><td><code id="formatLabelSample_+3A_noise.cluster">noise.cluster</code></td>
<td>
<p>character name of the cluster &quot;noise&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>formatLabelSample formats labels for unsupervised classification and adds cleaned observations as 'Noise'
</p>


<h3>Value</h3>

<p>new.labels formatted labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf &lt;- tempfile()
write.table(dat, tf, sep=",", dec=".")

x &lt;- importSample(file.features=tf)
res &lt;- KmeansQuick(x$features$initial$x, K=3)

new.labels &lt;- formatLabelSample(res$cluster, x)


</code></pre>

<hr>
<h2 id='formatParameterList'>Format Parameter List</h2><span id='topic+formatParameterList'></span>

<h3>Description</h3>

<p>formatParameterList format parameters required by following functions, dealing with operations on features
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatParameterList(parameterList, lowercase = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatParameterList_+3A_parameterlist">parameterList</code></td>
<td>
<p>list describing a single preprocessing instruction.</p>
</td></tr>
<tr><td><code id="formatParameterList_+3A_lowercase">lowercase</code></td>
<td>
<p>boolean to build lowercase operation name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>format Parameter character matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
instr &lt;- list("select","x","log")
formatParameterList &lt;- formatParameterList(instr)

</code></pre>

<hr>
<h2 id='guessFileEncoding'>File Encoding Identification.</h2><span id='topic+guessFileEncoding'></span>

<h3>Description</h3>

<p>Guess file encoding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guessFileEncoding(file.name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guessFileEncoding_+3A_file.name">file.name</code></td>
<td>
<p>a character vector, describing one file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>guessFileEncoding guess file encoding.
</p>


<h3>Value</h3>

<p>file character encoding.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))

csv.file &lt;- tempfile()
write.table(dat, csv.file, sep=",", dec=".")

guessFileEncoding(csv.file)


</code></pre>

<hr>
<h2 id='imgClassif'>Images clustering</h2><span id='topic+imgClassif'></span>

<h3>Description</h3>

<p>Sort images (if available) in different directories according to a clustering result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imgClassif(data.sample, imgdir, method, user.name = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imgClassif_+3A_data.sample">data.sample</code></td>
<td>
<p>list containing features, profiles and clustering results.</p>
</td></tr>
<tr><td><code id="imgClassif_+3A_imgdir">imgdir</code></td>
<td>
<p>character vector specifying the path of the images directory.</p>
</td></tr>
<tr><td><code id="imgClassif_+3A_method">method</code></td>
<td>
<p>character vector specifying the clustering method (already performed) to use.</p>
</td></tr>
<tr><td><code id="imgClassif_+3A_user.name">user.name</code></td>
<td>
<p>character vector specifying the user name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>imgClassif sorts images (if available) in different directories according to a clustering result
</p>


<h3>Value</h3>

<p>images files in the different directories, csv file containing the detail.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sigClassif">sigClassif</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf1 &lt;- tempfile()
write.table(dat, tf1, sep=",", dec=".")

rep &lt;- system.file("extdata", package="RclusTool")
imgdir &lt;- file.path(rep, "img_example")

dir.results &lt;- tempdir()
x &lt;- importSample(file.features=tf1, dir.images=imgdir, dir.save=dir.results)
x &lt;- computeUnSupervised(x, K=3, method.name="K-means")

imgClassif(x, imgdir, method = "K-means_preprocessed")


</code></pre>

<hr>
<h2 id='importLabelSample'>Labels importation</h2><span id='topic+importLabelSample'></span>

<h3>Description</h3>

<p>Import labels and add cleaned observations as 'noise'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>importLabelSample(label, data.sample, noise.cluster = "Noise")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="importLabelSample_+3A_label">label</code></td>
<td>
<p>vector of labels.</p>
</td></tr>
<tr><td><code id="importLabelSample_+3A_data.sample">data.sample</code></td>
<td>
<p>sample object.</p>
</td></tr>
<tr><td><code id="importLabelSample_+3A_noise.cluster">noise.cluster</code></td>
<td>
<p>character name of the cluster &quot;Noise&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>importLabelSample imports labels
</p>


<h3>Value</h3>

<p>new.labels imported labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf &lt;- tempfile()
write.table(dat, tf, sep=",", dec=".")

x &lt;- importSample(file.features=tf)
res &lt;- KmeansQuick(x$features$initial$x, K=3)

new.labels &lt;- importLabelSample(res$cluster, x)


</code></pre>

<hr>
<h2 id='importSample'>Sample importation</h2><span id='topic+importSample'></span>

<h3>Description</h3>

<p>Import the required and the optional files, and build a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>importSample(
  file.features = "",
  file.meta = "",
  file.profiles = "",
  file.RDS = "",
  file.config = "",
  dir.images = "",
  dir.save = "",
  sepFeat = ",",
  decFeat = ".",
  naFeat = c("", "NA"),
  sepSig = ",",
  decSig = ".",
  naSig = c("", "NA"),
  headerCSV = TRUE,
  RclusTool.env = new.env(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="importSample_+3A_file.features">file.features</code></td>
<td>
<p>character vector specifying the csv file containing features data.</p>
</td></tr>
<tr><td><code id="importSample_+3A_file.meta">file.meta</code></td>
<td>
<p>character vector specifying the txt file containing metadata.</p>
</td></tr>
<tr><td><code id="importSample_+3A_file.profiles">file.profiles</code></td>
<td>
<p>character vector specifying the csv file containing profiles data.</p>
</td></tr>
<tr><td><code id="importSample_+3A_file.rds">file.RDS</code></td>
<td>
<p>character vector for a RDS file containing a data.sample object. This file is automatically saved when importing a (csv-)file-features. When both a csv-file-features and a RDS file are given, the last one is ignored.</p>
</td></tr>
<tr><td><code id="importSample_+3A_file.config">file.config</code></td>
<td>
<p>character vector for the name of the configuration file.</p>
</td></tr>
<tr><td><code id="importSample_+3A_dir.images">dir.images</code></td>
<td>
<p>character vector containing the path of images directory.</p>
</td></tr>
<tr><td><code id="importSample_+3A_dir.save">dir.save</code></td>
<td>
<p>character vector specifying path of the working directory to save results ; &quot;&quot; to not save any results</p>
</td></tr>
<tr><td><code id="importSample_+3A_sepfeat">sepFeat</code></td>
<td>
<p>character specifying the field separator for the csv file containing features data.</p>
</td></tr>
<tr><td><code id="importSample_+3A_decfeat">decFeat</code></td>
<td>
<p>character specifying the decimal points for the csv file containing features data.</p>
</td></tr>
<tr><td><code id="importSample_+3A_nafeat">naFeat</code></td>
<td>
<p>vector containing missing values for the csv file containing features data.</p>
</td></tr>
<tr><td><code id="importSample_+3A_sepsig">sepSig</code></td>
<td>
<p>character specifying the field separator for the csv file containing profiles data.</p>
</td></tr>
<tr><td><code id="importSample_+3A_decsig">decSig</code></td>
<td>
<p>character specifying the decimal point for the csv file containing profiles data.</p>
</td></tr>
<tr><td><code id="importSample_+3A_nasig">naSig</code></td>
<td>
<p>vector containing missing values for the csv file containing profiles data.</p>
</td></tr>
<tr><td><code id="importSample_+3A_headercsv">headerCSV</code></td>
<td>
<p>boolean if TRUE (default) the file contains the names of the variables as its first line.</p>
</td></tr>
<tr><td><code id="importSample_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>environment in which data and intermediate results are stored.</p>
</td></tr>
<tr><td><code id="importSample_+3A_...">...</code></td>
<td>
<p>parameters adressed to read.csv functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function to import sample from CSV files; sample is preprocessed
</p>


<h3>Value</h3>

<p>data.sample loaded data.sample.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loadSample">loadSample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf1 &lt;- tempfile()
write.table(dat, tf1, sep=",", dec=".")

metadat &lt;- rbind("First metadata: ...", "Second metadata: ...")
tf2 &lt;- tempfile()
writeLines(metadat, tf2)

x &lt;- importSample(file.features=tf1, file.meta=tf2)


</code></pre>

<hr>
<h2 id='initBatchTab'>batch tab</h2><span id='topic+initBatchTab'></span>

<h3>Description</h3>

<p>This function generates the batch tab  of the <code><a href="#topic+RclusToolGUI">RclusToolGUI</a></code>, in which the user can batch files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initBatchTab(RclusTool.env, reset = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initBatchTab_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>: environment in which data and intermediate results are stored.</p>
</td></tr>
<tr><td><code id="initBatchTab_+3A_reset">reset</code></td>
<td>
<p>: if TRUE the whole tab is reset, with default options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function to initialize (and to create) the 'batchTab'
</p>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='initImportTab'>import tab</h2><span id='topic+initImportTab'></span>

<h3>Description</h3>

<p>This function generates the import tab of the <code><a href="#topic+RclusToolGUI">RclusToolGUI</a></code>, in which the user can import files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initImportTab(RclusTool.env, reset = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initImportTab_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>: environment in which data and intermediate results are stored.</p>
</td></tr>
<tr><td><code id="initImportTab_+3A_reset">reset</code></td>
<td>
<p>: if TRUE the whole tab is reset, with default options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function to initialize (and to create) the 'importTab'
</p>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='initParameters'>Parameters initialization</h2><span id='topic+initParameters'></span>

<h3>Description</h3>

<p>Initialize the global parameters and variables and generate a new environment used in the <code><a href="#topic+RclusToolGUI">RclusToolGUI</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initParameters(RclusTool.env = new.env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initParameters_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>environment in which data and intermediate results are stored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function to initialize the global parameters and variables
</p>


<h3>Value</h3>

<p>RclusTool.env new environment in which all global parameters, raw data and results are stored.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RclusTool.env &lt;- initParameters()

</code></pre>

<hr>
<h2 id='initPreprocessTab'>build Preprocess tab</h2><span id='topic+initPreprocessTab'></span>

<h3>Description</h3>

<p>Generate the data preprocessing tab of the <code><a href="#topic+RclusToolGUI">RclusToolGUI</a></code>, in which the user can select, transform, filter or create variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initPreprocessTab(RclusTool.env, reset = FALSE, readConfig = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initPreprocessTab_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>environment in which data and intermediate results are stored.</p>
</td></tr>
<tr><td><code id="initPreprocessTab_+3A_reset">reset</code></td>
<td>
<p>boolean to reset the whole interface</p>
</td></tr>
<tr><td><code id="initPreprocessTab_+3A_readconfig">readConfig</code></td>
<td>
<p>boolean to reset the whole interface according the config parameters of the data.sample</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function to initialize/refresh the 'preprocessTab' for data preprocessing (variables selection, transformation, creation, ...)
</p>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='initSemisupTab'>Semi-Supervised tab</h2><span id='topic+initSemisupTab'></span>

<h3>Description</h3>

<p>Generate the semi-supervised classification tab of the <code><a href="#topic+RclusToolGUI">RclusToolGUI</a></code>, in which the user can choose and configure the semi-supervised method to apply.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initSemisupTab(RclusTool.env, reset = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initSemisupTab_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>environment in which data and intermediate results are stored.</p>
</td></tr>
<tr><td><code id="initSemisupTab_+3A_reset">reset</code></td>
<td>
<p>: if TRUE the whole tab is reset, with default options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function to initialize (and to create) the 'semisupTab' for data clustering
</p>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='initSupTab'>supervised tab</h2><span id='topic+initSupTab'></span>

<h3>Description</h3>

<p>This function generates the supervised classification tab of the <code><a href="#topic+RclusToolGUI">RclusToolGUI</a></code>, in which the user can choose and configure the classification method to apply.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initSupTab(RclusTool.env, reset = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initSupTab_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>: environment in which data and intermediate results are stored.</p>
</td></tr>
<tr><td><code id="initSupTab_+3A_reset">reset</code></td>
<td>
<p>: if TRUE the whole tab is reset, with default options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function to initialize (and to create) the 'supTab' for supervised classification
</p>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='initUnsupTab'>Unsupervised tab</h2><span id='topic+initUnsupTab'></span>

<h3>Description</h3>

<p>This function generates the unsupervised classification tab of the <code><a href="#topic+RclusToolGUI">RclusToolGUI</a></code>, in which the user can choose and configure the clustering method to apply.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initUnsupTab(RclusTool.env, reset = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initUnsupTab_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>: environment in which data and intermediate results are stored.</p>
</td></tr>
<tr><td><code id="initUnsupTab_+3A_reset">reset</code></td>
<td>
<p>: if TRUE the whole tab is reset, with default options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function to initialize (and to create) the 'unsupTab' for data clustering
</p>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='itemsModel'>Predictive models computation for the number of cells in colonies</h2><span id='topic+itemsModel'></span>

<h3>Description</h3>

<p>Compute and save specific predictive model from manual countings for the estimation of number of cells in colonies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itemsModel(dat, countFile, method = "mda")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="itemsModel_+3A_dat">dat</code></td>
<td>
<p>matrix or data.frame of raw data (points by line).</p>
</td></tr>
<tr><td><code id="itemsModel_+3A_countfile">countFile</code></td>
<td>
<p>character vector specifying the path and the name of the file containing manual countings.</p>
</td></tr>
<tr><td><code id="itemsModel_+3A_method">method</code></td>
<td>
<p>character vector specifying the name of method tu use for the building of predictive models. Must be 'lm', 'lda' or 'mda' (default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>itemsModel computes and saves specific predictive model from manual countings for the estimation of number of cells in colonies
</p>


<h3>Value</h3>

<p>RDS file containing the predictive model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeItemsSample">computeItemsSample</a></code>, <code><a href="#topic+countItems">countItems</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf &lt;- tempfile()
write.table(dat, tf, sep=",", dec=".")
x &lt;- importSample(file.features=tf)

x &lt;- computeUnSupervised(x, K=0, pca=TRUE, echo=TRUE)

countFile &lt;- countItemsSampleGUI(x)
if (file.exists(countFile))
     itemsModel(x$features$initial$x, countFile)

</code></pre>

<hr>
<h2 id='KmeansAutoElbow'>Kmeans clustering with automatic estimation of number of clusters</h2><span id='topic+KmeansAutoElbow'></span>

<h3>Description</h3>

<p>Perform Elbow method and kmeans algorithm for the automatic estimation of the number of clusters and data clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KmeansAutoElbow(
  features,
  Kmax,
  StopCriteria = 0.99,
  graph = FALSE,
  Elbow = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KmeansAutoElbow_+3A_features">features</code></td>
<td>
<p>matrix of raw data (point by line).</p>
</td></tr>
<tr><td><code id="KmeansAutoElbow_+3A_kmax">Kmax</code></td>
<td>
<p>maximum number of clusters.</p>
</td></tr>
<tr><td><code id="KmeansAutoElbow_+3A_stopcriteria">StopCriteria</code></td>
<td>
<p>elbow method cumulative explained variance &gt; criteria to stop K-search.</p>
</td></tr>
<tr><td><code id="KmeansAutoElbow_+3A_graph">graph</code></td>
<td>
<p>boolean: if TRUE, figures for total of within-class inertia and explained variance are plotted.</p>
</td></tr>
<tr><td><code id="KmeansAutoElbow_+3A_elbow">Elbow</code></td>
<td>
<p>boolean: if TRUE, Elbow method is used for finding the knee point of a curve.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>KmeansAutoElbow return partition and K number of groups according to kmeans clustering and Elbow method
</p>


<h3>Value</h3>

<p>The function returns a list containing:
</p>
<table>
<tr><td><code>K</code></td>
<td>
<p>number of clusters obtained by Elbow method.</p>
</td></tr>
<tr><td><code>res.kmeans</code></td>
<td>
<p>results obtained from kmeans algorithm.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+KmeansQuick">KmeansQuick</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
           
res &lt;- KmeansAutoElbow(dat, Kmax=20, graph=TRUE)

plot(dat[,1], dat[,2], type = "p", xlab = "x", ylab = "y", 
	col = res$res.kmeans$cluster, main = "K-means clustering")

</code></pre>

<hr>
<h2 id='KmeansQuick'>Quick kmeans clustering</h2><span id='topic+KmeansQuick'></span>

<h3>Description</h3>

<p>Perform quick kmeans algorithm for data clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KmeansQuick(features, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KmeansQuick_+3A_features">features</code></td>
<td>
<p>matrix of raw data (point by line).</p>
</td></tr>
<tr><td><code id="KmeansQuick_+3A_k">K</code></td>
<td>
<p>number of clusters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>KmeansQuick partition and K number of groups according to kmeans clustering
</p>


<h3>Value</h3>

<p>res.kmeans results obtained from kmeans algorithm.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+KmeansAutoElbow">KmeansAutoElbow</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
           
res &lt;- KmeansQuick(dat, K=3)

plot(dat[,1], dat[,2], type = "p", xlab = "x", ylab = "y", 
	col = res$cluster, main = "K-means clustering")

</code></pre>

<hr>
<h2 id='KwaySSSC'>Semi-supervised spectral clustering</h2><span id='topic+KwaySSSC'></span>

<h3>Description</h3>

<p>Perform semi-supervised spectral clustering thanks to a similarity matrix and constraints sets (according to Wacquet et al., 2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KwaySSSC(
  sim,
  K = 0,
  list.ML = list(),
  list.CNL = list(),
  alphas = seq(from = 0, to = 1, length = 100),
  K.max = 20
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KwaySSSC_+3A_sim">sim</code></td>
<td>
<p>similarity matrix.</p>
</td></tr>
<tr><td><code id="KwaySSSC_+3A_k">K</code></td>
<td>
<p>number of clusters (0 for automatic estimation).</p>
</td></tr>
<tr><td><code id="KwaySSSC_+3A_list.ml">list.ML</code></td>
<td>
<p>list of ML (must-link) constrained pairs.</p>
</td></tr>
<tr><td><code id="KwaySSSC_+3A_list.cnl">list.CNL</code></td>
<td>
<p>list of CNL (cannot-link) constrained pairs.</p>
</td></tr>
<tr><td><code id="KwaySSSC_+3A_alphas">alphas</code></td>
<td>
<p>numeric vector for the weight of constraints considered.</p>
</td></tr>
<tr><td><code id="KwaySSSC_+3A_k.max">K.max</code></td>
<td>
<p>maximal number of clusters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>KwaySSSC returns a partition obtained by semi-supervised spectral clustering (according to Wacquet et al., 2013)
</p>


<h3>Value</h3>

<p>The function returns a list containing:
</p>
<table>
<tr><td><code>alpha</code></td>
<td>
<p>chosen alpha.</p>
</td></tr>
<tr><td><code>label</code></td>
<td>
<p>vector of labels.</p>
</td></tr>
<tr><td><code>medoids</code></td>
<td>
<p>matrix of cluster centers in the space of the K first normalized eigenvectors.</p>
</td></tr>
<tr><td><code>id.med</code></td>
<td>
<p>vector containing the medoids indices.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>matrix containing, in columns, the eigenvectors of the similarity matrix.</p>
</td></tr>
<tr><td><code>eigen.val</code></td>
<td>
<p>vector containing the eigenvalues of the similarity matrix.</p>
</td></tr>
<tr><td><code>cluster.info</code></td>
<td>
<p>some statistics on each cluster.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>number of clusters.</p>
</td></tr>
</table>


<h3>References</h3>

<p>G. Wacquet, E. Poisson Caillault, D. Hamad, P.-A. Hebert, Constrained spectral embedding for K-way data clustering, Pattern Recognition Letters, 2013, 34 (9), pp.1009-1017.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeSemiSupervised">computeSemiSupervised</a></code>, <code><a href="#topic+computeCKmeans">computeCKmeans</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
           
ML &lt;- list()
ML[[1]] &lt;- c(sel="10",mem="20")
ML[[2]] &lt;- c(sel="60",mem="70")

CNL &lt;- list()
CNL[[1]] &lt;- c(sel="30",mem="80")
CNL[[2]] &lt;- c(sel="90",mem="120")

sim &lt;- computeGaussianSimilarity(dat, 1)
res &lt;- KwaySSSC(sim, K=0, list.ML=ML, list.CNL=CNL)

plot(dat[,1], dat[,2], type = "p", xlab = "x", ylab = "y", 
col = res$label, main = "Constrained spectral clustering")

</code></pre>

<hr>
<h2 id='listDerivableFeatureSpaces'>Builds list of derivable feature spaces</h2><span id='topic+listDerivableFeatureSpaces'></span>

<h3>Description</h3>

<p>Builds list of derivable feature spaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listDerivableFeatureSpaces(
  scaling = FALSE,
  pca = FALSE,
  spectral = FALSE,
  RclusTool.env = initParameters()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="listDerivableFeatureSpaces_+3A_scaling">scaling</code></td>
<td>
<p>boolean TRUE if scaling required.</p>
</td></tr>
<tr><td><code id="listDerivableFeatureSpaces_+3A_pca">pca</code></td>
<td>
<p>boolean TRUE if Principal Components Analysis required.</p>
</td></tr>
<tr><td><code id="listDerivableFeatureSpaces_+3A_spectral">spectral</code></td>
<td>
<p>boolean TRUE if Spectral Embedding required.</p>
</td></tr>
<tr><td><code id="listDerivableFeatureSpaces_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>environment in which all global parameters, raw data and results are stored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>listDerivableFeatureSpaces build the list of feature spaces matching parameters.
</p>


<h3>Value</h3>

<p>character vector naming feature spaces.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
listDerivableFeatureSpaces(scaling=TRUE, spectral=TRUE)

</code></pre>

<hr>
<h2 id='loadPreprocessFile'>Preprocessing loading</h2><span id='topic+loadPreprocessFile'></span>

<h3>Description</h3>

<p>Load a csv file configuration with instruction to remove bad observations and builds object config that describes all preprocessings to apply.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadPreprocessFile(file.config, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadPreprocessFile_+3A_file.config">file.config</code></td>
<td>
<p>character vector specifying the name of a csv file with preprocessing instructions.</p>
</td></tr>
<tr><td><code id="loadPreprocessFile_+3A_...">...</code></td>
<td>
<p>parameters adressed to read.csv functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>loadPreprocessFile reads a csv file configuration with instruction to remove bad particles and builds object config that describes all preprocessings done
</p>


<h3>Value</h3>

<p>operations character matrix describing all preprocessing operations.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+applyPreprocessing">applyPreprocessing</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>instr &lt;- rbind(c("select","x","log",""), c("select","y","log",""))
tf &lt;- tempfile()
write.table(instr, tf, sep=",", col.names = FALSE, row.names = FALSE)

operations &lt;- loadPreprocessFile(tf)

</code></pre>

<hr>
<h2 id='loadPreviousRes'>Previous clustering results loading</h2><span id='topic+loadPreviousRes'></span>

<h3>Description</h3>

<p>Load previous clustering results obtained from previous analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadPreviousRes(data.sample, noise.cluster = "Noise")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadPreviousRes_+3A_data.sample">data.sample</code></td>
<td>
<p>sample object.</p>
</td></tr>
<tr><td><code id="loadPreviousRes_+3A_noise.cluster">noise.cluster</code></td>
<td>
<p>character name of the cluster &quot;Noise&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>loadPreviousRes loads previous results obtained from previous analyses.
</p>


<h3>Value</h3>

<p>data.sample updated with previous clustering results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf &lt;- tempfile()
write.table(dat, tf, sep=",", dec=".")

x &lt;- importSample(file.features=tf, dir.save=dirname(tf))
loadPreviousRes(x)


</code></pre>

<hr>
<h2 id='loadSample'>Sample loading</h2><span id='topic+loadSample'></span>

<h3>Description</h3>

<p>Load and preprocess sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadSample(file.RDS, RclusTool.env = initParameters(), file.config = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadSample_+3A_file.rds">file.RDS</code></td>
<td>
<p>character vector for the name of the .RDS file where built data.sample object is saved.</p>
</td></tr>
<tr><td><code id="loadSample_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>environment in which all global parameters, raw data and results are stored.</p>
</td></tr>
<tr><td><code id="loadSample_+3A_file.config">file.config</code></td>
<td>
<p>character vector for the name of the configuration file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>loadSample reads RDS sample file; sample is preprocessed by call to function preprocessSample()
</p>


<h3>Value</h3>

<p>data.sample loaded data.sample.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+importSample">importSample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf &lt;- tempfile()
write.table(dat, tf, sep=",", dec=".")

x &lt;- importSample(tf, dir.save=dirname(tf))

res &lt;- loadSample(x$files$RDS)       


</code></pre>

<hr>
<h2 id='loadSummary'>Summaries loading</h2><span id='topic+loadSummary'></span>

<h3>Description</h3>

<p>Load the clusters summaries results (min, max, sum, average, sd) from a csv file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadSummary(filename.csv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadSummary_+3A_filename.csv">filename.csv</code></td>
<td>
<p>character vector specifying the name and directory of the csv file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>loadSummary loads the clusters summaries results (min, max, sum, average, sd) from a csv file
</p>


<h3>Value</h3>

<p>res data.frame containing the clusters summaries.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+saveSummary">saveSummary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
colnames(dat) &lt;- c("x","y")
tf1 &lt;- tempfile()
write.table(dat, tf1, sep=",", dec=".")

x &lt;- importSample(file.features=tf1)
res &lt;- KmeansQuick(x$features$initial$x, K=3)
labels &lt;- formatLabelSample(res$cluster, x)
cluster.summary &lt;- clusterSummary(x, labels)

tf2 &lt;- tempfile()
saveSummary(basename(tf2), cluster.summary, dirname(tf2))

loadSummary(tf2)
 

</code></pre>

<hr>
<h2 id='MainWindow'>Main window</h2><span id='topic+MainWindow'></span>

<h3>Description</h3>

<p>Generate an user-friendly interface to classify data in a unsupervised, semi-supervised or supervised way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MainWindow(RclusTool.env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MainWindow_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>environment in which data and results will be stored. If NULL, a local environment will be created.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function to display the graphical user interface to classify dataset.
</p>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='makeFeatureSpaceOperations'>Make operation config object to build feature spaces</h2><span id='topic+makeFeatureSpaceOperations'></span>

<h3>Description</h3>

<p>makeFeatureSpaceOperations create config object for datasample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeFeatureSpaceOperations(
  pca = FALSE,
  pca.nb.dims = 0,
  spectral = FALSE,
  sampling = FALSE,
  sampling.size.max = 0,
  scaling = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeFeatureSpaceOperations_+3A_pca">pca</code></td>
<td>
<p>boolean: if TRUE, Principal Components Analysis is applied to reduce the data space.</p>
</td></tr>
<tr><td><code id="makeFeatureSpaceOperations_+3A_pca.nb.dims">pca.nb.dims</code></td>
<td>
<p>number of principal components kept. If pca.nb.dims=0, this number is computed automatically.</p>
</td></tr>
<tr><td><code id="makeFeatureSpaceOperations_+3A_spectral">spectral</code></td>
<td>
<p>boolean: if TRUE, spectral embedding is applied to reduce the data space.</p>
</td></tr>
<tr><td><code id="makeFeatureSpaceOperations_+3A_sampling">sampling</code></td>
<td>
<p>boolean: if TRUE, data sampling is used.</p>
</td></tr>
<tr><td><code id="makeFeatureSpaceOperations_+3A_sampling.size.max">sampling.size.max</code></td>
<td>
<p>: maximum size of the sampled dataframe.</p>
</td></tr>
<tr><td><code id="makeFeatureSpaceOperations_+3A_scaling">scaling</code></td>
<td>
<p>boolean: if TRUE, scaling is applied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>configuration object created from parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
operations &lt;- makeFeatureSpaceOperations(pca=TRUE)

</code></pre>

<hr>
<h2 id='makeTitle'>RclusTool makeTitle.</h2><span id='topic+makeTitle'></span>

<h3>Description</h3>

<p>Makes a character title from string by completion with a specified character.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeTitle(string, length = 120, prefix.length = 5, char = "_")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeTitle_+3A_string">string</code></td>
<td>
<p>string to be completed</p>
</td></tr>
<tr><td><code id="makeTitle_+3A_length">length</code></td>
<td>
<p>final title length in characters</p>
</td></tr>
<tr><td><code id="makeTitle_+3A_prefix.length">prefix.length</code></td>
<td>
<p>space length in front of the title</p>
</td></tr>
<tr><td><code id="makeTitle_+3A_char">char</code></td>
<td>
<p>character used to complete the title</p>
</td></tr>
</table>


<h3>Details</h3>

<p>makeTitle Makes a title from a string.
</p>


<h3>Value</h3>

<p>title
</p>

<hr>
<h2 id='matchNames'>Match Names</h2><span id='topic+matchNames'></span>

<h3>Description</h3>

<p>make a new character from two characters with maj/min adjustment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchNames(requested.names, names.set)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchNames_+3A_requested.names">requested.names</code></td>
<td>
<p>a character vector from an operation.</p>
</td></tr>
<tr><td><code id="matchNames_+3A_names.set">names.set</code></td>
<td>
<p>a character vector from Features/Profiles column.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>matchNames correct Maj/Min to match operations and Features/Profiles columns
</p>


<h3>Value</h3>

<p>character
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
matchedName&lt;-matchNames("Profiles","profiles")

matchedName

</code></pre>

<hr>
<h2 id='measureConstraintsOk'>Rates of constraints satisfaction</h2><span id='topic+measureConstraintsOk'></span>

<h3>Description</h3>

<p>Calculate the rates of ML and CNL constraints satisfaction in a clustering result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measureConstraintsOk(label, list.ML = list(), list.CNL = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="measureConstraintsOk_+3A_label">label</code></td>
<td>
<p>vector of labels.</p>
</td></tr>
<tr><td><code id="measureConstraintsOk_+3A_list.ml">list.ML</code></td>
<td>
<p>list of ML (must-link) constrained pairs.</p>
</td></tr>
<tr><td><code id="measureConstraintsOk_+3A_list.cnl">list.CNL</code></td>
<td>
<p>list of CNL (cannot-link) constrained pairs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>measureConstraintsOk returns the rates of constraints satisfaction
</p>


<h3>Value</h3>

<p>The function returns a list containing:
</p>
<table>
<tr><td><code>ML</code></td>
<td>
<p>rate of ML (must-link) constraints satisfaction.</p>
</td></tr>
<tr><td><code>CNL</code></td>
<td>
<p>rate of CNL (cannot-link) constraints satisfaction.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
           
ML &lt;- list()
ML[[1]] &lt;- c(sel="10",mem="20")
ML[[2]] &lt;- c(sel="60",mem="70")

CNL &lt;- list()
CNL[[1]] &lt;- c(sel="30",mem="80")
CNL[[2]] &lt;- c(sel="90",mem="120")

sim &lt;- computeGaussianSimilarity(dat, 1)
res &lt;- KwaySSSC(sim, K=0, list.ML=ML, list.CNL=CNL)

measureConstraintsOk(res$label, list.ML=ML, list.CNL=CNL)

</code></pre>

<hr>
<h2 id='measureMNCut'>Multiple Normalized Cut</h2><span id='topic+measureMNCut'></span>

<h3>Description</h3>

<p>Calculate the Multiple Normalized Cut value from a similarity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measureMNCut(sim, label)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="measureMNCut_+3A_sim">sim</code></td>
<td>
<p>similarity matrix.</p>
</td></tr>
<tr><td><code id="measureMNCut_+3A_label">label</code></td>
<td>
<p>vector of labels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>measureMNCut returns the Multiple Normalized Cut value
</p>


<h3>Value</h3>

<p>MNCut Multiple Normalized Cut value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
           
sim &lt;- computeGaussianSimilarity(dat, 1)

ML &lt;- list(c("10","20"),  c("60","70"))
CNL &lt;- list(c("30","80"), c("90","120"))

res &lt;- KwaySSSC(sim, K=0, list.ML=ML, list.CNL=CNL)

measureMNCut(sim, res$label)

</code></pre>

<hr>
<h2 id='messageConsole'>RclusTool consoleMessage.</h2><span id='topic+messageConsole'></span>

<h3>Description</h3>

<p>Adds a message in the RclusTool GUI.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>messageConsole(message, RclusTool.env = initParameters())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="messageConsole_+3A_message">message</code></td>
<td>
<p>string to print in the console.</p>
</td></tr>
<tr><td><code id="messageConsole_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>environment in which all global parameters, raw data and results are stored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>consoleMessage Adds a message in the RclusTool GUI.
</p>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='nameClusters'>Clusters renaming</h2><span id='topic+nameClusters'></span>

<h3>Description</h3>

<p>Assign a class name to each cluster obtained by unsupervised or semi-supervised classification, thanks to the use of a training set and the majority rule method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nameClusters(data.sample, method, RclusTool.env = initParameters())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nameClusters_+3A_data.sample">data.sample</code></td>
<td>
<p>list containing features, profiles and clustering results.</p>
</td></tr>
<tr><td><code id="nameClusters_+3A_method">method</code></td>
<td>
<p>character vector specifying the clustering method (already performed) to use.</p>
</td></tr>
<tr><td><code id="nameClusters_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>environment in which all global parameters, raw data and results are stored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>nameClusters assigns a class name to each cluster obtained by unsupervised or semi-supervised classification, thanks to the use of a training set and the majority rule method
</p>


<h3>Value</h3>

<p>data.sample list containing features, profiles and clustering results with updated labels names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf1 &lt;- tempfile()
write.table(dat, tf1, sep=",", dec=".")

x &lt;- importSample(file.features=tf1)
x &lt;- computeUnSupervised(x, K=3, method.name="K-means")

nameClusters(x, method = "K-means_preprocessed")



## End(Not run)
</code></pre>

<hr>
<h2 id='plotDensity2D'>plot Variables Density</h2><span id='topic+plotDensity2D'></span>

<h3>Description</h3>

<p>Plots density of a variable by cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDensity2D(
  data,
  parH = NULL,
  clustering.name,
  charsize = 11,
  col = c("grey", "black", "red", "blue", "green", "cyan", "yellow", "orange",
    "rosybrown", "palevioletred", "darkblue", "deeppink", "blueviolet", "darkgoldenrod1",
    "chartreuse", "darkorchid1", "deeppink", "coral", "darkolivegreen1", "#66C2A5",
    "#9DAE8C", "#D49A73", "#F08F6D", "#C79693", "#9E9DBA", "#9F9BC9", "#C193C6",
    "#E28BC3", "#D2A29F", "#BABF77", "#AAD852", "#CBD844", "#ECD836", "#FAD53E",
    "#F1CD64", "#E7C689", "#D7BF9C", "#C5B9A7", "#B3B3B3", "#D53E4F", "#E04F4A",
    "#EB6046", "#F47346", "#F88B51", 
     "#FBA35C", "#FDB869", "#FDCA79", "#FDDD88",
    "#F6E68F", "#EDEE93", "#E2F398", "#CDEA9D", "#B7E2A1", "#A0D8A4", "#86CEA4",
    "#6DC4A4", "#58B2AB", "#459DB4", "#3288BD")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDensity2D_+3A_data">data</code></td>
<td>
<p>density data.frame with x,y and Cluster indication.</p>
</td></tr>
<tr><td><code id="plotDensity2D_+3A_parh">parH</code></td>
<td>
<p>character vector specifying the name of the feature to use as x-axis.</p>
</td></tr>
<tr><td><code id="plotDensity2D_+3A_clustering.name">clustering.name</code></td>
<td>
<p>character vector specifying the name of the clustering.</p>
</td></tr>
<tr><td><code id="plotDensity2D_+3A_charsize">charsize</code></td>
<td>
<p>character size</p>
</td></tr>
<tr><td><code id="plotDensity2D_+3A_col">col</code></td>
<td>
<p>vector of colors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>plotDensity2D plots density of a variable by cluster
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf &lt;- tempfile()
write.table(dat, tf, sep=",", dec=".")

x &lt;- importSample(file.features=tf)
x &lt;- computeUnSupervised(x, K=3, method.name="K-means")

label&lt;-x[["clustering"]][["K-means_preprocessed"]][["label"]]

cluster.density &lt;- clusterDensity(x, label, "preprocessed",features.to.keep='V1')
plotDensity2D(cluster.density, clustering.name='Test Kmeans', parH='V1')


</code></pre>

<hr>
<h2 id='plotProfile'>Profile and image plotting</h2><span id='topic+plotProfile'></span>

<h3>Description</h3>

<p>Plot the profile and the image (if available) of a particle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotProfile(
  profiles,
  profiles.colors = NULL,
  image = NULL,
  curve.names = NULL,
  title = "Some observation",
  sub = "",
  sub.color = NULL,
  image.dir = NULL,
  charsize = 11
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotProfile_+3A_profiles">profiles</code></td>
<td>
<p>matrix of profile data (signals in columns).</p>
</td></tr>
<tr><td><code id="plotProfile_+3A_profiles.colors">profiles.colors</code></td>
<td>
<p>vector of colors corresponding to each signal in profile.</p>
</td></tr>
<tr><td><code id="plotProfile_+3A_image">image</code></td>
<td>
<p>character vector specifying the name (without path) + extension of the associated image (if available).</p>
</td></tr>
<tr><td><code id="plotProfile_+3A_curve.names">curve.names</code></td>
<td>
<p>vector of character specifying the names of each signal in profile.</p>
</td></tr>
<tr><td><code id="plotProfile_+3A_title">title</code></td>
<td>
<p>character vector specifying the title of the plot.</p>
</td></tr>
<tr><td><code id="plotProfile_+3A_sub">sub</code></td>
<td>
<p>character vector specifying the subtitle of the plot.</p>
</td></tr>
<tr><td><code id="plotProfile_+3A_sub.color">sub.color</code></td>
<td>
<p>character vector specifying the color of the subtitle.</p>
</td></tr>
<tr><td><code id="plotProfile_+3A_image.dir">image.dir</code></td>
<td>
<p>images directory.</p>
</td></tr>
<tr><td><code id="plotProfile_+3A_charsize">charsize</code></td>
<td>
<p>character size</p>
</td></tr>
</table>


<h3>Details</h3>

<p>plotProfile plots the profile and the image (if available) of a particle
</p>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotSampleFeatures">plotSampleFeatures</a></code>, <code><a href="#topic+visualizeSampleClustering">visualizeSampleClustering</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 6, sd = 0.3), ncol = 2))
colnames(dat) &lt;- c("x","y")
tf1 &lt;- tempfile()
write.table(dat, tf1, sep=",", dec=".")

sig &lt;- data.frame(ID=rep(1:150, each=30), SIGNAL=rep(dnorm(seq(-2,2,length=30)),150))
tf2 &lt;- tempfile()
write.table(sig, tf2, sep=",", dec=".")

x &lt;- importSample(file.features=tf1, file.profiles=tf2)

plotProfile(x$profiles[[1]])


</code></pre>

<hr>
<h2 id='plotProfileExtract'>Profile and image plotting</h2><span id='topic+plotProfileExtract'></span>

<h3>Description</h3>

<p>Plot the profile and the image (if available) of a particle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotProfileExtract(
  profiles,
  profiles.colors = NULL,
  image = NULL,
  curve.names = NULL,
  title = "Some observation",
  sub = "",
  sub.color = NULL,
  image.dir = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotProfileExtract_+3A_profiles">profiles</code></td>
<td>
<p>matrix of profile data (signals in columns).</p>
</td></tr>
<tr><td><code id="plotProfileExtract_+3A_profiles.colors">profiles.colors</code></td>
<td>
<p>vector of colors corresponding to each signal in profile.</p>
</td></tr>
<tr><td><code id="plotProfileExtract_+3A_image">image</code></td>
<td>
<p>character vector specifying the name (without path) + extension of the associated image (if available).</p>
</td></tr>
<tr><td><code id="plotProfileExtract_+3A_curve.names">curve.names</code></td>
<td>
<p>vector of character specifying the names of each signal in profile.</p>
</td></tr>
<tr><td><code id="plotProfileExtract_+3A_title">title</code></td>
<td>
<p>character vector specifying the title of the plot.</p>
</td></tr>
<tr><td><code id="plotProfileExtract_+3A_sub">sub</code></td>
<td>
<p>character vector specifying the subtitle of the plot.</p>
</td></tr>
<tr><td><code id="plotProfileExtract_+3A_sub.color">sub.color</code></td>
<td>
<p>character vector specifying the color of the subtitle.</p>
</td></tr>
<tr><td><code id="plotProfileExtract_+3A_image.dir">image.dir</code></td>
<td>
<p>images directory.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>plotProfileExtract plots the profile and the image (if available) of a particle
</p>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotSampleFeatures">plotSampleFeatures</a></code>, <code><a href="#topic+visualizeSampleClustering">visualizeSampleClustering</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 6, sd = 0.3), ncol = 2))
colnames(dat) &lt;- c("x","y")
tf1 &lt;- tempfile()
write.table(dat, tf1, sep=",", dec=".")

sig &lt;- data.frame(ID=rep(1:150, each=30), SIGNAL=rep(dnorm(seq(-2,2,length=30)),150))
tf2 &lt;- tempfile()
write.table(sig, tf2, sep=",", dec=".")

x &lt;- importSample(file.features=tf1, file.profiles=tf2)

plotProfileExtract(x$profiles[[1]])


</code></pre>

<hr>
<h2 id='plotSampleFeatures'>2D-features scatter-plot</h2><span id='topic+plotSampleFeatures'></span>

<h3>Description</h3>

<p>Plot 2D-features scatter-plot of all particles. Grey color (label=0) is for data to cleaned or to remove in classification process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSampleFeatures(
  data,
  label,
  parH = NULL,
  parV = NULL,
  figure.title = "Scatter plot",
  logscale = "",
  cex = 0.8,
  point.param = expand.grid(col = c("grey", "black", "red", "blue", "green", "cyan",
    "yellow", "orange", "rosybrown", "palevioletred", "darkblue", "deeppink",
    "blueviolet", "darkgoldenrod1", "chartreuse", "darkorchid1", "deeppink", "coral",
    "darkolivegreen1", "#66C2A5", "#9DAE8C", "#D49A73", "#F08F6D", "#C79693", "#9E9DBA",
    "#9F9BC9", "#C193C6", "#E28BC3", "#D2A29F", "#BABF77", "#AAD852", "#CBD844",
    "#ECD836", "#FAD53E", "#F1CD64", "#E7C689", "#D7BF9C", "#C5B9A7", "#B3B3B3",
    "#D53E4F", "#E04F4A", "#EB6046", "#F47346", 
     "#F88B51", "#FBA35C", "#FDB869",
    "#FDCA79", "#FDDD88", "#F6E68F", "#EDEE93", "#E2F398", "#CDEA9D", "#B7E2A1",
    "#A0D8A4", "#86CEA4", "#6DC4A4", "#58B2AB", "#459DB4", "#3288BD"), pch = c(20, 0:18),
    stringsAsFactors = FALSE),
  env.plot = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSampleFeatures_+3A_data">data</code></td>
<td>
<p>matrix or data.frame of raw data (points by line).</p>
</td></tr>
<tr><td><code id="plotSampleFeatures_+3A_label">label</code></td>
<td>
<p>vector of labels.</p>
</td></tr>
<tr><td><code id="plotSampleFeatures_+3A_parh">parH</code></td>
<td>
<p>character vector specifying the name of the feature to use as x-axis.</p>
</td></tr>
<tr><td><code id="plotSampleFeatures_+3A_parv">parV</code></td>
<td>
<p>character vector specifying the name of the feature to use as y-axis.</p>
</td></tr>
<tr><td><code id="plotSampleFeatures_+3A_figure.title">figure.title</code></td>
<td>
<p>character vector specifying the title of the scatter-plot.</p>
</td></tr>
<tr><td><code id="plotSampleFeatures_+3A_logscale">logscale</code></td>
<td>
<p>character vector containing &quot;x&quot; if the x-axis is to be logarithmic, &quot;y&quot; if the y-axis is to be logarithmic and &quot;xy&quot; or &quot;yx&quot; if both axes are to be logarithmic.</p>
</td></tr>
<tr><td><code id="plotSampleFeatures_+3A_cex">cex</code></td>
<td>
<p>numeric value specifying the size of the graphical labels.</p>
</td></tr>
<tr><td><code id="plotSampleFeatures_+3A_point.param">point.param</code></td>
<td>
<p>data.frame specifying the colors and the symbols to use for clusters display.</p>
</td></tr>
<tr><td><code id="plotSampleFeatures_+3A_env.plot">env.plot</code></td>
<td>
<p>environment where to store graphical parameters used by function PlotScatter to select points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>plotSampleFeatures plots 2D-features scatter-plot of all particles
</p>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotProfile">plotProfile</a></code>, <code><a href="#topic+visualizeSampleClustering">visualizeSampleClustering</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 6, sd = 0.3), ncol = 2))
colnames(dat) &lt;- c("x","y")
tf1 &lt;- tempfile()
write.table(dat, tf1, sep=",", dec=".")

sig &lt;- data.frame(ID=rep(1:150, each=30), SIGNAL=rep(dnorm(seq(-2,2,length=30)),150))
tf2 &lt;- tempfile()
write.table(sig, tf2, sep=",", dec=".")

x &lt;- importSample(file.features=tf1, file.profiles=tf2)

res &lt;- KmeansQuick(x$features$initial$x, K=3)
new.labels &lt;- formatLabelSample(res$cluster, x)

plotSampleFeatures(x$features$initial$x, label = new.labels, parH="x", parV="y")


</code></pre>

<hr>
<h2 id='previewCSVfile'>Preview CSV file</h2><span id='topic+previewCSVfile'></span>

<h3>Description</h3>

<p>This function generates a window printing first rows of the csv file and the first rows of the data.frame obtained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>previewCSVfile(file, sep, dec, na.strings, RclusTool.env, nrows = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="previewCSVfile_+3A_file">file</code></td>
<td>
<p>: csv filename.</p>
</td></tr>
<tr><td><code id="previewCSVfile_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>environment in which data and intermediate results are stored.</p>
</td></tr>
<tr><td><code id="previewCSVfile_+3A_nrows">nrows</code></td>
<td>
<p>: number of rows to be read.</p>
</td></tr>
<tr><td><code id="previewCSVfile_+3A_...">...</code></td>
<td>
<p>: other parameters of read.csv function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function to preview csv file
</p>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='purgeSample'>Sample purging</h2><span id='topic+purgeSample'></span>

<h3>Description</h3>

<p>Purge sample from its temporary computing results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>purgeSample(
  data.sample,
  purge.preprocessing = TRUE,
  purge.clustering = TRUE,
  user.expert = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="purgeSample_+3A_data.sample">data.sample</code></td>
<td>
<p>sample object</p>
</td></tr>
<tr><td><code id="purgeSample_+3A_purge.preprocessing">purge.preprocessing</code></td>
<td>
<p>boolean: if TRUE (default), the configuration is reset.</p>
</td></tr>
<tr><td><code id="purgeSample_+3A_purge.clustering">purge.clustering</code></td>
<td>
<p>boolean: if TRUE (default), the clusterings are reset.</p>
</td></tr>
<tr><td><code id="purgeSample_+3A_user.expert">user.expert</code></td>
<td>
<p>boolean : if FALSE (default), initial classification feature space is PCA.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function to purgeSample from its temporary computing results
</p>


<h3>Value</h3>

<p>data.sample purged data.sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf &lt;- tempfile()
write.table(dat, tf, sep=",", dec=".")

x &lt;- importSample(file.features=tf)
x &lt;- computeUnSupervised(x, K=3, method.name="K-means")
x &lt;- purgeSample(x, purge.clustering=TRUE)


</code></pre>

<hr>
<h2 id='RclusToolGUI'>Username and user type selection</h2><span id='topic+RclusToolGUI'></span>

<h3>Description</h3>

<p>Generate a first window to enter the username and to select the user type ('standard' or 'expert').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RclusToolGUI(RclusTool.env = new.env(), debug = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RclusToolGUI_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>environment in which data and results will be stored. If NULL, a local environment will be created.</p>
</td></tr>
<tr><td><code id="RclusToolGUI_+3A_debug">debug</code></td>
<td>
<p>boolean: if TRUE, the debug mode is activated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function to display the first window of the RclusTool interface (username and user type selection)
</p>


<h3>Value</h3>

<p>Nothing, just open the graphical user interface.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RclusToolGUI()

</code></pre>

<hr>
<h2 id='readTrainSet'>Training set reading</h2><span id='topic+readTrainSet'></span>

<h3>Description</h3>

<p>Read a training set built from prototypes, to train a classifier for supervised classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readTrainSet(
  traindir,
  keep_ = FALSE,
  operations = NULL,
  RclusTool.env = initParameters()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readTrainSet_+3A_traindir">traindir</code></td>
<td>
<p>character vector specifying the path of the training set.</p>
</td></tr>
<tr><td><code id="readTrainSet_+3A_keep_">keep_</code></td>
<td>
<p>boolean: if FALSE (default), the '_' directory is not considered in the training set.</p>
</td></tr>
<tr><td><code id="readTrainSet_+3A_operations">operations</code></td>
<td>
<p>list of data.frames describing all preprocessing operations.</p>
</td></tr>
<tr><td><code id="readTrainSet_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>environment in which all global parameters, raw data and results are stored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>readTrainSet reads a training set built from prototypes, to train a classifier for supervised classification
</p>


<h3>Value</h3>

<p>prototypes data.frame containing the features of each prototype associated to a class.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dropTrainSetVars">dropTrainSetVars</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rep &lt;- system.file("extdata", package="RclusTool")
traindir &lt;- file.path(rep, "train_example")
train &lt;- readTrainSet(traindir)

</code></pre>

<hr>
<h2 id='removeZeros'>Zeros replacement</h2><span id='topic+removeZeros'></span>

<h3>Description</h3>

<p>Replace all zeros-like values (in [-threshold,+threshold])
by +threshold (if positive values are required) or +/-threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeZeros(x, threshold = .Machine$double.eps, positive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeZeros_+3A_x">x</code></td>
<td>
<p>numeric matrix or data.frame of raw data (points by line).</p>
</td></tr>
<tr><td><code id="removeZeros_+3A_threshold">threshold</code></td>
<td>
<p>numeric value; must be positive.</p>
</td></tr>
<tr><td><code id="removeZeros_+3A_positive">positive</code></td>
<td>
<p>boolean: if TRUE, zeros-like values are replaced by +threshold</p>
</td></tr>
</table>


<h3>Details</h3>

<p>removeZeros replaces all zeros-like values (in [-threshold,+threshold])
</p>


<h3>Value</h3>

<p>x numeric matrix or data.frame of raw data (points by line), with no zeros.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf &lt;- tempfile()
write.table(dat, tf, sep=",", dec=".")
x &lt;- importSample(file.features=tf)

res &lt;- removeZeros(x$features$initial$x)  


</code></pre>

<hr>
<h2 id='saveCalcul'>Object saving</h2><span id='topic+saveCalcul'></span>

<h3>Description</h3>

<p>Save object created after calculation in a csv file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveCalcul(filename.rdata, dat, dir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveCalcul_+3A_filename.rdata">filename.rdata</code></td>
<td>
<p>character vector specifying the path and the name of the rdata file.</p>
</td></tr>
<tr><td><code id="saveCalcul_+3A_dat">dat</code></td>
<td>
<p>object to save.</p>
</td></tr>
<tr><td><code id="saveCalcul_+3A_dir">dir</code></td>
<td>
<p>character vector specifying the directory where to save the rdata file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>saveCalcul saves object created after calculation in a csv file
</p>


<h3>Value</h3>

<p>RDS file containing calculation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf1 &lt;- tempfile()
write.table(dat, tf1, sep=",", dec=".")

x &lt;- importSample(file.features=tf1)
res.pca &lt;- computePcaSample(x)

tf2 &lt;- tempfile()
saveCalcul(basename(tf2), res.pca$pca, dirname(tf2))


</code></pre>

<hr>
<h2 id='saveClustering'>Clustering saving</h2><span id='topic+saveClustering'></span>

<h3>Description</h3>

<p>Save a clustering result in a csv file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveClustering(filename.csv, label, dir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveClustering_+3A_filename.csv">filename.csv</code></td>
<td>
<p>character vector specifying the path and the name of the csv file.</p>
</td></tr>
<tr><td><code id="saveClustering_+3A_label">label</code></td>
<td>
<p>vector of labels.</p>
</td></tr>
<tr><td><code id="saveClustering_+3A_dir">dir</code></td>
<td>
<p>character vector specifying the directory where to save the csv file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>saveClustering saves a clustering result in a csv file
</p>


<h3>Value</h3>

<p>csv file containing clustering result.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildClusteringSample">buildClusteringSample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf1 &lt;- tempfile()
write.table(dat, tf1, sep=",", dec=".")

x &lt;- importSample(file.features=tf1, dir.save=tempdir())
res &lt;- KmeansQuick(x$features$initial$x, K=3)

tf2 &lt;- tempfile()
saveClustering(basename(tf2), res$cluster, tempdir())


</code></pre>

<hr>
<h2 id='saveCounts'>Count saving</h2><span id='topic+saveCounts'></span>

<h3>Description</h3>

<p>Save a count result in a csv file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveCounts(filename.csv, counts, dir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveCounts_+3A_filename.csv">filename.csv</code></td>
<td>
<p>character vector specifying the path and the name of the csv file.</p>
</td></tr>
<tr><td><code id="saveCounts_+3A_counts">counts</code></td>
<td>
<p>vector of counts.</p>
</td></tr>
<tr><td><code id="saveCounts_+3A_dir">dir</code></td>
<td>
<p>character vector specifying the directory where to save the csv file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>saveCounts saves a count result in a csv file
</p>


<h3>Value</h3>

<p>csv file containing count result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf1 &lt;- tempfile()
write.table(dat, tf1, sep=",", dec=".")

x &lt;- importSample(file.features=tf1)
res &lt;- KmeansQuick(x$features$initial$x, K=3)

tf2 &lt;- tempfile()
saveCounts(basename(tf2), table(res$cluster), dirname(tf2))
 

</code></pre>

<hr>
<h2 id='saveLogFile'>Log file saving</h2><span id='topic+saveLogFile'></span>

<h3>Description</h3>

<p>Save a log txt file at the end of the session, describing the different steps of the analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveLogFile(filename.txt, txt, dir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveLogFile_+3A_filename.txt">filename.txt</code></td>
<td>
<p>character vector specifying the path and the name of the txt file.</p>
</td></tr>
<tr><td><code id="saveLogFile_+3A_txt">txt</code></td>
<td>
<p>character vector describing the different steps of the analyses.</p>
</td></tr>
<tr><td><code id="saveLogFile_+3A_dir">dir</code></td>
<td>
<p>character vector specifying the directory where to save the txt file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>saveLogFile saves a log txt file at the end of the session, describing the different steps of the analyses
</p>


<h3>Value</h3>

<p>log txt file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logfile &lt;- tempfile()
saveLogFile(basename(logfile), txt=rbind("Analysis date: ...", "Analysis duration: ..."), 
     dirname(logfile))


</code></pre>

<hr>
<h2 id='saveManualProtos'>Manual prototypes saving</h2><span id='topic+saveManualProtos'></span>

<h3>Description</h3>

<p>Save the profiles and images of prototypes selected manually by user in a scatterplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveManualProtos(data.sample, protos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveManualProtos_+3A_data.sample">data.sample</code></td>
<td>
<p>list containing features, profiles and clustering results.</p>
</td></tr>
<tr><td><code id="saveManualProtos_+3A_protos">protos</code></td>
<td>
<p>list of selected prototypes (with index and name).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>saveManualProtos saves the profiles and images of prototypes selected manually by user in a scatterplot
</p>


<h3>Value</h3>

<p>profiles and images of prototypes selected, csv file with detail.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf &lt;- tempfile()
write.table(dat, tf, sep=",", dec=".")

x &lt;- importSample(file.features=tf1, dir.save=dirname(tf))

new.protos &lt;- visualizeSampleClustering(x, selection.mode = "prototypes", 
			 profile.mode="whole sample", wait.close=FALSE)
saveManualProtos(x, new.protos)


## End(Not run)
</code></pre>

<hr>
<h2 id='savePreprocess'>Preprocessing exportation</h2><span id='topic+savePreprocess'></span>

<h3>Description</h3>

<p>Export all preprocessing operations in a csv file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>savePreprocess(filename.csv, config, dir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="savePreprocess_+3A_filename.csv">filename.csv</code></td>
<td>
<p>character vector specifying the name of the csv file.</p>
</td></tr>
<tr><td><code id="savePreprocess_+3A_config">config</code></td>
<td>
<p>4-columns character matrix describing all preprocessing operations.</p>
</td></tr>
<tr><td><code id="savePreprocess_+3A_dir">dir</code></td>
<td>
<p>character vector specifying the directory of the csv file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>savePreprocess exports all preprocessing operations in a csv file
</p>


<h3>Value</h3>

<p>csv file containing preprocessing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test.file &lt;- tempfile()
config &lt;- matrix(c("select","x",NA,NA,"select","y",NA,NA), byrow=TRUE, ncol=4)
savePreprocess(basename(test.file), config, dirname(test.file))


</code></pre>

<hr>
<h2 id='saveSummary'>Clusters summaries saving</h2><span id='topic+saveSummary'></span>

<h3>Description</h3>

<p>Save clusters summaries results in a csv file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveSummary(filename.csv, cluster.summary, dir, info = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveSummary_+3A_filename.csv">filename.csv</code></td>
<td>
<p>character vector specifying the path and the name of the csv file.</p>
</td></tr>
<tr><td><code id="saveSummary_+3A_cluster.summary">cluster.summary</code></td>
<td>
<p>data.frame containing the clusters summaries results.</p>
</td></tr>
<tr><td><code id="saveSummary_+3A_dir">dir</code></td>
<td>
<p>character vector specifying the directory where to save the csv file.</p>
</td></tr>
<tr><td><code id="saveSummary_+3A_info">info</code></td>
<td>
<p>character vector about sample or clustering.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>saveSummary saves clusters summaries results in a csv file
</p>


<h3>Value</h3>

<p>csv file containing clusters summaries results.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loadSummary">loadSummary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
colnames(dat) &lt;- c("x","y")
tf1 &lt;- tempfile()
write.table(dat, tf1, sep=",", dec=".")

x &lt;- importSample(file.features=tf1)
res &lt;- KmeansQuick(x$features$initial$x, K=3)
labels &lt;- formatLabelSample(res$cluster, x)
cluster.summary &lt;- clusterSummary(x, labels)

tf2 &lt;- tempfile()
saveSummary(basename(tf2), cluster.summary, dirname(tf2))


</code></pre>

<hr>
<h2 id='search.neighbour'>Search neighbour</h2><span id='topic+search.neighbour'></span>

<h3>Description</h3>

<p>search.neighbour give the id of the Kth nearest neighbour
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search.neighbour(vdist, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search.neighbour_+3A_vdist">vdist</code></td>
<td>
<p>distance vector of point with other points</p>
</td></tr>
<tr><td><code id="search.neighbour_+3A_k">k</code></td>
<td>
<p>number of neighbours</p>
</td></tr>
</table>


<h3>Value</h3>

<p>id of the Kth nearest neighbour
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeGaussianSimilarityZP">computeGaussianSimilarityZP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
vdist=c(0,2,1,5,7,1,3)

id&lt;-search.neighbour(vdist,2)
</code></pre>

<hr>
<h2 id='sigClassif'>Signals clustering</h2><span id='topic+sigClassif'></span>

<h3>Description</h3>

<p>Sort signals (if available) in different directories according to a clustering result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigClassif(data.sample, method, user.name = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigClassif_+3A_data.sample">data.sample</code></td>
<td>
<p>list containing features, profiles and clustering results.</p>
</td></tr>
<tr><td><code id="sigClassif_+3A_method">method</code></td>
<td>
<p>character vector specifying the clustering method (already performed) to use.</p>
</td></tr>
<tr><td><code id="sigClassif_+3A_user.name">user.name</code></td>
<td>
<p>character vector specifying the user name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>sigClassif sorts signals (if available) in different directories according to a clustering result
</p>


<h3>Value</h3>

<p>signals plots images in the different directories.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+imgClassif">imgClassif</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf1 &lt;- tempfile()
write.table(dat, tf1, sep=",", dec=".")

sig &lt;- data.frame(ID=rep(1:150, each=30), SIGNAL=rep(dnorm(seq(-2,2,length=30)),150))
tf2 &lt;- tempfile()
write.table(sig, tf2, sep=",", dec=".")

dir.results &lt;- tempdir()
x &lt;- importSample(file.features=tf1,file.profiles = tf2, dir.save=dir.results)
x &lt;- computeUnSupervised(x, K=3, method.name="K-means")

sigClassif(x, method = "K-means_preprocessed")
 

</code></pre>

<hr>
<h2 id='sortCharAsNum'>Character vector numeric sorting</h2><span id='topic+sortCharAsNum'></span>

<h3>Description</h3>

<p>Performs sorting of a vector of characters numerically, if possible
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortCharAsNum(char.vec, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sortCharAsNum_+3A_char.vec">char.vec</code></td>
<td>
<p>a character vector, describing numbers.</p>
</td></tr>
<tr><td><code id="sortCharAsNum_+3A_...">...</code></td>
<td>
<p>other parameters controlling the order treatment of the character vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>sortCharAsNum performs sorting of a vector of characters numerically, if possible
</p>


<h3>Value</h3>

<p>the character vector sorted, if possible.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeSemiSupervised">computeSemiSupervised</a></code>, <code><a href="#topic+KwaySSSC">KwaySSSC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("12", "8", "101")

sortCharAsNum(x)

</code></pre>

<hr>
<h2 id='sortLabel'>Clusters labels sorting</h2><span id='topic+sortLabel'></span>

<h3>Description</h3>

<p>Sort clusters labels by decreasing sizes for unsupervised classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortLabel(label)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sortLabel_+3A_label">label</code></td>
<td>
<p>vector of labels (integers).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>sortLabel sorts clusters labels by decreasing sizes, in unsupervised classification
</p>


<h3>Value</h3>

<p>sorted labels
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf &lt;- tempfile()
write.table(dat, tf, sep=",", dec=".")

x &lt;- importSample(file.features=tf)
res &lt;- KmeansQuick(x$features$initial$x, K=3)

sortLabel(res$cluster)


</code></pre>

<hr>
<h2 id='spectralClustering'>Spectral clustering</h2><span id='topic+spectralClustering'></span>

<h3>Description</h3>

<p>Perform spectral clustering thanks to a similarity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectralClustering(
  sim,
  K,
  nruns = 1,
  test.dim = FALSE,
  projection = "Ng",
  post.norm = "sphere",
  clustering = "kmeans",
  max.dim = 30,
  add.1 = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectralClustering_+3A_sim">sim</code></td>
<td>
<p>similarity matrix.</p>
</td></tr>
<tr><td><code id="spectralClustering_+3A_k">K</code></td>
<td>
<p>number of clusters.</p>
</td></tr>
<tr><td><code id="spectralClustering_+3A_nruns">nruns</code></td>
<td>
<p>number of random sets.</p>
</td></tr>
<tr><td><code id="spectralClustering_+3A_test.dim">test.dim</code></td>
<td>
<p>boolean, only used to test dimensions (setting the number of left singular vectors to be computed).</p>
</td></tr>
<tr><td><code id="spectralClustering_+3A_projection">projection</code></td>
<td>
<p>character: final data projection. Must be 'Ng' (default), 'LPP', or 'AFC'.</p>
</td></tr>
<tr><td><code id="spectralClustering_+3A_post.norm">post.norm</code></td>
<td>
<p>character: final data normalization. Must be 'sphere' (default) or 'Shi'.</p>
</td></tr>
<tr><td><code id="spectralClustering_+3A_clustering">clustering</code></td>
<td>
<p>character: clustering method in the spectral space. Must be 'kmeans' (default) or 'pam'.</p>
</td></tr>
<tr><td><code id="spectralClustering_+3A_max.dim">max.dim</code></td>
<td>
<p>maximal number of dimensions for the computation of left sigular vectors.</p>
</td></tr>
<tr><td><code id="spectralClustering_+3A_add.1">add.1</code></td>
<td>
<p>boolean : if TRUE add a column to the matrix containing the eigenvectors of the similarity matrix equal to 1/sqrt(nrow(similarity matrix))</p>
</td></tr>
</table>


<h3>Details</h3>

<p>spectralClustering returns a partition obtained by spectral clustering
</p>


<h3>Value</h3>

<p>The function returns a list containing:
</p>
<table>
<tr><td><code>label</code></td>
<td>
<p>vector of labels.</p>
</td></tr>
<tr><td><code>medoids</code></td>
<td>
<p>matrix of cluster centers in the space of the K first normalized eigenvectors.</p>
</td></tr>
<tr><td><code>id.med</code></td>
<td>
<p>vector containing the medoids indices.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>matrix containing, in columns, the eigenvectors of the similarity matrix.</p>
</td></tr>
<tr><td><code>eigen.val</code></td>
<td>
<p>vector containing the eigenvalues of the similarity matrix.</p>
</td></tr>
<tr><td><code>cluster.info</code></td>
<td>
<p>some statistics on each cluster.</p>
</td></tr>
<tr><td><code>ncp</code></td>
<td>
<p>number of left singular vectors computed.</p>
</td></tr>
</table>


<h3>References</h3>

<p>A. Ng, M. Jordan, Y. Weiss, On spectral clustering: Analysis and an algorithm, Neural Inf. Process. Systems NIPS14 (2002), pp. 849-856.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spectralClusteringNg">spectralClusteringNg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))

sim &lt;- computeGaussianSimilarity(dat, 1)
res &lt;- spectralClustering(sim, K=3)

plot(dat[,1], dat[,2], type = "p", xlab = "x", ylab = "y", 
col = res$label, main = "Initial features space")
plot(res$x[,1], res$x[,2], type = "p", xlab = "2nd eigenvector", 
	ylab = "3rd eigenvector", col = res$label, main = "Spectral embedding")

</code></pre>

<hr>
<h2 id='spectralClusteringNg'>Spectral clustering</h2><span id='topic+spectralClusteringNg'></span>

<h3>Description</h3>

<p>Perform spectral clustering thanks to a similarity matrix (according to Ng et al., 2002).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectralClusteringNg(sim, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectralClusteringNg_+3A_sim">sim</code></td>
<td>
<p>similarity matrix.</p>
</td></tr>
<tr><td><code id="spectralClusteringNg_+3A_k">K</code></td>
<td>
<p>number of clusters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>spectralClusteringNg returns a partition obtained by spectral clustering (according to Ng et al., 2002)
</p>


<h3>Value</h3>

<p>The function returns a list containing:
</p>
<table>
<tr><td><code>label</code></td>
<td>
<p>vector of labels.</p>
</td></tr>
<tr><td><code>medoids</code></td>
<td>
<p>matrix of cluster centers in the space of the K first normalized eigenvectors.</p>
</td></tr>
<tr><td><code>id.med</code></td>
<td>
<p>vector containing the medoids indices.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>matrix containing, in columns, the eigenvectors of the similarity matrix.</p>
</td></tr>
<tr><td><code>eigen.val</code></td>
<td>
<p>vector containing the eigenvalues of the similarity matrix.</p>
</td></tr>
<tr><td><code>cluster.info</code></td>
<td>
<p>some statistics on each cluster.</p>
</td></tr>
</table>


<h3>References</h3>

<p>A. Ng, M. Jordan, Y. Weiss, On spectral clustering: Analysis and an algorithm, Neural Inf. Process. Systems NIPS14 (2002), pp. 849-856.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spectralClustering">spectralClustering</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))

sim &lt;- computeGaussianSimilarity(dat, 1)
res &lt;- spectralClusteringNg(sim, K=3)

plot(dat[,1], dat[,2], type = "p", xlab = "x", ylab = "y", 
col = res$label, main = "Initial features space")
plot(res$x[,2], res$x[,3], type = "p", xlab = "2nd eigenvector", 
ylab = "3rd eigenvector", col = res$label, main = "Spectral embedding")
</code></pre>

<hr>
<h2 id='spectralEmbeddingNg'>Spectral embedding</h2><span id='topic+spectralEmbeddingNg'></span>

<h3>Description</h3>

<p>Build a spectral space from a similarity matrix (according to Ng et al., 2002).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectralEmbeddingNg(sim, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectralEmbeddingNg_+3A_sim">sim</code></td>
<td>
<p>similarity matrix.</p>
</td></tr>
<tr><td><code id="spectralEmbeddingNg_+3A_k">K</code></td>
<td>
<p>number of clusters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>spectralEmbeddingNg returns a spectral space built from a similarity matrix (according to Ng et al., 2002)
</p>


<h3>Value</h3>

<p>The function returns a list containing:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>matrix containing, in columns, the eigenvectors of the similarity matrix.</p>
</td></tr>
<tr><td><code>eigen.val</code></td>
<td>
<p>vector containing the eigenvalues of the similarity matrix.</p>
</td></tr>
</table>


<h3>References</h3>

<p>A. Ng, M. Jordan, Y. Weiss, On spectral clustering: Analysis and an algorithm, Neural Inf. Process. Systems NIPS14 (2002), pp. 849-856.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
           matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))

sim &lt;- computeGaussianSimilarity(dat, 1)
res &lt;- spectralEmbeddingNg(sim, K=3)

plot(res$x[,2], res$x[,3], type = "p", xlab = "2nd eigenvector", ylab = "3rd eigenvector")
</code></pre>

<hr>
<h2 id='tk2add.notetab'>Add notetab.</h2><span id='topic+tk2add.notetab'></span>

<h3>Description</h3>

<p>Add a notetab.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk2add.notetab(nb, tab.label, tab.name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tk2add.notetab_+3A_nb">nb</code></td>
<td>
<p>a notebook.</p>
</td></tr>
<tr><td><code id="tk2add.notetab_+3A_tab.label">tab.label</code></td>
<td>
<p>string the label of a tab on the interface.</p>
</td></tr>
<tr><td><code id="tk2add.notetab_+3A_tab.name">tab.name</code></td>
<td>
<p>string the name of the tab in a notebook.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>tk2add.notetab add a notetab.
</p>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='tk2delete.notetab'>Delete notetab inside a tk-notebook</h2><span id='topic+tk2delete.notetab'></span>

<h3>Description</h3>

<p>Delete notetab inside a tk-notebook.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk2delete.notetab(nb, tab.names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tk2delete.notetab_+3A_nb">nb</code></td>
<td>
<p>a notebook.</p>
</td></tr>
<tr><td><code id="tk2delete.notetab_+3A_tab.names">tab.names</code></td>
<td>
<p>either NULL to delete all the notetabs, or a vector of notetab names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>tk2delete.notetab delete a notetab
</p>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='tk2draw.notetab'>Draw in a Notetab.</h2><span id='topic+tk2draw.notetab'></span>

<h3>Description</h3>

<p>Draw in a Notetab with a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk2draw.notetab(nb, tab.name, fun, hscale = 1.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tk2draw.notetab_+3A_nb">nb</code></td>
<td>
<p>a notebook.</p>
</td></tr>
<tr><td><code id="tk2draw.notetab_+3A_tab.name">tab.name</code></td>
<td>
<p>name of the tk2notetab variable.</p>
</td></tr>
<tr><td><code id="tk2draw.notetab_+3A_fun">fun</code></td>
<td>
<p>a function.</p>
</td></tr>
<tr><td><code id="tk2draw.notetab_+3A_hscale">hscale</code></td>
<td>
<p>numeric value corresponding to the horizontal scale of graphic</p>
</td></tr>
</table>


<h3>Details</h3>

<p>tk2draw.notetab draw in a notetab.
</p>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='tk2notetab.RclusTool'>RclusTool tk2notetab.</h2><span id='topic+tk2notetab.RclusTool'></span>

<h3>Description</h3>

<p>RclusTool adaptation of tk2notetab; builds and returns a R tk2notetab matching a notetab already declared in tk notebook.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk2notetab.RclusTool(nb, tab.label, tab.name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tk2notetab.RclusTool_+3A_nb">nb</code></td>
<td>
<p>a tk2notebook or ttk2notebook widget.</p>
</td></tr>
<tr><td><code id="tk2notetab.RclusTool_+3A_tab.label">tab.label</code></td>
<td>
<p>the label of a tab on the interface.</p>
</td></tr>
<tr><td><code id="tk2notetab.RclusTool_+3A_tab.name">tab.name</code></td>
<td>
<p>the name of the tab in a notebook.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>tk2notetab.RclusTool RclusTool adaptation of tk2notetab.
</p>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='tkEmptyLine'>RclusTool tkEmptyLine.</h2><span id='topic+tkEmptyLine'></span>

<h3>Description</h3>

<p>Makes a character title from string by completion with a specified character.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tkEmptyLine(tk.object, row = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tkEmptyLine_+3A_tk.object">tk.object</code></td>
<td>
<p>tk object in which to insert the new line</p>
</td></tr>
<tr><td><code id="tkEmptyLine_+3A_row">row</code></td>
<td>
<p>row number of the insertion</p>
</td></tr>
</table>


<h3>Details</h3>

<p>tkEmptyLine Inserts an empty line in a graphical tk objects dealt with grid.
</p>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='tkrplot.RclusTool'>RclusTool tkrplot.</h2><span id='topic+tkrplot.RclusTool'></span>

<h3>Description</h3>

<p>RclusTool adaptation of tkrplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tkrplot.RclusTool(graphicFrame, fun, hscale = 1, vscale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tkrplot.RclusTool_+3A_graphicframe">graphicFrame</code></td>
<td>
<p>frame of the RclusTool interface in which graphics should be displayed.</p>
</td></tr>
<tr><td><code id="tkrplot.RclusTool_+3A_fun">fun</code></td>
<td>
<p>a function</p>
</td></tr>
<tr><td><code id="tkrplot.RclusTool_+3A_hscale">hscale</code></td>
<td>
<p>numeric value corresponding to the horizontal scale of graphic</p>
</td></tr>
<tr><td><code id="tkrplot.RclusTool_+3A_vscale">vscale</code></td>
<td>
<p>vertical scale</p>
</td></tr>
</table>


<h3>Details</h3>

<p>tkrplot.RclusTool RclusTool adaptation of tkrplot.
</p>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='tkrreplot.RclusTool'>RclusTool tkrreplot.</h2><span id='topic+tkrreplot.RclusTool'></span>

<h3>Description</h3>

<p>RclusTool adaptation of tkrreplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tkrreplot.RclusTool(env.graphic)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tkrreplot.RclusTool_+3A_env.graphic">env.graphic</code></td>
<td>
<p>graphic environment generated by tkrplot.RclusTool</p>
</td></tr>
</table>


<h3>Details</h3>

<p>tkrreplot.RclusTool RclusTool adaptation of tkrreplot.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tkrreplot.RclusTool">tkrreplot.RclusTool</a></code>
</p>

<hr>
<h2 id='toStringDataFrame'>To String Data Frame</h2><span id='topic+toStringDataFrame'></span>

<h3>Description</h3>

<p>Convert dataframe to string to print it in console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toStringDataFrame(object, digits = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toStringDataFrame_+3A_object">object</code></td>
<td>
<p>dataframe to convert to string</p>
</td></tr>
<tr><td><code id="toStringDataFrame_+3A_digits">digits</code></td>
<td>
<p>digits in dataframe</p>
</td></tr>
</table>


<h3>Details</h3>

<p>toStringDataFrame convert dataframe to string to print it in console
</p>


<h3>Value</h3>

<p>string to print.
</p>


<h3>References</h3>

<p><a href="https://stackoverflow.com/a/45541857">https://stackoverflow.com/a/45541857</a>
</p>

<hr>
<h2 id='updateClustersNames'>Clusters names updating</h2><span id='topic+updateClustersNames'></span>

<h3>Description</h3>

<p>Update the clusters names according to the names assigning to each prototype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateClustersNames(data.sample, protos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateClustersNames_+3A_data.sample">data.sample</code></td>
<td>
<p>list containing features, profiles and clustering results.</p>
</td></tr>
<tr><td><code id="updateClustersNames_+3A_protos">protos</code></td>
<td>
<p>list of selected prototypes (with index and name).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>updateClustersNames updates the clusters names according to the names assigning to each prototype
</p>


<h3>Value</h3>

<p>data.sample list containing features, profiles and clustering results with updated labels names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- rbind(matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2))
tf1 &lt;- tempfile()
write.table(dat, tf1, sep=",", dec=".")

x &lt;- importSample(file.features=tf1)

new.protos &lt;- visualizeSampleClustering(x, selection.mode = "prototypes", 
			 profile.mode="none", wait.close=FALSE)
x &lt;- updateClustersNames(x, new.protos$prototypes)


</code></pre>

<hr>
<h2 id='visualizeSampleClustering'>Interactive figure with 2D scatter-plot</h2><span id='topic+visualizeSampleClustering'></span>

<h3>Description</h3>

<p>Open an interactive figure with 2D scatter-plot of all particles with axis choice. Grey color (label=0) is for data to cleaned or to remove in classification process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visualizeSampleClustering(
  data.sample,
  label = NULL,
  clustering.name = "proposed clustering",
  cluster.summary = NULL,
  RclusTool.env = initParameters(),
  prototypes = NULL,
  profile.mode = "none",
  selection.mode = "none",
  compare.mode = "off",
  pairs = NULL,
  features.mode = "initial",
  wait.close = FALSE,
  fontsize = 9
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visualizeSampleClustering_+3A_data.sample">data.sample</code></td>
<td>
<p>list containing features, profiles and clustering results.</p>
</td></tr>
<tr><td><code id="visualizeSampleClustering_+3A_label">label</code></td>
<td>
<p>vector of labels.</p>
</td></tr>
<tr><td><code id="visualizeSampleClustering_+3A_clustering.name">clustering.name</code></td>
<td>
<p>character vector specifying the clustering method used to get labels.</p>
</td></tr>
<tr><td><code id="visualizeSampleClustering_+3A_cluster.summary">cluster.summary</code></td>
<td>
<p>data.frame containing the clusters summaries (as returned by 'clusterSummary').</p>
</td></tr>
<tr><td><code id="visualizeSampleClustering_+3A_rclustool.env">RclusTool.env</code></td>
<td>
<p>environment in which all global parameters, raw data and results are stored.</p>
</td></tr>
<tr><td><code id="visualizeSampleClustering_+3A_prototypes">prototypes</code></td>
<td>
<p>list containing vectors of prototypes indices.</p>
</td></tr>
<tr><td><code id="visualizeSampleClustering_+3A_profile.mode">profile.mode</code></td>
<td>
<p>character vector specifying the plot mode of profiles. Must be 'none' (default), 'whole sample', 'cluster i' or 'constrained pairs'.</p>
</td></tr>
<tr><td><code id="visualizeSampleClustering_+3A_selection.mode">selection.mode</code></td>
<td>
<p>character vector specifying the selection mode of profiles. Must be 'none' (default), 'prototypes' or 'pairs'.</p>
</td></tr>
<tr><td><code id="visualizeSampleClustering_+3A_compare.mode">compare.mode</code></td>
<td>
<p>character vector specifying the mode of comparison between two clusterings results. Must be 'off' (default) or 'on'.</p>
</td></tr>
<tr><td><code id="visualizeSampleClustering_+3A_pairs">pairs</code></td>
<td>
<p>list of constrained pairs (must-link and cannot-link).</p>
</td></tr>
<tr><td><code id="visualizeSampleClustering_+3A_features.mode">features.mode</code></td>
<td>
<p>character vector specifying the plot mode of features (projection in a specific space). Must be 'initial' (default), 'preprocessed', 'pca', 'pca_full' or 'spectral', or prefixed versions ('sampled', 'scaled') of those space names.</p>
</td></tr>
<tr><td><code id="visualizeSampleClustering_+3A_wait.close">wait.close</code></td>
<td>
<p>boolean: if FALSE (default), the following steps of the analysis calculations are computed even if the window is not closed.</p>
</td></tr>
<tr><td><code id="visualizeSampleClustering_+3A_fontsize">fontsize</code></td>
<td>
<p>size of font (default is 9)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>visualizeSampleClustering opens an interactive figure with 2D scatter-plot of all particles with axis choice
</p>


<h3>Value</h3>

<p>prototypes in <code>selection.mode</code> = &quot;prototypes&quot; mode, pairs in <code>selection.mode</code> = &quot;pairs&quot; mode.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotProfile">plotProfile</a></code>, <code><a href="#topic+plotSampleFeatures">plotSampleFeatures</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- rbind(matrix(rnorm(100, mean = 2, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 4, sd = 0.3), ncol = 2), 
             matrix(rnorm(100, mean = 6, sd = 0.3), ncol = 2))
colnames(dat) &lt;- c("x","y")
tf1 &lt;- tempfile()
write.table(dat, tf1, sep=",", dec=".")

sig &lt;- data.frame(ID=rep(1:150, each=30), SIGNAL=rep(dnorm(seq(-2,2,length=30)),150))
tf2 &lt;- tempfile()
write.table(sig, tf2, sep=",", dec=".")

x &lt;- importSample(file.features=tf1, file.profiles=tf2)

res &lt;- KmeansQuick(x$features$initial$x, K=3)
new.labels &lt;- formatLabelSample(res$cluster, x)

visualizeSampleClustering(x, label = new.labels, clustering.name="K-means", 
		     profile.mode="whole sample")
 
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
