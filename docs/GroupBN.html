<!DOCTYPE html><html><head><title>Help for package GroupBN</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GroupBN}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cross.en'><p>cross.en</p></a></li>
<li><a href='#discretize.dens'><p>discretize.dens</p></a></li>
<li><a href='#groupbn'><p>groupbn</p></a></li>
<li><a href='#groupbn_refine_manually'><p>groupbn_refine_manually</p></a></li>
<li><a href='#groupbn_refinement'><p>groupbn_refinement</p></a></li>
<li><a href='#groupbn.output.table'><p>groupbn.output.table</p></a></li>
<li><a href='#groupbn.vis.html.plot'><p>groupbn.vis.html.plot</p></a></li>
<li><a href='#is.groupbn'><p>is.groupbn</p></a></li>
<li><a href='#plot.groupbn'><p>plot.groupbn</p></a></li>
<li><a href='#predict.groupbn'><p>predict.groupbn</p></a></li>
<li><a href='#print.groupbn'><p>print.groupbn</p></a></li>
<li><a href='#wine.groupbn.refined'><p>wine.groupbn.refined</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-03-07</td>
</tr>
<tr>
<td>Title:</td>
<td>Inferring Group Bayesian Networks using Hierarchical Feature
Clustering</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ann-Kristin Becker &lt;annkristinbecker@web.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Group Bayesian Networks: This package implements the inference of group Bayesian networks based on hierarchical feature clustering, and the adaptive refinement of the grouping regarding an outcome of interest, as described in Becker et. al (2021) &lt;<a href="https://doi.org/10.1371%2Fjournal.pcbi.1008735">doi:10.1371/journal.pcbi.1008735</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), bnlearn, ClustOfVar, PCAmixdata, arules, zoo</td>
</tr>
<tr>
<td>Imports:</td>
<td>PRROC, MLmetrics, rlist, stats, magrittr, visNetwork, plyr,
stringr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.r-project.org">https://www.r-project.org</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-03-07 11:50:30 UTC; Arbeit</td>
</tr>
<tr>
<td>Author:</td>
<td>Ann-Kristin Becker [aut, cre],
  Lars Kaderali [aut, ths]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-03-07 14:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cross.en'>cross.en
</h2><span id='topic+cross.en'></span>

<h3>Description</h3>

<p>Calculates the weighted cross entropy / log-loss for a vector of observations and predicted probabilities (weighted by class proportions)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross.en(pred, obs, sdpred=NULL, weighted=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross.en_+3A_pred">pred</code></td>
<td>
<p>a numeric vector, the predicted probabilities of the reference class</p>
</td></tr>
<tr><td><code id="cross.en_+3A_obs">obs</code></td>
<td>
<p>the vector of observations, a categorical variable with 2-4 levels</p>
</td></tr>
<tr><td><code id="cross.en_+3A_sdpred">sdpred</code></td>
<td>
<p>either NULL or a vector containing the standard deviations of every estimate</p>
</td></tr>
<tr><td><code id="cross.en_+3A_weighted">weighted</code></td>
<td>
<p>a boolean, if FALSE, the unweighted logloss is calculated. By default, the weighted cross entropy is calculated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if sdpred contains the standard deviations for each estimated probability, then a lower bound of the log loss is returned.
</p>


<h3>Value</h3>

<p>a numeric value: cross entropy / log loss for comparison of classifiers. The smaller, the better.
</p>


<h3>Author(s)</h3>

<p> Ann-Kristin Becker
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#observations
obs&lt;-as.factor(c("A","A","B"))
#correct prediction
pred1&lt;-c(1,1,0)
#wrong prediction
pred2&lt;-c(0,0,1)

cross.en(pred=pred1, obs=obs) #small
cross.en(pred=pred2, obs=obs) #large

#prediction of only majority class
pred3&lt;-c(1,1,1)
#prediction of only minority class
pred4&lt;-c(0,0,0)

cross.en(pred=pred3, obs=obs, weighted=TRUE)
cross.en(pred=pred4, obs=obs, weighted=TRUE)
#both equal (as weighted)

cross.en(pred=pred3, obs=obs, weighted=FALSE)
cross.en(pred=pred4, obs=obs, weighted=FALSE)
#unweighted, majority class is favored
</code></pre>

<hr>
<h2 id='discretize.dens'>discretize.dens
</h2><span id='topic+discretize.dens'></span>

<h3>Description</h3>

<p>density approximative discretization. Significant peaks in the density are determined and used as starting points for k-means based discretization. If only one peak is present, distribution quartiles are used for binning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discretize.dens(data, graph=F, title="Density-approxmative Discretization",
rename.level=F, return.all=T, cluster=F, seed=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discretize.dens_+3A_data">data</code></td>
<td>
<p>a vector containing the data that may be discretized</p>
</td></tr>
<tr><td><code id="discretize.dens_+3A_graph">graph</code></td>
<td>
<p>a boolean value, if TRUE, the density and the determined binning are plotted</p>
</td></tr>
<tr><td><code id="discretize.dens_+3A_title">title</code></td>
<td>
<p>a title for the plot</p>
</td></tr>
<tr><td><code id="discretize.dens_+3A_rename.level">rename.level</code></td>
<td>
<p>a boolean value, if TRUE, factor levels are replaced by integers 1:n</p>
</td></tr>
<tr><td><code id="discretize.dens_+3A_return.all">return.all</code></td>
<td>
<p>a boolean value, if FALSE, only the discretized data are returned.</p>
</td></tr>
<tr><td><code id="discretize.dens_+3A_cluster">cluster</code></td>
<td>
<p>a boolean value, if data is a cluster variable and may already be discrete or not</p>
</td></tr>
<tr><td><code id="discretize.dens_+3A_seed">seed</code></td>
<td>
<p>a random seed number</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>discretized</code></td>
<td>
<p>the discretized data</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p>the factor levels</p>
</td></tr>
<tr><td><code>optima</code></td>
<td>
<p>the x and y coordinates of the determined peaks</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ann-Kristin Becker
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testdata = c(rnorm(100,-3,1), rnorm(100,3,1))
d&lt;-discretize.dens(testdata, graph=TRUE)
summary(d$discretized)
</code></pre>

<hr>
<h2 id='groupbn'>groupbn
</h2><span id='topic+groupbn'></span>

<h3>Description</h3>

<p>creates groupbn object
(determines an initial clustering based on a hierarchy with target variable and 'separated' variables separated, learns a Bayesian network from grouped data and saves discretization and pca parameters)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groupbn(hierarchy, k, target, separate=NULL, separate.as.roots=FALSE,
X.quanti=NULL, X.quali=NULL, struct.alg="hc", boot=TRUE,
discretize=TRUE, arc.thresh=NULL,
debug=FALSE, R=100, seed=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="groupbn_+3A_hierarchy">hierarchy</code></td>
<td>
<p>a cluster object from ClustOfVar.</p>
</td></tr>
<tr><td><code id="groupbn_+3A_k">k</code></td>
<td>
<p>a positive integer number, the number of initial clusters.</p>
</td></tr>
<tr><td><code id="groupbn_+3A_target">target</code></td>
<td>
<p>a string, the name of the target variable.</p>
</td></tr>
<tr><td><code id="groupbn_+3A_separate">separate</code></td>
<td>
<p>a vector of strings, names of variables that should be separated from the groups, such as age, sex,...</p>
</td></tr>
<tr><td><code id="groupbn_+3A_separate.as.roots">separate.as.roots</code></td>
<td>
<p>a boolean; if TRUE separated variables are used as roots in the network. Can be ignored if separate is empty.</p>
</td></tr>
<tr><td><code id="groupbn_+3A_x.quanti">X.quanti</code></td>
<td>
<p>a numeric matrix of data,
or an object that can be coerced to such a matrix
(such as a numeric vector or a data frame with all numeric columns).</p>
</td></tr>
<tr><td><code id="groupbn_+3A_x.quali">X.quali</code></td>
<td>
<p>a categorical matrix of data,
or an object that can be coerced to such a matrix
(such as a character vector, a factor or a data frame with all factor columns).</p>
</td></tr>
<tr><td><code id="groupbn_+3A_struct.alg">struct.alg</code></td>
<td>
<p>structure learning algorithm according to bnlearn</p>
</td></tr>
<tr><td><code id="groupbn_+3A_arc.thresh">arc.thresh</code></td>
<td>
<p>threshold for bootstrap arcs</p>
</td></tr>
<tr><td><code id="groupbn_+3A_discretize">discretize</code></td>
<td>
<p>a boolean, if a network variables should be discretized before network learning</p>
</td></tr>
<tr><td><code id="groupbn_+3A_boot">boot</code></td>
<td>
<p>boolean, if TRUE, a bootstrap based network averaging approach is used</p>
</td></tr>
<tr><td><code id="groupbn_+3A_debug">debug</code></td>
<td>
<p>a boolean,
if TRUE, debugging messages are printed</p>
</td></tr>
<tr><td><code id="groupbn_+3A_r">R</code></td>
<td>
<p>number of bootstrap replicates for model averaging, default is 100</p>
</td></tr>
<tr><td><code id="groupbn_+3A_seed">seed</code></td>
<td>
<p>a random seed number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class groupbn
</p>
<table>
<tr><td><code>bn</code></td>
<td>
<p>a Bayesian Network structure of bn class from bnlearn.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>a Bayesian Network with fitted parameters of bn.fit class from bnlearn.</p>
</td></tr>
<tr><td><code>X.quanti</code></td>
<td>
<p>a data.frame containing only the quantitative variables.</p>
</td></tr>
<tr><td><code>X.quali</code></td>
<td>
<p>a data.frame containing only the qualitative variables.</p>
</td></tr>
<tr><td><code>grouping</code></td>
<td>
<p>a vector of positive integers, giving the cluster assignment.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>the number of clusters.</p>
</td></tr>
<tr><td><code>group.data</code></td>
<td>
<p>a data.frame containing the cluster representants.</p>
</td></tr>
<tr><td><code>target</code></td>
<td>
<p>a string, the name of the target variable.</p>
</td></tr>
<tr><td><code>separate</code></td>
<td>
<p>a vector of strings, names of variables that should be separated from the groups.</p>
</td></tr>
<tr><td><code>pca.param</code></td>
<td>
<p>the PCAmix used to determine the cluster representants.</p>
</td></tr>
<tr><td><code>disc.param</code></td>
<td>
<p>the cutpoints used to discretize the cluster representants.</p>
</td></tr>
<tr><td><code>score</code></td>
<td>
<p>Different prediction scores for the target variable using the fitted network.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ann-Kristin Becker
</p>


<h3>References</h3>

<p>Becker A-K, Dörr M, Felix SB, Frost F, Grabe HJ, Lerch MM, et al. (2021) From heterogeneous healthcare data to disease-specific biomarker networks: A hierarchical Bayesian network approach. PLoS Comput Biol 17(2): e1008735. https://doi.org/10.1371/journal.pcbi.1008735</p>


<h3>See Also</h3>

<p><code><a href="#topic+groupbn_refinement">groupbn_refinement</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load example data
data(wine)
wine.test&lt;-wine[wine$Soil%in%c("Reference", "Env1"),1:29]
wine.test$Soil&lt;-factor(wine.test$Soil)
levels(wine.test$Soil)&lt;-c("0", "1")

#cluster data
hierarchy&lt;-hclustvar(X.quanti=wine.test[,3:29], X.quali=wine.test[,1:2])

#Learn group network among 5 clusters with "Soil" as target variable
wine.groupbn&lt;-groupbn(hierarchy, k=5, target="Soil", separate=NULL,
X.quanti=wine.test[,3:29], X.quali=wine.test[,1:2], seed=321)

#Plot network
plot(wine.groupbn)
</code></pre>

<hr>
<h2 id='groupbn_refine_manually'>groupbn_refine_manually
</h2><span id='topic+groupbn_refine_manually'></span>

<h3>Description</h3>

<p>Based on a GroupBN, a cluster can be selected manually, that is split and the refined model is learned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groupbn_refine_manually(res, hierarchy, refine, arc.thresh=NULL,
R=100, debug=FALSE, seed=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="groupbn_refine_manually_+3A_res">res</code></td>
<td>
<p>an object of class groupbn</p>
</td></tr>
<tr><td><code id="groupbn_refine_manually_+3A_hierarchy">hierarchy</code></td>
<td>
<p>a cluster object from ClustOfVar</p>
</td></tr>
<tr><td><code id="groupbn_refine_manually_+3A_refine">refine</code></td>
<td>
<p>name of group to be refined</p>
</td></tr>
<tr><td><code id="groupbn_refine_manually_+3A_arc.thresh">arc.thresh</code></td>
<td>
<p>threshold for bootstrap arcs</p>
</td></tr>
<tr><td><code id="groupbn_refine_manually_+3A_r">R</code></td>
<td>
<p>number of bootstrap replicates for model averaging, default is 100</p>
</td></tr>
<tr><td><code id="groupbn_refine_manually_+3A_debug">debug</code></td>
<td>
<p>a boolean,
if TRUE, debugging messages are printed</p>
</td></tr>
<tr><td><code id="groupbn_refine_manually_+3A_seed">seed</code></td>
<td>
<p>a random seed number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns an object of class groupbn
</p>


<h3>Author(s)</h3>

<p>Ann-Kristin Becker
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load example data
data(wine)
wine.test&lt;-wine[wine$Soil%in%c("Reference", "Env1"),1:29]
wine.test$Soil&lt;-factor(wine.test$Soil)
levels(wine.test$Soil)&lt;-c("0", "1")

#cluster data
hierarchy&lt;-hclustvar(X.quanti=wine.test[,3:29], X.quali=wine.test[,1:2])

#Learn group network among 5 clusters with "Soil" as target variable
wine.groupbn&lt;-groupbn(hierarchy, k=5, target="Soil", separate=NULL,
X.quanti=wine.test[,3:29], X.quali=wine.test[,1:2], seed=321)

#Refine cluster 2
wine.groupbn.refined&lt;-groupbn_refine_manually(wine.groupbn, hierarchy,
refine = "cl2", seed=321)

#Plot refined network
plot(wine.groupbn.refined)
</code></pre>

<hr>
<h2 id='groupbn_refinement'>groupbn_refinement
</h2><span id='topic+groupbn_refinement'></span>

<h3>Description</h3>

<p>Adaptive Refinement of a group Bayesian Network
using hierarchical Clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groupbn_refinement(res, hierarchy, refinement.part="mb", restart=0, perturb=1,
max.step=10, max.min=Inf, R=100,
return.all=FALSE, arc.thresh=NULL, debug=FALSE, seed=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="groupbn_refinement_+3A_res">res</code></td>
<td>
<p>an object of class groupbn</p>
</td></tr>
<tr><td><code id="groupbn_refinement_+3A_hierarchy">hierarchy</code></td>
<td>
<p>a cluster object from ClustOfVar</p>
</td></tr>
<tr><td><code id="groupbn_refinement_+3A_refinement.part">refinement.part</code></td>
<td>
<p>&quot;mb&quot;, &quot;mb2&quot;, &quot;arc.confid&quot; or &quot;all&quot;, selects if the refinement steps should be done only within the markov blanket of the target variable (mb), within the second-order markov blanket (mb2), in all clusters with an arcconfidence to target &gt;0 (arc.confid) or within all clusters (all). Default: &quot;mb&quot;</p>
</td></tr>
<tr><td><code id="groupbn_refinement_+3A_restart">restart</code></td>
<td>
<p>a positive integer number, the number of restarts</p>
</td></tr>
<tr><td><code id="groupbn_refinement_+3A_perturb">perturb</code></td>
<td>
<p>a positive integer number, the number of perturbations (splits) in each restart</p>
</td></tr>
<tr><td><code id="groupbn_refinement_+3A_max.step">max.step</code></td>
<td>
<p>a positive integer number, the maximal number of refinement steps, default is 10</p>
</td></tr>
<tr><td><code id="groupbn_refinement_+3A_max.min">max.min</code></td>
<td>
<p>a positive integer number, the maximal run time in minutes, default is unlimited</p>
</td></tr>
<tr><td><code id="groupbn_refinement_+3A_r">R</code></td>
<td>
<p>number of bootstrap replicates for model averaging, default is 100</p>
</td></tr>
<tr><td><code id="groupbn_refinement_+3A_return.all">return.all</code></td>
<td>
<p>a boolean, if TRUE, the output is a whole list of group models, if FALSE, the output is only the best-scoring model.</p>
</td></tr>
<tr><td><code id="groupbn_refinement_+3A_arc.thresh">arc.thresh</code></td>
<td>
<p>threshold for bootstrap arcs</p>
</td></tr>
<tr><td><code id="groupbn_refinement_+3A_debug">debug</code></td>
<td>
<p>a boolean,
if TRUE, debugging messages are printed</p>
</td></tr>
<tr><td><code id="groupbn_refinement_+3A_seed">seed</code></td>
<td>
<p>a random seed number</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on a variable grouping, data are aggregated and a Bayesian network is learned. The target variable is kept separated during this procedure, so that the resulting network model can be used for risk prediction and classification. Starting from a coarse group network, groups are iteratively refined to smaller groups. The heuristic refinement happens downwards along the dendrogram, and stops, if it no longer improves the predictive performance of the model. The refinement part is implemented using a hill-climbing procedure.
</p>


<h3>Value</h3>

<p>returns an object of class groupbn
</p>


<h3>Author(s)</h3>

<p>Ann-Kristin Becker
</p>


<h3>References</h3>

<p>Becker A-K, Dörr M, Felix SB, Frost F, Grabe HJ, Lerch MM, et al. (2021) From heterogeneous healthcare data to disease-specific biomarker networks: A hierarchical Bayesian network approach. PLoS Comput Biol 17(2): e1008735. https://doi.org/10.1371/journal.pcbi.1008735</p>


<h3>See Also</h3>

<p><code><a href="#topic+groupbn">groupbn</a></code>
<code><a href="#topic+groupbn.output.table">groupbn.output.table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load example data
data(wine)
wine.test&lt;-wine[wine$Soil%in%c("Reference", "Env1"),1:29]
wine.test$Soil&lt;-factor(wine.test$Soil)
levels(wine.test$Soil)&lt;-c("0", "1")

#cluster data
hierarchy&lt;-hclustvar(X.quanti=wine.test[,3:29], X.quali=wine.test[,1:2])

#Learn group network among 5 clusters with "Soil" as target variable
wine.groupbn&lt;-groupbn(hierarchy, k=5, target="Soil", separate=NULL,
X.quanti=wine.test[,3:29], X.quali=wine.test[,1:2], seed=321)

#Do one refinement step
#Set max.step higher to optimize completely
wine.groupbn.refined&lt;-groupbn_refinement(wine.groupbn, hierarchy,
refinement.part="mb", max.step = 1, seed=321)

#Plot refined network
plot(wine.groupbn.refined)
</code></pre>

<hr>
<h2 id='groupbn.output.table'>groupbn.output.table
</h2><span id='topic+groupbn.output.table'></span>

<h3>Description</h3>

<p>Create an output table with clusters and included variables with similarity scores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groupbn.output.table(res, with.scores=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="groupbn.output.table_+3A_res">res</code></td>
<td>
<p>gn object</p>
</td></tr>
<tr><td><code id="groupbn.output.table_+3A_with.scores">with.scores</code></td>
<td>
<p>if TRUE, similarity scores of every cluster member to the cluster center are added to the table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a table with one column per group,
similarity scores to cluster centers are calculated for each variable
</p>


<h3>Author(s)</h3>

<p>Ann-Kristin Becker
</p>


<h3>See Also</h3>

<p><code><a href="#topic+groupbn">groupbn</a></code>
<code><a href="#topic+groupbn_refinement">groupbn_refinement</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("wine.groupbn.refined")
df&lt;-groupbn.output.table(wine.groupbn.refined)
</code></pre>

<hr>
<h2 id='groupbn.vis.html.plot'>groupbn.vis.html.plot
</h2><span id='topic+groupbn.vis.html.plot'></span>

<h3>Description</h3>

<p>Create an interactive html network object with visNet (displaying similarity scores and number of variables in a score)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groupbn.vis.html.plot(res, df=NULL, save.file=TRUE, save.name=NULL,
hierarchical=FALSE, nodecolor.all="#E0F3F8",
nodecolor.special="cornflowerblue", main=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="groupbn.vis.html.plot_+3A_res">res</code></td>
<td>
<p>a groupbn object</p>
</td></tr>
<tr><td><code id="groupbn.vis.html.plot_+3A_df">df</code></td>
<td>
<p>output from output.table if already calculated, otherwise the same table is calculated internally</p>
</td></tr>
<tr><td><code id="groupbn.vis.html.plot_+3A_save.file">save.file</code></td>
<td>
<p>boolean; if TRUE a html file is produced</p>
</td></tr>
<tr><td><code id="groupbn.vis.html.plot_+3A_save.name">save.name</code></td>
<td>
<p>name for saving html object, date is additionally used</p>
</td></tr>
<tr><td><code id="groupbn.vis.html.plot_+3A_hierarchical">hierarchical</code></td>
<td>
<p>boolean; if TRUE the network is plotted with a hierarchical layout</p>
</td></tr>
<tr><td><code id="groupbn.vis.html.plot_+3A_nodecolor.all">nodecolor.all</code></td>
<td>
<p>a color for &quot;normal&quot; nodes</p>
</td></tr>
<tr><td><code id="groupbn.vis.html.plot_+3A_nodecolor.special">nodecolor.special</code></td>
<td>
<p>a color for the target variable and all separated nodes, if any.</p>
</td></tr>
<tr><td><code id="groupbn.vis.html.plot_+3A_main">main</code></td>
<td>
<p>optionally a title for the plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots an interactive network plot using visNetwork package
</p>


<h3>Value</h3>

<p>an html widget of class visNetwork
</p>


<h3>Author(s)</h3>

<p>Ann-Kristin Becker
</p>


<h3>See Also</h3>

<p><code><a href="#topic+groupbn">groupbn</a></code>
<code><a href="#topic+groupbn_refinement">groupbn_refinement</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("wine.groupbn.refined")
groupbn.vis.html.plot(wine.groupbn.refined, hierarchical=TRUE, save.file=FALSE)
</code></pre>

<hr>
<h2 id='is.groupbn'>is.groupbn
</h2><span id='topic+is.groupbn'></span>

<h3>Description</h3>

<p>Generic function for groupbn objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.groupbn(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.groupbn_+3A_x">x</code></td>
<td>
<p>an object of class groupbn
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean; TRUE if x is of class groupbn, FALSE otherwise.
</p>


<h3>Author(s)</h3>

<p>Ann-Kristin Becker
</p>


<h3>See Also</h3>

<p><code><a href="#topic+groupbn">groupbn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("wine.groupbn.refined")
is.groupbn(wine.groupbn.refined)
</code></pre>

<hr>
<h2 id='plot.groupbn'>plot.groupbn
</h2><span id='topic+plot.groupbn'></span>

<h3>Description</h3>

<p>generic plot function for class groupbn
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'groupbn'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.groupbn_+3A_x">x</code></td>
<td>
<p>an object of class groupbn</p>
</td></tr>
<tr><td><code id="plot.groupbn_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot the group bayesian network structure
</p>


<h3>Value</h3>

<p>No return value, called for plotting
</p>


<h3>Author(s)</h3>

<p>Ann-Kristin Becker
</p>


<h3>See Also</h3>

<p><code><a href="#topic+groupbn">groupbn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("wine.groupbn.refined")
plot(wine.groupbn.refined)
</code></pre>

<hr>
<h2 id='predict.groupbn'>predict.groupbn
</h2><span id='topic+predict.groupbn'></span>

<h3>Description</h3>

<p>Predict the target variable from a group Bayesian network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'groupbn'
predict(object, X.quanti, X.quali, rename.level=FALSE, return.data=FALSE,
new.fit=FALSE, debug=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.groupbn_+3A_object">object</code></td>
<td>
<p>An object of class groupbn generated by the functions groupbn or groupbn_refinement
</p>
</td></tr>
<tr><td><code id="predict.groupbn_+3A_x.quanti">X.quanti</code></td>
<td>
<p>quantitative variables</p>
</td></tr>
<tr><td><code id="predict.groupbn_+3A_x.quali">X.quali</code></td>
<td>
<p>qualitative variables</p>
</td></tr>
<tr><td><code id="predict.groupbn_+3A_rename.level">rename.level</code></td>
<td>
<p>a boolean; if TRUE, all levels of categorical variables are renamed by integers. Default is FALSE.</p>
</td></tr>
<tr><td><code id="predict.groupbn_+3A_return.data">return.data</code></td>
<td>
<p>a boolean; if TRUE, a list with predictions and group.data is returned instead of only predicitions. Default is FALSE.</p>
</td></tr>
<tr><td><code id="predict.groupbn_+3A_new.fit">new.fit</code></td>
<td>
<p>a boolean; if TRUE, the parameters are newly fit using the test data.</p>
</td></tr>
<tr><td><code id="predict.groupbn_+3A_debug">debug</code></td>
<td>
<p>a boolean,
if TRUE, debugging messages are printed</p>
</td></tr>
<tr><td><code id="predict.groupbn_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe with a column of predictions and a column of the target data. If the target is discrete, class probabilities are returned. Otherwise continuous scores are returned. If return.data is TRUE, additionally the transformed group data are returned.
</p>


<h3>Author(s)</h3>

<p>Ann-Kristin Becker
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load example data
data(wine)
wine.test&lt;-wine[wine$Soil%in%c("Reference", "Env1"),1:29]
wine.test$Soil&lt;-factor(wine.test$Soil)
levels(wine.test$Soil)&lt;-c("0", "1")

data(wine.groupbn.refined)
predict(wine.groupbn.refined, X.quanti=wine.test[,3:29], X.quali=wine.test[,1:2])
</code></pre>

<hr>
<h2 id='print.groupbn'>print.groupbn
</h2><span id='topic+print.groupbn'></span>

<h3>Description</h3>

<p>This is a method for the function print for objects of the class groupbn.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'groupbn'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.groupbn_+3A_x">x</code></td>
<td>
<p>An object of class groupbn generated by the functions groupbn or groupbn_refinement</p>
</td></tr>
<tr><td><code id="print.groupbn_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, prints a description of the object
</p>


<h3>Author(s)</h3>

<p>Ann-Kristin Becker
</p>


<h3>See Also</h3>

<p><code><a href="#topic+groupbn">groupbn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("wine.groupbn.refined")
print(wine.groupbn.refined)
</code></pre>

<hr>
<h2 id='wine.groupbn.refined'>wine.groupbn.refined
</h2><span id='topic+wine.groupbn.refined'></span>

<h3>Description</h3>

<p>A refined group Bayesian network with 8 groups learned from dataset 'wine'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("wine.groupbn.refined")</code></pre>


<h3>Format</h3>

<p>group Bayesian network (class 'groupbn')
</p>
<p>name of target variable: Soil
number of groups:  8
achieved scoring: F1:  0.92 ; Precision:  1 ; Recall:  0.86 ; AUC-PR:  1 ; AUC-ROC:  1 ; cross-entr.:  1.43; BIC (netw.): -77.21
</p>
<p>name          description
&quot;$bn&quot;         &quot;Bayesian network structure&quot;
&quot;$fit&quot;        &quot;fitted Bayesian network (multinomial)&quot;
&quot;$arc.confid&quot; &quot;arc confidence&quot;
&quot;$X.quali&quot;    &quot;qualitative variables in a data.frame&quot;
&quot;$X.quanti&quot;   &quot;quantitative variables in a data.frame&quot;
&quot;$grouping&quot;   &quot;group memberships&quot;
&quot;$k&quot;          &quot;number of groups of initial grouping&quot;
&quot;$group.data&quot; &quot;group representatives used for network inference&quot;
&quot;$target&quot;     &quot;name of target variable&quot;
&quot;$separate&quot;   &quot;name of any other separated variables&quot;
&quot;$pca.param&quot;  &quot;pca parameters of each group&quot;
&quot;$disc.param&quot; &quot;discretization intervals of each group&quot;
&quot;$score&quot;      &quot;cross entropy and additional scoring information&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wine.groupbn.refined)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
