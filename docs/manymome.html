<!DOCTYPE html><html><head><title>Help for package manymome</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {manymome}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#all_indirect_paths'><p>Enumerate All Indirect Effects in a Model</p></a></li>
<li><a href='#check_path'><p>Check a Path Exists in a Model</p></a></li>
<li><a href='#coef.cond_indirect_diff'><p>Print the Output of</p>
'cond_indirect_diff()'</a></li>
<li><a href='#coef.cond_indirect_effects'><p>Estimates of Conditional</p>
Indirect Effects or Conditional
Effects</a></li>
<li><a href='#coef.delta_med'><p>Delta_Med in a</p>
'delta_med'-Class Object</a></li>
<li><a href='#coef.indirect'><p>Extract the Indirect Effect or</p>
Conditional Indirect Effect</a></li>
<li><a href='#coef.indirect_list'><p>Extract the Indirect Effects</p>
from a 'indirect_list' Object</a></li>
<li><a href='#coef.indirect_proportion'><p>Extract the Proportion of</p>
Effect Mediated</a></li>
<li><a href='#coef.lm_from_lavaan'><p>Coefficients of an</p>
'lm_from_lavaan'-Class Object</a></li>
<li><a href='#cond_indirect'><p>Conditional, Indirect, and</p>
Conditional Indirect Effects</a></li>
<li><a href='#cond_indirect_diff'><p>Differences In Conditional</p>
Indirect Effects</a></li>
<li><a href='#confint.cond_indirect_diff'><p>Confidence Interval of the</p>
Output of 'cond_indirect_diff()'</a></li>
<li><a href='#confint.cond_indirect_effects'><p>Confidence Intervals of</p>
Indirect Effects or Conditional
Indirect Effects</a></li>
<li><a href='#confint.delta_med'><p>Confidence Interval for</p>
Delta_Med in a 'delta_med'-Class Object</a></li>
<li><a href='#confint.indirect'><p>Confidence Interval of</p>
Indirect Effect or Conditional
Indirect Effect</a></li>
<li><a href='#confint.indirect_list'><p>Confidence Intervals of</p>
Indirect Effects in an 'indirect_list'
Object</a></li>
<li><a href='#data_med'><p>Sample Dataset: Simple</p>
Mediation</a></li>
<li><a href='#data_med_complicated'><p>Sample Dataset: A Complicated</p>
Mediation Model</a></li>
<li><a href='#data_med_mod_a'><p>Sample Dataset: Simple</p>
Mediation with a-Path Moderated</a></li>
<li><a href='#data_med_mod_ab'><p>Sample Dataset: Simple</p>
Mediation with Both Paths Moderated
(Two Moderators)</a></li>
<li><a href='#data_med_mod_ab1'><p>Sample Dataset: Simple</p>
Mediation with Both Paths Moderated
By a Moderator</a></li>
<li><a href='#data_med_mod_b'><p>Sample Dataset: Simple</p>
Mediation with b-Path Moderated</a></li>
<li><a href='#data_med_mod_b_mod'><p>Sample Dataset: A Simple</p>
Mediation Model with b-Path
Moderated-Moderation</a></li>
<li><a href='#data_med_mod_parallel'><p>Sample Dataset: Parallel</p>
Mediation with Two Moderators</a></li>
<li><a href='#data_med_mod_parallel_cat'><p>Sample Dataset: Parallel</p>
Moderated Mediation with Two
Categorical Moderators</a></li>
<li><a href='#data_med_mod_serial'><p>Sample Dataset: Serial</p>
Mediation with Two Moderators</a></li>
<li><a href='#data_med_mod_serial_cat'><p>Sample Dataset: Serial</p>
Moderated Mediation with Two
Categorical Moderators</a></li>
<li><a href='#data_med_mod_serial_parallel'><p>Sample Dataset:</p>
Serial-Parallel Mediation with Two
Moderators</a></li>
<li><a href='#data_med_mod_serial_parallel_cat'><p>Sample Dataset:</p>
Serial-Parallel Moderated Mediation
with Two Categorical Moderators</a></li>
<li><a href='#data_mod'><p>Sample Dataset: One Moderator</p></a></li>
<li><a href='#data_mod_cat'><p>Sample Dataset: Moderation</p>
with One Categorical Moderator</a></li>
<li><a href='#data_mod2'><p>Sample Dataset: Two Moderators</p></a></li>
<li><a href='#data_mome_demo'><p>Sample Dataset: A Complicated</p>
Moderated-Mediation Model</a></li>
<li><a href='#data_mome_demo_missing'><p>Sample Dataset: A Complicated</p>
Moderated-Mediation Model With
Missing Data</a></li>
<li><a href='#data_parallel'><p>Sample Dataset: Parallel Mediation</p></a></li>
<li><a href='#data_sem'><p>Sample Dataset: A Latent</p>
Variable Mediation Model With 4
Factors</a></li>
<li><a href='#data_serial'><p>Sample Dataset: Serial</p>
Mediation</a></li>
<li><a href='#data_serial_parallel'><p>Sample Dataset:</p>
Serial-Parallel Mediation</a></li>
<li><a href='#data_serial_parallel_latent'><p>Sample Dataset: A</p>
Latent Mediation Model With Three
Mediators</a></li>
<li><a href='#delta_med'><p>Delta_Med by Liu, Yuan, and Li (2023)</p></a></li>
<li><a href='#do_boot'><p>Bootstrap Estimates for</p>
'indirect_effects' and
'cond_indirect_effects'</a></li>
<li><a href='#do_mc'><p>Monte Carlo Estimates for</p>
'indirect_effects' and
'cond_indirect_effects'</a></li>
<li><a href='#factor2var'><p>Create Dummy Variables</p></a></li>
<li><a href='#fit2boot_out'><p>Bootstrap Estimates for a</p>
<code>lavaan</code> Output</a></li>
<li><a href='#fit2mc_out'><p>Monte Carlo Estimates for a</p>
<code>lavaan</code> Output</a></li>
<li><a href='#get_one_cond_indirect_effect'><p>Get The Conditional Indirect</p>
Effect for One Row of
'cond_indirect_effects' Output</a></li>
<li><a href='#get_prod'><p>Product Terms (if Any)</p>
Along a Path</a></li>
<li><a href='#index_of_mome'><p>Index of Moderated Mediation</p>
and Index of Moderated Moderated
Mediation</a></li>
<li><a href='#indirect_effects_from_list'><p>Coefficient Table of an 'indirect_list' Class</p>
Object</a></li>
<li><a href='#indirect_i'><p>Indirect Effect (No</p>
Bootstrapping)</a></li>
<li><a href='#indirect_proportion'><p>Proportion of Effect Mediated</p></a></li>
<li><a href='#lm_from_lavaan_list'><p>'lavaan'-class to</p>
'lm_from_lavaan_list'-Class</a></li>
<li><a href='#lm2boot_out'><p>Bootstrap Estimates for <code>lm</code></p>
Outputs</a></li>
<li><a href='#lm2list'><p>Join 'lm()' Output to Form an</p>
'lm_list'-Class Object</a></li>
<li><a href='#manymome-package'><p>manymome: Mediation, Moderation and Moderated-Mediation After Model Fitting</p></a></li>
<li><a href='#math_indirect'><p>Math Operators for</p>
'indirect'-Class Objects</a></li>
<li><a href='#merge_mod_levels'><p>Merge the Generated Levels of</p>
Moderators</a></li>
<li><a href='#mod_levels'><p>Create Levels of Moderators</p></a></li>
<li><a href='#modmed_x1m3w4y1'><p>Sample Dataset: Moderated</p>
Serial Mediation</a></li>
<li><a href='#plot.cond_indirect_effects'><p>Plot Conditional Effects</p></a></li>
<li><a href='#predict.lm_from_lavaan'><p>Predicted Values of a</p>
'lm_from_lavaan'-Class Object</a></li>
<li><a href='#predict.lm_from_lavaan_list'><p>Predicted Values of an</p>
'lm_from_lavaan_list'-Class Object</a></li>
<li><a href='#predict.lm_list'><p>Predicted Values of an</p>
'lm_list'-Class Object</a></li>
<li><a href='#print.all_paths'><p>Print 'all_paths' Class Object</p></a></li>
<li><a href='#print.boot_out'><p>Print a <code>boot_out</code>-Class</p>
Object</a></li>
<li><a href='#print.cond_indirect_diff'><p>Print the Output of</p>
'cond_indirect_diff'</a></li>
<li><a href='#print.cond_indirect_effects'><p>Print a</p>
'cond_indirect_effects' Class Object</a></li>
<li><a href='#print.delta_med'><p>Print a 'delta_med' Class Object</p></a></li>
<li><a href='#print.indirect'><p>Print an 'indirect' Class</p>
Object</a></li>
<li><a href='#print.indirect_list'><p>Print an 'indirect_list' Class</p>
Object</a></li>
<li><a href='#print.indirect_proportion'><p>Print an 'indirect_proportion'-Class</p>
Object</a></li>
<li><a href='#print.lm_list'><p>Print an <code>lm_list</code>-Class</p>
Object</a></li>
<li><a href='#print.mc_out'><p>Print a <code>mc_out</code>-Class</p>
Object</a></li>
<li><a href='#simple_mediation_latent'><p>Sample Dataset: A Simple</p>
Latent Mediation Model</a></li>
<li><a href='#subsetting_cond_indirect_effects'><p>Extraction Methods for</p>
'cond_indirect_effects' Outputs</a></li>
<li><a href='#subsetting_wlevels'><p>Extraction Methods for a</p>
'wlevels'-class Object</a></li>
<li><a href='#summary.lm_list'><p>Summary of an <code>lm_list</code>-Class</p>
Object</a></li>
<li><a href='#terms.lm_from_lavaan'><p>Model Terms of an</p>
'lm_from_lavaan'-Class Object</a></li>
<li><a href='#total_indirect_effect'><p>Total Indirect Effect Between</p>
Two Variables</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Mediation, Moderation and Moderated-Mediation After Model
Fitting</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.14</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes indirect effects, conditional effects, and conditional
  indirect effects in a structural equation model or path model after model
  fitting, with no need to define any user parameters or label any paths in
  the model syntax, using the approach presented in Cheung and Cheung
  (2023) &lt;<a href="https://doi.org/10.3758%2Fs13428-023-02224-z">doi:10.3758/s13428-023-02224-z</a>&gt;. Can also form bootstrap
  confidence intervals by doing bootstrapping only once and reusing the
  bootstrap estimates in all subsequent computations. Supports bootstrap
  confidence intervals for standardized (partially or completely) indirect
  effects, conditional effects, and conditional indirect effects as described
  in Cheung (2009) &lt;<a href="https://doi.org/10.3758%2FBRM.41.2.425">doi:10.3758/BRM.41.2.425</a>&gt; and Cheung, Cheung, Lau, Hui,
  and Vong (2022) &lt;<a href="https://doi.org/10.1037%2Fhea0001188">doi:10.1037/hea0001188</a>&gt;. Model fitting can be done by
  structural equation modeling using lavaan() or regression using lm().</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://sfcheung.github.io/manymome/">https://sfcheung.github.io/manymome/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/sfcheung/manymome/issues">https://github.com/sfcheung/manymome/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, semPlot, semptools, semTools, Amelia, mice,
testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/start-first:</td>
<td>cond_indirect_*</td>
</tr>
<tr>
<td>Imports:</td>
<td>lavaan, boot, parallel, pbapply, stats, ggplot2, igraph, MASS,
methods</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-16 18:24:30 UTC; sfcheung</td>
</tr>
<tr>
<td>Author:</td>
<td>Shu Fai Cheung <a href="https://orcid.org/0000-0002-9871-9448"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Sing-Hang Cheung <a href="https://orcid.org/0000-0001-5182-0752"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Shu Fai Cheung &lt;shufai.cheung@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-16 19:10:14 UTC</td>
</tr>
</table>
<hr>
<h2 id='all_indirect_paths'>Enumerate All Indirect Effects in a Model</h2><span id='topic+all_indirect_paths'></span><span id='topic+all_paths_to_df'></span>

<h3>Description</h3>

<p>Check all indirect paths in a model and
return them as a list of arguments of <code>x</code>, <code>y</code>,
and <code>m</code>, to be used by <code>indirect_effect()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_indirect_paths(fit = NULL, exclude = NULL, x = NULL, y = NULL)

all_paths_to_df(all_paths)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_indirect_paths_+3A_fit">fit</code></td>
<td>
<p>A fit object. Either the output of
<code><a href="lavaan.html#topic+lavaan">lavaan::lavaan()</a></code> or its wrapper such as <code><a href="lavaan.html#topic+sem">lavaan::sem()</a></code>,
or a list of the output of <code><a href="stats.html#topic+lm">lm()</a></code> or the output of
<code><a href="#topic+lm2list">lm2list()</a></code>.</p>
</td></tr>
<tr><td><code id="all_indirect_paths_+3A_exclude">exclude</code></td>
<td>
<p>A character vector of variables to be excluded
in the search, such as control variables.</p>
</td></tr>
<tr><td><code id="all_indirect_paths_+3A_x">x</code></td>
<td>
<p>A character vector of variables that will be
included as the <code>x</code> variables. If supplied, only
paths that start from these variables will be included
in the search.
If <code>NULL</code>, the default, then all variables that are
one of the predictors in at least one regression
equation will be
included in the search.</p>
</td></tr>
<tr><td><code id="all_indirect_paths_+3A_y">y</code></td>
<td>
<p>A character vector of variables that will be
included as the <code>y</code> variables. If supplied, only
paths that start from these variables will be included
in the search.
If <code>NULL</code>, the default, then all variables that are
the outcome variables in at least one regression
equation will be
included in the search.</p>
</td></tr>
<tr><td><code id="all_indirect_paths_+3A_all_paths">all_paths</code></td>
<td>
<p>An <code>all_paths</code>-class object. For example,
the output of <code><a href="#topic+all_indirect_paths">all_indirect_paths()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It makes use of <code><a href="igraph.html#topic+all_simple_paths">igraph::all_simple_paths()</a></code>
to identify paths in a model.
</p>


<h3>Value</h3>

<p><code><a href="#topic+all_indirect_paths">all_indirect_paths()</a></code> returns
a list of the class <code>all_paths</code>. Each argument is a
list of three character vectors,
<code>x</code>, the name of the predictor that starts a path, <code>y</code>,
the name of the outcome that ends a path, and <code>m</code>, a
character vector of one or more names of the mediators,
from <code>x</code> to <code>y</code>. This class has a print method.
</p>
<p><code><a href="#topic+all_paths_to_df">all_paths_to_df()</a></code> returns a data frame with three
columns, <code>x</code>, <code>y</code>, and <code>m</code>, which can be used by
functions such as <code><a href="#topic+indirect_effect">indirect_effect()</a></code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>all_indirect_paths()</code>: Enumerate all indirect paths.
</p>
</li>
<li> <p><code>all_paths_to_df()</code>: Convert the output of
<code><a href="#topic+all_indirect_paths">all_indirect_paths()</a></code> to a data frame with
three columns: <code>x</code>, <code>y</code>, and <code>m</code>.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Shu Fai Cheung <a href="https://orcid.org/0000-0002-9871-9448">https://orcid.org/0000-0002-9871-9448</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+indirect_effect">indirect_effect()</a></code>, <code><a href="#topic+lm2list">lm2list()</a></code>.
<code><a href="#topic+many_indirect_effects">many_indirect_effects()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
data(data_serial_parallel)
mod &lt;-
"
m11 ~ x + c1 + c2
m12 ~ m11 + x + c1 + c2
m2 ~ x + c1 + c2
y ~ m12 + m2 + m11 + x + c1 + c2
"
fit &lt;- sem(mod, data_serial_parallel,
           fixed.x = FALSE)
# All indirect paths
out1 &lt;- all_indirect_paths(fit)
out1
names(out1)

# Exclude c1 and c2 in the search
out2 &lt;- all_indirect_paths(fit, exclude = c("c1", "c2"))
out2
names(out2)

# Exclude c1 and c2, and only consider paths start
# from x and end at y
out3 &lt;- all_indirect_paths(fit, exclude = c("c1", "c2"),
                           x = "x",
                           y = "y")
out3
names(out3)

</code></pre>

<hr>
<h2 id='check_path'>Check a Path Exists in a Model</h2><span id='topic+check_path'></span>

<h3>Description</h3>

<p>It checks whether a
path, usually an indirect path,
exists in a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_path(x, y, m = NULL, fit = NULL, est = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_path_+3A_x">x</code></td>
<td>
<p>Character. The name of
predictor at the start of the path.</p>
</td></tr>
<tr><td><code id="check_path_+3A_y">y</code></td>
<td>
<p>Character. The name of the
outcome variable at the end of the
path.</p>
</td></tr>
<tr><td><code id="check_path_+3A_m">m</code></td>
<td>
<p>A vector of the variable
names of the mediators. The path goes
from the first mediator successively
to the last mediator. If <code>NULL</code>, the
default, the path goes from <code>x</code> to
<code>y</code>.</p>
</td></tr>
<tr><td><code id="check_path_+3A_fit">fit</code></td>
<td>
<p>The fit object. Currently
only supports a
<a href="lavaan.html#topic+lavaan-class">lavaan::lavaan</a> object or a
list of outputs of <code><a href="stats.html#topic+lm">lm()</a></code>.
It can also be
a <code>lavaan.mi</code> object
returned by
<code><a href="semTools.html#topic+runMI">semTools::runMI()</a></code> or
its wrapper, such as <code><a href="semTools.html#topic+runMI">semTools::sem.mi()</a></code>.</p>
</td></tr>
<tr><td><code id="check_path_+3A_est">est</code></td>
<td>
<p>The output of
<code><a href="lavaan.html#topic+parameterEstimates">lavaan::parameterEstimates()</a></code>. If
<code>NULL</code>, the default, it will be
generated from <code>fit</code>. If supplied,
<code>fit</code> will ge ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It checks whether the path
defined by a predictor (<code>x</code>), an
outcome (<code>y</code>), and optionally a
sequence of mediators (<code>m</code>), exists
in a model. It can check models in a
<a href="lavaan.html#topic+lavaan-class">lavaan::lavaan</a> object or a
list of outputs of <code><a href="stats.html#topic+lm">lm()</a></code>.
It also support
<code>lavaan.mi</code> objects
returned by
<code><a href="semTools.html#topic+runMI">semTools::runMI()</a></code> or
its wrapper, such as <code><a href="semTools.html#topic+runMI">semTools::sem.mi()</a></code>.
</p>
<p>For example, in the ql
in <a href="lavaan.html#topic+lavaan">lavaan</a> syntax
</p>
<div class="sourceCode"><pre>m1 ~ x
m2 ~ m1
m3 ~ x
y ~ m2 + m3
</pre></div>
<p>This path is valid: <code style="white-space: pre;">&#8288;x = "x", y = "y", m = c("m1", "m2")&#8288;</code>
</p>
<p>This path is invalid: <code style="white-space: pre;">&#8288;x = "x", y = "y", m = c("m2")&#8288;</code>
</p>
<p>This path is also invalid: <code style="white-space: pre;">&#8288;x = "x", y = "y", m = c("m1", "m2")&#8288;</code>
</p>


<h3>Value</h3>

<p>A logical vector of length
one. <code>TRUE</code> if the path is valid,
<code>FALSE</code> if the path is invalid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)
data(data_serial_parallel)
dat &lt;- data_serial_parallel
mod &lt;-
"
m11 ~ x + c1 + c2
m12 ~ m11 + x + c1 + c2
m2 ~ x + c1 + c2
y ~ m12 + m2 + m11 + x + c1 + c2
"
fit &lt;- sem(mod, dat,
           meanstructure = TRUE, fixed.x = FALSE)

# The following paths are valid
check_path(x = "x", y = "y", m = c("m11", "m12"), fit = fit)
check_path(x = "x", y = "y", m = "m2", fit = fit)
# The following paths are invalid
check_path(x = "x", y = "y", m = c("m11", "m2"), fit = fit)
check_path(x = "x", y = "y", m = c("m12", "m11"), fit = fit)

</code></pre>

<hr>
<h2 id='coef.cond_indirect_diff'>Print the Output of
'cond_indirect_diff()'</h2><span id='topic+coef.cond_indirect_diff'></span>

<h3>Description</h3>

<p>Extract the change in
conditional indirect effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cond_indirect_diff'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.cond_indirect_diff_+3A_object">object</code></td>
<td>
<p>The output of
<code><a href="#topic+cond_indirect_diff">cond_indirect_diff()</a></code>.</p>
</td></tr>
<tr><td><code id="coef.cond_indirect_diff_+3A_...">...</code></td>
<td>
<p>Optional arguments.
Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>coef</code> method of the
<code>cond_indirect_diff</code>-class object.
</p>


<h3>Value</h3>

<p>Scalar: The change of
conditional indirect effect in
<code>object</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cond_indirect_diff">cond_indirect_diff()</a></code>
</p>

<hr>
<h2 id='coef.cond_indirect_effects'>Estimates of Conditional
Indirect Effects or Conditional
Effects</h2><span id='topic+coef.cond_indirect_effects'></span>

<h3>Description</h3>

<p>Return the estimates of
the conditional indirect effects or
conditional effects for all levels in
the output of
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cond_indirect_effects'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.cond_indirect_effects_+3A_object">object</code></td>
<td>
<p>The output of
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>.</p>
</td></tr>
<tr><td><code id="coef.cond_indirect_effects_+3A_...">...</code></td>
<td>
<p>Optional arguments.
Ignored by the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It extracts and returns the
column <code>ind</code> or <code>std</code> in the output
of <code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>.
</p>


<h3>Value</h3>

<p>A numeric vector: The
estimates of the conditional effects
or conditional indirect effects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)
dat &lt;- modmed_x1m3w4y1
mod &lt;-
"
m1 ~ x  + w1 + x:w1
m2 ~ m1
y  ~ m2 + x + w4 + m2:w4
"
fit &lt;- sem(mod, dat,
           meanstructure = TRUE, fixed.x = FALSE,
           se = "none", baseline = FALSE)
est &lt;- parameterEstimates(fit)

# Conditional effects from x to m1 when w1 is equal to each of the levels
out1 &lt;- cond_indirect_effects(x = "x", y = "m1",
                      wlevels = c("w1"), fit = fit)
out1
coef(out1)

# Conditional indirect effects from x1 through m1 and m2 to y,
out2 &lt;- cond_indirect_effects(x = "x", y = "y", m = c("m1", "m2"),
                      wlevels = c("w1", "w4"), fit = fit)
out2
coef(out2)

# Standardized conditional indirect effects from x1 through m1 and m2 to y,
out2std &lt;- cond_indirect_effects(x = "x", y = "y", m = c("m1", "m2"),
                      wlevels = c("w1", "w4"), fit = fit,
                      standardized_x = TRUE, standardized_y = TRUE)
out2std
coef(out2std)

</code></pre>

<hr>
<h2 id='coef.delta_med'>Delta_Med in a
'delta_med'-Class Object</h2><span id='topic+coef.delta_med'></span>

<h3>Description</h3>

<p>Return the estimate of
Delta_Med in a 'delta_med'-class
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'delta_med'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.delta_med_+3A_object">object</code></td>
<td>
<p>The output of
<code><a href="#topic+delta_med">delta_med()</a></code>.</p>
</td></tr>
<tr><td><code id="coef.delta_med_+3A_...">...</code></td>
<td>
<p>Optional arguments.
Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It just extracts and
returns the element <code>delta_med</code>
in the output of <code>delta_med()</code>,
the estimate of the Delta_Med
proposed by Liu, Yuan, and Li (2023),
an <code class="reqn">R^2</code>-like measure of indirect
effect.
</p>


<h3>Value</h3>

<p>A scalar: The estimate of Delta_Med.
</p>


<h3>Author(s)</h3>

<p>Shu Fai Cheung <a href="https://orcid.org/0000-0002-9871-9448">https://orcid.org/0000-0002-9871-9448</a>
</p>


<h3>References</h3>

<p>Liu, H., Yuan, K.-H., &amp; Li, H. (2023).
A systematic framework for defining
R-squared measures in mediation
analysis. <em>Psychological Methods</em>.
Advance online publication.
https://doi.org/10.1037/met0000571
</p>


<h3>See Also</h3>

<p><code><a href="#topic+delta_med">delta_med()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)
dat &lt;- data_med
mod &lt;-
"
m ~ x
y ~ m + x
"
fit &lt;- sem(mod, dat)
dm &lt;- delta_med(x = "x",
                y = "y",
                m = "m",
                fit = fit)
dm
print(dm, full = TRUE)
coef(dm)

</code></pre>

<hr>
<h2 id='coef.indirect'>Extract the Indirect Effect or
Conditional Indirect Effect</h2><span id='topic+coef.indirect'></span>

<h3>Description</h3>

<p>Return the estimate of
the indirect effect in the output of
<code><a href="#topic+indirect_effect">indirect_effect()</a></code> or or the
conditional indirect in the output of
<code><a href="#topic+cond_indirect">cond_indirect()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'indirect'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.indirect_+3A_object">object</code></td>
<td>
<p>The output of
<code><a href="#topic+indirect_effect">indirect_effect()</a></code> or
<code><a href="#topic+cond_indirect">cond_indirect()</a></code>.</p>
</td></tr>
<tr><td><code id="coef.indirect_+3A_...">...</code></td>
<td>
<p>Optional arguments.
Ignored by the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It extracts and returns the
element <code>indirect</code>. in an object.
</p>
<p>If standardized effect is requested
when calling <code><a href="#topic+indirect_effect">indirect_effect()</a></code> or
<code><a href="#topic+cond_indirect">cond_indirect()</a></code>, the effect
returned is also standardized.
</p>


<h3>Value</h3>

<p>A scalar: The estimate of the
indirect effect or conditional
indirect effect.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+indirect_effect">indirect_effect()</a></code> and
<code><a href="#topic+cond_indirect">cond_indirect()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)
dat &lt;- modmed_x1m3w4y1
mod &lt;-
"
m1 ~ x + w1 + x:w1
m2 ~ x
y  ~ m1 + m2 + x
"
fit &lt;- sem(mod, dat,
           meanstructure = TRUE, fixed.x = FALSE,
           se = "none", baseline = FALSE)
est &lt;- parameterEstimates(fit)

# Examples for indirect_effect():

# Inidrect effect from x through m2 to y
out1 &lt;- indirect_effect(x = "x", y = "y", m = "m2", fit = fit)
out1
coef(out1)

# Conditional Indirect effect from x1 through m1 to y,
# when w1 is 1 SD above mean
hi_w1 &lt;- mean(dat$w1) + sd(dat$w1)
out2 &lt;- cond_indirect(x = "x", y = "y", m = "m1",
                      wvalues = c(w1 = hi_w1), fit = fit)
out2
coef(out2)

</code></pre>

<hr>
<h2 id='coef.indirect_list'>Extract the Indirect Effects
from a 'indirect_list' Object</h2><span id='topic+coef.indirect_list'></span>

<h3>Description</h3>

<p>Return the estimates of
the indirect effects in the output of
<code><a href="#topic+many_indirect_effects">many_indirect_effects()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'indirect_list'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.indirect_list_+3A_object">object</code></td>
<td>
<p>The output of
<code><a href="#topic+many_indirect_effects">many_indirect_effects()</a></code>.</p>
</td></tr>
<tr><td><code id="coef.indirect_list_+3A_...">...</code></td>
<td>
<p>Optional arguments.
Ignored by the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It extracts the estimates
in each 'indirect'-class object
in the list.
</p>
<p>If standardized effect is requested
when calling <code><a href="#topic+many_indirect_effects">many_indirect_effects()</a></code>,
the effects
returned are also standardized.
</p>


<h3>Value</h3>

<p>A numeric vector of the
indirect effects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+many_indirect_effects">many_indirect_effects()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)
data(data_serial_parallel)
mod &lt;-
"
m11 ~ x + c1 + c2
m12 ~ m11 + x + c1 + c2
m2 ~ x + c1 + c2
y ~ m12 + m2 + m11 + x + c1 + c2
"
fit &lt;- sem(mod, data_serial_parallel,
           fixed.x = FALSE)
# All indirect paths from x to y
paths &lt;- all_indirect_paths(fit,
                           x = "x",
                           y = "y")
paths
# Indirect effect estimates
out &lt;- many_indirect_effects(paths,
                             fit = fit)
out
coef(out)


</code></pre>

<hr>
<h2 id='coef.indirect_proportion'>Extract the Proportion of
Effect Mediated</h2><span id='topic+coef.indirect_proportion'></span>

<h3>Description</h3>

<p>Return the proportion
of effect mediated in the output of
<code><a href="#topic+indirect_proportion">indirect_proportion()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'indirect_proportion'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.indirect_proportion_+3A_object">object</code></td>
<td>
<p>The output of
<code><a href="#topic+indirect_proportion">indirect_proportion()</a></code></p>
</td></tr>
<tr><td><code id="coef.indirect_proportion_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It extracts and returns the
element <code>proportion</code> in the input
object.
</p>


<h3>Value</h3>

<p>A scalar: The proportion of effect
mediated.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+indirect_proportion">indirect_proportion()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)
dat &lt;- data_med
head(dat)
mod &lt;-
"
m ~ x + c1 + c2
y ~ m + x + c1 + c2
"
fit &lt;- sem(mod, dat, fixed.x = FALSE)
out &lt;- indirect_proportion(x = "x",
                           y = "y",
                           m = "m",
                           fit = fit)
out
coef(out)

</code></pre>

<hr>
<h2 id='coef.lm_from_lavaan'>Coefficients of an
'lm_from_lavaan'-Class Object</h2><span id='topic+coef.lm_from_lavaan'></span>

<h3>Description</h3>

<p>Returns the path
coefficients of the terms in an
<code>lm_from_lavaan</code>-class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm_from_lavaan'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.lm_from_lavaan_+3A_object">object</code></td>
<td>
<p>A
'lm_from_lavaan'-class object.</p>
</td></tr>
<tr><td><code id="coef.lm_from_lavaan_+3A_...">...</code></td>
<td>
<p>Additional arguments.
Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An <code>lm_from_lavaan</code>-class
object converts a regression model
for a variable in a <code>lavaan</code>-class
object to a <code>formula</code>-class object.
This function simply extracts the
path coefficients estimates.
Intercept is always included, and set
to zero if mean structure is not in
the source <code>lavaan</code>-class object.
</p>
<p>This is an advanced helper used by
<code><a href="#topic+plot.cond_indirect_effects">plot.cond_indirect_effects()</a></code>.
Exported for advanced users and
developers.
</p>


<h3>Value</h3>

<p>A numeric vector of the path
coefficients.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lm_from_lavaan_list">lm_from_lavaan_list()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
data(data_med)
mod &lt;-
"
m ~ a * x + c1 + c2
y ~ b * m + x + c1 + c2
"
fit &lt;- sem(mod, data_med, fixed.x = FALSE)
fit_list &lt;- lm_from_lavaan_list(fit)
coef(fit_list$m)
coef(fit_list$y)

</code></pre>

<hr>
<h2 id='cond_indirect'>Conditional, Indirect, and
Conditional Indirect Effects</h2><span id='topic+cond_indirect'></span><span id='topic+cond_indirect_effects'></span><span id='topic+indirect_effect'></span><span id='topic+many_indirect_effects'></span>

<h3>Description</h3>

<p>Compute the conditional
effects, indirect effects, or
conditional indirect effects in a
structural model fitted by <code><a href="stats.html#topic+lm">lm()</a></code>,
<code><a href="lavaan.html#topic+sem">lavaan::sem()</a></code>, or <code><a href="semTools.html#topic+runMI">semTools::sem.mi()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cond_indirect(
  x,
  y,
  m = NULL,
  fit = NULL,
  est = NULL,
  implied_stats = NULL,
  wvalues = NULL,
  standardized_x = FALSE,
  standardized_y = FALSE,
  boot_ci = FALSE,
  level = 0.95,
  boot_out = NULL,
  R = 100,
  seed = NULL,
  parallel = TRUE,
  ncores = max(parallel::detectCores(logical = FALSE) - 1, 1),
  make_cluster_args = list(),
  progress = TRUE,
  save_boot_full = FALSE,
  prods = NULL,
  get_prods_only = FALSE,
  save_boot_out = TRUE,
  mc_ci = FALSE,
  mc_out = NULL,
  save_mc_full = FALSE,
  save_mc_out = TRUE,
  ci_out = NULL,
  save_ci_full = FALSE,
  save_ci_out = TRUE,
  ci_type = NULL
)

cond_indirect_effects(
  wlevels,
  x,
  y,
  m = NULL,
  fit = NULL,
  w_type = "auto",
  w_method = "sd",
  sd_from_mean = NULL,
  percentiles = NULL,
  est = NULL,
  implied_stats = NULL,
  boot_ci = FALSE,
  R = 100,
  seed = NULL,
  parallel = TRUE,
  ncores = max(parallel::detectCores(logical = FALSE) - 1, 1),
  make_cluster_args = list(),
  progress = TRUE,
  boot_out = NULL,
  output_type = "data.frame",
  mod_levels_list_args = list(),
  mc_ci = FALSE,
  mc_out = NULL,
  ci_out = NULL,
  ci_type = NULL,
  ...
)

indirect_effect(
  x,
  y,
  m = NULL,
  fit = NULL,
  est = NULL,
  implied_stats = NULL,
  standardized_x = FALSE,
  standardized_y = FALSE,
  boot_ci = FALSE,
  level = 0.95,
  boot_out = NULL,
  R = 100,
  seed = NULL,
  parallel = TRUE,
  ncores = max(parallel::detectCores(logical = FALSE) - 1, 1),
  make_cluster_args = list(),
  progress = TRUE,
  save_boot_full = FALSE,
  mc_ci = FALSE,
  mc_out = NULL,
  save_mc_full = FALSE,
  save_mc_out = TRUE,
  ci_out = NULL,
  save_ci_full = FALSE,
  save_ci_out = TRUE,
  ci_type = NULL
)

many_indirect_effects(paths, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cond_indirect_+3A_x">x</code></td>
<td>
<p>Character. The name of the
predictor at the start of the path.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_y">y</code></td>
<td>
<p>Character. The name of the
outcome variable at the end of the
path.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_m">m</code></td>
<td>
<p>A vector of the variable
names of the mediator(s). The path
goes from the first mediator
successively to the last mediator. If
<code>NULL</code>, the default, the path goes
from <code>x</code> to <code>y</code>.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_fit">fit</code></td>
<td>
<p>The fit object. Can be a
<a href="lavaan.html#topic+lavaan-class">lavaan::lavaan</a> object or a
list of <code><a href="stats.html#topic+lm">lm()</a></code> outputs.
It can also be
a <code>lavaan.mi</code> object
returned by
<code><a href="semTools.html#topic+runMI">semTools::runMI()</a></code> or
its wrapper, such as <code><a href="semTools.html#topic+runMI">semTools::sem.mi()</a></code>.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_est">est</code></td>
<td>
<p>The output of
<code><a href="lavaan.html#topic+parameterEstimates">lavaan::parameterEstimates()</a></code>. If
<code>NULL</code>, the default, it will be
generated from <code>fit</code>. If supplied,
<code>fit</code> will be ignored.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_implied_stats">implied_stats</code></td>
<td>
<p>Implied means,
variances, and covariances of
observed variables, of the form of
the output of <code><a href="lavaan.html#topic+lavInspect">lavaan::lavInspect()</a></code>
with <code>what</code> set to <code>"implied"</code>. The
standard deviations are extracted
from this object for standardization.
Default is <code>NULL</code>, and implied
statistics will be computed from
<code>fit</code> if required.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_wvalues">wvalues</code></td>
<td>
<p>A numeric vector of
named elements. The names are the
variable names of the moderators, and
the values are the values to which
the moderators will be set to.
Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_standardized_x">standardized_x</code></td>
<td>
<p>Logical.
Whether <code>x</code> will be standardized.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_standardized_y">standardized_y</code></td>
<td>
<p>Logical.
Whether <code>y</code> will be standardized.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_boot_ci">boot_ci</code></td>
<td>
<p>Logical. Whether
bootstrap confidence interval will be
formed. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_level">level</code></td>
<td>
<p>The level of confidence
for the bootstrap confidence
interval. Default is .95.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_boot_out">boot_out</code></td>
<td>
<p>If <code>boot_ci</code> is
<code>TRUE</code>, users can supply pregenerated
bootstrap estimates. This can be the
output of <code><a href="#topic+do_boot">do_boot()</a></code>. For
<code><a href="#topic+indirect_effect">indirect_effect()</a></code> and
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>, this can
be the output of a previous call to
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>,
<code><a href="#topic+indirect_effect">indirect_effect()</a></code>, or
<code><a href="#topic+cond_indirect">cond_indirect()</a></code> with bootstrap
confidence intervals requested. These
stored estimates will be reused such
that there is no need to do
bootstrapping again. If not supplied,
the function will try to generate
them from <code>fit</code>.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_r">R</code></td>
<td>
<p>Integer. If <code>boot_ci</code> is
<code>TRUE</code>, <code>boot_out</code> is <code>NULL</code>, and
bootstrap standard errors not
requested if <code>fit</code> is a
<a href="lavaan.html#topic+lavaan-class">lavaan</a> object, this function
will do bootstrapping on <code>fit</code>. <code>R</code>
is the number of bootstrap samples.
Default is 100. For Monte Carlo
simulation, this is the number
of replications.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_seed">seed</code></td>
<td>
<p>If bootstrapping
or Monte Carlo simulation is
conducted, this is the seed for the
bootstrapping or simulation.
Default is <code>NULL</code> and
seed is not set.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_parallel">parallel</code></td>
<td>
<p>Logical. If
bootstrapping is conducted, whether
parallel processing will be used.
Default is <code>TRUE</code>. If <code>fit</code> is a list
of <code><a href="stats.html#topic+lm">lm()</a></code> outputs, parallel
processing will not be used.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_ncores">ncores</code></td>
<td>
<p>Integer. The number of
CPU cores to use when <code>parallel</code> is
<code>TRUE</code>. Default is the number of
non-logical cores minus one (one
minimum). Will raise an error if
greater than the number of cores
detected by
<code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>. If
<code>ncores</code> is set, it will override
<code>make_cluster_args</code> in <code><a href="#topic+do_boot">do_boot()</a></code>.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_make_cluster_args">make_cluster_args</code></td>
<td>
<p>A named list
of additional arguments to be passed
to <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>. For
advanced users. See
<code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code> for
details. Default is <code>list()</code>.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_progress">progress</code></td>
<td>
<p>Logical. Display
bootstrapping progress or not.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_save_boot_full">save_boot_full</code></td>
<td>
<p>If <code>TRUE</code>, full
bootstrapping results will be stored.
Default is <code>FALSE.</code></p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_prods">prods</code></td>
<td>
<p>The product terms found. For internal use.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_get_prods_only">get_prods_only</code></td>
<td>
<p>IF <code>TRUE</code>, will
quit early and return the product
terms found. The results can be
passed to the <code>prod</code> argument when
calling this function. Default is
<code>FALSE</code>. This function is for
internal use.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_save_boot_out">save_boot_out</code></td>
<td>
<p>If <code>boot_out</code> is
supplied, whether it will be saved in
the output. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_mc_ci">mc_ci</code></td>
<td>
<p>Logical. Whether
Monte Carlo confidence interval will be
formed. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_mc_out">mc_out</code></td>
<td>
<p>If <code>mc_ci</code> is
<code>TRUE</code>, users can supply pregenerated
Monte Carlo estimates. This can be the
output of <code><a href="#topic+do_mc">do_mc()</a></code>. For
<code><a href="#topic+indirect_effect">indirect_effect()</a></code> and
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>, this can
be the output of a previous call to
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>,
<code><a href="#topic+indirect_effect">indirect_effect()</a></code>, or
<code><a href="#topic+cond_indirect">cond_indirect()</a></code> with Monte Carlo
confidence intervals requested. These
stored estimates will be reused such
that there is no need to do
Monte Carlo simulation again. If not
supplied,
the function will try to generate
them from <code>fit</code>.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_save_mc_full">save_mc_full</code></td>
<td>
<p>If <code>TRUE</code>, full
Monte Carlo results will be stored.
Default is <code>FALSE.</code></p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_save_mc_out">save_mc_out</code></td>
<td>
<p>If <code>mc_out</code> is
supplied, whether it will be saved in
the output. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_ci_out">ci_out</code></td>
<td>
<p>If <code>ci_type</code> is supplied,
this is the corresponding argument.
If <code>ci_type</code> is <code>"boot"</code>, this
argument will be used as <code>boot_out</code>.
If <code>ci_type</code> is <code>"mc"</code>, this
argument will be used as <code>mc_out</code>.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_save_ci_full">save_ci_full</code></td>
<td>
<p>If <code>TRUE</code>, full
bootstrapping or Monte Carlo results
will be stored.
Default is <code>FALSE.</code></p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_save_ci_out">save_ci_out</code></td>
<td>
<p>If either <code>mc_out</code>
or <code>boot_out</code> is
supplied, whether it will be saved in
the output. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_ci_type">ci_type</code></td>
<td>
<p>The type of
confidence intervals to be formed.
Can be either <code>"boot"</code> (bootstrapping)
or <code>"mc"</code> (Monte Carlo). If not
supplied or is <code>NULL</code>, will check
other arguments
(e.g, <code>boot_ci</code> and <code>mc_ci</code>). If
supplied, will override <code>boot_ci</code>
and <code>mc_ci</code>.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_wlevels">wlevels</code></td>
<td>
<p>The output of
<code><a href="#topic+merge_mod_levels">merge_mod_levels()</a></code>, or the
moderator(s) to be passed to
<code><a href="#topic+mod_levels_list">mod_levels_list()</a></code>. If all the
moderators can be represented by one
variable, that is, each moderator is
(a) a numeric variable, (b) a
dichotomous categorical variable, or
(c) a factor or string variable used
in <code><a href="stats.html#topic+lm">lm()</a></code> in <code>fit</code>, then it is a
vector of the names of the moderators
as appeared in the data frame. If at
least one of the moderators is a
categorical variable represented by
more than one variable, such as
user-created dummy variables used in
<code><a href="lavaan.html#topic+sem">lavaan::sem()</a></code>, then it must be a
list of the names of the moderators,
with such moderators represented by a
vector of names. For example:
<code style="white-space: pre;">&#8288;list("w1", c("gpgp2", "gpgp3")&#8288;</code>, the
first moderator <code>w1</code> and the second
moderator a three-categorical
variable represented by <code>gpgp2</code> and
<code>gpgp3</code>.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_w_type">w_type</code></td>
<td>
<p>Character. Whether the
moderator is a <code>"numeric"</code> variable
or a <code>"categorical"</code> variable. If
<code>"auto"</code>, the function will try to
determine the type automatically.
See <code><a href="#topic+mod_levels_list">mod_levels_list()</a></code> for further
information.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_w_method">w_method</code></td>
<td>
<p>Character, either
<code>"sd"</code> or <code>"percentile"</code>. If <code>"sd"</code>,
the levels are defined by the
distance from the mean in terms of
standard deviation. if
<code>"percentile"</code>, the levels are
defined in percentiles.  See
<code><a href="#topic+mod_levels_list">mod_levels_list()</a></code> for further
information.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_sd_from_mean">sd_from_mean</code></td>
<td>
<p>A numeric vector.
Specify the distance in standard
deviation from the mean for each
level. Default is <code>c(-1, 0, 1)</code> when
there is only one moderator, and
<code>c(-1, 1)</code> when there are more than
one moderator. Ignored if <code>w_method</code>
is not equal to <code>"sd"</code>. See
<code><a href="#topic+mod_levels_list">mod_levels_list()</a></code> for further
information.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_percentiles">percentiles</code></td>
<td>
<p>A numeric vector.
Specify the percentile (in
proportion) for each level. Default
is <code>c(.16, .50, .84)</code> if there is one
moderator, and <code>c(.16, .84)</code> when
there are more than one moderator.
Ignored if <code>w_method</code> is not equal to
<code>"percentile"</code>. See
<code><a href="#topic+mod_levels_list">mod_levels_list()</a></code> for further
information.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_output_type">output_type</code></td>
<td>
<p>The type of output
of <code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>. If
<code>"data.frame"</code>, the default, the
output will be converted to a data
frame. If any other values, the
output is a list of the outputs from
<code><a href="#topic+cond_indirect">cond_indirect()</a></code>.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_mod_levels_list_args">mod_levels_list_args</code></td>
<td>
<p>Additional arguments to be passed to
<code><a href="#topic+mod_levels_list">mod_levels_list()</a></code> if it is called
for creating the levels of
moderators. Default is <code>list()</code>.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_...">...</code></td>
<td>
<p>For <code><a href="#topic+many_indirect_effects">many_indirect_effects()</a></code>,
these are arguments to be passed to
<code><a href="#topic+indirect_effect">indirect_effect()</a></code>.</p>
</td></tr>
<tr><td><code id="cond_indirect_+3A_paths">paths</code></td>
<td>
<p>The output of <code><a href="#topic+all_indirect_paths">all_indirect_paths()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a model with a mediation path
moderated by one or more moderators,
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code> can be used
to compute the conditional indirect
effect from one variable to another
variable, at one or more set of
selected value(s) of the
moderator(s).
</p>
<p>If only the effect for one set of
value(s) of the moderator(s) is
needed, <code><a href="#topic+cond_indirect">cond_indirect()</a></code> can be
used.
</p>
<p>If only the mediator(s) is/are
specified (<code>m</code>) and no values of
moderator(s) are specified, then the
indirect effect from one variable
(<code>x</code>) to another variable (<code>y</code>) is
computed. A convenient wrapper
<code><a href="#topic+indirect_effect">indirect_effect()</a></code> can be used to
compute the indirect effect.
</p>
<p>If only the value(s) of moderator(s)
is/are specified (<code>wvalues</code> or
<code>wlevels</code>) and no mediators (<code>m</code>) are
specified when calling
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code> or
<code><a href="#topic+cond_indirect">cond_indirect()</a></code>, then the
conditional direct effects from one
variable to another are computed.
</p>
<p>All three functions support using
nonparametric bootstrapping (for
<code>lavaan</code> or <code>lm</code> outputs) or
Monte Carlo simulation (for
<code>lavaan</code> outputs only) to form
confidence intervals.
Bootstrapping or Monte Carlo
simulation only needs to be done
once. These are the possible ways to
form bootstrapping:
</p>

<ol>
<li><p> Do bootstrapping or Monte Carlo
simulation in the first call
to one of these functions, by setting
<code>boot_ci</code> or <code>mc_ci</code> to <code>TRUE</code> and
<code>R</code> to the
number of bootstrap samples or
replications, <code>level</code>
to the level of confidence (default
.95 or 95%), and <code>seed</code> to reproduce
the results (<code>parallel</code> and <code>ncores</code>
are optional for bootstrapping).
This will take some
time to run for bootstrapping. The
output will have all
bootstrap or Monte Carlo estimates
stored. This
output, whether it is from
<code><a href="#topic+indirect_effect">indirect_effect()</a></code>,
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>, or
<code><a href="#topic+cond_indirect">cond_indirect()</a></code>, can be reused by
any of these three functions by
setting <code>boot_out</code> (for bootstrapping)
or <code>mc_out</code> (for Monte Carlo
simulation) to this output.
They will form the confidence
intervals using the stored bootstrap
or Monte Carlo
estimates.
</p>
</li>
<li><p> Do bootstrapping using
<code><a href="#topic+do_boot">do_boot()</a></code> or Monte Carlo simulation
us8ing <code><a href="#topic+do_mc">do_mc()</a></code>. The output can be used
in the <code>boot_out</code> (for bootstrapping)
or <code>mc_out</code> (for Monte Carlo simulation)
argument of
<code><a href="#topic+indirect_effect">indirect_effect()</a></code>,
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code> and
<code><a href="#topic+cond_indirect">cond_indirect()</a></code>.
</p>
</li>
<li><p> For bootstrapping,
if <code><a href="lavaan.html#topic+sem">lavaan::sem()</a></code> is used to fit
a model and <code>se = "boot"</code> is used,
<code><a href="#topic+do_boot">do_boot()</a></code> can extract them to
generate a <code>boot_out</code>-class object
that again can be used in the
<code>boot_out</code> argument.
</p>
</li></ol>

<p>If <code>boot_out</code> or <code>mc_out</code>
is set, arguments such
as <code>R</code>, <code>seed</code>, and <code>parallel</code> will
be ignored.
</p>


<h3>Value</h3>

<p><code><a href="#topic+indirect_effect">indirect_effect()</a></code> and
<code><a href="#topic+cond_indirect">cond_indirect()</a></code> return an
<code>indirect</code>-class object.
</p>
<p><code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code> returns a
<code>cond_indirect_effects</code>-class object.
</p>
<p>These two classes of objects have
their own print methods for printing
the results (see <code><a href="#topic+print.indirect">print.indirect()</a></code>
and <code><a href="#topic+print.cond_indirect_effects">print.cond_indirect_effects()</a></code>).
They also have a <code>coef</code> method for
extracting the estimates
(<code><a href="#topic+coef.indirect">coef.indirect()</a></code> and
<code><a href="#topic+coef.cond_indirect_effects">coef.cond_indirect_effects()</a></code>) and a
<code>confint</code> method for extracting the
confidence intervals
(<code><a href="#topic+confint.indirect">confint.indirect()</a></code> and
<code><a href="#topic+confint.cond_indirect_effects">confint.cond_indirect_effects()</a></code>).
Addition and subtraction can also be
conducted on <code>indirect</code>-class object
to estimate and test a function of
effects (see <a href="#topic+math_indirect">math_indirect</a>)
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>cond_indirect()</code>: Compute
conditional, indirect, or conditional
indirect effects for one set of
levels.
</p>
</li>
<li> <p><code>cond_indirect_effects()</code>: Compute the
conditional effects or conditional
indirect effects for several sets of
levels of the moderator(s).
</p>
</li>
<li> <p><code>indirect_effect()</code>: Compute the
indirect effect. A wrapper of
<code><a href="#topic+cond_indirect">cond_indirect()</a></code>. Can be used when
there is no moderator.
</p>
</li>
<li> <p><code>many_indirect_effects()</code>: Compute the
indirect effects along more than one paths.
It call <code><a href="#topic+indirect_effect">indirect_effect()</a></code> once for
each of the path.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+mod_levels">mod_levels()</a></code> and
<code><a href="#topic+merge_mod_levels">merge_mod_levels()</a></code> for generating
levels of moderators. <a href="#topic+do_boot">do_boot</a> for
doing bootstrapping before calling
these functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)
dat &lt;- modmed_x1m3w4y1
mod &lt;-
"
m1 ~ a1 * x  + d1 * w1 + e1 * x:w1
m2 ~ a2 * x
y  ~ b1 * m1 + b2 * m2 + cp * x
"
fit &lt;- sem(mod, dat, meanstructure = TRUE, fixed.x = FALSE, se = "none", baseline = FALSE)
est &lt;- parameterEstimates(fit)
hi_w1 &lt;- mean(dat$w1) + sd(dat$w1)

# Examples for cond_indirect():

# Conditional effect from x to m1 when w1 is 1 SD above mean
cond_indirect(x = "x", y = "m1",
              wvalues = c(w1 = hi_w1), fit = fit)

# Indirect effect from x1 through m2 to y
indirect_effect(x = "x", y = "y", fit = fit)

# Conditional Indirect effect from x1 through m1 to y, when w1 is 1 SD above mean
cond_indirect(x = "x", y = "y", m = "m1",
              wvalues = c(w1 = hi_w1), fit = fit)



# Examples for cond_indirect_effects():

# Create levels of w1, the moderators
w1levels &lt;- mod_levels("w1", fit = fit)
w1levels

# Conditional effects from x to m1 when w1 is equal to each of the levels
cond_indirect_effects(x = "x", y = "m1",
                      wlevels = w1levels, fit = fit)

# Conditional Indirect effect from x1 through m1 to y,
# when w1 is equal to each of the levels
cond_indirect_effects(x = "x", y = "y", m = "m1",
                      wlevels = w1levels, fit = fit)


# Examples for many_indirect_effects():

library(lavaan)
data(data_serial_parallel)
mod &lt;-
"
m11 ~ x + c1 + c2
m12 ~ m11 + x + c1 + c2
m2 ~ x + c1 + c2
y ~ m12 + m2 + m11 + x + c1 + c2
"
fit &lt;- sem(mod, data_serial_parallel,
           fixed.x = FALSE)

# All indirect paths from x to y
paths &lt;- all_indirect_paths(fit,
                           x = "x",
                           y = "y")
paths

# Indirect effect estimates
out &lt;- many_indirect_effects(paths,
                             fit = fit)
out


</code></pre>

<hr>
<h2 id='cond_indirect_diff'>Differences In Conditional
Indirect Effects</h2><span id='topic+cond_indirect_diff'></span>

<h3>Description</h3>

<p>Compute the difference
in conditional indirect effects
between two sets of levels of the
moderators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cond_indirect_diff(output, from = NULL, to = NULL, level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cond_indirect_diff_+3A_output">output</code></td>
<td>
<p>A
<code>cond_indirect_effects</code>-class object:
The output of
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>.</p>
</td></tr>
<tr><td><code id="cond_indirect_diff_+3A_from">from</code></td>
<td>
<p>A row number of <code>output</code>.</p>
</td></tr>
<tr><td><code id="cond_indirect_diff_+3A_to">to</code></td>
<td>
<p>A row number of <code>output</code>.
The change in indirect effects is
computed by the change in the
level(s) of the moderator(s) from Row
<code>from</code> to Row <code>to</code>.</p>
</td></tr>
<tr><td><code id="cond_indirect_diff_+3A_level">level</code></td>
<td>
<p>The level of confidence
for the confidence
interval. Default is .95.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Ths function takes the output of
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code> and
computes the difference in
conditional indirect effects between
any two rows, that is, between levels
of the moderator, or two sets of
levels of the moderators when the
path has more than one moderator.
</p>
<p>The difference is meaningful when the
difference between the two levels or
sets of levels are meaningful. For
example, if the two levels are the
mean of the moderator and one
standard deviation above mean of the
moderator, then this difference is
the change in indirect effect when
the moderator increases by one
standard deviation.
</p>
<p>If the two levels are 0 and 1, then
this difference is the index of
moderated mediation as proposed by
Hayes (2015). (This index can also be
computed directly by
<code><a href="#topic+index_of_mome">index_of_mome()</a></code>, designed
specifically for this purpose.)
</p>
<p>The function can also compute the
change in the standardized indirect
effect between two levels of a
moderator or two sets of levels of
the moderators.
</p>
<p>This function is intended to be a
general purpose function that allows
users to compute the difference
between any two levels or sets of
levels that are meaningful in a
context.
</p>
<p>This function itself does not set the
levels of comparison. The levels to
be compared need to be set when
calling <code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>.
This function extracts required
information from the output of
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>.
</p>
<p>If bootstrap or Monte Carlo
estimates are available
in the input or bootstrap
or Monte Carlo confidence
intervals are requested in calling
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>,
<code><a href="#topic+cond_indirect_diff">cond_indirect_diff()</a></code> will also form
the percentile confidence
interval for the difference in
conditional indirect effects
using the stored estimates.
</p>


<h3>Value</h3>

<p>A <code>cond_indirect_diff</code>-class
object. This class has a <code>print</code>
method
(<code><a href="#topic+print.cond_indirect_diff">print.cond_indirect_diff()</a></code>), a
<code>coef</code> method
(<code><a href="#topic+coef.cond_indirect_diff">coef.cond_indirect_diff()</a></code>), and a
<code>confint</code> method
(<code><a href="#topic+confint.cond_indirect_diff">confint.cond_indirect_diff()</a></code>).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>cond_indirect_diff()</code>: Compute the difference in in
conditional indirect effect between
two rows in the output of
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>.
</p>
</li></ul>


<h3>References</h3>

<p>Hayes, A. F. (2015). An index and test of linear moderated mediation.
<em>Multivariate Behavioral Research, 50</em>(1), 1-22.
<a href="https://doi.org/10.1080/00273171.2014.962683">doi:10.1080/00273171.2014.962683</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+index_of_mome">index_of_mome()</a></code> for
computing the index of moderated
mediation, <code><a href="#topic+index_of_momome">index_of_momome()</a></code> for
computing the index of moderated
moderated mediation,
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>,
<code><a href="#topic+mod_levels">mod_levels()</a></code>, and
<code><a href="#topic+merge_mod_levels">merge_mod_levels()</a></code> for preparing
the levels to be compared.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)
dat &lt;- modmed_x1m3w4y1
dat$xw1 &lt;- dat$x * dat$w1
mod &lt;-
"
m1 ~ a * x  + f * w1 + d * xw1
y  ~ b * m1 + cp * x
"
fit &lt;- sem(mod, dat,
           meanstructure = TRUE, fixed.x = FALSE,
           se = "none", baseline = FALSE)
est &lt;- parameterEstimates(fit)

# Create levels of w1, the moderators
w1levels &lt;- mod_levels("w1", fit = fit)
w1levels

# Conditional effects from x to y when w1 is equal to each of the levels
boot_out &lt;- fit2boot_out_do_boot(fit, R = 40, seed = 4314, progress = FALSE)
out &lt;- cond_indirect_effects(x = "x", y = "y", m = "m1",
                             wlevels = w1levels, fit = fit,
                             boot_ci = TRUE, boot_out = boot_out)
out
out_ind &lt;- cond_indirect_diff(out, from = 2, to = 1)
out_ind
coef(out_ind)
confint(out_ind)



</code></pre>

<hr>
<h2 id='confint.cond_indirect_diff'>Confidence Interval of the
Output of 'cond_indirect_diff()'</h2><span id='topic+confint.cond_indirect_diff'></span>

<h3>Description</h3>

<p>Extract the confidence
interval the output of
<code><a href="#topic+cond_indirect_diff">cond_indirect_diff()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cond_indirect_diff'
confint(object, parm, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.cond_indirect_diff_+3A_object">object</code></td>
<td>
<p>The output of
<code><a href="#topic+cond_indirect_diff">cond_indirect_diff()</a></code>.</p>
</td></tr>
<tr><td><code id="confint.cond_indirect_diff_+3A_parm">parm</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="confint.cond_indirect_diff_+3A_level">level</code></td>
<td>
<p>The level of confidence
for the confidence
interval. Default is .95. Must match
the level of the stored confidence
interval.</p>
</td></tr>
<tr><td><code id="confint.cond_indirect_diff_+3A_...">...</code></td>
<td>
<p>Optional arguments.
Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>confint</code> method of the
<code>cond_indirect_diff</code>-class object.
</p>
<p>The type of confidence intervals
depends on the call used to
create the object. This function
merely extracts the stored
confidence intervals.
</p>


<h3>Value</h3>

<p>A one-row-two-column data
frame of the confidence limits. If
confidence interval is not available,
the limits are <code>NA</code>s.
</p>

<hr>
<h2 id='confint.cond_indirect_effects'>Confidence Intervals of
Indirect Effects or Conditional
Indirect Effects</h2><span id='topic+confint.cond_indirect_effects'></span>

<h3>Description</h3>

<p>Return the confidence
intervals of the conditional indirect
effects or conditional effects in the
output of <code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cond_indirect_effects'
confint(object, parm, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.cond_indirect_effects_+3A_object">object</code></td>
<td>
<p>The output of
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>.</p>
</td></tr>
<tr><td><code id="confint.cond_indirect_effects_+3A_parm">parm</code></td>
<td>
<p>Ignored. Always returns
the confidence intervals of
the effects for all levels stored.</p>
</td></tr>
<tr><td><code id="confint.cond_indirect_effects_+3A_level">level</code></td>
<td>
<p>The level of confidence,
default is .95, returning the 95%
confidence interval. Ignored for now
and will use the level of the stored
intervals.</p>
</td></tr>
<tr><td><code id="confint.cond_indirect_effects_+3A_...">...</code></td>
<td>
<p>Additional arguments.
Ignored by the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It extracts and returns the
columns for confidence intervals, if
available.
</p>
<p>The type of confidence intervals
depends on the call used to
compute the effects. This function
merely retrieves the confidence
intervals stored, if any,
which could be formed by
nonparametric bootstrapping,
Monte Carlo simulation, or other
methods to be supported in the
future.
</p>


<h3>Value</h3>

<p>A data frame with two
columns, one for each confidence
limit of the confidence intervals.
The number of rows is equal to the
number of rows of <code>object</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)
dat &lt;- modmed_x1m3w4y1
mod &lt;-
"
m1 ~ x  + w1 + x:w1
m2 ~ m1
y  ~ m2 + x + w4 + m2:w4
"
fit &lt;- sem(mod, dat, meanstructure = TRUE, fixed.x = FALSE, se = "none", baseline = FALSE)
est &lt;- parameterEstimates(fit)

# Examples for cond_indirect():

# Create levels of w1 and w4
w1levels &lt;- mod_levels("w1", fit = fit)
w1levels
w4levels &lt;- mod_levels("w4", fit = fit)
w4levels
w1w4levels &lt;- merge_mod_levels(w1levels, w4levels)

# Conditional effects from x to m1 when w1 is equal to each of the levels
# R should be at least 2000 or 5000 in real research.
out1 &lt;- suppressWarnings(cond_indirect_effects(x = "x", y = "m1",
                      wlevels = w1levels, fit = fit,
                      boot_ci = TRUE, R = 20, seed = 54151,
                      parallel = FALSE,
                      progress = FALSE))
confint(out1)


</code></pre>

<hr>
<h2 id='confint.delta_med'>Confidence Interval for
Delta_Med in a 'delta_med'-Class Object</h2><span id='topic+confint.delta_med'></span>

<h3>Description</h3>

<p>Return the confidence
interval of the Delta_Med in the
output of <code><a href="#topic+delta_med">delta_med()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'delta_med'
confint(object, parm, level = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.delta_med_+3A_object">object</code></td>
<td>
<p>The output of
<code><a href="#topic+delta_med">delta_med()</a></code>.</p>
</td></tr>
<tr><td><code id="confint.delta_med_+3A_parm">parm</code></td>
<td>
<p>Not used because only
one parameter, the Delta_Med, is
allowed.</p>
</td></tr>
<tr><td><code id="confint.delta_med_+3A_level">level</code></td>
<td>
<p>The level of confidence,
default is <code>NULL</code> and the level used
when the object was created will be
used.</p>
</td></tr>
<tr><td><code id="confint.delta_med_+3A_...">...</code></td>
<td>
<p>Optional arguments.
Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It returns the nonparametric
bootstrap
percentile confidence interval of
Delta_Med, proposed byLiu, Yuan, and
Li (2023). The object must be the
output of <code><a href="#topic+delta_med">delta_med()</a></code>, with
bootstrap confidence interval
requested when calling <code><a href="#topic+delta_med">delta_med()</a></code>.
However, the level of confidence
can be different from that used when
call <code><a href="#topic+delta_med">delta_med()</a></code>.
</p>


<h3>Value</h3>

<p>A one-row matrix of the confidence
interval. All values are <code>NA</code> if
bootstrap confidence interval was
not requested when calling
<code><a href="#topic+delta_med">delta_med()</a></code>.
</p>


<h3>Author(s)</h3>

<p>Shu Fai Cheung <a href="https://orcid.org/0000-0002-9871-9448">https://orcid.org/0000-0002-9871-9448</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+delta_med">delta_med()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)
dat &lt;- data_med
mod &lt;-
"
m ~ x
y ~ m + x
"
fit &lt;- sem(mod, dat)

# Call do_boot() to generate
# bootstrap estimates
# Use 2000 or even 5000 for R in real studies
# Set parallel to TRUE in real studies for faster bootstrapping
boot_out &lt;- do_boot(fit,
                    R = 45,
                    seed = 879,
                    parallel = FALSE,
                    progress = FALSE)
# Remove 'progress = FALSE' in practice
dm_boot &lt;- delta_med(x = "x",
                     y = "y",
                     m = "m",
                     fit = fit,
                     boot_out = boot_out,
                     progress = FALSE)
dm_boot
confint(dm_boot)

</code></pre>

<hr>
<h2 id='confint.indirect'>Confidence Interval of
Indirect Effect or Conditional
Indirect Effect</h2><span id='topic+confint.indirect'></span>

<h3>Description</h3>

<p>Return the
confidence interval of the indirect
effect or conditional indirect effect
stored in the output of
<code><a href="#topic+indirect_effect">indirect_effect()</a></code> or
<code><a href="#topic+cond_indirect">cond_indirect()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'indirect'
confint(object, parm, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.indirect_+3A_object">object</code></td>
<td>
<p>The output of
<code><a href="#topic+indirect_effect">indirect_effect()</a></code> or
<code><a href="#topic+cond_indirect">cond_indirect()</a></code>.</p>
</td></tr>
<tr><td><code id="confint.indirect_+3A_parm">parm</code></td>
<td>
<p>Ignored because the
stored object always has only one
parameter.</p>
</td></tr>
<tr><td><code id="confint.indirect_+3A_level">level</code></td>
<td>
<p>The level of confidence,
default is .95, returning the 95%
confidence interval.</p>
</td></tr>
<tr><td><code id="confint.indirect_+3A_...">...</code></td>
<td>
<p>Additional arguments.
Ignored by the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It extracts and returns the
stored confidence interval
if available.
</p>
<p>The type of confidence interval
depends on the call used to
compute the effect. This function
merely retrieves the stored estimates,
which could be generated by
nonparametric bootstrapping,
Monte Carlo simulation, or other
methods to be supported in
the future, and uses them to form the
percentile confidence interval.
</p>


<h3>Value</h3>

<p>A numeric vector of
two elements, the limits of
the confidence interval.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+indirect_effect">indirect_effect()</a></code> and
<code><a href="#topic+cond_indirect">cond_indirect()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- modmed_x1m3w4y1

# Indirect Effect

library(lavaan)
mod1 &lt;-
"
m1 ~ x
m2 ~ m1
y  ~ m2 + x
"
fit &lt;- sem(mod1, dat,
           meanstructure = TRUE, fixed.x = FALSE,
           se = "none", baseline = FALSE)
# R should be at least 2000 or 5000 in real research.
out1 &lt;- indirect_effect(x = "x", y = "y",
                        m = c("m1", "m2"),
                        fit = fit,
                        boot_ci = TRUE, R = 45, seed = 54151,
                        parallel = FALSE,
                        progress = FALSE)
out1
confint(out1)


</code></pre>

<hr>
<h2 id='confint.indirect_list'>Confidence Intervals of
Indirect Effects in an 'indirect_list'
Object</h2><span id='topic+confint.indirect_list'></span>

<h3>Description</h3>

<p>Return the
confidence intervals of the indirect
effects
stored in the output of
<code><a href="#topic+many_indirect_effects">many_indirect_effects()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'indirect_list'
confint(object, parm = NULL, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.indirect_list_+3A_object">object</code></td>
<td>
<p>The output of
<code><a href="#topic+many_indirect_effects">many_indirect_effects()</a></code>.</p>
</td></tr>
<tr><td><code id="confint.indirect_list_+3A_parm">parm</code></td>
<td>
<p>Ignored for now.</p>
</td></tr>
<tr><td><code id="confint.indirect_list_+3A_level">level</code></td>
<td>
<p>The level of confidence,
default is .95, returning the 95%
confidence interval.</p>
</td></tr>
<tr><td><code id="confint.indirect_list_+3A_...">...</code></td>
<td>
<p>Additional arguments.
Ignored by the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It extracts and returns the
stored confidence interval
if available.
</p>
<p>The type of confidence intervals
depends on the call used to
compute the effects. This function
merely retrieves the stored estimates,
which could be generated by
nonparametric bootstrapping,
Monte Carlo simulation, or other
methods to be supported in
the future, and uses them to form the
percentile confidence interval.
</p>


<h3>Value</h3>

<p>A two-column data frame.
The columns are the limits of
the confidence intervals.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+many_indirect_effects">many_indirect_effects()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)
data(data_serial_parallel)
mod &lt;-
"
m11 ~ x + c1 + c2
m12 ~ m11 + x + c1 + c2
m2 ~ x + c1 + c2
y ~ m12 + m2 + m11 + x + c1 + c2
"
fit &lt;- sem(mod, data_serial_parallel,
           fixed.x = FALSE)
# All indirect paths from x to y
paths &lt;- all_indirect_paths(fit,
                           x = "x",
                           y = "y")
paths
# Indirect effect estimates
# R should be 2000 or even 5000 in real research
# parallel should be used in real research.
fit_boot &lt;- do_boot(fit, R = 45, seed = 8974,
                    parallel = FALSE,
                    progress = FALSE)
out &lt;- many_indirect_effects(paths,
                             fit = fit,
                             boot_ci = TRUE,
                             boot_out = fit_boot)
out
confint(out)



</code></pre>

<hr>
<h2 id='data_med'>Sample Dataset: Simple
Mediation</h2><span id='topic+data_med'></span>

<h3>Description</h3>

<p>A simple mediation
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_med
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows
and 5 variables:
</p>

<dl>
<dt>x</dt><dd><p>Predictor. Numeric.</p>
</dd>
<dt>m</dt><dd><p>Mediator. Numeric.</p>
</dd>
<dt>y</dt><dd><p>Outcome variable. Numeric.</p>
</dd>
<dt>c1</dt><dd><p>Control variable. Numeric.</p>
</dd>
<dt>c2</dt><dd><p>Control variable. Numeric.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
data(data_med)
mod &lt;-
"
m ~ a * x + c1 + c2
y ~ b * m + x + c1 + c2
ab := a * b
"
fit &lt;- sem(mod, data_med, fixed.x = FALSE)
parameterEstimates(fit)
</code></pre>

<hr>
<h2 id='data_med_complicated'>Sample Dataset: A Complicated
Mediation Model</h2><span id='topic+data_med_complicated'></span>

<h3>Description</h3>

<p>A mediation model with
two predictors, two pathways,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_med_complicated
</code></pre>


<h3>Format</h3>

<p>A data frame with 300 rows
and 5 variables:
</p>

<dl>
<dt>x1</dt><dd><p>Predictor 1. Numeric.</p>
</dd>
<dt>x2</dt><dd><p>Predictor 2. Numeric.</p>
</dd>
<dt>m11</dt><dd><p>Mediator 1 in Path 1. Numeric.</p>
</dd>
<dt>m12</dt><dd><p>Mediator 2 in Path 1. Numeric.</p>
</dd>
<dt>m2</dt><dd><p>Mediator in Path 2. Numeric.</p>
</dd>
<dt>y1</dt><dd><p>Outcome variable 1. Numeric.</p>
</dd>
<dt>y2</dt><dd><p>Outcome variable 2. Numeric.</p>
</dd>
<dt>c1</dt><dd><p>Control variable. Numeric.</p>
</dd>
<dt>c2</dt><dd><p>Control variable. Numeric.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(data_med_complicated)
dat &lt;- data_med_complicated
summary(lm_m11 &lt;- lm(m11 ~ x1 + x1 + x2 + c1 + c2, dat))
summary(lm_m12 &lt;- lm(m12 ~ m11 + x1 + x2 + c1 + c2, dat))
summary(lm_m2 &lt;- lm(m2 ~ x1 + x2 + c1 + c2, dat))
summary(lm_y1 &lt;- lm(y1 ~ m11 + m12 + m2 + x1 + x2 + c1 + c2, dat))
summary(lm_y2 &lt;- lm(y2 ~ m11 + m12 + m2 + x1 + x2 + c1 + c2, dat))
</code></pre>

<hr>
<h2 id='data_med_mod_a'>Sample Dataset: Simple
Mediation with a-Path Moderated</h2><span id='topic+data_med_mod_a'></span>

<h3>Description</h3>

<p>A simple mediation model
with a-path moderated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_med_mod_a
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows
and 6 variables:
</p>

<dl>
<dt>x</dt><dd><p>Predictor. Numeric.</p>
</dd>
<dt>w</dt><dd><p>Moderator. Numeric.</p>
</dd>
<dt>m</dt><dd><p>Mediator. Numeric.</p>
</dd>
<dt>y</dt><dd><p>Outcome variable. Numeric.</p>
</dd>
<dt>c1</dt><dd><p>Control variable. Numeric.</p>
</dd>
<dt>c2</dt><dd><p>Control variable. Numeric.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
data(data_med_mod_a)
data_med_mod_a$xw &lt;-
 data_med_mod_a$x *
 data_med_mod_a$w
mod &lt;-
"
m ~ a * x + w + d * xw + c1 + c2
y ~ b * m + x + w + c1 + c2
w ~~ v_w * w
w ~ m_w * 1
ab := a * b
ab_lo := (a + d * (m_w - sqrt(v_w))) * b
ab_hi := (a + d * (m_w + sqrt(v_w))) * b
"
fit &lt;- sem(mod, data_med_mod_a,
           meanstructure = TRUE, fixed.x = FALSE)
parameterEstimates(fit)[c(1, 3, 6, 11, 12, 31:33), ]
</code></pre>

<hr>
<h2 id='data_med_mod_ab'>Sample Dataset: Simple
Mediation with Both Paths Moderated
(Two Moderators)</h2><span id='topic+data_med_mod_ab'></span>

<h3>Description</h3>

<p>A simple mediation model
with a-path and b-path each moderated
by a moderator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_med_mod_ab
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows
and 7 variables:
</p>

<dl>
<dt>x</dt><dd><p>Predictor. Numeric.</p>
</dd>
<dt>w1</dt><dd><p>Moderator 1. Numeric.</p>
</dd>
<dt>w2</dt><dd><p>Moderator 2. Numeric.</p>
</dd>
<dt>m</dt><dd><p>Mediator. Numeric.</p>
</dd>
<dt>y</dt><dd><p>Outcome variable. Numeric.</p>
</dd>
<dt>c1</dt><dd><p>Control variable. Numeric.</p>
</dd>
<dt>c2</dt><dd><p>Control variable. Numeric.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
data(data_med_mod_ab)
data_med_mod_ab$xw1 &lt;-
 data_med_mod_ab$x *
 data_med_mod_ab$w1
data_med_mod_ab$mw2 &lt;-
 data_med_mod_ab$m *
 data_med_mod_ab$w2
mod &lt;-
"
m ~ a * x + w1 + d1 * xw1 + c1 + c2
y ~ b * m + x + w1 + w2 + d2 * mw2 + c1 + c2
w1 ~~ v_w1 * w1
w1 ~ m_w1 * 1
w2 ~~ v_w2 * w2
w2 ~ m_w2 * 1
ab := a * b
ab_lolo := (a + d1 * (m_w1 - sqrt(v_w1))) * (b + d2 * (m_w2 - sqrt(v_w2)))
ab_lohi := (a + d1 * (m_w1 - sqrt(v_w1))) * (b + d2 * (m_w2 + sqrt(v_w2)))
ab_hilo := (a + d1 * (m_w1 + sqrt(v_w1))) * (b + d2 * (m_w2 - sqrt(v_w2)))
ab_hihi := (a + d1 * (m_w1 + sqrt(v_w1))) * (b + d2 * (m_w2 + sqrt(v_w2)))
"
fit &lt;- sem(mod, data_med_mod_ab,
           meanstructure = TRUE, fixed.x = FALSE)
parameterEstimates(fit)[c(1, 3, 6, 10, 41:45), ]
</code></pre>

<hr>
<h2 id='data_med_mod_ab1'>Sample Dataset: Simple
Mediation with Both Paths Moderated
By a Moderator</h2><span id='topic+data_med_mod_ab1'></span>

<h3>Description</h3>

<p>A simple mediation model
with a-path and b-path moderated by
one moderator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_med_mod_ab1
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows
and 6 variables:
</p>

<dl>
<dt>x</dt><dd><p>Predictor. Numeric.</p>
</dd>
<dt>w</dt><dd><p>Moderator. Numeric.</p>
</dd>
<dt>m</dt><dd><p>Mediator. Numeric.</p>
</dd>
<dt>y</dt><dd><p>Outcome variable. Numeric.</p>
</dd>
<dt>c1</dt><dd><p>Control variable. Numeric.</p>
</dd>
<dt>c2</dt><dd><p>Control variable. Numeric.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
data(data_med_mod_ab1)
data_med_mod_ab1$xw &lt;-
 data_med_mod_ab1$x *
 data_med_mod_ab1$w
data_med_mod_ab1$mw &lt;-
 data_med_mod_ab1$m *
 data_med_mod_ab1$w
mod &lt;-
"
m ~ a * x + w + da * xw + c1 + c2
y ~ b * m + x + w + db * mw + c1 + c2
w ~~ v_w * w
w ~ m_w * 1
ab := a * b
ab_lo := (a + da * (m_w - sqrt(v_w))) * (b + db * (m_w - sqrt(v_w)))
ab_hi := (a + da * (m_w + sqrt(v_w))) * (b + db * (m_w + sqrt(v_w)))
"
fit &lt;- sem(mod, data_med_mod_ab1,
           meanstructure = TRUE, fixed.x = FALSE)
parameterEstimates(fit)[c(1, 3, 6, 9, 38:40), ]
</code></pre>

<hr>
<h2 id='data_med_mod_b'>Sample Dataset: Simple
Mediation with b-Path Moderated</h2><span id='topic+data_med_mod_b'></span>

<h3>Description</h3>

<p>A simple mediation model
with b-path moderated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_med_mod_b
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows
and 6 variables:
</p>

<dl>
<dt>x</dt><dd><p>Predictor. Numeric.</p>
</dd>
<dt>w</dt><dd><p>Moderator. Numeric.</p>
</dd>
<dt>m</dt><dd><p>Mediator. Numeric.</p>
</dd>
<dt>y</dt><dd><p>Outcome variable. Numeric.</p>
</dd>
<dt>c1</dt><dd><p>Control variable. Numeric.</p>
</dd>
<dt>c2</dt><dd><p>Control variable. Numeric.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
data(data_med_mod_b)
data_med_mod_b$mw &lt;-
 data_med_mod_b$m *
 data_med_mod_b$w
mod &lt;-
"
m ~ a * x + w + c1 + c2
y ~ b * m + x + d * mw + c1 + c2
w ~~ v_w * w
w ~ m_w * 1
ab := a * b
ab_lo := a * (b + d * (m_w - sqrt(v_w)))
ab_hi := a * (b + d * (m_w + sqrt(v_w)))
"
fit &lt;- sem(mod, data_med_mod_b,
           meanstructure = TRUE, fixed.x = FALSE)
parameterEstimates(fit)[c(1, 5, 7, 10, 11, 30:32), ]
</code></pre>

<hr>
<h2 id='data_med_mod_b_mod'>Sample Dataset: A Simple
Mediation Model with b-Path
Moderated-Moderation</h2><span id='topic+data_med_mod_b_mod'></span>

<h3>Description</h3>

<p>A simple mediation model
with moderated-mediation on the
b-path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_med_mod_b_mod
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows
and 5 variables:
</p>

<dl>
<dt>x</dt><dd><p>Predictor. Numeric.</p>
</dd>
<dt>w1</dt><dd><p>Moderator on b-path. Numeric.</p>
</dd>
<dt>w2</dt><dd><p>Moderator on the moderating effect of w1. Numeric.</p>
</dd>
<dt>m</dt><dd><p>Mediator. Numeric.</p>
</dd>
<dt>y</dt><dd><p>Outcome variable. Numeric.</p>
</dd>
<dt>c1</dt><dd><p>Control variable. Numeric.</p>
</dd>
<dt>c2</dt><dd><p>Control variable. Numeric.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(data_med_mod_b_mod)
dat &lt;- data_med_mod_b_mod
summary(lm_m &lt;- lm(m ~ x + c1 + c2, dat))
summary(lm_y &lt;- lm(y ~ m*w1*w2 + x + c1 + c2, dat))
</code></pre>

<hr>
<h2 id='data_med_mod_parallel'>Sample Dataset: Parallel
Mediation with Two Moderators</h2><span id='topic+data_med_mod_parallel'></span>

<h3>Description</h3>

<p>A parallel mediation
model with a1-path and b2-path
moderated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_med_mod_parallel
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows
and 8 variables:
</p>

<dl>
<dt>x</dt><dd><p>Predictor. Numeric.</p>
</dd>
<dt>w1</dt><dd><p>Moderator 1. Numeric.</p>
</dd>
<dt>w2</dt><dd><p>Moderator 2. Numeric.</p>
</dd>
<dt>m1</dt><dd><p>Mediator 1. Numeric.</p>
</dd>
<dt>m2</dt><dd><p>Mediator 2. Numeric.</p>
</dd>
<dt>y</dt><dd><p>Outcome variable. Numeric.</p>
</dd>
<dt>c1</dt><dd><p>Control variable. Numeric.</p>
</dd>
<dt>c2</dt><dd><p>Control variable. Numeric.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
data(data_med_mod_parallel)
data_med_mod_parallel$xw1 &lt;-
 data_med_mod_parallel$x *
 data_med_mod_parallel$w1
data_med_mod_parallel$m2w2 &lt;-
 data_med_mod_parallel$m2 *
 data_med_mod_parallel$w2
mod &lt;-
"
m1 ~ a1 * x + w1 + da1 * xw1 + c1 + c2
m2 ~ a2 * x + w1 + c1 + c2
y ~ b1 * m1 + b2 * m2 + x + w1 + w2 + db2 * m2w2 + c1 + c2
w1 ~~ v_w1 * w1
w1 ~ m_w1 * 1
w2 ~~ v_w2 * w2
w2 ~ m_w2 * 1
a1b1 := a1 * b1
a2b2 := a2 * b2
a1b1_w1lo := (a1 + da1 * (m_w1 - sqrt(v_w1))) * b1
a1b1_w1hi := (a1 + da1 * (m_w1 + sqrt(v_w1))) * b2
a2b2_w2lo := a2 * (b2 + db2 * (m_w2 - sqrt(v_w2)))
a2b2_w2hi := a2 * (b2 + db2 * (m_w2 + sqrt(v_w2)))
"
fit &lt;- sem(mod, data_med_mod_parallel,
           meanstructure = TRUE, fixed.x = FALSE)
parameterEstimates(fit)[c(1, 3, 6, 10, 11, 15, 48:53), ]
</code></pre>

<hr>
<h2 id='data_med_mod_parallel_cat'>Sample Dataset: Parallel
Moderated Mediation with Two
Categorical Moderators</h2><span id='topic+data_med_mod_parallel_cat'></span>

<h3>Description</h3>

<p>A parallel mediation
model with two categorical
moderators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_med_mod_parallel_cat
</code></pre>


<h3>Format</h3>

<p>A data frame with 300 rows
and 8 variables:
</p>

<dl>
<dt>x</dt><dd><p>Predictor. Numeric.</p>
</dd>
<dt>w1</dt><dd><p>Moderator. String. Values: &quot;group1&quot;, &quot;group2&quot;, &quot;group3&quot;</p>
</dd>
<dt>w2</dt><dd><p>Moderator. String. Values: &quot;team1&quot;, &quot;team2&quot;</p>
</dd>
<dt>m1</dt><dd><p>Mediator 1. Numeric.</p>
</dd>
<dt>m2</dt><dd><p>Mediator 2. Numeric.</p>
</dd>
<dt>y</dt><dd><p>Outcome variable. Numeric.</p>
</dd>
<dt>c1</dt><dd><p>Control variable. Numeric.</p>
</dd>
<dt>c2</dt><dd><p>Control variable. Numeric.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(data_med_mod_parallel_cat)
dat &lt;- data_med_mod_parallel_cat
summary(lm_m1 &lt;- lm(m1 ~ x*w1 + c1 + c2, dat))
summary(lm_m2 &lt;- lm(m2 ~ x*w1 + c1 + c2, dat))
summary(lm_y &lt;- lm(y ~ m1*w2 + m2*w2 + m1 + x + w1 + c1 + c2, dat))
</code></pre>

<hr>
<h2 id='data_med_mod_serial'>Sample Dataset: Serial
Mediation with Two Moderators</h2><span id='topic+data_med_mod_serial'></span>

<h3>Description</h3>

<p>A simple mediation model
with a-path and b2-path moderated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_med_mod_serial
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows
and 8 variables:
</p>

<dl>
<dt>x</dt><dd><p>Predictor. Numeric.</p>
</dd>
<dt>w1</dt><dd><p>Moderator 1. Numeric.</p>
</dd>
<dt>w2</dt><dd><p>Moderator 2. Numeric.</p>
</dd>
<dt>m1</dt><dd><p>Mediator 1. Numeric.</p>
</dd>
<dt>m2</dt><dd><p>Mediator 2. Numeric.</p>
</dd>
<dt>y</dt><dd><p>Outcome variable. Numeric.</p>
</dd>
<dt>c1</dt><dd><p>Control variable. Numeric.</p>
</dd>
<dt>c2</dt><dd><p>Control variable. Numeric.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
data(data_med_mod_serial)
data_med_mod_serial$xw1 &lt;-
 data_med_mod_serial$x *
 data_med_mod_serial$w1
data_med_mod_serial$m2w2 &lt;-
 data_med_mod_serial$m2 *
 data_med_mod_serial$w2
mod &lt;-
"
m1 ~ a * x + w1 + da1 * xw1 + c1 + c2
m2 ~ b1 * m1 + x + w1 + c1 + c2
y ~ b2 * m2 + m1 + x + w1 + w2 + db2 * m2w2 + c1 + c2
w1 ~~ v_w1 * w1
w1 ~ m_w1 * 1
w2 ~~ v_w2 * w2
w2 ~ m_w2 * 1
ab1b2 := a * b1 * b2
ab1b2_lolo := (a + da1 * (m_w1 - sqrt(v_w1))) * b1 * (b2 + db2 * (m_w2 - sqrt(v_w2)))
ab1b2_lohi := (a + da1 * (m_w1 - sqrt(v_w1))) * b1 * (b2 + db2 * (m_w2 + sqrt(v_w2)))
ab1b2_hilo := (a + da1 * (m_w1 + sqrt(v_w1))) * b1 * (b2 + db2 * (m_w2 - sqrt(v_w2)))
ab1b2_hihi := (a + da1 * (m_w1 + sqrt(v_w1))) * b1 * (b2 + db2 * (m_w2 + sqrt(v_w2)))
"
fit &lt;- sem(mod, data_med_mod_serial,
           meanstructure = TRUE, fixed.x = FALSE)
parameterEstimates(fit)[c(1, 3, 6, 11, 16, 49:53), ]
</code></pre>

<hr>
<h2 id='data_med_mod_serial_cat'>Sample Dataset: Serial
Moderated Mediation with Two
Categorical Moderators</h2><span id='topic+data_med_mod_serial_cat'></span>

<h3>Description</h3>

<p>A serial mediation model
with two categorical moderators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_med_mod_serial_cat
</code></pre>


<h3>Format</h3>

<p>A data frame with 300 rows
and 8 variables:
</p>

<dl>
<dt>x</dt><dd><p>Predictor. Numeric.</p>
</dd>
<dt>w1</dt><dd><p>Moderator. String. Values: &quot;group1&quot;, &quot;group2&quot;, &quot;group3&quot;</p>
</dd>
<dt>w2</dt><dd><p>Moderator. String. Values: &quot;team1&quot;, &quot;team2&quot;</p>
</dd>
<dt>m1</dt><dd><p>Mediator 1. Numeric.</p>
</dd>
<dt>m2</dt><dd><p>Mediator 2. Numeric.</p>
</dd>
<dt>y</dt><dd><p>Outcome variable. Numeric.</p>
</dd>
<dt>c1</dt><dd><p>Control variable. Numeric.</p>
</dd>
<dt>c2</dt><dd><p>Control variable. Numeric.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(data_med_mod_serial_cat)
dat &lt;- data_med_mod_serial_cat
summary(lm_m1 &lt;- lm(m1 ~ x*w1 + c1 + c2, dat))
summary(lm_m2 &lt;- lm(m2 ~ m1 + x + w1 + c1 + c2, dat))
summary(lm_y &lt;- lm(y ~ m2*w2 + m1 + x + w1 + c1 + c2, dat))
</code></pre>

<hr>
<h2 id='data_med_mod_serial_parallel'>Sample Dataset:
Serial-Parallel Mediation with Two
Moderators</h2><span id='topic+data_med_mod_serial_parallel'></span>

<h3>Description</h3>

<p>A serial-parallel
mediation model with some paths
moderated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_med_mod_serial_parallel
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows
and 9 variables:
</p>

<dl>
<dt>x</dt><dd><p>Predictor. Numeric.</p>
</dd>
<dt>w1</dt><dd><p>Moderator 1. Numeric.</p>
</dd>
<dt>w2</dt><dd><p>Moderator 2. Numeric.</p>
</dd>
<dt>m11</dt><dd><p>Mediator 1 in Path 1. Numeric.</p>
</dd>
<dt>m12</dt><dd><p>Mediator 2 in Path 2. Numeric.</p>
</dd>
<dt>m2</dt><dd><p>Mediator 2. Numeric.</p>
</dd>
<dt>y</dt><dd><p>Outcome variable. Numeric.</p>
</dd>
<dt>c1</dt><dd><p>Control variable. Numeric.</p>
</dd>
<dt>c2</dt><dd><p>Control variable. Numeric.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
data(data_med_mod_serial_parallel)
data_med_mod_serial_parallel$xw1 &lt;-
 data_med_mod_serial_parallel$x *
 data_med_mod_serial_parallel$w1
data_med_mod_serial_parallel$m2w2 &lt;-
 data_med_mod_serial_parallel$m2 *
 data_med_mod_serial_parallel$w2
mod &lt;-
"
m11 ~ a1 * x + w1 + da11 * xw1 + c1 + c2
m12 ~ b11 * m11 + x + w1 + c1 + c2
m2 ~ a2 * x + c1 + c2
y ~ b12 * m12 + b2 * m2 + m11 + x + w1 + w2 + db2 * m2w2 + c1 + c2
w1 ~~ v_w1 * w1
w1 ~ m_w1 * 1
w2 ~~ v_w2 * w2
w2 ~ m_w2 * 1
a1b11b22 := a1 * b11 * b12
a2b2 := a2 * b2
ab := a1b11b22 + a2b2
a1b11b12_w1lo := (a1 + da11 * (m_w1 - sqrt(v_w1))) * b11 * b12
a1b11b12_w1hi := (a1 + da11 * (m_w1 + sqrt(v_w1))) * b11 * b12
a2b2_w2lo := a2 * (b2 + db2 * (m_w2 - sqrt(v_w2)))
a2b2_w2hi := a2 * (b2 + db2 * (m_w2 + sqrt(v_w2)))
"
fit &lt;- sem(mod, data_med_mod_serial_parallel,
           meanstructure = TRUE, fixed.x = FALSE)
parameterEstimates(fit)[parameterEstimates(fit)$label != "", ]
</code></pre>

<hr>
<h2 id='data_med_mod_serial_parallel_cat'>Sample Dataset:
Serial-Parallel Moderated Mediation
with Two Categorical Moderators</h2><span id='topic+data_med_mod_serial_parallel_cat'></span>

<h3>Description</h3>

<p>A serial-parallel
mediation model with two categorical
moderators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_med_mod_serial_parallel_cat
</code></pre>


<h3>Format</h3>

<p>A data frame with 300 rows
and 8 variables:
</p>

<dl>
<dt>x</dt><dd><p>Predictor. Numeric.</p>
</dd>
<dt>w1</dt><dd><p>Moderator. String. Values: &quot;group1&quot;, &quot;group2&quot;, &quot;group3&quot;</p>
</dd>
<dt>w2</dt><dd><p>Moderator. String. Values: &quot;team1&quot;, &quot;team2&quot;</p>
</dd>
<dt>m11</dt><dd><p>Mediator 1 in Path 1. Numeric.</p>
</dd>
<dt>m12</dt><dd><p>Mediator 2 in Path 1. Numeric.</p>
</dd>
<dt>m2</dt><dd><p>Mediator in Path 2. Numeric.</p>
</dd>
<dt>y</dt><dd><p>Outcome variable. Numeric.</p>
</dd>
<dt>c1</dt><dd><p>Control variable. Numeric.</p>
</dd>
<dt>c2</dt><dd><p>Control variable. Numeric.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(data_med_mod_serial_parallel_cat)
dat &lt;- data_med_mod_serial_parallel_cat
summary(lm_m11 &lt;- lm(m11 ~ x*w1 + c1 + c2, dat))
summary(lm_m12 &lt;- lm(m12 ~ m11 + x + w1 + c1 + c2, dat))
summary(lm_m2 &lt;- lm(m2 ~ x + w1 + c1 + c2, dat))
summary(lm_y &lt;- lm(y ~ m12 + m2*w2 + m12 + x + c1 + c2, dat))
</code></pre>

<hr>
<h2 id='data_mod'>Sample Dataset: One Moderator</h2><span id='topic+data_mod'></span>

<h3>Description</h3>

<p>A one-moderator model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_mod
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows
and 5 variables:
</p>

<dl>
<dt>x</dt><dd><p>Predictor. Numeric.</p>
</dd>
<dt>w</dt><dd><p>Moderator. Numeric.</p>
</dd>
<dt>y</dt><dd><p>Outcome variable. Numeric.</p>
</dd>
<dt>c1</dt><dd><p>Control variable. Numeric.</p>
</dd>
<dt>c2</dt><dd><p>Control variable. Numeric.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
data(data_mod)
data_mod$xw &lt;- data_mod$x * data_mod$w
mod &lt;-
"
y ~ a * x + w + d * xw + c1 + c2
w ~~ v_w * w
w ~ m_w * 1
a_lo := a + d * (m_w - sqrt(v_w))
a_hi := a + d * (m_w + sqrt(v_w))
"
fit &lt;- sem(mod, data_mod, fixed.x = FALSE)
parameterEstimates(fit)[c(1, 3, 6, 7, 24, 25), ]
</code></pre>

<hr>
<h2 id='data_mod_cat'>Sample Dataset: Moderation
with One Categorical Moderator</h2><span id='topic+data_mod_cat'></span>

<h3>Description</h3>

<p>A moderation model with
a categorical moderator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_mod_cat
</code></pre>


<h3>Format</h3>

<p>A data frame with 300 rows
and 5 variables:
</p>

<dl>
<dt>x</dt><dd><p>Predictor. Numeric.</p>
</dd>
<dt>w</dt><dd><p>Moderator. String. Values: &quot;group1&quot;, &quot;group2&quot;, &quot;group3&quot;</p>
</dd>
<dt>y</dt><dd><p>Outcome variable. Numeric.</p>
</dd>
<dt>c1</dt><dd><p>Control variable. Numeric.</p>
</dd>
<dt>c2</dt><dd><p>Control variable. Numeric.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(data_mod_cat)
dat &lt;- data_mod_cat
summary(lm_y &lt;- lm(y ~ x*w + c1 + c2, dat))
</code></pre>

<hr>
<h2 id='data_mod2'>Sample Dataset: Two Moderators</h2><span id='topic+data_mod2'></span>

<h3>Description</h3>

<p>A two-moderator model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_mod2
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows
and 6 variables:
</p>

<dl>
<dt>x</dt><dd><p>Predictor. Numeric.</p>
</dd>
<dt>w1</dt><dd><p>Moderator 1. Numeric.</p>
</dd>
<dt>w2</dt><dd><p>Moderator 2. Numeric.</p>
</dd>
<dt>y</dt><dd><p>Outcome variable. Numeric.</p>
</dd>
<dt>c1</dt><dd><p>Control variable. Numeric.</p>
</dd>
<dt>c2</dt><dd><p>Control variable. Numeric.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
data(data_mod2)
data_mod2$xw1 &lt;- data_mod2$x * data_mod2$w1
data_mod2$xw2 &lt;- data_mod2$x * data_mod2$w2
mod &lt;-
"
y ~ a * x + w1 + w2 + d1 * xw1 + d2 * xw2 + c1 + c2
w1 ~~ v_w1 * w1
w1 ~ m_w1 * 1
w2 ~~ v_w2 * w2
w2 ~ m_w2 * 1
a_lolo := a + d1 * (m_w1 - sqrt(v_w1)) + d2 * (m_w2 - sqrt(v_w2))
a_lohi := a + d1 * (m_w1 - sqrt(v_w1)) + d2 * (m_w2 + sqrt(v_w2))
a_hilo := a + d1 * (m_w1 + sqrt(v_w1)) + d2 * (m_w2 - sqrt(v_w2))
a_hihi := a + d1 * (m_w1 + sqrt(v_w1)) + d2 * (m_w2 + sqrt(v_w2))
"
fit &lt;- sem(mod, data_mod2, fixed.x = FALSE)
parameterEstimates(fit)[c(1, 4, 5, 8:11, 34:37), ]
</code></pre>

<hr>
<h2 id='data_mome_demo'>Sample Dataset: A Complicated
Moderated-Mediation Model</h2><span id='topic+data_mome_demo'></span>

<h3>Description</h3>

<p>Generated from a
complicated moderated-mediation model
for demonstration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_mome_demo
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 rows
and 11 variables:
</p>

<dl>
<dt>x1</dt><dd><p>Predictor 1. Numeric.</p>
</dd>
<dt>x2</dt><dd><p>Predictor 2. Numeric.</p>
</dd>
<dt>m1</dt><dd><p>Mediator 1. Numeric.</p>
</dd>
<dt>m2</dt><dd><p>Mediator 2. Numeric.</p>
</dd>
<dt>m3</dt><dd><p>Mediator 3. Numeric.</p>
</dd>
<dt>y1</dt><dd><p>Outcome Variable 1. Numeric.</p>
</dd>
<dt>y2</dt><dd><p>Outcome Variable 2. Numeric.</p>
</dd>
<dt>w1</dt><dd><p>Moderator 1. Numeric.</p>
</dd>
<dt>w2</dt><dd><p>Moderator 21. Numeric.</p>
</dd>
<dt>c1</dt><dd><p>Control Variable 1. Numeric.</p>
</dd>
<dt>c2</dt><dd><p>Control Variable 2. Numeric.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The model:
</p>
<div class="sourceCode"><pre># w1x1 &lt;- x1 * w1
# w2m2 &lt;- w2 * m2
m1 ~ x1 + w1 + w1x1 + x2 + c1 + c2
m2 ~ m1 + c1 + c2
m3 ~ x2 + x1 + c1 + c2
y1 ~ m2 + w2 + w2m2 + x1 + x2 + m3 + c1 + c2
y2 ~ m3 + x2 + x1 + m2 + c1 + c2
# Covariances excluded for brevity
</pre></div>

<hr>
<h2 id='data_mome_demo_missing'>Sample Dataset: A Complicated
Moderated-Mediation Model With
Missing Data</h2><span id='topic+data_mome_demo_missing'></span>

<h3>Description</h3>

<p>Generated from a
complicated moderated-mediation model
for demonstration, with missing data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_mome_demo_missing
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 rows
and 11 variables:
</p>

<dl>
<dt>x1</dt><dd><p>Predictor 1. Numeric.</p>
</dd>
<dt>x2</dt><dd><p>Predictor 2. Numeric.</p>
</dd>
<dt>m1</dt><dd><p>Mediator 1. Numeric.</p>
</dd>
<dt>m2</dt><dd><p>Mediator 2. Numeric.</p>
</dd>
<dt>m3</dt><dd><p>Mediator 3. Numeric.</p>
</dd>
<dt>y1</dt><dd><p>Outcome Variable 1. Numeric.</p>
</dd>
<dt>y2</dt><dd><p>Outcome Variable 2. Numeric.</p>
</dd>
<dt>w1</dt><dd><p>Moderator 1. Numeric.</p>
</dd>
<dt>w2</dt><dd><p>Moderator 21. Numeric.</p>
</dd>
<dt>c1</dt><dd><p>Control Variable 1. Numeric.</p>
</dd>
<dt>c2</dt><dd><p>Control Variable 2. Numeric.</p>
</dd>
</dl>



<h3>Details</h3>

<p>A copy of <a href="#topic+data_mome_demo">data_mome_demo</a> with some
randomly selected cells changed to
<code>NA</code>. The number of cases with no
missing data is 169.
</p>
<p>The model:
</p>
<div class="sourceCode"><pre># w1x1 &lt;- x1 * w1
# w2m2 &lt;- w2 * m2
m1 ~ x1 + w1 + w1x1 + x2 + c1 + c2
m2 ~ m1 + c1 + c2
m3 ~ x2 + x1 + c1 + c2
y1 ~ m2 + w2 + w2m2 + x1 + x2 + m3 + c1 + c2
y2 ~ m3 + x2 + x1 + m2 + c1 + c2
# Covariances excluded for brevity
</pre></div>

<hr>
<h2 id='data_parallel'>Sample Dataset: Parallel Mediation</h2><span id='topic+data_parallel'></span>

<h3>Description</h3>

<p>A parallel mediation model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_parallel
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows and 6 variables:
</p>

<dl>
<dt>x</dt><dd><p>Predictor. Numeric.</p>
</dd>
<dt>m1</dt><dd><p>Mediator 1. Numeric.</p>
</dd>
<dt>m2</dt><dd><p>Mediator 2. Numeric.</p>
</dd>
<dt>y</dt><dd><p>Outcome variable. Numeric.</p>
</dd>
<dt>c1</dt><dd><p>Control variable. Numeric.</p>
</dd>
<dt>c2</dt><dd><p>Control variable. Numeric.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
data(data_parallel)
mod &lt;-
"
m1 ~ a1 * x + c1 + c2
m2 ~ a2 * x + c1 + c2
y ~ b2 * m2 + b1 * m1 + x + c1 + c2
indirect1 := a1 * b1
indirect2 := a2 * b2
indirect := a1 * b1 + a2 * b2
"
fit &lt;- sem(mod, data_parallel,
           meanstructure = TRUE, fixed.x = FALSE)
parameterEstimates(fit)[c(1, 4, 7, 8, 27:29), ]
</code></pre>

<hr>
<h2 id='data_sem'>Sample Dataset: A Latent
Variable Mediation Model With 4
Factors</h2><span id='topic+data_sem'></span>

<h3>Description</h3>

<p>This data set is for
testing functions in a four-factor
structural model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_sem
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 rows
and 14 variables:
</p>

<dl>
<dt>x01</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x02</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x03</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x04</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x05</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x06</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x07</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x08</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x09</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x10</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x11</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x12</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x13</dt><dd><p>Indicator. Numeric.</p>
</dd>
<dt>x14</dt><dd><p>Indicator. Numeric.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(data_sem)
dat &lt;- data_med_mod_b_mod
mod &lt;-
  'f1 =~ x01 + x02 + x03
   f2 =~ x04 + x05 + x06 + x07
   f3 =~ x08 + x09 + x10
   f4 =~ x11 + x12 + x13 + x14
   f3 ~  a1*f1 + a2*f2
   f4 ~  b1*f1 + b3*f3
   a1b3 := a1 * b3
   a2b3 := a2 * b3
  '
fit &lt;- lavaan::sem(model = mod, data = data_sem)
summary(fit)

</code></pre>

<hr>
<h2 id='data_serial'>Sample Dataset: Serial
Mediation</h2><span id='topic+data_serial'></span>

<h3>Description</h3>

<p>A serial mediation
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_serial
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows
and 6 variables:
</p>

<dl>
<dt>x</dt><dd><p>Predictor. Numeric.</p>
</dd>
<dt>m1</dt><dd><p>Mediator 1. Numeric.</p>
</dd>
<dt>m2</dt><dd><p>Mediator 2. Numeric.</p>
</dd>
<dt>y</dt><dd><p>Outcome variable. Numeric.</p>
</dd>
<dt>c1</dt><dd><p>Control variable. Numeric.</p>
</dd>
<dt>c2</dt><dd><p>Control variable. Numeric.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
data(data_serial)
mod &lt;-
"
m1 ~ a * x + c1 + c2
m2 ~ b1 * m1 + x + c1 + c2
y ~ b2 * m2 + m1 + x + c1 + c2
indirect := a * b1 * b2
"
fit &lt;- sem(mod, data_serial,
           meanstructure = TRUE, fixed.x = FALSE)
parameterEstimates(fit)[c(1, 4, 8, 28), ]
</code></pre>

<hr>
<h2 id='data_serial_parallel'>Sample Dataset:
Serial-Parallel Mediation</h2><span id='topic+data_serial_parallel'></span>

<h3>Description</h3>

<p>A mediation model with
both serial and parallel components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_serial_parallel
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows
and 7 variables:
</p>

<dl>
<dt>x</dt><dd><p>Predictor. Numeric.</p>
</dd>
<dt>m11</dt><dd><p>Mediator 1 in Path 1. Numeric.</p>
</dd>
<dt>m12</dt><dd><p>Mediator 2 in Path 1. Numeric.</p>
</dd>
<dt>m2</dt><dd><p>Mediator in Path 2. Numeric.</p>
</dd>
<dt>y</dt><dd><p>Outcome variable. Numeric.</p>
</dd>
<dt>c1</dt><dd><p>Control variable. Numeric.</p>
</dd>
<dt>c2</dt><dd><p>Control variable. Numeric.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
data(data_serial_parallel)
mod &lt;-
"
m11 ~ a11 * x + c1 + c2
m12 ~ b11 * m11 + x + c1 + c2
m2 ~ a2 * x + c1 + c2
y ~ b12 * m12 + b2 * m2 + m11 + x + c1 + c2
indirect1 := a11 * b11 * b12
indirect2 := a2 * b2
indirect := a11 * b11 * b12 + a2 * b2
"
fit &lt;- sem(mod, data_serial_parallel,
           meanstructure = TRUE, fixed.x = FALSE)
parameterEstimates(fit)[c(1, 4, 8, 11, 12, 34:36), ]
</code></pre>

<hr>
<h2 id='data_serial_parallel_latent'>Sample Dataset: A
Latent Mediation Model With Three
Mediators</h2><span id='topic+data_serial_parallel_latent'></span>

<h3>Description</h3>

<p>Generated from a 3-mediator
mediation model among eight latent
factors, <code>fx1</code>, <code>fx2</code>, <code>fm11</code>, <code>fm12</code>,
<code>fy1</code>, and <code>fy2</code>, each
has three indicators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_serial_parallel_latent
</code></pre>


<h3>Format</h3>

<p>A data frame with 500 rows
and 21 variables:
</p>

<dl>
<dt>x1</dt><dd><p>Indicator of <code>fx1</code>. Numeric.</p>
</dd>
<dt>x2</dt><dd><p>Indicator of <code>fx1</code>. Numeric.</p>
</dd>
<dt>x3</dt><dd><p>Indicator of <code>fx1</code>. Numeric.</p>
</dd>
<dt>x4</dt><dd><p>Indicator of <code>fx2</code>. Numeric.</p>
</dd>
<dt>x5</dt><dd><p>Indicator of <code>fx2</code>. Numeric.</p>
</dd>
<dt>x6</dt><dd><p>Indicator of <code>fx2</code>. Numeric.</p>
</dd>
<dt>m11a</dt><dd><p>Indicator of <code>fm11</code>. Numeric.</p>
</dd>
<dt>m11b</dt><dd><p>Indicator of <code>fm11</code>. Numeric.</p>
</dd>
<dt>m11c</dt><dd><p>Indicator of <code>fm11</code>. Numeric.</p>
</dd>
<dt>m12a</dt><dd><p>Indicator of <code>fm12</code>. Numeric.</p>
</dd>
<dt>m12b</dt><dd><p>Indicator of <code>fm12</code>. Numeric.</p>
</dd>
<dt>m12c</dt><dd><p>Indicator of <code>fm12</code>. Numeric.</p>
</dd>
<dt>m2a</dt><dd><p>Indicator of <code>fm2</code>. Numeric.</p>
</dd>
<dt>m2b</dt><dd><p>Indicator of <code>fm2</code>. Numeric.</p>
</dd>
<dt>m2c</dt><dd><p>Indicator of <code>fm2</code>. Numeric.</p>
</dd>
<dt>y1</dt><dd><p>Indicator of <code>fy1</code>. Numeric.</p>
</dd>
<dt>y2</dt><dd><p>Indicator of <code>fy1</code>. Numeric.</p>
</dd>
<dt>y3</dt><dd><p>Indicator of <code>fy1</code>. Numeric.</p>
</dd>
<dt>y4</dt><dd><p>Indicator of <code>fy2</code>. Numeric.</p>
</dd>
<dt>y5</dt><dd><p>Indicator of <code>fy2</code>. Numeric.</p>
</dd>
<dt>y6</dt><dd><p>Indicator of <code>fy2</code>. Numeric.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The model:
</p>
<div class="sourceCode"><pre>fx1 =~ x1 + x2 + x3
fx2 =~ x4 + x5 + x6
fm11 =~ m11a + m11b + m11c
fm12 =~ m12a + m12b + m12c
fm2  =~ m2a + m2b + m2c
fy1 =~ y1 + y2 + y3
fy2 =~ y3 + y4 + y5
fm11 ~ a1 * fx1
fm12 ~ b11 * fm11 + a2m * fx2
fm2 ~ a2 * fx2
fy1 ~ b12 * fm12 + b11y1 * fm11 + cp1 * fx1
fy2 ~ b2 * fm2 + cp2 * fx2
a1b11b12 := a1 * b11 * b12
a1b11y1 := a1 * b11y1
a2b2 := a2 * b2
a2mb12 := a2m * b12
</pre></div>

<hr>
<h2 id='delta_med'>Delta_Med by Liu, Yuan, and Li (2023)</h2><span id='topic+delta_med'></span>

<h3>Description</h3>

<p>It computes the
Delta_Med proposed by Liu, Yuan,
and Li (2023), an <code class="reqn">R^2</code>-like measure of
indirect effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delta_med(
  x,
  y,
  m,
  fit,
  paths_to_remove = NULL,
  boot_out = NULL,
  level = 0.95,
  progress = TRUE,
  skip_check_single_x = FALSE,
  skip_check_m_between_x_y = FALSE,
  skip_check_x_to_y = FALSE,
  skip_check_latent_variables = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delta_med_+3A_x">x</code></td>
<td>
<p>The name of the <code>x</code> variable.
Must be supplied as a quoted string.</p>
</td></tr>
<tr><td><code id="delta_med_+3A_y">y</code></td>
<td>
<p>The name of the <code>y</code> variable.
Must be supplied as a quoted string.</p>
</td></tr>
<tr><td><code id="delta_med_+3A_m">m</code></td>
<td>
<p>A vector of the variable
names of the mediator(s). If more
than one mediators, they do not have
to be on the same path from <code>x</code>
to <code>y</code>.
Cannot be <code>NULL</code> for this function.</p>
</td></tr>
<tr><td><code id="delta_med_+3A_fit">fit</code></td>
<td>
<p>The fit object. Must be a
<a href="lavaan.html#topic+lavaan-class">lavaan::lavaan</a> object.</p>
</td></tr>
<tr><td><code id="delta_med_+3A_paths_to_remove">paths_to_remove</code></td>
<td>
<p>A character
vector of paths users want to
manually remove, specified in
<code>lavaan</code> model syntax. For example,
<code>c("m2~x", "m3~m2")</code> removes the
path from <code>x</code> to <code>m2</code> and the path
from <code>m2</code> to <code>m3</code>. The default is
<code>NULL</code>, and the paths to remove will
be determined using the method
by Liu et al. (2023). If supplied,
then only paths specified explicitly
will be removed.</p>
</td></tr>
<tr><td><code id="delta_med_+3A_boot_out">boot_out</code></td>
<td>
<p>The
output of <code><a href="#topic+do_boot">do_boot()</a></code>. If supplied,
the stored bootstrap estimates will
be used to form the nonparametric
percentile bootstrap confidence
interval of Delta_Med.</p>
</td></tr>
<tr><td><code id="delta_med_+3A_level">level</code></td>
<td>
<p>The level of confidence
of the bootstrap confidence interval.
Default is .95.</p>
</td></tr>
<tr><td><code id="delta_med_+3A_progress">progress</code></td>
<td>
<p>Logical. Display
bootstrapping progress or not.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="delta_med_+3A_skip_check_single_x">skip_check_single_x</code></td>
<td>
<p>Logical
Check whether the model has one and
only one x-variable. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="delta_med_+3A_skip_check_m_between_x_y">skip_check_m_between_x_y</code></td>
<td>
<p>Logical. Check whether all <code>m</code>
variables are along a path from <code>x</code>
to <code>y</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="delta_med_+3A_skip_check_x_to_y">skip_check_x_to_y</code></td>
<td>
<p>Logical.
Check whether there is a direct path
from <code>x</code> to <code>y</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="delta_med_+3A_skip_check_latent_variables">skip_check_latent_variables</code></td>
<td>
<p>Logical. Check whether the model
has any latent variables. Default
is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It computes Delta_Med, an
<code class="reqn">R^2</code>-like effect
size measure for the indirect effect
from one variable (the <code>y</code>-variable)
to another variable (the <code>x</code>-variable)
through one or more mediators
(<code>m</code>, or <code>m1</code>, <code>m2</code>, etc. when
there are more than one mediator).
</p>
<p>The Delta_Med of one or more
mediators was computed as the
difference between
two <code class="reqn">R^2</code>s:
</p>

<ul>
<li> <p><code class="reqn">R^2_1</code>, the <code class="reqn">R^2</code> when <code>y</code>
is predicted by <code>x</code> and all
mediators.
</p>
</li>
<li> <p><code class="reqn">R^2_2</code>, the <code class="reqn">R^2</code> when the
mediator(s) of
interest is/are removed from the
models, while the error term(s)
of the mediator(s) is/are kept.
</p>
</li></ul>

<p>Delta_Med is given by
<code class="reqn">R^2_1 - R^2_2</code>.
</p>
<p>Please refer to Liu et al. (2023)
for the technical details.
</p>
<p>The function can also form a
nonparametric percentile bootstrap
confidence of Delta_Med.
</p>


<h3>Value</h3>

<p>A <code>delta_med</code> class object.
It is a list-like object with these
major elements:
</p>

<ul>
<li> <p><code>delta_med</code>: The Delta_Med.
</p>
</li>
<li> <p><code>x</code>: The name of the <code>x</code>-variable.
</p>
</li>
<li> <p><code>y</code>: The name of the <code>y</code>-variable.
</p>
</li>
<li> <p><code>m</code>: A character vector of the
mediator(s) along a path. The path
runs from the first element to the
last element.
</p>
</li></ul>

<p>This class has a <code>print</code> method,
a <code>coef</code> method, and a <code>confint</code>
method. See <code><a href="#topic+print.delta_med">print.delta_med()</a></code>,
<code><a href="#topic+coef.delta_med">coef.delta_med()</a></code>, and
<code><a href="#topic+confint.delta_med">confint.delta_med()</a></code>.
</p>


<h3>Implementation</h3>

<p>The function identifies all the
path(s) pointing to the mediator(s)
of concern and fixes the path(s) to
zero, effectively removing the
mediator(s). However, the model is
not refitted, hence keeping the
estimates of all other parameters
unchanged.
It then uses <code><a href="lavaan.html#topic+lav_model">lavaan::lav_model_set_parameters()</a></code>
to update the parameters,
<code><a href="lavaan.html#topic+lav_model">lavaan::lav_model_implied()</a></code> to
update the implied statistics, and
then calls <code><a href="lavaan.html#topic+lavInspect">lavaan::lavInspect()</a></code> to
retrieve the implied variance of the
predicted values of <code>y</code> for computing
the <code class="reqn">R^2_2</code>. Subtracting this
<code class="reqn">R^2_2</code> from <code class="reqn">R^2_1</code> of
<code>y</code> can then yield Delta_Med.
</p>


<h3>Model Requirements</h3>

<p>For now, by defaul, it only
computes Delta_Med
for the types
of models discussed in
Liu et al. (2023):
</p>

<ul>
<li><p> Having one predictor (the
<code>x</code>-variable).
</p>
</li>
<li><p> Having one or more mediators, the
<code>m</code>-variables, with
arbitrary way to mediate the effect
of <code>x</code> on the outcome variable
(<code>y</code>-variable).
</p>
</li>
<li><p> Having one or more outcome variables.
Although their models only have
outcome variables, the computation
of the Delta_Med is not affected
by the presence of other outcome
variables.
</p>
</li>
<li><p> Having no control variables.
</p>
</li>
<li><p> The mediator(s), <code>m</code>, and the
<code>y</code>-variable are continuous.
</p>
</li>
<li> <p><code>x</code> can be continuous
or categorical. If categorical, it
needs to be handle appropriately
when fitting the model.
</p>
</li>
<li> <p><code>x</code> has a direct
path to <code>y</code>.
</p>
</li>
<li><p> All the mediators listed in the
argument <code>m</code> is present in at least
one path from <code>x</code> to <code>y.</code>
</p>
</li>
<li><p> None of the paths from <code>x</code> to <code>y</code>
are moderated.
</p>
</li></ul>

<p>It can be used for other kinds
of models but support for them is
disabled by default. To use
this function for
cases not discussed in
Liu et al. (2023), please disable
relevant requirements stated above
using the relevant
<code style="white-space: pre;">&#8288;skip_check_*&#8288;</code> arguments. An error
will be raised if the models failed
any of the checks not skipped by
users.
</p>


<h3>References</h3>

<p>Liu, H., Yuan, K.-H., &amp; Li, H. (2023).
A systematic framework for defining
R-squared measures in mediation
analysis. <em>Psychological Methods</em>.
Advance online publication.
https://doi.org/10.1037/met0000571
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.delta_med">print.delta_med()</a></code>,
<code><a href="#topic+coef.delta_med">coef.delta_med()</a></code>, and
<code><a href="#topic+confint.delta_med">confint.delta_med()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)
dat &lt;- data_med
mod &lt;-
"
m ~ x
y ~ m + x
"
fit &lt;- sem(mod, dat)
dm &lt;- delta_med(x = "x",
                y = "y",
                m = "m",
                fit = fit)
dm
print(dm, full = TRUE)

# Call do_boot() to generate
# bootstrap estimates
# Use 2000 or even 5000 for R in real studies
# Set parallel to TRUE in real studies for faster bootstrapping
boot_out &lt;- do_boot(fit,
                    R = 45,
                    seed = 879,
                    parallel = FALSE,
                    progress = FALSE)
# Remove 'progress = FALSE' in practice
dm_boot &lt;- delta_med(x = "x",
                     y = "y",
                     m = "m",
                     fit = fit,
                     boot_out = boot_out,
                     progress = FALSE)
dm_boot
confint(dm_boot)


</code></pre>

<hr>
<h2 id='do_boot'>Bootstrap Estimates for
'indirect_effects' and
'cond_indirect_effects'</h2><span id='topic+do_boot'></span>

<h3>Description</h3>

<p>Generate bootstrap
estimates to be used by
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>,
<code><a href="#topic+indirect_effect">indirect_effect()</a></code>, and
<code><a href="#topic+cond_indirect">cond_indirect()</a></code>,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_boot(
  fit,
  R = 100,
  seed = NULL,
  parallel = TRUE,
  ncores = max(parallel::detectCores(logical = FALSE) - 1, 1),
  make_cluster_args = list(),
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do_boot_+3A_fit">fit</code></td>
<td>
<p>Either (a) a list of <code>lm</code>
class objects, or the output of
<code><a href="#topic+lm2list">lm2list()</a></code> (i.e., an <code>lm_list</code>-class
object), or (b) the output of
<code><a href="lavaan.html#topic+sem">lavaan::sem()</a></code>.</p>
</td></tr>
<tr><td><code id="do_boot_+3A_r">R</code></td>
<td>
<p>The number of bootstrap
samples. Default is 100.</p>
</td></tr>
<tr><td><code id="do_boot_+3A_seed">seed</code></td>
<td>
<p>The seed for the
bootstrapping. Default is <code>NULL</code> and
seed is not set.</p>
</td></tr>
<tr><td><code id="do_boot_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Whether
parallel processing will be used.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="do_boot_+3A_ncores">ncores</code></td>
<td>
<p>Integer. The number of
CPU cores to use when <code>parallel</code> is
<code>TRUE</code>. Default is the number of
non-logical cores minus one (one
minimum). Will raise an error if
greater than the number of cores
detected by
<code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>. If
<code>ncores</code> is set, it will override
<code>make_cluster_args</code>.</p>
</td></tr>
<tr><td><code id="do_boot_+3A_make_cluster_args">make_cluster_args</code></td>
<td>
<p>A named list
of additional arguments to be passed
to <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>. For
advanced users. See
<code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code> for
details. Default is <code>list()</code>, no
additional arguments.</p>
</td></tr>
<tr><td><code id="do_boot_+3A_progress">progress</code></td>
<td>
<p>Logical. Display
progress or not. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It does nonparametric
bootstrapping to generate bootstrap
estimates of the parameter estimates
in a model fitted either by
<code><a href="lavaan.html#topic+sem">lavaan::sem()</a></code> or by a sequence of
calls to <code><a href="stats.html#topic+lm">lm()</a></code>. The stored estimates
can then be used by
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>,
<code><a href="#topic+indirect_effect">indirect_effect()</a></code>, and
<code><a href="#topic+cond_indirect">cond_indirect()</a></code> to form
bootstrapping confidence intervals.
</p>
<p>This approach removes the need to
repeat bootstrapping in each call to
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>,
<code><a href="#topic+indirect_effect">indirect_effect()</a></code>, and
<code><a href="#topic+cond_indirect">cond_indirect()</a></code>. It also ensures
that the same set of bootstrap
samples is used in all subsequent
analysis.
</p>
<p>It determines the type of the fit
object automatically and then calls
<code><a href="#topic+lm2boot_out">lm2boot_out()</a></code>, <code><a href="#topic+fit2boot_out">fit2boot_out()</a></code>, or
<code><a href="#topic+fit2boot_out_do_boot">fit2boot_out_do_boot()</a></code>.
</p>


<h3>Value</h3>

<p>A <code>boot_out</code>-class object
that can be used for the <code>boot_out</code>
argument of
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>,
<code><a href="#topic+indirect_effect">indirect_effect()</a></code>, and
<code><a href="#topic+cond_indirect">cond_indirect()</a></code> for forming
bootstrap confidence intervals. The
object is a list with the number of
elements equal to the number of
bootstrap samples. Each element is a
list of the parameter estimates and
sample variances and covariances of
the variables in each bootstrap
sample.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lm2boot_out">lm2boot_out()</a></code>,
<code><a href="#topic+fit2boot_out">fit2boot_out()</a></code>, and
<code><a href="#topic+fit2boot_out_do_boot">fit2boot_out_do_boot()</a></code>, which
implements the bootstrapping.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data_med_mod_ab1)
dat &lt;- data_med_mod_ab1
lm_m &lt;- lm(m ~ x*w + c1 + c2, dat)
lm_y &lt;- lm(y ~ m*w + x + c1 + c2, dat)
lm_out &lt;- lm2list(lm_m, lm_y)
# In real research, R should be 2000 or even 5000
# In real research, no need to set parallel and progress to FALSE
# Parallel processing is enabled by default and
# progress is displayed by default.
lm_boot_out &lt;- do_boot(lm_out, R = 50, seed = 1234,
                       parallel = FALSE,
                       progress = FALSE)
wlevels &lt;- mod_levels(w = "w", fit = lm_out)
wlevels
out &lt;- cond_indirect_effects(wlevels = wlevels,
                             x = "x",
                             y = "y",
                             m = "m",
                             fit = lm_out,
                             boot_ci = TRUE,
                             boot_out = lm_boot_out)
out

</code></pre>

<hr>
<h2 id='do_mc'>Monte Carlo Estimates for
'indirect_effects' and
'cond_indirect_effects'</h2><span id='topic+do_mc'></span><span id='topic+gen_mc_est'></span>

<h3>Description</h3>

<p>Generate Monte Carlo
estimates to be used by
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>,
<code><a href="#topic+indirect_effect">indirect_effect()</a></code>, and
<code><a href="#topic+cond_indirect">cond_indirect()</a></code>,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_mc(
  fit,
  R = 100,
  seed = NULL,
  parallel = TRUE,
  ncores = max(parallel::detectCores(logical = FALSE) - 1, 1),
  make_cluster_args = list(),
  progress = TRUE
)

gen_mc_est(fit, R = 100, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do_mc_+3A_fit">fit</code></td>
<td>
<p>The output of
<code><a href="lavaan.html#topic+sem">lavaan::sem()</a></code>.
It can also be
a <code>lavaan.mi</code> object
returned by
<code><a href="semTools.html#topic+runMI">semTools::runMI()</a></code> or
its wrapper, such as <code><a href="semTools.html#topic+runMI">semTools::sem.mi()</a></code>.
The output of
<code><a href="stats.html#topic+lm">stats::lm()</a></code> is not supported.</p>
</td></tr>
<tr><td><code id="do_mc_+3A_r">R</code></td>
<td>
<p>The number of replications.
Default is 100.</p>
</td></tr>
<tr><td><code id="do_mc_+3A_seed">seed</code></td>
<td>
<p>The seed for the
generating Monte Carlo estimates.
Default is <code>NULL</code> and seed is not set.</p>
</td></tr>
<tr><td><code id="do_mc_+3A_parallel">parallel</code></td>
<td>
<p>Not used. Kept
for compatibility with <code><a href="#topic+do_boot">do_boot()</a></code>.</p>
</td></tr>
<tr><td><code id="do_mc_+3A_ncores">ncores</code></td>
<td>
<p>Not used. Kept
for compatibility with <code><a href="#topic+do_boot">do_boot()</a></code>.</p>
</td></tr>
<tr><td><code id="do_mc_+3A_make_cluster_args">make_cluster_args</code></td>
<td>
<p>Not used. Kept
for compatibility with <code><a href="#topic+do_boot">do_boot()</a></code>.</p>
</td></tr>
<tr><td><code id="do_mc_+3A_progress">progress</code></td>
<td>
<p>Logical. Display
progress or not. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It uses the parameter
estimates and their variance-covariance
matrix to generate Monte Carlo
estimates of the parameter estimates
in a model fitted by
<code><a href="lavaan.html#topic+sem">lavaan::sem()</a></code>. The stored estimates
can then be used by
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>,
<code><a href="#topic+indirect_effect">indirect_effect()</a></code>, and
<code><a href="#topic+cond_indirect">cond_indirect()</a></code> to form
Monte Carlo confidence intervals.
</p>
<p>It also supports a model estimated
by multiple imputation using
<code><a href="semTools.html#topic+runMI">semTools::runMI()</a></code> or its wrapper,
such as <code><a href="semTools.html#topic+runMI">semTools::sem.mi()</a></code>.
The pooled estimates and their
variance-covariance matrix will be used
to generate the Monte Carlo estimates.
</p>
<p>This approach removes the need to
repeat Monte Carlo simulation in
each call to
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>,
<code><a href="#topic+indirect_effect">indirect_effect()</a></code>, and
<code><a href="#topic+cond_indirect">cond_indirect()</a></code>. It also ensures
that the same set of Monte Carlo
estimates is used in all subsequent
analysis.
</p>


<h3>Value</h3>

<p>A <code>mc_out</code>-class object
that can be used for the <code>mc_out</code>
argument of
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>,
<code><a href="#topic+indirect_effect">indirect_effect()</a></code>, and
<code><a href="#topic+cond_indirect">cond_indirect()</a></code> for forming
Monte Carlo confidence intervals. The
object is a list with the number of
elements equal to the number of
Monte Carlo replications. Each element
is a
list of the parameter estimates and
sample variances and covariances of
the variables in each Monte Carlo
replication.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>do_mc()</code>: A general purpose function for
creating Monte Carlo estimates to be reused
by other functions. It returns a
<code>mc_out</code>-class object.
</p>
</li>
<li> <p><code>gen_mc_est()</code>: Generate Monte Carlo
estimates and store them in the <code>external</code>
slot: <code>external$manymome$mc</code>. For advanced
users.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+fit2mc_out">fit2mc_out()</a></code>, which
implements the Monte Carlo simulation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)
data(data_med_mod_ab1)
dat &lt;- data_med_mod_ab1
mod &lt;-
"
m ~ x + w + x:w + c1 + c2
y ~ m + w + m:w + x + c1 + c2
"
fit &lt;- sem(mod, dat)
# In real research, R should be 5000 or even 10000
mc_out &lt;- do_mc(fit, R = 100, seed = 1234)
wlevels &lt;- mod_levels(w = "w", fit = fit)
wlevels
out &lt;- cond_indirect_effects(wlevels = wlevels,
                             x = "x",
                             y = "y",
                             m = "m",
                             fit = fit,
                             mc_ci = TRUE,
                             mc_out = mc_out)
out

</code></pre>

<hr>
<h2 id='factor2var'>Create Dummy Variables</h2><span id='topic+factor2var'></span>

<h3>Description</h3>

<p>Create dummy variables
from a categorical variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factor2var(
  x_value,
  x_contrasts = "contr.treatment",
  prefix = "",
  add_rownames = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factor2var_+3A_x_value">x_value</code></td>
<td>
<p>The vector of
categorical variable.</p>
</td></tr>
<tr><td><code id="factor2var_+3A_x_contrasts">x_contrasts</code></td>
<td>
<p>The contrast to be
used. Default is
<code>"constr.treatment"</code>.</p>
</td></tr>
<tr><td><code id="factor2var_+3A_prefix">prefix</code></td>
<td>
<p>The prefix to be added
to the variables to be created.
Default is <code>""</code>.</p>
</td></tr>
<tr><td><code id="factor2var_+3A_add_rownames">add_rownames</code></td>
<td>
<p>Whether row names
will be added to the output. Default
is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Its main use is for creating
dummy variables (indicator variables)
from a categorical variable, to be
used in <code><a href="lavaan.html#topic+sem">lavaan::sem()</a></code>.
</p>
<p>Optionally, the other contrasts can
be used through the argument
<code>x_contrasts</code>.
</p>


<h3>Value</h3>

<p>It always returns a matrix
with the number of rows equal to the
length of the vector (<code>x_value</code>). If
the categorical has only two
categories and so only one dummy
variable is needed, the output is
still a one-column &quot;matrix&quot; in R.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- data_mod_cat
dat &lt;- data.frame(dat,
                  factor2var(dat$w, prefix = "gp", add_rownames = FALSE))
head(dat[, c("w", "gpgroup2", "gpgroup3")], 15)

</code></pre>

<hr>
<h2 id='fit2boot_out'>Bootstrap Estimates for a
<code>lavaan</code> Output</h2><span id='topic+fit2boot_out'></span><span id='topic+fit2boot_out_do_boot'></span>

<h3>Description</h3>

<p>Generate bootstrap
estimates from the output of
<code><a href="lavaan.html#topic+sem">lavaan::sem()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit2boot_out(fit)

fit2boot_out_do_boot(
  fit,
  R = 100,
  seed = NULL,
  parallel = FALSE,
  ncores = max(parallel::detectCores(logical = FALSE) - 1, 1),
  make_cluster_args = list(),
  progress = TRUE,
  internal = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit2boot_out_+3A_fit">fit</code></td>
<td>
<p>The fit object. This
function only supports a
<a href="lavaan.html#topic+lavaan-class">lavaan::lavaan</a> object.</p>
</td></tr>
<tr><td><code id="fit2boot_out_+3A_r">R</code></td>
<td>
<p>The number of bootstrap
samples. Default is 100.</p>
</td></tr>
<tr><td><code id="fit2boot_out_+3A_seed">seed</code></td>
<td>
<p>The seed for the random
resampling. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="fit2boot_out_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Whether
parallel processing will be used.
Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="fit2boot_out_+3A_ncores">ncores</code></td>
<td>
<p>Integer. The number of
CPU cores to use when <code>parallel</code> is
<code>TRUE</code>. Default is the number of
non-logical cores minus one (one
minimum). Will raise an error if
greater than the number of cores
detected by
<code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>. If
<code>ncores</code> is set, it will override
<code>make_cluster_args</code>.</p>
</td></tr>
<tr><td><code id="fit2boot_out_+3A_make_cluster_args">make_cluster_args</code></td>
<td>
<p>A named list
of additional arguments to be passed
to <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>. For
advanced users. See
<code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code> for
details. Default is <code>list()</code>.</p>
</td></tr>
<tr><td><code id="fit2boot_out_+3A_progress">progress</code></td>
<td>
<p>Logical. Display
progress or not. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fit2boot_out_+3A_internal">internal</code></td>
<td>
<p>A list of arguments
to be used internally for debugging.
Default is <code>list()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is for
advanced users. <code><a href="#topic+do_boot">do_boot()</a></code> is a
function users should try first
because <code><a href="#topic+do_boot">do_boot()</a></code> has a general
interface for input-specific
functions like this one.
</p>
<p>If bootstrapping confidence intervals
was requested when calling
<code><a href="lavaan.html#topic+sem">lavaan::sem()</a></code> by setting <code>se = "boot"</code>, <code><a href="#topic+fit2boot_out">fit2boot_out()</a></code> can be used
to extract the stored bootstrap
estimates so that they can be reused
by <code><a href="#topic+indirect_effect">indirect_effect()</a></code>,
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code> and related
functions to form bootstrapping
confidence intervals for effects such
as indirect effects and conditional
indirect effects.
</p>
<p>If bootstrapping confidence was not
requested when fitting the model by
<code><a href="lavaan.html#topic+sem">lavaan::sem()</a></code>,
<code><a href="#topic+fit2boot_out_do_boot">fit2boot_out_do_boot()</a></code> can be used
to generate nonparametric bootstrap
estimates from the output of
<code><a href="lavaan.html#topic+sem">lavaan::sem()</a></code> and store them for
use by <code><a href="#topic+indirect_effect">indirect_effect()</a></code>,
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>, and
related functions.
</p>
<p>This approach removes the need to
repeat bootstrapping in each call to
<code><a href="#topic+indirect_effect">indirect_effect()</a></code>,
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>, and
related functions. It also ensures
that the same set of bootstrap
samples is used in all subsequent
analyses.
</p>


<h3>Value</h3>

<p>A <code>boot_out</code>-class object
that can be used for the <code>boot_out</code>
argument of <code><a href="#topic+indirect_effect">indirect_effect()</a></code>,
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>, and
related functions for forming
bootstrapping confidence intervals.
</p>
<p>The object is a list with the number
of elements equal to the number of
bootstrap samples. Each element is a
list of the parameter estimates and
sample variances and covariances of
the variables in each bootstrap
sample.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fit2boot_out()</code>: Process
stored bootstrap estimates for
functions such as
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>.
</p>
</li>
<li> <p><code>fit2boot_out_do_boot()</code>: Do
bootstrapping and store information
to be used by
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code> and related
functions. Support parallel
processing.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+do_boot">do_boot()</a></code>, the general
purpose function that users should
try first before using this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)
data(data_med_mod_ab1)
dat &lt;- data_med_mod_ab1
dat$"x:w" &lt;- dat$x * dat$w
dat$"m:w" &lt;- dat$m * dat$w
mod &lt;-
"
m ~ x + w + x:w + c1 + c2
y ~ m + w + m:w + x + c1 + c2
"

# Bootstrapping not requested in calling lavaan::sem()
fit &lt;- sem(model = mod, data = dat, fixed.x = FALSE,
           se = "none", baseline = FALSE)
fit_boot_out &lt;- fit2boot_out_do_boot(fit = fit,
                                     R = 40,
                                     seed = 1234,
                                     progress = FALSE)
out &lt;- cond_indirect_effects(wlevels = "w",
                             x = "x",
                             y = "y",
                             m = "m",
                             fit = fit,
                             boot_ci = TRUE,
                             boot_out = fit_boot_out)
out

</code></pre>

<hr>
<h2 id='fit2mc_out'>Monte Carlo Estimates for a
<code>lavaan</code> Output</h2><span id='topic+fit2mc_out'></span>

<h3>Description</h3>

<p>Generate Monte Carlo
estimates from the output of
<code><a href="lavaan.html#topic+sem">lavaan::sem()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit2mc_out(fit, progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit2mc_out_+3A_fit">fit</code></td>
<td>
<p>The fit object. This
function only supports a
<a href="lavaan.html#topic+lavaan-class">lavaan::lavaan</a> object.
It can also be
a <code>lavaan.mi</code> object
returned by
<code><a href="semTools.html#topic+runMI">semTools::runMI()</a></code> or
its wrapper, such as <code><a href="semTools.html#topic+runMI">semTools::sem.mi()</a></code>.</p>
</td></tr>
<tr><td><code id="fit2mc_out_+3A_progress">progress</code></td>
<td>
<p>Logical. Display
progress or not. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is for
advanced users. <code><a href="#topic+do_mc">do_mc()</a></code> is a
function users should try first
because <code><a href="#topic+do_mc">do_mc()</a></code> has a general
interface for input-specific
functions like this one.
</p>
<p><code><a href="#topic+fit2mc_out">fit2mc_out()</a></code> can be used
to extract the stored Monte Carlo
estimates so that they can be reused
by <code><a href="#topic+indirect_effect">indirect_effect()</a></code>,
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code> and related
functions to form Monte Carlo
confidence intervals for effects such
as indirect effects and conditional
indirect effects.
</p>
<p>This approach removes the need to
repeat Monte Carlo simulation in each
call to
<code><a href="#topic+indirect_effect">indirect_effect()</a></code>,
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>, and
related functions. It also ensures
that the same set of Monte Carlo
estimates is used in all subsequent
analyses.
</p>


<h3>Value</h3>

<p>A <code>mc_out</code>-class object
that can be used for the <code>mc_out</code>
argument of <code><a href="#topic+indirect_effect">indirect_effect()</a></code>,
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>, and
related functions for forming
Monte Carlo confidence intervals.
</p>
<p>The object is a list with the number
of elements equal to the number of
Monte Carlo replications. Each element
is a
list of the parameter estimates and
sample variances and covariances of
the variables in each Monte Carlo
replication.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+do_mc">do_mc()</a></code>, the general
purpose function that users should
try first before using this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)
data(data_med_mod_ab1)
dat &lt;- data_med_mod_ab1
dat$"x:w" &lt;- dat$x * dat$w
dat$"m:w" &lt;- dat$m * dat$w
mod &lt;-
"
m ~ x + w + x:w + c1 + c2
y ~ m + w + m:w + x + c1 + c2
"

fit &lt;- sem(model = mod, data = dat, fixed.x = FALSE,
           baseline = FALSE)
# In real research, R should be 5000 or even 10000.
fit &lt;- gen_mc_est(fit, R = 100, seed = 453253)
fit_mc_out &lt;- fit2mc_out(fit)
out &lt;- cond_indirect_effects(wlevels = "w",
                             x = "x",
                             y = "y",
                             m = "m",
                             fit = fit,
                             mc_ci = TRUE,
                             mc_out = fit_mc_out)
out

</code></pre>

<hr>
<h2 id='get_one_cond_indirect_effect'>Get The Conditional Indirect
Effect for One Row of
'cond_indirect_effects' Output</h2><span id='topic+get_one_cond_indirect_effect'></span><span id='topic+get_one_cond_effect'></span>

<h3>Description</h3>

<p>Return the conditional
indirect effect of one row of the
output of <code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_one_cond_indirect_effect(object, row)

get_one_cond_effect(object, row)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_one_cond_indirect_effect_+3A_object">object</code></td>
<td>
<p>The output of
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>.</p>
</td></tr>
<tr><td><code id="get_one_cond_indirect_effect_+3A_row">row</code></td>
<td>
<p>The row number of the row
to be retrieved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It just extracts the
corresponding output of
<code><a href="#topic+cond_indirect">cond_indirect()</a></code> from the requested
row.
</p>


<h3>Value</h3>

<p>An <code>indirect</code>-class object,
similar to the output of
<code><a href="#topic+indirect_effect">indirect_effect()</a></code> and
<code><a href="#topic+cond_indirect">cond_indirect()</a></code>. See
[indirect_effect)] and
<code><a href="#topic+cond_indirect">cond_indirect()</a></code> for details on
these classes.
</p>
<p>[indirect_effect)]: R:indirect_effect)
<code><a href="#topic+cond_indirect">cond_indirect()</a></code>: R:cond_indirect()
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>get_one_cond_effect()</code>: An alias
to <code><a href="#topic+get_one_cond_indirect_effect">get_one_cond_indirect_effect()</a></code>
</p>
</li></ul>


<h3>See Also</h3>

<p><a href="#topic+cond_indirect_effects">cond_indirect_effects</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)
dat &lt;- modmed_x1m3w4y1
mod &lt;-
"
m1 ~ x  + w1 + x:w1
m2 ~ m1
y  ~ m2 + x + w4 + m2:w4
"
fit &lt;- sem(mod, dat,
           meanstructure = TRUE, fixed.x = FALSE,
           se = "none", baseline = FALSE)
est &lt;- parameterEstimates(fit)

# Examples for cond_indirect():

# Conditional effects from x to m1
# when w1 is equal to each of the default levels
out1 &lt;- cond_indirect_effects(x = "x", y = "m1",
                              wlevels = c("w1", "w4"), fit = fit)
get_one_cond_indirect_effect(out1, 3)

# Conditional Indirect effect from x1 through m1 to y,
# when w1 is equal to each of the levels
out2 &lt;- cond_indirect_effects(x = "x", y = "y", m = c("m1", "m2"),
                              wlevels = c("w1", "w4"), fit = fit)
get_one_cond_indirect_effect(out2, 4)

</code></pre>

<hr>
<h2 id='get_prod'>Product Terms (if Any)
Along a Path</h2><span id='topic+get_prod'></span>

<h3>Description</h3>

<p>Identify the product
term(s), if any, along a path in
a model and return the term(s),
with the variables involved and
the coefficient(s) of the term(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_prod(
  x,
  y,
  operator = ":",
  fit = NULL,
  est = NULL,
  data = NULL,
  expand = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_prod_+3A_x">x</code></td>
<td>
<p>Character. Variable name.</p>
</td></tr>
<tr><td><code id="get_prod_+3A_y">y</code></td>
<td>
<p>Character. Variable name.</p>
</td></tr>
<tr><td><code id="get_prod_+3A_operator">operator</code></td>
<td>
<p>Character. The string
used to indicate a product term.
Default is <code>":"</code>, used in both <code><a href="stats.html#topic+lm">lm()</a></code>
and <code><a href="lavaan.html#topic+sem">lavaan::sem()</a></code> for observed
variables.</p>
</td></tr>
<tr><td><code id="get_prod_+3A_fit">fit</code></td>
<td>
<p>The fit object. Currently
only supports a
<a href="lavaan.html#topic+lavaan-class">lavaan::lavaan</a> object.
It can also be
a <code>lavaan.mi</code> object
returned by
<code><a href="semTools.html#topic+runMI">semTools::runMI()</a></code> or
its wrapper, such as <code><a href="semTools.html#topic+runMI">semTools::sem.mi()</a></code>.</p>
</td></tr>
<tr><td><code id="get_prod_+3A_est">est</code></td>
<td>
<p>The output of
<code><a href="lavaan.html#topic+parameterEstimates">lavaan::parameterEstimates()</a></code>. If
<code>NULL</code>, the default, it will be
generated from <code>fit</code>. If supplied,
<code>fit</code> will ge ignored.</p>
</td></tr>
<tr><td><code id="get_prod_+3A_data">data</code></td>
<td>
<p>Data frame (optional). If
supplied, it will be used to identify
the product terms.</p>
</td></tr>
<tr><td><code id="get_prod_+3A_expand">expand</code></td>
<td>
<p>Whether products of
more than two terms will be searched.
<code>FALSE</code> by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used
by several functions in <code>manymome</code>
to identify product terms along
a path. If possible, this is done
by numerically checking whether a
column in a dataset is the product
of two other columns. If not possible
(e.g., the &quot;product term&quot; is the
&quot;product&quot; of two latent variables,
formed by the products of indicators),
then it requires the user to specify
an operator.
</p>
<p>The detailed workflow of this function
can be found in the
article <a href="https://sfcheung.github.io/manymome/articles/get_prod.html">https://sfcheung.github.io/manymome/articles/get_prod.html</a>
</p>
<p>This function is not intended to be used
by users. It is exported such that
advanced users or developers can use
it.
</p>


<h3>Value</h3>

<p>If at least one product term is found,
it returns a list with these elements:
</p>

<ul>
<li> <p><code>prod</code>: The names of the product terms
found.
</p>
</li>
<li> <p><code>b</code>: The coefficients of these
product terms.
</p>
</li>
<li> <p><code>w</code>: The variable, other than
<code>x</code>, in each product term.
</p>
</li>
<li> <p><code>x</code>: The <code>x</code>-variable, that is,
where the path starts.
</p>
</li>
<li> <p><code>y</code>: The <code>y</code>-variable, that is,
where the path ends.
</p>
</li></ul>

<p>It returns <code>NA</code> if no product term
is found along the path.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- modmed_x1m3w4y1
library(lavaan)
mod &lt;-
"
m1 ~ x   + w1 + x:w1
m2 ~ m1  + w2 + m1:w2
m3 ~ m2
y  ~ m3  + w4 + m3:w4 + x + w3 + x:w3 + x:w4
"
fit &lt;- sem(model = mod,
           data = dat,
           meanstructure = TRUE,
           fixed.x = FALSE)

# One product term
get_prod(x = "x", y = "m1", fit = fit)
# Two product terms
get_prod(x = "x", y = "y", fit = fit)
# No product term
get_prod(x = "m2", y = "m3", fit = fit)

</code></pre>

<hr>
<h2 id='index_of_mome'>Index of Moderated Mediation
and Index of Moderated Moderated
Mediation</h2><span id='topic+index_of_mome'></span><span id='topic+index_of_momome'></span>

<h3>Description</h3>

<p>It computes the index of
moderated mediation and the index of
moderated moderated mediation
proposed by Hayes (2015, 2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index_of_mome(
  x,
  y,
  m = NULL,
  w = NULL,
  fit = NULL,
  boot_ci = FALSE,
  level = 0.95,
  boot_out = NULL,
  R = 100,
  seed = NULL,
  progress = TRUE,
  mc_ci = FALSE,
  mc_out = NULL,
  ci_type = NULL,
  ci_out = NULL,
  ...
)

index_of_momome(
  x,
  y,
  m = NULL,
  w = NULL,
  z = NULL,
  fit = NULL,
  boot_ci = FALSE,
  level = 0.95,
  boot_out = NULL,
  R = 100,
  seed = NULL,
  progress = TRUE,
  mc_ci = FALSE,
  mc_out = NULL,
  ci_type = NULL,
  ci_out = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index_of_mome_+3A_x">x</code></td>
<td>
<p>Character. The name of the
predictor at the start of the path.</p>
</td></tr>
<tr><td><code id="index_of_mome_+3A_y">y</code></td>
<td>
<p>Character. The name of the
outcome variable at the end of the
path.</p>
</td></tr>
<tr><td><code id="index_of_mome_+3A_m">m</code></td>
<td>
<p>A vector of the variable
names of the mediator(s). The path
goes from the first mediator
successively to the last mediator. If
<code>NULL</code>, the default, the path goes
from <code>x</code> to <code>y</code>.</p>
</td></tr>
<tr><td><code id="index_of_mome_+3A_w">w</code></td>
<td>
<p>Character. The name of the
moderator.</p>
</td></tr>
<tr><td><code id="index_of_mome_+3A_fit">fit</code></td>
<td>
<p>The fit object. Can be a
<a href="lavaan.html#topic+lavaan-class">lavaan::lavaan</a> object, a list
of <code><a href="stats.html#topic+lm">lm()</a></code> outputs, or an object
created by <code><a href="#topic+lm2list">lm2list()</a></code>.
It can also be
a <code>lavaan.mi</code> object
returned by
<code><a href="semTools.html#topic+runMI">semTools::runMI()</a></code> or
its wrapper, such as <code><a href="semTools.html#topic+runMI">semTools::sem.mi()</a></code>.</p>
</td></tr>
<tr><td><code id="index_of_mome_+3A_boot_ci">boot_ci</code></td>
<td>
<p>Logical. Whether
bootstrap confidence interval will be
formed. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="index_of_mome_+3A_level">level</code></td>
<td>
<p>The level of confidence
for the bootstrap confidence
interval. Default is .95.</p>
</td></tr>
<tr><td><code id="index_of_mome_+3A_boot_out">boot_out</code></td>
<td>
<p>If <code>boot_ci</code> is
<code>TRUE</code>, users can supply pregenerated
bootstrap estimates. This can be the
output of <code><a href="#topic+do_boot">do_boot()</a></code>. For
<code><a href="#topic+indirect_effect">indirect_effect()</a></code> and
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>, this can
be the output of a previous call to
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>,
<code><a href="#topic+indirect_effect">indirect_effect()</a></code>, or
<code><a href="#topic+cond_indirect">cond_indirect()</a></code> with bootstrap
confidence intervals requested. These
stored estimates will be reused such
that there is no need to do
bootstrapping again. If not supplied,
the function will try to generate
them from <code>fit</code>.</p>
</td></tr>
<tr><td><code id="index_of_mome_+3A_r">R</code></td>
<td>
<p>Integer. If <code>boot_ci</code> is
<code>TRUE</code>, <code>boot_out</code> is <code>NULL</code>, and
bootstrap standard errors not
requested if <code>fit</code> is a
<a href="lavaan.html#topic+lavaan-class">lavaan</a> object, this function
will do bootstrapping on <code>fit</code>. <code>R</code>
is the number of bootstrap samples.
Default is 100. For Monte Carlo
simulation, this is the number
of replications.</p>
</td></tr>
<tr><td><code id="index_of_mome_+3A_seed">seed</code></td>
<td>
<p>If bootstrapping
or Monte Carlo simulation is
conducted, this is the seed for the
bootstrapping or simulation.
Default is <code>NULL</code> and
seed is not set.</p>
</td></tr>
<tr><td><code id="index_of_mome_+3A_progress">progress</code></td>
<td>
<p>Logical. Display
bootstrapping progress or not.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="index_of_mome_+3A_mc_ci">mc_ci</code></td>
<td>
<p>Logical. Whether
Monte Carlo confidence interval will be
formed. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="index_of_mome_+3A_mc_out">mc_out</code></td>
<td>
<p>If <code>mc_ci</code> is
<code>TRUE</code>, users can supply pregenerated
Monte Carlo estimates. This can be the
output of <code><a href="#topic+do_mc">do_mc()</a></code>. For
<code><a href="#topic+indirect_effect">indirect_effect()</a></code> and
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>, this can
be the output of a previous call to
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>,
<code><a href="#topic+indirect_effect">indirect_effect()</a></code>, or
<code><a href="#topic+cond_indirect">cond_indirect()</a></code> with Monte Carlo
confidence intervals requested. These
stored estimates will be reused such
that there is no need to do
Monte Carlo simulation again. If not
supplied,
the function will try to generate
them from <code>fit</code>.</p>
</td></tr>
<tr><td><code id="index_of_mome_+3A_ci_type">ci_type</code></td>
<td>
<p>The type of
confidence intervals to be formed.
Can be either <code>"boot"</code> (bootstrapping)
or <code>"mc"</code> (Monte Carlo). If not
supplied or is <code>NULL</code>, will check
other arguments
(e.g, <code>boot_ci</code> and <code>mc_ci</code>). If
supplied, will override <code>boot_ci</code>
and <code>mc_ci</code>.</p>
</td></tr>
<tr><td><code id="index_of_mome_+3A_ci_out">ci_out</code></td>
<td>
<p>If <code>ci_type</code> is supplied,
this is the corresponding argument.
If <code>ci_type</code> is <code>"boot"</code>, this
argument will be used as <code>boot_out</code>.
If <code>ci_type</code> is <code>"mc"</code>, this
argument will be used as <code>mc_out</code>.</p>
</td></tr>
<tr><td><code id="index_of_mome_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code></p>
</td></tr>
<tr><td><code id="index_of_mome_+3A_z">z</code></td>
<td>
<p>Character. The name of the
second moderator, for computing the
index of moderated moderated
mediation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function
<code><a href="#topic+index_of_mome">index_of_mome()</a></code> computes the <em>index
of moderated mediation</em> proposed by
Hayes (2015). It supports any path in
a model with one (and only one)
component path moderated. For
example, <code>x-&gt;m1-&gt;m2-&gt;y</code> with <code>x-&gt;m1</code>
moderated by <code>w</code>. It measures the
change in indirect effect when the
moderator increases by one unit.
</p>
<p>The function <code><a href="#topic+index_of_momome">index_of_momome()</a></code>
computes the <em>index of moderated
moderated mediation</em> proposed by
Hayes (2018). It supports any path in
a model, with two component paths
moderated, each by one moderator. For
example, <code>x-&gt;m1-&gt;m2-&gt;y</code> with <code>x-&gt;m1</code>
moderated by <code>w</code> and <code>m2-&gt;y</code>
moderated by <code>z</code>. It measures the
change in the index of moderated
mediation of one moderator when the
other moderator increases by one
unit.
</p>


<h3>Value</h3>

<p>It returns a
<code>cond_indirect_diff</code>-class object.
This class has a <code>print</code> method
(<code><a href="#topic+print.cond_indirect_diff">print.cond_indirect_diff()</a></code>), a
<code>coef</code> method for extracting the
index (<code><a href="#topic+coef.cond_indirect_diff">coef.cond_indirect_diff()</a></code>),
and a <code>confint</code> method for extracting
the confidence interval if
available
(<code><a href="#topic+confint.cond_indirect_diff">confint.cond_indirect_diff()</a></code>).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>index_of_mome()</code>: Compute the
index of moderated mediation.
</p>
</li>
<li> <p><code>index_of_momome()</code>: Compute the
index of moderated moderated
mediation.
</p>
</li></ul>


<h3>References</h3>

<p>Hayes, A. F. (2015). An index and test of linear moderated mediation.
<em>Multivariate Behavioral Research, 50</em>(1), 1-22.
<a href="https://doi.org/10.1080/00273171.2014.962683">doi:10.1080/00273171.2014.962683</a>
</p>
<p>Hayes, A. F. (2018). Partial, conditional, and moderated moderated
mediation: Quantification, inference, and interpretation.
<em>Communication Monographs, 85</em>(1), 4-40.
<a href="https://doi.org/10.1080/03637751.2017.1352100">doi:10.1080/03637751.2017.1352100</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)
dat &lt;- modmed_x1m3w4y1
dat$xw1 &lt;- dat$x * dat$w1
mod &lt;-
"
m1 ~ a * x  + f * w1 + d * xw1
y  ~ b * m1 + cp * x
ind_mome := d * b
"
fit &lt;- sem(mod, dat,
           meanstructure = TRUE, fixed.x = FALSE,
           se = "none", baseline = FALSE)
est &lt;- parameterEstimates(fit)

# R should be at least 2000 or even 5000 in real research.
# parallel is set to TRUE by default.
# Therefore, in research, the argument parallel can be omitted.
out_mome &lt;- index_of_mome(x = "x", y = "y", m = "m1", w = "w1",
                          fit = fit,
                          boot_ci = TRUE,
                          R = 42,
                          seed = 4314,
                          parallel = FALSE,
                          progress = FALSE)
out_mome
coef(out_mome)
# From lavaan
print(est[19, ], nd = 8)
confint(out_mome)



library(lavaan)
dat &lt;- modmed_x1m3w4y1
dat$xw1 &lt;- dat$x * dat$w1
dat$m1w4 &lt;- dat$m1 * dat$w4
mod &lt;-
"
m1 ~ a * x  + f1 * w1 + d1 * xw1
y  ~ b * m1 + f4 * w4 + d4 * m1w4 + cp * x
ind_momome := d1 * d4
"
fit &lt;- sem(mod, dat,
           meanstructure = TRUE, fixed.x = FALSE,
           se = "none", baseline = FALSE)
est &lt;- parameterEstimates(fit)

# See the example of index_of_mome on how to request
# bootstrap confidence interval.
out_momome &lt;- index_of_momome(x = "x", y = "y", m = "m1",
                              w = "w1", z = "w4",
                              fit = fit)
out_momome
coef(out_momome)
print(est[32, ], nd = 8)

</code></pre>

<hr>
<h2 id='indirect_effects_from_list'>Coefficient Table of an 'indirect_list' Class
Object</h2><span id='topic+indirect_effects_from_list'></span>

<h3>Description</h3>

<p>Create a coefficient table
for the point estimates and
confidence intervals (if available)
in the
output of <code><a href="#topic+many_indirect_effects">many_indirect_effects()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indirect_effects_from_list(object, add_sig = TRUE, pvalue = FALSE, se = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indirect_effects_from_list_+3A_object">object</code></td>
<td>
<p>The output of
<code><a href="#topic+indirect_effect">indirect_effect()</a></code> or
<code><a href="#topic+cond_indirect">cond_indirect()</a></code>.</p>
</td></tr>
<tr><td><code id="indirect_effects_from_list_+3A_add_sig">add_sig</code></td>
<td>
<p>Whether a column
of significance test results
will be added. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="indirect_effects_from_list_+3A_pvalue">pvalue</code></td>
<td>
<p>Logical. If <code>TRUE</code>,
asymmetric <em>p</em>-values based on
bootstrapping will be added
available. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="indirect_effects_from_list_+3A_se">se</code></td>
<td>
<p>Logical. If <code>TRUE</code> and
confidence intervals are available,
the standard errors of the estimates
are also added. They are simply the
standard deviations of the bootstrap
estimates or Monte Carlo simulated
values, depending on the method used
to form the confidence intervals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If bootstrapping confidence interval
was requested, this method has the
option to add
<em>p</em>-values computed by the
method presented in Asparouhov and Muthn (2021).
Note that these <em>p</em>-values is asymmetric
bootstrap <em>p</em>-values based on the
distribution of the bootstrap estimates.
They are not computed based on the
distribution under the null hypothesis.
</p>
<p>For a <em>p</em>-value of <em>a</em>, it means that
a 100(1 - <em>a</em>)% bootstrapping confidence
interval
will have one of its limits equal to
0. A confidence interval
with a higher confidence level will
include zero, while a confidence
interval with a lower confidence level
will exclude zero.
</p>


<h3>Value</h3>

<p>A data frame with the
indirect effect estimates and
confidence intervals (if available).
It also has A string column, <code>"Sig"</code>,
for #' significant test results
if <code>add_sig</code> is <code>TRUE</code> and
confidence intervals are available.
</p>


<h3>References</h3>

<p>Asparouhov, A., &amp; Muthn, B. (2021). Bootstrap p-value computation.
Retrieved from https://www.statmodel.com/download/FAQ-Bootstrap%20-%20Pvalue.pdf
</p>


<h3>See Also</h3>

<p><code><a href="#topic+many_indirect_effects">many_indirect_effects()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)
data(data_serial_parallel)
mod &lt;-
"
m11 ~ x + c1 + c2
m12 ~ m11 + x + c1 + c2
m2 ~ x + c1 + c2
y ~ m12 + m2 + m11 + x + c1 + c2
"
fit &lt;- sem(mod, data_serial_parallel,
           fixed.x = FALSE)

# All indirect paths from x to y
paths &lt;- all_indirect_paths(fit,
                           x = "x",
                           y = "y")
paths

# Indirect effect estimates
out &lt;- many_indirect_effects(paths,
                             fit = fit)
out

# Create a data frame of the indirect effect estimates

out_df &lt;- indirect_effects_from_list(out)
out_df


</code></pre>

<hr>
<h2 id='indirect_i'>Indirect Effect (No
Bootstrapping)</h2><span id='topic+indirect_i'></span>

<h3>Description</h3>

<p>It computes an indirect
effect, optionally conditional on the
value(s) of moderator(s) if present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indirect_i(
  x,
  y,
  m = NULL,
  fit = NULL,
  est = NULL,
  implied_stats = NULL,
  wvalues = NULL,
  standardized_x = FALSE,
  standardized_y = FALSE,
  computation_digits = 5,
  prods = NULL,
  get_prods_only = FALSE,
  data = NULL,
  expand = TRUE,
  warn = TRUE,
  allow_mixing_lav_and_obs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indirect_i_+3A_x">x</code></td>
<td>
<p>Character. The name of the
predictor at the start of the path.</p>
</td></tr>
<tr><td><code id="indirect_i_+3A_y">y</code></td>
<td>
<p>Character. The name of the
outcome variable at the end of the
path.</p>
</td></tr>
<tr><td><code id="indirect_i_+3A_m">m</code></td>
<td>
<p>A vector of the variable
names of the mediator(s). The path
goes from the first mediator
successively to the last mediator. If
<code>NULL</code>, the default, the path goes
from <code>x</code> to <code>y</code>.</p>
</td></tr>
<tr><td><code id="indirect_i_+3A_fit">fit</code></td>
<td>
<p>The fit object. Currently
only supports <a href="lavaan.html#topic+lavaan-class">lavaan::lavaan</a>
objects. Support for lists of <code><a href="stats.html#topic+lm">lm()</a></code>
output is implemented by high level
functions such as <code><a href="#topic+indirect_effect">indirect_effect()</a></code>
and <code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>.
It can also be
a <code>lavaan.mi</code> object
returned by
<code><a href="semTools.html#topic+runMI">semTools::runMI()</a></code> or
its wrapper, such as <code><a href="semTools.html#topic+runMI">semTools::sem.mi()</a></code>.</p>
</td></tr>
<tr><td><code id="indirect_i_+3A_est">est</code></td>
<td>
<p>The output of
<code><a href="lavaan.html#topic+parameterEstimates">lavaan::parameterEstimates()</a></code>. If
<code>NULL</code>, the default, it will be
generated from <code>fit</code>. If supplied,
<code>fit</code> will be ignored.</p>
</td></tr>
<tr><td><code id="indirect_i_+3A_implied_stats">implied_stats</code></td>
<td>
<p>Implied means,
variances, and covariances of
observed variables and latent
variables (if any), of the form of
the output of <code><a href="lavaan.html#topic+lavInspect">lavaan::lavInspect()</a></code>
with <code>what</code> set to <code>"implied"</code>, but
with means extracted with <code>what</code> set
to <code>"mean.ov"</code> and <code>"mean.lv"</code>. The
standard deviations are extracted
from this object for standardization.
Default is <code>NULL</code>, and implied
statistics will be computed from
<code>fit</code> if required.</p>
</td></tr>
<tr><td><code id="indirect_i_+3A_wvalues">wvalues</code></td>
<td>
<p>A numeric vector of
named elements. The names are the
variable names of the moderators, and
the values are the values to which
the moderators will be set to.
Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="indirect_i_+3A_standardized_x">standardized_x</code></td>
<td>
<p>Logical.
Whether <code>x</code> will be standardized.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="indirect_i_+3A_standardized_y">standardized_y</code></td>
<td>
<p>Logical.
Whether <code>y</code> will be standardized.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="indirect_i_+3A_computation_digits">computation_digits</code></td>
<td>
<p>The number
of digits in storing the computation
in text. Default is 3.</p>
</td></tr>
<tr><td><code id="indirect_i_+3A_prods">prods</code></td>
<td>
<p>The product terms found.
For internal use.</p>
</td></tr>
<tr><td><code id="indirect_i_+3A_get_prods_only">get_prods_only</code></td>
<td>
<p>IF <code>TRUE</code>, will
quit early and return the product
terms found. The results can be
passed to the <code>prod</code> argument when
calling this function. Default is
<code>FALSE</code>. For internal use.</p>
</td></tr>
<tr><td><code id="indirect_i_+3A_data">data</code></td>
<td>
<p>Data frame (optional). If
supplied, it will be used to identify
the product terms. For internal use.</p>
</td></tr>
<tr><td><code id="indirect_i_+3A_expand">expand</code></td>
<td>
<p>Whether products of
more than two terms will be searched.
<code>TRUE</code> by default. For internal use.</p>
</td></tr>
<tr><td><code id="indirect_i_+3A_warn">warn</code></td>
<td>
<p>If <code>TRUE</code>, the default,
the function will warn against
possible misspecification, such as
not setting the value of a moderator
which moderate one of the component
path. Set this to <code>FALSE</code> will
suppress these warnings. Suppress
them only when the moderators are
omitted intentionally.</p>
</td></tr>
<tr><td><code id="indirect_i_+3A_allow_mixing_lav_and_obs">allow_mixing_lav_and_obs</code></td>
<td>
<p>If
<code>TRUE</code>, it accepts a path with both
latent variables and observed
variables. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a low-level
function called by
<code><a href="#topic+indirect_effect">indirect_effect()</a></code>,
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>, and
<code><a href="#topic+cond_indirect">cond_indirect()</a></code>, which call this
function multiple times if bootstrap
confidence interval is requested.
</p>
<p>This function usually should not be
used directly. It is exported for
advanced users and developers
</p>


<h3>Value</h3>

<p>It returns an
<code>indirect</code>-class object. This class
has the following methods:
<code><a href="#topic+coef.indirect">coef.indirect()</a></code>,
<code><a href="#topic+print.indirect">print.indirect()</a></code>. The
<code><a href="#topic+confint.indirect">confint.indirect()</a></code> method is used
only when called by <code><a href="#topic+cond_indirect">cond_indirect()</a></code>
or <code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+indirect_effect">indirect_effect()</a></code>,
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>, and
<code><a href="#topic+cond_indirect">cond_indirect()</a></code>, the high level
functions that should usually be
used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)
dat &lt;- modmed_x1m3w4y1
mod &lt;-
"
m1 ~ a1 * x   + b1 * w1 + d1 * x:w1
m2 ~ a2 * m1  + b2 * w2 + d2 * m1:w2
m3 ~ a3 * m2  + b3 * w3 + d3 * m2:w3
y  ~ a4 * m3  + b4 * w4 + d4 * m3:w4
"
fit &lt;- sem(mod, dat, meanstructure = TRUE,
           fixed.x = FALSE, se = "none", baseline = FALSE)
est &lt;- parameterEstimates(fit)

wvalues &lt;- c(w1 = 5, w2 = 4, w3 = 2, w4 = 3)

# Compute the conditional indirect effect by indirect_i()
indirect_1 &lt;- indirect_i(x = "x", y = "y", m = c("m1", "m2", "m3"), fit = fit,
                       wvalues = wvalues)

# Manually compute the conditional indirect effect
indirect_2 &lt;- (est[est$label == "a1", "est"] +
                wvalues["w1"] * est[est$label == "d1", "est"]) *
              (est[est$label == "a2", "est"] +
                wvalues["w2"] * est[est$label == "d2", "est"]) *
              (est[est$label == "a3", "est"] +
                wvalues["w3"] * est[est$label == "d3", "est"]) *
              (est[est$label == "a4", "est"] +
                wvalues["w4"] * est[est$label == "d4", "est"])
# They should be the same
coef(indirect_1)
indirect_2

</code></pre>

<hr>
<h2 id='indirect_proportion'>Proportion of Effect Mediated</h2><span id='topic+indirect_proportion'></span>

<h3>Description</h3>

<p>It computes the proportion
of effect mediated along a pathway.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indirect_proportion(x, y, m = NULL, fit = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indirect_proportion_+3A_x">x</code></td>
<td>
<p>The name of the <code>x</code> variable.
Must be supplied as a quoted string.</p>
</td></tr>
<tr><td><code id="indirect_proportion_+3A_y">y</code></td>
<td>
<p>The name of the <code>y</code> variable.
Must be supplied as a quoted string.</p>
</td></tr>
<tr><td><code id="indirect_proportion_+3A_m">m</code></td>
<td>
<p>A vector of the variable
names of the mediator(s). The path
goes from the first mediator
successively to the last mediator.
Cannot be <code>NULL</code> for this function.</p>
</td></tr>
<tr><td><code id="indirect_proportion_+3A_fit">fit</code></td>
<td>
<p>The fit object. Can be a
<a href="lavaan.html#topic+lavaan-class">lavaan::lavaan</a> object or a
list of <code><a href="stats.html#topic+lm">lm()</a></code> outputs.
It can also be
a <code>lavaan.mi</code> object
returned by
<code><a href="semTools.html#topic+runMI">semTools::runMI()</a></code> or
its wrapper, such as <code><a href="semTools.html#topic+runMI">semTools::sem.mi()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The proportion of effect
mediated along a path from <code>x</code> to
<code>y</code> is the indirect effect along
this path divided by the total
effect from <code>x</code> to <code>y</code>
(Alwin &amp; Hauser, 1975). This total
effect is equal to the sum of all
indirect effects from <code>x</code> to <code>y</code>
and the direct effect from <code>x</code> to
<code>y</code>.
</p>
<p>To ensure that the proportion can
indeed be interpreted as a proportion,
this function computes the the
proportion only if the signs of
all the indirect and direct effects
from <code>x</code> to <code>y</code>
are same (i.e., all effects
positive or all effects negative).
</p>


<h3>Value</h3>

<p>An <code>indirect_proportion</code> class object.
It is a list-like object with these
major elements:
</p>

<ul>
<li> <p><code>proportion</code>: The proportion of
effect mediated.
</p>
</li>
<li> <p><code>x</code>: The name of the <code>x</code>-variable.
</p>
</li>
<li> <p><code>y</code>: The name of the <code>y</code>-variable.
</p>
</li>
<li> <p><code>m</code>: A character vector of the
mediator(s) along a path. The path
runs from the first element to the
last element.
</p>
</li></ul>

<p>This class has a <code>print</code> method
and a <code>coef</code> method.
</p>


<h3>References</h3>

<p>Alwin, D. F., &amp; Hauser, R. M. (1975).
The decomposition of effects in path
analysis.
<em>American Sociological Review, 40</em>(1),
37. <a href="https://doi.org/10.2307/2094445">doi:10.2307/2094445</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.indirect_proportion">print.indirect_proportion()</a></code>
for the <code>print</code> method, and
<code><a href="#topic+coef.indirect_proportion">coef.indirect_proportion()</a></code> for
the <code>coef</code> method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)
dat &lt;- data_med
head(dat)
mod &lt;-
"
m ~ x + c1 + c2
y ~ m + x + c1 + c2
"
fit &lt;- sem(mod, dat, fixed.x = FALSE)
out &lt;- indirect_proportion(x = "x",
                           y = "y",
                           m = "m",
                           fit = fit)
out

</code></pre>

<hr>
<h2 id='lm_from_lavaan_list'>'lavaan'-class to
'lm_from_lavaan_list'-Class</h2><span id='topic+lm_from_lavaan_list'></span>

<h3>Description</h3>

<p>Converts the regression
models in a <code>lavaan</code>-class model to
an <code>lm_from_lavaan_list</code>-class
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm_from_lavaan_list(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm_from_lavaan_list_+3A_fit">fit</code></td>
<td>
<p>A <code>lavaan</code>-class object,
usually the output of
<code><a href="lavaan.html#topic+lavaan">lavaan::lavaan()</a></code> or its wrappers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It identifies all dependent
variables in a <code>lavaan</code> model and
creates an <code>lm_from_lavaan</code>-class
object for each of them.
</p>
<p>This is an advanced helper used by
<code><a href="#topic+plot.cond_indirect_effects">plot.cond_indirect_effects()</a></code>.
Exported for advanced users and
developers.
</p>


<h3>Value</h3>

<p>An
<code>lm_from_lavaan_list</code>-class object,
which is a list of <code>lm_from_lavaan</code>
objects. It has a <code>predict</code>-method
(<code><a href="#topic+predict.lm_from_lavaan_list">predict.lm_from_lavaan_list()</a></code>) for
computing the predicted values from
one variable to another.
</p>


<h3>See Also</h3>

<p><a href="#topic+predict.lm_from_lavaan_list">predict.lm_from_lavaan_list</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
data(data_med)
mod &lt;-
"
m ~ a * x + c1 + c2
y ~ b * m + x + c1 + c2
"
fit &lt;- sem(mod, data_med, fixed.x = FALSE)
fit_list &lt;- lm_from_lavaan_list(fit)
tmp &lt;- data.frame(x = 1, c1 = 2, c2 = 3, m = 4)
predict(fit_list, x = "x", y = "y", m = "m", newdata = tmp)

</code></pre>

<hr>
<h2 id='lm2boot_out'>Bootstrap Estimates for <code>lm</code>
Outputs</h2><span id='topic+lm2boot_out'></span><span id='topic+lm2boot_out_parallel'></span>

<h3>Description</h3>

<p>Generate bootstrap
estimates for models in a list of
'lm' outputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm2boot_out(outputs, R = 100, seed = NULL, progress = TRUE)

lm2boot_out_parallel(
  outputs,
  R = 100,
  seed = NULL,
  parallel = FALSE,
  ncores = max(parallel::detectCores(logical = FALSE) - 1, 1),
  make_cluster_args = list(),
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm2boot_out_+3A_outputs">outputs</code></td>
<td>
<p>A list of <code>lm</code> class
objects, or the output of <code><a href="#topic+lm2list">lm2list()</a></code>
(i.e., an <code>lm_list</code>-class object).</p>
</td></tr>
<tr><td><code id="lm2boot_out_+3A_r">R</code></td>
<td>
<p>The number of bootstrap
samples. Default is 100.</p>
</td></tr>
<tr><td><code id="lm2boot_out_+3A_seed">seed</code></td>
<td>
<p>The seed for the random
resampling. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="lm2boot_out_+3A_progress">progress</code></td>
<td>
<p>Logical. Display
progress or not. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="lm2boot_out_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Whether
parallel processing will be used.
Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="lm2boot_out_+3A_ncores">ncores</code></td>
<td>
<p>Integer. The number of
CPU cores to use when <code>parallel</code> is
<code>TRUE</code>. Default is the number of
non-logical cores minus one (one
minimum). Will raise an error if
greater than the number of cores
detected by
<code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>. If
<code>ncores</code> is set, it will override
<code>make_cluster_args</code>.</p>
</td></tr>
<tr><td><code id="lm2boot_out_+3A_make_cluster_args">make_cluster_args</code></td>
<td>
<p>A named list
of additional arguments to be passed
to <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>. For
advanced users. See
<code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code> for
details. Default is <code>list()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is for
advanced users. <code><a href="#topic+do_boot">do_boot()</a></code> is a
function users should try first
because <code><a href="#topic+do_boot">do_boot()</a></code> has a general
interface for input-specific
functions like this one.
</p>
<p>It does nonparametric bootstrapping
to generate bootstrap estimates of
the regression coefficients in the
regression models of a list of <code><a href="stats.html#topic+lm">lm()</a></code>
outputs, or an <code>lm_list</code>-class object
created by <code><a href="#topic+lm2list">lm2list()</a></code>. The stored
estimates can be used by
<code><a href="#topic+indirect_effect">indirect_effect()</a></code>,
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>, and
related functions in forming
bootstrapping confidence intervals
for effects such as indirect effect
and conditional indirect effects.
</p>
<p>This approach removes the need to
repeat bootstrapping in each call to
<code><a href="#topic+indirect_effect">indirect_effect()</a></code>,
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>, and
related functions. It also ensures
that the same set of bootstrap
samples is used in all subsequent
analyses.
</p>


<h3>Value</h3>

<p>A <code>boot_out</code>-class object
that can be used for the <code>boot_out</code>
argument of <code><a href="#topic+indirect_effect">indirect_effect()</a></code>,
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>, and
related functions for forming
bootstrapping confidence intervals.
The object is a list with the number
of elements equal to the number of
bootstrap samples. Each element is a
list of the parameter estimates and
sample variances and covariances of
the variables in each bootstrap
sample.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>lm2boot_out()</code>: Generate
bootstrap estimates using one process
(serial, without parallelization).
</p>
</li>
<li> <p><code>lm2boot_out_parallel()</code>: Generate
bootstrap estimates using parallel
processing.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+do_boot">do_boot()</a></code>, the general
purpose function that users should
try first before using this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(data_med_mod_ab1)
dat &lt;- data_med_mod_ab1
lm_m &lt;- lm(m ~ x*w + c1 + c2, dat)
lm_y &lt;- lm(y ~ m*w + x + c1 + c2, dat)
lm_out &lt;- lm2list(lm_m, lm_y)
# In real research, R should be 2000 or even 5000
# In real research, no need to set progress to FALSE
# Progress is displayed by default.
lm_boot_out &lt;- lm2boot_out(lm_out, R = 100, seed = 1234,
                           progress = FALSE)
out &lt;- cond_indirect_effects(wlevels = "w",
                             x = "x",
                             y = "y",
                             m = "m",
                             fit = lm_out,
                             boot_ci = TRUE,
                             boot_out = lm_boot_out)
out

</code></pre>

<hr>
<h2 id='lm2list'>Join 'lm()' Output to Form an
'lm_list'-Class Object</h2><span id='topic+lm2list'></span>

<h3>Description</h3>

<p>The resulting model can
be used by <code><a href="#topic+indirect_effect">indirect_effect()</a></code>,
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>, or
<code><a href="#topic+cond_indirect">cond_indirect()</a></code> as a path method,
as if fitted by <code><a href="lavaan.html#topic+sem">lavaan::sem()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm2list(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm2list_+3A_...">...</code></td>
<td>
<p>The <code><a href="stats.html#topic+lm">lm()</a></code> outputs to be
grouped in a list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a path model with
mediation and/or moderation is fitted
by a set of regression models using
<code><a href="stats.html#topic+lm">lm()</a></code>, this function can combine
them to an object of the class
<code>lm_list</code> that represents a path
model, as one fitted by structural
equation model functions such as
<code><a href="lavaan.html#topic+sem">lavaan::sem()</a></code>. This class of object
can be used by some functions, such
as <code><a href="#topic+indirect_effect">indirect_effect()</a></code>,
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>, and
<code><a href="#topic+cond_indirect">cond_indirect()</a></code> as if they were the
output of fitting a path model, with
the regression coefficients treated
as path coefficients.
</p>
<p>The regression outputs to be combined
need to meet the following
requirements:
</p>

<ul>
<li><p> All models must be connected to at
least one another model. That is, a
regression model must either have (a)
at least on predictor that is the
outcome variable of another model, or
(b) its outcome variable the
predictor of another model.
</p>
</li>
<li><p> All models must be fitted to the
same sample. This implies that the
sample size must be the same in all
analysis.
</p>
</li></ul>



<h3>Value</h3>

<p>It returns an <code>lm_list</code>-class
object that forms a path model
represented by a set of regression
models. This class has a <code>summary</code>
method that shows the summary of
each regression model stored (see
<code><a href="#topic+summary.lm_list">summary.lm_list()</a></code>), and a <code>print</code>
method that prints the models stored
(see <code><a href="#topic+print.lm_list">print.lm_list()</a></code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.lm_list">summary.lm_list()</a></code> and
<code><a href="#topic+print.lm_list">print.lm_list()</a></code> for related
methods, <code><a href="#topic+indirect_effect">indirect_effect()</a></code> and
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code> which
accept <code>lm_list</code>-class objects as
input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


data(data_serial_parallel)
lm_m11 &lt;- lm(m11 ~ x + c1 + c2, data_serial_parallel)
lm_m12 &lt;- lm(m12 ~ m11 + x + c1 + c2, data_serial_parallel)
lm_m2 &lt;- lm(m2 ~ x + c1 + c2, data_serial_parallel)
lm_y &lt;- lm(y ~ m11 + m12 + m2 + x + c1 + c2, data_serial_parallel)
# Join them to form a lm_list-class object
lm_serial_parallel &lt;- lm2list(lm_m11, lm_m12, lm_m2, lm_y)
lm_serial_parallel
summary(lm_serial_parallel)

# Compute indirect effect from x to y through m11 and m12
outm11m12 &lt;- cond_indirect(x = "x", y = "y",
                           m = c("m11", "m12"),
                           fit = lm_serial_parallel)
outm11m12
# Compute indirect effect from x to y
# through m11 and m12 with bootstrapping CI
# R should be at least 2000 or even 5000 in read study.
# In real research, parallel and progress can be omitted.
# They are est to TRUE by default.
outm11m12 &lt;- cond_indirect(x = "x", y = "y",
                           m = c("m11", "m12"),
                           fit = lm_serial_parallel,
                           boot_ci = TRUE,
                           R = 100,
                           seed = 1234,
                           parallel = FALSE,
                           progress = FALSE)
outm11m12

</code></pre>

<hr>
<h2 id='manymome-package'>manymome: Mediation, Moderation and Moderated-Mediation After Model Fitting</h2><span id='topic+manymome'></span><span id='topic+manymome-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Computes indirect effects, conditional effects, and conditional indirect effects in a structural equation model or path model after model fitting, with no need to define any user parameters or label any paths in the model syntax, using the approach presented in Cheung and Cheung (2023) <a href="https://doi.org/10.3758/s13428-023-02224-z">doi:10.3758/s13428-023-02224-z</a>. Can also form bootstrap confidence intervals by doing bootstrapping only once and reusing the bootstrap estimates in all subsequent computations. Supports bootstrap confidence intervals for standardized (partially or completely) indirect effects, conditional effects, and conditional indirect effects as described in Cheung (2009) <a href="https://doi.org/10.3758/BRM.41.2.425">doi:10.3758/BRM.41.2.425</a> and Cheung, Cheung, Lau, Hui, and Vong (2022) <a href="https://doi.org/10.1037/hea0001188">doi:10.1037/hea0001188</a>. Model fitting can be done by structural equation modeling using lavaan() or regression using lm().
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Shu Fai Cheung <a href="mailto:shufai.cheung@gmail.com">shufai.cheung@gmail.com</a> (<a href="https://orcid.org/0000-0002-9871-9448">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Sing-Hang Cheung (<a href="https://orcid.org/0000-0001-5182-0752">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://sfcheung.github.io/manymome/">https://sfcheung.github.io/manymome/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/sfcheung/manymome/issues">https://github.com/sfcheung/manymome/issues</a>
</p>
</li></ul>


<hr>
<h2 id='math_indirect'>Math Operators for
'indirect'-Class Objects</h2><span id='topic+math_indirect'></span><span id='topic++2B.indirect'></span><span id='topic+-.indirect'></span>

<h3>Description</h3>

<p>Mathematic operators for
'indirect'-class object, the output
of <code><a href="#topic+indirect_effect">indirect_effect()</a></code> and
<code><a href="#topic+cond_indirect">cond_indirect()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'indirect'
e1 + e2

## S3 method for class 'indirect'
e1 - e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="math_indirect_+3A_e1">e1</code></td>
<td>
<p>An 'indirect'-class object.</p>
</td></tr>
<tr><td><code id="math_indirect_+3A_e2">e2</code></td>
<td>
<p>An 'indirect'-class object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For now, only <code>+</code> operator
and <code>-</code> operator are supported. These
operators can be used to estimate and
test a function of effects between
the same pair of variables but along
different paths.
</p>
<p>For example, they can be used to
compute and test the total effects
along different paths. They can also
be used to compute and test the
difference between the effects along
two paths.
</p>
<p>The operators will check whether an
operation is valid. An operation is
not valid if
</p>

<ol>
<li><p> the two paths do not start from
the same variable,
</p>
</li>
<li><p> the two paths do not end at the
same variable, (c) a path appears in
both objects,
</p>
</li>
<li><p> moderators are involved but they
are not set to the same values in
both objects, and
</p>
</li>
<li><p> bootstrap estimates stored in
<code>boot_out</code>, if any, are not identical.
</p>
</li>
<li><p> Monte Carlo simulated
estimates stored in
<code>mc_out</code>, if any, are not identical.
</p>
</li></ol>



<h3>Value</h3>

<p>An 'indirect'-class object
with a list of effects stored. See
<code><a href="#topic+indirect_effect">indirect_effect()</a></code> on details for
this class.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+indirect_effect">indirect_effect()</a></code> and
<code><a href="#topic+cond_indirect">cond_indirect()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
dat &lt;- modmed_x1m3w4y1
mod &lt;-
"
m1 ~ a1 * x  + d1 * w1 + e1 * x:w1
m2 ~ m1 + a2 * x
y  ~ b1 * m1 + b2 * m2 + cp * x
"
fit &lt;- sem(mod, dat,
           meanstructure = TRUE, fixed.x = FALSE,
           se = "none", baseline = FALSE)
est &lt;- parameterEstimates(fit)
hi_w1 &lt;- mean(dat$w1) + sd(dat$w1)

# Examples for cond_indirect():

# Conditional effect from x to m1 when w1 is 1 SD above mean
out1 &lt;- cond_indirect(x = "x", y = "y", m = c("m1", "m2"),
              wvalues = c(w1 = hi_w1), fit = fit)
out2 &lt;- cond_indirect(x = "x", y = "y", m = c("m2"),
              wvalues = c(w1 = hi_w1), fit = fit)
out3 &lt;- cond_indirect(x = "x", y = "y",
              wvalues = c(w1 = hi_w1), fit = fit)

out12 &lt;- out1 + out2
out12
out123 &lt;- out1 + out2 + out3
out123
coef(out1) + coef(out2) + coef(out3)

</code></pre>

<hr>
<h2 id='merge_mod_levels'>Merge the Generated Levels of
Moderators</h2><span id='topic+merge_mod_levels'></span>

<h3>Description</h3>

<p>Merge the levels of
moderators generated by
<code><a href="#topic+mod_levels">mod_levels()</a></code> into a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_mod_levels(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_mod_levels_+3A_...">...</code></td>
<td>
<p>The output from
<code><a href="#topic+mod_levels">mod_levels()</a></code>, or a list of levels
generated by <code><a href="#topic+mod_levels_list">mod_levels_list()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It merges the levels of
moderators generated by
<code><a href="#topic+mod_levels">mod_levels()</a></code> into a data frame,
with each row represents a
combination of the levels. The output
is to be used by
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>.
</p>
<p>Users usually do not need to use this
function because
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code> will merge
the levels internally if necessary.
This function is used when users need
to customize the levels for each
moderator and so cannot use
<code><a href="#topic+mod_levels_list">mod_levels_list()</a></code> or the default
levels in <code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>.
</p>


<h3>Value</h3>

<p>A <code>wlevels</code>-class object,
which is a data frame of the
combinations of levels, with
additional attributes about the
levels.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mod_levels">mod_levels()</a></code> on generating
the levels of a moderator.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(data_med_mod_ab)
dat &lt;- data_med_mod_ab
# Form the levels from a list of lm() outputs
lm_m &lt;- lm(m ~ x*w1 + c1 + c2, dat)
lm_y &lt;- lm(y ~ m*w2 + x + w1 + c1 + c2, dat)
lm_out &lt;- lm2list(lm_m, lm_y)
w1_levels &lt;- mod_levels(lm_out, w = "w1")
w1_levels
w2_levels &lt;- mod_levels(lm_out, w = "w2")
w2_levels
merge_mod_levels(w1_levels, w2_levels)

</code></pre>

<hr>
<h2 id='mod_levels'>Create Levels of Moderators</h2><span id='topic+mod_levels'></span><span id='topic+mod_levels_list'></span>

<h3>Description</h3>

<p>Create levels of
moderators to be used by
<code><a href="#topic+indirect_effect">indirect_effect()</a></code>,
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>, and
<code><a href="#topic+cond_indirect">cond_indirect()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mod_levels(
  w,
  fit,
  w_type = c("auto", "numeric", "categorical"),
  w_method = c("sd", "percentile"),
  sd_from_mean = c(-1, 0, 1),
  percentiles = c(0.16, 0.5, 0.84),
  extract_gp_names = TRUE,
  prefix = NULL,
  values = NULL,
  reference_group_label = NULL,
  descending = TRUE
)

mod_levels_list(
  ...,
  fit,
  w_type = "auto",
  w_method = "sd",
  sd_from_mean = NULL,
  percentiles = NULL,
  extract_gp_names = TRUE,
  prefix = NULL,
  descending = TRUE,
  merge = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mod_levels_+3A_w">w</code></td>
<td>
<p>Character. The names of the moderator. If the moderator is
categorical with 3 or more groups, this is the vector of the
indicator variables.</p>
</td></tr>
<tr><td><code id="mod_levels_+3A_fit">fit</code></td>
<td>
<p>The fit object. Can be a
<a href="lavaan.html#topic+lavaan-class">lavaan::lavaan</a> object or a
list of <code><a href="stats.html#topic+lm">lm()</a></code> outputs.
It can also be
a <code>lavaan.mi</code> object
returned by
<code><a href="semTools.html#topic+runMI">semTools::runMI()</a></code> or
its wrapper, such as <code><a href="semTools.html#topic+runMI">semTools::sem.mi()</a></code>.</p>
</td></tr>
<tr><td><code id="mod_levels_+3A_w_type">w_type</code></td>
<td>
<p>Character. Whether the
moderator is a <code>"numeric"</code> variable
or a <code>"categorical"</code> variable. If
<code>"auto"</code>, the function will try to
determine the type automatically.</p>
</td></tr>
<tr><td><code id="mod_levels_+3A_w_method">w_method</code></td>
<td>
<p>Character, either
<code>"sd"</code> or <code>"percentile"</code>. If <code>"sd"</code>,
the levels are defined by the
distance from the mean in terms of
standard deviation. if
<code>"percentile"</code>, the levels are
defined in percentiles.</p>
</td></tr>
<tr><td><code id="mod_levels_+3A_sd_from_mean">sd_from_mean</code></td>
<td>
<p>A numeric vector.
Specify the distance in standard
deviation from the mean for each
level. Default is <code>c(-1, 0, 1)</code> for
<code><a href="#topic+mod_levels">mod_levels()</a></code>. For
<code><a href="#topic+mod_levels_list">mod_levels_list()</a></code>, the default is
<code>c(-1, 0, 1)</code> when there is only one
moderator, and <code>c(-1, 1)</code> when there
are more than one moderator. Ignored
if <code>w_method</code> is not equal to <code>"sd"</code>.</p>
</td></tr>
<tr><td><code id="mod_levels_+3A_percentiles">percentiles</code></td>
<td>
<p>A numeric vector.
Specify the percentile (in
proportion) for each level. Default
is <code>c(.16, .50, .84)</code> for
<code><a href="#topic+mod_levels">mod_levels()</a></code>, corresponding
approximately to one standard
deviation below mean, mean, and one
standard deviation above mean in a
normal distribution. For
<code><a href="#topic+mod_levels_list">mod_levels_list()</a></code>, default is
<code>c(.16, .50, .84)</code> if there is one
moderator, and <code>c(.16, .84)</code> when
there are more than one moderator.
Ignored if <code>w_method</code> is not equal to
<code>"percentile"</code>.</p>
</td></tr>
<tr><td><code id="mod_levels_+3A_extract_gp_names">extract_gp_names</code></td>
<td>
<p>Logical. If
<code>TRUE</code>, the default, the function
will try to determine the name of
each group from the variable names.</p>
</td></tr>
<tr><td><code id="mod_levels_+3A_prefix">prefix</code></td>
<td>
<p>Character. If
<code>extract_gp_names</code> is <code>TRUE</code> and
<code>prefix</code> is supplied, it will be
removed from the variable names to
create the group names. Default is
<code>NULL</code>, and the function will try to
determine the prefix automatically.</p>
</td></tr>
<tr><td><code id="mod_levels_+3A_values">values</code></td>
<td>
<p>For numeric moderators,
a numeric vector. These are the
values to be used and will override
other options. For categorical
moderators, a named list of numeric
vector, each vector has length equal
to the number of indicator variables.
If the vector is named, the names
will be used to label the values. For
example, if set to <code style="white-space: pre;">&#8288;list(gp1 = c(0, 0), gp3 = c(0, 1)&#8288;</code>, two levels will
be returned, one named <code>gp1</code> with the
indicator variables equal to 0 and 0,
the other named <code>gp3</code> with the
indicator variables equal to 0 and 1.
Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mod_levels_+3A_reference_group_label">reference_group_label</code></td>
<td>
<p>For
categorical moderator, if the label
for the reference group (group with
all indicators equal to zero) cannot
be determined, the default label is
<code>"Reference"</code>. To change it, set
<code>reference_group_label</code> to the
desired label. Ignored if <code>values</code> is
set.</p>
</td></tr>
<tr><td><code id="mod_levels_+3A_descending">descending</code></td>
<td>
<p>If <code>TRUE</code>
(default), the rows are sorted in
descending order for numerical
moderators: The highest value on the
first row and the lowest values on
the last row. For user supplied
values, the first value is on the
last row and the last value is on the
first row. If <code>FALSE</code>, the rows are
sorted in ascending order.</p>
</td></tr>
<tr><td><code id="mod_levels_+3A_...">...</code></td>
<td>
<p>The names of moderators
variables. For a categorical
variable, it should be a vector of
variable names.</p>
</td></tr>
<tr><td><code id="mod_levels_+3A_merge">merge</code></td>
<td>
<p>If <code>TRUE</code>,
<code><a href="#topic+mod_levels_list">mod_levels_list()</a></code> will call
<code><a href="#topic+merge_mod_levels">merge_mod_levels()</a></code> and return the
merged levels. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It creates values of a
moderator that can be used to compute
conditional effect or conditional
indirect effect. By default, for a
numeric moderator, it uses one
standard deviation below mean, mean,
and one standard deviation above
mean. The percentiles of these three
levels in a normal distribution
(16th, 50th, and 84th) can also be
used. For categorical variable, it
will simply collect the unique
categories in the data.
</p>
<p>The generated levels are then used by
<code><a href="#topic+cond_indirect">cond_indirect()</a></code> and
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>.
</p>
<p>If a model has more than one
moderator, <code><a href="#topic+mod_levels_list">mod_levels_list()</a></code> can be
used to generate combinations of
levels. The output can then passed to
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code> to compute
the conditional effects or
conditional indirect effects for all
the combinations.
</p>


<h3>Value</h3>

<p><code><a href="#topic+mod_levels">mod_levels()</a></code> returns a
<code>wlevels</code>-class object which is a
data frame with additional attributes
about the levels.
</p>
<p><code><a href="#topic+mod_levels_list">mod_levels_list()</a></code> returns a list of
<code>wlevels</code>-class objects, or a
<code>wlevels</code>-class object which is a
data frame of the merged levels if
<code>merge = TRUE</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>mod_levels()</code>: Generate
levels for one moderator.
</p>
</li>
<li> <p><code>mod_levels_list()</code>: Generate
levels for several moderators.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code> for computing conditional
indiret effects; <code><a href="#topic+merge_mod_levels">merge_mod_levels()</a></code> for merging
levels of moderators.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)
data(data_med_mod_ab)
dat &lt;- data_med_mod_ab
# Form the levels from a list of lm() outputs
lm_m &lt;- lm(m ~ x*w1 + c1 + c2, dat)
lm_y &lt;- lm(y ~ m*w2 + x + w1 + c1 + c2, dat)
lm_out &lt;- lm2list(lm_m, lm_y)
w1_levels &lt;- mod_levels(lm_out, w = "w1")
w1_levels
w2_levels &lt;- mod_levels(lm_out, w = "w2")
w2_levels
# Indirect effect from x to y through m, at the first levels of w1 and w2
cond_indirect(x = "x", y = "y", m = "m",
              fit = lm_out,
              wvalues = c(w1 = w1_levels$w1[1],
                          w2 = w2_levels$w2[1]))
# Can form the levels based on percentiles
w1_levels2 &lt;- mod_levels(lm_out, w = "w1", w_method = "percentile")
w1_levels2
# Form the levels from a lavaan output
# Compute the product terms before fitting the model
dat$mw2 &lt;- dat$m * dat$w2
mod &lt;-
"
m ~ x + w1 + x:w1 + c1 + c2
y ~ m + x + w1 + w2 + mw2 + c1 + c2
"
fit &lt;- sem(mod, dat, fixed.x = FALSE)
cond_indirect(x = "x", y = "y", m = "m",
              fit = fit,
              wvalues = c(w1 = w1_levels$w1[1],
                          w2 = w2_levels$w2[1]))
# Can pass all levels to cond_indirect_effects()
# First merge the levels by merge_mod_levels()
w1w2_levels &lt;- merge_mod_levels(w1_levels, w2_levels)
cond_indirect_effects(x = "x", y = "y", m = "m",
                      fit = fit,
                      wlevels = w1w2_levels)




# mod_levels_list() forms a combinations of levels in one call
# It returns a list, by default.
# Form the levels from a list of lm() outputs
# "merge = TRUE" is optional. cond_indirect_effects will merge the levels
# automatically.
w1w2_levels &lt;- mod_levels_list("w1", "w2", fit = fit, merge = TRUE)
w1w2_levels
cond_indirect_effects(x = "x", y = "y", m = "m",
                      fit = fit, wlevels = w1w2_levels)
# Can work without merge = TRUE:
w1w2_levels &lt;- mod_levels_list("w1", "w2", fit = fit)
w1w2_levels
cond_indirect_effects(x = "x", y = "y", m = "m",
                      fit = fit, wlevels = w1w2_levels)


</code></pre>

<hr>
<h2 id='modmed_x1m3w4y1'>Sample Dataset: Moderated
Serial Mediation</h2><span id='topic+modmed_x1m3w4y1'></span>

<h3>Description</h3>

<p>Generated from a serial
mediation model with one predictor,
three mediators, and one outcome
variable, with one moderator in each
stage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modmed_x1m3w4y1
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 rows
and 11 variables:
</p>

<dl>
<dt>x</dt><dd><p>Predictor. Numeric.</p>
</dd>
<dt>w1</dt><dd><p>Moderator 1. Numeric.</p>
</dd>
<dt>w2</dt><dd><p>Moderator 2. Numeric.</p>
</dd>
<dt>w3</dt><dd><p>Moderator 3. Numeric.</p>
</dd>
<dt>w4</dt><dd><p>Moderator 4. Numeric.</p>
</dd>
<dt>m1</dt><dd><p>Mediator 1. Numeric.</p>
</dd>
<dt>m2</dt><dd><p>Mediator 2. Numeric.</p>
</dd>
<dt>m3</dt><dd><p>Mediator 3. Numeric.</p>
</dd>
<dt>y</dt><dd><p>Outcome variable. Numeric.</p>
</dd>
<dt>gp</dt><dd><p>Three values: &quot;earth&quot;, &quot;mars&quot;, &quot;venus&quot;. String.</p>
</dd>
<dt>city</dt><dd><p>Four values: &quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;, &quot;sigma&quot;. String.</p>
</dd>
</dl>


<hr>
<h2 id='plot.cond_indirect_effects'>Plot Conditional Effects</h2><span id='topic+plot.cond_indirect_effects'></span>

<h3>Description</h3>

<p>Plot the conditional
effects for different levels of
moderators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cond_indirect_effects'
plot(
  x,
  x_label,
  w_label = "Moderator(s)",
  y_label,
  title,
  x_from_mean_in_sd = 1,
  x_method = c("sd", "percentile"),
  x_percentiles = c(0.16, 0.84),
  x_sd_to_percentiles = NA,
  note_standardized = TRUE,
  no_title = FALSE,
  line_width = 1,
  point_size = 5,
  graph_type = c("default", "tumble"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cond_indirect_effects_+3A_x">x</code></td>
<td>
<p>The output of
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>. (Named <code>x</code>
because it is required in the naming
of arguments of the <code>plot</code> generic
function.)</p>
</td></tr>
<tr><td><code id="plot.cond_indirect_effects_+3A_x_label">x_label</code></td>
<td>
<p>The label for the
X-axis. Default is the value of the
predictor in the output of
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.cond_indirect_effects_+3A_w_label">w_label</code></td>
<td>
<p>The label for the
legend for the lines. Default is
<code>"Moderator(s)"</code>.</p>
</td></tr>
<tr><td><code id="plot.cond_indirect_effects_+3A_y_label">y_label</code></td>
<td>
<p>The label for the
Y-axis. Default is the name of the
response variable in the model.</p>
</td></tr>
<tr><td><code id="plot.cond_indirect_effects_+3A_title">title</code></td>
<td>
<p>The title of the graph.
If not supplied, it will be generated
from the variable names or labels (in
<code>x_label</code>, <code>y_label</code>, and <code>w_label</code>).
If <code>""</code>, no title will be printed.
This can be used when the plot is for
manuscript submission and figures are
required to have no titles.</p>
</td></tr>
<tr><td><code id="plot.cond_indirect_effects_+3A_x_from_mean_in_sd">x_from_mean_in_sd</code></td>
<td>
<p>How many SD
from mean is used to define &quot;low&quot; and
&quot;high&quot; for the focal variable.
Default is 1.</p>
</td></tr>
<tr><td><code id="plot.cond_indirect_effects_+3A_x_method">x_method</code></td>
<td>
<p>How to define &quot;high&quot;
and &quot;low&quot; for the focal variable
levels. Default is in terms of the
standard deviation of the focal
variable, <code>"sd"</code>. If equal to
<code>"percentile"</code>, then the percentiles
of the focal variable in the dataset
is used.</p>
</td></tr>
<tr><td><code id="plot.cond_indirect_effects_+3A_x_percentiles">x_percentiles</code></td>
<td>
<p>If <code>x_method</code> is
<code>"percentile"</code>, then this argument
specifies the two percentiles to be
used, divided by 100. It must be a
vector of two numbers. The default
is <code>c(.16, .84)</code>, the 16th and 84th
percentiles, which corresponds
approximately to one SD below and
above mean for a normal distribution,
respectively.</p>
</td></tr>
<tr><td><code id="plot.cond_indirect_effects_+3A_x_sd_to_percentiles">x_sd_to_percentiles</code></td>
<td>
<p>If
<code>x_method</code> is <code>"percentile"</code> and this
argument is set to a number, this
number will be used to determine the
percentiles to be used. The lower
percentile is the percentile in a
normal distribution that is
<code>x_sd_to_percentiles</code> SD below the
mean. The upper percentile is the
percentile in a normal distribution
that is <code>x_sd_to_percentiles</code> SD
above the mean. Therefore, if
<code>x_sd_to_percentiles</code> is set to 1,
then the lower and upper percentiles
are 16th and 84th, respectively.
Default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="plot.cond_indirect_effects_+3A_note_standardized">note_standardized</code></td>
<td>
<p>If <code>TRUE</code>,
will check whether a variable has SD
nearly equal to one. If yes, will
report this in the plot. Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.cond_indirect_effects_+3A_no_title">no_title</code></td>
<td>
<p>If <code>TRUE</code>, title will
be suppressed. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.cond_indirect_effects_+3A_line_width">line_width</code></td>
<td>
<p>The width of the
lines as used in
<code><a href="ggplot2.html#topic+geom_segment">ggplot2::geom_segment()</a></code>. Default is
1.</p>
</td></tr>
<tr><td><code id="plot.cond_indirect_effects_+3A_point_size">point_size</code></td>
<td>
<p>The size of the
points as used in
<code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code>. Default is
5.</p>
</td></tr>
<tr><td><code id="plot.cond_indirect_effects_+3A_graph_type">graph_type</code></td>
<td>
<p>If <code>"default"</code>, the
typical line-graph with equal
end-points will be plotted. If
<code>"tubmle"</code>, then the tumble graph
proposed by Bodner (2016) will be
plotted. Default is <code>"default"</code>.</p>
</td></tr>
<tr><td><code id="plot.cond_indirect_effects_+3A_...">...</code></td>
<td>
<p>Additional arguments.
Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a plot
method of the output of
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>. It will
use the levels of moderators in the
output.
</p>
<p>It plots the conditional effect from
<code>x</code> to <code>y</code> in a model for different
levels of the moderators.
</p>
<p>It does not support conditional
indirect effects. If there is one or
more mediators in <code>x</code>, it will raise
an error.
</p>


<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot2">ggplot2</a> graph. Plotted if
not assigned to a name. It can be
further modified like a usual
<a href="ggplot2.html#topic+ggplot2">ggplot2</a> graph.
</p>


<h3>References</h3>

<p>Bodner, T. E. (2016). Tumble graphs: Avoiding misleading end point
extrapolation when graphing interactions from a moderated multiple
regression analysis. <em>Journal of Educational and Behavioral
Statistics, 41</em>(6), 593-604. <a href="https://doi.org/10.3102/1076998616657080">doi:10.3102/1076998616657080</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
dat &lt;- modmed_x1m3w4y1
n &lt;- nrow(dat)
set.seed(860314)
dat$gp &lt;- sample(c("gp1", "gp2", "gp3"), n, replace = TRUE)
dat &lt;- cbind(dat, factor2var(dat$gp, prefix = "gp", add_rownames = FALSE))

# Categorical moderator

mod &lt;-
"
m3 ~ m1 + x + gpgp2 + gpgp3 + x:gpgp2 + x:gpgp3
y ~ m2 + m3 + x
"
fit &lt;- sem(mod, dat, meanstructure = TRUE, fixed.x = FALSE)
out_mm_1 &lt;- mod_levels(c("gpgp2", "gpgp3"),
                       sd_from_mean = c(-1, 1),
                       fit = fit)
out_1 &lt;- cond_indirect_effects(wlevels = out_mm_1, x = "x", y = "m3", fit = fit)
plot(out_1)
plot(out_1, graph_type = "tumble")

# Numeric moderator

dat &lt;- modmed_x1m3w4y1
mod2 &lt;-
"
m3 ~ m1 + x + w1 + x:w1
y ~ m3 + x
"
fit2 &lt;- sem(mod2, dat, meanstructure = TRUE, fixed.x = FALSE)
out_mm_2 &lt;- mod_levels("w1",
                       w_method = "percentile",
                       percentiles = c(.16, .84),
                       fit = fit2)
out_mm_2
out_2 &lt;- cond_indirect_effects(wlevels = out_mm_2, x = "x", y = "m3", fit = fit2)
plot(out_2)
plot(out_2, graph_type = "tumble")


</code></pre>

<hr>
<h2 id='predict.lm_from_lavaan'>Predicted Values of a
'lm_from_lavaan'-Class Object</h2><span id='topic+predict.lm_from_lavaan'></span>

<h3>Description</h3>

<p>Compute the predicted
values based on the model stored in a
'lm_from_lavaan'-class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm_from_lavaan'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.lm_from_lavaan_+3A_object">object</code></td>
<td>
<p>A
'lm_from_lavaan'-class object.</p>
</td></tr>
<tr><td><code id="predict.lm_from_lavaan_+3A_newdata">newdata</code></td>
<td>
<p>Required. A data frame
of the new data. It must be a data
frame.</p>
</td></tr>
<tr><td><code id="predict.lm_from_lavaan_+3A_...">...</code></td>
<td>
<p>Additional arguments.
Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An <code>lm_from_lavaan</code>-class
method that converts a regression
model for a variable in a <code>lavaan</code>
model to a <code>formula</code> object. This
function uses the stored model to
compute predicted values using
user-supplied data.
</p>
<p>This is an advanced helper used by
<code><a href="#topic+plot.cond_indirect_effects">plot.cond_indirect_effects()</a></code>.
Exported for advanced users and
developers.
</p>


<h3>Value</h3>

<p>A numeric vector of the
predicted values, with length equal
to the number of rows of
user-supplied data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lm_from_lavaan_list">lm_from_lavaan_list()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
data(data_med)
mod &lt;-
"
m ~ a * x + c1 + c2
y ~ b * m + x + c1 + c2
"
fit &lt;- sem(mod, data_med, fixed.x = FALSE)
fit_list &lt;- lm_from_lavaan_list(fit)
tmp &lt;- data.frame(x = 1, c1 = 2, c2 = 3, m = 4)
predict(fit_list$m, newdata = tmp)
predict(fit_list$y, newdata = tmp)

</code></pre>

<hr>
<h2 id='predict.lm_from_lavaan_list'>Predicted Values of an
'lm_from_lavaan_list'-Class Object</h2><span id='topic+predict.lm_from_lavaan_list'></span>

<h3>Description</h3>

<p>It computes the
predicted values based on the models
stored in an
'lm_from_lavaan_list'-class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm_from_lavaan_list'
predict(object, x = NULL, y = NULL, m = NULL, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.lm_from_lavaan_list_+3A_object">object</code></td>
<td>
<p>A
'lm_from_lavaan'-class object.</p>
</td></tr>
<tr><td><code id="predict.lm_from_lavaan_list_+3A_x">x</code></td>
<td>
<p>The variable name at the
start of a path.</p>
</td></tr>
<tr><td><code id="predict.lm_from_lavaan_list_+3A_y">y</code></td>
<td>
<p>The variable name at the end
of a path.</p>
</td></tr>
<tr><td><code id="predict.lm_from_lavaan_list_+3A_m">m</code></td>
<td>
<p>Optional. The mediator(s)
from <code>x</code> to <code>y</code>. A numeric vector of
the names of the mediators. The path
goes from the first element to the
last element. For example, if <code>m = c("m1", "m2")</code>, then the path is <code>x -&gt; m1 -&gt; m2 -&gt; y</code>.</p>
</td></tr>
<tr><td><code id="predict.lm_from_lavaan_list_+3A_newdata">newdata</code></td>
<td>
<p>Required. A data frame
of the new data. It must be a data
frame.</p>
</td></tr>
<tr><td><code id="predict.lm_from_lavaan_list_+3A_...">...</code></td>
<td>
<p>Additional arguments.
Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An
<code>lm_from_lavaan_list</code>-class object
is a list of <code>lm_from_lavaan</code>-class
objects.
</p>
<p>This is an advanced helper used by
<code><a href="#topic+plot.cond_indirect_effects">plot.cond_indirect_effects()</a></code>.
Exported for advanced users and
developers.
</p>


<h3>Value</h3>

<p>A numeric vector of the
predicted values, with length equal
to the number of rows of
user-supplied data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lm_from_lavaan_list">lm_from_lavaan_list()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
data(data_med)
mod &lt;-
"
m ~ a * x + c1 + c2
y ~ b * m + x + c1 + c2
"
fit &lt;- sem(mod, data_med, fixed.x = FALSE)
fit_list &lt;- lm_from_lavaan_list(fit)
tmp &lt;- data.frame(x = 1, c1 = 2, c2 = 3, m = 4)
predict(fit_list, x = "x", y = "y", m = "m", newdata = tmp)

</code></pre>

<hr>
<h2 id='predict.lm_list'>Predicted Values of an
'lm_list'-Class Object</h2><span id='topic+predict.lm_list'></span>

<h3>Description</h3>

<p>Compute the predicted
values based on the models stored in
an 'lm_list'-class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm_list'
predict(object, x = NULL, y = NULL, m = NULL, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.lm_list_+3A_object">object</code></td>
<td>
<p>An 'lm_list'-class
object.</p>
</td></tr>
<tr><td><code id="predict.lm_list_+3A_x">x</code></td>
<td>
<p>The variable name at the
start of a path.</p>
</td></tr>
<tr><td><code id="predict.lm_list_+3A_y">y</code></td>
<td>
<p>The variable name at the end
of a path.</p>
</td></tr>
<tr><td><code id="predict.lm_list_+3A_m">m</code></td>
<td>
<p>Optional. The mediator(s)
from <code>x</code> to <code>y</code>. A numeric vector of
the names of the mediators. The path
goes from the first element to the
last element. For example, if <code>m = c("m1", "m2")</code>, then the path is <code>x -&gt; m1 -&gt; m2 -&gt; y</code>.</p>
</td></tr>
<tr><td><code id="predict.lm_list_+3A_newdata">newdata</code></td>
<td>
<p>Required. A data frame
of the new data. It must be a
data frame.</p>
</td></tr>
<tr><td><code id="predict.lm_list_+3A_...">...</code></td>
<td>
<p>Additional arguments.
Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An <code>lm_list</code>-class object is
a list of <code>lm</code>-class objects, this
function is similar to the
<code><a href="stats.html#topic+predict">stats::predict()</a></code> method of <code><a href="stats.html#topic+lm">lm()</a></code>
but it works on a system defined by a
list of regression models.
</p>
<p>This is an advanced helper used by
some functions in this package.
Exported for advanced users.
</p>


<h3>Value</h3>

<p>A numeric vector of the
predicted values, with length equal
to the number of rows of
user-supplied data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lm2list">lm2list()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data_serial_parallel)
lm_m11 &lt;- lm(m11 ~ x + c1 + c2, data_serial_parallel)
lm_m12 &lt;- lm(m12 ~ m11 + x + c1 + c2, data_serial_parallel)
lm_m2 &lt;- lm(m2 ~ x + c1 + c2, data_serial_parallel)
lm_y &lt;- lm(y ~ m11 + m12 + m2 + x + c1 + c2, data_serial_parallel)
# Join them to form a lm_list-class object
lm_serial_parallel &lt;- lm2list(lm_m11, lm_m12, lm_m2, lm_y)
lm_serial_parallel
summary(lm_serial_parallel)
newdat &lt;- data_serial_parallel[3:5, ]
predict(lm_serial_parallel,
        x = "x",
        y = "y",
        m = "m2",
        newdata = newdat)

</code></pre>

<hr>
<h2 id='print.all_paths'>Print 'all_paths' Class Object</h2><span id='topic+print.all_paths'></span>

<h3>Description</h3>

<p>Print the content of 'all_paths'-class object,
which can be generated by <code><a href="#topic+all_indirect_paths">all_indirect_paths()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'all_paths'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.all_paths_+3A_x">x</code></td>
<td>
<p>A 'all_paths'-class object.</p>
</td></tr>
<tr><td><code id="print.all_paths_+3A_...">...</code></td>
<td>
<p>Optional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to
print the paths identified in a readable
format.
</p>


<h3>Value</h3>

<p><code>x</code> is returned invisibly. Called for its side effect.
</p>


<h3>Author(s)</h3>

<p>Shu Fai Cheung <a href="https://orcid.org/0000-0002-9871-9448">https://orcid.org/0000-0002-9871-9448</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+all_indirect_paths">all_indirect_paths()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
data(data_serial_parallel)
mod &lt;-
"
m11 ~ x + c1 + c2
m12 ~ m11 + x + c1 + c2
m2 ~ x + c1 + c2
y ~ m12 + m2 + m11 + x + c1 + c2
"
fit &lt;- sem(mod, data_serial_parallel,
           fixed.x = FALSE)
# All indirect paths
out1 &lt;- all_indirect_paths(fit)
out1

</code></pre>

<hr>
<h2 id='print.boot_out'>Print a <code>boot_out</code>-Class
Object</h2><span id='topic+print.boot_out'></span>

<h3>Description</h3>

<p>Print the content of the
output of <code><a href="#topic+do_boot">do_boot()</a></code> or related
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boot_out'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.boot_out_+3A_x">x</code></td>
<td>
<p>The output of <code><a href="#topic+do_boot">do_boot()</a></code>,
or any <code>boot_out</code>-class object
returned
by similar functions.</p>
</td></tr>
<tr><td><code id="print.boot_out_+3A_...">...</code></td>
<td>
<p>Other arguments. Not
used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> is returned invisibly.
Called for its side effect.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(data_med_mod_ab1)
dat &lt;- data_med_mod_ab1
lm_m &lt;- lm(m ~ x*w + c1 + c2, dat)
lm_y &lt;- lm(y ~ m*w + x + c1 + c2, dat)
lm_out &lt;- lm2list(lm_m, lm_y)
# In real research, R should be 2000 or even 5000
# In real research, no need to set parallel to FALSE
# In real research, no need to set progress to FALSE
# Progress is displayed by default.
lm_boot_out &lt;- do_boot(lm_out, R = 100,
                       seed = 1234,
                       progress = FALSE,
                       parallel = FALSE)
# Print the output of do_boot()
lm_boot_out

library(lavaan)
data(data_med_mod_ab1)
dat &lt;- data_med_mod_ab1
dat$"x:w" &lt;- dat$x * dat$w
dat$"m:w" &lt;- dat$m * dat$w
mod &lt;-
"
m ~ x + w + x:w + c1 + c2
y ~ m + w + m:w + x + c1 + c2
"
fit &lt;- sem(model = mod, data = dat, fixed.x = FALSE,
           se = "none", baseline = FALSE)
# In real research, R should be 2000 or even 5000
# In real research, no need to set progress to FALSE
# In real research, no need to set parallel to FALSE
# Progress is displayed by default.
fit_boot_out &lt;- do_boot(fit = fit,
                        R = 40,
                        seed = 1234,
                        parallel = FALSE,
                        progress = FALSE)
# Print the output of do_boot()
fit_boot_out

</code></pre>

<hr>
<h2 id='print.cond_indirect_diff'>Print the Output of
'cond_indirect_diff'</h2><span id='topic+print.cond_indirect_diff'></span>

<h3>Description</h3>

<p>Print the output of
<code><a href="#topic+cond_indirect_diff">cond_indirect_diff()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cond_indirect_diff'
print(x, digits = 3, pvalue = FALSE, pvalue_digits = 3, se = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cond_indirect_diff_+3A_x">x</code></td>
<td>
<p>The output of
<code><a href="#topic+cond_indirect_diff">cond_indirect_diff()</a></code>.</p>
</td></tr>
<tr><td><code id="print.cond_indirect_diff_+3A_digits">digits</code></td>
<td>
<p>The number of decimal
places in the printout.</p>
</td></tr>
<tr><td><code id="print.cond_indirect_diff_+3A_pvalue">pvalue</code></td>
<td>
<p>Logical. If <code>TRUE</code>,
asymmetric <em>p</em>-value based on
bootstrapping will be printed if
available. Default is <code>FALSE.</code></p>
</td></tr>
<tr><td><code id="print.cond_indirect_diff_+3A_pvalue_digits">pvalue_digits</code></td>
<td>
<p>Number of decimal
places to display for the <em>p</em>-value.
Default is 3.</p>
</td></tr>
<tr><td><code id="print.cond_indirect_diff_+3A_se">se</code></td>
<td>
<p>Logical. If <code>TRUE</code> and
confidence intervals are available,
the standard errors of the estimates
are also printed. They are simply the
standard deviations of the bootstrap
estimates or Monte Carlo simulated
values, depending on the method used
to form the confidence intervals.</p>
</td></tr>
<tr><td><code id="print.cond_indirect_diff_+3A_...">...</code></td>
<td>
<p>Optional arguments.
Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>print</code> method of the
<code>cond_indirect_diff</code>-class object.
</p>
<p>If bootstrapping confidence interval
was requested, this method has the
option to print a
<em>p</em>-value computed by the
method presented in Asparouhov and Muthn (2021).
Note that this <em>p</em>-value is asymmetric
bootstrap <em>p</em>-value based on the
distribution of the bootstrap estimates.
It is not computed based on the
distribution under the null hypothesis.
</p>
<p>For a <em>p</em>-value of <em>a</em>, it means that
a 100(1 - <em>a</em>)% bootstrapping confidence
interval
will have one of its limits equal to
0. A confidence interval
with a higher confidence level will
include zero, while a confidence
interval with a lower confidence level
will exclude zero.
</p>


<h3>Value</h3>

<p>It returns <code>x</code> invisibly.
Called for its side effect.
</p>


<h3>References</h3>

<p>Asparouhov, A., &amp; Muthn, B. (2021). Bootstrap p-value computation.
Retrieved from https://www.statmodel.com/download/FAQ-Bootstrap%20-%20Pvalue.pdf
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cond_indirect_diff">cond_indirect_diff()</a></code>
</p>

<hr>
<h2 id='print.cond_indirect_effects'>Print a
'cond_indirect_effects' Class Object</h2><span id='topic+print.cond_indirect_effects'></span>

<h3>Description</h3>

<p>Print the content of the
output of <code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cond_indirect_effects'
print(
  x,
  digits = 3,
  annotation = TRUE,
  pvalue = FALSE,
  pvalue_digits = 3,
  se = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cond_indirect_effects_+3A_x">x</code></td>
<td>
<p>The output of
<code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>.</p>
</td></tr>
<tr><td><code id="print.cond_indirect_effects_+3A_digits">digits</code></td>
<td>
<p>Number of digits to
display. Default is 3.</p>
</td></tr>
<tr><td><code id="print.cond_indirect_effects_+3A_annotation">annotation</code></td>
<td>
<p>Logical. Whether
the annotation after the table of
effects is to be printed. Default is
<code>TRUE.</code></p>
</td></tr>
<tr><td><code id="print.cond_indirect_effects_+3A_pvalue">pvalue</code></td>
<td>
<p>Logical. If <code>TRUE</code>,
asymmetric <em>p</em>-values based on
bootstrapping will be printed if
available. Default is <code>FALSE.</code></p>
</td></tr>
<tr><td><code id="print.cond_indirect_effects_+3A_pvalue_digits">pvalue_digits</code></td>
<td>
<p>Number of decimal
places to display for the <em>p</em>-values.
Default is 3.</p>
</td></tr>
<tr><td><code id="print.cond_indirect_effects_+3A_se">se</code></td>
<td>
<p>Logical. If <code>TRUE</code> and
confidence intervals are available,
the standard errors of the estimates
are also printed. They are simply the
standard deviations of the bootstrap
estimates or Monte Carlo simulated
values, depending on the method used
to form the confidence intervals.</p>
</td></tr>
<tr><td><code id="print.cond_indirect_effects_+3A_...">...</code></td>
<td>
<p>Other arguments. Not
used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>print</code> method of the
<code>cond_indirect_effects</code>-class object.
</p>
<p>If bootstrapping confidence intervals
were requested, this method has the
option to print
<em>p</em>-values computed by the
method presented in Asparouhov and Muthn (2021).
Note that these <em>p</em>-values are asymmetric
bootstrap <em>p</em>-values based on the
distribution of the bootstrap estimates.
They not computed based on the
distribution under the null hypothesis.
</p>
<p>For a <em>p</em>-value of <em>a</em>, it means that
a 100(1 - <em>a</em>)% bootstrapping confidence
interval
will have one of its limits equal to
0. A confidence interval
with a higher confidence level will
include zero, while a confidence
interval with a lower confidence level
will exclude zero.
</p>


<h3>Value</h3>

<p><code>x</code> is returned invisibly.
Called for its side effect.
</p>


<h3>References</h3>

<p>Asparouhov, A., &amp; Muthn, B. (2021). Bootstrap p-value computation.
Retrieved from https://www.statmodel.com/download/FAQ-Bootstrap%20-%20Pvalue.pdf
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)
dat &lt;- modmed_x1m3w4y1
mod &lt;-
"
m1 ~ a1 * x  + d1 * w1 + e1 * x:w1
m2 ~ a2 * x
y  ~ b1 * m1 + b2 * m2 + cp * x
"
fit &lt;- sem(mod, dat,
           meanstructure = TRUE, fixed.x = FALSE, se = "none", baseline = FALSE)

# Conditional effects from x to m1 when w1 is equal to each of the default levels
cond_indirect_effects(x = "x", y = "m1",
                      wlevels = "w1", fit = fit)

# Conditional Indirect effect from x1 through m1 to y,
# when w1 is equal to each of the default levels
out &lt;- cond_indirect_effects(x = "x", y = "y", m = "m1",
                      wlevels = "w1", fit = fit)
out

print(out, digits = 5)

print(out, annotation = FALSE)


</code></pre>

<hr>
<h2 id='print.delta_med'>Print a 'delta_med' Class Object</h2><span id='topic+print.delta_med'></span>

<h3>Description</h3>

<p>Print the content of
a <code>delta_med</code>-class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'delta_med'
print(x, digits = 3, level = NULL, full = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.delta_med_+3A_x">x</code></td>
<td>
<p>A <code>delta_med</code>-class object.</p>
</td></tr>
<tr><td><code id="print.delta_med_+3A_digits">digits</code></td>
<td>
<p>The number of digits
after the decimal. Default is 3.</p>
</td></tr>
<tr><td><code id="print.delta_med_+3A_level">level</code></td>
<td>
<p>The level of confidence
of bootstrap confidence interval,
if requested when created. If <code>NULL</code>,
the default, the level requested when
calling <code><a href="#topic+delta_med">delta_med()</a></code> is used. If
not null, then this level will be
used.</p>
</td></tr>
<tr><td><code id="print.delta_med_+3A_full">full</code></td>
<td>
<p>Logical. Whether
additional information will be printed.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="print.delta_med_+3A_...">...</code></td>
<td>
<p>Optional arguments.
Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It prints the output of
<code>delta_med()</code>, which is a
<code>delta_med</code>-class object.
</p>


<h3>Value</h3>

<p><code>x</code> is returned invisibly. Called
for its side effect.
</p>


<h3>Author(s)</h3>

<p>Shu Fai Cheung <a href="https://orcid.org/0000-0002-9871-9448">https://orcid.org/0000-0002-9871-9448</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+delta_med">delta_med()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)
dat &lt;- data_med
mod &lt;-
"
m ~ x
y ~ m + x
"
fit &lt;- sem(mod, dat)
dm &lt;- delta_med(x = "x",
                y = "y",
                m = "m",
                fit = fit)
dm
print(dm, full = TRUE)

# Call do_boot() to generate
# bootstrap estimates
# Use 2000 or even 5000 for R in real studies
# Set parallel to TRUE in real studies for faster bootstrapping
boot_out &lt;- do_boot(fit,
                    R = 45,
                    seed = 879,
                    parallel = FALSE,
                    progress = FALSE)
# Remove 'progress = FALSE' in practice
dm_boot &lt;- delta_med(x = "x",
                     y = "y",
                     m = "m",
                     fit = fit,
                     boot_out = boot_out,
                     progress = FALSE)
dm_boot
confint(dm_boot)
confint(dm_boot,
        level = .90)

</code></pre>

<hr>
<h2 id='print.indirect'>Print an 'indirect' Class
Object</h2><span id='topic+print.indirect'></span>

<h3>Description</h3>

<p>Print the content of the
output of <code><a href="#topic+indirect_effect">indirect_effect()</a></code> or
<code><a href="#topic+cond_indirect">cond_indirect()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'indirect'
print(x, digits = 3, pvalue = FALSE, pvalue_digits = 3, se = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.indirect_+3A_x">x</code></td>
<td>
<p>The output of
<code><a href="#topic+indirect_effect">indirect_effect()</a></code> or
<code><a href="#topic+cond_indirect">cond_indirect()</a></code>.</p>
</td></tr>
<tr><td><code id="print.indirect_+3A_digits">digits</code></td>
<td>
<p>Number of digits to
display. Default is 3.</p>
</td></tr>
<tr><td><code id="print.indirect_+3A_pvalue">pvalue</code></td>
<td>
<p>Logical. If <code>TRUE</code>,
asymmetric <em>p</em>-value based on
bootstrapping will be printed if
available.</p>
</td></tr>
<tr><td><code id="print.indirect_+3A_pvalue_digits">pvalue_digits</code></td>
<td>
<p>Number of decimal
places to display for the <em>p</em>-value.
Default is 3.</p>
</td></tr>
<tr><td><code id="print.indirect_+3A_se">se</code></td>
<td>
<p>Logical. If <code>TRUE</code> and
confidence interval is available, the
standard error of the estimate is
also printed. This is simply the
standard deviation of the bootstrap
estimates or Monte Carlo simulated
values, depending on the method used
to form the confidence interval.</p>
</td></tr>
<tr><td><code id="print.indirect_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>print</code> method of the
<code>indirect</code>-class object.
</p>
<p>If bootstrapping confidence interval
was requested, this method has the
option to print a
<em>p</em>-value computed by the
method presented in Asparouhov and Muthn (2021).
Note that this <em>p</em>-value is asymmetric
bootstrap <em>p</em>-value based on the
distribution of the bootstrap estimates.
It is not computed based on the
distribution under the null hypothesis.
</p>
<p>For a <em>p</em>-value of <em>a</em>, it means that
a 100(1 - <em>a</em>)% bootstrapping confidence
interval
will have one of its limits equal to
0. A confidence interval
with a higher confidence level will
include zero, while a confidence
interval with a lower confidence level
will exclude zero.
</p>
<p>We recommend using confidence interval
directly. Therefore, <em>p</em>-value is not
printed by default. Nevertheless,
users who need it can request it
by setting <code>pvalue</code> to <code>TRUE</code>.
</p>


<h3>Value</h3>

<p><code>x</code> is returned invisibly.
Called for its side effect.
</p>


<h3>References</h3>

<p>Asparouhov, A., &amp; Muthn, B. (2021). Bootstrap p-value computation.
Retrieved from https://www.statmodel.com/download/FAQ-Bootstrap%20-%20Pvalue.pdf
</p>


<h3>See Also</h3>

<p><code><a href="#topic+indirect_effect">indirect_effect()</a></code> and
<code><a href="#topic+cond_indirect">cond_indirect()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)
dat &lt;- modmed_x1m3w4y1
mod &lt;-
"
m1 ~ a1 * x   + b1 * w1 + d1 * x:w1
m2 ~ a2 * m1  + b2 * w2 + d2 * m1:w2
m3 ~ a3 * m2  + b3 * w3 + d3 * m2:w3
y  ~ a4 * m3  + b4 * w4 + d4 * m3:w4
"
fit &lt;- sem(mod, dat,
           meanstructure = TRUE, fixed.x = FALSE,
           se = "none", baseline = FALSE)
est &lt;- parameterEstimates(fit)

wvalues &lt;- c(w1 = 5, w2 = 4, w3 = 2, w4 = 3)

indirect_1 &lt;- cond_indirect(x = "x", y = "y",
                            m = c("m1", "m2", "m3"),
                            fit = fit,
                            wvalues = wvalues)
indirect_1

dat &lt;- modmed_x1m3w4y1
mod2 &lt;-
"
m1 ~ a1 * x
m2 ~ a2 * m1
m3 ~ a3 * m2
y  ~ a4 * m3 + x
"
fit2 &lt;- sem(mod2, dat,
            meanstructure = TRUE, fixed.x = FALSE,
            se = "none", baseline = FALSE)
est &lt;- parameterEstimates(fit)

indirect_2 &lt;- indirect_effect(x = "x", y = "y",
                              m = c("m1", "m2", "m3"),
                              fit = fit2)
indirect_2
print(indirect_2, digits = 5)


</code></pre>

<hr>
<h2 id='print.indirect_list'>Print an 'indirect_list' Class
Object</h2><span id='topic+print.indirect_list'></span>

<h3>Description</h3>

<p>Print the content of the
output of <code><a href="#topic+many_indirect_effects">many_indirect_effects()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'indirect_list'
print(
  x,
  digits = 3,
  annotation = TRUE,
  pvalue = FALSE,
  pvalue_digits = 3,
  se = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.indirect_list_+3A_x">x</code></td>
<td>
<p>The output of
<code><a href="#topic+many_indirect_effects">many_indirect_effects()</a></code>.</p>
</td></tr>
<tr><td><code id="print.indirect_list_+3A_digits">digits</code></td>
<td>
<p>Number of digits to
display. Default is 3.</p>
</td></tr>
<tr><td><code id="print.indirect_list_+3A_annotation">annotation</code></td>
<td>
<p>Logical. Whether
the annotation after the table of
effects is to be printed. Default is
<code>TRUE.</code></p>
</td></tr>
<tr><td><code id="print.indirect_list_+3A_pvalue">pvalue</code></td>
<td>
<p>Logical. If <code>TRUE</code>,
asymmetric <em>p</em>-values based on
bootstrapping will be printed if
available.</p>
</td></tr>
<tr><td><code id="print.indirect_list_+3A_pvalue_digits">pvalue_digits</code></td>
<td>
<p>Number of decimal
places to display for the <em>p</em>-values.
Default is 3.</p>
</td></tr>
<tr><td><code id="print.indirect_list_+3A_se">se</code></td>
<td>
<p>Logical. If <code>TRUE</code> and
confidence intervals are available,
the standard errors of the estimates
are also printed. They are simply the
standard deviations of the bootstrap
estimates or Monte Carlo simulated
values, depending on the method used
to form the confidence intervals.</p>
</td></tr>
<tr><td><code id="print.indirect_list_+3A_...">...</code></td>
<td>
<p>Other arguments. Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>print</code> method of the
<code>indirect_list</code>-class object.
</p>
<p>If bootstrapping confidence interval
was requested, this method has the
option to print a
<em>p</em>-value computed by the
method presented in Asparouhov and Muthn (2021).
Note that this <em>p</em>-value is asymmetric
bootstrap <em>p</em>-value based on the
distribution of the bootstrap estimates.
It is not computed based on the
distribution under the null hypothesis.
</p>
<p>For a <em>p</em>-value of <em>a</em>, it means that
a 100(1 - <em>a</em>)% bootstrapping confidence
interval
will have one of its limits equal to
0. A confidence interval
with a higher confidence level will
include zero, while a confidence
interval with a lower confidence level
will exclude zero.
</p>


<h3>Value</h3>

<p><code>x</code> is returned invisibly.
Called for its side effect.
</p>


<h3>References</h3>

<p>Asparouhov, A., &amp; Muthn, B. (2021). Bootstrap p-value computation.
Retrieved from https://www.statmodel.com/download/FAQ-Bootstrap%20-%20Pvalue.pdf
</p>


<h3>See Also</h3>

<p><code><a href="#topic+many_indirect_effects">many_indirect_effects()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)
data(data_serial_parallel)
mod &lt;-
"
m11 ~ x + c1 + c2
m12 ~ m11 + x + c1 + c2
m2 ~ x + c1 + c2
y ~ m12 + m2 + m11 + x + c1 + c2
"
fit &lt;- sem(mod, data_serial_parallel,
           fixed.x = FALSE)
# All indirect paths from x to y
paths &lt;- all_indirect_paths(fit,
                           x = "x",
                           y = "y")
paths
# Indirect effect estimates
out &lt;- many_indirect_effects(paths,
                             fit = fit)
out


</code></pre>

<hr>
<h2 id='print.indirect_proportion'>Print an 'indirect_proportion'-Class
Object</h2><span id='topic+print.indirect_proportion'></span>

<h3>Description</h3>

<p>Print the content of an
'indirect_proportion'-class object,
the output of <code><a href="#topic+indirect_proportion">indirect_proportion()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'indirect_proportion'
print(x, digits = 3, annotation = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.indirect_proportion_+3A_x">x</code></td>
<td>
<p>An 'indirect_proportion'-class
object.</p>
</td></tr>
<tr><td><code id="print.indirect_proportion_+3A_digits">digits</code></td>
<td>
<p>Number of digits to
display. Default is 3.</p>
</td></tr>
<tr><td><code id="print.indirect_proportion_+3A_annotation">annotation</code></td>
<td>
<p>Logical. Whether
additional information should be
printed. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="print.indirect_proportion_+3A_...">...</code></td>
<td>
<p>Optional arguments.
Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>print</code> method of the
<code>indirect_proportion</code>-class object,
which is produced by
<code><a href="#topic+indirect_proportion">indirect_proportion()</a></code>. In addition
to the proportion of effect
mediated, it also prints additional
information such as the path for
which the proportion is computed,
and all indirect path(s) from the
x-variable to the y-variable.
</p>
<p>To get the proportion as a scalar,
use the <code>coef</code> method of
<code>indirect_proportion</code> objects.
</p>


<h3>Value</h3>

<p><code>x</code> is returned invisibly. Called for
its side effect.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+indirect_proportion">indirect_proportion()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)
dat &lt;- data_med
head(dat)
mod &lt;-
"
m ~ x + c1 + c2
y ~ m + x + c1 + c2
"
fit &lt;- sem(mod, dat, fixed.x = FALSE)
out &lt;- indirect_proportion(x = "x",
                           y = "y",
                           m = "m",
                           fit = fit)
out
print(out, digits = 5)


</code></pre>

<hr>
<h2 id='print.lm_list'>Print an <code>lm_list</code>-Class
Object</h2><span id='topic+print.lm_list'></span>

<h3>Description</h3>

<p>Print the content of the
output of <code><a href="#topic+lm2list">lm2list()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm_list'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.lm_list_+3A_x">x</code></td>
<td>
<p>The output of <code><a href="#topic+lm2list">lm2list()</a></code>.</p>
</td></tr>
<tr><td><code id="print.lm_list_+3A_...">...</code></td>
<td>
<p>Other arguments. Not
used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> is returned invisibly.
Called for its side effect.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(data_serial_parallel)
lm_m11 &lt;- lm(m11 ~ x + c1 + c2, data_serial_parallel)
lm_m12 &lt;- lm(m12 ~ m11 + x + c1 + c2, data_serial_parallel)
lm_m2 &lt;- lm(m2 ~ x + c1 + c2, data_serial_parallel)
lm_y &lt;- lm(y ~ m11 + m12 + m2 + x + c1 + c2, data_serial_parallel)
# Join them to form a lm_list-class object
lm_serial_parallel &lt;- lm2list(lm_m11, lm_m12, lm_m2, lm_y)
lm_serial_parallel

</code></pre>

<hr>
<h2 id='print.mc_out'>Print a <code>mc_out</code>-Class
Object</h2><span id='topic+print.mc_out'></span>

<h3>Description</h3>

<p>Print the content of the
output of <code><a href="#topic+do_mc">do_mc()</a></code> or related
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mc_out'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mc_out_+3A_x">x</code></td>
<td>
<p>The output of <code><a href="#topic+do_mc">do_mc()</a></code>,
or any <code>mc_out</code>-class object
returned
by similar functions.</p>
</td></tr>
<tr><td><code id="print.mc_out_+3A_...">...</code></td>
<td>
<p>Other arguments. Not
used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> is returned invisibly.
Called for its side effect.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)
data(data_med_mod_ab1)
dat &lt;- data_med_mod_ab1
mod &lt;-
"
m ~ x + w + x:w + c1 + c2
y ~ m + w + m:w + x + c1 + c2
"
fit &lt;- sem(mod, dat)
# In real research, R should be 5000 or even 10000
mc_out &lt;- do_mc(fit, R = 100, seed = 1234)

# Print the output of do_boot()
mc_out

</code></pre>

<hr>
<h2 id='simple_mediation_latent'>Sample Dataset: A Simple
Latent Mediation Model</h2><span id='topic+simple_mediation_latent'></span>

<h3>Description</h3>

<p>Generated from a simple
mediation model among xthree latent
factors, <code>fx</code>, <code>fm</code>, and <code>fy</code>, xeach
has three indicators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simple_mediation_latent
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 rows
and 11 variables:
</p>

<dl>
<dt>x1</dt><dd><p>Indicator of <code>fx</code>. Numeric.</p>
</dd>
<dt>x2</dt><dd><p>Indicator of <code>fx</code>. Numeric.</p>
</dd>
<dt>x3</dt><dd><p>Indicator of <code>fx</code>. Numeric.</p>
</dd>
<dt>m1</dt><dd><p>Indicator of <code>fm</code>. Numeric.</p>
</dd>
<dt>m2</dt><dd><p>Indicator of <code>fm</code>. Numeric.</p>
</dd>
<dt>m3</dt><dd><p>Indicator of <code>fm</code>. Numeric.</p>
</dd>
<dt>y1</dt><dd><p>Indicator of <code>fy</code>. Numeric.</p>
</dd>
<dt>y2</dt><dd><p>Indicator of <code>fy</code>. Numeric.</p>
</dd>
<dt>y3</dt><dd><p>Indicator of <code>fy</code>. Numeric.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The model:
</p>
<div class="sourceCode"><pre>fx =~ x1 + x2 + x3
fm =~ m1 + m2 + m3
fy =~ y1 + y2 + y3
fm ~ a * fx
fy ~ b * fm + cp * fx
indirect := a * b
</pre></div>

<hr>
<h2 id='subsetting_cond_indirect_effects'>Extraction Methods for
'cond_indirect_effects' Outputs</h2><span id='topic+subsetting_cond_indirect_effects'></span><span id='topic++5B.cond_indirect_effects'></span>

<h3>Description</h3>

<p>For subsetting a
'cond_indirect_effects'-class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cond_indirect_effects'
x[i, j, drop = if (missing(i)) TRUE else length(j) == 1]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsetting_cond_indirect_effects_+3A_x">x</code></td>
<td>
<p>A
'cond_indirect_effects'-class object.</p>
</td></tr>
<tr><td><code id="subsetting_cond_indirect_effects_+3A_i">i</code></td>
<td>
<p>A numeric vector of row
number(s), a character vector of row
name(s), or a logical vector of
row(s) to be selected.</p>
</td></tr>
<tr><td><code id="subsetting_cond_indirect_effects_+3A_j">j</code></td>
<td>
<p>A numeric vector of column
number(s), a character vector of
column name(s), or a logical vector
of column(s) to be selected.</p>
</td></tr>
<tr><td><code id="subsetting_cond_indirect_effects_+3A_drop">drop</code></td>
<td>
<p>Whether dropping a
dimension if it only have one
row/column.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Customized <code>[</code> for
'cond_indirect_effects'-class
objects, to ensure that these
operations work as they would be on a
data frame object, while information
specific to conditional effects is
modified correctly.
</p>


<h3>Value</h3>

<p>A
'cond_indirect_effects'-class object.
See <code><a href="#topic+cond_indirect_effects">cond_indirect_effects()</a></code> for
details on this class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)
dat &lt;- modmed_x1m3w4y1
mod &lt;-
"
m1 ~ x  + w1 + x:w1
m2 ~ m1
y  ~ m2 + x + w4 + m2:w4
"
fit &lt;- sem(mod, dat, meanstructure = TRUE, fixed.x = FALSE, se = "none", baseline = FALSE)
est &lt;- parameterEstimates(fit)

# Examples for cond_indirect():

# Conditional effects from x to m1 when w1 is equal to each of the levels
out1 &lt;- cond_indirect_effects(x = "x", y = "m1",
                      wlevels = "w1", fit = fit)
out1[2, ]

# Conditional Indirect effect from x1 through m1 to y,
# when w1 is equal to each of the levels
out2 &lt;- cond_indirect_effects(x = "x", y = "y", m = c("m1", "m2"),
                      wlevels = c("w1", "w4"), fit = fit)
out2[c(1, 3), ]

</code></pre>

<hr>
<h2 id='subsetting_wlevels'>Extraction Methods for a
'wlevels'-class Object</h2><span id='topic+subsetting_wlevels'></span><span id='topic++5B.wlevels'></span><span id='topic++5B+3C-.wlevels'></span><span id='topic++5B+5B+3C-.wlevels'></span>

<h3>Description</h3>

<p>For subsetting a
'wlevels'-class object. Attributes
related to the levels will be
preserved if appropriate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wlevels'
x[i, j, drop = if (missing(i)) TRUE else length(j) == 1]

## S3 replacement method for class 'wlevels'
x[i, j] &lt;- value

## S3 replacement method for class 'wlevels'
x[[i, j]] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsetting_wlevels_+3A_x">x</code></td>
<td>
<p>A 'wlevels'-class object.</p>
</td></tr>
<tr><td><code id="subsetting_wlevels_+3A_i">i</code></td>
<td>
<p>A numeric vector of row
number(s), a character vector of row
name(s), or a logical vector of
row(s) to be selected.</p>
</td></tr>
<tr><td><code id="subsetting_wlevels_+3A_j">j</code></td>
<td>
<p>A numeric vector of column
number(s), a character vector of
column name(s), or a logical vector
of column(s) to be selected.</p>
</td></tr>
<tr><td><code id="subsetting_wlevels_+3A_drop">drop</code></td>
<td>
<p>Whether dropping a
dimension if it only have one
row/column.</p>
</td></tr>
<tr><td><code id="subsetting_wlevels_+3A_value">value</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Customized <code>[</code> for
'wlevels'-class objects, to ensure
that these operations work as they
would be on a data frame object,
while information specific to a
<code>wlevels</code>-class object modified
correctly.
</p>
<p>The assignment methods <code style="white-space: pre;">&#8288;[&lt;-&#8288;</code>
and <code style="white-space: pre;">&#8288;[[&lt;-&#8288;</code> for
<code>wlevels</code>-class objects will raise an
error. This class of objects should
be created by <code><a href="#topic+mod_levels">mod_levels()</a></code> or
related functions.
</p>
<p>Subsetting the output of
<code><a href="#topic+mod_levels">mod_levels()</a></code> is possible but not
recommended. It is more reliable to
generate the levels using
<code><a href="#topic+mod_levels">mod_levels()</a></code> and related functions.
Nevertheless, there are situations in
which subsetting is preferred.
</p>


<h3>Value</h3>

<p>A 'wlevels'-class object. See
<code><a href="#topic+mod_levels">mod_levels()</a></code> and
<code><a href="#topic+merge_mod_levels">merge_mod_levels()</a></code> for details on
this class.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mod_levels">mod_levels()</a></code>,
<code><a href="#topic+mod_levels_list">mod_levels_list()</a></code>, and
<code><a href="#topic+merge_mod_levels">merge_mod_levels()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(data_med_mod_ab)
dat &lt;- data_med_mod_ab
# Form the levels from a list of lm() outputs
lm_m &lt;- lm(m ~ x*w1 + c1 + c2, dat)
lm_y &lt;- lm(y ~ m*w2 + x + w1 + c1 + c2, dat)
lm_out &lt;- lm2list(lm_m, lm_y)
w1_levels &lt;- mod_levels(lm_out, w = "w1")
w1_levels
w1_levels[2, ]
w1_levels[c(2, 3), ]

dat &lt;- data_med_mod_serial_cat
lm_m1 &lt;- lm(m1 ~ x*w1 + c1 + c2, dat)
lm_y &lt;- lm(y ~ m1 + x + w1 + c1 + c2, dat)
lm_out &lt;- lm2list(lm_m1, lm_y)
w1gp_levels &lt;- mod_levels(lm_out, w = "w1")
w1gp_levels
w1gp_levels[2, ]
w1gp_levels[3, ]

merged_levels &lt;- merge_mod_levels(w1_levels, w1gp_levels)
merged_levels

merged_levels[4:6, ]
merged_levels[1:3, c(2, 3)]
merged_levels[c(1, 4, 7), 1, drop = FALSE]

</code></pre>

<hr>
<h2 id='summary.lm_list'>Summary of an <code>lm_list</code>-Class
Object</h2><span id='topic+summary.lm_list'></span><span id='topic+print.summary_lm_list'></span>

<h3>Description</h3>

<p>The summary of content
of the output of <code><a href="#topic+lm2list">lm2list()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm_list'
summary(object, ...)

## S3 method for class 'summary_lm_list'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.lm_list_+3A_object">object</code></td>
<td>
<p>The output of
<code><a href="#topic+lm2list">lm2list()</a></code>.</p>
</td></tr>
<tr><td><code id="summary.lm_list_+3A_...">...</code></td>
<td>
<p>Other arguments. Not
used.</p>
</td></tr>
<tr><td><code id="summary.lm_list_+3A_x">x</code></td>
<td>
<p>An object of class
<code>summary_lm_list</code>.</p>
</td></tr>
<tr><td><code id="summary.lm_list_+3A_digits">digits</code></td>
<td>
<p>The number of
significant digits in printing
numerical results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+summary.lm_list">summary.lm_list()</a></code> returns a
<code>summary_lm_list</code>-class object, which
is a list of the <code><a href="base.html#topic+summary">summary()</a></code> outputs
of the <code><a href="stats.html#topic+lm">lm()</a></code> outputs stored.
</p>
<p><code><a href="#topic+print.summary_lm_list">print.summary_lm_list()</a></code> returns <code>x</code>
invisibly. Called for its side
effect.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>print(summary_lm_list)</code>: Print
method for output of summary for
lm_list.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
data(data_serial_parallel)
lm_m11 &lt;- lm(m11 ~ x + c1 + c2, data_serial_parallel)
lm_m12 &lt;- lm(m12 ~ m11 + x + c1 + c2, data_serial_parallel)
lm_m2 &lt;- lm(m2 ~ x + c1 + c2, data_serial_parallel)
lm_y &lt;- lm(y ~ m11 + m12 + m2 + x + c1 + c2, data_serial_parallel)
# Join them to form a lm_list-class object
lm_serial_parallel &lt;- lm2list(lm_m11, lm_m12, lm_m2, lm_y)
lm_serial_parallel
summary(lm_serial_parallel)

</code></pre>

<hr>
<h2 id='terms.lm_from_lavaan'>Model Terms of an
'lm_from_lavaan'-Class Object</h2><span id='topic+terms.lm_from_lavaan'></span>

<h3>Description</h3>

<p>It extracts the terms
object from an <code>lm_from_lavaan</code>-class
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm_from_lavaan'
terms(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="terms.lm_from_lavaan_+3A_x">x</code></td>
<td>
<p>An 'lm_from_lavaan'-class
object.</p>
</td></tr>
<tr><td><code id="terms.lm_from_lavaan_+3A_...">...</code></td>
<td>
<p>Additional arguments.
Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A method for
<code>lm_from_lavaan</code>-class that converts
a regression model for a variable in
a <code>lavaan</code> model to a <code>formula</code>
object. This function simply calls
<code><a href="stats.html#topic+terms">stats::terms()</a></code> on the <code>formula</code>
object to extract the predictors of a
variable.
</p>


<h3>Value</h3>

<p>A <code>terms</code>-class object. See
<a href="stats.html#topic+terms.object">terms.object</a> for details.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+terms.object">terms.object</a>,
<code><a href="#topic+lm_from_lavaan_list">lm_from_lavaan_list()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
data(data_med)
mod &lt;-
"
m ~ a * x + c1 + c2
y ~ b * m + x + c1 + c2
"
fit &lt;- sem(mod, data_med, fixed.x = FALSE)
fit_list &lt;- lm_from_lavaan_list(fit)
terms(fit_list$m)
terms(fit_list$y)

</code></pre>

<hr>
<h2 id='total_indirect_effect'>Total Indirect Effect Between
Two Variables</h2><span id='topic+total_indirect_effect'></span>

<h3>Description</h3>

<p>Compute the total
indirect effect between two
variables in the paths estimated by
<code><a href="#topic+many_indirect_effects">many_indirect_effects()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>total_indirect_effect(object, x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="total_indirect_effect_+3A_object">object</code></td>
<td>
<p>The output of
<code><a href="#topic+many_indirect_effects">many_indirect_effects()</a></code>, or a list
of <code>indirect</code>-class objects.</p>
</td></tr>
<tr><td><code id="total_indirect_effect_+3A_x">x</code></td>
<td>
<p>Character. The name of the <code>x</code> variable.
All paths start from <code>x</code> will be
included.</p>
</td></tr>
<tr><td><code id="total_indirect_effect_+3A_y">y</code></td>
<td>
<p>Character. The name of the <code>y</code> variable.
All paths end at <code>y</code> will be included.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It extracts the
<code>indirect</code>-class objects
of relevant paths and then add
the indirect effects together
using the <code>+</code> operator.
</p>


<h3>Value</h3>

<p>An <code>indirect</code>-class
object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+many_indirect_effects">many_indirect_effects()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)
data(data_serial_parallel)
mod &lt;-
"
m11 ~ x + c1 + c2
m12 ~ m11 + x + c1 + c2
m2 ~ x + c1 + c2
y ~ m12 + m2 + m11 + x + c1 + c2
"
fit &lt;- sem(mod, data_serial_parallel,
           fixed.x = FALSE)

# All indirect paths, control variables excluded
paths &lt;- all_indirect_paths(fit,
                            exclude = c("c1", "c2"))
paths

# Indirect effect estimates
out &lt;- many_indirect_effects(paths,
                             fit = fit)
out

# Total indirect effect from x to y
total_indirect_effect(out,
                      x = "x",
                      y = "y")


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
