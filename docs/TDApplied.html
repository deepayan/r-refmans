<!DOCTYPE html><html><head><title>Help for package TDApplied</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TDApplied}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#analyze_representatives'><p>Analyze the data point memberships of multiple representative (co)cycles.</p></a></li>
<li><a href='#bootstrap_persistence_thresholds'><p>Estimate persistence threshold(s) for topological features in a data set using bootstrapping.</p></a></li>
<li><a href='#check_PyH_setup'><p>Make sure that python has been configured correctly for persistent homology calculations.</p></a></li>
<li><a href='#check_ripser'><p>Verify an imported ripser module.</p></a></li>
<li><a href='#diagram_distance'><p>Calculate distance between a pair of persistence diagrams.</p></a></li>
<li><a href='#diagram_kernel'><p>Calculate persistence Fisher kernel value between a pair of persistence diagrams.</p></a></li>
<li><a href='#diagram_kkmeans'><p>Cluster a group of persistence diagrams using kernel k-means.</p></a></li>
<li><a href='#diagram_kpca'><p>Calculate the kernel PCA embedding of a group of persistence diagrams.</p></a></li>
<li><a href='#diagram_ksvm'><p>Fit a support vector machine model where each training set instance is a persistence diagram.</p></a></li>
<li><a href='#diagram_mds'><p>Dimension reduction of a group of persistence diagrams via metric multidimensional scaling.</p></a></li>
<li><a href='#diagram_to_df'><p>Convert a TDA/TDAstats persistence diagram to a data frame.</p></a></li>
<li><a href='#distance_matrix'><p>Compute a distance matrix from a list of persistence diagrams.</p></a></li>
<li><a href='#gram_matrix'><p>Compute the gram matrix for a group of persistence diagrams.</p></a></li>
<li><a href='#import_ripser'><p>Import the python module ripser.</p></a></li>
<li><a href='#independence_test'><p>Independence test for two groups of persistence diagrams.</p></a></li>
<li><a href='#loss'><p>Turner loss function for a list of groups (lists) of persistence diagrams.</p></a></li>
<li><a href='#permutation_test'><p>Permutation test for finding group differences between persistence diagrams.</p></a></li>
<li><a href='#plot_diagram'><p>Plot persistence diagrams</p></a></li>
<li><a href='#plot_vr_graph'><p>Plot a VR graph using the igraph package.</p></a></li>
<li><a href='#predict_diagram_kkmeans'><p>Predict the cluster labels for new persistence diagrams using a pre-computed clustering.</p></a></li>
<li><a href='#predict_diagram_kpca'><p>Project persistence diagrams into a low-dimensional space via a pre-computed kernel PCA embedding.</p></a></li>
<li><a href='#predict_diagram_ksvm'><p>Predict the outcome labels for a list of persistence diagrams using a pre-trained diagram ksvm model.</p></a></li>
<li><a href='#PyH'><p>Fast persistent homology calculations with python.</p></a></li>
<li><a href='#TDApplied-package'><p>TDApplied: Machine Learning and Inference for Topological Data Analysis</p></a></li>
<li><a href='#vr_graphs'><p>Compute Vietoris-Rips graphs of a dataset at particular epsilon radius values.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Machine Learning and Inference for Topological Data Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Shael Brown [aut, cre],
  Dr. Reza Farivar [aut, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Shael Brown &lt;shaelebrown@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Topological data analysis is a powerful tool for finding non-linear global structure
    in whole datasets. The main tool of topological data analysis is persistent homology, which computes
    a topological shape descriptor of a dataset called a persistence diagram. 'TDApplied' provides 
    useful and efficient methods for analyzing groups of persistence diagrams with machine learning and statistical inference,
    and these functions can also interface with other data science packages to form flexible and integrated
    topological data analysis pipelines.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, doParallel, foreach, clue, rdist, parallelly,
kernlab, iterators, methods, stats, utils, Rcpp (&ge; 0.11.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/shaelebrown/TDApplied">https://github.com/shaelebrown/TDApplied</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/shaelebrown/TDApplied/issues">https://github.com/shaelebrown/TDApplied/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, testthat (&ge; 3.0.0), TDAstats, reticulate,
igraph</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-12 22:37:01 UTC; jibaccount</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-12 23:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='analyze_representatives'>Analyze the data point memberships of multiple representative (co)cycles.</h2><span id='topic+analyze_representatives'></span>

<h3>Description</h3>

<p>Multiple distance matrices with corresponding data points can contain the same topological features. 
Therefore we may wish to compare many representative (co)cycles across distance matrices to decide if their topological features are the same.
The 'analyze_representatives' function returns a matrix of binary datapoint memberships in an input list of representatives across distance matrices.
Optionally this matrix can be plotted as a heatmap with columns as data points and rows (i.e. representatives) reordered by similarity, and the 
contributions (i.e. percentage membership) of each point in the representatives can also be returned. The heatmap has
dark red squares representing membership - location [i,j] is dark red if data point j is in representative i.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze_representatives(
  diagrams,
  dim,
  num_points,
  plot_heatmap = TRUE,
  return_contributions = FALSE,
  boxed_reps = NULL,
  d = NULL,
  lwd = NULL,
  title = NULL,
  return_clust = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyze_representatives_+3A_diagrams">diagrams</code></td>
<td>
<p>a list of persistence diagrams, either the output of persistent homology calculations like ripsDiag/<code><a href="TDAstats.html#topic+calculate_homology">calculate_homology</a></code>/<code><a href="#topic+PyH">PyH</a></code>, <code><a href="#topic+diagram_to_df">diagram_to_df</a></code> or <code><a href="#topic+bootstrap_persistence_thresholds">bootstrap_persistence_thresholds</a></code>.</p>
</td></tr>
<tr><td><code id="analyze_representatives_+3A_dim">dim</code></td>
<td>
<p>the integer homological dimension of representatives to consider.</p>
</td></tr>
<tr><td><code id="analyze_representatives_+3A_num_points">num_points</code></td>
<td>
<p>the integer number of data points in all the original datasets (from which the diagrams were calculated).</p>
</td></tr>
<tr><td><code id="analyze_representatives_+3A_plot_heatmap">plot_heatmap</code></td>
<td>
<p>a boolean representing if a heatmap of data point membership similarity of the representatives should be plotted, default 'TRUE'. A dendrogram of hierarchical clustering is plotted, and rows (representatives) are sorted according to this clustering.</p>
</td></tr>
<tr><td><code id="analyze_representatives_+3A_return_contributions">return_contributions</code></td>
<td>
<p>a boolean indicating whether or not to return the membership contributions (i.e. percentages) of the data points (1:'num_points') across all the representatives, default 'FALSE'.</p>
</td></tr>
<tr><td><code id="analyze_representatives_+3A_boxed_reps">boxed_reps</code></td>
<td>
<p>a data frame specifying specific rows of the output heatmap which should have a box drawn around them (for highlighting), default NULL. See the details section for more information.</p>
</td></tr>
<tr><td><code id="analyze_representatives_+3A_d">d</code></td>
<td>
<p>either NULL (default) or a &quot;dist&quot; object representing a distance matrix for the representatives, which must have the same number of rows and columns as cycles in the dimension 'dim'.</p>
</td></tr>
<tr><td><code id="analyze_representatives_+3A_lwd">lwd</code></td>
<td>
<p>a positive number width for the lines of drawn boxes, if boxed_reps is not null.</p>
</td></tr>
<tr><td><code id="analyze_representatives_+3A_title">title</code></td>
<td>
<p>a character string title for the plotted heatmap, default NULL.</p>
</td></tr>
<tr><td><code id="analyze_representatives_+3A_return_clust">return_clust</code></td>
<td>
<p>a boolean determining whether or not to return the result of the 'stats::hclust()' call when a heatmap is plotted, default 'FALSE'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The clustering dendrogram can be used to determine if there are any similar groups of representatives (i.e.
shared topological features across datasets) and if so how many. The row labels of the heatmap are of the form
'DX[Y]', meaning the Yth representative of diagram X, and the column labels are the data point numbers.
If diagrams are the output of the <code><a href="#topic+bootstrap_persistence_thresholds">bootstrap_persistence_thresholds</a></code>
function, then the subsetted_representatives (if present) will be analyzed. Therefore, a column label like 'DX[Y]' in the 
plotted heatmap would mean the Yth representative of diagram X. If certain representatives should be highlighted (by drawing a box around its row)
in the heatmap, a dataframe &lsquo;boxed_reps' can be supplied with two integer columns - &rsquo;diagram' and 'rep'. For example, if we wish to draw a box for DX[Y] then we
add the row (diagram = X,rep = Y) to 'boxed_reps'. If 'd' is supplied then it will be used to cluster the representatives, based on the distances in 'd'.
</p>


<h3>Value</h3>

<p>either a matrix of data point contributions to the representatives, or a list with elements &quot;memberships&quot; (the matrix) and some combination of elements &quot;contributions&quot; (a vector of membership percentages for each data point across representatives) and &quot;clust&quot; (the results of 'stats::hclust()' on the membership matrix).
</p>


<h3>Author(s)</h3>

<p>Shael Brown - <a href="mailto:shaelebrown@gmail.com">shaelebrown@gmail.com</a>
</p>

<hr>
<h2 id='bootstrap_persistence_thresholds'>Estimate persistence threshold(s) for topological features in a data set using bootstrapping.</h2><span id='topic+bootstrap_persistence_thresholds'></span>

<h3>Description</h3>

<p>Bootstrapping is used to find a conservative estimate of a 1-'alpha' percent &quot;confidence interval&quot; around
each point in the persistence diagram of the data set, and points whose intervals do not
touch the diagonal (birth == death) would be considered &quot;significant&quot; or &quot;real&quot;.
One threshold is computed for each dimension in the diagram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap_persistence_thresholds(
  X,
  FUN_diag = "calculate_homology",
  FUN_boot = "calculate_homology",
  maxdim = 0,
  thresh,
  distance_mat = FALSE,
  ripser = NULL,
  ignore_infinite_cluster = TRUE,
  calculate_representatives = FALSE,
  num_samples = 30,
  alpha = 0.05,
  return_subsetted = FALSE,
  return_pvals = FALSE,
  return_diag = TRUE,
  num_workers = parallelly::availableCores(omit = 1),
  p_less_than_alpha = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap_persistence_thresholds_+3A_x">X</code></td>
<td>
<p>the input dataset, must either be a matrix or data frame.</p>
</td></tr>
<tr><td><code id="bootstrap_persistence_thresholds_+3A_fun_diag">FUN_diag</code></td>
<td>
<p>a string representing the persistent homology function to use for calculating the full persistence diagram, either
'calculate_homology' (the default), 'PyH' or 'ripsDiag'.</p>
</td></tr>
<tr><td><code id="bootstrap_persistence_thresholds_+3A_fun_boot">FUN_boot</code></td>
<td>
<p>a string representing the persistent homology function to use for calculating the bootstrapped persistence diagrams, either
'calculate_homology' (the default), 'PyH' or 'ripsDiag'.</p>
</td></tr>
<tr><td><code id="bootstrap_persistence_thresholds_+3A_maxdim">maxdim</code></td>
<td>
<p>the integer maximum homological dimension for persistent homology, default 0.</p>
</td></tr>
<tr><td><code id="bootstrap_persistence_thresholds_+3A_thresh">thresh</code></td>
<td>
<p>the positive numeric maximum radius of the Vietoris-Rips filtration.</p>
</td></tr>
<tr><td><code id="bootstrap_persistence_thresholds_+3A_distance_mat">distance_mat</code></td>
<td>
<p>a boolean representing if 'X' is a distance matrix (TRUE) or not (FALSE, default).
dimensions together (TRUE, the default) or if one threshold should be calculated for each dimension separately (FALSE).</p>
</td></tr>
<tr><td><code id="bootstrap_persistence_thresholds_+3A_ripser">ripser</code></td>
<td>
<p>the imported ripser module when 'FUN_diag' or 'FUN_boot' is 'PyH'.</p>
</td></tr>
<tr><td><code id="bootstrap_persistence_thresholds_+3A_ignore_infinite_cluster">ignore_infinite_cluster</code></td>
<td>
<p>a boolean indicating whether or not to ignore the infinitely lived cluster when 'FUN_diag' or 'FUN_boot' is 'PyH'.</p>
</td></tr>
<tr><td><code id="bootstrap_persistence_thresholds_+3A_calculate_representatives">calculate_representatives</code></td>
<td>
<p>a boolean representing whether to calculate representative (co)cycles, default FALSE. Note that representatives cant be
calculated when using the 'calculate_homology' function.</p>
</td></tr>
<tr><td><code id="bootstrap_persistence_thresholds_+3A_num_samples">num_samples</code></td>
<td>
<p>the positive integer number of bootstrap samples, default 30.</p>
</td></tr>
<tr><td><code id="bootstrap_persistence_thresholds_+3A_alpha">alpha</code></td>
<td>
<p>the type-1 error threshold, default 0.05.</p>
</td></tr>
<tr><td><code id="bootstrap_persistence_thresholds_+3A_return_subsetted">return_subsetted</code></td>
<td>
<p>a boolean representing whether or not to return the subsetted persistence diagram (with or without representatives), default FALSE.</p>
</td></tr>
<tr><td><code id="bootstrap_persistence_thresholds_+3A_return_pvals">return_pvals</code></td>
<td>
<p>a boolean representing whether or not to return p-values for features in the subsetted diagram, default FALSE.</p>
</td></tr>
<tr><td><code id="bootstrap_persistence_thresholds_+3A_return_diag">return_diag</code></td>
<td>
<p>a boolean representing whether or not to return the calculated persistence diagram, default TRUE.</p>
</td></tr>
<tr><td><code id="bootstrap_persistence_thresholds_+3A_num_workers">num_workers</code></td>
<td>
<p>the integer number of cores used for parallelizing (over bootstrap samples), default one less the maximum amount of cores on the machine.</p>
</td></tr>
<tr><td><code id="bootstrap_persistence_thresholds_+3A_p_less_than_alpha">p_less_than_alpha</code></td>
<td>
<p>a boolean representing whether or not subset further and return only feature whose p-values are strictly less than 'alpha', default 'FALSE'. Note that this is not part of the original bootstrap procedure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The thresholds are then determined by calculating the 1-&lsquo;alpha&rsquo;' percentile of the bottleneck
distance values between the real persistence diagram and other diagrams obtained
by bootstrap resampling the data. Since 'ripsDiag' is the slowest homology engine but is the
only engine which calculates representative cycles (as opposed to co-cycles with 'PyH'), two
homology engines are input to this function - one to calculate the actual persistence diagram, 'FUN_diag'
(possibly with representative (co)cycles) and one to calculate the bootstrap diagrams, 'FUN_boot' (this should be
a faster engine, like 'calculate_homology' or 'PyH').
p-values can be calculated for any feature which survives the thresholding if both 'return_subsetted' and 'return_pvals' are 'TRUE', 
however these values may be larger than the original 'alpha' value in some cases. Note that this is not part of the original bootstrap procedure.
If stricter thresholding is desired,
or the p-values must be less than 'alpha', set 'p_less_than_alpha' to 'TRUE'. The minimum
possible p-value is always 1/('num_samples' + 1).
Note that since <code><a href="TDAstats.html#topic+calculate_homology">calculate_homology</a></code> 
can ignore the longest-lived cluster, fewer &quot;real&quot; clusters may be found. To avoid this possibility
try setting &lsquo;FUN_diag' equal to &rsquo;ripsDiag'. Please note that due to the TDA package no longer being available on CRAN,
if &lsquo;FUN_diag' or 'FUN_boot' are &rsquo;ripsDiag' then 'bootstrap_persistence_thresholds' will look for the ripsDiag function in the global environment, 
so the TDA package should be attached with 'library(&quot;TDA&quot;)' prior to use.
</p>


<h3>Value</h3>

<p>either a numeric vector of threshold values, with one for each dimension 0..'maxdim' (in that order), or a list containing those thresholds and elements (if desired)
</p>


<h3>Author(s)</h3>

<p>Shael Brown - <a href="mailto:shaelebrown@gmail.com">shaelebrown@gmail.com</a>
</p>


<h3>References</h3>

<p>Chazal F et al (2017). &quot;Robust Topological Inference: Distance to a Measure and Kernel Distance.&quot; <a href="https://www.jmlr.org/papers/volume18/15-484/15-484.pdf">https://www.jmlr.org/papers/volume18/15-484/15-484.pdf</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(require("TDAstats"))
{
  # create a persistence diagram from a sample of the unit circle
  df &lt;- TDAstats::circle2d[sample(1:100,size = 50),]

  # calculate persistence thresholds for alpha = 0.05 
  # and return the calculated diagram as well as the subsetted diagram
  bootstrapped_diagram &lt;- bootstrap_persistence_thresholds(X = df,
  maxdim = 1,thresh = 2,num_workers = 2)
}
</code></pre>

<hr>
<h2 id='check_PyH_setup'>Make sure that python has been configured correctly for persistent homology calculations.</h2><span id='topic+check_PyH_setup'></span>

<h3>Description</h3>

<p>Ensures that the reticulate package has been installed, that python is available to be used
by reticulate functions, and that the python module &quot;ripser&quot; has been installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_PyH_setup()
</code></pre>


<h3>Details</h3>

<p>An error message will be thrown if any of the above conditions are not met.
</p>


<h3>Author(s)</h3>

<p>Shael Brown - <a href="mailto:shaelebrown@gmail.com">shaelebrown@gmail.com</a>
</p>

<hr>
<h2 id='check_ripser'>Verify an imported ripser module.</h2><span id='topic+check_ripser'></span>

<h3>Description</h3>

<p>Verify an imported ripser module.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_ripser(ripser)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_ripser_+3A_ripser">ripser</code></td>
<td>
<p>the ripser module object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Shael Brown - <a href="mailto:shaelebrown@gmail.com">shaelebrown@gmail.com</a>
</p>

<hr>
<h2 id='diagram_distance'>Calculate distance between a pair of persistence diagrams.</h2><span id='topic+diagram_distance'></span>

<h3>Description</h3>

<p>Calculates the distance between a pair of persistence diagrams, either the output from a <code><a href="#topic+diagram_to_df">diagram_to_df</a></code> function call
or from a persistent homology calculation like ripsDiag/<code><a href="TDAstats.html#topic+calculate_homology">calculate_homology</a></code>/<code><a href="#topic+PyH">PyH</a></code>,
in a particular homological dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagram_distance(
  D1,
  D2,
  dim = 0,
  p = 2,
  distance = "wasserstein",
  sigma = NULL,
  rho = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagram_distance_+3A_d1">D1</code></td>
<td>
<p>the first persistence diagram.</p>
</td></tr>
<tr><td><code id="diagram_distance_+3A_d2">D2</code></td>
<td>
<p>the second persistence diagram.</p>
</td></tr>
<tr><td><code id="diagram_distance_+3A_dim">dim</code></td>
<td>
<p>the non-negative integer homological dimension in which the distance is to be computed, default 0.</p>
</td></tr>
<tr><td><code id="diagram_distance_+3A_p">p</code></td>
<td>
<p>a number representing the wasserstein power parameter, at least 1 and default 2.</p>
</td></tr>
<tr><td><code id="diagram_distance_+3A_distance">distance</code></td>
<td>
<p>a string which determines which type of distance calculation to carry out, either &quot;wasserstein&quot; (default) or &quot;fisher&quot;.</p>
</td></tr>
<tr><td><code id="diagram_distance_+3A_sigma">sigma</code></td>
<td>
<p>either NULL (default) or a positive number representing the bandwidth for the Fisher information metric.</p>
</td></tr>
<tr><td><code id="diagram_distance_+3A_rho">rho</code></td>
<td>
<p>either NULL (default) or a positive number. If NULL then the exact calculation of the Fisher information metric is returned and otherwise a fast approximation, see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The most common distance calculations between persistence diagrams
are the wasserstein and bottleneck distances, both of which &quot;match&quot; points between
their two input diagrams and compute the &quot;loss&quot; of the optimal matching 
(see <a href="https://dl.acm.org/doi/10.1145/3064175">https://dl.acm.org/doi/10.1145/3064175</a> for details). Another 
method for computing distances, the Fisher information metric, 
converts the two diagrams into distributions
defined on the plane, and calculates a distance between the resulting two distributions
(<a href="https://proceedings.neurips.cc/paper/2018/file/959ab9a0695c467e7caf75431a872e5c-Paper.pdf">https://proceedings.neurips.cc/paper/2018/file/959ab9a0695c467e7caf75431a872e5c-Paper.pdf</a>).
If the 'distance' parameter is &quot;fisher&quot; then 'sigma' must not be NULL. As noted in the Persistence Fisher paper,
there is a fast speed-up approximation which has been implemented from <a href="https://github.com/vmorariu/figtree">https://github.com/vmorariu/figtree</a> 
and can be accessed by setting the 'rho' parameter. Smaller
values of 'rho' will result in tighter approximations at the expense of longer runtime, and vice versa.
</p>


<h3>Value</h3>

<p>the numeric value of the distance calculation.
</p>


<h3>Author(s)</h3>

<p>Shael Brown - <a href="mailto:shaelebrown@gmail.com">shaelebrown@gmail.com</a>
</p>


<h3>References</h3>

<p>Kerber M, Morozov D and Nigmetov A (2017). &quot;Geometry Helps to Compare Persistence Diagrams.&quot; <a href="https://dl.acm.org/doi/10.1145/3064175">https://dl.acm.org/doi/10.1145/3064175</a>.
</p>
<p>Le T, Yamada M (2018). &quot;Persistence fisher kernel: a riemannian manifold kernel for persistence diagrams.&quot; <a href="https://proceedings.neurips.cc/paper/2018/file/959ab9a0695c467e7caf75431a872e5c-Paper.pdf">https://proceedings.neurips.cc/paper/2018/file/959ab9a0695c467e7caf75431a872e5c-Paper.pdf</a>.
</p>
<p>Vlad I. Morariu, Balaji Vasan Srinivasan, Vikas C. Raykar, Ramani Duraiswami, and Larry S. Davis. Automatic online tuning for fast Gaussian summation. Advances in Neural Information Processing Systems (NIPS), 2008.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distance_matrix">distance_matrix</a></code> for distance matrix calculations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(require("TDAstats"))
{
  # create two diagrams
  D1 &lt;- TDAstats::calculate_homology(TDAstats::circle2d[sample(1:100,size = 20),],
                      dim = 1,threshold = 2)
  D2 &lt;- TDAstats::calculate_homology(TDAstats::circle2d[sample(1:100,size = 20),],
                      dim = 1,threshold = 2)

  # calculate 2-wasserstein distance between D1 and D2 in dimension 1
  diagram_distance(D1,D2,dim = 1,p = 2,distance = "wasserstein")

  # calculate bottleneck distance between D1 and D2 in dimension 0
  diagram_distance(D1,D2,dim = 0,p = Inf,distance = "wasserstein")

  # Fisher information metric calculation between D1 and D2 for sigma = 1 in dimension 1
  diagram_distance(D1,D2,dim = 1,distance = "fisher",sigma = 1)
  
  # repeat but with fast approximation
  ## Not run: 
  diagram_distance(D1,D2,dim = 1,distance = "fisher",sigma = 1,rho = 0.001)
  
## End(Not run)
}
</code></pre>

<hr>
<h2 id='diagram_kernel'>Calculate persistence Fisher kernel value between a pair of persistence diagrams.</h2><span id='topic+diagram_kernel'></span>

<h3>Description</h3>

<p>Returns the persistence Fisher kernel value between a pair of persistence diagrams
in a particular homological dimension, each of which is either the output from a <code><a href="#topic+diagram_to_df">diagram_to_df</a></code> 
function call or from a persistent homology calculation like ripsDiag/<code><a href="TDAstats.html#topic+calculate_homology">calculate_homology</a></code>/<code><a href="#topic+PyH">PyH</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagram_kernel(D1, D2, dim = 0, sigma = 1, t = 1, rho = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagram_kernel_+3A_d1">D1</code></td>
<td>
<p>the first persistence diagram.</p>
</td></tr>
<tr><td><code id="diagram_kernel_+3A_d2">D2</code></td>
<td>
<p>the second persistence diagram.</p>
</td></tr>
<tr><td><code id="diagram_kernel_+3A_dim">dim</code></td>
<td>
<p>the non-negative integer homological dimension in which the distance is to be computed, default 0.</p>
</td></tr>
<tr><td><code id="diagram_kernel_+3A_sigma">sigma</code></td>
<td>
<p>a positive number representing the bandwidth for the Fisher information metric, default 1.</p>
</td></tr>
<tr><td><code id="diagram_kernel_+3A_t">t</code></td>
<td>
<p>a positive number representing the scale for the persistence Fisher kernel, default 1.</p>
</td></tr>
<tr><td><code id="diagram_kernel_+3A_rho">rho</code></td>
<td>
<p>an optional positive number representing the heuristic for Fisher information metric approximation, see <code><a href="#topic+diagram_distance">diagram_distance</a></code>. Default NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The persistence Fisher kernel is calculated from the Fisher information metric according to the formula
<code class="reqn">k_{PF}(D_1,D_2) = exp(-t*d_{FIM}(D_1,D_2))</code>, resembling a radial basis kernel for standard
Euclidean spaces.
</p>


<h3>Value</h3>

<p>the numeric kernel value.
</p>


<h3>Author(s)</h3>

<p>Shael Brown - <a href="mailto:shaelebrown@gmail.com">shaelebrown@gmail.com</a>
</p>


<h3>References</h3>

<p>Le T, Yamada M (2018). &quot;Persistence fisher kernel: a riemannian manifold kernel for persistence diagrams.&quot; <a href="https://proceedings.neurips.cc/paper/2018/file/959ab9a0695c467e7caf75431a872e5c-Paper.pdf">https://proceedings.neurips.cc/paper/2018/file/959ab9a0695c467e7caf75431a872e5c-Paper.pdf</a>.
</p>
<p>Murphy, K. &quot;Machine learning: a probabilistic perspective&quot;, MIT press (2012).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gram_matrix">gram_matrix</a></code> for Gram (i.e. kernel) matrix calculations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(require("TDAstats"))
{
  # create two diagrams
  D1 &lt;- TDAstats::calculate_homology(TDAstats::circle2d[sample(1:100,20),],
                      dim = 1,threshold = 2)
  D2 &lt;- TDAstats::calculate_homology(TDAstats::circle2d[sample(1:100,20),],
                      dim = 1,threshold = 2)

  # calculate the kernel value between D1 and D2 with sigma = 2, t = 2 in dimension 1
  diagram_kernel(D1,D2,dim = 1,sigma = 2,t = 2)
  # calculate the kernel value between D1 and D2 with sigma = 2, t = 2 in dimension 0
  diagram_kernel(D1,D2,dim = 0,sigma = 2,t = 2)
}
</code></pre>

<hr>
<h2 id='diagram_kkmeans'>Cluster a group of persistence diagrams using kernel k-means.</h2><span id='topic+diagram_kkmeans'></span>

<h3>Description</h3>

<p>Finds latent cluster labels for a group of persistence diagrams, using a kernelized version
of the popular k-means algorithm. An optimal number of clusters may be determined by analyzing
the withinss field of the clustering object over several values of k.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagram_kkmeans(
  diagrams,
  K = NULL,
  centers,
  dim = 0,
  t = 1,
  sigma = 1,
  rho = NULL,
  num_workers = parallelly::availableCores(omit = 1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagram_kkmeans_+3A_diagrams">diagrams</code></td>
<td>
<p>a list of n&gt;=2 persistence diagrams which are either the output of a persistent homology calculation like ripsDiag/<code><a href="TDAstats.html#topic+calculate_homology">calculate_homology</a></code>/<code><a href="#topic+PyH">PyH</a></code>, or the <code><a href="#topic+diagram_to_df">diagram_to_df</a></code> function.</p>
</td></tr>
<tr><td><code id="diagram_kkmeans_+3A_k">K</code></td>
<td>
<p>an optional precomputed Gram matrix of persistence diagrams, default NULL.</p>
</td></tr>
<tr><td><code id="diagram_kkmeans_+3A_centers">centers</code></td>
<td>
<p>number of clusters to initialize, no more than the number of diagrams although smaller values are recommended.</p>
</td></tr>
<tr><td><code id="diagram_kkmeans_+3A_dim">dim</code></td>
<td>
<p>the non-negative integer homological dimension in which the distance is to be computed, default 0.</p>
</td></tr>
<tr><td><code id="diagram_kkmeans_+3A_t">t</code></td>
<td>
<p>a positive number representing the scale for the persistence Fisher kernel, default 1.</p>
</td></tr>
<tr><td><code id="diagram_kkmeans_+3A_sigma">sigma</code></td>
<td>
<p>a positive number representing the bandwidth for the Fisher information metric, default 1.</p>
</td></tr>
<tr><td><code id="diagram_kkmeans_+3A_rho">rho</code></td>
<td>
<p>an optional positive number representing the heuristic for Fisher information metric approximation, see <code><a href="#topic+diagram_distance">diagram_distance</a></code>. Default NULL. If supplied, Gram matrix calculation is sequential.</p>
</td></tr>
<tr><td><code id="diagram_kkmeans_+3A_num_workers">num_workers</code></td>
<td>
<p>the number of cores used for parallel computation, default is one less than the number of cores on the machine.</p>
</td></tr>
<tr><td><code id="diagram_kkmeans_+3A_...">...</code></td>
<td>
<p>additional parameters for the <code><a href="kernlab.html#topic+kkmeans">kkmeans</a></code> kernlab function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the output of <code><a href="kernlab.html#topic+kkmeans">kkmeans</a></code> on the desired Gram matrix of a group of persistence diagrams
in a particular dimension. The additional list elements stored in the output are needed
to estimate cluster labels for new persistence diagrams in the 'predict_diagram_kkmeans'
function.
</p>


<h3>Value</h3>

<p>a list of class 'diagram_kkmeans' containing the output of <code><a href="kernlab.html#topic+kkmeans">kkmeans</a></code> on the Gram matrix, i.e. a list containing the elements
</p>

<dl>
<dt>clustering</dt><dd><p>an S4 object of class specc, the output of a <code><a href="kernlab.html#topic+kkmeans">kkmeans</a></code> function call. The '.Data' slot of this object contains cluster memberships, 'withinss' contains the within-cluster sum of squares for each cluster, etc.</p>
</dd>
<dt>diagrams</dt><dd><p>the input 'diagrams' argument.</p>
</dd>
<dt>dim</dt><dd><p>the input 'dim' argument.</p>
</dd>
<dt>t</dt><dd><p>the input 't' argument.</p>
</dd>
<dt>sigma</dt><dd><p>the input 'sigma' argument.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Shael Brown - <a href="mailto:shaelebrown@gmail.com">shaelebrown@gmail.com</a>
</p>


<h3>References</h3>

<p>Dhillon, I and Guan, Y and Kulis, B (2004). &quot;A Unified View of Kernel k-means , Spectral Clustering and Graph Cuts.&quot; <a href="https://people.bu.edu/bkulis/pubs/spectral_techreport.pdf">https://people.bu.edu/bkulis/pubs/spectral_techreport.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict_diagram_kkmeans">predict_diagram_kkmeans</a></code> for predicting cluster labels of new diagrams.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(require("TDAstats"))
{
  # create two diagrams
  D1 &lt;- TDAstats::calculate_homology(TDAstats::circle2d[sample(1:100,20),],
                      dim = 1,threshold = 2)
  D2 &lt;- TDAstats::calculate_homology(TDAstats::circle2d[sample(1:100,20),],
                      dim = 1,threshold = 2)
  g &lt;- list(D1,D1,D2,D2)

  # calculate kmeans clusters with centers = 2, and sigma = t = 2 in dimension 0
  clust &lt;- diagram_kkmeans(diagrams = g,centers = 2,dim = 0,t = 2,sigma = 2,num_workers = 2)
  
  # repeat with precomputed Gram matrix, gives the same result just much faster
  K &lt;- gram_matrix(diagrams = g,num_workers = 2,t = 2,sigma = 2)
  cluster &lt;- diagram_kkmeans(diagrams = g,K = K,centers = 2,dim = 0,sigma = 2,t = 2)
  
}
</code></pre>

<hr>
<h2 id='diagram_kpca'>Calculate the kernel PCA embedding of a group of persistence diagrams.</h2><span id='topic+diagram_kpca'></span>

<h3>Description</h3>

<p>Project a group of persistence diagrams into a low-dimensional embedding space using
a kernelized version of the popular PCA algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagram_kpca(
  diagrams,
  K = NULL,
  dim = 0,
  t = 1,
  sigma = 1,
  rho = NULL,
  features = 1,
  num_workers = parallelly::availableCores(omit = 1),
  th = 1e-04
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagram_kpca_+3A_diagrams">diagrams</code></td>
<td>
<p>a list of persistence diagrams which are either the output of a persistent homology calculation like ripsDiag/<code><a href="TDAstats.html#topic+calculate_homology">calculate_homology</a></code>/<code><a href="#topic+PyH">PyH</a></code>, or <code><a href="#topic+diagram_to_df">diagram_to_df</a></code>.</p>
</td></tr>
<tr><td><code id="diagram_kpca_+3A_k">K</code></td>
<td>
<p>an optional precomputed Gram matrix of the persistence diagrams in 'diagrams', default NULL.</p>
</td></tr>
<tr><td><code id="diagram_kpca_+3A_dim">dim</code></td>
<td>
<p>the non-negative integer homological dimension in which the distance is to be computed, default 0.</p>
</td></tr>
<tr><td><code id="diagram_kpca_+3A_t">t</code></td>
<td>
<p>a positive number representing the scale for the persistence Fisher kernel, default 1.</p>
</td></tr>
<tr><td><code id="diagram_kpca_+3A_sigma">sigma</code></td>
<td>
<p>a positive number representing the bandwidth for the Fisher information metric, default 1.</p>
</td></tr>
<tr><td><code id="diagram_kpca_+3A_rho">rho</code></td>
<td>
<p>an optional positive number representing the heuristic for Fisher information metric approximation, see <code><a href="#topic+diagram_distance">diagram_distance</a></code>. Default NULL. If supplied, Gram matrix calculation is sequential.</p>
</td></tr>
<tr><td><code id="diagram_kpca_+3A_features">features</code></td>
<td>
<p>number of features (principal components) to return, default 1.</p>
</td></tr>
<tr><td><code id="diagram_kpca_+3A_num_workers">num_workers</code></td>
<td>
<p>the number of cores used for parallel computation, default is one less than the number of cores on the machine.</p>
</td></tr>
<tr><td><code id="diagram_kpca_+3A_th">th</code></td>
<td>
<p>the threshold value under which principal components are ignored (default 0.0001).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the output of kernlab's <code><a href="kernlab.html#topic+kpca">kpca</a></code> function on the desired Gram matrix of a group of persistence diagrams
in a particular dimension. The prediction function <code><a href="#topic+predict_diagram_kpca">predict_diagram_kpca</a></code> can be used to 
project new persistence diagrams using an old embedding, and this could be one practical
advantage of using <code><a href="#topic+diagram_kpca">diagram_kpca</a></code> over <code><a href="#topic+diagram_mds">diagram_mds</a></code>. The embedding coordinates can also
be used for further analysis, or simply as a data visualization tool for persistence diagrams.
</p>


<h3>Value</h3>

<p>a list of class 'diagram_kpca' containing the elements
</p>

<dl>
<dt>pca</dt><dd><p>the output of kernlab's <code><a href="kernlab.html#topic+kpca">kpca</a></code> function on the Gram matrix: an S4 object containing the slots 'pcv' (a matrix containing the principal component vectors (column wise)), 'eig' (the corresponding eigenvalues), 'rotated' (the original data projected (rotated) on the principal components) and 'xmatrix' (the original data matrix).</p>
</dd>
<dt>diagrams</dt><dd><p>the input 'diagrams' argument.</p>
</dd>
<dt>t</dt><dd><p>the input 't' argument.</p>
</dd>
<dt>sigma</dt><dd><p>the input 'sigma' argument.</p>
</dd>
<dt>dim</dt><dd><p>the input 'dim' argument.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Shael Brown - <a href="mailto:shaelebrown@gmail.com">shaelebrown@gmail.com</a>
</p>


<h3>References</h3>

<p>Scholkopf, B and Smola, A and Muller, K (1998). &quot;Nonlinear Component Analysis as a Kernel Eigenvalue Problem.&quot; <a href="https://www.mlpack.org/papers/kpca.pdf">https://www.mlpack.org/papers/kpca.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict_diagram_kpca">predict_diagram_kpca</a></code> for predicting embedding coordinates of new diagrams.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(require("TDAstats"))
{
  # create six diagrams
  D1 &lt;- TDAstats::calculate_homology(TDAstats::circle2d[sample(1:100,20),],
                      dim = 1,threshold = 2)
  D2 &lt;- TDAstats::calculate_homology(TDAstats::circle2d[sample(1:100,20),],
                      dim = 1,threshold = 2)
  D3 &lt;- TDAstats::calculate_homology(TDAstats::sphere3d[sample(1:100,20),],
                      dim = 1,threshold = 2)
  D4 &lt;- TDAstats::calculate_homology(TDAstats::sphere3d[sample(1:100,20),],
                      dim = 1,threshold = 2)
  D5 &lt;- TDAstats::calculate_homology(TDAstats::sphere3d[sample(1:100,20),],
                      dim = 1,threshold = 2)
  D6 &lt;- TDAstats::calculate_homology(TDAstats::sphere3d[sample(1:100,20),],
                      dim = 1,threshold = 2)
  g &lt;- list(D1,D2,D3,D4,D5,D6)

  # calculate their 2D PCA embedding with sigma = t = 2 in dimension 1
  pca &lt;- diagram_kpca(diagrams = g,dim = 1,t = 2,sigma = 2,features = 2,num_workers = 2,th = 1e-6)
  
  # repeat with precomputed Gram matrix, gives same result but much faster
  K &lt;- gram_matrix(diagrams = g,dim = 1,t = 2,sigma = 2,num_workers = 2)
  pca &lt;- diagram_kpca(diagrams = g,K = K,dim = 1,t = 2,sigma = 2,features = 2,th = 1e-6)
  
}
</code></pre>

<hr>
<h2 id='diagram_ksvm'>Fit a support vector machine model where each training set instance is a persistence diagram.</h2><span id='topic+diagram_ksvm'></span>

<h3>Description</h3>

<p>Returns the output of kernlab's <code><a href="kernlab.html#topic+ksvm">ksvm</a></code> function on the Gram matrix of the list of persistence diagrams
in a particular dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagram_ksvm(
  diagrams,
  cv = 1,
  dim,
  t = 1,
  sigma = 1,
  rho = NULL,
  y,
  type = NULL,
  distance_matrices = NULL,
  C = 1,
  nu = 0.2,
  epsilon = 0.1,
  prob.model = FALSE,
  class.weights = NULL,
  fit = TRUE,
  cache = 40,
  tol = 0.001,
  shrinking = TRUE,
  num_workers = parallelly::availableCores(omit = 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagram_ksvm_+3A_diagrams">diagrams</code></td>
<td>
<p>a list of persistence diagrams which are either the output of a persistent homology calculation like ripsDiag/<code><a href="TDAstats.html#topic+calculate_homology">calculate_homology</a></code>/<code><a href="#topic+PyH">PyH</a></code>, or <code><a href="#topic+diagram_to_df">diagram_to_df</a></code>.</p>
</td></tr>
<tr><td><code id="diagram_ksvm_+3A_cv">cv</code></td>
<td>
<p>a positive number at most the length of 'diagrams' which determines the number of cross validation splits to be performed (default 1, aka no cross-validation). If 'prob.model' is TRUE then cv is set to 1 since kernlab performs 3-fold CV internally in this case. When performing classification, classes are balanced within each cv fold.</p>
</td></tr>
<tr><td><code id="diagram_ksvm_+3A_dim">dim</code></td>
<td>
<p>a non-negative integer vector of homological dimensions in which the model is to be fit.</p>
</td></tr>
<tr><td><code id="diagram_ksvm_+3A_t">t</code></td>
<td>
<p>either a vector of positive numbers representing the grid of values for the scale of the persistence Fisher kernel or NULL, default 1. If NULL then t is selected automatically, see details.</p>
</td></tr>
<tr><td><code id="diagram_ksvm_+3A_sigma">sigma</code></td>
<td>
<p>a vector of positive numbers representing the grid of values for the bandwidth of the Fisher information metric, default 1.</p>
</td></tr>
<tr><td><code id="diagram_ksvm_+3A_rho">rho</code></td>
<td>
<p>an optional positive number representing the heuristic for Fisher information metric approximation, see <code><a href="#topic+diagram_distance">diagram_distance</a></code>. Default NULL. If supplied, distance matrix calculations are sequential.</p>
</td></tr>
<tr><td><code id="diagram_ksvm_+3A_y">y</code></td>
<td>
<p>a response vector with one label for each persistence diagram. Must be either numeric or factor, but doesn't need to be supplied when 'type' is &quot;one-svc&quot;.</p>
</td></tr>
<tr><td><code id="diagram_ksvm_+3A_type">type</code></td>
<td>
<p>a string representing the type of task to be performed. Can be any one of &quot;C-svc&quot;,&quot;nu-svc&quot;,&quot;one-svc&quot;,&quot;eps-svr&quot;,&quot;nu-svr&quot; - default for regression is &quot;eps-svr&quot; and for classification is &quot;C-svc&quot;. See <code><a href="kernlab.html#topic+ksvm">ksvm</a></code> for details.</p>
</td></tr>
<tr><td><code id="diagram_ksvm_+3A_distance_matrices">distance_matrices</code></td>
<td>
<p>an optional list of precomputed Fisher distance matrices, corresponding to the rows in 'expand.grid(dim = dim,sigma = sigma)', default NULL.</p>
</td></tr>
<tr><td><code id="diagram_ksvm_+3A_c">C</code></td>
<td>
<p>a number representing the cost of constraints violation (default 1) this is the 'C'-constant of the regularization term in the Lagrange formulation.</p>
</td></tr>
<tr><td><code id="diagram_ksvm_+3A_nu">nu</code></td>
<td>
<p>numeric parameter needed for nu-svc, one-svc and nu-svr. The 'nu' parameter sets the upper bound on the training error and the lower bound on the fraction of data points to become Support Vector (default 0.2).</p>
</td></tr>
<tr><td><code id="diagram_ksvm_+3A_epsilon">epsilon</code></td>
<td>
<p>epsilon in the insensitive-loss function used for eps-svr, nu-svr and eps-bsvm (default 0.1).</p>
</td></tr>
<tr><td><code id="diagram_ksvm_+3A_prob.model">prob.model</code></td>
<td>
<p>if set to TRUE builds a model for calculating class probabilities or in case of regression, calculates the scaling parameter of the Laplacian distribution fitted on the residuals. Fitting is done on output data created by performing a 3-fold cross-validation on the training data. For details see references (default FALSE).</p>
</td></tr>
<tr><td><code id="diagram_ksvm_+3A_class.weights">class.weights</code></td>
<td>
<p>a named vector of weights for the different classes, used for asymmetric class sizes. Not all factor levels have to be supplied (default weight: 1). All components have to be named.</p>
</td></tr>
<tr><td><code id="diagram_ksvm_+3A_fit">fit</code></td>
<td>
<p>indicates whether the fitted values should be computed and included in the model or not (default TRUE).</p>
</td></tr>
<tr><td><code id="diagram_ksvm_+3A_cache">cache</code></td>
<td>
<p>cache memory in MB (default 40).</p>
</td></tr>
<tr><td><code id="diagram_ksvm_+3A_tol">tol</code></td>
<td>
<p>tolerance of termination criteria (default 0.001).</p>
</td></tr>
<tr><td><code id="diagram_ksvm_+3A_shrinking">shrinking</code></td>
<td>
<p>option whether to use the shrinking-heuristics (default TRUE).</p>
</td></tr>
<tr><td><code id="diagram_ksvm_+3A_num_workers">num_workers</code></td>
<td>
<p>the number of cores used for parallel computation, default is one less the number of cores on the machine.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cross validation is carried out in parallel, using a trick
noted in doi: <a href="https://doi.org/10.1007/s41468-017-0008-7">10.1007/s41468-017-0008-7</a> - since the persistence Fisher kernel can be
written as <code class="reqn">d_{PF}(D_1,D_2)=exp(t*d_{FIM}(D_1,D_2))=exp(d_{FIM}(D_1,D_2))^t</code>, we can
store the Fisher information metric distance matrix for each sigma value in the parameter grid to avoid
recomputing distances, and cross validation is therefore performed in parallel. 
Note that the response parameter 'y' must be a factor for classification - 
a character vector for instance will throw an error. If 't' is NULL then 1/'t' is selected as
the 1,2,5,10,20,50 percentiles of the upper triangle of the distance matrix of its training sample (per fold in the case of cross-validation). 
This is the process suggested in the persistence Fisher kernel paper. If
any of these values would divide by 0 (i.e. if the training set is small) then the minimum non-zero element
is taken as the denominator (and hence the returned parameters may have duplicate rows except for differing error values). If
cross-validation is performed then the mean error across folds is still recorded, but the best 't' parameter
across all folds is recorded in the cv results table.
</p>


<h3>Value</h3>

<p>a list of class 'diagram_ksvm' containing the elements
</p>

<dl>
<dt>cv_results</dt><dd><p>the cross-validation results - a matrix storing the parameters for each model in the tuning grid and its mean cross-validation error over all splits.</p>
</dd>
<dt>best_model</dt><dd><p>a list containing the output of <code><a href="kernlab.html#topic+ksvm">ksvm</a></code> run on the whole dataset with the optimal model parameters found during cross-validation, as well as the optimal kernel parameters for the model.</p>
</dd>
<dt>diagrams</dt><dd><p>the diagrams which were supplied in the function call.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Shael Brown - <a href="mailto:shaelebrown@gmail.com">shaelebrown@gmail.com</a>
</p>


<h3>References</h3>

<p>Murphy, K. &quot;Machine learning: a probabilistic perspective.&quot; MIT press (2012).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict_diagram_ksvm">predict_diagram_ksvm</a></code> for predicting labels of new diagrams.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(require("TDAstats"))
{
  # create four diagrams
  D1 &lt;- TDAstats::calculate_homology(TDAstats::circle2d[sample(1:100,20),],
                      dim = 1,threshold = 2)
  D2 &lt;- TDAstats::calculate_homology(TDAstats::circle2d[sample(1:100,20),],
                      dim = 1,threshold = 2)
  D3 &lt;- TDAstats::calculate_homology(TDAstats::sphere3d[sample(1:100,20),],
                      dim = 1,threshold = 2)
  D4 &lt;- TDAstats::calculate_homology(TDAstats::sphere3d[sample(1:100,20),],
                      dim = 1,threshold = 2)
  g &lt;- list(D1,D2,D3,D4)

  # create response vector
  y &lt;- as.factor(c("circle","circle","sphere","sphere"))

  # fit model without cross validation
  model_svm &lt;- diagram_ksvm(diagrams = g,cv = 1,dim = c(0),
                            y = y,sigma = c(1),t = c(1),
                            num_workers = 2)
}
</code></pre>

<hr>
<h2 id='diagram_mds'>Dimension reduction of a group of persistence diagrams via metric multidimensional scaling.</h2><span id='topic+diagram_mds'></span>

<h3>Description</h3>

<p>Projects a group of persistence diagrams (or a precomputed distance matrix of diagrams) into a low-dimensional 
embedding space via metric multidimensional scaling. Such a projection can be used for visualization of data, 
or a static analysis of the embedding dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagram_mds(
  diagrams,
  D = NULL,
  k = 2,
  distance = "wasserstein",
  dim = 0,
  p = 2,
  sigma = NULL,
  rho = NULL,
  eig = FALSE,
  add = FALSE,
  x.ret = FALSE,
  list. = eig || add || x.ret,
  num_workers = parallelly::availableCores(omit = 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagram_mds_+3A_diagrams">diagrams</code></td>
<td>
<p>a list of n&gt;=2 persistence diagrams which are either the output of a persistent homology calculation like ripsDiag/<code><a href="TDAstats.html#topic+calculate_homology">calculate_homology</a></code>/<code><a href="#topic+PyH">PyH</a></code>, or <code><a href="#topic+diagram_to_df">diagram_to_df</a></code>. Only one of 'diagrams' and 'D' need to be supplied.</p>
</td></tr>
<tr><td><code id="diagram_mds_+3A_d">D</code></td>
<td>
<p>an optional precomputed distance matrix of persistence diagrams, default NULL. If not NULL then 'diagrams' parameter does not need to be supplied.</p>
</td></tr>
<tr><td><code id="diagram_mds_+3A_k">k</code></td>
<td>
<p>the dimension of the space which the data are to be represented in; must be in {1,2,...,n-1}.</p>
</td></tr>
<tr><td><code id="diagram_mds_+3A_distance">distance</code></td>
<td>
<p>a string representing the desired distance metric to be used, either 'wasserstein' (default) or 'fisher'.</p>
</td></tr>
<tr><td><code id="diagram_mds_+3A_dim">dim</code></td>
<td>
<p>the non-negative integer homological dimension in which the distance is to be computed, default 0.</p>
</td></tr>
<tr><td><code id="diagram_mds_+3A_p">p</code></td>
<td>
<p>a positive number representing the wasserstein power, a number at least 1 (infinity for the bottleneck distance), default 2.</p>
</td></tr>
<tr><td><code id="diagram_mds_+3A_sigma">sigma</code></td>
<td>
<p>a positive number representing the bandwidth for the Fisher information metric, default NULL.</p>
</td></tr>
<tr><td><code id="diagram_mds_+3A_rho">rho</code></td>
<td>
<p>an optional positive number representing the heuristic for Fisher information metric approximation, see <code><a href="#topic+diagram_distance">diagram_distance</a></code>. Default NULL. If supplied, distance matrix calculation is sequential.</p>
</td></tr>
<tr><td><code id="diagram_mds_+3A_eig">eig</code></td>
<td>
<p>a boolean indicating whether the eigenvalues should be returned.</p>
</td></tr>
<tr><td><code id="diagram_mds_+3A_add">add</code></td>
<td>
<p>a boolean indicating if an additive constant c* should be computed, and added to the non-diagonal dissimilarities such that the modified dissimilarities are Euclidean.</p>
</td></tr>
<tr><td><code id="diagram_mds_+3A_x.ret">x.ret</code></td>
<td>
<p>a boolean indicating whether the doubly centered symmetric distance matrix should be returned.</p>
</td></tr>
<tr><td><code id="diagram_mds_+3A_list.">list.</code></td>
<td>
<p>a boolean indicating if a list should be returned or just the n*k matrix.</p>
</td></tr>
<tr><td><code id="diagram_mds_+3A_num_workers">num_workers</code></td>
<td>
<p>the number of cores used for parallel computation, default is one less than the number of cores on the machine.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the output of <code><a href="stats.html#topic+cmdscale">cmdscale</a></code> on the desired distance matrix of a group of persistence diagrams
in a particular dimension. If 'distance' is &quot;fisher&quot; then 'sigma' must not be NULL.
</p>


<h3>Value</h3>

<p>the output of <code><a href="stats.html#topic+cmdscale">cmdscale</a></code> on the diagram distance matrix. If 'list.' is false (as per default),
a matrix with 'k' columns whose rows give the coordinates of the points chosen to represent the dissimilarities.
</p>
<p>Otherwise, a list containing the following components.
</p>

<dl>
<dt>points</dt><dd><p>a matrix with 'k' columns whose rows give the coordinates of the points chosen to represent the dissimilarities.</p>
</dd>
<dt>eig</dt><dd><p>the <code class="reqn">n</code> eigenvalues computed during the scaling process if 'eig' is true.</p>
</dd>
<dt>x</dt><dd><p>the doubly centered distance matrix if 'x.ret' is true.</p>
</dd>
<dt>ac</dt><dd><p>the additive constant <code class="reqn">c*</code>, 0 if 'add' = FALSE.</p>
</dd>
<dt>GOF</dt><dd><p>the numeric vector of length 2, representing the sum of all the eigenvalues divided by the sum of their absolute values (first vector element) or by the sum of the max of each eigenvalue and 0 (second vector element).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Shael Brown - <a href="mailto:shaelebrown@gmail.com">shaelebrown@gmail.com</a>
</p>


<h3>References</h3>

<p>Cox M and Cox F (2008). &quot;Multidimensional Scaling.&quot; doi: <a href="https://doi.org/10.1007/978-3-540-33037-0_14">10.1007/978-3-540-33037-0_14</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(require("TDAstats"))
{
  # create two diagrams
  D1 &lt;- TDAstats::calculate_homology(TDAstats::circle2d[sample(1:100,10),],
                      dim = 1,threshold = 2)
  D2 &lt;- TDAstats::calculate_homology(TDAstats::circle2d[sample(1:100,10),],
                      dim = 1,threshold = 2)
  g &lt;- list(D1,D2)

  # calculate their 1D MDS embedding in dimension 0 with the bottleneck distance
  mds &lt;- diagram_mds(diagrams = g,k = 1,dim = 0,p = Inf,num_workers = 2)
  
  # repeat but with a precomputed distance matrix, gives same result just much faster
  Dmat &lt;- distance_matrix(diagrams = list(D1,D2),dim = 0,p = Inf,num_workers = 2)
  mds &lt;- diagram_mds(D = Dmat,k = 1)
  
}
</code></pre>

<hr>
<h2 id='diagram_to_df'>Convert a TDA/TDAstats persistence diagram to a data frame.</h2><span id='topic+diagram_to_df'></span>

<h3>Description</h3>

<p>The output of homology calculations from the R packages TDA
and TDAstats are not dataframes. This function converts these 
outputs into a data frame either for further usage in this package or
for personalized analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagram_to_df(d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagram_to_df_+3A_d">d</code></td>
<td>
<p>the output of a TDA/TDAstats homology calculation, like ripsDiag or <code><a href="TDAstats.html#topic+calculate_homology">calculate_homology</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a diagram is constructed using a TDA function like ripsDiag
with the 'location' parameter set to true then the return value will ignore the location information.
</p>


<h3>Value</h3>

<p>a 3-column data frame, with each row representing a topological feature. The first column is the feature dimension (a non-negative integer), the second column is the birth radius of the feature and the third column is the death radius.
</p>


<h3>Author(s)</h3>

<p>Shael Brown - <a href="mailto:shaelebrown@gmail.com">shaelebrown@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(require("TDAstats"))
{
  # create a persistence diagram from a 2D Gaussian
  df = data.frame(x = rnorm(n = 20,mean = 0,sd = 1),y = rnorm(n = 20,mean = 0,sd = 1))

  # compute persistence diagram with calculate_homology from package TDAstats
  phom_TDAstats = TDAstats::calculate_homology(mat = df,dim = 0,threshold = 1)

  # convert to data frame
  phom_TDAstats_df = diagram_to_df(d = phom_TDAstats)
}
</code></pre>

<hr>
<h2 id='distance_matrix'>Compute a distance matrix from a list of persistence diagrams.</h2><span id='topic+distance_matrix'></span>

<h3>Description</h3>

<p>Calculate the distance matrix <code class="reqn">d</code> for either a single list of persistence diagrams <code class="reqn">(D_1,D_2,\dots,D_n)</code>, i.e. <code class="reqn">d[i,j] = d(D_i,D_j)</code>, 
or between two lists, <code class="reqn">(D_1,D_2,\dots,D_n)</code> and <code class="reqn">(D'_1,D'_2,\dots,D'_n)</code>, <code class="reqn">d[i,j] = d(D_i,D'_j)</code>, in parallel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_matrix(
  diagrams,
  other_diagrams = NULL,
  dim = 0,
  distance = "wasserstein",
  p = 2,
  sigma = NULL,
  rho = NULL,
  num_workers = parallelly::availableCores(omit = 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_matrix_+3A_diagrams">diagrams</code></td>
<td>
<p>a list of persistence diagrams, either the output of persistent homology calculations like ripsDiag/<code><a href="TDAstats.html#topic+calculate_homology">calculate_homology</a></code>/<code><a href="#topic+PyH">PyH</a></code>, or <code><a href="#topic+diagram_to_df">diagram_to_df</a></code>.</p>
</td></tr>
<tr><td><code id="distance_matrix_+3A_other_diagrams">other_diagrams</code></td>
<td>
<p>either NULL (default) or another list of persistence diagrams to compute a cross-distance matrix.</p>
</td></tr>
<tr><td><code id="distance_matrix_+3A_dim">dim</code></td>
<td>
<p>the non-negative integer homological dimension in which the distance is to be computed, default 0.</p>
</td></tr>
<tr><td><code id="distance_matrix_+3A_distance">distance</code></td>
<td>
<p>a character determining which metric to use, either &quot;wasserstein&quot; (default) or &quot;fisher&quot;.</p>
</td></tr>
<tr><td><code id="distance_matrix_+3A_p">p</code></td>
<td>
<p>a number representing the wasserstein power parameter, at least 1 and default 2.</p>
</td></tr>
<tr><td><code id="distance_matrix_+3A_sigma">sigma</code></td>
<td>
<p>a positive number representing the bandwidth of the Fisher information metric, default NULL.</p>
</td></tr>
<tr><td><code id="distance_matrix_+3A_rho">rho</code></td>
<td>
<p>an optional positive number representing the heuristic for Fisher information metric approximation, see <code><a href="#topic+diagram_distance">diagram_distance</a></code>. Default NULL. If not NULL then matrix is calculated sequentially, but functions in the &quot;exec&quot; directory
of the package can be loaded to calculate distance matrices in parallel with approximation.</p>
</td></tr>
<tr><td><code id="distance_matrix_+3A_num_workers">num_workers</code></td>
<td>
<p>the number of cores used for parallel computation, default is one less than the number of cores on the machine.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Distance matrices of persistence diagrams are used in downstream analyses, like in the 
<code><a href="#topic+diagram_mds">diagram_mds</a></code>, <code><a href="#topic+permutation_test">permutation_test</a></code> and <code><a href="#topic+diagram_ksvm">diagram_ksvm</a></code> functions. 
If 'distance' is &quot;fisher&quot; then 'sigma' must not be NULL. Since the matrix is computed sequentially when
approximating the Fisher information metric this is only recommended when the persistence diagrams
contain many points and when the number of available cores is small.
</p>


<h3>Value</h3>

<p>the numeric distance matrix.
</p>


<h3>Author(s)</h3>

<p>Shael Brown - <a href="mailto:shaelebrown@gmail.com">shaelebrown@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diagram_distance">diagram_distance</a></code> for individual distance calculations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(require("TDAstats"))
{
  # create two diagrams
  D1 &lt;- TDAstats::calculate_homology(TDAstats::circle2d[sample(1:100,10),],
                                     dim = 0,threshold = 2)
  D2 &lt;- TDAstats::calculate_homology(TDAstats::circle2d[sample(1:100,10),],
                                     dim = 0,threshold = 2)
  g &lt;- list(D1,D2)

  # calculate their distance matrix in dimension 0 with the persistence Fisher metric
  # using 2 cores
  D &lt;- distance_matrix(diagrams = g,dim = 0,distance = "fisher",sigma = 1,num_workers = 2)

  # calculate their distance matrix in dimension 0 with the 2-wasserstein metric 
  # using 2 cores
  D &lt;- distance_matrix(diagrams = g,dim = 0,distance = "wasserstein",p = 2,num_workers = 2)

  # now do the cross distance matrix, which is the same as the previous
  D_cross &lt;- distance_matrix(diagrams = g,other_diagrams = g,
                             dim = 0,distance = "wasserstein",
                             p = 2,num_workers = 2)
}
</code></pre>

<hr>
<h2 id='gram_matrix'>Compute the gram matrix for a group of persistence diagrams.</h2><span id='topic+gram_matrix'></span>

<h3>Description</h3>

<p>Calculate the Gram matrix <code class="reqn">K</code> for either a single list of persistence diagrams <code class="reqn">(D_1,D_2,\dots,D_n)</code>, i.e. <code class="reqn">K[i,j] = k_{PF}(D_i,D_j)</code>, 
or between two lists of persistence diagrams, <code class="reqn">(D_1,D_2,\dots,D_n)</code> and <code class="reqn">(D'_1,D'_2,\dots,D'_n)</code>, <code class="reqn">K[i,j] = k_{PF}(D_i,D'_j)</code>, in parallel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gram_matrix(
  diagrams,
  other_diagrams = NULL,
  dim = 0,
  sigma = 1,
  t = 1,
  rho = NULL,
  num_workers = parallelly::availableCores(omit = 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gram_matrix_+3A_diagrams">diagrams</code></td>
<td>
<p>a list of persistence diagrams, where each diagram is either the output of a persistent homology calculation like ripsDiag/<code><a href="TDAstats.html#topic+calculate_homology">calculate_homology</a></code>/<code><a href="#topic+PyH">PyH</a></code>, or <code><a href="#topic+diagram_to_df">diagram_to_df</a></code>.</p>
</td></tr>
<tr><td><code id="gram_matrix_+3A_other_diagrams">other_diagrams</code></td>
<td>
<p>either NULL (default) or another list of persistence diagrams to compute a cross-Gram matrix.</p>
</td></tr>
<tr><td><code id="gram_matrix_+3A_dim">dim</code></td>
<td>
<p>the non-negative integer homological dimension in which the distance is to be computed, default 0.</p>
</td></tr>
<tr><td><code id="gram_matrix_+3A_sigma">sigma</code></td>
<td>
<p>a positive number representing the bandwidth for the Fisher information metric, default 1.</p>
</td></tr>
<tr><td><code id="gram_matrix_+3A_t">t</code></td>
<td>
<p>a positive number representing the scale for the kernel, default 1.</p>
</td></tr>
<tr><td><code id="gram_matrix_+3A_rho">rho</code></td>
<td>
<p>an optional positive number representing the heuristic for Fisher information metric approximation, see <code><a href="#topic+diagram_distance">diagram_distance</a></code>. Default NULL. If supplied, code execution is sequential, but functions in the &quot;exec&quot; directory
of the package can be loaded to calculate distance matrices in parallel with approximation.</p>
</td></tr>
<tr><td><code id="gram_matrix_+3A_num_workers">num_workers</code></td>
<td>
<p>the number of cores used for parallel computation, default is one less than the number of cores on the machine.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gram matrices are used in downstream analyses, like in the 'diagram_kkmeans', 'diagram_nearest_cluster','diagram_kpca', 
'predict_diagram_kpca', 'predict_diagram_ksvm' and 'independence_test' functions.
</p>


<h3>Value</h3>

<p>the numeric (cross) Gram matrix of class 'kernelMatrix'.
</p>


<h3>Author(s)</h3>

<p>Shael Brown - <a href="mailto:shaelebrown@gmail.com">shaelebrown@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diagram_kernel">diagram_kernel</a></code> for individual persistence Fisher kernel calculations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(require("TDAstats"))
{
  # create two diagrams
  D1 &lt;- TDAstats::calculate_homology(TDAstats::circle2d[sample(1:100,20),],
                      dim = 1,threshold = 2)
  D2 &lt;- TDAstats::calculate_homology(TDAstats::circle2d[sample(1:100,20),],
                      dim = 1,threshold = 2)
  g &lt;- list(D1,D2)

  # calculate the Gram matrix in dimension 0 with sigma = 2, t = 2
  G &lt;- gram_matrix(diagrams = g,dim = 0,sigma = 2,t = 2,num_workers = 2)

  # calculate cross-Gram matrix, which is the same as G
  G_cross &lt;- gram_matrix(diagrams = g,other_diagrams = g,dim = 0,sigma = 2,
                         t = 2,num_workers = 2)
}
</code></pre>

<hr>
<h2 id='import_ripser'>Import the python module ripser.</h2><span id='topic+import_ripser'></span>

<h3>Description</h3>

<p>The ripser module is needed for fast persistent cohomology calculations with the PyH function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_ripser()
</code></pre>


<h3>Details</h3>

<p>Same as &quot;reticulate::import(&quot;ripser&quot;)&quot;, just with additional checks.
</p>


<h3>Value</h3>

<p>the python ripser module.
</p>


<h3>Author(s)</h3>

<p>Shael Brown - <a href="mailto:shaelebrown@gmail.com">shaelebrown@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# import ripser
ripser &lt;- import_ripser()

## End(Not run)
</code></pre>

<hr>
<h2 id='independence_test'>Independence test for two groups of persistence diagrams.</h2><span id='topic+independence_test'></span>

<h3>Description</h3>

<p>Carries out inference to determine if two groups of persistence diagrams are independent or not
based on kernel calculations (see 
(<a href="https://proceedings.neurips.cc/paper/2007/file/d5cfead94f5350c12c322b5b664544c1-Paper.pdf">https://proceedings.neurips.cc/paper/2007/file/d5cfead94f5350c12c322b5b664544c1-Paper.pdf</a>) for details).
A small p-value in a certain dimension suggests that the groups are not independent in that dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>independence_test(
  g1,
  g2,
  dims = c(0, 1),
  sigma = 1,
  rho = NULL,
  t = 1,
  num_workers = parallelly::availableCores(omit = 1),
  verbose = FALSE,
  Ks = NULL,
  Ls = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="independence_test_+3A_g1">g1</code></td>
<td>
<p>the first group of persistence diagrams, where each diagram was either the output from a persistent homology calculation like ripsDiag/<code><a href="TDAstats.html#topic+calculate_homology">calculate_homology</a></code>/<code><a href="#topic+PyH">PyH</a></code>, or <code><a href="#topic+diagram_to_df">diagram_to_df</a></code>.</p>
</td></tr>
<tr><td><code id="independence_test_+3A_g2">g2</code></td>
<td>
<p>the second group of persistence diagrams, where each diagram was either the output from a persistent homology calculation like ripsDiag/<code><a href="TDAstats.html#topic+calculate_homology">calculate_homology</a></code>/<code><a href="#topic+PyH">PyH</a></code>, or <code><a href="#topic+diagram_to_df">diagram_to_df</a></code>.</p>
</td></tr>
<tr><td><code id="independence_test_+3A_dims">dims</code></td>
<td>
<p>a non-negative integer vector of the homological dimensions in which the test is to be carried out, default c(0,1).</p>
</td></tr>
<tr><td><code id="independence_test_+3A_sigma">sigma</code></td>
<td>
<p>a positive number representing the bandwidth for the Fisher information metric, default 1.</p>
</td></tr>
<tr><td><code id="independence_test_+3A_rho">rho</code></td>
<td>
<p>an optional positive number representing the heuristic for Fisher information metric approximation, see <code><a href="#topic+diagram_distance">diagram_distance</a></code>. Default NULL. If supplied, calculation of Gram matrices is sequential.</p>
</td></tr>
<tr><td><code id="independence_test_+3A_t">t</code></td>
<td>
<p>a positive number representing the scale for the persistence Fisher kernel, default 1.</p>
</td></tr>
<tr><td><code id="independence_test_+3A_num_workers">num_workers</code></td>
<td>
<p>the number of cores used for parallel computation, default is one less than the number of cores on the machine.</p>
</td></tr>
<tr><td><code id="independence_test_+3A_verbose">verbose</code></td>
<td>
<p>a boolean flag for if the time duration of the function call should be printed, default FALSE</p>
</td></tr>
<tr><td><code id="independence_test_+3A_ks">Ks</code></td>
<td>
<p>an optional list of precomputed Gram matrices for the first group of diagrams, with one element for each dimension. If not NULL and 'Ls' is not NULL then 'g1' and 'g2' do not need to be supplied.</p>
</td></tr>
<tr><td><code id="independence_test_+3A_ls">Ls</code></td>
<td>
<p>an optional list of precomputed Gram matrices for the second group of diagrams, with one element for each dimension. If not NULL and 'Ks' is not NULL then 'g1' and 'g2' do not need to be supplied.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test is carried out with a parametric null distribution, making it much faster than non-parametric
approaches. If all of the diagrams in either g1 or g2 are the same in some dimension, then some p-values may be NaN.
</p>


<h3>Value</h3>

<p>a list with the following elements:
</p>

<dl>
<dt>dimensions</dt><dd><p>the input 'dims' argument.</p>
</dd>
<dt>test_statisics</dt><dd><p>a numeric vector of the test statistic value in each dimension.</p>
</dd>
<dt>p_values</dt><dd><p>a numeric vector of the p-values in each dimension.</p>
</dd>
<dt>run_time</dt><dd><p>the run time of the function call, containing time units.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Shael Brown - <a href="mailto:shaelebrown@gmail.com">shaelebrown@gmail.com</a>
</p>


<h3>References</h3>

<p>Gretton A et al. (2007). &quot;A Kernel Statistical Test of Independence.&quot; <a href="https://proceedings.neurips.cc/paper/2007/file/d5cfead94f5350c12c322b5b664544c1-Paper.pdf">https://proceedings.neurips.cc/paper/2007/file/d5cfead94f5350c12c322b5b664544c1-Paper.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+permutation_test">permutation_test</a></code> for an inferential group difference test for groups of persistence diagrams.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(require("TDAstats"))
{
  # create two independent groups of diagrams of length 6, which
  # is the minimum length
  D1 &lt;- TDAstats::calculate_homology(TDAstats::circle2d[sample(1:100,10),],
                                     dim = 0,threshold = 2)
  D2 &lt;- TDAstats::calculate_homology(TDAstats::circle2d[sample(1:100,10),],
                                     dim = 0,threshold = 2)
  g1 &lt;- list(D1,D2,D2,D2,D2,D2)
  g2 &lt;- list(D2,D1,D1,D1,D1,D1)

  # do independence test with sigma = t = 1 in dimension 0, using
  # precomputed Gram matrices
  K = gram_matrix(diagrams = g1,dim = 0,t = 1,sigma = 1,num_workers = 2)
  L = gram_matrix(diagrams = g2,dim = 0,t = 1,sigma = 1,num_workers = 2)
  indep_test &lt;- independence_test(Ks = list(K),Ls = list(L),dims = c(0))
  
}
</code></pre>

<hr>
<h2 id='loss'>Turner loss function for a list of groups (lists) of persistence diagrams.</h2><span id='topic+loss'></span>

<h3>Description</h3>

<p>An internal function to calculate the normalized sum of within-group exponentiated distances 
between pairs of persistence diagrams (stored as data frames)
for an arbitrary number of groups in parallel. Note that this function may run
into memory issues for large numbers of diagrams.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loss(
  diagram_groups,
  dist_mats,
  dims,
  p,
  q,
  distance,
  sigma,
  rho,
  num_workers,
  group_sizes
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loss_+3A_diagram_groups">diagram_groups</code></td>
<td>
<p>groups (lists/vectors) of persistence diagrams, stored as lists of a data frame and
an index of the diagram in all the diagrams across all groups.</p>
</td></tr>
<tr><td><code id="loss_+3A_dist_mats">dist_mats</code></td>
<td>
<p>distance matrices between all possible pairs of persistence diagrams across and within groups
storing the current distances which have been pre-computed.</p>
</td></tr>
<tr><td><code id="loss_+3A_dims">dims</code></td>
<td>
<p>a numeric vector of which homological dimensions in which the loss function is to be computed.</p>
</td></tr>
<tr><td><code id="loss_+3A_p">p</code></td>
<td>
<p>a number representing the wasserstein parameter, at least 1, and if Inf then the bottleneck distance is calculated.</p>
</td></tr>
<tr><td><code id="loss_+3A_q">q</code></td>
<td>
<p>a finite number at least 1.</p>
</td></tr>
<tr><td><code id="loss_+3A_distance">distance</code></td>
<td>
<p>a string which determines which type of distance calculation to carry out, either &quot;wasserstein&quot; (default) or &quot;fisher&quot;.</p>
</td></tr>
<tr><td><code id="loss_+3A_sigma">sigma</code></td>
<td>
<p>the positive bandwidth for the persistence Fisher distance.</p>
</td></tr>
<tr><td><code id="loss_+3A_rho">rho</code></td>
<td>
<p>the approximation heuristic for Fisher information metric, results in sequential computation.</p>
</td></tr>
<tr><td><code id="loss_+3A_num_workers">num_workers</code></td>
<td>
<p>the number of cores used for parallel computation.</p>
</td></tr>
<tr><td><code id="loss_+3A_group_sizes">group_sizes</code></td>
<td>
<p>for when using precomputed distance matrices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Turner loss function is described in Robinson and Turner 2017
(<a href="https://link.springer.com/article/10.1007/s41468-017-0008-7">https://link.springer.com/article/10.1007/s41468-017-0008-7</a>), and is used
in the 'permutation_test' function to describe how well-separated a particular
grouping of persistence diagrams is. When the 'distance' parameter is &quot;fisher&quot;,
'sigma' must not be NULL.
</p>


<h3>Value</h3>

<p>the numeric value of the Turner loss function.
</p>


<h3>Author(s)</h3>

<p>Shael Brown - <a href="mailto:shaelebrown@gmail.com">shaelebrown@gmail.com</a>
</p>


<h3>References</h3>

<p>Robinson T, Turner K (2017). &quot;Hypothesis testing for topological data analysis.&quot; <a href="https://link.springer.com/article/10.1007/s41468-017-0008-7">https://link.springer.com/article/10.1007/s41468-017-0008-7</a>.
</p>

<hr>
<h2 id='permutation_test'>Permutation test for finding group differences between persistence diagrams.</h2><span id='topic+permutation_test'></span>

<h3>Description</h3>

<p>A non-parametric ANOVA-like test for persistence diagrams 
(see <a href="https://link.springer.com/article/10.1007/s41468-017-0008-7">https://link.springer.com/article/10.1007/s41468-017-0008-7</a> for details). In each
desired dimension a test statistic (loss) is calculated, then the group labels are shuffled
for some number of iterations and the loss is recomputed each time thereby generating a null
distribution for the test statistic. This test generates a p-value in each desired dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permutation_test(
  ...,
  iterations = 20,
  p = 2,
  q = 2,
  dims = c(0, 1),
  dist_mats = NULL,
  group_sizes = NULL,
  paired = FALSE,
  distance = "wasserstein",
  sigma = NULL,
  rho = NULL,
  num_workers = parallelly::availableCores(omit = 1),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permutation_test_+3A_...">...</code></td>
<td>
<p>lists of persistence diagrams which are either the output of persistent homology calculations like ripsDiag/<code><a href="TDAstats.html#topic+calculate_homology">calculate_homology</a></code>/<code><a href="#topic+PyH">PyH</a></code>, or <code><a href="#topic+diagram_to_df">diagram_to_df</a></code>. Each list must contain at least 2 diagrams.</p>
</td></tr>
<tr><td><code id="permutation_test_+3A_iterations">iterations</code></td>
<td>
<p>the number of iterations for permuting group labels, default 20.</p>
</td></tr>
<tr><td><code id="permutation_test_+3A_p">p</code></td>
<td>
<p>a positive number representing the wasserstein power parameter, a number at least 1 (and Inf if using the bottleneck distance) and default 2.</p>
</td></tr>
<tr><td><code id="permutation_test_+3A_q">q</code></td>
<td>
<p>a finite number at least 1 for exponentiation in the Turner loss function, default 2.</p>
</td></tr>
<tr><td><code id="permutation_test_+3A_dims">dims</code></td>
<td>
<p>a non-negative integer vector of the homological dimensions in which the test is to be carried out, default c(0,1).</p>
</td></tr>
<tr><td><code id="permutation_test_+3A_dist_mats">dist_mats</code></td>
<td>
<p>an optional list of precomputed distances matrices, one for each dimension, where the rows and columns would correspond to the unlisted groups of diagrams (in order), default NULL. If not NULL then no lists of diagrams need to be supplied.</p>
</td></tr>
<tr><td><code id="permutation_test_+3A_group_sizes">group_sizes</code></td>
<td>
<p>a vector of group sizes, one for each group, when 'dist_mats' is not NULL.</p>
</td></tr>
<tr><td><code id="permutation_test_+3A_paired">paired</code></td>
<td>
<p>a boolean flag for if there is a second-order pairing between diagrams at the same index in different groups, default FALSE</p>
</td></tr>
<tr><td><code id="permutation_test_+3A_distance">distance</code></td>
<td>
<p>a string which determines which type of distance calculation to carry out, either &quot;wasserstein&quot; (default) or &quot;fisher&quot;.</p>
</td></tr>
<tr><td><code id="permutation_test_+3A_sigma">sigma</code></td>
<td>
<p>the positive bandwidth for the Fisher information metric, default NULL.</p>
</td></tr>
<tr><td><code id="permutation_test_+3A_rho">rho</code></td>
<td>
<p>an optional positive number representing the heuristic for Fisher information metric approximation, see <code><a href="#topic+diagram_distance">diagram_distance</a></code>. Default NULL. If supplied, code execution is sequential.</p>
</td></tr>
<tr><td><code id="permutation_test_+3A_num_workers">num_workers</code></td>
<td>
<p>the number of cores used for parallel computation, default is one less than the number of cores on the machine.</p>
</td></tr>
<tr><td><code id="permutation_test_+3A_verbose">verbose</code></td>
<td>
<p>a boolean flag for if the time duration of the function call should be printed, default FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test is carried out in parallel and optimized in order to not recompute already-calculated distances. As such, memory issues
may occur when the number of persistence diagrams is very large. 
Like in (<a href="https://github.com/hassan-abdallah/Statistical_Inference_PH_fMRI/blob/main/Abdallah_et_al_Statistical_Inference_PH_fMRI.pdf">https://github.com/hassan-abdallah/Statistical_Inference_PH_fMRI/blob/main/Abdallah_et_al_Statistical_Inference_PH_fMRI.pdf</a>)
an option is provided for pairing diagrams between groups to reduce variance (in order to boost statistical power), and
like it was suggested in the original paper functionality is provided for an arbitrary number of groups (not just 2).
A small p-value in a dimension suggests that the groups are different (separated) in that dimension.
If 'distance' is &quot;fisher&quot; then 'sigma' must not be NULL. TDAstats also has a 'permutation_test' function
so care should be taken to use the desired function when using TDApplied with TDAstats. If 'dist_mats' is supplied
then the sum of the elements of 'group_sizes' must equal the number of rows and columns of each of its elements.
</p>


<h3>Value</h3>

<p>a list with the following elements:
</p>

<dl>
<dt>dimensions</dt><dd><p>the input 'dims' argument.</p>
</dd>
<dt>permvals</dt><dd><p>a numeric vector of length 'iterations' with the permuted loss value for each iteration (permutation)</p>
</dd>
<dt>test_statisics</dt><dd><p>a numeric vector of the test statistic value in each dimension.</p>
</dd>
<dt>p_values</dt><dd><p>a numeric vector of the p-values in each dimension.</p>
</dd>
<dt>run_time</dt><dd><p>the run time of the function call, containing time units.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Shael Brown - <a href="mailto:shaelebrown@gmail.com">shaelebrown@gmail.com</a>
</p>


<h3>References</h3>

<p>Robinson T, Turner K (2017). &quot;Hypothesis testing for topological data analysis.&quot; <a href="https://link.springer.com/article/10.1007/s41468-017-0008-7">https://link.springer.com/article/10.1007/s41468-017-0008-7</a>.
</p>
<p>Abdallah H et al. (2021). &quot;Statistical Inference for Persistent Homology applied to fMRI.&quot; <a href="https://github.com/hassan-abdallah/Statistical_Inference_PH_fMRI/blob/main/Abdallah_et_al_Statistical_Inference_PH_fMRI.pdf">https://github.com/hassan-abdallah/Statistical_Inference_PH_fMRI/blob/main/Abdallah_et_al_Statistical_Inference_PH_fMRI.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+independence_test">independence_test</a></code> for an inferential test of independence for two groups of persistence diagrams.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(require("TDAstats"))
{
  # create two groups of diagrams
  D1 &lt;- TDAstats::calculate_homology(TDAstats::circle2d[sample(1:100,10),],
                                     dim = 0,threshold = 2)
  D2 &lt;- TDAstats::calculate_homology(TDAstats::circle2d[sample(1:100,10),],
                                     dim = 0,threshold = 2)
  g1 &lt;- list(D1,D2)
  g2 &lt;- list(D1,D2)

  # run test in dimension 0 with 1 iteration, note that the TDA package function
  # "permutation_test" can mask TDApplied's function, so we will specify explicitly
  # which function we are using
  perm_test &lt;- TDApplied::permutation_test(g1,g2,iterations = 1,
                                           num_workers = 2,
                                           dims = c(0))
                                 
  # repeat with precomputed distance matrix, gives similar results
  # (same but the randomness of the permutations can give small differences)
  # just much faster
  D &lt;- distance_matrix(diagrams = list(D1,D2,D1,D2),dim = 0,
                       num_workers = 2)
  perm_test &lt;- TDApplied::permutation_test(dist_mats = list(D),group_sizes = c(2,2),
                                           dims = c(0))
}
</code></pre>

<hr>
<h2 id='plot_diagram'>Plot persistence diagrams</h2><span id='topic+plot_diagram'></span>

<h3>Description</h3>

<p>Plots a persistence diagram outputted from either a persistent homology calculation or from diagram_to_df, with
maximum homological dimension no more than 12 (otherwise the legend doesn't fit in the plot).
Each homological dimension has its own color (the rcartocolor color-blind safe color palette) and point type, 
and the main plot title can be altered via the 'title' parameter. Each feature is plotted with
a black point at its center in order to distinguish between overlapping features and easily compare
features to their persistence thresholds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_diagram(
  D,
  title = NULL,
  max_radius = NULL,
  legend = TRUE,
  thresholds = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_diagram_+3A_d">D</code></td>
<td>
<p>a persistence diagram, either outputted from either a persistent homology homology calculation like ripsDiag/<code><a href="TDAstats.html#topic+calculate_homology">calculate_homology</a></code>/<code><a href="#topic+PyH">PyH</a></code> or from <code><a href="#topic+diagram_to_df">diagram_to_df</a></code>, with
maximum dimension at most 12.</p>
</td></tr>
<tr><td><code id="plot_diagram_+3A_title">title</code></td>
<td>
<p>the character string plot title, default NULL.</p>
</td></tr>
<tr><td><code id="plot_diagram_+3A_max_radius">max_radius</code></td>
<td>
<p>the x and y limits of the plot are defined as 'c(0,max_radius)', and the default value of 'max_radius' is the maximum death value in 'D'.</p>
</td></tr>
<tr><td><code id="plot_diagram_+3A_legend">legend</code></td>
<td>
<p>a logical indicating whether to include a legend of feature dimensions, default TRUE.</p>
</td></tr>
<tr><td><code id="plot_diagram_+3A_thresholds">thresholds</code></td>
<td>
<p>either a numeric vector with one persistence threshold for each dimension in 'D' or the output of a <code><a href="#topic+bootstrap_persistence_thresholds">bootstrap_persistence_thresholds</a></code> function call, default NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'thresholds' parameter, if not NULL, can either be a user-defined numeric vector, with
one entry (persistence threshold) for each dimension in 'D', or the output of
<code><a href="#topic+bootstrap_persistence_thresholds">bootstrap_persistence_thresholds</a></code>. Points whose persistence are greater than or equal to their dimension's
threshold will be plotted in their dimension's color, and in gray otherwise.
</p>


<h3>Author(s)</h3>

<p>Shael Brown - <a href="mailto:shaelebrown@gmail.com">shaelebrown@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(require("TDAstats"))
{
  # create a sample diagram from the unit circle
  df &lt;- TDAstats::circle2d[sample(1:100,50),]
  diag &lt;- TDAstats::calculate_homology(df,threshold = 2)

  # plot without title
  plot_diagram(diag)

  # plot with title
  plot_diagram(diag,title = "Example diagram")

  # determine persistence thresholds
  thresholds &lt;- bootstrap_persistence_thresholds(X = df,maxdim = 1,
  thresh = 2,num_samples = 3,
  num_workers = 2)

  # plot with bootstrap persistence thresholds
  plot_diagram(diag,title = "Example diagram with thresholds",thresholds = thresholds)

  #' # plot with personalized persistence thresholds
  plot_diagram(diag,title = "Example diagram with personalized thresholds",thresholds = c(0.5,1))
}
</code></pre>

<hr>
<h2 id='plot_vr_graph'>Plot a VR graph using the igraph package.</h2><span id='topic+plot_vr_graph'></span>

<h3>Description</h3>

<p>This function will throw an error if the igraph package is not installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_vr_graph(
  graphs,
  eps,
  cols = NULL,
  layout = NULL,
  title = NULL,
  component_of = NULL,
  plot_isolated_vertices = FALSE,
  return_layout = FALSE,
  vertex_labels = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_vr_graph_+3A_graphs">graphs</code></td>
<td>
<p>the output of a 'vr_graphs' function call.</p>
</td></tr>
<tr><td><code id="plot_vr_graph_+3A_eps">eps</code></td>
<td>
<p>the numeric radius of the graph in 'graphs' to plot.</p>
</td></tr>
<tr><td><code id="plot_vr_graph_+3A_cols">cols</code></td>
<td>
<p>an optional character vector of vertex colors, default 'NULL'.</p>
</td></tr>
<tr><td><code id="plot_vr_graph_+3A_layout">layout</code></td>
<td>
<p>an optional 2D matrix of vertex coordinates, default 'NULL'. If row names are supplied they can be used to subset a graph by those vertex names.</p>
</td></tr>
<tr><td><code id="plot_vr_graph_+3A_title">title</code></td>
<td>
<p>an optional str title for the plot, default 'NULL'.</p>
</td></tr>
<tr><td><code id="plot_vr_graph_+3A_component_of">component_of</code></td>
<td>
<p>a vertex name (integer or character), only the component of the graph containing that vertex will be plotted (useful for identifying representative (co)cycles in graphs). Default 'NULL' (plot the whole graph).</p>
</td></tr>
<tr><td><code id="plot_vr_graph_+3A_plot_isolated_vertices">plot_isolated_vertices</code></td>
<td>
<p>a boolean representing whether or not to plot isolated vertices, default 'FALSE'.</p>
</td></tr>
<tr><td><code id="plot_vr_graph_+3A_return_layout">return_layout</code></td>
<td>
<p>a boolean representing whether or not to return the plotting layout (x-y coordinates of each vertex) and the vertex labels, default 'FALSE'.</p>
</td></tr>
<tr><td><code id="plot_vr_graph_+3A_vertex_labels">vertex_labels</code></td>
<td>
<p>a boolean representing whether or not to plot vertex labels, default 'TRUE'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if 'return_layout' is 'TRUE' then a list with elements &quot;layout&quot; (the numeric matrix of vertex x-y coordinates) and &quot;vertices&quot; (character vertex labels), otherwise the function does not return anything.
</p>


<h3>Author(s)</h3>

<p>Shael Brown - <a href="mailto:shaelebrown@gmail.com">shaelebrown@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vr_graphs">vr_graphs</a></code> for computing VR graphs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(require("TDAstats") &amp; require("igraph"))
{
  # simulate data from the unit circle and calculate 
  # its diagram
  df &lt;- TDAstats::circle2d[sample(1:100,25),]
  diag &lt;- TDAstats::calculate_homology(df,
                                       dim = 1,
                                       threshold = 2)
  
  # get minimum death radius of any data cluster
  min_death_H0 &lt;- 
  min(diag[which(diag[,1] == 0),3L])
  
  # get birth and death radius of the loop
  loop_birth &lt;- as.numeric(diag[nrow(diag),2L])
  loop_death &lt;- as.numeric(diag[nrow(diag),3L])

  # compute VR graphs at radii half of 
  # min_death_H0 and the mean of loop_birth and 
  # loop_death, returning clusters
  graphs &lt;- vr_graphs(X = df,eps = 
  c(0.5*min_death_H0,(loop_birth + loop_death)/2))
  
  # plot graph of smaller (first) radius
  plot_vr_graph(graphs = graphs,eps = 0.5*min_death_H0,
                  plot_isolated_vertices = TRUE)
  
  # plot graph of larger (second) radius
  plot_vr_graph(graphs = graphs,eps = (loop_birth + loop_death)/2)
  
  # repeat but with rownames for df, each vertex
  # will be plotted with its rownames
  rownames(df) &lt;- paste0("V",1:25)
  graphs &lt;- vr_graphs(X = df,eps = 
  c(0.5*min_death_H0,(loop_birth + loop_death)/2))
  plot_vr_graph(graphs = graphs,eps = 0.5*min_death_H0,
                  plot_isolated_vertices = TRUE)
  
  # plot without vertex labels
  plot_vr_graph(graphs = graphs,eps = (loop_birth + loop_death)/2,
                  vertex_labels = FALSE)
                 
  # plot only the graph component containing vertex "1"
  plot_vr_graph(graphs = graphs,eps = 0.5*min_death_H0,
                  component_of = "V1",plot_isolated_vertices = TRUE)
 
  # save the layout of the graph for adding features to 
  # the same graph layout, like color
  layout &lt;- plot_vr_graph(graphs = graphs,eps = (loop_birth + loop_death)/2,
                            return_layout = TRUE,vertex_labels = TRUE)
  cols &lt;- rep("blue",25)
  cols[1:5] &lt;- "red"
  plot_vr_graph(graphs = graphs,eps = (loop_birth + loop_death)/2,cols = cols,
                  layout = layout)
  
}
</code></pre>

<hr>
<h2 id='predict_diagram_kkmeans'>Predict the cluster labels for new persistence diagrams using a pre-computed clustering.</h2><span id='topic+predict_diagram_kkmeans'></span>

<h3>Description</h3>

<p>Returns the nearest (highest kernel value) <code><a href="kernlab.html#topic+kkmeans">kkmeans</a></code> cluster center label for new persistence diagrams.
This allows for reusing old cluster models for new tasks, or to perform cross validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_diagram_kkmeans(
  new_diagrams,
  K = NULL,
  clustering,
  num_workers = parallelly::availableCores(omit = 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_diagram_kkmeans_+3A_new_diagrams">new_diagrams</code></td>
<td>
<p>a list of persistence diagrams which are either the output of a persistent homology calculation like ripsDiag/<code><a href="TDAstats.html#topic+calculate_homology">calculate_homology</a></code>/<code><a href="#topic+PyH">PyH</a></code>, or <code><a href="#topic+diagram_to_df">diagram_to_df</a></code>. Only one of 'new_diagrams' and 'K' need to be supplied.</p>
</td></tr>
<tr><td><code id="predict_diagram_kkmeans_+3A_k">K</code></td>
<td>
<p>an optional precomputed cross Gram matrix of the new diagrams and the diagrams used in 'clustering', default NULL. If not NULL then 'new_diagrams' does not need to be supplied.</p>
</td></tr>
<tr><td><code id="predict_diagram_kkmeans_+3A_clustering">clustering</code></td>
<td>
<p>the output of a <code><a href="#topic+diagram_kkmeans">diagram_kkmeans</a></code> function call, of class 'diagram_kkmeans'.</p>
</td></tr>
<tr><td><code id="predict_diagram_kkmeans_+3A_num_workers">num_workers</code></td>
<td>
<p>the number of cores used for parallel computation, default is one less than the number of cores on the machine.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the predicted cluster labels for the new diagrams.
</p>


<h3>Author(s)</h3>

<p>Shael Brown - <a href="mailto:shaelebrown@gmail.com">shaelebrown@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diagram_kkmeans">diagram_kkmeans</a></code> for clustering persistence diagrams.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(require("TDAstats"))
{
  # create two diagrams
  D1 &lt;- TDAstats::calculate_homology(TDAstats::circle2d[sample(1:100,20),],
                      dim = 1,threshold = 2)
  D2 &lt;- TDAstats::calculate_homology(TDAstats::circle2d[sample(1:100,20),],
                      dim = 1,threshold = 2)
  g &lt;- list(D1,D1,D2,D2)

  # calculate kmeans clusters with centers = 2, and sigma = t = 2 in dimension 0
  clust &lt;- diagram_kkmeans(diagrams = g,centers = 2,dim = 0,t = 2,sigma = 2,num_workers = 2)

  # create two new diagrams
  D3 &lt;- TDAstats::calculate_homology(TDAstats::circle2d[sample(1:100,20),],
                      dim = 1,threshold = 2)
  D4 &lt;- TDAstats::calculate_homology(TDAstats::circle2d[sample(1:100,20),],
                      dim = 1,threshold = 2)
  g_new &lt;- list(D3,D4)

  # predict cluster labels
  predict_diagram_kkmeans(new_diagrams = g_new,clustering = clust,num_workers = 2)
  
  # predict cluster labels with precomputed Gram matrix, gives same result but
  # much faster
  K &lt;- gram_matrix(diagrams = g_new,other_diagrams = clust$diagrams,
                   dim = clust$dim,t = clust$t,sigma = clust$sigma,
                   num_workers = 2)
  predict_diagram_kkmeans(K = K,clustering = clust)
  
}
</code></pre>

<hr>
<h2 id='predict_diagram_kpca'>Project persistence diagrams into a low-dimensional space via a pre-computed kernel PCA embedding.</h2><span id='topic+predict_diagram_kpca'></span>

<h3>Description</h3>

<p>Compute the location in low-dimensional space of each element of a list of new persistence diagrams using a
previously-computed kernel PCA embedding (from the <code><a href="#topic+diagram_kpca">diagram_kpca</a></code> function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_diagram_kpca(
  new_diagrams,
  K = NULL,
  embedding,
  num_workers = parallelly::availableCores(omit = 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_diagram_kpca_+3A_new_diagrams">new_diagrams</code></td>
<td>
<p>a list of persistence diagrams which are either the output of a persistent homology calculation like ripsDiag/<code><a href="TDAstats.html#topic+calculate_homology">calculate_homology</a></code>/<code><a href="#topic+PyH">PyH</a></code>, or <code><a href="#topic+diagram_to_df">diagram_to_df</a></code>. Only one of 'new_diagrams' and 'K' need to be supplied.</p>
</td></tr>
<tr><td><code id="predict_diagram_kpca_+3A_k">K</code></td>
<td>
<p>an optional precomputed cross-Gram matrix of the new diagrams and the ones used in 'embedding', default NULL. If not NULL then 'new_diagrams' does not need to be supplied.</p>
</td></tr>
<tr><td><code id="predict_diagram_kpca_+3A_embedding">embedding</code></td>
<td>
<p>the output of a <code><a href="#topic+diagram_kpca">diagram_kpca</a></code> function call, of class 'diagram_kpca'.</p>
</td></tr>
<tr><td><code id="predict_diagram_kpca_+3A_num_workers">num_workers</code></td>
<td>
<p>the number of cores used for parallel computation, default is one less than the number of cores on the machine.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the data projection (rotation), stored as a numeric matrix. Each row corresponds to the same-index diagram in 'new_diagrams'.
</p>


<h3>Author(s)</h3>

<p>Shael Brown - <a href="mailto:shaelebrown@gmail.com">shaelebrown@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diagram_kpca">diagram_kpca</a></code> for embedding persistence diagrams into a low-dimensional space.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(require("TDAstats"))
{
  # create six diagrams
  D1 &lt;- TDAstats::calculate_homology(TDAstats::circle2d[sample(1:100,20),],
                      dim = 1,threshold = 2)
  D2 &lt;- TDAstats::calculate_homology(TDAstats::circle2d[sample(1:100,20),],
                      dim = 1,threshold = 2)
  D3 &lt;- TDAstats::calculate_homology(TDAstats::sphere3d[sample(1:100,20),],
                      dim = 1,threshold = 2)
  D4 &lt;- TDAstats::calculate_homology(TDAstats::sphere3d[sample(1:100,20),],
                      dim = 1,threshold = 2)
  D5 &lt;- TDAstats::calculate_homology(TDAstats::sphere3d[sample(1:100,20),],
                      dim = 1,threshold = 2)
  D6 &lt;- TDAstats::calculate_homology(TDAstats::sphere3d[sample(1:100,20),],
                      dim = 1,threshold = 2)
  g &lt;- list(D1,D2,D3,D4,D5,D6)

  # calculate their 2D PCA embedding with sigma = t = 2 in dimension 0
  pca &lt;- diagram_kpca(diagrams = g,dim = 1,t = 2,sigma = 2,
                      features = 2,num_workers = 2,th = 1e-6)

  # project two new diagrams onto old model
  D7 &lt;- TDAstats::calculate_homology(TDAstats::circle2d[sample(1:100,50),],
                                     dim = 0,threshold = 2)
  D8 &lt;- TDAstats::calculate_homology(TDAstats::circle2d[sample(1:100,50),],
                                     dim = 0,threshold = 2)
  g_new &lt;- list(D7,D8)

  # calculate new embedding coordinates
  new_pca &lt;- predict_diagram_kpca(new_diagrams = g_new,embedding = pca,num_workers = 2)
  
  # repeat with precomputed Gram matrix, gives same result but much faster
  K &lt;- gram_matrix(diagrams = g_new,other_diagrams = pca$diagrams,dim = pca$dim,
                   t = pca$t,sigma = pca$sigma,num_workers = 2)
  new_pca &lt;- predict_diagram_kpca(K = K,embedding = pca,num_workers = 2)
}
</code></pre>

<hr>
<h2 id='predict_diagram_ksvm'>Predict the outcome labels for a list of persistence diagrams using a pre-trained diagram ksvm model.</h2><span id='topic+predict_diagram_ksvm'></span>

<h3>Description</h3>

<p>Returns the predicted response vector of the model on the new diagrams.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_diagram_ksvm(
  new_diagrams,
  model,
  K = NULL,
  num_workers = parallelly::availableCores(omit = 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_diagram_ksvm_+3A_new_diagrams">new_diagrams</code></td>
<td>
<p>a list of persistence diagrams which are either the output of a persistent homology calculation like ripsDiag/<code><a href="TDAstats.html#topic+calculate_homology">calculate_homology</a></code>/<code><a href="#topic+PyH">PyH</a></code>, or <code><a href="#topic+diagram_to_df">diagram_to_df</a></code>. Only one of 'new_diagrams' and 'K' need to be supplied.</p>
</td></tr>
<tr><td><code id="predict_diagram_ksvm_+3A_model">model</code></td>
<td>
<p>the output of a <code><a href="#topic+diagram_ksvm">diagram_ksvm</a></code> function call, of class 'diagram_ksvm'.</p>
</td></tr>
<tr><td><code id="predict_diagram_ksvm_+3A_k">K</code></td>
<td>
<p>an optional cross-Gram matrix of the new diagrams and the diagrams in 'model', default NULL. If not NULL then 'new_diagrams' does not need to be supplied.</p>
</td></tr>
<tr><td><code id="predict_diagram_ksvm_+3A_num_workers">num_workers</code></td>
<td>
<p>the number of cores used for parallel computation, default is one less than the number of cores on the machine.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper of the kernlab <code><a href="stats.html#topic+predict">predict</a></code> function.
</p>


<h3>Value</h3>

<p>a vector containing the output of <code><a href="kernlab.html#topic+predict.ksvm">predict.ksvm</a></code> on the cross Gram matrix of the new diagrams and the support vector diagrams stored in the model.
</p>


<h3>Author(s)</h3>

<p>Shael Brown - <a href="mailto:shaelebrown@gmail.com">shaelebrown@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diagram_ksvm">diagram_ksvm</a></code> for training a SVM model on a training set of persistence diagrams and labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(require("TDAstats"))
{
  # create four diagrams
  D1 &lt;- TDAstats::calculate_homology(TDAstats::circle2d[sample(1:100,20),],
                      dim = 1,threshold = 2)
  D2 &lt;- TDAstats::calculate_homology(TDAstats::circle2d[sample(1:100,20),],
                      dim = 1,threshold = 2)
  D3 &lt;- TDAstats::calculate_homology(TDAstats::sphere3d[sample(1:100,20),],
                      dim = 1,threshold = 2)
  D4 &lt;- TDAstats::calculate_homology(TDAstats::sphere3d[sample(1:100,20),],
                      dim = 1,threshold = 2)
  g &lt;- list(D1,D2,D3,D4)

  # create response vector
  y &lt;- as.factor(c("circle","circle","sphere","sphere"))

  # fit model without cross validation
  model_svm &lt;- diagram_ksvm(diagrams = g,cv = 1,dim = c(0),
                            y = y,sigma = c(1),t = c(1),
                            num_workers = 2)

  # create two new diagrams
  D5 &lt;- TDAstats::calculate_homology(TDAstats::circle2d[sample(1:100,20),],
                      dim = 1,threshold = 2)
  D6 &lt;- TDAstats::calculate_homology(TDAstats::sphere3d[sample(1:100,20),],
                      dim = 1,threshold = 2)
  g_new &lt;- list(D5,D6)

  # predict with precomputed Gram matrix
  K &lt;- gram_matrix(diagrams = g_new,other_diagrams = model_svm$diagrams,
                   dim = model_svm$best_model$dim,sigma = model_svm$best_model$sigma,
                   t = model_svm$best_model$t,num_workers = 2)
  predict_diagram_ksvm(K = K,model = model_svm,num_workers = 2)
}
</code></pre>

<hr>
<h2 id='PyH'>Fast persistent homology calculations with python.</h2><span id='topic+PyH'></span>

<h3>Description</h3>

<p>This function is a wrapper of the python wrapper of the ripser engine for persistent cohomology, 
but is still faster than using the R package TDAstats (see the TDApplied package vignette for details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PyH(
  X,
  maxdim = 1,
  thresh,
  distance_mat = FALSE,
  ripser,
  ignore_infinite_cluster = TRUE,
  calculate_representatives = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PyH_+3A_x">X</code></td>
<td>
<p>either a matrix or dataframe, representing either point cloud data or a distance matrix. In either case there
must be at least two rows and 1 column.</p>
</td></tr>
<tr><td><code id="PyH_+3A_maxdim">maxdim</code></td>
<td>
<p>the non-negative integer maximum dimension for persistent homology, default 1.</p>
</td></tr>
<tr><td><code id="PyH_+3A_thresh">thresh</code></td>
<td>
<p>the non-negative numeric radius threshold for the Vietoris-Rips filtration.</p>
</td></tr>
<tr><td><code id="PyH_+3A_distance_mat">distance_mat</code></td>
<td>
<p>a boolean representing whether the input X is a distance matrix or not, default FALSE.</p>
</td></tr>
<tr><td><code id="PyH_+3A_ripser">ripser</code></td>
<td>
<p>the ripser python module.</p>
</td></tr>
<tr><td><code id="PyH_+3A_ignore_infinite_cluster">ignore_infinite_cluster</code></td>
<td>
<p>a boolean representing whether to remove clusters (0 dimensional cycles) which
die at the threshold value. Default is TRUE as this is the default for TDAstats homology calculations, but can be set to
FALSE which is the default for python ripser.</p>
</td></tr>
<tr><td><code id="PyH_+3A_calculate_representatives">calculate_representatives</code></td>
<td>
<p>a boolean representing whether to return a list of representative cocycles for the
topological features found in the persistence diagram, default FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If 'distance_mat' is 'TRUE' then 'X' must be a square matrix. The 'ripser' parameter should be the
result of an 'import_ripser' function call, but since that function is slow the ripser object should
be explicitly created before a PyH function call (see examples). Cohomology is computed over Z2,
as is the case for the TDAstats function <code><a href="TDAstats.html#topic+calculate_homology">calculate_homology</a></code> (this is also the
default for ripser in c++). If representative cocycles are returned, then they are stored in a list with
one element for each point in the persistence diagram, ignoring dimension 0 points. Each representative of
a dimension d cocycle (1 for loops, 2 for voids, etc.) is a kxd dimension matrix/array containing the row number-labelled
edges, triangles etc. in the cocycle.
</p>


<h3>Value</h3>

<p>Either a dataframe containing the persistence diagram if 'calculate_representatives' is 'FALSE' (the default), otherwise a list with two elements: 
diagram of class diagram, containing the persistence diagram,
and representatives, a list containing the edges, triangles etc. contained in each representative cocycle.
</p>


<h3>Author(s)</h3>

<p>Shael Brown - <a href="mailto:shaelebrown@gmail.com">shaelebrown@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# create sample data
df &lt;- data.frame(x = 1:10,y = 1:10)

# import the ripser module
ripser &lt;- import_ripser()

# calculate persistence diagram up to dimension 1 with a maximum
# radius of 5
phom &lt;- PyH(X = df,thresh = 5,ripser = ripser)

## End(Not run)
</code></pre>

<hr>
<h2 id='TDApplied-package'>TDApplied: Machine Learning and Inference for Topological Data Analysis</h2><span id='topic+TDApplied'></span><span id='topic+TDApplied-package'></span>

<h3>Description</h3>

<p>Topological data analysis is a powerful tool for finding non-linear global structure in whole datasets. The main tool of topological data analysis is persistent homology, which computes a topological shape descriptor of a dataset called a persistence diagram. 'TDApplied' provides useful and efficient methods for analyzing groups of persistence diagrams with machine learning and statistical inference, and these functions can also interface with other data science packages to form flexible and integrated topological data analysis pipelines.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Shael Brown <a href="mailto:shaelebrown@gmail.com">shaelebrown@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Dr. Reza Farivar <a href="mailto:reza.farivar@mcgill.ca">reza.farivar@mcgill.ca</a> [funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/shaelebrown/TDApplied">https://github.com/shaelebrown/TDApplied</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/shaelebrown/TDApplied/issues">https://github.com/shaelebrown/TDApplied/issues</a>
</p>
</li></ul>


<hr>
<h2 id='vr_graphs'>Compute Vietoris-Rips graphs of a dataset at particular epsilon radius values.</h2><span id='topic+vr_graphs'></span>

<h3>Description</h3>

<p>Persistence diagrams computed from Rips-Vietoris filtrations contain information about 
distance radius scales at which topological features of a dataset exist, but the features
can be challenging to visualize, analyze and interpret. In order to help solve this problem the 'vr_graphs'
function computes the 1-skeleton (i.e. graph) of Rips complexes at particular radii, called &quot;Vietoris-Rips graphs&quot; (VR graphs) in the literature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vr_graphs(X, distance_mat = FALSE, eps, return_clusters = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vr_graphs_+3A_x">X</code></td>
<td>
<p>either a point cloud data frame/matrix, or a distance matrix.</p>
</td></tr>
<tr><td><code id="vr_graphs_+3A_distance_mat">distance_mat</code></td>
<td>
<p>a boolean representing if the input 'X' is a distance matrix, default value is 'FALSE'.</p>
</td></tr>
<tr><td><code id="vr_graphs_+3A_eps">eps</code></td>
<td>
<p>a numeric vector of the positive scales at which to compute the Rips-Vietoris complexes, i.e. all edges at most the specified values.</p>
</td></tr>
<tr><td><code id="vr_graphs_+3A_return_clusters">return_clusters</code></td>
<td>
<p>a boolean determining if the connected components (i.e. data clusters) of the complex should be explicitly returned, default is 'TRUE'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function may be used in conjunction with the igraph package to visualize the graphs (see <code><a href="#topic+plot_vr_graph">plot_vr_graph</a></code>).
</p>


<h3>Value</h3>

<p>A list with a 'vertices' field, containing the rownames of 'X', and then a list 'graphs' one (named) entry for each value in 'eps'. Each entry is a list with a 'graph' field, storing the (undirected) edges in the Rips-Vietoris complex in matrix format, and a 'clusters' field, containing vectors of the data indices (or row names) in each connected component of the Rips graph.
</p>


<h3>Author(s)</h3>

<p>Shael Brown - <a href="mailto:shaelebrown@gmail.com">shaelebrown@gmail.com</a>
</p>


<h3>References</h3>

<p>A Zomorodian, The tidy set: A minimal simplicial set for computing homology of clique complexes in Proceedings of the Twenty-Sixth Annual Symposium on Computational Geometry, SoCG ’10. (Association for Computing Machinery, New York, NY, USA), p. 257–266 (2010).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_vr_graph">plot_vr_graph</a></code> for plotting VR graphs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(require("TDAstats") &amp; require("igraph"))
{
  # simulate data from the unit circle and calculate 
  # its diagram
  df &lt;- TDAstats::circle2d[sample(1:100,25),]
  diag &lt;- TDAstats::calculate_homology(df,
                                       dim = 1,
                                       threshold = 2)
  
  # get minimum death radius of any data cluster
  min_death_H0 &lt;- 
  min(diag[which(diag[,1] == 0),3L])
  
  # get birth and death radius of the loop
  loop_birth &lt;- as.numeric(diag[nrow(diag),2L])
  loop_death &lt;- as.numeric(diag[nrow(diag),3L])

  # compute VR graphs at radii half of 
  # min_death_H0 and the mean of loop_birth and 
  # loop_death, returning clusters
  graphs &lt;- vr_graphs(X = df,eps = 
  c(0.5*min_death_H0,(loop_birth + loop_death)/2))

  # verify that there are 25 clusters for the smaller radius
  length(graphs$graphs[[1]]$clusters)
  
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
