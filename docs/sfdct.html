<!DOCTYPE html><html><head><title>Help for package sfdct</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sfdct}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sfdct-package'><p>sfdct: Constrained Triangulation for Simple Features</p></a></li>
<li><a href='#antarctica'><p>Antarctica, and not Antarctica.</p></a></li>
<li><a href='#ct_triangulate'><p>Constrained Delaunay Triangulation</p></a></li>
<li><a href='#lakesuperior'><p>Lake Superior polygons.</p></a></li>
<li><a href='#map_world'><p>The 'world' database from the <code>maps</code> package.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Constrained Triangulation for Simple Features</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Build a constrained high quality Delaunay triangulation from simple 
   features objects, applying constraints based on input line segments, and 
   triangle properties including maximum area, minimum internal angle. The 
   triangulation code in 'RTriangle' uses the method of Cheng, Dey and Shewchuk 
   (2012, ISBN:9781584887300). For a low-dependency alternative with low-quality 
   path-based constrained  triangulation see <a href="https://CRAN.R-project.org/package=decido">https://CRAN.R-project.org/package=decido</a> and for high-quality configurable
    triangulation see <a href="https://github.com/hypertidy/anglr">https://github.com/hypertidy/anglr</a>. Also consider comparison
    with the 'GEOS' lib which since version 3.10.0 includes a low quality 
    polygon triangulation method that starts with ear clipping and refines to Delaunay. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a></td>
</tr>
<tr>
<td>License_restricts_use:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, methods, RTriangle, sf, sp, tibble</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr, knitr, maps, rmarkdown, viridisLite</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/hypertidy/sfdct">https://github.com/hypertidy/sfdct</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/hypertidy/sfdct/issues">https://github.com/hypertidy/sfdct/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-08 21:48:59 UTC; mdsumner</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael D. Sumner [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael D. Sumner &lt;mdsumner@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-09 02:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='sfdct-package'>sfdct: Constrained Triangulation for Simple Features</h2><span id='topic+sfdct'></span><span id='topic+sfdct-package'></span>

<h3>Description</h3>

<p>Build a constrained high quality Delaunay triangulation from simple features objects, applying constraints based on input line segments, and triangle properties including maximum area, minimum internal angle. The triangulation code in 'RTriangle' uses the method of Cheng, Dey and Shewchuk (2012, ISBN:9781584887300). For a low-dependency alternative with low-quality path-based constrained triangulation see <a href="https://CRAN.R-project.org/package=decido">https://CRAN.R-project.org/package=decido</a> and for high-quality configurable triangulation see <a href="https://github.com/hypertidy/anglr">https://github.com/hypertidy/anglr</a>. Also consider comparison with the 'GEOS' lib which since version 3.10.0 includes a low quality polygon triangulation method that starts with ear clipping and refines to Delaunay.
</p>
<p>Triangulate simple features including the input edges as constraints, rather than
being bounded to the convex hull.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michael D. Sumner <a href="mailto:mdsumner@gmail.com">mdsumner@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/hypertidy/sfdct">https://github.com/hypertidy/sfdct</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/hypertidy/sfdct/issues">https://github.com/hypertidy/sfdct/issues</a>
</p>
</li></ul>


<hr>
<h2 id='antarctica'>Antarctica, and not Antarctica.</h2><span id='topic+antarctica'></span>

<h3>Description</h3>

<p>See data-raw for original source.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
plot(antarctica, col = rainbow(nrow(antarctica), alpha = 0.4))
</code></pre>

<hr>
<h2 id='ct_triangulate'>Constrained Delaunay Triangulation</h2><span id='topic+ct_triangulate'></span><span id='topic+ct_triangulate.POINT'></span><span id='topic+ct_triangulate.MULTIPOINT'></span><span id='topic+ct_triangulate.GEOMETRYCOLLECTION'></span><span id='topic+ct_triangulate.sfg'></span><span id='topic+ct_triangulate.sfc'></span><span id='topic+ct_triangulate.sf'></span>

<h3>Description</h3>

<p>Triangulate simple features including the input edges as constraints, rather than
being bounded to the convex hull.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ct_triangulate(x, ...)

## S3 method for class 'POINT'
ct_triangulate(x, trim = TRUE, ...)

## S3 method for class 'MULTIPOINT'
ct_triangulate(x, trim = TRUE, ...)

## S3 method for class 'GEOMETRYCOLLECTION'
ct_triangulate(x, trim = TRUE, ...)

## S3 method for class 'sfg'
ct_triangulate(x, trim = TRUE, ...)

## S3 method for class 'sfc'
ct_triangulate(x, ...)

## S3 method for class 'sf'
ct_triangulate(x, trim = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ct_triangulate_+3A_x">x</code></td>
<td>
<p>simple feature geometry or data frame</p>
</td></tr>
<tr><td><code id="ct_triangulate_+3A_...">...</code></td>
<td>
<p>arguments for <code><a href="RTriangle.html#topic+triangulate">triangulate</a></code>, see details</p>
</td></tr>
<tr><td><code id="ct_triangulate_+3A_trim">trim</code></td>
<td>
<p>drop triangles that fall &quot;outside&quot; i.e. &quot;holes&quot; and non-convex regions, <code>TRUE</code> by default</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is not a Delaunay Triangulation by default, but is &quot;mostly-Delaunay&quot;. Use the <code>D = TRUE</code> option,
passed to the underlying function in RTriangle to ensure the criterion is met, as well as edge constraints.
</p>
<p>All POLYGON, LINESTRING, MULTIPOLYGON, and MULTILINESTRING inputs (including those in GEOMETRYCOLLECTION)
are broken down into line segments that are included in the mesh. Holes are removed
by default, but can be retained with the <code>trim</code> argument.
</p>
<p>The triangles are collected as POLYGONs within a GEOMETRYCOLLECTION, and in the case of an <code>sf</code> object
it's returned within the original input data frame.
</p>
<p>There's no way in this package to retain the set of shared vertices, or the segment or
the triangle indices. It is a fundamental feature of the standard, that this information is not represented.
</p>
<p>Further arguments may be passed down to the underlying triangulation function <code><a href="RTriangle.html#topic+triangulate">triangulate</a></code>.
Note that planar coordinates are assumed, no matter what projection the input is in. There's no
sensible meaning to a value for <code>a</code> in units m^2 for a layer that is in longitude/latitude, for those
use &quot;area in square degrees&quot;, the straightforward meaning in planar coordinates.
These arguments are, from the documentation of that function:
</p>

<dl>
<dt>a</dt><dd><p> a Maximum triangle area. If specified, triangles cannot be
larger than this area.</p>
</dd>
<dt>q</dt><dd><p> Minimum triangle angle in degrees.</p>
</dd>
<dt>Y</dt><dd><p> If <code>TRUE</code> prohibits the insertion of Steiner points
on the mesh boundary.</p>
</dd>
<dt>j</dt><dd><p> If <code>TRUE</code> jettisons vertices that are not part of
the final triangulation from the output.</p>
</dd>
<dt>D</dt><dd><p> If <code>TRUE</code> produce a conforming Delaunay
triangulation. This ensures that all the triangles in the mesh are
truly Delaunay, and not merely constrained Delaunay.  This option
invokes Ruppert's original algorithm, which splits every
subsegment whose diametral circle is encroached.  It usually
increases the number of vertices and triangles.</p>
</dd>
<dt>S</dt><dd><p> Specifies the maximum number of added Steiner points.</p>
</dd>
<dt>V</dt><dd><p> Verbosity level. Specify higher values  for more detailed
information about what the Triangle library is doing.</p>
</dd>
<dt>Q</dt><dd><p> If <code>TRUE</code> suppresses all explanation of what the
Triangle library is doing, unless an error occurs. </p>
</dd>
</dl>



<h3>Value</h3>

<p>simple feature column <code><a href="sf.html#topic+st_sfc">st_sfc</a></code> or data frame <code><a href="sf.html#topic+st_sfc">st_sfc</a></code>
</p>


<h3>Note</h3>

<p>GEOMETRYCOLLECTION as input is not yet supported.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
nc &lt;- read_sf(system.file("shape/nc.shp", package="sf"), quiet = TRUE)
nc_triangles &lt;- ct_triangulate(nc[, c("NAME", "geometry")])
plot(nc[, "NAME"])
plot(nc_triangles, add = TRUE, col = NA, lty = "dotted")
idx &lt;- c(4, 5, 6, 7, 8, 20, 21)
op &lt;- par(mfrow = c(2, 1))
if (packageVersion("sf") &lt;= '0.2.8'){
nc &lt;- st_transform(nc, "+proj=eqc +ellps=WGS84")
}

plot(st_triangulate(nc[idx, c("NAME", "geometry")]), col = "grey")

## Warning ct_triangulate does correctly triangulate longitude/latitude data
plot(ct_triangulate(nc[idx, c("NAME", "geometry")]))
</code></pre>

<hr>
<h2 id='lakesuperior'>Lake Superior polygons.</h2><span id='topic+lakesuperior'></span>

<h3>Description</h3>

<p>See data-raw for original source.
</p>

<hr>
<h2 id='map_world'>The 'world' database from the <code>maps</code> package.</h2><span id='topic+map_world'></span>

<h3>Description</h3>

<p>Data is in <code>sf</code> form.
See data-raw for original source.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
