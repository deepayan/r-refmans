<!DOCTYPE html><html><head><title>Help for package crqa</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {crqa}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#crqa-package'>
<p>Unidimensional and Multidimensional Methods for Recurrence Quantification Analysis</p></a></li>
<li><a href='#crqa'><p>Auto, cross and multidimensional recurrence measures</p>
of one, two or multiple time-series, time-delayed and embedded
in higher dimensional space</a></li>
<li><a href='#drpfromts'><p>Diagonal recurrence profile</p></a></li>
<li><a href='#eyemovement'><p>Eye-movement categorical time-series</p></a></li>
<li><a href='#Figure_1'><p>Eye-movement categorical time-series</p></a></li>
<li><a href='#Figure_2'><p>A unidimensional sinusoidal time series</p></a></li>
<li><a href='#Figure_3'><p>Simulated time series of the three dimensions from the Lorenz system</p></a></li>
<li><a href='#Figure_6'><p>Figure_6</p></a></li>
<li><a href='#handmovement'><p>Continuous series of hand movements</p></a></li>
<li><a href='#lorenzattractor'><p>Simulate the Lorenz Attractor</p></a></li>
<li><a href='#mdDelay'><p>Find optimal delay from a multi-dimensional dataset.</p></a></li>
<li><a href='#mdFnn'><p>Find optimal embedding dimension of a multi-dimensional dataset.</p></a></li>
<li><a href='#optimizeParam'><p>Estimate optimal delay, embedding dimension and radius</p>
for continuous time-series data</a></li>
<li><a href='#piecewiseRQA'><p>Compute recurrence plots for long time-series data series</p>
using a block (piece-wise) method.</a></li>
<li><a href='#plotRP'><p>Plot a recurrence matrix</p></a></li>
<li><a href='#simts'><p>Simulate dichotomous binary time-series</p></a></li>
<li><a href='#spdiags'><p>Extract diagonal matrices</p></a></li>
<li><a href='#text'><p>Categorical sequence of words</p></a></li>
<li><a href='#wincrqa'><p>Windowed Recurrence Measures</p></a></li>
<li><a href='#windowdrp'><p>Windowed Recurrence Profile</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Unidimensional and Multidimensional Methods for Recurrence
Quantification Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-06</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Moreno I. Coco &lt;moreno.cocoi@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Auto, Cross and Multi-dimensional recurrence quantification analysis. 
    Different methods for computing recurrence, cross vs. multidimensional
    or profile iti.e., only looking at the diagonal recurrent points, 
    as well as functions for optimization and plotting are proposed.
    in-depth measures of the whole cross-recurrence plot,
    Please refer to Coco and others (2021) &lt;<a href="https://doi.org/10.32614%2FRJ-2021-062">doi:10.32614/RJ-2021-062</a>&gt;,
    Coco and Dale (2014) &lt;<a href="https://doi.org/10.3389%2Ffpsyg.2014.00510">doi:10.3389/fpsyg.2014.00510</a>&gt; 
    and Wallot (2018) &lt;<a href="https://doi.org/10.1080%2F00273171.2018.1512846">doi:10.1080/00273171.2018.1512846</a>&gt;
    for further details about the method.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, pracma, tseriesChaos, gplots, plot3D, rdist</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Collate:</td>
<td>'crqa.R' 'crqa_helpers.R' 'drpfromts.R' 'lorenzattractor.R'
'mdDelay.R' 'mdFnn.R' 'optimizeParam.R' 'piecewiseRQA.R'
'plotRP.R' 'simts.R' 'spdiags.R' 'wincrqa.R' 'windowdrp.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-11 14:21:39 UTC; nak_d</td>
</tr>
<tr>
<td>Author:</td>
<td>Moreno I. Coco [cre, aut],
  Dan Monster [aut],
  Giuseppe Leonardi [aut],
  Rick Dale [aut],
  Sebastian Wallot [aut],
  James D. Dixon [ctb],
  John C. Nash [ctb],
  Alexandra Paxton [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-27 12:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='crqa-package'>
Unidimensional and Multidimensional Methods for Recurrence Quantification Analysis
</h2><span id='topic+crqa-package'></span>

<h3>Description</h3>

<p>Auto, Cross and Multi-dimensional recurrence quantification analysis. 
Different methods for computing recurrence, cross vs. multidimensional
or profile iti.e., only looking at the diagonal recurrent points, 
as well as functions for optimization and plotting are proposed.
in-depth measures of the whole cross-recurrence plot,
Please refer to by Coco and Dale (2014) &lt;doi:10.3389/fpsyg.2014.00510&gt; 
and Wallot (2018) &lt;doi: 10.1080/00273171.2018.1512846&gt;
for further details about the method.
</p>


<h3>Details</h3>

<p><code>crqa</code>: Core recurrence function, which examines
recurrent structures of a single rqa, two crqa, 
or multidimensional time-series mdcrqa, which are
time-delayed and embedded in higher dimensional space.
The approach compares the phase space trajectories of 
the time-series in the same phase-space when delays are
introduced. A distance matrix between the time-series,
delayed and embedded is calculated. Several measures
representative of the underlying dynamics of the system
are extracted.
</p>
<p><code>drpfromts</code>: Method to explore the diagonal profile of 
the recurrence plot (Auto, Cross, or Multi-dimensional).
It returns the recurrence for different delays, 
the maximal recurrence observed and the delay at which it occurred.
</p>
<p><code>lorenzattractor</code>: An implementation of the Lorenz dynamical system,
which describes the motion of a possible particle, which will
neither converge to a steady state, nor diverge to infinity;
but rather stay in a bounded but 'chaotically' defined
region, i.e., an attractor. 
</p>
<p><code>mdDelay</code>:Estimates time delay for embedding of a 
multi-dimensional dataset.
</p>
<p><code>mdFnn</code>: Computes the percentage of false nearest
neighbors for multidimensional time series as a function 
of embedding dimension.
</p>
<p><code>optimizeParam</code>:   Iterative procedure to examine the values
of delay, embedding dimension and radius 
to compute recurrence plots of one, two, 
or more time-series.
</p>
<p><code>piecewiseRQA</code>: This is a convenience function which breaks down 
the computation of large recurrence plots into a collection of
smaller recurrence plots. It can ease speed and memory issues
if an appropriate size for the block is found.
</p>
<p><code>plotRP</code>: A convenience function to plot the RP matrix returned by 
the crqa.
</p>
<p><code>simts</code>: A simple algorithm for producing a time-series that drives
a second time-series using parameters, which change independent and conditional
probability of an event to occur.
</p>
<p><code>wincrqa</code>: A recurrence plot is computed in overlapping
windows of a certain size for a number of delays smaller
than the size of the window; and measures of it extracted.
</p>
<p><code>windowdrp</code>:  A recurrence plot is computed in overlapping
windows of a specified size for a number of
delays smaller than the size of the window.
In every window, the recurrence value for the
different delays is calculated.
A mean is then taken across the delays to obtain
a recurrence value in that particular window.
</p>


<h3>Author(s)</h3>

<p>Moreno I. Coco <a href="mailto:moreno.cocoi@gmail.com">moreno.cocoi@gmail.com</a>
Dan Monster <a href="mailto:danm@econ.au.dk">danm@econ.au.dk</a>
Giuseppe Leonardi <a href="mailto:g.leonardi@vizja.pl">g.leonardi@vizja.pl</a>
Rick Dale <a href="mailto:rdale@ucla.edu">rdale@ucla.edu</a> 
Sebastian Wallot <a href="mailto:sebastian.wallot@ae.mpg.de">sebastian.wallot@ae.mpg.de</a> 
</p>


<h3>References</h3>

<p>Webber Jr, C. L., and Zbilut, J. P. (2005). Recurrence
quantification analysis of nonlinear dynamical systems.
Tutorials in contemporary nonlinear methods for the
behavioral sciences, 26-94.
</p>
<p>Marwan, N., and Kurths, J. Nonlinear analysis of bivariate
data with cross recurrence plots. Physics Letters A 302.5
(2002): 299-307.
</p>
<p>Coco, M. I., Monster, D., Leonardi, G., Dale, R., &amp; Wallot, S. (2021). 
Unidimensional and Multidimensional Methods for Recurrence 
Quantification Analysis with crqa. R Journal, 13(1).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# use the available data
data(crqa) 

listener = eyemovement$listener
narrator = eyemovement$narrator

delay = 1; embed = 1; rescale = 0; radius = .1;
normalize = 0; mindiagline = 2; minvertline = 2;
tw = 0; whiteline = FALSE; recpt = FALSE; side = "both"
method = 'crqa'; metric = 'euclidean';  
datatype = "categorical"

ans = crqa(narrator, listener, delay, embed, rescale, radius, normalize, 
           mindiagline, minvertline, tw, whiteline, recpt, side, method, metric, 
           datatype)

print(ans[1:10]) ## last argument of list is the recurrence plot


</code></pre>

<hr>
<h2 id='crqa'>Auto, cross and multidimensional recurrence measures 
of one, two or multiple time-series, time-delayed and embedded 
in higher dimensional space
</h2><span id='topic+crqa'></span>

<h3>Description</h3>

<p>Core recurrence function, which examines
recurrent structures of a single (rqa), two (crqa), 
or multidimensional time-series (mdcrqa), which are
time-delayed and embedded in higher dimensional space.
The approach compares the phase space trajectories of 
the time-series in the same phase-space when delays are
introduced. A distance matrix between the time-series,
delayed and embedded is calculated. Several measures
representative of the underlying dynamics of the system
are extracted (explained below).</p>


<h3>Usage</h3>

<pre><code class='language-R'>crqa(ts1, ts2, delay, embed, rescale, radius, normalize,
mindiagline, minvertline, tw, whiteline, recpt, side, method,
metric, datatype)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crqa_+3A_ts1">ts1</code></td>
<td>
<p>First time-series dataset.</p>
</td></tr>
<tr><td><code id="crqa_+3A_ts2">ts2</code></td>
<td>
<p>Second time-series dataset</p>
</td></tr>
<tr><td><code id="crqa_+3A_delay">delay</code></td>
<td>
<p>The delay unit by which the series are lagged.</p>
</td></tr>
<tr><td><code id="crqa_+3A_embed">embed</code></td>
<td>
<p>The number of embedding dimension for
phase-reconstruction, i.e., the lag intervals.</p>
</td></tr>
<tr><td><code id="crqa_+3A_rescale">rescale</code></td>
<td>
<p>Rescale the distance matrix;
if rescale = 0 (do nothing);
if rescale = 1 (mean distance of entire matrix);
if rescale = 2 (maximum distance of entire matrix).
if rescale = 3 (minimum distance of entire matrix).
if rescale = 4 (euclidean distance of entire matrix).</p>
</td></tr>
<tr><td><code id="crqa_+3A_radius">radius</code></td>
<td>
<p>A threshold, cut-off, constant used to
decide whether two points are recurrent or not.</p>
</td></tr>
<tr><td><code id="crqa_+3A_normalize">normalize</code></td>
<td>
<p>Normalize the time-series;
if normalize = 0 (do nothing);
if normalize = 1 (Unit interval);
if normalize =  2 (z-score).</p>
</td></tr>
<tr><td><code id="crqa_+3A_mindiagline">mindiagline</code></td>
<td>
<p>A minimum diagonal length of
recurrent points. Usually set to 2, as it takes
a minimum of two points to define any line.</p>
</td></tr>
<tr><td><code id="crqa_+3A_minvertline">minvertline</code></td>
<td>
<p>A minimum vertical length of
recurrent points.</p>
</td></tr>
<tr><td><code id="crqa_+3A_tw">tw</code></td>
<td>
<p>The Theiler window parameter</p>
</td></tr>
<tr><td><code id="crqa_+3A_whiteline">whiteline</code></td>
<td>
<p>A logical flag to calculate (TRUE)
or not (FALSE) empty vertical lines.</p>
</td></tr>
<tr><td><code id="crqa_+3A_recpt">recpt</code></td>
<td>
<p>A logical flag indicating whether
measures of cross-recurrence are calculated directly
from a recurrent plot (TRUE) or not (FALSE).</p>
</td></tr>
<tr><td><code id="crqa_+3A_side">side</code></td>
<td>
<p>A string indicating whether recurrence measures
should be calculated in the 'upper' triangle of the RP
'lower' triangle of the matrix, or 'both'.
LOC is automatically excluded for 'upper' and 'lower'.</p>
</td></tr>
<tr><td><code id="crqa_+3A_method">method</code></td>
<td>
<p>A string to indicate the type of recurrence
analysis to peform. There are three options:
rqa (autorecurrence); crqa(cross-recurrence); 
mdcrqa(multidimensional recurrence). Default value is crqa</p>
</td></tr>
<tr><td><code id="crqa_+3A_metric">metric</code></td>
<td>
<p>A string to indicate the type of 
distance metric used, default is euclidean but 
see help rdist() to list all other possible metrics.</p>
</td></tr> 
<tr><td><code id="crqa_+3A_datatype">datatype</code></td>
<td>
<p>a string (continuous or categorical) 
to indicate whether the nature of the data type</p>
</td></tr>	
</table>


<h3>Details</h3>

<p>We recommend setting whiteline = FALSE, as the current
version of the library does not make use of such
information to extract recurrence measures.
</p>


<h3>Value</h3>

<p>If a recurrence plot (RP) can be calculated and hence 
recurrence observed the function will returna a list with 
different measures extracted. 
Otherwise, the values for the output arguments will be
either 0 or NA.
</p>
<table>
<tr><td><code>RR</code></td>
<td>
<p>The percentage of recurrent points falling within
the specified radius (range between 0 and 100)</p>
</td></tr>
<tr><td><code>DET</code></td>
<td>
<p>Proportion of recurrent points forming diagonal
line structures.</p>
</td></tr>
<tr><td><code>NRLINE</code></td>
<td>
<p>The total number of lines in the recurrent plot</p>
</td></tr>
<tr><td><code>maxL</code></td>
<td>
<p>The length of the longest diagonal line
segment in the plot, excluding the main diagonal</p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p>The average length of line structures</p>
</td></tr>
<tr><td><code>ENTR</code></td>
<td>
<p>Shannon information entropy of
diagonal line lengths longer than the minimum length</p>
</td></tr>
<tr><td><code>rENTR</code></td>
<td>
<p>Entropy measure normalized by the number of
lines observed in the plot. Handy to compare across contexts
and conditions</p>
</td></tr>
<tr><td><code>LAM</code></td>
<td>
<p>Proportion of recurrent points forming vertical
line structures</p>
</td></tr>
<tr><td><code>TT</code></td>
<td>
<p>The average length of vertical line structures</p>
</td></tr>
<tr><td><code>catH</code></td>
<td>
<p>Entropy of categorical recurrence plots based on rectangular block structures</p>
</td></tr>
<tr><td><code>RP</code></td>
<td>
<p>The Recurrence Plot sparse matrix data</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Original bits of this code were translated from a Matlab
version provided by Rick Dale, and created during 
the Non-Linear Methods for Psychological Science
summer school held at the University of Cincinnati
in 2012. The multi-dimensional method for the crqa function 
has been written together with Sebastian Wallot 
(sebastian.wallot at aesthetics.mpg.de )</p>


<h3>Author(s)</h3>

<p>Moreno I. Coco (moreno.cocoi@gmail.com)</p>


<h3>References</h3>

<p>Coco, M. I., and Dale, R. (2014). Cross-recurrence quantification analysis of categorical and continuous time series: an R package. Frontiers in psychology, 5, 510.
</p>
<p>Wallot, S. (2018). Multidimensional Cross-Recurrence Quantification Analysis (MdCRQA) a method for quantifying correlation between multivariate time-series. Multivariate behavioral research, 1-19</p>


<h3>See Also</h3>

<p><code><a href="#topic+spdiags">spdiags</a></code>, <code><a href="#topic+simts">simts</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# use the available data
data(crqa) 

listener = eyemovement$listener
narrator = eyemovement$narrator

delay = 1; embed = 1; rescale = 0; radius = .1;
normalize = 0; mindiagline = 2; minvertline = 2;
tw = 0; whiteline = FALSE; recpt = FALSE; side = "both"
method = 'crqa'; metric = 'euclidean';  
datatype = "categorical"

ans = crqa(narrator, listener, delay, embed, rescale, radius, normalize, 
           mindiagline, minvertline, tw, whiteline, recpt, side, method,
           metric, datatype)

print(ans[1:10]) ## last argument of list is the recurrence plot

</code></pre>

<hr>
<h2 id='drpfromts'>Diagonal recurrence profile</h2><span id='topic+drpfromts'></span>

<h3>Description</h3>

<p>Method to explore the diagonal profile of 
the recurrence plot (Auto, Cross, or Multi-dimensional).
It returns the recurrence for different delays, 
the maximal recurrence observed and the delay at which it occurred.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> drpfromts(ts1, ts2, windowsize, radius,
delay, embed, rescale, normalize, mindiagline, minvertline, tw,
whiteline, recpt, side, method, metric, datatype) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drpfromts_+3A_ts1">ts1</code></td>
<td>
<p>First time-series</p>
</td></tr>
<tr><td><code id="drpfromts_+3A_ts2">ts2</code></td>
<td>
<p>Second time-series</p>
</td></tr>
<tr><td><code id="drpfromts_+3A_windowsize">windowsize</code></td>
<td>
<p>A constant indicating the range of delays
(positive and negative) to explore</p>
</td></tr>
<tr><td><code id="drpfromts_+3A_radius">radius</code></td>
<td>
<p>A threshold, cut-off, constant used
to decide whether two points are recurrent or not.</p>
</td></tr>
<tr><td><code id="drpfromts_+3A_delay">delay</code></td>
<td>
<p>The delay unit by which the series are lagged.</p>
</td></tr>
<tr><td><code id="drpfromts_+3A_embed">embed</code></td>
<td>
<p>The number of embedding dimension for
phase-reconstruction, i.e., the lag intervals.</p>
</td></tr>
<tr><td><code id="drpfromts_+3A_rescale">rescale</code></td>
<td>
<p>Rescale the distance matrix;
if rescale = 0 (do nothing);
if rescale = 1 (mean distance of entire matrix);
if rescale = 2 (maximum distance of entire matrix).
if rescale = 3 (minimum distance of entire matrix).
if rescale = 4 (euclidean distance of entire matrix).</p>
</td></tr>
<tr><td><code id="drpfromts_+3A_normalize">normalize</code></td>
<td>
<p>Normalize the time-series;
if normalize = 0 (do nothing);
if normalize = 1 (Unit interval);
if normalize =  2 (z-score).</p>
</td></tr>
<tr><td><code id="drpfromts_+3A_mindiagline">mindiagline</code></td>
<td>
<p>A minimum diagonal length of
recurrent points. Usually set to 2, as it takes
a minimum of two points to define any line.</p>
</td></tr>
<tr><td><code id="drpfromts_+3A_minvertline">minvertline</code></td>
<td>
<p>A minimum vertical length of
recurrent points.</p>
</td></tr>
<tr><td><code id="drpfromts_+3A_tw">tw</code></td>
<td>
<p>The Theiler window parameter</p>
</td></tr>
<tr><td><code id="drpfromts_+3A_whiteline">whiteline</code></td>
<td>
<p>A logical flag to calculate (TRUE)
or not (FALSE) empty vertical lines.</p>
</td></tr>
<tr><td><code id="drpfromts_+3A_recpt">recpt</code></td>
<td>
<p>A logical flag indicating whether
measures of cross-recurrence are calculated directly
from a recurrent plot (TRUE) or not (FALSE).</p>
</td></tr>
<tr><td><code id="drpfromts_+3A_side">side</code></td>
<td>
<p>A string indicating whether recurrence measures
should be calculated in the 'upper' triangle of the RP
'lower' triangle of the matrix, or 'both'.
LOC is automatically excluded for 'upper' and 'lower'.</p>
</td></tr>
<tr><td><code id="drpfromts_+3A_method">method</code></td>
<td>
<p>A string to indicate the type of recurrence
analysis to peform. There are three options:
rqa (autorecurrence); crqa(cross-recurrence); 
mdcrqa(multidimensional recurrence). Default value is crqa</p>
</td></tr>
<tr><td><code id="drpfromts_+3A_metric">metric</code></td>
<td>
<p>A string to indicate the type of 
distance metric used, default is euclidean but 
see help rdist() to list all other possible metrics.</p>
</td></tr> 
<tr><td><code id="drpfromts_+3A_datatype">datatype</code></td>
<td>
<p>a string (continuous or categorical) 
to indicate whether the nature of the data type</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following arguments:
</p>
<table>
<tr><td><code>profile</code></td>
<td>
<p>A vector of recurrence (ranging from 0,1)
with length equal to the number of delays explored</p>
</td></tr>
<tr><td><code>maxrec</code></td>
<td>
<p>Maximal recurrence observed between the
two-series</p>
</td></tr>
<tr><td><code>maxlag</code></td>
<td>
<p>Delay at which maximal recurrence is
observed</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Moreno I. Coco (moreno.cocoi@gmail.com)</p>


<h3>See Also</h3>

<p><code><a href="#topic+windowdrp">windowdrp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# use the available data
data(crqa) 

listener = eyemovement$listener
narrator = eyemovement$narrator

res = drpfromts(narrator, listener, windowsize = 100,
                 radius = 0.001, delay = 1, embed = 1, rescale = 0,
                 normalize = 0, mindiagline = 2, minvertline = 2,
                 tw = 0, whiteline = FALSE, recpt = FALSE, 
                 side = 'both', method = 'crqa', 
                 metric = 'euclidean', datatype = 'continuous')

 profile = res$profile

 plot(seq(1,length(profile),1), profile, type = "l", lwd = 5,
     xaxt = "n", xlab = "Lag", ylab = "Recurrence")

</code></pre>

<hr>
<h2 id='eyemovement'>Eye-movement categorical time-series</h2><span id='topic+eyemovement'></span>

<h3>Description</h3>

<p>A two-columns dataset of eye-movement fixation scan-pattern, 
which are temporal sequences of fixated objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eyemovement</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 rows and 2 variables:
</p>

<dl>
<dt>listener</dt><dd><p>the listener time series</p>
</dd>
<dt>narrator</dt><dd><p>the narrator time series</p>
</dd>
</dl>



<h3>References</h3>

<p>Richardson, D. C., and Dale, R. (2005). Looking to
understand: The coupling between speakers and listeners
eye movements and its relationship to discourse
comprehension. Cognitive Science, 29, 39-54.
</p>

<hr>
<h2 id='Figure_1'>Eye-movement categorical time-series</h2><span id='topic+Figure_1'></span>

<h3>Description</h3>

<p>Three time series (1250 observations) organised as columns and simulating data from: a periodical sine wave, one of the dimensions of the Lorenz attractor and a white noise signal. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Figure_1</code></pre>


<h3>Format</h3>

<p>A data frame with 1250 rows and 3 columns:
</p>

<dl>
<dt>sinus</dt><dd><p>A periodical sine wave</p>
</dd>
<dt>lorenz</dt><dd><p>One dimension of a Lorenz attractor</p>
</dd>
<dt>wnoise</dt><dd><p>White noise</p>
</dd>
</dl>


<hr>
<h2 id='Figure_2'>A unidimensional sinusoidal time series</h2><span id='topic+Figure_2'></span>

<h3>Description</h3>

<p>A unidimensional sinusoidal time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Figure_2</code></pre>


<h3>Format</h3>

<p>A data frame with 45 rows and 1 column:
</p>

<dl>
<dt>V1</dt><dd><p>A unidimensional sinusoidal time series</p>
</dd>
</dl>


<hr>
<h2 id='Figure_3'>Simulated time series of the three dimensions from the Lorenz system</h2><span id='topic+Figure_3'></span>

<h3>Description</h3>

<p>Simulated time series of the three dimensions from the Lorenz system
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Figure_3</code></pre>


<h3>Format</h3>

<p>A data frame with 2048 rows and 3 columns:
</p>

<dl>
<dt>V1</dt><dd><p>First dimension of the Lorenz system</p>
</dd>
<dt>V2</dt><dd><p>Second dimension of the Lorenz system</p>
</dd>
<dt>V3</dt><dd><p>Third dimension of the Lorenz system</p>
</dd>
</dl>


<hr>
<h2 id='Figure_6'>Figure_6</h2><span id='topic+Figure_6'></span>

<h3>Description</h3>

<p>Speed (time in seconds) and memory (peak RAM in MB) performance of crqa() 
and piecewiseRQA() for simulated data of increasing size 
(from 3000 to 7000 data points), compared in  blocks of different 
sizes (from 1000 to 6500 in increments of 500)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Figure_6</code></pre>


<h3>Format</h3>

<p>A data frame with 28 rows and 2 variables:
</p>

<dl>
<dt>speed</dt><dd><p>The time in seconds to perform a crqa() analysis</p>
</dd>
<dt>memory</dt><dd><p>The peak MB occupied in the RAM to perform a crqa() analysis</p>
</dd>
<dt>typeRQA</dt><dd><p>Whether the analysis contained all data points (full) or was
computed piecewise (piece)</p>
</dd>
<dt>datapoint</dt><dd><p>The number of datapoints</p>
</dd>
<dt>blocksize</dt><dd><p>The dimension of the block</p>
</dd>
</dl>


<hr>
<h2 id='handmovement'>Continuous series of hand movements</h2><span id='topic+handmovement'></span>

<h3>Description</h3>

	
<p>Hand-movement velocity profiles of two participants (P1 and P2) for the dominant (d) and non-dominant (n) hand. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handmovement</code></pre>


<h3>Format</h3>

<p>A dataframe of 5799 observations.
</p>

<dl>
<dt>P1_TT_d</dt><dd><p>Participant 1 dominant hand</p>
</dd>
<dt>P1_TT_n</dt><dd><p>Participant 1 non-dominant hand</p>
</dd>
<dt>P2_TT_d</dt><dd><p>Participant 2 dominant hand</p>
</dd>
<dt>P2_TT_n</dt><dd><p>Participant 2 non-dominant</p>
</dd>
</dl>



<h3>References</h3>

<p>Wallot, S., Mitkidis, P., McGraw, J. J. and Roepstorff, A. (2016). Beyond synchrony: joint action in a complex production task reveals beneficial effects of decreased interpersonal synchrony. PloS one, 11(12), e0168306.
</p>

<hr>
<h2 id='lorenzattractor'>Simulate the Lorenz Attractor</h2><span id='topic+lorenzattractor'></span>

<h3>Description</h3>

<p>An implementation of the Lorenz dynamical system,
which describes the motion of a possible particle, which will
neither converge to a steady state, nor diverge to infinity;
but rather stay in a bounded but 'chaotically' defined
region, i.e., an attractor. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lorenzattractor(numsteps, dt, sigma, r, b, plots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lorenzattractor_+3A_numsteps">numsteps</code></td>
<td>
<p>The number of simulated points</p>
</td></tr>
<tr><td><code id="lorenzattractor_+3A_dt">dt</code></td>
<td>
<p>System parameter</p>
</td></tr>
<tr><td><code id="lorenzattractor_+3A_sigma">sigma</code></td>
<td>
<p>System parameter</p>
</td></tr>
<tr><td><code id="lorenzattractor_+3A_r">r</code></td>
<td>
<p>System parameter</p>
</td></tr>
<tr><td><code id="lorenzattractor_+3A_b">b</code></td>
<td>
<p>System parameter</p>
</td></tr>
<tr><td><code id="lorenzattractor_+3A_plots">plots</code></td>
<td>
<p>If TRUE, it plots the Lorenz obtained</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a matrix with the 3 dimensions of the Lorenz
</p>


<h3>Author(s)</h3>

<p>Moreno I. Coco (moreno.cocoi@gmail.com) </p>


<h3>References</h3>

<p>Lorenz, Edward Norton (1963). Deterministic nonperiodic flow.
Journal of the Atmospheric Sciences 20(2) 130-141.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## initialize the parameters
numsteps = 2 ^ 11; dt = .01; sigma = 10; r = 28; b = 8/3;
plots = TRUE

res = lorenzattractor(numsteps, dt, sigma, r, b, plots)

</code></pre>

<hr>
<h2 id='mdDelay'>Find optimal delay from a multi-dimensional dataset.</h2><span id='topic+mdDelay'></span>

<h3>Description</h3>

<p>Estimates time delay for embedding of a 
multi-dimensional dataset.</p>


<h3>Usage</h3>

<pre><code class='language-R'> mdDelay(data, nbins, maxlag, criterion, threshold) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mdDelay_+3A_data">data</code></td>
<td>
<p>The matrix containing all variables</p>
</td></tr>
<tr><td><code id="mdDelay_+3A_nbins">nbins</code></td>
<td>
<p>The number of bins considered to estimate mutual information</p>
</td></tr>
<tr><td><code id="mdDelay_+3A_maxlag">maxlag</code></td>
<td>
<p>Number of lags considered</p>
</td></tr>
<tr><td><code id="mdDelay_+3A_criterion">criterion</code></td>
<td>
<p>A string to indicate what delay optizes
mutual information: 'firstBelow' uses the lowest delay 
at which the AMI function drops below the value set 
by the threshold parameter. 'localMin' uses the position 
of the first local minimum of the AMI function.
The categorical state on which phi is calculated</p>
</td></tr>
<tr><td><code id="mdDelay_+3A_threshold">threshold</code></td>
<td>
<p>Value to select the delay when AMI drops below it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns the recurrence phi-coefficient profile for
state k for all delays considered
</p>


<h3>Author(s)</h3>

<p>Sebastian Wallot, Max Planck Insitute for Empirical Aesthetics
Dan Moenster, Aarhus University, 
Moreno I. Coco, University of East London</p>


<h3>References</h3>

<p>Wallot, S., and Moenster, D. (2018). Calculation of 
average mutual information (AMI) and false-nearest neighbors (FNN) 
for the estimation of embedding parameters of multidimensional time
-series in Matlab. Front. Psychol. - Quantitative Psychology and
Measurement</p>


<h3>See Also</h3>

<p><code><a href="#topic+mdFnn">mdFnn</a></code>, <code><a href="#topic+optimizeParam">optimizeParam</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
nbins = 10; maxlag = 10; criterion = "firstBelow"; threshold = exp(-1)

data(crqa) ## load the data

handset = handmovement[1:300, ] ## take less points

mdDelay(handset, nbins, maxlag, criterion, threshold)



</code></pre>

<hr>
<h2 id='mdFnn'>Find optimal embedding dimension of a multi-dimensional dataset.</h2><span id='topic+mdFnn'></span>

<h3>Description</h3>

<p>Computes the percentage of false nearest
neighbors for multidimensional time series as a function 
of embedding dimension.</p>


<h3>Usage</h3>

<pre><code class='language-R'> mdFnn(data, tau, maxEmb, numSamples, Rtol, Atol) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mdFnn_+3A_data">data</code></td>
<td>
<p>The matrix of data to estimate FNN.</p>
</td></tr>
<tr><td><code id="mdFnn_+3A_tau">tau</code></td>
<td>
<p>Time delay for embedding.</p>
</td></tr>
<tr><td><code id="mdFnn_+3A_maxemb">maxEmb</code></td>
<td>
<p>Maximum number of embedding dimensions considered</p>
</td></tr>
<tr><td><code id="mdFnn_+3A_numsamples">numSamples</code></td>
<td>
<p>Number of randomly drawn coordinates from phase-space used to estimate FNN</p>
</td></tr>
<tr><td><code id="mdFnn_+3A_rtol">Rtol</code></td>
<td>
<p>First distance criterion for separating false neighbors</p>
</td></tr>
<tr><td><code id="mdFnn_+3A_atol">Atol</code></td>
<td>
<p>Second distance criterion for separating false neighbors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns the percentage of false neighbors for each embedding.
</p>


<h3>Author(s)</h3>

<p>Sebastian Wallot, Max Planck Insitute for Empirical Aesthetics
Dan Moenster, Aarhus University, 
Moreno I. Coco, University of East London</p>


<h3>References</h3>

<p>Kennel, M. B., Brown, R., &amp; Abarbanel, H. D. (1992).
Determining embedding dimension for phase-space reconstruction using
a geometrical construction. Physical review A, 45, 3403.
Wallot, S., and Moenster, D. (2018). Calculation of average mutual
information (AMI) and false-nearest neighbors (FNN) for the
estimation of embedding parameters of multidimensional time-series in
Matlab. Front. Psychol. - Quantitative Psychology and Measurement
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mdDelay">mdDelay</a></code>, <code><a href="#topic+optimizeParam">optimizeParam</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
tau = 1; maxEmb = 10; numSamples = 500; Rtol = 10; Atol = 2

data(crqa) ## load the data

handset = handmovement[1:300, ] ## take less points

mdFnn(handset, tau, maxEmb, numSamples, Rtol, Atol)

</code></pre>

<hr>
<h2 id='optimizeParam'>Estimate optimal delay, embedding dimension and radius
for continuous time-series data</h2><span id='topic+optimizeParam'></span>

<h3>Description</h3>

<p>Iterative procedure to examine the values
of delay, embedding dimension and radius 
to compute recurrence plots of one, two, 
or more time-series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimizeParam(ts1, ts2, par, min.rec, max.rec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimizeParam_+3A_ts1">ts1</code></td>
<td>
<p>First time-series</p>
</td></tr>
<tr><td><code id="optimizeParam_+3A_ts2">ts2</code></td>
<td>
<p>Second time-series</p>
</td></tr>
<tr><td><code id="optimizeParam_+3A_par">par</code></td>
<td>
<p>A list of parameters needed for the optimization, 
refer to the Details section.</p>
</td></tr>
<tr><td><code id="optimizeParam_+3A_min.rec">min.rec</code></td>
<td>
<p>The minimum value of recurrence accepted.
Default = 2</p>
</td></tr>
<tr><td><code id="optimizeParam_+3A_max.rec">max.rec</code></td>
<td>
<p>The maximum value of recurrence accepted.
Default = 5</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The optimization can be applied both to uni-dimensional 
time-series (method = crqa), or multi-dimensional (method = mdcrqa)
</p>
<p>The procedure is identical in both cases:
</p>
<p>1) Identify a delay that accommodates both time-series
by finding the local minimum where mutual information
between them drops, and starts to level off.
When one ts has a considerably longer delay indicated
than the another, the function selects the longer delay
of the two to ensure that new information is gained for
both. When the delays are close to each other, the
function computes the mean of the two delays.
</p>
<p>2) Determine embedding dimensions by using false nearest
neighbors and checking when it bottoms out (i.e., there
is no gain in adding more dimensions). If the embedding
dimension for the two ts are different the algorithm
selects the higher embedding dimension of the two to
make sure that both time series are sufficiently unfolded.
</p>
<p>3) Determine radius yielding a recurrence rate between 2-5
To do so, we first determine a starting radius that yields 
approximately 25
We generate a sampled sequence of equally spaced possible 
radi from such radius till 0, using as unit for the sequence 
step, the standard deviation of the distance matrix divided 
by a scaling parameter (radiusspan). The larger this parameter,
the finer the unit.
</p>
<p>For uni-dimensional time-series, the user has to decide how to 
choose the value of average mutual information (i.e., <code>typeami = mindip</code>, 
the lag at which minimal information is observed, or <code>typeami = maxlag</code>, 
the maximum lag at which minimal information is observed) and the relative
percentage of information gained in FNN, relative to the first embedding 
dimension, when higher embeddings are considered (i.e., <code>fnnpercent</code>). 
Then, as <code>crqa</code> is integrated in the <code>optimizeParam</code> to estimate the
radius, most of the arguments are the same (e.g., <code>mindiagline</code> 
or <code>tw</code>).
</p>
<p>For multidimensional series, the user needs to specify the right RQA method 
(i.e., <code>method = "mdcrqa"</code>). Then, for the estimation of the delay via
AMI: (1) <code>nbins</code> the number of bins to compute the two-dimensional 
histogram of the original and delayed time series and (2) the <code>criterion</code> 
to select the delay (<code>firstBelow</code> to use the lowest delay at which the AMI
function drops below the value set by the <code>threshold</code> argument, and 
<code>localMin</code> to use the position of the first local AMI minimum). 
The estimation of the embedding dimensions instead needs the following arguments:
(1) <code>maxEmb</code>, which is the maximum number of embedding dimensions considered,
(2) <code>noSamples</code>, which is the number of randomly drawn coordinates 
from phase-space used to estimate the percentage of false-nearest neighbors,
(3) <code>Rtol</code>, which is the first distance criterion for separating false
neighbors, and (4) <code>Atol</code>, which is the second distance criterion for
separating false neighbors. The radius is estimated as before.
</p>


<h3>Value</h3>

<p>It returns a list with the following arguments:
</p>
<table>
<tr><td><code>radius</code></td>
<td>
<p>The optimal radius value found</p>
</td></tr>
<tr><td><code>emddim</code></td>
<td>
<p>Number of embedding dimensions</p>
</td></tr>
<tr><td><code>delay</code></td>
<td>
<p>The lag parameter.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>As <code>optimizeParam</code> uses <code>crqa</code> to estimate
the parameters: the additional arguments normalize,
rescale, mindiagline, minvertline, whiteline,
recpt should be supplied in the par list.
Set up relatively large radiusspan (e.g. 100), 
for a decent coverage of radius values.
</p>


<h3>Author(s)</h3>

<p>Moreno I. Coco (moreno.cocoi@gmail.com),
James A. Dixon (james.dixon@uconn.edu)
Sebastian Wallot, Max Planck Insitute for Empirical Aesthetics
Dan Moenster, Aarhus University
</p>


<h3>References</h3>

<p>Marwan, N., Carmen Romano, M., Thiel, M., and Kurths, J.
(2007). Recurrence plots for the analysis of
complex systems. Physics Reports, 438(5), 237-329.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+crqa">crqa</a></code>, <code><a href="#topic+wincrqa">wincrqa</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(crqa) ## load the data

handset = handmovement[1:300, ] ## take less points

P1 = cbind(handset$P1_TT_d, handset$P1_TT_n) 
P2 = cbind(handset$P2_TT_d, handset$P2_TT_n)

par = list(method = "mdcrqa", metric = "euclidean", maxlag =  20, 
           radiusspan = 100, radiussample = 40, normalize = 0, 
           rescale = 4, mindiagline = 10, minvertline = 10, tw = 0, 
           whiteline = FALSE, recpt = FALSE, side = "both", 
           datatype = "continuous", fnnpercent  = NA,  
           typeami = NA, nbins  = 50, criterion = "firstBelow",
           threshold = 1, maxEmb = 20, numSamples = 500, 
           Rtol = 10, Atol = 2)

results = optimizeParam(P1, P2, par, min.rec = 2, max.rec = 5)
print(unlist(results))
           

</code></pre>

<hr>
<h2 id='piecewiseRQA'>Compute recurrence plots for long time-series data series
using a block (piece-wise) method.</h2><span id='topic+piecewiseRQA'></span>

<h3>Description</h3>

<p>This is a convenience function which breaks down 
the computation of large recurrence plots into a collection of
smaller recurrence plots. It can ease speed and memory issues
if an appropriate size for the block is found.</p>


<h3>Usage</h3>

<pre><code class='language-R'>piecewiseRQA(ts1, ts2, blockSize, delay, embed, rescale, radius,
normalize, mindiagline, minvertline, tw, whiteline, recpt, side, 
method, metric, datatype, typeRQA, windowsize)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="piecewiseRQA_+3A_ts1">ts1</code></td>
<td>
<p>First time-series.</p>
</td></tr>
<tr><td><code id="piecewiseRQA_+3A_ts2">ts2</code></td>
<td>
<p>Second time-series.</p>
</td></tr>
<tr><td><code id="piecewiseRQA_+3A_blocksize">blockSize</code></td>
<td>
<p>The dimension of the time-series subunit in which the-recurrence plot will be computed</p>
</td></tr>
<tr><td><code id="piecewiseRQA_+3A_delay">delay</code></td>
<td>
<p>The delay unit by which the series are lagged.</p>
</td></tr>
<tr><td><code id="piecewiseRQA_+3A_embed">embed</code></td>
<td>
<p>The number of embedding dimension for
phase-reconstruction, i.e., the lag intervals.</p>
</td></tr>
<tr><td><code id="piecewiseRQA_+3A_rescale">rescale</code></td>
<td>
<p>Rescale the distance matrix;
if rescale = 0 (do nothing);
if rescale = 1 (mean distance of entire matrix);
if rescale = 2 (maximum distance of entire matrix).
if rescale = 3 (minimum distance of entire matrix).
if rescale = 4 (euclidean distance of entire matrix).</p>
</td></tr>
<tr><td><code id="piecewiseRQA_+3A_radius">radius</code></td>
<td>
<p>A threshold, cut-off, constant used to
decide whether two points are recurrent or not.</p>
</td></tr>
<tr><td><code id="piecewiseRQA_+3A_normalize">normalize</code></td>
<td>
<p>Normalize the time-series;
if normalize = 0 (do nothing);
if normalize = 1 (Unit interval);
if normalize =  2 (z-score).</p>
</td></tr>
<tr><td><code id="piecewiseRQA_+3A_mindiagline">mindiagline</code></td>
<td>
<p>A minimum diagonal length of
recurrent points. Usually set to 2, as it takes
a minimum of two points to define any line.</p>
</td></tr>
<tr><td><code id="piecewiseRQA_+3A_minvertline">minvertline</code></td>
<td>
<p>A minimum vertical length of
recurrent points.</p>
</td></tr>
<tr><td><code id="piecewiseRQA_+3A_tw">tw</code></td>
<td>
<p>The Theiler window parameter</p>
</td></tr>
<tr><td><code id="piecewiseRQA_+3A_whiteline">whiteline</code></td>
<td>
<p>A logical flag to calculate (TRUE)
or not (FALSE) empty vertical lines.</p>
</td></tr>
<tr><td><code id="piecewiseRQA_+3A_recpt">recpt</code></td>
<td>
<p>A logical flag indicating whether
measures of cross-recurrence are calculated directly
from a recurrent plot (TRUE) or not (FALSE).</p>
</td></tr>
<tr><td><code id="piecewiseRQA_+3A_side">side</code></td>
<td>
<p>A string indicating whether recurrence measures
should be calculated in the 'upper' triangle of the RP
'lower' triangle of the matrix, or 'both'.
LOC is automatically excluded for 'upper' and 'lower'.</p>
</td></tr>
<tr><td><code id="piecewiseRQA_+3A_method">method</code></td>
<td>
<p>A string to indicate the type of recurrence
analysis to peform. There are three options:
rqa (autorecurrence); crqa(cross-recurrence); 
mdcrqa(multidimensional recurrence). Default value is crqa</p>
</td></tr>
<tr><td><code id="piecewiseRQA_+3A_metric">metric</code></td>
<td>
<p>A string to indicate the type of 
distance metric used, default is euclidean but 
see help rdist() to list all other possible metrics.</p>
</td></tr> 
<tr><td><code id="piecewiseRQA_+3A_datatype">datatype</code></td>
<td>
<p>a string (continuous or categorical) 
to indicate whether the nature of the data type</p>
</td></tr>
<tr><td><code id="piecewiseRQA_+3A_typerqa">typeRQA</code></td>
<td>
<p>a string (full or diagonal) to indicate
whether piecewise recurrence quantification measures 
should be returned for full plot or for the diagonal profile</p>
</td></tr>  
<tr><td><code id="piecewiseRQA_+3A_windowsize">windowsize</code></td>
<td>
<p>the size of the window around the
diagonal of the recurrence (if typeRQA = diagonal)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is important to estimate the size of the block that 
may maximize the speed of the computation. 
We suggest to monitor how speed and memory usage
changes as a result of increasing the time-series and
the block size. 
We also recommend setting whiteline = FALSE, as the current
version of the library does not make use of such
information to extract measures of recurrence.
</p>


<h3>Value</h3>

<p>If an RP can be calculated and recurrence is found, 
the piecewiseRQA will return exactly the same measures 
as crqa() if the typeRQA is set to 'full' and 
drpdfromts() if the typeRQA is set to 'diagonal'.
Please refer to the help file for those two functions 
for details about the measures.
</p>
<table>
<tr><td><code>RP</code></td>
<td>
<p>The Recurrence Plot sparse matrix data</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Moreno I. Coco (moreno.cocoi@gmail.com) based 
on Matlab code by Sebastian Wallot</p>


<h3>See Also</h3>

<p><code><a href="#topic+crqa">crqa</a></code>, <code><a href="#topic+spdiags">spdiags</a></code>, <code><a href="#topic+simts">simts</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Uncomment and run locally

## generate some data using pracma

# ts1 = seq(0.1, 200, .1)
# ts1 = sin(ts1) + linspace(0, 1,length(ts1));

# ts2 = ts1

## initialize the parameters
# blockSize = 100; delay  = 15; embed  = 2; rescale = 0; radius = 0.5;
# normalize = 0; mindiagline = 2; minvertline = 2;
# tw = 1; whiteline = FALSE; recpt = FALSE; side = 'both'
# method = "crqa"; metric = 'euclidean'; datatype = "continuous"
# typeRQA = "full"; windowsize = NA

# pieceRP = piecewiseRQA(ts1, ts2, blockSize, delay, embed, rescale,
#                       radius, normalize, mindiagline, minvertline,
#                       tw, whiteline, recpt, side,
#                       method, metric, datatype, typeRQA, 
#                       windowsize)
                       
# print(unlist(pieceRP[1:10]))
                       
</code></pre>

<hr>
<h2 id='plotRP'>Plot a recurrence matrix</h2><span id='topic+plotRP'></span>

<h3>Description</h3>

<p>A convenience function to plot the RP matrix returned by
'crqa()'
</p>


<h3>Usage</h3>

<pre><code class='language-R'> plotRP(RP, labelx, labely, labelmain, 
                   cols, pcex, pch, unit, 
                   show_ticks) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotRP_+3A_rp">RP</code></td>
<td>
<p>A recurrence plot sparse matrix from 'crqa()'</p>
</td></tr>
<tr><td><code id="plotRP_+3A_labelx">labelx</code></td>
<td>
<p>The text label of the x-axis (character). Default: &quot;Time&quot;</p>
</td></tr>
<tr><td><code id="plotRP_+3A_labely">labely</code></td>
<td>
<p>The text label of the y-axis (character). Default: &quot;Time&quot;</p>
</td></tr>
<tr><td><code id="plotRP_+3A_labelmain">labelmain</code></td>
<td>
<p>Main title text of the plot (character). Default: &quot;Recurrence Plot&quot;</p>
</td></tr>
<tr><td><code id="plotRP_+3A_cols">cols</code></td>
<td>
<p>The color for the recurrent points (character). May include any colors from the base R plot repertoire. Default: &quot;black&quot;</p>
</td></tr>
<tr><td><code id="plotRP_+3A_pcex">pcex</code></td>
<td>
<p>The size of the recurrent points (numeric). Default: .3</p>
</td></tr>
<tr><td><code id="plotRP_+3A_pch">pch</code></td>
<td>
<p>The style of the recurrent points (numeric). Default: 1</p>
</td></tr>
<tr><td><code id="plotRP_+3A_unit">unit</code></td>
<td>
<p>Gap between sample labeling on axes (numeric). Note: only relevant if 'show_ticks = TRUE'. Default: 10</p>
</td></tr>
<tr><td><code id="plotRP_+3A_show_ticks">show_ticks</code></td>
<td>
<p>Whether to show x- and y-ticks or not (boolean). Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A square plot visualising the recurrence matrix, saved as a 'output_plot' object
</p>


<h3>Author(s)</h3>

<p>Moreno I. Coco <a href="mailto:moreno.cocoi@gmail.com">moreno.cocoi@gmail.com</a>
Alexandra Paxton <a href="mailto:alexandra.paxton@uconn.edu">alexandra.paxton@uconn.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## run a simple crqa
ts1 = c(0, 0, 1, 1, 0, 0, 2, 2, 1, 1)
ts2 = c(1, 1, 2, 2, 0, 0, 1, 2, 2, 1)
delay = 1; embed = 1; rescale = 1; radius = 0.001;
normalize = 0; mindiagline = 2; minvertline = 2;
tw = 0;

res = crqa(ts2, ts1, delay, embed, rescale, radius,  normalize, mindiagline,
minvertline, tw)

RP = res$RP
plotRP(RP, labelx = "Time", labely = "Time", show_ticks = TRUE, unit = 2,
       cols = "blue", pcex = 1)
</code></pre>

<hr>
<h2 id='simts'>Simulate dichotomous binary time-series</h2><span id='topic+simts'></span>

<h3>Description</h3>

<p>A simple algorithm for producing a time-series that drives
a second time-series (1 for event occurrence; 0 otherwise)
using parameters, which change independent and conditional
probability of an event to occur.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> simts(BL1, BL2, BLR1, BLR2, BL2C1, tsL) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simts_+3A_bl1">BL1</code></td>
<td>
<p>Base event rate of the first time-series</p>
</td></tr>
<tr><td><code id="simts_+3A_bl2">BL2</code></td>
<td>
<p>Base event rate of the second time-series</p>
</td></tr>
<tr><td><code id="simts_+3A_blr1">BLR1</code></td>
<td>
<p>Rate of repetition in the first series</p>
</td></tr>
<tr><td><code id="simts_+3A_blr2">BLR2</code></td>
<td>
<p>Rate of repetition in the second series</p>
</td></tr>
<tr><td><code id="simts_+3A_bl2c1">BL2C1</code></td>
<td>
<p>Conditional probability of repetition.</p>
</td></tr>
<tr><td><code id="simts_+3A_tsl">tsL</code></td>
<td>
<p>Length of the simulated time-series</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with two-rows, where the first row is
the 'driving' time-series and the second row
is the second time-series. The columns are
the number of simulated points as selected
by the argument <code>tsL</code>.
</p>


<h3>Author(s)</h3>

<p>Rick Dale and Moreno I. Coco
(moreno.cocoi@gmail.com)</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## set up parameters

BL1 = .08; BL2 = .05; BLR1 = .5; BLR2 = .5;
BL2C1 = .33; tsL = 100

ts = simts(BL1, BL2, BLR1, BLR2, BL2C1, tsL)

</code></pre>

<hr>
<h2 id='spdiags'>Extract diagonal matrices</h2><span id='topic+spdiags'></span>

<h3>Description</h3>

<p>Extracts all nonzero diagonals from the m-by-n matrix A.
B is a min(m,n)-by-p matrix whose columns are the
p nonzero diagonals of A.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> spdiags(A) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spdiags_+3A_a">A</code></td>
<td>
<p>An m-by-n matrix with nonzero elements located on p diagonals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compared to the original Matlab implementation:
1) it does not handle the case with more than one input,
and  2) (m &gt; n) matrices give the B matrix columns in a
different order, but the d vector of indices will also
be changed accordingly, so the set of columns is OK,
just ordered differently
</p>


<h3>Value</h3>

<table>
<tr><td><code>B</code></td>
<td>
<p>A min(m,n)-by-p matrix, usually (but not necessarily)
full, whose columns are the diagonals of A.</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>A vector of length p whose integer components
specify the diagonals in A.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For computational efficiency spdiags is actually
computed using a Fortan implementation (<code>jspd.f</code>) </p>


<h3>Author(s)</h3>

<p>John C. Nash (nashjc@uottawa.ca)</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dta &lt;- c(0, 5, 0, 10, 0, 0, 0, 0, 6, 0, 11, 0, 3, 0, 0,
7, 0, 12, 1, 4, 0, 0, 8, 0, 0, 2, 5, 0, 0, 9)

A1 &lt;- matrix(dta, nrow=5, ncol=6, byrow=TRUE)

print(A1)
res1 &lt;- spdiags(A1)
print(res1) 

</code></pre>

<hr>
<h2 id='text'>Categorical sequence of words</h2><span id='topic+text'></span>

<h3>Description</h3>

<p>A simple text of the nursery rhyme, \'the wheels on the bus\'   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text</code></pre>


<h3>Format</h3>

<p>A vector of 120 words</p>


<h3>References</h3>

<p>Verna Hills (1939). The Wheels on the bus. American Childhood (25), 56
</p>

<hr>
<h2 id='wincrqa'>Windowed Recurrence Measures</h2><span id='topic+wincrqa'></span>

<h3>Description</h3>

<p>A recurrence plot is computed in overlapping
windows of a certain size for a number of delays smaller
than the size of the window; and measures of it extracted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
wincrqa(ts1, ts2, windowstep, windowsize, delay, embed, 
radius, rescale, normalize, mindiagline, minvertline, tw, whiteline, 
recpt, side, method, metric, datatype, trend)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wincrqa_+3A_ts1">ts1</code></td>
<td>
<p>First time-series</p>
</td></tr>
<tr><td><code id="wincrqa_+3A_ts2">ts2</code></td>
<td>
<p>Second time-series</p>
</td></tr>
<tr><td><code id="wincrqa_+3A_windowstep">windowstep</code></td>
<td>
<p>Interval by which the window is moved.</p>
</td></tr>
<tr><td><code id="wincrqa_+3A_windowsize">windowsize</code></td>
<td>
<p>The size of the window</p>
</td></tr>  
<tr><td><code id="wincrqa_+3A_delay">delay</code></td>
<td>
<p>The delay unit by which the series are lagged.</p>
</td></tr>
<tr><td><code id="wincrqa_+3A_embed">embed</code></td>
<td>
<p>The number of embedding dimension for
phase-reconstruction, i.e., the lag intervals.</p>
</td></tr>
<tr><td><code id="wincrqa_+3A_radius">radius</code></td>
<td>
<p>A threshold, cut-off, constant used to
decide whether two points are recurrent or not.</p>
</td></tr>
<tr><td><code id="wincrqa_+3A_rescale">rescale</code></td>
<td>
<p>Rescale the distance matrix;
if rescale = 0 (do nothing);
if rescale = 1 (mean distance of entire matrix);
if rescale = 2 (maximum distance of entire matrix).
if rescale = 3 (minimum distance of entire matrix).
if rescale = 4 (euclidean distance of entire matrix).</p>
</td></tr>
<tr><td><code id="wincrqa_+3A_normalize">normalize</code></td>
<td>
<p>Normalize the time-series;
if normalize = 0 (do nothing);
if normalize = 1 (Unit interval);
if normalize =  2 (z-score).</p>
</td></tr>
<tr><td><code id="wincrqa_+3A_mindiagline">mindiagline</code></td>
<td>
<p>A minimum diagonal length of
recurrent points. Usually set to 2, as it takes
a minimum of two points to define any line.</p>
</td></tr>
<tr><td><code id="wincrqa_+3A_minvertline">minvertline</code></td>
<td>
<p>A minimum vertical length of
recurrent points.</p>
</td></tr>
<tr><td><code id="wincrqa_+3A_tw">tw</code></td>
<td>
<p>The Theiler window parameter</p>
</td></tr>
<tr><td><code id="wincrqa_+3A_whiteline">whiteline</code></td>
<td>
<p>A logical flag to calculate (TRUE)
or not (FALSE) empty vertical lines.</p>
</td></tr>
<tr><td><code id="wincrqa_+3A_recpt">recpt</code></td>
<td>
<p>A logical flag indicating whether
measures of cross-recurrence are calculated directly
from a recurrent plot (TRUE) or not (FALSE).</p>
</td></tr>
<tr><td><code id="wincrqa_+3A_side">side</code></td>
<td>
<p>A string indicating whether recurrence measures
should be calculated in the 'upper' triangle of the RP
'lower' triangle of the matrix, or 'both'.
LOC is automatically excluded for 'upper' and 'lower'.</p>
</td></tr>
<tr><td><code id="wincrqa_+3A_method">method</code></td>
<td>
<p>A string to indicate the type of recurrence
analysis to peform. There are three options:
rqa (autorecurrence); crqa(cross-recurrence); 
mdcrqa(multidimensional recurrence). Default value is crqa</p>
</td></tr>
<tr><td><code id="wincrqa_+3A_metric">metric</code></td>
<td>
<p>A string to indicate the type of 
distance metric used, default is euclidean but 
see help rdist() to list all other possible metrics.</p>
</td></tr> 
<tr><td><code id="wincrqa_+3A_datatype">datatype</code></td>
<td>
<p>a string (continuous or categorical) 
to indicate whether the nature of the data type</p>
</td></tr>
<tr><td><code id="wincrqa_+3A_trend">trend</code></td>
<td>
<p>a boolean (TRUE or FALSE) 
to indicate whether the TREND should be computed of the
system</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a matrix where the rows are the
different windows explored, and the columns
are the recurrence measures observed
in that particular window.
Refer to <code>crqa</code> for the values returned.
</p>


<h3>Note</h3>

<p>If no-recurrence is found in a window,
that window will not be saved, and a message
about it will be warned.
TREND is implemented following a solution proposed
by Norbert Marwan, and translated here in R,
for those who have asked him.
He, however, warns that this measure might strongly depend
on the chosen settings to calculate crq.
Relying blindly on such measure can, therefore, produce misleading results.
Also, we enabled the possibility to input directly a RP with recpt = T, 
and so extract the measures. This implies that it will not be the same 
as by conducting phase-space reconstruction on subsets of the time series.  
So, please, make sure why you are doing it and why.
</p>


<h3>Author(s)</h3>

<p>Moreno I. Coco (moreno.cocoi@gmail.com)
Alexandra Paxton <a href="mailto:alexandra.paxton@uconn.edu">alexandra.paxton@uconn.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+crqa">crqa</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(crqa) 

listener = eyemovement$listener[1:200]
narrator = eyemovement$narrator[1:200]

# NB, the parameters for windowsize and windowstep are large to allow
# faster running time, please set them carefully in your analysis. 

delay = 1; embed = 1; rescale = 0; radius = 0.001;
normalize = 0; mindiagline = 2; minvertline = 2;
tw = 0; whiteline = FALSE; recpt = FALSE; side = "both"
method = 'crqa'; metric = 'euclidean';  
datatype = "continuous"; 
windowsize =  100; windowstep = 50
trend = FALSE

ans = wincrqa(listener, narrator, windowstep, windowsize, delay, embed,
                    radius, rescale, normalize, mindiagline, minvertline,
                    tw, whiteline, recpt, side, method, metric, 
                    datatype, trend)

## other recurrence measures are available in ans
profile = as.numeric(ans$RR) 

plot(profile, type = 'l')

</code></pre>

<hr>
<h2 id='windowdrp'>Windowed Recurrence Profile</h2><span id='topic+windowdrp'></span>

<h3>Description</h3>

<p>A recurrence plot is computed in overlapping
windows of a specified size for a number of
delays smaller than the size of the window.
In every window, the recurrence value for the
different delays is calculated.
A mean is then taken across the delays to obtain
a recurrence value in that particular window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>windowdrp(ts1, ts2, windowstep, windowsize, lagwidth,
radius, delay, embed, rescale, normalize, mindiagline, minvertline,
tw, whiteline, recpt, side, method, metric, datatype)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="windowdrp_+3A_ts1">ts1</code></td>
<td>
<p>First time-series</p>
</td></tr>
<tr><td><code id="windowdrp_+3A_ts2">ts2</code></td>
<td>
<p>Second time-series</p>
</td></tr>
<tr><td><code id="windowdrp_+3A_windowstep">windowstep</code></td>
<td>
<p>Interval by which the window is
moved.</p>
</td></tr>
<tr><td><code id="windowdrp_+3A_windowsize">windowsize</code></td>
<td>
<p>The size of the window</p>
</td></tr>  
<tr><td><code id="windowdrp_+3A_lagwidth">lagwidth</code></td>
<td>
<p>The number of delays to be
considered within the window</p>
</td></tr>
<tr><td><code id="windowdrp_+3A_radius">radius</code></td>
<td>
<p>For numeric time-series, the
cutoff distance to accept or reject
two-points as recurrent</p>
</td></tr>
<tr><td><code id="windowdrp_+3A_delay">delay</code></td>
<td>
<p>The delay unit by which the series are lagged.</p>
</td></tr>
<tr><td><code id="windowdrp_+3A_embed">embed</code></td>
<td>
<p>The number of embedding dimension for
phase-reconstruction, i.e., the lag intervals.</p>
</td></tr>
<tr><td><code id="windowdrp_+3A_rescale">rescale</code></td>
<td>
<p>Rescale the distance matrix;
if rescale = 0 (do nothing);
if rescale = 1 (mean distance of entire matrix);
if rescale = 2 (maximum distance of entire matrix).
if rescale = 3 (minimum distance of entire matrix).
if rescale = 4 (euclidean distance of entire matrix).</p>
</td></tr>
<tr><td><code id="windowdrp_+3A_normalize">normalize</code></td>
<td>
<p>Normalize the time-series;
if normalize = 0 (do nothing);
if normalize = 1 (Unit interval);
if normalize =  2 (z-score).</p>
</td></tr>
<tr><td><code id="windowdrp_+3A_mindiagline">mindiagline</code></td>
<td>
<p>A minimum diagonal length of
recurrent points. Usually set to 2, as it takes
a minimum of two points to define any line.</p>
</td></tr>
<tr><td><code id="windowdrp_+3A_minvertline">minvertline</code></td>
<td>
<p>A minimum vertical length of
recurrent points.</p>
</td></tr>
<tr><td><code id="windowdrp_+3A_tw">tw</code></td>
<td>
<p>The Theiler window parameter</p>
</td></tr>
<tr><td><code id="windowdrp_+3A_whiteline">whiteline</code></td>
<td>
<p>A logical flag to calculate (TRUE)
or not (FALSE) empty vertical lines.</p>
</td></tr>
<tr><td><code id="windowdrp_+3A_recpt">recpt</code></td>
<td>
<p>A logical flag indicating whether
measures of cross-recurrence are calculated directly
from a recurrent plot (TRUE) or not (FALSE).</p>
</td></tr>
<tr><td><code id="windowdrp_+3A_side">side</code></td>
<td>
<p>A string indicating whether recurrence measures
should be calculated in the 'upper' triangle of the RP
'lower' triangle of the matrix, or 'both'.
LOC is automatically excluded for 'upper' and 'lower'.</p>
</td></tr>
<tr><td><code id="windowdrp_+3A_method">method</code></td>
<td>
<p>A string to indicate the type of recurrence
analysis to peform. There are three options:
rqa (autorecurrence); crqa(cross-recurrence); 
mdcrqa(multidimensional recurrence). Default value is crqa</p>
</td></tr>
<tr><td><code id="windowdrp_+3A_metric">metric</code></td>
<td>
<p>A string to indicate the type of 
distance metric used, default is euclidean but 
see help rdist() to list all other possible metrics.</p>
</td></tr> 
<tr><td><code id="windowdrp_+3A_datatype">datatype</code></td>
<td>
<p>a string (continuous or categorical) 
to indicate whether the nature of the data type</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a list of arguments where:
</p>
<table>
<tr><td><code>profile</code></td>
<td>
<p>Time-course windowed recurrence profile</p>
</td></tr>
<tr><td><code>maxrec</code></td>
<td>
<p>Maximal recurrence observed along the time-course</p>
</td></tr>
<tr><td><code>maxlag</code></td>
<td>
<p>The point where maximal recurrence is observed</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Moreno I. Coco (moreno.cocoi@gmail.com)
and Rick Dale (rdale@ucmerced.edu)</p>


<h3>References</h3>

<p>Boker, S. M., Rotondo, J. L., Xu, M., and King, K. (2002).
Windowed cross-correlation and peak picking
for the analysis of variability in the
association between behavioral time series.
Psychological Methods, 7(3), 338.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drpfromts">drpfromts</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# use the available data
data(crqa) 

listener = eyemovement$listener
narrator = eyemovement$narrator

# NB, the parameters for windowsize and windowstep are large to allow
# faster running time, please set them carefully in your analysis. 

delay = 1; embed = 1; rescale = 1; radius = 0.001;
normalize = 0; mindiagline = 2; minvertline = 2;
tw = 0; whiteline = FALSE; recpt = FALSE; side = "both"
method = 'crqa'; metric = 'euclidean';  
datatype = "continuous"; windowsize =  100; 
lagwidth = 10; windowstep = 200

ans = windowdrp(narrator, listener, windowstep, windowsize, lagwidth, 
                radius, delay, embed, rescale, normalize, 
                mindiagline, minvertline, tw, 
                whiteline, recpt, side, method, metric, 
                datatype)


profile = ans$profile; maxrec = ans$maxrec; maxlag = ans$maxlag

plot(profile, type = 'l')

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
