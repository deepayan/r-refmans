<!DOCTYPE html><html lang="en-US"><head><title>Help for package additive</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {additive}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#additive'><p>General Interface for Additive TidyModels</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Title:</td>
<td>Bindings for Additive TidyModels</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit Generalized Additive Models (GAM) using 'mgcv' with 'parsnip'/'tidymodels'
    via 'additive' &lt;<a href="https://doi.org/10.5281%2Fzenodo.4784245">doi:10.5281/zenodo.4784245</a>&gt;. 'tidymodels' is a collection of
    packages for machine learning; see Kuhn and Wickham (2020) <a href="https://www.tidymodels.org">https://www.tidymodels.org</a>).
    The technical details of 'mgcv' are described in Wood (2017)
    &lt;<a href="https://doi.org/10.1201%2F9781315370279">doi:10.1201/9781315370279</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://hsbadr.github.io/additive/">https://hsbadr.github.io/additive/</a>,
<a href="https://github.com/hsbadr/additive">https://github.com/hsbadr/additive</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/hsbadr/additive/issues">https://github.com/hsbadr/additive/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>mgcv (&ge; 1.9-1), parsnip (&ge; 1.2.1), R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, purrr, rlang, stats, tibble, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, devtools, knitr, recipes, rmarkdown, roxygen2,
spelling, testthat, workflows</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'additive_init.R' 'additive_load.R' 'additive_make.R'
'additive.R'</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-28 15:14:40 UTC; runner</td>
</tr>
<tr>
<td>Author:</td>
<td>Hamada S. Badr <a href="https://orcid.org/0000-0002-9808-2344"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hamada S. Badr &lt;badr@jhu.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-28 21:00:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='additive'>General Interface for Additive TidyModels</h2><span id='topic+additive'></span><span id='topic+update.additive'></span><span id='topic+additive_fit'></span>

<h3>Description</h3>

<p><code>additive()</code> is a way to generate a <em>specification</em> of a model
before fitting and allows the model to be created using
<span class="pkg">mgcv</span> package in <span class="pkg">R</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>additive(
  mode = "regression",
  engine = "mgcv",
  fitfunc = NULL,
  formula.override = NULL,
  family = NULL,
  method = NULL,
  optimizer = NULL,
  control = NULL,
  scale = NULL,
  gamma = NULL,
  knots = NULL,
  sp = NULL,
  min.sp = NULL,
  paraPen = NULL,
  chunk.size = NULL,
  rho = NULL,
  AR.start = NULL,
  H = NULL,
  G = NULL,
  offset = NULL,
  subset = NULL,
  start = NULL,
  etastart = NULL,
  mustart = NULL,
  drop.intercept = NULL,
  drop.unused.levels = NULL,
  cluster = NULL,
  nthreads = NULL,
  gc.level = NULL,
  use.chol = NULL,
  samfrac = NULL,
  coef = NULL,
  discrete = NULL,
  select = NULL,
  fit = NULL
)

## S3 method for class 'additive'
update(
  object,
  parameters = NULL,
  fitfunc = NULL,
  formula.override = NULL,
  family = NULL,
  method = NULL,
  optimizer = NULL,
  control = NULL,
  scale = NULL,
  gamma = NULL,
  knots = NULL,
  sp = NULL,
  min.sp = NULL,
  paraPen = NULL,
  chunk.size = NULL,
  rho = NULL,
  AR.start = NULL,
  H = NULL,
  G = NULL,
  offset = NULL,
  subset = NULL,
  start = NULL,
  etastart = NULL,
  mustart = NULL,
  drop.intercept = NULL,
  drop.unused.levels = NULL,
  cluster = NULL,
  nthreads = NULL,
  gc.level = NULL,
  use.chol = NULL,
  samfrac = NULL,
  coef = NULL,
  discrete = NULL,
  select = NULL,
  fit = NULL,
  fresh = FALSE,
  ...
)

additive_fit(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="additive_+3A_mode">mode</code></td>
<td>
<p>A single character string for the prediction outcome mode.
Possible values for this model are &quot;unknown&quot;, &quot;regression&quot;, or
&quot;classification&quot;.</p>
</td></tr>
<tr><td><code id="additive_+3A_engine">engine</code></td>
<td>
<p>A single character string specifying what computational
engine to use for fitting. Possible engines are listed below.
The default for this model is <code>"mgcv"</code>.</p>
</td></tr>
<tr><td><code id="additive_+3A_fitfunc">fitfunc</code></td>
<td>
<p>A named character vector that describes how to call
a function for fitting a generalized additive model. This defaults
to <code>c(pkg = "mgcv", fun = "gam")</code> (<code><a href="mgcv.html#topic+gam">gam</a></code>).
<code>fitfunc</code> should have elements <code>pkg</code> and <code>fun</code>.
The former is optional but is recommended and the latter is
required. For example, <code>c(pkg = "mgcv", fun = "bam")</code> would
be used to invoke <code><a href="mgcv.html#topic+bam">bam</a></code> for big data.
A user-specified function is also accepted provided that it is
fully compatible with <code><a href="mgcv.html#topic+gam">gam</a></code>.</p>
</td></tr>
<tr><td><code id="additive_+3A_formula.override">formula.override</code></td>
<td>
<p>Overrides the formula; for details see
<code><a href="mgcv.html#topic+formula.gam">formula.gam</a></code>.</p>
</td></tr>
<tr><td><code id="additive_+3A_family">family</code></td>
<td>

<p>This is a family object specifying the distribution and link to use in
fitting etc (see <code><a href="stats.html#topic+glm">glm</a></code> and <code><a href="stats.html#topic+family">family</a></code>). See 
<code><a href="mgcv.html#topic+family.mgcv">family.mgcv</a></code> for a full list of what is available, which goes well beyond exponential family.
Note that <code>quasi</code> families actually result in the use of extended quasi-likelihood 
if <code>method</code> is set to a RE/ML method (McCullagh and Nelder, 1989, 9.6).
</p>
</td></tr>
<tr><td><code id="additive_+3A_method">method</code></td>
<td>
<p>The smoothing parameter estimation method. <code>"GCV.Cp"</code> to use GCV for unknown scale parameter and
Mallows' Cp/UBRE/AIC for known scale. <code>"GACV.Cp"</code> is equivalent, but using GACV in place of GCV. <code>"NCV"</code>
for neighbourhood cross-validation using the neighbourhood structure speficied by <code>nei</code> (<code>"QNCV"</code> for numerically more ribust version).  <code>"REML"</code> 
for REML estimation, including of unknown scale, <code>"P-REML"</code> for REML estimation, but using a Pearson estimate 
of the scale. <code>"ML"</code> and <code>"P-ML"</code> are similar, but using maximum likelihood in place of REML. Beyond the 
exponential family <code>"REML"</code> is the default, and the only other options are <code>"ML"</code>, <code>"NCV"</code> or <code>"QNCV"</code>.</p>
</td></tr>
<tr><td><code id="additive_+3A_optimizer">optimizer</code></td>
<td>
<p>An array specifying the numerical optimization method to use to optimize the smoothing 
parameter estimation criterion (given by <code>method</code>). <code>"outer"</code> 
for the direct nested optimization approach. <code>"outer"</code> can use several alternative optimizers, specified in the 
second element of <code>optimizer</code>: <code>"newton"</code> (default), <code>"bfgs"</code>, <code>"optim"</code> or <code>"nlm"</code>. <code>"efs"</code>
for the extended Fellner Schall method of Wood and Fasiolo (2017).</p>
</td></tr>
<tr><td><code id="additive_+3A_control">control</code></td>
<td>
<p>A list of fit control parameters to replace defaults returned by 
<code><a href="mgcv.html#topic+gam.control">gam.control</a></code>. Values not set assume default values. </p>
</td></tr>
<tr><td><code id="additive_+3A_scale">scale</code></td>
<td>
<p> If this is positive then it is taken as the known scale parameter. Negative signals that the 
scale parameter is unknown. 0 signals that the scale parameter is 1  for Poisson and binomial and unknown otherwise. 
Note that (RE)ML methods can only work with scale parameter 1 for the Poisson and binomial cases.    
</p>
</td></tr>
<tr><td><code id="additive_+3A_gamma">gamma</code></td>
<td>
<p>Increase this beyond 1 to produce smoother models. <code>gamma</code> multiplies the effective degrees of freedom in the GCV or UBRE/AIC. <code>n/gamma</code> can be viewed as an effective sample size in the GCV score, and this also enables it to be used with REML/ML. Ignored with P-RE/ML or the <code>efs</code> optimizer. </p>
</td></tr>
<tr><td><code id="additive_+3A_knots">knots</code></td>
<td>
<p>this is an optional list containing user specified knot values to be used for basis construction. 
For most bases the user simply supplies the knots to be used, which must match up with the <code>k</code> value
supplied (note that the number of knots is not always just <code>k</code>). 
See <code><a href="mgcv.html#topic+tprs">tprs</a></code> for what happens in the <code>"tp"/"ts"</code> case. 
Different terms can use different numbers of knots, unless they share a covariate.
</p>
</td></tr>
<tr><td><code id="additive_+3A_sp">sp</code></td>
<td>
<p>A vector of smoothing parameters can be provided here.
Smoothing parameters must be supplied in the order that the smooth terms appear in the model 
formula. Negative elements indicate that the parameter should be estimated, and hence a mixture 
of fixed and estimated parameters is possible. If smooths share smoothing parameters then <code>length(sp)</code> 
must correspond to the number of underlying smoothing parameters.</p>
</td></tr>
<tr><td><code id="additive_+3A_min.sp">min.sp</code></td>
<td>
<p>Lower bounds can be supplied for the smoothing parameters. Note
that if this option is used then the smoothing parameters <code>full.sp</code>, in the 
returned object, will need to be added to what is supplied here to get the 
smoothing parameters actually multiplying the penalties. <code>length(min.sp)</code> should 
always be the same as the total number of penalties (so it may be longer than <code>sp</code>,
if smooths share smoothing parameters).</p>
</td></tr>
<tr><td><code id="additive_+3A_parapen">paraPen</code></td>
<td>
<p>optional list specifying any penalties to be applied to parametric model terms. 
<code><a href="mgcv.html#topic+gam.models">gam.models</a></code> explains more.</p>
</td></tr>
<tr><td><code id="additive_+3A_chunk.size">chunk.size</code></td>
<td>
<p>The model matrix is created in chunks of this size, rather than ever being formed whole. 
Reset to <code>4*p</code> if <code>chunk.size &lt; 4*p</code> where <code>p</code> is the number of coefficients.</p>
</td></tr>
<tr><td><code id="additive_+3A_rho">rho</code></td>
<td>
<p>An AR1 error model can be used for the residuals (based on dataframe order), of Gaussian-identity 
link models. This is the AR1 correlation parameter. Standardized residuals (approximately 
uncorrelated under correct model) returned in 
<code>std.rsd</code> if non zero. Also usable with other models when <code>discrete=TRUE</code>, in which case the AR model
is applied to the working residuals and corresponds to a GEE approximation.</p>
</td></tr>
<tr><td><code id="additive_+3A_ar.start">AR.start</code></td>
<td>
<p>logical variable of same length as data, <code>TRUE</code> at first observation of an independent
section of AR1 correlation. Very first observation in data frame does not need this. If <code>NULL</code> then 
there are no breaks in AR1 correlaion.</p>
</td></tr>
<tr><td><code id="additive_+3A_h">H</code></td>
<td>
<p>A user supplied fixed quadratic penalty on the parameters of the 
GAM can be supplied, with this as its coefficient matrix. A common use of this term is 
to add a ridge penalty to the parameters of the GAM in circumstances in which the model
is close to un-identifiable on the scale of the linear predictor, but perfectly well
defined on the response scale.</p>
</td></tr>
<tr><td><code id="additive_+3A_g">G</code></td>
<td>
<p>Usually <code>NULL</code>, but may contain the object returned by a previous call to <code>gam</code> with 
<code>fit=FALSE</code>, in which case all other arguments are ignored except for
<code>sp</code>, <code>gamma</code>, <code>in.out</code>, <code>scale</code>, <code>control</code>, <code>method</code> <code>optimizer</code> and <code>fit</code>.</p>
</td></tr>
<tr><td><code id="additive_+3A_offset">offset</code></td>
<td>
<p>Can be used to supply a model offset for use in fitting. Note
that this offset will always be completely ignored when predicting, unlike an offset 
included in <code>formula</code> (this used to conform to the behaviour of
<code>lm</code> and <code>glm</code>).</p>
</td></tr>
<tr><td><code id="additive_+3A_subset">subset</code></td>
<td>
<p> an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="additive_+3A_start">start</code></td>
<td>
<p>Initial values for the model coefficients.</p>
</td></tr>
<tr><td><code id="additive_+3A_etastart">etastart</code></td>
<td>
<p>Initial values for the linear predictor.</p>
</td></tr>
<tr><td><code id="additive_+3A_mustart">mustart</code></td>
<td>
<p>Initial values for the expected response.</p>
</td></tr>
<tr><td><code id="additive_+3A_drop.intercept">drop.intercept</code></td>
<td>
<p>Set to <code>TRUE</code> to force the model to really not have a constant in the parametric model part,
even with factor variables present. Can be vector when <code>formula</code> is a list.</p>
</td></tr>
<tr><td><code id="additive_+3A_drop.unused.levels">drop.unused.levels</code></td>
<td>
<p>by default unused levels are dropped from factors before fitting. For some smooths 
involving factor variables you might want to turn this off. Only do so if you know what you are doing.</p>
</td></tr>
<tr><td><code id="additive_+3A_cluster">cluster</code></td>
<td>
<p><code>bam</code> can compute the computationally dominant QR decomposition in parallel using <a href="parallel.html#topic+clusterApply">parLapply</a>
from the <code>parallel</code> package, if it is supplied with a cluster on which to do this (a cluster here can be some cores of a 
single machine). See details and example code. 
</p>
</td></tr>
<tr><td><code id="additive_+3A_nthreads">nthreads</code></td>
<td>
<p>Number of threads to use for non-cluster computation (e.g. combining results from cluster nodes).
If <code>NA</code> set to <code>max(1,length(cluster))</code>. See details.</p>
</td></tr>
<tr><td><code id="additive_+3A_gc.level">gc.level</code></td>
<td>
<p>to keep the memory footprint down, it can help to call the garbage collector often, but this takes 
a substatial amount of time. Setting this to zero means that garbage collection only happens when R decides it should. Setting to 2 gives frequent garbage collection. 1 is in between. Not as much of a problem as it used to be, but can really matter for very large datasets.
</p>
</td></tr>
<tr><td><code id="additive_+3A_use.chol">use.chol</code></td>
<td>
<p>By default <code>bam</code> uses a very stable QR update approach to obtaining the QR decomposition
of the model matrix. For well conditioned models an alternative accumulates the crossproduct of the model matrix
and then finds its Choleski decomposition, at the end. This is somewhat more efficient, computationally.</p>
</td></tr>
<tr><td><code id="additive_+3A_samfrac">samfrac</code></td>
<td>
<p>For very large sample size Generalized additive models the number of iterations needed for the model fit can 
be reduced by first fitting a model to a random sample of the data, and using the results to supply starting values. This initial fit is run with sloppy convergence tolerances, so is typically very low cost. <code>samfrac</code> is the sampling fraction to use. 0.1 is often reasonable. </p>
</td></tr>
<tr><td><code id="additive_+3A_coef">coef</code></td>
<td>
<p>initial values for model coefficients</p>
</td></tr>
<tr><td><code id="additive_+3A_discrete">discrete</code></td>
<td>
<p>experimental option for setting up models for use with discrete methods employed in <code><a href="mgcv.html#topic+bam">bam</a></code>. Do not modify.</p>
</td></tr>
<tr><td><code id="additive_+3A_select">select</code></td>
<td>
<p> If this is <code>TRUE</code> then <code>gam</code> can add an extra penalty to each term so 
that it can be penalized to zero.  This means that the smoothing parameter estimation that is 
part of fitting can completely remove terms from the model. If the corresponding 
smoothing parameter is estimated as zero then the extra penalty has no effect. Use <code>gamma</code> to increase level of penalization.
</p>
</td></tr>
<tr><td><code id="additive_+3A_fit">fit</code></td>
<td>
<p>If this argument is <code>TRUE</code> then <code>gam</code> sets up the model and fits it, but if it is
<code>FALSE</code> then the model is set up and an object <code>G</code> containing what
would be required to fit is returned is returned. See argument <code>G</code>.</p>
</td></tr>
<tr><td><code id="additive_+3A_object">object</code></td>
<td>
<p>A Generalized Additive Model (GAM) specification.</p>
</td></tr>
<tr><td><code id="additive_+3A_parameters">parameters</code></td>
<td>
<p>A 1-row tibble or named list with <em>main</em>
parameters to update. If the individual arguments are used,
these will supersede the values in <code>parameters</code>. Also, using
engine arguments in this object will result in an error.</p>
</td></tr>
<tr><td><code id="additive_+3A_fresh">fresh</code></td>
<td>
<p>A logical for whether the arguments should be
modified in-place of or replaced wholesale.</p>
</td></tr>
<tr><td><code id="additive_+3A_...">...</code></td>
<td>
<p>Other arguments passed to internal functions.</p>
</td></tr>
<tr><td><code id="additive_+3A_formula">formula</code></td>
<td>
<p> A GAM formula, or a list of formulae (see <code><a href="mgcv.html#topic+formula.gam">formula.gam</a></code> and also <code><a href="mgcv.html#topic+gam.models">gam.models</a></code>). 
These are exactly like the formula for a GLM except that smooth terms, <code><a href="mgcv.html#topic+s">s</a></code>, <code><a href="mgcv.html#topic+te">te</a></code>, <code><a href="mgcv.html#topic+ti">ti</a></code> 
and <code><a href="mgcv.html#topic+t2">t2</a></code>, can be added to the right hand side to specify that the linear predictor depends on smooth functions of predictors (or linear functionals of these).
</p>
</td></tr>
<tr><td><code id="additive_+3A_data">data</code></td>
<td>
<p> A data frame or list containing the model response variable and 
covariates required by the formula. By default the variables are taken 
from <code>environment(formula)</code>: typically the environment from 
which <code>gam</code> is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments are converted to their specific names at the
time that the model is fit. Other options and argument can be
set using <code>set_engine()</code>. If left to their defaults
here (<code>NULL</code>), the values are taken from the underlying model
functions. If parameters need to be modified, <code>update()</code> can be
used in lieu of recreating the object from scratch.
</p>
<p>The data given to the function are not saved and are only used
to determine the <em>mode</em> of the model. For <code>additive()</code>, the
possible modes are &quot;regression&quot; and &quot;classification&quot;.
</p>
<p>The model can be created by the <code>fit()</code> function using the
following <em>engines</em>:
</p>

<ul>
<li> <p><span class="pkg">mgcv</span>:  <code>"mgcv"</code>
</p>
</li></ul>



<h3>Value</h3>

<p>An updated model specification.
</p>


<h3>Engine Details</h3>

<p>Engines may have pre-set default arguments when executing the model fit
call. For this type of model, the template of the fit calls are:
</p>
<div class="sourceCode r"><pre>additive() |&gt;
  set_engine("mgcv") |&gt;
  translate()
</pre></div>
<div class="sourceCode"><pre>## Generalized Additive Model (GAM) Specification (regression)
## 
## Computational engine: mgcv 
## 
## Model fit template:
## additive::additive_fit(formula = missing_arg(), data = missing_arg(), 
##     weights = missing_arg())
</pre></div>


<h3>See Also</h3>

<p><code><a href="mgcv.html#topic+mgcv-package">mgcv-package</a></code>,
<code><a href="mgcv.html#topic+gam">gam</a></code>,
<code><a href="mgcv.html#topic+bam">bam</a></code>,
<code><a href="mgcv.html#topic+gamObject">gamObject</a></code>,
<code><a href="mgcv.html#topic+gam.models">gam.models</a></code>,
<code><a href="mgcv.html#topic+smooth.terms">smooth.terms</a></code>,
<code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code>,
<code><a href="mgcv.html#topic+plot.gam">plot.gam</a></code>,
<code><a href="mgcv.html#topic+summary.gam">summary.gam</a></code>,
<code><a href="mgcv.html#topic+gam.side">gam.side</a></code>,
<code><a href="mgcv.html#topic+gam.selection">gam.selection</a></code>,
<code><a href="mgcv.html#topic+gam.control">gam.control</a></code>,
<code><a href="mgcv.html#topic+gam.check">gam.check</a></code>,
<code><a href="mgcv.html#topic+vis.gam">vis.gam</a></code>,
<code><a href="mgcv.html#topic+family.mgcv">family.mgcv</a></code>,
<code><a href="mgcv.html#topic+formula.gam">formula.gam</a></code>,
<code><a href="stats.html#topic+family">family</a></code>,
<code><a href="stats.html#topic+formula">formula</a></code>,
<code><a href="stats.html#topic+update.formula">update.formula</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
additive()

show_model_info("additive")

additive(mode = "classification")
additive(mode = "regression")

set.seed(2020)
dat &lt;- gamSim(1, n = 400, dist = "normal", scale = 2)

additive_mod &lt;-
  additive() |&gt;
  set_engine("mgcv") |&gt;
  fit(
    y ~ s(x0) + s(x1) + s(x2) + s(x3),
    data = dat
  )

summary(additive_mod$fit)

model &lt;- additive(select = FALSE)
model
update(model, select = TRUE)
update(model, select = TRUE, fresh = TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
