<!DOCTYPE html><html><head><title>Help for package DELTD</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DELTD}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Beta'><p>Estimate Density Values by Beta kernel</p></a></li>
<li><a href='#BS'><p>Estimate Density Values by Birnbaum-Saunders kernel</p></a></li>
<li><a href='#DELTD-package'><p>DELTD</p></a></li>
<li><a href='#Erlang'><p>Estimate Density Values by Erlang kernel</p></a></li>
<li><a href='#Gamma'><p>Estimate Density Values by Gamma kernel</p></a></li>
<li><a href='#LogN'><p>Estimate Density Values by Lognormal kernel</p></a></li>
<li><a href='#mse'><p>Calculate Mean Squared Error( MSE) by using different Kernels</p></a></li>
<li><a href='#plot.Beta'><p>Density Plot by Beta kernel</p></a></li>
<li><a href='#plot.BS'><p>Density Plot by Birnbaum-Saunders kernel</p></a></li>
<li><a href='#plot.Erlang'><p>Density Plot by Erlang kernel</p></a></li>
<li><a href='#plot.Gamma'><p>Density Plot by Gamma kernel</p></a></li>
<li><a href='#plot.LogN'><p>Density Plot by Lognormal kernel</p></a></li>
<li><a href='#TUNA'><p>Data of Tuna fish</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Kernel Density Estimation using Lifetime Distributions</td>
</tr>
<tr>
<td>Version:</td>
<td>2.6.8</td>
</tr>
<tr>
<td>Author:</td>
<td>Javaria Ahmad Khan, Atif Akbar.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Javaria Ahmad Khan &lt;jakhan0@yahoo.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of asymmetrical kernels belong to lifetime distributions for kernel density estimation is presented. 
    Mean Squared Errors (MSE) are calculated for estimated curves. For this purpose, R functions allow the distribution to be Gamma, Exponential or Weibull.
    For details see Chen (2000a,b), Jin and Kawczak (2003) and Salha et al. (2014) &lt;<a href="https://doi.org/10.12988%2Fpms.2014.4616">doi:10.12988/pms.2014.4616</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://CRAN.R-project.org/package=DELTD">https://CRAN.R-project.org/package=DELTD</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-20 14:28:28 UTC; Javaria Ahamd Khan</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-20 14:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Beta'>Estimate Density Values by Beta kernel</h2><span id='topic+Beta'></span>

<h3>Description</h3>

<p>This function provide the estimated Kernel density values by using Beta Kernel. The Beta kernel is developed by Chen (2000) by using Beta distribution of first kind. He was first to introduce asymetrical kernels to control boundary Bias.
Beta Kernel is
</p>
<p style="text-align: center;"><code class="reqn">K_{Beta( \frac{x}{h}+1, \frac{1-x}{h}+1)}(y)=\frac{y^ \frac{x}{h} (1-y)^{\frac{1-x}{b}}} { B \{ \frac{x}{h}+1, \frac{(1-x)}{h}+1 \}}</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>Beta(x = NULL, y, k = NULL, h = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Beta_+3A_x">x</code></td>
<td>
<p>scheme for generating grid points</p>
</td></tr>
<tr><td><code id="Beta_+3A_y">y</code></td>
<td>
<p>a numeric vector of positive values</p>
</td></tr>
<tr><td><code id="Beta_+3A_k">k</code></td>
<td>
<p>number of gird points</p>
</td></tr>
<tr><td><code id="Beta_+3A_h">h</code></td>
<td>
<p>the bandwidth</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this function, choice of bandwidth, number of grid points and scheme that how these grid points are generated are user based. If any parameter(s) is missing then function used default parameters.
But at least <code>x</code> or <code>k</code> should be specified otherwise <code>NA</code> will be produced. If <code>x</code> is missing then function will generate <code>k</code> grid points by using uniform distribution. Similarly, if
<code>k</code> is missing then function consider it same to length of main vector. In case if <code>h</code> is missing then function used normal scale rule bandwidth for non-normal data and described in Silverman (1986). This function can be only used if
data is between (0, 1). Similarly, <code>x</code> should be also lies between (0, 1).
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>grid points</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>estimated values of density</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Javaria Ahmad Khan, Atif Akbar.
</p>


<h3>References</h3>

<p>Chen, S. X. 2000. Beta kernel smothers for regression curves. <em>Statistica Sinica</em> <strong>10</strong>, 73-91.
Silverman, B. W. 1986. <em>Density Estimation</em>. Chapman &amp; Hall/ CRC, London.
</p>


<h3>See Also</h3>

<p>For further kernels see <code><a href="#topic+Erlang">Erlang</a></code>, <code><a href="#topic+BS">BS</a></code>, <code><a href="#topic+Gamma">Gamma</a></code>and <code><a href="#topic+LogN">LogN</a></code>. To plot its density see <code><a href="#topic+plot.Beta">plot.Beta</a></code> and to calculate MSE <code><a href="#topic+mse">mse</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data: Simulated or real data can be used
## Number of grid points "k" should be at least equal to the data size.
## If user defines the generating scheme of grid points then length
## of grid points should be equal or greater than "k", Otherwise NA will be produced.
y &lt;- runif(50)
xx &lt;- sample(0.00001:900, 500, replace = FALSE)/1000
h &lt;- 0.9
Beta(x = xx, y = y, k = 500, h = h)

## If scheme for generating grid points is unknown
y &lt;- runif(500)
h &lt;- 0.9
Beta(x = xx, y = y, k = 500, h = h)

## Not run: 
## If user do not mention the number of grid points
y &lt;- runif(1000)
xx &lt;- seq(0.001, 1000, length = 2000)

## any bandwidth can be used
require(kedd)
h &lt;- h.bcv(y) ## Biased cross validation
Beta(x = xx, y = y, h = h)

## End(Not run)

## Not run: 
##if both generating scheme and number of grid points are missing then function generate NA
y &lt;- runif(1000)
band = 0.8
Beta(y = y, h = band)

## End(Not run)

## if bandwidth is missing
y &lt;- runif(100)
xx &lt;- seq(0.001, 100, length = 300)
Beta(x = xx, y = y, k = 200)

</code></pre>

<hr>
<h2 id='BS'>Estimate Density Values by Birnbaum-Saunders kernel</h2><span id='topic+BS'></span>

<h3>Description</h3>

<p>This function calculates the estimated Values by using Birnbaum-Saunders Kernel. The Birnbaum-Saunders kernel is developed by Jin and Kawczak (2003). They claimed that performance of their developed kernel is better near the
boundary points in terms of boundary reduction.
</p>
<p style="text-align: center;"><code class="reqn">K_{BS(h^\frac{1}{2},x)} (y)=\frac{1}{2\sqrt 2 \pi h} \left(\sqrt \frac{1}{xy} +\sqrt\frac{x}{y^3}\right)exp\left(-\frac{1}{2h}\left(\frac{y}{x}-2+\frac{x}{y}\right)\right)</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>BS(x = NULL, y, k = NULL, h = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BS_+3A_x">x</code></td>
<td>
<p>scheme for generating grid points</p>
</td></tr>
<tr><td><code id="BS_+3A_y">y</code></td>
<td>
<p>a numeric vector of positive values.</p>
</td></tr>
<tr><td><code id="BS_+3A_k">k</code></td>
<td>
<p>gird points</p>
</td></tr>
<tr><td><code id="BS_+3A_h">h</code></td>
<td>
<p>the bandwidth</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this function, choice of bandwidth, number of grid points and scheme that how these grid points are generated are user based. If any parameter(s) is missing then function used default parameters.
But at least <code>x</code> or <code>k</code> should be specified otherwise <code>NA</code> will be produced. If <code>x</code> is missing then function will generate <code>k</code> grid points between minimum and maximum values of vector. Similarly, if
<code>k</code> is missing then function consider it same to length of main vector. In case if <code>h</code> is missing then function used normal scale rule bandwidth for non-normal data and described in Silverman (1986).
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>grid points</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>estimated values of density</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Javaria Ahmad Khan, Atif Akbar.
</p>


<h3>References</h3>

<p>Jin, X.; Kawczak, J. 2003. Birnbaum-Saunders &amp; Lognormal kernel estimators for modeling durations in high frequency financial data. <em>Annals of Economics and Finance</em> <strong>4</strong>, 103-124.
</p>


<h3>See Also</h3>

<p>For further kernels see <code><a href="#topic+Erlang">Erlang</a></code>, <code><a href="#topic+Gamma">Gamma</a></code> and <code><a href="#topic+LogN">LogN</a></code>. To plot the density by using BS kernel <code><a href="#topic+plot.BS">plot.BS</a></code> and to calculate MSE by <code><a href="#topic+mse">mse</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data: Simulated or real data can be used
## Number of grid points "k" should be at least equal to the data size.
## If user defines the generating scheme of grid points then length
## of grid points should be equal or greater than "k", Otherwise NA will be produced.
alpha = 10
theta = 15 / 60

y &lt;- rgamma(n = 1000, shape = alpha, scale = theta)
xx &lt;- seq(min(y) + 0.05, max(y), length =200)
h &lt;- 1.1
den &lt;- BS(x = xx, y = y, k = 200, h = h)

##If scheme for generating grid points is unknown
y &lt;- rgamma(n = 1000, shape = alpha, scale = theta)
h &lt;- 3
BS(y = y, k = 90, h = h)

## Not run: 
##If user do not mention the number of grid points
y &lt;- rgamma(n = 1000, shape = alpha, scale = theta)
xx &lt;- seq(0.001, 1000, length = 1000)

#any bandwidth can be used
require(KernSmooth)
h &lt;- dpik(y)     #Direct Plug-In Bandwidth
BS(x = xx, y = y, h = h)

## End(Not run)

## Not run: 
#if both generating scheme and number of grid points are missing then function generate NA
y &lt;- rgamma(n = 1000, shape = alpha, scale = theta)
band = 3
BS(y = y, h = band)

## End(Not run)

#if bandwidth is missing
y &lt;- rgamma(n = 1000, shape = alpha, scale = theta)
xx &lt;- seq(0.001, 100, length = 1000)
BS(x = xx, y = y, k = 900)
</code></pre>

<hr>
<h2 id='DELTD-package'>DELTD</h2><span id='topic+DELTD'></span><span id='topic+DELTD-package'></span>

<h3>Description</h3>

<p>A collection of asymmetrical kernels belong to lifetime distributions for kernel density estimation is presented. i.e. <code><a href="#topic+plot.BS">plot.BS</a></code>, <code><a href="#topic+plot.Beta">plot.Beta</a></code>, <code><a href="#topic+plot.Erlang">plot.Erlang</a></code>,
<code><a href="#topic+plot.Gamma">plot.Gamma</a></code> and <code><a href="#topic+plot.LogN">plot.LogN</a></code>. Estimated values can also observed by using
<code><a href="#topic+Beta">Beta</a></code>, <code><a href="#topic+BS">BS</a></code>, <code><a href="#topic+Gamma">Gamma</a></code>, <code><a href="#topic+Erlang">Erlang</a></code> and <code><a href="#topic+LogN">LogN</a></code>. For calculating mean squared error by using different kernels functions are <code><a href="#topic+mse">mse</a></code> can be used.
</p>
<p>A collection of asymmetrical kernels belong to lifetime distributions for kernel density estimation is presented. i.e. <code><a href="#topic+plot.BS">plot.BS</a></code>, <code><a href="#topic+plot.Erlang">plot.Erlang</a></code>,
<code><a href="#topic+plot.Gamma">plot.Gamma</a></code> and <code><a href="#topic+plot.LogN">plot.LogN</a></code>. Estimated values can also observed by using
<code><a href="#topic+BS">BS</a></code>, <code><a href="#topic+Gamma">Gamma</a></code>, <code><a href="#topic+Erlang">Erlang</a></code> and <code><a href="#topic+LogN">LogN</a></code>, where data can belong to any distribution. For calculating mean squared error by using different kernel functions  <code><a href="#topic+mse">mse</a></code> .
</p>


<h3>Details</h3>

<p>Kernel Density Estimation using Lifetime Distributions
</p>
<p>Kernel Density Estimation using Lifetime Distributions
</p>


<h3>Author(s)</h3>

<p>Javaria Ahmad Khan, Atif Akbar.
</p>
<p>Javaria Ahmad Khan, Atif Akbar.
</p>


<h3>References</h3>


<ul>
<li><p> Jin, X.; Kawczak, J. 2003. Birnbaum-Saunders &amp; Lognormal kernel estimators for modeling durations in high frequency financial data. <em>Annals of Economics and Finance</em> <strong>4</strong>, 103–124.
</p>
</li>
<li><p> Salha, R. B.; Ahmed, E. S.; Alhoubi, I. M. 2014. Hazard rate function estimation using Erlang Kernel. <em>Pure Mathematical Sciences</em> <strong>3</strong> (4), 141–152.
</p>
</li>
<li><p> Chen, S. X. 2000. Probability density function estimation using Gamma kernels. <em>Annals of the Institute of Statistical Mathematics</em> <strong>52</strong> (3), 471-480.
</p>
</li>
<li><p> Chen, S. X. 2000. Beta kernel smothers for regression curves. <em>Statistica Sinica</em> <strong>10</strong>, 73-91.
</p>
</li>
<li><p> Buckland, S. T.; Burnham, K. P.; Anderson, D. R.; Laake, J. L. 1993. <em>Density Estimation using Distance Sampling</em>. Chapman &amp; Hall, London.
</p>
</li></ul>


<ul>
<li><p> Jin, X.; Kawczak, J. 2003. Birnbaum-Saunders &amp; Lognormal kernel estimators for modeling durations in high frequency financial data. <em>Annals of Economics and Finance</em> <strong>4</strong>, 103-124.
</p>
</li>
<li><p> Salha, R. B.; Ahmed, E. S.; Alhoubi, I. M. 2014. Hazard rate function estimation using Erlang Kernel. <em>Pure Mathematical Sciences</em> <strong>3</strong> (4), 141-152.
</p>
</li>
<li><p> Chen, S. X. 2000. Probability density function estimation using Gamma kernels. <em>Annals of the Institute of Statistical Mathematics</em> <strong>52</strong> (3), 471-480.
</p>
</li>
<li><p> Chen, S. X. 2000.Beta kernel smoothers for regression curves. <em>Statistica Sinica</em> <strong>10</strong>, 73-91.
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://CRAN.R-project.org/package=DELTD">https://CRAN.R-project.org/package=DELTD</a>
</p>
</li></ul>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://CRAN.R-project.org/package=DELTD">https://CRAN.R-project.org/package=DELTD</a>
</p>
</li></ul>


<hr>
<h2 id='Erlang'>Estimate Density Values by Erlang kernel</h2><span id='topic+Erlang'></span>

<h3>Description</h3>

<p>This function provide the estimated values for density by using Erlang Kernel. Erlang kernel is developed by Salha et al. (2014). They developed this asymmetrical kernal with its hazard function and also
proved its asymtotic normality.
</p>
<p style="text-align: center;"><code class="reqn">K_{E(x,\frac{1}{h})}  (y)=\frac{1}{\Gamma (1+\frac{1}{h})} \left[\frac{1}{x} (1+\frac{1}{h}) \right]^\frac{h+1}{h} y^\frac{1}{h} exp\left(-\frac{y}{x} (1+\frac{1}{h}) \right)</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>Erlang(x = NULL, y, k = NULL, h = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Erlang_+3A_x">x</code></td>
<td>
<p>scheme for generating grid points</p>
</td></tr>
<tr><td><code id="Erlang_+3A_y">y</code></td>
<td>
<p>a numeric vector of positive values.</p>
</td></tr>
<tr><td><code id="Erlang_+3A_k">k</code></td>
<td>
<p>gird points.</p>
</td></tr>
<tr><td><code id="Erlang_+3A_h">h</code></td>
<td>
<p>the bandwidth</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see the details in the <code><a href="#topic+BS">BS</a></code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>grid points</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>estimated values of density</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Javaria Ahmad Khan, Atif Akbar.
</p>


<h3>References</h3>

<p>Salha, R. B.; Ahmed, E. S.; Alhoubi, I. M. 2014. Hazard rate function estimation using Erlang Kernel. <em>Pure Mathematical Sciences</em> <strong>3</strong> (4), 141-152.
</p>


<h3>See Also</h3>

<p>For further MSE by using other kernels see <code><a href="#topic+Beta">Beta</a></code>, <code><a href="#topic+BS">BS</a></code>, <code><a href="#topic+Gamma">Gamma</a></code> and <code><a href="#topic+LogN">LogN</a></code>. For plotting these estimated values <code><a href="#topic+plot.Erlang">plot.Erlang</a></code> and for calculating MSE use <code><a href="#topic+mse">mse</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data: Simulated or real data can be used
## Number of grid points "k" should be at least equal to the data size.
## If user defines the generating scheme of grid points then length
## of grid points should be equal or greater than "k", Otherwise NA will be produced.
y &lt;- rlnorm(100, meanlog = 0, sdlog = 1)
xx &lt;- seq(min(y) + 0.05, max(y), length = 500)
h &lt;-2
den &lt;- Erlang(x = xx, y = y, k = 200, h = h)

##If scheme for generating grid points is unknown
y &lt;- rlnorm(1000, meanlog = 0, sdlog = 1)
h &lt;- 3
Erlang(y = y, k = 90, h = h)

## Not run: 
##If user do not mention the number of grid points
 y &lt;- rlnorm(100, meanlog = 0, sdlog = 1)
xx &lt;- seq(0.001, 1000, length = 1000)

#any bandwidth can be used
require(kedd)
h &lt;- h.ucv(y)     #Unbaised cross validation bandwidth
Erlang(x = xx, y = y, h = h)

## End(Not run)

## Not run: 
#if generating scheme and number of grid points are missing then function generate NA
y &lt;- rlnorm(100, meanlog = 0, sdlog = 1)
band = 3
Erlang(y = y, h = band)

## End(Not run)

#if bandwidth is missing
 y &lt;- rlnorm(100, meanlog = 0, sdlog = 1)
xx &lt;- seq(0.001, 100, length = 100)
Erlang(x = xx, y = y, k = 90)
</code></pre>

<hr>
<h2 id='Gamma'>Estimate Density Values by Gamma kernel</h2><span id='topic+Gamma'></span>

<h3>Description</h3>

<p>This function provide the estimated Kernel density values by using Gamma Kernel.The Gamma kernel is developed by Chen (2000). He was first to introduce asymetrical kernels to control boundary Bias.
Gamma Kernel is
</p>
<p style="text-align: center;"><code class="reqn">K_{Gam1( \frac{x}{h}+1, h)}(y) = \frac{y^ \frac{x}{h} exp(-\frac{y}{h})}{ \Gamma (\frac{x}{h}+1)h^{ \frac{x}{h}+1}}</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>Gamma(x = NULL, y, k = NULL, h = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gamma_+3A_x">x</code></td>
<td>
<p>scheme for generating grid points</p>
</td></tr>
<tr><td><code id="Gamma_+3A_y">y</code></td>
<td>
<p>a numeric vector of positive values</p>
</td></tr>
<tr><td><code id="Gamma_+3A_k">k</code></td>
<td>
<p>number of gird points</p>
</td></tr>
<tr><td><code id="Gamma_+3A_h">h</code></td>
<td>
<p>the bandwidth</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see the details in the <code><a href="#topic+BS">BS</a></code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>grid points</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>estimated values of density</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Javaria Ahmad Khan, Atif Akbar.
</p>


<h3>References</h3>

<p>Chen, S. X. 2000. Probability density function estimation using Gamma kernels.  <em>Annals of the Institute of Statistical Mathematics</em> <strong>52</strong> (3), 471-480.
Silverman, B. W. 1986. <em>Density Estimation</em>. Chapman &amp; Hall/ CRC, London.
</p>


<h3>See Also</h3>

<p>For further kernels see <code><a href="#topic+Erlang">Erlang</a></code>, <code><a href="#topic+BS">BS</a></code>, <code><a href="#topic+Beta">Beta</a></code>and <code><a href="#topic+LogN">LogN</a></code>. To plot its density see <code><a href="#topic+plot.Gamma">plot.Gamma</a></code> and to calculate MSE <code><a href="#topic+mse">mse</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Number of grid points "k" should be at least equal to the data size.
###If user defines the generating scheme of grid points then length
####of grid points should be equal or greater than "k". Otherwise NA will be produced.
y &lt;- rexp(100, 1)
xx &lt;- seq(min(y) + 0.05, max(y), length = 500)
h &lt;- 2
den &lt;- Gamma(x = xx, y = y, k = 200, h = h)

##If scheme for generating grid points is unknown
y &lt;- rexp(200, 1)
h &lt;- 3
Gamma(y = y, k = 90, h = h)

## Not run: 
y &lt;- data(TUNA)
xx &lt;- seq(min(y) + 0.05, max(y), length = 500)
h &lt;- 2
den &lt;- Gamma(x = xx, y = y, k = 200, h = h)

## End(Not run)

## Not run: 
##If user do not mention the number of grid points
y &lt;- rexp(1000, 1)
xx &lt;- seq(0.001, 1000, length = 1000)

#any bandwidth can be used
require(KernSmooth)
h &lt;- dpik(y)
Gamma(x = xx, y = y, h = h)

## End(Not run)

## Not run: 
#if generating scheme and number of grid points are missing then function generate NA
y &lt;- rexp(1000, 1)
band = 3
Gamma(y = y, h = band)

## End(Not run)

#if bandwidth is missing
y &lt;- rexp(100,1)
xx &lt;- seq(0.001, max(y), length = 100)
Gamma(x = xx, y = y, k = 90)

</code></pre>

<hr>
<h2 id='LogN'>Estimate Density Values by Lognormal kernel</h2><span id='topic+LogN'></span>

<h3>Description</h3>

<p>The <code>LogN</code> estimate Values of density by using Lognormal Kernel.The Lognomal kernel is developed by Jin and Kawczak (2003). For this too, they claimed that performance of their developed kernel is better near the
boundary points in terms of boundary reduction.
Lognormal Kernel is
</p>
<p style="text-align: center;"><code class="reqn">K_{LN(\ln(x),4\ln(1+h))}=\frac{1}{\sqrt{( 8\pi \ln(1+h))} y)} exp\left[-\frac{(\ln(y)-\ln(x))^2}{(8\ln(1+h))}\right]</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>LogN(x = NULL, y, k = NULL, h = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LogN_+3A_x">x</code></td>
<td>
<p>scheme for generating grid points</p>
</td></tr>
<tr><td><code id="LogN_+3A_y">y</code></td>
<td>
<p>a numeric vector of positive values.</p>
</td></tr>
<tr><td><code id="LogN_+3A_k">k</code></td>
<td>
<p>gird points.</p>
</td></tr>
<tr><td><code id="LogN_+3A_h">h</code></td>
<td>
<p>the bandwidth</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see the details in the <code><a href="#topic+BS">BS</a></code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>grid points</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>estimated values of density</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Javaria Ahmad Khan, Atif Akbar.
</p>


<h3>References</h3>

<p>Jin, X.; Kawczak, J. 2003. Birnbaum-Saunders &amp; Lognormal kernel estimators for modeling durations in high frequency financial data. <em>Annals of Economics and Finance</em> <strong>4</strong>, 103-124.
</p>


<h3>See Also</h3>

<p>For further kernels see <code><a href="#topic+Beta">Beta</a></code>, <code><a href="#topic+Erlang">Erlang</a></code>, <code><a href="#topic+Gamma">Gamma</a></code> and <code><a href="#topic+BS">BS</a></code>. To plot its density see <code><a href="#topic+plot.LogN">plot.LogN</a></code> and to calculate MSE use <code><a href="#topic+mse">mse</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data: Simulated or real data can be used
## Number of grid points "k" should be at least equal to the data size.
## If user defines the generating scheme of grid points then length
## of grid points should be equal or greater than "k", Otherwise NA will be produced.
y &lt;- rweibull(350, 1)
xx &lt;- seq(0.001, max(y), length = 500)
h &lt;- 2
den &lt;- LogN(x = xx, y = y, k = 200, h = h)

##If scheme for generating grid points is unknown
n &lt;- 1000
y &lt;- abs(rlogis(n, location = 0, scale = 1))
h &lt;- 3
LogN(y = y, k = 90, h = h)

## Not run: 
##If user do not mention the number of grid points
y &lt;- rweibull(350, 1)
xx &lt;- seq(0.00001, max(y), 500)

#any bandwidth can be used
require(ks)
h &lt;- hscv(y)   #Smooth cross validation bandwidth
LogN(x = xx, y = y, h = h)

## End(Not run)

## Not run: 
#if both scheme and number of grid points are missing then function generate NA
n &lt;- 1000
y &lt;- abs(rlogis(n, location = 0, scale = 1))
band = 3
LogN(y = y, h = band)

## End(Not run)

#if bandwidth is missing
y &lt;- rweibull(350, 1)
xx &lt;- seq(0.001, 100, length = 500)
LogN(x = xx, y = y, k = 90)
</code></pre>

<hr>
<h2 id='mse'>Calculate Mean Squared Error( MSE) by using different Kernels</h2><span id='topic+mse'></span>

<h3>Description</h3>

<p>This function calculates the mean squared error (MSE) by using user specified kernel. But distribution of vector should be Exponential, Gamma or Weibull. Any other choice of distribution will result <code>NaN</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mse(kernel, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mse_+3A_kernel">kernel</code></td>
<td>
<p>type of kernel which is to be used</p>
</td></tr>
<tr><td><code id="mse_+3A_type">type</code></td>
<td>
<p>mention distribution of vector.If exponential distribution then use <code>"Exp"</code>.
If use gamma distribution then use <code>"Gamma"</code>.If Weibull distribution then use <code>"Weibull"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mean Squared Error (MSE)
</p>


<h3>Author(s)</h3>

<p>Javaria Ahmad Khan, Atif Akbar.
</p>


<h3>References</h3>


<ul>
<li><p> Jin, X.; Kawczak, J. 2003. Birnbaum-Saunders &amp; Lognormal kernel estimators for modeling durations in high frequency financial data. <em>Annals of Economics and Finance</em> <strong>4</strong>, 103-124.
</p>
</li>
<li><p> Salha, R. B.; Ahmed, E. S.; Alhoubi, I. M. 2014. Hazard rate function estimation using Erlang Kernel. <em>Pure Mathematical Sciences</em> <strong>3</strong> (4), 141-152.
</p>
</li>
<li><p> Chen, S. X. 2000. Probability density function estimation using Gamma kernels. <em>Annals of the Institute of Statistical Mathematics</em> <strong>52</strong> (3), 471-480.
</p>
</li>
<li><p> Chen, S. X. 2000. Beta kernel smothers for regression curves. <em>Statistica Sinica</em> <strong>10</strong>, 73-91.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- rexp(100, 1)
xx &lt;- seq(min(y) + 0.05, max(y), length = 500)
h &lt;- 2
gr &lt;- Gamma(x = xx, y = y, k = 200, h = h)
mse(kernel = gr, type = "Exp")
## if distribution is other than mentioned \code{type} is used then NaN will be produced.
## Not run: 
mse(kernel = gr, type ="Beta")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.Beta'>Density Plot by Beta kernel</h2><span id='topic+plot.Beta'></span>

<h3>Description</h3>

<p>Plot density by using Beta Kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Beta'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Beta_+3A_x">x</code></td>
<td>
<p>an object of class &quot;Beta&quot;</p>
</td></tr>
<tr><td><code id="plot.Beta_+3A_...">...</code></td>
<td>
<p>Not presently used in this implementation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Javaria Ahmad Khan, Atif Akbar.
</p>


<h3>References</h3>

<p>Chen, S. X. 2000. Beta kernel smothers for regression curves. <em>Statistica Sinica</em> <strong>10</strong>, 73-91.
</p>


<h3>See Also</h3>

<p>For further kernels see <code><a href="#topic+plot.Gamma">plot.Gamma</a></code>, <code><a href="#topic+plot.Erlang">plot.Erlang</a></code>, <code><a href="#topic+plot.BS">plot.BS</a></code> and <code><a href="#topic+plot.LogN">plot.LogN</a></code>. To calculate its estimated values see <code><a href="#topic+Beta">Beta</a></code> and for
MSE see <code><a href="#topic+mse">mse</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- runif(100)
h &lt;- 0.5
xx &lt;- sample(0.00001:900, 50, replace = FALSE)/1000
den &lt;- Beta(x = xx, y = y, k = 50, h = h)
plot(den, type = "p")
##other details can also be added
y &lt;- runif(100)
h &lt;- 0.7
xx &lt;- sample(0.00001:900, 50, replace = FALSE)/1000
den &lt;- Beta(x = xx, y = y, k = 50, h = h)
plot(den, type = "l", ylab = "Density Function", lty = 1, xlab = "Time")

</code></pre>

<hr>
<h2 id='plot.BS'>Density Plot by Birnbaum-Saunders kernel</h2><span id='topic+plot.BS'></span>

<h3>Description</h3>

<p>Plot Kernel density by using Birnbaum-Saunders Kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BS'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.BS_+3A_x">x</code></td>
<td>
<p>An object of class &quot;BS&quot;</p>
</td></tr>
<tr><td><code id="plot.BS_+3A_...">...</code></td>
<td>
<p>Not presently used in this implementation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>Javaria Ahmad Khan, Atif Akbar.
</p>


<h3>References</h3>

<p>Jin, X.; Kawczak, J. 2003. Birnbaum-Saunders &amp; Lognormal kernel estimators for modeling durations in high frequency financial data. <em>Annals of Economics and Finance</em> <strong>4</strong>, 103-124.
</p>


<h3>See Also</h3>

<p>For further kernels see  <code><a href="#topic+plot.Beta">plot.Beta</a></code>, <code><a href="#topic+plot.Erlang">plot.Erlang</a></code>, <code><a href="#topic+plot.Gamma">plot.Gamma</a></code> and <code><a href="#topic+plot.LogN">plot.LogN</a></code>. For estimated values <code><a href="#topic+BS">BS</a></code> and for MSE <code><a href="#topic+mse">mse</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha = 10
theta = 15 / 60
y &lt;- rgamma(n = 10000, shape = alpha, scale = theta)
h &lt;- 1.5
xx &lt;- seq(min(y) + 0.05, max(y), length = 200)
den &lt;- BS(x = xx, y = y, k = 200, h = h)
plot(den, type = "l")

##other details can also be added
y &lt;- rgamma(n = 10000, shape = alpha, scale = theta)
h &lt;- 0.79 * IQR(y) * length(y) ^ (-1/5)  #Normal Scale Rule Bandwidth
gr &lt;- BS(x = xx, y = y, k = 200, h = h)
plot(gr, type = "s", ylab = "Density Function", lty = 1, xlab = "Time")

## To add true density along with estimated
d1 &lt;- density(y, bw = h)
lines(d1, type = "p", col = "red")
legend("topright", c("Real Density", "Density by Birnbaum-Saunders Kernel"),
col=c("red", "black"), lty = c(1,2))
</code></pre>

<hr>
<h2 id='plot.Erlang'>Density Plot by Erlang kernel</h2><span id='topic+plot.Erlang'></span>

<h3>Description</h3>

<p>Plot Kernel density by using Erlang Kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Erlang'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Erlang_+3A_x">x</code></td>
<td>
<p>An object of class &quot;Erlang&quot;</p>
</td></tr>
<tr><td><code id="plot.Erlang_+3A_...">...</code></td>
<td>
<p>Not presently used in this implementation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>Javaria Ahmad Khan, Atif Akbar.
</p>


<h3>References</h3>

<p>Salha, R. B.; Ahmed, E. S.; Alhoubi, I. M. 2014. Hazard rate function estimation using Erlang Kernel. <em>Pure Mathematical Sciences</em> <strong>3</strong> (4), 141-152.
</p>


<h3>See Also</h3>

<p>For further MSE by using other kernels see <code><a href="#topic+plot.Beta">plot.Beta</a></code>, <code><a href="#topic+plot.BS">plot.BS</a></code>, <code><a href="#topic+plot.Gamma">plot.Gamma</a></code> and <code><a href="#topic+plot.LogN">plot.LogN</a></code>. For estimated values <code><a href="#topic+Erlang">Erlang</a></code> and for calculating MSE see <code><a href="#topic+mse">mse</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- rlnorm(100, meanlog = 0, sdlog = 1)
h &lt;- 1.5
xx &lt;- seq(min(y) + 0.05, max(y), length = 200)
den &lt;- Erlang(x = xx, y = y, k = 200, h = h)
plot(den, type = "l")

##other details can also be added
y &lt;- rlnorm(100, meanlog = 0, sdlog = 1)
grid &lt;- seq(min(y) + 0.05, max(y), length = 200)
h &lt;- 0.79 * IQR(y) * length(y) ^ (-1/5)
gr &lt;- Erlang(x = grid, y = y, k = 200, h = h)
plot(gr, type = "s", ylab = "Density Function", lty = 1, xlab = "Time")

## To add true density along with estimated
d1 &lt;- density(y, bw = h)
lines(d1, type = "p", col = "red")
legend("topright", c("Real Density", "Density by Erlang Kernel"),
col=c("red", "black"), lty=c(1,2))
</code></pre>

<hr>
<h2 id='plot.Gamma'>Density Plot by Gamma kernel</h2><span id='topic+plot.Gamma'></span>

<h3>Description</h3>

<p>Plot density by using Gamma Kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Gamma'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Gamma_+3A_x">x</code></td>
<td>
<p>an object of class &quot;Gamma&quot;</p>
</td></tr>
<tr><td><code id="plot.Gamma_+3A_...">...</code></td>
<td>
<p>Not presently used in this implementation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Javaria Ahmad Khan, Atif Akbar.
</p>


<h3>References</h3>

<p>Chen, S. X. 2000. Probability density function estimation using Gamma kernels.  <em>Annals of the Institute of Statistical Mathematics</em> <strong>52</strong> (3), 471-480.
</p>


<h3>See Also</h3>

<p>For further kernels see <code><a href="#topic+plot.Beta">plot.Beta</a></code>, <code><a href="#topic+plot.Erlang">plot.Erlang</a></code>, <code><a href="#topic+plot.BS">plot.BS</a></code> and <code><a href="#topic+plot.LogN">plot.LogN</a></code>. To calculate its estimated values see <code><a href="#topic+Gamma">Gamma</a></code> and for
MSE <code><a href="#topic+mse">mse</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- rexp(100, 1)
h &lt;- 1.5
xx &lt;- seq(min(y) + 0.05, max(y), length =200)
den &lt;- Gamma(x=xx, y=y, k=200, h=h)
plot(den, type = "l")

##other details can also be added
y &lt;- rexp(100, 2)
h &lt;- 0.79 * IQR(y) * length(y) ^ (-1/5)
gr &lt;- Gamma(x=xx, y=y, k=200, h=h)
plot(gr, type = "s", ylab = "Density Function", lty = 1, xlab = "Time")

## To add true density along with estimated
d1 &lt;- density(y, bw=h)
lines(d1, type="p", col="red")
legend("topright", c("Real Density", "Density by Gamma Kernel"),
col=c("red", "black"), lty=c(1,2))

</code></pre>

<hr>
<h2 id='plot.LogN'>Density Plot by Lognormal kernel</h2><span id='topic+plot.LogN'></span>

<h3>Description</h3>

<p>Plot Kernel density by using Lognormal Kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LogN'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.LogN_+3A_x">x</code></td>
<td>
<p>An object of class &quot;LogN&quot;</p>
</td></tr>
<tr><td><code id="plot.LogN_+3A_...">...</code></td>
<td>
<p>Not presently used in this implementation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>Javaria Ahmad Khan, Atif Akbar.
</p>


<h3>References</h3>

<p>Jin, X.; Kawczak, J. 2003. Birnbaum-Saunders &amp; Lognormal kernel estimators for modeling durations in high frequency financial data. <em>Annals of Economics and Finance</em> <strong>4</strong>, 103-124.
</p>


<h3>See Also</h3>

<p>For further kernels see <code><a href="#topic+plot.Beta">plot.Beta</a></code>, <code><a href="#topic+plot.Erlang">plot.Erlang</a></code>, <code><a href="#topic+plot.Gamma">plot.Gamma</a></code> and <code><a href="#topic+plot.BS">plot.BS</a></code>. To calculate MSE use <code><a href="#topic+mse">mse</a></code> and for estimated values for density
estimation see <code><a href="#topic+LogN">LogN</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 1000
y &lt;- abs(rlogis(n, location = 0, scale = 1))
xx &lt;- seq(min(y) + 0.05, max(y), length =90)
h &lt;- 0.00003
den &lt;- LogN(x = xx, y = y, k = 90, h = h)
plot(den, type = "l")

##other details can also be added
y &lt;- abs(rlogis(n, location = 0, scale = 1))
h &lt;- 3
gr &lt;- LogN(x = xx, y = y, k = 90, h = h)
plot(gr, type = "s", ylab = "Density Function", lty = 1, xlab = "Time")

## To add true density along with estimated
d1 &lt;- density(y, bw = h)
lines(d1, type = "p", col = "green")
legend("topleft", c("Real Density", "Density by Lognormal Kernel"),
col = c("green", "black"), lty = c(1,2))
</code></pre>

<hr>
<h2 id='TUNA'>Data of Tuna fish</h2><span id='topic+TUNA'></span>

<h3>Description</h3>

<p>Data is about Tuna, which is saltwater fish. Its seasonal migration is between waters off the coast of Australia and the Indian Ocean. The data represents a line transect aerial survey of
Southern Bluefin Tuna in the Great Australian Bight in summer when the tuna tend to stay on the surface. The abundance D is measured by </p>
<p style="text-align: center;"><code class="reqn">D = \frac{N}{A}</code>
</p>
<p> , where N is the total number of surface
schools in the Bight and A is the survey area. To estimate D, an aircraft with two spotters on board is used to fly randomly allocated transect lines to detect tuna schools.
Each school sighted from transect is counted and its perpendicular distance to transect is measured.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TUNA
</code></pre>


<h3>Format</h3>

<p>A vector with 64 observations
</p>


<h3>References</h3>

<p>Buckland, S. T.; Burnham, K. P.; Anderson, D. R.; Laake, J. L. 1993. <em>Density Estimation using Distance Sampling</em>. Chapman &amp; Hall, London.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
