<!DOCTYPE html><html lang="en-GB"><head><title>Help for package pixelclasser</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pixelclasser}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pixelclasser'><p>pixelclasser: Functions to classify pixels by colour</p></a></li>
<li><a href='#classify_pixels'><p>Classifies the pixels of an image</p></a></li>
<li><a href='#deprecated'><p>Deprecated functions</p></a></li>
<li><a href='#label_rule'><p>Adds a label to the rule</p></a></li>
<li><a href='#pixel_category'><p>Creates a category object</p></a></li>
<li><a href='#pixel_rule'><p>Creates a rule object</p></a></li>
<li><a href='#pixel_subcategory'><p>Creates a subcategory object</p></a></li>
<li><a href='#place_rule'><p>Places a line on the rgb plot</p></a></li>
<li><a href='#plot_pixels'><p>Plot the pixels of a transformed image</p></a></li>
<li><a href='#plot_rgb_plane'><p>Plots a triangular plot to be filled with pixels and rules</p></a></li>
<li><a href='#plot_rule'><p>Plots the line that defines a rule</p></a></li>
<li><a href='#read_image'><p>Imports  and transforms a jpg or tiff file.</p></a></li>
<li><a href='#save_classif_image'><p>Saves a classified image in TIFF or JPEG format</p></a></li>
<li><a href='#transform_colours'><p>Transforms RGB values into proportions (rgb values)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Classifies Image Pixels by Colour</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-18</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains functions to classify the pixels of an image file by its colour. It implements a simple form of the techniques known as Support Vector Machine adapted to this particular problem.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>false</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, jpeg, tiff,</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Contact:</td>
<td>carlos.real@usc.es</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-18 14:13:44 UTC; mnium</td>
</tr>
<tr>
<td>Author:</td>
<td>Carlos Real <a href="https://orcid.org/0000-0002-5433-6728"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Quentin Read [rev]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Carlos Real &lt;carlos.real@usc.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-18 14:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='pixelclasser'>pixelclasser: Functions to classify pixels by colour</h2><span id='topic+pixelclasser'></span><span id='topic+pixelclasser-package'></span>

<h3>Description</h3>

<p><code>pixelclasser</code> contains functions to classify the pixels of a digital
image file (in format jpeg or tiff) by its colour. It uses a simple form of
the technique known as Support Vector Machine, adapted to this particular
problem. The original colour variables (<code>R, G, B</code>) are transformed into
colour proportions (<code>r, g, b</code>), and the resulting two dimensional plane,
defined by any convenient pair of the transformed variables is divided in
several subsets (categories) by one or more straight lines (rules) manually
selected by the user. Finally, the pixels belonging to each category are
identified using the rules, and a classified image can be created and saved.
</p>


<h3>Details</h3>

<p>To classify the pixels of an image, a series of steps must be done
in the following order, using the functions shown in parenthesis:
</p>

<ul>
<li><p> import the image into an R array of transformed (<code>rgb</code>) data
(using <code>read_image()</code>).
</p>
</li>
<li><p> plot the pixels of the image on the plane of two transformed
variables that shows the categories of pixels most clearly
(<code>plot_rgb_plane()</code>, <code>plot_pixels</code>).
</p>
</li>
<li><p> trace lines between the pixel clusters and use them to create
classification rules (<code>place_rule()</code>, <code>pixel_rule</code>,
<code>plot_rule()</code>). The user places the lines manually.
</p>
</li>
<li><p> combine the rules to define categories. Sometimes the rules are
combined into subcategories and these into categories
(<code>pixel_category()</code>, <code>pixel_subcategory()</code>).
</p>
</li>
<li><p> use the categories to classify the pixels (<code>classify_pixels()</code>).
</p>
</li>
<li><p> save the results of the classification as an image, if needed
(<code>save_clasif_image()</code>). </p>
</li></ul>

<p>These steps are explained in depth in the vignette included in the package.
</p>


<h3>Author(s)</h3>

<p>Carlos Real (carlos.real@usc.es)
</p>

<hr>
<h2 id='classify_pixels'>Classifies the pixels of an image</h2><span id='topic+classify_pixels'></span><span id='topic+is.classified_image'></span><span id='topic+summary.pixel_classified_image'></span>

<h3>Description</h3>

<p>Classifies the pixels represented in an object of class
<code>"pixel_transformed_image"</code> using the rules contained in a list of
objects of class <code>"pixel_category"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify_pixels(image_prop, ..., unclassed_colour = "black", verbose = TRUE)

is.classified_image(x)

## S3 method for class 'pixel_classified_image'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="classify_pixels_+3A_image_prop">image_prop</code></td>
<td>
<p>an object of class <code>"pixel_transformed_image"</code> created
by function <code>read_image()</code>.</p>
</td></tr>
<tr><td><code id="classify_pixels_+3A_...">...</code></td>
<td>
<p>in <code>classify_pixels()</code> a list of objects of class
<code>"pixel_category"</code>; in <code>summary()</code>, additional parameters (none
needed by now).</p>
</td></tr>
<tr><td><code id="classify_pixels_+3A_unclassed_colour">unclassed_colour</code></td>
<td>
<p>a character string defining the colour of the
unclassified pixels. Defaults to <code>"black"</code>.</p>
</td></tr>
<tr><td><code id="classify_pixels_+3A_verbose">verbose</code></td>
<td>
<p>a logical value. When <code>TRUE</code> (default) the function
prints some statistics about the classification.</p>
</td></tr>
<tr><td><code id="classify_pixels_+3A_x">x</code></td>
<td>
<p>the R object being tested.</p>
</td></tr>
<tr><td><code id="classify_pixels_+3A_object">object</code></td>
<td>
<p>an object of class <code>"pixel_classified_image"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the rules contained in <code>"pixel_category"</code>
objects to create a set of incidence matrices indicating whether a pixel
belongs to a pixel category or not.
</p>
<p>To create the incidence matrices for each category, a matrix for each rule
is created and then combined with the matrices of the other using the
<code>and</code> operator. An additional matrix identifies the pixels that do not
belong to the defined categories, i.e. unclassed pixels. It is always
present and named <code>unclassified</code> even in the case that all pixels were
assigned to some class.
</p>
<p>When a category is divided in a set of subcategories the pixels are
classfied in subcategories as explained in the previous paragraph, and then
the matrices of the subcategories are combined again, this time using the
<code>or</code> operator. See <code>"pixel_subcategory"</code> for more details.
</p>
<p><code>unclassed_colour</code> can be specified in any form understood by
<code>grDevices::col2grb</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>"pixel_classified_image"</code>, which is
a list containing nested lists. Each first-level element corresponds to one
of the pixel categories and its name is the category name. They contains
the second-level list, which have the following elements:
</p>

<ul>
<li> <p><code>colour</code>: a matrix defining a colour to paint the pixels in the
classified image. Inherited from the <code>"pixel_class"</code> object defining
the
class.
</p>
</li>
<li> <p><code>incid_mat</code>: a logical matrix where <code>TRUE</code> values
indicate that the pixel belongs to this pixel category. </p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+pixel_category">pixel_category</a></code>, <code><a href="grDevices.html#topic+col2rgb">col2rgb</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# These are the steps to classify an example image supplied in the package

yellow &lt;- "#ffcd0eff"
blue &lt;- "#5536ffff"

ivy_oak_rgb &lt;- read_image(system.file("extdata", "IvyOak400x300.JPG",
                          package = "pixelclasser"))

rule_01 &lt;- pixel_rule("rule_01", "g", "b",
                       list(c(0.345, 1/3), c(0.40, 0.10)), comp_op = "&lt;")
rule_02 &lt;- pixel_rule("rule_02", "g", "b",
                       list(c(0.345, 1/3), c(0.40, 0.10)), comp_op = "&gt;=")

cat_dead_leaves &lt;- pixel_category("dead_leaves", blue, rule_01)
cat_living_leaves &lt;- pixel_category("living_leaves", yellow, rule_02)

ivy_oak_classified &lt;- classify_pixels(ivy_oak_rgb, cat_dead_leaves,
                        cat_living_leaves)

</code></pre>

<hr>
<h2 id='deprecated'>Deprecated functions</h2><span id='topic+deprecated'></span><span id='topic+define_cat'></span><span id='topic+define_subcat'></span><span id='topic+define_rule'></span>

<h3>Description</h3>

<p>Deprecated functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_cat(cat_name, cat_colour, ...)

define_subcat(subcat_name, ...)

define_rule(rule_name, x_axis, y_axis, rule_points, comp_op)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deprecated_+3A_cat_name">cat_name</code></td>
<td>
<p>a character string containing the name of the category.</p>
</td></tr>
<tr><td><code id="deprecated_+3A_cat_colour">cat_colour</code></td>
<td>
<p>a character string defining the colour to paint the pixels
with when creating a classified picture.</p>
</td></tr>
<tr><td><code id="deprecated_+3A_...">...</code></td>
<td>
<p>a list of objects of class <code>pixel_rule</code>.</p>
</td></tr>
<tr><td><code id="deprecated_+3A_subcat_name">subcat_name</code></td>
<td>
<p>a character string containing the name of the subcategory.</p>
</td></tr>
<tr><td><code id="deprecated_+3A_rule_name">rule_name</code></td>
<td>
<p>a character string containing the name of the rule.</p>
</td></tr>
<tr><td><code id="deprecated_+3A_x_axis">x_axis</code></td>
<td>
<p>a character string selecting the colour variable used as x
axis, one of <code>"r"</code>, <code>"g"</code> or <code>"b"</code>.</p>
</td></tr>
<tr><td><code id="deprecated_+3A_y_axis">y_axis</code></td>
<td>
<p>a character string selecting the colour variable used as y
axis, one of <code>"r"</code>, <code>"g"</code> or <code>"b"</code>.</p>
</td></tr>
<tr><td><code id="deprecated_+3A_rule_points">rule_points</code></td>
<td>
<p>either an object of  of class <code>"rule_points"</code> created
with function <code>place_rule()</code>, or a list containing the coordinates of
two points defining the line.</p>
</td></tr>
<tr><td><code id="deprecated_+3A_comp_op">comp_op</code></td>
<td>
<p>a character string containing one of the comparison operators
<code>"&gt;", "&gt;=", "&lt;", "&lt;="</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions were constructors for pixelclasser objects, but now
they are substituted by constructors with the same name as the class, as is
customary in R.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pixel_category">pixel_category</a></code>, <code><a href="#topic+pixel_subcategory">pixel_subcategory</a></code> and
<code><a href="#topic+pixel_rule">pixel_rule</a></code>.
</p>

<hr>
<h2 id='label_rule'>Adds a label to the rule</h2><span id='topic+label_rule'></span>

<h3>Description</h3>

<p>This function adds a label to a line representing a rule on the plots created
by <code>plot_rgb_plane()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label_rule(rule, label = "", shift = c(0, 0), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="label_rule_+3A_rule">rule</code></td>
<td>
<p>an object of class <code>"pixel_rule"</code>.</p>
</td></tr>
<tr><td><code id="label_rule_+3A_label">label</code></td>
<td>
<p>a string to label the line. It is attached at the coordinates of
the start (first point) of the line.</p>
</td></tr>
<tr><td><code id="label_rule_+3A_shift">shift</code></td>
<td>
<p>a numeric vector to set the displacement of the label from the
start of the line. Expressed in graph units, defaults to <code>c(0, 0)</code>.</p>
</td></tr>
<tr><td><code id="label_rule_+3A_...">...</code></td>
<td>
<p>additional graphical parameters passed to the underlying
<code>graphics::text()</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the information stored in <code>"pixel_rule"</code>
objects to label the line at its start point. The <code>shift</code> values,
expressed in plot coordinates, are added to the coordinates of that point
to place the label elsewhere. Note that ... can be used to pass
additional parameters (<code>pos</code> and <code>adj</code>) to the underlying
<code>graphics::text()</code> function, to further adjust the position of the
label. Pass a character string understood by <code>grDevices::col2rgb()</code> to
set the colour of the label (<code>col</code>).
</p>


<h3>Value</h3>

<p>The function does not return any value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_rgb_plane">plot_rgb_plane</a></code>, <code><a href="#topic+pixel_rule">pixel_rule</a></code>,
<code><a href="grDevices.html#topic+col2rgb">col2rgb</a></code>, <code><a href="graphics.html#topic+text">text</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rule_01 &lt;- pixel_rule("rule_01", "g", "b",
                       list(c(0.1, 0.8), c(0.40, 0.10)), "&lt;")
plot_rgb_plane("g", "b")

# The rule is represented as a green line
plot_rule(rule_01, col = "green")

# And the label is added in three different positions by passing col and adj
# to the underlying function
label_rule(rule_01, label = expression('R'[1]*''), shift = c(0,0),
           col = 'black', adj = 1.5)
label_rule(rule_01, label = expression('R'[1]*''), shift = c(0.2, -0.4),
           col = 'blue', adj = 0)
label_rule(rule_01, label = expression('R'[1]*''), shift = c(0.3, -0.7),
           col = 'black', adj = -0.5)

</code></pre>

<hr>
<h2 id='pixel_category'>Creates a category object</h2><span id='topic+pixel_category'></span><span id='topic+is.category'></span><span id='topic+summary.pixel_category'></span>

<h3>Description</h3>

<p>Creates an object of class <code>"pixel_category"</code>, which contains a list of
objects of class <code>"pixel_subcategory"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pixel_category(cat_name, cat_colour, ...)

is.category(x)

## S3 method for class 'pixel_category'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pixel_category_+3A_cat_name">cat_name</code></td>
<td>
<p>a character string containing the name of the category.</p>
</td></tr>
<tr><td><code id="pixel_category_+3A_cat_colour">cat_colour</code></td>
<td>
<p>a character string defining the colour to paint the pixels
with when creating a classified picture.</p>
</td></tr>
<tr><td><code id="pixel_category_+3A_...">...</code></td>
<td>
<p>in <code>pixel_category()</code> a list of objects of class
<code>"pixel_subcategory"</code> or <code>"pixel_rule"</code>; in <code>summary()</code>,
additional parameters (none needed by now).</p>
</td></tr>
<tr><td><code id="pixel_category_+3A_x">x</code></td>
<td>
<p>the R object being tested</p>
</td></tr>
<tr><td><code id="pixel_category_+3A_object">object</code></td>
<td>
<p>an object of class <code>"pixel_category"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function receives a list of objects of class
<code>"pixel_subcategory"</code> and creates an object of class
<code>"pixel_category"</code> with them. However, subcategories are not always
needed (see <code><a href="#topic+pixel_subcategory">pixel_subcategory</a></code>). In these cases
<code>"pixel_rule"</code> objects can be passed to this function, which creates
an internal subcategory object (named &quot;S0&quot;) to contain them. See the
examples below.
</p>
<p>Note that it is an error to pass a mixture of <code>"pixel_rule"</code> and
<code>"pixel_subcategory"</code> objects.
</p>
<p><code>colour</code> can be specified in any form understood by
<code>grDevices::col2grb</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"pixel_category"</code> which is a list with the
following elements:
</p>

<ul>
<li> <p><code>name</code>: the character string with the name of the pixel
category.
</p>
</li>
<li> <p><code>colour</code>: a character string describing the
colour of the pixels of the category in the classified images.
</p>
</li>
<li> <p><code>subcats</code>: a list of <code>"pixel_subcategory"</code> objects.</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+pixel_rule">pixel_rule</a></code>, <code><a href="#topic+pixel_subcategory">pixel_subcategory</a></code>,
<code><a href="grDevices.html#topic+col2rgb">col2rgb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This set of rules is not consistent, they are only useful as examples
rule01 &lt;- pixel_rule("R01", "g", "b",
                      list(c(0.35, 0.30), c(0.45, 0.10)), "&gt;=")
rule02 &lt;- pixel_rule("R02", "g", "b",
                      list(c(0.35, 0.253), c(0.45, 0.253)), "&gt;=")
rule03 &lt;- pixel_rule("R03", "g", "b",
                      list(c(0.35, 0.29), c(0.49, 0.178)), "&gt;=")
rule04 &lt;- pixel_rule("R04", "g", "b",
                      list(c(0.35, 0.253), c(0.45, 0.253)), "&lt;")

subcat01 &lt;- pixel_subcategory("Subcat01", rule01, rule02)
subcat02 &lt;- pixel_subcategory("Subcat02", rule03, rule04)

cat01 &lt;- pixel_category("Cat01", "#ffae2a", subcat01, subcat02)

# A single category defined by a set of rules, not subcategories
cat02 &lt;- pixel_category("Cat02", "#00ae2a", rule01, rule02, rule03)

</code></pre>

<hr>
<h2 id='pixel_rule'>Creates a rule object</h2><span id='topic+pixel_rule'></span><span id='topic+is.rule'></span><span id='topic+summary.pixel_rule'></span>

<h3>Description</h3>

<p>Creates an object of class <code>pixel_rule</code> from a line in <code>rgb</code> space,
defined by the user, and a relational operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pixel_rule(rule_name, x_axis, y_axis, line_points, comp_op)

is.rule(x)

## S3 method for class 'pixel_rule'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pixel_rule_+3A_rule_name">rule_name</code></td>
<td>
<p>a character string containing the name of the rule.</p>
</td></tr>
<tr><td><code id="pixel_rule_+3A_x_axis">x_axis</code></td>
<td>
<p>a character string selecting the colour variable used as x
axis, one of <code>"r"</code>, <code>"g"</code> or <code>"b"</code>.</p>
</td></tr>
<tr><td><code id="pixel_rule_+3A_y_axis">y_axis</code></td>
<td>
<p>a character string selecting the colour variable used as y
axis, one of <code>"r"</code>, <code>"g"</code> or <code>"b"</code>.</p>
</td></tr>
<tr><td><code id="pixel_rule_+3A_line_points">line_points</code></td>
<td>
<p>either an object of  of class <code>"rule_points"</code> created
with function <code>place_rule()</code>, or a list containing the coordinates of
two points defining the line. The coordinates are two-element numeric
vectors.</p>
</td></tr>
<tr><td><code id="pixel_rule_+3A_comp_op">comp_op</code></td>
<td>
<p>a character string containing one of the comparison operators
<code>"&gt;", "&gt;=", "&lt;", "&lt;="</code>.</p>
</td></tr>
<tr><td><code id="pixel_rule_+3A_x">x</code></td>
<td>
<p>the R object being tested</p>
</td></tr>
<tr><td><code id="pixel_rule_+3A_object">object</code></td>
<td>
<p>an object of class <code>"pixel_category"</code>.</p>
</td></tr>
<tr><td><code id="pixel_rule_+3A_...">...</code></td>
<td>
<p>additional parameters to pass to the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates the slope (<code>a</code>) and intercept
(<code>c</code>) of the line <code>y = ax + c</code> from the coordinates of two points
on the line. <code>x</code> and <code>y</code> are two colour variables selected by the
user (<code>r</code>, <code>g</code>, or <code>b</code>). The line divides the plane in two
subsets and the comparison operator selects the subset that contains the
points (pixels) of interest.
</p>
<p>When the line is defined by a list containing a couple of points, it is
first converted into an object of class <code>"pixel_rule_points"</code> (see
<code><a href="#topic+place_rule">place_rule</a></code>, and the examples below).
</p>
<p>The lines are mathematical objects that extend without bound, i.e. all
along the x axis. The pair of points do not set the line limits, they only
allow the estimation of the line parameters. Therefore, they are not
constrained to be inside the triangular area occupied by the pixels, and
the points can be selected in the most convenient way, provided that the
line divides correctly the categories. Convenience in this context means
that the line should seem nice in the plot, if this matters.
</p>
<p>Because the variables were transformed into proportions, the pixels in the
plot are always inside the triangle defined by the points <code>(0, 0), (1,
  0), (0, 1)</code>. So, the sides of this triangle can be considered as implicit
rules which do not need to be created explicitly. In this way, a single
line creates two polygons by cutting the triangle in two. Usually, the
implicit rules reduce the number of rules to create.
</p>


<h3>Value</h3>

<p>An object of class <code>"pixel_rule"</code> containing these elements:
</p>

<ul>
<li> <p><code>rule_name</code>: a character string containing the rule name.
</p>
</li>
<li> <p><code>rule_text</code>: a character string containing the mathematical
expression of the rule.
</p>
</li>
<li> <p><code>comp_op</code>: a character string containing the comparison operator
used in the rule.
</p>
</li>
<li> <p><code>a</code>: a numerical vector containing the parameter <code>a</code>
(slope) of the line.
</p>
</li>
<li> <p><code>c</code>: a numerical vector containing the parameter <code>c</code>
(intercept) of the line.
</p>
</li>
<li> <p><code>x_axis</code>: a character string containing the colour variable
selected as <code>x</code> axis (one of &quot;r&quot;, &quot;g&quot; or &quot;b&quot;).
</p>
</li>
<li> <p><code>y_axis</code>: a character string containing the colour variable
selected as <code>y</code> axis.
</p>
</li>
<li> <p><code>first_point</code>: a numerical vector containing the coordinates of
the first point used to estimate the line equation.
</p>
</li>
<li> <p><code>second_point</code>: a numerical vector containing the coordinates of
the second point. </p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+pixel_subcategory">pixel_subcategory</a></code>, <code><a href="#topic+pixel_category">pixel_category</a></code>,
<code><a href="#topic+plot_rule">plot_rule</a></code>, <code><a href="#topic+plot_rgb_plane">plot_rgb_plane</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating the line by passing the coordinates of two points on the line:
rule01 &lt;- pixel_rule("rule01", "g", "b",
                      list(c(0.35, 0.30), c(0.45, 0.10)),"&gt;")

# A vertical line as a rule; note that the equation will be simplified
rule02 &lt;- pixel_rule("rule02", "g", "b",
                      list(c(0.35, 0.30), c(0.35, 0.00)), "&gt;")
## Not run: 
# Creating the rule by passing an object of type rule_point:
rule_points01 &lt;- place_rule("g", "b")
rule03 &lt;- pixel_rule("rule03", "g", "b", rule_points01,"&gt;")

# Note that the creation of the intermediate object can be avoided:
rule04 &lt;- pixel_rule("rule04", "g", "b", place_rule("g", "b"),"&gt;")

## End(Not run)
</code></pre>

<hr>
<h2 id='pixel_subcategory'>Creates a subcategory object</h2><span id='topic+pixel_subcategory'></span><span id='topic+is.subcategory'></span><span id='topic+summary.pixel_subcategory'></span>

<h3>Description</h3>

<p>Creates an object of class <code>pixel_subcategory</code> from a list of objects of
class <code>pixel_rule</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pixel_subcategory(subcat_name, ...)

is.subcategory(x)

## S3 method for class 'pixel_subcategory'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pixel_subcategory_+3A_subcat_name">subcat_name</code></td>
<td>
<p>a character string containing the name of the subcategory.</p>
</td></tr>
<tr><td><code id="pixel_subcategory_+3A_...">...</code></td>
<td>
<p>in <code>pixel_subcategory()</code> a list of objects of class
<code>"pixel_rule"</code>; in <code>summary()</code>, additional parameters (none
needed by now).</p>
</td></tr>
<tr><td><code id="pixel_subcategory_+3A_x">x</code></td>
<td>
<p>the R object being tested</p>
</td></tr>
<tr><td><code id="pixel_subcategory_+3A_object">object</code></td>
<td>
<p>an object of class <code>"pixel_subcategory"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the shape of the cluster of pixels belonging to one category is
not convex, the rules become inconsistent (the lines cross in awkward ways)
and the classification produced is erroneous. To solve this problem, the
complete set of rules is divided into several subsets (subcategories) that
break the original non-convex shape into a set of convex polygons. Note
that any polygon can be divided in a number of triangles, so this problem
always has solution. However, in many cases (such as the one presented in
the pixelclasser vignette) a complete triangulation is not needed.
</p>
<p>Internally, <code>classify_pixels()</code> classifies the points belonging to
each subcategory and then joins the incidence matrices using the <code>or</code>
operator, to create the matrix for the whole category.
</p>


<h3>Value</h3>

<p>An object of class <code>"pixel_subcategory"</code>, which is a list with
these elements:
</p>

<ul>
<li> <p><code>name</code> a character string containing the name of the
subcategory.
</p>
</li>
<li> <p><code>rules_list</code> a list of  <code>pixel_rule</code> objects.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+pixel_rule">pixel_rule</a></code>, <code><a href="#topic+pixel_category">pixel_category</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rule01 &lt;- pixel_rule("R01", "g", "b",
                      list(c(0.35, 0.30), c(0.45, 0.10)), "&gt;=")
rule02 &lt;- pixel_rule("R02", "g", "b",
                      list(c(0.35, 0.253), c(0.45, 0.253)), "&gt;=")

subcat01 &lt;- pixel_subcategory("Subcat_01", rule01, rule02)

</code></pre>

<hr>
<h2 id='place_rule'>Places a line on the rgb plot</h2><span id='topic+place_rule'></span><span id='topic+is.rule_points'></span>

<h3>Description</h3>

<p>A wrapper function for <code>graphics::locator</code> that helps in creating rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>place_rule(x_axis, y_axis, line_type = "f")

is.rule_points(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="place_rule_+3A_x_axis">x_axis</code></td>
<td>
<p>a character string indicating the colour variable that
corresponds to the x axis, one of <code>"r"</code>, <code>"g"</code> or <code>"b"</code>.</p>
</td></tr>
<tr><td><code id="place_rule_+3A_y_axis">y_axis</code></td>
<td>
<p>a character string indicating the colour variable that
corresponds to the y axis, one of <code>"r"</code>, <code>"g"</code> or <code>"b"</code>.</p>
</td></tr>
<tr><td><code id="place_rule_+3A_line_type">line_type</code></td>
<td>
<p>a character string indicating that the line is vertical
(<code>"v"</code>), horizontal (<code>"h"</code>) or free (<code>"f"</code>, the default).</p>
</td></tr>
<tr><td><code id="place_rule_+3A_x">x</code></td>
<td>
<p>the R object being tested</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls <code>graphics::locator</code> on a previously plotted
rgb plane to select two points with the mouse. Then it plots the line
joining them and returns an object of class <code>"pixel_rule_object"</code>.
These objects are passed as parameters to <code>pixel_rule()</code> to create
<code>"pixel_rule"</code> objects.
</p>
<p>True horizontal and vertical lines are difficult to create by hand. In
these cases, specifying <code>"vertical"</code> or <code>"horizontal"</code> (partial
match allowed, i.e. <code>"h"</code>) will copy the appropriate coordinate value
from the first point to the second to make them the same. Note that this is
done after <code>locator()</code> returns, so the plot will show the line joining
the original points, not the corrected ones. Use <code>plot_rule()</code> to see
the corrected line.
</p>


<h3>Value</h3>

<p>An object of class <code>"pixel_rule_points"</code> containing these
elements:
</p>

<ul>
<li> <p><code>x_axis</code>: a character string containing the colour variable
selected as <code>x</code> axis (one of &quot;r, &quot;g or &quot;b&quot;).
</p>
</li>
<li> <p><code>y_axis</code>: a character string containing the colour variable
selected as <code>y</code> axis.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="graphics.html#topic+locator">locator</a></code>, <code><a href="#topic+pixel_rule">pixel_rule</a></code>,
<code><a href="#topic+plot_rule">plot_rule</a></code>, <code><a href="#topic+plot_rgb_plane">plot_rgb_plane</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plot_rgb_plane("r", "g")
line01 &lt;- place_rule("r", "g")          # A "free" line
line02 &lt;- place_rule("r", "g", "h")     # A horizontal line

## End(Not run)

</code></pre>

<hr>
<h2 id='plot_pixels'>Plot the pixels of a transformed image</h2><span id='topic+plot_pixels'></span>

<h3>Description</h3>

<p>This function is a wrapper for function <code>graphics::points()</code> for
plotting the pixels of an object of class <code>"pixel_transformed_image"</code> on
an rgb plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_pixels(image_rgb, x_axis, y_axis, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_pixels_+3A_image_rgb">image_rgb</code></td>
<td>
<p>an object of class <code>"pixel_transformed_image"</code> produced
by <code>read_image()</code>.</p>
</td></tr>
<tr><td><code id="plot_pixels_+3A_x_axis">x_axis</code></td>
<td>
<p>a character string indicating the colour variable that
corresponds to the x axis, one of <code>"r"</code>, <code>"g"</code> or <code>"b"</code>.</p>
</td></tr>
<tr><td><code id="plot_pixels_+3A_y_axis">y_axis</code></td>
<td>
<p>a character string indicating the colour variable that
corresponds to the x axis.</p>
</td></tr>
<tr><td><code id="plot_pixels_+3A_...">...</code></td>
<td>
<p>additional graphical parameters to be passed to
<code>graphics::points()</code>, mainly to set the colour (<code>col</code>) of the
points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is advantageous to specify a colour such as <code>"#00000005"</code>
which is black but almost transparent. In this way a kind of density plot
is created because the clustering of points creates areas of darker colour.
Note that a colour without specific transparency information defaults to an
opaque colour, so <code>"#000000"</code> is the same as <code>"#000000ff"</code>. The
colours can be specified in any form understandable by
<code>grDevices::col2rgb</code>, but the hexadecimal string allows setting the
colour transparency. Note also that the points are plotted using <code>pch
  = "."</code>, as any other symbol would clutter the graph.
</p>
<p>Warning: plotting several million points in an R graph is a slow process.
Be patient or reduce the size of the images as much as possible. A nice
smartphone with a petapixel camera sensor is good for artistic purposes,
but not always for efficient scientific work.
</p>


<h3>Value</h3>

<p>The function does not return any value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_rgb_plane">plot_rgb_plane</a></code>, <code><a href="grDevices.html#topic+col2rgb">col2rgb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Plotting the pixels of the example image included in this package
ivy_oak_rgb &lt;- read_image(system.file("extdata", "IvyOak400x300.JPG",
                                       package = "pixelclasser"))
plot_rgb_plane("g", "b")
plot_pixels(ivy_oak_rgb, "g", "b", col = "#00000005")

</code></pre>

<hr>
<h2 id='plot_rgb_plane'>Plots a triangular plot to be filled with pixels and rules</h2><span id='topic+plot_rgb_plane'></span>

<h3>Description</h3>

<p>Plots the plane of the two variables selected by the user, one of (<code>r</code>,
<code>g</code> or <code>b</code>), and lines identifying the triangular area that can
contain pixels. representing the pixels of a transformed image and lines
representing the rules can be later added to the plot using functions
<code>plot_pixels()</code> and <code>plot_rule()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_rgb_plane(
  x_axis,
  y_axis,
  plot_limits = TRUE,
  plot_guides = TRUE,
  plot_grid = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_rgb_plane_+3A_x_axis">x_axis</code></td>
<td>
<p>a character string indicating which colour variable use as x,
one of <code>"r"</code>, <code>"g"</code> or <code>"b"</code>,</p>
</td></tr>
<tr><td><code id="plot_rgb_plane_+3A_y_axis">y_axis</code></td>
<td>
<p>a character string indicating which colour variable use as y.</p>
</td></tr>
<tr><td><code id="plot_rgb_plane_+3A_plot_limits">plot_limits</code></td>
<td>
<p>a logical value. When TRUE (default) the limits of the
area where the pixels can be found are plotted.</p>
</td></tr>
<tr><td><code id="plot_rgb_plane_+3A_plot_guides">plot_guides</code></td>
<td>
<p>a logical value. When TRUE (default) the limits of the
area where one variable dominates are plotted.</p>
</td></tr>
<tr><td><code id="plot_rgb_plane_+3A_plot_grid">plot_grid</code></td>
<td>
<p>a logical value; if TRUE (default) a grid is added.</p>
</td></tr>
<tr><td><code id="plot_rgb_plane_+3A_...">...</code></td>
<td>
<p>additional graphical parameters passed to the underlying
plotting functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because the variables were transformed into proportions, the pixels
are always inside the triangle defined by the points <code>(0, 0), (1, 0),
  (0, 1)</code>. This triangle is plotted in blue. The point where all three
variables have the same value is <code>(1/3, 1/3)</code>. The (red) lines joining
this point with the centres of the triangle sides divide the plot in areas
where one of the three variables has higher proportions than the other two.
Also, a standard grid can be added. All these lines are visual aids, so, if
desired, they can be eliminated using the parameters of the function.
</p>
<p>Additional graphical parameters can be passed to the underlying graphical
function to modify the appearance of the plot. Intended for passing
<code>xlim</code> and <code>ylim</code> values to plot only the part of the graph where
the points are concentrated.
</p>


<h3>Value</h3>

<p>The function does not return any value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_pixels">plot_pixels</a></code>, <code><a href="#topic+plot_rule">plot_rule</a></code>,
<code><a href="#topic+pixel_rule">pixel_rule</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simplest call
plot_rgb_plane("g", "b")

# Plane without the red lines
plot_rgb_plane("g", "b", plot_guides = FALSE)

# Restricting the plane area showed in the graph
plot_rgb_plane("g", "b", xlim = c(0.2, 0.5), ylim = c(0.0, 0.33))

</code></pre>

<hr>
<h2 id='plot_rule'>Plots the line that defines a rule</h2><span id='topic+plot_rule'></span>

<h3>Description</h3>

<p>This function draws the line that defines a rule on the plot created by
<code>plot_rgb_plane()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_rule(rule, label = "", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_rule_+3A_rule">rule</code></td>
<td>
<p>an object of class <code>"pixel_rule"</code> produced by
<code>pixel_rule()</code>.</p>
</td></tr>
<tr><td><code id="plot_rule_+3A_label">label</code></td>
<td>
<p>a string to label the line. It is attached at the coordinates of
the second point used to define the line.</p>
</td></tr>
<tr><td><code id="plot_rule_+3A_...">...</code></td>
<td>
<p>additional graphical parameters passed to the underlying graphic
functions, for example to define the line colour or dashing style.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the information stored in the <code>"pixel_rule"</code>
object to plot the line.
</p>
<p>Use the ... to set the colour and other characteristics of the line. For
colours use any character string understood by <code>col2rgb()</code>.
</p>
<p>A label can be added to the line using <code>label_rule()</code>.
</p>


<h3>Value</h3>

<p>The function does not return any value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_rgb_plane">plot_rgb_plane</a></code>, <code><a href="#topic+pixel_rule">pixel_rule</a></code>,
<code><a href="#topic+label_rule">label_rule</a></code> <code><a href="grDevices.html#topic+col2rgb">col2rgb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rule_01 &lt;- pixel_rule("rule_01", "g", "b",
                      list(c(0.345, 1/3), c(0.40, 0.10)), "&lt;")

plot_rgb_plane("g", "b")
plot_rule(rule_01, col = "green")

</code></pre>

<hr>
<h2 id='read_image'>Imports  and transforms a jpg or tiff file.</h2><span id='topic+read_image'></span><span id='topic+is.transformed_image'></span><span id='topic+summary.pixel_transformed_image'></span>

<h3>Description</h3>

<p>Imports an image file (in JPEG or TIFF format) into an array, and converts
the original <code>R</code>, <code>G</code> and <code>B</code> values in the file into
proportions (<code>r</code>, <code>g</code> and <code>b</code> variables).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_image(file_name)

is.transformed_image(x)

## S3 method for class 'pixel_transformed_image'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_image_+3A_file_name">file_name</code></td>
<td>
<p>A character string containing the name of the image file.</p>
</td></tr>
<tr><td><code id="read_image_+3A_x">x</code></td>
<td>
<p>the R object being tested</p>
</td></tr>
<tr><td><code id="read_image_+3A_object">object</code></td>
<td>
<p>an object of class <code>"pixel_transformed_image"</code>.</p>
</td></tr>
<tr><td><code id="read_image_+3A_...">...</code></td>
<td>
<p>other parameters passed to the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls the functions <code>jpeg::readJPEG()</code> or
<code>tiff::readTIFF()</code> to import the image into an R array. Then it
transforms the data into proportions
</p>


<h3>Value</h3>

<p>Returns an object of class  <code>"pixel_transformed_image"</code>, which
is an array of dimensions <code>r x c x 3</code>,  being <code>r</code> and <code>c</code>
the number of rows and columns in the image. The last dimension corresponds
to the original <code>R</code>, <code>G</code> and <code>B</code> variables (= bands) that
define the colours of the pixels. The values in the array are the
proportions of each colour (<code>r, g, b</code>), i.e. <code>r</code> = <code>R</code> /
(<code>R + G + B</code>), and so on.
</p>


<h3>See Also</h3>

<p>For more information about jpeg and tiff file formats, see the help
pages of <code><a href="jpeg.html#topic+readJPEG">readJPEG</a></code> and
<code><a href="tiff.html#topic+readTIFF">readTIFF</a></code> functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# An example that loads the example file included in the package
ivy_oak_rgb &lt;- read_image(system.file("extdata", "IvyOak400x300.JPG",
                                       package = "pixelclasser"))

</code></pre>

<hr>
<h2 id='save_classif_image'>Saves a classified image in TIFF or JPEG format</h2><span id='topic+save_classif_image'></span>

<h3>Description</h3>

<p>Creates an image file in JPEG or TIFF format from an object of class
<code>"pixel_classified_image"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_classif_image(classified_image, file_name, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="save_classif_image_+3A_classified_image">classified_image</code></td>
<td>
<p>an object of class <code>"pixel_classified_image"</code>.</p>
</td></tr>
<tr><td><code id="save_classif_image_+3A_file_name">file_name</code></td>
<td>
<p>a character string with the name of the output file,
including the extension.</p>
</td></tr>
<tr><td><code id="save_classif_image_+3A_...">...</code></td>
<td>
<p>further parameters to pass to functions <code>writeJPG</code> and
<code>writeTIFF</code>. If not used, the default values of these functions are
used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The type of the output file (JPEG or TIFF) is selected from the
extension included in the file name. It must be one of <code>("jpg", "JPG",
  "jpeg", "JPEG", "tif", "TIF", "tiff", "TIFF")</code>.
</p>
<p>Note that the default value for jpg quality is 0.7. For maximal quality set
<code>quality = 1</code> using the ... argument. Such adjustments are not
needed with <code>tiff</code> files, as this is a lossless format.
</p>


<h3>Value</h3>

<p>It does not return anything, only creates the file.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+classify_pixels">classify_pixels</a></code>
</p>
<p>For more information about the options for file formatting see see the help
pages of <code><a href="jpeg.html#topic+readJPEG">readJPEG</a></code> and <code><a href="tiff.html#topic+readTIFF">readTIFF</a></code>
functions in packages <code>jpeg</code> and <code>tiff</code>, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Saving an hypothetical image. Note the use of quality to set the
# maximum quality level in the JPEG file
save_classif_image(image01_class, "./myimages/image01_classified.jpg",
                   quality = 1)

## End(Not run)

</code></pre>

<hr>
<h2 id='transform_colours'>Transforms RGB values into proportions (rgb values)</h2><span id='topic+transform_colours'></span>

<h3>Description</h3>

<p>This function transforms an array of RGB absolute values into a similar array
containing the proportion of each band (= colour variable): r g and b.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_colours(image_array)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transform_colours_+3A_image_array">image_array</code></td>
<td>
<p>an array of class <code>image_array</code> created by function
<code>read_image()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The proportions are calculated as <code>r</code> = <code>R</code> / (<code>R + G
  + B</code>), and so on. It is used by function read_image().
</p>


<h3>Value</h3>

<p>Returns an array of class <code>transformed_image</code> containing the
proportions of each colour variable in the pixels of the image. The third
dimension of the array is named &quot;bands&quot; and its elements are labelled as
&quot;r&quot;, &quot;g&quot; and &quot;b&quot;, respectively.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
