<!DOCTYPE html><html><head><title>Help for package poppr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {poppr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#poppr-package'><p>The <span class="pkg">poppr</span> R package</p></a></li>
<li><a href='#[,bootgen,ANY,ANY,ANY-method'><p>Methods used for the bootgen object.</p></a></li>
<li><a href='#[,snpclone,ANY,ANY,ANY-method'><p>Methods used for the snpclone object</p></a></li>
<li><a href='#%&gt;%'><p>magrittr forward-pipe operator</p></a></li>
<li><a href='#aboot'><p>Calculate a dendrogram with bootstrap support using any distance applicable</p>
to genind or genclone objects.</a></li>
<li><a href='#Aeut'><p>Oomycete root rot pathogen *Aphanomyces euteiches* AFLP data</p></a></li>
<li><a href='#as.snpclone'><p>Create a snpclone object from a genlight object.</p></a></li>
<li><a href='#bitwise.dist'><p>Calculate dissimilarity or Euclidean distance for genlight objects</p></a></li>
<li><a href='#bitwise.ia'><p>Calculate the index of association between samples in a genlight object.</p></a></li>
<li><a href='#boot.ia'><p>Bootstrap the index of association</p></a></li>
<li><a href='#bootgen-class'><p>Bootgen object</p></a></li>
<li><a href='#bootgen2genind'><p>Switch between genind and genclone objects.</p></a></li>
<li><a href='#bruvo.boot'><p>Create a tree using Bruvo's Distance with non-parametric bootstrapping.</p></a></li>
<li><a href='#bruvo.dist'><p>Bruvo's distance for microsatellites</p></a></li>
<li><a href='#bruvo.msn'><p>Create minimum spanning network of selected populations using Bruvo's</p>
distance.</a></li>
<li><a href='#bruvomat-class'><p>bruvomat object</p></a></li>
<li><a href='#clonecorrect'><p>Remove potential bias caused by cloned genotypes in genind or genclone</p>
object.</a></li>
<li><a href='#cutoff_predictor'><p>Predict cutoff thresholds for use with mlg.filter</p></a></li>
<li><a href='#diss.dist'><p>Calculate a distance matrix based on relative dissimilarity</p></a></li>
<li><a href='#diversity_boot'><p>Perform a bootstrap analysis on diversity statistics</p></a></li>
<li><a href='#diversity_ci'><p>Perform bootstrap statistics, calculate, and plot confidence intervals.</p></a></li>
<li><a href='#diversity_stats'><p>Produce a table of diversity statistics</p></a></li>
<li><a href='#filter_stats'><p>Utilize all algorithms of mlg.filter</p></a></li>
<li><a href='#fix_replen'><p>Find and fix inconsistent repeat lengths</p></a></li>
<li><a href='#genclone-class'><p>GENclone and SNPclone classes</p></a></li>
<li><a href='#genind2genalex'><p>Export data from genind objects to genalex formatted \*.csv files.</p></a></li>
<li><a href='#genotype_curve'><p>Produce a genotype accumulation curve</p></a></li>
<li><a href='#getfile'><p>Get a file name and path and store them in a list.</p></a></li>
<li><a href='#greycurve'><p>Display a greyscale gradient adjusted to specific parameters</p></a></li>
<li><a href='#ia'><p>Index of Association</p></a></li>
<li><a href='#imsn'><p>Create minimum spanning networks interactively</p></a></li>
<li><a href='#incomp'><p>Check for samples that are incomparable due to missing data</p></a></li>
<li><a href='#info_table'><p>Create a table summarizing missing data or ploidy information of a genind or</p>
genclone object</a></li>
<li><a href='#informloci'><p>Remove all non-phylogentically informative loci</p></a></li>
<li><a href='#initialize,bruvomat-method'><p>Methods used for the bruvomat object.</p></a></li>
<li><a href='#initialize,genclone-method'><p>Methods used for the genclone object</p></a></li>
<li><a href='#initialize,MLG-method'><p>Methods used for MLG objects</p></a></li>
<li><a href='#is.snpclone'><p>Check for validity of a genclone or snpclone object</p></a></li>
<li><a href='#levels,MLG-method'><p>Unique and Duplicated implementations for MLG objects</p></a></li>
<li><a href='#locus_table'><p>Create a table of summary statistics per locus.</p></a></li>
<li><a href='#make_haplotypes'><p>Split samples from a genind object into pseudo-haplotypes</p></a></li>
<li><a href='#missingno'><p>Treat missing data</p></a></li>
<li><a href='#mlg'><p>Create counts, vectors, and matrices of multilocus genotypes.</p></a></li>
<li><a href='#MLG-class'><p>MLG class</p></a></li>
<li><a href='#mlg.filter'><p>MLG definitions based on genetic distance</p></a></li>
<li><a href='#mll'><p>Access and manipulate multilocus lineages.</p></a></li>
<li><a href='#mll.custom'><p>Define custom multilocus lineages</p></a></li>
<li><a href='#mll.reset'><p>Reset multilocus lineages</p></a></li>
<li><a href='#monpop'><p>Peach brown rot pathogen *Monilinia fructicola*</p></a></li>
<li><a href='#nei.dist'><p>Calculate Genetic Distance for a genind or genclone object.</p></a></li>
<li><a href='#old2new_genclone'><p>Convert an old genclone object to a new genclone object</p></a></li>
<li><a href='#partial_clone'><p>Simulated data illustrating a Minimum Spanning Network based on Bruvo's</p>
Distance</a></li>
<li><a href='#pgen'><p>Genotype Probability</p></a></li>
<li><a href='#Pinf'><p>Phytophthora infestans data from Mexico and South America.</p></a></li>
<li><a href='#plot_filter_stats'><p>Plot the results of filter_stats</p></a></li>
<li><a href='#plot_poppr_msn'><p>Plot minimum spanning networks produced in poppr.</p></a></li>
<li><a href='#poppr'><p>Produce a basic summary table for population genetic analyses.</p></a></li>
<li><a href='#poppr_has_parallel'><p>Determines whether openMP is support on this system.</p></a></li>
<li><a href='#poppr.all'><p>Process a list of files with poppr</p></a></li>
<li><a href='#poppr.amova'><p>Perform Analysis of Molecular Variance (AMOVA) on genind or genclone objects.</p></a></li>
<li><a href='#poppr.msn'><p>Create a minimum spanning network of selected populations using a distance</p>
matrix.</a></li>
<li><a href='#poppr.plot'><p>Internal function to plot the results from ia() and poppr()</p></a></li>
<li><a href='#popsub'><p>Subset data by population</p></a></li>
<li><a href='#Pram'><p>Phytophthora ramorum data from OR Forests and Nurseries (OR and CA)</p></a></li>
<li><a href='#private_alleles'><p>Tabulate alleles the occur in only one population.</p></a></li>
<li><a href='#psex'><p>Probability of encountering a genotype more than once by chance</p></a></li>
<li><a href='#rare_allele_correction'><p>Correcting rare allele frequencies</p></a></li>
<li><a href='#read.genalex'><p>Importing data from genalex formatted \*.csv files.</p></a></li>
<li><a href='#recode_polyploids'><p>Recode polyploid microsatellite data for use in frequency based statistics.</p></a></li>
<li><a href='#rraf'><p>Round Robin Allele Frequencies</p></a></li>
<li><a href='#rrmlg'><p>Round Robin Multilocus Genotypes</p></a></li>
<li><a href='#samp.ia'><p>Calculate random samples of the index of association for genlight objects.</p></a></li>
<li><a href='#shufflepop'><p>Shuffle individuals in a <code>genclone</code> or</p>
<code>genind</code> object independently over each locus.</a></li>
<li><a href='#test_replen'><p>Test repeat length consistency.</p></a></li>
<li><a href='#unique,MLG-method'><p>Unique and Duplicated implementations for MLG objects</p></a></li>
<li><a href='#upgma'><p>UPGMA</p></a></li>
<li><a href='#visible'><p>Accessors for the MLG object</p></a></li>
<li><a href='#win.ia'><p>Calculate windows of the index of association for genlight objects.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Genetic Analysis of Populations with Mixed Reproduction</td>
</tr>
<tr>
<td>Version:</td>
<td>2.9.6</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zhian N. Kamvar &lt;zkamvar@gmail.com&gt;</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://grunwaldlab.github.io/poppr/">https://grunwaldlab.github.io/poppr/</a>,
<a href="https://github.com/grunwaldlab/poppr/">https://github.com/grunwaldlab/poppr/</a>,
<a href="https://grunwaldlab.github.io/Population_Genetics_in_R/">https://grunwaldlab.github.io/Population_Genetics_in_R/</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Population genetic analyses for hierarchical analysis of partially
    clonal populations built upon the architecture of the 'adegenet' package. 
    Originally described in Kamvar, Tabima, and Grünwald (2014) 
    &lt;<a href="https://doi.org/10.7717%2Fpeerj.281">doi:10.7717/peerj.281</a>&gt; with version 2.0 described in Kamvar, Brooks, and 
    Grünwald (2015) &lt;<a href="https://doi.org/10.3389%2Ffgene.2015.00208">doi:10.3389/fgene.2015.00208</a>&gt;. </td>
</tr>
<tr>
<td>MailingList:</td>
<td>https://groups.google.com/d/forum/poppr</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/grunwaldlab/poppr/issues/">https://github.com/grunwaldlab/poppr/issues/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15.1), adegenet (&ge; 2.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, grDevices, utils, vegan, ggplot2, ape (&ge;
3.1-1), igraph (&ge; 1.0.0), methods, ade4, pegas, polysat, dplyr
(&ge; 0.4), rlang, boot, shiny, magrittr, progressr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, poweRlaw, cowplot</td>
</tr>
<tr>
<td>Config/Needs/check:</td>
<td>dbailleul/RClone</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-15 16:49:52 UTC; zhian</td>
</tr>
<tr>
<td>Author:</td>
<td>Zhian N. Kamvar <a href="https://orcid.org/0000-0003-1458-7108"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Javier F. Tabima <a href="https://orcid.org/0000-0002-3603-2691"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Sydney E. Everhart
    <a href="https://orcid.org/0000-0002-5773-1280"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb, dtc],
  Jonah C. Brooks [aut],
  Stacy A. Krueger-Hadfield
    <a href="https://orcid.org/0000-0002-7324-7448"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Erik Sotka [ctb],
  Brian J. Knaus <a href="https://orcid.org/0000-0003-1665-4343"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Patrick G. Meirmans
    <a href="https://orcid.org/0000-0002-6395-8107"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Frédéric D. Chevalier
    <a href="https://orcid.org/0000-0003-2611-8106"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  David Folarin [aut],
  Niklaus J. Grünwald
    <a href="https://orcid.org/0000-0003-1656-7602"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ths]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-15 17:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='poppr-package'>The <span class="pkg">poppr</span> R package</h2><span id='topic+poppr-package'></span>

<h3>Description</h3>

<p><span class="pkg">Poppr</span> provides tools for population genetic analysis that
include genotypic diversity measures, genetic distances with bootstrap
support, native organization and handling of population hierarchies, and
clone correction.
</p>
<p>To cite <span class="pkg">poppr</span>, please use <code>citation("poppr")</code>. When referring to
<span class="pkg">poppr</span> in your manuscript, please use lower case unless it occurs at the
beginning of a sentence.
</p>


<h3>Details</h3>

<p>This package relies on the <span class="pkg"><a href="adegenet.html#topic+adegenet.package">adegenet</a></span> package.
It is built around the <a href="adegenet.html#topic+genind-class">genind</a> and
<a href="adegenet.html#topic+genlight-class">genlight</a> object. Genind objects store genetic
information in a table of allele frequencies while genlight objects store
SNP data efficiently by packing binary allele calls into single bits.
<span class="pkg">Poppr</span> has extended these object into new objects called
<a href="#topic+genclone-class">genclone</a> and <a href="#topic+snpclone-class">snpclone</a>,
respectively. These objects are designed for analysis of clonal organisms
as they add the <strong>@mlg</strong> slot for keeping track of multilocus
genotypes and multilocus lineages.
</p>


<h4>Documentation</h4>

<p> Documentation is available for any function by
typing <code>?function_name</code> in the R console. Detailed topic explanations
live in the package vignettes:
</p>

<table>
<tr>
 <td style="text-align: left;">
<strong>Vignette</strong>              </td><td style="text-align: left;"> <strong>command</strong></td>
</tr>
<tr>
 <td style="text-align: left;">
Data import and manipulation   </td><td style="text-align: left;"> <code>vignette("poppr_manual", "poppr")</code></td>
</tr>
<tr>
 <td style="text-align: left;">
Algorithms and Equations       </td><td style="text-align: left;"> <code>vignette("algo", "poppr")</code></td>
</tr>
<tr>
 <td style="text-align: left;">
Multilocus Genotype Analysis   </td><td style="text-align: left;"> <code>vignette("mlg", "poppr")</code>
</td>
</tr>

</table>

<p>Essential functions for importing and manipulating data are detailed within
the <em>Data import and manipulation</em> vignette, details on algorithms
used in <span class="pkg">poppr</span> are within the <em>Algorithms and equations</em>
vignette, and details for working with multilocus genotypes are in
<em>Multilocus Genotype Analysis</em>.
</p>
<p>Examples of analyses are available in a primer written by Niklaus J.
Grünwald, Zhian N. Kamvar, and Sydney E.  Everhart at
<a href="https://grunwaldlab.github.io/Population_Genetics_in_R/">https://grunwaldlab.github.io/Population_Genetics_in_R/</a>.</p>



<h4>Getting help</h4>

<p> If you have a specific question or issue with
<span class="pkg">poppr</span>, feel free to contribute to the google group at
<a href="https://groups.google.com/d/forum/poppr">https://groups.google.com/d/forum/poppr</a>. If you find a bug and
are a github user, you can submit bug reports at
<a href="https://github.com/grunwaldlab/poppr/issues">https://github.com/grunwaldlab/poppr/issues</a>. Otherwise, leave a
message on the groups. Personal emails are highly discouraged as they do
not allow others to learn.</p>



<h3>Functions in <span class="pkg">poppr</span></h3>

<p>Below are descriptions and links to functions found in <span class="pkg">poppr</span>. Be
aware that all functions in <span class="pkg"><a href="adegenet.html#topic+adegenet.package">adegenet</a></span> are also
available. The functions are documented as:
</p>

<ul>
<li> <p><code>function_name()</code> (data type) - Description
</p>
</li></ul>

<p>Where &lsquo;data type&rsquo; refers to the type of data that can be used:
</p>

<table>
<tr>
 <td style="text-align: left;">
<strong>m</strong> </td><td style="text-align: left;"> a genclone or genind object </td>
</tr>
<tr>
 <td style="text-align: left;">
<strong>s</strong> </td><td style="text-align: left;"> a snpclone or genlight object </td>
</tr>
<tr>
 <td style="text-align: left;">
<strong>x</strong> </td><td style="text-align: left;"> a different data type (e.g. a matrix from <code><a href="#topic+mlg.table">mlg.table()</a></code>)
</td>
</tr>

</table>



<h3>Data import/export</h3>


<ul>
<li> <p><code><a href="#topic+getfile">getfile()</a></code> (x) - Provides a quick GUI to grab files for import
</p>
</li>
<li> <p><code><a href="#topic+read.genalex">read.genalex()</a></code> (x) - Reads GenAlEx formatted csv files to a genind object
</p>
</li>
<li> <p><code><a href="#topic+genind2genalex">genind2genalex()</a></code> (m) - Converts genind objects to GenAlEx formatted csv files
</p>
</li>
<li> <p><code><a href="#topic+genclone2genind">genclone2genind()</a></code> (m) - Removes the @mlg slot from genclone objects
</p>
</li>
<li> <p><code><a href="#topic+as.genambig">as.genambig()</a></code> (m) - Converts genind data to <span class="pkg">polysat</span>'s <a href="polysat.html#topic+genambig-class">genambig</a> data structure.
</p>
</li>
<li> <p><code><a href="#topic+bootgen2genind">bootgen2genind()</a></code> (x) - see <code><a href="#topic+aboot">aboot()</a></code> for details)
</p>
</li></ul>



<h3>Data Structures</h3>

<p>Data structures &quot;genclone&quot; (based off of adegenet's <a href="adegenet.html#topic+genind">genind</a>) and
&quot;snpclone&quot; (based off of adegenet's <a href="adegenet.html#topic+genlight">genlight</a> for large SNP data sets).
Both of these data structures are defined by the presence of an extra
MLG slot representing multilocus genotype assignments, which can be a numeric
vector or a MLG class object.
</p>

<ul>
<li> <p><a href="#topic+genclone-class">genclone</a> - Handles microsatellite, presence/absence, and small SNP data sets
</p>
</li>
<li> <p><a href="#topic+snpclone-class">snpclone</a> - Designed to handle larger binary SNP data sets.
</p>
</li>
<li> <p><a href="#topic+MLG-class">MLG</a> - An internal class holding a data frame of multilocus genotype
assignments that acts like a vector, allowing the user to easily switch
between different MLG definitions.
</p>
</li>
<li> <p><a href="#topic+bootgen-class">bootgen</a> - An internal class used explicitly for <code><a href="#topic+aboot">aboot()</a></code> that
inherits the <a href="adegenet.html#topic+virClasses">gen-class</a> virtual object. It is
designed to allow for sampling loci with replacement.
</p>
</li>
<li> <p><a href="#topic+bruvomat-class">bruvomat</a> - An internal class designed to handle bootstrapping for
Bruvo's distance where blocks of integer loci can be shuffled.
</p>
</li></ul>



<h3>Data manipulation</h3>


<ul>
<li> <p><code><a href="#topic+as.genclone">as.genclone()</a></code> (m) - Converts genind objects to genclone objects
</p>
</li>
<li> <p><code><a href="#topic+missingno">missingno()</a></code> (m) - Handles missing data
</p>
</li>
<li> <p><code><a href="#topic+clonecorrect">clonecorrect()</a></code> (m | s) - Clone-censors at a specified population hierarchy
</p>
</li>
<li> <p><code><a href="#topic+informloci">informloci()</a></code> (m) - Detects and removes phylogenetically uninformative loci
</p>
</li>
<li> <p><code><a href="#topic+popsub">popsub()</a></code> (m | s) - Subsets genind objects by population
</p>
</li>
<li> <p><code><a href="#topic+shufflepop">shufflepop()</a></code> (m) - Shuffles genotypes at each locus using four different shuffling algorithms
</p>
</li>
<li> <p><code><a href="#topic+recode_polyploids">recode_polyploids()</a></code> (m | x) - Recodes polyploid data sets with missing alleles imported as &quot;0&quot;
</p>
</li>
<li> <p><code><a href="#topic+make_haplotypes">make_haplotypes()</a></code> (m | s) - Splits data into pseudo-haplotypes. This is mainly used in AMOVA.
</p>
</li>
<li> <p><code><a href="#topic+test_replen">test_replen()</a></code> (m) - Tests for inconsistent repeat lengths in microsatellite data. For use in <code><a href="#topic+bruvo.dist">bruvo.dist()</a></code> functions.
</p>
</li>
<li> <p><code><a href="#topic+fix_replen">fix_replen()</a></code> (m) - Fixes inconsistent repeat lengths. For use in <code><a href="#topic+bruvo.dist">bruvo.dist()</a></code> functions.
</p>
</li></ul>



<h3>Genetic distances</h3>


<ul>
<li> <p><code><a href="#topic+bruvo.dist">bruvo.dist()</a></code> (m) - Bruvo's distance (see also: <code><a href="#topic+fix_replen">fix_replen()</a></code>)
</p>
</li>
<li> <p><code><a href="#topic+diss.dist">diss.dist()</a></code> (m) - Absolute genetic distance (see <code><a href="#topic+prevosti.dist">prevosti.dist()</a></code>)
</p>
</li>
<li> <p><code><a href="#topic+nei.dist">nei.dist()</a></code> (m | x) - Nei's 1978 genetic distance
</p>
</li>
<li> <p><code><a href="#topic+rogers.dist">rogers.dist()</a></code> (m | x) - Rogers' euclidean distance
</p>
</li>
<li> <p><code><a href="#topic+reynolds.dist">reynolds.dist()</a></code> (m | x) - Reynolds' coancestry distance
</p>
</li>
<li> <p><code><a href="#topic+edwards.dist">edwards.dist()</a></code> (m | x) - Edwards' angular distance
</p>
</li>
<li> <p><code><a href="#topic+prevosti.dist">prevosti.dist()</a></code> (m | x) - Prevosti's absolute genetic distance
</p>
</li>
<li> <p><code><a href="#topic+bitwise.dist">bitwise.dist()</a></code> (s) - Calculates fast pairwise distances for genlight objects.
</p>
</li></ul>



<h3>Bootstrapping</h3>


<ul>
<li> <p><code><a href="#topic+aboot">aboot()</a></code> (m | s | x) - Creates a bootstrapped dendrogram for any distance measure
</p>
</li>
<li> <p><code><a href="#topic+bruvo.boot">bruvo.boot()</a></code> (m) - Produces dendrograms with bootstrap support based on Bruvo's distance
</p>
</li>
<li> <p><code><a href="#topic+diversity_boot">diversity_boot()</a></code> (x) - Generates boostrap distributions of diversity statistics for multilocus genotypes
</p>
</li>
<li> <p><code><a href="#topic+diversity_ci">diversity_ci()</a></code> (m | s | x) - Generates confidence intervals for multilocus genotype diversity.
</p>
</li>
<li> <p><code><a href="#topic+resample.ia">resample.ia()</a></code> (m) - Calculates the index of association over subsets of data.
</p>
</li></ul>



<h3>Multilocus Genotypes</h3>


<ul>
<li> <p><code><a href="#topic+mlg">mlg()</a></code> (m | s) - Calculates the number of multilocus genotypes
</p>
</li>
<li> <p><code><a href="#topic+mll">mll()</a></code> (m | s) - Displays the current multilocus lineages (genotypes) defined.
</p>
</li>
<li> <p><code><a href="#topic+nmll">nmll()</a></code> (m | s) - Same as <code><a href="#topic+mlg">mlg()</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+mlg.crosspop">mlg.crosspop()</a></code> (m | s) - Finds all multilocus genotypes that cross populations
</p>
</li>
<li> <p><code><a href="#topic+mlg.table">mlg.table()</a></code> (m | s) - Returns a table of populations by multilocus genotypes
</p>
</li>
<li> <p><code><a href="#topic+mlg.vector">mlg.vector()</a></code> (m | s) - Returns a vector of a numeric multilocus genotype assignment for each individual
</p>
</li>
<li> <p><code><a href="#topic+mlg.id">mlg.id()</a></code> (m | s) - Finds all individuals associated with a single multilocus genotype
</p>
</li>
<li> <p><code><a href="#topic+mlg.filter">mlg.filter()</a></code> (m | s) - Collapses MLGs by genetic distance
</p>
</li>
<li> <p><code><a href="#topic+filter_stats">filter_stats()</a></code> (m | s) - Calculates mlg.filter for all algorithms and plots
</p>
</li>
<li> <p><code><a href="#topic+cutoff_predictor">cutoff_predictor()</a></code> (x) - Predicts cutoff threshold from mlg.filter.
</p>
</li>
<li> <p><code><a href="#topic+mll.custom">mll.custom()</a></code> (m | s) - Allows for the custom definition of multilocus lineages
</p>
</li>
<li> <p><code><a href="#topic+mll.levels">mll.levels()</a></code> (m | s) - Allows the user to change levels of custom MLLs.
</p>
</li>
<li> <p><code><a href="#topic+mll.reset">mll.reset()</a></code> (m | s) - Reset multilocus lineages.
</p>
</li>
<li> <p><code><a href="#topic+diversity_stats">diversity_stats()</a></code> (x) - Creates a table of diversity indices for multilocus genotypes.
</p>
</li></ul>



<h3>Index of Association Analysis</h3>

<p>Analysis of multilocus linkage disequilibrium.
</p>

<ul>
<li> <p><code><a href="#topic+ia">ia()</a></code> (m) - Calculates the index of association
</p>
</li>
<li> <p><code><a href="#topic+pair.ia">pair.ia()</a></code> (m) - Calculates the index of association for all loci pairs.
</p>
</li>
<li> <p><code><a href="#topic+win.ia">win.ia()</a></code> (s) - Index of association windows for genlight objects.
</p>
</li>
<li> <p><code><a href="#topic+samp.ia">samp.ia()</a></code> (s) - Index of association on random subsets of loci for genlight objects.
</p>
</li></ul>



<h3>Population Genetic Analysis</h3>


<ul>
<li> <p><code><a href="#topic+poppr.amova">poppr.amova()</a></code> (m | s) - Analysis of Molecular Variance (as implemented in ade4)
</p>
</li>
<li> <p><code><a href="#topic+poppr">poppr()</a></code> (m | x) - Returns a diversity table by population
</p>
</li>
<li> <p><code><a href="#topic+poppr.all">poppr.all()</a></code> (m | x) - Returns a diversity table by population for all compatible files specified
</p>
</li>
<li> <p><code><a href="#topic+private_alleles">private_alleles()</a></code> (m) - Tabulates the occurrences of alleles that only occur in one population.
</p>
</li>
<li> <p><code><a href="#topic+locus_table">locus_table()</a></code> (m) - Creates a table of summary statistics per locus.
</p>
</li>
<li> <p><code><a href="#topic+rrmlg">rrmlg()</a></code> (m | x) - Round-robin multilocus genotype estimates.
</p>
</li>
<li> <p><code><a href="#topic+rraf">rraf()</a></code> (m) - Round-robin allele frequency estimates.
</p>
</li>
<li> <p><code><a href="#topic+pgen">pgen()</a></code> (m) - Probability of genotypes.
</p>
</li>
<li> <p><code><a href="#topic+psex">psex()</a></code> (m) - Probability of observing a genotype more than once.
</p>
</li>
<li> <p><a href="#topic+rare_allele_correction">rare_allele_correction</a> (m) - rules for correcting rare alleles for round-robin estimates.
</p>
</li>
<li> <p><code><a href="#topic+incomp">incomp()</a></code> (m) - Check data for incomparable samples.
</p>
</li></ul>



<h3>Visualization</h3>


<ul>
<li> <p><code><a href="#topic+imsn">imsn()</a></code> (m | s) - Interactive construction and visualization of minimum spanning networks
</p>
</li>
<li> <p><code><a href="#topic+plot_poppr_msn">plot_poppr_msn()</a></code> (m | s | x) - Plots minimum spanning networks produced in poppr with scale bar and legend
</p>
</li>
<li> <p><code><a href="#topic+greycurve">greycurve()</a></code> (x) - Helper to determine the appropriate parameters for adjusting the grey level for msn functions
</p>
</li>
<li> <p><code><a href="#topic+bruvo.msn">bruvo.msn()</a></code> (m) - Produces minimum spanning networks based off Bruvo's distance colored by population
</p>
</li>
<li> <p><code><a href="#topic+poppr.msn">poppr.msn()</a></code> (m | s | x) - Produces a minimum spanning network for any pairwise distance matrix related to the data
</p>
</li>
<li> <p><code><a href="#topic+info_table">info_table()</a></code> (m) - Creates a heatmap representing missing data or observed ploidy
</p>
</li>
<li> <p><code><a href="#topic+genotype_curve">genotype_curve()</a></code> (m | x) - Creates a series of boxplots to demonstrate how many markers are needed to represent the diversity of your data.
</p>
</li></ul>



<h3>Datasets</h3>


<ul>
<li> <p><code><a href="#topic+Aeut">Aeut()</a></code> - (AFLP) Oomycete root rot pathogen <em>Aphanomyces euteiches</em> (Grünwald and Hoheisel, 2006)
</p>
</li>
<li> <p><code><a href="#topic+monpop">monpop()</a></code> - (SSR) Peach brown rot pathogen <em>Monilinia fructicola</em> (Everhart and Scherm, 2015)
</p>
</li>
<li> <p><code><a href="#topic+partial_clone">partial_clone()</a></code> - (SSR) partially-clonal data simulated via simuPOP (Peng and Amos, 2008)
</p>
</li>
<li> <p><code><a href="#topic+Pinf">Pinf()</a></code> - (SSR) Potato late blight pathogen <em>Phytophthora infestans</em> (Goss et. al., 2014)
</p>
</li>
<li> <p><code><a href="#topic+Pram">Pram()</a></code> - (SSR) Sudden Oak Death pathogen <em>Phytophthora ramorum</em> (Kamvar et. al., 2015; Goss et. al., 2009)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Zhian N. Kamvar, Jonah C. Brooks, Sydney E. Everhart, Javier F.
Tabima, Stacy Krueger-Hadfield, Erik Sotka, Niklaus J. Grünwald
</p>
<p>Maintainer: Zhian N. Kamvar
</p>


<h3>References</h3>

<p>&mdash;&mdash;&mdash; Papers announcing poppr &mdash;&mdash;&mdash;
</p>
<p>Kamvar ZN, Tabima JF, Grünwald NJ. (2014) Poppr: an R package for genetic
analysis of populations with clonal, partially clonal, and/or sexual
reproduction. PeerJ 2:e281 <a href="https://doi.org/10.7717/peerj.281">doi:10.7717/peerj.281</a>
</p>
<p>Kamvar ZN, Brooks JC and Grünwald NJ (2015) Novel R tools for analysis of
genome-wide population genetic data with emphasis on clonality. Front. Genet.
6:208. <a href="https://doi.org/10.3389/fgene.2015.00208">doi:10.3389/fgene.2015.00208</a>
</p>
<p>&mdash;&mdash;&mdash; Papers referencing data sets &mdash;&mdash;&mdash;
</p>
<p>Grünwald, NJ and Hoheisel, G.A. 2006. Hierarchical Analysis of Diversity,
Selfing, and Genetic Differentiation in Populations of the Oomycete
<em>Aphanomyces euteiches</em>. Phytopathology 96:1134-1141 doi:
<a href="https://doi.org/10.1094/PHYTO-96-1134">doi:10.1094/PHYTO-96-1134</a>
</p>
<p>SE Everhart, H Scherm, (2015) Fine-scale genetic structure of <em>Monilinia
fructicola</em> during brown rot epidemics within individual peach tree canopies.
Phytopathology 105:542-549 doi:
<a href="https://doi.org/10.1094/PHYTO-03-14-0088-R">doi:10.1094/PHYTO-03-14-0088-R</a>
</p>
<p>Bo Peng and Christopher Amos (2008) Forward-time simulations of nonrandom
mating populations using simuPOP. <em>bioinformatics</em>, 24 (11): 1408-1409.
</p>
<p>Goss, Erica M., Javier F. Tabima, David EL Cooke, Silvia Restrepo, William E.
Fry, Gregory A. Forbes, Valerie J. Fieland, Martha Cardenas, and Niklaus J.
Grünwald. (2014) &quot;The Irish potato famine pathogen <em>Phytophthora
infestans</em> originated in central Mexico rather than the Andes.&quot; Proceedings
of the National Academy of Sciences 111:8791-8796. doi:
<a href="https://doi.org/10.1073/pnas.1401884111">doi:10.1073/pnas.1401884111</a>
</p>
<p>Kamvar, Z. N., Larsen, M. M., Kanaskie, A. M., Hansen, E. M., &amp; Grünwald, N.
J. (2015). Spatial and temporal analysis of populations of the sudden oak
death pathogen in Oregon forests. Phytopathology 105:982-989. doi:
<a href="https://doi.org/10.1094/PHYTO-12-14-0350-FI">doi:10.1094/PHYTO-12-14-0350-FI</a>
</p>
<p>Goss, E. M., Larsen, M., Chastagner, G. A., Givens, D. R., and Grünwald, N.
J. 2009. Population genetic analysis infers migration pathways of
<em>Phytophthora ramorum</em> in US nurseries. PLoS Pathog. 5:e1000583. doi:
<a href="https://doi.org/10.1371/journal.ppat.1000583">doi:10.1371/journal.ppat.1000583</a>
</p>

<hr>
<h2 id='+5B+2Cbootgen+2CANY+2CANY+2CANY-method'>Methods used for the bootgen object.</h2><span id='topic++5B+2Cbootgen+2CANY+2CANY+2CANY-method'></span><span id='topic+dim+2Cbootgen-method'></span><span id='topic++24+2Cbootgen-method'></span><span id='topic+initialize+2Cbootgen-method'></span>

<h3>Description</h3>

<p>This is not designed for user interaction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'bootgen,ANY,ANY,ANY'
x[i, j, ..., drop = FALSE]

## S4 method for signature 'bootgen'
dim(x)

## S4 method for signature 'bootgen'
x$name

## S4 method for signature 'bootgen'
initialize(.Object, gen, na = "mean", freq = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B2Cbootgen+2B2CANY+2B2CANY+2B2CANY-method_+3A_x">x</code></td>
<td>
<p>a <code>"<a href="#topic+bootgen-class">bootgen</a>"</code> object</p>
</td></tr>
<tr><td><code id="+2B5B+2B2Cbootgen+2B2CANY+2B2CANY+2B2CANY-method_+3A_i">i</code></td>
<td>
<p>vector of numerics indicating number of individuals desired</p>
</td></tr>
<tr><td><code id="+2B5B+2B2Cbootgen+2B2CANY+2B2CANY+2B2CANY-method_+3A_j">j</code></td>
<td>
<p>a vector of numerics corresponding to the loci desired.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2Cbootgen+2B2CANY+2B2CANY+2B2CANY-method_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2Cbootgen+2B2CANY+2B2CANY+2B2CANY-method_+3A_drop">drop</code></td>
<td>
<p>set to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="+2B5B+2B2Cbootgen+2B2CANY+2B2CANY+2B2CANY-method_+3A_.object">.Object</code></td>
<td>
<p>a character, &quot;bootgen&quot;</p>
</td></tr>
<tr><td><code id="+2B5B+2B2Cbootgen+2B2CANY+2B2CANY+2B2CANY-method_+3A_gen">gen</code></td>
<td>
<p>a genind, genclone, or genpop object</p>
</td></tr>
<tr><td><code id="+2B5B+2B2Cbootgen+2B2CANY+2B2CANY+2B2CANY-method_+3A_na">na</code></td>
<td>
<p>how missing data should be treated. Default is &quot;mean&quot;, averaging 
over other values in the matrix. Possible values are listed in 
<code><a href="adegenet.html#topic+tab">tab</a></code>.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2Cbootgen+2B2CANY+2B2CANY+2B2CANY-method_+3A_freq">freq</code></td>
<td>
<p>if <code>TRUE</code>, the matrix will be a genotype frequency matrix.
If <code>FALSE</code>, the matrix will be allele counts.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>

<hr>
<h2 id='+5B+2Csnpclone+2CANY+2CANY+2CANY-method'>Methods used for the snpclone object</h2><span id='topic++5B+2Csnpclone+2CANY+2CANY+2CANY-method'></span><span id='topic+initialize+2Csnpclone-method'></span><span id='topic+show+2Csnpclone-method'></span>

<h3>Description</h3>

<p>Default methods for subsetting snpclone objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'snpclone,ANY,ANY,ANY'
x[i, j, ..., mlg.reset = FALSE, drop = FALSE]

## S4 method for signature 'snpclone'
initialize(.Object, ..., mlg, mlgclass = TRUE)

## S4 method for signature 'snpclone'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B2Csnpclone+2B2CANY+2B2CANY+2B2CANY-method_+3A_x">x</code></td>
<td>
<p>a snpclone object</p>
</td></tr>
<tr><td><code id="+2B5B+2B2Csnpclone+2B2CANY+2B2CANY+2B2CANY-method_+3A_i">i</code></td>
<td>
<p>vector of numerics indicating number of individuals desired</p>
</td></tr>
<tr><td><code id="+2B5B+2B2Csnpclone+2B2CANY+2B2CANY+2B2CANY-method_+3A_j">j</code></td>
<td>
<p>a vector of numerics corresponding to the loci desired.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2Csnpclone+2B2CANY+2B2CANY+2B2CANY-method_+3A_...">...</code></td>
<td>
<p>passed on to the <code><a href="adegenet.html#topic+genlight-class">genlight</a></code> object.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2Csnpclone+2B2CANY+2B2CANY+2B2CANY-method_+3A_mlg.reset">mlg.reset</code></td>
<td>
<p>logical. Defaults to <code>FALSE</code>. If <code>TRUE</code>, the mlg
vector will be reset</p>
</td></tr>
<tr><td><code id="+2B5B+2B2Csnpclone+2B2CANY+2B2CANY+2B2CANY-method_+3A_drop">drop</code></td>
<td>
<p>set to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="+2B5B+2B2Csnpclone+2B2CANY+2B2CANY+2B2CANY-method_+3A_.object">.Object</code></td>
<td>
<p>a character, &quot;snpclone&quot;</p>
</td></tr>
<tr><td><code id="+2B5B+2B2Csnpclone+2B2CANY+2B2CANY+2B2CANY-method_+3A_mlg">mlg</code></td>
<td>
<p>a vector where each element assigns the multilocus genotype of
that individual in the data set.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2Csnpclone+2B2CANY+2B2CANY+2B2CANY-method_+3A_mlgclass">mlgclass</code></td>
<td>
<p>a logical value specifying whether or not to translate the
mlg object into an MLG class object.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2Csnpclone+2B2CANY+2B2CANY+2B2CANY-method_+3A_object">object</code></td>
<td>
<p>a snpclone object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>

<hr>
<h2 id='+25+26gt+3B+25'>magrittr forward-pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>magrittr forward-pipe operator
</p>

<hr>
<h2 id='aboot'>Calculate a dendrogram with bootstrap support using any distance applicable
to genind or genclone objects.</h2><span id='topic+aboot'></span><span id='topic+bootstrap'></span>

<h3>Description</h3>

<p>Calculate a dendrogram with bootstrap support using any distance applicable
to genind or genclone objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aboot(
  x,
  strata = NULL,
  tree = "upgma",
  distance = "nei.dist",
  sample = 100,
  cutoff = 0,
  showtree = TRUE,
  missing = "mean",
  mcutoff = 0,
  quiet = FALSE,
  root = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aboot_+3A_x">x</code></td>
<td>
<p>a <a href="adegenet.html#topic+genind">genind-class</a>, <a href="adegenet.html#topic+genpop">genpop-class</a>,
<a href="#topic+genclone">genclone-class</a>, <a href="adegenet.html#topic+genlight-class">genlight</a>, <a href="#topic+snpclone-class">snpclone</a> or
<a href="base.html#topic+matrix">matrix</a> object.</p>
</td></tr>
<tr><td><code id="aboot_+3A_strata">strata</code></td>
<td>
<p>a formula specifying the strata to be used to convert x to a
genclone object if x is a genind object. Defaults to <code>NULL</code>. See details.</p>
</td></tr>
<tr><td><code id="aboot_+3A_tree">tree</code></td>
<td>
<p>a text string or function that can calculate a tree from a
distance matrix. Defaults to &quot;upgma&quot;. Note that you must load the package
with the function for it to work.</p>
</td></tr>
<tr><td><code id="aboot_+3A_distance">distance</code></td>
<td>
<p>a character or function defining the distance to be applied
to x. Defaults to <code><a href="#topic+nei.dist">nei.dist()</a></code>.</p>
</td></tr>
<tr><td><code id="aboot_+3A_sample">sample</code></td>
<td>
<p>An integer representing the number of bootstrap replicates
Default is 100.</p>
</td></tr>
<tr><td><code id="aboot_+3A_cutoff">cutoff</code></td>
<td>
<p>An integer from 0 to 100 setting the cutoff value to return the
bootstrap values on the nodes. Default is 0.</p>
</td></tr>
<tr><td><code id="aboot_+3A_showtree">showtree</code></td>
<td>
<p>If <code>TRUE</code> (Default), a dendrogram will be plotted. If
<code>FALSE</code>, nothing will be plotted.</p>
</td></tr>
<tr><td><code id="aboot_+3A_missing">missing</code></td>
<td>
<p>any method to be used by <code><a href="#topic+missingno">missingno()</a></code>: &quot;mean&quot;
(default), &quot;zero&quot;, &quot;loci&quot;, &quot;genotype&quot;, or &quot;ignore&quot;.</p>
</td></tr>
<tr><td><code id="aboot_+3A_mcutoff">mcutoff</code></td>
<td>
<p>a value between 0 (default) and 1 defining the percentage of
tolerable missing data if the <code>missing</code> parameter is set to &quot;loci&quot; or
&quot;genotype&quot;. This should only be set if the distance metric can handle
missing data.</p>
</td></tr>
<tr><td><code id="aboot_+3A_quiet">quiet</code></td>
<td>
<p>if <code>FALSE</code> (default), a progress bar will be printed to
screen.</p>
</td></tr>
<tr><td><code id="aboot_+3A_root">root</code></td>
<td>
<p>is the tree rooted? This is a parameter passed off to
<code><a href="ape.html#topic+boot.phylo">ape::boot.phylo()</a></code>. If the <code>tree</code> parameter returns a
rooted tree (like UPGMA), this should be <code>TRUE</code>, otherwise (like
neighbor-joining), it should be false. When set to <code>NULL</code> (default),
the tree is considered rooted if <code><a href="ape.html#topic+is.ultrametric">ape::is.ultrametric()</a></code> is true.</p>
</td></tr>
<tr><td><code id="aboot_+3A_...">...</code></td>
<td>
<p>any parameters to be passed off to the distance method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function automates the process of bootstrapping genetic data to
create a dendrogram with bootstrap support on the nodes. It will randomly
sample with replacement the loci of a <code>gen</code> (genind/genpop) object or the columns of a
numeric matrix, <strong>assuming that all loci/columns are independent</strong>. The
process of randomly sampling <code>gen</code> objects with replacement is carried out
through the use of an internal class called
<a href="#topic+bootgen-class">bootgen</a>. This is necessary due to the fact that columns in
the genind matrix are defined as alleles and are thus interrelated. This
function will specifically bootstrap loci so that results are biologically
relevant. With this function, the user can also define a custom distance to
be performed on the genind or genclone object. If you have a data frame-like
object where all of the columns are independent or pairs of columns are
independent, then it may be simpler to use <code><a href="ape.html#topic+boot.phylo">ape::boot.phylo()</a></code> to calculate
your bootstrap support values.
</p>


<h4>the strata argument</h4>

<p>There is an argument called <code>strata</code>. This argument is useful for when
you want to bootstrap by populations from a <code><a href="adegenet.html#topic+new.genind">adegenet::genind()</a></code>
object. When you specify strata, the genind object will be converted to
<code><a href="adegenet.html#topic+new.genpop">adegenet::genpop()</a></code> with the specified strata.
</p>



<h3>Value</h3>

<p>an object of class <code><a href="ape.html#topic+read.tree">ape::phylo()</a></code>.
</p>


<h3>Note</h3>

<p><code><a href="#topic+prevosti.dist">prevosti.dist()</a></code> and <code><a href="#topic+diss.dist">diss.dist()</a></code> are exactly the
same, but <code><a href="#topic+diss.dist">diss.dist()</a></code> scales better for large numbers of
individuals (n &gt; 125) at the cost of required memory.
</p>


<h4>missing data</h4>

<p>Missing data is not allowed by many of the distances. Thus, one of
the first steps of this function is to treat missing data by setting it to
the average allele frequency in the data set. If you are using a distance
that can handle missing data (Prevosti's distance), you can set
<code>missing = "ignore"</code> to allow the distance function to handle any
missing data. See <code><a href="#topic+missingno">missingno()</a></code> for details on missing
data.</p>



<h4>Bruvo's Distance</h4>

<p>While calculation of Bruvo's distance
is possible with this function, it is optimized in the function
<code><a href="#topic+bruvo.boot">bruvo.boot()</a></code>.</p>



<h3>References</h3>

<p>Kamvar ZN, Brooks JC and Grünwald NJ (2015) Novel R tools for analysis of
genome-wide population genetic data with emphasis on clonality.
Frontiers in Genetics 6:208. <a href="https://doi.org/10.3389/fgene.2015.00208">doi:10.3389/fgene.2015.00208</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nei.dist">nei.dist()</a></code> <code><a href="#topic+edwards.dist">edwards.dist()</a></code>
<code><a href="#topic+rogers.dist">rogers.dist()</a></code> <code><a href="#topic+reynolds.dist">reynolds.dist()</a></code>
<code><a href="#topic+prevosti.dist">prevosti.dist()</a></code> <code><a href="#topic+diss.dist">diss.dist()</a></code>
<code><a href="#topic+bruvo.boot">bruvo.boot()</a></code> <code><a href="ape.html#topic+boot.phylo">ape::boot.phylo()</a></code>
<code><a href="adegenet.html#topic+dist.genpop">adegenet::dist.genpop()</a></code> <code><a href="stats.html#topic+dist">dist()</a></code>
<code><a href="#topic+bootgen2genind">bootgen2genind()</a></code> <a href="#topic+bootgen-class">bootgen</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(nancycats)
nan9 &lt;- popsub(nancycats, 9)

set.seed(9999)
# Generate a tree using nei's distance
neinan &lt;- aboot(nan9, dist = nei.dist)

set.seed(9999)
# Generate a tree using custom distance
bindist &lt;- function(x) dist(tab(x), method = "binary")
binnan &lt;- aboot(nan9, dist = bindist)

## Not run: 
# Distances from other packages.
#
# Sometimes, distance functions from other packages will have the constraint
# that the incoming data MUST be genind. Internally, aboot uses the 
# bootgen class ( class?bootgen ) to shuffle loci, and will throw an error
# The function bootgen2genind helps fix that. Here's an example of a function
# that expects a genind class from above
bindist &lt;- function(x){
  stopifnot(is.genind(x))
  dist(tab(x), method = "binary")
}
#
# Fails:
# aboot(nan9, dist = bindist)
## Error: is.genind(x) is not TRUE
#
# Add bootgen2genind to get it working!
# Works:
aboot(nan9, dist = function(x) bootgen2genind(x) %&gt;% bindist)

# AFLP data
data(Aeut)

# Nei's distance
anei &lt;- aboot(Aeut, dist = nei.dist, sample = 1000, cutoff = 50)

# Rogers' distance
arog &lt;- aboot(Aeut, dist = rogers.dist, sample = 1000, cutoff = 50)

# This can also be run on genpop objects
strata(Aeut) &lt;- other(Aeut)$population_hierarchy[-1]
Aeut.gc &lt;- as.genclone(Aeut)
setPop(Aeut.gc) &lt;- ~Pop/Subpop
Aeut.pop &lt;- genind2genpop(Aeut.gc)
set.seed(5000)
aboot(Aeut.pop, sample = 1000) # compare to Grunwald et al. 2006

# You can also use the strata argument to convert to genpop inside the function.
set.seed(5000)
aboot(Aeut.gc, strata = ~Pop/Subpop, sample = 1000)

# And genlight objects 
# From glSim:
## 1,000 non structured SNPs, 100 structured SNPs
x &lt;- glSim(100, 1e3, n.snp.struc=100, ploid=2)
aboot(x, distance = bitwise.dist)

# Utilizing other tree methods

library("ape")

aboot(Aeut.pop, tree = fastme.bal, sample = 1000)

# Utilizing options in other tree methods

myFastME &lt;- function(x) fastme.bal(x, nni = TRUE, spr = FALSE, tbr = TRUE)
aboot(Aeut.pop, tree = myFastME, sample = 1000)


## End(Not run)
</code></pre>

<hr>
<h2 id='Aeut'>Oomycete root rot pathogen *Aphanomyces euteiches* AFLP data</h2><span id='topic+Aeut'></span>

<h3>Description</h3>

<p>The Aeut dataset consists of 187 isolates of the Oomycete root 
rot pathogen, *Aphanomyces euteiches* collected from two different 
fields in NW Oregon and W Washington, USA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Aeut)
</code></pre>


<h3>Format</h3>

<p>a [genind()] object with two populations containing a data
frame in the 'other' slot called 'population_hierarchy'. This
data frame gives indices of the populations and subpopulations for the data
set.
</p>


<h3>References</h3>

<p>Grunwald, NJ and Hoheisel, G.A. 2006. Hierarchical Analysis of
Diversity, Selfing, and Genetic Differentiation in Populations of the 
Oomycete *Aphanomyces euteiches*. Phytopathology 96:1134-1141
doi: <a href="https://doi.org/10.1094/PHYTO-96-1134">doi:10.1094/PHYTO-96-1134</a>
</p>

<hr>
<h2 id='as.snpclone'>Create a snpclone object from a genlight object.</h2><span id='topic+as.snpclone'></span><span id='topic+as.snpclone+2Cgenlight-method'></span>

<h3>Description</h3>

<p>Wrapper for snpclone initializer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.snpclone(x, ..., parallel = FALSE, n.cores = NULL, mlg, mlgclass = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.snpclone_+3A_x">x</code></td>
<td>
<p>a <code><a href="adegenet.html#topic+genlight-class">genlight</a></code> or <code><a href="#topic+snpclone-class">snpclone</a></code> 
object</p>
</td></tr>
<tr><td><code id="as.snpclone_+3A_...">...</code></td>
<td>
<p>arguments to be passed on to the genlight constructor. These are
not used if x is not missing.</p>
</td></tr>
<tr><td><code id="as.snpclone_+3A_parallel">parallel</code></td>
<td>
<p>should the parallel package be used to construct the object?</p>
</td></tr>
<tr><td><code id="as.snpclone_+3A_n.cores">n.cores</code></td>
<td>
<p>how many cores should be utilized? See documentation for
<code><a href="adegenet.html#topic+genlight-class">genlight</a></code> for details.</p>
</td></tr>
<tr><td><code id="as.snpclone_+3A_mlg">mlg</code></td>
<td>
<p>a vector of multilocus genotypes or an object of class MLG for the
new snpclone object.</p>
</td></tr>
<tr><td><code id="as.snpclone_+3A_mlgclass">mlgclass</code></td>
<td>
<p>if <code>TRUE</code> (default), the multilocus genotypes will be
represented as an <code><a href="#topic+MLG-class">MLG</a></code> object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(x &lt;- as.snpclone(glSim(100, 1e3, ploid=2)))
## Not run: 
# Without parallel processing
system.time(x &lt;- as.snpclone(glSim(1000, 1e5, ploid=2)))

# With parallel processing... doesn't really save you much time.
system.time(x &lt;- as.snpclone(glSim(1000, 1e5, ploid=2, parallel = TRUE), 
                             parallel = TRUE))

## End(Not run)

</code></pre>

<hr>
<h2 id='bitwise.dist'>Calculate dissimilarity or Euclidean distance for genlight objects</h2><span id='topic+bitwise.dist'></span>

<h3>Description</h3>

<p>This function calculates both dissimilarity and Euclidean distances for
<a href="adegenet.html#topic+genlight-class">genlight</a> or <a href="#topic+snpclone-class">snpclone</a> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bitwise.dist(
  x,
  percent = TRUE,
  mat = FALSE,
  missing_match = TRUE,
  scale_missing = FALSE,
  euclidean = FALSE,
  differences_only = FALSE,
  threads = 0L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bitwise.dist_+3A_x">x</code></td>
<td>
<p>a <a href="adegenet.html#topic+genlight-class">genlight</a> or <a href="#topic+snpclone-class">snpclone</a> object.</p>
</td></tr>
<tr><td><code id="bitwise.dist_+3A_percent">percent</code></td>
<td>
<p><code>logical</code>. Should the distance be represented from 0 to
1? Default set to <code>TRUE</code>. <code>FALSE</code> will return the distance
represented as integers from 1 to n where n is the number of loci.
This option has no effect if <code>euclidean = TRUE</code></p>
</td></tr>
<tr><td><code id="bitwise.dist_+3A_mat">mat</code></td>
<td>
<p><code>logical</code>. Return a matrix object. Default set to
<code>FALSE</code>, returning a dist object. <code>TRUE</code> returns a matrix object.</p>
</td></tr>
<tr><td><code id="bitwise.dist_+3A_missing_match">missing_match</code></td>
<td>
<p><code>logical</code>. Determines whether two samples differing
by missing data in a location should be counted as matching at that
location. Default set to <code>TRUE</code>, which forces missing data to match
with anything. <code>FALSE</code> forces missing data to not match with any other
information, <strong>including other missing data</strong>.</p>
</td></tr>
<tr><td><code id="bitwise.dist_+3A_scale_missing">scale_missing</code></td>
<td>
<p>A logical. If <code>TRUE</code>, comparisons with missing
data is scaled up proportionally to the number of columns used by
multiplying the value by <code>m / (m - x)</code> where m is the number of
loci and x is the number of missing sites. This option matches the behavior
of base R's <code><a href="stats.html#topic+dist">dist()</a></code> function.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bitwise.dist_+3A_euclidean">euclidean</code></td>
<td>
<p><code>logical</code>. if <code>TRUE</code>, the Euclidean distance will
be calculated.</p>
</td></tr>
<tr><td><code id="bitwise.dist_+3A_differences_only">differences_only</code></td>
<td>
<p><code>logical</code>. When <code>differences_only = TRUE</code>,
the output will reflect the number of different loci. The default setting,
<code>differences_only = FALSE</code>, reflects the number of different alleles.
Note: this has no effect on haploid organisms since 1 locus = 1 allele.
This option is NOT recommended.</p>
</td></tr>
<tr><td><code id="bitwise.dist_+3A_threads">threads</code></td>
<td>
<p>The maximum number of parallel threads to be used within this
function. A value of 0 (default) will attempt to use as many threads as
there are available cores/CPUs. In most cases this is ideal. A value of 1
will force the function to run serially, which may increase stability on
some systems. Other values may be specified, but should be used with
caution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default distance calculated here is quite simple and goes by
many names depending on its application. The most familiar name might be
the Hamming distance, or the number of differences between two strings.
</p>
<p>As of poppr version 2.8.0, this function now also calculates Euclidean
distance and is considerably faster and more memory-efficient than the
standard <code>dist()</code> function.
</p>


<h3>Value</h3>

<p>A dist object containing pairwise distances between samples.
</p>


<h3>Note</h3>

<p>This function is optimized for <a href="adegenet.html#topic+genlight-class">genlight</a> and
<a href="#topic+snpclone-class">snpclone</a> objects. This does not mean that it is a
catch-all optimization for SNP data. Three assumptions must be met for this
function to work:
</p>

<ol>
<li><p> SNPs are bi-allelic
</p>
</li>
<li><p> Samples are haploid or diploid
</p>
</li>
<li><p> All samples have the same ploidy
</p>
</li></ol>

<p>If the user supplies a <a href="adegenet.html#topic+genind-class">genind</a> or
<a href="#topic+genclone-class">genclone</a> object, <code><a href="#topic+prevosti.dist">prevosti.dist()</a></code> will be used for
calculation.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar, Jonah C. Brooks
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diss.dist">diss.dist()</a></code>, <a href="#topic+snpclone-class">snpclone</a>,
<a href="adegenet.html#topic+genlight-class">genlight</a>, <code><a href="#topic+win.ia">win.ia()</a></code>,  <code><a href="#topic+samp.ia">samp.ia()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(999)
x &lt;- glSim(n.ind = 10, n.snp.nonstruc = 5e2, n.snp.struc = 5e2, ploidy = 2)
x
# Assess fraction of different alleles
system.time(xd &lt;- bitwise.dist(x, threads = 1L))
xd

# Calculate Euclidean distance
system.time(xdt &lt;- bitwise.dist(x, euclidean = TRUE, scale_missing = TRUE, threads = 1L))
xdt

## Not run: 

# This function is more efficient in both memory and speed than [dist()] for
# calculating Euclidean distance on genlight objects. For example, we can
# observe a clear speed increase when we attempt a calculation on 100k SNPs
# with 10% missing data:

set.seed(999)
mat &lt;- matrix(sample(c(0:2, NA), 
                     100000 * 50, 
                     replace = TRUE, 
                     prob = c(0.3, 0.3, 0.3, 0.1)),
              nrow = 50)
glite &lt;- new("genlight", mat, ploidy = 2)

# Default Euclidean distance 
system.time(dist(glite))

# Bitwise dist
system.time(bitwise.dist(glite, euclidean = TRUE, scale_missing = TRUE))


## End(Not run)
</code></pre>

<hr>
<h2 id='bitwise.ia'>Calculate the index of association between samples in a genlight object.</h2><span id='topic+bitwise.ia'></span>

<h3>Description</h3>

<p>This function parses over a genlight object to calculate and return the index
of association for those samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bitwise.ia(x, missing_match = TRUE, differences_only = FALSE, threads = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bitwise.ia_+3A_x">x</code></td>
<td>
<p>a <a href="adegenet.html#topic+genlight-class">genlight</a> or <a href="#topic+snpclone-class">snpclone</a> object.</p>
</td></tr>
<tr><td><code id="bitwise.ia_+3A_missing_match">missing_match</code></td>
<td>
<p>a boolean determining whether missing data should be
considered a match. If TRUE (default) missing data at a locus will match
with any data at that locus in each comparison. If FALSE, missing data at a
locus will cause all comparisons to return the maximum possible distance at
that locus (ie, if sample 1 has missing data at locus 1, and sample 2 is
heterozygous at locus 1, the distance at that locus will be 1. If sample 2
was heterozygous or missing at locus 1, the distance would be 2.</p>
</td></tr>
<tr><td><code id="bitwise.ia_+3A_differences_only">differences_only</code></td>
<td>
<p>a boolean determining how distance should be counted
for diploids. Whether TRUE or FALSE the distance between a heterozygous
locus and a homozygous locus is 1. If FALSE (default) the distance between
opposite homozygous loci is 2. If TRUE that distance counts as 1,
indicating only that the two samples differ at that locus.</p>
</td></tr>
<tr><td><code id="bitwise.ia_+3A_threads">threads</code></td>
<td>
<p>The maximum number of parallel threads to be used within this
function. A value of 0 (default) will attempt to use as many threads as
there are available cores/CPUs. In most cases this is ideal. A value of 1
will force the function to run serially, which may increase stability on
some systems. Other values may be specified, but should be used with
caution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Index of association representing the samples in this genlight
object.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar, Jonah C. Brooks
</p>


<h3>See Also</h3>

<p><code><a href="#topic+win.ia">win.ia()</a></code>, <code><a href="#topic+samp.ia">samp.ia()</a></code>
</p>

<hr>
<h2 id='boot.ia'>Bootstrap the index of association</h2><span id='topic+boot.ia'></span>

<h3>Description</h3>

<p>This function will perform the index of association on a bootstrapped data
set multiple times to create a distribution, showing the variation of the
index due to repeat observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.ia(gid, how = "partial", reps = 999, quiet = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.ia_+3A_gid">gid</code></td>
<td>
<p>a genind or genclone object</p>
</td></tr>
<tr><td><code id="boot.ia_+3A_how">how</code></td>
<td>
<p>method of bootstrap. The default <code>how = "partial"</code> will include
all the unique genotypes and sample with replacement from the unique
genotypes until the total number of individuals has been reached. Using
<code>how = "full"</code> will randomly sample with replacement from the data as it
is. Using <code>how = "psex"</code> will sample from the full data set after first
weighting the samples via the probability of encountering the nth occurence
of a particular multilocus genotype. See <code><a href="#topic+psex">psex()</a></code> for details.</p>
</td></tr>
<tr><td><code id="boot.ia_+3A_reps">reps</code></td>
<td>
<p>an integer specifying the number of replicates to perform.
Defaults to 999.</p>
</td></tr>
<tr><td><code id="boot.ia_+3A_quiet">quiet</code></td>
<td>
<p>a logical. If <code>FALSE</code>, a progress bar will be displayed. If
<code>TRUE</code>, the progress bar is suppressed.</p>
</td></tr>
<tr><td><code id="boot.ia_+3A_...">...</code></td>
<td>
<p>options passed on to <code><a href="#topic+psex">psex()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with the index of association and standardized index of
association in columns. Number of rows represents the number of reps.
</p>


<h3>Note</h3>

<p>This function is experimental. Please do not use this unless you know
what you are doing.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ia">ia()</a></code>,
<code><a href="#topic+pair.ia">pair.ia()</a></code>,
<code><a href="#topic+psex">psex()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Pinf)
boot.ia(Pinf, reps = 99)
</code></pre>

<hr>
<h2 id='bootgen-class'>Bootgen object</h2><span id='topic+bootgen-class'></span>

<h3>Description</h3>

<p>An internal object used for bootstrapping. Not intended for user interaction.
</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>a character denoting Codominant (&quot;codom&quot;) or Dominant data (&quot;P/A&quot;)</p>
</dd>
<dt><code>ploidy</code></dt><dd><p>an integer denoting the ploidy of the data set. (&gt;=1)</p>
</dd>
<dt><code>alllist</code></dt><dd><p>a list with numeric vectors, each representing a different
locus where each element in the vector represents the index for a specific
allele.</p>
</dd>
<dt><code>names</code></dt><dd><p>a vector containing names of the observed samples.</p>
</dd>
</dl>


<h3>Extends</h3>

<p>Virtual Class <code>"<a href="adegenet.html#topic+gen-class">gen</a>"</code>.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>

<hr>
<h2 id='bootgen2genind'>Switch between genind and genclone objects.</h2><span id='topic+bootgen2genind'></span><span id='topic+bootgen2genind+2Cbootgen-method'></span><span id='topic+as.genclone'></span><span id='topic+as.genclone+2Cgenind-method'></span><span id='topic+genclone2genind'></span><span id='topic+genclone2genind+2Cgenclone-method'></span><span id='topic+as.genambig'></span><span id='topic+as.genambig+2Cgenind-method'></span>

<h3>Description</h3>

<p>as.genclone will create a genclone object from a genind object OR anything
that can be passed to the genind initializer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootgen2genind(bg)

as.genclone(x, ..., mlg, mlgclass = TRUE)

genclone2genind(x)

as.genambig(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootgen2genind_+3A_bg">bg</code></td>
<td>
<p>a bootgen object</p>
</td></tr>
<tr><td><code id="bootgen2genind_+3A_x">x</code></td>
<td>
<p>a <code><a href="adegenet.html#topic+genind-class">genind</a></code> or <code><a href="#topic+genclone-class">genclone</a></code> 
object</p>
</td></tr>
<tr><td><code id="bootgen2genind_+3A_...">...</code></td>
<td>
<p>arguments passed on to the <code><a href="adegenet.html#topic+genind-class">genind</a></code> constructor</p>
</td></tr>
<tr><td><code id="bootgen2genind_+3A_mlg">mlg</code></td>
<td>
<p>an optional vector of multilocus genotypes as integers</p>
</td></tr>
<tr><td><code id="bootgen2genind_+3A_mlgclass">mlgclass</code></td>
<td>
<p>should the mlg slot be of class MLG?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>genclone2genind will remove the mlg slot from the genclone object, creating a 
genind object.
</p>
<p>as.genambig will convert a genind or genclone object to a polysat genambig 
class.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>See Also</h3>

<p><code><a href="adegenet.html#topic+splitStrata">splitStrata</a></code>, <code><a href="#topic+genclone-class">genclone</a></code>,
<code><a href="#topic+read.genalex">read.genalex</a></code>
<code><a href="#topic+aboot">aboot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Aeut)
Aeut

# Conversion to genclone --------------------------------------------------
Aeut.gc &lt;- as.genclone(Aeut)
Aeut.gc

# Conversion to genind ----------------------------------------------------
Aeut.gi &lt;- genclone2genind(Aeut.gc)
Aeut.gi

# Conversion to polysat's "genambig" class --------------------------------
if (require("polysat")) {
  data(Pinf)
  Pinf.gb &lt;- as.genambig(Pinf)
  summary(Pinf.gb)
}

data(nancycats)

# Conversion to bootgen for random sampling of loci -----------------------
nan.bg  &lt;- new("bootgen", nancycats[pop = 9])
nan.bg

# Conversion back to genind -----------------------------------------------
nan.gid &lt;- bootgen2genind(nan.bg)
nan.gid

</code></pre>

<hr>
<h2 id='bruvo.boot'>Create a tree using Bruvo's Distance with non-parametric bootstrapping.</h2><span id='topic+bruvo.boot'></span>

<h3>Description</h3>

<p>Create a tree using Bruvo's Distance with non-parametric bootstrapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bruvo.boot(
  pop,
  replen = 1,
  add = TRUE,
  loss = TRUE,
  sample = 100,
  tree = "upgma",
  showtree = TRUE,
  cutoff = NULL,
  quiet = FALSE,
  root = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bruvo.boot_+3A_pop">pop</code></td>
<td>
<p>a <code><a href="adegenet.html#topic+genind">genind</a></code> or <code><a href="#topic+genclone">genclone</a></code> object</p>
</td></tr>
<tr><td><code id="bruvo.boot_+3A_replen">replen</code></td>
<td>
<p>a <code>vector</code> of <code>integers</code> indicating the length of the
nucleotide repeats for each microsatellite locus.</p>
</td></tr>
<tr><td><code id="bruvo.boot_+3A_add">add</code></td>
<td>
<p>if <code>TRUE</code>, genotypes with zero values will be treated under 
the genome addition model presented in Bruvo et al. 2004.</p>
</td></tr>
<tr><td><code id="bruvo.boot_+3A_loss">loss</code></td>
<td>
<p>if <code>TRUE</code>, genotypes with zero values will be treated under 
the genome loss model presented in Bruvo et al. 2004.</p>
</td></tr>
<tr><td><code id="bruvo.boot_+3A_sample">sample</code></td>
<td>
<p>an <code>integer</code> indicated the number of bootstrap replicates 
desired.</p>
</td></tr>
<tr><td><code id="bruvo.boot_+3A_tree">tree</code></td>
<td>
<p>any function that can generate a tree from a distance matrix.
Default is <code><a href="#topic+upgma">upgma</a></code>.</p>
</td></tr>
<tr><td><code id="bruvo.boot_+3A_showtree">showtree</code></td>
<td>
<p><code>logical</code> if <code>TRUE</code>, a tree will be plotted with 
nodelabels.</p>
</td></tr>
<tr><td><code id="bruvo.boot_+3A_cutoff">cutoff</code></td>
<td>
<p><code>integer</code> the cutoff value for bootstrap node label values
(between 0 and 100).</p>
</td></tr>
<tr><td><code id="bruvo.boot_+3A_quiet">quiet</code></td>
<td>
<p><code>logical</code> defaults to <code>FALSE</code>. If <code>TRUE</code>, a 
progress bar and messages will be suppressed.</p>
</td></tr>
<tr><td><code id="bruvo.boot_+3A_root">root</code></td>
<td>
<p><code>logical</code> This is a parameter passed on to
<code><a href="ape.html#topic+boot.phylo">boot.phylo</a></code>. If the <code>tree</code> argument produces a
rooted tree (e.g. &quot;upgma&quot;), then this value should be <code>TRUE</code>. If it
produces an unrooted tree (e.g. &quot;nj&quot;), then the value should be
<code>FALSE</code>. By default, it is set to <code>NULL</code>, which will assume an
unrooted phylogeny unless the function name contains &quot;upgma&quot;.</p>
</td></tr>
<tr><td><code id="bruvo.boot_+3A_...">...</code></td>
<td>
<p>any argument to be passed on to <code><a href="ape.html#topic+boot.phylo">boot.phylo</a></code>. eg. 
<code>quiet = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will calculate a tree based off of Bruvo's distance
and then utilize <code><a href="ape.html#topic+boot.phylo">boot.phylo</a></code> to randomly sample loci with
replacement, recalculate the tree, and tally up the bootstrap support
(measured in percent success). While this function can take any tree
function, it has native support for two algorithms: <code><a href="ape.html#topic+nj">nj</a></code>
and <code><a href="#topic+upgma">upgma</a></code>. If you want to use any other functions,
you must load the package before you use them (see examples).
</p>


<h3>Value</h3>

<p>a tree of class phylo with nodelables
</p>


<h3>Note</h3>

<p><strong>Please refer to the documentation for bruvo.dist for details on
the algorithm.</strong> If the user does not provide a vector of appropriate length
for <code>replen</code> , it will be estimated by taking the minimum difference
among represented alleles at each locus. IT IS NOT RECOMMENDED TO RELY ON
THIS ESTIMATION.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar, Javier F. Tabima
</p>


<h3>References</h3>

<p>Ruzica Bruvo, Nicolaas K. Michiels, Thomas G. D'Souza, and
Hinrich Schulenburg. A simple method for the calculation of microsatellite
genotype distances irrespective of ploidy level. Molecular Ecology,
13(7):2101-2106, 2004.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bruvo.dist">bruvo.dist</a></code>, <code><a href="adegenet.html#topic+nancycats">nancycats</a></code>, 
<code><a href="#topic+upgma">upgma</a></code>, <code><a href="ape.html#topic+nj">nj</a></code>, <code><a href="ape.html#topic+boot.phylo">boot.phylo</a></code>, 
<code><a href="ape.html#topic+nodelabels">nodelabels</a></code>, <code><a href="adegenet.html#topic+tab">tab</a></code>, 
<code><a href="#topic+missingno">missingno</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Please note that the data presented is assuming that the nancycat dataset 
# contains all dinucleotide repeats, it most likely is not an accurate
# representation of the data.

# Load the nancycats dataset and construct the repeat vector.
data(nancycats)
ssr &lt;- rep(2, 9)

# Analyze the 1st population in nancycats

bruvo.boot(popsub(nancycats, 1), replen = ssr)

## Not run: 

# Always load the library before you specify the function.
library("ape")

# Estimate the tree based off of the BIONJ algorithm.

bruvo.boot(popsub(nancycats, 9), replen = ssr, tree = bionj)

# Utilizing  balanced FastME
bruvo.boot(popsub(nancycats, 9), replen = ssr, tree = fastme.bal)

# To change parameters for the tree, wrap it in a function.
# For example, let's build the tree without utilizing subtree-prune-regraft

myFastME &lt;- function(x) fastme.bal(x, nni = TRUE, spr = FALSE, tbr = TRUE)
bruvo.boot(popsub(nancycats, 9), replen = ssr, tree = myFastME)


## End(Not run)

</code></pre>

<hr>
<h2 id='bruvo.dist'>Bruvo's distance for microsatellites</h2><span id='topic+bruvo.dist'></span><span id='topic+bruvo.between'></span>

<h3>Description</h3>

<p>Calculate the average Bruvo's distance over all loci in a population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bruvo.dist(pop, replen = 1, add = TRUE, loss = TRUE, by_locus = FALSE)

bruvo.between(
  query,
  ref,
  replen = 1,
  add = TRUE,
  loss = TRUE,
  by_locus = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bruvo.dist_+3A_pop">pop</code></td>
<td>
<p>a <code><a href="adegenet.html#topic+genind">genind</a></code> or <code><a href="#topic+genclone">genclone</a></code> object</p>
</td></tr>
<tr><td><code id="bruvo.dist_+3A_replen">replen</code></td>
<td>
<p>a <code>vector</code> of <code>integers</code> indicating the length of the
nucleotide repeats for each microsatellite locus. E.g. a locus with a (CAT) 
repeat would have a replen value of 3. (Also see <code><a href="#topic+fix_replen">fix_replen</a></code>)</p>
</td></tr>
<tr><td><code id="bruvo.dist_+3A_add">add</code></td>
<td>
<p>if <code>TRUE</code>, genotypes with zero values will be treated under 
the genome addition model presented in Bruvo et al. 2004. See the
<strong>Note</strong> section for options.</p>
</td></tr>
<tr><td><code id="bruvo.dist_+3A_loss">loss</code></td>
<td>
<p>if <code>TRUE</code>, genotypes with zero values will be treated under 
the genome loss model presented in Bruvo et al. 2004. See the
<strong>Note</strong> section for options.</p>
</td></tr>
<tr><td><code id="bruvo.dist_+3A_by_locus">by_locus</code></td>
<td>
<p>indicator to get the results per locus. The default setting
is <code>by_locus = FALSE</code>, indicating that Bruvo's distance is to be
averaged over all loci. When <code>by_locus = TRUE</code>, a list of distance
matrices will be returned.</p>
</td></tr>
<tr><td><code id="bruvo.dist_+3A_query">query</code></td>
<td>
<p>a <code><a href="adegenet.html#topic+genind">genind</a></code> or <code><a href="#topic+genclone">genclone</a></code> object</p>
</td></tr>
<tr><td><code id="bruvo.dist_+3A_ref">ref</code></td>
<td>
<p>a <code><a href="adegenet.html#topic+genind">genind</a></code> or <code><a href="#topic+genclone">genclone</a></code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bruvo's distance between two alleles is calculated as 
</p>
<p style="text-align: center;"><code class="reqn">d = 1 - 2^{-\mid x \mid}</code>
</p>
<p>, where <strong>x</strong>
is the number of repeat units between the two alleles (see the Algorithms 
and Equations vignette for more details). These distances are calculated 
over all combinations of alleles at a locus and then the minimum average
distance between allele combinations is taken as the distance for that 
locus. All loci are then averaged over to obtain the distance between two
samples. Missing data is ignored (in the same fashion as 
<code>mean(c(1:9, NA), na.rm = TRUE)</code>) if all alleles are missing. See the
next section for other cases.
</p>


<h4>Polyploids</h4>

<p>Ploidy is irrelevant with respect to calculation of Bruvo's 
distance. However, since it makes a comparison between all alleles at a 
locus, it only makes sense that the two loci need to have the same ploidy 
level. Unfortunately for polyploids, it's often difficult to fully separate
distinct alleles at each locus, so you end up with genotypes that appear to
have a lower ploidy level than the organism.
</p>
<p>To help deal with these situations, Bruvo has suggested three methods for
dealing with these differences in ploidy levels: </p>
 <ul>
<li>
<p><strong>Infinite Model</strong> - The simplest way to deal with it is to count all
missing alleles as infinitely large so that the distance between it and
anything else is 1. Aside from this being computationally simple, it will
tend to <strong>inflate distances between individuals</strong>. </p>
</li>
<li>
<p><strong>Genome Addition Model</strong> - If it is suspected that the organism has
gone through a recent genome expansion, <strong>the missing alleles will be
replace with all possible combinations of the observed alleles in the
shorter genotype</strong>. For example, if there is a genotype of [69, 70, 0, 0]
where 0 is a missing allele, the possible combinations are: [69, 70, 69,
69], [69, 70, 69, 70], [69, 70, 70, 69], and [69, 70, 70, 70]. The
resulting distances are then averaged over the number of comparisons. </p>
</li>
<li>
<p><strong>Genome Loss Model</strong> - This is similar to the genome addition model,
except that it assumes that there was a recent genome reduction event and
uses <strong>the observed values in the full genotype to fill the missing
values in the short genotype</strong>. As with the Genome Addition Model, the
resulting distances are averaged over the number of comparisons. </p>
</li>
<li>
<p><strong>Combination Model</strong> - Combine and average the genome addition and
loss models. </p>
</li></ul>
 
<p>As mentioned above, the infinite model is biased, but it is not nearly as
computationally intensive as either of the other models. The reason for
this is that both of the addition and loss models requires replacement of
alleles and recalculation of Bruvo's distance. The number of replacements
required is equal to n^k where where <em>n</em> is the number of potential
replacements and <em>k</em> is the number of alleles to be replaced.
To reduce the number of calculations and assumptions otherwise, Bruvo's 
distance will be calculated using the largest observed ploidy in pairwise 
comparisons. This means that when comparing [69,70,71,0] and [59,60,0,0], 
they will be treated as triploids.
</p>



<h3>Value</h3>

<p>an object of class <code><a href="stats.html#topic+dist">dist</a></code> or a list of these objects if
<code>by_locus = TRUE</code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>bruvo.between()</code>: Bruvo's distance between a query and a reference
Only diferences between query individuals and reference individuals will be reported
All other values are NaN
</p>
</li></ul>


<h3>Note</h3>

<p>Do not use missingno with this function.
</p>


<h4>Missing alleles and Bruvo's distance in <span class="pkg">poppr</span> versions &lt; 2.5</h4>

<p>In earlier versions of <span class="pkg">poppr</span>, the authors had assumed that, because
the calculation of Bruvo's distance does not rely on orderd sets of
alleles, the imputation methods in the genome addition and genome loss
models would also assume unordered alleles for creating the hypothetical
genotypes. This means that the results from this imputation did not
consider all possible combinations of alleles, resulting in either an over-
or under- estimation of Bruvo's distance between two samples with two or
more missing alleles. This version of <span class="pkg">poppr</span> considers all possible
combinations when calculating Bruvo's distance for incomplete genotype with
a negligable gain in computation time.
</p>
<p>If you want to see the effect of this change on your data, you can use the
global <span class="pkg">poppr</span> option <code>old.bruvo.model</code>. Currently, this option is
<code>FALSE</code> and you can set it by using 
<code>options(old.bruvo.model = TRUE)</code>, but make sure to reset it to 
<code>FALSE</code> afterwards.
</p>



<h4>Repeat Lengths (replen)</h4>

<p>The <code>replen</code> argument is crucial for proper analysis of Bruvo's
distance since the calculation relies on the knowledge of the number of
steps between alleles. To calculate Bruvo's distance, your raw allele calls
are first divided by the repeat lengths and then rounded. This can create a
problem with repeat lengths of even size due to the IEC 60559 standard that
says rounding at 0.5 is to the nearest even number, meaning that it is
possible for two alleles that are one step apart may appear to be exactly
the same. This can be fixed by subtracting a tiny number from the repeat
length with the function <code><a href="#topic+fix_replen">fix_replen</a></code>. Please consider using
this before running Bruvo's distance.
</p>



<h4>Model Choice</h4>

<p> The <code>add</code> and <code>loss</code> arguments 
modify the model choice accordingly: </p>
 <ul>
<li> <p><strong>Infinite 
Model:</strong>  <code>add = FALSE, loss = FALSE</code> </p>
</li>
<li> <p><strong>Genome Addition 
Model:</strong>  <code>add = TRUE, loss = FALSE</code> </p>
</li>
<li> <p><strong>Genome Loss Model:</strong> 
<code>add = FALSE, loss = TRUE</code> </p>
</li>
<li> <p><strong>Combination Model</strong>
<em>(DEFAULT):</em>  <code>add = TRUE, loss = TRUE</code> </p>
</li></ul>
<p> Details of each model
choice are described in the <strong>Details</strong> section, above. Additionally,
genotypes containing all missing values at a locus will return a value of
<code>NA</code> and not contribute to the average across loci. </p>



<h4>Repeat Lengths</h4>

<p> If the user does not provide a vector of 
appropriate length for <code>replen</code> , it will be estimated by taking the 
minimum difference among represented alleles at each locus. IT IS NOT 
RECOMMENDED TO RELY ON THIS ESTIMATION. </p>



<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>
<p>David Folarin
</p>


<h3>References</h3>

<p>Ruzica Bruvo, Nicolaas K. Michiels, Thomas G. D'Souza, and 
Hinrich Schulenburg. A simple method for the calculation of microsatellite 
genotype distances irrespective of ploidy level. Molecular Ecology, 
13(7):2101-2106, 2004.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fix_replen">fix_replen</a></code>, <code><a href="#topic+test_replen">test_replen</a></code>,
<code><a href="#topic+bruvo.boot">bruvo.boot</a></code>, <code><a href="#topic+bruvo.msn">bruvo.msn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Please note that the data presented is assuming that the nancycat dataset 
# contains all dinucleotide repeats, it most likely is not an accurate
# representation of the data.

# Load the nancycats dataset and construct the repeat vector.
data(nancycats)
names(alleles(nancycats)) &lt;- locNames(nancycats) # small bug in this data set
# Assume the alleles are all dinucleotide repeats.
ssr &lt;- rep(2, nLoc(nancycats))
test_replen(nancycats, ssr)         # Are the repeat lengths consistent?
(ssr &lt;- fix_replen(nancycats, ssr)) # Nope. We need to fix them.

# Analyze the first population in nancycats
bruvo.dist(popsub(nancycats, 1), replen = ssr)

## Not run: 

# get the per locus estimates:
bruvo.dist(popsub(nancycats, 1), replen = ssr, by_locus = TRUE)

# View each population as a heatmap.
sapply(popNames(nancycats), function(x) 
heatmap(as.matrix(bruvo.dist(popsub(nancycats, x), replen = ssr)), symm=TRUE))

## End(Not run)
</code></pre>

<hr>
<h2 id='bruvo.msn'>Create minimum spanning network of selected populations using Bruvo's 
distance.</h2><span id='topic+bruvo.msn'></span><span id='topic+msn.bruvo'></span>

<h3>Description</h3>

<p>Create minimum spanning network of selected populations using Bruvo's 
distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bruvo.msn(
  gid,
  replen = 1,
  add = TRUE,
  loss = TRUE,
  mlg.compute = "original",
  palette = topo.colors,
  sublist = "All",
  exclude = NULL,
  blacklist = NULL,
  vertex.label = "MLG",
  gscale = TRUE,
  glim = c(0, 0.8),
  gadj = 3,
  gweight = 1,
  wscale = TRUE,
  showplot = TRUE,
  include.ties = FALSE,
  threshold = NULL,
  clustering.algorithm = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bruvo.msn_+3A_gid">gid</code></td>
<td>
<p>a <code><a href="adegenet.html#topic+genind">genind</a></code> or <code><a href="#topic+genclone">genclone</a></code> object</p>
</td></tr>
<tr><td><code id="bruvo.msn_+3A_replen">replen</code></td>
<td>
<p>a <code>vector</code> of <code>integers</code> indicating the length of the
nucleotide repeats for each microsatellite locus.</p>
</td></tr>
<tr><td><code id="bruvo.msn_+3A_add">add</code></td>
<td>
<p>if <code>TRUE</code>, genotypes with zero values will be treated under 
the genome addition model presented in Bruvo et al. 2004.</p>
</td></tr>
<tr><td><code id="bruvo.msn_+3A_loss">loss</code></td>
<td>
<p>if <code>TRUE</code>, genotypes with zero values will be treated under 
the genome loss model presented in Bruvo et al. 2004.</p>
</td></tr>
<tr><td><code id="bruvo.msn_+3A_mlg.compute">mlg.compute</code></td>
<td>
<p>if the multilocus genotypes are set to &quot;custom&quot; (see 
<code><a href="#topic+mll.custom">mll.custom</a></code> for details) in your genclone object, this will 
specify which mlg level to calculate the nodes from. See details.</p>
</td></tr>
<tr><td><code id="bruvo.msn_+3A_palette">palette</code></td>
<td>
<p>a <code>vector</code> or <code>function</code> defining the color palette 
to be used to color the populations on the graph. It defaults to 
<code><a href="grDevices.html#topic+topo.colors">topo.colors</a></code>. See examples for details.</p>
</td></tr>
<tr><td><code id="bruvo.msn_+3A_sublist">sublist</code></td>
<td>
<p>a <code>vector</code> of population names or indexes that the user 
wishes to keep. Default to &quot;ALL&quot;.</p>
</td></tr>
<tr><td><code id="bruvo.msn_+3A_exclude">exclude</code></td>
<td>
<p>a <code>vector</code> of population names or indexes that the user
wishes to discard. Default to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="bruvo.msn_+3A_blacklist">blacklist</code></td>
<td>
<p>DEPRECATED, use exclude.</p>
</td></tr>
<tr><td><code id="bruvo.msn_+3A_vertex.label">vertex.label</code></td>
<td>
<p>a <code>vector</code> of characters to label each vertex. There
are two defaults: <code>"MLG"</code> will label the nodes with the multilocus 
genotype from the original data set and <code>"inds"</code> will label the nodes 
with the representative individual names.</p>
</td></tr>
<tr><td><code id="bruvo.msn_+3A_gscale">gscale</code></td>
<td>
<p>&quot;grey scale&quot;. If this is <code>TRUE</code>, this will scale the color
of the edges proportional to the observed distance, with the lines becoming
darker for more related nodes. See <code><a href="#topic+greycurve">greycurve</a></code> for details.</p>
</td></tr>
<tr><td><code id="bruvo.msn_+3A_glim">glim</code></td>
<td>
<p>&quot;grey limit&quot;. Two numbers between zero and one. They determine 
the upper and lower limits for the <code><a href="grDevices.html#topic+gray">gray</a></code> function. Default is 
0 (black) and 0.8 (20% black). See <code><a href="#topic+greycurve">greycurve</a></code> for details.</p>
</td></tr>
<tr><td><code id="bruvo.msn_+3A_gadj">gadj</code></td>
<td>
<p>&quot;grey adjust&quot;. a positive <code>integer</code> greater than zero that 
will serve as the exponent to the edge weight to scale the grey value to 
represent that weight. See <code><a href="#topic+greycurve">greycurve</a></code> for details.</p>
</td></tr>
<tr><td><code id="bruvo.msn_+3A_gweight">gweight</code></td>
<td>
<p>&quot;grey weight&quot;. an <code>integer</code>. If it's 1, the grey scale 
will be weighted to emphasize the differences between closely related 
nodes. If it is 2, the grey scale will be weighted to emphasize the 
differences between more distantly related nodes. See 
<code><a href="#topic+greycurve">greycurve</a></code> for details.</p>
</td></tr>
<tr><td><code id="bruvo.msn_+3A_wscale">wscale</code></td>
<td>
<p>&quot;width scale&quot;. If this is <code>TRUE</code>, the edge widths will be 
scaled proportional to the inverse of the observed distance , with the 
lines becoming thicker for more related nodes.</p>
</td></tr>
<tr><td><code id="bruvo.msn_+3A_showplot">showplot</code></td>
<td>
<p>logical. If <code>TRUE</code>, the graph will be plotted. If 
<code>FALSE</code>, it will simply be returned.</p>
</td></tr>
<tr><td><code id="bruvo.msn_+3A_include.ties">include.ties</code></td>
<td>
<p>logical. If <code>TRUE</code>, the graph will include all edges
that were arbitrarily passed over in favor of another edge of equal weight.
If <code>FALSE</code>, which is the default, one edge will be arbitrarily 
selected when two or more edges are tied, resulting in a pure minimum
spanning network.</p>
</td></tr>
<tr><td><code id="bruvo.msn_+3A_threshold">threshold</code></td>
<td>
<p>numeric. By default, this is <code>NULL</code>, which will have no
effect. Any threshold value passed to this argument will be used in
<code><a href="#topic+mlg.filter">mlg.filter</a></code> prior to creating the MSN. If you have a data set
that contains contracted MLGs, this argument will override the threshold in
the data set. See Details.</p>
</td></tr>
<tr><td><code id="bruvo.msn_+3A_clustering.algorithm">clustering.algorithm</code></td>
<td>
<p>string. By default, this is <code>NULL</code>. If
<code>threshold = NULL</code>, this argument will have no effect. When supplied
with either &quot;farthest_neighbor&quot;, &quot;average_neighbor&quot;, or &quot;nearest_neighbor&quot;,
it will be passed to <code><a href="#topic+mlg.filter">mlg.filter</a></code> prior to creating the MSN. If
you have a data set that contains contracted MLGs, this argument will
override the algorithm in the data set. See Details.</p>
</td></tr>
<tr><td><code id="bruvo.msn_+3A_...">...</code></td>
<td>
<p>any other arguments that could go into plot.igraph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The minimum spanning network generated by this function is generated
via igraph's <code><a href="igraph.html#topic+mst">minimum.spanning.tree</a></code>. The resultant
graph produced can be plotted using igraph functions, or the entire object
can be plotted using the function <code><a href="#topic+plot_poppr_msn">plot_poppr_msn</a></code>, which will
give the user a scale bar and the option to layout your data.
</p>


<h4>node sizes</h4>

<p>The area of the nodes are representative of the number of samples. Because
<span class="pkg">igraph</span> scales nodes by radius, the node sizes in the graph are 
represented as the square root of the number of samples.</p>



<h4>mlg.compute</h4>

<p>Each node on the graph represents a different multilocus genotype. 
The edges on the graph represent genetic distances that connect the
multilocus genotypes. In genclone objects, it is possible to set the
multilocus genotypes to a custom definition. This creates a problem for
clone correction, however, as it is very possible to define custom lineages
that are not monophyletic. When clone correction is performed on these
definitions, information is lost from the graph. To circumvent this, The
clone correction will be done via the computed multilocus genotypes, either
&quot;original&quot; or &quot;contracted&quot;. This is specified in the <code>mlg.compute</code>
argument, above.</p>



<h4>contracted multilocus genotypes</h4>

<p>If your incoming data set is of the class <code><a href="#topic+genclone-class">genclone</a></code>,
and it contains contracted multilocus genotypes, this function will retain
that information for creating the minimum spanning network. You can use the
arguments <code>threshold</code> and <code>clustering.algorithm</code> to change the
threshold or clustering algorithm used in the network. For example, if you
have a data set that has a threshold of 0.1 and you wish to have a minimum
spanning network without a threshold, you can simply add 
<code>threshold = 0.0</code>, and no clustering will happen. 
</p>
<p>The <code>threshold</code> and <code>clustering.algorithm</code> arguments can also be
used to filter un-contracted data sets.
</p>



<h3>Value</h3>

<table>
<tr><td><code>graph</code></td>
<td>
<p>a minimum spanning network with nodes corresponding to 
MLGs within the data set. Colors of the nodes represent population 
membership. Width and color of the edges represent distance.</p>
</td></tr> 
<tr><td><code>populations</code></td>
<td>
<p>a vector of the population names corresponding to the 
vertex colors</p>
</td></tr> <tr><td><code>colors</code></td>
<td>
<p>a vector of the hexadecimal representations of
the colors used in the vertex colors</p>
</td></tr>
</table>


<h3>Note</h3>

 <ul>
<li> <p><strong>Please see the documentation for
<code><a href="#topic+bruvo.dist">bruvo.dist</a></code> for details on the algorithm</strong>. </p>
</li>
<li><p> The edges of
these graphs may cross each other if the graph becomes too large. </p>
</li>
<li><p> The
nodes in the graph represent multilocus genotypes. The colors of the nodes
are representative of population membership. It is not uncommon to see
different populations containing the same multilocus genotype.</p>
</li></ul>



<h3>Author(s)</h3>

<p>Zhian N. Kamvar, Javier F. Tabima
</p>


<h3>References</h3>

<p>Ruzica Bruvo, Nicolaas K. Michiels, Thomas G. D'Souza, and 
Hinrich Schulenburg. A simple method for the calculation of microsatellite 
genotype distances irrespective of ploidy level. Molecular Ecology, 
13(7):2101-2106, 2004.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bruvo.dist">bruvo.dist</a></code>, <code><a href="adegenet.html#topic+nancycats">nancycats</a></code>, 
<code><a href="#topic+plot_poppr_msn">plot_poppr_msn</a></code>, <code><a href="igraph.html#topic+mst">mst</a></code> 
<code><a href="#topic+bruvo.boot">bruvo.boot</a></code>, <code><a href="#topic+greycurve">greycurve</a></code> <code><a href="#topic+poppr.msn">poppr.msn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load the data set.
data(nancycats)

# View populations 8 and 9 with default colors. 
bruvo.msn(nancycats, replen = rep(2, 9), sublist=8:9, vertex.label="inds", 
          vertex.label.cex=0.7, vertex.label.dist=0.4)
## Not run: 
# View heat colors.
bruvo.msn(nancycats, replen=rep(2, 9), sublist=8:9, vertex.label="inds", 
palette=heat.colors, vertex.label.cex=0.7, vertex.label.dist=0.4)

# View custom colors. Here, we use black and orange.
bruvo.msn(nancycats, replen=rep(2, 9), sublist=8:9, vertex.label="inds", 
palette = colorRampPalette(c("orange", "black")), vertex.label.cex=0.7, 
vertex.label.dist=0.4)

# View with darker shades of grey (setting the upper limit to 1/2 black 1/2 white).
bruvo.msn(nancycats, replen=rep(2, 9), sublist=8:9, vertex.label="inds", 
palette = colorRampPalette(c("orange", "black")), vertex.label.cex=0.7, 
vertex.label.dist=0.4, glim=c(0, 0.5))

# View with no grey scaling.
bruvo.msn(nancycats, replen=rep(2, 9), sublist=8:9, vertex.label="inds", 
palette = colorRampPalette(c("orange", "black")), vertex.label.cex=0.7, 
vertex.label.dist=0.4, gscale=FALSE)

# View with no line widths.
bruvo.msn(nancycats, replen=rep(2, 9), sublist=8:9, vertex.label="inds", 
palette = colorRampPalette(c("orange", "black")), vertex.label.cex=0.7, 
vertex.label.dist=0.4, wscale=FALSE)

# View with no scaling at all.
bruvo.msn(nancycats, replen=rep(2, 9), sublist=8:9, vertex.label="inds", 
palette = colorRampPalette(c("orange", "black")), vertex.label.cex=0.7, 
vertex.label.dist=0.4, gscale=FALSE)

# View the whole population, but without labels.
bruvo.msn(nancycats, replen=rep(2, 9), vertex.label=NA)

## End(Not run)
</code></pre>

<hr>
<h2 id='bruvomat-class'>bruvomat object</h2><span id='topic+bruvomat-class'></span>

<h3>Description</h3>

<p>An internal object used for bruvo's distance. 
Not intended for user interaction.
</p>


<h3>Slots</h3>


<dl>
<dt><code>mat</code></dt><dd><p>a matrix of genotypes with one allele per locus. Number of rows
will be equal to (ploidy)*(number of loci)</p>
</dd>
<dt><code>replen</code></dt><dd><p>repeat length of microsatellite loci</p>
</dd>
<dt><code>ploidy</code></dt><dd><p>the ploidy of the data set</p>
</dd>
<dt><code>ind.names</code></dt><dd><p>names of individuals in matrix rows.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>

<hr>
<h2 id='clonecorrect'>Remove potential bias caused by cloned genotypes in genind or genclone 
object.</h2><span id='topic+clonecorrect'></span>

<h3>Description</h3>

<p>This function removes any duplicated multilocus genotypes from any specified 
population strata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clonecorrect(pop, strata = 1, combine = FALSE, keep = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clonecorrect_+3A_pop">pop</code></td>
<td>
<p>a <code><a href="adegenet.html#topic+genind-class">genind</a></code>, <code><a href="#topic+genclone-class">genclone</a></code>, or
<code><a href="#topic+snpclone-class">snpclone</a></code> object</p>
</td></tr>
<tr><td><code id="clonecorrect_+3A_strata">strata</code></td>
<td>
<p>a hierarchical formula or numeric vector. This will define the
columns of the data frame in the strata slot to use.</p>
</td></tr>
<tr><td><code id="clonecorrect_+3A_combine">combine</code></td>
<td>
<p><code>logical</code>. When set to TRUE, the strata will be combined
to create a new population for the clone-corrected genind or genclone
object.</p>
</td></tr>
<tr><td><code id="clonecorrect_+3A_keep">keep</code></td>
<td>
<p><code>integer</code>. When <code>combine</code> is set to <code>FALSE</code>, you 
can use this flag to choose the levels of your population strata. For 
example: if your clone correction strata is set to &quot;Pop&quot;, &quot;Subpop&quot;, and 
&quot;Year&quot;, and you want to analyze your populations with respect to year, you 
can set <code>keep = c(1,3)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will clone correct based on the stratification 
provided. To clone correct indiscriminately of population structure, set 
<code>strata = NA</code>.
</p>


<h3>Value</h3>

<p>a clone corrected <code><a href="#topic+genclone-class">genclone</a></code>, 
<code><a href="#topic+snpclone-class">snpclone</a></code>, or <code><a href="adegenet.html#topic+genind-class">genind</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>Examples</h3>

<pre><code class='language-R'># LOAD A. euteiches data set
data(Aeut)

# Redefine it as a genclone object
Aeut &lt;- as.genclone(Aeut)
strata(Aeut) &lt;- other(Aeut)$population_hierarchy[-1]

# Check the number of multilocus genotypes
mlg(Aeut)
popNames(Aeut)

# Clone correct at the population level.
Aeut.pop &lt;- clonecorrect(Aeut, strata =  ~Pop)
mlg(Aeut.pop)
popNames(Aeut.pop)

## Not run: 
# Clone correct at the subpopulation level with respect to population and
# combine.
Aeut.subpop &lt;- clonecorrect(Aeut, strata = ~Pop/Subpop, combine=TRUE)
mlg(Aeut.subpop)
popNames(Aeut.subpop)

# Do the same, but set to the population level.
Aeut.subpop2 &lt;- clonecorrect(Aeut, strata = ~Pop/Subpop, keep=1)
mlg(Aeut.subpop2)
popNames(Aeut.subpop2)

# LOAD H3N2 dataset
data(H3N2)

strata(H3N2) &lt;- other(H3N2)$x

# Extract only the individuals located in China
country &lt;- clonecorrect(H3N2, strata =  ~country)

# How many isolates did we have from China before clone correction?
sum(strata(H3N2, ~country) == "China") # 155

# How many unique isolates from China after clone correction?
sum(strata(country, ~country) == "China") # 79

# Something a little more complicated. (This could take a few minutes on
# slower computers)

# setting the hierarchy to be Country &gt; Year &gt; Month  
c.y.m &lt;- clonecorrect(H3N2, strata =  ~year/month/country)

# How many isolates in the original data set?
nInd(H3N2) # 1903

# How many after we clone corrected for country, year, and month?
nInd(c.y.m) # 1190

## End(Not run)
</code></pre>

<hr>
<h2 id='cutoff_predictor'>Predict cutoff thresholds for use with mlg.filter</h2><span id='topic+cutoff_predictor'></span>

<h3>Description</h3>

<p>Given a series of thresholds for a data set that collapse it into one giant 
cluster, this will search the top fraction of threshold differences to find 
the largest difference. The average between the thresholds spanning that 
difference is the cutoff threshold defining the clonal lineage threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutoff_predictor(thresholds, fraction = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutoff_predictor_+3A_thresholds">thresholds</code></td>
<td>
<p>a vector of numerics coming from mlg.filter where the 
threshold has been set to the maximum threshold theoretically possible.</p>
</td></tr>
<tr><td><code id="cutoff_predictor_+3A_fraction">fraction</code></td>
<td>
<p>the fraction of the data to seek the threshold.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value representing the threshold at which multilocus 
lineages should be defined.
</p>


<h3>Note</h3>

<p>This function originally appeared in 
<a href="https://doi.org/10.5281/zenodo.17424">doi:10.5281/zenodo.17424</a>. 
This is a bit of a blunt instrument.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>References</h3>

<p>ZN Kamvar, JC Brooks, and NJ Grünwald. 2015. Supplementary
Material for Frontiers Plant Genetics and Genomics 'Novel R tools for
analysis of genome-wide population genetic data with emphasis on clonality'.
DOI: <a href="https://doi.org/10.5281/zenodo.17424">doi:10.5281/zenodo.17424</a>
</p>
<p>Kamvar ZN, Brooks JC and Grünwald NJ (2015) Novel R tools for analysis of 
genome-wide population genetic data with emphasis on clonality. Front. Genet.
6:208. doi:
<a href="https://doi.org/10.3389/fgene.2015.00208">doi:10.3389/fgene.2015.00208</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filter_stats">filter_stats</a></code> <code><a href="#topic+mlg.filter">mlg.filter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Pinf)
pinfreps &lt;- fix_replen(Pinf, c(2, 2, 6, 2, 2, 2, 2, 2, 3, 3, 2))
pthresh  &lt;- filter_stats(Pinf, distance = bruvo.dist, replen = pinfreps, 
                         plot = TRUE, stats = "THRESHOLD", threads = 1L)

# prediction for farthest neighbor
cutoff_predictor(pthresh$farthest)

# prediction for all algorithms
sapply(pthresh, cutoff_predictor)

</code></pre>

<hr>
<h2 id='diss.dist'>Calculate a distance matrix based on relative dissimilarity</h2><span id='topic+diss.dist'></span>

<h3>Description</h3>

<p>diss.dist uses the same discrete dissimilarity matrix utilized by the index 
of association (see <code><a href="#topic+ia">ia</a></code> for details). By default, it returns a
distance reflecting the number of allelic differences between two
individuals. When <code>percent = TRUE</code>, it returns a ratio of the number of
observed differences by the number of possible differences. Eg. two
individuals who share half of the same alleles will have a distance of 0.5.
This function can analyze distances for any marker system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diss.dist(x, percent = FALSE, mat = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diss.dist_+3A_x">x</code></td>
<td>
<p>a <code><a href="adegenet.html#topic+genind">genind</a></code> object.</p>
</td></tr>
<tr><td><code id="diss.dist_+3A_percent">percent</code></td>
<td>
<p><code>logical</code>. Should the distance be represented as a 
percent? If set to <code>FALSE</code> (default), the distance will be reflected 
as the number of alleles differing between to individuals. When set to 
<code>TRUE</code>, These will be divided by the ploidy multiplied  by the number 
of loci.</p>
</td></tr>
<tr><td><code id="diss.dist_+3A_mat">mat</code></td>
<td>
<p><code>logical</code>. Return a matrix object. Default set to 
<code>FALSE</code>, returning a dist object. <code>TRUE</code> returns a matrix object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distance calculated here is quite simple and goes by many names,
depending on its application. The most familiar name might be the Hamming
distance, or the number of differences between two strings.
</p>


<h3>Value</h3>

<p>Pairwise distances between individuals present in the genind object.
</p>


<h3>Note</h3>

<p>When <code>percent = TRUE</code>, this is exactly the same as
<code><a href="#topic+provesti.dist">provesti.dist</a></code>, except that it performs better for large
numbers of individuals (n &gt; 125) at the cost of available memory.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prevosti.dist">prevosti.dist</a></code>,
<code><a href="#topic+bitwise.dist">bitwise.dist</a></code> (for SNP data)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# A simple example. Let's analyze the mean distance among populations of A.
# euteiches.

data(Aeut)
mean(diss.dist(popsub(Aeut, 1)))
## Not run: 
mean(diss.dist(popsub(Aeut, 2)))
mean(diss.dist(Aeut))

## End(Not run)
</code></pre>

<hr>
<h2 id='diversity_boot'>Perform a bootstrap analysis on diversity statistics</h2><span id='topic+diversity_boot'></span>

<h3>Description</h3>

<p>This function is intended to perform bootstrap statistics on a matrix of
multilocus genotype counts in different populations. Results from this
function should be interpreted carefully as the default statistics are known
to have a downward bias. See the details for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diversity_boot(
  tab,
  n,
  n.boot = 1L,
  n.rare = NULL,
  H = TRUE,
  G = TRUE,
  lambda = TRUE,
  E5 = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diversity_boot_+3A_tab">tab</code></td>
<td>
<p>a table produced from the <span class="pkg">poppr</span> function
<code><a href="#topic+mlg.table">mlg.table()</a></code>. MLGs in columns and populations in rows</p>
</td></tr>
<tr><td><code id="diversity_boot_+3A_n">n</code></td>
<td>
<p>an integer &gt; 0 specifying the number of bootstrap replicates to
perform (corresponds to <code>R</code> in the function <code><a href="boot.html#topic+boot">boot::boot()</a></code>.</p>
</td></tr>
<tr><td><code id="diversity_boot_+3A_n.boot">n.boot</code></td>
<td>
<p>an integer specifying the number of samples to be drawn in each
bootstrap replicate. If <code>n.boot</code> &lt; 2 (default), the number of samples
drawn for each bootstrap replicate will be equal to the number of samples in
the data set.</p>
</td></tr>
<tr><td><code id="diversity_boot_+3A_n.rare">n.rare</code></td>
<td>
<p>a sample size at which all resamplings should be performed.
This should be no larger than the smallest sample size. Defaults to
<code>NULL</code>, indicating that each population will be sampled at its own
size.</p>
</td></tr>
<tr><td><code id="diversity_boot_+3A_h">H</code></td>
<td>
<p>logical whether or not to calculate Shannon's index</p>
</td></tr>
<tr><td><code id="diversity_boot_+3A_g">G</code></td>
<td>
<p>logical whether or not to calculate Stoddart and Taylor's index (aka
inverse Simpson's index).</p>
</td></tr>
<tr><td><code id="diversity_boot_+3A_lambda">lambda</code></td>
<td>
<p>logical whether or not to calculate Simpson's index</p>
</td></tr>
<tr><td><code id="diversity_boot_+3A_e5">E5</code></td>
<td>
<p>logical whether or not to calculate Evenness</p>
</td></tr>
<tr><td><code id="diversity_boot_+3A_...">...</code></td>
<td>
<p>other parameters passed on to <code><a href="boot.html#topic+boot">boot::boot()</a></code> and
<code><a href="#topic+diversity_stats">diversity_stats()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bootstrapping is performed in three ways:
</p>

<ul>
<li><p> if <code>n.rare</code> is a number greater than zero, then bootstrapping
is performed by randomly sampling without replacement <em>n.rare</em>
samples from the data.
</p>
<div class="sourceCode"><pre>\item if `n.boot` is greater than 1, bootstrapping is performed by
sampling n.boot samples from a multinomial distribution weighted by the
proportion of each MLG in the data.

\item if `n.boot` is less than 2, bootstrapping is performed by 
sampling N samples from a multinomial distribution weighted by the
proportion of each MLG in the data.
</pre></div>
</li></ul>



<h4>Downward Bias</h4>

<p>When sampling with replacement, the diversity statistics here present a
downward bias partially due to the small number of samples in the data.
The result is that the mean of the bootstrapped samples will often be
much lower than the observed value. Alternatively, you can increase the
sample size of the bootstrap by increasing the size of <code>n.boot</code>. Both
of these methods should be taken with caution in interpretation. There
are several R packages freely available that will calculate and perform
bootstrap estimates of Shannon and Simpson diversity metrics (eg.
<span class="pkg">entropart</span>, <span class="pkg">entropy</span>, <span class="pkg">simboot</span>, and
<span class="pkg">EntropyEstimation</span>. These packages also offer unbiased estimators of
Shannon and Simpson diversity. Please take care when attempting to
interpret the results of this function.
</p>



<h3>Value</h3>

<p>a list of objects of class &quot;boot&quot;.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diversity_stats">diversity_stats()</a></code> for basic statistic calculation,
<code><a href="#topic+diversity_ci">diversity_ci()</a></code> for confidence intervals and plotting, and
<code><a href="#topic+poppr">poppr()</a></code>. For bootstrap sampling:
<code><a href="stats.html#topic+Multinom">stats::rmultinom()</a></code> <code><a href="boot.html#topic+boot">boot::boot()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(poppr)
data(Pinf)
tab &lt;- mlg.table(Pinf, plot = FALSE)
diversity_boot(tab, 10L)
## Not run: 
# This can be done in a parallel fashion (OSX uses "multicore", Windows uses "snow")
system.time(diversity_boot(tab, 10000L, parallel = "multicore", ncpus = 4L))
system.time(diversity_boot(tab, 10000L))

## End(Not run)
</code></pre>

<hr>
<h2 id='diversity_ci'>Perform bootstrap statistics, calculate, and plot confidence intervals.</h2><span id='topic+diversity_ci'></span>

<h3>Description</h3>

<p>This function is for calculating bootstrap statistics and their confidence
intervals. It is important to note that the calculation of confidence
intervals is not perfect (See Details). Please be cautious when interpreting
the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diversity_ci(
  tab,
  n = 1000,
  n.boot = 1L,
  ci = 95,
  total = TRUE,
  rarefy = FALSE,
  n.rare = 10,
  plot = TRUE,
  raw = TRUE,
  center = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diversity_ci_+3A_tab">tab</code></td>
<td>
<p>a <code><a href="adegenet.html#topic+genind">genind()</a></code>, <code><a href="#topic+genclone">genclone()</a></code>,
<code><a href="#topic+snpclone">snpclone()</a></code>, OR a matrix produced from
<code><a href="#topic+mlg.table">mlg.table()</a></code>.</p>
</td></tr>
<tr><td><code id="diversity_ci_+3A_n">n</code></td>
<td>
<p>an integer defining the number of bootstrap replicates (defaults to
1000).</p>
</td></tr>
<tr><td><code id="diversity_ci_+3A_n.boot">n.boot</code></td>
<td>
<p>an integer specifying the number of samples to be drawn in each
bootstrap replicate. If <code>n.boot</code> &lt; 2 (default), the number of samples
drawn for each bootstrap replicate will be equal to the number of samples
in the data set. See Details.</p>
</td></tr>
<tr><td><code id="diversity_ci_+3A_ci">ci</code></td>
<td>
<p>the percent for confidence interval.</p>
</td></tr>
<tr><td><code id="diversity_ci_+3A_total">total</code></td>
<td>
<p>argument to be passed on to <code><a href="#topic+mlg.table">mlg.table()</a></code> if
<code>tab</code> is a genind object.</p>
</td></tr>
<tr><td><code id="diversity_ci_+3A_rarefy">rarefy</code></td>
<td>
<p>if <code>TRUE</code>, bootstrapping will be performed on the smallest
population size or the value of <code>n.rare</code>, whichever is larger.
Defaults to <code>FALSE</code>, indicating that bootstrapping will be performed
respective to each population size.</p>
</td></tr>
<tr><td><code id="diversity_ci_+3A_n.rare">n.rare</code></td>
<td>
<p>an integer specifying the smallest size at which to resample
data. This is only used if <code>rarefy = TRUE</code>.</p>
</td></tr>
<tr><td><code id="diversity_ci_+3A_plot">plot</code></td>
<td>
<p>If <code>TRUE</code> (default), boxplots will be produced for each
population, grouped by statistic. Colored dots will indicate the observed
value.This plot can be retrieved by using <code>p &lt;- last_plot()</code> from the
<span class="pkg">ggplot2</span> package.</p>
</td></tr>
<tr><td><code id="diversity_ci_+3A_raw">raw</code></td>
<td>
<p>if <code>TRUE</code> (default) a list containing three elements will be
returned</p>
</td></tr>
<tr><td><code id="diversity_ci_+3A_center">center</code></td>
<td>
<p>if <code>TRUE</code> (default), the confidence interval will be
centered around the observed statistic. Otherwise, if <code>FALSE</code>, the
confidence interval will be bias-corrected normal CI as reported from
<code><a href="boot.html#topic+boot.ci">boot::boot.ci()</a></code></p>
</td></tr>
<tr><td><code id="diversity_ci_+3A_...">...</code></td>
<td>
<p>parameters to be passed on to <code><a href="boot.html#topic+boot">boot::boot()</a></code> and
<code><a href="#topic+diversity_stats">diversity_stats()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Bootstrapping</h4>

<p>For details on the bootstrapping procedures, see
<code><a href="#topic+diversity_boot">diversity_boot()</a></code>. Default bootstrapping is performed by
sampling <strong>N</strong> samples from a multinomial distribution weighted by the
relative multilocus genotype abundance per population where <strong>N</strong> is
equal to the number of samples in the data set. If <strong>n.boot</strong> &gt; 2,
then <strong>n.boot</strong> samples are taken at each bootstrap replicate. When
<code>rarefy = TRUE</code>, then samples are taken at the smallest population
size without replacement. This will provide confidence intervals for all
but the smallest population.
</p>



<h4>Confidence intervals</h4>

<p>Confidence intervals are derived from the function
<code><a href="boot.html#topic+norm.ci">boot::norm.ci()</a></code>. This function will attempt to correct for bias
between the observed value and the bootstrapped estimate. When <code>center = TRUE</code> (default), the confidence interval is calculated from the
bootstrapped distribution and centered around the bias-corrected estimate
as prescribed in Marcon (2012). This method can lead to undesirable
properties, such as the confidence interval lying outside of the maximum
possible value. For rarefaction, the confidence interval is simply
determined by calculating the percentiles from the bootstrapped
distribution. If you want to calculate your own confidence intervals, you
can use the results of the permutations stored in the <code style="white-space: pre;">&#8288;$boot&#8288;</code> element
of the output.
</p>



<h4>Rarefaction</h4>

<p>Rarefaction in the sense of this function is simply sampling a subset of
the data at size <strong>n.rare</strong>. The estimates derived from this method
have straightforward interpretations and allow you to compare diversity
across populations since you are controlling for sample size.
</p>



<h4>Plotting</h4>

<p> Results are plotted as boxplots with point
estimates. If there is no rarefaction applied, confidence intervals are
displayed around the point estimates. The boxplots represent the actual
values from the bootstrapping and will often appear below the estimates and
confidence intervals.
</p>



<h3>Value</h3>



<h4>raw = TRUE</h4>


<ul>
<li> <p><strong>obs</strong> a matrix with observed statistics in columns,
populations in rows
</p>
</li>
<li> <p><strong>est</strong> a matrix with estimated statistics in columns,
populations in rows
</p>
</li>
<li> <p><strong>CI</strong> an array of 3 dimensions giving the lower and upper
bound, the index measured, and the population.
</p>
</li>
<li> <p><strong>boot</strong> a list containing the output of
<code><a href="boot.html#topic+boot">boot::boot()</a></code> for each population.
</p>
</li></ul>




<h4>raw = FALSE</h4>

<p> a data frame with the statistic observations,
estimates, and confidence intervals in columns, and populations in rows. Note
that the confidence intervals are converted to characters and rounded to
three decimal places. </p>



<h3>Note</h3>



<h4>Confidence interval calculation</h4>

<p> Almost all of the statistics
supplied here have a maximum when all genotypes are equally represented.
This means that bootstrapping the samples will always be downwardly biased.
In many cases, the confidence intervals from the bootstrapped distribution
will fall outside of the observed statistic. The reported confidence
intervals here are reported by assuming the variance of the bootstrapped
distribution is the same as the variance around the observed statistic. As
different statistics have different properties, there will not always be
one clear method for calculating confidence intervals. A suggestion for
correction in Shannon's index is to center the CI around the observed
statistic (Marcon, 2012), but there are theoretical limitations to this.
For details, see <a href="https://stats.stackexchange.com/q/156235/49413">https://stats.stackexchange.com/q/156235/49413</a>.
</p>



<h4>User-defined functions</h4>

<p>While it is possible to use custom functions with this, there are three
important things to remember when using these functions:
</p>
<div class="sourceCode"><pre>1. The function must return a single value. 
2. The function must allow for both matrix and vector inputs 
3. The function name cannot match or partially match any arguments 
from [boot::boot()]
</pre></div>
<p>Anonymous functions are okay <br />(e.g. <code>function(x) vegan::rarefy(t(as.matrix(x)), 10)</code>).
</p>



<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>References</h3>

<p>Marcon, E., Herault, B., Baraloto, C. and Lang, G. (2012). The Decomposition
of Shannon’s Entropy and a Confidence Interval for Beta Diversity.
<em>Oikos</em> 121(4): 516-522.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diversity_boot">diversity_boot()</a></code> <code><a href="#topic+diversity_stats">diversity_stats()</a></code>
<code><a href="#topic+poppr">poppr()</a></code> <code><a href="boot.html#topic+boot">boot::boot()</a></code> <code><a href="boot.html#topic+norm.ci">boot::norm.ci()</a></code>
<code><a href="boot.html#topic+boot.ci">boot::boot.ci()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(poppr)
data(Pinf)
diversity_ci(Pinf, n = 100L)
## Not run: 
# With pretty results
diversity_ci(Pinf, n = 100L, raw = FALSE)

# This can be done in a parallel fasion (OSX uses "multicore", Windows uses "snow")
system.time(diversity_ci(Pinf, 10000L, parallel = "multicore", ncpus = 4L))
system.time(diversity_ci(Pinf, 10000L))

# We often get many requests for a clonal fraction statistic. As this is 
# simply the number of observed MLGs over the number of samples, we 
# recommended that people calculate it themselves. With this function, you
# can add it in:

CF &lt;- function(x){
 x &lt;- drop(as.matrix(x))
 if (length(dim(x)) &gt; 1){
   res &lt;- rowSums(x &gt; 0)/rowSums(x)
 } else {
   res &lt;- sum(x &gt; 0)/sum(x)
 }
 return(res)
}
# Show pretty results

diversity_ci(Pinf, 1000L, CF = CF, center = TRUE, raw = FALSE)
diversity_ci(Pinf, 1000L, CF = CF, rarefy = TRUE, raw = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='diversity_stats'>Produce a table of diversity statistics</h2><span id='topic+diversity_stats'></span>

<h3>Description</h3>

<p>Calculate diversity statistics on a matrix containing counts of multilocus
genotypes per population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diversity_stats(z, H = TRUE, G = TRUE, lambda = TRUE, E5 = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diversity_stats_+3A_z">z</code></td>
<td>
<p>a table of integers representing counts of MLGs (columns) per
population (rows)</p>
</td></tr>
<tr><td><code id="diversity_stats_+3A_h">H</code></td>
<td>
<p>logical whether or not to calculate Shannon's index</p>
</td></tr>
<tr><td><code id="diversity_stats_+3A_g">G</code></td>
<td>
<p>logical whether or not to calculate Stoddart and Taylor's index (aka
inverse Simpson's index).</p>
</td></tr>
<tr><td><code id="diversity_stats_+3A_lambda">lambda</code></td>
<td>
<p>logical whether or not to calculate Simpson's index</p>
</td></tr>
<tr><td><code id="diversity_stats_+3A_e5">E5</code></td>
<td>
<p>logical whether or not to calculate Evenness</p>
</td></tr>
<tr><td><code id="diversity_stats_+3A_...">...</code></td>
<td>
<p>any functions that can be calculated on a vector or matrix of
genotype counts.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will calculate any diversity statistic for counts of
multilocus genotypes per population. This does not count allelic diversity.
The calculations of H, G, and lambda are all performed by
<code><a href="vegan.html#topic+diversity">vegan::diversity()</a></code>. E5 is calculated as </p>
<p style="text-align: center;"><code class="reqn">E_{5} = 
  \frac{(1/\lambda) - 1}{e^{H} - 1}</code>
</p>
<p>.
</p>


<h3>Value</h3>

<p>a numeric matrix giving statistics (columns) for each population
(rows).
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diversity_boot">diversity_boot()</a></code> <code><a href="#topic+diversity_ci">diversity_ci()</a></code>
<code><a href="#topic+poppr">poppr()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(poppr)
data(Pinf)
tab &lt;- mlg.table(Pinf, plot = FALSE)
diversity_stats(tab)
## Not run: 
# Example using the poweRlaw package to calculate the negative slope of the
# Pareto distribution.

library("poweRlaw")
power_law_beta &lt;- function(x){
  xpow &lt;- displ(x[x &gt; 0])                 # Generate the distribution
  xpow$setPars(estimate_pars(xpow))       # Estimate the parameters
  xdat &lt;- plot(xpow, draw = FALSE)        # Extract the data
  xlm &lt;- lm(log(y) ~ log(x), data = xdat) # Run log-log linear model for slope
  return(-coef(xlm)[2])
}

Beta &lt;- function(x){
  x &lt;- drop(as.matrix(x))
  if (length(dim(x)) &gt; 1){
    res &lt;- apply(x, 1, power_law_beta)
  } else {
    res &lt;- power_law_beta(x)
  }
  return(res)
}

diversity_stats(tab, B = Beta)

## End(Not run)
</code></pre>

<hr>
<h2 id='filter_stats'>Utilize all algorithms of mlg.filter</h2><span id='topic+filter_stats'></span>

<h3>Description</h3>

<p>This function is a wrapper to mlg.filter. It will calculate all of the stats 
for mlg.filter utilizing all of the algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_stats(
  x,
  distance = bitwise.dist,
  threshold = 1e+06 + .Machine$double.eps^0.5,
  stats = "All",
  missing = "ignore",
  plot = FALSE,
  cols = NULL,
  nclone = NULL,
  hist = "Scott",
  threads = 1L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_stats_+3A_x">x</code></td>
<td>
<p>a <code><a href="adegenet.html#topic+genind">genind</a></code>, <code><a href="#topic+genclone">genclone</a></code>,
<code><a href="adegenet.html#topic+genlight">genlight</a></code>, or <code><a href="#topic+snpclone">snpclone</a></code> object</p>
</td></tr>
<tr><td><code id="filter_stats_+3A_distance">distance</code></td>
<td>
<p>a distance function or matrix</p>
</td></tr>
<tr><td><code id="filter_stats_+3A_threshold">threshold</code></td>
<td>
<p>a threshold to be passed to <code><a href="#topic+mlg.filter">mlg.filter</a></code> 
(Default: 1e6)</p>
</td></tr>
<tr><td><code id="filter_stats_+3A_stats">stats</code></td>
<td>
<p>what statistics should be calculated.</p>
</td></tr>
<tr><td><code id="filter_stats_+3A_missing">missing</code></td>
<td>
<p>how to treat missing data with mlg.filter</p>
</td></tr>
<tr><td><code id="filter_stats_+3A_plot">plot</code></td>
<td>
<p>If the threshold is a maximum threshold, should the statistics be
plotted (Figure 2)</p>
</td></tr>
<tr><td><code id="filter_stats_+3A_cols">cols</code></td>
<td>
<p>the colors to use for each algorithm (defaults to set1 of 
<span class="pkg">RColorBrewer</span>).</p>
</td></tr>
<tr><td><code id="filter_stats_+3A_nclone">nclone</code></td>
<td>
<p>the number of multilocus genotypes you expect for the data. 
This will draw horizontal line on the graph at the value nclone and then 
vertical lines showing the cutoff thresholds for each algorithm.</p>
</td></tr>
<tr><td><code id="filter_stats_+3A_hist">hist</code></td>
<td>
<p>if you want a histogram to be plotted behind the statistics, 
select a method here. Available methods are &quot;sturges&quot;, &quot;fd&quot;, or &quot;scott&quot; 
(default) as documented in <code><a href="graphics.html#topic+hist">hist</a></code>. If you don't want 
to plot the histogram, set <code>hist = NULL</code>.</p>
</td></tr>
<tr><td><code id="filter_stats_+3A_threads">threads</code></td>
<td>
<p>(unused) Previously the number of threads to be used. As of
poppr version 2.4.1, this is by default set to 1.</p>
</td></tr>
<tr><td><code id="filter_stats_+3A_...">...</code></td>
<td>
<p>extra parameters passed on to the distance function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of results from mlg.filter from the three
algorithms. (returns invisibly if <code>plot = TRUE</code>)
</p>


<h3>Note</h3>

<p>This function originally appeared in 
<a href="https://doi.org/10.5281/zenodo.17424">doi:10.5281/zenodo.17424</a>
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar, Jonah C. Brooks
</p>


<h3>References</h3>

<p>ZN Kamvar, JC Brooks, and NJ Grünwald. 2015. Supplementary 
Material for Frontiers Plant Genetics and Genomics 'Novel R tools for 
analysis of genome-wide population genetic data with emphasis on
clonality'. DOI:
<a href="https://doi.org/10.5281/zenodo.17424">doi:10.5281/zenodo.17424</a>
</p>
<p>Kamvar ZN, Brooks JC and Grünwald NJ (2015) Novel R tools for analysis of 
genome-wide population genetic data with emphasis on clonality. Front.
Genet. 6:208. doi: 
<a href="https://doi.org/10.3389/fgene.2015.00208">doi:10.3389/fgene.2015.00208</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mlg.filter">mlg.filter</a></code> <code><a href="#topic+cutoff_predictor">cutoff_predictor</a></code> 
<code><a href="#topic+bitwise.dist">bitwise.dist</a></code> <code><a href="#topic+diss.dist">diss.dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Basic usage example: Bruvo's Distance --------------------------------
data(Pinf)
pinfreps &lt;- fix_replen(Pinf, c(2, 2, 6, 2, 2, 2, 2, 2, 3, 3, 2))
bres &lt;- filter_stats(Pinf, distance = bruvo.dist, replen = pinfreps, plot = TRUE, threads = 1L)
print(bres) # shows all of the statistics

# Use these results with cutoff_filter()
print(thresh &lt;- cutoff_predictor(bres$farthest$THRESHOLDS))
mlg.filter(Pinf, distance = bruvo.dist, replen = pinfreps) &lt;- thresh
Pinf 

# Different distances will give different results -----------------------
nres &lt;- filter_stats(Pinf, distance = nei.dist, plot = TRUE, threads = 1L, missing = "mean")
print(thresh &lt;- cutoff_predictor(nres$farthest$THRESHOLDS))
mlg.filter(Pinf, distance = nei.dist, missing = "mean") &lt;- thresh
Pinf 
</code></pre>

<hr>
<h2 id='fix_replen'>Find and fix inconsistent repeat lengths</h2><span id='topic+fix_replen'></span>

<h3>Description</h3>

<p>Attempts to fix inconsistent repeat lengths found by <code>test_replen</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_replen(gid, replen, e = 1e-05, fix_some = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fix_replen_+3A_gid">gid</code></td>
<td>
<p>a <code><a href="adegenet.html#topic+genind">genind</a></code> or <code><a href="#topic+genclone">genclone</a></code> object</p>
</td></tr>
<tr><td><code id="fix_replen_+3A_replen">replen</code></td>
<td>
<p>a numeric vector of repeat motif lengths.</p>
</td></tr>
<tr><td><code id="fix_replen_+3A_e">e</code></td>
<td>
<p>a number to be subtracted or added to inconsistent repeat lengths to
allow for proper rounding.</p>
</td></tr>
<tr><td><code id="fix_replen_+3A_fix_some">fix_some</code></td>
<td>
<p>if <code>TRUE</code> (default), when there are inconsistent repeat 
lengths that cannot be fixed by subtracting or adding e, those than can be 
fixed will. If <code>FALSE</code>, the original repeat lengths will not be fixed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is modified from the version used in 
<a href="https://doi.org/10.5281/zenodo.13007">doi:10.5281/zenodo.13007</a>.<br /> Before being fed into the
algorithm to calculate Bruvo's distance, the amplicon length is divided by
the repeat unit length. Because of the amplified primer sequence attached
to sequence repeat, this division does not always result in an integer and
so the resulting numbers are rounded. The rounding also protects against
slight mis-calls of alleles. Because we know that </p>
<p style="text-align: center;"><code class="reqn">\frac{(A - e) - (B
  - e)}{r}</code>
</p>
<p> is equivalent to </p>
<p style="text-align: center;"><code class="reqn">\frac{A - B}{r}</code>
</p>
<p>, we know that the primer sequence will not alter the relationships
between the alleles. Unfortunately for nucleotide repeats that have powers
of 2, rounding in R is based off of the IEC 60559 standard (see
<code><a href="base.html#topic+round">round</a></code>), that means that any number ending in 5 is rounded to
the nearest <em>even</em> digit. This function will attempt to alleviate this
problem by adding a very small amount to the repeat length so that division
will not result in a 0.5. If this fails, the same amount will be
subtracted. If neither of these work, a warning will be issued and it is up
to the user to determine if the fault is in the allele calls or the repeat
lengths.
</p>


<h3>Value</h3>

<p>a numeric vector of corrected repeat motif lengths.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>References</h3>

<p>Zhian N. Kamvar, Meg M. Larsen, Alan M. Kanaskie, Everett M. 
Hansen, &amp; Niklaus J. Grünwald. Sudden_Oak_Death_in_Oregon_Forests: Spatial
and temporal population dynamics of the sudden oak death epidemic in Oregon
Forests. ZENODO, <a href="https://doi.org/10.5281/zenodo.13007">doi:10.5281/zenodo.13007</a>, 2014.
</p>
<p>Kamvar, Z. N., Larsen, M. M., Kanaskie, A. M., Hansen, E. M., &amp; Grünwald,
N. J. (2015). Spatial and temporal analysis of populations of the sudden
oak death pathogen in Oregon forests. Phytopathology 105:982-989.
doi: <a href="https://doi.org/10.1094/PHYTO-12-14-0350-FI">doi:10.1094/PHYTO-12-14-0350-FI</a>
</p>
<p>Ruzica Bruvo, Nicolaas K. Michiels, Thomas G. D'Souza, and Hinrich 
Schulenburg. A simple method for the calculation of microsatellite genotype
distances irrespective of ploidy level. Molecular Ecology, 13(7):2101-2106,
2004.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+test_replen">test_replen</a></code> <code><a href="#topic+bruvo.dist">bruvo.dist</a></code>
<code><a href="#topic+bruvo.msn">bruvo.msn</a></code> <code><a href="#topic+bruvo.boot">bruvo.boot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Pram)
(Pram_replen &lt;- setNames(c(3, 2, 4, 4, 4), locNames(Pram)))
fix_replen(Pram, Pram_replen)
# Let's start with an example of a tetranucleotide repeat motif and imagine
# that there are twenty alleles all 1 step apart:
(x &lt;- 1:20L * 4L)
# These are the true lengths of the different alleles. Now, let's add the
# primer sequence to them. 
(PxP &lt;- x + 21 + 21)
# Now we make sure that x / 4 is equal to 1:20, which we know each have
# 1 difference.
x/4
# Now, we divide the sequence with the primers by 4 and see what happens.
(PxPc &lt;- PxP/4)
(PxPcr &lt;- round(PxPc))
diff(PxPcr) # we expect all 1s

# Let's try that again by subtracting a tiny amount from 4
(PxPc &lt;- PxP/(4 - 1e-5))
(PxPcr &lt;- round(PxPc))
diff(PxPcr)
</code></pre>

<hr>
<h2 id='genclone-class'>GENclone and SNPclone classes</h2><span id='topic+genclone-class'></span><span id='topic+genclone'></span><span id='topic+snpclone-class'></span><span id='topic+snpclone'></span>

<h3>Description</h3>

<p><strong>GENclone</strong> is an S4 class that extends the 
<code><a href="adegenet.html#topic+genind-class">genind</a></code> object.<br /> <strong>SNPclone</strong> is an S4 class
that extends the <code><a href="adegenet.html#topic+genlight-class">genlight</a></code> object.<br /><br /> They will have
all of the same attributes as their parent classes, but they will contain
one extra slot to store extra information about multilocus genotypes.
</p>


<h3>Details</h3>

<p>The genclone and snpclone classes will allow for more optimized 
methods of clone correction.
</p>
<p>Previously for <a href="adegenet.html#topic+genind-class">genind</a> and <a href="adegenet.html#topic+genlight-class">genlight</a> objects, 
multilocus genotypes were not retained after a data set was subset by 
population. The new <strong><code>mlg</code></strong> slot allows us to assign the 
multilocus genotypes and retain that information no matter how we subset 
the data set. This new slot can either contain numeric values for 
multilocus genotypes OR it can contain a special internal 
<code><a href="#topic+MLG-class">MLG</a></code> class that allows for custom multilocus genotype 
definitions and filtering.
</p>


<h3>Slots</h3>


<dl>
<dt><code>mlg</code></dt><dd><p>a vector representing multilocus genotypes for the data set OR an 
object of class <code><a href="#topic+MLG-class">MLG</a></code>.</p>
</dd>
</dl>


<h3>Extends</h3>

<p>The <code>genclone</code> class extends class 
<code>"<a href="adegenet.html#topic+genind-class">genind</a>"</code>, directly. <br /> The <code>snpclone</code> class 
extends class <code>"<a href="adegenet.html#topic+genlight-class">genlight</a>"</code>, directly.
</p>


<h3>Note</h3>

<p>When calculating multilocus genotypes for genclone objects, a rank 
function is used, but calculation of multilocus genotypes for snpclone
objects is distance-based (via <code><a href="#topic+bitwise.dist">bitwise.dist</a></code> and 
<code><a href="#topic+mlg.filter">mlg.filter</a></code>). This means that genclone objects are sensitive
to missing data, whereas snpclone objects are insensitive.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.genclone">as.genclone</a></code> <code><a href="#topic+as.snpclone">as.snpclone</a></code> 
<code><a href="adegenet.html#topic+genind-class">genind</a></code> <code><a href="adegenet.html#topic+genlight-class">genlight</a></code> 
<code><a href="adegenet.html#topic+accessors">strata</a></code> <code><a href="adegenet.html#topic+accessors">setPop</a></code> 
<code><a href="#topic+MLG">MLG</a></code> <code><a href="#topic+mll">mll</a></code> <code><a href="#topic+mlg.filter">mlg.filter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# genclone objects can be created from genind objects
#
data(partial_clone)
partial_clone
(pc &lt;- as.genclone(partial_clone))

# snpclone objects can be created from genlight objects
#
set.seed(999)
(gl &lt;- glSim(100, 0, n.snp.struc = 1e3, ploidy = 2, parallel = FALSE))
(sc &lt;- as.snpclone(rbind(gl, gl, parallel = FALSE), parallel = FALSE))
# 
# Use mlg.filter to create a distance threshold to define multilocus genotypes.
mlg.filter(sc, threads = 1L) &lt;- 0.25
sc # 82 mlgs


## End(Not run)
</code></pre>

<hr>
<h2 id='genind2genalex'>Export data from genind objects to genalex formatted \*.csv files.</h2><span id='topic+genind2genalex'></span>

<h3>Description</h3>

<p>genind2genalex will export a genclone or genind object to a \*.csv file
formatted for use in genalex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genind2genalex(
  gid,
  filename = "",
  overwrite = FALSE,
  quiet = FALSE,
  pop = NULL,
  allstrata = TRUE,
  geo = FALSE,
  geodf = "xy",
  sep = ",",
  sequence = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genind2genalex_+3A_gid">gid</code></td>
<td>
<p>a <a href="#topic+genclone-class">genclone</a> or <a href="adegenet.html#topic+genind-class">genind</a>
object.</p>
</td></tr>
<tr><td><code id="genind2genalex_+3A_filename">filename</code></td>
<td>
<p>a string indicating the name and/or path of the file you wish
to create. If this is left unchanged, the results will be saved in a
temporary file and a warning will be displayed for six seconds before the
file is written. This process should give you time to cancel the process
and choose a file path. Otherwise, the name of the file is returned, so you
can copy that to a file of your choice with <code><a href="base.html#topic+file.copy">file.copy()</a></code></p>
</td></tr>
<tr><td><code id="genind2genalex_+3A_overwrite">overwrite</code></td>
<td>
<p><code>logical</code> if <code>FALSE</code> (default) and <code>filename</code> exists, then
the file will not be overwritten. Set this option to <code>TRUE</code> to overwrite
the file.</p>
</td></tr>
<tr><td><code id="genind2genalex_+3A_quiet">quiet</code></td>
<td>
<p><code>logical</code> If <code>FALSE</code> a message will be printed to the
screen.</p>
</td></tr>
<tr><td><code id="genind2genalex_+3A_pop">pop</code></td>
<td>
<p>a character vector OR formula specifying the population factor.
This can be used to specify a specific subset of strata or custom
population factor for the output. Note that the <code>allstrata</code> command
has precedence over this unless the value of this is a new population
factor.</p>
</td></tr>
<tr><td><code id="genind2genalex_+3A_allstrata">allstrata</code></td>
<td>
<p>if this is <code>TRUE</code>, the strata will be combined into a
single population factor in the genalex file.</p>
</td></tr>
<tr><td><code id="genind2genalex_+3A_geo">geo</code></td>
<td>
<p><code>logical</code> Default is <code>FALSE</code>. If it is set to
<code>TRUE</code>, the resulting file will have two columns for geographic data.</p>
</td></tr>
<tr><td><code id="genind2genalex_+3A_geodf">geodf</code></td>
<td>
<p><code>character</code> Since the <code>other</code> slot in the adegenet
object can contain many different items, you must specify the name of the
data frame in the <code>other</code> slot containing your geographic coordinates.
It defaults to &quot;xy&quot;.</p>
</td></tr>
<tr><td><code id="genind2genalex_+3A_sep">sep</code></td>
<td>
<p>a character specifying what character to use to separate columns.
Defaults to &quot;,&quot;.</p>
</td></tr>
<tr><td><code id="genind2genalex_+3A_sequence">sequence</code></td>
<td>
<p>when <code>TRUE</code>, sequence data will be converted to integers
as per the GenAlEx specifications.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The the file path or connection where the data were written.
</p>


<h3>Note</h3>

<p>If your data set lacks a population structure, it will be coded in the
new file as a single population labeled &quot;Pop&quot;. Likewise, if you don't have
any labels for your individuals, they will be labeled as &quot;ind1&quot; through
&quot;ind<em>N</em>&quot;, with <em>N</em> being the size of your population.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.genalex">read.genalex()</a></code>, <code><a href="#topic+clonecorrect">clonecorrect()</a></code>, <a href="#topic+genclone-class">genclone</a>, <a href="adegenet.html#topic+genind-class">genind</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(nancycats)
genind2genalex(nancycats, "~/Documents/nancycats.csv", geo=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='genotype_curve'>Produce a genotype accumulation curve</h2><span id='topic+genotype_curve'></span>

<h3>Description</h3>

<p>Genotype accumulation curves are useful for determining the minimum number of
loci necessary to discriminate between individuals in a population. This 
function will randomly sample loci without replacement and count the number 
of multilocus genotypes observed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genotype_curve(
  gen,
  sample = 100,
  maxloci = 0L,
  quiet = FALSE,
  thresh = 1,
  plot = TRUE,
  drop = TRUE,
  dropna = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genotype_curve_+3A_gen">gen</code></td>
<td>
<p>a <code><a href="#topic+genclone-class">genclone</a></code>, <code><a href="adegenet.html#topic+genind-class">genind</a></code>, or
<code><a href="pegas.html#topic+read.loci">loci</a></code> object.</p>
</td></tr>
<tr><td><code id="genotype_curve_+3A_sample">sample</code></td>
<td>
<p>an <code>integer</code> defining the number of times loci will be 
resampled without replacement.</p>
</td></tr>
<tr><td><code id="genotype_curve_+3A_maxloci">maxloci</code></td>
<td>
<p>the maximum number of loci to sample. By default, 
<code>maxloci = 0</code>, which indicates that n - 1 loci are to be used. Note 
that this will always take min(n - 1, maxloci)</p>
</td></tr>
<tr><td><code id="genotype_curve_+3A_quiet">quiet</code></td>
<td>
<p>if <code>FALSE</code> (default), Progress of the iterations will be 
displayed. If <code>TRUE</code>, nothing is printed to screen as the function 
runs.</p>
</td></tr>
<tr><td><code id="genotype_curve_+3A_thresh">thresh</code></td>
<td>
<p>a number from 0 to 1. This will draw a line at that fraction of
multilocus genotypes, rounded. Defaults to 1, which will draw a line at the
maximum number of observable genotypes.</p>
</td></tr>
<tr><td><code id="genotype_curve_+3A_plot">plot</code></td>
<td>
<p>if <code>TRUE</code> (default), the genotype curve will be plotted via 
ggplot2. If <code>FALSE</code>, the resulting matrix will be visibly returned.</p>
</td></tr>
<tr><td><code id="genotype_curve_+3A_drop">drop</code></td>
<td>
<p>if <code>TRUE</code> (default), monomorphic loci will be removed before
analysis as these loci affect the shape of the curve.</p>
</td></tr>
<tr><td><code id="genotype_curve_+3A_dropna">dropna</code></td>
<td>
<p>if <code>TRUE</code> (default) and <code>drop = TRUE</code>, NAs will be
ignored when determining if a locus is monomorphic. When <code>FALSE</code>,
presence of NAs will result in the locus being retained. This argument has
no effect when <code>drop = FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally, this function works by converting the data into a 
<code><a href="pegas.html#topic+read.loci">loci</a></code> object, which represents genotypes as a data 
frame of factors. Random samples are taken of 1 to n-1 columns of the 
matrix and the number of unique rows are counted to determine the number of
multilocus genotypes in that random sample. This function does not take 
into account any definitions of MLGs via <code><a href="#topic+mlg.filter">mlg.filter</a></code> or 
<code><a href="#topic+mll.custom">mll.custom</a></code>.
</p>


<h3>Value</h3>

<p>(invisibly by deafuls) a matrix of integers showing the results of
each randomization. Columns represent the number of loci sampled and rows 
represent an independent sample.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nancycats)
nan_geno &lt;- genotype_curve(nancycats)
## Not run: 

# Marker Type Comparison --------------------------------------------------
# With AFLP data, it is often necessary to include more markers for resolution
data(Aeut)
Ageno &lt;- genotype_curve(Aeut)

# Many microsatellite data sets have hypervariable markers
data(microbov)
mgeno &lt;- geotype_curve(microbov)

# Adding a trendline ------------------------------------------------------

# Trendlines: you can add a smoothed trendline with geom_smooth()
library("ggplot2")
p &lt;- last_plot()
p + geom_smooth()

# Producing Figures for Publication ---------------------------------------

# This data set has been pre filtered
data(monpop)
mongeno &lt;- genotype_curve(monpop)

# Here, we add a curve and a title for publication
p &lt;- last_plot()
mytitle &lt;- expression(paste("Genotype Accumulation Curve for ", 
                            italic("M. fructicola")))
p + geom_smooth() + 
  theme_bw() + 
  theme(text = element_text(size = 12, family = "serif")) +
  theme(title = element_text(size = 14)) +
  ggtitle(mytitle)

## End(Not run)

</code></pre>

<hr>
<h2 id='getfile'>Get a file name and path and store them in a list.</h2><span id='topic+getfile'></span>

<h3>Description</h3>

<p>getfile is a convenience function that serves as a wrapper for the functions
<code><a href="base.html#topic+file.choose">file.choose()</a></code>, <code><a href="base.html#topic+file.path">file.path()</a></code>, and <code><a href="base.html#topic+list.files">list.files()</a></code>.
If the user is working in a GUI environment, a window will pop up, allowing
the user to choose a specified file regardless of path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getfile(multi = FALSE, pattern = NULL, combine = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getfile_+3A_multi">multi</code></td>
<td>
<p>this is an indicator to allow the user to store the names of
multiple files found in the directory. This is useful in conjunction with
<code><a href="#topic+poppr.all">poppr.all()</a></code>.</p>
</td></tr>
<tr><td><code id="getfile_+3A_pattern">pattern</code></td>
<td>
<p>a <code><a href="base.html#topic+regex">regex()</a></code> pattern for use while
<code>multi == TRUE</code>. This will grab all files matching this pattern.</p>
</td></tr>
<tr><td><code id="getfile_+3A_combine">combine</code></td>
<td>
<p><code>logical</code>. When this is set to <code>TRUE</code> (default), the
<code style="white-space: pre;">&#8288;$files&#8288;</code> vector will have the path appended to them. When it is set to
<code>FALSE</code>, it will have the basename.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>path</code></td>
<td>
<p>a character string of the absolute path to the
chosen file or files</p>
</td></tr>
<tr><td><code>files</code></td>
<td>
<p>a character vector containing the chosen file
name or names.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

x &lt;- getfile()
poppr(x$files)

y &lt;- getfile(multi=TRUE, pattern="^.+?dat$") 
#useful for reading in multiple FSTAT formatted files.

yfiles &lt;- poppr.all(y$files)


## End(Not run)  
</code></pre>

<hr>
<h2 id='greycurve'>Display a greyscale gradient adjusted to specific parameters</h2><span id='topic+greycurve'></span>

<h3>Description</h3>

<p>This function has one purpose. It is for deciding the appropriate scaling for
a grey palette to be used for edge weights of a minimum spanning network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>greycurve(
  data = seq(0, 1, length = 1000),
  glim = c(0, 0.8),
  gadj = 3,
  gweight = 1,
  scalebar = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="greycurve_+3A_data">data</code></td>
<td>
<p>a sequence of numbers to be converted to greyscale.</p>
</td></tr>
<tr><td><code id="greycurve_+3A_glim">glim</code></td>
<td>
<p>&quot;grey limit&quot;. Two numbers between zero and one. They determine 
the upper and lower limits for the <code><a href="grDevices.html#topic+gray">gray</a></code> function. Default is 0
(black) and 0.8 (20% black).</p>
</td></tr>
<tr><td><code id="greycurve_+3A_gadj">gadj</code></td>
<td>
<p>&quot;grey adjust&quot;. a positive <code>integer</code> greater than zero that
will serve as the exponent to the edge weight to scale the grey value to
represent that weight.</p>
</td></tr>
<tr><td><code id="greycurve_+3A_gweight">gweight</code></td>
<td>
<p>&quot;grey weight&quot;. an <code>integer</code>. If it's 1, the grey scale
will be weighted to emphasize the differences between closely related nodes.
If it is 2, the grey scale will be weighted to emphasize the differences
between more distantly related nodes.</p>
</td></tr>
<tr><td><code id="greycurve_+3A_scalebar">scalebar</code></td>
<td>
<p>When this is set to <code>TRUE</code>, two scalebars will be
plotted. The purpose of this is for adding a scale bar to minimum spanning
networks produced in earlier versions of poppr.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot displaying a grey gradient from 0.001 to 1 with minimum and 
maximum values displayed as yellow lines, and an equation for the correction 
displayed in red.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Normal grey curve with an adjustment of 3, an upper limit of 0.8, and
# weighted towards smaller values.
greycurve()
## Not run: 
# 1:1 relationship grey curve.
greycurve(gadj=1, glim=1:0)

# Grey curve weighted towards larger values.
greycurve(gweight=2)

# Same as the first, but the limit is 1.
greycurve(glim=1:0)

# Setting the lower limit to 0.1 and weighting towards larger values.
greycurve(glim=c(0.1,0.8), gweight=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='ia'>Index of Association</h2><span id='topic+ia'></span><span id='topic+pair.ia'></span><span id='topic+resample.ia'></span><span id='topic+jack.ia'></span>

<h3>Description</h3>

<p>Calculate the Index of Association and Standardized Index of Association.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ia(
  gid,
  sample = 0,
  method = 1,
  quiet = FALSE,
  missing = "ignore",
  plot = TRUE,
  hist = TRUE,
  index = "rbarD",
  valuereturn = FALSE
)

pair.ia(
  gid,
  sample = 0L,
  quiet = FALSE,
  plot = TRUE,
  low = "blue",
  high = "red",
  limits = NULL,
  index = "rbarD",
  method = 1L
)

resample.ia(gid, n = NULL, reps = 999, quiet = FALSE, use_psex = FALSE, ...)

jack.ia(gid, n = NULL, reps = 999, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ia_+3A_gid">gid</code></td>
<td>
<p>a <code><a href="adegenet.html#topic+new.genind">adegenet::genind()</a></code> or <code><a href="#topic+genclone">genclone()</a></code> object.</p>
</td></tr>
<tr><td><code id="ia_+3A_sample">sample</code></td>
<td>
<p>an integer indicating the number of permutations desired
(eg 999).</p>
</td></tr>
<tr><td><code id="ia_+3A_method">method</code></td>
<td>
<p>an integer from 1 to 4 indicating the sampling method desired.
see <code><a href="#topic+shufflepop">shufflepop()</a></code> for details.</p>
</td></tr>
<tr><td><code id="ia_+3A_quiet">quiet</code></td>
<td>
<p>Should the function print anything to the screen while it is
performing calculations?
<code>TRUE</code> prints nothing.
<code>FALSE</code> (default) will print the population name and progress bar.</p>
</td></tr>
<tr><td><code id="ia_+3A_missing">missing</code></td>
<td>
<p>a character string. see <code><a href="#topic+missingno">missingno()</a></code> for details.</p>
</td></tr>
<tr><td><code id="ia_+3A_plot">plot</code></td>
<td>
<p>When <code>TRUE</code> (default), a heatmap of the values per locus pair
will be plotted (for <code><a href="#topic+pair.ia">pair.ia()</a></code>). When <code>sampling &gt; 0</code>, different things
happen with <code><a href="#topic+ia">ia()</a></code> and <code><a href="#topic+pair.ia">pair.ia()</a></code>. For <code><a href="#topic+ia">ia()</a></code>, a histogram for the data
set is plotted. For <code><a href="#topic+pair.ia">pair.ia()</a></code>, p-values are added as text on the
heatmap.</p>
</td></tr>
<tr><td><code id="ia_+3A_hist">hist</code></td>
<td>
<p><code>logical</code> Deprecated. Use plot.</p>
</td></tr>
<tr><td><code id="ia_+3A_index">index</code></td>
<td>
<p><code>character</code> either &quot;Ia&quot; or &quot;rbarD&quot;. If <code>hist = TRUE</code>,
this indicates which index you want represented in the plot (default:
&quot;rbarD&quot;).</p>
</td></tr>
<tr><td><code id="ia_+3A_valuereturn">valuereturn</code></td>
<td>
<p><code>logical</code> if <code>TRUE</code>, the index values from the
reshuffled data is returned. If <code>FALSE</code> (default), the index is
returned with associated p-values in a 4 element numeric vector.</p>
</td></tr>
<tr><td><code id="ia_+3A_low">low</code></td>
<td>
<p>(for pair.ia) a color to use for low values when 'plot =
TRUE'</p>
</td></tr>
<tr><td><code id="ia_+3A_high">high</code></td>
<td>
<p>(for pair.ia) a color to use for low values when 'plot =
TRUE'</p>
</td></tr>
<tr><td><code id="ia_+3A_limits">limits</code></td>
<td>
<p>(for pair.ia) the limits to be used for the color scale. 
Defaults to 'NULL'. If you want to use a custom range, supply two
numbers between -1 and 1, (e.g. 'limits = c(-0.15, 1)')</p>
</td></tr>
<tr><td><code id="ia_+3A_n">n</code></td>
<td>
<p>an integer specifying the number of samples to be drawn. Defaults to
<code>NULL</code>, which then uses the number of multilocus genotypes.</p>
</td></tr>
<tr><td><code id="ia_+3A_reps">reps</code></td>
<td>
<p>an integer specifying the number of replicates to perform. 
Defaults to 999.</p>
</td></tr>
<tr><td><code id="ia_+3A_use_psex">use_psex</code></td>
<td>
<p>a logical. If <code>TRUE</code>, the samples will be weighted by the value 
of psex. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ia_+3A_...">...</code></td>
<td>
<p>arguments passed on to <code><a href="#topic+psex">psex</a></code></p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code><a href="#topic+ia">ia()</a></code> calculates the index of association over all loci in the data set.
</p>
</li>
<li> <p><code><a href="#topic+pair.ia">pair.ia()</a></code> calculates the index of association in a pairwise manner
among all loci.
</p>
</li>
<li> <p><code><a href="#topic+resample.ia">resample.ia()</a></code> calculates the index of association on a reduced data set
multiple times to create a distribution, showing the variation of values
observed at a given sample size (previously <code><a href="#topic+jack.ia">jack.ia()</a></code>).
</p>
</li></ul>

<p>The index of association was originally developed by A.H.D. Brown analyzing
population structure of wild barley (Brown, 1980). It has been widely used
as a tool to detect clonal reproduction within populations . Populations
whose members are undergoing sexual reproduction, whether it be selfing or
out-crossing, will produce gametes via meiosis, and thus have a chance to
shuffle alleles in the next generation. Populations whose members are
undergoing clonal reproduction, however, generally do so via mitosis. This
means that the most likely mechanism for a change in genotype is via
mutation. The rate of mutation varies from species to species, but it is
rarely sufficiently high to approximate a random shuffling of alleles. The
index of association is a calculation based on the ratio of the variance of
the raw number of differences between individuals and the sum of those
variances over each locus . You can also think of it as the observed
variance over the expected variance. If they  are the same, then the index
is zero after subtracting one (from Maynard-Smith, 1993):
</p>
<p style="text-align: center;"><code class="reqn">I_A = \frac{V_O}{V_E}-1</code>
</p>

<p>Since the distance is more or less a binary distance, any sort of marker can
be used for this analysis. In the calculation, phase is not considered, and
any difference increases the distance between two individuals. Remember that
each column represents a different allele and that each entry in the table
represents the fraction of the genotype made up by that allele at that
locus. Notice also that the sum of the rows all equal one. Poppr uses this
to calculate distances by simply taking the sum of the absolute values of
the differences between rows.
</p>
<p>The calculation for the distance between two individuals at a single locus
with <em>a</em> allelic states and a ploidy of <em>k</em> is as follows (except
for Presence/Absence data):
</p>
<p style="text-align: center;"><code class="reqn"> d = \displaystyle \frac{k}{2}\sum_{i=1}^{a} \mid A_{i} - B_{i}\mid</code>
</p>

<p>To find the total number of differences between two individuals over all
loci, you just take <em>d</em> over <em>m</em> loci, a value we'll call
<em>D</em>:
</p>
<p style="text-align: center;"><code class="reqn">D = \displaystyle \sum_{i=1}^{m} d_i </code>
</p>

<p>These values are calculated over all possible combinations of individuals
in the data set, <code class="reqn">{n \choose 2}</code> after which you end up
with <code class="reqn">{n \choose 2}\cdot{}m</code> values of <em>d</em> and
<code class="reqn">{n \choose 2}</code> values of <em>D</em>. Calculating the
observed variances is fairly straightforward (modified from Agapow and
Burt, 2001):
</p>
<p style="text-align: center;"><code class="reqn"> V_O = \frac{\displaystyle \sum_{i=1}^{n \choose 2} D_{i}^2 - 
\frac{(\displaystyle\sum_{i=1}^{n \choose 2} D_{i})^2}{{n \choose 2}}}{{n 
\choose 2}}</code>
</p>

<p>Calculating the expected variance is the sum of each of the variances of the
individual loci. The calculation at a single locus, <em>j</em> is the same as
the previous equation, substituting values of <em>D</em> for <em>d</em>:
</p>
<p style="text-align: center;"><code class="reqn"> var_j = \frac{\displaystyle \sum_{i=1}^{n \choose 2} d_{i}^2 - 
\frac{(\displaystyle\sum_{i=1}^{n \choose 2} d_i)^2}{{n \choose 2}}}{{n 
\choose 2}} </code>
</p>

<p>The expected variance is then the sum of all the variances over all <em>m</em>
loci:
</p>
<p style="text-align: center;"><code class="reqn"> V_E = \displaystyle \sum_{j=1}^{m} var_j </code>
</p>

<p>Agapow and Burt showed that <code class="reqn">I_A</code> increases steadily with the number
of loci, so they came up with an approximation that is widely used,
<code class="reqn">\bar r_d</code>. For the derivation, see the manual for
<em>multilocus</em>.
</p>
<p style="text-align: center;"><code class="reqn"> \bar r_d = \frac{V_O - V_E} {2\displaystyle 
\sum_{j=1}^{m}\displaystyle \sum_{k \neq j}^{m}\sqrt{var_j\cdot{}var_k}} 
</code>
</p>



<h3>Value</h3>



<h4>for <code><a href="#topic+pair.ia">pair.ia()</a></code></h4>

<p>A matrix with two columns and choose(nLoc(gid), 2) rows representing the
values for Ia and rbarD per locus pair.
</p>



<h4>If no sampling has occurred:</h4>

<p>A named number vector of length 2 giving the Index of Association, &quot;Ia&quot;;
and the Standardized Index of Association, &quot;rbarD&quot;
</p>



<h4>If there is sampling:</h4>

<p>A a named numeric vector of length 4 with the following values:
</p>

<ul>
<li><p> Ia - numeric. The index of association.
</p>
</li>
<li><p> p.Ia - A number indicating the p-value resulting from a one-sided
permutation test based on the number of samples indicated in the
original call.
</p>
</li>
<li><p> rbarD - numeric. The standardized index of association.
</p>
</li>
<li><p> p.rD - A factor indicating the p-value resulting from a
one-sided permutation test based on the number of samples indicated in
the original call.
</p>
</li></ul>




<h4>If there is sampling and <code>valureturn = TRUE</code></h4>

<p>A list with the following elements:
</p>

<ul>
<li><p> index The above vector
</p>
</li>
<li><p> samples A data frame with s by 2 column data frame where s is the
number of samples defined. The columns are for the values of Ia and
rbarD, respectively.
</p>
</li></ul>




<h4>resample.ia()</h4>

<p>a data frame with the index of association and standardized index of
association in columns. Number of rows represents the number of reps.</p>



<h3>Note</h3>

<p><code><a href="#topic+jack.ia">jack.ia()</a></code> is deprecated as the name was misleading. Please use
<code><a href="#topic+resample.ia">resample.ia()</a></code>
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>References</h3>

<p>Paul-Michael Agapow and Austin Burt. Indices of multilocus
linkage disequilibrium. <em>Molecular Ecology Notes</em>, 1(1-2):101-102,
2001
</p>
<p>A.H.D. Brown, M.W. Feldman, and E. Nevo. Multilocus structure of natural
populations of <em>Hordeum spontaneum</em>. <em>Genetics</em>, 96(2):523-536, 1980.
</p>
<p>J M Smith, N H Smith, M O'Rourke, and B G Spratt. How clonal are bacteria?
Proceedings of the National Academy of Sciences, 90(10):4384-4388, 1993.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+poppr">poppr()</a></code>, <code><a href="#topic+missingno">missingno()</a></code>,
<code><a href="adegenet.html#topic+import2genind">import2genind()</a></code>, <code><a href="#topic+read.genalex">read.genalex()</a></code>,
<code><a href="#topic+clonecorrect">clonecorrect()</a></code>, <code><a href="#topic+win.ia">win.ia()</a></code>, <code><a href="#topic+samp.ia">samp.ia()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nancycats)
ia(nancycats)

# Pairwise over all loci:
data(partial_clone)
res &lt;- pair.ia(partial_clone)
plot(res, low = "black", high = "green", index = "Ia")

# Resampling
data(Pinf)
resample.ia(Pinf, reps = 99)

## Not run: 

# Pairwise IA with p-values (this will take about a minute)
res &lt;- pair.ia(partial_clone, sample = 999)
head(res)

# Plot the results of resampling rbarD. 
library("ggplot2")
Pinf.resamp &lt;- resample.ia(Pinf, reps = 999)
ggplot(Pinf.resamp[2], aes(x = rbarD)) +
  geom_histogram() +
  geom_vline(xintercept = ia(Pinf)[2]) +
  geom_vline(xintercept = ia(clonecorrect(Pinf))[2], linetype = 2) +
  xlab(expression(bar(r)[d]))

# Get the indices back and plot the distributions.
nansamp &lt;- ia(nancycats, sample = 999, valuereturn = TRUE)

plot(nansamp, index = "Ia")
plot(nansamp, index = "rbarD")

# You can also adjust the parameters for how large to display the text
# so that it's easier to export it for publication/presentations.
library("ggplot2")
plot(nansamp, labsize = 5, linesize = 2) +
  theme_bw() +                                      # adding a theme
  theme(text = element_text(size = rel(5))) +       # changing text size
  theme(plot.title = element_text(size = rel(4))) + # changing title size
  ggtitle("Index of Association of nancycats")      # adding a new title

# Get the index for each population.
lapply(seppop(nancycats), ia)
# With sampling
lapply(seppop(nancycats), ia, sample = 999)

# Plot pairwise ia for all populations in a grid with cowplot
# Set up the library and data
library("cowplot")
data(monpop)
splitStrata(monpop) &lt;- ~Tree/Year/Symptom
setPop(monpop)      &lt;- ~Tree

# Need to set up a list in which to store the plots.
plotlist        &lt;- vector(mode = "list", length = nPop(monpop))
names(plotlist) &lt;- popNames(monpop)

# Loop throgh the populations, calculate pairwise ia, plot, and then
# capture the plot in the list
for (i in popNames(monpop)){
  x &lt;- pair.ia(monpop[pop = i], limits = c(-0.15, 1)) # subset, calculate, and plot
  plotlist[[i]] &lt;- ggplot2::last_plot() # save the last plot
}

# Use the plot_grid function to plot.
plot_grid(plotlist = plotlist, labels = paste("Tree", popNames(monpop)))


## End(Not run)
</code></pre>

<hr>
<h2 id='imsn'>Create minimum spanning networks interactively</h2><span id='topic+imsn'></span>

<h3>Description</h3>

<p>This function will launch an interactive interface that allows you to create,
plot, manipulate, and save minimum spanning networks. It runs using the
<span class="pkg">shiny</span> R package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imsn()
</code></pre>


<h3>Details</h3>

<p>Creating and plotting MSNs requires three steps:
</p>

<ol>
<li><p> Create a distance matrix from your data
</p>
</li>
<li><p> Create a minimum spanning network with your data and the matrix
</p>
</li>
<li><p> Visualize the minimum spanning network</p>
</li></ol>

<p>The function <code><a href="#topic+plot_poppr_msn">plot_poppr_msn</a></code> is currently the most flexible way
of visualizing your minimum spanning network, but with 20 parameters, it can
become pretty intimidating trying to find the right display for your MSN. 
</p>
<p>With this function, all three steps are combined into one interactive 
interface that will allow you to intuitively modify your minimum spanning 
network and even save the results to a pdf or png file.
</p>


<h3>Value</h3>

<p>NULL, invisibly
</p>


<h3>Interface</h3>



<h4>Buttons</h4>

<p>In the left hand panel, there are three buttons to execute the functions.
These allow you to run the data set after you manipulate all of the
parameters.
</p>

<ul>
<li> <p><strong>GO!</strong> - This button will start the application with the
specified parameters
</p>
</li>
<li> <p><strong>reData</strong> - Use this button when you have changed any parameters
under the section <strong>Data Parameters</strong>. This involves recalculating the
distance matrix and msn.
</p>
</li>
<li> <p><strong>reGraph</strong> - Use this button when you have changed any parameters
under the section <strong>Graphical Parameters</strong>. This involves superficial
changes to the display of the minimum spanning network.
</p>
</li></ul>




<h4>Tabs</h4>

<p>The right hand panel contains different tabs related to your data set of
choice.
</p>

<ul>
<li> <p><strong>Plot</strong> - The minimum spanning network itself
</p>
</li>
<li> <p><strong>Data</strong> - A display of your data set
</p>
</li>
<li> <p><strong>Command</strong> - The commands used to create the plot. You can copy
and paste this to an R file for reproducibility.
</p>
</li>
<li> <p><strong>Save Plot</strong> - This provides a tool for you to save the plot to a
PDF or PNG image.
</p>
</li>
<li> <p><strong>Session Information</strong> - displays the result of
<code><a href="utils.html#topic+sessionInfo">sessionInfo</a></code> for reproducibility.
</p>
</li></ul>




<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_poppr_msn">plot_poppr_msn</a></code> <code><a href="#topic+diss.dist">diss.dist</a></code>
<code><a href="#topic+bruvo.dist">bruvo.dist</a></code> <code><a href="#topic+bruvo.msn">bruvo.msn</a></code> <code><a href="#topic+poppr.msn">poppr.msn</a></code>
<code><a href="#topic+nei.dist">nei.dist</a></code> <code><a href="#topic+popsub">popsub</a></code> <code><a href="#topic+missingno">missingno</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Set up some data
library("poppr")
library("magrittr")
data(monpop)
splitStrata(monpop) &lt;- ~Tree/Year/Symptom
summary(monpop)
monpop_ssr &lt;- c(CHMFc4 = 7, CHMFc5 = 2, CHMFc12 = 4, 
                SEA = 4, SED = 4, SEE = 2, SEG = 6, 
                SEI = 3, SEL = 4, SEN = 2, SEP = 4, 
                SEQ = 2, SER = 4)
t26 &lt;- monpop %&gt;% setPop(~Tree) %&gt;% popsub("26") %&gt;% setPop(~Year/Symptom)
t26
if (interactive()) {
  imsn() # select Bruvo's distance and enter "monpop_ssr" into the Repeat Length field.
  
  # It is also possible to run this from github if you are connected to the internet.
  # This allows you to access any bug fixes that may have been updated before a formal
  # release on CRAN

  shiny::runGitHub("grunwaldlab/poppr", subdir = "inst/shiny/msn_explorer")

  # You can also use your own distance matrices, but there's a small catch.
  # in order to do so, you must write a function that will subset the matrix
  # to whatever populations are in your data. Here's an example with the above

  mondist &lt;- bruvo.dist(monpop, replen = monpop_ssr)
  myDist &lt;- function(x, d = mondist){
   dm &lt;- as.matrix(d)          # Convert the dist object to a square matrix
   xi &lt;- indNames(x)           # Grab the sample names that exist
   return(as.dist(dm[xi, xi])) # return only the elements that have the names
                               # in the data set
  }
  # After executing imsn, choose:
  # Distance: custom
  # myDist
  imsn() 
}

## End(Not run)
</code></pre>

<hr>
<h2 id='incomp'>Check for samples that are incomparable due to missing data</h2><span id='topic+incomp'></span>

<h3>Description</h3>

<p>If two samples share no loci typed in common, they are incomparable and will
produce missing data in a distance matrix, which could lead to problems with
further analyses. This function finds these samples and returns a matrix of
how many other samples these are incomparable with.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>incomp(gid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="incomp_+3A_gid">gid</code></td>
<td>
<p>a genind or genclone object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a square matrix with samples that are incomparable
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(nancycats)
# These two populations have no samples that are incomparable
incomp(nancycats[pop = c(1, 17)])

# If you reduce the number of loci, we find that there are 
# incomparable samples.
incomp(nancycats[pop = c(1, 17), loc = c(1, 4)])
</code></pre>

<hr>
<h2 id='info_table'>Create a table summarizing missing data or ploidy information of a genind or
genclone object</h2><span id='topic+info_table'></span>

<h3>Description</h3>

<p>Create a table summarizing missing data or ploidy information of a genind or
genclone object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>info_table(
  gen,
  type = c("missing", "ploidy"),
  percent = TRUE,
  plot = FALSE,
  df = FALSE,
  returnplot = FALSE,
  low = "blue",
  high = "red",
  plotlab = TRUE,
  scaled = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="info_table_+3A_gen">gen</code></td>
<td>
<p>a <a href="adegenet.html#topic+genind-class">genind</a> or <a href="#topic+genclone-class">genclone</a> object.</p>
</td></tr>
<tr><td><code id="info_table_+3A_type">type</code></td>
<td>
<p><code>character</code>. What information should be returned. Choices
are &quot;missing&quot; (Default) and &quot;ploidy&quot;. See Description.</p>
</td></tr>
<tr><td><code id="info_table_+3A_percent">percent</code></td>
<td>
<p><code>logical</code>. (ONLY FOR <code>type = 'missing'</code>) If
<code>TRUE</code> (default), table and plot will represent missing data as a
percentage of each cell. If <code>FALSE</code>, the table and plot will represent
missing data as raw counts. (See details)</p>
</td></tr>
<tr><td><code id="info_table_+3A_plot">plot</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, a simple heatmap will be 
produced. If <code>FALSE</code> (default), no heatmap will be produced.</p>
</td></tr>
<tr><td><code id="info_table_+3A_df">df</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, the data will be returned as a long
form data frame. If <code>FALSE</code> (default), a matrix with samples in rows
and loci in columns will be returned.</p>
</td></tr>
<tr><td><code id="info_table_+3A_returnplot">returnplot</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, a list is returned with two
elements: <code>table</code> - the normal output and <code>plot</code> - the ggplot 
object. If <code>FALSE</code>, the table is returned.</p>
</td></tr>
<tr><td><code id="info_table_+3A_low">low</code></td>
<td>
<p><code>character</code>. What color should represent no missing data or 
lowest observed ploidy? (default: &quot;blue&quot;)</p>
</td></tr>
<tr><td><code id="info_table_+3A_high">high</code></td>
<td>
<p><code>character</code>. What color should represent the highest amount 
of missing data or observed ploidy? (default: &quot;red&quot;)</p>
</td></tr>
<tr><td><code id="info_table_+3A_plotlab">plotlab</code></td>
<td>
<p><code>logical</code>. (ONLY FOR <code>type = 'missing'</code>) If
<code>TRUE</code> (default), values of missing data greater than 0% will be
plotted. If <code>FALSE</code>, the plot will appear un-appended.</p>
</td></tr>
<tr><td><code id="info_table_+3A_scaled">scaled</code></td>
<td>
<p><code>logical</code>. (ONLY FOR <code>type = 'missing'</code>) This is for
when <code>percent = TRUE</code>. If <code>TRUE</code> (default), the color specified
in <code>high</code> will represent the highest observed value of missing data.
If <code>FALSE</code>, the color specified in <code>high</code> will represent 100%.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing data is accounted for on a per-population level.<br />
Ploidy is accounted for on a per-individual level.
</p>


<h4>For type = 'missing'</h4>

<p>This data is potentially useful for identifying areas of systematic missing
data. There are a few caveats to be aware of. </p>
 <ul>
<li>
<p><strong>Regarding counts of missing data</strong>: Each count represents the number
of individuals with missing data at each locus. The last column, &quot;mean&quot; can
be thought of as the average number of individuals with missing data per
locus. </p>
</li>
<li> <p><strong>Regarding percentage missing data</strong>: This percentage is
<strong>relative to the population and locus</strong>, not to the entire data set.
The last column, &quot;mean&quot; represents the average percent of the population
with missing data per locus. </p>
</li></ul>
 


<h4>For type = 'ploidy'</h4>

<p>This option is useful for data that has been imported with mixed ploidies.
It will summarize the relative levels of ploidy per individual per locus.
This is simply based off of observed alleles and does not provide any
further estimates.</p>



<h3>Value</h3>

<p>a matrix, data frame (<code>df = TRUE</code>), or a list (<code>returnplot 
  = TRUE</code>) representing missing data per population (<code>type = 'missing'</code>)
or ploidy per individual (<code>type = 'ploidy'</code>) in a <a href="adegenet.html#topic+genind-class">genind</a>
or <a href="#topic+genclone-class">genclone</a> object.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nancycats)
nancy.miss &lt;- info_table(nancycats, plot = TRUE, type = "missing")
data(Pinf)
Pinf.ploid &lt;- info_table(Pinf, plot = TRUE, type = "ploidy")

</code></pre>

<hr>
<h2 id='informloci'>Remove all non-phylogentically informative loci</h2><span id='topic+informloci'></span>

<h3>Description</h3>

<p>This function will facilitate in removing phylogenetically uninformative loci
from a <code><a href="#topic+genclone-class">genclone</a></code> or <code><a href="adegenet.html#topic+genind-class">genind</a></code> object. 
The user has the ability to define what uninformative means by setting a 
cutoff value for either percentage of differentiating genotypes or minor 
allele frequency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>informloci(pop, cutoff = 2/nInd(pop), MAF = 0.01, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="informloci_+3A_pop">pop</code></td>
<td>
<p>a <code><a href="#topic+genclone-class">genclone</a></code> or <code><a href="adegenet.html#topic+genind-class">genind</a></code> 
object.</p>
</td></tr>
<tr><td><code id="informloci_+3A_cutoff">cutoff</code></td>
<td>
<p><code>numeric</code>. A number from 0 to 1 defining the minimum 
number of differentiating samples.</p>
</td></tr>
<tr><td><code id="informloci_+3A_maf">MAF</code></td>
<td>
<p><code>numeric</code>. A number from 0 to 1 defining the minimum minor
allele frequency. This is passed as the <code>thresh</code> parameter of
<code><a href="adegenet.html#topic+isPoly">isPoly</a></code>.</p>
</td></tr>
<tr><td><code id="informloci_+3A_quiet">quiet</code></td>
<td>
<p><code>logical</code>. When <code>quiet = TRUE</code> (default), messages 
indicating the loci removed will be printed to screen. When <code>quiet = 
FALSE</code>, nothing will be printed to screen.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will remove uninformative loci using a traditional MAF
cutoff (using <code><a href="adegenet.html#topic+isPoly">isPoly</a></code> from <span class="pkg">adegenet</span>) as well
as analyzing the number of observed genotypes in a locus. This is important
for clonal organisms that can have fixed heterozygous sites not detected by
MAF methods.
</p>


<h3>Value</h3>

<p>A <code>genind</code> object with user-defined informative loci.
</p>


<h3>Note</h3>

<p>This will have a few side effects that affect certain analyses. First, 
the number of multilocus genotypes might be reduced due to the reduced 
number of markers (if you are only using a genind object). Second, if you 
plan on using this data for analysis of the index of association, be sure 
to use the standardized version (rbarD) that corrects for the number of 
observed loci.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We will use a dummy data set to demonstrate how this detects uninformative
# loci using both MAF and a cutoff.

genos &lt;- c("A/A", "A/B", "A/C", "B/B", "B/C", "C/C")

v &lt;- sample(genos, 100, replace = TRUE)
w &lt;- c(rep(genos[2], 99), genos[3])           # found by cutoff
x &lt;- c(rep(genos[1], 98), genos[3], genos[2]) # found by MAF
y &lt;- c(rep(genos[1], 99), genos[2])           # found by both
z &lt;- sample(genos, 100, replace = TRUE)
dat &lt;- df2genind(data.frame(v = v, w = w, x = x, y = y, z = z), sep = "/")

informloci(dat)

## Not run: 
# Ignore MAF
informloci(dat, MAF = 0)

# Ignore cutoff
informloci(dat, cutoff = 0)

# Real data
data(H3N2)
informloci(H3N2)


## End(Not run)
</code></pre>

<hr>
<h2 id='initialize+2Cbruvomat-method'>Methods used for the bruvomat object.</h2><span id='topic+initialize+2Cbruvomat-method'></span><span id='topic+dim+2Cbruvomat-method'></span><span id='topic++5B+2Cbruvomat+2CANY+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>This is not designed for user interaction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'bruvomat'
initialize(.Object, gen, replen)

## S4 method for signature 'bruvomat'
dim(x)

## S4 method for signature 'bruvomat,ANY,ANY,ANY'
x[i, j, ..., drop = FALSE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize+2B2Cbruvomat-method_+3A_.object">.Object</code></td>
<td>
<p>a character, &quot;bruvomat&quot;</p>
</td></tr>
<tr><td><code id="initialize+2B2Cbruvomat-method_+3A_gen">gen</code></td>
<td>
<p><code>"<a href="adegenet.html#topic+genind-class">genind</a>"</code> object</p>
</td></tr>
<tr><td><code id="initialize+2B2Cbruvomat-method_+3A_replen">replen</code></td>
<td>
<p>a vector of numbers indicating the repeat length for each 
microsatellite locus.</p>
</td></tr>
<tr><td><code id="initialize+2B2Cbruvomat-method_+3A_x">x</code></td>
<td>
<p>a <code>"<a href="#topic+bruvomat-class">bruvomat</a>"</code> object</p>
</td></tr>
<tr><td><code id="initialize+2B2Cbruvomat-method_+3A_i">i</code></td>
<td>
<p>vector of numerics indicating number of individuals desired</p>
</td></tr>
<tr><td><code id="initialize+2B2Cbruvomat-method_+3A_j">j</code></td>
<td>
<p>a vector of numerics corresponding to the loci desired.</p>
</td></tr>
<tr><td><code id="initialize+2B2Cbruvomat-method_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
<tr><td><code id="initialize+2B2Cbruvomat-method_+3A_drop">drop</code></td>
<td>
<p>set to <code>FALSE</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>

<hr>
<h2 id='initialize+2Cgenclone-method'>Methods used for the genclone object</h2><span id='topic+initialize+2Cgenclone-method'></span><span id='topic++5B+2Cgenclone+2CANY+2CANY+2CANY-method'></span><span id='topic+show+2Cgenclone-method'></span><span id='topic+print+2Cgenclone-method'></span>

<h3>Description</h3>

<p>Default methods for subsetting genclone objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'genclone'
initialize(.Object, ..., mlg, mlgclass = TRUE)

## S4 method for signature 'genclone,ANY,ANY,ANY'
x[i, j, ..., mlg.reset = FALSE, drop = FALSE]

## S4 method for signature 'genclone'
show(object)

## S4 method for signature 'genclone'
print(x, ..., fullnames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize+2B2Cgenclone-method_+3A_.object">.Object</code></td>
<td>
<p>a character, &quot;genclone&quot;</p>
</td></tr>
<tr><td><code id="initialize+2B2Cgenclone-method_+3A_...">...</code></td>
<td>
<p>passed on to the <code><a href="adegenet.html#topic+genind-class">genind</a></code> object.</p>
</td></tr>
<tr><td><code id="initialize+2B2Cgenclone-method_+3A_mlg">mlg</code></td>
<td>
<p>a vector where each element assigns the multilocus genotype of 
that individual in the data set.</p>
</td></tr>
<tr><td><code id="initialize+2B2Cgenclone-method_+3A_mlgclass">mlgclass</code></td>
<td>
<p>a logical value specifying whether or not to translate the 
mlg object into an MLG class object.</p>
</td></tr>
<tr><td><code id="initialize+2B2Cgenclone-method_+3A_x">x</code></td>
<td>
<p>a genclone object</p>
</td></tr>
<tr><td><code id="initialize+2B2Cgenclone-method_+3A_i">i</code></td>
<td>
<p>vector of numerics indicating number of individuals desired</p>
</td></tr>
<tr><td><code id="initialize+2B2Cgenclone-method_+3A_j">j</code></td>
<td>
<p>a vector of numerics corresponding to the loci desired.</p>
</td></tr>
<tr><td><code id="initialize+2B2Cgenclone-method_+3A_mlg.reset">mlg.reset</code></td>
<td>
<p>logical. Defaults to <code>FALSE</code>. If <code>TRUE</code>, the mlg
vector will be reset</p>
</td></tr>
<tr><td><code id="initialize+2B2Cgenclone-method_+3A_drop">drop</code></td>
<td>
<p>set to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="initialize+2B2Cgenclone-method_+3A_object">object</code></td>
<td>
<p>a genclone object</p>
</td></tr>
<tr><td><code id="initialize+2B2Cgenclone-method_+3A_fullnames">fullnames</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, then the full names of the
populations will be printed. If <code>FALSE</code>, then only the first and last
three population names are displayed.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>

<hr>
<h2 id='initialize+2CMLG-method'>Methods used for MLG objects</h2><span id='topic+initialize+2CMLG-method'></span><span id='topic++5B+2CMLG+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2CMLG+2CANY+2CANY+2CANY-method'></span><span id='topic+show+2CMLG-method'></span><span id='topic+length+2CMLG-method'></span><span id='topic+Ops+2CMLG+2CANY-method'></span><span id='topic+Math+2CMLG-method'></span><span id='topic+Math2+2CMLG-method'></span><span id='topic+Summary+2CMLG-method'></span>

<h3>Description</h3>

<p>Default methods for accessing and subsetting MLG objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MLG'
initialize(.Object, mlg)

## S4 method for signature 'MLG,ANY,ANY,ANY'
x[i, j, ..., all = FALSE, drop = TRUE]

## S4 replacement method for signature 'MLG,ANY,ANY,ANY'
x[i, j] &lt;- value

## S4 method for signature 'MLG'
show(object)

## S4 method for signature 'MLG'
length(x)

## S4 method for signature 'MLG,ANY'
Ops(e1, e2)

## S4 method for signature 'MLG'
Math(x)

## S4 method for signature 'MLG'
Math2(x, digits)

## S4 method for signature 'MLG'
Summary(x, ..., na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize+2B2CMLG-method_+3A_.object">.Object</code></td>
<td>
<p>a character, &quot;MLG&quot;</p>
</td></tr>
<tr><td><code id="initialize+2B2CMLG-method_+3A_mlg">mlg</code></td>
<td>
<p>a vector where each element assigns the multilocus genotype of 
that individual in the data set.</p>
</td></tr>
<tr><td><code id="initialize+2B2CMLG-method_+3A_x">x</code></td>
<td>
<p>an MLG object</p>
</td></tr>
<tr><td><code id="initialize+2B2CMLG-method_+3A_i">i</code></td>
<td>
<p>a vector of integers or logical values to index the MLG vector.</p>
</td></tr>
<tr><td><code id="initialize+2B2CMLG-method_+3A_j">j</code></td>
<td>
<p>One of 
</p>

<ul>
<li><p> &quot;original&quot;
</p>
</li>
<li><p> &quot;expanded&quot;
</p>
</li>
<li><p> &quot;contracted&quot;
</p>
</li>
<li><p> &quot;custom&quot;
</p>
</li></ul>
</td></tr>
<tr><td><code id="initialize+2B2CMLG-method_+3A_...">...</code></td>
<td>
<p>passed on to summary methods</p>
</td></tr>
<tr><td><code id="initialize+2B2CMLG-method_+3A_all">all</code></td>
<td>
<p>a logical value indicating whether or not to return the subset of
all MLG values or only the numeric.</p>
</td></tr>
<tr><td><code id="initialize+2B2CMLG-method_+3A_value">value</code></td>
<td>
<p>the vector of MLGs to replace. <strong>For internal use only</strong>.</p>
</td></tr>
<tr><td><code id="initialize+2B2CMLG-method_+3A_object">object</code></td>
<td>
<p>an MLG object.</p>
</td></tr>
<tr><td><code id="initialize+2B2CMLG-method_+3A_e1">e1</code></td>
<td>
<p>an MLG object</p>
</td></tr>
<tr><td><code id="initialize+2B2CMLG-method_+3A_e2">e2</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code id="initialize+2B2CMLG-method_+3A_digits">digits</code></td>
<td>
<p>the number of digits to retain</p>
</td></tr>
<tr><td><code id="initialize+2B2CMLG-method_+3A_na.rm">na.rm</code></td>
<td>
<p>passed on to summary methods</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MLG-class">MLG</a></code> <code><a href="#topic+genclone-class">genclone</a></code>
<code><a href="#topic+snpclone-class">snpclone</a></code> <code><a href="#topic+visible">visible</a></code> 
<code><a href="#topic+unique+2CMLG-method">unique,MLG-method</a></code> <code><a href="#topic+levels+2CMLG-method">levels,MLG-method</a></code>
</p>

<hr>
<h2 id='is.snpclone'>Check for validity of a genclone or snpclone object</h2><span id='topic+is.snpclone'></span><span id='topic+is.clone'></span><span id='topic+is.genclone'></span>

<h3>Description</h3>

<p>Check for validity of a genclone or snpclone object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.snpclone(x)

is.clone(x)

is.genclone(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.snpclone_+3A_x">x</code></td>
<td>
<p>a genclone or snpclone object</p>
</td></tr>
</table>


<h3>Note</h3>

<p>a <a href="#topic+genclone-class">genclone</a> object will always be a valid 
<a href="adegenet.html#topic+genind-class">genind</a> object and a <a href="#topic+snpclone-class">snpclone</a> object will always
be a valid <a href="adegenet.html#topic+genlight-class">genlight</a> object.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(sc &lt;- as.snpclone(glSim(100, 1e3, ploid=2, parallel = FALSE), 
                   parallel = FALSE, n.cores = 1L))
is.snpclone(sc)
is.clone(sc)
data(nancycats)
nanclone &lt;- as.genclone(nancycats)
is.genclone(nanclone)
</code></pre>

<hr>
<h2 id='levels+2CMLG-method'>Unique and Duplicated implementations for MLG objects</h2><span id='topic+levels+2CMLG-method'></span><span id='topic+levels+3C-+2CMLG-method'></span>

<h3>Description</h3>

<p>internal use
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MLG'
levels(x)

## S4 replacement method for signature 'MLG'
levels(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="levels+2B2CMLG-method_+3A_x">x</code></td>
<td>
<p>an MLG object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector showing the levels of custom MLGs or NULL if the 
visible slot is not set to &quot;custom&quot;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+visible">visible</a></code> <code><a href="#topic+MLG-class">MLG</a></code> 
<code><a href="#topic+genclone">genclone</a></code> <code><a href="#topic+snpclone">snpclone</a></code>
</p>

<hr>
<h2 id='locus_table'>Create a table of summary statistics per locus.</h2><span id='topic+locus_table'></span>

<h3>Description</h3>

<p>Create a table of summary statistics per locus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locus_table(
  x,
  index = "simpson",
  lev = "allele",
  population = "ALL",
  information = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locus_table_+3A_x">x</code></td>
<td>
<p>a <a href="adegenet.html#topic+genind">adegenet::genind</a> or <a href="#topic+genclone-class">genclone</a>
object.</p>
</td></tr>
<tr><td><code id="locus_table_+3A_index">index</code></td>
<td>
<p>Which diversity index to use. Choices are
</p>

<ul>
<li> <p><code>"simpson"</code> (Default) to give Simpson's index
</p>
</li>
<li> <p><code>"shannon"</code> to give the Shannon-Wiener index
</p>
</li>
<li> <p><code>"invsimpson"</code> to give the Inverse Simpson's index aka the Stoddard and
Tayor index.
</p>
</li></ul>
</td></tr>
<tr><td><code id="locus_table_+3A_lev">lev</code></td>
<td>
<p>At what level do you want to analyze diversity? Choices are
<code>"allele"</code> (Default) or <code>"genotype"</code>.</p>
</td></tr>
<tr><td><code id="locus_table_+3A_population">population</code></td>
<td>
<p>Select the populations to be analyzed. This is the
parameter <code>sublist</code> passed on to the function <code><a href="#topic+popsub">popsub()</a></code>.
Defaults to <code>"ALL"</code>.</p>
</td></tr>
<tr><td><code id="locus_table_+3A_information">information</code></td>
<td>
<p>When <code>TRUE</code> (Default), this will print out a header
of information to the R console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a table with 4 columns indicating the Number of alleles/genotypes
observed, Diversity index chosen, Nei's 1978 gene diversity (expected
heterozygosity), and Evenness.
</p>


<h3>Note</h3>

<p>The calculation of <code>Hexp</code> is <code class="reqn">(\frac{n}{n-1}) 1 - \sum_{i =
1}^k{p^{2}_{i}}</code> where p is the allele
frequencies at a given locus and n is the number of observed alleles (Nei,
1978) in each locus and then returning the average. Caution should be
exercised in interpreting the results of Hexp with polyploid organisms with
ambiguous ploidy. The lack of allelic dosage information will cause rare
alleles to be over-represented and artificially inflate the index. This is
especially true with small sample sizes.
</p>
<p>If <code>lev = "genotype"</code>, then all statistics reflect <strong>genotypic</strong> diversity
within each locus. This includes the calculation for <code>Hexp</code>, which turns
into the unbiased Simpson's index.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>References</h3>

<p>Jari Oksanen, F. Guillaume Blanchet, Roeland Kindt, Pierre Legendre, Peter
R. Minchin, R. B. O'Hara, Gavin L. Simpson, Peter Solymos, M. Henry H.
Stevens, and Helene Wagner. vegan: Community Ecology Package, 2012. R
package version 2.0-5.
</p>
<p>Niklaus J. Gr\&quot;unwald, Stephen B. Goodwin, Michael G. Milgroom, and William
E. Fry. Analysis of genotypic diversity data for populations of
microorganisms. Phytopathology, 93(6):738-46, 2003
</p>
<p>J.A. Ludwig and J.F. Reynolds. Statistical Ecology. A Primer on Methods and
Computing. New York USA: John Wiley and Sons, 1988.
</p>
<p>E.C. Pielou. Ecological Diversity. Wiley, 1975.
</p>
<p>J.A. Stoddart and J.F. Taylor. Genotypic diversity: estimation and
prediction in samples. Genetics, 118(4):705-11, 1988.
</p>
<p>Masatoshi Nei. Estimation of average heterozygosity and genetic distance
from a small number of individuals. Genetics, 89(3):583-590, 1978.
</p>
<p>Claude Elwood Shannon. A mathematical theory of communication. Bell Systems
Technical Journal, 27:379-423,623-656, 1948
</p>


<h3>See Also</h3>

<p><code><a href="vegan.html#topic+diversity">vegan::diversity()</a></code>, <code><a href="#topic+poppr">poppr()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(nancycats)
locus_table(nancycats[pop = 5])
## Not run: 
# Analyze locus statistics for the North American population of P. infestans.
# Note that due to the unknown dosage of alleles, many of these statistics
# will be artificially inflated for polyploids.
data(Pinf)
locus_table(Pinf, population = "North America")

## End(Not run)
</code></pre>

<hr>
<h2 id='make_haplotypes'>Split samples from a genind object into pseudo-haplotypes</h2><span id='topic+make_haplotypes'></span><span id='topic+make_haplotypes+2Cgenclone-method'></span><span id='topic+make_haplotypes+2Csnpclone-method'></span><span id='topic+make_haplotypes+2Cgenind-method'></span><span id='topic+make_haplotypes+2Cgenlight-method'></span><span id='topic+make_haplotypes+2CANY-method'></span>

<h3>Description</h3>

<p>Split samples from a genind object into pseudo-haplotypes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_haplotypes(gid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_haplotypes_+3A_gid">gid</code></td>
<td>
<p>a <a href="adegenet.html#topic+new.genind">genind</a> or <a href="adegenet.html#topic+genlight">genlight</a> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Certain analyses, such as <a href="#topic+poppr.amova">amova</a> work best if within-sample
variance (error) can be estimated. Practically, this is performed by
splitting the genotypes across all loci to create multiple haplotypes. This
way, the within-sample distance can be calculated and incorporated into the
model. Please note that the haplotypes generated are based on the order of
the unphased alleles in the genind object and do not represent true
haplotypes.
</p>
<p>Haploid data will be returned un-touched.
</p>


<h3>Value</h3>

<p>a haploid genind object with an extra <a href="adegenet.html#topic+strata-methods">strata</a>
column called &quot;Individual&quot;.
</p>


<h3>Note</h3>

<p>The <a href="adegenet.html#topic+accessors">other slot</a> will not be copied over to the new
genind object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+poppr.amova">poppr.amova()</a></code> <code><a href="pegas.html#topic+amova">pegas::amova()</a></code> <code><a href="#topic+as.genambig">as.genambig()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Diploid data is doubled -------------------------------------------------

data(nancycats)
nan9 &lt;- nancycats[pop = 9]
nan9hap &lt;- make_haplotypes(nan9) 
nan9              # 9 individuals from population 9
nan9hap           # 18 haplotypes
strata(nan9hap)   # strata gains a new column: Individual
indNames(nan9hap) # individuals are renamed sequentially


# Mix ploidy data can be split, but should be treated with caution --------
# 
# For example, the Pinf data set contains 86 tetraploid individuals, 
# but there appear to only be diploids and triploid genotypes. When 
# we convert to haplotypes, those with all missing data are dropped.
data(Pinf)
Pinf
pmiss &lt;- info_table(Pinf, type = "ploidy", plot = TRUE)

# No samples appear to be triploid across all loci. This will cause
# several haplotypes to have a lot of missing data.
p_haps &lt;- make_haplotypes(Pinf)
p_haps
head(genind2df(p_haps), n = 20)
</code></pre>

<hr>
<h2 id='missingno'>Treat missing data</h2><span id='topic+missingno'></span>

<h3>Description</h3>

<p>missingno gives the user four options to deal with missing data: remove loci,
remove samples, replace with zeroes, or replace with average allele counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missingno(pop, type = "loci", cutoff = 0.05, quiet = FALSE, freq = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missingno_+3A_pop">pop</code></td>
<td>
<p>a <code><a href="#topic+genclone-class">genclone</a></code> or <code><a href="adegenet.html#topic+genind-class">genind</a></code> 
object.</p>
</td></tr>
<tr><td><code id="missingno_+3A_type">type</code></td>
<td>
<p>a <code>character</code> string: can be &quot;ignore&quot;, &quot;zero&quot;, &quot;mean&quot;, 
&quot;loci&quot;, or &quot;geno&quot; (see <code>Details</code> for definitions).</p>
</td></tr>
<tr><td><code id="missingno_+3A_cutoff">cutoff</code></td>
<td>
<p><code>numeric</code>. A number from 0 to 1 indicating the allowable 
rate of missing data in either genotypes or loci. This will be ignored for 
<code>type</code> values of <code>"mean"</code> or <code>"zero"</code>.</p>
</td></tr>
<tr><td><code id="missingno_+3A_quiet">quiet</code></td>
<td>
<p>if <code>TRUE</code>, it will print to the screen the action performed.</p>
</td></tr>
<tr><td><code id="missingno_+3A_freq">freq</code></td>
<td>
<p>defaults to <code>FALSE</code>. This option is passed on to the
<code><a href="adegenet.html#topic+tab">tab</a></code> function. If <code>TRUE</code>, the matrix in the
genind object will be replaced by a numeric matrix (as opposed to integer).
THIS IS NOT RECOMMENDED. USE THE FUNCTION <code><a href="adegenet.html#topic+tab">tab</a></code>
instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These methods provide a way to deal with systematic missing data and 
to give a wrapper for <code>adegenet</code>'s <code> <a href="adegenet.html#topic+tab">tab</a></code> function. 
ALL OF THESE ARE TO BE USED WITH CAUTION. 
</p>
<p>Using this function with polyploid data (where missing data is coded as &quot;0&quot;)
may give spurious results.
</p>


<h4>Treatment types</h4>

 
 
<ul>
<li><p><code>"ignore"</code> - does not remove or replace missing data. 
</p>
</li>
<li><p><code>"loci"</code> - removes all loci containing missing data in the entire
data set. 
</p>
</li>
<li><p><code>"genotype"</code> - removes any genotypes/isolates/individuals with
missing data.
</p>
</li>
<li><p><code>"mean"</code> - replaces all NA's with the mean of the alleles for the
entire data set. 
</p>
</li>
<li><p><code>"zero"</code> or <code>"0"</code> - replaces all NA's with &quot;0&quot;. Introduces
more diversity.
</p>
</li></ul>




<h3>Value</h3>

<p>a <code><a href="#topic+genclone-class">genclone</a></code> or <code><a href="adegenet.html#topic+genind-class">genind</a></code> object.
</p>


<h3>Note</h3>

<p><em>&quot;wild missingno appeared!&quot;</em>
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>See Also</h3>

<p><code><a href="adegenet.html#topic+tab">tab</a></code>, <code><a href="#topic+poppr">poppr</a></code>, <code><a href="#topic+poppr.amova">poppr.amova</a></code>,
<code><a href="#topic+nei.dist">nei.dist</a></code>, <code><a href="#topic+aboot">aboot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(nancycats)

nancy.locina &lt;- missingno(nancycats, type = "loci")

## Found 617 missing values.
## 2 loci contained missing values greater than 5%.
## Removing 2 loci : fca8 fca45 

nancy.genona &lt;- missingno(nancycats, type = "geno")

## Found 617 missing values.
## 38 genotypes contained missing values greater than 5%.
## Removing 38 genotypes : N215 N216 N188 N189 N190 N191 N192 N302 N304 N310 
## N195 N197 N198 N199 N200 N201 N206 N182 N184 N186 N298 N299 N300 N301 N303 
## N282 N283 N288 N291 N292 N293 N294 N295 N296 N297 N281 N289 N290  

# Replacing all NA with "0" (see tab in the adegenet package).
nancy.0 &lt;- missingno(nancycats, type = "0")

## Replaced 617 missing values 

# Replacing all NA with the mean of each column (see tab in the
# adegenet package).
nancy.mean &lt;- missingno(nancycats, type = "mean")

## Replaced 617 missing values 
</code></pre>

<hr>
<h2 id='mlg'>Create counts, vectors, and matrices of multilocus genotypes.</h2><span id='topic+mlg'></span><span id='topic+mlg.table'></span><span id='topic+mlg.vector'></span><span id='topic+mlg.crosspop'></span><span id='topic+mlg.id'></span>

<h3>Description</h3>

<p>Create counts, vectors, and matrices of multilocus genotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlg(gid, quiet = FALSE)

mlg.table(
  gid,
  strata = NULL,
  sublist = "ALL",
  exclude = NULL,
  blacklist = NULL,
  mlgsub = NULL,
  bar = TRUE,
  plot = TRUE,
  total = FALSE,
  color = FALSE,
  background = FALSE,
  quiet = FALSE
)

mlg.vector(gid, reset = FALSE)

mlg.crosspop(
  gid,
  strata = NULL,
  sublist = "ALL",
  exclude = NULL,
  blacklist = NULL,
  mlgsub = NULL,
  indexreturn = FALSE,
  df = FALSE,
  quiet = FALSE
)

mlg.id(gid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mlg_+3A_gid">gid</code></td>
<td>
<p>a <a href="adegenet.html#topic+new.genind">adegenet::genind</a>, <a href="#topic+genclone-class">genclone</a>, <a href="adegenet.html#topic+genlight">adegenet::genlight</a>, or <a href="#topic+snpclone-class">snpclone</a> object.</p>
</td></tr>
<tr><td><code id="mlg_+3A_quiet">quiet</code></td>
<td>
<p><code>Logical</code>. If FALSE, progress of functions will be printed
to the screen.</p>
</td></tr>
<tr><td><code id="mlg_+3A_strata">strata</code></td>
<td>
<p>a formula specifying the strata at which computation is to be
performed.</p>
</td></tr>
<tr><td><code id="mlg_+3A_sublist">sublist</code></td>
<td>
<p>a <code>vector</code> of population names or indices that the user
wishes to keep. Default to &quot;ALL&quot;.</p>
</td></tr>
<tr><td><code id="mlg_+3A_exclude">exclude</code></td>
<td>
<p>a <code>vector</code> of population names or indexes that the user
wishes to discard. Default to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mlg_+3A_blacklist">blacklist</code></td>
<td>
<p>DEPRECATED, use exclude.</p>
</td></tr>
<tr><td><code id="mlg_+3A_mlgsub">mlgsub</code></td>
<td>
<p>a <code>vector</code> of multilocus genotype indices with which to
subset <code>mlg.table</code> and <code>mlg.crosspop</code>. NOTE: The resulting table
from <code>mlg.table</code> will only contain countries with those MLGs</p>
</td></tr>
<tr><td><code id="mlg_+3A_bar">bar</code></td>
<td>
<p>deprecated. Same as <code>plot</code>. Retained for compatibility.</p>
</td></tr>
<tr><td><code id="mlg_+3A_plot">plot</code></td>
<td>
<p><code>logical</code> If <code>TRUE</code>, a bar graph for each population
will be displayed showing the relative abundance of each MLG within the
population.</p>
</td></tr>
<tr><td><code id="mlg_+3A_total">total</code></td>
<td>
<p><code>logical</code> If <code>TRUE</code>, a row containing the sum of all
represented MLGs is appended to the matrix produced by mlg.table.</p>
</td></tr>
<tr><td><code id="mlg_+3A_color">color</code></td>
<td>
<p>an option to display a single barchart for mlg.table, colored by
population (note, this becomes facetted if 'background = TRUE').</p>
</td></tr>
<tr><td><code id="mlg_+3A_background">background</code></td>
<td>
<p>an option to display the the total number of MLGs across
populations per facet in the background of the plot.</p>
</td></tr>
<tr><td><code id="mlg_+3A_reset">reset</code></td>
<td>
<p>logical. For genclone objects, the MLGs are defined by the input
data, but they do not change if more or less information is added (i.e.
loci are dropped). Setting 'reset = TRUE' will recalculate MLGs.
Default is 'FALSE', returning the MLGs defined in the @mlg slot.</p>
</td></tr>
<tr><td><code id="mlg_+3A_indexreturn">indexreturn</code></td>
<td>
<p><code>logical</code> If <code>TRUE</code>, a vector will be returned
to index the columns of <code>mlg.table</code>.</p>
</td></tr>
<tr><td><code id="mlg_+3A_df">df</code></td>
<td>
<p><code>logical</code> If <code>TRUE</code>, return a data frame containing the
counts of the MLGs and what countries they are in. Useful for making graphs
with <a href="ggplot2.html#topic+ggplot">ggplot</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multilocus genotypes are the unique combination of alleles across
all loci. For details of how these are calculated see <code>vignette("mlg", package = "poppr")</code>. In short, for genind and genclone objects, they are
calculated by using a rank function on strings of alleles, which is
sensitive to missing data. For genlight and snpclone objects, they are
calculated with distance methods via <a href="#topic+bitwise.dist">bitwise.dist</a> and
<a href="#topic+mlg.filter">mlg.filter</a>, which means that these are insensitive to missing
data. Three different types of MLGs can be defined in <span class="pkg">poppr</span>:
</p>

<ul>
<li> <p><strong>original</strong> the default definition of multilocus genotypes as
detailed above
</p>
</li>
<li> <p><strong>contracted</strong> these are multilocus genotypes collapsed into multilocus
lineages (<a href="#topic+mll">mll</a>) with genetic distance via <a href="#topic+mlg.filter">mlg.filter</a>
</p>
</li>
<li> <p><strong>custom</strong> user-defined multilocus genotypes. These are useful for
information such as mycelial compatibility groups
</p>
</li></ul>

<p><strong>All of the functions documented here will work on any of the MLG types
defined in <span class="pkg">poppr</span></strong>
</p>


<h3>Value</h3>



<h4>mlg</h4>

<p>an integer describing the number of multilocus genotypes observed.
</p>



<h4>mlg.table</h4>

<p>a matrix with columns indicating unique multilocus genotypes and rows
indicating populations. This table can be used with the funciton
<a href="#topic+diversity_stats">diversity_stats</a> to calculate the Shannon-Weaver index (H), Stoddart and
Taylor's index (aka inverse Simpson's index; G), Simpson's index (lambda),
and evenness (E5).
</p>



<h4>mlg.vector</h4>

<p>a numeric vector naming the multilocus genotype of each individual in the
dataset.
</p>



<h4>mlg.crosspop</h4>


<ul>
<li> <p><strong>default</strong> a <code>list</code> where each element contains a named integer
vector representing the number of individuals represented from each
population in that MLG
</p>
</li>
<li> <p><code>indexreturn = TRUE</code> a <code>vector</code> of integers defining the multilocus
genotypes that have individuals crossing populations
</p>
</li>
<li> <p><code>df = TRUE</code> A long form data frame with the columns: MLG, Population,
Count. Useful for graphing with ggplot2
</p>
</li></ul>




<h4>mlg.id</h4>

<p>a list of multilocus genotypes with the associated individual names per MLG.
</p>



<h3>Note</h3>

<p>The resulting matrix of 'mlg.table' can be used for analysis with 
the <span class="pkg">vegan</span> package.
</p>
<p>mlg.vector will recalculate the mlg vector for
[adegenet::genind] objects and will return the contents of the mlg
slot in [genclone][genclone-class] objects. This means that MLGs will be
different for subsetted [adegenet::genind] objects.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>See Also</h3>

<p><code><a href="vegan.html#topic+diversity">vegan::diversity()</a></code>
<a href="#topic+diversity_stats">diversity_stats</a>
<a href="#topic+popsub">popsub</a>
<a href="#topic+mll">mll</a>
<a href="#topic+mlg.filter">mlg.filter</a>
<a href="#topic+mll.custom">mll.custom</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load the data set
data(Aeut)

# Investigate the number of multilocus genotypes.
amlg &lt;- mlg(Aeut)
amlg # 119

# show the multilocus genotype vector 
avec &lt;- mlg.vector(Aeut)
avec 

# Get a table
atab &lt;- mlg.table(Aeut, color = TRUE)
atab

# See where multilocus genotypes cross populations
acrs &lt;- mlg.crosspop(Aeut) # MLG.59: (2 inds) Athena Mt. Vernon

# See which individuals belong to each MLG
aid &lt;- mlg.id(Aeut)
aid["59"] # individuals 159 and 57

## Not run: 

# For the mlg.table, you can also choose to display the number of MLGs across
# populations in the background

mlg.table(Aeut, background = TRUE)
mlg.table(Aeut, background = TRUE, color = TRUE)

# A simple example. 10 individuals, 5 genotypes.
mat1 &lt;- matrix(ncol=5, 25:1)
mat1 &lt;- rbind(mat1, mat1)
mat &lt;- matrix(nrow=10, ncol=5, paste(mat1,mat1,sep="/"))
mat.gid &lt;- df2genind(mat, sep="/")
mlg(mat.gid)
mlg.vector(mat.gid)
mlg.table(mat.gid)

# Now for a more complicated example.
# Data set of 1903 samples of the H3N2 flu virus genotyped at 125 SNP loci.
data(H3N2)
mlg(H3N2, quiet = FALSE)

H.vec &lt;- mlg.vector(H3N2)

# Changing the population vector to indicate the years of each epidemic.
pop(H3N2) &lt;- other(H3N2)$x$country
H.tab &lt;- mlg.table(H3N2, plot = FALSE, total = TRUE)

# Show which genotypes exist accross populations in the entire dataset.
res &lt;- mlg.crosspop(H3N2, quiet = FALSE)

# Let's say we want to visualize the multilocus genotype distribution for the
# USA and Russia
mlg.table(H3N2, sublist = c("USA", "Russia"), bar=TRUE)

# An exercise in subsetting the output of mlg.table and mlg.vector.
# First, get the indices of each MLG duplicated across populations.
inds &lt;- mlg.crosspop(H3N2, quiet = FALSE, indexreturn = TRUE)

# Since the columns of the table from mlg.table are equal to the number of
# MLGs, we can subset with just the columns.
H.sub &lt;- H.tab[, inds]

# We can also do the same by using the mlgsub flag.
H.sub &lt;- mlg.table(H3N2, mlgsub = inds)

# We can subset the original data set using the output of mlg.vector to
# analyze only the MLGs that are duplicated across populations. 
new.H &lt;- H3N2[H.vec %in% inds, ]


## End(Not run)
</code></pre>

<hr>
<h2 id='MLG-class'>MLG class</h2><span id='topic+MLG-class'></span><span id='topic+MLG'></span>

<h3>Description</h3>

<p>A class to store multilocus genotypes in genclone objects. This is intended
for internal use only.
</p>


<h3>Slots</h3>


<dl>
<dt><code>mlg</code></dt><dd><p>a list containing four vectors, one for each type of MLG 
manipulation.</p>
</dd>
<dt><code>visible</code></dt><dd><p>a character specifying which MLG type is to be displayed and 
accessed.</p>
</dd>
<dt><code>distname</code></dt><dd><p>the name of the distance function or matrix used to collapse 
mlgs.</p>
</dd>
<dt><code>distenv</code></dt><dd><p>the environment that contains the distance function or matrix</p>
</dd>
<dt><code>distargs</code></dt><dd><p>the arguments provided to compute the distance function.</p>
</dd>
<dt><code>distalgo</code></dt><dd><p>the algorithm used to contract multilocus genotypes.</p>
</dd>
<dt><code>cutoff</code></dt><dd><p>Two numbers specifying the cutoff value for expanding and 
collapsing MLGs.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genclone-class">genclone</a></code> <code><a href="#topic+snpclone-class">snpclone</a></code>
<code><a href="#topic+mll">mll</a></code> For developers: <code><a href="#topic+visible">visible</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# These examples will simply show you what you can do with these
set.seed(5000)
(x &lt;- sample(10, 20, replace = TRUE))
(m &lt;- new("MLG", x))

 visible(m) # original is always default
 
 m[]       # adding braces after the object will always return a vector of 
           # the same type as defined in "visible"
           
 m + 1     # You can do math on the numeric ones
 
 visible(m) &lt;- "custom"
 m + 2     # This should throw a warning
 # The types are stored in a data frame. You can retrieve them easily:
 visible(m) &lt;- "original"
 m
 m[, "custom"]
 
 # Important for subsetting, if you subset the object, normally, it will 
 # return a vector unless you specify all = TRUE
 m[1:10]             # original vector
 m[1:10, all = TRUE] # still class MLG

</code></pre>

<hr>
<h2 id='mlg.filter'>MLG definitions based on genetic distance</h2><span id='topic+mlg.filter'></span><span id='topic+mlg.filter+2Cgenclone-method'></span><span id='topic+mlg.filter+2Csnpclone-method'></span><span id='topic+mlg.filter+2Cgenind-method'></span><span id='topic+mlg.filter+2Cgenlight-method'></span><span id='topic+mlg.filter+3C-'></span><span id='topic+mlg.filter+3C-+2Cgenclone-method'></span><span id='topic+mlg.filter+3C-+2Cgenind-method'></span><span id='topic+mlg.filter+3C-+2Csnpclone-method'></span><span id='topic+mlg.filter+3C-+2Cgenlight-method'></span>

<h3>Description</h3>

<p>Multilocus genotypes are initially defined by naive string matching, but this
definition does not take into account missing data or genotyping error,
casting these as unique genotypes. Defining multilocus genotypes by genetic
distance allows you to incorporate genotypes that have missing data o
genotyping error into their parent clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlg.filter(
  pop,
  threshold = 0,
  missing = "asis",
  memory = FALSE,
  algorithm = "farthest_neighbor",
  distance = "diss.dist",
  threads = 1L,
  stats = "MLGs",
  ...
)

mlg.filter(
  pop,
  missing = "asis",
  memory = FALSE,
  algorithm = "farthest_neighbor",
  distance = "diss.dist",
  threads = 1L,
  ...
) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mlg.filter_+3A_pop">pop</code></td>
<td>
<p>a <code><a href="#topic+genclone-class">genclone</a></code>, <code><a href="#topic+snpclone-class">snpclone</a></code>, or
<code><a href="adegenet.html#topic+genind-class">genind</a></code> object.</p>
</td></tr>
<tr><td><code id="mlg.filter_+3A_threshold">threshold</code></td>
<td>
<p>a number indicating the minimum distance two MLGs must be
separated by to be considered different. Defaults to 0, which will reflect
the original (naive) MLG definition.</p>
</td></tr>
<tr><td><code id="mlg.filter_+3A_missing">missing</code></td>
<td>
<p>any method to be used by <code><a href="#topic+missingno">missingno</a></code>: &quot;mean&quot;, 
&quot;zero&quot;, &quot;loci&quot;, &quot;genotype&quot;, or &quot;asis&quot; (default).</p>
</td></tr>
<tr><td><code id="mlg.filter_+3A_memory">memory</code></td>
<td>
<p>whether this function should remember the last distance matrix 
it generated. TRUE will attempt to reuse the last distance matrix if the 
other parameters are the same. (default) FALSE will ignore any stored 
matrices and not store any it generates.</p>
</td></tr>
<tr><td><code id="mlg.filter_+3A_algorithm">algorithm</code></td>
<td>
<p>determines the type of clustering to be done. 
</p>

<dl>
<dt>&quot;farthest_neighbor&quot;</dt><dd><p><em> (default) </em>merges clusters based on the 
maximum distance between points in either cluster. This is the strictest of
the three.</p>
</dd>
<dt>&quot;nearest_neighbor&quot;</dt><dd><p> merges clusters based on the minimum distance
between points in either cluster. This is the loosest of the three.</p>
</dd>
<dt>&quot;average_neighbor&quot;</dt><dd><p> merges clusters based on the average distance
between every pair of points between clusters.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="mlg.filter_+3A_distance">distance</code></td>
<td>
<p>a character or function defining the distance to be applied 
to pop. Defaults to <code><a href="#topic+diss.dist">diss.dist</a></code> for genclone objects and
<code><a href="#topic+bitwise.dist">bitwise.dist</a></code> for snpclone objects. A matrix or table
containing distances between individuals (such as the output of 
<code><a href="#topic+rogers.dist">rogers.dist</a></code>) is also accepted for this parameter.</p>
</td></tr>
<tr><td><code id="mlg.filter_+3A_threads">threads</code></td>
<td>
<p>(unused) Previously, this was the maximum number of parallel 
threads to be used within this function. Default is 1 indicating that this
function will run serially. Any other number will result in a warning.</p>
</td></tr>
<tr><td><code id="mlg.filter_+3A_stats">stats</code></td>
<td>
<p>a character vector specifying which statistics should be
returned (details below). Choices are &quot;MLG&quot;, &quot;THRESHOLDS&quot;, &quot;DISTANCES&quot;,
&quot;SIZES&quot;, or &quot;ALL&quot;. If choosing &quot;ALL&quot; or more than one, a named list will be
returned.</p>
</td></tr>
<tr><td><code id="mlg.filter_+3A_...">...</code></td>
<td>
<p>any parameters to be passed off to the distance method.</p>
</td></tr>
<tr><td><code id="mlg.filter_+3A_value">value</code></td>
<td>
<p>the threshold at which genotypes should be collapsed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will take in any distance matrix or function and
collapse multilocus genotypes below a given threshold. If you use this
function as the assignment method (mlg.filter(myData, distance = myDist) &lt;-
0.5), the distance function or matrix will be remembered by the object. This
means that if you define your own distance matrix or function, you must keep
it in memory to further utilize mlg.filter.
</p>


<h3>Value</h3>

<p>Default, a vector of collapsed multilocus genotypes. Otherwise, any
combination of the following:
</p>


<h4>MLGs</h4>

<p>a numeric vector defining the multilocus genotype cluster of each
individual in the dataset. Each genotype cluster is separated from every
other genotype cluster by at least the defined threshold value, as 
calculated by the selected algorithm.
</p>



<h4>THRESHOLDS</h4>

<p>A numeric vector representing the thresholds <strong>beyond</strong> which clusters
of multilocus genotypes were collapsed. 
</p>



<h4>DISTANCES</h4>

<p>A square matrix representing the distances between each cluster.
</p>



<h4>SIZES</h4>

<p>The sizes of the multilocus genotype clusters in order. 
</p>



<h3>Note</h3>

<p><code>mlg.vector</code> makes use of <code>mlg.vector</code> grouping prior to 
applying the given threshold. Genotype numbers returned by
<code>mlg.vector</code> represent the lowest numbered genotype (as returned by
<code>mlg.vector</code>) in in each new multilocus genotype. Therefore
<strong><code>mlg.filter</code> and <code>mlg.vector</code> return the same vector when
threshold is set to 0 or less</strong>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filter_stats">filter_stats</a></code>, 
<code><a href="#topic+cutoff_predictor">cutoff_predictor</a></code>, 
<code><a href="#topic+mll">mll</a></code>, 
<code><a href="#topic+genclone">genclone</a></code>, 
<code><a href="#topic+snpclone">snpclone</a></code>, 
<code><a href="#topic+diss.dist">diss.dist</a></code>, 
<code><a href="#topic+bruvo.dist">bruvo.dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(partial_clone)
pc &lt;- as.genclone(partial_clone, threads = 1L) # convert to genclone object

# Basic Use ---------------------------------------------------------------


# Show MLGs at threshold 0.05
mlg.filter(pc, threshold = 0.05, distance = "nei.dist", threads = 1L)
pc # 26 mlgs

# Set MLGs at threshold 0.05
mlg.filter(pc, distance = "nei.dist", threads = 1L) &lt;- 0.05
pc # 25 mlgs

## Not run: 

# The distance definition is persistant
mlg.filter(pc) &lt;- 0.1
pc # 24 mlgs

# But you can still change the definition
mlg.filter(pc, distance = "diss.dist", percent = TRUE) &lt;- 0.1
pc

# Choosing a threshold ----------------------------------------------------


# Thresholds for collapsing multilocus genotypes should not be arbitrary. It
# is important to consider what threshold is suitable. One method of choosing
# a threshold is to find a gap in the distance distribution that represents
# clonal groups. You can look at this by analyzing the distribution of all
# possible thresholds with the function "cutoff_predictor".

# For this example, we'll use Bruvo's distance to predict the cutoff for
# P. infestans.

data(Pinf)
Pinf
# Repeat lengths are necessary for Bruvo's distance
(pinfreps &lt;- fix_replen(Pinf, c(2, 2, 6, 2, 2, 2, 2, 2, 3, 3, 2)))

# Now we can collect information of the thresholds. We can set threshold = 1
# because we know that this will capture the maximum possible distance:
(thresholds &lt;- mlg.filter(Pinf, distance = bruvo.dist, stats = "THRESHOLDS",
                          replen = pinfreps, threshold = 1))
# We can use these thresholds to find an appropriate cutoff
(pcut &lt;- cutoff_predictor(thresholds))
mlg.filter(Pinf, distance = bruvo.dist, replen = pinfreps) &lt;- pcut
Pinf

# This can also be visualized with the "filter_stats" function.

# Special case: threshold = 0 ---------------------------------------------


# It's important to remember that a threshold of 0 is equal to the original
# MLG definition. This example will show a data set that contains genotypes
# with missing data that share all alleles with other genotypes except for 
# the missing one.

data(monpop)
monpop # 264 mlg
mlg.filter(monpop) &lt;- 0
nmll(monpop) # 264 mlg

# In order to merge these genotypes with missing data, we should set the 
# threshold to be slightly higher than 0. We will use the smallest fraction 
# the computer can store.

mlg.filter(monpop) &lt;- .Machine$double.eps ^ 0.5
nmll(monpop) # 236 mlg

# Custom distance ---------------------------------------------------------

# Custom genetic distances can be used either in functions from other
# packages or user-defined functions

data(Pinf)
Pinf
mlg.filter(Pinf, distance = function(x) dist(tab(x))) &lt;- 3
Pinf
mlg.filter(Pinf) &lt;- 4
Pinf

# genlight / snpclone objects ---------------------------------------------


set.seed(999)
gc &lt;- as.snpclone(glSim(100, 0, n.snp.struc = 1e3, ploidy = 2))
gc # 100 mlgs
mlg.filter(gc) &lt;- 0.25
gc # 82 mlgs


## End(Not run)
</code></pre>

<hr>
<h2 id='mll'>Access and manipulate multilocus lineages.</h2><span id='topic+mll'></span><span id='topic+mll+2Cgenclone-method'></span><span id='topic+mll+2Csnpclone-method'></span><span id='topic+mll+2Cgenind-method'></span><span id='topic+mll+2Cgenlight-method'></span><span id='topic+nmll'></span><span id='topic+nmll+2Cgenclone-method'></span><span id='topic+nmll+2Csnpclone-method'></span><span id='topic+nmll+2Cgenind-method'></span><span id='topic+nmll+2Cgenlight-method'></span><span id='topic+mll+3C-'></span><span id='topic+mll+3C-+2Cgenclone-method'></span><span id='topic+mll+3C-+2Csnpclone-method'></span>

<h3>Description</h3>

<p>The following methods allow the user to access and manipulate multilocus 
lineages in genclone or snpclone objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mll(x, type = NULL)

nmll(x, type = NULL)

mll(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mll_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+genclone-class">genclone</a> or <a href="#topic+snpclone-class">snpclone</a> object.</p>
</td></tr>
<tr><td><code id="mll_+3A_type">type</code></td>
<td>
<p>a character specifying &quot;original&quot;, &quot;contracted&quot;, or &quot;custom&quot;
defining they type of mlgs to return. Defaults to what is set in the
object.</p>
</td></tr>
<tr><td><code id="mll_+3A_value">value</code></td>
<td>
<p>a character specifying which mlg type is visible in the object.
See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="#topic+genclone-class">genclone</a> and <a href="#topic+snpclone-class">snpclone</a> objects have a
slot for an internal class of object called <a href="#topic+MLG-class">MLG</a>. This class
allows the storage of flexible mll definitions: </p>
 <ul>
<li><p> &quot;original&quot;
- naive mlgs defined by string comparison. This is default. </p>
</li>
<li>
<p>&quot;contracted&quot; - mlgs defined by a genetic distance threshold. </p>
</li>
<li><p> &quot;custom&quot;
- user-defined MLGs </p>
</li></ul>



<h3>Value</h3>

<p>an object of the same type as x.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mll.custom">mll.custom</a></code> <code><a href="#topic+mlg.table">mlg.table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(partial_clone)
pc &lt;- as.genclone(partial_clone)
mll(pc)
mll(pc) &lt;- "custom"
mll(pc)
mll.levels(pc) &lt;- LETTERS
mll(pc)
</code></pre>

<hr>
<h2 id='mll.custom'>Define custom multilocus lineages</h2><span id='topic+mll.custom'></span><span id='topic+mll.custom+2Cgenclone-method'></span><span id='topic+mll.custom+2Csnpclone-method'></span><span id='topic+mll.custom+3C-'></span><span id='topic+mll.custom+3C-+2Cgenclone-method'></span><span id='topic+mll.custom+3C-+2Csnpclone-method'></span><span id='topic+mll.levels'></span><span id='topic+mll.levels+2Cgenclone-method'></span><span id='topic+mll.levels+2Csnpclone-method'></span><span id='topic+mll.levels+3C-'></span><span id='topic+mll.levels+3C-+2Cgenclone-method'></span><span id='topic+mll.levels+3C-+2Csnpclone-method'></span>

<h3>Description</h3>

<p>This function will allow you to define custom multilocus lineages for your
data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mll.custom(x, set = TRUE, value)

mll.custom(x, set = TRUE) &lt;- value

mll.levels(x, set = TRUE, value)

mll.levels(x, set = TRUE) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mll.custom_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+genclone-class">genclone</a> or <a href="#topic+snpclone-class">snpclone</a> object.</p>
</td></tr>
<tr><td><code id="mll.custom_+3A_set">set</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), the visible mlls will be set to
'custom'.</p>
</td></tr>
<tr><td><code id="mll.custom_+3A_value">value</code></td>
<td>
<p>a vector that defines the multilocus lineages for your data.
This can be a vector of ANYTHING that can be turned into a factor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of the same type as x
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mll">mll</a></code> <code><a href="#topic+mlg.table">mlg.table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(partial_clone)
pc &lt;- as.genclone(partial_clone)
mll.custom(pc) &lt;- LETTERS[mll(pc)]
mll(pc)

# Let's say we had a mistake and the A mlg was actually B. 
mll.levels(pc)[mll.levels(pc) == "A"] &lt;- "B"
mll(pc)

# Set the MLL back to the original definition.
mll(pc) &lt;- "original"
mll(pc)
</code></pre>

<hr>
<h2 id='mll.reset'>Reset multilocus lineages</h2><span id='topic+mll.reset'></span><span id='topic+mll.reset+2Cgenclone-method'></span><span id='topic+mll.reset+2Csnpclone-method'></span>

<h3>Description</h3>

<p>This function will allow you to reset multilocus lineages for your data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mll.reset(x, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mll.reset_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+genclone-class">genclone</a> or <a href="#topic+snpclone-class">snpclone</a> object.</p>
</td></tr>
<tr><td><code id="mll.reset_+3A_value">value</code></td>
<td>
<p>a character vector that specifies which levels you wish to be 
reset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of the same type as x
</p>


<h3>Note</h3>

<p>This method has no assignment method. If &quot;original&quot; is not contained in
&quot;value&quot;, it is assumed that the &quot;original&quot; definition will be used to reset
the MLGs.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mll">mll</a></code> <code><a href="#topic+mlg.table">mlg.table</a></code> <code><a href="#topic+mll.custom">mll.custom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This data set was a subset of a larger data set, so the multilocus
# genotypes are not all sequential
data(Pinf)
mll(Pinf) &lt;- "original"
mll(Pinf)

# If we use mll.reset, then it will become sequential
Pinf.new &lt;- mll.reset(Pinf, TRUE) # reset all
mll(Pinf.new)

## Not run: 

# It is possible to reset only specific mll definitions. For example, let's
# say that we wanted to filter our multilocus genotypes by nei's distance
mlg.filter(Pinf, dist = nei.dist, missing = "mean") &lt;- 0.02

# And we wanted to set those as custom genotypes,
mll.custom(Pinf) &lt;- mll(Pinf, "contracted")
mll.levels(Pinf) &lt;- .genlab("MLG", nmll(Pinf, "custom"))

# We could reset just the original and the filtered if we wanted to and keep
# the custom as it were.

Pinf.new &lt;- mll.reset(Pinf, c("original", "contracted"))

mll(Pinf.new, "original")
mll(Pinf.new, "contracted")
mll(Pinf.new, "custom")

# If "original" is not one of the values, then that is used as a baseline.
Pinf.orig &lt;- mll.reset(Pinf, "contracted")
mll(Pinf.orig, "contracted")
mll(Pinf.new, "contracted")

## End(Not run)

</code></pre>

<hr>
<h2 id='monpop'>Peach brown rot pathogen *Monilinia fructicola*</h2><span id='topic+monpop'></span>

<h3>Description</h3>

<p>This is microsatellite data for a population of the haploid 
plant pathogen *Monilinia fructicola* that causes disease within peach
tree canopies (Everhart &amp; Scherm, 2014). Entire populations within trees
were sampled across 3 years (2009, 2010, and 2011) in a total of four
trees, where one tree was sampled in all three years, for a total of 6
within-tree populations. Within each year, samples in the spring were taken
from affected blossoms (termed &quot;BB&quot; for blossom blight) and in late summer
from affected fruits (termed &quot;FR&quot; for fruit rot). There are a total of 694 
isolates with 65 to 173 isolates within each canopy population that were 
characterized using a set of 13 microsatellite markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(monpop)
</code></pre>


<h3>Format</h3>

<p>a [genclone-class] object with 3 hierarchical levels 
coded into one population factor. These are named &quot;Tree&quot;, &quot;Year&quot;, and 
&quot;Symptom&quot;
</p>


<h3>References</h3>

<p>SE Everhart, H Scherm, (2015) Fine-scale genetic structure of 
*Monilinia fructicola* during brown rot epidemics within individual
peach tree canopies. Phytopathology 105:542-549 doi:
<a href="https://doi.org/10.1094/PHYTO-03-14-0088-R">doi:10.1094/PHYTO-03-14-0088-R</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(monpop)
splitStrata(monpop) &lt;- ~Tree/Year/Symptom
setPop(monpop) &lt;- ~Symptom/Year
monpop
</code></pre>

<hr>
<h2 id='nei.dist'>Calculate Genetic Distance for a genind or genclone object.</h2><span id='topic+nei.dist'></span><span id='topic+edwards.dist'></span><span id='topic+rogers.dist'></span><span id='topic+reynolds.dist'></span><span id='topic+provesti.dist'></span><span id='topic+prevosti.dist'></span>

<h3>Description</h3>

<p>These functions are modified from the function <a href="adegenet.html#topic+dist.genpop">dist.genpop</a> to
be applicable for distances between individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nei.dist(x, warning = TRUE)

edwards.dist(x)

rogers.dist(x)

reynolds.dist(x)

provesti.dist(x)

prevosti.dist
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nei.dist_+3A_x">x</code></td>
<td>
<p>a <a href="adegenet.html#topic+genind-class">genind</a>, <a href="#topic+genclone-class">genclone</a>, or matrix object.</p>
</td></tr>
<tr><td><code id="nei.dist_+3A_warning">warning</code></td>
<td>
<p>If <code>TRUE</code>, a warning will be printed if any infinite 
values are detected and replaced. If <code>FALSE</code>, these values will be 
replaced without warning. See Details below.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>function</code> of length 1.
</p>


<h3>Details</h3>

<p>It is important to be careful with the interpretation of these 
distances as they were originally intended for calculation of 
between-population distance. As Nei's distance is the negative log of 0:1, 
this means that it is very possible to obtain distances of infinity. When 
this happens, infinite values are corrected to be 10 * max(D) where D is
the distance matrix without infinite values.
</p>


<h3>Value</h3>

<p>an object of class dist with the same number of observations as the 
number of individuals in your data.
</p>


<h3>Note</h3>

<p>Prevosti's distance is identical to <code><a href="#topic+diss.dist">diss.dist</a></code>, except 
that <code><a href="#topic+diss.dist">diss.dist</a></code> is optimized for a larger number of 
individuals (n &gt; 125) at the cost of required memory. Both
<code>prevosti.dist</code> and <code>provesti.dist</code> are the same function,
<code>provesti.dist</code> is a spelling error and exists for backwards
compatibility.
</p>
<p>These distances were adapted from the <span class="pkg">adegenet</span> function
<code><a href="adegenet.html#topic+dist.genpop">dist.genpop</a></code> to work with <code><a href="adegenet.html#topic+genind-class">genind</a></code> objects.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar (poppr adaptation)
Thibaut Jombart (adegenet adaptation)
Daniel Chessel (ade4)
</p>


<h3>References</h3>

<p>Nei, M. (1972) Genetic distances between populations. American Naturalist,
106, 283-292. 
</p>
<p>Nei M. (1978) Estimation of average heterozygosity and genetic
distance from a small number of individuals. Genetics, 23, 341-369. 
</p>
<p>Avise, J. C. (1994) Molecular markers, natural history and evolution. Chapman &amp; Hall,
London.
</p>
<p>Edwards, A.W.F. (1971) Distance between populations on the basis of gene
frequencies. Biometrics, 27, 873-881. 
</p>
<p>Cavalli-Sforza L.L. and Edwards A.W.F.
(1967) Phylogenetic analysis: models and estimation procedures. Evolution,
32, 550-570. 
</p>
<p>Hartl, D.L. and Clark, A.G. (1989) Principles of population
genetics. Sinauer Associates, Sunderland, Massachussetts (p. 303).
</p>
<p>Reynolds, J. B., B. S. Weir, and C. C. Cockerham. (1983) Estimation of the
coancestry coefficient: basis for a short-term genetic distance. Genetics,
105, 767-779.
</p>
<p>Rogers, J.S. (1972) Measures of genetic similarity and genetic distances.
Studies in Genetics, Univ. Texas Publ., 7213, 145-153. 
</p>
<p>Avise, J. C. (1994)
Molecular markers, natural history and evolution. Chapman &amp; Hall, London.
</p>
<p>Prevosti A. (1974) La distancia genetica entre poblaciones. Miscellanea
Alcobe, 68, 109-118. 
</p>
<p>Prevosti A., Ocana J. and Alonso G. (1975) Distances
between populations of Drosophila subobscura, based on chromosome
arrangements frequencies. Theoretical and Applied Genetics, 45, 231-241. 
</p>
<p>For more information on dissimilarity indexes: 
</p>
<p>Gower J. and Legendre P. (1986)
Metric and Euclidean properties of dissimilarity coefficients. Journal of
Classification, 3, 5-48 
</p>
<p>Legendre P. and Legendre L. (1998) Numerical Ecology,
Elsevier Science B.V. 20, pp274-288.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aboot">aboot</a></code> <code><a href="#topic+diss.dist">diss.dist</a></code> <code><a href="#topic+poppr.amova">poppr.amova</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(nancycats)
(nan9   &lt;- popsub(nancycats, 9))
(neinan &lt;- nei.dist(nan9))
(ednan  &lt;- edwards.dist(nan9))
(rodnan &lt;- rogers.dist(nan9))
(reynan &lt;- reynolds.dist(nan9))
(pronan &lt;- prevosti.dist(nan9))

</code></pre>

<hr>
<h2 id='old2new_genclone'>Convert an old genclone object to a new genclone object</h2><span id='topic+old2new_genclone'></span>

<h3>Description</h3>

<p>Convert an old genclone object to a new genclone object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>old2new_genclone(object, donor = new(class(object)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="old2new_genclone_+3A_object">object</code></td>
<td>
<p>a genclone object from poppr v. 1.1</p>
</td></tr>
<tr><td><code id="old2new_genclone_+3A_donor">donor</code></td>
<td>
<p>a new genclone object from poppr v. 2.0</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>

<hr>
<h2 id='partial_clone'>Simulated data illustrating a Minimum Spanning Network based on Bruvo's
Distance</h2><span id='topic+partial_clone'></span><span id='topic+old_partial_clone'></span>

<h3>Description</h3>

<p>These data were simulated using SimuPOP version 1.0.8 with 
99.9% clonal reproduction over 10,000 generations. Populations were
assigned post-hoc and are simply present for the purposes of demonstrating
a minimum spanning network with Bruvo's distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(partial_clone)
</code></pre>


<h3>Format</h3>

<p>a [genind()] object with 50 individuals, 10 loci, and four 
populations.
</p>


<h3>References</h3>

<p>Bo Peng and Christopher Amos (2008) Forward-time simulations of 
nonrandom mating populations using simuPOP. *bioinformatics*, 24 (11):
1408-1409.
</p>

<hr>
<h2 id='pgen'>Genotype Probability</h2><span id='topic+pgen'></span>

<h3>Description</h3>

<p>Calculate the probability of genotypes based on the product of allele
frequencies over all loci.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgen(gid, pop = NULL, by_pop = TRUE, log = TRUE, freq = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgen_+3A_gid">gid</code></td>
<td>
<p>a genind or genclone object.</p>
</td></tr>
<tr><td><code id="pgen_+3A_pop">pop</code></td>
<td>
<p>either a formula to set the population factor from the 
<code><a href="survival.html#topic+strata">strata</a></code> slot or a vector specifying the population factor for 
each sample. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pgen_+3A_by_pop">by_pop</code></td>
<td>
<p>When this is <code>TRUE</code> (default), the calculation will be
done by population.</p>
</td></tr>
<tr><td><code id="pgen_+3A_log">log</code></td>
<td>
<p>a <code>logical</code> if <code>log =TRUE</code> (default), the values
returned will be log(Pgen). If <code>log = FALSE</code>, the values returned will
be Pgen.</p>
</td></tr>
<tr><td><code id="pgen_+3A_freq">freq</code></td>
<td>
<p>a vector or matrix of allele frequencies. This defaults to 
<code>NULL</code>, indicating that the frequencies will be determined via 
round-robin approach in <code><a href="#topic+rraf">rraf</a></code>. <strong>If this matrix or 
vector is not provided, zero-value allele frequencies will automatically be
corrected.</strong> For details, please see the documentation on
<a href="#topic+rare_allele_correction">correcting rare alleles</a>.</p>
</td></tr>
<tr><td><code id="pgen_+3A_...">...</code></td>
<td>
<p>options from <a href="#topic+rare_allele_correction">correcting rare
alleles</a>. The default is to correct allele frequencies to 1/n</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pgen is the probability of a given genotype occuring in a population
assuming HWE. Thus, the value for diploids is 
</p>
<p style="text-align: center;"><code class="reqn">P_{gen} = \left(\prod_{i=1}^m p_i\right)2^h</code>
</p>
 
<p>where <code class="reqn">p_i</code> are the allele frequencies and <em>h</em> is the count of the
number of heterozygous sites in the sample (Arnaud-Haond et al. 2007; Parks
and Werth, 1993). The allele frequencies, by default, are calculated using
a round-robin approach where allele frequencies at a particular locus are 
calculated on the clone-censored genotypes without that locus.
</p>
<p>To avoid issues with numerical precision of small numbers, this function 
calculates pgen per locus by adding up log-transformed values of allele 
frequencies. These can easily be transformed to return the true value (see
examples).
</p>


<h3>Value</h3>

<p>A vector containing Pgen values per locus for each genotype in the 
object.
</p>


<h3>Note</h3>

<p>For haploids, Pgen at a particular locus is the allele frequency. This 
function cannot handle polyploids. Additionally, when the argument 
<code>pop</code> is not <code>NULL</code>, <code>by_pop</code> is automatically <code>TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar, Jonah Brooks, Stacy A. Krueger-Hadfield, Erik Sotka
</p>


<h3>References</h3>

<p>Arnaud-Haond, S., Duarte, C. M., Alberto, F., &amp; Serrão, E. A. 2007.
Standardizing methods to address clonality in population studies.
<em>Molecular Ecology</em>, 16(24), 5115-5139.
</p>
<p>Parks, J. C., &amp; Werth, C. R. 1993. A study of spatial features of clones in a
population of bracken fern, <em>Pteridium aquilinum</em> (Dennstaedtiaceae).
<em>American Journal of Botany</em>, 537-544.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psex">psex</a></code>, <code><a href="#topic+rraf">rraf</a></code>, <code><a href="#topic+rrmlg">rrmlg</a></code>, 
<code><a href="#topic+rare_allele_correction">rare_allele_correction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Pram)
head(pgen(Pram, log = FALSE))

## Not run: 
# You can also supply the observed allele frequencies
pramfreq &lt;- Pram %&gt;% genind2genpop() %&gt;% tab(freq = TRUE)
head(pgen(Pram, log = FALSE, freq = pramfreq))

# You can get the Pgen values over all loci by summing over the logged results:
pgen(Pram, log = TRUE) %&gt;%  # calculate pgen matrix
  rowSums(na.rm = TRUE) %&gt;% # take the sum of each row
  exp()                     # take the exponent of the results

# You can also take the product of the non-logged results:
apply(pgen(Pram, log = FALSE), 1, prod, na.rm = TRUE)

## Rare Allele Correction ---------------------------------------------------
##
# If you don't supply a table of frequencies, they are calculated with rraf 
# with correction = TRUE. This is normally benign when analyzing large 
# populations, but it can have a great effect on small populations. To help 
# control this, you can supply arguments described in 
# help("rare_allele_correction"). 


# Default is to correct by 1/n per population. Since the calculation is 
# performed on a smaller sample size due to round robin clone correction, it
# would be more appropriate to correct by 1/rrmlg at each locus. This is 
# acheived by setting d = "rrmlg". Since this is a diploid, we would want to
# account for the number of chromosomes, and so we set mul = 1/2
head(pgen(Pram, log = FALSE, d = "rrmlg", mul = 1/2)) # compare with the output above

# If you wanted to treat all alleles as equally rare, then you would set a
# specific value (let's say the rare alleles are 1/100):
head(pgen(Pram, log = FALSE, e = 1/100))

## End(Not run)
</code></pre>

<hr>
<h2 id='Pinf'>Phytophthora infestans data from Mexico and South America.</h2><span id='topic+Pinf'></span><span id='topic+old_Pinf'></span>

<h3>Description</h3>

<p>The Pinf data set contains 86 isolates genotyped over 11 
microsatellite loci collected from Mexico, Peru, Columbia, and Ecuador. 
This is a subset of the data used for the reference below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Pinf)
</code></pre>


<h3>Format</h3>

<p>a [genclone-class] object with 2 hierarchical levels 
called &quot;Continent&quot; and &quot;Country&quot; that contain 2 and 4 populations, 
respectively.
</p>


<h3>References</h3>

<p>Goss, Erica M., Javier F. Tabima, David EL Cooke, Silvia 
Restrepo, William E. Fry, Gregory A. Forbes, Valerie J. Fieland, Martha 
Cardenas, and Niklaus J. Grünwald. &quot;The Irish potato famine pathogen 
*Phytophthora infestans* originated in central Mexico rather than the 
Andes.&quot; Proceedings of the National Academy of Sciences 111:8791-8796. doi:
<a href="https://doi.org/10.1073/pnas.1401884111">doi:10.1073/pnas.1401884111</a>
</p>

<hr>
<h2 id='plot_filter_stats'>Plot the results of filter_stats</h2><span id='topic+plot_filter_stats'></span>

<h3>Description</h3>

<p>Plot the results of filter_stats
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_filter_stats(
  x,
  fstats,
  distmat,
  cols = NULL,
  nclone = NULL,
  breaks = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_filter_stats_+3A_x">x</code></td>
<td>
<p>a genlight of genind object</p>
</td></tr>
<tr><td><code id="plot_filter_stats_+3A_fstats">fstats</code></td>
<td>
<p>the list passed from <code><a href="#topic+filter_stats">filter_stats</a></code></p>
</td></tr>
<tr><td><code id="plot_filter_stats_+3A_distmat">distmat</code></td>
<td>
<p>a distance matrix passed from <code><a href="#topic+filter_stats">filter_stats</a></code></p>
</td></tr>
<tr><td><code id="plot_filter_stats_+3A_cols">cols</code></td>
<td>
<p>colors to use for each algorithm (defaults to <span class="pkg">RColorBrewer</span>
set 1)</p>
</td></tr>
<tr><td><code id="plot_filter_stats_+3A_nclone">nclone</code></td>
<td>
<p>see <code><a href="#topic+filter_stats">filter_stats</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot depicting how many MLLs are collapsed as the genetic distance 
increases for each algorithm.
</p>


<h3>Note</h3>

<p>This function originally appeared in 
<a href="https://doi.org/10.5281/zenodo.17424">doi:10.5281/zenodo.17424</a>
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>References</h3>

<p>ZN Kamvar, JC Brooks, and NJ Grünwald. 2015. Supplementary
Material for Frontiers Plant Genetics and Genomics 'Novel R tools for
analysis of genome-wide population genetic data with emphasis on clonality'.
DOI: <a href="https://doi.org/10.5281/zenodo.17424">doi:10.5281/zenodo.17424</a>
</p>
<p>Kamvar ZN, Brooks JC and Grünwald NJ (2015) Novel R tools for analysis of 
genome-wide population genetic data with emphasis on clonality. Front. Genet.
6:208. doi:
<a href="https://doi.org/10.3389/fgene.2015.00208">doi:10.3389/fgene.2015.00208</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filter_stats">filter_stats</a></code>
</p>

<hr>
<h2 id='plot_poppr_msn'>Plot minimum spanning networks produced in poppr.</h2><span id='topic+plot_poppr_msn'></span>

<h3>Description</h3>

<p>This function allows you to take the output of poppr.msn and bruvo.msn and 
customize the plot by labeling groups of individuals, size of nodes, and 
adjusting the palette and scale bar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_poppr_msn(
  x,
  poppr_msn,
  gscale = TRUE,
  gadj = 3,
  mlg.compute = "original",
  glim = c(0, 0.8),
  gweight = 1,
  wscale = TRUE,
  nodescale = 10,
  nodebase = NULL,
  nodelab = 2,
  inds = "ALL",
  mlg = FALSE,
  quantiles = TRUE,
  cutoff = NULL,
  palette = NULL,
  layfun = layout.auto,
  beforecut = FALSE,
  pop.leg = TRUE,
  size.leg = TRUE,
  scale.leg = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_poppr_msn_+3A_x">x</code></td>
<td>
<p>a <code><a href="adegenet.html#topic+genind-class">genind</a></code>, <code><a href="#topic+genclone-class">genclone</a></code>,
<code><a href="adegenet.html#topic+genlight-class">genlight</a></code>, or <code><a href="#topic+snpclone-class">snpclone</a></code> object from
which <code>poppr_msn</code> was derived.</p>
</td></tr>
<tr><td><code id="plot_poppr_msn_+3A_poppr_msn">poppr_msn</code></td>
<td>
<p>a <code>list</code> produced from either <code><a href="#topic+poppr.msn">poppr.msn</a></code> 
or <code><a href="#topic+bruvo.msn">bruvo.msn</a></code>. This list should contain a graph, a vector of 
population names and a vector of hexadecimal color definitions for each 
population.</p>
</td></tr>
<tr><td><code id="plot_poppr_msn_+3A_gscale">gscale</code></td>
<td>
<p>&quot;grey scale&quot;. If this is <code>TRUE</code>, this will scale the color
of the edges proportional to the observed distance, with the lines becoming
darker for more related nodes. See <code><a href="#topic+greycurve">greycurve</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot_poppr_msn_+3A_gadj">gadj</code></td>
<td>
<p>&quot;grey adjust&quot;. a positive <code>integer</code> greater than zero that
will serve as the exponent to the edge weight to scale the grey value to
represent that weight.</p>
</td></tr>
<tr><td><code id="plot_poppr_msn_+3A_mlg.compute">mlg.compute</code></td>
<td>
<p>if the multilocus genotypes are set to &quot;custom&quot; (see 
<code><a href="#topic+mll.custom">mll.custom</a></code> for details) in your genclone object, this will 
specify which mlg level to calculate the nodes from. See details.</p>
</td></tr>
<tr><td><code id="plot_poppr_msn_+3A_glim">glim</code></td>
<td>
<p>&quot;grey limit&quot;. Two numbers between zero and one. They determine 
the upper and lower limits for the <code><a href="grDevices.html#topic+gray">gray</a></code> function. Default is 0
(black) and 0.8 (20% black).</p>
</td></tr>
<tr><td><code id="plot_poppr_msn_+3A_gweight">gweight</code></td>
<td>
<p>&quot;grey weight&quot;. an <code>integer</code>. If it's 1, the grey scale
will be weighted to emphasize the differences between closely related nodes.
If it is 2, the grey scale will be weighted to emphasize the differences
between more distantly related nodes.</p>
</td></tr>
<tr><td><code id="plot_poppr_msn_+3A_wscale">wscale</code></td>
<td>
<p>&quot;width scale&quot;. If this is <code>TRUE</code>, the edge widths will be 
scaled proportional to the inverse of the observed distance , with the 
lines becoming thicker for more related nodes.</p>
</td></tr>
<tr><td><code id="plot_poppr_msn_+3A_nodescale">nodescale</code></td>
<td>
<p>a <code>numeric</code> indicating how to scale the node sizes (scales by area).</p>
</td></tr>
<tr><td><code id="plot_poppr_msn_+3A_nodebase">nodebase</code></td>
<td>
<p><strong>deprecated</strong> a <code>numeric</code> indicating what base logarithm should be
used to scale the node sizes. Defaults to 1.15. See details.</p>
</td></tr>
<tr><td><code id="plot_poppr_msn_+3A_nodelab">nodelab</code></td>
<td>
<p>an <code>integer</code> specifying the smallest size of node to 
label. See details.</p>
</td></tr>
<tr><td><code id="plot_poppr_msn_+3A_inds">inds</code></td>
<td>
<p>a <code>character</code> or <code>numeric</code> vector indicating which
samples or multilocus genotypes to label on the graph. See details.</p>
</td></tr>
<tr><td><code id="plot_poppr_msn_+3A_mlg">mlg</code></td>
<td>
<p><code>logical</code> When <code>TRUE</code>, the nodes will be labeled by
multilocus genotype. When <code>FALSE</code> (default), nodes will be labeled by
sample names.</p>
</td></tr>
<tr><td><code id="plot_poppr_msn_+3A_quantiles">quantiles</code></td>
<td>
<p><code>logical</code>. When set to <code>TRUE</code> (default), the scale
bar will be composed of the quantiles from the observed edge weights. When 
set to <code>FALSE</code>, the scale bar will be composed of a smooth gradient 
from the minimum edge weight to the maximum edge weight.</p>
</td></tr>
<tr><td><code id="plot_poppr_msn_+3A_cutoff">cutoff</code></td>
<td>
<p>a number indicating the longest distance to display in your 
graph. This is performed by removing edges with weights greater than this 
number.</p>
</td></tr>
<tr><td><code id="plot_poppr_msn_+3A_palette">palette</code></td>
<td>
<p>a function or character corresponding to a specific palette 
you want to use to delimit your populations. The default is whatever 
palette was used to produce the original graph.</p>
</td></tr>
<tr><td><code id="plot_poppr_msn_+3A_layfun">layfun</code></td>
<td>
<p>a function specifying the layout of nodes in your graph. It 
defaults to <code><a href="igraph.html#topic+layout_nicely">layout.auto</a></code>.</p>
</td></tr>
<tr><td><code id="plot_poppr_msn_+3A_beforecut">beforecut</code></td>
<td>
<p>if <code>TRUE</code>, the layout of the graph will be computed 
before any edges are removed with <code>cutoff</code>. If <code>FALSE</code> (Default),
the layout will be computed after any edges are removed.</p>
</td></tr>
<tr><td><code id="plot_poppr_msn_+3A_pop.leg">pop.leg</code></td>
<td>
<p>if <code>TRUE</code>, a legend indicating the populations will
appear in the top right corner of the graph, but will not overlap. Setting
<code>pop.leg = FALSE</code> disables this legend. See details.</p>
</td></tr>
<tr><td><code id="plot_poppr_msn_+3A_size.leg">size.leg</code></td>
<td>
<p>if <code>TRUE</code>, a legend displyaing the number of samples per
node will appear either below the population legend or in the top right
corner of the graph. Setting <code>size.leg = FALSE</code> disables this legend.</p>
</td></tr>
<tr><td><code id="plot_poppr_msn_+3A_scale.leg">scale.leg</code></td>
<td>
<p>if <code>TRUE</code>, a scale bar indicating the distance will
appear under the graph. Setting <code>scale.leg = FALSE</code> suppresses this
bar. See details.</p>
</td></tr>
<tr><td><code id="plot_poppr_msn_+3A_...">...</code></td>
<td>
<p>any other parameters to be passed on to 
<code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The previous incarnation of msn plotting in poppr simply plotted the
minimum spanning network with the legend of populations, but did not 
provide a scale bar and it did not provide the user a simple way of 
manipulating the layout or labels. This function allows the user to 
manipulate many facets of graph creation, making the creation of minimum 
spanning networks ever so slightly more user friendly. 
</p>
<p>This function must have both the source data and the output msn to work. 
The source data must contain the same population structure as the graph. 
Every other parameter has a default setting.
</p>


<h4>Parameter details</h4>

  
<ul>
<li> <p><code>inds</code> By default, the graph will label each node (circle) with
all of the samples (individuals) that are contained within that node. As
each node represents a single multilocus genotype (MLG) or individuals (n
&gt;= 1), this argument is designed to allow you to selectively label the
nodes based on query of sample name or MLG number. If the option <code>mlg
  = TRUE</code>, the multilocus genotype assignment will be used to label the node.
If you do not want to label the nodes by individual or multilocus genotype,
simply set this to a name that doesn't exist in your data.
</p>
</li>
<li> <p><code>nodescale</code> The nodes (circles) on the graph represent different
multilocus genotypes. The area of the nodes represent the number of
individuals. Setting nodescale will scale the area of the nodes.
</p>
</li>
<li> <p><code>nodelab</code> If a node is not labeled by individual, this will
label the size of the nodes greater than or equal to this value. If you
don't want to label the size of the nodes, simply set this to a very high
number.
</p>
</li>
<li> <p><code>cutoff</code> This is useful for when you want to investigate groups
of multilocus genotypes separated by a specific distance or if you have two
distinct populations and you want to physically separate them in your
network.
</p>
</li>
<li> <p><code>beforecut</code> This is an indicator useful if you want to maintain
the same position of the nodes before and after removing edges with the
<code>cutoff</code> argument. This works best if you set a seed before you run
the function.
</p>
</li></ul>



<h4>mlg.compute</h4>

<p>Each node on the graph represents a different multilocus genotype. 
The edges on the graph represent genetic distances that connect the
multilocus genotypes. In genclone objects, it is possible to set the
multilocus genotypes to a custom definition. This creates a problem for
clone correction, however, as it is very possible to define custom lineages
that are not monophyletic. When clone correction is performed on these
definitions, information is lost from the graph. To circumvent this, The
clone correction will be done via the computed multilocus genotypes, either
&quot;original&quot; or &quot;contracted&quot;. This is specified in the <code>mlg.compute</code>
argument, above.</p>



<h4>legends</h4>

<p> To avoid drawing the legend over the graph, legends 
are separated by different plotting areas. This means that if legends are 
included, you cannot plot multiple MSNs in a single plot. The scale bar (to
be added in manually) can be obtained from <code><a href="#topic+greycurve">greycurve</a></code> and the
legend can be plotted with <code><a href="graphics.html#topic+legend">legend</a></code>.</p>



<h3>Value</h3>

<p>the modified msn list, invisibly.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>See Also</h3>

<p><code><a href="igraph.html#topic+layout_nicely">layout.auto</a></code> <code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code>
<code><a href="#topic+poppr.msn">poppr.msn</a></code> <code><a href="#topic+bruvo.msn">bruvo.msn</a></code> <code><a href="#topic+greycurve">greycurve</a></code>
<code><a href="igraph.html#topic+delete_edges">delete_edges</a></code> <code><a href="grDevices.html#topic+palette">palette</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using a data set of the Aphanomyces eutieches root rot pathogen.
data(Aeut)
adist &lt;- diss.dist(Aeut, percent = TRUE)
amsn &lt;- poppr.msn(Aeut, adist, showplot = FALSE)

# Default
library("igraph") # To get all the layouts.
set.seed(500)
plot_poppr_msn(Aeut, amsn, gadj = 15)

## Not run: 

# Different layouts (from igraph) can be used by supplying the function name.
set.seed(500)
plot_poppr_msn(Aeut, amsn, gadj = 15, layfun = layout_with_kk)

# Removing link between populations (cutoff = 0.2) and labelling no individuals
set.seed(500)
plot_poppr_msn(Aeut, amsn, inds = "none", gadj = 15, beforecut = TRUE, cutoff = 0.2)

# Labelling individual #57 because it is an MLG that crosses populations
# Showing clusters of MLGS with at most 5% variation
# Notice that the Mt. Vernon population appears to be more clonal
set.seed(50) 
plot_poppr_msn(Aeut, amsn, gadj = 15, cutoff = 0.05, inds = "057")


data(partial_clone)
pcmsn &lt;- bruvo.msn(partial_clone, replen = rep(1, 10))

# You can plot using a color palette or a vector of named colors
# Here's a way to define the colors beforehand
pc_colors &lt;- nPop(partial_clone) %&gt;% 
  RColorBrewer::brewer.pal("Set2") %&gt;% 
  setNames(popNames(partial_clone))

pc_colors

# Labelling the samples contained in multilocus genotype 9
set.seed(999)
plot_poppr_msn(partial_clone, pcmsn, palette = pc_colors, inds = 9)

# Doing the same thing, but using one of the sample names as input.
set.seed(999)
plot_poppr_msn(partial_clone, pcmsn, palette = pc_colors, inds = "sim 20")

# Note that this is case sensitive. Nothing is labeled. 
set.seed(999)
plot_poppr_msn(partial_clone, pcmsn, palette = pc_colors, inds = "Sim 20")

# Something pretty
data(microbov)
mdist &lt;- diss.dist(microbov, percent = TRUE)
micmsn &lt;- poppr.msn(microbov, mdist, showplot = FALSE)

plot_poppr_msn(microbov, micmsn, palette = "terrain.colors", inds = "n", 
  quantiles = FALSE)
plot_poppr_msn(microbov, micmsn, palette = "terrain.colors", inds = "n", 
  cutoff = 0.3, quantiles = FALSE)
  
### Utilizing vectors for palettes

data(Pram)
Pram_sub &lt;- popsub(Pram, exclude = c("Nursery_CA", "Nursery_OR"))

# Creating the network for the forest
min_span_net_sub &lt;- bruvo.msn(Pram_sub, replen = other(Pram)$REPLEN, 
                              add = TRUE, loss = TRUE, showplot = FALSE, 
                              include.ties = TRUE)
                              
# Creating the network with nurseries
min_span_net     &lt;- bruvo.msn(Pram, replen = other(Pram)$REPLEN, 
                              add = TRUE, loss = TRUE, showplot = FALSE, 
                              include.ties = TRUE)

# Only forest genotypes
set.seed(70)
plot_poppr_msn(Pram,
               min_span_net_sub,
               inds = "ALL",
               mlg = TRUE,
               gadj = 9,
               nodescale = 5,
               palette = other(Pram)$comparePal,
               cutoff = NULL,
               quantiles = FALSE,
               beforecut = TRUE)

# With Nurseries
set.seed(70)
plot_poppr_msn(Pram,
               min_span_net,
               inds = "ALL",
               mlg = TRUE,
               gadj = 9,
               nodescale = 5,
               palette = other(Pram)$comparePal,
               cutoff = NULL,
               quantiles = FALSE,
               beforecut = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='poppr'>Produce a basic summary table for population genetic analyses.</h2><span id='topic+poppr'></span>

<h3>Description</h3>

<p>For the <span class="pkg">poppr</span> package description, please see <code>package?poppr</code>
</p>
<p>This function allows the user to quickly view indices of heterozygosity,
evenness, and linkage to aid in the decision of a path to further analyze a
specified dataset. It natively takes <a href="adegenet.html#topic+new.genind">adegenet::genind</a> and
<a href="#topic+genclone-class">genclone</a> objects, but can convert any raw data formats
that adegenet can take (fstat, structure, genetix, and genpop) as well as
genalex files exported into a csv format (see <code><a href="#topic+read.genalex">read.genalex()</a></code> for details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poppr(
  dat,
  total = TRUE,
  sublist = "ALL",
  exclude = NULL,
  blacklist = NULL,
  sample = 0,
  method = 1,
  missing = "ignore",
  cutoff = 0.05,
  quiet = FALSE,
  clonecorrect = FALSE,
  strata = 1,
  keep = 1,
  plot = TRUE,
  hist = TRUE,
  index = "rbarD",
  minsamp = 10,
  legend = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poppr_+3A_dat">dat</code></td>
<td>
<p>a <a href="adegenet.html#topic+new.genind">adegenet::genind</a> object OR a <a href="#topic+genclone-class">genclone</a>
object OR any fstat, structure, genetix, genpop, or genalex formatted
file.</p>
</td></tr>
<tr><td><code id="poppr_+3A_total">total</code></td>
<td>
<p>When <code>TRUE</code> (default), indices will be calculated for the
pooled populations.</p>
</td></tr>
<tr><td><code id="poppr_+3A_sublist">sublist</code></td>
<td>
<p>a list of character strings or integers to indicate specific
population names (accessed via <code><a href="adegenet.html#topic+accessors">adegenet::popNames()</a></code>).
Defaults to &quot;ALL&quot;.</p>
</td></tr>
<tr><td><code id="poppr_+3A_exclude">exclude</code></td>
<td>
<p>a <code>vector</code> of population names or indexes that the user
wishes to discard. Default to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="poppr_+3A_blacklist">blacklist</code></td>
<td>
<p>DEPRECATED, use exclude.</p>
</td></tr>
<tr><td><code id="poppr_+3A_sample">sample</code></td>
<td>
<p>an integer indicating the number of permutations desired to
obtain p-values. Sampling will shuffle genotypes at each locus to simulate
a panmictic population using the observed genotypes. Calculating the
p-value includes the observed statistics, so set your sample number to one
off for a round p-value (eg. <code>sample = 999</code> will give you p = 0.001 and
<code>sample = 1000</code> will give you p = 0.000999001).</p>
</td></tr>
<tr><td><code id="poppr_+3A_method">method</code></td>
<td>
<p>an integer from 1 to 4 indicating the method of sampling
desired. see <code><a href="#topic+shufflepop">shufflepop()</a></code> for details.</p>
</td></tr>
<tr><td><code id="poppr_+3A_missing">missing</code></td>
<td>
<p>how should missing data be treated? <code>"zero"</code> and
<code>"mean"</code> will set the missing values to those documented in
<code><a href="adegenet.html#topic+tab">tab()</a></code>. <code>"loci"</code> and <code>"geno"</code> will remove any loci or
genotypes with missing data, respectively (see <code><a href="#topic+missingno">missingno()</a></code> for
more information.</p>
</td></tr>
<tr><td><code id="poppr_+3A_cutoff">cutoff</code></td>
<td>
<p><code>numeric</code> a number from 0 to 1 indicating the percent
missing data allowed for analysis. This is to be used in conjunction with
the flag <code>missing</code> (see <code><a href="#topic+missingno">missingno()</a></code> for details)</p>
</td></tr>
<tr><td><code id="poppr_+3A_quiet">quiet</code></td>
<td>
<p><code>FALSE</code> (default) will display a progress bar for each
population analyzed.</p>
</td></tr>
<tr><td><code id="poppr_+3A_clonecorrect">clonecorrect</code></td>
<td>
<p>default <code>FALSE</code>. must be used with the <code>strata</code>
parameter, or the user will potentially get undesired results. see
<code><a href="#topic+clonecorrect">clonecorrect()</a></code> for details.</p>
</td></tr>
<tr><td><code id="poppr_+3A_strata">strata</code></td>
<td>
<p>a <code>formula</code> indicating the hierarchical levels to be used.
The hierarchies should be present in the <code>strata</code> slot. See
<code><a href="survival.html#topic+strata">strata()</a></code> for details.</p>
</td></tr>
<tr><td><code id="poppr_+3A_keep">keep</code></td>
<td>
<p>an <code>integer</code>. This indicates which strata you wish to keep
after clone correcting your data sets. To combine strata, just set keep
from 1 to the number of straifications set in strata. see
<code><a href="#topic+clonecorrect">clonecorrect()</a></code> for details.</p>
</td></tr>
<tr><td><code id="poppr_+3A_plot">plot</code></td>
<td>
<p><code>logical</code> if <code>TRUE</code> (default) and <code>sampling &gt; 0</code>,
a histogram will be produced for each population.</p>
</td></tr>
<tr><td><code id="poppr_+3A_hist">hist</code></td>
<td>
<p><code>logical</code> Deprecated. Use plot.</p>
</td></tr>
<tr><td><code id="poppr_+3A_index">index</code></td>
<td>
<p><code>character</code> Either &quot;Ia&quot; or &quot;rbarD&quot;. If <code>hist = TRUE</code>,
this will determine the index used for the visualization.</p>
</td></tr>
<tr><td><code id="poppr_+3A_minsamp">minsamp</code></td>
<td>
<p>an <code>integer</code> indicating the minimum number of individuals
to resample for rarefaction analysis. See <code><a href="vegan.html#topic+rarefy">vegan::rarefy()</a></code> for
details.</p>
</td></tr>
<tr><td><code id="poppr_+3A_legend">legend</code></td>
<td>
<p><code>logical</code>. When this is set to <code>TRUE</code>, a legend describing the
resulting table columns will be printed. Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="poppr_+3A_...">...</code></td>
<td>
<p>arguments to be passed on to <code><a href="#topic+diversity_stats">diversity_stats()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This table is intended to be a first look into the dynamics of mutlilocus
genotype diversity. Many of the statistics (except for the the index of
association) are simply based on counts of multilocus genotypes and do not
take into account the actual allelic states. <strong>Descriptions of the
statistics can be found in the Algorithms and Equations vignette</strong>:
<code>vignette("algo", package = "poppr")</code>.
</p>


<h4>sampling</h4>

<p>The sampling procedure is explicitly for testing the index of association.
None of the other diversity statistics (H, G, lambda, E.5) are tested with
this sampling due to the differing data types. To obtain confidence
intervals for these statistics, please see <code><a href="#topic+diversity_ci">diversity_ci()</a></code>.
</p>



<h4>rarefaction</h4>

<p>Rarefaction analysis is performed on the number of multilocus genotypes
because it is relatively easy to estimate (Grünwald et al., 2003). To
obtain rarefied estimates of diversity, it is possible to use
<code><a href="#topic+diversity_ci">diversity_ci()</a></code> with the argument <code>rarefy = TRUE</code>
</p>



<h4>graphic</h4>

<p>This function outputs a <span class="pkg">ggplot2</span> graphic of histograms. These can be
manipulated to be visualized in another manner by retrieving the plot with
the <code><a href="ggplot2.html#topic+last_plot">last_plot()</a></code> command from <span class="pkg">ggplot2</span>. A useful manipulation would
be to arrange the graphs into a single column so that the values of the
statistic line up: <code style="white-space: pre;">&#8288;p &lt;- last_plot(); p + facet_wrap(~population, ncol = 1, scales = "free_y")&#8288;</code> The name for the groupings is
&quot;population&quot; and the name for the x axis is &quot;value&quot;.
</p>



<h3>Value</h3>

<p>A data frame with populations in rows and the following columns:
</p>

<ul>
<li> <p><strong>Pop</strong>: A vector indicating the population factor
</p>
</li>
<li> <p><strong>N</strong>: An integer vector indicating the number of individuals/isolates in
the specified population.
</p>
</li>
<li> <p><strong>MLG</strong>: An integer vector indicating the number of multilocus genotypes
found in the specified population, (see: <code><a href="#topic+mlg">mlg()</a></code>)
</p>
</li>
<li> <p><strong>eMLG</strong>: The expected number of MLG at the lowest common sample size (set
by the parameter <code>minsamp</code>).
</p>
</li>
<li> <p><strong>SE</strong>: The standard error for the rarefaction analysis
</p>
</li>
<li> <p><strong>H</strong>: Shannon-Weiner Diversity index
</p>
</li>
<li> <p><strong>G</strong>: Stoddard and Taylor's Index
</p>
</li>
<li> <p><strong>lambda</strong>: Simpson's index
</p>
</li>
<li> <p><strong>E.5</strong>: Evenness
</p>
</li>
<li> <p><strong>Hexp</strong>: Nei's gene diversity (expected heterozygosity)
</p>
</li>
<li> <p><strong>Ia</strong>: A numeric vector giving the value of the Index of Association for
each population factor, (see <code><a href="#topic+ia">ia()</a></code>).
</p>
</li>
<li> <p><strong>p.Ia</strong>: A numeric vector indicating the p-value for Ia from the number
of reshufflings indicated in <code>sample</code>. Lowest value is 1/n where n is the
number of observed values.
</p>
</li>
<li> <p><strong>rbarD</strong>: A numeric vector giving the value of the Standardized Index of
Association for each population factor, (see <code><a href="#topic+ia">ia()</a></code>).
</p>
</li>
<li> <p><strong>p.rD</strong>: A numeric vector indicating the p-value for rbarD from the
number of reshuffles indicated in <code>sample</code>. Lowest value is 1/n where n is
the number of observed values.
</p>
</li>
<li> <p><strong>File</strong>: A vector indicating the name of the original data file.
</p>
</li></ul>



<h3>Note</h3>

<p>The calculation of <code>Hexp</code> has changed from <span class="pkg">poppr</span> 1.x. It was
previously calculated based on the diversity of multilocus genotypes,
resulting in a value of 1 for sexual populations. This was obviously not
Nei's 1978 expected heterozygosity. We have thus changed the statistic to
be the true value of Hexp by calculating <code class="reqn">(\frac{n}{n-1}) 1 - \sum_{i =
  1}^k{p^{2}_{i}}</code> where p is the allele
frequencies at a given locus and n is the number of observed alleles (Nei,
1978) in each locus and then returning the average. Caution should be
exercised in interpreting the results of Hexp with polyploid organisms with
ambiguous ploidy. The lack of allelic dosage information will cause rare
alleles to be over-represented and artificially inflate the index. This is
especially true with small sample sizes.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>References</h3>

<p>Paul-Michael Agapow and Austin Burt. Indices of multilocus
linkage disequilibrium. <em>Molecular Ecology Notes</em>, 1(1-2):101-102,
2001
</p>
<p>A.H.D. Brown, M.W. Feldman, and E. Nevo. Multilocus structure of natural
populations of <em>Hordeum spontaneum</em>. <em>Genetics</em>, 96(2):523-536,
1980.
</p>
<p>Niklaus J. Gr\&quot;unwald, Stephen B. Goodwin, Michael G. Milgroom, and William
E. Fry. Analysis of genotypic diversity data for populations of
microorganisms. Phytopathology, 93(6):738-46, 2003
</p>
<p>Bernhard Haubold and Richard R. Hudson. Lian 3.0: detecting linkage
disequilibrium in multilocus data. Bioinformatics, 16(9):847-849, 2000.
</p>
<p>Kenneth L.Jr. Heck, Gerald van Belle, and Daniel Simberloff. Explicit
calculation of the rarefaction diversity measurement and the determination
of sufficient sample size. Ecology, 56(6):pp. 1459-1461, 1975
</p>
<p>Masatoshi Nei. Estimation of average heterozygosity and genetic distance
from a small number of individuals. Genetics, 89(3):583-590, 1978.
</p>
<p>S H Hurlbert. The nonconcept of species diversity: a critique and
alternative parameters. Ecology, 52(4):577-586, 1971.
</p>
<p>J.A. Ludwig and J.F. Reynolds. Statistical Ecology. A Primer on Methods and
Computing. New York USA: John Wiley and Sons, 1988.
</p>
<p>Simpson, E. H. Measurement of diversity. Nature 163: 688, 1949
doi:10.1038/163688a0
</p>
<p>Good, I. J. (1953). On the Population Frequency of Species and the
Estimation of Population Parameters. <em>Biometrika</em> 40(3/4): 237-264.
</p>
<p>Lande, R. (1996). Statistics and partitioning of species diversity, and
similarity among multiple communities. <em>Oikos</em> 76: 5-13.
</p>
<p>Jari Oksanen, F. Guillaume Blanchet, Roeland Kindt, Pierre Legendre, Peter
R. Minchin, R. B. O'Hara, Gavin L. Simpson, Peter Solymos, M. Henry H.
Stevens, and Helene Wagner. vegan: Community Ecology Package, 2012. R
package version 2.0-5.
</p>
<p>E.C. Pielou. Ecological Diversity. Wiley, 1975.
</p>
<p>Claude Elwood Shannon. A mathematical theory of communication. Bell Systems
Technical Journal, 27:379-423,623-656, 1948
</p>
<p>J M Smith, N H Smith, M O'Rourke, and B G Spratt. How clonal are bacteria?
Proceedings of the National Academy of Sciences, 90(10):4384-4388, 1993.
</p>
<p>J.A. Stoddart and J.F. Taylor. Genotypic diversity: estimation and
prediction in samples. Genetics, 118(4):705-11, 1988.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clonecorrect">clonecorrect()</a></code>,
<code><a href="#topic+poppr.all">poppr.all()</a></code>,
<code><a href="#topic+ia">ia()</a></code>,
<code><a href="#topic+missingno">missingno()</a></code>,
<code><a href="#topic+mlg">mlg()</a></code>,
<code><a href="#topic+diversity_stats">diversity_stats()</a></code>,
<code><a href="#topic+diversity_ci">diversity_ci()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nancycats)
poppr(nancycats)

## Not run: 
# Sampling
poppr(nancycats, sample = 999, total = FALSE, plot = TRUE)

# Customizing the plot
library("ggplot2")
p &lt;- last_plot()
p + facet_wrap(~population, scales = "free_y", ncol = 1)

# Turning off diversity statistics (see get_stats)
poppr(nancycats, total=FALSE, H = FALSE, G = FALSE, lambda = FALSE, E5 = FALSE)

# The previous version of poppr contained a definition of Hexp, which
# was calculated as (N/(N - 1))*lambda. It basically looks like an unbiased 
# Simpson's index. This statistic was originally included in poppr because it
# was originally included in the program multilocus. It was finally figured
# to be an unbiased Simpson's diversity metric (Lande, 1996; Good, 1953).

data(Aeut)

uSimp &lt;- function(x){
  lambda &lt;- vegan::diversity(x, "simpson")
  x &lt;- drop(as.matrix(x))
  if (length(dim(x)) &gt; 1){
    N &lt;- rowSums(x)
  } else {
    N &lt;- sum(x)
  }
  return((N/(N-1))*lambda)
}
poppr(Aeut, uSimp = uSimp)


# Demonstration with viral data
# Note: this is a larger data set that could take a couple of minutes to run
# on slower computers. 
data(H3N2)
strata(H3N2) &lt;- data.frame(other(H3N2)$x)
setPop(H3N2) &lt;- ~country
poppr(H3N2, total = FALSE, sublist=c("Austria", "China", "USA"), 
  clonecorrect = TRUE, strata = ~country/year)

## End(Not run)
</code></pre>

<hr>
<h2 id='poppr_has_parallel'>Determines whether openMP is support on this system.</h2><span id='topic+poppr_has_parallel'></span>

<h3>Description</h3>

<p>Determines whether openMP is support on this system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poppr_has_parallel()
</code></pre>


<h3>Value</h3>

<p>FALSE if openMP is not supported, TRUE if it is
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar, Jonah C. Brooks
</p>


<h3>Examples</h3>

<pre><code class='language-R'>poppr_has_parallel()
</code></pre>

<hr>
<h2 id='poppr.all'>Process a list of files with poppr</h2><span id='topic+poppr.all'></span>

<h3>Description</h3>

<p>poppr.all is a wrapper function that will loop through a list of files from
the working directory, execute [poppr()], and concatenate the
output into one data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poppr.all(filelist, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poppr.all_+3A_filelist">filelist</code></td>
<td>
<p>a list of files in the current working directory</p>
</td></tr>
<tr><td><code id="poppr.all_+3A_...">...</code></td>
<td>
<p>arguments passed on to poppr</p>
</td></tr>
</table>


<h3>Value</h3>

<p>see [poppr()]
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>See Also</h3>

<p>[poppr()], [getfile()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Obtain a list of fstat files from a directory.
x &lt;- getfile(multi=TRUE, pattern="^.+?dat$")

# run the analysis on each file.
poppr.all(file.path(x$path, x$files))

## End(Not run)
</code></pre>

<hr>
<h2 id='poppr.amova'>Perform Analysis of Molecular Variance (AMOVA) on genind or genclone objects.</h2><span id='topic+poppr.amova'></span><span id='topic+amova'></span>

<h3>Description</h3>

<p>This function simplifies the process necessary for performing AMOVA in R. It
gives user the choice of utilizing either the <span class="pkg">ade4</span> or the <span class="pkg">pegas</span>
implementation of AMOVA. See <code><a href="ade4.html#topic+amova">ade4::amova()</a></code> (ade4) and <code><a href="pegas.html#topic+amova">pegas::amova()</a></code>
(pegas) for details on the specific implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poppr.amova(
  x,
  hier = NULL,
  clonecorrect = FALSE,
  within = TRUE,
  dist = NULL,
  squared = TRUE,
  freq = TRUE,
  correction = "quasieuclid",
  sep = "_",
  filter = FALSE,
  threshold = 0,
  algorithm = "farthest_neighbor",
  threads = 1L,
  missing = "loci",
  cutoff = 0.05,
  quiet = FALSE,
  method = c("ade4", "pegas"),
  nperm = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poppr.amova_+3A_x">x</code></td>
<td>
<p>a <a href="adegenet.html#topic+genind-class">genind</a>, <a href="#topic+genclone-class">genclone</a>, <a href="adegenet.html#topic+genlight-class">genlight</a>, or <a href="#topic+snpclone-class">snpclone</a> object</p>
</td></tr>
<tr><td><code id="poppr.amova_+3A_hier">hier</code></td>
<td>
<p>a hierarchical <a href="stats.html#topic+formula">formula</a> that defines your population
hierarchy. (e.g.: <code>~Population/Subpopulation</code>). <strong>See Details below</strong>.</p>
</td></tr>
<tr><td><code id="poppr.amova_+3A_clonecorrect">clonecorrect</code></td>
<td>
<p><code>logical</code> if <code>TRUE</code>, the data set will be clone corrected
with respect to the lowest level of the hierarchy. The default is set to
<code>FALSE</code>. See <code><a href="#topic+clonecorrect">clonecorrect()</a></code> for details.</p>
</td></tr>
<tr><td><code id="poppr.amova_+3A_within">within</code></td>
<td>
<p><code>logical</code>. When this is set to <code>TRUE</code> (Default), variance
within individuals are calculated as well. If this is set to <code>FALSE</code>, The
lowest level of the hierarchy will be the sample level. See Details below.</p>
</td></tr>
<tr><td><code id="poppr.amova_+3A_dist">dist</code></td>
<td>
<p>an optional distance matrix calculated on your data. If this is
set to <code>NULL</code> (default), the raw pairwise distances will be calculated via
<code><a href="stats.html#topic+dist">dist()</a></code>.</p>
</td></tr>
<tr><td><code id="poppr.amova_+3A_squared">squared</code></td>
<td>
<p>if a distance matrix is supplied, this indicates whether or
not it represents squared distances.</p>
</td></tr>
<tr><td><code id="poppr.amova_+3A_freq">freq</code></td>
<td>
<p><code>logical</code>. If <code>within = FALSE</code>, the parameter rho is calculated
(Ronfort et al. 1998; Meirmans and Liu 2018). By setting <code>freq = TRUE</code>,
(default) allele counts will be converted to frequencies before the
distance is calculated, otherwise, the distance will be calculated on
allele counts, which can bias results in mixed-ploidy data sets. Note that
this option has no effect for haploid or presence/absence data sets.</p>
</td></tr>
<tr><td><code id="poppr.amova_+3A_correction">correction</code></td>
<td>
<p>a <code>character</code> defining the correction method for
non-euclidean distances. Options are <code><a href="ade4.html#topic+quasieuclid">ade4::quasieuclid()</a></code> (Default),
<code><a href="ade4.html#topic+lingoes">ade4::lingoes()</a></code>, and <code><a href="ade4.html#topic+cailliez">ade4::cailliez()</a></code>. See Details below.</p>
</td></tr>
<tr><td><code id="poppr.amova_+3A_sep">sep</code></td>
<td>
<p>Deprecated. As of poppr version 2, this argument serves no
purpose.</p>
</td></tr>
<tr><td><code id="poppr.amova_+3A_filter">filter</code></td>
<td>
<p><code>logical</code> When set to <code>TRUE</code>, mlg.filter will be run to
determine genotypes from the distance matrix. It defaults to <code>FALSE</code>. You
can set the parameters with <code>algorithm</code> and <code>threshold</code> arguments. Note
that this will not be performed when <code>within = TRUE</code>. Note that the
threshold should be the number of allowable substitutions if you don't
supply a distance matrix.</p>
</td></tr>
<tr><td><code id="poppr.amova_+3A_threshold">threshold</code></td>
<td>
<p>a number indicating the minimum distance two MLGs must be
separated by to be considered different. Defaults to 0, which will reflect
the original (naive) MLG definition.</p>
</td></tr>
<tr><td><code id="poppr.amova_+3A_algorithm">algorithm</code></td>
<td>
<p>determines the type of clustering to be done. 
</p>

<dl>
<dt>&quot;farthest_neighbor&quot;</dt><dd><p><em> (default) </em>merges clusters based on the 
maximum distance between points in either cluster. This is the strictest of
the three.</p>
</dd>
<dt>&quot;nearest_neighbor&quot;</dt><dd><p> merges clusters based on the minimum distance
between points in either cluster. This is the loosest of the three.</p>
</dd>
<dt>&quot;average_neighbor&quot;</dt><dd><p> merges clusters based on the average distance
between every pair of points between clusters.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="poppr.amova_+3A_threads">threads</code></td>
<td>
<p><code>integer</code> When using filtering or genlight objects, this
parameter specifies the number of parallel processes passed to
<code><a href="#topic+mlg.filter">mlg.filter()</a></code> and/or <code><a href="#topic+bitwise.dist">bitwise.dist()</a></code>.</p>
</td></tr>
<tr><td><code id="poppr.amova_+3A_missing">missing</code></td>
<td>
<p>specify method of correcting for missing data utilizing
options given in the function <code><a href="#topic+missingno">missingno()</a></code>. Default is <code>"loci"</code>. This only
applies to genind or genclone objects.</p>
</td></tr>
<tr><td><code id="poppr.amova_+3A_cutoff">cutoff</code></td>
<td>
<p>specify the level at which missing data should be
removed/modified. See <code><a href="#topic+missingno">missingno()</a></code> for details. This only applies to
genind or genclone objects.</p>
</td></tr>
<tr><td><code id="poppr.amova_+3A_quiet">quiet</code></td>
<td>
<p><code>logical</code> If <code>FALSE</code> (Default), messages regarding any
corrections will be printed to the screen. If <code>TRUE</code>, no messages will be
printed.</p>
</td></tr>
<tr><td><code id="poppr.amova_+3A_method">method</code></td>
<td>
<p>Which method for calculating AMOVA should be used? Choices
refer to package implementations: &quot;ade4&quot; (default) or &quot;pegas&quot;. See details
for differences.</p>
</td></tr>
<tr><td><code id="poppr.amova_+3A_nperm">nperm</code></td>
<td>
<p>the number of permutations passed to the pegas implementation of
amova.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The poppr implementation of AMOVA is a very detailed wrapper for the
ade4 implementation. The output is an <code><a href="ade4.html#topic+amova">ade4::amova()</a></code> class list that
contains the results in the first four elements. The inputs are contained
in the last three elements. The inputs required for the ade4 implementation
are:
</p>

<ol>
<li><p> a distance matrix on all unique genotypes (haplotypes)
</p>
</li>
<li><p> a data frame defining the hierarchy of the distance matrix
</p>
</li>
<li><p> a genotype (haplotype) frequency table.
</p>
</li></ol>

<p>All of this data can be constructed from a <a href="adegenet.html#topic+genind-class">genind</a> or
<a href="adegenet.html#topic+genlight-class">genlight</a> object, but can be daunting for a novice R user.
<em>This function automates the entire process</em>. Since there are many
variables regarding genetic data, some points need to be highlighted:
</p>


<h4>On Hierarchies:</h4>

<p>The hierarchy is defined by different
population strata that separate your data hierarchically. These strata are
defined in the <strong>strata</strong> slot of <a href="adegenet.html#topic+genind-class">genind</a>,
<a href="adegenet.html#topic+genlight-class">genlight</a>, <a href="#topic+genclone-class">genclone</a>, and
<a href="#topic+snpclone-class">snpclone</a> objects. They are useful for defining the
population factor for your data. See the function <code><a href="survival.html#topic+strata">strata()</a></code> for details on
how to properly define these strata.</p>



<h4>On Within Individual Variance:</h4>

<p> Heterozygosities within
genotypes are sources of variation from within individuals and can be
quantified in AMOVA. When <code>within = TRUE</code>, poppr will split genotypes into
haplotypes with the function <code><a href="#topic+make_haplotypes">make_haplotypes()</a></code> and use those to calculate
within-individual variance. No estimation of phase is made. This acts much
like the default settings for AMOVA in the Arlequin software package.
Within individual variance will not be calculated for haploid individuals
or dominant markers as the haplotypes cannot be split further. Setting
<code>within = FALSE</code> uses the euclidean distance of the allele frequencies
within each individual. <strong>Note:</strong> <code>within = TRUE</code> is incompatible with
<code>filter = TRUE</code>. In this case, <code>within</code> will be set to <code>FALSE</code></p>



<h4>On Euclidean Distances:</h4>

<p> With the <span class="pkg">ade4</span> implementation of
AMOVA (utilized by <span class="pkg">poppr</span>), distances must be Euclidean (due to the
nature of the calculations). Unfortunately, many genetic distance measures
are not always euclidean and must be corrected for before being analyzed.
Poppr automates this with three methods implemented in <span class="pkg">ade4</span>,
<code><a href="ade4.html#topic+quasieuclid">quasieuclid()</a></code>, <code><a href="ade4.html#topic+lingoes">lingoes()</a></code>, and <code><a href="ade4.html#topic+cailliez">cailliez()</a></code>. The correction of these
distances should not adversely affect the outcome of the analysis.</p>



<h4>On Filtering:</h4>

<p> Filtering multilocus genotypes is performed by
<code><a href="#topic+mlg.filter">mlg.filter()</a></code>. This can necessarily only be done AMOVA tests that do not
account for within-individual variance. The distance matrix used to
calculate the amova is derived from using <code><a href="#topic+mlg.filter">mlg.filter()</a></code> with the option
<code>stats = "distance"</code>, which reports the distance between multilocus
genotype clusters. One useful way to utilize this feature is to correct for
genotypes that have equivalent distance due to missing data. (See example
below.)</p>



<h4>On Methods:</h4>

<p> Both <span class="pkg">ade4</span> and <span class="pkg">pegas</span> have
implementations of AMOVA, both of which are appropriately called &quot;amova&quot;.
The ade4 version is faster, but there have been questions raised as to the
validity of the code utilized. The pegas version is slower, but careful
measures have been implemented as to the accuracy of the method. It must be
noted that there appears to be a bug regarding permuting analyses where
within individual variance is accounted for (<code>within = TRUE</code>) in the pegas
implementation. If you want to perform permutation analyses on the pegas
implementation, you must set <code>within = FALSE</code>. In addition, while clone
correction is implemented for both methods, filtering is only implemented
for the ade4 version.</p>



<h4>On Polyploids:</h4>

<p> As of <span class="pkg">poppr</span> version 2.7.0, this
function is able to calculate phi statistics for within-individual variance
for polyploid data with <strong>full dosage information</strong>. When a data set does
not contain full dosage information for all samples, then the resulting
pseudo-haplotypes will contain missing data, which would result in an
incorrect estimate of variance.
</p>
<p>Instead, the AMOVA will be performed on the distance matrix derived from
allele counts or allele frequencies, depending on the <code>freq</code> option. This
has been shown to be robust to estimates with mixed ploidy (Ronfort et al.
1998; Meirmans and Liu 2018). If you wish to brute-force your way to
estimating AMOVA using missing values, you can split your haplotypes with
the <code><a href="#topic+make_haplotypes">make_haplotypes()</a></code> function.
</p>
<p>One strategy for addressing ambiguous dosage in your polyploid data set
would be to convert your data to <span class="pkg">polysat</span>'s <code>genambig</code> class with the
<code><a href="#topic+as.genambig">as.genambig()</a></code>, estimate allele frequencies with <code><a href="polysat.html#topic+deSilvaFreq">polysat::deSilvaFreq()</a></code>,
and use these frequencies to randomly sample alleles to fill in the
ambiguous alleles.
</p>



<h3>Value</h3>

<p>a list of class <code>amova</code> from the ade4 or pegas package. See
<code><a href="ade4.html#topic+amova">ade4::amova()</a></code> or <code><a href="pegas.html#topic+amova">pegas::amova()</a></code> for details.
</p>


<h3>References</h3>

<p>Excoffier, L., Smouse, P.E. and Quattro, J.M. (1992) Analysis of
molecular variance inferred from metric distances among DNA haplotypes:
application to human mitochondrial DNA restriction data. <em>Genetics</em>,
<strong>131</strong>, 479-491.
</p>
<p>Ronfort, J., Jenczewski, E., Bataillon, T., and Rousset, F. (1998). Analysis
of population structure in autotetraploid species. <em>Genetics</em>, <strong>150</strong>,
921–930.
</p>
<p>Meirmans, P., Liu, S. (2018) Analysis of Molecular Variance (AMOVA) for
Autopolyploids <em>Submitted</em>.
</p>


<h3>See Also</h3>

<p><code><a href="ade4.html#topic+amova">ade4::amova()</a></code>, <code><a href="pegas.html#topic+amova">pegas::amova()</a></code>, <code><a href="#topic+clonecorrect">clonecorrect()</a></code>, <code><a href="#topic+diss.dist">diss.dist()</a></code>,
<code><a href="#topic+missingno">missingno()</a></code>, <code><a href="ade4.html#topic+is.euclid">ade4::is.euclid()</a></code>, <code><a href="survival.html#topic+strata">strata()</a></code>, <code><a href="#topic+make_haplotypes">make_haplotypes()</a></code>,
<code><a href="#topic+as.genambig">as.genambig()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Aeut)
strata(Aeut) &lt;- other(Aeut)$population_hierarchy[-1]
agc &lt;- as.genclone(Aeut)
agc
amova.result &lt;- poppr.amova(agc, ~Pop/Subpop)
amova.result
amova.test &lt;- randtest(amova.result) # Test for significance
plot(amova.test)
amova.test

## Not run: 

# You can get the same results with the pegas implementation
amova.pegas &lt;- poppr.amova(agc, ~Pop/Subpop, method = "pegas")
amova.pegas
amova.pegas$varcomp/sum(amova.pegas$varcomp)

# Clone correction is possible
amova.cc.result &lt;- poppr.amova(agc, ~Pop/Subpop, clonecorrect = TRUE)
amova.cc.result
amova.cc.test &lt;- randtest(amova.cc.result)
plot(amova.cc.test)
amova.cc.test


# Example with filtering
data(monpop)
splitStrata(monpop) &lt;- ~Tree/Year/Symptom
poppr.amova(monpop, ~Symptom/Year) # gets a warning of zero distances
poppr.amova(monpop, ~Symptom/Year, filter = TRUE, threshold = 0.1) # no warning



## End(Not run)
</code></pre>

<hr>
<h2 id='poppr.msn'>Create a minimum spanning network of selected populations using a distance 
matrix.</h2><span id='topic+poppr.msn'></span><span id='topic+msn.poppr'></span>

<h3>Description</h3>

<p>Create a minimum spanning network of selected populations using a distance 
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poppr.msn(
  gid,
  distmat,
  palette = topo.colors,
  mlg.compute = "original",
  sublist = "All",
  exclude = NULL,
  blacklist = NULL,
  vertex.label = "MLG",
  gscale = TRUE,
  glim = c(0, 0.8),
  gadj = 3,
  gweight = 1,
  wscale = TRUE,
  showplot = TRUE,
  include.ties = FALSE,
  threshold = NULL,
  clustering.algorithm = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poppr.msn_+3A_gid">gid</code></td>
<td>
<p>a <code><a href="adegenet.html#topic+genind">genind</a></code>, <code><a href="#topic+genclone">genclone</a></code>,
<code><a href="adegenet.html#topic+genlight">genlight</a></code>, or <code><a href="#topic+snpclone">snpclone</a></code> object</p>
</td></tr>
<tr><td><code id="poppr.msn_+3A_distmat">distmat</code></td>
<td>
<p>a distance matrix that has been derived from your data set.</p>
</td></tr>
<tr><td><code id="poppr.msn_+3A_palette">palette</code></td>
<td>
<p>a <code>vector</code> or <code>function</code> defining the color palette 
to be used to color the populations on the graph. It defaults to 
<code><a href="grDevices.html#topic+topo.colors">topo.colors</a></code>. See examples for details.</p>
</td></tr>
<tr><td><code id="poppr.msn_+3A_mlg.compute">mlg.compute</code></td>
<td>
<p>if the multilocus genotypes are set to &quot;custom&quot; (see 
<code><a href="#topic+mll.custom">mll.custom</a></code> for details) in your genclone object, this will 
specify which mlg level to calculate the nodes from. See details.</p>
</td></tr>
<tr><td><code id="poppr.msn_+3A_sublist">sublist</code></td>
<td>
<p>a <code>vector</code> of population names or indexes that the user 
wishes to keep. Default to &quot;ALL&quot;.</p>
</td></tr>
<tr><td><code id="poppr.msn_+3A_exclude">exclude</code></td>
<td>
<p>a <code>vector</code> of population names or indexes that the user
wishes to discard. Default to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="poppr.msn_+3A_blacklist">blacklist</code></td>
<td>
<p>DEPRECATED, use exclude.</p>
</td></tr>
<tr><td><code id="poppr.msn_+3A_vertex.label">vertex.label</code></td>
<td>
<p>a <code>vector</code> of characters to label each vertex. There
are two defaults: <code>"MLG"</code> will label the nodes with the multilocus 
genotype from the original data set and <code>"inds"</code> will label the nodes 
with the representative individual names.</p>
</td></tr>
<tr><td><code id="poppr.msn_+3A_gscale">gscale</code></td>
<td>
<p>&quot;grey scale&quot;. If this is <code>TRUE</code>, this will scale the color
of the edges proportional to the observed distance, with the lines becoming
darker for more related nodes. See <code><a href="#topic+greycurve">greycurve</a></code> for details.</p>
</td></tr>
<tr><td><code id="poppr.msn_+3A_glim">glim</code></td>
<td>
<p>&quot;grey limit&quot;. Two numbers between zero and one. They determine 
the upper and lower limits for the <code><a href="grDevices.html#topic+gray">gray</a></code> function. Default is 
0 (black) and 0.8 (20% black). See <code><a href="#topic+greycurve">greycurve</a></code> for details.</p>
</td></tr>
<tr><td><code id="poppr.msn_+3A_gadj">gadj</code></td>
<td>
<p>&quot;grey adjust&quot;. a positive <code>integer</code> greater than zero that 
will serve as the exponent to the edge weight to scale the grey value to 
represent that weight. See <code><a href="#topic+greycurve">greycurve</a></code> for details.</p>
</td></tr>
<tr><td><code id="poppr.msn_+3A_gweight">gweight</code></td>
<td>
<p>&quot;grey weight&quot;. an <code>integer</code>. If it's 1, the grey scale 
will be weighted to emphasize the differences between closely related 
nodes. If it is 2, the grey scale will be weighted to emphasize the 
differences between more distantly related nodes. See 
<code><a href="#topic+greycurve">greycurve</a></code> for details.</p>
</td></tr>
<tr><td><code id="poppr.msn_+3A_wscale">wscale</code></td>
<td>
<p>&quot;width scale&quot;. If this is <code>TRUE</code>, the edge widths will be 
scaled proportional to the inverse of the observed distance , with the 
lines becoming thicker for more related nodes.</p>
</td></tr>
<tr><td><code id="poppr.msn_+3A_showplot">showplot</code></td>
<td>
<p>logical. If <code>TRUE</code>, the graph will be plotted. If 
<code>FALSE</code>, it will simply be returned.</p>
</td></tr>
<tr><td><code id="poppr.msn_+3A_include.ties">include.ties</code></td>
<td>
<p>logical. If <code>TRUE</code>, the graph will include all edges
that were arbitrarily passed over in favor of another edge of equal weight.
If <code>FALSE</code>, which is the default, one edge will be arbitrarily 
selected when two or more edges are tied, resulting in a pure minimum
spanning network.</p>
</td></tr>
<tr><td><code id="poppr.msn_+3A_threshold">threshold</code></td>
<td>
<p>numeric. By default, this is <code>NULL</code>, which will have no
effect. Any threshold value passed to this argument will be used in
<code><a href="#topic+mlg.filter">mlg.filter</a></code> prior to creating the MSN. If you have a data set
that contains contracted MLGs, this argument will override the threshold in
the data set. See Details.</p>
</td></tr>
<tr><td><code id="poppr.msn_+3A_clustering.algorithm">clustering.algorithm</code></td>
<td>
<p>string. By default, this is <code>NULL</code>. If
<code>threshold = NULL</code>, this argument will have no effect. When supplied
with either &quot;farthest_neighbor&quot;, &quot;average_neighbor&quot;, or &quot;nearest_neighbor&quot;,
it will be passed to <code><a href="#topic+mlg.filter">mlg.filter</a></code> prior to creating the MSN. If
you have a data set that contains contracted MLGs, this argument will
override the algorithm in the data set. See Details.</p>
</td></tr>
<tr><td><code id="poppr.msn_+3A_...">...</code></td>
<td>
<p>any other arguments that could go into plot.igraph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The minimum spanning network generated by this function is generated
via igraph's <code><a href="igraph.html#topic+mst">minimum.spanning.tree</a></code>. The resultant
graph produced can be plotted using igraph functions, or the entire object
can be plotted using the function <code><a href="#topic+plot_poppr_msn">plot_poppr_msn</a></code>, which will
give the user a scale bar and the option to layout your data.
</p>


<h4>node sizes</h4>

<p>The area of the nodes are representative of the number of samples. Because
<span class="pkg">igraph</span> scales nodes by radius, the node sizes in the graph are 
represented as the square root of the number of samples.</p>



<h4>mlg.compute</h4>

<p>Each node on the graph represents a different multilocus genotype. 
The edges on the graph represent genetic distances that connect the
multilocus genotypes. In genclone objects, it is possible to set the
multilocus genotypes to a custom definition. This creates a problem for
clone correction, however, as it is very possible to define custom lineages
that are not monophyletic. When clone correction is performed on these
definitions, information is lost from the graph. To circumvent this, The
clone correction will be done via the computed multilocus genotypes, either
&quot;original&quot; or &quot;contracted&quot;. This is specified in the <code>mlg.compute</code>
argument, above.</p>



<h4>contracted multilocus genotypes</h4>

<p>If your incoming data set is of the class <code><a href="#topic+genclone-class">genclone</a></code>,
and it contains contracted multilocus genotypes, this function will retain
that information for creating the minimum spanning network. You can use the
arguments <code>threshold</code> and <code>clustering.algorithm</code> to change the
threshold or clustering algorithm used in the network. For example, if you
have a data set that has a threshold of 0.1 and you wish to have a minimum
spanning network without a threshold, you can simply add 
<code>threshold = 0.0</code>, and no clustering will happen. 
</p>
<p>The <code>threshold</code> and <code>clustering.algorithm</code> arguments can also be
used to filter un-contracted data sets.
</p>
<p>All filtering will use the distance matrix supplied in the argument 
<code>distmat</code>.
</p>



<h3>Value</h3>

<table>
<tr><td><code>graph</code></td>
<td>
<p>a minimum spanning network with nodes corresponding to 
MLGs within the data set. Colors of the nodes represent population 
membership. Width and color of the edges represent distance.</p>
</td></tr> 
<tr><td><code>populations</code></td>
<td>
<p>a vector of the population names corresponding to the 
vertex colors</p>
</td></tr> <tr><td><code>colors</code></td>
<td>
<p>a vector of the hexadecimal representations of
the colors used in the vertex colors</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The edges of these graphs may cross each other if the graph becomes too
large.
</p>


<h3>Author(s)</h3>

<p>Javier F. Tabima, Zhian N. Kamvar, Jonah C. Brooks
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_poppr_msn">plot_poppr_msn</a></code> <code><a href="adegenet.html#topic+nancycats">nancycats</a></code>,
<code><a href="#topic+upgma">upgma</a></code>, <code><a href="ape.html#topic+nj">nj</a></code>, <code><a href="ape.html#topic+nodelabels">nodelabels</a></code>,
<code><a href="adegenet.html#topic+tab">tab</a></code>, <code><a href="#topic+missingno">missingno</a></code>, <code><a href="#topic+bruvo.msn">bruvo.msn</a></code>,
<code><a href="#topic+greycurve">greycurve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load the data set and calculate the distance matrix for all individuals.
data(Aeut)
A.dist &lt;- diss.dist(Aeut)

# Graph it.
A.msn &lt;- poppr.msn(Aeut, A.dist, gadj = 15, vertex.label = NA)

# Find the sizes of the nodes (number of individuals per MLL):
igraph::vertex_attr(A.msn$graph, "size")^2

## Not run: 
# Set subpopulation structure.
Aeut.sub &lt;- as.genclone(Aeut)
setPop(Aeut.sub) &lt;- ~Pop/Subpop

# Plot respective to the subpopulation structure
As.msn &lt;- poppr.msn(Aeut.sub, A.dist, gadj=15, vertex.label=NA)

# Show only the structure of the Athena population.
As.msn &lt;- poppr.msn(Aeut.sub, A.dist, gadj=15, vertex.label=NA, sublist=1:10)

# Let's look at the structure of the microbov data set

library("igraph")
data(microbov)
micro.dist &lt;- diss.dist(microbov, percent = TRUE)
micro.msn &lt;- poppr.msn(microbov, micro.dist, vertex.label=NA)

# Let's plot it and show where individuals have &lt; 15% of their genotypes 
# different.

edge_weight &lt;- E(micro.msn$graph)$weight
edge_labels &lt;- ifelse(edge_weight &lt; 0.15, round(edge_weight, 3), NA)
plot.igraph(micro.msn$graph, edge.label = edge_labels, vertex.size = 2, 
edge.label.color = "red")


## End(Not run)

</code></pre>

<hr>
<h2 id='poppr.plot'>Internal function to plot the results from ia() and poppr()</h2><span id='topic+poppr.plot'></span>

<h3>Description</h3>

<p>Internal function to plot the results from ia() and poppr()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poppr.plot(
  sample,
  pval = c(Ia = 0.05, rbarD = 0.05),
  pop = NULL,
  file = NULL,
  N = NULL,
  observed = c(Ia = 0, rbarD = 0),
  index = c("rbarD", "Ia"),
  labsize = rel(3),
  linesize = rel(1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poppr.plot_+3A_sample">sample</code></td>
<td>
<p>either an object of class &quot;ialist&quot; or a list of ialists</p>
</td></tr>
<tr><td><code id="poppr.plot_+3A_pval">pval</code></td>
<td>
<p>a named vector specifying the p values to display</p>
</td></tr>
<tr><td><code id="poppr.plot_+3A_pop">pop</code></td>
<td>
<p>The name of the population</p>
</td></tr>
<tr><td><code id="poppr.plot_+3A_file">file</code></td>
<td>
<p>The name of the source file</p>
</td></tr>
<tr><td><code id="poppr.plot_+3A_n">N</code></td>
<td>
<p>The number of samples in the population</p>
</td></tr>
<tr><td><code id="poppr.plot_+3A_observed">observed</code></td>
<td>
<p>observed values of Ia and rbarD</p>
</td></tr>
<tr><td><code id="poppr.plot_+3A_index">index</code></td>
<td>
<p>The index to plot (defaults to &quot;rbarD&quot;)</p>
</td></tr>
<tr><td><code id="poppr.plot_+3A_labsize">labsize</code></td>
<td>
<p>size of the in-plot label</p>
</td></tr>
<tr><td><code id="poppr.plot_+3A_linesize">linesize</code></td>
<td>
<p>size of the in-plot line</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(Pinf)
x &lt;- Pinf %&gt;% seppop() %&gt;% lapply(ia, sample = 99, valuereturn = TRUE, quiet = TRUE, plot = FALSE)
x
poppr:::poppr.plot(sample = x, file = "hey") # plots multiple populations
# plot.ialist takes care of the single populations.
for (i in x){
  print(plot(i))
}

## End(Not run)

</code></pre>

<hr>
<h2 id='popsub'>Subset data by population</h2><span id='topic+popsub'></span>

<h3>Description</h3>

<p>Create a new dataset with specified populations or exclude specified
populations from the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popsub(
  gid,
  sublist = "ALL",
  exclude = NULL,
  blacklist = NULL,
  mat = NULL,
  drop = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="popsub_+3A_gid">gid</code></td>
<td>
<p>a <code><a href="adegenet.html#topic+genind-class">genind</a></code>, <code><a href="#topic+genclone-class">genclone</a></code>,
<code><a href="adegenet.html#topic+genlight-class">genlight</a></code>, or <code><a href="#topic+snpclone-class">snpclone</a></code> object.</p>
</td></tr>
<tr><td><code id="popsub_+3A_sublist">sublist</code></td>
<td>
<p>a <code>vector</code> of population names or indexes that the user
wishes to keep. Default to <code>"ALL"</code>.</p>
</td></tr>
<tr><td><code id="popsub_+3A_exclude">exclude</code></td>
<td>
<p>a <code>vector</code> of population names or indexes that the user
wishes to discard. Default to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="popsub_+3A_blacklist">blacklist</code></td>
<td>
<p>DEPRECATED, use exclude.</p>
</td></tr>
<tr><td><code id="popsub_+3A_mat">mat</code></td>
<td>
<p>a <code>matrix</code> object produced by <code><a href="#topic+mlg.table">mlg.table</a></code> to be
subsetted. If this is present, the subsetted matrix will be returned instead
of the genind object</p>
</td></tr>
<tr><td><code id="popsub_+3A_drop">drop</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, unvarying alleles will be dropped
from the population.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>genind</code> object or a matrix.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the dataset microbov.
data(microbov)

# List the population names.
popNames(microbov)

# Analyze only the populations with exactly 50 individuals
mic.50 &lt;- popsub(microbov, sublist=c(1:6, 11:15), exclude=c(3,4,13,14))

## Not run: 
# Analyze the first 10 populations, except for "Bazadais"
mic.10 &lt;- popsub(microbov, sublist=1:10, exclude="Bazadais")

# Take out the two smallest populations
micbig &lt;- popsub(microbov, exclude=c("NDama", "Montbeliard"))

# Analyze the two largest populations
miclrg &lt;- popsub(microbov, sublist=c("BlondeAquitaine", "Charolais"))

## End(Not run)
</code></pre>

<hr>
<h2 id='Pram'>Phytophthora ramorum data from OR Forests and Nurseries (OR and CA)</h2><span id='topic+Pram'></span>

<h3>Description</h3>

<p>This is the data set from 
<a href="https://doi.org/10.5281/zenodo.13007">doi:10.5281/zenodo.13007</a>. It has been converted to the 
genclone object as of poppr version 2.0. It contains 729 samples of the 
Sudden Oak Death pathogen *Phytophthora ramorum* genotyped over five 
microsatellite loci (Kamvar et. al., 2015). 513 samples were collected from
forests in Curry County, OR from 2001 to mid-2014 (labeled by watershed
region). The other 216 samples represents genotypes collected from
Nurseries in OR and CA from Goss et. al. (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Pram)
</code></pre>


<h3>Format</h3>

<p>a [genclone-class] object with 3 hierarchical levels 
called &quot;SOURCE&quot;, &quot;YEAR&quot;, and, &quot;STATE&quot;. The <strong>other</strong> slot contains a 
named vector of repeat lengths called <strong>&quot;REPLEN&quot;</strong>, a matrix of xy 
coordinates for the forest samples called <strong>&quot;xy&quot;</strong>, and a palette to 
color the ~SOURCE/STATE stratification called <strong>&quot;comparePal&quot;</strong>.
</p>


<h3>References</h3>

<p>Kamvar, Z. N., Larsen, M. M., Kanaskie, A. M., Hansen, E. M., &amp; 
Grünwald, N. J. (2015). Spatial and temporal analysis of populations of the
sudden oak death pathogen in Oregon forests. Phytopathology 105:982-989. 
doi:
<a href="https://doi.org/10.1094/PHYTO-12-14-0350-FI">doi:10.1094/PHYTO-12-14-0350-FI</a>
</p>
<p>Zhian N. Kamvar, Meg M. Larsen, Alan M. Kanaskie, Everett M. Hansen, &amp; 
Niklaus J. Grünwald. 2014. Sudden_Oak_Death_in_Oregon_Forests: Spatial and 
temporal population dynamics of the sudden oak death epidemic in Oregon 
Forests. ZENODO, doi:
<a href="https://doi.org/10.5281/zenodo.13007">doi:10.5281/zenodo.13007</a>
</p>
<p>Goss, E. M., Larsen, M., Chastagner, G. A., Givens, D. R., and Grünwald, N.
J. 2009. Population genetic analysis infers migration pathways of 
*Phytophthora ramorum* in US nurseries. PLoS Pathog. 5:e1000583. doi:
<a href="https://doi.org/10.1371/journal.ppat.1000583">doi:10.1371/journal.ppat.1000583</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Pram)

# Repeat lengths (previously processed via fix_replen)
other(Pram)$REPLEN

# Color palette for source by state. Useful for minimum spanning networks
other(Pram)$comparePal
</code></pre>

<hr>
<h2 id='private_alleles'>Tabulate alleles the occur in only one population.</h2><span id='topic+private_alleles'></span>

<h3>Description</h3>

<p>Tabulate alleles the occur in only one population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>private_alleles(
  gid,
  form = alleles ~ .,
  report = "table",
  level = "population",
  count.alleles = TRUE,
  drop = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="private_alleles_+3A_gid">gid</code></td>
<td>
<p>a <a href="adegenet.html#topic+genind">adegenet::genind</a> or <a href="#topic+genclone-class">genclone</a>
object.</p>
</td></tr>
<tr><td><code id="private_alleles_+3A_form">form</code></td>
<td>
<p>a <code><a href="stats.html#topic+formula">formula()</a></code> giving the levels of markers and
hierarchy to analyze. See Details.</p>
</td></tr>
<tr><td><code id="private_alleles_+3A_report">report</code></td>
<td>
<p>one of <code style="white-space: pre;">&#8288;"table", "vector",&#8288;</code> or <code>"data.frame"</code>. Tables
(Default) and data frame will report counts along with populations or
individuals. Vectors will simply report which populations or individuals
contain private alleles. Tables are matrices with populations or
individuals in rows and alleles in columns. Data frames are long form.</p>
</td></tr>
<tr><td><code id="private_alleles_+3A_level">level</code></td>
<td>
<p>one of <code>"population"</code> (Default) or <code>"individual"</code>.</p>
</td></tr>
<tr><td><code id="private_alleles_+3A_count.alleles">count.alleles</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code> (Default), The report
will return the observed number of alleles private to each population. If
<code>FALSE</code>, each private allele will be counted once, regardless of
dosage.</p>
</td></tr>
<tr><td><code id="private_alleles_+3A_drop">drop</code></td>
<td>
<p><code>logical</code>. if <code>TRUE</code>, populations/individuals without
private alleles will be dropped from the result. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the argument <code>form</code> allows for control over the strata at which
private alleles should be computed. It takes a form where the left hand
side of the formula can be either &quot;allele&quot;, &quot;locus&quot;, or &quot;loci&quot;. The right
hand of the equation, by default is &quot;.&quot;. If you change it, it must
correspond to strata located in the <code><a href="adegenet.html#topic+strata-methods">adegenet::strata()</a></code> slot.
Note, that the right hand side is disabled for genpop objects.
</p>


<h3>Value</h3>

<p>a matrix, data.frame, or vector defining the populations or
individuals containing private alleles. If vector is chosen, alleles are
not defined.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Pinf) # Load P. infestans data.
private_alleles(Pinf)

## Not run: 
# Analyze private alleles based on the country of interest:
private_alleles(Pinf, alleles ~ Country)

# Number of observed alleles per locus
private_alleles(Pinf, locus ~ Country, count.alleles = TRUE)

# Get raw number of private alleles per locus.
(pal &lt;- private_alleles(Pinf, locus ~ Country, count.alleles = FALSE))

# Get percentages.
sweep(pal, 2, nAll(Pinf)[colnames(pal)], FUN = "/")

# An example of how these data can be displayed.
library("ggplot2")
Pinfpriv &lt;- private_alleles(Pinf, report = "data.frame")
ggplot(Pinfpriv) + geom_tile(aes(x = population, y = allele, fill = count))

## End(Not run)
</code></pre>

<hr>
<h2 id='psex'>Probability of encountering a genotype more than once by chance</h2><span id='topic+psex'></span>

<h3>Description</h3>

<p>Probability of encountering a genotype more than once by chance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psex(
  gid,
  pop = NULL,
  by_pop = TRUE,
  freq = NULL,
  G = NULL,
  method = c("single", "multiple"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psex_+3A_gid">gid</code></td>
<td>
<p>a genind or genclone object.</p>
</td></tr>
<tr><td><code id="psex_+3A_pop">pop</code></td>
<td>
<p>either a formula to set the population factor from the 
<code><a href="survival.html#topic+strata">strata</a></code> slot or a vector specifying the population factor for 
each sample. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="psex_+3A_by_pop">by_pop</code></td>
<td>
<p>When this is <code>TRUE</code> (default), the calculation will be
done by population.</p>
</td></tr>
<tr><td><code id="psex_+3A_freq">freq</code></td>
<td>
<p>a vector or matrix of allele frequencies. This defaults to 
<code>NULL</code>, indicating that the frequencies will be determined via 
round-robin approach in <code><a href="#topic+rraf">rraf</a></code>. <strong>If this matrix or 
vector is not provided, zero-value allele frequencies will automatically be
corrected.</strong> For details, please see the documentation on
<a href="#topic+rare_allele_correction">correcting rare alleles</a>.</p>
</td></tr>
<tr><td><code id="psex_+3A_g">G</code></td>
<td>
<p>an integer vector specifying the number of observed genets. If NULL,
this will be the number of original multilocus genotypes for 
<code>method = "single"</code> and the number of populations for 
<code>method = "multiple"</code>. <code>G</code> can also be a <strong>named</strong> integer 
vector for each population if <code>by_pop = TRUE</code>. Unnamed vectors with
a lengths greater than 1 will throw an error.</p>
</td></tr>
<tr><td><code id="psex_+3A_method">method</code></td>
<td>
<p>which method of calculating psex should be used? Using 
<code>method = "single"</code> (default) indicates that the calculation for psex 
should reflect the probability of encountering a second genotype. Using 
<code>method = "multiple"</code> gives the probability of encountering multiple 
samples of the same genotype (see details).</p>
</td></tr>
<tr><td><code id="psex_+3A_...">...</code></td>
<td>
<p>options from <a href="#topic+rare_allele_correction">correcting rare
alleles</a>. The default is to correct allele frequencies to 1/n</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>single encounter:</h4>

<p>Psex is the probability of encountering a given genotype more than 
once by chance. The basic equation from Parks and Werth (1993) is
</p>
<p style="text-align: center;"><code class="reqn">p_{sex} = 1 - (1 - p_{gen})^{G})</code>
</p>

<p>where <em>G</em> is the number of multilocus genotypes and <em>pgen</em> is the
probability of a given genotype (see
<code><a href="#topic+pgen">pgen</a></code> for its calculation). For a given value of alpha (e.g.
alpha = 0.05), genotypes with psex &lt; alpha can be thought of as a single
genet whereas genotypes with psex &gt; alpha do not have strong evidence that
members belong to the same genet (Parks and Werth, 1993).
</p>



<h4>multiple encounters:</h4>

<p>When <code>method = "multiple"</code>, the method from Arnaud-Haond et al. (1997)
is used where the sum of the binomial density is taken.
</p>
<p style="text-align: center;"><code class="reqn">
  p_{sex} = \sum_{i = n}^N {N \choose i} \left(p_{gen}\right)^i\left(1 - p_{gen}\right)^{N - i}
  </code>
</p>

<p>where <em>N</em> is the number of sampling units <em>i</em> is the ith - 1 
encounter of a given genotype, and <em>pgen</em> is the value of pgen for 
that genotype. This procedure is performed for all samples in the data.
For example, if you have a genotype whose pgen value was 0.0001, with 5 
observations out of 100 samples, the value of psex is computed like so:
</p>
<pre>
  dbinom(0:4, 100, 0.0001)</pre>



<h4>using by_pop = TRUE and modifying G:</h4>

<p>It is possible to modify <code>G</code> for single or multiple encounters. With
<code>method = "single"</code>, <code>G</code> takes place of the exponent, whereas 
with <code>method = "multiple"</code>, <code>G</code> replaces <code>N</code> (see above). 
If you supply a named vector for <code>G</code> with the population names and
<code>by_pop = TRUE</code>, then the value of <code>G</code> will be different for each
population. 
</p>
<p>For example, in the case of <code>method = "multiple"</code>, let's say you have
two populations that share a genotype between them. The size of population
A and B are 25 and 75, respectively, The values of pgen for that genotype
in population A and B are 0.005 and 0.0001, respectively, and the number of
samples with the genotype in popualtions A and B are 4 and 6, respectively.
In this case psex for this genotype would be calculated for each population
separately if we don't specify <code>G</code>:
</p>
<pre>
  psexA = dbinom(0:3, 25, 0.005)
  psexB = dbinom(0:5, 75, 0.0001)</pre>
<p>If we specify <code>G = 100</code>, then it changes to:
</p>
<pre>
  psexA = dbinom(0:3, 100, 0.005)
  psexB = dbinom(0:5, 100, 0.0001)</pre>
<p>We could also specify G to be the number of genotypes observed in the 
population (let's say A = 10, B = 20)
</p>
<pre>
  psexA = dbinom(0:3, 10, 0.005)
  psexB = dbinom(0:5, 20, 0.0001)</pre>

<p>Unless <code>freq</code> is supplied, the function will automatically calculate
the round-robin allele frequencies with <code><a href="#topic+rraf">rraf</a></code> and <em>G</em>
with <code><a href="#topic+nmll">nmll</a></code>.
</p>


<h3>Value</h3>

<p>a vector of Psex for each sample.
</p>


<h3>Note</h3>

<p>The values of Psex represent the value for each multilocus genotype. 
Additionally, when the argument <code>pop</code> is not <code>NULL</code>, 
<code>by_pop</code> is automatically <code>TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar, Jonah Brooks, Stacy A. Krueger-Hadfield, Erik Sotka
</p>


<h3>References</h3>

<p>Arnaud-Haond, S., Duarte, C. M., Alberto, F., &amp; Serrão, E. A. 2007. 
Standardizing methods to address clonality in population studies. 
<em>Molecular Ecology</em>, 16(24), 5115-5139.
</p>
<p>Parks, J. C., &amp; Werth, C. R. 1993. A study of spatial features of clones in a
population of bracken fern, <em>Pteridium aquilinum</em> (Dennstaedtiaceae). 
<em>American Journal of Botany</em>, 537-544.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pgen">pgen</a></code>, <code><a href="#topic+rraf">rraf</a></code>, <code><a href="#topic+rrmlg">rrmlg</a></code>,
<code><a href="#topic+rare_allele_correction">rare_allele_correction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Pram)

# With multiple encounters
Pram_psex &lt;- psex(Pram, by_pop = FALSE, method = "multiple")
plot(Pram_psex, log = "y", col = ifelse(Pram_psex &gt; 0.05, "red", "blue"))
abline(h = 0.05, lty = 2)
title("Probability of multiple encounters")
## Not run: 

# For a single encounter (default)
Pram_psex &lt;- psex(Pram, by_pop = FALSE)
plot(Pram_psex, log = "y", col = ifelse(Pram_psex &gt; 0.05, "red", "blue"))
abline(h = 0.05, lty = 2)
title("Probability of second encounter")

# This can be also done assuming populations structure
Pram_psex &lt;- psex(Pram, by_pop = TRUE, method = "multiple")
plot(Pram_psex, log = "y", col = ifelse(Pram_psex &gt; 0.05, "red", "blue"))
abline(h = 0.05, lty = 2)
title("Probability of multiple encounters\nwith pop structure")

# The above, but correcting zero-value alleles by 1/(2*rrmlg) with no 
# population structure assumed
# Type ?rare_allele_correction for details.
Pram_psex2 &lt;- psex(Pram, by_pop = FALSE, d = "rrmlg", mul = 1/2, method = "multiple")
plot(Pram_psex2, log = "y", col = ifelse(Pram_psex2 &gt; 0.05, "red", "blue"))
abline(h = 0.05, lty = 2)
title("Probability of multiple encounters\nwith pop structure (1/(2*rrmlg))")

# We can also set G to the total population size
(G &lt;- nInd(Pram))
Pram_psex &lt;- psex(Pram, by_pop = TRUE, method = "multiple", G = G)
plot(Pram_psex, log = "y", col = ifelse(Pram_psex &gt; 0.05, "red", "blue"))
abline(h = 0.05, lty = 2)
title("Probability of multiple encounters\nwith pop structure G = 729")

# Or we can set G to the number of unique MLGs
(G &lt;- rowSums(mlg.table(Pram, plot = FALSE) &gt; 0))
Pram_psex &lt;- psex(Pram, by_pop = TRUE, method = "multiple", G = G)
plot(Pram_psex, log = "y", col = ifelse(Pram_psex &gt; 0.05, "red", "blue"))
abline(h = 0.05, lty = 2)
title("Probability of multiple encounters\nwith pop structure G = nmll")

## An example of supplying previously calculated frequencies and G
# From Parks and Werth, 1993, using the first three genotypes.

# The row names indicate the number of samples found with that genotype
x &lt;- "
 Hk Lap Mdh2 Pgm1 Pgm2 X6Pgd2
54 12 12 12 23 22 11
36 22 22 11 22 33 11
10 23 22 11 33 13 13"

# Since we aren't representing the whole data set here, we are defining the
# allele frequencies before the analysis.
afreq &lt;- c(Hk.1 = 0.167, Hk.2 = 0.795, Hk.3 = 0.038, 
           Lap.1 = 0.190, Lap.2 = 0.798, Lap.3 = 0.012,
           Mdh2.0 = 0.011, Mdh2.1 = 0.967, Mdh2.2 = 0.022,
           Pgm1.2 = 0.279, Pgm1.3 = 0.529, Pgm1.4 = 0.162, Pgm1.5 = 0.029,
           Pgm2.1 = 0.128, Pgm2.2 = 0.385, Pgm2.3 = 0.487,
           X6Pgd2.1 = 0.526, X6Pgd2.2 = 0.051, X6Pgd2.3 = 0.423)

xtab &lt;- read.table(text = x, header = TRUE, row.names = 1)

# Here we are expanding the number of samples to their observed values.
# Since we have already defined the allele frequencies, this step is actually
# not necessary. 
all_samples &lt;- rep(rownames(xtab), as.integer(rownames(xtab)))
xgid        &lt;- df2genind(xtab[all_samples, ], ncode = 1)

freqs &lt;- afreq[colnames(tab(xgid))] # only used alleles in the sample
pSex  &lt;- psex(xgid, by_pop = FALSE, freq = freqs, G = 45)

# Note, pgen returns log values for each locus, here we take the sum across
# all loci and take the exponent to give us the value of pgen for each sample
pGen &lt;- exp(rowSums(pgen(xgid, by_pop = FALSE, freq = freqs)))

res  &lt;- matrix(c(unique(pGen), unique(pSex)), ncol = 2)
colnames(res) &lt;- c("Pgen", "Psex")
res &lt;- cbind(xtab, nRamet = rownames(xtab), round(res, 5))
rownames(res) &lt;- 1:3
res # Compare to the first three rows of Table 2 in Parks &amp; Werth, 1993

## End(Not run)
</code></pre>

<hr>
<h2 id='rare_allele_correction'>Correcting rare allele frequencies</h2><span id='topic+rare_allele_correction'></span>

<h3>Description</h3>

<p>The following is a set of arguments for use in <code><a href="#topic+rraf">rraf</a></code>, 
<code><a href="#topic+pgen">pgen</a></code>, and <code><a href="#topic+psex">psex</a></code> to correct rare allele frequencies
that were lost in estimating round-robin allele frequencies.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="rare_allele_correction_+3A_e">e</code></td>
<td>
<p>a numeric epsilon value to use for all missing allele frequencies.</p>
</td></tr>
<tr><td><code id="rare_allele_correction_+3A_d">d</code></td>
<td>
<p>the unit by which to take the reciprocal. <code>div = "sample"</code> will
be 1/(n samples), <code>d = "mlg"</code> will be 1/(n mlg), and <code>d = 
"rrmlg"</code> will be 1/(n mlg at that locus). This is overridden by <code>e</code>.</p>
</td></tr>
<tr><td><code id="rare_allele_correction_+3A_mul">mul</code></td>
<td>
<p>a multiplier for div. Default is <code>mul = 1</code>. This parameter 
is overridden by <code>e</code></p>
</td></tr>
<tr><td><code id="rare_allele_correction_+3A_sum_to_one">sum_to_one</code></td>
<td>
<p>when <code>TRUE</code>, the original frequencies will be reduced 
so that all allele frequencies will sum to one. <strong>Default: 
<code>FALSE</code></strong></p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default (<code>d = "sample", e = NULL, sum_to_one = FALSE, mul =
1</code>), this will add 1/(n samples) to all zero-value alleles. The basic formula
is <strong>1/(d * m)</strong> unless <strong>e</strong> is specified. If <code>sum_to_one = 
TRUE</code>, then the frequencies will be scaled as x/sum(x) AFTER correction, 
indicating that the allele frequencies will be reduced. See the examples for 
details. The general pattern of correction is that the value of the MAF will 
be <em>rrmlg &gt; mlg &gt; sample</em>
</p>


<h3>Motivation</h3>

<p>When <a href="#topic+rraf">calculating allele frequencies from a round-robin
approach</a>, rare alleles are often lost resulting in zero-valued allele
frequencies (Arnaud-Haond et al. 2007, Parks and Werth 1993). This can be
problematic when calculating values for <code><a href="#topic+pgen">pgen</a></code> and
<code><a href="#topic+psex">psex</a></code> because frequencies of zero will result in undefined
values for samples that contain those rare alleles. The solution to this
problem is to give an estimate for the frequency of those rare alleles, but
the question of HOW to do that arises. These arguments provide a way to
define how rare alleles are to be estimated/corrected.
</p>


<h3>Using these arguments</h3>

<p>These arguments are for use in the functions <code><a href="#topic+rraf">rraf</a></code>, 
<code><a href="#topic+pgen">pgen</a></code>, and <code><a href="#topic+psex">psex</a></code>. They will replace the dots (...) 
that appear at the end of the function call. For example, if you want to set 
the minor allele frequencies to a specific value (let's say 0.001),
regardless of locus, you can insert <code>e = 0.001</code> along with any other 
arguments (note, position is not specific): </p>
<pre>
pgen(my_data, e = 0.001, log = FALSE) 
psex(my_data, method = "multiple", e = 0.001)</pre>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>References</h3>

<p>Arnaud-Haond, S., Duarte, C. M., Alberto, F., &amp; Serrão, E. A. 2007.
Standardizing methods to address clonality in population studies.
<em>Molecular Ecology</em>, 16(24), 5115-5139.
</p>
<p>Parks, J. C., &amp; Werth, C. R. 1993. A study of spatial features of clones in a
population of bracken fern, <em>Pteridium aquilinum</em> (Dennstaedtiaceae).
<em>American Journal of Botany</em>, 537-544.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rraf">rraf</a></code>, 
<code><a href="#topic+pgen">pgen</a></code>, 
<code><a href="#topic+psex">psex</a></code>, 
<code><a href="#topic+rrmlg">rrmlg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

data(Pram)
#-------------------------------------

# If you set correction = FALSE, you'll notice the zero-valued alleles

rraf(Pram, correction = FALSE)

# By default, however, the data will be corrected by 1/n

rraf(Pram)

# Of course, this is a diploid organism, we might want to set 1/2n

rraf(Pram, mul = 1/2)

# To set MAF = 1/2mlg

rraf(Pram, d = "mlg", mul = 1/2)

# Another way to think about this is, since these allele frequencies were
# derived at each locus with different sample sizes, it's only appropriate to
# correct based on those sample sizes.

rraf(Pram, d = "rrmlg", mul = 1/2)

# If we were going to use these frequencies for simulations, we might want to
# ensure that they all sum to one. 

rraf(Pram, d = "mlg", mul = 1/2, sum_to_one = TRUE) 

#-------------------------------------
# When we calculate these frequencies based on population, they are heavily
# influenced by the number of observed mlgs. 

rraf(Pram, by_pop = TRUE, d = "rrmlg", mul = 1/2)

# This can be fixed by specifying a specific value

rraf(Pram, by_pop = TRUE, e = 0.01)


## End(Not run)
</code></pre>

<hr>
<h2 id='read.genalex'>Importing data from genalex formatted \*.csv files.</h2><span id='topic+read.genalex'></span>

<h3>Description</h3>

<p>read.genalex will read in a genalex-formatted file that has been exported in
a comma separated format and will parse most types of genalex data. The
output is a <a href="#topic+genclone">genclone-class</a> or <a href="adegenet.html#topic+genind">genind-class</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.genalex(
  genalex,
  ploidy = 2,
  geo = FALSE,
  region = FALSE,
  genclone = TRUE,
  sep = ",",
  recode = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.genalex_+3A_genalex">genalex</code></td>
<td>
<p>a \*.csv file exported from genalex</p>
</td></tr>
<tr><td><code id="read.genalex_+3A_ploidy">ploidy</code></td>
<td>
<p>an integer to indicate the ploidy of the dataset</p>
</td></tr>
<tr><td><code id="read.genalex_+3A_geo">geo</code></td>
<td>
<p>indicates the presence of geographic data in the file. This data
will be included in a data frame labeled <code>xy</code> in the
<code><a href="adegenet.html#topic+other">other()</a></code> slot.</p>
</td></tr>
<tr><td><code id="read.genalex_+3A_region">region</code></td>
<td>
<p>indicates the presence of regional data in the file.</p>
</td></tr>
<tr><td><code id="read.genalex_+3A_genclone">genclone</code></td>
<td>
<p>when <code>TRUE</code> (default), the output will be a <a href="#topic+genclone-class">genclone</a>
object. When <code>FALSE</code>, the output will be a <a href="adegenet.html#topic+genind-class">genind</a> object</p>
</td></tr>
<tr><td><code id="read.genalex_+3A_sep">sep</code></td>
<td>
<p>A character specifying the column separator of the data. Defaults
to &quot;,&quot;.</p>
</td></tr>
<tr><td><code id="read.genalex_+3A_recode">recode</code></td>
<td>
<p><strong>For polyploid data</strong>: Do you want to recode your data to
have varying ploidy? Default is <code>FALSE</code>, and the data will be returned
with even ploidy where missing alleles are coded as &quot;0&quot;. When <code>TRUE</code>,
the data is run through the function <code><a href="#topic+recode_polyploids">recode_polyploids()</a></code> before
being returned. Note that this will prevent conversion to genpop objects in
the future. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The resulting <a href="#topic+genclone">genclone-class</a> or <a href="adegenet.html#topic+genind">genind-class</a>
object will have a single strata defined in the strata slot. This will be
called &quot;Pop&quot; and will reflect the population factor defined in the genalex
input. If <code>region = TRUE</code>, a second column will be inserted and labeled
&quot;Region&quot;. If you have more than two strata within your data set, you should
run the command <code><a href="adegenet.html#topic+strata-methods">adegenet::splitStrata()</a></code> on your data set to define the
unique stratifications.
</p>


<h4>FOR POLYPLOID (&gt; 2n) DATA SETS</h4>

<p> The genind object has
an all-or-none approach to missing data. If a sample has missing data at a
particular locus, then the entire locus is considered missing. This works
for diploids and haploids where allelic dosage is unambiguous. For
polyploids this poses a problem as much of the data set would be
transformed into missing data. With this function, I have created a
workaround.
</p>
<p>When importing polyploid data sets, missing data is scored as &quot;0&quot; and kept
within the genind object as an extra allele. This will break most analyses
relying on allele frequencies*. All of the functions in poppr will work
properly with these data sets as multilocus genotype analysis is agnostic
of ploidy and we have written both Bruvo's distance and the index of
association in such a way as to be able to handle polyploids presented in
this manner.
</p>
<p>\* To restore functionality of analyses relying on allele frequencies, use
the <code><a href="#topic+recode_polyploids">recode_polyploids()</a></code> function.</p>



<h3>Value</h3>

<p>A <a href="#topic+genclone-class">genclone</a> or <a href="adegenet.html#topic+genind-class">genind</a> bject.
</p>


<h3>Note</h3>

<p>This function cannot handle raw allele frequency data.
</p>
<p>In the case that there are duplicated names within the file, this function
will assume separate individuals and rename each one to a sequence of
integers from 1 to the number of individuals. A vector of the original
names will be saved in the <code>other</code> slot under <code>original_names</code>.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genind2genalex">genind2genalex()</a></code>, <code><a href="#topic+clonecorrect">clonecorrect()</a></code>, <a href="#topic+genclone-class">genclone</a>,
<a href="adegenet.html#topic+genind-class">genind</a>, <code><a href="#topic+recode_polyploids">recode_polyploids()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
Aeut &lt;- read.genalex(system.file("files/rootrot.csv", package="poppr"))

genalex2 &lt;- read.genalex("genalex2.csv", geo=TRUE)
# A genalex file with geographic coordinate data.

genalex3 &lt;- read.genalex("genalex3.csv", region=TRUE) 
# A genalex file with regional information.

genalex4 &lt;- read.genalex("genalex4.csv", region=TRUE, geo=TRUE) 
# A genalex file with both regional and geographic information.

## End(Not run)
</code></pre>

<hr>
<h2 id='recode_polyploids'>Recode polyploid microsatellite data for use in frequency based statistics.</h2><span id='topic+recode_polyploids'></span>

<h3>Description</h3>

<p>As the genind object requires ploidy to be consistent across loci, a 
workaround to importing polyploid data was to code missing alleles as &quot;0&quot; 
(for microsatellite data sets). The advantage of this is that users would be 
able to calculate Bruvo's distance, the index of association, and genotypic 
diversity statistics. The tradeoff was the fact that this broke all other 
analyses as they relied on allele frequencies and the missing alleles are 
treated as extra alleles. This function removes those alleles and returns a 
<code><a href="#topic+genclone-class">genclone</a></code> or <code><a href="adegenet.html#topic+genind-class">genind</a></code> object where 
allele frequencies are coded based on the number of alleles observed at a 
single locus per individual. See the examples for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recode_polyploids(poly, newploidy = FALSE, addzero = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recode_polyploids_+3A_poly">poly</code></td>
<td>
<p>a <code><a href="#topic+genclone-class">genclone</a></code>, <code><a href="adegenet.html#topic+genind-class">genind</a></code>, or 
<code><a href="adegenet.html#topic+genpop-class">genpop</a></code> object that has a ploidy of &gt; 2</p>
</td></tr>
<tr><td><code id="recode_polyploids_+3A_newploidy">newploidy</code></td>
<td>
<p>for genind or genclone objects: if <code>FALSE</code> (default),
the user-defined ploidy will stay constant. if <code>TRUE</code>, the ploidy for
each sample will be determined by the maximum ploidy observed for each
genotype.</p>
</td></tr>
<tr><td><code id="recode_polyploids_+3A_addzero">addzero</code></td>
<td>
<p>add zeroes onto genind or genclone objects with uneven ploidy?
if <code>TRUE</code>, objects with uneven ploidies will have zeroes appended to all
loci to allow conversion to genpop objects. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The genind object has two caveats that make it difficult to work 
with polyploid data sets: 
</p>

<ol>
<li><p> ploidy must be constant throughout the data set 
</p>
</li>
<li><p> missing data is treated as &quot;all-or-none&quot;
</p>
</li></ol>
<p> In an ideal world, polyploid genotypes would be just as unambiguous as 
diploid or haploid genotypes. Unfortunately, the world we live in is far 
from ideal and a genotype of AB in a tetraploid organism could be AAAB, 
AABB, or ABBB. In order to get polyploid data in to <span class="pkg">adegenet</span> or 
<span class="pkg">poppr</span>, we must code all loci to have the same number of allelic 
states as the ploidy or largest observed heterozygote (if ploidy is 
unknown). The way to do this is to insert zeroes to pad the alleles. So, to
import two genotypes of:
</p>

<table>
<tr>
 <td style="text-align: right;">
NA </td><td style="text-align: right;"> 20 </td><td style="text-align: right;"> 23 </td><td style="text-align: right;"> 24</td>
</tr>
<tr>
 <td style="text-align: right;">
20 </td><td style="text-align: right;"> 24 </td><td style="text-align: right;"> 26 </td><td style="text-align: right;"> 43
</td>
</tr>

</table>
 
<p>they should be coded as: 
</p>

<table>
<tr>
 <td style="text-align: right;">
 0 </td><td style="text-align: right;"> 20 </td><td style="text-align: right;"> 23 </td><td style="text-align: right;"> 24</td>
</tr>
<tr>
 <td style="text-align: right;">
20 </td><td style="text-align: right;"> 24 </td><td style="text-align: right;"> 26 </td><td style="text-align: right;"> 43
</td>
</tr>

</table>
 
<p>This zero is treated as an extra allele and is represented in the genind object as so:
</p>

<table>
<tr>
 <td style="text-align: right;">
<strong>0</strong> </td><td style="text-align: right;"> <strong>20</strong> </td><td style="text-align: right;"> <strong>23</strong> </td><td style="text-align: right;"> <strong>24</strong> </td><td style="text-align: right;"> <strong>26</strong> </td><td style="text-align: right;"> <strong>43</strong></td>
</tr>
<tr>
 <td style="text-align: right;">
1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0</td>
</tr>
<tr>
 <td style="text-align: right;">
0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1
</td>
</tr>

</table>

<p>This function remedies this problem by removing the zero column.
The above table would become:
</p>

<table>
<tr>
 <td style="text-align: right;">
<strong>20</strong> </td><td style="text-align: right;"> <strong>23</strong> </td><td style="text-align: right;"> <strong>24</strong> </td><td style="text-align: right;"> <strong>26</strong> </td><td style="text-align: right;"> <strong>43</strong></td>
</tr>
<tr>
 <td style="text-align: right;">
1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0</td>
</tr>
<tr>
 <td style="text-align: right;">
1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1
</td>
</tr>

</table>

<p>With this, the user is able to calculate frequency based statistics on the
data set.
</p>


<h3>Value</h3>

<p>a <code><a href="#topic+genclone-class">genclone</a></code>, <code><a href="adegenet.html#topic+genind-class">genind</a></code>, or
<code><a href="adegenet.html#topic+genpop-class">genpop</a></code> object.
</p>


<h3>Note</h3>

<p>This is an approximation, and a bad one at that. <span class="pkg">Poppr</span> was not
originally intended for polyploids, but with the inclusion of Bruvo's
distance, it only made sense to attempt something beyond single use.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Pinf)
iPinf &lt;- recode_polyploids(Pinf)

# Note that the difference between the number of alleles.
nAll(Pinf)
nAll(iPinf)

## Not run: 
library("ape")

# Removing missing data. 
setPop(Pinf) &lt;- ~Country

# Calculating Rogers' distance. 
rog &lt;- rogers.dist(genind2genpop(Pinf))
irog &lt;- rogers.dist(recode_polyploids(genind2genpop(Pinf)))

# We will now plot neighbor joining trees. Note the decreased distance in the
# original data.
plot(nj(rog), type = "unrooted")
add.scale.bar(lcol = "red", length = 0.02)
plot(nj(irog), type = "unrooted")
add.scale.bar(lcol = "red", length = 0.02)

## End(Not run)
</code></pre>

<hr>
<h2 id='rraf'>Round Robin Allele Frequencies</h2><span id='topic+rraf'></span>

<h3>Description</h3>

<p>This function utilizes <code><a href="#topic+rrmlg">rrmlg</a></code> to calculate multilocus genotypes 
and then subsets each locus by the resulting MLGs to calculate the 
round-robin allele frequencies used for pgen and psex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rraf(gid, pop = NULL, res = "list", by_pop = FALSE, correction = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rraf_+3A_gid">gid</code></td>
<td>
<p>a genind or genclone object</p>
</td></tr>
<tr><td><code id="rraf_+3A_pop">pop</code></td>
<td>
<p>either a formula to set the population factor from the 
<code><a href="survival.html#topic+strata">strata</a></code> slot or a vector specifying the population factor for 
each sample. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="rraf_+3A_res">res</code></td>
<td>
<p>either &quot;list&quot; (default), &quot;vector&quot;, or &quot;data.frame&quot;.</p>
</td></tr>
<tr><td><code id="rraf_+3A_by_pop">by_pop</code></td>
<td>
<p>When this is <code>TRUE</code>, the calculation will be done by 
population. Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="rraf_+3A_correction">correction</code></td>
<td>
<p>a logical indicating whether or not zero-valued allele 
frequencies should be corrected using the methods outlined in 
<a href="#topic+rare_allele_correction">correcting rare alleles</a>. 
(Default: <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="rraf_+3A_...">...</code></td>
<td>
<p>options from <a href="#topic+rare_allele_correction">correcting rare
alleles</a>. The default is to correct allele frequencies to 1/n</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculating allele frequencies for clonal populations is a difficult
task. Frequencies calculated on non-clone-corrected data suffer from bias 
due to non-independent samples. On the other hand, frequencies calculated 
on clone-corrected data artificially increases the significance of rare 
alleles. The method of round-robin allele frequencies as presented in Parks
and Werth (1993) provides a method of calculating allele frequencies in a 
way that minimizes both of these effects. 
</p>


<h4>Rare Alleles</h4>

<p>Allele frequencies at a given locus are
calculated based on samples that are <strong>clone corrected without that
locus</strong>. When this happens, rare alleles have a high likelihood of dropping
out, giving them a frequency of &quot;0&quot;. For some analyses, this is a perfectly
fine outcome, but for analyses such as <code><a href="#topic+pgen">pgen</a></code> and
<code><a href="#topic+psex">psex</a></code>, this could result in undefined values. Setting 
<code>correction = TRUE</code> will allow you to control how these zero-valued 
allele frequencies are corrected. For details, please see the documentation
on <a href="#topic+rare_allele_correction">correcting rare alleles</a> and examples.</p>



<h3>Value</h3>

<p>a vector or list of allele frequencies
</p>


<h3>Note</h3>

<p>When <code>by_pop = TRUE</code>, the output will be a matrix of allele 
frequencies. Additionally, when the argument <code>pop</code> is not <code>NULL</code>,
<code>by_pop</code> is automatically <code>TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar, Jonah Brooks, Stacy A. Krueger-Hadfield, Erik Sotka
</p>


<h3>References</h3>

<p>Arnaud-Haond, S., Duarte, C. M., Alberto, F., &amp; Serrão, E. A. 2007.
Standardizing methods to address clonality in population studies.
<em>Molecular Ecology</em>, 16(24), 5115-5139.
</p>
<p>Parks, J. C., &amp; Werth, C. R. 1993. A study of spatial features of clones in a
population of bracken fern, <em>Pteridium aquilinum</em> (Dennstaedtiaceae).
<em>American Journal of Botany</em>, 537-544.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rrmlg">rrmlg</a></code>, <code><a href="#topic+pgen">pgen</a></code>, <code><a href="#topic+psex">psex</a></code>,
<code><a href="#topic+rare_allele_correction">rare_allele_correction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Pram)

# Round robin allele frequencies, correcting zero-valued frequencies to 1/nInd(Pram)
rraf(Pram)


## Not run: 

## Round robin allele frequencies will be different than observed

# Compare to without round robin:
PrLoc &lt;- seploc(Pram, res = "mat") # get locus by matrix
lapply(PrLoc, colMeans, na.rm = TRUE)

# Without round robin, clone corrected:
Pcc    &lt;- clonecorrect(Pram, strata = NA) # indiscriminantly clone correct
PccLoc &lt;- seploc(Pcc, res = "mat")
lapply(PccLoc, colMeans, na.rm = TRUE)

## Different methods of obtaining round robin allele frequencies

# Get vector output.
rraf(Pram, res = "vector")

# Getting the output as a data frame allows us to use ggplot2 to visualize
(Prdf &lt;- rraf(Pram, res = "data.frame"))
library("ggplot2")
ggplot(Prdf, aes(y = allele, x = frequency)) +
  geom_point() +
  facet_grid(locus ~ ., scale = "free_y", space = "free")

## Round Robin allele frequencies by population (matrix only)

# By default, allele frequencies will be corrected by 1/n per population
(Prbp &lt;- rraf(Pram, by_pop = TRUE))

# This might be problematic because populations like PistolRSF_OR has a 
# population size of four.

# By using the 'e' argument to rare_allele_correction, this can be set to a
# more reasonable value.
(Prbp &lt;- rraf(Pram, by_pop = TRUE, e = 1/nInd(Pram)))




## End(Not run)
</code></pre>

<hr>
<h2 id='rrmlg'>Round Robin Multilocus Genotypes</h2><span id='topic+rrmlg'></span>

<h3>Description</h3>

<p>This function will mask each locus one by one and then calculate multilocus
genotypes from the remaining loci in a round-robin fashion. This is used for
calculating the round robin allele frequencies for pgen and psex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rrmlg(gid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rrmlg_+3A_gid">gid</code></td>
<td>
<p>a genind, genclone, or loci object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of multilocus genotype assignments by masked locus. There 
will be n rows and m columns where n = number of samples and m = number of
loci.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar, Jonah Brooks, Stacy A. Krueger-Hadfield, Erik Sotka
</p>


<h3>References</h3>

<p>Arnaud-Haond, S., Duarte, C. M., Alberto, F., &amp; Serrão, E. A. 2007.
Standardizing methods to address clonality in population studies.
<em>Molecular Ecology</em>, 16(24), 5115-5139.
</p>
<p>Parks, J. C., &amp; Werth, C. R. 1993. A study of spatial features of clones in a
population of bracken fern, <em>Pteridium aquilinum</em> (Dennstaedtiaceae).
<em>American Journal of Botany</em>, 537-544.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rraf">rraf</a></code>, <code><a href="#topic+pgen">pgen</a></code>, <code><a href="#topic+psex">psex</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Find out the round-robin multilocus genotype assignments for P. ramorum
data(Pram)
pmlg_rr &lt;- rrmlg(Pram)
head(pmlg_rr)
## Not run: 
# You can find out how many unique genotypes are found without each locus:

colSums(!apply(pmlg_rr, 2, duplicated))

## End(Not run)
</code></pre>

<hr>
<h2 id='samp.ia'>Calculate random samples of the index of association for genlight objects.</h2><span id='topic+samp.ia'></span>

<h3>Description</h3>

<p>Genlight objects can contain millions of loci. Since it does not make much 
sense to calculate the index of association over that many loci, this
function will randomly sample sites to calculate the index of association.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samp.ia(x, n.snp = 100L, reps = 100L, threads = 1L, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samp.ia_+3A_x">x</code></td>
<td>
<p>a [genlight][genlight-class] or [snpclone][snpclone-class] object.</p>
</td></tr>
<tr><td><code id="samp.ia_+3A_n.snp">n.snp</code></td>
<td>
<p>the number of snps to be used to calculate standardized index
of association.</p>
</td></tr>
<tr><td><code id="samp.ia_+3A_reps">reps</code></td>
<td>
<p>the number of times to perform the calculation.</p>
</td></tr>
<tr><td><code id="samp.ia_+3A_threads">threads</code></td>
<td>
<p>The maximum number of parallel threads to be used within this 
function. A value of 0 (default) will attempt to use as many threads as
there are available cores/CPUs. In most cases this is ideal. A value of 1
will force the function to run serially, which may increase stability on
some systems. Other values may be specified, but should be used with
caution.</p>
</td></tr>
<tr><td><code id="samp.ia_+3A_quiet">quiet</code></td>
<td>
<p>if 'FALSE', a progress bar will be printed to the screen.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The index of association is a summary of linkage disequilibrium 
among many loci. More information on the index of association can be found 
associated with the funciton [ia()]. A value near or at zero
indicator of linkage equilibrium, whereas values significantly greater than
zero indicate linkage disequilibrium. However, if the observed variance in 
distance among individuals is less than the expected, mildly negative 
values may be observed (as the range of this index is negative one to one).
This function will call the function [bitwise.ia()] for
'reps' times to calculate the index of association over 'n.snp'
loci. The standardized index of association ('rbarD') will be calculated
'reps' times. These esitmates of linkage disequilibrium from random
genomic fractions can then be summarized (e.g., using a histogram) as an
estimate of genome-wide linkage disequilibrium.
</p>
<p>This function currently only works for objects of class genlight or snpclone
that are of a single ploidy level and that ploidy is either haploid or
diploid.
</p>


<h3>Value</h3>

<p>Index of association representing the samples in this genlight
object.
</p>


<h3>Note</h3>

<p>this will calculate the standardized index of association from Agapow
2001. See [ia()] for details.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar, Jonah C. Brooks
</p>


<h3>See Also</h3>

<p>[genlight][genlight-class],
[snpclone][snpclone-class],
[win.ia()],
[ia()],
[bitwise.dist()]
[bitwise.ia()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'># with structured snps assuming 1e4 positions
set.seed(999)
x &lt;- glSim(n.ind = 10, n.snp.nonstruc = 5e2, 
           n.snp.struc = 5e2, ploidy = 2,
           parallel = FALSE)
position(x) &lt;- sort(sample(1e4, 1e3))
res &lt;- samp.ia(x)
hist(res, breaks = "fd")

# with unstructured snps assuming 1e4 positions
set.seed(999)
x &lt;- glSim(n.ind = 10, n.snp.nonstruc = 1e3, ploidy = 2)
position(x) &lt;- sort(sample(1e4, 1e3))
res &lt;- samp.ia(x)
hist(res, breaks = "fd")
</code></pre>

<hr>
<h2 id='shufflepop'>Shuffle individuals in a <code><a href="#topic+genclone-class">genclone</a></code> or
<code><a href="adegenet.html#topic+genind-class">genind</a></code> object independently over each locus.</h2><span id='topic+shufflepop'></span>

<h3>Description</h3>

<p>Shuffle individuals in a <code><a href="#topic+genclone-class">genclone</a></code> or
<code><a href="adegenet.html#topic+genind-class">genind</a></code> object independently over each locus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shufflepop(pop, method = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shufflepop_+3A_pop">pop</code></td>
<td>
<p>a <code><a href="#topic+genclone-class">genclone</a></code> or <code><a href="adegenet.html#topic+genind-class">genind</a></code>
object</p>
</td></tr>
<tr><td><code id="shufflepop_+3A_method">method</code></td>
<td>
<p>an integer between 1 and 4. See details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will shuffle each locus in the data set independently 
of one another, rendering them essentially unlinked. The following methods 
are available to shuffle your data: </p>
 <ol>
<li> <p><strong>Permute 
Alleles</strong> This will redistribute all alleles in the sample throughout the 
locus. Missing data is fixed in place. This maintains allelic structure, 
but heterozygosity is variable. </p>
</li>
<li> <p><strong>Parametric Bootstrap</strong> This 
will redistribute available alleles within the locus based on their allelic
frequencies. This means that both the allelic state and heterozygosity will
vary. The resulting data set will not have missing data. </p>
</li>
<li> 
<p><strong>Non-Parametric Bootstrap</strong> This will shuffle the allelic state for 
each individual. Missing data is fixed in place. </p>
</li>
<li> <p><strong>Multilocus 
Style Permutation</strong> This will shuffle the genotypes at each locus, 
maintaining the heterozygosity and allelic structure. </p>
</li></ol>



<h3>Value</h3>

<p>a <code><a href="#topic+genclone-class">genclone</a></code> or <code><a href="adegenet.html#topic+genind-class">genind</a></code> object
shuffled by a specified method
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>References</h3>

<p>Paul-Michael Agapow and Austin Burt. 2001. Indices of multilocus
linkage disequilibrium. <em>Molecular Ecology Notes</em>, 1(1-2):101-102
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the microbov dataset
data(microbov)
# Let's look at a single population for now. Howsabout Zebu
Zebu &lt;- popsub(microbov, "Zebu")
summary(Zebu)

# Take note of the Number of alleles per population and the Observed
# heterozygosity as we go through each method.

# Permute Alleles: maintain allelic state; heterozygosity varies.
summary(shufflepop(Zebu, method=1))
## Not run: 
# Parametric Bootstrap: do not maintain allelic state or heterozygosity
summary(shufflepop(Zebu, method=2))

# Non-Parametric Bootstrap: do not maintain allelic state or heterozygosity.
summary(shufflepop(Zebu, method=3))

# Multilocus Style: maintain allelic state and heterozygosity.
summary(shufflepop(Zebu, method=4))

## End(Not run)
</code></pre>

<hr>
<h2 id='test_replen'>Test repeat length consistency.</h2><span id='topic+test_replen'></span>

<h3>Description</h3>

<p>This function will test for consistency in the sense that all alleles are 
able to be represented as discrete units after division and rounding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_replen(gid, replen)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_replen_+3A_gid">gid</code></td>
<td>
<p>a <code><a href="adegenet.html#topic+genind">genind</a></code> or <code><a href="#topic+genclone">genclone</a></code> object</p>
</td></tr>
<tr><td><code id="test_replen_+3A_replen">replen</code></td>
<td>
<p>a numeric vector of repeat motif lengths.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is modified from the version used in 
<a href="https://doi.org/10.5281/zenodo.13007">doi:10.5281/zenodo.13007</a>.
</p>


<h3>Value</h3>

<p>a logical vector indicating whether or not the repeat motif length is
consistent.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>References</h3>

<p>Zhian N. Kamvar, Meg M. Larsen, Alan M. Kanaskie, Everett M. 
Hansen, &amp; Niklaus J. Grünwald. Sudden_Oak_Death_in_Oregon_Forests: Spatial
and temporal population dynamics of the sudden oak death epidemic in Oregon
Forests. ZENODO, <a href="https://doi.org/10.5281/zenodo.13007">doi:10.5281/zenodo.13007</a>, 2014.
</p>
<p>Kamvar, Z. N., Larsen, M. M., Kanaskie, A. M., Hansen, E. M., &amp; Grünwald,
N. J. (2015). Spatial and temporal analysis of populations of the sudden
oak death pathogen in Oregon forests. Phytopathology 105:982-989.
doi: <a href="https://doi.org/10.1094/PHYTO-12-14-0350-FI">doi:10.1094/PHYTO-12-14-0350-FI</a>
</p>
<p>Ruzica Bruvo, Nicolaas K. Michiels, Thomas G. D'Souza, and Hinrich 
Schulenburg. A simple method for the calculation of microsatellite genotype
distances irrespective of ploidy level. Molecular Ecology, 13(7):2101-2106,
2004.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fix_replen">fix_replen</a></code> <code><a href="#topic+bruvo.dist">bruvo.dist</a></code>
<code><a href="#topic+bruvo.msn">bruvo.msn</a></code> <code><a href="#topic+bruvo.boot">bruvo.boot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Pram)
(Pram_replen &lt;- setNames(c(3, 2, 4, 4, 4), locNames(Pram)))
test_replen(Pram, Pram_replen)
</code></pre>

<hr>
<h2 id='unique+2CMLG-method'>Unique and Duplicated implementations for MLG objects</h2><span id='topic+unique+2CMLG-method'></span><span id='topic+unique+2CMLG+2CANY-method'></span><span id='topic+duplicated+2CMLG-method'></span>

<h3>Description</h3>

<p>internal use
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MLG'
unique(x, incomparables = FALSE, ...)

## S4 method for signature 'MLG'
duplicated(x, incomparables = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unique+2B2CMLG-method_+3A_incomparables">incomparables</code></td>
<td>
<p>vector of values that cannot be compared</p>
</td></tr>
<tr><td><code id="unique+2B2CMLG-method_+3A_...">...</code></td>
<td>
<p>options passed on to the base function <a href="base.html#topic+unique">unique</a> or <a href="base.html#topic+duplicated">duplicated</a>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+visible">visible</a></code> <code><a href="#topic+MLG-class">MLG</a></code> 
<code><a href="#topic+genclone">genclone</a></code> <code><a href="#topic+snpclone">snpclone</a></code> 
<code><a href="#topic+initialize+2CMLG-method">initialize,MLG-method</a></code> <code><a href="#topic+levels+2CMLG-method">levels,MLG-method</a></code>
</p>

<hr>
<h2 id='upgma'>UPGMA</h2><span id='topic+upgma'></span>

<h3>Description</h3>

<p>UPGMA clustering. Just a wrapper function around <code><a href="stats.html#topic+hclust">hclust</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upgma(d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upgma_+3A_d">d</code></td>
<td>
<p>A distance matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A phylogenetic tree of class <code>phylo</code>.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="ape.html#topic+as.phylo">as.phylo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ape)
data(woodmouse)
dm &lt;- dist.dna(woodmouse)
tree &lt;- upgma(dm)
plot(tree)

</code></pre>

<hr>
<h2 id='visible'>Accessors for the MLG object</h2><span id='topic+visible'></span><span id='topic+visible+2CMLG-method'></span><span id='topic+visible+3C-'></span><span id='topic+visible+3C-+2CMLG-method'></span><span id='topic+MLG2df'></span><span id='topic+MLG2df+2CMLG-method'></span><span id='topic+distname'></span><span id='topic+distname+2CMLG-method'></span><span id='topic+distenv'></span><span id='topic+distenv+2CMLG-method'></span><span id='topic+distname+3C-'></span><span id='topic+distname+3C-+2CMLG-method'></span><span id='topic+distenv+3C-'></span><span id='topic+distenv+3C-+2CMLG-method'></span><span id='topic+distargs'></span><span id='topic+distargs+2CMLG-method'></span><span id='topic+distargs+3C-'></span><span id='topic+distargs+3C-+2CMLG-method'></span><span id='topic+distalgo'></span><span id='topic+distalgo+2CMLG-method'></span><span id='topic+distalgo+3C-'></span><span id='topic+distalgo+3C-+2CMLG-method'></span><span id='topic+cutoff'></span><span id='topic+cutoff+2CMLG-method'></span><span id='topic+cutoff+3C-'></span><span id='topic+cutoff+3C-+2CMLG-method'></span>

<h3>Description</h3>

<p><strong>This documentation is for developers of poppr.</strong> The accessors here 
are preferred over accessing the elements via the @ symbol. Please use these
in your code when accessing MLG objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visible(x)

visible(x) &lt;- value

MLG2df(x)

distname(x)

distenv(x)

distname(x) &lt;- value

distenv(x) &lt;- value

distargs(x)

distargs(x) &lt;- value

distalgo(x)

distalgo(x) &lt;- value

cutoff(x)

cutoff(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visible_+3A_x">x</code></td>
<td>
<p>an MLG object</p>
</td></tr>
<tr><td><code id="visible_+3A_value">value</code></td>
<td>
<p>see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These accessors are intended for internal use only. They only affect
MLG objects, not genind objects. Only visible and MLG2df are general for 
all forms of MLG. The distargs and cutoff are specific for use in 
mlg.filter or any function that offers filtering as an option. The argument
&quot;value&quot; will always take the type defined in the <code><a href="#topic+MLG-class">MLG</a></code> 
class.
</p>


<h3>Value</h3>

<p>see details
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MLG">MLG</a></code> <code><a href="#topic+genclone-class">genclone</a></code> 
<code><a href="adegenet.html#topic+genlight-class">genlight</a></code> <code><a href="#topic+initialize+2CMLG-method">initialize,MLG-method</a></code>
<code><a href="#topic+levels+2CMLG-method">levels,MLG-method</a></code> <code><a href="#topic+unique+2CMLG-method">unique,MLG-method</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# These examples will simply show you what you can do with these
set.seed(5000)
(x &lt;- sample(10, 20, replace = TRUE))
(m &lt;- new("MLG", x))

# Visibility ------------------------------
visible(m) # original
visible(m) &lt;- "contracted"
m          # shows contracted MLGS

# Conversion to data frame ----------------
MLG2df(m)  # Grab the internal data frame

# Distance function handling --------------
distname(m) # nei.dist
distargs(m) # list()
distalgo(m) # farthest
cutoff(m)

distname(m) &lt;- substitute("diss.dist")
distargs(m) &lt;- list(percent = TRUE)
distalgo(m) &lt;- "average"
cutoff(m)["contracted"] &lt;- 0.2


## End(Not run)
</code></pre>

<hr>
<h2 id='win.ia'>Calculate windows of the index of association for genlight objects.</h2><span id='topic+win.ia'></span>

<h3>Description</h3>

<p>Genlight objects can contain millions of loci. Since it does not make much
sense to calculate the index of association over that many loci, this
function will scan windows across the loci positions and calculate the index
of association.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>win.ia(
  x,
  window = 100L,
  min.snps = 3L,
  threads = 1L,
  quiet = FALSE,
  name_window = TRUE,
  chromosome_buffer = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="win.ia_+3A_x">x</code></td>
<td>
<p>a <a href="adegenet.html#topic+genlight-class">genlight</a> or <a href="#topic+snpclone-class">snpclone</a> object.</p>
</td></tr>
<tr><td><code id="win.ia_+3A_window">window</code></td>
<td>
<p>an integer specifying the size of the window.</p>
</td></tr>
<tr><td><code id="win.ia_+3A_min.snps">min.snps</code></td>
<td>
<p>an integer specifying the minimum number of snps allowed per
window. If a window does not meet this criteria, the value will return as
<code>NA</code>.</p>
</td></tr>
<tr><td><code id="win.ia_+3A_threads">threads</code></td>
<td>
<p>The maximum number of parallel threads to be used within this
function. Defaults to 1 thread, in which the function will run serially. A
value of 0 will attempt to use as many threads as there are available
cores/CPUs. In most cases this is ideal for speed. Note: this option is
passed to <code><a href="#topic+bitwise.ia">bitwise.ia()</a></code> and does not parallelize the windowization process.</p>
</td></tr>
<tr><td><code id="win.ia_+3A_quiet">quiet</code></td>
<td>
<p>if <code>FALSE</code> (default), a progress bar will be printed to the screen.</p>
</td></tr>
<tr><td><code id="win.ia_+3A_name_window">name_window</code></td>
<td>
<p>if <code>TRUE</code> (default), the result vector will be named with
the terminal position of the window. In the case where several chromosomes
are represented, the position will be appended using a period/full stop.</p>
</td></tr>
<tr><td><code id="win.ia_+3A_chromosome_buffer">chromosome_buffer</code></td>
<td>
<p><em>DEPRECATED</em> if <code>TRUE</code> (default), buffers will be placed
between adjacent chromosomal positions to prevent windows from spanning two
chromosomes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A value of the standardized index of association for all windows in
each chromosome.
</p>


<h3>Note</h3>

<p>this will calculate the standardized index of association from Agapow
and Burt, 2001. See <code><a href="#topic+ia">ia()</a></code> for details.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar, Jonah C. Brooks
</p>


<h3>See Also</h3>

<p><a href="adegenet.html#topic+genlight-class">genlight</a>, <a href="#topic+snpclone-class">snpclone</a>, <code><a href="#topic+ia">ia()</a></code>, <code><a href="#topic+samp.ia">samp.ia()</a></code>, <code><a href="#topic+bitwise.dist">bitwise.dist()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# with structured snps assuming 1e4 positions
set.seed(999)
x &lt;- glSim(n.ind = 10, n.snp.nonstruc = 5e2, n.snp.struc = 5e2, ploidy = 2)
position(x) &lt;- sort(sample(1e4, 1e3))
res &lt;- win.ia(x, window = 300L) # Calculate for windows of size 300
plot(res, type = "l")

## Not run: 

# unstructured snps
set.seed(999)
x &lt;- glSim(n.ind = 10, n.snp.nonstruc = 1e3, ploidy = 2)
position(x) &lt;- sort(sample(1e4, 1e3))
res &lt;- win.ia(x, window = 300L) # Calculate for windows of size 300
plot(res, type = "l")

# Accounting for chromosome coordinates
set.seed(999)
x &lt;- glSim(n.ind = 10, n.snp.nonstruc = 5e2, n.snp.struc = 5e2, ploidy = 2)
position(x) &lt;- as.vector(vapply(1:10, function(x) sort(sample(1e3, 100)), integer(100)))
chromosome(x) &lt;- rep(1:10, each = 100)
res &lt;- win.ia(x, window = 100L)
plot(res, type = "l")

# Converting chromosomal coordinates to tidy data
library("dplyr")
library("tidyr")
res_tidy &lt;- res %&gt;% 
  tibble(rd = ., chromosome = names(.)) %&gt;% # create two column data frame
  separate(chromosome, into = c("chromosome", "position")) %&gt;% # get the position info
  mutate(position = as.integer(position)) %&gt;% # force position as integers
  mutate(chromosome = factor(chromosome, unique(chromosome))) # force order chromosomes
res_tidy

# Plotting with ggplot2
library("ggplot2")
ggplot(res_tidy, aes(x = position, y = rd, color = chromosome)) +
  geom_line() +
  facet_wrap(~chromosome, nrow = 1) +
  ylab(expression(bar(r)[d])) +
  xlab("terminal position of sliding window") +
  labs(caption = "window size: 100bp") + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
  theme(legend.position = "top")


## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
