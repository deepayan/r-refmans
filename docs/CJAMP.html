<!DOCTYPE html><html><head><title>Help for package CJAMP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CJAMP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cjamp'><p>C-JAMP: Copula-based joint analysis of multiple phenotypes.</p></a></li>
<li><a href='#compute_expl_var'><p>Phenotypic variance explained by genetic variants.</p></a></li>
<li><a href='#compute_MAF'><p>Compute minor allele frequency of genetic variants.</p></a></li>
<li><a href='#generate_clayton_copula'><p>Generate data from the Clayton copula.</p></a></li>
<li><a href='#generate_genodata'><p>Functions to generate genetic data.</p></a></li>
<li><a href='#generate_phenodata'><p>Functions to generate phenotype data.</p></a></li>
<li><a href='#get_estimates_naive'><p>Naive estimates of the copula and marginal parameters.</p></a></li>
<li><a href='#lrt'><p>Compute likelihood ratio tests.</p></a></li>
<li><a href='#minusloglik'><p>Minus log-likelihood of copula models.</p></a></li>
<li><a href='#summary.cjamp'><p>Summary function.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Copula-Based Joint Analysis of Multiple Phenotypes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>We provide a computationally efficient and robust implementation of the recently proposed C-JAMP (Copula-based Joint Analysis of Multiple Phenotypes) method (Konigorski et al., 2019, submitted). C-JAMP allows estimating and testing the association of one or multiple predictors on multiple outcomes in a joint model, and is implemented here with a focus on large-scale genome-wide association studies with two phenotypes. The use of copula functions allows modeling a wide range of multivariate dependencies between the phenotypes, and previous results are supporting that C-JAMP can increase the power of association studies to identify associated genetic variants in comparison to existing methods (Konigorski, Yilmaz, Pischon, 2016, &lt;<a href="https://doi.org/10.1186%2Fs12919-016-0045-6">doi:10.1186/s12919-016-0045-6</a>&gt;; Konigorski, Yilmaz, Bull, 2014, &lt;<a href="https://doi.org/10.1186%2F1753-6561-8-S1-S72">doi:10.1186/1753-6561-8-S1-S72</a>&gt;). In addition to the C-JAMP functions, functions are available to generate genetic and phenotypic data, to compute the minor allele frequency (MAF) of genetic markers, and to estimate the phenotypic variance explained by genetic markers.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, optimx</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-03-20 21:13:35 UTC; Stefan.Konigorski</td>
</tr>
<tr>
<td>Author:</td>
<td>Stefan Konigorski [aut, cre],
  Yildiz E. Yilmaz [ctb, ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stefan Konigorski &lt;stefan.konigorski@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-03-20 22:23:33 UTC</td>
</tr>
</table>
<hr>
<h2 id='cjamp'>C-JAMP: Copula-based joint analysis of multiple phenotypes.</h2><span id='topic+cjamp'></span><span id='topic+cjamp_loop'></span>

<h3>Description</h3>

<p>Functions to perform C-JAMP: <code><a href="#topic+cjamp">cjamp</a></code> fits a joint model of two
phenotypes conditional on one or multiple predictors; <code><a href="#topic+cjamp_loop">cjamp_loop</a></code>
uses <code><a href="#topic+cjamp">cjamp</a></code> to fit the same copula model separately for a list of
multiple predictors, e.g. for a genetic association study.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cjamp(copula = "Clayton", Y1 = NULL, Y2 = NULL,
  predictors_Y1 = NULL, predictors_Y2 = NULL, scale_var = FALSE,
  optim_method = "BFGS", trace = 0, kkt2tol = 1e-16, SE_est = TRUE,
  pval_est = TRUE, n_iter_max = 10)

cjamp_loop(copula = "Clayton", Y1 = NULL, Y2 = NULL,
  predictors = NULL, covariates_Y1 = NULL, covariates_Y2 = NULL,
  scale_var = FALSE, optim_method = "BFGS", trace = 0,
  kkt2tol = 1e-16, SE_est = TRUE, pval_est = TRUE, n_iter_max = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cjamp_+3A_copula">copula</code></td>
<td>
<p>String indicating whether the joint model will be computed
under the Clayton (<code>"Clayton"</code>) or 2-parameter copula
(<code>"2param"</code>) model.</p>
</td></tr>
<tr><td><code id="cjamp_+3A_y1">Y1</code></td>
<td>
<p>Numeric vector containing the first phenotype.</p>
</td></tr>
<tr><td><code id="cjamp_+3A_y2">Y2</code></td>
<td>
<p>Numeric vector containing the second phenotype.</p>
</td></tr>
<tr><td><code id="cjamp_+3A_predictors_y1">predictors_Y1</code></td>
<td>
<p>Dataframe containing the predictors of <code>Y1</code>
in columns (for the <code><a href="#topic+cjamp">cjamp</a></code> function).</p>
</td></tr>
<tr><td><code id="cjamp_+3A_predictors_y2">predictors_Y2</code></td>
<td>
<p>Dataframe containing the predictors of <code>Y2</code>
in columns (for the <code><a href="#topic+cjamp">cjamp</a></code> function).</p>
</td></tr>
<tr><td><code id="cjamp_+3A_scale_var">scale_var</code></td>
<td>
<p>Logical. Indicating whether all predictors will be centered and
scaled before the analysis or not (default: FALSE).</p>
</td></tr>
<tr><td><code id="cjamp_+3A_optim_method">optim_method</code></td>
<td>
<p>String passed to the <code><a href="optimx.html#topic+optimx">optimx</a></code>
function. It specifies the optimization method in the
<code><a href="optimx.html#topic+optimx">optimx</a></code> function that is used for
maximizing the log-likelihood function. Recommended is the
<code>"BFGS"</code> optimization method (default). For further
methods, see the description of the
<code><a href="optimx.html#topic+optimx">optimx</a></code> function.</p>
</td></tr>
<tr><td><code id="cjamp_+3A_trace">trace</code></td>
<td>
<p>Integer passed to the <code><a href="optimx.html#topic+optimx">optimx</a></code>
function. It specifies the tracing information on the progress
of the optimization. The value <code>2</code> gives full tracing,
default value <code>0</code> blocks all details. See also the <code><a href="optimx.html#topic+optimx">optimx</a></code>
documentation.</p>
</td></tr>
<tr><td><code id="cjamp_+3A_kkt2tol">kkt2tol</code></td>
<td>
<p>Numeric. Passed to the <code><a href="optimx.html#topic+optimx">optimx</a></code>
function, default value is 1E-16. It specifies the tolerance for
the eigenvalue ratio in the Karush-Kuhn-Tucker (KKT) test for a positive definite
Hessian matrix. See also the <code><a href="optimx.html#topic+optimx">optimx</a></code>
documentation.</p>
</td></tr>
<tr><td><code id="cjamp_+3A_se_est">SE_est</code></td>
<td>
<p>Logical indicator whether standard error estimates are
computed for the parameters using the inverse of the observed
information matrix (<code>TRUE</code>, default), or whether standard
error estimates are not computed (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="cjamp_+3A_pval_est">pval_est</code></td>
<td>
<p>Logical indicator whether p-values are computed from
hypothesis tests of the absence of effects of each predictor
on each phenotype in the marginal models (<code>TRUE</code>, default),
or whether p-values are not computed (<code>FALSE</code>). P-values
are obtained from large sample Wald-type tests based on the
maximum likelihood parameter estimates and the standard error
estimates.</p>
</td></tr>
<tr><td><code id="cjamp_+3A_n_iter_max">n_iter_max</code></td>
<td>
<p>Integer indicating the maximum number of optimization attempts
of the log-likelihood function with different starting values,
if the optimization doesn't converge (default: 10).</p>
</td></tr>
<tr><td><code id="cjamp_+3A_predictors">predictors</code></td>
<td>
<p>Dataframe containing the predictors of <code>Y1</code>
and <code>Y2</code> in columns for which estimates are returned
(for the <code><a href="#topic+cjamp_loop">cjamp_loop</a></code> function).</p>
</td></tr>
<tr><td><code id="cjamp_+3A_covariates_y1">covariates_Y1</code></td>
<td>
<p>Dataframe containing the covariates of <code>Y1</code>
in columns for which estimates are not returned
(for the <code><a href="#topic+cjamp_loop">cjamp_loop</a></code> function).</p>
</td></tr>
<tr><td><code id="cjamp_+3A_covariates_y2">covariates_Y2</code></td>
<td>
<p>Dataframe containing the covariates of <code>Y2</code>
in columns for which estimates are not returned
(for the <code><a href="#topic+cjamp_loop">cjamp_loop</a></code> function).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both functions <code><a href="#topic+cjamp">cjamp</a></code> and <code><a href="#topic+cjamp_loop">cjamp_loop</a></code> fit a joint copula model
of two phenotypes using the Clayton copula or 2-parameter copula, conditional on none
or multiple predictors and covariates in the marginal models. The <code><a href="optimx.html#topic+optimx">optimx</a></code>
function of the <code>optimx</code> package is used to maximize the log-likelihood (i.e. to minimize
the minus log-likelihood function <code><a href="#topic+minusloglik">minusloglik</a></code>) to obtain
maximum likelihood coefficient estimates of all parameters.
For this, the BFGS optimization method is recommended. Standard error estimates
of the coefficient estimates can be obtained by using
the observed inverse information matrix. P-values from hypothesis tests of
the absence of effects of each predictor on each phenotype in the marginal
models can be obtained from large-sample Wald-type tests (see the vignette for details).
</p>
<p>It should be noted that <code><a href="#topic+cjamp">cjamp</a></code>, <code><a href="#topic+cjamp_loop">cjamp_loop</a></code> and
<code><a href="#topic+minusloglik">minusloglik</a></code>) assume quantitative predictors and use an
additive model, i.e. for categorical predictors with more than 2 levels,
dummy variables have to be created beforehand. Accordingly, if single
nucleotide variants (SNVs) are included as predictors, the computation is
based on an additive genetic model if SNVs are provided as 0-1-2 genotypes
and on a dominant model if SNVs are provided as 0-1 genotypes.
</p>
<p>The <code><a href="#topic+cjamp">cjamp</a></code> function returns point estimates of all parameters,
standard error estimates and p-values for all marginal parameters (i.e. all parameters
for <code>predictors_Y1</code>, <code>predictors_Y1</code>), the minus
log-likelihood value as well as information about the convergence. The
<code><a href="#topic+cjamp_loop">cjamp_loop</a></code> function only returns point estimates, standard error
estimates, and p-values for the specified predictors <code>predictors</code> and not
the covariates <code>covariates_Y1</code> and <code>covariates_Y2</code>, in addition
to the minus log-likelihood value as well as convergence information.
</p>
<p>It is recommended that all variables are centered and scaled before the analysis,
which can be done through the <code>scale_var</code> parameter. Otherwise, if the scales
of the variables differ, it can lead to convergence problems of the optimization.
</p>


<h3>Value</h3>

<p>An object of class <code>cjamp</code>, for which the summary function
<code><a href="#topic+summary.cjamp">summary.cjamp</a></code> is implemented. The output is a list
containing estimates of the copula parameters, marginal parameters, Kendall's
tau (as well as the upper and lower tail dependence <code class="reqn">\lambda_l,
        \lambda_u</code> if the 2-parameter copula model is fitted), the standard
error estimates of all parameters, p-values of hypothesis tests
of the marginal parameters (i.e. of the absence of predictor effects on the
phenotypes), the convergence code of the log-likelihood maximization
(from the <code><a href="optimx.html#topic+optimx">optimx</a></code>
function, where 0 indicates successful convergence), the KKT
conditions 1 and 2 of the convergence, and the maximum log-likelihood value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data generation
set.seed(10)
genodata &lt;- generate_genodata(n_SNV = 20, n_ind = 100)
phenodata &lt;- generate_phenodata_2_copula(genodata = genodata$SNV1,
                                         MAF_cutoff = 1, prop_causal = 1,
                                         tau = 0.2, b1 = 0.3, b2 = 0.3)
predictors &lt;- data.frame(X1 = phenodata$X1, X2 = phenodata$X2,
                         genodata[, 1:3])

## Not run. When executing, the following takes about 2 minutes running time.
## Example 1: Analysis of multiple SNVs as predictors in one model
#cjamp(copula = "Clayton", Y1 = phenodata$Y1, Y2 = phenodata$Y2,
#      predictors_Y1 = predictors, predictors_Y2 = predictors,
#      optim_method = "BFGS", trace = 0, kkt2tol = 1E-16, SE_est = TRUE,
#      pval_est = TRUE, n_iter_max = 10)
#cjamp(copula = "2param", Y1 = phenodata$Y1, Y2 = phenodata$Y2,
#      predictors_Y1 = predictors, predictors_Y2 = predictors,
#      optim_method = "BFGS", trace = 0, kkt2tol = 1E-16, SE_est = TRUE,
#      pval_est = TRUE, n_iter_max = 10)
#
## Example 2: Analysis of multiple SNVs in separate models
#covariates &lt;- data.frame(X1 = phenodata$X1, X2 = phenodata$X2)
#predictors &lt;- genodata
#cjamp_loop(copula = "Clayton", Y1 = phenodata$Y1, Y2 = phenodata$Y2,
#           predictors = predictors, covariates_Y1 = covariates,
#           covariates_Y2 = covariates, optim_method = "BFGS", trace = 0,
#           kkt2tol = 1E-16, SE_est = TRUE, pval_est = TRUE,
#           n_iter_max = 10)

</code></pre>

<hr>
<h2 id='compute_expl_var'>Phenotypic variance explained by genetic variants.</h2><span id='topic+compute_expl_var'></span>

<h3>Description</h3>

<p>Function to estimate the percentage of the variance of a phenotype
that can be explained by given single nucleotide variants
(SNVs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_expl_var(genodata = NULL, phenodata = NULL,
  type = "Rsquared_unadj", causal_idx = NULL, effect_causal = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_expl_var_+3A_genodata">genodata</code></td>
<td>
<p>Numeric vector or dataframe containing the genetic variant(s) in
columns. Must be in allelic coding 0, 1, 2.</p>
</td></tr>
<tr><td><code id="compute_expl_var_+3A_phenodata">phenodata</code></td>
<td>
<p>Numeric vector or dataframe of the phenotype.</p>
</td></tr>
<tr><td><code id="compute_expl_var_+3A_type">type</code></td>
<td>
<p>String (vector) specifying the estimation approach(es) that are computed.
Available are the methods <code>"Rsquared_unadj"</code>,
<code>"Rsquared_adj"</code>, <code>"MAF_based"</code>, and
<code>"MAF_based_Y_adjusted"</code>. See below for more details.</p>
</td></tr>
<tr><td><code id="compute_expl_var_+3A_causal_idx">causal_idx</code></td>
<td>
<p>Vector with entries <code>TRUE</code>, <code>FALSE</code> specifying which
SNVs are causal. Has to be supplied for the approaches
<code>MAF_based</code> and <code>MAF_based_Y_adjusted</code>.</p>
</td></tr>
<tr><td><code id="compute_expl_var_+3A_effect_causal">effect_causal</code></td>
<td>
<p>Numeric vector containing the effect sizes of the causal SNVs.
Has to be supplied for the approaches <code>MAF_based</code> and
<code>MAF_based_Y_adjusted</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Four different approaches are available to estimate the percentage of
explained phenotypic variance (Laird &amp; Lange, 2011):
</p>
<p>(1) <code>"Rsquared_unadj"</code>: Unadjusted <code class="reqn">R^2</code> from a linear regression of
the phenotype conditional on all provided SNVs.
</p>
<p>(2) <code>"Rsquared_adj"</code>: Adjusted <code class="reqn">R^2</code> from a linear regression of
the phenotype conditional on all provided SNVs.
</p>
<p>(3) <code>"MAF_based"</code>: Expected explained phenotypic variance computed based on the
MAF and effect size of the provided causal SNVs.
</p>
<p>(4) <code>"MAF_based_Y_adjusted"</code>: Expected explained phenotypic variance computed
based on the MAF and effect size of the causal SNVs, with respect to the empirical
phenotypic variance, which is the broad-sense heritability relative to the
empirical phenotypic variance.
</p>
<p>References:
</p>
<p>Laird NM, Lange C (2011). The fundamentals of modern statistical genetics. New York: Springer.
</p>


<h3>Value</h3>

<p>A list containing the estimated percentage of explained phenotypic variance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(10)
genodata &lt;- generate_genodata(n_SNV = 20, n_ind = 1000)
phenodata &lt;- generate_phenodata_1_simple(genodata = genodata[,1],
                                         type = "quantitative", b = 0)
compute_expl_var(genodata = genodata, phenodata = phenodata$Y,
                 type = c("Rsquared_unadj", "Rsquared_adj"),
                 causal_idx = NULL, effect_causal = NULL)

</code></pre>

<hr>
<h2 id='compute_MAF'>Compute minor allele frequency of genetic variants.</h2><span id='topic+compute_MAF'></span>

<h3>Description</h3>

<p>Function to compute the minor allele frequency (MAF) of
one or more genetic variants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_MAF(genodata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_MAF_+3A_genodata">genodata</code></td>
<td>
<p>Numeric vector or dataframe containing the genetic variants
in columns. Must be in allelic coding 0, 1, 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the minor allele frequencies of the variants.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example of a single variant
set.seed(10)
genodata &lt;- stats::rbinom(2000, 2, 0.3)
compute_MAF(genodata)

# Example of a set of variants
genodata &lt;- generate_genodata()
compute_MAF(genodata)

</code></pre>

<hr>
<h2 id='generate_clayton_copula'>Generate data from the Clayton copula.</h2><span id='topic+generate_clayton_copula'></span>

<h3>Description</h3>

<p>Function to generate two quantitative phenotypes <code class="reqn">Y_1</code>, <code class="reqn">Y_2</code>,
from the bivariate Clayton copula with standard normal
marginal distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_clayton_copula(n = NULL, phi = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_clayton_copula_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="generate_clayton_copula_+3A_phi">phi</code></td>
<td>
<p>Integer specifying the value of the copula parameter <code class="reqn">\phi</code> for
the dependence between the two generated phenotypes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing <code>n</code> observations of <code class="reqn">Y_1</code>, <code class="reqn">Y_2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(10)
dat1a &lt;- generate_clayton_copula(n = 1000, phi = 0.5)
dat1b &lt;- generate_clayton_copula(n = 1000, phi = 2)
dat1c &lt;- generate_clayton_copula(n = 1000, phi = 8)
par(mfrow = c(3, 1))
plot(dat1a$Y1, dat1a$Y2, main="Clayton copula, tau = 0.2")
plot(dat1b$Y1, dat1b$Y2, main="Clayton copula, tau = 0.5")
plot(dat1c$Y1, dat1c$Y2, main="Clayton copula, tau = 0.8")

</code></pre>

<hr>
<h2 id='generate_genodata'>Functions to generate genetic data.</h2><span id='topic+generate_genodata'></span><span id='topic+generate_singleton_data'></span><span id='topic+generate_doubleton_data'></span>

<h3>Description</h3>

<p>Functions to generate genetic data in the form of single
nucleotide variants (SNVs). The function
<code><a href="#topic+generate_singleton_data">generate_singleton_data</a></code> generates singletons (i.e. SNVs with
one observed minor allele); <code><a href="#topic+generate_doubleton_data">generate_doubleton_data</a></code>
generates doubletons (i.e. SNVs with two observed minor alleles), and the
function <code><a href="#topic+generate_genodata">generate_genodata</a></code> generates <code>n_ind</code>
observations of <code>n_SNV</code> SNVs with random minor allele frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_genodata(n_SNV = 100, n_ind = 1000)

generate_singleton_data(n_SNV = 100, n_ind = 1000)

generate_doubleton_data(n_SNV = 100, n_ind = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_genodata_+3A_n_snv">n_SNV</code></td>
<td>
<p>Integer specifying the number of SNVs that are generated.</p>
</td></tr>
<tr><td><code id="generate_genodata_+3A_n_ind">n_ind</code></td>
<td>
<p>Integer specifying the number of observations that are generated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing <code>n_ind</code> observations of <code>n_SNV</code> SNVs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)
genodata1 &lt;- generate_singleton_data()
compute_MAF(genodata1)

genodata2 &lt;- generate_doubleton_data()
compute_MAF(genodata2)

genodata3 &lt;- generate_genodata()
compute_MAF(genodata3)

</code></pre>

<hr>
<h2 id='generate_phenodata'>Functions to generate phenotype data.</h2><span id='topic+generate_phenodata'></span><span id='topic+generate_phenodata_1_simple'></span><span id='topic+generate_phenodata_1'></span><span id='topic+generate_phenodata_2_bvn'></span><span id='topic+generate_phenodata_2_copula'></span>

<h3>Description</h3>

<p>Functions to generate standard normal or binary phenotypes based on provided genetic
data, for specified effect sizes.
The functions <code><a href="#topic+generate_phenodata_1_simple">generate_phenodata_1_simple</a></code> and
<code><a href="#topic+generate_phenodata_1">generate_phenodata_1</a></code> generate one phenotype Y conditional on
single nucleotide variants (SNVs) and two covariates.
<code><a href="#topic+generate_phenodata_2_bvn">generate_phenodata_2_bvn</a></code> as well as <code><a href="#topic+generate_phenodata_2_copula">generate_phenodata_2_copula</a></code>
generate two phenotypes <code class="reqn">Y_1</code>, <code class="reqn">Y_2</code> with dependence Kendall's tau conditional on
the provided SNVs and two covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_phenodata_1_simple(genodata = NULL, type = "quantitative",
  b = 0, a = c(0, 0.5, 0.5))

generate_phenodata_1(genodata = NULL, type = "quantitative", b = 0.6,
  a = c(0, 0.5, 0.5), MAF_cutoff = 1, prop_causal = 0.1,
  direction = "a")

generate_phenodata_2_bvn(genodata = NULL, tau = NULL, b1 = 0,
  b2 = 0, a1 = c(0, 0.5, 0.5), a2 = c(0, 0.5, 0.5))

generate_phenodata_2_copula(genodata = NULL, phi = NULL, tau = 0.5,
  b1 = 0.6, b2 = 0.6, a1 = c(0, 0.5, 0.5), a2 = c(0, 0.5, 0.5),
  MAF_cutoff = 1, prop_causal = 0.1, direction = "a")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_phenodata_+3A_genodata">genodata</code></td>
<td>
<p>Numeric input vector or dataframe containing the genetic
variant(s) in columns. Must be in allelic coding 0, 1, 2.</p>
</td></tr>
<tr><td><code id="generate_phenodata_+3A_type">type</code></td>
<td>
<p>String with value <code>"quantitative"</code> or <code>"binary"</code>
specifying whether normally-distributed or binary phenotypes
are generated.</p>
</td></tr>
<tr><td><code id="generate_phenodata_+3A_b">b</code></td>
<td>
<p>Integer or vector specifying the genetic effect size(s) of
the provided SNVs (<code>genodata</code>) in the data generation.</p>
</td></tr>
<tr><td><code id="generate_phenodata_+3A_a">a</code></td>
<td>
<p>Numeric vector specifying the effect sizes of the covariates <code class="reqn">X_1</code>, <code class="reqn">X_2</code>
in the data generation.</p>
</td></tr>
<tr><td><code id="generate_phenodata_+3A_maf_cutoff">MAF_cutoff</code></td>
<td>
<p>Integer specifying a minor allele frequency cutoff to
determine among which SNVs the causal SNVs are
sampled for the phenotype generation.</p>
</td></tr>
<tr><td><code id="generate_phenodata_+3A_prop_causal">prop_causal</code></td>
<td>
<p>Integer specifying the desired percentage of causal SNVs
among all SNVs.</p>
</td></tr>
<tr><td><code id="generate_phenodata_+3A_direction">direction</code></td>
<td>
<p>String with value <code>"a"</code>, <code>"b"</code>, or <code>"c"</code>
specifying whether all causal SNVs have a positive effect on
the phenotypes (<code>"a"</code>), 20% of the causal SNVs have a
negative effect and 80% a positive effect on the phenotypes
(<code>"b"</code>), or 50% of the causal SNVs have a negative
effect and 50% a positive effect on the phenotypes (<code>"c"</code>).</p>
</td></tr>
<tr><td><code id="generate_phenodata_+3A_tau">tau</code></td>
<td>
<p>Integer specifying Kendall's tau, which determines the
dependence between the two generated phenotypes.</p>
</td></tr>
<tr><td><code id="generate_phenodata_+3A_b1">b1</code></td>
<td>
<p>Integer or vector specifying the genetic effect size(s) of
the provided SNVs (<code>genodata</code>) on the first phenotype
in the data generation.</p>
</td></tr>
<tr><td><code id="generate_phenodata_+3A_b2">b2</code></td>
<td>
<p>Integer or vector specifying the genetic effect size(s) of
the provided SNVs (<code>genodata</code>) on the second phenotype
in the data generation.</p>
</td></tr>
<tr><td><code id="generate_phenodata_+3A_a1">a1</code></td>
<td>
<p>Numeric vector specifying the effect sizes of the covariates <code class="reqn">X_1</code>, <code class="reqn">X_2</code>
on the first phenotype in the data generation.</p>
</td></tr>
<tr><td><code id="generate_phenodata_+3A_a2">a2</code></td>
<td>
<p>Numeric vector specifying the effect sizes of the covariates <code class="reqn">X_1</code>, <code class="reqn">X_2</code>
on the second phenotype in the data generation.</p>
</td></tr>
<tr><td><code id="generate_phenodata_+3A_phi">phi</code></td>
<td>
<p>Integer specifying the parameter <code class="reqn">\phi</code> for
the dependence between the two generated phenotypes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In more detail, the function <code><a href="#topic+generate_phenodata_1_simple">generate_phenodata_1_simple</a></code>
generates a quantitative or binary phenotype Y with n observations,
conditional on the specified SNVs with given effect sizes and conditional
on one binary and one standard normally-distributed covariate with
specified effect sizes. n is given through the provided SNVs.
</p>
<p><code><a href="#topic+generate_phenodata_1">generate_phenodata_1</a></code> provides an extension of
<code><a href="#topic+generate_phenodata_1_simple">generate_phenodata_1_simple</a></code> and allows to further select
the percentage of causal SNVs, a minor allele frequency cutoff on the
causal SNVs, and varying effect directions. n is given through the
provided SNVs.
</p>
<p>The function <code><a href="#topic+generate_phenodata_2_bvn">generate_phenodata_2_bvn</a></code> generates
two quantitative phenotypes <code class="reqn">Y_1</code>, <code class="reqn">Y_2</code> conditional on one binary and one
standard normally-distributed covariate <code class="reqn">X_1</code>, <code class="reqn">X_2</code> from the bivariate
normal distribution so that they have have dependence <code class="reqn">\tau</code> given
by Kendall's <code>tau</code>.
</p>
<p>The function <code><a href="#topic+generate_phenodata_2_copula">generate_phenodata_2_copula</a></code> generates
two quantitative phenotypes <code class="reqn">Y_1</code>, <code class="reqn">Y_2</code> conditional on one binary and one
standard normally-distributed covariate <code class="reqn">X_1</code>, <code class="reqn">X_2</code> from the Clayton copula
so that <code class="reqn">Y_1</code>, <code class="reqn">Y_2</code> are marginally normally distributed and have dependence
Kendall's tau specified by <code>tau</code> or <code>phi</code>, using the function
<code><a href="#topic+generate_clayton_copula">generate_clayton_copula</a></code>.
</p>
<p>The genetic effect sizes are the specified numeric values <code>b</code> and
<code>b1, b2</code>, respectively, in the functions <code><a href="#topic+generate_phenodata_1_simple">generate_phenodata_1_simple</a></code>
and <code><a href="#topic+generate_phenodata_2_bvn">generate_phenodata_2_bvn</a></code>. In
<code><a href="#topic+generate_phenodata_1">generate_phenodata_1</a></code> and <code><a href="#topic+generate_phenodata_2_copula">generate_phenodata_2_copula</a></code>,
the genetic effect sizes are computed by multiplying <code>b</code> or <code>b1, b2</code>,
respectively, with the absolute value of the log10-transformed
minor allele frequencies, so that rarer variants have larger effect sizes.
</p>


<h3>Value</h3>

<p>A dataframe containing n observations of the phenotype Y or phenotypes
<code class="reqn">Y_1</code>, <code class="reqn">Y_2</code> and of the covariates <code class="reqn">X_1</code>, <code class="reqn">X_2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate genetic data:
set.seed(10)
genodata &lt;- generate_genodata(n_SNV = 20, n_ind = 1000)
compute_MAF(genodata)

# Generate different phenotype data:
phenodata1 &lt;- generate_phenodata_1_simple(genodata = genodata[,1],
                                          type = "quantitative", b = 0)
phenodata2 &lt;- generate_phenodata_1_simple(genodata = genodata[,1],
                                          type = "quantitative", b = 2)
phenodata3 &lt;- generate_phenodata_1_simple(genodata = genodata,
                                          type = "quantitative", b = 2)
phenodata4 &lt;- generate_phenodata_1_simple(genodata = genodata,
                                          type = "quantitative",
                                          b = seq(0.1, 2, 0.1))
phenodata5 &lt;- generate_phenodata_1_simple(genodata = genodata[,1],
                                          type = "binary", b = 0)
phenodata6 &lt;- generate_phenodata_1(genodata = genodata[,1],
                                   type = "quantitative", b = 0,
                                   MAF_cutoff = 1, prop_causal = 0.1,
                                   direction = "a")
phenodata7 &lt;- generate_phenodata_1(genodata = genodata,
                                   type = "quantitative", b = 0.6,
                                   MAF_cutoff = 0.1, prop_causal = 0.05,
                                   direction = "a")
phenodata8 &lt;- generate_phenodata_1(genodata = genodata,
                                   type = "quantitative",
                                   b = seq(0.1, 2, 0.1),
                                   MAF_cutoff = 0.1, prop_causal = 0.05,
                                   direction = "a")
phenodata9 &lt;- generate_phenodata_2_bvn(genodata = genodata[,1],
                                       tau = 0.5, b1 = 0, b2 = 0)
phenodata10 &lt;- generate_phenodata_2_bvn(genodata = genodata,
                                        tau = 0.5, b1 = 0, b2 = 0)
phenodata11 &lt;- generate_phenodata_2_bvn(genodata = genodata,
                                        tau = 0.5, b1 = 1,
                                        b2 = seq(0.1,2,0.1))
phenodata12 &lt;- generate_phenodata_2_bvn(genodata = genodata,
                                        tau = 0.5, b1 = 1, b2 = 2)
par(mfrow = c(3, 1))
hist(phenodata12$Y1)
hist(phenodata12$Y2)
plot(phenodata12$Y1, phenodata12$Y2)

phenodata13 &lt;- generate_phenodata_2_copula(genodata = genodata[,1],
                                           MAF_cutoff = 1, prop_causal = 1,
                                           tau = 0.5, b1 = 0, b2 = 0)
phenodata14 &lt;- generate_phenodata_2_copula(genodata = genodata,
                                           MAF_cutoff = 1, prop_causal = 0.5,
                                           tau = 0.5, b1 = 0, b2 = 0)
phenodata15 &lt;- generate_phenodata_2_copula(genodata = genodata,
                                           MAF_cutoff = 1, prop_causal = 0.5,
                                           tau = 0.5, b1 = 0, b2 = 0)
phenodata16 &lt;- generate_phenodata_2_copula(genodata = genodata,
                                           MAF_cutoff = 1, prop_causal = 0.5,
                                           tau = 0.2, b1 = 0.3,
                                           b2 = seq(0.1, 2, 0.1))
phenodata17 &lt;- generate_phenodata_2_copula(genodata = genodata,
                                           MAF_cutoff = 1, prop_causal = 0.5,
                                           tau = 0.2, b1 = 0.3, b2 = 0.3)
par(mfrow = c(3, 1))
hist(phenodata17$Y1)
hist(phenodata17$Y2)
plot(phenodata17$Y1, phenodata17$Y2)






</code></pre>

<hr>
<h2 id='get_estimates_naive'>Naive estimates of the copula and marginal parameters.</h2><span id='topic+get_estimates_naive'></span>

<h3>Description</h3>

<p>Function to compute naive estimates of the copula parameter(s)
and maximum likelihood (ML) estimates of the marginal parameters in a joint
copula model of <code>Y1</code> and <code>Y2</code> given the predictors of <code>Y1</code>
and <code>Y2</code>. The main use of the function is to provide parameter
starting values for the optimization of the log-likelihood function of the
joint copula model in <code><a href="#topic+cjamp">cjamp</a></code> in order to obtain maximum
likelihood estimates in the copula model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_estimates_naive(Y1 = NULL, Y2 = NULL, predictors_Y1 = NULL,
  predictors_Y2 = NULL, copula_param = "both")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_estimates_naive_+3A_y1">Y1</code></td>
<td>
<p>Numeric vector containing the first phenotype.</p>
</td></tr>
<tr><td><code id="get_estimates_naive_+3A_y2">Y2</code></td>
<td>
<p>Numeric vector containing the second phenotype.</p>
</td></tr>
<tr><td><code id="get_estimates_naive_+3A_predictors_y1">predictors_Y1</code></td>
<td>
<p>Dataframe containing the predictors of <code>Y1</code>
in columns.</p>
</td></tr>
<tr><td><code id="get_estimates_naive_+3A_predictors_y2">predictors_Y2</code></td>
<td>
<p>Dataframe containing the predictors of <code>Y2</code>
in columns.</p>
</td></tr>
<tr><td><code id="get_estimates_naive_+3A_copula_param">copula_param</code></td>
<td>
<p>String indicating whether estimates should be computed
for <code class="reqn">\phi</code> (<code>"phi"</code>), for <code class="reqn">\theta</code>
(<code>"theta"</code>), or both (<code>"both"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimates of the copula parameter(s) include estimates of <code class="reqn">\phi</code>
(if <code>copula_param == "phi"</code>), <code class="reqn">\theta</code> (if
<code>copula_param == "theta"</code>) or both (if <code>copula_param == "both"</code>).
They are obtained by computing Kendall's tau between <code>Y1</code> and <code>Y2</code>
and using the relationship <code class="reqn">\tau = \phi/(\phi+2)</code> of the Clayton
copula to obtain an estimate of <code class="reqn">\phi</code> and <code class="reqn">\tau = (\theta-1)/\theta</code>
of the Gumbel copula to obtain an estimate of <code class="reqn">\theta</code>.
</p>
<p>The ML estimates of the marginal parameters include estimates of the log standard
deviations of <code>Y1</code>, <code>Y2</code> given their predictors (<code class="reqn">log(\sigma1), log(\sigma2)</code>)
and of the effects of <code>predictors_Y1</code> on <code>Y1</code> and
<code>predictors_Y2</code> on <code>Y2</code>. The estimates of the marginal effects are
obtained from linear regression models of <code>Y1</code> given <code>predictors_Y1</code>
and <code>Y2</code> given <code>predictors_Y2</code>, respectively. If single nucleotide
variants (SNVs) are included as predictors, the genetic effect estimates
are obtained from an underlying additive genetic model if SNVs are provided
as 0-1-2 genotypes and from an underlying dominant model if SNVs are provided
as 0-1 genotypes.
</p>


<h3>Value</h3>

<p>Vector of the numeric estimates of the copula parameters
<code class="reqn">log(\phi)</code> and/or <code class="reqn">log(\theta-1)</code>, of the marginal
parameters (<code class="reqn">log(\sigma1), log(\sigma2)</code>, and estimates
of the effects of the predictors <code>predictors_Y1</code>
on <code>Y1</code> and <code>predictors_Y2</code> on <code>Y2</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate genetic data:
set.seed(10)
genodata &lt;- generate_genodata(n_SNV = 20, n_ind = 1000)

# Generate phenotype data:
phenodata &lt;- generate_phenodata_2_copula(genodata = genodata, MAF_cutoff = 1,
                                         prop_causal = 0.5, tau = 0.2,
                                         b1 = 0.3, b2 = 0.3)
predictors &lt;- data.frame(X1 = phenodata$X1, X2 = phenodata$X2,
                         SNV = genodata$SNV1)

get_estimates_naive(Y1 = phenodata$Y1, Y2 = phenodata$Y2,
                    predictors_Y1 = predictors, predictors_Y2 = predictors,
                    copula_param = "both")

</code></pre>

<hr>
<h2 id='lrt'>Compute likelihood ratio tests.</h2><span id='topic+lrt'></span><span id='topic+lrt_copula'></span><span id='topic+lrt_param'></span>

<h3>Description</h3>

<p>Functions to compute likelihood ratio tests of two nested copula models
with the same marginal models, and of marginal parameters in the same copula
model but with different nested marginal models where one or more parameters
are set to 0 (Yilmaz &amp; Lawless, 2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lrt_copula(minlogl_null = NULL, minlogl_altern = NULL)

lrt_param(minlogl_null = NULL, minlogl_altern = NULL, df = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lrt_+3A_minlogl_null">minlogl_null</code></td>
<td>
<p>Minus log-likelihood of the null model, which is nested
within the larger alternative model <code>minlogl_altern</code>.</p>
</td></tr>
<tr><td><code id="lrt_+3A_minlogl_altern">minlogl_altern</code></td>
<td>
<p>Minus log-likelihood of the alternative model, which
contains the null model <code>minlogl_null</code>.</p>
</td></tr>
<tr><td><code id="lrt_+3A_df">df</code></td>
<td>
<p>Degrees of freedom in the likelihood ratio test of marginal
parameters in the same copula model, i.e. the number of
parameters that are in the alternative model but that are not
contained in the smaller nested null model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>References:
</p>
<p>Yilmaz YE, Lawless JF (2011). Likelihood ratio procedures and tests of fit in parametric and semiparametric copula models with censored data. Lifetime Data Analysis, 17(3): 386-408.
</p>


<h3>Value</h3>

<p>List including the <code class="reqn">\chi^2</code> value and p-value of the likelihood
ratio test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1: Test whether 2-parameter copula model has a better
#            model fit compared to Clayton copula (no).
set.seed(10)
genodata &lt;- generate_genodata(n_SNV = 20, n_ind = 100)
phenodata &lt;- generate_phenodata_2_copula(genodata = genodata$SNV1,
                                         MAF_cutoff = 1, prop_causal = 1,
                                         tau = 0.2, b1 = 0.3, b2 = 0.3)
predictors &lt;- data.frame(X1 = phenodata$X1, X2 = phenodata$X2,
                         SNV = genodata$SNV1)
estimates_c &lt;- get_estimates_naive(Y1 = phenodata$Y1, Y2 = phenodata$Y2,
                                   predictors_Y1 = predictors,
                                   predictors_Y2 = predictors,
                                   copula_param = "phi")
minusloglik_Clayton &lt;- minusloglik(Y1 = phenodata$Y1, Y2 = phenodata$Y2,
                                   predictors_Y1 = predictors,
                                   predictors_Y2 = predictors,
                                   parameters = estimates_c, copula = "Clayton")
estimates_2p &lt;- get_estimates_naive(Y1 = phenodata$Y1, Y2 = phenodata$Y2,
                                    predictors_Y1 = predictors,
                                    predictors_Y2 = predictors,
                                    copula_param = "both")
minusloglik_2param &lt;- minusloglik(Y1 = phenodata$Y1, Y2 = phenodata$Y2,
                                  predictors_Y1 = predictors,
                                  predictors_Y2 = predictors,
                                  parameters = estimates_2p, copula = "2param")
lrt_copula(minusloglik_Clayton, minusloglik_2param)

# Example 2: Test marginal parameters (alternative model has better fit).
set.seed(10)
genodata &lt;- generate_genodata(n_SNV = 20, n_ind = 100)
phenodata &lt;- generate_phenodata_2_copula(genodata = genodata$SNV1,
                                         MAF_cutoff = 1, prop_causal = 1,
                                         tau = 0.2, b1 = 2, b2 = 2)
predictors_1 &lt;- data.frame(X1 = phenodata$X1, X2 = phenodata$X2)
estimates_1 &lt;- get_estimates_naive(Y1 = phenodata$Y1, Y2 = phenodata$Y2,
                                   predictors_Y1 = predictors_1,
                                   predictors_Y2 = predictors_1,
                                   copula_param = "phi")
minusloglik_1 &lt;- minusloglik(Y1 = phenodata$Y1, Y2 = phenodata$Y2,
                             predictors_Y1 = predictors_1,
                             predictors_Y2 = predictors_1,
                             parameters = estimates_1, copula = "Clayton")
predictors_2 &lt;- data.frame(X1 = phenodata$X1, X2 = phenodata$X2,
                           SNV = genodata$SNV1)
estimates_2 &lt;- get_estimates_naive(Y1 = phenodata$Y1, Y2 = phenodata$Y2,
                                   predictors_Y1 = predictors_2,
                                   predictors_Y2 = predictors_2,
                                   copula_param = "phi")
minusloglik_2 &lt;- minusloglik(Y1 = phenodata$Y1, Y2 = phenodata$Y2,
                             predictors_Y1 = predictors_2,
                             predictors_Y2 = predictors_2,
                             parameters = estimates_2, copula = "Clayton")
lrt_param(minusloglik_1, minusloglik_2, df=2)

</code></pre>

<hr>
<h2 id='minusloglik'>Minus log-likelihood of copula models.</h2><span id='topic+minusloglik'></span>

<h3>Description</h3>

<p>Function to compute the minus log-likelihood of the joint distribution
of <code>Y1</code> and <code>Y2</code> given the predictors <code>predictors_Y1</code>
of <code>Y1</code> and <code>predictors_Y2</code> of <code>Y2</code> in a copula model
for given parameter values <code>parameters</code>. Implemented are the
Clayton and 2-parameter copula. The function assumes quantitative
predictors and uses an additive model, i.e. for categorical predictors
with more than 2 levels, dummy variables have to be created beforehand.
Accordingly, if single nucleotide variants (SNVs) are included as
predictors, the computation is based on an additive genetic model if
SNVs are provided as 0-1-2 genotypes and on a dominant model if SNVs
are provided as 0-1 genotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minusloglik(copula = "Clayton", Y1 = NULL, Y2 = NULL,
  predictors_Y1 = NULL, predictors_Y2 = NULL, parameters = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minusloglik_+3A_copula">copula</code></td>
<td>
<p>String indicating whether the likelihood should be computed
under the Clayton (<code>"Clayton"</code>) or 2-parameter copula
(<code>"2param"</code>) model.</p>
</td></tr>
<tr><td><code id="minusloglik_+3A_y1">Y1</code></td>
<td>
<p>Numeric vector containing the first phenotype.</p>
</td></tr>
<tr><td><code id="minusloglik_+3A_y2">Y2</code></td>
<td>
<p>Numeric vector containing the second phenotype.</p>
</td></tr>
<tr><td><code id="minusloglik_+3A_predictors_y1">predictors_Y1</code></td>
<td>
<p>Dataframe containing the predictors of <code>Y1</code>
in columns.</p>
</td></tr>
<tr><td><code id="minusloglik_+3A_predictors_y2">predictors_Y2</code></td>
<td>
<p>Dataframe containing predictors of <code>Y2</code>
in columns.</p>
</td></tr>
<tr><td><code id="minusloglik_+3A_parameters">parameters</code></td>
<td>
<p>Named integer vector containing the parameter estimates
of the marginal and copula parameters, for which the
log-likelihood will be computed. For details and the
necessary format of the vector, see the details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of predictors is not fixed and also different predictors
can be supplied for <code>Y1</code> and <code>Y2</code>. However, for the functioning
of the log-likelihood function, the <code>parameters</code> vector has to be
supplied in a pre-specified form and formatting:
</p>
<p>The vector has to include the copula parameter(s), marginal parameters
for <code>Y1</code>, and marginal parameters for <code>Y2</code> in this order.
For example, for the 2-parameter copula with parameters <code class="reqn">\phi, \theta</code>
and marginal models
</p>
<p style="text-align: center;"><code class="reqn">Y_1 = \alpha_0 + \alpha_1 \cdot X_1 + \alpha_2 \cdot X_2 + \epsilon_1, \ \epsilon_1 \sim N(0,\sigma_1^2),</code>
</p>

<p style="text-align: center;"><code class="reqn">Y_1 = \beta_0 + \beta_1 \cdot X_1 + \epsilon_2, \ \epsilon_2 \sim N(0,\sigma_2^2),</code>
</p>

<p>the parameter vector has be
</p>
<p style="text-align: center;"><code class="reqn">(log(\phi), log(\theta-1), log(\sigma_1), log(\sigma_2), \alpha_0, \alpha_2, \alpha_1, \beta_0, \beta_1)^T.</code>
</p>

<p><code class="reqn">log(\phi)</code> and <code class="reqn">log(\theta-1)</code> have to be provided instead of
<code class="reqn">\phi, \theta</code> and <code class="reqn">log(\sigma_1)</code>, <code class="reqn">log(\sigma_2)</code> instead of
<code class="reqn">\sigma_1</code>, <code class="reqn">\sigma_2</code> for computational reasons when the log-likelihood
function is optimized in <code><a href="#topic+cjamp">cjamp</a></code>. As further necessary format,
the vector has to be named and the names of the copula parameter(s) has/have
to be <code>log_phi</code> and/or <code>log_theta_minus1</code>.
</p>


<h3>Value</h3>

<p>Minus log-likelihood value (integer).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate genetic data:
set.seed(10)
genodata &lt;- generate_genodata(n_SNV = 20, n_ind = 1000)

# Generate phenotype data:
phenodata &lt;- generate_phenodata_2_copula(genodata = genodata, MAF_cutoff = 1,
                                         prop_causal = 0.5, tau = 0.2,
                                         b1 = 0.3, b2 = 0.3)

# Example 1: Log-likelihood of null model without covariates &amp; genetic effects
estimates &lt;- get_estimates_naive(Y1 = phenodata$Y1, Y2 = phenodata$Y2,
                                 predictors_Y1 = NULL, predictors_Y2 = NULL,
                                 copula_param = "both")
minusloglik(Y1 = phenodata$Y1, Y2 = phenodata$Y2, predictors_Y1 = NULL,
            predictors_Y2 = NULL, parameters = estimates, copula = "2param")

# Example 2: Log-likelihood of null model with covariates, without genetic effects
predictors &lt;- data.frame(X1 = phenodata$X1, X2 = phenodata$X2)
estimates &lt;- get_estimates_naive(Y1 = phenodata$Y1, Y2 = phenodata$Y2,
                                 predictors_Y1 = predictors,
                                 predictors_Y2 = predictors,
                                 copula_param = "both")
minusloglik(Y1 = phenodata$Y1, Y2 = phenodata$Y2, predictors_Y1 = predictors,
            predictors_Y2 = predictors, parameters = estimates, copula = "2param")

# Example 3: Log-likelihood of model with covariates &amp; genetic effect on Y1 only
predictors_Y1 &lt;- data.frame(X1 = phenodata$X1, X2 = phenodata$X2,
                            SNV = genodata$SNV1)
predictors_Y2 &lt;- data.frame(X1 = phenodata$X1, X2 = phenodata$X2)
estimates &lt;- get_estimates_naive(Y1 = phenodata$Y1, Y2 = phenodata$Y2,
                                 predictors_Y1 = predictors_Y1,
                                 predictors_Y2 = predictors_Y2,
                                 copula_param = "both")
minusloglik(Y1 = phenodata$Y1, Y2 = phenodata$Y2, predictors_Y1 = predictors_Y1,
            predictors_Y2 = predictors_Y2, parameters = estimates,
            copula = "2param")

# Example 4: Log-likelihood of model with covariates &amp; genetic effect on Y2 only
predictors_Y1 &lt;- data.frame(X1 = phenodata$X1, X2 = phenodata$X2)
predictors_Y2 &lt;- data.frame(X1 = phenodata$X1, X2 = phenodata$X2,
                            SNV = genodata$SNV1)
estimates &lt;- get_estimates_naive(Y1 = phenodata$Y1, Y2 = phenodata$Y2,
                                 predictors_Y1 = predictors_Y1,
                                 predictors_Y2 = predictors_Y2,
                                 copula_param = "both")
minusloglik(Y1 = phenodata$Y1, Y2 = phenodata$Y2, predictors_Y1 = predictors_Y1,
            predictors_Y2 = predictors_Y2, parameters = estimates,
            copula = "2param")

# Example 5: Log-likelihood of model without covariates, with genetic effects
predictors &lt;- data.frame(SNV = genodata$SNV1)
estimates &lt;- get_estimates_naive(Y1 = phenodata$Y1, Y2 = phenodata$Y2,
                                 predictors_Y1 = predictors,
                                 predictors_Y2 = predictors,
                                 copula_param = "both")
minusloglik(Y1 = phenodata$Y1, Y2 = phenodata$Y2, predictors_Y1 = predictors,
            predictors_Y2 = predictors, parameters = estimates, copula = "2param")

# Example 6: Log-likelihood of model with covariates &amp; genetic effects
predictors &lt;- data.frame(X1 = phenodata$X1, X2 = phenodata$X2, SNV = genodata$SNV1)
estimates &lt;- get_estimates_naive(Y1 = phenodata$Y1, Y2 = phenodata$Y2,
                                 predictors_Y1 = predictors,
                                 predictors_Y2 = predictors,
                                 copula_param = "both")
minusloglik(Y1 = phenodata$Y1, Y2 = phenodata$Y2, predictors_Y1 = predictors,
            predictors_Y2 = predictors, parameters = estimates, copula = "2param")

# Example 7: Log-likelihood of model with covariates &amp; multiple genetic effects
predictors &lt;- data.frame(X1 = phenodata$X1, X2 = phenodata$X2, genodata[, 1:5])
estimates &lt;- get_estimates_naive(Y1 = phenodata$Y1, Y2 = phenodata$Y2,
                                 predictors_Y1 = predictors,
                                 predictors_Y2 = predictors,
                                 copula_param = "both")
minusloglik(Y1 = phenodata$Y1, Y2 = phenodata$Y2, predictors_Y1 = predictors,
            predictors_Y2 = predictors, parameters = estimates, copula = "2param")

</code></pre>

<hr>
<h2 id='summary.cjamp'>Summary function.</h2><span id='topic+summary.cjamp'></span>

<h3>Description</h3>

<p>Summary function for the <code><a href="#topic+cjamp">cjamp</a></code> and <code><a href="#topic+cjamp_loop">cjamp_loop</a></code>
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cjamp'
summary(object = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cjamp_+3A_object">object</code></td>
<td>
<p><code>cjamp</code> object (output of the <code><a href="#topic+cjamp">cjamp</a></code>
or <code><a href="#topic+cjamp_loop">cjamp_loop</a></code> function).</p>
</td></tr>
<tr><td><code id="summary.cjamp_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Formatted data frame of the results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run. When executing, the following takes about 2 minutes running time.
## Summary of regular cjamp function
#set.seed(10)
#genodata &lt;- generate_genodata(n_SNV = 20, n_ind = 100)
#phenodata &lt;- generate_phenodata_2_copula(genodata = genodata$SNV1,
#                                         MAF_cutoff = 1, prop_causal = 1,
#                                         tau = 0.2, b1 = 0.3, b2 = 0.3)
#predictors &lt;- data.frame(X1 = phenodata$X1, X2 = phenodata$X2,
#                        genodata[, 1:3])
#results &lt;- cjamp(Y1 = phenodata$Y1, Y2 = phenodata$Y2,
#                 predictors_Y1 = predictors, predictors_Y2 = predictors,
#                 copula = "2param", optim_method = "BFGS", trace = 0,
#                 kkt2tol = 1E-16, SE_est = TRUE, pval_est = TRUE,
#                 n_iter_max = 10)
#summary(results)
#
## Summary of looped cjamp function
#covariates &lt;- data.frame(X1 = phenodata$X1, X2 = phenodata$X2)
#predictors &lt;- genodata
#results &lt;- cjamp_loop(Y1 = phenodata$Y1, Y2 = phenodata$Y2,
#                      covariates_Y1 = covariates,
#                      covariates_Y2 = covariates,
#                      predictors = predictors, copula = "Clayton",
#                      optim_method = "BFGS", trace = 0, kkt2tol = 1E-16,
#                      SE_est = TRUE, pval_est = TRUE, n_iter_max = 10)
#summary(results)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
