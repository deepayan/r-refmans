<!DOCTYPE html><html lang="en"><head><title>Help for package FuzzyImputationTest</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FuzzyImputationTest}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ApplyStatisticalTests'><p>Statistical epistemic tests the imputed values.</p></a></li>
<li><a href='#CalculateFuzzyMeasures'><p>Calculation of the fuzzy measures for the imputed values.</p></a></li>
<li><a href='#ErrorMatrix'><p>Calculation of the errors for the imputed values.</p></a></li>
<li><a href='#FuzzifyMatrix'><p>Fuzzyfing the crisp values.</p></a></li>
<li><a href='#FuzzyImputation'><p>Main method to impute fuzzy values.</p></a></li>
<li><a href='#FuzzyNumbersToMatrix'><p>Conversion of a list of fuzzy numbers into a matrix.</p></a></li>
<li><a href='#ImputationDimp'><p>DIMP (d-imputation) method for fuzzy numbers.</p></a></li>
<li><a href='#ImputationTests'><p>Battery of test for the imputed fuzzy values.</p></a></li>
<li><a href='#IntroducingNA'><p>Introducing NAs to the specified matrix.</p></a></li>
<li><a href='#MatrixToFuzzyNumbers'><p>Conversion of a matrix to a list of fuzzy numbers.</p></a></li>
<li><a href='#MeasureAHD'><p>Function to calculate the AHD distance between two fuzzy numbers.</p></a></li>
<li><a href='#MeasureEuclidean'><p>Function to calculate the Euclidean distance between two fuzzy numbers.</p></a></li>
<li><a href='#MeasureHSD'><p>Function to calculate the HSD distance between two fuzzy numbers.</p></a></li>
<li><a href='#methodNames'><p>A vector containing names of the resampling methods.</p></a></li>
<li><a href='#MethodsComparison'><p>Comparison of imputation methods for fuzzy values.</p></a></li>
<li><a href='#RemoveNotFuzzy'><p>Removing values that are not fuzzy numbers.</p></a></li>
<li><a href='#StatisticalMeasures'><p>Calculation of statistical measures for errors of the imputed data.</p></a></li>
<li><a href='#summary.impTest'><p>Print summary of the benchmark for the imputation method.</p></a></li>
<li><a href='#summary.metComp'><p>Print summary of the comparison of the imputation methods.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Imputation Procedures and Quality Tests for Fuzzy Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Special procedures for the imputation of missing fuzzy numbers are still underdeveloped. The goal of the package is to provide the new d-imputation method (DIMP for short, Romaniuk, M. and Grzegorzewski, P. (2023) "Fuzzy Data Imputation with DIMP and FGAIN" RB/23/2023) and covert some classical ones applied in R packages ('missForest','miceRanger','knn') for use with fuzzy datasets. Additionally, specially tailored benchmarking tests are provided to check and compare these imputation procedures with fuzzy datasets.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, methods, FuzzySimRes, FuzzyNumbers, missForest,
miceRanger, VIM, utils</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-24 15:05:02 UTC; mroman</td>
</tr>
<tr>
<td>Author:</td>
<td>Maciej Romaniuk <a href="https://orcid.org/0000-0001-9649-396X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Maciej Romaniuk &lt;mroman@ibspan.waw.pl&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-24 15:20:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='ApplyStatisticalTests'>Statistical epistemic tests the imputed values.</h2><span id='topic+ApplyStatisticalTests'></span>

<h3>Description</h3>

<p><code>ApplyStatisticalTests</code> applies the epistemic goodness-of-fit test for
fuzzy data to check the quality of the imputed values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ApplyStatisticalTests(
  trueData,
  imputedData,
  imputedMask,
  trapezoidal = TRUE,
  cutsNumber = 100,
  K = 50,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ApplyStatisticalTests_+3A_truedata">trueData</code></td>
<td>
<p>Name of the input matrix (or data frame) with the true values of the variables.</p>
</td></tr>
<tr><td><code id="ApplyStatisticalTests_+3A_imputeddata">imputedData</code></td>
<td>
<p>Name of the input matrix (or data frame) with the imputed values.</p>
</td></tr>
<tr><td><code id="ApplyStatisticalTests_+3A_imputedmask">imputedMask</code></td>
<td>
<p>Matrix (or data frame) with logical values where <code>TRUE</code> indicates the cells with the imputed values.</p>
</td></tr>
<tr><td><code id="ApplyStatisticalTests_+3A_trapezoidal">trapezoidal</code></td>
<td>
<p>Logical value depending on the type of fuzzy values (triangular or trapezoidal ones) in the dataset.</p>
</td></tr>
<tr><td><code id="ApplyStatisticalTests_+3A_cutsnumber">cutsNumber</code></td>
<td>
<p>Number of cuts for the epistemic bootstrap tests.</p>
</td></tr>
<tr><td><code id="ApplyStatisticalTests_+3A_k">K</code></td>
<td>
<p>Value of <code>K</code> for the <code>res</code> epistemic test.</p>
</td></tr>
<tr><td><code id="ApplyStatisticalTests_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure applies three types of the epistemic goodness-of-fit Kolmogorov-Smirnov tests (<code>avs</code> - averaging statistic,
<code>ms</code> - multi-statistic, <code>res</code> - resampling algorithm) from the <code>FuzzySimRes</code>
package to check the quality of the imputed values.
To do this, three subsamples are used:
</p>

<ul>
<li> <p><code>true</code> - the dataset <code>trueData</code> without imputed values vs the values from the same dataset that are then imputed,
</p>
</li>
<li> <p><code>imputed</code> - the dataset <code>trueData</code> without imputed values vs only the imputed values from <code>imputedData</code>,
</p>
</li>
<li> <p><code>parts</code> - only the imputed values from the dataset <code>trueData</code> vs their counterparts from <code>imputedData</code>.
</p>
</li></ul>

<p>To assess the respective imputation quality, p-values for <code>true</code> and <code>imputed</code> should be close to each other,
and in the case of <code>parts</code>, they should exceed the selected significance level.
</p>
<p>All of the input datasets can be given as matrices or data frames.
The statistical tests are performed only for the input values that are proper fuzzy numbers (triangular or trapezoidal ones).
</p>


<h3>Value</h3>

<p>The output is given as a matrix (the rows are related to various types of the test and subsamples, the columns - to the variables plus the overall mean).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# seed PRNG

set.seed(1234)

# load the necessary library

library(FuzzySimRes)

# generate sample of trapezoidal fuzzy numbers with FuzzySimRes library

list1&lt;-SimulateSample(20,originalPD="rnorm",parOriginalPD=list(mean=0,sd=1),
incrCorePD="rexp", parIncrCorePD=list(rate=2),
suppLeftPD="runif",parSuppLeftPD=list(min=0,max=0.6),
suppRightPD="runif", parSuppRightPD=list(min=0,max=0.6),
type="trapezoidal")

# convert fuzzy data into a matrix

matrix1 &lt;- FuzzyNumbersToMatrix(list1$value)

# check starting values

head(matrix1)

# add some NAs to the matrix

matrix1NA &lt;- IntroducingNA(matrix1,percentage = 0.1)

head(matrix1NA)

# impute missing values (with possible repetitions!)

matrix1DImp &lt;- FuzzyImputation(matrix1NA,method="dimp",checkFuzzy=TRUE)

# find cells with NAs

matrix1Mask &lt;- is.na(matrix1NA)

# apply statistical epistemic bootstrap tests

ApplyStatisticalTests(matrix1,matrix1DImp,matrix1Mask,cutsNumber = 100, K=10)



</code></pre>

<hr>
<h2 id='CalculateFuzzyMeasures'>Calculation of the fuzzy measures for the imputed values.</h2><span id='topic+CalculateFuzzyMeasures'></span>

<h3>Description</h3>

<p>'CalculateFuzzyMeasures' calculates the various types of fuzzy measures between two datasets &ndash; the true and the imputed one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculateFuzzyMeasures(
  trueData,
  imputedData,
  imputedMask,
  trapezoidal = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalculateFuzzyMeasures_+3A_truedata">trueData</code></td>
<td>
<p>Name of the input matrix (or data frame) with the true values of the variables.</p>
</td></tr>
<tr><td><code id="CalculateFuzzyMeasures_+3A_imputeddata">imputedData</code></td>
<td>
<p>Name of the input matrix (or data frame) with the imputed values.</p>
</td></tr>
<tr><td><code id="CalculateFuzzyMeasures_+3A_imputedmask">imputedMask</code></td>
<td>
<p>Matrix (or data frame) with logical values where <code>TRUE</code> indicates the cells with the imputed values.</p>
</td></tr>
<tr><td><code id="CalculateFuzzyMeasures_+3A_trapezoidal">trapezoidal</code></td>
<td>
<p>Logical value depending on the type of fuzzy values (triangular or trapezoidal ones) in the dataset.</p>
</td></tr>
<tr><td><code id="CalculateFuzzyMeasures_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure calculates different types of the distance measures (Euclidean - the Euclidean measure,
AHD - the AHD measure, HSD - the HSD measure), and means of the absolute differences for various fuzzy characteristics
(DiffVal - the difference of the value, DiffAmb - the ambiguity, DiffEV - the expected value, DiffWidth - the width)
between two datasets - the first one with true values (set by <code>trueData</code>), and the second one (specified by <code>imputedData</code>) with
the imputed variables.
Only the truly imputed values are taken into account for these calculations.
To properly distinguish the real values with their imputed counterparts, the additional matrix <code>imputedMask</code> should be provided.
In this matrix, the logical value <code>TRUE</code> points out the cells with the imputed values.
Otherwise, <code>FALSE</code> should be used.
</p>
<p>All of the input datasets can be given as matrices or data frames.
</p>


<h3>Value</h3>

<p>The output is given as a matrix (the rows are related to various types of the errors, the columns - to the variables and the overall mean).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# seed PRNG

set.seed(1234)

# load the necessary library

library(FuzzySimRes)

# generate sample of trapezoidal fuzzy numbers with FuzzySimRes library

list1&lt;-SimulateSample(20,originalPD="rnorm",parOriginalPD=list(mean=0,sd=1),
incrCorePD="rexp", parIncrCorePD=list(rate=2),
suppLeftPD="runif",parSuppLeftPD=list(min=0,max=0.6),
suppRightPD="runif", parSuppRightPD=list(min=0,max=0.6),
type="trapezoidal")

# convert fuzzy data into a matrix

matrix1 &lt;- FuzzyNumbersToMatrix(list1$value)

# check starting values

head(matrix1)

# add some NAs to the matrix

matrix1NA &lt;- IntroducingNA(matrix1,percentage = 0.1)

head(matrix1NA)

# impute missing values

matrix1DImp &lt;- ImputationDimp(matrix1NA)

# find cells with NAs

matrix1Mask &lt;- is.na(matrix1NA)

# calculate fuzzy measures for the imputed values

CalculateFuzzyMeasures(matrix1,matrix1DImp,matrix1Mask,trapezoidal=TRUE)



</code></pre>

<hr>
<h2 id='ErrorMatrix'>Calculation of the errors for the imputed values.</h2><span id='topic+ErrorMatrix'></span>

<h3>Description</h3>

<p>'ErrorMatrix' calculates the various types of the errors between two datasets &ndash; the true and the imputed one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ErrorMatrix(trueData, imputedData, imputedMask, trapezoidal = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ErrorMatrix_+3A_truedata">trueData</code></td>
<td>
<p>Name of the input matrix (or data frame, or list) with the true values of the variables.</p>
</td></tr>
<tr><td><code id="ErrorMatrix_+3A_imputeddata">imputedData</code></td>
<td>
<p>Name of the input matrix (or data frame) with the imputed values.</p>
</td></tr>
<tr><td><code id="ErrorMatrix_+3A_imputedmask">imputedMask</code></td>
<td>
<p>Matrix (or data frame) with logical values where <code>TRUE</code> indicates the cells with the imputed values.</p>
</td></tr>
<tr><td><code id="ErrorMatrix_+3A_trapezoidal">trapezoidal</code></td>
<td>
<p>Logical value depending on the type of fuzzy values (triangular or trapezoidal ones) in the dataset.</p>
</td></tr>
<tr><td><code id="ErrorMatrix_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure calculates different types of the errors (MAE - the mean absolute error, WMA - the weighted mean absolute error,
MSE - the mean squared error, WMSE - the weighted mean squared error, NRMSE - the normalized root mean squared error)
between two datasets - the first one with true values (set by <code>trueData</code>), and the second one (specified by <code>imputedData</code>) with
the imputed variables.
To properly distinguish the real values with their imputed counterparts, the additional matrix <code>imputedMask</code> should be provided.
In this matrix, the logical value <code>TRUE</code> points out the cells with the imputed values.
Otherwise, <code>FALSE</code> should be used.
</p>
<p>All of the input datasets can be given as matrices or data frames.
</p>


<h3>Value</h3>

<p>The output is given as a matrix (the rows are related to various types of the errors, the columns - to the variables).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# seed PRNG

set.seed(1234)

# load the necessary library

library(FuzzySimRes)

# generate sample of trapezoidal fuzzy numbers with FuzzySimRes library

list1&lt;-SimulateSample(20,originalPD="rnorm",parOriginalPD=list(mean=0,sd=1),
incrCorePD="rexp", parIncrCorePD=list(rate=2),
suppLeftPD="runif",parSuppLeftPD=list(min=0,max=0.6),
suppRightPD="runif", parSuppRightPD=list(min=0,max=0.6),
type="trapezoidal")

# convert fuzzy data into a matrix

matrix1 &lt;- FuzzyNumbersToMatrix(list1$value)

# check starting values

head(matrix1)

# add some NAs to the matrix

matrix1NA &lt;- IntroducingNA(matrix1,percentage = 0.1)

head(matrix1NA)

# impute missing values

matrix1DImp &lt;- ImputationDimp(matrix1NA)

# find cells with NAs

matrix1Mask &lt;- is.na(matrix1NA)

# calculate errors for the imputed values

ErrorMatrix(matrix1,matrix1DImp,matrix1Mask)



</code></pre>

<hr>
<h2 id='FuzzifyMatrix'>Fuzzyfing the crisp values.</h2><span id='topic+FuzzifyMatrix'></span>

<h3>Description</h3>

<p>'FuzzifyMatrix' converts real-valued variables into fuzzy numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FuzzifyMatrix(
  crispMatrix,
  coreFactor = 0.2,
  supportFactor = 0.2,
  trapezoidal = TRUE,
  varNames = colnames(crispMatrix),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FuzzifyMatrix_+3A_crispmatrix">crispMatrix</code></td>
<td>
<p>Name of the input matrix (or data frame) with real-valued variables to fuzzify.</p>
</td></tr>
<tr><td><code id="FuzzifyMatrix_+3A_corefactor">coreFactor</code></td>
<td>
<p>Value used as the multiplier for the left/right end of the interval of the uniform distribution applied to
randomly generated increments of the core.</p>
</td></tr>
<tr><td><code id="FuzzifyMatrix_+3A_supportfactor">supportFactor</code></td>
<td>
<p>Value used as the multiplier for the left/right end of the interval of the uniform distribution applied to
randomly generated increments of the support.</p>
</td></tr>
<tr><td><code id="FuzzifyMatrix_+3A_trapezoidal">trapezoidal</code></td>
<td>
<p>Logical value that indicates if trapezoidal (or triangular, otherwise) fuzzy numbers should be generated.</p>
</td></tr>
<tr><td><code id="FuzzifyMatrix_+3A_varnames">varNames</code></td>
<td>
<p>Names of the input variables.</p>
</td></tr>
<tr><td><code id="FuzzifyMatrix_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure generates trapezoidal fuzzy numbers (when the default <code>trapezoidal=TRUE</code> is set) or triangular
ones (for <code>trapezoidal=FALSE</code>) based on the real-valued data from the given matrix or the data frame.
To do this, for each variable the standard deviation is calculated.
Then, the left and right increments of the core (in the case of trapezoidal fuzzy numbers) are
randomly generated using the original value plus/minus two random values from
the uniform distribution on the interval [0,<code>coreFactor</code>*(standard deviation)].
In the case of triangular fuzzy numbers, the cores are equal to the original real values.
In the same manner, the left and right increments of the support are randomly generated with
two random values from the uniform distribution on the interval [0,<code>supportFactor</code>*(standard deviation)].
</p>


<h3>Value</h3>

<p>The output is given as a matrix with three (in the case of triangular fuzzy numbers) or four (for trapezoidal
fuzzy numbers) columns for each input variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# set seed for the random generator

set.seed(12345)

# let's look at the beginning of the iris dataset (four numeric variables)

head(iris[,1:4])

# and fuzzify these variables

fuzzyOutput &lt;- FuzzifyMatrix(iris[,1:4])

head(fuzzyOutput)


</code></pre>

<hr>
<h2 id='FuzzyImputation'>Main method to impute fuzzy values.</h2><span id='topic+FuzzyImputation'></span>

<h3>Description</h3>

<p>'FuzzyImputation' imputes (i.e., replaces missing values) fuzzy numbers using various methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FuzzyImputation(
  dataToImpute,
  method = "dimp",
  trapezoidal = TRUE,
  checkFuzzy = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FuzzyImputation_+3A_datatoimpute">dataToImpute</code></td>
<td>
<p>Name of the input matrix (data frame or list) of fuzzy numbers with some NAs.</p>
</td></tr>
<tr><td><code id="FuzzyImputation_+3A_method">method</code></td>
<td>
<p>Name of the imputation method (possible values: <code>dimp,missForest,miceRanger,knn</code>).</p>
</td></tr>
<tr><td><code id="FuzzyImputation_+3A_trapezoidal">trapezoidal</code></td>
<td>
<p>Logical value depending on the type of fuzzy values (triangular or trapezoidal ones) in the dataset.</p>
</td></tr>
<tr><td><code id="FuzzyImputation_+3A_checkfuzzy">checkFuzzy</code></td>
<td>
<p>If <code>TRUE</code> is set, after each imputation, the output values are checked if they are proper fuzzy numbers.
If there are some improper fuzzy numbers, they are removed, and the imputation procedure is repeated.</p>
</td></tr>
<tr><td><code id="FuzzyImputation_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> is set, the current simulation number is printed.</p>
</td></tr>
<tr><td><code id="FuzzyImputation_+3A_...">...</code></td>
<td>
<p>Additional parameters that are passed to the imputation procedure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure randomly imputes missing values (NAs) with suitable data in the case of a data frame (or a matrix, or a list)
consisting of fuzzy numbers (triangular fuzzy numbers if <code>trapezoidal=FALSE</code> is set, or trapezoidal ones if the default
<code>trapezoidal=TRUE</code> is used).
The output is given as a matrix without NAs, where each row is related to fuzzy numbers (given by 3 values for the triangular fuzzy numbers,
or 4 values in the case of trapezoidal ones) for the consecutive variables.
Many fuzzy variables (not only the single one) can be used. 
The input has to consist of fuzzy numbers of the same type (i.e., mixing triangular and trapezoidal fuzzy numbers is not allowed).
</p>
<p>Various possible imputation methods can be used when the parameter <code>method</code> is specified &ndash;
both the general ones (<code>missForest</code> or <code>miceRanger</code> from the respective packages, or <code>knn</code> from
<code>VIM</code> package) and a more specific ones, tailored for the fuzzy data (<code>dimp</code> in the case of the DIMP method).
Please note that due to the imputation, some output values can be improper fuzzy variables 
(e.g., a core of a fuzzy number can have greater value than its right end of the support).
To avoid this, <code>checkFuzzy=TRUE</code> should be set.
In this case, the imputation procedure is repeated until all of the results are proper triangular or trapezoidal fuzzy numbers.
The improper values are removed and replaced with the respective fuzzy numbers from the input dataset.
However, many repetitions (even unacceptably many) are then possible.
</p>


<h3>Value</h3>

<p>The output is given as a matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# seed PRNG

set.seed(1234)

# load the necessary library

library(FuzzySimRes)

# generate sample of trapezoidal fuzzy numbers with FuzzySimRes library

list1&lt;-SimulateSample(20,originalPD="rnorm",parOriginalPD=list(mean=0,sd=1),
incrCorePD="rexp", parIncrCorePD=list(rate=2),
suppLeftPD="runif",parSuppLeftPD=list(min=0,max=0.6),
suppRightPD="runif", parSuppRightPD=list(min=0,max=0.6),
type="trapezoidal")

# convert fuzzy data into a matrix

matrix1 &lt;- FuzzyNumbersToMatrix(list1$value)

# check starting values

head(matrix1)

# add some NAs to the matrix

matrix1NA &lt;- IntroducingNA(matrix1,percentage = 0.1)

head(matrix1NA)

# impute missing values with the DIMP method

set.seed(12345)

FuzzyImputation(matrix1NA)

# impute missing values with the miceRanger method

set.seed(12345)

FuzzyImputation(matrix1NA,method = "miceRanger")


</code></pre>

<hr>
<h2 id='FuzzyNumbersToMatrix'>Conversion of a list of fuzzy numbers into a matrix.</h2><span id='topic+FuzzyNumbersToMatrix'></span>

<h3>Description</h3>

<p>'FuzzyNumbersToMatrix' converts a list of triangular or trapezoidal fuzzy numbers into a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FuzzyNumbersToMatrix(fuzzyList, trapezoidal = TRUE, varNames = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FuzzyNumbersToMatrix_+3A_fuzzylist">fuzzyList</code></td>
<td>
<p>Name of the list with fuzzy numbers.</p>
</td></tr>
<tr><td><code id="FuzzyNumbersToMatrix_+3A_trapezoidal">trapezoidal</code></td>
<td>
<p>Logical value depending on the type of fuzzy values (triangular or trapezoidal ones).</p>
</td></tr>
<tr><td><code id="FuzzyNumbersToMatrix_+3A_varnames">varNames</code></td>
<td>
<p>Optional names for columns of the output matrix.</p>
</td></tr>
<tr><td><code id="FuzzyNumbersToMatrix_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure converts the given list of triangular or trapezoidal fuzzy numbers into a matrix.
It is necessary to select the appropriate type of these fuzzy numbers (using <code>trapezoidal=FALSE</code> for
triangular fuzzy
numbers or the default <code>trapezoidal=TRUE</code> for trapezoidal ones)
The output matrix has 3 (for triangular fuzzy numbers)
or 4 (for trapezoidal ones) columns with the values of the left supports, cores (or the left and right ends of the cores for trapezoidal fuzzy 
cores) and right supports. 
Each row is related to single fuzzy number.
</p>


<h3>Value</h3>

<p>The output is given as a matrix with 3 (for triangular fuzzy numbers)
or 4 (for trapezoidal ones) columns and the number of rows is equal to number of fuzzy values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MatrixToFuzzyNumbers">MatrixToFuzzyNumbers</a></code> for conversion of a matrix to fuzzy numbers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# seed PRNG

set.seed(1234)

# load the necessary library

library(FuzzySimRes)

# generate sample of trapezoidal fuzzy numbers with FuzzySimRes library

list1&lt;-SimulateSample(20,originalPD="rnorm",parOriginalPD=list(mean=0,sd=1),
incrCorePD="rexp", parIncrCorePD=list(rate=2),
suppLeftPD="runif",parSuppLeftPD=list(min=0,max=0.6),
suppRightPD="runif", parSuppRightPD=list(min=0,max=0.6),
type="trapezoidal")

# check the first fuzzy number

list1$value[[1]]

# convert fuzzy numbers to a matrix and check the first value

head(FuzzyNumbersToMatrix(list1$value))


</code></pre>

<hr>
<h2 id='ImputationDimp'>DIMP (d-imputation) method for fuzzy numbers.</h2><span id='topic+ImputationDimp'></span>

<h3>Description</h3>

<p>'ImputationDimp' imputes (i.e., replaces missing values) fuzzy numbers using the DIMP (d-imputation) method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ImputationDimp(dataToImpute, trapezoidal = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ImputationDimp_+3A_datatoimpute">dataToImpute</code></td>
<td>
<p>Name of the input matrix (data frame or list) of fuzzy numbers with some NAs.</p>
</td></tr>
<tr><td><code id="ImputationDimp_+3A_trapezoidal">trapezoidal</code></td>
<td>
<p>Logical value depending on the type of fuzzy values (triangular or trapezoidal ones) in the dataset.</p>
</td></tr>
<tr><td><code id="ImputationDimp_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to other functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure randomly imputes missing values (NAs) with suitable data in the case of the dataset (or matrix, or list)
consisting of fuzzy numbers (triangular fuzzy numbers if <code>trapezoidal=FALSE</code> is set, or trapezoidal if the default
<code>trapezoidal=TRUE</code> is used).
The output is given as a matrix without NAs, where each row is related to fuzzy numbers (given by 3 values for the triangular fuzzy numbers,
or 4 values in the case of trapezoidal ones) for the consecutive variables.
Many fuzzy variables (not the only one) can be used. 
The input has to consist of fuzzy numbers of the same types (i.e., mixing triangular and trapezoidal fuzzy numbers is not allowed).
</p>


<h3>Value</h3>

<p>The output is given as a matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# seed PRNG

set.seed(1234)

# load the necessary library

library(FuzzySimRes)

# generate sample of trapezoidal fuzzy numbers with FuzzySimRes library

list1&lt;-SimulateSample(20,originalPD="rnorm",parOriginalPD=list(mean=0,sd=1),
incrCorePD="rexp", parIncrCorePD=list(rate=2),
suppLeftPD="runif",parSuppLeftPD=list(min=0,max=0.6),
suppRightPD="runif", parSuppRightPD=list(min=0,max=0.6),
type="trapezoidal")

# convert fuzzy data into a matrix

matrix1 &lt;- FuzzyNumbersToMatrix(list1$value)

# check starting values

head(matrix1)

# add some NAs to the matrix

matrix1NA &lt;- IntroducingNA(matrix1,percentage = 0.1)

head(matrix1NA)

# impute missing values

ImputationDimp(matrix1NA)


</code></pre>

<hr>
<h2 id='ImputationTests'>Battery of test for the imputed fuzzy values.</h2><span id='topic+ImputationTests'></span>

<h3>Description</h3>

<p>'ImputationTests' calculates various measures and applies goodness-of-fit statistical tests to
check the quality of the imputed fuzzy values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ImputationTests(
  trueData,
  imputedData,
  imputedMask,
  trapezoidal = TRUE,
  cutsNumber = 100,
  K = 50,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ImputationTests_+3A_truedata">trueData</code></td>
<td>
<p>Name of the input matrix (or data frame, or list) with the true values of the variables.</p>
</td></tr>
<tr><td><code id="ImputationTests_+3A_imputeddata">imputedData</code></td>
<td>
<p>Name of the input matrix (or data frame) with the imputed values.</p>
</td></tr>
<tr><td><code id="ImputationTests_+3A_imputedmask">imputedMask</code></td>
<td>
<p>Matrix (or data frame) with logical values where <code>TRUE</code> indicates the cells with the imputed values.</p>
</td></tr>
<tr><td><code id="ImputationTests_+3A_trapezoidal">trapezoidal</code></td>
<td>
<p>Logical value depending on the type of fuzzy values (triangular or trapezoidal ones) in the dataset.</p>
</td></tr>
<tr><td><code id="ImputationTests_+3A_cutsnumber">cutsNumber</code></td>
<td>
<p>Number of cuts for the epistemic bootstrap tests.</p>
</td></tr>
<tr><td><code id="ImputationTests_+3A_k">K</code></td>
<td>
<p>Value of <code>K</code> for the <code>res</code> epistemic test.</p>
</td></tr>
<tr><td><code id="ImputationTests_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure uses other functions embedded in this package to check the quality of the imputed fuzzy values if they
are compared with the original ones.
This procedure calculates number of non-FNs for each variable, error matrix (using <code>ErrorMatrix</code>), various statistical measures 
(with <code>StatisticalMeasures</code>), applies epistemic goodness-of-fit tests (using <code>ApplyStatisticalTests</code>), and evaluates the
fuzzy measures (with <code>CalculateFuzzyMeasures</code>).
Therefore, this function can be directly applied as one-click benchmark tool.
</p>
<p>To properly distinguish the real values with their imputed counterparts, the additional matrix <code>imputedMask</code> should be provided.
In this matrix, the logical value <code>TRUE</code> points out the cells with the imputed values.
Otherwise, <code>FALSE</code> should be used.
</p>
<p>All of the input datasets can be given as matrices or data frames.
</p>
<p>To get overall comparison of the methods, <code>summary(object,...)</code> can be used for the output object from this method.
The values <code>diff</code> are equal to the differences of p-values between the respective tests for the parts
<code>true</code> and <code>imputed</code> there.
</p>


<h3>Value</h3>

<p>The output is an S3 object of the class <code>impTest</code> given as a list of the matrices:
<code>trueValues</code> - the true, input values (the same as <code>trueData</code>),
<code>mask</code> - the masked (NAs) values (the same as <code>imputedMask</code>),
<code>nonFNNumbers</code> - the vector with the numbers of non-FNs samples for each variable (with the overall mean),
<code>errorMatrix</code> &ndash; the output from the function <code>ErrorMatrix</code>,
<code>statisticalMeasures</code> &ndash; the output from the function <code>StatisticalMeasures</code>, 
<code>statisticalTests</code> &ndash; the output from the function <code>ApplyStatisticalTests</code>, 
<code>fuzzyMeasures</code> &ndash; the output from the function <code>CalculateFuzzyMeasures</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MethodsComparison">MethodsComparison</a> for the imputation benchmark for all methods, <a href="#topic+summary.impTest">summary.impTest</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# seed PRNG

set.seed(1234)

# load the necessary library

library(FuzzySimRes)

# generate sample of trapezoidal fuzzy numbers with FuzzySimRes library

list1&lt;-SimulateSample(20,originalPD="rnorm",parOriginalPD=list(mean=0,sd=1),
incrCorePD="rexp", parIncrCorePD=list(rate=2),
suppLeftPD="runif",parSuppLeftPD=list(min=0,max=0.6),
suppRightPD="runif", parSuppRightPD=list(min=0,max=0.6),
type="trapezoidal")

# convert fuzzy data into a matrix

matrix1 &lt;- FuzzyNumbersToMatrix(list1$value)

# check starting values

head(matrix1)

# add some NAs to the matrix

matrix1NA &lt;- IntroducingNA(matrix1,percentage = 0.1)

head(matrix1NA)

# impute missing values

matrix1DImp &lt;- ImputationDimp(matrix1NA)

# find cells with NAs

matrix1Mask &lt;- is.na(matrix1NA)

# check the quality of the imputed values

ImputationTests(matrix1,matrix1DImp,matrix1Mask,trapezoidal=TRUE)



</code></pre>

<hr>
<h2 id='IntroducingNA'>Introducing NAs to the specified matrix.</h2><span id='topic+IntroducingNA'></span>

<h3>Description</h3>

<p>'IntroducingNA' introduces missing values (NAs) to the specified data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IntroducingNA(dataMatrix, percentage = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IntroducingNA_+3A_datamatrix">dataMatrix</code></td>
<td>
<p>Name of the input matrix (or list, or data frame).</p>
</td></tr>
<tr><td><code id="IntroducingNA_+3A_percentage">percentage</code></td>
<td>
<p>Desired percentage of missing values (NAs) in each row.</p>
</td></tr>
<tr><td><code id="IntroducingNA_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure changes randomly some values in the specified matrix to &quot;missing values&quot; (denoted by NA).
Number of these missing values in each row is given by the parameter <code>percentage</code>.
If the input is a list of fuzzy numbers or data frame, then it is automatically converted to a matrix.
</p>


<h3>Value</h3>

<p>The output is given as a matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# prepare matrix with 3 columns and 3 rows

matrix1 &lt;- matrix(c(1,3,5,2,5,7,1,4,5),ncol=3,byrow = TRUE)

# add 1 NA in each row

set.seed(12345)

IntroducingNA(matrix1,percentage = 0.33)


</code></pre>

<hr>
<h2 id='MatrixToFuzzyNumbers'>Conversion of a matrix to a list of fuzzy numbers.</h2><span id='topic+MatrixToFuzzyNumbers'></span>

<h3>Description</h3>

<p>'MatrixToFuzzyNumbers' converts a matrix into a list of triangular or trapezoidal fuzzy numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MatrixToFuzzyNumbers(fuzzyMatrix, varNames = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MatrixToFuzzyNumbers_+3A_fuzzymatrix">fuzzyMatrix</code></td>
<td>
<p>Name of the matrix with fuzzy numbers.</p>
</td></tr>
<tr><td><code id="MatrixToFuzzyNumbers_+3A_varnames">varNames</code></td>
<td>
<p>Optional names for values of the output list.</p>
</td></tr>
<tr><td><code id="MatrixToFuzzyNumbers_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure converts the given matrix to a list of triangular or trapezoidal fuzzy numbers.
If the input matrix has 3 columns, then they are treated as descriptions of consecutive triangular fuzzy
numbers.
In the case of 4 columns, we get trapezoidal fuzzy numbers.
The values in these columns are equal to
the left supports, cores (or left and right ends of the cores for trapezoidal fuzzy 
numbers) and right supports. 
Each row is related to single fuzzy number.
</p>


<h3>Value</h3>

<p>The output is given as a list of fuzzy numbers.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FuzzyNumbersToMatrix">FuzzyNumbersToMatrix</a></code> for conversion of a list of fuzzy numbers into a matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(FuzzyNumbers)

# prepare matrix with 2 triangular fuzzy numbers

matrix1 &lt;- matrix(c(1,3,5,2,5,7),ncol=3,byrow = TRUE)

# convert this matrix to list of fuzzy numbers

MatrixToFuzzyNumbers(matrix1)


</code></pre>

<hr>
<h2 id='MeasureAHD'>Function to calculate the AHD distance between two fuzzy numbers.</h2><span id='topic+MeasureAHD'></span>

<h3>Description</h3>

<p>'MeasureAHD' calculates the AHD (Area Hight Distance) measure between two trapezoidal or triangular fuzzy numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MeasureAHD(value1, value2, trapezoidal = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MeasureAHD_+3A_value1">value1</code></td>
<td>
<p>The first input triangular or trapezoidal fuzzy number.</p>
</td></tr>
<tr><td><code id="MeasureAHD_+3A_value2">value2</code></td>
<td>
<p>The second input triangular or trapezoidal fuzzy number.</p>
</td></tr>
<tr><td><code id="MeasureAHD_+3A_trapezoidal">trapezoidal</code></td>
<td>
<p>Logical value depending on the type of input fuzzy values (triangular or trapezoidal ones).</p>
</td></tr>
<tr><td><code id="MeasureAHD_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure calculates the AHD (Area Hight Distance) measure of the distance between two trapezoidal or triangular fuzzy numbers.
The input values can be given as triangular/trapezoidal fuzzy numbers using the objects defined in <code>FuzzyNumbers</code> package
or vectors with three (in the case of triangular fuzzy numbers) or four (for trapezoidal fuzzy numbers) values related to
left end of the support, the core (or its interval, respectively), and the right end of the support.
The parameter <code>trapezoidal</code> is used to indicate if the input values are trapezoidal fuzzy numbers or triangular ones.
</p>


<h3>Value</h3>

<p>The output is given as a numerical value.
</p>


<h3>References</h3>

<p>M. Amirfakhrian, S. Yeganehmanesh, and P. Grzegorzewski, “A new distance on fuzzy semi-numbers&quot;,
Soft Computing, vol. 22, no. 14, pp. 4511–4524, 2018
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MeasureHSD">MeasureHSD</a>, <a href="#topic+MeasureEuclidean">MeasureEuclidean</a></code> for other procedures to calculate distance measures.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# let's define two trapezoidal fuzzy numbers

tpfn1 &lt;- c(1,2,3,4)

tpfn2 &lt;- c(2,6,8,10)

# calculate the distance

MeasureAHD(tpfn1,tpfn2)

# now we use objects from the FuzzyNumbers package

# load the necessary library

library(FuzzyNumbers)

tpfn1 &lt;- TrapezoidalFuzzyNumber(1,2,3,4)

tpfn2 &lt;- TrapezoidalFuzzyNumber(2,6,8,10)

MeasureAHD(tpfn1,tpfn2)


</code></pre>

<hr>
<h2 id='MeasureEuclidean'>Function to calculate the Euclidean distance between two fuzzy numbers.</h2><span id='topic+MeasureEuclidean'></span>

<h3>Description</h3>

<p>'MeasureEuclidean' calculates the Euclidean measure between two trapezoidal or triangular fuzzy numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MeasureEuclidean(value1, value2, trapezoidal = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MeasureEuclidean_+3A_value1">value1</code></td>
<td>
<p>The first input triangular or trapezoidal fuzzy number.</p>
</td></tr>
<tr><td><code id="MeasureEuclidean_+3A_value2">value2</code></td>
<td>
<p>The second input triangular or trapezoidal fuzzy number.</p>
</td></tr>
<tr><td><code id="MeasureEuclidean_+3A_trapezoidal">trapezoidal</code></td>
<td>
<p>Logical value depending on the type of input fuzzy values (triangular or trapezoidal ones)</p>
</td></tr>
<tr><td><code id="MeasureEuclidean_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure calculates the Euclidean measure of the distance between two trapezoidal or triangular fuzzy numbers.
The input values can be given as triangular/trapezoidal fuzzy numbers using the objects defined in <code>FuzzyNumbers</code> package
or vectors with three (in the case of triangular fuzzy numbers) or four (for trapezoidal fuzzy numbers) values related to
left end of the support, the core (or its interval, respectively), and the right end of the support.
The parameter <code>trapezoidal</code> is used to indicate if the input values are trapezoidal fuzzy numbers or triangular ones.
</p>


<h3>Value</h3>

<p>The output is given as a numerical value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MeasureAHD">MeasureAHD</a>, <a href="#topic+MeasureHSD">MeasureHSD</a></code> for other procedures to calculate distance measures.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# let's define two trapezoidal fuzzy numbers

tpfn1 &lt;- c(1,2,3,4)

tpfn2 &lt;- c(2,6,8,10)

# calculate the distance

MeasureEuclidean(tpfn1,tpfn2)

# now we use objects from the FuzzyNumbers package

# load the necessary library

library(FuzzyNumbers)

tpfn1 &lt;- TrapezoidalFuzzyNumber(1,2,3,4)

tpfn2 &lt;- TrapezoidalFuzzyNumber(2,6,8,10)

MeasureEuclidean(tpfn1,tpfn2)


</code></pre>

<hr>
<h2 id='MeasureHSD'>Function to calculate the HSD distance between two fuzzy numbers.</h2><span id='topic+MeasureHSD'></span>

<h3>Description</h3>

<p>'MeasureHSD' calculates the HSD (Area Hight Distance) measure between two trapezoidal or triangular fuzzy numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MeasureHSD(value1, value2, trapezoidal = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MeasureHSD_+3A_value1">value1</code></td>
<td>
<p>The first input triangular or trapezoidal fuzzy number.</p>
</td></tr>
<tr><td><code id="MeasureHSD_+3A_value2">value2</code></td>
<td>
<p>The second input triangular or trapezoidal fuzzy number.</p>
</td></tr>
<tr><td><code id="MeasureHSD_+3A_trapezoidal">trapezoidal</code></td>
<td>
<p>Logical value depending on the type of input fuzzy values (triangular or trapezoidal ones).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure calculates the HSD (Hight Source Distance) measure of the distance between two trapezoidal or triangular fuzzy numbers.
The input values can be given as triangular/trapezoidal fuzzy numbers using the objects defined in <code>FuzzyNumbers</code> package
or vectors with three (in the case of triangular fuzzy numbers) or four (for trapezoidal fuzzy numbers) values related to
left end of the support, the core (or its interval, respectively), and the right end of the support.
The parameter <code>trapezoidal</code> is used to indicate if the input values are trapezoidal fuzzy numbers or triangular ones.
</p>


<h3>Value</h3>

<p>The output is given as a numerical value.
</p>


<h3>References</h3>

<p>S. Yeganehmanesh, M. Amirfakhrian, and P. Grzegorzewski, “Fuzzy semi-numbers and a distance on them with a case study in medicine,”
Mathematical Sciences, vol. 12, no. 1, pp. 41–52, 2018
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MeasureAHD">MeasureAHD</a>, <a href="#topic+MeasureEuclidean">MeasureEuclidean</a></code> for other procedures to calculate distance measures.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# let's define two trapezoidal fuzzy numbers

tpfn1 &lt;- c(1,2,3,4)

tpfn2 &lt;- c(2,6,8,10)

# calculate the distance

MeasureHSD(tpfn1,tpfn2)

# now we use objects from the FuzzyNumbers package

# load the necessary library

library(FuzzyNumbers)

tpfn1 &lt;- TrapezoidalFuzzyNumber(1,2,3,4)

tpfn2 &lt;- TrapezoidalFuzzyNumber(2,6,8,10)

MeasureHSD(tpfn1,tpfn2)


</code></pre>

<hr>
<h2 id='methodNames'>A vector containing names of the resampling methods.</h2><span id='topic+methodNames'></span>

<h3>Description</h3>

<p>'methodNames' is a vector containing names of the resampling methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>methodNames
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 4.
</p>


<h3>Value</h3>

<p>This function returns a vector of strings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# check the names

methodNames

</code></pre>

<hr>
<h2 id='MethodsComparison'>Comparison of imputation methods for fuzzy values.</h2><span id='topic+MethodsComparison'></span>

<h3>Description</h3>

<p>'MethodsComparison' compares the quality of built-in imputation methods using various measures and goodness-of-fit statistical tests
for the given fuzzy dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MethodsComparison(
  trueData,
  iterations = 100,
  percentage = 0.05,
  trapezoidal = TRUE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MethodsComparison_+3A_truedata">trueData</code></td>
<td>
<p>Name of the input matrix (or data frame) with the true values of the variables.</p>
</td></tr>
<tr><td><code id="MethodsComparison_+3A_iterations">iterations</code></td>
<td>
<p>Number of the repetitions of each analyses (introducing NAs and then imputation of the missing values).</p>
</td></tr>
<tr><td><code id="MethodsComparison_+3A_percentage">percentage</code></td>
<td>
<p>Desired percentage of missing values (NAs) in each row.</p>
</td></tr>
<tr><td><code id="MethodsComparison_+3A_trapezoidal">trapezoidal</code></td>
<td>
<p>Logical value depending on the type of fuzzy values (triangular or trapezoidal ones) in the dataset.</p>
</td></tr>
<tr><td><code id="MethodsComparison_+3A_verbose">verbose</code></td>
<td>
<p>Logical value if the progress bar should be shown.</p>
</td></tr>
<tr><td><code id="MethodsComparison_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure uses the function <code>ImputationTests</code> to compare the quality of the imputation methods for the specified fuzzy dataset.
To minimize random effects, each analysis is repeated <code>iterations</code> times with the new randomly generated NA values
in the input dataset, and then new imputed values for all built-in methods.
To generate the new NAs values, the function <code>IntroducingNA</code> is used.
Next, the results, the same as for<code>ImputationTests</code> (apart from <code>trueValues</code> and <code>mask</code>), are averaged.
</p>
<p>The input dataset can be given as matrix or data frame.
</p>
<p>To get overall comparison of the methods, <code>summary(object,...)</code> can be used for the output object from this method.
The values <code>diff</code> are equal to the differences of p-values between the respective tests for the parts
<code>true</code> and <code>imputed</code> there.
</p>


<h3>Value</h3>

<p>The output is an S3 object of the class <code>metComp</code> given as a list of the matrices: 
<code>nonFNNumbers</code> - the vector with the numbers of non-FNs samples for each variable (with the overall mean),
<code>errorMatrix</code> &ndash; the output from the function <code>ErrorMatrix</code>,
<code>statisticalMeasures</code> &ndash; the output from the function <code>StatisticalMeasures</code>, 
<code>statisticalTests</code> &ndash; the output from the function <code>ApplyStatisticalTests</code>, 
<code>fuzzyMeasures</code> &ndash; the output from the function <code>CalculateFuzzyMeasures</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ImputationTests">ImputationTests</a> for the single imputation benchmark, <a href="#topic+summary.metComp">summary.metComp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# seed PRNG

set.seed(1234)

# load the necessary library

library(FuzzySimRes)

# generate sample of trapezoidal fuzzy numbers with FuzzySimRes library

list1&lt;-SimulateSample(20,originalPD="rnorm",parOriginalPD=list(mean=0,sd=1),
incrCorePD="rexp", parIncrCorePD=list(rate=2),
suppLeftPD="runif",parSuppLeftPD=list(min=0,max=0.6),
suppRightPD="runif", parSuppRightPD=list(min=0,max=0.6),
type="trapezoidal")

# convert fuzzy data into a matrix

matrix1 &lt;- FuzzyNumbersToMatrix(list1$value)

# check starting values

head(matrix1)


# check the quality of the imputed values

## Not run: 

MethodsComparison(matrix1,iterations=10,trapezoidal=TRUE)


## End(Not run)

</code></pre>

<hr>
<h2 id='RemoveNotFuzzy'>Removing values that are not fuzzy numbers.</h2><span id='topic+RemoveNotFuzzy'></span>

<h3>Description</h3>

<p>'RemoveNotFuzzy' removes all values that are not proper fuzzy numbers and restores the previous ones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RemoveNotFuzzy(trueData, imputedData, trapezoidal = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RemoveNotFuzzy_+3A_truedata">trueData</code></td>
<td>
<p>Name of the input matrix (data frame(or data frame)) that is used to restore erroneous fuzzy numbers.</p>
</td></tr>
<tr><td><code id="RemoveNotFuzzy_+3A_imputeddata">imputedData</code></td>
<td>
<p>Name of the input matrix (data frame) with fuzzy numbers to check their correctness.</p>
</td></tr>
<tr><td><code id="RemoveNotFuzzy_+3A_trapezoidal">trapezoidal</code></td>
<td>
<p>Logical value depending on the type of fuzzy values (triangular or trapezoidal ones) in the dataset.</p>
</td></tr>
<tr><td><code id="RemoveNotFuzzy_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure checks all the values in the given matrix (or data frame) specified by <code>imputedData</code>
and if some of them are not proper fuzzy numbers (e.g., their cores are outside the supports), they are removed.
Instead of these erroneous values, the previous ones from the input matrix (a data frame, or a list) <code>trueData</code> are restored.
These matrices (or data frames) should consist of fuzzy numbers (triangular fuzzy numbers if <code>trapezoidal=FALSE</code> is set,
or trapezoidal ones if the default <code>trapezoidal=TRUE</code> is used).
The output is given as a matrix where each row is related to fuzzy numbers (with 3 values for the triangular fuzzy numbers,
or 4 values in the case of trapezoidal ones) for the consecutive variables.
The input has to consist of fuzzy numbers of the same type (i.e., mixing triangular and trapezoidal fuzzy numbers is not allowed).
</p>


<h3>Value</h3>

<p>The output is given as a matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# matrix with proper values of triangular fuzzy numbers

matrixOK &lt;- matrix(c(1,2,3,7,10,12,8,10,11),ncol=3,byrow = TRUE)

# matrix with the wrong third value of fuzzy triangular number (its core is greater than
# the left end of its support) 

matrixFalse &lt;- matrix(c(1,2,3,7,10,12,8,20,11),ncol=3,byrow = TRUE)

# remove the third value and restore the previous one

RemoveNotFuzzy(matrixOK,matrixFalse,trapezoidal = FALSE)


</code></pre>

<hr>
<h2 id='StatisticalMeasures'>Calculation of statistical measures for errors of the imputed data.</h2><span id='topic+StatisticalMeasures'></span>

<h3>Description</h3>

<p><code>StatisticalMeasures</code> calculates various statistical measures between the real and imputed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StatisticalMeasures(trueData, imputedData, imputedMask, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="StatisticalMeasures_+3A_truedata">trueData</code></td>
<td>
<p>Name of the input matrix (or data frame) with the true values of the variables.</p>
</td></tr>
<tr><td><code id="StatisticalMeasures_+3A_imputeddata">imputedData</code></td>
<td>
<p>Name of the input matrix (or data frame) with the imputed values.</p>
</td></tr>
<tr><td><code id="StatisticalMeasures_+3A_imputedmask">imputedMask</code></td>
<td>
<p>Matrix (or data frame) with logical values where <code>TRUE</code> indicates the cells with the imputed values.</p>
</td></tr>
<tr><td><code id="StatisticalMeasures_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure calculates different statistical measures between the real and
imputed data for each column, namely:
</p>

<ul>
<li><p> TrueMean - the mean only for the real but missing data,
</p>
</li>
<li><p> ImpMean - the mean only for the imputed values,
</p>
</li>
<li><p> TrueSD - the standard deviation only for the real but missing data,
</p>
</li>
<li><p> ImpSD - the standard deviation only for the imputed values,
</p>
</li>
<li><p> GenMean - the mean for the all real data (given by <code>trueData</code>),
</p>
</li>
<li><p> GenImpMean - the mean for real data with the respectively imputed values (given by <code>imputedData</code>),
</p>
</li>
<li><p> GenSD - the standard deviation for the all real data (given by <code>trueData</code>),
</p>
</li>
<li><p> GenImpSD - the standard deviation for real data with the respectively imputed values (given by <code>imputedData</code>),
</p>
</li>
<li><p> AbsDiffTrueImpMean - the absolute difference between TrueMean and ImpMean,
</p>
</li>
<li><p> AbsDiffTrueImpSD - the absolute difference between TrueSD and ImSD,
</p>
</li>
<li><p> AbsDiffGenImpMean - the absolute difference between GenMean and GenImpMean,
</p>
</li>
<li><p> AbsDiffGenImpSD - the absolute difference between GenSD and GenImpSD.
</p>
</li></ul>

<p>To properly distinguish the real values with their imputed counterparts, the additional matrix <code>imputedMask</code> should be provided.
In this matrix, the logical value <code>TRUE</code> points out the cells with the imputed values.
Otherwise, <code>FALSE</code> should be used. These input datasets should be given as matrices
or data frames.
</p>


<h3>Value</h3>

<p>The output is given as a matrix with columns related to all columns of the input dataset plus the overall mean.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# seed PRNG

set.seed(1234)

# load the necessary library

library(FuzzySimRes)

# generate sample of trapezoidal fuzzy numbers with FuzzySimRes library

list1&lt;-SimulateSample(20,originalPD="rnorm",parOriginalPD=list(mean=0,sd=1),
incrCorePD="rexp", parIncrCorePD=list(rate=2),
suppLeftPD="runif",parSuppLeftPD=list(min=0,max=0.6),
suppRightPD="runif", parSuppRightPD=list(min=0,max=0.6),
type="trapezoidal")

# convert fuzzy data into a matrix

matrix1 &lt;- FuzzyNumbersToMatrix(list1$value)

# check starting values

head(matrix1)

# add some NAs to the matrix

matrix1NA &lt;- IntroducingNA(matrix1,percentage = 0.1)

head(matrix1NA)

# impute missing values

matrix1DImp &lt;- ImputationDimp(matrix1NA)

# find cells with NAs

matrix1Mask &lt;- is.na(matrix1NA)

# calculate errors for the imputed values

StatisticalMeasures(matrix1,matrix1DImp,matrix1Mask)


</code></pre>

<hr>
<h2 id='summary.impTest'>Print summary of the benchmark for the imputation method.</h2><span id='topic+summary.impTest'></span>

<h3>Description</h3>

<p>Print summary of the benchmark for the imputation method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'impTest'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.impTest_+3A_object">object</code></td>
<td>
<p>Object of S3 class <code>impTest</code>.</p>
</td></tr>
<tr><td><code id="summary.impTest_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to other functions.</p>
</td></tr>
</table>

<hr>
<h2 id='summary.metComp'>Print summary of the comparison of the imputation methods.</h2><span id='topic+summary.metComp'></span>

<h3>Description</h3>

<p>Print summary of the comparison of the imputation methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'metComp'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.metComp_+3A_object">object</code></td>
<td>
<p>Object of S3 class <code>metComp</code>.</p>
</td></tr>
<tr><td><code id="summary.metComp_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to other functions.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
