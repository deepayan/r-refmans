<!DOCTYPE html><html lang="en"><head><title>Help for package fuseMLR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fuseMLR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bestLayerLearner'><p>The best layer-specific model is used as meta model.</p></a></li>
<li><a href='#cobra'><p>Cobra Meta Learner</p></a></li>
<li><a href='#createCobraPred'><p>Create COBRA Predictions</p></a></li>
<li><a href='#createDif'><p>Create Difference</p></a></li>
<li><a href='#createLoss'><p>Create Loss</p></a></li>
<li><a href='#createTesting'><p>createTesting</p></a></li>
<li><a href='#createTestLayer'><p>createTestLayer</p></a></li>
<li><a href='#createTraining'><p>createTraining</p></a></li>
<li><a href='#createTrainLayer'><p>createTrainLayer</p></a></li>
<li><a href='#createTrainMetaLayer'><p>createTrainMetaLayer</p></a></li>
<li><a href='#createWeights'><p>Create weights for COBRA Predictions</p></a></li>
<li><a href='#Data'><p>Abstract class Data</p></a></li>
<li><a href='#extractData'><p>extractData</p></a></li>
<li><a href='#extractModel'><p>extractModel</p></a></li>
<li><a href='#fusemlr'><p>fusemlr</p></a></li>
<li><a href='#HashTable'><p>Class HashTable</p></a></li>
<li><a href='#Lrner'><p>Lrner Class</p></a></li>
<li><a href='#Model'><p>Model Class</p></a></li>
<li><a href='#multi_omics'><p>Simulated multiomics data for 70 training participants and 23 testing participants,</p>
each with an effect size of 20 on each layer. Each layer includes 50 participants for
training and 20 for testing. Participants do not perfectly overlap across layers.
The simulation is based on the R package <code>interSIM</code>.</a></li>
<li><a href='#predict.bestLayerLearner'><p>Best specific Learner prediction.</p></a></li>
<li><a href='#predict.cobra'><p>Predict Using COBRA object</p></a></li>
<li><a href='#predict.Training'><p>predict.Training</p></a></li>
<li><a href='#predict.weightedMeanLearner'><p>Weighted mean prediction.</p></a></li>
<li><a href='#PredictData'><p>PredictData Class</p></a></li>
<li><a href='#Predicting'><p>Predicting Class</p></a></li>
<li><a href='#PredictLayer'><p>PredictLayer Class</p></a></li>
<li><a href='#PredictMetaLayer'><p>PredictMetaLayer Class</p></a></li>
<li><a href='#summary.Testing'><p>Testing object Summaries</p></a></li>
<li><a href='#summary.Training'><p>Training object Summaries</p></a></li>
<li><a href='#Target'><p>Target Class</p></a></li>
<li><a href='#TestData'><p>TestData Class</p></a></li>
<li><a href='#Testing'><p>Testing Class</p></a></li>
<li><a href='#TestLayer'><p>TestLayer Class</p></a></li>
<li><a href='#TestMetaLayer'><p>TestMetaLayer Class</p></a></li>
<li><a href='#TrainData'><p>TrainData Class</p></a></li>
<li><a href='#Training'><p>Training Class</p></a></li>
<li><a href='#TrainLayer'><p>TrainLayer Class</p></a></li>
<li><a href='#TrainMetaLayer'><p>TrainMetaLayer Class</p></a></li>
<li><a href='#upsetplot'><p>upsetplot</p></a></li>
<li><a href='#VarSel'><p>Varsel Class</p></a></li>
<li><a href='#varSelection'><p>varSelection</p></a></li>
<li><a href='#weightedMeanLearner'><p>The weighted mean meta-learner</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fusing Machine Learning in R</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Cesaire J. K. Fouodo &lt;cesaire.kuetefouodo@uni-luebeck.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Recent technological advances have enable the simultaneous collection
    of multi-omics data i.e., different types or modalities of molecular data, 
    presenting challenges for integrative prediction modeling due to the heterogeneous,
    high-dimensional nature and possible missing modalities of some individuals. 
    We introduce this package for late integrative prediction modeling, enabling 
    modality-specific variable selection and prediction modeling, followed by the 
    aggregation of the modality-specific predictions to train a final meta-model. 
    This package facilitates conducting late integration predictive modeling in a 
    systematic, structured, and reproducible way.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6, stats, digest</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), UpSetR (&ge; 1.4.0), caret, ranger,
glmnet, Boruta, knitr, rmarkdown, pROC, checkmate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Collate:</td>
<td>'Data.R' 'HashTable.R' 'Lrner.R' 'Model.R' 'PredictData.R'
'PredictLayer.R' 'PredictMetaLayer.R' 'Predicting.R' 'Target.R'
'TestData.R' 'TestLayer.R' 'TestMetaLayer.R' 'Testing.R'
'TrainData.R' 'TrainLayer.R' 'TrainMetaLayer.R' 'Training.R'
'VarSel.R' 'bestLayerLearner.R' 'cobra.R' 'createCobraPred.R'
'createDif.R' 'createLoss.R' 'createWeights.R' 'multi_omics.R'
'predict.bestLayerLearner.R' 'predict.cobra.R'
'weightedMeanLearner.R' 'predict.weightedMeanLearner.R'
'testingFunctions.R' 'trainingFunctions.R'</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/imbs-hl/fuseMLR/issues">https://github.com/imbs-hl/fuseMLR/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-15 04:36:16 UTC; fouodo</td>
</tr>
<tr>
<td>Author:</td>
<td>Cesaire J. K. Fouodo [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-17 09:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bestLayerLearner'>The best layer-specific model is used as meta model.</h2><span id='topic+bestLayerLearner'></span>

<h3>Description</h3>

<p>The meta learner is the best layer-specific learner. This function is intended to be (internally) used as meta-learner in fuseMLR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bestLayerLearner(x, y, perf = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bestLayerLearner_+3A_x">x</code></td>
<td>
<p><code>data.frame</code> <br />
<code>data.frame</code> of predictors.</p>
</td></tr>
<tr><td><code id="bestLayerLearner_+3A_y">y</code></td>
<td>
<p><code>vector</code> <br />
True target observations. Either binary or two level factor variable.</p>
</td></tr>
<tr><td><code id="bestLayerLearner_+3A_perf">perf</code></td>
<td>
<p><code>function</code> <br />
Function to compute layer-specific performance of learners. If NULL, the Brier Score (classification) or a mean squared error (regression) is used by default as performance measure.
Otherwise, the performance function must accept two parameters: <code>observed</code> (observed values) and <code>predicted</code> (predicted values).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A model object of class <code>weightedMeanLeaner</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(20240624L)
x = data.frame(x1 = runif(n = 50L, min = 0, max = 1))
y = sample(x = 0L:1L, size = 50L, replace = TRUE)
my_best_model = bestLayerLearner(x = x, y = y)
</code></pre>

<hr>
<h2 id='cobra'>Cobra Meta Learner</h2><span id='topic+cobra'></span>

<h3>Description</h3>

<p>The function <code>cobra</code> implements the COBRA (COmBined Regression Alternative),
an aggregation method for combining predictions from multiple individual learners.
This method aims to tune key parameters for achieving optimal predictions
by averaging the target values of similar candidates in the training dataset's predictions.
Only the training points that are sufficiently similar to the test point
(based on the proximity threshold <code>epsilon</code>) are used for prediction.
If no suitable training points are found, the function returns <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cobra(x, y, tune = "epsilon", k_folds = NULL, eps = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cobra_+3A_x">x</code></td>
<td>
<p><code>data.frame</code> <br />
A training data, where rows are observations and
columns are predictions from individual learners. Use <code>NA</code> for missing predictions.</p>
</td></tr>
<tr><td><code id="cobra_+3A_y">y</code></td>
<td>
<p><code>vector</code> <br />
A vector containing the training targets. This can be a binary or two-level factor variable.</p>
</td></tr>
<tr><td><code id="cobra_+3A_tune">tune</code></td>
<td>
<p><code>character</code> <br />
A character value specifying the tuning mode:
</p>

<ul>
<li> <p><code>"alpha_epsilon"</code>: Tunes both <code>alpha</code> (number of learners) and <code>epsilon</code> (proximity threshold) via cross-validation.
</p>
</li>
<li> <p><code>"epsilon"</code>: Tunes <code>epsilon</code> only via cross-validation.
</p>
</li>
<li> <p><code>"user"</code>: No tuning; the user provides an optimal <code>epsilon</code>.
#' The default value is <code>epsilon</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="cobra_+3A_k_folds">k_folds</code></td>
<td>
<p><code>integer</code> <br />
Number of folds for cross-validation when <code>tune = "alpha_epsilon"</code> or <code>"epsilon"</code>.
Default is <code>10</code>.</p>
</td></tr>
<tr><td><code id="cobra_+3A_eps">eps</code></td>
<td>
<p><code>numeric</code> <br />
A numeric value for the proximity threshold, used only when <code>tune = "user"</code>.
Defaults to <code>0.1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>cobra</code> containing the training data, target values, and chosen parameters.
</p>


<h3>References</h3>

<p>Biau, G., Fischer, A., Guedj, B., &amp; Malley, J. D. (2014). COBRA: A combined regression strategy. The Journal of Multivariate Analysis 46:18-28
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage
set.seed(123)
x_train &lt;- data.frame(a = runif(10L), b = runif(10L))
y_train &lt;- sample(0L:1L, size = 10L, replace = TRUE)

# Train the model with epsilon optimization
cobra_model &lt;- cobra(x = x_train, y = y_train, tune = "epsilon", k_folds = 2)

# Make predictions on new data
set.seed(156)
x_new &lt;- data.frame(a = runif(5L), b = runif(5L))
prediction &lt;- predict(object = cobra_model, data = x_new)

</code></pre>

<hr>
<h2 id='createCobraPred'>Create COBRA Predictions</h2><span id='topic+createCobraPred'></span>

<h3>Description</h3>

<p>The <code>createCobraPred</code> function calculates predictions by averaging the target
values of all the nearest candidates in the training dataset. Only the
training points that are within the specified proximity (<code>eps</code>) to the test
point are used to determine the prediction. If no suitable training points
are found, the function returns <code>NA</code> as the prediction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createCobraPred(
  train,
  test,
  n_train,
  n_test,
  nlearners,
  eps,
  alpha,
  train_target
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createCobraPred_+3A_train">train</code></td>
<td>
<p>A <code>matrix</code> representing the training data. Rows represent observations,
and columns contain predictions from individual learners for these observations.
In cases where a prediction is unavailable for a specific observation, <code>NA</code> is used.</p>
</td></tr>
<tr><td><code id="createCobraPred_+3A_test">test</code></td>
<td>
<p>A <code>matrix</code> representing the test data. Rows represent observations,
and columns contain predictions from individual learners for these observations.
In cases where a prediction is unavailable for a specific observation, <code>NA</code> is used.</p>
</td></tr>
<tr><td><code id="createCobraPred_+3A_n_train">n_train</code></td>
<td>
<p>An <code>integer</code> specifying the number of training observations.</p>
</td></tr>
<tr><td><code id="createCobraPred_+3A_n_test">n_test</code></td>
<td>
<p>An <code>integer</code> specifying the number of test observations.</p>
</td></tr>
<tr><td><code id="createCobraPred_+3A_nlearners">nlearners</code></td>
<td>
<p>An <code>integer</code> representing the number of learners.</p>
</td></tr>
<tr><td><code id="createCobraPred_+3A_eps">eps</code></td>
<td>
<p>A <code>numeric</code> value representing the threshold for proximity between two predictions.</p>
</td></tr>
<tr><td><code id="createCobraPred_+3A_alpha">alpha</code></td>
<td>
<p>A value that determines the optimal number of learners in the neighborhood (only for alpha optimization).</p>
</td></tr>
<tr><td><code id="createCobraPred_+3A_train_target">train_target</code></td>
<td>
<p>A <code>vector</code> containing the target values for the training dataset</p>
</td></tr>
</table>

<hr>
<h2 id='createDif'>Create Difference</h2><span id='topic+createDif'></span>

<h3>Description</h3>

<p>The <code>createDif</code> function computes the difference between the maximum and minimum predictions in a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createDif(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createDif_+3A_x">x</code></td>
<td>
<p>Predictions vector</p>
</td></tr>
</table>

<hr>
<h2 id='createLoss'>Create Loss</h2><span id='topic+createLoss'></span>

<h3>Description</h3>

<p>Create Loss
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createLoss(pred, target)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createLoss_+3A_pred">pred</code></td>
<td>
<p>A <code>vector</code> of predictions.</p>
</td></tr>
<tr><td><code id="createLoss_+3A_target">target</code></td>
<td>
<p>A <code>vector</code> of target values.</p>
</td></tr>
</table>

<hr>
<h2 id='createTesting'>createTesting</h2><span id='topic+createTesting'></span>

<h3>Description</h3>

<p>Creates a <a href="#topic+Testing">Testing</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createTesting(id, ind_col, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createTesting_+3A_id">id</code></td>
<td>
<p><code>character</code> <br />
Testing id.</p>
</td></tr>
<tr><td><code id="createTesting_+3A_ind_col">ind_col</code></td>
<td>
<p><code>character</code> <br />
Name of column of individuals IDs in testing <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="createTesting_+3A_verbose">verbose</code></td>
<td>
<p><code>boolean</code> <br />
Warning messages will be displayed if set to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+Testing">Testing</a> object.
</p>

<hr>
<h2 id='createTestLayer'>createTestLayer</h2><span id='topic+createTestLayer'></span>

<h3>Description</h3>

<p>Creates and stores a <a href="#topic+TestLayer">TestLayer</a> on the <a href="#topic+Testing">Testing</a> object passed as argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createTestLayer(testing, test_layer_id, test_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createTestLayer_+3A_testing">testing</code></td>
<td>
<p><code>Testing</code> <br />
Testing object where the created layer will be stored.</p>
</td></tr>
<tr><td><code id="createTestLayer_+3A_test_layer_id">test_layer_id</code></td>
<td>
<p><code>character</code> <br />
ID of the testing layer to be created.</p>
</td></tr>
<tr><td><code id="createTestLayer_+3A_test_data">test_data</code></td>
<td>
<p><code>data.frame</code> <br />
Data modality to be stored in <a href="#topic+TestData">TestData</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <a href="#topic+Testing">Testing</a> object (with the new layer) is returned.
</p>

<hr>
<h2 id='createTraining'>createTraining</h2><span id='topic+createTraining'></span>

<h3>Description</h3>

<p>Creates a <a href="#topic+Training">Training</a> object. A training object is designed to encapsulate training layers
and training meta-layer. Functions <a href="#topic+createTrainLayer">createTrainLayer</a> and <a href="#topic+createTrainMetaLayer">createTrainMetaLayer</a> are available
to add the training layer and the training meta-layer to a training object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createTraining(
  id,
  target_df,
  ind_col,
  target,
  problem_type = "classification",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createTraining_+3A_id">id</code></td>
<td>
<p><code>character</code> <br />
Training's ID.</p>
</td></tr>
<tr><td><code id="createTraining_+3A_target_df">target_df</code></td>
<td>
<p><code>data.frame</code> <br />
Observed target values. A data frame with two columns: individual IDs and response variable values.</p>
</td></tr>
<tr><td><code id="createTraining_+3A_ind_col">ind_col</code></td>
<td>
<p><code>character</code> <br />
Name of column of individuals IDs.</p>
</td></tr>
<tr><td><code id="createTraining_+3A_target">target</code></td>
<td>
<p><code>character</code> <br />
Name of the target variable.</p>
</td></tr>
<tr><td><code id="createTraining_+3A_problem_type">problem_type</code></td>
<td>
<p><code>character</code> <br />
Either &quot;classification&quot; or &quot;regression&quot;.</p>
</td></tr>
<tr><td><code id="createTraining_+3A_verbose">verbose</code></td>
<td>
<p><code>boolean</code> <br />
Warning and processing information (including those of cross-validation) will be displayed if set to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The created <a href="#topic+Training">Training</a> object is returned.
</p>


<h3>See Also</h3>

<p><a href="#topic+createTrainLayer">createTrainLayer</a>, <a href="#topic+createTrainMetaLayer">createTrainMetaLayer</a> and <a href="#topic+fusemlr">fusemlr</a>.
</p>

<hr>
<h2 id='createTrainLayer'>createTrainLayer</h2><span id='topic+createTrainLayer'></span>

<h3>Description</h3>

<p>Creates and stores a <a href="#topic+TrainLayer">TrainLayer</a> on the <a href="#topic+Training">Training</a> object passed as argument.
The main components of a training layer are training data modality, a variable
selection methods, and a modality-specific learner.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createTrainLayer(
  training,
  train_layer_id,
  train_data,
  varsel_package = NULL,
  varsel_fct = NULL,
  varsel_param = list(),
  lrner_package = NULL,
  lrn_fct,
  param_train_list = list(),
  param_pred_list = list(),
  na_action = "na.rm",
  x_varsel = "x",
  y_varsel = "y",
  x_lrn = "x",
  y_lrn = "y",
  object = "object",
  data = "data",
  extract_pred_fct = NULL,
  extract_var_fct = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createTrainLayer_+3A_training">training</code></td>
<td>
<p><code>Training</code> <br />
Training object for storing the created layer.</p>
</td></tr>
<tr><td><code id="createTrainLayer_+3A_train_layer_id">train_layer_id</code></td>
<td>
<p><code>character</code> <br />
ID of the <a href="#topic+TrainLayer">TrainLayer</a> to be created.</p>
</td></tr>
<tr><td><code id="createTrainLayer_+3A_train_data">train_data</code></td>
<td>
<p><code>data.frame</code> <br />
Data modality to be stored on the layer.</p>
</td></tr>
<tr><td><code id="createTrainLayer_+3A_varsel_package">varsel_package</code></td>
<td>
<p><code>character</code> <br />
Package name containing the variable selection algorithm function.
Defaults to <code>NULL</code> if the function exists in the current working environment.<br /></p>
</td></tr>
<tr><td><code id="createTrainLayer_+3A_varsel_fct">varsel_fct</code></td>
<td>
<p><code>character</code> <br />
Variable selection function name. Default value is <code>NULL</code> for no variable selection.
If specified, the function must accept at least two parameters: <code>x</code> (predictors)
and <code>y</code> (response values), and return a vector of selected variables.
Alternatively, use the interface parameters <code>x_varsel</code> and <code>y_varsel</code> to map
the original argument names, and <code>extract_var_fct</code> to specify how to extract
the vector of selected variables. An exception is made for the <code>Boruta</code> function,
which includes an internal adjustment and requires no additional modifications.</p>
</td></tr>
<tr><td><code id="createTrainLayer_+3A_varsel_param">varsel_param</code></td>
<td>
<p><code>list</code> <br />
List of arguments to be passed to <code>varsel_fct</code>.</p>
</td></tr>
<tr><td><code id="createTrainLayer_+3A_lrner_package">lrner_package</code></td>
<td>
<p><code>character</code> <br />
Name of the package containing the learning algorithm function. Defaults to
<code>NULL</code> if the function is available in the current working environment.</p>
</td></tr>
<tr><td><code id="createTrainLayer_+3A_lrn_fct">lrn_fct</code></td>
<td>
<p><code>character</code> <br />
Name of the learning function. The function must accept at least two parameters:
<code>x</code> (predictors) and <code>y</code> (response values) and return a model. Alternatively,
use the interface parameters <code>x_lrn</code> and <code>y_lrn</code> to map these names to the
original arguments in your function.
The returned model must support the generic <code>predict</code> function (with arguments
<code>object</code> and <code>data</code>) to generate predictions for new data. Predictions should
be either a vector or a <code>list</code> containing a vector named <code>predictions</code> with
the predicted values.<br />
If the arguments <code>object</code> and <code>data</code> have different names in your <code>predict</code>
function, use the interface parameters below to map them to the original names.
Additionally, if predictions are stored as a <code>matrix</code> or <code>data.frame</code>
(e.g., predicted probabilities for dichotomous classification), only the second
column (assumed to be class <code>1</code> probabilities) will be used.
If the predicted values are not returned in one of the formats mentioned above,
use the <code>extract_pred_fct</code> argument below to specify how to extract the predicted
values from the prediction object.</p>
</td></tr>
<tr><td><code id="createTrainLayer_+3A_param_train_list">param_train_list</code></td>
<td>
<p><code>character</code> <br />
List of arguments to be passed to <code>lrn_fct</code>.</p>
</td></tr>
<tr><td><code id="createTrainLayer_+3A_param_pred_list">param_pred_list</code></td>
<td>
<p><code>character</code> <br />
List of arguments to be passed to <code>predict</code> when generating predictions.</p>
</td></tr>
<tr><td><code id="createTrainLayer_+3A_na_action">na_action</code></td>
<td>
<p><code>character</code><br />
Handling of missing values in data during training. Set to <code>"na.keep"</code> to retain
missing values, or <code>"na.rm"</code> to remove instances with missing values.</p>
</td></tr>
<tr><td><code id="createTrainLayer_+3A_x_varsel">x_varsel</code></td>
<td>
<p><code>character</code> <br />
If the name of the argument used by the provided original variable selection function to pass
the matrix of independent variable is not <code>x</code>, use this argument to specify how it is called in the provided function.</p>
</td></tr>
<tr><td><code id="createTrainLayer_+3A_y_varsel">y_varsel</code></td>
<td>
<p><code>character</code> <br />
If the name of the argument used by the provided original variable selection function to pass
the target variable is not <code>y</code>, use this argument to specify how it is called in the provided function.</p>
</td></tr>
<tr><td><code id="createTrainLayer_+3A_x_lrn">x_lrn</code></td>
<td>
<p><code>character</code> <br />
If the name of the argument used by the provided original learning function to pass
the matrix of independent variable is not <code>x</code>, use this argument to specify how it is called in the provided function.</p>
</td></tr>
<tr><td><code id="createTrainLayer_+3A_y_lrn">y_lrn</code></td>
<td>
<p><code>character</code> <br />
If the name of the argument used by the provided original learning function to pass
the target variable is not <code>y</code>, use this argument to specify how it is called in the provided function.</p>
</td></tr>
<tr><td><code id="createTrainLayer_+3A_object">object</code></td>
<td>
<p><code>character</code> <br />
The generic function <code>predict</code> uses the parameter <code>object</code> to pass a model.
If the corresponding argument is named differently in your <code>predict</code> function, specify its name.</p>
</td></tr>
<tr><td><code id="createTrainLayer_+3A_data">data</code></td>
<td>
<p><code>character</code> <br />
The generic function <code>predict</code> uses a parameter <code>data</code> to pass new data.
If the corresponding argument is named differently in your predict function, specify the name.</p>
</td></tr>
<tr><td><code id="createTrainLayer_+3A_extract_pred_fct">extract_pred_fct</code></td>
<td>
<p><code style="white-space: pre;">&#8288;character or function&#8288;</code> <br />
If the <code>predict</code> function called for the model does not return a vector,
use this argument to specify a function (or the name of a function) to extract
the vector of predictions. The default value is <code>NULL</code> if predictions are returned as a vector.</p>
</td></tr>
<tr><td><code id="createTrainLayer_+3A_extract_var_fct">extract_var_fct</code></td>
<td>
<p><code style="white-space: pre;">&#8288;character or function&#8288;</code> <br />
If the variable selection function does not return a vector, use this argument
to specify a function (or the name of a function) to extract the vector of selected variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <a href="#topic+Training">Training</a> object (with the new layer) is returned.
</p>


<h3>References</h3>

<p>Fouodo C.J.K, Bleskina M. and Szymczak S. (2024). fuseMLR: An R package for integrative prediction modeling of multi-omics data, paper submitted.
</p>


<h3>See Also</h3>

<p><a href="#topic+createTrainMetaLayer">createTrainMetaLayer</a> and <a href="#topic+fusemlr">fusemlr</a>.
</p>

<hr>
<h2 id='createTrainMetaLayer'>createTrainMetaLayer</h2><span id='topic+createTrainMetaLayer'></span>

<h3>Description</h3>

<p>Creates and store a <a href="#topic+TrainMetaLayer">TrainMetaLayer</a> on the <a href="#topic+Training">Training</a> object passed as argument.
The meta-layer encapsulates the meta-learner and the fold predictions (internally created) of the layer-specific
base models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createTrainMetaLayer(
  training,
  meta_layer_id,
  lrner_package = NULL,
  lrn_fct,
  param_train_list = list(),
  param_pred_list = list(),
  na_action = "na.impute",
  x_lrn = "x",
  y_lrn = "y",
  object = "object",
  data = "data",
  extract_pred_fct = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createTrainMetaLayer_+3A_training">training</code></td>
<td>
<p><code>Training</code> <br />
Training object for storing the created meta-layer.</p>
</td></tr>
<tr><td><code id="createTrainMetaLayer_+3A_meta_layer_id">meta_layer_id</code></td>
<td>
<p><code>character</code> <br />
ID of the layer to be created.</p>
</td></tr>
<tr><td><code id="createTrainMetaLayer_+3A_lrner_package">lrner_package</code></td>
<td>
<p><code>character</code> <br />
Package name containing the variable selection algorithm function.
Defaults to <code>NULL</code> if the function exists in the current working environment.</p>
</td></tr>
<tr><td><code id="createTrainMetaLayer_+3A_lrn_fct">lrn_fct</code></td>
<td>
<p><code>character</code> <br />
Name of the learning function. The function must accept at least two
parameters: <code>x</code> (predictors) and <code>y</code> (response values), and return a model.
If not, use the interface parameters <code>x_lrn</code> and <code>y_lrn</code> below to map these
argument names to the original arguments in your function. The returned model
must support the generic <code>predict</code> function (with arguments <code>object</code> and <code>data</code>)
to make predictions for new data, and the predictions should be a vector or
a <code>list</code> containing a vector called <code>predictions</code> with the predicted values.
If the arguments <code>object</code> and <code>data</code> are named differently in your predict
function, use the interface parameters <code>object</code> and <code>data</code> below to specify
the original names. See the details below about meta-learners.</p>
</td></tr>
<tr><td><code id="createTrainMetaLayer_+3A_param_train_list">param_train_list</code></td>
<td>
<p><code>character</code> <br />
List of arguments to be passed to <code>lrn_fct</code>.</p>
</td></tr>
<tr><td><code id="createTrainMetaLayer_+3A_param_pred_list">param_pred_list</code></td>
<td>
<p><code>list</code> <br />
List of arguments to be passed to <code>predict</code> when computing predictions.</p>
</td></tr>
<tr><td><code id="createTrainMetaLayer_+3A_na_action">na_action</code></td>
<td>
<p><code>character</code><br />
Handling of missing values in modality-specific predictions during training.
Set to <code>"na.keep"</code> to keep missing values, <code>"na.rm"</code> to remove individuals
with missing values or <code>"na.impute"</code> to impute missing values in modality-specific
predictions. Only median and mode based imputations are actually handled.
With the <code>"na.keep"</code> option, ensure that the provided meta-learner can handle missing values.</p>
</td></tr>
<tr><td><code id="createTrainMetaLayer_+3A_x_lrn">x_lrn</code></td>
<td>
<p><code>character</code> <br />
If the argument name used by the provided original function to pass the matrix
of independent variables is not <code>x</code>, use this argument to specify the name used
in the function.</p>
</td></tr>
<tr><td><code id="createTrainMetaLayer_+3A_y_lrn">y_lrn</code></td>
<td>
<p><code>character</code> <br />
If the argument name used by the provided original function to pass the target
variable is not <code>y</code>, use this argument to specify the name used in the function.</p>
</td></tr>
<tr><td><code id="createTrainMetaLayer_+3A_object">object</code></td>
<td>
<p><code>character</code> <br />
The generic function <code>predict</code> uses a parameter <code>object</code> to pass a model.
If the corresponding argument is named differently in your predict function, specify the name.</p>
</td></tr>
<tr><td><code id="createTrainMetaLayer_+3A_data">data</code></td>
<td>
<p><code>character</code> <br />
The generic function <code>predict</code> uses a parameter <code>data</code> to pass new data.
If the corresponding argument is named differently in your predict function, specify the name.</p>
</td></tr>
<tr><td><code id="createTrainMetaLayer_+3A_extract_pred_fct">extract_pred_fct</code></td>
<td>
<p><code style="white-space: pre;">&#8288;character or function&#8288;</code> <br />
If the predict function that is called for the model does not return a vector, then
use this argument to specify a (or a name of a) function that can be used to extract vector of predictions.
Defaults to NULL, if predictions are a vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal meta-learners are available in the package.
</p>
<p>The <a href="#topic+cobra">cobra</a> meta-learner implements the COBRA (COmBined Regression Alternative),
an aggregation method for combining predictions from multiple individual learners (Biau et al. 2014).
This method aims to tune key parameters for achieving optimal predictions
by averaging the target values of similar candidates in the training dataset's predictions.
Only the training points that are sufficiently similar to the test point
(based on the proximity threshold <code>epsilon</code>) are used for prediction.
If no suitable training points are found, the function returns <code>NA</code>.
</p>
<p>The <a href="#topic+weightedMeanLearner">weightedMeanLearner</a> evaluates the prediction performance of modality-specific
learners and uses these estimates to weight the base models, aggregating their
predictions accordingly.
</p>
<p>The <a href="#topic+bestLayerLearner">bestLayerLearner</a> evaluates the prediction performance of modality-specific
learners and returns predictions made by the best learner as the meta-prediction.
</p>
<p>Beyond the internal meta-learners, any other learning algorithm can be used.
</p>


<h3>Value</h3>

<p>The updated <a href="#topic+Training">Training</a> object (with the new layer) is returned.
</p>


<h3>References</h3>

<p>Fouodo C.J.K, Bleskina M. and Szymczak S. (2024). fuseMLR: An R package for integrative prediction modeling of multi-omics data, paper submitted. <br />
Biau, G., Fischer, A., Guedj, B., &amp; Malley, J. D. (2014). COBRA: A combined regression strategy. The Journal of Multivariate Analysis 46:18-28
</p>


<h3>See Also</h3>

<p><a href="#topic+createTrainLayer">createTrainLayer</a>, <a href="#topic+varSelection">varSelection</a>, and <a href="#topic+fusemlr">fusemlr</a>.
</p>

<hr>
<h2 id='createWeights'>Create weights for COBRA Predictions</h2><span id='topic+createWeights'></span>

<h3>Description</h3>

<p>The <code>createWeights</code> function is used to calculate weights for predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createWeights(train, test, n_train, n_test, nlearners, eps, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createWeights_+3A_train">train</code></td>
<td>
<p>A <code>matrix</code> representing the training data. Rows represent observations,
and columns contain predictions from individual learners for these observations.
In cases where a prediction is unavailable for a specific observation, <code>NA</code> is used.</p>
</td></tr>
<tr><td><code id="createWeights_+3A_test">test</code></td>
<td>
<p>A <code>matrix</code> representing the test data. Rows represent observations,
and columns contain predictions from individual learners for these observations.
In cases where a prediction is unavailable for a specific observation, <code>NA</code> is used.</p>
</td></tr>
<tr><td><code id="createWeights_+3A_n_train">n_train</code></td>
<td>
<p>An <code>integer</code> specifying the number of training observations.</p>
</td></tr>
<tr><td><code id="createWeights_+3A_n_test">n_test</code></td>
<td>
<p>An <code>integer</code> specifying the number of test observations.</p>
</td></tr>
<tr><td><code id="createWeights_+3A_nlearners">nlearners</code></td>
<td>
<p>An <code>integer</code> representing the number of learners.</p>
</td></tr>
<tr><td><code id="createWeights_+3A_eps">eps</code></td>
<td>
<p>A <code>numeric</code> value representing the threshold for proximity between two predictions.</p>
</td></tr>
<tr><td><code id="createWeights_+3A_alpha">alpha</code></td>
<td>
<p>A value that determines the optimal number of learners in the neighborhood (only for alpha optimization).</p>
</td></tr>
</table>

<hr>
<h2 id='Data'>Abstract class Data</h2><span id='topic+Data'></span>

<h3>Description</h3>

<p>As abstract, a <a href="#topic+Data">Data</a> object cannot be stored on any layer. Instead, extended
<a href="#topic+TrainData">TrainData</a> or <a href="#topic+TestData">TestData</a> objects can be stored on a layer.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Data-new"><code>Data$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Data-print"><code>Data$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Data-getIndSubset"><code>Data$getIndSubset()</code></a>
</p>
</li>
<li> <p><a href="#method-Data-impute"><code>Data$impute()</code></a>
</p>
</li>
<li> <p><a href="#method-Data-getVarSubset"><code>Data$getVarSubset()</code></a>
</p>
</li>
<li> <p><a href="#method-Data-getSetDiff"><code>Data$getSetDiff()</code></a>
</p>
</li>
<li> <p><a href="#method-Data-getDataFrame"><code>Data$getDataFrame()</code></a>
</p>
</li>
<li> <p><a href="#method-Data-setDataFrame"><code>Data$setDataFrame()</code></a>
</p>
</li>
<li> <p><a href="#method-Data-getCompleteData"><code>Data$getCompleteData()</code></a>
</p>
</li>
<li> <p><a href="#method-Data-getId"><code>Data$getId()</code></a>
</p>
</li>
<li> <p><a href="#method-Data-getData"><code>Data$getData()</code></a>
</p>
</li>
<li> <p><a href="#method-Data-getIndCol"><code>Data$getIndCol()</code></a>
</p>
</li>
<li> <p><a href="#method-Data-clone"><code>Data$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Data-new"></a>



<h4>Method <code>new()</code></h4>

<p>Constructor of class Data.
</p>


<h5>Usage</h5>

<div class="r"><pre>Data$new(id, ind_col, data_frame)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character</code> <br />
Object ID.</p>
</dd>
<dt><code>ind_col</code></dt><dd><p><code>character</code> <br />
Column name containing individual IDs.</p>
</dd>
<dt><code>data_frame</code></dt><dd><p><code>data.frame</code> <br />
<code>data.frame</code> containing data.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Data-print"></a>



<h4>Method <code>print()</code></h4>

<p>Printer
</p>


<h5>Usage</h5>

<div class="r"><pre>Data$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p><code>any</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-Data-getIndSubset"></a>



<h4>Method <code>getIndSubset()</code></h4>

<p>Retrieve a data subset for a given variable name and values, a data subset.
</p>


<h5>Usage</h5>

<div class="r"><pre>Data$getIndSubset(var_name, value)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>var_name</code></dt><dd><p><code>character</code> <br />
Variable name of interest.</p>
</dd>
<dt><code>value</code></dt><dd><p><code>vector</code> <br />
Values of interest.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The data subset is returned.
</p>


<hr>
<a id="method-Data-impute"></a>



<h4>Method <code>impute()</code></h4>

<p>Imputes missing values in modality-specific predictions.
Only mode and median based imputations are actually supported.
</p>


<h5>Usage</h5>

<div class="r"><pre>Data$impute(impute_fct, impute_param, target_name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>impute_fct</code></dt><dd><p><code>character</code> <br />
An imputation function to use instead of median or mode imputation. Not yet implemented!</p>
</dd>
<dt><code>impute_param</code></dt><dd><p><code>list</code> <br /></p>
</dd>
<dt><code>target_name</code></dt><dd><p><code>character</code> <br />
Name of the target variable.
The list of parameters to call the imputation function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new object with the predicted values is returned.
</p>


<hr>
<a id="method-Data-getVarSubset"></a>



<h4>Method <code>getVarSubset()</code></h4>

<p>Retrieve a subset of variables from data.
</p>


<h5>Usage</h5>

<div class="r"><pre>Data$getVarSubset(var_name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>var_name</code></dt><dd><p><code>character</code> <br />
Variable names of interest.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The data subset is returned.
</p>


<hr>
<a id="method-Data-getSetDiff"></a>



<h4>Method <code>getSetDiff()</code></h4>

<p>For the given variable name, non existing values in the
current dataset are returned.
</p>


<h5>Usage</h5>

<div class="r"><pre>Data$getSetDiff(var_name, value)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>var_name</code></dt><dd><p><code>character</code> <br />
Variable name of interest.</p>
</dd>
<dt><code>value</code></dt><dd><p><code>vector</code> <br />
Values of interest.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The subset difference is returned.
</p>


<hr>
<a id="method-Data-getDataFrame"></a>



<h4>Method <code>getDataFrame()</code></h4>

<p>Getter of the <code>data.frame</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Data$getDataFrame()</pre></div>



<h5>Returns</h5>

<p>The <code>data.frame</code> of the current object is returned.
</p>


<hr>
<a id="method-Data-setDataFrame"></a>



<h4>Method <code>setDataFrame()</code></h4>

<p>Set a new <code>data.frame</code> to the current object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Data$setDataFrame(data_frame)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data_frame</code></dt><dd><p><code>data.frame</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The current object is returned.
</p>


<hr>
<a id="method-Data-getCompleteData"></a>



<h4>Method <code>getCompleteData()</code></h4>

<p>Getter of the complete dataset without missing values.
</p>


<h5>Usage</h5>

<div class="r"><pre>Data$getCompleteData()</pre></div>



<h5>Returns</h5>

<p>The complete dataset is returned.
</p>


<hr>
<a id="method-Data-getId"></a>



<h4>Method <code>getId()</code></h4>

<p>Getter of the current object ID.
</p>


<h5>Usage</h5>

<div class="r"><pre>Data$getId()</pre></div>



<h5>Returns</h5>

<p>The current object ID is returned.
</p>


<hr>
<a id="method-Data-getData"></a>



<h4>Method <code>getData()</code></h4>

<p>Getter of the current Data. This function is re-implemented
by <a href="#topic+TrainData">TrainData</a> and <a href="#topic+TestData">TestData</a>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Data$getData()</pre></div>



<h5>Returns</h5>

<p>Do not use on this class.
</p>


<hr>
<a id="method-Data-getIndCol"></a>



<h4>Method <code>getIndCol()</code></h4>

<p>Getter of the individual column variable.
</p>


<h5>Usage</h5>

<div class="r"><pre>Data$getIndCol()</pre></div>


<hr>
<a id="method-Data-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Data$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><a href="#topic+TrainData">TrainData</a> and <a href="#topic+TestData">TestData</a>
</p>

<hr>
<h2 id='extractData'>extractData</h2><span id='topic+extractData'></span>

<h3>Description</h3>

<p>Extracts data stored on each layers; base data and modality-specific predictions (for Training) are extracted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractData(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractData_+3A_object">object</code></td>
<td>
<p><code style="white-space: pre;">&#8288;Training or Testing&#8288;</code> <br />
The object of interest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data is returned.
</p>

<hr>
<h2 id='extractModel'>extractModel</h2><span id='topic+extractModel'></span>

<h3>Description</h3>

<p>Extracts models stored on each layers; base and meta models are extracted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractModel(training)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractModel_+3A_training">training</code></td>
<td>
<p><code>Training</code> <br />
The <a href="#topic+Training">Training</a> object of interest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of models is returned.
</p>

<hr>
<h2 id='fusemlr'>fusemlr</h2><span id='topic+fusemlr'></span>

<h3>Description</h3>

<p>Trains the <a href="#topic+Training">Training</a> object passed as argument. A training object must contain
the training layers and a training meta-layer. A training layer encapsulates
data modalities, a variable selection method and a learner. Use the function
<a href="#topic+createTraining">createTraining</a> to create a training object, <a href="#topic+createTrainLayer">createTrainLayer</a> to add training
layers to the created training object, and <a href="#topic+createTrainMetaLayer">createTrainMetaLayer</a> to add a meta-layer
with the corresponding meta-learner to the training object. The function <code>fusemlr</code>
is designed to train all training layers and the meta-learner. After training
the layer-specific base models and the meta-model will be stored in the training
object which can be used for predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fusemlr(
  training,
  ind_subset = NULL,
  use_var_sel = FALSE,
  resampling_method = NULL,
  resampling_arg = list(),
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fusemlr_+3A_training">training</code></td>
<td>
<p><code>Training</code> <br />
Training object for storing training layers.</p>
</td></tr>
<tr><td><code id="fusemlr_+3A_ind_subset">ind_subset</code></td>
<td>
<p><code>vector</code> <br />
ID subset to be used for training.</p>
</td></tr>
<tr><td><code id="fusemlr_+3A_use_var_sel">use_var_sel</code></td>
<td>
<p><code>boolean</code> <br />
If <code>TRUE</code> and no variable selection has been performed for the provide training object,
then a variable selection will proceed the training.
Otherwise, if variable selection has been previously performed, the selected variables will be used for training.</p>
</td></tr>
<tr><td><code id="fusemlr_+3A_resampling_method">resampling_method</code></td>
<td>
<p><code>function</code> <br />
Function for internal validation. If not specify, the <code>resampling</code> function
from the package <code>caret</code> is used for a 10-folds cross-validation.</p>
</td></tr>
<tr><td><code id="fusemlr_+3A_resampling_arg">resampling_arg</code></td>
<td>
<p><code>list</code> <br />
List of arguments to be passed to the function.</p>
</td></tr>
<tr><td><code id="fusemlr_+3A_seed">seed</code></td>
<td>
<p><code>integer</code> <br />
Random seed used for resampling. Default is NULL, which generates the seed from <code>R</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The current object is returned, with each learner trained on each layer.
</p>


<h3>References</h3>

<p>Fouodo C.J.K, Bleskina M. and Szymczak S. (2024). fuseMLR: An R package for integrative prediction modeling of multi-omics data, paper submitted.
</p>


<h3>See Also</h3>

<p><a href="#topic+createTrainLayer">createTrainLayer</a>, <a href="#topic+createTrainMetaLayer">createTrainMetaLayer</a>, <a href="#topic+extractModel">extractModel</a> and <a href="#topic+extractData">extractData</a>.
</p>

<hr>
<h2 id='HashTable'>Class HashTable</h2><span id='topic+HashTable'></span>

<h3>Description</h3>

<p>Hashtable to contain object modalities. Storage objects like <a href="#topic+Training">Training</a> and <a href="#topic+TrainLayer">TrainLayer</a> are extensions of this class.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-HashTable-new"><code>HashTable$new()</code></a>
</p>
</li>
<li> <p><a href="#method-HashTable-print"><code>HashTable$print()</code></a>
</p>
</li>
<li> <p><a href="#method-HashTable-add2HashTable"><code>HashTable$add2HashTable()</code></a>
</p>
</li>
<li> <p><a href="#method-HashTable-getFromHashTable"><code>HashTable$getFromHashTable()</code></a>
</p>
</li>
<li> <p><a href="#method-HashTable-getKeyClass"><code>HashTable$getKeyClass()</code></a>
</p>
</li>
<li> <p><a href="#method-HashTable-removeFromHashTable"><code>HashTable$removeFromHashTable()</code></a>
</p>
</li>
<li> <p><a href="#method-HashTable-getId"><code>HashTable$getId()</code></a>
</p>
</li>
<li> <p><a href="#method-HashTable-getHashTable"><code>HashTable$getHashTable()</code></a>
</p>
</li>
<li> <p><a href="#method-HashTable-checkClassExist"><code>HashTable$checkClassExist()</code></a>
</p>
</li></ul>


<hr>
<a id="method-HashTable-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize a default parameters list.
</p>


<h5>Usage</h5>

<div class="r"><pre>HashTable$new(id)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character</code> <br />
ID of the hash table. It must be unique.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HashTable-print"></a>



<h4>Method <code>print()</code></h4>

<p>Printer
</p>


<h5>Usage</h5>

<div class="r"><pre>HashTable$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p><code>any</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-HashTable-add2HashTable"></a>



<h4>Method <code>add2HashTable()</code></h4>

<p>Function to add a key-value pair to the hash table.
</p>


<h5>Usage</h5>

<div class="r"><pre>HashTable$add2HashTable(key, value, .class)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>key</code></dt><dd><p><code>character</code> <br />
The key to be added.</p>
</dd>
<dt><code>value</code></dt><dd><p><code>object</code> <br />
Object to be added.</p>
</dd>
<dt><code>.class</code></dt><dd><p><code>character</code> <br />
Class of the object to be added.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HashTable-getFromHashTable"></a>



<h4>Method <code>getFromHashTable()</code></h4>

<p>Getter of the object which the key passed as argument.
</p>


<h5>Usage</h5>

<div class="r"><pre>HashTable$getFromHashTable(key)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>key</code></dt><dd><p><code>character</code> <br />
Key of the required object.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HashTable-getKeyClass"></a>



<h4>Method <code>getKeyClass()</code></h4>

<p>Getter of the <code>data.frame</code> that stores all key class pairs.
</p>


<h5>Usage</h5>

<div class="r"><pre>HashTable$getKeyClass()</pre></div>



<h5>Returns</h5>

<p><a href="base.html#topic+data.frame">data.frame</a>
</p>


<hr>
<a id="method-HashTable-removeFromHashTable"></a>



<h4>Method <code>removeFromHashTable()</code></h4>

<p>Remove the object with the corresponding key from the hashtable.
</p>


<h5>Usage</h5>

<div class="r"><pre>HashTable$removeFromHashTable(key)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>key</code></dt><dd><p>Key of the object to be removed.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HashTable-getId"></a>



<h4>Method <code>getId()</code></h4>

<p>Getter of the current object ID.
</p>


<h5>Usage</h5>

<div class="r"><pre>HashTable$getId()</pre></div>


<hr>
<a id="method-HashTable-getHashTable"></a>



<h4>Method <code>getHashTable()</code></h4>

<p>Getter of the current hashtable.
</p>


<h5>Usage</h5>

<div class="r"><pre>HashTable$getHashTable()</pre></div>


<hr>
<a id="method-HashTable-checkClassExist"></a>



<h4>Method <code>checkClassExist()</code></h4>

<p>Check whether object from a class has already been stored.
</p>


<h5>Usage</h5>

<div class="r"><pre>HashTable$checkClassExist(.class)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>.class</code></dt><dd><p><code>character</code> <br /></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Boolean value
</p>



<hr>
<h2 id='Lrner'>Lrner Class</h2><span id='topic+Lrner'></span>

<h3>Description</h3>

<p>This class implements a learner. A <a href="#topic+Lrner">Lrner</a> object can only exist as a component of a
<a href="#topic+TrainLayer">TrainLayer</a> or a <a href="#topic+TrainMetaLayer">TrainMetaLayer</a> object.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Lrner-new"><code>Lrner$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Lrner-print"><code>Lrner$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Lrner-summary"><code>Lrner$summary()</code></a>
</p>
</li>
<li> <p><a href="#method-Lrner-interface"><code>Lrner$interface()</code></a>
</p>
</li>
<li> <p><a href="#method-Lrner-train"><code>Lrner$train()</code></a>
</p>
</li>
<li> <p><a href="#method-Lrner-getTrainLayer"><code>Lrner$getTrainLayer()</code></a>
</p>
</li>
<li> <p><a href="#method-Lrner-getNaRm"><code>Lrner$getNaRm()</code></a>
</p>
</li>
<li> <p><a href="#method-Lrner-getNaAction"><code>Lrner$getNaAction()</code></a>
</p>
</li>
<li> <p><a href="#method-Lrner-getId"><code>Lrner$getId()</code></a>
</p>
</li>
<li> <p><a href="#method-Lrner-getPackage"><code>Lrner$getPackage()</code></a>
</p>
</li>
<li> <p><a href="#method-Lrner-getIndSubset"><code>Lrner$getIndSubset()</code></a>
</p>
</li>
<li> <p><a href="#method-Lrner-getVarSubset"><code>Lrner$getVarSubset()</code></a>
</p>
</li>
<li> <p><a href="#method-Lrner-getParamPred"><code>Lrner$getParamPred()</code></a>
</p>
</li>
<li> <p><a href="#method-Lrner-getParamInterface"><code>Lrner$getParamInterface()</code></a>
</p>
</li>
<li> <p><a href="#method-Lrner-getExtractPred"><code>Lrner$getExtractPred()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Lrner-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize a default parameters list.
</p>


<h5>Usage</h5>

<div class="r"><pre>Lrner$new(
  id,
  package = NULL,
  lrn_fct,
  param_train_list,
  param_pred_list = list(),
  train_layer,
  na_action = "na.rm"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character</code> <br />
Learner ID.</p>
</dd>
<dt><code>package</code></dt><dd><p><code>character</code> <br />
Package that implements the learn function. If NULL, the</p>
</dd>
<dt><code>lrn_fct</code></dt><dd><p><code>character</code> <br />
learn function is called from the current environment.</p>
</dd>
<dt><code>param_train_list</code></dt><dd><p><code>list</code> <br />
List of parameter for training.</p>
</dd>
<dt><code>param_pred_list</code></dt><dd><p><code>list</code> <br />
List of parameter for testing.
Learn parameters.</p>
</dd>
<dt><code>train_layer</code></dt><dd><p><code>TrainLayer</code> <br />
Layer on which the learner is stored.</p>
</dd>
<dt><code>na_action</code></dt><dd><p><code>character</code> <br />
Handling of missing values. Set to &quot;na.keep&quot; to keep missing values, &quot;na.rm&quot; to remove individuals with missing values or &quot;na.impute&quot; (only applicable on meta-data) to impute missing values in meta-data. Only median and mode based imputations are actually handled. With the &quot;na.keep&quot; option, ensure that the provided learner can handle missing values.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Lrner-print"></a>



<h4>Method <code>print()</code></h4>

<p>Printer
</p>


<h5>Usage</h5>

<div class="r"><pre>Lrner$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p><code>any</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-Lrner-summary"></a>



<h4>Method <code>summary()</code></h4>

<p>Printer
</p>


<h5>Usage</h5>

<div class="r"><pre>Lrner$summary(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p><code>any</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-Lrner-interface"></a>



<h4>Method <code>interface()</code></h4>

<p>Learner and prediction parameter interface. Use this function
to provide how the following parameters are named in the learning
function (<code>lrn_fct</code>) you provided when creating the learner, or in the predicting function.
</p>


<h5>Usage</h5>

<div class="r"><pre>Lrner$interface(
  x = "x",
  y = "y",
  object = "object",
  data = "data",
  extract_pred_fct = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p><code>character</code> <br />
Name of the argument to pass the matrix of independent variables in the original learning function.</p>
</dd>
<dt><code>y</code></dt><dd><p><code>character</code> <br />
Name of the argument to pass the response variable in the original learning function.</p>
</dd>
<dt><code>object</code></dt><dd><p><code>character</code> <br />
Name of the argument to pass the model in the original predicting function.</p>
</dd>
<dt><code>data</code></dt><dd><p><code>character</code> <br />
Name of the argument to pass new data in the original predicting function.</p>
</dd>
<dt><code>extract_pred_fct</code></dt><dd><p><code>character</code> or <code>function</code> <br />
If the predict function that is called for the model does not return a vector, then
use this argument to specify a (or a name of a) function that can be used to extract vector of predictions.
Default value is NULL, if predictions are in a vector.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Lrner-train"></a>



<h4>Method <code>train()</code></h4>

<p>Tains the current learner (from class <a href="#topic+Lrner">Lrner</a>) on the current training data (from class <a href="#topic+TrainData">TrainData</a>).
</p>


<h5>Usage</h5>

<div class="r"><pre>Lrner$train(ind_subset = NULL, use_var_sel = FALSE, verbose = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ind_subset</code></dt><dd><p><code>vector</code> <br />
Individual ID subset on which the training will be performed.</p>
</dd>
<dt><code>use_var_sel</code></dt><dd><p><code>boolean</code> <br />
If TRUE, variable selection is performed before training.</p>
</dd>
<dt><code>verbose</code></dt><dd><p><code>boolean</code> <br />
Warning messages will be displayed if set to TRUE.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The resulting model, from class <a href="#topic+Model">Model</a>, is returned.
</p>


<hr>
<a id="method-Lrner-getTrainLayer"></a>



<h4>Method <code>getTrainLayer()</code></h4>

<p>The current layer is returned.
</p>


<h5>Usage</h5>

<div class="r"><pre>Lrner$getTrainLayer()</pre></div>



<h5>Returns</h5>

<p><a href="#topic+TrainLayer">TrainLayer</a> object.
</p>


<hr>
<a id="method-Lrner-getNaRm"></a>



<h4>Method <code>getNaRm()</code></h4>

<p>The current layer is returned.
</p>


<h5>Usage</h5>

<div class="r"><pre>Lrner$getNaRm()</pre></div>


<hr>
<a id="method-Lrner-getNaAction"></a>



<h4>Method <code>getNaAction()</code></h4>

<p>The current layer is returned.
</p>


<h5>Usage</h5>

<div class="r"><pre>Lrner$getNaAction()</pre></div>


<hr>
<a id="method-Lrner-getId"></a>



<h4>Method <code>getId()</code></h4>

<p>Getter of the current learner ID.
</p>


<h5>Usage</h5>

<div class="r"><pre>Lrner$getId()</pre></div>



<h5>Returns</h5>

<p>The current learner ID.
</p>


<hr>
<a id="method-Lrner-getPackage"></a>



<h4>Method <code>getPackage()</code></h4>

<p>Getter of the learner package implementing the learn function.
</p>


<h5>Usage</h5>

<div class="r"><pre>Lrner$getPackage()</pre></div>



<h5>Returns</h5>

<p>The name of the package implementing the learn function.
</p>


<hr>
<a id="method-Lrner-getIndSubset"></a>



<h4>Method <code>getIndSubset()</code></h4>

<p>Getter of the learner package implementing the learn function.
</p>


<h5>Usage</h5>

<div class="r"><pre>Lrner$getIndSubset()</pre></div>



<h5>Returns</h5>

<p>The name of the package implementing the learn function.
</p>


<hr>
<a id="method-Lrner-getVarSubset"></a>



<h4>Method <code>getVarSubset()</code></h4>

<p>Getter of the variable subset used for training.
</p>


<h5>Usage</h5>

<div class="r"><pre>Lrner$getVarSubset()</pre></div>



<h5>Returns</h5>

<p>The list of variables used for training is returned.
</p>


<hr>
<a id="method-Lrner-getParamPred"></a>



<h4>Method <code>getParamPred()</code></h4>

<p>Getter predicting parameter list.
</p>


<h5>Usage</h5>

<div class="r"><pre>Lrner$getParamPred()</pre></div>



<h5>Returns</h5>

<p>The list of predicting parameters.
</p>


<hr>
<a id="method-Lrner-getParamInterface"></a>



<h4>Method <code>getParamInterface()</code></h4>

<p>The current parameter interface is returned.
</p>


<h5>Usage</h5>

<div class="r"><pre>Lrner$getParamInterface()</pre></div>



<h5>Returns</h5>

<p>A data.frame of interface.
</p>


<hr>
<a id="method-Lrner-getExtractPred"></a>



<h4>Method <code>getExtractPred()</code></h4>

<p>The function to extract predicted values is returned.
</p>


<h5>Usage</h5>

<div class="r"><pre>Lrner$getExtractPred()</pre></div>



<h5>Returns</h5>

<p>A data.frame of interface.
</p>



<hr>
<h2 id='Model'>Model Class</h2><span id='topic+Model'></span>

<h3>Description</h3>

<p>This class implements a model. A <a href="#topic+Model">Model</a> object can only exist as element of a
<a href="#topic+TrainLayer">TrainLayer</a> or a <a href="#topic+TrainMetaLayer">TrainMetaLayer</a> object. A <a href="#topic+Model">Model</a> object is
automatically created by fitting a learner on a training data.
</p>
<p>A <a href="#topic+Model">Model</a> object can compute predictions for a <a href="#topic+TestData">TestData</a> object. See the <code>predict</code> function below.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Model-new"><code>Model$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-print"><code>Model$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-summary"><code>Model$summary()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-getBaseModel"><code>Model$getBaseModel()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-getTrainData"><code>Model$getTrainData()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-getTrainLabel"><code>Model$getTrainLabel()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-getLrner"><code>Model$getLrner()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-setId"><code>Model$setId()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-predict"><code>Model$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-clone"><code>Model$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Model-new"></a>



<h4>Method <code>new()</code></h4>

<p>Constructor of Model class.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$new(lrner, train_data, base_model, train_layer)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>lrner</code></dt><dd><p><code>Lrner</code> <br />
The learner.</p>
</dd>
<dt><code>train_data</code></dt><dd><p><code>TrainData(1)</code> <br />
Training data.</p>
</dd>
<dt><code>base_model</code></dt><dd><p><code>object</code> <br />
Base model as returned by the original learn function.</p>
</dd>
<dt><code>train_layer</code></dt><dd><p><code>TrainLayer</code> <br />
The current training layer on which the model is stored.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object is returned.
</p>


<hr>
<a id="method-Model-print"></a>



<h4>Method <code>print()</code></h4>

<p>Printer
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p><code>any</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-Model-summary"></a>



<h4>Method <code>summary()</code></h4>

<p>Summary
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$summary(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p><code>any</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-Model-getBaseModel"></a>



<h4>Method <code>getBaseModel()</code></h4>

<p>Getter of the base model
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$getBaseModel()</pre></div>


<hr>
<a id="method-Model-getTrainData"></a>



<h4>Method <code>getTrainData()</code></h4>

<p>Getter of the traning data
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$getTrainData()</pre></div>


<hr>
<a id="method-Model-getTrainLabel"></a>



<h4>Method <code>getTrainLabel()</code></h4>

<p>Getter of the individual ID column in the training data.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$getTrainLabel()</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p><code>any</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-Model-getLrner"></a>



<h4>Method <code>getLrner()</code></h4>

<p>Getter of the learner use to fit the model.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$getLrner()</pre></div>


<hr>
<a id="method-Model-setId"></a>



<h4>Method <code>setId()</code></h4>

<p>Setter of the model ID.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$setId(id)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character</code> <br />
ID value</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Model-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Predict target values for the new data
(from class <a href="#topic+TestData">TestData</a>) taken as into.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$predict(testing_data, use_var_sel, ind_subset = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>testing_data</code></dt><dd><p><code>TestData</code> <br />
An object from class <a href="#topic+TestData">TestData</a>.</p>
</dd>
<dt><code>use_var_sel</code></dt><dd><p><code>boolean</code> <br />
If TRUE, selected variables available at each layer are used.</p>
</dd>
<dt><code>ind_subset</code></dt><dd><p><code>vector</code> <br />
Subset of individual IDs to be predicted.</p>
</dd>
<dt><code>...</code></dt><dd><p>Further parameters to be passed to the basic predict function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The predicted object are returned. The predicted object must be either a vector or a list
containing a field predictions with predictions.
</p>


<hr>
<a id="method-Model-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='multi_omics'>Simulated multiomics data for 70 training participants and 23 testing participants,
each with an effect size of 20 on each layer. Each layer includes 50 participants for
training and 20 for testing. Participants do not perfectly overlap across layers.
The simulation is based on the R package <code>interSIM</code>.</h2><span id='topic+multi_omics'></span>

<h3>Description</h3>

<p>The dataset is a list containing training and testing data,
called <code>training</code> and <code>testing</code> respectively. Each data is a list
containing the following multi_omics at each layer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(multi_omics)
</code></pre>


<h3>Format</h3>

<p>A list with training and testing data contaning methylation, gene expressions and protein expressions data.
</p>


<h3>Details</h3>


<ul>
<li> <p><code>methylation</code>: A <code>data.frame</code> containing the simulated methylation dataset.
</p>
</li>
<li> <p><code>genexpr</code>    : A <code>data.frame</code> containing the gene expression dataset.
</p>
</li>
<li> <p><code>proteinexpr</code>: A <code>data.frame</code> containing the protein expression dataset.
</p>
</li>
<li> <p><code>target</code>: A <code>data.frame</code> with two columns, containing patient IDs and values of target variable.
</p>
</li></ul>


<hr>
<h2 id='predict.bestLayerLearner'>Best specific Learner prediction.</h2><span id='topic+predict.bestLayerLearner'></span>

<h3>Description</h3>

<p>Predict function for models from class <code>bestLayerLearner</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bestLayerLearner'
predict(object, data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.bestLayerLearner_+3A_object">object</code></td>
<td>
<p><code>bestLayerLearner</code> <br />
An object from class <a href="#topic+bestLayerLearner">bestLayerLearner</a></p>
</td></tr>
<tr><td><code id="predict.bestLayerLearner_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> <br />
New data to predicted.</p>
</td></tr>
<tr><td><code id="predict.bestLayerLearner_+3A_...">...</code></td>
<td>
<p><code>any</code><br />
Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Predicted target values are returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(20240625)
x = data.frame(x1 = runif(n = 50L, min = 0, max = 1))
y &lt;- sample(x = 0:1, size = 50L, replace = TRUE)
my_model &lt;- bestLayerLearner(x = x, y = y)
x_new &lt;- data.frame(x1 = rnorm(10L))
my_predictions &lt;- predict(object = my_model, data = x_new)


</code></pre>

<hr>
<h2 id='predict.cobra'>Predict Using COBRA object</h2><span id='topic+predict.cobra'></span>

<h3>Description</h3>

<p>#' The <code>predict.cobra</code> function makes predictions on new data using a trained COBRA object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cobra'
predict(object, data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.cobra_+3A_object">object</code></td>
<td>
<p>An object of class &quot;cobra&quot; created by the <code>cobra</code> function.</p>
</td></tr>
<tr><td><code id="predict.cobra_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> of new data, where rows are observations and
columns are predictions from individual learners. Use <code>NA</code> for missing predictions.</p>
</td></tr>
<tr><td><code id="predict.cobra_+3A_...">...</code></td>
<td>
<p>Additional arguments (currently not used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of predictions for the new data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage
set.seed(123)
x_train &lt;- data.frame(a = rnorm(10L), b = rnorm(10L))
y_train &lt;- sample(0L:1L, size = 10L, replace = TRUE)

# Train the model with epsilon optimization
cobra_model &lt;- cobra(x = x_train, y = y_train, tune = "epsilon")

# Make predictions on new data
set.seed(156)
x_new &lt;- data.frame(a = rnorm(5L), b = rnorm(5L))
prediction &lt;- predict(object = cobra_model, data = x_new)
</code></pre>

<hr>
<h2 id='predict.Training'>predict.Training</h2><span id='topic+predict.Training'></span>

<h3>Description</h3>

<p>Computes predictions for the <a href="#topic+Testing">Testing</a> object passed as argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Training'
predict(object, testing, ind_subset = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.Training_+3A_object">object</code></td>
<td>
<p><code>Training</code> <br />
A trained Training object to be used to compute predictions.</p>
</td></tr>
<tr><td><code id="predict.Training_+3A_testing">testing</code></td>
<td>
<p><code>Testing</code> <br />
A new testing object to be predicted.</p>
</td></tr>
<tr><td><code id="predict.Training_+3A_ind_subset">ind_subset</code></td>
<td>
<p><code>vector</code> <br />
Vector of IDs to be predicted.</p>
</td></tr>
<tr><td><code id="predict.Training_+3A_...">...</code></td>
<td>
<p><code>any</code> <br />
Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The final predicted object. All layers and the meta layer are predicted.
</p>

<hr>
<h2 id='predict.weightedMeanLearner'>Weighted mean prediction.</h2><span id='topic+predict.weightedMeanLearner'></span>

<h3>Description</h3>

<p>Predict function for models from class <code>weightedMeanLearner</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'weightedMeanLearner'
predict(object, data, na_rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.weightedMeanLearner_+3A_object">object</code></td>
<td>
<p><code>weightedMeanLearner(1)</code> <br />
An object from class <a href="#topic+weightedMeanLearner">weightedMeanLearner</a></p>
</td></tr>
<tr><td><code id="predict.weightedMeanLearner_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> <br />
<code>data.frame</code> to be predicted.</p>
</td></tr>
<tr><td><code id="predict.weightedMeanLearner_+3A_na_rm">na_rm</code></td>
<td>
<p><code>boolean</code> <br />
Removes NAs when TRUE.</p>
</td></tr>
<tr><td><code id="predict.weightedMeanLearner_+3A_...">...</code></td>
<td>
<p><code>any</code> <br />
Further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Predicted target values are returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(20240625)
x &lt;- data.frame(x1 = rnorm(50L))
y &lt;- sample(x = 0:1, size = 50L, replace = TRUE)
my_model &lt;- weightedMeanLearner(x = x, y = y)
x_new &lt;- data.frame(x1 = rnorm(10L))
my_predictions &lt;- predict(object = my_model, data = x_new)

</code></pre>

<hr>
<h2 id='PredictData'>PredictData Class</h2><span id='topic+PredictData'></span>

<h3>Description</h3>

<p>This class implements <a href="#topic+PredictData">PredictData</a> object to be predicted.
A <a href="#topic+PredictData">PredictData</a> object can only exist as a component of a <a href="#topic+PredictLayer">PredictLayer</a> or a <a href="#topic+PredictMetaLayer">PredictMetaLayer</a> object.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Data">fuseMLR::Data</a></code> -&gt; <code>PredictData</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PredictData-new"><code>PredictData$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PredictData-print"><code>PredictData$print()</code></a>
</p>
</li>
<li> <p><a href="#method-PredictData-getPredictData"><code>PredictData$getPredictData()</code></a>
</p>
</li>
<li> <p><a href="#method-PredictData-getPredictLayer"><code>PredictData$getPredictLayer()</code></a>
</p>
</li>
<li> <p><a href="#method-PredictData-setPredictLayer"><code>PredictData$setPredictLayer()</code></a>
</p>
</li>
<li> <p><a href="#method-PredictData-clone"><code>PredictData$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="getCompleteData"><a href='../../fuseMLR/html/Data.html#method-Data-getCompleteData'><code>fuseMLR::Data$getCompleteData()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="getData"><a href='../../fuseMLR/html/Data.html#method-Data-getData'><code>fuseMLR::Data$getData()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="getDataFrame"><a href='../../fuseMLR/html/Data.html#method-Data-getDataFrame'><code>fuseMLR::Data$getDataFrame()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="getId"><a href='../../fuseMLR/html/Data.html#method-Data-getId'><code>fuseMLR::Data$getId()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="getIndCol"><a href='../../fuseMLR/html/Data.html#method-Data-getIndCol'><code>fuseMLR::Data$getIndCol()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="getIndSubset"><a href='../../fuseMLR/html/Data.html#method-Data-getIndSubset'><code>fuseMLR::Data$getIndSubset()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="getSetDiff"><a href='../../fuseMLR/html/Data.html#method-Data-getSetDiff'><code>fuseMLR::Data$getSetDiff()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="getVarSubset"><a href='../../fuseMLR/html/Data.html#method-Data-getVarSubset'><code>fuseMLR::Data$getVarSubset()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="impute"><a href='../../fuseMLR/html/Data.html#method-Data-impute'><code>fuseMLR::Data$impute()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="setDataFrame"><a href='../../fuseMLR/html/Data.html#method-Data-setDataFrame'><code>fuseMLR::Data$setDataFrame()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PredictData-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize a new object from the current class.
</p>


<h5>Usage</h5>

<div class="r"><pre>PredictData$new(id, ind_col, data_frame)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character</code> <br />
Object ID.</p>
</dd>
<dt><code>ind_col</code></dt><dd><p><code>character</code><br />
Column name containing individual IDs.</p>
</dd>
<dt><code>data_frame</code></dt><dd><p><code>data.frame</code><br />
<code>data.frame</code> containing data.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PredictData-print"></a>



<h4>Method <code>print()</code></h4>

<p>Printer
</p>


<h5>Usage</h5>

<div class="r"><pre>PredictData$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p><code>any</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-PredictData-getPredictData"></a>



<h4>Method <code>getPredictData()</code></h4>

<p>Getter of the current predicted <code>data.frame</code> wihtout individual
ID variable.
</p>


<h5>Usage</h5>

<div class="r"><pre>PredictData$getPredictData()</pre></div>



<h5>Returns</h5>

<p>The <code>data.frame</code> without individual ID nor target variables is returned.
</p>


<hr>
<a id="method-PredictData-getPredictLayer"></a>



<h4>Method <code>getPredictLayer()</code></h4>

<p>Getter of the current layer.
</p>


<h5>Usage</h5>

<div class="r"><pre>PredictData$getPredictLayer()</pre></div>



<h5>Returns</h5>

<p>The layer (from class <a href="#topic+PredictLayer">PredictLayer</a>) on which the current train data are stored
is returned.
</p>


<hr>
<a id="method-PredictData-setPredictLayer"></a>



<h4>Method <code>setPredictLayer()</code></h4>

<p>Assigns a predicted layer to the predicted data.
</p>


<h5>Usage</h5>

<div class="r"><pre>PredictData$setPredictLayer(predict_layer)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>predict_layer</code></dt><dd><p><code>PredictLayer(1)</code> <br /></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The current object
</p>


<hr>
<a id="method-PredictData-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PredictData$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><a href="#topic+TrainData">TrainData</a>, <a href="#topic+TestData">TestData</a>
</p>

<hr>
<h2 id='Predicting'>Predicting Class</h2><span id='topic+Predicting'></span>

<h3>Description</h3>

<p>This class is designed for predictions.
</p>
<p>The Predicting is structured as followed:
</p>

<ul>
<li> <p><a href="#topic+PredictLayer">PredictLayer</a>: Exists for each modality.
</p>

<ul>
<li> <p><a href="#topic+PredictData">PredictData</a>: Related class for modality-specific predictions.
</p>
</li></ul>

</li>
<li> <p><a href="#topic+PredictMetaLayer">PredictMetaLayer</a>: Related class for meta predictions.
</p>

<ul>
<li> <p><a href="#topic+PredictData">PredictData</a>: Specific to the meta layer, it is set up internally after cross-validation.
</p>
</li></ul>

</li></ul>

<p>Use the function <code>train</code> for training and <code>predict</code> for predicting.
</p>
<p>TODO: Do not export me.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+HashTable">fuseMLR::HashTable</a></code> -&gt; <code>Predicting</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Predicting-new"><code>Predicting$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Predicting-print"><code>Predicting$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Predicting-createMetaTestData"><code>Predicting$createMetaTestData()</code></a>
</p>
</li>
<li> <p><a href="#method-Predicting-getIndIDs"><code>Predicting$getIndIDs()</code></a>
</p>
</li>
<li> <p><a href="#method-Predicting-getPredictMetaLayer"><code>Predicting$getPredictMetaLayer()</code></a>
</p>
</li>
<li> <p><a href="#method-Predicting-getIndCol"><code>Predicting$getIndCol()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="add2HashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-add2HashTable'><code>fuseMLR::HashTable$add2HashTable()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="checkClassExist"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-checkClassExist'><code>fuseMLR::HashTable$checkClassExist()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getFromHashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getFromHashTable'><code>fuseMLR::HashTable$getFromHashTable()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getHashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getHashTable'><code>fuseMLR::HashTable$getHashTable()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getId"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getId'><code>fuseMLR::HashTable$getId()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getKeyClass"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getKeyClass'><code>fuseMLR::HashTable$getKeyClass()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="removeFromHashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-removeFromHashTable'><code>fuseMLR::HashTable$removeFromHashTable()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Predicting-new"></a>



<h4>Method <code>new()</code></h4>

<p>constructor
</p>


<h5>Usage</h5>

<div class="r"><pre>Predicting$new(id, ind_col)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character</code><br />
Predicting id.</p>
</dd>
<dt><code>ind_col</code></dt><dd><p><code>character</code>
Name of column of individuals IDS</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Predicting-print"></a>



<h4>Method <code>print()</code></h4>

<p>Printer
</p>


<h5>Usage</h5>

<div class="r"><pre>Predicting$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p><code>any</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-Predicting-createMetaTestData"></a>



<h4>Method <code>createMetaTestData()</code></h4>

<p>Creates a new modality-specific predictions dataset based on layer predictions.
</p>


<h5>Usage</h5>

<div class="r"><pre>Predicting$createMetaTestData(meta_layer_id)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>meta_layer_id</code></dt><dd><p>(<code>character(1)</code>) <br />
ID of the meta layer where the testing meta data will be stored.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="#topic+TestData">TestData</a> is returned.
</p>


<hr>
<a id="method-Predicting-getIndIDs"></a>



<h4>Method <code>getIndIDs()</code></h4>

<p>Gather individual IDs from all layer.
</p>


<h5>Usage</h5>

<div class="r"><pre>Predicting$getIndIDs()</pre></div>



<h5>Returns</h5>

<p>A <code>data.frame</code> containing individuals IDs.
</p>


<hr>
<a id="method-Predicting-getPredictMetaLayer"></a>



<h4>Method <code>getPredictMetaLayer()</code></h4>

<p>Getter of the meta layer.
</p>


<h5>Usage</h5>

<div class="r"><pre>Predicting$getPredictMetaLayer()</pre></div>



<h5>Returns</h5>

<p>Object from class <a href="#topic+PredictMetaLayer">PredictMetaLayer</a>
</p>


<hr>
<a id="method-Predicting-getIndCol"></a>



<h4>Method <code>getIndCol()</code></h4>

<p>Getter of the individual column name.
</p>


<h5>Usage</h5>

<div class="r"><pre>Predicting$getIndCol()</pre></div>




<h3>See Also</h3>

<p><a href="#topic+TrainLayer">TrainLayer</a>
</p>

<hr>
<h2 id='PredictLayer'>PredictLayer Class</h2><span id='topic+PredictLayer'></span>

<h3>Description</h3>

<p>This class implements a layer. A <a href="#topic+PredictLayer">PredictLayer</a> object can only exist as a component of a <a href="#topic+Predicting">Predicting</a> object.
</p>
<p>A predicted layer can only contain <a href="#topic+PredictData">PredictData</a>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+HashTable">fuseMLR::HashTable</a></code> -&gt; <code>PredictLayer</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PredictLayer-new"><code>PredictLayer$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PredictLayer-print"><code>PredictLayer$print()</code></a>
</p>
</li>
<li> <p><a href="#method-PredictLayer-getPredicting"><code>PredictLayer$getPredicting()</code></a>
</p>
</li>
<li> <p><a href="#method-PredictLayer-getIndIDs"><code>PredictLayer$getIndIDs()</code></a>
</p>
</li>
<li> <p><a href="#method-PredictLayer-getPredictData"><code>PredictLayer$getPredictData()</code></a>
</p>
</li>
<li> <p><a href="#method-PredictLayer-setPredicting"><code>PredictLayer$setPredicting()</code></a>
</p>
</li>
<li> <p><a href="#method-PredictLayer-summary"><code>PredictLayer$summary()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="add2HashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-add2HashTable'><code>fuseMLR::HashTable$add2HashTable()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="checkClassExist"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-checkClassExist'><code>fuseMLR::HashTable$checkClassExist()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getFromHashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getFromHashTable'><code>fuseMLR::HashTable$getFromHashTable()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getHashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getHashTable'><code>fuseMLR::HashTable$getHashTable()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getId"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getId'><code>fuseMLR::HashTable$getId()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getKeyClass"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getKeyClass'><code>fuseMLR::HashTable$getKeyClass()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="removeFromHashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-removeFromHashTable'><code>fuseMLR::HashTable$removeFromHashTable()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PredictLayer-new"></a>



<h4>Method <code>new()</code></h4>

<p>constructor
</p>


<h5>Usage</h5>

<div class="r"><pre>PredictLayer$new(id)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character</code> <br />
The layer ID.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PredictLayer-print"></a>



<h4>Method <code>print()</code></h4>

<p>Printer
</p>


<h5>Usage</h5>

<div class="r"><pre>PredictLayer$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p><code>any</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-PredictLayer-getPredicting"></a>



<h4>Method <code>getPredicting()</code></h4>

<p>Getter of the current predicting object
</p>


<h5>Usage</h5>

<div class="r"><pre>PredictLayer$getPredicting()</pre></div>



<h5>Returns</h5>

<p>The current predicting object is returned.
</p>


<hr>
<a id="method-PredictLayer-getIndIDs"></a>



<h4>Method <code>getIndIDs()</code></h4>

<p>Getter of IDS from the current layer.
</p>


<h5>Usage</h5>

<div class="r"><pre>PredictLayer$getIndIDs()</pre></div>



<h5>Returns</h5>

<p>A <code>data.frame</code> containing individuals IDs values.
</p>


<hr>
<a id="method-PredictLayer-getPredictData"></a>



<h4>Method <code>getPredictData()</code></h4>

<p>Getter of the predicted data stored on the current layer.
</p>


<h5>Usage</h5>

<div class="r"><pre>PredictLayer$getPredictData()</pre></div>



<h5>Returns</h5>

<p>The stored <a href="#topic+PredictData">PredictData</a> object is returned.
</p>


<hr>
<a id="method-PredictLayer-setPredicting"></a>



<h4>Method <code>setPredicting()</code></h4>

<p>Assigns a predicting object to the predicted layer.
</p>


<h5>Usage</h5>

<div class="r"><pre>PredictLayer$setPredicting(predicting)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>predicting</code></dt><dd><p><code>Predicting</code> <br /></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The current object
</p>


<hr>
<a id="method-PredictLayer-summary"></a>



<h4>Method <code>summary()</code></h4>

<p>Generate summary.
</p>


<h5>Usage</h5>

<div class="r"><pre>PredictLayer$summary()</pre></div>




<h3>See Also</h3>

<p><a href="#topic+Training">Training</a>, <a href="#topic+Lrner">Lrner</a>, <a href="#topic+TrainData">TrainData</a>, <a href="#topic+TestData">TestData</a> and <a href="#topic+Model">Model</a>
</p>

<hr>
<h2 id='PredictMetaLayer'>PredictMetaLayer Class</h2><span id='topic+PredictMetaLayer'></span>

<h3>Description</h3>

<p>This class implement a predicted meta layer. A <a href="#topic+PredictMetaLayer">PredictMetaLayer</a> can only exist as unique element of a <a href="#topic+Training">Training</a> object.
</p>
<p>A predicted meta layer can only contain a <a href="#topic+PredictData">PredictData</a> object.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+HashTable">fuseMLR::HashTable</a></code> -&gt; <code>PredictMetaLayer</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PredictMetaLayer-new"><code>PredictMetaLayer$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PredictMetaLayer-print"><code>PredictMetaLayer$print()</code></a>
</p>
</li>
<li> <p><a href="#method-PredictMetaLayer-getPredicting"><code>PredictMetaLayer$getPredicting()</code></a>
</p>
</li>
<li> <p><a href="#method-PredictMetaLayer-getIndIDs"><code>PredictMetaLayer$getIndIDs()</code></a>
</p>
</li>
<li> <p><a href="#method-PredictMetaLayer-getPredictData"><code>PredictMetaLayer$getPredictData()</code></a>
</p>
</li>
<li> <p><a href="#method-PredictMetaLayer-openAccess"><code>PredictMetaLayer$openAccess()</code></a>
</p>
</li>
<li> <p><a href="#method-PredictMetaLayer-closeAccess"><code>PredictMetaLayer$closeAccess()</code></a>
</p>
</li>
<li> <p><a href="#method-PredictMetaLayer-getAccess"><code>PredictMetaLayer$getAccess()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="add2HashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-add2HashTable'><code>fuseMLR::HashTable$add2HashTable()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="checkClassExist"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-checkClassExist'><code>fuseMLR::HashTable$checkClassExist()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getFromHashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getFromHashTable'><code>fuseMLR::HashTable$getFromHashTable()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getHashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getHashTable'><code>fuseMLR::HashTable$getHashTable()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getId"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getId'><code>fuseMLR::HashTable$getId()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getKeyClass"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getKeyClass'><code>fuseMLR::HashTable$getKeyClass()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="removeFromHashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-removeFromHashTable'><code>fuseMLR::HashTable$removeFromHashTable()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PredictMetaLayer-new"></a>



<h4>Method <code>new()</code></h4>

<p>constructor
</p>


<h5>Usage</h5>

<div class="r"><pre>PredictMetaLayer$new(id, predicting)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character</code><br /></p>
</dd>
<dt><code>predicting</code></dt><dd><p><code>Predicting</code><br /></p>
</dd>
</dl>

</div>


<hr>
<a id="method-PredictMetaLayer-print"></a>



<h4>Method <code>print()</code></h4>

<p>Printer
</p>


<h5>Usage</h5>

<div class="r"><pre>PredictMetaLayer$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p><code>any</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-PredictMetaLayer-getPredicting"></a>



<h4>Method <code>getPredicting()</code></h4>

<p>Getter of the current predicting object
</p>


<h5>Usage</h5>

<div class="r"><pre>PredictMetaLayer$getPredicting()</pre></div>



<h5>Returns</h5>

<p>The current predicting object is returned.
</p>


<hr>
<a id="method-PredictMetaLayer-getIndIDs"></a>



<h4>Method <code>getIndIDs()</code></h4>

<p>Getter of IDS from the current layer.
</p>


<h5>Usage</h5>

<div class="r"><pre>PredictMetaLayer$getIndIDs()</pre></div>



<h5>Returns</h5>

<p>A <code>data.frame</code> containing individuals IDs values.
</p>


<hr>
<a id="method-PredictMetaLayer-getPredictData"></a>



<h4>Method <code>getPredictData()</code></h4>

<p>Getter of the predicted data.
</p>


<h5>Usage</h5>

<div class="r"><pre>PredictMetaLayer$getPredictData()</pre></div>



<h5>Returns</h5>

<p>The stored <a href="#topic+PredictData">PredictData</a> object is returned.
</p>


<hr>
<a id="method-PredictMetaLayer-openAccess"></a>



<h4>Method <code>openAccess()</code></h4>

<p>Open access to the meta layer. A meta learner is only
modifiable if the access is opened.
</p>


<h5>Usage</h5>

<div class="r"><pre>PredictMetaLayer$openAccess()</pre></div>


<hr>
<a id="method-PredictMetaLayer-closeAccess"></a>



<h4>Method <code>closeAccess()</code></h4>

<p>Close access to the meta layer to avoid accidental
modification.
</p>


<h5>Usage</h5>

<div class="r"><pre>PredictMetaLayer$closeAccess()</pre></div>


<hr>
<a id="method-PredictMetaLayer-getAccess"></a>



<h4>Method <code>getAccess()</code></h4>

<p>Getter of the current access to the meta layer.
</p>


<h5>Usage</h5>

<div class="r"><pre>PredictMetaLayer$getAccess()</pre></div>



<hr>
<h2 id='summary.Testing'>Testing object Summaries</h2><span id='topic+summary.Testing'></span>

<h3>Description</h3>

<p>Summaries a <code>fuseMLR</code> <a href="#topic+Testing">Testing</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Testing'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.Testing_+3A_object">object</code></td>
<td>
<p><code>Testing</code> <br />
The <a href="#topic+Testing">Testing</a> object of interest.</p>
</td></tr>
<tr><td><code id="summary.Testing_+3A_...">...</code></td>
<td>
<p><code>any</code> <br />
Further arguments.</p>
</td></tr>
</table>

<hr>
<h2 id='summary.Training'>Training object Summaries</h2><span id='topic+summary.Training'></span>

<h3>Description</h3>

<p>Summaries a <code>fuseMLR</code> <a href="#topic+Training">Training</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Training'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.Training_+3A_object">object</code></td>
<td>
<p><code>Training</code> <br />
The <a href="#topic+Training">Training</a> object of interest.</p>
</td></tr>
<tr><td><code id="summary.Training_+3A_...">...</code></td>
<td>
<p><code>any</code> <br />
Further arguments.</p>
</td></tr>
</table>

<hr>
<h2 id='Target'>Target Class</h2><span id='topic+Target'></span>

<h3>Description</h3>

<p>This class implements the target object. A <a href="#topic+Target">Target</a> object can only
exist as a component of a <a href="#topic+Training">Training</a> object.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Data">fuseMLR::Data</a></code> -&gt; <code>Target</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Target-new"><code>Target$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Target-print"><code>Target$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Target-summary"><code>Target$summary()</code></a>
</p>
</li>
<li> <p><a href="#method-Target-getData"><code>Target$getData()</code></a>
</p>
</li>
<li> <p><a href="#method-Target-getTargetValues"><code>Target$getTargetValues()</code></a>
</p>
</li>
<li> <p><a href="#method-Target-getTargetName"><code>Target$getTargetName()</code></a>
</p>
</li>
<li> <p><a href="#method-Target-getTraining"><code>Target$getTraining()</code></a>
</p>
</li>
<li> <p><a href="#method-Target-setData"><code>Target$setData()</code></a>
</p>
</li>
<li> <p><a href="#method-Target-clone"><code>Target$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="getCompleteData"><a href='../../fuseMLR/html/Data.html#method-Data-getCompleteData'><code>fuseMLR::Data$getCompleteData()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="getDataFrame"><a href='../../fuseMLR/html/Data.html#method-Data-getDataFrame'><code>fuseMLR::Data$getDataFrame()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="getId"><a href='../../fuseMLR/html/Data.html#method-Data-getId'><code>fuseMLR::Data$getId()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="getIndCol"><a href='../../fuseMLR/html/Data.html#method-Data-getIndCol'><code>fuseMLR::Data$getIndCol()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="getIndSubset"><a href='../../fuseMLR/html/Data.html#method-Data-getIndSubset'><code>fuseMLR::Data$getIndSubset()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="getSetDiff"><a href='../../fuseMLR/html/Data.html#method-Data-getSetDiff'><code>fuseMLR::Data$getSetDiff()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="getVarSubset"><a href='../../fuseMLR/html/Data.html#method-Data-getVarSubset'><code>fuseMLR::Data$getVarSubset()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="impute"><a href='../../fuseMLR/html/Data.html#method-Data-impute'><code>fuseMLR::Data$impute()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="setDataFrame"><a href='../../fuseMLR/html/Data.html#method-Data-setDataFrame'><code>fuseMLR::Data$setDataFrame()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Target-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize a new object from the current class.
</p>


<h5>Usage</h5>

<div class="r"><pre>Target$new(id, data_frame, training)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character</code> <br />
The Object ID.</p>
</dd>
<dt><code>data_frame</code></dt><dd><p><code>data.frame</code><br />
<code>data.frame</code> containing data.</p>
</dd>
<dt><code>training</code></dt><dd><p><code>Training</code> <br />
Training where to store the current object.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Target-print"></a>



<h4>Method <code>print()</code></h4>

<p>Printer
</p>


<h5>Usage</h5>

<div class="r"><pre>Target$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p><code>any</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-Target-summary"></a>



<h4>Method <code>summary()</code></h4>

<p>Summary
</p>


<h5>Usage</h5>

<div class="r"><pre>Target$summary(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p><code>any</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-Target-getData"></a>



<h4>Method <code>getData()</code></h4>

<p>Getter of the current <code>data.frame</code> wihtout individual
ID nor target variables.
</p>


<h5>Usage</h5>

<div class="r"><pre>Target$getData()</pre></div>



<h5>Returns</h5>

<p>The <code>data.frame</code> without individual ID nor target variables is returned.
</p>


<hr>
<a id="method-Target-getTargetValues"></a>



<h4>Method <code>getTargetValues()</code></h4>

<p>Getter of target values stored on the current training layer.
</p>


<h5>Usage</h5>

<div class="r"><pre>Target$getTargetValues()</pre></div>



<h5>Returns</h5>

<p>The observed target values stored on the current training layer are returned.
</p>


<hr>
<a id="method-Target-getTargetName"></a>



<h4>Method <code>getTargetName()</code></h4>

<p>Getter of the target variable name.
</p>


<h5>Usage</h5>

<div class="r"><pre>Target$getTargetName()</pre></div>


<hr>
<a id="method-Target-getTraining"></a>



<h4>Method <code>getTraining()</code></h4>

<p>Getter of the current training object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Target$getTraining()</pre></div>



<h5>Returns</h5>

<p>The training layer (from class <a href="#topic+Training">Training</a>) on which the current train data are stored
is returned.
</p>


<hr>
<a id="method-Target-setData"></a>



<h4>Method <code>setData()</code></h4>

<p>Getter of the current <code>data.frame</code> wihtout individual
ID nor target variables.
</p>


<h5>Usage</h5>

<div class="r"><pre>Target$setData(data_frame)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data_frame</code></dt><dd><p><code>data.frame</code> <br />
data.frame to be set.
</p>
<p>Title</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Target-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Target$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><a href="#topic+TrainLayer">TrainLayer</a>, <a href="#topic+Lrner">Lrner</a>, <a href="#topic+Model">Model</a>, <a href="#topic+TestData">TestData</a>
</p>

<hr>
<h2 id='TestData'>TestData Class</h2><span id='topic+TestData'></span>

<h3>Description</h3>

<p>This class implements <a href="#topic+TestData">TestData</a> object to be predicted.
A <a href="#topic+TestData">TestData</a> object can only exist as a component of a <a href="#topic+TestLayer">TestLayer</a> or a <a href="#topic+TestMetaLayer">TestMetaLayer</a> object.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Data">fuseMLR::Data</a></code> -&gt; <code>TestData</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TestData-new"><code>TestData$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TestData-print"><code>TestData$print()</code></a>
</p>
</li>
<li> <p><a href="#method-TestData-getData"><code>TestData$getData()</code></a>
</p>
</li>
<li> <p><a href="#method-TestData-getTestLayer"><code>TestData$getTestLayer()</code></a>
</p>
</li>
<li> <p><a href="#method-TestData-clone"><code>TestData$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="getCompleteData"><a href='../../fuseMLR/html/Data.html#method-Data-getCompleteData'><code>fuseMLR::Data$getCompleteData()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="getDataFrame"><a href='../../fuseMLR/html/Data.html#method-Data-getDataFrame'><code>fuseMLR::Data$getDataFrame()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="getId"><a href='../../fuseMLR/html/Data.html#method-Data-getId'><code>fuseMLR::Data$getId()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="getIndCol"><a href='../../fuseMLR/html/Data.html#method-Data-getIndCol'><code>fuseMLR::Data$getIndCol()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="getIndSubset"><a href='../../fuseMLR/html/Data.html#method-Data-getIndSubset'><code>fuseMLR::Data$getIndSubset()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="getSetDiff"><a href='../../fuseMLR/html/Data.html#method-Data-getSetDiff'><code>fuseMLR::Data$getSetDiff()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="getVarSubset"><a href='../../fuseMLR/html/Data.html#method-Data-getVarSubset'><code>fuseMLR::Data$getVarSubset()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="impute"><a href='../../fuseMLR/html/Data.html#method-Data-impute'><code>fuseMLR::Data$impute()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="setDataFrame"><a href='../../fuseMLR/html/Data.html#method-Data-setDataFrame'><code>fuseMLR::Data$setDataFrame()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TestData-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize a new object from the current class.
</p>


<h5>Usage</h5>

<div class="r"><pre>TestData$new(id, data_frame, new_layer)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character</code> <br />
Object ID.</p>
</dd>
<dt><code>data_frame</code></dt><dd><p><code>data.frame</code><br />
<code>data.frame</code> containing data.</p>
</dd>
<dt><code>new_layer</code></dt><dd><p><code>TestLayer</code> <br />
Layer where to store the current object.</p>
</dd>
<dt><code>ind_col</code></dt><dd><p><code>character</code><br />
Column name containing individual IDs.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TestData-print"></a>



<h4>Method <code>print()</code></h4>

<p>Printer
</p>


<h5>Usage</h5>

<div class="r"><pre>TestData$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p><code>any</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-TestData-getData"></a>



<h4>Method <code>getData()</code></h4>

<p>Getter of the current <code>data.frame</code> wihtout individual
ID variable.
</p>


<h5>Usage</h5>

<div class="r"><pre>TestData$getData()</pre></div>



<h5>Returns</h5>

<p>The <code>data.frame</code> without individual ID nor target variables is returned.
</p>


<hr>
<a id="method-TestData-getTestLayer"></a>



<h4>Method <code>getTestLayer()</code></h4>

<p>Getter of the current layer.
</p>


<h5>Usage</h5>

<div class="r"><pre>TestData$getTestLayer()</pre></div>



<h5>Returns</h5>

<p>The layer (from class <a href="#topic+TestLayer">TestLayer</a>) on which the current train data are stored
is returned.
</p>


<hr>
<a id="method-TestData-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TestData$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><a href="#topic+TrainData">TrainData</a>
</p>

<hr>
<h2 id='Testing'>Testing Class</h2><span id='topic+Testing'></span>

<h3>Description</h3>

<p>This is a primary classes of fuseMLR. An object from this class
is designed to contain multiple layers, but only one new meta layer.
</p>
<p>A Testing object is structured as followed:
</p>

<ul>
<li> <p><a href="#topic+TestLayer">TestLayer</a>
</p>
</li>
<li> <p><a href="#topic+TestMetaLayer">TestMetaLayer</a>
</p>
</li></ul>



<h3>Super class</h3>

<p><code><a href="#topic+HashTable">fuseMLR::HashTable</a></code> -&gt; <code>Testing</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Testing-new"><code>Testing$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Testing-print"><code>Testing$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Testing-getIndIDs"><code>Testing$getIndIDs()</code></a>
</p>
</li>
<li> <p><a href="#method-Testing-getTestMetaLayer"><code>Testing$getTestMetaLayer()</code></a>
</p>
</li>
<li> <p><a href="#method-Testing-getIndCol"><code>Testing$getIndCol()</code></a>
</p>
</li>
<li> <p><a href="#method-Testing-getVerbose"><code>Testing$getVerbose()</code></a>
</p>
</li>
<li> <p><a href="#method-Testing-getData"><code>Testing$getData()</code></a>
</p>
</li>
<li> <p><a href="#method-Testing-upset"><code>Testing$upset()</code></a>
</p>
</li>
<li> <p><a href="#method-Testing-summary"><code>Testing$summary()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="add2HashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-add2HashTable'><code>fuseMLR::HashTable$add2HashTable()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="checkClassExist"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-checkClassExist'><code>fuseMLR::HashTable$checkClassExist()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getFromHashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getFromHashTable'><code>fuseMLR::HashTable$getFromHashTable()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getHashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getHashTable'><code>fuseMLR::HashTable$getHashTable()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getId"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getId'><code>fuseMLR::HashTable$getId()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getKeyClass"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getKeyClass'><code>fuseMLR::HashTable$getKeyClass()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="removeFromHashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-removeFromHashTable'><code>fuseMLR::HashTable$removeFromHashTable()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Testing-new"></a>



<h4>Method <code>new()</code></h4>

<p>constructor
</p>


<h5>Usage</h5>

<div class="r"><pre>Testing$new(id, ind_col, verbose = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character</code><br />
Testing id.</p>
</dd>
<dt><code>ind_col</code></dt><dd><p><code>character</code>
Name of column of individuals IDS in testing data.frame.</p>
</dd>
<dt><code>verbose</code></dt><dd><p><code>boolean</code> <br />
Warning messages will be displayed if set to TRUE.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Testing-print"></a>



<h4>Method <code>print()</code></h4>

<p>Printer
</p>


<h5>Usage</h5>

<div class="r"><pre>Testing$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p><code>any</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-Testing-getIndIDs"></a>



<h4>Method <code>getIndIDs()</code></h4>

<p>Gather individual IDs from all layer.
</p>


<h5>Usage</h5>

<div class="r"><pre>Testing$getIndIDs()</pre></div>



<h5>Returns</h5>

<p>A <code>data.frame</code> containing individuals IDs.
</p>


<hr>
<a id="method-Testing-getTestMetaLayer"></a>



<h4>Method <code>getTestMetaLayer()</code></h4>

<p>Getter of the meta layer.
</p>


<h5>Usage</h5>

<div class="r"><pre>Testing$getTestMetaLayer()</pre></div>



<h5>Returns</h5>

<p>Object from class <a href="#topic+TestMetaLayer">TestMetaLayer</a>
</p>


<hr>
<a id="method-Testing-getIndCol"></a>



<h4>Method <code>getIndCol()</code></h4>

<p>Getter of the individual column name.
</p>


<h5>Usage</h5>

<div class="r"><pre>Testing$getIndCol()</pre></div>


<hr>
<a id="method-Testing-getVerbose"></a>



<h4>Method <code>getVerbose()</code></h4>

<p>Getter of the verbose setting.
</p>


<h5>Usage</h5>

<div class="r"><pre>Testing$getVerbose()</pre></div>


<hr>
<a id="method-Testing-getData"></a>



<h4>Method <code>getData()</code></h4>

<p>Retrieve modality-specific prediction data.
</p>


<h5>Usage</h5>

<div class="r"><pre>Testing$getData()</pre></div>



<h5>Returns</h5>

<p>A <code>list</code> containing all (base and meta) models.
</p>


<hr>
<a id="method-Testing-upset"></a>



<h4>Method <code>upset()</code></h4>

<p>UpSet plot to show an overview of the overlap of individuals across various layers.
</p>


<h5>Usage</h5>

<div class="r"><pre>Testing$upset(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p><code>any</code> <br />
Further parameters to be passed to the the <code>upset</code> function from package <code>UpSetR</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Testing-summary"></a>



<h4>Method <code>summary()</code></h4>

<p>Generate testing summary
</p>


<h5>Usage</h5>

<div class="r"><pre>Testing$summary()</pre></div>




<h3>See Also</h3>

<p><a href="#topic+TrainLayer">TrainLayer</a>
</p>

<hr>
<h2 id='TestLayer'>TestLayer Class</h2><span id='topic+TestLayer'></span>

<h3>Description</h3>

<p>This class implements a layer. A <a href="#topic+TestLayer">TestLayer</a> object can only exist as a component of a <a href="#topic+Predicting">Predicting</a> object.
</p>
<p>A predicted layer can only contain <a href="#topic+TestData">TestData</a>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+HashTable">fuseMLR::HashTable</a></code> -&gt; <code>TestLayer</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TestLayer-new"><code>TestLayer$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TestLayer-print"><code>TestLayer$print()</code></a>
</p>
</li>
<li> <p><a href="#method-TestLayer-getTesting"><code>TestLayer$getTesting()</code></a>
</p>
</li>
<li> <p><a href="#method-TestLayer-getIndIDs"><code>TestLayer$getIndIDs()</code></a>
</p>
</li>
<li> <p><a href="#method-TestLayer-getTestData"><code>TestLayer$getTestData()</code></a>
</p>
</li>
<li> <p><a href="#method-TestLayer-checkTestDataExist"><code>TestLayer$checkTestDataExist()</code></a>
</p>
</li>
<li> <p><a href="#method-TestLayer-summary"><code>TestLayer$summary()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="add2HashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-add2HashTable'><code>fuseMLR::HashTable$add2HashTable()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="checkClassExist"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-checkClassExist'><code>fuseMLR::HashTable$checkClassExist()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getFromHashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getFromHashTable'><code>fuseMLR::HashTable$getFromHashTable()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getHashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getHashTable'><code>fuseMLR::HashTable$getHashTable()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getId"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getId'><code>fuseMLR::HashTable$getId()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getKeyClass"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getKeyClass'><code>fuseMLR::HashTable$getKeyClass()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="removeFromHashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-removeFromHashTable'><code>fuseMLR::HashTable$removeFromHashTable()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TestLayer-new"></a>



<h4>Method <code>new()</code></h4>

<p>constructor
</p>


<h5>Usage</h5>

<div class="r"><pre>TestLayer$new(id, testing)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character</code><br />
Testing layer id.</p>
</dd>
<dt><code>testing</code></dt><dd><p><code>Testing</code><br /></p>
</dd>
</dl>

</div>


<hr>
<a id="method-TestLayer-print"></a>



<h4>Method <code>print()</code></h4>

<p>Printer
</p>


<h5>Usage</h5>

<div class="r"><pre>TestLayer$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p><code>any</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-TestLayer-getTesting"></a>



<h4>Method <code>getTesting()</code></h4>

<p>Getter of the current Testing object.
</p>


<h5>Usage</h5>

<div class="r"><pre>TestLayer$getTesting()</pre></div>



<h5>Returns</h5>

<p>The current Testing object is returned.
</p>


<hr>
<a id="method-TestLayer-getIndIDs"></a>



<h4>Method <code>getIndIDs()</code></h4>

<p>Getter of IDS from the current layer.
</p>


<h5>Usage</h5>

<div class="r"><pre>TestLayer$getIndIDs()</pre></div>



<h5>Returns</h5>

<p>A <code>data.frame</code> containing individuals IDs values.
</p>


<hr>
<a id="method-TestLayer-getTestData"></a>



<h4>Method <code>getTestData()</code></h4>

<p>Getter of the predicted data stored on the current layer.
</p>


<h5>Usage</h5>

<div class="r"><pre>TestLayer$getTestData()</pre></div>



<h5>Returns</h5>

<p>The stored <a href="#topic+TestData">TestData</a> object is returned.
</p>


<hr>
<a id="method-TestLayer-checkTestDataExist"></a>



<h4>Method <code>checkTestDataExist()</code></h4>

<p>Check whether a new data has been already stored.
</p>


<h5>Usage</h5>

<div class="r"><pre>TestLayer$checkTestDataExist()</pre></div>



<h5>Returns</h5>

<p>Boolean value
</p>


<hr>
<a id="method-TestLayer-summary"></a>



<h4>Method <code>summary()</code></h4>

<p>Generate summary.
</p>


<h5>Usage</h5>

<div class="r"><pre>TestLayer$summary()</pre></div>




<h3>See Also</h3>

<p><a href="#topic+Training">Training</a>, <a href="#topic+Lrner">Lrner</a>, <a href="#topic+TrainData">TrainData</a>, <a href="#topic+TestData">TestData</a> and <a href="#topic+Model">Model</a>
</p>

<hr>
<h2 id='TestMetaLayer'>TestMetaLayer Class</h2><span id='topic+TestMetaLayer'></span>

<h3>Description</h3>

<p>This class implement a predicted meta layer. A <a href="#topic+TestMetaLayer">TestMetaLayer</a> can only exist as unique element of a <a href="#topic+Training">Training</a> object.
</p>
<p>A predicted meta layer can only contain a <a href="#topic+TestData">TestData</a> object.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+HashTable">fuseMLR::HashTable</a></code> -&gt; <code>TestMetaLayer</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TestMetaLayer-new"><code>TestMetaLayer$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TestMetaLayer-print"><code>TestMetaLayer$print()</code></a>
</p>
</li>
<li> <p><a href="#method-TestMetaLayer-getTesting"><code>TestMetaLayer$getTesting()</code></a>
</p>
</li>
<li> <p><a href="#method-TestMetaLayer-getTestData"><code>TestMetaLayer$getTestData()</code></a>
</p>
</li>
<li> <p><a href="#method-TestMetaLayer-openAccess"><code>TestMetaLayer$openAccess()</code></a>
</p>
</li>
<li> <p><a href="#method-TestMetaLayer-closeAccess"><code>TestMetaLayer$closeAccess()</code></a>
</p>
</li>
<li> <p><a href="#method-TestMetaLayer-getAccess"><code>TestMetaLayer$getAccess()</code></a>
</p>
</li>
<li> <p><a href="#method-TestMetaLayer-setTestData"><code>TestMetaLayer$setTestData()</code></a>
</p>
</li>
<li> <p><a href="#method-TestMetaLayer-checkTestDataExist"><code>TestMetaLayer$checkTestDataExist()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="add2HashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-add2HashTable'><code>fuseMLR::HashTable$add2HashTable()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="checkClassExist"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-checkClassExist'><code>fuseMLR::HashTable$checkClassExist()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getFromHashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getFromHashTable'><code>fuseMLR::HashTable$getFromHashTable()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getHashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getHashTable'><code>fuseMLR::HashTable$getHashTable()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getId"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getId'><code>fuseMLR::HashTable$getId()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getKeyClass"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getKeyClass'><code>fuseMLR::HashTable$getKeyClass()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="removeFromHashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-removeFromHashTable'><code>fuseMLR::HashTable$removeFromHashTable()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TestMetaLayer-new"></a>



<h4>Method <code>new()</code></h4>

<p>constructor
</p>


<h5>Usage</h5>

<div class="r"><pre>TestMetaLayer$new(id, testing)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character</code><br />
Testing meta-layer id.</p>
</dd>
<dt><code>testing</code></dt><dd><p><code>Testing</code><br /></p>
</dd>
</dl>

</div>


<hr>
<a id="method-TestMetaLayer-print"></a>



<h4>Method <code>print()</code></h4>

<p>Printer
</p>


<h5>Usage</h5>

<div class="r"><pre>TestMetaLayer$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p><code>any</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-TestMetaLayer-getTesting"></a>



<h4>Method <code>getTesting()</code></h4>

<p>Getter of the current testing object.
</p>


<h5>Usage</h5>

<div class="r"><pre>TestMetaLayer$getTesting()</pre></div>



<h5>Returns</h5>

<p>The current testing object is returned.
</p>


<hr>
<a id="method-TestMetaLayer-getTestData"></a>



<h4>Method <code>getTestData()</code></h4>

<p>Getter of the training dataset stored on the current layer.
</p>


<h5>Usage</h5>

<div class="r"><pre>TestMetaLayer$getTestData()</pre></div>



<h5>Returns</h5>

<p>The stored <a href="#topic+TestData">TestData</a> object is returned.
</p>


<hr>
<a id="method-TestMetaLayer-openAccess"></a>



<h4>Method <code>openAccess()</code></h4>

<p>Open access to the meta layer. A meta learner is only
modifiable if the access is opened.
</p>


<h5>Usage</h5>

<div class="r"><pre>TestMetaLayer$openAccess()</pre></div>


<hr>
<a id="method-TestMetaLayer-closeAccess"></a>



<h4>Method <code>closeAccess()</code></h4>

<p>Close access to the meta layer to avoid accidental
modification.
</p>


<h5>Usage</h5>

<div class="r"><pre>TestMetaLayer$closeAccess()</pre></div>


<hr>
<a id="method-TestMetaLayer-getAccess"></a>



<h4>Method <code>getAccess()</code></h4>

<p>Getter of the current access to the meta layer.
</p>


<h5>Usage</h5>

<div class="r"><pre>TestMetaLayer$getAccess()</pre></div>


<hr>
<a id="method-TestMetaLayer-setTestData"></a>



<h4>Method <code>setTestData()</code></h4>

<p>Create and set an <a href="#topic+TestData">TestData</a> object to the current
new meta learner.
</p>


<h5>Usage</h5>

<div class="r"><pre>TestMetaLayer$setTestData(id, ind_col, data_frame)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character(1)</code> <br />
ID of the <a href="#topic+TestData">TestData</a> object to be instanciated.</p>
</dd>
<dt><code>ind_col</code></dt><dd><p><code>character(1)</code> <br />
Name of individual column IDs.</p>
</dd>
<dt><code>data_frame</code></dt><dd><p><code>data.frame(1)</code> <br />
<code>data.frame</code> of layer specific predictions.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TestMetaLayer-checkTestDataExist"></a>



<h4>Method <code>checkTestDataExist()</code></h4>

<p>Check whether a new data has been already stored.
</p>


<h5>Usage</h5>

<div class="r"><pre>TestMetaLayer$checkTestDataExist()</pre></div>



<h5>Returns</h5>

<p>Boolean value
</p>



<hr>
<h2 id='TrainData'>TrainData Class</h2><span id='topic+TrainData'></span>

<h3>Description</h3>

<p>This class implements the training data. A <a href="#topic+TrainData">TrainData</a> object can only
exist as a component of a <a href="#topic+TrainLayer">TrainLayer</a> or a <a href="#topic+TrainMetaLayer">TrainMetaLayer</a> object.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Data">fuseMLR::Data</a></code> -&gt; <code>TrainData</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TrainData-new"><code>TrainData$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainData-print"><code>TrainData$print()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainData-summary"><code>TrainData$summary()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainData-getData"><code>TrainData$getData()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainData-getTargetValues"><code>TrainData$getTargetValues()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainData-getTargetName"><code>TrainData$getTargetName()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainData-getTrainLayer"><code>TrainData$getTrainLayer()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainData-getTestLayer"><code>TrainData$getTestLayer()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainData-setDataFrame"><code>TrainData$setDataFrame()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainData-clone"><code>TrainData$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="getCompleteData"><a href='../../fuseMLR/html/Data.html#method-Data-getCompleteData'><code>fuseMLR::Data$getCompleteData()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="getDataFrame"><a href='../../fuseMLR/html/Data.html#method-Data-getDataFrame'><code>fuseMLR::Data$getDataFrame()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="getId"><a href='../../fuseMLR/html/Data.html#method-Data-getId'><code>fuseMLR::Data$getId()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="getIndCol"><a href='../../fuseMLR/html/Data.html#method-Data-getIndCol'><code>fuseMLR::Data$getIndCol()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="getIndSubset"><a href='../../fuseMLR/html/Data.html#method-Data-getIndSubset'><code>fuseMLR::Data$getIndSubset()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="getSetDiff"><a href='../../fuseMLR/html/Data.html#method-Data-getSetDiff'><code>fuseMLR::Data$getSetDiff()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="getVarSubset"><a href='../../fuseMLR/html/Data.html#method-Data-getVarSubset'><code>fuseMLR::Data$getVarSubset()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="Data" data-id="impute"><a href='../../fuseMLR/html/Data.html#method-Data-impute'><code>fuseMLR::Data$impute()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TrainData-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize a new object from the current class.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainData$new(id, data_frame, train_layer)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character</code> <br />
The Object ID.</p>
</dd>
<dt><code>data_frame</code></dt><dd><p><code>data.frame</code><br />
<code>data.frame</code> containing data.</p>
</dd>
<dt><code>train_layer</code></dt><dd><p><code>TrainLayer</code> <br />
Training layer where to store the current object.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TrainData-print"></a>



<h4>Method <code>print()</code></h4>

<p>Printer
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainData$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p><code>any</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-TrainData-summary"></a>



<h4>Method <code>summary()</code></h4>

<p>Summary
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainData$summary(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p><code>any</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-TrainData-getData"></a>



<h4>Method <code>getData()</code></h4>

<p>Getter of the current <code>data.frame</code> wihtout individual
ID nor target variables.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainData$getData()</pre></div>



<h5>Returns</h5>

<p>The <code>data.frame</code> without individual ID nor target variables is returned.
</p>


<hr>
<a id="method-TrainData-getTargetValues"></a>



<h4>Method <code>getTargetValues()</code></h4>

<p>Getter of target values stored on the current training layer.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainData$getTargetValues()</pre></div>



<h5>Returns</h5>

<p>The observed target values stored on the current training layer are returned.
</p>


<hr>
<a id="method-TrainData-getTargetName"></a>



<h4>Method <code>getTargetName()</code></h4>

<p>Getter of the target variable name.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainData$getTargetName()</pre></div>


<hr>
<a id="method-TrainData-getTrainLayer"></a>



<h4>Method <code>getTrainLayer()</code></h4>

<p>Getter of the current training layer.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainData$getTrainLayer()</pre></div>



<h5>Returns</h5>

<p>The training layer (from class <a href="#topic+TrainLayer">TrainLayer</a>) on which the current train data are stored
is returned.
</p>


<hr>
<a id="method-TrainData-getTestLayer"></a>



<h4>Method <code>getTestLayer()</code></h4>

<p>Getter of the current layer.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainData$getTestLayer()</pre></div>



<h5>Returns</h5>

<p>The layer (from class <a href="#topic+TestLayer">TestLayer</a>) on which the current train data are stored
is returned.
</p>


<hr>
<a id="method-TrainData-setDataFrame"></a>



<h4>Method <code>setDataFrame()</code></h4>

<p>Set a new <code>data.frame</code> to the current object.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainData$setDataFrame(data_frame)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data_frame</code></dt><dd><p><code>data.frame</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The current object is returned.
</p>


<hr>
<a id="method-TrainData-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainData$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><a href="#topic+TrainLayer">TrainLayer</a>, <a href="#topic+Lrner">Lrner</a>, <a href="#topic+Model">Model</a>, <a href="#topic+TestData">TestData</a>
</p>

<hr>
<h2 id='Training'>Training Class</h2><span id='topic+Training'></span>

<h3>Description</h3>

<p>This is a primary classes of fuseMLR. An object from this class
is designed to contain multiple training layers, but only one meta training layer.
</p>
<p>The Training class is structured as followed:
</p>

<ul>
<li> <p><a href="#topic+TrainLayer">TrainLayer</a>: Specific layer containing:
</p>

<ul>
<li> <p><a href="#topic+Lrner">Lrner</a>: Specific learner. This must be set by the user.
</p>
</li>
<li> <p><a href="#topic+TrainData">TrainData</a>: Specific training dataset. This must be set up by the user.
</p>
</li>
<li> <p><a href="#topic+Model">Model</a>: Specific model. This is set up by training the learner on the training data.
</p>
</li></ul>

</li>
<li> <p><a href="#topic+TrainMetaLayer">TrainMetaLayer</a>: Basically a <a href="#topic+TrainLayer">TrainLayer</a>, but with some specific properties.
</p>

<ul>
<li> <p><a href="#topic+Lrner">Lrner</a>: This is the meta learner, it must be set up by the user.
</p>
</li>
<li> <p><a href="#topic+TrainData">TrainData</a>: Specific modality-specific prediction data. This is set up internally after cross-validation.
</p>
</li>
<li> <p><a href="#topic+Model">Model</a>: Specific meta model. This is set up by training the learner on the training data.
</p>
</li></ul>

</li></ul>

<p>Use the function <code>train</code> for training and <code>predict</code> for predicting.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+HashTable">fuseMLR::HashTable</a></code> -&gt; <code>Training</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Training-new"><code>Training$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Training-print"><code>Training$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Training-trainLayer"><code>Training$trainLayer()</code></a>
</p>
</li>
<li> <p><a href="#method-Training-predictLayer"><code>Training$predictLayer()</code></a>
</p>
</li>
<li> <p><a href="#method-Training-createMetaTrainData"><code>Training$createMetaTrainData()</code></a>
</p>
</li>
<li> <p><a href="#method-Training-train"><code>Training$train()</code></a>
</p>
</li>
<li> <p><a href="#method-Training-predict"><code>Training$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-Training-varSelection"><code>Training$varSelection()</code></a>
</p>
</li>
<li> <p><a href="#method-Training-getTargetValues"><code>Training$getTargetValues()</code></a>
</p>
</li>
<li> <p><a href="#method-Training-getIndIDs"><code>Training$getIndIDs()</code></a>
</p>
</li>
<li> <p><a href="#method-Training-getLayer"><code>Training$getLayer()</code></a>
</p>
</li>
<li> <p><a href="#method-Training-getTrainMetaLayer"><code>Training$getTrainMetaLayer()</code></a>
</p>
</li>
<li> <p><a href="#method-Training-getModel"><code>Training$getModel()</code></a>
</p>
</li>
<li> <p><a href="#method-Training-getData"><code>Training$getData()</code></a>
</p>
</li>
<li> <p><a href="#method-Training-removeLayer"><code>Training$removeLayer()</code></a>
</p>
</li>
<li> <p><a href="#method-Training-removeTrainMetaLayer"><code>Training$removeTrainMetaLayer()</code></a>
</p>
</li>
<li> <p><a href="#method-Training-getIndCol"><code>Training$getIndCol()</code></a>
</p>
</li>
<li> <p><a href="#method-Training-getTarget"><code>Training$getTarget()</code></a>
</p>
</li>
<li> <p><a href="#method-Training-getVerbose"><code>Training$getVerbose()</code></a>
</p>
</li>
<li> <p><a href="#method-Training-getUseVarSel"><code>Training$getUseVarSel()</code></a>
</p>
</li>
<li> <p><a href="#method-Training-getVarSelDone"><code>Training$getVarSelDone()</code></a>
</p>
</li>
<li> <p><a href="#method-Training-increaseNbTrainedLayer"><code>Training$increaseNbTrainedLayer()</code></a>
</p>
</li>
<li> <p><a href="#method-Training-checkTargetExist"><code>Training$checkTargetExist()</code></a>
</p>
</li>
<li> <p><a href="#method-Training-getTargetObj"><code>Training$getTargetObj()</code></a>
</p>
</li>
<li> <p><a href="#method-Training-getProblemTyp"><code>Training$getProblemTyp()</code></a>
</p>
</li>
<li> <p><a href="#method-Training-setImpute"><code>Training$setImpute()</code></a>
</p>
</li>
<li> <p><a href="#method-Training-testOverlap"><code>Training$testOverlap()</code></a>
</p>
</li>
<li> <p><a href="#method-Training-upset"><code>Training$upset()</code></a>
</p>
</li>
<li> <p><a href="#method-Training-summary"><code>Training$summary()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="add2HashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-add2HashTable'><code>fuseMLR::HashTable$add2HashTable()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="checkClassExist"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-checkClassExist'><code>fuseMLR::HashTable$checkClassExist()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getFromHashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getFromHashTable'><code>fuseMLR::HashTable$getFromHashTable()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getHashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getHashTable'><code>fuseMLR::HashTable$getHashTable()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getId"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getId'><code>fuseMLR::HashTable$getId()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getKeyClass"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getKeyClass'><code>fuseMLR::HashTable$getKeyClass()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="removeFromHashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-removeFromHashTable'><code>fuseMLR::HashTable$removeFromHashTable()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Training-new"></a>



<h4>Method <code>new()</code></h4>

<p>constructor
</p>


<h5>Usage</h5>

<div class="r"><pre>Training$new(
  id,
  ind_col,
  target,
  target_df,
  problem_type = "classification",
  verbose = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character</code> <br /></p>
</dd>
<dt><code>ind_col</code></dt><dd><p><code>character</code> <br />
Name of column of individuals IDS.</p>
</dd>
<dt><code>target</code></dt><dd><p><code>character</code> <br />
Name of the target variable.</p>
</dd>
<dt><code>target_df</code></dt><dd><p><code>data.frame</code> <br />
Data frame with two columns: individual IDs and response variable values.</p>
</dd>
<dt><code>problem_type</code></dt><dd><p><code>character</code> <br />
Either &quot;classification&quot; or &quot;regression&quot;.</p>
</dd>
<dt><code>verbose</code></dt><dd><p><code>boolean</code> <br />
Warning messages will be displayed if set to TRUE.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Training-print"></a>



<h4>Method <code>print()</code></h4>

<p>Printer
</p>


<h5>Usage</h5>

<div class="r"><pre>Training$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p><code>any</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-Training-trainLayer"></a>



<h4>Method <code>trainLayer()</code></h4>

<p>Train each layer of the current Training.
</p>


<h5>Usage</h5>

<div class="r"><pre>Training$trainLayer(ind_subset = NULL, use_var_sel = FALSE, verbose = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ind_subset</code></dt><dd><p><code>character</code><br />
Subset of individuals IDs to be used for training.</p>
</dd>
<dt><code>use_var_sel</code></dt><dd><p><code>boolean</code> <br />
If TRUE, selected variables available at each layer are used.</p>
</dd>
<dt><code>verbose</code></dt><dd><p><code>boolean</code> <br />
Warning messages will be displayed if set to TRUE.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Returns the object itself, with a model for each layer.
</p>


<hr>
<a id="method-Training-predictLayer"></a>



<h4>Method <code>predictLayer()</code></h4>

<p>Predicts values given new data.
</p>


<h5>Usage</h5>

<div class="r"><pre>Training$predictLayer(testing, ind_subset = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>testing</code></dt><dd><p><code>TestData</code> <br />
Object of class <a href="#topic+TestData">TestData</a>.</p>
</dd>
<dt><code>ind_subset</code></dt><dd><p><code>vector</code> <br />
Subset of individuals IDs to be used for training.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <a href="#topic+Training">Training</a> with predicted values for each layer.
</p>


<hr>
<a id="method-Training-createMetaTrainData"></a>



<h4>Method <code>createMetaTrainData()</code></h4>

<p>Creates a meta training dataset and assigns it to the meta layer.
</p>


<h5>Usage</h5>

<div class="r"><pre>Training$createMetaTrainData(
  resampling_method,
  resampling_arg,
  use_var_sel,
  impute = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>resampling_method</code></dt><dd><p><code>function</code> <br />
Function for internal validation.</p>
</dd>
<dt><code>resampling_arg</code></dt><dd><p><code>list</code> <br />
List of arguments to be passed to the function.</p>
</dd>
<dt><code>use_var_sel</code></dt><dd><p><code>boolean</code> <br />
If TRUE, selected variables available at each layer are used.</p>
</dd>
<dt><code>impute</code></dt><dd><p><code>boolean</code> <br />
If TRUE, mode or median based imputation is performed on the modality-specific predictions.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The current object is returned, with a meta training dataset assigned to the meta layer.
</p>


<hr>
<a id="method-Training-train"></a>



<h4>Method <code>train()</code></h4>

<p>Trains the current object. All leaners and the meta learner are trained.
</p>


<h5>Usage</h5>

<div class="r"><pre>Training$train(
  ind_subset = NULL,
  use_var_sel = FALSE,
  resampling_method = NULL,
  resampling_arg = list(),
  seed = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ind_subset</code></dt><dd><p><code>vector</code> <br />
ID subset to be used for training.</p>
</dd>
<dt><code>use_var_sel</code></dt><dd><p><code>boolean</code> <br />
If TRUE, variable selection is performed before training.</p>
</dd>
<dt><code>resampling_method</code></dt><dd><p><code>function</code> <br />
Function for internal validation. If not specify, the <code>resampling</code> function from the package <code>caret</code> is used for a 10-folds cross-validation.</p>
</dd>
<dt><code>resampling_arg</code></dt><dd><p><code>list</code> <br />
List of arguments to be passed to the function.</p>
</dd>
<dt><code>seed</code></dt><dd><p><code>integer</code> <br />
Random seed. Default is NULL, which generates the seed from <code>R</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The current object is returned, with each learner trained on each layer.
</p>


<hr>
<a id="method-Training-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Compute predictions for a testing object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Training$predict(testing, ind_subset = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>testing</code></dt><dd><p><code>Testing</code> <br />
A new testing object to be predicted.</p>
</dd>
<dt><code>ind_subset</code></dt><dd><p><code>vector</code> <br />
Vector of IDs to be predicted.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The predicted object. All layers and the meta layer are predicted. This is the final predicted object.
</p>


<hr>
<a id="method-Training-varSelection"></a>



<h4>Method <code>varSelection()</code></h4>

<p>Variable selection on the current training object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Training$varSelection(ind_subset = NULL, verbose = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ind_subset</code></dt><dd><p><code>vector</code> <br />
ID subset of individuals to be used for variable selection.</p>
</dd>
<dt><code>verbose</code></dt><dd><p><code>boolean</code> <br />
Warning messages will be displayed if set to TRUE.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The current layer is returned with the resulting model.
</p>


<hr>
<a id="method-Training-getTargetValues"></a>



<h4>Method <code>getTargetValues()</code></h4>

<p>Gather target values from all layer.
</p>


<h5>Usage</h5>

<div class="r"><pre>Training$getTargetValues()</pre></div>



<h5>Returns</h5>

<p>A <code>data.frame</code> containing individuals IDs and corresponding target values.
</p>


<hr>
<a id="method-Training-getIndIDs"></a>



<h4>Method <code>getIndIDs()</code></h4>

<p>Gather individual IDs from all layer.
</p>


<h5>Usage</h5>

<div class="r"><pre>Training$getIndIDs()</pre></div>



<h5>Returns</h5>

<p>A <code>data.frame</code> containing individuals IDs.
</p>


<hr>
<a id="method-Training-getLayer"></a>



<h4>Method <code>getLayer()</code></h4>

<p>Get a layer of a given ID.
</p>


<h5>Usage</h5>

<div class="r"><pre>Training$getLayer(id)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character</code> <br />
The ID of the layer to be returned.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The <a href="#topic+TrainLayer">TrainLayer</a> object is returned for the given ID.
</p>


<hr>
<a id="method-Training-getTrainMetaLayer"></a>



<h4>Method <code>getTrainMetaLayer()</code></h4>

<p>Getter of the meta layer.
</p>


<h5>Usage</h5>

<div class="r"><pre>Training$getTrainMetaLayer()</pre></div>



<h5>Returns</h5>

<p>Object from class <a href="#topic+TrainMetaLayer">TrainMetaLayer</a>
</p>


<hr>
<a id="method-Training-getModel"></a>



<h4>Method <code>getModel()</code></h4>

<p>Retrieve models from all layer.
</p>


<h5>Usage</h5>

<div class="r"><pre>Training$getModel()</pre></div>



<h5>Returns</h5>

<p>A <code>list</code> containing all (base and meta) models.
</p>


<hr>
<a id="method-Training-getData"></a>



<h4>Method <code>getData()</code></h4>

<p>Retrieve modality-specific predictions.
</p>


<h5>Usage</h5>

<div class="r"><pre>Training$getData()</pre></div>



<h5>Returns</h5>

<p>A <code>list</code> containing all (base and meta) models.
</p>


<hr>
<a id="method-Training-removeLayer"></a>



<h4>Method <code>removeLayer()</code></h4>

<p>Remove a layer of a given ID.
</p>


<h5>Usage</h5>

<div class="r"><pre>Training$removeLayer(id)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character</code> <br />
The ID of the layer to be removed.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The <a href="#topic+TrainLayer">TrainLayer</a> object is returned for the given ID.
</p>


<hr>
<a id="method-Training-removeTrainMetaLayer"></a>



<h4>Method <code>removeTrainMetaLayer()</code></h4>

<p>Remove the meta layer from the current <a href="#topic+Training">Training</a> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Training$removeTrainMetaLayer()</pre></div>


<hr>
<a id="method-Training-getIndCol"></a>



<h4>Method <code>getIndCol()</code></h4>

<p>Getter of the individual column name.
</p>


<h5>Usage</h5>

<div class="r"><pre>Training$getIndCol()</pre></div>


<hr>
<a id="method-Training-getTarget"></a>



<h4>Method <code>getTarget()</code></h4>

<p>Getter of the target variable name.
</p>


<h5>Usage</h5>

<div class="r"><pre>Training$getTarget()</pre></div>


<hr>
<a id="method-Training-getVerbose"></a>



<h4>Method <code>getVerbose()</code></h4>

<p>Getter of the verbose setting.
</p>


<h5>Usage</h5>

<div class="r"><pre>Training$getVerbose()</pre></div>


<hr>
<a id="method-Training-getUseVarSel"></a>



<h4>Method <code>getUseVarSel()</code></h4>

<p>Getter of the use_var_sel field.
</p>


<h5>Usage</h5>

<div class="r"><pre>Training$getUseVarSel()</pre></div>


<hr>
<a id="method-Training-getVarSelDone"></a>



<h4>Method <code>getVarSelDone()</code></h4>

<p>Getter of the use_var_sel field.
</p>


<h5>Usage</h5>

<div class="r"><pre>Training$getVarSelDone()</pre></div>


<hr>
<a id="method-Training-increaseNbTrainedLayer"></a>



<h4>Method <code>increaseNbTrainedLayer()</code></h4>

<p>Increase the number of trained layer.
</p>


<h5>Usage</h5>

<div class="r"><pre>Training$increaseNbTrainedLayer()</pre></div>


<hr>
<a id="method-Training-checkTargetExist"></a>



<h4>Method <code>checkTargetExist()</code></h4>

<p>Check whether a target object has already been stored.
</p>


<h5>Usage</h5>

<div class="r"><pre>Training$checkTargetExist()</pre></div>



<h5>Returns</h5>

<p>Boolean value
</p>


<hr>
<a id="method-Training-getTargetObj"></a>



<h4>Method <code>getTargetObj()</code></h4>

<p>Getter of the target object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Training$getTargetObj()</pre></div>


<hr>
<a id="method-Training-getProblemTyp"></a>



<h4>Method <code>getProblemTyp()</code></h4>

<p>Getter of the problem type.
</p>


<h5>Usage</h5>

<div class="r"><pre>Training$getProblemTyp()</pre></div>


<hr>
<a id="method-Training-setImpute"></a>



<h4>Method <code>setImpute()</code></h4>

<p>Set imputation action na.action.
</p>


<h5>Usage</h5>

<div class="r"><pre>Training$setImpute(impute)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>impute</code></dt><dd><p><code>character</code> <br />
How to handle missing values.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Training-testOverlap"></a>



<h4>Method <code>testOverlap()</code></h4>

<p>Test that individuals overlap over layers.
At least five individuals must overlapped.
</p>


<h5>Usage</h5>

<div class="r"><pre>Training$testOverlap()</pre></div>


<hr>
<a id="method-Training-upset"></a>



<h4>Method <code>upset()</code></h4>

<p>UpSet plot to show an overview of the overlap of individuals across various layers.
</p>


<h5>Usage</h5>

<div class="r"><pre>Training$upset(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p><code>any</code> <br />
Further parameters to be passed to the <code>upset</code> function from package <code>UpSetR</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Training-summary"></a>



<h4>Method <code>summary()</code></h4>

<p>Generate training summary
</p>


<h5>Usage</h5>

<div class="r"><pre>Training$summary()</pre></div>




<h3>See Also</h3>

<p><a href="#topic+TrainLayer">TrainLayer</a>
</p>
<p><a href="#topic+Testing">Testing</a> and <a href="#topic+Predicting">Predicting</a>
</p>

<hr>
<h2 id='TrainLayer'>TrainLayer Class</h2><span id='topic+TrainLayer'></span>

<h3>Description</h3>

<p>This class implements a traning layer. A <a href="#topic+TrainLayer">TrainLayer</a> object can only exist as a component of a <a href="#topic+Training">Training</a> object.
</p>
<p>A training layer is structured as followed:
</p>

<ul>
<li> <p><a href="#topic+TrainData">TrainData</a>: Data to be used to train the learner.
</p>
</li>
<li> <p><a href="#topic+Lrner">Lrner</a>: Includes a learning function and the package implementing the function.
</p>
</li>
<li> <p><a href="#topic+Model">Model</a>: The result of training the learner on the training data.
</p>
</li>
<li> <p><a href="#topic+VarSel">VarSel</a>: Includes a variable selection function and the package implementing the function.
</p>
</li></ul>

<p>A training layer can train its learner on its training data and store the resulting model. See the public function <code>Layer$train()</code> below.
</p>
<p>A training layer can make predictions for a new layer passed as argument to its predict function. See the public function <code>Layer$predict()</code> below.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+HashTable">fuseMLR::HashTable</a></code> -&gt; <code>TrainLayer</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TrainLayer-new"><code>TrainLayer$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainLayer-print"><code>TrainLayer$print()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainLayer-getTraining"><code>TrainLayer$getTraining()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainLayer-getTargetObj"><code>TrainLayer$getTargetObj()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainLayer-train"><code>TrainLayer$train()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainLayer-varSelection"><code>TrainLayer$varSelection()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainLayer-predict"><code>TrainLayer$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainLayer-getTrainData"><code>TrainLayer$getTrainData()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainLayer-getTargetValues"><code>TrainLayer$getTargetValues()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainLayer-getIndIDs"><code>TrainLayer$getIndIDs()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainLayer-getTestData"><code>TrainLayer$getTestData()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainLayer-getLrner"><code>TrainLayer$getLrner()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainLayer-getVarSel"><code>TrainLayer$getVarSel()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainLayer-getModel"><code>TrainLayer$getModel()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainLayer-checkLrnerExist"><code>TrainLayer$checkLrnerExist()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainLayer-checkModelExist"><code>TrainLayer$checkModelExist()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainLayer-checkVarSelExist"><code>TrainLayer$checkVarSelExist()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainLayer-checkTrainDataExist"><code>TrainLayer$checkTrainDataExist()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainLayer-summary"><code>TrainLayer$summary()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="add2HashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-add2HashTable'><code>fuseMLR::HashTable$add2HashTable()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="checkClassExist"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-checkClassExist'><code>fuseMLR::HashTable$checkClassExist()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getFromHashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getFromHashTable'><code>fuseMLR::HashTable$getFromHashTable()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getHashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getHashTable'><code>fuseMLR::HashTable$getHashTable()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getId"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getId'><code>fuseMLR::HashTable$getId()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getKeyClass"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getKeyClass'><code>fuseMLR::HashTable$getKeyClass()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="removeFromHashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-removeFromHashTable'><code>fuseMLR::HashTable$removeFromHashTable()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TrainLayer-new"></a>



<h4>Method <code>new()</code></h4>

<p>constructor
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainLayer$new(id, training)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character</code><br />
Training layer id.</p>
</dd>
<dt><code>training</code></dt><dd><p><code>Training</code><br /></p>
</dd>
</dl>

</div>


<hr>
<a id="method-TrainLayer-print"></a>



<h4>Method <code>print()</code></h4>

<p>Printer
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainLayer$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p><code>any</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-TrainLayer-getTraining"></a>



<h4>Method <code>getTraining()</code></h4>

<p>Getter of the current training object.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainLayer$getTraining()</pre></div>



<h5>Returns</h5>

<p>The current training object is returned.
</p>


<hr>
<a id="method-TrainLayer-getTargetObj"></a>



<h4>Method <code>getTargetObj()</code></h4>

<p>Getter of the target object.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainLayer$getTargetObj()</pre></div>


<hr>
<a id="method-TrainLayer-train"></a>



<h4>Method <code>train()</code></h4>

<p>Trains the current layer.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainLayer$train(ind_subset = NULL, use_var_sel = FALSE, verbose = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ind_subset</code></dt><dd><p><code>vector</code> <br />
ID subset of individuals to be used for training.</p>
</dd>
<dt><code>use_var_sel</code></dt><dd><p><code>boolean</code> <br />
If TRUE, variable selection is performed before training.</p>
</dd>
<dt><code>verbose</code></dt><dd><p><code>boolean</code> <br />
Warning messages will be displayed if set to TRUE.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The current layer is returned with the resulting model.
</p>


<hr>
<a id="method-TrainLayer-varSelection"></a>



<h4>Method <code>varSelection()</code></h4>

<p>Variable selection on the current layer.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainLayer$varSelection(ind_subset = NULL, verbose = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ind_subset</code></dt><dd><p><code>vector</code> <br />
ID subset of individuals to be used for variable selection.</p>
</dd>
<dt><code>verbose</code></dt><dd><p><code>boolean</code> <br />
Warning messages will be displayed if set to TRUE.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The current layer is returned with the resulting model.
</p>


<hr>
<a id="method-TrainLayer-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Predicts values for the new layer taking as argument.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainLayer$predict(new_layer, use_var_sel, ind_subset = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>new_layer</code></dt><dd><p><code>TrainLayer</code> <br /></p>
</dd>
<dt><code>use_var_sel</code></dt><dd><p><code>boolean</code> <br />
If TRUE, selected variables available at each layer are used.</p>
</dd>
<dt><code>ind_subset</code></dt><dd><p><code>vector</code> <br /></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <a href="#topic+PredictLayer">PredictLayer</a> object with the predicted data is returned.
</p>


<hr>
<a id="method-TrainLayer-getTrainData"></a>



<h4>Method <code>getTrainData()</code></h4>

<p>Getter of the training dataset stored on the current layer.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainLayer$getTrainData()</pre></div>



<h5>Returns</h5>

<p>The stored <a href="#topic+TrainData">TrainData</a> object is returned.
</p>


<hr>
<a id="method-TrainLayer-getTargetValues"></a>



<h4>Method <code>getTargetValues()</code></h4>

<p>Getter of target values from the current layer.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainLayer$getTargetValues()</pre></div>



<h5>Returns</h5>

<p>A <code>data.frame</code> containing individuals IDs and corresponding target values.
</p>


<hr>
<a id="method-TrainLayer-getIndIDs"></a>



<h4>Method <code>getIndIDs()</code></h4>

<p>Getter of IDS from the current layer.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainLayer$getIndIDs()</pre></div>



<h5>Returns</h5>

<p>A <code>data.frame</code> containing individuals IDs values.
</p>


<hr>
<a id="method-TrainLayer-getTestData"></a>



<h4>Method <code>getTestData()</code></h4>

<p>Getter of the new data.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainLayer$getTestData()</pre></div>



<h5>Returns</h5>

<p>The stored <a href="#topic+TestData">TestData</a> object is returned.
</p>


<hr>
<a id="method-TrainLayer-getLrner"></a>



<h4>Method <code>getLrner()</code></h4>

<p>Getter of the learner.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainLayer$getLrner()</pre></div>



<h5>Returns</h5>

<p>The stored <a href="#topic+Lrner">Lrner</a> object is returned.
</p>


<hr>
<a id="method-TrainLayer-getVarSel"></a>



<h4>Method <code>getVarSel()</code></h4>

<p>Getter of the variable selector.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainLayer$getVarSel()</pre></div>



<h5>Returns</h5>

<p>The stored <a href="#topic+VarSel">VarSel</a> object is returned.
</p>


<hr>
<a id="method-TrainLayer-getModel"></a>



<h4>Method <code>getModel()</code></h4>

<p>Getter of the model.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainLayer$getModel()</pre></div>



<h5>Returns</h5>

<p>The stored <a href="#topic+Model">Model</a> object is returned.
</p>


<hr>
<a id="method-TrainLayer-checkLrnerExist"></a>



<h4>Method <code>checkLrnerExist()</code></h4>

<p>Check whether a learner has been already stored.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainLayer$checkLrnerExist()</pre></div>



<h5>Returns</h5>

<p>Boolean value
</p>


<hr>
<a id="method-TrainLayer-checkModelExist"></a>



<h4>Method <code>checkModelExist()</code></h4>

<p>Check whether a model has been already stored.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainLayer$checkModelExist()</pre></div>



<h5>Returns</h5>

<p>Boolean value
</p>


<hr>
<a id="method-TrainLayer-checkVarSelExist"></a>



<h4>Method <code>checkVarSelExist()</code></h4>

<p>Check whether a variable selection tool has been already stored.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainLayer$checkVarSelExist()</pre></div>



<h5>Returns</h5>

<p>Boolean value
</p>


<hr>
<a id="method-TrainLayer-checkTrainDataExist"></a>



<h4>Method <code>checkTrainDataExist()</code></h4>

<p>Check whether a training data has been already stored.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainLayer$checkTrainDataExist()</pre></div>



<h5>Returns</h5>

<p>Boolean value
</p>


<hr>
<a id="method-TrainLayer-summary"></a>



<h4>Method <code>summary()</code></h4>

<p>Generate summary.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainLayer$summary()</pre></div>




<h3>See Also</h3>

<p><a href="#topic+Training">Training</a>, <a href="#topic+Lrner">Lrner</a>, <a href="#topic+TrainData">TrainData</a>, <a href="#topic+TestData">TestData</a> and <a href="#topic+Model">Model</a>
</p>

<hr>
<h2 id='TrainMetaLayer'>TrainMetaLayer Class</h2><span id='topic+TrainMetaLayer'></span>

<h3>Description</h3>

<p>This class implement a meta meta layer. A <a href="#topic+TrainMetaLayer">TrainMetaLayer</a> can only exist as unique element of a <a href="#topic+Training">Training</a> object.
</p>
<p>A layer is structured as followed:
</p>

<ul>
<li> <p><a href="#topic+Lrner">Lrner</a>: It is set by the user to be trained on the meta training data.
</p>
</li>
<li> <p><a href="#topic+TrainData">TrainData</a>: It are modality-specific prediction data, automatically created by the internal cross validation.
</p>
</li>
<li> <p><a href="#topic+Model">Model</a>: The meta model, result of training the learner on the training data, and therefore, not to be set by the user.
</p>
</li>
<li> <p><a href="#topic+TestData">TestData</a>: The meta new data to be predicted, consisting in predictions obtained from each layer.
</p>
</li></ul>

<p>A meta layer can train its meta learner on the meta training data and store the resulting meta model.
The meta layer can predict values given a new meta layer.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+HashTable">fuseMLR::HashTable</a></code> -&gt; <code>TrainMetaLayer</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TrainMetaLayer-new"><code>TrainMetaLayer$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainMetaLayer-print"><code>TrainMetaLayer$print()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainMetaLayer-getTraining"><code>TrainMetaLayer$getTraining()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainMetaLayer-getTargetObj"><code>TrainMetaLayer$getTargetObj()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainMetaLayer-train"><code>TrainMetaLayer$train()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainMetaLayer-predict"><code>TrainMetaLayer$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainMetaLayer-impute"><code>TrainMetaLayer$impute()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainMetaLayer-getTrainData"><code>TrainMetaLayer$getTrainData()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainMetaLayer-getLrner"><code>TrainMetaLayer$getLrner()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainMetaLayer-getModel"><code>TrainMetaLayer$getModel()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainMetaLayer-openAccess"><code>TrainMetaLayer$openAccess()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainMetaLayer-closeAccess"><code>TrainMetaLayer$closeAccess()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainMetaLayer-getAccess"><code>TrainMetaLayer$getAccess()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainMetaLayer-setTrainData"><code>TrainMetaLayer$setTrainData()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainMetaLayer-checkLrnerExist"><code>TrainMetaLayer$checkLrnerExist()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainMetaLayer-checkModelExist"><code>TrainMetaLayer$checkModelExist()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainMetaLayer-checkTrainDataExist"><code>TrainMetaLayer$checkTrainDataExist()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainMetaLayer-set2NotTrained"><code>TrainMetaLayer$set2NotTrained()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainMetaLayer-summary"><code>TrainMetaLayer$summary()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="add2HashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-add2HashTable'><code>fuseMLR::HashTable$add2HashTable()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="checkClassExist"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-checkClassExist'><code>fuseMLR::HashTable$checkClassExist()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getFromHashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getFromHashTable'><code>fuseMLR::HashTable$getFromHashTable()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getHashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getHashTable'><code>fuseMLR::HashTable$getHashTable()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getId"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getId'><code>fuseMLR::HashTable$getId()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="getKeyClass"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-getKeyClass'><code>fuseMLR::HashTable$getKeyClass()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fuseMLR" data-topic="HashTable" data-id="removeFromHashTable"><a href='../../fuseMLR/html/HashTable.html#method-HashTable-removeFromHashTable'><code>fuseMLR::HashTable$removeFromHashTable()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TrainMetaLayer-new"></a>



<h4>Method <code>new()</code></h4>

<p>constructor
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainMetaLayer$new(id, training)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character</code><br />
Id of training meta-layer.</p>
</dd>
<dt><code>training</code></dt><dd><p><code>Training</code><br /></p>
</dd>
</dl>

</div>


<hr>
<a id="method-TrainMetaLayer-print"></a>



<h4>Method <code>print()</code></h4>

<p>Printer
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainMetaLayer$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p><code>any</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-TrainMetaLayer-getTraining"></a>



<h4>Method <code>getTraining()</code></h4>

<p>Getter of the current training object.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainMetaLayer$getTraining()</pre></div>



<h5>Returns</h5>

<p>The current training object is returned.
</p>


<hr>
<a id="method-TrainMetaLayer-getTargetObj"></a>



<h4>Method <code>getTargetObj()</code></h4>

<p>Getter of the target object.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainMetaLayer$getTargetObj()</pre></div>


<hr>
<a id="method-TrainMetaLayer-train"></a>



<h4>Method <code>train()</code></h4>

<p>Trains the current layer.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainMetaLayer$train(ind_subset = NULL, verbose = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ind_subset</code></dt><dd><p><code>vector</code> <br />
ID subset of individuals to be used for training.</p>
</dd>
<dt><code>verbose</code></dt><dd><p><code>boolean</code> <br />
Warning messages will be displayed if set to TRUE.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The current layer is returned with the resulting model.
</p>


<hr>
<a id="method-TrainMetaLayer-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Predicts values for the new layer taking as argument.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainMetaLayer$predict(new_layer, ind_subset = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>new_layer</code></dt><dd><p><code>TrainLayer</code> <br />
A trained TrainLayer object.</p>
</dd>
<dt><code>ind_subset</code></dt><dd><p><code>vector</code> <br />
Index subset.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new object with the predicted values is returned.
</p>


<hr>
<a id="method-TrainMetaLayer-impute"></a>



<h4>Method <code>impute()</code></h4>

<p>Imputes missing values in modality-specific predictions.
Only mode and median based imputations are actually supported.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainMetaLayer$impute(impute_fct = NULL, impute_param = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>impute_fct</code></dt><dd><p><code>character</code> <br />
An imputation function to use instead of median or mode imputation.
This parameter is actually not used.
This corresponds to median or mode based imputation.</p>
</dd>
<dt><code>impute_param</code></dt><dd><p><code>list</code> <br />
The list of parameters to call the imputation function. Not yet implemented!</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new object with the predicted values is returned.
</p>


<hr>
<a id="method-TrainMetaLayer-getTrainData"></a>



<h4>Method <code>getTrainData()</code></h4>

<p>Getter of the training dataset stored on the current layer.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainMetaLayer$getTrainData()</pre></div>



<h5>Returns</h5>

<p>The stored <a href="#topic+TrainData">TrainData</a> object is returned.
</p>


<hr>
<a id="method-TrainMetaLayer-getLrner"></a>



<h4>Method <code>getLrner()</code></h4>

<p>Getter of the learner.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainMetaLayer$getLrner()</pre></div>



<h5>Returns</h5>

<p>The stored <a href="#topic+Lrner">Lrner</a> object is returned.
</p>


<hr>
<a id="method-TrainMetaLayer-getModel"></a>



<h4>Method <code>getModel()</code></h4>

<p>Getter of the model.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainMetaLayer$getModel()</pre></div>



<h5>Returns</h5>

<p>The stored <a href="#topic+Model">Model</a> object is returned.
</p>


<hr>
<a id="method-TrainMetaLayer-openAccess"></a>



<h4>Method <code>openAccess()</code></h4>

<p>Open access to the meta layer. A meta learner is only
modifiable if the access is opened.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainMetaLayer$openAccess()</pre></div>


<hr>
<a id="method-TrainMetaLayer-closeAccess"></a>



<h4>Method <code>closeAccess()</code></h4>

<p>Close access to the meta layer to avoid accidental
modification.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainMetaLayer$closeAccess()</pre></div>


<hr>
<a id="method-TrainMetaLayer-getAccess"></a>



<h4>Method <code>getAccess()</code></h4>

<p>Getter of the current access to the meta layer.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainMetaLayer$getAccess()</pre></div>


<hr>
<a id="method-TrainMetaLayer-setTrainData"></a>



<h4>Method <code>setTrainData()</code></h4>

<p>Create and set an <a href="#topic+TrainData">TrainData</a> object to the current
meta learner.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainMetaLayer$setTrainData(id, ind_col, data_frame)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character</code> <br />
ID of the <a href="#topic+TrainData">TrainData</a> object to be instanciated.</p>
</dd>
<dt><code>ind_col</code></dt><dd><p><code>character</code> <br />
Name of individual column IDs.</p>
</dd>
<dt><code>data_frame</code></dt><dd><p><code>data.frame</code> <br />
<code>data.frame</code> of layer specific predictions.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TrainMetaLayer-checkLrnerExist"></a>



<h4>Method <code>checkLrnerExist()</code></h4>

<p>Check whether a training data has been already stored.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainMetaLayer$checkLrnerExist()</pre></div>



<h5>Returns</h5>

<p>Boolean value
</p>


<hr>
<a id="method-TrainMetaLayer-checkModelExist"></a>



<h4>Method <code>checkModelExist()</code></h4>

<p>Check whether a model has been already stored.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainMetaLayer$checkModelExist()</pre></div>



<h5>Returns</h5>

<p>Boolean value
</p>


<hr>
<a id="method-TrainMetaLayer-checkTrainDataExist"></a>



<h4>Method <code>checkTrainDataExist()</code></h4>

<p>Check whether a training data has been already stored.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainMetaLayer$checkTrainDataExist()</pre></div>



<h5>Returns</h5>

<p>Boolean value
</p>


<hr>
<a id="method-TrainMetaLayer-set2NotTrained"></a>



<h4>Method <code>set2NotTrained()</code></h4>

<p>Only usefull to reset status FALSE after cross validation.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainMetaLayer$set2NotTrained()</pre></div>


<hr>
<a id="method-TrainMetaLayer-summary"></a>



<h4>Method <code>summary()</code></h4>

<p>Generate summary.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainMetaLayer$summary()</pre></div>



<hr>
<h2 id='upsetplot'>upsetplot</h2><span id='topic+upsetplot'></span>

<h3>Description</h3>

<p>An upset plot of overlapping individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upsetplot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="upsetplot_+3A_object">object</code></td>
<td>
<p><code style="white-space: pre;">&#8288;Training or Testing&#8288;</code> <br />
Training or testing object for each the upset plot will be created.</p>
</td></tr>
<tr><td><code id="upsetplot_+3A_...">...</code></td>
<td>
<p><code>any</code> <br />
Further arguments to be passed to the <code>upset</code> function from package <code>UpSetR</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='VarSel'>Varsel Class</h2><span id='topic+VarSel'></span>

<h3>Description</h3>

<p>This class implements a learner. A <a href="#topic+VarSel">VarSel</a> object can only exist as a component of a
<a href="#topic+TrainLayer">TrainLayer</a> or a <a href="#topic+TrainMetaLayer">TrainMetaLayer</a> object.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-VarSel-new"><code>VarSel$new()</code></a>
</p>
</li>
<li> <p><a href="#method-VarSel-print"><code>VarSel$print()</code></a>
</p>
</li>
<li> <p><a href="#method-VarSel-summary"><code>VarSel$summary()</code></a>
</p>
</li>
<li> <p><a href="#method-VarSel-interface"><code>VarSel$interface()</code></a>
</p>
</li>
<li> <p><a href="#method-VarSel-varSelection"><code>VarSel$varSelection()</code></a>
</p>
</li>
<li> <p><a href="#method-VarSel-getTrainLayer"><code>VarSel$getTrainLayer()</code></a>
</p>
</li>
<li> <p><a href="#method-VarSel-getId"><code>VarSel$getId()</code></a>
</p>
</li>
<li> <p><a href="#method-VarSel-getPackage"><code>VarSel$getPackage()</code></a>
</p>
</li>
<li> <p><a href="#method-VarSel-getVarSubSet"><code>VarSel$getVarSubSet()</code></a>
</p>
</li>
<li> <p><a href="#method-VarSel-getParamInterface"><code>VarSel$getParamInterface()</code></a>
</p>
</li>
<li> <p><a href="#method-VarSel-getNaAction"><code>VarSel$getNaAction()</code></a>
</p>
</li>
<li> <p><a href="#method-VarSel-getExtractVar"><code>VarSel$getExtractVar()</code></a>
</p>
</li></ul>


<hr>
<a id="method-VarSel-new"></a>



<h4>Method <code>new()</code></h4>

<p>Variable selection parameter list.
</p>
<p>Learner ID.
</p>


<h5>Usage</h5>

<div class="r"><pre>VarSel$new(
  id,
  package = NULL,
  varsel_fct,
  varsel_param,
  train_layer,
  na_action = "na.rm"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character</code> <br />
Package that implements the variable selection function.
If NULL, the variable selection  function is called from
the current environment.</p>
</dd>
<dt><code>package</code></dt><dd><p><code>character</code> <br />
Variable selection function name. Note: Variable selection functions, except <code>Boruta</code>, must return a vector of selected variables.</p>
</dd>
<dt><code>varsel_fct</code></dt><dd><p><code>character</code> <br />
Variable selection parameters.</p>
</dd>
<dt><code>varsel_param</code></dt><dd><p><code>list</code> <br />
Layer on which the learner is stored.</p>
</dd>
<dt><code>train_layer</code></dt><dd><p><code>TrainLayer</code> <br />
The training layer where to store the learner.</p>
</dd>
<dt><code>na_action</code></dt><dd><p><code>character</code> <br />
Handling of missing values in meta-data. Set to &quot;na.keep&quot; to keep missing values, &quot;na.rm&quot; to remove individuals with missing values or &quot;na.impute&quot; (only applicable on meta-data) to impute missing values in meta-data. Only median and mode based imputations are actually handled. With the &quot;na.keep&quot; option, ensure that the provided learner can handle missing values.
If <code>TRUE</code>, the individuals with missing predictor values will be removed from the training dataset.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-VarSel-print"></a>



<h4>Method <code>print()</code></h4>

<p>Printer
</p>


<h5>Usage</h5>

<div class="r"><pre>VarSel$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p><code>any</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-VarSel-summary"></a>



<h4>Method <code>summary()</code></h4>

<p>Summary
</p>


<h5>Usage</h5>

<div class="r"><pre>VarSel$summary(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p><code>any</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-VarSel-interface"></a>



<h4>Method <code>interface()</code></h4>

<p>Learner and prediction parameter interface. Use this function
to provide how the following parameters are named in the learning
function (<code>lrn_fct</code>) you provided when creating the learner, or in the predicting function.
</p>


<h5>Usage</h5>

<div class="r"><pre>VarSel$interface(
  x = "x",
  y = "y",
  object = "object",
  data = "data",
  extract_var_fct = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p><code>string</code> <br />
Name of the argument to pass the matrix of independent variables in the original learning function.</p>
</dd>
<dt><code>y</code></dt><dd><p><code>string</code> <br />
Name of the argument to pass the response variable in the original learning function.</p>
</dd>
<dt><code>object</code></dt><dd><p><code>string</code> <br />
Name of the argument to pass the model in the original predicting function.</p>
</dd>
<dt><code>data</code></dt><dd><p><code>character</code> <br />
Name of the argument to pass new data in the original predicting function.</p>
</dd>
<dt><code>extract_var_fct</code></dt><dd><p><code>character</code> or <code>function</code> <br />
If the variable selection function that is called does not return a vector, then
use this argument to specify a (or a name of a) function that can be used to extract vector of selected variables.
Default value is NULL, if selected variables are in a vector.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-VarSel-varSelection"></a>



<h4>Method <code>varSelection()</code></h4>

<p>Tains the current learner (from class <a href="#topic+Lrner">Lrner</a>) on the current training data (from class <a href="#topic+TrainData">TrainData</a>).
</p>


<h5>Usage</h5>

<div class="r"><pre>VarSel$varSelection(ind_subset = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ind_subset</code></dt><dd><p><code>vector</code> <br />
Individual ID subset on which the training will be performed.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The resulting model, from class <a href="#topic+Model">Model</a>, is returned.
</p>


<hr>
<a id="method-VarSel-getTrainLayer"></a>



<h4>Method <code>getTrainLayer()</code></h4>

<p>The current layer is returned.
</p>


<h5>Usage</h5>

<div class="r"><pre>VarSel$getTrainLayer()</pre></div>



<h5>Returns</h5>

<p><a href="#topic+TrainLayer">TrainLayer</a> object.
</p>


<hr>
<a id="method-VarSel-getId"></a>



<h4>Method <code>getId()</code></h4>

<p>Getter of the current learner ID.
</p>


<h5>Usage</h5>

<div class="r"><pre>VarSel$getId()</pre></div>



<h5>Returns</h5>

<p>The current learner ID.
</p>


<hr>
<a id="method-VarSel-getPackage"></a>



<h4>Method <code>getPackage()</code></h4>

<p>Getter of the variable selection package implementing the variable selection function.
</p>


<h5>Usage</h5>

<div class="r"><pre>VarSel$getPackage()</pre></div>



<h5>Returns</h5>

<p>The name of the package implementing the variable selection function.
</p>


<hr>
<a id="method-VarSel-getVarSubSet"></a>



<h4>Method <code>getVarSubSet()</code></h4>

<p>Getter of the list of selected variables.
</p>


<h5>Usage</h5>

<div class="r"><pre>VarSel$getVarSubSet()</pre></div>



<h5>Returns</h5>

<p>List of selected variables..
</p>


<hr>
<a id="method-VarSel-getParamInterface"></a>



<h4>Method <code>getParamInterface()</code></h4>

<p>The current parameter interface is returned.
</p>


<h5>Usage</h5>

<div class="r"><pre>VarSel$getParamInterface()</pre></div>



<h5>Returns</h5>

<p>A data.frame of interface.
</p>


<hr>
<a id="method-VarSel-getNaAction"></a>



<h4>Method <code>getNaAction()</code></h4>

<p>The current layer is returned.
</p>


<h5>Usage</h5>

<div class="r"><pre>VarSel$getNaAction()</pre></div>


<hr>
<a id="method-VarSel-getExtractVar"></a>



<h4>Method <code>getExtractVar()</code></h4>

<p>The function to extract selected variables is returned.
</p>


<h5>Usage</h5>

<div class="r"><pre>VarSel$getExtractVar()</pre></div>



<h5>Returns</h5>

<p>A data.frame of interface.
</p>



<hr>
<h2 id='varSelection'>varSelection</h2><span id='topic+varSelection'></span>

<h3>Description</h3>

<p>Variable selection on the training object passed as argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varSelection(training, ind_subset = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varSelection_+3A_training">training</code></td>
<td>
<p><code>Training</code> <br />
Training object for storing the created layer.</p>
</td></tr>
<tr><td><code id="varSelection_+3A_ind_subset">ind_subset</code></td>
<td>
<p><code>vector</code> <br />
ID subset of individuals to be used for variable selection.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with two columns: layer and selected variables.
</p>


<h3>References</h3>

<p>Fouodo C.J.K, Bleskina M. and Szymczak (2024). fuseMLR: An R package for integrative prediction modeling of multi-omics data, paper submitted. <br />
</p>

<hr>
<h2 id='weightedMeanLearner'>The weighted mean meta-learner</h2><span id='topic+weightedMeanLearner'></span>

<h3>Description</h3>

<p>Modality-specific learner are assessed and weighted based on their predictions. This function is intended to be (internally) used as meta-learner in fuseMLR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weightedMeanLearner(x, y, weighted = TRUE, perf = NULL, na_rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weightedMeanLearner_+3A_x">x</code></td>
<td>
<p><code>data.frame</code> <br />
Modality-specific predictions. Each column of the <code>data.frame</code> content the predictions
a specific learner.</p>
</td></tr>
<tr><td><code id="weightedMeanLearner_+3A_y">y</code></td>
<td>
<p><code>vector</code> <br />
True target values. If classification, either binary or two level factor variable.</p>
</td></tr>
<tr><td><code id="weightedMeanLearner_+3A_weighted">weighted</code></td>
<td>
<p><code>boolean</code> <br />
If TRUE, a weighted sum is computed. As default, weights are estimated based on Brier Score
for classification setting and mean squared error for regression. Otherwise, use argument
<code>perf</code> below to specify the function to use estimate learner performance.</p>
</td></tr>
<tr><td><code id="weightedMeanLearner_+3A_perf">perf</code></td>
<td>
<p><code>function</code> <br />
Function to compute layer-specific performance of learners. If NULL, the Brier Score (classification) or a mean squared error (regression) is used by default as performance measure.
Otherwise, the performance function must accept two parameters: <code>observed</code> (observed values) and <code>predicted</code> (predicted values).</p>
</td></tr>
<tr><td><code id="weightedMeanLearner_+3A_na_rm">na_rm</code></td>
<td>
<p><code>boolean</code> <br />
Should missing values be removed when computing the weights?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>weightedMeanLearner</code> with the vector of estimated weights pro layer.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(20240624L)
x = data.frame(x1 = runif(n = 50L, min = 0, max = 1),
               x2 = runif(n = 50L, min = 0, max = 1))
y = sample(x = 0L:1L, size = 50L, replace = TRUE)
my_model = weightedMeanLearner(x = x, y = y)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
