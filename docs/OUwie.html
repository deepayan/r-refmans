<!DOCTYPE html><html lang="en"><head><title>Help for package OUwie</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {OUwie}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check.identify'><p>A test of regime identifiability</p></a></li>
<li><a href='#Example'><p>An example dataset</p></a></li>
<li><a href='#fix.kappa'><p>Adjust tree for matrix condition</p></a></li>
<li><a href='#OUwie'><p>Generalized Hansen models</p></a></li>
<li><a href='#OUwie.anc'><p>Estimate ancestral states given a fitted OUwie model</p></a></li>
<li><a href='#OUwie.boot'><p>Parametric bootstrap function</p></a></li>
<li><a href='#OUwie.contour'><p>Generates data for contour plot of likelihood surface</p></a></li>
<li><a href='#OUwie.dredge'><p>Generalized Detection of shifts in OU process</p></a></li>
<li><a href='#OUwie.fixed'><p>Generalized Hansen model likelihood calculator</p></a></li>
<li><a href='#OUwie.sim'><p>Generalized Hansen model simulator</p></a></li>
<li><a href='#plot.OUwie.contour'><p>Contour plot</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>2.10</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-06-06</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of Evolutionary Rates in an OU Framework</td>
</tr>
<tr>
<td>Author:</td>
<td>Jeremy M. Beaulieu &lt;jmbeauli@uark.edu&gt;, Brian O'Meara &lt;bomeara@utk.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jeremy Beaulieu &lt;jmbeauli@uark.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0), ape, corpcor, nloptr, geiger, RColorBrewer</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph, numDeriv, phytools, paleotree, phangorn, stats, lhs,
interp, grDevices, parallel, phylolm</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimates rates for continuous character evolution under Brownian motion and a new set of Ornstein-Uhlenbeck based Hansen models that allow both the strength of the pull and stochastic motion to vary across selective regimes. Beaulieu et al (2012).</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/thej022214/OUwie">https://github.com/thej022214/OUwie</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-07 12:37:26 UTC; jeremybeaulieu</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-15 09:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='check.identify'>A test of regime identifiability</h2><span id='topic+check.identify'></span>

<h3>Description</h3>

<p>Ho and Ane test for determining whether all regimes form connected subtrees, making both the ancestral state and the regime optima unidentifiable.</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.identify(phy, data, simmap.tree=FALSE, quiet=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check.identify_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree, in <code>ape</code> &ldquo;phylo&rdquo; format and with internal nodes labeled denoting the ancestral selective regimes.</p>
</td></tr>
<tr><td><code id="check.identify_+3A_data">data</code></td>
<td>
<p>a data.frame containing species information (see Details).</p>
</td></tr>
<tr><td><code id="check.identify_+3A_simmap.tree">simmap.tree</code></td>
<td>
<p>a logical indicating whether the input tree is in SIMMAP format. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="check.identify_+3A_quiet">quiet</code></td>
<td>
<p>a logical indicating whether messages should be written to the screen. The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This returns a vector with two elements, with the first being an indicator of identifiability (0=unidentifiable, 1=identifiable, and if <code>get.penalty=TRUE</code>, the second is the penalty used for the modified BIC.</p>


<h3>Author(s)</h3>

<p>Jeremy M. Beaulieu and Brian C. O'Meara</p>


<h3>References</h3>

<p>Ho, L.S.T., and C. Ane. 2014. Intrinsic inference difficulties for trait evolution with Ornstein-Uhlenbeck models. Methods in Ecology and Evolution, 5: 1133-1146.
</p>

<hr>
<h2 id='Example'>An example dataset</h2><span id='topic+tree'></span><span id='topic+trait'></span>

<h3>Description</h3>

<p>An example dataset containing a 64-tip birth-death tree with internal node labels denoting two selective regimes, and a trait file in the proper format: 1) Genus_species, 2) current selective regime, 3) continuous trait data. 
</p>


<h3>Format</h3>

<p>a tree of class &ldquo;phylo&rdquo; and a data frame with 3 columns and 64 rows</p>

<hr>
<h2 id='fix.kappa'>Adjust tree for matrix condition</h2><span id='topic+fix.kappa'></span>

<h3>Description</h3>

<p>Iteratively deletes taxa with shortest tip length to try to get a variance covariance matrix with good matrix condition.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix.kappa(phy, data, threshold = log(40))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fix.kappa_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree, in <code>ape</code> &ldquo;phylo&rdquo; format and with internal nodes labeled denoting the ancestral selective regimes.</p>
</td></tr>
<tr><td><code id="fix.kappa_+3A_data">data</code></td>
<td>
<p>a data.frame containing species information (see Details).</p>
</td></tr>
<tr><td><code id="fix.kappa_+3A_threshold">threshold</code></td>
<td>
<p>log(condition), as measured by kappa(), which is too large</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally, OUwie uses an algorithm that can perform poorly when the variance covariance matrix is poorly conditioned (which can happen if two columns are very similar, as when the divergence depth of two species is very recent). This does not mean there is anything wrong with the biology, just that the numerical algorithms perform poorly in that case. If it's a model that can be fit in phylolm or geiger, those packages use a differnt algorithm that is more robust to this. What this function does is take your original tree and data and deletes taxa with the shortest branches, in order, to try to get a starting tree with generally good condition. Deleting data is always a sad thing, but this can result in a more accurate estimate of the likelihood and parameter values.
</p>


<h3>Value</h3>

<p>This returns a list with two elements:
</p>
<table role = "presentation">
<tr><td><code>$phy</code></td>
<td>
<p>the phylogeny with taxa deleted.</p>
</td></tr>
<tr><td><code>$data</code></td>
<td>
<p>the data with taxa deleted.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brian C. O'Meara</p>

<hr>
<h2 id='OUwie'>Generalized Hansen models</h2><span id='topic+OUwie'></span>

<h3>Description</h3>

<p>Fits generalized Ornstein-Uhlenbeck-based Hansen models of continuous characters evolving under discrete selective regimes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>OUwie(phy, data, model=c("BM1","BMS","OU1","OUM","OUMV","OUMA","OUMVA",
"TrendyM","TrendyMS"), simmap.tree=FALSE, root.age=NULL,scaleHeight=FALSE,
root.station=FALSE, get.root.theta=FALSE, shift.point=0.5, clade=NULL, mserr="none",
starting.vals=NULL, check.identify=TRUE, algorithm=c("invert", "three.point"),
diagn=FALSE, quiet=FALSE, warn=TRUE, lb = NULL, ub = NULL, opts = list(algorithm = 
"NLOPT_LN_SBPLX", maxeval = "1000", ftol_rel = .Machine$double.eps^0.5))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="OUwie_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree, in <code>ape</code> &ldquo;phylo&rdquo; format and with internal nodes labeled denoting the ancestral selective regimes.</p>
</td></tr>
<tr><td><code id="OUwie_+3A_data">data</code></td>
<td>
<p>a data.frame containing species information (see Details).</p>
</td></tr>
<tr><td><code id="OUwie_+3A_model">model</code></td>
<td>
<p>models to fit to comparative data (see Details).</p>
</td></tr>
<tr><td><code id="OUwie_+3A_simmap.tree">simmap.tree</code></td>
<td>
<p>a logical indicating whether the input tree is in SIMMAP format. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="OUwie_+3A_root.age">root.age</code></td>
<td>
<p>indicates the age of the tree. This is to be used in cases where the &quot;tips&quot; are not contemporary, such as in cases for fossil trees. Default is <code>NULL</code> meaning latest tip is modern day.</p>
</td></tr>
<tr><td><code id="OUwie_+3A_scaleheight">scaleHeight</code></td>
<td>
<p>a logical indicating whether the total tree height should be scaled to 1 (see Details). The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="OUwie_+3A_root.station">root.station</code></td>
<td>
<p>a logical indicating whether to assume a random starting point (TRUE) or a fixed starting point (FALSE) (see Details).</p>
</td></tr>
<tr><td><code id="OUwie_+3A_get.root.theta">get.root.theta</code></td>
<td>
<p>a logical indicating whether the starting state, <code class="reqn">\theta_0</code>, should be estimated (see Details).</p>
</td></tr>
<tr><td><code id="OUwie_+3A_shift.point">shift.point</code></td>
<td>
<p>the point along a branch where a regime change is assumed to have occurred (if <code>SIMMAP=FALSE</code>. The default is set to 0.5, or halfway along a branch.</p>
</td></tr>
<tr><td><code id="OUwie_+3A_clade">clade</code></td>
<td>
<p>a list containing a pair of taxa whose MRCA is the clade of interest (see Details).</p>
</td></tr>
<tr><td><code id="OUwie_+3A_mserr">mserr</code></td>
<td>
<p>designates whether a fourth column in the data matrix contains measurement error for each species value (&quot;known&quot;). The measurement error is assumed to be the standard error of the species mean. The default is &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="OUwie_+3A_starting.vals">starting.vals</code></td>
<td>
<p>a vector of initial values for the optimization search. For OU models, two must be supplied, with the first being the initial alpha value and the second being the initial sigma squared. For BM models, just a single value is needed.</p>
</td></tr>
<tr><td><code id="OUwie_+3A_check.identify">check.identify</code></td>
<td>
<p>a logical indicating whether to check that the user-supplied regime paintings will produce identifiable theta estimates. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="OUwie_+3A_algorithm">algorithm</code></td>
<td>
<p>designates whether the standard matrix inversion ('invert') or the faster 'three-point' algorithm of Ho and Ane (2013) should be used.</p>
</td></tr>
<tr><td><code id="OUwie_+3A_diagn">diagn</code></td>
<td>
<p>a logical indicating whether the full diagnostic analysis should be carried out. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="OUwie_+3A_quiet">quiet</code></td>
<td>
<p>a logical indicating whether progress should be written to the screen. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="OUwie_+3A_warn">warn</code></td>
<td>
<p>a logical indicating whether a warning should be printed if the number of parameters exceeds ntips/10. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="OUwie_+3A_lb">lb</code></td>
<td>
<p>if algorithm == &quot;invert&quot; a single value indicating the lower bound for the parameter values. if algorithm == &quot;three.point&quot;, a vector of length 3 with position 1 as alpha lower bound, position 2 as sigma.sq's lower bound, position 3 as theta's lower bound. when set to NULL it will be a default value of 1e-9. Note that even if the model you're using doesn't include alpha (e.g. BM1), it must be included in this vector, but it will not be used to set any bounds.</p>
</td></tr>
<tr><td><code id="OUwie_+3A_ub">ub</code></td>
<td>
<p>if algorithm == &quot;invert&quot; a single value indicating the upper bound for the parameter values. if algorithm == &quot;three.point&quot;, a vector of length 3 with position 1 as alpha upper bound, position 2 as sigma.sq's upper bound, position 3 as theta's upper bound. when set to NULL it will be a default value of 100. Note that even if the model you're using doesn't include alpha (e.g. BM1), it must be included in this vector, but it will not be used to set any bounds.</p>
</td></tr>
<tr><td><code id="OUwie_+3A_opts">opts</code></td>
<td>
<p>a list of options to pass to nloptr for the optimization: useful to adjust for faster, coarser searches</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits various likelihood models for continuous characters evolving under discrete selective regimes. The function returns parameter estimates and their approximate standard errors. The R package <code>nloptr</code> provides a common interface to NLopt, an open-source library for nonlinear optimization. The likelihood function is maximized using the bounded subplex optimization routine (<code>NLOPT_LN_SBPLX</code>). As input all <code>OUwie</code> requires is a tree and a trait data.frame. The tree must be of class &ldquo;phylo&rdquo; and must contain the ancestral selective regimes as internal node labels. Internal node labels can be applied manually or from some sort of ancestral state reconstruction procedure (BayesTraits, <code>ape</code>, <code>diversitree</code>, SIMMAP, etc.), which would then be brought into OUwie. This is essentially what is required by <code>ouch</code> and Brownie (though Brownie provides built-in ancestral state reconstruction capabilities). The trait data.frame must have column entries in the following order: [,1] species names, [,2] current selective regime, and [,3] the continuous trait of interest. Alternatively, if the user wants to incorporate measurement error (<code>mserr</code>=&quot;known&quot;), then a fourth column, [,4] must be included that provides the standard error estimates for each species mean. However, a global measurement error for all taxa can be estimated from the data (<code>mserr</code>=&quot;est&quot;); is not well tested, so use at your own risk. Also, a user can specify a particular clade as being in a different selective regime, by specifying a pair of species whose mrca is the root of the clade of interest [e.g., <code>clade</code>=c(&quot;taxaA&quot;,&quot;taxaB&quot;)]. OUwie will automatically assign internal node labels and update the data matrix according to this clade designation.
</p>
<p>Possible models are as follows: single-rate Brownian motion (<code>model=BM1</code>), Brownian motion with different rate parameters for each state on a tree (<code>model=BMS</code>), Ornstein-Uhlenbeck model with a single optimum for all species (<code>model=OU1</code>), Ornstein-Uhlenbeck model with different state means and a single <code class="reqn">\alpha</code> and <code class="reqn">\sigma^2</code> acting all selective regimes (<code>model=OUM</code>), and new Ornstein-Uhlenbeck models that assume different state means as well as either multiple <code class="reqn">\sigma^2</code> (<code>model=OUMV</code>), multiple <code class="reqn">\alpha</code> (<code>model=OUMA</code>), or multiple <code class="reqn">\alpha</code> and <code class="reqn">\sigma^2</code> per selective regime (<code>model=OUMVA</code>).
</p>
<p>By default, we drop the root optima and absorb the weight into whatever regime the root is in. In previous version we used to incorrectly refer to this as &quot;stationarity&quot;. True stationarity assumes that the starting state comes from a distribution, and the covariance requires an additional variance term to account for the fact that, up until T=0, the lineage is assumed to have been evolving in the ancestral regime. We have added this in for the OU1 and OUM models only (root.station=TRUE).
</p>
<p>Note, too, that when specifying the BMS model also be mindful of the root.station flag. When root.station=FALSE, the non-censored model of O'Meara et al. 2006 is invoked (i.e., a single regime at the root is estimated), and when root.station==TRUE the group mean model of Thomas et al. 2006 (i.e., the number of means equals the number of regimes). The latter case appears to be a strange special case of OU, in that it behaves similarly to the OUMV model, but without selection. I would say that this is more consistent with the censored test of O'Meara et al. (2006), as opposed to having any real connection to OU. In any case, more work is clearly needed to understand the behavior of the group means model, and therefore, I recommend setting root.station=FALSE in the BMS case.
</p>
<p>The Hessian matrix is used as a means to estimate the approximate standard errors of the model parameters and to assess whether they are the maximum likelihood estimates. The variance-covariance matrix of the estimated values of <code class="reqn">\alpha</code> and <code class="reqn">\sigma^2</code> are computed as the inverse of the Hessian matrix and the standard errors are the square roots of the diagonals of this matrix. The Hessian is a matrix of second-order derivatives and is approximated in the R package <code>numDeriv</code>. So, if changes in the value of a parameter results in sharp changes in the slope around the maximum of the log-likelihood function, the second-order derivative will be large, the standard error will be small, and the parameter estimate is considered stable. On the other hand, if the second-order derivative is nearly zero, then the change in the slope around the maximum is also nearly zero, indicating that the parameter value can be moved in any direction without greatly affecting the log-likelihood. In such situations, the standard error of the parameter will be large.
</p>
<p>For models that allow <code class="reqn">\alpha</code> and <code class="reqn">\sigma^2</code> to vary (i.e., <code>OUMV</code>, <code>OUMA</code>, and <code>OUMVA</code>), the complexity of the model can often times be greater than the information that is contained within the data. As a result one or many parameters are poorly estimated, which can cause the function to return a log-likelihood that is suboptimal. This has great potential for poor model choice and incorrect biological interpretations. An eigendecomposition of the Hessian can provide an indication of whether the search returned the maximum likelihood estimates. If all the eigenvalues of the Hessian are positive, then the Hessian is positive definite, and all parameter estimates are considered reliable. However, if there are both positive and negative eigenvalues, then the objective function is at a saddlepoint and one or several parameters cannot be estimated adequately. One solution is to just fit a simpler model. Another is to actually identify the offending parameters. This can be done through the examination of the eigenvectors. The row order corresponds to the entries in <code>index.matrix</code>, the columns correspond to the order of values in <code>eigval</code>, and the larger the value of the row entry the greater the association between the corresponding parameter and the eigenvalue. Thus, the largest values in the columns associated with negative eigenvalues are the parameters that are causing the objective function to be at a saddlepoint.
</p>


<h3>Value</h3>

<p><code>OUwie</code> returns an object of class <code>OUwie</code>. This is a list with elements:
</p>
<table role = "presentation">
<tr><td><code>$loglik</code></td>
<td>
<p>the maximum log-likelihood.</p>
</td></tr>
<tr><td><code>$AIC</code></td>
<td>
<p>Akaike information criterion.</p>
</td></tr>
<tr><td><code>$AICc</code></td>
<td>
<p>Akaike information criterion corrected for sample-size.</p>
</td></tr>
<tr><td><code>$BIC</code></td>
<td>
<p>Bayesian information criterion.</p>
</td></tr>
<tr><td><code>$mBIC</code></td>
<td>
<p>modified Bayesian information criterion of Ho and Ane (2014).</p>
</td></tr>
<tr><td><code>$model</code></td>
<td>
<p>The model being fit.</p>
</td></tr>
<tr><td><code>$param.count</code></td>
<td>
<p>The number of parameters counted in the model.</p>
</td></tr>
<tr><td><code>$solution</code></td>
<td>
<p>a matrix containing the maximum likelihood estimates of <code class="reqn">\alpha</code> and <code class="reqn">\sigma^2</code>.</p>
</td></tr>
<tr><td><code>$theta</code></td>
<td>
<p>a matrix containing the maximum likelihood estimates of <code class="reqn">\theta</code> and its standard error.</p>
</td></tr>
<tr><td><code>$solution.se</code></td>
<td>
<p>a matrix containing the approximate standard errors of <code class="reqn">\alpha</code> and <code class="reqn">\sigma^2</code>. The standard error is calculated as the diagonal of the inverse of the Hessian matrix.</p>
</td></tr>
<tr><td><code>$tot.state</code></td>
<td>
<p>A vector of names for the different regimes</p>
</td></tr>
<tr><td><code>$index.mat</code></td>
<td>
<p>The indices of the parameters being estimated are returned. The numbers correspond to the row in the <code>eigvect</code> and can useful for identifying the parameters that are causing the objective function to be at a saddlepoint (see Details).</p>
</td></tr>
<tr><td><code>$simmap.tree</code></td>
<td>
<p>A logical indicating whether the input phylogeny is a SIMMAP formatted tree.</p>
</td></tr>
<tr><td><code>$root.age</code></td>
<td>
<p>The user-supplied age at the root of the tree.</p>
</td></tr>
<tr><td><code>$split.point</code></td>
<td>
<p>The user-supplied point at which regime changes are assumed to have occurred.</p>
</td></tr>
<tr><td><code>$opts</code></td>
<td>
<p>Internal settings of the likelihood search.</p>
</td></tr>
<tr><td><code>$data</code></td>
<td>
<p>User-supplied dataset.</p>
</td></tr>
<tr><td><code>$phy</code></td>
<td>
<p>User-supplied tree.</p>
</td></tr>
<tr><td><code>$root.station</code></td>
<td>
<p>A logical indicating whether the starting state, <code class="reqn">\theta_0</code>, was estimated.</p>
</td></tr>
<tr><td><code>$starting.vals</code></td>
<td>
<p>A vector of user-supplied initial search parameters.</p>
</td></tr>
<tr><td><code>$lb</code></td>
<td>
<p>The lower bound set.</p>
</td></tr>
<tr><td><code>$ub</code></td>
<td>
<p>The upper bound set.</p>
</td></tr>
<tr><td><code>$iterations</code></td>
<td>
<p>Number of iterations of the likelihood search that were executed.</p>
</td></tr>
<tr><td><code>$get.root.theta</code></td>
<td>
<p>Indicates whether the root.theta was included in the model.</p>
</td></tr>
<tr><td><code>$regime.weights</code></td>
<td>
<p>A table containing parameter estimates and the weights for time spent in each regime for each tip.</p>
</td></tr>
<tr><td><code>$eigval</code></td>
<td>
<p>The eigenvalues from the decomposition of the Hessian of the likelihood function. If any <code>eigval&lt;0</code> then one or more parameters were not optimized during the likelihood search (see Details).</p>
</td></tr>
<tr><td><code>$eigvect</code></td>
<td>
<p>The eigenvectors from the decomposition of the Hessian of the likelihood function is returned (see Details).</p>
</td></tr>
<tr><td><code>$new.start</code></td>
<td>
<p>The vector of values to use if you want to restart the run from this point (starting.vals for a new run).</p>
</td></tr>
<tr><td><code>$algorithm</code></td>
<td>
<p>The algorithm used to estimate parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeremy M. Beaulieu and Brian C. O'Meara</p>


<h3>References</h3>

<p>Beaulieu J.M., Jhwueng D.C., Boettiger C., and O'Meara B.C. 2012. Modeling stabilizing selection: Expanding the Ornstein-Uhlenbeck model of adaptive evolution. Evolution 66:2369-2383.
</p>
<p>O'Meara B.C., Ane C., Sanderson P.C., Wainwright P.C. 2006. Testing for different rates of continuous trait evolution using likelihood. Evolution 60:922-933.
</p>
<p>Butler M.A., King A.A. 2004. Phylogenetic comparative analysis: A modeling approach for adaptive evolution. American Naturalist 164:683-695.
</p>
<p>Ho, L.S.T., and C. Ane. 2014. Intrinsic inference difficulties for trait evolution with Ornstein-Uhlenbeck models. Methods in Ecology and Evolution, 5: 1133-1146.
</p>
<p>Thomas G.H., Freckleton R.P., and Szekely T. 2006. Comparative analysis of the influence of developmental mode on phenotypic diversification rates in shorebirds. Proceedings of the Royal Society, B. 273:1619-1624.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(tworegime)

#Plot the tree and the internal nodes to highlight the selective regimes:
select.reg&lt;-character(length(tree$node.label))
select.reg[tree$node.label == 1] &lt;- "black"
select.reg[tree$node.label == 2] &lt;- "red"
plot(tree)
nodelabels(pch=21, bg=select.reg)



## Not run: 
#To see the first 5 lines of the data matrix to see what how to
#structure the data:
trait[1:5,]

#Now fit an OU model that allows different sigma^2:
OUwie(tree,trait,model=c("OUMV"))

#Fit an OU model based on a clade of interest:
OUwie(tree,trait,model=c("OUMV"), clade=c("t50", "t64"), algorithm="three.point")

#For large trees, it may be useful to have ways to restart the search (due to
#finite time per run on a computing cluster, for example). You can do this
#by changing settings of OUwie runs. For example:

run1 &lt;- OUwie(tree,trait,model=c("OUMV"), root.station=FALSE, algorithm="invert", 
opts = list("algorithm"="NLOPT_LN_SBPLX", "maxeval"="500", "ftol_abs"=0.001))

save(run1, file="run1.rda")

#Then, later or in a different session:

load("run1.rda")

run2 &lt;- OUwie(tree, trait, model=c("OUMV"), algorithm="three.point", 
opts = list("algorithm"="NLOPT_LN_SBPLX", "maxeval"="500", "ftol_abs"=0.001),
starting.vals=run1$new.start)

#run2 will start off where run1 stopped.

## End(Not run)
</code></pre>

<hr>
<h2 id='OUwie.anc'>Estimate ancestral states given a fitted OUwie model</h2><span id='topic+OUwie.anc'></span>

<h3>Description</h3>

<p>Fits ancestral states (a joint estimate) given a fitted OUwie model. Currently, only works for trees with regimes painted on as node labels (rather than a simmap tree). The intended use case is just to visualize what the model is saying about evolution to help intuition (is the model something you can believe in?) rather than a firm estimate you should use to say, Yes, 56.4 MY, the ancestral body size was 17.34 mm. It could likely be anywhere from 1 to 100 mm with about equal chance. Please read details before using this function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>OUwie.anc(fitted.OUwie.object, opts = list("algorithm"="NLOPT_LN_SBPLX",
"maxeval"="1000", "ftol_abs"=0.001), knowledge=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="OUwie.anc_+3A_fitted.ouwie.object">fitted.OUwie.object</code></td>
<td>
<p>an object returned from the OUwie function</p>
</td></tr>
<tr><td><code id="OUwie.anc_+3A_opts">opts</code></td>
<td>
<p>a list of options to pass to nloptr for the ancestral state optimization</p>
</td></tr>
<tr><td><code id="OUwie.anc_+3A_knowledge">knowledge</code></td>
<td>
<p>a logical indicating whether or not you have read the documentation The default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You probably DON'T want to use this function for anything more serious than poking around to make sure the data and model look right (oh, golly: my tips are all between 5 and 15 mm in size, and the ancestral states are 674 mm.). The request to implement ancestral state estimation resulted in many important comments from experts in the public R-SIG-PHYLO discussion forum. Here is a sampling; to see them all, go to <a href="https://www.mail-archive.com/r-sig-phylo@r-project.org/msg05257.html">R-SIG-PHYLO</a>.
</p>
<p>&quot;So in short, yes, you can do it, with any number of methods. But why? If you can answer your biological question with methods that do not involve estimation of a parameter that is inherently fraught with error, it might be better to go another way. Bottom line - use caution and be thoughtful!&quot; &ndash; Marguerite Butler
</p>
<p>&quot;I would add an extra caveat to Marguerite's excellent post: Most researchers work with extant taxa only, ignoring extinction. This causes a massive ascertainment bias, and the character states of the extinct taxa can often be very different to the ancestral state reconstructions, particularly if the evolutionary model is wrong. Eg. there has been an evolutionary trend for example. Ancestral state reconstructions based only on extant taxa should be treated as hypotheses to be tested with fossil data. I wouldn't rely on them for much more.&quot; &ndash; Simone Blomberg
</p>
<p>&quot;While I am at it, let me echo Simone and Marguerite's warnings. The predicted ancestral states will reflect the process you assumed to predict them. Hence, if you  use them to make inferences about evolution, you will recover your own assumptions. I.e. if you predict from a model with no trend, you will find no trend, etc. Many comparative studies are flawed for this reason.&quot; &ndash; Thomas Hansen
</p>
<p>&quot;Let me add more warnings to Marguerite and Thomas's excellent responses. People may be tempted to infer ancestral states and then treat those inferences as data (and also to infer ancestral environments and then treat those inferences as data). In fact, I wonder whether that is not the main use people make of these inferences. But not only are those inferences very noisy, they are correlated with each other. So if you infer the ancestral state for the clade (Old World Monkeys, Apes) and also the ancestral state for the clade (New World Monkeys, (Old World Monkeys, Apes)) the two will typically not only be error-prone, but will also typically be subject to strongly correlated errors.  Using them as data for further inferences is very dubious. It is better to figure out what your hypothesis is and then test it on the data from the tips of the tree, without the intermediate step of taking ancestral state inferences as observations. The popular science press in particular demands a fly-on-the-wall account of what happened in evolution, and giving them the ancestral state inferences as if they were known precisely is a mistake.&quot; &ndash; Joe Felsenstein
</p>
<p>&quot;The minor twist I would throw in is that it's difficult to make universal generalizations about the quality of ancestral state estimation.  If one is interested in the ancestral state value at node N, it might be reasonably estimated if it is nested high up within the phylogeny, if the rates of change aren't high, etc. And (local) trends etc might well be reliably inferred.  We are pretty confident that the common ancestor of humans and chimps was larger than many deeper primate ancestors, for instance. If N is the root of your available phylogeny, however, you have to be much more cautious.&quot; &ndash; Nick Matzke
</p>
<p>&quot;I'll also add that I think there's a great deal to be skeptical of ancestral trait reconstruction even when large amounts of fossil data is available. You can try the exercise yourself: simulate pure BM on a non-ultrametric tree with lots of 'extinct' tips, and you'll still find pretty large confidence intervals on the estimates of the trait values. What does it mean to do ancestral trait reconstruction, if our calculations of uncertainty are that broad?&quot; &ndash; Dave Bapst
</p>
<p>These are some of the people who best know the power and limitations of the OU model in phylogenetics. Heed them!
</p>
<p>To ensure that you've read this before use, please pass knowledge=TRUE as an argument to the function.
</p>


<h3>Value</h3>

<p><code>OUwie.anc</code> returns an object of class <code>OUwie.anc</code>. This is an OUwie object but with terminal species added at each node representing the ancestral states at each node (which are also included in the data object). There is also a <code>NodeRecon</code> element in the list that has the optimal ancestral states. There is not currently an estimate of uncertainty, but it is substantial.
</p>


<h3>Author(s)</h3>

<p>Brian C. O'Meara</p>

<hr>
<h2 id='OUwie.boot'>Parametric bootstrap function</h2><span id='topic+OUwie.boot'></span>

<h3>Description</h3>

<p>A function that performs a parametric bootstrap for a set of user-specified model parameters</p>


<h3>Usage</h3>

<pre><code class='language-R'>OUwie.boot(phy, data, model=c("BM1","BMS","OU1","OUM","OUMV","OUMA","OUMVA"),
 nboot=100, alpha, sigma.sq, theta, theta0, simmap.tree=FALSE, root.age=NULL,
 scaleHeight=FALSE, root.station=FALSE, get.root.theta=FALSE, shift.point=0.5, 
 clade=NULL, mserr="none", algorithm=c("invert", "three.point"), 
 diagn=FALSE, quiet=TRUE, warn=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="OUwie.boot_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree, in <code>ape</code> &ldquo;phylo&rdquo; format and with internal nodes labeled denoting the ancestral selective regimes.</p>
</td></tr>
<tr><td><code id="OUwie.boot_+3A_data">data</code></td>
<td>
<p>a data matrix containing species information.</p>
</td></tr>
<tr><td><code id="OUwie.boot_+3A_model">model</code></td>
<td>
<p>models to fit to comparative data.</p>
</td></tr>
<tr><td><code id="OUwie.boot_+3A_nboot">nboot</code></td>
<td>
<p>The number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="OUwie.boot_+3A_alpha">alpha</code></td>
<td>
<p>a numeric vector giving the values of <code class="reqn">\alpha</code> for each selective regime.</p>
</td></tr>
<tr><td><code id="OUwie.boot_+3A_sigma.sq">sigma.sq</code></td>
<td>
<p>a numeric vector giving the values of <code class="reqn">\sigma^2</code> for each selective regime.</p>
</td></tr> 
<tr><td><code id="OUwie.boot_+3A_theta">theta</code></td>
<td>
<p>a numeric vector giving the values of <code class="reqn">\theta</code> for each selective regime.</p>
</td></tr>
<tr><td><code id="OUwie.boot_+3A_theta0">theta0</code></td>
<td>
<p>a numeric indicating the starting state, <code class="reqn">\theta_0</code></p>
</td></tr>
<tr><td><code id="OUwie.boot_+3A_simmap.tree">simmap.tree</code></td>
<td>
<p>a logical indicating whether the input tree is in SIMMAP format. The default is <code>FALSE</code>.</p>
</td></tr> 
<tr><td><code id="OUwie.boot_+3A_root.age">root.age</code></td>
<td>
<p>indicates the age of the tree. This is to be used in cases where the &quot;tips&quot; are not contemporary, such as in cases for fossil trees. Default is <code>NULL</code> meaning latest tip is modern day.</p>
</td></tr>
<tr><td><code id="OUwie.boot_+3A_get.root.theta">get.root.theta</code></td>
<td>
<p>a logical indicating whether the starting state, <code class="reqn">\theta_0</code>, should be estimated (see Details).</p>
</td></tr>
<tr><td><code id="OUwie.boot_+3A_scaleheight">scaleHeight</code></td>
<td>
<p>a logical indicating whether the total tree height should be scaled to 1 (see Details). The default is <code>FALSE</code>.</p>
</td></tr> 
<tr><td><code id="OUwie.boot_+3A_root.station">root.station</code></td>
<td>
<p>a logical indicating whether the starting state, <code class="reqn">\theta_0</code>, should be estimated (see Details).</p>
</td></tr> 
<tr><td><code id="OUwie.boot_+3A_shift.point">shift.point</code></td>
<td>
<p>the point along a branch where a regime change is assumed to have occurred (if <code>SIMMAP=FALSE</code>. The default is set to 0.5, or halfway along a branch.</p>
</td></tr>
<tr><td><code id="OUwie.boot_+3A_clade">clade</code></td>
<td>
<p>a list containing a pair of taxa whose MRCA is the clade of interest.</p>
</td></tr>
<tr><td><code id="OUwie.boot_+3A_mserr">mserr</code></td>
<td>
<p>designates whether a fourth column in the data matrix contains measurement error for each species value (&quot;known&quot;). The measurement error is assumed to be the standard error of the species mean. The default is &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="OUwie.boot_+3A_algorithm">algorithm</code></td>
<td>
<p>designates whether the standard matrix inversion ('invert') or the faster 'three-point' algorithm of Ho and Ane (2013) should be used.</p>
</td></tr>
<tr><td><code id="OUwie.boot_+3A_diagn">diagn</code></td>
<td>
<p>a logical indicating whether the full diagnostic analysis should be carried out. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="OUwie.boot_+3A_quiet">quiet</code></td>
<td>
<p>a logical indicating whether progress should be written to the screen. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="OUwie.boot_+3A_warn">warn</code></td>
<td>
<p>a logical indicating whether a warning should be printed if the number of parameters exceeds ntips/10. The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simple function for conducting a parametric bootstrap on parameters estimated in OUwie. As before, the input is a tree and a data file. The tree must be of class &ldquo;phylo&rdquo; and if <code>simmap=FALSE</code> must contain the ancestral selective regimes as internal node labels. The data file is a dataframe that must have column entries in the following order: [,1] species names and [,2] their current selective regime. The user specifies the simulated parameter values (i.e. <code class="reqn">\alpha</code>, <code class="reqn">\sigma^2</code>, <code class="reqn">\theta_0</code>, <code class="reqn">\theta</code>), which is assumed to be the maximum likelihood estimates obtained from an OUwie run.
</p>
<p>Note that if <code>root.station</code> is <code>TRUE</code> (the default), <code class="reqn">\theta_0</code> was dropped from the model. In this case, then, <code class="reqn">\theta_0</code> should be set to the value of the selective regime mapped at the root (i.e., state 1 in the &ldquo;tworegime&rdquo; example dataset). 
</p>


<h3>Value</h3>

<p><code>OUwie.boot</code> returns an object of class <code>OUwie.boot</code>. This is a matrix of column length equal to the number of parameters, and row length of the number of bootstrap replicates specified.
</p>


<h3>Author(s)</h3>

<p>Jeremy M. Beaulieu</p>


<h3>References</h3>

<p>Beaulieu J.M., Jhwueng D.C., Boettiger C., and O'Meara B.C. 2012. Modeling stabilizing selection: Expanding the Ornstein-Uhlenbeck model of adaptive evolution. Evolution 66:2369-2383.
</p>
<p>O'Meara B.C., Ane C., Sanderson P.C., Wainwright P.C. 2006. Testing for different rates of continuous trait evolution using likelihood. Evolution 60:922-933.
</p>
<p>Butler M.A., King A.A. 2004. Phylogenetic comparative analysis: A modeling approach for adaptive evolution. American Naturalist 164:683-695.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(tworegime)

##First step is estimate parameters under a particular model:
pp &lt;- OUwie(tree,trait,model=c("OUMV"),root.station=FALSE, algorithm="three.point")

##Second step is to run bootstrap replicates:
boot.reps &lt;- OUwie.boot(tree,trait,model="OUMV", nboot=10, alpha=pp$solution[1,], 
sigma.sq=pp$solution[2,],theta=pp$theta[,1], theta0=pp$theta[1,1], 
algorithm="three.point")

##Finally summarize to obtain the desired confidence -- here is the 95% CI:
apply(boot.reps, 2, quantile, probs=c(0.025,0.975))


</code></pre>

<hr>
<h2 id='OUwie.contour'>Generates data for contour plot of likelihood surface</h2><span id='topic+OUwie.contour'></span>

<h3>Description</h3>

<p>Generates the likelihood surface for pairs of free parameters for generalized Ornstein-Uhlenbeck-based Hansen models of continuous characters evolving under discrete selective regimes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>OUwie.contour(OUwie.obj, focal.params=c("alpha_1", "sigma.sq_1"), 
focal.params.lower=c(0,0), focal.params.upper=c(5,5), nreps=1000, n.cores=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="OUwie.contour_+3A_ouwie.obj">OUwie.obj</code></td>
<td>
<p>an object of class &ldquo;OUwie&rdquo; that contains the focal parameters for conducting the likelihood surface search.</p>
</td></tr>
<tr><td><code id="OUwie.contour_+3A_focal.params">focal.params</code></td>
<td>
<p>a vector specifying the parameters that you would like the likelihood surface. The format is parameter_regime &ndash; that is, for theta in regime 1, the input would be &quot;theta_1&quot;.</p>
</td></tr> 
<tr><td><code id="OUwie.contour_+3A_focal.params.lower">focal.params.lower</code></td>
<td>
<p>a vector specifying the lower bounds for the parameters. The values need to be in the order as the focal parameters.</p>
</td></tr>
<tr><td><code id="OUwie.contour_+3A_focal.params.upper">focal.params.upper</code></td>
<td>
<p>a vector specifying the upper bounds for the parameters. The values need to be in the order as the focal parameters.</p>
</td></tr>
<tr><td><code id="OUwie.contour_+3A_nreps">nreps</code></td>
<td>
<p>the number points to use to estimate the likelihood surface (see Details).</p>
</td></tr>
<tr><td><code id="OUwie.contour_+3A_n.cores">n.cores</code></td>
<td>
<p>specifies the number of independent processors to conduct the analysis. The default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function samples a set of points to estimate the likelihood surface for any pair of parameters, letting the other parameters find their own optima. This process can be very slow, as it involves optimization <code>nrep</code> times (though with two fewer parameters than with the chosen model, as the focal parameter values are fixed). It uses a latin hypercube design to sample points across the user-defined range of the focal parameters.
</p>
<p>The pair of parameters to examine is passed by focal.param. The parameters need to be one of three: theta, alpha, sigma.sq. For example, to do a plot of sigma.sq from the first regime and alpha from the second regime, one would pass <code>focal.param = c( "sigma.sq_1", "alpha_2")</code>. As another example, if the regimes are characters like, flower color, the focal parameter would be <code>focal.param = c( "sigma.sq_Red", "sigma.sq_Blue")</code>. 
</p>
<p>This returns a data.frame with the last two columns being the values of the points examined and the first column the loglik of those points. The first row contains the MLE. The data.frame can be incorporated into a plotting function to obtain a contour plot (see plot.OUwie.contour).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>surface.data</code></td>
<td>
<p>the parameter values and loglik</p>
</td></tr>
<tr><td><code>focal.params</code></td>
<td>
<p>the vector specifying the parameter pair for which likelihood surface is evaluated</p>
</td></tr>
<tr><td><code>focal.params.lower</code></td>
<td>
<p>the vector specifying the lower bounds for the parameter pair.</p>
</td></tr>
<tr><td><code>focal.params.upper</code></td>
<td>
<p>the vector specifying the upper bounds for the parameter pair.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeremy M. Beaulieu</p>


<h3>References</h3>

<p>Beaulieu J.M., Jhwueng D.C., Boettiger C., and O'Meara B.C. 2012. Modeling stabilizing selection: Expanding the Ornstein-Uhlenbeck model of adaptive evolution. Evolution 66:2369-2383.
</p>

<hr>
<h2 id='OUwie.dredge'>Generalized Detection of shifts in OU process</h2><span id='topic+OUwie.dredge'></span>

<h3>Description</h3>

<p>Allows the hypothesis free detection of shifts in the OU process. The number and location of shifts is estimated using a user-specified information criterion.</p>


<h3>Usage</h3>

<pre><code class='language-R'>OUwie.dredge(phy, data, criterion=c("AIC", "AICc", "BIC", "mBIC"), shift.max=3, 
sigma.sq.max.k=3, alpha.max.k=3, root.age=NULL, scaleHeight=FALSE, root.station=FALSE, 
shift.point=0.5, mserr="none", algorithm=c("invert", "three.point"), 
opts = list("algorithm"="NLOPT_LN_SBPLX", "maxeval"="1000", 
"ftol_rel"=.Machine$double.eps^0.5))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="OUwie.dredge_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree, in <code>ape</code> &ldquo;phylo&rdquo; format and with internal nodes labeled denoting the ancestral selective regimes</p>
</td></tr>
<tr><td><code id="OUwie.dredge_+3A_data">data</code></td>
<td>
<p>a dataframe containing two columns, taxon names in the first column, and species trait information in the second column.</p>
</td></tr>
<tr><td><code id="OUwie.dredge_+3A_criterion">criterion</code></td>
<td>
<p>information criterion to use for shift detection.</p>
</td></tr>
<tr><td><code id="OUwie.dredge_+3A_shift.max">shift.max</code></td>
<td>
<p>maximum allowed number of shifts.</p>
</td></tr> 
<tr><td><code id="OUwie.dredge_+3A_sigma.sq.max.k">sigma.sq.max.k</code></td>
<td>
<p>maximum allowed number of sigma.sq parameters.</p>
</td></tr> 
<tr><td><code id="OUwie.dredge_+3A_alpha.max.k">alpha.max.k</code></td>
<td>
<p>maximum allowed number of alpha parameters.</p>
</td></tr> 
<tr><td><code id="OUwie.dredge_+3A_root.age">root.age</code></td>
<td>
<p>indicates the age of the tree. This is to be used in cases where the &quot;tips&quot; are not contemporary, such as in cases for fossil trees. Default is <code>NULL</code> meaning latest tip is modern day.</p>
</td></tr>
<tr><td><code id="OUwie.dredge_+3A_scaleheight">scaleHeight</code></td>
<td>
<p>a logical indicating whether the total tree height should be scaled to 1. The default is <code>FALSE</code>.</p>
</td></tr> 
<tr><td><code id="OUwie.dredge_+3A_root.station">root.station</code></td>
<td>
<p>a logical indicating whether the starting state, <code class="reqn">\theta_0</code>, should be estimated.</p>
</td></tr>
<tr><td><code id="OUwie.dredge_+3A_shift.point">shift.point</code></td>
<td>
<p>the point along a branch where a regime change is assumed to have occurred (if <code>SIMMAP=FALSE</code>. The default is set to 0.5, or halfway along a branch.</p>
</td></tr>
<tr><td><code id="OUwie.dredge_+3A_algorithm">algorithm</code></td>
<td>
<p>designates whether the standard matrix inversion ('invert') or the faster 'three-point' algorithm of Ho and Ane (2013) should be used.</p>
</td></tr>
<tr><td><code id="OUwie.dredge_+3A_mserr">mserr</code></td>
<td>
<p>designates whether a fourth column in the data matrix contains measurement error for each species value (&quot;known&quot;). The measurement error is assumed to be the standard error of the species mean. The default is &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="OUwie.dredge_+3A_opts">opts</code></td>
<td>
<p>a list of options to pass to nloptr for the optimization: useful to adjust for faster, coarser searches</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an expanded version of the shift point model of Ho and Ane (2014). This is currently being tested, but as of now we strongly recommend using the mBIC criterion when searching for shifts.
</p>


<h3>Value</h3>

<p><code>OUwie.dredge</code> returns an object of class <code>OUwie.dredge</code>. This is a list with elements:
</p>
<table role = "presentation">
<tr><td><code>$loglik</code></td>
<td>
<p>the maximum log-likelihood.</p>
</td></tr>
<tr><td><code>$criterion</code></td>
<td>
<p>the information criterion to use for shift detection.</p>
</td></tr>
<tr><td><code>$criterion.score</code></td>
<td>
<p>the information criterion score used for shift detection.</p>
</td></tr>
<tr><td><code>$shift.model</code></td>
<td>
<p>The shift model estimated from the data.</p>
</td></tr>
<tr><td><code>$solution</code></td>
<td>
<p>a matrix containing the maximum likelihood estimates of <code class="reqn">\alpha</code> and <code class="reqn">\sigma^2</code>.</p>
</td></tr>
<tr><td><code>$mserr.est</code></td>
<td>
<p>indicates value of the measurement error if it was estimated from the data.</p>
</td></tr>
<tr><td><code>$theta</code></td>
<td>
<p>a matrix containing the maximum likelihood estimates of <code class="reqn">\theta</code>.</p>
</td></tr>
<tr><td><code>$tot.states</code></td>
<td>
<p>A vector of names for the different regimes</p>
</td></tr>
<tr><td><code>$index.mat</code></td>
<td>
<p>The indices of the parameters being estimated are returned. The numbers correspond to the row in the <code>eigvect</code> and can useful for identifying the parameters that are causing the objective function to be at a saddlepoint (see Details)</p>
</td></tr>
<tr><td><code>$simmap.tree</code></td>
<td>
<p>A logical indicating whether the input phylogeny is a SIMMAP formatted tree.</p>
</td></tr>
<tr><td><code>$root.age</code></td>
<td>
<p>The user-supplied age at the root of the tree.</p>
</td></tr>
<tr><td><code>$scaleHeight</code></td>
<td>
<p>Indicates whether the tree was constrained to a total height of 1.</p>
</td></tr>
<tr><td><code>$shift.point</code></td>
<td>
<p>The user-specified portion of the branch where a regime shift occurs.</p>
</td></tr>
<tr><td><code>$opts</code></td>
<td>
<p>Settings used for optimization routine.</p>
</td></tr>
<tr><td><code>$data</code></td>
<td>
<p>The shift model dataset, which includes regime painting for each tip.</p>
</td></tr>
<tr><td><code>$phy</code></td>
<td>
<p>The shift model painted phylogeny.</p>
</td></tr>
<tr><td><code>$root.station</code></td>
<td>
<p>A logical indicating whether the starting state, <code class="reqn">\theta_0</code>, was estimated</p>
</td></tr>
<tr><td><code>$starting.vals</code></td>
<td>
<p>the starting values used for the parameter search.</p>
</td></tr>
<tr><td><code>$regime.weights</code></td>
<td>
<p>A table containing parameter estimates and the weights for time spent in each regime for each tip.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeremy M. Beaulieu</p>


<h3>References</h3>

<p>Ho, L.S.T., and C. Ane. 2014. Intrinsic inference difficulties for trait evolution with Ornstein-Uhlenbeck models. Methods in Ecology and Evolution, 5: 1133-1146.
</p>

<hr>
<h2 id='OUwie.fixed'>Generalized Hansen model likelihood calculator</h2><span id='topic+OUwie.fixed'></span>

<h3>Description</h3>

<p>Allows the user to calculate the likelihood given a specified set of parameter values</p>


<h3>Usage</h3>

<pre><code class='language-R'>OUwie.fixed(phy, data, model=c("BM1","BMS","OU1","OUM","OUMV","OUMA","OUMVA"), 
simmap.tree=FALSE, root.age=NULL, scaleHeight=FALSE, root.station=FALSE, 
get.root.theta=FALSE, shift.point=0.5, alpha=NULL, sigma.sq=NULL, theta=NULL, 
clade=NULL, mserr="none", check.identify=TRUE, algorithm=c("invert", "three.point"), 
tip.paths=NULL, quiet=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="OUwie.fixed_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree, in <code>ape</code> &ldquo;phylo&rdquo; format and with internal nodes labeled denoting the ancestral selective regimes</p>
</td></tr>
<tr><td><code id="OUwie.fixed_+3A_data">data</code></td>
<td>
<p>a dataframe containing species information (see Details)</p>
</td></tr>
<tr><td><code id="OUwie.fixed_+3A_model">model</code></td>
<td>
<p>models to fit to comparative data (see Details).</p>
</td></tr>
<tr><td><code id="OUwie.fixed_+3A_simmap.tree">simmap.tree</code></td>
<td>
<p>a logical indicating whether the input tree is in SIMMAP format. The default is <code>FALSE</code>.</p>
</td></tr> 
<tr><td><code id="OUwie.fixed_+3A_root.age">root.age</code></td>
<td>
<p>indicates the age of the tree. This is to be used in cases where the &quot;tips&quot; are not contemporary, such as in cases for fossil trees. Default is <code>NULL</code> meaning latest tip is modern day.</p>
</td></tr>
<tr><td><code id="OUwie.fixed_+3A_scaleheight">scaleHeight</code></td>
<td>
<p>a logical indicating whether the total tree height should be scaled to 1 (see Details). The default is <code>FALSE</code>.</p>
</td></tr> 
<tr><td><code id="OUwie.fixed_+3A_root.station">root.station</code></td>
<td>
<p>a logical indicating whether the starting state, <code class="reqn">\theta_0</code>, should be estimated.</p>
</td></tr>
<tr><td><code id="OUwie.fixed_+3A_get.root.theta">get.root.theta</code></td>
<td>
<p>a logical indicating whether the starting state, <code class="reqn">\theta_0</code>, should be estimated (see Details).</p>
</td></tr>
<tr><td><code id="OUwie.fixed_+3A_shift.point">shift.point</code></td>
<td>
<p>the point along a branch where a regime change is assumed to have occurred (if <code>SIMMAP=FALSE</code>. The default is set to 0.5, or halfway along a branch.</p>
</td></tr>
<tr><td><code id="OUwie.fixed_+3A_alpha">alpha</code></td>
<td>
<p>a numeric vector giving the values of <code class="reqn">\alpha</code> for each selective regime</p>
</td></tr>
<tr><td><code id="OUwie.fixed_+3A_sigma.sq">sigma.sq</code></td>
<td>
<p>a numeric vector giving the values of <code class="reqn">\sigma^2</code> for each selective regime</p>
</td></tr> 
<tr><td><code id="OUwie.fixed_+3A_theta">theta</code></td>
<td>
<p>a numeric vector giving the values of <code class="reqn">\theta</code> for each selective regime</p>
</td></tr>
<tr><td><code id="OUwie.fixed_+3A_clade">clade</code></td>
<td>
<p>a list containing a pair of taxa whose MRCA is the clade of interest.</p>
</td></tr>
<tr><td><code id="OUwie.fixed_+3A_mserr">mserr</code></td>
<td>
<p>designates whether a fourth column in the data matrix contains measurement error for each species value (&quot;known&quot;). The measurement error is assumed to be the standard error of the species mean. The default is &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="OUwie.fixed_+3A_check.identify">check.identify</code></td>
<td>
<p>a logical indicating whether to check that the user-supplied regime paintings will produce identifiable theta estimates. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="OUwie.fixed_+3A_algorithm">algorithm</code></td>
<td>
<p>designates whether the standard matrix inversion ('invert') or the faster 'three-point' algorithm of Ho and Ane (2013) should be used.</p>
</td></tr>
<tr><td><code id="OUwie.fixed_+3A_tip.paths">tip.paths</code></td>
<td>
<p>an optional list that can be provided by the user where each element from 1:nTips is the path from tip to root by labeled node number. The default is NULL and this option is used for internal speedups.</p>
</td></tr>
<tr><td><code id="OUwie.fixed_+3A_quiet">quiet</code></td>
<td>
<p>a logical indicating whether or not to print progress to the screen. The default is &quot;FALSE&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input is a tree and a data file. The tree must be of class &ldquo;phylo&rdquo; and must contain the ancestral selective regimes as internal node labels. The data file is a data.frame that must have column entries in the following order: [,1] species names and [,2] their current selective regime. The user specifies the  parameter values (i.e. <code class="reqn">\alpha</code>, <code class="reqn">\sigma^2</code>, and <code class="reqn">\theta</code>).
</p>


<h3>Value</h3>

<p><code>OUwie.fixed</code> returns an object of class <code>OUwie.fixed</code>. This is a list with elements:
</p>
<table role = "presentation">
<tr><td><code>$loglik</code></td>
<td>
<p>the maximum log-likelihood.</p>
</td></tr>
<tr><td><code>$AIC</code></td>
<td>
<p>Akaike information criterion.</p>
</td></tr>
<tr><td><code>$AICc</code></td>
<td>
<p>Akaike information criterion corrected for sample-size.</p>
</td></tr>
<tr><td><code>$BIC</code></td>
<td>
<p>Schwartz information criterion.</p>
</td></tr>
<tr><td><code>$model</code></td>
<td>
<p>The model being fit</p>
</td></tr>
<tr><td><code>$param.count</code></td>
<td>
<p>The number of parameters counted in the model.</p>
</td></tr>
<tr><td><code>$solution</code></td>
<td>
<p>a matrix containing the maximum likelihood estimates of <code class="reqn">\alpha</code> and <code class="reqn">\sigma^2</code>.</p>
</td></tr>
<tr><td><code>$theta</code></td>
<td>
<p>a matrix containing the maximum likelihood estimates of <code class="reqn">\theta</code>.</p>
</td></tr>
<tr><td><code>$tot.state</code></td>
<td>
<p>A vector of names for the different regimes</p>
</td></tr>
<tr><td><code>$index.mat</code></td>
<td>
<p>The indices of the parameters being estimated are returned. The numbers correspond to the row in the <code>eigvect</code> and can useful for identifying the parameters that are causing the objective function to be at a saddlepoint (see Details)</p>
</td></tr>
<tr><td><code>$simmap.tree</code></td>
<td>
<p>A logical indicating whether the input phylogeny is a SIMMAP formatted tree.</p>
</td></tr>
<tr><td><code>$root.age</code></td>
<td>
<p>The user-supplied age at the root of the tree.</p>
</td></tr>
<tr><td><code>$shift.point</code></td>
<td>
<p>The user-specified portion of the branch where a regime shift occurs.</p>
</td></tr>
<tr><td><code>$data</code></td>
<td>
<p>User-supplied dataset</p>
</td></tr>
<tr><td><code>$phy</code></td>
<td>
<p>User-supplied tree</p>
</td></tr>
<tr><td><code>$root.station</code></td>
<td>
<p>A logical indicating whether the starting state, <code class="reqn">\theta_0</code>, was estimated</p>
</td></tr>
<tr><td><code>$scaleHeight</code></td>
<td>
<p>Indicates whether the tree was constrained to a total height of 1.</p>
</td></tr>
<tr><td><code>$get.root.theta</code></td>
<td>
<p>Indicates whether the root.theta was included in the model.</p>
</td></tr>
<tr><td><code>$regime.weights</code></td>
<td>
<p>A table containing parameter estimates and the weights for time spent in each regime for each tip.</p>
</td></tr>
<tr><td><code>$algorithm</code></td>
<td>
<p>The algorithm used to estimate parameters.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeremy M. Beaulieu</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(tworegime)

#Calculate the likelihood based on known values of
#alpha, sigma^2, and theta:
alpha=c(0.5632459,0.1726052)
sigma.sq=c(0.1064417,0.3461386)
theta=c(1.678196,0.4185894)

OUwie.fixed(tree,trait,model=c("OUMVA"), simmap.tree=FALSE, scaleHeight=FALSE,
clade=NULL, alpha=alpha,sigma.sq=sigma.sq,theta=theta, algorithm="three.point")

</code></pre>

<hr>
<h2 id='OUwie.sim'>Generalized Hansen model simulator</h2><span id='topic+OUwie.sim'></span>

<h3>Description</h3>

<p>Simulates the Ornstein-Uhlenbeck process of continuous characters evolving under discrete selective regimes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>OUwie.sim(phy=NULL, data=NULL, simmap.tree=FALSE, root.age=NULL, scaleHeight=FALSE,
alpha=NULL, sigma.sq=NULL, theta0=NULL, theta=NULL, mserr="none", shift.point=0.5, 
fitted.object=NULL, get.all=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="OUwie.sim_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree, in <code>ape</code> &ldquo;phylo&rdquo; format and with internal nodes labeled denoting the ancestral selective regimes</p>
</td></tr>
<tr><td><code id="OUwie.sim_+3A_data">data</code></td>
<td>
<p>a dataframe containing species information (see Details). Not necessary to include if <code>simmap=TRUE</code>.</p>
</td></tr>
<tr><td><code id="OUwie.sim_+3A_simmap.tree">simmap.tree</code></td>
<td>
<p>a logical indicating whether the input tree is in SIMMAP format. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="OUwie.sim_+3A_root.age">root.age</code></td>
<td>
<p>indicates the age of the tree. This is to be used in cases where the &quot;tips&quot; are not contemporary, such as in cases for fossil trees. Default is <code>NULL</code> meaning latest tip is modern day.</p>
</td></tr>
<tr><td><code id="OUwie.sim_+3A_scaleheight">scaleHeight</code></td>
<td>
<p>a logical indicating whether the total tree height should be scaled to 1 (see Details). The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="OUwie.sim_+3A_alpha">alpha</code></td>
<td>
<p>a numeric vector giving the values of <code class="reqn">\alpha</code> for each selective regime (see Details)</p>
</td></tr>
<tr><td><code id="OUwie.sim_+3A_sigma.sq">sigma.sq</code></td>
<td>
<p>a numeric vector giving the values of <code class="reqn">\sigma^2</code> for each selective regime (see Details)</p>
</td></tr>
<tr><td><code id="OUwie.sim_+3A_theta0">theta0</code></td>
<td>
<p>a numeric indicating the starting state, <code class="reqn">\theta_0</code></p>
</td></tr>
<tr><td><code id="OUwie.sim_+3A_theta">theta</code></td>
<td>
<p>a numeric vector giving the values of <code class="reqn">\theta</code> for each selective regime (see Details)</p>
</td></tr>
<tr><td><code id="OUwie.sim_+3A_mserr">mserr</code></td>
<td>
<p>designates whether a third column in the data matrix contains measurement error for each species value (&quot;known&quot;). The measurement error is assumed to be the standard error of the species mean. The default is &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="OUwie.sim_+3A_shift.point">shift.point</code></td>
<td>
<p>the point along a branch where a regime change is assumed to have occurred (if <code>SIMMAP=FALSE</code>. The default is set to 0.5, or halfway along a branch.</p>
</td></tr>
<tr><td><code id="OUwie.sim_+3A_fitted.object">fitted.object</code></td>
<td>
<p>a model fit from OUwie to use for simulation.</p>
</td></tr>
<tr><td><code id="OUwie.sim_+3A_get.all">get.all</code></td>
<td>
<p>a logical indicating whether or not the entire simulation history is to be returned. The default is <code>FALSE</code> meaning that only the tips are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input is a tree and a data file OR a fitted OUwie object. The tree must be of class &ldquo;phylo&rdquo; and if <code>simmap=FALSE</code> must contain the ancestral selective regimes as internal node labels. The data file is a dataframe that must have column entries in the following order: [,1] species names and [,2] their current selective regime. If <code>mserr="known"</code> then a third column can be added which contains the measurement error for each species. Note that if <code>simmap=TRUE</code> no data file is needed. The user specifies the simulated parameter values (i.e. <code class="reqn">\alpha</code>, <code class="reqn">\sigma^2</code>, <code class="reqn">\theta_0</code>, <code class="reqn">\theta</code>). Assuming two selective regimes, possible models can be specified as follows (Note that this assumes a stationary distribution at the root):
</p>
<p>a. Single rate Brownian motion (<code>BM1</code>): alpha=c(1e-10,1e-10); sigma.sq=c(0.45,0.45); theta0=1.0; theta=c(0,0).
</p>
<p>b. Brownian motion with different rate parameters for each state on a tree (<code>BMS</code>): alpha=c(1e-10,1e-10) sigma.sq=c(0.45,0.90); theta0=1.0; theta=c(0,0).
</p>
<p>c. Ornstein Uhlenbeck with a single optimum for all species (<code>OU1</code>): alpha=c(0.1,0.1); sigma.sq=c(0.9,0.9); theta0=1; theta=c(1.0,1.0).
</p>
<p>d. Ornstein Uhlenbeck model that assumes different state means and a single <code class="reqn">\alpha</code> and <code class="reqn">\sigma^2</code> (<code>OUM</code>): alpha=c(1.0,1.0); sigma.sq=c(0.45,0.45); theta0=1.0; theta=c(1.0,2.0).
</p>
<p>e. Ornstein Uhlenbeck model that assumes different state means and multiple <code class="reqn">\sigma^2</code> (<code>OUMV</code>): alpha=c(1.0,1.0); sigma.sq=c(0.45,0.90); theta0=1.0; theta=c(1.0,2.0).
</p>
<p>f. Ornstein Uhlenbeck model that assumes different state means and multiple <code class="reqn">\alpha</code> (<code>OUMA</code>): alpha=c(1.0,0.5); sigma.sq=c(0.45,0.45); theta0=1.0; theta=c(1.0,2.0).
</p>
<p>g. Ornstein Uhlenbeck model that assumes different state means and multiple <code class="reqn">\sigma^2</code> and <code class="reqn">\alpha</code> (<code>OUMVA</code>): alpha=c(1.0,0.5); sigma.sq=c(0.45,0.9); theta0=1.0; theta=c(1.0,2.0).
</p>
<p>With a fitted OUwie model, it just uses the parameters from that, ignoring any alpha, theta, etc. set in the function.
</p>


<h3>Value</h3>

<p>A dataframe containing, as column entries, [,1] species names, [,2] current regime, [,3] simulated continuous trait, x.
</p>


<h3>Author(s)</h3>

<p>Jeremy M. Beaulieu and Brian C. O'Meara</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sim.ex)

#Simulate an Ornstein-Uhlenbeck model with different state means
#and a separate alpha and sigma^2 per selective regime
alpha=c(1.0,0.5)
sigma.sq=c(0.45,0.9)
theta0=1.0
theta=c(1.0,2.0)

sim.data&lt;-OUwie.sim(tree,trait,simmap.tree=FALSE,scaleHeight=FALSE,
alpha=alpha,sigma.sq=sigma.sq,theta0=theta0,theta=theta)

#Now fit a model to this and simulate from the fitted results
result &lt;- OUwie(tree, sim.data, model="OUMVA", simmap.tree=FALSE,scaleHeight=FALSE)
sim.data.2 &lt;- OUwie.sim(fitted.object=result)


</code></pre>

<hr>
<h2 id='plot.OUwie.contour'>Contour plot</h2><span id='topic+plot.OUwie.contour'></span>

<h3>Description</h3>

<p>A plotting function for visualizing likelihood surface for a pair of parameters using OUwie.contour data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'OUwie.contour'
plot(x, mle.point=NULL, levels=c(0:20*0.1), xlab=NULL, 
ylab=NULL, xlim=NULL, ylim=NULL, col=grey.colors(21, start=0, end=1), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.OUwie.contour_+3A_x">x</code></td>
<td>
<p>a <code>OUwie.contour</code> object.</p>
</td></tr>
<tr><td><code id="plot.OUwie.contour_+3A_mle.point">mle.point</code></td>
<td>
<p>specifies the color for the maximum likelihood set of parameters. By default the point is not plotted (i.e., set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot.OUwie.contour_+3A_levels">levels</code></td>
<td>
<p>the levels at which to draw contour lines, measured as lnL units away from the best values.</p>
</td></tr>
<tr><td><code id="plot.OUwie.contour_+3A_xlab">xlab</code></td>
<td>
<p>allows users to specify the x-axis label.</p>
</td></tr>
<tr><td><code id="plot.OUwie.contour_+3A_ylab">ylab</code></td>
<td>
<p>allows users to specify the y-axis label.</p>
</td></tr>
<tr><td><code id="plot.OUwie.contour_+3A_xlim">xlim</code></td>
<td>
<p>allows users to specify the lower and upper limits of the x-axis.</p>
</td></tr>
<tr><td><code id="plot.OUwie.contour_+3A_ylim">ylim</code></td>
<td>
<p>allows users to specify the lower and upper limits of the y-axis.</p>
</td></tr>
<tr><td><code id="plot.OUwie.contour_+3A_col">col</code></td>
<td>
<p>indicates the color gradient.</p>
</td></tr>
<tr><td><code id="plot.OUwie.contour_+3A_...">...</code></td>
<td>
<p>additional parameters to control the plot.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeremy M. Beaulieu</p>


<h3>References</h3>

<p>Beaulieu J.M., Jhwueng D.C., Boettiger C., and O'Meara B.C. 2012. Modeling stabilizing selection: Expanding the Ornstein-Uhlenbeck model of adaptive evolution. Evolution 66:2369-2383.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
