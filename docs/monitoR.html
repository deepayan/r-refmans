<!DOCTYPE html><html lang="en"><head><title>Help for package monitoR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {monitoR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#monitoR'><p>Automated Acoustic Monitoring&ndash;overview and examples</p></a></li>
<li><a href='#batchDetection'>
<p>Batch Template Detection</p></a></li>
<li><a href='#bindEvents'>
<p>Summarize/Archive Manually Derived Sound Events</p></a></li>
<li><a href='#btnw'>
<p>Black-Throated Green Warbler (<em>Setophaga virens</em>) Song</p></a></li>
<li><a href='#changeSampRate'>
<p>Resample Wave objects</p></a></li>
<li><a href='#collapseClips'>
<p>Summarize/Archive Song Events</p></a></li>
<li><a href='#combineTemplates'>
<p>Combine Acoustic Template Lists</p></a></li>
<li><a href='#compareTemplates'>
<p>Compare Performance of Templates</p></a></li>
<li><a href='#cutWave'>
<p>Extract Shorter Wave Objects from other Wave Objects</p></a></li>
<li><a href='#dbDownload'><p>Retrieve Card-Recorder ID Values or Survey Names from a Database</p></a></li>
<li><a href='#dbDownloadResult'>
<p>Create <code>detectionList</code> Objects from Data Stored in a Database</p></a></li>
<li><a href='#dbDownloadTemplate'><p>Retrieve templates from an acoustics database</p></a></li>
<li><a href='#dbSchema'>
<p>Upload a MySQL Database Schema to Create Tables in an Acoustics Database</p></a></li>
<li><a href='#dbUploadAnno'><p>Upload Spectrogram Annotations to an Acoustics Database</p></a></li>
<li><a href='#dbUploadResult'><p>Upload Detection Results to an Acoustics Database</p></a></li>
<li><a href='#dbUploadSurvey'><p>Upload Survey Metadata to an Acoustics Database</p></a></li>
<li><a href='#dbUploadTemplate'><p>Upload Acoustic Templates to a Database</p></a></li>
<li><a href='#detectionList-class'><p>Class <code>"detectionList"</code></p></a></li>
<li><a href='#eventEval'>
<p>Evaluate Detected Events with Known Event Sources and Times</p></a></li>
<li><a href='#extract-methods'><p>Indexing (Extraction) Methods for <span class="pkg">monitoR</span> Package</p></a></li>
<li><a href='#fileCopyRename'>
<p>Copy and Rename Sound Files from Portable Media</p></a></li>
<li><a href='#findPeaks'>
<p>Find Score Peaks and Detections in a <code>templateScores</code> Object</p></a></li>
<li><a href='#getDetections'>
<p>Extract Detections or Peaks from a <code>detectionList</code> Object</p></a></li>
<li><a href='#getTemplates'>
<p>Extract a Template List</p></a></li>
<li><a href='#internals'>
<p><code>monitoR</code> Internal Functions</p></a></li>
<li><a href='#makeTemplate'>
<p>Make an Acoustic Template</p></a></li>
<li><a href='#mp3Subsamp'>
<p>Extract Short Surveys from Longer mp3 Recordings</p></a></li>
<li><a href='#oven'>
<p>Ovenbird (<em>Seiurus aurocapilla</em>) Song</p></a></li>
<li><a href='#plot-methods'><p>Methods for the <code>plot</code> Function</p></a></li>
<li><a href='#readMP3'>
<p>Read MP3 Files into a Wave Object</p></a></li>
<li><a href='#readTemplates'>
<p>Read Acoustic Templates from a Local Disk</p></a></li>
<li><a href='#show-methods'><p>Methods for the <code>show</code> and <code>summary</code> Functions</p></a></li>
<li><a href='#showPeaks'>
<p>View or Verify Detections or Peaks</p></a></li>
<li><a href='#specCols'>
<p>Color Vectors for Spectrograms</p></a></li>
<li><a href='#survey'>
<p>Sample Acoustic Survey (Short)</p></a></li>
<li><a href='#survey_anno'>
<p>Annotations for <code>survey</code></p></a></li>
<li><a href='#Template-class'><p>Class <code>"Template"</code></p></a></li>
<li><a href='#templateComment'>
<p>Query or Set Template Cutoffs</p></a></li>
<li><a href='#templateCutoff'>
<p>Query or Set Template Cutoffs</p></a></li>
<li><a href='#TemplateList-class'><p>Class <code>"TemplateList"</code></p></a></li>
<li><a href='#templateMatching'>
<p>Calculate Spectrogram Template Matching Scores</p></a></li>
<li><a href='#templateNames'>
<p>Names of Templates</p></a></li>
<li><a href='#templatePath'>
<p>Song clip path of Templates</p></a></li>
<li><a href='#templateScores-class'><p>Class <code>"templateScores"</code></p></a></li>
<li><a href='#timeAlign'>
<p>Condense Detections or Peaks from Multiple Templates</p></a></li>
<li><a href='#viewSpec'>
<p>Interactively View and Annotate Spectrograms</p></a></li>
<li><a href='#writeTemplates'>
<p>Write Acoustic Templates to Text Files</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Acoustic Template Detection in R</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-02-14</td>
</tr>
<tr>
<td>Author:</td>
<td>Sasha D. Hafner &lt;sdh11@cornell.edu&gt; and Jon Katz &lt;jonkatz4@gmail.com&gt;, with code for the Fourier transform from the seewave package (by Jerome Sueur, Thierry Aubin, and Caroline Simonis), and code for the readMP3 function from the tuneR package (by Uwe Ligges). Therese Donovan provided creative direction and database design support. </td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sasha D. Hafner &lt;sdh11@cornell.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), tuneR, methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>fftw, parallel, RODBC, knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>Acoustic template detection and monitoring database interface. Create, modify, save, and use templates for detection of animal vocalizations. View, verify, and extract results. Upload a MySQL schema to a existing instance, manage survey metadata, write and read templates and detections locally or to the database. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.uvm.edu/rsenr/vtcfwru/R/?Page=monitoR/monitoR.htm">http://www.uvm.edu/rsenr/vtcfwru/R/?Page=monitoR/monitoR.htm</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-02-14 09:56:14 UTC; sasha</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-02-14 16:38:52 UTC</td>
</tr>
</table>
<hr>
<h2 id='monitoR'>Automated Acoustic Monitoring&ndash;overview and examples</h2><span id='topic+monitoR-package'></span><span id='topic+monitoR'></span>

<h3>Description</h3>

<p>monitoR contains functions for template matching, template construction, spectrogram viewing and annotation, and direct MySQL database connectivity.  This package offers two fully-supported template matching algorithms: binary point matching and spectrogram cross-correlation.  The direct database connection facilitates efficient data management when batch processing as well as template storage and sharing.  It supplies a database schema that is useful for managing recorders in the field as well as functions for reading metadata from sound files when they are copied from external media.</p>


<h3>Details</h3>

<p>For an introduction to the package see the vignette. For some introductory examples, see &lsquo;Examples&rsquo; below.
</p>


<h3>Acknowledgments</h3>

<p>A Fourier transformed is used in the <span class="pkg">monitoR</span> package to transform time-domain acoustic data to frequency-domain data (i.e., the data displayed in the spectrograms used to produce templates). The <code>spectro</code> function used in our package is a pared-down version of a function of the same name in Jerome Sueur's excellent package <span class="pkg">seewave</span>. To use <code>spectro</code>, the <span class="pkg">seewave</span> functions <code>dBweight</code>, <code>ftwindow</code>, <code>hamming.w</code> and other window functions, and <code>stft</code> are from <span class="pkg">seewave</span>. The function <code><a href="#topic+readMP3">readMP3</a></code> is modified from Uwe Ligges' package <span class="pkg">tuneR</span>. And several other <span class="pkg">tuneR</span> functions are used directly from the <span class="pkg">tuneR</span> package. Without <span class="pkg">seewave</span> and <span class="pkg">tuneR</span> this project would have gotten off to a much slower start.   
</p>
<p>Generous funding for this work was provided by the National Park Service, the U.S. Geological Survey, and the National Phenology Network.
</p>


<h3>Disclaimer</h3>

<p>&ldquo;Although this software program has been used by the U.S. Geological Survey (USGS), no warranty, expressed or implied, is made by the USGS or the U.S. Government as to the accuracy and functioning of the program and related program material nor shall the fact of distribution constitute any such warranty, and no responsibility is assumed by the USGS in connection therewith.&rdquo;
</p>


<h3>Functions in monitoR</h3>

<p>Create a MySQL database (<code><a href="#topic+dbSchema">dbSchema</a></code>), to which survey metadata, templates and metadata, and results can be sent. Copy sound files from external media (<code><a href="#topic+fileCopyRename">fileCopyRename</a></code>) and upload the metadata to the database (<code><a href="#topic+dbUploadSurvey">dbUploadSurvey</a></code>).  View and interactively annotate sound files of any length (<code><a href="#topic+viewSpec">viewSpec</a></code>). Download a table of surveys from the database (<code><a href="#topic+dbDownloadSurvey">dbDownloadSurvey</a></code>), construct a template (<code><a href="#topic+makeBinTemplate">makeBinTemplate</a></code> or <code><a href="#topic+makeCorTemplate">makeCorTemplate</a></code>), detect/score events in a survey (<code><a href="#topic+binMatch">binMatch</a></code>, <code><a href="#topic+corMatch">corMatch</a></code>), apply a threshold to the scores (<code><a href="#topic+findPeaks">findPeaks</a></code>), send the results to the database (<code><a href="#topic+dbUploadResult">dbUploadResult</a></code>).
</p>


<h3>Author(s)</h3>

<p>Sasha D. Hafner <a href="mailto:sdh11@cornell.edu">sdh11@cornell.edu</a> and Jon Katz <a href="mailto:jonkatz4@gmail.com">jonkatz4@gmail.com</a>, with code for the Fourier transform from the seewave package (by Jerome Sueur, Thierry Aubin, and Caroline Simonis), and code for the readMP3 function from the tuneR package (by Uwe Ligges).
</p>
<p>Maintainer: Sasha D. Hafner <a href="mailto:sdh11@cornell.edu">sdh11@cornell.edu</a>
</p>


<h3>References</h3>

<p>Ligges, Uwe.  2011. tuneR: Analysis of music. <a href="http://r-forge.r-project.org/projects/tuner/">http://r-forge.r-project.org/projects/tuner/</a>
</p>
<p>Sueur J, Aubin, T, Simonis, C. 2008. Seewave: a free modular tool for sound analysis and synthesis. <em>Bioacoustics</em> <b>18</b>, 213-226.
</p>
<p>Towsey M, Planitz, B, Nantes, A, Wimmer, J, Roe, P.  2012.  A toolbox for animal call recognition.  <em>Bioacoustics</em> <b>21</b>, 107-125.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># View spectrograms
data(survey)
viewSpec(survey)

# Annotate features
## Not run: 
# Not run because it is interactive and a file is written to user's working directory
viewSpec(survey, annotate = TRUE)

# View previous annotations
data(survey_anno)

write.csv(survey_anno, "survey_anno.csv", row.names = FALSE)

viewSpec(survey, annotate = TRUE, anno = "survey_anno.csv", start.time = 5)

## End(Not run)

# Load example Wave object
data(btnw)
data(oven)

# Write Wave objects to file (temporary directory used here)
btnw.fp &lt;- file.path(tempdir(), "btnw.wav")
oven.fp &lt;- file.path(tempdir(), "oven.wav")
survey.fp &lt;- file.path(tempdir(), "survey2010-12-31_120000_EST.wav")

writeWave(btnw, btnw.fp)
writeWave(oven, oven.fp)
writeWave(survey, survey.fp)

# Correlation example
# Create two correlation templates
wct &lt;- makeCorTemplate(btnw.fp, t.lim = c(1.5, 2.1), frq.lim = c(4.2, 5.6), name = "w")

oct &lt;- makeCorTemplate(oven.fp, t.lim = c(1, 4), frq.lim = c(1, 11), dens = 0.1, name = "o")

# Combine them
ctemps &lt;- combineCorTemplates(wct, oct)

# Calculate scores
cscores &lt;- corMatch(survey.fp, ctemps)

# Find peaks and detections
cdetects &lt;- findPeaks(cscores)
## Not run: 
# Not run because it takes a second to draw the plot
# View results
plot(cdetects, hit.marker = "points")

# Interactively inspect individual detections
# Not run because it is interactive
cdetects &lt;- showPeaks(cdetects, which.one = "w1", flim = c(2, 8), point = TRUE, 
                      scorelim = c(0, 1), verify = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='batchDetection'>
Batch Template Detection
</h2><span id='topic+batchCorMatch'></span><span id='topic+batchBinMatch'></span>

<h3>Description</h3>

<p>These functions are used to carry out template dection for multiple template and survey files in a single call.
These functions make it easy to analyze multiple survey files in a single call. They call <code><a href="#topic+corMatch">corMatch</a></code> or <code><a href="#topic+binMatch">binMatch</a></code>, followed by <code><a href="#topic+findPeaks">findPeaks</a></code> and <code><a href="#topic+getDetections">getDetections</a></code> to do the work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batchCorMatch(dir.template, dir.survey = ".", ext.template = "ct", ext.survey = "wav", 
    templates, parallel = FALSE, show.prog = FALSE, cor.method = "pearson", warn = TRUE, 
    time.source = "filename", fd.rat = 1, ...)

batchBinMatch(dir.template, dir.survey = ".", ext.template = "bt", ext.survey = "wav", 
    templates, parallel = FALSE, show.prog = FALSE, warn = TRUE, 
    time.source = "filename", fd.rat = 1, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="batchDetection_+3A_dir.template">dir.template</code></td>
<td>

<p>A file path to a directory that contains template files to be used.
Only used if <code>template</code> is missing.
</p>
</td></tr>
<tr><td><code id="batchDetection_+3A_dir.survey">dir.survey</code></td>
<td>

<p>A file path to a directory that contains survey files to be analyzed.
</p>
</td></tr>
<tr><td><code id="batchDetection_+3A_ext.template">ext.template</code></td>
<td>

<p>Extension of the template files.
</p>
</td></tr>
<tr><td><code id="batchDetection_+3A_ext.survey">ext.survey</code></td>
<td>

<p>Extension of the survey files.
</p>
</td></tr>
<tr><td><code id="batchDetection_+3A_templates">templates</code></td>
<td>

<p>A template list&ndash;a <code><a href="#topic+corTemplateList-class">corTemplateList</a></code> object for <code>corMatch</code> or a <code><a href="#topic+binTemplateList-class">binTemplateList</a></code> object for <code>binMatch</code>.
If <code>templates</code> is missing, all the template files in <code>dir.template</code> will be used instead.
</p>
</td></tr>
<tr><td><code id="batchDetection_+3A_parallel">parallel</code></td>
<td>

<p>If <code>TRUE</code>, <code><a href="parallel.html#topic+mclapply">mclapply</a></code> from the <span class="pkg">parallel</span> package is used for calculation of scores across all time bins for each template.
This option is not available for Windows operating systems.
</p>
</td></tr>
<tr><td><code id="batchDetection_+3A_show.prog">show.prog</code></td>
<td>

<p>If <code>TRUE</code>, progress will be reported during the score calculations.
</p>
</td></tr>
<tr><td><code id="batchDetection_+3A_cor.method">cor.method</code></td>
<td>

<p>For <code>corMatch</code>, the method used to calculate correlation coefficients (see <code><a href="stats.html#topic+cor">cor</a></code>).
</p>
</td></tr>
<tr><td><code id="batchDetection_+3A_warn">warn</code></td>
<td>

<p>Set to <code>FALSE</code> to suppress warnings about step mismatches. 
</p>
</td></tr>
<tr><td><code id="batchDetection_+3A_time.source">time.source</code></td>
<td>

<p>The source of date and time information.
<code>filename</code> will look in the name of the survey file (<code>survey</code> argument) for a date and time with format YYYY-MM-DD_HHMMSS_TimeZone.
<code>fileinfo</code> will take the date and time from the file modification information.
</p>
</td></tr>
<tr><td><code id="batchDetection_+3A_fd.rat">fd.rat</code></td>
<td>

<p>A ratio of frame width (twice minimum peak separation) to template duration.
Used by <code><a href="#topic+findPeaks">findPeaks</a></code>.
</p>
</td></tr>
<tr><td><code id="batchDetection_+3A_...">...</code></td>
<td>

<p>Additional arguments to the <code><a href="#topic+spectro">spectro</a></code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are simple but do not provide flexibility in how results are handled.
Manually writing a <code>for</code> loop is a more flexible solution.
</p>


<h3>Value</h3>

<p>A data frame of detections, as returned by <code><a href="#topic+getDetections">getDetections</a></code>.
</p>


<h3>Author(s)</h3>

<p>Sasha D. Hafner
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corMatch">corMatch</a></code>, 
<code><a href="#topic+binMatch">binMatch</a></code>, 
<code><a href="#topic+findPeaks">findPeaks</a></code>, 
<code><a href="#topic+getDetections">getDetections</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Assume multiple survey files are in the subdirectory "Surveys" and templates 
# are in subdirectory "Templates"
detects &lt;- batchCorMatch("Templates", "Surveys")

# Or, to use an existing template list instead
detects &lt;- batchCorMatch(templates = ctemps, dir.survey = "Surveys")

## End(Not run)

</code></pre>

<hr>
<h2 id='bindEvents'>
Summarize/Archive Manually Derived Sound Events
</h2><span id='topic+bindEvents'></span>

<h3>Description</h3>

<p>Read in a table of song event times and the corresponding <code><a href="tuneR.html#topic+Wave">Wave</a></code> object, extract the song events, and bind them into a single <code>Wave</code> object for archiving or comparison viewing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bindEvents(rec, file, by.species = TRUE, parallel = FALSE, return.times = FALSE)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bindEvents_+3A_rec">rec</code></td>
<td>
<p>File path to mp3 or wav file or object of class <code><a href="tuneR.html#topic+Wave">Wave</a></code></p>
</td></tr>
<tr><td><code id="bindEvents_+3A_file">file</code></td>
<td>
<p>File path to csv file containing event times.  See details.</p>
</td></tr>
<tr><td><code id="bindEvents_+3A_by.species">by.species</code></td>
<td>
<p>Logical.  Should each species be in its own <code>Wave</code> object?</p>
</td></tr>
<tr><td><code id="bindEvents_+3A_parallel">parallel</code></td>
<td>
<p>Logical.  <code>FALSE</code> will use <code><a href="base.html#topic+lapply">lapply</a></code>, <code>TRUE</code> will use <code><a href="parallel.html#topic+mclapply">mclapply</a></code>.</p>
</td></tr>
<tr><td><code id="bindEvents_+3A_return.times">return.times</code></td>
<td>
<p>Logical.  <code>FALSE</code> returns only the <code>Wave</code> object with events.  <code>TRUE</code> will also return a data frame with the start and end times of each event in the new <code>Wave</code> object linked to their original start and end times.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The csv file supplied must use a standard set of column names, which can occur in any order:
</p>

<ul>
<li><p><code>name</code> Species name
</p>
</li>
<li><p><code>start.time</code> Event start time, in seconds
</p>
</li>
<li><p><code>end.time</code> Event end time, in seconds    
</p>
</li></ul>

<p>These column names are those supplied in an annotation file produced by <code><a href="#topic+viewSpec">viewSpec</a></code>.
</p>


<h3>Value</h3>

<p>If <code>return.times = FALSE</code>, an object of class <code><a href="tuneR.html#topic+Wave">Wave</a></code>. <br />
If <code>return.times = TRUE</code>, a list:
</p>
<table role = "presentation">
<tr><td><code>times</code></td>
<td>
<p>A data frame with the start and end times of events in the <code>Wave</code> object</p>
</td></tr>
<tr><td><code>wave</code></td>
<td>
<p>An object of class <code>Wave</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sasha D. Hafner
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+viewSpec">viewSpec</a></code>, 
<code><a href="#topic+collapseClips">collapseClips</a></code>, 
<code><a href="tuneR.html#topic+bind">bind</a></code>.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 

data(survey_anno) 
data(survey)

# Don't return times
events &lt;- bindEvents( rec = survey, file = survey_anno, by.species = TRUE, parallel = FALSE,
                     return.times = FALSE)

# Return times       
events &lt;- bindEvents( rec = survey, file = survey_anno, by.species = TRUE, parallel = FALSE,
                     return.times = TRUE)
        
</code></pre>

<hr>
<h2 id='btnw'>
Black-Throated Green Warbler (<em>Setophaga virens</em>) Song
</h2><span id='topic+btnw'></span>

<h3>Description</h3>

<p>A 3 second wave recording of a Black-throated Green Warbler (<em>Setophaga virens</em>) song.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(btnw)
</code></pre>


<h3>Format</h3>

<p>The format is: <br />
<code>Formal class 'Wave' [package "tuneR"] with 6 slots
  ..@ left     : int [1:72001] -53 -65 -32 44 -15 -37 -5 26 26 55 ...
  ..@ right    : num(0) 
  ..@ stereo   : logi FALSE
  ..@ samp.rate: int 24000
  ..@ bit      : int 16
  ..@ pcm      : logi TRUE
</code>
</p>


<h3>Source</h3>

<p>Sound clips were recorded in Vermont, USA in 2010.  Equipment was a Wildlife Acoustics SM1(TM) recorder recording in WAC0 format, converted to wave using the Wildlife Acoustics Wac2Wav (TM) converter.  Recording has a sample rate of 24kHz and is 16-bit mono.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(btnw)

viewSpec(btnw)
</code></pre>

<hr>
<h2 id='changeSampRate'>
Resample Wave objects
</h2><span id='topic+changeSampRate'></span>

<h3>Description</h3>

<p>Downsample or upsample <code><a href="tuneR.html#topic+Wave">Wave</a></code> objects by specifying either a new sample rate or matching the sample rate of a different <code><a href="tuneR.html#topic+Wave">Wave</a></code> object.  Optional adjustable dithering. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>changeSampRate(wchange, wkeep = NULL, sr.new = wkeep@samp.rate, dither = FALSE, 
               dith.noise = 32)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="changeSampRate_+3A_wchange">wchange</code></td>
<td>
<p>Object of class <code>Wave</code> to resample.</p>
</td></tr>
<tr><td><code id="changeSampRate_+3A_wkeep">wkeep</code></td>
<td>
<p>Object of class <code>Wave</code> to use to match sampling rate, or specify sampling rate with <code>sr.new</code>.</p>
</td></tr>
<tr><td><code id="changeSampRate_+3A_sr.new">sr.new</code></td>
<td>
<p>Numerical sampling rate, if specified directly.</p>
</td></tr>
<tr><td><code id="changeSampRate_+3A_dither">dither</code></td>
<td>
<p>Logical.  <code>TRUE</code> adds gaussian dithering.</p>
</td></tr>
<tr><td><code id="changeSampRate_+3A_dith.noise">dith.noise</code></td>
<td>
<p>Adjustable dithering.  If <code>dither = TRUE</code>, this value will be the <code>stdev</code> of the normally distributed noise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both downsampling and upsampling are done by spline-fitting a curve to the waveform and resampling the resulting waveform.  Artifacts from resampling are nearly guaranteed.  Artifacts can be masked with dithering at a cost: dithering raises the amplitude of background noise but not signal.
</p>


<h3>Value</h3>

<p>An object of class <code>Wave</code> with a modified sample rate.
</p>


<h3>Author(s)</h3>

<p>Sasha D. Hafner, 
Jon Katz
</p>


<h3>See Also</h3>

<p><code><a href="tuneR.html#topic+downsample">downsample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(survey)

survey &lt;- changeSampRate(wchange = survey, sr.new = 24000)
</code></pre>

<hr>
<h2 id='collapseClips'>
Summarize/Archive Song Events
</h2><span id='topic+collapseClips'></span>

<h3>Description</h3>

<p>Read in a <code><a href="tuneR.html#topic+Wave">Wave</a></code> object, extract the song events, and bind them into a single <code>Wave</code> object for archiving or comparison viewing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapseClips(rec, start.times, end.times, return.times = FALSE)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collapseClips_+3A_rec">rec</code></td>
<td>
<p>Object of class <code>Wave</code> or file path to wave file.</p>
</td></tr>
<tr><td><code id="collapseClips_+3A_start.times">start.times</code></td>
<td>
<p>Vector of event start times, in seconds.</p>
</td></tr>
<tr><td><code id="collapseClips_+3A_end.times">end.times</code></td>
<td>
<p>Vector of event end times, in seconds.</p>
</td></tr>
<tr><td><code id="collapseClips_+3A_return.times">return.times</code></td>
<td>
<p>Logical.  <code>TRUE</code> will return </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A stripped-down version of <code><a href="#topic+bindEvents">bindEvents</a></code>, perhaps more readily applied to the output of <code><a href="#topic+findPeaks">findPeaks</a></code>.
</p>


<h3>Value</h3>

<p>If <code>return.times = FALSE</code>, an object of class <code>Wave</code>.
If <code>return.times = TRUE</code>, a list:
</p>
<table role = "presentation">
<tr><td><code>times</code></td>
<td>
<p>A data frame with the start and end times of events in the wave object</p>
</td></tr>
<tr><td><code>wave</code></td>
<td>
<p>An object of class <code>Wave</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sasha D. Hafner
</p>


<h3>See Also</h3>

<p><code><a href="#topic+viewSpec">viewSpec</a></code>, <code><a href="#topic+bindEvents">bindEvents</a></code>, <code><a href="tuneR.html#topic+bind">bind</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(survey_anno)

data(survey)

events &lt;- collapseClips(rec = survey, start.times = survey_anno[, "start.time"], 
                        end.times = survey_anno[, "end.time"], return.times = FALSE)
</code></pre>

<hr>
<h2 id='combineTemplates'>
Combine Acoustic Template Lists
</h2><span id='topic+combineCorTemplates'></span><span id='topic+combineBinTemplates'></span>

<h3>Description</h3>

<p>Use these functions to combine any number of templates together into a larger template list.
They can combine template lists that themselves contain any number of templates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineCorTemplates(...)

combineBinTemplates(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combineTemplates_+3A_...">...</code></td>
<td>
<p>Correlation <em>or</em> binary template lists (class <code><a href="#topic+corTemplateList-class">corTemplateList</a></code> or <code><a href="#topic+binTemplateList-class">binTemplateList</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are the only way to create template lists containing more than one template, and so should be used often.
Only <code>binTemplateList</code> objects should be used with <code>combineBinTemplates</code>, and only <code>corTemplateList</code> objects should be used with <code>combineCorTemplates</code>.
If you combine templates that use the same name, a suffix (<code>.2</code>) will be added to the later name.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+TemplateList-class">TemplateList</a></code> object that contains all the templates submitted to the function.
</p>


<h3>Author(s)</h3>

<p>Sasha D. Hafner
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeCorTemplate">makeCorTemplate</a></code>,  
<code><a href="#topic+makeBinTemplate">makeBinTemplate</a></code>, 
<code><a href="#topic+templateNames">templateNames</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First need to make some template lists to combine
# Load data
data(btnw)
data(oven)
data(survey)

# Write Wave objects to file (temporary directory used here)
btnw.fp &lt;- file.path(tempdir(), "btnw.wav")

oven.fp &lt;- file.path(tempdir(), "oven.wav")

writeWave(btnw, btnw.fp)

writeWave(oven, oven.fp)

# Create four correlation templates
wct1 &lt;- makeCorTemplate(btnw.fp, name = "w1")

wct2 &lt;- makeCorTemplate(btnw.fp, t.lim = c(1.5, 2.1), frq.lim = c(4.2, 5.6), 
                        name = "w2")

oct1 &lt;- makeCorTemplate(oven.fp, t.lim = c(1, 4), frq.lim = c(1, 11), name = "o1")

oct2 &lt;- makeCorTemplate(oven.fp, t.lim = c(1, 4), frq.lim = c(1, 11), dens = 0.1, 
                        name = "o2")

# Combine all of them
ctemps &lt;- combineCorTemplates(wct1, wct2, oct1, oct2)
ctemps

# Binary templates are similar
# Create four templates
wbt1 &lt;- makeBinTemplate(btnw.fp, amp.cutoff = -40, name = "w1")

wbt2 &lt;- makeBinTemplate(btnw.fp, amp.cutoff = -30, t.lim = c(1.5, 2.1), 
                        frq.lim = c(4.2, 5.6), buffer = 2, name = "w2")

obt1 &lt;- makeBinTemplate(oven.fp, amp.cutoff = -20, t.lim = c(1, 4), 
                        frq.lim = c(1, 11), name = "o1")

obt2 &lt;- makeBinTemplate(oven.fp, amp.cutoff = -17, t.lim = c(1, 4), 
                        frq.lim = c(1, 11), buffer = 2, name = "o2")

# Combine all of them
btemps &lt;- combineBinTemplates(wbt1, wbt2, obt1, obt2)
btemps

# Clean up (only because these files were created in these examples)
file.remove(btnw.fp)

file.remove(oven.fp)
</code></pre>

<hr>
<h2 id='compareTemplates'>
Compare Performance of Templates
</h2><span id='topic+compareTemplates'></span>

<h3>Description</h3>

<p>Provided a <code><a href="#topic+detectionList-class">detectionList</a></code> object containing results from N templates scored against the same survey with Y song events, <code>compareTemplates</code> will create a Y x N matrix to compare how each template scored each song event.  If the song events are the sound clips used to create each template, <code>compareTemplates</code> may be a means of measuring overall similarity among sound events.  Can be used to identify template clips that may match more than one song type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareTemplates(detection.obj, cutoff.return, cutoff.ignore, tol, n.drop = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compareTemplates_+3A_detection.obj">detection.obj</code></td>
<td>
<p>Object of class <code><a href="#topic+detectionList-class">detectionList</a></code>.</p>
</td></tr>
<tr><td><code id="compareTemplates_+3A_cutoff.return">cutoff.return</code></td>
<td>
<p>Score cutoff below which events are not returned.</p>
</td></tr>
<tr><td><code id="compareTemplates_+3A_cutoff.ignore">cutoff.ignore</code></td>
<td>
<p>Score cutoff below which events are ignored.</p>
</td></tr>
<tr><td><code id="compareTemplates_+3A_tol">tol</code></td>
<td>
<p>Tolerance (s). If a peak is within <code>tol</code> of a peak from another template, they are in the same event.</p>
</td></tr>
<tr><td><code id="compareTemplates_+3A_n.drop">n.drop</code></td>
<td>
<p>Rows with this many templates or fewer will be dropped. <code>n.drop = 0</code> drops none.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The matrix is created by comparing the score for each event to the average score for that event.  For cases in which a template does not score an event above <code>cutoff</code> a value of <code>NA</code> is placed in the matrix for that template-event junction.  Similarly, if a template scores an event above <code>cutoff</code> but is beyond <code>tol</code> of the mean of other events, it will enter the matrix as its own event and an <code>NA</code> will be placed in the matrix for the event's junctions with other templates.
</p>


<h3>Value</h3>

<p>A list:
</p>
<table role = "presentation">
<tr><td><code>times.mean</code></td>
<td>
<p>Vector of mean times for each row of the matrix.</p>
</td></tr>
<tr><td><code>times</code></td>
<td>
<p>Matrix of times for each event detection and template.</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>Matrix of scores for each event detection and template.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>It can be difficult to make this function do the same grouping of peaks that a human might do.
</p>


<h3>Author(s)</h3>

<p>Sasha D. Hafner
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeCorTemplate">makeCorTemplate</a></code>, 
<code><a href="#topic+makeBinTemplate">makeBinTemplate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data(btnw)

# Write Wave objects to file (temporary directory used here)
btnw.fp &lt;- file.path(tempdir(), "btnw.wav")

writeWave(btnw, btnw.fp)

# Make three templates to compare
btnw.1 &lt;- makeBinTemplate(clip = btnw.fp, frq.lim = c(2.75, 7), t.lim = c(.5, 2.5), 
                          amp.cutoff = -20, name = -20)

btnw.2 &lt;- makeBinTemplate(clip = btnw.fp, frq.lim = c(2.75, 7), t.lim = c(.5, 2.5), 
                          amp.cutoff = -27, name = -27)

btnw.3 &lt;- makeBinTemplate(clip = btnw.fp, frq.lim = c(2.75, 7), t.lim = c(.5, 2.5), 
                          amp.cutoff = -34, name = -34)

# Combine templates
templates &lt;- combineBinTemplates(btnw.1, btnw.2, btnw.3)

survey &lt;- bind(btnw, btnw, btnw)

survey.fp &lt;- file.path(tempdir(), "survey.wav")

writeWave(survey, survey.fp)

scores &lt;- binMatch(survey = survey.fp, templates = templates, time.source = "fileinfo")

pks &lt;- findPeaks(scores)

compareTemplates(detection.obj = pks, cutoff.return = 12, cutoff.ignore = 6, tol = 1, 
                 n.drop = 0) 

# Clean up
file.remove(btnw.fp)
file.remove(survey.fp)
</code></pre>

<hr>
<h2 id='cutWave'>
Extract Shorter Wave Objects from other Wave Objects
</h2><span id='topic+cutWave'></span>

<h3>Description</h3>

<p>Extract shorter Wave objects from other Wave objects.  Extracted wave object will be between the <code>from</code> and <code>to</code> boundaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutWave(wave, from = NULL, to = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cutWave_+3A_wave">wave</code></td>
<td>
<p>Object of class <code><a href="tuneR.html#topic+Wave">Wave</a></code>.</p>
</td></tr>
<tr><td><code id="cutWave_+3A_from">from</code></td>
<td>
<p>Start extracted segment from this point, in seconds from beginning of <code>Wave</code> object.</p>
</td></tr>
<tr><td><code id="cutWave_+3A_to">to</code></td>
<td>
<p>End of extracted segment, in seconds from beginning of <code>Wave</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a simplified version of <code><a href="seewave.html#topic+cutw">cutw</a></code> from the seewave package.
Its original name in the monitoR was the same (<code>cutw</code>), but has since been changed to avoid conflict for those who use both packages.
</p>


<h3>Value</h3>

<p>An object of class <code>Wave</code>.
</p>


<h3>Author(s)</h3>

<p>Sasha D. Hafner
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(survey)

event1 &lt;- cutWave(wave = survey, from = 1.5, to = 4.75)
</code></pre>

<hr>
<h2 id='dbDownload'>Retrieve Card-Recorder ID Values or Survey Names from a Database</h2><span id='topic+dbDownloadCardRecorderID'></span><span id='topic+dbDownloadSurvey'></span>

<h3>Description</h3>

<p>Convenience functions to execute a prewritten SQL query.  Wrappers for <code>RODBC::sqlQuery</code> with no additional processing.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbDownloadCardRecorderID(db.name = "acoustics", uid, pwd, 
                         date.deployed, date.collected, 
			 loc.prefix, ...)

dbDownloadSurvey(db.name = "acoustics", uid, pwd, start.date, 
                 end.date, loc.prefix, samp.rate, ext, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dbDownload_+3A_db.name">db.name</code></td>
<td>
<p>Name of the ODBC connector data source corresponding to the acoustics database.</p>
</td></tr>
<tr><td><code id="dbDownload_+3A_uid">uid</code></td>
<td>
<p>User ID to allow ODBC connector to connect to database, if not present in ODBC connector.</p>
</td></tr>
<tr><td><code id="dbDownload_+3A_pwd">pwd</code></td>
<td>
<p>Password to allow ODBC connector to connect to database, if not present in ODBC connector.</p>
</td></tr>
<tr><td><code id="dbDownload_+3A_date.deployed">date.deployed</code>, <code id="dbDownload_+3A_date.collected">date.collected</code>, <code id="dbDownload_+3A_start.date">start.date</code>, <code id="dbDownload_+3A_end.date">end.date</code></td>
<td>
<p>Dates to filter results, as a character string formatted to your database storage; in the example we use <code>YYYY/MM/DD</code>, but be aware that you may need to include a full timestamp: <code>YYYY/MM/DD 00:00:00</code>.</p>
</td></tr>
<tr><td><code id="dbDownload_+3A_loc.prefix">loc.prefix</code></td>
<td>
<p>Location prefix or vector of six-character prefixes by which to filter results.</p>
</td></tr>
<tr><td><code id="dbDownload_+3A_samp.rate">samp.rate</code></td>
<td>
<p>Numerical sampling rate of surveys (Hz).</p>
</td></tr>
<tr><td><code id="dbDownload_+3A_ext">ext</code></td>
<td>
<p>Character file extension &quot;wav&quot; or &quot;mp3&quot;.</p>
</td></tr>
<tr><td><code id="dbDownload_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>RODBC::odbcConnect</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions assume a database structure identical to that provided in the acoustics schema.  <code>dbDownloadCardRecorderID</code> may be used to look up CardRecorderID values before uploading survey metadata; <code>dbDownloadSurvey</code> may be used to generate a table of survey names to work through for batch detection with either <code><a href="#topic+corMatch">corMatch</a></code> or <code><a href="#topic+binMatch">binMatch</a></code>.
If the username and password are present in the ODBC datasource they do not need to be provided.  It is possible to store only the username in the datasource and enter a password, but the reverse will not work.
</p>


<h3>Value</h3>

<p><code>dbDownloadCardRecorderID</code> returns a data frame with fields pkCardRecorderID, fldLocationNameAbbreviation, fldSerialNumber, and pkCardID. <code>dbDownloadSurvey</code> returns a data frame with a single field: fldSurveyName.
</p>


<h3>Note</h3>

<p>These are convenience functions for users who are unfamiliar with SQL syntax and/or have not established an alternative front-end for their acoustics database.  Users capable of doing so may find more utility and flexibility writing custom queries directly either with an alternative front-end or <code>RODBC::sqlQuery</code>.  No processing is performed; data from the database is returned as it exists in the database.
</p>


<h3>Author(s)</h3>

<p>Jon Katz
</p>


<h3>See Also</h3>

<p><code><a href="RODBC.html#topic+sqlQuery">sqlQuery</a></code>, <code><a href="#topic+dbDownloadTemplate">dbDownloadTemplate</a></code>, <code><a href="#topic+dbUploadSurvey">dbUploadSurvey</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#If using the 'acoustics' schema verbatim:
CRs &lt;- dbDownloadCardRecorderID(
        date.deployed = "2012/05/22", 
        date.collected = "2012/05/29", 
        loc.prefix = "MABI01")
        
surveys &lt;- dbDownloadSurvey(
        start.date = "2012/05/22", 
        end.date = "2012/05/29", 
        loc.prefix = "MABI01", 
        samp.rate = 24000, 
        ext = "wav")
        
#'acoustics' schema, different database name:
CRs &lt;- dbDownloadCardRecorderID(
        db.name = "LocalSQLdb", 
        uid = "EntryOnly", 
        pwd = "07H23BBM", 
        date.deployed = "2012/05/22", 
        date.collected = "2012/05/29", 
        loc.prefix = "MABI01")
        
surveys &lt;- dbDownloadSurvey(
        db.name = "LocalSQLdb", 
        uid = "EntryOnly", 
        pwd = "07H23BBM", 
        start.date = "2012/05/22", 
        end.date = "2012/05/29", 
        loc.prefix = "MABI01", 
        samp.rate = 24000, 
        ext = "wav")

## End(Not run)
</code></pre>

<hr>
<h2 id='dbDownloadResult'>
Create <code><a href="#topic+detectionList-class">detectionList</a></code> Objects from Data Stored in a Database 
</h2><span id='topic+dbDownloadResult'></span>

<h3>Description</h3>

<p>This function creates <code>detectionList</code> objects corresponding to a specified survey and <code><a href="#topic+TemplateList-class">TemplateList</a></code> from data available in an acoustics database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbDownloadResult(db.name = "acoustics", uid, pwd, survey, templates, 
                 type, FFTwl, FFTwn, FFTovlp, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dbDownloadResult_+3A_db.name">db.name</code></td>
<td>
<p>Name of the ODBC connector data source corresponding to the acoustics database.</p>
</td></tr>
<tr><td><code id="dbDownloadResult_+3A_uid">uid</code></td>
<td>
<p>User ID to allow ODBC connector to connect to database, if not present in ODBC connector.</p>
</td></tr>
<tr><td><code id="dbDownloadResult_+3A_pwd">pwd</code></td>
<td>
<p>Password to allow ODBC connector to connect to database, if not present in ODBC connector.</p>
</td></tr>
<tr><td><code id="dbDownloadResult_+3A_survey">survey</code></td>
<td>
<p>Character value, name of survey as it appears in the acoustics database</p>
</td></tr>
<tr><td><code id="dbDownloadResult_+3A_templates">templates</code></td>
<td>
<p>object of class <code>TemplateList</code> or character vector of template names as they appear in an acoustics database</p>
</td></tr>
<tr><td><code id="dbDownloadResult_+3A_type">type</code></td>
<td>
<p>Character value in c(&quot;BIN&quot;, &quot;COR&quot;) to filter the results for either <code><a href="#topic+binMatch">binMatch</a></code> or <code><a href="#topic+corMatch">corMatch</a></code> results, respectively</p>
</td></tr>
<tr><td><code id="dbDownloadResult_+3A_fftwl">FFTwl</code></td>
<td>
<p>Filter for templates with specific FFT window lengths.</p>
</td></tr>
<tr><td><code id="dbDownloadResult_+3A_fftovlp">FFTovlp</code></td>
<td>
<p>Filter for templates with specific FFT window overlap.</p>
</td></tr>
<tr><td><code id="dbDownloadResult_+3A_fftwn">FFTwn</code></td>
<td>
<p>Filter for templates with specific FFT window names.</p>
</td></tr>
<tr><td><code id="dbDownloadResult_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>sqlQuery</code>.  For example, if the function fails on an error such as: Error in as.POSIXlt.character(x, tz, ...) : character string is not in a standard unambiguous format, adding <code>as.is = TRUE</code> may help circumnavigate the problem (although it will not solve the data issue!)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows database data to be coerced back into an object of class <code>detectionList</code>, which is useful in that data can be pulled from the database and used in functions that require <code>detectionList</code> objects such as <code>plot</code> and <code><a href="#topic+showPeaks">showPeaks</a></code>.  
</p>
<p>The resulting <code>detectionList</code> object will be incomplete as it is missing the complete scores list, which is used to plot the scores in the second row of the above plotting functions.  Hit markers are still plotted, and these can still be useful if set to <code>hit.marker = "points"</code>. 
</p>


<h3>Value</h3>

<p>An object of class <code>detectionList</code>
</p>


<h3>Author(s)</h3>

<p>Jon Katz, 
Sasha D. Hafner
</p>


<h3>See Also</h3>

<p><code><a href="#topic+detectionList-class">detectionList</a></code>, <code><a href="#topic+TemplateList-class">TemplateList</a></code>, <code><a href="#topic+binMatch">binMatch</a></code>, <code><a href="#topic+corMatch">corMatch</a></code>, <code><a href="#topic+showPeaks">showPeaks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#If using the 'acoustics' schema verbatim:
examp &lt;- dbDownloadResult(
        survey = "INTV02_2011-06-25_081000_EDT.mp3", 
        templates = templates, type = "BIN")
        
#'acoustics' schema, different database name:
examp &lt;- dbDownloadResult(
        db.name = "LocalSQLdb", 
        uid = "EntryOnly" , 
        pwd = "07H23BBM", 
        survey = "INTV02_2011-06-25_081000_EDT.mp3", 
        templates = templates, 
        type = "BIN")
## End(Not run)
</code></pre>

<hr>
<h2 id='dbDownloadTemplate'>Retrieve templates from an acoustics database</h2><span id='topic+dbDownloadTemplate'></span>

<h3>Description</h3>

<p>Download Acoustic Templates from a Database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbDownloadTemplate(db.name = "acoustics", uid, pwd, type, names, 
                   species, FFTwl, FFTovlp, FFTwn, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dbDownloadTemplate_+3A_db.name">db.name</code></td>
<td>
<p>Name of the ODBC connector data source corresponding to the acoustics database.</p>
</td></tr>
<tr><td><code id="dbDownloadTemplate_+3A_uid">uid</code></td>
<td>
<p>User ID to allow ODBC connector to connect to database, if not present in ODBC connector.</p>
</td></tr>
<tr><td><code id="dbDownloadTemplate_+3A_pwd">pwd</code></td>
<td>
<p>Password to allow ODBC connector to connect to database, if not present in ODBC connector.</p>
</td></tr>
<tr><td><code id="dbDownloadTemplate_+3A_type">type</code></td>
<td>
<p>Type of templates to select. Character value of either &quot;BIN&quot; or &quot;COR&quot;.  Some partial matching is performed to accept &quot;bt&quot; and &quot;ct&quot;, for example.</p>
</td></tr>
<tr><td><code id="dbDownloadTemplate_+3A_names">names</code></td>
<td>
<p>Optional character value or vector of template names to filter selection from the database. If missing all templates matching other filters are selected.</p>
</td></tr>
<tr><td><code id="dbDownloadTemplate_+3A_species">species</code></td>
<td>
<p>Optional character value or vector of species to filter selection from the database. If missing all templates matching other filters are selected.</p>
</td></tr>
<tr><td><code id="dbDownloadTemplate_+3A_fftwl">FFTwl</code></td>
<td>
<p>Optional character value or vector of FFT window lengths to filter selection from the database. If missing all templates matching other filters are selected.</p>
</td></tr>
<tr><td><code id="dbDownloadTemplate_+3A_fftovlp">FFTovlp</code></td>
<td>
<p>Optional character value or vector of FFT window overlap to filter selection from the database. If missing all templates matching other filters are selected.</p>
</td></tr>
<tr><td><code id="dbDownloadTemplate_+3A_fftwn">FFTwn</code></td>
<td>
<p>Optional character value or vector of FFT window names to filter selection from the database. If missing all templates matching other filters are selected.</p>
</td></tr>
<tr><td><code id="dbDownloadTemplate_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="RODBC.html#topic+odbcConnect">odbcConnect</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes a database structure identical to that provided in the acoustics schema.  If the username and password are present in the ODBC datasource they do not need to be provided.  It is possible to store only the username in the datasource and enter a password, but the reverse will not work.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+TemplateList-class">TemplateList</a></code>.
</p>


<h3>Note</h3>

<p>In the acoustics database templates are broken into components, and vectors are stored as text objects in various fields. To stay beneath the maximum download vector size of <code><a href="RODBC.html#topic+sqlQuery">sqlQuery</a></code>, extraneous characters are removed from each vector during upload; some must be re-inserted during download.  Space characters are not replaced, but all amplitude values for correlation templates are sign-inverted and converted from integers to floating point decimal.  All decimals were rounded to the hundredth's place during upload.  These measures are sometimes insufficient and users may find it useful to increase the maximum download vector size in sqlQuery (see the vignette &ldquo;MySQL_DataSources_RODBC&rdquo; for further details).  Large templates may take more than several seconds to download; 2-10 seconds is normal for binary point matching templates, and 5-30 seconds is normal for correlation templates.
</p>


<h3>Author(s)</h3>

<p>Jon Katz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dbUploadTemplate">dbUploadTemplate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#If using the 'acoustics' schema verbatim:
btnw &lt;- dbDownloadTemplate(
        type = "BIN", 
        names= c("template1", "template2")
        FFTwl = 512, 
        FFTovlp = 0, 
        FFTwn = "hanning")
        
#'acoustics' schema, different database name:
btnw &lt;- dbDownloadTemplate(
        db.name = "LocalSQLdb", 
        uid = "EntryOnly" , 
        pwd = "07H23BBM", 
        type = "COR", 
        species = c("BTNW", "OVEN") 
        FFTwl = 512, 
        FFTovlp = 0, 
        FFTwn = "hanning")
## End(Not run)
</code></pre>

<hr>
<h2 id='dbSchema'>
Upload a MySQL Database Schema to Create Tables in an Acoustics Database
</h2><span id='topic+dbSchema'></span>

<h3>Description</h3>

<p>Use this function to select a schema and upload it to an existing MySQL database.  All tables in the schema will be created in the database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbSchema(schema, name.on.host, tables = FALSE, 
         schema.name = "NOH", db.name = "acoustics", uid, pwd, 
         ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dbSchema_+3A_schema">schema</code></td>
<td>
<p>File path to schema (.txt or .sql).</p>
</td></tr>
<tr><td><code id="dbSchema_+3A_name.on.host">name.on.host</code></td>
<td>
<p>Database name on MySQL host.</p>
</td></tr>
<tr><td><code id="dbSchema_+3A_tables">tables</code></td>
<td>
<p><code>TRUE</code> will return the result of <code><a href="RODBC.html#topic+sqlTables">sqlTables</a></code></p>
</td></tr>
<tr><td><code id="dbSchema_+3A_schema.name">schema.name</code></td>
<td>
<p>Current name of schema to be replaced by <code>name.on.host</code></p>
</td></tr>
<tr><td><code id="dbSchema_+3A_db.name">db.name</code></td>
<td>
<p>Connection name in ODBC data source.</p>
</td></tr>
<tr><td><code id="dbSchema_+3A_uid">uid</code></td>
<td>
<p>Database User ID, if not in ODBC data source.</p>
</td></tr>
<tr><td><code id="dbSchema_+3A_pwd">pwd</code></td>
<td>
<p>Database Password, if not in ODBC data source.</p>
</td></tr>
<tr><td><code id="dbSchema_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="RODBC.html#topic+odbcConnect">odbcConnect</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creating a MySQL database typically requires three steps:<br />
1. Design/test/export schema<br />
2. Create a MySQL instance on the host (locally or on a server)<br />
3. Import schema to create tables, keys, and relationships<br />
<br />
The default acoustics database schema will allow the user to skip step 1; this function will take care of step 3.  The user must ensure that a database instance exists and is present in the ODBC data source list before attempting to use this function.  This function was tested using a schema automatically generated using the default &quot;forward engineer&quot; export function in MySQL Workbench with DROP statements. The default acoustics schema can be downloaded at <a href="http://www.uvm.edu/rsenr/vtcfwru/R/?Page=monitoR/monitoR.htm">http://www.uvm.edu/rsenr/vtcfwru/R/?Page=monitoR/monitoR.htm</a>.
</p>


<h3>Value</h3>

<p>If <code>tables</code>, a list:<br />
</p>
<table role = "presentation">
<tr><td><code>upload.time</code></td>
<td>
<p>Duration of upload and processing.</p>
</td></tr>
<tr><td><code>tables</code></td>
<td>
<p>Description tables in the acoustics database.</p>
</td></tr>
</table>
<p><br />
Otherwise a report of the duration of upload and processing time to indicate completion.
</p>


<h3>Author(s)</h3>

<p>Jon Katz
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dbSchema(
    schema = "acoustics.sql", 
    name.on.host = "acoustics", 
    tables = TRUE, 
    schema.name = 'myschema', 
    db.name = "acoustics", 
    uid = "Admin", 
    pwd = "BadPassword!" )
     
## $upload.time
## [1] "Upload time 10.977 secs"
##
## $tables
##    TABLE_CAT TABLE_SCHEM           TABLE_NAME TABLE_TYPE
## 1     JKATZ3                   tblAnnotations      TABLE
## 2     JKATZ3                       tblArchive      TABLE
## 3     JKATZ3                          tblCard      TABLE
## 4     JKATZ3                  tblCardRecorder      TABLE
## 5     JKATZ3                     tblCovariate      TABLE
## 6     JKATZ3             tblEnvironmentalData      TABLE
## 7     JKATZ3                      tblLocation      TABLE
## 8     JKATZ3                  tblOrganization      TABLE
## 9     JKATZ3                        tblPerson      TABLE
## 10    JKATZ3                 tblPersonContact      TABLE
## 11    JKATZ3                       tblProject      TABLE
## 12    JKATZ3                      tblRecorder      TABLE
## 13    JKATZ3                        tblResult      TABLE
## 14    JKATZ3                 tblResultSummary      TABLE
## 15    JKATZ3                       tblSpecies      TABLE
## 16    JKATZ3                 tblSpeciesPriors      TABLE
## 17    JKATZ3                        tblSurvey      TABLE
## 18    JKATZ3                      tblTemplate      TABLE
## 19    JKATZ3                 tblTemplatePrior      TABLE
##                                                          REMARKS
## 1                          For annotated song events in surveys.
## 2              For archiving sound clips extracted from surveys.
## 3              This table stores information about memory cards.
## 4                 Track survey, recorder, and memory card links.
## 5  Describe covariates and types of enviromental data collected.
## 6                   Non-acoustic data: environmental covariates.
## 7   Information about about locations for surveys and templates.
## 8             Store the organization name and contact info here.
## 9                     Names of people in the monitoring program.
## 10            Contact info, including Cell/Work Phone and email.
## 11   Store the names of multiple projects per organization here.
## 12          This table stores information about recording units.
## 13                    Table to store the results of findPeaks().
## 14                         Store probability of survey presence.
## 15          Store BBL codes or other 4, 6, or 8 character codes.
## 16                    Store site &amp; species specific priors here.
## 17         This table stores attributes of the survey recording.
## 18                        Store templates and template metadata.
## 19               Store beta parameter estimates for error rates.



## End(Not run)
</code></pre>

<hr>
<h2 id='dbUploadAnno'>Upload Spectrogram Annotations to an Acoustics Database</h2><span id='topic+dbUploadAnno'></span>

<h3>Description</h3>

<p>Spectrogram annotations from <code>viewSpec</code> can be uploaded to tblAnnotations in an acoustics database.  Annotations can be specified as either a file path to a csv document or as a data frame.  The name of the survey to associate with the annotations must be identical to tblSurvey.fldSurveyName to properly link the annotations to the survey.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbUploadAnno(annotations, survey, db.name = "acoustics", uid, 
             pwd, analyst = "", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dbUploadAnno_+3A_annotations">annotations</code></td>
<td>
<p>Either a file path to a csv file or a data frame of annotations.</p>
</td></tr>
<tr><td><code id="dbUploadAnno_+3A_survey">survey</code></td>
<td>
<p>Name of survey annotations belong to.  Must match tblSurvey.fldSurveyName</p>
</td></tr>
<tr><td><code id="dbUploadAnno_+3A_db.name">db.name</code></td>
<td>
<p>Name of the ODBC connector data source corresponding to the acoustics database.</p>
</td></tr>
<tr><td><code id="dbUploadAnno_+3A_uid">uid</code></td>
<td>
<p>User ID to allow ODBC connector to connect to database, if not present in ODBC connector.</p>
</td></tr>
<tr><td><code id="dbUploadAnno_+3A_pwd">pwd</code></td>
<td>
<p>Password to allow ODBC connector to connect to database, if not present in ODBC connector.</p>
</td></tr>
<tr><td><code id="dbUploadAnno_+3A_analyst">analyst</code></td>
<td>
<p>Numerical key value corresponding to the user's tblPerson.pkPersonID value in the acoustics database.</p>
</td></tr>
<tr><td><code id="dbUploadAnno_+3A_...">...</code></td>
<td>
<p>Additional arguments to RODBC::odbcConnect.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dbUploadAnno</code> assumes a database structure identical to that provided in the acoustics schema.  If the username and password are present in the ODBC datasource they do not need to be provided.  It is possible to store only the username in the datasource and enter a password, but the reverse will not work.
Annotations are expected to be formatted by (or as if by) <code>viewSpec</code>, so if another piece of software is recording the annotations the field order must be altered to match output of <code>viewSpec</code>. 
</p>


<h3>Value</h3>

<p>Invoked for its side effect.  Successful upload is marked by a report of the upload time; unsuccessful upload will report any errors encountered.
</p>


<h3>Note</h3>

<p>The expected field order is <code>c("start.time", "end.time", "min.frq", "max.frq", "name")</code>.  <code>"name"</code> is intentionally ambiguous; it may be used to store the species code, but it is not referenced back to tblSpecies.fldSpeciesCode for verification.
</p>


<h3>Author(s)</h3>

<p>Jon Katz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+viewSpec">viewSpec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Assumes 'MABI01_2010-05-22_054400_0_000.wav' is a survey in tblSurvey.fldSurveyName
# Assumes 'MABI01_2010-05-22_054400.csv' is a file of annotations belonging to the above survey

## Not run: 
#If using the 'acoustics' schema verbatim:
dbUploadAnno(
    annotations = "MABI01_2010-05-22_054400.csv", 
    survey = "MABI01_2010-05-22_054400_0_000.wav", 
    analyst = 1)

#'acoustics' schema, different database name:
dbUploadAnno(
    annotations = "MABI01_2010-05-22_054400.csv", 
    survey = "MABI01_2010-05-22_054400_0_000.wav", 
    db.name = "LocalSQLdb", 
    uid = "EntryOnly", 
    pwd = "07H23BBM", 
    analyst = 1)
## End(Not run)
</code></pre>

<hr>
<h2 id='dbUploadResult'>Upload Detection Results to an Acoustics Database</h2><span id='topic+dbUploadResult'></span>

<h3>Description</h3>

<p>Upload detection results (peaks or detections) from <code><a href="#topic+findPeaks">findPeaks</a></code> directly to tblResult in an acoustics database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbUploadResult(detection.obj, which.one, what = "detections", db.name = "acoustics", 
               uid, pwd, analysis.type, analyst = "", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dbUploadResult_+3A_detection.obj">detection.obj</code></td>
<td>
<p>Object of class <code><a href="#topic+detectionList-class">detectionList</a></code> containing results from <code><a href="#topic+findPeaks">findPeaks</a></code>.</p>
</td></tr>
<tr><td><code id="dbUploadResult_+3A_which.one">which.one</code></td>
<td>
<p>Results from a single template can be selected for upload, or leave blank to upload results from all templates.</p>
</td></tr>
<tr><td><code id="dbUploadResult_+3A_what">what</code></td>
<td>
<p>Character value of either &quot;detections&quot; (the default; peaks above the score cutoff) or &quot;peaks&quot; (all peaks regardless of score cutoff).</p>
</td></tr>
<tr><td><code id="dbUploadResult_+3A_db.name">db.name</code></td>
<td>
<p>Name of the ODBC connector data source corresponding to the acoustics database.</p>
</td></tr>
<tr><td><code id="dbUploadResult_+3A_uid">uid</code></td>
<td>
<p>User ID to allow ODBC connector to connect to database, if not present in ODBC connector.</p>
</td></tr>
<tr><td><code id="dbUploadResult_+3A_pwd">pwd</code></td>
<td>
<p>Password to allow ODBC connector to connect to database, if not present in ODBC connector.</p>
</td></tr>
<tr><td><code id="dbUploadResult_+3A_analysis.type">analysis.type</code></td>
<td>
<p>Character value identifying analysis type, in c(&quot;BIN&quot;, &quot;COR&quot;).  Some partial matching is performed.</p>
</td></tr>
<tr><td><code id="dbUploadResult_+3A_analyst">analyst</code></td>
<td>
<p>Numerical key value corresponding to the user's tblPerson.pkPersonID value in the acoustics database.</p>
</td></tr>
<tr><td><code id="dbUploadResult_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>RODBC::odbcConnect</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dbUploadResult</code> assumes a database structure identical to that provided in the acoustics schema.  If the username and password are present in the ODBC datasource they do not need to be provided.  It is possible to store only the username in the datasource and enter a password, but the reverse will not work.
</p>
<p>The value for analyst must be present in tblPeople.pkPeopleID for upload to succeed.
</p>


<h3>Value</h3>

<p>Invoked for its side effect, which is to insert the detection results into tblResult in an acoustics database.  Successful upload is marked by a report of the upload time; unsuccessful upload will report any errors encountered.
</p>


<h3>Author(s)</h3>

<p>Jon Katz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findPeaks">findPeaks</a></code>, <code><a href="#topic+getPeaks">getPeaks</a></code>, <code><a href="#topic+getDetections">getDetections</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Not run, as it requires a database to receive the upload
# Load data
data(btnw)
data(survey)

# Write Wave objects to file (temporary directory used here)
btnw.fp &lt;- file.path(tempdir(), "btnw.wav")
survey.fp &lt;- file.path(tempdir(), "survey2010-12-31_120000_EST.wav")
writeWave(btnw, btnw.fp)
writeWave(survey, survey.fp)

# Template construction
b4 &lt;- makeBinTemplate(
    btnw.fp, 
    frq.lim = c(2, 8), 
    select = "auto", 
    name = "b4", 
    buffer = 4, 
    amp.cutoff = -31, 
    binary = TRUE)

# Binary point matching
scores &lt;- binMatch(survey = survey.fp, templates = b4, time.source = 'fileinfo')

# Isolate peaks
pks &lt;- findPeaks(scores)

#If using the 'acoustics' schema verbatim:
dbUploadResult(detection.obj = pks, analysis.type = "BIN", analyst = 1)

#'acoustics' schema, different database name:
dbUploadResult(
    detection.obj = pks, 
    which.one = "b4", 
    what = "peaks", 
    db.name = "LocalSQLdb", 
    uid = "EntryOnly" , 
    pwd = "07H23BBM", 
    analysis.type = "BIN", 
    analyst = 1)
## End(Not run)
    
    
    
</code></pre>

<hr>
<h2 id='dbUploadSurvey'>Upload Survey Metadata to an Acoustics Database</h2><span id='topic+dbUploadSurvey'></span>

<h3>Description</h3>

<p>Upload survey metadata to tblSurvey in an acoustics database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbUploadSurvey(db.name = "acoustics", uid, pwd, survey.meta, update.query = FALSE, 
               tz, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dbUploadSurvey_+3A_survey.meta">survey.meta</code></td>
<td>
<p>Object containing survey metadata, typically gathered in one or more invocations of <code><a href="#topic+fileCopyRename">fileCopyRename</a></code>.</p>
</td></tr>
<tr><td><code id="dbUploadSurvey_+3A_db.name">db.name</code></td>
<td>
<p>Name of the ODBC connector data source corresponding to the acoustics database.</p>
</td></tr>
<tr><td><code id="dbUploadSurvey_+3A_uid">uid</code></td>
<td>
<p>User ID to allow ODBC connector to connect to database, if not present in ODBC connector.</p>
</td></tr>
<tr><td><code id="dbUploadSurvey_+3A_pwd">pwd</code></td>
<td>
<p>Password to allow ODBC connector to connect to database, if not present in ODBC connector.</p>
</td></tr>
<tr><td><code id="dbUploadSurvey_+3A_update.query">update.query</code></td>
<td>
<p>Logical value to control the type of query.  See Details.</p>
</td></tr>
<tr><td><code id="dbUploadSurvey_+3A_tz">tz</code></td>
<td>
<p>Time zone, if not in file names or metadata.  See Details.</p>
</td></tr>
<tr><td><code id="dbUploadSurvey_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>RODBC::odbcConnect</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dbUploadSurvey</code> assumes a database structure identical to that provided in the acoustics schema.  If the username and password are present in the ODBC datasource they do not need to be provided.  It is possible to store only the username in the datasource and enter a password, but the reverse will not work.
</p>
<p>Surveys recorded as wav files have metadata read from the header of the file automatically; these data can be uploaded to the database in a single call to <code>dbUploadSurvey</code>.  Metadata for surveys recorded in proprietary compressed file formats cannot be gathered in the same manner; some basic metadata is gleaned from the initial transfer of the surveys from memory-card to storage drive, and the rest is read after the conversion from proprietary format to wav file. If recording in a proprietary format, normal operation would thus call for two invocations of <code>dbUploadSurvey</code>: the first with partial metadata, and the second as an update query to fill in the missing values.  Therefore, standard use (<code>update.query = FALSE</code>) passes a simple INSERT INTO query to the database and parses the fields appropriately.  When <code>update.query = TRUE</code>, the assumption is made that many of the fields in survey.meta have already been entered into the database, but some remain <code>NULL</code>.
</p>
<p>If no 'fldOriginalDateModified' exists in the metadata it will be automatically generated from the date coded in the file name during <code>fileCopyRename</code>.
</p>


<h3>Value</h3>

<p>Invoked for its side effect, which is to insert the detection results into tblResult in an acoustics database.  Successful upload is marked by a report of the upload time; unsuccessful upload will report any errors encountered.
</p>


<h3>Note</h3>

<p>This is a convenience function for users who are unfamiliar with SQL syntax and/or have not established an alternative front-end for their acoustics database.  Users capable of doing so may find more utility and flexibility writing custom queries directly either with an alternative front-end or <code>RODBC::sqlQuery</code>.  No processing is performed; data is uploaded to the database as it exists in the metadata object.
</p>


<h3>Author(s)</h3>

<p>Jon Katz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fileCopyRename">fileCopyRename</a></code>, <code><a href="#topic+mp3Subsamp">mp3Subsamp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# metadata for wav files:
metadata &lt;- fileCopyRename(
        from = '~/media/SDcard', 
        to = '~/Desktop/Acoustics/Recordings', 
        csv.dir = '~/Desktop/Acoustics/Results', 
        loc.prefix = 'MABI01', 
        ext = 'wav', 
        CardRecorderID = 1, 
        kaleidoscope = FALSE)
        
# If using the 'acoustics' schema verbatim:
dbUploadSurvey(survey.meta = metadata)

# 'acoustics' schema, different database name:
dbUploadSurvey(
    survey.meta = metadata, 
    db.name = "LocalSQLdb", 
    uid = "EntryOnly", 
    pwd = "07H23BBM")

# metadata for wac files:
metadata &lt;- fileCopyRename(
        from = '~/media/SDcard', 
        to = '~/Desktop/Acoustics/Recordings', 
        csv.dir = '~/Desktop/Acoustics/Results', 
        loc.prefix = 'MABI01', 
        ext = 'wac', 
        CardRecorderID = 1)
        
# If using the 'acoustics' schema verbatim:
dbUploadSurvey(survey.meta = metadata)

# 'acoustics' schema, different database name:
dbUploadSurvey(
    survey.meta = metadata, 
    db.name = "LocalSQLdb", 
    uid = "EntryOnly", 
    pwd = "07H23BBM")

# After converting wac files to wav files use update.query = TRUE:
new.metadata &lt;- fileCopyRename(
        from = '~/Desktop/Acoustics/Recordings', 
        to = '~/Desktop/Acoustics/Surveys', 
        csv.dir = '~/Desktop/Acoustics/Results', 
        loc.prefix = 'MABI01', 
        ext = 'wav', 
        CardRecorderID = 1, 
        metadata.only = TRUE)
        
# If using the 'acoustics' schema verbatim:
dbUploadSurvey(survey.meta = new.metadata, update.query = TRUE)

# 'acoustics' schema, different database name:
dbUploadSurvey(
    survey.meta = new.metadata, 
    db.name = "LocalSQLdb", 
    uid = "EntryOnly", 
    pwd = "07H23BBM", 
    update.query = TRUE)
## End(Not run)
</code></pre>

<hr>
<h2 id='dbUploadTemplate'>Upload Acoustic Templates to a Database</h2><span id='topic+dbUploadTemplate'></span>

<h3>Description</h3>

<p>Upload a binary point matching or correlation template list containing one or more templates to tblTemplate in an acoustics database.  One or more templates may be indexed by name or position from the template list for upload.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbUploadTemplate(templates, which.one, db.name = "acoustics", uid , pwd, analyst, 
locationID = "", date.recorded = "", recording.equip = "", species.code, 
type, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dbUploadTemplate_+3A_templates">templates</code></td>
<td>
<p><code>TemplateList</code> object of class <code>binTemplateList</code> or <code>corTemplateList</code> to upload.</p>
</td></tr>
<tr><td><code id="dbUploadTemplate_+3A_which.one">which.one</code></td>
<td>
<p>Indexing option for individual templates within the <code>TemplateList</code> object.  Indexing may be by name or numerical position.  If missing, all templates within the list are uploaded.</p>
</td></tr>
<tr><td><code id="dbUploadTemplate_+3A_db.name">db.name</code></td>
<td>
<p>Name of the ODBC connector data source corresponding to the acoustics database.</p>
</td></tr>
<tr><td><code id="dbUploadTemplate_+3A_uid">uid</code></td>
<td>
<p>User ID to allow ODBC connector to connect to database, if not present in ODBC connector.</p>
</td></tr>
<tr><td><code id="dbUploadTemplate_+3A_pwd">pwd</code></td>
<td>
<p>Password to allow ODBC connector to connect to database, if not present in ODBC connector.</p>
</td></tr>
<tr><td><code id="dbUploadTemplate_+3A_analyst">analyst</code></td>
<td>
<p>Numerical key value corresponding to the user's tblPerson.pkPersonID value in the acoustics database.</p>
</td></tr>
<tr><td><code id="dbUploadTemplate_+3A_locationid">locationID</code></td>
<td>
<p>Numerical key value corresponding to the location's tblLocation.pkLocationID value in the acoustics database.</p>
</td></tr>
<tr><td><code id="dbUploadTemplate_+3A_date.recorded">date.recorded</code></td>
<td>
<p>Dates template clip was recorded, in a recognizable POSIX format: YYYY/MM/DD.</p>
</td></tr>
<tr><td><code id="dbUploadTemplate_+3A_recording.equip">recording.equip</code></td>
<td>
<p>Equipment used to record template clip.</p>
</td></tr>
<tr><td><code id="dbUploadTemplate_+3A_species.code">species.code</code></td>
<td>
<p>Character value corresponding to the species' tblSpecies.fldSpeciesCode value in the acoustics database; usually a 4, 6, or 8-character code.  Codes not in the database will return a cryptic error and cause upload to fail.</p>
</td></tr>
<tr><td><code id="dbUploadTemplate_+3A_type">type</code></td>
<td>
<p>Character value identifying template type, in c(&quot;BIN&quot;, &quot;COR&quot;).  Some partial matching is performed.</p>
</td></tr>
<tr><td><code id="dbUploadTemplate_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>RODBC::odbcConnect</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dbUploadTemplate</code> assumes a database structure identical to that provided in the acoustics schema.  If the username and password are present in the ODBC datasource they do not need to be provided.  It is possible to store only the username in the datasource and enter a password, but the reverse will not work.
</p>
<p>The following must be true for upload to succeed:
The value for analyst must be present in tblPeople.pkPeopleID
The value for locationID must be present in tblLocation.pkLocationID
the value for species.code must be present in tblSpecies.fldSpeciesCode</p>


<h3>Value</h3>

<p>This function is invoked for its side effect, which is to insert the template list into tblTemplate in an acoustics database.  Successful upload is marked by a report of the upload time; unsuccessful upload will report any errors encountered.
</p>


<h3>Note</h3>

<p>In the acoustics database templates are broken into components, and vectors are stored as text objects in various fields.  Ultimately templates must be downloaded again to be used; to stay beneath the maximum download vector size of <code><a href="RODBC.html#topic+sqlQuery">sqlQuery</a></code>, extraneous characters are removed from each vector during upload.  All amplitude values for correlation templates are sign-inverted and converted from floating point decimal to integers, and all decimals are rounded to the hundredth's place before upload; after upload all spaces, new-line, and carriage return characters are removed.  Removal of these characters is usually the most time-consuming part of the upload process, and the console will report &quot;cleaning up&quot; while this is taking place.  These measures sometimes inadequately trim character count, and users may find it necessary to increase the maximum download vector size in sqlQuery (see the vignette &quot;MySQL_DataSources_RODBC&quot; for further details).  Large templates may take more than several seconds to upload; 2-5 seconds is normal for binary point matching templates, and 5-20 seconds is normal for correlation templates.
</p>


<h3>Author(s)</h3>

<p>Jon Katz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dbDownloadTemplate">dbDownloadTemplate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Template construction
## Not run: 
data(btnw)
b4 &lt;- makeBinTemplate(
    "btnw.wav", 
    frq.lim = c(2, 8), 
    select = "auto", 
    name = "b4", 
    buffer = 4, 
    amp.cutoff = -31, 
    binary = TRUE)

\dontrun{
#If using the 'acoustics' schema verbatim:
dbUploadTemplate(
    templates = b4, 
    analyst = 1, 
    locationID = "MABI01", 
    date.recorded = "2012/05/22", 
    recording.equip = "SM2", 
    species.code = "BTNW", 
    type = "BIN")
    
#'acoustics' schema, different database name:
dbUploadTemplate(
    templates = b4, 
    which.one = 1, 
    db.name = "LocalSQLdb", 
    uid = "EntryOnly", 
    pwd = "07H23BBM", 
    analyst = 1, 
    locationID = "MABI01", 
    date.recorded = "2012/05/22", 
    recording.equip = "SM2", 
    species.code = "BTNW", 
    type = "BIN")}

## End(Not run)
</code></pre>

<hr>
<h2 id='detectionList-class'>Class <code>"detectionList"</code></h2><span id='topic+detectionList-class'></span>

<h3>Description</h3>

<p>These objects contain information on template detections, as well as (almost) all the information contained in <code><a href="#topic+templateScores-class">templateScores</a></code> 
These objects represent the final result of the template detection process.
Various functions exist for working with these objects.
Information on the detections alone can be extracted with <code><a href="#topic+getDetections">getDetections</a></code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("detectionList", ...)</code>.
However, these objects should always be created by applying the <code><a href="#topic+findPeaks">findPeaks</a></code> to <code><a href="#topic+templateScores-class">templateScores</a></code> objects.
There are other functions the exist for modifying existing <code>detectionList</code> objects, including <code><a href="#topic+showPeaks">showPeaks</a></code>, and the combination of <code><a href="#topic+templateCutoff">templateCutoff</a></code> and <code><a href="#topic+findDetections">findDetections</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>survey.name</code>:</dt><dd><p>Object of class <code>"character"</code>. The name of the survey file, or <code>"A Wave object"</code> if the survey was not read in from a file.</p>
</dd>
<dt><code>survey</code>:</dt><dd><p>Object of class <code><a href="tuneR.html#topic+Wave">Wave</a></code>. The survey data, as a <code>"Wave"</code> object.</p>
</dd> 
<dt><code>survey.data</code>:</dt><dd><p>Object of class <code>list</code>. A named list, with one element for each template. Each element contains data from a Fourier transform of the original survey: <code>amp</code> is a matrix of amplitudes (frequency by time, r by column), <code>t.bins</code> is a numeric vector with the values of the time bins (left-aligned&ndash;first bin is always 0.0), and <code>frq.bins</code> is a numeric vector with the values of the frequency bins (top-aligned&ndash;last bin is always the upper limit). There is a separate element for each template because each template may use different parameters for the Fourier transform (see <code><a href="#topic+Template-class">Template</a></code>).</p>
</dd>
<dt><code>templates</code>:</dt><dd><p>Object of class <code>list</code>. A named list of templates, which is identical to the original <code><a href="#topic+TemplateList-class">TemplateList</a></code> used for template matching. This template list can be extracted with <code><a href="#topic+getTemplates">getTemplates</a></code>.</p>
</dd>
<dt><code>scores</code>:</dt><dd><p>Object of class <code>list</code>. A named list, with one element for each template. Each element is a data frame with three columns: <code>date.time</code> is the absolute time of the score, <code>time</code> is the relative time of the score (relative to the survey start), and <code>score</code> is the score. Times are based on the center of the template, and so <code>time</code> will not correspond to values in <code>t.bins</code> in the <code>survey.data</code> above if the template spans an even number of time bins.</p>
</dd>
<dt><code>peaks</code>:</dt><dd><p>Object of class <code>list</code>. A named list, with one element for each template. Each element is a data frame that contains information on peaks that were found. The first three columns are identical to those in the <code>scores</code> data frames (above) (but of course only contain those values that were identified as peaks). The fourth column is logical and indicates whether the peak was also a detection.</p>
</dd>
<dt><code>detections</code>:</dt><dd><p>Object of class <code>list</code>. A named list, with one element for each template. Each element is a data frame that contains information on detections. The columns are identical to those in the <code>scores</code> data frames (above) (but of course only contain those values that were identified as detections (i.e., peaks with a score above the <code>score.cutoff</code>).</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "detectionList")</code>: ... </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "detectionList")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Sasha D. Hafner
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findPeaks">findPeaks</a></code>, 
<code><a href="#topic+getDetections">getDetections</a></code>, 
<code><a href="#topic+templateCutoff">templateCutoff</a></code>, 
<code><a href="#topic+templateScores-class">templateScores</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("detectionList")



</code></pre>

<hr>
<h2 id='eventEval'>
Evaluate Detected Events with Known Event Sources and Times
</h2><span id='topic+eventEval'></span>

<h3>Description</h3>

<p>Evaluate whether the detected events are True +, True -, False +, or False - detections by comparing the results to a table of events with known sources and times (such as annotations from <code><a href="#topic+viewSpec">viewSpec</a></code>).  Events to evaluate may be either directly from an object of class <code><a href="#topic+detectionList-class">detectionList</a></code>, a csv file or data frame resulting from a call to <code><a href="#topic+getPeaks">getPeaks</a></code> or <code><a href="#topic+getDetections">getDetections</a></code>, or a data frame downloaded from an acoustics database.  A value for score.cutoff must be supplied to distinguish between True + and False -, even if assessing all peaks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eventEval(detections, what = "detections", which.one, standard, 
score.cutoff = 11, tol = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eventEval_+3A_detections">detections</code></td>
<td>
<p>An object of class <code><a href="#topic+detectionList-class">detectionList</a></code>, a csv file, or data frame containing detection results.  See Details.</p>
</td></tr>
<tr><td><code id="eventEval_+3A_what">what</code></td>
<td>
<p>If a <code>detectionList</code> object is supplied for <code>detections</code> the character value of either &quot;detections&quot; (default; all peaks above the score cutoff) or all &quot;peaks&quot; may be selected.</p>
</td></tr>
<tr><td><code id="eventEval_+3A_which.one">which.one</code></td>
<td>
<p>If the detection process involved multiple templates only one may be selected for evaluation.  Value can be either character (identifying the template name), or numerical (identifying the position in names(detections['template']).  See Details.</p>
</td></tr>
<tr><td><code id="eventEval_+3A_standard">standard</code></td>
<td>
<p>The &quot;standard&quot; is the results from annotation with <code>viewSpec</code> (i.e. Gold Standard) containing the source and time of each event.  Can be a data frame or a file path to a csv file.</p>
</td></tr>
<tr><td><code id="eventEval_+3A_score.cutoff">score.cutoff</code></td>
<td>
<p>If no template is supplied a <code>score.cutoff</code> can be supplied to evaluate false negatives.</p>
</td></tr>
<tr><td><code id="eventEval_+3A_tol">tol</code></td>
<td>
<p>Numeric value for tolerance, with units seconds.  If a detected event is within this value (actually +/- 0.5 x <code>tol</code>), the events are assumed to co-occur and be of the same origin.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Little checking is performed to ensure that evaluation is possible based on the values for detections and standard.  The standard must contain the fields <code>c("start.time", "end.time", "min.frq", "max.frq", "name")</code>.  Objects are assumed to be from an acoustics database if they contain the fields <code>c("fldTime", "fldScore", "fldTemplateName")</code>.  Data frames are assumed to be objects formerly of class <code><a href="#topic+detectionList-class">detectionList</a></code> if they contain the fields <code>c("time", "score", "template")</code>.<br />
</p>
<p>Results from only one template from one survey may be evaluated in each call to <code>eventEval</code>.
</p>


<h3>Value</h3>

<p>The detections data frame with an outcome field appended.
</p>


<h3>Note</h3>

<p><code>eventEval</code> performs the evaluation by merging the detections and standard data frames, ordering by time, and checking to see which rows occur within a value of <code>tol</code> to the row above. True + are defined as a detected event that co-occurrs in time with an event from the standard AND scores above or equal to the score.cutoff.  Such an event that scores below the score.cutoff is classified as a False -.  False - events may also be the product of an event from the standard failing to co-occur with any detected events.  True - events don't co-occur with any standard events, and False + events similarly don't co-occur with standard events but score above or equal to the score.cutoff.
</p>


<h3>Author(s)</h3>

<p>Jon Katz
</p>


<h3>See Also</h3>

<p>The function <code><a href="#topic+timeAlign">timeAlign</a></code> operates similarly, but rather than evaluate a set of detections against a standard it merges detections from multiple templates and retains only the co-occurring detections with the highest scores.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data(btnw)
data(survey)

# Write Wave objects to file (temporary directory used here)
btnw.fp &lt;- file.path(tempdir(), "btnw.wav")
survey.fp &lt;- file.path(tempdir(), "survey2010-12-31_120000_EST.wav")
writeWave(btnw, btnw.fp)
writeWave(survey, survey.fp)

# Make a template
btemp &lt;- makeBinTemplate(btnw.fp, frq.lim = c(2, 8), select = "auto", name = "btnw1", buffer =
                         4, amp.cutoff = -31, binary = TRUE)

# Binary point matching
scores &lt;- binMatch(survey = survey.fp, templates = btemp, time.source = "fileinfo")

# Isolate peaks
pks &lt;- findPeaks(scores)

# Evaluate peaks
data(survey_anno)

survey_anno &lt;- survey_anno[survey_anno['name'] == 'BTNW', ]  # Extract the "BTNW" rows

peaks &lt;- getPeaks(pks) 

eval &lt;- eventEval(detections = peaks, standard = survey_anno, score.cutoff = 15)



</code></pre>

<hr>
<h2 id='extract-methods'>Indexing (Extraction) Methods for <span class="pkg">monitoR</span> Package</h2><span id='topic++5B-methods'></span><span id='topic++5B+2CdetectionList-method'></span><span id='topic++5B+2CTemplateList-method'></span><span id='topic++5B+2CtemplateScores-method'></span>

<h3>Description</h3>

<p>These methods can be used to index detection list (<code><a href="#topic+detectionList-class">detectionList</a></code>), template lists (<code><a href="#topic+TemplateList-class">TemplateList</a></code>), and template scores (<code><a href="#topic+templateScores-class">templateScores</a></code>) objects.
Indexing is analogous to indexing a vector&ndash;with single square brackets, and character (template name) or integer (template position) values.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "detectionList")</code></dt><dd>
<p>Index by name or position of template(s).
</p>
</dd>
<dt><code>signature(x = "TemplateList")</code></dt><dd>
<p>Index by name or position of template(s).
</p>
</dd>
<dt><code>signature(x = "templateScores")</code></dt><dd>
<p>Index by name or position of template(s).
</p>
</dd>
</dl>

<hr>
<h2 id='fileCopyRename'>
Copy and Rename Sound Files from Portable Media
</h2><span id='topic+fileCopyRename'></span>

<h3>Description</h3>

<p>Collects a variety of metadata about recordings that will be acoustic surveys and encodes the date modified into the file name.  Copies files between directories to move them for an SD card to a hard disk, for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fileCopyRename(files, from = ".", to, csv.dir = to, csv.name, loc.prefix, ext, 
rec.tz = NA, hours.offset = 0, CardRecorderID = NA, kaleidoscope = TRUE, 
split.channels = FALSE, metadata.only = FALSE, full.survey.names = FALSE, 
rename = TRUE, copy = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fileCopyRename_+3A_files">files</code></td>
<td>
<p>Optional vector of mp3, WAC, or WAV files to extract surveys from.</p>
</td></tr>
<tr><td><code id="fileCopyRename_+3A_from">from</code></td>
<td>
<p>Directory containing mp3, WAC, or WAV recordings to extract survey from; required only if <code>files</code> is missing.</p>
</td></tr>
<tr><td><code id="fileCopyRename_+3A_to">to</code></td>
<td>
<p>Directory where surveys will be placed after extraction.</p>
</td></tr>
<tr><td><code id="fileCopyRename_+3A_csv.dir">csv.dir</code></td>
<td>
<p>Directory where csv file of survey metadata will be saved; defaults to the <code>to</code> directory.</p>
</td></tr>
<tr><td><code id="fileCopyRename_+3A_csv.name">csv.name</code></td>
<td>
<p>Name to save csv file of metadata, character value ending in .csv</p>
</td></tr>
<tr><td><code id="fileCopyRename_+3A_loc.prefix">loc.prefix</code></td>
<td>
<p>Character value identifying the location at which the recording was made.  Will be used in the file name (see Details) and the csv file name.  Must be in tblLocation.fldLocationName in the acoustics database.</p>
</td></tr>
<tr><td><code id="fileCopyRename_+3A_ext">ext</code></td>
<td>
<p>three-characters.  The file extension defining the type of files to move, rename, and collect metadata on.  Typically in <code>c("wav", "wac")</code></p>
</td></tr>
<tr><td><code id="fileCopyRename_+3A_rec.tz">rec.tz</code></td>
<td>
<p>Time zone for which the recordings were made (optional). Needed if different from the time zone setting of the operating system, when times will be adjusted to the &lsquo;correct&rsquo; time zone. See details.</p>
</td></tr>
<tr><td><code id="fileCopyRename_+3A_hours.offset">hours.offset</code></td>
<td>
<p>Hours to offset the modification time. Minimally useful when the recorder clock was set incorrectly. Use not at all, or if you must, with caution.</p>
</td></tr>
<tr><td><code id="fileCopyRename_+3A_cardrecorderid">CardRecorderID</code></td>
<td>
<p>Numeric key value from tblCardRecorder.pkCardRecorderID, which links the recorder that made the recording with the location it was recorded.</p>
</td></tr>
<tr><td><code id="fileCopyRename_+3A_kaleidoscope">kaleidoscope</code></td>
<td>
<p>Logical. If <code>ext = "wac"</code> files must be converted to .wav in Kaleidoscope.  Setting to <code>TRUE</code> anticipates the renaming by Kaleidoscope.</p>
</td></tr>
<tr><td><code id="fileCopyRename_+3A_split.channels">split.channels</code></td>
<td>
<p>Logical. If <code>ext = "wac"</code> files must be converted to .wav in Kaleidoscope.  Setting to <code>TRUE</code> anticipates further renaming by Kaleidoscope.</p>
</td></tr>
<tr><td><code id="fileCopyRename_+3A_metadata.only">metadata.only</code></td>
<td>
<p>Logical.  If <code>ext = "wac"</code> files must be converted to .wav before metadata can be collected; this argument typically is used in the second pass to collect the metadata.</p>
</td></tr>
<tr><td><code id="fileCopyRename_+3A_full.survey.names">full.survey.names</code></td>
<td>
<p>Logical.  <code>TRUE</code> will use the full file path for the survey name in the resulting metadata table.  In those cases the full path name will be stored in the database as well.  Useful for coping with nested or disparate survey directories.</p>
</td></tr>
<tr><td><code id="fileCopyRename_+3A_rename">rename</code></td>
<td>
<p>Logical.  <code>FALSE</code> will disable renaming.</p>
</td></tr>
<tr><td><code id="fileCopyRename_+3A_copy">copy</code></td>
<td>
<p>Logical.  <code>FALSE</code> will disable file copying.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The file name is where two important pieces of metadata are encoded: the location (as the location prefix) and the date and time of recording (as the date modified of the original file). The detection functions <code><a href="#topic+corMatch">corMatch</a></code> <code><a href="#topic+binMatch">binMatch</a></code> are capable of using this data as a time reference. Time zone management is tricky; if recordings were made in a different time zone than the OS running <code>fileCopyRename</code>, specify the correct time zone for the recordings with the <code>rec.tz</code> argument. Unexpected results are possible, as time zone abbreviations in general use may not match those in the Internet Assigned Numbers Authority tz database. The most reliable way to specify time zone is to use the full name, most quickly seen using <code><a href="base.html#topic+OlsonNames">OlsonNames</a></code>, and also found on wikipedia: <a href="http://en.wikipedia.org/wiki/List_of_tz_database_time_zones">http://en.wikipedia.org/wiki/List_of_tz_database_time_zones</a>.
Metadata cannot be read for non-wave recordings, so typically a first function call is used to encode the location prefix and date modified into the file name and move it from the portable media, and a second function call with <code>metadata.ony = TRUE</code> is used after conversion to wave format to fill in the missing metadata.  
The <code>full.survey.names</code> argument is designed to permit the batch processing of sound files saved in different directories.
</p>


<h3>Value</h3>

<p>A data frame of metadata about the surveys.  Contains column names &quot;fldOriginalDateModified&quot;, &quot;fldOriginalRecordingName&quot;, &quot;fldSurveyName&quot;, &quot;fldRecordingFormat&quot;, &quot;fkCardRecorderID&quot;, &quot;fldSurveyLength&quot;, &quot;fldSampleRate&quot;, &quot;fldBitsperSample&quot;, and &quot;fldChannels&quot;.  Column names reflect the assumption that this data will become a catalog of surveys stored in the database.
</p>


<h3>Author(s)</h3>

<p>Jon Katz
</p>


<h3>References</h3>

<p>Time zone conversion assisted by a post on David Smith's Revolutions blog, June 02, 2009: <a href="http://blog.revolutionanalytics.com/2009/06/converting-time-zones.html">http://blog.revolutionanalytics.com/2009/06/converting-time-zones.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mp3Subsamp">mp3Subsamp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Not run because it will create a file in user's working directory
data(survey)

writeWave(survey, "survey.wav")

meta &lt;- fileCopyRename(
            files = "survey.wav", 
            to = getwd(), 
            csv.name = "sampleMeta.csv", 
            loc.prefix = "MABI06", 
            ext = "wav", 
            CardRecorderID = 1)
            
# If your recorder's clock is set to GMT but your OS is not:            
altmeta &lt;- fileCopyRename(
               files = "survey.wav", 
               to = getwd(), 
               csv.name = "sampleMeta.csv", 
               loc.prefix = "MABI06", 
               ext = "wav", 
               rec.tz = "GMT", 
               CardRecorderID = 1)
            
file.remove("survey.wave")
## End(Not run)
</code></pre>

<hr>
<h2 id='findPeaks'>
Find Score Peaks and Detections in a <code>templateScores</code> Object
</h2><span id='topic+findPeaks'></span>

<h3>Description</h3>

<p>This function accepts <code>templateScores</code> objects and returns information on all score peaks and those peaks that are considered detections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findPeaks(score.obj, fd.rat = 1, frame, parallel = FALSE)
  </code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findPeaks_+3A_score.obj">score.obj</code></td>
<td>

<p>A <code>templateScores</code> object, produced by <code>corMatch</code> or <code>binMatch</code>.
</p>
</td></tr>
<tr><td><code id="findPeaks_+3A_fd.rat">fd.rat</code></td>
<td>

<p>A ratio of frame width (twice minimum peak separation) to template duration. 
</p>
</td></tr>
<tr><td><code id="findPeaks_+3A_frame">frame</code></td>
<td>

<p>If you want the same frame width for templates with varying duration, specify a value directly.
<code>fd.rate</code> will be ignored if <code>frame</code> is specified.
</p>
</td></tr>
<tr><td><code id="findPeaks_+3A_parallel">parallel</code></td>
<td>

<p>Set to <code>TRUE</code> for parallel processing using <code><a href="parallel.html#topic+mclapply">mclapply</a></code>.
This option is not available for Windows operating systems.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>findPeaks</code> function translates raw scores from template matching to detection information, by finding peaks in the score data, and determining which peaks, if any, exceed the score cutoffs specified in the templates (see the two functions for making templates, <code><a href="#topic+makeBinTemplate">makeBinTemplate</a></code> and <code><a href="#topic+makeCorTemplate">makeCorTemplate</a></code> and <code><a href="#topic+templateCutoff">templateCutoff</a></code> for more details on cutoffs). 
</p>


<h3>Value</h3>

<p>An S4 object of class <code>templateScores</code>, with the following slots:
</p>
<table role = "presentation">
<tr><td><code>survey.name</code></td>
<td>
<p>The file path to the survey that the scores apply to.</p>
</td></tr>
<tr><td><code>survey</code></td>
<td>
<p>The actual survey as a <code>Wave</code> object.</p>
</td></tr>
<tr><td><code>survey.data</code></td>
<td>
<p>A named list with one element per template.
Each element is a named list with time-domain results for the survey.
</p>
</td></tr>
<tr><td><code>templates</code></td>
<td>
<p>The templates (an S4 object of class <code>corTemplateList</code> or <code>binTemplateList</code>) used to calculate the scores.</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>A named list with an element for each template.
Each element contains the scores for an individual template.
</p>
</td></tr>
<tr><td><code>peaks</code></td>
<td>
<p>A named list with peak information (as a data frame) for each template.</p>
</td></tr>
<tr><td><code>detections</code></td>
<td>
<p>A named list with detection information (as a data frame) for each template.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sasha D. Hafner and Jon Katz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeCorTemplate">makeCorTemplate</a></code>, 
<code><a href="#topic+makeBinTemplate">makeBinTemplate</a></code>, 
<code><a href="#topic+corMatch">corMatch</a></code>, 
<code><a href="#topic+binMatch">binMatch</a></code>, 
<code><a href="#topic+getDetections">getDetections</a></code>, 
<code><a href="#topic+getPeaks">getPeaks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data(btnw)
data(oven)
data(survey)

# Write Wave objects to file (temporary directory used here)
btnw.fp &lt;- file.path(tempdir(), "btnw.wav")
oven.fp &lt;- file.path(tempdir(), "oven.wav")
survey.fp &lt;- file.path(tempdir(), "survey2010-12-31_120000_EST.wav")
writeWave(btnw, btnw.fp)
writeWave(oven, oven.fp)
writeWave(survey, survey.fp)

# Correlation example
# Create two correlation templates
wct &lt;- makeCorTemplate(btnw.fp, t.lim = c(1.5, 2.1), frq.lim = c(4.2, 5.6), name = "w")

oct &lt;- makeCorTemplate(oven.fp, t.lim = c(1, 4), frq.lim = c(1, 11), dens = 0.1, name = "o")

# Combine them
ctemps &lt;- combineCorTemplates(wct, oct)

# Calculate scores
cscores &lt;- corMatch(survey.fp, ctemps)

# Finally, find peaks and detections
cdetects &lt;- findPeaks(cscores)

cdetects

plot(cdetects)

# plotting help:
method?plot('detectionList')

# Binary example
## Not run: 
# Not run because of the time required (maybe 2-5 seconds) Create two templates
wbt &lt;- makeBinTemplate(btnw.fp, amp.cutoff = -30, t.lim = c(1.5, 2.1), frq.lim = c(4.2, 5.6),
                       buffer = 2, name = "w")

obt &lt;- makeBinTemplate(oven.fp, amp.cutoff = -20, t.lim = c(1, 4), frq.lim = c(1, 11), 
                       name = "o")

# Combine them
btemps &lt;- combineBinTemplates(wbt, obt)

# Calculate scores
bscores &lt;- binMatch(survey.fp, btemps)

# Finally, find peaks and detections
bdetects &lt;- findPeaks(bscores)

bdetects

plot(bdetects)

## End(Not run)

# Clean up (only because these files were created in these examples)
file.remove(btnw.fp)
file.remove(oven.fp)
file.remove(survey.fp)
</code></pre>

<hr>
<h2 id='getDetections'>
Extract Detections or Peaks from a <code>detectionList</code> Object
</h2><span id='topic+getDetections'></span><span id='topic+getPeaks'></span>

<h3>Description</h3>

<p>These functions return detection and peak timing and scores from a <code>detectionList</code> object for one or more templates used to create the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDetections(detection.obj, which.one = names(detection.obj@detections), id = NULL, 
              output = "data frame")

getPeaks(detection.obj, which.one = names(detection.obj@detections), id = NULL, 
         output = "data frame")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getDetections_+3A_detection.obj">detection.obj</code></td>
<td>

<p>The <code>detectionList</code> object.
</p>
</td></tr>
<tr><td><code id="getDetections_+3A_which.one">which.one</code></td>
<td>

<p>The name(s) of the template(s) for which results should be returned.
Character vector.
</p>
</td></tr>
<tr><td><code id="getDetections_+3A_id">id</code></td>
<td>

<p>Additional information that will be added as an additional column in the returned data frame(s).
By default, no column is added.
Length-one vector.
</p>
</td></tr>
<tr><td><code id="getDetections_+3A_output">output</code></td>
<td>

<p>Type of output, can be <code>"data frame"</code> or <code>"list"</code>.
List output contains a single element (a data frame) for each template.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>id</code> argument is for adding an identifying &ldquo;tag&rdquo; to the output.
This could be useful when, e.g., extracting detections for multiple surveys and then combining all results into a single data frame.
</p>


<h3>Value</h3>

<p>A data frame with up to six (seven for <code>getPeaks</code>) columns: <code>id</code> (from the <code>id</code> argument) (optional), template name (<code>template</code>), date and time (<code>date.time</code>, relative <code>time</code> (relative to the recording start), <code>score</code>, and verification results (<code>true</code>) (only present if the <code>detectionList</code> contains verification results from <code>showPeaks</code>).
Or, a list with a separate data frame for each template.
For <code>getPeaks</code>, there is also a <code>detection</code> column, with <code>TRUE</code> when a peak has been identified as a detection.
</p>


<h3>Author(s)</h3>

<p>Sasha D. Hafner
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findPeaks">findPeaks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data(btnw)
data(oven)
data(survey)

# Write Wave objects to file (temporary directory used here)
btnw.fp &lt;- file.path(tempdir(), "btnw.wav")
oven.fp &lt;- file.path(tempdir(), "oven.wav")
survey.fp &lt;- file.path(tempdir(), "survey2010-12-31_120000_EST.wav")
writeWave(btnw, btnw.fp)
writeWave(oven, oven.fp)
writeWave(survey, survey.fp)

# Correlation example
# Create two correlation templates
wct &lt;- makeCorTemplate(btnw.fp, t.lim = c(1.5, 2.1), frq.lim = c(4.2, 5.6), name = "w")
oct &lt;- makeCorTemplate(oven.fp, t.lim = c(1, 4), frq.lim = c(1, 11), dens = 0.1, name = "o")

# Combine both of them
ctemps &lt;- combineCorTemplates(wct, oct)

# Calculate scores
cscores &lt;- corMatch(survey.fp, ctemps)

# Find peaks
cdetects &lt;- findPeaks(cscores)

# Finally, get detections
getDetections(cdetects)

# If list is preferred
getDetections(cdetects, output = "list")

# For select templates
getDetections(cdetects, which.one = 1)
getDetections(cdetects, which.one = "w")

# Or for all peaks
getPeaks(cdetects)
getPeaks(cdetects, output = "list")
getPeaks(cdetects, which.one = 1)

# Clean up (only because these files were created in these examples)
file.remove(btnw.fp)
file.remove(oven.fp)
file.remove(survey.fp)
</code></pre>

<hr>
<h2 id='getTemplates'>
Extract a Template List
</h2><span id='topic+getTemplates'></span>

<h3>Description</h3>

<p>Use this function to extract template lists from <code><a href="#topic+templateScores-class">templateScores</a></code> or <code><a href="#topic+detectionList-class">detectionList</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTemplates(object, which.ones = names(object@templates))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getTemplates_+3A_object">object</code></td>
<td>

<p>The <code>templateScores</code> or <code>detectionList</code> object that contains the templates that are to be extracted. 
</p>
</td></tr>
<tr><td><code id="getTemplates_+3A_which.ones">which.ones</code></td>
<td>

<p>Which templates should be included?
A character vector of templates names, or an integer vector.
Default is all templates.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function would typically be used to extract and save a complete set of templates from a <code><a href="#topic+detectionList-class">detectionList</a></code> object if <code><a href="#topic+templateCutoff">templateCutoff</a></code> has been used to modify the template list after scores were calculated. 
<code>getTemplates</code> could also be used to extract a subset of templates present in a template list, but indexing with square brackets is an easier approach.
</p>


<h3>Value</h3>

<p>A template list of class <code>corTemplateList</code> or <code>binTemplateList</code>.
</p>


<h3>Author(s)</h3>

<p>Sasha D. Hafner
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeCorTemplate">makeCorTemplate</a></code>, 
<code><a href="#topic+makeBinTemplate">makeBinTemplate</a></code>, 
<code><a href="#topic+templateCutoff">templateCutoff</a></code>, 
<code><a href="#topic+templateComment">templateComment</a></code>
</p>

<hr>
<h2 id='internals'>
<code>monitoR</code> Internal Functions
</h2><span id='topic+dBweight'></span><span id='topic+ftwindow'></span><span id='topic+hamming.w'></span><span id='topic+hanning.w'></span><span id='topic+blacktop.w'></span><span id='topic+flattop.w'></span><span id='topic+rectangle.w'></span><span id='topic+rbindf'></span><span id='topic+spectro'></span><span id='topic+stft'></span><span id='topic+findDetections'></span><span id='topic+getClip'></span><span id='topic+getOneClip'></span><span id='topic+readClip'></span><span id='topic+readOneBinTemplate'></span><span id='topic+readOneCorTemplate'></span><span id='topic+writeOneBinTemplate'></span><span id='topic+writeOneCorTemplate'></span><span id='topic+mp3Subsamp.one'></span>

<h3>Description</h3>

<p>These functions are used by other functions in the monitoR package, but are not intended to be called by users.
The functions are:
<code>dBweight</code>, 
<code>ftwindow</code>, 
<code>hamming.w</code>, 
<code>hanning.w</code>, 
<code>blackman.w</code>, 
<code>flattop.w</code>, 
<code>rectangle.w</code>, 
<code>rbindf</code>, 
<code>spectro</code>, 
<code>stft</code>, 
<code>findDetections</code>, 
<code>getClip</code>, 
<code>getOneClip</code>, 
<code>readClip</code>, 
<code>readOneBinTemplate</code>, 
<code>readOneCorTemplate</code>, 
<code>writeOneBinTemplate</code>, 
<code>writeOneCorTemplate</code>, 
and <code>mp3Subsamp.one</code>
</p>


<h3>Details</h3>

<p>The first six functions listed above are functions of the same name in the excellent <span class="pkg">seewave</span> package, written by Jerome Sueur, Thierry Aubin, and Caroline Simonis.
Except for <code>spectro</code>, these functions were copied directly from <span class="pkg">seewave</span>.
Our version of <code>spectro</code> is used only for the Fourier transform here, and so excludes the plotting options of the <code>seewave</code> version, and also includes a few small changes in identifying values for time and frequency bins.
The remaining five functions taken from <span class="pkg">seewave</span> are called only by the <code>spectro</code> function.
The author list given below includes the <span class="pkg">seewave</span> authors to acknowledge our use of their code.
The remaining seven functions listed above are used to read audio files or read and write templates to file.
To carry out these tasks, users should use the functions listed below in the &ldquo;See Also&rdquo; section.
</p>


<h3>Author(s)</h3>

<p>Sasha D. Hafner, 
Jon Katz, 
Jerome Sueur, 
Thierry Aubin, 
Caroline Simonis
</p>


<h3>See Also</h3>

<p><code><a href="tuneR.html#topic+writeWave">writeWave</a></code>, 
<code><a href="tuneR.html#topic+readWave">readWave</a></code>, 
<code><a href="#topic+writeBinTemplates">writeBinTemplates</a></code>, 
<code><a href="#topic+writeCorTemplates">writeCorTemplates</a></code>, 
<code><a href="#topic+readBinTemplates">readBinTemplates</a></code>, 
<code><a href="#topic+readCorTemplates">readCorTemplates</a></code>, 
<code><a href="seewave.html#topic+spectro">spectro</a></code>
</p>

<hr>
<h2 id='makeTemplate'>
Make an Acoustic Template
</h2><span id='topic+makeCorTemplate'></span><span id='topic+makeBinTemplate'></span>

<h3>Description</h3>

<p>Functions for creating a spectrogram cross-correlation template or a binary point matching template for later use in identification of acoustic signals.
A template is made by manually or automatically selecting cells within a Fourier-transformed representation (a spectrogram) of an audio recording.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 

makeCorTemplate(clip, t.lim = NA, frq.lim = c(0, 12), select = "auto", dens = 1,
                score.cutoff = 0.4, name = "A", comment = "", spec.col = gray.3(), 
                sel.col = ifelse(dens == 1, "#99009975", "orange"),
                wl = 512, ovlp = 0, wn = "hanning", write.wav = FALSE, ...)

makeBinTemplate(clip, t.lim = NA, frq.lim = c(0, 12), select = "auto", binary = TRUE, 
                buffer = 0, dens = 1, score.cutoff = 12, name = "A", comment = "", 
                amp.cutoff = "i", shift = "i", high.pass = -Inf, spec.col = gray.3(), 
                bin.col = c("white", "black"), 
                quat.col = c("white", "gray40", "gray75", "black"), 
                sel.col = c("orange", "blue"), legend.bg.col = "#2E2E2E94", 
                legend.text.col = "black", wl = 512, ovlp = 0, wn = "hanning", 
                write.wav = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeTemplate_+3A_clip">clip</code></td>
<td>

<p>A file path to one wav or mp3 file, or a Wave object (but see 'Details' for this case).
Or, for <code>makeBinTemplate</code> only, a list or vector of two such objects.
Character vector or list. 
</p>
</td></tr>
<tr><td><code id="makeTemplate_+3A_t.lim">t.lim</code></td>
<td>

<p>Time limits of the spectrogram plot or template itself, or a list of exactly two such vectors.
Length two numeric vector.
</p>
</td></tr>
<tr><td><code id="makeTemplate_+3A_frq.lim">frq.lim</code></td>
<td>

<p>Frequency limits of spectrogram plot or template.
Length two numeric vector.
</p>
</td></tr>
<tr><td><code id="makeTemplate_+3A_select">select</code></td>
<td>

<p>How should points be selected? 
Options are &quot;cell&quot;, &quot;rectangle&quot;, &quot;auto&quot;.
Length one character vector. 
</p>
</td></tr>
<tr><td><code id="makeTemplate_+3A_binary">binary</code></td>
<td>

<p>Should plot be binary?
Length one logical vector. 
</p>
</td></tr>
<tr><td><code id="makeTemplate_+3A_buffer">buffer</code></td>
<td>

<p>The size of a buffer (in number of time by frequency bins) around &ldquo;on&rdquo; points for select = &quot;rectangle&quot; and select = &quot;auto&quot; for <code>makeBinTemplate</code>.
Bins within the buffer will not be included as &ldquo;on&rdquo; or &ldquo;off&rdquo; points.
Length one integer vector.
</p>
</td></tr>
<tr><td><code id="makeTemplate_+3A_dens">dens</code></td>
<td>

<p>Approximate density of points included with select = &quot;rectangle&quot; and select = &quot;auto&quot; as a fraction of 1.0.
Length one numeric vector.
</p>
</td></tr>
<tr><td><code id="makeTemplate_+3A_score.cutoff">score.cutoff</code></td>
<td>

<p>The numeric value set for the <code>score.cutoff</code> element of the resulting template.
This value will determine which peaks qualify as detections when the resulting template is used in a complete detection analysis.
Length one numeric vector.
</p>
</td></tr>
<tr><td><code id="makeTemplate_+3A_name">name</code></td>
<td>

<p>The name of the template, which will be associated with the template.
To change the name of an existing template, see <code>templatenames</code>.
Length one character vevetor.
</p>
</td></tr>
<tr><td><code id="makeTemplate_+3A_comment">comment</code></td>
<td>

<p>Comment that will be saved with the template.
See <code><a href="#topic+templateComment">templateComment</a></code>.
</p>
</td></tr>
<tr><td><code id="makeTemplate_+3A_amp.cutoff">amp.cutoff</code></td>
<td>

<p>Amplitude cutoff for creating a binary plot.
Length one numeric vector or else <code>"i"</code> for interactive selection.
</p>
</td></tr>
<tr><td><code id="makeTemplate_+3A_shift">shift</code></td>
<td>

<p>When two clips are used, the forward shift for the second clip, in time bins.
Length one integer vector, or <code>"i"</code> for interactive.
</p>
</td></tr>
<tr><td><code id="makeTemplate_+3A_high.pass">high.pass</code></td>
<td>

<p>High-pass filter value. 
All amplitudes below this frequency will be set to the minimum.
</p>
</td></tr>
<tr><td><code id="makeTemplate_+3A_spec.col">spec.col</code></td>
<td>

<p>A color palette function for the spectrogram when <code>binary = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="makeTemplate_+3A_bin.col">bin.col</code></td>
<td>

<p>Colors for the spectrogram when <code>binary = TRUE</code>.
Length two character vector: <code>bin.col[1]</code> for cells below the cutoff, <code>bin.col[2]</code> for cells above the cutoff.
</p>
</td></tr>
<tr><td><code id="makeTemplate_+3A_quat.col">quat.col</code></td>
<td>

<p>Colors for the spectrogram when using two clips.
Length four character vector: <code>bin.col[1]</code> for cells below the cutoff for both clips, <code>bin.col[2]</code> for cells above the cutoff for clip 1 only, <code>bin.col[3]</code> for cells above the cutoff for clip 2 only, <code>bin.col[4]</code> for cells above the cutoff for both clips.
</p>
</td></tr>
<tr><td><code id="makeTemplate_+3A_sel.col">sel.col</code></td>
<td>

<p>The color for displaying selected cells.
</p>
</td></tr>
<tr><td><code id="makeTemplate_+3A_legend.bg.col">legend.bg.col</code></td>
<td>

<p>The color of the legend background.
</p>
</td></tr>
<tr><td><code id="makeTemplate_+3A_legend.text.col">legend.text.col</code></td>
<td>

<p>Legend text color.
</p>
</td></tr>
<tr><td><code id="makeTemplate_+3A_wl">wl</code></td>
<td>

<p>The <code>wl</code> argument sent to the <code>spectro</code> function.
</p>
</td></tr>
<tr><td><code id="makeTemplate_+3A_ovlp">ovlp</code></td>
<td>

<p>The <code>ovlp</code> argument sent to the <code>spectro</code> function.
</p>
</td></tr>
<tr><td><code id="makeTemplate_+3A_wn">wn</code></td>
<td>

<p>The <code>wn</code> argument sent to the <code>spectro</code> function.
</p>
</td></tr>
<tr><td><code id="makeTemplate_+3A_write.wav">write.wav</code></td>
<td>

<p>If <code>clip</code> is a <code>Wave</code> object, should it be written to file? If <code>FALSE</code>, functions will return an error.
</p>
</td></tr>
<tr><td><code id="makeTemplate_+3A_...">...</code></td>
<td>

<p>Additional arguments to <code>spectro</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>makeCorTemplate</code> is used for making correlation templates, while <code>makeBinTemplate</code> is used to make binary point matching templates.
<code>makeBinTemplate</code> can be used with one or two recordings (<code>clip</code> argument).
If the <code>clip</code> argument is a <code>Wave</code> object, the functions will attempt to write the object(s) to a wav file(s) in the working directory, but only if the <code>write.wav</code> argument is <code>TRUE</code>. 
To use templates produced with these functions, see <code><a href="#topic+corMatch">corMatch</a></code> or <code><a href="#topic+binMatch">binMatch</a></code>.
To combine template lists, see <code><a href="#topic+combineCorTemplates">combineCorTemplates</a></code> or <code><a href="#topic+combineBinTemplates">combineBinTemplates</a></code>.
</p>


<h3>Value</h3>

<p>An S4 object of class <code><a href="#topic+corTemplateList-class">corTemplateList</a></code> (returned by <code>makeCorTemplate</code>) or <code><a href="#topic+binTemplateList-class">binTemplateList</a></code> (returned by <code>makeBinTemplate</code>).
</p>


<h3>Author(s)</h3>

<p>Sasha D. Hafner and Jon Katz
</p>


<h3>References</h3>

<p>Mellinger, DK, Clark, CW. 1997. Methods for automatic detection of mysticete sounds. <em>Marine and Freshwater Behaviour and Physiology</em> <b>29</b>, 163-181.
</p>
<p>Towsey M, Planitz, B, Nantes, A, Wimmer, J, Roe, P.  2012.  A toolbox for animal call recognition.  <em>Bioacoustics</em> <b>21</b>, 107-125.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corMatch">corMatch</a></code>, 
<code><a href="#topic+binMatch">binMatch</a></code>, 
<code><a href="#topic+templateNames">templateNames</a></code>, 
<code><a href="#topic+templateCutoff">templateCutoff</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load example Wave objects
data(btnw)
data(oven)

# Use a Wave object directly to make a template
## Not run: 
# Not run because it will create a file in user's working directory with write.wav = TRUE
wct1 &lt;- makeCorTemplate(btnw, name = "w1", write.wav = TRUE)
wct1

## End(Not run)

# For traceability, better to use acoustic files
# Here, first write Wave objects to file (temporary directory used here)
btnw.fp &lt;- file.path(tempdir(), "btnw.wav")
oven.fp &lt;- file.path(tempdir(), "oven.wav")
writeWave(btnw, btnw.fp)
writeWave(oven, oven.fp)

# Use default arguments except for name
wct1 &lt;- makeCorTemplate(btnw.fp, name = "w1")

# Specify time and frequency limits to focus on a smaller area
wct2 &lt;- makeCorTemplate(btnw.fp, t.lim = c(1.5, 2.1), frq.lim = c(4.2, 5.6), name = "w2")

# For finer control, see options for select argument, e.g., 
## Not run: 
# Not run because requires user interaction
wct3 &lt;- makeCorTemplate(btnw.fp, select = "cell", name = "w3")
wct4 &lt;- makeCorTemplate(btnw.fp, select = "rectangle", name = "w4")

## End(Not run)

# Use a different recording--different species here
oct1 &lt;- makeCorTemplate(oven.fp, name = "o1", t.lim = c(1, 4), frq.lim = c(1, 11))

# Reduce cell density
oct2 &lt;- makeCorTemplate(oven.fp, name = "o2", t.lim = c(1, 4), frq.lim = c(1, 11), 
                        dens = 0.1)

# Binary templates are similar
# By default, amplitude cutoff is interactively set
## Not run: 
wbt1 &lt;- makeBinTemplate(btnw.fp, name = "w1")

## End(Not run)

# Or specify cutoff directly
wbt1 &lt;- makeBinTemplate(btnw.fp, amp.cutoff = -40, name = "w1")

# Specify time and frequency limits to focus on a smaller area in spectrogram, and add a 
# buffer
## Not run: 
wbt2 &lt;- makeBinTemplate(btnw.fp, amp.cutoff = -30, t.lim = c(1.5, 2.1), 
                        frq.lim = c(4.2, 5.6), buffer = 2, name = "w2")

## End(Not run)

# For finer control, see options for select argument, e.g., 
## Not run: 
# Not run because it requires user input to select cells for the template
wbt3 &lt;- makeBinTemplate(btnw.fp, amp.cutoff = -40, t.lim = c(0.5, 2.5), 
                        frq.lim = c(1, 11), select = "cell", name = "w3")

wbt4 &lt;- makeBinTemplate(btnw.fp, amp.cutoff = -40, t.lim = c(0.5, 2.5), 
                        frq.lim = c(1, 11), select = "rectangle", buffer = 3, name = "w4")

## End(Not run)

# Clean up (only because these files were created in these examples)
file.remove(btnw.fp)
file.remove(oven.fp)

# TemplateList plotting help:
method?plot('TemplateList')
</code></pre>

<hr>
<h2 id='mp3Subsamp'>
Extract Short Surveys from Longer mp3 Recordings
</h2><span id='topic+mp3Subsamp'></span>

<h3>Description</h3>

<p>Extract short surveys from longer mp3 recordings without decoding and re-encoding.  Collects metadata about surveys for upload to an acoustic database and renames files with original date modified.  Timing options are one or more surveys per hour starting at the beginning time of the recording or one survey per hour starting on each hour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mp3Subsamp(files, from = ".", to, csv.dir = to, csv.name, duration = 600, 
           mins.between = 50, index = "hour", loc.prefix, CardRecorderID = NA,
           kbps = 128, samp.rate = 44100, channels = 2, split = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mp3Subsamp_+3A_files">files</code></td>
<td>
<p>Optional vector of mp3 file paths to extract surveys from.</p>
</td></tr>
<tr><td><code id="mp3Subsamp_+3A_from">from</code></td>
<td>
<p>Directory containing mp3 recordings to extract survey from; required only if <code>files</code> is missing.</p>
</td></tr>
<tr><td><code id="mp3Subsamp_+3A_to">to</code></td>
<td>
<p>Directory where surveys will be placed after extraction.</p>
</td></tr>
<tr><td><code id="mp3Subsamp_+3A_csv.dir">csv.dir</code></td>
<td>
<p>Directory where csv file of survey metadata will be saved; defaults to the <code>to</code> directory.</p>
</td></tr>
<tr><td><code id="mp3Subsamp_+3A_csv.name">csv.name</code></td>
<td>
<p>Name assigned to csv file of metadata (character value ending in .csv).</p>
</td></tr>
<tr><td><code id="mp3Subsamp_+3A_duration">duration</code></td>
<td>
<p>Duration of surveys to extract (numeric, units = 'seconds'). Defaults to 600 seconds (10 minutes).</p>
</td></tr>
<tr><td><code id="mp3Subsamp_+3A_mins.between">mins.between</code></td>
<td>
<p>Number of minutes to skip between surveys (numeric). If <code>index = "hour"</code>, the value for <code>mins.between + duration * 60</code> (duration converted to minutes) equals the repeat period.  Defaults to 50 minutes, for a 60 minute repeat period.</p>
</td></tr>
<tr><td><code id="mp3Subsamp_+3A_index">index</code></td>
<td>
<p>Character value indicating whether to take the first survey at the next hour in the recording (identified based on file date modified) or simply from the start of the recording.  In <code>c("hour", "time0")</code>.  Defaults to <code>"hour"</code>.</p>
</td></tr>
<tr><td><code id="mp3Subsamp_+3A_loc.prefix">loc.prefix</code></td>
<td>
<p>Six characters identifying the location at which the recording was made.  Will be used in the file name (see Details) and the csv file name.  Must be in <em>tblLocation.fldLocationName</em> in the acoustics database.</p>
</td></tr>
<tr><td><code id="mp3Subsamp_+3A_cardrecorderid">CardRecorderID</code></td>
<td>
<p>Numeric key value from <em>tblCardRecorder.pkCardRecorderID</em>, which links the recorder that made the recording with the location it was recorded.</p>
</td></tr>
<tr><td><code id="mp3Subsamp_+3A_kbps">kbps</code></td>
<td>
<p>Numeric value for mp3 bitrate.  Common values are <code>c(64, 128, 160, 192, 224, 256, 320)</code>.  Must match the bitrate set by the recording device.</p>
</td></tr>
<tr><td><code id="mp3Subsamp_+3A_samp.rate">samp.rate</code></td>
<td>
<p>Numeric value for mp3 sample rate.  Common values are <code>c(22050, 44100, 48000)</code>.  Must match the sample rate set by the recording device.</p>
</td></tr>
<tr><td><code id="mp3Subsamp_+3A_channels">channels</code></td>
<td>
<p>Numeric value for number of audio channels in mp3 file.  Both &quot;Stereo&quot; and &quot;Joint Stereo&quot; are 2-channel recordings.  &quot;Mono&quot; is a 1-channel recording.</p>
</td></tr>
<tr><td><code id="mp3Subsamp_+3A_split">split</code></td>
<td>
<p>Logical.  The default <code>TRUE</code> will send the call to mp3splt to subsample the surveys; <code>FALSE</code> will generate metadata only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls mp3splt, a third party library that must be installed separately from <a href="http://mp3splt.sourceforge.net">http://mp3splt.sourceforge.net</a>.  Supplemental installation instructions are provided in the document &quot;Installing_mp3splt.pdf&quot;, available the monitoR website <a href="http://www.uvm.edu/rsenr/vtcfwru/R/?Page=monitoR/monitoR.htm">http://www.uvm.edu/rsenr/vtcfwru/R/?Page=monitoR/monitoR.htm</a>.  This function supplants <code><a href="#topic+fileCopyRename">fileCopyRename</a></code> as a file copying function and a metadata collection tool when using the acoustic database.  
</p>
<p>The survey file names produced will be of the form PREFIX_YYYY-mm-dd_HHMSS.mp3.  Surveys from the same location can be linked by the location prefix and differentiated by different modification dates.
</p>


<h3>Value</h3>

<p>Data frame with metadata about the surveys.  Metadata includes: the date modified (fldOriginalDateModified), the original recording name (fldOriginalRecordingName), the new survey name (fldSurveyName), the recording format (fldRecordingFormat), the value for pkCardrecorderID (fkCardRecorderID), the duration of each survey (fldSurveyLength), the sample rate (fldSampleRate), the bit depth (fldBitsperSample), and the number of channels (fldChannels).
</p>


<h3>Note</h3>

<p><code><a href="#topic+dbUploadSurvey">dbUploadSurvey</a></code> assumes a database structure identical to that provided in the acoustics schema.
</p>


<h3>Author(s)</h3>

<p>Jon Katz
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+fileCopyRename">fileCopyRename</a></code> to move wave files and prepare metadata for the database; <code><a href="#topic+dbUploadSurvey">dbUploadSurvey</a></code> to upload the survey metadata to the acoustics database.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Specify individual files, 10 minutes every hour from the file start:
## Not run: metadata &lt;- mp3Subsamp(files = '~/media/SDcard/MA01.mp3', to = '~/Desktop/Acoustics/Recordings', 
csv.dir = '~/Desktop/Acoustics/Results', index = "time0", loc.prefix = 'MABI01', CardRecorderID = 1
## End(Not run)

# 10 minute surveys at the top of every hour, from an entire SD card:
## Not run: metadata &lt;- mp3Subsamp(from = '~/media/SDcard', to = '~/Desktop/Acoustics/Recordings', 
csv.dir = '~/Desktop/Acoustics/Results', loc.prefix = 'MABI01', CardRecorderID = 1
## End(Not run)

# 5 minute surveys every 30 minutes starting at the top of every hour, from an entire SD card:
## Not run: metadata &lt;- mp3Subsamp(from = '~/media/SDcard', to = '~/Desktop/Acoustics/Recordings', 
csv.dir = '~/Desktop/Acoustics/Results', duration = 300, mins.between = 25, loc.prefix = 'MABI01', 
CardRecorderID = 1
## End(Not run)





</code></pre>

<hr>
<h2 id='oven'>
Ovenbird (<em>Seiurus aurocapilla</em>) Song
</h2><span id='topic+oven'></span>

<h3>Description</h3>

<p>A 3 second wave recording of an Ovenbird (<em>Seiurus aurocapilla</em>) song.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(oven)</code></pre>


<h3>Format</h3>

<p>The format is: <br />
<code>Formal class 'Wave' [package "tuneR"] with 6 slots
  ..@ left     : int [1:120001] 84 170 281 142 129 55 120 181 126 178 ...
  ..@ right    : num(0)
  ..@ stereo   : logi FALSE
  ..@ samp.rate: int 24000
  ..@ bit      : int 16
  ..@ pcm      : logi TRUE
</code>
</p>


<h3>Source</h3>

<p>Sound clips were recorded in Vermont, USA in 2010.  Equipment was a Wildlife Acoustics SM1(TM) recorder recording in WAC0 format, converted to wave using the Wildlife Acoustics Wac2Wav (TM) converter.  Recording has a sample rate of 24kHz and is 16-bit mono.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(oven)
viewSpec(oven)
</code></pre>

<hr>
<h2 id='plot-methods'>Methods for the <code>plot</code> Function</h2><span id='topic+plot-methods'></span><span id='topic+plot+2CTemplateList+2CANY-method'></span><span id='topic+plot+2CdetectionList+2CANY-method'></span>

<h3>Description</h3>

<p>Plotting acoustic templates and template scores</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TemplateList,ANY'
plot(x, which.one = names(x@templates), click = FALSE, 
ask = if(length(which.one)&gt;1) TRUE else FALSE, spec.col = gray.3(), on.col = '#FFA50075', 
off.col = '#0000FF75', pt.col = '#FFA50075', line.col = 'black')

## S4 method for signature 'detectionList,ANY'
plot(x, flim = c(0, 12), scorelim, 
which.one = names(x@templates), box = TRUE, spec.col = gray.2(), t.each = 30, 
hit.marker = 'lines', 
color = c('red', 'blue', 'green', 'orange', 'purple', 'pink', 'darkgreen', 'turquoise', 
'royalblue', 'orchid4', 'brown', 'salmon2'), legend = TRUE, all.peaks = FALSE, 
ask = if(dev.list() == 2) TRUE else FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot-methods_+3A_x">x</code></td>
<td>
<p>A template list (<code><a href="#topic+TemplateList-class">TemplateList</a></code> object) or detection list (<code><a href="#topic+detectionList-class">detectionList</a></code> object).</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_which.one">which.one</code></td>
<td>
<p>Names of templates to be plotted.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_click">click</code></td>
<td>
<p>Set to <code>TRUE</code> to see values of locations on plot by mouse clicks.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_ask">ask</code></td>
<td>
<p>Set to <code>FALSE</code> to eliminate pause between plots.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_spec.col">spec.col</code></td>
<td>
<p>Color ramp for spectrogram.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_on.col">on.col</code></td>
<td>
<p>Color for &ldquo;on&rdquo; points (binary templates only).</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_off.col">off.col</code></td>
<td>
<p>Color for &ldquo;off&rdquo; points (binary templates only).</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_pt.col">pt.col</code></td>
<td>
<p>Color for template points (correlation templates only).</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_line.col">line.col</code></td>
<td>
<p>Color for lines if <code>click = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_flim">flim</code></td>
<td>
<p>Frequency limits for plot.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_scorelim">scorelim</code></td>
<td>
<p>Score limits for plot.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_box">box</code></td>
<td>
<p>If <code>TRUE</code> boxes are plotted in spectrogram for each detection.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_t.each">t.each</code></td>
<td>
<p>Duration shown in each individual plot (s).</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_hit.marker">hit.marker</code></td>
<td>
<p>Type of marker used to show detections in score plot. Can be <code>"lines"</code> or <code>"points"</code>.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_color">color</code></td>
<td>
<p>Colors used for individual templates.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_legend">legend</code></td>
<td>
<p>Show legend?</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_all.peaks">all.peaks</code></td>
<td>
<p>Indicate location of all peaks?</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sasha D. Hafner
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeCorTemplate">makeCorTemplate</a></code>, 
<code><a href="#topic+makeBinTemplate">makeBinTemplate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Not run because of the time required (maybe 5-10 seconds)
# Also some plot calls require user input by default
# Load data
data(btnw)
data(survey)

# Write Wave objects to file (temporary directory used here)
btnw.fp &lt;- file.path(tempdir(), "btnw.wav")
oven.fp &lt;- file.path(tempdir(), "oven.wav")
survey.fp &lt;- file.path(tempdir(), "survey2010-12-31_120000_EST.wav")
writeWave(btnw, btnw.fp)
writeWave(survey, survey.fp)

# Create a template list
ctemp1 &lt;- makeCorTemplate(btnw.fp, name = "w1")
ctemp2 &lt;- makeCorTemplate(btnw.fp, t.lim = c(0.5, 2.5), frq.lim = c(1, 10), dens = 0.1, name = "w2")
ctemps &lt;- combineCorTemplates(ctemp1, ctemp2)

# Then it can be plotted like this
plot(ctemps)

# Next call is not useful for template w1 but good for w2:
plot(ctemps, pt.col = "red")

# Can plot just one template
plot(ctemps, which.one = 2, pt.col = "red")
plot(ctemps, which.one = "w2", pt.col = "red")

# And to check values
plot(ctemps, which.one = 1, click = TRUE)

# To plot detections, let's create some
cscores &lt;- corMatch(survey.fp, ctemps)
cdetects &lt;- findPeaks(cscores)

# And to plot them:
plot(cdetects)

# Clean up (only because these files were created in these examples)
file.remove(btnw.fp)
file.remove(survey.fp)

## End(Not run)
</code></pre>

<hr>
<h2 id='readMP3'>
Read MP3 Files into a Wave Object
</h2><span id='topic+readMP3'></span>

<h3>Description</h3>

<p>A variation of the MP3 file reader supplied in <code><a href="tuneR.html#topic+tuneR">tuneR</a></code>.  Reads MP3 files in as 16bit PCM data stored in a Wave object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readMP3(filename, from, to)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readMP3_+3A_filename">filename</code></td>
<td>
<p>Filename of MP3 file.</p>
</td></tr>
<tr><td><code id="readMP3_+3A_from">from</code></td>
<td>
<p>Seconds to begin reading, measured from beginning of file.  See details.</p>
</td></tr>
<tr><td><code id="readMP3_+3A_to">to</code></td>
<td>
<p>Seconds to end reading, measured from beginning of file.  See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bare bones MP3 file reader supplied in <code><a href="tuneR.html#topic+tuneR">tuneR</a></code> reads the entire file in.  When the user installs the third party software mp3splt and libmp3splt, this variant will allow <code>from</code> and <code>to</code> to be specified, and mp3splt will attempt to read in the MP3 segment without first decoding the file.  Because mp3splt will cut the MP3 file at frame boundaries the <code>from</code> and <code>to</code> arguments are necessarily only guiding values; actual values may differ.  Supplemental mp3splt installation instructions are provided in the document &quot;Installing_mp3splt.pdf&quot;, available the monitoR website <a href="http://www.uvm.edu/rsenr/vtcfwru/R/?Page=monitoR/monitoR.htm">http://www.uvm.edu/rsenr/vtcfwru/R/?Page=monitoR/monitoR.htm</a>.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="tuneR.html#topic+Wave">Wave</a></code>.
</p>


<h3>Note</h3>

<p>If mp3splt is not installed a prompt will suggest falling back on the version from tuneR.
</p>


<h3>Author(s)</h3>

<p>Jon Katz
</p>


<h3>References</h3>

<p>mp3splt is documented at http://mp3splt.sourceforge.net/mp3splt_page/home.php.
</p>


<h3>See Also</h3>

<p><code><a href="tuneR.html#topic+readMP3">readMP3</a></code>, <code><a href="tuneR.html#topic+readWave">readWave</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Assume myMP3 is an MP3 file with a duration of at least 60 seconds:
readMP3 (filename = "myMP3.mp3", from = "30", to = "60")
## End(Not run) 
</code></pre>

<hr>
<h2 id='readTemplates'>
Read Acoustic Templates from a Local Disk
</h2><span id='topic+readBinTemplates'></span><span id='topic+readCorTemplates'></span>

<h3>Description</h3>

<p>Read single templates stored on a local disk, or read in entire directories of templates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readBinTemplates(files = NULL, dir = ".", ext = "bt", parallel = FALSE)
readCorTemplates(files = NULL, dir = ".", ext = "ct", parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readTemplates_+3A_files">files</code></td>
<td>
<p>Optional named vector of file names. See details.</p>
</td></tr>
<tr><td><code id="readTemplates_+3A_dir">dir</code></td>
<td>
<p>Name of directory to read files from. Default is working directory.</p>
</td></tr>
<tr><td><code id="readTemplates_+3A_ext">ext</code></td>
<td>
<p>Extension of files that should be read in. Files in <code>dir</code> without this extension will be skipped. Not necessary if <code>files</code> is provided.</p>
</td></tr>
<tr><td><code id="readTemplates_+3A_parallel">parallel</code></td>
<td>
<p>Logical.  <code>TRUE</code> uses mclapply, otherwise lapply is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions can be used in three different ways, in both cases combing all templates read in into a single template list.
By specifying a character vector of file names for <code>files</code>, they will read in the named files, and assign names based on file names.
If <code>files</code> is a named vector, the vector names will be used in the resulting template list.
Finally, if <code>files</code> is not provided, the functions will read in all saved templates with the extension <code>ext</code>.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+TemplateList-class">TemplateList</a></code> containing either binary point templates or spectrogram cross-correlation templates.  
</p>


<h3>Author(s)</h3>

<p>Sasha D. Hafner
</p>


<h3>See Also</h3>

<p><code><a href="#topic+writeBinTemplates">writeBinTemplates</a></code>, 
<code><a href="#topic+writeCorTemplates">writeCorTemplates</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data(btnw)
data(oven)

# Write Wave objects to file (temporary directory used here)
btnw.fp &lt;- file.path(tempdir(), "btnw.wav")
oven.fp &lt;- file.path(tempdir(), "oven.wav")
writeWave(btnw, btnw.fp)
writeWave(oven, oven.fp)

# Correlation example
# Create one correlation templates
wct1 &lt;- makeCorTemplate(btnw.fp, name = "w1")
wct2 &lt;- makeCorTemplate(btnw.fp, t.lim = c(1.5, 2.1), frq.lim = c(4.2, 5.6), name = "w2")
oct1 &lt;- makeCorTemplate(oven.fp, t.lim = c(1, 4), frq.lim = c(1, 11), name = "o1")
oct2 &lt;- makeCorTemplate(oven.fp, t.lim = c(1, 4), frq.lim = c(1, 11), dens = 0.1, name = "o2")

# Combine all of them
ctemps &lt;- combineCorTemplates(wct1, wct2, oct1, oct2)

## Not run: 
# Write ctemps to a directory "templates"
writeCorTemplates(ctemps, dir = "templates")

# Read in all correlation templates in a directory "templates"
ctemps &lt;- readCorTemplates(dir = "templates")

# Read in two specific files
ctemps &lt;- readCorTemplates(files = c("o1.ct", "o2.ct"), dir = "templates")

# Read in two specific files, and give them names
ctemps &lt;- readCorTemplates(files = c(oven1 = "o1.ct", oven2 = "o2.ct"), dir = "templates")

## End(Not run)

# Clean up (only because these files were created in these examples)
file.remove(btnw.fp)
file.remove(oven.fp)
</code></pre>

<hr>
<h2 id='show-methods'>Methods for the <code>show</code> and <code>summary</code> Functions</h2><span id='topic+show-methods'></span><span id='topic+show+2CbinTemplateList-method'></span><span id='topic+show+2CcorTemplateList-method'></span><span id='topic+show+2CdetectionList-method'></span><span id='topic+show+2CtemplateScores-method'></span><span id='topic+summary-methods'></span><span id='topic+summary+2CbinTemplateList-method'></span><span id='topic+summary+2CcorTemplateList-method'></span><span id='topic+summary+2CTemplateList-method'></span><span id='topic+summary+2CdetectionList-method'></span><span id='topic+summary+2CtemplateScores-method'></span>

<h3>Description</h3>

<p>These methods are used for viewing template lists and other objects.
For all types of objects documented here, <code>show</code> and <code>summary</code> will produce identical results.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "binTemplateList")</code></dt><dd>
<p>Displays a summary of <code><a href="#topic+binTemplateList-class">binTemplateList</a></code> objects.
</p>
</dd>
<dt><code>signature(object = "corTemplateList")</code></dt><dd>
<p>Displays a summary of <code><a href="#topic+corTemplateList-class">corTemplateList</a></code> objects.
</p>
</dd>
<dt><code>signature(object = "TemplateList")</code></dt><dd>
<p>Displays a summary of <code><a href="#topic+TemplateList-class">TemplateList</a></code> objects.
</p>
</dd>
<dt><code>signature(object = "detectionList")</code></dt><dd>
<p>Displays a summary of <code><a href="#topic+detectionList-class">detectionList</a></code> objects.
</p>
</dd>
<dt><code>signature(object = "templateScores")</code></dt><dd>
<p>Displays a summary of <code><a href="#topic+templateScores-class">templateScores</a></code> objects.
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Sasha D. Hafner
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeCorTemplate">makeCorTemplate</a></code>, 
<code><a href="#topic+makeBinTemplate">makeBinTemplate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data(btnw)
data(oven)

# Write Wave objects to file (temporary directory used here)
btnw.fp &lt;- file.path(tempdir(), "btnw.wav")
oven.fp &lt;- file.path(tempdir(), "oven.wav")
writeWave(btnw, btnw.fp)
writeWave(oven, oven.fp)

# Correlation example
# Create two correlation templates
wct &lt;- makeCorTemplate(btnw.fp, t.lim = c(1.5, 2.1), frq.lim = c(4.2, 5.6), name = "w")
oct &lt;- makeCorTemplate(oven.fp, t.lim = c(1, 4), frq.lim = c(1, 11), dens = 0.1, name = "o")

# Combine them
ctemps &lt;- combineCorTemplates(wct, oct)

# Then for a quick summary:
ctemps

# Clean up (only because these files were created in these examples)
file.remove(btnw.fp)
file.remove(oven.fp)
</code></pre>

<hr>
<h2 id='showPeaks'>
View or Verify Detections or Peaks
</h2><span id='topic+showPeaks'></span>

<h3>Description</h3>

<p>Use this function to view a spectrogram and score plot of detections or peaks.
In its simplest usage, <code>showPeaks</code> will show all detections within for the first template within the detection list object, one after the other.
With the verify option (<code>verify = TRUE</code>), the user can tag detections or peaks as <code>TRUE</code> or <code>FALSE</code>, and these results will be saved in an updated detection list object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showPeaks(detection.obj, which.one = names(detection.obj@templates)[1], fd.rat = 4, 
frame = fd.rat * detection.obj@templates[[which.one]]@duration, id = 1:nrow(pks), 
t.lim, flim = c(0, 20), point = TRUE, ask = if (verify) FALSE else TRUE, 
scorelim = NULL, verify = FALSE, what = "detections", box = TRUE, 
player = "play", spec.col = gray.3(), on.col = '#FFA50075', off.col = '#0000FF75', 
pt.col = '#FFA50075')
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="showPeaks_+3A_detection.obj">detection.obj</code></td>
<td>

<p>A detection list object (<code><a href="#topic+detectionList-class">detectionList</a></code>).
</p>
</td></tr>
<tr><td><code id="showPeaks_+3A_which.one">which.one</code></td>
<td>

<p>Which template should be shown? Identify by name or position. Length-one integer or character vector.
</p>
</td></tr>
<tr><td><code id="showPeaks_+3A_fd.rat">fd.rat</code></td>
<td>

<p>Ratio of plot frame (time duration of plots) to template duration.
</p>
</td></tr>
<tr><td><code id="showPeaks_+3A_frame">frame</code></td>
<td>

<p>Or, specify the plot frame (x limits of plots) instead of <code>fr.rate</code>. Length-one numeric vector.
</p>
</td></tr>
<tr><td><code id="showPeaks_+3A_id">id</code></td>
<td>

<p>Use to specify which peaks or detections will be shown. Integer vector.
</p>
</td></tr>
<tr><td><code id="showPeaks_+3A_t.lim">t.lim</code></td>
<td>

<p>Or, to view only those detections or peaks within a certain time range, specify it here. Length-two numeric vector.
</p>
</td></tr>
<tr><td><code id="showPeaks_+3A_flim">flim</code></td>
<td>

<p>Frequency limits (y axis limits) for the spectrogram. Length-two numeric vector.
</p>
</td></tr>
<tr><td><code id="showPeaks_+3A_point">point</code></td>
<td>

<p>If <code>TRUE</code>, plot points to show detection or peak locations.
</p>
</td></tr>
<tr><td><code id="showPeaks_+3A_ask">ask</code></td>
<td>

<p>The setting of the <code><a href="graphics.html#topic+par">par</a></code> setting <code>ask</code>. Default value is based on other arguments, and should suffice in most cases.
</p>
</td></tr>
<tr><td><code id="showPeaks_+3A_scorelim">scorelim</code></td>
<td>

<p>Score limits (y axis limits) for the score plot.
</p>
</td></tr>
<tr><td><code id="showPeaks_+3A_verify">verify</code></td>
<td>

<p>If <code>TRUE</code>, R will prompt user to identify whether detections are <code>TRUE</code>
</p>
</td></tr>
<tr><td><code id="showPeaks_+3A_what">what</code></td>
<td>

<p>Should all peaks (<code>what = "peaks"</code>) or just detections (<code>what = "detections"</code>) be shown?
</p>
</td></tr>
<tr><td><code id="showPeaks_+3A_box">box</code></td>
<td>

<p>If <code>TRUE</code> plot a box around detections in the spectrogram. Box boundaries are based on template duration and frequency limits. Can also be set to &quot;template&quot; to see the template points plotted over the detection.
</p>
</td></tr>
<tr><td><code id="showPeaks_+3A_player">player</code></td>
<td>

<p>If <code>verify = TRUE</code>, the user will have the option to play the detection or peak. This argument is the command used for starting the player. See Details.
</p>
</td></tr>
<tr><td><code id="showPeaks_+3A_spec.col">spec.col</code></td>
<td>

<p>A vector of colors for the spectrogram.
</p>
</td></tr>
<tr><td><code id="showPeaks_+3A_on.col">on.col</code></td>
<td>

<p>Colors for the on points of a binary point template, if <code>box = "template"</code>. Default is #RRGGBBAA, where AA is the transparency.
</p>
</td></tr>
<tr><td><code id="showPeaks_+3A_off.col">off.col</code></td>
<td>

<p>Colors for the off points of a binary point template, if <code>box = "template"</code>. Default is #RRGGBBAA, where AA is the transparency.
</p>
</td></tr>
<tr><td><code id="showPeaks_+3A_pt.col">pt.col</code></td>
<td>

<p>Colors for the points of a correlation template, if <code>box = "template"</code>. Default is #RRGGBBAA, where AA is the transparency.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that almost all of the arguments have a default value.<br />
The default audio player, &quot;play&quot;, is the shell command for SoX, the multi-OS media player. Windows will detect the file type and use the default media player with &quot;start&quot;, or you can specify one (such as Windows Media Player) with &quot;start wmplayer.exe&quot;. On Ubuntu try Rhythmbox (&quot;rhythmbox&quot;), and on Mac OS try afplay (&quot;afplay&quot;).        
</p>


<h3>Value</h3>

<p><code>NULL</code>, invisibly, or, if <code>verify = TRUE</code>, an updated detection list object (<code><a href="#topic+detectionList-class">detectionList</a></code>).
</p>


<h3>Author(s)</h3>

<p>Sasha D. Hafner
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findPeaks">findPeaks</a></code>, 
<code><a href="#topic+plot-methods">plot-methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data(btnw)
data(oven)
data(survey)

# Write Wave objects to file (temporary directory used here)
btnw.fp &lt;- file.path(tempdir(), "btnw.wav")
oven.fp &lt;- file.path(tempdir(), "oven.wav")
survey.fp &lt;- file.path(tempdir(), "survey2010-12-31_120000_EST.wav")
writeWave(btnw, btnw.fp)
writeWave(oven, oven.fp)
writeWave(survey, survey.fp)

# Correlation example
# Create two correlation templates
wct &lt;- makeCorTemplate(btnw.fp, t.lim = c(1.5, 2.1), frq.lim = c(4.2, 5.6), name = "w")
oct &lt;- makeCorTemplate(oven.fp, t.lim = c(1, 4), frq.lim = c(1, 11), dens = 0.1, name = "o")

# Combine them
ctemps &lt;- combineCorTemplates(wct, oct)

# Calculate scores
cscores &lt;- corMatch(survey.fp, ctemps)

# Find peaks and detections
cdetects &lt;- findPeaks(cscores)
cdetects

# Interactively inspect individual detections, no return value
## Not run: 
# Not run because user input is required
showPeaks(detection.obj = cdetects, which.one = "w", flim = c(2, 8), point = TRUE, 
          scorelim = c(0, 1))

# Interactively verify individual detections, return adds verification field
cdetects &lt;- showPeaks(detection.obj = cdetects, which.one = "w", flim = c(0, 20), 
                      point = TRUE, scorelim = c(0, 1), verify = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='specCols'>
Color Vectors for Spectrograms
</h2><span id='topic+gray.1'></span><span id='topic+gray.2'></span><span id='topic+gray.3'></span><span id='topic+rainbow.1'></span><span id='topic+topo.1'></span><span id='topic+specCols'></span>

<h3>Description</h3>

<p>Functions to generate a selection of color vectors for spectrograms based on existing color vectors for images in <span class="pkg">grDevices</span>.  Vectors are reversed relative to their parent (i.e. numerical sequences progress from 1 to 0 rather than 0 to 1). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gray.1(n = 30)
gray.2(n = 30)
gray.3(n = 30)
rainbow.1(n = 15)
topo.1(n = 12)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="specCols_+3A_n">n</code></td>
<td>
<p>A vector of desired color levels between 1 and 0; one indicates high amplitude (&quot;black&quot;, &quot;red&quot;, or &quot;blue&quot;) and zero indicates low amplitude (&quot;white&quot;, &quot;purple&quot;, or &quot;tan&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>n</code> argument will divide the vector into <code>n</code> color levels.
</p>


<h3>Value</h3>

<p>A vector of colors.
</p>


<h3>Author(s)</h3>

<p>Jon Katz, Sasha D. Hafner
</p>


<h3>References</h3>

<p>Based on the color palettes from <span class="pkg">grDevices</span>, and loosely on those used in <span class="pkg">seewave</span>
</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+gray">gray</a></code>, <code><a href="grDevices.html#topic+rainbow">rainbow</a></code>, <code><a href="grDevices.html#topic+topo.colors">topo.colors</a></code>, <code><a href="grDevices.html#topic+terrain.colors">terrain.colors</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spec.test &lt;- function(mat, spec.col) image(z = t(mat), col = spec.col)

mat &lt;- matrix(1:30, ncol = 6, byrow = TRUE)

spec.test(mat = mat, spec.col = gray.1())
spec.test(mat = mat, spec.col = gray.2())
spec.test(mat = mat, spec.col = gray.3())
spec.test(mat = mat, spec.col = rainbow.1())
spec.test(mat = mat, spec.col = topo.1())

## Not run: 
# Colors are defined as:
gray.1 &lt;- function(n = 30) gray(seq(1, 0, length.out = n))
gray.2 &lt;- function(n = 30) gray(1-seq(0, 1, length.out = n)^2)
gray.3 &lt;- function(n = 30) gray(1-seq(0, 1, length.out = n)^3)
rainbow.1 &lt;- function(n = 15) rev(rainbow(n))
topo.1 &lt;- function(n = 12) rev(topo.colors(n))
## End(Not run)
</code></pre>

<hr>
<h2 id='survey'>
Sample Acoustic Survey (Short)
</h2><span id='topic+survey'></span>

<h3>Description</h3>

<p>A composite wave file 23.5 seconds long containing 3 black-throated green warbler (<em>Setophaga virens</em>) songs (at 1.8, 10.5, and 21.6 seconds) and 4 ovenbird (<em>Seiurus aurocapilla</em>) songs (at 5.8, 9.1, 14.8, and 22.0 seconds).  The ovenbird song at 14.8 seconds is considerably lower amplitude than the others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(survey)</code></pre>


<h3>Format</h3>

<p>The format is: <br />
<code>Formal class 'Wave' [package "tuneR"] with 6 slots
  ..@ left     : int [1:564000] 135 192 230 163 158 230 289 277 249 280 ...
  ..@ right    : num(0)
  ..@ stereo   : logi FALSE
  ..@ samp.rate: int 24000
  ..@ bit      : int 16 
  ..@ pcm      : logi TRUE 
</code>
</p>


<h3>Source</h3>

<p>Sound clips were recorded in Vermont, USA in 2010.  Equipment was a Wildlife Acoustics SM1(TM) recorder recording in WAC0 format, converted to wave using the Wildlife Acoustics Wac2Wav (TM) converter.  Recording has a sample rate of 24kHz and is 16-bit mono.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(survey)
viewSpec(survey)
</code></pre>

<hr>
<h2 id='survey_anno'>
Annotations for <code><a href="#topic+survey">survey</a></code>
</h2><span id='topic+survey_anno'></span>

<h3>Description</h3>

<p>Data frame containing annotations for the data file <code><a href="#topic+survey">survey</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(survey_anno)</code></pre>


<h3>Format</h3>

<p>The format is:
'data.frame':	7 obs. of  5 variables:
$ start.time: num  1.06 4.21 7.55 9.85 13.84 ...
$ end.time  : num  2.59 7.41 10.7 11.06 15.85 ...
$ min.frq   : num  3.61 2.58 2.63 3.88 2.82 ...
$ max.frq   : num  6.35 9.54 9.33 6.25 6.39 ...
$ name      : Factor w/ 2 levels &quot;BTNW&quot;, &quot;OVEN&quot;: 1 2 2 1 2 2 1
</p>


<h3>Details</h3>

<p>These annotations can be plotted onto the spectrogram by loading them in with the <code>anno</code> argument of <code><a href="#topic+viewSpec">viewSpec</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# View annotations
data(survey)
data(survey_anno)
write.csv(survey_anno, "survey_anno.csv", row.names = FALSE)
viewSpec(survey, annotate = TRUE, anno = "survey_anno.csv")

## End(Not run)
</code></pre>

<hr>
<h2 id='Template-class'>Class <code>"Template"</code></h2><span id='topic+Template-class'></span><span id='topic+corTemplate-class'></span><span id='topic+binTemplate-class'></span>

<h3>Description</h3>

<p>A template is an object with acoustic information (frequency, time, and amplitude) on an animal volcalization.
Objects of class <code>"corTemplate"</code> are correlation templates, which contain quantitative data on amplitude.
Objects of class <code>"binTemplate"</code> are binary templates, which contain only qualitative data on amplitude: only whether the it is high (&ldquo;on&rdquo; cells) or low (&ldquo;off&rdquo;) cells.
The class <code>"Template"</code> is a virtual class, and both types of templates have this class.
Templates are always stored as part of a <code><a href="#topic+TemplateList-class">TemplateList</a></code>, either a <code><a href="#topic+corTemplateList-class">corTemplateList</a></code> or a <code><a href="#topic+binTemplateList-class">binTemplateList</a></code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("corTemplate", ...)</code> or <code>new("binTemplate", ...)</code>.
However, users should not work directly with objects of this class, but only with <code>corTemplateList</code> or <code>binTemplateList</code>, which can be created as described in the documentation for <code>TemplateList</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>clip.path</code>:</dt><dd><p>Object of class <code>character</code>.  The file path of the original recording used to create the template.</p>
</dd>
<dt><code>samp.rate</code>:</dt><dd><p>Object of class <code>integer</code>.  The sample rate of the recording.</p>
</dd>
<dt><code>pt.on</code>:</dt><dd><p>Object of class <code>matrix</code> (<code>binTemplate</code> class only). A two-dimensional matrix with time (column 1) and frequency (column 2) bins for &ldquo;on&rdquo; points. Bin locations are relative to the first bin (&ldquo;on&rdquo; or &ldquo;off&rdquo;), which has a value of 1.</p>
</dd>
<dt><code>pt.off</code>:</dt><dd><p>Object of class <code>matrix</code> (<code>binTemplate</code> class only). A two-dimensional matrix with time (column 1) and frequency (column 2) bins for &ldquo;off&rdquo; points. Bin locations are relative to the first bin (&ldquo;on&rdquo; or &ldquo;off&rdquo;), which has a value of 1.</p>
</dd>
<dt><code>pts</code>:</dt><dd><p>Object of class <code>"matrix"</code> (<code>corTemplate</code> class only). A two-dimensional matrix with time (column 1) and frequency (column 2) bins, and amplitude (column 3).</p>
</dd>
<dt><code>t.step</code>:</dt><dd><p>Object of class <code>numeric</code>.  Time step between time bins (sec).</p>
</dd>
<dt><code>frq.step</code>:</dt><dd><p>Object of class <code>numeric</code>.  Frequency step between frequency bins (kHz).</p>
</dd>
<dt><code>n.t.bins</code>:</dt><dd><p>Object of class <code>integer</code>.  Total number of time bins in the template.</p>
</dd>
<dt><code>first.t.bin</code>:</dt><dd><p>Object of class <code>numeric</code>.  Time of the first time bin in the original recording (sec).</p>
</dd>
<dt><code>n.frq.bins</code>:</dt><dd><p>Object of class <code>integer</code>.  Total number of frequency bins.</p>
</dd>
<dt><code>duration</code>:</dt><dd><p>Object of class <code>numeric</code>.  Template duration (sec).</p>
</dd>
<dt><code>frq.lim</code>:</dt><dd><p>Object of class <code>numeric</code>.  Frequency limits (kHz).</p>
</dd>
<dt><code>wl</code>:</dt><dd><p>Object of class <code>integer</code>.  Value of argument <code>wl</code> used in the <code><a href="#topic+spectro">spectro</a></code> function call when the template was created.</p>
</dd>
<dt><code>ovlp</code>:</dt><dd><p>Object of class <code>integer</code>.   Value of argument <code>ovlp</code> used in the <code><a href="#topic+spectro">spectro</a></code> function call when the template was created.</p>
</dd>
<dt><code>wn</code>:</dt><dd><p>Object of class <code>character</code>.  Value of argument <code>wn</code> used in the <code><a href="#topic+spectro">spectro</a></code> function call when the template was created.</p>
</dd>
<dt><code>score.cutoff</code>:</dt><dd><p>Object of class <code>numeric</code>.  The cutoff that will be used to identify detections when this template is used.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Classes <code>corTemplate</code> and <code>binTemplate</code> extend <code>Template</code>, directly.
</p>


<h3>Methods</h3>

<p>No methods defined with these classes in the signature.
But see <code><a href="#topic+TemplateList-class">TemplateList</a></code>.
</p>


<h3>Author(s)</h3>

<p>Sasha D. Hafner
</p>


<h3>See Also</h3>

<p><code><a href="#topic+binTemplateList-class">binTemplateList</a></code>, 
<code><a href="#topic+corTemplateList-class">corTemplateList</a></code>, 
<code><a href="#topic+TemplateList-class">TemplateList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("Template")

showClass("corTemplate")

showClass("binTemplate")
</code></pre>

<hr>
<h2 id='templateComment'>
Query or Set Template Cutoffs
</h2><span id='topic+templateComment'></span><span id='topic+templateComment+3C-'></span>

<h3>Description</h3>

<p>Use this function to add or check comments to templates within template lists (<code><a href="#topic+corTemplateList-class">corTemplateList</a></code> or <code><a href="#topic+binTemplateList-class">binTemplateList</a></code> objects), scores (<code><a href="#topic+templateScores-class">templateScores</a></code> objects), or detection list (<code><a href="#topic+detectionList-class">detectionList</a></code> objects).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>templateComment(object)
templateComment(object) &lt;- value

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="templateComment_+3A_object">object</code></td>
<td>
<p>A binary or correlation template list (class <code>binTemplateList</code> or <code>corTemplateList</code>).</p>
</td></tr>
<tr><td><code id="templateComment_+3A_value">value</code></td>
<td>
<p>A character vector with the new comment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>templateComment</code> is an accessor function and <code>templateComment &lt;- </code> is a replacement function.<br />
For replacement, the <code>value</code> object should be as long as the number of templates in <code>object</code> (or the number selecting via indexing) unless it is a named vector (see Examples).
</p>


<h3>Value</h3>

<p>For extraction, a numeric vector of the same length as <code>object</code> with comments.  
For replacement, the updated object.
</p>


<h3>Author(s)</h3>

<p>Sasha D. Hafner
</p>


<h3>See Also</h3>

<p><code><a href="#topic+templateNames">templateNames</a></code>, 
<code><a href="#topic+templateCutoff">templateCutoff</a></code>, 
<code><a href="#topic+getTemplates">getTemplates</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data(btnw)
data(oven)

# Write Wave objects to file (temporary directory used here)
btnw.fp &lt;- file.path(tempdir(), "btnw.wav")
oven.fp &lt;- file.path(tempdir(), "oven.wav")
writeWave(btnw, btnw.fp)
writeWave(oven, oven.fp)

# Create four correlation templates
wct1 &lt;- makeCorTemplate(btnw.fp, name = "w1")
wct2 &lt;- makeCorTemplate(btnw.fp, t.lim = c(1.5, 2.1), frq.lim = c(4.2, 5.6), name = "w2")
oct1 &lt;- makeCorTemplate(oven.fp, t.lim = c(1, 4), frq.lim = c(1, 11), name = "o1")
oct2 &lt;- makeCorTemplate(oven.fp, t.lim = c(1, 4), frq.lim = c(1, 11), dens = 0.1, name = "o2")

# Combine all of them
ctemps &lt;- combineCorTemplates(wct1, wct2, oct1, oct2)
ctemps

# Add a comment for two templates
templateComment(ctemps) &lt;- c(w1 = "This is the best template so far.", 
                           o1 = "Should we drop the lowest syllable?")

# Add a default comment also
templateComment(ctemps) &lt;- c(w1 = "This is the best template so far.", 
                           o1 = "Should we drop the lowest syllable?", 
                           default = "These templates have not been tested.")
# View comments
templateComment(ctemps)

# Clean up (only because these files were created in these examples)
file.remove(btnw.fp)
file.remove(oven.fp)
</code></pre>

<hr>
<h2 id='templateCutoff'>
Query or Set Template Cutoffs
</h2><span id='topic+templateCutoff'></span><span id='topic+templateCutoff+3C-'></span>

<h3>Description</h3>

<p>Use this function to check or change the values of score cutoff in template lists (<code><a href="#topic+corTemplateList-class">corTemplateList</a></code> or <code><a href="#topic+binTemplateList-class">binTemplateList</a></code> objects), scores (<code><a href="#topic+templateScores-class">templateScores</a></code> objects), or detections list (<code><a href="#topic+detectionList-class">detectionList</a></code> objects).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>templateCutoff(object)
templateCutoff(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="templateCutoff_+3A_object">object</code></td>
<td>

<p>A binary or correlation template list (class <code>binTemplateList</code> or <code>corTemplateList</code>).
</p>
</td></tr>
<tr><td><code id="templateCutoff_+3A_value">value</code></td>
<td>

<p>A numeric vector with the new score cutoff.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>templateCutoff</code> is an accessor function and <code>templateCutoff &lt;- </code> is a replacement function.<br />
For replacement, the <code>value</code> object should be as long as the number of templates in <code>object</code> (or the number selecting via indexing) unless it is a named vector (see Examples).
</p>


<h3>Value</h3>

<p>For extraction, a numeric vector of the same length as <code>object</code> with score cutoffs.  
For replacement, the updated object.
</p>


<h3>Author(s)</h3>

<p>Sasha D. Hafner
</p>


<h3>See Also</h3>

<p><code><a href="#topic+templateNames">templateNames</a></code>, <code><a href="#topic+templateComment">templateComment</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data(btnw)
data(oven)

# Write Wave objects to file (temporary directory used here)
btnw.fp &lt;- file.path(tempdir(), "btnw.wav")
oven.fp &lt;- file.path(tempdir(), "oven.wav")
writeWave(btnw, btnw.fp)
writeWave(oven, oven.fp)

# Create four correlation templates
wct1 &lt;- makeCorTemplate(btnw.fp, name = "w1")
wct2 &lt;- makeCorTemplate(btnw.fp, t.lim = c(1.5, 2.1), frq.lim = c(4.2, 5.6), name = "w2")
oct1 &lt;- makeCorTemplate(oven.fp, t.lim = c(1, 4), frq.lim = c(1, 11), name = "o1")
oct2 &lt;- makeCorTemplate(oven.fp, t.lim = c(1, 4), frq.lim = c(1, 11), dens = 0.1, name = "o2")

# Combine all of them
ctemps &lt;- combineCorTemplates(wct1, wct2, oct1, oct2)
ctemps

# Check cutoffs
templateCutoff(ctemps)

# Change all like this 
templateCutoff(ctemps) &lt;- c(0.35, 0.35, 0.35, 0.35)
# or this
templateCutoff(ctemps) &lt;- c(default = 0.35)

# Change select ones like this
templateCutoff(ctemps) &lt;- c(o1 = 0.45, o2 = 0.45)
# or this
templateCutoff(ctemps)[c(3, 4)] &lt;- 0.45

# Could combine these two steps
templateCutoff(ctemps) &lt;- c(default = 0.35, o1 = 0.45, o2 = 0.45)

# Clean up (only because these files were created in these examples)
file.remove(btnw.fp)
file.remove(oven.fp)
</code></pre>

<hr>
<h2 id='TemplateList-class'>Class <code>"TemplateList"</code></h2><span id='topic+corTemplateList-class'></span><span id='topic+binTemplateList-class'></span><span id='topic+TemplateList-class'></span>

<h3>Description</h3>

<p>A template is an object with acoustic information (frequency, time, and volume) on an animal volcalization.
In monitoR, all templates are stored within a template list, which has the (virtual) class <code>TemplateList</code>.
Because the structure of the two types of templates differs slightly (see <code><a href="#topic+Template-class">Template</a></code>), there are actually two classes for template lists: <code>corTemplateList</code> and <code>binTemplateList</code>, and the virtual class <code>TemplateList</code> (which includes both types of template lists) is used to define most methods.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("corTemplateList", ...)</code> or <code>new("binTemplateList", ...)</code>.
However, objects should always be created with the template-creation functions <code><a href="#topic+makeCorTemplate">makeCorTemplate</a></code> or <code><a href="#topic+makeBinTemplate">makeBinTemplate</a></code>, or else by reading from a file using <code><a href="#topic+readCorTemplates">readCorTemplates</a></code> or <code><a href="#topic+readBinTemplates">readBinTemplates</a></code>.
There are also functions for modifying existing template lists or extracting template lists from other objects.
</p>


<h3>Slots</h3>


<dl>
<dt><code>templates</code>:</dt><dd><p>Object of class <code>"list"</code> A list of either <code><a href="#topic+corTemplate-class">corTemplate</a></code> or <code><a href="#topic+binTemplate-class">binTemplate</a></code> objects.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Classes <code>corTemplateList</code> and <code>binTemplateList</code> extend the virtual class <code>TemplateList</code>, directly.
</p>


<h3>Methods</h3>


<ul>
<li><p>show <code>signature(object = "corTemplateList")</code>: ... 
</p>
</li>
<li><p>summary <code>signature(object = "corTemplateList")</code>: ... 
</p>
</li>
<li><p>show <code>signature(object = "binTemplateList")</code>: ... 
</p>
</li>
<li><p>summary <code>signature(object = "binTemplateList")</code>: ... 
</p>
</li>
<li><p>plot <code>signature(x = "TemplateList", y = "ANY")</code>: ... 
</p>
</li></ul>



<h3>Note</h3>

<p>For details on the structure of the actual templates, see <code><a href="#topic+Template-class">Template</a></code>.
</p>


<h3>Author(s)</h3>

<p>Sasha D. Hafner
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Template-class">Template</a></code>, 
<code><a href="#topic+combineBinTemplates">combineBinTemplates</a></code>, 
<code><a href="#topic+templateCutoff">templateCutoff</a></code>, 
<code><a href="#topic+templateComment">templateComment</a></code>, 
<code><a href="#topic+getTemplates">getTemplates</a></code>, 
<code><a href="#topic+plot-methods">plot-methods</a></code>, 
<code><a href="#topic++5B-methods">[-methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("TemplateList")

showClass("corTemplateList")

showClass("binTemplateList")

</code></pre>

<hr>
<h2 id='templateMatching'>
Calculate Spectrogram Template Matching Scores
</h2><span id='topic+corMatch'></span><span id='topic+binMatch'></span>

<h3>Description</h3>

<p>These functions are used to calculate spectrogram template matching scores between a set of templates and an acoustic survey using spectrogram cross correlation (<code>corMatch</code>) or binary point matching (<code>binMatch</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corMatch(survey, templates, parallel = FALSE, show.prog = FALSE, cor.method = "pearson", 
         time.source = "filename", rec.tz = NA, write.wav = FALSE, quiet = FALSE, ...)

binMatch(survey, templates, parallel = FALSE, show.prog = FALSE, time.source = "filename",
         rec.tz = NA, write.wav = FALSE, report.amp = FALSE, quiet = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="templateMatching_+3A_survey">survey</code></td>
<td>

<p>A file path to a wav or mp3 recording, or a <code><a href="tuneR.html#topic+Wave">Wave</a></code> object.
The <code>survey</code> is the acoustic survey that you want to make detections within.  
</p>
</td></tr>
<tr><td><code id="templateMatching_+3A_templates">templates</code></td>
<td>

<p>A template list&ndash;a <code>corTemplateList</code> object for <code>corMatch</code> or a <code>binTemplateList</code> object for <code>binMatch</code>.
</p>
</td></tr>
<tr><td><code id="templateMatching_+3A_parallel">parallel</code></td>
<td>

<p>If <code>TRUE</code>, <code><a href="parallel.html#topic+mclapply">mclapply</a></code> is used for calculation of scores across all time bins for each template.
This option is not available for Windows operating systems.
</p>
</td></tr>
<tr><td><code id="templateMatching_+3A_show.prog">show.prog</code></td>
<td>

<p>If <code>TRUE</code>, progress will be reported during the score calculations.
</p>
</td></tr>
<tr><td><code id="templateMatching_+3A_cor.method">cor.method</code></td>
<td>

<p>For <code>corMatch</code>, the method used to calculate correlation coefficients (see <code>?cor</code>).
</p>
</td></tr>
<tr><td><code id="templateMatching_+3A_time.source">time.source</code></td>
<td>

<p>The source of date and time information.
<code>filename</code> will look in the name of the survey file (<code>survey</code> argument) for a date and time with format YYYY-MM-DD_HHMMSS_TimeZone.
<code>"fileinfo"</code> will take the date and time from the file modification information.  See details.
</p>
</td></tr>
<tr><td><code id="templateMatching_+3A_rec.tz">rec.tz</code></td>
<td>
<p>Time zone for which the recordings were made (optional). Needed if different from the time zone setting of the operating system, when times will be adjusted to the &lsquo;correct&rsquo; time zone. See details.</p>
</td></tr>
<tr><td><code id="templateMatching_+3A_write.wav">write.wav</code></td>
<td>

<p>If <code>survey</code> is a <code>Wave</code> object, should it be written to file? If <code>FALSE</code>, functions will return an error.
</p>
</td></tr>
<tr><td><code id="templateMatching_+3A_report.amp">report.amp</code></td>
<td>

<p>If <code>TRUE</code>, <code>binMatch</code> will return the mean &ldquo;on&rdquo; and &ldquo;off&rdquo; amplitudes as well as their difference (the score). See details.
</p>
</td></tr>
<tr><td><code id="templateMatching_+3A_quiet">quiet</code></td>
<td>

<p>Use <code>TRUE</code> to suppress status updates to the console. Does not suppress messages or warnings.
</p>
</td></tr>
<tr><td><code id="templateMatching_+3A_...">...</code></td>
<td>

<p>Additional arguments to the <code>spectro</code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Scores are refereced by both the time elapsed since the beginning of the recording and the time of day on the date the recording was made.  For times derived from the date modified of the recording file (<code>time.source = "fileinfo"</code>) to be accurate the sound file must not have been edited (no samples added or removed) since its original creation.  File copying and duplication (as from removeable media to a storage drive) should not affect the date modified, although the creation date will be reset.  Date modified values are stored in the time zone when they were recorded but will be translated to the current time zone when read, which may result in errors due to daylight savings changes or when recorded surveys are shared across time zones. Time zone management is tricky; if recordings were made in a different time zone than the operating system running <code>fileCopyRename</code>, you can specify the correct time zone for the recordings with the <code>rec.tz</code> argument. Unexpected results are possible, as time zone abbreviations in general use may not match those in the Internet Assigned Numbers Authority tz database. The most reliable way to specify time zone is to use the full name, most quickly seen using <code><a href="base.html#topic+OlsonNames">OlsonNames</a></code>, and also found on Wikipedia: <a href="http://en.wikipedia.org/wiki/List_of_tz_database_time_zones">http://en.wikipedia.org/wiki/List_of_tz_database_time_zones</a>. Times derived from a date-time value encoded in the file name (<code>time.source = "filename"</code>) are more stable in regard, and are automatically created with either <code><a href="#topic+fileCopyRename">fileCopyRename</a></code> or <code><a href="#topic+mp3Subsamp">mp3Subsamp</a></code>.<br />
Binary point matching scores each time frame by computing the difference between the mean amplitude in the &ldquo;on&rdquo; cells and the mean amplitude in the &ldquo;off&rdquo; cells.  The resulting score can be a rough estimate of signal:noise.   
</p>


<h3>Value</h3>

<p>An S4 object of class <code>templateScores</code>, with the following slots:
</p>
<table role = "presentation">
<tr><td><code>survey.name</code></td>
<td>
<p>The file path to the survey that the scores apply to.</p>
</td></tr>
<tr><td><code>survey</code></td>
<td>
<p>The actual survey as a <code>Wave</code> object.</p>
</td></tr>
<tr><td><code>survey.data</code></td>
<td>
<p>A named list with one element per template.  Each element is a named list with time-domain results for the survey.</p>
</td></tr>
<tr><td><code>templates</code></td>
<td>
<p>The templates (an S4 object of class <code>corTemplateList</code> or <code>binTemplateList</code>) used to calculate the scores.</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>A named list with an element for each template. Each element contains the scores for an individual template.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>A character vector containing information on the run time.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Cross-correlation values are not normalized.
</p>


<h3>Note</h3>

<p>For examples, see <code><a href="#topic+findPeaks">findPeaks</a></code> and <code><a href="#topic+getDetections">getDetections</a></code>.
</p>


<h3>Author(s)</h3>

<p>Sasha D. Hafner and Jon Katz
</p>


<h3>References</h3>

<p>Mellinger, D. K. and C. W. Clark. 1997. Methods for automatic detection of mysticete sounds. <em>Marine and Freshwater Behaviour and Physiology</em>. <b>29</b>, 163-181.
</p>
<p>Towsey, M., B. Planitz, A. Nantes, J. Wimmer, and P. Roe. 2012. A toolbox for animal call recognition. <em>Bioacoustics-the International Journal of Animal Sound and Its Recording</em> <b>21</b>, 107-125.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeCorTemplate">makeCorTemplate</a></code>, 
<code><a href="#topic+makeBinTemplate">makeBinTemplate</a></code>, 
<code><a href="#topic+findPeaks">findPeaks</a></code>, 
<code><a href="#topic+getDetections">getDetections</a></code>, 
<code><a href="#topic+getPeaks">getPeaks</a></code>, 
<code><a href="#topic+fileCopyRename">fileCopyRename</a></code>, 
<code><a href="#topic+mp3Subsamp">mp3Subsamp</a></code>
</p>

<hr>
<h2 id='templateNames'>
Names of Templates
</h2><span id='topic+templateNames'></span><span id='topic+templateNames+3C-'></span>

<h3>Description</h3>

<p>Functions to check or change the names of templates within an acoustic template list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  templateNames(object)
  templateNames(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="templateNames_+3A_object">object</code></td>
<td>
<p>An acoustic template list, i.e., a <code><a href="#topic+corTemplateList-class">corTemplateList</a></code> or <code><a href="#topic+binTemplateList-class">binTemplateList</a></code> object.</p>
</td></tr>
<tr><td><code id="templateNames_+3A_value">value</code></td>
<td>
<p>A character vector of names. May be named.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is analogous to the function <code><a href="base.html#topic+names">names</a></code>.
</p>


<h3>Value</h3>

<p>For <code>names</code>, <code>NULL</code> or a character vector of the same length as <code>object</code>. For <code>names &lt;- </code>, the updated template list, i.e., the original template list with only the names changed.
</p>


<h3>Author(s)</h3>

<p>Sasha D. Hafner
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeCorTemplate">makeCorTemplate</a></code>, 
<code><a href="#topic+makeBinTemplate">makeBinTemplate</a></code>, 
<code><a href="#topic+templateComment">templateComment</a></code>, 
<code><a href="#topic+templateCutoff">templateCutoff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data(btnw)
data(oven)
data(survey)

# Write Wave objects to file (temporary directory used here)
btnw.fp &lt;- file.path(tempdir(), "btnw.wav")
oven.fp &lt;- file.path(tempdir(), "oven.wav")
writeWave(btnw, btnw.fp)
writeWave(oven, oven.fp)

# Create four correlation templates
wct1 &lt;- makeCorTemplate(btnw.fp, name = "w1")
wct2 &lt;- makeCorTemplate(btnw.fp, t.lim = c(1.5, 2.1), frq.lim = c(4.2, 5.6), name = "w2")
oct1 &lt;- makeCorTemplate(oven.fp, t.lim = c(1, 4), frq.lim = c(1, 11), name = "o1")
oct2 &lt;- makeCorTemplate(oven.fp, t.lim = c(1, 4), frq.lim = c(1, 11), dens = 0.1, name = "o2")

# Combine all of them
ctemps &lt;- combineCorTemplates(wct1, wct2, oct1, oct2)
ctemps

# To check template names
templateNames(ctemps)

# Change the first two
templateNames(ctemps)[1:2] &lt;- c("warbler 1", "warbler 2")

# Change all
templateNames(ctemps) &lt;- c("a", "b", "c", "d")

# To check template names
templateNames(ctemps)

# Clean up (only because these files were created in these examples)
file.remove(btnw.fp)
file.remove(oven.fp)
</code></pre>

<hr>
<h2 id='templatePath'>
Song clip path of Templates
</h2><span id='topic+templatePath'></span><span id='topic+templatePath+3C-'></span>

<h3>Description</h3>

<p>Functions to check or change the song clip path of templates within an acoustic template list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  templatePath(object)
  templatePath(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="templatePath_+3A_object">object</code></td>
<td>
<p>An acoustic template list, i.e., a <code><a href="#topic+corTemplateList-class">corTemplateList</a></code> or <code><a href="#topic+binTemplateList-class">binTemplateList</a></code> object.</p>
</td></tr>
<tr><td><code id="templatePath_+3A_value">value</code></td>
<td>
<p>A character vector of paths. May be named.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function works in the same way as the function <code><a href="base.html#topic+names">names</a></code>.
No check is performed to ensure that the specified path is valid.
</p>


<h3>Value</h3>

<p>For <code>filePath</code>, <code>NULL</code> or a character vector of the same length as <code>object</code>. For <code>filePath &lt;- </code>, the updated template list, i.e., the original template list with only the clip.path values changed.
</p>


<h3>Author(s)</h3>

<p>Sasha D. Hafner
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeCorTemplate">makeCorTemplate</a></code>, 
<code><a href="#topic+makeBinTemplate">makeBinTemplate</a></code>, 
<code><a href="#topic+templateComment">templateComment</a></code>, 
<code><a href="#topic+templateCutoff">templateCutoff</a></code>, 
<code><a href="#topic+templateNames">templateNames</a></code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data(btnw)
data(oven)

# Write Wave objects to file (temporary directory used here)
btnw.fp &lt;- file.path(tempdir(), "btnw.wav")
oven.fp &lt;- file.path(tempdir(), "oven.wav")
writeWave(btnw, btnw.fp)
writeWave(oven, oven.fp)

# Create four correlation templates
wct1 &lt;- makeCorTemplate(btnw.fp, name = "w1")
wct2 &lt;- makeCorTemplate(btnw.fp, t.lim = c(1.5, 2.1), frq.lim = c(4.2, 5.6), name = "w2")
oct1 &lt;- makeCorTemplate(oven.fp, t.lim = c(1, 4), frq.lim = c(1, 11), name = "o1")
oct2 &lt;- makeCorTemplate(oven.fp, t.lim = c(1, 4), frq.lim = c(1, 11), dens = 0.1, name = "o2")

# Combine all of them
ctemps &lt;- combineCorTemplates(wct1, wct2, oct1, oct2)
ctemps

# To check paths
templatePath(ctemps)

# Change the first two
templatePath(ctemps)[1:2] &lt;- c("~/templates/btnw.wav", "~/templates/btnw.wav")

# Clean up (only because these files were created in these examples)
file.remove(btnw.fp)
file.remove(oven.fp)
</code></pre>

<hr>
<h2 id='templateScores-class'>Class <code>"templateScores"</code></h2><span id='topic+templateScores-class'></span>

<h3>Description</h3>

<p>These objects contain template scores, which indicate how well templates match a single survey recording, with a value for each time bin.
Additionally, all the objects which were used to create these scores are also saved within the objects.
Objects of this class represent an intermediate step in the template detection process&ndash;detections need to be found in the scores using <code><a href="#topic+findPeaks">findPeaks</a></code>. 
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("templateScores", ...)</code>.
However, they should always be created with the <code><a href="#topic+corMatch">corMatch</a></code> or <code><a href="#topic+binMatch">binMatch</a></code> function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>survey.name</code>:</dt><dd><p>Object of class <code>character</code>. The name of the survey file, or <code>"A Wave object"</code> if the survey was not read in from a file.</p>
</dd>
<dt><code>survey</code>:</dt><dd><p>Object of class <code><a href="tuneR.html#topic+Wave">Wave</a></code>. The survey data, as a <code>"Wave"</code> object.</p>
</dd>
<dt><code>survey.data</code>:</dt><dd><p>Object of class <code>list</code>. A named list, with one element for each template. Each element contains data from a Fourier transform of the original survey: <code>amp</code> is a matrix of amplitudes (frequency by time), <code>t.bins</code> is a numeric vector with the values of the time bins (left-aligned&ndash;first bin is always 0.0), and <code>frq.bins</code> is a numeric vector with the values of the frequency bins (top-aligned&ndash;last bin is always the upper limit). There is a separate element for each template because each template may use different parameters for the Fourier transform (see <code><a href="#topic+Template-class">Template</a></code>).</p>
</dd>
<dt><code>templates</code>:</dt><dd><p>Object of class <code>list</code>. A named list of templates, which is identical to the original <code><a href="#topic+TemplateList-class">TemplateList</a></code> used for template matching. This template list can be extracted with <code><a href="#topic+getTemplates">getTemplates</a></code>.</p>
</dd>
<dt><code>scores</code>:</dt><dd><p>Object of class <code>list</code>. A named list, with one element for each template. Each element is a data frame with three columns: <code>date.time</code> is the absolute time of the score, <code>time</code> is the relative time of the score (relative to the survey start), and <code>score</code> is the score. Times are based on the center of the template, and so <code>time</code> will not correspond to values in <code>t.bins</code> in the <code>survey.data</code> above if the template spans an even number of time bins.</p>
</dd>
<dt><code>time</code>:</dt><dd><p>Object of class <code>character</code>. Information on the time <code><a href="#topic+corMatch">corMatch</a></code> or <code><a href="#topic+binMatch">binMatch</a></code> took to run. The first element is the run time (s), and the second element is &ldquo;real-time factor&rdquo; (survey length divided by the run time).</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "templateScores")</code>: ... </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "templateScores")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Sasha D. Hafner
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findPeaks">findPeaks</a></code>, 
<code><a href="#topic+detectionList-class">detectionList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("templateScores")



</code></pre>

<hr>
<h2 id='timeAlign'>
Condense Detections or Peaks from Multiple Templates
</h2><span id='topic+timeAlign'></span>

<h3>Description</h3>

<p>Condense detections or peaks from a number of templates (of the same detection type); events that occur within an adjustable time buffer of one another are assumed to be duplicate detections.  In such cases the event with the highest score is saved.  Functions with detections for a single species or multiple species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeAlign(x, what = "detections", tol = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="timeAlign_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+detectionList-class">detectionList</a></code>, a single data frame of detections, or list of either file paths to a csv file or of data frames.</p>
</td></tr>
<tr><td><code id="timeAlign_+3A_what">what</code></td>
<td>
<p>Character, in <code>c("detections", "peaks")</code>.  Detections are peaks above a score cutoff.  Peaks are all peaks.  Required only if <code>x</code> is of class <code>detectionList</code></p>
</td></tr>
<tr><td><code id="timeAlign_+3A_tol">tol</code></td>
<td>
<p>Numeric value for tolerance, with units seconds.  If a detected event is within this value (actually +/- 0.5<code>tol</code>), the events are assumed to co-occur and be of the same origin.  A somewhat arbitrary value (like epsilon), but should be less than 2/3 the template duration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If input is an object of class <code><a href="#topic+detectionList-class">detectionList</a></code>, a single data frame, or list of either file paths or data frames.  Must be called for each survey.
</p>


<h3>Value</h3>

<p>Returns a single data frame of detections (the input <code>x</code>) with duplicated events removed, leaving only the event that had the highest score.
</p>


<h3>Note</h3>

<p>Events are assumed to be duplicated if they co-occur within a time duration of <code>tol</code>, but they are only compared to the event above and below when ordered by time.  Events with similar times can be spuriously discarded if <code>tol</code> is set larger than the separation of unrelated peaks.  Excessive deletion of events may also occur if the value for <code>tol</code> is set larger than the duration of the template.   Note that in this function <code>tol</code> specifies seconds, whereas in <code><a href="#topic+findPeaks">findPeaks</a></code> <code>tol</code> specifies a ratio.   
</p>


<h3>Author(s)</h3>

<p>Jon Katz
</p>


<h3>See Also</h3>

<p>The function <code><a href="#topic+eventEval">eventEval</a></code> operates similarly, but rather than merge detection results from multiple templates it compares them to known events and reports the True +, True -, False +, and False - rates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Not run because it will create files in user's working directory
data(survey)
data(btnw)

writeWave(btnw, "btnw.wav")

btnw2 &lt;- cutw(survey, from = 0.75, to = 3)

writeWave(btnw2, "btnw2.wav")

# Template construction
btnw1 &lt;- makeBinTemplate(
        "btnw.wav", 
        frq.lim = c(2, 8), 
        select = "auto", 
        name = "btnw1", 
        buffer = 4, 
        amp.cutoff = -31, 
        binary = TRUE)

btnw2 &lt;- makeBinTemplate(
        "btnw2.wav", 
        frq.lim = c(2, 8), 
        select = "auto", 
        name = "btnw2", 
        buffer = 4, 
        amp.cutoff = -24, 
        binary = TRUE)

# Join templates
btnw &lt;- combineBinTemplates(btnw1, btnw2)

# Binary point matching
scores &lt;- binMatch(survey = survey, templates = btnw, time.source = 'fileinfo')

# Isolate peaks
pks &lt;- findPeaks(scores)

# View detections
getDetections(pks)

# Compare to output of timeAlign
timeAlign(pks)
## End(Not run)
</code></pre>

<hr>
<h2 id='viewSpec'>
Interactively View and Annotate Spectrograms
</h2><span id='topic+viewSpec'></span>

<h3>Description</h3>

<p>Interactively page through short or long spectrograms of wav or mp3 files or <code><a href="tuneR.html#topic+Wave">Wave</a></code> objects.  Extract short or long wave files, play audio while viewing spectrogram, and annotate sounds in the spectrogram.  Load annotations from csv files for viewing.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viewSpec(clip, interactive = FALSE, start.time = 0, 
    units = "seconds", page.length = 30, 
    annotate = FALSE, anno, channel = "left", 
    output.dir = getwd(), frq.lim = c(0, 12), spec.col = gray.3(), 
    page.ovlp = 0.25, player = "play", wl = 512, ovlp = 0, 
    wn = "hanning", consistent = TRUE, 
    mp3.meta = list(kbps = 128, samp.rate = 44100, stereo = TRUE), 
    main = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="viewSpec_+3A_clip">clip</code></td>
<td>
<p>File path to wav file, mp3 file, or wave object.  See Details.</p>
</td></tr>
<tr><td><code id="viewSpec_+3A_interactive">interactive</code></td>
<td>
<p>Logical.  <code>FALSE</code> displays the first 30 seconds (or more, if <code>page.length</code> is increased) of a spectrogram.  <code>TRUE</code> enables the options to page through spectrograms, zoom in time and frequency, play, extract segments, and annotate.  See Details.</p>
</td></tr>
<tr><td><code id="viewSpec_+3A_start.time">start.time</code></td>
<td>
<p>Time in file to start reading.</p>
</td></tr>
<tr><td><code id="viewSpec_+3A_units">units</code></td>
<td>
<p>Units for start.time.  Available units are <code>c("seconds", "minutes", "hours")</code> Defaults to &quot;seconds&quot;.</p>
</td></tr>
<tr><td><code id="viewSpec_+3A_page.length">page.length</code></td>
<td>
<p>Duration of page length to view, in seconds.  Can be repeatedly halved and doubled within the function.</p>
</td></tr>
<tr><td><code id="viewSpec_+3A_annotate">annotate</code></td>
<td>
<p>Logical, to allow sounds to be highlighted and named on the spectrogram.  See Details.</p>
</td></tr>
<tr><td><code id="viewSpec_+3A_anno">anno</code></td>
<td>
<p>Character, file path to csv containing annotations.  Read in only if <code>annotate = TRUE</code>.</p>
</td></tr>
<tr><td><code id="viewSpec_+3A_channel">channel</code></td>
<td>
<p>Character value in <code>c("left", "right", "both")</code>.  Stereo recordings may be viewed as single channel or multi-channel spectrograms.  See Details.</p>
</td></tr>
<tr><td><code id="viewSpec_+3A_output.dir">output.dir</code></td>
<td>
<p>File path to directory where extracted clips and annotations will be saved, if other than the current working directory.</p>
</td></tr>
<tr><td><code id="viewSpec_+3A_frq.lim">frq.lim</code></td>
<td>
<p>Initial frequency limits to spectrogram, in kHz.  Accepts a 2 element vector.  Can be adjusted from within the function.</p>
</td></tr>
<tr><td><code id="viewSpec_+3A_spec.col">spec.col</code></td>
<td>
<p>Color (or grayscale) gradient to apply to the spectrogram.  See Details.</p>
</td></tr>
<tr><td><code id="viewSpec_+3A_page.ovlp">page.ovlp</code></td>
<td>
<p>Numeric value between 0 and 1.  Proportion of page.length to overlap when moving to a new page.</p>
</td></tr>
<tr><td><code id="viewSpec_+3A_player">player</code></td>
<td>
<p>Character value specifying an audio player to play the portion of the file corresponding to the visible spectrogram.</p>
</td></tr>
<tr><td><code id="viewSpec_+3A_wl">wl</code></td>
<td>
<p>Numeric value specifying number of samples per window in the Fourier Transform.  Accepts powers of 2: <code>c(128, 256, 512, 1024, 2048)</code></p>
</td></tr>
<tr><td><code id="viewSpec_+3A_ovlp">ovlp</code></td>
<td>
<p>Numeric value specifying window overlap in the Fourier Transform.  Specified as a percent between 0 and 99.</p>
</td></tr>
<tr><td><code id="viewSpec_+3A_wn">wn</code></td>
<td>
<p>Character value specifying window function in the Fourier Transform.  Defaults to <code>"hanning"</code>; <code>"hamming"</code> is also implemented.</p>
</td></tr>
<tr><td><code id="viewSpec_+3A_consistent">consistent</code></td>
<td>
<p>Logical, offers a method of maintaining color gradient map from page to page.  See Details.</p>
</td></tr>
<tr><td><code id="viewSpec_+3A_mp3.meta">mp3.meta</code></td>
<td>
<p>List of metadata used when paging through mp3 files using mp3splt.  <code>kbps</code> is the compression rate, <code>samp.rate</code> is the sample rate, and <code>stereo</code> is logical where <code>TRUE</code> represents both stereo and JntStereo.</p>
</td></tr>  
<tr><td><code id="viewSpec_+3A_main">main</code></td>
<td>
<p>Optional character object with which to name the spectrogram.  If <code>NULL</code> the file name will be used if possible.</p>
</td></tr>
<tr><td><code id="viewSpec_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="#topic+spectro">spectro</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>interactive = TRUE</code>, during the function session the console will display a command menu that prints commands to scroll or nudge to the next/previous page, zoom in/out in the time axis (by halving or doubling the page.length), play the page, save the page as a wave file, change spectrogram parameters (e.g. <code>frq.lim, start.time, wl, ovlp, </code> etc), or quit. An option not presented on-screen is &quot;i&quot; to identify the RMS amplitude in a selected portion of the spectrogram.<br />  
</p>
<p><code>viewSpec</code> relies on the WaveIO functions in <code><a href="tuneR.html#topic+tuneR">tuneR</a></code>, with some modifications.  Seeking in wave files and wave objects is accurate to the nearest sample, but the decoding required for mp3 files is &quot;bare bones&quot;.  Users can install the software mp3splt which will allow seeking in mp3 files very similar (albeit slightly less accurate) to that that exists for wave files.  When using mp3splt a short mp3 file the duration of each page is extracted from the <code>clip</code> file or object and saved to the working directory for each new page.<br />
</p>
<p>When <code>annotation</code> is set to TRUE the default is to start a new annotation file, unless a csv file containing annotations is specified with the argument <code>anno</code>.  Annotation adds the option to annotate to the console command menu, and annotations can be made after typing &quot;a&quot; into the console and pressing enter.  Annotation is accomplished by selecting first the upper-left corner of a bounding box around an event in the spectrogram followed by the lower-right corner; after the selection is complete the console will prompt to name the annotation.  At a minimum the first annotation must be named, but subsequent annotations will recycle the previous name if a new one is not provided.  When in annotation mode the console menu is not shown; instructions for annotation are displayed instead.  To exit annotation mode right-click an appropriate number of times, and the console command menu will return.  One or more annotations can be deleted by typing &quot;d&quot; in the console after the command menu is displayed, then bounding all annotations to delete in the same manner as if creating a new annotation.  Annotations are saved when the command to exit the function is initiated (&quot;q&quot;).  Occasionally unrecognized commands may cause the function to exit before annotations can be saved; to guard against losing annotations in such an event, annotations are auto-saved to a file called &quot;TMPannotations.csv&quot; in the working directory, from where they can be retrieved until written over during the next session.  Annotation is only possible in one channel per function invocation.  The channel will revert to <code>"left"</code> if <code>annotate = TRUE</code> and <code>channel = "both"</code>.<br />  
</p>
<p>Spectrogram colors are adjustable, and users may opt to create their own gradients for display.  A few are provided with monitoR including <code><a href="#topic+gray.1">gray.1</a></code>, <code><a href="#topic+gray.2">gray.2</a></code>, <code><a href="#topic+gray.3">gray.3</a></code>, <code><a href="#topic+rainbow.1">rainbow.1</a></code>, and <code><a href="#topic+topo.1">topo.1</a></code>, all of which are based on existing R colors.  The gradient is mapped to the values in the spectrogram each time the page is loaded.  In <code>gray.2</code>, for example, this means that every page will display the highest dB value as black and the lowest value as white.  The highest dB value likely changes from page to page, which can result in successive pages being displayed with wildly different color values.  Setting <code>consistent = TRUE</code> (the default) offers a way to minimize this effect, as it artificially weights a single cell in the lower-left corner with a value of 0 dB, which is usually mapped to a black.  Under normal circumstances this artificially black cell will not be noticed, but at high magnification it may stand out as erroneous, in which case setting <code>consistent = FALSE</code> may be warranted.<br />
</p>
<p>Spectrograms of existing <code>Wave</code> objects are titled with the first argument of the call, which is assumed to be <code>clip</code>.<br />
</p>
<p>The default audio player, &quot;play&quot;, is the shell command for SoX, the multi-OS media player. Windows will detect the file type and use the default media player with &quot;start&quot;, or you can specify one (such as Windows Media Player) with &quot;start wmplayer.exe&quot;. On Ubuntu try Rhythmbox (&quot;rhythmbox&quot;), and on Mac OS try afplay (&quot;afplay&quot;).           
</p>


<h3>Value</h3>

<p>A spectrogram plot.  Certain options invoked during the function may write new wave or csv files to the working directory.
</p>


<h3>Note</h3>

<p>The time axis is presented with a fair amount of rounding.  It becomes progressively more accurate as the zoom level increases.
</p>


<h3>Author(s)</h3>

<p>Jon Katz, Sasha D. Hafner
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dbUploadAnno">dbUploadAnno</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(survey)
viewSpec(survey)

## Not run: 
# Start a new annotation file
viewSpec(survey, annotate = TRUE)

# View previous annotations
data(survey_anno)
write.csv(survey_anno, "survey_anno.csv", row.names = FALSE)
viewSpec(survey, interactive = TRUE, annotate = TRUE, anno = "survey_anno.csv", start.time = 5)

# Disable consistent spectrograms
viewSpec(survey, interactive = TRUE, annotate = TRUE, page.length = 10, consistent = FALSE)

## End(Not run)</code></pre>

<hr>
<h2 id='writeTemplates'>
Write Acoustic Templates to Text Files
</h2><span id='topic+writeCorTemplates'></span><span id='topic+writeBinTemplates'></span>

<h3>Description</h3>

<p>These functions write all templates within a template list to text files within a specified directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeCorTemplates(..., dir = ".", ext = "ct", parallel = FALSE)
writeBinTemplates(..., dir = ".", ext = "bt", parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="writeTemplates_+3A_...">...</code></td>
<td>

<p>One or more template lists. 
</p>
</td></tr>
<tr><td><code id="writeTemplates_+3A_dir">dir</code></td>
<td>

<p>A file path to the directory where the files should be saved.
If it doesn't exist, the function will create it.
By default, the working directory.
</p>
</td></tr>
<tr><td><code id="writeTemplates_+3A_ext">ext</code></td>
<td>

<p>The file extension used for the new file(s).
</p>
</td></tr>
<tr><td><code id="writeTemplates_+3A_parallel">parallel</code></td>
<td>

<p>Set to <code>TRUE</code> to use <code>mclapply</code> from the parallel package to speed up the call for large template lists (not available for Windows operating systems).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For correlation templates (class <code><a href="#topic+corTemplateList-class">corTemplateList</a></code>) use <code>writeCorTemplates</code>, and use <code>writeBinTemplates</code> for binary templates (class <code>linkS4class{binTemplateList}</code>).
To write only some of the templates in a list to file, use indexing (<code><a href="#topic++5B-methods">[-methods</a></code>).
</p>


<h3>Value</h3>

<p><code>NULL</code>, invisibly.
</p>


<h3>Author(s)</h3>

<p>Sasha D. Hafner
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeCorTemplate">makeCorTemplate</a></code>, 
<code><a href="#topic+makeBinTemplate">makeBinTemplate</a></code>, 
<code><a href="#topic+readBinTemplates">readBinTemplates</a></code>, 
<code><a href="#topic+readCorTemplates">readCorTemplates</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data(btnw)
data(oven)

# Write Wave objects to file (temporary directory used here)
btnw.fp &lt;- file.path(tempdir(), "btnw.wav")
oven.fp &lt;- file.path(tempdir(), "oven.wav")
writeWave(btnw, btnw.fp)
writeWave(oven, oven.fp)

# Create four correlation templates
wct1 &lt;- makeCorTemplate(btnw.fp, name = "w1")
wct2 &lt;- makeCorTemplate(btnw.fp, t.lim = c(1.5, 2.1), frq.lim = c(4.2, 5.6), name = "w2")
oct1 &lt;- makeCorTemplate(oven.fp, t.lim = c(1, 4), frq.lim = c(1, 11), name = "o1")
oct2 &lt;- makeCorTemplate(oven.fp, t.lim = c(1, 4), frq.lim = c(1, 11), dens = 0.1, name = "o2")

# Combine all of them
ctemps &lt;- combineCorTemplates(wct1, wct2, oct1, oct2)

# To write ctemps to a directory "templates"
## Not run: 
# Not run because it will write files outside of user's temporary directory
writeCorTemplates(ctemps, dir = "templates")

## End(Not run)

# Clean up (only because these files were created in these examples)
file.remove(btnw.fp)
file.remove(oven.fp)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
