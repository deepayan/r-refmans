<!DOCTYPE html><html lang="en"><head><title>Help for package pheno</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pheno}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#connectedSets'><p>Connected sets in a matrix</p></a></li>
<li><a href='#date2jul1'><p>Converts string date to Julian date</p></a></li>
<li><a href='#date2jul2'><p>Converts a date (day,month,year) to Julian date</p></a></li>
<li><a href='#daylength'><p>Daylength at julian day i on latitude l</p></a></li>
<li><a href='#daysbetween'><p>Number of days between two dates</p></a></li>
<li><a href='#DWD'><p>Phenological observations</p></a></li>
<li><a href='#getConnectedSets'><p>Finds connected sets in a matrix or data frame</p></a></li>
<li><a href='#jul2date1'><p>Converts Julian date into string date</p></a></li>
<li><a href='#jul2date2'><p>Converts Julian date to integers day,month,year</p></a></li>
<li><a href='#leapyear'><p>Boolean test for leap year</p></a></li>
<li><a href='#matrix2raw'><p>Converts numeric matrix to data frame</p></a></li>
<li><a href='#maxConnectedSet'><p>Maximal connected set in a matrix</p></a></li>
<li><a href='#maxdaylength'><p>Maximal day length on latitude l</p></a></li>
<li><a href='#pheno.ddm'><p>Dense design matrix for phenological data</p></a></li>
<li><a href='#pheno.flm.fit'><p>Fits a two-way linear fixed model</p></a></li>
<li><a href='#pheno.lad.fit'><p>Fits a robust two-way linear model</p></a></li>
<li><a href='#pheno.mlm.fit'><p>Fits a two-way linear mixed model</p></a></li>
<li><a href='#raw2matrix'><p>Converts a numeric data frame to matrix</p></a></li>
<li><a href='#Searle'><p>Example of a two-way classification table</p></a></li>
<li><a href='#seqMK'><p>Sequential Mann-Kendall test for time series.</p></a></li>
<li><a href='#Simple'><p>Simple example of a two-way classification table</p></a></li>
<li><a href='#tau'><p>Kendall's normalized tau</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Auxiliary Functions for Phenological Data Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-05-12</td>
</tr>
<tr>
<td>Author:</td>
<td>Joerg Schaber</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides some easy-to-use functions for time series
        analyses of (plant-) phenological data sets. These functions
        mainly deal with the estimation of combined phenological time
        series and are usually wrappers for functions that are already
        implemented in other R packages adapted to the special
        structure of phenological data and the needs of phenologists.
        Some date conversion functions to handle Julian dates are also
        provided.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Maximilian Lange &lt;maximilian.lange@ufz.de&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0), nlme, SparseM, quantreg, methods, stats</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-12 13:54:36 UTC; langema</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-12 21:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='connectedSets'>Connected sets in a matrix</h2><span id='topic+connectedSets'></span>

<h3>Description</h3>

<p>Finds connected data sets, i.e. connected rows and columns
of a numeric matrix M.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>connectedSets(M)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="connectedSets_+3A_m">M</code></td>
<td>
<p>Numeric matrix with missing values assumed to be NA or 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a two-way classification of linear models sometimes independent
sets of normal equations are obtained due to missing data in the
experiments design, i.e. the complete design matrix is not of full rank
and thus no solution can be found. However, solutions of the independent
sets of normal equations can still exist.
This phenomenon is called 'connectedness' of the data.
Especially in phenological analysis experimental designs are almost
always unbalanced because of missing data. Thus, when combined time
series are to be estimated, it is worth checking for and finding
connected data sets for which combined time series can then be estimated.
Example (also see example data(Simple) and example in 'maxConnectedSet'):
In the following matrix dots represent missing values, X represent observations
and the lines join the connected sets:
</p>
<p>:	X\_\_\_X   .   .	<br />
:	    <code class="reqn">\mid</code>	<br />
:	X\_\_\_X   .   .	<br />
:						<br />
:	.   .   X\_\_\_X	<br />
</p>
<p>Thus, in this matrix observations in rows 1 and 2 or colums 1 and 2 form one connected
set. Likewise row 3 (or columns 3 and 4) form also one connected set.	
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>rowclasses</code></td>
<td>
<p>Vector of set numbers of rows of M (&gt;=1). A value of <code>-1</code> indicates a row with missing data.</p>
</td></tr>
<tr><td><code>colclasses</code></td>
<td>
<p>Vector of set numbers of columns of M(&gt;=1).  A value of <code>-1</code> indicates a column with missing data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joerg Schaber
</p>


<h3>References</h3>

<p>Searle (1997) 'Linear Models'. Wiley. page 318.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+maxConnectedSet">maxConnectedSet</a></code>
<code><a href="#topic+getConnectedSets">getConnectedSets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(Simple)
	connectedSets(Simple)
</code></pre>

<hr>
<h2 id='date2jul1'>Converts string date to Julian date</h2><span id='topic+date2jul1'></span>

<h3>Description</h3>

<p>Converts a string date &quot;DD.MM.YYYY&quot; into a Julian day
of year (DOY).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date2jul1(d)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="date2jul1_+3A_d">d</code></td>
<td>
<p>Date as charater string 'DD.MM.YYYY'.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>doy</code></td>
<td>
<p>Day of year as integer.</p>
</td></tr>	
<tr><td><code>year</code></td>
<td>
<p>Year as integer.</p>
</td></tr>	
</table>


<h3>Author(s)</h3>

<p>Joerg Schaber
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	date2jul1('31.05.1970')
</code></pre>

<hr>
<h2 id='date2jul2'>Converts a date (day,month,year) to Julian date</h2><span id='topic+date2jul2'></span>

<h3>Description</h3>

<p>Converts an integer date (day,month,year) into a Julian day of year (DOY).
If y is missing, 2000 is assumed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date2jul2(d,m,y)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="date2jul2_+3A_d">d</code></td>
<td>
<p>Day of month, numeric coecerd into an integer.</p>
</td></tr>
<tr><td><code id="date2jul2_+3A_m">m</code></td>
<td>
<p>Month of year, numeric coerced into an integer.</p>
</td></tr>
<tr><td><code id="date2jul2_+3A_y">y</code></td>
<td>
<p>Year, numeric coerced into an integer, default 2000.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>doy</code></td>
<td>
<p>Day of year as integer.</p>
</td></tr>	
<tr><td><code>year</code></td>
<td>
<p>Year as integer.</p>
</td></tr>	
</table>


<h3>Author(s)</h3>

<p>Joerg Schaber
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	date2jul2(31,5,1970)
</code></pre>

<hr>
<h2 id='daylength'>Daylength at julian day i on latitude l</h2><span id='topic+daylength'></span>

<h3>Description</h3>

<p>Calculates daylength [h] and declination angle delta [radians]
on day i [julian day of year] for latitude l [degrees].	
</p>


<h3>Usage</h3>

<pre><code class='language-R'>daylength(i,l)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="daylength_+3A_i">i</code></td>
<td>
<p>Integer as julian day of year (1-365)</p>
</td></tr>	
<tr><td><code id="daylength_+3A_l">l</code></td>
<td>
<p>Float as latitude [degress]</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>dl</code></td>
<td>
<p>daylength [h]</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>declination angle [degrees]</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joerg Schaber
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	daylength(as.integer(120),63)
</code></pre>

<hr>
<h2 id='daysbetween'>Number of days between two dates</h2><span id='topic+daysbetween'></span>

<h3>Description</h3>

<p>Number of days between date1 and date2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>daysbetween(d1,d2)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="daysbetween_+3A_d1">d1</code></td>
<td>
<p>Date as a character string 'DD.MM.YYYY'.</p>
</td></tr>
<tr><td><code id="daysbetween_+3A_d2">d2</code></td>
<td>
<p>Date as s character string 'DD.MM.YYYY'.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ndays</code></td>
<td>
<p>Number of days between d1 and d2.</p>
</td></tr>	
</table>


<h3>Author(s)</h3>

<p>Joerg Schaber
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	daysbetween('31.05.1970','10.03.2004')
</code></pre>

<hr>
<h2 id='DWD'>Phenological observations</h2><span id='topic+DWD'></span>

<h3>Description</h3>

<p>Phenological observations of nine stations from 1951 to 1998.
Data from the German Weather Service.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DWD)</code></pre>


<h3>Format</h3>

<p>Data frame containing three columns (day of year of observations,year,station-id)</p>


<h3>Source</h3>

<p>German Weather Service</p>


<h3>References</h3>

<p>Schaber J, Badeck F-W (2002) 'Evaluation of methods for the combination of phenological time series and outlier detection'. Tree Physiology 22:973-982
</p>

<hr>
<h2 id='getConnectedSets'>Finds connected sets in a matrix or data frame</h2><span id='topic+getConnectedSets'></span>

<h3>Description</h3>

<p>Finds a list of connected data sets in a matrix or data frame
and returns them accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getConnectedSets(M)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getConnectedSets_+3A_m">M</code></td>
<td>
<p>Numeric matrix with missing values considered as 0, or
a data frame. The data frame is internally converted to a matrix
and should have three columns (x, factor 1, factor 2) where
x are considered the entries of the matrix, rows correspond to 
levels of factor 2 and columns correspond to levels of factor 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>getConnctedSets returns a list of connected data sets as numeric data frames D
with three columns (x, factor 1, factor 2) or a n*m matrix M,
where the n rows correspond to n levels of factor 2 and m columns
correspond to m levels of factor the respective factors.
Output as data frame or matrix, depending on input.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>cs_i</code></td>
<td>
<p>List of connected sets as matrix or data frame, corresponding to the input.
named as cs_i with i being the number of the connected sets.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joerg Schaber
</p>


<h3>References</h3>

<p>Searle (1997) 'Linear Models'. Wiley. page 318.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+connectedSets">connectedSets</a></code>
<code><a href="#topic+maxConnectedSet">maxConnectedSet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(Searle)
	getConnectedSets(Searle)
</code></pre>

<hr>
<h2 id='jul2date1'>Converts Julian date into string date</h2><span id='topic+jul2date1'></span>

<h3>Description</h3>

<p>Converts Julian day of year (DOY) into a string date 'DD.MM.YYYY'.
If y is missing a non-leap year is assumed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jul2date1(d,y)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jul2date1_+3A_d">d</code></td>
<td>
<p>DOY, numeric coerced into an integer.</p>
</td></tr>
<tr><td><code id="jul2date1_+3A_y">y</code></td>
<td>
<p>Year, numeric coerced into an integer, default 2000.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>date</code></td>
<td>
<p>Date, as character string 'DD.MM.YYYY'</p>
</td></tr>	
</table>


<h3>Author(s)</h3>

<p>Joerg Schaber
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	jul2date1(151,1970)
</code></pre>

<hr>
<h2 id='jul2date2'>Converts Julian date to integers day,month,year</h2><span id='topic+jul2date2'></span>

<h3>Description</h3>

<p>Converts Julian day of year (DOY) into an integer date (day,month,year).
If y is missing a non-leap year is assumed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jul2date2(d,y)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jul2date2_+3A_d">d</code></td>
<td>
<p>DOY, numeric coerced into an integer.</p>
</td></tr>
<tr><td><code id="jul2date2_+3A_y">y</code></td>
<td>
<p>Year, numeric coerced into an integer, default 2000.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>day</code></td>
<td>
<p>Day of month as integer.</p>
</td></tr>	
<tr><td><code>month</code></td>
<td>
<p>Month of year as integer.</p>
</td></tr>	
<tr><td><code>year</code></td>
<td>
<p>Year as integer.</p>
</td></tr>	
</table>


<h3>Author(s)</h3>

<p>Joerg Schaber
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	jul2date2(151,1970)
</code></pre>

<hr>
<h2 id='leapyear'>Boolean test for leap year</h2><span id='topic+leapyear'></span>

<h3>Description</h3>

<p>Tests whether a given year is a leap year or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leapyear(y)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="leapyear_+3A_y">y</code></td>
<td>
<p>Year, numeric coerced into integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>TRUE</code></td>
<td>
<p>leap year</p>
</td></tr>	
<tr><td><code>FALSE</code></td>
<td>
<p>non leap year</p>
</td></tr>	
</table>


<h3>Author(s)</h3>

<p>Joerg Schaber
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	leapyear(2000)
	leapyear(2004)
</code></pre>

<hr>
<h2 id='matrix2raw'>Converts numeric matrix to data frame</h2><span id='topic+matrix2raw'></span>

<h3>Description</h3>

<p>Converts a numeric matrix M into a dataframe D
with three columns (x, factor 1, factor 2)
where rows of M are ranks of factor 1 levels and columns of M are
ranks of factor 2 levels, missing values are assumed to be 0 or NA.
The resulting dataframe D has no missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix2raw(M,l1,l2)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matrix2raw_+3A_m">M</code></td>
<td>
<p>Numeric matrix, with missing values assumed to be NA or 0.</p>
</td></tr>
<tr><td><code id="matrix2raw_+3A_l1">l1</code></td>
<td>
<p><b>Optional</b> numeric vector of level names of column 2 (factor 1)
of returned data frame. If missing it is assigned row numbers of <code>M</code>.</p>
</td></tr>
<tr><td><code id="matrix2raw_+3A_l2">l2</code></td>
<td>
<p><b>Optional</b> numeric vector of level names of column 3 (factor 2)
of returned data frame. If missing it is assigned column numbers of <code>M</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>D</code></td>
<td>
<p>Data frame with three columns: (y,f1,f1). <code>y</code>: observations, i.e.
non-zero entries, in matrix. <code>f1</code>: factor 1, i.e. row number of M or <code>l1</code>.
<code>f2</code>: factor 2, i.e. column number of M or <code>l2</code>. D is ordered first by
factor 2 and then factor 1. D has no missing values.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joerg Schaber
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(DWD)
	M &lt;- raw2matrix(DWD)			# conversion to matrix
	D1 &lt;- matrix2raw(M)			# back conversion, but with different level names
	D2 &lt;- matrix2raw(M,c(1951:1998),c(1:9))	# with original level names
</code></pre>

<hr>
<h2 id='maxConnectedSet'>Maximal connected set in a matrix</h2><span id='topic+maxConnectedSet'></span>

<h3>Description</h3>

<p>Finds connected data set, i.e. connected rows and columns
of a numeric matrix M, that has the largest number of data entries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxConnectedSet(M)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maxConnectedSet_+3A_m">M</code></td>
<td>
<p>Numeric matrix with missing values considered as 0, or
a data frame. The data frame is internally converted to a matrix
and should have three columns (x, factor 1, factor 2) where
x are considered the entries of the matrix, rows correspond to 
levels of factor 2 and columns correspond to levels of factor 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a two-way classification of linear models sometimes independent
sets of normal equations are obtained due to missing data in the
experiments design, i.e. the complete design matrix is not of full rank
and thus no solution can be found. However, solutions of the independent
sets of normal equations can still exist.
This phenomenon is called 'connectedness' of the data.
Especially in phenological analysis experimental designs are almost
always unbalanced because of missing data. Thus, when combined time
series are to be estimated, it is worth checking for and finding
connected data sets for which combined time series can then be estimated.
This can also be interpreted in the way that a prerequisite to obtain
a combined time series is to have overlapping time series.
Example (also see example data(Searle) from Searle (1997), page 324 and
example in 'connectedSets'):
In the following matrix dots represent missing values, X represent observations
and the lines join the connected sets:
</p>
<p>:	X\_\_\_.\_\_\_.\_\_\_.\_\_\_X   .   .   . 		<br />
:                       <code class="reqn">\mid</code>				<br />
:	.   .   X\_\_\_.\_\_\_!\_\_\_.\_\_\_.\_\_\_X	<br />
:                       <code class="reqn">\mid</code>           <code class="reqn">\mid</code><br />
:	.   X\_\_\_.\_\_\_.\_\_\_!\_\_\_X\_\_\_X   !<br />
:                       <code class="reqn">\mid</code>       <code class="reqn">\mid</code>   <code class="reqn">\mid</code><br />
:	.   X\_\_\_.\_\_\_.\_\_\_!\_\_\_X\_\_\_X   !<br />
:                       <code class="reqn">\mid</code>           <code class="reqn">\mid</code><br />
:	.   .   .   .   X   .   .   !					<br />
:                       <code class="reqn">\mid</code>           <code class="reqn">\mid</code><br />
:	.   .   X\_\_\_.\_\_\_!\_\_\_.\_\_\_.\_\_\_X	<br />
:                       <code class="reqn">\mid</code>				<br />
:	.   .   .   X\_\_\_X   .   .   .				<br />
</p>
<p>Thus, in this matrix observations of rows 1, 5 and 7 or colums 1, 4 and 5 form
one connected set. Likewise observations of rows 2 and 6 (or columns 3 and 8)
and rows 3 and 4 (or columns 2, 6 and 7) form also connected sets, respectively.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ms</code></td>
<td>
<p>maximal connected set as matrix or data frame, corresponding to the input.</p>
</td></tr>
<tr><td><code>maxl</code></td>
<td>
<p>Number of observations in the maximal connected data set.</p>
</td></tr>
<tr><td><code>nsets</code></td>
<td>
<p>Number of connected data sets.</p>
</td></tr>
<tr><td><code>lsets</code></td>
<td>
<p>Vector with number of observations in each connected data sets, i.e. lsets[i] is the number of observations in connected data set i.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joerg Schaber
</p>


<h3>References</h3>

<p>Searle (1997) 'Linear Models'. Wiley. page 318.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+connectedSets">connectedSets</a></code>
<code><a href="#topic+maxConnectedSet">maxConnectedSet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(Searle)
	maxConnectedSet(Searle)
</code></pre>

<hr>
<h2 id='maxdaylength'>Maximal day length on latitude l</h2><span id='topic+maxdaylength'></span>

<h3>Description</h3>

<p>Calculates maximal daylength maxdl [h] at a certain latitude l [degrees].	
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxdaylength(l)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maxdaylength_+3A_l">l</code></td>
<td>
<p>Latitude in degrees.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>maxdl</code></td>
<td>
<p>Maximal daylength [h] at a certain latitude l [degrees]</p>
</td></tr>	
</table>


<h3>Author(s)</h3>

<p>Joerg Schaber
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	maxdaylength(60)
</code></pre>

<hr>
<h2 id='pheno.ddm'>Dense design matrix for phenological data</h2><span id='topic+pheno.ddm'></span>

<h3>Description</h3>

<p>Creation of dense two-way classification design matrix.
The sum of the second factor is constrained to be zero. No general mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pheno.ddm(D,na.omit=TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pheno.ddm_+3A_d">D</code></td>
<td>
<p>Data frame with three columns: (observations, factor 1, factor 2).</p>
</td></tr>
<tr><td><code id="pheno.ddm_+3A_na.omit">na.omit</code></td>
<td>
<p>Determined whether missing values should be omitted or not. Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In phenological applications observations should be the julian day
of observation of a certain phase, factor 1 should be the observation year
and factor 2 should be a station-id.
Usually this is much easier created by:
<code>y &lt;- factor(f1),
	s &lt;- factor(f2),
	ddm &lt;- as.matrix.csr(model.matrix(~ y + s -1, contrasts=list(s=("contr.sum"))))</code>.
However, this procedure can be quite memory demanding and might exceed storage
capacity for large problems. 
This procedure here is much less memory comsuming.
Moreover, in order to get direct estimates for all coefficients, 
an additional row is appended to the matrix, where the columns for the second factor are set to 1.
Therefore, dimensions of <code>ddm</code> are (nlevels(factor1)+1)x(nlevels(factor2)).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ddm</code></td>
<td>
<p>Dense roworder matrix, matrix.csr format (see matrix.csr in package SparseM)</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Data frame D sorted first by f2 then by f1 and with rows containing NA's removed.</p>
</td></tr>
<tr><td><code>na.rows</code></td>
<td>
<p>Rows in D that were omitted due to missing values.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joerg Schaber
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+model.matrix">model.matrix</a></code>
<code><a href="SparseM.html#topic+matrix.csr">matrix.csr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(DWD)
	ddm1 &lt;- pheno.ddm(DWD)
	attach(DWD)
	y &lt;- factor(DWD[[2]])
	s &lt;- factor(DWD[[3]])
	ddm2 &lt;- as.matrix.csr(model.matrix(~ y + s -1, contrasts=list(s=("contr.sum"))))
	identical(ddm1$ddm,ddm2)
</code></pre>

<hr>
<h2 id='pheno.flm.fit'>Fits a two-way linear fixed model</h2><span id='topic+pheno.flm.fit'></span>

<h3>Description</h3>

<p>Fits a two-way linear fixed model. 
The model assumes the first factor f1 the second factor f2 to be fixed. 
Errors are assumed to be i.i.d. No general mean and sum of 
f2 is constrained to be zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pheno.flm.fit(D,limit=1000)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pheno.flm.fit_+3A_d">D</code></td>
<td>
<p>Data frame with three columns (x, f1, f2) or a matrix
where rows are ranks of factor f1 levels and columns are ranks 
of factor f2 levels and missing values are assumed to be NA or 0.</p>
</td></tr>	
<tr><td><code id="pheno.flm.fit_+3A_limit">limit</code></td>
<td>
<p>Integer that determines which algorithm to use (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is basically a wrapper for the <code>slm.fit()</code> function
form the <code>SparseM</code> package, adapted for the estimation of combined phenological time series.
In phenological application, x should be the julian day
of observation of a certain phase, factor f1 should be the observation year
and factor f2 should be a station-id.
For large problems <code>length(x)&gt;limit</code>, the linear model is calculated
for treatment contrasts for efficiency reasons, and the constraint that the sum of f2 is zero,
is adjusted afterwards. This results in a slight over-estimation of
standard errors.
Note that the input data is sorted before fitting, such that subsequent
analyses using the input data should be done using the sorted output data frame.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>f1</code></td>
<td>
<p>Estimated fixed effects f1, in phenology this is precisely the combined time series.</p>
</td></tr>
<tr><td><code>f1.se</code></td>
<td>
<p>f1 estimated standard error.</p>
</td></tr>
<tr><td><code>f1.lev</code></td>
<td>
<p>Levels of f1. Should be the same order as f1.</p>
</td></tr>
<tr><td><code>f2</code></td>
<td>
<p>Estimated fixed effects f2, in phenology these are the station effects.</p>
</td></tr>
<tr><td><code>f2.se</code></td>
<td>
<p>f2 estimated standard error.</p>
</td></tr>
<tr><td><code>f2.lev</code></td>
<td>
<p>Levels of f2. Should be the same order as f2.</p>
</td></tr>
<tr><td><code>resid</code></td>
<td>
<p>Residuals</p>
</td></tr>
<tr><td><code>lclf1</code></td>
<td>
<p>Lower 95 percent confidence limit of factor f1.</p>
</td></tr>
<tr><td><code>uclf1</code></td>
<td>
<p>Upper 95 percent confidence limit of factor f1.</p>
</td></tr>
<tr><td><code>lclf2</code></td>
<td>
<p>Lower 95 percent confidence limit of factor f2.</p>
</td></tr>
<tr><td><code>uclf2</code></td>
<td>
<p>Upper 95 percent confidence limit of factor f2.</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>The input as ordered data frame, ordered first by f2 then by f1</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>The fitted lm model object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joerg Schaber
</p>


<h3>References</h3>

<p>Searle (1997) 'Linear Models'. Wiley.
Schaber J, Badeck F-W (2002) 'Evaluation of methods for the combination of phenological time series and outlier detection'. Tree Physiology 22:973-982
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+lm">lm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(DWD)
	R &lt;- pheno.flm.fit(DWD)					# parameter estimation
</code></pre>

<hr>
<h2 id='pheno.lad.fit'>Fits a robust two-way linear model</h2><span id='topic+pheno.lad.fit'></span>

<h3>Description</h3>

<p>Fits a robust two-way linear model. 
The model assumes both factors (f1 and f2) to be fixed.
Errors are assumed to be i.i.d. No general mean and sum of
f2 is constrained to be zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pheno.lad.fit(D,limit=1000)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pheno.lad.fit_+3A_d">D</code></td>
<td>
<p>Data frame with three columns (x, f1, f2) or a matrix 
where rows are ranks of factor f1 levels and columns are ranks 
of factor f2 levels and missing values are assumed to be NA or 0.</p>
</td></tr>	
<tr><td><code id="pheno.lad.fit_+3A_limit">limit</code></td>
<td>
<p>Integer that determines which algorithm to use (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function minimizes the least absolute deviations (LAD or L1 norm)
of the residuals of a two-way linear model.
This function is basically a wrapper for the <code>rq.fit()</code> or <code>rq.fit.sfn()</code>
functions of the <code>quantreg</code> package, respectively,
adapted for the estimation of combined phenological time series. 
Depending on the size of the problem <code>length(x)&lt;=limit</code> 
either the <code>rq.fit()</code> function using the Barrodale-Roberts algorithm is used or 
(length(x)&gt;1000) the corresponding dense matrix implementation with 
<code>rq.fit.sfn()</code> using the Interior-Point method.
In phenological applications, x should be the julian day
of observation of a certain phase, factor f1 should be the observation year
and factor f2 should be a station-id. 
For efficiency reasons, the linear model is calcualted for treatment contrasts 
and the constraint that the sum of f2 is zero, is adjusted afterwards.
Note that the input data is sorted before fitting, such that subsequent
analyses using the input data should be done using the sorted output data frame.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>f1</code></td>
<td>
<p>Estimated parameters of factor f1, in phenology this is precisely the combined time series.</p>
</td></tr>
<tr><td><code>f1.lev</code></td>
<td>
<p>Levels of f1. Should be the same order as f1.</p>
</td></tr>
<tr><td><code>f2</code></td>
<td>
<p>Estimated parameters of factor f2, in phenology these are precisely the station effects.</p>
</td></tr>
<tr><td><code>f2.lev</code></td>
<td>
<p>Levels of f2. Should be the same order as f2.</p>
</td></tr>
<tr><td><code>resid</code></td>
<td>
<p>Residuals</p>
</td></tr>
<tr><td><code>ierr</code></td>
<td>
<p>For length(x) &gt; 1000 this is the return error code of <code>rq.fit.sfn()</code></p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>The input as ordered data frame, ordered first by f2 then by f1</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>The fitted rq.fit model object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joerg Schaber
</p>


<h3>References</h3>

<p>Rousseeuw PJ, Leroy AM (1987) 'Robust estimation and outlier detection'. Wiley.
Schaber J, Badeck F-W (2002) 'Evaluation of methods for the combination of phenological time series and outlier detection'. Tree Physiology 22:973-982
</p>


<h3>See Also</h3>

<p><code><a href="quantreg.html#topic+rq.fit">rq.fit</a></code>
<code><a href="quantreg.html#topic+rq.fit.sfn">rq.fit.sfn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(DWD)
	R &lt;- pheno.lad.fit(DWD)				# robust parameter estimation
	plot(levels(factor(R$D[[2]])),R$p1,type="l")	# plot combined time series
	R$D[R$resid &gt;= 30,]				# observation whose residuals
							# are &gt; 30 days (outliers)
</code></pre>

<hr>
<h2 id='pheno.mlm.fit'>Fits a two-way linear mixed model</h2><span id='topic+pheno.mlm.fit'></span>

<h3>Description</h3>

<p>Fits a two-way linear mixed model. 
The model assumes the first factor f1 to be fixed and the second factor f2 to
be random. Errors are assumed to be i.i.d. No general mean and sum of 
f2 is constrained to be zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pheno.mlm.fit(D)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pheno.mlm.fit_+3A_d">D</code></td>
<td>
<p>Data frame with three columns (x, f1, f2) or a matrix
where rows are ranks of factor f1 levels and columns are ranks 
of factor f2 levels and missing values are set to 0.</p>
</td></tr>	
</table>


<h3>Details</h3>

<p>This function is basically a wrapper for the <code>lme()</code> function of
the <code>nlme</code> package, adapted for the estimation of combined
phenological time series. Estimation method: restricted maximum likelihood (REML)
In phenological application, x should be the julian day
of observation of a certain phase, factor f1 should be the observation year
and factor f2 should be a station-id. 
Note that the input data is sorted before fitting, such that subsequent
analyses using the input data should be done using the sorted output data frame.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>fixed</code></td>
<td>
<p>Estimated fixed effects, in phenology this is precisely the combined time series.</p>
</td></tr>
<tr><td><code>fixed.lev</code></td>
<td>
<p>Levels of fixed effects. Should be the same order as fixed effects.</p>
</td></tr>
<tr><td><code>random</code></td>
<td>
<p>Estimated random effects, in phenology these are the station effects.</p>
</td></tr>
<tr><td><code>random.lev</code></td>
<td>
<p>Levels of random effects. Should be the same order as random effects.</p>
</td></tr>
<tr><td><code>SEf1</code></td>
<td>
<p>Standard error group f1, i.e. square root of variance component fixed effect.</p>
</td></tr>
<tr><td><code>SEf2</code></td>
<td>
<p>Standard error group f2, i.e. square root of variance component random effect.</p>
</td></tr>
<tr><td><code>lclf</code></td>
<td>
<p>Lower 95 percent confidence limit of fixed effects.</p>
</td></tr>
<tr><td><code>uclf</code></td>
<td>
<p>Upper 95 percent confidence limit of fixed effects.</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>The input as ordered data frame, ordered first by f2 then by f1</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>The fitted lme model object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joerg Schaber
</p>


<h3>References</h3>

<p>Searle (1997) 'Linear Models'. Wiley.
Schaber J, Badeck F-W (2002) 'Evaluation of methods for the combination of phenological time series and outlier detection'. Tree Physiology 22:973-982
</p>


<h3>See Also</h3>

<p><code><a href="nlme.html#topic+lme">lme</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(DWD)
	R &lt;- pheno.mlm.fit(DWD)				# parameter estimation
	plot(levels(factor(DWD[[2]])),R$fixed,type="l")	# plot combined time series
	tr &lt;- lm(R$fixed~rank(levels(factor(DWD[[2]]))))# trend estimation
	summary(tr)$coef[2]				# slope of trend
	summary(tr)$coef[4]				# standard error of trend
</code></pre>

<hr>
<h2 id='raw2matrix'>Converts a numeric data frame to matrix</h2><span id='topic+raw2matrix'></span>

<h3>Description</h3>

<p>Converts a numeric data frame D with three columns (x, factor 1, factor 2)
to a numeric matrix M where rows are ranks of levels of factor 1 and columns are
ranks of levels of factor 2, missing values are set to NA.	
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw2matrix(D)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raw2matrix_+3A_d">D</code></td>
<td>
<p>Data frame with three columns (x, factor 1, factor 2)</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>M</code></td>
<td>
<p>Numeric matrix where rows are ranks of levels of factor 1 and columns are
ranks of levels of factor 2, missing values are set to NA.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joerg Schaber
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(DWD)
	raw2matrix(DWD)
</code></pre>

<hr>
<h2 id='Searle'>Example of a two-way classification table</h2><span id='topic+Searle'></span>

<h3>Description</h3>

<p>Example of a two-way classification table where lacking data
creates three distinct connected sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Searle)</code></pre>


<h3>Format</h3>

<p>R source file</p>


<h3>References</h3>

<p>Searle (1997) 'Linear Models'. Wiley. 324p.
</p>

<hr>
<h2 id='seqMK'>Sequential Mann-Kendall test for time series.</h2><span id='topic+seqMK'></span>

<h3>Description</h3>

<p>The sequential Mann-Kendall test on time series x detects 
approximate potential trend turning points in time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqMK(x)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seqMK_+3A_x">x</code></td>
<td>
<p>Numeric vector x.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implicitly assumes a equidistant time series x. 
Calculates a progressive and a retrograde series of Kendall normalized tau's. 
Points where the two lines cross are considered as approximate potential 
trend turning points. When either the progressive or retrograde row exceed
certain confidence limits before and after the crossing points, this trend
turning point is considered significant at the corresponding level, 
i.e. 1.96 for 95
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>prog</code></td>
<td>
<p>Progressive row of Kendall's normalized tau's</p>
</td></tr>
<tr><td><code>retr</code></td>
<td>
<p>Retrograde row of Kendall's normalized tau's</p>
</td></tr>
<tr><td><code>tp</code></td>
<td>
<p>Boolean vector indicating at what indices of the original timeseries the prog and retr cross, i.e. TRUE at potential trend turning points.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joerg Schaber
</p>


<h3>References</h3>

<p>Kendall M, Gibbons JD (1990) 'Rank correlation methods'. Arnold.
Sneyers R (1990) 'On statistical analysis of series of observations. Technical  Note
No 143. Geneva. Switzerland. World Meteorological Society.
Schaber J (2003) 'Phenology in German in the 20th Century: Methods, analyses and models.
Ph.D. Thesis. University of Potsdam. Germany.
<a href="https://nbn-resolving.org/urn:nbn:de:kobv:517-0000532">https://nbn-resolving.org/urn:nbn:de:kobv:517-0000532</a>
</p>

<hr>
<h2 id='Simple'>Simple example of a two-way classification table</h2><span id='topic+Simple'></span>

<h3>Description</h3>

<p>Simple example of a two-way classification table
where missing data creates two distinct connected sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Simple)</code></pre>


<h3>Format</h3>

<p>R source file</p>

<hr>
<h2 id='tau'>Kendall's normalized tau</h2><span id='topic+tau'></span>

<h3>Description</h3>

<p>Kendall's normalized tau for time series x
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tau(x)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tau_+3A_x">x</code></td>
<td>
<p>Numeric vector x.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implicitly assumes a equidistant time series x. 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>t</code></td>
<td>
<p>Kendall's normalized tau.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joerg Schaber
</p>


<h3>References</h3>

<p>Kendall M, Gibbons JD (1990) 'Rank correlation methods'. Arnold.
Sneyers R (1990) 'On statistical analysis of series of observations. Technical  Note
No 143. Geneva. Switzerland. World Meteorological Society.
Schaber J (2003) 'Phenology in German in the 20th Century: Methods, analyses and models.
Ph.D. Thesis. University of Potsdam. Germany.
<a href="https://nbn-resolving.org/urn:nbn:de:kobv:517-0000532">https://nbn-resolving.org/urn:nbn:de:kobv:517-0000532</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
