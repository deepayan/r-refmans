<!DOCTYPE html><html><head><title>Help for package BAMBI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BAMBI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_burnin_thin'><p>Add (extra) burnin and thin to angmcmc object after original run</p></a></li>
<li><a href='#as.mcmc.list.angmcmc'><p>Create an mcmc.list object from an angmcmc object</p></a></li>
<li><a href='#BAMBI'><p><code>BAMBI</code>: An R package for Bivariate Angular Mixture Models</p></a></li>
<li><a href='#bestmodel'><p>Convenience function for extracting angmcmc object, and the value of the model</p>
selection criterion corresponding to the best fitted model in stepwise fits</a></li>
<li><a href='#bridge_sampler.angmcmc'><p>Log Marginal Likelihood via Bridge Sampling for angmcmc objects</p></a></li>
<li><a href='#circ_cor'><p>Sample circular correlation coefficients</p></a></li>
<li><a href='#circ_varcor_model'><p>Analytic circular variances and correlations for bivariate angular models</p></a></li>
<li><a href='#contour_model'><p>Contourplot for bivariate angular mixture model densities</p></a></li>
<li><a href='#contour.angmcmc'><p>Contour plot for angmcmc objects with bivariate data</p></a></li>
<li><a href='#d_fitted'><p>Density and random deviates from an angmcmc object</p></a></li>
<li><a href='#densityplot.angmcmc'><p>Density plots for angmcmc objects</p></a></li>
<li><a href='#DIC'><p>Deviance Information Criterion (DIC) for angmcmc objects</p></a></li>
<li><a href='#extractsamples'><p>Extract MCMC samples for parameters from an angmcmc object</p></a></li>
<li><a href='#fit_angmix'><p>Fitting Bivariate and univariate angular mixture models</p></a></li>
<li><a href='#fit_incremental_angmix'><p>Stepwise fitting of angular mixture models with incremental component sizes and optimum model selection</p></a></li>
<li><a href='#fit_vmcosmix'><p>Fitting bivariate von Mises cosine model mixtures using MCMC</p></a></li>
<li><a href='#fit_vmmix'><p>Fitting univariate von Mises mixtures using MCMC</p></a></li>
<li><a href='#fit_vmsinmix'><p>Fitting bivariate von Mises sine model mixtures using MCMC</p></a></li>
<li><a href='#fit_wnorm2mix'><p>Fitting bivariate wrapped normal model mixtures using MCMC</p></a></li>
<li><a href='#fit_wnormmix'><p>Fitting univariate wrapped normal mixtures using MCMC</p></a></li>
<li><a href='#fix_label'><p>Fix label switching in angmcmc objects</p></a></li>
<li><a href='#is.angmcmc'><p>Angular MCMC (<code>angmcmc</code>) Object</p></a></li>
<li><a href='#latent_allocation'><p>Finding latent allocation (component indicators) from an angmcmc object</p></a></li>
<li><a href='#logLik.angmcmc'><p>Extract Log-Likelihood from angmcmc objects</p></a></li>
<li><a href='#loo.angmcmc'><p>Leave-one-out cross-validation (LOO) for angmcmc objects</p></a></li>
<li><a href='#lpdtrace'><p>Trace and autocorrelation plots of log posterior density or log likelihood from an angmcmc object</p></a></li>
<li><a href='#paramtrace'><p>Trace plot for parameters from an angmcmc object</p></a></li>
<li><a href='#plot.angmcmc'><p>Summary plots for angmcmc objects</p></a></li>
<li><a href='#pointest'><p>Point estimates for parameters from an angmcmc object</p></a></li>
<li><a href='#quantile.angmcmc'><p>Quantile estimates for parameters from an angmcmc object</p></a></li>
<li><a href='#rvm'><p>The univariate von Mises distribution</p></a></li>
<li><a href='#rvmcos'><p>The bivariate von Mises cosine model</p></a></li>
<li><a href='#rvmcosmix'><p>The bivariate von Mises cosine model mixtures</p></a></li>
<li><a href='#rvmmix'><p>The univariate von Mises mixtures</p></a></li>
<li><a href='#rvmsin'><p>The bivariate von Mises sine model</p></a></li>
<li><a href='#rvmsinmix'><p>The bivariate von Mises sine model mixtures</p></a></li>
<li><a href='#rwnorm'><p>The univariate Wrapped Normal distribution</p></a></li>
<li><a href='#rwnorm2'><p>The bivariate Wrapped Normal distribution</p></a></li>
<li><a href='#rwnorm2mix'><p>The bivariate Wrapped Normal mixtures</p></a></li>
<li><a href='#rwnormmix'><p>The univariate Wrapped Normal mixtures</p></a></li>
<li><a href='#select_chains'><p>Select chains from angmcmc objects</p></a></li>
<li><a href='#summary.angmcmc'><p>Summary statistics for parameters from an angmcmc object</p></a></li>
<li><a href='#surface_model'><p>Surface for bivariate angular mixture model densities</p></a></li>
<li><a href='#tim8'><p>Backbone Dihedral Angles of Triose Phosphate Isomerase (8TIM)</p></a></li>
<li><a href='#vm2_mle'><p>Maximum likelihood estimation of bivariate von Mises parameters</p></a></li>
<li><a href='#waic.angmcmc'><p>Watanabe-Akaike Information Criterion (WAIC) for angmcmc objects</p></a></li>
<li><a href='#wind'><p>Saturna Island wind directions</p></a></li>
<li><a href='#zero_to_2pi'><p>Wrap angles into <code>[-pi, pi]</code> or <code>[0, 2*pi]</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bivariate Angular Mixture Models</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-08</td>
</tr>
<tr>
<td>Author:</td>
<td>Saptarshi Chakraborty,
        Samuel W.K. Wong</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Saptarshi Chakraborty &lt;chakra.saptarshi@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit (using Bayesian methods) and simulate mixtures of univariate and bivariate angular distributions. Chakraborty and Wong (2021) &lt;<a href="https://doi.org/10.18637%2Fjss.v099.i11">doi:10.18637/jss.v099.i11</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, stats4, graphics, lattice, grDevices, Rcpp, tcltk,
qrng, mvtnorm, gtools, parallel, label.switching, methods,
coda, future.apply, loo (&ge; 2.4.1), RColorBrewer,
bridgesampling, scales, numDeriv</td>
</tr>
<tr>
<td>Suggests:</td>
<td>future, gridExtra</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://doi.org/10.18637/jss.v099.i11">https://doi.org/10.18637/jss.v099.i11</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/c7rishi/BAMBI/issues">https://github.com/c7rishi/BAMBI/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-08 22:28:25 UTC; chakrab2</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-08 23:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_burnin_thin'>Add (extra) burnin and thin to angmcmc object after original run</h2><span id='topic+add_burnin_thin'></span>

<h3>Description</h3>

<p>Add (extra) burnin and thin to angmcmc object after original run
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_burnin_thin(object, burnin.prop = 0, thin = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_burnin_thin_+3A_object">object</code></td>
<td>
<p>angmcmc object</p>
</td></tr>
<tr><td><code id="add_burnin_thin_+3A_burnin.prop">burnin.prop</code></td>
<td>
<p>proportion of iterations to used for burnin. Must be a be a number in [0, 1].
Default is 0.5.</p>
</td></tr>
<tr><td><code id="add_burnin_thin_+3A_thin">thin</code></td>
<td>
<p>thining size to be used. Must be a positive integer. If <code>thin = </code> n, then every nth iteration is reatained
in the final MCMC sample.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># first fit a vmsin mixture model
# illustration only - more iterations needed for convergence
fit.vmsin.20 &lt;- fit_vmsinmix(tim8, ncomp = 3, n.iter =  20,
                             n.chains = 1)
lpdtrace(fit.vmsin.20)
# Now add extra burn-in
fit.vmsin.20.burn &lt;- add_burnin_thin(fit.vmsin.20, 0.3)
lpdtrace(fit.vmsin.20.burn)
</code></pre>

<hr>
<h2 id='as.mcmc.list.angmcmc'>Create an mcmc.list object from an angmcmc object</h2><span id='topic+as.mcmc.list.angmcmc'></span>

<h3>Description</h3>

<p>Create an mcmc.list object from an angmcmc object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'angmcmc'
as.mcmc.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.mcmc.list.angmcmc_+3A_x">x</code></td>
<td>
<p>angmcmc object</p>
</td></tr>
<tr><td><code id="as.mcmc.list.angmcmc_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># first fit a vmsin mixture model
# illustration only - more iterations needed for convergence
fit.vmsin.20 &lt;- fit_vmsinmix(tim8, ncomp = 3, n.iter =  20,
                             n.chains = 1)

# now convert it to mcmc.list
library(coda)
fit.vmsin.20.mcmc &lt;- as.mcmc.list(fit.vmsin.20)
</code></pre>

<hr>
<h2 id='BAMBI'><code>BAMBI</code>: An R package for Bivariate Angular Mixture Models</h2><span id='topic+BAMBI'></span>

<h3>Description</h3>

<p><code>BAMBI</code> is an R package that provides functions for fitting
(using Bayesian methods) and simulating mixtures of univariate
and bivariate angular distributions. Please see the reference for a
detailed description of the functionalities of <code>BAMBI</code>.
</p>


<h3>References</h3>

<p>Chakraborty, S., &amp; Wong, S. W. (2021). BAMBI: An R package for
fitting bivariate angular mixture models. <em>Journal of Statistical Software</em>,
99 (11), 1-69. <a href="https://doi.org/10.18637/jss.v099.i11">doi:10.18637/jss.v099.i11</a>
</p>

<hr>
<h2 id='bestmodel'>Convenience function for extracting angmcmc object, and the value of the model
selection criterion corresponding to the best fitted model in stepwise fits</h2><span id='topic+bestmodel'></span><span id='topic+bestcriterion'></span>

<h3>Description</h3>

<p>Convenience function for extracting angmcmc object, and the value of the model
selection criterion corresponding to the best fitted model in stepwise fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bestmodel(step_object)

bestcriterion(step_object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bestmodel_+3A_step_object">step_object</code></td>
<td>
<p>stepwise fitted object obtained from <a href="#topic+fit_incremental_angmix">fit_incremental_angmix</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are convenience functions; the best fitted model and the corresponding value of model selection criterion
can also be directly obtained by
extracting the elements <code>"fit.best"</code> and <code>"crit.best"</code> from <code>step_object</code> respectively.
Note that <code>bestcriterion</code> returns:
(a) a scalar number (class = <code>numeric</code>) if <code>crit</code>
used in original <code>fit_incremental_angmix</code> call is <code>'AIC'</code>, <code>'BIC'</code> or <code>'DIC'</code>,
(b) an element of class <code>bridge</code> from package <code>bridgesampling</code> if <code>crit</code> is
<code>LOGML</code>, (c) an element of class <code>c("waic", "loo")</code> if <code>crit = 'WAIC'</code>, and (d) an element of
class <code>c("psis_loo", "loo")</code> if <code>crit = "LOOIC"</code>. See documentations of these model
selection criteria for more details.
</p>


<h3>Value</h3>

<p><code>bestmodel</code> returns an <code>angmcmc</code> object, and
<code>bestcriterion</code> returns the  corresponding value of model selection criterion  for the best fitted model in <code>step_object</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># illustration only - more iterations needed for convergence
set.seed(1)
fit.vmsin.step.15 &lt;- fit_incremental_angmix("vmsin", tim8, start_ncomp = 1,
                                            max_ncomp = 3, n.iter = 15,
                                            n.chains = 1,
                                            crit = "WAIC")
fit.vmsin.best.15 &lt;- bestmodel(fit.vmsin.step.15)
fit.vmsin.best.15

crit.best &lt;- bestcriterion(fit.vmsin.step.15)
crit.best
</code></pre>

<hr>
<h2 id='bridge_sampler.angmcmc'>Log Marginal Likelihood via Bridge Sampling for angmcmc objects</h2><span id='topic+bridge_sampler.angmcmc'></span>

<h3>Description</h3>

<p>Log Marginal Likelihood via Bridge Sampling for angmcmc objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'angmcmc'
bridge_sampler(samples, ..., ave_over_chains = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bridge_sampler.angmcmc_+3A_samples">samples</code></td>
<td>
<p>angmcmc object</p>
</td></tr>
<tr><td><code id="bridge_sampler.angmcmc_+3A_...">...</code></td>
<td>
<p>additional argument passed to <a href="bridgesampling.html#topic+bridge_sampler">bridge_sampler</a>. Note that default for
the argument <code>method</code> is <code>"warp3"</code>, (instead of <code>"normal"</code> as used in <code>bridgesampling</code> package)
to account for multi-modality of the posterior density.</p>
</td></tr>
<tr><td><code id="bridge_sampler.angmcmc_+3A_ave_over_chains">ave_over_chains</code></td>
<td>
<p>logical. Separately call <a href="bridgesampling.html#topic+bridge_sampler">bridge_sampler</a> on
each chain in the angmcmc object and then take the average? Defaults to <code>TRUE</code>.
See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Marginal likelihood is calculated by first converting the <code>angmcmc</code> object <code>samples</code> to an
<code>mcmc.list</code> object, and then by passing the resulting <code>mcmc.list</code> object to <a href="bridgesampling.html#topic+bridge_sampler">bridge_sampler</a>.
If variablity across multiple chains (if any) are very different,
then calling <a href="bridgesampling.html#topic+bridge_sampler">bridge_sampler</a> separately for each chain
usually provides more stable results; the final log ML is computed by averaging over
chain specific MLs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(future)
library(parallel)
# plan(multisession, gc = TRUE) # parallelize chains

set.seed(100)
MC.fit &lt;- fit_angmix("vmsin", tim8, ncomp=3, n.iter=5000,
                     n.chains = 3)


library(bridgesampling)
bridge_sampler(MC.fit)


</code></pre>

<hr>
<h2 id='circ_cor'>Sample circular correlation coefficients</h2><span id='topic+circ_cor'></span>

<h3>Description</h3>

<p>Sample circular correlation coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circ_cor(
  x,
  type = "js",
  alternative = "two.sided",
  jackknife = FALSE,
  bootse = FALSE,
  n.boot = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circ_cor_+3A_x">x</code></td>
<td>
<p>two column matrix. NA values are not allowed.</p>
</td></tr>
<tr><td><code id="circ_cor_+3A_type">type</code></td>
<td>
<p>type of the circular correlation.
Must be one of &quot;fl&quot;, &quot;js&quot;, &quot;tau1&quot; and &quot;tau2&quot;. See details.</p>
</td></tr>
<tr><td><code id="circ_cor_+3A_alternative">alternative</code></td>
<td>
<p>one of <code>"two.sided"</code>, <code>"less"</code> or <code>"greater"</code>
(defaults to <code>"two.sided"</code>).
Hypothesis test is performed only when <code>type</code> is either <code>"fl"</code> or <code>"js"</code>,
in which case asymptotic standard error of the estimator is used to construct the test
statistic.</p>
</td></tr>
<tr><td><code id="circ_cor_+3A_jackknife">jackknife</code></td>
<td>
<p>logical. Compute jackknifed estimate and standard error? Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="circ_cor_+3A_bootse">bootse</code></td>
<td>
<p>logical. Compute bootstrap standard error? Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="circ_cor_+3A_n.boot">n.boot</code></td>
<td>
<p>number of bootstrapped samples to compute bootstrap standard error. Defaults to
100. Ignored if <code>bootse</code> if FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>circ_cor</code> calculates the (sample) circular correlation between the columns of x.
Two parametric (the Jammalamadaka-Sarma (1988, equation 2.6) form <code>"js"</code>, and
the Fisher-Lee (1983, Section 3) form <code>"fl"</code>)
and two non-parametric (two versions of Kendall's tau) correlation coefficients are considered.
The first version of Kendall's tau (<code>"tau1"</code>) is based on equation 2.1 in Fisher and Lee (1982),
whereas the second version (<code>"tau2"</code>) is computed using equations 6.7-6.8 in Zhan et al (2017).
</p>
<p>The cost-complexity for <code>"js"</code>, <code>"fl"</code>, <code>"tau2"</code> and <code>"tau1"</code> are <code class="reqn">O(n), O(n^2), O(n^2)</code> and <code class="reqn">O(n^3)</code>
respectively, where <code class="reqn">n</code> denotes the number of rows in <code>x</code>. As such, for large <code class="reqn">n</code> evaluation of
<code>"tau1"</code> will be slow.
</p>


<h3>References</h3>

<p>Fisher, N. I. and Lee, A. J. (1982). Nonparametric measures of angular-angular association. Biometrika, 69(2), 315-321.
</p>
<p>Fisher, N. I. and Lee, A. J. (1983). A correlation coefficient for circular data. Biometrika, 70(2):327-332.
</p>
<p>Jammalamadaka, S. R. and Sarma, Y. (1988). A correlation coefficient for
angular variables. Statistical theory and data analysis II, pages 349-364.
</p>
<p>Zhan, X., Ma, T., Liu, S., &amp; Shimizu, K. (2017). On circular correlation for data on the torus. Statistical Papers, 1-21.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate data from vmsin model
set.seed(1)
dat &lt;- rvmsin(100, 2,3,-0.8,0,0)

# now calculate circular correlation(s) between the 2 columns of dat
circ_cor(dat, type="js")
circ_cor(dat, type="fl")
circ_cor(dat, type="tau1")
circ_cor(dat, type="tau2")


</code></pre>

<hr>
<h2 id='circ_varcor_model'>Analytic circular variances and correlations for bivariate angular models</h2><span id='topic+circ_varcor_model'></span>

<h3>Description</h3>

<p>Analytic circular variances and correlations for bivariate angular models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circ_varcor_model(
  model = "vmsin",
  kappa1 = 1,
  kappa2 = 1,
  kappa3 = 0,
  mu1 = 0,
  mu2 = 0,
  nsim = 10000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circ_varcor_model_+3A_model">model</code></td>
<td>
<p>bivariate angular model. Must be one of <code>"vmsin"</code>,
<code>"vmcos"</code>, or <code>"wnorm2"</code>.</p>
</td></tr>
<tr><td><code id="circ_varcor_model_+3A_kappa1">kappa1</code>, <code id="circ_varcor_model_+3A_kappa2">kappa2</code>, <code id="circ_varcor_model_+3A_kappa3">kappa3</code></td>
<td>
<p>concentration and covariance parameters.
Recycled to the same size. kappa3^2 must be &lt; kappa1*kappa2 in the wnorm2 model
(see <a href="#topic+rwnorm2">rwnorm2</a> for a detailed parameterization of <code>wnorm2</code>).</p>
</td></tr>
<tr><td><code id="circ_varcor_model_+3A_mu1">mu1</code>, <code id="circ_varcor_model_+3A_mu2">mu2</code></td>
<td>
<p>mean parameters. Ignored as they do not play any role in
the analytical formulas.</p>
</td></tr>
<tr><td><code id="circ_varcor_model_+3A_nsim">nsim</code></td>
<td>
<p>Monte Carlo sample size. Ignored if all of <code>kappa1</code>, <code>kappa2</code>
and <code>abs(kappa3)</code> are &lt; 150 or if model = <code>"wnorm2"</code>.</p>
</td></tr>
<tr><td><code id="circ_varcor_model_+3A_...">...</code></td>
<td>
<p>additional model specific argment</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the analytic circular variances and correlations
(both Jammalamadaka-Sarma (JS) and Fisher-Lee (FL) forms) for von Mises sine,
von Mises cosine and bivariate wrapped normal distributions.
</p>
<p>For <code>wnorm2</code>, expressions for the circular variances,
JS and FL correlation coefficients can be found in Mardia and Jupp (2009),
Jammalamadaka and Sarma (1988) and Fisher and Lee (1983) respectively.
For <code>vmsin</code> and <code>vmcos</code> these expressions are provided in Chakraborty and Wong (2018).
</p>
<p>Because the analytic expressions in <code>vmsin</code> and <code>vmcos</code> models involve infinite sums
of product of Bessel functions,
if any of <code>kappa1</code>, <code>kappa2</code> and <code>abs(kappa3)</code> is larger
than or equal to 150, IID Monte Carlo with sample size <code>nsim</code> is used
to approximate <code>rho_js</code> for numerical stability.  From <code>rho_js</code>,
<code>rho_fl</code> is computed using Corollary 2.2 in
Chakraborty and Wong (2018), which makes cost-complexity for
the <code>rho_fl</code> evaluation to be of order  O(<code>nsim</code>) for <code>vmsin</code>
and <code>vmcos</code> models. (In general,  <code>rho_fl</code> evaluation
is of order O(<code>nsim</code>^2)).
</p>
<p>In addition, for the <code>vmcos</code> model, when <code>-150 &lt; kappa3 &lt; -1</code>
or <code>50 &lt; max(kappa1, kappa2, abs(kappa3)) &lt;= 150</code>, the analytic formulas
in Chakraborty and Wong (2018) are used; however, the reciprocal of the normalizing
constant and its partial derivatives are all calculated numerically via (quasi) Monte carlo method for
numerical stability. These (quasi) random numbers can be provided through the
argument <code>qrnd</code>, which must be a two column matrix, with each element being
a  (quasi) random number between 0 and 1. Alternatively, if <code>n_qrnd</code> is
provided (and <code>qrnd</code> is missing), a two dimensional sobol sequence of size <code>n_qrnd</code> is
generated via the function <a href="qrng.html#topic+sobol">sobol</a> from the R package <code>qrng</code>. If none of <code>qrnd</code>
or <code>n_qrnd</code> is available, a two dimensional sobol sequence of size 1e4 is used.
</p>


<h3>Value</h3>

<p>Returns a list with elements <code>var1</code>, <code>var2</code> (circular variances for the
first and second coordinates), <code>rho_fl</code> and <code>rho_js</code> (circular correlations).
See details.
</p>


<h3>References</h3>

<p>Fisher, N. I. and Lee, A. (1983). A correlation coefficient for circular data. Biometrika, 70(2):327-332.
</p>
<p>Jammalamadaka, S. R. and Sarma, Y. (1988). A correlation coefficient for
angular variables. Statistical theory and data analysis II, pages 349-364.
</p>
<p>Mardia, K. and Jupp, P. (2009). Directional Statistics. Wiley Series in Probability and Statistics. Wiley.
</p>
<p>Chakraborty, S. and Wong, S, W.K. (2018). On the circular correlation coefficients
for bivariate von Mises distributions on a torus. arXiv e-print.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>circ_varcor_model("vmsin", kappa1= 1, kappa2 = 2, kappa3 = 3)

# Monte Carlo approximation
set.seed(1)
dat &lt;- rvmsin(1000, 1, 2, 3)
# sample circular variance
circ_var &lt;- function(x)
  1 - mean(cos(x - atan2(mean(sin(x)), mean(cos(x))) ))
circ_var(dat[, 1])
circ_var(dat[, 2])
circ_cor(dat, "fl")
circ_cor(dat, "js")

</code></pre>

<hr>
<h2 id='contour_model'>Contourplot for bivariate angular mixture model densities</h2><span id='topic+contour_model'></span>

<h3>Description</h3>

<p>Contourplot for bivariate angular mixture model densities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contour_model(
  model = "vmsin",
  kappa1,
  kappa2,
  kappa3,
  mu1,
  mu2,
  pmix = rep(1/length(kappa1), length(kappa1)),
  xpoints = seq(0, 2 * pi, length.out = 100),
  ypoints = seq(0, 2 * pi, length.out = 100),
  levels,
  nlevels = 20,
  xlab = "x",
  ylab = "y",
  col = "black",
  lty = 1,
  main,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contour_model_+3A_model">model</code></td>
<td>
<p>bivariate angular model whose mixture is of interest. Must be one of
&quot;vmsin&quot;, &quot;vmcos&quot; and &quot;wnorm2&quot;.</p>
</td></tr>
<tr><td><code id="contour_model_+3A_kappa1">kappa1</code>, <code id="contour_model_+3A_kappa2">kappa2</code>, <code id="contour_model_+3A_kappa3">kappa3</code>, <code id="contour_model_+3A_mu1">mu1</code>, <code id="contour_model_+3A_mu2">mu2</code>, <code id="contour_model_+3A_pmix">pmix</code></td>
<td>
<p>model parameters and mixing
proportions. See the respective mixture model densities (<a href="#topic+dvmsinmix">dvmsinmix</a>, <a href="#topic+dvmcosmix">dvmcosmix</a>,
<a href="#topic+dwnorm2mix">dwnorm2mix</a>) for more details.</p>
</td></tr>
<tr><td><code id="contour_model_+3A_xpoints">xpoints</code></td>
<td>
<p>Points on the first (x-) coordinate where the density is to be evaluated.
Default to seq(0, 2*pi, length.out=100).</p>
</td></tr>
<tr><td><code id="contour_model_+3A_ypoints">ypoints</code></td>
<td>
<p>Points on the first (x-) coordinate where the density is to be evaluated.
Default to seq(0, 2*pi, length.out=100).</p>
</td></tr>
<tr><td><code id="contour_model_+3A_levels">levels</code></td>
<td>
<p>numeric vector of levels at which to draw contour lines;
passed to the <a href="graphics.html#topic+contour">contour</a> function in graphics.</p>
</td></tr>
<tr><td><code id="contour_model_+3A_nlevels">nlevels</code></td>
<td>
<p>number of contour levels desired <strong>if</strong> levels is not supplied;
passed to the <a href="graphics.html#topic+contour">contour</a> function in graphics.</p>
</td></tr>
<tr><td><code id="contour_model_+3A_xlab">xlab</code>, <code id="contour_model_+3A_ylab">ylab</code>, <code id="contour_model_+3A_col">col</code>, <code id="contour_model_+3A_lty">lty</code>, <code id="contour_model_+3A_main">main</code></td>
<td>
<p>graphical parameters passed to <a href="graphics.html#topic+contour">contour</a>.</p>
</td></tr>
<tr><td><code id="contour_model_+3A_...">...</code></td>
<td>
<p>additional model specific argment</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>contour_model('vmsin', 1, 1, 1.5, pi, pi)
contour_model('vmcos', 1, 1, 1.5, pi, pi)


</code></pre>

<hr>
<h2 id='contour.angmcmc'>Contour plot for angmcmc objects with bivariate data</h2><span id='topic+contour.angmcmc'></span>

<h3>Description</h3>

<p>Contour plot for angmcmc objects with bivariate data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'angmcmc'
contour(
  x,
  fn = "MAP",
  type = "point-est",
  show.data = TRUE,
  xpoints = seq(0, 2 * pi, length.out = 100),
  ypoints = seq(0, 2 * pi, length.out = 100),
  levels,
  nlevels = 20,
  cex = 1,
  col = "red",
  alpha = 0.4,
  pch = 19,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contour.angmcmc_+3A_x">x</code></td>
<td>
<p>angular MCMC object (with bivariate data).</p>
</td></tr>
<tr><td><code id="contour.angmcmc_+3A_fn">fn</code></td>
<td>
<p>function, or a single character string specifying its name, to evaluate on MCMC samples to estimate
parameters.  Defaults to <code>mean</code>, which computes the estimated posterior mean.
Note that if <code>fn = "MODE"</code> (warning: not <code>"mode"</code>) or <code>fn = "MAP"</code>, then the maximum aposteriori estimate (MAP) is
calculated.</p>
</td></tr>
<tr><td><code id="contour.angmcmc_+3A_type">type</code></td>
<td>
<p>Passed to <a href="#topic+d_fitted">d_fitted</a>. Possible choices are &quot;point-est&quot; and &quot;post-pred&quot;.</p>
</td></tr>
<tr><td><code id="contour.angmcmc_+3A_show.data">show.data</code></td>
<td>
<p>logical. Should the data points be added to the contour plot? Ignored if <code>object</code> is NOT supplied.</p>
</td></tr>
<tr><td><code id="contour.angmcmc_+3A_xpoints">xpoints</code></td>
<td>
<p>Points on the first (x-) coordinate where the density is to be evaluated.
Default to seq(0, 2*pi, length.out=100).</p>
</td></tr>
<tr><td><code id="contour.angmcmc_+3A_ypoints">ypoints</code></td>
<td>
<p>Points on the first (x-) coordinate where the density is to be evaluated.
Default to seq(0, 2*pi, length.out=100).</p>
</td></tr>
<tr><td><code id="contour.angmcmc_+3A_levels">levels</code></td>
<td>
<p>numeric vector of levels at which to draw contour lines;
passed to the <a href="graphics.html#topic+contour">contour</a> function in graphics.</p>
</td></tr>
<tr><td><code id="contour.angmcmc_+3A_nlevels">nlevels</code></td>
<td>
<p>number of contour levels desired <strong>if</strong> levels is not supplied;
passed to the <a href="graphics.html#topic+contour">contour</a> function in graphics.</p>
</td></tr>
<tr><td><code id="contour.angmcmc_+3A_cex">cex</code>, <code id="contour.angmcmc_+3A_col">col</code>, <code id="contour.angmcmc_+3A_pch">pch</code></td>
<td>
<p>graphical parameters passed to <code><a href="graphics.html#topic+points">points</a></code> from graphics for plotting the data points.
Ignored if show.data == FALSE.</p>
</td></tr>
<tr><td><code id="contour.angmcmc_+3A_alpha">alpha</code></td>
<td>
<p>color transparency for the data points, implemented via <code><a href="scales.html#topic+alpha">alpha</a></code> from package <code>scales</code>.
Ignored if show.data == FALSE.</p>
</td></tr>
<tr><td><code id="contour.angmcmc_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the function <code><a href="graphics.html#topic+contour">contour</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>contour.angmcmc</code> is an S3 function for angmcmc objects that calls <code><a href="graphics.html#topic+contour">contour</a></code> from graphics.
</p>
<p>To estimate the mixture density required to construct the contour plot, first the parameter vector <code class="reqn">\eta</code> is estimated
by applying <code>fn</code> on the MCMC samples, yielding the (consistent) Bayes estimate <code class="reqn">\hat{\eta}</code>. Then the mixture density
<code class="reqn">f(x|\eta)</code> at any point <code class="reqn">x</code> is (consistently) estimated by <code class="reqn">f(x|\hat{\eta})</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first fit a vmsin mixture model
# illustration only - more iterations needed for convergence
fit.vmsin.20 &lt;- fit_vmsinmix(tim8, ncomp = 3, n.iter =  20,
                             n.chains = 1)
# now create a contour plot
contour(fit.vmsin.20)

</code></pre>

<hr>
<h2 id='d_fitted'>Density and random deviates from an angmcmc object</h2><span id='topic+d_fitted'></span><span id='topic+r_fitted'></span>

<h3>Description</h3>

<p>Density and random deviates from an angmcmc object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d_fitted(x, object, type = "point-est", fn = mean, log = FALSE, chain.no, ...)

r_fitted(n = 1, object, type = "point-est", fn = mean, chain.no, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d_fitted_+3A_x">x</code></td>
<td>
<p>vector, if univariate or a two column matrix, if bivariate, with each row a 2-D vector, (can
also be a data frame of similar dimensions) of points where the
densities are to be computed.</p>
</td></tr>
<tr><td><code id="d_fitted_+3A_object">object</code></td>
<td>
<p>angular MCMC object. The dimension of the model must match with <code>x</code>.</p>
</td></tr>
<tr><td><code id="d_fitted_+3A_type">type</code></td>
<td>
<p>Method of estimating density/generating random deviates. Possible choices are
<code>"post-pred"</code> and <code>"point-est"</code>. See details. Defaults to <code>"point-est"</code>.</p>
</td></tr>
<tr><td><code id="d_fitted_+3A_fn">fn</code></td>
<td>
<p>function, or a single character string specifying its name, to evaluate on MCMC samples to estimate
parameters.  Defaults to <code>mean</code>, which computes the estimated posterior mean.
Note that if <code>fn = "MODE"</code> (warning: not <code>"mode"</code>) or <code>fn = "MAP"</code>, then the maximum aposteriori estimate (MAP) is
calculated.</p>
</td></tr>
<tr><td><code id="d_fitted_+3A_log">log</code></td>
<td>
<p>logical. Should the log density be returned instead?</p>
</td></tr>
<tr><td><code id="d_fitted_+3A_chain.no">chain.no</code></td>
<td>
<p>vector of chain numbers whose samples are to be be used.
in the estimation. By default all chains are used.</p>
</td></tr>
<tr><td><code id="d_fitted_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the function.</p>
</td></tr>
<tr><td><code id="d_fitted_+3A_n">n</code></td>
<td>
<p>number of observations to be generated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>type = 'point-est'</code>, density is evaluated/random samples are generated at a point estimate of
the parameter values.  To estimate the mixture density, first the parameter vector <code class="reqn">\eta</code> is estimated
by applying <code>fn</code> on the MCMC samples (using the function <a href="#topic+pointest">pointest</a>), yielding the (consistent) Bayes estimate <code class="reqn">\hat{\eta}</code>.
Then the mixture density <code class="reqn">f(x|\eta)</code> at any point <code class="reqn">x</code> is (consistently) estimated by
<code class="reqn">f(x|\hat{\eta})</code>. The random deviates are generated from the estimated mixture density <code class="reqn">f(x|\hat{\eta})</code>.
</p>
<p>If <code>type == 'post-pred'</code>, posterior predictive samples and densities are returned. That
is, the average density <code class="reqn">S^{-1} \sum_{s = 1}^S f(x | \eta_s)</code> is returned in <code>d_fitted</code>,
where <code class="reqn">\eta_1, \dots, \eta_S</code> is the set posterior MCMC samples obtained from <code>object</code>. In
<code>r_fitted</code>, first a random sub-sample <code class="reqn">\eta_{(1)}, \dots, \eta_{(n)}</code> of size <code>n</code> from the
set of posterior samples <code class="reqn">\eta_1, \dots, \eta_S</code> is drawn (with replacement if <code>n</code> &gt; S). Then
the i-th posterior predictive data point is generated from the mixture density
<code class="reqn">f(x|\eta_{(i)})</code> for i = 1,..., n.
</p>


<h3>Value</h3>

<p><code>d_fitted</code> gives a vector the densities computed at the given points  and <code>r_fitted</code>
creates a vector (if univariate) or a matrix (if bivariate) with each row being a 2-D point, of random deviates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
# illustration only - more iterations needed for convergence
fit.vmsin.20 &lt;- fit_vmsinmix(tim8, ncomp = 3, n.iter =  20,
                             n.chains = 1)
d_fitted(c(0,0), fit.vmsin.20, type = "post-pred")
d_fitted(c(0,0), fit.vmsin.20, type = "point-est")

r_fitted(10, fit.vmsin.20, type = "post-pred")
r_fitted(10, fit.vmsin.20, type = "point-est")
</code></pre>

<hr>
<h2 id='densityplot.angmcmc'>Density plots for angmcmc objects</h2><span id='topic+densityplot.angmcmc'></span>

<h3>Description</h3>

<p>Plot fitted angular mixture model density surfaces or curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'angmcmc'
densityplot(
  x,
  data = NULL,
  fn = mean,
  type = "point-est",
  log.density = FALSE,
  xpoints = seq(0, 2 * pi, length.out = 35),
  ypoints = seq(0, 2 * pi, length.out = 35),
  plot = TRUE,
  show.hist = ifelse(log.density, FALSE, TRUE),
  xlab,
  ylab,
  zlab = ifelse(log.density, "Log Density", "Density"),
  main,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densityplot.angmcmc_+3A_x">x</code></td>
<td>
<p>angmcmc object.</p>
</td></tr>
<tr><td><code id="densityplot.angmcmc_+3A_data">data</code></td>
<td>
<p>unused. The parameter is already filled with results from fitted angular model. It is kept
to ensure compatibility with the lattice S3 generic <code>densityplot</code>.</p>
</td></tr>
<tr><td><code id="densityplot.angmcmc_+3A_fn">fn</code></td>
<td>
<p>function, or a single character string specifying its name, to evaluate on MCMC samples to estimate
parameters.  Defaults to <code>mean</code>, which computes the estimated posterior mean.
Note that if <code>fn = "MODE"</code> (warning: not <code>"mode"</code>) or <code>fn = "MAP"</code>, then the maximum aposteriori estimate (MAP) is
calculated.</p>
</td></tr>
<tr><td><code id="densityplot.angmcmc_+3A_type">type</code></td>
<td>
<p>Passed to <a href="#topic+d_fitted">d_fitted</a>. Possible choices are &quot;point-est&quot; and &quot;post-pred&quot;.</p>
</td></tr>
<tr><td><code id="densityplot.angmcmc_+3A_log.density">log.density</code></td>
<td>
<p>logical. Should log density be used for the plot?</p>
</td></tr>
<tr><td><code id="densityplot.angmcmc_+3A_xpoints">xpoints</code>, <code id="densityplot.angmcmc_+3A_ypoints">ypoints</code></td>
<td>
<p>Points on the  x and y coordinates (if bivariate) or only x coordinate
(if univariate) where the density is to be evaluated. Each defaults to seq(0, 2*pi, length.out=100).</p>
</td></tr>
<tr><td><code id="densityplot.angmcmc_+3A_plot">plot</code></td>
<td>
<p>logical. Should the density surface (if the fitted data is bivariate) or the density
curve (if univariate) be plotted?</p>
</td></tr>
<tr><td><code id="densityplot.angmcmc_+3A_show.hist">show.hist</code></td>
<td>
<p>logical. Should a histogram for the data
points be added to the plot, if the fitted data is univariate? Ignored if data is
bivariate.</p>
</td></tr>
<tr><td><code id="densityplot.angmcmc_+3A_xlab">xlab</code>, <code id="densityplot.angmcmc_+3A_ylab">ylab</code>, <code id="densityplot.angmcmc_+3A_zlab">zlab</code>, <code id="densityplot.angmcmc_+3A_main">main</code></td>
<td>
<p>graphical parameters passed to <code>lattice::wireframe</code> (if
bivariate) or <a href="graphics.html#topic+plot">plot</a> (if univariate). If the data is univariate, <code>zlab</code> and <code>ylab</code> can be
used interchangeably (both correspond to the density).</p>
</td></tr>
<tr><td><code id="densityplot.angmcmc_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>lattice::wireframe</code> if
fitted data is bivariate, or to <a href="graphics.html#topic+hist">hist</a> (if (<code>show.hist == TRUE</code>)), if the fitted data is univariate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>plot==TRUE</code>, <code>densityplot.angmcmc</code> calls <code>lattice::wireframe</code> or
<a href="graphics.html#topic+plot">plot</a> from graphics to draw the surface or curve.
</p>
<p>To estimate the mixture density, first the parameter vector <code class="reqn">\eta</code> is estimated
by applying <code>fn</code> on the MCMC samples, yielding the (consistent) Bayes estimate <code class="reqn">\hat{\eta}</code>. Then the mixture density
<code class="reqn">f(x|\eta)</code> at any point <code class="reqn">x</code> is (consistently) estimated by <code class="reqn">f(x|\hat{\eta})</code>.
</p>
<p>Note that <code>densityplot.angmcmc</code> <strong>does not</strong> plot the kernel densitie estimates
of the MCMC parameters. (These plots can be obtained by first converting an <code>angmcmc</code>
object to an <code>mcmc</code> object via <a href="coda.html#topic+as.mcmc.list">as.mcmc.list</a>, and then
by using <code>densplot</code> from package coda on the resulting <code>mcmc.list</code> object. Instead,
<code>densityplot.angmcmc</code> returns the surface (if 2-D) or the curve (if 1-D)
of the fitted model density evaluated at the estimated parameter vector (obtain through <a href="#topic+pointest">pointest</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first fit a vmsin mixture model
# illustration only - more iterations needed for convergence
fit.vmsin.20 &lt;- fit_vmsinmix(tim8, ncomp = 3, n.iter =  20,
                             n.chains = 1)
# now create density surface with the default first 1/3 as burn-in and thin = 1
library(lattice)
densityplot(fit.vmsin.20)
# the viewing angles can be changed through the argument 'screen'
# (passed to lattice::wireframe)
densityplot(fit.vmsin.20, screen = list(z=-30, x=-60))
densityplot(fit.vmsin.20, screen = list(z=30, x=-60))
# the colors can be changed through 'col.regions'
cols &lt;- grDevices::colorRampPalette(c("blue", "green",
                                      "yellow", "orange", "red"))(100)
densityplot(fit.vmsin.20, col.regions = cols)

# Now fit a vm mixture model
# illustration only - more iterations needed for convergence
fit.vm.20 &lt;- fit_vmmix(wind$angle, ncomp = 3, n.iter =  20,
                             n.chains = 1)
densityplot(fit.vm.20)

</code></pre>

<hr>
<h2 id='DIC'>Deviance Information Criterion (DIC) for angmcmc objects</h2><span id='topic+DIC'></span>

<h3>Description</h3>

<p>Deviance Information Criterion (DIC) for angmcmc objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DIC(object, form = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DIC_+3A_object">object</code></td>
<td>
<p>angular MCMC object.</p>
</td></tr>
<tr><td><code id="DIC_+3A_form">form</code></td>
<td>
<p>form of DIC to use. Available choices are 1 and 2 (default). See details.</p>
</td></tr>
<tr><td><code id="DIC_+3A_...">...</code></td>
<td>
<p>additional model specific arguments to be passed to <code>DIC</code>. For example, <code>int.displ</code>
specifies integer dispacement in wnorm and wnorm2 models. See <a href="#topic+fit_wnormmix">fit_wnormmix</a> and
<a href="#topic+fit_wnorm2mix">fit_wnorm2mix</a> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a deviance function <code class="reqn">D(\theta) = -2 log(p(y|\theta))</code>, and an estimate
<code class="reqn">\theta* = (\sum \theta_i) / N</code> of the posterior mean
<code class="reqn">E(\theta|y)</code>, where <code class="reqn">y</code> denote the data, <code class="reqn">\theta</code> are the unknown
parameters of the model, <code class="reqn">\theta_1, ..., \theta_N</code> are MCMC samples from the posterior
distribution of <code class="reqn">\theta</code> given <code class="reqn">y</code> and <code class="reqn">p(y|\theta)</code> is the likelihood function,
the (form 1 of) Deviance Infomation Criterion (DIC) is defined as
</p>
<p style="text-align: center;"><code class="reqn">DIC = 2 ( (\sum_{s=1}^N D(\theta_s)) / N - D(\theta*) )</code>
</p>

<p>The second form for DIC is given by
</p>
<p style="text-align: center;"><code class="reqn">DIC = D(\theta*) - 4 \hat{var} \log p(y|\theta_s)</code>
</p>

<p>where for <code class="reqn">i = 1, ..., n</code>, <code class="reqn">\hat{var} \log p(y|\theta)</code> denotes the estimated variance
of the log likelihood based on the realizations <code class="reqn">\theta_1, ..., \theta_N</code>.
</p>
<p>Like AIC and BIC, DIC is an asymptotic approximation for large samples, and
is only valid when the posterior distribution is approximately normal.
</p>


<h3>Value</h3>

<p>Computes the DIC for a given angmcmc object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># illustration only - more iterations needed for convergence
fit.vmsin.20 &lt;- fit_vmsinmix(tim8, ncomp = 3, n.iter =  20,
                             n.chains = 1)
DIC(fit.vmsin.20)

</code></pre>

<hr>
<h2 id='extractsamples'>Extract MCMC samples for parameters from an angmcmc object</h2><span id='topic+extractsamples'></span>

<h3>Description</h3>

<p>Extract MCMC samples for parameters from an angmcmc object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractsamples(object, par.name, comp.label, chain.no, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractsamples_+3A_object">object</code></td>
<td>
<p>angular MCMC object</p>
</td></tr>
<tr><td><code id="extractsamples_+3A_par.name">par.name</code></td>
<td>
<p>vector of names of parameters for which point estimates are to be computed.  If <code>NULL</code>, results for all parameters are provided.</p>
</td></tr>
<tr><td><code id="extractsamples_+3A_comp.label">comp.label</code></td>
<td>
<p>vector of component labels (positive integers, e.g., <code>1, 2, ...</code>) for which point estimates are to be computed.
If <code>NULL</code>, results for all components are provided.</p>
</td></tr>
<tr><td><code id="extractsamples_+3A_chain.no">chain.no</code></td>
<td>
<p>vector of chain numbers whose samples are to be be used.
in the estimation. By default all chains are used.</p>
</td></tr>
<tr><td><code id="extractsamples_+3A_drop">drop</code></td>
<td>
<p>logical. Should the dimension of the output be dropped, if <code>par.name</code>,
<code>comp.label</code> or <code>chain.no</code> has a single level?</p>
</td></tr>
<tr><td><code id="extractsamples_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default for both <code>par.name</code> and <code>comp.label</code> are the all possible choices
available in <code>object</code>.
</p>


<h3>Value</h3>

<p>Returns  a four dimensional array with
</p>
<p>dimension 1 - model parameters and mixing proportions
dimention 2 - components
dimension 3 - MCMC iterations
dimension 4 - chain number
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first fit a vmsin mixture model
# illustration only - more iterations needed for convergence
fit.vmsin.20 &lt;- fit_vmsinmix(tim8, ncomp = 3, n.iter =  20,
                             n.chains = 1)
# extract Markov chain realizations for kappa1 from component 1
extr_kappa1_1 &lt;- extractsamples(fit.vmsin.20, "kappa1", 1)
# for kappa1 from component from all components
extr_kappa1 &lt;- extractsamples(fit.vmsin.20, "kappa1")
# for all parameters in component 1
extr_1 &lt;- extractsamples(fit.vmsin.20, comp.label = 1)

</code></pre>

<hr>
<h2 id='fit_angmix'>Fitting Bivariate and univariate angular mixture models</h2><span id='topic+fit_angmix'></span>

<h3>Description</h3>

<p>Fitting Bivariate and univariate angular mixture models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_angmix(
  model = "vmsin",
  data,
  ncomp,
  cov.restrict = "NONE",
  unimodal.component = FALSE,
  start_par = NULL,
  rand_start = rep(FALSE, n.chains),
  method = "hmc",
  perm_sampling = FALSE,
  n.chains = 3,
  chains_parallel = TRUE,
  return_llik_contri = FALSE,
  int.displ = 3,
  epsilon = 0.1,
  L = 10,
  epsilon.random = TRUE,
  L.random = FALSE,
  burnin.prop = 0.5,
  tune.prop = 1,
  thin = 1,
  propscale = 0.05,
  n.iter = 500,
  pmix.alpha = NULL,
  norm.var = 1000,
  autotune = TRUE,
  show.progress = TRUE,
  accpt.prob.upper,
  accpt.prob.lower,
  epsilon.incr = 0.05,
  L.incr = 0.075,
  tune.incr = 0.05,
  tune_ave_size = 100,
  kappa_upper = 150,
  kappa_lower = 1e-04,
  return_tune_param = FALSE,
  qrnd = NULL,
  n_qrnd = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_angmix_+3A_model">model</code></td>
<td>
<p>angular model whose mixtures are to be fitted. Available choices are <code>"vmsin", "vmcos"</code> and <code>"wnorm2"</code> for
bivariate data, and <code>"vm"</code> and <code>"wnorm"</code> for univariate data.</p>
</td></tr>
<tr><td><code id="fit_angmix_+3A_data">data</code></td>
<td>
<p>data matrix (if bivarate, in which case it must have two columns) or vector. If outside, the values
are transformed into the scale <code class="reqn">[0, 2\pi)</code>. *Note:* BAMBI cannot handle missing data. Missing values must
either be removed or properly imputed.</p>
</td></tr>
<tr><td><code id="fit_angmix_+3A_ncomp">ncomp</code></td>
<td>
<p>number of components in the mixture model. Must be a positive integer. vector values are not allowed.
If <code>comp == 1</code>, a single component model is fitted.</p>
</td></tr>
<tr><td><code id="fit_angmix_+3A_cov.restrict">cov.restrict</code></td>
<td>
<p>Should there be any restriction on the covariance parameter for a bivariate model. Available choices are
<code>"POSITIVE", "NEGATIVE", "ZERO"</code> and &quot;NONE&quot;. Note that <code>"ZERO"</code> fits a mixture with product components. Defaults to
<code>"NONE"</code>.</p>
</td></tr>
<tr><td><code id="fit_angmix_+3A_unimodal.component">unimodal.component</code></td>
<td>
<p>logical. Should each component in the mixture model be unimodal? Only used if <code>model</code> is either <code>"vmsin"</code>
or <code>"vmcos"</code>. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="fit_angmix_+3A_start_par">start_par</code></td>
<td>
<p>list with elements <code>pmix</code> (ignored if <code>comp == 1</code>), together with <code>kappa1, kappa2, mu1</code> and <code>mu2</code>,
for bivariate models, and <code>kappa</code> and <code>mu</code> for univariate models,
all being vectors of length same as <code>ncomp</code>.
These provides the starting values for the Markov chain; with <code class="reqn">j</code>-th component of each vector corresponding to the <code class="reqn">j</code>-th
component of the mixture distribution. If missing, the data is first clustered into <code>ncomp</code> groups either via k-means (after
projecting onto a unit sphere), or randomly, depending on <code>rand_start</code>,  and then moment estimators for components are used as
the starting points. Note that a very wrong starting point can potentially lead the chain to get stuck at a wrong solution for thousands
of iterations. As such, we recommend using the default option, which is k-means followed by moment estimation.</p>
</td></tr>
<tr><td><code id="fit_angmix_+3A_rand_start">rand_start</code></td>
<td>
<p>logical. Should a random starting clustering be used? Must be either a scalar, or a vector of length <code>ncomp</code>,
one for each chain. Ignored if <code>start_par</code> is supplied. See <code>start_par</code> for more details. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fit_angmix_+3A_method">method</code></td>
<td>
<p>MCMC strategy to be used for the model paramters:  <code>"hmc"</code> or <code>"rwmh"</code>.</p>
</td></tr>
<tr><td><code id="fit_angmix_+3A_perm_sampling">perm_sampling</code></td>
<td>
<p>logical. Should the permutation sampling algorithm of Fruhwirth-Schnatter (2001) be used?
If TRUE, at every iteration after burnin, once model parameters and mixing proportions are sampled,
a random permutation of 1, ..., ncomp is considered, and components are relabelled according
to this random permutation. This forced random label switchings may imporve the mixing rate of the chage. However, (automated) tuning
is very difficult with such a scheme, as there is no simple way of keeping track of the &quot;original&quot; component labels. This creates problem
with computing standard deviations of the generated model parameters, thus making the
scaling step used in tuning for <code>epsilon</code> or <code>paramscale</code> problematic as well. As such, <code>perm_sampling</code> is always turned
off during burn-in (even if <code>autotune = FALSE</code>), and turned on thereafter, if <code>TRUE</code>.
Defaults to and is set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fit_angmix_+3A_n.chains">n.chains</code></td>
<td>
<p>number of chains to run. Must be a positive integer.</p>
</td></tr>
<tr><td><code id="fit_angmix_+3A_chains_parallel">chains_parallel</code></td>
<td>
<p>logical. Should the chains be run in parallel? Defaluts to TRUE, and ignored if <code>n.chains</code> = 1.
Note that parallelization is implemented via <a href="future.apply.html#topic+future_lapply">future_lapply</a> from package <code>future.apply</code> which
uses futures for this purpose, and thus provides a convenient way of parallelization across various OSs and computing environments.
However, a proper <a href="future.html#topic+plan">plan</a> must be set for the parallization before running the chain. Otherwise the chains will run sequentially.</p>
</td></tr>
<tr><td><code id="fit_angmix_+3A_return_llik_contri">return_llik_contri</code></td>
<td>
<p>logical. Should the log likelihood contribution of each data point for each MCMC iteration in each chain be returned? This makes
computation of <a href="#topic+waic.angmcmc">waic.angmcmc</a> and <a href="#topic+loo.angmcmc">loo.angmcmc</a> much faster. *Warning*: Depending on the length of data and <code>n.iter</code>, this can be
very memory intensive. We suggest setting <code>return_llik_contri = TRUE</code> only if <a href="#topic+waic.angmcmc">waic.angmcmc</a> and <a href="#topic+loo.angmcmc">loo.angmcmc</a> are aimed for. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fit_angmix_+3A_int.displ">int.displ</code></td>
<td>
<p>absolute integer displacement for each coordinate for <code>wnorm</code> and <code>wnorm2</code> models (ignored otherwise). Default is 3.
Allowed minimum and maximum are 1 and 5 respectively.</p>
</td></tr>
<tr><td><code id="fit_angmix_+3A_epsilon">epsilon</code>, <code id="fit_angmix_+3A_l">L</code></td>
<td>
<p>tuning parameters for HMC; ignored if <code>method = "rwmh"</code>. <code>epsilon</code> (step-size) is a single number,
or a vector of size <code>2*ncomp</code> for univariate models and <code>5*ncomp</code> for bivariate models. Note that the &quot;mass matrix&quot;
in HMC is assumed to be identity. As such, <code>epsilon</code>'s corresponding to different model parameters need to be in proper scale for
optimal acceptance rate. Can be autotuned during burnin. See <code>autotune</code>.
<code>L</code> (leapfrog steps) is a positive integer or a vector of positive integers of length <code>n.chains</code>.
If multiple chains are used, we suggest same <code>L</code> values acorss different chains to make the chains as homogenous as possible.</p>
</td></tr>
<tr><td><code id="fit_angmix_+3A_epsilon.random">epsilon.random</code></td>
<td>
<p>logical. Should <code>epsilon*delta</code>, where <code>delta</code> is a random
number between <code>(1-epsilon.incr, 1+epsilon.incr)</code> be used instead of <code>epsilon</code> at each iteration?
Ignored if <code>method = "rwmh"</code>.</p>
</td></tr>
<tr><td><code id="fit_angmix_+3A_l.random">L.random</code></td>
<td>
<p>logical. Should a random integer between <code>L.orig/exp(L.incr)</code> and <code>L.orig*exp(L.incr)</code>be used instead as <code>L</code>
at each iteration? Ignored if <code>method = "rwmh"</code>. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fit_angmix_+3A_burnin.prop">burnin.prop</code></td>
<td>
<p>proportion of iterations to used for burnin. Must be a be a number in [0, 1].
Default is 0.5.</p>
</td></tr>
<tr><td><code id="fit_angmix_+3A_tune.prop">tune.prop</code></td>
<td>
<p>proportion of *<code>burnin</code>* used to tune the parameters (<code>epsilon</code> in HMC and
<code>propscale</code> in RWMH). Must be a number between 0 and 1; defaults to 1.  Ignored if <code>autotune == FALSE</code>.</p>
</td></tr>
<tr><td><code id="fit_angmix_+3A_thin">thin</code></td>
<td>
<p>thining size to be used. Must be a positive integer. If <code>thin = </code> n, then every nth iteration is reatained
in the final MCMC sample.</p>
</td></tr>
<tr><td><code id="fit_angmix_+3A_propscale">propscale</code></td>
<td>
<p>tuning parameters for RWMH; a vector of size 5 (for bivariate models) or 2 (for univariate models) representing
the variances for the proposal normal densities
for the model parameters. Ignored if <code>method = "hmc"</code>. Can be autotuned during burnin. See <code>autotune</code>.</p>
</td></tr>
<tr><td><code id="fit_angmix_+3A_n.iter">n.iter</code></td>
<td>
<p>number of iterations for the Markov Chain.</p>
</td></tr>
<tr><td><code id="fit_angmix_+3A_pmix.alpha">pmix.alpha</code></td>
<td>
<p>concentration parameter(s) for the Dirichlet prior for <code>pmix</code>. Must either be a positive real number, or a vector
with positive entries and of length <code>ncomp</code>. The default is <code class="reqn">(r+r(r+1)/2)/2+3</code>, where <code class="reqn">r</code> is 1 or 2 according as whether
the model is univariate or bivariate. Note that it is recommended to use larger <code>alpha</code> values to ensure the a good posterior behavior,
especially when <a href="#topic+fit_incremental_angmix">fit_incremental_angmix</a> is used for model selection, which handles overfitting in &quot;let two component-specific parameters be
size, and then penalizes for model complexity. See Fruhwirth-Schnatter (2011) for more details on this.</p>
</td></tr>
<tr><td><code id="fit_angmix_+3A_norm.var">norm.var</code></td>
<td>
<p>variance (hyper-) parameters in the normal prior for <code>log(kappa), log(kappa1), log(kappa2)</code> and <code>kappa3</code>. (Prior mean is zero).
Can be a vector. Default is 1000 that makes the prior non-informative.</p>
</td></tr>
<tr><td><code id="fit_angmix_+3A_autotune">autotune</code></td>
<td>
<p>logical. Should the Markov chain auto-tune the parameter <code>epsilon</code> (in HMC) or
<code>propscale</code> (in RWMH) during burn-in?  Set to <code>TRUE</code> by default. An adaptive tuning strategy is implemented.
Here, at every 10th iteration during in burn-in, the acceptance ratio in the last <code>tune_ave_size</code>
iterations is calculated. Then the tuning parameter is decreased  (increased) by a factor of
<code>1-tune.incr</code> (<code>1+tune.incr</code>) if the calculated acceptance rate
falls below (above) <code>accpt.prob.lower</code> (<code>accpt.prob.upper</code>). In addditon, when <code>iter</code> is a multiple of
<code>tune_ave_size</code>, <code>epsilon</code> for each model parameter is rescaled via the standard deviation of
the corresponding parameter over the past <code>tune_ave_size</code> iterations.</p>
</td></tr>
<tr><td><code id="fit_angmix_+3A_show.progress">show.progress</code></td>
<td>
<p>logical. Should a progress bar be displayed?</p>
</td></tr>
<tr><td><code id="fit_angmix_+3A_accpt.prob.lower">accpt.prob.lower</code>, <code id="fit_angmix_+3A_accpt.prob.upper">accpt.prob.upper</code></td>
<td>
<p>lower and upper limits of acceptance ratio to be maintained while tuning
during burn-in. Must be numbers between 0 and 1, which <code>accpt.prob.lower &lt; accpt.prob.upper</code>. See <code>autotune</code>. Default to (0.6, 0,9) for HMC and  (0.3, 0.5) for RWMH.
Ignored if <code>autotune = FALSE</code>.</p>
</td></tr>
<tr><td><code id="fit_angmix_+3A_epsilon.incr">epsilon.incr</code></td>
<td>
<p>amount of randomness incorporated in <code>epsilon</code> if <code>epsilon.random = TRUE</code>.</p>
</td></tr>
<tr><td><code id="fit_angmix_+3A_l.incr">L.incr</code></td>
<td>
<p>amount of randomness incorporated in L if <code>L.random = TRUE</code>.</p>
</td></tr>
<tr><td><code id="fit_angmix_+3A_tune.incr">tune.incr</code></td>
<td>
<p>how much should the tuning parameter be increased or decreased at each step while tuning during burn-in?
Must be a number between 0 and 1. See <code>autotune</code>. Defaults to 0.05. Ignored if <code>autotune = FALSE</code>.</p>
</td></tr>
<tr><td><code id="fit_angmix_+3A_tune_ave_size">tune_ave_size</code></td>
<td>
<p>number previous iterations used to compute the acceptance rate while tuning in burn-in. Must be a positive
integer. Defaults to 100.</p>
</td></tr>
<tr><td><code id="fit_angmix_+3A_kappa_upper">kappa_upper</code>, <code id="fit_angmix_+3A_kappa_lower">kappa_lower</code></td>
<td>
<p>upper and lower bounds for the concentration and (absolute) association parameters. Must be a positive integers. Defaults to 150 and 1e-4,
and parameter with value above or below these limits rarely make sense in practice.
Warning: values much larger or smaller than the default are not recommended as they can cause numerical instability.</p>
</td></tr>
<tr><td><code id="fit_angmix_+3A_return_tune_param">return_tune_param</code></td>
<td>
<p>logical. Should the values of the tuning parameters used at each iteration in each chain be returned? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fit_angmix_+3A_qrnd">qrnd</code>, <code id="fit_angmix_+3A_n_qrnd">n_qrnd</code></td>
<td>
<p>Used only if <code>method="vmcos"</code>. See <a href="#topic+dvmcos">dvmcos</a> for details.</p>
</td></tr>
<tr><td><code id="fit_angmix_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Sampling is done in log scale for the concentration parameters (kappa, kappa1 and kappa2).
</p>
<p>Parallelization is done by default when more than one chain is used,
but the chains can be run sequentially as well by setting
<code>chains_parallel = FALSE</code>. To retain reproducibility while running
multiple chains in parallel, the same RNG state is passed at the
beginning of each chain. This is done by specifying <code>future.seed = TRUE</code>
in <code>future.apply::future_lapply</code> call. Then at the beginning of the i-th
chain, before drawing any parameters, i-many Uniform(0, 1) random numbers are
generated using <code>runif(i)</code> (and then thrown away). This ensures that the
RNG states across chains prior to random generation of the parameters are
different, and hence, no two chains can become identical, even if they have
the same starting and tuning parameters. This, however creates a difference
between a <code>fit_angmix</code> call with multiple chains which is run sequentially
by setting <code>chains_parallel = FALSE</code>, and another which is run sequentially
because of a sequential <code>plan()</code> (or no <code>plan()</code>), with
<code>chains_parallel = TRUE</code>. In the former, different RNG states are passed at
the initiation of each chain.
</p>


<h3>References</h3>

<p>Fruhwirth-Schnatter, S. (2011). Label switching under model uncertainty. Mixtures: Estimation and Application, 213-239.
</p>
<p>Fruhwirth-Schnatter, S. (2001). Markov chain Monte Carlo estimation of classical and dynamic switching and mixture models. Journal of the American Statistical Association, 96(453), 194-209.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># illustration only - more iterations needed for convergence
fit.vmsin.20 &lt;- fit_angmix("vmsin", tim8,
  ncomp = 3, n.iter = 20,
  n.chains = 1
)
fit.vmsin.20


# Parallelization is implemented via future_lapply from the
# package future.apply. To parallelize, first provide a parallel
# plan(); otherwise the chains will run sequentially.
# Note that not all plan() might work on every OS, as they execute
# functions defined internally in fit_mixmodel. We suggest
# plan(multisession) which works on every OS.

library(future)
library(parallel)
# plan(multisession, gc = TRUE) # parallelize chains

set.seed(1)
MC.fit &lt;- fit_angmix("vmsin", tim8,
  ncomp = 3, n.iter = 5000,
  n.chains = 3
)


pointest(MC.fit)

MC.fix &lt;- fix_label(MC.fit)

contour(MC.fit)
contour(MC.fix)
lpdtrace(MC.fit)


</code></pre>

<hr>
<h2 id='fit_incremental_angmix'>Stepwise fitting of angular mixture models with incremental component sizes and optimum model selection</h2><span id='topic+fit_incremental_angmix'></span>

<h3>Description</h3>

<p>Stepwise fitting of angular mixture models with incremental component sizes and optimum model selection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_incremental_angmix(
  model,
  data,
  crit = "LOOIC",
  start_ncomp = 1,
  max_ncomp = 10,
  L = NULL,
  fn = mean,
  fix_label = NULL,
  form = 2,
  start_par = NULL,
  prev_par = TRUE,
  logml_maxiter = 10000,
  return_all = FALSE,
  save_fits = FALSE,
  save_file = NULL,
  save_dir = "",
  silent = FALSE,
  return_llik_contri = (crit %in% c("LOOIC", "WAIC")),
  use_best_chain = TRUE,
  alpha = 0.05,
  bonferroni_alpha = TRUE,
  bonferroni_adj_type = "decreasing",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_incremental_angmix_+3A_model">model</code></td>
<td>
<p>angular model whose mixtures are to be fitted. Available choices are <code>"vmsin", "vmcos"</code> and <code>"wnorm2"</code> for
bivariate data, and <code>"vm"</code> and <code>"wnorm"</code> for univariate data.</p>
</td></tr>
<tr><td><code id="fit_incremental_angmix_+3A_data">data</code></td>
<td>
<p>data matrix (if bivarate, in which case it must have two columns) or vector. If outside, the values
are transformed into the scale <code class="reqn">[0, 2\pi)</code>. *Note:* BAMBI cannot handle missing data. Missing values must
either be removed or properly imputed.</p>
</td></tr>
<tr><td><code id="fit_incremental_angmix_+3A_crit">crit</code></td>
<td>
<p>model selection criteria, one of <code>"LOOIC", "WAIC", "AIC", "BIC", "DIC"</code> or <code>"LOGML"</code>. Default is
<code>"LOOIC"</code>.</p>
</td></tr>
<tr><td><code id="fit_incremental_angmix_+3A_start_ncomp">start_ncomp</code></td>
<td>
<p>starting component size. A single component model is fitted if <code>start_ncomp</code> is equal to one.</p>
</td></tr>
<tr><td><code id="fit_incremental_angmix_+3A_max_ncomp">max_ncomp</code></td>
<td>
<p>maximum number of components allowed in the mixture model.</p>
</td></tr>
<tr><td><code id="fit_incremental_angmix_+3A_l">L</code></td>
<td>
<p>HMC tuning parameter (trajectory length) passed to <a href="#topic+fit_angmix">fit_angmix</a>. Can be a numeric vetor (or scalar), in which case
the same <code>L</code> is passed to all <a href="#topic+fit_angmix">fit_angmix</a> calls, or can be a list of length <code>max_ncomp-start_ncomp+1</code>,
so that <code>L_list[[i]]</code> is passed as the argument <code>L</code> to <a href="#topic+fit_angmix">fit_angmix</a> call with <code>ncomp = max_ncomp+i-1</code>. See
<a href="#topic+fit_angmix">fit_angmix</a> for more details on <code>L</code> including its default values. Ignored if <code>method = "rwmh"</code>.</p>
</td></tr>
<tr><td><code id="fit_incremental_angmix_+3A_fn">fn</code></td>
<td>
<p>function to evaluate on MCMC samples to estimate parameters.
Defaults to <code>mean</code>, which computes the estimated posterior means. If <code>fn = max</code>,
then MAP estimate is calculated from the MCMC run. Used only if <code>crit = "DIC"</code>, and ignored otherwise.</p>
</td></tr>
<tr><td><code id="fit_incremental_angmix_+3A_fix_label">fix_label</code></td>
<td>
<p>logical. Should the label switchings on the current fit (only the corresponding &quot;best chain&quot; if <code>use_best_chain = TRUE</code>)
be fixed before computing parameter estimates and model selection criterion? Defaults to <code>TRUE</code> if <code>perm_sampling</code> is true in
the <a href="#topic+fit_angmix">fit_angmix</a> call, or if <code>crit = "DIC"</code> and <code>form = 1</code>.</p>
</td></tr>
<tr><td><code id="fit_incremental_angmix_+3A_form">form</code></td>
<td>
<p>form of crit to be used. Available choices are 1 and 2. Used only if <code>crit</code> is <code>"DIC"</code> and ignored otherwise.</p>
</td></tr>
<tr><td><code id="fit_incremental_angmix_+3A_start_par">start_par</code></td>
<td>
<p>list with elements <code>pmix</code> (ignored if <code>comp == 1</code>), together with <code>kappa1, kappa2, mu1</code> and <code>mu2</code>,
for bivariate models, and <code>kappa</code> and <code>mu</code> for univariate models,
all being vectors of length same as <code>ncomp</code>.
These provides the starting values for the Markov chain; with <code class="reqn">j</code>-th component of each vector corresponding to the <code class="reqn">j</code>-th
component of the mixture distribution. If missing, the data is first clustered into <code>ncomp</code> groups either via k-means (after
projecting onto a unit sphere), or randomly, depending on <code>rand_start</code>,  and then moment estimators for components are used as
the starting points. Note that a very wrong starting point can potentially lead the chain to get stuck at a wrong solution for thousands
of iterations. As such, we recommend using the default option, which is k-means followed by moment estimation.</p>
</td></tr>
<tr><td><code id="fit_incremental_angmix_+3A_prev_par">prev_par</code></td>
<td>
<p>logical. Should the MAP estimated parameters from the model with <code>ncomp = K</code> be used in the model
with <code>ncomp = K+1</code> as the starting parameters, with the component with largest mixing proportion appearing twice in the
bigger model?</p>
</td></tr>
<tr><td><code id="fit_incremental_angmix_+3A_logml_maxiter">logml_maxiter</code></td>
<td>
<p>maximum number of iterations (<code>maxiter</code>) passed to <a href="bridgesampling.html#topic+bridge_sampler">bridge_sampler</a> for calculating
<code>LOGML</code>. Ignored if <code>crit</code> is not <code>LOGML</code>.</p>
</td></tr>
<tr><td><code id="fit_incremental_angmix_+3A_return_all">return_all</code></td>
<td>
<p>logical. Should all angmcmc objects obtained during step-wise run be returned? *Warning*: depending on the
sizes of <code>n.iter</code>, <code>start_ncomp</code>, <code>max_ncomp</code> and <code>n.chains</code>, this can be very memory intesive. In such
cases, it is recommended that <code>return_all</code> be set to <code>FALSE</code>, and, if required, the intermediate fitted objects be
saved to file by setting <code>save_fits = TRUE</code>.</p>
</td></tr>
<tr><td><code id="fit_incremental_angmix_+3A_save_fits">save_fits</code></td>
<td>
<p>logical. Should the intermediate angmcmc objects obtained during step-wise run be saved
to file using <a href="base.html#topic+save">save</a>? Defaults to TRUE. See <code>save_file</code> and <code>save_dir</code>.</p>
</td></tr>
<tr><td><code id="fit_incremental_angmix_+3A_save_file">save_file</code>, <code id="fit_incremental_angmix_+3A_save_dir">save_dir</code></td>
<td>
<p><code>save_file</code> is a list of size <code>max_ncomp-start_ncomp+1</code>,
with k-th entry providing the <code>file</code>
argument used to <a href="base.html#topic+save">save</a> the intermediate angmcmc object with <code>ncomp = k</code> (titled <code>"fit_angmcmc"</code>).
If not provided, then k-th element
of <code>save_file[[k]]</code> is taken to be <code><a href="base.html#topic+paste">paste</a>(save_dir, "comp_k", sep="/")</code>. Both are ignored if
<code>save_fits = FALSE</code>.</p>
</td></tr>
<tr><td><code id="fit_incremental_angmix_+3A_silent">silent</code></td>
<td>
<p>logical. Should the current status (such as what is the current component labels, which job is being done etc.)
be printed? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fit_incremental_angmix_+3A_return_llik_contri">return_llik_contri</code></td>
<td>
<p>passed to <a href="#topic+fit_angmix">fit_angmix</a>. By default, set to <code>TRUE</code> if <code>crit</code> is either <code>"LOOIC"</code>
or <code>"WAIC"</code>, and to <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="fit_incremental_angmix_+3A_use_best_chain">use_best_chain</code></td>
<td>
<p>logical. Should only the &quot;best&quot; chain obtained during each intermediate fit be used during
computation of model selection criterion? Here &quot;best&quot; means the chain
with largest (mean over iterations) log-posterior density. This can be helpful if one of the chains gets stuck at local optima. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="fit_incremental_angmix_+3A_alpha">alpha</code></td>
<td>
<p>significance level used in the test H_0K: expected log predictive density (elpd) for the fitted model with  K components &gt;= elpd for the fitted model
with K + 1 components if <code>crit</code> is <code>"LOOIC"</code> or <code>"WAIC"</code>.
Must be a scalar between 0 and 1. Defaults to 0.05. See Details. Ignored for any other <code>crit</code>.</p>
</td></tr>
<tr><td><code id="fit_incremental_angmix_+3A_bonferroni_alpha">bonferroni_alpha</code></td>
<td>
<p>logical. Should a Bonferroni correction be made on the test size <code>alpha</code> to adjust for
multiplicity due to (<code>max_ncomp</code> - <code>start_ncomp</code>) possible hypothesis tests? Defaults to TRUE.
Relevant only if <code>crit</code> is in  <code>c("LOOIC", "WAIC")</code>, and ignored otherwise. See Details.</p>
</td></tr>
<tr><td><code id="fit_incremental_angmix_+3A_bonferroni_adj_type">bonferroni_adj_type</code></td>
<td>
<p>character string. Denoting type of Bonferroni adjustment to make.
Possible choices are <code>"decreasing"</code> (default) and <code>"equal"</code>. Ignored if either <code>bonferroni_alpha</code>
is FALSE, or <code>crit</code> is outside <code>c("LOOIC", "WAIC")</code>. See Details.</p>
</td></tr>
<tr><td><code id="fit_incremental_angmix_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <a href="#topic+fit_angmix">fit_angmix</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The goal is to fit an angular mixture model with an optimally chosen component size K.
To obtain an optimum K, mixture models with incremental component sizes
between <code>start_ncomp</code> and <code>max_ncomp</code> are fitted incrementally using <a href="#topic+fit_angmix">fit_angmix</a>,
starting from K = 1.
If the model selection criterion <code>crit</code> is <code>"LOOIC"</code> or <code>"WAIC"</code>, then a test of hypothesis
H_0K: expected log predictive density (elpd) for the fitted model with  K components &gt;= elpd for the fitted model
with K + 1 components, is performed at every K &gt;= 1. The test-statistic used for the test is an approximate z-score
based on the normalized estimated elpd difference between the two models obtained from <a href="loo.html#topic+compare">compare</a>, which provides
estimated elpd difference along with its standard error estimate. Because the computed standard error of elpd difference
can be overly optimistic when the elpd difference is small (in particular &lt; 4),
a conservative worst-case estimate (equal to twice of the computed standard error)
is used in such cases. To account for multiplicity among the M =
(<code>max_ncomp</code> - <code>start_ncomp</code>) possible sequential tests performed,
by default a Bonferroni adjustment to the test level <code>alpha</code> is made.
Set <code>bonferroni_alpha = FALSE</code> to remove the adjustment. To encourage
parsimony in the final model, by default (<code>bonferroni_adj_type = "decreasing"</code>)
a decreasing sequence of adjusted alphas of the form <code>alpha * (0.5)^(1:M) / sum((0.5)^(1:M))</code>
is used. Set <code>bonferroni_adj_type = "equal"</code>
to use equal sequence of adjusted alphas (i.e., <code>alpha/M</code>) instead.
</p>
<p>The incremental fitting stops if  H_0K cannot be rejected
(at level <code>alpha</code>) for some K &gt;= 1; this K is then regarded as the optimum number of components.
If <code>crit</code> is not <code>"LOOIC"</code> or <code>"WAIC"</code> then mixture model with the first minimum value of the model selection criterion <code>crit</code>
is taken as the best model.
</p>
<p>Note that in each intermediate fitted model, the total number of components (instead of the number of
&quot;non-empty components&quot;) in the model is used to estimate of the true component
size, and then the fitted model is penalized for model complexity (via the model selection criterion used).
This approach of selecting an optimal K follows the perspective &quot;let two component specific parameters
be identical&quot; for overfitting mixtures, and as such the  Dirichlet prior hyper-parameters <code>pmix.alpha</code>
(passed to <a href="#topic+fit_angmix">fit_angmix</a>) should be large. See  Fruhwirth-Schnatter (2011) for more deltails.
</p>
<p>Note that the stability of <a href="bridgesampling.html#topic+bridge_sampler">bridge_sampler</a> used in marginal likelihood estimation heavily depends on stationarity of the
chains. As such, while using this criterion, we recommending running the chain long engouh, and setting <code>fix_label = TRUE</code>
for optimal performance.
</p>


<h3>Value</h3>

<p>Returns a named list (with class = <code>stepfit</code>) with the following seven elements:
</p>
<p><code>fit.all</code> (if <code>return_all = TRUE</code>) - a list all angmcmc objects created at each component size;
</p>
<p><code>fit.best</code> - angmcmc object corresponding to the optimum component size;
</p>
<p><code>ncomp.best</code> - optimum component size (integer);
</p>
<p><code>crit</code> - which model comparison criterion used (one of <code>"LOOIC", "WAIC", "AIC", "BIC", "DIC"</code> or <code>"LOGML"</code>);
</p>
<p><code>crit.all</code> - all <code>crit</code> values calculated (for all component sizes);
</p>
<p><code>crit.best</code> - <code>crit</code> value for the optimum component size; and
</p>
<p><code>maxllik.all</code> - maximum (obtained from MCMC iterations) log likelihood for all fitted models
</p>
<p><code>maxllik.best</code> - maximum log likelihodd for the optimal model; and
</p>
<p><code>check_min</code> - logical; is the optimum component size less than <code>max_ncomp</code>?
</p>


<h3>References</h3>

<p>Fruhwirth-Schnatter, S.: Label switching under model uncertainty. In: Mengerson, K., Robert, C., Titterington, D. (eds.) Mixtures:
Estimation and Application, pp. 213-239. Wiley, New York (2011).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># illustration only - more iterations needed for convergence
set.seed(1)
fit.vmsin.step.15 &lt;- fit_incremental_angmix("vmsin", tim8, "BIC", start_ncomp = 1,
                                          max_ncomp = 3, n.iter = 15,
                                          n.chains = 1, save_fits=FALSE)
(fit.vmsin.best.15 &lt;- bestmodel(fit.vmsin.step.15))
lattice::densityplot(fit.vmsin.best.15)

</code></pre>

<hr>
<h2 id='fit_vmcosmix'>Fitting bivariate von Mises cosine model mixtures using MCMC</h2><span id='topic+fit_vmcosmix'></span>

<h3>Description</h3>

<p>Fitting bivariate von Mises cosine model mixtures using MCMC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_vmcosmix(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_vmcosmix_+3A_...">...</code></td>
<td>
<p>arguments (other than <code>model</code>) passed to <a href="#topic+fit_angmix">fit_angmix</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Wrapper for <a href="#topic+fit_angmix">fit_angmix</a> with <code>model = "vmcos"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># illustration only - more iterations needed for convergence
fit.vmcos.10 &lt;- fit_vmcosmix(tim8, ncomp = 3, n.iter =  10,
                             n.chains = 1)
fit.vmcos.10

</code></pre>

<hr>
<h2 id='fit_vmmix'>Fitting univariate von Mises mixtures using MCMC</h2><span id='topic+fit_vmmix'></span>

<h3>Description</h3>

<p>Fitting univariate von Mises mixtures using MCMC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_vmmix(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_vmmix_+3A_...">...</code></td>
<td>
<p>arguments (other than <code>model</code>) passed to <a href="#topic+fit_angmix">fit_angmix</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Wrapper for <a href="#topic+fit_angmix">fit_angmix</a> with <code>model = "vm"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># illustration only - more iterations needed for convergence
fit.vm.20 &lt;- fit_vmmix(wind$angle, ncomp = 3, n.iter =  20,
                       n.chains = 1)
fit.vm.20
</code></pre>

<hr>
<h2 id='fit_vmsinmix'>Fitting bivariate von Mises sine model mixtures using MCMC</h2><span id='topic+fit_vmsinmix'></span>

<h3>Description</h3>

<p>Fitting bivariate von Mises sine model mixtures using MCMC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_vmsinmix(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_vmsinmix_+3A_...">...</code></td>
<td>
<p>arguments (other than <code>model</code>) passed to <a href="#topic+fit_angmix">fit_angmix</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Wrapper for <a href="#topic+fit_angmix">fit_angmix</a> with <code>model = "vmsin"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># illustration only - more iterations needed for convergence
fit.vmsin.20 &lt;- fit_vmsinmix(tim8, ncomp = 3, n.iter =  20,
                             n.chains = 1)
fit.vmsin.20

</code></pre>

<hr>
<h2 id='fit_wnorm2mix'>Fitting bivariate wrapped normal model mixtures using MCMC</h2><span id='topic+fit_wnorm2mix'></span>

<h3>Description</h3>

<p>Fitting bivariate wrapped normal model mixtures using MCMC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_wnorm2mix(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_wnorm2mix_+3A_...">...</code></td>
<td>
<p>arguments (other than <code>model</code>) passed to <a href="#topic+fit_angmix">fit_angmix</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Wrapper for <a href="#topic+fit_angmix">fit_angmix</a> with <code>model = "wnorm2"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># illustration only - more iterations needed for convergence
fit.wnorm2.10 &lt;- fit_wnorm2mix(tim8, ncomp = 3, n.iter =  10,
                             n.chains = 1)
fit.wnorm2.10

</code></pre>

<hr>
<h2 id='fit_wnormmix'>Fitting univariate wrapped normal mixtures using MCMC</h2><span id='topic+fit_wnormmix'></span>

<h3>Description</h3>

<p>Fitting univariate wrapped normal mixtures using MCMC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_wnormmix(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_wnormmix_+3A_...">...</code></td>
<td>
<p>arguments (other than <code>model</code>) passed to <a href="#topic+fit_angmix">fit_angmix</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Wrapper for <a href="#topic+fit_angmix">fit_angmix</a> with <code>model = "wnorm"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># illustration only - more iterations needed for convergence
fit.wnorm.20 &lt;- fit_wnormmix(wind$angle, ncomp = 3, n.iter =  20,
                             n.chains = 1)
fit.wnorm.20

</code></pre>

<hr>
<h2 id='fix_label'>Fix label switching in angmcmc objects</h2><span id='topic+fix_label'></span>

<h3>Description</h3>

<p>Fix label switching in angmcmc objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_label(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fix_label_+3A_object">object</code></td>
<td>
<p>angular MCMC object.</p>
</td></tr>
<tr><td><code id="fix_label_+3A_...">...</code></td>
<td>
<p>arguments other than <code>z, K, complete, mcmc, p</code>
and <code>data</code> passed to <a href="label.switching.html#topic+label.switching">label.switching</a>. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fix_label</code> is a wrapper for  <a href="label.switching.html#topic+label.switching">label.switching</a> from
package <code>label.switching</code> for <code>angmcmc</code> objects. The arguments
<code>z, K, complete, mcmc, p</code> and <code>data</code> are appropriately filled in
from <code>object</code>. The <code>label.switching</code> argument <code>method</code> can
be a scalar or vector; for this wrapper it defaults to <code>"STEPHENS"</code> if the <code>angmcmc</code> was
created with permutation sampling (by setting perm_sampling = TRUE in
<a href="#topic+fit_angmix">fit_angmix</a>), and to <code>"DATA-BASED"</code> otherwise.
</p>


<h3>Value</h3>

<p>Returns a single <code>angmcmc</code> object or a list of <code>angmcmc</code> objects (according as whether
the argument <code>method</code> is a scalar or vector) with label switchings corrected (after burn-in and thin)
according to the resulting permutation from <a href="label.switching.html#topic+label.switching">label.switching</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first fit a vmsin mixture model
# illustration only - more iterations needed for convergence
fit.vmsin.20 &lt;- fit_vmsinmix(tim8, ncomp = 3, n.iter =  20,
                             n.chains = 1)
# now apply fix_label
fit.vmsin.20.fix &lt;- fix_label(fit.vmsin.20)

</code></pre>

<hr>
<h2 id='is.angmcmc'>Angular MCMC (<code>angmcmc</code>) Object</h2><span id='topic+is.angmcmc'></span><span id='topic+angmcmc'></span>

<h3>Description</h3>

<p>Checking for and creating an angmcmc object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.angmcmc(object)

angmcmc(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.angmcmc_+3A_object">object</code></td>
<td>
<p>any R object</p>
</td></tr>
<tr><td><code id="is.angmcmc_+3A_...">...</code></td>
<td>
<p>arguments required to make an angmcmc object. See details</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>angmcmc</code> objects are classified lists that are created when any of the five mixture model fitting
functions, viz., <code>fit_vmmix</code>, <code>fit_wnormmix</code>, <code>fit_vmsinmix</code>, <code>fit_vmcosmix</code> and
<code>fit_wnorm2mix</code> is used. An <code>angmcmc</code> object contains a number of elements, including the dataset, the
model being fitted on the dataset and dimension of the model (univariate or bivariate), the tuning parameters
used, MCMC samples for the mixture model parameters, the (hidden) component or cluster indicators for  data
points in each iteration and the (iteration-wise) log likelihood and log posterior density values (both calculated
upto some normalizing constants). When printed, an angmcmc object returns a brief summary of the function
arguments used to produce the object and the average acceptance rate of the proposals (in HMC and RWMH) used
over iterations. An <code>angmcmc</code> object can be used as an argument for the diagnostic and post-processing
functions available in <code>BAMBI</code> for making further inferences.
</p>


<h3>Value</h3>

<p>logical. Is the input an angmcmc object?
</p>


<h3>Examples</h3>

<pre><code class='language-R'># illustration only - more iterations needed for convergence
fit.vmsin.20 &lt;- fit_vmsinmix(tim8, ncomp = 3, n.iter =  20,
                             n.chains = 1)
is.angmcmc(fit.vmsin.20)
</code></pre>

<hr>
<h2 id='latent_allocation'>Finding latent allocation (component indicators) from an angmcmc object</h2><span id='topic+latent_allocation'></span>

<h3>Description</h3>

<p>Finding latent allocation (component indicators) from an angmcmc object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latent_allocation(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latent_allocation_+3A_object">object</code></td>
<td>
<p>angular MCMC object.</p>
</td></tr>
<tr><td><code id="latent_allocation_+3A_...">...</code></td>
<td>
<p>passed to <a href="#topic+pointest">pointest</a> to estimate parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to find the latent component indicators, estimates
of mixing proportions and model parameters are first computed via
pointest. Then, a data point is assigned label j, if the j-th
component gives highest density for that point.
</p>


<h3>Value</h3>

<p>Returns a vector of length n, where n is the length (if univariate) or
number of rows (if bivariate) of the data used in original fit.
i-th entry of the output vector provides component label for the i-th data point.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first fit a vmsin mixture model
# illustration only - more iterations needed for convergence
fit.vmsin.20 &lt;- fit_vmsinmix(tim8, ncomp = 3, n.iter =  20,
                             n.chains = 1)
# now find latent allocation
latent_allocation(fit.vmsin.20)
</code></pre>

<hr>
<h2 id='logLik.angmcmc'>Extract Log-Likelihood from angmcmc objects</h2><span id='topic+logLik.angmcmc'></span>

<h3>Description</h3>

<p>Extract Log-Likelihood from angmcmc objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'angmcmc'
logLik(object, method = 1, fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.angmcmc_+3A_object">object</code></td>
<td>
<p>angular MCMC object.</p>
</td></tr>
<tr><td><code id="logLik.angmcmc_+3A_method">method</code></td>
<td>
<p>interger specifying method of estimating the log likelihood. Must be 1 or 2. Defaults to 1. See details.</p>
</td></tr>
<tr><td><code id="logLik.angmcmc_+3A_fn">fn</code></td>
<td>
<p>function to evaluate on the iteration-wise log-likelihood values obtained during MCMC run if <code>method = 1</code>; or,
if <code>method = 2</code>, function to evaluate on the MCMC samples for parameter estimation (passed to <a href="#topic+pointest">pointest</a>).
Defaults to <code>max</code> if <code>method = 1</code> and <code>mean</code> if <code>method = 2</code>.</p>
</td></tr>
<tr><td><code id="logLik.angmcmc_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two ways to estimate the log likelihood from the model. If <code>method = 1</code>,
then log likelihood is estimated by applying <code>fn</code> (defaults to max, if method = 1)
direclty on the log likelihood values from observed during the MCMC run.
On the other hand, if <code>method == 2</code>, then  parameter estimates
are first computed using <code>pointest</code> with <code>fn</code>
(defaults to &quot;MODE&quot;, if <code>method == 2</code>) applied on the MCMC samples,
and then then log likelihood is evaluated at the parameter estimates.
</p>
<p>The degrees of the likelihood function is the total number of free parameters estimated in the mixture models,
which is equal to <code class="reqn">6K - 1</code> for bivariate models (vmsin, vmcos and wnorm2), or <code class="reqn">3K - 1</code> for univariate
models (vm and wnorm), where <code class="reqn">K</code> denotes the number of components in the mixture model.
</p>


<h3>Value</h3>

<p>Returns an object of class <a href="stats.html#topic+logLik">logLik</a>. This is a number (the estimated log likelihood) with attributes &quot;df&quot;
(degrees of freedom) and &quot;nobs&quot; (number of observations).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># illustration only - more iterations needed for convergence
fit.vmsin.20 &lt;- fit_vmsinmix(tim8, ncomp = 3, n.iter =  20,
                             n.chains = 1)
logLik(fit.vmsin.20)
</code></pre>

<hr>
<h2 id='loo.angmcmc'>Leave-one-out cross-validation (LOO) for angmcmc objects</h2><span id='topic+loo.angmcmc'></span>

<h3>Description</h3>

<p>Leave-one-out cross-validation (LOO) for angmcmc objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'angmcmc'
loo(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loo.angmcmc_+3A_x">x</code></td>
<td>
<p>angmcmc object.</p>
</td></tr>
<tr><td><code id="loo.angmcmc_+3A_...">...</code></td>
<td>
<p>additional model specific arguments to be passed to <a href="loo.html#topic+waic">waic</a> from loo. For example, <code>int.displ</code>
specifies integer displacement in wnorm and wnorm2 models. See <a href="#topic+fit_wnormmix">fit_wnormmix</a> and
<a href="#topic+fit_wnorm2mix">fit_wnorm2mix</a> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that loo.angmcmc calls <a href="loo.html#topic+loo">loo</a> for computation. If the likelihood contribution of each data
point for each MCMC iteration is available in <code>object</code> (can be returned by setting <code>return_llik_contri = TRUE</code>)
during <a href="#topic+fit_angmix">fit_angmix</a> call), <code>loo.array</code> is used; otherwise <code>loo.function</code> is
called. Computation is much faster if the likelihood contributions are available - however, they are very
memory intensive, and by default not returned in <a href="#topic+fit_angmix">fit_angmix</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# illustration only - more iterations needed for convergence
fit.vmsin.20 &lt;- fit_vmsinmix(tim8, ncomp = 3, n.iter =  20,
                             n.chains = 1, return_llik_contri = TRUE)
library(loo)
loo(fit.vmsin.20)

</code></pre>

<hr>
<h2 id='lpdtrace'>Trace and autocorrelation plots of log posterior density or log likelihood from an angmcmc object</h2><span id='topic+lpdtrace'></span>

<h3>Description</h3>

<p>Trace and autocorrelation plots of log posterior density or log likelihood from an angmcmc object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lpdtrace(
  object,
  chain.no,
  use.llik = FALSE,
  plot.autocor = FALSE,
  lag.max = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lpdtrace_+3A_object">object</code></td>
<td>
<p>angular MCMC object.</p>
</td></tr>
<tr><td><code id="lpdtrace_+3A_chain.no">chain.no</code></td>
<td>
<p>vector of chain numbers whose samples are to be be used.
in the estimation. By default all chains are used.</p>
</td></tr>
<tr><td><code id="lpdtrace_+3A_use.llik">use.llik</code></td>
<td>
<p>logical. Should log likelihood be plotted instead of log posterior? Set
to <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="lpdtrace_+3A_plot.autocor">plot.autocor</code></td>
<td>
<p>logical. Should the autocorrelations be plotted as well?</p>
</td></tr>
<tr><td><code id="lpdtrace_+3A_lag.max">lag.max</code></td>
<td>
<p>maximum lag for autocorrelation.  Passed to <a href="stats.html#topic+acf">acf</a>. Ignored if
<code>plot.autocor = FALSE</code>.</p>
</td></tr>
<tr><td><code id="lpdtrace_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># first fit a vmsin mixture model
# illustration only - more iterations needed for convergence
fit.vmsin.20 &lt;- fit_vmsinmix(tim8, ncomp = 3, n.iter =  20,
                             n.chains = 1)
# log posterior density trace
lpdtrace(fit.vmsin.20)
# log likelihood trace
lpdtrace(fit.vmsin.20, use.llik = TRUE)

</code></pre>

<hr>
<h2 id='paramtrace'>Trace plot for parameters from an angmcmc object</h2><span id='topic+paramtrace'></span>

<h3>Description</h3>

<p>Trace plot for parameters from an angmcmc object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paramtrace(object, par.name, comp.label, chain.no, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paramtrace_+3A_object">object</code></td>
<td>
<p>angular MCMC object.</p>
</td></tr>
<tr><td><code id="paramtrace_+3A_par.name">par.name</code></td>
<td>
<p>vector of names of parameters for which point estimates are to be computed.  If <code>NULL</code>, results for all parameters are provided.</p>
</td></tr>
<tr><td><code id="paramtrace_+3A_comp.label">comp.label</code></td>
<td>
<p>vector of component labels (positive integers, e.g., <code>1, 2, ...</code>) for which point estimates are to be computed.
If <code>NULL</code>, results for all components are provided.</p>
</td></tr>
<tr><td><code id="paramtrace_+3A_chain.no">chain.no</code></td>
<td>
<p>vector of chain numbers whose samples are to be be used.
in the estimation. By default all chains are used.</p>
</td></tr>
<tr><td><code id="paramtrace_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="paramtrace_+3A_par">par</code></td>
<td>
<p>parameter for which trace plot is to be created.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a single plot if a single <code>par</code> and a single <code>comp.label</code> is supplied.
Otherwise, a series of plots is produced.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first fit a vmsin mixture model
# illustration only - more iterations needed for convergence
fit.vmsin.20 &lt;- fit_vmsinmix(tim8, ncomp = 3, n.iter =  20,
                             n.chains = 1)
# trace plot for kappa1 in component 1
paramtrace(fit.vmsin.20, "kappa1", 1)
# for kappa1 in all components
paramtrace(fit.vmsin.20, "kappa1")
# for all parameters in component 1
paramtrace(fit.vmsin.20, comp.label = 1)

</code></pre>

<hr>
<h2 id='plot.angmcmc'>Summary plots for angmcmc objects</h2><span id='topic+plot.angmcmc'></span>

<h3>Description</h3>

<p>Summary plots for angmcmc objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'angmcmc'
plot(
  x,
  par.name,
  comp.label,
  chain.no,
  do.paramtrace = TRUE,
  do.lpdtrace = TRUE,
  use.llik = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.angmcmc_+3A_x">x</code></td>
<td>
<p>angmcmc object</p>
</td></tr>
<tr><td><code id="plot.angmcmc_+3A_par.name">par.name</code></td>
<td>
<p>vector of names of parameters for which point estimates are to be computed.  If <code>NULL</code>, results for all parameters are provided.</p>
</td></tr>
<tr><td><code id="plot.angmcmc_+3A_comp.label">comp.label</code></td>
<td>
<p>vector of component labels (positive integers, e.g., <code>1, 2, ...</code>) for which point estimates are to be computed.
If <code>NULL</code>, results for all components are provided.</p>
</td></tr>
<tr><td><code id="plot.angmcmc_+3A_chain.no">chain.no</code></td>
<td>
<p>vector of chain numbers whose samples are to be be used.
in the estimation. By default all chains are used.</p>
</td></tr>
<tr><td><code id="plot.angmcmc_+3A_do.paramtrace">do.paramtrace</code></td>
<td>
<p>logical. Should the trace(s) for the
parameter(s) be plotted?</p>
</td></tr>
<tr><td><code id="plot.angmcmc_+3A_do.lpdtrace">do.lpdtrace</code></td>
<td>
<p>logical. Should the log posterior trace
be plotted?</p>
</td></tr>
<tr><td><code id="plot.angmcmc_+3A_use.llik">use.llik</code></td>
<td>
<p>logical. Should the log likelihood be plotted
instead? Ignored if <code>do.lpdtrace == FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.angmcmc_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># first fit a vmsin mixture model
# illustration only - more iterations needed for convergence
fit.vmsin.20 &lt;- fit_vmsinmix(tim8, ncomp = 3, n.iter =  20,
                             n.chains = 1)
plot(fit.vmsin.20)
</code></pre>

<hr>
<h2 id='pointest'>Point estimates for parameters from an angmcmc object</h2><span id='topic+pointest'></span>

<h3>Description</h3>

<p>Point estimates for parameters from an angmcmc object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pointest(object, fn = mean, par.name, comp.label, chain.no, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pointest_+3A_object">object</code></td>
<td>
<p>angular MCMC object.</p>
</td></tr>
<tr><td><code id="pointest_+3A_fn">fn</code></td>
<td>
<p>function, or a single character string specifying its name, to evaluate on MCMC samples to estimate
parameters.  Defaults to <code>mean</code>, which computes the estimated posterior mean.
Note that if <code>fn = "MODE"</code> (warning: not <code>"mode"</code>) or <code>fn = "MAP"</code>, then the maximum aposteriori estimate (MAP) is
calculated.</p>
</td></tr>
<tr><td><code id="pointest_+3A_par.name">par.name</code></td>
<td>
<p>vector of names of parameters for which point estimates are to be computed.  If <code>NULL</code>, results for all parameters are provided.</p>
</td></tr>
<tr><td><code id="pointest_+3A_comp.label">comp.label</code></td>
<td>
<p>vector of component labels (positive integers, e.g., <code>1, 2, ...</code>) for which point estimates are to be computed.
If <code>NULL</code>, results for all components are provided.</p>
</td></tr>
<tr><td><code id="pointest_+3A_chain.no">chain.no</code></td>
<td>
<p>vector of chain numbers whose samples are to be be used.
in the estimation. By default all chains are used.</p>
</td></tr>
<tr><td><code id="pointest_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of point estimates, or vector of point estimates if <code>length(par.name)==1</code> or <code>length(comp.label)==1</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first fit a vmsin mixture model
# illustration only - more iterations needed for convergence
fit.vmsin.20 &lt;- fit_vmsinmix(tim8, ncomp = 3, n.iter =  20,
                             n.chains = 1)
# estimate parameters by sample mean
(est_mean &lt;- pointest(fit.vmsin.20))
# estimate parameters by sample median
(est_median &lt;- pointest(fit.vmsin.20, fn = median))
# estimate parameters by MAP
(est_median &lt;- pointest(fit.vmsin.20, fn = "MODE"))
</code></pre>

<hr>
<h2 id='quantile.angmcmc'>Quantile estimates for parameters from an angmcmc object</h2><span id='topic+quantile.angmcmc'></span>

<h3>Description</h3>

<p>Quantile estimates for parameters from an angmcmc object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'angmcmc'
quantile(x, par.name, comp.label, chain.no, probs = seq(0, 1, 0.25), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.angmcmc_+3A_x">x</code></td>
<td>
<p>angmcmc object</p>
</td></tr>
<tr><td><code id="quantile.angmcmc_+3A_par.name">par.name</code></td>
<td>
<p>vector of names of parameters for which point estimates are to be computed.  If <code>NULL</code>, results for all parameters are provided.</p>
</td></tr>
<tr><td><code id="quantile.angmcmc_+3A_comp.label">comp.label</code></td>
<td>
<p>vector of component labels (positive integers, e.g., <code>1, 2, ...</code>) for which point estimates are to be computed.
If <code>NULL</code>, results for all components are provided.</p>
</td></tr>
<tr><td><code id="quantile.angmcmc_+3A_chain.no">chain.no</code></td>
<td>
<p>vector of chain numbers whose samples are to be be used.
in the estimation. By default all chains are used.</p>
</td></tr>
<tr><td><code id="quantile.angmcmc_+3A_probs">probs</code></td>
<td>
<p>numeric vector of probabilities with values in
<code class="reqn">[0,1]</code>.  (Values up to &lsquo;<span class="samp">&#8288;2e-14&#8288;</span>&rsquo; outside that
range are accepted and moved to the nearby endpoint.)</p>
</td></tr>
<tr><td><code id="quantile.angmcmc_+3A_...">...</code></td>
<td>
<p>further arguments to pass to <code>quantile</code>.  In particular, <code>probs = seq(0, 1, 0.25)</code>
is the default vector of quantiles computed for each parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a three dimensional array of quantiles, or a matrix (vector) of quantiles
if one (or two) among <code>par.name</code>,  <code>comp.label</code>, <code>probs</code> has length 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first fit a vmsin mixture model
# illustration only - more iterations needed for convergence
fit.vmsin.20 &lt;- fit_vmsinmix(tim8, ncomp = 3, n.iter =  20,
                             n.chains = 1)
# 0.025th quantiles
(quant_025 &lt;- quantile(fit.vmsin.20, prob = 0.025))
# 0.975th quantiles
(quant_975 &lt;- quantile(fit.vmsin.20, prob = 0.975))
# default quantiles
(quant_def &lt;- quantile(fit.vmsin.20))

</code></pre>

<hr>
<h2 id='rvm'>The univariate von Mises distribution</h2><span id='topic+rvm'></span><span id='topic+dvm'></span>

<h3>Description</h3>

<p>The univariate von Mises distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvm(n, kappa = 1, mu = 0)

dvm(x, kappa = 1, mu = 0, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rvm_+3A_n">n</code></td>
<td>
<p>number of observations. Ignored if at least one of the other parameters have length k &gt; 1, in which
case, all the parameters are recycled to length k to produce k random variates.</p>
</td></tr>
<tr><td><code id="rvm_+3A_kappa">kappa</code></td>
<td>
<p>vector of concentration (inverse-variance) parameters; <code>kappa</code> &gt; 0.</p>
</td></tr>
<tr><td><code id="rvm_+3A_mu">mu</code></td>
<td>
<p>vector of means.</p>
</td></tr>
<tr><td><code id="rvm_+3A_x">x</code></td>
<td>
<p>vector of angles (in radians) where the densities are to be evaluated.</p>
</td></tr>
<tr><td><code id="rvm_+3A_log">log</code></td>
<td>
<p>logical. Should the log density be returned instead?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>mu</code> and <code>kappa</code> are not specified they assume the default values of <code>0</code> and <code>1</code> respectively.
</p>
<p>The univariate von Mises distribution has density
</p>
<p style="text-align: center;"><code class="reqn">f(x) = 1/(2\pi I_0 (\kappa)) \exp(\kappa \cos(x - mu))</code>
</p>

<p>where <code class="reqn">I_0 (\kappa)</code> denotes the modified Bessel function of the first kind with order 0 evaluated at the point <code class="reqn">\kappa</code>.
</p>


<h3>Value</h3>

<p><code>dvm</code> gives the density  and <code>rvm</code> generates random deviates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
kappa &lt;- 1:3
mu &lt;- 0:2
x &lt;- 1:10
n &lt;- 10


# when x and both parameters are scalars, dvm returns a single density
dvm(x[1], kappa[1], mu[1])

# when x is a vector but both the parameters are scalars, dmv returns a vector of
# densities calculated at each entry of x with the same parameters
dvm(x, kappa[1], mu[1])

# if x is scalar and at least one of the two paraemters is a vector, both parameters are
# recycled to the same length, and dvm returns a vector of with ith element being the
# density evaluated at x with parameter values kappa[i] and mu[i]
dvm(x[1], kappa, mu)

# if x and at least one of the two paraemters is a vector, x and the two parameters are
# recycled to the same length, and dvm returns a vector of with ith element being the
# density at ith element of the (recycled) x with parameter values kappa[i] and mu[i]
dvm(x, kappa, mu)

# when parameters are all scalars, number of observations generated by rvm is n
rvm(n, kappa[1], mu[1])

# when at least one of the two parameters is a vector, both are recycled to the same length,
# n is ignored, and the number of observations generated by rvm is the same as the length of
# the recycled vectors
rvm(n, kappa, mu)

</code></pre>

<hr>
<h2 id='rvmcos'>The bivariate von Mises cosine model</h2><span id='topic+rvmcos'></span><span id='topic+dvmcos'></span>

<h3>Description</h3>

<p>The bivariate von Mises cosine model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvmcos(
  n,
  kappa1 = 1,
  kappa2 = 1,
  kappa3 = 0,
  mu1 = 0,
  mu2 = 0,
  method = "naive"
)

dvmcos(
  x,
  kappa1 = 1,
  kappa2 = 1,
  kappa3 = 0,
  mu1 = 0,
  mu2 = 0,
  log = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rvmcos_+3A_n">n</code></td>
<td>
<p>number of observations. Ignored if at least one of the other parameters have length k &gt; 1, in which
case, all the parameters are recycled to length k to produce k random variates.</p>
</td></tr>
<tr><td><code id="rvmcos_+3A_kappa1">kappa1</code>, <code id="rvmcos_+3A_kappa2">kappa2</code>, <code id="rvmcos_+3A_kappa3">kappa3</code></td>
<td>
<p>vectors of concentration parameters; <code>kappa1, kappa2 &gt; 0</code>.</p>
</td></tr>
<tr><td><code id="rvmcos_+3A_mu1">mu1</code>, <code id="rvmcos_+3A_mu2">mu2</code></td>
<td>
<p>vectors of mean parameters.</p>
</td></tr>
<tr><td><code id="rvmcos_+3A_method">method</code></td>
<td>
<p>Rejection sampling method to be used. Available choices are <code>"naive"</code> (default) or <code>"vmprop"</code>. See details.</p>
</td></tr>
<tr><td><code id="rvmcos_+3A_x">x</code></td>
<td>
<p>bivariate vector  or a two-column matrix with each row being a bivariate vector of angles
(in radians)  where the densities are to be evaluated.</p>
</td></tr>
<tr><td><code id="rvmcos_+3A_log">log</code></td>
<td>
<p>logical. Should the log density be returned instead?</p>
</td></tr>
<tr><td><code id="rvmcos_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to dvmcos. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bivariate von Mises cosine model density at the point <code class="reqn">x = (x_1, x_2)</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">f(x) = C_c (\kappa_1, \kappa_2, \kappa_3) \exp(\kappa_1 \cos(T_1) + \kappa_2 \cos(T_2) + \kappa_3 \cos(T_1 - T_2))</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">T_1 = x_1 - \mu_1;  T_2 = x_2 - \mu_2</code>
</p>

<p>and <code class="reqn">C_c (\kappa_1, \kappa_2, \kappa_3)</code> denotes the normalizing constant for the cosine model.
</p>
<p>Because <code class="reqn">C_c</code> involves an infinite  alternating series with product of Bessel functions,
if <code>kappa3 &lt; -5</code> or <code>max(kappa1, kappa2, abs(kappa3)) &gt; 50</code>, <code class="reqn">C_c</code> is evaluated
numerically via (quasi) Monte carlo method for
numerical stability. These (quasi) random numbers can be provided through the
argument <code>qrnd</code>, which must be a two column matrix, with each element being
a  (quasi) random number between 0 and 1. Alternatively, if <code>n_qrnd</code> is
provided (and <code>qrnd</code> is missing), a two dimensional sobol sequence of size <code>n_qrnd</code> is
generated via the function <a href="qrng.html#topic+sobol">sobol</a> from the R package <code>qrng</code>. If none of <code>qrnd</code>
or <code>n_qrnd</code> is available, a two dimensional sobol sequence of size 1e4 is used. By default Monte
Carlo approximation is used only if <code>kappa3 &lt; -5</code> or <code>max(kappa1, kappa2, abs(kappa3)) &gt; 50</code>.
However, a forced Monte Carlo approximation can be made (irrespective of the choice of <code>kappa1, kappa2</code> and
<code>kappa3</code>) by setting <code>force_approx_const = TRUE</code>. See examples.
</p>


<h3>Value</h3>

<p><code>dvmcos</code> gives the density  and <code>rvmcos</code> generates random deviates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kappa1 &lt;- c(1, 2, 3)
kappa2 &lt;- c(1, 6, 5)
kappa3 &lt;- c(0, 1, 2)
mu1 &lt;- c(1, 2, 5)
mu2 &lt;- c(0, 1, 3)
x &lt;- diag(2, 2)
n &lt;- 10

# when x is a bivariate vector and parameters are all scalars,
# dvmcos returns single density
dvmcos(x[1, ], kappa1[1], kappa2[1], kappa3[1], mu1[1], mu2[1])

# when x is a two column matrix and parameters are all scalars,
# dmvsin returns a vector of densities calculated at the rows of
# x with the same parameters
dvmcos(x, kappa1[1], kappa2[1], kappa3[1], mu1[1], mu2[1])

# if x is a bivariate vector and at least one of the parameters is
# a vector, all parameters are recycled to the same length, and
# dvmcos returns a vector with ith element being the density
# evaluated at x with parameter values kappa1[i], kappa2[i],
# kappa3[i], mu1[i] and mu2[i]
dvmcos(x[1, ], kappa1, kappa2, kappa3, mu1, mu2)

# if x is a two column matrix and at least one of the parameters is
# a vector, rows of x and the parameters are recycled to the same
# length, and dvmcos returns a vector with ith element being the
# density evaluated at ith row of x with parameter values kappa1[i],
# kappa2[i], # kappa3[i], mu1[i] and mu2[i]
dvmcos(x, kappa1, kappa2, kappa3, mu1, mu2)

# when parameters are all scalars, number of observations generated
# by rvmcos is n
rvmcos(n, kappa1[1], kappa2[1], kappa3[1], mu1[1], mu2[1])

# when at least one of the parameters is a vector, all parameters are
# recycled to the same length, n is ignored, and the number of
# observations generated by rvmcos is the same as the length of the
# recycled vectors
rvmcos(n, kappa1, kappa2, kappa3, mu1, mu2)



## Visualizing (quasi) Monte Carlo based approximations of
## the normalizing constant through density evaluations.

# "good" setup, where the analytic formula for C_c can be
# calculated without numerical issues
# kappa1 = 1, kappa2 = 1, kappa3 = -2, mu1 = pi, mu2 = pi

n_qrnd &lt;-  (1:500)*20
# analytic
good.a &lt;- dvmcos(c(3,3), 1, 1, -2, pi, pi, log=TRUE)
# using quasi Monte Carlo
good.q &lt;- sapply(n_qrnd,
                 function(j)
                   dvmcos(c(3,3), 1, 1, -2, pi, pi,
                          log=TRUE, n_qrnd = j,
                          force_approx_const = TRUE))
# using ordinary Monte Carlo
set.seed(1)
good.r &lt;- sapply(n_qrnd,
                 function(j)
                   dvmcos(c(3,3), 1, 1, -2, pi, pi,
                          log=TRUE,
                          qrnd = matrix(runif(2*j), ncol = 2),
                          force_approx_const = TRUE))


plot(n_qrnd, good.q, ylim = range(good.a, good.q, good.r),
     col = "orange", type = "l",
     ylab = "",
     main = "dvmcos(c(3,3), 1, 1, -2, pi, pi, log = TRUE)")
points(n_qrnd, good.r, col = "skyblue", type = "l")
abline(h = good.a, lty = 2, col = "grey")
legend("topright",
       legend = c("Sobol", "Random", "Analytic"),
       col = c("orange", "skyblue", "grey"),
       lty = c(1, 1, 2))


# "bad" setup, where the calculating C_c
# numerically using the analytic formula is problematic
# kappa1 = 100, kappa2 = 100, kappa3 = -200, mu1 = pi, mu2 = pi

n_qrnd &lt;-  (1:500)*20

# using quasi Monte Carlo
bad.q &lt;- sapply(n_qrnd,
                function(j)
                  dvmcos(c(3,3), 100, 100, -200, pi, pi,
                         log=TRUE, n_qrnd = j,
                         force_approx_const = TRUE))
# using ordinary Monte Carlo
set.seed(1)
bad.r &lt;- sapply(n_qrnd,
                function(j)
                  dvmcos(c(3,3), 100, 100, -200, pi, pi,
                         log=TRUE,
                         qrnd = matrix(runif(2*j), ncol = 2),
                         force_approx_const = TRUE))


plot(n_qrnd, bad.q, ylim = range(bad.q, bad.r),
     col = "orange", type = "l",
     ylab = "",
     main = "dvmcos(c(3,3), 100, 100, -200, pi, pi, log = TRUE)")
points(n_qrnd, bad.r, col = "skyblue", type = "l")
legend("topright",
       legend = c("Sobol", "Random"),
       col = c("orange", "skyblue"), lty = 1)


</code></pre>

<hr>
<h2 id='rvmcosmix'>The bivariate von Mises cosine model mixtures</h2><span id='topic+rvmcosmix'></span><span id='topic+dvmcosmix'></span>

<h3>Description</h3>

<p>The bivariate von Mises cosine model mixtures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvmcosmix(n, kappa1, kappa2, kappa3, mu1, mu2, pmix, method = "naive", ...)

dvmcosmix(x, kappa1, kappa2, kappa3, mu1, mu2, pmix, log = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rvmcosmix_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="rvmcosmix_+3A_kappa1">kappa1</code>, <code id="rvmcosmix_+3A_kappa2">kappa2</code>, <code id="rvmcosmix_+3A_kappa3">kappa3</code></td>
<td>
<p>vectors of concentration parameters; <code>kappa1, kappa2 &gt; 0</code> for each component.</p>
</td></tr>
<tr><td><code id="rvmcosmix_+3A_mu1">mu1</code>, <code id="rvmcosmix_+3A_mu2">mu2</code></td>
<td>
<p>vectors of mean parameters.</p>
</td></tr>
<tr><td><code id="rvmcosmix_+3A_pmix">pmix</code></td>
<td>
<p>vector of mixture proportions.</p>
</td></tr>
<tr><td><code id="rvmcosmix_+3A_method">method</code></td>
<td>
<p>Rejection sampling method to be used. Available choices are <code>"naive"</code> (default) or <code>"vmprop"</code>. See details.</p>
</td></tr>
<tr><td><code id="rvmcosmix_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to dvmcos. See details.</p>
</td></tr>
<tr><td><code id="rvmcosmix_+3A_x">x</code></td>
<td>
<p>matrix of angles (in radians) where the density is to be evaluated, with each row being a
single bivariate vector of angles.</p>
</td></tr>
<tr><td><code id="rvmcosmix_+3A_log">log</code></td>
<td>
<p>logical. Should the log density be returned instead?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All the argument vectors <code>pmix, kappa1, kappa2, kappa3, mu1</code> and <code>mu2</code> must be of
the same length ( = component size of the mixture model), with <code class="reqn">j</code>-th element corresponding to the
<code class="reqn">j</code>-th component of the mixture distribution.
</p>
<p>The bivariate von Mises cosine model mixture distribution with component size <code>K = <a href="base.html#topic+length">length</a>(pmix)</code> has density
</p>
<p style="text-align: center;"><code class="reqn">g(x) = \sum p[j] * f(x; \kappa_1[j], \kappa_2[j], \kappa_3[j], \mu_1[j], \mu_2[j])</code>
</p>

<p>where the sum extends over <code class="reqn">j</code>; <code class="reqn">p[j]; \kappa_1[j], \kappa_2[j], \kappa_3[j]</code>; and <code class="reqn">\mu_1[j], \mu_2[j]</code> respectively denote the mixing proportion,
the three concentration parameters and the two mean parameter for the <code class="reqn">j</code>-th cluster, <code class="reqn">j = 1, ..., K</code>,
and <code class="reqn">f(. ; \kappa_1, \kappa_2, \kappa_3, \mu_1, \mu_2)</code> denotes the density function of the von Mises cosine model
with concentration parameters <code class="reqn">\kappa_1, \kappa_2, \kappa_3</code> and  mean parameters <code class="reqn">\mu_1, \mu_2</code>.
</p>


<h3>Value</h3>

<p><code>dvmcosmix</code> computes the density  and <code>rvmcosmix</code> generates random deviates from the mixture density.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kappa1 &lt;- c(1, 2, 3)
kappa2 &lt;- c(1, 6, 5)
kappa3 &lt;- c(0, 1, 2)
mu1 &lt;- c(1, 2, 5)
mu2 &lt;- c(0, 1, 3)
pmix &lt;- c(0.3, 0.4, 0.3)
x &lt;- diag(2, 2)
n &lt;- 10

# mixture densities calculated at the rows of x
dvmcosmix(x, kappa1, kappa2, kappa3, mu1, mu2, pmix)

# number of observations generated from the mixture distribution is n
rvmcosmix(n, kappa1, kappa2, kappa3, mu1, mu2, pmix)

</code></pre>

<hr>
<h2 id='rvmmix'>The univariate von Mises mixtures</h2><span id='topic+rvmmix'></span><span id='topic+dvmmix'></span>

<h3>Description</h3>

<p>The univariate von Mises mixtures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvmmix(n, kappa, mu, pmix)

dvmmix(x, kappa, mu, pmix, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rvmmix_+3A_n">n</code></td>
<td>
<p>number of observations. Ignored if at least one of the other parameters have length k &gt; 1, in which
case, all the parameters are recycled to length k to produce k random variates.</p>
</td></tr>
<tr><td><code id="rvmmix_+3A_kappa">kappa</code></td>
<td>
<p>vector of component concentration (inverse-variance) parameters, <code>kappa &gt; 0</code>.</p>
</td></tr>
<tr><td><code id="rvmmix_+3A_mu">mu</code></td>
<td>
<p>vector of component means.</p>
</td></tr>
<tr><td><code id="rvmmix_+3A_pmix">pmix</code></td>
<td>
<p>vector of mixing proportions.</p>
</td></tr>
<tr><td><code id="rvmmix_+3A_x">x</code></td>
<td>
<p>vector of angles (in radians) where the densities are to be evaluated.</p>
</td></tr>
<tr><td><code id="rvmmix_+3A_log">log</code></td>
<td>
<p>logical. Should the log density be returned instead?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pmix</code>, <code>mu</code> and <code>kappa</code> must be of the same length, with <code class="reqn">j</code>-th element corresponding to the <code class="reqn">j</code>-th component of the mixture distribution.
</p>
<p>The univariate von Mises mixture distribution with component size <code>K = <a href="base.html#topic+length">length</a>(pmix)</code> has density
</p>
<p style="text-align: center;"><code class="reqn">g(x) = p[1] * f(x; \kappa[1], \mu[1]) + ... + p[K] * f(x; \kappa[K], \mu[K])</code>
</p>

<p>where <code class="reqn">p[j], \kappa[j], \mu[j]</code> respectively denote the mixing proportion, concentration parameter and the mean parameter for the <code class="reqn">j</code>-th component
and <code class="reqn">f(. ; \kappa, \mu)</code> denotes the density function of the (univariate) von Mises distribution with mean parameter <code class="reqn">\mu</code> and concentration parameter <code class="reqn">\kappa</code>.
</p>


<h3>Value</h3>

<p><code>dvmmix</code> computes the density  and <code>rvmmix</code> generates random deviates from the mixture density.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kappa &lt;- 1:3
mu &lt;- 0:2
pmix &lt;- c(0.3, 0.3, 0.4)
x &lt;- 1:10
n &lt;- 10

# mixture densities calculated at each point in x
dvmmix(x, kappa, mu, pmix)

# number of observations generated from the mixture distribution is n
rvmmix(n, kappa, mu, pmix)

</code></pre>

<hr>
<h2 id='rvmsin'>The bivariate von Mises sine model</h2><span id='topic+rvmsin'></span><span id='topic+dvmsin'></span>

<h3>Description</h3>

<p>The bivariate von Mises sine model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvmsin(
  n,
  kappa1 = 1,
  kappa2 = 1,
  kappa3 = 0,
  mu1 = 0,
  mu2 = 0,
  method = "naive"
)

dvmsin(x, kappa1 = 1, kappa2 = 1, kappa3 = 0, mu1 = 0, mu2 = 0, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rvmsin_+3A_n">n</code></td>
<td>
<p>number of observations. Ignored if at least one of the other parameters have length k &gt; 1, in which
case, all the parameters are recycled to length k to produce k random variates.</p>
</td></tr>
<tr><td><code id="rvmsin_+3A_kappa1">kappa1</code>, <code id="rvmsin_+3A_kappa2">kappa2</code>, <code id="rvmsin_+3A_kappa3">kappa3</code></td>
<td>
<p>vectors of concentration parameters; <code>kappa1, kappa2 &gt; 0</code>.</p>
</td></tr>
<tr><td><code id="rvmsin_+3A_mu1">mu1</code>, <code id="rvmsin_+3A_mu2">mu2</code></td>
<td>
<p>vectors of mean parameters.</p>
</td></tr>
<tr><td><code id="rvmsin_+3A_method">method</code></td>
<td>
<p>Rejection sampling method to be used. Available choices are <code>"naive"</code> (default) or <code>"vmprop"</code>. See details.</p>
</td></tr>
<tr><td><code id="rvmsin_+3A_x">x</code></td>
<td>
<p>bivariate vector  or a two-column matrix with each row being a bivariate vector of angles
(in radians)  where the densities are to be evaluated.</p>
</td></tr>
<tr><td><code id="rvmsin_+3A_log">log</code></td>
<td>
<p>logical. Should the log density be returned instead?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bivariate von Mises sine model density at the point <code class="reqn">x = (x_1, x_2)</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">f(x) = C_s (\kappa_1, \kappa_2, \kappa_3) \exp(\kappa_1 \cos(T_1) + \kappa_2 \cos(T_2) + \kappa_3 \sin(T_1) \sin(T_2))</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">T_1 = x_1 - \mu_1;  T_2 = x_2 - \mu_2</code>
</p>

<p>and <code class="reqn">C_s (\kappa_1, \kappa_2, \kappa_3)</code> denotes the normalizing constant for the sine model.
</p>
<p>Two different rejection sampling methods are implemented for random generation. If <code>method = "vmprop"</code>, then first the y-marginal
is drawn from the associated marginal density, and then x is generated from the conditional distributio of x given y. The marginal generation of
y is implemented in a rejection sampling scheme with proposal being either von Mises (if the target marginal density is unimodal), or a mixture of
von Mises (if bimodal), with optimally chosen concentration. This the method suggested in Mardia et al. (2007). On the other hand, when
<code>method = "naive"</code> (default) a (naive) bivariate rejection sampling scheme with (bivariate) uniform propsoal is used.
</p>
<p>Note that although method = <code>"vmprop"</code> may provide better efficiency when the density is highly concentrated, it does have
an (often substantial) overhead due to the optimziation step required to find a reasonable proposal concentration parameter.
This can compensate the efficiency gains of this method, especially when <code>n</code> is not large.
</p>


<h3>Value</h3>

<p><code>dvmsin</code> gives the density  and <code>rvmsin</code> generates random deviates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kappa1 &lt;- c(1, 2, 3)
kappa2 &lt;- c(1, 6, 5)
kappa3 &lt;- c(0, 1, 2)
mu1 &lt;- c(1, 2, 5)
mu2 &lt;- c(0, 1, 3)
x &lt;- diag(2, 2)
n &lt;- 10

# when x is a bivariate vector and parameters are all scalars,
# dvmsin returns single density
dvmsin(x[1, ], kappa1[1], kappa2[1], kappa3[1], mu1[1], mu2[1])

# when x is a two column matrix and parameters are all scalars,
# dmvsin returns a vector of densities calculated at the rows of
# x with the same parameters
dvmsin(x, kappa1[1], kappa2[1], kappa3[1], mu1[1], mu2[1])

# if x is a bivariate vector and at least one of the parameters is
# a vector, all parameters are recycled to the same length, and
# dvmsin returns a vector of with ith element being the density
# evaluated at x with parameter values kappa1[i], kappa2[i],
# kappa3[i], mu1[i] and mu2[i]
dvmsin(x[1, ], kappa1, kappa2, kappa3, mu1, mu2)

# if x is a two column matrix and at least one of the parameters is
# a vector, rows of x and the parameters are recycled to the same
# length, and dvmsin returns a vector of with ith element being the
# density evaluated at ith row of x with parameter values kappa1[i],
# kappa2[i], # kappa3[i], mu1[i] and mu2[i]
dvmsin(x[1, ], kappa1, kappa2, kappa3, mu1, mu2)

# when parameters are all scalars, number of observations generated
# by rvmsin is n
rvmsin(n, kappa1[1], kappa2[1], kappa3[1], mu1[1], mu2[1])

# when at least one of the parameters is a vector, all parameters are
# recycled to the same length, n is ignored, and the number of
# observations generated by rvmsin is the same as the length of the
# recycled vectors
rvmsin(n, kappa1, kappa2, kappa3, mu1, mu2)

</code></pre>

<hr>
<h2 id='rvmsinmix'>The bivariate von Mises sine model mixtures</h2><span id='topic+rvmsinmix'></span><span id='topic+dvmsinmix'></span>

<h3>Description</h3>

<p>The bivariate von Mises sine model mixtures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvmsinmix(n, kappa1, kappa2, kappa3, mu1, mu2, pmix, method = "naive")

dvmsinmix(x, kappa1, kappa2, kappa3, mu1, mu2, pmix, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rvmsinmix_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="rvmsinmix_+3A_kappa1">kappa1</code>, <code id="rvmsinmix_+3A_kappa2">kappa2</code>, <code id="rvmsinmix_+3A_kappa3">kappa3</code></td>
<td>
<p>vectors of concentration parameters; <code>kappa1, kappa2 &gt; 0</code> for each component.</p>
</td></tr>
<tr><td><code id="rvmsinmix_+3A_mu1">mu1</code>, <code id="rvmsinmix_+3A_mu2">mu2</code></td>
<td>
<p>vectors of mean parameters.</p>
</td></tr>
<tr><td><code id="rvmsinmix_+3A_pmix">pmix</code></td>
<td>
<p>vector of mixture proportions.</p>
</td></tr>
<tr><td><code id="rvmsinmix_+3A_method">method</code></td>
<td>
<p>Rejection sampling method to be used. Available choices are <code>"naive"</code> (default) or <code>"vmprop"</code>. See details.</p>
</td></tr>
<tr><td><code id="rvmsinmix_+3A_x">x</code></td>
<td>
<p>matrix of angles (in radians) where the density is to be evaluated, with each row being a
single bivariate vector of angles.</p>
</td></tr>
<tr><td><code id="rvmsinmix_+3A_log">log</code></td>
<td>
<p>logical. Should the log density be returned instead?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All the argument vectors <code>pmix, kappa1, kappa2, kappa3, mu1</code> and <code>mu2</code> must be of
the same length ( = component size of the mixture model), with <code class="reqn">j</code>-th element corresponding to the
<code class="reqn">j</code>-th component of the mixture distribution.
</p>
<p>The bivariate von Mises sine model mixture distribution with component size <code>K = <a href="base.html#topic+length">length</a>(p.mix)</code> has density
</p>
<p style="text-align: center;"><code class="reqn">g(x) = \sum p[j] * f(x; \kappa_1[j], \kappa_2[j], \kappa_3[j], \mu_1[j], \mu_2[j])</code>
</p>

<p>where the sum extends over <code class="reqn">j</code>; <code class="reqn">p[j]; \kappa_1[j], \kappa_2[j], \kappa_3[j]</code>; and <code class="reqn">\mu_1[j], \mu_2[j]</code> respectively denote the mixing proportion,
the three concentration parameters and the two mean parameter for the <code class="reqn">j</code>-th component, <code class="reqn">j = 1, ..., K</code>,
and <code class="reqn">f(. ; \kappa_1, \kappa_2, \kappa_3, \mu_1, \mu_2)</code> denotes the density function of the von Mises sine model
with concentration parameters <code class="reqn">\kappa_1, \kappa_2, \kappa_3</code> and  mean parameters <code class="reqn">\mu_1, \mu_2</code>.
</p>


<h3>Value</h3>

<p><code>dvmsinmix</code> computes the density (vector if x is a two column matrix with more than one row)
and <code>rvmsinmix</code> generates random deviates from the mixture density.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kappa1 &lt;- c(1, 2, 3)
kappa2 &lt;- c(1, 6, 5)
kappa3 &lt;- c(0, 1, 2)
mu1 &lt;- c(1, 2, 5)
mu2 &lt;- c(0, 1, 3)
pmix &lt;- c(0.3, 0.4, 0.3)
x &lt;- diag(2, 2)
n &lt;- 10

# mixture densities calculated at the rows of x
dvmsinmix(x, kappa1, kappa2, kappa3, mu1, mu2, pmix)

# number of observations generated from the mixture distribution is n
rvmsinmix(n, kappa1, kappa2, kappa3, mu1, mu2, pmix)

</code></pre>

<hr>
<h2 id='rwnorm'>The univariate Wrapped Normal distribution</h2><span id='topic+rwnorm'></span><span id='topic+dwnorm'></span>

<h3>Description</h3>

<p>The univariate Wrapped Normal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rwnorm(n = 1, kappa = 1, mu = 0)

dwnorm(x, kappa = 1, mu = 0, int.displ, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rwnorm_+3A_n">n</code></td>
<td>
<p>number of observations. Ignored if at least one of the other parameters have length k &gt; 1, in which
case, all the parameters are recycled to length k to produce k random variates.</p>
</td></tr>
<tr><td><code id="rwnorm_+3A_kappa">kappa</code></td>
<td>
<p>vector of concentration (inverse-variance) parameters; <code>kappa</code> &gt; 0.</p>
</td></tr>
<tr><td><code id="rwnorm_+3A_mu">mu</code></td>
<td>
<p>vector of means.</p>
</td></tr>
<tr><td><code id="rwnorm_+3A_x">x</code></td>
<td>
<p>vector of angles (in radians) where the densities are to be evaluated.</p>
</td></tr>
<tr><td><code id="rwnorm_+3A_int.displ">int.displ</code></td>
<td>
<p>integer displacement. If <code>int.displ =</code> M, then the infinite sum in the
density is approximated by a sum over 2*M + 1 elements. (See Details.) The allowed values are 1, 2, 3, 4 and 5. Default is 3.</p>
</td></tr>
<tr><td><code id="rwnorm_+3A_log">log</code></td>
<td>
<p>logical. Should the log density be returned instead?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>mu</code> and <code>kappa</code> are not specified they assume the default values of <code>0</code> and <code>1</code> respectively.
</p>
<p>The univariate wrapped normal distribution has density
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \sqrt(\kappa/(2\pi)) \sum \exp(-\kappa/2 (x - \mu(2\pi\omega))^2)</code>
</p>

<p>where the sum extends over all integers <code class="reqn">\omega</code>,
and is approximated by a sum over <code class="reqn">\omega</code> in <code class="reqn">\{-M, -M+1, ..., M-1, M \}</code> if <code>int.displ = </code> <code class="reqn">M</code>.
</p>


<h3>Value</h3>

<p><code>dwnorm</code> gives the density  and <code>rwnorm</code> generates random deviates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
kappa &lt;- 1:3
mu &lt;- 0:2
x &lt;- 1:10
n &lt;- 10


# when x and both parameters are scalars, dwnorm returns a single density
dwnorm(x[1], kappa[1], mu[1])

# when x is a vector but both the parameters are scalars, dmv returns a vector of
# densities calculated at each entry of x with the same parameters
dwnorm(x, kappa[1], mu[1])

# if x is scalar and at least one of the two paraemters is a vector, both parameters are
# recycled to the same length, and dwnorm returns a vector of with ith element being the
# density evaluated at x with parameter values kappa[i] and mu[i]
dwnorm(x[1], kappa, mu)

# if x and at least one of the two paraemters is a vector, x and the two parameters are
# recycled to the same length, and dwnorm returns a vector of with ith element being the
# density at ith element of the (recycled) x with parameter values kappa[i] and mu[i]
dwnorm(x, kappa, mu)

# when parameters are all scalars, number of observations generated by rwnorm is n
rwnorm(n, kappa[1], mu[1])

# when at least one of the two parameters is a vector, both are recycled to the same length,
# n is ignored, and the number of observations generated by rwnorm is the same as the length
# of the recycled vectors
rwnorm(n, kappa, mu)

</code></pre>

<hr>
<h2 id='rwnorm2'>The bivariate Wrapped Normal distribution</h2><span id='topic+rwnorm2'></span><span id='topic+dwnorm2'></span>

<h3>Description</h3>

<p>The bivariate Wrapped Normal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rwnorm2(n, kappa1 = 1, kappa2 = 1, kappa3 = 0, mu1 = 0, mu2 = 0, ...)

dwnorm2(
  x,
  kappa1 = 1,
  kappa2 = 1,
  kappa3 = 0,
  mu1 = 0,
  mu2 = 0,
  int.displ,
  log = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rwnorm2_+3A_n">n</code></td>
<td>
<p>number of observations. Ignored if at least one of the other parameters have length k &gt; 1, in which
case, all the parameters are recycled to length k to produce k random variates.</p>
</td></tr>
<tr><td><code id="rwnorm2_+3A_kappa1">kappa1</code>, <code id="rwnorm2_+3A_kappa2">kappa2</code>, <code id="rwnorm2_+3A_kappa3">kappa3</code></td>
<td>
<p>vectors of concentration parameters; <code>kappa1, kappa2 &gt; 0</code>,
and <code>kappa3^2 &lt; kappa1*kappa2</code>.</p>
</td></tr>
<tr><td><code id="rwnorm2_+3A_mu1">mu1</code>, <code id="rwnorm2_+3A_mu2">mu2</code></td>
<td>
<p>vectors of mean parameters.</p>
</td></tr>
<tr><td><code id="rwnorm2_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <a href="mvtnorm.html#topic+rmvnorm">rmvnorm</a> from package <code>mvtnorm</code></p>
</td></tr>
<tr><td><code id="rwnorm2_+3A_x">x</code></td>
<td>
<p>bivariate vector  or a two-column matrix with each row being a bivariate vector of angles
(in radians)  where the densities are to be evaluated.</p>
</td></tr>
<tr><td><code id="rwnorm2_+3A_int.displ">int.displ</code></td>
<td>
<p>integer displacement. If <code>int.displ =</code> M, then each infinite sum in the
density is approximated by a finite sum over 2*M + 1 elements. (See Details.) The allowed values are 1, 2, 3, 4 and 5. Default is 3.</p>
</td></tr>
<tr><td><code id="rwnorm2_+3A_log">log</code></td>
<td>
<p>logical. Should the log density be returned instead?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bivariate wrapped normal density at the point <code class="reqn">x = (x_1, x_2)</code> is given by,
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \sqrt((\kappa_1 \kappa_2 - (\kappa_3)^2)) / (2\pi) \sum \exp(-1/2 * (\kappa_1 (T_1)^2 + \kappa_2 (T_2)^2 + 2 \kappa_3 (T_1) (T_2)) )</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">T_1 = T_1(x, \mu, \omega) = (x_1 - \mu_1(2\pi\omega_1))</code>
</p>

<p style="text-align: center;"><code class="reqn">T_2 = T_2(x, \mu, \omega) = (x_2 - \mu_1(2\pi\omega_2))</code>
</p>

<p>the sum extends over all pairs of integers <code class="reqn">\omega = (\omega_1, \omega_2)</code>,
and is approximated by a sum over <code class="reqn">(\omega_1, \omega_2)</code> in <code class="reqn">\{-M, -M+1, ..., M-1, M \}^2</code> if <code>int.displ = </code> <code class="reqn">M</code>.
</p>
<p>Note that above density is essentially the &quot;wrapped&quot; version of a bivariate normal density with mean
</p>
<p style="text-align: center;"><code class="reqn">\mu = (\mu_1, \mu_2)</code>
</p>

<p>and dispersion matrix  <code class="reqn">\Sigma = \Delta^{-1}</code>, where
</p>

<table>
<tr>
 <td style="text-align: left;">
               </td><td style="text-align: right;"> <code class="reqn">\kappa_1</code> </td><td style="text-align: right;">  <code class="reqn"> </code> </td><td style="text-align: right;"> <code class="reqn">\kappa_3</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">\Delta =</code> </td><td style="text-align: right;"> <code class="reqn"> </code>        </td><td style="text-align: right;">  <code class="reqn"> </code> </td><td style="text-align: right;"> <code class="reqn"> </code> </td>
</tr>
<tr>
 <td style="text-align: left;">
               </td><td style="text-align: right;"> <code class="reqn">\kappa_3</code> </td><td style="text-align: right;">  <code class="reqn"> </code> </td><td style="text-align: right;">  <code class="reqn">\kappa_2</code>.
</td>
</tr>

</table>



<h3>Value</h3>

<p><code>dwnorm2</code> gives the density  and <code>rwnorm2</code> generates random deviates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kappa1 &lt;- c(1, 2, 3)
kappa2 &lt;- c(1, 6, 5)
kappa3 &lt;- c(0, 1, 2)
mu1 &lt;- c(1, 2, 5)
mu2 &lt;- c(0, 1, 3)
x &lt;- diag(2, 2)
n &lt;- 10

# when x is a bivariate vector and parameters are all scalars,
# dwnorm2 returns single density
dwnorm2(x[1, ], kappa1[1], kappa2[1], kappa3[1], mu1[1], mu2[1])

# when x is a two column matrix and parameters are all scalars,
# dmvsin returns a vector of densities calculated at the rows of
# x with the same parameters
dwnorm2(x, kappa1[1], kappa2[1], kappa3[1], mu1[1], mu2[1])

# if x is a bivariate vector and at least one of the parameters is
# a vector, all parameters are recycled to the same length, and
# dwnorm2 returns a vector of with ith element being the density
# evaluated at x with parameter values kappa1[i], kappa2[i],
# kappa3[i], mu1[i] and mu2[i]
dwnorm2(x[1, ], kappa1, kappa2, kappa3, mu1, mu2)

# if x is a two column matrix and at least one of the parameters is
# a vector, rows of x and the parameters are recycled to the same
# length, and dwnorm2 returns a vector of with ith element being the
# density evaluated at ith row of x with parameter values kappa1[i],
# kappa2[i], # kappa3[i], mu1[i] and mu2[i]
dwnorm2(x, kappa1, kappa2, kappa3, mu1, mu2)

# when parameters are all scalars, number of observations generated
# by rwnorm2 is n
rwnorm2(n, kappa1[1], kappa2[1], kappa3[1], mu1[1], mu2[1])

# when at least one of the parameters is a vector, all parameters are
# recycled to the same length, n is ignored, and the number of
# observations generated by rwnorm2 is the same as the length of the
# recycled vectors
rwnorm2(n, kappa1, kappa2, kappa3, mu1, mu2)

</code></pre>

<hr>
<h2 id='rwnorm2mix'>The bivariate Wrapped Normal mixtures</h2><span id='topic+rwnorm2mix'></span><span id='topic+dwnorm2mix'></span>

<h3>Description</h3>

<p>The bivariate Wrapped Normal mixtures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rwnorm2mix(n, kappa1, kappa2, kappa3, mu1, mu2, pmix, ...)

dwnorm2mix(x, kappa1, kappa2, kappa3, mu1, mu2, pmix, int.displ, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rwnorm2mix_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="rwnorm2mix_+3A_kappa1">kappa1</code>, <code id="rwnorm2mix_+3A_kappa2">kappa2</code>, <code id="rwnorm2mix_+3A_kappa3">kappa3</code></td>
<td>
<p>vectors of concentration parameters; <code>kappa1, kappa2 &gt; 0, kappa3^2 &lt; kappa1*kappa2</code> for each component.</p>
</td></tr>
<tr><td><code id="rwnorm2mix_+3A_mu1">mu1</code>, <code id="rwnorm2mix_+3A_mu2">mu2</code></td>
<td>
<p>vectors of mean parameters.</p>
</td></tr>
<tr><td><code id="rwnorm2mix_+3A_pmix">pmix</code></td>
<td>
<p>vector of mixture proportions.</p>
</td></tr>
<tr><td><code id="rwnorm2mix_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <a href="mvtnorm.html#topic+rmvnorm">rmvnorm</a> from package <code>mvtnorm</code></p>
</td></tr>
<tr><td><code id="rwnorm2mix_+3A_x">x</code></td>
<td>
<p>matrix of angles (in radians) where the density is to be evaluated, with each row being a
single bivariate vector of angles.</p>
</td></tr>
<tr><td><code id="rwnorm2mix_+3A_int.displ">int.displ</code></td>
<td>
<p>integer displacement. If <code>int.displ =</code> M, then each infinite sum in the
density is approximated by a finite sum over 2*M + 1 elements. (See Details.) The allowed values are 1, 2, 3, 4 and 5. Default is 3.</p>
</td></tr>
<tr><td><code id="rwnorm2mix_+3A_log">log</code></td>
<td>
<p>logical. Should the log density be returned instead?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All the argument vectors <code>pmix, kappa1, kappa2, kappa3, mu1</code> and <code>mu2</code> must be of the same length,
with <code class="reqn">j</code>-th element corresponding to the <code class="reqn">j</code>-th component of the mixture distribution.
</p>
<p>The bivariate wrapped normal mixture distribution with component size <code>K = <a href="base.html#topic+length">length</a>(pmix)</code> has density
</p>
<p style="text-align: center;"><code class="reqn">g(x) = \sum p[j] * f(x; \kappa_1[j], \kappa_2[j], \kappa_3[j], \mu_1[j], \mu_2[j])</code>
</p>

<p>where the sum extends over <code class="reqn">j</code>; <code class="reqn">p[j]; \kappa_1[j], \kappa_2[j], \kappa_3[j]</code>; and <code class="reqn">\mu_1[j], \mu_2[j]</code> respectively denote the mixing proportion,
the three concentration parameters and the two mean parameter for the <code class="reqn">j</code>-th component, <code class="reqn">j = 1, ..., K</code>,
and <code class="reqn">f(. ; \kappa_1, \kappa_2, \kappa_3, \mu_1, \mu_2)</code> denotes the density function of the wrapped normal distribution
with concentration parameters <code class="reqn">\kappa_1, \kappa_2, \kappa_3</code> and  mean parameters <code class="reqn">\mu_1, \mu_2</code>.
</p>


<h3>Value</h3>

<p><code>dwnorm2mix</code> computes the density  and <code>rwnorm2mix</code> generates random deviates from the mixture density.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kappa1 &lt;- c(1, 2, 3)
kappa2 &lt;- c(1, 6, 5)
kappa3 &lt;- c(0, 1, 2)
mu1 &lt;- c(1, 2, 5)
mu2 &lt;- c(0, 1, 3)
pmix &lt;- c(0.3, 0.4, 0.3)
x &lt;- diag(2, 2)
n &lt;- 10

# mixture densities calculated at the rows of x
dwnorm2mix(x, kappa1, kappa2, kappa3, mu1, mu2, pmix)

# number of observations generated from the mixture distribution is n
rwnorm2mix(n, kappa1, kappa2, kappa3, mu1, mu2, pmix)

</code></pre>

<hr>
<h2 id='rwnormmix'>The univariate Wrapped Normal mixtures</h2><span id='topic+rwnormmix'></span><span id='topic+dwnormmix'></span>

<h3>Description</h3>

<p>The univariate Wrapped Normal mixtures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rwnormmix(n = 1, kappa, mu, pmix)

dwnormmix(x, kappa, mu, pmix, int.displ = 3, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rwnormmix_+3A_n">n</code></td>
<td>
<p>number of observations. Ignored if at least one of the other parameters have length k &gt; 1, in which
case, all the parameters are recycled to length k to produce k random variates.</p>
</td></tr>
<tr><td><code id="rwnormmix_+3A_kappa">kappa</code></td>
<td>
<p>vector of component concentration (inverse-variance) parameters, <code>kappa &gt; 0</code>.</p>
</td></tr>
<tr><td><code id="rwnormmix_+3A_mu">mu</code></td>
<td>
<p>vector of component means.</p>
</td></tr>
<tr><td><code id="rwnormmix_+3A_pmix">pmix</code></td>
<td>
<p>vector of mixing proportions.</p>
</td></tr>
<tr><td><code id="rwnormmix_+3A_x">x</code></td>
<td>
<p>vector of angles (in radians) where the densities are to be evaluated.</p>
</td></tr>
<tr><td><code id="rwnormmix_+3A_int.displ">int.displ</code></td>
<td>
<p>integer displacement. If <code>int.displ =</code> M, then the infinite sum in the
density is approximated by a sum over 2*M + 1 elements. (See Details.) The allowed values are 1, 2, 3, 4 and 5. Default is 3.</p>
</td></tr>
<tr><td><code id="rwnormmix_+3A_log">log</code></td>
<td>
<p>logical. Should the log density be returned instead?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pmix</code>, <code>mu</code> and <code>kappa</code> must be of the same length, with <code class="reqn">j</code>-th element corresponding to the <code class="reqn">j</code>-th component of the mixture distribution.
</p>
<p>The univariate wrapped normal mixture distribution with component size <code>K = <a href="base.html#topic+length">length</a>(pmix)</code> has density
</p>
<p style="text-align: center;"><code class="reqn">g(x) = p[1] * f(x; \kappa[1], \mu[1]) + ... + p[K] * f(x; \kappa[K], \mu[K])</code>
</p>

<p>where <code class="reqn">p[j], \kappa[j], \mu[j]</code> respectively denote the mixing proportion, concentration parameter and the mean parameter for the <code class="reqn">j</code>-th component
and <code class="reqn">f(. ; \kappa, \mu)</code> denotes the density function of the (univariate) wrapped normal distribution with mean parameter <code class="reqn">\mu</code> and concentration parameter <code class="reqn">\kappa</code>.
</p>


<h3>Value</h3>

<p><code>dwnormmix</code> computes the density  and <code>rwnormmix</code> generates random deviates from the mixture density.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kappa &lt;- 1:3
mu &lt;- 0:2
pmix &lt;- c(0.3, 0.3, 0.4)
x &lt;- 1:10
n &lt;- 10

# mixture densities calculated at each point in x
dwnormmix(x, kappa, mu, pmix)

# number of observations generated from the mixture distribution is n
rwnormmix(n, kappa, mu, pmix)

</code></pre>

<hr>
<h2 id='select_chains'>Select chains from angmcmc objects</h2><span id='topic+select_chains'></span>

<h3>Description</h3>

<p>Select chains from angmcmc objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_chains(object, chain.no, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_chains_+3A_object">object</code></td>
<td>
<p>angular MCMC object.</p>
</td></tr>
<tr><td><code id="select_chains_+3A_chain.no">chain.no</code></td>
<td>
<p>labels of chains to be retained in the final sample. If missing,
all chains are used.</p>
</td></tr>
<tr><td><code id="select_chains_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns another angmcmc object with only selected chains passed through <code>chain.no</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># illustration only - more iterations needed for convergence
fit.vmsin.20 &lt;- fit_vmsinmix(tim8, ncomp = 3, n.iter =  20,
                             L = c(10, 12), chains_parallel = FALSE,
                             n.chains = 2)
fit.vmsin.20
fit.vmsin.20.1 &lt;- select_chains(fit.vmsin.20, 1)
fit.vmsin.20.1

</code></pre>

<hr>
<h2 id='summary.angmcmc'>Summary statistics for parameters from an angmcmc object</h2><span id='topic+summary.angmcmc'></span>

<h3>Description</h3>

<p>Summary statistics for parameters from an angmcmc object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'angmcmc'
summary(object, par.name, comp.label, chain.no, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.angmcmc_+3A_object">object</code></td>
<td>
<p>angular MCMC object.</p>
</td></tr>
<tr><td><code id="summary.angmcmc_+3A_par.name">par.name</code></td>
<td>
<p>vector of names of parameters for which point estimates are to be computed.  If <code>NULL</code>, results for all parameters are provided.</p>
</td></tr>
<tr><td><code id="summary.angmcmc_+3A_comp.label">comp.label</code></td>
<td>
<p>vector of component labels (positive integers, e.g., <code>1, 2, ...</code>) for which point estimates are to be computed.
If <code>NULL</code>, results for all components are provided.</p>
</td></tr>
<tr><td><code id="summary.angmcmc_+3A_chain.no">chain.no</code></td>
<td>
<p>vector of chain numbers whose samples are to be be used.
in the estimation. By default all chains are used.</p>
</td></tr>
<tr><td><code id="summary.angmcmc_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes (after thinning and discarding burn-in) point estimates with 95% posterior credible sets for all components and all parameters,
together with the sample averages of log likelihood and log posterior density.
</p>


<h3>Value</h3>

<p>Returns a list with elements <code>estimate, lower, upper, llik</code> and <code>lpd</code>. <code>estimate</code>
is itself a list with three elements: <code>mean</code>, <code>median</code> and <code>mode</code> providing the
sample mean, sample median and (sample) MAP estimates.
</p>
<p>Note that <code>summary.angmcmc</code> has its own print method, providing a table the estimated mean and 95% credible intervals for each parameter
</p>


<h3>Examples</h3>

<pre><code class='language-R'># illustration only - more iterations needed for convergence
fit.vmsin.20 &lt;- fit_vmsinmix(tim8, ncomp = 3, n.iter =  20,
                             n.chains = 1)
summary(fit.vmsin.20)

</code></pre>

<hr>
<h2 id='surface_model'>Surface for bivariate angular mixture model densities</h2><span id='topic+surface_model'></span>

<h3>Description</h3>

<p>Surface for bivariate angular mixture model densities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surface_model(
  model = "vmsin",
  kappa1,
  kappa2,
  kappa3,
  mu1,
  mu2,
  pmix = rep(1/length(kappa1), length(kappa1)),
  xpoints = seq(0, 2 * pi, length.out = 30),
  ypoints = seq(0, 2 * pi, length.out = 30),
  log.density = FALSE,
  xlab = "x",
  ylab = "y",
  zlab = ifelse(log.density, "Log Density", "Density"),
  main,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surface_model_+3A_model">model</code></td>
<td>
<p>bivariate angular model whose mixture is of interest. Must be one of
&quot;vmsin&quot;, &quot;vmcos&quot; and &quot;wnorm2&quot;.</p>
</td></tr>
<tr><td><code id="surface_model_+3A_kappa1">kappa1</code>, <code id="surface_model_+3A_kappa2">kappa2</code>, <code id="surface_model_+3A_kappa3">kappa3</code>, <code id="surface_model_+3A_mu1">mu1</code>, <code id="surface_model_+3A_mu2">mu2</code>, <code id="surface_model_+3A_pmix">pmix</code></td>
<td>
<p>model parameters and mixing
proportions. See the respective mixture model densities (<a href="#topic+dvmsinmix">dvmsinmix</a>, <a href="#topic+dvmcosmix">dvmcosmix</a>,
<a href="#topic+dwnorm2mix">dwnorm2mix</a>) for more details.</p>
</td></tr>
<tr><td><code id="surface_model_+3A_xpoints">xpoints</code></td>
<td>
<p>Points on the first (x-) coordinate where the density is to be evaluated.
Default to seq(0, 2*pi, length.out=100).</p>
</td></tr>
<tr><td><code id="surface_model_+3A_ypoints">ypoints</code></td>
<td>
<p>Points on the first (x-) coordinate where the density is to be evaluated.
Default to seq(0, 2*pi, length.out=100).</p>
</td></tr>
<tr><td><code id="surface_model_+3A_log.density">log.density</code></td>
<td>
<p>logical. Should log density be used for the plot?</p>
</td></tr>
<tr><td><code id="surface_model_+3A_xlab">xlab</code>, <code id="surface_model_+3A_ylab">ylab</code>, <code id="surface_model_+3A_zlab">zlab</code>, <code id="surface_model_+3A_main">main</code></td>
<td>
<p>graphical parameters passed to <code>lattice::wireframe</code></p>
</td></tr>
<tr><td><code id="surface_model_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>lattice::wireframe</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>surface_model('vmsin', 1, 1, 1.5, pi, pi)
surface_model('vmcos', 1, 1, 1.5, pi, pi)

</code></pre>

<hr>
<h2 id='tim8'>Backbone Dihedral Angles of Triose Phosphate Isomerase (8TIM)</h2><span id='topic+tim8'></span>

<h3>Description</h3>

<p>A dataset consisting of 490 pairs of backbone dihedral angles (in radian scale <code class="reqn">[0, 2\pi)</code> )
<code class="reqn">(\phi, \psi)</code> for the protein Triose Phosphate Isomerase (8TIM). The angles were obtained first by using
the DSSP software on the PDB file for 8TIM to get the backbone angles (in degrees),
and then by converting all angles into radians. Due to the presence of different secondary structures
(helices, sheets and loops) in the protein, the angular data show considerable variability, and is multimodal
with noticeably distinct clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tim8)
</code></pre>


<h3>Format</h3>

<p>A data frame with 490 rows and 2 variables (backbone dihedral angles) phi and psi.
</p>


<h3>Source</h3>

<p>8TIM PDB file: <a href="http://www.rcsb.org/pdb/explore.do?structureId=8tim">http://www.rcsb.org/pdb/explore.do?structureId=8tim</a>.
</p>
<p>DSSP software: <a href="https://swift.cmbi.umcn.nl/gv/dssp/">https://swift.cmbi.umcn.nl/gv/dssp/</a>.
</p>

<hr>
<h2 id='vm2_mle'>Maximum likelihood estimation of bivariate von Mises parameters</h2><span id='topic+vm2_mle'></span>

<h3>Description</h3>

<p>Maximum likelihood estimation of bivariate von Mises parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vm2_mle(data, model = c("vmsin", "vmcos"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vm2_mle_+3A_data">data</code></td>
<td>
<p>data matrix (if bivarate, in which case it must have two columns) or vector. If outside, the values
are transformed into the scale <code class="reqn">[0, 2\pi)</code>. *Note:* BAMBI cannot handle missing data. Missing values must
either be removed or properly imputed.</p>
</td></tr>
<tr><td><code id="vm2_mle_+3A_model">model</code></td>
<td>
<p>Bivariate von Mises model. One of &quot;vmsin&quot;, &quot;vmcos&quot; or &quot;indep&quot;.</p>
</td></tr>
<tr><td><code id="vm2_mle_+3A_...">...</code></td>
<td>
<p>Additional arguments. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameters <code>kappa1</code> and <code>kappa2</code> are optimized
in log scales. The method of optimization used (passed to <a href="stats.html#topic+optim">optim</a>)
can be specified through <code>method</code> in <code>...</code>
(defaults to <code>"L-BFGS-B"</code>). Note, however, that
lower (0)  and upper (2*pi) bounds for <code>mu1</code> and <code>mu2</code>
are specified; so not all methods implemented in <a href="stats.html#topic+optim">optim</a> will work.
</p>


<h3>Value</h3>

<p>An object of class <a href="stats4.html#topic+mle-class">mle-class</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pars &lt;- list(kappa1 = 3, kappa2 = 2, kappa3 = 1.5, mu1 = 0.5, mu2 = 1.5)
nsamp &lt;- 2000
model &lt;- "vmsin"
set.seed(100)
dat_gen &lt;- do.call(paste0("r", model), c(list(n = nsamp), pars))

est &lt;- vm2_mle(dat_gen, model = model)
library(stats4)
coef(est)
vcov(est)
</code></pre>

<hr>
<h2 id='waic.angmcmc'>Watanabe-Akaike Information Criterion (WAIC) for angmcmc objects</h2><span id='topic+waic.angmcmc'></span>

<h3>Description</h3>

<p>Watanabe-Akaike Information Criterion (WAIC) for angmcmc objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'angmcmc'
waic(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="waic.angmcmc_+3A_x">x</code></td>
<td>
<p>angmcmc object.</p>
</td></tr>
<tr><td><code id="waic.angmcmc_+3A_...">...</code></td>
<td>
<p>additional model specific arguments to be passed to <a href="loo.html#topic+waic">waic</a> from loo. For example, <code>int.displ</code>
specifies integer displacement in wnorm and wnorm2 models. See <a href="#topic+fit_wnormmix">fit_wnormmix</a> and
<a href="#topic+fit_wnorm2mix">fit_wnorm2mix</a> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a deviance function <code class="reqn">D(\eta) = -2 \log(p(y|\eta))</code>, and an estimate
<code class="reqn">\eta* = (\sum \eta_i) / n</code> of the posterior mean
<code class="reqn">E(\eta|y)</code>, where <code class="reqn">y = (y_1, ..., y_n)</code> denote the data, <code class="reqn">\eta</code> is the unknown
parameter vector of the model, <code class="reqn">\eta_1, ..., \eta_N</code> are MCMC samples from the posterior
distribution of <code class="reqn">\eta</code> given <code class="reqn">y</code> and <code class="reqn">p(y|\eta)</code> is the likelihood function,
the Watanabe-Akaike Information Criterion (WAIC) is defined as
</p>
<p style="text-align: center;"><code class="reqn">WAIC = LPPD - p_W</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">LPPD  = \sum_{i=1}^n \log (N^{-1} \sum_{s=1}^N p(y_i|\eta_s) )</code>
</p>

<p>and (form 1 of)
</p>
<p style="text-align: center;"><code class="reqn">p_W =  2 \sum_{i=1}^n [ \log (N^{-1} \sum_{s=1}^N p(y_i|\eta_s) ) - N^{-1} \sum_{s=1}^N \log \:p(y_i|\eta_s) ].</code>
</p>

<p>An alternative form (form 2) for <code class="reqn">p_W</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">p_W = \sum_{i=1}^n \hat{var} \log p(y_i|\eta)</code>
</p>

<p>where for <code class="reqn">i = 1, ..., n</code>, <code class="reqn">\hat{var} \log p(y_i|\eta)</code> denotes the estimated variance
of <code class="reqn">\log p(y_i|\eta)</code> based on the realizations <code class="reqn">\eta_1, ..., \eta_N</code>.
</p>
<p>Note that waic.angmcmc calls <a href="loo.html#topic+waic">waic</a> for computation. If the likelihood contribution of each data
point for each MCMC iteration is available in <code>object</code> (can be returned by setting <code>return_llik_contri = TRUE</code>)
during <a href="#topic+fit_angmix">fit_angmix</a> call), <code>waic.array</code> is used; otherwise <code>waic.function</code> is
called. Computation is much faster if the likelihood contributions are available - however, they are very
memory intensive, and by default not returned in <a href="#topic+fit_angmix">fit_angmix</a>.
</p>


<h3>Value</h3>

<p>Computes the WAIC for a given angmcmc object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># illustration only - more iterations needed for convergence
fit.vmsin.20 &lt;- fit_vmsinmix(tim8, ncomp = 3, n.iter =  20,
                             n.chains = 1, return_llik_contri = TRUE)
library(loo)
waic(fit.vmsin.20)

</code></pre>

<hr>
<h2 id='wind'>Saturna Island wind directions</h2><span id='topic+wind'></span>

<h3>Description</h3>

<p>A dataset consisting of 239 observations on wind direction in radians (original measurements were
in 10s of degrees), measured at Saturna Island, British Columbia,
Canada during October 1-10, 2016 (obtained from Environment Canada website). There was a severe storm
during October 4-7, which caused significant fluctuations among the wind directions. As a result the
angular data show a clear multimodality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wind)
</code></pre>


<h3>Format</h3>

<p>A data frame with 239 rows and 2 columns; the column &quot;angle&quot; provides the angular direction (in radian)
and the column day provides the days on which the data points were collected (ranges between 1-10, corresponding to
October 1-10, 2016).
</p>


<h3>Source</h3>

<p>Environment Canada: <a href="https://climate.weather.gc.ca/climate_data/data_quality_e.html">https://climate.weather.gc.ca/climate_data/data_quality_e.html</a>.
</p>
<p>CBC news on the storm: <a href="https://www.cbc.ca/news/canada/british-columbia/storm-bc-1.3795204">https://www.cbc.ca/news/canada/british-columbia/storm-bc-1.3795204</a>.
</p>

<hr>
<h2 id='zero_to_2pi'>Wrap angles into <code>[-pi, pi]</code> or <code>[0, 2*pi]</code></h2><span id='topic+zero_to_2pi'></span><span id='topic+minuspi_to_pi'></span>

<h3>Description</h3>

<p>Wrap angles into <code>[-pi, pi]</code> or <code>[0, 2*pi]</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zero_to_2pi(x)

minuspi_to_pi(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zero_to_2pi_+3A_x">x</code></td>
<td>
<p>numeric vector or matrix or data.frame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>minuspi_to_pi</code> wraps <code>x</code> into <code>[-pi, pi]</code>,
while <code>zero_to_pi</code> wraps <code>x</code> into <code>[0, 2*pi]</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- matrix(runif(100, -pi, pi), ncol=2)
dat1 &lt;- zero_to_2pi(dat)
dat2 &lt;- minuspi_to_pi(dat1)
all.equal(dat, dat2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
