<!DOCTYPE html><html><head><title>Help for package GRCdata</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GRCdata}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#GRCdata-package'>
<p>Parameter inference and optimal designs for grouped and/or right-censored count data</p></a></li>
<li><a href='#find.scheme'>
<p>Search for the global optimal grouping scheme of grouped and/or right-censored count data</p></a></li>
<li><a href='#grcmle'>
<p>Maximum likelihood estimation of Poisson or ZIP parameters at the aggregate level.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Parameter Inference and Optimal Designs for Grouped and/or
Right-Censored Count Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-07-28</td>
</tr>
<tr>
<td>Author:</td>
<td>Xin Guo &lt;x.guo@polyu.edu.hk&gt;, Qiang Fu &lt;qiang.fu@ubc.ca&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xin Guo &lt;x.guo@polyu.edu.hk&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>nloptr, cubature</td>
</tr>
<tr>
<td>Description:</td>
<td>We implement two main functions.
    The first function uses a given grouped and/or
    right-censored grouping scheme and empirical data to infer parameters,
    and implements chi-square goodness-of-fit tests.
    The second function searches for the global optimal grouping
    scheme of grouped and/or right-censored count responses in surveys.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-08-19 01:30:21 UTC; xin</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-08-20 16:47:38 UTC</td>
</tr>
</table>
<hr>
<h2 id='GRCdata-package'>
Parameter inference and optimal designs for grouped and/or right-censored count data
</h2><span id='topic+GRCdata-package'></span><span id='topic+GRCdata'></span>

<h3>Description</h3>

<p>This package consists of two main functions:
The first function uses a given grouped and/or right-censored grouping scheme and empirical data to infer parameters, and implements chi-square goodness-of-fit tests;
The second function searches for the global optimal grouping scheme of grouped and/or right-censored count responses in surveys.
</p>
<p>This R package is designed to implement methods and algorithms developed in the following papers and please cite these articles at your convenience:
</p>
<p>Qiang Fu, Xin Guo and Kenneth C. Land. Forthcoming. &quot;A Poisson-Multinomial Mixture Approach to Grouped and Right-Censored Counts.&quot; Communications in Statistics &ndash; Theory and Methods.
DOI: 10.1080/03610926.2017.1303736
(mainly about the first function for aggregate-level parameter inference)
</p>
<p>Qiang Fu, Xin Guo and Kenneth C. Land. Conditionally accepted. &quot;Optimizing Count Responses in Surveys: A Machine-Learning Approach.&quot; Sociological Methods &amp; Research. 
(mainly about the second function for finding optimal grouping schemes)
</p>
<p>To install the package &quot;GRCdata_1.0.tar.gz&quot;, one may place this
file in the working directory/folder of R, and type
</p>
<p><code>install.packages("GRCdata", repos = NULL, type = "source")</code>
</p>
<p>To check the current working directory of R, one may type
</p>
<p><code>getwd()</code>
</p>
<p>To see the source code, one could extract the package &ldquo;GRCdata_1.0.tar.gz&rdquo;.
There would be two directories/folders: <code>man</code> and <code>R</code>. The source code
is under the <code>R</code> directory/folder.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> GRCdata</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> July 28, 2017</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPLv3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Authors: Xin Guo &lt;x.guo@polyu.edu.hk&gt;, Qiang Fu &lt;qiang.fu@ubc.ca&gt;
</p>
<p>Maintainers: Xin Guo &lt;x.guo@polyu.edu.hk&gt;
</p>


<h3>References</h3>

<p>Qiang Fu, Xin Guo and Kenneth C. Land. Conditionally accepted. &quot;Optimizing Count Responses in Surveys: A Machine-Learning Approach.&quot; Sociological Methods &amp; Research. 
</p>
<p>Qiang Fu, Xin Guo and Kenneth C. Land. Forthcoming. &quot;A Poisson-Multinomial Mixture Approach to Grouped and Right-Censored Counts.&quot; Communications in Statistics &ndash; Theory and Methods.
DOI: 10.1080/03610926.2017.1303736  
</p>

<hr>
<h2 id='find.scheme'>
Search for the global optimal grouping scheme of grouped and/or right-censored count data
</h2><span id='topic+find.scheme'></span>

<h3>Description</h3>

<p>Given the prior distribution (or values) of parameters,
and the total/maximum number of groups (N) allowed for grouping schemes,
this function finds the global optimal grouping scheme that makes
the sampling process most informative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.scheme(N,
  densityFUN, lambda.lwr, lambda.upr, p.lwr, p.upr,
  probs, lambdas, ps,
  is.0.isolated = TRUE, model = c("Poisson", "ZIP"),
  matSc = c("A", "D", "E"), M = "auto")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.scheme_+3A_n">N</code></td>
<td>

<p>(maximum) number of groups allowed for all grouping schemes. A non-integral value will be coerced to an integer.
</p>
</td></tr>
<tr><td><code id="find.scheme_+3A_densityfun">densityFUN</code>, <code id="find.scheme_+3A_lambda.lwr">lambda.lwr</code>, <code id="find.scheme_+3A_lambda.upr">lambda.upr</code>, <code id="find.scheme_+3A_p.lwr">p.lwr</code>, <code id="find.scheme_+3A_p.upr">p.upr</code></td>
<td>

<p>prior information of parameters in a continuous form.
These parameters denote the prior probability density function (optional),
the lower bound of <code class="reqn">\lambda</code> (for Poisson models), the higher bound of <code class="reqn">\lambda</code> (for Poisson models),
the lower bound of <code>p</code> (optional for ZIP models),
the higher bound of <code>p</code> (optional for ZIP models), respectively.
</p>
</td></tr>
<tr><td><code id="find.scheme_+3A_probs">probs</code>, <code id="find.scheme_+3A_lambdas">lambdas</code>, <code id="find.scheme_+3A_ps">ps</code></td>
<td>

<p>prior information of the parameters in a discrete form.
These parameters are vectors denoting the mass probabilities, the corresponding values of <code class="reqn">\lambda</code> and <code>p</code> (optional), respectively.
</p>
</td></tr>
<tr><td><code id="find.scheme_+3A_is.0.isolated">is.0.isolated</code></td>
<td>

<p>a logical value indicating whether zero is contained and only contained in a single group.
</p>
</td></tr>
<tr><td><code id="find.scheme_+3A_model">model</code></td>
<td>

<p>underlying Poisson models to be used for optimal designs: <code>Poisson</code> or <code>ZIP</code>.
The default value is <code>Poisson</code>.
</p>
</td></tr>
<tr><td><code id="find.scheme_+3A_matsc">matSc</code></td>
<td>

<p>A character indicating types of optimality functions of the Fisher information (matrix).
It must be one from the three letters: <code>A</code>, <code>D</code>, and <code>E</code>.
In particular,
if <code>J</code> is the 2-by-2 Fisher information matrix, then
</p>
<p><code>"A"</code> or A-optimality maximizes <code class="reqn">1/\mathrm{tr}(J^{-1})</code>;
</p>
<p><code>"D"</code> or D-optimality maximizes <code class="reqn">\mathrm{det}(J)</code>;
</p>
<p><code>"E"</code> or E-optimality maximizes the minimum eigenvalue of <code class="reqn">J</code>.
</p>
</td></tr>
<tr><td><code id="find.scheme_+3A_m">M</code></td>
<td>

<p>a sufficiently large integer needed to facilitate the search, or a character <code>"auto"</code>.
Theoretically, it could be the lowest integer contained in the last right-censored
group of the global optimal grouping scheme. A non-integral value will be coerced to an integer.
If <code>M</code> is set to be <code>"auto"</code>, the algorithm takes longer time to converge
because it will automatically determine <code>M</code> and return the global optimal
grouping scheme;
The default value of <code>M</code> is <code>"auto"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tries to find the N-group scheme maximizing Fisher information (matrix).
If <code>model</code> is specified as Poisson, <code>p.lwr</code> or <code>p.upr</code> will be ignored.
When the prior distribution is discrete, <code>lambdas</code> specify discrete values that <code class="reqn">\lambda</code> may take,
and <code>probs</code> specify probabilities associated with <code>p</code>.
In the ZIP model, <code>lambdas</code> and <code>ps</code> specify discrete values that <code class="reqn">\lambda</code> and p may take, respectively.
<code>probs</code> denotes joint mass probabilities associated with (<code class="reqn">\lambda</code>, p). The values of
(p.lwr, p.upr) cannot be (0, 1) as the algorithm will not converge. Instead, approximate values, such as
(0.000001, 0.999999), can be used.
</p>
<p>A sufficiently large integer <code>M</code> should be provided by the user so that infinitely many grouping schemes
could be handled by the search algorithm. <code>M</code> is in theory the lowest integer to be contained in the last
right-censored group of the global optimal grouping scheme. In practice, the choice of <code>M</code> should be slightly higher than
its theoretical value because the search algorithem is designed in a way that it prevents any acceptance of a false optimal
solution at the cost of tolerating false rejection of the correct optimal grouping scheme. This idea is implemented by
a logical indicator <code>succeed</code> in the output. Its value will be <code>TRUE</code> if the real optimal grouping scheme is identified.
Otherwise, a <code>FALSE</code> output means that <code>M</code> is not large enough to gurantee that the grouping scheme yielded by
the search algorithm is the global optimal grouping scheme. Researchers then need to select a larger <code>M</code> and repeat this
process until the logical indicator <code>succeed</code> becomes <code>TRUE</code>. Alternatively, users may use the <code>"auto"</code> option so that
this iterative process will be automatically implemented.
</p>


<h3>Value</h3>

<p>The returned value is a list with components.
</p>
<table>
<tr><td><code>best.scheme.compact</code>, <code>best.scheme.loose</code>, <code>best.scheme.innerCode</code></td>
<td>
<p>the same optimal grouping scheme is printed in various forms.</p>
</td></tr>
<tr><td><code>succeed</code></td>
<td>
<p>see Details. This is a logical variable. The global optimal grouping scheme is obtained if it is <code>TRUE</code>;
a larger <code>M</code> needs to be selected for a successful search if it is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xin Guo &lt;x.guo@polyu.edu.hk&gt;, Qiang Fu &lt;qiang.fu@ubc.ca&gt;
</p>


<h3>References</h3>

<p>Qiang Fu, Xin Guo and Kenneth C. Land. Conditionally accepted. &quot;Optimizing Count Responses in Surveys: A Machine-Learning Approach.&quot; Sociological Methods &amp; Research.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1 ####################################
# M=7, N=3, 0 is not required to be contained
# in a separate group of grouping schemes.
# Poisson model, lambda takes 4 and 5 and each value has a probability of 0.5.
find.scheme(probs = c(0.5, 0.5), lambdas = c(4,5),
  M = 7, N = 3, is.0.isolated = FALSE, model = "Poisson")

# Example 2 ####################################
# N=3, 0 is required to be contained in a separate group of grouping schemes.
# Poisson model, lambda takes 4 and 5 and each value has a probability of 0.5.
# M is not given, so it will be selected automatically.
find.scheme(probs = c(0.5, 0.5), lambdas = c(4,5),
  N = 3, is.0.isolated = TRUE, model = "Poisson")

# Example 3 ####################################
# M=7, N=3, 0 is not required to be contained in a separate group.
# ZIP model, (lambda, p) take (4, 0.3) and (5, 0.4)
# with their probabilities denoted by c(0.5, 0.5)

find.scheme(probs = c(0.5, 0.5), lambdas = c(4,5), ps = c(0.3, 0.5),
  M = 7, N = 3, is.0.isolated = FALSE, model = "ZIP")


# Example 4 ####################################
# N=3, 0 is not required to be contained in a separate group.
# Poisson model, lambda takes a normal distribution truncated to [1, 10]
# M is not given, so it will be selected automatically.

find.scheme(densityFUN = function(lambda)
  dnorm(lambda, mean = 3, sd = 1),
  lambda.lwr = 1, lambda.upr = 10,
  N = 3, is.0.isolated = FALSE, model = "Poisson")


# Example 5 ####################################
# M=7, N=3, 0 is required to be contained in a separate group.
# Poisson model, lambda takes a normal distribution truncated to [1, 10]

find.scheme(densityFUN = function(lambda)
  dnorm(lambda, mean = 3, sd = 1),
  lambda.lwr = 1, lambda.upr = 10,
  M = 7, N = 3, is.0.isolated = TRUE, model = "Poisson")


# Example 6 ####################################
# N=3, 0 is required to be contained in a separate group.
# Poisson model, lambda takes an uniform distribution on [1, 10]
# M is not given, so it will be selected automatically.
find.scheme(densityFUN = function(lambda)
  dunif(lambda, min = 1, max = 10),
  lambda.lwr = 1, lambda.upr = 10,
  N = 3, is.0.isolated = TRUE, model = "Poisson")

# Example 7 #################################
# M=7, N=3, 0 is required to be contained in a separate group.
# ZIP model, (lambda, p) has an uniform distribution with
# lambda on [1,10] and p on [0.1, 0.9]

find.scheme(densityFUN = function(...) 1,
  lambda.lwr = 1, lambda.upr = 10, p.lwr = 0.0001, p.upr = 0.9999,
  M = 7, N = 3, is.0.isolated = TRUE, model = "ZIP")


# Example 8 ####################################
# M=7, N=3, 0 is required to be contained in a separate group.
# ZIP model, (lambda, p) has a normal distribution centered
# at (5.5, 0.5) with a covariance matrix showing their correlation
#    /                 \
#    |  11/3      3    |
#    |    3     11/3   |
#    \                 /.
# This normal distribution is also truncated to
# [1, 10] X [0.1, 0.9]
# Note: this example may take several minutes to converge,
# depending on your computer configuration.

dsty &lt;- function(lambda, p){
  vec &lt;- c(lambda - 5.5, p - 0.5)
  mat &lt;- matrix(c(11/3,3,3,11/3), nrow = 2, ncol = 2)
  pw &lt;- -0.5 * sum(vec * solve(mat, vec))
  return(exp(pw))
}
find.scheme(densityFUN = dsty,
  lambda.lwr = 1, lambda.upr = 10, p.lwr = 0.1, p.upr = 0.9,
  M = 7, N = 3, is.0.isolated = TRUE, model = "ZIP")

</code></pre>

<hr>
<h2 id='grcmle'>
Maximum likelihood estimation of Poisson or ZIP parameters at the aggregate level.
</h2><span id='topic+grcmle'></span>

<h3>Description</h3>

<p>This function infers Poisson or zero-inflated Poisson (ZIP) parameters from grouped and right-censored count data,
and conducts a chi-squared goodness-of-fit test.
A grouped and right-censored scheme may look like
</p>
<p><code>  0, 1, 2--4, 5--8, 9+.</code>
</p>
<p>For grouped and right-censored count data collected in a survey, such as frequency of alcohol drinking, number of births or occurrence of crimes,
the response category designed as the example above means never, once, 2 to 4 times, 5 to 8 times, 9 times and more.
The frequency distribution from a sample corresponding to the example above may look like
</p>
<p><code>  3, 15, 168, 155, 15</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grcmle(counts, scheme, method = c("Poisson", "ZIP"),
  do.plot = T, init.guess = NULL,
  optimizing.algorithm.index = 2, lambda.extend.ratio = 3,
  conf.level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grcmle_+3A_counts">counts</code></td>
<td>

<p>specifies the frequency distribution of the grouped and right-censored count data. For the example above, one may input
</p>
<p><code>  counts = c(3, 15, 168, 155, 15)</code>.
</p>
</td></tr>
<tr><td><code id="grcmle_+3A_scheme">scheme</code></td>
<td>

<p>specifies the grouping scheme. It should be a vector of integers containing the starting
point (or the lowest integer) of each group. For example, to input the scheme above
</p>
<p><code>  0, 1, 2--4, 5--8, 9+,</code>
</p>
<p>one may use
</p>
<p><code>  scheme = c(0, 1, 2, 5, 9)</code>.
</p>
</td></tr>
<tr><td><code id="grcmle_+3A_method">method</code></td>
<td>

<p>a string parameter specifies which statistical model to use. Currently there are two options
<code>"Poisson"</code> and <code>"ZIP"</code>. The default value is <code>"Poisson"</code>.
It can be abbreviated.
</p>
</td></tr>
<tr><td><code id="grcmle_+3A_do.plot">do.plot</code></td>
<td>

<p>a logical variable indicating whether or not to plot the log likelihood.
The default is <code>T</code>.
</p>
</td></tr>
<tr><td><code id="grcmle_+3A_init.guess">init.guess</code></td>
<td>

<p>the initial value used for the optimization procedure of the likelihood estimation. The default value
is <code>NULL</code>, which instructs the function <code>grcmle</code> to select the initial value automatically.
</p>
</td></tr>
<tr><td><code id="grcmle_+3A_optimizing.algorithm.index">optimizing.algorithm.index</code></td>
<td>

<p>defines which optimization algorithm to use. Currently the possible values are <code>1,2,3,4,5,6,7</code> and <code>8</code>,
representing the following algorithms, respectively:
</p>
<p><code>  NLOPT_GN_DIRECT_L</code>
</p>
<p><code>  NLOPT_GN_DIRECT</code>
</p>
<p><code>  NLOPT_GN_DIRECT_L_RAND</code>
</p>
<p><code>  NLOPT_GN_DIRECT_NOSCAL</code>
</p>
<p><code>  NLOPT_GN_DIRECT_L_NOSCAL</code>
</p>
<p><code>  NLOPT_GN_DIRECT_L_RAND_NOSCAL</code>
</p>
<p><code>  NLOPT_GN_ORIG_DIRECT</code>
</p>
<p><code>  NLOPT_GN_ORIG_DIRECT_L</code>
</p>
<p>For details of these algorithms, please see the manual of the <span class="rlang"><b>R</b></span> package <code>"nloptr"</code>.
The default value is 2.
</p>
</td></tr>
<tr><td><code id="grcmle_+3A_lambda.extend.ratio">lambda.extend.ratio</code></td>
<td>

<p>specifies the searching interval of possible <code class="reqn">\lambda</code> as <code class="reqn">[0, nr]</code>, where <code class="reqn">n</code> is the left end (i.e., the lowest integer)
of the last right-censored group, and <code class="reqn">r</code> is <code>lambda.extend.ratio</code>. By default,
we set
</p>
<p><code>lambda.extend.ratio=3</code>.
</p>
</td></tr>
<tr><td><code id="grcmle_+3A_conf.level">conf.level</code></td>
<td>

<p>confidence level of the confidence interval(s) for the parameter(s) inferred
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Maximum likelihood estimation is used for the inference.
</p>


<h3>Value</h3>

<p>The returned value is a list containing
</p>
<table>
<tr><td><code>mle</code></td>
<td>
<p>the parameter(s) inferred. For Poisson model, it is the estimate of <code class="reqn">\lambda</code>.
For ZIP model, it shows a vector of length 2: the first element is the estimate of <code class="reqn">p</code> and
the second element is the estimate of <code class="reqn">\lambda</code>.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the chi-squared test of goodness-of-fit.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the degree(s) of freedom of the chi-squared test of goodness-of-fit.</p>
</td></tr>
<tr><td><code>CI.lambda</code></td>
<td>
<p>the confidence interval of <code class="reqn">\lambda</code> obtained by normal approximation</p>
</td></tr>
<tr><td><code>CI.p</code></td>
<td>
<p>the confidence interval of <code class="reqn">p</code> obtained by normal approximation</p>
</td></tr>
<tr><td><code>conf.level</code></td>
<td>
<p>the confidence level</p>
</td></tr>
<tr><td><code>std.err</code></td>
<td>
<p>the standard error of <code class="reqn">\lambda</code>
or the standard errors of <code class="reqn">(p, \lambda)</code>, if a ZIP model is specified</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Authors: Xin Guo &lt;x.guo@polyu.edu.hk&gt;, Qiang Fu &lt;qiang.fu@ubc.ca&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grcmle(counts=c(6, 15, 168, 155, 15), scheme = c(0, 1, 2, 5, 9))

grcmle(counts=c(6, 15, 168, 155, 15), scheme = c(0, 1, 2, 5, 9), method = "ZIP")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
