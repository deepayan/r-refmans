<!DOCTYPE html><html><head><title>Help for package GPArotation</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GPArotation}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#00.GPArotation'><p>Gradient Projection Algorithms for Factor Rotation</p></a></li>
<li><a href='#echelon'><p>Echelon Rotation</p></a></li>
<li><a href='#eiv'><p>Errors-in-Variables Rotation</p></a></li>
<li><a href='#GPA'><p>Rotation Optimization</p></a></li>
<li><a href='#Harman'><p>Example Data from Harman</p></a></li>
<li><a href='#NormalizingWeight'><p>Internal Utility for Normalizing Weights</p></a></li>
<li><a href='#print.GPArotation'><p>Print and Summary Methods for GPArotation</p></a></li>
<li><a href='#Random.Start'><p>Generate a Random Orthogonal Rotation</p></a></li>
<li><a href='#rotations'><p>Rotations</p></a></li>
<li><a href='#Thurstone'><p>Example Data from Thurstone</p></a></li>
<li><a href='#vgQ'><p>Rotations</p></a></li>
<li><a href='#WansbeekMeijer'><p>Factor Example from Wansbeek and Meijer</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2024.3-1</td>
</tr>
<tr>
<td>Title:</td>
<td>Gradient Projection Factor Rotation</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.0.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Gradient Projection Algorithms for Factor Rotation. 
    For details see ?GPArotation. When using this package, please cite:
    Bernaards and Jennrich (2005) &lt;<a href="https://doi.org/10.1177%2F0013164404272507">doi:10.1177/0013164404272507</a>&gt;.
    "Gradient Projection Algorithms and Software 
    for Arbitrary Rotation Criteria in Factor Analysis".</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://optimizer.r-forge.r-project.org/GPArotation_www/">https://optimizer.r-forge.r-project.org/GPArotation_www/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-01 19:57:44 UTC; coen</td>
</tr>
<tr>
<td>Author:</td>
<td>Coen Bernaards [aut, cre],
  Paul Gilbert [aut],
  Robert Jennrich [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Coen Bernaards &lt;cab.gparotation@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-02 00:12:35 UTC</td>
</tr>
</table>
<hr>
<h2 id='00.GPArotation'>Gradient Projection Algorithms for Factor Rotation</h2><span id='topic+GPArotation'></span><span id='topic+GPArotation-package'></span><span id='topic+GPArotation.Intro'></span>

<h3>Description</h3>

<p>GPA Rotation for Factor Analysis
</p>
<p>The GPArotation package contains functions for the rotation of factor loadings
matrices. The functions implement Gradient Projection (GP) algorithms for orthogonal 
and oblique rotation. Additionally, a number of rotation criteria are provided.
The GP algorithms minimize the rotation criterion function, and provide the 
corresponding rotation matrix. For oblique rotation, the covariance / correlation matrix
of the factors is also provided. The rotation criteria implemented in this package 
are described in Bernaards and Jennrich (2005). Theory of the GP algorithm is 
described in Jennrich (2001, 2002) publications.
</p>
<p>Additionally 2 rotation methods are provided that do not rely on GP (eiv and echelon)
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> GPArotation</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 2.0.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL Version 2.</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://optimizer.r-forge.r-project.org/GPArotation_www/</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Index of functions:
</p>
<p>Wrapper functions that include random starts option <br />
</p>

<table>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+GPFRSorth">GPFRSorth</a></code> </td><td style="text-align: left;"> Orthogonal rotation with random starts </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+GPFRSorth">GPFRSorth</a></code> </td><td style="text-align: left;"> Oblique rotation with random starts </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Gradient Projection Rotation Algorithms (code unchanged since 2008)<br />
</p>

<table>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+GPForth">GPForth</a></code> </td><td style="text-align: left;"> Orthogonal rotation function </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+GPForth">GPForth</a></code> </td><td style="text-align: left;"> Oblique rotation function </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Utility functions<br />
</p>

<table>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+Random.Start">Random.Start</a></code> </td><td style="text-align: left;"> Generate random a starting matrix </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+NormalizingWeight">NormalizingWeight</a></code> </td><td style="text-align: left;"> Kaiser normalization (not exported from NAMESPACE) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+print.GPArotation">print.GPArotation</a></code></td><td style="text-align: left;"> Print results (S3 level function) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+summary.GPArotation">summary.GPArotation</a></code> </td><td style="text-align: left;"> Summary of results (S3 level function) </td>
</tr>

</table>

<p>Rotations<br />
</p>

<table>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+oblimin">oblimin</a></code> </td><td style="text-align: left;"> Oblimin rotation  </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+quartimin">quartimin</a></code> </td><td style="text-align: left;"> Quartimin rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+targetT">targetT</a></code> </td><td style="text-align: left;"> Orthogonal Target rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+targetQ">targetQ</a></code> </td><td style="text-align: left;"> Oblique Target rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+pstT">pstT</a></code> </td><td style="text-align: left;"> Orthogonal Partially Specified Target rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+pstQ">pstQ</a></code> </td><td style="text-align: left;"> Oblique Partially Specified Target rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+oblimax">oblimax</a></code> </td><td style="text-align: left;"> Oblimax rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+entropy">entropy</a></code> </td><td style="text-align: left;"> Minimum Entropy rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+quartimax">quartimax</a></code> </td><td style="text-align: left;"> Quartimax rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+Varimax">Varimax</a></code> </td><td style="text-align: left;"> Varimax rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+simplimax">simplimax</a></code> </td><td style="text-align: left;"> Simplimax rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+bentlerT">bentlerT</a></code> </td><td style="text-align: left;"> Orthogonal Bentler's Invariant Pattern Simplicity rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+bentlerQ">bentlerQ</a></code> </td><td style="text-align: left;"> Oblique Bentler's Invariant Pattern Simplicity rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+tandemI">tandemI</a></code> </td><td style="text-align: left;"> The Tandem Criteria Principle I rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+tandemII">tandemII</a></code> </td><td style="text-align: left;"> The Tandem Criteria Principle II rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+geominT">geominT</a></code> </td><td style="text-align: left;"> Orthogonal Geomin rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+geominQ">geominQ</a></code> </td><td style="text-align: left;"> Oblique Geomin rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+bigeominT">bigeominT</a></code> </td><td style="text-align: left;"> Orthogonal Bi-Geomin rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+bigeominQ">bigeominQ</a></code> </td><td style="text-align: left;"> Oblique Bi-Geomin rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+cfT">cfT</a></code> </td><td style="text-align: left;"> Orthogonal Crawford-Ferguson Family rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+cfQ">cfQ</a></code> </td><td style="text-align: left;"> Oblique Crawford-Ferguson Family rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+equamax">equamax</a></code> </td><td style="text-align: left;"> Equamax rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+parsimax">parsimax</a></code> </td><td style="text-align: left;"> Parsimax rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+infomaxT">infomaxT</a></code> </td><td style="text-align: left;"> Orthogonal Infomax rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+infomaxQ">infomaxQ</a></code> </td><td style="text-align: left;"> Oblique Infomax rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+mccammon">mccammon</a></code> </td><td style="text-align: left;"> McCammon Minimum Entropy Ratio rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+varimin">varimin</a></code> </td><td style="text-align: left;"> Varimin rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+bifactorT">bifactorT</a></code> </td><td style="text-align: left;"> Orthogonal Bifactor rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+bifactorQ">bifactorQ</a></code> </td><td style="text-align: left;"> Oblique Bifactor rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+eiv">eiv</a></code> </td><td style="text-align: left;"> Errors-in-Variables rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+echelon">echelon</a></code> </td><td style="text-align: left;"> Echelon rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>vgQ routines to compute value and gradient of the criterion (not exported from NAMESPACE)<br />
</p>

<table>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+vgQ.oblimin">vgQ.oblimin</a></code> </td><td style="text-align: left;"> Oblimin vgQ  </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+vgQ.quartimin">vgQ.quartimin</a></code></td><td style="text-align: left;"> Quartimin vgQ </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+vgQ.target">vgQ.target</a></code></td><td style="text-align: left;"> Target vgQ </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+vgQ.pst">vgQ.pst</a></code></td><td style="text-align: left;"> Partially Specified Target vgQ </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+vgQ.oblimax">vgQ.oblimax</a></code> </td><td style="text-align: left;"> Oblimax vgQ </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+vgQ.entropy">vgQ.entropy</a></code> </td><td style="text-align: left;"> Minimum Entropy vgQ </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+vgQ.quartimax">vgQ.quartimax</a></code></td><td style="text-align: left;"> Quartimax vgQ </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+vgQ.varimax">vgQ.varimax</a></code></td><td style="text-align: left;"> Varimax vgQ </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+vgQ.simplimax">vgQ.simplimax</a></code></td><td style="text-align: left;"> Simplimax vgQ </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+vgQ.bentler">vgQ.bentler</a></code></td><td style="text-align: left;"> Bentler's Invariant Pattern Simplicity vgQ </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+vgQ.tandemI">vgQ.tandemI</a></code></td><td style="text-align: left;"> The Tandem Criteria Principle I vgQ </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+vgQ.tandemII">vgQ.tandemII</a></code></td><td style="text-align: left;"> The Tandem Criteria Principle II vgQ </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+vgQ.geomin">vgQ.geomin</a></code></td><td style="text-align: left;"> Geomin vgQ </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+vgQ.bigeomin">vgQ.bigeomin</a></code></td><td style="text-align: left;"> Bi-Geomin vgQ </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+vgQ.cf">vgQ.cf</a></code> </td><td style="text-align: left;"> Crawford-Ferguson Family vgQ </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+vgQ.infomax">vgQ.infomax</a></code> </td><td style="text-align: left;"> Infomax vgQ </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+vgQ.mccammon">vgQ.mccammon</a></code></td><td style="text-align: left;"> McCammon Minimum Entropy Ratio vgQ </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+vgQ.varimin">vgQ.varimin</a></code></td><td style="text-align: left;"> Varimin vgQ </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+vgQ.bifactor">vgQ.bifactor</a></code></td><td style="text-align: left;"> Bifactor vgQ </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Data sets included in the GPArotation package <br />
</p>

<table>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+Harman">Harman</a></code></td><td style="text-align: left;"> Initial factor loading matrix for Harman's 8 physical variables </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+Thurstone">Thurstone</a></code> </td><td style="text-align: left;"> box20 and box26 initial factor loadings matrices </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+WansbeekMeijer">WansbeekMeijer</a></code> </td><td style="text-align: left;"> Netherlands TV viewership </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Coen A. Bernaards and Robert I. Jennrich
with some R modifications by Paul Gilbert.
</p>
<p>Code is modified from original source &lsquo;<span class="file">splusfunctions.net</span>&rsquo; available at 
<a href="https://optimizer.r-forge.r-project.org/GPArotation_www/">https://optimizer.r-forge.r-project.org/GPArotation_www/</a>.
</p>


<h3>References</h3>

<p>The software reference is
</p>
<p>Bernaards, C.A. and Jennrich, R.I. (2005) Gradient Projection Algorithms 
and Software for Arbitrary Rotation Criteria in Factor Analysis. 
<em>Educational and Psychological Measurement</em>, <b>65</b>, 676&ndash;696.
</p>
<p>Theory of gradient projection algorithms may be found in:
</p>
<p>Jennrich, R.I. (2001). A simple general procedure for orthogonal rotation.
<em>Psychometrika</em>, <b>66</b>, 289&ndash;306.
</p>
<p>Jennrich, R.I. (2002). A simple general method for oblique rotation. 
<em>Psychometrika</em>, <b>67</b>, 7&ndash;19.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GPFRSorth">GPFRSorth</a></code>,
<code><a href="#topic+GPFRSoblq">GPFRSoblq</a></code>,
<code><a href="#topic+rotations">rotations</a></code>,
<code><a href="#topic+vgQ">vgQ</a></code>
</p>

<hr>
<h2 id='echelon'>Echelon Rotation</h2><span id='topic+echelon'></span>

<h3>Description</h3>

<p>Rotate to an echelon parameterization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    echelon(L, reference=seq(NCOL(L)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="echelon_+3A_l">L</code></td>
<td>
<p>a factor loading matrix</p>
</td></tr>
<tr><td><code id="echelon_+3A_reference">reference</code></td>
<td>
<p>indicates rows of loading matrix that should be 
used to determine the rotation transformation.</p>
</td></tr>
<tr><td><code id="echelon_+3A_...">...</code></td>
<td>
<p>additional arguments discarded.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The loadings matrix is rotated so the <code class="reqn">k</code> rows of the loading matrix 
indicated by <code>reference</code> are the Cholesky factorization given by 
<code>t(chol(L[reference,] %*% t(L[reference,])))</code>.
This defines the
rotation transformation, which is then also applied to other rows to 
give the new loadings matrix.
</p>
<p>The optimization is not iterative and does not use the GPA algorithm.  
The function can be used directly or the
function name can be passed to factor analysis functions like <code>factanal</code>.
An orthogonal solution is assumed (so <code class="reqn">\Phi</code> is identity).
</p>
<p>The default uses the first <code class="reqn">k</code> rows 
as the reference. If the submatrix of <code>L</code> indicated by reference is 
singular then the rotation will fail and the
user needs to supply a different choice of rows.
</p>
<p>One use of this parameterization is
for obtaining good starting values (so it may appear strange
to rotate towards this solution afterwards). It has a few other purposes: 
</p>
<p>(1) It can be useful for comparison with
published results in this parameterization.
</p>
<p>(2) The S.E.s are more straightforward to compute, because it is the solution 
to an unconstrained optimization (though not necessarily computed as such). 
</p>
<p>(3) The models with k and (k+1) factors are nested, so it
is more straightforward to test the k-factor model versus the
(k+1)-factor model. In particular, in addition to the LR test
(which does not depend on the rotation), now the Wald test
and LM test can be used as well. For these, the test of a
k-factor model versus a (k+1)-factor model is a 
joint test whether all the free parameters (loadings) in the (k+1)st 
column of <code>L</code> are zero.
</p>
<p>(4) For some purposes, only the subspace spanned by the factors
is important, not the specific parameterization within this subspace.
</p>
<p>(5) The back-predicted indicators (explained portion of the indicators) 
do not depend
on the rotation method. Combined with the greater ease to obtain
correct standard errors of this method, this allows easier and more
accurate prediction-standard errors.  
</p>
<p>(6) This parameterization and its standard errors can be used to
detect identification problems (McDonald, 1999, pp. 181-182).
</p>


<h3>Value</h3>

<p>A list (which includes elements used by <code>factanal</code>) with:
</p>
<table>
<tr><td><code>loadings</code></td>
<td>
<p>The new loadings matrix.</p>
</td></tr> 
<tr><td><code>Th</code></td>
<td>
<p>The rotation.</p>
</td></tr> 
<tr><td><code>method</code></td>
<td>
<p>A string indicating the rotation objective function (&quot;echelon&quot;).</p>
</td></tr>
<tr><td><code>orthogonal</code></td>
<td>
<p>For consistency with other rotation results. Always TRUE.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>For consistency with other rotation results. Always TRUE.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Erik Meijer and Paul Gilbert.</p>


<h3>References</h3>

<p>Roderick P. McDonald (1999)
<em>Test Theory: A Unified Treatment</em>, Mahwah, NJ: Erlbaum.
</p>
<p>Tom Wansbeek and Erik Meijer (2000) <em>Measurement Error and 
Latent Variables in Econometrics</em>, Amsterdam: North-Holland.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eiv">eiv</a></code>, 
<code><a href="#topic+rotations">rotations</a></code>, 
<code><a href="#topic+GPForth">GPForth</a></code>, 
<code><a href="#topic+GPFoblq">GPFoblq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data("WansbeekMeijer", package="GPArotation")
  fa.unrotated  &lt;- factanal(factors = 2, covmat=NetherlandsTV, rotation="none")

  fa.ech &lt;- echelon(fa.unrotated$loadings)
 
  fa.ech2 &lt;- factanal(factors = 2, covmat=NetherlandsTV, rotation="echelon")
  
  cbind(loadings(fa.unrotated), loadings(fa.ech), loadings(fa.ech2))

  fa.ech3 &lt;- echelon(fa.unrotated$loadings, reference=6:7)
  cbind(loadings(fa.unrotated), loadings(fa.ech), loadings(fa.ech3))
  </code></pre>

<hr>
<h2 id='eiv'>Errors-in-Variables Rotation</h2><span id='topic+eiv'></span>

<h3>Description</h3>

<p>Rotate to errors-in-variables representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    eiv(L, identity=seq(NCOL(L)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eiv_+3A_l">L</code></td>
<td>
<p>a factor loading matrix</p>
</td></tr>
<tr><td><code id="eiv_+3A_identity">identity</code></td>
<td>
<p>indicates rows which should be identity matrix.</p>
</td></tr>
<tr><td><code id="eiv_+3A_...">...</code></td>
<td>
<p>additional arguments discarded.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function rotates to an errors-in-variables representation. The
optimization is not iterative and does not use the GPA algorithm.  
The function can be used directly or the
function name can be passed to factor analysis functions like <code>factanal</code>.
</p>
<p>The loadings matrix is rotated so the <code class="reqn">k</code> rows indicated by <code>identity</code> 
form an identity matrix, and the remaining <code class="reqn">M-k</code> rows are free parameters.
<code class="reqn">\Phi</code> is also free. The default makes the first <code class="reqn">k</code> rows 
the identity. If inverting the matrix
of the rows indicated by <code>identity</code> fails, the rotation will fail and the
user needs to supply a different choice of rows.
</p>
<p>Not all authors consider this representation to be a rotation. 
Viewed as a rotation method, it is oblique, with an
explicit solution: given an initial loadings matrix <code class="reqn">L</code> partitioned as
<code class="reqn">L = (L_1^T, L_2^T)^T</code>, then (for the default 
<code>identity</code>) the new loadings matrix is 
<code class="reqn">(I,  (L_2 L_1^{-1})^T)^T</code> 
and <code class="reqn">\Phi = L_1 L_1^T</code>, where <code class="reqn">I</code> is the <code class="reqn">k</code> 
by <code class="reqn">k</code> identity matrix. It is
assumed that <code class="reqn">\Phi = I</code> for the initial loadings matrix.
</p>
<p>One use of this parameterization is
for obtaining good starting values (so it looks a little strange
to rotate towards this solution afterwards). It has a few other purposes: 
(1) It can be useful for comparison with
published results in this parameterization; 
(2) The
S.E.s are more straightfoward to compute, because it is the solution 
to an unconstrained
optimization (though not necessarily computed as such); 
(3) One
may have an idea about which reference variables load on only one
factor, but not impose restrictive constraints on the other loadings,
so, in a nonrestrictive
way, it has similarities to CFA; 
(4) For some purposes, only the subspace spanned by the factors
is important, not the specific parameterization within this subspace;
(5) The back-predicted indicators (explained portion of the indicators) 
do not depend
on the rotation method. Combined with the greater ease to obtain
correct standard errors of this method, this allows easier and more
accurate prediction-standard errors.  
</p>


<h3>Value</h3>

<p>A list (which includes elements used by <code>factanal</code>) with:
</p>
<table>
<tr><td><code>loadings</code></td>
<td>
<p>The new loadings matrix.</p>
</td></tr> 
<tr><td><code>Th</code></td>
<td>
<p>The rotation.</p>
</td></tr> 
<tr><td><code>method</code></td>
<td>
<p>A string indicating the rotation objective function (&quot;eiv&quot;).</p>
</td></tr>
<tr><td><code>orthogonal</code></td>
<td>
<p>For consistency with other rotation results. Always FALSE.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>For consistency with other rotation results. Always TRUE.</p>
</td></tr>
<tr><td><code>Phi</code></td>
<td>
<p>The covariance matrix of the rotated factors.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Erik Meijer and Paul Gilbert.</p>


<h3>References</h3>

<p>Gösta Hägglund. (1982). &quot;Factor Analysis by
Instrumental Variables Methods.&quot; <em>Psychometrika</em>, 47, 209&ndash;222.
</p>
<p>Sock-Cheng Lewin-Koh and Yasuo Amemiya. (2003). &quot;Heteroscedastic factor
analysis.&quot; <em>Biometrika</em>, 90, 85&ndash;97.
</p>
<p>Tom Wansbeek and Erik Meijer (2000) <em>Measurement Error and 
Latent Variables in Econometrics</em>, Amsterdam: North-Holland.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+echelon">echelon</a></code>, 
<code><a href="#topic+rotations">rotations</a></code>, 
<code><a href="#topic+GPForth">GPForth</a></code>, 
<code><a href="#topic+GPFoblq">GPFoblq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data("WansbeekMeijer", package="GPArotation")
  fa.unrotated  &lt;- factanal(factors = 2, covmat=NetherlandsTV, rotation="none")

  fa.eiv &lt;- eiv(fa.unrotated$loadings)
 
  fa.eiv2 &lt;- factanal(factors = 2, covmat=NetherlandsTV, rotation="eiv")
  
  cbind(loadings(fa.unrotated), loadings(fa.eiv), loadings(fa.eiv2))

  fa.eiv3 &lt;- eiv(fa.unrotated$loadings, identity=6:7)
  cbind(loadings(fa.unrotated), loadings(fa.eiv), loadings(fa.eiv3))

  </code></pre>

<hr>
<h2 id='GPA'>Rotation Optimization</h2><span id='topic+GPFRSorth'></span><span id='topic+GPFRSoblq'></span><span id='topic+GPForth'></span><span id='topic+GPFoblq'></span>

<h3>Description</h3>

<p>Gradient projection rotation optimization routine used by various rotation
objective.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    GPFRSorth(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000, 
       method="varimax", methodArgs=NULL, randomStarts=0)
    GPFRSoblq(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000, 
       method="quartimin", methodArgs=NULL, randomStarts=0)

    GPForth(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000, 
       method="varimax", methodArgs=NULL)
    GPFoblq(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000, 
       method="quartimin", methodArgs=NULL)
    </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GPA_+3A_a">A</code></td>
<td>
<p>initial factor loadings matrix for which the rotation 
criterian is to be optimized.</p>
</td></tr>
<tr><td><code id="GPA_+3A_tmat">Tmat</code></td>
<td>
<p>initial rotation matrix.</p>
</td></tr>
<tr><td><code id="GPA_+3A_normalize">normalize</code></td>
<td>
<p>see details.</p>
</td></tr>
<tr><td><code id="GPA_+3A_eps">eps</code></td>
<td>
<p>convergence is assumed when the norm of the gradient is smaller
than eps.</p>
</td></tr>
<tr><td><code id="GPA_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations allowed in the main loop.</p>
</td></tr>
<tr><td><code id="GPA_+3A_method">method</code></td>
<td>
<p>rotation objective criterian.</p>
</td></tr>
<tr><td><code id="GPA_+3A_methodargs">methodArgs</code></td>
<td>
<p>a list ofmethodArgs arguments passed to the rotation objective</p>
</td></tr>
<tr><td><code id="GPA_+3A_randomstarts">randomStarts</code></td>
<td>
<p>number of random starts (GPFRSorth and GPFRSoblq)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gradient projection (GP) rotation optimization routines developed by
Jennrich (2001, 2002) and Bernaards and Jennrich (2005).
These functions can be used directly
to rotate a loadings matrix, or indirectly through a rotation
objective passed to a factor estimation routine such as <code><a href="stats.html#topic+factanal">factanal</a></code>.
A rotation of a matrix <code>A</code> is defined as <code>A %*% solve(t(Th))</code>. 
In case of orthogonal rotation, the factors the rotation matrix
<code>Tmat</code> is orthonormal, and the rotation simplifies 
to <code>A %*% Th</code>. The rotation matrix <code>Th</code> is computed by GP rotation.
</p>
<p>The <code>GPFRsorth</code> and <code>GPFRSoblq</code> functions are the primary functions 
for orthogonal and oblique rotations, respectively. These two functions 
serve as wrapper functions for  <code>GPForth</code> and <code>GPFoblq</code>, with the
added functionality of multiple random starts. 
<code>GPForth</code> is the main GP algorithm for orthogonal rotation.
<code>GPFoblq</code> is the main GP algorithm for oblique rotation.
The <code>GPForth</code> and <code>GPFoblq</code> may be also be called directly. 
</p>
<p>Arguments in the wrapper functions <code>GPFRsorth</code> and <code>GPFRSoblq</code> 
are passed to GP algorithms. Functions require an initial loadings matrix 
<code>A</code> which fixes the equivalence class over which the optimization is done. 
It must be the solution to the orthogonal factor analysis problem as obtained 
from <code>factanal</code> or other factor estimation routines. 
The initial rotation matrix is given by the <code>Tmat</code>. 
By default the GP algorithm use the identity matrix as the initial rotation matrix. 
</p>
<p>For some rotation criteria local minima may exist. To start from random 
initial rotation matrices, the <code>randomStarts</code> argument is available
in <code>GPFRSorth</code> and <code>GPFRSoblq</code>. The returned object includes 
the rotated loadings matrix with the lowest criterion value <code>f</code> 
among attemnpted starts.Technically, this does not have to be the global 
minimum. The <code>randomStarts</code> argument
is not available <code>GPForth</code> and <code>GPFoblq</code>. However, for 
<code>GPForth</code> and <code>GPFoblq</code> a single random
initial rotation matrix may be set by <code>Tmat = <a href="#topic+Random.Start">Random.Start</a>(ncol(A))</code>.
</p>
<p>The argument <code>method</code> can be used to specify a string indicating
the rotation objective. Oblique rotation defaults to <code>"quartimin"</code> 
and orthogonal rotation defaults to <code>"varimax"</code>. Available rotation objectives
are <code>"oblimin"</code>, <code>"quartimin"</code>, <code>"target"</code>, <code>"pst"</code>,
<code>"oblimax"</code>, <code>"entropy"</code>, <code>"quartimax"</code>, <code>"varimax"</code>, 
<code>"simplimax"</code>, <code>"bentler"</code>, <code>"tandemI"</code>, <code>"tandemII"</code>, 
<code> "geomin"</code>, <code>"cf"</code>, <code>"infomax"</code>, <code>"mccammon"</code>, <code>bifactor</code>,
and <code>"varimin"</code>. The string is prefixed with &quot;vgQ.&quot; to give the actual function call. 
See <code><a href="#topic+vgQ">vgQ</a></code> for details.
</p>
<p>Some rotation criteria (<code>"oblimin"</code>, <code>"target"</code>, <code>"pst"</code>, <code>"simplimax"</code>,
<code>"geomin"</code>, <code>"cf"</code>) require one or more additional arguments. See <code>link{rotations}</code>
for details and default values, if applicable. 
</p>
<p>For examples of the indirect use see <code><a href="#topic+rotations">rotations</a></code>. 
</p>
<p>The argument <code>normalize</code> gives an indication of if and how any
normalization should be done before rotation, and then undone after rotation.
If <code>normalize</code> is <code>FALSE</code> (the default) no normalization is done.
If <code>normalize</code> is <code>TRUE</code> then Kaiser normalization is done. (So
squared row entries of normalized <code>A</code> sum to 1.0. This is sometimes called
Horst normalization.)
If <code>normalize</code> is a vector of length equal to the number of indicators (=
number of rows of <code>A</code>) then the colums are divided by <code>normalize</code> 
before rotation and multiplied by <code>normalize</code> after rotation. 
If <code>normalize</code> is a function then it should take <code>A</code> as an argument
and return a vector which is used like the vector above. See Nguyen and Waller (2022)
for detailed investigation of normalization on factor rotations, including 
potential effect on qualitative interpretation of loadings.
</p>


<h3>Value</h3>

<p>A GPArotation object which is a list with elements 
</p>
<table>
<tr><td><code>loadings</code></td>
<td>
<p>The rotated loadings, one column for each factor. If randomStarts
were requested then this is the rotated loadings matrix with the 
lowest criterion value.</p>
</td></tr>
<tr><td><code>Th</code></td>
<td>
<p>The rotation matrix, loadings %*% t(Th) = A.</p>
</td></tr>
<tr><td><code>Table</code></td>
<td>
<p>A matrix recording the iterations of the rotation optimization.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>A string indicating the rotation objective function.</p>
</td></tr>
<tr><td><code>orthogonal</code></td>
<td>
<p>A logical indicating if the rotation is orthogonal.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>A logical indicating if convergence was obtained.</p>
</td></tr>
<tr><td><code>Phi</code></td>
<td>
<p>t(Th) %*% Th.  The covariance matrix of the rotated factors.
This will be the identity matrix for orthogonal
rotations so is omitted (NULL) for the result from GPFRSorth and GPForth.</p>
</td></tr>
<tr><td><code>Gq</code></td>
<td>
<p>The gradient of the objective function at the rotated loadings.</p>
</td></tr>
<tr><td><code>randStartChar</code></td>
<td>
<p>A vector with characteristics of random starts 
(GPFRSorth and GPFRSoblq only; omitted if randomStarts =&lt; 1).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Coen A. Bernaards and Robert I. Jennrich
with some R modifications by Paul Gilbert</p>


<h3>References</h3>

<p>Bernaards, C.A. and Jennrich, R.I. (2005) Gradient Projection Algorithms 
and Software for Arbitrary Rotation Criteria in Factor Analysis. 
<em>Educational and Psychological Measurement</em>, <b>65</b>, 676&ndash;696.
</p>
<p>Jennrich, R.I. (2001). A simple general procedure for orthogonal rotation.
<em>Psychometrika</em>, <b>66</b>, 289&ndash;306.
</p>
<p>Jennrich, R.I. (2002). A simple general method for oblique rotation. 
<em>Psychometrika</em>, <b>67</b>, 7&ndash;19.
</p>
<p>Nguyen, H.V. and Waller, N.G. (2022). Local minima and factor rotations
in exploratory factor analysis. <em> Psychological Methods</em>. 
Advance online publication. https://doi.org/10.1037/met0000467
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Random.Start">Random.Start</a></code>,
<code><a href="stats.html#topic+factanal">factanal</a></code>,
<code><a href="#topic+oblimin">oblimin</a></code>,
<code><a href="#topic+quartimin">quartimin</a></code>,
<code><a href="#topic+targetT">targetT</a></code>,
<code><a href="#topic+targetQ">targetQ</a></code>,
<code><a href="#topic+pstT">pstT</a></code>,
<code><a href="#topic+pstQ">pstQ</a></code>,
<code><a href="#topic+oblimax">oblimax</a></code>,
<code><a href="#topic+entropy">entropy</a></code>,
<code><a href="#topic+quartimax">quartimax</a></code>,
<code><a href="#topic+Varimax">Varimax</a></code>,
<code><a href="stats.html#topic+varimax">varimax</a></code>,
<code><a href="#topic+simplimax">simplimax</a></code>,
<code><a href="#topic+bentlerT">bentlerT</a></code>,
<code><a href="#topic+bentlerQ">bentlerQ</a></code>,
<code><a href="#topic+tandemI">tandemI</a></code>,
<code><a href="#topic+tandemII">tandemII</a></code>,
<code><a href="#topic+geominT">geominT</a></code>,
<code><a href="#topic+geominQ">geominQ</a></code>,
<code><a href="#topic+bigeominT">bigeominT</a></code>,
<code><a href="#topic+bigeominQ">bigeominQ</a></code>,
<code><a href="#topic+cfT">cfT</a></code>,
<code><a href="#topic+cfQ">cfQ</a></code>,
<code><a href="#topic+equamax">equamax</a></code>,
<code><a href="#topic+parsimax">parsimax</a></code>,
<code><a href="#topic+infomaxT">infomaxT</a></code>,
<code><a href="#topic+infomaxQ">infomaxQ</a></code>,
<code><a href="#topic+mccammon">mccammon</a></code>,
<code><a href="#topic+varimin">varimin</a></code>,
<code><a href="#topic+bifactorT">bifactorT</a></code>,
<code><a href="#topic+bifactorQ">bifactorQ</a></code>,
<code><a href="stats.html#topic+promax">promax</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # see rotations for more examples	
	
  data(Harman, package = "GPArotation")
  GPFRSorth(Harman8, method = "quartimax")
  quartimax(Harman8)
  GPFRSoblq(Harman8, method = "quartimin", normalize = TRUE)
  loadings( quartimin(Harman8, normalize = TRUE) )

  # using random starts
  data("WansbeekMeijer", package = "GPArotation")
  fa.unrotated  &lt;- factanal(factors = 3, covmat=NetherlandsTV, normalize=TRUE, rotation="none")
  GPFRSoblq(loadings(fa.unrotated), normalize = TRUE, method = "oblimin", randomStarts = 100)
  oblimin(loadings(fa.unrotated), randomStarts=100)
  data(Thurstone, package = "GPArotation")
  geominQ(box26, normalize = TRUE, randomStarts=100)
  
  # displaying results of factor analysis rotation output
  origdigits &lt;- options("digits")
  Abor.unrotated &lt;- factanal(factors = 2, covmat = ability.cov, rotation = "none")
  Abor &lt;- oblimin(loadings(Abor.unrotated), randomStarts = 20)
  Abor
  print(Abor)
  print(Abor, sortLoadings=FALSE) #this matches the output passed to factanal
  print(Abor, Table=TRUE)
  print(Abor, rotateMat=TRUE)
  print(Abor, digits=2)
  # by default provides the structure matrix for oblique rotation
  summary(Abor)
  summary(Abor, Structure=FALSE)
  options(digits = origdigits$digits)
  
  # GPArotation output does sort loadings, but use print to obtain if needed
  set.seed(334)
  xusl &lt;- quartimin(Harman8, normalize = TRUE, randomStarts=100)
  # loadings without ordering (default)
  loadings(xusl)
  max(abs(print(xusl)$loadings - xusl$loadings)) == 0 # FALSE
  # output sorted loadings via print (not default)
  xsl &lt;- print(xusl)
  max(abs(print(xsl)$loadings - xsl$loadings)) == 0 # TRUE
  
  # Kaiser normalization is used when normalize=TRUE
  factanal(factors = 2, covmat = ability.cov, rotation = "oblimin", 
  			control=list(rotate=list(normalize = TRUE)))
  # Cureton-Mulaik normalization can be done by passing values to the rotation
  # may result in convergence problems
  NormalizingWeightCM &lt;- function (L) {
    Dk &lt;- diag(sqrt(diag(L %*% t(L)))^-1) %*% L
    wghts &lt;- rep(0, nrow(L))
    fpls &lt;- Dk[, 1]
    acosi &lt;- acos(ncol(L)^(-1/2))
    for (i in 1:nrow(L)) {
    	num &lt;- (acosi - acos(abs(fpls[i])))
        dem &lt;- (acosi - (function(a, m) ifelse(abs(a) &lt; (m^(-1/2)), pi/2, 0))(fpls[i], ncol(L)))
        wghts[i] &lt;- cos(num/dem * pi/2)^2 + 0.001
    	}
    Dv &lt;- wghts * sqrt(diag(L %*% t(L)))^-1        
    Dv
  }
  quartimin(Harman8, normalize = NormalizingWeightCM(Harman8), randomStarts=100)
  quartimin(Harman8, normalize = TRUE, randomStarts=100)
	
  </code></pre>

<hr>
<h2 id='Harman'>Example Data from Harman</h2><span id='topic+Harman'></span><span id='topic+Harman8'></span>

<h3>Description</h3>

<p>Harman8 is initial factor loading matrix for 
Harman's 8 physical variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	data(Harman)
</code></pre>


<h3>Format</h3>

<p>The object Harman8 is a matrix.
</p>


<h3>Details</h3>

<p>The object Harman8 is loaded from the data file Harman.
</p>


<h3>Source</h3>

<p>Harman, H. H. (1976) <em>Modern Factor Analysis</em>, Third Edition
Revised, University of Chicago Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GPForth">GPForth</a></code>,
<code><a href="#topic+Thurstone">Thurstone</a></code>, 
<code><a href="#topic+WansbeekMeijer">WansbeekMeijer</a></code>
</p>

<hr>
<h2 id='NormalizingWeight'>Internal Utility for Normalizing Weights</h2><span id='topic+NormalizingWeight'></span>

<h3>Description</h3>

<p>See GPFRSoblq and GPFRSorth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    NormalizingWeight(A, normalize=FALSE)
    </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NormalizingWeight_+3A_a">A</code></td>
<td>
<p>A loading matrix.</p>
</td></tr>
<tr><td><code id="NormalizingWeight_+3A_normalize">normalize</code></td>
<td>
<p>An indication of if/how the matrix should be normalized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix. This function is not exported in the NAMESPACE, and is only used by the GP rotation functions. See <a href="#topic+GPFRSorth">GPFRSorth</a> for an example of its use.</p>

<hr>
<h2 id='print.GPArotation'>Print and Summary Methods for GPArotation</h2><span id='topic+print.GPArotation'></span><span id='topic+summary.GPArotation'></span><span id='topic+print.summary.GPArotation'></span>

<h3>Description</h3>

<p>Print an object or summary of an object returned by <code>GPFRSorth</code>,
<code>GPFRSoblq</code>, <code>GPForth</code>, or <code>GPFoblq</code>.
</p>
<p>A GPArotation object by default to will print sorted loadings, Phi, and rotation matrix (if requested).
</p>
<p>Output includes contributions of factors <code>SS loadings</code> 
(Sum of Squared loadings), (see e.g. Harman 1976, sections 2.4 and 12.4).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    ## S3 method for class 'GPArotation'
print(x, digits=3, sortLoadings=TRUE, rotateMat=FALSE, Table=FALSE, ...)
    ## S3 method for class 'GPArotation'
summary(object, digits=3, Structure=TRUE, ...)
    ## S3 method for class 'summary.GPArotation'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.GPArotation_+3A_x">x</code></td>
<td>
<p>a GPArotation object to summarize.</p>
</td></tr>
<tr><td><code id="print.GPArotation_+3A_object">object</code></td>
<td>
<p>a summary.GPArotation to print.</p>
</td></tr>
<tr><td><code id="print.GPArotation_+3A_digits">digits</code></td>
<td>
<p>precision of printed numbers.</p>
</td></tr>
<tr><td><code id="print.GPArotation_+3A_sortloadings">sortLoadings</code></td>
<td>
<p>display sorted loadings of a GPArotation object.</p>
</td></tr>
<tr><td><code id="print.GPArotation_+3A_rotatemat">rotateMat</code></td>
<td>
<p>display the rotation matrix of a GPArotation object.</p>
</td></tr>
<tr><td><code id="print.GPArotation_+3A_table">Table</code></td>
<td>
<p>display the convergence table of a GPArotation object.</p>
</td></tr>
<tr><td><code id="print.GPArotation_+3A_structure">Structure</code></td>
<td>
<p>display the structure matrix of a summary.GPArotation object of a oblique rotation.</p>
</td></tr>
<tr><td><code id="print.GPArotation_+3A_...">...</code></td>
<td>
<p>further arguments passed to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For examples of print and summary functions, see <code><a href="#topic+GPForth">GPForth</a></code>. 
</p>


<h3>Value</h3>

<p>The object printed or a summary object.</p>


<h3>References</h3>

<p>Harman, H.H. (1976). <em>Modern Factor Analysis.</em> The University of Chicago Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GPForth">GPForth</a></code>, 
<code><a href="base.html#topic+summary">summary</a></code>
</p>

<hr>
<h2 id='Random.Start'>Generate a Random Orthogonal Rotation</h2><span id='topic+Random.Start'></span>

<h3>Description</h3>

<p>Random orthogonal rotation to use as Tmat matrix to start GPFRSorth, GPFRSoblq, GPForth, or GPFoblq.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    Random.Start(k)
    </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Random.Start_+3A_k">k</code></td>
<td>
<p>An integer indicating the dimension of the square matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The random start function produces an orthogonal matrix with columns
of length one based on the QR decompostion. This randomization procedures
follows the logic of Stewart(1980) and Mezzari(2007), as of GPArotation version 2024.2-1.
</p>


<h3>Value</h3>

<p>An orthogonal matrix.</p>


<h3>Author(s)</h3>

<p>Coen A. Bernaards and Robert I. Jennrich
with some R modifications by Paul Gilbert. Additional input from Yves Rosseel.
</p>


<h3>References</h3>

<p>Stewart, G. W. (1980). The Efficient Generation of Random Orthogonal Matrices 
with an Application to Condition Estimators. 
<em>SIAM Journal on Numerical Analysis</em>, 
<b>17</b>(3), 403&ndash;409. http://www.jstor.org/stable/2156882
</p>
<p>Mezzadri, F. (2007). How to generate random matrices from the classical
compact groups. <em>Notices of the American Mathematical Society</em>, <b>54</b>(5), 592&ndash;604.
https://arxiv.org/abs/math-ph/0609050
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GPFRSorth">GPFRSorth</a></code>, 
<code><a href="#topic+GPFRSoblq">GPFRSoblq</a></code>,
<code><a href="#topic+GPForth">GPForth</a></code>, 
<code><a href="#topic+GPFoblq">GPFoblq</a></code>,
<code><a href="#topic+rotations">rotations</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Generate a random ortogonal matrix of dimension 5 x 5
  Random.Start(5)
  
  # function for generating orthogonal or oblique random matrix
  Random.Start &lt;- function(k = 2L,orthogonal=TRUE){
    mat &lt;- matrix(rnorm(k*k),k)
    if (orthogonal){
      qr.out &lt;- qr(matrix(rnorm(k * k), nrow = k, ncol = k))
      Q &lt;- qr.Q(qr.out)
      R &lt;- qr.R(qr.out)
      R.diag &lt;- diag(R)
      R.diag2 &lt;- R.diag/abs(R.diag)
      ans &lt;- t(t(Q) * R.diag2)
      ans
      }
    else{
	  ans &lt;- mat %*% diag(1/sqrt(diag(crossprod(mat))))
 	  }
    ans
    }
    	
  data("Thurstone", package="GPArotation")
  simplimax(box26,Tmat = Random.Start(3, orthogonal = TRUE))
  simplimax(box26,Tmat = Random.Start(3, orthogonal = FALSE))

  # covariance matrix is Phi = t(Th) %*% Th
  rms &lt;- Random.Start(3, FALSE)
  t(rms) %*% rms # covariance matrix because oblique rms
  rms &lt;- Random.Start(3, TRUE)
  t(rms) %*% rms # identity matrix because orthogonal rms
	
   </code></pre>

<hr>
<h2 id='rotations'>Rotations</h2><span id='topic+rotations'></span><span id='topic+oblimin'></span><span id='topic+quartimin'></span><span id='topic+targetT'></span><span id='topic+targetQ'></span><span id='topic+pstT'></span><span id='topic+pstQ'></span><span id='topic+oblimax'></span><span id='topic+entropy'></span><span id='topic+quartimax'></span><span id='topic+Varimax'></span><span id='topic+simplimax'></span><span id='topic+bentlerT'></span><span id='topic+bentlerQ'></span><span id='topic+tandemI'></span><span id='topic+tandemII'></span><span id='topic+geominT'></span><span id='topic+geominQ'></span><span id='topic+bigeominT'></span><span id='topic+bigeominQ'></span><span id='topic+cfT'></span><span id='topic+cfQ'></span><span id='topic+equamax'></span><span id='topic+parsimax'></span><span id='topic+infomaxT'></span><span id='topic+infomaxQ'></span><span id='topic+mccammon'></span><span id='topic+varimin'></span><span id='topic+bifactorT'></span><span id='topic+bifactorQ'></span>

<h3>Description</h3>

<p>Optimize factor loading rotation objective.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    oblimin(A, Tmat=diag(ncol(A)), gam=0, normalize=FALSE, eps=1e-5, 
    		maxit=1000, randomStarts=0)
    quartimin(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, 
    		maxit=1000, randomStarts=0)
    targetT(A, Tmat=diag(ncol(A)), Target=NULL, normalize=FALSE, eps=1e-5, 
    		maxit=1000, randomStarts=0, L=NULL)
    targetQ(A, Tmat=diag(ncol(A)), Target=NULL, normalize=FALSE, eps=1e-5, 
    		maxit=1000, randomStarts=0, L=NULL)
    pstT(A, Tmat=diag(ncol(A)), W=NULL, Target=NULL, normalize=FALSE, eps=1e-5, 
    		maxit=1000, randomStarts=0, L=NULL)
    pstQ(A, Tmat=diag(ncol(A)), W=NULL, Target=NULL, normalize=FALSE, eps=1e-5, 
    		maxit=1000, randomStarts=0, L=NULL)
    oblimax(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000, randomStarts=0)
    entropy(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000, randomStarts=0)
    quartimax(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5,maxit=1000,randomStarts=0)
    Varimax(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000, randomStarts=0)
    simplimax(A, Tmat=diag(ncol(A)), k=nrow(A), normalize=FALSE, eps=1e-5, 
    		maxit=1000, randomStarts=0)
    bentlerT(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000, randomStarts=0)
    bentlerQ(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000, randomStarts=0)
    tandemI(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000, randomStarts=0)
    tandemII(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000, randomStarts=0)
    geominT(A, Tmat=diag(ncol(A)), delta=.01, normalize=FALSE, eps=1e-5, 
    		maxit=1000, randomStarts=0)
    geominQ(A, Tmat=diag(ncol(A)), delta=.01, normalize=FALSE, eps=1e-5, 
    		maxit=1000, randomStarts=0)
    bigeominT(A, Tmat=diag(ncol(A)), delta=.01, normalize=FALSE, eps=1e-5, 
    		maxit=1000, randomStarts=0)
    bigeominQ(A, Tmat=diag(ncol(A)), delta=.01, normalize=FALSE, eps=1e-5, 
    		maxit=1000, randomStarts=0)
    cfT(A, Tmat=diag(ncol(A)), kappa=0, normalize=FALSE, eps=1e-5, 
    		maxit=1000, randomStarts=0)
    cfQ(A, Tmat=diag(ncol(A)), kappa=0, normalize=FALSE, eps=1e-5, 
    		maxit=1000, randomStarts=0)
    equamax(A, Tmat=diag(ncol(A)), kappa=ncol(A)/(2*nrow(A)), normalize=FALSE,
    		eps=1e-5, maxit=1000, randomStarts = 0)
    parsimax(A, Tmat=diag(ncol(A)), kappa=(ncol(A)-1)/(ncol(A)+nrow(A)-2), 
    		normalize=FALSE, eps=1e-5, maxit=1000, randomStarts = 0)
    infomaxT(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000, randomStarts=0)
    infomaxQ(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000, randomStarts=0)
    mccammon(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000, randomStarts=0)
    varimin(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000, randomStarts=0)
    bifactorT(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000,randomStarts=0)
    bifactorQ(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000,randomStarts=0)
    </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotations_+3A_a">A</code></td>
<td>
<p>an initial loadings matrix to be rotated.</p>
</td></tr>
<tr><td><code id="rotations_+3A_tmat">Tmat</code></td>
<td>
<p>initial rotation matrix.</p>
</td></tr>
<tr><td><code id="rotations_+3A_gam">gam</code></td>
<td>
<p>0=Quartimin, .5=Biquartimin, 1=Covarimin.</p>
</td></tr>
<tr><td><code id="rotations_+3A_target">Target</code></td>
<td>
<p>rotation target for objective calculation.</p>
</td></tr>
<tr><td><code id="rotations_+3A_w">W</code></td>
<td>
<p>weighting of each element in target.</p>
</td></tr>
<tr><td><code id="rotations_+3A_k">k</code></td>
<td>
<p>number of close to zero loadings.</p>
</td></tr>
<tr><td><code id="rotations_+3A_delta">delta</code></td>
<td>
<p>constant added to Lambda^2 in objective calculation.</p>
</td></tr>
<tr><td><code id="rotations_+3A_kappa">kappa</code></td>
<td>
<p>see details.</p>
</td></tr>
<tr><td><code id="rotations_+3A_normalize">normalize</code></td>
<td>
<p>parameter passed to optimization routine (GPForth or GPFoblq).</p>
</td></tr>
<tr><td><code id="rotations_+3A_eps">eps</code></td>
<td>
<p>parameter passed to optimization routine (GPForth or GPFoblq).</p>
</td></tr>
<tr><td><code id="rotations_+3A_maxit">maxit</code></td>
<td>
<p>parameter passed to optimization routine (GPForth or GPFoblq).</p>
</td></tr>
<tr><td><code id="rotations_+3A_randomstarts">randomStarts</code></td>
<td>
<p>parameter passed to optimization routine (GPFRSorth or GPFRSoblq).</p>
</td></tr>
<tr><td><code id="rotations_+3A_l">L</code></td>
<td>
<p>provided for backward compatibility in target rotations only. Use A going forward.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions optimize a rotation objective. They can be used directly or the
function name can be passed to factor analysis functions like <code>factanal</code>.
Several of the function names end in T or Q, which indicates if they are
orthogonal or oblique rotations (using <code>GPFRSorth</code> or <code>GPFRSoblq</code>
respectively).  
</p>
<p>Rotations which are available are 
</p>

<table>
<tr>
 <td style="text-align: left;">
 <code>oblimin</code>   </td><td style="text-align: left;"> oblique    </td><td style="text-align: left;">  oblimin family 			</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>quartimin</code> </td><td style="text-align: left;"> oblique	   </td><td style="text-align: left;">         				</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>targetT</code>   </td><td style="text-align: left;"> orthogonal </td><td style="text-align: left;">  target rotation			</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>targetQ</code>   </td><td style="text-align: left;"> oblique    </td><td style="text-align: left;">  target rotation			</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>pstT</code>	   </td><td style="text-align: left;"> orthogonal </td><td style="text-align: left;">  partially specified target rotation	</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>pstQ</code>	   </td><td style="text-align: left;"> oblique    </td><td style="text-align: left;">  partially specified target rotation	</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>oblimax</code>   </td><td style="text-align: left;"> oblique	   </td><td style="text-align: left;">         				</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>entropy</code>   </td><td style="text-align: left;"> orthogonal </td><td style="text-align: left;">  minimum entropy			</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>quartimax</code> </td><td style="text-align: left;"> orthogonal </td><td style="text-align: left;"> 					</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>varimax</code>   </td><td style="text-align: left;"> orthogonal </td><td style="text-align: left;"> 					</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>simplimax</code> </td><td style="text-align: left;"> oblique	   </td><td style="text-align: left;">         				</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>bentlerT</code>  </td><td style="text-align: left;"> orthogonal </td><td style="text-align: left;">  Bentler's invariant pattern simplicity criterion</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>bentlerQ</code>  </td><td style="text-align: left;"> oblique    </td><td style="text-align: left;">  Bentler's invariant pattern simplicity criterion</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>tandemI</code>   </td><td style="text-align: left;"> orthogonal </td><td style="text-align: left;">  Tandem principle I criterion		   </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>tandemII</code>  </td><td style="text-align: left;"> orthogonal </td><td style="text-align: left;">  Tandem principle II criterion		   </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>geominT</code>   </td><td style="text-align: left;"> orthogonal </td><td style="text-align: left;"> 				   </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>geominQ</code>   </td><td style="text-align: left;"> oblique	   </td><td style="text-align: left;">         			   </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>bigeominT</code> </td><td style="text-align: left;"> orthogonal </td><td style="text-align: left;"> 				   </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>bigeominQ</code> </td><td style="text-align: left;"> oblique	   </td><td style="text-align: left;">         			   </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>cfT</code>	   </td><td style="text-align: left;"> orthogonal </td><td style="text-align: left;">  Crawford-Ferguson family	   </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>cfQ</code>	   </td><td style="text-align: left;"> oblique	   </td><td style="text-align: left;">  Crawford-Ferguson family	   </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>equamax</code>   </td><td style="text-align: left;"> orthogonal </td><td style="text-align: left;">  Crawford-Ferguson family	   </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>parsimax</code>  </td><td style="text-align: left;"> orthogonal </td><td style="text-align: left;">  Crawford-Ferguson family	   </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>infomaxT</code>  </td><td style="text-align: left;"> orthogonal </td><td style="text-align: left;"> 				   </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>infomaxQ</code>  </td><td style="text-align: left;"> oblique	   </td><td style="text-align: left;">         			   </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>mccammon</code>  </td><td style="text-align: left;"> orthogonal </td><td style="text-align: left;">  McCammon minimum entropy ratio    </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>varimin</code>   </td><td style="text-align: left;"> orthogonal </td><td style="text-align: left;"> 				   </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>bifactorT</code> </td><td style="text-align: left;"> orthogonal </td><td style="text-align: left;">  Jennrich and Bentler bifactor rotation</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>bifactorQ</code> </td><td style="text-align: left;"> oblique    </td><td style="text-align: left;">  Jennrich and Bentler biquartimin rotation</td>
</tr>
<tr>
 <td style="text-align: left;">
 </td>
</tr>

</table>

<p>Note that <code>Varimax</code> defined here uses <code>vgQ.varimax</code> and 
is not <code>varimax</code>
defined in the <code>stats</code> package. <code>stats:::varimax</code> does Kaiser 
normalization by default whereas <code>Varimax</code> defined here does not.
</p>
<p>The argument <code>kappa</code> parameterizes the family for the Crawford-Ferguson 
method. If <code>m</code> is the number of factors and <code>p</code> is the number of 
indicators then <code>kappa</code> values having special names are 0=Quartimax, 
1/p=Varimax, m/(2*p)=Equamax, (m-1)/(p+m-2)=Parsimax, 1=Factor parsimony.
</p>


<h3>Value</h3>

<p>A list (which includes elements used by <code>factanal</code>) with:
</p>
<table>
<tr><td><code>loadings</code></td>
<td>
<p>Lh from <code>GPFRSorth</code> or <code>GPFRSoblq</code>.</p>
</td></tr> 
<tr><td><code>Th</code></td>
<td>
<p>Th from <code>GPFRSorth</code> or <code>GPFRSoblq</code>.</p>
</td></tr>  
<tr><td><code>Table</code></td>
<td>
<p>Table from <code>GPForth</code> or <code>GPFoblq</code>.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>A string indicating the rotation objective function.</p>
</td></tr>
<tr><td><code>orthogonal</code></td>
<td>
<p>A logical indicating if the rotation is orthogonal.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>Convergence indicator from <code>GPFRSorth</code> or <code>GPFRSoblq</code>.</p>
</td></tr>
<tr><td><code>Phi</code></td>
<td>
<p>t(Th) %*% Th.  The covariance matrix of the rotated factors.
This will be the identity matrix for orthogonal
rotations so is omitted (NULL) for the result from GPFRSorth and GPForth.</p>
</td></tr>
<tr><td><code>randStartChar</code></td>
<td>
<p>Vector indicating results from random starts 
from <code>GPFRSorth</code> or <code>GPFRSoblq</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Coen A. Bernaards and Robert I. Jennrich
with some R modifications by Paul Gilbert.</p>


<h3>References</h3>

<p>Bernaards, C.A. and Jennrich, R.I. (2005) Gradient Projection Algorithms 
and Software for Arbitrary Rotation Criteria in Factor Analysis. 
<em>Educational and Psychological Measurement</em>, <b>65</b>, 676&ndash;696.
</p>
<p>Bifactor rotation, bifactorT and bifactorQ are called bifactor and
biquartimin in Jennrich, R.I. and Bentler, P.M. 
(2011) Exploratory bi-factor analysis. <em>Psychometrika</em>, <b>76</b>. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GPFRSorth">GPFRSorth</a></code>, 
<code><a href="#topic+GPFRSoblq">GPFRSoblq</a></code>, 
<code><a href="#topic+vgQ">vgQ</a></code>,
<code><a href="#topic+eiv">eiv</a></code>, 
<code><a href="#topic+echelon">echelon</a></code>, 
<code><a href="#topic+WansbeekMeijer">WansbeekMeijer</a></code>, 
<code><a href="stats.html#topic+factanal">factanal</a></code>, 
<code><a href="stats.html#topic+varimax">varimax</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # see GPFRSorth and GPFRSoblq for more examples
  
  # getting loadings matrices
  data("Harman", package="GPArotation")
  qHarman  &lt;- GPFRSorth(Harman8, Tmat=diag(2), method="quartimax")
  qHarman &lt;- quartimax(Harman8) 
  loadings(qHarman) - qHarman$loadings   #2 ways to get the loadings

  # factanal loadings used in GPArotation
  data("WansbeekMeijer", package="GPArotation")
  fa.unrotated  &lt;- factanal(factors = 2, covmat=NetherlandsTV, normalize=TRUE, rotation="none")
  quartimax(loadings(fa.unrotated), normalize=TRUE)
  geominQ(loadings(fa.unrotated), normalize=TRUE, randomStarts=100)

  # passing arguments to factanal (See vignette for a caution)
  # vignette("GPAguide", package = "GPArotation")
  data(ability.cov)
  factanal(factors = 2, covmat = ability.cov, rotation="infomaxT")
  factanal(factors = 2, covmat = ability.cov, rotation="infomaxT", 
    control=list(rotate=list(normalize = TRUE, eps = 1e-6)))
  # when using factanal for oblique rotation it is best to use the rotation command directly
  # instead of including it in the factanal command (see Vignette).  
  fa.unrotated  &lt;- factanal(factors = 3, covmat=NetherlandsTV, normalize=TRUE, rotation="none")
  quartimin(loadings(fa.unrotated), normalize=TRUE)

  # oblique target rotation of 2 varimax rotated matrices towards each other
  # See vignette for additional context and computation,
  trBritain &lt;- matrix( c(.783,-.163,.811,.202,.724,.209,.850,.064,
    -.031,.592,-.028,.723,.388,.434,.141,.808,.215,.709), byrow=TRUE, ncol=2)
  trGermany &lt;- matrix( c(.778,-.066, .875,.081, .751,.079, .739,.092,
    .195,.574, -.030,.807, -.135,.717, .125,.738, .060,.691), byrow=TRUE, ncol = 2)
  trx &lt;- targetQ(trGermany, Target = trBritain)
  # Difference between rotated loadings matrix and target matrix 
  y &lt;- trx$loadings - trBritain
  
  # partially specified target; See vignette for additional method
  A &lt;- matrix(c(.664, .688, .492, .837, .705, .82, .661, .457, .765, .322, 
    .248, .304, -0.291, -0.314, -0.377, .397, .294, .428, -0.075,.192,.224,
    .037, .155,-.104,.077,-.488,.009), ncol=3)  
  SPA &lt;- matrix(c(rep(NA, 6), .7,.0,.7, rep(0,3), rep(NA, 7), 0,0, NA, 0, rep(NA, 4)), ncol=3)
  targetT(A, Target=SPA)

  # using random starts
  data("WansbeekMeijer", package="GPArotation")
  fa.unrotated  &lt;- factanal(factors = 3, covmat=NetherlandsTV, normalize=TRUE, rotation="none")
  # single rotation with a random start
  oblimin(loadings(fa.unrotated), Tmat=Random.Start(3))
  oblimin(loadings(fa.unrotated), randomStarts=1)
  # multiple random starts
  oblimin(loadings(fa.unrotated), randomStarts=100)

  # assessing local minima for box26 data
  data(Thurstone, package = "GPArotation")
  infomaxQ(box26, normalize = TRUE, randomStarts = 150)
  geominQ(box26, normalize = TRUE, randomStarts = 150)
  # for detailed investigation of local minima, consult package 'fungible' 
  # library(fungible)
  # faMain(urLoadings=box26, rotate="geominQ", rotateControl=list(numberStarts=150))
  # library(psych) # package 'psych' with random starts:
  # faRotations(box26, rotate = "geominQ", hyper = 0.15, n.rotations = 150)

  </code></pre>

<hr>
<h2 id='Thurstone'>Example Data from Thurstone</h2><span id='topic+Thurstone'></span><span id='topic+box20'></span><span id='topic+box26'></span>

<h3>Description</h3>

<p>box20 and box26 are initial factor loading matrices.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	data(Thurstone)
</code></pre>


<h3>Format</h3>

<p>The objects box20 and box26 are matrices.
</p>


<h3>Details</h3>

<p>The objects box20 and box26 are loaded from the data file Thurstone.
</p>


<h3>Source</h3>

<p>Thurstone, L.L. (1947). <em>Multiple Factor Analysis</em>. 
Chicago: University of Chicago Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GPForth">GPForth</a></code>,
<code><a href="#topic+Harman">Harman</a></code>,
<code><a href="#topic+WansbeekMeijer">WansbeekMeijer</a></code>
</p>

<hr>
<h2 id='vgQ'>Rotations</h2><span id='topic+vgQ'></span><span id='topic+vgQ.oblimin'></span><span id='topic+vgQ.quartimin'></span><span id='topic+vgQ.target'></span><span id='topic+vgQ.pst'></span><span id='topic+vgQ.oblimax'></span><span id='topic+vgQ.entropy'></span><span id='topic+vgQ.quartimax'></span><span id='topic+vgQ.varimax'></span><span id='topic+vgQ.simplimax'></span><span id='topic+vgQ.bentler'></span><span id='topic+vgQ.tandemI'></span><span id='topic+vgQ.tandemII'></span><span id='topic+vgQ.geomin'></span><span id='topic+vgQ.bigeomin'></span><span id='topic+vgQ.cf'></span><span id='topic+vgQ.infomax'></span><span id='topic+vgQ.mccammon'></span><span id='topic+vgQ.bifactor'></span><span id='topic+vgQ.varimin'></span>

<h3>Description</h3>

<p>vgQ routines to compute value and gradient of the criterion (not exported from NAMESPACE)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    vgQ.oblimin(L, gam=0)
    vgQ.quartimin(L)
    vgQ.target(L, Target=NULL)
    vgQ.pst(L, W=NULL, Target=NULL)
    vgQ.oblimax(L)
    vgQ.entropy(L)
    vgQ.quartimax(L)
    vgQ.varimax(L)
    vgQ.simplimax(L, k=nrow(L))
    vgQ.bentler(L)
    vgQ.tandemI(L)
    vgQ.tandemII(L)
    vgQ.geomin(L, delta=.01)
    vgQ.bigeomin(L, delta=.01)
    vgQ.cf(L, kappa=0)
    vgQ.infomax(L)
    vgQ.mccammon(L)
    vgQ.varimin(L)
    vgQ.bifactor(L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vgQ_+3A_l">L</code></td>
<td>
<p>a factor loading matrix</p>
</td></tr>
<tr><td><code id="vgQ_+3A_gam">gam</code></td>
<td>
<p>0=Quartimin, .5=Biquartimin, 1=Covarimin.</p>
</td></tr>
<tr><td><code id="vgQ_+3A_target">Target</code></td>
<td>
<p>rotation target for objective calculation.</p>
</td></tr>
<tr><td><code id="vgQ_+3A_w">W</code></td>
<td>
<p>weighting of each element in target.</p>
</td></tr>
<tr><td><code id="vgQ_+3A_k">k</code></td>
<td>
<p>number of close to zero loadings.</p>
</td></tr>
<tr><td><code id="vgQ_+3A_delta">delta</code></td>
<td>
<p>constant added to Lambda^2 in objective calculation.</p>
</td></tr>
<tr><td><code id="vgQ_+3A_kappa">kappa</code></td>
<td>
<p>see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>vgQ.*</code> versions of the code are called by the optimization routine and
would typically not be used directly, so these methods are not exported
from the package NAMESPACE. (They simply return the function value and gradient
for a given rotation matrix.) You can print these functions, but the package 
name needs to be specified since they are not exported. For example, use
<code>GPArotation:::vgQ.oblimin</code> to view the function <code>vgQ.oblimin</code>.
The T or Q ending on function names should be omitted for the <code>vgQ.*</code> 
versions of the code so, for example, use <code>GPArotation:::vgQ.target</code> to view the target
criterion calculation.
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>vgQ.oblimin</code>   </td><td style="text-align: left;"> orthogonal or oblique </td><td style="text-align: left;">  oblimin family</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>vgQ.quartimin</code> </td><td style="text-align: left;"> oblique	   </td><td style="text-align: left;">         				</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>vgQ.target</code>    </td><td style="text-align: left;"> orthogonal or oblique </td><td style="text-align: left;">  target rotation			</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>vgQ.pst</code>	   </td><td style="text-align: left;"> orthogonal or oblique </td><td style="text-align: left;">  partially specified target rotation	</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>vgQ.oblimax</code>   </td><td style="text-align: left;"> oblique	   </td><td style="text-align: left;">         				</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>vgQ.entropy</code>   </td><td style="text-align: left;"> orthogonal </td><td style="text-align: left;">  minimum entropy			</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>vgQ.quartimax</code> </td><td style="text-align: left;"> orthogonal </td><td style="text-align: left;"> 					</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>vgQ.varimax</code>   </td><td style="text-align: left;"> orthogonal </td><td style="text-align: left;"> 					</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>vgQ.simplimax</code> </td><td style="text-align: left;"> oblique	   </td><td style="text-align: left;">         				</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>vgQ.bentler</code>   </td><td style="text-align: left;"> orthogonal or oblique </td><td style="text-align: left;">  Bentler's invariant pattern simplicity criterion</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>vgQ.tandemI</code> </td><td style="text-align: left;"> orthogonal	   </td><td style="text-align: left;"> Tandem principle I criterion	</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>vgQ.tandemII</code> </td><td style="text-align: left;"> orthogonal	   </td><td style="text-align: left;"> Tandem principle II criterion	</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>vgQ.geomin</code>    </td><td style="text-align: left;"> orthogonal or oblique  </td><td style="text-align: left;"> 				   </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>vgQ.bigeomin</code>    </td><td style="text-align: left;"> orthogonal or oblique  </td><td style="text-align: left;"> 				   </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>vgQ.cf</code>		   </td><td style="text-align: left;"> orthogonal or oblique </td><td style="text-align: left;">  Crawford-Ferguson family	   </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>vgQ.cubimax</code>   </td><td style="text-align: left;"> orthogonal    </td><td style="text-align: left;">  	</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>vgQ.infomax</code>   </td><td style="text-align: left;"> orthogonal or oblique   </td><td style="text-align: left;"> 				   </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>vgQ.mccammon</code>   </td><td style="text-align: left;"> orthogonal    </td><td style="text-align: left;"> McCammon minimum entropy ratio  </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>vgQ.varimin</code> </td><td style="text-align: left;"> orthogonal </td><td style="text-align: left;"> varimin criterion </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>vgQ.bifactor</code> </td><td style="text-align: left;"> orthogonal or oblique </td><td style="text-align: left;"> bifactor/biquartimin rotation</td>
</tr>
<tr>
 <td style="text-align: left;">
 </td>
</tr>

</table>

<p>See <a href="#topic+rotations">rotations</a> for use of arguments.
</p>
<p>New rotation methods can be programmed with a name &quot;vgQ.newmethod&quot;. The 
inputs are the matrix L, and optionally any additional arguments. The
output should be a list with elements <code>f</code>, <code>Gq</code>, and <code>Method</code>.
</p>
<p>Gradient projection <em>without</em> derivatives can be performed using the
<code>GPArotateDF</code> package; type <code>vignette("GPArotateDF", package = "GPArotation")</code>
at the command line.
</p>


<h3>Value</h3>

<p>A list (which includes elements used by <code>GPForth</code> and <code>GPFoblq</code>) with:
</p>
<table>
<tr><td><code>f</code></td>
<td>
<p>The value of the criterion at L.</p>
</td></tr>
<tr><td><code>Gq</code></td>
<td>
<p>The gradient at L.</p>
</td></tr>
<tr><td><code>Method</code></td>
<td>
<p>A string indicating the criterion.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Coen A. Bernaards and Robert I. Jennrich
with some R modifications by Paul Gilbert.</p>


<h3>References</h3>

<p>Bernaards, C.A. and Jennrich, R.I. (2005) Gradient Projection Algorithms 
and Software for Arbitrary Rotation Criteria in Factor Analysis. 
<em>Educational and Psychological Measurement</em>, <b>65</b>, 676&ndash;696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rotations">rotations</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  GPArotation:::vgQ.oblimin
  getAnywhere(vgQ.oblimax)	
  
</code></pre>

<hr>
<h2 id='WansbeekMeijer'>Factor Example from Wansbeek and Meijer</h2><span id='topic+WansbeekMeijer'></span><span id='topic+NetherlandsTV'></span>

<h3>Description</h3>

<p>Netherlands TV viewership example p 171, Wansbeek and Meijer (2000) 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	data(WansbeekMeijer)
</code></pre>


<h3>Format</h3>

<p>The object NetherlandsTV is a correlation matrix.
</p>


<h3>Details</h3>

<p>The object NetherlandsTV is loaded from the data file WansbeekMeijer.
</p>


<h3>Source</h3>

<p>Tom Wansbeek and Erik Meijer (2000) <em>Measurement 
Error and Latent Variables in Econometrics</em>, Amsterdam: North-Holland.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GPForth">GPForth</a></code>,
<code><a href="#topic+Thurstone">Thurstone</a></code>,
<code><a href="#topic+Harman">Harman</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
