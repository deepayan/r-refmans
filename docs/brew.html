<!DOCTYPE html><html><head><title>Help for package brew</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {brew}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#brew'><p>Report Brewing For Text and R Output</p></a></li>
<li><a href='#brewCache'><p>Caching Brew Templates</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Templating Framework for Report Generation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-10</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements a templating framework for mixing text and R code
    for report generation. brew template syntax is similar to PHP, Ruby's
    erb module, Java Server Pages, and Python's psp module.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/gregfrog/brew">https://github.com/gregfrog/brew</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gregfrog/brew/issues">https://github.com/gregfrog/brew/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-16 07:21:30 UTC; greg</td>
</tr>
<tr>
<td>Author:</td>
<td>Jeffrey Horner [aut, cph],
  Greg Hunt [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Greg Hunt &lt;greg@firmansyah.com&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-16 08:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='brew'>Report Brewing For Text and R Output</h2><span id='topic+brew'></span>

<h3>Description</h3>

<p><code>brew</code> provides a templating system for text reporting. The syntax is similar to PHP,
Java Server Pages, Ruby's erb module, and Python's psp module.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brew(file=stdin(),output=stdout(),text=NULL,envir=parent.frame(),
     run=TRUE,parseCode=TRUE,tplParser=NULL,chdir=FALSE, extendedErrorReport=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brew_+3A_file">file</code></td>
<td>
<p>A connection, or a character string naming the file
to read from. stdin() is the default.</p>
</td></tr>
<tr><td><code id="brew_+3A_output">output</code></td>
<td>
<p>A connection, or a character string naming the file
to print to. stdout() is the default.</p>
</td></tr>
<tr><td><code id="brew_+3A_text">text</code></td>
<td>
<p> A character string treated as if it contained lines of a file
to read from. Only one of <code>file</code> or <code>text</code> is used as input. 
Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="brew_+3A_envir">envir</code></td>
<td>
<p>the <code><a href="base.html#topic+environment">environment</a></code> in which the input is to
be evaluated.  Default is the caller's environment, useful for 
nested <code>brew</code> calls.</p>
</td></tr>
<tr><td><code id="brew_+3A_run">run</code></td>
<td>
<p>Logical to determine if <code>brew</code> should evaluate the input (<code>run=TRUE</code>) or 
just parse it (<code>run=FALSE</code>). Useful for debugging.</p>
</td></tr>
<tr><td><code id="brew_+3A_parsecode">parseCode</code></td>
<td>
<p>Logical. only relevant when run=FALSE. When TRUE the brewed code is parsed and then silently returned. When FALSE, the brewed code is returned as a list. See the Value section for details.</p>
</td></tr>
<tr><td><code id="brew_+3A_tplparser">tplParser</code></td>
<td>
<p>a function to parse the text between '&lt;%%' and '%%&gt;' and return the result as
a character vector. The template text is passed to the function as a variable
length character vector in the first argument position.</p>
</td></tr>
<tr><td><code id="brew_+3A_chdir">chdir</code></td>
<td>
<p>logical; if <code>TRUE</code> and <code>file</code> is a pathname, the R working
directory is temporarily changed to the directory containing
<code>file</code> for evaluating. <code>brew</code> will also honor the global option <code>brew.chdir</code>.</p>
</td></tr>
<tr><td><code id="brew_+3A_extendederrorreport">extendedErrorReport</code></td>
<td>
<p>changes error handling behaviour to print a stack trace when an error occurs, the global option <code>brew.extended.error</code> can also be used to achive the same effect.  Existing brew behaviour is preserved if this switch is not set to TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>brew syntax is quite simple and there are very few delimiters to learn:
</p>

<ul>
<li><p>1. All text that falls outside of the delimiters is printed as-is.
</p>
</li>
<li><p>2. R expressions between the '&lt;%' and '%&gt;' delimiters are executed in-place.
</p>
</li>
<li><p>3. The value of the R expression between the '&lt;%=' and '%&gt;' delimiters is printed.
</p>
</li>
<li><p>4. All text between the '&lt;%#' and '%&gt;' delimiters is thrown away. Use it as a comment.
</p>
</li>
<li><p>5. If you place a '-' just before the '%&gt;' delimiter, and it's placed at the end of a line, then the newline is omitted from the output.
</p>
</li></ul>

<p>The following template contains syntax to exercise all <code>brew</code> functionality:
</p>
<pre>
---------------
You won't see this R output, but it will run. &lt;% foo &lt;- 'bar' %&gt;
Now foo is &lt;%=foo%&gt; and today is &lt;%=format(Sys.time(),'%B %d, %Y')%&gt;.
&lt;%# Comment -- ignored -- useful in testing. 
    Also notice the dash-percent-gt.
    It chops off the trailing newline. 
    You can add it to any percent-gt. -%&gt;
How about generating a template from a template?
&lt;%% foo &lt;- 'fee fi fo fum' %%&gt;
foo is still &lt;%=foo%&gt;.
---------------
</pre>
<p>The output is:
</p>
<pre>
--------------
You won't see this R output, but it will run.
Now foo is bar and today is April 20, 2007.
How about generating a template from a template?
&lt;% foo &lt;- 'fee fi fo fum' %&gt;
foo is still bar.
--------------
</pre>
<p>Also, for power users, there's one more thing:
</p>

<ul>
<li><p>6. Text between the '&lt;%%' and '%%&gt;' delimiters is treated as a brew template and
is printed as-is, but the delimiters are changed to '&lt;%' and '%&gt;'. This happens when tplParser=NULL. But if tplParser is a valid function, then the text is passed to tplParser which should return a character vector to replace the text.
</p>
</li></ul>

<p>NOTE: brew calls can be nested and rely on placing a function named '.brew.cat' in the environment in which it is passed. Each time brew is called, a check for the existence of this function is made. If it exists, then it is replaced with a new copy that is lexically scoped to the current brew frame. Once the brew call is done, the function is replaced with the previous function. The function is finally removed from the environment once all brew calls return.
</p>


<h3>Value</h3>

<p>When <code>run=TRUE</code>, the value of the last expression after brewing the input or an object of class 'try-error' containing the error message if brewing failed.
</p>
<p>When <code>run=FALSE</code> and <code>parseCode=TRUE</code>, a function whose environment contains the text vector and the code vector of the parsed expressions after brewing the input. It takes brew's output and envir arguments.
</p>
<p>When <code>run=FALSE</code> and <code>parseCode=FALSE</code>, a list containing the text vector and the unparsed code vector.
</p>


<h3>Author(s)</h3>

<p> Jeffrey Horner &lt;jeff.horner@vanderbilt.edu&gt; </p>


<h3>See Also</h3>

 <p><code><a href="utils.html#topic+Sweave">Sweave</a></code> for the original report generator. </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## A port of the Sweave test file.
brew(system.file("brew-test-1.brew",package="brew"),"brew-test-1.tex",envir=new.env())
##clean up generated files
unlink("brew-test-1-1.eps")
unlink("brew-test-1-2.eps")
unlink("brew-test-1.tex")

## Everything you wanted to know about your R session.
brew(system.file("brew-test-2.brew",package="brew"),"brew-test-2.html",envir=new.env())
browseURL(paste('file://',file.path(getwd(),'brew-test-2.html'),sep=''))

## clean up generated files
unlink("brew-test-2.html")

## Don't sully up environment, so use envir=new.env(). Nested brew calls will still work.
brew(system.file("example1.brew",package="brew"),envir=new.env())

## Various ways to print R output 
library(datasets)
brew(system.file("catprint.brew",package="brew"),envir=new.env())
rm(iris)

## The example from the Details section
brew(system.file("featurefull.brew",package="brew"),envir=new.env())

## Using the tplParser argument
tParse &lt;- function(text) paste('Got this: &lt;',text,'&gt;\n',sep='',collapse='')
brew(system.file("featurefull.brew",package="brew"),envir=new.env(),tplParser=tParse)
rm(tParse)
</code></pre>

<hr>
<h2 id='brewCache'>Caching Brew Templates</h2><span id='topic+brewCache'></span><span id='topic+setBufLen'></span><span id='topic+brewCacheOn'></span><span id='topic+brewCacheOff'></span>

<h3>Description</h3>

<p>These functions provide a cache system for brew templates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brewCache(envir=NULL)

brewCacheOn()
brewCacheOff()

setBufLen(len=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brewCache_+3A_envir">envir</code></td>
<td>
<p>the <code><a href="base.html#topic+environment">environment</a></code> to store text and R expressions for
each brewed template.</p>
</td></tr>
<tr><td><code id="brewCache_+3A_len">len</code></td>
<td>
<p>length of internal buffers for parsing the templates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>brew can cache parsed templates for potential speedup but only when brew
calls are passed filenames, not connections, and when tplParser
is NULL.
</p>
<p>brew caching is implemented by storing file names, modification
times, and the associated text and R expressions in an internal
environment. Calling <code>brewCache()</code> with an appropriate
environment sets the internal cache. Calling without arguments
returns the internal cache. The cache is exposed this way mainly
for testing, debugging, performance improvement, etc. and this
may be off-limits in future releases.
</p>
<p>Simple enough, <code>brewCacheOn()</code> turns on
caching of brew templates and is equivalent to calling
<code>brewCache(envir=new.env(hash=TRUE,parent=globalenv()))</code>.
<code>brewCache()</code> without arguments returns the internal
environment. Calling <code>brewCacheOff()</code> turns off caching by
setting the internal environment to <code>NULL</code>.
</p>
<p>One thing to note: filenames act as keys in the internal cache
environment, and brew does nothing to expand them to their full
paths. Thus, '/home/user/brew.html' and '~usr/brew.html' will
act as separate keys, although on-disk they may actually point
to the same file.
</p>
<p><code>setBufLen()</code> initializes internal parsing vectors to length <code>len</code>. Default is 0.
</p>


<h3>Value</h3>

<p><code>brewCache()</code> without arguments returns the internal cache. All others invisibly return <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p> Jeffrey Horner &lt;jeff.horner@vanderbilt.edu&gt; </p>


<h3>See Also</h3>

 <p><code><a href="utils.html#topic+Sweave">Sweave</a></code> for the original report generator. </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Turn on caching
brewCacheOn()

## Brew a template
brew(system.file("featurefull.brew",package="brew"),envir=new.env())

## Get the internal cache
cache &lt;- brewCache()

## Inspect
as.list(cache)

## Inspect first file cached in list
as.list(cache)[[1]]

## Inspect environment that contains text and parsed code
as.list(as.list(cache)[[1]]$env)

## Turn off brew caching
brewCacheOff()
rm(cache)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
