<!DOCTYPE html><html lang="en"><head><title>Help for package mosaicCore</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mosaicCore}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ash_points'><p>Compute knot points of an average shifted histogram</p></a></li>
<li><a href='#coef.function'><p>Extract coefficients from a function</p></a></li>
<li><a href='#columns'><p>return a vector of row or column indices</p></a></li>
<li><a href='#compare'><p>Campare two numeric vectors</p></a></li>
<li><a href='#counts'><p>Compute all proportions or counts</p></a></li>
<li><a href='#coverage'><p>Interval statistics</p></a></li>
<li><a href='#df_stats'><p>Calculate statistics for &quot;response&quot; variables</p></a></li>
<li><a href='#dfapply'><p>apply-type function for data frames</p></a></li>
<li><a href='#ediff'><p>Lagged Differences with equal length</p></a></li>
<li><a href='#evalFormula'><p>Evaluate a formula</p></a></li>
<li><a href='#evalSubFormula'><p>Evaluate a part of a formula</p></a></li>
<li><a href='#fit_distr_fun'><p>Fit a distribution to data and return a function</p></a></li>
<li><a href='#formularise'><p>Convert lazy objects into formulas</p></a></li>
<li><a href='#infer_transformation'><p>Infer a Back-Transformation</p></a></li>
<li><a href='#inspect'><p>Inspect objects</p></a></li>
<li><a href='#joinFrames'><p>Join data frames</p></a></li>
<li><a href='#logical2factor'><p>Convert logical vector into factor</p></a></li>
<li><a href='#logit'><p>Logit and inverse logit functions</p></a></li>
<li><a href='#make_df'><p>Convert to a data frame</p></a></li>
<li><a href='#makeFun'><p>Create a function from a formula</p></a></li>
<li><a href='#modelVars'><p>extract predictor variables from a model</p></a></li>
<li><a href='#mosaic_formula'><p>Convert formulas into standard shapes</p></a></li>
<li><a href='#mosaic_tally'><p>Internal tally methods</p></a></li>
<li><a href='#n_missing'><p>Counting missing/non-missing elements</p></a></li>
<li><a href='#na.warn'><p>Exclude Missing Data with Warning</p></a></li>
<li><a href='#named'><p>List extraction</p></a></li>
<li><a href='#nice_names'><p>Nice names</p></a></li>
<li><a href='#parse.formula'><p>Parse Formulas</p></a></li>
<li><a href='#print.msummary.lm'><p>Modified summaries</p></a></li>
<li><a href='#prop'><p>Compute proportions, percents, or counts for a single level</p></a></li>
<li><a href='#reop_formula'><p>Insert Inhibition of Interpretation/Conversion into formulas</p></a></li>
<li><a href='#rhs_or_expr'><p>Return rhs of a formula or expression</p></a></li>
<li><a href='#tally'><p>Tabulate categorical data</p></a></li>
<li><a href='#vector2df'><p>Convert a vector to a data frame</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Common Utilities for Other MOSAIC-Family Packages</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.4.0</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, dplyr, rlang, tidyr, MASS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mosaicData, mosaic, ggformula, NHANES, testthat, mosaicCalc
(&ge; 0.5.9)</td>
</tr>
<tr>
<td>Author:</td>
<td>Randall Pruim &lt;rpruim@calvin.edu&gt;, Daniel T. Kaplan
    &lt;kaplan@macalester.edu&gt;, Nicholas J. Horton &lt;nhorton@amherst.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Randall Pruim &lt;rpruim@calvin.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Common utilities used in other MOSAIC-family packages are 
    collected here.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ProjectMOSAIC/mosaicCore">https://github.com/ProjectMOSAIC/mosaicCore</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ProjectMOSAIC/mosaicCore/issues">https://github.com/ProjectMOSAIC/mosaicCore/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-05 00:16:16 UTC; rpruim</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-05 01:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ash_points'>Compute knot points of an average shifted histogram</h2><span id='topic+ash_points'></span>

<h3>Description</h3>

<p>Mainly a utility for the <span class="pkg">lattice</span> and <span class="pkg">ggplot2</span> plotting
functions, <code>ash_points()</code> returns the points to be plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ash_points(x, binwidth = NULL, adjust = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ash_points_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="ash_points_+3A_binwidth">binwidth</code></td>
<td>
<p>The width of the histogram bins.  If <code>NULL</code> (the default) the
binwidth will be chosen so that approximately 10 bins cover the data.  <code>adjust</code>
can be used to to increase or decrease <code>binwidth</code>.</p>
</td></tr>
<tr><td><code id="ash_points_+3A_adjust">adjust</code></td>
<td>
<p>A number used to scale <code>binwidth</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing x and y coordinates of the resulting ASH plot.
</p>

<hr>
<h2 id='coef.function'>Extract coefficients from a function</h2><span id='topic+coef.function'></span><span id='topic+coef'></span>

<h3>Description</h3>

<p><code>coef</code>  will extract the coefficients attribute from a function.
Functions created by applying <code>link{makeFun}</code> to a model produced
by <code><a href="stats.html#topic+lm">lm()</a></code>, <code><a href="stats.html#topic+glm">glm()</a></code>, or <code><a href="stats.html#topic+nls">nls()</a></code> store
the model coefficients there to enable this extraction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class ''function''
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.function_+3A_object">object</code></td>
<td>
<p>a function</p>
</td></tr>
<tr><td><code id="coef.function_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(mosaicData)) {
  model &lt;- lm( width ~ length, data = KidsFeet)
  f &lt;- makeFun( model )
  coef(f)
}
</code></pre>

<hr>
<h2 id='columns'>return a vector of row or column indices</h2><span id='topic+columns'></span><span id='topic+rows'></span>

<h3>Description</h3>

<p>return a vector of row or column indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>columns(x, default = c())

rows(x, default = c())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="columns_+3A_x">x</code></td>
<td>
<p>an object that may or may not have any rows or columns</p>
</td></tr>
<tr><td><code id="columns_+3A_default">default</code></td>
<td>
<p>what to return if there are no rows or columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>x</code> has rows or columns, a vector of indices, else <code>default</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dim(iris)
columns(iris)
rows(iris)
columns(NULL)
columns("this doesn't have columns")
</code></pre>

<hr>
<h2 id='compare'>Campare two numeric vectors</h2><span id='topic+compare'></span>

<h3>Description</h3>

<p>This wrapper around <code>sign()</code> provides a more intuitive labeling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare(x, y, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_+3A_x">x</code>, <code id="compare_+3A_y">y</code></td>
<td>
<p>numeric verctors to be compared item by item</p>
</td></tr>
<tr><td><code id="compare_+3A_verbose">verbose</code></td>
<td>
<p>a logical indicating whether verbose labeling is desired</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a factor with three levels (<code>&lt;</code>, <code>=</code>, and <code>&gt;</code> if <code>verbose</code> is <code>FALSE</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tally( ~ compare(mcs, pcs), data = mosaicData::HELPrct)
tally( ~ compare(mcs, pcs, verbose = TRUE), data = mosaicData::HELPrct)
tally( ~ compare(sexrisk, drugrisk), data = mosaicData::HELPrct)
</code></pre>

<hr>
<h2 id='counts'>Compute all proportions or counts</h2><span id='topic+counts'></span><span id='topic+counts.factor'></span><span id='topic+counts.default'></span><span id='topic+counts.formula'></span><span id='topic+props'></span><span id='topic+percs'></span>

<h3>Description</h3>

<p>Compute vector of counts, proportions, or percents for each unique value (and <code>NA</code> if there
is missing data) in a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>counts(x, ...)

## S3 method for class 'factor'
counts(x, ..., format = c("count", "proportion", "percent"))

## Default S3 method:
counts(x, ..., format = c("count", "proportion", "percent"))

## S3 method for class 'formula'
counts(x, data, ..., format = "count")

props(x, ..., format = "proportion")

percs(x, ..., format = "percent")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="counts_+3A_x">x</code></td>
<td>
<p>A vector or a formula.</p>
</td></tr>
<tr><td><code id="counts_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods.</p>
</td></tr>
<tr><td><code id="counts_+3A_format">format</code></td>
<td>
<p>One of <code>"count"</code>, <code>"proportion"</code>, or <code>"percent"</code>.  May be abbreviated.</p>
</td></tr>
<tr><td><code id="counts_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="mosaic.html#topic+reexports">mosaic::prop()</a></code>
</p>
<p><code><a href="mosaic.html#topic+reexports">mosaic::count()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(mosaicData)) {
  props(HELPrct$substance)
  # numeric version tallies missing values as well
  props(HELPmiss$link)
  # Formula version omits missing data with warning (by default)
  props( ~ link, data = HELPmiss)                       # omit NAs with warning
  props( ~ link, data = HELPmiss, na.action = na.pass)  # no warning; tally NAs
  props( ~ link, data = HELPmiss, na.action = na.omit)  # no warning, omit NAs
  props( ~ substance | sex, data = HELPrct)
  props( ~ substance | sex, data = HELPrct, format = "percent")
  percs( ~ substance | sex, data = HELPrct)
  counts( ~ substance | sex, data = HELPrct)
  df_stats( ~ substance | sex, data = HELPrct, props, counts)
  df_stats( ~ substance | sex, data = HELPmiss, props, na.action = na.pass)
}

</code></pre>

<hr>
<h2 id='coverage'>Interval statistics</h2><span id='topic+coverage'></span><span id='topic+interval_statistics'></span><span id='topic+ci.mean'></span><span id='topic+ci.median'></span><span id='topic+ci.sd'></span><span id='topic+ci.prop'></span>

<h3>Description</h3>

<p>Calculate coverage intervals and confidence intervals for the sample mean, median, sd, proportion, ...
Typically, these will be used within <code>df_stats()</code>. For the mean, median, and sd, the variable x must be
quantitative. For proportions, the x can be anything; use the <code>success</code> argument to specify what
value you want the proportion of. Default for <code>success</code> is <code>TRUE</code> for x logical, or the first level returned
by <code>unique</code> for categorical or numerical variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coverage(x, level = 0.95, na.rm = TRUE)

ci.mean(x, level = 0.95, na.rm = TRUE)

ci.median(x, level = 0.9, na.rm = TRUE)

ci.sd(x, level = 0.95, na.rm = TRUE)

ci.prop(
  x,
  success = NULL,
  level = 0.95,
  method = c("Clopper-Pearson", "binom.test", "Score", "Wilson", "prop.test", "Wald",
    "Agresti-Coull", "Plus4")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coverage_+3A_x">x</code></td>
<td>
<p>a variable.</p>
</td></tr>
<tr><td><code id="coverage_+3A_level">level</code></td>
<td>
<p>number in 0 to 1 specifying the confidence level for the interval. (Default: 0.95)</p>
</td></tr>
<tr><td><code id="coverage_+3A_na.rm">na.rm</code></td>
<td>
<p>if <code>TRUE</code> disregard missing data</p>
</td></tr>
<tr><td><code id="coverage_+3A_success">success</code></td>
<td>
<p>for proportions, this specifies the categorical level for which the calculation of proportion will
be done. Defaults: <code>TRUE</code> for logicals for which the proportion is to
be calculated.</p>
</td></tr>
<tr><td><code id="coverage_+3A_method">method</code></td>
<td>
<p>for <code>ci.prop()</code>, the method to use in calculating the confidence
interval. See <code>mosaic::binom.test()</code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods: <code>ci.mean()</code> uses the standard t confidence interval.
<code>ci.median()</code> uses the normal approximation method.
<code>ci.sd()</code> uses the chi-squared method.
<code>ci.prop()</code> uses the binomial method. In the usual situation where the <code>mosaic</code> package is available,
<code>ci.prop()</code> uses <code>mosaic::binom.test()</code> internally, which provides several
methods for the calculation. See the documentation
for <code>binom.test()</code> for details about the available methods. Clopper-Pearson is
the default method. When used with <code>df_stats()</code>, the confidence interval
is calculated for each group separately. For &quot;pooled&quot; confidence intervals, see methods
such as <code>lm()</code> or <code>glm()</code>.
</p>


<h3>Value</h3>

<p>a named numerical vector with components <code>lower</code> and <code>upper</code>, and,
in the case of <code>ci.prop()</code>, <code>center</code>. When used the <code>df_stats()</code>, these components
are formed into a data frame.
</p>


<h3>Note</h3>

<p>When using these functions with <code>df_stats()</code>, omit the <code>x</code> argument, which
will be supplied automatically by <code>df_stats()</code>. See examples.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+df_stats">df_stats()</a></code>, <code><a href="mosaic.html#topic+binom.test">mosaic::binom.test()</a></code>, <code><a href="mosaic.html#topic+ttest">mosaic::t.test()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The central 95% interval
df_stats(hp ~ cyl, data = mtcars, c95 = coverage(0.95))
# The confidence interval on the mean
df_stats(hp ~ cyl, data = mtcars, mean, ci.mean)
# What fraction of cars have 6 cylinders?
df_stats(mtcars, ~ cyl, six_cyl_prop = ci.prop(success = 6, level = 0.90))
# Use without `df_stats()` (rare)
ci.mean(mtcars$hp)

</code></pre>

<hr>
<h2 id='df_stats'>Calculate statistics for &quot;response&quot; variables</h2><span id='topic+df_stats'></span>

<h3>Description</h3>

<p>Creates a data frame of statistics calculated on one or more response variables,
possibly for each group formed by combinations of additional variables.
The resulting data frame has one column
for each of the statistics requested as well as columns for any grouping variables and a
column identifying the response variable for which the statistics was calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_stats(
  formula,
  data,
  ...,
  drop = TRUE,
  fargs = list(),
  sep = "_",
  format = c("wide", "long"),
  groups = NULL,
  long_names = FALSE,
  nice_names = FALSE,
  na.action = "na.warn"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="df_stats_+3A_formula">formula</code></td>
<td>
<p>A formula indicating which variables are to be used.
Semantics are approximately as in <code><a href="stats.html#topic+lm">lm()</a></code> since <code><a href="stats.html#topic+model.frame">stats::model.frame()</a></code>
is used to turn the formula into a data frame.  But first conditions and <code>groups</code>
are re-expressed into a form that <code><a href="stats.html#topic+model.frame">stats::model.frame()</a></code> can interpret.
Multiple response variables can be separated by <code>+</code> on the left hand side of
the formula.  A one-sided formula <code>~ rhs | cond</code> is treated as <code>rhs ~ 1 | cond</code>.
See details.</p>
</td></tr>
<tr><td><code id="df_stats_+3A_data">data</code></td>
<td>
<p>A data frame or list containing the variables.</p>
</td></tr>
<tr><td><code id="df_stats_+3A_...">...</code></td>
<td>
<p>Functions used to compute the statistics.  If this is empty,
a default set of summary statistics is used.  Functions used must accept
a vector of values and return either a (possibly named) single value,
a (possibly named) vector of values, or a data frame with one row.
Functions can be specified with character strings, names, or expressions
that look like function calls with the first argument missing.  The latter
option provides a convenient way to specify additional arguments.  See the
examples.
Note: If these arguments are named, those names will be used in the data
frame returned (see details).  Such names may not be among the names of the named
arguments of <code>df_stats</code>().
</p>
<p>If a function is specified using <code>::</code>, be sure to include the trailing
parens, even if there are no additional arguments required.</p>
</td></tr>
<tr><td><code id="df_stats_+3A_drop">drop</code></td>
<td>
<p>A logical indicating whether combinations of the grouping
variables that do not occur in <code>data</code> should be dropped from the
result.</p>
</td></tr>
<tr><td><code id="df_stats_+3A_fargs">fargs</code></td>
<td>
<p>Arguments passed to the functions in <code>...</code>.</p>
</td></tr>
<tr><td><code id="df_stats_+3A_sep">sep</code></td>
<td>
<p>A character string to separate components of names.  Set to <code>""</code> if
you don't want separation.</p>
</td></tr>
<tr><td><code id="df_stats_+3A_format">format</code></td>
<td>
<p>One of <code>"long"</code> or <code>"wide"</code> indicating the desired shape of the
returned data frame.</p>
</td></tr>
<tr><td><code id="df_stats_+3A_groups">groups</code></td>
<td>
<p>An expression or formula to be evaluated in <code>data</code> and defining (additional) groups.
This isn't necessary, since these can be placed into the formula, but it is provided
for similarity to other functions from the <span class="pkg">mosaic</span> package.</p>
</td></tr>
<tr><td><code id="df_stats_+3A_long_names">long_names</code></td>
<td>
<p>A logical indicating whether the default names should include the name
of the variable being summarized as well as the summarizing function name in the default
case when names are not derived from the names of the returned object or
an argument name.</p>
</td></tr>
<tr><td><code id="df_stats_+3A_nice_names">nice_names</code></td>
<td>
<p>A logical indicating whether <code><a href="base.html#topic+make.names">make.names()</a></code> should be
used to force names of the returned data frame to by syntactically valid.</p>
</td></tr>
<tr><td><code id="df_stats_+3A_na.action">na.action</code></td>
<td>
<p>A function (or character string naming a function) that determines how NAs are treated.
Options include <code>"na.warn"</code> which removes missing data and emits a warning,
<code>"na.pass"</code> which includes all of the data,
<code>"na.omit"</code> or <code>"na.exclude"</code> which silently discard missing data,
and <code>"na.fail"</code> which fails if there is missing data.
See <code>link[stats]{na.pass}()</code> and <code><a href="#topic+na.warn">na.warn()</a></code> for details.
The default is <code>"na.warn"</code> unless no function are specified in <code>...</code>, in which case
<code>"na.pass"</code> is used since the default function reports the number of missing values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use a one-sided formula to compute summary statistics for the right hand side
expression over the entire data.
Use a two-sided formula to compute summary statistics for the left hand (response)
expression(s) for each combination of levels of the expressions occurring on the
right hand side.
This is most useful when the left hand side is quantitative and each expression
on the right hand side has relatively few unique values.  A function like
<code><a href="mosaic.html#topic+ntiles">mosaic::ntiles()</a></code> is often useful to create a few groups of roughly equal size
determined by ranges of a quantitative variable.  See the examples.
</p>
<p>Note that unlike <code>dplyr::<a href="dplyr.html#topic+summarise">summarise</a>()</code>, <code>df_stats()</code> ignores
any grouping defined in <code>data</code> if <code>data</code> is a grouped <code>tibble</code>.
</p>


<h3>Value</h3>

<p>A data frame. Names of columns in the resulting data frame consist of three
parts separated by <code>sep</code>.
The first part is the argument name, if it exists, else the function.
The second part is the name of the variable being summarised if <code>long_names == TRUE</code> and
the first part is the function name, else &quot;&quot;
The third part is the names of the object returned by the summarizing function, if they
exist, else a sequence of consecutive integers or &quot;&quot; if there is only one component
returned by the summarizing function.
See the examples.
</p>


<h3>Cautions Regarding Formulas</h3>

<p>The use of <code>|</code> to define groups is tricky because (a) <code><a href="stats.html#topic+model.frame">stats::model.frame()</a></code>
doesn't handle this sort of thing and (b) <code>|</code> is also used for logical or.  The
current algorithm for handling this will turn the first  occurrence of <code>|</code> into an attempt
to condition, so logical or cannot be used before conditioning in the formula.
If you have need of logical or, we suggest creating a new variable that contains the
results of evaluating the expression.
</p>
<p>Similarly, addition (<code>+</code>) is used to separate grouping variables, not for
arithmetic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df_stats( ~ hp, data = mtcars)
# There are several ways to specify functions
df_stats( ~ hp, data = mtcars, mean, trimmed_mean = mean(trim = 0.1), "median",
  range, Q = quantile(c(0.25, 0.75)))
# When using ::, be sure to include parens, even if there are no additional arguments.
df_stats( ~ hp, data = mtcars, mean = base::mean(), trimmed_mean = base::mean(trim = 0.1))

# force names to by syntactically valid
df_stats( ~ hp, data = mtcars, Q = quantile(c(0.25, 0.75)), nice_names = TRUE)
# longer names
df_stats( ~ hp, data = mtcars, mean, trimmed_mean = mean(trim = 0.1), "median", range,
  long_names = TRUE)
# wide vs long format
df_stats( hp ~ cyl, data = mtcars, mean, median, range)
df_stats( hp + wt + mpg ~ cyl, data = mtcars, mean, median, range)
df_stats( hp ~ cyl, data = mtcars, mean, median, range, format = "long")
# More than one grouping variable -- 4 ways.
df_stats( hp ~ cyl + gear, data = mtcars, mean, median, range)
df_stats( hp ~ cyl | gear, data = mtcars, mean, median, range)
df_stats( hp ~ cyl, groups = ~gear, data = mtcars, mean, median, range)
df_stats( hp ~ cyl, groups = gear, data = mtcars, mean, median, range)

# because the result is a data frame, df_stats() is also useful for creating plots
if(require(ggformula)) {
  gf_violin(hp ~ cyl, data = mtcars, group = ~ cyl) |&gt;
  gf_point(mean ~ cyl, data = df_stats(hp ~ cyl, data = mtcars, mean),
    color = ~ "mean") |&gt;
  gf_point(median ~ cyl, data = df_stats(hp ~ cyl, data = mtcars, median),
    color = ~"median") |&gt;
  gf_labs(color = "")
}

# magrittr style piping is also supported
if (require(ggformula)) {
  mtcars |&gt;
    df_stats(hp ~ cyl, mean, median, range)
  mtcars |&gt;
    df_stats(hp ~ cyl + gear, mean, median, range) |&gt;
    gf_point(mean ~ cyl, color = ~ factor(gear)) |&gt;
    gf_line(mean ~ cyl, color = ~ factor(gear))
}

# can be used with a categorical response, too
if (require(mosaic)) {
  df_stats(sex ~ substance, data = HELPrct, table, prop_female = prop)
}
if (require(mosaic)) {
  df_stats(sex ~ substance, data = HELPrct, table, props)
}
</code></pre>

<hr>
<h2 id='dfapply'>apply-type function for data frames</h2><span id='topic+dfapply'></span>

<h3>Description</h3>

<p>An <code>apply</code>-type function for data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfapply(data, FUN, select = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dfapply_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="dfapply_+3A_fun">FUN</code></td>
<td>
<p>a function to apply to (some) variables in the data frame</p>
</td></tr>
<tr><td><code id="dfapply_+3A_select">select</code></td>
<td>
<p>a logical, character (naming variables), or numeric vector or a
function used to select variables to which <code>FUN</code> is applied.  If a function,
it should take a vector as input and return a single logical. See examples.</p>
</td></tr>
<tr><td><code id="dfapply_+3A_...">...</code></td>
<td>
<p>arguments passed along to <code>FUN</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+apply">apply()</a></code>,
<code><a href="base.html#topic+sapply">sapply()</a></code>,
<code><a href="base.html#topic+tapply">tapply()</a></code>,
<code><a href="base.html#topic+lapply">lapply()</a></code>,
<code><a href="#topic+inspect">inspect()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dfapply(iris, mean, select = is.numeric)
dfapply(iris, mean, select = c(1,2))
dfapply(iris, mean, select = c("Sepal.Length", "Petal.Length"))
if (require(mosaicData)) {
  dfapply(HELPrct, table, select = is.factor)
  do.call(rbind, dfapply(HELPrct, mean, select = is.numeric))
}
</code></pre>

<hr>
<h2 id='ediff'>Lagged Differences with equal length</h2><span id='topic+ediff'></span>

<h3>Description</h3>

<p>Often when creating lagged differences, it is awkward that the differences
vector is shorter than the original.  <code>ediff</code> pads with <code>pad.value</code> to
make its output the same length as the input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ediff(
  x,
  lag = 1,
  differences = 1,
  pad = c("head", "tail", "symmetric"),
  pad.value = NA,
  frontPad,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ediff_+3A_x">x</code></td>
<td>
<p>a numeric vector or a matrix containing the values to be differenced</p>
</td></tr>
<tr><td><code id="ediff_+3A_lag">lag</code></td>
<td>
<p>an integer indicating which lag to use</p>
</td></tr>
<tr><td><code id="ediff_+3A_differences">differences</code></td>
<td>
<p>an integer indicating the order of the difference</p>
</td></tr>
<tr><td><code id="ediff_+3A_pad">pad</code></td>
<td>
<p>one of <code>"head"</code>, <code>"tail"</code>, or <code>"symmetric"</code>.
indicating where the <code>pad.value</code> padding should be added to the result.</p>
</td></tr>
<tr><td><code id="ediff_+3A_pad.value">pad.value</code></td>
<td>
<p>the value to be used for padding.</p>
</td></tr>
<tr><td><code id="ediff_+3A_frontpad">frontPad</code></td>
<td>
<p>logical indicating whether padding is on the front (head) or
back (tail) end. This exists for backward compatibility. New code should use
<code>pad</code> instead.</p>
</td></tr>
<tr><td><code id="ediff_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+diff">diff()</a></code> since
<code>ediff</code> is a thin wrapper around <code><a href="base.html#topic+diff">diff()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ediff(1:10)
ediff(1:10, pad.value = 0)
ediff(1:10, 2)
ediff(1:10, 2, 2)
x &lt;- cumsum(cumsum(1:10))
ediff(x, lag = 2)
ediff(x, differences = 2)
ediff(x, differences = 2, pad = "symmetric")
ediff(.leap.seconds)
</code></pre>

<hr>
<h2 id='evalFormula'>Evaluate a formula</h2><span id='topic+evalFormula'></span>

<h3>Description</h3>

<p>Evaluate a formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalFormula(formula, data = parent.frame(), subset, ops = c("+", "&amp;"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evalFormula_+3A_formula">formula</code></td>
<td>
<p>a formula (<code> y ~ x | z</code>) to evaluate</p>
</td></tr>
<tr><td><code id="evalFormula_+3A_data">data</code></td>
<td>
<p>a data frame or environment in which evaluation occurs</p>
</td></tr>
<tr><td><code id="evalFormula_+3A_subset">subset</code></td>
<td>
<p>an optional vector describing a subset of the observations to be used.
Currently only implemented when data is a data frame.</p>
</td></tr>
<tr><td><code id="evalFormula_+3A_ops">ops</code></td>
<td>
<p>a vector of operator symbols allowable to separate variables in rhs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing data frames corresponding to the left, right, and condition
slots of <code>formula</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(mosaicData)) {
data(CPS85)
cps &lt;- CPS85[1:6,]
cps
evalFormula(wage ~ sex &amp; married &amp; age | sector &amp; race, data=cps)
}
</code></pre>

<hr>
<h2 id='evalSubFormula'>Evaluate a part of a formula</h2><span id='topic+evalSubFormula'></span>

<h3>Description</h3>

<p>Evaluate a part of a formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalSubFormula(x, data = NULL, ops = c("+", "&amp;"), env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evalSubFormula_+3A_x">x</code></td>
<td>
<p>an object appearing as a subformula (typically a name or a call)</p>
</td></tr>
<tr><td><code id="evalSubFormula_+3A_data">data</code></td>
<td>
<p>a data frame or environment in which things are evaluated</p>
</td></tr>
<tr><td><code id="evalSubFormula_+3A_ops">ops</code></td>
<td>
<p>a vector of operators that are not evaluated as operators but
instead used to further split <code>x</code></p>
</td></tr>
<tr><td><code id="evalSubFormula_+3A_env">env</code></td>
<td>
<p>an environment in which to search for objects not in <code>data</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame containing the terms of the evaluated subformula
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(mosaicData)) {
data(CPS85)
cps &lt;- CPS85[1:6,]
cps
evalSubFormula( rhs( ~ married &amp; sector), data=cps )
}
</code></pre>

<hr>
<h2 id='fit_distr_fun'>Fit a distribution to data and return a function</h2><span id='topic+fit_distr_fun'></span>

<h3>Description</h3>

<p>Given the name of a family of 1-dimensional distributions, this function chooses a
particular member  of the family that fits the data and returns a function in the
selected p, d, q, or r format. When analytical solutions do not exist, <code>MASS::fitdistr()</code>
is used to estimate the parameters by numerical maximum likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_distr_fun(data, formula, dist, start = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_distr_fun_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="fit_distr_fun_+3A_formula">formula</code></td>
<td>
<p>A formula.  A distribution will be fit to the data defined by the
right side and evaluated in <code>data</code>.</p>
</td></tr>
<tr><td><code id="fit_distr_fun_+3A_dist">dist</code></td>
<td>
<p>A string naming the function desired.  Tyically this will be
&quot;d&quot;, &quot;p&quot;, &quot;q&quot;, or &quot;r&quot; followed by the (abbrevation for) a family of
distributions such as &quot;pnorm&quot;, &quot;rgamma&quot;. Fitting is done use
<code><a href="MASS.html#topic+fitdistr">MASS::fitdistr()</a></code>; see the help there for a list of distributions that
are available.</p>
</td></tr>
<tr><td><code id="fit_distr_fun_+3A_start">start</code></td>
<td>
<p>Starting values for the numerical maximum likelihood method
(passed to <code>MASS::fitdistr</code>).</p>
</td></tr>
<tr><td><code id="fit_distr_fun_+3A_...">...</code></td>
<td>
<p>Additional arguments to MASS::fitdistr()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function of one variable that acts like, say,
<code>pnorm()</code>, <code>dnorm()</code>, <code>qnorm()</code>, or <code>rnorm()</code>, but with the default
values of the parameters set to their maximum likelihood estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fit_distr_fun( ~ cesd, data = mosaicData::HELPrct, dist = "dnorm")
fit_distr_fun( ~ cesd, data = mosaicData::HELPrct, dist = "pnorm")
fit_distr_fun( ~ cesd, data = mosaicData::HELPrct, dist = "qpois")
</code></pre>

<hr>
<h2 id='formularise'>Convert lazy objects into formulas</h2><span id='topic+formularise'></span>

<h3>Description</h3>

<p>Convert lazy objects into a formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formularise(lazy_formula, envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="formularise_+3A_lazy_formula">lazy_formula</code></td>
<td>
<p>an object of class <code>lazy</code></p>
</td></tr>
<tr><td><code id="formularise_+3A_envir">envir</code></td>
<td>
<p>an environment that will be come the environment of the returned formula</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expression of the lazy object is evaluated in its environment.  If the
result is not a formula, then the formula is created with an empty left hand side
and the expression on the right hand side.
</p>


<h3>Value</h3>

<p>a formula
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
formularise(rlang::quo(foo))
formularise(rlang::quo(y ~ x))
bar &lt;- a ~ b
formularise(rlang::quo(bar))
</code></pre>

<hr>
<h2 id='infer_transformation'>Infer a Back-Transformation</h2><span id='topic+infer_transformation'></span>

<h3>Description</h3>

<p>For a handful of transformations on y, infer the reverse transformation.  If the
transformation is not recognized, return the identity function.  This is primarily
intended to be used for setting a default value in other functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infer_transformation(formula, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="infer_transformation_+3A_formula">formula</code></td>
<td>
<p>A formula as used by, for example, <code><a href="stats.html#topic+lm">lm()</a></code>.</p>
</td></tr>
<tr><td><code id="infer_transformation_+3A_warn">warn</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function.
</p>

<hr>
<h2 id='inspect'>Inspect objects</h2><span id='topic+inspect'></span><span id='topic+inspect.list'></span><span id='topic+inspect.character'></span><span id='topic+inspect.logical'></span><span id='topic+inspect.numeric'></span><span id='topic+inspect.factor'></span><span id='topic+inspect.Date'></span><span id='topic+inspect.POSIXt'></span><span id='topic+inspect.data.frame'></span><span id='topic+print.inspected_data_frame'></span>

<h3>Description</h3>

<p>Print a short summary of the contents of an object.  Most useful as a way to
get a quick overview of the variables in data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inspect(object, ...)

## S3 method for class 'list'
inspect(object, max.level = 2, ...)

## S3 method for class 'character'
inspect(object, ...)

## S3 method for class 'logical'
inspect(object, ...)

## S3 method for class 'numeric'
inspect(object, ...)

## S3 method for class 'factor'
inspect(object, ...)

## S3 method for class 'Date'
inspect(object, ...)

## S3 method for class 'POSIXt'
inspect(object, ...)

## S3 method for class 'data.frame'
inspect(object, select = TRUE, digits = getOption("digits", 3), ...)

## S3 method for class 'inspected_data_frame'
print(x, digits = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inspect_+3A_object">object</code></td>
<td>
<p>a data frame or a vector</p>
</td></tr>
<tr><td><code id="inspect_+3A_...">...</code></td>
<td>
<p>additional arguments passed along to specific methods</p>
</td></tr>
<tr><td><code id="inspect_+3A_max.level">max.level</code></td>
<td>
<p>an integer giving the depth to which lists should be expanded</p>
</td></tr>
<tr><td><code id="inspect_+3A_select">select</code></td>
<td>
<p>a logical, character (naming variables), or numeric vector or a
function used to select variables to which <code>FUN</code> is applied.  If a function,
it should take a vector as input and return a single logical. See examples here and
at <code>link{dfapply}</code>.</p>
</td></tr>
<tr><td><code id="inspect_+3A_digits">digits</code></td>
<td>
<p>and integer giving the number of digits to display</p>
</td></tr>
<tr><td><code id="inspect_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(mosaicData)) {
  inspect(Births78)
  inspect(Births78, is.numeric)
}
</code></pre>

<hr>
<h2 id='joinFrames'>Join data frames</h2><span id='topic+joinFrames'></span><span id='topic+joinTwoFrames'></span>

<h3>Description</h3>

<p>Join data frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joinFrames(...)

joinTwoFrames(left, right)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="joinFrames_+3A_...">...</code></td>
<td>
<p>data frames to be joined</p>
</td></tr>
<tr><td><code id="joinFrames_+3A_left">left</code>, <code id="joinFrames_+3A_right">right</code></td>
<td>
<p>data frames</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame containing columns from each of data frames being joined.
</p>

<hr>
<h2 id='logical2factor'>Convert logical vector into factor</h2><span id='topic+logical2factor'></span><span id='topic+logical2factor.default'></span><span id='topic+logical2factor.data.frame'></span>

<h3>Description</h3>

<p>Turn logicals into factors with levels ordered with <code>TRUE</code> before <code>FALSE</code>.
Other inputs are returned unaltered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logical2factor(x, ...)

## Default S3 method:
logical2factor(x, ...)

## S3 method for class 'data.frame'
logical2factor(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logical2factor_+3A_x">x</code></td>
<td>
<p>a vector or data frame</p>
</td></tr>
<tr><td><code id="logical2factor_+3A_...">...</code></td>
<td>
<p>additional arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>x</code> is a vector either <code>x</code> or the result
of converting <code>x</code> into a factor with levels <code>TRUE</code>
and <code>FALSE</code> (in that order);  if <code>x</code> is a data frame,
a data frame with all logicals converted to factors in this manner.
</p>

<hr>
<h2 id='logit'>Logit and inverse logit functions</h2><span id='topic+logit'></span><span id='topic+ilogit'></span>

<h3>Description</h3>

<p>Logit and inverse logit functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(x)

ilogit(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logit_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>logit</code> the value is
</p>
<p style="text-align: center;"><code class="reqn">log(x/(1 - x))</code>
</p>

<p>For <code>ilogit</code> the value is
</p>
<p style="text-align: center;"><code class="reqn">exp(x)/(1 + exp(x))</code>
</p>



<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- seq(.1, .9, by=.10)
l &lt;- logit(p); l
ilogit(l)
ilogit(l) == p
</code></pre>

<hr>
<h2 id='make_df'>Convert to a data frame</h2><span id='topic+make_df'></span><span id='topic+make_df.list'></span><span id='topic+make_df.matrix'></span><span id='topic+make_df.numeric'></span><span id='topic+make_df.default'></span>

<h3>Description</h3>

<p>A generic and several methods for converting objects into data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_df(object, ...)

## S3 method for class 'list'
make_df(object, ...)

## S3 method for class 'matrix'
make_df(object, ...)

## S3 method for class 'numeric'
make_df(object, ...)

## Default S3 method:
make_df(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_df_+3A_object">object</code></td>
<td>
<p>An object to be converted into a data frame.</p>
</td></tr>
<tr><td><code id="make_df_+3A_...">...</code></td>
<td>
<p>Additional arguments used by methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These methods are primarily for internal use inside <code><a href="#topic+df_stats">df_stats()</a></code>,
but are exported in case they have other uses. The conversion works as follows.
Data frames are left as is.
Matrices are converted column-by-column and the columns
assembled with <code><a href="base.html#topic+as.data.frame">as.data.frame()</a></code>; this allows matrices that are lists
to be converted into data frames where columns can have differing types.
The names are then set to the column
names of <code>object</code>, even if that results in <code>NULL</code>.
A numeric vector is converted into a data frame with 1 column.
If <code>object</code> is a list, each element is converted using <code><a href="#topic+vector2df">vector2df()</a></code>
and the resulting columns are joined with <code><a href="dplyr.html#topic+bind_rows">bind_rows()</a></code>.
</p>

<hr>
<h2 id='makeFun'>Create a function from a formula</h2><span id='topic+makeFun'></span><span id='topic+makeFun.function'></span><span id='topic+makeFun.formula'></span><span id='topic+makeFun.lm'></span><span id='topic+makeFun.glm'></span><span id='topic+makeFun.nls'></span>

<h3>Description</h3>

<p>Provides an easy mechanism for creating simple &quot;mathematical&quot;
functions via a formula interface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeFun(object, ...)

## S3 method for class ''function''
makeFun(
  object,
  ...,
  strict.declaration = TRUE,
  use.environment = TRUE,
  suppress.warnings = FALSE
)

## S3 method for class 'formula'
makeFun(
  object,
  ...,
  strict.declaration = TRUE,
  use.environment = TRUE,
  suppress.warnings = TRUE
)

## S3 method for class 'lm'
makeFun(object, ..., transformation = NULL)

## S3 method for class 'glm'
makeFun(object, ..., type = c("response", "link"), transformation = NULL)

## S3 method for class 'nls'
makeFun(object, ..., transformation = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeFun_+3A_object">object</code></td>
<td>
<p>an object from which to create a function.  This should generally
be specified without naming.</p>
</td></tr>
<tr><td><code id="makeFun_+3A_...">...</code></td>
<td>
<p>additional arguments in the form <code>var = val</code> that
set default values for the inputs to the function.</p>
</td></tr>
<tr><td><code id="makeFun_+3A_strict.declaration">strict.declaration</code></td>
<td>
<p>if <code>TRUE</code> (the default), an error is thrown if
default values are given for variables not appearing in the <code>object</code> formula.</p>
</td></tr>
<tr><td><code id="makeFun_+3A_use.environment">use.environment</code></td>
<td>
<p>if <code>TRUE</code>, then variables implicitly defined in the
<code>object</code> formula can take default values from the environment at the time
<code>makeFun</code> is called.  A warning message alerts the user to this situation,
unless <code>suppress.warnings</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="makeFun_+3A_suppress.warnings">suppress.warnings</code></td>
<td>
<p>A logical indicating whether warnings should be suppressed.</p>
</td></tr>
<tr><td><code id="makeFun_+3A_transformation">transformation</code></td>
<td>
<p>a function used to transform the response.
This can be useful to invert a transformation used on the response
when creating the model.  If <code>NULL</code>, an attempt will be made to infer
the transformation from the model formula. A few simple transformations
(<code>log</code>, <code>log2</code>, <code>sqrt</code>) are recognized.  For other transformations,
<code>transformation</code> should be provided explicitly.</p>
</td></tr>
<tr><td><code id="makeFun_+3A_type">type</code></td>
<td>
<p>one of <code>'response'</code> (default) or <code>'link'</code> specifying scale to be used
for value of function returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The definition of the function is given by the left side of a two-sided formula
or the right side of a one-sided formula.
The right
side lists at least one of the inputs to the function.
The inputs to the function are all variables appearing on either the left
or right sides of the formula.  Those appearing in the right side will
occur in the order specified.  Those not appearing in the right side will
appear in an unspecified order.
</p>
<p>When creating a function from a model created with <code>lm</code>, <code>glm</code>, or <code>nls</code>,
the function produced is a wrapper around the corresponding version of <code>predict</code>.
This means that having variables in the model with names that match arguments of
<code>predict</code> will lead to potentially ambiguous situations and should be avoided.
</p>


<h3>Value</h3>

<p>a function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- makeFun( sin(x^2 * b) ~ x &amp; y &amp; a); f
g &lt;- makeFun( sin(x^2 * b) ~ x &amp; y &amp; a, a = 2 ); g
h &lt;- makeFun( a * sin(x^2 * b) ~ b &amp; y, a = 2, y = 3); h
ff &lt;- makeFun(~ a*x^b + y ); ff # one sided formula
gg &lt;- makeFun(cos(a*x^b + y) ~ . ); gg # dummy right-hand side
if (require(mosaicData)) {
  model &lt;- lm( log(length) ~ log(width), data = KidsFeet)
  f &lt;- makeFun(model, transformation = exp)
  f(8.4)
  head(KidsFeet, 1)
}

if (require(mosaicData)) {
  model &lt;- lm(wage ~ poly(exper, degree = 2), data = CPS85)
  fit &lt;- makeFun(model)
  if (require(ggformula)) {
    gf_point(wage ~ exper, data = CPS85) |&gt;
    gf_fun(fit(exper) ~ exper, color = "red")
  }
}
if (require(mosaicData)) {
model &lt;- glm(wage ~ poly(exper, degree = 2), data = CPS85, family = gaussian)
fit &lt;- makeFun(model)
  if (require(ggformula)) {
    gf_jitter(wage ~ exper, data = CPS85) |&gt;
    gf_fun(fit(exper) ~ exper, color = "red")
    gf_jitter(wage ~ exper, data = CPS85) |&gt;
    gf_function(fun = fit, color = "blue")
  }
}
if (require(mosaicData)) {
model &lt;- nls( wage ~ A + B * exper + C * exper^2, data = CPS85, start = list(A = 1, B = 1, C = 1) )
fit &lt;- makeFun(model)
  if (require(ggformula)) {
    gf_point(wage ~ exper, data = CPS85) |&gt;
    gf_fun(fit(exper) ~ exper, color = "red")
  }
}

</code></pre>

<hr>
<h2 id='modelVars'>extract predictor variables from a model</h2><span id='topic+modelVars'></span>

<h3>Description</h3>

<p>extract predictor variables from a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelVars(model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelVars_+3A_model">model</code></td>
<td>
<p>a model, typically of class <code>lm</code> or <code>glm</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of variable names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(mosaicData)) {
  model &lt;- lm( wage ~ poly(exper, degree = 2), data = CPS85 )
  modelVars(model)
}
</code></pre>

<hr>
<h2 id='mosaic_formula'>Convert formulas into standard shapes</h2><span id='topic+mosaic_formula'></span><span id='topic+mosaic_formula_q'></span>

<h3>Description</h3>

<p>These functions convert formulas into standard shapes, including by
incorporating a groups argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mosaic_formula(
  formula,
  groups = NULL,
  envir = parent.frame(),
  max.slots = 3,
  groups.first = FALSE
)

mosaic_formula_q(
  formula,
  groups = NULL,
  max.slots = 3,
  groups.first = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mosaic_formula_+3A_formula">formula</code></td>
<td>
<p>a formula</p>
</td></tr>
<tr><td><code id="mosaic_formula_+3A_groups">groups</code></td>
<td>
<p>a name used for grouping</p>
</td></tr>
<tr><td><code id="mosaic_formula_+3A_envir">envir</code></td>
<td>
<p>the environment in which the resulting formula may be evaluated.
May also be <code>NULL</code>, a list, a data frame, or a pairlist.</p>
</td></tr>
<tr><td><code id="mosaic_formula_+3A_max.slots">max.slots</code></td>
<td>
<p>an integer specifying the maximum number of slots for the resulting formula.
An error results from trying to create a formula that is too complex.</p>
</td></tr>
<tr><td><code id="mosaic_formula_+3A_groups.first">groups.first</code></td>
<td>
<p>a logical indicating whether groups should be inserted
ahead of the condition (else after).</p>
</td></tr>
<tr><td><code id="mosaic_formula_+3A_...">...</code></td>
<td>
<p>additional arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mosaic_formula_q</code> uses nonstandard evaluation of <code>groups</code> that may be
necessary for use within other functions.  <code>mosaic_formula</code> is a wrapper
around <code>mosaic_formula_q</code> and quotes <code>groups</code> before passing it along.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mosaic_formula( ~ x | z )
mosaic_formula( ~ x, groups=g )
mosaic_formula( y ~ x, groups=g )
# this is probably not what you want for interactive use.
mosaic_formula_q( y ~ x, groups=g )
# but it is for programming
foo &lt;- function(x, groups=NULL) {
    mosaic_formula_q(x, groups=groups, envir=parent.frame())
}
foo( y ~ x , groups = g)
</code></pre>

<hr>
<h2 id='mosaic_tally'>Internal tally methods</h2><span id='topic+mosaic_tally'></span><span id='topic+mosaic_count'></span>

<h3>Description</h3>

<p>These are used to implement <code>tally()</code> in a way that allows <code>dplyr</code> and <code>mosaicCore</code> to co-exist.
End users should call the generics <code>tally()</code> and <code>count()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mosaic_tally(x, ...)

mosaic_count(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mosaic_tally_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="mosaic_tally_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="base.html#topic+table">table()</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='n_missing'>Counting missing/non-missing elements</h2><span id='topic+n_missing'></span><span id='topic+n_not_missing'></span><span id='topic+n_total'></span>

<h3>Description</h3>

<p>Counting missing/non-missing elements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_missing(..., type = c("any", "all"))

n_not_missing(..., type = c("any", "all"))

n_total(..., type = c("any", "all"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n_missing_+3A_...">...</code></td>
<td>
<p>vectors of equal length to be checked in parallel for missing values.</p>
</td></tr>
<tr><td><code id="n_missing_+3A_type">type</code></td>
<td>
<p>one of <code>"any"</code> (default) or <code>"all"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of counts of missing or non-missing values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(NHANES) &amp;&amp; require(mosaic) &amp;&amp; require(dplyr)) {
  mosaic::tally( ~ is.na(Height) + is.na(Weight), data = NHANES, margins = TRUE)
  NHANES |&gt;
    summarise(
      mean.wt = mean(Weight, na.rm = TRUE),
      missing.Wt = n_missing(Weight),
      missing.WtAndHt = n_missing(Weight, Height, type = "all"),
      missing.WtOrHt = n_missing(Weight, Height, type = "any")
      )
    }
</code></pre>

<hr>
<h2 id='na.warn'>Exclude Missing Data with Warning</h2><span id='topic+na.warn'></span>

<h3>Description</h3>

<p>Similar to <code><a href="stats.html#topic+na.fail">stats::na.exclude()</a></code> this function excludes missing data.
When missing data are excluded, a warning message indicating the number of excluded
rows is emited as a caution for the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na.warn(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="na.warn_+3A_object">object</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object, typically a data frame</p>
</td></tr>
<tr><td><code id="na.warn_+3A_...">...</code></td>
<td>
<p>further arguments special methods could require.</p>
</td></tr>
</table>

<hr>
<h2 id='named'>List extraction</h2><span id='topic+named'></span><span id='topic+unnamed'></span><span id='topic+named_among'></span>

<h3>Description</h3>

<p>These functions create subsets of lists based on their names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>named(l)

unnamed(l)

named_among(l, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="named_+3A_l">l</code></td>
<td>
<p>A list.</p>
</td></tr>
<tr><td><code id="named_+3A_n">n</code></td>
<td>
<p>A vector of character strings (potential names).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sublist of <code>l</code> determined by <code>names(l)</code>.
</p>

<hr>
<h2 id='nice_names'>Nice names</h2><span id='topic+nice_names'></span>

<h3>Description</h3>

<p>Convert a character vector into a similar character vector that would
work better as names in a data frame by avoiding certain awkward characters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nice_names(x, unique = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nice_names_+3A_x">x</code></td>
<td>
<p>a character vector</p>
</td></tr>
<tr><td><code id="nice_names_+3A_unique">unique</code></td>
<td>
<p>a logical indicating whether returned values should be uniquified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nice_names( c("bad name", "name (crazy)", "a:b", "two-way") )
</code></pre>

<hr>
<h2 id='parse.formula'>Parse Formulas</h2><span id='topic+parse.formula'></span><span id='topic+rhs'></span><span id='topic+lhs'></span><span id='topic+condition'></span><span id='topic+operator'></span><span id='topic+rhs.formula'></span><span id='topic+lhs.formula'></span><span id='topic+condition.formula'></span><span id='topic+operator.formula'></span><span id='topic+rhs.parsedFormula'></span><span id='topic+lhs.parsedFormula'></span><span id='topic+operator.parsedFormula'></span><span id='topic+condition.parsedFormula'></span>

<h3>Description</h3>

<p>Utilities for extracting portions of formulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse.formula(formula, ...)

rhs(x, ...)

lhs(x, ...)

condition(x, ...)

operator(x, ...)

## S3 method for class 'formula'
rhs(x, ...)

## S3 method for class 'formula'
lhs(x, ...)

## S3 method for class 'formula'
condition(x, ...)

## S3 method for class 'formula'
operator(x, ...)

## S3 method for class 'parsedFormula'
rhs(x, ...)

## S3 method for class 'parsedFormula'
lhs(x, ...)

## S3 method for class 'parsedFormula'
operator(x, ...)

## S3 method for class 'parsedFormula'
condition(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse.formula_+3A_formula">formula</code></td>
<td>
<p>a formula</p>
</td></tr>
<tr><td><code id="parse.formula_+3A_...">...</code></td>
<td>
<p>additional arguments, current ignored</p>
</td></tr>
<tr><td><code id="parse.formula_+3A_x">x</code></td>
<td>
<p>an object (currently a <code>formula</code> or <code>parsedFormula</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>currently this is primarily concerned with extracting the operator, left hand side, right hand
side (minus any condition) and the condition. Improvements/extensions may come in the future.
</p>


<h3>Value</h3>

<p>an object of class <code>parsedFormula</code> from which information is easy to extract
</p>

<hr>
<h2 id='print.msummary.lm'>Modified summaries</h2><span id='topic+print.msummary.lm'></span><span id='topic+print.msummary.glm'></span><span id='topic+msummary'></span><span id='topic+msummary.default'></span><span id='topic+msummary.lm'></span><span id='topic+msummary.glm'></span>

<h3>Description</h3>

<p><code>msummary</code> provides modified summary objects that typically produce
output that is either identical to or somewhat terser than their
<code><a href="base.html#topic+summary">summary()</a></code> analogs.  The contents of the object itself are unchanged
(except for an augmented class) so that other downstream functions should work as
before.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msummary.lm'
print(
  x,
  digits = max(3L, getOption("digits") - 3L),
  symbolic.cor = x$symbolic.cor,
  signif.stars = getOption("show.signif.stars"),
  ...
)

## S3 method for class 'msummary.glm'
print(
  x,
  digits = max(3L, getOption("digits") - 3L),
  symbolic.cor = x$symbolic.cor,
  signif.stars = getOption("show.signif.stars"),
  ...
)

msummary(object, ...)

## Default S3 method:
msummary(object, ...)

## S3 method for class 'lm'
msummary(object, ...)

## S3 method for class 'glm'
msummary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.msummary.lm_+3A_x">x</code></td>
<td>
<p>an object to summarize</p>
</td></tr>
<tr><td><code id="print.msummary.lm_+3A_digits">digits</code></td>
<td>
<p>desired number of digits to display</p>
</td></tr>
<tr><td><code id="print.msummary.lm_+3A_symbolic.cor">symbolic.cor</code></td>
<td>
<p>see <code><a href="base.html#topic+summary">summary()</a></code></p>
</td></tr>
<tr><td><code id="print.msummary.lm_+3A_signif.stars">signif.stars</code></td>
<td>
<p>a logical indicating whether to display stars to
indicate significance</p>
</td></tr>
<tr><td><code id="print.msummary.lm_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="print.msummary.lm_+3A_object">object</code></td>
<td>
<p>an object to summarise</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>msummary(lm(Sepal.Length ~ Species, data = iris))

</code></pre>

<hr>
<h2 id='prop'>Compute proportions, percents, or counts for a single level</h2><span id='topic+prop'></span><span id='topic+prop1'></span><span id='topic+count'></span><span id='topic+perc'></span>

<h3>Description</h3>

<p>Compute proportions, percents, or counts for a single level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop(
  x,
  data = parent.frame(),
  useNA = "no",
  ...,
  success = NULL,
  level = NULL,
  long.names = TRUE,
  sep = ".",
  format = c("proportion", "percent", "count"),
  quiet = TRUE,
  pval.adjust = FALSE
)

prop1(..., pval.adjust = TRUE)

count(x, ...)

perc(x, data = parent.frame(), ..., format = "percent")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prop_+3A_x">x</code></td>
<td>
<p>an R object, usually a formula</p>
</td></tr>
<tr><td><code id="prop_+3A_data">data</code></td>
<td>
<p>a data frame in which <code>x</code> is to be evaluated</p>
</td></tr>
<tr><td><code id="prop_+3A_usena">useNA</code></td>
<td>
<p>an indication of how NA's should be handled.  By default, they are
ignored.</p>
</td></tr>
<tr><td><code id="prop_+3A_...">...</code></td>
<td>
<p>arguments passed through to <code><a href="#topic+tally">tally()</a></code></p>
</td></tr>
<tr><td><code id="prop_+3A_success">success</code></td>
<td>
<p>the level for which counts, proportions or percents are
calculated</p>
</td></tr>
<tr><td><code id="prop_+3A_level">level</code></td>
<td>
<p>Deprecated.  Use <code>sucess</code>.</p>
</td></tr>
<tr><td><code id="prop_+3A_long.names">long.names</code></td>
<td>
<p>a logical indicating whether long names should be
when there is a conditioning variable</p>
</td></tr>
<tr><td><code id="prop_+3A_sep">sep</code></td>
<td>
<p>a character used to separate portions of long names</p>
</td></tr>
<tr><td><code id="prop_+3A_format">format</code></td>
<td>
<p>one of <code>proportion</code>, <code>percent</code>, or <code>count</code>,
possibly abbreviated</p>
</td></tr>
<tr><td><code id="prop_+3A_quiet">quiet</code></td>
<td>
<p>a logical indicating whether messages regarding the
success level should be supressed.</p>
</td></tr>
<tr><td><code id="prop_+3A_pval.adjust">pval.adjust</code></td>
<td>
<p>a logical indicating whether the &quot;p-value&quot; adjustment should be
applied.  This adjustment adds 1 to the numerator and denominator counts.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>prop1</code> is intended for the computation of p-values from randomization
distributions and differs from <code>prop</code> only in its default value of
<code>pval.adjust</code>.
</p>


<h3>Note</h3>

<p>For 0-1 data, <code>success</code> is set to 1 by default since that a standard
coding scheme for success and failure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(mosaicData)) {
  prop( ~sex, data=HELPrct)
  prop( ~sex, data=HELPrct, success = "male")
  count( ~sex | substance, data=HELPrct)
  prop( ~sex | substance, data=HELPrct)
  perc( ~sex | substance, data=HELPrct)
}
</code></pre>

<hr>
<h2 id='reop_formula'>Insert Inhibition of Interpretation/Conversion into formulas</h2><span id='topic+reop_formula'></span>

<h3>Description</h3>

<p><code>model.frame()</code> assumes that certain operations (e.g. <code>/</code>, <code>*</code>, <code>^</code>) have special
meanings.  These can be inhibited using <code>I()</code>.  This function inserts <code>I()</code> into
a formula when encountering a specified operator or parens.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reop_formula(x, ops = c("/", "*", "^"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reop_formula_+3A_x">x</code></td>
<td>
<p>a formula (or a call of length 2 or 3, for recursive processing of formulas).
Other objects are returned unchanged.</p>
</td></tr>
<tr><td><code id="reop_formula_+3A_ops">ops</code></td>
<td>
<p>a vector of character representions of operators to be inhibited.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a formula with <code>I()</code> inserted where required to inhibit interpretation/conversion.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reop_formula(y ~ x * y)
reop_formula(y ~ (x * y))
reop_formula(y ~ x ^ y)
reop_formula(y ~ x * y ^ z)

</code></pre>

<hr>
<h2 id='rhs_or_expr'>Return rhs of a formula or expression</h2><span id='topic+rhs_or_expr'></span>

<h3>Description</h3>

<p>Return rhs of a formula or expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhs_or_expr(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rhs_or_expr_+3A_x">x</code></td>
<td>
<p>A formula or some other object to be quoted</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># This should evaluate to TRUE
rhs_or_expr(~z)
rhs_or_expr(z)
identical(rhs_or_expr(~z), rhs_or_expr(z))
</code></pre>

<hr>
<h2 id='tally'>Tabulate categorical data</h2><span id='topic+tally'></span><span id='topic+mosaic_tally.tbl'></span><span id='topic+mosaic_tally.data.frame'></span><span id='topic+mosaic_tally.formula'></span>

<h3>Description</h3>

<p>Tabulate categorical data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tally(x, ...)

## S3 method for class 'tbl'
mosaic_tally(x, wt, sort = FALSE, ..., envir = parent.frame())

## S3 method for class 'data.frame'
mosaic_tally(x, wt, sort = FALSE, ..., envir = parent.frame())

## S3 method for class 'formula'
mosaic_tally(
  x,
  data = parent.frame(),
  format = c("count", "proportion", "percent", "data.frame", "sparse", "default"),
  margins = FALSE,
  quiet = TRUE,
  subset,
  groups = NULL,
  useNA = "ifany",
  groups.first = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tally_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="tally_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="base.html#topic+table">table()</a></code></p>
</td></tr>
<tr><td><code id="tally_+3A_wt">wt</code></td>
<td>
<p>for weighted tallying,
see <code><a href="dplyr.html#topic+count">dplyr::tally()</a></code> in <span class="pkg">dplyr</span></p>
</td></tr>
<tr><td><code id="tally_+3A_sort">sort</code></td>
<td>
<p>a logical,
see <code><a href="dplyr.html#topic+count">dplyr::tally()</a></code> in <span class="pkg">dplyr</span></p>
</td></tr>
<tr><td><code id="tally_+3A_envir">envir</code></td>
<td>
<p>an environment in which to evaluate</p>
</td></tr>
<tr><td><code id="tally_+3A_data">data</code></td>
<td>
<p>a data frame or environment in which evaluation occurs.
Note that the default is <code>data=parent.frame()</code>.  This makes it convenient to
use this function interactively by treating the working envionment as if it were
a data frame.  But this may not be appropriate for programming uses.
When programming, it is best to use an explicit <code>data</code> argument
&ndash; ideally supplying a data frame that contains the variables mentioned</p>
</td></tr>
<tr><td><code id="tally_+3A_format">format</code></td>
<td>
<p>a character string describing the desired format of the results.
One of <code>'default'</code>, <code>'count'</code>, <code>'proportion'</code>, <code>'percent'</code>,
<code>'data.frame'</code>, <code>'sparse'</code>, or <code>'default'</code>.
In case of <code>'default'</code>, counts are used unless there is a condition, in
which case proportions are used instead.  Note that prior to version 0.9.3,
<code>'default'</code> was the default, now it is <code>'count'</code>.
<code>'data.frame'</code> converts the table to a data frame with one row per cell;
<code>'sparse'</code> additionally removes any rows with 0 counts.</p>
</td></tr>
<tr><td><code id="tally_+3A_margins">margins</code></td>
<td>
<p>a logical indicating whether marginal distributions should be displayed.</p>
</td></tr>
<tr><td><code id="tally_+3A_quiet">quiet</code></td>
<td>
<p>a logical indicating whether messages about order in which
marginal distributions are calculated should be suppressed.
See <code><a href="stats.html#topic+addmargins">stats::addmargins()</a></code>.</p>
</td></tr>
<tr><td><code id="tally_+3A_subset">subset</code></td>
<td>
<p>an expression evaluating to a logical vector used to select a subset of <code>data</code></p>
</td></tr>
<tr><td><code id="tally_+3A_groups">groups</code></td>
<td>
<p>used to specify a condition as an alternative to using a formula
with a condition.</p>
</td></tr>
<tr><td><code id="tally_+3A_usena">useNA</code></td>
<td>
<p>as in <code><a href="base.html#topic+table">table()</a></code>, but the default here is <code>"ifany"</code>.</p>
</td></tr>
<tr><td><code id="tally_+3A_groups.first">groups.first</code></td>
<td>
<p>a logical indicating whether groups should be inserted
ahead of the condition (else after).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <span class="pkg">dplyr</span> package also exports a <code><a href="dplyr.html#topic+count">dplyr::tally()</a></code> function.
If <code>x</code> inherits from class <code>"tbl"</code> or <code>"data frame"</code>,
then <span class="pkg">dplyr</span>'s <code><a href="dplyr.html#topic+count">dplyr::tally()</a></code> is called.  This makes it
easier to have the two packages coexist.
</p>
<p>Otherwise, <code>tally()</code> is designed as an alternative to <code><a href="base.html#topic+table">table()</a></code> and
<code><a href="stats.html#topic+xtabs">xtabs()</a></code>.  The primary use case it to describe a (possibly multi-dimensional)
table using a formula.  For a table of counts, each component of the formula becomes one
of the dimensions of the cross table.  For tables of proportions or percents, conditional
proportions and percents are computed, conditioned on each level of all &quot;secondary&quot;
(i.e., conditioning) variables, defined as everything other than the left hand side,
if there is a left hand side to the formula; and everything except the right hand side
if the left hand side of the formula is empty.  Note that <code>groups</code> is folded into
the formula prior to this determination and becomes part of the conditioning.
</p>
<p>When marginal totals are added, they are added for all of the conditioning dimensions, and
proportions should sum to 1 for each level of the conditioning variables.  This can be
useful to make it clear which conditional proportions are being computed.
</p>
<p>See the examples for some typical use cases.
</p>


<h3>Value</h3>

<p>A object of class <code>"table"</code>, unless passing through to <span class="pkg">dplyr</span>
or converted to a data frame because <code>format</code> is <code>"data.frame"</code> or
<code>"sparse"</code>.
</p>


<h3>Note</h3>

<p>The current implementation when <code>format = "sparse"</code> first creates the full data frame
and then removes the unneeded rows.  So the savings is in terms of space, not time.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(mosaicData)) {
tally( ~ substance, data = HELPrct)
tally( ~ substance + sex , data = HELPrct)
tally( sex ~ substance, data = HELPrct)   # equivalent to tally( ~ sex | substance, ... )
tally( ~ substance | sex , data = HELPrct)
tally( ~ substance | sex , data = HELPrct, format = 'count', margins = TRUE)
tally( ~ substance + sex , data = HELPrct, format = 'percent', margins = TRUE)
tally( ~ substance | sex , data = HELPrct, format = 'percent', margins = TRUE)
# force NAs to show up
tally( ~ sex, data = HELPrct, useNA = "always")
# show NAs if any are there
tally( ~ link, data = HELPrct)
# ignore the NAs
tally( ~ link, data = HELPrct, useNA = "no")
}
</code></pre>

<hr>
<h2 id='vector2df'>Convert a vector to a data frame</h2><span id='topic+vector2df'></span>

<h3>Description</h3>

<p>Convert a vector into a 1-row data frame using the names of the vector as
column names for the data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vector2df(x, nice_names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vector2df_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="vector2df_+3A_nice_names">nice_names</code></td>
<td>
<p>A logical indicating whether names should be nicified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vector2df(c(1, b = 2, `(Intercept)` = 3))
vector2df(c(1, b = 2, `(Intercept)` = 3), nice_names = TRUE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
