<!DOCTYPE html><html lang="en"><head><title>Help for package diemr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {diemr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#brenthis'><p>Dataset of Butterfly Genotypes</p></a></li>
<li><a href='#CheckDiemFormat'><p>diem input file checker</p></a></li>
<li><a href='#diem'><p>Diagnostic Index Expectation Maximisation</p></a></li>
<li><a href='#emPolarise'><p>Polarises a marker</p></a></li>
<li><a href='#importPolarized'><p>Imports genomic data polarized according to the specification</p></a></li>
<li><a href='#ModelOfDiagnostic'><p>Model of Diagnostic Marker Based on All Individual State Counts</p></a></li>
<li><a href='#myotis'><p>Dataset of Modified Genotypes of Bats</p></a></li>
<li><a href='#pHetErrOnStateCount'><p>Hybrid index, heterozygosity, error rate</p></a></li>
<li><a href='#plotDeFinetti'><p>Plot the De Finetti Diagram for Polarized Genotypes</p></a></li>
<li><a href='#plotMarkerAxis'><p>Add a Marker Axis with Chromosome Names to a Plot of Polarized Genotypes</p></a></li>
<li><a href='#plotPolarized'><p>Plot Polarized Genotypes</p></a></li>
<li><a href='#rank2map'><p>Convert SNP Ranks To Windows Corresponding to Mapping Distance</p></a></li>
<li><a href='#smoothPolarizedGenotypes'><p>Smooth Polarized Genotype States</p></a></li>
<li><a href='#sStateCount'><p>Count states in a vector</p></a></li>
<li><a href='#testdata'><p>Dataset of Fish Genotypes</p></a></li>
<li><a href='#truncatedLaplace'><p>Truncated Laplace distribution to 95% of area under the curve, weights scaled to 10/19</p></a></li>
<li><a href='#unbiasedWeightedStateChoice'><p>Selects weighted mode of the genomic state</p></a></li>
<li><a href='#vcf2diem'><p>Convert vcf files to diem format</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Diagnostic Index Expectation Maximisation in R</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Likelihood-based genome polarisation finds which alleles of genomic markers 
    belong to which side of the barrier. 
	Co-estimates which individuals belong to either side of the barrier and barrier strength.
	Uses expectation maximisation in likelihood framework. The method is described in 
	Baird et al. (2023) &lt;<a href="https://doi.org/10.1111%2F2041-210X.14010">doi:10.1111/2041-210X.14010</a>&gt;.</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/StuartJEBaird/diem/issues">https://github.com/StuartJEBaird/diem/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), knitr, rmarkdown</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>zoo, vcfR</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-20 13:27:28 UTC; martinkova</td>
</tr>
<tr>
<td>Author:</td>
<td>Natalia Martinkova
    <a href="https://orcid.org/0000-0003-4556-4363"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Stuart Baird <a href="https://orcid.org/0000-0002-7144-9919"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Natalia Martinkova &lt;martinkova@ivb.cz&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-20 13:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='brenthis'>Dataset of Butterfly Genotypes</h2><span id='topic+brenthis'></span>

<h3>Description</h3>

<p>A subset of single nucleotide polymorphisms in butterflies of the genus <em>Brenthis</em>.
</p>


<h3>Format</h3>

<p>vcf file with 13 individuals and 4 markers.
</p>


<h3>Details</h3>

<p>The data is used to test conversion of genotype data from vcf to diem format with
function <code>vcf2diem</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filename &lt;- system.file("extdata", "brenthis.vcf", package = "diemr")
</code></pre>

<hr>
<h2 id='CheckDiemFormat'>diem input file checker</h2><span id='topic+CheckDiemFormat'></span>

<h3>Description</h3>

<p>Checks format of files with genotype data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CheckDiemFormat(files, ChosenInds, ploidy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CheckDiemFormat_+3A_files">files</code></td>
<td>
<p>A character vector with paths to files with genotypes.</p>
</td></tr>
<tr><td><code id="CheckDiemFormat_+3A_choseninds">ChosenInds</code></td>
<td>
<p>A numeric or logical vector of indices of individuals to be included
in the analysis.</p>
</td></tr>
<tr><td><code id="CheckDiemFormat_+3A_ploidy">ploidy</code></td>
<td>
<p>A logical or a list of length equal to length of <code>files</code>. Each
element of the list
contains a numeric vector with ploidy numbers for all individuals specified in
the <code>files</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input file must have genotypes of one marker for all individuals on one
line. The line must start with a letter &quot;S&quot; and contain only characters
&quot;_&quot; or &quot;U&quot; for unknown genotypes or a third/fourth allele, &quot;0&quot; for homozygots for
allele 1, &quot;1&quot; for heterozygots, and &quot;2&quot; for homozygots for allele 2. Check the
vignette with <code>browseVignettes(package = "diemr")</code> for the example of the
input format.
</p>
<p>Ploidies must be given as a list with each element corresponding to a genomic
compartment (aka a file). For each compartment, the numeric vector specifying
ploidies of all individuals chosen for the specific analysis must be given.
</p>


<h3>Value</h3>

<p>Returns invisible <code>TRUE</code> if all files are executable by <code>diem</code>. Exits
with informative error messages otherwise, specifying file names and lines with
potential problems. When too many lines contain problems, the first six are given.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set up input genotypes file names, ploidies and selection of individual samples
inputFile &lt;- system.file("extdata", "data7x3.txt", package = "diemr")
ploidies &lt;- list(c(2, 1, 2, 2, 2, 1, 2))
inds &lt;- 1:7

# check input data
CheckDiemFormat(files = inputFile, ploidy = ploidies, ChosenInds = inds)
#  File check passed: TRUE
#  Ploidy check passed: TRUE
</code></pre>

<hr>
<h2 id='diem'>Diagnostic Index Expectation Maximisation</h2><span id='topic+diem'></span>

<h3>Description</h3>

<p>Estimates how to assign alleles in a genome to maximise the distinction between two
unknown groups of individuals. Using expectation maximisation (EM) in likelihood
framework, <code>diem</code> provides marker
polarities for importing data, their likelihood-based diagnostic index and its support
for all markers, and hybrid indices for all individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diem(
  files,
  ploidy = FALSE,
  markerPolarity = FALSE,
  ChosenInds,
  ChosenSites = "all",
  epsilon = 0.99999,
  verbose = FALSE,
  nCores = parallel::detectCores() - 1,
  maxIterations = 50,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diem_+3A_files">files</code></td>
<td>
<p>A character vector with paths to files with genotypes.</p>
</td></tr>
<tr><td><code id="diem_+3A_ploidy">ploidy</code></td>
<td>
<p>A logical or a list of length equal to length of <code>files</code>. Each
element of the list
contains a numeric vector with ploidy numbers for all individuals specified in
the <code>files</code>.</p>
</td></tr>
<tr><td><code id="diem_+3A_markerpolarity">markerPolarity</code></td>
<td>
<p><code>FALSE</code> or a list of logical vectors.</p>
</td></tr>
<tr><td><code id="diem_+3A_choseninds">ChosenInds</code></td>
<td>
<p>A numeric or logical vector of indices of individuals to be included
in the analysis.</p>
</td></tr>
<tr><td><code id="diem_+3A_chosensites">ChosenSites</code></td>
<td>
<p>A logical vector indicating which sites are to be included in the
analysis.</p>
</td></tr>
<tr><td><code id="diem_+3A_epsilon">epsilon</code></td>
<td>
<p>A numeric, specifying how much the hypothetical diagnostic markers should
contribute to the likelihood calculations. Must be in <code>[0,1)</code>, keeping
tolerance setting of the <code>R</code> session in mind.</p>
</td></tr>
<tr><td><code id="diem_+3A_verbose">verbose</code></td>
<td>
<p>Logical or character with path to directory where run diagnostics will
be saved.</p>
</td></tr>
<tr><td><code id="diem_+3A_ncores">nCores</code></td>
<td>
<p>A numeric number of cores to be used for parallelisation. Must be
<code>nCores = 1</code> on Windows.</p>
</td></tr>
<tr><td><code id="diem_+3A_maxiterations">maxIterations</code></td>
<td>
<p>A numeric.</p>
</td></tr>
<tr><td><code id="diem_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given two alleles of a marker, one allele can belong to one side of a barrier
to geneflow and the other to the other side. Which allele belongs where is a non-trivial
matter. A marker state in an individual can be encoded as 0 if the individual is
homozygous for the first allele, and 2 if the individual is homozygous for the second
allele. Marker polarity determines how the marker will be imported. Marker polarity
equal to <code>FALSE</code> means that the marker will be imported as-is. A marker with
polarity equal to <code>TRUE</code> will be imported with states 0 mapped as 2 and states 2
mapped as 0, in effect switching which allele belongs to which side of a barrier to
geneflow.
</p>
<p>When <code>markerPolarity = FALSE</code>, <code>diem</code> uses random null polarities to
initiate the EM algorithm. To fix the null polarities, <code>markerPolarity</code> must be
a list of length equal to the length of the <code>files</code> argument, where each element
in the list is a logical vector of length equal to the number of markers (rows) in
the specific file.
</p>
<p>Ploidy needs to be given for each compartment and for each individual. For example,
for a dataset of three diploid mammal males consisting of an autosomal
compartment, an X chromosome
compartment and a Y chromosome compartment, the ploidy list would be
<code>ploidy = list(rep(2, 3), rep(1, 3), rep(1, 3)</code>. If the dataset consisted of
one male and two females,
ploidy for the sex chromosomes should be vectors reflecting that females have two X
chromosomes, but males only one, and females have no Y chromosomes:
<code>ploidy = list(rep(2, 3), c(1, 2, 2), c(1, 0, 0))</code>.
</p>
<p>When a subset of individuals is used to inform the genome polarisation in the
<code>ChosenInds</code> argument, <code>ploidy</code> must still be provided for all individuals
included in the <code>files</code>.
</p>
<p><code>ChosenInds</code> should preferably be numeric values within the range from 1 to the
number of individuals in the <code>files</code>. Logical vectors must have a length equal
to the number of individuals in the <code>files</code>.
</p>
<p>When <code>verbose = TRUE</code>, <code>diem</code> will output multiple files with information
on the iterations of the EM algorithm, including tracking marker polarities and the
respective likelihood-based diagnostics. See vignette <code>vignette("Understanding-genome-polarisation-output-files",
  package = "diemr")</code> for a detailed explanation of the individual output files.
</p>


<h3>Value</h3>

<p>A list including suggested marker polarities, diagnostic indices and support for all
markers, four genomic state counts matrix for all individuals, and polarity changes
for the EM iterations.
</p>


<h3>Note</h3>

<p>To ensure that the data input format of the genotype files, ploidies and individual
selection are readable for <code>diem</code>, first use <a href="#topic+CheckDiemFormat">CheckDiemFormat</a>.
Fix all errors, and run <code>diem</code> only once the checks all passed.
</p>
<p>The working directory or a folder optionally specified in the <code>verbose</code>
argument must have write permissions. <code>diem</code> will store temporary files in the
location and output results files.
</p>
<p>The grain for parallelisation is the compartment <code>files</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+CheckDiemFormat">CheckDiemFormat</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set up input genotypes file names, ploidies and selection of individual samples
inputFile &lt;- system.file("extdata", "data7x3.txt", package = "diemr")
ploidies &lt;- list(c(2, 1, 2, 2, 2, 1, 2))
inds &lt;- 1:6

# check input data
CheckDiemFormat(files = inputFile, ploidy = ploidies, ChosenInds = inds)
#  File check passed: TRUE
#  Ploidy check passed: TRUE

# run diem
## Not run: 
# diem will write temporal files during EM iterations
# prior to running diem, set the working directory to a location with write permission
fit &lt;- diem(files = inputFile, ChosenInds = inds, ploidy = ploidies, nCores = 1)

# run diem with fixed null polarities
fit2 &lt;- diem(
  files = inputFile, ChosenInds = inds, ploidy = ploidies, nCores = 1,
  markerPolarity = list(c(TRUE, FALSE, TRUE))
)

## End(Not run)
</code></pre>

<hr>
<h2 id='emPolarise'>Polarises a marker</h2><span id='topic+emPolarise'></span>

<h3>Description</h3>

<p>Changes encodings of genomic markers according to user specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emPolarise(origM, changePolarity = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="emPolarise_+3A_origm">origM</code></td>
<td>
<p>A character vector of genotypes comprising of _012 encodings.</p>
</td></tr>
<tr><td><code id="emPolarise_+3A_changepolarity">changePolarity</code></td>
<td>
<p>A logical scalar, indicating whether to leave the marker as is
(<code>FALSE</code>) or whether to change its polarity (<code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a character vector with polarised markers.
</p>


<h3>Note</h3>

<p>Note that <a href="#topic+diem">diem</a> and <a href="#topic+importPolarized">importPolarized</a> accept also a <code>U</code>
encoding for an unknown or third allele, but <code>emPolarise</code> requires all <code>U</code> to
be replaced with <code style="white-space: pre;">&#8288;_&#8288;</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diem">diem</a></code> for determining appropriate marker polarity with
respect to a barrier to geneflow.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>emPolarise(c("0", "0", "1", "2", "2"), TRUE)
# [1] "2" "2" "1" "0" "0"

emPolarise(c("0", "_", "2", "2", "1"), FALSE)
# [1] "0" "_" "2" "2" "1"
</code></pre>

<hr>
<h2 id='importPolarized'>Imports genomic data polarized according to the specification</h2><span id='topic+importPolarized'></span>

<h3>Description</h3>

<p>Reads genotypes from a file and changes marker polarity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>importPolarized(
  files,
  changePolarity,
  ChosenInds,
  ChosenSites = "all",
  nCores = 1,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="importPolarized_+3A_files">files</code></td>
<td>
<p>A character vector with paths to files with genotypes.</p>
</td></tr>
<tr><td><code id="importPolarized_+3A_changepolarity">changePolarity</code></td>
<td>
<p>A logical vector with length equal to the number of markers.</p>
</td></tr>
<tr><td><code id="importPolarized_+3A_choseninds">ChosenInds</code></td>
<td>
<p>A numeric or logical vector of indices of individuals to be included
in the analysis.</p>
</td></tr>
<tr><td><code id="importPolarized_+3A_chosensites">ChosenSites</code></td>
<td>
<p>A logical vector indicating which sites are to be included in the
analysis.</p>
</td></tr>
<tr><td><code id="importPolarized_+3A_ncores">nCores</code></td>
<td>
<p>A numeric number of cores to be used for parallelisation. Must be
<code>nCores = 1</code> on Windows.</p>
</td></tr>
<tr><td><code id="importPolarized_+3A_verbose">verbose</code></td>
<td>
<p>Logical whether to show messages on import progress.</p>
</td></tr>
<tr><td><code id="importPolarized_+3A_...">...</code></td>
<td>
<p>Optional numeric vector of <code>compartmentSizes</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details on the input data format, check the <code>file</code> with
<a href="#topic+CheckDiemFormat">CheckDiemFormat</a>.
</p>
<p>The <code>changePolarity</code> argument influences how each marker is imported. Value
<code>FALSE</code> means that the marker will be imported as it is saved in the <code>file</code>. Value
<code>TRUE</code> means that the genotypes encoded as <code>0</code> will be imported as <code>2</code>, and genotypes
encoded in the <code>file</code> as <code>2</code> will be imported as <code>0</code>.
</p>


<h3>Value</h3>

<p>Returns a character matrix with rows containing individual genotypes and columns
containing markers.
</p>


<h3>See Also</h3>

<p><a href="#topic+diem">diem</a> for determining appropriate marker polarity with
respect to a barrier to gene flow.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- importPolarized(
  files = system.file("extdata", "data7x3.txt", package = "diemr"),
  changePolarity = c(FALSE, TRUE, TRUE),
  ChosenInds = 1:6,
  ChosenSites = "all"
)
dat
#    m1  m2  m3
# 1 "0" "1" "2"
# 2 "0" "0" "0"
# 3 "1" "1" "0"
# 4 "1" "2" "0"
# 5 "2" "2" "1"
# 6 "2" "2" "_"
</code></pre>

<hr>
<h2 id='ModelOfDiagnostic'>Model of Diagnostic Marker Based on All Individual State Counts</h2><span id='topic+ModelOfDiagnostic'></span>

<h3>Description</h3>

<p>Estimates a diagnostic marker for the state counts of all genomic markers for all
individuals. Using the hypothetical, diagnostic marker, calculates individual state
counts with respect to their weighted similarity to the diagnostic marker states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ModelOfDiagnostic(
  I4,
  OriginalHI,
  epsilon = 0.99,
  verbose = FALSE,
  folder = "likelihood",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ModelOfDiagnostic_+3A_i4">I4</code></td>
<td>
<p>a matrix or data.frame with 4 numeric columns
representing character state
counts for missing data, homozygots for allele 1, heterozygots, and
homozygots for allele 2. Individuals in rows.</p>
</td></tr>
<tr><td><code id="ModelOfDiagnostic_+3A_originalhi">OriginalHI</code></td>
<td>
<p>numeric vector of length equal to number of rows in <code>I4</code>,
representing hybrid indices of individuals.</p>
</td></tr>
<tr><td><code id="ModelOfDiagnostic_+3A_epsilon">epsilon</code></td>
<td>
<p>A numeric, specifying how much the hypothetical diagnostic markers should
contribute to the likelihood calculations. Must be in <code>[0,1)</code>, keeping
tolerance setting of the <code>R</code> session in mind.</p>
</td></tr>
<tr><td><code id="ModelOfDiagnostic_+3A_verbose">verbose</code></td>
<td>
<p>Logical or character with path to directory where run diagnostics will
be saved.</p>
</td></tr>
<tr><td><code id="ModelOfDiagnostic_+3A_folder">folder</code></td>
<td>
<p>character specifying path to a folder for the verbose output.</p>
</td></tr>
<tr><td><code id="ModelOfDiagnostic_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>OriginalHI</code> can be calculated with <code><a href="#topic+pHetErrOnStateCount">pHetErrOnStateCount</a></code>.
</p>


<h3>Value</h3>

<p>Matrix with dimensions of I4.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diem">diem</a></code> for utilising the model to determine appropriate marker
polarisation in estimating barriers to geneflow.
</p>

<hr>
<h2 id='myotis'>Dataset of Modified Genotypes of Bats</h2><span id='topic+myotis'></span>

<h3>Description</h3>

<p>A subset of single nucleotide polymorphisms in <em>Myotis myotis</em> from Harazim et al.
(2021). The genotypes were modified for testing purposes in such a way that markers
15 and 17 now include additional indel and substitution alleles. Eight markers
used in the dataset are monomorphic.
</p>


<h3>Format</h3>

<p>vcf file with 14 individuals and 20 markers.
</p>


<h3>Details</h3>

<p>The data is used to test conversion of genotype data from vcf to diem format with
function <code>vcf2diem</code>.
</p>


<h3>Source</h3>

<p>Harazim M., Pialek L., Pikula J., Seidlova V., Zukal J., Bachorec E.,
Bartonicka T., Kokurewicz T., Martinkova N. (2021) Associating physiological
functions with genomic variability in hibernating bats.
<em>Evolutionary Ecology</em>, 35, 291-308, doi: 10.1007/s10682-020-10096-4.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filename &lt;- system.file("extdata", "myotis.vcf", package = "diemr")
</code></pre>

<hr>
<h2 id='pHetErrOnStateCount'>Hybrid index, heterozygosity, error rate</h2><span id='topic+pHetErrOnStateCount'></span>

<h3>Description</h3>

<p>Using genotype allele counts, calculates
the hybrid index,
heterozygosity and error rate in a single individual.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pHetErrOnStateCount(sCount)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pHetErrOnStateCount_+3A_scount">sCount</code></td>
<td>
<p>A numeric vector of length 4 with allele counts for missing data,
homozygots for allele 1, heterozygots, and homozygots for allele 2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Allele counts are genomic state counts multiplied by ploidy. As different
compartments might have different ploidies (e.g. autosomal markers, sex chromosomes,
mitochondrial markers), allele counts should be calculated per compartment and then
summarised to obtain the correct genomic allele counts.
When all individuals in each compartmenst have the same ploidy, state counts do
not need to be corrected.
</p>


<h3>Value</h3>

<p>Returns a named numeric vector with three values: p - hybrid index,
Het - heterozygosity,
Err - error rate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pHetErrOnStateCount(sCount = c(2, 4, 2, 6))
#         p       Het       Err
# 0.5833333 0.1666667 0.1428571
</code></pre>

<hr>
<h2 id='plotDeFinetti'>Plot the De Finetti Diagram for Polarized Genotypes</h2><span id='topic+plotDeFinetti'></span>

<h3>Description</h3>

<p>This function calculates genotype frequencies from polarized genotypes, ideally
imported using the
<code>importPolarized</code> function. It plots individuals onto a ternary De Finetti
diagram and includes a curve indicating Hardy-Weinberg equilibrium if specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDeFinetti(
  genotypes,
  cols,
  HWE = TRUE,
  tipLabels = c("Homozygous 0", "Heterozygous 1", "Homozygous 2"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotDeFinetti_+3A_genotypes">genotypes</code></td>
<td>
<p>A character matrix comprising of _012 encodings.</p>
</td></tr>
<tr><td><code id="plotDeFinetti_+3A_cols">cols</code></td>
<td>
<p>A character vector of colors with a length equal to the number of
individuals (rows) in <code>genotypes</code>.</p>
</td></tr>
<tr><td><code id="plotDeFinetti_+3A_hwe">HWE</code></td>
<td>
<p>Logical indicating whether to plot the curve for Hardy-Weinberg Equilibrium.</p>
</td></tr>
<tr><td><code id="plotDeFinetti_+3A_tiplabels">tipLabels</code></td>
<td>
<p>A character vector of length 3 with names for the ternary plot vertices.</p>
</td></tr>
<tr><td><code id="plotDeFinetti_+3A_...">...</code></td>
<td>
<p>additional graphical parameters (see <a href="graphics.html#topic+plot.default">plot.default</a>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To import and polarize genotypes, use the <a href="#topic+importPolarized">importPolarized</a> function.
Alternatively, the I4 matrix can be used as input for <code>genotypes</code>.
</p>


<h3>Value</h3>

<p>No return value; the function is called for its side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gen &lt;- importPolarized(
  file = system.file("extdata", "data7x10.txt", package = "diemr"),
  changePolarity = c(TRUE, FALSE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, TRUE),
  ChosenInds = 1:7
)

plotDeFinetti(gen, cols = palette.colors(nrow(gen), "Accent"), pch = 19)
</code></pre>

<hr>
<h2 id='plotMarkerAxis'>Add a Marker Axis with Chromosome Names to a Plot of Polarized Genotypes</h2><span id='topic+plotMarkerAxis'></span>

<h3>Description</h3>

<p>This function adds a marker axis with chromosome names to an existing plot of polarized
genotypes. It requires that the plot is already created using <a href="#topic+plotPolarized">plotPolarized</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMarkerAxis(
  includedSites,
  ChosenSites,
  tickDist = 1e+06,
  axisInfo = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotMarkerAxis_+3A_includedsites">includedSites</code></td>
<td>
<p>A character path to a file with columns <code>CHROM</code> and <code>POS</code>.</p>
</td></tr>
<tr><td><code id="plotMarkerAxis_+3A_chosensites">ChosenSites</code></td>
<td>
<p>A logical vector indicating which sites are to be included in the
analysis.</p>
</td></tr>
<tr><td><code id="plotMarkerAxis_+3A_tickdist">tickDist</code></td>
<td>
<p>A numeric indicating the spacing of physical tick marks along a chromosome.</p>
</td></tr>
<tr><td><code id="plotMarkerAxis_+3A_axisinfo">axisInfo</code></td>
<td>
<p>A list with user-defined tick positions and labels for marker axis. See
Details.</p>
</td></tr>
<tr><td><code id="plotMarkerAxis_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>includedSites</code> file should ideally be generated by
<a href="#topic+vcf2diem">vcf2diem</a> to ensure congruence between the plotted genotypes and
the respective metadata.
</p>
<p>Tick mark distances within a chromosome are located at <code>tickDist</code> and formated to
multiples of millions.
</p>
<p>The optional <code>axisInfo</code> argument must have five named elements with the following
information:
</p>

<ul>
<li> <p><code>CHROMbreaks</code>: Numeric vector with positions defining ticks separating
chromosomes. The metric for all positions is in the number of markers.
</p>
</li>
<li> <p><code>CHROMnamesPos</code>: Numeric vector with positions to place the chromosome
labels.
</p>
</li>
<li> <p><code>CHROMnames</code>: Character vector with the names of the chromosomes. Must be the
same length as <code>CHROMnamesPos</code>.
</p>
</li>
<li> <p><code>ticksPos</code>: Numeric vector with positions of ticks within chromosomes.
</p>
</li>
<li> <p><code>ticksNames</code>: Character vector with the names to be displayed at <code>ticksPos</code>.
</p>
</li></ul>

<p>When <code>axisInfo = NULL</code>, the function extracts the necessary information from the
<code>includedSites</code> file.
</p>


<h3>Value</h3>

<p>Returns an invisible <code>axisInfo</code> list with the tick positions and labels
for the marker axis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Run this example in a working directory with write permissions
myo &lt;- system.file("extdata", "myotis.vcf", package = "diemr")
vcf2diem(myo, "myo")
inds &lt;- 1:14
fit &lt;- diem("myo-001.txt", ChosenInds = inds, ploidy = FALSE)
gen &lt;- importPolarized("myo-001.txt", fit$markerPolarity, inds)
h &lt;- apply(gen, 1, function(x) pHetErrOnStateCount(sStateCount(x)))[1, ]
plotPolarized(gen, h, xlab = "")
plotMarkerAxis("myo-includedSites.txt", rep(TRUE, 11), tickDist = 100)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotPolarized'>Plot Polarized Genotypes</h2><span id='topic+plotPolarized'></span>

<h3>Description</h3>

<p>Plots genotypes that can be optionally polarized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPolarized(
  genotypes,
  HI,
  cols = c("#FFFFFF", "#800080", "#FFE500", "#008080"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotPolarized_+3A_genotypes">genotypes</code></td>
<td>
<p>A character matrix comprising of _012 encodings.</p>
</td></tr>
<tr><td><code id="plotPolarized_+3A_hi">HI</code></td>
<td>
<p>A numeric vector of individual hybrid indices with length equal to number
of rows in <code>genotypes</code>.</p>
</td></tr>
<tr><td><code id="plotPolarized_+3A_cols">cols</code></td>
<td>
<p>A vector of four colors, representing missing data, homozygotes for
genotype 0, heterozygotes and homozygotes for genotype 2.</p>
</td></tr>
<tr><td><code id="plotPolarized_+3A_...">...</code></td>
<td>
<p>Additional selected arguments passed to <a href="graphics.html#topic+image">image</a> and
<a href="graphics.html#topic+axis">axis</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To import and polarize genotypes, use the <a href="#topic+importPolarized">importPolarized</a> function.
</p>
<p>When using <a href="#topic+diem">diem</a>, hybrid indices,
<code>HI</code>, can be found in the file 'HIwithOptimalPolarities.txt'. Alternatively,
calculate <code>HI</code> from the polarized genotypes as shown in the examples.
</p>
<p>By default, the function plots colored tick marks for individuals, changing the
color at the steepest change in sorted <code>HI</code>. The second and fourth colors in
<code>cols</code> are used for the tick marks.
</p>

<ul>
<li><p> To turn off this feature, use the argument <code>tick = FALSE</code>.
</p>
</li>
<li><p> To use custom tick mark colors, provide a vector of colors for all individuals
(equal to the number of rows in <code>genotypes</code>). The <strong>vector of colors must be
ordered</strong> according to <code>order(HI)</code>.
</p>
</li>
<li><p> To include individual <code>labels</code> (e.g., accession numbers), provide a character
vector with the <strong>names in the same order as they are</strong> in the <code>genotypes</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>No return value, called for side effects. In the default plot, purple and green
represent sides of the barrier to gene flow encoded as <code>0</code> and <code>2</code>, respectively,
yellow shows heterozygotes and white represents missing or undetermined genotypes.
Individuals are ordered according to the sorted <code>HI</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+plotMarkerAxis">plotMarkerAxis</a> to add chromosome information to the x axis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gen &lt;- importPolarized(
  file = system.file("extdata", "data7x10.txt", package = "diemr"),
  changePolarity = c(TRUE, FALSE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, TRUE),
  ChosenInds = 1:7
)

h &lt;- apply(gen, 1, FUN = function(x) pHetErrOnStateCount(sStateCount(x)))[1, ]

plotPolarized(genotypes = gen, HI = h)

# Incorrect tick color order
plotPolarized(gen, h, col.ticks = c(rep("purple", 5), "green", "purple"), lwd = 3)

# Correct tick color order
plotPolarized(gen, h, col.ticks = c(rep("purple", 5), "green", "purple")[order(h)], lwd = 3)

# Correct individual label order 
plotPolarized(gen, h, labels = c(paste("purple", 1:5), "green 1", "purple 6"), ylab = "")
</code></pre>

<hr>
<h2 id='rank2map'>Convert SNP Ranks To Windows Corresponding to Mapping Distance</h2><span id='topic+rank2map'></span>

<h3>Description</h3>

<p>This function estimates positions of ordered single nucleotide polymorphisms (SNPs) that correspond
to a window spanning a user-defined distance in the SNP positions mapped to a reference.
Each window is centered at the SNP mapped position.
Conversion of a SNP rank position metric to a mapped position metric is useful for
kernel smoothing of the <code>diem</code>
output state along a genomic sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rank2map(includedSites, ChosenSites = "all", windowSize = 1e+07, nCores = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rank2map_+3A_includedsites">includedSites</code></td>
<td>
<p>A character path to a file with columns <code>CHROM</code> and <code>POS</code>.</p>
</td></tr>
<tr><td><code id="rank2map_+3A_chosensites">ChosenSites</code></td>
<td>
<p>A logical vector indicating which sites are to be included in the
analysis.</p>
</td></tr>
<tr><td><code id="rank2map_+3A_windowsize">windowSize</code></td>
<td>
<p>A numeric window size for metric conversion in base-pairs.</p>
</td></tr>
<tr><td><code id="rank2map_+3A_ncores">nCores</code></td>
<td>
<p>A numeric number of cores to be used for parallelisation. Must be
<code>nCores = 1</code> on Windows.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Single nucleotide polymorphisms (SNPs) tend to be spread across a genome randomly.
To facilitate interpretation of the <code>diem</code> output, the marker states should be
assessed on the metric of their position along chromosomes (contigs). The windows for
kernel smoothing might contain a variable number of markers. This function estimates
which markers should be assessed together given their proximity on a chromosome.
</p>
<p>Values in <code>includedSites</code> are in essence SNP positions in BED format with a header.
The <code>includedSites</code> file should ideally be generated by
<a href="#topic+vcf2diem">vcf2diem</a> to ensure congruence across all analyses.
</p>
<p>The function reads SNP positions from the specified BED-like file and divides the
genome into segments based on chromosomes. Each segment is then processed to identify
genomic windows encompassing each SNP, considering the specified window size. This
process is parallelized to enhance performance, and each SNP is considered within
its chromosomal context to ensure accurate window placement.
</p>
<p>Minimum value of <code>windowSize</code> is equal to 3, but in genomic data evaluations, window
size should be at least two orders of magnitude larger. A good approximation of a
useful minimum window size is $(genome size) / ((number of SNPSs) / 2)$. Throughout the
diemr package, <code>windowSize</code> refers to the genomic context of the respective SNP
that the user wishes to consider when smoothing over the polarized genomic states.
</p>


<h3>Value</h3>

<p>A two-column matrix with the number of rows corresponding to the number of
<code>ChosenSites</code>, indicating start and end indices of adjacent markers that are
within an interval of length <code>windowSize</code> centered on the specific marker.
</p>


<h3>Note</h3>

<p>The unit of parallelization when using <code>nCores &gt; 1</code> is set per chromosome.
This may differ from the parallelization approach used in <a href="#topic+diem">diem</a>, where processing
of compartment files is parallelized. Note that while compartment files can correspond
to chromosomes, this is not necessarily the case.
</p>


<h3>Author(s)</h3>

<p>Natalia Martinkova
</p>
<p>Filip Jagos <a href="mailto:521160@mail.muni.cz">521160@mail.muni.cz</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+smoothPolarizedGenotypes">smoothPolarizedGenotypes</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
 # Run this example in a working directory with write permissions
 myo &lt;- system.file("extdata", "myotis.vcf", package = "diemr")
 vcf2diem(myo, "myo")
 rank2map("myo-includedSites.txt", windowSize = 50)
 
## End(Not run) 
</code></pre>

<hr>
<h2 id='smoothPolarizedGenotypes'>Smooth Polarized Genotype States</h2><span id='topic+smoothPolarizedGenotypes'></span>

<h3>Description</h3>

<p>This function smooths polarized genotype states using a Laplace kernel density estimation.
It calculates a smoothed version of the genotype states over specified physical extent
of genomic content around a site. At each
genomic position, the function returns a weighted mode of the genomic state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothPolarizedGenotypes(
  genotypes,
  includedSites,
  ChosenSites = "all",
  windows = NULL,
  windowSize = 250000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smoothPolarizedGenotypes_+3A_genotypes">genotypes</code></td>
<td>
<p>A character matrix comprising of _012 encodings.</p>
</td></tr>
<tr><td><code id="smoothPolarizedGenotypes_+3A_includedsites">includedSites</code></td>
<td>
<p>A character path to a file with columns <code>CHROM</code> and <code>POS</code>.</p>
</td></tr>
<tr><td><code id="smoothPolarizedGenotypes_+3A_chosensites">ChosenSites</code></td>
<td>
<p>A logical vector indicating which sites are to be included in the
analysis.</p>
</td></tr>
<tr><td><code id="smoothPolarizedGenotypes_+3A_windows">windows</code></td>
<td>
<p>A two-column numeric matrix with indices of start and end positions for
windows for all markers indicated by <code>ChosenSites</code>. If <code>windows = NULL</code>, the function
calculates the windows using <a href="#topic+rank2map">rank2map</a>.</p>
</td></tr>
<tr><td><code id="smoothPolarizedGenotypes_+3A_windowsize">windowSize</code></td>
<td>
<p>A numeric window size for metric conversion in base-pairs.</p>
</td></tr>
<tr><td><code id="smoothPolarizedGenotypes_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <a href="#topic+rank2map">rank2map</a> if <code>windows = NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Ensure that <code>ChosenSites</code> match those used to import polarized genotypes.
</p>
<p>The function uses a truncated and scaled Laplace kernel to weight the genotype states
within a window around each marker position,
based on physical positions of the markers.
</p>
<p>The Laplace kernel weights are calculated for physical positions of the sites centered at
the site being smoothed as:
</p>
<p style="text-align: center;"><code class="reqn">\frac{10}{19} \exp\left(\frac{-x}{b}\right),</code>
</p>

<p>when <code class="reqn">x &lt; 0</code>, meaning that the site <code class="reqn">x</code> is upstream of the site being smoothed, and as:
</p>
<p style="text-align: center;"><code class="reqn">\frac{10}{19} \exp\left(\frac{x}{b}\right),</code>
</p>

<p>when <code class="reqn">x \geq 0</code>, meaning that the site is downstream.
The value <code class="reqn">x</code> is the position of a neighbouring site relative to the site being
smoothed, and <code class="reqn">b</code> is the scale parameter of the Laplace kernel.
The scale parameter is equal to:
</p>
<p style="text-align: center;"><code class="reqn">b = \frac{\text{windowSize}}{2 \ln(20)}.</code>
</p>



<h3>See Also</h3>

<p><a href="#topic+rank2map">rank2map</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
 # Run this example in a working directory with write permissions
 myo &lt;- system.file("extdata", "myotis.vcf", package = "diemr")
 vcf2diem(myo, "myo")
 fit &lt;- diem("myo-001.txt", ChosenInds = 1:14)
 gen &lt;- importPolarized("myo-001.txt", changePolarity = fit$markerPolarity, ChosenInds = 1:14)
 h &lt;- apply(gen, 1, \(x) pHetErrOnStateCount(sStateCount(x)))[1, ]
 gen2 &lt;- smoothPolarizedGenotypes(genotypes = gen, 
    includedSites = "myo-includedSites.txt", windowSize = 50)
 plotPolarized(gen, h)
 plotPolarized(gen2, h)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='sStateCount'>Count states in a vector</h2><span id='topic+sStateCount'></span>

<h3>Description</h3>

<p>Counts genomic states in one sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sStateCount(s)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sStateCount_+3A_s">s</code></td>
<td>
<p>A character vector with elements &quot;_&quot;, &quot;0&quot;, &quot;1&quot;, &quot;2&quot; representing
missing data, homozygots for allele 1, heterozygots, and
homozygots for allele 2. The vector should represent a single individual.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Summarizes the number of markers that are fixed for an allele in the genome of
one individual. This is used to construct the I4 matrix in <a href="#topic+diem">diem</a>.
</p>


<h3>Value</h3>

<p>Numeric vector of length 4 with counts of &quot;_&quot;, &quot;0&quot;, &quot;1&quot;, &quot;2&quot; respectively.
</p>


<h3>See Also</h3>

<p><a href="#topic+emPolarise">emPolarise</a> for changing marker polarity.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genotype &lt;- c("0", "0", "_", "2", "1", "0", "1")
sStateCount(genotype)
# [1] 1 3 2 1

# calculate state counts for a polarised genotype
sStateCount(emPolarise(genotype, TRUE))
# [1] 1 1 2 3
</code></pre>

<hr>
<h2 id='testdata'>Dataset of Fish Genotypes</h2><span id='topic+testdata'></span>

<h3>Description</h3>

<p>A subset of single nucleotide polymorphisms in fish for testing purposes of
multiallelic markers.
</p>


<h3>Format</h3>

<p>vcf file with 92 individuals and 6 markers.
</p>


<h3>Details</h3>

<p>The data is used to test conversion of genotype data from vcf to diem format with
the function <code>vcf2diem</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filename &lt;- system.file("extdata", "testdata.vcf", package = "diemr")
</code></pre>

<hr>
<h2 id='truncatedLaplace'>Truncated Laplace distribution to 95% of area under the curve, weights scaled to 10/19</h2><span id='topic+truncatedLaplace'></span>

<h3>Description</h3>

<p>Truncated Laplace distribution to 95% of area under the curve, weights scaled to 10/19
</p>


<h3>Usage</h3>

<pre><code class='language-R'>truncatedLaplace(x, laplaceScale)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="truncatedLaplace_+3A_x">x</code></td>
<td>
<p>A vector of integers, representing centered positions of SNPs</p>
</td></tr>
<tr><td><code id="truncatedLaplace_+3A_laplacescale">laplaceScale</code></td>
<td>
<p>A numeric giving scale of the Laplace distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>x must be within +-laplaceScale * log(20)
</p>

<hr>
<h2 id='unbiasedWeightedStateChoice'>Selects weighted mode of the genomic state</h2><span id='topic+unbiasedWeightedStateChoice'></span>

<h3>Description</h3>

<p>Selects weighted mode of the genomic state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unbiasedWeightedStateChoice(genomicStates, laplaceWeights)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unbiasedWeightedStateChoice_+3A_genomicstates">genomicStates</code></td>
<td>
<p>A character vector of genomic states in a given interval</p>
</td></tr>
<tr><td><code id="unbiasedWeightedStateChoice_+3A_laplaceweights">laplaceWeights</code></td>
<td>
<p>A numeric vector of weights</p>
</td></tr>
</table>

<hr>
<h2 id='vcf2diem'>Convert vcf files to diem format</h2><span id='topic+vcf2diem'></span>

<h3>Description</h3>

<p>Reads vcf files and writes genotypes of the most frequent alleles based on
chromosome positions to diem format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcf2diem(
  SNP,
  filename,
  chunk = 1L,
  requireHomozygous = TRUE,
  ChosenInds = "all"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcf2diem_+3A_snp">SNP</code></td>
<td>
<p>A character vector with a path to the '.vcf' or '.vcf.gz' file, or an <code>vcfR</code>
object. Diploid data are currently supported.</p>
</td></tr>
<tr><td><code id="vcf2diem_+3A_filename">filename</code></td>
<td>
<p>A character vector with a path where to save the converted genotypes.</p>
</td></tr>
<tr><td><code id="vcf2diem_+3A_chunk">chunk</code></td>
<td>
<p>Numeric indicating by how many markers should the result be split into
separate files.</p>
</td></tr>
<tr><td><code id="vcf2diem_+3A_requirehomozygous">requireHomozygous</code></td>
<td>
<p>A logical or numeric vector indicating whether to require the marker
to have at least one or more
homozygous individual(s) for each allele.</p>
</td></tr>
<tr><td><code id="vcf2diem_+3A_choseninds">ChosenInds</code></td>
<td>
<p>A numeric or logical vector of indices of individuals to be included
in the analysis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Importing vcf files larger than 1GB, and those containing multiallelic
genotypes is not recommended. Instead, use the path to the
vcf file in <code>SNP</code>. <code>vcf2diem</code> then reads the file line by line, which is
a preferred solution for data conversion, especially for
very large and complex genomic datasets.
</p>
<p>The number of files <code>vcf2diem</code> creates depends on the <code>chunk</code> argument
and class of the <code>SNP</code> object.
</p>

<ul>
<li><p> Values of <code>chunk &lt; 100</code> are interpreted as the number of files into which to
split data in <code>SNP</code>. For <code>SNP</code> object of class <code>vcfR</code>, the number
of markers per file is calculated from the dimensions of <code>SNP</code>. When class
of <code>SNP</code> is <code>character</code>, the number of markers per file is approximated
from a model with a message. If this number of markers per file is inappropriate
for the expected
output, provide the intended number of markers per file in <code>chunk</code> greater
than 100 (values greater than 10000 are recommended for genomic data).
<code>vcf2diem</code> will scan the whole input specified in the <code>SNP</code> file, creating
additional output files until the last line in <code>SNP</code> is reached.
</p>
</li>
<li><p> Values of <code>chunk &gt;= 100</code> mean that each output file
in diem format will contain <code>chunk</code> number of lines with the data in <code>SNP</code>.
</p>
</li></ul>

<p>When the vcf file contains markers not informative for genome polarisation,
those are removed and listed in a file ending with <em>omittedSites.txt</em> in the
directory specified in the <code>SNP</code> argument or in the working directory.
The omitted loci are identified by their information in the CHROM and POS columns,
and include the QUAL column data. The last column is an integer specifying
the reason why the respective marker was omitted. The reasons why markers are
not informative for genome polarisation using <code>diem</code> are:
</p>

<ol>
<li><p> Marker has fewer than 2 alleles representing substitutions.
</p>
</li>
<li><p> Required homozygous individuals for the 2 most frequent alleles are not present
(optional, controlled
by the <code>requireHomozygous</code> argument).
</p>
</li>
<li><p> The second most frequent allele is found only in one heterozygous individual.
</p>
</li>
<li><p> Dataset is invariant for the most frequent allele.
</p>
</li>
<li><p> Dataset is invariant for the allele listed as the first ALT in the vcf input.
</p>
</li></ol>

<p>The CHROM, POS, and QUAL information for loci included in the converted files are
listed in the file ending with <em>includedSites.txt</em>. Additional columns show which
allele is
encoded as 0 in its homozygous state and which is encoded as 2.
</p>


<h3>Value</h3>

<p>No value returned, called for side effects.
</p>


<h3>Author(s)</h3>

<p>Natalia Martinkova
</p>
<p>Filip Jagos <a href="mailto:521160@mail.muni.cz">521160@mail.muni.cz</a>
</p>
<p>Jachym Postulka <a href="mailto:506194@mail.muni.cz">506194@mail.muni.cz</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# vcf2diem will write files to a working directory or a specified folder
# make sure the working directory or the folder are at a location with write permission
myofile &lt;- system.file("extdata", "myotis.vcf", package = "diemr")

vcf2diem(SNP = myofile, filename = "test1")
vcf2diem(SNP = myofile, filename = "test2", chunk = 3)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
